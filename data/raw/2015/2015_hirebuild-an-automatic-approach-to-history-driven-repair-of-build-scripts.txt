HireBuild: An Automatic Approach to History-Driven Repair
of Build Scripts
Foyzul Hassan
The University of Texas at San Antonio
foyzul.hassan@my.utsa.eduXiaoyin Wang
The University of Texas at San Antonio
xiaoyin.wang@utsa.edu
ABSTRACT
Advancements in software build tools such as Maven reduce build
management effort, but developers still need specialized knowledge
and long time to maintain build scripts and resolve build failures.
More recent build tools such as Gradle give developers greater extent
of customization Ô¨Çexibility, but can be even more difÔ¨Åcult to main-
tain. According to the TravisTorrent dataset of open-source software
continuous integration, 22% of code commits include changes in
build script Ô¨Åles to maintain build scripts or to resolve build failu-res. Automated program repair techniques have great potential to
reduce cost of resolving software failures, but the existing techniques
mostly focus on repairing source code so that they cannot directlyhelp resolving software build failures. To address this limitation,
we propose HireBuild: History-Driven Repair of Build Scripts, the
Ô¨Årst approach to automatic patch generation for build scripts, using
Ô¨Åx patterns automatically generated from existing build script Ô¨Åxes
and recommending Ô¨Åx patterns based on build log similarity. From
TravisTorrent dataset, we extracted 175 build failures and their cor-
responding Ô¨Åxes which revise Gradle build scripts. Among these
175 build failures, we used the 135 earlier build Ô¨Åxes for automatic
Ô¨Åx-pattern generation and the more recent 40 build failures (Ô¨Åxes)for evaluation of our approach. Our experiment shows that our ap-proach can Ô¨Åx 11 of 24 reproducible build failures, or 45% of the
reproducible build failures, within comparable time of manual Ô¨Åxes.
CCS CONCEPTS
‚Ä¢Software and its engineering Automatic programming ;Main-
taining software;
KEYWORDS
Patch Generation, Software Build Scripts, Build Logs
ACM Reference Format:
Foyzul Hassan and Xiaoyin Wang. 2018. HireBuild: An Automatic Approach
to History-Driven Repair of Build Scripts. In ICSE ‚Äô18: ICSE ‚Äô18: 40th
International Conference on Software Engineering , May 27-June 3, 2018,
Gothenburg, Sweden. ACM, New Y ork, NY , USA, 12 pages. https://doi.org/
10.1145/3180155.3180181
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission and/or a
fee. Request permissions from permissions@acm.org.
ICSE ‚Äô18, May 27-June 3, 2018, Gothenburg, Sweden
¬© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5638-1/18/05. . . $15.00
https://doi.org/10.1145/3180155.31801811 INTRODUCTION
Most well maintained software projects use build tools, such as
Ant [ 44], Maven [ 29] and Gradle [ 18] to automate the software
building and testing process. Using these tools, developers can des-
cribe the build process of their projects with build scripts such as
build.xml for Ant, pom.xml for Maven, and build.gradle for
Gradle. With growing software size and functionality, build scripts
can be complicated [ 25] and may need frequent maintenance [ 16].
As software evolves, developers make changes to their code, test
cases, system conÔ¨Åguration, and dependencies, which may all lead to
necessary changes in the build script. Adams et al. [ 4] found strong
co-evolutionary relationship between source code and build script in
their study. Since build scripts need to be synchronized with source
code and the whole build environment, neglecting such changes in
build scripts often leads to build failures.
According to our statistics on TravisTorrent [ 9] dataset on the
continuous integration of open-source software projects, 29% ofcode commits fail to go through a successful build on the integra-tion server. Seo et al. [
35] also mentioned a similar build failure
proportion at Google, which is 37%. These build failures hinders a
project‚Äôs development process so that they need to be Ô¨Åxed as soon
as possible. However, many developers do not have the requiredexpertise to repair build scripts [
34]. Therefore, automatic repair
of build scripts can be desirable for software project managers and
developers.
Automatic generation of software patches is an emerging techni-
que, and has been addressed by multiple previous research efforts.
For example, GenProg [ 14] and PAR [ 20] achieve promising result
for automatic bug Ô¨Åxing. But these works are designed for repai-ring source code written in different programming languages. In
contrast, repairing build scripts has its unique challenges. First, alt-
hough the code similarity assumption (both GenProg and PAR are
taking advantage of this assumption to fetch patch candidates from
other portion of the project or other projects) still holds for build
scripts, build-script repair often involves open knowledge that do not
exist in the current project, such as a newly available version of a
dependency or a build-tool plug-in (See Example 1). Second, unlike
source code bugs, build failures does not have a test suite to facilitatefault localization [
31] and to serve as the Ô¨Åtness function [ 12]. Third,
while different programming languages share similar semantics (so
that code patterns / templates can be adapted and reused), the seman-
tics of build scripts are very different from normal programs, so we
need to re-develop abstract Ô¨Åx templates for build scripts.
On the other hand, there are also special opportunities we can
take advantage of in the repair of build scripts. First, build failures
often provide richer log information than normal test failures, and
the build failure log can often be used to determine the reason and
location of a build failure. Second, build scripts are programs in a
10782018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô18, May 27-June 3, 2018, Gothenburg, Sweden Foyzul Hassan and Xiaoyin Wang
Example 1 Gradle V ersion Dependency Change (puniverse/quasar: 2a45c6f)
task wrapper(type: Wrapper) {
- gradleVersion = ‚Äô1.11‚Äô
+ gradleVersion = ‚Äô2.0‚Äô
}
speciÔ¨Åc domain, so it is possible to develop more speciÔ¨Åc build-Ô¨Åx
templates (e.g., involving more domain-speciÔ¨Åc concepts such as
versions, dependencies instead of general concepts like parameters,
variables). Third, many build failures are related to the build tools
and environments. These failures are not project-speciÔ¨Åc and may
be recursive [ 39,51] in different projects, so Ô¨Åx patterns can often
be used beyond a project‚Äôs boundary.
In this paper, we propose a novel approach, HireBuild, to generate
patches for build scripts. Our insight is that, since many software
projects use the same build tool (e.g., Gradle), similar build failures
will result in similar build logs. Therefore, given a build failure, it
is possible to use its build-failure log to locate similar build failures
from a historical build-Ô¨Åx dataset, and adapt historical Ô¨Åxes for these
new failures. SpeciÔ¨Åcally, our technique consists of the following
three phases. First, for a given build failure, based on build log simi-
larity, we acquire a number of historically Ô¨Åxed build failures that
have the most similar build logs. We refer to these build Ô¨Åxes as seed
Ô¨Åxes. Second, from build-script diffs of the seed Ô¨Åxes, we extract a
number of Ô¨Åx patterns based on our predeÔ¨Åned Ô¨Åx-pattern templates
for build scripts, and rank the patterns by their commonality among
seed Ô¨Åxes. To generate build-script diffs, our approach uses an exis-
ting tool GumTree [ 11] which extracts changes of Java source code,
XML, JavaScript code change. Third, we combine the patterns with
information extracted from the build scripts and logs of the build
failure to generate a ranked list of patches, which are applied to the
build script until the build is successful.
Although following the general generation-validation process
for program repair, our technique is featured with following major
differences to address the challenges and take advantage of the
opportunities in build-script repair.
‚Ä¢Build log analysis. Build logs contain a lot of information
about the location and reason of build failures, and someti-
mes even provide solutions. Our build log analysis parses
build logs and extracts information relevant to build failures.
Furthermore, HireBuild measures the similarity of build logs
based on extracted information.
‚Ä¢Build-Ô¨Åx-pattern templates. There are a number of common
domain-speciÔ¨Åc operations in build scripts, such as including
/ excluding a dependency, updating version numbers, etc.
In HireBuild, we developed build-Ô¨Åx-pattern templates to
involve these common operations speciÔ¨Åc to software build
process.
‚Ä¢Build validation. In build-script repair, without test cases,
we need a new measurement to validate generated patches.
SpeciÔ¨Åcally, we use the successful notiÔ¨Åcation in the build
log and the numbers of compiled source Ô¨Åles to measure build
successfulness.
In our work, we focus on repair of build scripts, so we do not
consider compilation errors or unit-testing failures (although theyalso cause build failures) as they can be easily identiÔ¨Åed based on
build logs and may be automatically repaired with existing bug repair
techniques. Furthermore, we use Gradle (based on Groovy) as our
targeted build tool as it is the most promising Java build tools now,
and recent statistics [ 40] show that more than 50% of top GitHub
apps have already switched to Gradle.
In our evaluation, we extracted 175 reproducible build Ô¨Åxes with
corresponding build logs and build script changes from Travistorrentdataset [
9] on February 8, 2017, the build Ô¨Åxes are from 54 different
projects). To evaluate HireBuild, we use the earlier 135 build Ô¨Åxes
as our training set, and 40 later actual build failures (chronologically
135 earlier and 40 later bug Ô¨Åxes among the 175 regardless of which
project they belong to) as our evaluations set. Among these 40 build
failures, we reproduced 24 build failures in our test environment.
Empirical evaluation results show that our approach is able to ge-
nerate a Ô¨Åx for 11 of the 24 reproduced build script failures which
gives same build output as developers‚Äô original Ô¨Åx. Overall, our work
presented in the paper makes the following contributions.
‚Ä¢A novel approach and tool to automatic patch generation for
build scripts to resolve software build failures.
‚Ä¢A dataset of 175 build Ô¨Åxes which can serve as the basis and
a benchmark for future research.
‚Ä¢An empirical evaluation of our approach on real-world build
Ô¨Åxes.
‚Ä¢An Abstract-Syntax-Tree (AST) diff generation tool for Gradle
build scripts, which potentially have more applications.
The remaining part of this paper is organized as follows. After
presenting a motivation example of how build-script repair is diffe-
rent from source-code repair in Section 2, we describe the design
details of HireBuild in Section 3. Section 4 presents the evaluation
of our approach, while Section 5 presents discussion of important
issues. Related works and Conclusion will be discussed in Section 6
and Section 7, respectively.
2 MOTIV ATING EXAMPLE
In this section, we introduce a real example from our dataset to
illustrate how patch generation of build scripts is different frompatch generation of source code. Example 2 shows a build failureand its corresponding patch where the upper part shows the mostrelevant snippet in the build-failure log and the lower part shows
the code change to resolve the build failure. The project name and
commit id are presented after the example title.
In this build failure, the build-failure log complains that there
are two conÔ¨Çicting versions of slf4j module, and the bug Ô¨Åx is
to add an exclusion of the module in the compilation of Galaxy
component. Although this build Ô¨Åx is just a one-line simple Ô¨Åx, it
illustrates differences between source-code repair and build-script
repair in the following aspects.
First, it is possible to Ô¨Ånd from existing scripts or past Ô¨Åxes that we
need to perform an exclude operation, however, since org.slf4j
never appears in the script (it is transitively referred and will be
downloaded from Gradle central dependency repository at runtime),
the string ‚Äúorg.slf4j‚Äù can be hard to generate, and enumerating all
possible strings is not a feasible solution. The string can actually be
generated by comparing the build-failure log and available modules
in Gradle central dependency repository, but this is very different
1079
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. HireBuild: An Automatic Approach to History-Driven Repair
of Build ScriptsICSE ‚Äô18, May 27-June 3, 2018, Gothenburg, Sweden
Example 2 A Gradle Build Failure and Patch (puniverse/quasar: Build Failure
V ersion:017fa18, Build Fix V ersion:509cd40)
Could not resolve all dependencies for
configuration ':quasar-galaxy:compile'.
> A conflict was found between the following
modules:
- org.slf4j:slf4j-api:1.7.10
- org.slf4j:slf4j-api:1.7.7
________________________________________________compile ("co.paralleluniverse:galaxy:1.4") {
...exclude group: 'com.google.guava', module: '
guava'
+ exclude group: ‚Äúorg.slf4j‚Äù, module: ‚Äô *‚Äô
}
from source-code patching where all variable names to be referred
to are already deÔ¨Åned in the code (in the case when a generated Ô¨Åx
contains a newly declared variable, the variable can have any name
as long as it does not conÔ¨Çict with existing names in the scope).
Second, in build-script repair, we are able to, and need to consider
build-speciÔ¨Åc operations. For example, we should not simply deem
exclude as an arbitrary method name, but needs to involve its
semantics into Ô¨Åx-pattern templates, so that we know a module
name will follow the exclude command.
Third, the build log information is very important in that it not
only provides the name of conÔ¨Çicting dependency, but also provides
the compilation task performed when build failure happens, which
can largely help patch generation tool to locate the build failure and
determine where to apply the patch.
3 APPROACH
The overall goal of HireBuild is to generate build-script patches
that can be used to resolve build failures. HireBuild achieves these
goals with three steps: (1) log similarity calculation to Ô¨Ånd similar
historical build Ô¨Åxes as seed Ô¨Åxes, (2) extraction of build-Ô¨Åx patternsfrom seed Ô¨Åxes, and (3) generation and validation of concrete patches
for build scripts. In the following subsections, we Ô¨Årst introduce
preliminary knowledge on Gradle, and then describe the three steps
of HireBuild with more details in the following subsections.
3.1 Gradle Build Tool
Gradle is a general purpose build management system based on
Groovy and Kotlin [ 2]. Gradle supports the automatic download and
conÔ¨Åguration of dependencies or other libraries. It supports Maven
and Ivy repositories for retrieving these dependencies. This allows
reusing the artifacts of existing build systems.
A Gradle build may consist of one or more build projects. A
build project corresponds to the building of the whole software
project or a submodule. Each build project consists of a number of
tasks. A task represents a piece of work during the building process
of the build project, e.g., compile the source code or generate the
Javadoc. A project using Gradle describes its build process in the
build.gradle Ô¨Åle. This Ô¨Åle is typically located in the root folder
of the project. In this Ô¨Åle, a developer can use a combination ofdeclarative and imperative statements in Groovy or Kotlin code.
This build Ô¨Åle deÔ¨Ånes a project and its tasks, and tasks can also be
created and extended dynamically at runtime. Gradle is a general
purpose build system hence this build Ô¨Åle can perform any task.
3.2 Log Similarity Calculation to Find Similar
Fixes
One of the most important characteristic of build script repair is that,
a lot of software projects use the same build tools (e.g., Gradle),so that build-failure logs of different projects and versions often
share the same format and output similar error messages for similar
build errors. So given a new build failure, HireBuild measures thesimilarity between its build-failure log and the build-failure logsof historical build failures to Ô¨Ånd its most similar build failures in
history dataset.
3.2.1 Build Log Parsing. Gradle build logs typically contain
thousands of lines of text. Gradle prints these lines when performingdifferent tasks such as downloading dependencies, compiling source
Ô¨Åles, and when facing errors during the build. Our point of interest
is the error-and-exception part, which typically accounts for onlya small portion of the build log. So if we use the whole build log
to calculate similarity, the remaining part will bring a lot of noises
to the calculation (e.g., build logs from projects that have similar
dependencies may be considered similar).
Therefore, we use only the error-and-exception part of the build
log to calculate similarity between build logs. An example of the
error-and-exception part in Gradle build log is presented as below.
*What went wrong:
A problem occurred evaluating project ':android-
rest'.
>
Gradle version 1.9 is required. Current version is
1.8. If using the gradle wrapper, try editing
the distributionUrl in /home/travis/build/47
deg/appsly-android-rest/gradle/wrapper/gradle-
wrapper.properties to gradle-1.9-all.zip
To extract the error-and-exception part, HireBuild extracts the
portion of the build log after the error indicating header in Gradle
(e.g., ‚Äú* What went wrong‚Äù). HireBuild extracts only the last error,
as the earlier ones are likely to be errors that are tolerated and are
thus not likely to be the reason for the build failure. Furthermore,
when there are exception stack traces in the error-and-exception
part, HireBuild removes the stack traces for two reasons. First, stack
traces are often very long, so they may dominate the main error
message and bring noise (as mentioned above). Second, stack traces
are often different from project to project so they cannot catch the
commonality between build failures.
3.2.2 T ext Processing. After we extracted the error-and-exception
part from the build-failure log, we perform the following processing
to convert the log text to standard word vector.
‚Ä¢Text Normalization breaks plain text into separate to-
kens and splits camel case words to multiple words.
1080
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô18, May 27-June 3, 2018, Gothenburg, Sweden Foyzul Hassan and Xiaoyin Wang
‚Ä¢Stop word Removal removes common stop words, punc-
tuation marks etc. For better similarity, HireBuild also remo-
ves common words for building process including ‚Äúbuild‚Äù,
‚Äúfailure‚Äù, and ‚Äúerror‚Äù.
‚Ä¢Stemming is the process of reducing inÔ¨Çected words to
their root word. As an example, the word ‚Äúgoes‚Äù derived
from word ‚Äúgo‚Äù. The stemming process converts ‚Äúgoes‚Äù to
its root word ‚Äúgo‚Äù. For stemming we applied popular Porter
stemming algorithm [47].
3.2.3 Similarity Calculation. With the generated word vec-
tor from the error-and-exception part of the build-failure logs, weuse the standard Term Frequency‚ÄìInverse Document Frequency
(TF‚ÄìIDF) [ 33] formula to weight all the words. Finally, we calculate
cosine similarity between the log of build failure to be resolved and
all build-failure logs of historical build Ô¨Åxes in our training set, and
fetch the most similar historical Ô¨Åxes. HireBuild uses the Ô¨Åve most
similar historical Ô¨Åxes as seed Ô¨Åxes to generate build-Ô¨Åx patterns.
3.3 Generation of Build-Fix Patterns
To generate build-Ô¨Åx patterns, for each seed Ô¨Åx, HireBuild Ô¨Årst cal-
culates the code difference between the versions before and afterthe Ô¨Åx. The code difference consists of a list of elementary revi-sions including insertions, deletions and updates. Then, for each
revision, HireBuild generalizes it to hierarchical pattern and merges
similar patterns. Finally, HireBuild Ô¨Çattens the hierarchical pattern
to generate a set of build-Ô¨Åx patterns, and ranks these patterns.
3.3.1 Build-Script Differencing. In this phase, for each seed
Ô¨Åx, we extract Gradle build script commits before and after Ô¨Åx, and
convert the script code to AST representation. Gradle build uses
Groovy [ 2]-based scripting language extended with domain-speciÔ¨Åc
features to describe software build process. With support of the
Groovy parser, AST representation of script code can be generated.
Our goal is to generate an abstract representation of code changes
between two commits. Having build script content represented as an
AST, we can apply tree difference algorithms, such as ChangeDis-
tiller [ 13] or GumTree [ 11], to extract AST changes with sufÔ¨Åcient
abstraction. In particular, HireBuild uses GumTree to extract chan-
ges between two Gradle build scripts. GumTree generates a diffbetween two ASTs with list of actions which can be insertion, de-letion, update, and movement of individual AST nodes to transfer
from a source version to a destination version. However, GumTree
generates a list of AST revisions without node type information,
so we revise GumTree to include the information. Furthermore, Hi-
reBuild also records the ancestor AST nodes of the changed AST
subtree. Such ancestor AST nodes are typically the enclosing expres-
sion, statement, block, and task of the change, and they are helpful
for merging different seed Ô¨Åxes for more general patterns, and for
determining where the generated patches should be applied. As men-
tioned earlier, in Gradle scripts, a task is a piece of work which a
build performs, and a script block is a method call with parameters
as closure [ 3], so keeping such information helps to apply patches
to a certain block or task. Example 3 shows an exemplar output of
HireBuild‚Äôs build-script differencing module, in which the operation,
node type, and ancestor nodes are extracted. Note that HireBuild
extracts only one level of parent expression to avoid potential noises.As shown in the example, the task/block name can be empty if the
Ô¨Åx is not in any tasks/blocks.
Example 3 Build Script Differencing Output (BuildCraft/BuildCraft: 98f7196)
1<?xml version="1.0" encoding="UTF-8" standalone="no"?>
2<patch>
3<lineno id="30"><exp id="0">
4 <operation>Update</operation>
5 <nodetype>ConstantExpression</nodetype>
6 <nodeexp>1.7.2-10.12.1.1079</nodeexp>
7 <nodeparenttype>BinaryExpression</nodeparenttype>
8 <nodeparentexp>(version = 1.7.2-10.12.1.1079)
9 </nodeparentexp>
10 <nodeblockname>minecraft</nodeblockname>
11 <nodetaskname>< / nodetaskname></exp>
12 </lineno>
13</patch>
3.3.2 Hierarchical Build-Fix Patterns. In some rare cases
we can directly use the concrete build-Ô¨Åx pattern to generate a
correct patch. Example 4 provides such a patch from Project:
nohana/Laevatein:a2aaca4 . There exists an exactly same build
Ô¨Åx in the training set (from a different project).
Example 4 Training Project Fix (journeyapps/zxing-android-embedded: 12cfa60)
+ lintOptions {
+ abortOnError false
+}
However, in more common scenarios, code diffs generated from
seed Ô¨Åxes are too speciÔ¨Åc and cannot be directly applied as patches.
Consider Examples 5 and 6, changes made in different project are
similar, but if we consider concrete change of Example 5 as ‚ÄúUpdate
1.7.2-10.12.1.1079‚Äù then this change can hardly be applied to other
scripts. Therefore, we need to infer more general build-Ô¨Åx patterns
from them.
Example 5 Gradle Build Fix (BuildCraft/BuildCraft: 98f7196)
- version = ‚Äú1.7.2-10.12.1.1079‚Äù
+ version = ‚Äú1.7.2-10.12.2.1121‚Äù
Example 6 Gradle Build Fix (F orgeEssentials/F orgeEssentialsMain:fcbb468)
-version = ‚Äú1.4.0-beta7‚Äù
+version = ‚Äú1.4.0-beta8‚Äù
SpeciÔ¨Åcally, HireBuild infers a hierarchy of build-Ô¨Åx patterns
from each seed Ô¨Åx by generalizing each element in the differencing
output of the seed Ô¨Åx. For example, the hierarchies generalized from
Examples 5 and 6 are shown in Figure 1. From the Ô¨Ågure, we can
see that, HireBuild does not generalize operations and the node type
of expression that are involved in the Ô¨Åx (i.e., ConstantExpression),
because a change on those typically indicates a totally different Ô¨Åx.
HireBuild also does not include the task and block information in
1081
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. HireBuild: An Automatic Approach to History-Driven Repair
of Build ScriptsICSE ‚Äô18, May 27-June 3, 2018, Gothenburg, Sweden
	

 









Figure 1: Hierarchies of Build-Fix Patterns

	
 		


 
	


Figure 2: Merged Hierarchies
the pattern as they are typically not a part of the Ô¨Åx. Given a hier-
archy, by choosing whether and which leaf node to be generalized,
we can generate patches at different abstract levels. For example,
if we generalize the parent expression from version=1.7.2...
toParentExp: any , we generate a pattern that updates a value
1.7.2... without considering its parent. If we generalize both the
parent expression and the node expression, we generate a pattern
that update any constants in the script. Note that HireBuild does not
consider the cases where the node expression is generalized but the
parent expression is not, as such a pattern can never match real code.
3.3.3 Merging Build-Fix Patterns. After generating hierar-
chies of build-Ô¨Åx patterns, HireBuild Ô¨Årst tries to merge similar
hierarchies. For example, the two hierarchies in Figure 1 will be
merged to a hierarchy shown in Figure 2. HireBuild merges only a
pair of hierarchies with the same operation and node type (Update
and Constant Expression in this case). During the merging process,
HireBuild merges hierarchies recursively from their root node, and
merges nodes with exactly the same value. If two nodes to be merged
have different constant values, HireBuild does not merge them and
their children nodes. If two nodes to be merged have different expres-
sion values, HireBuild extracts their corresponding AST tree, and
merges the AST tree so that the common part of the expressions can
be extracted. In Figure 2, since the expressions version=1.7.2...
andversion=1.4.0... share the same child nodes version and
=, a node version= *is added. Note that more than two hierarchies
can be merged in the same way if they share the same operation and
node type.
3.3.4 Ranking of Build-Fix Patterns. After hierarchies are
merged, HireBuild calculates frequencies of build-Ô¨Åx patterns amongseed Ô¨Åxes. If a hierarchy cannot be merged with other hierarchies, all
the build-Ô¨Åx patterns in it have a frequency 1 among seed Ô¨Åxes, as
they are speciÔ¨Åc to the seed Ô¨Åx they are from. In a merged hierarchy,
the frequency of all its patterns is always the number of originalhierarchies being merged. After calculating the frequencies of all
build-Ô¨Åx patterns from hierarchies, HireBuild ranks build-Ô¨Åx patterns
according to the frequency. For each build-Ô¨Åx pattern Œ±, we counted
ntŒ±:Œ±‚Äôs frequency among seed Ô¨Åxes. Then probability of Œ±is as
follows.PŒ±=ntŒ±
N
where N is the total occurrences of build-Ô¨Åx patterns. Then, we
rank the Ô¨Åx patterns based on the probability so that we use higher
ranked build-Ô¨Åx patterns Ô¨Årst to generate concrete patches. When
there are ties between pattern AandB,i fAis a generalization
ofB(Ais generated by generalizing one or more leaf nodes of
B), we rank BoverA. The reason is that, when a build-Ô¨Åx pattern
is generalized, it can lead to a larger number of concrete patches
(e.g., update gradleVersion from any existing version to anot-
her existing version), so HireBuild needs to perform more build
trials to exhaust all possibilities. As an example, all build-Ô¨Åx pat-terns from the hierarchy in Figure 2 have the same popularity, but
the most concrete pattern: update constant expression with
parent expression version= *will be ranked highest.
If there is no generalization relation between patterns, HireBuild
ranks higher the build-Ô¨Åx patterns from the seed Ô¨Åx with higher
ranking (the seed Ô¨Åx whose build failure log is more similar to that
of the build failure to be Ô¨Åxed).
3.4 Generation and Validation of Concrete
Patches
Before generation of concrete patches, we need to Ô¨Årst decide which
.gradle Ô¨Åle to apply the Ô¨Åx. HireBuild uses a simple heuristic,
which always choose the Ô¨Årst .gradle Ô¨Åle mentioned in the er-
ror part extracted from the build failure log. If no .gradle Ô¨Åle is
mentioned, HireBuild uses the build.gradle Ô¨Åle in the root folder.
Given a build-Ô¨Åx pattern, and the buggy Gradle build script as
input, to generate concrete patches, HireBuild Ô¨Årst parses the buggy
Gradle build script to AST, and then HireBuild tries to Ô¨Ånd where a
patch should be applied.
For updates and deletions, HireBuild matches the build-Ô¨Åx pat-
terns to nodes in the AST. For example, the build-Ô¨Åx pattern update
constant expression with parent expression version
=*can be mapped to an AST node of type ConstantExpression
and its parent expression node has a value matching version= *.
When a build-Ô¨Åx pattern can be mapped to multiple AST nodes (very
common for general build-Ô¨Åx patterns), and HireBuild generates pa-
tches for all the mapped AST nodes. The only exception is when
a build-Ô¨Åx pattern is mapped to multiple AST nodes in one block.
In build scripts, within the same block, the sequence of commands
typically does not matter, so HireBuild retains only the Ô¨Årst mapped
node in the block to reduce duplication.
For insertions, it is impossible to map a build-Ô¨Åx pattern to an
existing AST node, so HireBuild matches the block and task names
of the build-Ô¨Åx patterns to the buggy build script. When a build-Ô¨Åx
pattern is generated from a hierarchy merging multiple seed-Ô¨Åxes,
HireBuild considers the task and block names of all seed-Ô¨Åxes. If a
task or block name in the buggy script is matched, HireBuild inserts
the build patch at the end of the task or block.
After HireBuild determines which build-Ô¨Åx pattern to apply and
where to apply, we Ô¨Ånally need to concentrate on the abstract parts of
the build-Ô¨Åx pattern and determine the values of the abstract nodes
(e.g., value of ‚Äú*‚Äù in the pattern update constant expression
with parent expression version= *). The most commonly
1082
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô18, May 27-June 3, 2018, Gothenburg, Sweden Foyzul Hassan and Xiaoyin Wang
used values in build scripts are (1) identiÔ¨Åers including task names,
block names, variable names, etc.; (2) names of Gradle plug-ins
and third-party tools / libraries; (3) Ô¨Åle paths within the project;and (4) version numbers. HireBuild Ô¨Årst determines which typethe value to added belongs to, based on the concrete values and
AST nodes in the seed Ô¨Åxes leading to the build-Ô¨Åx pattern to be
applied. HireBuild identiÔ¨Åes version number and Ô¨Åle paths basedon regression expression matching (e.g., HireBuild can determine
that1.4.0-beta8 is a version number), and task / block / variable
names by scanning the AST containing the seed Ô¨Åx. Other typesof values including dependencies / plug-in names, and Ô¨Åle paths
are all speciÔ¨Åc to certain AST nodes so that they can be easily
identiÔ¨Åed. Once the value type is determined, HireBuild generates
values differently for different types as follows.
‚Ä¢IdentiÔ¨Åers: HireBuild considers identiÔ¨Åers in the concrete
seed Ô¨Åxes, as well as all available identiÔ¨Åers at the Ô¨Åx location.
‚Ä¢Names of plug-ins / libraries / tools: HireBuild considers
names appearing in the concrete seed Ô¨Åxes, in the build failure
log, and in the buggy build script.
‚Ä¢File paths: HireBuild considers paths appearing in the con-
crete seed Ô¨Åxes, in the build failure log, and in the buggy
build script.
‚Ä¢V ersion numbers: HireBuild Ô¨Årst locates the possible tools /
libraries / plug-ins the version number is related to. This is
done by searching for all occurrences of the version variable
or constant in the AST of the buggy script. Once the tool /library / plug-in is determined, HireBuild searches Gradle
central repository for all existing version numbers.
After the build-Ô¨Åx pattern, the location, and the concrete value
are determined, a concrete patch is generated and added to the list
of patches.
3.4.1 Ranking of Generated Patches. The previous steps
generate a large number of patch candidates, so ranking of themis necessary to locate the actual Ô¨Åx as soon as possible. HireBuild
ranks concrete patches with the following heuristics. Basically, we
give higher priority to the patches which involve values or scopes
more similar to the buggy script and the build-failure log.
(1) Patches generated from higher ranked build-Ô¨Åx patterns are
ranked higher than those generated from lower ranked build-
Ô¨Åx patterns. The initial priority value of a patch is the proba-
bility value of its build-Ô¨Åx pattern.
(2) If a patch pis to be applied to a location L, andpis generated
from a build-Ô¨Åx pattern hierarchy merged from seed Ô¨Åxes A1,
...,Ai, ...,An.I fLresides in a task / block whose name is the
same as the task / block name in any Ai, HireBuild adds p‚Äôs
priority value by 1.0.
(3) If a patch involves a value (any one of the four types des-
cribed in Section 3.4) which appears in the build-failure log.
HireBuild adds the priority value of the patch by 1.0.
(4) Rank all patches with updated priority values.
Note that, since the initial priority value is from 0 to 1, in the
heuristics, we always add the priority value by 1.0 when certaincondition meets, so that it go beyond all the other patches which
do not satisfy the condition, no matter how high the initial priority
value is.3.4.2 Patch Application. After the ranked list of patches are
generated, HireBuild applies the patches one by one until a timeout
threshold is reached or the failure is Ô¨Åxed. HireBuild determines the
failure is Ô¨Åxed if (1) the build process returns 0 and the build log
shows build success, and (2) all source Ô¨Åles that are compiled in the
latest successfully built version are compiled if they are not deleted
in between. We add the second criterion so that HireBuild can avoid
trivial incorrect Ô¨Åxes such as changing the task to be performed from
compile to clean up and to eliminate fake patches. HireBuild stops
applying patches after it reaches the Ô¨Årst patch passing the patch
validation. Though there may be multiple valid patches, we apply
only the Ô¨Årst one that passes the validation.
HireBuild generally focuses on one line Ô¨Åxes as most other soft-
ware repair tool does. But it also includes a technique to generate
multi-line patches if the failure is not Ô¨Åxed until all single line pat-
ches are applied. Multi-line patches can be viewed as a combination
of single line patches, but it is impossible to exhaust the whole com-
bination space. Example 7 shows a bug Ô¨Åx, which can be viewed as
the combination of three one-line patches (two deletions and one in-
sertion). To reduce the search space of patch combination, HireBuild
considers only the combination that occurs in original seed Ô¨Åxes.
Consider two one-line patches AandB, which are generated from
hierarchies HA andHB . HireBuild considers the combination ( A,B)
only ifHA andHB can be generalized from a same seed Ô¨Åx. After
the Ô¨Åltering, HireBuild ranks patch combinations by the priority sum
of the patches in the combination.
Example 7 Template with abstract node Ô¨Åx (passy/Android-
DirectoryChooser:27c194f)
dependencies {
...
-testCompile
files(‚Äôtestlibs/robolectric -2.4-SNAPS
HOT-jar-with -dependencies.jar‚Äô)
-android TestProvided
files(‚Äôtestlibs/robolectric -2.4-SNAPS
HOT-jar-with -dependencies.jar‚Äô)
+android TestCompile
‚Äôorg.robolectric:robolectric:2.3+‚Äô
...}
4 EMPIRICAL EV ALUATION
In this section, we describe our dataset construction in Section 4.1
and our experimental settings in Section 4.2, followed by research
questions in Section 4.3 and experiment results in Section 4.4. Fi-
nally, we discuss the threats to validity in Section 4.5.
4.1 Dataset
We evaluate our approach to build-script repair on a dataset of build
Ô¨Åxes extracted from the TravisTorrent dataset [ 9] snapshot at Feb-
ruary 8, 2017. The tool and bug set used in our evaluation are all
available at our website1. TravisTorrent provides easy-to-use Travis
1HireBuild Dataset and Tools: https://sites.google.com/site/buildÔ¨Åx2017/
1083
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. HireBuild: An Automatic Approach to History-Driven Repair
of Build ScriptsICSE ‚Äô18, May 27-June 3, 2018, Gothenburg, Sweden
Table 1: Dataset Summary
Type Count
# Total Number of Projects 54
# Maximum Number of Fix From Single Project 25
# Minimum Number of Fix From Single Project 1
# Average Number of Fix Per Project 3.2
# Total Number of Fix 175
# Training Fix Size 135
# Testing Fix Size 40
# Reproducible Build Failure Size for Testing 24
CI build data to the masses through its open database. Though it
provides large amount of build logs and relevant data, our point
of interest is build status transition from error or fail status to pass
status with changes in build scripts. From the version history of all
projects in the TravisTorrent dataset, we identiÔ¨Åed as build Ô¨Åxes the
code commits that satisfy: (1) the build status of their immediate
previous version is fail / error; (2) the build status of the committed
version is success; and (3) they contain only changes in gradle build
scripts. Since HireBuild focuses on build script errors, we use code
commits with only build-script changes so that we can Ô¨Ålter out unit
test failures and compilation failures. Our dataset may miss the more
complicated build Ô¨Åxes that involve a combination of source-code
changes and build-script changes, or a combination of build-script
changes from different build tools (e.g., Gradle and Maven). Hire-
Build currently does not support the generation of such build Ô¨Åxes
cross programming languages. Actually, Ô¨Åxing such bugs are very
challenging and is not supported by any existing software repair
tools.
From the commit history of all projects, we extracted a dataset
of 175 build Ô¨Åxes. More detailed information about our data set is
presented in Table 1. We can see that these Ô¨Åxes are from 54 different
projects, with maximal number of Ô¨Åxes in one project to be 25.
We ordered the build Ô¨Åxes according to the code commit time
stamp, and use 135 (75%) earlier build Ô¨Åxes as the training set and
the rest 40 build Ô¨Åxes (25%) as the evaluation set. Therefore, all
the build Ô¨Åxes in our evaluation set are chronically later thanthe build Ô¨Åxes in our training set.
Note that we combine all the
projects in both training sets and evaluation sets, so our evaluation is
cross-project in nature.
Among these 40 build Ô¨Åxes for evaluation, we successfully repro-
duced 24 build failures. The remaining 16 build failures cannot be
reproduced in our test environment for the following three reasons:
(1) a missing library or build conÔ¨Åguration Ô¨Åle was originally mis-
sing from the central repository and caused the build failure, but theyare added later; (2) a Ô¨Çawed third-party library or build conÔ¨Åguration
caused the build failure, but the Ô¨Çaws are Ô¨Åxed and Ô¨Çawed releases
are no longer available on the Internet; and (3) the failure can bereproduced only with speciÔ¨Åc build commands and options whichare not recorded in the repository. For case (3), we were able toreproduce some bugs by trying common build command options.
We also contacted the TravisCI people about the availability of such
commands / options, but they could not provide them to us. For
training set, we did not reproduce build failures since we trust the
software version history in TravisTorrent that human made changes
resolved the build failures and we extracted only seed Ô¨Åxes from
training set.Table 2: Project-wise Build Failure / Fix List
Project Name #Failures #Correctly Fixed
aol/micro-server 2 1
BuildCraft/BuildCraft 2 0
exteso/alf.io 1 1
facebook/rebound 1 1
griffon/griffon 1 0
/btrace 1 1
jMonkeyEngine/jmonkeyengine 2 0
jphp-compiler/jphp 1 0
NetÔ¨Çix/Hystrix 2 0
puniverse/quasar 6 2
RS485/LogisticsPipes 5 5
Total 24 11
4.2 Experiment Settings
TravisTorrent datset provides Travis CI build analysis result as SQL
dump and CSV format. We use SQL dump Ô¨Åle for our experiment.
We use a computer with 2.4 GHz Intel Core i7 CPU with 16GB of
Memory, and Ubuntu 14.10 L TS operating system. We use MySQL
Server 5.7 to store build Ô¨Åx changes. In our evaluation, we use 600
minutes as the time out threshold for HireBuild.
4.3 Research Questions
In our research experiment, we seek to answer following research
questions.
‚Ä¢RQ1 How many reproducible build failures in the evaluation
set can HireBuild Ô¨Åx?
‚Ä¢RQ2 What are the amount of time HireBuild spends to Ô¨Åx a
build failure?
‚Ä¢RQ3 What are the sizes of build Ô¨Åxes that can be successfully
Ô¨Åxed and that cannot be Ô¨Åxed?
‚Ä¢RQ4 What are the reasons behind unsuccessful build-script
repair?
4.4 Results
RQ1: Number of successfully Ô¨Åxed build failures. In our evalua-
tion, we consider a Ô¨Åx to be correct only if there is no build failure
message in build log after applying patch, and the build result (i.e.,
all compiled classes) are exactly the same as those generated by the
manual Ô¨Åx. Among 24 reproducible build failures in the test set, we
can generate the correct Ô¨Åx for 11 of them. Table 2 shows the list
of projects that are used for testing. Columns 2 and 3 represent the
number of build failures and the number of those Ô¨Åxed successfully.
Figure 3 shows the breakdown of successful build Ô¨Åxes according
the type of changes. With HireBuild, we can correctly generate 3
Ô¨Åxes about gradle option changes, 3 Ô¨Åxes about property changes, 2
Ô¨Åxes about dependency changes and external-tool option changes,
respectively, and 1 Ô¨Åx about removing incompatible statements.
Example 8 shows a build Ô¨Åx that is correctly generated by HireBuild
falling in the category of external-tool option changes. The build
failure is caused by adding a new option which is compatible only
with Java 8. So the Ô¨Åx is to add an if condition to check the Java
version. Note that this Ô¨Åx involves applying the combination of two
insertion patches, but HireBuild still can Ô¨Åx it as there are a seed Ô¨Åx
that contains both build-Ô¨Åx patterns.
1084
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô18, May 27-June 3, 2018, Gothenburg, Sweden Foyzul Hassan and Xiaoyin Wang
Figure 3: Breakdown of Build Fixes
Example 8 A Build Fix Correctly Generated By HireBuild (puniverse/-
quasar:33bb265)
+if(JavaVersion.current().isJava8Compatible()){
+tasks.withType(Javadoc) {
options.addStringOption('Xdoclint:none', '-
quiet')
+}
+}
Figure 4: Patch List Sizes
RQ2: Time Spent on Fixes Time spent on Ô¨Åxes is very important
for build failures as they need to be Ô¨Åxed timely. The size of patch
list has impact on automatic build script repair. If patch list size is
too large, it will take large time span to generate Ô¨Åx sequence. Wecompare patch list size of build failures we can correctly Ô¨Åx and
patch list size of build failures we cannot correctly Ô¨Åx, and present
the result in Figure 4. From the Ô¨Ågure, we can see that for Ô¨Åxed
build failures, the patch list has minimum size of 68 and maximum
size of 2,245, while median is 486. For non-Ô¨Åxed build failures,patch list minimum, median and maximum are 8, 223 and 1,266
respectively, which are lower than Ô¨Åxable build failure‚Äôs patch list.
The reason behind this result is that for non-Ô¨Åxable build failure,
HireBuild cannot Ô¨Ånd similar build Ô¨Åxes in the training set, and thus
the generated build-Ô¨Åx patterns cannot be easily mapped to AST
nodes in buggy scripts.
For the 11 Ô¨Åxed build failures, we compared in Figure 5 the time
HireBuild spent on automatic Ô¨Åxing build failures with the manual
Ô¨Åx time of the build failures in the commit history. Manual Ô¨Åx time
comes from commit information and we use the time difference
between build failure inducing commit and build failure Ô¨Åx commit
as the manual Ô¨Åx time. From Figure 5, we can see that build script
Ô¨Åx generated by our approach takes minimum 2 minutes, maximum
305 minutes and median value of 44 minutes. While human Ô¨Åx takesminimum less than one minute, maximum 5,281 minutes and median
42 minutes. We can see that for the Ô¨Åxable build failures, HireBuild
Ô¨Åxed them with time comparable to manual Ô¨Åxes.
Figure 5: Amount of Time Required for Build Script Fix
Figure 6: Actual Fix Sizes
Table 3: Cause of unsuccessful patch generation
Fix Type #of Failures
Project speciÔ¨Åc change adaption 2(15%)
No matching patterns 6(46%)
Dependency resolution failures 3(23%)
Multi-location Ô¨Åxes 2(15%)
RQ3: Actual Fix Size. Patch size has impact on automatic pro-
gram repair. According to Le et al. [ 21], bugs with over six lines
of Ô¨Åx are difÔ¨Åcult for automatic repair. In our dataset we have notperformed any Ô¨Åltering based on actual Ô¨Åx size. But during resultanalysis, we performed statistical analysis to Ô¨Ånd out the sizes ofbuild-Ô¨Åx patches, and the difference in size between the patchesour approach can correctly generate and the patches our approachcannot. According to Figure 6, Ô¨Åxed build script failures contain
minimum one, maximum two and median one. Actually 9 of the
Ô¨Åxes contain only 1 statement change, and 2 of the Ô¨Åxes contain
only 2 statement changes. For non-Ô¨Åxed Gradle build script failures
minimum change size is one, while maximum and median change
size is 11 and 1 respectively. Therefore, our approach mainly works
in the cases where the number of statement changes is small (1 or
2), which is similar to other automatic repair tools.
RQ4: Failing reasons for the rest 13 build failures. For 54.16%
of evaluated build failures, our approach cannot generate build Ô¨Åx.
So, we performed manual analysis to Ô¨Ånd out why our approach
fails. We check whether the reason is related to generation of version
numbers, dependency names, etc. Then we categorize these failure
reasons to four major groups: (1) Project speciÔ¨Åc change adaption,
(2) Non-matching patterns, (3) Dependency resolution failures, and
(4) Multi-location Ô¨Åxes, as shown in Table 3.
Project speciÔ¨Åc change adaption indicates those changes that
are dependent on project structure, Ô¨Åle path etc. As build scriptmanages build and its conÔ¨Åguration, so there are project speciÔ¨Åc
change issues and with our approach we cannot adapt the build-Ô¨Åx
patterns. Example 9 shows such a build Ô¨Åx where it uses a speciÔ¨Åc
path in build script.
Non-matching patterns indicates that our automatic patterns ge-
neration failed to provide required pattern that can resolve the build
1085
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. HireBuild: An Automatic Approach to History-Driven Repair
of Build ScriptsICSE ‚Äô18, May 27-June 3, 2018, Gothenburg, Sweden
Example 9 Project speciÔ¨Åc change (NetÔ¨Çix/Hystrix:6600947)
+if(dep.moduleName ==‚Äôser vlet -api‚Äô ){
+it.artifactId[0].text() ==dep.moduleName
&&
+asNode().dependencies[0].dependency.find{
+...
+}}
+}
failure. HireBuild could not generate appropriate patterns for 6 failu-
res which account 46% of failures. This may be due to limited size
of training data and insufÔ¨Åcient number of available build Ô¨Åxes that
we used for template generation.
Dependency resolution failures happens for some project when
HireBuild did not Ô¨Ånd an actual dependency from central repository
based on build log error. Even if we Ô¨Ånd dependency based on miss-
compiled classes, that may not match with actual Ô¨Åxing. Example
10 shows such a dependency update where our approach failed to
generate the dependency name.
Example 10 Dependency resolve Issue (BuildCraft/BuildCraft:12f4f06)
-mappings =‚Äôsnaps hot_20160214‚Äô
+mappings =‚Äôsta ble_22‚Äô
Multi-Location Fixes happen when we need to apply multiple
patches to Ô¨Åx a single build failure. HireBuild considers only limited
combinations of patches as introduced in Section 3.4.2. Example 11
shows such a case where our patch generation technique generated
the two ‚Äúexclude‚Äù statements in two different patches. But this buildfailure is Ô¨Åxed only when we apply both ‚Äúexclude‚Äù statement change
simultaneously.
Example 11 Dependency resolve Issue (joansmith/quasar:64e42ef)
-jvmArgs ‚Äô-Xboot clas spathp:
${Sy stem.getProperty(√ºser.home ¬®)}jsr166.jar‚Äô
-testCompile ‚Äôorg.testng:testng:6.9.6‚Äô
+tes tCompile(‚Äôorg.testng:testng:6.9.6‚Äô) {
+exclude group:‚Äôcom.google.guava‚Äô,
module:‚Äô *‚Äô
+exclude group:‚Äôjunit‚Äô, module:‚Äô *‚Äô
+}
4.5 Threats of Validity
There are three major threats to the internal validity of our evaluation.
First, there can be mistakes in our data processing and bugs in the
implementation of HireBuild. To reduce this threat, we carefullydouble checked all the code and data in our evaluation. Second,the successful Ô¨Åxes generated by HireBuild may still have subtledifferences with the manual Ô¨Åxes. Furthermore, the manual Ô¨Åxes
that we use as the ground truth may in itself has Ô¨Çaws. To reduce
this threat, we used a strict criterion for correct Ô¨Åxes. We need the
automatically generated Ô¨Åx to generate exactly the same build results
as those generated by the manual Ô¨Åx. Third, the manual Ô¨Åxing timecollected in the commit history may be longer the actual Ô¨Åxing time
as developers may choose to wait and not to Ô¨Åx the bug. We agree
that this can happen but we believe the difference is not large as
developers typically want to Ô¨Åx failure as soon as possible so that it
does not affect other developers.
The major threat to the external validity of our evaluation is that
we use a evaluation set with limited number of reproducible bug Ô¨Åxes.
Furthermore, our evaluation set contains only build Ô¨Åxes where only
Gradle build scripts are changed. So it is possible that our conclusion
is limited to the data set, Gradle-script Ô¨Åxes, or Gradle-script-only
Ô¨Åxes. Figure 3 shows that our evaluation set already covers a large
range of change types, and we plan to expand our evaluation setto more build failures and reproduce more bugs as TravisTorrent
data set grows overtime. Gradle is the most widely adopted building
system now, and its market share is still increasing. We also dida statistics on the number of build Ô¨Åxes with both Gradle-script
changes and other Ô¨Åle-changes and found 263 of them. Compared
with 175 build Ô¨Åxes in our dataset, Gradle-script-only Ô¨Åxes accounts
for a large portion of build script Ô¨Åxes for Gradle systems.
5 DISCUSSION
Patch Validation and Build Correctness. In the patch validation
stage, HireBuild deems a patch as valid if applying it results in asuccessful build message, and all the Ô¨Åles that are compiled in the
most recent successful build are still compiled as long as they are not
deleted. Our evaluation uses a more strict constraint which requires
the compiled Ô¨Åles in the automatically Ô¨Åxed build to be exactly the
same as those in the manually Ô¨Åxed build. The evaluation results
show that our patch validation strategy is very effective because in all
11 Ô¨Åxed builds in our evaluation, the Ô¨Årst patches passing validation
are conÔ¨Årmed to be correct patches. The reason is that, based on
the same compiler, once a source Ô¨Åle is successfully compiled, it is
unlikely to be compiled in different ways. The only exception is that
a library-class reference is resolved to a wrong class when a wrong
dependency is added. Furthermore, to pass compilation, the wrong
class must accidentally have compatible behaviors (e.g., methods)
with the correct class. Such coincidence is not likely to happen.
Build Environment. Build environment deÔ¨Ånes the environment
of a system that compiles source code, links module and generates
assembles. From developer‚Äôs point of view, they install all requi-
red dependencies like Java, GCC and other frameworks. But when
projects are built in different environment then build problem canbe generated. For example, if certain project has dependency on
Java 1.8 then building the project in build environment with Java
1.7 might generate build failure. This a challenge for build automa-
tion as well as automatic build repair. During software evaluation,developers change environment dependency based on functional
requirements or efÔ¨Åciency. With version changes, developers build
the software having those changed dependencies. But for build script
repair, if we change the version of any dependency and keep the
build environment as it was before, then the Ô¨Åx might not resolve
build failures. For Android projects environment, this issue creates
greater impact as in most Gradle build script it mentions SDK ver-
sion, build tool version etc. inside build script. As a result, build
script version dependency and build environment should be synced
to avoid build breakage.
1086
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô18, May 27-June 3, 2018, Gothenburg, Sweden Foyzul Hassan and Xiaoyin Wang
6 RELATED WORK
6.1 Automatic Program Repair
Automatic program repair is gaining research interest in the soft-
ware engineering community with the focus to reduce bug Ô¨Åxing
time and effort. Recent advancements in program analysis, synthe-
sis, and machine learning have made automatic program repair apromising direction. Early software repair techniques are mainly
speciÔ¨Åc to predeÔ¨Åned problems [ 19,37,45,50]. Le Goues et al. [ 14]
GenProg which is one of the earliest and promising search basedautomatic patch generation technique based on genetic program-ming. Patch generated by this approach follows random mutation
and use test case for the veriÔ¨Åcation of the patch. Later in 2012, aut-
hors optimized their mutation operation and performed systematic
evaluation 105 real bugs [ 22]. RSRepair [ 32] performs similar patch
generation based on random search. D. Kim et al. [ 20] proposed an
approach to automatic software patching by learning from common
bug-Ô¨Åxing patterns in software version history, and later studied
the usefulness of generated patches [ 43]. AE [ 46] uses determinis-
tic search technique to generate patch. Pattern-based Automatic
Program Repair(P AR) [ 20] uses manually generated templates lear-
ned from human written patches to prepare a patch. PAR also used
randomized technique to apply the Ô¨Åx patches. Nguyen et al. [ 30]
proposed SemFix, which applied software synthesis to automaticprogram repair, by checking whether a suspicious statement canbe re-written to make a failed test case pass. Le et al. [
21] mines
bug Ô¨Åx patterns for automatic template generation and uses version
control history to perform mutation. Prophet [ 24] proposed a pro-
babilistic model learned from human written patched to generatenew patch. The above mentioned approaches infers a hypothesisthat new patch can be constructed based on existing source. Thishypothesis also validated by Barr et al.[
8] that 43 percent changes
can be generated from existing code. With this hypothesis, we propo-
sed Ô¨Årst approach for automatic build failure patch generation. Tan
and Roychoudhury proposed ReliÔ¨Åx [ 42], a technique that taking
advantage of version history information to repair regression faults.
Smith et al. [ 38] reported an empirical study on the overÔ¨Åtting to test
suites of automatically generated software patches. Most recently,
Long and Rinard proposed SPR [ 23], which generates patching rules
with condition synthesis, and searches for the valid patch in the
patch candidates generated with the rules. Angelix [ 28] and Direct-
Fix [ 27] both use semantics-based approach for patch generation.
To Ô¨Åx buggy conditions, Nopol [ 49] proposes test-suite based repair
technique using SatisÔ¨Åability Modulo Theory(SMT). Although our
fundamental goal is same, but our approach is different than others
in several aspects: 1) Our approach is applicable for build scripts, 2)
We generate automatic Ô¨Åx template using build failure log similarity,
3) With abstract Ô¨Åx template matching we can generate Ô¨Åx candidate
lists with reasonable size.
6.2 Analysis of Build ConÔ¨Åguration Files
Analysis of build conÔ¨Åguration Ô¨Åles is growing as an important as-
pect for software engineering research such as dependency analysis
for path expression, migration of build conÔ¨Åguration Ô¨Åle and empiri-
cal studies. On dependency analysis, Gunter [ 7] proposed a Petri-net
based model to describe the dependencies in build conÔ¨Åguration
Ô¨Åles. Adams et al. [ 5] proposed a framework to extract a dependencygraph for build conÔ¨Åguration Ô¨Åles, and provide automatic tools to
keep consistency during revision. Most recently, Al-Kofahi et al. [ 6]
proposed a fault localization approach for make Ô¨Åles, which provides
the suspiciousness scores of each statement in a make Ô¨Åles for a
building error. Wolf et al. proposed an approach [ 48] to predict build
errors from the social relationship among developers. McIntosh et
al. [ 26] carried out an empirical study on the efforts developers
spend on the building conÔ¨Ågurations of projects. Downs et al. [ 10]
proposed an approach to remind developers in a development team
about the building status of the project. On the study of building
errors, Seo et al. [ 36] and Hassan et al. [ 15,17] carried out empirical
studies to categorize build errors. Their study shows that missing
types and incompatibility are the most common type of build errors,
which are consistent with our Ô¨Åndings.
The most closely related work in this category is SYMake deve-
loped by Tamrawi et al. [ 41]. SYMake uses a symbolic-evaluation-
based technique to generate a string dependency graph for the string
variables/constants in a MakeÔ¨Åle, automatically traces these values
in maintenance tasks (e.g.,renaming), and detect common errors.
Compared to SYMake, the proposed project plans to develop build
conÔ¨Åguration analysis for a different purpose (i.e., automatic soft-
ware building). Therefore, the proposed analysis estimates run-time
values of string variables with grammar-based string analysis instead
of string dependency analysis, and analyzes Ô¨Çows of Ô¨Åles to identify
the paths to put downloaded Ô¨Åles and source Ô¨Åles to be involved.On migration of build conÔ¨Åguration Ô¨Åles, AutoConf [
1] is a GNU
software that automatically generates conÔ¨Åguration scripts based on
detected features of a computer system. AutoConf detects existing
features (e.g., libraries, software installed) in a build environment,
and conÔ¨Ågure the software based on pre-deÔ¨Åned options.
7 CONCLUSION AND FUTURE WORK
For Source code, automatic patch generation research is already in
good shape. Unfortunately, existing techniques are only concentra-
ted to source code related bug Ô¨Åxing. In this work, we propose the
Ô¨Årst approach for automatic build Ô¨Åx candidate patch generation for
Gradle build script. Our solution works on automatic build Ô¨Åx tem-
plate generation based on build failure log similarity and historical
build script Ô¨Åxes. For extracting build script changes, we developed
GradleDiff for AST level build script change identiÔ¨Åcation. Based
on automated Ô¨Åx template we generated a ranked list of patches. In
our evaluation, our approach can Ô¨Åx 11 out of 24 reproducible build
failures.
In future, we plan to increase training and testing data size for
better coverage of build failures with better evaluation and perform
study on patch quality for the patches generated by out tool. Moreo-
ver, change patterns from general build script commits may also be
useful, and we have a plan to work on build script change patterns
regardless of build status. Apart from that, we are planning to apply
search based technique such as genetic programming with Ô¨Åtness
function on our patch list to better rank our generated patches and
apply combination of patches.
ACKNOWLEDGEMENTS. The authors are supported in part by
NSF Awards CCF-1464425, CNS-1748109, and DHS grant DHS-
14-ST-062-001.
1087
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. HireBuild: An Automatic Approach to History-Driven Repair
of Build ScriptsICSE ‚Äô18, May 27-June 3, 2018, Gothenburg, Sweden
REFERENCES
[1] 2015. GNU Autoconf - Creating Automatic ConÔ¨Åguration Scripts. http://www.
gnu.org/software/autoconf/manual/index.html. (2015). Accessed: 2015-10-25.
[2] 2017. The Gradle build language. https://docs.gradle.org/current/userguide/
writing_build_scripts.html. (2017). Accessed: 2017-04-30.
[3] 2017. Gradle Build Script Structure. https://docs.gradle.org/3.5/dsl/. (2017).
Accessed: 2017-04-30.
[4] Bram Adams, Kris De Schutter, Herman Tromp, and Wolfgang De Meuter. 2007.
The Evolution of the Linux Build System. ECEASST 8 (2007).
[5] B. Adams, H. Tromp, K. De Schutter, and W. De Meuter. 2007. Design recovery
and maintenance of build systems. In Software Maintenance, 2007. ICSM 2007.
IEEE International Conference on. 114‚Äì123. DOI: http://dx.doi.org/10.1109/
ICSM.2007.4362624
[6] Jafar Al-Kofahi, Hung Viet Nguyen, and Tien N. Nguyen. 2014. Fault Localization
for Build Code Errors in MakeÔ¨Åles. In Companion Proceedings of the 36th Interna-
tional Conference on Software Engineering (ICSE Companion 2014). ACM, New
Y ork, NY , USA, 600‚Äì601. DOI:http://dx.doi.org/10.1145/2591062.2591135
[7] Nasreddine Aoumeur and Gunter Saake. 2004. Dynamically Evolving ConcurrentInformation Systems SpeciÔ¨Åcation and V alidation: A Component-based Petri Nets
Proposal. Data Knowl. Eng. 50, 2 (Aug. 2004), 117‚Äì173. DOI: http://dx.doi.org/
10.1016./j.datak.2003.10.005
[8] Earl T Barr, Y uriy Brun, Premkumar Devanbu, Mark Harman, and Federica Sarro.
2014. The plastic surgery hypothesis. In Proceedings of the 22nd ACM SIGSOFT
International Symposium on F oundations of Software Engineering. ACM, 306‚Äì
317.
[9] Moritz Beller, Georgios Gousios, and Andy Zaidman. 2017. TravisTorrent: Synt-
hesizing Travis CI and GitHub for Full-Stack Research on Continuous Integration.
InProceedings of the 14th working conference on mining software repositories.
[10] John Downs, Beryl Plimmer, and John G. Hosking. 2012. Ambient A wareness of
Build Status in Collocated Software Teams. In Proceedings of ICSE. 507‚Äì517.
[11] Jean-R√©my Falleri, Flor√©al Morandat, Xavier Blanc, Matias Martinez, and Mar-
tin Monperrus. 2014. Fine-grained and Accurate Source Code Differencing.
InProceedings of the 29th ACM/IEEE International Conference on Automated
Software Engineering (ASE ‚Äô14). ACM, New Y ork, NY , USA, 313‚Äì324. DOI:
http://dx.doi.org/10.1145/2642937.2642982
[12] Ethan Fast, Claire Le Goues, Stephanie Forrest, and Westley Weimer. 2010. De-
signing better Ô¨Åtness functions for automated program repair. In GECCO, Martin
Pelikan and J√ºrgen Branke (Eds.). ACM, 965‚Äì972.
[13] B. Fluri, M. Wuersch, M. PInzger, and H. Gall. 2007. Change Distilling:Tree
Differencing for Fine-Grained Source Code Change Extraction. IEEE Transactions
on Software Engineering 33, 11 (Nov 2007), 725‚Äì743. DOI: http://dx.doi.org/10.
1109/TSE.2007.70731
[14] C. Le Goues, T. Nguyen, S. Forrest, and W. Weimer. 2012. GenProg: A Generic
Method for Automatic Software Repair. IEEE Transactions on Software Engineer-
ing 38, 1 (Jan 2012), 54‚Äì72. DOI:http://dx.doi.org/10.1109/TSE.2011.104
[15] F. Hassan, S. Mostafa, E. S. L. Lam, and X. Wang. 2017. Automatic Building of
Java Projects in Software Repositories: A Study on Feasibility and Challenges. In
2017 ACM/IEEE International Symposium on Empirical Software Engineering
and Measurement (ESEM). 38‚Äì47.
[16] F. Hassan and X. Wang. 2017. Change-Aware Build Prediction Model for Stall
Avoidance in Continuous Integration. In 2017 ACM/IEEE International Sympo-
sium on Empirical Software Engineering and Measurement (ESEM). 157‚Äì162.
[17] Foyzul Hassan and Xiaoyin Wang. 2017. Mining readme Ô¨Åles to support automatic
building of java projects in software repositories: Poster. In Proceedings of the
39th International Conference on Software Engineering Companion. 277‚Äì279.
[18] Hubert Klein Ikkink. 2015. Gradle Dependency Management. Packt Publishing.
[19] Hannes Kegel and Friedrich Steimann. 2008. Systematically Refactoring Inheri-
tance to Delegation in Java. In Proceedings of the 30th International Conference
on Software Engineering (ICSE ‚Äô08). 431‚Äì440.
[20] Dongsun Kim, Jaechang Nam, Jaewoo Song, and Sunghun Kim. 2013. Automa-
tic Patch Generation Learned from Human-written Patches. In Proceedings of
the 2013 International Conference on Software Engineering (ICSE ‚Äô13). IEEE
Press, Piscataway, NJ, USA, 802‚Äì811. http://dl.acm.org/citation.cfm?id=2486788.
2486893
[21] X. B. D. Le, D. Lo, and C. L. Goues. 2016. History Driven Program Repair.
In2016 IEEE 23rd International Conference on Software Analysis, Evolution,
and Reengineering (SANER), V ol. 1. 213‚Äì224. DOI: http://dx.doi.org/10.1109/
SANER.2016.76
[22] Claire Le Goues, Michael Dewey-V ogt, Stephanie Forrest, and Westley Weimer.
2012. A Systematic Study of Automated Program Repair: Fixing 55 out of
105 Bugs for $8 Each. In Proceedings of the 34th International Conference
on Software Engineering (ICSE ‚Äô12). IEEE Press, Piscataway, NJ, USA, 3‚Äì13.
http://dl.acm.org/citation.cfm?id=2337223.2337225
[23] Fan Long and Martin Rinard. 2015. Staged Program Repair in SPR. In Joint
Meeting of the European Software Engineering Conference and the ACM SIGSOFT
Symposium on The F oundations of Software Engineering.
[24] Fan Long and Martin Rinard. 2016. Automatic patch generation by learning
correct code. In ACM SIGPLAN Notices, V ol. 51. ACM, 298‚Äì312.[25] Shane Mcintosh, Bram Adams, and Ahmed E. Hassan. 2012. The Evolution of
Java Build Systems. Empirical Softw. Engg. 17, 4-5 (Aug. 2012), 578‚Äì608. DOI:
http://dx.doi.org/10.1007/s10664-011-9169-5
[26] S. McIntosh, B. Adams, T.H.D. Nguyen, Y . Kamei, and AE. Hassan. 2011. An
empirical study of build maintenance effort. In Software Engineering (ICSE), 2011
33rd International Conference on. 141‚Äì150. DOI: http://dx.doi.org/10.1145/
1985793.1985813
[27] S. Mechtaev, J. Yi, and A. Roychoudhury. 2015. DirectFix: Looking for Simple
Program Repairs. In 2015 IEEE/ACM 37th IEEE International Conference on
Software Engineering, V ol. 1. 448‚Äì458. DOI: http://dx.doi.org/10.1109/ICSE.
2015.63
[28] S. Mechtaev, J. Yi, and A. Roychoudhury. 2016. Angelix: Scalable Multi-
line Program Patch Synthesis via Symbolic Analysis. In 2016 IEEE/ACM 38th
International Conference on Software Engineering (ICSE). 691‚Äì701. DOI:
http://dx.doi.org/10.1145/2884781.2884807
[29] Frederic P . Miller, Agnes F. V andome, and John McBrewster. 2010. Apache
Maven. Alpha Press.
[30] Hoang Duong Thien Nguyen, Dawei Qi, Abhik Roychoudhury, and Satish
Chandra. 2013. SemFix: Program Repair via Semantic Analysis. In Proceedings
of the 2013 International Conference on Software Engineering. 772‚Äì781.
[31] S. Pearson, J. Campos, R. Just, G. Fraser, R. Abreu, M. D. Ernst, D. Pang, and B.
Keller. 2017. Evaluating and Improving Fault Localization. In 2017 IEEE/ACM
39th International Conference on Software Engineering (ICSE). 609‚Äì620. DOI:
http://dx.doi.org/10.1109/ICSE.2017.62
[32] Y uhua Qi, Xiaoguang Mao, Y an Lei, Ziying Dai, and Chengsong Wang. 2014. The
Strength of Random Search on Automated Program Repair. In Proceedings of the
36th International Conference on Software Engineering (ICSE 2014). ACM, New
Y ork, NY , USA, 254‚Äì265. DOI:http://dx.doi.org/10.1145/2568225.2568254
[33] Juan Ramos and others. 2003. Using tf-idf to determine word relevance in do-
cument queries. In Proceedings of the Ô¨Årst instructional conference on machine
learning.
[34] T. Rausch, W. Hummer, P . Leitner, and S. Schulte. 2017. An Empirical Analysis
of Build Failures in the Continuous Integration WorkÔ¨Çows of Java-Based Open-
Source Software. In 2017 IEEE/ACM 14th International Conference on Mining
Software Repositories (MSR). 345‚Äì355. DOI: http://dx.doi.org/10.1109/MSR.
2017.54
[35] Hyunmin Seo, Caitlin Sadowski, Sebastian Elbaum, Edward Aftandilian, and
Robert Bowdidge. 2014. Programmers‚Äô Build Errors: A Case Study (at Google).
InProceedings of the 36th International Conference on Software Engineering
(ICSE 2014). ACM, New Y ork, NY , USA, 724‚Äì734. DOI: http://dx.doi.org/10.
1145/2568225.2568255
[36] Hyunmin Seo, Caitlin Sadowski, Sebastian Elbaum, Edward Aftandilian, and
Robert Bowdidge. 2014. Programmers‚Äô Build Errors: A Case Study (at Google).
InProceedings of ICSE. 724‚Äì734.
[37] S. Sidiroglou and A. D. Keromytis. 2005. Countering network worms through
automatic patch generation. IEEE Security Privacy 3, 6 (2005), 41‚Äì49.
[38] E. Smith, E. Barr, C. Le Goues, and Y . Brun. 2015. Is the Cure Worse Than
the Disease? OverÔ¨Åtting in Automated Program Repair. In Joint Meeting of the
European Software Engineering Conference and the ACM SIGSOFT Symposium
on The F oundations of Software Engineering.
[39] Y oonki Song, Xiaoyin Wang, Tao Xie, Lu Zhang, and Hong Mei. 2010. JDF:detecting duplicate bug reports in Jazz. In Proceedings of the 32nd ACM/IEEE
International Conference on Software Engineering-V olume 2. ACM, 315‚Äì316.
[40] Mat√∫≈° Sul√≠r and Jaroslav Porub√§n. 2016. A Quantitative Study of Java Software
Buildability. In Proceedings of the 7th International Workshop on Evaluation and
Usability of Programming Languages and Tools (PLATEAU 2016). ACM, New
Y ork, NY , USA, 17‚Äì25. DOI:http://dx.doi.org/10.1145/3001878.3001882
[41] Ahmed Tamrawi, Hoan Anh Nguyen, Hung Viet Nguyen, and Tien N. Nguyen.
2012. SYMake: A Build Code Analysis and Refactoring Tool for MakeÔ¨Åles.InProceedings of the 27th IEEE/ACM International Conference on Automated
Software Engineering (ASE 2012). ACM, New Y ork, NY , USA, 366‚Äì369. DOI:
http://dx.doi.org/10.1145/2351676.2351749
[42] S. H. Tan and A. Roychoudhury. 2015. ReliÔ¨Åx: Automated Repair of Software
Regressions. In International Conference on Software Engineering.
[43] Yida Tao, Jindae Kim, Sunghun Kim, and Chang Xu. 2014. Automatically Gene-
rated Patches As Debugging Aids: A Human Study. In Proceedings of the 22Nd
ACM SIGSOFT International Symposium on F oundations of Software Engineering.
64‚Äì74.
[44] Jesse Tilly and Eric M. Burke. 2002. Ant: The DeÔ¨Ånitive Guide (1st ed.). O‚ÄôReilly
& Associates, Inc., Sebastopol, CA, USA.
[45] Xiaoyin Wang, Lu Zhang, Tao Xie, Hong Mei, and Jiasu Sun. 2009. Transtrl:
An automatic need-to-translate string locator for software internationalization. In
Proceedings of the 31st International Conference on Software Engineering . IEEE
Computer Society, 555‚Äì558.
[46] Westley Weimer, Zachary P Fry, and Stephanie Forrest. 2013. Leveraging program
equivalence for adaptive program repair: Models and Ô¨Årst results. In Automated
Software Engineering (ASE), 2013 IEEE/ACM 28th International Conference on.
IEEE, 356‚Äì366.
1088
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô18, May 27-June 3, 2018, Gothenburg, Sweden Foyzul Hassan and Xiaoyin Wang
[47] Peter Willett. 2006. The Porter stemming algorithm: then and now. Program 40,
3 (2006), 219‚Äì223.
[48] Timo Wolf, Adrian Schroter, Daniela Damian, and Thanh Nguyen. 2009. Pre-
dicting Build Failures Using Social Network Analysis on Developer Communica-
tion. In Proceedings of ICSE. 1‚Äì11.
[49] J. Xuan, M. Martinez, F. DeMarco, M. Cl√Él ‚Äôment, S. L. Marcote, T. Durieux,
D. Le Berre, and M. Monperrus. 2017. Nopol: Automatic Repair of Conditional
Statement Bugs in Java Programs. IEEE Transactions on Software Engineering43, 1 (Jan 2017), 34‚Äì55. DOI:http://dx.doi.org/10.1109/TSE.2016.2560811
[50] Hongyu Zhang, Hee Beng Kuan Tan, Lu Zhang, Xi Lin, Xiaoyin Wang, Chun
Zhang, and Hong Mei. 2011. Checking enforcement of integrity constraints in
database applications based on code patterns. Journal of Systems and Software 84,
12 (2011), 2253‚Äì2264.
[51] Hao Zhong and Na Meng. 2017. An empirical study on using hints from pastÔ¨Åxes: poster. In Proceedings of the 39th International Conference on Software
Engineering Companion. 144‚Äì145.
1089
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. 