Goal-Conflict Likelihood Assessment based on Model Counting
Renzo Degiovanni
Universidad Nacional de R√≠o Cuarto
Argentina
rdegiovanni@dc.exa.unrc.edu.arPablo Castro
Universidad Nacional de R√≠o Cuarto
and CONICET, Argentina
pcastro@dc.exa.unrc.edu.arMarcelo Arroyo
Universidad Nacional de R√≠o Cuarto
Argentina
marcelo.arroyo@dc.exa.unrc.edu.ar
Marcelo Ruiz
Universidad Nacional de R√≠o Cuarto
Argentina
mruiz@exa.unrc.edu.arNazareno Aguirre
Universidad Nacional de R√≠o Cuarto
and CONICET, Argentina
naguirre@dc.exa.unrc.edu.arMarcelo Frias
Instituto Tecnol√≥gico de Buenos Aires
and CONICET, Argentina
mfrias@itba.edu.ar
ABSTRACT
In goal-oriented requirements engineering approaches, conflict
analysishasbeenproposedasanabstractionforriskanalysis.Intu-
itively,givenasetofexpectedgoalstobeachievedbythesystem-to-be, a conflict represents a subtle situation that makes goals diverge,i.e.,notbesatisfiableasawhole.Conflictanalysisistypicallydrivenby the identify-assess-control cycle, aimed at identifying, assessing
and resolving conflicts that may obstruct the satisfaction of the
expectedgoals.Inparticular,theassessmentstepisconcernedwith
evaluating how likely the identified conflicts are, and how likely
and severe are their consequences.
Sofar,existingassessmentapproachesrestricttheiranalysisto
obstacles(conflictsthatpreventthesatisfactionofasinglegoal),and
assume that certain probabilistic information on the domain is pro-
vided,thatneedstobepreviouslyelicitedfromexperiencedusers,
statistical data or simulations. In this paper, we present a novel au-
tomated approach to assess how likely a conflict is, that applies to
generalconflicts(notonlyobstacles)withoutrequiringprobabilistic
information on the domain. Intuitively, given the LTL formulation
ofthedomainandofasetofgoalstobeachieved,wecomputegoal
conflicts, and exploit string model counting techniques to estimate
thelikelihoodoftheoccurrenceofthecorrespondingconflicting
situations and the severity in which these affect the satisfaction of
the goals. This information can then be used to prioritize conflicts
to be resolved, and suggest which goals to drive attention to for
refinements.
CCS CONCEPTS
‚Ä¢Software and its engineering ‚ÜíRequirements analysis ;
Risk management ;‚Ä¢Theory of computation ‚ÜíModal and
temporal logics ; Regular languages;
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ICSE ‚Äô18, May 27-June 3, 2018, Gothenburg, Sweden
¬©2018 Copyright held by the owner/author(s). Publication rights licensed to Associa-
tion for Computing Machinery.
ACM ISBN 978-1-4503-5638-1/18/05...$15.00
https://doi.org/10.1145/3180155.3180261KEYWORDS
Goal Conflicts, Risk Likelihood Assessment, Model Counting
ACM Reference Format:
Renzo Degiovanni, PabloCastro, Marcelo Arroyo,Marcelo Ruiz, Nazareno
Aguirre, and Marcelo Frias. 2018. Goal-Conflict Likelihood Assessment
based on Model Counting. In Proceedings of ICSE ‚Äô18: 40th International
Conference on Software Engineering , Gothenburg, Sweden, May 27-June 3,
2018 (ICSE ‚Äô18), 12 pages.
https://doi.org/10.1145/3180155.3180261
1 INTRODUCTION
As many errors in software development are due to an incorrect
understanding of what the system should do, putting sufficient
emphasisinrequirementsanalysisandspecificationisknowntobe
a major task toward successful software development projects [ 27].
There exist many reasons for requirements descriptions to be in-
adequate, including requirements being too ideal (e.g., assumingthat some aspect of the environment will behave unrealistically
benevolentlywiththesystem),requirementsbeingtooabstractand
thus leaving room for conflicting situations whose treatment goes
unspecified,missingsomerequirementsaltogetherorleavingthem
implicit, and even having inconsistent requirements that cannot
be satisfied as a whole [ 40]. The requirements analysis phase deals
precisely with these issues, and attempts to identify such problems
as early as possible, so that appropriate actions can be taken to
improve the software requirements prior to development.
Aparticularfamilyofapproachestowardrequirementsanaly-
sis and specification are the so called goal-oriented requirements
methodologies [14,45]. In such approaches, requirements are orga-
nizedaround goals,prescriptivestatementsthatspecifywhatthe
systemtobedevelopedshoulddo.Thesegoalsaresubjecttoanum-
ber of activities (that are part of the requirements process); they
can be analyzed, decomposed, refined, assigned to agents for their
realization,andassessedinanumberofdifferentways,including
assessments that evaluate their feasibility, and potential threats to
their satisfaction. Indeed, risk analysis deals precisely with this last
issue,invariousways,including goal-conflictanalysis [41].Goal-
conflictanalysisaimsatidentifying conflicts,i.e.,conditionsthat,
whenpresent,makeasetofotherwiseconsistentgoalsinconsistent,
as well as assessing and controlling such conflicts. Once a conflict
is identified, the assessment step is concerned with evaluating how
likelytheidentifiedconflictis,andhowsevereareitsconsequences.
So far, existing assessment approaches[ 4,11‚Äì13,43] restrict their
11252018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô18, May 27-June 3, 2018, Gothenburg, Sweden R. Degiovanni, P. Castro, M. Arroyo, M. Ruiz, N. Aguirre, and M. Frias
analysestosimplerkindofconflicts,called obstacles,andassume
that certain probabilistic information on the domain is provided.
While goal-conflict assessment can be naturally thought of as a
quantitative analysisthatusesprobabilitiesofconflictingsituations
to analyze their impact in the overall requirements description,
manytimesoneisunabletocomeupwiththerequiredprobabili-
ties for such analyses. The reason is that the required probabilistic
information needs to be obtained prior to the goal-conflict analysis
from some trusted source, e.g., available statistical data, simula-
tions, or stakeholders whose expertise allows them to estimate
theseprobabilities.Inmanydevelopmentprojects,especiallynew
developments,suchinformation maybeunavailable,inparticular
in early phases of requirements analysis. Thus, in these situations,
importantrequirementsactivitiessuchasconflictprioritizationand
goalrefinement,thatbenefitfromgoal-conflictanalysis,needtobe
postponed or performed without such information.
Inthispaperweproposeanautomatedtechniqueforgoal-conflict
analysis.Thistechniqueisnovelintworespects,namely,itdoesnot
demandprobabilisticinformation,anditappliestogeneralconflicts
(as opposed to previous works that are restricted to goal obstacles).
Theapproachisbasedonautomaticallycomputinggoalconflicts,
capturing these as formulas, and using model counting to estimate
theircorrespondinglikelihood.Moreprecisely,givenanLTLfor-
mulationofthedomainandofasetofgoalstobeachieved,wecom-
putegoalconflicts,andexploitstringmodelcountingtechniques
toestimatethelikelihoodoftheoccurrenceofthecorresponding
conflicting situations and the severity in which these affect the
satisfaction of the goals.
Basically, from an LTL formula œÜ, we can generate a regular
expression eœÜrepresenting the prefixes accepted by œÜ.W ec a n
then use a string model counter to compute the number of strings
(prefixes) of length kthat are recognized by the regular expression
eœÜ, as an estimation of the number of models that satisfy œÜ. This
toolcancomputethenumberof(finite)traces,foragivenbound,
thatsatisfythedomaindescription,andtocalculate howmanyof
thesecorrespondtoaparticularconflictingsituation,asawayof
estimating the likelihood of the conflict. This information can then
be used to prioritize conflicts to be resolved, and suggest which
goalstodriveattentiontoforrefinements.Wedevelopanumberof
casestudies,withrequirementsmodelstakenfromtheliterature,
forwhichweperformautomatedgoalconflictdetection,andmodel
counting for their assessment.
The remainder of the paper is organized as follows. Section 2
introduces preliminary concepts necessary in subsequent sections.
Section3presentsanillustratingexample,thatmotivatesourap-
proach. Section 4 describes the approach in detail. In Section 5 we
evaluateourtechnique,byanalyzinghowmodelcountingcanbe
usedtoestimatethelikelihoodofconflictingsituations,inanumber
ofcasestudies.Finally,wediscussrelatedworkinSection6,and
present our conclusions in Section 7.
2 BACKGROUND
2.1 Goal-Oriented Modelling and Conflict
Analysis
Among the various approaches to Requirements Engineering, goal-
orientedmethodologies,andinparticulartheonepresentedin[ 40],proposeorganizingthespecificationofhowasystemshouldbehave
aroundasetof goals.Thesegoalsare prescriptive statementsthatthe
system to be developed is expected to achieve in cooperation with
otheragents(e.g., devices, users, etc, besides the software itself),
within a given domain. The domain is captured through domain
properties, descriptive statements about the problem world, such as,
e.g., natural laws relevant to the system. A goal model indicates,
through refinements, how higher-level goals can be achieved in
termsofsimplerones,eventuallysimpleenoughsothattheycan
be assigned to single agents for their fulfillment.
There exist many reasons for requirements descriptions to be
inadequate, including requirements being too ideal (e.g., assuming
that some aspect of the environment will behave unrealisticallybenevolently with the system), requirements being too abstract
(andthusleavingroomforconflictingsituationswhosetreatmentis
underspecified), missing some requirements altogether (or leaving
them implicit), and even having inconsistent requirements that
cannot be satisfied as a whole.
The process leading to the right requirements is not straightfor-
ward.Conflict analysis [40,42] helps in improving requirements
specificationsthroughthreemainsteps: (i)identifyasmanycon-
flictsaspossibleandrelatethemto(setsof)goalsinthegoalmodel,
(ii)assess how likely the identified conflicts are, and how likely
and severeare their consequences;and (iii)resolve thoseconflicts
whose likelihood deems them critical, by providing appropriate
countermeasures and, consequently, transforming the goal model.
Conflicts in goal models represent conditions whose occurrence
resultinthelossofsatisfactionofthegoals,i.e.,thatmakethegoals
diverge.Formally,aset G1,...,Gnofgoalsissaidtobe divergent
with respect to a set Domof domain properties iff there exists a
boundarycondition BCsuchthatthefollowingconditionshold[ 41]:
{Dom ,BC,/logicalandtext
1‚â§i‚â§nGi}|=false (logical inconsistency )
{Dom ,BC,/logicalandtext
j/nequaliGj}/negationslash|=false,for each 1‚â§i‚â§n (minimality )
BC/nequal¬¨(G1‚àß...‚àßGn)( non-triviality )
Intuitively, the above conditions indicate that the boundary con-
ditionisconsistentwithdomainandcapturesaparticularcombi-
nationofcircumstancesthatmakesthegoalsconflicting.Thatis,
whentheboundarycondition BCholds,thenthegoalscannotbe
simultaneouslysatisfiedin Domunderanycircumstances.Bound-
ary conditions represent a very general form of conflict, that in
particular subsume obstacles[43], a particular instance of conflicts
in which Gonly contains one single goal.
There are relevant approaches that can automatically identify
boundaryconditionsforconflictinggoalswritteninLinear-Time
Temporal Logic (LTL). The pattern-based approach put forward
in [41] supports a limited set of patterns and only produces pre-
determined formulations of boundary conditions. The approachintroduced in [
15] automatically produces boundary conditions
throughtheprocessingofanLTLtableauxforthegoalsanddomain
properties.Wewillusethelattertoidentifyboundaryconditions,
whose likelihood will be assessed through model counting.
2.2 Linear-Time Temporal Logic
Linear-TimeTemporalLogic(LTL)[ 34]isalogicalformalismwidely
employedtoformallystatepropertiesofreactivesystems.Thislogic
1126
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. Goal-Conflict Likelihood Assessment based on Model Counting ICSE ‚Äô18, May 27-June 3, 2018, Gothenburg, Sweden
is used as the specification formalism in various tools for formal
analysis, including model checkers [ 26,33], trace checkers [ 7] and
theorem provers [10], among others.
LTL assumes that time is linear, i.e., each instant is succeeded
by a single future instant. The syntax of LTL is formally defined
as follows. Given a set APof propositional variables, LTL formulas
are inductively defined using the standard logical connectives and
temporal operators /circlecopyrtandU, by the following rules: (i)every
p‚ààAPis an LTL formula, and (ii)iff1andf2are LTL formulas,
then so are¬¨f1,f1‚à®f2,f1‚àßf2,/circlecopyrtf1andf1Uf2. We consider the
usual definition for the operators 2(always) and 3(eventually) in
terms of/circlecopyrt,Uand logical connectives [34].
2.3 LTL Model Counting
LTLformulasareinterpretedoverinfinitetracesofpropositional
valuations. These traces are typically finitely-represented through
finite-statetransitionsystems,i.e.,theycorrespondto(infinite)words
overagivenfinite-statetransitionsystem.Thus,problemsregardingLTLareusuallyexpressedinrelationtothesefinite-statetransitionsystems.Aknownexampleismodelchecking[
6],whichisdefined
as the problem of deciding, given a transition system Tand an LTL
formulaœÜ, whether all executions of TsatisfyœÜ. Similarly, LTL
satisfiability can be defined as the problem of deciding, given an
LTLformula œÜ,ifthereexistsafinite-statetransitionsystem Twith
at least one execution that satisfies œÜ. Themodel counting problem
forLTListhentheproblemof,givenanLTLformula œÜ,counting
howmanytransitionsystemssatisfy œÜ.Itisnotdifficulttoseethat,
if anLTLformula œÜhasa model,then ithas an infinitenumber of
models (e.g., one can ‚Äúunfold‚Äù a satisfying transition system Tany
finitenumberoftimes,obtainingagainamodelof œÜ).Then,anLTL
formulacanhaveeitheraninfinitenumberofmodels(whenitis
satisfiable), or no model at all (when it is unsatisfiable).
In order to obtain a more useful value, the LTL model counting
problemisusuallyrestrictedto boundedmodels.Thatis,givenan
LTLformula œÜandabound k,themodelcountingproblemconsists
of calculating how many models of at most kstates exist. Based on
knownresultsfromtheareaof boundedmodelchecking [9],onecan
typicallyrestricttheanalysistocertainkindofcanonicalmodels.
In[20],forinstance,twodifferentkindsofboundedmodelsforLTL
areconsidered, namely k-wordmodelsand k-treemodels.Wewill
concentrate in k-word models.
A word model can be represented by a finite sequence of states,
calledthe baseoftheword,suchthatthelaststatehasalooptosome
previousstate.Thesearecalled lassotraces [20],andFigure1shows
theirgeneralshape.Formally,givenaset APofatomicpropositions,
a word model œÉis a sequence of states s0,...,si‚àí1,(si,...,sk)œâ,
such that, s0,...,sk‚àà2AP; in such a word model, there is a loop
from state kto statei.
s0 si sk
Figure 1: Shape of word models.
The straightforward approach one can use to count the num-
ber of word-models is through SAT-based Bounded Model Check-
ing [9]. For a given bound k, LTL formulas can be encoded aspropositionalformulas[ 32].Theencodingissuchthat eachsatis-
fying valuation of the encoding corresponds to a lasso trace of k
states of the LTL formula. Then, a model counter for propositional
logic,e.g., RelSAT[28],cachet[37]and sharpSAT [38],canbeused
for ‚Äúindirect‚Äù LTL (bounded) model counting. An alternative ap-
proach, presented in [ 20], introduces an automata-based algorithm
for counting word models of safetyLTL formulas. It proceeds in
twosteps:first,itconstructsawordautomatonthatacceptsafinitesequenceofsize
kifitisabaseforawordmodelof œÜ;andsecond,it
uses the word automaton to calculate how many loops are allowed
in order to count the number of word models of œÜ.
As explainedin [ 20], both of theabove approachesbecome im-
practicalforrelativelysmallvaluesof k.Ononehand,thereduction
topropositionalcountingleadsustopropositionalconstraintswith
thousandsofvariablesthatcannotbeefficientlyhandledbyavail-
able model counters. In case of the algorithm in [ 20], it is linear in
k, but double exponential on the size of the LTL formula, and only
applies to safety formulas.
2.4 String Model Counting
Inorder toperformasignificant assessmentonhowlikely agoal-
conflictis,weneedthemodelcountinganalysistoscaletorelativelylarge values of
k, and thus current LTL model counting technology
quicklyreachesitslimits. However, ifweconsidercounting word
basesinsteadofwordmodels,theproblemcanbeveryefficiently
solvedbyusingstringmodelcounting.Theproblemofstringmodel
counting consists of computing the number of strings of a given
lengthk, that satisfy a set of string constraints. For instance, given
aregularexpression e=(a|b)‚àó,wemayneedtoknowhowmany
stringsof,say,length2,satisfytheconstraint e(inthiscase,itis4: aa,
ab,baandbb). In this work, we use the recently introduced string
modelcounter ABC[5].Givenaset Cofstringconstraints, ABCfirst
constructs anautomaton thataccepts allthe stringssatisfying the
constraintsin C,andthenproducesa generatingfunction thattakes
alengthbound kasinputandreturnsthetotalnumberofstringsof
lengthk,thatareacceptedbytheautomaton.Wedenoteby# (C,k)
theresultofevaluatingin kthegeneratingfunctionproducedfrom
the set of string constraints C.ABCchecks the satisfiability of C
only once, when producing the generating function; after that,
we can evaluate the generating function on many different values
ofk, without having to check for satisfiability again. This is the
main feature of ABCthat allows us to scale to considerably large
valuesof k(e.g.,1000),inseconds. ABCsupportsawidesetofstring
constraints, but we use only regular expressions.
2.5 Word Base Counting
Figure 1 shows the general shape of a word model. In particular,
the sequence of states s0,...,skis thebaseof the word. Notice
that the word base can be thought of as a finite string of length
kthat can be accepted by a regular expression. Then, if we can
encode an LTL formula œÜinto a set CœÜof string constraints, we
can use ABCto compute # (CœÜ,k), the number of word bases of
lengthksatisfying œÜ. For instance, for the LTL formula 2(p‚à®
q),ourapproachproducestheregularexpression (a|b|c)‚àó,where
characters a,bandccharacterisethe3differentpossiblewaysof
makingp‚à®qtrue.Thus,for k=4,# ((a|b|c)‚àó,4)=81,meaningthat
1127
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô18, May 27-June 3, 2018, Gothenburg, Sweden R. Degiovanni, P. Castro, M. Arroyo, M. Ruiz, N. Aguirre, and M. Frias
there are 81 word bases that can be obtained from word models
of at most 4 states. Notice that each string we count may be thebase of different word models. For instance, we count the wordbase
aaaaonly once, but there are 4 different word models with
the same base but with differentloops (namely, (aaaa )œâ,a(aaa )œâ,
aa(aa)œâandaaa (a)œâ).
Moreprecisely,givenanLTLformula œÜ,wegeneratetheregular
expression eœÜbyperformingthefollowingencodings:(1)wegen-
erate the B√ºchi automaton BœÜthat recognises œÜ; (2) we generate
a Finite State Automaton AœÜfromBœÜ; and (3) we generate the
regular expression eœÜfromAœÜ. Intuitively, the B√ºchi automaton
BœÜrecognises all the word models for formula œÜ. Recall that B√ºchi
automata onlyrecognise infinitewords, sincetheir acceptingcon-
ditionrequiresthatsomeacceptingstatehastobevisitedinfinitely
often in the word model. However, when we generate the finiteautomaton
AœÜfromBœÜ, the strings recognised by AœÜare finite
(its accepting condition requires only reaching some final state).
Because of that, the words recognised by AœÜare the bases of some
word model. Finally, we can convert AœÜto a regular expression eœÜ
thatrecognises exactlythe samelanguage, i.e.,the wordbases for
the LTL formula œÜ.
Along the process, we apply a minimization algorithm to the
B√ºchi automaton, to produce a regular expression that is more
compactandeasiertoanalyse.Alltheconversionsaredonewith
thetools LamaConv [2]and JFLAP[1].Ourexperimentalevaluation
shows that the translations can be performed very efficiently.
3 MOTIVATING EXAMPLE
LetusconsiderasimplifiedversionoftheMinePumpController
(MPC)[30],toillustrateboththeproblemaddressedandourpro-
posed approach. The MPC controls a pump in a mine. It communi-
cates with a sensor that detects when the water level is high, and a
sensor to detect the presence of methane in the environment. The
propositional variables hw,mandpoare employed to represent
the facts that the water level has reached a high threshold, thatmethane is present in the environment, and that the pump is on,respectively. For this problem setting, the following assumption
and goals have already been elicited:
Assumption: PumpEffect
InformalDef : If the pump is on, the level of water decreases in at
most two time units.FormalDef :2(2
‚â§2(po)‚Üí3‚â§2(¬¨hw ))
Goal:NoExplosion
InformalDef : The pump should be off when methane is detected.
FormalDef :2(m‚Üí/circlecopyrt (¬¨po))
Goal:NoFlooding
InformalDef : The pump should be on when the water level is
above the high threshold.FormalDef :2(hw‚Üí/circlecopyrt (po))
The above assumption captures the presumed behaviour of the
pumpactuatorinrelationtotheenvironment:whenthepumpis
on,thenatmostin2timeunitsthewaterlevelshoulddecrease.The
goals prescribe how the pump should work when there is methane
presentintheenvironment,andwhenthewaterlevelishigh,respec-
tively.Noticethatwhilethesegoalscanbesimultaneouslysatisfied(e.g.,whenthewaterlevelisneverhighormethaneisneverpresent
intheenvironment),theybecomelogicallyinconsistentwhen,at
thesametime,thewaterlevelishighandmethaneispresent.Such
conflicting situations, that as we mentioned are called boundary
conditions,aremanytimessubtleanddifficulttoidentify,andatthe
sametimetheirfindingisessentialfortherequirementsprocess.In
thiscase,thementionedboundaryconditionis BC1:3(hw‚àßm),
andisoneofthetwoboundaryconditionsautomaticallycomputed
usingthetoolpresentedin[ 15].Theotherboundaryconditionis
lesslegible: BC2:3(hw‚àß¬¨m‚àßpo‚àß/circlecopyrt (¬¨hw‚àß¬¨po‚à®hw‚àß(m‚à®¬¨po))).
These boundary conditions capture differentconflicting situ-
ations that lead us to violating the goals. To continue with the
identify-assess-control approachforgoal-conflictanalysis,weshould
nowattempttoassesshowlikelytheseconflictingsituationsare,
and in what degree they affect each of the goals. This information
is of course very useful for the engineer, as it can be used for clas-
sifyingtheboundaryconditionsaccordingtotheircriticality,and
basedonwhichgoalsaremoreaffected,maysuggestactionstothe
engineer toward resolving the conflicts.
Inanidealsituation,wemayhavestatisticalinformationregard-
ing the chances of sensing methane in the environment, or how
oftenthewaterlevelreachesthehighthreshold,enablingustoper-form someprobabilistic analysisas in[
11], even with uncertainties
intheelicitedvalues[ 13].Ourcurrentapproach,ontheotherhand,
tries to help the engineer when such information is unavailable.
Atypicalapproachwhennoprobabilisticinformationisavail-
able, is assuming that all events are equally likely, and performing
a probabilistic analysis under such hypothesis. For instance, under
such an assumption, we can use a quantitative analysis such asprobabilistic model checking [
6], to analyze the likelihood of our
identifiedboundaryconditions.Thisapproachishowever ineffec-
tive: both boundary conditions can be eventually reached with
probability1,andthusareindistinguishable(intermsofseverity)
by such technique.
As mentioned before, our technique is based on using string
model counting to assess the boundary conditions. We can start
by computing, for some given bound k, the number of word bases
that satisfy our domain properties ( truefor this example) and as-
sumptions( PumpEffect ),denotedby# (PumpEffect ,k).Noticethat
by# (PumpEffect ,k)wedenotethenumberofstringsoflength kthat
arerecognisedbytheregularexpressionobtainedfrom PumpEffect .
Then,wecancomputehowmanyofthesefinitetraceshaveastate
where boundary condition BC1, and (separately) boundary con-
ditionBC2, are reached (i.e., we compute # ({PumpEffect ,BC1},k)
and # ({PumpEffect ,BC2},k)). The quotient between the number of
word bases of length kthat satisfy BC1(resp.BC2) and the number
of all ‚Äúvalid‚Äù word bases (i.e., word bases that satisfy the domain
propertiesandassumptions)oflength k,giveusanestimationof
the likelihood of reaching the boundary condition BC1(resp.BC2)
inksteps. Table 1 summarizes, for several values of k, the number
of word bases that satisfy the assumption, and in addition each of
the boundary conditions, for our mine pump model.
Thisfirststraightforwardanalysisalreadyallowsustoclassify
the boundary conditions. Notice that, as the evaluation shows, the
chancesof reaching BC1tendsto 0%asthevalue of kisincreased
(despite of having good chances initially ‚Äì 22%); while the chances
ofreaching BC2convergesto%6.2.So,wecanclassify BC2asbeing
1128
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. 1129
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô18, May 27-June 3, 2018, Gothenburg, Sweden R. Degiovanni, P. Castro, M. Arroyo, M. Ruiz, N. Aguirre, and M. Frias
Table 2: Loss of Goal Satisfaction for the Mine Pump Controller, in k-bounded word bases.
k
#(CœÜ,k) 123456 10 20 50 75 100 1000
#({PumpEffect ,NoExplosion},k)94822410404864224009990144 4.17E+13 3.05E+33 1.09E+50 3.89E+66 3.16E+662
#({PumpEffect ,NoExplosion ,BC1},k)0211623321580667624 1.37E+12 6.82E+30 2.52E+46 9.32E+61 2.58E+622
%BC1 00.0420.0490.0590.0680.070 0.067 0.033 0.002 0 0 0
#({PumpEffect ,NoExplosion ,BC2},k)002852266146568 6.73E+11 4.95E+31 1.76E+48 6.31E+64 5.12E+660
%BC2 000.0090.0080.010.011 0.014 0.016 0.016 0.016 0.016 0.016
#({PumpEffect ,NoFlooding},k)948248128065043298421633944 2.37E+14 3.14E+35 1.25E+53 5.02E+70 2.27+E704
#({PumpEffect ,NoFlooding ,BC1},k)021610454627221280356 3.92E+12 8.87E+31 1.19E+48 1.59E+64 6.25E+644
%BC1 00.0420.0650.0810.0840.083 0.059 0.016 0 0 0 0
#({PumpEffect ,NoFlooding ,BC2},k)04128040020841407600 1.55E+13 2.06E+34 8,23E+51 3.28E+69 1.49E+703
%BC2 00.0830.0480.0620.0610.063 0.065 0.065 0.065 0.065 0.065 0.065
Goal-ConflictLikelihoodAssessment. Thisphase,concernedwith
evaluatinghowlikelytheidentifiedconflictsareandhowsevere
aretheirconsequences,isthemainphaseofourapproach,where
modelcountingtakesplace.TheinputforthisphasearetheLTLfor-
mulation Domofthedomain,theset {G1,...,Gn}ofgoals,andthe
set{BC1,...,BCm}of boundary conditions previously identified.
As explained in Section 2, given an LTL formula œÜ, we can gen-
erate a regular expression eœÜ, such that eœÜis satisfiable iff there
existsaword-modelwhoseword-baseisrecognisedby eœÜ.Then,
we can feed this regular expression to a string model counter, in
ourcase ABC,tocomputethenumberofstringsthatsatisfy eœÜ.The
obtainednumberofinstancesindirectlyrepresentsthenumberof
wordbases,thatarepartofsomewordmodelthatsatisfiestheLTL
formulaœÜ. We denote this last notion by # (eœÜ,k), or, equivalently,
by# (œÜ,k).Recallthatwhenthestringconstraint eœÜissatisfiable,
ABCproduces a generating function that can be used for solving
the counting problem for different values of k, without the need
ofrecheckingthesatisfiabilityof eœÜ.Thisfeatureisofutmostim-
portance to scaling the analysis to sufficiently large values of k,
allowingustoperformameaningfulassessmentonhowlikelya
boundary condition is.
Recallthateveryboundarycondition BCi‚ààBChasthecanonical
shape3œÜi(see above). Thus, the canonical shape of the regular
expression generated from BCiis:
e3œÜi=e‚àó
¬¨œÜieœÜialph‚àó
where alphrepresents any character from the alphabet of the reg-
ular expression. Intuitively, the regular expression e3œÜirecognises
strings that initially have a prefix in which œÜidoes not hold ( e‚àó¬¨œÜi),
thentheeventuality œÜiisfulfilled( eœÜi),andfromthatpointonany
character is recognised. Given e3œÜi, by removing the suffix alph‚àó,
wecanobtainaregularexpression e/prime3œÜithatrecognisestheword
bases of the LTL formula 3œÜi:
e/prime
3œÜi=e‚àó
¬¨œÜieœÜi
Noticethat e/prime3œÜiforcestheboundarycondition œÜitoholdexactlyin
the last state of any string recognised by such a regular expression.
Thus,foreachboundarycondition BCi‚ààBC,westartbygenerat-
ingtheregularexpressionthatcharacterisesthedomainproperties
Dom,andtheregularexpression e/prime3œÜiaswejustexplained.Then,
weperformthestringmodel countingprocessforeachoneofthe
following string constraints:
(A)#(Dom ,k) (B)# ({Dom ,e/prime3œÜi},k)Intuitively, the model counting problem (A)gives us the number
ofallpossiblewordbases,oflength k,thatarepartofsomeword
modelthatsatisfiesthedomainproperties Dom.Ontheotherhand,
the model counting problem (B)gives us how many of the word
basescomputedin (A),reachtheboundarycondition BCi,forthe
first time, exactlyin thek-th state. The reason for counting in
this way, as opposed to directly counting the traces that reach the
boundary condition BCiinanystate, has to do with avoiding to
count several times what would be, essentially, the same violation.
Forinstance,assumeanalphabet {p,q}oftwopropositionalletters,
the boundary condition being represented by 3(p‚àßq), and ak
value of 3. If p‚àßqholds in the first state, then no matter what
happenslateroninthetrace,theywillallbeviolations(aknown
fact of safety properties as interpreted in [ 31] and formalized in
[3]).Then,wewillbecounting16differentviolations(4different
valuations for the second state, times 4 different violations for the
thirdstate),thatare,inessence,allthesameone.Amoreprecise
wayofcountingviolationsis,aswepropose,takingintoaccount
the traces that reach the property of interest exactly in the k-th
state,aswedo(or,even,calculatingthesumofviolationsfrom1
uptok,where,ineachcase,westipulatethatthepropertymustbe
first reached exactly at the last state).
Using the results of model counting as shown in (A)and(B),w e
can compute the quotient (B)/(A), that represents the likelihood of
reaching,forthefirsttime,theboundarycondition BCiinexactly
ksteps.Inordertoassesshowthisprobabilityismodifiedasthe
trace length is increased, we perform the above model counting
iteratively for increasingly large values of k, until some predefined
maximumvalue Nisreached(orsomeotherpredefinedstopping
criterion is reached, e.g, a timeout). These computed likelihoods
can be used to generate a progression of how the number of word
basesreaching BCirelatetothenumberofwordbasessatisfying
domainproperties.Theseprogressionsgeneratedforeach BCi‚ààBC
should be analysed by the engineer, to determine which boundary
conditions are more likely, and prioritize these for resolution.
The selection of the maximum value Nshould be large enough
to allow the model counting process to converge the likelihoodcomputation to some average value. In our experimental evalua-
tionweuse1000asthemaximumvaluefor k.Iftheprogressions
computedconvergetosomeconstantvalue,thentheaverageofthe
progressionscanbeusedasaquantifiablevaluetoclassifywhich
boundary condition is more likely. For instance, in the Mine Pump
Controller, the progressions for BC1converges to 0%, while the
progressions of % BC2converges to 6 .2%. This indicates that BC2
1130
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. Goal-Conflict Likelihood Assessment based on Model Counting ICSE ‚Äô18, May 27-June 3, 2018, Gothenburg, Sweden
has more chances to be reached than BC1and the engineer should
prioritise BC2 in the search for mechanisms that would allow him
to reduce the chances of reaching BC2.
Goal-ConflictSeverityAssessment. Whenaboundarycondition
is reached, it is not possible to satisfy, simultaneously, all the goals.
Our abovequantitative assessment basedon model countingonly
tells us how many violations of length kwe have, over the total
number of possible ‚Äúvalid‚Äù executions (i.e., executions where do-
main properties hold) of length k. In order to assess the impact
ofaboundaryconditiononaspecificgoal,weneedtoperforma
different analysis. Essentially, we would like to evaluate to what
extent a boundary condition contradicts a specific goal. In order toanalyze this issue, for each boundary condition
BCi‚ààBCand goal
Gj‚ààG, we perform the following model counting tasks:
(C)#({Dom ,Gj},k) (D)# ({Dom ,Gj,e/prime3œÜi},k)
Intuitively, counting problem (C)counts the number of word
bases of length kthat satisfy both the domain and goal Gj.O nt h e
otherhand,modelcountingproblem (D)countshowmanyofthe
wordbases that satisfy DomandGjreach theboundary condition
BCiin thek-th step, for the first time. Then, the quotient (D)/(C)
characterizes the likelihood of reaching the boundary condition
BCi,exactlyin ksteps,withoutviolatinggoal Gj.Intuitively,the
smaller this number, the worse, since having a very small value
for(D)/(C)wouldmeanthatwhentheboundarycondition BCiis
reached, there are higher chances of violating goal Gj(i.e.,BCihas
severe consequences on the satisfaction of goal Gj).
Again, if we perform the above model counting tasks for in-
creasingly larger values of k, for each of the identified boundary
conditions and every goal, we can produce a progression, to facili-
tate the analysis of howthe satisfaction of the goals is affected by
theboundaryconditions.Thisinformationcanhelptheengineer
in focusing on those goals that result to be affected to a greater
extent, thus suggesting which goals should receive more attention
for refinements.
5 EVALUATION
In this section we evaluate our proposal, on various demonstrat-ing examples from the literature on formal requirements speci-fications. We compute goal-conflicts for each of them, following
the approach presented in [ 15], and then perform model counting
experiments as described in the previous section. All the experi-ments were run on an Intel Core i5 4460 processor, 3.2Ghz, with8Gb of RAM, running GNU/Linux (Ubuntu 16.04). The scripts torun the experiments, the specifications for all case studies, and a
description of how to reproduce the experiments, can be found in
https://dc.exa.unrc.edu.ar/staff/rdegiovanni/ICSE2018.html .
5.1 Case Studies and Conflict Detection
Weevaluateourapproachonthefollowingdemonstratingexam-
ples takenfrom theliterature:the MinePump Controller[ 30],the
ATM [39],theLondonAmbulanceService(LAS)[ 21],theRailRoad
CrossingSystem[ 8],theTCPnetworkprotocol,andTelephone[ 18].
Table3summarizesthesizeofeachspecification,intermsofthe
correspondingnumberofdomainpropertiesandgoals,thenumber
of computed boundary conditions, and the time it took the toolfor the corresponding computation. Notice that only for three case
studies, namely, MPC, ATM and TCP, the tool produced more than
one boundary condition.
Table3:CaseStudies:ComputationofBoundaryConditions.
Case Study Spec. Size BCsTime (sec.)
MPC 3 2 11
ATM 3 3 2.71
LAS 5 111.68
RRCS 4 1 0.50
TCP 2 2 1.31
Telephone 5 111.43
5.2 Goal-Conflict Likelihood Evaluation
We already presented in Table 1 the model counting based analysis
of conflicts for the Mine Pump Controller. Table 4 summarizes the
results of the same assessment, for the boundary conditions identi-
fiedforeachoftheremainingcasestudies.Thisinformationisalso
graphicallydepicted,asgraphsplottingthenumberofmodelsof
boundaryconditionsinrelationtothemodelsofthecorresponding
domain properties, as the length trace is increased, in Figure 3.
Noticethat, normally, onewouldexpect thatmodelsofdomain
properties grow exponentially as the trace length is increased. Arelatively unlikely boundary condition may cover an important
numberofmodelsforasmall k(wheretheoverallnumberofmodels
forthedomainpropertiesissmall),butasthetracelengthincreases,
the ratio between models of the boundary condition and models of
the domain properties should exponentially decrease.
Let us focus, for instance, on the plot for the MPC case study.
Noticethat theabove observation appliesto BC1:as tracelength
isincreased,theprobabilityofreaching BC1(i.e.,3(hw‚àßm))de-
creasesexponentially.Ontheotherhand,theprobabilityofreaching
BC2remainsmorestable,andinfactquicklybecomesmorelikely
thanBC1as trace length grows. The engineer should prioritize the
treatment of BC2overBC1for resolution.
A similar observation applies to the ATM case study. Observing
theATMboundaryconditionsplot,wenoticethat,althoughinitiallytheprobabilityofreaching
BC1ismuchgreaterthanthatofreaching
BC2andBC3,bothBC1andBC2showanexponentialdecreaseas
tracelengthgrows(infact, BC2showsaverysmallprobabilityof
occurring right from the beginning). On the other hand, notice
how the probability of reaching BC3shows more stability than the
others‚Äô as trace length is increased. Again, the engineer should
prioritize dealing with BC3overBC1andBC2.
Regarding the TCP case study, notice that both probabilities
remainstableastracelengthgrows,but BC1ismorelikelythan BC2
whilethetracelengthisincreased.Theengineershouldprioritize
dealing with BC1overBC2.
For the other three case studies we have only one identified
boundary condition, so no prioritization is needed. Both RRCS and
LASshowanexponentialdecreaseintheprobabilityofreachingthe
corresponding boundary condition as the trace length is increased.
In the case of Telephone, on the other hand, the probability shows
more stability, again calling for attention.
1131
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô18, May 27-June 3, 2018, Gothenburg, Sweden R. Degiovanni, P. Castro, M. Arroyo, M. Ruiz, N. Aguirre, and M. Frias
Table 4: Counting k-bounded word bases for the boundary conditions, for each case study.
Case Study k
ATM 12 3 4 5 6 10 20 50 75 100 1000 Time
#(Dom ,k) 432256 1536 10240 61440 97517568 1.20E+16 2.58E+40 4.87E+60 9.21E+80 8.07E+810 1s
#({Dom ,BC1},k)210 50 190 830 3226 1023346 2.48E+12 4.12E+31 4.30E+47 4.47E+63 1.94E+640 1s
%BC1 0.50.312 0.195 0.123 0.081 0.052 0.010 0,002 0 0 0 0 -
#({Dom ,BC2},k)00 2 8 64 256 425984 5.48E+13 1.17E+38 2.22E+58 4.19E+78 3.68E+808 1s
%BC2 000.008 0.005 0.006 0.004 0.004 0.004 0.004 0.004 0.004 0.004 -
#({Dom ,BC3},k)0216 64 512 2560 4456448 5.74E+14 1.23E+39 2.32E+59 4.39E+79 3.85E+809 1s
%BC3 00.062 0.062 0.042 0.05 0.042 0.046 0.048 0.048 0.048 0.048 0.048 -
TCP 12 3 4 5 6 10 20 50 75 100 1000 Time
#(Dom ,k) 964512 4096 32768 262144 1073741824 1.15E+18 1.42E+45 5.39E+67 2.03E+90 1.23E+903 1s
#({Dom ,BC1},k)324192 1536 12288 98304 402653184 4.32E+17 5.35E+44 2.02E+67 7.63E+89 4.61E+902 1s
%BC1 0.3330.375 0.375 0.375 0.375 0.375 0.375 0.375 0.375 0.375 0.375 0.375 -
#({Dom ,BC2},k)216128 1024 8192 65536 268435456 2.88E+17 3.56E+44 1.34E+67 5.09E+89 3.07E+902 1s
%BC2 0.2220.25 0.25 0.25 0.25 0.25 0.25 0.25 0.25 0.25 0.25 0.25 -
LAS 12 3 4 5 6 10 20 50 75 100 1000 Time
#(Dom ,k)129163842097152 2.68E+8 3.43E+10 4.39E+12 1.18E+21 1.39E+42 2.29E+105 1.09E+148 5.26E+210 1.62E+2107 1s
#({Dom ,BC1},k)903420129960 4.93E*6 1.87E+8 7.13E+9 1.48E+16 9.33E+31 2.31E+79 7.21E+118 2.25E+158 1.43E+1580 1s
%BC1 0.6970.208 0.062 0.018 0.005 0.001 0 0 0 0 0 0 -
RRCS 12 3 4 5 6 10 20 50 75 100 1000 Time
#(Dom ,k)323203052 29196 278264 2647284 2.23E+10 1.51E+20 4.76E+49 1.83E+74 7.08E+98 9.10E+983 1s
#({Dom ,BC1},k)1442258 1686 11514 79026 2.10E+8 7.93E+16 3.85E+42 9.78E+63 2.48E+85 9.05E+855 1s
%BC1 0.4370.131 0.084 0.057 0.041 0.0293 0.009 0.005 0 0 0 0 -
Telephone 12 3 4 5 6 10 20 50 75 100 1000 Time
#(Dom ,k) 964512 4096 32768 262144 1.07E+9 1.15E+18 1.42E+45 5.39E+67 2.03E+90 1.23E+903 1s
#({Dom ,BC1},k)0324 192 1536 12288 5.03E+7 5.40E+16 6.69E+43 2.52E+66 9.54E+88 5.76E+901 1s
%BC1 0.00.047 0.047 0.047 0.047 0.047 0.047 0.047 0.047 0.047 0.047 0.047 - 
 
 
 
 
 

 
 
 
 
 
   
   
 
 
	 

 
  
        






 



 










  !" #$ % & ' ()*  & ')*  & '+, --
+, -
.
+, -/
+, -
0
+, 1
+, 1-
+, 1
.
+, 1/
+, 1
0+
2+ -+ 1+
.+
3+ /+
4+
0+
5+
2++
67 8 9 7 :;< = 972;< = 97->
> ?> @
> ?A
> ?A @
> ?B
> ?B @
> ?C
> ?C @
> ?D
> ?D @> A> B> C> D> @ >E
>F
>G
>H
> A>>
II JK L JMN O
L JAP
P QR
P QS
P QT
P QU
P QV
P QW
P QXP R PS
PT
P UPV
P WP XPY
PZ
P RPP
[\ ] ^ _`a b
^_Rc
cd
cce
cd
cf
cd
cfe
cd
cg
cd
cge
cd
ch
cd
che
cd
ci
cd
cie
cd
cecf
c gch
ci
ce
cj
ck
cl
cm
cf
cc
no p oq rsto u vwx y
uvf
Figure 3: Plotting boundary condition models in relation to domain models, as trace length increases.
Let us now turn our attention to how the identified boundary
conditionsaffectthegoals.Therelationshipbetweenthenumberof
modelsofeachgoal,andthenumberofthesemodelsthatreachthecorrespondingboundaryconditionisgraphicallyplottedinFigure4
(due to space restrictions, the table is available in the site).
Let us first analyze the MPC case. As it can be seen in the plots,
both BCsseriously affectsthe satisfactionof thegoals (recallthat,for the effect of boundary conditions on the satisfaction of the
goals, the smaller the number, the worse). In particular, notice that
boundarycondition BC2,themostlikelyconflict,affectstoagreater
extent the satisfaction of goal G1, compared to its effect on the
satisfaction of G2. So, we would recommend the engineer that goal
G2(G(hw‚Üí/circlecopyrt (po)))istheonethatshouldreceivemoreattention,
in relation to boundary condition BC1(3(hw‚àßm)). A common
1132
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. Goal-Conflict Likelihood Assessment based on Model Counting ICSE ‚Äô18, May 27-June 3, 2018, Gothenburg, Sweden
mechanismforrequirementsimprovement,inthesesituations,is
goalrefinementbystrengthening.Infact,theidentifiedsituation
leads to a well known action for this case study, present in the
literature, namely, solving the conflict by strengthening goal G2to
get rid of the conflict. A solution is based on replacing the original
goal with: G/prime
2=G(hw‚àß¬¨m‚Üí/circlecopyrt (po)).
Regarding the ATM case study, we previously indicated that
BC3is more likely than the other boundary conditions. In addition,
given the plots in Figure 4, we can notice that boundary condition
BC3affects more the satisfaction of goal G1than the satisfaction
of goalG2. So then our approach would suggest the engineer to
focus on G1, in relation to conflict BC3, for refinements (a closer
lookattheconflictingsituationshowsthatthisboundarycondition
isenabledbya weakcharacterizationofthedomaininrelationto
account unblocking, that directly affects G1).
WithrespecttotheTCPexample,wepreviouslymentionedthat
BC1ismorelikelythan BC2.TheplotsinFigure4indicatethat BC1
affects more the satisfaction of goal G1, whileBC2strongly affects
more the satisfaction of goal G2. Thus, our approach would recom-
mendtheengineertofocusongoal G1whenresolvingconflict BC1,
and focus on goal G2when resolving conflict BC2.
Now, regardingthe RRCScase study, noticethat BC1G2 is con-
stantlyzero,indicatingthat,throughboundarycondition BC1,goal
G1cannot be violated without violating G2at the same time. Thus,
concentrating in resolving the conflict between BC1andG2, i.e.,
trying to avoid violating G2, directly implies that the chances of
violating G1are decreased.
In the case of Telephone, both goals are equally affected by
boundarycondition BC1.InthecaseofLAS,boundarycondition
BC1affects to a greater extent goals G2andG3, but there is no a
significant difference. All the goals are affected in a similar way,
suggesting that these should be resolved as a whole.
Regarding the scalability of our approach, notice that the ex-
perimentsuse goalmodels forwhich conflictsare computedauto-
matically, andthen use model counting onthe obtained boundary
conditions.Whilemodelcountingisefficient(theexperimentsscale
wellonformulabehavioursofupto1000stepsormore),thecom-
pleteapproachhasabottleneckintheconflictdetectionphase:itis
verycostly, dueto itbeing basedonLTL tableau[ 15].However, if
goals and conflicts are provided (e.g., computed previously, manu-
ally identified), then the model counting phase can be applied with
improved scalability compared to the complete approach. Dealing
withmorecomplexcasestudiesrequiresformalgoalmodelswith
pre-identifiedconflicts(mostintheliteratureidentifyobstaclesthat
affect only one goal, deeming the analysis of conflict impact on
different goals less interesting).
Noticethat,insteadofusingourapproach,onemightthinkof
using [11] with a uniform probabilistic distribution to estimate
conflictslikelihood.However,thisisdifferenttoourapproach.A
uniform distribution with [ 11] would apply to all executions of
the system, but our approach calculates likelihood using partial
executions. E.g., in a goal decomposition into two leaves, imposing
auniformprobabilityimpliesassigning50%chanceseachleaf,over-
ruling other possible executions. In our approach, we use partial
executionstoanalyzeinwhichofthesewereachaBC,butother
possiblepartialexecutionsbesidesthetwocasesarealsoconsidered.
See the site for further details.6 RELATED WORK
Detectinginconsistenciesinrequirementsspecificationsisavery
challenging problem that has received significant attention [ 24,25,
29]. Inconsistency management, i.e., how to deal with inconsisten-
cies in requirements, has also been the focus of several studies, in
particularontheformalside,e.g.,[ 16,17,23,36,41].Muchworkhas
beendoneonthequalitativeend,e.g.,[ 22,35],wherethegeneral
focushasbeenonidentifyingcontradictorylow-levelrequirements
and computing the degree to which goals are satisfied or denied
by them. In general, these approaches focus on the relation be-
tweennon-functionalandbehaviouralrequirements.Ourapproach
tacklesaproblemofafinergranularity.Weproposetheuseofan
approach for identifying inconsistencies, that are captured via the
generation of boundary conditions (i.e., declarative expressions)that characterize different conflicting situations, and introduce anovel approach to classify these according their likelihood and
severityonthegoals.Thisinformationcanthenbeusedtoguide
the engineer when goal refinements are required.
Inthecontextofgoal-orientedrequirementsengineering,most
of the work contributing to risk analysis [ 4,11‚Äì13,43] has been
restrictedto obstacles,aparticularkindofconflicts,makingthem
ineffectiveinsituationsthatarisewhenthegoalsthemselvesare
conflicting.Theworksin[ 15,41],ontheotherhand,focusongoal-
conflictsidentification,butdonotprovideanymechanismtoassess
the criticality of the computed conflicts. In contrast to these works,
ourapproachprovidesamoregeneralsupporttoriskanalysis:it
buildsuponamechanismtocomputegeneralgoalsconflicts,not
only obstacles, and puts forward a quantitative approach to assess
how likely and severe the identified conflicts are.
A work particularly close to our approach is that presented
in [11], where a probabilistic framework to propagate obstacle
probabilities into the obstacle/goal model is proposed, that enables
onetocalculatethelossofsatisfactionoftheobstructedgoals.This
approach assumes that certain probabilistic information on the
domain is provided. More precisely, it assumes that the likelihood
of the leaf obstacle is known, having been previously elicited from
some experience users, statistical data or some other source. As
we mentioned earlier in the paper, our approach tries to help in
situationwheresuchinformationisunavailable,andadoptsamodel
countingmechanismtoassessthelikelihoodofagivenidentified
conflict being reached, and its impact on the goals.
Our work applies to specifications formally captured as LTL
formulas.OnenaturalchoicewouldbetoresorttoanLTLmodel
counter, as that presented in [ 20], for the purposes of this paper.
Whiletheworkin[ 20]dealswiththekindofcanonicalLTLmodels
weareinterestedin,namely,wordmodels,theapproachisonlyable
todealwithsafetyproperties,makingitunsuitableforourpurposes.
Another alternative is to translate the LTL formula to a proposi-
tional formula, given a bound k, and then exploiting some proposi-
tionalmodelcounterto,indirectly,countthenumberofinstancesoftheoriginalLTLformula.Despitethefactthatthereexistvariousef-ficientpropositionalmodelcounters,e.g.,
RelSAT[28],cachet[37]
andsharpSAT [38],thereductiontopropositionalcountingleads
us to constraints with thousands of variables that cannot be effi-
cientlyhandled.Forthesereasons,inthisworkweusearecently
presentedstringmodelcounter ABC[5],thathasbeendemonstrated
1133
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô18, May 27-June 3, 2018, Gothenburg, Sweden R. Degiovanni, P. Castro, M. Arroyo, M. Ruiz, N. Aguirre, and M. Frias 
    
   

    
   

    
   

    
   
	   
   
    
   
	  
    
    

 
  
  
  
  
  
  
  
  
               
!" #$% &' ()*+
)*+
)
,
,
-,
.
,
-/
,
-/
.
,
- 0
,
- 0.
,
-1
,
-1
., /,
0, 1, 2,
., 3 , 4 , 5, 6, /, ,
78 9 :/;< /
:/;<
0:/;< 1
:/=
=
>=
?
=
>@
=
>@ ?
=
>A
=
>A ?
=
>B
=
>B
?=
@=
A= B=
C=
?=
D=
E=
F=
G=
@==
HI J K ALM @ KALM A KALMB
KA
NO PQ
NO PR
NO S
NO SS
NO S
T
NO SQ
NO SR
NO U
NO US
NO U
T
NO UQN PN SN UN
TN VN QN WN RN XN PN N
YZ [ \P]
ZP
\P]
ZS
\P^
^
_^
`
^
_ a
^
_ a`
^
_ b
^
_ b`
^
_c
^
_c
`^
a^
b^ c^
d^
`^
e^
f^
g^
h^
a^ ^
ij k l bm ja l bm jb l bn
no
np
no
q
no
qp
nor
nor pn qnr
ns
nt
np
nu
nv
nw
nx
n qnn
yyz { | q } ~ |r¬Ä
zq | q¬Ä
zq |r¬Å
¬Å¬Ç¬É
¬Å¬Ç
¬Ñ
¬Å¬Ç¬Ö
¬Å¬Ç
¬Ü
¬Å¬Ç¬á
¬Å¬Ç
¬à
¬Å¬Ç¬â
¬Å¬Ç
¬ä¬Å¬É
¬Å ¬Ñ¬Å¬Ö
¬Å ¬Ü¬Å¬á
¬Å ¬à¬Å¬â
¬Å ¬ä¬Å¬ã
¬Å¬É
¬Å¬Å
¬å¬ç ¬é ¬è¬É
¬ê¬è ¬Ñ ¬ê¬è¬Ö
¬ê ¬è ¬Ü ¬ë¬í¬ì ¬è¬á¬î¬ï ¬É
¬è¬É¬î¬ï ¬É
¬è¬Ñ¬î¬ï ¬É
¬è¬Ö¬î¬ï ¬É
¬è¬Ü¬î¬ï ¬É
¬è¬á¬ñ
¬ñ¬ó
¬ñ ¬ñ¬ò
¬ñ¬ó
¬ñ ¬ñ¬ô
¬ñ¬ó
¬ñ ¬ñ¬ö
¬ñ¬ó
¬ñ ¬ñ¬õ
¬ñ¬ó
¬ñ¬ú
¬ñ¬ó
¬ñ ¬ú¬ò
¬ñ¬ó
¬ñ ¬ú¬ô
¬ñ¬ó
¬ñ ¬ú¬ö
¬ñ¬ó
¬ñ ¬ú¬õ
¬ñ¬ó
¬ñ¬ò¬ñ ¬ú¬ñ¬ò
¬ñ¬ù
¬ñ¬ô
¬ñ¬û
¬ñ ¬ö¬ñ¬ü
¬ñ ¬õ¬ñ¬†
¬ñ ¬ú¬ñ¬ñ
¬°¬¢ ¬£ ¬¢¬§¬•¬¶¬ß¬¢ ¬® ¬ú ¬© ¬ß¬™ ¬®¬ò¬´¬¨
¬ú ¬®¬ú¬´¬¨
¬ú ¬®¬ò
Figure 4: The effect of Boundary Conditions on Goal Satisfaction.
tobeveryefficientwhenappliedtocomplexstringconstraints.The
scalability of ABCis related to the factthat it asks for satisfiability
only once, producinga generating function that canbe evaluated
for big values of kvery efficiently.
Model counting techniques have been recently used in novel
waystoprovidequantitativeinformationrelatedtorelevantsoft-
ware engineering problems. For instance, in [ 19] a model count-
ing algorithm is defined with the aim of counting the number of
datastructuresthatsatisfyagiveninvariant,generalizingmodelcounting techniques that are restricted to linear constraints, and
enablingapplicationsinprobabilisticsoftwareanalysis.In[ 44],a
modelcounterforlinearconstraintsisusedinthecontextofmu-
tation testing, to determine how difficult it is to kill a particularmutant. We consider that our approach also presents an original
application of model counting techniques, in our case, to aid in the
construction of requirements specifications.
7 CONCLUSION
Gettingacorrectandsufficientlycompleteunderstandingofwhata
software system to be developed should do is a crucial step toward
a successful development project, and the subject of challenging
research in software engineering. Among the many problems that
arise while producing a software requirements specification, iden-
tifyinganddealingwithinconsistenciesinrequirements,asearlyaspossible,hasamajorsignificance,bothfromaeconomicalper-
spective,helpingtoavoidcostlysoftwarereworks,andofcourse
in terms of its impact in software quality. In this paper we havepresented an approach that builds upon a technique for identify-
ing subtle conflicting situations in requirements specifications, the
so called goal conflicts, and proposes the use of modern model
counting techniques to assess the criticality of these conflicts, and
the severity of their impact in system goals‚Äô satisfaction. While re-lated techniques deal with this issue, they require the provision of
probabilistic information regarding the likelihood of some system
events, a knowledge that must be gathered from statistical data,
stakeholders‚Äô experience or system simulations. Our approach, on
the other hand, is to the best of our knowledge the only one that is
abletoquantitativelyassessgoalconflictsandtheirimpactwhen
such information is unavailable. Indeed, our approach does not re-
quireaprobabilisticmodeloftheenvironment;instead,itcomputes
probabilities by counting how many models satisfy a conflicting
situation, among the models that satisfy the requirements assump-
tions, and similar kinds of calculations. We showed, through the
analysisofvariouscasestudies,thatthisinformationcanbevery
useful for the engineer, in tasks such as prioritizing the resolution
of certain goal conflicts, and directing attention to most affected
goals for their refinement.
1134
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. Goal-Conflict Likelihood Assessment based on Model Counting ICSE ‚Äô18, May 27-June 3, 2018, Gothenburg, Sweden
REFERENCES
[1] Jflap. urlhttp://www.jflap.org.
[2]Lamaconv‚Äîlogics and automata converter library. urlhttp://www.isp.uni-
luebeck.de/lamaconv.
[3]Bowen Alpern and Fred B. Schneider. Defining liveness. Inf. Process. Lett. ,
21(4):181‚Äì185, 1985.
[4]Dalal Alrajeh, Jeff Kramer, Axel van Lamsweerde, Alessandra Russo, and Se-
basti√°n Uchitel. Generating obstacle conditions for requirementscompleteness.
In34thInternationalConferenceonSoftwareEngineering,ICSE2012,June2-9,2012,
Zurich, Switzerland, pages 705‚Äì715, 2012.
[5]Abdulbaki Aydin, Lucas Bang, and Tevfik Bultan. Automata-based model count-
ing for string constraints. In Computer Aided Verification - 27th International
Conference, CAV 2015, San Francisco, CA, USA, July 18-24, 2015, Proceedings, Part
I, pages 255‚Äì272, 2015.
[6]ChristelBaierandJoost-PieterKatoen. PrinciplesofModelChecking. TheMIT
Press, May 2008.
[7]Benjamin Barre, Mathieu Klein, Maxime Soucy-Boivin, Pierre-Antoine Ollivier,
and Sylvain Hall√©. Mapreduce for parallel trace validation of LTL properties. In
ShazQadeerandSerdarTasiran,editors, RuntimeVerification,ThirdInternational
Conference, RV 2012, Istanbul, Turkey, September 25-28, 2012, Revised Selected
Papers,volume7687of LectureNotesinComputerScience,pages184‚Äì198.Springer,
2012.
[8]Adrian Beer, Stephan Heidinger, Uwe K√ºhne, Florian Leitner-Fischer, and Stefan
Leue. Symboliccausalitycheckingusingboundedmodelchecking. In Proc.of
the 22nd Intl. Sym. on Model Checking Software, pages 203‚Äì221, 2015.
[9]ArminBiere,AlessandroCimatti,EdmundM.Clarke,andYunshanZhu.Symbolic
model checking without bdds. In Proceedings of the 5th International Conference
on Tools and Algorithms for Construction and Analysis of Systems, TACAS ‚Äô99,
pages 193‚Äì207, London, UK, UK, 1999. Springer-Verlag.
[10]Nikolaj Bj√∏rner, Anca Browne, Michael Col√≥n, Bernd Finkbeiner, Zohar Manna,
Henny Sipma, and Tom√°s E. Uribe. Verifying temporal properties of reactive
systems: A step tutorial. Formal Methods in System Design, 16(3):227‚Äì270, 2000.
[11]Antoine Cailliau and Axel van Lamsweerde. A probabilistic framework for goal-
oriented risk analysis. In 2012 20th IEEE International Requirements Engineering
Conference (RE), Chicago, IL, USA, September 24-28, 2012, pages 201‚Äì210, 2012.
[12]AntoineCailliau andAxelvanLamsweerde. Integratingexceptionhandlingin
goal models. In IEEE 22nd International Requirements Engineering Conference, RE
2014, Karlskrona, Sweden, August 25-29, 2014, pages 43‚Äì52, 2014.
[13]Antoine Cailliau and Axel vanLamsweerde. Handling knowledgeuncertainty in
risk-based requirements engineering. In 23rd IEEE International Requirements
Engineering Conference, RE 2015, Ottawa, ON, Canada, August 24-28, 2015, pages
106‚Äì115, 2015.
[14]Anne Dardenne, Axel van Lamsweerde, and Stephen Fickas. Goal-directed
requirementsacquisition. In SCIENCEOFCOMPUTERPROGRAMMING,pages
3‚Äì50, 1993.
[15]RenzoDegiovanni,Nicol√°sRicci,DalalAlrajeh,PabloF.Castro,andNazareno
Aguirre. Goal-conflict detection based on temporal satisfiability checking. In
Proceedingsofthe31stIEEE/ACMInternationalConferenceonAutomatedSoftware
Engineering, ASE 2016, Singapore, September 3-7, 2016, pages 507‚Äì518, 2016.
[16]ChristianEllen,SvenSieverding,andHardiHungar. Detectingconsistenciesand
inconsistencies of pattern-based functional requirements. In Proc. of the 19th
Intl. Conf. on Formal Methods for Industrial Critical Systems, pages 155‚Äì169, 2014.
[17]Neil A. Ernst, Alexander Borgida, John Mylopoulos, and Ivan J. Jureta. Ag-ile requirements evolution via paraconsistent reasoning. In Proc. of the 24th
Intl. Conf. on Advanced Information Systems Engineering, pages 382‚Äì397, 2012.
[18]AmyP.FeltyandKedarS.Namjoshi. Featurespecificationandautomatedconflict
detection. ACM TOSEM, 12(1):3‚Äì27, 2003.
[19]Antonio Filieri, Marcelo F. Frias, Corina S. Pasareanu, and Willem Visser. Model
countingforcomplexdatastructures. In ModelCheckingSoftware-22ndInter-
national Symposium, SPIN 2015, Stellenbosch, South Africa, August 24-26, 2015,
Proceedings, pages 222‚Äì241, 2015.
[20]Bernd Finkbeiner and Hazem Torfah. Counting models of linear-time temporal
logic. In Adrian Horia Dediu, Carlos Mart√≠n-Vide, Jos√© Luis Sierra-Rodr√≠guez,
andBiancaTruthe,editors, LanguageandAutomataTheoryandApplications-8th
InternationalConference,LATA2014,Madrid,Spain,March10-14,2014.Proceedings,
volume 8370 of Lecture Notes in Computer Science, pages 360‚Äì371. Springer, 2014.
[21]A. Finkelstein and J. Dowell. A comedy of errors: The london ambulance service
case study. In Proceedings of the 8th International Workshop on Software Spec-
ification and Design , IWSSD ‚Äô96, pages 2‚Äì, Washington, DC, USA, 1996. IEEE
Computer Society.[22]Paolo Giorgini, John Mylopoulos, and Roberto Sebastiani. Goal-oriented require-
mentsanalysisandreasoninginthetroposmethodology. EngineeringApplications
of Artificial Intelligence, 18(2):159 ‚Äì 171, 2005.
[23]David Harel, Hillel Kugler, and Amir Pnueli. Synthesis revisited: Generatingstatechart models from scenario-based requirements. In Formal Methods in
SoftwareandSystemsModeling:EssaysDedicatedtoHartmutEhrigontheOccasion
of His 60th Birthday, pages 309‚Äì324, 2005.
[24]J.H. Hausmann,R.Heckel, andG. Taentzer. Detectionof conflictingfunctional
requirements in a use case-driven approach. In ICSE, pages 105‚Äì115, 2002.
[25]Sebastian J.I. Herzig and Christiaan J.J. Paredis. A conceptual basis for inconsis-
tency management in model-based systems engineering. Procedia CIRP, 21:52 ‚Äì
57, 2014.
[26]Gerard J. Holzmann. The SPIN Model Checker - primer and reference manual.
Addison-Wesley, 2004.
[27]IEEE. Ieee recommended practice for software requirements specifications, 1998.
[28]RobertoJ.BayardoJr.andRobertSchrag.UsingCSPlook-backtechniquestosolve
real-worldSATinstances. In ProceedingsoftheFourteenthNationalConference
onArtificialIntelligenceandNinthInnovativeApplicationsofArtificialIntelligence
Conference,AAAI97,IAAI97,July27-31,1997,Providence,RhodeIsland.,pages
203‚Äì208, 1997.
[29]M.Kamalrudin. Automatedsoftwaretoolsupportforcheckingtheinconsistency
of requirements. In ASE, pages 693‚Äì697, 2009.
[30]J.Kramer,J.Magee,andM.Sloman.CONIC:Anintegratedapproachtodistributed
computer control systems. In IEE Proc., Part E 130, pages 1‚Äì10, 1983.
[31]LeslieLamport. Provingthecorrectnessofmultiprocessprograms. IEEETrans.
Software Eng., 3(2):125‚Äì143, 1977.
[32]Timo Latvala, Armin Biere, Keijo Heljanko, and Tommi A. Junttila. Simple
bounded LTL model checking. In Formal Methods in Computer-Aided Design, 5th
International Conference, FMCAD 2004, Austin, Texas, USA, November 15-17, 2004,
Proceedings, pages 186‚Äì200, 2004.
[33]JeffMageeandJeffKramer. Concurrency-statemodelsandJavaprograms(2.ed.).
Wiley, 2006.
[34]ZoharMannaandAmirPnueli. TheTemporalLogicofReactiveandConcurrent
Systems. Springer-Verlag New York, Inc., New York, NY, USA, 1992.
[35]J.Mylopoulos,L.Chung,andB.Nixon. Representingandusingnonfunctional
requirements:Aprocess-orientedapproach. IEEETrans.Softw.Eng.,18(6):483‚Äì
497, June 1992.
[36]Tuong Huan Nguyen, Bao Quoc Vo, Markus Lumpe, and John Grundy. KBRE:
a framework for knowledge-based requirements engineering. Software Quality
Journal, 22(1):87‚Äì119, 2013.
[37]TianSang,FahiemBacchus,PaulBeame,HenryA.Kautz,andToniannPitassi.
Combining component caching and clause learning for effective model counting.
InSAT 2004 - The Seventh International Conference on Theory and Applications of
Satisfiability Testing, 10-13 May 2004, Vancouver, BC, Canada, Online Proceedings,
2004.
[38]MarcThurley. sharpsat-countingmodelswithadvancedcomponentcaching
and implicit BCP. In Theory and Applications of SatisfiabilityTesting- SAT 2006,
9th InternationalConference,Seattle, WA, USA,August12-15, 2006,Proceedings,
pages 424‚Äì429, 2006.
[39]Sebasti√°nUchitel,JeffKramer,andJeffMagee. Synthesisofbehavioralmodels
from scenarios. IEEE Trans. Software Eng., 29(2):99‚Äì115, 2003.
[40]Axel van Lamsweerde. Requirements Engineering - From System Goals to UML
Models to Software Specifications. Wiley, 2009.
[41]Axel van Lamsweerde, Robert Darimont, and Emmanuel Letier. Managing
conflicts in goal-driven requirements engineering. IEEE Trans. Software Eng.,
24(11):908‚Äì926, 1998.
[42]AxelvanLamsweerdeandEmmanuelLetier. Integratingobstaclesingoal-driven
requirements engineering. In Proceedings of the 20th International Conference on
Software Engineering, ICSE ‚Äô98, pages53‚Äì62, Washington,DC, USA, 1998. IEEE
Computer Society.
[43]AxelvanLamsweerdeandEmmanuelLetier. Handlingobstaclesingoal-oriented
requirements engineering. IEEE Trans. Softw. Eng. , 26(10):978‚Äì1005, October
2000.
[44]Willem Visser. What makes killing a mutant hard. In Proceedings of the 31st
IEEE/ACMInternationalConferenceonAutomatedSoftwareEngineering,ASE2016,
Singapore, September 3-7, 2016, pages 39‚Äì44, 2016.
[45]Eric S. K. Yu. Towards modeling and reasoning support for early-phase require-
ments engineering. In Proceedings of the 3rd IEEE International Symposium on
Requirements Engineering, RE ‚Äô97, pages 226‚Äì, Washington, DC, USA, 1997. IEEE
Computer Society.
1135
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. 