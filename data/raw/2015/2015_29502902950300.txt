On Well-Separation of GR(1) Speciï¬cations
Shahar Maoz
School of Computer Science
Tel Aviv University, IsraelJan Oliver Ringert
School of Computer Science
Tel Aviv University, Israel
ABSTRACT
Specications for reactive synthesis, an automated proce-
dure to obtain a correct-by-construction reactive system,
consist of assumptions and guarantees. One way a controller
may satisfy the specication is by preventing the environ-
ment from satisfying the assumptions, without satisfying the
guarantees. Although valid this solution is usually undesired
and specications that allow it are called non-well-separated.
In this work we investigate non-well-separation in the con-
text of GR(1), an expressive fragment of LTL that enables
ecient synthesis. We distinguish dierent cases of non-
well-separation, and compute strategies showing how the
environment can be forced to violate its assumptions. More-
over, we show how to nd a core, a minimal set of assump-
tions that lead to non-well-separation, and further extend
our work to support past-time LTL and patterns.
We implemented our work and evaluated it on 79 speci-
cations. The evaluation shows that non-well-separation is a
common problem in specications and that our tools can be
eciently applied to identify it and its causes.
CCS Concepts
Software and its engineering !Formal methods;
Keywords
reactive synthesis, GR(1), well-separation, assumptions
1. INTRODUCTION
Reactive synthesis is an automated procedure to obtain
a correct-by-construction reactive system from its temporal
logic specication [22]. Rather than manually constructing
an implementation and using model checking to verify it
against a specication, synthesis oers an approach where
a correct implementation of the system is automatically ob-
tained for a given specication, if such an implementation
exists. In the case of reactive synthesis, an implementationis typically given as a controller, i.e., an automaton that ac-
cepts input from the environment (e.g., from sensors) and
produces the system's output (e.g., commands for actuators)
to always satisfy the specication.
One challenge for applying reactive synthesis to software
engineering practice relates to the process of writing the
specication, which typically consists of assumptions and
guarantees. Assumptions play an important role as they de-
scribe the possible environments a system has to operate in.
One way a controller may satisfy the specication is by pre-
venting the environment from satisfying the assumptions,
without satisfying the guarantees. Although valid, this vac-
uous solution to the reactive synthesis problem is usually
undesired. Following Klein and Pnueli [13], we call speci-
cations that allow this solution non-well-separated .
In this work we investigate non-well-separated specica-
tions in the context of GR(1), a fragment of LTL, which
has an ecient polynomial time symbolic synthesis algo-
rithm [6, 21] and whose expressive power covers most of the
well-known LTL specication patterns of Dwyer et al. [9,
16]. We distinguish dierent cases of non-well-separation,
and compute strategies showing how the environment can
be forced to violate its assumptions. Moreover, we show
how to nd a core, a minimal set of assumptions that lead
to non-well-separation, and further extend our work to sup-
port past-time LTL and patterns.
Specically, rst, we present an algorithm for the diag-
nosis of non-well-separated environment specications (see
Sect. 4.1). The algorithm checks for well-separation and
distinguishes several cases: it identies whether the envi-
ronment can be forced to violate its assumptions from all
initial or only from some reachable states, and whether the
safety or the liveness assumptions can be forced to be vio-
lated. The distinction between the dierent cases is impor-
tant for the following strategy synthesis: in case our algo-
rithm identies non-well-separation, we synthesize strategies
that demonstrate how the environment can be forced to vi-
olate its assumptions (see Sect. 4.2).
Second, we dene and show how to compute a non-well-
separated core , a minimal subset of assumptions that already
makes the environment specication non-well-separated (see
Sect. 5). As shown in our evaluation, see below, the core is
indeed typically much smaller than the original set of as-
sumptions, facilitating better focus on the reasons for non-
well-separation.
Finally, we show in Sect. 6.1 how the above can correctly
handle extensions of the specication language with past-
time LTL [6] and LTL specication patterns [16]. We present
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proï¬t or commercial advantage and that copies bear this notice and the full citation
on the ï¬rst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciï¬c permission and/or a
fee. Request permissions from Permissions@acm.org.
FSEâ€™16 , November 13â€“18, 2016, Seattle, WA, USA
c2016 ACM. 978-1-4503-4218-6/16/11...$15.00
http://dx.doi.org/10.1145/2950290.2950300
362
Controller
boolean 
atStation 
boolean 
cargo MotorCmd 
mot
LiftCmd 
lift
enum 
MotorCmd 
FWD STOP TURN BWD enum 
LiftCmd 
LIFT DROP NIL Figure 1: A forklift and its controller Controller
further extensions in Sect. 6.
Together, our analyses serve as powerful debugging tools
for specications, which can assist in nding and under-
standing the reasons for non-well-separation in reactive syn-
thesis specications.
We have implemented the above in our GR(1) synthesis
framework, on top of JTLV [23]. We present evaluation
of the diagnosis algorithm and the non-well-separated core
computation on 79 specications created by students who
took a six month project class on reactive synthesis. The
evaluation shows that non-well-separation appears in many
specications, that our diagnosis algorithm is ecient, and
that non-well-separated cores eectively reduce the set of
assumptions one has to consider when trying to understand
the reasons of non-well-separation. See Sect. 7.
Some previous works suggested criteria for environment
specications susceptible to being forced to violate assump-
tions [5, 8, 13]. Our work is partly inspired by these works.
These works, however, did not consider algorithms and au-
tomated means for debugging the problematic environment
specications, computing cores etc., and did not evaluate
the problem on a corpus of specications. Unrealizability
is another common problem of reactive systems specica-
tions, which can be handled using (counter-)strategies and
a notion of core. However, non-well-separation is very dif-
ferent than unrealizability. It requires the construction of
strategies not only from all initial states but also from some
reachable states. Moreover, its core, as we dene it, is made
of assumptions, not guarantees. See Sect. 8.
2. EXAMPLE
We start o with a running example, adapted from our
specication of a Lego forklift, shown in Fig. 11, see [17]. The
forklift has two sensors: one sensor to determine whether it
is at a station and one sensor to detect cargo. It also has
two motors, to drive the forklift and to lift the fork. Values
read by the sensors are provided as inputs to component
Controller and its outputs are commands that control the
motors. All inputs and outputs are typed, e.g., the out-
putmothas type MotorCmd . The datatypes are boolean or
dened as enumerations in Fig. 1.
A team of engineers is writing a specication of the fork-
lift controller to automatically synthesize an implementa-
tion. The main task of the forklift is to traverse an open
area and always eventually deliver cargo; it nds cargo at
stations, lifts it, and drops it at other stations. A bene-
t of synthesizing a controller is that it is guaranteed to
satisfy its specication. However, without any environment
1Note that this is a real Lego robot that we have built. We
use our synthesis tool and code generation to run it.Specification
1ASM findStat : -- always possible to find a station
2 G F ( atStation );
3ASM samePos : -- same station position when stopped
4 G ( mot = STOP -> next ( atStation )= atStation );
5ASM liftCargo : -- lifting clears sensor
6 G ( lift = LIFT -> next (! cargo ));
7ASM dropCargo : -- dropping senses cargo
8 G ( lift = DROP -> next ( cargo ));
9ASM clearCargo : -- backing up clears cargo
10 G ( mot =BWD -> next (! cargo ));
Listing 1: Excerpt of an environment specication
for the forklift controller
assumptions a forklift controller cannot be synthesized. As
an example, the forklift can not ensure that it will nd a sta-
tion to deliver cargo to because the sensors are completely
controlled by the environment. To guarantee the comple-
tion of its task, the forklift has to assume that it will always
nd stations. This is expressed in the assumption G F (at-
Station) named findStat in List. 1, ll. 1-2. The temporal
operator Gintuitively stands for always, i.e., at every state,
and Fstands for eventually, i.e., within nitely many steps.
Additional assumptions in List. 1 describe environment
reactions to actions of the forklift controller. The assump-
tion samePos species that the value of the station sen-
sor remains the same if the forklift stops: G (mot=STOP ->
next(atStation)=atStation) (i.e., stations do not move).
The temporal operator next(v) interprets vin the next time
step; here, the next value of atStation must be equal to its
current value. The next three assumptions follow the same
pattern and restrict the expected environment behavior for
handling cargo. When the forklift lifts cargo the cargo sen-
sor is cleared (assumption liftCargo , l. 5). When it drops
cargo the cargo is detected by the sensor (assumption lift-
Cargo , l. 7). Finally, the forklift can clear the cargo by
moving backward from it (assumption clearCargo , l. 9).
The engineers complete the specication consisting of as-
sumptions and guarantees and successfully synthesize a con-
troller that satises all guarantees if all assumptions hold.
However, once the controller is deployed to the forklift the
team observes strange behavior. Sometimes the forklift drops
cargo and behaves chaotic. An engineer nds out that this
happens when the forklift drives backwards while dropping
cargo. Our new well-separation analysis informs her that
the environment can be forced to violate safety assumptions
from all initial states (diagnosed case ( P-all ,E-safe ), see
Sect. 1). Specically, one of the assumptions dropCargo or
clearCargo can be forced to be violated. She xes the prob-
lematic assumptions by changing the assumption dropCargo
from G (lift=DROP -> next(cargo)) toG (lift=DROP &
mot!=BWD -> next(cargo)) .
After some more runs of the forklift the team observes
that the forklift sometimes stops between stations and does
not continue delivering cargo. It clearly does not continue
to satisfy its guarantees, i.e., some assumption must be vi-
olated. Again, our new well-separation analysis informs the
team that the environment can be forced to violate a jus-
tice assumption from some reachable states (diagnosed case
(P-reach ,E-just ), see Sect. 1). The reason involves the as-
sumption to always eventually nd a station findStat and
the safety assumption samePos (which states that the station
sensor reading does not change when motors are stopped, as
described above). When the forklift is not at a station it
363stops and thus forces the environment to violate its liveness
assumption findStat .
This example shows how non-well-separation can lead to
unexpected behavior of a synthesized controller and how a
small set of relevant assumption can be used to explain the
reason for non-well-separation.
3. PRELIMINARIES
3.1 LTL and GR(1)
We repeat some of the standard denitions of linear tem-
poral logic (LTL), e.g., as found in [6], a modal temporal
logic with modalities referring to time. LTL allows engi-
neers to express properties of executions of reactive systems.
The syntax of LTL formulas is typically dened over a set of
atomic propositions APwith the future temporal operators
X(next) and U(until) and the past-time temporal operators
Y(previous) and S(since).
Definition 1.The syntax of LTL formulas over AP is
'::=pj:'j'_'jX'j'U'jY'j'S'forp2AP.
For  = 2APa computation u=u0u1::2!is a sequence
whereuiis the set of atomic propositions that hold at the
i-th position. For position iwe useu;ij='to denote that
'holds at position i, inductively dened as:
u;ij=pip2ui
u;ij=:iu;i6j=
u;ij='1_'2iu;ij='1oru;ij='2
u;ij=X'iu;i+1j='
u;ij='1U'2i9ki:u;kj='2and
8j;ij <k :u;jj='1
u;ij=Y'iu;i 1j='
u;ij='1S'2i9k;0ki:u;kj='2and
8j;k<ji:u;jj='1
We denote u;0j='byuj='. Additional LTL operators
are dened as abbreviations of the above:
F':=true U'(nally)
G':=:F:'(globally)
'1W'2:= ('1U'2)_G'1(weak until)
H':=:(true S:') (historically)
LTL formulas can be used as specications of reactive sys-
tems where atomic propositions are interpreted as environ-
ment (input) and system (output) variables. An assignment
to all variables is called a state.
A strategy for an LTL specication 'prescribes the out-
puts of a system that from its winning states for all en-
vironment choices lead to computations that satisfy '. A
specication 'is called realizable if a strategy exists such
that for all initial environment choices the initial states are
winning states. This strategy can be represented as an au-
tomaton called a controller. The goal of LTL synthesis is,
given an LTL specication, to nd a controller that realizes
it, if such a controller exists.
GR(1) synthesis [6] handles an assume-guarantee frag-
ment of LTL where specications contain assertions over ini-
tial states, safety constraints relating the current and next
state, and justice constraints requiring that an assertion
holds innitely many times during a computation. A GR(1)
synthesis problem consists of the following elements[6]:X input variables controlled by the environment
Youtput variables controlled by the system
eassertion overXcharacterizing initial environment states
sassertion overX[Y characterizing initial system states
e(X[Y;X) transition relation of the environment
s(X[Y;X[Y ) transition relation of the system
Je
i21::njustice requirements of the environment
Js
j21::mjustice requirements of the system
We also write environment and system specications as
tuplesh;;Ji. GR(1) synthesis has two dierent notions of
realizability, which are expressed in the following LTL spec-
ications [6]. The rst and more intuitive notion is called
implication realizability, because all environment assump-
tions imply all system guarantees:
'!= (e^Ge^^
i21::nGFJe
i)!(s^Gs^^
j21::mGFJs
j)
The second kind of realizability is called strict realizability:
'sr= (e!s)^(e!G((He)!s))^
(e^Ge!(^
i21::nGFJe
i!^
j21::mGFJs
j))
Realizability of 'srimplies realizability of '!. Speci-
cations for GR(1) synthesis have to be expressible in the
above structure and thus do not cover the complete LTL. Ef-
cient symbolic algorithms for GR(1) realizability checking
and controller synthesis for 'srhave been presented in [6,
21]. The algorithm of Piterman et al. [21] computes winning
states for the system, i.e., states from which the system can
ensure satisfaction of 'sr.
3.2 Well-Separation
Klein and Pnueli [13] dened well-separation as a sucient
property of environment specications he;e;Jeisuch that
realizability of 'sris equivalent to realizability of '!. A
well-separated environment can satisfy all assumptions from
every reachable state. We repeat the denition of Klein and
Pnueli adapted to our syntax in Def. 2.
Definition 2 (Well-Separation [13]). A GR(1) en-
vironment specication he;e;Jei, is well-separated i 'sr
has no reachable system winning states for system specica-
tionhtrue;true;ffalsegi.
Note that well-separation is dened as a property of the
environment part of the GR(1) specication, i.e., the as-
sumptions, without the guarantees. Intuitively, the sys-
tem specication htrue;true;ffalsegimeans that initially
and for every step the system choices are unconstrained
(s=true =s) but its justice requirements cannot be sat-
isedJs=ffalseg. Winning strategies for 'srthus have to
force the environment to violate its assumptions.
Klein and Pnueli [13] showed how to reduce implication
realizability to strict realizability. For the system specica-
tion in Def. 2 strict realizability 'srand implication real-
izability'!both reduce to the LTL formula :(e^Ge^V
i21::nGFJe
i). The set of states where the environment can
be forced to violate its assumptions can thus be computed
by the standard GR(1) algorithm.
3644. DEBUGGING NON-WELL-SEPARATION
We start by arguing why well-separation is desired and
why it is necessary to provide tools for debugging non-well-
separated environment specications. We then follow with
an analysis of dierent cases of non-well-separation. These
cases distinguish winning positions and environment speci-
cation parts that can be forced to violate. The cases on the
one hand present an informative summary of well-separation
of the specication and on the other require dierent means
to further explain reasons for non-well-separation. We ex-
plain in Sect. 4.2 how strategies to demonstrate the dierent
cases of non-well-separation can be computed.
Well-separation is a property of the environment specica-
tion, i.e., the assumptions in GR(1) synthesis. In most cases
the environment is specied by the same engineer specify-
ing the guarantees of the system2. Non-well-separation is a
problem in the specications due to two main reasons. First,
controllers that force an environment to violate assumptions
are undesired in general because they do not have to satisfy
their guarantees. Second, we assume that the true environ-
ment (e.g., in the physical world) of the synthesis problem is
well-separated, i.e., cannot be forced to violate its assump-
tions. Thus, it should not be possible to force an environ-
ment to a deadlock or prevent it from satisfying its justice
assumptions. A non-well-separated environment thus points
to a gap or a mismatch between the real environment and
the assumptions describing it, i.e., it points to a problem in
the specication.
Due to its assume-guarantee nature, the GR(1) synthesis
algorithm might exploit non-well-separation and synthesize
controllers that fail in a real environment. Note that accord-
ing to Def. 2 an environment can also be non-well-separated
without a malicious system, i.e., no matter what the system
does the environment has to violate its assumptions. We
consider this again to be an undesirable specication.
We now present approaches to debug non-well-separated
environments by further distinguishing dierent cases of non-
well-separation and presenting methods that assist engineers
in understanding the reasons for non-well-separation.
4.1 Cases of Non-Well-Separation
We distinguish dierent cases of non-well-separation based
on two dierent criteria: winning positions and environment
specication parts.
4.1.1 Winning Positions (all or reachable)
Well-separation in Def. 2 is dened based on winning states
for the system specication htrue;true;ffalsegi, i.e., the
only way for the system to win is to ensure assumption vi-
olations by the environment. Non-well-separation is weaker
than realizability of 'srin Def. 2. Realizability of 'srim-
plies non-well-separation. If the environment specication
is realizable but not non-well-separated there exists a state
that can be reached by environment choice from which the
environment can be forced to violate its assumptions. To dis-
tinguish these two cases we dene the positions from which
a controller can force the violation of assumption:
P-all force violation from all initial environment choices;
P-reach force violation from some reachable state.
2Exceptions that we do not consider here are for example
specications derived from existing components.The rst case P-all means that a controller can always
force the environment to violate its assumptions, i.e., it does
not have to satisfy any guarantee. An example of this case
are the two assumption dropCargo and clearCargo shown
in List. 1: a controller can always force a violation of either
one. The second case P-reach means that during execution
of a controller the environment can reach a state from which
the controller can force it to violate its assumptions, i.e.,
until the state is reached, if ever, all guarantees have to
be satised. An example for this case is the combination
of assumptions samePos and findStat from a state with
station =false . It is easy to see that P-all implies P-
reach but not the other way around.
4.1.2 Env. Parts (initial, safety, or justice)
To express which part of the environment specication can
be forced to be violated we distinguish the following cases:
E-ini all initial environment choices are invalid ( e=false );
E-safe force violation of safety assumptions e(deadlock);
E-just force violation of some justice assumption Je
i2Je.
Both cases of E-ini andE-safe imply the case of E-just ,
i.e., all non-well-separated environment specications are of
case E-just . An example for E-safe are the two assump-
tions dropCargo andclearCargo while the two assumptions
samePos and findStat are only an example for case E-just .
4.1.3 Summarizing Case Combinations
When checking all environment parts and the positions
from which each can be violated we obtain 2 33 possible
combinations of cases ( E-ini may appear with P-all or be
absent, while the other parts may appear with P-all ,P-
reach , or be absent). A combinations of cases might contain
redundancies because one case implies another one, e.g., case
(P-all ,E-safe ) implies ( P-all ,E-just ) and we can summarize
their combination as case ( P-all ,E-safe ).
More formally, we summarize case combinations by den-
ing the total orders P-all<pP-reach andE-ini<eE-safe <e
E-just and their product order on pairs, i.e., the partial or-
der (p1;e1)<pe(p2;e2),p1<pp2^e1<ee2. Finally, we
represent a combination of cases by their smallest elements.
This summarization of case combinations leaves 7 combina-
tions shown in Fig. 2. The only time two cases are reported is
for cases ( P-reach;E-safe ) and ( P-all;E-just ) because these
cases are not comparable in the product order.
The representation in Fig. 2 is ordered from the weak-
est case combination at the top, i.e., well-separation, to the
strongest case combination of non-well-separation f(P-all ,
E-ini )gat the bottom.
4.1.4 An Algorithm to Identify the Cases
Algorithm 1 presents our algorithm to identify non-well-
separation and the cases along the dimensions of winning
positions and environment specication parts. Its input is
an environment specication he;e;Jeiand its output is
a set of cases of non-well-separation. A case of non-well-
separation is reported as a tuple of winning positions P-
allorP-reach and responsible parts of the specication E-
ini,E-safe , orE-just . The algorithm reports summarized
strongest case combinations as discussed in Sect. 4.1.3 and
shown in Fig. 2. Note that the algorithm returns an empty
set i the environment specication is well-separated.
365{} 
{( P-all , E-ini )} {( P-all , E-safe )} {(P-reach ,E-safe ),( P-all ,E-just )} {( P-reach, E-just )} 
{( P-all ,E-just )} {( P-reach , E-safe )} strongest case of non-well-separation 
weakest case, i.e., well-separation Figure 2: Cases of non-well-separation from weakest
case, i.e., well-separation, to strongest case ( P-all,E-
ini); the cases ( P-reach ,E-safe ) and ( P-all,E-just ) are
incomparable
Algorithm 1 Diagnosing non-well-separation cases
1:ifefalse then
2:returnf(P-all;E-ini )g
3:end if
4:deneresas Set
5:reach reachStates (e;e)
6:wins sysWinSts (he;e;;i;htrue;true;ffalsegi)
7:ifwins\reach6=;then
8:if sysWinAllIni (wins;e)then
9: returnf(P-all;E-safe )g
10: end if
11: add (P-reach;E-safe )tores
12:end if
13:win sysWinSts (he;e;Jei;htrue;true;ffalsegi)
14:ifwin\reach6=;then
15: if sysWinAllIni (win;e)then
16: add (P-all ,E-just )tores
17: else ifres=;then
18: add (P-reach ,E-just )tores
19: end if
20:end if
21:returnres
The algorithm starts by rst checking case E-ini of non-
well-separation by testing the satisability of e. Fore=
false the system wins from all positions. It then checks case
E-safe by computing the environment reachable states in
line 5 and the system winning states according to Def. 2 but
forJe=;in line 6. For an empty set of justice assumptions
a system can only win by violating safety assumptions. The
method sysWinSts (:;:) returns all system winning states,
i.e., the Zx-point in the GR(1) algorithm of [6]. If any
of the winning states is reachable, the environment is non-
well-separated (l. 7). In case all initial states are winning
for the system (l. 8) the strongest result is ( P-all;E-safe ).
Otherwise the algorithm also checks the complete environ-
ment specication including Jefor possible system winning
states. This second E-just part in lines 13-20 is analogous
to the rst part of case E-safe but the case ( P-reach ,E-
just) is only added if resis empty, i.e., does not contain the
stronger case ( P-reach ,E-safe ) possibly added in line 11.
The time complexity of Algorithm 1 for n=jJejand state
space sizeNis inO(nN2) because it uses the GR(1) algo-
rithm of [6] to compute sysWinSts (:;:) and its other opera-tions sysWinAllIni (:;:) and reachStates (:;:) are inO(N).
Note that a simple algorithm to check well-separation ac-
cording to Def. 2 without our diagnosis computes the sets
reach (l. 5) andwin(l. 13) and checks for an empty inter-
section (l. 14). The time complexity of this algorithm is also
inO(nN2).
Applied to the example in List. 1, Algorithm 1 reports
f(P-all;E-safe )g. After replacing assumption dropCargo with
its modied version, as suggested in the end of Sect. 2, the
algorithm reports f(P-reach;E-just )g.
4.2 Strategies Forcing Assumption Violation
In addition to identifying and distinguishing the dier-
ent cases of non-well-separation, as a means to further ex-
plain the reasons for non-well-separation to the engineer, we
compute and present concrete strategies that demonstrate
how a system can ensure assumption violations. Dierent
non-well-separation cases require dierent strategy compu-
tations. What is common, is that all strategies are con-
structed from the game memory stored during realizability
checking as implemented in the GR(1) algorithm and de-
scribed in [6].
4.2.1 Winning Positions (all or reachable)
In case the system can force an assumption violation from
all initial states (case P-all ) controller construction is the
same as for regular GR(1) synthesis. A controller constructed
for the system specication htrue;true;ffalsegishows how
to force assumption violations.
The case P-reach and not P-all is more complicated. If
P-all does not hold a controller does not exist because for
some initial environment choices the environment cannot be
forced to violate assumptions. However, from every state
that is winning for the system | here those that can force
assumption violations | a winning strategy exists and can
be computed from the game memory.
The only dierence during strategy computation is the
treatment of initial states. In controller construction for case
P-all the initial states are computed one for every initial
environment choice. Strategy construction from reachable
states in case P-reach starts with all reachable states, i.e.,
possibly multiple assignments to system variables for each
assignment to environment variables.
Understanding reasons for non-well-separation for the case
P-reach might require understanding how the states of the
strategy can be reached from initial states. How these states
are reached might already exhibit environment behavior that
should be restricted by additional assumptions to make the
environment well-separated. To show how a state can be
reached we can simply compute a trace starting with an
initial state and ending with a state in the strategy.
4.2.2 Env. Parts (initial, safety, or justice)
In addition to the distinction between cases P-all and
P-reach we distinguish the environment parts that can be
forced to be violated.
Non-well-separation of case E-ini means that the initial
assumptions of the environment are contradicting. In this
case the system has nothing to do to force assumption vio-
lations so there is no need to discuss it further.
To obtain a controller for case E-safe that shows safety vi-
olations only, we have to use the modied environment spec-
icationhe;e;;i. Otherwise the controller might chose to
366!atStation 
!cargo 
mot=STOP 
lift=LIFT !atStation 
cargo=* 
mot=STOP 
lift=NIL 
!atStation 
cargo 
mot=STOP 
lift=LIFT !atStation 
cargo=* 
mot=STOP 
lift=DROP atStation=* 
cargo=* 
mot=BWD 
lift=DROP 
(a) (b)
controller for all initial environment choices strategy from reachable states Figure 3: (a) A controller forcing violation of as-
sumptions clearCargo ordropCargo for all initial envi-
ronment choices (case ( P-all,E-safe )) and (b) a strat-
egy forcing violation of assumption findStat from
reachable states (case ( P-reach ,E-just )), for the spec-
ication in List. 1
violate a justice assumption in Jeinstead. Strategies for case
E-safe with environment specication he;e;;iinclude only
nite computations.
To obtain a strategy for case E-just we simply use the
game memory computed for the check of Def. 2. Strategies
for case E-just might include innite computations.
4.2.3 Examples
The environment of the example of Sect. 2 shown in List. 1
is non-well-separated of case ( P-all ,E-safe ). A controller
that forces assumption violations is shown in Fig. 3 (a). The
initial choices of the environment are not constrained, i.e.,
the environment can choose all four possible assignments to
the variables atStation and cargo . The controller has a
single initial state labeled with assignments to environment
and system variables. The symbol *denotes all possible val-
ues of a variable, i.e., the symbolic state in Fig. 3 (a) denotes
four concrete states. The controller assigns mot=BWD forcing
!cargo in the next state and lift=DROP forcing cargo in
the next state, i.e., a contradiction and thus an assumption
violation of clearCargo ordropCargo from List. 1.
In the second part of the example of Sect. 2, the assump-
tion dropCargo from List. 1 was changed to G (lift=DROP
& mot!=BWD -> next(cargo)) to resolve the rst non-well-
separation case ( P-all;E-safe ). The modied environment
is non-well-separated of case ( P-reach;E-just ). A strategy
that forces it to violate assumptions from reachable states is
shown in Fig. 3 (b). The strategy is only dened for states
where the forklift is not at a station and stops. The strat-
egy forces the environment to violate the justice assumption
findStat by stopping forever and thus forcing the environ-
ment to always keep atStation set to false .
5. CORES OF NON-WELL-SEPARATION
Every environment specication he;e;Jeiconsists of a
set of assumptions similar to the ones shown in List. 1.
The specication elements e,e, andJemight result from
many assumptions, e.g., for the specication in List. 1 eis
the conjunction of assumptions samePos ,liftCargo ,drop-
Cargo , and clearCargo . To further assist in debugging non-
well-separated environments we compute a minimal sub-
set of the assumptions that demonstrates a reason for non-
well-separation. We call these minimal subsets non-well-
separated cores.5.1 The Importance of Monotonicity
The notion of a core has appeared in works that address
unrealizability, see e.g. [14, 19]. These works rely on the
monotonicity of unrealizability with regard to adding guar-
antees, to make the core denition meaningful and to al-
low its ecient computation. A denition of core with re-
gard to non-well-separation is however challenging, because
non-well-separation by itself is not monotonic with regard to
adding assumptions. Without monotonicity, the reason for
non-well-separation exhibited by a subset of assumptions is
not necessarily a reason for non-well-separation of the orig-
inal specication.
Theorem 1 (Non-Well-Separation not monotonic).
Non-well-separation is not monotonic wrt. adding or remov-
ing assumptions.
Proof. We show counter examples for both cases. (1)
Non-well-separation is not preserved when removing assump-
tions: the non-well-separated environment specication con-
sisting of justice assumption findStat and safety assump-
tion samePos from List. 1 becomes well-separated when re-
moving assumption samePos . (2) Non-well-separation is not
preserved when adding assumptions: the non-well-separated
environment specication consisting of assumptions find-
Stat,samePos becomes well-separated when adding the as-
sumption G (atStation) .
Def. 2 of well-separation includes both the reachable states
and states winning for the system. This provides dierent
possible resolutions of non-well-separation in an environ-
ment specication. Intuitively these are (1) weakening as-
sumptions to remove system winning states and (2) strength-
ening assumptions to remove reachable states. Both cases
are demonstrated in the proof of Theorem 1. It is important
to note that these cases are not exclusive. The dependence
on reachable states and winning states makes the property
of non-well-separation not monotonic.
5.2 Non-Well-Separated Core
To address the non-monotonicity challenge, we provide
a stronger denition of core, which relates to the reachable
states of the original complete specication and ensures that
the reason for non-well-separation exhibited by a core is a
reason for non-well-separation of the original specication.
Thus, we dene a non-well-separated core to be a min-
imal subset of a specication's assumptions which can be
forced to be violated from the reachable states of the origi-
nal specication. Given a set of assumptions ASMwe denote
the environment specication resulting from it by e
ASM,e
ASM
andJe
ASMin Def. 3.
Definition 3 (Non-Well-Separated Core). A non-
well-separated core for a set of assumptions ASMis a minimal
setCASMsuch that
sysWinSts (he
C;e
C;Je
Ci;htrue;true;ffalsegi)\
reachStates (e
ASM;e
ASM)6=;:
Intuitively, we look for a minimal set of assumptions C
that is non-well-separated within the reachable states for
the original set of assumptions ASM. On the one hand this
restriction is natural when debugging non-well-separation of
ASMbecause it relates only to states relevant to the original
367specication. On the other hand the restriction makes the
check monotonic with respect to adding assumptions, i.e.,
for all CC'ASMifCcan be forced to violate its assump-
tion in reachStates (e
ASM;e
ASM) then the same applies to C'
(and ASM). This makes cores as dened in Def. 3 meaning-
ful because the reason for non-well-separation in the core
Cis a reason for non-well-separation in ASM. We show this
monotonicity in Theorem 2.
Theorem 2 (Core Monotonic). The check for a non-
well-separated core Cin Def. 3 is monotonic with respect to
adding assumptions from ASM.
Proof. A strategy to force violation of CASMinreach-
States (e
ASM;e
ASM) is also a strategy to force violation of C'
with CC'ASMinreachStates (e
ASM;e
ASM). Adding
assumptions can only make the environment specication
stronger, i.e., e
C')e
C,e
C')e
C, andJe
CJe
C'. All Cwin-
ning states in reachStates (e
ASM;e
ASM) are also C'winning
states because their successor states in Care deadlocks or
exist in C', i.e., if a strategy can force a deadlock in Cit can
force a deadlock in C'becausee
C')e
C. Otherwise there
exists at least one j2Je
CJe
C'that can be prevented by a
strategy to violate assumptions C. A winning strategy for C
also prevents jinC'becausee
C')e
Cand thus states in C'
have the same or less successor states not satisfying j.
The proof of Theorem 2 also shows how to construct a
strategy to force violation of he
ASM;e
ASM;Je
ASMifrom the result
of checking the GR(1) realizability of C.
5.3 Implementation and Example
We implemented the computation of non-well-separated
cores in our synthesis framework based on JTLV [23] using
the delta-debugging algorithm of Zeller [25] to check sub-
sets of assumptions and compute minimal cores according
to Def. 3. After core computation our tools can construct a
strategy as described in Sect. 4.2 to demonstrate non-well-
separation and present a minimal set of assumptions to the
engineer.
For the example of Sect. 2 shown in List. 1 our core cal-
culation algorithm computes the core fliftCargo ,clear-
Cargog. After the modication of assumption dropCargo as
described in Sect. 2 the core calculation algorithm computes
the corefsamePos ,findStatg.3
6. EXTENSIONS
6.1 Support for Patterns and Past-Time LTL
The LTL fragment of GR(1) is limited to initial con-
straints, safety constraints over the current and next state,
and justice constraints over states to visit innitely often.
This is a very restricted subset of LTL. However, GR(1)
synthesis is quite expressive because deterministic B uchi au-
tomata can be used as assumptions and guarantees [6]. This
additional expressiveness is achieved by adding auxiliary
variables to the GR(1) synthesis problem. In practice, this
allows GR(1) specications to include most LTL specica-
tion patterns of Dwyer et al. [9] as shown in [16] and past-
time LTL as shown in [6].
3Actually, both checks returned the second core, which
is also a core for the rst variant. To obtain the core
fliftCargo ,clearCargogwe had to restrict the analysis
to safety parts of the specication as in Algorithm 1, l. 6.Technically the support of LTL specication patterns and
past-time LTL works by encoding deterministic B uchi au-
tomata or observer automata as additional safety constraints
a,awith auxiliary variables Aencoding the statespace of
the automata. The acceptance of B uchi automata is encoded
as justice assumptions in Jeor justice guarantees in Js. Fi-
nally, a system specication for synthesis with patterns and
past-time LTL is updated to hs^a;s^a;Jsiover the
new system variables Y[A .
As an example consider the following assumption using
the response pattern to express that the forklift can nd a
station by going forward:
ASM res: G(!atStation -> F(atStation | mot!=FWD))
This response formula is not in the GR(1) fragment. It can
however be used in GR(1) synthesis by adding a new Boolean
variable auxtoA, adding aux= true toa, adding next(aux)
<-> ((atStation | mot!=FWD) | aux & atStation) toa,
and adding aux= true toJe. Similar translations exist for
past-time LTL [6]. The translations have in common that
the auxiliary specication parts aandaand the new vari-
ablesAare added on the system side of the specication for
the GR(1) algorithm.
The denition of well-separation in Def. 2 uses the sys-
tem specicationhtrue;true;ffalsegiand thus does not sup-
port patterns and past-time LTL. When naively applying
Def. 2 to specications that use patterns or past-time LTL
in assumptions an analysis automatically yields (potentially
false) negatives. For the example of assumption resthe
systemhtrue;true;ffalsegifully controls the new variable
auxand can thus always prevent the environment justice
aux= true2Je.
We x this inconsistency between the support for pat-
terns and past-time LTL for GR(1) synthesis and the de-
nition of well-separation by replacing the system specica-
tionhtrue;true;ffalsegiin Def. 2 withha
ASM;a
ASM;ffalsegi
wherea
ASManda
ASMare the auxiliary initial and safety con-
straints from the translation of patterns and past-time LTL
that appear as part of assumptions in ASM. The reachable
states to consider for well-separation are accordingly reach-
States (e^a
ASM;e^a
ASM). We update Algorithm 1 with the
restriction of reachable states in line 5 and the system spec-
icationha
ASM;a
ASM;ffalsegiin line 6 and line 13.
In the updated denition of well-separation the assump-
tion resalone will not be identied as a reason for non-well-
separation. The environment can always force aux= true by
either keeping atStation= true or setting atStation= true
after atStation= false .
6.2 Preventing Forced Assumption Violations
via Safety Guarantees
A non-well-separated environment is undesirable because
it might allow synthesis of controllers that force assumption
violations instead of satisfying their guarantees. We have
presented ways to diagnose and debug non-well-separated
environments. In this subsection we consider a dierent
approach: considering the guarantees of a specication to
prevent the system from forcing assumption violations.
From a methodological point of view xing a non-well-
separated environment specication should be preferred to
enable reuse and support evolution of the environment spec-
ication. From a pragmatic point of view it might be enough
that a system guarantees to not force the environment to
368violate assumptions. Recall that the satisfaction of safety
guarantees until assumptions are violated is part of strict re-
alizability semantics 'srbut not implication semantics '!.
As an example, consider a non-well-separated environ-
ment specication consisting of the assumptions dropCargo
and clearCargo from List. 1. A strategy to force assump-
tion violation is dropping cargo to require next(cargo) and
driving backwards to require next(!cargo) . The following
new guarantee dropStop expresses that the system has to
stop when dropping cargo:
GAR dropStop: G(lift=DROP -> mot=STOP)
A system satisfying dropStop cannot force a violation of
an environment specication consisting the two assumptions
dropCargo and clearCargo .
More formally, we dene a weaker version of well-separation
over the complete specication, i.e., all assumptions and
guarantees.
Definition 4 (Well-Separation wrt. Guarantees).
A GR(1) specication with environment he;e;Jeiand sys-
temhs;s;Jsi, is well-separated i
sysWinSts (he;e;Jei;hs;s;ffalsegi)\
reachStates (e^s;e^s) =;:
Note that well-separation implies well-separation with re-
spect to guarantees, but not the other way around. Also
note that a trivial case of well-separation wrt. guarantees
is unrealizability of the safety part of the system, i.e., when
the environment can force the system to a deadlock before
the system can force an assumption violation.
6.3 Annotating Synthesized Controllers
Finally, we present a complementary approach for helping
to understand non-well-separation by annotating a synthe-
sized controller with traceability information (see [20]) of
the assumptions it tries to violate. Note that we now talk
about controllers synthesized for realizing a GR(1) speci-
cation (including system guarantees) and not the ones of
Sect. 4.2 synthesized to show non-well-separation.
Given a controller realizing a specication we annotate
every state in the controller with a reason why it was added
to the controller. The annotations link states to guarantees
the controller tries to satisfy or assumptions it tries to pre-
vent from being satised. An excerpt of a controller for the
forklift is shown in Fig. 4. The system specication for this
example has two justice guarantees to always eventually pick
up cargo, formally, GF (lift=LIFT) , and to always eventu-
ally deliver cargo, formally, GF (lift=DROP) . The upper left
state in Fig. 4 satises the justice guarantee GF (lift=LIFT)
and its successor to the right works towards satisfying the
next justice guarantee GF (lift=DROP) . Note that the state
on the bottom right is annotated as trying to prevent the
justice assumption GF (atStation) . This annotation helps
to identify undesired behavior caused by non-well-separation
and links it to a responsible assumption.
We have implemented this approach in our synthesis envi-
ronment as an extension of [20] for assumption traceability.
7. EVALUATION
We have implemented Algorithm 1, the non-well-separated
core computation of Sect. 5, and the three extensions dis-
cussed in Sect. 6 in our synthesis framework using JTLV [23].
atStation 
cargo 
mot=STOP 
lift=LIFT atStation 
!cargo 
mot=FWD 
lift=NIL 
!atStation 
!cargo 
mot=STOP 
lift=NIL atStation 
!cargo 
mot=FWD 
lift=NIL working towards system 
justice GF (lift=LIFT) working towards system 
justice GF (lift=DROP) satisfying system 
justice GF (lift=LIFT) 
trying to prevent 
environment justice 
GF (atStation)
Figure 4: An excerpt of a synthesized controller an-
notated with reasons why states were added during
controller construction
To evaluate the mechanism we suggest for debugging non-
well-separation we consider the following research questions:
R1Does non-well-separation appear in specications?
R2Can diagnosis be run eciently during development?
R3Does core computation eectively reduce the number of
assumptions to inspect?
7.1 Material and Execution
Only few GR(1) specications are available and these were
usually created by authors of synthesis algorithms or exten-
sions thereof. The most popular GR(1) specications are
AMBA and GenBuf published and used in many works [6,
14, 1]. We consider these specications not well suited for
our evaluation due to their origin and purpose.
To collect more realistic specications we have conducted
a project class on reactive synthesis for undergraduate stu-
dents at Tel Aviv University. The task of the students was
to write GR(1) specications for robotic systems similar to
the case study described in [17] with automation for syn-
thesis and code generation to Lego NXT robots. Students
worked in six teams of two or three students each for the full
duration of a semester. They developed specications using
an extended version of the AspectLTL tools [18] and stored
these in a version control system. The time between the
rst committed specication and the last committed spec-
ication was six month. The typical development cycle of
the students was updating their specication, synthesizing
a controller, and deploying generated code directly on their
robot for validation. The dierent robots were a color sorter,
an elevator, a humanoid, a self-balancing and remotely con-
trolled robot, and two self-parking cars.
The students had tools for synthesis and code generation
but not for detecting or debugging non-well-separation ex-
cept for the possibility to synthesize controllers annotated
with the controller's objective as described in Sect. 6.3.
We have collected a total of 86 specications for six robots
with 2 to 26 revisions per robot.4Seven committed specica-
tions were syntactically invalid. The 79 valid specications
have on average 6 assumptions per specication from a sin-
gle case of 0 up to a maximum of 10 assumptions. The state
space (input, output, and auxiliary variables) ranges from
24to 247(median 227, third quartile 235).
4The specications are available from http://smlab.cs.tau.
ac.il/syntech/separation/.
369non-WS 
60 G 
unreal 
5WS wrt. G 
15 
WS 
19 Figure 5: An overview of the evaluated speci-
cations: 19 are well-separated, 60 are non-well-
separated of which 15 are well-separated wrt. guar-
antees of which 5 have unrealizable safety guarantees
7.2 Results
R1: Occurrence of Non-Well-Separation. We have
analyzed all 79 syntactically valid specications for well-
separation with Algorithm 1 extended to support patterns
and past-time LTL as described in Sect. 6.1.
As a result, only 19 out of 79 environment specications
were found to be well-separated. The algorithm detected
non-well-separation for 60 environment specications.
Algorithm 1 diagnosed the following cases of non-well-
separation: 4 times case ( P-all ,E-safe ), 11 times casef(P-
reach ,E-safe ), (P-all ,E-just )g, 12 times casef(P-reach ,
E-safe ), (P-reach ,E-just )g, 26 times case ( P-all ,E-just ),
and 7 times case ( P-reach ,E-just ). These cases do not only
appear in intermediate versions but also in the nal submis-
sions of the students.
The tool used by the students implements the more robust
strict realizability semantics 'sr. We have thus also checked
whether including the guarantees in the well-separation check
(described as an extension in Sect. 6.2) prevents the sys-
tem from exploiting non-well-separation. Indeed, 15 out of
60 non-well-separated environment specications are well-
separated wrt. guarantees, i.e., the safety guarantees ensure
that the environment cannot be forced to violate assump-
tions. A further check revealed that in 5 out of these 15
cases the well-separation wrt. guarantees is trivially satis-
ed because the safety guarantees are unrealizable. We have
summarized the numbers in an overview in Fig. 5. The left-
most box represents the desired 19 well-separated specica-
tions while the right boxes represent 60 non-well-separated
specications. With strict realizability semantics 20 speci-
cations in the dotted middle box prevent forced assumption
violations (5 trivially by unrealizable safety guarantees).
To answer research question R1: non-well-separation
frequently occurs in environment specications (60
out of 79 specications) and in many specications vio-
lation of an assumption can be forced from all initial
positions (P-all ) (41 out of 79 specications).
R2: Eciency of Diagnosis. It is important that the
diagnosis of non-well-separation is fast and can be executed
frequently by the engineer. We have thus measured running
times of Algorithm 1 for a diagnosis of cases of non-well-
separation for the 79 specications in our evaluation. Again
the algorithm supports past-time LTL and patterns as de-
scribed in Sect. 6.1.
We have run the experiments for measuring diagnosis times
on an ordinary laptop computer with an i7 2.3 GHz CPU
running Windows 10 64Bit, Java 1.7 32Bit, and CUDD 2.4.2
32Bit with automatic variable reordering. Neither our Java
implementation nor CUDD made use of more than one core
of the CPU. The times we report are wall-clock-times mea-sured by the Java API. We repeated each experiment 12
times and report running times in milliseconds for all 12*79
runs on syntactically valid specications.
Due to the small size of some specications many runs
of Algorithm 1 were reported to complete after 0ms. The
minimum time and the rst quartile of all runs are both 0ms.
The median of measured running times is 15ms, the third
quartile is 78ms and the maximum time to run Algorithm 1
on the specications was 250ms. As a reference time for
each specication we have also measured synthesis times,
i.e., time of the realizability check and construction of a
symbolic controller5. We report on the factors that non-
well-separation diagnosis is faster than symbolic controller
synthesis (we removed 452 out of 948 cases where the time of
Algorithm 1 was measured as 0ms). The rst quartile is at
factor 5 (i.e., non-well-separation diagnosis is 5 times faster
than checking realizability and constructing the controller),
the median at factor 9, and the third quartile is at factor 23.
Only for ve very small specications synthesis was faster
than diagnosis and both times measured were below 16ms.
To answer research question R2: diagnosing non-well-
separation using Algorithm 1 is conveniently e-
cient , indeed it is in 75% of the cases more than 5
times faster than the synthesis step , which is exe-
cuted frequently during specication development.
R3: Reduction by Core Computation We are inter-
ested whether the computation of a non-well-separated core
eectively reduces the number of assumptions to consider
for understanding a reason for non-well-separation of the
environment specication.
We have run our core computation algorithm based on
delta-debugging and Def. 3 as described in Sect. 5 on all 60
non-well-separated specications. The results of the com-
putation were minimal sets of assumptions consisting of a
single assumption for 45 specications and of two assump-
tion for 15 specications. The reduction factor rst quartile
is 3, the median is 5, and the third quartile is 6.25.
A non-well-separated core of a single assumption is sur-
prising. We expected a set of assumptions that together
presents a non-well-separation problem. We thus inspected
some of the specications with a singleton core and found
out that indeed the assumptions in the core refer to system
variables the environment cannot control. We rerun the ex-
periments with all system guarantees according to Sect. 6.2
to ensure the analysis did not miss implicit patterns imple-
mented by the students. Except for the 15 specications
where the guarantees prevent forced assumption violation
the cores remained at sizes of one or two assumptions.
To answer research question R3: Core computation eec-
tively reduces the number of assumptions to con-
sider (by a factor larger than 3 in 75% and larger than 5
in 50% of the specications).
7.3 Discussion and Threats to Validity
It is important to note the limitations of our ndings and
threats to their validity. We have based our evaluation on
specications created by students with no prior experience
in LTL and specication writing.
5For most cases concrete controller construction was infeasi-
ble; students executed symbolic controllers on their robots.
370From diagnosing specications we found out that 76%
of the specications are non-well-separated and most non-
well-separated cores consisted of a single assumption. These
rather simple cases of non-well-separation may be due to stu-
dents' unawareness of the problem of non-well-separation,
which was not part of the teaching during the project. More-
over, non-well-separation did not always lead to a visible
problem because our GR(1) implementation uses the more
robust strict realizability semantics 'srand favors progress
over assumption violation during strategy extraction and be-
cause validation by execution on the robot typically did not
exercise many scenarios. Nevertheless, many times students
consulted with us about observed undesired behavior in con-
trollers resulting from non-well-separation, which indicates
that the problem was indeed there, implicitly.
Analyzing multiple revisions of the same specication (from
the version control system used by the students) bares the
risk of using intermediate specications that are more likely
to contain problems. Our observations of development be-
haviors and the low number of committed revisions however
indicate that most versions were considered stable by the
students before committing them. Nevertheless, our debug-
ging techniques are intended to support developers during
all stages of development, including intermediate versions.
Finally, students might have implemented assumption pat-
terns in the specication that were not identied by our
analysis. The analysis is limited to patterns described in
Sect. 6.1. To mitigate this threat we have overapproximated
the pattern implementations by considering all guarantees as
described in Sect. 7.2. We still found that 45 out of 60 non-
well-separated specications remain non-well-separated.
8. RELATED WORK
We give a brief overview of works on the relation between
environment specications and controllers, debugging mech-
anisms for unrealizable specications, and vacuity.
Assumptions: Bloem et al. [4] provide an overview and dis-
cussion how assumptions are treated in reactive synthesis.
They argue that most approaches, e.g., GR(1) synthesis [6,
21], insuciently handle assumption violations. They sug-
gest and later dene [5] cooperative synthesis levels where
the highest level ensures that assumptions and guarantees
are always satised. Ehlers et al. [10] present cooperative
GR(1) synthesis for one of the levels that ensures that from
every state the environment can satisfy its guarantees. Co-
operative synthesis may fail when regular GR(1) synthesis
does not. Our work on well-separation can help in the con-
text of cooperative synthesis because every controller for a
well-separated specication is cooperative.
Well-separation for GR(1) environments has been intro-
duced by Klein and Pnueli [13]. They dened this property
to show when the GR(1) semantics of strict realizability and
implication realizability agree. We have argued for the im-
portance of well-separation in general and extended Klein
and Pnueli's work with more ne-grained analysis of cases,
strategies, a core, implementation and evaluation.
D'Ippolito et al. [8] present GR(1) synthesis for event-
based controllers and dene anomalous controllers that sat-
isfy their specication by forcing assumption violations. The
notion of assumption compatibility in the event-based case
is a dual of well-separation. We believe that the techniques
we introduced can be transferred to debug environments in
the event-based case.Debugging Unrealizability: One may view our work as
using and extending ideas that were recently introduced to
deal with unrealizability (counter strategies, cores), in or-
der to create new means to deal with the challenge of well-
separation. Counter-strategy synthesis for GR(1) and inter-
active execution were presented, e.g., by Cimatti et al. [7],
Konighofer et al. [14], Maoz and Sa'ar for AspectLTL [20]
and for scenarios [19], and Raman and Kress-Gazit [24] in
a robotics domain. Non-well-separation is very dierent
than unrealizability. Compared to our work on non-well-
separation, counter-strategies for unrealizability focus on the
system part and deal only with the case P-all .
Alur et al. [1] suggest a heuristics for xing unrealizabil-
ity by adding assumptions obtained from enumerated candi-
dates checked against a counter strategy. The case of well-
separation is dierent because it is not monotonic and deals
with assumptions only. A dual approach might be possible
for the extension with guarantees dened in Sect. 6.2.
Vacuity: Finally, the problem of vacuity as dened by Beer
et al. [3] and studied in many works (e.g., [2, 12, 15]), in the
context of model-checking, can be viewed as related to well-
separation and synthesis. Fisman et al. [11] have extended
vacuity to specications where satisfaction is replaced by re-
alizability and witnesses are subformulas. All these works
are however very dierent than our work in their approach
and motivation. First, a vacuous controller could be syn-
thesized for a non-well-separated specication of case P-all6
and second, non-well-separation of case P-reach cannot be
detected by checking a controller for vacuous satisfaction.
9. CONCLUSION
In this work we investigated non-well-separation, where an
environment can be forced to violate the assumptions, in the
context of GR(1), an expressive fragment of LTL. We distin-
guished cases of non-well-separation, and computed strate-
gies showing how the environment can be forced to violate its
assumptions. We further showed how to nd a core, a mini-
mal set of assumptions that lead to non-well-separation, and
extended our work to support past-time LTL and patterns.
We implemented our work and evaluated it on 79 specica-
tions. The evaluation shows that non-well-separation is a
common problem in specications and that our tools can be
eciently applied to identify it and its causes. Our work is
the rst to investigate and implement means to identify and
address non-well-separation. It is also the rst to evaluate
non-well-separation on a corpus of specications.
The work is part of a larger project on bridging the gap be-
tween the theory and algorithms of reactive synthesis on the
one hand and software engineering practice on the other. In
this project we are building engineer-friendly tools for writ-
ing and understanding specications for reactive synthesis.
10. ACKNOWLEDGMENTS
JOR acknowledges support from a postdoctoral Minerva
Fellowship, funded by the German Federal Ministry for Ed-
ucation and Research. Part of this work was done while
SM was on sabbatical as visiting scientist at MIT CSAIL.
This project has received funding from the European Re-
search Council (ERC) under the European Union's Horizon
2020 research and innovation programme (grant agreement
No 638049, SYNTECH).
6Non-well-separation is necessary but not sucient for a
controller that is vacuous in the system guarantees.
37111. REFERENCES
[1] R. Alur, S. Moarref, and U. Topcu. Counter-strategy
guided renement of GR(1) temporal logic
specications. In FMCAD , pages 26{33. IEEE, 2013.
[2] R. Armoni, L. Fix, A. Flaisher, O. Grumberg,
N. Piterman, A. Tiemeyer, and M. Y. Vardi. Enhanced
vacuity detection in linear temporal logic. In CAV ,
volume 2725 of LNCS , pages 368{380. Springer, 2003.
[3] I. Beer, S. Ben-David, C. Eisner, and Y. Rodeh.
Ecient detection of vacuity in ACTL formulaas. In
CAV , volume 1254 of LNCS , pages 279{290. Springer,
1997.
[4] R. Bloem, R. Ehlers, S. Jacobs, and R. K onighofer.
How to handle assumptions in synthesis. In
Proceedings 3rd Workshop on Synthesis, SYNT 2014,
Vienna, Austria, July 23-24, 2014. , volume 157 of
EPTCS , pages 34{50, 2014.
[5] R. Bloem, R. Ehlers, and R. K onighofer. Cooperative
reactive synthesis. In ATVA , volume 9364 of LNCS ,
pages 394{410. Springer, 2015.
[6] R. Bloem, B. Jobstmann, N. Piterman, A. Pnueli, and
Y. Sa'ar. Synthesis of Reactive(1) Designs. J. Comput.
Syst. Sci. , 78(3):911{938, 2012.
[7] A. Cimatti, M. Roveri, V. Schuppan, and
A. Tchaltsev. Diagnostic information for realizability.
InVMCAI , volume 4905 of LNCS , pages 52{67.
Springer, 2008.
[8] N. D'Ippolito, V. A. Braberman, N. Piterman, and
S. Uchitel. Synthesizing nonanomalous event-based
controllers for liveness goals. ACM Trans. Softw. Eng.
Methodol. , 22(1):9, 2013.
[9] M. B. Dwyer, G. S. Avrunin, and J. C. Corbett.
Patterns in property specications for nite-state
verication. In ICSE , pages 411{420. ACM, 1999.
[10] R. Ehlers, R. K onighofer, and R. Bloem. Synthesizing
cooperative reactive mission plans. In IROS , pages
3478{3485. IEEE, 2015.
[11] D. Fisman, O. Kupferman, S. Sheinvald-Faragy, and
M. Y. Vardi. A framework for inherent vacuity. In
Haifa Verication Conference (HVC) , volume 5394 of
LNCS , pages 7{22. Springer, 2008.
[12] A. Gurnkel and M. Chechik. How vacuous is
vacuous? In TACAS , volume 2988 of LNCS , pages
451{466. Springer, 2004.[13] U. Klein and A. Pnueli. Revisiting synthesis of GR(1)
specications. In Haifa Verication Conference
(HVC) , volume 6504 of LNCS , pages 161{181.
Springer, 2010.
[14] R. K onighofer, G. Hoerek, and R. Bloem. Debugging
formal specications: a practical approach using
model-based diagnosis and counterstrategies. STTT ,
15(5-6):563{583, 2013.
[15] O. Kupferman and M. Y. Vardi. Vacuity detection in
temporal model checking. STTT , 4(2):224{233, 2003.
[16] S. Maoz and J. O. Ringert. GR(1) synthesis for LTL
specication patterns. In ESEC/FSE , pages 96{106.
ACM, 2015.
[17] S. Maoz and J. O. Ringert. Synthesizing a Lego
Forklift Controller in GR(1): A Case Study. In Proc.
4th Workshop on Synthesis, SYNT 2015 colocated with
CAV 2015 , volume 202 of EPTCS , pages 58{72, 2015.
[18] S. Maoz and Y. Sa'ar. AspectLTL: an aspect language
for LTL specications. In AOSD , pages 19{30. ACM,
2011.
[19] S. Maoz and Y. Sa'ar. Counter play-out: executing
unrealizable scenario-based specications. In ICSE ,
pages 242{251. IEEE / ACM, 2013.
[20] S. Maoz and Y. Sa'ar. Two-way traceability and
conict debugging for aspectltl programs. T.
Aspect-Oriented Software Development , 10:39{72,
2013.
[21] N. Piterman, A. Pnueli, and Y. Sa'ar. Synthesis of
reactive(1) designs. In VMCAI , volume 3855 of LNCS ,
pages 364{380. Springer, 2006.
[22] A. Pnueli and R. Rosner. On the Synthesis of a
Reactive Module. In POPL , pages 179{190. ACM
Press, 1989.
[23] A. Pnueli, Y. Sa'ar, and L. D. Zuck. JTLV: A
framework for developing verication algorithms. In
CAV , volume 6174 of LNCS , pages 171{174. Springer,
2010.
[24] V. Raman and H. Kress-Gazit. Explaining impossible
high-level robot behaviors. IEEE Transactions on
Robotics , 29(1):94{104, 2013.
[25] A. Zeller. Yesterday, my program worked. today, it
does not. why? In ESEC/FSE , volume 1687 of LNCS ,
pages 253{267. Springer, 1999.
372