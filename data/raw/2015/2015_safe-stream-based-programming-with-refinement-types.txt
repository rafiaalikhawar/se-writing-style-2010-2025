Safe Stream-Based Programming with Refinement Types
Benno Stein
University of Colorado Boulder
Boulder, Colorado, USA
benno.stein@colorado.eduLazaro Clapp
Uber Technologies, Inc.
San Francisco, California, USA
lazaro@uber.com
Manu Sridharan
Uber Technologies, Inc.
San Francisco, California, USA
msridhar@uber.comBor-Yuh Evan Chang
University of Colorado Boulder
Boulder, Colorado, USA
evan.chang@colorado.edu
ABSTRACT
In stream-based programming, data sources are abstracted as a
stream of values that can be manipulated via callback functions.Stream-based programming is exploding in popularity, as it pro-
videsapowerfulandexpressiveparadigmforhandlingasynchro-
nous data sources in interactive software. However, high-levelstream abstractions can also make it difficult for developers to
reasonaboutcontrol-anddata-flowrelationshipsintheirprograms.
This is particularly impactful when asynchronous stream-based
code interacts with thread-limited features such as UI frameworks
that restrict UI access to a single thread, since the threading behav-ior of streaming constructs is often non-intuitive and insufficiently
documented.
Inthispaper,wepresentatype-basedapproachthatcanstatically
prove the thread-safety of UI accesses in stream-based software.
Our key insight is that the fluent APIs of stream-processing frame-
worksenablethetrackingofthreadsviatype-refinement,making
it possible to reason automatically about what thread a piece of
code runs on – a difficult problem in general.
We implement the system as an annotation-based Java type-
checker for Android programs built upon the popular ReactiveX
framework and evaluate its efficacy by annotating and analyzing 8
open-source apps,where wefind 33 instancesof unsafeUI access
whileincurringanannotationburdenofonlyoneannotationper
186sourcelinesofcode.Wealsoreportonourexperienceapplying
the typechecker to two much larger apps from the Uber Technolo-
gies,Inc.codebase,whereitcurrentlyrunsoneverycodechange
and blocks changes that introduce potential threading bugs.
CCS CONCEPTS
•Software and its engineering →Software notations and
tools;Formal software verification;
KEYWORDS
stream-based programming, refinement types, mobile applications
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ASE ’18, September 3–7, 2018, Montpellier, France
© 2018 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.3238174ACM Reference Format:
BennoStein,LazaroClapp,ManuSridharan,andBor-YuhEvanChang.2018.
Safe Stream-Based Programming with Refinement Types. In Proceedings
of the 2018 33rd ACM/IEEE International Conference on Automated Software
Engineering(ASE’18),September3–7,2018,Montpellier,France. ACM,New
York, NY, USA, 12pages.https://doi.org/10.1145/3238147.3238174
1 INTRODUCTION
Manypopularuserinterfaceframeworks(e.g.,Swing,Cocoa,Eclipse,
iOS,Android)distinguishasinglemainthreadfromwhichallUI
accesses must be performed [ 4,5,16,25,47]. This design is pre-
ferred by library developers since it eliminates the need for library-
internal synchronization: there is no need to worry about data
racesordeadlockwhenonlyonethreadisallowedtoperformUI
operations.
However, the single UI thread model requires application devel-
opers to carefully avoid interacting with the UI from other threads
since doing so results in a runtime crash or undefined behavior.
Suchinvalidthreadaccess bugsareverycommoninpractice:a
Google search for Android’s CalledFromWrongThreadException , one
of several exceptions that Android can throw when the UI is ac-
cessed improperly,yields over47,000 results,including numerous
Githubbugreports,StackOverflowquestions,anddeveloperguides
and tutorials.
Furthermore,invalidthreadaccessesaredifficulttodetectand
debuginpractice.ExistingUItestingtechniquesareoftenunable
to achieve adequate coverage of possible UI interaction traces [ 11]
and struggle with bugs that only manifest on certain devices in
the diverse Android hardware and software ecosystem [ 19,58].
Program analysis approaches to finding improperly threaded UI
accessesaresimilarlyinadequate:thecallgraph-reachabilitytech-
nique proposed by Zhang et al. [ 64] and the effect type system
ofGordonetal.[ 28]bothidentifymethodsthatinteractwiththe
UIeffectivelybutusea veryconservativeandrestrictivemodelto
determine when those methods run on the UI thread; on the other
hand,generalapproachestoconcurrencyanalysistypicallyfocus
onsharedmemoryaccessratherthandeterminingthethreadon
which a given piece of code will run [20, 44].
In recent years, there has been an explosion in popularity of
stream-basedprogramming frameworkslikeReactiveExtensions
[50],especiallyforinteractivesoftwarelikeAndroidapplications
thatneedtorespondtouserinputinrealtime.Suchframeworks
provide expressiveand convenientthreading abstractionsfor ma-
nipulatingstreamsofdataandcomputation,butofferlittleinthe
565
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Benno Stein, Lazaro Clapp, Manu Sridharan, and Bor-Yuh Evan Chang
wayoftoolsupporttohelpdevelopersavoidinvalidUIaccessby
reasoning about what thread a stream is running on.
Weproposeinthispaperarefinementtype-basedstaticanalysis
thatidentifiespossibleinvalidthreadUIaccessesinstream-based
Android applications, combining an effect type system that tracks
thepossibleUIinteractionsperformedbymethodswithathread
type system that encodes the possible threading behaviors of asyn-
chronous data streams.
Our approach not only detects (or proves the absence of) im-
proper UI access, but also helps developers understand and reason
aboutUIinteractionsintheircode.Furthermore,ourannotation-
basedapproachmakesthatreasoningexplicitandself-documenting,
allowing future contributors to more easily understand, modify, or
extend previously annotated code.
Ourtypecheckercurrentlyrunsoneverycommitmadetotwo
majorAndroidapplicationsatUberTechnologies,Inc.(Uber),block-
ing any changes that may introduce invalid thread access bugs. In
practice, we have found that the typechecker catches potential
bugs earlierin the development processand more efficiently than
existing testing and manual code review are able to.
We build on the insights of Gordon et al. [ 28], who first showed
theapplicability ofeffect-typing tomodern UIframeworks witha
distinguishedUIthread,byextendingtheirworkintwokeydimen-
sions. First, we introduce a thread type system for determining the
threadonwhichstreamoperatorsexecute.Combiningthethread
typesystemwiththeeffecttypingofGordonetal.enablesverify-
ingUIeffectsafetyforawiderclassofthreadingconstructs,with
almost no additional annotation burden for developers. Second,
we develop an effect inference technique for callbacks and lambda
abstractions that further lowers the annotation burden of UI effect
typing and improves code readability.
Contributions: The primary contributions of our work are as
follows:
•We introduce anovel refinement-type systemthat soundly
verifies that stream-processing code only accesses the UI
fromstreamsrunningontheAndroidmainthread.Wedemon-
strate its efficacy by implementing a static annotation-based
type checker for Android applications built upon the Re-activeX Java stream-based programming framework. Our
systemstaticallyrefinesthetypesofcallbacksandlambda
abstractions by the effectsthey may incur and data/event
streams by the threadson which they may run, then verifies
thatnon-UIthreadstreamsnevercallmethodswithUIeffect.
•We analyze a corpus of 8 open-source Android applications,
as well as two large closed-source applications developedatUber.Indoingso,wefindthat (a)improperUIaccessis
detectablebyourtoolandprevalentinbothopen-sourceand
closed-sourcecodebasesand (b)annotationburdenonthe
programmerislowenoughforthetooltobeincorporated
intoaproductiondeveloperworkflow.Intotal,wefind33in-stancesofUI-effectfulcallbacksrunningonnon-UI-threaded
streamsintheopen-sourcecorpus.AtUberourtoolrunson
everycode changeas partofcontinuous integration,block-
ing any change that may introduce stream-based threading
bugs.2 OVERVIEW
Inthissection,weprovidebackgroundinformationaboutstream-
basedprogrammingframeworks,theAndroidUImodel,andrefine-
ment typechecking by applying our tool to a simple example from
a user’s perspective.
2.1 Reactive Extensions
Reactive Extensions (ReactiveX) [ 50] is a multi-language frame-
work for asynchronous stream-based programming which allows
developerstoeasilywritecodethatoperatesoverstreamsofevents
or data, composing and transforming them with various functional
operators and subscribing callbacks to perform computations in
response to events.
Stream processing frameworks have gained popularity in recent
years due to their ability to provide a uniform interface to multiple
asynchronous inputsources, allowing developers tobuild respon-
sive interactive applications and easily interoperate (via the stream
API) with new frameworks and technologies. Stream-based pro-
gramming also encourages a functional programming paradigm,
preferring composable modular computations to imperative proce-
dures over mutable state.
A typical use-case of ReactiveX is to receive or generate an
Observable stream,performanumberofoperationsthatmodifyits
dataorthread,andthensubscribean Observer (orothercallback-
like object) to asynchronously consume the resulting event stream.
Thisso-called“fluent”interface,inwhichmultiplecallsarechained
together,isahallmarkofthestream-basedprogrammingparadigm,
combining ideas from the Observer pattern, the Iterator pattern,
and functional programming [50].
Take, for example, the code snippet in Fig. 1, which updates
car locations on a map using the ReactiveX framework. The
carLocationData stream represents location data for some set of
cars, updated periodically by a remote server. The filteroperator
filtersthestreamtoincludeonlycarscurrentlywithoutapassenger.
Then, observeOn moves subsequent operations to themain thread,
a requirement for performing UI updates on Android. The delay
operatorintroducesadelaybeforeeachlocationupdate,toallow
for other processing to complete. Finally, the anonymous function
passed to subscribe invokes UI APIs to display the cars in the map.
A key feature of the ReactiveX fluent interface is that each oper-
ationinachainofcallsreturnsanew Observable instancerather
thanperformingsideeffectsonthereceiverofthecall.Thisside-
effect free nature of ReactiveX enables a type-based analysis, since
eachintermediate Observable instanceinthecallchaincanbegiven
asinglestatictypethatisnotsubjecttochangelaterinthechain.
Note that ReactiveX’s API is distinct from the Builder pattern [ 23],
whichsupportsasimilarcall-chainingsyntaxbutdoesperformside
effectswitheachcall,passingthesameBuilderinstancethrough
the chain.
Though Fig. 1’s example makes use of only a few simple stream
operators,ReactiveXprovidesawiderange,fromfunctionalpro-
grammingstandardslike filter(emitonlythosedatathatsatisfy
a given predicate) to more exotic combinators like switchMap (map
incoming data to new streams, emitting events only from the most
recent datum’s stream). Streams (i.e. Observable s) possess 340 such
566
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. Safe Stream-Based Programming with Refinement Types ASE ’18, September 3–7, 2018, Montpellier, France
Observable <...> carLocationData = ... ;
carLocationData
.filter(car -> /*car has no passenger*/ )
.observeOn(Andro idSchedulers.mainThread())
.delay(100, TimeUnit.MILLISECONDS)
.subscribe(
car -> { /* display car on map */ },
err -> { /* render error message */ })
Figure 1: Simple example usage of ReactiveX Observable
streams. Contains the distillation of a threading bug that
was detected by our tool and fixed, as explained in sec-
tion2.2.
operatorsinReactiveXJavaversion2.1.12,inadditiontoanycus-
tomoperatorsdefinedbythirdpartylibrariesormorespecialized
types of streams.
With the expressivity of such a large and complex framework
inevitably comes a steep learning curve, since it is difficult for
developerstobecomefamiliarwiththeAPI.Thiscontributestothe
preponderance of threading bugs in real-world applications using
ReactiveX.Inourexperiments,wefindthatmanyprogramscontain
latent threading bugs that require a nuanced understanding of the
framework to detect.
The program in Fig. 1, for example, looks safe from improper
UI access at first glance: its author was careful to observeOn the
Android main thread before subscribing a callback that renders
UI elements and error messages. Howev er, due to the threading
behaviorofthe delayoperator,theprogramactuallyaccessesthe
UI from a background thread.
2.2 Refinement Typechecking
Inspiteof theintractabilityofdeterminingwhatthread apieceof
codewillrunoningeneral,stream-basedframeworkslikeReactive
Extensions are amenable to thread analysis by means of refine-
ment types [22,48]. As discussed in the previous section, the fluent
functional interface of ReactiveX streams is the key feature which
enables the use of a type-based approach to track the thread of in-
termediatecallsinthechain,obviatingtheneedformoreexpensive
general-purpose thread analyses.
Informally,arefinementtypesystemcanbethoughtofasaug-
mentingbase types (e.g., integers, lists, strings) by qualifiers that
further restrict the values of the base type (e.g., positiveintegers,
nonempty lists,ASCIIstrings).Refinementsubtypingholdswhen
bothbasesubtypingandqualifiersubtypinghold,andstandardintu-
itionsaboutnominalsubtypingoverbasetypesbehaveanalogously
for refined types1.
Inthispaper,weverifythesafetyofUIaccessinstream-based
Androidprogramsusingtwoseparatebutparalleltyperefinements.
First,werefinethetypesofallmethodsandcallback-likeobjects
withaneffectqualifier fromFig. 2,whichplacesanupperboundon
thesideeffectstheymayincur,asinGordonetal.[ 28].Wesaya
methodis“UI-effectful”whenitmayaccesstheUIandisannotated
with @UIEffect .
1Namely, refinement subtyping is reflexive and transitive, and the Liskov substitution
principle holds for refined types.@UIEffect
@SafeEffect
Figure 2: Qualifier hierarchy for effect type refinements.
@AnyThread
@CompThread @UIThread
@BottomThread
Figure 3: Qualifier hierarchy for thread type refinements.
Next, we refine the types of all data streams with a thread qual-
ifierfrom Fig. 3, which places an upper bound on the thread on
whichtheymayemitevents.Ifsuchathreadcannotbedetermined
statically,thestreamwillhavethetrivial @AnyThread qualifier,which
does not restrict the base type at all.
Inbothcases,wetakecaretominimizeannotationburdenusing
sensible default qualifiers, shorthands to annotate entire classes or
packages, and type inference to determine qualifiers where they
are implied.
Finally,wetypechecktheprogram,confirmingthatallassign-
ments,returnvalues,andfunctionargumentsrespecttheirdeclaredtypes,UI-effectfulmethodsarenevercalledfromsafe-effectfulmeth-
ods,andUI-effectful callbacksaresubscribedonlytoUI-threaded
streams. Otherwise, we report warnings to the developer where
these conditions are not met.
A more precise and formal treatment of the refinement type sys-
temweinstantiatecanbefoundinsection 3.Fornow,wewillbuild
intuition byapplying ourrefinement typecheckerto theprogram
in Fig.1.
When a developer tries to compile the program in Fig. 1, our
compiler issues the following error at the subscribe callsite:
error: [rx.thread.violation] Subscribing a callback with
@UIEffect to an observable scheduled on @CompThread; @UIEffect
effects are limited to @UIThread observables
Thiserrorindicatesapotentialthreadingerrorintheprogram:
the callbacks being passed to subscribe can touch the UI, but they
are being subscribed to a Observable scheduled on a background
computation thread.
The reason for this error is that delayautomatically returns a
streamrunningonabackgroundcomputationthread.Thus,even
thoughthe developerused observeOn toforce thestream ontothe
main thread before subscribing UI-effectful callbacks, the interme-
diatecallto delaypromptlymovedittoacomputationthread.In
practice,wefoundthatevenexpertdeveloperswereoftenunaware
ofthis delaybehavior,documentationofwhichislimitedtoashort
note buried deep in a large generated documentation file.
However, our typechecker refines the types of each program
value: @AnyThread fortheinitial carLocationData stream, @AnyThread
for the result of filter,@UIThread for the result of observeOn ,
@CompThread for the result of delay, and @UIEffect for the lambda
expressions passed to subscribe . Thus, our typechecker is able
567
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Benno Stein, Lazaro Clapp, Manu Sridharan, and Bor-Yuh Evan Chang
to identify the bug – subscription of a @UIEffect function onto a
@CompThread stream – and issues the error reproduced above.
Thefixtothisissue,oncethedeveloperhasbeenmadeawareof
it by the typechecker, is simple and requires no annotations: swap
the positions of the delayand observeOn calls and the code will
typecheck and compile without error.
3 THREAD & EFFECT SEMANTICS
This section details the thread semantics of the Android UI frame-
workandtheReactiveXthreadingmodelandformalizesthethread
andeffecttypesystemsweusetoanalyzeReactiveX-basedAndroid
applications.
Recall that the Android UI toolkit is not thread-safe and adheres
toasinglethreadmodel;assuch,anycodethataccessesUIcom-
ponentsmustdo so from the UI thread [ 25]. This is a relatively
standardmodelforotherUIframeworks,includingiOSaswellas
Java’s Swing, SWT, and AWT [4].
Existing work has established effect types as a useful abstraction
fordeveloperstoavoidviolatingthissingle-threadassumption[ 28].
However, such work is limited to relatively simple threading
models where the library provides an interface to the UI thread for
coderunningelsewhere:forexample,theEclipseSWTUIframe-
work defines a function with signature
static void asyncExec(Runnable r);
whichallowsadevelopertopasssomeUI-effectfulcode rtoberun
on the UI thread.
WhileAndroiddoesprovideanalogousfunctions(e.g., Activity#
runOnUiThread ,View#post )thatcanbeanalyzedbyexistingeffect-
typingtechniques,italsoprovidesmoreexpressivefunctionsbe-yond their reach (e.g.,
AsyncTask ,Handler). In addition, Reactive
Extensions’threading constructsintroduceeven morecomplexity
and require new techniques to be analyzed properly.
3.1 Effects
The applicationof effect type systemsto UI frameworksis a fairly
well-understood technique: functions are annotated with effect
qualifiers, which canthen be checked to verifythat the annotated
function does not perform any effects not permitted by its annota-
tion.OureffectsystembuildsontopofthatofGordonetal.[ 28],
whereinfunctionshaveoneoftwoeffectannotations: @UIEffect ,
denotingamethodthatmay(ormaynot)interactwiththeUI,or
@SafeEffect ,denotingamethodthatisguaranteednottotouchthe
UI2.
Thesub-effectingrelation /precedesequalisgivenby @SafeEffect/precedesequal@UIEffect
andthetworeflexiverelationships, @SafeEffect/precedesequal@SafeEffect and
@UIEffect/precedesequal@UIEffect . That is, a method with safe effect can be
used in place of a method with UI effect, but not vice versa.
We say that aprogram is effect-safe when its effect annotations
over-approximateallpossibleeffectsperformedatruntime;thus,
in an effect-safe program, a method annotated @SafeEffect is guar-
anteed never to interact with the UI. Checking effect-safety of a
programwhosemethodsareannotatedbytheireffectreducesto
checking the following two conditions:
-Transitivity: A method with effect annotation emay only
call a method with effect annotation e/primeife/prime/precedesequale.
2Note that this ignores polymorphic qualifiers, which will be detailed in section 3.3.class A {
@UIEffect void foo() {...}
@SafeEffect void bar() {...} }
class B extends A {
// Transitivity violation
@SafeEffect void baz() { foo(); }
// Inheritance violation
@UIEffect void bar() {...} }
Figure4:Exampleviolationsoftheeffecttypesystem. B#baz
violatesthetransitivityconditionbecauseitisannotatedas
safe but calls a UI-effectful method A#foo, while B#barvio-
lates the inheritance condition because it manipulates theUI but overrides a method declared to be safe.
-
Inheritance: A method with effect annotation emay only
override a method with effect annotation e/primeife/precedesequale/prime.
Inotherwords,the transitivity conditionstatesthatsafemethods
cannot call UI methods, while the inheritance condition states that
methodscannothaveUIeffectiftheyoverrideasafemethod.As-
sumingthatUI-effectfullibrarymethodsareannotatedaccordingly,
proving these two conditions suffices to show that the UI is only
accessedfrommethodsannotatedwith @UIEffect .Figure4provides
concrete examples of effect-safety violations.
The reader may find it useful to think of these two conditions
in terms of reachability in a directed graph whose vertices aremethods, with edges from callers to callees and from superclass
methods tooverriding subclass methods.In such agraph, an edge
from a method with effect eto a method with effect e/primeviolates one
of the above conditions when e≺e/prime. The task of applying effect
types to an Android application is thus equivalent to determining
the region of nodes from which Android UI methods are reachable:
that region has UI effect, while its complement has safe effect.
Other than the lambda support and inference mechanism de-
scribed in section 3.4, this effect type system is identical to that of
Gordon et al. [28].
3.2 Threads
ThethreadingbehaviorofAndroidapplicationsthatmakeuseof
stream-basedprogramming frameworkslikeReactiveExtensions
isdeterminednotonlybyasmallsetofAndroidAPImethodswith
fixed semantics but also by a wide range of stream operators with
dynamic threading behavior. Effect typing alone is therefore insuf-
ficient to properly verify the UI thread-safety of such applications.
Consider,forexample,the subscribe methodof Observable ,which
is called on a stream in order to register some callback to be exe-
cuted whenever an event is emitted by the receiver stream.
In contrast to Android’s runOnUiThread , which can safely be
passed a UI-effectful callback in all contexts, subscribe can only
be passed a UI-effectful callback obswhen the receiver stream is
running on the UI thread.
Inordertoexpressthatinvariant,ananalysismustreasonnot
only about the effects of methods, but also the threads on whichstreams emit events (and, by extension, execute subscribed call-
backs).
568
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. Safe Stream-Based Programming with Refinement Types ASE ’18, September 3–7, 2018, Montpellier, France
Tothatend,weaugmentourtypesystemwithtypeannotations
that refine stream types by their thread. These type annotations
aredrawnfromthequalifierhierarchygiveninFig. 3.Thetopof
the qualifier hierarchy, @AnyThread , denotes a stream that can emit
events on any thread; @UIThread and @CompThread denote streams
thatcanemiteventsonlyontheUIthreadorabackgroundcom-
putation thread, respectively; @BottomThread denotes a stream that
cannotemiteventsonanythread.Thisbottomtypeisneverwritten
byaprogrammerbutisusedwithinthetypecheckerforthe null
value, dead code, and wildcard lower bounds [9].
Annotating stream operators with thread type refinements al-
lowsatypecheckertoreasonaboutthethreadingbehaviorofthose
constructs. For example, the thread semantics of the delayfunc-
tion used in the motivating example in Fig. 1can be specified by
annotating its receiver @AnyThread and its return type @CompThread .
Combiningthreadrefinementtypesforstreamswitheffectrefine-
menttypesformethodsisthekeyideathatallowsourtypechecker
to verify UI thread-safety of stream-based Android applications by
checking that subscription of UI-effectful callbacks only occurs on
UI-threaded streams.
3.3 Qualifier Polymorphism
Some design patterns – particularly those designed for modularity
and reusability – have effect and thread behavior that cannot be
expressed by a single type signature with fixed refinements. In
these cases, we make use of qualifier polymorphism.
Qualifierpolymorphismisaformof parametricpolymorphism,
whichalsounderliesgenericsinJavaandC#anduniversallyquanti-
fiedtypesinHaskellandOCaml.Consider,forexample,thismethod
from the Java collections library, which creates a singleton set:
Set<T> singleton(T obj){...}
The generic type variable Tmay be instantiated as any single Java
object type, constraining the element type of the returned set to be
the same as the argument type.
Similarly, qualifier polymorphism uses a generic refinement
variableto relatetyperefinementsratherthanexplicitlyannotat-
ing types with a fixed qualifier. We define a @PolyThread (resp.,
@PolyUIEffect )qualifierthatmaybeinstantiatedasanyconcrete
thread (resp., effect) qualifier, constraining the refinements on mul-
tiple types to be the same3.
Qualifier polymorphism is well suited to several design patterns
instream-basedAndroidapplications,severalexamplesofwhich
are selected and reproduced in Figure 5.
The Callback interfaceexhibitseffectpolymorphism:weusethe
polymorphicqualifiers @PolyUIType and @PolyUIEffect toenforce
thata Callback instancehasaUIannotationwhenits handleMessage
method has UI effect. Similar interfaces such as Runnable,Action,
and Observer are annotated analogously, relating the refinement
type of the callback-like object to the effect of its implemented
method(s).
3Implicitly,aclassormethodwithpolymorphicqualifierannotationsisparameterized
byasinglerefinementtypevariablewhichis usedwhereverthe polymorphicqualifier
iswritten.Assuch,itisimpossibletoparameterizeadefinitionbymultiplerefinement
typevariables,butwehavenotfoundanyanycodepatternsinpracticewheresuch
atypeisrequired.Thispolymorphicqualifiersyntaxisdefinedandprovidedbythe
Checker Framework [9].@PolyUIType interface Callback {
@PolyUIEffect
boolean handleMessage(Message m); }
class Observable <T> {
@PolyThread Observable <T> take
(@PolyThread Observable <T> this,
int k){...};
@PolyThread Observable <T> observeOn
(@PolyThread Scheduler thread){...};}
Figure5:Examplesofthread-andeffect-polymorphictypes,drawn from Reactive Extensions’
io.reactivex.Observable
and Android’s android.os.Handler , respectively.
Methods that take Callback instances with UI effect versions of
handleMessage willneedtodeclarethecorrespondingformalparam-
eteras @UI Callback.Methodsthatdonotcareaboutthecallback’s
effecttake @PolyUI Callback instances.Ourtooldefaultstointer-
pretingunannotatedformalsofapolymorphictypeas @AlwaysSafe
(non-UIaffecting)instances.Analogouslogicappliestothetypes
of fields and locals.
The Observable class–themainstreamdatatypeinReactiveX–
exhibits two distinct forms of thread polymorphism. First, most of
itsmethods(e.g., takeinFig.5)donotaffectthethreadofthestream
they operate on; we express this behavior by constraining their
receiver4andreturnvaluestohavethesamethreadrefinementwith
the@PolyThread qualifier. Second, we use thread polymorphism to
express the dependently-typed behavior of the observeOn operator,
whichtakesa Scheduler (e.g.,athreadpool)andreturnsastream
emitting events on that thread pool. In order to do so, we overload
the meaning of our thread qualifiers to apply to schedulers as well
as streams and annotate the scheduler and the returned stream of
observeOn with the @PolyThread qualifier.
Qualifier polymorphism introduces some additional complexity
tothedefinitionofeffect-safetygiveninsection 3.1.Theinterac-
tion between polymorphic and concrete effects is fairly straight-
forward:wehave @SafeEffect/precedesequal@PolyUIEffect and @PolyUIEffect
/precedesequal@UIEffect , since those relations would hold for whatever con-
creteeffect @PolyUIEffect takeson.Thatis,thebodyofaneffect-
polymorphic method can call any method with safe effect but isforbidden from calling UI-effectful methods. On the other hand,the body of an effect-polymorphic method may only call othereffect-polymorphic methods when they share the same receiver
object,sincearbitraryothereffect-polymorphicmethodsmaybe
instantiated with an incompatible concrete effect.
3.4 Lambdas and Qualifier Inference
ThecallbacksusedinstreamprocessingframeworkslikeReactiveX
aretypicallywrittenaseitheranonymousinnerclassesorJava8
lambda expressions. When a callback is passed to a method whose
formal parameter is annotated with a particular effect qualifier, the
anonymousclassorlambdamustitselfhaveacompatibletypequal-
ifier.Inthecaseofanonymousinnerclassesthiscanbeachievedby
4The receiver thisis explicitly written and annotated as the first argument to the
method,asperJava’sTypeAnnotationspecification;thisdoesnotaffectthesemantics
of the function whatsoever [36].
569
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Benno Stein, Lazaro Clapp, Manu Sridharan, and Bor-Yuh Evan Chang
Library
Annotation
Stubs
Java SourcesRx Thread & Eﬀect Checkerjavac
Type Qualiﬁer Hierarchies
Custom Typing Rules
Implicit Type FactoryExecutable
List of Alarms

Figure 6: Typechecker infrastructure diagram showing its
internalcomponents,inputsandoutputs.Fromauser’sper-spective,UIthread-safetycheckingisintegratedseamlessly
with other
javaccompile-time checks in this default config-
uration,butitisalsopossible(bymeansofacommand-lineoption)torunthecheckerasastandaloneprocess,emittingasuccessmessageinsteadofgeneratinganexecutablewhenthe program is deemed safe.
using a type-use annotation (e.g., new @UI Consumer{...} to spec-
ify a Consumer whose acceptmethod has @UIEffect ). However, the
syntax of Java lambda expressions does not permit any explicittype annotations (refinement or otherwise). Rather, their type is
resolved through type inference.
Consider, for example, the Java type of thelambda expression
passed as the first argument to Observable#subscribe in Figure 1:
car -> { /*display car on map */}
The first formal parameter of Observable#subscribe has type
@PolyUI Consumer,so thecompilerinfers that Consumer isthefunc-
tionalinterface5basetypeofthelambda.Duringcompilation, javac
will convert any lambda expression to an anonymous instantiation
of a compatible functional interface, inferring its base type from
the context.
However, the base type inference mechanism does not apply to
refinement type qualifiers. Instead, we apply local type qualifier
inferencetocomputethepropereffectannotationwithwhichtoin-
stantiate the @PolyUIpolymorphic qualifier by inspecting the body
ofthelambdaexpression.Ifacalltoamethodwith @UIEffect effect
isfoundwithinthebodyofthelambda,wemarkthecorresponding
anonymousinstanceofthefunctionalinterfaceas @UI,andother-
wiseassafe. Intheexampleabove, aslongasthe codeinbrackets
includesatleastonecalltoan @UIEffect method,weinferthetype
of the lambda to be @UI Consumer.
4 TYPECHECKER IMPLEMENTATION
This section details the implementation of a typechecker for the
aforementioned thread and effect type systems, which is able to
soundlyverifytheUIthreadsafetyofReactiveX-basedJavaAndroid
applications.
The typechecker’s design balances competing goals: it must not
only provide reliable guarantees of safety and correctness, but also
be easy-to-use and integrate into developer workflows. What’s
more, in order to find and fix existing UI threading bugs, it must
be applicable to legacy codebases without a prohibitive amountof configuration or annotation effort. To that end, we build the
5A functional interface is any Java interface with a single abstract method.typecheckerupontheCheckerFramework[ 9,14,48],whichpro-
videsinfrastructureforbuildingcustomtypecheckersthataugment
Java’s base type system.
Refinement types are implemented as Checker Framework type
qualifiers: annotations on existing Java base types which are then
processedatcompile-timebyourtypechecker.TheCheckerFrame-
work allows users to check those types by simply invoking a javac
compiler with certain command-line flags. This design enables any
modernJavabuildsystemorIDEtoincorporateUIthread-safety
typechecking with minimal configuration overhead.
The typechecker plugin itself consists primarily of three com-
ponents, as shown in Fig. 6: the type qualifiers themselves, custom
typing rules that specify the UI thread-safety invariant, and a type
factorythatgeneratesannotationsthatarenotexplicitlywritten
but rather inherited, derived, or inferred.
Thetypequalifierhierarchies –describedindetailindividually
inSection 3–implementJavatypeannotationsforeachthreadand
effecttype.InadditiontothetypehierarchiesshowninFigures 2
and3, this also includes polymorphic qualifiers that range over
thoselatticesaswellasclass-andpackage-levelannotationswhich
apply some annotation to each method therein.
Thecustom typing rules express the constraints on effect in-
heritance and transitivity and enforce the core UI thread-safety
invariant:that @UIEffect -fulcallbacksmayonlybesubscribedto
@UIThread streams.Thesecustomtypingrulesaugmentthestandard
rules implemented by the Checker Framework which constrain,
for example, actual parameters to declared formal parameter types,
assignment r-values to corresponding l-value types, and return
values to declared method signatures.
Finally, the implicit type factory is responsible for generating
typerefinementsforthosevariablesthatlackanexplicitrefinement
annotation. This process takes one of three forms:
-Inheritance: In addition to the @UIEffect and @SafeEffect
methodannotations,theeffecttypesystemwebuildupon
also provides shorthand annotations to facilitate blanket an-
notation of all methods in a class or package [ 28]. These
shorthands are especially useful when all methods of a par-
ticular package or class share the same effect, saving the
effort of annotating each one manually.
-Inference: Whenever our typechecker encounters a lambda
expression, we retrieve the functional interface base type
inferred by javacfor the lambda. If that type has a concrete
effectqualifier,noinferenceisrequiredandwesimplyapplythatqualifier.Otherwise,wescanthebodyofthelambdaforanyinvocationsofmethodswith
@UIEffect .Ifanyarefound,
then the anonymous instance associated with the lambda
expression is annotated @UI(see Section 3.4).
-Defaults: Whenanun-annotatedmethodorvariabledoes
notinheritatyperefinementandinferencedoesnotapply,asensibledefaultischosenbythetypechecker.Thesedefaults
minimize annotation burden dramatically by only forcing
developersto writeannotations wherethetype refinement
varies from the default.
Werefineun-annotatedmethodswiththe @SafeEffect quali-
fiersothatannotationsonlyneedtobeexplicitlywrittenon
code that interacts with the UI, while un-annotated streams
570
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. Safe Stream-Based Programming with Refinement Types ASE ’18, September 3–7, 2018, Montpellier, France
receive the @AnyThread trivial refinement so that, unless oth-
erwise specified, we soundly assume a stream could emit
events on any thread.
The choice of default annotations is a design choice; in prac-
tice, we find that these defaults largely correspond to devel-
oper intuitions and reduce annotation overhead.
Thosethreeelements–qualifierhierarchies,customtypingrules,
andimplicittypegeneration–sufficetotypecheck wholeprograms:
programs that are complete and self-contained in a set of source
files. The stream-based Android apps we are concerned with, how-
ever, are openprograms which interact with other libraries and
frameworks whose source code the typechecker may not have
access to: ReactiveX and the Android standard library, at a bare
minimum.
Inordertotypecheckcodethatinteractswithun-analyzedex-
ternal libraries, we refine types as needed at the public interface
of libraries using annotation stubs: files consisting of annotated
typesignaturesforlibrarymethods.Theseannotationsallowthe
typecheckertospecifyrefinementtypesforthird-partylibrarycode
withoutcheckingtheinternalsofthoselibrariesorrebuildingthem
from source.
Annotation stubs are particularly effective for specifying the
effectsofAndroidlibrarymethodsandthethreadingbehaviorof
Observable operators. We present several such annotation stubs in
Figure7in order to build intuition and demonstrate the technique.
-ScrollView isanAndroidUIelement,somostofitsmethods
have UI effect. The @UITypeclass-level shorthand applies
@UIEffect to each of its methods; however, some methods –
including post– can safely be called from non-UI threads
and are thus annotated @SafeEffect .
-delayschedulesthereturned Observable onthecomputation
threadpool, so its return value is annotated @CompThread .
-observeOn returns an Observable that emits events on the
given Scheduler . This behavior is expressed by applying the
polymorphic @PolyThread qualifier to both the return type
and the threadparameter, constraining them to both have
the same thread refinement.
-takesimplytruncatesastreamafter keventsanddoesnot
affectthethreadofthestreamitiscalledon,asisthecase
withmost Observable operators.Wethereforeconstrainits
receiverand return value to run on the same thread, using
the polymorphic @PolyThread qualifier.
Annotation stubs are a possible source of unsoundness in our
approach, sincethe refinementtypes theyprovide aretrusted and
the corresponding source code is unchecked. However, we are able
to mitigate this concern through careful review of source code and
documentation forboth Androidand ReactiveX.In particular,our
annotationstubsconformtotheAndroiddeveloperguide’sadmoni-
tion that the android.widget and android.view packages comprise
theAndroidUItoolkit(i.e.haveUIeffect)andtoallthreadingbehav-
iors specified in the ReactiveX Observable documentation [ 25,50].
5 EVALUATION
We answer the following research questions in order to evaluate
our approach.(1)Is the typechecker usable and practical? Is the annotation
burden sufficiently small for real-world Android developersto make use of the tool, and are the messages and warnings
emitted by the tool useful and understandable?
(2)Does the typechecker find real bugs and help fix them? Are
threading bugs in stream processing code prevalent in prac-
tice, does our tool identify them successfully, and is a pro-
gramthatsuccessfullytypechecksreliablyfreeofsuchbugs?
5.1 Evaluation Suite
Ourexperimentalevaluationconsistsofcasestudiesover8open-
source Android applications, as well as a report on our experience
applying the tool in production to two Android applications devel-
oped at Uber
We select open-source applications for our experiments from
Github according to the following criteria. First, we restrict our
search to Android applications written in Java (excluding Android
applicationswritteninotherlanguages since ourtypecheckerop-
erates over a Java AST).
Ofthose,weconsideronlyapplicationsthatimporta2.xversion
of ReactiveX. We exclude applications using a 1.x version because
ourannotationstubcoveragethereofismoresparseandapplica-
tionsusingtheolderlibraryversionaremorelikelytobeabandoned
or broken.
Finally,wetookthe8mostrecentlyindexedapplicationswith
10ormoreGithub“stars.”Thesetwocriteriaformanimperfectbut
practicalproxyforrepositoryactivity:takingrecentlyindexedapps
avoids those that are abandoned or unmaintained, while requiring
atleast10starsensuresthattheappsarenotsmallpersonalprojects
or one-off experimental applications.
We believe that the 8 subject programs selected thusly form a
reasonably representative cross-section of open-source Android
projects,including,forexample:awidely-forkedtemplateforModel-
View-Presenterapps[ 61],aclientforaRussiantechnologynews
website[45],andanappthatscans,tracks,andorganizesreceipts[ 7].
In total, this open-source evaluation suite consists of 142 thousand
lines of code written by 82 distinct contributors.
In addition to this corpus of open-source applications, we have
alsoappliedthetypecheckertotheUberEatsandUberDriverapps,
bothofwhicharelargeclosed-sourceAndroidapplicationswritten
and maintained by professional developers at Uber.
5.2 Annotation Workflow
Thissectiondetailstheprocessofapplyingthetypecheckertoan
existing Android application.
First,weclonetheapplication,andconfirmthatitbuildssuccess-
fully in our local environment. In practice, we found that all of the
open-source apps gathered according to our criteria use the Gradle
build system and were relatively easy to build locally [ 29]. Next,
we configure the application’s build to invoke our custom type-
checker simply by adding package dependencies and setting javac
command-line options in the build.gradle configuration file. At
thispoint,thetypecheckerisfullyconfiguredandwillbeseamlessly
integrated with the existing compilation process.
However, the task of refining effect and thread types of existing
coderemains.Wefinditmostefficienttoannotateintwophases:
571
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Benno Stein, Lazaro Clapp, Manu Sridharan, and Bor-Yuh Evan Chang
@UIType class ScrollView { //...
@SafeEffect boolean post( @UI Runnable action);}
class Observable <T> { //...
@CompThread Observable <T> delay( long delay, TimeUnit unit);
@PolyThread Observable <T> observeOn( @PolyThread Scheduler thread);
@PolyThread Observable <T> take( @PolyThread Observable <T> this, int k);}
Figure 7: Selected example stub annotations for ReactiveX Observable methods and an Android UI class.
first, apply effect annotations throughout the application, ignoring
anyerrorsrelatedtothreadingandthen,onceallmethodshavethe
proper effect type, apply thread annotations and/or fix real bugs
until no alarms remain.
Recall the two conditions that govern effect typing: methods
may only call methods with lesser effect (transitivity) and override
methods with greater effect (inheritance).
Since all unannotated application code has @SafeEffect by de-
fault and all Android UI methods have @UIEffect from annotation
stubs,everycallfromtheapplicationintotheAndroidUItoolkit
violates the transitivity condition in the app’s initial (unannotated)
state.Inordertodealwiththisavalancheofalarms,wefirstidentify
allpackages withnamesconnotingUIeffect(e.g., ui,view,widget,
layout, etc.) and use the package-level @UIPackage annotation to
apply @UIEffect to all methods therein.
Then, we triage remaining alarms and write type annotations
manuallyuntilnoalarmsremain.Weproceedfromfileswiththe
most alarms to those with fewest, using the class-level @UITypefor
especially alarm-ridden classes where most methods have UI effect.
Itispossiblethatourpackage-andclass-levelannotationsassign
the@UIEffect refinement to methods that do notactually interact
withtheUI.Assuch,manualtriageisnotassimpleasblindlypropa-
gating @UIEffect annotations:wearecarefultoidentifycaseswhere
analarmisduetothepackage-andclass-levelannotationsanduse
@SafeEffect to exclude a method from the coarse UI annotation
rather than further propagating the spurious @UIEffect .
Unliketheeffecttypesystem,whichrequiresamoderateamount
ofmanualannotation,thethreadtypesystemrequiresalmostnone.
Rather, our library annotation stubs are sufficient for the type-
checkertodeterminethethreadtyperefinementofintermediate
values of fluent call-chains in most cases, and it is rare for develop-
ers to store Observable streams in instance fields or local variables,
which would require type annotation at their declaration.
Therefore, once effect annotations are completed, the only re-
maining alarms in most applications are genuine threading vio-
lations, where a UI-effectful callback is subscribed to a non-UI-
threaded stream. We manually inspect these violations to confirm
that they are bugs and then find fixes on a case-by-case basis.
Oncefixeshavebeenfoundandapplied,theapplicationisverifi-
ablysafefromnon-UIthreadaccessofUIelementsinstream-based
code.
Crucially,thisfairlyinvolvedannotationprocessisaone-time
cost. After an application has been configured to use the thread
andeffecttypecheckerandfullyannotatedonce,futurebugfixes
and feature additions require minimal annotations. Nonetheless,possible threading errors are automatically reported by the com-
piler as they are written, allowing developers to write and modify
complex asynchronous stream-based software with confidence.5.3 Experimental Results
For our experiments, we apply the described workflow to the 8
open-sourceapplicationsgatheredaccordingtotheaforementionedcriteria. Figure 8reports a summary of our results, which we apply
here to the two stated research questions:
Is the typechecker usable and practical?
There are two facets to this question: first, is the annotation
burden reasonable, both in terms of developer time and total anno-
tation,andsecond,isthetypecheckerusableandunderstandable
for real Android developers?
Our results on the open source evaluation suite demonstrate
that,whiletheinitialoverheadofannotationismeaningful,itisfar
from prohibitive: we spent an average of 2 .3 hours per application,
writing one annotation per 186 source lines of code.
Does the typechecker find real bugs and help fix them?.We find a total of 33 threading defects spread across 6 different
appsintheopensourceevaluationsuite,anaverageof4 .1errors
perapplication.Theerrorsvaryfromsimpleoversights(e.g.,forget-
ting an observeOn ) to more complex interactions between multiple
stream operators and combinators. The wide range of bugs found
acrossamajorityofsubjectprogramsdemonstratestheapplicability
and efficacy of our approach.
We reproduce one example defect identified by the typechecker
here, taken from the ForPDA[45] application and slightly modified
for clarity.
observable.onErrorReturn(throwable -> {
handleError(throwable , onErrorAction);
return fallbackValue; })
.observeOn(Andro idSchedulers.mainThread())
.subscribe(callback)
The onErrorReturn methodtakesalambdathatrunswhenever
thereceiver Observable emitsanerror,catchingtheerrorandemit-
ting the lambda’s return value instead.
In this case, the lambda simply calls handleError on the error
throwable and returns a default value fallbackValue , before sched-
uling the resulting stream on the main thread and subscribinga callback
callback. The handleError function renders the error
message in the UI, but it may run on a background thread since
onErrorReturn precedesthe observeOn thatmovesthestreamtothe
mainthread.Thefixtothisbugissimple:switchthepositionsof
onErrorReturn and observeOn , and the code compiles without error.
5.4 Uber Case Study
Aspartofourevaluation,wedeployedthetypecheckerinUber’s
development infrastructure for two major applications: the Uber
EatsAndroidappandthenewestversionoftheUberDriverAndroid
572
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. Safe Stream-Based Programming with Refinement Types ASE ’18, September 3–7, 2018, Montpellier, France
App KLoC Annotations Time Spent (hrs.) Errors Found Compile Time (sec.)
ForPDA[45]3 3.0 197 3 4 27
chat-sdk-android [8]3 4 .6 102 2 6 21
trust-wallet-android [55]8 .82 7 1 2 1 7
arch-components-date [21]0 .72 0 .50 8
MVPArms[61]6 .35 9 1 1 9
rxbus[37]3 .31 2 1 0 3
SmartReceiptsLibrary [7]3 9 .9 217 7 16 30
OpenFoodFacts [46]1 4 .9 146 3 4 41
Averages 17.79 5 2 .34 .11 9.5
Figure 8: Open-source test corpus experimental results. Reported LoC figures are computed with sloccount [59]. Reported
compilation times are the mean of five executions of gradlecompiling all application release sources with our typechecker
enabled, measured on a laptop with an Intel i7-6700HQ processor and 8GB RAM, running Ubuntu 16.04.
app(thenindevelopment,itwasreleasedtopartnersinApril2018).
Thetypecheckerrunsaspartofthecontinuousintegrationpipeline
in parallel with a manual code review process. It inspects every
patch, blocking code from merging into the trunk of the repository
if it fails to typecheck.
Android apps at Uber are organized as a collection of targets,
compiled and unit tested separately. Over a period of 8 months, we
progressivelyenrolledindividualtargetsfromeachofthetwoapps
ontothetypechecker.Foreachtarget,wefirstwroteaninitialsetof
annotationsforexistingcode,thenenabledtypecheckingforthat
target and merged in the new annotations simultaneously.
Overall, we enrolled over half a million LoC corresponding to
targets from each of the two apps. As of this writing, we did notenroll targets in other Uber apps, or shared platform code and
first-partylibraries,althoughwedidadd(trustedbutunchecked)
annotations stubs for shared UI code.
Duringtheinitialenrollmentprocess,wemade41substantive
changestotheapplicationinadditiontotheaddedtypeannotations.
Most of those changes are simple additions of observeOn calls to
ReactiveX fluent call chains to move streams onto the main thread.
These represent potential preexisting issues regarding improper
UI access off the main thread. Although it is possible for manyof them to be safe in practice, due to implicit knowledge aboutruntime behavior not captured in our type system, we considerthe safety offered by the typechecker to be worth the potentialmarginal performance cost of moving these streams to the main
thread or performing redundant observeOn calls.
During this enrollment period, we observed two critical pro-
duction bugs involving ReactiveX streams accessing the UI from a
backgroundthread.Thefirstwasdistilledintothe delay()example
showninFigure 1.Thesecondwasanissuewheredevelopersfailed
to notice that Observable#switchMap could create and return a new
Observable on a different thread, rather than propagate the thread
ofitsreceiver.Thesebugswerepatchedassoonastheymanifested
in production and the app updated accordingly, but both would
have been caught by the current version of the typechecker had it
alreadybeenenabledforthecorrespondingtargets.Thisgivesus
someconfidencethatthetooliscatchingothersimilarissuesbefore
theymakeitpastthe developmentstage.Bydesign,issuesidenti-
fiedbythetypecheckerarefixedbeforetheybecomeproduction
bugs.After enrollment, any further commits changing files inside the
corresponding target are checked against our type system and de-
velopers are responsible for maintaining the annotations as part of
thedevelopmentcycle.Overthe8monthsofourrollout,over4 ,000
commitsand178developersinteractedwithourtypechecker.We
notethatenrolledtargetscontainanaverageofonetypeannotation
per 104 LoC, indicating that the burden placed on developers is
relatively low.
Furthermore, when excluding commits made by the authors
during the initial enrollment, the annotation burden falls to one
typeannotationper179LoC,implyingthatmuchoftheannotation
burden is incurred upfront and not as ongoing maintenance cost.
Wemeasuredthatdevelopershaveadded135 observeOn(...) in-
vocationstocommitsundercodereviewinresponsetotypechecker
warnings,eachrepresentingapotentialfixtoathreadingdefectthat
couldotherwisehavegoneuncaught.Notethatwecannotverify
that all of these changes are fixing real threading bugs; some may
have been needed due to a spurious @UIEffect annotation or other
typechecking imprecision.But, aswe have notreceived developer
feedback indicating excessive false positives, we believe that many
of these changes were either fixing real issues or improving the
codebymakingitmoreobviouslysafe.Catchingthesethreading
issuesearlyinthedevelopmentprocessreducescostsandimproves
productivity,asdevelopersdonotneedtocontext-switchbackto
code they wrote days or weeks earlier to fix bugs.
5.5 Threats to Validity
Theevaluationresultspresentedinthissectionarepredicatedupon
thecorrectnessandsoundness ofourtechniqueandexperimentaldesign.
First,itisimportanttonotethatourtechniquedoesnotmake
any global guarantee about UI access or general thread-safety: the
typechecker only verifies that UI-effectful code is annotated ac-cordingly and stream-based code is safe from invalid UI thread
access. As such, our tool does notfind UI threading bugs outside of
stream-based codeor non-UIthreading bugs suchas deadlocksor
data races.
Furthermore,thesafetyguaranteesprovidedbythetypechecker
aresoundwithrespecttotrustedlibraryannotationstubs,which
could potentially diverge from the true behavior of the underlying
code. We note, however, that our @UIEffect annotations for the
573
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Benno Stein, Lazaro Clapp, Manu Sridharan, and Bor-Yuh Evan Chang
Android standard library include all methods explicitly specified as
UI-effectful by the official developer guide [25].
Sincetheseexperimentswereperformedbyanauthorofthetool,
it is possible that the reported time spent underestimates the time
thatwouldbespentbyalessexperienceduser.However,thatfactor
is balanced somewhat by the fact that we were unfamiliar with the
open-source applications being annotated – several of which were
even documented in languages not spoken by the annotator.
Itisalsopossiblethatoursubjectprogramcorpusisnotrepre-
sentative of stream-based Android programs in general, either due
to small sample size or biases in our selection criteria.
6 RELATED WORK
Althoughthereisawealthofresearchonanalysisofconcurrentpro-
grams,existingapproachesareill-suitedtotheproblemofdetecting
improperlythreadedUIinteractionsinasynchronousstream-based
software.
Much of the existing literature focuses on race detection, order-
ing violations, and deadlocks, leveraging a wide range of dynamic
andstatictechniquesincludinginstrumentation,locksetalgorithms,
and model checking [20, 32,44,53].
However,thesinglethreadmodelwewishtoverifyprecludes
the need for general thread analyses: there are no data races or
deadlocksinaUIlibrarythatrunsononlyonethread.Furthermore,theaforementionedanalysesarecomputationallyexpensive,relying
onvariouspointerandaliasanalysestoreasonaboutJava’sheap-
allocated threading constructs.
Our type-based approach builds upon a deep body of work in
extensibletypesystemstoaddressbothoftheseissueswithconcur-
rencyanalysis,sincetypecheckingisanintraproceduralanalysis
that scales well and our type system is designed specifically to
identify improper UI thread access.
Theideaofaugmentinganexistingtypesystemwithmoreex-
pressive domain-specific types was introduced by Freeman and
PfenningintheirseminalworkrefiningalgebraicdatatypesinStan-dardML[
22].However,theircontributionsareprimarilytheoretical,
providing only a barebones proof-of-concept implementation.
Extendingalanguage’ssyntaxwith annotations toexpressrefine-
ments,asoriginallyproposedforStandardMLin[ 13],hasemerged
as a technique enabling practical adoptionof refinement type sys-
tems. Annotation-based type systems are widespread, augmenting
an existing static type system in Haskell [ 56] and SML [ 15]o r
adding simple static types to dynamically typed languages such as
JavaScript [42] and Python [57].
InJava,theCheckerFramework[ 48]providesameanstoextend
the Java base type system with arbitrary custom type refinements.
This has also been used in the past, for example, to infer and check
locking disciplines for multithreaded programs, verify information
flow properties, and implement ownership and universe types [ 17,
18,34].
The most closely related work to our own of which we are
aware is the effect type system of Gordon et al. [ 28], which is also
implemented using the Checker Framework. However, withoutthe qualifier inference and thread typing techniques detailed in
thispaper,theirtypecheckerisunabletoverifythestream-based
applications with which we are concerned.Testing is a popular alternative to static analysis (type-based
or otherwise) when trying to rule out classes of errors in soft-
ware. There isa largebody ofwork on automaticallytesting An-
droid applications at the level of the UI. Fully automated test-
ing approaches include random and search-directed event gen-
eration tools [ 12,27,35,38,40,52,63], model-based exploration
[1,2,6,10,31,43,49,62],concolictesting[ 3],andeventgeneration
using evolutionary algorithms [39].
Industrial state of the art mostly uses scripted UI tests con-
structed for a particular app using a testing framework [ 26,51,
54,60]. Record-and-replay systems also see widespread use to iso-
latebugsencounteredduringmanualtestingorafterdeployment
[24,30,33] and can be combined with search-based approaches
into hybrid testing schemes [41].
However, by their very nature, testing techniques cannot show
the absence of bugs, only their presence. Even a theoretical perfect
tester which explores all possible UI interaction traces can missthreading bugs. For example, issues flagged by our typechecker
maydependoninteractionwiththenetworkcausinganeventto
be emitted on a stream that is subscribed by UI affecting code, but
it is possible to explore every reachable view without this event
ever occurring and thus miss the bug.
A survey by Choudhary et al. [ 11] suggests that existing fully
automated UI testing tools do not significantly outperform random
exploration in terms of code coverage under a fixed time budget.
This could be due to either a faster rate of event generation for the
simplerapproachorthedifferenceinengineeringeffortsgoingintoanindustrystandardtoolversusresearchprototypes.Ineithercase,
these approaches are challenging to scale for large and complex
applications.
Finally,testing-basedtoolsusuallyrunlateinthedevelopment
process, whereas our analysis can run before a code change has
even been merged into the trunk of the repository for our apps.
7 CONCLUSION
WepresentinthispaperatechniquethatstaticallyverifiesUIaccess
tooccuronlyfromtheUIthreadinstream-basedAndroidprograms.
Our approach refines the types of data streams with a static bound
on their thread, refines the types of methods and callback-likeobjects with a static bound on their side-effects, and collates the
twotypesystemsinordertodetectinvalidthreadaccessesorprove
the absence thereof.
We demonstrate the efficacy and usefulness of our typechecker
by evaluating it on 8 open-source applications and finding 33 bugs.
We also report on our experience applying the tool at scale to
two large production Android applications at Uber, where it has
analyzed over 4000 commits by 178 developers at time of writing.
ACKNOWLEDGMENT
TheauthorswouldliketothankWernerDietl,ColinGordon,Michael
Ernst, and members of the CUPLV lab for valuable discussions.
This material is based on research sponsored in part by the
NationalScienceFoundationundergrantnumberCCF-1055066and
by DARPA under agreement number FA8750-14-2-0263. The U.S.
Goverernmentisauthorizedtoreproduceanddistributereprintsfor
Governmentalpurposesnotwithstandinganycopyrightnotation
thereon.
574
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. Safe Stream-Based Programming with Refinement Types ASE ’18, September 3–7, 2018, Montpellier, France
REFERENCES
[1]DomenicoAmalfitano,AnnaRitaFasolino,PorfirioTramontana,SalvatoreDe
Carmine, andAtif M. Memon.2012. Using GUI Rippingfor Automated Testing
ofAndroidApplications.In ProceedingsoftheIEEE/ACMInternationalConference
on Automated Software Engineering (ASE). 258–261.
[2]DomenicoAmalfitano,AnnaRitaFasolino,PorfirioTramontana,BryanDzung
Ta, and Atif M. Memon. 2015. MobiGUITAR: Automated Model-Based Testing of
Mobile Apps. IEEE Software 32, 5 (2015), 53–59.
[3]SaswatAnand,MayurNaik,MaryJeanHarrold,andHongseokYang.2012. Auto-
matedConcolicTestingofSmartphoneApps.In ProceedingsoftheACMSIGSOFT
International Symposium on Foundations of Software Engineering (FSE). 59.
[4]Apple. 2018. App Programming Guide for iOS. https://developer.apple.com/
library/content/documentation/iPhoneOSProgrammingGuide.
[5]Apple. 2018. MacOS Cocoa. http://developer.apple.com/technologies/mac/cocoa.
html.
[6]TanzirulAzimandIulianNeamtiu.2013. TargetedandDepth-FirstExploration
for Systematic Testing of Android Apps. In Proceedings of the ACM SIGPLAN
InternationalConferenceonObjectOrientedProgrammingSystemsLanguages&
Applications (OOPSLA). 641–660.
[7]Will Baumann. 2018. Smart Receipts. https://github.com/wbaumann/
SmartReceiptsLibrary.
[8]Chat SDK. 2018. Chat SDK Android. https://github.com/chat-sdk/
chat-sdk-android.
[9]Checker Framework Developers. 2018. Checker Framework Manual. https:
//checkerframework.org/manual.
[10]Wontae Choi, George C. Necula, and Koushik Sen. 2013. Guided GUI Testing of
AndroidAppswithMinimalRestartandApproximateLearning.In Proceedings
oftheACMSIGPLANInternationalConferenceonObjectOrientedProgramming
Systems Languages & Applications (OOPSLA). 623–640.
[11]Shauvik Roy Choudhary, Alessandra Gorla, and Alessandro Orso. 2015. Auto-
mated Test Input Generation for Android: Are We There Yet?. In Proceedings of
the IEEE/ACM International Conference on Automated Software Engineering (ASE).
429–440.
[12]Lazaro Clapp, Osbert Bastani, Saswat Anand, and Alex Aiken. 2016. Minimizing
GUIEventTraces.In ProceedingsoftheACMSIGSOFTInternationalSymposium
on Foundations of Software Engineering (FSE). 422–434.
[13]Rowan Davies. 1997. Refinement-Type Checker for Standard ML. In Proceedings
oftheInternationalConferenceonAlgebraicMethodologyandSoftwareTechnology
(AMAST). 565–566.
[14]WernerDietl,StephanieDietzel,MichaelD.Ernst,KivançMuslu,andToddW.
Schiller. 2011. Building and Using Pluggable Type-checkers. In Proceedings of the
International Conference on Software Engineering (ICSE). 681–690.
[15]Joshua Dunfield. 2007. Refined Typechecking with Stardust. In Proceedings of
theACMWorkshopProgrammingLanguagesmeetsProgramVerification(PLPV).
21–32.
[16] Eclipse. 2018. Standard Widget Toolkit. http://eclipse.org/swt.
[17]Michael D. Ernst, René Just, Suzanne Millstein, Werner Dietl, Stuart Pernsteiner,
Franziska Roesner, Karl Koscher, Paulo Barros, Ravi Bhoraskar, Seungyeop Han,
Paul Vines, and Edward XueJun Wu. 2014. Collaborative Verification of Informa-
tion Flow for a High-Assurance App Store. In Proceedings of the ACM SIGSAC
Conference on Computer and Communications Security (CCS). 1092–1104.
[18]Michael D. Ernst, Alberto Lovato, Damiano Macedonio, Fausto Spoto, and Javier
Thaine.2016. LockingDisciplineInferenceandChecking.In Proceedingsofthe
International Conference on Software Engineering (ICSE). 1133–1144.
[19] Mattia Fazzini and Alessandro Orso. 2017. Automated Cross-Platform Inconsis-
tencyDetectionforMobileApps.In ProceedingsoftheIEEE/ACMInternational
Conference on Automated Software Engineering (ASE) 2017. 308–318.
[20]Cormac Flanagan and Stephen N. Freund. 2009. FastTrack: Efficient and Precise
Dynamic Race Detection. In Proceedings of the ACM SIGPLAN Conference on
Programming Language Design and Implementation (PLDI).
[21]Rebecca Franks. 2018. Date Countdown. https://github.com/riggaroo/
android-arch-components-date-countdown.
[22]Timothy S. Freeman and Frank Pfenning. 1991. Refinement Types for ML. In
ProceedingsoftheACMSIGPLANConferenceonProgrammingLanguageDesign
and Implementation (PLDI). 268–277.
[23]ErichGamma,RichardHelm,RalphJohnson,andJohnVlissides.1995. Design
Patterns:ElementsofReusableObject-orientedSoftware. Addison-WesleyLongman
Publishing Co., Inc., Boston, MA, USA.
[24]Lorenzo Gomez, Iulian Neamtiu, Tanzirul Azim, and Todd D. Millstein. 2013.
RERAN: Timing- and Touch-Sensitive Record and Replay for Android. In Pro-
ceedings of the International Conference on Software Engineering (ICSE). 72–81.
[25] Google. 2018. Android Developer Guide. https://developer.android.com/guide.
[26]Google.2018. Espresso.https://developer.android.com/training/testing/ui-testing/
espresso-testing.html.
[27]Google.2018. UI/ApplicationExerciserMonkey. https://developer.android.com/
tools/help/monkey.html.[28]Colin S. Gordon, Werner Dietl, Michael D. Ernst, and Dan Grossman. 2013. Java
UI : Effects for Controlling UI Object Access. In Proceedings of the European
Conference on Object-Oriented Programming (ECOOP). 179–204.
[29] Gradle, Inc. 2018. Gradle Build Tool. https://gradle.org.
[30]MatthewHalpern,YuhaoZhu,RameshPeri,andVijayJanapaReddi.2015.Mosaic:
Cross-Platform User-Interaction Record and Replay for the Fragmented Android
Ecosystem.In ProceedingsoftheIEEEInternationalSymposiumonPerformance
Analysis of Systems and Software (ISPASS). 215–224.
[31]Shuai Hao, Bin Liu, Suman Nath, William G. J. Halfond, and Ramesh Govindan.
2014. PUMA:Programmable UI-Automation forLarge-scale DynamicAnalysis
of Mobile Apps. In Proceedings of the International Conference on Mobile Systems,
Applications, and Services (MobiSys). 204–217.
[32]Thomas A. Henzinger, Ranjit Jhala, and Rupak Majumdar. 2004. Race Check-ing by Context Inference. In Proceedings of the ACM SIGPLAN Conference on
Programming Language Design and Implementation (PLDI). 1–13.
[33]YongjianHu,TanzirulAzim,andIulianNeamtiu.2015. VersatileyetLightweight
Record-and-ReplayforAndroid.In ProceedingsoftheACMSIGPLANInternational
ConferenceonObject-OrientedProgramming,Systems,Languages,andApplications
(OOPSLA). 349–366.
[34]Wei Huang, Werner Dietl, Ana Milanova, and Michael D. Ernst. 2012. Inference
and Checking of Object Ownership. In Proceedings of the European Conference on
Object-Oriented Programming (ECOOP). 181–206.
[35]Bo Jiang, Yuxuan Wu, Teng Li, and W. K. Chan. 2017. SimplyDroid: Efficient
Event Sequence Simplification for Android Application. In Proceedings of the
IEEE/ACM International Conference on Automated Software Engineering (ASE).
297–307.
[36]JSR 308 Expert Group. 2014. Annotations on Java Types. http://download.oracle.
com/otndocs/jcp/annotations-2014_01_08-pfd-spec.
[37] Kuwork. 2018. RxBus.https://github.com/kuwork/rxbus.
[38]Aravind Machiry, Rohan Tahiliani, and Mayur Naik. 2013. Dynodroid: An Input
Generation System for Android Apps. In Proceedings of the Joint Meeting on
Foundations of Software Engineering (FSE/ESEC). 224–234.
[39]RiyadhMahmood,NarimanMirzaei,andSamMalek.2014. EvoDroid:Segmented
Evolutionary Testing of Android Apps. In Proceedings of the ACM SIGSOFT Inter-
national Symposium on Foundations of Software Engineering (FSE). 599–609.
[40]KeMao, MarkHarman,andYueJia. 2016. Sapienz:Multi-ObjectiveAutomated
Testing for Android Applications. In Proceedings of the International Symposium
on Software Testing and Analysis (ISSTA). 94–105.
[41]KeMao,MarkHarman,andYueJia.2017. CrowdIntelligenceEnhancesAuto-
matedMobileTesting.In ProceedingsoftheIEEE/ACMInternationalConference
on Automated Software Engineering (ASE). 16–26.
[42] Microsoft. 2018. TypeScript. https://www.typescriptlang.org.
[43]NarimanMirzaei,JoshuaGarcia,HamidBagheri,AlirezaSadeghi,andSamMalek.
2016. ReducingCombinatoricsinGUITestingofAndroidApplications.In Pro-
ceedings of the International Conference on Software Engineering (ICSE). 559–570.
[44]Mayur Naik, Alex Aiken, and John Whaley. 2006. Effective Static Race Detec-tion for Java. In Proceedings of the ACM SIGPLAN Conference on Programming
Language Design and Implementation (PLDI). 308–319.
[45] Evgeny Nizamiev. 2018. ForPDA. https://github.com/RadiationX/ForPDA.
[46]Open Food Facts, Org. 2018. Open Food Facts .https://github.com/openfoodfacts/
openfoodfacts-androidapp.
[47]Oracle. 2018. JDK Swing Framework. http://docs.oracle.com/javase/6/docs/
technotes/guides/swing/.
[48]Matthew M. Papi, Mahmood Ali, Telmo Luis Correa Jr., Jeff H. Perkins, and
MichaelD. Ernst.2008. Practical PluggableTypesfor Java.In Proceedingsof the
ACM/SIGSOFT International Symposium on Software Testing and Analysis (ISSTA).
201–212.
[49]Vaibhav Rastogi, Yan Chen, and William Enck. 2013. AppsPlayground: Auto-
matic SecurityAnalysis ofSmartphone Applications.In Proceedings ofthe ACM
Conference on Data and Application Security and Privacy (CODASPY). 209–220.
[50] Reactive Extensions. 2018. Reactive Extensions. reactivex.io.
[51] Robotium. 2018. Robotium. https://github.com/robotiumtech/robotium.
[52]Raimondas Sasnauskas and John Regehr. 2014. Intent Fuzzer: Crafting Intents of
Death.In ProceedingsoftheJointInternationalWorkshoponDynamicAnalysis
(WODA) and Software and System Performance Testing, Debugging, and Analytics
(PERTEA). 1–5.
[53]StefanSavage,MichaelBurrows,GregNelson,PatrickSobalvarro,andThomasE.
Anderson. 1997. Eraser: A Dynamic Data Race Detector for Multi-Threaded
Programs. In Proceedings of the ACM Symposium on Operating System Principles
(SOSP). 27–37.
[54] Selendroid. 2018. Selendroid. http://selendroid.io/.
[55]Trust. 2018. Trust Wallet. https://github.com/TrustWallet/
trust-wallet-android-source.
[56]Niki Vazou, Patrick Maxim Rondon, and Ranjit Jhala. 2013. Abstract Refinement
Types.In ProceedingsoftheEuropeanSymposiumonProgramming(ESOP).209–
228.
[57]Michael M. Vitousek, Andrew M. Kent, Jeremy G. Siek, and Jim Baker. 2014.
Design and Evaluation of Gradual Typing for Python. In Proceedings of the ACM
575
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Benno Stein, Lazaro Clapp, Manu Sridharan, and Bor-Yuh Evan Chang
Symposium on Dynamic Languages (DLS). 45–56.
[58]Lili Wei, Yepang Liu, and Shing-Chi Cheung. 2016. Taming Android Fragmenta-
tion: Characterizing and Detecting Compatibility Issues for Android Apps. In
Proceedings of the IEEE/ACM International Conference on Automated Software
Engineering (ASE). 226–237.
[59] David A. Wheeler. 2004. SLOCCount. https://www.dwheeler.com/sloccount/.
[60] Xamarin. 2018. Calabash. http://calaba.sh/.
[61] Jess Yan. 2018. MVP Arms. https://github.com/JessYanCoding/MVPArms.
[62]Wei Yang, Mukul R. Prasad, and Tao Xie. 2013. A Grey-Box Approach for Au-
tomated GUI-Model Generation of Mobile Applications. In Proceedings of theInternational Conference on Fundamental Approaches to Software Engineering
(FASE). 250–265.
[63]HuiYe,ShaoyinCheng,LanboZhang,andFanJiang.2013. DroidFuzzer:Fuzzing
the Android Apps with Intent-Filter Tag. In Proceedings of the International
Conference on Advances in Mobile Computing & Multimedia (MoMM). 68.
[64]Sai Zhang, Hao Lü, and Michael D. Ernst. 2012. Finding Errors in Multithreaded
GUI Applications. In Proceedings of the ACM/SIGSOFT International Symposium
on Software Testing and Analysis (ISSTA). 243–253.
576
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. 