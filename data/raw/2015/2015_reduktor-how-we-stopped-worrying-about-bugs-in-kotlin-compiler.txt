ReduKtor: How We Stopped Worrying About Bugs
in Kotlin Compiler
Daniil Stepanov, Marat Akhin, Mikhail Belyaev
Saint Petersburg Polytechnic University
JetBrains Research
Saint Petersburg, Russia
{stepanov,akhin,belyaev}@kspt.icc.spbstu.ru
Abstract —Bug localization is well-known to be a difﬁcult
problem in software engineering, and speciﬁcally in compiler
development, where it is beneﬁcial to reduce the input program
to a minimal reproducing example; this technique is more com-
monly known as delta debugging. What additionally contributes
to the problem is that every new programming language has
its own unique quirks and foibles, making it near impossible to
reuse existing tools and approaches with full efﬁciency. In this
experience paper we tackle the delta debugging problem w.r .t.
Kotlin, a relatively new programming language from JetBrains.
Our approach is based on a novel combination of program slicing,
hierarchical delta debugging and Kotlin-speciﬁc transformations,
which are synergistic to each other . We implemented it in
a prototype called ReduKtor and did extensive evaluation on
both synthetic and real Kotlin programs; we also compared
its performance with classic delta debugging techniques. The
evaluation results support the practical usability of our approach
to Kotlin delta debugging and also shows the importance of
using both language-agnostic and language-speciﬁc techniques
to achieve best reduction efﬁciency and performance.
Index T erms —program fuzzing, delta debugging, program
slicing, input reduction, compiler testing
I. I NTRODUCTION
In the recent years software has been becoming more
and more complex, with the subsequent rise in difﬁculty of
debugging. Despite all the latest advances in the ﬁeld of
software quality assurance, such as testing, static analysis and
veriﬁcation, ﬁnding the root cause of a bug still takes a lot of
time and effort from a developer. One of the main reasons for
that is the inherent difﬁculty of bug localization — ﬁguring out
which part of the program or program inputs causes the bug to
manifest itself. In compilers, for example, reducing the input
ﬁle to a minimal reproducing example is a very important step
in bug investigation, which is often done manually.
Automatic reduction of input ﬁles which cause a compiler
error greatly simpliﬁes the debugging process, as it removes
irrelevant details, allowing the developer to better understand
and focus on what triggers the bug. Several techniques such
as delta debugging [ 1], program slicing [ 2] and their various
improvements [ 3], [4], [5] attempt to deal with this problem.
These methods are language-agnostic, which is their clear-cut
advantage; however, in practice they often are hard to employ
efﬁciently for real-world cases, with complex language-speciﬁc
interdependencies and features. Using stand-alone language-oriented transformations [ 6] or incorporating them into other
reduction techniques [7] has been shown to perform best.
This work aims at creating an automatic input reduction tool
for the Kotlin1compiler. Our approach is based on a novel
combination of program slicing, hierarchical delta debugging
and Kotlin-speciﬁc transformations, which help each other in
ﬁnding and pruning irrelevant parts of input Kotlin ﬁles. As
real-world Kotlin projects often consist of multiple ﬁles, we
also support simultaneous reduction of several input ﬁles.
We have implemented our approach in a prototype tool called
ReduKtor and tested it extensively on several types of input.
For the ﬁrst part of the evaluation, we applied ReduKtor to a
number of input ﬁles generated by Kotlin compiler fuzzer [ 8].
For the second part of the evaluation, a number of real-
world projects were injected with various bugs, which trigger
Kotlin compiler errors, and processed with ReduKtor. We also
compared ReduKtor with classic input reduction techniques,
such as slicing and hierarchical delta debugging (HDD). Our
results show ReduKtor to outperform other approaches on the
size and complexity of the resulting inputs, and also support
the need for hybrid reduction approaches.
The rest of the paper is organized as follows. We introduce
the basics of various input reduction techniques and approaches
in section II. In section III we explain our approach in more
detail, how it relates to Kotlin features and what challenges we
had to tackle. We talk about the implementation in section IV;
evaluation setup and results are discussed in section V. We
overview related works in section VI, make conclusion and
identify possible future work in section VII.
II. I NPUT REDUCTION 101
As we established earlier, input data triggering a program
error often contains a lot of irrelevant information; for example,
listing 1 shows an example Kotlin program, which crashes the
compiler. Despite the program being more than 50 lines, the
actual error is triggered by the single expression (when {}) .
Of course, in this case the reduction could be done manually,
however, such an approach does not scale well for bigger and
more intricate inputs. That is why a lot of effort has been put
into automating the process of input reduction. Let us brieﬂy
review the different techniques applicable to compiler input
reduction, i.e., reduction of program source code.
1https://kotlinlang.org/
3172019 34th IEEE/ACM International Conference on Automated Software Engineering (ASE)
978-1-7281-2508-4/19/$31.00 ©2019 IEEE
DOI 10.1109/ASE.2019.00038
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:24:30 UTC from IEEE Xplore.  Restrictions apply. fun box(): String {
return (when {
(if("OK") == ("OK")) {}
// ... 50 more lines
})
}
Fig. 1: Compiler-crashing (when{}) example
Slicing was historically among the ﬁrst techniques to attempt
simpliﬁcation of a given program w.r.t. number of criteria,
which describe interesting program properties; it was coined
by Weiser in [ 2]. A slicing criterion is often given as a pair
“program statement – set of variables” and is used to create a
program slice: a reduced program containing only elements
related to the criterion, e.g., elements which inﬂuence the
criterion variables at the given statement. By deﬁnition, for
slicing to be applicable to an input reduction problem, we must
have a sound slicing criterion, a setup we do not always have.
Delta debugging is an approach free from such limitation,
proposed by Zeller and Hildebrandt in [ 1]. It views an input
sample Tof a program Pas a combination of individual
components, which can be minimized to Tmin , such that:
•Tmin causes the same failure as T
•if you remove any component of Tmin , the error does not
reproduce on P
The minimization is done via a variation of binary search;
let program Pand input Tbe given, such that P(T)crashes
the program. We ﬁnd Tmin=DD(T)using the following
procedure: the initial input sample Tis divided into nparts
T=Δ 1∪Δ2∪...∪Δn, which are examined in order to
understand if they could be removed from the input. If needed,
we increase nand repeat the procedure. This delta debugging
algorithm from [1] is shown in ﬁgure 2.
The principal input agnosticism of delta debugging is its
main pro and con; on one hand, it can be applied to any kind of
input data, on the other hand, it does not take into account the
inherent structure of the input and usually performs poorly on
complex data. In 2006, Mishergi and Su introduced hierarchical
delta debugging [ 3], an extension of classic delta debugging,
which focuses on applying delta debugging to hierarchical
inputs (e.g., abstract syntax trees, XML documents, HTML
DD(T)=DD 2(T,2)
DD 2(T,n)=⎧
⎪⎪⎪⎨
⎪⎪⎪⎩DD 2(Δi,2) ifP(Δi)fails
DD 2(∇i,m a x(n−1,2)) ifP(∇i)fails
DD 2(T, min(|T|,2n)) ifn<|T|
T otherwise
∇i=T−Δi
T=Δ 1∪Δ2∪...∪Δn,∀i/negationslash=j:Δi∩Δj=∅
Fig. 2: Delta debugging algorithmpages), representable as trees. Their algorithm works as shown
in ﬁgure 3; it independently analyzes every level of the input
tree in a top-down fashion. First, it collects all tree nodes at
the current level; second, these nodes are reduced using the
classic delta debugging, creating a minimal node conﬁguration.
This conﬁguration is then applied to the tree, following which
we proceed to the next tree level.
While HDD does work better than classic delta debugging
on structured data and can achieve good reduction on any input,
for many practical examples its performance is subpar, as it
has no knowledge about the ﬁner structure of the input. For
programming languages, for example, it does not take into
account control or data dependencies, and has to deduce them
implicitly, via its level-by-level tree reduction. To speed up
this process and improve on its quality, many practical delta
debugging tools include custom language-speciﬁc transforma-
tions [ 6], [7], [9]. For example, C-Reduce attempts to replace
arbitrary function arguments with compatible constants and
performs inlining of small functions.
For Kotlin, we decided to combine these approaches in such
a way that individual techniques support each other. Let us
describe our approach in more detail.
III. R EDUCTION FOR KOTLIN COMPILER
Our approach to input reduction for Kotlin compiler (see
ﬁgure 4), similarly to many other approaches, consists of a
number of independent steps, each taking a set of Kotlin ﬁles
as an input and reducing them via some kind of transformation.
Even before we discuss these steps in more detail, we need to
explore two things: transformation soundness and their order.
A. Transformation soundness
A transformation is sound w.r.t. input reduction problem, if
it preserves the original error; if a program Pfails on input T,
it should fail with the same error on the transformed input T/prime.
However, for compiler errors it is often very hard to deﬁne what
“same” means. For example, an error message may contain
parts of generated bytecode, which may be different for ﬁles
before and after transformation, but relate to the same cause.
There are 2 ways to solve this problem. The ﬁrst one
assumes error messages have a speciﬁc format, which can
be automatically parsed and compared. A number of errors
from Kotlin compiler satisfy this condition; an example of such
INPUT: hierarchical input data tree
RESULT: tree is reduced
1:level⇐0
2:nodes⇐getNodes (tree,level)
3:whilenodes/negationslash=∅do
4:minConﬁg ⇐DD(nodes)
5: removeNodes (tree,level ,minConﬁg )
6:level⇐level+1
7:nodes⇐getNodes (tree,level)
Fig. 3: Hierarchical delta debugging
318
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:24:30 UTC from IEEE Xplore.  Restrictions apply. Fig. 4: Overview of our approach
error is shown in listing 5. As one can see from the example,
the type and location of error are easily identiﬁable. For such
errors we have developed a number of parsers, which extract
relevant information used for error comparison.
If error messages do not have a structure, we need to compare
them directly, i.e., ﬁnd their differences. A classic approach
is to view this problem as a string difference one, solvable
via longest common subsequence (LCS) algorithm, such as
Myers’ [ 10]. To avoid reinventing the wheel, we use Diff Match
Patch [ 11], a highly-optimized library from Google for text
synchronization. The Diff component compares two strings and
outputs a list of their differences, which we can use to estimate
the similarity of original strings as/summationtext|diﬀ|//summationtext|total|. The
closer this coefﬁcient is to zero, the more similar the strings
are. To be considered the same, error messages should have
similarity lower than a set threshold, which is conﬁgurable.
Our approach ﬁrst attempts to compare two error messages
using one of the template parsers; if they fail, it falls back
to a direct difference comparison. This allows our approach
to more aggressively reduce input for a large class of errors,
which have comprehensive error messages.
B. Transformation order
All input reduction steps are independent of each other,
however, even for a ﬁxed set of transformations, the ﬁnal result
may be affected by the order , in which these transformations
are applied. More so, the overall performance also depends
on the transformation order, as the individual performance of
many transformations is greatly related to the input size. For
this work, we decided to apply transformations in the order of
their “reductiveness” based on the preliminary evaluation, from
coarse-grained steps, which can remove whole input ﬁles, to
more ﬁne-grained ones, which may work on a subexpression
level. It would be interesting to see, if it is possible to reliably
learn a quazi-optimal transformation order for a speciﬁc class
of inputs via machine learning or genetic engineering. We hope
to explore this opportunity in our future work.
The resulting pipeline is as follows.
•Project-level simpliﬁcations
•SlicingError:Kotlin: [Internal Error] org.jetbrains.
kotlin.codegen.CompilationException: Back-
end (JVM) Internal error: wrong code
generated
org.jetbrains.kotlin.codegen.
CompilationException Back-end (JVM)
Internal error: Couldn’t transform method
node:
test ()V:
L0
LINENUMBER 2 L0
L1
POP
L2
...
Cause: AFTER mandatory stack transformations:
incorrect bytecode
Element is unknown The root cause was thrown
at: MethodVerifier.kt:28
File being compiled at position: (1,1) in Main
.kt
...
Fig. 5: An example of a Kotlin compiler error message with
well-deﬁned format
•Text based transformations
•Syntax tree based transformations
•Hierarchical delta debugging
Every transformation is applied in order until convergence, i.e.,
until its input stops decreasing in size. We also check if the
transformation preserves the error by comparing before and
after error messages. If the error stops reproducing, we rollback
the input and continue with the subsequent transformations.
C. Reduction criterion
As mentioned before, our approach takes as an input a set of
Kotlin ﬁles with its respective error, which allows to support
reduction of not only individual ﬁles, but also whole projects.
However, some transformations need a starting point, e.g.,
slicing needs a criterion from which to do its work. When the
error message contains information about the error location,
we extract it as described in III-A and use from here on. If
the information is missing, we ask the developer to provide
a ﬁle, presumably containing the error. From here on out, we
will call this starting point a reduction criterion (RC).
Note: despite our fallback strategy appearing as unsound (re-
lying on manual developer input may seem quite unsound),
the approach established in section III-A helps us to ensure
soundness. If the developer speciﬁes an incorrect ﬁle for the RC,
they will get a suboptimal reduction, but the original error will
still be preserved. In case you are interested in how often the
fallback RC have been actually used, we kindly forward you
to the evaluation, speciﬁcally section V -A.
D. Project-level simpliﬁcations
The ﬁrst transformation we use performs different project-
level simpliﬁcations. Their main purpose is to prune away parts
319
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:24:30 UTC from IEEE Xplore.  Restrictions apply. of the project which are irrelevant to the error. Modern programs
have complex internal dependencies, greatly complicating
reducing individual ﬁles. To solve this problem, we need to
remove these dependencies.
In Kotlin dependencies of a ﬁle are usually deﬁned via
import lists: statements specifying which other parts of the
project are needed in the current ﬁle. Another way of specifying
dependencies is fully qualiﬁed names (FQN), when a program
component is referenced by its complete name. These elements
form the dependency tree , which may be used to guide the
simpliﬁcation process.
Figure 6a shows an example with import dependencies. In
order to reduce class A and leave only the relevant function
with the bug, we must reduce classes B, C and D in the correct
order. To do this we use the dependency tree, as in ﬁgure 6b.
To build this tree, we recursively collect the imports and
FQNs, starting from the reduction criterion. All ﬁles not in the
dependency tree are removed from the project. After that, we
traverse the dependency tree in the bottom up order, applying
to each ﬁle a subset of transformations, aimed speciﬁcally at
simplifying the project dependencies. As all ﬁles except one do
not contain the RC, all transformations must not depend on a
given starting point. The transformations used are listed below,
we describe them in more detail in their respective sections.
•All text based transformations
•Syntax tree based transformations related to pruning
unused program parts
–Removing of unused components
–Simplifying interdependent components
E. Slicing
As mentioned in section II, slicing is one of the most basic
input reduction techniques. It creates a program slice, free
of unneeded parts w.r.t. slicing criterion; in our case, we use
the RC as the slicing criterion. There are several different
types of slicing varying in their performance and complexity.
For our purposes we decided to implement a static backward
slicing [ 12] over the syntax trees, which is applied on the
following levels in their respective order.
•Intraprocedural level
•Function level
•Class level
The algorithm for intraprocedural slicing is presented in
ﬁgure 7. The algorithm analyzes the function in the reverse
order. All lines after the slicing criterion are removed using the
deleteLineIfSound function, which checks for transformation
soundness, as described in sections III-A and III-B . After that
we collect the interesting variables (aka dependencies) from
the slicing criterion and continue processing the function; if
a line depends on these variables, we keep it and extend the
dependencies, otherwise it can be removed. The dependsOn
and getDeps functions can handle different Kotlin language
statements and expressions (such as if statements, loops, etc.).
In case the RC does not contain an exact line, we perform
redundant slicing w.r.t. every line as the possible slicing
criterion and pick the best (shortest) resulting ﬁle.(a) Example of import dependencies
// File A.kt
class A() {
fun funWithBug() {
// ...
}
fun f() {
// ...
}
}
// File B.kt
class B() {
val a = A()
fun f() = a.f()
}
// File C.kt
class C() {
val a = A()
}
// File D.kt
class D() {
val b = B()
fun f() = b.f()
}
(b) Built dependency tree
Fig. 6: Example of project dependencies problem
Slicing at the function level works similarly to the depen-
dency tree pruning. Starting from the slicing criterion, we
collect the function call graph tree, marking all functions called
as used. Afterwards all unused functions are removed from the
ﬁle, if their deletion is sound w.r.t. RC (see ﬁgure 8). Class
level slicing is performed in a parallel fashion.
An example of how our slicing algorithm works is shown
in ﬁgure 9; in the example, we attempt slicing w.r.t. line 15.
F . Text based transformations
Direct transformations over the program text representation,
despite their simplicity, are often the most efﬁcient way
of reducing the program. Examples of such transformations
include removing some or all text in a string literal, changing
320
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:24:30 UTC from IEEE Xplore.  Restrictions apply. INPUT: slicing criterion targetLine
INPUT: functionfun
OUTPUT: reduced function fun
1:curLine←getLastLine (fun)
2:whilecurLine/negationslash=targetLine do
3: deleteLineIfSound (fun,curLine)
4:curLine←getPrevLine (fun,curLine)
5:deps←getDeps(curLine)
6:whilecurLine≥getFirstLine (fun)do
7: ifdependsOn (curLine ,deps)then
8: deps←deps+getDeps(curLine)
9: else
10: deleteLineIfSound (fun,curLine)
11:curLine←getPrevLine (fun,curLine)
12: returnfun
Fig. 7: Intraprocedural slicing algorithm
INPUT: slicing criterion targetFun
INPUT: ﬁleﬁle
OUTPUT: reduced ﬁle ﬁle
1:callTree←buildCallTree (ﬁle)
2:callees←collectCalleesFor (targetFun ,callTree)
3:funsToRemove ←getAllFuns (ﬁle)−callees
4:topologicalSort (funsToRemove )
5:forfun∈funsToRemove do
6: removeFunIfSound (ﬁle,fun)
7:returnﬁle
8:
9:function COLLECT CALLEES FOR(fun,callTree )
10:directCallees ←getDirectCallees (fun,callTree)
11:res←directCallees
12: fordirect∈directCallees do
13: res←res+collectCalleesFor (direct ,callTree)
14: returnres
15: end function
Fig. 8: Function-level slicing algorithm
code based on a pattern, etc. We selected about 30 of various
text transformations to be used based on the following.
•Our Kotlin programming experience
•Transformations used in other reduction tools ([7], [13])
•Transformations used in the Kotlin IntelliJ IDEA plugin
for code simpliﬁcation2
As most of them are pretty straightforward to invent and
implement, we skip on describing them for brevity. Below is
an incomplete list of text based transformations included in
our approach.
•Removal of text inside a balanced pair of parentheses
•Pattern-based removal or substitution of text
2https://www.jetbrains.com/idea/(a) Original example
1 class Square( private val a:Double ){
2 fun getPerimeter(): Double =a *4
3 fun getSquare(): Double =a *a
4 }
5
6 class Triangle( private val a:Double ,
7 private val b:Double ,
8 private val c:Double ){
9
10 fun getPerimeter(): Double =a+b+c
11
12 fun getSquare(): Double {
13 var square = 0.0
14 if(a*a+b *b= =c *c) {
15 square = a *b/2
16 }else {
17 val p = getPerimeter() / 2
18 square = Math.sqrt(p *( p-a ) *
19 ( p-b ) *(p - c))
20 }
21 return square
22 }
23 }
(b) Example after slicing
1 class Triangle( private val a:Double ,
2 private val b:Double ,
3 private val c:Double ){
4
5 fun getSquare(): Double {
6 var square = 0.0
7 if(a*a+b *b= =c *c) {
8 square = a *b/2
9 }else {}
10 return square
11 }
12 }
Fig. 9: Slicing algorithm: before and after example
•Replacement of string literals with empty strings
•Replacement of integer constants with 0
An example of these transformations is shown in ﬁgure 10.
G. Syntax tree based transformations
Another group of ad hoc transformations, which perform well
for source code reduction, are syntax tree based transformations.
There are two main approaches to them: language-agnostic and
language-speciﬁc. Language-agnostic transformations assume
only the basic tree structure and are deﬁned in terms of
generic node transformations; this allows them to successfully
reduce any input representable as a tree. On the other hand,
language-speciﬁc transformations usually depend on particular
tree properties for a given programming language; this limits
their generality, but improves the reduction efﬁciency.
Similarly to text-based transformations (section III-F ), we
decided to use a number of Kotlin-speciﬁc transformations,
derived from our Kotlin programming experience and from
321
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:24:30 UTC from IEEE Xplore.  Restrictions apply. (a) Original example
fun f() {
var a = 815162342
val b=a+1
val c = 1.1
var d:Double
while (a.toDouble() != c) {
d=a *b*c
a+ =1
}
println("a = $a")
}
(b) Example after text based transformations
fun f() {
var a=0
val b=a+1
val c = 0.0
var d:Double
if(a.toDouble() != c) {
d=a *c
a++
}
println("")
}
Fig. 10: Text based transformations: before and after example
which transformations are used in other tools. They can be
divided into the following groups.
•Expression simpliﬁcation (if statements, loops, elvis
operator, etc.)
•Removal of unneeded components (function and construc-
tor parameters, imports, etc.)
•Simpliﬁcation of interdependencies (removal of inherited
properties and functions, replacement of function bodies
with TODO() , etc.)
•Miscellaneous (comment deletion, replacement of function
return value, etc.)
Such transformations are implemented as syntax tree based ones
instead of text based, because they either cannot be expressed
or would create too many syntactically incorrect programs if
done over text. The latter may greatly inﬂuence the overall
reduction performance, as every incorrect transformation causes
a rollback to the previous reduction state.
Our approach currently includes 27 Kotlin-speciﬁc syntax
tree-based transformations; as describing each and every of
these transformation would have taken up most of the paper,
we decided to describe in detail only the most interesting ones.
1) Simplifying elvis operator: Kotlin has an elvis operator,
a succinct way of checking value for null and providing a
sensible default option; val a=b? :c means “if bis not
null , assign the non-null value btoa, else assign the default
value ctoa”. This operator can be reduced as val a=c , i.e.,
we can drop its left-hand side. As the type of cis guaranteed
to be a subtype of b? :c , this substitution is safe.2) Deleting function parameters: Function parameters often
become unused as a result of other reduction steps. To delete
them efﬁciently, you have to perform a bona ﬁde refactoring:
modify the function itself, ﬁnd all calls to the function and
delete the corresponding argument. At the same time, you have
to consider function overloading and inheritance, making this
transformation quite sophisticated to implement.
3)TODO() simpliﬁcation: Kotlin has a special TODO func-
tion, which throws a NotImplementedError exception when
called and has a special Nothing return type. Nothing is
a uninhabited subtype of all Kotlin types, i.e., can be used
in place of any other Kotlin expression. The corresponding
transformation attempts to replace arbitrary expressions, such
as function bodies or variable initializers, with the call to TODO .
4) Inlining: In case of small functions it makes sense to
inline their bodies in place of their calls, to improve readability
and give other transformations additional opportunities for
reduction. The inlining threshold is conﬁgurable by the user,
by default we attempt inlining for functions less than 10 lines.
5) Simplifying if statements: This transformation attempts
to replace the if statement with its true or false branch. If the
condition contains a type check, Kotlin performs a smart cast3,
a variation of ﬂow-based typing, aimed at reducing the code
boilerplate by automatically changing the compile-time type of
a variable after type checks and type-check-like constructions.
For our transformation, we create a corresponding type cast ( v
as T ) for every type check from the condition ( vi sT ),
taking into account their negation for the false branch.
H. Hierarchical delta debugging
The last step in input reduction is hierarchical delta debug-
ging [ 3]. HDD is used as a ﬁnishing tool to remove redundant
constructions not considered by the previous steps. After other
transformations have done their job, the input ﬁle is already
signiﬁcantly reduced compared to the starting point; this means
HDD can be performed much faster, if we were to compare it
to an HDD-only approach.
IV . I MPLEMENT A TION
We implemented a prototype tool for Kotlin ﬁle reduction
based on our approach, called ReduKtor. In this section we
would like to discuss some of the more interesting ReduKtor
implementation details.
A. Working with Kotlin
Many of our reduction steps require quite an advanced
understanding of the Kotlin source code, e.g., building and
manipulating its abstract syntax trees (AST). We also need
to be able to efﬁciently recompile the source code after each
change, so that we can check if the target error is preserved,
as described in section III-A.
To achieve these goals, we made a well-considered decision
to build ReduKtor on top of the Kotlin compiler using it as
a library. This allows us to use its robust source code parser,
3https://kotlinlang.org/docs/reference/typecasts.html
322
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:24:30 UTC from IEEE Xplore.  Restrictions apply. which produces Program Structure Interface (PSI) trees4, Jet-
Brains’ traditional concrete syntax tree (CST) implementation,
supporting both text- and tree-based transformations. By using
the compiler as a library, we signiﬁcantly reduced the time
needed to check the error reproducibility, as Kotlin compiler
has quite a long startup time, if used externally.
Unfortunately, this decision has a serious drawback: by being
dependent on the very thing we are trying to debug, we may be
reducing the space of supported Kotlin inputs; if the parser itself
fails, ReduKtor also cannot work. That said, in our experience
we have never encountered such a situation.
The Kotlin compiler is used in a two-stage process. First, we
use only the parser to create the PSI, which is much quicker
than invoking the full compilation; if the PSI contains error
nodes, the input ﬁle is syntactically incorrect and should be
rejected. Second, we perform the full compilation and analyze
the error message. This scheme also helps to save time checking
for transformation soundness.
B. Parallel processing
The ﬁrst step of the transformations (project-level simpliﬁ-
cations) is performed in parallel on every project ﬁle, to better
utilize the modern hardware. As described in section III-D ,w e
process the project dependency tree in the bottom up order,
and do so in parallel for independent ﬁles, i.e., viewing the
dependency tree as a parallel task graph. Additionally, we also
considered running the separate reduction steps in parallel, but
decided against it in the prototype, due to the complexity of
how to merge the possibly interdependent results together.
C. Caching
Another optimization employed in ReduKtor is the caching
of intermediate results. During transformations we may en-
counter source code conﬁgurations, which have been already
explored; this is most often encountered during HDD. To avoid
rechecking, we cache previously checked AST conﬁgurations
as their hashes together with the result. If the current hash
has already been seen, we reuse the cached result to guide the
subsequent transformations. In our experience, this signiﬁcantly
improves the HDD performance.
V. E V ALUA TION
For the evaluation, we run ReduKtor for Kotlin compiler
version 1.3.10 on two types of input. For the ﬁrst part, we used
the results of Kotlin compiler fuzzer [ 8]: single ﬁles, which
cause compiler crashes, — together with the code samples from
various compiler bugs, collected from the Kotlin compiler bug
tracker5. For the second part, a number of real-world projects
were injected with invalid code, to test the relevance and
performance of project-level simpliﬁcations. We did attempt
to ﬁnd project-level inputs with compiler-crashing bugs to no
avail, which is why we opted to create such inputs artiﬁcially.
The brief description of selected projects is shown in table I.
4https://www.jetbrains.org/intellij/sdk/docs/basics/architectural_overview/
psi.html
5https://youtrack.jetbrains.com/issues/KTWe collected the following statistics: reduction efﬁ-
ciency (i.e., the decrease in ﬁle size) and performance (i.e., the
wall-clock time for reduction). For every test project, we ran
input reduction in the following conﬁgurations.
•Slicing only (S)
•Kotlin-speciﬁc transformations (KST) only (T)
•HDD only (D)
•Pardis only (P)
•ReduKtor without transformations (S + D)
•ReduKtor without slicing (T + D)
•ReduKtor without HDD (S + T)
•ReduKtor ( S+T+D )
•ReduKtor with Pardis instead of HDD ( S+T+P )
Pardis [ 14] is the latest addition to the family of language-
agnostic input reduction algorithms, considered to be state-of-
the-art and outperform C-Reduce by a factor of 2 in reduction
performance. For the purposes of evaluation, we implemented
Pardis as an optional step in ReduKtor, to see how it performs
within a complex input reduction tool.
For the test bench, we used a machine with Intel Core i7-
4790 3.6 GHz processor, 32 GB of memory and Intel 535 SSD
storage. The evaluation results are shown in tables II and III.
An example of how different modes of ReduKtor perform on
an example from Kotlin fuzzer tests is shown in ﬁgure 11.
A. Reduction soundness
In section III-A we discussed two ways of ensuring reduction
soundness: one based on parsing error messages in a speciﬁc
format and another based on generic string comparison. In
our evaluation we did not encounter a single crash , for which
our error parsers failed to extract the error type and location;
this fact speaks highly of Kotlin compiler team and their error
handling discipline. This also means our evaluation compares
and talks about sound reduction results.
In a scenario when ReduKtor has to fallback to generic
string comparison, one has a possible problem with reduction
soundness only in a large-scale evaluation, when it is not
feasible to manually manage the similarity threshold. If we
are to talk about using ReduKtor in practice, there should be
a human developer in the reduction feedback loop, who can
check and tweak the similarity threshold as needed.
B. Lessons learned
There are several interesting insights we can extract from the
evaluation results. First, slicing impact on the input reduction
is negligible: if we remove slicing from the pipeline, the
reduction efﬁciency is almost unchanged, and the performance
is decreased by 6 percent at most. In our opinion, this means
slicing is better used for subsequent bug localization , a step
performed after the input reduction has been done.
Second, custom language-speciﬁc transformations outper-
form even the state-of-the-art language-agnostic technique (Par-
dis) in both performance and efﬁciency. They are better in
reduction efﬁciency by up to 1.64x for 4 out of 6 project (fuz-
zTests, bugsTests, mapdb, koin), and faster by up to 2.0x for
323
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:24:30 UTC from IEEE Xplore.  Restrictions apply. Name Lines×103Tokens ×103Description
fuzzTests 8 128.8 Kotlin fuzzer tests (446 ﬁles)
bugsTests 1.3 11 Code samples from the bug tracker (93 ﬁles)
kotlinpoet 10 52.4 Library for Kotlin source code generation
kfg 3.5 66 CFG builder for JVM bytecode
mapdb 2 14.8 Embeddable database
koin 8 17.8 Library for dependency injection
T ABLE I: Description of the test projects
Project O(#)R(#)
S T D P S+D T+D S+T S+T+D S+T+P
fuzzTests 128,843 97,269 39,547 39,546 43,614 39,587 22,497 34,181 22,682 22,623
bugsTests 11,080 10,881 8,006 8,364 8,290 8,364 7,145 7,683 7,145 7,088
kotlinpoet 8,251 6,595 605 462 525 462 32 644 32 32
kfg 6,762 6,490 327 327 199 327 136 438 136 136
mapdb 4,120 3,543 561 574 574 574 305 478 303 305
koin 1,080 639 281 466 466 466 79 281 79 79
Column O shows the number of original tokens, column R — number of tokens after reduction
T ABLE II: Reduction efﬁciency
ProjectT(s)
S T D P S+D T+D S+T S+T+D S+T+P
fuzzTests 512 2,023 4,869 2,009 4,554 3,215 1,704 3,018 2,251
bugsTests 47 186 770 225 765 624 220 661 401
kotlinpoet 155 1,814 4,810 2,769 4,800 1,280 1,362 1,270 1,205
kfg 329 1,159 3,386 1,269 3,299 1,306 1,195 1,297 1,196
mapdb 83 166 1,282 335 758 431 169 428 267
koin 49 382 619 188 456 466 384 484 419
Column T shows the reduction wall-clock time in seconds
T ABLE III: Reduction performance
4 out of 6 projects (bugsTests, kotlinpoet, kfg, mapdb). This
proves their importance for reduction in real-world applications.
Third, despite their standalone efﬁciency, the results of
language-speciﬁc transformations can be signiﬁcantly improved
by applying language-agnostic techniques (such as HDD or
Pardis) to their results. Adding either HDD or Pardis, together
with slicing, improves the results by 1.1x to 18.9x times. Of
course, adding additional reduction steps causes a subsequent
reduction in performance, by up to 3.5x times. Besides that,
from a practical standpoint, aggressive caching of intermediate
results together with using compiler in a two-stage process (see
section IV -A for further details) greatly improves performance.
For example, disabling these features slows down the reduction
process for bugsTests by 12.0x times.
We believe the second and third insights to strongly support
the need for hybrid input reduction approaches, to utilize
the synergy between language-agnostic and language-speciﬁc
techniques. They also show we need a better strategy for
comparing different input reduction tools; for example, Pardis
is said to be 4 times faster than C-Reduce, however, it is a
consequence of C-Reduce using HDD as its ﬁnal step.
We also performed a manual overview of the reduction
results and identiﬁed some inefﬁciencies. In several cases,
ReduKtor failed to remove all information irrelevant to the
error from the target ﬁle in a multi-ﬁle project. This happened
because the project-level simpliﬁcations failed to remove all
unneeded dependencies inside the project. In our future work
we plan to explore how one may better perform project-levelreduction, by either extending the number of transformations
used or selecting better project-level transformations.
As mentioned in section III-B , the reduction process consists
of many stages, the order of which can affect both the reduction
time and its result. We conducted additional experiments (not
presented here for the sake of brevity), which have shown the
selected order to outperform alternative orders. For example,
if you implement the same transformations in reverse order,
the reduction slows down by as much as 40% on fuzzTests,
and by 20% on average.
C. Real-world adoption
Unfortunately, ReduKtor is only a research prototype, and
we do not have any solid practical adoption yet; besides the
evaluation, we only used it internally (in our research group)
for several quirky bugs triggered by our code in the Kotlin
compiler. One of the main reasons for that is, as discussed in
section IV -A , to speed up reduction we use the compiler as
a library, via a non-stable internal API. As this API changes
between versions, one cannot currently use ReduKtor as an off-
the-shelf solution for their particular compiler version and/or
development environment.
We recently contacted the Kotlin compiler team and proposed
them to incorporate ReduKtor in their workﬂow. Their feedback
was positive; with their cooperation we should be able to
migrate ReduKtor to a new stable API, to better support
different compiler versions. We also further conﬁrmed the need
for project-level simpliﬁcation in real use cases, as currently
324
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:24:30 UTC from IEEE Xplore.  Restrictions apply. (a) Original test case
class A() {
fun String .test(OK: String ){ }
}
fun box(): String {
val clazz = (A)?:: class .java
val method = clazz.getDeclaredMethod("test
",
String ::class .java, String ::class .java
)
val parameters = method.getParameters()
if(!method[0].isImplicit() ||
parameters[0].isSynthetic()) {
return "wrong modifier"
}
return parameters[1].name
}
(b) Test case after slicing
class A() {}
fun box(): String {
val clazz = (A)?:: class .java
val method = clazz.getDeclaredMethod("test",
String ::class .java, String ::class .java)
val parameters = method.getParameters()
return parameters[1].name
}
(c) Test case after HDD
fun box(): String {
val clazz = (A)?:: class .java
val method = clazz.getDeclaredMethod
val parameters = method.getParameters
return parameters.name
}
(d) Test case after full ReduKtor mode
fun box() {
val clazz = (A)?:: class .java
}
Fig. 11: Example of different reduction modes
developers spend a lot of their time manually reducing complex
project setups to create minimal reproducing examples. We
hope to explore how we can improve on reduction for multi-ﬁle
projects in our future work.
VI. R ELA TED WORK
As mentioned before, input reduction is a popular research
area with a lot of practically applicable tools. At the moment,
the most developed tool for delta debugging is C-Reduce [ 7],
initially created for reduction of C/C ++ compiler tests, gener-
ated by Csmith [ 15]. These tests, being randomly generated,
usually contain a lot of irrelevant information. Over the years, C-
Reduce has evolved into a sophisticated hybrid input reduction
tool, utilizing the following transformations.•Delta debugging using topformﬂat [16]
•V arious text- and tree-based transformations over the
source code, for example: function inlining, removal of
unused functions and variables, etc.
•Source code pretty printing
C-Reduce has a proven track record of being able to han-
dle even complex C/C ++ programs [ 17]. ReduKtor may
be considered an adaptation of the C-Reduce approach to
the Kotlin programming language; however, it also supports
simultaneous reduction of several Kotlin ﬁles, i.e., project-level
input reduction, and uses slicing to improve performance.
Other tools for input reduction of Java or C ++ programming
languages include JSlice [ 13], Indus [ 18], JavaBST [ 19] and
CodeSurfer [ 20]. They implement a variety of techniques, in
a way more or less similar to C-Reduce. An example of an
approach, similar to ours, combining delta debugging and static
slicing would be the one by Leitner et al. [ 21], targeted at
minimizing randomly generated tests for Eiffel.
Some approaches use dynamic slicing instead of static, which
helps with the related activity of program understanding, e.g.,
Gupta et al. [ 22]. This approach takes a forward dynamic slice
from the delta debugged input and intersects it with a backward
dynamic slice of the erroneous output, creating what is called a
failure-inducing chop. It is used to better guide the bug-ﬁnding
activities; we did not have the opportunity to focus on this
problem in our work, and hope to explore it in the future.
A number of tools attempt to perform language-agnostic
input reduction. The classic example of this is Picireny [ 23], an
implementation of HDD. It performs HDD over the parse trees
produced from an input ANTLR [24] grammar; if your input
can be described with ANTLR, Picireny can try to reduce it.
The advantages and disadvantages of this tool mirror the ones
of HDD: it is universal, but often takes very long to reduce
complex inputs. Other tools based on HDD include [ 25], [26].
Herfert in [ 4] presents a language-independent algorithm,
named Generalized Tree Reduction (GTR). It extends HDD,
in an attempt to improve its performance, combining HDD
with a greedy backtracking-based search over a set of generic
tree transformations. These transformations improve the HDD
performance and efﬁciency, by limiting the number of tree
conﬁgurations considered on every level and also allowing to
reduce the tree on several levels simultaneously.
Sun et al. [ 27] tackle the same problem (HDD performance)
from another angle in their Perses framework. Perses is also
language-agnostic and accepts input grammar in Backus-Naur
form, which is then transformed into an internal grammar
representation. Tree nodes are classiﬁed into four classes
(regular, Kleene-Plus, Kleene-Star and Optional); regular
node is replaced with its minimal compatible descendant,
other types of nodes are reduced using a variation of delta
debugging. Evaluation shows Perses produces much smaller
results compared to most other input reduction tools (55-98%
smaller) except for C-Reduce. At the same time, it performs on
average two times faster than C-Reduce. Gharachorlu et al. [ 14]
present a new technique called Pardis, which improves Perses
by prioritizing reduction of larger subtrees ﬁrst. It is shown
325
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:24:30 UTC from IEEE Xplore.  Restrictions apply. to work 1.3x to 7.8x faster than Perses, with less reduction
soundness checks and same overall reduction quality.
VII. C ONCLUSION
Despite all the latest advances in software engineering, input
reduction is still a very hard problem, in a lot of cases solved
by tedious manual efforts. The more complex an input structure
is, the more time it takes to reduce the input manually; this is
especially true for compilers, as reducing code requires deep
understanding of the said code.
In this experience paper we present an approach to automatic
input reduction for the Kotlin programming language. The
approach is based on a combination of Kotlin-speciﬁc trans-
formations, program slicing, and hierarchical delta debugging,
which are highly synergistic. It also accounts for multi-ﬁle
projects by supporting simultaneous reduction of several ﬁles.
We have implemented a prototype tool called ReduKtor
based on our approach, and performed its thorough evaluation.
The results show that, to achieve high reduction quality, one
must still employ language-speciﬁc transformations together
with general approaches, such as HDD; language-agnostic
techniques, despite their recent advances, still fail to achieve
the efﬁciency of custom transformations when used standalone.
As for our future work, we hope to explore both theoretical
and practical improvements. The input reduction pipeline
consists of multiple steps, and the order of these steps may
inﬂuence the performance; it would be interesting to see if
machine learning could be used to ﬁnd a quazi-optimal ordering,
depending on the input properties. From the practical side, we
plan to better parallelize the pipeline, allowing to perform
transformations simultaneously, and improve the integration
with Kotlin compiler, to speed up the soundness checks. We
also hope to collaborate with the Kotlin compiler team on
incorporating ReduKtor into their workﬂow, to further the
understanding of how input reduction performs in practice.
ACKNOWLEDGEMENT
We would like to express our gratitude to the Kotlin compiler
team for their support and feedback, to all the reviewers for
their questions and comments, and to our shepherd for their
help in improving the ﬁnal version of the paper.
REFERENCES
[1] A. Zeller and R. Hildebrandt, “Simplifying and isolating failure-inducing
input,” IEEE Transactions on Software Engineering , vol. 28, no. 2, pp.
183–200, 2002.
[2] M. Weiser, “Program slicing,” in International Conference on Software
Engineering . IEEE Press, 1981, pp. 439–449.
[3] G. Misherghi and Z. Su, “HDD: Hierarchical delta debugging,” in
International Conference on Software Engineering . ACM, 2006, pp.
142–151.[4] S. Herfert, J. Patra, and M. Pradel, “Automatically reducing tree-
structured test inputs,” in International Conference on Automated Software
Engineering . IEEE, 2017, pp. 861–871.
[5] D. Binkley, N. Gold, M. Harman, S. Islam, J. Krinke, and S. Y oo, “ORBS:
Language-independent program slicing,” in International Symposium on
F oundations of Software Engineering . ACM, 2014, pp. 109–120.
[6] C. D. Sterling and R. A. Olsson, “Automated bug isolation via program
chipping,” Software: Practice and Experience , vol. 37, no. 10, pp. 1061–
1086, 2007.
[7] J. Regehr, Y . Chen, P . Cuoq, E. Eide, C. Ellison, and X. Y ang, “Test-
case reduction for C compiler bugs,” in ACM SIGPLAN Conference
on Programming Language Design and Implementation , vol. 47, no. 6.
ACM, 2012, pp. 335–346.
[8] M. Koltsov, “Kotlin fuzzer,” https://github.com/ItsLastDay/KotlinFuzzer,
2017, accessed: 01.05.2019.
[9] “JS Delta,” https://github.com/wala/jsdelta, 2019, accessed: 01.05.2019.
[10] E. W. Myers, “An O(ND) difference algorithm and its variations,”
Algorithmica , vol. 1, no. 1-4, pp. 251–266, 1986.
[11] “Diff match patch library,” https://github.com/google/diff-match-patch,
2019, accessed: 01.05.2019.
[12] V . Kasyanov and I. Mirzuitova, “Slicing: Program slices and their
applications,” p. 116, 2002.
[13] T. Wang and A. Roychoudhury, “Using compressed bytecode traces
for slicing Java programs,” in International Conference on Software
Engineering , 2004, pp. 512–521.
[14] G. Gharachorlu and N. Sumner, “Pardis: Priority aware test case
reduction,” in International Conference on Fundamental Approaches
to Software Engineering . Springer, 2019, pp. 409–426.
[15] X. Y ang, Y . Chen, E. Eide, and J. Regehr, “Finding and understanding
bugs in C compilers,” in ACM SIGPLAN Conference on Programming
Language Design and Implementation , vol. 46, no. 6. ACM, 2011, pp.
283–294.
[16] S. McPeak and D. S. Wilkerson, “Delta debugging implementation,”
http://delta.tigris.org/, accessed: 01.05.2019.
[17] A. Groce, M. A. Alipour, C. Zhang, Y . Chen, and J. Regehr, “Cause
reduction: Delta debugging, even without bugs,” Software Testing,
V eriﬁcation and Reliability , vol. 26, no. 1, pp. 40–68, 2016.
[18] G. Jayaraman, V . P . Ranganath, and J. Hatcliff, “Kaveri: Delivering the
Indus Java program slicer to Eclipse,” in International Conference on
Fundamental Approaches to Software Engineering . Springer, 2005, pp.
269–272.
[19] M. Abdallah, B. Alokush, M. Alrefaee, M. Salah, R. Bader, and K. A wad,
“JavaBST: Java backward slicing tool,” in International Conference on
Information Technology . IEEE, 2017, pp. 614–618.
[20] P . Anderson, “CodeSurfer/Path inspector,” in International Conference
on Software Maintenance . IEEE, 2004, p. 508.
[21] A. Leitner, M. Oriol, A. Zeller, I. Ciupa, and B. Meyer, “Efﬁcient unit test
case minimization,” in International Conference on Automated Software
Engineering . ACM, 2007, pp. 417–420.
[22] N. Gupta, H. He, X. Zhang, and R. Gupta, “Locating faulty code
using failure-inducing chops,” in International Conference on Automated
Software Engineering . ACM, 2005, pp. 263–272.
[23] R. Hodován, Á. Kiss, and T. Gyimóthy, “Tree preprocessing and
test outcome caching for efﬁcient hierarchical delta debugging,” in
International Workshop on Automation of Software Testing . IEEE,
2017, pp. 23–29.
[24] T. Parr, The deﬁnitive ANTLR 4 reference . Pragmatic Bookshelf, 2013.
[25] Y . Lei and J. H. Andrews, “Minimization of randomized unit test cases,”
inInternational Symposium on Software Reliability Engineering . IEEE,
2005, pp. 267–276.
[26] A. Orso, S. Joshi, M. Burger, and A. Zeller, “Isolating relevant component
interactions with JINSI,” in International Workshop on Dynamic Systems
Analysis . ACM, 2006, pp. 3–10.
[27] C. Sun, Y . Li, Q. Zhang, T. Gu, and Z. Su, “Perses: Syntax-guided
program reduction,” in International Conference on Software Engineering .
ACM, 2018, pp. 361–371.
326
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:24:30 UTC from IEEE Xplore.  Restrictions apply. 