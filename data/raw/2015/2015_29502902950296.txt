On-Demand Strong Update Analysis via
Value-Flow ReÔ¨Ånement
Yulei Sui Jingling Xue
School of Computer Science and Engineering, UNSW, Australia
ABSTRACT
We present a new Strong UPdate Analysis for C programs,
called Supa , that enables computing points-to information
on-demand via value-ow renement, in environments with
small time and memory budgets such as IDEs. We formulate
Supa by solving a graph-reachability problem on a value-
ow graph representation of the program, so that strong
updates are performed where needed, as long as the total
analysis budget is not exhausted. Supa facilitates eciency
and precision tradeos by allowing dierent pointer analyses
to be applied in a hybrid multi-stage analysis framework.
We have implemented Supa in LLVM and evaluated
Supa by choosing uninitialized pointer detection as a ma-
jor client on 12 open-source C programs. As the analysis
budget increases, Supa achieves improved precision, with
its single-stage ow-sensitive analysis reaching 97% of that
achieved by whole-program ow-sensitive analysis by con-
suming about 0.19 seconds and 36KB of memory per query,
on average (with a budget of at most 10000 value-ow edges
per query).
CCS Concepts
Software and its engineering √ëSoftware verication
and validation; Software defect analysis; Theory of com-
putation√ëProgram analysis;
Keywords
strong updates, value ow, pointer analysis, ow sensitivity
1. INTRODUCTION
Strong updates , where stores overwrite, i.e., kill the previ-
ous contents of their abstract destination locations with new
values, is an important factor in the precision of pointer anal-
ysis [14, 15, 23]. In the case of weak updates , these locations
are assumed conservatively to also retain their old contents.
A pointer analysis is (1) ow-sensitive if it respects con-
trol ow and ow-insensitive otherwise and (2) context-
sensitive if it distinguishes dierent calling contexts and
context-insensitive otherwise. A ow-sensitive analysis canstrongly update an abstract location written at a store if
and only if that location refers to exactly one concrete mem-
ory address. By applying strong updates where needed, an
analysis can improve precision, thereby providing signicant
benets to many clients, such as change impact analysis [2],
bug detection [58], security analysis [4], type state verica-
tion [12], compiler optimization, and symbolic execution [5].
In this paper, we investigate how to perform strong up-
dates eectively in analyzing large C programs, for which
ow-sensitivity is important in achieving the precision re-
quired by the afore-mentioned client applications. For
object-oriented languages like Java, context-sensitivity is es-
sential in achieving useful precision [24, 26, 27, 28, 32, 33,
42, 53, 54, 56].
Ideally, strong updates at stores should be performed by
analyzing all paths independently by solving a meet-over-all-
paths (MOP) problem. However, even with branch condi-
tions ignored, this problem is intractable due to potentially
unbounded number of paths that must be analyzed [21, 38].
Instead, traditional ow-sensitive pointer analysis ( FS)
for C [17, 18] computes the maximal-xed-point solution
(MFP) as an over-approximation of MOP by solving an it-
erative data-ow problem. Thus, the data-ow facts that
reach a conuence point along dierent paths are merged.
Recently, sparse ow-sensitive pointer analysis ( SFS) [15,
25, 35, 59, 60] boosts the performance of FS in analyzing
large C programs while maintaining the same strong updates
done by FS. The basic idea is to rst conduct a pre-analysis
on the program to over-approximate its def-use chains and
then perform FS by propagating the data-ow facts, i.e.,
points-to information sparsely along only the pre-computed
def-use chains (aka value-ows) instead of all program points
in the program's control-ow graph.
Recently, an approach [23] for performing strong updates
in C programs is introduced. It sacrices the precision of FS
to gain eciency by applying strong updates at stores where
ow-sensitive singleton points-to sets are available but falls
back to the ow-insensitive points-to information otherwise.
By nature, the challenge of pointer analysis is to make ju-
dicious tradeos between eciency and precision. Virtually
all of the prior analyses that consider some degree of ow-
sensitivity are whole-program analyses. Precise ones are un-
scalable since they must typically consider both ow- and
context-sensitivity ( FSCS ) in order to maximize the num-
ber of strong updates performed. In contrast, faster ones
like [23] are less precise, due to both missing strong updates
and propagating the points-to information ow-insensitively
along all the weakly-updated (abstract) locations.
In practice, a client application may require only parts of
the program to be analyzed. In addition, some queries may
demand precise answers while others can be answered as
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission and/or a
fee. Request permissions from Permissions@acm.org.
FSE‚Äô16 , November 13‚Äì18, 2016, Seattle, WA, USA
c2016 ACM. 978-1-4503-4218-6/16/11...$15.00
http://dx.doi.org/10.1145/2950290.2950296
Artifact evaluated by FSE‚úì
460
Program
Pre-analysis
Value-Flows
Stage[i]
On-Demand Reachability SolverQueries
Out-Of-Budget[i]?
StagesStage[0]Stage[N-1]EfÔ¨ÅciencyPrecision....BudgetsNoYesSelect  ii++ReÔ¨ÅneFigure 1: Overview of Supa
precisely as possible with small time and memory budgets.
In all these cases, performing strong updates blindly across
the entire program is cost-ineective in achieving precision.
For C programs, how do we develop precise and ecient
pointer analyses that are focused and partial, paying closer
attention to the parts of the programs relevant to on-demand
queries? Existing demand-driven analyses for C [16, 61,
64] and Java [29, 41, 44, 47, 57] are ow-insensitive and
thus cannot perform strong updates to produce the preci-
sion needed by some clients. In addition, recent advances in
whole-program ow-sensitive analysis for C have exploited
some form of sparsity to improve performance [15, 25, 35,
59, 60]. However, how to replicate this success for demand-
driven ow-sensitive analysis is unclear. Finally, it remains
open as to whether sparse strong update analysis can be
performed both ow- and context-sensitively on-demand to
avoid under- or over-analyzing.
In this paper, we introduce Supa , the rst value-ow
based demand-driven Strong UPdateAnalysis for C, de-
signed to support exible yet eective tradeos between
eciency and precision in answering client queries, in en-
vironments with small time and memory budgets such as
IDEs. As shown in Figure 1, its novelty lies in performing
strong update analysis precisely by rening imprecisely pre-
computed value-ows away in a hybrid multi-stage analysis
framework. Given a points-to query, strong updates are per-
formed by solving a graph-reachability problem on an inter-
procedural value-ow graph that captures the def-use chains
of the program obtained conservatively by a pre-analysis.
Such over-approximated value-ows can be obtained by ap-
plying Andersen's analysis [3] (ow-insensitively). Supa
conducts its reachability analysis on-demand sparsely along
only the pre-computed value-ows rather than control-ows.
In addition, Supa lters out imprecise value-ows by per-
forming strong updates where needed with no loss of preci-
sion as long as the total analysis budget is sucient. The
precision of Supa depends on the degree of value-ow rene-
ment performed under a budget. The more spurious value-
ows Supa removes, the more precise the nal results are.
Supa handles large programs by staging analyses in in-
creasing eciency but decreasing precision in a hybrid man-
ner. Presently, Supa proceeds in two stages by applying
FSCS andFSin that order with a congurable budget for
each analysis. When failing to answer a query in a stage
within its alloted budget, Supa downgrades itself to a more
scalable but less precise analysis in the next stage and will
eventually fall back to the pre-computed ow-insensitive in-
formation. At each stage, Supa will re-answer the query by
reusing the points-to information found from processing the
current and earlier queries. By increasing the budgets used
in the earlier stages (e.g., FSCS ),Supa will obtain improved
precision via improved value-ow renement.
  p = &a;  q = &c;  a = &b;  c = &d; t1 = *p; *p = *q; *q = t1;   p = &a;   q = &c;    x = &b;    y = &d;*p = x;*q = y;  t1 = *p;  t2 = *q; *p = t2; *q = t1;(a) C code(b) Partial SSA pqacbdpqacbd(c) Before swap(d) After swapswapswapFigure 2: A swap example and its partial SSA (with
the points-to relations for pandqat run time)
This paper makes the following contributions:
We present the rst strong update analysis for C that
enables computing precise points-to information on-
demand, with strong updates applied where needed,
by rening away imprecisely precomputed value-ows,
subject to analysis budgets.
We introduce a hybrid multi-stage analysis framework
that facilitates eciency and precision tradeos by
staging dierent analyses in answering client queries.
We have produced an implementation of Supa in
LLVM with its artifact available at [1]. We choose
uninitialized pointer detection as a practical client us-
ing 12 open-source C programs. As the analysis bud-
get increases, Supa achieves improved precision, with
its single-stage ow-sensitive analysis reaching 97% of
that achieved by whole-program ow-sensitive analy-
sis, by consuming about 0.19 seconds and 36KB of
memory per query, on average (with a per-query bud-
get of at most 10000 value-ow edges traversed).
2. BACKGROUND
We describe the partial SSA form used for representing a
C program and the sparse value-ow graph used for repre-
senting conservatively its value-ows, i.e., def-use chains.
2.1 Partial SSA Form
We represent a program by putting it into LLVM's par-
tial SSA form, following [15, 23, 25, 59, 50]. The set of all
variablesVare separated into two subsets: Acontaining
all possible targets, i.e., address-taken variables of a pointer
andTcontaining all top-level variables , whereVTYA.
After the SSA conversion, a program is represented by
ve types of statements: p&a(AddrOf ),pq(Copy ),
pq(Load ),pq(Store ), andppq;rq(Phi). Top-
level variables are put directly in SSA form, while address-
taken variables are accessed indirectly via Load orStore .
Passing arguments into and returning results from functions
are modeled by copies. For an AddrOf statementp&a,
known as an allocation site ,ais a stack or global variable or
a dynamically created abstract heap object.
Figure 2 shows a swap program in C and its corresponding
partial SSA form, where p;q;x;y;t 1;t2PTanda;b;c;dPA.
Here,x;y;t 1 andt2 are new temporaries introduced.
2.2 Sparse Value-Flow Graph
Given a program in partial SSA form, a sparse value-ow
graph (SVFG)GpN;Eqis a multi-edged directed graph
461    z = *t3;(a) A program and its SVFG (withonly indirect value-Ô¨Çows shown) (d) The SUPA analysis for resolving  pt(‚ü®‚Ñì16 ,z‚ü©) = {i} bytraversing from ‚ü®‚Ñì16 ,z‚ü© backwards against the value-Ô¨Çows
1[a][a][c][c]
[b][b][d][d]‚Ñì16:
 *q = y;   
 p = &a;   
  t2 = *q;
  t3 = *p;
      z = *t3;
 y = &d;   
 v = &i;   
  *p = t2;
  *t3 = v; *t3 = w;[b][d][d][b]
 q = &c;   [q][q][p][p][t2][y]
[t3][v][t3]
2
3[a]
4
5
6[c]
7
8
9
SU for d
SU for a
SU for c‚Ñì1:‚Ñì2:‚Ñì4:‚Ñì6:‚Ñì8:‚Ñì9:‚Ñì12:‚Ñì13:‚Ñì14:‚Ñì15:‚Ñì16:paqcbdiut3z(b) Flow-sensitive points-to relations found to hold at the end of the program (with some for top-level pointers omitted) Direct Value-Ô¨Çow Indirect Value-Ô¨Çow Points-toSpurious Points-topaqcbdiut3zswap
*t3 = v;*t3 = w; t3 = *p;  v = &i;  w = &u;*q = t1; *p = t2;  t2 = *q;  t1 = *p;*q = y;*p = x;    y = &d;    x = &b;    q = &c;    p = &a;‚Ñì1:‚Ñì2:‚Ñì3:‚Ñì5:‚Ñì6:‚Ñì7:‚Ñì8:‚Ñì4:
‚Ñì10:‚Ñì9:
‚Ñì14:‚Ñì15:‚Ñì13:‚Ñì11:‚Ñì12:
(c) Flow-insensitive points-to relations(with some for top-level pointers omitted) Spurious Value-Flowsxxx*p = x;[a]
[a]x‚Ñì5:.Querypt(‚ü®‚Ñì16 ,z‚ü©) =?Figure 3: A motivating example for illustrating the Supa analysis (with SU standing for \Strong Update")
that captures its def-use chains conservatively. Nis the set
of nodes representing all statements and Eis the set of edges
representing all potential def-use chains. In particular, an
edge`1v√ù √ë`2, wherevPV, from statement `1to statement
`2signies a potential def-use chain for vwith its def at
`1and use at `2. This representation is sparse since the
intermediate program points between `1and`2are omitted.
As top-level variables are in SSA form, their uses have
unique denitions (with functions inserted at conuence
points as is standard). A def-use chain `1t√ù √ë`2, wheretPT,
represents a direct value-ow oft. Such def-use chains can
be found easily without requiring pointer analysis.
As address-taken variables are not (yet) in SSA form, their
indirect uses at loads may be dened indirectly at multiple
stores. We can build their def-use chains in several steps
by following [15, 51], with an illustrating example given in
Section 3. First, the points-to information in the program
is computed by a pre-analysis. Second, a load p qis
annotated with a function paqfor each variable aPAthat
may be pointed to by qto represent a potential use of aat the
load. Similarly, a store pqis annotated with a function
apaqfor each variable aPAthat may be pointed to by
pto represent a potential def and use of aat the store. If a
can be strongly updated, then areceives whatever qpoints
to and the old contents in aare killed. Otherwise, amust
also incorporate its old contents, resulting in a weak update
toa. Third, we convert all the address-taken variables into
SSA form, with each paqtreated as a use of aand each
apaqas both a def and use of a. Finally, we obtain the
indirect def-use chains for an address-taken variable aPA
as follows. For a use of aidentied as an(with its versionidentied by n) at a load or store `, its unique denition in
SSA form is anat a store`1. Then, an indirect def-use chain
`1a√ù √ë`is added to represent potentially the indirect value-
ow ofafrom`1to`. Note that the functions introduced
for address-taken variables will now be ignored as the value
athat appears in `1a√ù √ë`is not versioned.
3. A MOTIVATING EXAMPLE
Our example program, shown in Figure 3(a), is simple
(even with 16 lines). The program consists of a straight-
line sequence of code, with `1{`10taken directly from Fig-
ure 2(b) and the six new statements `11{`16added to enable
us to highlight some key properties of Supa . We assume
thatuat`11is uninitialized but iat`12is initialized. The
SVFG embedded in Figure 3(a) will be discussed later. We
describe how Supa can be used to prove that zat`16points
only to the initialized object i, by computing on-demand the
points-to query ptpx`16;zyq, i.e., the points-to set of zat the
program point after `16, which is dened in (1) in Section 4.
Figure 3(b) depicts the points-to relations for the six
address-taken variables and some top-level ones found at the
endof the code sequence by a whole-program ow-sensitive
analysis (with strong updates) like SFS [15]. Due to ow-
sensitivity, multiple solutions for a pointer are maintained.
In this example, these are the true relations observed at the
end of program execution. Note that SFS gives rise to Fig-
ure 2(c) by analyzing `1{`6, Figure 2(d) by analyzing also
`7{`10, and nally, Figure 3(b) by analyzing `11{`16fur-
ther. Aszpoints toibut notu, no warning is issued for z.
Figure 3(c) shows how the points-to relations in Fig-
ure 3(b) are over-approximated ow-insensitively by apply-
462ing Andersen's analysis [3]. In this case, a single solution is
computed conservatively for the entire program. Due to the
lack of strong updates in analyzing the two stores performed
byswap , the points-to relations in Figures 2(c) and 2(d)
are merged, causing aandcto become spurious aliases.
When`11{`16are analyzed, the seven spurious points-to
relations (shown in dashed arrows in Figure 3(c)) are intro-
duced. Since zpoints toi(correctly) and u(spuriously), a
false positive for zwill be issued. Failing to consider ow-
sensitivity, Andersen's analysis is not precise for this client.
Let us now explain how Supa , shown in Figure 1, works.
Supa will rst perform a pre-analysis to the example pro-
gram to build the SVFG given in Figure 3(a). For its top-
level variables, their direct value-ows, i.e., def-use chains
are explicit and thus omitted to avoid cluttering. For ex-
ample,qhas three def-use chains `2q√ù √ë`6,`2q√ù √ë`8and
`2q√ù √ë`10. For its address-taken variables, we rst apply
Andersen's analysis to nd ow-insensitively their points-to
relations, which are given in Figure 3(c). We then obtain
the nine indirect value-ows, i.e., def-use chains depicted in
Figure 3(a), as described in Section 2. Let us see how the
two def-use chains for bare created. As t3 points to b,`14,
`15and`16will be annotated with bpbq,bpbqand
pbq, respectively. By putting bin SSA form, these three
functions become b2pb1q,b3pb2qandpb3q. Hence,
we have`14b√ù √ë`15and`15b√ù √ë`16, indicating bat`16has two
potential denitions, with the one at `15overwriting the one
at`14. The def-use chains for dandaare built similarly.
Let us consider a single-stage analysis with Stage[N-1]
Stage[0]FSin Figure 1. Figure 3(d) shows how Supa
computes ptpx`16;zyqon-demand, starting from `16, by per-
forming a backward reachability analysis on the SVFG, with
the visiting order of def-use chains marked as 1{9. For-
mally, this is done in Figure 5. The def-use chains for only
the relevant top-level variables are shown. By ltering out
the four spurious value-ows (marked by ),Supa nds that
onlyiat`12is backward reachable from zat`16. Thus,
ptpx`16;zyqtiu. So no warning for zwill be issued.
Supa diers from prior work in three major aspects:
On-Demand Strong Updates
A whole-program ow-sensitive analysis like SFS [15]
can answer ptpx`16;zyqprecisely but must accomplish
this task by analyzing all the 16 statements, resulting
in six strong updates at the six stores, with some done
unnecessarily for this query. Unfortunately, existing
whole-program FSCS or even just FS algorithms do
not scale well for large C programs [2].
In contrast, Supa computes ptpx`16;zyqprecisely by
performing only three strong updates at `6,`9and
`15. The earlier Supa performs a strong update dur-
ing its reachability analysis, the fewer the number of
statements traversed. After 1{8,Supa nds thatt3
points todonly. With a strong update done at `15:
t3v(9),Supa concludes that ptpx`16;zyqtiu.
Value-Flow Renement
Existing demand-driven analyses [41, 44, 57, 61, 64]
are ow-insensitive and thus suer from the same im-
precision as their ow-insensitive whole-program coun-
terparts. In the absence of strong updates, many spu-
rious aliases (such as aandc) result, causing ztopoint to both iandu. As a result, a false positive for
zis issued, as discussed earlier.
However, Supa performs strong updates ow-
sensitively by ltering out the four spurious pre-
computed value-ows marked by . Ast3 points to
donly,`15b√ù √ë`16is spurious and not traversed. In ad-
dition, a strong update is enabled at `15:t3v,
rendering`14b√ù √ë`15and`14d√ù √ë`15spurious. Finally,
`5a√ù √ë`9is rened away due to another strong update
done at`9. Thus, Supa has avoided many spurious
aliases (e.g.,aandc) introduced ow-insensitively
by pre-analysis, resulting in ptpx`16;zyqtiuprecisely.
Thus, no warning for zis issued.
Query-based Precision Control
To balance eciency and precision, Supa operates in
a hybrid multi-stage analysis framework. When asked
to answer the query ptpx`16;zyqin, say, three steps,
Supa will stop its traversal from `9to`8(at4) in
Figure 3(d) and falls back to the pre-computed results
by returning ptpx`16;zyqtu;iu. In this case, a false
positive for zwill end up being reported.
4. DEMAND-DRIVEN STRONG UPDATES
We introduce our on-demand strong update analysis (Fig-
ure 1). We rst describe our inference rules in a ow-
sensitive setting (Section 4.1). We then discuss our context-
sensitive extension (Section 4.2). Finally, we examine our
hybrid multi-stage analysis framework (Section 4.3). All our
analyses are eld-sensitive, as discussed in Section 5.1.
4.1 Formalism: Flow-Sensitivity
We present a formalization of a single-stage Supa consist-
ing of only a ow-sensitive (FS) analysis. Given a program,
Supa will operate on its SVFG representation Gvfgcon-
structed by applying Andersen's analysis as a pre-analysis,
as discussed in Section 2.2 and illustrated in Section 3.
LetVLVbe the set of labeled variables lv, where
Lis the set of statement labels and VTYA.Supa
conducts a backward reachability analysis ow-sensitively
onGvfgby computing a reachability relation, √ê√¢¬ÑVV. In
our formalism, x`;vy√ê √¢x`1;v1ysignies a value-ow from a
def ofv1at`1to a use ofvat`through one or multiple value-
ow paths in Gvfg. For an object ocreated at an AddrOf
statement, i.e., an allocation site at `1, identied as x`1;oy,
we must distinguish it from x`;oyaccessed elsewhere at `in
our inference rules. Our abbreviation for x`1;oyispo.
Givenx`;vy,Supa computes ptpx`;vyq, i.e., the points-to
set ofx`;vyby nding all reachable target objects po:
ptpx`;vyqto|x`;vy√ê √¢pou (1)
Despite ow-sensitivity, our formalization in Figure 4 makes
no explicit references to program points. As Supa operates
on the def-use chains in Gvfg, each variable x`;vymentioned
in a rule appears at the point just after `, wherevis dened.
Let us examine our rules in detail. By [ADDR] , an object
pocreated at an allocation site `is backward reachable from
pat`(or precisely at the point after `). The pre-computed
direct value-ows across the top-level variables in Gvfgare
always precise ( [COPY] and [PHI] ). In partial SSA form,
[PHI] exists only for top-level variables (Section 2.2).
However, the indirect value-ows across the address-taken
variables in Gvfgcan be imprecise; they need to be rened on
463[ADDR]`:p&o
x`;py√ê √¢po[COPY]`:pq `1q√ù √ë`
x`;py√ê √¢x`1;qy[PHI]`:ppq;rq`1q√ù √ë` `2r√ù √ë`
x`;py√ê √¢x`1;qy x`;py√ê √¢x`2;ry
[LOAD]`:pq `2q√ù √ë`x`2;qy√ê √¢po `1o√ù √ë`
x`;py√ê √¢x`1;oy[STORE]`:pq `2p√ù √ë`x`2;py√ê √¢po `1q√ù √ë`
x`;oy√ê √¢x`1;qy
[SU/WU]`:p`1o√ù √ë` oPAzkillp`;pq
x`;oy√ê √¢x`1;oy[COMPO]lv√ê√¢lv1lv1√ê√¢lv2
lv√ê√¢lv2
killp`;pq$
'&
'%to1uifptpx`;pyqto1u^o1Psingletons
A else if ptpx`;pyq?
? otherwise
Figure 4: Single-stage ow-sensitive Supa analysis with demand-driven strong updates
`13:t3p `1p√ù √ë`13`1:p&a
x`1;py√ê √¢pa[ADDR]`9a√ù √ë`13
x`13;t3y√ê √¢x`9;ay[LOAD]`9:pt2`1p√ù √ë`9x`1;py√ê √¢pa`8t2√ù √ë`9
x`9;ay√ê √¢x`8;t2y[STORE]
x`13;t3y√ê √¢x`8;t2y[COMPO]
(a)Deriving ptpx`13;t3yq(corresponding to 1{4in Figure 3(d))
x`13;t3y√ê √¢x`8;t2y`8:t2q `2q√ù √ë`8`2:q&c
x`2;qy√ê √¢pc[ADDR]`6c√ù √ë`8
x`8;t2y√ê √¢x`6;cy[LOAD]
x`13;t3y√ê √¢x`6;cy[COMPO]`6:qy `2q√ù √ë`6x`2;qy√ê √¢pc`4y√ù √ë`6
x`6;cy√ê √¢x`4;yy[STORE]
x`13;t3y√ê √¢x`4;yy[COMPO]`4:y&d
x`4;yy√ê √¢pd[ADDR]
x`13;t3y√ê √¢pd[COMPO]
(b)Deriving ptpx`13;t3yq(corresponding to 5{7in Figure 3(d))
`16:zt3`13t3√ù √ë`16x`13;t3y√ê √¢pd `15d√ù √ë`16
x`16;zy√ê √¢x`15;dy[LOAD]`15:t3v `13t3√ù √ë`15x`13;t3y√ê √¢pd`12v√ù √ë`15
x`15;dy√ê √¢x`12;vy[STORE]
x`16;zy√ê √¢x`12;vy[COMPO]`12:v&i
x`12;vy√ê √¢pi[ADDR]
x`16;zy√ê √¢pi[COMPO]
(c)Deriving ptpx`16;zyq(corresponding to 8{9in Figure 3(d))
Figure 5: Reachability derivations for ptpx`16;zyqshown in Figure 3(d) (with reuse of cached points-to results
inside each box)
the y to remove the spurious aliases thus introduced. When
handling a load pqin[LOAD] , we can traverse backwards
frompat`to the def of oat`1only ifoisactually used
by, i.e., aliased with qat`, which requires the reachability
relationx`2;qy √ê √¢poto be computed recursively. A store
pqis handled similarly ( [STORE] ):qdened at`1can be
reached backwards by oat`only ifois aliased with pat`.
Ifqin a loadqis aliased with pin a storep
executed earlier, then pandqmust be both backward
reachable from po. Otherwise, any alias relation established
betweenpandqinGvfgby pre-analysis must be spurious
and will thus be ltered out by value-ow renement.
[SU/WU] models strong and weak updates at a store
`:p. Dening its kill set killp`;pqinvolves three cases.
In Case (1), ppoints to one singleton object o1insingletons ,
which contains all objects in Aexcept the local variables
in recursion, arrays (treated monolithically) or heap ob-
jects [23]. In Section 4.2, we discuss how to apply strong
updates to heap objects context-sensitively. A strong up-date is then possible to o. By killing its old contents at `1,
no further backward traversal along the def-use chain `1o√ù √ë`
is needed. Thus, x`;oy√ê √¢x`1;oyis falsied. In Case (2), the
points-to set of pis empty. Again, further traversal to x`1;oy
must be prevented to avoid dereferencing a null pointer as
is standard [14, 15, 23]. In Case (3), a weak update is per-
formed tooso that its old contents at `1are preserved. Thus,
x`;oy√ê √¢x`1;oyis established, which implies that the back-
ward traversal along `1o√ù √ë`must continue.
Finally,√ê√¢is transitive, stated by [COMPO] .
Let us try all our rules, by rst revisiting our motivat-
ing example where strong updates are performed extensively
(Example 1) and then examining weak updates (Example 2).
Example 1. Figure 5 shows how we apply the rules of Supa
to answer ptpx`16;zyqillustrated in Figure 3(d). [SU/WU]
(implicit in these derivations) is applied to `6,`9and`15to
cause a strong update at each store. At `6,ptpx`6;qyqtcu,
the old contents in care killed. At `9,`5a√ù √ë`9becomes
464spurious since x`9;ay√ê √¢x`5;ayis falsied. At `15,`14b√ù √ë
`15and`14d√ù √ë`15are ltered out since x`15;by√ê √¢x`14;byand
x`15;dy√ê √¢x`14;dyare falsied. Finally, `15b√ù √ë`16is ignored
sincet3points todonly ( [LOAD] ). l
Supa improves performance by caching points-to results
to reduce redundant traversal, with reuse happening in the
marked boxes in Figure 5. For example, in Figure 5(c),
ptpx`13;t3yqt pducomputed in [LOAD] is reused in [STORE] .
Example 2. Let us consider a weak update example in Fig-
ure 6 by computing ptpx`11;zyqon-demand. At the conu-
ence point`9,p3receives the points-to information from both
p1andp2in its two branches: x`9;p3y√ê √¢paandx`9;p3y√ê √¢pe.
Thus, a weak update is performed to the two locations aand
eat`10. Let us focus on paonly. By applying [STORE] ,
x`10;ay √ê √¢x`4;ry √ê √¢pd. By applying [SU/WU] ,x`10;ay √ê √¢
x`6;ay √ê √¢x`3;yy √ê √¢pc. Thus, ptpx`11;ayq  tc;du, which
excludesbdue to a strong update performed at `6. As
ptpx`7;qyqtau, we obtain ptpx`11;zyqtc;du. l
            p1 = &a;              x = &b;              y = &c;              r = &d;           *p1 = x;            *p1 = y;              q = p1      if(*) p2 = &e;            p3 = /u1D7A5(p1,p2);            *p3 = r;              z = *q;‚Ñì1:‚Ñì8:‚Ñì9:‚Ñì10:‚Ñì2:‚Ñì3:‚Ñì5:‚Ñì6:‚Ñì7:‚Ñì11:[a][a]
WU for a[a]Andersen's Points-to: pt(p1) = {a} pt(p2) = {e}    pt(p3) = {a,e}  pt(q) = {a}  pt(x) = {b}  pt(y) = {c}   pt(r) = {d}        pt(a) = {b,c,d}        pt(z) = {b,c,d}
SU for aQuerypt(‚ü®‚Ñì11 ,z‚ü©) =?‚Ñì4:Direct value-Ô¨Çow Indirect value-Ô¨Çow 
Figure 6: Resolving ptpx`11;zyqtc;duwith a weak
update
Unlike [23], which falls back to the ow-insensitive points-
to information for all weakly updated objects, Supa handles
them as precisely as (whole-program) ow-sensitive analysis
given a sucient budget. In Figure 6, due to a weak up-
date performed to aat`10,ptpx`10;ayqtc;duis obtained,
forcing their approach to adopt ptpx`10;ayqtb;c;duthere-
after, causing ptpx`11;zyqtb;c;du. By maintaining ow-
sensitivity with a strong update applied to `6to killb,Supa
obtains ptpx`11;zyqtc;duprecisely.
4.1.1 Handling Value-Flow Cycles
To compute soundly and precisely the points-to informa-
tion in a value-ow cycle, Supa retraverses it whenever new
points-to information is found until a x point is reached.
Example 3. Figure 7 shows a value-ow cycle formed by
`5x√ù √ë`6and`6z√ù √ë`5. To compute ptpx`6;zyq, we must com-
pute ptpx`5;xyq, which requires the aliases of zat the load
`5:xzto be found by using ptpx`6;zyq.Supa computes
ptpx`6;zyqby analyzing this value-ow cycle in two itera-
tions. In the rst iteration, a pointed-to target pbis found
sincex`6;zy√ê √¢x`4;yy√ê √¢pb. Due tox`2;qy√ê √¢pb,zandq
               p = &a;               q = &b;              *q = p;               y = &b;               x = *z;                z = /u1D7A5(x,y);‚Ñì2:‚Ñì3:‚Ñì4:‚Ñì5:‚Ñì6:[b][z][x].Querypt(‚ü®‚Ñì5 ,z‚ü©) =?Direct Value-Ô¨Çow Indirect Value-Ô¨Çow ‚Ñì1:Figure 7: Resolving ptpx`5;zyqta;buin a value-ow
cycle
are found to be aliases. In the second iteration, another tar-
getpais found since x`6;zy√ê √¢x`5;xy√ê √¢x`3;by√ê √¢x`1;py√ê √¢
pa. Thus, ptpx`6;zyqta;buis obtained. l
4.1.2 Call Graph ReÔ¨Ånement
Unlike [15], which uses an imprecisely pre-computed call
graph during its analysis, Supa renes it on-the-y. Let us
consider how to resolve the points-to set of zat an indirect
callsite`:zpfpqpq. Instead of analyzing all the callees
found by the pre-analysis, Supa recursively computes the
points-to set of fpto discover new callees at the callsite and
then continues rening ptpx`;zyqusing the new callees.
4.1.3 Properties
Theorem 1 (Soundness) .Supa is sound in analyzing a
program as long as its pre-analysis is sound.
Proof Sketch. When building the SVFG for a program,
the def-use chains for its top-level variables are identied ex-
plicitly in its partial SSA form. If the pre-analysis is sound,
then the def-use chains built for all the address-taken vari-
ables are over-approximate. According to its inference rules
in Figure 4, Supa performs essentially a ow-sensitive anal-
ysis on-demand, by restricting the propagation of points-to
information along the precomputed def-use chains, and falls
back to the sound points-to information computed by the
pre-analysis when running out of its given budgets. Thus,
Supa is sound if the pre-analysis is sound.
Theorem 2 (Precision) .Givenx`;vy,ptpx`;vyqcomputed
bySupa is the same as that computed by (whole-program)
FSifSupa can successfully resolve it within a given budget.
Proof Sketch. Let ptSupapx`;vyqand ptFSpx`;vyqbe the
points-to sets computed by Supa andFS, respectively. By
Theorem 1, ptSupapx`;vyq ¬Ö ptFSpx`;vyq, since Supa is a
demand-driven version of FSand thus cannot be more pre-
cise. To show that ptSupapx`;vyq ¬Ñ ptFSpx`;vyq, we note
that Supa operates on the SVFG of the program to im-
prove its eciency, by also ltering out value-ows impre-
cisely pre-computed by the pre-analysis. For the top-level
variables, their direct value-ows are precise. So Supa pro-
ceeds exactly the same as FS([ADDR] ,[COPY] ,[PHI] and
[COMPO] ). For the address-taken variables, Supa establishes
the same indirect value-ows ow-sensitively as FSdoes
but in a demand-driven manner, by rening away impre-
cisely pre-computed value-ows ( [LOAD] ,[STORE] ,[SU/WU]
and [COMPO] ). IfSupa can complete its query within the
given budget, then ptSupapx`;vyq ¬Ñ ptFSpx`;vyq. Thus,
ptSupapx`;vyq ptFSpx`;vyq.
465[C-ADDR]c;`:p&o
xc;`;py√ê √¢pc;poq[C-COPY]c;`:pq `1q√ù √ë`
xc;`;py√ê √¢xc;`1;qy[C-PHI]c;`:ppq;rq`1q√ù √ë` `2r√ù √ë`
xc;`;py√ê √¢xc;`1;qy xc;`;py√ê √¢xc;`2;ry
[C-LOAD]c;`:pq `2q√ù √ë`xc;`2;qy√ê √¢pc1;poq`1o√ù √ë`
xc;`;py√ê √¢xc1;`1;oy[C-STORE]c;`:pq `2p√ù √ë`xc;`2;py√ê √¢pc1;poq`1q√ù √ë`
xc1;`;oy√ê √¢xc;`1;qy
[C-SU/WU]c;`:p`1o√ù √ë`pc1;oqPAzkillpc;`;pq
xc1;`;oy√ê √¢xc1;`1;oy[C-COMPO]lv√ê√¢lv1lv1√ê√¢lv2
lv√ê√¢lv2
[C-CALL]c;`cal:vv1c1ca `1v1
√ù √ë`cal
xc;`cal;vy√ê √¢xc1;`1;v1y[C-RET]c;`ret:vv1c1c` `1v1
√ù √ë`ret
xc;`ret;vy√ê √¢xc1;`1;v1y
killpc;`;pq$
'&
'%tpc1;o1quifptpxc;`;pyqtpc1;o1qu^pc1;o1qPcxtSingletons
A else if ptpxc;`;pyq?
? otherwise
Figure 8: Single-stage ow- and context-sensitive Supa analysis with demand-driven strong updates
4.2 Formalism:Flow- and Context-Sensitivity
We extend our ow-sensitive formalization by considering
also context-sensitivity to enable more strong updates (espe-
cially now for heap objects). We solve a balanced-parentheses
problem by matching calls and returns to lter out unreal-
izable inter-procedural paths [29, 40, 41, 44, 57]. A context
stackcis encoded as a sequence of callsites, [ 1:::m].c`
denotes an operation for pushing a callsite intoc.ca
popsfromcifccontainsas its top value or is empty since
a realizable path may start and end in dierent functions.
With context-sensitivity, a statement is parameterized ad-
ditionally by a context c, e.g.,c;`:p&o, to represent its
instance when its containing function is analyzed under c. A
labeled variable lvhas the form xc;`;vy, representing vari-
ablevaccessed at statement `under context c. An object po
that is created at an AddrOf statement under context cis
also context-sensitive, identied as pc;poq.
Givenxc;`;vy,Supa computes its points-to set context-
sensitively by applying the rules given in Figure 8:
ptpxc;`;vyqtpc1;oq|xc;`;vy√ê √¢pc1;poqu
where the reachability relation √ê√¢is now context-sensitive.
Passing parameters to and returning results from a callee
invoked at a callsite are modeled by copies ( vv1) [15,
51, 60]. In [C-CALL] ,v1PVdenotes a variable passed into
the callee directly or indirectly via parameter passing. Sim-
ilarly,v1in[C-RET] represents a value returned directly or
indirectly from the callee to its caller. Such def-use chains
are built in the same way as others (Section 2.2), based on
the points-to information obtained by pre-analysis.
With context-sensitivity, Supa will lter out more spu-
rious value-ows, thereby producing more precise points-to
information to enable more strong updates ( [C-SU/WU] ). At
a storec;`:p, its kill set is context-sensitive. A strong
update is applied if ppoints to a context-sensitive singleton
pc1;o1q PcxtSingletons , whereo1is a (non-heap) singleton
dened in Section 4.1 or a heap object with c1being a con-
crete context, i.e., one not involved in recursion or loops.
For a given program, the SCCs (strongly connected com-
ponents) in its call graph are constructed on the y. Supa
handles the SCCs in the program context-sensitively but the
function calls inside a SCC context-insensitively as in [44].
4.3 SUPA: Hybrid Multi-Stage Analysis
To facilitate eciency and precision tradeos in answer-
ing on-demand queries, Supa , as illustrated in Figure 1, or-ganizes its analyses in multiple stages sorted in increasing
eciency but decreasing precision. Let there be Mqueries
issued successively from the program. Let the Nstages of
Supa ,Stage[0];;Stage[N-1] , be congured with bud-
gets0;;N1, respectively. In our current implementa-
tion, each budget is specied as the maximum number of
def-use chains traversed in the SVFG of the program.
Supa answers a query on-demand by applying its Nanal-
yses successively, starting from Stage[0] . If the query is
not answered after budget ihas been exhausted at stage i,
Supa re-issues the query at stage i 1, and eventually falls
back to the results pre-computed by pre-analysis.
Supa caches fully computed points-to information in a
query and reuses it in subsequent queries, as illustrated in
Figure 5. LetQbe the set of queried variables issued from
a program. LetI¬ÖQbe the set of variables reached from
Qduring the analysis. Let p`;vqPQbe a queried variable.
We write pti
ipxi;`;vyqto represent the points-to set of a
variablex`;vycomputed at stage iunder budget i, where
iis a contextual qualier at stage i(e.g.,cin FSCS).
By convention, ptN
NpxN;`;vyqdenotes the points-to set
obtained by pre-analysis, at Stage[N] (conceptually).
When resolving pti
ipxi;`;vyqat stagei, suppose Supa
has reached a variable x`1;v1y PIand needs to compute
pti
pxi;`1;v1yq, wherep¬§i) represents an unknown bud-
get remaining, with p`1;v1qbeingp`;vqpossibly (in a cycle).
Presently, Supa exploits two types of reuse to improve
eciency with no loss of precision in a hybrid manner:
Backward Reuse: p`1;v1qPIIfptj
pxj;`1;v1yq, where
j¬§i, was previously cached, then pti
pxi;`1;v1yq
ptj
pxj;`1;v1yq, provided that ptj
pxj;`1;v1yqis a
sound representation of pti
pxi;`1;v1yq. For exam-
ple, if Stage[i]FSandStage[j]FSCS , then
ptFSCS
pxc1;`1;v1yqcan be reused for ptFS
px`1;v1yqifc1
istrue, representing a context-free points-to set.
Forward Reuse: p`1;v1qPQIfptj
jpxj;`1;v1yq, where
j¬°i, was previously computed and cached but
ptk
kpxk;`1;v1yqwas not, where 0 ¬§k¬†j, then Supa
will also fail for ptk
pxk;`1;v1yq, wherei¬§k¬†j, since
¬§k. Therefore, Supa will exploit the second type
of reuse by setting pti
pxi;`1;v1yq ptj
jpxj;`1;v1yq.
Of course, many other schemes are possible with or with-
out precision loss and will be investigated in future work.
4665. EVALUATION
We evaluate Supa by choosing detection of uninitialized
pointers as a major client. The objective is to show that
Supa is eective in answering client queries, in environments
with small time and memory budgets such as IDEs, by facil-
itating eciency and precision tradeos in a hybrid multi-
stage analysis framework. We provide evidence to demon-
strate (for the rst time) a good correlation between the
number of strong updates performed on-demand and the
degree of precision achieved during the analysis.
5.1 Implementation
We have implemented Supa in LLVM (3.5.0). The source
les of a program are compiled under \-O0" (to facilitate de-
tection of undened values [63]) into bit-code by clang and
then merged using the LLVM Gold Plugin at link time
to produce a whole program bc le. The compiler option
mem2reg is always applied to promote memory into regis-
ters. Otherwise, SUPA will perform more strong updates
on memory locations that would otherwise be promoted to
registers, favoring SUPA undesirably.
All the analyses used are eld-sensitive. Each eld in-
stance of a struct is treated as a separate object. Analyzing a
eld operation, e.g., x1xGetElementPtr fin the LLVM IR
is similar as handling a [COPY] statement. The only dier-
ence is that ptpx1qmust include the eld objects at the oset
fof the pointed-to targets in ptpxq:ptpx1qto:f|oPptpxqu.
Arrays are considered monolithic. Positive weight cycles
that arise from processing elds of struct objects are col-
lapsed [36]. Distinct allocation sites (i.e., AddrOf state-
ments) are modeled by distinct abstract objects as in [15].
We build the SVFG for a program based on our open-
source software, SVF [49]. The def-use chains are pre-
computed by Andersen's algorithm ow-insensitively.
To compare Supa with whole-program analysis, we have
implemented a sparse ow-sensitive ( SFS) analysis de-
scribed in [15] also in LLVM, as SFS is a recent solution
yielding exactly the ow-sensitive precision with good scal-
ability. However, there are some dierences. In [15], SFS
was implemented in LLVM (2.5.0), by using imprecisely pre-
computed call graphs and representing points-to sets with
binary decision diagrams (BDDs). In this paper, just like
Supa ,SFS is implemented in LLVM (3.5.0), by building a
program's call graph on the y (Section 4.1) and represent-
ing points-to sets with sparse bit vectors.
We have not implemented a whole-program FSCS pointer
analysis in LLVM. There is no open-source implementation
either in LLVM. According to [2], existing FSCS algorithms
for C \do not scale even for an order of magnitude smaller
size programs than those analyzed"by Andersen's algorithm.
As shown here, SFS can already spend hours on analyzing
some programs under 500 KLOC.
5.2 Methodology
We choose uninitialized pointer detection as a major
client, named Uninit , which requires strong update analysis
to be eective. As a common type of bugs in C programs,
uninitialized pointers are dangerous, as dereferencing them
can cause system crashes and security vulnerabilities. For
Uninit , ow-sensitivity is crucial. Otherwise, strong updates
are impossible, making Uninit checks futile.
We will show that Supa can answer Uninit 's on-demand
queries eciently while achieving nearly the same precisionTable 1: Program characteristics
Program KLOC Statements Pointers Alloc Sites Queries
milc-v6 15 11713 29584 865 3
less-451 27.1 6766 22835 1135 100
hmmer-2.3 36 27924 74689 1472 2043
make-4.1 40.4 14926 36707 1563 1133
a2ps-4.14 64.6 49172 116129 3625 5065
bison-3.0.4 113.3 36815 90049 1976 4408
grep-2.21 118.4 10199 33931 1108 562
tar-1.28 132 30504 85727 3350 909
bash-4.3 155.9 59442 191413 6359 5103
sendmail-8.15 259.9 86653 256074 7549 2715
vim-7.4 413.1 147550 466493 8960 6753
emacs-24.4 431.9 189097 754746 12037 4438
Total 1807.6 670761 2158377 49999 33232
asSFS. For C, global and static variables are default ini-
tialized, but local variables are not. In order to mimic the
default uninitialization at a stack or heap allocation site
`:p&afor an uninitialized pointer a, we add a special
storepuimmediately after `, whereupoints to an un-
known abstract object (UAO),ua. Given a load xy, we
can issue a points-to query for xto detect its potential unini-
tialization. If xpoints to a ua(for somea), thenxmay be
uninitialized. By performing strong updates more often, a
ow-sensitive analysis can nd more UAO's that do not reach
any pointer and thus prove more pointers to be initialized.
Note that SFS can yield false positives since, for example,
path correlations are not modeled.
We do not introduce UAO's for the local variables involved
in recursion and array objects since they cannot be strongly
updated. We also ignore all the default-initialized stack or
heap objects (e.g., those created by calloc() ).
We generate meaningful points-to queries, one query for
the top-level variable xat each load xy. However, we
ignore this query if xis found not to point to any UAO by
pre-analysis. This happens only when xpoints to either
default-initialized objects or unmodeled local variables in
recursion cycles or arrays. The number of queries issued in
each program is listed in the last column in Table 1.
5.3 Experimental Setup
We use a machine with a 3.7G Hz Intel Xeon 8-core
CPU and 64 GB memory. As shown in Table 1, we have
selected 12 open-source programs (including nine recently
released applications) from a variety of areas: milc-v6
(quantum chromodynamics), less-451 (a terminal pager),
hmmer-2.3 (sequence similarity searching), make-4.1 ,
a2ps-4.14 (a postScript lter), bison-3.04 (a parser),
grep-2.2.1 ,tar-1.28 ,bash-4.3 ,sendmail-8.15.1 ,
vim74 , and emacs-24.4 .
For each program, Table 1 lists its number of lines of code,
statements, pointers, allocation sites (or AddrOf state-
ments), and queries issued (as discussed in Section 5.2).
5.4 Results and Analysis
We evaluate Supa with two congurations, Supa-FS and
Supa-FSCS .Supa-FS is a one-stage FS analysis by con-
sidering ow-sensitivity only. Supa-FSCS is a two-stage
analysis consisting of FSCS and FS applied in that order.
5.4.1 Evaluating Supa-FS
When assessing Supa-FS , we consider two criteria: e-
4671011021031041050:00010:0010:010:1110
0.00020.00040.00090.00210.00400.00840.02090.03560.07270.18670.43010.8495 2.47622.8794
BudgetTime per query (secs)
1011021031041050:010:11101001;000
0.060.060.100.220.300.400.741.685.4135.3368.24135.78280.26360.67
BudgetMemory usage (KB)(a) Analysis Time (b) Memory Usage
Figure 9: Average analysis time and memory usage per query consumed by Supa-FS under dierent budgets
ciency (its analysis time and memory usage per query) and
precision (its competitiveness against SFS). For each query,
its analysis budget, denoted B, represents the maximum
number of traversed def-use chains. We consider a wide
range of budgets with Bfalling intor10;200000s.
Supa-FS is highly eectively. With B10000, Supa-FS
is nearly as precise as SFS, by consuming about 0.19 seconds
and 36KB of memory per query, on average.
Table 2: Pre-processing times taken by pre-analysis
shared by Supa and SFS and analysis times of SFS
(in seconds)
ProgramPre-Analysis Times Analysis
Shared by Supa andSFS Time of
Andersen's Analysis SVFG Total SFS
milc 0.42 0.1 0.52 0.16
less 0.42 0.37 0.79 1.94
hmmer 1.57 0.46 2.03 1.07
make 1.74 1.17 2.91 13.94
a2ps 7.34 1.31 8.65 60.61
bison 8.18 3.66 11.84 44.16
grep 1.44 0.17 1.61 2.39
tar 2.73 1.71 4.44 12.27
bash 53.48 44.07 97.55 2590.69
sendmail 24.05 23.43 47.48 348.63
vim 445.88 85.69 531.57 13823
emacs 135.93 146.94 282.87 8047.55
EfÔ¨Åciency .Figure 9(a) shows the average analysis time per
query for all the programs under a given budget, with about
0.19 seconds when B10000 and about 2.88 seconds when
B200000. Both axes are logarithmic. The longest-running
queries can take an order of magnitude as long as the average
cases. However, most queries (around 70% { 80% across
the programs) take much less than the average cases. For
emacs ,SFS takes over two hours (8047.55 seconds) to nish.
In contrast, Supa-FS spends less than ten minutes (502.10
seconds) when B2000, with an average per-query time
(memory usage) of 0.18 seconds (0.12KB), and produces the
same answers for all the queries as SFS (Figure 10).
ForSupa , its pre-analysis is lightweight, as shown in Ta-
ble 2. with vim taking the longest at 531.57 seconds. The
same pre-analysis is shared by SFS to enable its sparse anal-
ysis. The additional time taken by SFS for analyzing each
program entirely is given in the last column.
Figure 9(b) shows the average memory usage per query
under dierent budgets. Following the common practice,
we measure the real-time memory usage by reading the vir-
tual memory information ( VmSize ) from the linux kernel le
(/proc/self/status ). The memory monitor starts after
the pre-analysis to measure the memory usage for answer-
milcless
hmmermakea2psbisongreptarbash
sendmailvimemacs0%20%40%60%80%100% B=200k
B=100k
B=40k
B=20k
B=10k
B=4k
B=2k
B=1k
B=400
B=200
B=100
B=40
B=20
B=10Figure 10: Percentage of queried variables proved to
be initialized by Supa-FS over SFS under dierent
budgets
ing queries only. The average amount of memory consumed
per query is small, with about 36KB when B10000 and
about 360KB when B200000. Even under the largest bud-
getB200000 evaluated, Supa-FS never uses more than
3MB for any single query processed.
Precision .Given a query ptpx`;py),pis initialized if no
UAO is pointed by pand potentially uninitialized otherwise.
We measure the precision of Supa-FS in terms of the per-
centage of queried variables proved to be initialized by com-
paring with SFS, which yields the best precision achievable
as a whole-program ow-sensitive analysis.
Figure 10 reports our results. As Bincreases, the pre-
cision of Supa-FS generally improves. With B10000,
Supa-FS can answer correctly 97% of all the queries from
the 12 programs. These results indicate that our analysis is
highly accurate, even under tight budgets. For the 12 pro-
grams except a2ps ,bison andbash ,Supa-FS produces
the same answers for all the queries when B100000 as
SFS. WhenB200000 for these three programs, Supa
becomes as precise as SFS, by taking an average of 0.02 sec-
onds (88.5KB) for a2ps , 0.25 seconds (194.7KB) for bison ,
and 3.18 seconds (1139.3KB) for bash , per query.
Understanding On-Demand Strong Updates .Let us
examine the benets achieved by Supa-FS in answering
client queries by applying on-demand strong updates. For
each program, Figure 11 shows a good correlation between
the number of strong updates performed (#SU on the left
y-axis) in a blue curve and the number of UAO's reaching
some uninitialized pointers (# UAO on the right y-axis)
in a red curve under varying budgets (on the logarithmic
x-axis). The number of such UAO's reported by SFS is
shown as the lower bound for Supa-FS in a dashed line.
468Number of strong updates Number of UAO bySupa Number of UAO by SFS
10110310505101520
Budget#SU milc
1011031050246#UAO
1011031050100200300
Budget#SU less
1011031050204060#UAO
101103105050100150200
Budget#SU hmmer
101103105050100150#UAO
101103105050100150200
Budget#SU make
101103105010203040#UAO
10110310505001;0001;500
Budget#SU a2ps
1011031050204060#UAO
10110310505001;0001;500
Budget#SU bison
101103105050100150#UAO
101103105050100150200
Budget#SU grep
1011031050102030#UAO
1011031050200400600
Budget#SU tar
101103105020406080100#UAO
1011031050100200300400
Budget#SU bash
1011031050102030#UAO
1011031050200400600800
Budget#SU sendmail
101103105050100150#UAO
10110310501;0002;0003;000
Budget#SU vim
1011031050100200300#UAO
10110310505001;0001;500
Budget#SU emacs
101103105020406080#UAOFigure 11: Correlating the number of strong updates with the number of UAO's under dierent budgets
In most programs, Supa-FS performs increasingly more
strong updates to block increasingly more UAO's to reach
the queried variables as the analysis budget Bincreases,
because Supa-FS falls back increasingly less frequently from
FS to the pre-computed points-to information. When B
increases, Supa-FS can lter out more spurious value-ows
in the SVFG to obtain more precise points-to information,
thereby enabling more strong updates to kill the UAO's.
WhenB200000, Supa-FS gives the same answers as
SFS in all the 12 programs except bison andvim, which
causes Supa-FS to report 16 and 35 more, respectively.
For some programs such as milc ,hmmer andgrep , most
of their strong updates happen under small budgets (e.g.,
B1000). In hmmer , for example, 192 strong updates are
performed when B10000. Of the 5126 queries issued,
Supa-FS runs out-of-budget for only three queries, which
are all fully resolved when B200000, but with no further
strong updates being observed.
For programs like bison ,bash andemacs , quite a few
strong updates take place when B¬°1000. There are
two main reasons. First, these programs have many in-
direct callsites (with 293 in bison , 126 in bash and 446
inemacs ), making their on-the-y call graph construction
costly (Section 4.1.2). Second, there are many value-ow
cycles (with over 50% def-use chains occurring in cycles in
bison ), making their constraint resolution costly (to reach a
xed point). Therefore, relatively large budgets are needed
to enable more strong updates to be performed.
Interestingly, in programs such as a2ps andvim, fewer
strong updates are observed when larger budgets are used.
Invim, the number of strong updates performed is 1492
whenB2000 but drops to 1204 when B4000. This
is due to the forward reuse described in Section 4.3. When
answering a query ptpx`;vyqunder two budgets B1andB2,
whereB1¬†B2,Supa-FS has reachedx`1;v1yand needs to
compute ptpx`1;v1yqin each case. Supa-FS may fall back to
the ow-insensitive points-to set of v1underB1but notB2,
resulting in more strong updates performed under B1in the
part of the program that is not explored under B2.
5.4.2 Evaluating Supa-FSCS
For C programs, ow-sensitivity is regarded as beingTable 3: Average analysis times and UAO's reported
by Supa-FSCS (with a budget of 10000 in each stage)
and Supa-FS (with a budget of 10000 in total)
ProgramSupa-FS Supa-FSCS
Time (ms) #UAO Time (ms) #UAO
milc 0.02 3 14.52 0
less 15.15 37 92.41 37
hmmer 11.41 86 135.05 71
make 124.40 26 229.44 26
a2ps 126.01 34 448.26 32
bison 465.54 94 529.20 86
grep 124.46 14 197.66 14
tar 26.31 70 83.10 68
bash 188.69 17 327.16 17
sendmail 200.32 94 250.19 85
vim 168.67 218 473.25 218
emacs 159.22 45 222.65 45
important for achieving useful high precision. However,
context-sensitivity can be important for some C programs.
Unfortunately, whole-program analysis does not scale well
to large programs when both are considered (Section 5.1).
In this section, we demonstrate that Supa can exploit
both ow- and context-sensitivity eectively on-demand in a
hybrid multi-stage analysis framework, providing improved
precision needed by some programs. Table 3 compares
Supa-FSCS (with a budget of 20000 divided evenly in its
FSCS and FS stages) with Supa-FS (with a budget of 10000
in its single FS stage). The maximal depth of a context
stack allowed is 3. By allocating the budgets this way, we
can investigate some additional precision benets achieved
by considering both ow- and context-sensitivity.
In general, Supa-FSCS has longer query response times
than Supa-FS due to the larger budgets used in our set-
ting and the times taken in handling context-sensitivity. In
milc ,hmmer ,a2ps ,bison ,tar andsendmail ,Supa-
FSCS reports fewer UAO's than Supa-FS , for two reasons.
First, Supa-FSCS can perform strong updates context-
sensitively, resulting in 0 UAO's reported by Supa-FSCS
formilc. Second, Supa-FSCS can perform strong updates
to context-sensitive singleton heap objects dened in Sec-
469tion 4.2, by eliminating eight UAO's inbison , 1 in tarand
1 insendmail , which have been reported by Supa-FS .
6. RELATED WORK
Demand-driven and whole-program approaches represent
two important solutions to long-standing pointer analysis
problems. While a whole-program pointer analysis aims to
resolve all the pointers in the program, a demand-driven
pointer analysis is designed to resolve only a (typically small)
subset of the set of these pointers in a client-specic man-
ner. This work is not concerned with developing an ultra-
fast whole-program pointer analysis. Rather, our objective
is to design a staged demand-driven strong update analy-
sis framework that facilitates eciency and precision trade-
os ow- and context-sensitively according to the needs of
a client (e.g., user-specied budgets). Below we limit our
discussion to the work that is most relevant to Supa .
6.1 Flow-Sensitive Pointer Analysis
Strong updates require pointers to be analyzed ow-
sensitively with respect to program execution order. Whole-
program ow-sensitive pointer analysis has been studied
extensively in the literature. Earlier, Choi et al. [6] and
Emami et al. [10] gave some formulations in an iterative
data-ow framework [18]. Wilson and Lam [55] considered
both ow- and context-sensitivity by representing procedure
summaries with partial transfer functions, but restricted
strong updates to top-level variables only. To eliminate un-
necessary propagation of points-to information during the
iterative data-ow analysis [14, 15, 20, 35, 60], some form
of sparsity has been exploited. The sparse value-ows, i.e.,
def-use chains in a program are captured by sparse evalua-
tion graphs [7, 39] as in [17] and various SSA representations
such as HSSA [8] and partial SSA [22]. The def-use chains
for top-level pointers, once put in SSA, can be explicitly
and precisely identied, giving rise to a so-called semi-sparse
ow-sensitive analysis [14]. Recently, the idea of staged anal-
ysis [12, 15] that uses pre-computed points-to information to
bootstrap a later more precise analysis has been leveraged
to make pointer analysis full-sparse for both top-level and
address-taken variables [15, 35, 48, 52, 59, 60]. This paper
is the rst to exploit sparsity to improve the performance of
a demand-driven strong update analysis.
There are several parallel implementations of Ander-
sen's ow-insensitive algorithm on multicore CPUs [31, 37],
GPUs [30], and heterogeneous CPU-GPU systems [46], with
no strong updates performed. However, a ow-sensitive par-
allel implementation of Andersen's algorithm that supports
strong updates on multi-core CPUs also exists [34].
6.2 Demand-Driven Pointer Analysis
All the existing demand-driven pointer analyses for C [16,
64, 61] and Java [29, 41, 57, 44, 47] are ow-insensitive, for-
mulated in terms of CFL (Context-Free-Language) reacha-
bility [40]. Heintze and Tardieu [16] introduced the rst on-
demand Andersen-style pointer analysis for C. Later, Zheng
and Rugina [64] performed alias analysis for C in terms of
CFL-reachability ow- and context-insensitively with indi-
rect function calls handled conservatively. Sridharan et al.
gave two CFL-reachability-based formulations for Java, ini-
tially without considering context-sensitivity [45] and later
with context-sensitivity [45, 44]. Shang et al. [41] and Yan et
al. [57] investigated how to summarize points-to informationdiscovered during the CFL-reachability analysis to improve
performance for Java programs. Lu et al. [29] introduced an
incremental pointer analysis with a CFL-reachability formu-
lation for Java. Su et al. [47] demonstrated that the CFL-
reachability formulation is highly amenable to parallelisation
on multi-core CPUs. Recently, Feng et al. [11] focused on
answering demand queries for Java programs in a context-
sensitive analysis framework (without strong updates). Un-
like these ow-insensitive analyses, which are not eective
for many clients like Uninit ,Supa can perform strong up-
dates on-demand ow and context-sensitively.
Boomerang [43], a very recent IFDS-based ow- and
context-sensitive pointer analysis for Java, also demon-
strates the importance of demand-driven pointer analysis
for security clients, such as FlowDroid [4].
6.3 Hybrid Pointer Analysis
The basic idea is to nd a right balance between e-
ciency and precision. For C programs, the one-level ap-
proach [9] achieves a precision between Steensgaard's and
Andersen's analyses by applying a unication process to
address-taken variables only. In the case of Java programs,
context-sensitivity can be made more eective by consider-
ing both call-site-sensitivity and object-sensitivity together
than either alone [19]. In [13], how to adjust the analysis
precision according to a client's needs is discussed. Zhang
et al. [62] focus on nding eective abstractions for whole-
program analyses written in Datalog via abstraction rene-
ment. Lhot ak and Chung [23] trades precision for eciency
by performing strong updates only on ow-sensitive single-
ton objects but falls back to the ow-insensitive points-to
information otherwise. In this paper, we propose to carry
out our on-demand strong update analysis in a hybrid multi-
stage analysis framework. Unlike [23], Supa is capable of
achieving the same precision as whole-program ow-sensitive
analysis, subject to a given budget.
7. CONCLUSION
We have introduced, Supa , an on-demand strong update
analysis that enables computing precise points-to informa-
tion for C programs ow- and context-sensitively by rening
away imprecisely pre-computed value-ows, subject to some
analysis budgets. Supa handles large C programs eectively
by allowing pointer analyses with dierent eciency and
precision tradeos to be applied in a hybrid multi-stage anal-
ysis framework. Supa is particularly suitable for environ-
ments with small time and memory budgets such as IDEs.
We have evaluated Supa by choosing uninitialized pointer
detection as a major client on 12 C programs. Supa can
achieve nearly the same precision as whole-program ow-
sensitive analysis under small budgets.
One interesting future work is to investigate how to allo-
cate budgets in Supa to its stages to improve the precision
achieved in answering some time-consuming queries for a
particular client. Another direction is to add more stages to
its analysis, by considering, for example, path correlations.
8. ACKNOWLEDGEMENTS
We thank all the reviewers for their constructive com-
ments on an earlier version of this paper. This research
has been supported by ARC grants, DP130101970 and
DP150101970.
4709. ARTIFACT DESCRIPTION
9.1 Artifact Package
You can nd this package, together with instructions,
on how to use Supa at http://www.cse.unsw.edu.au/~corg/
supa.
A brief checklist:.
index.html : the detailed instructions for reproduc-
ing the experimental results in the paper.
SUPA.ova : a virtual image le ( 5GB) contain-
ing installed Ubuntu OS and Supa project (http://
corg-pluto.cse.unsw.edu.au/supa/SUPA.ova).
Supa implementation developed on top of the SVF
framework: http://unsw-corg.github.io/SVF.
Scripts for reproducing all the data in the paper, in-
cluding:
{./run.sh ,
{./figure_9.sh .
{./figure_10.sh ,
{./figure_11.sh ,
{./table_2.sh ,
{./table_3.sh .
Micro-benchmarks to validate pointer analysis results.
Platform:.
All the results related to analysis times and memory usage
in our paper are obtained on a 3.7G Hz Intel Xeon 8-core
CPU with 64 GB memory. The OS in the virtual machine
image is Ubuntu 12.04. A user account has been created
with both its username and password as \pta".
To run SUPA, you are advised to allocate at least 16GB
memory to the virtual machine. The whole-program sparse
ow analysis, denoted SFS in the paper, requires more mem-
ory, as a lower memory budget may force OS to kill the
running process when it is used to analyze some large pro-
grams, e.g., vim,gdb andemacs . Finally, a VirtualBox
with version 4.1.12 or newer is required to run the image.
License:.
GPLv3 (www.gnu.org/licenses/gpl-3.0.en.html)
9.2 Quick Guidelines
To run the experiments as we did for in our paper, open
a terminal and do:
cd /home/pta/pta/ # Go to the SUPA project direc-
tory, denoted as $SUPAHOME
. ./setup.sh # Set up environment variables (please
note that there is a white space between the two dots)
cd SUPA-exp # Go to the experiment directory
To run the three analyses for all 12 benchmarks, execute
the following scripts:
./run.sh DFS # Run SUPA-FS./run.sh CXT # Run SUPA-FSCS
./run.sh SFS # Run whole-program SFS
On our platform, obtaining the results for SUPA may take
about 30 mins with a budget of 1000, and obtaining the
results for SFS may take more than ve hours (especially
for large programs, such as bash ,vim andemacs ).
Initially, the users are advised to analyze a few bench-
marks with small budgets using the default conguration
les `budget' and `benchmarks'. To analyze all the bench-
marks, please use another conguration le containing all
the benchmarks (and remember to re-run everything if the
conguration les have been changed):
After all the analyses are complete, you can collect the
data included in our tables and gures using the following
scripts in the same folder:
./Ô¨Ågure_9.sh # Data in Figure 9
./Ô¨Ågure_10.sh # Data in Figure 10
./Ô¨Ågure_11.sh # Data in Figure 11
./table_2.sh # Data in Table 2
./table_3.sh # Data in Table 3
For comparison purposes, we have also provided
the experimental data presented in the paper under
\$SUPAHOME/SUPA-exp/supa-fse/".
To reproduce the results shown in tables and gures with
the provided data, issue the following commands:
./Ô¨Ågure_9.sh supa-fse # Data in Figure 9
./Ô¨Ågure_10.sh supa-fse # Data in Figure 10
./Ô¨Ågure_11.sh supa-fse # Data in Figure 11
./table_2.sh supa-fse # Data in Table 2
./table_3.sh supa-fse # Data in Table 3
9.3 More Experiments and Developer Guide
Please refer to
The website of Supa (http://www.cse.unsw.edu.au/
~corg/supa)
The Wiki site of our SVF framework (http://
unsw-corg.github.io/SVF).
10. REFERENCES
[1] SUPA. http://www.cse.unsw.edu.au/~corg/supa.
[2] M. Acharya and B. Robinson. Practical change impact
analysis based on static program slicing for industrial
software systems. In ICSE '11 , pages 746{755, 2011.
[3] L. Andersen. Program analysis and specialization for
the C programming language . PhD thesis, DIKU,
University of Copenhagen, 1994.
[4] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel,
J. Klein, Y. Le Traon, D. Octeau, and P. McDaniel.
Flowdroid: Precise context, ow, eld, object-sensitive
and lifecycle-aware taint analysis for android apps. In
PLDI '14 , pages 259{269, 2014.
471[5] S. Blackshear, B.-Y. E. Chang, and M. Sridharan.
Thresher: Precise refutations for heap reachability. In
PLDI '13 , pages 275{286, 2013.
[6] J.-D. Choi, M. Burke, and P. Carini. Ecient
ow-sensitive interprocedural computation of
pointer-induced aliases and side eects. In POPL '93 ,
pages 232{245, 1993.
[7] J.-D. Choi, R. Cytron, and J. Ferrante. Automatic
construction of sparse data ow evaluation graphs. In
POPL '91 , pages 55{66, 1991.
[8] F. Chow, S. Chan, S. Liu, R. Lo, and M. Streich.
Eective representation of aliases and indirect memory
operations in SSA form. In CC '96 , pages 253{267,
1996.
[9] M. Das. Unication-based pointer analysis with
directional assignments. In PLDI '00 , pages 35{46,
2000.
[10] R. Emami, M. Ghiya and J. Hendren.
Context-sensitive interprocedural points-to analysis in
presence of function pointers. In PLDI '94 , pages
242{256, 1994.
[11] Y. Feng, X. Wang, I. Dillig, and C. Lin. EXPLORER:
query- and demand-driven exploration of
interprocedural control ow properties. In OOPSLA
'15, pages 520{534, 2015.
[12] S. J. Fink, E. Yahav, N. Dor, G. Ramalingam, and
E. Geay. Eective typestate verication in the
presence of aliasing. ACM TOSEM , 17(2):9, 2008.
[13] S. Z. Guyer and C. Lin. Client-driven pointer analysis.
InSAS '03 , pages 1073{1073, 2003.
[14] B. Hardekopf and C. Lin. Semi-sparse ow-sensitive
pointer analysis. In POPL '09 , pages 226{238, 2009.
[15] B. Hardekopf and C. Lin. Flow-Sensitive Pointer
Analysis for Millions of Lines of Code. In CGO '11 ,
pages 289{298, 2011.
[16] N. Heintze and O. Tardieu. Demand-driven pointer
analysis. In PLDI '01 , pages 24{34, 2001.
[17] M. Hind and A. Pioli. Assessing the eects of
ow-sensitivity on pointer alias analyses. In SAS '98 ,
pages 57{81. 1998.
[18] J. B. Kam and J. D. Ullman. Monotone data ow
analysis frameworks. Acta Informatica , 7(3):305{317,
1977.
[19] G. Kastrinis and Y. Smaragdakis. Hybrid
context-sensitivity for points-to analysis. In PLDI '13 ,
pages 423{434, 2013.
[20] U. P. Khedker, A. Mycroft, and P. S. Rawat.
Liveness-based pointer analysis. In SAS '12 , pages
265{282. 2012.
[21] W. Landi. Undecidability of static analysis. ACM
Letters on Programming Languages and Systems
(LOPLAS) , 1(4):323{337, 1992.
[22] C. Lattner and V. Adve. LLVM: A compilation
framework for lifelong program analysis &
transformation. In CGO '04 , pages 75{86, 2004.
[23] O. Lhot ak and K.-C. A. Chung. Points-to analysis
with ecient strong updates. In POPL '11 , pages
3{16, 2011.
[24] O. Lhot ak and L. Hendren. Scaling Java points-to
analysis using Spark. CC '03, pages 153 { 169.
[25] L. Li, C. Cifuentes, and N. Keynes. Boosting the
performance of ow-sensitive points-to analysis usingvalue ow. In FSE '11 , pages 343{353, 2011.
[26] Y. Li, T. Tan, Y. Sui, and J. Xue. Self-inferencing
reection resolution for Java. In ECOOP '14 , pages
27{53.
[27] Y. Li, T. Tan, and J. Xue. Eective soundness-guided
reection analysis. In SAS '15 , pages 162{180.
[28] Y. Li, T. Tan, Y. Zhang, and J. Xue. Program
Tailoring: Slicing by Sequential Criteria. In ECOOP
'16, pages 15:1{15:27, 2016.
[29] Y. Lu, L. Shang, X. Xie, and J. Xue. An incremental
points-to analysis with CFL-reachability. In CC'13 ,
2013.
[30] M. M endez-Lojo, M. Burtscher, and K. Pingali. A
GPU implementation of inclusion-based points-to
analysis. In PPoPP '12 , pages 107{116, 2012.
[31] M. M endez-Lojo, A. Mathew, and K. Pingali. Parallel
inclusion-based points-to analysis. In OOPSLA '10 ,
pages 428{443, 2010.
[32] A. Milanova, A. Rountev, and B. G. Ryder.
Parameterized object sensitivity for points-to and
side-eect analyses for java. ISSTA '02.
[33] A. Milanova, A. Rountev, and B. G. Ryder.
Parameterized object sensitivity for points-to analysis
for Java. ACM Trans. Softw. Eng. Methodol. ,
14(1):1{41, 2005.
[34] V. Nagaraj and R. Govindarajan. Parallel
ow-sensitive pointer analysis by graph-rewriting. In
PACT '13 , pages 19{28, 2013.
[35] H. Oh, K. Heo, W. Lee, W. Lee, and K. Yi. Design
and implementation of sparse global analyses for
C-like languages. In PLDI '12 , pages 229{238, 2012.
[36] D. Pearce, P. Kelly, and C. Hankin. Ecient
eld-sensitive pointer analysis of C. ACM TOPLAS ,
30(1):4{es, 2007.
[37] S. Putta and R. Nasre. Parallel replication-based
points-to analysis. In CC '12 , pages 61{80, 2012.
[38] G. Ramalingam. The undecidability of aliasing. ACM
TOPLAS , 16(5):1467{1471, 1994.
[39] G. Ramalingam. On sparse evaluation representations.
Theoretical Computer Science , 277(1):119{147, 2002.
[40] T. Reps, S. Horwitz, and M. Sagiv. Precise
interprocedural dataow analysis via graph
reachability. In POPL '95 , pages 49{61, 1995.
[41] L. Shang, X. Xie, and J. Xue. On-demand dynamic
summary-based points-to analysis. In CGO '12 , pages
264{274, 2012.
[42] Y. Smaragdakis, M. Bravenboer, and O. Lhot ak. Pick
your contexts well: understanding object-sensitivity.
InPOPL'11 , pages 17{30, 2011.
[43] J. Sp ath, L. N. Q. Do, K. Ali, and E. Bodden.
Boomerang: Demand-driven ow-and context-sensitive
pointer analysis for java. ECOOP, 2016.
[44] M. Sridharan and R. Bod k. Renement-based
context-sensitive points-to analysis for java. PLDI '06 ,
pages 387{400, 2006.
[45] M. Sridharan, D. Gopan, L. Shan, and R. Bod k.
Demand-driven points-to analysis for java. In
OOPSLA '05 , pages 59{76, 2005.
[46] Y. Su, D. Ye, and J. Xue. Accelerating inclusion-based
pointer analysis on heterogeneous CPU-GPU systems.
InHiPC '13 , pages 149{158, 2013.
472[47] Y. Su, D. Ye, and J. Xue. Parallel pointer analysis
with c-reachability. In ICPP '14 , pages 451{460, Sept
2014.
[48] Y. Sui, P. Di, and J. Xue. Sparse ow-sensitive pointer
analysis for multithreaded programs. In CGO '16 ,
pages 160{170. ACM, 2016.
[49] Y. Sui and J. Xue. SVF: Interprocedural static
value-ow analysis in LLVM. In CC '16 , pages
265{266, 2016.
[50] Y. Sui, D. Ye, and J. Xue. Static memory leak
detection using full-sparse value-ow analysis. In
ISSTA '12 , pages 254{264, 2012.
[51] Y. Sui, D. Ye, and J. Xue. Detecting memory leaks
statically with full-sparse value-ow analysis. TSE '14 ,
40(2):107{122, 2014.
[52] Y. Sui, S. Ye, J. Xue, and P. Yew. SPAS: Scalable
path-sensitive pointer analysis on full-sparse SSA. In
APLAS '11 , pages 155{171, 2011.
[53] Q. Sun, J. Zhao, and Y. Chen. Probabilistic points-to
analysis for java. In CC '11 , pages 62{81, 2011.
[54] T. Tan, Y. Li, and J. Xue. Making k-object-sensitive
pointer analysis more precise with still k-limiting. In
SAS '16 . 2016.
[55] R. Wilson and M. Lam. Ecient context-sensitive
pointer analysis for C programs. PLDI '95 , pages
1{12, 1995.
[56] X. Xiao and C. Zhang. Geometric encoding: forging
the high performance context sensitive points-toanalysis for Java. In ISSTA '11 , pages 188{198, 2011.
[57] D. Yan, G. Xu, and A. Rountev. Demand-driven
context-sensitive alias analysis for Java. In ISSTA '11 ,
pages 155{165, 2011.
[58] D. Ye, Y. Sui, and J. Xue. Accelerating dynamic
detection of uses of undened variables with static
value-ow analysis. In CGO '14 , 2014.
[59] S. Ye, Y. Sui, and J. Xue. Region-based selective
ow-sensitive pointer analysis. In SAS '14 , pages
319{336. 2014.
[60] H. Yu, J. Xue, W. Huo, X. Feng, and Z. Zhang. Level
by level: making ow-and context-sensitive pointer
analysis scalable for millions of lines of code. In CGO
'10, pages 218{229, 2010.
[61] Q. Zhang, X. Xiao, C. Zhang, H. Yuan, and Z. Su.
Ecient subcubic alias analysis for C. In PLDI '14 ,
pages 829{845, 2014.
[62] X. Zhang, R. Mangal, R. Grigore, M. Naik, and
H. Yang. On abstraction renement for program
analyses in Datalog. In PLDI '14 , pages 239{248,
2014.
[63] J. Zhao, S. Nagarakatte, M. M. Martin, and
S. Zdancewic. Formalizing the LLVM intermediate
representation for veried program transformations. In
POPL '12 , pages 427{440, 2012.
[64] X. Zheng and R. Rugina. Demand-driven alias
analysis for C. In POPL '08 , pages 197{208, 2008.
473