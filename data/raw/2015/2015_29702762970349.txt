Goal-ConÔ¨Çict Detection Based on Temporal SatisÔ¨Åability
Checking
Renzo DegiovanniNicolas RicciDalal AlrajehyPablo CastroNazareno Aguirre
Departamento de Computaci√≥n, Universidad Nacional de R√≠o Cuarto and CONICET, Argentina
yDepartment of Computing, Imperial College London, UK
{rdegiovanni, nricci, pcastro, naguirre}@dc.exa.unrc.edu.ar, dalal.alrajeh@ic.ac.uk
ABSTRACT
Goal-oriented requirements engineering approaches propose
capturing how a system should behave through the specica-
tion of high-level goals, from which requirements can then
be systematically derived. Goals may however admit subtle
situations that make them diverge, i.e., not be satisable
as a whole under specic circumstances feasible within the
domain, called boundary conditions . While previous work al-
lows one to identify boundary conditions for conicting goals
written in LTL, it does so through a pattern-based approach,
that supports a limited set of patterns, and only produces
pre-determined formulations of boundary conditions.
We present a novel automated approach to compute bound-
ary conditions for general classes of conicting goals expressed
in LTL, using a tableaux-based LTL satisability procedure.
A tableau for an LTL formula is a nite representation of all
its satisfying models, which we process to produce boundary
conditions that violate the formula, indicating divergence
situations. We show that our technique can automatically
produce boundary conditions that are more general than
those obtainable through existing previous pattern-based
approaches, and can also generate boundary conditions for
goals that are not captured by these patterns.
CCS Concepts
Software and its engineering !Requirements anal-
ysis; Risk management; Theory of computation !Au-
tomated reasoning; Modal and temporal logics;
Keywords
Goal Conicts, Satisability Checking, Tableaux Method
1. INTRODUCTION
The derivation of correct software requirements specica-
tions is essential to any reliable software development pro-
cess [1]. With the ever increasing complexity of software, the
importance of rigorous methods in supporting the attainmentof correct specications prior to their implementation, also
increases. Much research over the last decades has demon-
strated the signicant advantages that formal, goal-oriented
approaches bring to the generation of correct software re-
quirements specication. Goals are prescriptive statements
of how the system should behave. They reect stakeholders'
understanding of what the envisioned system is intended
to do, and the criteria upon which it would be evaluated.
They are commonly used to: aid the elicitation and elab-
oration of requirements [43, 47]; guide the renement and
organisation of requirements [4]; and support the derivation
of software operations [2, 8]. However, for such tasks to be
successfully achieved, the goals themselves must be correct,
which is not often the case. Goals are typically too ideal
to start with (wavering o the exceptional conditions that
may arise within its environment once implemented [43, 3]),
partial and imprecise. Ensuring their correctness within the
development cycle is of utmost importance.
One of the challenges in specifying correct goals is ensuring
their consistency. Inconsistency occurs when two or more
goals cannot be satised simultaneously, owing to their con-
tradictory nature, non-conformance to standards, or because
of restrictions imposed within certain domains, amongst
other reasons [20]. They are typically a result of overlapping
and conicting expressions. Detecting and resolving inconsis-
tencies in goals (a process called inconsistency management )
early on not only helps in avoiding costly software repairs
but also supports systematic requirements' elicitation and
verication activities [35, 44]. Several approaches have been
proposed in the literature for managing inconsistency in goals.
Much work has been done on the qualitative end, e.g., [33,
15], where the general focus has been on identifying contra-
dictory low-level requirements and computing the degree to
which goals are satisced or denied by them. On the formal
side, inconsistency management has also been the focus of
several studies, e.g., [44, 18, 11, 34, 10].
A weaker notion of conict (called divergence ) in goals
expressed in Linear Temporal Logic (LTL) [37] has been
addressed in [44]. This latter type of inconsistency is con-
cerned with those goals which are not contradictory (can
be simultaneously satised), but become inconsistent when
certain conditions hold. Consider for instance the following
goals from the mine pump controller example [25]: \the pump
shall be on when the water level is above the high threshold" ,
and\the pump shall be o when methane is detected in the
mine" . These goals are not logically inconsistent as they
are satisable in cases where the water level never reaches
a high level or methane is not detected in the mine. They
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission and/or a
fee. Request permissions from Permissions@acm.org.
ASE‚Äô16 , September 3‚Äì7, 2016, Singapore, Singapore
c2016 ACM. 978-1-4503-3845-5/16/09...$15.00
http://dx.doi.org/10.1145/2970276.2970349
507
become logically inconsistent only in the case when the water
level is high and methane is present at the same time. Situa-
tions like the latter can be captured formally as assertions
called boundary conditions , i.e., declarative formulas that
characterise those particular circumstances that lead to in-
consistency. Existing model synthesis approaches would not
detect this type of inconsistency since there exists at least
one model that satises such goals, in which the boundary
condition never holds. So far, very limited work has been
done on automatically nding boundary conditions for goal
expressions, save for [44] which supposes goals expressed
according to xed templates written in LTL.
In this paper, we present a novel approach to automatically
compute boundary conditions for conicting goals expressed
in LTL, using a satisability procedure based on tableaux.
A tableau for an LTL formula is essentially a nite graph
representation of all its satisfying models; it is built by rst de-
composing the formula whose satisability is being analysed,
according to decomposition rules that produce, for tempo-
ral operators, constraints on the current state and future
states, for their satisfaction. The resulting graph explores
the possible ways of making the initial formula satisable,
and in this process, contradictory portions are identied.
The second phase of the tableau method removes contra-
dictory portions, as well as parts of the graph that cannot
satisfy eventualities, leaving a subgraph, the tableau, that
captures allmodels of the formula (when it becomes empty,
the formula is unsatisable). Intuitively, the tableau indi-
rectly captures \conicting situations", since any condition
not included in the tableau necessarily prevents the formula
from being satisable. Our approach consists of computing
the tableau from a set Gof goals, and then exploring it to
identify conditions that would \escape" the tableau, thus
violating the goals, to produce boundary conditions. Our
approach is general, in the sense that it can automatically
detect conicts in goals expressed as any LTL formula (as
opposed to [44], where goals must comply with specic pat-
terns for conict detection). In particular, our approach can
be applied to all patterns in [44]. In fact, as we will show,
our technique produces more general boundary conditions
than those of the pattern-based approach, while at the same
time it allows us to compute boundary conditions from goals
not captured by these patterns.
The rest of the paper is organised as follow. Section
2 introduces preliminary concepts necessary in the paper.
Section 3 presents an illustrating example, used to motivate
the approach. Section 4 describes the approach in detail. In
Section 5 we validate our technique, by comparing it with
the pattern-based mechanism for conict detection, and by
applying our approach on various case studies. Finally, we
discuss related work in Section 6, and draw some conclusions
and further work in Section 7.
2. BACKGROUND
2.1 Goal-Oriented Modelling
Goal-Oriented Requirements Engineering [43] proposes cap-
turing how a system should behave through the specication
of a set of high-level goals , that will drive the requirements
engineering process. Goals are prescriptive statements that
the envisioned system is expected to achieve through the
cooperation of its agents (e.g., humans, devices and software)
within a given domain. Domain properties are descriptivestatements about the problem world (such as natural laws).
In this setting, a goal model is a decomposition of goals
through renements, which essentially capture how a goal
can be achieved in terms of simpler ones. These goal re-
nements end when each leaf subgoal can be assigned to a
single agent. Agents provide operations, whose combined
behaviours must fulll the goals. A requirement is a terminal
goal assigned to a software agent, while an assumption is a
goal assigned to an agent in the environment.
In this context, inconsistent goals may arise from con-
icting expressions. In particular, a weak form of conict,
called divergence , is of relevance in goal-oriented require-
ments engineering. A set of goals G1;:::;Gnis said to be
divergent [44, 43] with respect to a set Dom of domain prop-
erties i there exists a boundary condition BCsuch that the
following conditions hold:
fDom;BC;V
1inGigj=false (logical inconsistency )
fDom;BC;V
j6=iGjg6j=false;for each 1in(minimality )
BC6=:(G1^:::^Gn) ( non-triviality )
Intuitively, conditions 1and2indicate that the boundary
condition captures a particular combination of circumstances
that makes the goals conicting. Roughly speaking, the rst
condition establishes that goals G1;:::;Gncannot simultane-
ously be satised in Dom under any circumstances when BC
holds. The second condition states that removing any of the
goals no longer results in a logical inconsistency. The third
condition prohibits a boundary condition to be simply the
negation of goals. Notice also that the minimality condition
forbids trivial boundary conditions ( BCcannot be false nor
can it be the negation of one of the goals ( :Gi)), and requires
it to be consistent with the domain Dom.
2.2 Linear-Time Temporal Logic
Linear-Time Temporal Logic (LTL) is a formalism that
has been extensively employed to state properties of reactive
systems. LTL assumes a lineal topology of time, i.e., each
instant is followed by a unique future instant, and its formu-
las are evaluated over innite traces that represent system
executions. Given a set APof propositional variables, LTL
formulas are inductively dened using the standard logical
connectives and temporal operators andU, as follows: (i)
everyp2APis an LTL formula, and (ii)iff1andf2are
LTL formulas, then so are :f1,f1_f2,f1^f2,f1and
f1Uf2. We consider the usual denition for the operators
2(always), 3(eventually) and Win terms of,Uand
logical connectives. Temporal formulas are evaluated over
innite traces of propositional valuations. Formulas with no
temporal operators are evaluated in the rst valuation of a
trace. Given a trace ,fis true inifis true in[1::]
(the trace obtained by removing the rst valuation from ),
andf1Uf2is true ini there exists a position isuch that
f2holds in[i::], and for all 0j <i ,f1holds in[j::].
In this work we focus on safety properties, typically spec-
ied as 2f, and a particular kind of liveness properties,
namely those captured by the reachability and response pat-
terns, specied as 3fand2(f1!3f2), respectively. For
further details on LTL and temporal patterns, see [30].
2.3 The Tableau Method for LTL
The tableau method is a well-known logical satisability
approach, based on the decomposition of the formula being
508assessed according to the semantics of its logical operators,
to search for satisfying valuations. In propositional logic, for-
mulas are decomposed according to the semantics of boolean
connectives: a model satises f1^f2i it satises both con-
juncts at the same time; a model satises f1_f2i it satises
at least one of the disjuncts; and so on. Notice that if we start
with the singleton containing the assessed formula and con-
nect sets of formulas according to decomposition rules (e.g.,
ff1^f2gwill be connected to ff1;f2g), then this tableau
process leads to a nite tree, the tableau . Branches originate
due to disjunction; niteness is guaranteed because sets con-
taining contradictions are not further expanded, and atomic
formulas cannot be decomposed. In a propositional tableau
structure, leaves not containing contradictions characterise
sets of satisfying valuations: those obtained by assigning true
(resp., false) to atomic variables appearing positively (resp.,
negatively) in the branch, and assigning any truth value to
any other atomic proposition.
The tableau method for LTL extends propositional tableau
with rules to cope with temporal operators. Temporal opera-
tors will lead to requirements on the\current" state in a trace,
and on the rest of the trace. For instance, 2f(globallyf)
will hold in a trace i fholds in the current state of the trace,
and2fholds in the rest of the trace (or equivalently, if 2f
holds in the current state). On the other hand, 3fleads to
branching, as disjunction does: a trace satises 3fi the
current state satises for the rest of the trace satises 3f(or
equivalently,3fis satised in the current state). Notice
that these additional decomposition rules, if applied exhaus-
tively, may lead to innite branches. To avoid decomposing
the same formula twice, decomposed formulas are marked,
and if a decomposition leads to a previously constructed set,
then the arc will lead to the already produced one (thus, LTL
tableaux are graphs , as opposed to propositional tableaux,
which are trees). Then, LTL tableaux will deal with sets of
formulas and marked formulas (subformulas of that being
assessed), connected according to decomposition rules. More
precisely, LTL tableau works as follows. Initially, the tableau
contains only one node, the root, consisting of the (unmarked)
formula being queried for satisability. Then, each node will
be decomposed according to the following rules:
f1^f2
f1
f22f1
f1
2f1
f1_f2
f1jf23f1
f1j3f1f1Uf2
f2jf1^(f1Uf2)
Notice that we do not have rules for negation; we assume the
original formula to be in negation normal form (NNF), where
negations are pushed to be applied to atomic propositions.
Rules labelled with do not lead to branches, whereas those
labelled with produce branches.
Definition 2.1 (Elementary Formula). We call lit-
eral to a propositional variable or its negation. A formula
iselementary i it is a literal, or a temporal formula whose
main operator is .
Then, the above rules are applied iteratively, taking into
account marked vs unmarked formulas, and elementary for-
mulas, as follows:
1.Ifnis a node labelled with a set Sof formulas containing
at least one unmarked non-elementary formula f, then:(i)iffis a formula , and1;2are the formulas
resulting from decomposing f, then we create a node
n0labelled with the set (S ffg)[f1;2g[ffg,
and then we connect nwithn0;(ii)iffis a formula ,
and1;2are the formulas resulting from decomposing
f, then we create two nodes n1andn2, such that, n1
is labelled with the set (S ffg)[ffg[f1gandn2
is labelled with (S ffg)[ffg[f2g, and nally we
connectnwithn1andn2.
2.Ifnis a node labelled with a set Sthat contains only
elementary and marked formulas, then we create a node
n0labelled with the set S0, such that, 2S0i2
S, and then we connect nwithn0.
Definition 2.2 (States and Pre-States). The set of
nodesSNNthat contain only elementary or marked for-
mulas are called states , whereas the set PNNthat contains
the initial root node and immediate successors of states are
called pre-states .
After constructing the tableau, to decide if 'is satisable,
the unsatisable nodes must be eliminated from the graph.
To do so, the following deletion rules are repeatedly applied:
1.If a node contains both a proposition pand its negation
:p, it is eliminated.
2.If all successors of a node have been eliminated, it is
eliminated.
3.If a node is a pre-state that contains some eventuality
3f2orf1Uf2that is not satisable, then it is elim-
inated. A formula 3f2orf1Uf2is satisable in a
pre-state i there exists a path in the tableau leading
from that pre-state to a node that contains formula f2.
Intuitively, eventualities express \promises" that a property
will eventually be fullled, so one must guarantee that a
future state satises them, to consider these satisable.
The decision procedure ends when all unsatisable nodes
have been removed from the tableau. If the initial node has
been eliminated, the initial formula is unsatisable; if not, it
is satisable. The reader is referred to [46] for further details
and examples regarding the tableau construction for LTL.
As an example, consider the tableau in Figure 1, gener-
ated for the formula 2p^3:p. The rootnode contains
f2p;3:pg(we already decomposed the conjunction for
space reasons). All nodes whose identiers are in boldface
(n2,n3,n5,n8 andn9) are states . Noden8 cannot be fur-
ther expanded since it contains a propositional inconsistency
(pand:p). Notice also that all nodes reachable from n3
containp, and therefore they cannot full the eventuality :p
associated to formula 3:p. The parts of the tableau that
are eliminated according to the above rules are highlighted
in the gure. Since root belongs to the tableau after all
deletion rules have been applied, 2p^3:pis satisable;
the tableau also indicates the only way to make it satisable
is in a trace in which the eventuality :pis fullled in the
rst state, while in the rest of the trace pis satised.
3. MOTIV ATING EXAMPLE
To illustrate both the problem addressed and our proposed
solution, let us consider a simplied version of the Mine Pump
Controller (MPC) [25]. The MPC has a sensor that detects
when the water level is high, and a sensor to detect the
presence of methane in the environment. The propositional
509{‚á§ p,‚åÉ¬¨p}‚á¢‚á§ p‚á§,‚åÉ¬¨p‚á§, p, (‚á§ p),¬¨p ‚á¢p,‚á§ p‚á§, p, (‚á§ p) {p,‚á§ p,‚åÉ¬¨p}‚á¢p,‚á§ p‚á§,‚åÉ¬¨p, p, (‚á§ p) ‚á¢p,‚á§ p‚á§,‚åÉ¬¨p‚á§, p, (‚á§ p),¬¨p ‚á¢p,‚á§ p‚á§,‚åÉ¬¨p‚á§, p, (‚á§ p), (‚åÉ¬¨p) rootn1n2n4n5n8n6n7n9‚á¢‚á§ p‚á§,‚åÉ¬¨p, p, (‚á§ p) ‚á¢‚á§ p‚á§,‚åÉ¬¨p‚á§, p, (‚á§ p), (‚åÉ¬¨p) n3{p,‚á§ p}Figure 1: Tableau Example.
variables hw,mand poare employed to represent the facts
that a high water level is reached, that methane is present
in the environment, and that the pump is on, respectively.
In this context, the following goals are relevant:
Goal : Maintain[ PumpOWhenMethane ]
InformalDef : The pump should be o when methane is
detected in the mine.
FormalDef :2(m! (:po))
Goal : Maintain[ PumpOnWhenHighWater ]
InformalDef : The pump should be on when the water level
is above the high threshold.
FormalDef :2(hw! (po))
While these goals can be simultaneously satised (e.g., when
the water level is never high or methane is never present in
the environment), they become logically inconsistent when, at
the same time, the water level is high and methane is present.
Such conicting situations, in this case characterised by the
boundary condition 3(hw^m), are not obvious to identify,
and are very important to detect. We propose automatically
detecting such boundary conditions by constructing and
processing a tableau from the goals' temporal formalisations.
Let us provide some intuition on how the process works, in
the particular case of safety goals.
From the above safety goals (that we denote here as G1
andG2for space reasons), the tableau method previously
introduced produces the tableau shown in Figure 2. The
rootnode is the only pre-state, and nodes n0,n1,n2and
n3are states. Also, since n3contains both pand:p, it is
not further expanded (will be removed from the tableau).
The dashed lines in the gure indicate that target nodes are
reached through intermediate nodes (that are neither states
nor pre-states).
States in the tableau capture sets of valuations in particular
instants of a trace, through the literals they contain. For
instance, state n0characterises valuations (or points during a
trace execution) in which there is no methane and water level
is not high (:m^:hw). Moreover, if the \consistent" states
in a tableau are identied (basically, the states of the tableau
that remain after the removal phase), since these characterise
allconsistent situations, the negation of their disjunction
indirectly captures how the goals would be violated (would
\fall" into the unsatisable part of the tableau). In our
particular example, this formula is :((:m^:hw)_(:m^
{G1,G2}8<:G‚á§1,G‚á§2,¬¨m,¬¨hwm!¬¨po‚á§, (G1)hw!po‚á§, (G2)9=;8<:G‚á§1,G‚á§2,¬¨m, pom!¬¨po‚á§, (G1)hw!po‚á§, (G2)9=;8<:G‚á§1,G‚á§2,¬¨po,pom!¬¨po‚á§, (G1)hw!po‚á§, (G2)9=;8<:G‚á§1,G‚á§2,¬¨po,¬¨hwm!¬¨po‚á§, (G1)hw!po‚á§, (G2)9=;root
n0n1n2n3Figure 2: Tableau for the Mine Pump Controller.
po)_(:po^:hw)), and reaching it leads to a violation of
the goals. Thus, 3:((:m^:hw)_(:m^po)_(:po^:hw))
is a boundary condition (or equivalently 3((:hw^m^po)_
(hw^(m_:po))), as our tool produces it after simplication),
evidencing a weak conict between the goals. Actually, as
we will explain later on, this is in fact a potential boundary
condition, since it may not satisfy minimality (an additional
checking must be performed on our produced violations to
guarantee minimality).
It is worth noting that our computed boundary condition is
more general than that manually identied above ( 3(hw^m)).
By more general we mean that the formula 3(hw^m)implies
the boundary condition computed by our approach. As
we will show in our experimental assessment, this tableau-
based approach produces more general conicts than those
obtained using alternative pattern-based techniques. In the
next section, we describe in detail the approach, including
how other kinds of goals (besides safety) are handled.
4. THE APPROACH
Our tableau-based approach to automatically detect goal
conicts receives a goal-oriented requirements specication
composed of LTL formulas capturing the domain assumptions
Dom , as well as goals G=fG1;:::;Gng. The process may
determine that there are no conicts, or that there exist
either strong orweak conicts. The most relevant case, upon
which we concentrate in this work, is when weak conicts
are detected. If this is the case, our process produces a
setBC=fBC 1;:::;BCkgofboundary conditions capturing
dierent divergent situations between the goals in the domain.
Our approach is able to deal with safety goals and a particu-
lar kind of liveness goals, namely those that can be expressed
following the reachability orresponse (progress) patterns [30].
Reachability goals have the form 3f, while response goals
have the form 2(f1!3f2). Progress goals, on the other
hand, are expressed as 23f2, and are a particular case of
response goals (those where f1=true) [30].
The overall approach is summarised in the following steps.
(1)Tableau generation and renement: A tableau struc-
tureTforDom^Gis automatically generated using the LTL
decision procedure presented in Section 2.3. As mentioned
before, structure Tencodes allmodels of Dom^G. If after
the deletion rules are applied all the nodes are removed from
T, then goals and domain specications are contradictory,
510and we do not look at it any further; otherwise, we proceed
to look for weak conicts.
(2)Potential BCidentication: At this point, tableau
Tproduced in the previous phase is non-empty, and charac-
terises all the models for Dom^G, in the sense that every
sequence that satises Dom^Gis a path in the tableau
T, and every nite path obtained from Tis the prex of
some model of Dom^G[31]. However, there may exist
some innite paths inTthat leave some eventuality formula
unsatised, and thus, such paths do not satisfy Dom^G.
Taking these observations into account, from T, there are
two potential sources of divergences that must be analysed.
On one hand, all the unsatisable nodes removed by the
application of the tableau deletion rules characterise a par-
ticular kind of violation to Dom^G. A condition that would
force one to reach the inconsistent portion removed from T,
may represent a divergence for Dom andG. We call this the
safety case . On the other hand, given a liveness goalGi2G
whose eventuality is f(e.g., a reachability goal Gi=3f), an
(innite ) path in the tableau Tthat does not pass through a
state in which fholds, is a violation for Giand a potential
source of divergence between the goals. We call this the live-
ness case . Why these cases are potential divergences and not
actual divergences is further discussed later on, and analysed
in the next phase. This current phase will produce a set of
LTL formulas characterising potential divergences for both
the safety and liveness cases.
This phase is achieved by extracting from tableau Ta
set of path conditions that characterise the two kinds of
inconsistencies just described. A path condition is an LTL
formula characterising a path in the tableau (see Section 4.2).
To produce path conditions, Tis traversed starting from the
root node, collecting the information provided by the states
to build LTL formulas that capture the following situations.
For the safety case, the produced LTL formula captures a
path that escapes from T, directing us into the unsatisable
nodes (those removed from the tableau during node deletion).
For the liveness case, the produced LTL formula characterises
a path inTthat avoids the states in which the eventuality
of some liveness goal is fullled.
Path conditions are used to produce the potential bound-
ary conditions pBC =fpBC1;:::;pBCmg, whose concrete
formulation depends on whether they are safety or liveness
cases. As previously mentioned, formulas in pBC arepoten-
tialconicts, because although they characterise violations
forDom^G, they do not necessarily represent a divergence
case between the goals with respect to the domain. More
precisely, according to the divergence denition given in Sec-
tion 2.1, we have to check if the logical inconsistency and
minimality conditions are satised, to guarantee that these
are divergences.
(3)BCextraction: This nal phase consists of removing
from pBC those conditions that do not satisfy the divergence
properties in Section 2.1. The remaining boundary conditions
BC=fBC 1;:::;BCkgcapture weak conicts between the
goals in Gand the domain Dom .
Algorithm 1 describes how the above steps are combined.
We provide further details of each step below.
4.1 Generating and ReÔ¨Åning the Tableau
LTL-TableauMethod (line 2 in Algorithm 1) implements
the LTL decision procedure introduced in Section 2.3. It
generates a tableau structure T=hN;R;rooti, which encodesAlgorithm 1 takes as input an LTL specication of the
domain Dom and of a set of goals G. The output indicates
if the goals have noconict, or if they are strongly orweakly
conicting. When goals are weakly conicting, a set BCof
boundary conditions capturing divergences is produced.
1:function DetectDivergences (Dom ,G):BC
2:T=hN;R; rooti LTL-TableauMethod (Dom^G)
3: ifN=;then
4:.Dom^Gis unsatisable.
5: return UNSAT . Goals and domain specications are contra-
dictory.
6: else
7:.Dom^Gis satisable. Look for weak conicts .
8:.compute potential boundary conditions.
9: pBC SafetyBC (T) .safety case.
10: Glive LivenessGoals (G)
11: for all Gi2Glivedo .liveness case.
12: pBC pBC[fLivenessBC (T;Gi)g
13: end for
14:.Check divergence conditions.
15: BC FilterDivergences (Dom;G;pBC)
16: ifBC6=;then
17: return Weak conict detected: BC.
18: else
19: return No conict detected:;.
20: end if
21: end if
22:end function
allpotential models for Dom^G. Recall that the formula
to which the tableau construction is applied (in our case
Dom^G) is satisable i the root node is not removed
during the application of the deletion rules. Notice that in
Algorithm 1 we simply indicate that the goals and domain
constraints are contradictory, when the tableau is empty
(root node removed). When, on the other hand, Tmaintains
some nodes after the application of the deletion rules, then
Dom^Gissatisable . In this case, the approach proceeds to
generate potential boundary conditions, as described below.
4.2 Generating Potential Boundary Conditions
After generating the tableau T, the approach proceeds to
extract from Ta set of of LTL formulas that characterise
potential boundary conditions. More precisely, functions
SafetyBC andLivenessBC in Algorithm 1 generate these
LTL formulas for the safety and liveness cases, respectively.
In both cases, the LTL formulas are generated in two steps.
First, SafetyBC computes a set of frontier path conditions
that escape from Tdirecting us into the unsatisable nodes,
previously removed by the tableau method. Similarly, Live-
nessBC rst computes a set of path conditions in Tthat
avoid passing through the states in which the eventuality
of some liveness goal is fullled. Then, given these path
conditions, SafetyBC andLivenessBC generate the set
of potential boundary conditions from these computed path
conditions. In the remainder of this subsection, we introduce
some terminology necessary to present the process for ex-
tracting potential boundary conditions from a tableau, and
then we further describe the above mentioned functions.
State Constraints, Successors and Path Conditions.
LetT=hN;R; rootibe a tableau structure. The state
nodes ofT(see denition 2.2) contain literals that represent
the constraints that the states should satisfy to be part of a
model for the formula that was queried for satisability.
Definition 4.1 (State Constraints). Given a state
nodes2SN, the state constraints imposed by s, denoted by
CONS (s), are composed of the conjunction of literal formulas
511thatscontains. Given a set SSNof state nodes, CONS (S)
is dened asW
s2SCONS (s).
CONS (s) then returns a propositional formula that charac-
terises all states that satisfy the conditions imposed by state
s. For instance, if s=f2(p_:q);3r;p_:q;:q;rg, then
CONS (s) =:q^r, characterising the states in which the
proposition qis false and ris true.
Notice that, according to denition 2.2, some nodes in N
are neither states nor pre-states. For the sake of simplicity,
let us ignore all these intermediate nodes, preserving the
transition relation between states and pre-states in R.
Definition 4.2 (Successors). Given two pre-state no-
desd1;d22PN,succs (d1;d2) =fs2SNj(d1;s)2R^
(s;d 2)2Rg, i.e., the set of state nodes that transit from d1to
d2. We will use succs (d)to denote all state nodes that are suc-
cessors of pre-state d, i.e., succs (d) =fs2SNj(d;s)2Rg.
Definition 4.3 (Path). Apath= (d0;S0); (d1;S1);-
:::; (dk;Sk)inTis a sequence of pairs of a pre-state node
and a set of state nodes such that: 1.d0=root;2.8i: 0
i < k;Sisuccs (di;di+1);andSksuccs (dk);3.8i: 0
ik;Si6=;:
Aloop-free path is a path where di6=dj, for 0i<jk.
Definition 4.4 (Path Condition). Apath condition
['0;:::;'k]is asequence of propositional formulas such that
there exists a path = (d0;S0); (d1;S1);:::; (dk;Sk)for a
given tableau T, where'i=CONS (Si), for all 0ik.
Intuitively, a path and its corresponding path condition
characterise consistent ways of traversing the tableau T.
Our approach will consider loop-free paths to compute path
conditions for producing potential boundary conditions. The
frontier path condition dened below is used for describing
the paths that \cross" the frontier of the consistent part of
the tableau, and lead to an inconsistent portion of it.
Definition 4.5 (Frontier Path Condition). Afron-
tier path condition [ '0;:::;'k 1; ]is asequence of propo-
sitional formulas such that there exists in Ta path condition
= ['0;:::;'k], and =:'k.
4.2.1 Potential Safety Boundary Conditions
Function SafetyBC given in Algorithm 2 receives as in-
put the tableau structure T=hN;R;rootiand returns a
set of potential boundary conditions. First, it calls function
SafetyFPCs (line 3) to compute a set of frontier path con-
ditions, capturing paths that \escape" from Treaching the
unsatisable nodes removed during the tableau construction.
SafetyFPCs exploresTstarting from the rootnode (invoca-
tion in line 3), and traverses Tusing the successors denition
given above (set Siin lines 19{21), recovering path conditions
(line 22) required to nally reach the inconsistent portion
of the tableau (set Skand formula  in lines 14{15). The
algorithm keeps track of the already visited pre-states nodes,
so loops are not considered (lines 11{13). Intuitively, Safe-
tyFPCs computes all the shortest loop-free frontier path
conditions in T, that start in the rootnode and escape from T,
ending in the unsatisable portion removed previously from
T. Then, function SafetyBC encodes each frontier path
condition as an LTL formula f, by nesting each condition in
the path using the next temporal operator (line 5). Theresulting formula fis used to generate a potential boundary
condition 3(f)(line 6). Intuitively, this formula indicates
that there might be a conict in our model if condition f
is eventually reached, since it would lead to reaching the
inconsistent part of the tableau. Notice that by applying 3
tofwe are somehow \generalising" the inconsistency case f.
This is necessary because otherwise, and due to our analysis
being limited to loop-free paths, the obtained divergences
would be too strong (representing divergent cases of a xed
length). This generalisation step may however make the
candidate boundary condition consistent with the goals and
domain, so we will have to later on check for inconsistency
with respect to these constraints (see Section 4.4).
Algorithm 2 Receives as input a tableau T=hN;R;rooti
and returns a set pBC of LTL formulas, characterising po-
tential boundary conditions.
1:function SafetyBC (T):pBC
2: pBC ;
3:frontierPCs SafetyFPCs (T;;;[ ];root)
4: for all ['1;:::;'k; ]2frontierPCs do
5:f '1^('2^:::^('k^ ):::)
6: pBC pBC[f3(f)g
7: end for
8: return pBC
9:end function
10: function SafetyFPCs (T,V,,d):FPC
11: ifV=PNthen return;
12: else
13:V0 V[fdg
14:Sk succs (d)
15:  :CONS (Sk)
16: currFPC + +[ ]
17: FPC fg
18: for alld2PN V0do
19: ifsuccs (d;d)6=;then
20: Si succs (d;d)
21: ' CONS (Si)
22: 0 + +[']
23: FPC FPC[SafetyFPCs (T;V0;0;d)
24: end if
25: end for
26: return FPC[fcurrFPCg
27: end if
28: end function
4.2.2 Potential Liveness Boundary Conditions
Function LivenessBC in Algorithm 3 takes as input the
tableauTand a liveness goal Gi2Glive, and returns an
LTL formula that characterises dierent paths in Tthat
do not guarantee the eventuality corresponding to the goal
Gi. This LTL formula represents a potential divergence
between goal Giand the other goals and domain constraints.
LivenessBC starts by identifying the nodes in Tin which
the eventuality required by Giis fullled. That is, if Giis
a reachability goal 3for a response goal 2(g!3f), then
3fis the eventuality that Gishould full. Then, sentence
E Eventualities (T;Gi) in line 2 will store in Ethe set of
all nodes from Tthat contain formula f(i.e., each node in E
satises the eventuality demanded by goal Gi). For instance,
ifGi=3p, then all nodes from Tthat contain proposition
p, will be in the set E.
After that, LivenessFPCs computes all the loop-free path
conditions in a way similar to that for the safety case. How-
ever, for the liveness case, the path conditions computed
avoid those paths that pass through the nodes in E. Then,
the main dierence with the safety case is the composition of
512the setsSiandSkin Algorithm 3. In particular, set Sionly
considers state nodes that transition to the next pre-state
node, but that are not included in the set E(line 21). The
setSkonly contains the nodes that are in E(line 18), thus  
(i.e.,:CONS (Sk)^CONS (succs (d) E)) characterises the
nodes that do not satisfy the eventuality (line 19).
LivenessFPCs then returns the shortest loop-free path
conditions that avoid reaching nodes in which the eventuality
required by Giholds. In line 6, a formula fcharacterising
each path condition, is generated. The disjunction of all
these formulas captures all the dierent ways of traversing
the tableau without hitting a state in which the eventuality
of goalGiis satised (line 7). If the goal is a reachability
one, of the form Gi=3f, and the computed path condition
isFC, then2(FC)is the potential divergence (line 12). This
LTL formula indicates that there is a conict if the condition
FCalways holds, preventing the eventuality frequired by
Gifrom being fullled. If, on the other hand, the goal
is a response one, of the form Gi=2(f1!3f2), and
the computed path condition is FC, then 3(f1^2(FC))
is the potential divergence (line 10). This LTL formula
indicates that there is a conict if f1holds at some point,
but the eventuality f2is never fullled. Notice that f2
may be satised before the condition f1holds, but it will
not be satised an innite number of times. The case of
a progress goal 23f2is the same as for response, simply
takingf1=true. Notice again that, in both cases, by putting
FCin the scope of 2we are generalising the divergent case.
Intuitively, formula 2FCtries to characterise the innite
paths in the tableau that do not satisfy the Gi's eventuality.
Despite the fact that the generated LTL formulas capture
conicts with Dom^G, these may be discarded in the follow-
ing phase because they may not meet all the requirements
to be considered divergences, e.g., the minimality condition.
Algorithm 3 Takes a tableau T=hN;R;rootiand a liveness
goalGi, and returns a potential boundary condition pBC.
1:function LivenessBC (T,Gi):pBC
2:E Eventualities (T;Gi)
3:FC false
4:PCs LivenessFPCs (T;E;;;[ ];root)
5: for all ['1;:::;'k; ]2frontierPCs do
6:f '1^('2^:::^('k^ ):::)
7:FC FC_f
8: end for
9: ifGi=2( !3')then
10: return 3( ^2(FC)) . Giis a response goal.
11: else
12: return 2(FC) . Giis a reachability goal.
13: end if
14: end function
15: function LivenessFPCs (T,E,V,,d):PC
16:.same algorithm as SafetyFPCs , except the computation of
setsSiandSk.
17: . . .
18:Sk succs (d)\E
19:  :CONS (Sk)^CONS (succs (d) E)
20: . . .
21:Si succs (d;d) E
22:' CONS (Si)
23: . . .
24: end function
4.3 Filtering Boundary Conditions
Continuing with Algorithm 1, after computing the set pBC
of potential boundary conditions for the safety and liveness
cases, function FilterDivergences (Dom;G;pBC)is concernedwith checking which ones represent actual divergences. The
previous phase produces potential boundary conditions pBC,
that may fail to be actual boundary conditions because of var-
ious reasons: (i)they might be consistent with the goals and
domain constraints; (ii)they might not be minimal; or (iii)
they might be the negation of a goal. Situation (i)can arise
because, despite the fact that we compute path conditions
that indeed contradict the goals and domain specication,
since such path conditions are loop-free we \generalise" them
(weaken them) by applying a temporal operator; such gen-
eralisation may make some potential boundary conditions
consistent with the goals and domain constraints. Situa-
tions (ii)and (iii) are more clear: these impose conditions
on our potential boundary conditions that the process to
generate them does not take into account, and thus they
must be checked afterwards. We then have to go through an
additional process, represented by function FilterDivergences
that for each LTL formula bc2pBC, checks whether bc
meets the conditions described in Section 2.1, that dene
divergences (i.e., inconsistency with goals and domain speci-
cation, minimality with respect to the set Gof goals, and that
bcis not a trivial boundary condition). FilterDivergences
checks inconsistency with goals and domain specication by
assessing the satisability of bc^G^Dom using an LTL
satisability procedure; minimality, i.e., that for each goal
Gi2G,Dom^V
j6=iGj^bcis satisable, is also checked us-
ing LTL satisability; nally, checking that bc6=:Gis just
a syntactical check. FilterDivergences discards those LTL
formulas in pBC that do not meet the above conditions, and
returns a set BCpBC of boundary conditions for the goals
Gin the domain Dom.
FilterDivergences needs, for each potential boundary condi-
tion, to perform as many calls to the LTL decision procedure
as goals are in G(to check the minimality condition). To
eciently perform all these checks, we use Aalta [27], an
ecient LTL satisability checker, recently developed. The
experimental evaluation in Section 5 shows that the time
required by FilterDivergences is small, compared to the time
required to build the tableau.
4.4 Correctness and (In)completeness
Let us discuss now termination, correctness and (in)com-
pleteness of our approach. Regarding termination, recall that
in Section 2.3 we explained that the tableau generation pro-
cess is guaranteed to terminate, and the structure generated
is a nite graph. So, the tableau contains a nite number
of pre-state and state nodes. Since the functions to com-
pute the path conditions, SafetyFPCs andLivenessFPCs ,
consider only loop-free paths over a nite graph, these are
nitely many, and thus SafetyFPCs andLivenessFPCs
terminate. All the checks performed in the last phase of the
approach, FilterDivergences , are made using the LTL satis-
ability checker Aalta [27] (that is guaranteed to terminate),
for a nite number of potential boundary conditions. Thus,
the whole process is guaranteed to terminate.
Regarding the correctness of the approach, i.e., that if
the process produces a formula bcthis is indeed a boundary
condition, notice that the last phase of our approach, Fil-
terDivergences , checks that bcsatises all the conditions of
the denition of boundary condition (see Section 2.1), thus
guaranteeing correctness.
513Regarding completeness , i.e., that if there exists a diver-
gence situation between the goals and the domain our process
is able to produce it, the situation is dierent. Unfortunately
our approach is not complete. Let us provide an example.
Consider again goals 2pand3:p, used in Section 2.3
to illustrate a tableau. As we mentioned, these goals can
be satised only when the eventuality :pis fullled in the
rst state, and in the rest of the trace pholds. So, if pholds
in the initial state, the goals diverge. In fact, pis indeed a
boundary condition, it meets the three properties dening
it in Section 2.1. However, our approach cannot compute it,
since we only produce formulas that contain at least one tem-
poral operator. In fact, our approach will produce formulas
2p,3pand3(:p^:p) as potential boundary conditions,
none of which satisfy the boundary condition denition and
thus are removed by FilterDivergences .
5. EV ALUATION
In this section we evaluate our proposal, addressing the
following research questions:
RQ1 Is our approach well suited to detect divergences in goal
specications?
RQ2 Are the boundary conditions computed by our approach
more general than those derived by related techniques?
RQ3 Does our approach apply to specications that cannot
be handled by related techniques?
To answer RQ1, we take various case studies from the lit-
erature on formal requirements specications, that feature
both safety and liveness goals, and evaluate our technique
for computing divergences. Section 5.1 reports the results
of analysing two case studies: the Elevator Controller [9]
and the Rail Road Crossing System [5]. To answer RQ2, in
Section 5.2 we briey introduce the pattern-based approach
to goal conict detection from [44], and compare divergences
computed using our approach against those obtained using
the pattern-based one. To answer RQ3, in Section 5.3 we
study a simplied version of the TCP protocol, whose goals
do not correspond to any of the patterns of the previous
approach from [44], to assess how our approach deals with
them. Finally, in Section 5.4 we provide further examples,
and discuss about the scalability of our approach and the
succinctness of the computed boundary conditions.
These research questions are answered using a tool that we
developed, that implements our tableau based goal conict
detection approach. The tableau generation and potential
boundary conditions computation is implemented in Haskell,
and employs a BDD library [6] to simplify expressions when
path conditions are collected, while computing boundary con-
ditions. Moreover, the tool integrates the LTL satisability
checker Aalta [27], to eciently perform all the SAT checks
required by the FilterDivergences phase.
The tool, the specications for all case studies, and a de-
scription of how to reproduce the experiments can be found
in http://dc.exa.unrc.edu.ar/sta/rdegiovanni/ase2016. All
the experiments were run on an Intel Core i5 4460 processor,
3.2Ghz, with 8Gb of RAM, running GNU/Linux (Ubuntu
15.04). For each case study we report the size of the con-
structed tableau (number of nodes and transitions), the num-
ber of computed potential boundary conditions, the number
of resulting divergences, and the analysis time required for
constructing the tableau and for the entire process. This
information is summarised in Section 5.4.5.1 Case Studies
We evaluate two case studies taken from the literature,
the Elevator Controller introduced in [9], and a simplied
version of the Rail Road Crossing System taken from [5].
5.1.1 Elevator Controller
The Elevator Controller [9] has one sensor callto detect
when a user has called the elevator, and one sensor atoor
that is set to true when the elevator reaches the oor where
the user is waiting. In addition, the controller sends an open
signal indicating the door must open. For simplication, we
assume there is only one user that may call the lift at a time.
The following goal and domain properties are elicited:
Goal : Achieve[ OpenWhenCall ]
FormalDef :2(call!3(open))
Domain : Maintain[ DoorOpensWhenAtFloor ]
FormalDef :2((open)!atoor )
The goal OpenWhenCall indicates that the controller should
respond to the user's calling by opening the door. The do-
main property DoorOpensWhenAtFloor captures the door's
behaviour, indicating the door opens only when the elevator
reaches the oor where the user is waiting. Our approach
computes the following 2 potential boundary conditions:
1.3(call^:atfloor^:open^ (open ))
2.3(call^2(:open_(call^:atfloor^:open^ (:open ))))
Condition 1 is computed for the safety case, while condition 2
is for the liveness goal. Only condition 2 meets the denition
of divergence (condition 1 is inconsistent with the domain
because the door will open in the next state, but the elevator
is not at the oor where the user called it). This formula
captures the scenarios in which the elevator has been called
but the elevator will not be at the oor where it was called,
and it will never open the door. The whole process to
compute this boundary condition takes 0.80 seconds.
5.1.2 The Rail Road Crossing System
Consider now a simplied Rail Road Crossing System [5].
In this model, a train can approach and enter a crossing,
captured by taandtc, respectively. A car may also approach
and enter the crossing, captured by caandcc, respectively.
The crossing gate may be opened ( go) or closed (:go). The
following goals and domain properties are elicited:
Goal : Avoid[ Collision ]
FormalDef :2:(tc^cc)
Goal : Maintain[ ClosedGateWhenTrainApproaching ]
FormalDef :2(ta!: go)
Domain property :TrainsNotStop
FormalDef :2((tc)$ta)
Domain property :CarsCrossWhenGateIsOpened
FormalDef :2((cc)!ca^go)
Our tool computes 5 potential boundary conditions, with
only one being a divergence, in 0.5 seconds. The identied
divergence is the following:
1.3((:cc^go^ta)_(cc^(:go^tc_go^(ta_tc))))
This boundary condition reveals a few dangerous situations.
A conict arises if the gate is open when the train is ap-
proaching, and the car has not crossed yet. Other similar
conicting situation arise when the car is crossing at the
same time as the train is approaching or crossing.
5145.2 Comparison with Divergence Patterns
We now compare our technique with the only previous
formal approach to derive boundary conditions, presented in
[44]. This previous approach requires matching goals against
a set of pre-dened divergence patterns, for which divergence
expressions are provided. To answer RQ2, we compare these
divergences with those computed by our approach, when fed
with the pre-dened patterns from [44]. Figure 3 summarises
the three divergence patterns presented in [44], in which the
goals and domain are specied in LTL.
‚á§(P!‚åÉQ)
‚á§(R!‚á§¬¨S)‚á§(Q!S)‚åÉ(P^R)Achieve-Avoid‚á§(P!‚åÉQ)‚á§(Q!P)‚åÉ(P^(¬¨QU‚á§¬¨P))Retraction1‚á§(Q!R)‚á§(P!(QWS))‚åÉ((P^R^¬¨S)U(P^¬¨R^¬¨S))Retraction2
Figure 3: Divergence Patterns from [44].
In the case of the Achieve-Avoid pattern, the following
potential boundary conditions are produced, resulting all in
divergences:
1.3(:P^(:Q^R^S_Q^(R_:S))
_P^(:Q^R_Q^(R_:S)))
2.3(:P^:Q^R^:S^ (P_Q_S))
3.3(P^:Q^:R^ (:Q^R_Q^(R_:S)))
4.3(P^2((P^:Q^:R)_
(:P^:Q^(:R_:S))_
(P^:Q^:R^ (:Q^:R))_
(:P^:Q^R^:S^ (:P^:Q^:S))))
The entire process for computing and ltering the boundary
conditions takes 0.43 seconds. Boundary conditions 1{3 are
computed for the safety case, while the last condition is
for the liveness goal. When we compare the pattern-based
derived boundary condition 3(P^R) with those computed
with our technique, we observe that the former implies our
boundary condition 1 (but not vice versa). That is, bound-
ary condition 1 is more general than that derived by the
pattern. The mentioned implication has been veried using
a simple LTL satisability check ( f1impliesf2if1^:f2
is unsatisable). From the point of view of succinctness,
clearly our boundary conditions, computed from loop-free
path conditions in the tableau, are more complex and less
readable than that derived by the pattern.
When applying our technique to the Retraction1 pattern,
the approach computes the following potential boundary
conditions, where 1 and 2 correspond to the safety case, and
3 to the liveness case:
1.3(:P^Q) 2.3(P^:Q^ (:P^Q))
3.3(P^2((:P_:Q)_(P^:Q^ (:P_:Q))))
The rst two are discarded because they do not satisfy the
minimality condition, while formula 3 is identied as a di-
vergence. The whole boundary condition computation takes
just 0.28 seconds. Again, our computed boundary condition
is not as succinct as the pattern-based one. And also as inthe previous pattern, our computed boundary condition is
more general than the pattern-based derived one (the pattern
based boundary condition implies formula 3).
When applying our technique to the Retraction2 pattern,
the tool computes the following potential boundary condition,
which is a divergence:
1.3((:P^Q^:R)_(P^(:Q^:S_Q^:R)))
The whole divergence computation takes 0.48 seconds. Since
this pattern does not consider liveness goals, the boundary
conditions were computed for the safety case only. As with
the previous patterns, formula 1 is implied by that derived
by the Retraction2 pattern, and consequently, our approach
is again more general .
Notice that for the Achieve-Avoid pattern our approach is
able to produce boundary conditions that are not identied
by the pattern. Thus, these characterise additional divergent
cases, that can be very useful to engineers when analysing
conicting situations in goal specications.
5.3 An Example Not Captured by Patterns
Consider the TCP network protocol, which provides reli-
able in-order delivery of packets in packet based data trans-
mission. For simplication, let us assume that the protocol
can send one packet at a time, i.e., it waits for an acknowl-
edgement (ack) before sending the next packet. Briey, the
following liveness goals are elicited for this protocol:
Goals : Achieve[ DeliveredWhenSent ]
FormalDef :2(send!(:ackUdelivered ))
Goals : Achieve[ WaitACKBeforeSendAgain ]
FormalDef :2(delivered!(:sendUack))
Notice that this example cannot be matched to any of the
above patterns. Our technique is able to analyse this speci-
cation, and computes, in 1.31 seconds, the following diver-
gences:
1.3(send^2((:ack^(:delivered_send )_ack^:delivered )
_(:ack^:delivered^send^ (:ack^(:delivered_send )
_(ack^:delivered )))))
2.3(delivered^2(:ack_(:delivered^send )
_(:ack^:delivered^send^ (:ack_:delivered ))))
The rst boundary condition evidences a divergence if, from
a certain point onwards, after sending a packet, either the
ack signal is never received, or it is received before the packet
has been delivered. The second boundary condition indicates
that the goals are divergent when a packet was delivered,
but its corresponding ack is never received, or a new packet
is sent before receiving the ack.
5.4 Discussion
Let us briey discuss about the scalability of our approach
and the readability of our computed boundary conditions.
Table 1 summarises for each case study the size of the con-
structed tableau (number of nodes and transitions), the
number of computed potential boundary conditions (pBCs)
and the resulting divergences (BCs), the analysis time re-
quired for constructing the tableau and for the entire process
(in seconds). Moreover, to assess the readability of the BCs
computed, we evaluate the succinctness of the boundary con-
dition computed for each case study (we choose the biggest
one, when multiple pBCs are computed). We measure the
number of literals (Lit.), and the number of logical and tem-
poral operators involved in the formula (L.Op. and T.Op.,
515resp.). We also consider additional, more complex, speci-
cations, namely, the ATM [42], Telephone [13], and London
Ambulance Service (LAS) [14] (3, 5 and 5 formulas, resp.).
Table 1: Scalability and Succinctness Summary
Case Tableau pBCs BC Succinctness Tableau Total
Study nodes/trans /BCs Lit. L.Op. T.Op. Time Time
Elevator 24 / 48 2 / 1 6 8 3 0.64 0.80
RRCS 53 / 120 5 / 1 9 10 1 0.31 0.50
TCP 34 / 86 2 / 2 14 20 3 0.92 1.31
ATM 72 / 206 4 / 3 13 16 3 2.08 2.71
Telephone 163 / 508 4 / 1 13 19 2 8.84 11.43
LAS 93 / 184 1 / 1 42 58 1 11.58 11.68
Achieve-Avoid 34 / 86 4 / 4 17 28 4 0.27 0.43
Retraction1 12 / 24 3 / 1 7 11 3 0.02 0.20
Reatraction2 30 / 66 1 / 1 8 12 1 0.45 0.48
Table 1 shows that almost all the analysis time is spent
in constructing the tableau. We observe that this is more
evident in the specications that contain more liveness goals,
as the TCP, ATM and Telephone case studies. This is
due to the fact that removing the nodes that do not satisfy
eventualities requires multiple visits to the tableau. Although
we need to perform a more thorough scalability evaluation,
the eciency of our approach is promising, at least when
analysing specications that involve only safety goals, or a
restricted number of liveness goals.
Table 1 also shows that the computed boundary conditions
involve a considerable number of literals, logical and temporal
operators, hindering their readability. This is, evidently, one
of the most important issues we need to overcome to help
the engineer in understanding the divergences computed and
resolving the goal models.
6. RELATED WORK
Various informal and semi-formal approaches have been
proposed for detecting conicts in requirements models [19,
23, 24]. In addition, formal methods for detecting inconsis-
tency have also been proposed in [41, 21, 18, 11, 34, 10].
These approaches focus on logical inconsistencies only, or
ontology mismatch. Other techniques for reasoning about
inconsistencies based on abduction such as [36] consider gen-
erating explanations (in the form of conjunctions of ground
literals) for strong inconsistencies in requirements expressed
in quasi-classical logic. Our approach focuses on detecting
weak inconsistencies and automatically generating general
LTL expressions that characterise situations in which in-
consistencies may arise. Techniques such as [18], perform
consistency checks for requirements expressed as conditional
scenarios as a precursor for model synthesis. These con-
sistency checks would identify inconsistency between two
enabled charts. Our work on the other hand focuses on nd-
ing a characterisation for enabling conditions that could lead
to an inconsistency. Conicts in non-functional requirements
have also been considered in [28, 29, 22]. For instance, [29]
proposes a catalogue of conicts, categorising these (pairwise)
according to the frequency in which they occur together.
In [13], an approach for detecting conicts between feature
descriptions expressible in LTL is presented. It focuses on
strong conicts (i.e., mutually inconsistent features), applies
to features of the form p!qU(r_d), and uses a model
checker for the conict check. Our approach focuses on
identifying weak conicts, characterising them by boundary
conditions, and is applicable to a wider class of LTL formulas.The technique presented in [3] combines model checking
and machine learning to automatically generate a set of
obstacle conditions with respect to goals and domain prop-
erties expressed in LTL. It supposes however that each goal
is satisable within its domain, and focuses on identifying
the conditions under which the goal and domain may be
inconsistent. It does not handle situations that arise because
the goals themselves are inconsistent with one another.
The resolution of conicts has been the subject of recent
work, e.g., [12, 32]. The technique proposed in [32] makes use
of argumentation patterns to elicit, compose and relate stake-
holders beliefs. The technique assumes conicts have already
been elicited, and calculates an inconsistency score between
beliefs and goals (described informally). These scores are
then used as a guide for engineers as to which goals to re-
solve. Approaches like [40] propose methods that generate
consistency specications by construction, eliminating the
need for detection. The problem of detecting inconsistency
in specications is related to that of vacuity detection [26,
17]. The latter may be a result of the former though incon-
sistency detection cannot be reduced to a vacuity check. It
is also somewhat related to that of detecting overconstrained
specications. For instance, [39] proposes an algorithm for
extracting a core set of assertions that cause an inconsistency
in an Alloy model. The method assumes that inconsistency
is already known to exist. Our method however attempts to
nd the assertion (i.e., BC) that would lead to the inconsis-
tency. It also relates to that of realisability of specications,
e.g., [38, 7], in that conicting goals may lead to unrealisable
requirements.
7. CONCLUSION AND FUTURE WORK
Detecting inconsistencies early on in the requirements en-
gineering process helps avoiding costly software repairs, and
also supports systematic requirements' elicitation and veri-
cation activities. This paper presents a novel approach for
detecting divergences in goal specications, and generating
boundary conditions that characterise the cases under which
a strong inconsistency could potentially arise. To the best
of our knowledge, our approach is the rst fully automated
technique for computing goal conicts that applies both to
safety and to a wide range of liveness goals, specied in LTL.
Our tableau-based method is guaranteed to produce correct
results and to terminate. Our approach computes more gen-
eral formulas than previous, related techniques. However, as
our boundary conditions are automatically produced from
tableau paths that lead to inconsistencies, they are often
longer and less comprehensible in some cases than the more
compact ones derived from patterns.
The presented work opens various lines for future work. For
instance, a source of incompleteness of our approach is related
to the way we interpret divergent tableau paths, applying a
kind of generalisation through the application of temporal
operators. We are studying alternative, stronger ways of
dealing with these divergent paths, to be able to identify
more boundary conditions. We are also considering the use
of inductive learning techniques to support the inference of
more generalised expressions.
Our approach relies on a tableaux construction; we plan to
study more ecient tableau procedures, e.g., [16], to increase
our technique's eciency. We also plan to exploit tableaux
structures for other problems related to requirements speci-
cations, such as obstacle condition identication [45].
5168. REFERENCES
[1] IEEE recommended practice for software requirements
specications. IEEE Std 830-1998 , pages 1{40, 1998.
[2] Dalal Alrajeh, Je Kramer, Alessandra Russo, and
Sebasti an Uchitel. Learning operational requirements
from goal models. In Proceedings of the 31st
Intl. Conf. on Software Engineering , ICSE '09, pages
265{275, Washington, DC, USA, 2009. IEEE Computer
Society.
[3] Dalal Alrajeh, Je Kramer, Axel van Lamsweerde,
Alessandra Russo, and Sebasti an Uchitel. Generating
obstacle conditions for requirements completeness. In
ICSE , pages 705{715, 2012.
[4] Ana I. Anton. Goal Identication and Renement in
the Specication of Software-based Information Systems .
PhD thesis, Atlanta, GA, USA, 1997. UMI Order No.
GAX97-35409.
[5] Adrian Beer, Stephan Heidinger, Uwe K uhne, Florian
Leitner-Fischer, and Stefan Leue. Symbolic causality
checking using bounded model checking. In Proc. of the
22nd Intl. Sym. on Model Checking Software , pages
203{221, 2015.
[6]Randal E. Bryant. Graph-based algorithms for boolean
function manipulation. IEEE Trans. Computers ,
35(8):677{691, 1986.
[7]A. Cimatti, M. Roveri, V. Schuppan, and A. Tchaltsev.
Diagnostic information for realizability. In Proc. of the
9th Intl. Conf. on Verication, Model Checking, and
Abstract Interpretation , pages 52{67, 2008.
[8] Renzo Degiovanni, Dalal Alrajeh, Nazareno Aguirre,
and Sebasti an Uchitel. Automated goal
operationalisation based on interpolation and sat
solving. In ICSE , pages 129{139, 2014.
[9] Matthew B. Dwyer, George S. Avrunin, and James C.
Corbett. Patterns in property specications for
nite-state verication. In ICSE , pages 411{420, 1999.
[10] Christian Ellen, Sven Sieverding, and Hardi Hungar.
Detecting consistencies and inconsistencies of
pattern-based functional requirements. In Proc. of the
19th Intl. Conf. on Formal Methods for Industrial
Critical Systems , pages 155{169, 2014.
[11] Neil A. Ernst, Alexander Borgida, John Mylopoulos,
and Ivan J. Jureta. Agile requirements evolution via
paraconsistent reasoning. In Proc. of the 24th
Intl. Conf. on Advanced Information Systems
Engineering , pages 382{397, 2012.
[12] Alexander Felfernig, Gerhard Friedrich, Monika
Schubert, Monika Mandl, Markus Mairitsch, and Erich
Teppan. Plausible repairs for inconsistent requirements.
InIJCAI , pages 791{796, 2009.
[13] Amy P. Felty and Kedar S. Namjoshi. Feature
specication and automated conict detection. ACM
TOSEM , 12(1):3{27, 2003.
[14] A. Finkelstein and J. Dowell. A comedy of errors: The
london ambulance service case study. In Proceedings of
the 8th International Workshop on Software
Specication and Design , IWSSD '96, pages 2{,
Washington, DC, USA, 1996. IEEE Computer Society.
[15] Paolo Giorgini, John Mylopoulos, and Roberto
Sebastiani. Goal-oriented requirements analysis and
reasoning in the tropos methodology. EngineeringApplications of Articial Intelligence , 18(2):159 { 171,
2005.
[16] Valentin Goranko, Angelo Kyrilov, and Dmitry
Shkatov. Tableau tool for testing satisability in ltl:
Implementation and experimental analysis. Electronic
Notes in Theoretical Computer Science , 262:113{125,
2010.
[17]Arie Gurnkel and Marsha Chechik. Robust vacuity for
branching temporal logic. ACM Trans. on
Computational Logic , 13(1):1{32, 2012.
[18]David Harel, Hillel Kugler, and Amir Pnueli. Synthesis
revisited: Generating statechart models from
scenario-based requirements. In Formal Methods in
Software and Systems Modeling: Essays Dedicated to
Hartmut Ehrig on the Occasion of His 60th Birthday ,
pages 309{324, 2005.
[19]J.H. Hausmann, R. Heckel, and G. Taentzer. Detection
of conicting functional requirements in a use
case-driven approach. In ICSE , pages 105{115, 2002.
[20] Sebastian J.I. Herzig and Christiaan J.J. Paredis. A
conceptual basis for inconsistency management in
model-based systems engineering. Procedia CIRP , 21:52
{ 57, 2014.
[21] Anthony Hunter and Bashar Nuseibeh. Managing
inconsistent specications: Reasoning, analysis, and
action. ACM TOSEM , 7(4):335{367, 1998.
[22] I. J. Jureta, A. Borgida, N. A. Ernst, and
J. Mylopoulos. Techne: Towards a new generation of
requirements modeling languages with goals,
preferences, and inconsistency handling. In Proc. of the
18th IEEE International Requirements Engineering
Conference , pages 115{124, 2010.
[23] M. Kamalrudin. Automated software tool support for
checking the inconsistency of requirements. In ASE,
pages 693{697, 2009.
[24] Massila Kamalrudin, John Hosking, and John Grundy.
Improving requirements quality using essential use case
interaction patterns. In ICSE , pages 531{540, 2011.
[25] J. Kramer, J. Magee, and M. Sloman. CONIC: An
integrated approach to distributed computer control
systems. In IEE Proc., Part E 130 , pages 1{10, 1983.
[26] Orna Kupferman and Moshe Y. Vardi. Vacuity
detection in temporal model checking. In Proc. of the
10th IFIP WG10.5 Advanced Research Working
Conf. on Correct Hardware Design and Verication
Methods , pages 82{98, 1999.
[27]Jianwen Li, Yinbo Yao, Geguang Pu, Lijun Zhang, and
Jifeng He. Aalta: an LTL satisability checker over
innite/nite traces. In Proceedings of the 22nd ACM
SIGSOFT International Symposium on Foundations of
Software Engineering, (FSE-22), Hong Kong, China,
November 16 - 22, 2014 , pages 731{734, 2014.
[28] C. L. Liu. Ontology-based conict analysis method in
non-functional requirements. In Proc. of the 9th
IEEE/ACIS Intl. Conf. on Computer and Information
Science , pages 491{496, 2010.
[29] Dewi Mairiza and Didar Zowghi. Constructing a
catalogue of conicts among non-functional
requirements. In Proc. of the Intl. Conf. Evaluation of
Novel Approaches to Software Engineering , pages 31{44,
2011.
517[30]Zohar Manna and Amir Pnueli. The Temporal Logic of
Reactive and Concurrent Systems . Springer-Verlag New
York, Inc., New York, NY, USA, 1992.
[31] Zohar Manna and Pierre Wolper. Synthesis of
communicating processes from temporal logic
specications. ACM Trans. Program. Lang. Syst. ,
6(1):68{93, January 1984.
[32] P.K. Murukannaiah, A.K. Kalia, P.R. Telangy, and
M.P. Singh. Resolving goal conicts via
argumentation-based analysis of competing hypotheses.
InProc. 23rd IEEE Int. Requirements Engineering
Conf. , pages 156{165, 2015.
[33] J. Mylopoulos, L. Chung, and B. Nixon. Representing
and using nonfunctional requirements: A
process-oriented approach. IEEE Trans. Softw. Eng. ,
18(6):483{497, June 1992.
[34] Tuong Huan Nguyen, Bao Quoc Vo, Markus Lumpe,
and John Grundy. KBRE: a framework for
knowledge-based requirements engineering. Software
Quality Journal , 22(1):87{119, 2013.
[35] Bashar Nuseibeh, Steve Easterbrook, and Alessandra
Russo. Leveraging inconsistency in software
development. Computer , 33(4):24{29, 2000.
[36] Bashar Nuseibeh and Alessandra Russo. Using
abduction to evolve inconsistent requirements
specication. Australasian Journal of Information
Systems , 6(2), 1999.
[37]Amir Pnueli. The temporal logic of programs. In FOCS ,
pages 46{57, 1977.
[38] Suchismita Roy, Sayantan Das, Prasenjit Basu, Pallab
Dasgupta, and P. P. Chakrabarti. Sat based solutions
for consistency problems in formal property
specications for open systems. In CAD , pages 885{888,
2005.[39] Ilya Shlyakhter, Robert Seater, Daniel Jackson, Manu
Sridharan, and Mana Taghdiri. Debugging
overconstrained declarative models using unsatisable
cores. In ASE, pages 94{105, 2003.
[40] Monique Snoeck, Cindy Michiels, and Guido Dedene.
Consistency by construction: The case of merode. In
Proc. of the ER Workshop on Conceptual Modeling for
Novel Application Domains , pages 105{117, 2003.
[41] George Spanoudakis and Anthony Finkelstein.
Reconciling requirements: a method for managing
interference, inconsistency and conict. Annals of
Software Engineering , 3(1):433{457, 1997.
[42] Sebasti an Uchitel, Je Kramer, and Je Magee.
Synthesis of behavioral models from scenarios. IEEE
Trans. Software Eng. , 29(2):99{115, 2003.
[43] Axel van Lamsweerde. Requirements Engineering -
From System Goals to UML Models to Software
Specications. Wiley, 2009.
[44] Axel van Lamsweerde, Emmanual Letier, and Robert
Darimont. Managing conicts in goal-driven
requirements engineering. IEEE Trans. Softw. Eng. ,
24(11):908{926, November 1998.
[45] Axel van Lamsweerde and Emmanuel Letier. Handling
obstacles in goal-oriented requirements engineering.
IEEE Trans. Softw. Eng. , 26(10):978{1005, October
2000.
[46] Pierre Wolper. The tableau method for temporal logic:
An overview. Logique et Analyse , (110{111):119{136,
1985.
[47] Eric S. K. Yu. Towards modeling and reasoning
support for early-phase requirements engineering. In
Proceedings of the 3rd IEEE International Symposium
on Requirements Engineering , RE '97, pages 226{,
Washington, DC, USA, 1997. IEEE Computer Society.
518