ConflictJS: Finding and Understanding Conflicts Between
JavaScript Libraries
Jibesh Patra
TU Darmstadt
jibesh.patra@gmail.comPooja N. Dixit
TU Darmstadt
poojandixit@gmail.comMichael Pradel
TU Darmstadt
michael@binaervarianz.de
ABSTRACT
It is a common practice for client-side web applications to build on
variousthird-partyJavaScriptlibraries.Duetothelackofnames-
paces in JavaScript, these libraries all share the same global names-
pace. As a result, one library may inadvertently modify or even
deletetheAPIsofanotherlibrary,causingunexpectedbehaviorofli-
braryclients.Giventhequicklyincreasingnumberoflibraries,man-
ually keeping track of such conflicts is practically impossible both
for library developers and users. This paper presents ConflictJS ,a n
automatedandscalableapproachtoanalyzelibrariesforconflicts.
The key idea is to tackle the huge search space of possible conflicts
in two phases. At first, a dynamic analysis of individual libraries
identifiespairsofpotentiallyconflictinglibraries.Then,targeted
testsynthesisvalidatespotentialconflictsbycreatingaclientap-
plicationthatsuffersfromaconflict.Theoverallapproachisfree
of false positives, in the sense that it reports a problem only when
suchaclientexists.Weuse ConflictJS toanalyzeandstudyconflicts
among 951 real-world libraries. The results show that one out offour libraries is potentially conflicting and that 166 libraries are
involvedinatleastonecertainconflict.Thedetectedconflictscause
crashesandotherkindsofunexpectedbehavior.Ourworkhelps
library developers to prevent conflicts,library users to avoidcom-
bining conflicting libraries, and provides evidence that designing a
language without explicit namespaces has undesirable effects.
ACM Reference Format:
JibeshPatra,PoojaN.Dixit,andMichaelPradel.2018. ConflictJS :Finding
and Understanding Conflicts Between JavaScript Libraries. In ICSE ’18:
ICSE ’18: 40th International Conference on Software Engineering , May 27-
June 3, 2018, Gothenburg, Sweden. ACM, New York, NY, USA, 11 pages.
https://doi.org/10.1145/3180155.3180184
1 INTRODUCTION
ThepopularityofJavaScripthasleadtothedevelopmentofnumer-
ous JavaScript libraries. For example, a popular content delivery
networkthathostsJavaScriptlibrariesprovidesover3,000differ-
ent libraries.1. Libraries are ubiquitous and many applications use
multiple libraries. One estimate is that 75% of the top 10 million
1https://cdnjs.com/libraries
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
©2018 Copyright held by the owner/author(s). Publication rights licensed to the
Association for Computing Machinery.
ACM ISBN 978-1-4503-5638-1/18/05...$15.00
https://doi.org/10.1145/3180155.3180184// Strophe.js
window.Base64 = {
encode: function
(b) {
/* code */
}
decode: function
(b) {
/* code */
}
};// JSEncrypt.js
window.Base64 = {
unarmor: function
(t) {
/* code */
}
decode: function(
i) {
/* code */
}
};// Library client
jsEncrypt = new JSEncrypt();
jsEncrypt.setKey(...);
// Returns false instead of
// decrypted data when
// Strophe.js is loaded
// after JSEncrypt.js.
jsEncrypt.encrypt(...);
Figure 1: Example of two conflicting libraries and a client
that will experience unexpected behavior when loadingboth libraries.
websites use at least one of the top 18 libraries.2A recent study
onthetop75,000Alexawebsites[ 29]reportsthatthenumberof
externally hosted scripts that a website includes has a median of 9
and a maximum of 202.
Unfortunately, using multiple independently developed libraries
togethermaycause unexpectedbehavior.Thereasonis thatJava-
Script does not have namespaces but instead, all libraries sharea single global namespace. As a result, a value or a function “ex-
ported”byonelibrarymaybeeasilyoverwritten,modified,deleted,
or accidentally used by another library. Moreover, libraries may
overwrite built-in APIs, sometimes called “monkey patching”, and
multiple libraries may try to overwrite the same API in different
ways.Inpractice,theproblemiscompoundedbytheloosetypingin
JavaScript, which allows one library to overwrite another library’s
API even with a type-incompatible value.
As a real-world example of a library conflict found by our ap-
proach, consider Figure 1. The left side of the figure shows an
excerptof Strophe.js,alibrarythatimplementstheXMPPmiddle-
wareprotocol.Thecenterpartofthefigureshows JSEncrypt.js,a
librarythatprovidesOpenSSLRSAencryption.Bothlibrarieswrite
to the global variable Base64.3When included together, the library
thatisincludedlastwilloverwritethe Base64objectofthelibrary
that was included first. Such overwriting may cause unexpectedbehavior in a client of either of these libraries. For example, theright side of the figure shows a client that tries to encrypt somedata using JSEncrypt.js. When executing this client after loading
onlyJSEncrypt.js, the last call returns the encrypted data. However,
when executing the client after loading JSEncrypt.js and then Stro-
phe.js, the last call simply returns false. The fact that including an
apparently unrelated library breaks the core feature of the encryp-
tionlibrarywillsurpriseusersandisunintendedbythedevelopers
of both libraries.
Problems caused by conflicting libraries may occur whenever a
developer loads two libraries, which is common practice. Even if a
2https://w3techs.com/technologies/overview/javascript_library/all
3Thewindowvariable is the global object in client-side JavaScript.
7412018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Jibesh Patra, Pooja N. Dixit, and Michael Pradel
developerexplicitlyloadsonlyonelibrary,otherlibrariesmaybe
implicitly loaded. Due to the highly dynamic nature of JavaScript,
where some code may dynamically load other code, an application
developer may implicitly load libraries without even noticing it.
Forexample,websitesbuiltontopofcontentmanagementsystems
oftenuseplugins,eachofwhichimplicitlyloadssomelibraries.4
Other common ways of implicitly loading libraries are third-party
ads,socialmediaservices,andnewsfeeds.Whenaconflictbetween
librariesexists,JavaScriptoftenfollowsa“nocrash”philosophy,i.e.,misbehaviormaynotleadtoanexception.Asaresult,conflictseas-
ily remain unnoticed at library load time or even later, until a user
triggerstheunexpectedbehavior,asillustratedinthemotivating
example.
In principle, there is a sane way for libraries to share the global
namespace.Ideally,librarydevelopersallfollowa“singleAPIobject”
pattern,wheretheentireAPIofthelibraryisencapsulatedintoa
singleobject.Thelibrarythenwritesthisobjecttoasingleglobal
variable,e.g.,namedlikethelibraryitself,tominimizethepotential
for conflicts. In practice, not all libraries follow this pattern, andsome global variables, such as
$and_, are particularly popular.
Ourempiricalresultsshowthat71%ofalllibrariesdonotfollow
the “single API object” pattern.
Libraryconflictsarechallengingtodetectforaprogramanalysis
and difficult to avoid for library developers. One reason is that
unintendedeffectsofconflictstypicallymanifestonlyatruntime.Apurelystaticanalysiscaneithersoundlyoverapproximatepotentialconflictsandtheireffects,whichislikelytoproducealargenumber
offalse positives,in particular forJavaScript,or unsoundly under-
approximatethem,whichmaymissconflicts.Anotherchallengefor
detecting conflicts is the large number of JavaScript libraries. With
thousands of libraries available, and new libraries being added and
updated every day, analyzing all possible combinations of libraries
leads to a combinatorial explosion that is prohibitive in practice.
Currently,thereexistsnotechniqueforlibrarydeveloperstocheck
whether their library conflicts with another and for library clients
tocheckwhichcombinationsoflibrariestoavoid.Furthermore,itis
currently unknown to what extent the problem of library conflicts
matters in practice.
This paper presents ConflictJS , the first automated and scalable
techniquethatanalyzesJavaScriptlibrariesforconflicts.Weaddress
the huge search space of possible conflicts and the difficulties of
statically analyzing JavaScript through a two-phase approach that
combines dynamic analysis and test synthesis. In the first phase,
ConflictJS dynamicallyanalyzesindividuallibrariestodetectwrites
to the global namespace while loading a library. An offline com-parison of these global writes yields a set of potential conflicts
betweenlibraries.Inthesecondphase, ConflictJS synthesizesand
dynamicallyanalyzes libraryclients tocheck ifpotential conflicts
indeedleadto unexpected behavior.Thesecond phase,andthere-
fore also the overall approach, is precise in the sense that every
validated conflict certainly occurs in the synthesized client and
leads to different behavior depending on the loaded libraries.
We useConflictJS to analyze and study 951 libraries. The re-
sultsshowthat268(28%)librariesarepotentiallyconflictingand
4For a real-world example, see http://simple-press.com/documentation/codex/faq/
troubleshooting/what-is-this-jquery-conflict/.that 166 (17%) libraries are certainly conflicting with at least oneother library. The conflicts may lead to crashes, unexpected be-havior, and globally reachable state with unexpected values andtypes. A manual analysis of conflicting libraries reveals several
recurringpatternsofrootcausesforconflicts,whichareinstructive
forlibrarydevelopers, API designers,andlanguagedesigners. We
reported seven of the detected conflicts to the respective librarydevelopers, of which four already have been acknowledged and
confirmedasproblematic.Ofthefourconflicts,twohavebeenfixed
by the developers of the respective libraries.
ComparedtoexistingworkonanalyzingJavaScript[ 3],ourwork
is the first to address conflicts among libraries. Existing static anal-
yses focus on type checks of single libraries [ 11] or assume the
presence of library clients [ 30]. Existing dynamic analyses that
target type inconsistencies [ 38] and other coding problems [ 17]
assume to have inputs to exercise the program, whereas our work
synthesizes library clients automatically. JSNose [ 10] identifies ex-
cessive uses of global variables, but focuses on single libraries.
Finally,ourempiricalresultsrelatetoexistinglarge-scalestudies
ofJavaScriptlibrariesandtheirusage[ 29,34].Ourworkisthefirst
to study library conflicts.
Weenvision ConflictJS tobeusefulfordevelopersoflibrariesand
libraryclientsalike.Librarydevelopersmayuse ConflictJS tocheck
whether their library conflicts with others, allowing them to avoid
theconflictsbyadaptingthelibrary.Developersoflibraryclients
mayuseConflictJS tocheckwhichlibrariesconflict,allowingthem
to avoid including them together.
In summary, this paper contributes the following:
•Wearethefirsttoaddresstheproblemofconflictsamonglibraries
in a language without explicit namespaces.
•Wepresent ConflictJS ,anautomatedandscalabletechniqueto
precisely detect conflicts in JavaScript libraries through a combi-
nation of dynamic analysis and test synthesis.
•Weprovide empirical evidence thatthe approachscales to951
libraries, where it effectively detects and validates 1,840 conflicts
among them.
•We provide our implementation as open-source.5
2 MOTIVATION AND PROBLEM STATEMENT
This section provides some background, motivates the problem of
conflictsamong libraries withexamples fromreal-world libraries,
and formulates the problem addressed in this paper.
2.1 Background
The JavaScript version that is fully supported by most modern
browsers is ECMAScript 5 [ 7]. It does not provide any kind of
namespacesormodulesatthelanguagelevel.Instead,libraryde-
velopers rely on several ad-hoc mechanisms to encapsulate code
and to export APIs. First, some libraries follow a “single API ob-
ject” pattern, where the library initializes itself in a local scope and
provides its API as properties of a single global object. The most
obviouschoicefornamingthisglobalAPIobjectisthenameofthe
library, which typically is unique. For example, react.jsfollows this
patternbyexportingitsAPIsintotheglobal Reactobject.Thepopu-
larjQuerylibraryfurthermoreenablesdeveloperstoavoidconflicts
5https://github.com/sola-da/ConflictJS
742
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. ConflictJS: Finding and Understanding Conflicts Between JavaScript Libraries ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
by specifying the global variable where to provide the library or to
evenexportthelibraryintoanexisting,non-globalobject.6Second,
somelibrariesbuild upontheasynchronous modulespecification
(AMD), a module system targeted at client-side JavaScript and im-
plementedasalibrary,e.g.,RequireJS7.Third,somelibrariesuse
CommonJS, a module system targeted at non-client-side JavaScript
and implemented as the default module system on the Node.js plat-form.Unfortunately,theseoptionsareneithercompatiblewitheach
othernoravailableonallJavaScriptplatforms.ECMAScript6[ 8]
unifiesideasfromCommonJSandAMDintolanguage-levelmodule
support, and popular JavaScript platforms have started to adopt it.
However,sincewidely usedlibrariescannotrelyonrecently added
language features, they typically ensure backward compatibilityby relying on other ways to export their APIs. In summary, the
lackofnamespaceandmodulesincurrentlydeployedversionsof
JavaScript creates a non-trivial problem for library developers.
2.2 Motivating Examples and Classification of
Conflicts
Thefollowingsectionmotivatestheproblemofconflictsbetween
libraries with real-world examples (Table 1) found using our ap-
proach. Furthermore, we use these examples to define four classesof conflicts, based on how the conflicts manifest to a library client.
For each example, we show code from two conflicting libraries and
a client application that observes different behavior depending on
which of the libraries are included and on the order of inclusion.
InclusionConflicts. Thiskindofconflictraisesanexceptionwhen
including multiple libraries, without any further interaction be-
tween the client and the libraries. The example in the first column
illustrates the problem with the curlanddojolibraries. Loading the
second library after loading the first library causes an exception.
Foralibraryuser,finding suchconflictsisnon-trivialbecause the
exceptiondependsontheorderofincludingthelibraries:Onlyif
a client loads dojobefore loading curlthe exception occurs. The
documentation of neither of the libraries provides any reference
to the other library, presumably because the respective developers
are not aware of each other.
TypeConflicts. Typeconflictsoccurwhenmultiplelibrarieswrite
type-incompatiblevaluestothesamegloballyreachablelocation.
Table1presentsanexampleoftwolibraries, ocanvas.js andaframe.js,
thatwriteto window.logs anarrayandafunction,respectively.A
client using one of these libraries may rely onthe type of the con-
flictingvalueandwillbesurprisedifincludinganotherlibraryor
changingtheorderoflibraryinclusionbreaksthetypeassumption.
This and the following kinds of conflict are more subtle than inclu-
sionconflictsbecause theydonotleadtoanobviouserror when
simply including the libraries.
ValueConflicts. Similar totypeconflicts,thiskindofconflict is
caused by multiple libraries writing different values to the same
globally reachable location. We classify a conflict as value conflict
if the values are type-compatible but different. Table 1 providesan example where two libraries, pakoand3Dmol, write different
6https://api.jQuery.com/jQuery.noconflict
7http://requirejs.org/valuestothesamevariable pako.Therootcauseofthisconflictis
that3Dmolcontains an outdated version of pako.
Behavior Conflicts. A behavior conflict occurs when multiple
librariesstorefunctionsatthesamegloballyreachablelocation,but
these functions do not provide the same behavior. Table 1 presents
an example where two libraries, jsfaceandmatreshka, overwrite
thesamevariable Class.Asillustratedbytheclientcode,thetwo
functions provide different behaviors, which may surprise a client
thatisnotawareofthefactthatbothlibrariesprovidedissimilar
implementations of the same global function.
2.3 Problem Statement
Based on these four types of conflicts, we now formulate the prob-
lemaddressedinthispaper.Theinputtoourapproachisaset Lof
libraries. We assume that each l∈Lis supposed to be usable with-
out including any other library in L. In particular, this assumption
excludes libraries that extend another library, e.g., libraries that
extend the popular jQuerylibrary with additional features.
Libraries are used by clients that interact with the APIs of a
library. Client here means any sequence of statements that is ex-ecuted after loading one or more libraries. We denote a client
c
that executes after loading libraries l1,..,lkascl1,.. ,lk. We call the
sequence l1,..,lkoflibrariesloadedbeforeexecutingaclientthe
libraryconfiguration.The“client”rowofTable1showsexamples
of clients.
Wetargetconflictsduetolibrariesthatwritetothesameglobally
accessible memory location. In JavaScript, such memory locations
are properties of an object. Properties are accessed using either dot
notation,e.g., x.p,orbracketnotation,e.g., x["p"].Ineithercase,
thenameofapropertyisrepresentedbyanidentifierofstringtype.
For properties of nested objects, the property accessors consistof multiple identifiers, e.g.,
window.foo.bar . We call all property
accessors, using either single or multiple identifiers, access paths.I f
thefirstsegmentofanaccesspathisgloballyreachable,wecallita
globalaccesspath.Forexample, window.foo.bar and window.baz are
globalaccesspaths.Sincethe window-prefixisoptionalinJavaScript,
we omit it in the remainder of the paper, unless needed.
Based on these definitions, we can now define conflicts between
pairs of libraries:
Definition 1 (Conflict).Letl1,l2∈Lbe two libraries that both
write to the same global access path p. These libraries are conflicting
with eachother if thereexists a clientso thatany of thefollowing is
true:
(1)cl1behaves differently than cl2
(2)cl1behaves differently than cl1,l2
(3)cl1behaves differently than cl2,l1
(4)cl2behaves differently than cl1,l2
(5)cl2behaves differently than cl2,l1
(6)cl1,l2behaves differently than cl2,l1
The first case means that the same client behaves differently
dependingonwhichlibraryisloaded.Suchaconflictisrelevantfor
thedevelopersofthelibrariesbecausetheselibrarieswritedifferent
data or functions to the same globally accessible memory location.
Cases 2 to 5 mean that a client that includes a single library will
changeitsbehaviorsimplybecauseanotherlibraryisalsoincluded.
743
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Jibesh Patra, Pooja N. Dixit, and Michael Pradel
Table 1: Examples of conflicts between real-world libraries.
Problem Inclusion conflict Type conflict Value conflict Behavior conflict
Code
Example/* curl.js */
window.define
=function K() { ... };
/* dojo.js */
var def = function() { ... };
var req = function() { ... };
if(window.define) {
...
}else {
window.define = def;
window.require = req;
}
window.require(); // exception/* ocanvas.js */
(function(a, b, c) {
a.logs = [];
}(window, document));
/* aframe.js */
c=function(e) {
...
};
window.logs = c/* pako */
var pako = {
Deflate: function() { ... },
Inflate: function() { ... },
...
}
/* 3Dmol */
var pako = {
inflate: function() { ... },
inflateRaw: function() { ... },
...
}/* jsface */
function O(t, o) {
...
}
window.Class =O ;
/* matreshka */
window.Class
=function(a, b) { ... }
Client// client that includes first
// curl.js and then dojo.js
// exception because require
// is undefined// try to add to
// the 'logs' array
logs.push("log");
// exception because
// logs is a functionObject.keys(pako);
// returns 35 with pako
// but 4 with 3Dmolvar v1 = null;
var v2 = "";
v0 = window.Class(v1, v2);
// TypeError with matreshka
// but no errors with jsface
Description Bothlibrarieswritetotheglobalvariable deﬁne.
Toavoidoverwritinganalreadydefinedvariable,
e.g,whenthesamelibraryisincludedmultiple
times,dojochecks whether deﬁneis already
defined. Unfortunately, the code incorrectly as-
sumesthat requireisalwaysdefinedtogether
with deﬁne,causinganexceptionwhentrying
tocallthisfunction.Theproblemistriggeredby
any client that includes first curland then dojo.Both libraries write to
a global variable logs.
The type of logsis ar-
rayinocanvasbutfunc-
tion inaframe.Bothlibrariesoverwritetheglobal
variable pako.Thesizeoftheglobal
variable is different in both cases.
Thisoverwritinghappensbecause
3Dmol ships a variant of the pako
library that misses some features.Both libraries write to the
same global variable Class.
The implementation of both
differ as illustrated by the
client.
Such a conflict is relevant for developers of clients who may be
surprisedthatsimplyincludinganotherlibrarycausesnewbehavior.
Thelastcasemeansthataclient’sbehaviorchangeswhenswapping
the order in which two libraries are included. Again, this case is
relevant for client developers because such a change in behavior is
surprising.
BasedonDefinition1,wesaythatalibraryis conflicting ifthere
existsanotherlibrarysothatbothareconflictingwitheachother.
The problem addressed in this paper is how to find conflicting
libraries in a precise way, i.e., without false positives.
2.4 Challenges
DuetotheincreasingpopularityofJavaScript,thereexistthousands
oflibraries.Onlyfewofthemcomewithrepresentativeclientsthat
could serve as test cases. Our work aims at detecting conflicts inan automated and scalable way. Automated here means that theapproach requires no input except for a set of libraries. Scalable
here means that this set may contains thousands of libraries.
To find conflicts in an automated and scalable way, we must
address several challenges. First, the sheer number of JavaScript
libraries makes it practically impossible for an analysis to compare
allcombinationsorevenallpairsoflibraries.Forexample,given
1,000libraries,thereareabout500,000pairsoflibraries.Weaddress
this challenge by identifying potential conflicts during an analysis
of individual libraries (Section 3.1), which significantly reduces the
numberofcombinationstoanalyzefurther.Second,theapproach
cannotrelyonanya-prioriavailablelibraryclients.Weaddressthis
challengebysynthesizinglibraryclients,guidedbythepotential
conflicts(Section3.2).Third,tovalidatewhetherapotentialconflict
is indeed a conflict, we need to check whether the behavior ofclients differsdepending onthe libraryconfiguration. We address
thischallengebycomparingtheruntimebehaviorofsynthesized
clients executed with different library configurations (Section 3.2).
2.5 Scope and Limitations
Some challenges are out of the scope of this work. One of themisdetectingalllibraryconflicts.Whileourapproachisprecise,it
isnotsound,i.e.,itmaymisssomeconflicts.Formostinteresting
program analysis tasks, providing a sound and precise answer isimpossible, and we opt for precision in this work. Another out-of-scope question is how many real-world clients suffer from a
detected conflict. Instead of addressing this question, our approach
showstheexistenceofaclientbysynthesizingtheclient,sothat
librarydeveloperscouldanticipateconflictsthatanypossibleclient
mayrunintoandpreventconflictsbeforetheyoccur.Finally,we
focus on pairwise library conflicts and ignore conflicts that arise
only if three or more libraries interact with each other.
3 APPROACH
Thissectionpresents ConflictJS ,ascalableandautomatedapproach
tofindconflictsbetweenlibraries.Givenasetoflibraries,theap-
proach consists of two main steps:
(1)Detectionofpotentialconflicts.Atfirst, ConflictJS dynamically
analyzesindividuallibrariestoidentifywhichgloballyreach-
ablememorylocationstheywriteto.Basedontheglobalwrites
of each library, the first step then reports a potential conflict
for each pair of libraries that write to the same location.
(2)Validation of conflicts. This step validates whether two libraries
thatwritetothesamegloballyreachablelocationcanindeed
744
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. ConflictJS: Finding and Understanding Conflicts Between JavaScript Libraries ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
cause a client to behave differently depending on the library
configuration. To this end, ConflictJS synthesizes clients and
compares their behavior across different library configurations.
Ifandonlyiftheapproachfindsaclientwithdivergingbehavior,
it reports a conflict.
The remainder of this section explains these two steps in more
detail.
3.1 Detection of Potential Conflicts
To find potential conflicts between libraries, ConflictJS analyzes
the global access paths written to by a library. To this end, wedynamically analyze the loading of each library to keep track of
the writes made to the global namespace:
Definition 2 (Global Writesof a Library ).Theglobalwritesof
alibrarylisasetGl={p1,..,pk}ofglobalaccesspathstowhich l
writes while loading l.
For example, if the global object is called windowand a library
writestoitusing window.obj = {prop1:1, prop2:2} ,thenthesetof
global writes is {obj, obj.prop1, obj.prop2} .
To compute the global writes of a library, ConflictJS generates a
trivialclientthatsimplyloadsthelibraryanddynamicallyanalyzes
theexecution.Thedynamicanalysisupdatestheset Gwhenspecific
runtime events occur, as summarized in Table 2. The analysis isguaranteed to observe all global writes that occur while loadingthelibrary.Inparticular,theanalysishandleswritestoaliasesof
globally reachable objects, as illustrated by the example involving
window.Array in Table 2. The access paths of all reachable values,
i.e.,paths (v)mentioned in Table 2 are computed by recursively
traversing the properties of the object v. The information whether
avariableis globalis providedbyJalangi [ 46]ontop ofwhichwe
implement the analysis.
Afterextractingtheglobalwritesofeachlibrary, ConflictJS com-
pares the global writes of all libraries with each other to check for
writestothesameglobalaccesspath.Iftwolibrariesshareaglobal
write, we classify them as potentially conflicting:
Definition 3 (Potentially Conflicting Libraries ).Two libraries
l1,l2∈Larepotentiallyconflictingif Gl1∩Gl2,∅,i.e.,ifthetwo
libraries share at least one access path in their global writes.
Thefirstphaseof ConflictJS reducesthesearchspaceofpotential
conflictstobeconsideredbythesecondphaseoftheapproach.The
firstphasescaleswelltoalargenumberoflibrariesbecauseeach
library is analyzed in isolation. Comparing the global writes across
librariesrequirescomputingpairwiseintersectionsofsets,which
easily scales to a large number of sets. As mentioned in Section 2.5,
theanalysismightmisspotentialconflicts,e.g.,becausealibrary
mightperformaglobalwriteafterthelibraryhasbeenloaded.A
manualinspectionofasubsetoflibrariessuggeststhislimitation
to be negligible in practice, because libraries tend to initialize their
APIs at load time.
3.2 Precise Validation of Conflicts
The second step of ConflictJS is to validate potential conflicts iden-
tifiedinthefirststep.Atfirst,wemotivatetheneedforthissecondstepwithanexample.Then,weexplainthedetailsofthevalidation.Table 2: Actions performed by the global-writes analysis.
Runtime
eventAction Example
Variable
write
w=vIfwis a global variable:
•AddwtoG.Letpaths (v)be
the access paths of all values
reachable from v. For each
pv∈paths (v), addpvtoG.(function() {
var x = {a: 23};
window.foo = x;
})();
G→G∪{ foo,foo.a}
Property
write
x.p=vLetpaths (window )be the ac-
cess paths of all globally reach-
able values. For each pw∈
paths (window ):
•Ifpwpoints to x:
–Addconcat (pw,p)to
G. Letpaths (v)be the
access paths of all valuesreachable from
v. For
eachpv∈paths (v), add
concat (pw,pv)toG.(function() {
var x=window.Array;
x.p = {b: 42};
var y = {};
y . q=5 ;
})();
G→G ∪{Array.p,Array.p.b}
Declara-tion of
function fIftheglobalvariable fpointsto
the declared function (i.e., thefunction is globally declared),
addftoG.(function() {
function foo() {}
})();
function bar() {}
G→G∪{ bar}
/* JSLite.js */
Array.prototype.remove =
function(t) {
var n=this.indexOf(t);
return n>- 1& &this.splice(
n, 1),
this
}/* ext-core.js */
Array.prototype.remove =
function(e) {
var t=this.indexOf(e);
return -1 != t && this.splice
(t, 1),
this
}
Figure2:Exampletoshowtheneedforvalidatingpotentialconflicts.
3.2.1 Motivation for Validation. Potentially conflicting libraries
write to the same globally accessible memory location. This sit-
uation may or may not cause a client to suffer from a conflict as
definedinDefinition1.Forexample,considerFigure2,whichshows
code snippets from two potentially conflicting libraries, JSLite.js
andext-core.js. The global access path to which both libraries write
isArray.prototype.remove . Both libraries extend the built-in Ar-
rayobject by adding a new method remove, which can be called
with one argument. Even though the two methods are syntacti-
cally different, close inspection shows that both pieces of code are
functionally equivalent. This example illustrates that reporting all
potential conflicts would cause false positives because for some
potentialconflicts,allclientsareguaranteedtoobservethesame
behavior, irrespective of the library configuration.
3.2.2 Synthesizing Clients and Comparing their Behavior. To
checkwhetherapotentialconflictbetweentwolibrariesisindeeda
conflict,ConflictJS synthesizeslibraryclientsandcheckswhether
theirruntime behavior differs dependingonthe libraryconfigura-
tion. The basic idea is to consider each of the six scenarios listed in
Definition 1 by comparing the behavior of two clients with each
other.Thetwoclientscontainexactlythesamecode,exceptthat
745
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Jibesh Patra, Pooja N. Dixit, and Michael Pradel
Algorithm 1 Validate potential conflicts
Input:Libraries l1,l2 that both write to global access path p
Output: Validated conflict between l1 andl2
1:cempty←empty client
2:ifconflictinдConfiдs (cempty )then return “inclusion con-
flict”
3:ctypes←synthesize client that checks type of p
4:ifconflictingConfigs (ctypes )then return “type conflict”
5:iftype ofpis non-function then
6:cvalues←synthesize client that checks value of p
7:ifconflictingConfigs (cvalues )thenreturn “valueconflict”
8:else
9:Cbehavior←synthesize clients that call function p
10:for each cbehavior∈Cbehaviordo
11: ifconflictingConfigs (cbehavior )then return “behavior
conflict”
12:function conflictingConfigs (c)
13:B←∅ ⊿Set of observed runtime behaviors
14:for each config∈{l1,l2,l1l2,l2l1}do
15: bconfig←executecconfig
16:B←B∪{ bconfig}
17:if|B|>1then return true
18:else return false
theyrunwithdifferentlibraryconfigurations.If ConflictJS observes
a behavioraldifference between thetwo clients, thepotential con-
flict between the two libraries is indeed a conflict.
Forillustration,consider thebehaviorconflictillustrated inTa-
ble1.Ourapproachtriestovalidatethisconflictbysynthesizing
clients, such as the client shown in the table. The approach com-
paresthebehaviorofthisclientwithdifferentlibraryconfigurations.For the example,
ConflictJS finds that on calling Class, there is one
librarythatthrowsan exception whiletheotherdoesnot. Thatis,
theapproachhasvalidatedtheconflictandreportsit,alongwith
the synthesized client that illustrates the conflict.
Algorithm1summarizesourapproachforvalidatingpotential
conflicts by synthesizing and dynamically executing library clients.
Themainideaistocomparetheexecutionofaclient cwithdifferent
library configurations, i.e., cl1,cl2,cl1,l2, andcl2,l1, as summarized
in function conflictingConfigs . If there are multiple different behav-
iors, then the algorithm has validated a conflict. The following
describes how ConflictJS creates clients to detect the four kinds of
conflicts presented in Section 2.2.
3.2.3 CheckingforInclusionConflicts. Atfirst,ConflictJS checks
forinclusionconflicts(lines1to2).Aninclusionconflictistriggered
by simply including libraries, i.e., the client is an empty client that
doesnotcontainanystatements.Tocomparelibraryconfigurations,thebehavior
bconfigindicateswhetherincludinglibrariescausesthe
client to throw an exception. If one library configuration causes an
exception,whereasanotherconfigurationdoesnot,then ConflictJS
reports an inclusion conflict.
For the inclusion conflict example of Table 1, ConflictJS reports
aconflictbecause tryingtoexecutetheemptyclientafter loading
curl.jsanddojo.jscausesanexception,whereasexecutingtheemptyclient after loading only one of these libraries does not throw any
exception.
3.2.4 CheckingforTypeConflicts. Foranypairoflibraries l1,l2
and shared global access path pfor which the approach has not
validated an inclusion conflict, the next step is to check for type
conflicts. To this end, ConflictJS synthesizes a client that reads the
value at the access path pand then checks its type (lines 3 to 4).
The approach again executes this client with all possible library
configurations and summarizes the behavior of each configuration
as the type of the access path p. If one library configuration causes
the client to see type t1, whereas another library configuration
causes the client to see type t2,t1, thenConflictJS reports a type
conflict.
An example of a library pair with a type conflict is given in
the second column of Table 1. The approach reports this conflict
because pushisanarraywhenloadingonelibrarybutafunction
whenloadingtheotherlibrary.The“client”cellofthetableshowsa
clientthatsuffersfromthistypeconflictbecausetheconflictcauses
the client to crash when it tries to call a function that turns out to
be an array.
3.2.5 Checking for Value Conflicts. While checking for type
conflicts,theanalysisgathersinformationaboutthetypesofvaluesstoredataglobalaccesspath.Forpotentialconflictsthatareneither
validatedto beaninclusion conflict nortobea typeconflict, both
libraries write values of the same type to the access path. Based on
thistype, ConflictJS checksfortheremainingtwokindsofconflicts.
If the type is function, the approach compares the behavior ofclients that call this function, as described below. If the type is a
non-function, then the approach synthesizes a client that reads the
value at the access path p(lines 6 to 7). To compare the behavior
ofthisclientacrosslibraryconfigurations, ConflictJS comparesthe
valuereadat p.Theanalysisdirectlycomparesprimitivevaluesand
deeplycomparesobjects.Ifdifferentlibraryconfigurationscause
theclienttoreaddifferentvalues,then ConflictJS reportsavalue
conflict.
The“valueconflict”columnofTable1givesanexampleofatype
conflictonthe pakoaccesspath. ConflictJS synthesizesaclientthat
extractsthe numberofpropertiesof thevaluestored at pakoand
the then recursively extracts the values of these properties. The
approachreportsaconflictbecausethenumberof pako’sproperties
dependsonwhetherthe pakolibraryorthe 3Dmollibraryisloaded.
3.2.6 Checking for Behavior Conflicts. The most challenging
kindofconflictare behaviorconflicts.Theseconflictsoccur when
differentlibrarieswritefunctionstothesameglobalaccesspathbutthebehaviorsofthesefunctionsdiffer.Ingeneral,decidingwhether
the behavior of two functions differs is undecidable. ConflictJS
approachesthisproblembytryingtosynthesizeclientsthatexposeadifferenceinbehavior.Iftheanalysissucceedsingeneratingsuch
a client within a fixed time budget, it reports a behavior conflict.
To synthesize clients we use a simple test generator inspired by
Randoop’sfeedback-directed,randomtestgeneration[ 36].Other
test generation techniques, such as symbolic or concolic execu-
tion[5,15,28]orsearch-basedtestgeneration[ 12],couldalsobe
used for this step. Given a function-typed access path pdefined by
two libraries, the test generator starts by estimating the number
746
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. ConflictJS: Finding and Understanding Conflicts Between JavaScript Libraries ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
nofargumentsthatthefunctionexpects.Tothisend,weusethe
lengthproperty of the function object at p, which in JavaScript
yields the number of declared function parameters. This number is
an estimate because a function body may also access additional ar-
gumentsusingthebuilt-in arguments value.Next,togenerateacall
to thefunction, the testgenerator randomlydecides on arandom
number ranging between 0 and nof arguments to pass. For each
argument, the test generator decides on the type of argument to
createbyrandomly choosingbetweenthefollowing types: boolean,
string,number,array,object,undefined andnull.Tocreateaboolean,
string,ornumber,thegeneratorpicksfromapre-definedpoolof
values.Forarrays,thegeneratorrandomlypicksalengthranging
between 0 and 10 and fills it with random strings and numbers.
Finally,tocreateanobject,thegeneratorcreatesupto10properties
and assigns randomly generated values to them.
Once the arguments are generated, the function iscalled using
the generated arguments. If and only if thecall succeeds, without
raising an exception, for at least one library configuration, the
generator synthesizes a client that contains this call.
To compare the behavior of synthesized clients across library
configurations, ConflictJS summarizes the behavior of the client
executionbasedonthereturnvalueofthefunctionandbasedon
whetherthefunctionraisesanexception.Theapproachreportsa
behaviorconflictintwocases:(i)ifonelibraryconfigurationcauses
the client to crash whereas another library configuration does not
cause a crash, or (ii) if both configurations do not crash but the
return value of the function at pdiffers.
For example, consider the last column of Table 1. ConflictJS
synthesizesclientsthatcallthefunctionstoredattheconflicting
accesspath Class.Theclientshowninthetablethrowsanexception
for one of the two libraries but not for the other, which is why
ConflictJS reports a behavior conflict.
4 IMPLEMENTATION
Weimplement ConflictJS asaclient-server-basedtoolthatanalyzes
JavaScript libraries. The client component synthesizes, executes,
and analyzes clients in a browser, and sends a summary of the
runtimebehaviortotheserver.Theserverdetectspotentialconflicts
and validates them based on execution behavior gathered in the
firstand secondphase,respectively. Ourdynamicanalyses tofind
global writes is build on top of Jalangi [ 46]. When synthesizing
clients to detect behavior conflicts, we set the testing budget to 50
testsperaccesspath.Inthispaper,weimplementtheapproachonly
forclient sideJavaScript libraries anditwould bestraightforward
toadaptforserver-sidenpmlibrariesbuttheproblemislesssevere
for Node.js because there is a commonly accepted module system.
5 RESULTS AND DISCUSSION
We apply ConflictJS to 951 popular JavaScript libraries to evaluate
the effectiveness of the approach in detecting library conflicts. We
focus on the following research questions:
•How effective is ConflictJS in finding library conflicts and what
kinds of conflicts occur in practice? (Section 5.2)
•What are the root causes of conflicts between libraries? (Sec-
tion 5.3.1)Table 3: JavaScript libraries used for the evaluation.
Min Median Max Total
Libraries - - - 951
Lines of code 9 574 275,0852 2,750,852
Size (bytes) 148 14,645 2,517,510 68,412,720
•Do library developers make an effort to avoid conflicting scenar-
ios by following the "single API object" pattern? (Section 5.3.2)
•Whatarethepopularaccesspathsthatdeveloperstendtochoose?
(Section 5.3.3)
•Isthereacorrelationbetweenconflictsandthepopularityofa
library? (Section 5.3.4)
•Howaretheglobalwritesandconflictsdistributedacrosslibraries
and access paths, respectively? (Sections 5.3.5 and 5.3.6)
5.1 Experimental Setup
Our evaluation uses 951 real-world JavaScript libraries with a total
of 2,750,852 lines of JavaScript code (Table 3). The libraries include
the popular jQuery,Underscore, and Dojoprojects, as well as var-
ious other highly popular libraries. We obtain these libraries by
downloading them from the CDNJS content delivery network.8At
the time of starting our experiments, the content delivery network
offered a total of 2,095 libraries. We remove libraries that cannot
be used in isolation in a standard desktop browser, e.g., because
they rely on another library or because they target mobile devices.
We heuristically check for such libraries by loading each library in
isolation and filtering away all libraries that throw an exception.
After filtering, 951 libraries remain, which is our benchmark set
for the evaluation. To run our experiments, we use an Intel Core
i7–4790 CPUmachine clocked at3.60GHz with 32GB of memory,
running Chrome 55, Node.js 6.9.1 on Ubuntu 16.04.
5.2 Effectiveness in Finding Library Conflicts
5.2.1 PotentialConflicts. When analyzing theglobalwritesof
individuallibraries, ConflictJS recordswritestoatotalof130,714
differentaccesspathsacrossthe951libraries.Intersectingtheglobal
writes of libraries reveals that 4,121 of the access paths cause a
potentialconflict,i.e.,atleasttwolibrarieswritetoeachofthese
access paths.These conflicting writesare performed by 268 of the
951libraries,i.e.,roughly one outoffourlibrariesisinvolvedina
potential conflict.
5.2.2 Validated Conflicts. Out of the 268 potentially conflicting
libraries,ConflictJS validates166ascertainlyconflictingbysynthe-
sizingaclientwhosebehaviordependsonthelibraryconfiguration.
The validated conflicts are due to 1,840 distinct access paths. In
otherwords, ConflictJS successfullyvalidates62%ofthepotentially
conflictinglibraries(i.e.,of268libraries)ascertainlyconflictingandfinds a validated conflict in 17% of all libraries (i.e., of 951 libraries).
5.2.3 Kinds of Validated Conflicts. Figure 3 summarizes how
prevalentthefourkindsofconflictsareamongallvalidatedconflicts.
Thetwosidesofthefigureprovidedifferentviewsonthesamedata.
Figure3afocusesonpairsofconflictinglibrariesandshowshow
manyofthesepairsarecausedbythefourkindsofconflicts.Ifapair
of libraries is involved in multiple kinds of conflicts, then this pair
8https://cdnjs.com/
747
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Jibesh Patra, Pooja N. Dixit, and Michael Pradel
66
4134
0
0
002
40
000055
0Inclusion TypeValue Behavior
(a) Library pairs classified by the type of conflict.
64
130
3
0
4442
46
4415221
2Inclusion TypeValue Behavior
(b) Libraries classified by the type of conflict.
Figure3: Prevalence ofthefourkinds ofvalidatedconflicts.
Note that the surface is not proportional to the numbers.
isshownatthesetintersection.Forexample,therearefourpairs
of libraries that have a value conflict for a global access path and a
behaviorconflictforanotherglobalaccesspath.Figure3bshows
the distribution among the four kinds of conflicts for individual
libraries. Since a single library may be involved in conflicts with
different libraries, these sets overlap. For example, there are seven
librariesthatareinvolvedinatleastoneinclusionconflict,value
conflict, and behavior conflict.
There are two main take-aways of these results. First, all four
kinds of conflicts are prevalent in practice, which confirms our de-
cisionstoconsiderallfourkindsin ConflictJS .Second,themajority
of conflicts are non-inclusion conflicts, i.e., they do not cause an
exceptionjustafter loadingtheconflictinglibraries.Finding such
conflicts and reasoning about them is challenging for both library
developers and users alike.
5.3 Empirical Study of Library Conflicts
The large number of libraries considered and conflicts detected
in our evaluation, enables us to learn more about how and why
conflicts occur in JavaScript libraries. We discuss these findingsin the following and discuss what impact they have on library
developers, library users, and language designers.
5.3.1 RootCausesofConflicts. Tounderstandtherootcauses
of conflicts between libraries we manually inspect a random sam-
ple of 25 conflicting libraries. During the manual inspection, we
identified seven recurring patterns. Table 4 describes each pattern
and and illustrates it with an example.
Five of the seven patterns, which account for 18 out of the 25
inspected conflicts, are unintended by the developers and likely
tocausesurprisingbehaviorforlibraryusers.Thesepatternsare
shown in the upper part of Table 4. The patterns cover conflictscausedbyindependentlydevelopedvariantsofthesamefunctional-ity, copied third-party code, poor API usage, repeated use of conve-nientglobalidentifiername,andincorrectattemptstopatchbuilt-in
JavaScript APIs. To double-check our intuition about whether con-
flicts are intended by the library developers, we reported sevenconflicts to the developers of conflicting libraries. At the time of
writing,fourofourreportshavebeenacknowledgedandconfirmed
as worth fixing by the respective developers. Of the four acknowl-
edged libraries, two have been fixed by the developers. Apart from
this,basedonourbugreport,thedeveloperofalibraryhasreportedabugtoanotherlibrarywithwhichitwasconflicting.Subsequently,
this bug report also got fixed.
Forallofthesefivepatterns,therootcauseboilsdowntosubop-
timal decisions by library developers, such as programming errors
orcopy-and-pasteofexistingcode.However,atleastforsomeof
them,thedesignoftheJavaScriptlanguageandAPIsmayalsobepartially toblame. For example, instances ofthe “PoorAPI usage”
pattern are caused by the fact that the JavaScript web APIs provide
two orthogonal ways to attach event handlers: Setting the handler,
e.g., onmessage = .. , which overwrites any already attached han-
dler, and adding a handler via addEventListener("message", ..) ,
which preserves already attached handlers. The conflicts detected
byConflictJS are the result of libraries overwriting each other’s
event handlers by directly setting the handler. Another example is
the“Incorrectmonkeypatching”pattern.Theterm“monkeypatch-
ing” refers to extending built-in APIs of the JavaScript language,
whichispossiblebutnon-trivialtoimplementwithoutremoving
existing functionality.
The remaining two patterns, shown in the lower part of Table 4,
both occur in a situation where library users are unlikely to be
surprisedbytheconflict.Onereasonisthatlibrariesdependoneachotheranddocumentthesedependenciesclearly,sothatlibraryusers
know in which order to load them. Ideally, our experimental setup
wouldfiltersuchlibraries,asweassumeeachlibraryissupposed
tobeusedindependently.Anotherreasonisthatlibraries provide
the same or very similar overall functionality, so that library users
would never include both together.
Overall,we drawtwoconclusion fromourmanual inspection.
First,mostconflictsreportedby ConflictJS areprogrammingerrors
thatshouldbefixedbylibrarydeveloperstopreventclientsfrom
surprisingbehavior.Second,therootcausesofconflictsarediversebutcanbeclassifiedintoasetofrecurringpatterns.Knowingthese
patterns may become the basis of guidelines for library developers
what mistakes to avoid. Furthermore, the patterns can guide the
designoffutureprogramrepairtechniquesthatfixconflictingcode.
5.3.2 The“SingleAPIObject”Pattern. The“singleAPIobject”
pattern (Section 2.1) allows developers to avoid conflicts by storingallgloballyaccessibledataintoasingleobjectnamedlikethelibrary.
If all libraries follow this pattern, no conflicts occur. To understand
whether libraries follow this pattern, we check for each library
whether for all writes to a global access path, the path begins with
a segment that matches the name of the library, as listed in the
CDNJScontentdeliverynetwork.When matchinganaccess path
and a library name, we omit the .jssuffix that some libraries use.
Wefindthat273outofthe951librariesfollowthe“singleAPIob-
ject”pattern.Whilepromising,thismeansthat71%ofalllibrariesdo
748
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. ConflictJS: Finding and Understanding Conflicts Between JavaScript Libraries ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Table 4: Recurring patterns among the root causes of conflicts.
Pattern Description Nb. Example(s)
Independent imple-
mentationsTwo libraries implement similar functionality and use
the same global access path to store the function, but the
behavior slightly differs.5/25polymerandtrixboth define wrapandunwrapfunctions. Other
examples: Figure 1 and issue #434 of es6-shim.
Copied third-party
codeTwolibrariesbothcopycodefromathirdparty,e.g.,an-
other library. At least one version of the code is outdated.5/25qooxdooincludes an outdated copy of sinon. See issue #9277 of
qooxdoo. Another example: Issue #1068 of d3fc.
Poor API usage A library adds an event handler in a way that removes all
other handlers for this kind of event, instead of adding to
the existing event handlers.4/25rxjsandgifshotbothwriteto onmessage tohandlepostMessage
communication. Instead, they should use addEventListener ,
which allows multiple event handlers.
Convenient identi-
fierTwo libraries use a convenient, global identifier for differ-
ent purposes.3/25mermaid, a library for generating diagrams, writes to _, which is
also used by score-jsand others. See issue #512 of mermaid.
Incorrect monkey
patchingA library tries to extend a built-in API but accidentally
removes existing functionality.1/25PreloadJS andzingchart both overwrite the built-in JSONin a way
that destroys existing functionality. See issue #226 of PreloadJS.
Documented depen-
dencyOnelibrarydependsonanotheranddocumentsthisde-
pendency.4/25alloy-uiis a framework built on top of yui. Clients should not be
surprised by “conflicts” between them.
Fork One library is derived from another library and modifies
or extends the functionality of the original library.3/25wysihtml is an extended version of wysihtml5. Clients should never
use both together.
Table 5: Popularity of global access paths (measured in the
number of libraries that write to an access path).
Libs. Global access paths
13 $
12 localStorage.debug10 requestAnimationFrame
9 _, jQuery, onload, require8
clearImmediate, Promise, __core-js_shared__, __core-
js_shared__.wks, setImmediate, __core-js_shared__.wks.iterator,
__core-js_shared__.wks.toStringTag
notfollowthepattern,butinsteadusethesharedglobalnamespace
inapossiblyconflictingway.Weconcludethatrelyingondeveloper
disciplineinanopenenvironment,suchastheJavaScriptlibrary
ecosystem, is insufficient to enforce a conflict-avoiding policy.
5.3.3 Popular Global Access Paths. The large number of poten-
tial conflicts detected by ConflictJS raises the question what global
access paths are particularly popular among library developers.
Table 5 lists the most popular global access paths along with the
number of libraries that write to it. Perhaps unsurprisingly, the
mostpopular access pathis thedollarsign, $,which isalegaliden-
tifier name in JavaScript and used by several libraries, includingjQueryto export their API. Another popular choice is the under-
scoresign,
_,whichisshared,e.g.,bythe Underscore andLodash
libraries.ChoosingashortidentifiernametoexportanAPIistempt-
ing for library developers and potentially convenient for library
users. Howeve r, the downside is that multiple libraries may (either
knowinglyornot)pickthesameshortidentifiername,whichlikely
causes surprises if these libraries are used together.
5.3.4 Conflicts Versus Library Popularity. To better understand
to what extent library conflicts depend on a library’s popularity,
Figure 4a shows for each library how many stars it has and in how
manyconflictsitisinvolved.Eachdatapointcorrespondstoone
library.Forexample,onelibrarythathas45,901startsisinvolvedin
two conflicts. Overall, the figure shows that most conflicts are due
tolibrarieswithlessthan10,000stars.Themainreasonisthatonlyfewlibrarieshavemorethan10,000stars,asillustratedinFigure4b.
Thisfigureshowshowthelibrariesvalidatedtobeconflictingfrom(a) Number of conflicts each library is involved in.
(b) Popularity measure of libraries validated to be conflicting
Figure4:Influenceofpopularityonnumberofconflictsandnumber of libraries. Each data point represents one library.
(twelve out of 166 libraries do not have a Github repository
and hence are not included here)
ourbenchmarkaredistributedacrossthepopularitymeasure.Both
figures look similar, which explains the distribution of conflictsacross popularity. At the same time, it is interesting to note thateven some highly popular libraries are involved in conflicts, as
indicated by the data points on the right end of Figure 4a.
5.3.5 Distribution ofGlobalWritesAcrossLibraries. Tobetter
understandthelargenumberof130,714globalwritesperformedbythe951libraries,weanalyzehowthesewritesaredistributedacross
the libraries. The results show a highly skewed distribution, with a
fewlibrarieswritingtomanyglobalaccesspathsbutwithamedian
749
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Jibesh Patra, Pooja N. Dixit, and Michael Pradel
of only one global write. The libraries that write to most global
access paths are large and popular libraries, such as Amazon’s
AWS JDK (36,049 access paths) and Microsoft’s implementation
of TypeScript (5,678 global writes). Their high number of global
writesdoes notimply badcodingpractice. Forexample, the many
access paths written by the AWS SDK library almost all start with
AWS., i.e., they follow the “single API object” pattern. We conclude
that judging libraries based on their total number of global writes,
which might have been a simple alternative to ConflictJS , is not an
effective way to find conflict-triggering libraries.
5.3.6 Distribution of Conflicts Across Access Paths. A reader
may wonder how many libraries write to the same global access
path.Investigatingthisquestionyieldsalong-taildistribution:Most
global access paths (3,836) are contended for by only two libraries,
but a large number of highly popular global access paths is writ-ten to by up to 13 libraries. We conclude that preventing library
developersfromusingafewhighlycontendedaccesspaths,such
as$and_,isinsufficienttosolvetheproblemoflibraryconflicts,
because there are many other access paths that cause conflicts.
6 RELATED WORK
Lint-likeCheckers. Lint-likecheckerssearchforbadcodingprac-
tices through lightweight static analysis9, dynamic analysis [ 17],
andcombinationsofboth[ 10].Someofthem,e.g.,ESLintandJS-
Nose [10], warn about excessive use of global variables within a
single file, but they do not analyze conflicts across files or libraries.
Analysis of Libraries. Existing analyses of JavaScript libraries
checkthatalibraryimplementationmatchesitsinterfacespecifi-
cation [11], statically analyze library clients to understand types
and other properties of a library [ 30], and search for code injection
vulnerabilities [ 49]. Our work synthesizes library clients instead
of analyzing existing clients. Beyond JavaScript, Pollux [ 27] deter-
mines the effects of upgrading a library. Our work differs fromall the above by analyzing multiple libraries and their potential
interactions, instead of a single library.
DynamicAnalysisforJavaScript. Asurvey[ 3]summarizesdy-
namicanalysesforJavaScript.Existinganalysesincludedetermi-
nacy analysis [ 43], dynamic data race detectors [ 23,33,37,41],
dynamicmodelcheckers[ 24],profilerstodetectperformanceprob-
lems [16,26,44], taint- and information-flow analyses [ 4,6,21],
and analyses to understand code changes [ 2] and the root cause
of a crash [ 31]. All these techniques are orthogonal to ConflictJS ,
which is the first to focuses on library conflicts.
TestGeneration. Thetestsynthesispartof ConflictJS relatesto
generatingtestcases,suchasfeedback-directed,randomtestgener-
ation [36], symbolic and concolic execution [ 5,15,47], and search-
based testing [ 12]. JSeft [32] exploits fixtures extracted from ex-
ecutions to create tests. These techniques could help the second
phase ofConflictJS to further increase the percentage of validated
behavior conflicts.
TypeCheckingand TypeInference. Typeconflictsrelatetotype
errors andtype inconsistencies [ 38]. Severalapproaches inferand
9Populartoolsincludehttp://eslint.org/,http://jshint.com/,andhttp://www.jslint.com/.check types through static [ 18,22,25,50], dynamic [ 38], or hy-
brid [19] analysis. None of these has been applied to multiple li-
braries. Another difference is that most type checkers focus on
soundnessandthereforesufferfromfalsepositives,whereas ConflictJS
validates potential conflicts.
StudiesofJavaScript Code. StudiesshowthatJavaScriptlibraries
arewidelyusedandoftencombinedwitheachother.Nikiforakis
etal.[34]reportthat88%ofthewebsitesincludeatleastoneremote
library,andthatlibrariesareloadedfromover300.000uniqueURLs.
Another study [ 29] shows that a web site includes a median of 9
and a maximum of 202 externally hosted scripts. These numbers
illustrate the risk of accidental conflicts between libraries. Beyond
JavaScript, Eshkevari et al. report conflict-like problems in PHP
applications[ 9].Otherstudiesinvestigaterecurringperformance
bottlenecks [ 45], dynamic code loading [ 40,42], insecure coding
practices [ 48,51], typecoercions [ 39], type-relatederrors [ 14], re-
curringbug patterns [ 20],the useof trivialsoftwarepackages [ 1],
the root causes of failures [35], and the use of callbacks [13].
7 CONCLUSION
JavaScriptcode,includingindependentlydevelopedlibraries,shares
thesameglobalnamespace.Becausethemostwidelyusedversions
of the language lack features designed for encapsulating exported
APIs,librarydevelopersrisktoaccidentallysharethesameglobally
accessible memory locations and write different data and functions
to them. This paper defines and classifies such library conflicts,
presentsanautomaticandscalableapproachtodetectthem,and
studiesconflictsin alargesetoflibraries.Wedealwiththe hugesearch space of possible conflicts through a two-phase approach
thatdynamicallyanalyzeslibrariesinisolationtodetectpotential
conflictsandthensynthesizeslibraryclientstovalidateconflicts.
Among951real-worldlibraries,theapproachfinds166(17%)cer-
tainly conflicting libraries. Furthermore, we empirically study how
andwhyconflictsoccur,showingthatadiversesetofprogramming
errors in libraries are the primary root cause.
Our work not only provides a practical tool for library devel-
operstodetectconflictsandforlibraryuserstoavoidconflicting
libraries,butalsohighlightstheimportanceoflanguagefeatures
forencapsulatingindependentlydevelopedcode.Webelievethat
our work provides ample opportunities for future work. One di-
rection is to complement our precise but unsound analysis with a
sound(and likelyimprecise)checkerforlibrary conflicts. Tohelp
developersavoidconflicts,anotherlineoffutureworkarerepair
toolsthateitheraddressthecodingerrorsthatcauseconflicts.Fi-
nally,futureworkcoulddevelopautomaticcodetransformations
to help libraries use encapsulation mechanisms provided in recent
and future versions of JavaScript.
Acknowledgments
This work was supported by the German Federal Ministry of Education and Research
and by the Hessian Ministry of Science and the Arts within CRISP, by the German
Research Foundation within the ConcSys and Perf4JS projects, and by the Hessian
LOEWE initiative within the Software-Factory 4.0 project.
REFERENCES
[1]Rabe Abdalkareem, Olivier Nourry, Sultan Wehaibi, Suhaib Mujahid, and Emad
Shihab. 2017. Why Do Developers Use Trivial Packages? An Empirical Case
750
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. ConflictJS: Finding and Understanding Conflicts Between JavaScript Libraries ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Study on npm. In FSE.
[2]Saba Alimadadi, Ali Mesbah, and Karthik Pattabiraman. 2015. Hybrid DOM-
Sensitive Change Impact Analysis for JavaScript. In ECOOP. 321–345.
[3]Esben Andreasen, Liang Gong, Anders Møller, Michael Pradel, Marija Selakovic,
KoushikSen,andCristianalexandruStaicu.2017. ASurveyofDynamicAnalysis
and Test Generation for JavaScript. Comput. Surveys (2017).
[4]Thomas H. Austin and Cormac Flanagan. 2010. Permissive dynamic information
flow analysis.. In PLAS.
[5]CristianCadar,DanielDunbar,andDawsonR.Engler.2008.KLEE:Unassistedand
Automatic Generation of High-Coverage Tests for Complex Systems Programs.
InSymposium on Operating Systems Design and Implementation (OSDI). USENIX,
209–224.
[6]Ravai Chugh, Jeffrey A. Meister, Ranjit Jhala, and Sorin Lerner. 2009. Staged
Information Flow for JavaScript. In Conference on Programming Language Design
and Implementation (PLDI). ACM, 50–62.
[7]ECMA. 2011. Standard ECMA-262, ECMAScript Language Specification, 5.1
Edition. (June 2011).
[8]ECMA. 2015. Standard ECMA-262, ECMAScript Language Specification, 6th
Edition. (June 2015).
[9]Laleh Eshkevari, Giuliano Antoniol, James R. Cordy, and Massimiliano Di Penta.
2014. IdentifyingandLocatingInterferenceIssuesinPHPApplications:TheCase
of WordPress. In Proceedings of the 22Nd International Conference on Program
Comprehension (ICPC 2014). ACM, New York, NY, USA, 157–167. DOI:http:
//dx.doi.org/10.1145/2597008.2597153
[10]Amin Milani Fard and Ali Mesbah. 2013. JSNOSE: Detecting JavaScript code
smells.In SourceCodeAnalysisandManipulation(SCAM),2013IEEE13thInterna-
tional Working Conference on. IEEE, 116–125.
[11]AsgerFeldthausandAndersMøller.2014. CheckingcorrectnessofTypeScript
interfaces for JavaScript libraries. In Conference on Object Oriented Programming
Systems Languages and Applications (OOPSLA). ACM, 1–16.
[12]GordonFraserandAndreaArcuri.2011. EvoSuite:automatictestsuitegeneration
for object-oriented software. In SIGSOFT/FSE’11 19th ACM SIGSOFT Symposium
on the Foundations of Software Engineering (FSE-19) and ESEC’11: 13th European
Software Engineering Conference (ESEC-13), Szeged, Hungary, September 5-9, 2011.
416–419.
[13]Keheliya Gallaba, Ali Mesbah, and Ivan Beschastnikh. 2015. Don’t Call Us, We’ll
Call You: Characterizing Callbacks in Javascript. In 2015 ACM/IEEE International
Symposium on Empirical Software Engineering and Measurement, ESEM 2015,
Beijing, China, October 22-23, 2015. 247–256.
[14]ZhengGao,Christian Bird, andEarl T.Barr. 2017. To typeor not totype: quan-
tifying detectable bugs in JavaScript. In Proceedings of the 39th International
Conference on Software Engineering, ICSE 2017, Buenos Aires, Argentina, May
20-28, 2017. 758–769.
[15]Patrice Godefroid, Nils Klarlund, and Koushik Sen. 2005. DART: directed au-
tomated random testing. In Conference on Programming Language Design and
Implementation (PLDI). ACM, 213–223.
[16]Liang Gong, Michael Pradel, and Koushik Sen. 2015. JITProf: Pinpointing JIT-
unfriendly JavaScript Code. In European Software Engineering Conference and
Symposium on the Foundations of Software Engineering (ESEC/FSE). 357–368.
[17]Liang Gong, Michael Pradel, Manu Sridharan, and Koushik Sen. 2015. DLint:
Dynamically Checking Bad Coding Practices in JavaScript. In International Sym-
posium on Software Testing and Analysis (ISSTA). 94–105.
[18]ArjunGuha,ClaudiuSaftoiu,andShriramKrishnamurthi.2011. TypingLocal
Control and State Using Flow Analysis. In European Symposium on Programming
(ESOP). 256–275.
[19]BrianHackettandShu-yuGuo.2012. FastandPreciseHybridTypeInferencefor
JavaScript. In Conference on Programming LanguageDesign and Implementation
(PLDI). ACM, 239–250.
[20]Quinn Hanam, Fernando Santos De Mattos Brito, and Ali Mesbah. 2016. Dis-
covering bug patterns in JavaScript. In Proceedings of the 24th ACM SIGSOFT
InternationalSymposiumonFoundationsofSoftwareEngineering,FSE2016,Seattle,
WA, USA, November 13-18, 2016. 144–156.
[21]DanielHedin,ArnarBirgisson,LucianoBello,andAndreiSabelfeld.2014. JSFlow:
tracking information flow in JavaScript and its APIs. In SAC. 1663–1671.
[22]Phillip Heidegger and Peter Thiemann. 2010. Recency Types for Analyzing
ScriptingLanguages.. In EuropeanConferenceonObject-OrientedProgramming
(ECOOP). 200–224.
[23]Shin Hong, Yongbae Park, and Moonzoo Kim. 2014. Detecting Concurrency
Errors in Client-Side Java Script Web Applications.. In ICST. 61–70.
[24]Casper Svenning Jensen, Anders Moller, Veselin Raychev, and Martin Vechev.
2015. Stateless Model Checking of Event-Driven Applications. In Conference on
Object-Oriented Programming Systems, Languages and Applications (OOPSLA).
[25]SimonHolmJensen,AndersMøller,andPeterThiemann.2009. TypeAnalysis
for JavaScript. In Symposium on Static Analysis (SAS). Springer, 238–255.
[26]Simon Holm Jensen, Manu Sridharan, Koushik Sen, and Satish Chandra. 2015.
MemInsight: platform-independent memory debugging for JavaScript. In Pro-
ceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering,
ESEC/FSE 2015, Bergamo, Italy, August 30 - September 4, 2015. 345–356.[27]Sukrit Kalra, Ayush Goel, Dhriti Khanna, Mohan Dhawan, Subodh Sharma,
andRahulPurandare.2016. POLLUX:safelyupgradingdependentapplication
libraries. In Proceedings of the 24th ACM SIGSOFT International Symposium on
Foundations of Software Engineering, FSE 2016, Seattle, WA, USA, November 13-18,
2016. 290–300.
[28]J. C. King. 1976. Symbolic Execution and Program Testing. Commun. ACM 19, 7
(1976), 385–394.
[29]TobiasLauinger,AbdelberiChaabane,SajjadArshad,WilliamRobertson,Christo
Wilson,andEnginKirda.2017. ThouShaltNotDependonMe:Analysingthe
Use of Outdated JavaScript Libraries on the Web. In NDSS.
[30]Magnus Madsen, Benjamin Livshits, and Michael Fanning. 2013. Practical static
analysisofJavaScriptapplicationsinthepresenceofframeworksandlibraries.
InESEC/SIGSOFT FSE. 499–509.
[31]Magnus Madsen, Frank Tip, Esben Andreasen, Koushik Sen, and Anders Møller.
2016. Feedback-directedinstrumentationfordeployedJavaScriptapplications.
InProceedings of the 38th International Conference on Software Engineering, ICSE
2016, Austin, TX, USA, May 14-22, 2016. 899–910.
[32]Shabnam Mirshokraie, Ali Mesbah, and Karthik Pattabiraman. 2015. JSEFT:
Automated Javascript Unit Test Generation. In ICST.
[33]Erdal Mutlu,Serdar Tasiran,and BenjaminLivshits. 2015. Detecting JavaScript
Races that Matter. In European Software Engineering Conference and International
Symposium on Foundations of Software Engineering (ESEC/FSE).
[34]Nick Nikiforakis, Luca Invernizzi, Alexandros Kapravelos, Steven Van Acker,
Wouter Joosen, Christopher Kruegel, Frank Piessens, and Giovanni Vigna. 2012.
You Are What You Include: Large-scale Evaluation of Remote Javascript In-
clusions. In Proceedings of the 2012 ACM Conference on Computer and Com-
munications Security (CCS ’12). ACM, New York, NY, USA, 736–747. DOI:
http://dx.doi.org/10.1145/2382196.2382274
[35]FrolinS.OcarizaJr.,KartikBajaj,KarthikPattabiraman,andAliMesbah.2013.
AnEmpiricalStudyofClient-SideJavaScriptBugs.In SymposiumonEmpirical
Software Engineering and Measurement (ESEM). 55–64.
[36]Carlos Pacheco, Shuvendu K. Lahiri, Michael D. Ernst, and Thomas Ball. 2007.
Feedback-Directed Random Test Generation. In International Conference on Soft-
ware Engineering (ICSE). IEEE, 75–84.
[37]Boris Petrov, Martin Vechev, Manu Sridharan, and Julian Dolby. 2012. Race
Detection for Web Applications. In Conference on Programming Language Design
and Implementation (PLDI).
[38]MichaelPradel,ParkerSchuh,andKoushikSen.2015. TypeDevil:DynamicType
Inconsistency Analysis for JavaScript. In International Conference on Software
Engineering (ICSE).
[39]Michael Pradeland KoushikSen. 2015. The Good, theBad, and theUgly: An Em-
pirical Study of Implicit Type Conversions in JavaScript. In European Conference
on Object-Oriented Programming (ECOOP).
[40]ParujRatanaworabhan,BenjaminLivshits,andBenjaminG.Zorn.2010. JSMeter:
Comparing the Behavior of JavaScript Benchmarks with Real Web Applications.
InUSENIX Conference on Web Application Development, WebApps’10, Boston,
Massachusetts, USA, June 23-24, 2010.
[41]VeselinRaychev,MartinVechev,andManuSridharan.2013. EffectiveRaceDetec-
tion for Event-Driven Programs. In Conference on Object-Oriented Programming,
Systems, Languages, and Applications (OOPSLA).
[42]Gregor Richards, Christian Hammer, Brian Burg, and Jan Vitek. 2011. The Eval
That Men Do- A Large-Scale Study ofthe Use of Evalin JavaScript Applications.
InEuropean Conference on Object-Oriented Programming (ECOOP). 52–78.
[43]Max Schäfer, Manu Sridharan, Julian Dolby, and Frank Tip. 2013. Dynamic
determinacy analysis. In PLDI. 165–174.
[44]Marija Selakovic, Thomas Glaser, and Michael Pradel. 2017. An Actionable
PerformanceProfilerforOptimizingtheOrderofEvaluations.In International
Symposium on Software Testing and Analysis (ISSTA). 170–180.
[45]MarijaSelakovicand MichaelPradel.2016. Performance IssuesandOptimiza-
tionsin JavaScript: AnEmpiricalStudy.In International Conference onSoftware
Engineering (ICSE). 61–72.
[46]Koushik Sen, Swaroop Kalasapur, Tasneem Brutch, and Simon Gibbs. 2013.
Jalangi: A Selective Record-Replay and Dynamic Analysis Framework for
JavaScript. In European Software EngineeringConferenceand Symposium on the
Foundations of Software Engineering (ESEC/FSE). 488–498.
[47]Koushik Sen, Darko Marinov, and Gul Agha. 2005. CUTE: a concolic unit testing
engine for C. In European Software Engineering Conference and International
Symposium on Foundations of Software Engineering (ESEC/FSE). ACM, 263–272.
[48]Sooel Son and Vitaly Shmatikov. 2013. The Postman Always Rings Twice: At-
tacking and Defending postMessage in HTML5 Websites.. In NDSS.
[49]Cristian-AlexandruStaicu,MichaelPradel,andBenLivshits.2018. Understanding
and Automatically Preventing Injection Attacks on Node.js. In NDSS.
[50]PeterThiemann.2005.TowardsaTypeSystemforAnalyzingJavaScriptPrograms.
InEuropean Symposium on Programming (ESOP). 408–422.
[51]ChuanYueandHainingWang.2009. Characterizinginsecurejavascriptpractices
on the web. In Proceedings of the 18th International Conference on World Wide
Web, WWW 2009, Madrid, Spain, April 20-24, 2009. 961–970.
751
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. 