arXiv:1807.03280v1  [cs.CR]  9 Jul 2018Adversarial SymbolicExecutionforDetecting
Concurrency-RelatedCache TimingLeaks
ShengjianGuo
Virginia Tech
Blacksburg,VA,USAMengWu
Virginia Tech
Blacksburg,VA,USAChaoWang
University of Southern California
LosAngeles,CA,USA
ABSTRACT
Thetiming characteristicsofcache, ahigh-speedstorageb etween
the fast CPU and the slow memory, may reveal sensitive inform a-
tion of a program, thus allowing an adversary to conduct side -
channel attacks. Existing methods for detecting timing lea ks ei-
ther ignore cache all together or focus only on passive leaks gen-
erated by the program itself, without considering leaks tha t are
madepossiblebyconcurrentlyrunningsomeotherthreads.I nthis
work, we show that timing-leak-freedom is not a compositional
property: a program that is not leaky when running alone may
become leaky when interleaved with other threads. Thus, we d e-
velop a new method, named adversarial symbolic execution , to de-
tectsuchleaks.Itsystematicallyexploresboththefeasib leprogram
paths andtheir interleavings whilemodelingthecache, and lever-
ages an SMT solver to decide if there are timing leaks. We have
implementedourmethodinLLVMandevaluateditonasetofrea l-
worldcipherswith14,455linesofCcodeintotal.Ourexperi ments
demonstrateboththeeﬃciencyofourmethodanditseﬀective ness
in detectingside-channel leaks.
CCS CONCEPTS
•Security and privacy →Cryptanalysis and other attacks ;
•Software and its engineering →Software veriﬁcation and
validation ;
KEYWORDS
Side-channel attack, concurrency, cache, timing, symboli c execu-
tion
1 INTRODUCTION
Side-channel attacks are security attacks where an adversa ry ex-
ploits the dependency between sensitive data and non-funct ional
propertiesofaprogramsuchastheexecutiontime[ 28,43],power
consumption[ 44,51],heat,sound[ 37],andelectromagnetic radia-
tion[36,57].Fortiming sidechannels, inparticular,thereare two
mainsourcesofleaks:variancesinthenumberofexecutedin struc-
tionsandvariancesinthecachebehavior.Instruction-ind ucedleaks
are caused by diﬀerences in the number and type of instructio ns
executedalongdiﬀerent paths:unless thediﬀerences are in depen-
dent of the sensitive data, they may be exploited by an advers ary.
Cache-induced leaks are caused by diﬀerences in the number o f
cache hits and misses along diﬀerent paths.
Existingmethodsfordetectingtimingleaksorprovingthei rab-
senceoftenignorethecachealltogetherwhilefocusingoni nstruction-
induced leaks. Forexample, Chen etal.[ 23]used CartesianHoare
Logic[58]toprovethetimingleakofaprogramiswithinabound;
Antonopoulos et al. [ 8] used a similar technique that partitions
, ,
.ProgramP′
(ThreadT2)Concurrent Pro-
gramP′′ProgramP
(ThreadT1)
Symbolic
Execution
Adversarial
Cache ModelingSMT Solving
Cache
ConﬁgurationCache-timing
LeakageAdversarial
Thread Schedule
Figure1: Flow of our cachetimingleakdetector S/y.sc/m.scSC.
the set of program paths in a way that, if individual partitio ns
areproved tobetimingattack resilient, theentire program is also
timing attack resilient. Unfortunately, these methods ign ore the
cache-timingcharacteristics.Evenfortechniquesthatco nsiderthe
cache [12,21,25,30,46,61], their focus has been on leaks mani-
fested by the program itself when running alone, without con sid-
ering the cases when it is executed concurrently with some ot her
(benign oradversarial) threads.
In this work, we show side-channel leak-freedom , as a security
property,is not compositional.That is, a leak-free progra m when
running alonemaystillbeleaky whenit is interleaved witho ther
threads, provided that they share the memory subsystem. Thi s is
the case even if all paths in the program have the same number
and type of instructions and thus do not have instruction-induced
timing leaks at all. Unfortunately, no existing method or to ol is
capableof detectingsuch timingleaks.
We propose a new method, named adversarial symbolic execu-
tion, to detect such concurrency-related timing leaks. Speciﬁc ally,
givenaprogramwhereonethreadconductsasecurity-critic alcom-
putation, e.g., by calling functions in a cryptographic lib rary, and
another thread is (either accidentallyorintentionally) a dversarial,
our method systematically explores both paths in these thre ads
and their interleavings. The explorationis symbolic in tha t it cov-
ers feasible paths under all input values. During the symbol ic ex-
ecution,we aim toanalyze thecache behavior relatedtosens itive
datatodetecttiming leaks causedbytheinterleaving.
Figure1showstheﬂowofourleakdetectornamed S/y.sc/m.scSC,which
takes the victim thread P, a potentially adversarial thread P′, and
the cache conﬁguration as input. If P′is not given, S/y.sc/m.scSCcre-
ates it automatically. While symbolically executing the pr ogram,
S/y.sc/m.scSCexploresallthreadpathsandsearchesforanadversarialin -
terleavingofthesepathsthatexposesdivergentcachebeha viorsin
P.Therearetwomaintechnicalchallenges.Theﬁrstoneisass oci-
atedwithsystematicexplorationoftheinterleavedexecut ionsofa
concurrentprogramsoasnottomissanyadversarialinterle aving.
The second one is associated with modeling the cache accurat ely
whilereducingthecomputationalcost.
1,, Shengjian Guo,Meng Wu, andChaoWang
Toaddresstheﬁrstchallenge,wedevelopedanewalgorithmf or
adversarially exploring the interleaved executions while mitigat-
ing thepath and interleavingexplosions . Speciﬁcally,cache timing
behaviorconstraints,whichareconstructed ontheﬂy duringsym-
bolicexecution,areleveragedtopruneinterleavingsredu ndantfor
detectingleaks and thusspeeduptheexploration.
To address the second challenge, we developed a technique fo r
modeling the cache behavior of a program based on the cache’s
typeandconﬁguration,aswellasoptimizationsofthesubse quent
constraint solvingtoreduceoverhead. Foreach concurrent execu-
tion (an interleaving of the threads) denoted π=(in,sch), where
inis the sensitive data input and schis the interleaving schedule,
we construct a logical constraint τt(in,sch)for every potentially
adversarial memory access t, to indicate when it leads to a cache
hit.Then,weseek twodistinctvaluesofthedatainput, inandin′,
for which the cache behaves diﬀerently: τt(in,sch)/nequalτt(in′,sch),
meaning one of them is a hit but the other is a miss, and they are
duetodiﬀerences inthesensitive data input.
We have implemented our method in a software tool based on
LLVM and the KLEE symbolic virtual machine [ 20], and evalu-
ateditontwentybenchmarkprograms.Thesesecurity-criti calpro-
gramsarecipherstakenfromcryptographiclibrariesinthe public
domain; they have 14,455 lines of C codein total.Since these pro-
grams are crafted by domain experts, they do not have obvious
timing leaks when running alone, such as unbalanced branchi ng
statementsorvariancesinlookup-tableaccesses.However ,ourex-
perimentsofapplying S/y.sc/m.scSCshowthattheymaystillhavetiming
leaks whenbeing executedconcurrentlywith otherthreads.
To summarize,wemake thefollowingcontributions:
•Weproposean adversarial symbolicexecution methodcapa-
bleofdetectingcachetimingleaksinasecurity-criticalp ro-
gram whenit runs concurrentlywithother threads.
•We implement and evaluate our method on real-world ci-
pherprogramstodemonstrateitseﬀectiveness indetecting
concurrency-related timingleaks.
In the remainder of this paper, we ﬁrst motivate our work us-
ing several examples in Section 2and then provide the technical
backgroundinSection 3.WepresentourdetailedalgorithmsinSec-
tions4and5,whicharefollowedbydomain-speciﬁcoptimizations
inSection 6toreducethecomputationaloverhead.Wepresentour
experimental results in Section 7and review the related work in
Section8.Finally, wegive ourconclusions inSection 9.
2 MOTIVATION
Inthissection,weuseexamples toexplainthediﬀerence bet ween
self-leaking and concurrency-induced leaking.
2.1 A Self-leakingProgramand theRepair
Figure2(a) shows a program whose execution time is dependent
of the sensitive variable k. It is a revised version of the running
exampleusedin[ 22],forwhichtheauthorsproposedtheleak-free
versionshowninFigure 2(b).Thetwoprogramshavethesameset
ofinstructionsbutdiﬀerinwherethehighlighted loadinstruction
is located:line 5in Pand line9 in Pr.
Consider executing the two programs under a 512-byte direct -
mapped cache with one byte per cache line, as shown in Figure 3.
Thechoiceofone-byte-per-cache-line—sameasin[ 22]—ismeant/* k is sensitive input */
1: char p[256];
2: unsigned char k;
3: char q[256];
4:
5:load reg1, p[k]
6: if (k <= 127)
7: load reg2, q[255-k]
8: else
9: load reg2, q[k-128]
10: add reg1, reg2
11: store reg1, p[k]
-----------------------------
k=0 : <miss, miss, miss>
1≤k≤255: <miss, miss, hit>
(a) Theleakyprogram P/* k is sensitive input */
1: char p[256];
2: unsigned char k;
3: char q[256];
4:
5: if (k <= 127)
6: load reg2, q[255-k]
7: else
8: load reg2, q[k-128]
9:load reg1, p[k]
10: add reg1, reg2
11: store reg1, p[k]
-----------------------------
0≤k≤255: <miss, miss, hit>
(b) Theleak-freeversion Pr
Figure2: A program with cache-timingleak(cf.[ 22]).
q[254]......q[1]q[0]kp[255]......p[1]p[0],q[255]
256 bytes
256 bytes
Figure3: Thedirect-mappedcache layout(cf. [ 22]).
tosimplifyanalysiswithoutlossofgenerality.Speciﬁcal ly,the256-
bytearray pisassociatedwiththeﬁrst256cachelines,whilevari-
ablekis associated with the 257-th cache line. Due to the ﬁnite
cachesize, q[255]has toshare thecache linewith p[0].
Thereare twoprogram paths in P, each withthree memoryac-
cesses:load(line 5),load(line 7 or line 9), and store(line 11).
However, depending on the value of k, these three memory ac-
cesses may exhibit diﬀerent cache behaviors, thus causing d ata-
dependent timing variance.
Assume that k’s value is 0, executing Pmeans taking the then
branch and accessing p[0],q[255], andp[0]. The ﬁrst access to
p[0]isacoldmisssincethecacheisemptyatthemoment.Theac-
cess toq[255]is a conﬂict miss becausethe cacheline (shared by
q[255]andp[0]) is occupied by p[0]; as a result q[255]evicts
p[0]. The next access to p[0]is also a conﬂict miss since the
cache line is occupied by q[255]. All in all, the cache behavior
is<miss,miss,miss> fork=0.
Thissequenceisalsouniqueinthatallothervalues of kwould
produce<miss,miss,hit> as shown at the bottom of Figure 2(a).
Thismeans P,whenrunningalone,leaksinformationabout k.For
example, uponobserving the delay caused by <miss,miss,miss>
via monitoring, anadversary mayinfer that k’s valueis 0.
Program Pris a repaired version [ 22] where the loadis moved
fromline5toline9asinFigure 2(b).Thus,the loadaccessing p[k]
atline9alwaysgenerates acoldmiss( 0<k≤255) oraconﬂictmiss
(k=0). Consequently,the storeatline11isalways ahit.Thus,for
allvaluesof k,thecachebehaviorremains <miss,miss,hit> –no
informationof kis leaked.
2.2 New Leak Induced by Concurrency
Although Prisavalidrepairwhentheprogramisexecutedsequen-
tially,thesituationchanges whenitisexecutedconcurren tlywith
2, ,
/* [Thread T1] */
1: char p[256];
2: unsigned char k;
3: char q[256];
4:
5: if (k <= 127)
6: load reg2, q[255-k]
7: else
8: load reg2, q[k-128]
9:load reg1, p[k]
10: add reg1, reg2
11: store reg1, p[k]/* [Thread T2] */
12: unsigned char tmp;
13:load reg3, tmp
14: ...
Figure4: Concurrentprogram with side-channelleak.
q[254]......q[1]q[0]kp[255]......p[1],tmpp[0],q[255]
p[k]p[k]q[255-k]T1
tmpT2
Figure5: Interleaving 6-9-13-11 andthecache layout.
other threads. Speciﬁcally, if we use one thread ( T1) to execute Pr
while allowing a second thread ( T2) to run concurrently, Prmay
exhibit new timingleaks.
Figure4shows a two-threaded program comprising T1and an
adversarial T2that accesses a new variable tmp. Assume tmpis
mapped to the same cache line as p[1]. Then, it is possible for
T2tocauseT1toleak informationof itssecret data.Thereare var-
ious ways of mapping tmpto the same cache line as p[1], e.g., by
dynamically allocating the memory used by tmpor invoking a re-
cursive(ornon-recursive) functionwithinwhich tmpisdeﬁnedas
a stack variable.
Table1shows the six interleavings of threads T1andT2. The
lefthalfofthistablecontainsthreeinterleavingswhere T1tookthe
thenbranchoftheif-statement,whiletherighthalfcontainsth ree
interleavingswhere T1tooktheelsebranch.Ineachcase,thefour
columns show the ID, the execution order, the cache sequence of
threadT1,andthevaluerangeof k.Forexample,in 6-9-11-13 ,the
storeat line 11 is a cache hit because its immediate predecessor
(line 9) already loads p[k]into the cache. Since the last loadat
line13comesfromthread T2,thecachebehaviorsequenceof T1is
<miss,miss,hit> , denoted <m,m,h>forbrevity.
Table 1: Interleavingsandthread T1’s cachesequences.
ID Interleaving Cache-seq kID Interleaving Cache-seq k
16-13-9-11 <m,m,h> [0,127] 48-13-9-11 <m,m,h> (127,255]
26-9-11-13 <m,m,h> [0,127] 58-11-9-13 <m,m,h> (127,255]
36-9-13-11 <m,m,h> [0,1)∪(1,127]68-9-13-11 <m,m,h> (127,255]
<m,m,m> 1
Although context switches between the threads T1andT2may
occur at any time in practice, for the purpose of analyzing ca che
timingleaks,weassumetheyoccuronlybeforethe loadandstore
statements.Furthermore,weonlyfocusonthesememoryacce sses
when they are mapped to the same cache line, e.g., between the
loadinT2and statements that access p[k]inT1.We use Figure 5to show details of 6-9-13-11 . The blue and
orange rectangles represent the loadandstoreaccesses, respec-
tively, and the red dashed poly-line shows their execution o rder.
The ﬁrst three loadoperations all cause cache misses, whereas
the laststorecould be a cache hit if ( k!=1) and a cache miss if
(k=1). When ( k=1), the four memory accesses would be q[254],
p[1],tmp, andp[1]. The ﬁrst two trigger cold misses. The third
one(tmp)triggersaconﬂictmissasthecachelinewasoccupiedby
p[1]. Evicting this cache line would then lead to another conﬂict
miss forthesubsequent storetop[1].
Theexamplespresentedsofarshowthat,evenforatiming-le ak-
freeprogram( T1),runningitconcurrentlywithanotherthread( T2)
maycauseittoexhibitnewtimingleaks.Thisisthecaseeven ifthe
twothreads( T1andT2) arelogicallyindependent ofeachother.In
other words, they do not need to share variables or communica te
through messages; they can aﬀect each other’s timing behavi ors
bysharing thesamecachesystem.
2.3 Adversarial SymbolicExecution
Thegoalofdeveloping anew symbolicexecutionmethodistod e-
tect such timing leaks. More speciﬁcally, we are concerned w ith
two application scenarios for S/y.sc/m.scSC, depending on whether the
adversarial thread ( T2) exists in thegiven program ornot.
Case 1. Thread T2is given, together with ﬁxed addresses of the
memoryregionaccessed by T2.Inthis case, T2isanintegral partof
theconcurrentsystemthatalsocontainsthesecurity-crit icalcom-
putationin T1. Since theonly source of nondeterminism is thread
interleaving, ourtoolaimstocheckiftheconcurrentsyste mitself
has timingleaks.
Case 2. Thread T2is not given, but created by our tool, and thus
the addresses of the memory region accessed by T2are assumed to
be symbolic. This is when, inside the cache layout of Figure 5, the
address of tmpwould be made symbolic, thus allowing it to be
mapped to any cache line (as opposedto be ﬁxed to the 2nd line) .
There are now two sources of non-determinism: thread interl eav-
ingandmemorylayout.Ourtoolexploresbothtocheckif T1may
leak informationduetointerference from T2.
In the second case, when T2executes a memory load instruc-
tiont, for example, the symbolic address addrmay be mapped to
any cache line. The purpose of having such aggressive advers ar-
ial addressing is to allow S/y.sc/m.scSCto conduct a (predictive) what-if
analysis:itsearches allpotentialmemorylayoutstocheck ifthere
exists onethatallows T2tocausea timingleak.
3 THE THREAT MODEL
We now review the technical background and present the threa t
model,which deﬁnes whatan adversary canorcannot do.
3.1 Cache and theTiming SideChannels
TheexecutiontimeofaprogramdependsontheCPUcyclestake n
toexecutetheinstructionsandthetimeneededtoaccess mem ory.
The ﬁrst component is easy to compute but also less important
inpractice,becausesecurity-criticalapplicationsofte nexecutethe
samesetofinstructionsregardlessofvaluesoftheirsensi tivevari-
ables[65].Incontrast,leaksaremorelikelytooccurinthesecond
component: the time taken to access memory. Compared to the
3,, Shengjian Guo,Meng Wu, andChaoWang
timeneededtoexecuteaninstruction,whichmaybe1-3clock cy-
cles, the time taken to access memory, during a cache miss, ma y
betens oreven hundreds of clockcycles.
Therearediﬀerenttypesofcachebasedonthesize,associat ivity
andreplacement policy.Foreaseofcomprehension, weusedi rect-
mappedcachewithLRUpolicyinthispaper,butothercachety pes
may be handled similarly. Indeed, during our experiments, b oth
direct-mapped cache and 4-way set-associative cache were e valu-
atedand theyled tosimilar analysis results.
We assume the security-critical program Pimplements a func-
tionc←f(k,x), wherekis the sensitive input (secret), xis the
non-sensitive input (public), and cis the output. In block ciphers,
for example, kwould be the cryptographic key, xwould be the
plaintext, cwould be the ciphertext, and fwould be the encryp-
tionordecryptionprocedure.
Let theexecutiontimeof PbeτP(k,x).Sincetheremaybemul-
tiple paths inside P, when referring to a particularpath p∈P, we
useτp(k,x). But if there is no ambiguity, we may omit the detail
and simply use τ(k,x). Wesay P is leak-free if τ(k,x)remains the
same forallinput values.Thatis,
∀x,k1,k2.τ(k1,x)=τ(k2,x)
Herek1andk2aretwoarbitraryvaluesof k.Sinceinpractice,deci-
sion procedures (e.g., SMT solvers) are designed for checki ng sat-
isﬁability, instead of proving the validity of a formula, we try to
falsify it bychecking theformulabelow:
∃x,k1,k2.τ(k1,x)/nequalτ(k2,x)
Here, we search for twovalues of kthatcanlead todiﬀerences.
If the set of instructions executed by Premains the same, we
only need to check whether τ(k1,x)andτ(k2,x)have the same
numberofcachehitsandmisses.Furthermore,inourthreatm odel
wheretheattackercanonlyobserve(passively)theexecuti ontime
ofP,butnotcontrolorobserve x,wecanreducethecomputational
cost by ﬁxing a value xofxarbitrarily and then checking if τ(k1)
andτ(k2)have thesame numberof cachehits and misses.
3.2 Exampleofan Attack
Now,weshowaconcreteexampleofexploitingcachetimingle aks
in concurrent systems. Thegoal is to illustratewhat an adve rsary
may beabletoachieve in practice.
Figure6showsatwo-threadedprogram,itscachemapping,and
thethread-localcontrolﬂows.Initially, T2allocatesamemoryarea
(buf) whose size matches the input. Although the input size may
be arbitrary, here, we assume it is an integral multiple of 64 , e.g.,
1024bytes( INPUT_SIZE =1024).Inthe while-loop(line14) T2reads
64 bytes from input every time to ﬁll buf. Thread T1tracks the
progress ( idx) ofT2(line 4) and repeatedlyretrieves 64-byte data
frombuftothearray out(line5).Theencryptionon outinvolves
the S-Box array Sand a given key(lines 6-7). Once the data is en-
crypted,T1sends it out (line 8). When T1ﬁnds that bufruns out
of data,itsleeps for50ms (line10).
First, we explain why the program has a timing leak. We use a
32KBdirect-mappedcachehereandseteachcachelineto64by tes.
The S-Box array Shence maps to 4 cache lines and the bufarray
mapsto16cachelines.Forbrevity,weonlyfocusontheimpor tant
arrays (Sandbuf) while assuming other variables do not aﬀect
the cache mapping. Furthermore, we assume Sandbufshare one
cache lineas highlighted inFigure 6.uint8_t *buf = 0; uint32_t size = INPUT_SIZE; uint32_t idx = 0 ;
/* [Thread T1] */
1: uint8_t S[256] = {0x4b,...};
2: uint8_t out[64] = {0};
3: for(int i=0; i<size; )
4: if (i < idx)
5: memcpy(out,buf+i,64);
6: for (int j=0;j<64;j++,i++)
7: out[j] &= S[key[j]];
8: write(out, ...);
9: else
10: sleep(50);/* [Thread T2] */
11: ......
12: buf=(uint8_t *)malloc(size);
13: while(idx<size)
14: memcpy(buf+idx,read(...),64);
15: idx+=64;
16: ......
......S[192]-S[255]S[128]-S[191]S[64]-S[127]S[0]-S[63], buf[960]-buf[1023]......buf[0]-buf[63]......64bytes
32KB
7
j<645i<idx
10i<sizeT1
1413idx<sizeT2
idx: 960
Figure6: A two-threadedencryption program.
ThegraphinFigure 6showsaninterleavingof T1andT2,where
thedottedredarrowrepresents acontextswitchafter T2executes
thememcpystatement (line 14) while T1just reaches the for-loop
atline6.Thetextabovethearrow means idx’s valueis 960atthe
moment,indicatingthread T2hasjustaccessedthelast64bytesof
bufat line14.
Afterthecontextswitch, T1entersthe for-loop(line6)andreads
S[key[j]] at line 7. Note that the oﬀset to S’s base address de-
pends on key[j], thus diﬀerent keys may make thread T1access
diﬀerent items of S. We pick two 64-byte keys k1andk2which
diﬀer in the ﬁrst eight bits: 10000000 for k1and 00000000 for k2.
Usingk1, threadT1ﬁrst reads key[0]andS[128]. The access to
S[128]would lead to a cache hit if iis greater than 63. This is
becauseafter the for-loop (lines 6-7) ﬁnishes once ( i=64),S[128]
is alreadymappedtocacheand no further accesses evict it.
In contrast, with k2, threadT1loadsS[0]which maps to the
cachelinesharedwith buf[960-1023] . Recallthat,beforethecon-
textswitch, T2justaccessedtheareastartingfrom buf+idx(buf[960] ).
Consequently T1’s access to S[0]causes a conﬂict miss because
the shared cache line was occupied by buf. Thus, we ﬁnd a leak:
twokeys( k1andk2)leadingtodivergentcachebehaviorsatapro-
gram locationduetothread interleaving.
Next, we discuss how this leak may be exploited. The leak is
due to the sharing of cache between Sandbuf, which is crucial
to our threat model. In this program, Shas a ﬁxed size while buf
is dynamically allocated at run time based on the input data. Fur-
thermore, INPUT_SIZE is a variable aﬀected by the external input.
Although the actual input size cannot be arbitrarily large i n prac-
tice, for this exploit to work, it only needs to be larger than the
totalcachesize, which is 32KB.
Thus, the attacker could mutate the input to alter the buﬀer
size,henceaﬀectingthememorylayout.Furthermore,reala pplica-
tions sometimes use relatively large ﬁxed buﬀers. For examp le, in
OpenSSH[ 5],thescpprogramhasa16KBbuﬀerfor COPY_BUFLEN
andthesftpprogramhasa32KBbuﬀerfor DEFAULT_COPY_BUFFER .
Moreover,OpenSSH’s SSHBUF_SIZE_MAX buﬀer fora socketchan-
nelisaslargeas256MB.Theselargebuﬀersallowroomforatt ack-
ers toconstructthedesired cache layout.
4, ,
/* cipher-ctr-mt.c */
...
504:for(i=0;i<CIPHER_THREADS;i++){
......
507: pthread_create(...,
thread_loop,...);
......
509:}/* cipher-ctr-mt.c */
238:static void*
239:thread_loop(void *x) {
......
326: for(i=0;i<KQLEN;i++) {
327: AES_encrypt(q->ctr,
q->keys[i],&key);
......
Figure7: Concurrency-relatedcodein HPN-SSH[ 2].
Wehavefoundasimilarscenariointheopen-sourceimplemen -
tationofHPN-SSH [ 2],whichisanenhancement ofOpenSSH[ 5]
by leveraging multi-threading to accelerate the data encry ption.
Figure7showsthecodesnippetdirectlytakenfromtheHPN-SSH[ 2]
repository: On the left-hand side are threads created to run the
thread_loop function, shown on the right-hand side, which re-
peatedlycalls AES_encrypt toencryptdatagivenbytheuser(line
327). By controlling the size and content of the data, as well as
the number of threads, a malicious user is able to aﬀect both t he
memory layoutand thethread interleaving.
In our experimental evaluation (Section 7), we will show that
the AES subroutine from OpenSSL indeed has cache timing leak s,
whichmaysubjectHPN-SSHtoattackscenariossimilartothe one
illustratedin Figure 6.
4 ADVERSARIAL SYMBOLIC EXECUTION
We ﬁrst present the baseline algorithm for concurrent progr ams.
Then, weenhance it tosearch for cachetiming leaks.
4.1 The BaselineAlgorithm
FollowingGuoetal.[ 40],weassumetheentireprogramconsistsof
aﬁniteset{T1,...,Tn}ofthreadswhereeachthread Ti(1≤i≤n)
is a sequential program. Withoutloss of generality, we assu meT1
is critical and any of T2,...,Tnmay be adversarial. Let stbe an
instruction in a thread. Let evente=/an}bracketle{ttid,l,st,l′/an}bracketri}htbe an instance
ofst,wherelandl′arethread-locallocationsbeforeandafterexe-
cutingst.Agloballocation is atuple s=/an}bracketle{tl1,...,ln/an}bracketri}htwhere each li
isalocationin Ti.Dependingonthetypeof st,anevent mayhave
one ofthefollowingtypes:
•α-event, which is an assignment /v.altl:=explwhere/v.altlis a
localvariableand explis anexpression in localvariables.
•β-event,whichisalocalbranchdenoted assume(condl)where
thecondition condlis expressed in localvariables.
•γ-event, which is a loadfrom global memory of the form
/v.altl:=/v.alt/afii10069.ital, astoretoglobal memory of the form /v.alt/afii10069.ital:=expl,
ora thread synchronization operation.
Foranif(c)-else statement,weuse assume(c)todenotethethen-
branch, and assume(¬c)to denote the else-branch. Since cis ex-
pressedinlocalvariablesorlocalcopiesofglobalvariabl es,β-events
are local branching points whereas γ-events are thread interleav-
ing points. Both β- andγ-events contribute to the state-space ex-
plosionproblem.Incontrast, α-eventsarelocaltotheirownthreads.
Detailsonhandlingoflanguagefeaturessuchaspointersan dfunc-
tion calls are omitted, since they are orthogonal issues add ressed
byexisting symbolicexecutiontools[ 20,26].
Algorithm 1shows the baseline symbolic execution procedure
thatfollowsthepriorwork[ 14,26,40]exceptthat,forthepurpose
ofdetectingtimingleaks,itconsiderstwoeventsas dependent also
when they are mappedtothe same cacheline. Here, anexecutio n
ischaracterizedby π=(in,sch)wherein={k,x}isthedatainputandschis the thread schedule, corresponding to a total order of
eventse1...en, andStackis a container for symbolic states. Each
s∈Stackisatuple/an}bracketle{tM,pcon,branch,enabled,crt/an}bracketri}ht,whereMisthe
symbolic memory, pconis the path condition, branchis the set of
branching ( β) events,enabledis the set of thread interleaving ( γ)
events, and crtis theevent chosen toexecuteat s.
Algorithm 1: Baseline SymbolicExecutionProcedure.
Initially:State stack Stack=∅;
StartS/y.sc/m.scSC(s0)with the initial symbolicstate s0.
1S/y.sc/m.scSC(States)
2begin
3Stack.push(s);
4ifsisa thread-local branchingpoint then
5 fort∈s.branch ands.pcon∧tissatisﬁable do
6 S/y.sc/m.scSC(NextSymbolicState (s,t));//βevent
7 end
8else ifsisa thread interleaving point then
9 fort∈s.enabled do
10 S/y.sc/m.scSC(NextSymbolicState (s,t));//γevent(enhanced)
11 end
12else ifsisother sequential computation then
13 S/y.sc/m.scSC(NextSymbolicState (s,s.crt));//αevent
14else
15 terminate at s;
16end
17Stack.pop();
18end
19NextSymbolicState (States,Eventt)
20begin
21s.crt←t;
22s′←Execute the event tinthe state s;
23returns′;
24end
Atthebeginning, thestack is emptyand theentry is theiniti al
states0.Then,dependingonthetypeofthestate s,wemayexecute
alocalbranch(line4),performacontextswitch(line8),or execute
a sequential computation (line 12). In all cases, S/y.sc/m.scSCis invoked
again onthenew state.
Sub-procedure NextSymbolicState takes the current state sand
to-be-executed event tas input, and returns the new state s′as
output:s′is the result of executing tats. We omit details since
theyareconsistentwithexistingsymbolicexecutionmetho ds[39–
41,66,67].
Also notethat, in theprior work, symbolic execution woulda l-
lowinterleavings betweenglobal( γ)events onlyif theyhave data
conﬂicts, i.e., they are from diﬀerent threads, accessing the same
memory location, and at least one of them is a write. This is be -
cause only such accesses may lead to diﬀerent states if they a re
executed in diﬀerent orders. However, in our case, whether t hese
events are mappedtothesame cacheline alsomatters.
4.2 Enhanced Algorithm
WeenhancethebaselinealgorithmtoarriveatAlgorithm 2,where
themaindiﬀerenceisintheinterleavingpoints.Uponenter ingthe
for-loop at line 5, we ﬁrst check if an enabled event tmay lead to
a timing leak by invoking DivergentCacheBehavior(s,t) . Details of
thesubroutinewillbepresented inSection 5,butatthehigh level,
it constructs a cache behavior constraint τtand then searches for
twovalues, k1andk2, suchthat τt(k1)/nequalτt(k2).
Sincedetectingsuchdivergentbehaviorsiscomputational lyex-
pensive,priortoinvokingthesubroutine,wemakesurethat event
tindeed may be involved in an adversarial interleaving. This is
determined by AdversarialAccess(s,t) which checks if (1) tcomes
5,, Shengjian Guo,Meng Wu, andChaoWang
from the critical thread T1and (2) there exists a previously exe-
cutedevent t′=s′.crtwheres′∈Stackand thetwoevents ( tand
t′)are mappedtothesame cacheline.
Algorithm 2: Symbolic Executionin S/y.sc/m.scSC
Initially: State stack Stack=∅;
StartS/y.sc/m.scSC(s0)with the initialsymbolicstate s0.
1S/y.sc/m.scSC(States)
2begin
3......
4else ifsisa global-memoryaccesspoint then
5 fort∈s.enableddo
6 ifDivergentCacheBehavior( s,t)then
7 generate testcase;
8 terminateat s;
9 else
10 S/y.sc/m.scSC(NextSymbolicState (s,t));
11 end
12 end
13......
14end
15
16DivergentCacheBehavior (States,Eventt)
17begin
18ifAdversarialAccess( s,t)then
19 τt←computet’s cachehit constraint;
20 if∃k,k′suchthatτt(k)/nequalτt(k′)then
21 returntrue;
22end
23returnfalse;
24end
25
26AdversarialAccess (States, Eventt)
27begin
28iftisfromthe criticalthread then
29 lets′∈Stackandt′=s′.crt;
30 if∃t′.tandt′maymap tosamecache line then
31 returntrue;
32returnfalse;
33end
ForourrunningexampleinFigure 4,inparticular,Algorithm 2
wouldexploretheﬁrstthreeinterleavingsinTable 1beforedetect-
ingtheleak.TheprocessispartiallyillustratedbyFigure 8,where
eventst1:load q[255-k] ,t2:load p[k] andt3:store p[k] belong
tothread T1whereast4:load tmp belongs tothread T2.
AssumeT1executest1toreacht2andT2is aboutto execute t4:
thiscorrespondstotheﬁgureontheleft.Atthismoment, s.enabled
= {t2,t4}.Ift4isexecutedbefore t2,AdversarialAccess( s,t2)would
evaluatetotruebecause t2comesfromthecriticalthreadand p[k]
maybemappedtothesamecachelineas tmpaccessedby t4.How-
ever, there is no timing leak at t2, because p[k]diﬀers from t1’s
accessq[255-k] , meaning the cache behavior at t2remains the
same forallvalues of k.
Ift2wereexecutedbefore t4,wewouldhavethesecondscenario
in Figure 8. At this moment, s.enabled = {t3,t4}. Ift4is executed
aftert3,theinterleavingwouldbe 6-9-11-13 ,whichdoesnothave
timing leaks either. But if t4were executed before t3, we would
have the third scenario in Figure 8, whereAdversarialAccess( s,t3)
evaluates to true, τt3(k)evaluates to falsefor (k=1) but to truefor
(k/nequal1)∧(k≤127), as shown in Table 2, leading to divergent cache
behaviors in 6-9-13-11 .
5 ADVERSARIAL CACHE ANALYSIS
Our method for detecting divergent cache behaviors is as fol lows.
First, it constructs the behavioral constraint for each mem ory ac-
cess. Then, it solves the constraint to compute a pair of sens itive
values that allowtheconstraint toreturndivergent result s.p[k]p[k]q[255-k]T1
tmpT2
p[k]p[k]q[255-k]T1
tmpT2
p[k]p[k]q[255-k]T1
tmpT2
Figure8: The threeinterleavingsgeneratedby S/y.sc/m.scSC.
5.1 Cache Modeling
Recall that the entire program contains T1andT2, among other
threads, where T1invokes the critical computation and T2is po-
tentiallyadversarial. During symbolicexecution, S/y.sc/m.scSCconducts
contextswitcheswhen loadorstoreinstructionsmaybemapped
tothesame cache line. Here, each interleaving pcorresponds to a
data input inand a thread schedule sch.The data input is divided
further into in={k,x}, wherekis sensitive (secret) and xis non-
sensitive (public). Whenever the value of xis immaterial, we as-
sumein={k}.
•Aninterleaving pisasequenceofmemoryaccessesdenoted
p(sch,in) ={A1,...,An}whereschrepresents the order of
theseaccesses and inrepresents thedata input.
•EachAi,wherei∈[0,n],denotes a memoryaccess.
•pconi(k)is thepath conditionunderwhich Aiis reached.
Thus,when pconi(k)istrue,meaning Aiisreachable,wecheck
ifAicanlead toacache hit:
•τi(k)denotestheconditionunderwhich Aitriggersacache
hit.
•addridenotes thememoryaddress accessed by Ai.
•ta/afii10069.ital(addr)is a functionthatreturns theunique ta/afii10069.italofaddr.
•line(addr)is a functionthatreturns thecache lineof addr.
Thus,we deﬁnethe cache-hitcondition as follows:
τi(k)≡/logicalordisplay.1
0≤j<i/parenleftBig
ta/afii10069.ital(addrj)=ta/afii10069.ital(addri)∧
∀l∈[j+1,i−1]/barex/barexline(addrl)/nequalline(addri)/parenrightBig
(1)
For each memory access Ai,S/y.sc/m.scSCtraverses the preceding mem-
oryaccesses intheinterleaving pto seeif any such Ajmay result
inAibeingacachehit.Thisisdonebycomparingthetagof addri
tothatof addrj—ahitispossibleonlywhentwotagsarethesame.
Furthermore, any other memory access ( Al) between AiandAj
mustnot evict thecache line occupiedby Aj(and hence Ai). This
means, forall j<l<i,wehave line(addrl)/nequalline(addri).
IfAialways causes a cache hit, or a miss, it cannot leak sen-
sitive information because it implies ∀k1,k2.τi(k1)=τi(k2). In
contrast, if τi(k)evaluates to truefor some value of kbut tofalse
fora diﬀerent valueof k,then itis a leak.
5.2 Leakage Detection
After constructing τi(k), which is the cache-hit condition for a po-
tentially adversarial memory access Ai, we instantiate the sym-
bolicexpressiontwice,ﬁrstwithafresh variable k1andthenwith
6, ,
Table 2: Cache-relatedinformation of interleaving p.
#line ipconiaddri τi cache
60k≤127q[255-k] false miss
91k≤127p[k] ta/afii10069.ital(p[k])=ta/afii10069.ital(q[255−k])miss
13 k≤127tmpta/afii10069.ital(tmp)=ta/afii10069.ital(p[k])∨
2/parenleftbigta/afii10069.ital(tmp)=ta/afii10069.ital(q[255−k])miss
∧line(tmp)/nequalline(p[k])/parenrightbig
11 k≤127p[k]ta/afii10069.ital(p[k])=ta/afii10069.ital(tmp)∨ miss
3/parenleftbigta/afii10069.ital(p[k])=ta/afii10069.ital(p[k]) or
∧line(p[k])/nequalline(tmp)/parenrightbighit
another fresh variable k2. We use an oﬀ-the-shelf SMT solver to
search forvaluesof k1andk2thatcanleadtodivergent behaviors.
Precise Solution. Thepreciseformulationis as follows:
∃k1,k2.(k1/nequalk2)∧τi(k1)/nequalτi(k2) (2)
Weneed toconductthis check at every memory access Ai,where
i∈[0,n], along the symbolic execution path p. If the above for-
mula is satisﬁable, the SMT solver will return values k1andk2of
variables k1andk2,respectively.
Two-Step Approximation. Since computing both values at the
same timeis expensive, in practice,wecantake twosteps:
•First, solve subformula ∃k1.τi(k1)to compute a concrete
valuefor k1,denoted k1.
•Second, solve subformula ∃k2.(k1/nequalk2)∧τi(k1)/nequalτi(k2)
tocomputea concrete value k2fork2.
Sincetheformulasolvedineachstepis(almosttwice)small er,the
solving timecan bereducedsigniﬁcantly. Furthermore, a va lid so-
lution(k1andk2) is guaranteed tobea valid solutionfor the orig-
inal formula as well. However, in general, the two-step appr oach
is an under-approximation: when it fails to ﬁnd any solution , it is
not a proofthat nosuch solutionexists.
To make the two-step approach precise, one would have to ap-
ply it repeatedly, each time with a diﬀerent k1computed in the
ﬁrststep,untilallsolutionsof k1iscovered.Nevertheless,weshall
show throughexperiments that,inpractice,applyingitonc eis of-
ten accurateenough todetecttheactualleak.
5.3 The RunningExample
We revisit the example in Figure 4to show how our approach de-
tectsthe leak.Recall that S/y.sc/m.scSCwouldgenerate thesix interleav-
ingsshowninTable 1.Foreachinterleaving,Table 2showstheline
number (#line) of every access Ai, path condition pconi, memory
addressaddri, and thecache-hit constraint τi.
Inside the interleaving 6-9-13-11 , for instance, uponreaching
theloadofq[255-k] at line 6, the path condition would be ( k≤
127). Since it is the ﬁrst memory access, τ0must befalse(cache
miss). Wewill recordthis memoryaddress for furtheranalys is.
Nextisthe loadofp[k]atline9.S/y.sc/m.scSCbuildsτ1andchecksits
satisﬁability. Since p[k]and the preceding q[255-k] correspond
to diﬀerent memory addresses, the ta/afii10069.italcomparison in τ1returns
false, indicating a cache miss. The loadat line 13 accesses tmp.
Sincetmpis diﬀerent from any of the elements in arrays pandq,
theta/afii10069.italcomparisons in τ2returnfalse, making A2a cachemiss.
Similarly, τ3forthestoreatline 11is showninthelastrow of
Table2.Itisworthmentioningthat τ3onlycompares p[k](addr3)1uint8_t SBOX1[64]={0x6f,0x3c,0x77,0xb7,0x2f,0x7b,0x5 f,0xc6, ...};
2uint8_t SBOX2[64]={0x3d,0x4c,0x5f,0xb6,0xd1,0xff,0x3 e,0xed, ...};
3voidencrypt(uint8_t *block){
4for(uint8_t i = 0; i < 64; i++){
5 block[i] |= SBOX1[block[i]];
6 block[i] ^= SBOX2[block[i]];
7}
8}
Figure9: Examplecodefor accessingS-Box lookuptables.
withtmp(addr2) andp[k](addr1) but not q[255-k] (addr0) be-
causeS/y.sc/m.scSCﬁndsthat,iftheaccessto tmpdoesnotevictthecache
lineusedbyitsprecedingaccess to p[k](addr1),thelast storeto
p[k](addr3)mustbeacachehit; S/y.sc/m.scSCstopsheretoavoidfurther
(and unnecessary) analysis.
Diﬀering from τ0,τ1andτ2,theconstraint τ3depends on kdue
to the constraint line(p[k])/nequalline(tmp).Speciﬁcally, τ3(k)istrue
when(k!=1∧k≤127) and isfalsewhen (k=1).
InS/y.sc/m.scSC, two symbolic variables k1,k2will be used to substi-
tutekinthesymbolicexpressionof τ3(k),toformτ3(k1)andτ3(k2).
Solving the satisﬁability problem described by τ3(k1)XOR τ3(k2)
wouldproducetheassignment {k1=0andk2=1},whichmakes τ3(0)
evaluateto trueandτ3(1)evaluate to false.
6 OPTIMIZATIONS
Symbolicexecution,whenapplieddirectlytocipherprogra ms,may
have a high computational overhead because of the heavy use o f
arithmetic computationsand look-uptables in these progra ms. In
this section,wepresent techniques forreducingtheoverhe ad.
Toward this end, we have two insights. First, when conductin g
cache analysis, we are not concerned with the actual numeric al
computationsinside the cipher unless they aﬀect the addres ses of
memoryaccessesthatmaydependonsensitivedata,e.g.,ind icesof
lookuptablessuchasS-Boxes.Second,forthepurposeofdet ecting
leaks, as opposed to proving their absence, we are free to und er-
approximateas long as it does not diminish the leak-detecti on ca-
pabilityof ouranalysis.
6.1 Domain-speciﬁc Reduction
By studying real-world cipher programs, we have found the co m-
putational overhead is often associated with symbolic indi ces of
lookuptablessuch as theoneshownin Figure 9.
Here,blockpoints to a 8-byte storage area whose content de-
pends on the cryptographic key; thus, the eight bytes are ini tial-
izedwithsymbolicvalues.Accordingly,indicestotheS-Bo xtables
–block[i] at line 4 – are symbolic. However, not all memory ac-
cesses should be treated as symbolic. For example, the addre ss of
block[i] itself,andtheaddressoflocalvariablessuchas ishould
be treated as concrete values to reduce the cost of symbolic e xe-
cution. Therefore, we conduct a static analysis of the inter leaved
executiontrace ptoidentifythesequenceofmemoryaccessesthat
needtobekeptsymbolicwhileavoidingthesymbolicexpress ions
ofotherunnecessary memoryaddresses.
Also,aprogrammayhavemultipleS-Boxarrays,like SBOX1and
SBOX2inFigure 9.Twosuccessiveaccessesto SBOX1andSBOX2(at
lines 5 and 6) cannot form a cache hit no matter what the lookup
indicesare.Therefore,wedonotneedtoinvoketheSMTsolve rto
7,, Shengjian Guo,Meng Wu, andChaoWang
checktheequivalenceofthesesymbolicaddresses.Thiscan signif-
icantly cutdowntheconstraint-solving time.
6.2 Layout-directed Reduction
Anotherreductionisguidedbythememorylayout.InLLVM,me m-
orylayout maybeextracted fromthe compilerback-end after the
code generation step. Recall that when analyzing a pair of po ten-
tiallyadversarialaddresses,weneedtocomparethemwitha llother
addresses accessed betweenthemtobuildthecachebehavior con-
straint. More speciﬁcally, to check if A2is a cache hit because of
A1along the execution A1−B1−,...,−Bn−A2, we need to check
if anyBi(1≤i≤n)couldevict thecache line used by A1. Dueto
the large value of nand often complex symbolic expression of Bi,
theconstraint-solving timecouldbelarge.
Ourapproachinthiscaseistodirectlycompare A1andA2while
postponingthecomparisonsto Bi.Thisisbasedontheobservation
that,inpractice,thecachelineof A1canpossiblybeevictedby Bi
only if the diﬀerences between their addresses is the multip le of
the cache size (e.g., 64KB), which may not be possiblein comp act
cipherprograms.Forexample,ina64KBdirect-mappedcache ,for
B1toevictthe64-bytecachelineof A1,theiraddressdiﬀerencehas
to be216=64KB. In a 4-way set-associative cache, their address
diﬀerence hastobe 214=16KB.Furthermore,intheevent that A2
has a cache hit due to A1, we can add back the initially-omitted
comparisons to B1,...,Bntoundotheapproximation.
7 EXPERIMENTS
We have implemented S/y.sc/m.scSCusing the LLVM compiler [ 48] and
Cloud9[18],whichisasymbolicexecutionengineformultithreaded
programs built upon KLEE [ 20]. We enhanced Cloud9in three as-
pects.First, we extended its supportfor multi-threading b y allow-
ing context switches prior to accessing global memory; the o rigi-
nalCloud9only allows context switches prior to executing a syn-
chronizationprimitive(e.g.,lock/unlock).Second,wema deCloud9
fork new states to ﬂip the execution order of two simultaneou sly
enabled events when they maybemappedtothesame cacheline;
theoriginal Cloud9doesnotcareaboutcachelines.Third,wemade
Cloud9recordtheaddressofeachmemoryaccessalongtheexecu-
tion, so it can incrementally build the cache-hit constrain t. Based
on these enhancements, we implemented our cache timing leak
detectorand optimizeditforeﬃcient constraint solving.
AftercompilingtheCcodeofaprogramtoLLVMbit-code,our
S/y.sc/m.scSCtool executes it symbolically to generate interleavings ac -
cording to Algorithm 2. The cache constraint at each memory ac-
cessisexpressedinstandardKQueryexpressionsdeﬁnedinK LEE[20].
By solving these constraints, we can obtain a concrete execu tion
that showcases the leak, including a thread schedule, two in put
valuesk1,k2and theadversarial memoryaddress.
7.1 Benchmarks
We evaluated S/y.sc/m.scSCon a diverse set of open-source cipher pro-
grams. Speciﬁcally,the ﬁrst group has ﬁve programs from a li ght-
weight cryptographic system named FELICS[29], which was de-
signedforresource-constraineddevices.Thesecondgroup hasfour
programs from Chronos[27], a real-time Linux kernel. The third
grouphasfourprogramsfromtheGNUlibrary Libgcrypt [3],while
theremainingprogramsarefromthe LibTomCrypt [4],theOpenSSL[6],
and a recent publication [ 21]. They include multiple versions ofTable3: Benchmarkstatistics:linesofCcode(LOC)andLLVMcode
(LL), sensitive key-size (KS), andthememory accesses (MA) .
Name LOC LLKSMAName LOC LLKSMA
AES[6] 1,4294,38424771FCrypt[27]4371,62312428
AES[27]1,3684,14424788KV_name[21]1,3501,402 419
Camellia [4]7765,319161,301LBlock[29]9304,010101,618
CAST5[4]7352,79016909Misty1[1]3911,19916270
CAST5[27]8834,190161,180Piccolo[29]3011,03412350
Chaskey[29]24863816242PRESENT[29]1942721094
DES[3] 5962,166 8963rfc2268[3]38887016149
DES[27]1,0103,926 81,029Seed[3] 6073,53516979
Kasumi[1]350122416259TWINE[29]25656210229
Khazad[27]83846316123Twofish[3]1,0484,510161,180
several well-known algorithmssuchas AES[6,27]andDES[3,27],
which are useful in evaluating the impact of cipher implemen ta-
tionsontheperformanceof S/y.sc/m.scSC.
Table3shows the statistics of these benchmark programs. The
LOCandLLcolumns denote the lines of C code and the corre-
spondingLLVMbit-code.The KScolumnshowsthesizeofthesen-
sitive input in bytes. The maximum number of memory accesses
onprogrampathsofeachbenchmarkisshowninthe MAcolumn,
which indicates thecomputationalcostof theprogram.
Eachprograminthebenchmarksuitehasfrom194to1,429line s
ofCcode.Intotal,thereare14,455lines ofC code,which com pile
to 49,048 lines of LLVM bit-code. These numbers are consider ed
substantial because ciphers are typically compact program s with
highly computation-intensive operations, e.g., due to the ir use of
loops and lookup-table based transformations. For example , the
program named PRESENT has only 194 lines of C code but 8,233
memoryaccesses atruntime.
Weanalyzedthesebenchmarkprogramsusingtwotypesofcach es:
direct-mappedcacheandfour-wayset-associativecache.T hecache
sizeis64KBwitheachcachelineconsistingof64bytes;thus ,there
are64KB/64B= 1024cache lines, which aretypical inmainstr eam
computerstoday.
Ourexperiments were designed toanswer two questions:
•CanS/y.sc/m.scSCdetect cache-timing leaks exposed by concur-
rently running a programwith otherthreads?
•Aretheoptimizations inSection 6eﬀective in reducingthe
costof symbolicexecutionand constraint solving?
WeconductedallexperimentswithUbuntu12.04Linuxrunnin gon
acomputerwitha3.40GHzCPUand8GBRAM.Forallevaluations
weset thetimeoutthreshold to1,600minutes.
7.2 Results Obtained withFixed Addresses
Table4shows our results obtained using ﬁxed addresses in the
cache layout (Case 1 in Section 2.3). The ﬁrst column shows the
benchmarkname.Thenextthreecolumnsshowtheresultofcom -
putingtheprecisesolutionforourcacheanalysisproblem. Thelast
threecolumnsshow theresultofrunning thesimpliﬁed,two- step
version,wherethesolutionfor ∃k1,k2.τ(k1)/nequalτ(k2)iscomputed
intwosteps,byﬁrstcomputingavalueof k1andthencomputinga
valueofk2.Ineach method,weshowthenumber ofinterleavings
explored(#.Inter), the number of leaky memory accesses det ected
(#.Test),andtheexecutiontimeinminutes(m).Forthetwo- stepap-
proach,we alsoshow thenumber of leakage points detectedaf ter
theﬁrststepand after thesecond step.
Among these twenty programs, we detected leakage points in
four:ASEfromOpenSSL [6],DESfromLibgcrypt [3],FCryptfrom
8, ,
Table4:Resultsofleakdetectionwith ﬁxedaddresses:Isthe
program leakyw.r.t.the giventhread?
NamePrecise Two-Step
#.Inter #.Test Time(m) #.Inter#.TestTime(m)step1/ step2
AES[6] 5755 430.2 5755/ 55 140.3
AES[27] 10 288.9 11/ 0 41.4
Camellia[ 4] 10 0.1 11/ 0 0.1
CAST5[4] 10 0.1 11/ 0 0.1
CAST5[27] 10 0.1 11/ 0 0.1
Chaskey[ 29] 10 0.1 11/ 0 0.1
DES[3] 1615 7.8 1616/ 15 3.5
DES[27] 10 0.1 11/ 0 0.1
FCrypt[27] 1615 4.1 1615/ 15 8.1
Kasumi[1] 10 0.1 11/ 0 0.2
Khazad[27] 2523 206.5 2523/ 23 83.0
KV_Name[ 21] 1406 0 0.51406 1406/ 0 0.4
LBlock[29] 10 0.1 11/ 0 0.1
Misty1[1] 10 0.1 11/ 0 0.1
Piccolo[29] 10 0.1 11/ 0 0.1
PRESENT[ 29] 10 0.1 11/ 0 0.1
rfc2268[3] 10 0.1 11/ 0 0.1
Seed[3] 10 0.1 11/ 0 0.1
TWINE[29] 10 0.1 11/ 0 0.1
Twoﬁsh[3] 10 0.1 11/ 0 0.2
Chronos[27],andKhazadfromChronos[27].Wemanuallyinspected
these four programs in a way similar to what is described in Se c-
tion3.2, and conﬁrmed that all these leakage points are realistic.
Furthermore,ourtwo-stepapproachreturnedexactlythesa mere-
sults as the precise analysis for all benchmark programs, bu t in
signiﬁcantly less time.
We alsoconductedourexperiments using 4-way set-associative
cache instead of direct-mapped cache. The results of these exper-
iments are similar to the ones reported in Table 4. Therefore, we
omit themfor brevity.
Nevertheless, the similarity is expected. For example, a 10 24-
byteS-Boxwouldbemappedto16consecutivecachelinesin directed-
mappedcacheaswellas 4-wayset-associative cache,providedthat
thecachesizeis 64KBand thelinesizeis 64-byte.Theonlymi nor
diﬀerence is that, in the 4-way set-associative cache, we need four
adversarial memoryaccesses from thread T2to fullyevict a cache
set. But if we have already detected the ﬁrst adversarial add ress
(sayaddr), the remaining three could simply be addr+cache_size ,
addr+2*cache_size ,andaddr+3*cache_size .Thus,thereisnosignif-
icant diﬀerence fromanalyzing direct-mapped cache.
7.3 ResultsObtained withSymbolicAddresses
The results shown in Table 4are useful, but also somewhat con-
servative. A more aggressive analysis is to assume the adversarial
threadT2mayaccess memoryregions whosecachelayoutis sym-
bolic(refer toCase 2in Section 2.3).
Table5shows the experimental results obtained using direct-
mappedcache and symbolic addresses in thread T2(Case 2 in Sec-
tion2.3).Theﬁrsttwocolumnsshowthebenchmarknameandthe
maximum number of memoryaddresses accessed by an interleav -
ingatruntime.The Precisecolumnshowstheresultofcomputing
the precise solutionforour cache analysis problem.The Two-Step
columnshowstheresultofrunningthesimpliﬁedversion.In both
cases,wereportthetotalnumberofinterleavingsexplored bysym-
bolicexecution(#.Inter),thenumberofleakymemoryacces sesde-
tected (#.Test), and the total execution time in minutes (m) . For
Two-Step,thenumberofleakyaccesses isfurtherdividedintotwoTable5:Resultsofleakdetectionwith symbolic addresses:Is
thegivenprogram leakyw.r.t. anyadversarialthread?
Name #.AccPrecise Two-Step
#.Inter #.TestTime(m) #.Inter#.TestTime(m)step1/ step2
AES[6] 1,026 224220 1016.4 224220/ 220 237.5
AES[27] 2,568 141139 >1600 256302/ 254 548.3
Camellia[ 4]2,590 176172 830.8 176172/ 172 303.5
CAST5[4]1,815 167164 >1600 384381/ 381 1337.4
CAST5[27]1,392 183180 >1600 384381/ 381 1392.5
Chaskey[ 29]1,380 10 0.1 11/ 0 0.1
DES[3] 2,135 144127 38.6 144164/ 127 27.2
DES[27] 2,539 119114 >1600 194187/ 183 1191.5
FCrypt[27] 428 6460 15.1 6460/ 60 20.1
Kasumi[1]1,785 8382 >1600 9694/ 94 151.9
Khazad[27] 684 114103 >1600 248254/ 240 165.3
KV_Name[ 21]1401406 0 0.51406 1406/ 0 0.5
LBlock[29]4,068 10 0.1 11/ 0 0.1
Misty1[1] 2,966 7675 >1600 9694/ 94 265.1
Piccolo[29]5,103 10 0.1 11/ 0 0.1
PRESENT[ 29]8,233 10 0.2 11/ 0 0.2
rfc2268[3]3,190 113112 303.4 113112/ 112 42.9
Seed[3] 1,632 201197 >1600 320316/ 316 1505.1
TWINE[29]10,492 10 0.1 11/ 0 0.1
Twoﬁsh[3]12,400 2514 84 >1600 90084,063/76 >1600
subcolumns:theleakyaccessesdetectedaftertheﬁrststep andthe
leakyaccesses detectedafter thesecondstep.
The results show that, for most of the benchmark programs,
the overhead of precisely solving our cache analysis is too h igh:
on nine of the twenty programs, it could not complete within t he
timelimit.Incontrast,ourtwo-stepanalysis wasabletoco mplete
nineteen out of the twenty programs. In terms of accuracy, ou r
two-stepapproachisalmostasgoodaspreciseanalysis:ina llcom-
pletedprograms,theydetectedthesamenumberofleakagepo ints,
which indicate a possible combination of adversarial threa ds and
memorylayoutthat cantrigger timingleaks.
Our results also show that, for the same type of cryptographi c
algorithms (such as AES), diﬀerent implementations may lea d to
drastically diﬀerent overhead. For example, we detected 34 more
leakagepointsinthe AESimplementationof Chronos[27]thanthat
ofOpenSSL[6].However, the AESofChronostookalmosttwiceas
long for our tool to analyze. For DESthe implementations from
Libgcrypt [3] andChronos[27], we detected a slightly diﬀerent
numberofleakagepoints,butthetimetakenissigniﬁcantly diﬀer-
ent (27.1 minutes versus 1191.5 minutes). In contrast, for t he two
versionsof CAST5,wedetectedthesamenumberofleakagepoints
inroughlythesameamount oftime.
Forthebenchmarkwhere Two-Step tookalongtime,wefoundit
isduetotheincreasing sizeofsymbolicconstraintswhichc onsist
of the addresses in S-Box accesses. Typically the later a S-B ox ac-
cessinaloop,thelargeritssymbolicaddressexpressionwo uldbe.
InTwofish,S/y.sc/m.scSCtimedoutbecauseitencounteredalargenum-
berof "may-be-related" event pairs (i.e., accessing thesa meS-Box
butnot thesamecache line), which madeSMTsolving diﬃcult.
7.4 Discussion
Basedontheresults,weanswer thetworesearch questions as fol-
lows.First, S/y.sc/m.scSCis abletoidentifycachetiming leaksinconcur-
rentprogramsautomatically.Speciﬁcally,using symbolicaddresses
in the adversarial thread allows us to demonstrate the possi bility
oftriggeringleaksinaconcurrentsystem,whereasusing ﬁxedad-
dresses in theanalysis allows ustoshowthatsuch leaks arem ore
9,, Shengjian Guo,Meng Wu, andChaoWang
practical. Second, S/y.sc/m.scSC’s performance optimization techniques
areeﬀectiveinreducingthecomputationaloverhead,which isdemon-
stratedona diverse set ofreal-world cipher programs.
S/y.sc/m.scSCsearches for sensitive inputs as well as an interleaving
schedule that, together, trigger divergent cache behavior s. If an
individual program path has a constant cache behavior, e.g. , all
the memory accesses refer to ﬁxed memory addresses regardle ss
of the value of the sensitive input, then timing leaks are imp ossi-
ble. By checking for and leveraging such conditions, S/y.sc/m.scSCcan
reducethecomputationcostevenfurther.Forinstance,wit hnaive
exploration, S/y.sc/m.scSCwould have generated 1,406 interleavings for
thebenchmarkprogramnamed KV_name.However,withtheabove
analysis, it doesnothave togenerate any interleaving.
In this example, KV_name’s 4-byte symbolic input only aﬀects
the branch conditions but does not taint any memory access ad -
dress.Thus,manypathsareexploredbysymbolicexecution. How-
ever, noleak is detectedonthese paths.
Another exampleis Chaskey, which has a single programpath,
togetherwith1,380memoryaccesses onthispath.Thesememo ry
addressesareallindependentofthe16-Bytesymbolicinput ,which
means no leakage pointcanbefound by S/y.sc/m.scSC.
8 RELATED WORK
Side-channel leaks have been exploited in a wide range of sys -
tems [28,36–38,43–45,51,54,57]. For timing side channels, in
particular,manyanalysisandveriﬁcationtechniqueshave beende-
veloped.Forexample,Chenetal.[ 23]proposedatechniquenamed
Cartesian Hoare Logic [ 58] for proving that the timing leaks of a
program are bounded. Antonopoulos et al. [ 8] proposed a similar
method for proving the absence of timing channels: it partit ions
theprogrampathsinawaythat,ifindividualpartitionsare proved
to be timing attack resilient, the entire program is also tim ing at-
tack resilient. However, these methods only consider instruction-
inducedtiming whileignoring thecache.
In the context of analyzing real-time systems, there is a lar ge
body of work on cache analysis [ 49,50,52], with the goal of esti-
matingtheworst-caseexecutiontime(WCET).Varioustechn iques
includingabstractinterpretation[ 61],symbolicexecution[ 12,21],
andinterpolation[ 25]havebeenusedtocomputetheupperbound
ofexecutiontimealongallprogrampaths.Chattopadhyayet al.[22]
also developed CHALICE to quantify information leaked through
thecachesidechannel,butthefocuswasondependenciesbet ween
sensitive data and misses/hits ontheCPU’s data cache.
Doychev et al. [ 30] developed CacheAudit , a toolrelying on ab-
stract interpretation based static analysis to analyze cac he timing
leaks. Wang et al. [ 64] developed CacheD, an oﬄine trace analy-
sis tool for detecting key-dependent program points in a cip her
program that may be vulnerable to side channel attacks. Sung et
al. [60] developed CANAL, an LLVM transformation that models
cache timing behaviors for standard veriﬁcation tools. How ever,
these techniques handlesequential programs ortracesonly .
Pasareanu et al. [ 55] developed a symbolic execution tool for
reasoningaboutthedegreeofleakedinformation,assuming theat-
tackercantakemultiplemeasurements. Thetestinputthatc auses
themaximumamountofleakageiscomputedusingMax-SMTsolv -
ing. Bultanetal.[ 10,17,19]developedtechniquesforquantifying
informationleakedbystringoperations.Theirmethodcanh andle
bothsingleandmultipleruns[ 10]:itappliesprobabilisticsymbolic
executiontocollectpath constraints ofa single runand the nusestheseconstraintstocomputetheleakageofmultipleruns.P hanet
al.[56]alsodevelopedasymbolicattackmodelandformulatedthe
problem of test generation to obtain the maximum leakage as a n
optimizationproblem.
However,inalltheseexistingmethods,theprogramisassum ed
tobesequential.Incontrast, S/y.sc/m.scSCfocusesonconcurrency-induced
leaks. Although Bartheet al. [ 11] proposedan abstractinterpreta-
tiontechniquebasedon CacheAudit [30]totrackthecachestateof
a program with concurrent adversary, the adversary is a sepa rate
process (that tries to probe and set the cache states), not a t hread.
Furthermore, users have to provide data inputs and interlea ving
schedules,whereas S/y.sc/m.scSCgenerates them automatically.
Stefanetal.[ 59]proposedaninstruction-basedschedulingmech-
anism in information ﬂow control systems running on a single
CPU,toavoidcachetimingattacksintroducedbyclassictim e-based
schedulers.Therefore, itis asystem-level mitigationtec hnique.In
contrast, S/y.sc/m.scSCfocuses on detecting whether a security-critical
program may leak sensitive information through the timing s ide
channel duetointerference fromother threads.
Our state-space reduction in S/y.sc/m.scSCis related to partial order
reduction (POR) [ 35] in model checking, but with an important
diﬀerence.InclassicPOR[ 9,24,42,47,63,69],onewouldtypically
selectrepresentativeinterleavingsfromequivalencecla sses,which
are deﬁned based on standard data-conﬂict and data-depende nce
relations. However, in S/y.sc/m.scSC, they must be broadened to also in-
clude functionally-independent events that may access the same
cacheline.
So far,S/y.sc/m.scSCfocuses on cases where the adversarial thread
ﬂushesasinglecacheline.Intheterminologyofside-chann elanal-
ysis, this corresponds to ﬁrst-order attacks. If, on the other hand,
the adversarial thread is capable of ﬂushing multiple cache lines,
it may be more likely to trigger timing leaks. Such cases woul d
be called high-order attacks. We leave the analysis of high-order
attacksforfuturework.
Besides leak detection, there are side-channel leak mitiga tion
techniques that can generate countermeasures automatical ly, e.g.,
usingcompiler-likeprogramtransformations[ 7,13,53,65]orSMT
solver based formal veriﬁcation [ 15,32,33,68] and program syn-
thesis [16,31,34,62] techniques. However, none of these emerg-
ingtechniqueswasdesignedfor,orapplicableto,cachetim ingside
channels duetoconcurrency.
9 CONCLUSIONS
Wehavepresentedasymbolicexecutionmethodfordetecting cache
timing leaks in a computation that runs concurrently with an ad-
versarial thread. Our method systematically explores both thread
pathsandtheirinterleavings,andreliesonanSMTsolverto detect
divergent cachebehaviors.Ourexperiments showthatrealc ipher
programs do have concurrency related cache timing leaks, an d al-
though it remains unclear to what extent such leaks are exploited
in practice, our method computes concrete data inputs and in ter-
leaving schedules to demonstrate these leaks are realistic . To the
bestofourknowledge,thisistheﬁrstsymbolicexecutionme thod
fordetectingcachetiming side-channel leaks duetoconcur rency.
10, ,
REFERENCES
[1]Botan.https://botan.randombit.net/ .
[2]High PerformanceSSH/SCP - HPN-SSH .https://www.psc.edu/hpn-ssh .
[3]Libgcrypt .https://gnupg.org/software/libgcrypt/index.html .
[4]LibTomCrypt .http://www.libtom.net/LibTomCrypt/ .
[5]OpenSSH.http://www.openssh.com/ .
[6]OpenSSL.https://github.com/openssl/openssl/tree/OpenSSL_0_9 _7-stable .
[7] Giovanni Agosta, Alessandro Barenghi, and Gerardo Pelo si. A code morphing
methodologytoautomatepoweranalysiscountermeasures.I nACM/IEEEDesign
AutomationConference ,pages77–82, 2012.
[8] Timos Antonopoulos, Paul Gazzillo, Michael Hicks, Eric Koskinen, Tachio Ter-
auchi, and Shiyi Wei. Decomposition instead of self-compos ition for proving
the absence of timing channels. In ACM SIGPLAN Conference on Programming
Language Designand Implementation , pages362–375,2017.
[9] StavrosAronis, Bengt Jonsson, Magnus Lång,and Konstan tinos Sagonas. Opti-
maldynamicpartialorderreductionwithobservers. In InternationalConference
onToolsandAlgorithmsforConstructionandAnalysisofSys tems,pages229–248,
2018.
[10] LucasBang,AbdulbakiAydin,Quoc-SangPhan,CorinaS. Pasareanu,andTevﬁk
Bultan. String analysis for side channels with segmented or acles. In ACM SIG-
SOFTSymposium onFoundations of SoftwareEngineering , pages193–204,2016.
[11] Gilles Barthe, Boris Köpf, Laurent Mauborgne, and Mart ín Ochoa. Leakage re-
silience against concurrent cache attacks. In International Conference on Princi-
ples of Security and Trust ,pages140–158,2014.
[12] Tiyash Basu and Sudipta Chattopadhyay. Testing cache s ide-channel leakage.
InIEEEInternational Conference on Software Testing,Veriﬁc ation and Validation ,
pages51–60,2017.
[13] Ali GalipBayrak,FrancescoRegazzoni,Philip Brisk,F rançois-XavierStandaert,
and Paolo Ienne. A ﬁrst step towards automatic application o f power analysis
countermeasures. In ACM/IEEE Design Automation Conference , pages 230–235,
2011.
[14] Tom Bergan, Dan Grossman, and Luis Ceze. Symbolic execu tion of multi-
threaded programs from arbitrary program contexts. In ACM SIGPLAN Con-
ference on Object Oriented Programming, Systems, Languages , and Applications ,
pages491–506,2014.
[15] Roderick Bloem, Hannes Groß, Rinat Iusupov, Bettina Kö nighofer, Stefan Man-
gard,and Johannes Winter. Formalveriﬁcationofmaskedhar dwareimplemen-
tations in the presence of glitches. In Annual International Conference on the
Theory and Applications of CryptographicTechniques (EURO CRYPT),pages 321–
353,2018.
[16] Arthur Blot, MasakiYamamoto, and Tachio Terauchi. Com positional synthesis
ofleakageresilientprograms.In InternationalConferenceonPrinciplesofSecurity
and Trust ,pages277–297, 2017.
[17] TeganBrennan,SeemantaSaha,andTevﬁkBultan. Symbol icpathcostanalysis
for side-channel detection. In International Conference on Software Engineering ,
pages424–425,2018.
[18] Stefan Bucur, Vlad Ureche, Cristian Zamﬁr, and George C andea. Parallel sym-
bolic execution for automated real-world software testing . InEuropean Confer-
ence onComputer Systems ,pages183–198, 2011.
[19] Tevﬁk Bultan, Fang Yu, Muath Alkhalaf, and Abdulbaki Ay din.String Analysis
forSoftware Veriﬁcationand Security . Springer,2017.
[20] Cristian Cadar, Daniel Dunbar, and Dawson R. Engler. KL EE: unassisted and
automatic generationof high-coveragetests for complexsy stems programs. In
USENIXSymposiumonOperatingSystemsDesignandImplement ation,pages209–
224,2008.
[21] Sudipta Chattopadhyay. Directed automated memory per formance testing. In
International Conference on Tools and Algorithms for Const ruction and Analysis
of Systems ,pages38–55, 2017.
[22] SudiptaChattopadhyay,MoritzBeck,AhmedRezine,and AndreasZeller. Quan-
tifying the information leak in cache attacks via symbolic e xecution. In ACM-
IEEE International Conference on Formal Methods and Models for System Design ,
pages25–35,2017.
[23] Jia Chen, Yu Feng, and Isil Dillig. Precise detection of side-channel vulnerabil-
ities using quantitative cartesian hoare logic. In ACM SIGSAC Conference on
Computerand CommunicationsSecurity , pages875–890,2017.
[24] Lin Cheng, Zijiang Yang, and Chao Wang. Systematic redu ction of GUI test
sequences. In IEEE/ACMInternational Conference On Automated Software E ngi-
neering, pages849–860,2017.
[25] Duc-Hiep Chu, Joxan Jaﬀar, and Rasool Maghareh. Precis e cache timing anal-
ysis via symbolic execution. In IEEE Symposium on Real-Time and Embedded
Technology and Applications , pages293–304, 2016.
[26] LiviuCiortea,CristianZamﬁr,StefanBucur,VitalyCh ipounov,andGeorgeCan-
dea. Cloud9: a software testing service. Operating Systems Review , 43(4):5–10,
2009.
[27] MatthewDellinger,PiyushGaryali,andBinoyRavindra n. Chronoslinux:abest-
eﬀort real-time multiprocessor linux kernel. In ACM/IEEE Design Automation
Conference ,pages474–479, 2011.
[28] Jean-François Dhem, François Koeune, Philippe-Alexa ndre Leroux, Patrick
Mestré,Jean-JacquesQuisquater,andJean-LouisWillems. Apracticalimplemen-
tation of the timing attack. In International Conference on Smart Card Researchand Applications ,pages167–182, 1998.
[29] Daniel Dinu, Yann Le Corre, Dmitry Khovratovich, Léo Pe rrin, Johann
Großschädl, and Alex Biryukov. Triathlon of lightweight bl ock ciphers for the
internet of things. Cryptology ePrint Archive,Report 2015 /209,2015.
[30] GoranDoychev,DominikFeld,BorisKöpf,LaurentMaubo rgne,andJanReineke.
Cacheaudit: A tool for the static analysis of cache side chan nels. In USENIX
Security Symposium ,pages431–446,2013.
[31] Hassan Eldib and Chao Wang. Synthesis of masking counte rmeasures against
sidechannelattacks. In InternationalConferenceonComputerAidedVeriﬁcation ,
pages114–130, 2014.
[32] Hassan Eldib, Chao Wang, and Patrick Schaumont. SMT-ba sed veriﬁcation of
software countermeasures against side-channel attacks. I nInternational Con-
ference on Tools and Algorithms for Construction and Analys is of Systems , pages
62–77, 2014.
[33] Hassan Eldib, Chao Wang, Mostafa Taha, and Patrick Scha umont. QMS: Eval-
uating the side-channel resistance of masked software from source code. In
ACM/IEEEDesignAutomationConference ,pages209:1–6,2014.
[34] HassanEldib,MengWu,andChaoWang. Synthesisoffault -attackcountermea-
suresfor cryptographiccircuits. In International Conference on ComputerAided
Veriﬁcation ,pages343–363,2016.
[35] Cormac Flanagan and Patrice Godefroid. Dynamic partia l-order reduction for
modelcheckingsoftware. In ACMSIGACT-SIGPLANSymposiumonPrinciplesof
ProgrammingLanguages ,pages110–121,2005.
[36] KarineGandolﬁ,ChristopheMourtel,andFrancisOlivi er. Electromagneticanal-
ysis: Concrete results. In International Conference on Cryptographic Hardware
and Embedded Systems ,pages251–261,2001.
[37] Daniel Genkin, Adi Shamir, and Eran Tromer. RSA key extr action via low-
bandwidth acoustic cryptanalysis. In Annual International Cryptology Confer-
ence (CRYPTO) , pages444–461, 2014.
[38] DanielGruss,JulianLettner,FelixSchuster,OlgaOhr imenko,IstvánHaller,and
Manuel Costa. Strong and eﬃcient cache side-channel protec tion using hard-
ware transactional memory. In USENIX Security Symposium , pages 217–233,
2017.
[39] Shengjian Guo, Markus Kusano, and Chao Wang. Conc-iSE: incremental sym-
bolic execution of concurrent software. In IEEE/ACM International Conference
On Automated Software Engineering ,pages531–542,2016.
[40] ShengjianGuo,MarkusKusano,ChaoWang,ZijiangYang, andAartiGupta. As-
sertionguidedsymbolicexecutionofmultithreadedprogra ms.InACMSIGSOFT
Symposium on Foundationsof Software Engineering ,pages854–865, 2015.
[41] Shengjian Guo, Meng Wu, and Chao Wang. Symbolic executi on of pro-
grammable logic controller code. In ACM SIGSOFT Symposium on Foundations
of Software Engineering ,2017.
[42] Vineet Kahlon, Chao Wang, and Aarti Gupta. Monotonic pa rtial order reduc-
tion: An optimal symbolic partial order reduction techniqu e. InInternational
Conference onComputer Aided Veriﬁcation ,pages398–413, 2009.
[43] Paul C. Kocher. Timing attacks on implementations of di ﬃe-hellman, rsa, dss,
and other systems. In Annual International Cryptology Conference (CRYPTO) ,
pages104–113, 1996.
[44] Paul C.Kocher, JoshuaJaﬀe,and BenjaminJun. Diﬀerent ialpower analysis. In
Annual International CryptologyConference (CRYPTO) ,pages388–397, 1999.
[45] JingfeiKong,OnurAciiçmez,Jean-PierreSeifert,and HuiyangZhou. Architect-
ing against software cache-based side-channel attacks. IEEE Trans. Computers ,
62(7):1276–1288, 2013.
[46] BorisKöpf,LaurentMauborgne,andMartínOchoa. Autom aticquantiﬁcationof
cacheside-channels. In InternationalConferenceonComputerAided Veriﬁcation ,
pages564–580, 2012.
[47] Markus Kusano and Chao Wang. Assertion guided abstract ion: a cooperative
optimization for dynamic partial order reduction. In IEEE/ACM International
Conference OnAutomated Software Engineering , pages175–186,2014.
[48] ChrisLattnerandVikramS.Adve. LLVM:Acompilationfr ameworkforlifelong
program analysis & transformation. In IEEE/ACM International Symposium on
Code Generationand Optimization ,pages75–88, 2004.
[49] Xianfeng Li, Tulika Mitra, and Abhik Roychoudhury. Acc urate timing analy-
sis by modeling caches, speculation and their interaction. InACM/IEEEDesign
AutomationConference , pages466–471,2003.
[50] YanLi,VivySuhendra,YunLiang,TulikaMitra,andAbhi kRoychoudhury. Tim-
ing analysis of concurrent programs running on shared cache multi-cores. In
IEEEReal-Time SystemsSymposium , pages57–67,2009.
[51] Stefan Mangard, Elisabeth Oswald, and Thomas Popp. Power analysis attacks -
revealing the secretsof smartcards . 2007.
[52] Tulika Mitra, Jürgen Teich, and Lothar Thiele. Time-cr itical systems design: A
survey.IEEEDesign&Test ,35(2):8–26, 2018.
[53] Andrew Moss, Elisabeth Oswald, Dan Page, and Michael Tu nstall. Compiler
assisted masking. In International Conference on Cryptographic Hardware and
Embedded Systems ,pages58–75, 2012.
[54] Elke De Mulder, Thomas Eisenbarth, and Patrick Schaumo nt. Identifying and
eliminating side-channel leaks in programmable systems. IEEE Design & Test ,
35(1):74–89, 2018.
[55] CorinaS. Pasareanu,Quoc-Sang Phan, and PasqualeMala caria. Multi-runside-
channel analysis using symbolic execution and max-smt. In IEEE Computer Se-
curity FoundationsSymposium , pages387–400,2016.
11,, Shengjian Guo,Meng Wu, andChaoWang
[56] Quoc-SangPhan,LucasBang,CorinaS.Pasareanu,Pasqu aleMalacaria,andTev-
ﬁkBultan. Synthesisofadaptiveside-channelattacks.In IEEEComputerSecurity
Foundations Symposium ,pages328–342,2017.
[57] Jean-Jacques Quisquater and David Samyde. ElectroMagnetic Analysis (EMA):
Measuresand Counter-measuresforSmart Cards ,pages200–210. 2001.
[58] MarceloSousaand Isil Dillig. Cartesianhoarelogic fo rverifyingk-safetyprop-
erties. In ACM SIGPLAN Conference on ProgrammingLanguage Design and Im-
plementation , pages57–69, 2016.
[59] Deian Stefan, Pablo Buiras, Edward Z. Yang, Amit Levy, D avid Terei, Alejan-
dro Russo, and David Mazières. Eliminating cache-based tim ing attacks with
instruction-basedscheduling. In European Symposium onResearch in Computer
Security, pages718–735,2013.
[60] ChunghaSung,BrandonPaulsen,andChaoWang.CANAL:Ac achetiminganal-
ysisframeworkvia llvm transformation. In IEEE/ACMInternational Conference
OnAutomated SoftwareEngineering , 2018.
[61] ValentinTouzeau,ClaireMaïza,DavidMonniaux,andJa nReineke.Ascertaining
uncertainty for eﬃcient exact cache analysis. In International Conference on
ComputerAided Veriﬁcation ,pages22–40,2017.
[62] ChaoWangandPatrickSchaumont. Security bycompilati on: anautomated ap-
proach to comprehensive side-channel resistance. ACMSIGLOG News ,4(2):76–
89,2017.
[63] Chao Wang, Zijiang Yang, Vineet Kahlon, and Aarti Gupta . Peephole partial
order reduction. In International Conference on Tools and Algorithms for Con-
structionand Analysisof Systems ,pages382–396,2008.[64] Shuai Wang, Pei Wang, Xiao Liu, Danfeng Zhang, and Dingh ao Wu. CacheD:
Identifying cache-based timing channels in production sof tware. In USENIX
Security Symposium ,pages235–252,2017.
[65] Meng Wu, Shengjian Guo, Patrick Schaumont, and Chao Wan g. Eliminating
timing side-channel leaksusing programrepair. In International Symposium on
Software Testingand Analysis , 2018.
[66] QiupingYi, ZijiangYang,ShengjianGuo,ChaoWang,Jia nLiu,and ChenZhao.
Eliminating path redundancy via postconditioned symbolic execution. IEEE
Trans.SoftwareEng. ,44(1):25–43,2018.
[67] Tingting Yu, Tarannum S. Zaman, and Chao Wang. DESCRY: r eproducing
system-levelconcurrencyfailures. In ACMSIGSOFTSymposiumonFoundations
of Software Engineering ,pages694–704, 2017.
[68] Jun Zhang, Pengfei Gao, Fu Song, and Chao Wang. SCInfer: Reﬁnement-based
veriﬁcationof software countermeasuresagainstside-cha nnel attacks. In Inter-
national Conferenceon ComputerAided Veriﬁcation ,2018.
[69] Naling Zhang, MarkusKusano, and Chao Wang. Dynamic par tial order reduc-
tionforrelaxedmemorymodels. In ACMSIGPLANConferenceonProgramming
Language Designand Implementation , pages250–259,2015.
12