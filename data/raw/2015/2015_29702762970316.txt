Model-Based Whitebox Fuzzing for Program Binaries
Van-Thuan Pham Marcel B√∂hme Abhik Roychoudhury
School of Computing, National University of Singapore, Singapore
{thuanpv, marcel, abhik}@comp.nus.edu.sg
ABSTRACT
Many real-world programs take highly structured and complex Ô¨Åles
as inputs. The automated testing of such programs is non-trivial. If
the test does not adhere to a speciÔ¨Åc Ô¨Åle format, the program returns
a parser error. For symbolic execution-based whitebox fuzzing the
corresponding error handling code becomes a signiÔ¨Åcant time sink.
Too much time is spent in the parser exploring too many paths lead-
ing to trivial parser errors. Naturally, the time is better spent explor-
ing the functional part of the program where failure with valid input
exposes deep and real bugs in the program.
In this paper, we suggest to leverage information about the Ô¨Åle
format and data chunks of existing, valid Ô¨Åles to swiftly carry the
exploration beyond the parser code. We call our approach Model-
based Whitebox Fuzzing (MoWF) because the Ô¨Åle format input
model of blackbox fuzzers can be exploited as a constraint on the
vast input space to rule out most invalid inputs during path explo-
ration in symbolic execution. We evaluate on 13 vulnerabilities in
8 large program binaries with 6 separate Ô¨Åle formats and found that
MoWF exposes all vulnerabilities while both, traditional whitebox
fuzzing and model-based blackbox fuzzing, expose only less than
half, respectively. Our experiments also demonstrate that MoWF
exposes 70% vulnerabilities without any seed inputs.
CCS Concepts:
Software and its engineering !Software testing and debug-
ging;Security and privacy !Vulnerability scanners;
Keywords: Symbolic Execution, Program Binaries
1. INTRODUCTION
Testing Ô¨Åle-processing programs can be challenging. Even though
a structured Ô¨Åle is stored as a vector of input bytes, it is often parsed
as a tree where data chunks contain Ô¨Åelds and other data chunks.
Our key insight is that certain branches in a Ô¨Åle-processing pro-
gram are exercised only depending on i) the presence of a speciÔ¨Åc
data chunk, ii) a speciÔ¨Åc value of a data Ô¨Åeld in a data chunk, or
iii) the integrity of the data chunks. Hence, an efÔ¨Åcient test gener-
ation technique not only sets speciÔ¨Åc values of the Ô¨Åelds but also
adds/removes complete chunks and establishes their integrity (e.g.,
checksum or size).Fuzzers help to test such Ô¨Åle-processing programs. Model-based
blackbox fuzzers (MoBF) [3, 5] utilize input models to generate
valid random Ô¨Åles. The input model speciÔ¨Åes the format of the data
chunks and integrity constraints. However, while valid, the modi-
Ô¨Åcation is still inherently random. Whitebox fuzzers (WF) employ
symbolic execution to explore program paths more systematically.
Given a valid Ô¨Åle, they can generate the speciÔ¨Åc values for the
data Ô¨Åelds quite comfortably. However, when it comes to adding
or deleting data chunks or enforcing integrity constraints, they are
bogged down by the large search space of invalid inputs [27].
Grammar-based whitebox fuzzers (GWF) can generate Ô¨Åles that
are valid w.r.t. a context-free grammar [14]. Like WF, GWF com-
putes path constraints: logical formulas that are satisÔ¨Åed only by
new Ô¨Åles exercising alternative paths. Unlike WF, these constraints
are converted into regular expressions such that a context-free con-
straint solver can generate an input that is accepted by both, the
grammar and the expression. However, the expression is much
weaker than the path constraint. Suppose, symbolic execution yields
the path constraint '^(x < y ). After conversion, the regular
expression cannot capture that arithmetic constraint. Moreover,
GWF cannot encode integrity constraints such as size-of, offset-of,
length-of and checksums. These integrity checks are very common
in several highly structured Ô¨Åle formats like PNG, PDF and WA V .
In this work, we present Model-based Whitebox Fuzzing (MoWF),
an automated testing technique for industrial-size program bina-
ries that process structured inputs. MoWF is a marriage of model-
based blackbox fuzzing and whitebox fuzzing that generates valid
Ô¨Åles efÔ¨Åciently that exercise critical target locations effectively. It
is adirected path exploration technique that prunes from the search
space those paths that are exercised by invalid, malformed inputs:
(i) MoWF uses information about the Ô¨Åle format to explore those
branches that are exercised depending on the presence of speciÔ¨Åc
chunks. To this end, MoWF removes the referenced chunk or adds
a new valid chunk by instantiation from the input model or a pro-
cess we call data chunk transplantation ‚Äî MoWF identiÔ¨Åes the
set of input bytes corresponding to the required chunk in a donor
Ô¨Åle and transplants them into the appropriate location of the receiv-
ing Ô¨Åle. (ii) MoWF employs selective symbolic execution [11] to
explore those branches that are exercised depending on speciÔ¨Åc val-
ues of the data Ô¨Åelds. (iii) Lastly, MoWF establishes the integrity
of the generated Ô¨Åles, repairing checksums and offsets.
Unlike MoBF, MoWF is directed and enumerates the speciÔ¨Åc
values of data Ô¨Åelds more systematically. Unlike WF, MoWF does
not get bogged down by the large search space of invalid inputs or
require any seed inputs (cf. [13, 16]). Unlike GWF, MoWF main-
tains fullpath constraints so it has no impact on the soundness and
completeness of WF. Moreover, MoWF leverages a more expres-
sive yet simple input model to handle integrity constraints.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission and/or a
fee. Request permissions from Permissions@acm.org.
ASE‚Äô16 , September 3‚Äì7, 2016, Singapore, Singapore
c2016 ACM. 978-1-4503-3845-5/16/09...$15.00
http://dx.doi.org/10.1145/2970276.2970316
543
89504E470D0A1A0A 0000000D 49484452  7FFFFFFF   00000001  0103000000  BA1BD884  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX         
width 
IHDR height others 
PLTE tRNS IDAT IEND 
PNG Data Signature ...
OTHERS Figure 1: The structure and the hex code of a PNG Ô¨Åle. A data chunk is a section in the hex code embedding one piece of information
about the image. The hex code above the light-grey boxes identiÔ¨Åes the data chunk type while the hex code above the dark-grey boxes
protects the correctness of the data chunk (via checksum).
The input model is used to generate valid Ô¨Åles efÔ¨Åciently, en-
force integrity constraints, and facilitate the transplantation of data
chunks. Since it only prunes search space, the input model does
not need to be complete. On one hand, whitebox fuzzing eventu-
ally constructs all relevant (semi-) valid Ô¨Åles by exploring paths that
are not pruned by the input model. On the other hand, transplan-
tating data chunks from donors maintains underspeciÔ¨Åed integrity
constraints, such as the concrete compression algorithm with which
the image data in a PNG Ô¨Åle must be encoded. An input model
is constructed once and can be used across all future testing ses-
sions. It has been shown that input models can also be derived in
an automated fashion [19, 18, 17]. Each of our input models was
constructed manually in less than a day.
The two main challenges of Traditional Whitebox Fuzzing (TWF)
that we address are:
Path Explosion . Parser code is often a large and very com-
plex part of a program. In practice, TWF gets bogged down
by an exponential number of paths in the parser that are ex-
ercised by invalid inputs [27].
Seed Dependendence . Most TWF approaches assume the
existence of a seed Ô¨Åle that features all necessary data chunks
‚Äì it is only a matter of setting the correct values for the data
Ô¨Åelds to expose an error. In practice, however, this may not
be the case. Data chunks may be missing or in the wrong
order. In other cases no seed Ô¨Åles may be available at all.
The main contributions of MoWF are as follows.
Pruning Invalid Paths . The input model allows to prune
most paths that are exercised by invalid inputs. As opposed
to TWF, MoWF is capable of negating those crucial branches
that are exercised only in the presence of certain data chunks
without having to iteratively construct the data chunk by ex-
ploring the parser code. All generated test inputs are valid
in that they adhere to the input model. Integrity constraints
are enforced. Given a 24h time budget, our MoWF tool ex-
posed all of thirteen vulnerabilities in our experimental sub-
jects while the TWF tool exposed only six.
Reduced Seed Dependence . The instantiation from the in-
put model allows to construct seed inputs from scratch. More-
over, given a seed input that is missing a data chunk to reach
a target location, MoWF allows to utilize other seed Ô¨Åles as
donors, transplant the missing data chunk, and construct a
new seed input that is closer to the target location. In the
absence of a donor, the missing data chunk can be directly
instantiated from the input model. Out of the thirteen vul-
nerabilities in our experimental subjects our MoWF tool ex-
posed nine without any seed inputs .
Fuzzing tool . We implement our MoWF tool as an extension
of the TWF tool, H ERCULES [22]. We compare our MoWF
tool not only to the H ERCULES TWF but also to the P EACH
model-based blackbox fuzzer [3]. Given a 24h time budget,
our MoWF tool exposed all of 13 vulnerabilities in our ex-
perimental subjects while the both H ERCULES and P EACH
tool exposed only six.Insights . Through our experiments we also gain insights about
the relative strengths of our technique MoWF, symbolic execu-
tion based traditional whitebox fuzzing (TWF), and model-based
blackbox fuzzing (MoBF) as in fuzzers like Peach/Spike [3, 5].
TWF performs well only if there exists a seed input that features
all necessary data chunks and only certain values for data Ô¨Åelds
need to be set. MoBF performs well if the vulnerability is exposed
by putting boundary values for certain data Ô¨Åelds, or by remov-
ing/adding empty data chunks. Deep vulnerabilities that require
speciÔ¨Åc values are best exposed by a symbolic execution-based ap-
proach. MoWF performs well even in the absence of seed inputs
and swiftly generates the speciÔ¨Åc values needed to expose even
deep vulnerabilities, while also gaining the capability to add and
remove complete data chunks as in MoBF.
2. OVERVIEW
2.1 Motivating Example
We motivate MoWF based on a real, serious vulnerability in a
library that is shipped with several browsers and media players.
LibPNG [24] is the ofÔ¨Åcial PNG reference library; it supports al-
most all PNG features, and has been extensively tested for over 20
years. The library is integrated into popular programs such as VLC
media player, Google Chrome web brower and Apple TV .
PNGs consist of four mandatory and fourteen optional types of
data chunks. For easy parsing and error detection the Ô¨Åle format
requires to specify the size, type, and checksum of each data chunk
besides the actual data. The particular PNG Ô¨Åle in Figure 1 hap-
pens to expose a memory access violation vulnerability (OSVDB-
95632) in VLC 2.0.7 [25] which uses LibPNG 1.5.14. To trigger
the bug, the image width deÔ¨Åned in the IHDR chunk must take a
speciÔ¨Åc value (from 0x7FFFFFF2 to0x7FFFFFFF ) and the op-
tional tRNS chunk must exist. The tRNS chunk speciÔ¨Åes alpha
values to control the transparency of pixels in the image.
Figure 1 partially shows structure of a Ô¨Åle that exposes the bug.
The Ô¨Årst eight bytes identify the Ô¨Åle as PNG. The next four bytes
specify the sizeof the next data chunk ( 0xD =hex(13) bytes),
followed by four bytes identifying the type of the chunk as IHDR
(light-grey box). The next 13 bytes are data Ô¨Åelds specifying im-
age width and height. This is followed by four bytes of checksum
protecting the correctness of the IHDR chunk (dark-grey box). The
remaining chunks are structured similarly. The image data in the
IDAT chunk is compressed using the DEFLATE compression algo-
rithm [1] and the end of the PNG Ô¨Åle is indicated by IEND chunk.
Listing 1 shows the pertinent code in LibPNG. In each iteration,
png_read_info (lines 2-27) parses information about the cur-
rent chunk, like its size and type. Depending on the type it calls the
corresponding function to handle the current chunk and validate the
checksum. These handler functions parse a chunk‚Äôs data Ô¨Åelds and
store their values for further image transformation and processing
steps. The chunks are parsed until the Ô¨Årst IDAT chunk is reached
(lines 18-22). The Ô¨Åle shown in Figure 1 passes all checks in the
parser and chunk-handling code and is therefore valid .
544Fragment 
Program   v ah,0 
int 1ah 
mov ax,dx 
mov dx,cx 
mov cl,4 
shl dx,cl 
mov bx,ax 
mov cl,12 
* 
File Stitcher Seed Files 
Initial File 
PoolPotentially 
Invalid Files File Repair 
√∑ 
Fragment 
‚úìCondition tainted 
by enum. type? 
 ‚úò Program   v ah,0 
int 1ah 
mov ax,dx 
mov dx,cx 
mov cl,4 
shl dx,cl 
mov bx,ax 
mov cl,12 
Hercules ++
SMT Solver ? 
* 
File Stitcher File Cracker Existing 
Initial Symbolic 
 Input File PoolPotentially 
Invalid File Valid Symbolic 
Input File 
Input Files File Repair √∑ 
File Cracker 
Identify 
Stitched Files 
Selective 
executed 
crucial  IFsSymb. Exec. ‚úì
‚úì‚úò
Valid Files ‚úì1. Add/Remove Chunks 2. Explore Data Fields 
3. Use as next seeds Crash Files 
Figure 2: Model-based Whitebox Fuzzing. Elements marked in grey are informed by the data model.
 
1// read chunks‚Äô info before first IDAT chunk
2void png_read_info(png_structp ptr)
3{
4// read and check the PNG file signature
5read_sig(f);
6for (;;)
7{
8 // get current chunk‚Äôs information
9 uint_32 length = read_chunk_header(ptr);
10 uint_32 chunk_name = ptr->chunk_name;
11 // mandatory chunks
12 if(chunk_name == png_IHDR)
13 handle_IHDR(ptr, length);
14 else if (chunk_name == png_IEND)
15 handle_IEND(ptr, length);
16 else if (chunk_name == png_PLTE)
17 handle_PLTE(ptr, length);
18 else if (chunk_name == png_IDAT)
19 {
20 ptr->idat_size = length;
21 break ;
22 }
23 // optional chunks
24 else if ...
25 else if (chunk_name == png_tRNS)
26 handle_tRNS(ptr, length);
27 else if ...
28}
29}
30// initialize row buffer for reading data from file
31void png_read_start_row(png_structp ptr)
32{
33 size_t buf_size;
34 ...
35 buf_size = calculateBufSize(ptr);
36 ptr->row_buf = png_malloc(ptr, buf_size);
37 png_memset(ptr->row_buf, 0, ptr->rowbytes);
38} 
Listing 1: SimpliÔ¨Åed parser code for data chunks. The code
is shown to ease the explanation; MoWF works directly with
program binaries.
When all other chunks have been parsed, LibPNG starts reading
pixel data from IDAT chunks. For each image row, LibPNG allo-
cates and initializes a buffer (lines 31-38 in png_read_start_row ).
This is the faulty function. SpeciÔ¨Åcally, the existence of tRNS
chunk and the improper validation of large image width leads to an
integer overÔ¨Çow while LibPNG is calculating buffer size for each
row (as simpliÔ¨Åed in calculateBufSize at line 35). Because of that
the allocated buffer is much smaller than required (line 36). As
a consequence, a buffer overÔ¨Çow occurs in png_memset causing
the program to crash. Notice that the third argument for the func-
tion call memset (ptr!rowbytes ) is much larger than the size of the
buffer.2.2 Exposing Vulnerabilities
2.2.1 Traditional Whitebox Fuzzing
Given a benign PNG Ô¨Åle having the required data chunks in
Figure 1 and the dangerous location in png_memset , a Whitebox
Fuzzing (TWF) tool can automatically generate an input that ex-
poses the vulnerability. However, suppose the benign Ô¨Åle is miss-
ing the tRNS chunk, it will be an obstacle for TWF because it is
very unlikely that TWF can correctly synthesize the missing chunk
and keep the Ô¨Åle valid. In fact, if there is no tRNS chunk, the true
branch of the IF-statement in line 25 of Listing 1 is not taken. Al-
though TWF can negate the branch and get a chunk with the name
‚ÄútRNS‚Äù, its size and content still adheres to speciÔ¨Åcation of another
chunk. Where LibPNG expects the size, data, and checksum of the
new tRNS chunk, it only Ô¨Ånds ‚Äúrandom noise‚Äù. So, TWF over-
rides perfectly encoded image data only to spend substantial time
constructing a valid tRNS chunk in its place. Since IDAT chunk
is compulsory, TWF spends even more time navigating the space
of invalid inputs to construct another IDAT chunk until it Ô¨Ånally
constructed a valid Ô¨Åle that contains a valid tRNS chunk and all
compulsory chunks where all integrity constraints are satisÔ¨Åed.
2.2.2 Model-Based Whitebox Fuzzing
We propose Model-based Whitebox Fuzzing (MoWF) as a mar-
riage of model-based backbox fuzzing and whitebox fuzzing. The
model-based approach allows MoWF to cover the search space of
valid test inputs efÔ¨Åciently while the whitebox approach in detail
covers each subdomain more effectively. Both approaches are inte-
grated in a feedback loop that is described in Figure 2.
Setup . In this example, the user provides the buggy VLC binary,
a crash report, a set of existing benign PNG Ô¨Åles (if available) and
a PNG model as shown in Listing 2. To implement MoWF, we
leverage a model-based blackbox fuzzer. The Peach framework
allows to specify a Ô¨Åle format as Peach Pit [4]. It describes the
types of and relationships (size, count, offsets) between data chunks
and Ô¨Åelds. It also supports Ô¨Åxups and transformers. Fixups allow
to repair related data Ô¨Åelds, such as checksums. Transformers are
used for encoding, decoding and compression.
The PNG Peach Pit in Listing 2 Ô¨Årst speciÔ¨Åes the generic data
chunk (lines 1-14). PNG chunks all contain at least three data
Ô¨Åelds, specifying the length, type, and checksum of the data chunk.
The other data chunks inherit these attributes (lines 15-31), Ô¨Åx the
chunk type as enumerable (IHDR, PLTE, tRNS, ..), and add fur-
ther data Ô¨Åelds. The whole PNG Ô¨Åle is speciÔ¨Åed last (lines 32-42).
It starts with a speciÔ¨Åc magic number (Signature for PNG Ô¨Åles),
followed by a header chunk (IHDR) and upto 30,000 chunks (in
Ô¨Çexible order) before ending up with an IEND chunk.
545 
1<DataModel name="Chunk">
2 <Number name="Length" size="32" >
3 <Relation type="size" of="Data" />
4 </Number>
5 <Block name="TypeData">
6 <Blob name="Type" length="4" />
7 <Blob name="Data" />
8 </Block>
9 <Number name="crc" size="32" >
10 <Fixup class="Crc32Fixup">
11 <Param name="ref" value="TypeData"/>
12 </Fixup>
13 </Number>
14</DataModel>
15<DataModel name="Chunk_IHDR" ref="Chunk">
16 <Block name="TypeData">
17 <String name="Type" value="IHDR" />
18 <Block name="Data">
19 <Number name="width" size="32" />
20 <Number name="height" size="32" />
21 ...
22 </Block>
23 </Block>
24</DataModel>
25...
26<DataModel name="Chunk_tRNS" ref="Chunk">
27 <Block name="TypeData">
28 <String name="Type" value="tRNS" />
29 <Blob name="Data" />
30 </Block>
31</DataModel>
32<DataModel name="PNG">
33 <Number name="Sig" value="89504e..." />
34 <Block name="IHDR" ref="Chunk_IHDR"/>
35 <Choice name="Chunks" maxOccurs="30000">
36 <Block name="PLTE" ref="Chunk_PLTE"/>
37 ...
38 <Block name="tRNS" ref="Chunk_tRNS"/>
39 <Block name="IDAT" ref="Chunk_IDAT"/>
40 </Choice>
41 <Block name="IEND" ref="Chunk_IEND"/>
42</DataModel> 
Listing 2: PNG input model as Peach Pit
Given the setup, to generate the crashing input in the motivating
example, MoWF manages to (i) insert a tRNS chunk into proper
position in a benign PNG Ô¨Åle, (ii) explore the paths affected by
the existence of tRNS towards crash location, and (iii) generate
speciÔ¨Åc value for the image width data Ô¨Åeld in IHDR chunk. This
is achieved in four steps.
Step 1. Seed selection and Ô¨Åle cracking . As shown in Figure 2,
MoWF Ô¨Årst selects as initial input that Ô¨Åle which is closest to a
potential crash location. All other PNG Ô¨Åles are considered donors,
disassembled by the Ô¨Åle cracker and added to the fragment pool .
File fragments can be transplanted into input Ô¨Åles as needed. If no
initial Ô¨Åles are provided, MoWF instantiates the initial input from
the input model. Then, MoWF marks as symbolic all data Ô¨Åelds
which the user speciÔ¨Åed as ‚ÄúmodiÔ¨Åable‚Äù. Only modiÔ¨Åeable data
Ô¨Åelds are considered for the fuzzing. In this example, all data Ô¨Åelds
(e.g., image width) are marked as modiÔ¨Åable except for the chunk‚Äôs
checksum and size. The resulting hybrid symbolic PNG Ô¨Åle (i.e.,
some parts are symbolic where others are concrete) is then executed
concolically by a traditional whitebox fuzzer.
Step 2. Adding and removing data chunks . Certain branches in
a Ô¨Åle-processing program are exercised only if a certain data chunk
is absent or present. To exercise these branches during path explo-
ration, MoWF removes the speciÔ¨Åc chunk or adds a new one. First,
in the execution of a given Ô¨Åle f, MoWF identiÔ¨Åes those crucial
if-statements (IFs) by their dependence on a data Ô¨Åeld in fof enu-
merable type. In Listing 1, the IFs in lines 11‚Äì26 can be considered
crucial while none of the those inside the handle_ **** func-tions are. In our experiments, we observe that such enumerables
do often uniquely identify a data chunk‚Äôs type. First, MoWF iden-
tiÔ¨Åes the input bytes in fthat inÔ¨Çuence the outcome of executed
branch predicates using classical taint analysis . In our example,
MoWF determines the relationship between the input bytes above
the grey boxes in Figure 1 and the IFs in Listing 1. Then, MoWF
learns the type of the referenced data Ô¨Åeld using the input model.
Finally, if the data Ô¨Åeld is of enumerable type and the IFis not al-
ready executed in both directions, then the IFis considered crucial
and MoWF removes the corresponding data chunk or adds a new
one through transplantation or instantiation from the input model.
Once MoWF identiÔ¨Åes the type corresponding to the data chunk
being removed or added, the Ô¨Åle stitcher coordinates the data chunk
transplantation. First, the stitcher searches the fragment pool for
candidate data chunks that are allowed (according to the input model)
to be put at the same level as the chosen chunk in the current seed
Ô¨Ålef. Finally, the Ô¨Åle sticher uses the input model to identify the
set of input bytes corresponding to each candidate data chunk in
the pool and transplants them into the appropriate location of the
receiving Ô¨Åle fto generate a number of new seed Ô¨Åles, one for
each chunk. For our example, in what follows we assume that the
candidate containing the tRNS chunk is chosen next.
Step 3. Changing data Ô¨Åelds in inserted data chunk . Other
branches in a Ô¨Åle-processing program are exercised only if spe-
ciÔ¨Åc values are set in the chunks‚Äô data Ô¨Åelds . In our example, the
vulnerability is exposed only when the image width is in a range
of certain values. To exercise these branches by Ô¨Ånding the spe-
ciÔ¨Åc values is the strength of whitebox fuzzing. Selective symbolic
execution explores the local search space of semi-valid inputs start-
ing from the negated crucial branch. This local search is very ef-
Ô¨Åcient when compared to classical TWF. During exploration, any
integrity check is identiÔ¨Åed and ignored. The potentially invalid
Ô¨Åles are later Ô¨Åxed during the Ô¨Åle repair . Once the target location
is reached, the whitebox fuzzer checks the satisÔ¨Åability of the con-
junction of path constraint and crash condition (inferred from the
given crash report or provided as output of static analysis tool).
If the conjunction is satisÔ¨Åable, the whitebox fuzzer generates a
crashing input. Otherwise, it uses the unsatisÔ¨Åable core to guide
the path exploration towards the crash location and does the check
again.
Step 4. Repeat. Data chunks can be nested in certain Ô¨Åle for-
mats (such as WA V). Thus, MoWF uses the generated Ô¨Åles as new
seeds to continue the next iteration starting from Step 1. From
the augmented seeds (initial seeds + new seeds), MoWF selects
a Ô¨Åle which is closest to the crash location and moves to next steps.
MoWF executes selected Ô¨Åle, identiÔ¨Åes crucial if-statements, trans-
plants data chunks and continues path explorations.
Summary. In this motivating example, MoWF follows these four
steps. During concolic execution, it identiÔ¨Åes line 25 (Listing 1)
as crucial if-statement. From the input model, the Ô¨Åle stitcher in-
fers that a tRNS chunk is a candidate for transplantation and it is
allowed after PLTE and before the IDAT chunk. So, Ô¨Åle stitcher
transplants a tRNS chunk from the fragment pool or directly in-
stantiates a minimal tRNS chunk from the input model and places
it right before IDAT chunk. As a result, the true branch of the if-
statement in line 25 is taken and the tRNS chunk is parsed before
doing further processing. Once the crash location is reached, the
image-width dependent crash condition is checked and a PNG Ô¨Åle
is produced. The resulting Ô¨Åle is still invalid because the new value
of image width invalidates the checksum of IHDR chunk. So, the
Ô¨Åle repair tool Ô¨Åxes the checksum and the vulnerability is exposed.
5463. MODEL-BASED WHITEBOX FUZZING
Algorithm 1 gives an overview of the procedure of directed model-
based whitebox fuzzing. It takes a program P, an input modelM,
a set of target locations LinP, and seed inputs T. The objective
of Algorithm 1 is to generate valid (crashing) Ô¨Åles that exercise L.
If no target is provided, MoWF uses static analysis to identify dan-
gerous locations in the program, such as locations for potential null
pointer dereferences or divisions by zero (line 1-3). The algorithm
uses the provided test cases Tas seed inputs for the test genera-
tion. However, if no seed Ô¨Åle is provided, MoWF leverages the
input modelMto instantiate a seed Ô¨Åle (lines 4-7).
Algorithm 1 Model-Based Whitebox Fuzzing
Input: ProgramP, Input ModelM
Input: Initial Test Suite T, TargetsL
Output: Augmented Test Suite T0
1:ifL=;then
2:L IDENTIFY CRITICAL LOCATIONS (P)
3:end if
4:ifT=;then
5:t INSTANTIATE ASVALID INPUT (M)
6:T ftg
7:end if
8:while timeout not exceeded do
9: Target location l CHOOSE TARGET (L)
10: Input Ô¨Åle t CHOOSE BEST(T;l)
11: Fragment Pool  FILECRACKER (T;M)
12: Crucial IFS DETECT CRUCIAL IFS(t;l;P;M)
13: for all2do
14: Valid Ô¨Åles T FILESTITCHER (t;;;M)
15: for allt2Tthat negatedo
16: Hybrid Ô¨Åle ^t MARK SYMBOLIC VARS(t;M)
17: Files F PATH EXPLORATION (^t;;l;L;P)
18: for allf2Fdo
19: Valid Ô¨Åle f0 FILEREPAIR (f;M)
20: T T[f0
21: end for
22: end for
23: end for
24:end while
25:T0 T
The main loop of Algorithm 1 is shown in lines 8-24. First,
MoWF chooses the next target location l. If MoWF works in crash
reproduction mode, lis the known crash location extracted from
the given crash report. Otherwise, lis picked if its average distance
to all seed inputs in Tis smallest. The distance between an input
tand a program location lis speciÔ¨Åed in DeÔ¨Ånition 1. Second,
MoWF chooses the next seed Ô¨Åle taccording to a search strategy
that seeks to generate the next input with a reduced distance to l
(line 10). The remaining seed Ô¨Åles are sent to the Ô¨Åle cracker to
construct the fragment pool in line 11. The fragement pool takes
a central role during data chunk transplantation.
DeÔ¨Ånition 1 ( Input Distance to Location )
Given an input t, a programPand a program location linP.
Let
(t)be the set of nodes in the Control Flow Graph (CFG) of
Pthat are exercised by t. The distance(t;l)fromttolis the
number of nodes on the shortest path from any b2
(t)tol.
Next, Algorithm 1 executes tonPto determine crucial IFs
(line 12). As speciÔ¨Åed in DeÔ¨Ånition 2, a crucial IFis evaluated in
different directions only depending on the type of the data chunkspresent int. Our implementation leverages Mto identify crucial
IFs by their dependence on a data Ô¨Åeld in tof enumerable type. We
observed that such enumerables do often uniquely identify a data
chunk‚Äôs type. Note that we ignore executed IFs negating which
does not reduce the distance to the target location l.
DeÔ¨Ånition 2 ( Crucial IF-statement )
Given input tfor programPand a target location linP, an if-
statementbinPiscrucial if
1) the statement bis executed by tinP,
2) only one direction of bhas been taken,
3) the negation of the branch condition at breduces the distance
tol, and
4) let'(b)be the branch condition at b; the outcome of '(b)
depends on a Ô¨Åeld in tthat speciÔ¨Åes the chunk‚Äôs type.
For each crucial IFthus identiÔ¨Åed, Algorithm 1 employs the
Ô¨Åle stitcher to negate ‚Äôs branch condition (lines 13-14). For each
stitched Ô¨Åletthat successfully negates , the algorithm executes
selective symbolic execution followed by Ô¨Åle repair to Ô¨Åne-tune the
speciÔ¨Åc values of the data chunks and reduce the distance to l(lines
15-20). More speciÔ¨Åcally, it marks all modiÔ¨Åable data Ô¨Åelds in t
as symbolic and starts the directed path exploration (lines 16-17).
During path exploration, MoWF does not collect integrity checks
as branch constraints. For instance, a checksum check might not
allow to change a data Ô¨Åeld which would otherwise lead to reducing
the distance to L(cf. TaintScope [26]). Such integrity constraints
are repaired in line 19. Whenever a potential dangerous location in
Lis reached, MoWF checks if the crash condition is satisÔ¨Åed and
generates a crashing test case accordingly.
A detailed discussion of the procedures in Algorithm 1 is found
in the following sections:
# Procedure Discussion
2IDENTIFY CRITICAL LOCATIONS ¬ß3.1
5INSTANTIATE ASVALID INPUT ¬ß3.2
10 CHOOSE BEST ¬ß3.1
11 FILECRACKER ¬ß3.2
12 DETECT CRUCIAL IFS ¬ß3.2
14 FILESTITCHER ¬ß3.2
16 MARK SYMBOLIC VARS ¬ß3.3
17 PATH EXPLORATION ¬ß3.3&¬ß3.4
19 FILEREPAIR ¬ß3.2
3.1 Directed Model-Based Search
In order to generate inputs that expose vulnerabilities, MoWF
uses the initial seed inputs Tto reduce the distance to the provided
or identiÔ¨Åed critical location luntil it is reached and the crash con-
dition is satisÔ¨Åed.
Critical Locations . If no targets Lare provided to the algo-
rithm, MoWF identiÔ¨Åes critical locations in the program P. Acrit-
ical location is a program location that may expose a vulnerability
if exercised by an appropriate input. There are several methods to
identify such critical locations [13, 26]. In our implementation, we
use IDAPro [2] to dissamble the program binary Pand perform
some lightweight analysis to identify instructions that conform to
the patterns shown in Listing 3. These patterns partially cover pro-
gram instructions that may trigger divide-by-zero and null-pointer
dereference vulnerabilities. SpeciÔ¨Åcally, we focus on division and
memory move instructions taking registers or stack arguments as
operands. For those instructions, the crash condition is obvious.
Once a critical location is reached during concolic exploration, we
just check whether the value of register/stack argument is zero (in
case it is concrete) or can be zero (in case it is symbolic).
547 
div register
div [ebp + argument_offset]
mov operand, [ register ]
mov operand, [ebp + argument_offset]
mov [ register ], operand
mov [ebp + argument_offset], operand 
Listing 3: Crash instruction templates
Model-based Search . To generate input that reduces the dis-
tance tol, MoWF Ô¨Årst chooses the seed input twith the least dis-
tance toland then identiÔ¨Åes the executed crucial IFs(lines 10,
12 in Alg. 1). The task of the subsequent data chunk transplanta-
tion and instantiation will be to generate valid inputs that negate the
branch conditions of . While other implementations are possible,
we decided to implement a hill climbing algorithm. Our imple-
mentation of CHOOSE BESTselects the input Ô¨Åle t2Tsuch that
for selected location l2Lwe have that the distance from ttol
is minimal. To detect crucial branches , MoWF Ô¨Årst determines,
using taint analysis, those input bytes in tthat may impact the out-
come of some b2
(t). We recall that 
(t)is the set of nodes in
the CFG of program Pwhich are exercised by t. In our implemen-
tation of DETECT CRUCIAL IFS, we leverage those capabilities in a
symbolic execution tool, Hercules. Next, MoWF uses the CFG to
compute the number of nodes on the shortest path between band
locationl2L. The negation of '(b)may reduce the distance to l
only ifbis in static backward slice of land the branch b0immedi-
ately following bdoes not have a smaller number of nodes on the
shortest path between b0andl. Lastly, MoWF uses Mto deter-
mine the data Ô¨Åeld corresponding to the identiÔ¨Åed input bytes and
whether the data Ô¨Åeld speciÔ¨Åes the chunk‚Äôs type. If all conditions
speciÔ¨Åed in DeÔ¨Ånition 2 are met, then bis marked as a crucial IF
and added to .
3.2 Transplantation, Instantiation, and Repair
File Cracker . ‚ÄúFile cracking‚Äù refers to the process of interpret-
ing valid Ô¨Åles according to a provided input model (i.e., the Peach
Pit Ô¨Åle). Given the input model Mand a valid Ô¨Åle t2T, the FILE-
CRACKER identiÔ¨Åes all data chunks and their data Ô¨Åelds in t. In
model-based blackbox fuzzers like Peach Fuzzer [3], the valid in-
put Ô¨Åles are cracked and fuzzed independently. However, in MoWF
we crack all Ô¨Åles and place their data components inside a frag-
ment pool . As a result, we can consider all Ô¨Åles (and even the input
model) as donors for data transplantation. By doing that, MoWF
can generate more (semi) valid Ô¨Åles and improve coverage.
File Stitcher . Given a valid Ô¨Åle tand the crucial IF, the ob-
jective of FILESTITCHER is to negate'()and reduce the distance
tolby adding or removing chunks from t. First, the stitcher has to
determine the chunk cintthat should be removed or before which
a different chunk should be added in order to negate '(). Chunk
cwas memorized previously when determining that the outcome of
depends on the data Ô¨Åeld specifying c‚Äôs type. Second, the stitcher
generates a new Ô¨Åle by removing cfromtif allowed according to
M. Third, for each chunk type Cthat is allowed before cint:
i)Transplantation. If there exists a chunk c0of typeCin the pool
, copy the input bytes corresponding to c0from the donor Ô¨Åle to
the position before cin the receiving Ô¨Åle t.
ii)Instantiation . Otherwise, use the speciÔ¨Åcation of CinMas a
template to generate the bytes for c0beforecint. All Ô¨Åles thus
generated that actually negate will be used for the subsequent
selective symbolic execution stage.
File Repair . Given a Ô¨Åle fand the input model M, the Ô¨Åle re-
pair tool re-establishes the integrity of the Ô¨Åle. Our implementation
utilizes the Ô¨Åxup and transformers that can be speciÔ¨Åed in Min the
Peach framework.3.3 Selective and Targeted Symbolic Execution
We reuse the targeted search strategy for symbolic exploration
implemented in Hercules [22]. Basically, to mitigate the path ex-
plosion problem, it enables fully symbolic reasoning only in some
selected modules of interest (i.e., executable binaries like .exe and
.dll Ô¨Åles). The list of selected modules can be inferred from the
target module TM, which contains the selected target location, and
a so-called Module Dependency Graph (MDG). The MDG is con-
structed by running the program under test with benign inputs and
collecting the control transfer between program modules. Using the
constructed MDG, TM and all modules on paths from entry mod-
ule (main program) to TM are selected to explore in fully symbolic
execution mode.
The search strategy of Hercules is targeted in the sense that it
explores program paths towards a target location (critical locations
like crashing one) by pruning irrelevant paths. Moreover, Hercules
leverages the unsatisÔ¨Åable core produced by a theory prover like Z3
[12] to guide the exploration.
3.4 Handling Incomplete Memory Modeling
The memory models of symbolic execution engines, like Her-
cules, KLEE or S2E [22, 10, 11], do not support memory allocation
with symbolic size. If a symbolic size is given, it is concretized be-
fore allocating heap memory. The concretization mechanism could
prevent us from exposing heap buffer overÔ¨Çow vulnerabilities. Sup-
pose in the motivating example the image width of the benign PNG
Ô¨Åle is very small, say 1, and it is marked as symbolic. In the pro-
cessing code, LibPNG needs to allocate a heap buffer having sym-
bolic size that depends on width (and other symbolic variables).
When the buffer is allocated, width is bound inPC by the con-
straint on concretized value for allocated buffer size.
Once the crash location (e.g., the instruction accessing the allo-
cated heap buffer) is reached, Hercules checks the satisÔ¨Åablity of
the conjunction between the current path constraint PC and the
crash condition CC. Suppose that to satisfy the crash condition,
the image width must be large enough. For the current Ô¨Åle with the
small image width, the crash condition CC could contradict the
path constraint PC;PC^CC is unsatisÔ¨Åable. Usually, based on
the unsatisÔ¨Åable core1ofPC^CC, Hercules Ô¨Ånd a set of branches
that can be negated to explore neighboring paths along which the
crash condition CCmay be satisÔ¨Åable. However, since width is al-
ready bound, there exists no alternative path along which the crash
conditionCCcan be satisÔ¨Åed.
In our extension of Hercules, we leverage recent advances in
maximal satisÔ¨Åcation with Z3 (MaxSMT)[8, 12]. Using a whitelist,
our tool automatically marks certain clauses as ‚Äúsoft clauses‚Äù. The
SatisÔ¨Åability Modulo Theory (SMT) Solver Z3 allows to generate
an assignment to the symbolic variables as solution that satisÔ¨Åes
the conjunction of all clauses ‚Äì but not necessarily the soft clauses.
SpeciÔ¨Åcally, in our case we set all constraints in CC as hard
clauses while specifying e.g., constraints due to memory allocation
inPCas soft clauses. To identify which constraints in PCcan be
soft, Ô¨Årst we check whether the conjunction PC^CC is unsatis-
Ô¨Åable. If so, we extract all symbolic variables in CC. Thereafter,
we iterate through all constraints in PC and consider them as soft
constraints accordingly if they contain any symbolic variable from
CC. After all these steps, we get PC0, the updated PC, and we
send another query to MaxSMT solver to check the maximum sat-
isÔ¨Åability of PC0^CC. IfPC0^CC is satisÔ¨Åable (by possibly
1Given an unsatisÔ¨Åable Boolean propositional formula in conjunc-
tive normal form, a minimal subset of clauses whose conjunction
is still unsatisÔ¨Åable is called an unsatisÔ¨Åable core of the original
formula.
548making one or more soft clauses in PC0as false) ‚Äì we generate a
input Ô¨Åle as the solution to the constraint. As an additional conÔ¨År-
mation, we validate the generated Ô¨Åle by feeding it to the program
binary and checking whether it crashes the program.
4. IMPLEMENTATION
* √∑ File Cracker 
File Stitcher 
File Repair Hercules 
Crucial IFS 
Detector 
MaxSMT 
Interface 
Pin tools 
(Profiling) 
Static Analysis 
(Finding critical 
locations) 
Input Model Manipulation Enhanced Whitebox Fuzzing 
Figure 3: Components of our MoWF tool
Our MoWF tool is based on several third-party tools and li-
braries. We implemented our technique into the Hercules [22]
directed symbolic execution engine which itself leverages S2E [11]
and the Z3[12] satisÔ¨Åability modulo theory constraint solver. We
also improved the accuracy of the taint analysis that is implemented
inHercules .IDAPro [2] and the Intel Dynamic Binary Instru-
mentation Tool [20] (or PIN tool ) were used for static anal-
ysis to Ô¨Ånd dangerous locations in the program code executing
which might crash the program (cf. ¬ß3.1). The PIN tools were
also used i) for instruction proÔ¨Åling to generate the execution trace
and compute the distance of the current seed input to the dan-
gerous locations, and ii) for branch proÔ¨Åling to determine which
crucial branches are explored. The framework around the Peach
model-based blackbox fuzzer [3] allowed us to implement the in-
put model-based components such as File cracker ,File Stitcher and
File Repair . In fact, the Ô¨Årst was modiÔ¨Åed for our purposes and the
latter two were implemented from scratch, for instance, to support
data chunk transplantation.
5. EXPERIMENTAL EV ALUATION
We evaluated our MoWF technique experimentally to answer the
following research questions.
RQ.1 How many vulnerabilities are exposed by MoWF com-
pared to Traditional Whitebox Fuzzing (TWF)?
RQ.2 How many vulnerabilities are exposed by MoWF com-
pared to Model-based Blackbox Fuzzing (MoBF)?
RQ.3 How many vulnerabilities are exposed by MoWF if no
initial seed inputs are available?
Each technique was evaluated with a 24 hour time budget.
5.1 Experimental Setup
5.1.1 Subjects
We selected our subjects from a pool of well-known program bi-
naries of video players, document readers, music players, and im-
age editors ‚Äì which take a variety of complex Ô¨Åle formats. Since
Hercules serves as a base line technique, we also added all Ô¨Åve
subjects on which Hercules was evaluated originally [22] (shown
with grey background). We also took the categories of vulnerabil-
ities into consideration. As shown in Table 1, we chose eight dis-
tinct real-world applications (some with different versions): AdobeTable 1: Subject Programs
Program Version Buggy module Size Errors
Video Lan Client 2.0.7 libpng.dll 184 KB 1
Video Lan Client 2.0.3 libpng.dll 182 KB 1
Libpng Test Program 1.5.4 libpng.dll 176 KB 1
XnView 1.98 XnView.exe 4.46 MB 0 + 3
Adobe Reader 9.2 cooltype.dll 2.32 MB 1
Windows Media Player 9.0 quartz.dll 1.22 MB 2 + 1
Real Player SP 1.0 realplay.exe 60 KB 1
MIDI Player 0.35 mamplayer.exe 336 KB 1
Orbital Viewer 1.04 ov.exe 538 KB 1
Total: 9 + 4
Reader (AR)2, Video Lan Client (VLC)3, Windows Media Player
(WMP), Real Player (RP)4and Music Animation Machine MIDI
Player (MP)5, XnView (XNV)6, LibPNG (LTP)7and Orbital Viewer
(OV)8.
Table 1 shows not only the subjects and their versions but also
the target buggy modules and their respective sizes. In addition, it
features the number of known vulnerabilities that we sought to re-
produce. In one case (XnView), we started without any known vul-
nerabilities and looked for unknown ones. In other cases, although
we targeted the known vulnerabilities, we managed to discover new
ones. Indeed, our MoWF tool reproduced successfully all 9 known
errors and discovered 4 unknown errors ‚Äì 3 in XnView and 1 in
Windows Media Player (See Section 5.2).
5.1.2 Input Modeling
TodeÔ¨Åne input models of Ô¨Åve Ô¨Åle formats (PDF, PNG, MIDI,
FLV and ORB) from scratch, we utilized the modeling language of
the Peach model-based blackbox fuzzer. We augmented the input
model for WA V Ô¨Åles which is provided freely by Peach Fuzzer. In
particular, we modeled one common image Ô¨Åle (PNG), three audio
and video Ô¨Åles (MIDI, WA V and FLV), one portable document Ô¨Åle
(PDF) and one geometry Ô¨Åle (ORB). In Table 2, we report the size
of the input models which are relatively small ‚Äì ranging from 4 KB
to 14 KB. It took us less than a day to write each model for a Ô¨Åle
format.
Table 2: Information on the Input Models
Format Size Time spent #Files Average size
PDF 4.5 KB 12 hours 10 200 KB
PNG 8.3 KB 4 hours 10 55 KB
MIDI 13.9 KB 4 hours 10 20 KB
FLV 6.0 KB 4 hours 10 300 KB
ORB 6.0 KB 8 hours 10 4 KB
WA V7.5 KB 2 hours 10 260 KB
5.1.3 Initial Seed Files Selection
Toselect the initial seed Ô¨Åles , we randomly downloaded 10 Ô¨Åles
of the corresponding format from the Internet, except ORB and
PNG initial seed Ô¨Åles. The ORB Ô¨Åles were downloaded from soft-
ware vendor‚Äôs website9while PNG Ô¨Åles were downloaded from the
Schaik online test suite.10The average size of seed Ô¨Åles in each test
suite is shown in the Ô¨Åfth column of Table 2.
2https://get.adobe.com/reader/
3http://www.videolan.org/index.html
4http://www.real.com/sg
5http://www.musanim.com/player/
6http://www.xnview.com/en/
7http://www.libpng.org/pub/png/libpng.html
8http://www.orbitals.com/orb/ov.htm
9http://www.orbitals.com/orb/ov.htm
10http://www.schaik.com/pngsuite
5495.1.4 Infrastructure
We evaluated three tools, our MoWF tool, the Hercules Tradi-
tional Whitebox Fuzzer (TWF) and the Peach Model-Based Black-
box Fuzzer (MoBF). For the experiments, we used the community
version of Peach Fuzzer which is provided with its source code.11
Both model-based techniques used the same input models. All sub-
ject programs were run on Windows XP 32-bit SP 3. For each
program, each tool was conÔ¨Ågured for a timeout after 24 hours of
execution. We conducted all experiments on a computer with a 3.6
GHz Intel Core i7-4790 CPU and 16 GB of RAM.
5.2 Results and Analysis
Table 3: The vulnerabilities exposed by our MoWF tool, the
Hercules TWF, and the Peach MoBF. Vulnerabilities from
theHercules benchmark are marked as grey.
Program Advisory ID Model Files MoWF MoBF TWF
VLC 2.0.7 OSVDB-95632 PNG 10 4 8 8
VLC 2.0.3 CVE-2012-5470 PNG 10 4 8 8
LTP 1.5.4 CVE-2011-3328 PNG 10 4 8 8
XNV 1.98 Unknown-1 PNG 10 4 4 8
XNV 1.98 Unknown-2 PNG 10 4 4 8
XNV 1.98 Unknown-3 PNG 10 4 4 8
WMP 9.0 Unknown-4 WA V 10 4 4 8
WMP 9.0 CVE-2014-2671 WA V 10 4 84
WMP 9.0 CVE-2010-0718 MIDI 10 4 84
AR 9.2 CVE-2010-2204 PDF 10 4 84
RP 1.0 CVE-2010-3000 FLV 10 4 84
MP 0.35 CVE-2011-0502 MIDI 10 4 4 4
OV 1.04 CVE-2010-0688 ORB 10 4 4 4
Table 3 shows the results in reproducing known vulnerabilities
and Ô¨Ånding unknown ones of the three compared techniques. Over-
all, in the experiments our MoWF tool outperforms both Hercules
andPeach . While our MoWF tool successfully generated 13 crash-
inducing inputs, neither Hercules norPeach can produce half
of them . Furthermore, our MoWF tool also found potential un-
known vulnerabilities in Windows Media Player and XnView. In-
deed, these vulnerabilities have previously not been reported at
MITRE12, OSVDB13or Exploit-DB.14. In addition, the power of
our MoWF tool is also demonstrated by its ability to expose differ-
ent types of vulnerabilities including integer and buffer overÔ¨Çows,
null pointer dereference and divide-by-zero. In the following sec-
tions, we have an in-depth analysis to answer the three research
questions about the effectiveness and sensitivity of our approach.
RQ.1 Versus Traditional Whitebox Fuzzing
Our experiments conÔ¨Årm the observations that TWF is unlikely to
synthesize missing composite data chunks. As in OSVDB-95632,
CVE-2012-5470, CVE-2011-3328 and Unknown 1-4, Hercules
cannot produce crash inputs to expose the vulnerabilities because
they require the existence of optional composite data chunks. In
our experiments, Hercules gets stuck in synthesizing such re-
quired data chunks. In particular, the following requirments must
be met to expose the 7 vulnerabilities that are not in the Hercules
benchmark:
OSVDB-95632 (Buffer OverÔ¨Çow): It requires a PNG Ô¨Åle with a
tRNS optional data chunk speciÔ¨Ång either alpha values that are as-
sociated with palette entries (for indexed-colour images) or a single
11http://community.peachfuzzer.com to download.
12http://cve.mitre.org/
13http://osvdb.org/
14https://www.exploit-db.com/transparent colour (for greyscale and truecolour images). More-
over, the value of a data Ô¨Åeld (image width) in IHDR chunk (the
header chunk of PNG) must be able to trigger an integer overÔ¨Çow
in the LibPNG plugin in VLC 2.0.7.
CVE-2012-5470 (Buffer OverÔ¨Çow): It requires a PNG Ô¨Åle with
a tEXt optional data chunk which stores text strings associated with
the image, such as an image description or copyright notice. Fur-
thermore, the length of the data chunk must be big enough to ex-
ceed the size of a heap buffer allocated for the image. However,
it cannot be so huge that it prevents LibPNG from successfully al-
locating a heap buffer that is supposed to store the data in tEXt
chunk.
CVE-2011-3328 (Divide-by-Zero): They require a PNG Ô¨Åle
with a cHRM optional data chunk. The cHRM speciÔ¨Åes chromatic-
ities of the red, green, and blue display primaries used in the image,
and the referenced white point. Second, some data Ô¨Åelds in cHRM
chunk must have speciÔ¨Åc values to trigger a divide-by-zero bug in
the LibPNG library.
Unknown 1-3 (Memory Read Access Violation): They require
PNG Ô¨Åles having optional data chunks (iTXt, zTXt or iCCP ac-
cordingly) which have no content. That is, the chunks that specify
a size of zero followed by chunk name and checksum.
Unknown 4 (Divide-by-Zero): It requires a WA V Ô¨Åle in which
the format chunk contains an optional extra composite data Ô¨Åeld
and one speciÔ¨Åc byte in the Ô¨Åeld is zero.
Unlike Hercules , our MoWF tool leverages the input models
to transplant required data chunks from other Ô¨Åles in the initial test
suite or generate the chunks automatically from the input model.
Hence, our MoWF tool can successfully produce crash inputs as
witnesses for the seven vulnerabilites mentioned above.
Since our MoWF tool is an extension of Hercules , it can suc-
cessfully reproduce all six vulnerabilites in the Hercules bench-
mark. As we will see for RQ.3, our MoWF tool does not re-
quire seed inputs to reproduce three out of the six vulnerabilites
in the Hercules benchmark (CVE-2010-0718, CVE-2011-0502
and CVE-2010-0688) because of its capability to generate (semi-)
valid Ô¨Åles directly from input models.
RQ2. Versus Model-Based Blackbox Fuzzing
ThePeach model-based blackbox fuzzer cannot expose half of the
vulnerabilities that our MoWF tool can expose (see Table 3). We
note that we conservatively assume that data chunk transplanation
and instantiation is available in Peach ‚Äì even though it is not. It is
worth mentioning that supporting transplanation and instantiation
inPeach could be challenging. In fact, Ô¨Ånding the correct chunk
to transplant and transplanting it to the correct location in the seed
input is subject to combinatorial explosion in an undirected fuzzing
technique like Peach . In constrast, MoWF uses information about
crucial IFs to direct the transplantation.
In the experiments, we simulated Peach ‚Äôs capability to do data
chunk transplanation and instantiation by augmenting the set of
all 10 seed inputs where none contains the missing data chunk
with at least one seed input where we manually transplanted the
missing data chunk. In Table 3, we indicate that Peach (with
the simulated capability) can expose three vulnerabilities Unknown
1-3 since these only require the existence of empty-data optional
chunks.
However, for the remaining 10 vulnerabilities, the MoBF tool
Peach cannot successfully expose 7 of 10 vulnerabilities even
though we provide inputs with the required optional data chunks.
It is because of its limitation on generating speciÔ¨Åc values . The
reason lies with the inability of blackbox fuzzing to generate the
speciÔ¨Åc values for data Ô¨Åelds that would expose deep vulnerabili-
550ties. For example, given a 4-byte integer data Ô¨Åeld, the chance for
a blackbox fuzzer to randomly mutate and get a speciÔ¨Åc value X is
extremely small, just only 1=232. In contrast, symbolic execution-
based whitebox fuzzing is very good at Ô¨Ånding such values.
Meanwhile, our MoWF tool is an enhancement of TWF (by
leveraging input models) and can tackle both the missing data chunk
problem and the limitation on generating speciÔ¨Åc input values. As
a result, it can successfully produce test cases to expose all of the
13 vulnerabilities.
RQ3. Sensitivity to the Initial Test Suite
Table 4: Vulnerabilities exposed by our MoWF tool if no initial
seed Ô¨Åles are provided.
Program Advisory ID Model #Files MoWF
VLC 2.0.7 OSVDB-95632 PNG 0 4
VLC 2.0.3 CVE-2012-5470 PNG 0 4
LTP 1.5.4 CVE-2011-3328 PNG 0 4
XNV 1.98 Unknown-1 PNG 0 4
XNV 1.98 Unknown-2 PNG 0 4
XNV 1.98 Unknown-3 PNG 0 4
WMP 9.0 Unknown-4 WA V 0 8
WMP 9.0 CVE-2014-2671 WA V 0 8
WMP 9.0 CVE-2010-0718 MIDI 0 4
AR 9.2 CVE-2010-2204 PDF 0 8
RP 1.0 CVE-2010-3000 FLV 0 8
MP 0.35 CVE-2011-0502 MIDI 0 4
OV 1.04 CVE-2010-0688 ORB 0 4
For this experiment, we run our MoWF tool with no initial seed
inputs as shown in Table 4. By leveraging input models of PNG,
MIDI and ORB, for each Ô¨Åle format our MoWF automatically gen-
erates one minimal seed Ô¨Åle. In particular, a minimal PNG Ô¨Åle is
an 1x1 image having four mandatory chunks ‚Äì IHDR, PLTE, IDAT
and IEND. In case of MIDI, it is a single track audio Ô¨Åle with one
header chunk (MThd) and one audio track chunk (MTrk). The min-
imal ORB Ô¨Åle contains all required properties for rendering an or-
bital object. Once the Ô¨Åles are generated, we run our MoWF tool
on all subjects listed in Table 4.
The experiments show that with the minimal Ô¨Åles, our MoWF
tool can expose 9 of 13 vulnerabilities (which can be revealed by
PNG, MIDI and ORB Ô¨Åles) as reported in Table 3. It means that
our MoWF tool exposes 70% vulnerabilites without any provided
seed inputs providing evidence that MoWF technique reduces the
dependence of TWF on selected seed inputs.
MoWF does not succeed in exposing the vulnerabilities in 4 of
13 vulnerabilities because they require WA V , FLV and PDF Ô¨Åles as
inputs. However, our models for these Ô¨Åle formats are still coarse.
Although they are enough to allow MoWF to work with given test
suites, they need to be more complete to support directly generating
(semi-) valid Ô¨Åles. Since these Ô¨Åle formats are complex, on one
hand we can spend more time to read and fully understand their
speciÔ¨Åcations in order to augment the input models. On the other
hand, we can reuse exhaustive models written by software vendors
or the owners of Ô¨Åle formats. For instance, according to a post at
the ofÔ¨Åcial Adobe Blog,15developers at Adobe System wrote their
model for PDF Ô¨Åle (which was a proprietary format controlled by
Adobe until 2008) and used Peach Fuzzer to fuzz their most popular
software ‚Äì Adobe Reader. Given such (partially) complete input
models, our MoWF approach would complement MoBF tool like
Peach Fuzzer to maximize the utility of these models and hence
expose more vulnerabilities.
15https://blogs.adobe.com/security/tag/fuzzing6. THREATS TO V ALIDITY
The main threat to external validity is the generality of our re-
sults. MoWF has been developed for real-world program binaries
that take complex program inputs. We choose a variety of well-
known programs from different domains where speciÔ¨Åcations of
the input models are available. While for proprietary applications
such format speciÔ¨Åcations might not be available, we believe that
grammar inference techniques can be a powerful tool to automat-
ically derive the input model. Half of the vulnerabilities have al-
ready been picked in earlier work [22]. To showcase the effective-
ness of MoWF, the other half has been chosen such that an optional
data chunk is required to expose the vulnerability.16
The main threat to internal validity is selection bias during the
seed selection (see Table 2). We chose the seed inputs either ran-
domly from a benchmark or from the internet. Moreover, our ex-
periments conÔ¨Årm the reduced dependence on the available seed
inputs.
The main threat to construct validity is the correctness of our im-
plementation. However, our tool is an extension of both Hercules
and Peach, the two baselines for our evaluation. So, our tool inher-
its the incorrectness of the baseline.
7. RELATED WORK
The Ô¨Årst automated testing technique for Ô¨Åle-processing programs
FUZZ was implemented in 1990 by Miller et al. [21] to understand
the reliability of UNIX tools. Since then fuzzing has evolved sub-
stantially, become widely adopted into practice, and exposed seri-
ous vulnerabilities in many important software programs. A fuzzer
quickly generates an excessive amount of program inputs in an at-
tempt to make it crash. Today, most compilers support to inject
so-called sanitizers during the compilation of the program under
test. A sanitizer is an automated oracle that can expose more intri-
cate but serious software bugs, such as buffer overÔ¨Çows, data races,
and memory errors. Together, fuzzers and the sanitizers allow the
automated testing and exposing of deep and intricate software bugs
in programs of any scale. Security sensitive programs are hardened
in a feedback loop where a program is Ô¨Årst sanitized, then fuzzed,
the exposed errors Ô¨Åxed, the patched version is fuzzed again, and
so on.
We can distinguish the more efÔ¨Åcient blackbox techniques that
generate test inputs without the analysis of the program source code
and the more effective whitebox techniques that leverage program
analysis to expose bugs hiding deeper in the source code of the
program.
Blackbox Fuzzing [3, 5, 6, 7, 21]. Programs processing simply
structured plain text input can be fuzzed by random input gener-
ators, like F UZZ [21]. In fact, random test generation can be a
very efÔ¨Åcient test generation technique [9]. However, for programs
processing highly structured input Ô¨Åles, like a PDF Reader, most
random Ô¨Åles are rejected as invalid. Hence, model-based blackbox
fuzzing (MoBF) tools utilize a user-given input model to generate
valid random Ô¨Åles [3, 5, 6, 7]. However, due to the random choice
of values for data Ô¨Åelds, MoBF may still be ineffective in expos-
ing more deeper errors in the program‚Äôs functionality. Systematic
path exploration to enumerate the speciÔ¨Åc values of a data Ô¨Åeld is
signiÔ¨Åcantly more effective.
Traditional Whitebox Fuzzing [15, 22, 13, 26] seeks to explore
alternative paths in the program by substituting input bytes in a
given Ô¨Åle with other values. Taint-based whitebox fuzzing [13, 26]
identiÔ¨Åes those ‚Äúhot bytes‚Äù in the input Ô¨Åle that impact the value
of a dangerous location, like a divisor or system call. Fuzzing the
16See RQ.1. in Section 5.2.
551hot bytes can reveal errors more quickly. More effective symbolic
execution-based whitebox fuzzers substitute input bytes that impact
the outcome of a branch with symbolic variables and employ sym-
bolic execution [15, 22] to negate those branches. Checksum-aware
whitebox fuzzing [26] attempts to identify checksum checks and
circumvent them during whitebox fuzzing. The check is identiÔ¨Åed
as the Ô¨Årst if-statementsthat depends on many input bytes and
is circumvented by removing sfrom the program. To repair the
generated malformed Ô¨Åles, the branch-condition of sis computed
in terms of the identiÔ¨Åed input bytes made symbolic. However,
checksum-aware whitebox fuzzing cannot solve any other integrity
constraints, like chunk size or offset. Throughout the paper, we
have shown the limitations of traditional whitebox fuzzing, such as
being bogged down by the large search space of invalid inputs and
the dependence in seed Ô¨Åles.
Grammar-based Whitebox Fuzzing (GWF) [14] generates inputs
that are valid w.r.t. a context-free grammar G. We use the example
in Listing 4 for illustration. 
1int i;
2char *input;
3char getNextToken() {
4 return input[i++];
5}
6bool isSorted() {
7 int prev_digit = 0;
8 if(‚Äô{‚Äô == getNextToken()) {
9 do{
10 char token = getNextToken();
11 if(‚Äô,‚Äô == token) continue ;
12 if(‚Äô}‚Äô == token) return true;
13 int digit = asInt(token);
14 if(prev_digit > digit) return false;
15 prev_digit = digit;
16 }while (true);
17 }
18 return false;
19} 
Listing 4: isSorted() returns true if the input is a sorted list of
single digit numbers
The context-free grammar Gmay be written as
G ! {Numbers } (1)
Numbers !Numbers ,Numbers (2)
Numbers !Digit (3)
Digit !0j1j2j3j4j5j6j7j8j9 (4)
which encodes that valid inputs start with an open curly bracket
followed by a comma-separated list of (at least one) digits and a
closing curly bracket. GWF encodes a path condition as regular
expression. For input {1,2} , GWF yields the following constraint
Rto explore the alternative branch where the input does not end in
a curly bracket:
token 1={ (5)
^token 2=Digit (6)
^token 3=, (7)
^token 4=Digit (8)
^token 56=} (9)
where Digit is a symbolic variable. Using a context-free constraint
solver, it is possible to derive an array with three digits that is ac-
cepted by both GandR(e.g., {0,0,0} ). However, since the reg-
ular expression cannot express the arithmetic relationship between
token 2and token 4(i.e.,1<2), a completely different path might
be exercised. This renders GWF both unsound as well as incom-
plete. In contrast, MoWF maintains path conditions as SMT for-
mulas and merely prunes paths that are exercised by inputs that are
invalid w.r.t. the input model. Moreover, the context-free languagewhich encodes the Ô¨Åle format cannot express integrity constraints
such as the checksum or the size of a data chunk. Functions com-
puted over the data in a data Ô¨Åeld, such as a compression algorithm,
cannot be expressed either. Our input models allow to specify in-
tegrity constraints and compression algorithms through the concept
of Fixups and Transformers.
Hybrid Fuzzing . Driller [23] combines the effectiveness of white-
box and the efÔ¨Åciency of blackbox fuzzing. After running the black-
box fuzzer for some time, the whitebox fuzzer is run on the most
promising seed Ô¨Åles produced by the blackbox fuzzer. In contrast to
MoWF, Driller does not leverage information from an input model
to generate more valid Ô¨Åles. Driller does not primarily target such
programs that process highly structured inputs. In this respect, our
approache is orthogonal to Driller. Driller can beneÔ¨Åt from MoWF
when testing programs processing highly structured inputs.
8. DISCUSSION
We introduced Model-based Whitebox Fuzzing (MoWF) as an
automated testing technique for program binaries that process highly
structured inputs. We have observed that certain branches in a Ô¨Åle-
processing program are exercised only depending on i) the presence
of a speciÔ¨Åc data chunk, ii) a speciÔ¨Åc value of a data Ô¨Åeld in a data
chunk, or iii) the integrity of the data chunks. Hence, we extend
HERCULES an existing traditional whitebox fuzzing technique not
only to set speciÔ¨Åc values of the Ô¨Åelds but also to add/remove com-
plete chunks and re-establish their integrity during fuzzing.
Pruning Invalid Paths . We discussed several approaches to prune
the vast search space of invalid inputs, including integrity enforce-
ment and data chunk transplantation and instantiation. As opposed
to Traditional Whitebox Fuzzing (TWF), MoWF is capable of negat-
ing those branches that are exercised only in the presence of certain
data chunks without having to iteratively construct the data chunk
by exploring the parser code. All generated test inputs are valid in
that they adhere to the input model. Integrity constraints are en-
forced. Given a 24hour time budget, our MoWF tool exposed all of
thirteen vulnerabilities in our subject programs while the TWF tool
exposed only six.
Reduced Seed Dependence . We also investigated the dependence
of MoWF on the provided initial seed Ô¨Åles. MoWF can instantiate
the initial seed Ô¨Åles directly from the provided input model. More-
over, given a seed input that is missing a data chunk to reach a target
location, MoWF allows to utilize other seed Ô¨Åles as donors, trans-
plant the missing data chunk, and construct a new seed input that
is closer to the target location. In the absence of a donor, the miss-
ing data chunk can be directly instantiated from the input model.
Out of the thirteen vulnerabilities in our experimental subjects our
MoWF tool exposed nine without any seed inputs .
In summary , MoWF is a promising fuzzing technique for pro-
gram binaries that process highly structured input. It is particularly
helpful when no initial seed Ô¨Åles are available that contain the re-
quired optional data chunks. Given the same time budget, MoWF
can generate more valid test inputs which aids in exposing vulner-
abilities that could not be exposed otherwise.
9. ACKNOWLEDGMENTS
We thank Law Wen Yong for his help with implementation. This
research was partially supported by a grant from DSO National
Laboratories, Singapore, and the National Research Foundation,
Prime Minister‚Äôs OfÔ¨Åce, Singapore under its National Cybersecu-
rity R&D Program (TSUNAMi project, Award No. NRF2014NCR-
NCR001-21) and administered by the National Cybersecurity R&D
Directorate.
55210. REFERENCES
[1] SpeciÔ¨Åcation of the DEFLATE Compression Algorithm.
https://tools.ietf.org/html/rfc1951. Accessed: 2016-02-13.
[2] Tool: IDA multi-processor disassembler and debugger.
https://www.hex-rays.com/products/ida/. Accessed:
2016-04-04.
[3] Tool: Peach Fuzzer Platform.
http://www.peachfuzzer.com/products/peach-platform/.
Accessed: 2016-01-23.
[4] Tool: Peach Fuzzer Platform (Input Model).
http://community.peachfuzzer.com/v3/DataModeling.html.
Accessed: 2016-01-23.
[5] Tool: SPIKE Fuzzer Platform. http://www.immunitysec.com.
Accessed: 2016-01-23.
[6] Tool: Suley Fuzzer. https://github.com/OpenRCE/sulley.
Accessed: 2016-01-23.
[7] G. Banks, M. Cova, V . Felmetsger, K. Almeroth,
R. Kemmerer, and G. Vigna. Snooze: Toward a stateful
network protocol fuzzer. In Proceedings of the 9th
International Conference on Information Security , ISC‚Äô06,
pages 343‚Äì358, 2006.
[8] N. Bjorner and A.-D. Phan. vz - maximal satisfaction with
z3. In T. Kutsia and A. V oronkov, editors, SCSS 2014. 6th
International Symposium on Symbolic Computation in
Software Science , volume 30 of EPiC Series in Computing ,
pages 1‚Äì9, 2014.
[9] M. B√∂hme and S. Paul. On the efÔ¨Åciency of automated
testing. In Proceedings of the 22Nd ACM SIGSOFT
International Symposium on Foundations of Software
Engineering , FSE 2014, pages 632‚Äì642, 2014.
[10] C. Cadar, D. Dunbar, and D. Engler. Klee: Unassisted and
automatic generation of high-coverage tests for complex
systems programs. In Proceedings of the 8th USENIX
Conference on Operating Systems Design and
Implementation , OSDI‚Äô08, pages 209‚Äì224, 2008.
[11] V . Chipounov, V . Kuznetsov, and G. Candea. S2e: A
platform for in-vivo multi-path analysis of software systems.
InProceedings of the Sixteenth International Conference on
Architectural Support for Programming Languages and
Operating Systems , ASPLOS XVI, pages 265‚Äì278, 2011.
[12] L. De Moura and N. Bj√∏rner. Z3: An efÔ¨Åcient smt solver. In
Proceedings of the Theory and Practice of Software, 14th
International Conference on Tools and Algorithms for the
Construction and Analysis of Systems ,
TACAS‚Äô08/ETAPS‚Äô08, pages 337‚Äì340, 2008.
[13] V . Ganesh, T. Leek, and M. Rinard. Taint-based directed
whitebox fuzzing. In Proceedings of the 31st International
Conference on Software Engineering , ICSE ‚Äô09, pages
474‚Äì484, 2009.
[14] P. Godefroid, A. Kiezun, and M. Y . Levin. Grammar-based
whitebox fuzzing. In Proceedings of the 29th ACM
SIGPLAN Conference on Programming Language Design
and Implementation , PLDI ‚Äô08, pages 206‚Äì215, 2008.[15] P. Godefroid, M. Y . Levin, and D. A. Molnar. Automated
whitebox fuzz testing. In Proceedings of the 2008 Network
and Distributed System Security Symposium , volume 8 of
NDSS ‚Äô08 , pages 151‚Äì166, 2008.
[16] I. Haller, A. Slowinska, M. Neugschwandtner, and H. Bos.
Dowsing for overÔ¨Çows: A guided fuzzer to Ô¨Ånd buffer
boundary violations. In Proceedings of the 22Nd USENIX
Conference on Security , SEC‚Äô13, pages 49‚Äì64, 2013.
[17] F. M. Kifetew, R. Tiella, and P. Tonella. Generating valid
grammar-based test inputs by means of genetic programming
and annotated grammars. Empirical Software Engineering ,
pages 1‚Äì34, 2016.
[18] S. Y . Kim, S. Cha, and D.-H. Bae. Automatic and lightweight
grammar generation for fuzz testing. Comput. Secur. ,
36:1‚Äì11, July 2013.
[19] Z. Lin and X. Zhang. Deriving input syntactic structure from
execution. In Proceedings of the 16th ACM SIGSOFT
International Symposium on Foundations of Software
Engineering , SIGSOFT ‚Äô08/FSE-16, pages 83‚Äì93, 2008.
[20] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser,
G. Lowney, S. Wallace, V . J. Reddi, and K. Hazelwood. Pin:
Building customized program analysis tools with dynamic
instrumentation. In Proceedings of the 2005 ACM SIGPLAN
Conference on Programming Language Design and
Implementation , PLDI ‚Äô05, pages 190‚Äì200, 2005.
[21] B. P. Miller, L. Fredriksen, and B. So. An empirical study of
the reliability of unix utilities. Commun. ACM ,
33(12):32‚Äì44, Dec. 1990.
[22] V .-T. Pham, W. B. Ng, K. Rubinov, and A. Roychoudhury.
Hercules: Reproducing crashes in real-world application
binaries. In Proceedings of the 37th International
Conference on Software Engineering - Volume 1 , ICSE ‚Äô15,
pages 891‚Äì901, 2015.
[23] N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang,
J. Corbetta, Y . Shoshitaishvili, C. Kruegel, and G. Vigna.
Driller: Augmenting fuzzing through selective symbolic
execution. In NDSS ‚Äô16 , pages 1‚Äì16, 2016.
[24] Tool. LibPNG Library.
http://www.libpng.org/pub/png/libpng.html. Accessed:
2016-02-13.
[25] Tool. Video Lan Client (VLC).
http://www.videolan.org/index.html. Accessed: 2016-02-13.
[26] T. Wang, T. Wei, G. Gu, and W. Zou. Taintscope: A
checksum-aware directed fuzzing tool for automatic software
vulnerability detection. In Proceedings of the 2010 IEEE
Symposium on Security and Privacy , SP ‚Äô10, pages 497‚Äì512,
2010.
[27] X. Wang, L. Zhang, and P. Tanofsky. Experience report:
How is dynamic symbolic execution different from manual
testing? a study on klee. In Proceedings of the 2015
International Symposium on Software Testing and Analysis ,
ISSTA 2015, pages 199‚Äì210, 2015.
553