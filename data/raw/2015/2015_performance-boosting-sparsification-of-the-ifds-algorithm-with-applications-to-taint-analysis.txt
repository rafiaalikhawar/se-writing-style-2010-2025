Performance-Boosting SparsiÔ¨Åcation of the IFDS
Algorithm with Applications to Taint Analysis
Dongjie He‚àó‚Ä†‚Ä°, Haofeng Li‚Ä†‚Ä°, Lei Wang‚Ä†‚Ä°, Haining Meng‚Ä†‚Ä°,
Hengjie Zheng‚Ä†‚Ä°, Jie Liu‚àó, Shuangwei Hu¬ß, Lian Li‚Ä†‚Ä°$and Jingling Xue‚àó$
‚àóUNSW Sydney, Australia
‚Ä†SKL of Computer Architecture, ICT, CAS, China
‚Ä°University of Chinese Academy of Sciences, China
¬ßVivo AI Lab, China
Abstract ‚ÄîThe IFDS algorithm can be compute- and memory-
intensive for some large programs, often running for a long time(more than expected) or terminating prematurely after some timeand/or memory budgets have been exhausted. In the latter case,the corresponding IFDS data-Ô¨Çow analyses may suffer from falsenegatives and/or false positives. To improve this, we introduce asparse alternative to the traditional IFDS algorithm. Instead of
propagating the data-Ô¨Çow facts across all the program points
along the program‚Äôs (interprocedural) control Ô¨Çow graph, wepropagate every data-Ô¨Çow fact directly to its next possible usepoints along its own sparse control Ô¨Çow graph constructed onthe Ô¨Çy, thus reducing signiÔ¨Åcantly both the time and memoryrequirements incurred by the traditional IFDS algorithm.
In our evaluation, we compare F
LOW DROID , a taint analysis
performed by using the traditional IFDS algorithm, with oursparse incarnation, S
PARSE DROID , on a set of 40 Android apps
selected. For the time budget (5 hours) and memory budget(220GB) allocated per app, S
PARSE DROID can run every app
to completion but F LOW DROID terminates prematurely for 9
apps, resulting in an average speedup of 22.0x. This implies that
when used as a market-level vetting tool, S PARSE DROID can
Ô¨Ånish analyzing these 40 apps in 2.13 hours (by issuing 228 leak
warnings) while F LOW DROID manages to analyze only 30 apps
in the same time period (by issuing only 147 leak warnings).
Index T erms ‚ÄîIFDS, data-Ô¨Çow analysis, taint analysis
I. I NTRODUCTION
The IFDS (Interprocedural, Finite, Distributive, Subset)
data-Ô¨Çow problems formulated in [1] are solved in a widerange of application areas, including model checking [2]‚Äì[5],
program veriÔ¨Åcation [6]‚Äì[8], slicing [9], pointer analysis [10],
dynamic test generation [11], [12], bug detection [13]‚Äì[15],security analysis [16], [17], and taint analysis [18]‚Äì[21]. Insuch an interprocedural data-Ô¨Çow problem, the set of data-Ô¨ÇowfactsDis Ô¨Ånite and the data Ô¨Çow functions (in 2
D/mapsto‚Üí2D)
distribute over the meet operator /intersectionsq(union or intersection).
When formulating the IFDS problems, Reps et al. [1]
introduced a polynomial-time algorithm for solving each asa special kind of graph-reachability problem (reachabilityalong interprocedurally realizable paths). This IFDS algorithmoperates on the interprocedural CFG G
‚àó=(N‚àó,E‚àó)of a
program (consisting of the CFGs for all its functions connectedby call and return edges). Interprocedurally, the data-Ô¨Çow facts
inDare propagated from a callsite to an invoked callee foo
$Corresponding authorinG‚àó(via a call edge to foo ‚Äôs CFG) and then back from the
foo ‚Äôs CFG (via a return edge) to the same callsite, context-
sensitively over a balanced-parentheses language by matchingcall and return edges. Intraprocedurally, the data-Ô¨Çow facts
inDare propagated across the edges in foo ‚Äôs CFG. This
algorithm runs in O(|E
‚àó||D|3)until a Ô¨Åxed point is found.
This classic IFDS algorithm can be compute- and memory-
intensive, as it propagates the data-Ô¨Çow facts across all the
program points along all the edges in G‚àó. Its multi-threaded
versions [19], [22], [23] can speed it up, but still unsatisfac-
torily for some programs. For example, F LOW DROID [19]
includes a multi-threaded IFDS solver that deploys multiplethreads on multiple CPU cores to propagate the data-Ô¨Çowfacts concurrently along different edges in G
‚àó. However, when
applied to perform taint analysis for a set of 2,950 Androidapps on a computer server with 64 Intel Xeon CPU cores
equipped with 730GB RAM, its IFDS solver (with even many
compromises made) can spend 24+ hours on one app byusing all the memory, resulting in 16 apps still unanalyzable[24]. Such premature terminations will cause the underlyinganalysis to report either more false negatives (i.e., miss morebugs) or more false positives (i.e., false warnings) or both.
In practice, static analysis tools have become part of the core
developer workÔ¨Çow in software industries such as Google [25].As part of nightly builds, static analysis tools are expected tobe efÔ¨Åcient, especially for handling large codebases [26].
In this paper, we focus on accelerating the IFDS algo-
rithm [1] by propagating the data-Ô¨Çow facts sparsely rather
than densely in G
‚àó(orthogonally to multi-threaded accelera-
tion). Our key insight is that the traditional IFDS algorithm
propagates too many data-Ô¨Çow facts redundantly across toomany edges in G
‚àóbefore they are actually used, resulting in
excessive time and memory requirements for some programs.We can speed it up signiÔ¨Åcantly if we can cut down its CPUand memory usage. We will achieve this by propagating adata-Ô¨Çow fact sparsely , i.e., directly to its next possible use
points in G
‚àó. The challenge lies in how to identify such ‚Äúnext
possible use points‚Äù for a data-Ô¨Çow fact efÔ¨Åciently, without
losing the performance beneÔ¨Åts reaped from its subsequentsparse propagation. The key novelty here is to build a sparseCFG (SCFG) for each data-Ô¨Çow fact on-demand (i.e., onlywhen needed) to enable its proÔ¨Åtable sparse propagation.
UI*&&&"$.*OUFSOBUJPOBM$POGFSFODFPO"VUPNBUFE4PGUXB SF&OHJOFFSJOH	"4&
¬•*&&&
%0*"4&
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:24:31 UTC from IEEE Xplore.  Restrictions apply. To demonstrate the performance beneÔ¨Åts for sparsifying
the IFDS algorithm, we consider taint analysis for Ô¨Åndinginformation leaks in Android apps, a signiÔ¨Åcant client analysissolved as an IFDS problem. Currently, F
LOW DROID [19]
represents a state-of-the-art tool for solving taint analysis byusing a multi-threaded implementation of the traditional IFDSalgorithm [1]. F
LOW DROID applies its two passes iteratively,
a forward one for discovering more tainted access paths anda backward one for discovering more aliases, until a Ô¨Åxedpoint has been reached. As its sparse alternative, our newtool, S
PARSE DROID , aims to improve its performance by
employing our sparse IFDS algorithm in both of its two passes.
This paper makes the following main contributions:
‚Ä¢We present a new approach for sparsifying the traditional
IFDS problems to accelerate its performance.
‚Ä¢We introduce a sparse IFDS-based taint analysis fordetecting information leaks in Android apps.
‚Ä¢We have evaluated S PARSE DROID against F LOW DROID
(driven by a non-sparse IFDS algorithm) on 40 Androidapps (with 34 from FossDroid [27] and 6 from GooglePlay). Given a time budget (5 hours) and memory budget(220GB) per app, S
PARSE DROID runs every app to
completion but F LOW DROID terminates prematurely for
9 apps, resulting in an average speedup of 22.0x. Thisimplies that when used as a vetting tool, S
PARSE DROID
can Ô¨Ånish analyzing these 40 apps in 2.13 hours byissuing 228 leak warnings while F
LOW DROID analyzes
only 30 apps in the same time period by issuing only 147leak warnings (even if ‚Äútimeout apps‚Äù are ignored).
The rest of the paper is organized as follows. Section II
provides an overview of and motivates our sparse IFDS
analysis. Section III introduces our sparse IFDS framework.Section IV contains a concrete instantiation of our sparseframework for performing sparse taint analysis. Section Vpresents and analyzes our experimental results. Section VIdescribes the limitations of our sparse algorithm. Section VII
discusses the related work. Finally, Section VIII concludes.
II. M
OTIV A TION
We motivate our sparsiÔ¨Åcation of the IFDS algorithm [1]
by considering taint analysis as an instantiation. In Sec-tion II-A, we introduce an example program and Ô¨Ånd itstainted access paths manually. In Section II-B, we describe
how F
LOW DROID [19] does this automatically by applying the
traditional IFDS algorithm. In Section II-C, we explain how
SPARSE DROID , our sparse version of F LOW DROID , works.
A. An Example Program
Let us focus on analyzing foo() in Figure 1, by assuming
thataanda.g passed from its callers are untainted and the
call to A() (line 12) has no effect on our analysis. To Ô¨Ånd
all the tainted accesses manually, we need to keep track of allthe relevant access paths (data-Ô¨Çow facts) Ô¨Çowing along thecontrol Ô¨Çow while also being mindful about their aliases.
Initially, bis tainted in line 2. Then both a.f (an instance
Ô¨Åeld) and A.h (a static variable) are tainted in lines 3 and 4,respectively. However, A.h becomes untainted after each call
toA.bar() (lines 7 and 10) as it is killed in A.bar() .I n
line 14, as a.f is tainted, x.k.f gets tainted. As candxare
aliases, c.k.f is tainted in line 14, too. With k-limiting [28],
all the access paths that are longer than kare truncated.
B.F
LOW DROID : The IFDS-based Taint Analysis
FLOW DROID [19] applies the traditional IFDS algorithm to
solve the taint analysis problem, as illustrated in Figure 1(a).FlowDroid operates on the interprocedural CFG (ICFG), i.e.,
supergraph G
‚àó=(N‚àó,E‚àó)[1], of the program. G‚àóconsists
of the CFGs of all the functions in the program. There are fourtypes of edges. In addition to the normal , i.e., intraprocedural
edges in a CFG, every callsite is connected to a called functionby a call edge ,a return edge , and a call-to-return edge (to
enable the interprocedural data-Ô¨Çows across the callsite). In
actuality, G
‚àóis exploded by associating its edges with all the
data-Ô¨Çow facts (i.e., access paths) in Dtracked during the taint
analysis. The meet operator /intersectionsqused is‚à™as an access path is
considered as tainted at a joint point if it is tainted in any of
incoming control-Ô¨Çow paths. Each edge has a Ô¨Çow functionthat takes the set of old facts arriving at the edge as input andsends the set of new facts across the edge as output.
F
LOW DROID proceeds iteratively by performing two passes
repeatedly, a forward pass for discovering tainted accesses anda backward pass for dicovering aliases, until a Ô¨Åxed point isreached. In the Ô¨Årst forward pass, F
LOW DROID discovers b,
a.f ,A.h ,x.k.f anddto be tainted at different program
points except that A.h becomes untainted after each call to
A.bar() . For example, as a.f is a tainted fact in line 14,
the Ô¨Çow function associated with its edge ending at line 15will cause x.k.f to be tainted. In the IFDS algorithm [1],
0denotes an empty fact allowing new facts to be generated
at a program point (e.g., line 2). As x . k=a is a store,
F
LOW DROID starts a backward pass to search for the aliases
ofx.k.f , Ô¨Ånding c.k.f to be aliased with x.k.f after line
13. For this standard pass, we refer to [19] for more details.
In a subsequent forward pass, c.k.f is propagated forwards
and recognized as being tainted just after line 14.
Two points are made about the traditional IFDS algorithm:
‚Ä¢Dense Propagation of Facts. The traditional IFDS algo-
rithm [1] employed by F LOW DROID propagates many data-
Ô¨Çow facts across many program points redundantly beforethey are actually used, as highlighted by many such solid
dots in Figure 1(a). Take a.f , tainted in line 3, for example.
All the subsequent propagations before it reaches line 9 and14 are a waste of both CPU and memory resources.
‚Ä¢Multi-Threading. In the IFDS framework, all the Ô¨Çow
functions are distributive. As also in [22], [23], F LOW -
DROID [19] takes advantage of multi-threading to process
propagations for different edges in different threads.
C.SPARSE DROID : Our Sparse IFDS-based Taint Analysis
Instead of propagating data-Ô¨Çow facts densely as in F LOW -
DROID based on the traditional IFDS algorithm (Figure 1(a)),
our sparse version, S PARSE DROID , based on our sparse IFDS

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:24:31 UTC from IEEE Xplore.  Restrictions apply.  Class A {  public A() {}
    18  static  void bar(p) {
    19      A.h = ƒä; // kill
    20  }
}  1  void foo(a) {
  2      b = source();
  3      a.f = b;
  4      A.h = b;
  5      if  (ƒä) {
  6          z = a.g;
  7          A.bar(z);
  8      } else {
  9          d = a.f;
10          A.bar(d);
11      }
12      x = new A();
13      c = x;14      x.k = a;
15      sink(a.f);  // tainted
16      sink(A.h); // untainted
17 }
/g1004/g271/g258/g856/g296 /g4/g856/g346/g282
/g1004/g4/g856/g346/g393/g69/g381/g396/g373/g258/g367/g3/g28/g282/g336/g286/g400/g3/g894/g296/g381/g396/g449/g258/g396/g282/g895
/g18/g258/g367/g367/g3/g28/g282/g336/g286/g400
/g18/g258/g367/g367/g882/g410/g381/g882/g90/g286/g410/g437/g396/g374/g3/g28/g282/g336/g286/g400
/g90/g286/g410/g437/g396/g374/g3/g28/g282/g336/g286/g400
/g1004
/g271
/g258/g856/g296
/g4/g856/g346/g282
/g393
/g272/g856/g364/g856/g296/g454/g856/g364/g856/g296
/g454/g856/g364/g856/g296
/g272/g856/g364/g856/g296
/g69/g381/g396/g373/g258/g367/g3/g28/g282/g336/g286/g400/g3/g894/g271/g258/g272/g364/g449/g258/g396/g282/g895
(a) F LOW DROID : non-sparse IFDS-based taint analysis
  1  void foo(a) {
  2      b = source();
  3      a.f = b;
  4      A.h = b;
  5      if  (ƒä) {
  6          z = a.g;
  7          A.bar(z);
  8      } else {
  9          d = a.f;
10          A.bar(d);
11      }
12      x = new A();
13      c = x;
14      x.k = a;
15      sink(a.f);  // tainted
16      sink(A.h); // untainted
17 }
/g1004/g271/g258/g856/g296 /g4/g856/g346/g282
 Class A {  public A() {}
    18  static  void bar(p) {
    19      A.h = ƒä; // kill
    20  }
}
/g1004/g4/g856/g346/g393
/g272/g856/g364/g856/g296/g454/g856/g364/g856/g296
(b) S PARSE DROID : sparse IFDS-based taint analysis
Fig. 1. Comparing non-sparse and sparse IFDS-based taint analysis, by discovering tainted access paths (aliases) in a forward (backward) pass itera tively.

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:24:31 UTC from IEEE Xplore.  Restrictions apply. /g286/g374/g410/g396/g455
/g286/g454/g349/g410/g1007/g855/g3/g258/g856/g296/g3/g1089/g3/g271/g1006/g855/g3/g271/g3/g1089/g3/g400/g381/g437/g396/g272/g286/g894/g895
/g1008/g855/g3/g4/g856/g346/g3/g1089/g3/g271
(a)b/g286/g374/g410/g396/g455
/g286/g454/g349/g410/g1007/g855/g3/g258/g856/g296/g3/g1089/g3/g271
/g1013/g855/g3/g282/g3/g1089/g3/g258/g856/g296
/g1005/g1008/g855/g3/g454/g856/g364/g3/g1089/g3/g258
/g1005/g1009/g855/g3/g400/g349/g374/g364/g894/g258/g856/g296/g895
(b)a.f/g286/g374/g410/g396/g455
/g286/g454/g349/g410/g1008/g855/g3/g4/g856/g346/g3/g1089/g3/g271
/g1005/g1010/g855/g3/g400/g349/g374/g364/g894/g4/g856/g346/g895/g1011/g855/g3/g4/g856/g271/g258/g396/g894/g460/g895 /g1005/g1004/g855/g3/g4/g856/g271/g258/g396/g894/g282/g895
(c)A.h/g286/g374/g410/g396/g455
/g286/g454/g349/g410/g1013/g855/g3/g282/g3/g1089/g3/g258/g856/g296
/g1005/g1004/g855/g3/g4/g856/g271/g258/g396/g894/g282/g895
(d)d/g286/g374/g410/g396/g455
/g286/g454/g349/g410/g1005/g1007/g855/g3/g272/g3/g1089/g3/g454/g1005/g1006/g855/g3/g454/g3/g1089/g3/g374/g286/g449/g3/g4/g894/g895
/g1005/g1008/g855/g3/g454/g856/g364/g3/g1089/g3/g258
(e)x.k/g286/g374/g410/g396/g455
/g286/g454/g349/g410/g1005/g1007/g855/g3/g272/g3/g1089/g3/g454
(f)c.k
Fig. 2. The SCFGs built on-demand by S PARSE DROID for Figure 1(b).
algorithm (Figure 1(b)) will propagate them sparsely, only to
where they are needed, reducing signiÔ¨Åcantly the time andmemory requirements (with much fewer dots remaining now).
Observation 1. Even if the Ô¨Çow function associated with an
edge is not the identity function (which will simply let all factspass through the edge unchanged), many data-Ô¨Çow facts willstill pass through the edge unchanged, without affecting theother facts and being affected by the other facts. In this case,
we can simply propagate such facts sparsely, i.e., directly to
their next possible use points (in the same function).
When propagating a data-Ô¨Çow fact din the CFG G
pof
a function p, we exploit this observation by building on-
demand a sparse CFG (SCFG) for d,Gp,d, as a sub-graph
ofGp, and then propagate dacross its edges instead. For taint
analysis, both its forward and backward passes are sparsiÔ¨Åed.
In addition, all the access paths, v.f1,¬∑¬∑¬∑,v.f 1.f2.¬∑¬∑¬∑.fn
share exactly the same SCFG, Gp,v.f 1(Theorem 2).
SPARSE DROID works sparsely as follows. Let us consider
the Ô¨Årst forward pass. When bis tainted in line 2, S PARSE -
DROID buildsGfoo,bin Figure 2(a), which contains all the
statements where bis used (accessed). According to Gfoo,b,b
should be sent to lines 3 and 4 Ô¨Årst and then directly to the exit
offoo() . Similarly, in line 3, where a.f is tainted, we build
Gfoo,a.fin Figure 2(b), by including the statements where a
ora.f is used. This allows a.f to be propagated directly to
lines 9 and 14. In line 4, we build Gfoo,A.hin Figure 2(c), by
including the statements accessing A.h and all the callsites
infoo() conservatively (since A.h is a global variable). In
line 9, dis tainted, we build Gfoo,din Figure 2(d).
When line 14 is analyzed, x.k.f is tainted. As this is a
store, a backward alias analysis pass is triggered. At this point,we build G
foo,x.kin Figure 2(e) in order to propagate sparsely
all access paths sharing x.k as its preÔ¨Åx (Theorem 2). In line
13, we Ô¨Ånd c.k.f to be aliased with x.k.f .A sc.k.f is
new, we then build Gfoo,c.kin Figure 2(f) in order to propagate
sparsely all access paths abstracted by c.k . Finally, in the last
forward pass, c.k.f is recognized to be tainted in line 14.
A number of salient properties about our sparse IFDS
framework are summarized as follows:‚Ä¢Sparsity. While we sparsify only the intraprocedural anal-
ysis of the IFDS algorithm, our approach can be regardedas being full-sparse. Once propagated from a callsite to acallee, all the data-Ô¨Çow facts are propagated sparsely again.
‚Ä¢On-Demand SCFG Construction. SCFGs are built on-
demand and reused later, reducing the unnecessary over-heads that would be otherwise incurred in a pre-analysis.
‚Ä¢Multi-Threading. SparsiÔ¨Åcation is orthogonal to multi-
threading parallelization. For example, S PARSE DROID has
reduced signiÔ¨Åcantly the number of edges that are concur-
rently processed by multiple threads in F LOW DROID .
‚Ä¢Precision and EfÔ¨Åciency. By sparsifying the IFDS algo-
rithm, we maintain its precision while signiÔ¨Åcantly reducing
its time and memory requirements (despite the small timeand space overheads incurred for managing SCFGs).
III. T
HESPARSE IFDS F RAMEWORK
We describe how to sparsify the classic IFDS framework [1]
in a formal setting. Section III-A reviews the classic IFDSalgorithm [1]. Section III-B describes its sparsiÔ¨Åcation. InSection IV, we will revisit taint analysis as an instantiationand have the opportunities to give some illustrating examples.
A. The Non-Sparse IFDS Framework
In Figure 3, we reproduce the classic IFDS algorithm
from [1] (with a few notational changes). There are threecases, with the Ô¨Årst two cases (lines 13 and 18) responsible forthe interprocedural analysis and the last case (line 25) for theintraprocedural analysis. As discussed in Section II, only the
intraprocedural analysis needs to be sparsiÔ¨Åed. However, for
completeness, we introduce brieÔ¨Çy the entire analysis below.
An instance IP of an IFDS problem is a Ô¨Åve-tuple, IP=
(G
‚àó,D,F,M, /intersectionsq), whereG‚àó=(N‚àó,E‚àó)is the supergraph of
the program, Dis a Ô¨Ånite set of data-Ô¨Çow facts, F‚äÜ2D‚Üí2D
is a set of distributive functions, M:E‚àó‚ÜíFis a map
fromG‚àó‚Äôs edges to data-Ô¨Çow functions (representing typically
traditional transfer functions deÔ¨Åned in terms of GEN andKILL [29]), and the meet operator /intersectionsqis either union or
intersection (depending on the problem modeled).
G
‚àó, known traditionally as the interprocedural CFG (ICFG)
of the program, consists of a collection of CFGs, G1,G2,¬∑¬∑¬∑
(one per function), one of which, Gmain , represents the pro-
gram‚Äôs main() . For a function p, its CFG Gpconsists of a
unique start nodesp, a unique exit nodeep, and the remaining
nodes representing its statements and predicates in the usualmanner. However, a callsite is split into two nodes, a call
node and a return-site node.G
‚àóhas four types of edges. The
ordinary intraprocedural edges in an individual CFG Gpare
called normal edges . For each callsite, with its call-node cand
return-site node r, wherepis called, three edges are included
to capture its interprocedural data-Ô¨Çows: an intraproceduralcall-to-return edge from ctor, an interprocedural call edge
fromctos
p, and an interprocedural return edge fromeptor.
To solve IP context-sensitively as a graph-reachability
problem, G‚àóis extended into an exploded supergraph ,G#
IP=
(N#,E#), where N#=N‚àó√ó(D‚à™{0})andE#=

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:24:31 UTC from IEEE Xplore.  Restrictions apply. Algorithm Tabulate( G#
IP)
1 LetG#
IP=(N#,E#)
2PathEdge ‚Üê{ /angbracketleftsmain,0/angbracketright‚Üí/angbracketleftsmain,0/angbracketright}
3WorkList ‚Üê{ /angbracketleftsmain,0/angbracketright‚Üí/angbracketleftsmain,0/angbracketright}
4S‚Üê‚àÖ
5 ForwardTabulateSLRPs()
6 forn‚ààN‚àódo
7Xn‚Üê{d2‚ààD|‚àÉd1‚àà(D‚à™{0})
s.t./angbracketleftsfun (n),d1/angbracketright‚Üí/angbracketleftn,d 2/angbracketright‚ààPathEdge }
Function Prop(e)
8 ife/‚ààPathEdge then
9 InserteintoPathEdge ; InserteintoWorkList
Function ForwardTabulateSLRPs()
10 whileWorkList /negationslash=‚àÖdo
11 Pop/angbracketleftsp,d1/angbracketright‚Üí/angbracketleftn,d 2/angbracketrightfromWorkList
12 switch n
13 casen‚ààcallsites (p)
14 ford3s.t./angbracketleftn,d 2/angbracketright‚Üí/angbracketleftscallee (n),d3/angbracketright‚ààE#do
15 Prop(/angbracketleftscallee (n),d3/angbracketright‚Üí/angbracketleftscallee (n),d3/angbracketright)
16 ford3s.t./angbracketleftn,d 2/angbracketright‚Üí/angbracketleftretSite (n),d3/angbracketright‚àà(E#‚à™S)do
17 Prop(/angbracketleftsp,d1/angbracketright‚Üí/angbracketleftretSite (n),d3/angbracketright)
18 casen=ep
19 forc‚ààcallers (p)do
20 ford4,d5s.t./angbracketleftc,d 4/angbracketright‚Üí/angbracketleftsp,d1/angbracketright‚ààE#and
/angbracketleftep,d2/angbracketright‚Üí/angbracketleftretSite (c),d5/angbracketright‚ààE#do
21 if/angbracketleftc,d 4/angbracketright‚Üí/angbracketleftretSite (c),d5/angbracketright/‚ààS then
22 Insert/angbracketleftc,d 4/angbracketright‚Üí/angbracketleftretSite (c),d5/angbracketrightintoS
23 ford3s.t./angbracketleftsfun (c),d3/angbracketright‚Üí/angbracketleftc,d 4/angbracketright‚ààPathEdge do
24 Prop(/angbracketleftsfun (c),d3/angbracketright‚Üí/angbracketleftretSite (c),d5/angbracketright)
25 casen‚àà(Np‚àícallsites (p)‚àí{ep})
26 for/angbracketleftm,d 3/angbracketrights.t./angbracketleftn,d 2/angbracketright‚Üí/angbracketleftm,d 3/angbracketright‚ààE#do
27 Prop(/angbracketleftsp,d1/angbracketright‚Üí/angbracketleftm,d 3/angbracketright)
Fig. 3. The IFDS algorithm from [1] (with some notational changes).
{/angbracketleftm,d 1/angbracketright‚Üí/angbracketleftn,d 2/angbracketright|(m,n )‚ààE‚àó,d2‚ààM(m,n )(d1)}. Note
that 0signiÔ¨Åes an empty set of facts (allowing new facts to be
generated at a program point) and M(m,n )‚ààFis the Ô¨Çow
function associated with the edge (m,n )‚ààE‚àó. For efÔ¨Åciency
reasons,G#
IPis usually built from G‚àóat run time.
In Figure 3, an IP is solved with dynamic programming
inO(|E‚àó||D|3). For a function p,callsites (p)is the set of
its call statements and callers (p)is the set of call statements
(inp‚Äôs callers) where pis invoked. For a call statement n,
retSite (n)denotes its return-side node and callee (n)the
function invoked. For a node n‚ààN‚àó,fun(n)identiÔ¨Åes its
containing function. Finally, Ssummarizes the interprocedural
data-Ô¨Çow facts obtained across the function boundaries.
PathEdge records the set of path edges , with each
/angbracketleftsp,d1/angbracketright‚Üí/angbracketleftn,d 2/angbracketrightrepresenting the sufÔ¨Åx of a realizable path
from/angbracketleftsmain,0/angbracketrightto/angbracketleftn,d 2/angbracketright, implying that the path edge from
/angbracketleftsmain,0/angbracketrightto/angbracketleftsp,d1/angbracketrightis realizable. Starting with /angbracketleftsmain,0/angbracketright‚Üí
/angbracketleftsmain,0/angbracketright(line s2‚Äì4 ) , ForwardTabulateSLRPs() col-
lects all possible path edges in PathEdge (line 5) with a
case analysis, by handling (1) the interprocedural data-Ô¨Çows
entering a function (lines 13 ‚Äì 17), (2) the interproceduraldata-Ô¨Çows leaving a function (lines 18 ‚Äì 24), and (3) theintraprocedural data-Ô¨Çows within a function (lines 25 ‚Äì 27).Finally, a data-Ô¨Çow fact d‚ààDexists at a program pointFunction ForwardTabulateSLRPs()
1 whileWorkList /negationslash=‚àÖdo
¬∑¬∑¬∑
2 switch ndo
13 casen‚ààcallsites (p)do
¬∑¬∑¬∑
16 ford3s.t./angbracketleftn,d 2/angbracketright‚Üí/angbracketleftretSite (n),d3/angbracketright‚àà(E#‚à™S)do
17a ifG#
p,d3is not constructed yet, i.e., not in the SCFG cache then
17b BuildG#
p,d3=(N#
p,d,E#
p,d)according to (2)
17c for/angbracketleftn,d 2/angbracketright‚Üí/angbracketleftm/prime,d3/angbracketright‚ààE#
p,d3do
17d Prop(/angbracketleftsp,d1/angbracketright‚Üí/angbracketleftm/prime,d3/angbracketright)
18 casen=epdo
¬∑¬∑¬∑
25 casen‚àà(Np‚àícallsites (p)‚àí{ep})do
26 for/angbracketleft,d3/angbracketrights.t./angbracketleftn,d 2/angbracketright‚Üí/angbracketleft,d3/angbracketright‚ààE#do
27a ifG#
p,d3is not constructed yet, i.e., not in the SCFG cache then
27b BuildG#
p,d3=(N#
p,d,E#
p,d)according to (2)
27c for/angbracketleftn,d 2/angbracketright‚Üí/angbracketleftm/prime,d3/angbracketright‚ààE#
p,d3do
27d Prop(/angbracketleftsp,d1/angbracketright‚Üí/angbracketleftm/prime,d3/angbracketright)
Fig. 4. The sparse IFDS algorithm adapted from Figure 3 with its line
17 (line 27) replaced by lines 17a ‚Äì 17d (lines 27a ‚Äì 27d).
id:ŒªS.S a:ŒªS.{a} f:ŒªS.ifb‚ààSthenS‚à™{a}elseS\{a} z:ŒªS.‚àÖ
0 a b
0 a b0 a b
0 a b0 a b c
0 a b c0 a b
0 a b
Fig. 5. Edge-speciÔ¨Åc Ô¨Çow functions illustrated (with the Ô¨Årst two from [1]).
n‚ààN‚àóiff there exists a realizable path in G#
IPfrom node
/angbracketleftsmain,0/angbracketrightto node/angbracketleftn,d/angbracketright(line s6‚Äì7 ) .
For our taint analysis problem, IP=(G‚àó,D,F,M, /intersectionsq),
Figure 1(a) gives its exploded supergraph. As explained inSection II, Dis the set of access paths, /intersectionsqis‚à™, andFandM
were discussed earlier but will be formalized in Section IV.
B. SparsiÔ¨Åcation
As the IFDS algorithm in Figure 3 spends the majority of its
analysis time on propagating data-Ô¨Çow facts intraprocedurally,it sufÔ¨Åces to sparsify its intraprocedural analysis only. Oursparse algorithm, which is given in Figure 4, is conceptuallysimple and easy to implement as well as both time- and space-
efÔ¨Åcient. Let us describe our sparsiÔ¨Åcation below.
Consider any IFDS problem IP=(G
‚àó,D,F,M, /intersectionsq). Ac-
cording to Observation 1, even if the Ô¨Çow function M(m,n )‚àà
2D/mapsto‚Üí2Dis not the identity function, many data-Ô¨Çow facts
X‚äÜDare propagated through (m,n )unchanged, without
affecting the other facts and being affected by the other facts.Our key insight is to propagate such facts in Xsparsely, i.e.,
directly to their next possible use points (in the same function),thereby reducing both time and space requirements overall.
Figure 5 illustrates a few edge-speciÔ¨Åc Ô¨Çow functions,
which can be understood as traditional transfer functions
composed using GEN and KILL [29]. Here, idis the identity
function, agenerates a new fact abut kills everything else in
S,fgenerates (kills) aifb‚ààS(b/‚ààS), and zkills everything
inS.I fM(m,n )= id, we can avoid propagating all the facts

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:24:31 UTC from IEEE Xplore.  Restrictions apply. along (m,n )by sending them directly to their next use points.
However, even if M(m,n )/negationslash=id, such sparse propagations
are still possible for some facts (as motivated in Figure 1). Toachieve this, we introduce fact-speciÔ¨Åc identity functions.
Letf‚ààF‚äÜ2
D/mapsto‚Üí2Dbe a Ô¨Çow function associated with
edge (m,n ). Letd‚ààDbe a fact. We say that fis ad-speciÔ¨Åc
identity function , denoted f‚â°fd, if the following holds:
‚àÄX‚àà2D:d‚ààX=‚áíd‚ààf(X)
‚àÄX‚àà2D\{d}:f(X)\{d}=f(X‚à™{d})\{d}(1)
For any fact darriving at m,dwill emerge at nwithout being
affected by the other facts by the Ô¨Årst condition, and ddoes
not affect the other facts reaching nby the second condition.
Let us re-examine each Ô¨Çow function (associated with an
edge (m,n )‚ààE‚àó) in Figure 5. As idis an identity function
by itself, idis ad-speciÔ¨Åc identity function for any d.F o r
a,w eh a v e a‚â°aa(asathat reaches mis regenerated and
propagated to n)b u t a/negationslash‚â°ab(asbis killed). For f,i ti sn o t
hard to see that f/negationslash‚â°fa,f/negationslash‚â°fbbut f‚â°fc. Finally, zis not a
d-speciÔ¨Åc identity function for any d(as all facts are killed).
For a call statement n, there is a unique intraprocedural
edge from nto its return-site node, retSite (n). Whether
M(n,retSite (n))is ad-speciÔ¨Åc identity function, where
d‚ààD, depends on the underlying IFDS problem, as will be
discussed in Section IV. Conservatively, we can always assumeM(n,retSite (n))/negationslash‚â°M(n,retSite (n))
dfor every d‚ààD.
Givend‚ààD, we are motivated to propagate dsparsely
across a CFG. Let Gp=(Np,Ep)be the CFG of a function
pinG‚àó. LetG#
p=(N#
p,E#
p)be the exploded CFG of
GpinGIP. We will propagate din a sparse CFG (SCFG),
Gp,d=(Np,d,Ep,d), as a subgraph of Gp. To construct Gp,d,
we construct below its exploded version G#
p,d=(N#
p,d,E#
p,d)
(as a subgraph of G#
p). In practice, Gp,dis actually built Ô¨Årst
and then exploded into G#
p,d. For convenience, we assume the
existence of a pseudo start (exit) node s/prime
p(e/prime
p)i nG#
p, such
thatM(s/prime
p,sp)/negationslash‚â°M(s/prime
p,sp)dandM(ep,e/prime
p)/negationslash‚â°M(ep,e/prime
p)d.
LetPd
p(n1,nk)= def(n0,n1),¬∑¬∑¬∑,(nk,nk+1)be a sparsi-
Ô¨Åable path inG#
p, wherek/greaterorequalslant2, such that (1) M(n0,n1)/negationslash‚â°
M(n0,n1)d, (2)M(ni,ni+1)‚â°M(ni,ni+1)d, where 1/lessorequalslant
i<k , and (3) M(nk,nk+1)/negationslash‚â°M(nk,nk+1)d. Starting at n1,
we will send ddirectly to nkby skipping these intermediate
edges.
The SCFG Gd
p=(N#
p,d,E#
p,d)is deÔ¨Åned as follows:
E#
p,d={(m,d)‚Üí(n,d/prime)‚ààE#
p)|M(m,n )/negationslash‚â°M(m,n )d}
‚à™{(m,d)‚Üí(n,d)|Pd
p(m,n )is sparsiÔ¨Åable }
N#
p,d=/uniontext
(m,d)‚Üí(n,d/prime)‚ààE#
p,d{(m,d)}‚à™{ (n,d/prime)}(2)
For our motivating example, we examined a few SCFGs in
Figure 2 and will discuss them in more detail in Section IV.
Frequently, many facts share the same SCFG (as motivated
in Section II and discussed further in Section IV). If Gp,d1=
Gp,d2, then the same SCFG is shared by d1andd2.
We can now understand our sparse algorithm given in
Figure 4 easily. For reasons of symmetry, it sufÔ¨Åces to explainits lines 27a ‚Äì 27d. Whenever the non-sparse IFDS algorithm‰£É‰£í‰£ç‰£É‰£Æ‰£´‰££‰£µ
‰¢¢‰£É‰£∞‰££‰£Æ‰£ª‰£µ‰£´‰£µ‰£ñ‰££‰£´‰£∞‰£∂
‰¢¢‰£É‰£∞‰££‰£Æ‰£ª‰£µ‰£´‰£µ‰£ï‰£≤‰££‰£¥‰£µ‰£ß
‰£ã‰£à‰£Ü‰£ï
‰¢¢‰£ï‰£±‰£Æ‰£∏‰£ß‰£¥
‰£ï‰£≤‰££‰£¥‰£µ‰£ß‰¢¢‰£Ö‰£à‰£â‰¢¢
‰£Ö‰££‰£•‰£™‰£ß‰£Ñ‰£∑‰£´‰£Æ‰£¶‰¢¢
‰£ï‰£Ö‰£à‰£â‰£µ‰£î‰£ß‰£≤‰£±‰£¥‰£∂/g90/g286/g410/g437/g396/g374/g3/g4/g367/g349/g258/g400/g3/g47/g374/g296/g381/g396/g373/g258/g410/g349/g381/g374
/g90/g286/g395/g437/g286/g400/g410/g3/g4/g367/g349/g258/g400/g3/g47/g374/g296/g381/g396/g373/g258/g410/g349/g381/g374
/g94/g18/g38/g39
/g24/g258/g410/g258/g882/g38/g367/g381/g449/g3/g38/g258/g272/g410/g400/g47/g18/g38/g39 /g62/g286/g258/g364/g400
Fig. 6. The workÔ¨Çow of S PARSE DROID .
is just about to propagate a fact d3at nodemdensely (line 27
of Figure 3), our sparse algorithm propagates d3on its own
SCFGG#
p,d3(built on the Ô¨Çy but reused subsequently) sparsely.
Theorem 1 (Correctness) .The sparse algorithm (Figure 4)
computes the same results as the non-sparse one (Figure 3).
Proof Sketch. Follows from the fact that every data-Ô¨Çow fact
d3is now propagated sparsely in G#
p,d3(Figure 4) rather than
densely in G#
p(Figure 3) by skipping only the statements that
are irrelevant as far as d3is concerned by (1) ‚Äì (2).
IV . T HESPARSE TAINT ANALYSIS
We describe an instantiation of our sparse algorithm for
Ô¨Ånding tainted accesses in Android apps. Figure 6 depicts
SPARSE DROID , our sparse version of F LOW DROID [19]. We
reuse F LOW DROID ‚Äôs modules, ‚ÄúTaint Analysis‚Äù and ‚ÄúAlias
Analysis‚Äù, for discovering tainted accesses and aliases in the
forward and backward passes, respectively (Section II). The
three modules with the light gray background are added byus to support sparse analysis. The ‚ÄúSparse IFDS Solver‚Äùimplements our sparse IFDS algorithm (Figure 4), which ismulti-threaded exactly as in F
LOW DROID . The ‚ÄúSparse CFG
Cache‚Äù manages all the SCFGs constructed so far while the‚ÄúBuild SCFGs‚Äù module constructs an SCFG for a data-Ô¨Çowfact on the Ô¨Çy if it not cached yet according to (2).
For the IFDS-based taint analysis, let us revisit its Ô¨Åve-tuple:
IP=(G
‚àó,D,F,M, /intersectionsq). In Figure 6, G‚àóis the ICFG, i.e.,
supergraph provided to the analysis. Note that Dis the set of
access paths and /intersectionsqis‚à™. In Section II, we discussed informally
the Ô¨Çow functions in Fthat are mapped to the edges in G‚àó
byM. In this section, we will deÔ¨Åne what Mis precisely.
Section IV-A introduces the intermediate representation (IR)
used. Section IV-B formalizes the Ô¨Çow functions used for taint
analysis. Section IV-C discusses SCFG construction.
A. Intermediate Representation
Table I gives eight kinds of statements used in our IR.
By convention, x=defx0,¬∑¬∑¬∑,xn‚àí1is a possibly empty
list of elements. To handle both virtual and static callsuniformly, a virtual call a
0.foo(a1,¬∑¬∑¬∑,an‚àí1)is written as
foo(a0,¬∑¬∑¬∑,an‚àí1)and a static call T.foo (a0,¬∑¬∑¬∑,an‚àí1)is
written as foo(a0,...,a n‚àí1)by dropping the irrelevant T.
All local variables are assumed to be in SSA form [30],
resulting in the Phi instruction being used as is standard.

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:24:31 UTC from IEEE Xplore.  Restrictions apply. a=source(){0}
{0,a.‚àó}a=source (){v.¬Øf}v/negationslash=a
{v.¬Øf}[SOURCE ]a=...{v.¬Øf}v=a
{}[KILL]
a=new T (){v.¬Øf}v/negationslash=a
{v.¬Øf}[NEW ]a=b{v.¬Øf}v=b
{v.¬Øf,a. ¬Øf}a=b{v.¬Øf}v/‚àà{a,b}
{v.¬Øf}[ASSIGN ]
a2=œÜ(a0,a1){v.¬Øf}v‚àà{a0,a1}
{v.¬Øf,a 2.¬Øf}a2=œÜ(a0,a1){v.¬Øf}v/‚àà{a0,a1,a2}
{v.¬Øf}[PHI]
a=Œæ.f/prime(Œæ‚àà{b,T}){v.¬Øf}v=Œæ‚àßcar(¬Øf)=f/prime
{v.¬Øf,a. cdr(¬Øf)}a=Œæ.f/prime(Œæ‚àà{b,T}){v.¬Øf}v/negationslash=a‚àß(v/negationslash=Œæ‚à®car(¬Øf)/negationslash=f/prime)
{v.¬Øf}[LOAD ]
Œæ.f/prime=b(Œæ‚àà{a,T}){v.¬Øf}
v=b
{v.¬Øf,Œæ.f/prime.¬Øf}Œæ.f/prime=b(Œæ‚àà{a,T}){v.¬Øf}
v=Œæ‚àßcar(¬Øf)=f/prime
{}Œæ.f/prime=b(Œæ‚àà{a,T}){v.¬Øf}v/negationslash=b‚àß(v/negationslash=Œæ‚à®car(¬Øf)/negationslash=f/prime)
{v.¬Øf}[STORE ]
r=foo(¬Øa){v.¬Øf}
v=aiai‚àà¬Øapiisai/primescorresponding formal parameter in foo
{pi.¬Øf}r=foo(¬Øa){v.¬Øf}v/‚àà¬Øa
{}r=foo(¬Øa){T.¬Øf}
{T.¬Øf}[CALL ]
r=foo(¬Øa){v.¬Øf}v‚àà¬Øa‚à®v=T
{}r=foo(¬Øa){v.¬Øf}v/‚àà¬Øa‚à™{r}‚àßv/negationslash=T
{v.¬Øf}[CALL -TO-RETURN ]
retfoor{v.¬Øf}v=pi
piisfoo ‚Äôs formal parameter aiispi/primescorresponding actual argument
{ai.¬Øf}retfoor0{v.¬Øf}v=r0
r1=foo(¬Øa)‚ààcallers (foo)
{r1.¬Øf}retfoor{T.¬Øf}
{T.¬Øf}[RETURN ]
Fig. 7. The Ô¨Çow functions for taint analysis operating on the IR given in Table I (with the alias analysis performed orthogonally [19] as illustrated in Figure 1).
TABLE I
INTERMEDIA TE REPRESENTA TION FOR TAINT ANALYSIS .
Name Instruction Name Instruction
Source a=source () Phi a2=œÜ(a0,a1)
New a=new T () Assign a=b
Loada=b.fStorea.f=b
a=T.f T.f=b
Call r=foo(a) Return return pr
B. Flow Functions
Figure 7 gives all the Ô¨Çow functions used for taint analysis
in our IR. In the IFDS framework, a Ô¨Çow function F‚àà
2D/mapsto‚Üí2D, whereDis the set of access paths, distributes
over the meet operator /intersectionsq:F(X)=/intersectionsqx‚ààXF({x}). Given a
Ô¨Çow function Fassociated with a control-Ô¨Çow edge from a
statement sat a source node to a statement s/primeat a target node
in the CFG, a rule for smaps the singleton fact set {x}on
entry of stoF({x})on entry of s/prime. (Ifxis tainted, then
F({x})contains all the tainted facts by s.) For a non-source
statement, F(0)= 0is omitted. For a list x,car(x)and cdr(x)
return the Ô¨Årst and the rest of the list, respectively. To simplifythe presentation of our rules, v.
fdenotes an access path (i.e.,
a local variable) vor a Ô¨Åeld access v.f1.¬∑¬∑¬∑.fn, wheren/greaterorequalslant1andT.fdenotes an access path T.f 1.¬∑¬∑¬∑.fn, wheren/greaterorequalslant1.
The rules for handling non-call statements are simple. At
a tainted source, a = source(), a.‚àósigniÔ¨Åes that aand all its
associated access paths are tainted. In [LOAD ]and [STORE ],
ifv.f=v.‚àó, then car(‚àó)=f/primeis assumed to hold always and
a.cdr(‚àó)=a.‚àó. Now, consider the three rules for handling a
call statement, [CALL ],[CALL -TO-RETURN ]and [RETURN ].
There are two cases in handling r=foo(a). A fact that is
a static variable, T.f , is propagated to its entry and then its
exit (if it remains tainted at the end). A fact that is an instancevariable, v.f , is handled in the same way if vis one of foo ‚Äôs
arguments and propagated to the call‚Äôs return node otherwise.
C. SCFG Construction
As motivated in Section II, we will construct an SCFG G
p,d
on-demand for every new fact dgenerated when a function p
is analyzed. Our sparse IFDS algorithm given in Figure 4 willthen operate on G
#
p,d, which is exploded from Gp,daccording
to (2) during the sparse analysis (Section III-B).
For a given IFDS problem, many facts may have identical
SCFGs. For taint analysis, we rely on the following theorem.
Theorem 2. LetŒæ.f1.¬∑¬∑¬∑.fnbe an access path, where Œæ‚àà
{a,T}. ThenGp,Œæ.f 1=Gp,Œæ.f 1,¬∑¬∑¬∑,fi, wherepis any function.
Proof. Follows from Figure 7 (as all the Ô¨Åeld accesses in the
IR are limited to only a single Ô¨Åeld as shown in Table I).

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:24:31 UTC from IEEE Xplore.  Restrictions apply. Therefore, we only need to build SCFGs for three types of
data-Ô¨Çow facts: (1) a local variable v, (2) a Ô¨Åeld access v.f,
and (3) a global variable T.f. LetGp=(Np,Ep)be the CFG
of a function p. To build these SCFGs (according to (2)), it
is just a simple matter of going through the Ô¨Çow functions
M(m,n )for all the edges (m,n )‚ààEand checking to see if
each is a fact-speciÔ¨Åc identity function or not (by (1)):
‚Ä¢Gp,v.M(m,n )/negationslash‚â°M(m,n )viffvappears in the statement
at nodem. In this case, Gp,vconsists of all the nodes in
Gp, wherevis referred to (Figures 2(a) and (d)).
‚Ä¢Gp,v.f .M(m,n )/negationslash‚â°M(m,n )v.fiff the statement at m
refers tovalone (without a Ô¨Åeld access) or v.f. Thus,Gp,v.f
consists of all such nodes in Gp(Figures 2(b), (e) and (f)).
‚Ä¢Gp,T.f .M(m,n )/negationslash‚â°M(m,n )T.fiff the statement at mac-
cessesT.f or is a callsite (as T.f may be killed indirectly).
Thus,Gp,T.f consists of all such nodes in Gp(Figure 2(c)).
Finally, there is one F LOW DROID -speciÔ¨Åc implementation
detail concerning when to ‚Äúactivate‚Äù aliases as being tainted.
Consider Figure 1 again. During a forward analysis, x.k.f is
found to be tainted by x . k=a in line 14. Then a backward
pass is started to search for its aliases. In line 13, c.k.f is
found as an alias. In a subsequent forward pass, c.k.f is
propagated forward and recognized as being tainted after ithas passed x . k=a , its so-called activation statement .
In S
PARSE DROID , we propagate c.k.f inGfoo,c.kshown
in Figure 2 rather than Gfoo. If its activation statement x.k
=a does not appear in Gfoo,c.k, which is true in this case, we
can simply activate c.k.f in the Ô¨Årst nodes in Gfoo,c.kthat
are reachable from this activation statement in Gfoo(along its
outgoing paths). The exit in Gfoo,c.k(andGfoo) satisÔ¨Åes this
condition. Note that by construction, c.k.f will simply be
propagated through lines 15 and 16 before reaching the exit.
V. E V ALUA TION
We demonstrate the signiÔ¨Åcant performance beneÔ¨Åts
achieved by our sparse IFDS algorithm by comparing S PARSE -
DROID and F LOW DROID for solving taint analysis in Android
apps as a major application. Our sparse analysis is fairly gen-eral. Other possible applications include pointer analysis [10],typestate analysis [31], uninitialized variables [1], constantpropagation [32], and Android compatibility detection [33].
For the taint analysis problem as motivated in Figure 1,
F
LOW DROID [19] relies on the traditional non-sparse IFDS
algorithm (Figure 3) while S PARSE DROID takes advantage of
our sparse IFDS algorithm (Figure 4). By Theorem 1, S PARSE -
DROID is equivalent to F LOW DROID in terms of their preci-
sion (i.e., leak-Ô¨Ånding capability) except that S PARSE DROID
is sparse. We have validated the correctness of S PARSE DROID
by extensive benchmarking. In the case of D ROID BENCH [34]
(containing small unit tests with each consisting of dozens oflines of code), for example, S
PARSE DROID has successfully
passed all the test cases that F LOW DROID has passed (with
a caveat on implicit data Ô¨Çows discussed in Section VI). We
will therefore focus on evaluating the performance advantages
of S PARSE DROID over F LOW DROID , by using relatively large
Android benchmarks and real-world Android apps.Our evaluation, as described below, will attempt to address
the following four research questions:
‚Ä¢RQ1. Is S PARSE DROID faster?
‚Ä¢RQ2. Is S PARSE DROID more memory-efÔ¨Åcient?
‚Ä¢RQ3. Is the sparse IFDS algorithm effective?
‚Ä¢RQ4. Is the on-demand SCFG construction effective?
A. Experimental Setup
a)Implementation: For F LOW DROID , we use its latest
version ( 0967ca2 ) [35] implemented in Soot [36]. S PARSE -
DROID is a sparse version (Figure 6). Given an app, its Dalvik
bytecode is converted into Soot‚Äôs Shimple IR in SSA form,operated on by both tools. In F
LOW DROID , all access paths
are abstracted with k-limiting with k=5 (by default). We
also use its source and sink deÔ¨Ånitions for taint analysis.
b)Benchmarks: We have selected 40 Android apps,
with 34 from Fossdroid [27], an alternate web interface for theF-Droid repository [37], and 6 from Google Play. From Foss-droid, we pick randomly 2 apps from the top 20 most popularapps in each of its 17 categories. Note that Graphics has 17
Apps in total. From Google Play , we obtain pokemongo
(a game app), word (a Microsoft Word app), outlook (a
Microsoft Outlook app), reader (an Adobe Acrobat reader),
bk (a Burger King app), and oeffi (a journey planner).
c)Platform: Our experiments are done on an Intel
Xeon E5-1660 v4 CPUs (3.20GHz) server with 256GB RAM,running Ubuntu 16.04.4 LTS (Xenial Xerus). For JVM, we
set the maximum heap size as 220GB (with -Xmx ). For both
tools, we turn on --mergedexfiles to enable analyzing
multiple dex Ô¨Åles for an app and use the -dt option to set 5
hours as the per-app time budget for their IFDS solvers. Asour platform has 8 cores, 8 threads are used to process all thepath edges in WorkList in Figures 3 and 4.
d)Results: Table II contains the results for F
LOW DROID
(FD) and S PARSE DROID (SD). The analysis time of an app is
the average of 3 runs. As indicated in its caption, F LOW DROID
terminates prematurely in 9 apps (with 3 running out of timeand 6 running out of memory). However, S
PARSE DROID has
successfully run every app to completion within the timeand memory budgets given. For each app (Columns 1 ‚Äì 4),we compare their analysis times (Columns 5 ‚Äì 7) for RQ1,
memory usage (Columns 8 ‚Äì 10) for RQ2, and #PathEdges
solved (Columns 11 ‚Äì 13) for RQ3. Finally, we examine SCFGconstruction (Columns 14 ‚Äì 17) for RQ4.
B. RQ1: Speedups
As shown in Columns 5 ‚Äì 7 of Table II, S
PARSE DROID is
signiÔ¨Åcantly faster than F LOW DROID , with the speedups rang-
ing from 1.1x to 357.3x averaged to 22.0x. So S PARSE DROID
outperforms F LOW DROID in every single app evaluated.
The largest speedup (357.3x) occurs on nya.miku.
wishmaster , for which F LOW DROID spends 15,561.2 sec-
onds to analyze it while S PARSE DROID spends only 43.6 sec-
onds. For org.gateshipone.odyssey exhibiting the second
largest speedup (94.0x), F LOW DROID terminates prematurely

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:24:31 UTC from IEEE Xplore.  Restrictions apply. TABLE II
PERFORMANCE OF FLOW DROID (FD) AND SPARSE DROID (SD). F LOW DROID RUNS OUT OF TIME IN THREE APPS WITH THEIR ANALYSIS TIMES
INDICA TED IN BLUE INCOLUMN 5AND OUT OF MEMORY IN SIX APPS WITH THEIR MEMORY USAGE MARKED WITH OOM INCOLUMN 8.
Category App V ersion Apk(MB)Analysis Time (s) Memory Usage (GB) #PathEdges SCFG Construction
FD SD FD/SD FD SD FD/SD FD SD FD/SD #SCFGs #Acc Paths Time/SD (%) Time/FD (%)
Connectivitybe.mygod.vpnhotspot 2.3.0 2.2 1,597.2 213.8 7.5 59.3 28.6 2.1 181,752,020 5,912,330 30.7 15,877 100,434 0.58 0.08
ca.cmetcalfe.locationshare 1.3.2 0.9 14,495.5 318.7 45.5 OOM 33.1 -826,787,619 8,621,141 95.9 17,454 170,923 0.48 0.01
Developmentorg.csploit.android 1.6.5 3.5 8.4 5.5 1.5 9.6 8.4 1.1 422,510 75,183 5.6 2,140 3,686 6.43 4.18
de.k3b.android.contentproviderhelper 1.3.1.1 0.6 0.3 0.1 2.2 0.3 0.4 0.7 9,715 1,056 9.2 107 117 29.29 13.06
Gamescom.ghstudios.android.mhgendatabase 2.3.1 8.8 0.2 0.1 1.3 0.5 0.4 1.2 2,148 492 4.4 154 176 38.26 28.95
net.ddns.mlsoftlaberge.trycorder 5.2.3 8.6 0.2 0.1 1.4 0.4 0.3 1.3 3,491 893 3.9 147 184 17.36 12.73
Graphicsrodrigodavy.com.github.pixelartist 3.1 1.8 2,066.6 97.9 21.1 71.7 29.7 2.4 190,149,877 3,105,457 61.2 13,678 101,537 1.27 0.06
uk.co.richyhbm.monochromatic 0.8.1 1.6 731.8 30.9 23.7 33.6 14.7 2.3 93,158,144 1,380,304 67.5 9,167 51,312 2.90 0.12
Internetnya.miku.wishmaster 1.5.0 3.5 15,561.2 43.6 357.3 190.9 13.7 13.9 893,798,548 2,318,824 385.5 8,917 30,905 4.43 0.01
acr.browser.lightning 4.5.1 2.6 77.6 25.4 3.1 38.5 15.8 2.4 12,819,994 1,948,356 6.6 6,595 39,651 4.09 1.34
Moneyorg.totschnig.myexpenses 3.0.1.2 11.0 910.6 31.6 28.8 72.9 17.9 4.1 159,482,692 1,533,402 104.0 7,583 49,693 2.71 0.09
com.igisw.openmoneybox 3.2.2.10 2.1 581.6 24.3 24.0 56.8 12.1 4.7 154,478,524 2,246,178 68.8 4,139 33,830 25.70 1.07
Multimediacom.poupa.vinylmusicplayer 0.20.1 4.4 32.3 6.4 5.0 8.6 2.8 3.1 4,029,184 143,505 28.1 2,192 7,036 6.13 1.22
org.gateshipone.odyssey 1.1.17 2.5 12,727.9 135.3 94.0 OOM 26.7 -858,074,482 4,232,587 202.7 16,325 131,838 1.02 0.01
Navigationcom.ilm.sandwich 2.2.4f 3.1 6.9 2.5 2.7 1.0 1.4 0.7 690,044 45,712 15.1 1,485 3,189 8.99 3.30
com.vonglasow.michael.satstat 3.3 2.5 8.3 0.8 10.1 12.7 0.6 21.2 1,388,430 21,673 64.1 785 2,282 62.41 6.21
Phone&SMSopencontacts.open.com.opencontacts 12 2.0 1.4 1.3 1.1 0.6 1.1 0.5 43,904 16,918 2.6 370 1,149 6.71 6.31
com.github.yeriomin.dumbphoneassistant 0.5 0.3 4.1 1.4 2.9 4.0 2.1 1.9 443,527 68,756 6.5 359 2,204 12.11 4.23
Readingnightlock.peppercarrot 1.0.1 4.2 0.6 0.2 2.9 1.0 0.4 2.5 26,660 2,012 13.3 300 425 37.19 12.82
org.decsync.sparss.Ô¨Çoss 1.13.4 2.1 7,943.5 698.5 11.4 OOM 42.2 -515,547,655 26,471,883 19.5 9,542 66,115 0.19 0.02
Sci&Educom.ichi2.anki 2.8.4 8.3 19.0 8.8 2.2 3.4 6.2 0.5 2,724,681 221,191 12.3 7,420 14,741 15.77 7.27
com.luk.timetable2 6.0.4 2.8 0.2 0.1 1.3 1.0 0.9 1.1 1,753 298 5.9 71 73 20.00 15.51
Securitycom.kunzisoft.keepass.libre 2.5.0.0beta18 7.3 6.9 0.7 9.3 14.8 1.0 14.8 1,002,449 20,218 49.6 622 1,863 13.88 1.49
eu.faircode.netguard 2.229 2.5 11,034.6 589.5 18.7 OOM 17.5 -935,368,414 14,070,780 66.5 15,290 235,259 0.31 0.02
Sports&Healthorg.openpetfoodfacts.scanner 2.9.8 6.0 18,001.5 492.1 36.6 113.1 70.7 1.6 210,096,647 13,678,491 15.4 11,036 111,064 0.21 0.01
org.secuso.privacyfriendlyactivitytracker 1.0.5 2.3 1.6 0.5 3.0 2.1 1.1 1.9 122,544 13,950 8.8 647 1,818 13.26 4.43
Systemdk.jens.backup 0.3.4-universal 6.2 8.8 6.0 1.4 2.5 2.0 1.2 789,556 149,990 5.3 456 2,329 1.31 0.90
com.github.axet.callrecorder 1.6.44 5.0 720.9 41.6 17.3 37.8 64.2 0.6 87,534,226 1,708,053 51.2 5,309 12,226 2.53 0.15
Themingorg.materialos.icons 2.1 8.5 3.2 0.4 7.7 4.4 0.8 5.5 282,413 2,255 125.2 108 108 58.21 7.54
org.adw.launcher 1.3.6 1.2 4.5 1.5 3.0 6.1 0.8 7.6 504,404 34,408 14.7 1,204 1,353 17.39 5.74
Timename.myigel.fahrplan.eh17 1.33.16 2.0 24.5 6.8 3.6 8.1 2.2 3.7 3,600,853 135,206 26.6 1,933 5,874 6.45 1.78
com.app.Zensuren 1.21 0.2 8.0 2.9 2.7 7.9 1.7 4.6 1,765,179 177,806 9.9 2,452 4,958 37.08 13.56
Writingcom.orgzly 1.7 4.7 9,482.5 1,700.6 5.6 OOM 49.7 -733,494,539 31,728,506 23.1 38,715 545,207 0.16 0.03
org.secuso.privacyfriendlytodolist 2.1 2.4 8.4 1.5 5.4 1.6 1.3 1.2 928,849 62,544 14.9 956 5,884 11.54 2.13
GooglePlaycom.nianticlabs.pokemongo 0.139.3 97.0 18,002.5 380.9 47.3 123.2 47.4 2.6 321,729,505 11,194,524 28.7 9,134 107,311 0.14 0.00
com.microsoft.ofÔ¨Åce.word 16.0.11425.20132 71.0 257.6 28.1 9.2 70.8 8.8 8.0 29,801,488 343,827 86.7 3,466 16,023 1.39 0.15
com.microsoft.ofÔ¨Åce.outlook 3.0.46 70.0 18,001.9 1,069.6 16.8 122.3 79.2 1.5 498,296,938 21,980,834 22.7 52,165 413,532 0.96 0.06
com.adobe.reader 19.2.1.9183 61.0 603.3 78.2 7.7 46.9 26.9 1.7 72,006,192 1,715,234 42.0 21,671 41,509 2.13 0.28
com.emn8.mobilem8.nativeapp.bk 5.0.10 11.0 10,228.3 1,451.9 7.0 OOM 66.9 -947,632,966 19,234,574 49.3 34,870 321,775 0.15 0.02
de.schildbach.oefÔ¨Å 10.5.3-google 2.1 312.2 14.8 21.1 18.9 6.1 3.1 50,630,514 405,221 124.9 7,388 23,337 6.79 0.32
after 12,727.9 seconds after running out of memory, S PARSE -
DROID takes only 135.3 seconds to run it to completion.
For opencontacts.open.com.opencontacts (with
the smallest speedup, 1.1x), com.ghstudios.android.
mhgendatabase (1.3x), com.luk.timetable2 (1.3x),
and net.ddns.mlsoftlaberge.trycorder (1.4x), the
performance beneÔ¨Åts from our sparse analysis are small.These apps can be analyzed by both tools within 1.5 seconds.
For
org.openpetfoodfacts.scanner ,com.nianti-
clabs.pokemongo andcom.microsoft.office.outlook ,
FLOW DROID times out for a 5-hour time budget given, but
SPARSE DROID has Ô¨Ånished analyzing these three apps in 8.2
mins, 6.3 mins, and 17.8 mins, respectively.
C. RQ2: Memory Requirements
As shown in Columns 8 ‚Äì 10 of Table II (also plotted
in Figure 8), F LOW DROID consumes more memory than
SPARSE DROID for all the 40 apps except for the Ô¨Åve marked
inbold font in Column 9 (discussed below), In particular,FLOW DROID runs out of memory for the six apps marked
with OOM in Column 8. In contrast, S PARSE DROID can Ô¨Ånish
analyzing all the 40 apps by consuming a maximum of 79.2GBmemory. For each app, we consider the maximum amount ofmemory used. This is calculated by using Java Runtime APIs.
With the six OOM apps excluded, the memory us-
age ratios of F
LOW DROID over S PARSE DROID range
from 0.5x ( com.ichi2.anki ) to 21.2x ( com.vonglasow.
michael.satstat ) with an average of 3.7x.
Let us examine the Ô¨Åve apps for which S PARSE DROID uses
more memory than F LOW DROID .F o r de.k3b.android.
contentproviderhelper ,com.ilm.sandwich andopen-
contacts.open.com.opencontacts , the extra amount of
memory used is small. In each case, the total amountof memory used by S
PARSE DROID is below 1.5GB. For
com.ichi2.anki andcom.github.axet.callrecorder ,
SPARSE DROID uses about twice memory as F LOW DROID , due
to the extra space taken by the SCFG cache used.

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:24:31 UTC from IEEE Xplore.  Restrictions apply. 1 3 5 7 911 13 15 17 19 21 23 25 27 29 31 33 35 37 39Avg050100150200OoM OoM OoM OoM OoM OoMMemory (GB)FlowDroid SparseDr oid
Fig. 8. Memory usage of F LOW DROID and S PARSE DROID for the 40 apps.
D. RQ3: Effectiveness of Sparse Analysis
As discussed in Sections V-B and V-C, S PARSE DROID is
signiÔ¨Åcantly faster and more memory-efÔ¨Åcient than F LOW -
DROID . The key reason is that F LOW DROID , which uses the
traditional IFDS algorithm in Figure 3, solves a signiÔ¨Åcantly
larger number of path edges (#PathEdges) than S PARSE -
DROID , which uses a sparse version in Figure 4, for an app,
as shown in Columns 11 ‚Äì 13 of Table II. The ratios of
FLOW DROID ‚Äôs #PathEdges over S PARSE DROID ‚Äôs #PathEdges
range from 2.6x to 385.5x with an average of 49.5x. As
motivated in Figure 1, solving an IFDS problem sparsely cuts
down substantially both the time and memory required.
In each IFDS algorithm, WorkList contains all the path
edges for an app to be solved by its IFDS solver. Figure 9
shows thatFLOW DROID/primes Non‚àíSparse IFDS Solver Time
SPARSE DROID/primes Sparse IFDS Solver Timecorrelates
well positively withFLOW DROID/primes#PathEdges
SPARSE DROID/primes#PathEdgesacross the 40
apps with both axes drawn in the log2scale. The three
blue‚äï‚Äôs represent the three apps for which F LOW DROID
runs out of time and the six red‚äó‚Äôs represent the six apps
for which F LOW DROID runs out of memory. The two blue
‚äï‚Äôs (org.openpetfoodfacts.scanner andcom.nianti-
clabs.pokemongo ) deviate slightly from the projected trend,
yielding better than expected speedups (Table II), possibly dueto excessive system resources consumed by F
LOW DROID .
Note that there is no correlation between the speedup of
SPARSE DROID over F LOW DROID achieved for an Android
app with its bytecode size. This is as expected since the
effectiveness of S PARSE DROID depends on the tainted sources
present in the app and their data dependent statements tracked(Figure 7) with aliases considered, which are all accurately
reÔ¨Çected by the percentage of #PathEdges reduced (Figure 9).
When used as a vetting tool, S
PARSE DROID can analyze all
the 40 apps in 7678 seconds (2.13 hours) by issuing 228 leakwarnings. By analyzing these apps (lexicographically) for thesame time period, F
LOW DROID can only analyze 30 apps by
issuing only 147 leak warnings even if the nine apps for which
FLOW DROID runs out of either time or memory are ignored.
E. RQ4: On-Demand SCFG Construction
As a sparse version of F LOW DROID ,S PARSE DROID per-
forms its taint analysis on-demand, by detecting the leaks froma set of speciÔ¨Åed sources to a set of speciÔ¨Åed sinks in an app.
As such, our on-demand SCFG construction has turned outto be effective, by building the SCFGs for only the access
paths encountered (Figure 1), as shown in Columns 14 ‚Äì 17 ofTable II. For each app, ‚Äú#SCFGs‚Äù gives the number of SCFGsbuilt and ‚Äú#Acc Paths‚Äù gives the number of access paths seen(i.e., the number of SCFGs that would have been built ifTheorem 2 were not applied). In addition, ‚ÄúTime/SD (%)‚Äù and‚ÄúTime/FD (%)‚Äù give the percentages of the SCFG contructiontime over the total analysis times spent by S
PARSE DROID and
FLOW DROID , respectively (plotted in Figure 10 graphically).
Certainly, SCFG construction incurs overheads, ranging
from 0.14% to 62.4% with an average of 11.9% over S PARSE -
DROID ‚Äôs analysis time but only from 0.0% to 29.0% with
an average of 3.3% over F LOW DROID ‚Äôs analysis time. As
highlighted in bold font in the last Column of Table II, out of
the six apps with double-digit percentage overheads (relativeto F
LOW DROID ),com.app.Zensuren is the only one taking
over 1 second for F LOW DROID to analyze. In this case,
despite 1.08 seconds taken in building SCFGs, S PARSE DROID
has reduced F LOW DROID ‚Äôs analysis time from 8 seconds to
2.9 seconds, achieving still a speedup of 2.7x. Overall, theoverheads incurred in SCFG construction are signiÔ¨Åcantly
more than offset by the performance beneÔ¨Åts reaped.
VI. L
IMITA TIONS
This work can be further improved in a number of di-
rections. First, just like the traditional IFDS algorithm [1],
our sparse IFDS algorithm (Figure 4) is applicable only tothe IFDS data-Ô¨Çow problems. Second, by making F
LOW -
DROID [19] sparse, our tool S PARSE DROID (Figure 6) is
also limited to detecting only the information leaks caused
by explicit data Ô¨Çows (via data-dependent assignments). Howto track the sensitive information Ô¨Çowing implicitly throughcontrol-dependent assignments (i.e. if (H) then L :=
true; else L := false ) [38], [39] is beyond the scope
of this paper. Third, on-demand SCFG construction may
introduce performance penalties for small CFGs. However,by applying this to all the CFGs in an app, the performancebeneÔ¨Åt seems to signiÔ¨Åcantly more than offset the overheadsincurred. Finally, the Ô¨Åndings reported in this paper may bedependent on the set of Android apps selected.
VII. RELA TED WORK
IFDS data-Ô¨Çow analyses are widely used in software testing,
program veriÔ¨Åcation, program understanding and maintenance,
and compiler optimization. Reps et al. [1] initially introduced
an efÔ¨Åcient framework for solving the IFDS problems andsubsequently generalized it to the IDE framework [32] forinterprocedural distributed environment problems, where thedataÔ¨Çow facts are maps (‚Äúenvironments‚Äù) from some Ô¨Ånite
set of symbols to some (possibly inÔ¨Ånite) set of values.
Later, Naeem et al. [22] give several extensions, makingit applicable to a wider class of interprocedural data-Ô¨Çowproblems, and also introduced a concurrent alternative im-plemented based on Scala‚Äôs actor framework. W ALA [40]contains a memory-efÔ¨Åcient bit-vector-based IFDS algorithm.
Recently, Bodden [23] has provided a generic (multi-threaded)

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:24:31 UTC from IEEE Xplore.  Restrictions apply. 123456789123456789
6HQr.`QB/«∂b LQM@aT`b2 A6.a bQHp2` f aT`b2.`QB/«∂b aT`b2 A6.a aQHp2` U log2V6HQr.`QB/«∂b OSi?1/;2b f
aT`b2.`QB/«∂b OSi?1/;2b U log2V
Fig. 9. Correlating #PathEdges with their solving time in an IFDS framework.
1 3 5 7 911 13 15 17 19 21 23 25 27 29 31 33 35 37 39Avg010203040506070SCFG Construction / FlowDroid SCFG Construction / SparseDroid
Fig. 10. Percentage of the time spent by S PARSE DROID on building SCFGs
on-demand over the total analysis time by each tool for an app.
implementation of a generic IFDS/IDE solver in Soot [36].
While the prior work [22], [23] takes advantage of multi-threading to accelerate IFDS analyses, this work exploits theirsparsity to improve their performance in an orthogonal way.
Sparse analysis has also been successfully applied in pointer
analysis. Hardekopf et al. speed up Ô¨Çow-sensitive pointeranalysis for C by employing a sparse data-Ô¨Çow graph ratherthan a dense control Ô¨Çow graph, initially for top-level variables[41] and then for also address-taken variables [42]. Sui etal. detect memory leaks in C programs by using a sparsevalue-Ô¨Çow graph that captures def-use chains and value Ô¨Çowsvia assignments for all memory locations represented by bothtop-level and address-taken variables [43] and also performdemand-driven Ô¨Çow- and context-sensitive pointer analysis
for C programs sparsely [44]. Unlike these earlier efforts
(focussing on standard pointer analysis algorithms), this paperrepresents the Ô¨Årst work for sparsifying the IFDS algorithm,
by constructing sparse CFGs on-demand instead of during a
pre-analysis in order to boost its performance signiÔ¨Åcantly.
Recently, synchronized pushdown systems are investigated
as an alternative to the traditional storeless k-limited access
path model for supporting pointer and data-Ô¨Çow analysis [45].Their pushdown systems contain many redundant rules, which
can be sparsiÔ¨Åed similarly to achieve performance gains.
Taint analysis is a form of data-Ô¨Çow analysis aiming at
secure information Ô¨Çow. Given Android‚Äôs popularity, manytaint analysis tools exist, including Amandroid [46], DidFail
[47], DroidSafe [48], EvoTaint [49], F
LOW DROID [19] and
IccTA [20], among which F LOW DROID remains to be a state-
of-the-art static taint analysis tool [50]. However, F LOW -
DROID , with its taint analysis performed in an IFDS/IDE
framework [23], is still compute- and memory-intensive [24],[51]. By sparsifying the traditional IFDS algorithm used, theperformance of F
LOW DROID has been signiÔ¨Åcantly improved.
VIII. CONCLUSION
We have introduced a sparse analysis to scale the IFDS
algorithm signiÔ¨Åcantly by reducing its time and memoryrequirements. We have demonstrated that our sparse IFDSalgorithm can improve substantially the scalability of taint
analysis, one of the most important interprocedural data-Ô¨Çow
analyses, on a range of Android apps. By constructing sparseCFGs on the Ô¨Çy for the data-Ô¨Çow facts propagated in boththe forward taint analysis and backward alias analysis phasesin the sparse IFDS framework, we have observed signiÔ¨Åcantperformance improvements. In future work, we plan to furtherreduce memory space consumed by taint analysis. We will alsoapply our sparse IFDS algorithm to other data-Ô¨Çow analyses.
A
CKNOWLEDGEMENT
We would like to thank all the reviewers for their valuable
inputs. This work is supported by the National Key R&Dprogram of China (No. 2016YFB1000201), the Innovation Re-search Group of National Natural Science Foundation of China(No. 61521092), the National Natural Science Foundation of
China (U1736028 and 61872043), and Australian Research
Council Grants (DP170103956 and DP180104069).

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:24:31 UTC from IEEE Xplore.  Restrictions apply. REFERENCES
[1] T. Reps, S. Horwitz, and M. Sagiv, ‚ÄúPrecise interprocedural dataÔ¨Çow
analysis via graph reachability,‚Äù in Proceedings of the 22nd ACM
SIGPLAN-SIGACT symposium on Principles of programming languages ,
1995, pp. 49‚Äì61.
[2] T. Ball and S. K. Rajamani, ‚ÄúBebop: A symbolic model checker for
boolean programs,‚Äù in International SPIN Workshop on Model Checking
of Software , 2000, pp. 113‚Äì130.
[3] B. Hackett, M. Das, D. Wang, and Z. Yang, ‚ÄúModular checking for
buffer overÔ¨Çows in the large,‚Äù in Proceedings of the 28th international
conference on Software engineering , 2006, pp. 232‚Äì241.
[4] D. Beyer, T. A. Henzinger, R. Jhala, and R. Majumdar, ‚ÄúThe software
model checker BLAST,‚Äù International Journal on Software Tools for
Technology Transfer , vol. 9, no. 5-6, pp. 505‚Äì525, 2007.
[5] T. Ball, B. Cook, V . Levin, and S. K. Rajamani, ‚ÄúSLAM and static
driver veriÔ¨Åer: Technology transfer of formal methods inside Microsoft,‚Äù
inInternational Conference on Integrated F ormal Methods , 2004, pp.
1‚Äì20.
[6] M. Das, S. Lerner, and M. Seigle, ‚ÄúESP: Path-sensitive program veriÔ¨Å-
cation in polynomial time,‚Äù in Proceedings of the ACM SIGPLAN 2002
Conference on Programming Language Design and Implementation ,
2002, pp. 57‚Äì68.
[7] S. J. Fink, E. Yahav, N. Dor, G. Ramalingam, and E. Geay, ‚ÄúEffective
typestate veriÔ¨Åcation in the presence of aliasing,‚Äù ACM Transactions on
Software Engineering and Methodology , vol. 17, no. 2, p. 9, 2008.
[8] S. Grebenshchikov, N. P . Lopes, C. Popeea, and A. Rybalchenko,
‚ÄúSynthesizing software veriÔ¨Åers from proof rules,‚Äù in Proceedings of
the 33rd ACM SIGPLAN Conference on Programming Language Designand Implementation , 2012, pp. 405‚Äì416.
[9] Y . Li, T. Tan, Y . Zhang, and J. Xue, ‚ÄúProgram Tailoring: Slicing
by Sequential Criteria,‚Äù in 30th European Conference on Object-
Oriented Programming (ECOOP 2016) , ser. Leibniz International
Proceedings in Informatics (LIPIcs), S. Krishnamurthi and B. S.Lerner, Eds., vol. 56. Dagstuhl, Germany: Schloss Dagstuhl‚ÄìLeibniz-Zentrum fuer Informatik, 2016, pp. 15:1‚Äì15:27. [Online]. Available:http://drops.dagstuhl.de/opus/volltexte/2016/6109
[10] J. Sp ¬®ath, L. Nguyen Quang Do, K. Ali, and E. Bodden, ‚ÄúBoomerang:
Demand-driven Ô¨Çow- and context-sensitive pointer analysis for Java,‚Äù inLIPIcs-Leibniz International Proceedings in Informatics , vol. 56, 2016.
[11] P . Godefroid, ‚ÄúCompositional dynamic test generation,‚Äù in Proceedings
of the 34th Annual ACM SIGPLAN-SIGACT Symposium on Principlesof Programming Languages , 2007, pp. 47‚Äì54.
[12] D. Babi ¬¥c, L. Martignoni, S. McCamant, and D. Song, ‚ÄúStatically-
directed dynamic automated test generation,‚Äù in Proceedings of the 2011
International Symposium on Software Testing and Analysis , 2011, pp.
12‚Äì22.
[13] R. Manevich, M. Sridharan, S. Adams, M. Das, and Z. Yang, ‚ÄúPSE:
Explaining program failures via postmortem static analysis,‚Äù in Pro-
ceedings of the 12th ACM SIGSOFT Twelfth International Symposiumon F oundations of Software Engineering , 2004, pp. 63‚Äì72.
[14] S. Hallem, B. Chelf, Y . Xie, and D. Engler, ‚ÄúA system and language for
building system-speciÔ¨Åc, static analyses,‚Äù in Proceedings of the ACM
SIGPLAN 2002 Conference on Programming Language Design andImplementation , 2002, pp. 69‚Äì82.
[15] G. Wassermann and Z. Su, ‚ÄúStatic detection of cross-site scripting
vulnerabilities,‚Äù in 2008 ACM/IEEE 30th International Conference on
Software Engineering , 2008, pp. 171‚Äì180.
[16] A. P . Fuchs, A. Chaudhuri, and J. S. Foster, ‚ÄúSCanDroid: Automated
security certiÔ¨Åcation of Android,‚Äù Tech. Rep., 2009.
[17] D. Octeau, P . McDaniel, S. Jha, A. Bartel, E. Bodden, J. Klein,
and Y . Le Traon, ‚ÄúEffective inter-component communication mappingin Android: An essential step towards holistic security analysis,‚Äù inPresented as part of the 22nd {USENIX}Security Symposium , 2013,
pp. 543‚Äì558.
[18] O. Tripp, M. Pistoia, S. J. Fink, M. Sridharan, and O. Weisman, ‚ÄúTAJ:
Effective taint analysis of web applications,‚Äù in Proceedings of the 30th
ACM SIGPLAN Conference on Programming Language Design and
Implementation , 2009, pp. 87‚Äì97.
[19] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel, J. Klein,
Y . Le Traon, D. Octeau, and P . McDaniel, ‚ÄúFlowdroid: Precise context,
Ô¨Çow, Ô¨Åeld, object-sensitive and lifecycle-aware taint analysis for Androidapps,‚Äù in Proceedings of the 35th ACM SIGPLAN Conference onProgramming Language Design and Implementation , 2014, pp. 259‚Äì
269.
[20] L. Li, A. Bartel, T. F. Bissyand ¬¥e, J. Klein, Y . Le Traon, S. Arzt,
S. Rasthofer, E. Bodden, D. Octeau, and P . McDaniel, ‚ÄúIccTA: Detectinginter-component privacy leaks in Android apps,‚Äù in Proceedings of the
37th International Conference on Software Engineering-V olume 1 , 2015,
pp. 280‚Äì291.
[21] S. Guarnieri, M. Pistoia, O. Tripp, J. Dolby, S. Teilhet, and R. Berg,
‚ÄúSaving the world wide web from vulnerable JavaScript,‚Äù in Proceedings
of the 2011 International Symposium on Software Testing and Analysis ,
2011, pp. 177‚Äì187.
[22] N. A. Naeem, O. Lhot ¬¥ak, and J. Rodriguez, ‚ÄúPractical extensions to the
IFDS algorithm,‚Äù in International Conference on Compiler Construction ,
2010, pp. 124‚Äì144.
[23] E. Bodden, ‚ÄúInter-procedural data-Ô¨Çow analysis with IFDS/IDE and
Soot,‚Äù in Proceedings of the ACM SIGPLAN International Workshop
on State of the Art in Java Program analysis , 2012, pp. 3‚Äì8.
[24] V . Avdiienko, K. Kuznetsov, A. Gorla, A. Zeller, S. Arzt, S. Rasthofer,
and E. Bodden, ‚ÄúMining apps for abnormal usage of sensitive data,‚ÄùinProceedings of the 37th International Conference on Software
Engineering-V olume 1 , 2015, pp. 426‚Äì436.
[25] C. Sadowski, J. V an Gogh, C. Jaspan, E. S ¬®oderberg, and C. Winter,
‚ÄúTricorder: Building a program analysis ecosystem,‚Äù in Proceedings of
the 37th International Conference on Software Engineering-V olume 1 ,
2015, pp. 598‚Äì608.
[26] R. Potvin and J. Levenberg, ‚ÄúWhy Google stores billions of lines of code
in a single repository,‚Äù Communications of the ACM , vol. 59, no. 7, pp.
78‚Äì87, 2016.
[27] (2019) Fossdroid. [Online]. Available: https://fossdroid.com/
[28] O. G. Shivers, ‚ÄúControl-Ô¨Çow analysis of higher-order languages of
taming lambda,‚Äù Ph.D. dissertation, 1991.
[29] G. A. Kildall, ‚ÄúA uniÔ¨Åed approach to global program optimization,‚Äù in
Proceedings of the 1st Annual ACM SIGACT-SIGPLAN Symposium onPrinciples of Programming Languages , 1973, pp. 194‚Äì206.
[30] F. Chow, S. Chan, S.-M. Liu, R. Lo, and M. Streich, ‚ÄúEffective
representation of aliases and indirect memory operations in SSA form,‚ÄùinInternational Conference on Compiler Construction , 1996, pp. 253‚Äì
267.
[31] J. Sp ¬®ath, K. Ali, and E. Bodden, ‚ÄúIdeal: EfÔ¨Åcient and precise alias-
aware dataÔ¨Çow analysis,‚Äù Proceedings of the ACM on Programming
Languages , vol. 1, no. OOPSLA, p. 99, 2017.
[32] M. Sagiv, T. Reps, and S. Horwitz, ‚ÄúPrecise interprocedural dataÔ¨Çow
analysis with applications to constant propagation,‚Äù Theoretical Com-
puter Science , vol. 167, no. 1-2, pp. 131‚Äì170, 1996.
[33] D. He, L. Li, L. Wang, H. Zheng, G. Li, and J. Xue, ‚ÄúUnderstanding
and detecting evolution-induced compatibility issues in android apps,‚ÄùinProceedings of the 33rd ACM/IEEE International Conference on
Automated Software Engineering , 2018, pp. 167‚Äì177.
[34] (2019) DroidBench: an open test suite for evaluating the effectiveness
of taint-analysis tools speciÔ¨Åcally for Android apps. [Online]. Available:https://github.com/secure-software-engineering/DroidBench
[35] (2019) FlowDroid. [Online]. Available: https://github.com/
secure-software-engineering/FlowDroid
[36] R. V all ¬¥ee-Rai, P . Co, E. Gagnon, L. Hendren, P . Lam, and V . Sundaresan,
‚ÄúSoot: A Java bytecode optimization framework,‚Äù in CASCON First
Decade High Impact Papers , 2010, pp. 214‚Äì224.
[37] (2019) Free and open source Android app repository. [Online].
Available: https://f-droid.org
[38] D. King, B. Hicks, M. Hicks, and T. Jaeger, ‚ÄúImplicit Ô¨Çows: Can‚Äôt
live with ‚Äòem, can‚Äôt live without ‚Äòem,‚Äù in International Conference on
Information Systems Security , 2008, pp. 56‚Äì70.
[39] P . Barros, R. Just, S. Millstein, P . Vines, W. Dietl, M. dAmorim, and
M. D. Ernst, ‚ÄúStatic analysis of implicit control Ô¨Çow: Resolving JavareÔ¨Çection and android intents,‚Äù in 2015 30th IEEE/ACM International
Conference on Automated Software Engineering (ASE) , 2015, pp. 669‚Äì
679.
[40] (2019) W ALA: T.J. Watson Libraries for Analysis. [Online]. Available:
http://wala.sourceforge.net/
[41] B. Hardekopf and C. Lin, ‚ÄúSemi-sparse Ô¨Çow-sensitive pointer analysis,‚Äù
inProceedings of the 36th Annual ACM SIGPLAN-SIGACT Symposium
on Principles of Programming Languages , 2009, pp. 226‚Äì238.
[42] ‚Äî‚Äî, ‚ÄúFlow-sensitive pointer analysis for millions of lines of code,‚Äù in
Proceedings of the 9th Annual IEEE/ACM International Symposium onCode Generation and Optimization , 2011, pp. 289‚Äì298.

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:24:31 UTC from IEEE Xplore.  Restrictions apply. [43] Y . Sui, D. Ye, and J. Xue, ‚ÄúStatic memory leak detection using full-
sparse value-Ô¨Çow analysis,‚Äù in Proceedings of the 2012 International
Symposium on Software Testing and Analysis , 2012, pp. 254‚Äì264.
[44] Y . Sui and J. Xue, ‚ÄúOn-demand strong update analysis via value-
Ô¨Çow reÔ¨Ånement,‚Äù in Proceedings of the 2016 24th ACM SIGSOFT
International Symposium on F oundations of Software Engineering , ser.
FSE 2016, 2016, pp. 460‚Äì473.
[45] J. Spth, ‚ÄúSynchronized pushdown systems for pointer and data-Ô¨Çow
analysis,‚Äù Ph.D. dissertation, University of Paderborn, Germany, 2019.
[46] F. Wei, S. Roy, X. Ou et al. , ‚ÄúAmandroid: A precise and general
inter-component data Ô¨Çow analysis framework for security vetting ofAndroid apps,‚Äù in Proceedings of the 2014 ACM SIGSAC Conference
on Computer and Communications Security , 2014, pp. 1329‚Äì1341.
[47] W. Klieber, L. Flynn, A. Bhosale, L. Jia, and L. Bauer, ‚ÄúAndroid taint
Ô¨Çow analysis for app sets,‚Äù in Proceedings of the 3rd ACM SIGPLAN
International Workshop on the State of the Art in Java Program Analysis ,2014, pp. 1‚Äì6.
[48] M. I. Gordon, D. Kim, J. H. Perkins, L. Gilham, N. Nguyen, and
M. C. Rinard, ‚ÄúInformation Ô¨Çow analysis of Android applications inDroidSafe,‚Äù in NDSS , vol. 15, 2015, p. 110.
[49] H. Cai and J. Jenkins, ‚ÄúLeveraging historical versions of Android apps
for efÔ¨Åcient and precise taint analysis,‚Äù in Proceedings of the 15th
International Conference on Mining Software Repositories , 2018, pp.
265‚Äì269.
[50] F. Pauck, E. Bodden, and H. Wehrheim, ‚ÄúDo Android taint analysis
tools keep their promises?‚Äù in Proceedings of the 2018 26th ACM Joint
Meeting on European Software Engineering Conference and Symposiumon the F oundations of Software Engineering , 2018, pp. 331‚Äì341.
[51] W. Huang, Y . Dong, A. Milanova, and J. Dolby, ‚ÄúScalable and precise
taint analysis for Android,‚Äù in Proceedings of the 2015 International
Symposium on Software Testing and Analysis , 2015, pp. 106‚Äì117.

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:24:31 UTC from IEEE Xplore.  Restrictions apply. 