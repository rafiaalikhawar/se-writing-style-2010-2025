Towards Practical Program Repair with On-Demand Candidate
Generation
Jinru Hua, Mengshi Zhang, Kaiyuan Wang and Sarfraz Khurshid
The University of Texas at Austin, USA
{lisahua,mengshi.zhang,kaiyuanw,khurshid}@utexas.edu
ABSTRACT
Effectiveprogramrepairtechniques,whichmodifyfaultyprograms
tofixthemwithrespecttogiventestsuites,cansubstantiallyreduce
the cost of manual debugging. A common repair approach is to
iterativelyfirstgeneratecandidateprogramswithpossiblebugfixes
andthenvalidatethemagainstthegiventestsuntilacandidatethat
passes all the tests is found. While this approach is conceptually
simple, due to the potentially high number of candidates that need
to first be generated and then be compiled and tested, existingrepairtechniquesthatembodythisapproachhaverelativelylow
effectiveness, especially for faults at a fine granularity.
To tackle this limitation, we introduce a novel repair technique,
SketchFix,whichgeneratescandidatefixes ondemand (asneeded)
duringthetestexecution.Insteadofiterativelyre-compilingand
re-executing each actual candidate program, SketchFix translates
faulty programs to sketches, i.e., partial programs with “holes”, and
compiles each sketch once which may represent thousands of con-
crete candidates. With the insight that the space of candidates can
be reduced substantially by utilizing the runtime behaviors of the
tests, SketchFix lazily initializes the candidates of the sketches
whilevalidating them against the test execution.
WeexperimentallyevaluateSketchFixontheDefects4Jbench-
mark and the experimental results show that SketchFix works
particularlywellinrepairingbugswithexpressionmanipulation
attheASTnode-levelgranularitycomparedtootherprogramre-
pairtechniques. Specifically,SketchFixcorrectlyfixes19outof
357defectsin23minutesonaverageusingthedefaultsetting.Inad-dition,SketchFixfindsthefirstrepairwith1.6%ofre-compilations
(#compiledsketches/#candidates) and3.0% ofre-executionsout of
all repair candidates.
ACM Reference Format:
Jinru Hua, Mengshi Zhang, Kaiyuan Wang and Sarfraz Khurshid. 2018.
Towards Practical Program Repair with On-Demand Candidate Generation.
InICSE’18: ICSE ’18:40th InternationalConference onSoftware Engineering
, May 27-June 3, 2018, Gothenburg, Sweden. ACM, New York, NY, USA,
12 pages. https://doi.org/10.1145/3180155.3180245
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5638-1/18/05...$15.00
https://doi.org/10.1145/3180155.31802451 INTRODUCTION
Manually debugging faulty code is often tedious and costly, and
itselferror-prone.Thelastdecadehasseenmuchprogressinthe
area of program repair, which has shown much promise for au-
tomating debugging to reduce its cost and increase its effective-
ness [2,11,19,23,29,32,45,46,54]. A common approach for auto-
matedprogramrepairis generate-and-validate [22,25,30,55,56,58],
where several candidate programs that represent potential bug
fixesareiterativelygeneratedusingrepairtemplates,andvalidated
against the given tests until a candidate that passes all tests is
found.Whiletechniquesthatembodythisapproachhaveshown
theireffectivenessonrepairinganumberof defectsusingvarious
search algorithms [ 21,43,55,56], a limiting characteristic of these
techniques,especiallyforrepairingfaultsatafinegranularity,is
that they require potentially many candidates to first be generated
and then be compiled and tested. The costs of compilation and test
execution are non-trivial [ 26,31,55], especially for open source
projectsliketheClosurecompiler[ 4],whichtakesaround1minute
forthecompilationandthetestexecution.Givenatypicalsearch
spaceofrepaircandidates(around5k),thetotalre-compilationand
re-execution time can be as long as 3 days.
To allow the exploration of large numbers of candidates, re-
searchershavedevelopedvarioustechniquesinpreviouswork.For
example,sometechniques[ 7,24,36,37,40]inferconstraintsand
synthesizerepairsbytranslatingtheconstraintstopropositional
satisfiability (SAT) formulas. Such translation-based synthesis may
involveincompletetranslationsorcreateimpracticalproblemsthat
require creating complex models for all involved libraries. More-over, they generally exclusively reason about
booleanorinteger
type [24,37] and can hardly handle manipulation of non-primitive-
type expressions in presence of libraries or complex constructs
like AST node-level type casting. Some techniques mine historical
data [25,28,30] or analyze documents [ 27,58] to rank the repair
candidates. These techniques have shown their effectiveness on
someclassesofdefectslikeexceptionhandling,yettheymaynot
be effective at repairs that require fine-grained expression manipu-
lations at the AST node-level.
We present SketchFix, which is a novel technique for more
effective generate-and-validate program repair using a perspective
differentfrompreviouswork.Ourkeyinsightisthatthespaceof
candidateprogramscanbeprunedsubstantiallybyutilizingrun-
time information and by generating candidates on-demand during
testvalidation.Toillustrate,considertryingtofixafaultycondition
inawhile-loopaswellasthebodyoftheloop;ifatestexecution
raisesanexceptionuponevaluatingaspecificcandidatewhile-loop
condition,allcandidatesofthewhile-loopbodyareprunedfrom
search for that choice of the candidate condition expression. In
fact, our approach for lazy candidate generation will not create any
122018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:49:35 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Jinru Hua, Mengshi Zhang, Kaiyuan Wang and Sarfraz Khurshid
candidates for the while-loop body (which may contain thousands
of patches) if the while-loop body is not executed. When a test
fails due to either a runtime exception or a test assertion failure,thepartsof the candidate program that were directly executed
determinethegenerationofthefuturecandidates.Insteadofthe
traditionalapproachofiterativelygeneratingandvalidatingeach
repaircandidate,wetightlyintegratethegenerationandvalidation
ofcandidates byeffectivelyutilizing runtimebehaviorsof thetest
executionstoprunealargepartofthesearchspace,whichmustbe
explored otherwise.
At the AST node-level, SketchFix performs a systematic re-
duction of programrepair to programsynthesis [10, 18, 41,51] by
translatingafaultyJavaprogramtosketches[ 16,50],whichwillbe
completedbyasynthesizer[ 13]withrespecttothegiventestsuite.
GivenafaultyJavaprogramandatestsuiteasinput,SketchFix
introducesholestosuspiciousstatementsbasedontheASTnode-
level transformation schemas. To fill in these holes, SketchFixemploys a practical sketch engine called EdSketch [
13] to syn-
thesizesketcheswithbacktrackingsearch.WheneverEdSketch
encounters runtime exceptions or test failures, it backtracks imme-
diatelyandfetchesforthenextchoiceuntilthespaceofcandidates
is exhausted or a complete program that satisfies all tests is found.
Thiscompleteprogramisregardedasarepairfortheoriginalfaulty
program.
SketchFix defines transformation schemas at a fine granularity
and prioritizes first the schemas that introduce smaller perturba-
tionstotheoriginalprogram.Recenttechniquespresenttheinsight
thatpatchesthataresemanticallyclosertotheoriginalprograms
aremorelikelytobecorrectfromtheperspectiveofthedevelop-
ers[5,24].Ourrankingstrategyisinlinewiththisinsightandaims
to mitigate the overfitting issue [49] in automated program repair.
We evaluate SketchFix using Defects4J [ 20]—a dataset that
hasbeen widelyusedtoevaluate automatedprogramrepair tech-
niques. With default setting, SketchFix correctly fixes 19 out of357 bugs in 23 minutes on average. It additionally fixes 15 faults
with alternative settings, such as applying more transformation
schemas,etc.Furthermore,wecompareSketchFixwithotherre-
pair techniques and illustrate favored defect classes for different
automated program repair approaches. With on-demand candidate
generation,SketchFixrequiresonly1.6%ofre-compilations(#com-piledsketches/#candidates)and3%ofre-executionsoutofallrepair
candidates when it finds the first repair. Lastly, we demonstrate
that our find-grained transformation schemas are able to generate
high-quality patches by introducing AST node-level edits to the
original programs.
In summary, we make the following contributions:
•On-DemandCandidateGenerationforProgramRepair. Uti-
lizing runtime behaviors, we lazily generate on-demand candi-
datesduringthetestexecutionformorepracticalprogramrepair.
This integration of the generation and the validation phases sub-
stantially prunes the search space of the repair candidates.
•ASTnode-levelProgramRepair WedesignasetofASTnode-
level transformation schemas to repair faulty programs at a fine
granularity. This strategy is effective for generating high-quality
patches that are semantically closer to the original programs.•PracticalReductionofProgramRepairtoSynthesis. With-
outinferringconstraintsorcreationofconstraintsolvingprob-
lemsforSAT/SMTsolvers,wetransformthefaultysubjectstosketchesandsynthesizecodetocompletethesketchesusinga
backtracking search-based sketch system. Our evaluation shows
that this reduction from program repair to program synthesis
helps build effective and well-founded repair techniques.
2 MOTIVATING EXAMPLE
(A) Part of the human-written patch to fix the Chart14 defect
1.public class CategoryPlot extends Plot...{...
2. public boolean removeDomainMarker (...,boolean notify) {3. ArrayList markers;
4. if (...) {...} else {
5.+ if (markers == null)6.+ return false;
7. ...} }
(B) A sketch generated by SketchFix and synthesized solutions
1.public class CategoryPlot extends Plot...{...
2. public boolean removeDomainMarker (...,boolean notify) {
3. ArrayList markers;
4. if (...) {...} else {5. if(SketchFix.COND(ArrayList.class,new Object[]{markers,..}))
6. return (Boolean) SketchFix.EXP(Boolean.class,
new Object[]{markers,..};
7. ...} }
// Synthesized solution:
// SketchFix.COND: markers==null,...// SketchFix.EXP: false,...
Figure1:AnIllustrativeExampleforaFaultandtheRepair
Generated by SketchFix
To illustrate the large search space of repair candidates, we
present a part of a defect derived from the JFreeChart project [ 17].
Figure 1 (A) presents a human-written patch to fix this part of the
bug that omits the null pointer checking for an ArrayList object
(markers). The class CategoryPlot contains 49 fields and 5 local
variables (54 candidates in total). Given a suspicious location, if an
automatedrepairtool wantstoinsertan if-conditionandareturn
statement to fix the bug, without considering field dereferences
derived from the variables and visible fields inherited from parent
classes, the space of candidates for the if-condition alone can be
more than5k. We defineconditions as leftand righthand side ex-
pressions combined with a relational operator (either “==” or “!=”)
for non-primitive types, thus the space is 542×2. The returnex-
pressionhasanother15candidateswiththe booleantypeincluding
the default boolean values ( trueandfalse). Given an average com-
pilationandtest-executiontimeof15secondsfortheJFreeChart
project, it takes more than 15 days to validate all 87k candidates.
Toeffectivelyexplorethislargesearchspaceofrepaircandidates,
SketchFixtranslatesthefaultyprogramtosketcheswithholesand
synthesizes sketches with on-demand candidate generation. Given
13
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:49:35 UTC from IEEE Xplore.  Restrictions apply. Towards Practical Program Repair with On-Demand Candidate Generation ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
asuspiciouslocation,SketchFixappliesASTnode-leveltransfor-
mation schemas to generate a set of sketches, and each sketch
can represent thousands of concrete repair candidates. Figure 1
(B)illustratesasketchgeneratedbySketchFix.Togeneratethis
sketch, SketchFix applies two schemas at the suspicious location,
one schema introduces an if-condition (if-condition schema ) and
anotherintroducesareturnstatement(return-statementschema ).
To represent an unknown condition hole, i.e, if (??), SketchFix
definesanAPI SketchFix.COND(...) inJavasyntax,whichreturnsa
non-deterministic boolean value (either trueorfalse) during the
test execution. This API takes two parameters: the hole’s target
type (i.e, ArrayList), and an array of visible variables as candidates
tofillinthehole.Thehole’stargettypeisdefinedasthetypeofthe
variablesusedtofillinthehole.SketchFixenumeratesalltypes
derived from visible variables and generates one sketch for each
target type. At line 6, the return-statement schema inserts a return
statementwithanon-deterministicexpression SketchFix.EXP(...),
i.e,return ??, whose target type is the return type of the method.
ThesketchshowninFigure1(B)willbecompiledonlyonce,yet
itrepresents87kcandidatepatches.SketchFixdirectlyexecutes
the given test suite after the compilation. When the test execution
firstreachesthehole SketchFix.COND(...),insteadofconsidering
thousands of concrete candidates like “markers!=null”, SketchFix
only considers two booleanvalues and non-deterministically se-
lectseither trueorfalsetofillintheconditionhole.If SketchFix
selects falsefor the ifcondition, it will not initialize any candi-
dates for the returnexpression because the test execution does not
reachthehole SketchFix.EXP(...) insidethe ifblock.Inthisexample,
choosingthevalue falseforthe ifconditionleadstoatestfailureat
runtime.SketchFixbacktracksimmediatelyandselectsthenext
choice which is the value truefor the if-condition. SketchFix gen-
erates candidates for the expression SketchFix.EXP(...) when the
testexecutionreachestheholeatthefirsttime.Given15candidates
oftheexpressionhole,SketchFixselectsonecandidateatatime
during the test execution until a candidate that satisfies all tests
isfound.Inthisexample,SketchFixfindsthefirstsolutionin40
seconds after compiling the sketch once and executing the tests
twice.
3 APPROACH
In this section, we describe how we translate faulty programs to
sketchesusingASTnode-leveltransformationschemas(Section3.1).
Thesesketchesarefurthersynthesizedbyapracticalsketchengine
with on-demand candidate generation (Section 3.2).
3.1 AST Node-Level Transformation
We perform a systematic reduction of program repair to program
synthesis by translating faulty programs to sketches at a fine gran-
ularity.Syntax of Partial Expressions (Holes).
Figure 2 denotes the
syntax of holes. We define two basic types of non-deterministic
holesforsketches:expressionholesandoperatorholes.Theatomicexpressionholes(
SketchFix.EXP() )representvisiblevariables,con-
stant values and field dereferences. As to the operator holes, wedefine arithmetic operators {
+,−,×,/,%} (SketchFix.AOP() ), rela-
tionaloperators{ ==,!=,>,<,/lessorequalslant,/greaterorequalslant}(Sketch Fix.ROP() )andlogicalatomic expr e:=var|const|var.f
constant const:=null|true|false|k
arithmetic op aop:=+|−|×|/|%
relational op rop:===|!=|>|<|/lessorequalslant|/greaterorequalslant
logical op lop:=&&|||
composite expr e:=e1op e2orarray[eint]
Figure 2: Syntax of Partial Expressions
Mexp=p[/lscript]/turnstileleftet
et/mapsto→ωt
Mop=p[/lscript]/turnstileleftop
op/mapsto→δ
Mpar=p[/lscript]/turnstileleftf(par ),f(par )/turnstileleftf/prime(par∪et)
f(par )/mapsto→f/prime(par∪ωt)
Mcon=p[/lscript]/turnstileleftif (c)
c/mapsto→clop (ωtropω/prime
t)
Mif=p(/lscript)/turnstileleft(v,t)
p(/lscript)/mapsto→if (ωtropω/prime
t)p(/lscript)
Mrtn=p(/lscript)/turnstileleft(v,t)
p(/lscript)/mapsto→returnωtp(/lscript)
Figure 3: Program Transformation Schemas
operators {||,&&} (SketchFix.BOP() ) that combine multiple clauses.
SketchFixgeneratescompositeexpressionsby combining expres-
sionholeswithoperatorholesorcombiningarrayvariableswiththe
index ofarray elements. Compositeholes can furthercombine to-
gether.Forinstance,wedefineaholeforconditions( SketchFix.COND
()) as two expression holes at left and right hand side combined
with a relational operator. Both sides of expression holes in the
condition canbe replacedby infix expressions (e.g., a+b) witharith-
meticoperators, andtheconditionholes canfurtherbecombined
togetherwithlogicaloperatorstosupportmultipleclauses.Tospec-
ify these holes in Java syntax, SketchFix provides a list of method
invocations and these invocations take two parameters: the target
type of the hole and a list of objects.
Base on the syntax of the holes, we define six AST node-level
transformation schemas (Figure 3) that take a faulty program pas
the input and produce sketches with holes.ExpressionTransformation M
exp:Givenasuspiciousstatement
/lscriptin the faulty program p, if it contains any variables, constant val-
ues, or field dereferences with the type t,Mexptransforms this ex-
pressionettoapartialexpression ωtthatrepresentsanyexpression
candidateswiththesametype t.Thatis,theoriginalexpressionwill
bereplacedbyahole SketchFix.EXP(t, new Object[]{v1,v2,...})
whiletheobjectlistcontainsallvisiblevariables,parametersand
fields.Operator Transformation M
op: Given a suspicious statement, if
itcontainsanyarithmetic,relationalorlogicaloperatorsdefined
in the syntax of holes (Figure 2), Moptransforms the operator to
anoperatorhole δthatdenotesanyoperatorsofthesameopera-
tortype.Forinstance,givenaclause a>binthefaultyprogram,
Mopwill replace this clause with a partial expression a??bwhere
14
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:49:35 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Jinru Hua, Mengshi Zhang, Kaiyuan Wang and Sarfraz Khurshid
Algorithm 1: Static Transformation for Sketch Generation
Input:Faulty program p, Fault locations L, Schemas M
Output:List of sketches Q
1Function transformSketch ( p,L,M)is
2Q←∅;
3foreach /lscript∈Ldo
/* apply one schema */
4 foreachσ∈Mdo
5 Q←Q∪σ(p,/lscript);
/* apply two schemas */
6 i←0;
7 whilei<M.sizedo
8 ω←M[i](p,/lscript);
9 j←i;
10 whilej<M.sizedo
11 Q←Q∪M[j](ω,/lscript),j++;
12 i++;
the operator hole ??can be any of { ==,!=,>,<,/lessorequalslant,/greaterorequalslant}. The cor-
respondinggeneratedsketchis SketchFix.ROP(Integer.class, new
Object[]{a,b}) ifaandbare ofIntegertype.
Overloading Transformation Mpar: Given a suspicious state-
ment,ifitcontainsamethodinvocation fthathasaoverloading
methodf/prime,SketchFixtriestomapparametertypesfor fandf/prime
using an approach similar to the edit distance [ 9]. SketchFix only
considers overloading methods f/primewhose edit distances in terms of
theparametertypesarenomorethantwo.SketchFixgenerates
holesωtforf/primeto represent parameters in different types.
Condition Transformation Mcon: Given a suspicious condition
expression c,Mconintroduces a new clause for the condition. The
newclauseisrepresentedas ωtropω/prime
twhereωtandω/prime
trepresent
any expression candidates with the type t. The hole roprepresents
relationaloperators.If tisanon-primitivetype,SketchFixapplies
relationaloperators“ ==”and“!=”toconstructtheclause,whereas
for primitive types, it applies all 6 relational operators. The new
clauseisappendedtotheexistingbooleanexpression cwithlogical
operators (“&&” and “ ||”).
If-condition transformation Mif: Given a suspicious location
/lscript,SketchFixintroducesanif-conditionbefore /lscriptwithacondition
“hole”. If SketchFix selects the target type t, the schema will in-
sert an if-condition as if (SketchFix.COND (t, new Object[]{v1,
v2,...}),wherethetarget type tisderived fromvisible variables
vat the location/lscript.
Return-statementtransformation Mrtn: Given a suspicious lo-
cation/lscript,SketchFixinsertsa returnstatementbefore/lscript.Ifthereturn
type of the current method is void, SketchFix simply inserts an
emptyreturnstatement, otherwise, SketchFix inserts a hole ωt
basedonthemethod’sreturntype,i.e., return (t) SketchFix.EXP(t,
new Object[]{v1, v2,...}) .
Tohandledefectsthatrequiremultipleholestofix,suchasthe
omissionofnull-pointer-checkinginFigure1,weapplytransfor-
mation schemas incrementally at the suspicious statements. Al-
gorithm 1 shows the static transformation approach that appliesno more than two schemas on the faulty program
p. The loop at
line4applieseachapplicableschemaonthesuspiciouslocation /lscriptto
createsketches.Thenestedloopstartingfromline7enumeratesallcombinationsoftwoschemasandappliesthesetwoschemasatthe
samelocation/lscript.Given thelargesearch spaceof repaircandidates
inopensourceprojects,bydefaultSketchFixappliesnomorethan
two transformation schemas at the same location. We leave the
discussion of applying more schemas in Section 4.2.2.
Intuitively,thesynthesiscostincreaseswithmoreholesinthe
sketch.Wedefinethecostoftransformationschemasasthenumber
ofatomicholes(expressionholesandoperatorholes)introduced
by the schemas. We prioritize the schemas with lower synthesis
cost. For instance, we favor expression (Mexpr) andoperator(Mop)
manipulation over the condition transformation schema ( Mcon)be -
causethe Mconinsertsarelationaloperatorholeandtwoexpression
holesattheleftandrighthandsideoftheoperator.Thisstrategyis
inlinewithexistingliteratures[ 5,24]basedontheheuristicthat
repair candidates semantically closer to the original programs are
relatively easier to comprehend and are more likely to be accepted
by the developers.
Existing automated repair techniques have utilized various sup-
portiveresourcestoimprovetherepairefficacy,suchashistorical
data [25,30], documents [ 27,58], anti-patterns [ 53] and test gener-
ation[57].YetwepreserveSketchFix’spracticalityandleavethe
improvement of fix patterns [28, 30, 58] as future work.
3.2 Practical Sketch Synthesis
Aftertransformingtheoriginalfaultyprogramtosketchesbased
ontheschemas,SketchFixexecutestestcasestosynthesizesketches
withon-demandcandidategeneration.SketchFixwillnotgenerate
concrete candidates for a hole until the test execution reaches the
hole. The candidates are created based on the runtime information.
Forinstance,wewillnotgeneratefielddereferencesfor nullvari-
ables (refer to [ 13]). Algorithm 2 describes the procedure of lazy
candidate generation and the sketching using backtracking search.
On-Demand Candidate Generation. When the test execution
first reaches a hole (line 2), SketchFix initializes the hole’s expres-
sion candidates based on the given visible variable list. For theexpression hole
SketchFix.EXP(...) , the method candidateGen()
atline3collectsvisiblevariables,constantvaluesandfieldderef-
erences (refer to EdSketch [ 13]), and returns a candidate vector
(hole.candidates ). Each candidate is assigned a unique identifier,
whichisitsindexinthevector.Eachhole’scandidateidentifieris
initializedas-1,indicatingthatSketchFixhasnotselectedacandi-
date for this hole (Algorithm 2 line 4). During the test execution,
the sketchengine non-deterministicallyselects anidentifier using
choose() operator(line5),andthecandidatewiththecorrespond-
ing identifier is used to fill in the hole. The execution continues
with this selection until it encounters a runtime exception or a
test failure, leading to a backtrack to the next choice of candidates,
i.e., incrementing the candidate identifier and selecting the next
candidate at runtime.Synthesis with Backtracking Search.
Algorithm 2 illustrates
the idea of synthesizing sketches with backtracking search, which
isembodiedinthesketchengineEdSketch[ 13].Insteadofinfer-
ringconstraintsandtranslatingthemtoSATfortherepairsynthesis,
EdSketch starts sketching by directly executing the given tests.
Wheneveraruntimeexceptionoratestfailureoccurs,EdSketch
backtracks bythrowing a BacktrackException , whichwill enforce
15
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:49:35 UTC from IEEE Xplore.  Restrictions apply. Towards Practical Program Repair with On-Demand Candidate Generation ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Algorithm 2: On-Demand Candidate Generation based
on EdSketch [13]
Input:Sketches P, test suite T
Output:Complete Program P/primethat pass all test cases
1Function synthesizeHole (hole) is
2ifhole.candidates==null then
/* First Access */
3 hole.candidates←candidateGen(hole);
4ifhole.id == -1 then
/* First Access */
5 hole.id←choose(0, hole.candidates.size-1) ;
6returnhole.candidates[hole.id] ;
7Function sketch ()is
8do
9 try
10 exploreCurrentChoice();
11 catchBacktrackException
12 createNextChoice() ;
13whileincrementCounter() ;
14Function exploreCurrentChoice() is
15try
16 foreachtest∈Tdo
17 test.run() ;
18catchTestFailureException
19 throwBacktrackException;
20printSolution() ;
21searchExit(); /* if only needs the first solution */
theprogramtore-executefromthebeginning(line19).Foreach
re-execution, the sketch engine increments the counter for the
non-deterministic choose() operatorandselectsthenextcandidate
(line 12) to fill the hole. The synthesizing process terminates when
the space of candidate programs is exhausted or a complete pro-
gram that satisfies all tests is found. EdSketch embeds a range of
pruning strategies to effectively explore the space of candidates.
Forinstance,basedontheprogramsymmetry,theconditionclause
a==bis equivalent to b==a, thus only one clause is considered.
Ranking Candidates Based on The Locality. With the notion
that variables declared closer to the hole are more likely to beused [
24,58], we rank variables based on their proximity to the
hole location,i.e., thenumber of statementsbetween thehole and
the variable declaration. We rank the target types of the hole with
a similar heuristic based on the number of statements between the
holeandvariabledeclarationsofthistypeinascendingorder.For
instance, in our motivating example (Figure 1(B)), the condition
holeatline5favorsthetype ArrayList becausetheclosestvariable
is with this type.
In summary, we discuss how we systematically reduce the prob-
lem of program repair to program synthesis at the fine granularity.
Weutilizetheruntimebehaviorsofteststoprunealargeamount
of search space with on-demand candidate generation.
4 EVALUATION
We evaluate SketchFix on the Defects4J benchmark [20], which
consistsof357realdefectsfrom5opensourceJavaapplications.De-fects4JcontainsvarioustypesofdefectsfromopensourceprojectsTable 1: Overview of the Evaluation Dataset and the Repair
Results of SketchFix
Project LoCTests#Bug#FixFLSketch Repair
Time(m) Time(s) Time(m)
Chart 96k2.2k 266/2 1.1 9.9 44.2
Closure 90k7.8k1333/2 7.2 10.8 3.6
Lang 22k2.2k 653/1 0.4 1.5 26.7
Math 85k3.6k1067/1 1.8 3.7 4.0
Time 28k4.1k 270/1 0.4 14.2 27.3
Total 35719/7
#Fixshowsthenumberofcorrectfixesandplausiblefixes(repairsthatpass
tests but fail in manual inspection).
to eliminate the bias of the dataset [ 39] in terms of the defects
types and the abundance of these defect classes [ 34,39]. In Sec-
tion4.2,wecompareSketchFix’srepairefficacyandfavoreddefect
typeswithotherautomatedrepairtechniques.InSection4.3,we
investigateiftheon-demandcandidategenerationcouldeffectivelyreducethesearchspaceofrepaircandidates.Wefinallydiscusshow
our AST node-level transformation influences the patch quality in
Section 4.4.
We address the following research questions in this section:
•What’s the repair efficacy of SketchFix compared to other
repair techniques?
•Doestheon-demandcandidategenerationtechniquereduce
the search space of repair candidates?
•How does our fine-grained transformation affect the quality
of the generated repairs?
4.1 Experiment Setting
Defects4Jisacollectionofreproduciblebugswithtriggeringtests
verified. SketchFix regards the test suite of each subject as the
correctnesspropertyandtriestosynthesizeanewprogramsuch
that all tests could pass.
Toidentifysuspiciousstatementsforthedefects,weusetheASM
bytecodeanalysisframework [ 3]togetherwith JavaAgent[ 14]to
capture the test coverage of both failing and passing test execu-
tions.SketchFixusesanexistingspectrum-basedfaultlocalization
technique called Ochiai [ 1] to rank potential faulty statements
based on their suspiciousness. Existing empirical studies [ 52,59]
illustrate that Ochiai is more effective on localizing the faults in
object-orientedprogramsthanothertechniques.Ochiaihasbeen
applied to numerous repair techniques [ 7,25,35,37,58], including
all four repair techniques [ 7,25,35,58] we use in the compari-
son. We rank the suspicious statements based on the Ochiai [ 1]
suspiciousness value for each statement covered by failing exe-cutions and select the top 50 suspicious statements by default. If
multiplestatements havethe samesuspiciousnessscore, weorder
themrandomly.Weleavethediscussionforthenumberofselected
statements in Section 4.2.2.
Table 1 presents the basic information of the subjects used in
the evaluation, including the lines of code ( LoC), the number of
test cases ( Test), the number of defects collected in the benchmark
16
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:49:35 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Jinru Hua, Mengshi Zhang, Kaiyuan Wang and Sarfraz Khurshid
6NHWFK)L[


1RSRO
$VWRU 6NHWFK)L[


$&6
+'5HSDLU
 
HDRepair [25] assumes that the faulty methods are known in advance.
SketchFix fixes 8 more defects with this assumption, 5 of them are also
fixed by HDRepair. We report two results without and with the
assumption.
Figure 4: Comparison of Correct Patches Generated by
SketchFix and Other Repair Techniques
(#Bug),andtheaverageperformancetimetoidentifyfaultystate-
ments(FL Time).Totranslatefaultyprogramstosketches,weim-
plement transformation schemas using JavaParser [ 15], a tool that
parses and transforms Java programs. The column Sketch Time de-
notes the average performance time to generate program sketches.
SketchFix explores the search space of repair candidates for each
program sketch until the space of candidates is exhausted or we
findapre-definednumberofrepairsthatpassalltests.Currently
we terminate after finding the first repair yet we set the number of
output repairs as configurable. We report the average performance
time SketchFix takes to find the first repair (column Repair Time )
following the spirit of existing literatures [ 29,37]. We execute only
the tests that reach the holes following the spirit of recent workon test pruning [
38]. We manually check all synthesized repairs
againsthuman-writtenpatchesfromtheversionhistory,andreport
the number of correct repairs and plausible ones that pass all tests
but fail in manual inspection in column #Fix.
All performance experiments are conducted on a platform with
4-core Intel Core i7-6700 CPU (3.40 GHz) and 16 Gigabyte RAM on
Ubuntu Linux 16.04.
4.2 Repair Efficacy
In this section, we answer the first research question by com-
paringSketchFix’srepairefficacywith otherrepair techniques—
Astor [35], Nopol [ 7], ACS [58] and HDRepair [ 25]. We select
these four publicly available repair techniques that have been eval-
uatedagainsttheDefects4Jbenchmarkandignoreotherswhich
either focus on another language [ 29,40,56] or are not publicly
available [ 22,24]. All four techniques use Ochiai [ 1] to identify the
suspiciousstatements.NotethatHDRepairassumesthatthefaultymethodsareknowninadvanceandperformsOchiaitoidentifythe
faultystatementsinthegivenmethods.Wethusaddthisassump-
tion when conducting the comparison with HDRepair. Due to the
difference in experiment platforms, we can hardly reproduce all
experiments for these four techniques, we thus mainly refer to the
generated repairs provided by the authors and refer to their results
of the manual inspection.Table2:ManualAssessmentResultofPatchesGeneratedby
SketchFix and Other Repair Approaches
No.SFANCHNo.SFANCH
CH1 /check?××/checkM5 /check/check×/check/check
CH3×??××M8×?×××
CH5×?×××M22××××/check
CH7×?×××M25×××/check×
CH8 /check×××/checkM28×?×××
CH9 /check××××M32×??××
CH11 /check××××M33 /check×?××
CH13 ???××M34××××/check
CH14×××/check×M35×××/check×
CH15×?×/check×M40×??××
CH19×××××M42××?××
CH20 /check××××M49×??××
CH21××?××M50 /check/check/check×/check
CH24 /check××××M53×/check××/check
CH25×??××M57××?××
CH26?∗??××M58××?××
C1×∗××××M59 /check××××
C10××××/checkM61×××/check×
C11×∗××××M69××?××
C14 /check×××/checkM70 /check/check××/check
C51××××/checkM71×??××
C62 /check×××/checkM73 ?/check?××
C70?∗×××/checkM78×??××
C73?∗×××/checkM80×??××
C126 /check×××/checkM81×??××
L6 /check×××/checkM82 /check??/check/check
L7××?/check×M84×××××
L10×∗×××/checkM85 /check??/check×
L24×××/check×M87××?××
L35×××/check×M88××?××
L39×××××M89×××/check×
L43××××/checkM90×××/check×
L44××/check××M93×××/check×
L46××?××M95×?×××
L51?∗×?×/checkM97××?××
L53××?××M99×××/check×
L55 /check?/check××M104××?××
L57××××/checkM105××?××
L58××/check××T4 ??×××
L59 /check×××/checkT11×??××
M2×?×××T15×××/check×
M3×××/check×T19×∗×××/check
M4×××/check×
SFrepresentsSketchFix,ArepresentsAstor[ 35],NrepresentsNopol[ 7],
C represents ACS [58], and H represents HDRepair [25]. /checkrepresents
correct fix, ? represents plausible fix, and ×represents not generating fix.
We use the * to mark the new generated fixes by providing the faulty
methods when comparing with HDRepair. We highlight the correct
repairs generated by SketchFix.
17
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:49:35 UTC from IEEE Xplore.  Restrictions apply. Towards Practical Program Repair with On-Demand Candidate Generation ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
(A) A bug fix for Chart24 generated by SketchFix
//Human-Written patch for the defect
private int upperBound, lowerBound;
public Paint getPaint(double value) {
double v=Math.max(value,this.lowerBound);
- int g=(int)((value-this.lowerBound)/...;+ int g=(int)((v-this.lowerBound)/...; ...}// A sketch generated by SketchFix and the synthesis result
public Paint getPaint(double value) {
double v=Math.max(value,this.lowerBound);
int g=(int)(((Integer)SketchFix.EXP(int.class,
new Object[]{v,value,...}) - this.lowerBound)/...;}
// Synthesized solution: SketchFix.EXP: v
(B) A bug fix for Math73 generated by Astor
//Human-Written patch for the defect Math73
if (yInitial*yMax<0) return solve(f,initial,yInitial,...);
+ if (yMin*yMax>0) throw new llegalArgumentException(...);
return solve(f, min, yMin,...);
//bug fix generated by Astor with API replacement
if (yInitial*yMax<0) return solve(f,initial,yInitial,...);
- return solve(f, min, yMin, max,...);+ return solve(f, min, max);
(C) A bug fix for Lang58 generated by Nopol
//Human-Written patch for the defect//Omit complex clauses for simplicity
- if (dec == null && exp == null && (A && B) || C) {..}
+ if (dec == null && exp == null && B && (A || D)) {..}
//bug fix generated by Nopol that is regarded as correct
- if (dec == null && exp == null && (A && B) || C) {..}+ if ((dec == null) && (exp == null)) {..}
(D) A bug fix for Time15 generated by ACS
//Human-Written patch for the defect and ACS's result is// semantically identical to this.
+ if (val1 == Long.MIN_VALUE) {+ throw new ArithmeticException("...");}
(E) A bug fix for Math34 generated by HDRepair
//Human-Written patch for the defect and HDRepair's result// is identical to this.
public Iterator<Chromosome> iterator() {
+ return chromosomes.iterator();
- return getChromosomes().iterator(); }
Figure5:ComparisonofFavoredDefectClassesforSketch-
Fix and Other Repair Techniques
Figure 4 denotes Venn Diagrams for the defects that can be cor-
rectly repaired by SketchFix and other techniques. Given that
SketchFix,AstorandNopoldonot requiresupportive informa-
tionsuchasdocuments(ACS[ 58])orhistoricaldata(HDRepair[ 25]),
we separate the comparison into two Venn Diagrams. Table 2
presents the repair result through manual inspection.4.2.1 Defect Classes favored by the repair techniques . Different
repair techniques focus on different types of bugs [ 39] (e.g., Nopol
onlydealswithconditionfaults).Wearenotintendedtoperformanapple-to-applecomparisonwiththeserepairtechniques,instead,we
highlightfavoreddefectclassesof SketchFixandothertechniques
with examples.
SketchFix. Figure 5 (A) presents a defect that can be fixed by
SketchFix.Inthisexample,SketchFixappliesthe Mexpschema
to a type-casting expression at the AST node-level. It synthesizes a
variable vfor the expression hole to replace the original variable
value.Notethattheconstraint-solving-basedrepairtechniques[ 36,
37,40] in general only modify expressions in conditions or the
right-sideofassignmentswith booleanorintegertypes,othertech-
niquesthatleveragestatement-levelmutation[ 35]orsupportive
information [ 25,58] can hardly repair the defect because this AST
node-level replacement has a rare chance to be duplicated in ex-
isting program context, history [ 25] or documents [ 58]. Table 3
reports the schema types that finally generate repairs for each
defect.SketchFixcorrectlygeneratesrepairsfor19subjectsand
around half of them (9 subjects) yield expression manipulation.
Themanipulationofoperatorsandvariabletypes(parametersfor
overloadingmethods)correctlyfixesanother6defects,andtherest
schemas or their combinations fix another 4 subjects. For the 6
defectsthatcanonlybefixedbySketchFixwithrespecttoother
four repair techniques (Table 2), 4 of them yield expression manip-
ulation,oneofthemisvariabletypemanipulationinoverloading
methods, and the last one applies an insertion of the if-condition.
Astor. Astor is a program repair library that contains three
repair modes based on the genetic algorithm, statement/condition
removal,andoperatormutation.Figure5(B)showsadefectthatcan
befixed byAstor.It replacesthe returnexpressionwith another
method invocation. The new return-statement exists in the current
program context, and the Astor correctly generates this repair
basedonthestatement-levelsearch.SketchFixgeneratesthesame
repairbytransformingtheoriginalinvocationtoanoverloading
method with holes at the AST node-level.Nopol.
Nopol is a repair technique that focuses on the condition
faults by modifying existing if-conditions or adding pre-conditions.
Figure 5 (C) shows a defect and a bug fix generated by Nopol.
Thegeneratedpatchremovesmultipleclausesandisreportedas
correctintheliterature[ 33].SketchFixfailstorepairthisintricate
condition defect that requires changes on multiple clauses.
ACS.ACS leverages document analysis to rank patches and it
advancesothertechniquesonfixingtheomissionerroroftheex-
ception handling ( if-throw). Figure 5 (D) presents an example of
the repair generated by ACS which is semantically equivalent to
the human-written patch. SketchFix is not designed to handle
exception omission and we leave this as future work.
HDRepair. HDRepair prioritizes patches based on the mined
repairmodelsfromhistoricaldata.Itpreferstherepairsthatrequire
the method invocation replacement. Figure 5 (E) shows a repair
generated by HDRepairthat replacesan expressionwith a method
invocation.SketchFixcanbeextendedtosupportAPIsynthesis
with a similar idea of the on-demand candidate generation [60].
Our experiment indicates that SketchFix performs particularly
well in the defect classes that require manipulations of expressions
andvariabletypes.Recentempiricalstudiesonrepairmodels[ 28,
18
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:49:35 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Jinru Hua, Mengshi Zhang, Kaiyuan Wang and Sarfraz Khurshid
Table 3: SketchFix Repair Result for Each Subject
# Fix Type Sk. Sp. cSk. Exe Cor T(m)
1CH1CMrop1.7k 301.2k 209 2.8k 2.9k 208.5
2CH8CMexp607 8.7k 83 663 663 32.9
3CH9CMcon744 6.9k 678 100 100 5.6
4CH11 CMexp249 2.4k 25 26 31 7.2
5CH13 PMpar813 79.8k 115 914 - -
6CH20 CMexp137 2.9k 127 206 206 14.9
7CH24 CMexp17 378 1 4 4 0.5
8CH26 PMif,77 1.6k 21 105 - -Mrtn
9C14CMexp2.6k 46.1k 144 4 36 40.7
10C62CMrop490 4.9k 58 72 92 8.8
11C70PMpar1.2k 18.9k 108 28 - -
12C73PMrop476 5.2k 59 40 - -
13C126 CMcon462 5.6k 32 8 64 7.3
14L6CMexp255 3.0k 1 51 424 2.9
15L51PMif,222 2.4k 43 28 - -Mrtn
16L55CMcon108 1.6k 76 62 71 86.2
17L59CMexp188 1.8k 48 5 5 0.1
18M5CMexp 1 7 2111 0 . 1
19M33CMpar1.1k 17.8k 446 221 631 20.2
20M50CMcon655 6.0k 43 22 92 0.9
21M59CMexp259 4.0k 36 7 7 0.4
22M70CMpar139 2.8k 60 8 8 0.1
23M73PMif,383 6.2k 76 59 - -Mrtn
24M82CMrop500 6.0k 68 36 803 12.1
25M85CMrop407 5.2k 78 590 590 23.1
26T4PMpar555 23.4k 40 274 - -
Fixrepresents whether it is a correct fix (C ) or a plausible fix (P ).Type
denotes the schema types that yield the repair. Sk.shows the number of
generated sketches. Sp.presents the total search space of candidates. cSk.
is the number of compiled sketches when SketchFix generates first repair.
Exerepresents the number of candidates SketchFix explores when it
generates the first repair passing all tests. Cor represents that number
when SketchFix generates the first correct repair based on the manual
inspection. T(m)reports the performance time to synthesize a correct fix.
34,61]showtheabundanceofsuchdefects.YetSketchFixisnot
designedtohandlestatement-levelmutationorexceptionhandling.
4.2.2 Search Space Extension. In this section, we extend the
searchspaceofrepaircandidatestoconsidermoresuspiciousstate-
ments and transformation schemas.
Suspicious Locations. By default, we consider top 50 suspicious
statementsas wenotice thatSketchFixcannotfix manydefects
with anincrease of boundwhereas thecost of theprogram repair
increases significantly. If we increase bound to 100, SketchFix cor-
rectly fixes 2 more defects: Chart26 and Lang10. HDRepair [ 25]
fixesdefectswithgivenfaultymethods.Withthesamecondition,
SketchFixcorrectlyfixes 6moredefects:Closure1,Closure11, Clo-
sure70, Closure73, Lang51 and Time19. This result also indicates
thatconcise faultlocalization techniquescan greatlyimprove the
efficacy of program repair techniques.MultipleTransformationSchemas. Asatrade-offbetweenthe
costofexperimentsandtherepairefficacy,SketchFixappliesno
more than two transformation schemas at a suspicious location.
Thenumberofgeneratedsketchesandcorrespondingcandidates
growquicklywithmoretransformationschemas.SketchFixfixes4
more bugs with 3 schemas at a given location (Closure130, Lang58,
Math53 and Time4).Repair at Multiple Locations.
We introduce an incremental ap-
proachtofixdefectsatmultiplelocationsbasedonthereduction
of the failing test cases [ 12]. If there exists multiple failing test
cases, we localize the defect with one failing test case and all pass-
ing test cases, let SketchFix generate sketches and evaluate ifany synthesized solution can eliminate one or more failing testcases. If a synthesized version reduces the number of the failing
test cases, SketchFix applies this repair and keeps on considering
other failing test cases. This incremental repair technique is based
on the assumption that at least one failing test case can be fixedby synthesizing a sketch and failing test cases are independent
with each other such that the fix of one test case will not affect
others. Although the validity of this assumption remains unsettled,
SketchFixcorrectlyfixesanother3defects(Chart14,Math4,and
Math22) based on this assumption.
4.2.3 Threats to Validity. Although Defects4J contains hun-
dreds of defects from multiple open-source projects, this defect
benchmarkmayunavoidablyyieldthebiasoftheevaluationdatasets
[39]withrespecttothedefecttypesandtheabundanceofthede-
fectclasses[ 34,39].Wecompareourresultwithotherfourrepair
techniques that have been evaluated with the same benchmarkand explain the favored defect classes for each technique. Based
on the human-written patches from the version history, we assess
the correctness of the generated repairs. However, this assessment
may still be biased.
4.3 Search Space Reduction
In this section, we answer the second research question on the
efficacy of our on-demand candidate generation.
SketchFix is able to generate repairs for the subjects shown
in Table 3. With the default setting, these repairs include correctfixesthatpassthemanualinspectionandtheplausibleonesthatpass all tests but are regarded as semantically-different from thedeveloper-written patches. The column
Fixdenotes whether the
repairiscorrect( C)orplausible( P).Thecolumn Typerepresentsthe
transformation schema types that are used to fix the bugs. If more
thanone schemacombinationcan generaterepairsthat satisfyall
testassertions,wereportthefirstschemacombination.Thecolumn
Sk. shows the total number of sketches generated by SketchFix
considering all selected locations, and the column Sp. lists the total
search space of the candidates that the sketches represent. For
instance,if SketchFixintroducesanon-deterministiccondition
clause for a primitive type, assume that there are 10 expressioncandidates at both left and right hand side, the search space ofcandidates for this sketch is 600 (6
×10×10) as two expressions
are combined with a relative operator which has 6 options ( ==,!=
,>,<,/lessorequalslant,/greaterorequalslant). The column cSk.presents the number of compiled
sketcheswhenSketchFixgeneratesthefirstrepairsthatpassall
tests. The column Exe.shows the number ofcandidates that have
19
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:49:35 UTC from IEEE Xplore.  Restrictions apply. Towards Practical Program Repair with On-Demand Candidate Generation ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
beenexecutedagainstthetestsuitewhenSketchFixgeneratesthe
first repairs satisfying all tests. And the column Cor.represents
the number when SketchFix finds the first correct repairs. The
columnT(m)illustratesthetotalperformancetimeinminuteswhen
SketchFix finds the first correct fix, including the time for the
compilation and the test execution.
With the on-demand candidate generation, every sketch will be
compiledoncewhichmayrepresentthousandsofcandidates.Upto
the time that SketchFix finds the first repair, it compiles 1.6% (avg.
#compiled sketches/#space). If SketchFix wants to exhaustively
searchtheentirespaceofrepaircandidates,itonlycompiles7%(avg.
#sketches/#space) of all candidates. SketchFix utilizes runtime
information to further prune the candidates that actually needtobeverifiedbythetestexecution.Forexample,SketchFixwill
notgeneratecandidatesfortheconditionbodyiftheconditionis
evaluated to be false. The experiment shows that SketchFix only
executes3%ofcandidates(avg.#Gen/#Space)whenitfindsthefirst
repairs that pass all tests.
Onaverage,SketchFixspends9minutesgeneratingsketches
withfaultlocalizationand23minutesgeneratingthefirstrepairs
thatsatisfyalltestassertions.Tocompareourperformancewith
other repair techniques, we refer to the performance time reported
in the literatures [ 7,33,35,58] as we are not able to reproduce
all experiments of other techniques due to the various experiment
platforms.AstorandNopolspend30-40minutesonaveragefor
eachrepaironapowerfulmachine.HDRepairspendsanaverage
of 20 minutes generating patches with given methods. Without
reportingtheperformancetimefordocumentanalysis,ACS’spatch
generationtime(max.28minutes,median 5.5minutes)isnotfairly
comparable with our repair technique. Without pre-processing his-
torical data or document analysis, our practical repair techniquecompareswellwithotherrepairtechniquesonperformance.We
omit the comparison on the number of executed candidates across
different repair techniques, because different techniques use differ-
ent templates and the choice of templates determines the search
space of the candidates.
4.4 The Quality of Generated Repairs
Weanswerthelastresearchquestioninthissectionbyinvestigating
if our AST node-level transformation helps generate high-quality
patches. Shown as Figure 6, we illustrate the quality of the repairs
generated by SketchFix using an example.
BasedontheASTnode-leveltransformationschema,SketchFix
transformsamethodinvocationtoitsoverloadingmethod,andcor-rectlyrepairsthedefectbyreplacingthevariable
maxUlps(integer)
toepsilon(double).Thisfine-grainedtransformationisinlinewith
the notion that the repairs which introduce smaller perturbations
to the original programs are more likely to be correct from the
perspectiveofthedevelopers.Withthesamenotion,SketchFixfa-
vors expression manipulations for the overloading method ( Mpar)
ratherthantheif-conditioninsertion( Mif)astheinsertionofanew
if-condition will introduce more atomic holes than the expression
manipulation. SketchFix generates sketches shown as Figure 6 (B)
and synthesizes this sketch as expected.
The repair techniques Astor, ACS, and HDRepair fail to gener-
ate repairs for this bug. Nopol fixes this defect by adding a new if
block.Althoughbothsolutionsmightbesemanticallyequivalent,(A) A human-written patch for the defect Math33
public class Precision {
public static int compareTo(double x,double y,double eps)..
public static int compareTo(double x,double y,int maxUlps)..
}
/* SimplexTableau.java */private final int maxUlps;
private final double epsilon;
protected void dropPhase1Objective() {
- if (Precision.compareTo(entry, 0d, maxUlps)>0){...
+ if (Precision.compareTo(entry, 0d, epsilon)>0){...
}
(B) A sketch generated by SketchFix and a synthesized solution
/* SimplexTableau.java as sketch */
protected void dropPhase1Objective() {
if (Precision.compareTo(entry, 0d, (Double) SketchFix.EXP(
Double.class, new Object[]{..,epsilon,maxUlps,..}))>0){..
}
// Synthesized solution: SketchFix.EXP: epsilon
(C) A plausible repair generated by Nopol
protected void dropPhase1Objective() {
if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
+ if (numSlackVariables<constraints.size()) {...}}
Figure 6: Patches Generated by SketchFix and Nopol for
the defect Math33
we believe that the repair generated from the fine-grained trans-
formationintroducesasmallerperturbationtotheoriginalfaulty
program and is conceptually easier to comprehend.
Apart from the fine-grained transformation, our candidate rank-
ingstrategybasedonthelocalityalsohelpsgeneratinghigh-quality
patches. Figure 5 (A) shows an expression manipulation that re-
placesthevariable valuewithv,whichisthemaximumvalueofthe
variable valueand the field lowerBound . BothvandlowerBound sat-
isfyalltestassertions,yetSketchFixfavorsthevariable vbecauseit
isdefinedatthepreviousstatementoftheholewhereas lowerBound
is a field in the class. With the insight that the variables defined
closertotheholesaremorelikelytobeused,ourpracticalcandi-
date ranking strategy is in line with other repair techniques that
aimtoimprovepatchquality,suchasanti-patterns[ 53],program
distance [5] and syntactic similarity [24].
5 RELATED WORK
ThissectioncomparesSketchFixwithotherapproachesonpro-
gram repair and program synthesis.Generate-and-Validate Repair.
Generate-and-Validate repair
techniques apply a setof transformations to generate a setof can-
didates and validate each candidate against the given test suite. To
efficientlyexploretheimmensesearchspaceofrepaircandidates
inlarge-scaleapplications,theseautomatedprogramrepairtools
leverage genetic algorithms [ 56], random search [ 43], semantic
20
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:49:35 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Jinru Hua, Mengshi Zhang, Kaiyuan Wang and Sarfraz Khurshid
search [21] and adaptive search [ 55] to find a repair that let all test
cases pass. Kali [ 44] applies code removal and Debroy et al. [ 6]
employasetofmutationoperators(e.g.,arithmeticoperators“ +”
and“×”)tofixfaults.Astor[ 35]isaprogramrepairlibrarythat
includes the re-implementations for GenProg [ 56], Kali [44], and
mutation-based repair [6] to fix Java code.
To prioritizerepairs, PAR manuallylearns repair patternsfrom
the human-written patches [ 22]. Other G&V techniques automati-
cally mine repair models from historical data [ 25,30]. CodePhage
[46] eliminates defects by transferring correct code across applica-
tions.Genesis[ 28]alsoautomaticallyinfersrepairmodelsbased
onthehuman-writtenpatches.Somerecentworksleveragedocu-
ment analysis [ 27,58], anti-patterns [ 53], test generation [ 57], and
location selection with test pruning [38] to enhance repair.
SketchFix differs from these G&V approaches in that it tightly
integrates the generation and validation phase of the repair candi-
datesandonlygenerateson-demandonesduringthetestexecution.
Thisintegrationsubstantiallyreducesthesearchspaceoftherepair
candidatesandeffectivelypruneslargeamountofre-compilation
and re-execution of the potential repairs. Moreover, a number of
approaches that aim to imp rove thepatch quality [ 53,57] are com-
plementary to ours. In particular, we can use mined repair mod-
els [25,28,30] and document analysis [ 58] to prioritize candidates
and support more transformation schemas at a fine granularity.
Constraint-Solving Repair. Programrepairtechniquessuchas
Nopol[7]andAngelix[ 37]dynamicallycollectpathconditions
andinferconstraintsbasedonthepassingandfailingtestexecu-
tions[36,40].TheseconstraintsarefurthertranslatedtoSATfor
SAT/SMT solvers to synthesize a repair that satisfies all inferred
specifications.SPR[ 29]infersatargetvalueforthefaultycondition
basedonthetestsuite.MintHintusesthesymbolicexecutionandstatisticalcorrelationanalysisforthepatchranking.S3[
24]extends
thesemantics-basedfamilylikeSemFix[ 40]andAngelix[ 37]to
incorporate a set of ranking criteria such as the variation of the
execution traces similar to Qlose [5].
By inferring constraints based on the execution and translat-
ing these constraints to SAT, these repair techniques may yield
incomplete translation [ 24,37] or impractical problem of creating
modelsforallrelevantlibraries[ 36,40].Ingeneral,theyexclusively
reason about booleanorintegertypes in conditions or the right
side of assignment. They may suffer from the limitations of thesymbolic execution engines to extract constraints. E.g., Angelix
cannotexecutelibrariessuchas python,lighttpd andfbcduetothe
limitation of KLEE. SketchFix is substantially different from these
translation-based techniques as its sketch backend [ 13] explores
the actual program behaviors in presence of libraries and does not
translate to SAT/SMT. SketchFix thus works well in manipulat-ing expressions and handles a whole range of variable types and
transformation locations, e.g., SketchFix fixes a bug by replacing
avariableinacastexpressionattheASTnode-level.Inaddition,
SketchFixisnotconfinedtothestructureofthesubjectsaslong
as the subjects can be executed. Therefore, it can be applied to the
projectslike Closure compiler whosetestcasesareorganizedusing
scriptsratherthanstandardJUnittestcases.Thisnon-conventional
structure has obstructed some repair techniques like Astor.
Automated program repair based on the formal specifications
hashadnumeroussuccess.AutoFix-E[ 54]isabletorepaircomplexdata structure for Eiffel program, but it relies on human-written
contractstogeneratefixes.Gopinathetal.[ 11]usepre-andpost-
conditionswritteninAlloyspecificationlanguagetoidentifyde-
fectsandrepairtheprogram,andwerethefirsttoconjecturethe
reduction of program repair to program sketching [ 12]f r o mt h e
bestofourknowledge.Singhetal.[ 47]usespecificationtogenerate
feedback for students’ faulty python program. Kneuss et al. [ 23]
generate test inputs automatically from the specifications to fix
faulty Scala programs using deductive program synthesis. Yet for-
mal specificationsare usually notavailable forprojects written in
imperative languages.Domain-Specific Repair.
ClearView [ 42] eliminates security
vulnerabilitywithinferredinvariants.Demskyetal.[ 8]useDaikon
to infer invariants for data-structure repair. Vejovis [ 19] infers
possible string replacement for DOM-related faults in JavaScript
codethroughstringconstraintsolver.SimilartoVejovis,PHPRe-
pair[45]usesstringconstraint-solvingtofixPHPprogramsthat
generateHTML.Theseapproachessharesimilarspiritwithconstraint-
solving repair and thus may encounter similar limitations.Program Synthesis.
Program synthesis has shown its promise
on synthesizing code in small well-defined domains such as bit-
vectorlogic[ 18]anddatastructures[ 48].Inparticular,sketch-based
synthesis [ 50] asks programmers to write a program skeleton con-
tainingholes,andusescounter-example-guidedinductivesynthesis
to complete the holes. However, these approaches require to trans-
formconstraintstoSATformulas,whichmightbeimpracticalin
large-scaleprojectswithexternallibraries.EdSketch[ 13]isaprac-
tical execution-driven sketching engine thatsynthesizes sketches
with backtracking search, yet it requires users to provide partial
programsastheinputs.Recentwork[ 60]enhancedEdSketchto
supportmethodsequencegenerationforAPIcompletion.DifferentfromEdSketchandotherprogramsynthesistechniques[
10,41,51],
we translate existing faulty programs to sketches with the purpose
of repairing the original faulty programs.
6 CONCLUSION
This paper introduced an on-demand repair technique, SketchFix,
which tightly integrates the traditionally separate phases of gener-
ationandvalidationofcandidateprogramsthatrepresentpotential
fixes to consider for the given faulty program. Utilizing runtime
information,thisintegrationeffectivelyprunesalargeportionof
thesearchspaceforthecandidatefixes.Thetechniquereducespro-
gram repair to program synthesis by transforming faulty programs
to sketches at the AST node-level granularity. SketchFix employs
an execution-driven sketching engine to complete the sketches
using a backtracking search. The experimental results show that
SketchFixworkswellinmanipulatingexpressions,andthefine-
grained transformation schemas it employs allow it to generate
high-quality patches.
ACKNOWLEDGMENTS
This work was funded in part by the National Science Foundation
(NSF Grant Nos. CCF-1319688, CCF-1704790, and CCF-1718903).
We thank Mukul Prasad and Yuqun Zhang for discussions and
comments.
21
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:49:35 UTC from IEEE Xplore.  Restrictions apply. Towards Practical Program Repair with On-Demand Candidate Generation ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
REFERENCES
[1]Rui Abreu, Peter Zoeteweij, and Arjan J. C. van Gemund. On the accuracy of
spectrum-basedfaultlocalization.In Testing-PracticeandResearchTechniques,
5th International Academic and Industrial Conference, TAIC PART 2007.
[2]Christoffer Quist Adamsen, Anders Møller, Rezwana Karim, Manu Sridharan,
Frank Tip, and Koushik Sen. 2017. Repairing event race errors by controlling
nondeterminism. In Proceedings of the 39th International Conference on Software
Engineering, ICSE 2017, Buenos Aires, Argentina, May 20-28, 2017. 289–299.
[3]ASM Java bytecode manipulation and analysis framework 2017. (2017). http:
//asm.ow2.org/ Accessed: 07-30-2017.
[4]Closure Compiler 2017. https://github.com/google/closure-compiler. (2017). Ac-
cessed: 2018-02-10.
[5]Loris D’Antoni, Roopsha Samanta, and Rishabh Singh. 2016. Qlose: Program
Repair with Quantitative Objectives. In Computer Aided Verification - 28th Inter-
nationalConference,CAV2016,Toronto,ON,Canada,July17-23,2016,Proceedings,
Part II. 383–401.
[6]Vidroha Debroy and W. Eric Wong. 2010. Using Mutation to Automatically Sug-
gest Fixes for Faulty Programs. In 3rd IEEE International Conference on Software
Testing, Verification and Validation, ICST 2010. 65–74.
[7]Favio Demarco, Jifeng Xuan, Daniel Le Berre, and Martin Monperrus. 2014.
Automatic repair of buggy if conditions and missing preconditions with SMT. In
6thInternationalWorkshoponConstraintsinSoftwareTesting,Verification,and
Analysis, CSTVA 2014.
[8]BrianDemsky,MichaelD.Ernst,PhilipJ.Guo,StephenMcCamant,JeffH.Perkins,
and Martin C. Rinard. 2006. Inference and enforcement of data structure consis-
tencyspecifications.In InternationalSymposiumonSoftwareTestingandAnalysis,
ISSTA 2006. 233–244.
[9]EditDistance2017. (2017). https://en.wikipedia.org/wiki/Edit_distance Accessed:
07-30-2017.
[10]Joel Galenson, Philip Reames, Rastislav Bodík, Björn Hartmann, and Koushik
Sen. 2014. CodeHint: dynamic and interactive synthesis of code snippets. In 36th
International Conference on Software Engineering, ICSE 2014. 653–663.
[11]Divya Gopinath, Muhammad Zubair Malik, and Sarfraz Khurshid. 2011.
Specification-Based Program Repair Using SAT. In Tools and Algorithms for
the Construction and Analysis of Systems -17th International Conference, TACAS
2011. 173–188.
[12]Jinru Hua and Sarfraz Khurshid. 2016. A Sketching-Based Approach for Debug-
ging UsingTest Cases.In AutomatedTechnology forVerification andAnalysis -
14th International Symposium, ATVA 2016. 463–478.
[13]Jinru Hua and Sarfraz Khurshid. 2017. EdSketch: execution-driven sketching for
Java.InProceedingsofthe24thACMSIGSOFTInternationalSPINSymposiumon
Model Checking of Software, Santa Barbara, CA, USA, July 10-14, 2017. 162–171.
[14]Java programming language agents 2017. (2017). https://docs.oracle.com/javase/
7/docs/api/java/lang/instrument/package-summary.html Accessed: 07-30-2017.
[15]JavaParser Transformation Tool 2017. http://javaparser.org. (2017). Accessed:
2017-07-30.
[16]Jinseong Jeon, Xiaokang Qiu, Jeffrey S. Foster, and Armando Solar-Lezama. 2015.
JSketch:sketchingforJava.In 23thACMSIGSOFTInternationalSymposiumon
Foundations of Software Engineering, ESEC/FSE 2015. 934–937.
[17]JFreeChart Project 2017. (2017). http://www.jfree.org/jfreechart/ Accessed:
07-30-2017.
[18]Susmit Jha, Sumit Gulwani, Sanjit A. Seshia, and Ashish Tiwari. 2010. Oracle-
guided component-based program synthesis. In 32th International Conference on
Software Engineering, ICSE 2010. 215–224.
[19]FrolinS.OcarizaJr.,KarthikPattabiraman,andAliMesbah.2014. Vejovis:sug-
gestingfixesforJavaScriptfaults.In 36thInternationalConferenceonSoftware
Engineering, ICSE ’14, Hyderabad, India - May 31 - June 07, 2014. 837–847.
[20]RenéJust,DarioushJalali,andMichaelD.Ernst.2014. Defects4J:adatabaseofex-istingfaultstoenablecontrolledtestingstudiesforJavaprograms.In International
Symposium on Software Testing and Analysis, ISSTA 2014. 437–440.
[21]Yalin Ke, Kathryn T. Stolee, Claire Le Goues, and Yuriy Brun. 2015. Repairing
ProgramswithSemanticCodeSearch.In 30thIEEE/ACMInternationalConference
onAutomatedSoftwareEngineering,ASE2015,Lincoln,NE,USA,November9-13,
2015. 295–306.
[22]Dongsun Kim, Jaechang Nam, Jaewoo Song, and Sunghun Kim. 2013. Automatic
patch generation learned from human-written patches. In 35th International
Conference on Software Engineering, ICSE 2013. 802–811.
[23]EtienneKneuss,ManosKoukoutos,andViktorKuncak.2015. DeductiveProgram
Repair. In Computer Aided Verification - 25th International Conference, CAV.
[24]Xuan-Bach D. Le, Duc-Hiep Chu, David Lo, Claire Le Goues, and Willem Visser.
2017. S3: syntax- and semantic-guided repair synthesis via programming by
examples.In Proceedingsofthe201711thJointMeetingonFoundationsofSoftware
Engineering,ESEC/FSE 2017,Paderborn, Germany,September 4-8,2017.593–604.
[25]Xuan-Bach D. Le, David Lo, and Claire Le Goues. 2016. History Driven Program
Repair. In IEEE 23rd International Conference on Software Analysis, Evolution, and
Reengineering, SANER 2016, Suita, Osaka, Japan, March 14-18, 2016 - Volume 1.
213–224.[26]ClaireLeGoues,StephanieForrest,andWestleyWeimer.2013.Currentchallenges
in automatic software repair. Software Quality Journal 21, 3 (2013), 421–443.
[27]Chen Liu, Jinqiu Yang, Lin Tan, and Munawar Hafiz. 2013. R2Fix: Automatically
GeneratingBugFixesfromBugReports.In SixthIEEEInternationalConferenceon
SoftwareTesting,VerificationandValidation,ICST2013,Luxembourg,Luxembourg,
March 18-22, 2013. 282–291.
[28]Fan Long, Peter Amidon, and Martin Rinard. 2017. Automatic inference of code
transforms for patch generation. In Proceedings of the 2017 11th Joint Meeting
on Foundations of Software Engineering, ESEC/FSE 2017, Paderborn, Germany,
September 4-8, 2017. 727–739.
[29]FanLongandMartinRinard.2015. Stagedprogramrepairwithconditionsyn-
thesis. In Proceedings of the 23th ACM SIGSOFT International Symposium on
Foundations of Software Engineering, ESEC/FSE 2015. 166–178.
[30]Fan Long and Martin Rinard. 2016. Automatic patch generation by learning
correct code. In 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of
Programming Languages, POPL 2016. 298–312.
[31]FanLongandMartinC.Rinard.2016.Ananalysisofthesearchspacesforgenerate
andvalidatepatchgenerationsystems.In Proceedingsofthe38thInternational
Conference on Software Engineering, ICSE 2016, Austin, TX, USA, May 14-22, 2016.
702–713.
[32]Sonal Mahajan, Abdulmajeed Alameer, Phil McMinn, and William G. J. Hal-
fond. 2017. Automated repair of layout cross browser issues using search-based
techniques. In Proceedings of the 26th ACM SIGSOFT International Symposium on
SoftwareTestingandAnalysis,SantaBarbara,CA,USA,July10-14,2017.249–260.
[33]Matias Martinez,Thomas Durieux, Romain Sommerard, Jifeng Xuan, andMartinMonperrus. 2017. Automatic repair of real bugs in java: a large-scale experiment
on the defects4j dataset. Empirical Software Engineering 22, 4 (2017), 1936–1964.
[34]MatiasMartinezandMartinMonperrus.2015. Miningsoftwarerepairmodelsfor
reasoning on the search space of automated program fixing. Empirical Software
Engineering 20, 1 (2015), 176–205.
[35]Matias Martinez and Martin Monperrus. 2016. ASTOR: a program repair library
for Java (demo). In International Symposium on Software Testing and Analysis,
ISSTA 2016. 441–444.
[36]Sergey Mechtaev, Jooyong Yi, and Abhik Roychoudhury. 2015. DirectFix: Look-
ing for Simple Program Repairs. In 37th International Conference on Software
Engineering, ICSE 2015. 448–458.
[37]Sergey Mechtaev, Jooyong Yi, and Abhik Roychoudhury. 2016. Angelix: Scalable
MultilineProgram PatchSynthesisvia SymbolicAnalysis.In 38thInternational
Conference on Software Engineering, ICSE 2016.
[38]Benjamin Mehne, Hiroaki Yoshida, Mukul Prasad, Koushik Sen, Divya Gopinath,
and Sarfraz Khurshid. 2018. Accelerating Search-based Program Repair. In 11th
IEEEConferenceonSoftwareTesting,ValidationandVerification(ICST). Toappear.
[39]MartinMonperrus.2014. Acriticalreviewof"automaticpatchgenerationlearned
fromhuman-writtenpatches":essayontheproblemstatementandtheevalua-
tionofautomaticsoftwarerepair.In 36thInternationalConferenceonSoftware
Engineering, ICSE 2014. 234–242.
[40]Hoang Duong Thien Nguyen, Dawei Qi, Abhik Roychoudhury, and Satish Chan-
dra. 2013. SemFix: program repair via semantic analysis. In 35th International
Conference on Software Engineering, ICSE 2013. 772–781.
[41]Daniel Perelman, Sumit Gulwani, Dan Grossman, and Peter Provost. 2014. Test-
driven synthesis. In ACM SIGPLAN Conference on Programming Language Design
and Implementation, PLDI 2014. 43.
[42]Jeff H. Perkins, Sunghun Kim, Samuel Larsen, Saman P. Amarasinghe, Jonathan
Bachrach, Michael Carbin, Carlos Pacheco, Frank Sherwood, Stelios Sidiroglou,
Greg Sullivan, Weng-Fai Wong, Yoav Zibin, Michael D. Ernst, and Martin C.
Rinard. 2009. Automatically patching errors in deployed software. In Proceedings
of the 22nd ACM Symposium on Operating Systems Principles 2009, SOSP 2009, Big
Sky, Montana, USA, October 11-14, 2009. 87–102.
[43]YuhuaQi,XiaoguangMao,YanLei,ZiyingDai,andChengsongWang.2014. The
strengthofrandomsearchonautomatedprogramrepair.In 36thInternational
Conference on Software Engineering, ICSE ’14. 254–265.
[44]ZichaoQi,FanLong,SaraAchour,andMartinC.Rinard.2015. Ananalysisofpatch plausibility and correctness for generate-and-validate patch generation
systems.In InternationalSymposiumonSoftwareTestingandAnalysis,ISSTA2015.
24–36.
[45]Hesam Samimi, Max Schäfer, Shay Artzi, Todd D. Millstein, Frank Tip, and
LaurieJ.Hendren.2012. AutomatedrepairofHTMLgenerationerrorsinPHP
applicationsusing stringconstraintsolving. In 34thInternational Conferenceon
Software Engineering, ICSE 2012, June 2-9, 2012, Zurich, Switzerland. 277–287.
[46]SteliosSidiroglou-Douskos,EricLahtinen,FanLong,andMartinRinard.2015.
Automaticerroreliminationbyhorizontalcodetransferacrossmultipleappli-
cations. In Proceedings of the 36th ACM SIGPLAN Conference on Programming
LanguageDesignandImplementation,Portland,OR,USA,June15-17,2015.43–54.
[47]RishabhSingh,SumitGulwani,andArmandoSolar-Lezama.2013. Automated
feedbackgenerationforintroductoryprogrammingassignments.In ACMSIG-
PLANConferenceonProgrammingLanguageDesignandImplementation,PLDI
2013. 15–26.
22
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:49:35 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Jinru Hua, Mengshi Zhang, Kaiyuan Wang and Sarfraz Khurshid
[48]Rishabh Singh and Armando Solar-Lezama. 2011. Synthesizing data structure
manipulations from storyboards. In 19th ACM SIGSOFT International Symposium
on Foundations of Software Engineering, FSE 2011. 289–299.
[49]Edward K. Smith, Earl T. Barr, Claire Le Goues, and Yuriy Brun. 2015. Is the
cure worse than the disease? overfitting in automated program repair. In 23th
ACMSIGSOFT InternationalSymposiumonFoundations ofSoftwareEngineering,
ESEC/FSE 2015. 532–543.
[50]ArmandoSolar-Lezama.2013. Programsketching. STTT15,5-6(2013),475–495.
[51]SaurabhSrivastava,SumitGulwani,andJeffreyS.Foster.2010. Fromprogramver-ificationtoprogramsynthesis.In 37thAnnualACMSIGPLAN-SIGACTSymposium
on Principles of Programming Languages, POPL 2010. 313–326.
[52]FriedrichSteimann,MarcusFrenkel,andRuiAbreu.2013. Threatstothevalidity
and value of empirical assessments of the accuracy of coverage-based fault
locators.In InternationalSymposiumonSoftwareTestingandAnalysis,ISSTA2013.
314–324.
[53]Shin Hwei Tan, Hiroaki Yoshida, Mukul R. Prasad, and Abhik Roychoudhury.2016. Anti-patterns in search-based program repair. In Proceedings of the 24th
ACMSIGSOFT InternationalSymposiumonFoundations ofSoftwareEngineering,
FSE 2016, Seattle, WA, USA, November 13-18, 2016. 727–738.
[54]Yi Wei, Yu Pei, Carlo A. Furia, Lucas Serpa Silva, Stefan Buchholz, Bertrand
Meyer,andAndreasZeller.2010. Automatedfixingofprogramswithcontracts.
InInternational Symposium on Software Testing and Analysis, ISSTA 2010. 61–72.
[55]WestleyWeimer,ZacharyP.Fry,andStephanieForrest.2013. Leveragingpro-
gram equivalence for adaptive program repair: Models and first results. In 28th
IEEE/ACMInternationalConferenceonAutomatedSoftwareEngineering,ASE2013.356–366.
[56]WestleyWeimer,ThanhVuNguyen,ClaireLeGoues,andStephanieForrest.2009.
Automatically finding patches using genetic programming. In 31st International
ConferenceonSoftwareEngineering,ICSE2009,May16-24,2009,Vancouver,Canada,
Proceedings. 364–374.
[57]QiXinandStevenP.Reiss.2017. Identifyingtest-suite-overfittedpatchesthrough
test case generation. In Proceedings of the 26th ACM SIGSOFT International Sym-
posium on Software Testing and Analysis, Santa Barbara, CA, USA, July 10 - 14,
2017. 226–236.
[58]Yingfei Xiong, Jie Wang, Runfa Yan, Jiachen Zhang, Shi Han, Gang Huang, and
LuZhang.2017. Preciseconditionsynthesisforprogramrepair.In Proceedings
ofthe39thInternationalConferenceonSoftwareEngineering,ICSE2017,Buenos
Aires, Argentina, May 20-28, 2017. 416–426.
[59]Jifeng Xuanand Martin Monperrus. 2014. Learning to CombineMultiple Rank-
ingMetricsforFaultLocalization.In IEEEInternationalConferenceonSoftware
Maintenance and Evolution, ICSME 2014. 191–200.
[60]Zijiang Yang, Jinru Hua, Kaiyuan Wang, and Sarfraz Khurshid. 2018. Test-
Execution-Driven Sketching for Complex APIs. In 11th IEEE Conference on Soft-
ware Testing, Validation and Verification (ICST). To appear.
[61]Jooyong Yi, Umair Z. Ahmed, Amey Karkare, Shin Hwei Tan, and Abhik Roy-choudhury. 2017. A feasibility study of using automated program repair forintroductory programming assignments. In Proceedings of the 2017 11th Joint
Meeting on Foundations of Software Engineering, ESEC/FSE 2017, Paderborn, Ger-
many, September 4-8, 2017. 740–751.
23
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:49:35 UTC from IEEE Xplore.  Restrictions apply. 