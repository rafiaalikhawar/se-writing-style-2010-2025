Scalable Incremental Building with Dynamic Task Dependencies
Gabriël Konat
Delft University of Technology
Delft, The Netherlands
g.d.p.konat@tudelft.nlSebastian Erdweg
Delft University of Technology
Delft, The Netherlands
s.t.erdweg@tudelft.nlEelco Visser
Delft University of Technology
Delft, The Netherlands
e.visser@tudelft.nl
ABSTRACT
Incrementalbuildsystemsareessentialforfast,reproduciblesoft-
warebuilds.Incrementalbuildsystemsenableshortfeedbackcycles
when they capture dependenciesprecisely andselectively execute
build tasks efficiently. A much overlooked feature of build systems
istheexpressivenessofthescriptinglanguage,whichdirectlyinflu-
encesthemaintainabilityofbuildscripts.Inthispaper,wepresentanewincrementalbuildalgorithmthatallowsbuildengineerstouse
a full-fledged programming language with explicit task invocation,
value and file inspection facilities, and conditional and iterative
languageconstructs.Incontrasttopriorworkonincrementalityfor
suchprogrammablebuilds,ouralgorithmscaleswiththenumber
oftasks affectedbya changeandisindependent ofthesize ofthe
softwareprojectbeingbuilt.Specifically,ouralgorithmacceptsa
set of changed files, transitively detects and re-executes affectedbuild tasks, but also accounts for new task dependencies discov-ered during building. We have evaluated the performance of our
algorithm in a real-world case study and confirm its scalability.
CCS CONCEPTS
•Softwareanditsengineering →Softwareconfigurationman-
agement and version control systems;
KEYWORDS
scalable, incremental, build, dynamic task dependency
ACM Reference Format:
GabriëlKonat,SebastianErdweg,andEelcoVisser.2018.ScalableIncremen-
talBuildingwithDynamicTaskDependencies.In Proceedingsofthe2018
33rd ACM/IEEE International Conference on Automated Software Engineering
(ASE ’18), September 3–7, 2018, Montpellier, France. ACM, New York, NY,
USA,11pages.https://doi.org/10.1145/3238147.3238196
1 INTRODUCTION
Virtually every large software project employs a build system to
resolvedependencies,compilesourcecode,andpackagebinaries.
One great feature of build systems besides build automation isincrementality: After a change to a source or configuration file,
only part of a build script needs re-execution while other parts can
bereusedfromapreviousrun.Indeed,incrementalbuildsystems
Permission to make digital or hard copies of part or all of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthefirstpage.Copyrightsforthird-partycomponentsofthisworkmustbehonored.
For all other uses, contact the owner/author(s).
ASE ’18, September 3–7, 2018, Montpellier, France
© 2018 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-5937-5/18/09.
https://doi.org/10.1145/3238147.3238196area keyenablerfor shortfeedbackcycles.The reliableandlong-
term maintainable usage of incremental build systems requires the
following three properties:
•Efficiency :Themostobviousrequirementisthatrebuilds
must be efficient. That is, the amount of time required for a
rebuild must be proportional to how many build tasks are
affectedbyachange.Specifically,asmallchangeaffecting
few tasks should only incur a short rebuild time.
•Precision : An incremental rebuild is only useful if it yields
the exact same result as a clean build. To this end, incre-
mentalbuildsystemsmustcaptureprecisedependencyin-
formation aboutfile usageand task invocations.Make-like
build systems do not offer means for capturing precise de-
pendencies. Instead, over-approximation ( *.h) leads to inef-
ficiency because of considering too many files, and under-
approximation( mylib.h)leadstoincorrectrebuildsbecause
ofmissingdependencies(e.g., other.h).Precisedependency
information is required for efficient and correct rebuilds.
•Expressiveness : Like all software artifacts, build scripts
grow during a project’s lifetime [ 19] and require increasing
maintenance [ 17]. Therefore, build scripts should be writ-
ten in expressive languages, avoiding accidental complexity.
Thatis,buildscriptinglanguagesshouldnotrequirebuild
engineerstoapplycomplicated designpatterns(e.g.,recur-
sive [20] or generated Makefiles) for expressing common
scenarios.
Currentincrementalbuildsystemsputaclearfocusonefficiency
andprecision,butfallshortintermsofexpressiveness.Inparticular,
in order to support incremental rebuilds, current systems impose a
strictseparationofconfigurationandbuildstages.Allvariability
of the build process needs to be fixed in the configuration stage,
whereas the build stage merely executes a pre-configured build
plan. This model contradicts reality, where how to build an artifact
dependsontheexecutionofotherbuildtasks.Wehaveobserved
twosourcesofvariabilityinbuilding.First,basedontheresultof
other tasks, conditional building selects one of multiple build tasks
toprocessacertaininput.Second,basedontheresultofothertasks,
iterative building invokes build tasks multiple times on different
inputs.Inbothcases,dependenciesontaskinvocationsonlyemerge
during the build; build engineers cannot describe these dynamic
dependencies in the configuration phase. We illustrate a concrete
example in Section 2.
A solution to the expressiveness problem is to provide build
engineers with a full-fledged programming language. In such a
system,buildtasksareproceduresthatcaninvokeotherbuildtasks
intheirbody.Buildtaskscaninspecttheoutputofinvokedtasks
andusethattoconditionallyanditerativelyinvokefurthertasks.
The problem of such a programmable build system is that it is
76
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Gabriël Konat, Sebastian Erdweg, and Eelco Visser
difficult to achieve incrementality. We are only aware of a single
build system that is both programmable and incremental: Pluto [ 3].
Unfortunately, the incremental build algorithm of Pluto has an
importantlimitation:Tocheckwhichtasksneedre-execution,Pluto
needstotraversetheentiredependencygraphofthepreviousbuild
and has to touch every file that was read or written in the previousbuild. This contradicts our first requirement, efficiency, because the
rebuild time of Pluto depends on the size of the software project
more than it depends on the size of the change. In particular, even
when no file was changed, Pluto’s algorithm requires seconds to
determine that indeed no task requires re-execution. We illustrate
Pluto’s algorithm using an example in Section 2.
In this paper, we design, implement, and evaluate a new in-
cremental build algorithm for build systems with dynamic task
dependencies. While Pluto’s algorithm only takes the old depen-
dency graphas input andtraverses ittop-down, ouralgorithm also
takes a set of changed files and primarily traverses the dependency
graphbottom-up.Wecancollectchangedfiles,forexample,from
IDEs that manage their workspace or by using a file system watch-
dog. Our algorithm uses the changed files to drive rebuilding of
tasks, only loading and executing those tasks that are (transitively)
affected by a change. However, due to dynamic task dependencies,
thedependency graphcan changefrom onebuild tothe nextone.
Ourbuildalgorithmaccountsfornewlydiscoveredanddeletedtask
dependencies by mixing bottom-up and top-down traversals.
Ournewincrementalbuildalgorithmprovidessignificantperfor-
mance improvements when changes are small. We have conducted
areal-worldcasestudyontheSpoofaxlanguageworkbench,atool
builtfordevelopingdomain-specificlanguages(DSLs).Thebuild
script of Spoofax processes DSL specification files and generates
interpreters,compilers,andIDEplug-insforthem.Wefoundthat
our algorithm successfully eliminates the overhead of large depen-
dency graphs and provides efficient rebuilding that is proportional
to the change size.
Insummary,wemakethefollowingcontributions.Wereview
programmaticbuildscripts,incrementalbuildingwithPluto,and
why this does not scale (Section 2). We describe our key idea of
bottom-up incremental building, and what is needed to make it
work(Section 3)Wepresentourhybridincrementalbuildalgorithm
thatmixesbottom-upandtop-downbuilding(Section 4),andbriefly
discussitsimplementation(Section 5).Weevaluatetheperformance
ofthehybridalgorithmagainstPluto’salgorithmwithacasestudy
on the Spoofax language workbench (Section 6).
2 BACKGROUND AND PROBLEM
STATEMENT
Mostbuildsystemsprovidea declarative scriptinglanguage.Declar-
ativelanguagesaregreatastheyletdevelopersfocuson whatto
compute rather than howto compute it. However, we argue that
declarativityismisdirectedwhenitcomestodescribingsophisti-
cated build processes that involve conditional and iterative task
application.
For example, consider the build script in Figure 1. We wrote this
buildscriptinthePIEbuildscriptlanguage[ 16],whichmostlypro-
videsstandard programminglanguageconcepts. Thatis,the build
script performs iterative building by defining and calling functionsfunc main() -> string {
val config = parseYaml(./config.yaml)val src = config.srcDirif (config.checkStyle) {
val styleOk = checkStyle(src)if (config.failOnStyle && !styleOk)
return "style error"
}val userTests = ./test/**val genTests = genTests(src, ./test-gen)var failed = 0
for (test <- userTests ++ genTests) {
val testOk = runTest(test)
if (!testOk) failed += 1
}return "Failed tests: " + failed
}
func parseYaml(p: path) -> Config {...}func checkStyle(src: path) -> bool {...}func genTests(src: path, trg: path) -> path* {...}func runTest(test: path) -> int {...}
Figure 1: Build script that invokes tasks conditionally anditeratively at build time.
(tasks) like mainandparseYaml , stores results of tasks in local
variablessuchas configandsrcwhichcanbeimmediatelyused
bysubsequenttasks,andinvolvesconditionalbuildingwithcontrol
structureslike ifandfor.Byandlarge,ourbuildscriptisanor-
mal program that happens to handle file paths and invoke external
processes to generate and run tests. But how can we execute such
a programmatic build script incrementally?
Most build systems require declarative specifications of build
tasksforthisreason:tosupportefficientincrementalrebuilds.How-
ever, Erdweg et al. demonstrated that it is also possible to incre-
mentallyexecuteprogrammaticbuildscripts,with Pluto[3],abuild
system that incrementally executes build scripts written in Java.
ThePIElanguageweusedinourexampleisanalternativefront-end
to Pluto [16].
The build algorithm of Pluto constructs a dependency graph
of a build while the build script runs. For example, consider thedependency graph of our example script in Figure 2. The depen-
dency graph contains a node for each invoked task and for each
read or written file. Edges between nodes encode dependencies. A
task depends on the tasks it invokes and on the files it reads or
writes. Moreover, when a task reads a file that was generated by
another task, the reading task depends on the generating task such
thatthegeneratingtaskisexecutedfirst.Whilenotshowninour
graph, both task-task edges and task-file edges are labeled with
stamps(e.g.,timestamp,hashsum)thatdetermineifthetaskoutput
respectively file content is up-to-date.
The incremental build algorithm of Pluto takes the dependency
graphofthepreviousrunandselectivelyrerunstaskstoensurecon-sistencyofthebuild.Thedependencygraphofabuildisconsistent
if for each invoked task (i) all read and written files are up-to-date
and(ii)theoutputsofallcalledtasksareup-to-date.Anincremental
77
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. Scalable Incremental Building with Dynamic Task Dependencies ASE ’18, September 3–7, 2018, Montpellier, France
mainparse
Yaml(..)
check
Style(..)
gen
Tests(..)./conﬁg
.yaml
./src/A ./src/B./src/
B_aux
./test-
gen/
A./test-
gen/
B./test/
X
runTest
mainparse
Yaml(..)
check
Style(..)
gen
Tests(..)./conﬁg
.yaml
./src/A ./src/B./src/
B_aux
./test-
gen/
A./test-
gen/
B./test/
X
runTestmainparse
Yaml(..)
check
Style(..)
gen
Tests(..)./conﬁg
.yaml
./src/A ./src/B./src/
B_aux
./test-
gen/
A./test-
gen/
B./test/
X
runTest./src/C
./test-
gen/
C
runTestInitial dependency graphChange C1
Change C2 Change C3reads ﬁle
writes ﬁle
requires task
aﬀected by changemainparse
Yaml(..)
gen
Tests(..)./conﬁg
.yaml
./src/A ./src/B./src/
B_aux
./test-
gen/
A./test-
gen/
B./test/
X
runTestcheck
Style(..)
Figure 2: The dependency graph of a build captures task and file dependencies and is the basis for incremental building.
buildalgorithmiscorrectifitalwaysrestoresconsistency[ 3].Or
intuitively:acorrectincrementalbuildalgorithmyieldsthesame
result as a clean build. The challenge is to restore consistency with
as little computational effort as possible.
Forexample,letusassumetheinitialdependencygraph(top-left
inFigure 2)isconsistenttobeginwith. Wediscussthreedifferent
changesC1–C3:
•C1: If we change file config.yaml to turn off style check-
ing, task mainbecomes inconsistent since the stamp of its
file dependency changes (e.g., newer timestamp, changed
hashsum). We can restore consistency by rerunning tasks
parseYaml andmainonly; all other tasks remain consistent
sincetheyneitherinvoke mainnorreadfileswrittenby main.
The incremental build yields a new dependency graph (top-
right in Figure 2), where the new invocation of maindoes
not depend on checkStyle anymore.•C2: If instead, we change the content of user test ./test/X ,
taskrunTest(./test/X) becomes inconsistent and needs
rerunning.Sincetask maincallsrunTest(./test/X) ,itneeds
rerunning if the value returned by runTestchanges such
that we obtain a different number of failedtests. Either
way, the dependency graph remains unaffected (bottom-left
in Figure 2).
•C3:Finally,ifweaddasourcefile ./src/C,taskscheckStyle
andgenTests are affected because they depend on the di-
rectory./src. If the new file has a style error, this affects
mainandyieldsanewdependencygraphwherenotesting
occurs(notshown).Otherwise,letusassume genTests pro-
duces a new test ./test-gen/C for the added file, which
affectsmain’s scan of directory test-gen . During the sub-
sequent rerun of main, we discover a new task invocation
runTest(./test-gen/C) (bottom-right in Figure 2).
78
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Gabriël Konat, Sebastian Erdweg, and Eelco Visser
The incremental build algorithm of Pluto can handle these and
anyotherchangescorrectly.Moreover,thealgorithmisoptimally
incrementalinthesensethatitonlyexecutesataskifabsolutely
necessary. The basic idea of the algorithm is to start at the root
node(s)ofthedependencygraph,totraverseitdepth-first,andto
interleave consistency checking and rerunning. In particular, while
rerunningataskthatinvokesanothertask,iftheinvokedtaskexists
inthedependencygraph,continuewithconsistencycheckingof
theinvokedtaskandonlyrerunitifnecessary.Thisinterleaving
of consistency checking and rerunning is what enables support for
conditional and iterative task invocations.
Problem Statement. The incremental build algorithm of Pluto
hasanimportantlimitation.Irrespectiveofthechangedfiles,ithas
to traversethe entiredependency graphto check consistencyand
todiscovertasksthatneedrerunning.Whilethatmaybefinefor
largerchangesthataffectlargepartsofthegraphlike C3,theover-
headforsmall-impactchangeslike C2issignificant.Especiallyin
interactive settings, where developers routinely trigger sequences
of small-impact changes, this overhead can quickly render the sys-
temunresponsive.Theproblemisthatthealgorithmdoesnot scale
downtosmallchangeswhen scalingup tolargedependencygraphs.
Our goal is to design, realize, and evaluate a new incremental
build algorithm for programmatic build scripts that scales in thesize of a change. That is, rebuild times should be proportional to
the impact a change has on the overall build. In particular, rebuild
timesshouldbeindependentofthesizeofthedependencygraph.
These requirements preclude a full traversal of the dependency
graph to discover affected tasks as done by Pluto. Instead, our new
algorithmtakesthesetofchangedfilesasinputandonlyevervisits
affected tasks.
3 KEY IDEA AND CHALLENGES
ThekeyideatoincreasingthescalabilityofthePlutoalgorithmisto
executetasks bottom-up.Inthissection,wemotivatethisapproach,
and we discuss the corner cases that require adjustments to a pure
bottom-up algorithm.
3.1 Bottom-Up Traversal
Thekeyproblem ofthePluto buildalgorithmis thatit visitsand
checks tasks that are ultimately unaffected. For example, in change
C2in Section 2, only a single task ( runTest) is affected by the
change to file ./test/X . However, Pluto will visit and check all
reachabletasksinatop-downdepth-firsttraversal,includingthe
tasks that are not affected by the change ( parseYaml ,checkStyle ,
andgenTests ). Establishing that these tasks are unaffected is ex-
pensive, as our benchmarks demonstrate (Section 6).
To make the algorithm scale, it should only visit the nodes of
thedependencygraphthatareactuallyaffectedbyachange.The
changesthattriggerare-buildareto files,whichareatthe leavesof
thedependencygraph.Tasksthatneedtoberecomputeddepend
directly or indirectly on such file changes. Instead of looking for
tasksthatmayindirectlydependonachangeandgraduallygettingcloser to the actual change, as Pluto does, why not start with those
changes and the tasks that depend on them?Thekeyideaofouralgorithmisto traversethedependencygraph
bottom-up, driven by file changes, only visiting and checking af-
fected tasks. The algorithm first executes the tasks that are directly
affectedbychangedfiles.Forexample,inchange C2,file./test/X
changes, which directly affects task runTest(./test/X) , which
must therefore be re-executed. Tasks can also be indirectly affected
byafilechange,namelywhenitreadsafileproducedbyanaffectedtaskorwhenitreadstheoutputvalueofanaffectedtask.Forexam-ple,inchange
C3,file./src/Cisadded,whichtriggersre-execution
ofgenTests ,whichyieldsanewoutputvaluetomain,whichthus
is indirectly affected, re-executes, and creates a new runTest task.
A subsequent edit of file ./src/CtriggersgenTests again, which
producesthesamevalueasbeforebutupdatesthegeneratedfile
./test-gen/C , which affects the corresponding runTest task (the
maintask is not affected this time).
Thus,abottom-uptraversalexecutestasksthatareaffectedby
changed files or by other affected tasks, following a path from the
changedleavesofthedependencygraphtotheroot(s).However,
a pure bottom-up traversal is not adequate to support program-matic build scripts with dynamic dependencies. We discuss the
adjustments that are necessary to realize an adequate algorithm.
3.2 Top-Down Initialization
In order to perform a bottom-up traversal over the dependencygraph, we need a dependency graph to start with. Therefore, we
startwithPluto’stop-downalgorithmtoobtaintheinitialdepen-
dency graph. This is efficient, since every task is affected in the
initial build.
3.3 Early Cut-Off
By default, a bottom-up traversal takes the transitive closure of
dependencies,re-executingalltasksonthepathfromachangedfile
to the root(s) of the dependency graph. However, re-execution of a
taskdoesnotalwaysleadtoanewresult.Iftheresultwasthesame
as before, thepath to the root canbe cut off early.For example, in
C2maindependson runTest(./test/X) ,whichdependsonthe
changed ./test/X file. So, do we need to re-execute main? That
depends on the output of task runTest(./test/X) . If the result
isadifferent(integer)valuethanbefore,thenumberofteststhat
fail changes, and mainshould be re-executed Otherwise, mainis
not affected and we can cut off the build early1, as shown in the
bottom-left part of Figure 2.
3.4 Order of Recomputation
Anotherpotentialproblemofnaivebottom-upevaluationisthat
tasks may be executed multiple times. For example, in change
C3,maindepends on two existing affected tasks: checkStyle and
genTests .Apossibleexecutiontracewhen checkStyle doesaffect
main(notshowninthefigure),istoexecute checkStyle ,thenmain
whichisaffectedby checkStyle ,thenexecute genTests ,andthen
executemainagainbecauseitisaffectedby genTests .Executinga
task multiple times is not onlyinefficient, but also causes glitches:
inconsistent results that are exposed to users.
1In a real-world build script, runTestwould output a report of which tests fail and
why, and mainwould be re-executed whenever this changes. We support this, but
chose to keep the example from Section 2simple for demonstration purposes.
79
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. Scalable Incremental Building with Dynamic Task Dependencies ASE ’18, September 3–7, 2018, Montpellier, France
To avoidsuchre-executions, weshould ensurethatall affected
dependenciesofataskareexecutedbeforethetaskitself.Instead
of eagerly executing tasks when encountered during a bottom-up
traversal,we scheduletasksinapriorityqueue,whichistopologi-
cally sorted according to the dependency graph. Until the queue is
empty,scheduledtasksareremovedfromthefrontofthequeueand
executed.Thetopologicalorderingofthepriorityqueueensures
that task dependencies are executed before the task itself.
3.5 Dynamic Dependencies
Thefinalchallengeistosupportdynamicdependenciesduringa
bottom-up traversal. Consider change C3again, where a new task
runTests(./test-gen/C) isdiscoveredby main.Abottom-uptra-
versalcanneverdetectsuchadynamicdependency,sinceitonly
hasaccesstothedependencygraphofthepreviousrun.Toremedy
this, we temporarily switch to top-down depth-first building when
executingatask,sothatthetaskcandiscoverdependenciestonew
tasks,discover dependenciesto existingtasks,or removeexisting
dependencies.
When discovering a dependency to a new task, top-down depth-
first building continues recursively by (eagerly) executing the new
task.Forexample,inchange C3,taskmainis(indirectly)affected
and thus is built in a top-down manner (after its dependencies
checkStyle andgenTests havebeenbuilt),whichrecursivelycalls
taskrunTests(./test-gen/C) and registers a dependency to it.
Furthermore,whenadependencyisdiscoveredtoatask tthatexists
intheolddependencygraph,itmightbeaffectedalready.Thatis, t
and dependencies of tmay have been scheduled in the queue. We
cannot execute tbefore executing its dependencies. Therefore, we
temporarilyswitchbacktobottom-upbuilding,executingdepen-
denciesof tthatarescheduledinthequeue,until titselfisexecuted
or found unaffected. Then we switch back to top-down buildingand continue executing the caller. Finally, when a dependency is
removed (i.e., dependency to a task that was made in the previous
run, but not in this run), the dependency graph is updated, but no
further action is taken.
3.6 Dependency Graph Validation
AsinthePlutoalgorithm,wealsoneedtoenforcevalidityofthe
dependencygraphbydetectingoverlappinggeneratedfiles,hidden
task dependencies, and cyclic tasks. An overlapping generated file
occurs when more than one task generates (creates or writes to)the same file. This makes it unclear in which order those tasksmust be executed to bring the file into a consistent state, and istherefore disallowed. Furthermore, a hidden dependency occurs
whenataskrequires(reads)afilethatwasgeneratedbyanother
task,withouttherequiringtaskdependingonthegeneratortask.
Suchadependencymustbemadeexplicit,sothatthegeneratedfileisupdatedbythegeneratortaskbeforebeingreadbytherequiring
task. Finally, a task is cyclic when it (indirectly) calls itself. We
disallow cyclictasks toensure terminationof the buildalgorithm.
Wechecktheseinvariantson-the-flywhileconstructingthenew
dependency graph for subsequent incremental builds.1:varTq;varTe;varOc;varDGnew
2:function buildNewTask( t,DGold)
3:Te:=∅;Oc:=∅;DGnew:=DGold
4:exec(t)
5:function buildWithChangedFiles( F,DGold)
6:Te:=∅;Oc:=∅;DGnew:=DGold
7:Tq:=new PriorityQueue( DGold.depOrder())
8:schedAffByFiles( F,DGold)
9: whileTq/nequal∅do
10: execAndSchedule( Tq.poll() ,DGold)
Figure 3: Algorithm: Main build functions.
1:function execAndSchedule( t,DGold)
2:valr:=exec(t)
3:schedAffByFiles( r.дenFiles ,DGold)
4:schedAffCallersOf( t,r.output ,DGold)
5: returnr.output
6:function schedAffByFiles( F,DGold)
7: forf←Fdo
8: for(stamp ,t)←DGold .requireesOf( f)do
9: if¬stamp .isConsistent( f)then
10: Tq:=Tq∪t
11: if(stamp ,t)←DGold .generatorOf( f)then
12: if¬stamp .isConsistent( f)then
13: Tq:=Tq∪t
14:function schedAffCallersOf( t,o,DGold)
15: for(stamp ,tcall)←DGold .callersOf( t)do
16: if¬stamp .isConsistent( o)then
17: Tq:=Tq∪tcall
Figure 4: Algorithm: Bottom-up Building.
1:function exec(t)
2: ift∈Tethenabort
3:Te:=Te∪t;valr:=t.run();Te:=Te\t
4:DGnew:=DGnew∪r;validate( t,r);observe(t,r.output)
5:Oc[t]:=r.output;returnr.output
6:function require(t,DGold)
7: ifo←Oc[t]then return o
8: else ift∈DGoldthen return requireNow( t,DGold)
9: else return exec(t)
10:function requireNow( t,DGold)
11: whilevaltmin:=Tq.leastDepFromOrEq( t)do
12: Tq:=Tq\tmin
13: valo:=execAndSchedule( tmin ,DGold)
14: ift=tmin then return o
15:valo:=DGold .outputOf( t)
16:observe(t,o);Oc[t]:=o;returno
17:function validate( t,r)
18: forf←r.дenFiles do
19: for(_,tдen)←DGnew .generatorOf( f)do
20: ift/nequaltдen thenabort
21: forf←r.reqFiles do
22: for(_,tдen)←DGnew .generatorOf( f)do
23: if¬DGnew .callsTaskTr( t,tдen)thenabort
Figure 5: Algorithm: Execution, Requirement, and Valida-tion.
80
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Gabriël Konat, Sebastian Erdweg, and Eelco Visser
4 CHANGE-DRIVEN INCREMENTAL
BUILDING
In this section, we present our hybrid algorithm that mixes bottom-
upandtop-downincremental buildingbasedontheobservations
andideasfromtheprevioussection.Wepresentthealgorithmin
threeparts:mainfunctions(Figure 3),bottom-upbuilding(Figure 4),
and execution (Figure 5). All functions share four global variables
definedatthetopofFigure 3.Variable Tqisatopologicallyordered
priority queue of affected tasks that still need to be executed. Vari-
ableTeis a set of currently executing tasks, used to detect cyclic
tasks. Variable Ocis a cache of output values for tasks that have
alreadybeenexecuted.Finally,variable DGnewisthenewdepen-
dency graph that is constructed from the old dependency graph
and dynamic dependencies on-the-fly.
WeprovidetwoentrypointstoincrementalbuildinginFigure 3,
both of which first clear the set of executing tasks Te, clear the
cacheOc, and copy the old dependency graph DGoldtoDGnew.
Function buildNewTask istheentrypointforaninitialbuild.Func-
tionbuildNewTask then simply invokes function exec(Figure5)
to execute the task. We describe execbelow.
The second entry point buildWithChangedFiles is more inter-
estingasitinitiatesbottom-upbuilding.Ittakesasinputasetof
changed file paths F, represented as filesystem path strings such as
./config.yaml ,andtheolddependencygraph DGold.Thebasic
ideaistoscheduleandrunaffectedtasksusingpriorityqueue Tq
until all affected tasks are up-to-date. To this end, we create a new
priority queue using the task dependencies in DGoldas a topologi-
cal ordering. We call function schedAffByFiles (described below)
with the old dependency graph to find all tasks directlyaffected
by the changed file paths F, and add those tasks to the queue Tq.
Themainloopofbottom-upbuildingisthefollowing while-loop:
As long as there are affected tasks in the queue, poll a scheduled
task(retrievethetaskatthefrontandremoveit)fromthequeue,
execute it, and add all tasks affected by it to the queue. Since the
queue is topologically ordered, dependencies of tasks are executed
before the task itself. Unless a task itself does not terminate (for
exampleby recursivelycallingnewtasks adinfinitum),thequeue
becomes empty at some point since cyclic tasks are disallowed,
terminating the algorithm.
4.1 Bottom-Up Building
Whenever a task occurs in the priority queue Tq, it is definitely
affected (directly or indirectly) by changed files. Hence, no further
consistency check is necessary. Function execAndSchedule in Fig-
ure4acceptsanaffectedtask,runsitunconditionallyusing exec,
andschedulesnewtasksbasedonthegeneratedfilesandoutput
value of the executed task. If a task does not change or create new
generated files, nor produce a new output value, no new tasks will
be scheduled and building may be cut off early.
Function schedAffByFiles schedulestasksbasedonchanged
filepaths F.Iftasktrequiresachangedfileandthestamp stamphas
changed(isinconsistent)then tisaffectedbythechangeto fandis
scheduled by adding it to Tq. Analogously, if a task generates a file
thathaschanged,itisaffectedandthusscheduled.Astampcontains
asummaryofafile’scontent,suchasthelastmodificationdateorahash,andisusedtoefficientlycheckwhetherafilehaschangedwithisConsistent .Forexample,whenusingthefile’smodificationdate
asastamp,wecomparethemodificationdateinthestamp,with
thecurrentmodificationdateofthefileonthelocalfilesystem,and
considerthefilechangedifthemodificationdateisdifferent.We
use the old dependency graph DGold(computed in a previous run
ofthealgorithm)tofindtasksthatrequireafile( requireesOf ),and
to find the task that generates a file ( generatorOf ), along with the
stamp that was produced at the time the dependency was created.
Likewise, the schedAffCallersOf function schedules callers
of tasktbased on changes to its output value o.I ftcallhas a
dependency to task t, and that dependency is inconsistent with
relation to the new output value ooft, thentcallis affected by
the new output value oand is scheduled. Similarly, we use a stamp
oftheoutputvalue,whichcouldbethefulloutputvalue,suchas
anintegerrepresentingthenumberoffailingtests,orasummary
ofthevaluesuchasahash,andcomparethestampwiththenew
outputvaluewith isConsistent .Finally,theolddependencygraph
DGoldis used to find callers of a task with callersOf.
4.2 Execution, Requirement, and Validation
Function exec(Figure5) executes the body of t. During task ex-
ecution, a task may require (call) other tasks with the require
function.Therefore,wefirstneedtocheckifwearealreadyexecut-ingtask
t,andabortwhenacycleisdetected.Then,weadd ttothe
set of executing tasks Te,runthe body of the task, and remove t
fromTe.Onceexecutioncompletes,weupdatethenewdependency
graphDGnewwiththeresult rofexecuting t.Aresult rcontains
thedynamicdependenciesthetaskmadeduringexecution:aset
reqFilesofreadfiles, дenFilesofcreatedorwrittentofiles,anda
setreqTasks of other tasks that were called by t; and the output
valueoutputthat the taskproduced. A dependency graph DGis a
set of those results, where each task has a single result. We then
validate thenewdependencygraph,callanyexternalobservers
of the task’s output with observe, cache the output, and finally
return the output.
Weusefunction exectoexecutetasksbothduringbottom-up
and top-down traversals. While execis agnostic to the traversal
order, function requiremust take care to handle tasks required
bottom-up and top-down correctly. We distinguish three cases. If t
wasalreadyexecuted(visited)thisrun,wereturnitscachedoutput
valueOc[t]. Otherwise, we check if twas in the old dependency
graphDGold. If tasktis new and does notoccur inDGold, then
we execute it unconditionally. Note that no existing task in DGold
can depend or be affected by the new task t.
Iftasktexistedbeforein DGold,weonlyexecuteitifitisactually
affected.Sincethecallerof tawaitstheoutputof t,weusefunction
requireNow toforceitscheckingandpossibleexecution now.Task
tis affected if it occurs in queue Tqor if any of its dependencies
occurringin Tqwillaffectitlater.Function requireNow repeatedly
finds dependency tminoftthat is lowest in the dependency graph
(closes to the leaves). Since the queue only contains affected tasks,
we execute tminand schedule tasks affected by it. We continue
until either we have executed the required task t, or until no more
dependenciesoftask tareaffectedandwecanreuse t’soutputvalue
from the old dependency graph with DGold .outputOf( t). Note
that this latter case always triggers for tasks scheduled bottom-up
81
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. Scalable Incremental Building with Dynamic Task Dependencies ASE ’18, September 3–7, 2018, Montpellier, France
bybuildWithChangedFiles , because their dependencies cannot
occur inTqanymore.
Thevalidate function incrementally validates the correctness
of the new dependency graph after executing a task t. For a depen-
dency graph to be correct, it may not have overlapping generated
files, nor any hidden dependencies. If another task tдengenerates
the same file fastdoes, there is an overlapping generated file and
execution is aborted. Furthermore, if trequires a file fwithout a
(transitive) task dependency on tдenthat generates f, there is a
hidden dependency and execution is aborted. In both cases, this
signals that there is an error in the build script.
4.3 Properties
Anincrementalbuildalgorithmiscorrectifitproducestheexact
sameresultasacleanbuild.Therefore,allaffectedandnewtasks
must be executed. Our algorithm is correct for tasks in the old
dependency graph: if a task is affected, it will be scheduled. A task
is affected directly by depending on a changed file, or indirectly
(transitively) bydepending ona changedfile that anaffected task
generates,orbydependingonthechangedoutputofanaffected
task. All indirectly affected tasks are always found by traversing
thedependencygraphbottom-up,throughpollingthequeueand
scheduling affected tasks. Finally, all scheduled tasks are executed.
Our algorithm is also correct for new tasks that are executed
top-downlikethePlutoalgorithm,whichiscorrect[ 3].Theonly
difference is the reqireNow function which first executes the de-
pendencies of the task, but does eventually execute the task itself.
Therefore, the hybrid algorithm is correct.
For optimality, we only consider and execute affected tasks. For
existing tasks, this is true because only affected tasks scheduled.
Newtasksareaffectedandalwaysexecuted.However,weonlywant
to execute neededtasks. The hybrid algorithm considers all task in
theolddependencygraphasneeded.Thisisanoverapproximation,because it can happen that an affected task is not needed any more
after top-down execution, since a task may remove its dependency
toanaffectedtask.Therefore,theoretically,thehybridalgorithmis
onlypartiallyoptimal.Ho wever, this is a rare case, as shown in the
evaluation in Section 6.
5 IMPLEMENTATION
Wehaveimplementedthehybridalgorithmasanalternativeexe-
cutionalgorithmforPIE[ 16],asystemfordevelopinginteractive
softwaredevelopmentpipelines,consistingofaDSLandAPIfor
implementing interactive pipelines, and a runtime for incremen-
tallyexecutingthem.Interactivesoftwaredevelopmentpipelines
are similar to incremental build systems: they are used to incre-
mentally build software artifacts, and also require fast feedback for
usage in interactive environments with many low-impact changes
such as IDEs and code editors. PIE builds forth on Pluto by reusing
itsmodelandalgorithm,butprovidesaconciseandexpressiveDSL
fordevelopinginteractivepipelinesandbuildscripts,minimizing
boilerplate in contrast to Pluto’s Java API.
Our algorithm is implemented as a separate executor in the PIE
runtime,fullyconformingtoitsAPI.Thatis,wecanrunexisting
PIEbuildscriptswithoutchangestoouralgorithm.Furthermore,
sincePIEimplementsthePlutobuildalgorithm,wecancompareour algorithm against Pluto’s, for the exact same build scripts. PIE,
includingourhybridalgorithm,isopensourcesoftwarethatcan
be found online2.
6 EVALUATION
Inthissection,weevaluatetheperformanceofthehybridalgorithm,
compared to Pluto’s pure top-down algorithm. We describe our
experimentalsetup,showtheresults,interpretthem,anddiscuss
threats to validity.
6.1 Experimental Setup
We compare the performance of the Pluto incremental build al-
gorithm, as implemented in the PIE runtime, against our hybrid
incrementalbuildalgorithm,whichwehaveimplementedinPIE
runtime.
Build Script. Asabuildscript,wereusetheSpoofax-PIEpipeline,
areimplementationofalargepartoftheSpoofaxpipeline,which
was used as a case study of PIE [ 16]. Spoofax [ 13] is a language
workbench[ 4](asetoftoolsfordevelopinglanguages)inwhichlan-
guagesare specifiedinterms ofmeta-languages,suchas SDF[ 27]
forsyntaxspecification,andNaBL[ 15,23,26]fornameandtype
analysis. The Spoofax pipeline derives artifacts from a languagespecification, such as a parse table for parsing, and a constraint
generatorand solverforsolving nameandtypeanalysis. Further-
more, Spoofax supports interactive language development in an
IDEsetting,enablingalanguagedevelopertomodifyalanguage
specification,resultinginimmediatefeedbackinexampleprograms
of that language, and also supports developing multiple languages
side-by-side. The Spoofax-PIE reimplementation supports these
features. The build script is open-source and can be found online3.
Asinput,theSpoofaxbuildscripttakesaworkspacedirectory
consisting of language specifications, where each language specifi-
cationhasaconfigurationfiledescribinghowtobuildthelanguage
specification,aspecificationofthesyntax,styling,andnameand
typeanalysisinmeta-languages,andexampleprograms.Aconfigu-
ration file at the root of the workspace lists the locations of all lan-
guage specifications, and locations of the Spoofax meta-languages.
As a concrete workspace, we use a directory with three Spoofax
languagespecificationsfortheTiger,Calc,andMiniJavalanguages.
DescribingtheSpoofaxbuildscriptisoutsideofthescopeofthis
paper.However,wedoarguewhySpoofaxrequiresaprogrammatic
build script with dynamic dependencies. The Spoofax build script
frequently makes use of conditional building, where the resultof executing a task influences a condition for another task. Forexample, when a program fails to parse, the program cannot be
analyzed, since analysis requires an AST. Therefore, a condition
that checks whether the parsing task succeeds guards the analysis
task. Furthermore, Spoofax also makes frequent use of iterative
building, where tasks are invoked multiples on different inputs
which are outputs of previous tasks. For example, there is a single
task description for parsing a file, which is dispatched based on
theresultofparsingtheworkspaceconfigurationfile,parsingthe
language specification configuration files, the concrete files thatare in the workspace, and the extension of each file. Without a
2https://github.com/metaborg/pie
3https://github.com/metaborg/spoofax-pie
82
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Gabriël Konat, Sebastian Erdweg, and Eelco Visser
programmaticbuildscript,alltheseformsofvariabilitywouldhave
tobeencodedintheconfigurationstepofadeclarativebuildscript,
which is not possible because many values only become evident
during build script execution.
Changes. Tomeasureincrementalperformance,wehavesynthe-
sizedachainof60realisticchangeswithvaryingimpacts.First,a
from-scratch buildis performedthat builds alllanguage specifica-
tions. Then, we make changes in the form of opening or changing
atexteditor,requiringexecutionofataskthatprovidesfeedback
for that editor, or of modifying and saving a file, which requires
execution of tasks that keep the workspace up-to-date.
Changes include: editing and saving example programs, styling
specifications, syntax specifications, and name and type analy-sis specifications; adding a new language specification; undoing
changes; and two extreme cases where we run the build with no or
allfileschanged.Thesechangeshavevaryingimpacts,wherethe
impact is determined by how many tasks are affected by a change,
andtheruntimeofthosetasks.Forexample,changingasyntaxdefi-nitionfilerequiresrecompilationoftheparsetableandreparsingof
all example programs. Changing the name and types specification
has a larger impact because it requires regeneration of a constraint
generator,compilationoftheconstraintgenerator,applicationof
thegeneratoragainstallexampleprograms,andfinallyapplication
of the constraint solver to solve all generated constraints. A small
impactchangeiseditinganexampleprograminaneditor,which
just requires parsing, styling, and analysis for that program.
WeruntheexactsamechangesagainstthePlutoandourhybrid
algorithm,withtheonlydifferencethatwepassthechangedfilesto
our hybrid algorithm, whereas Pluto does not require this. We run
thechainofchangesagainstonealgorithminonego,tosimulatea
full editing session.
Technicalities. We run the benchmark using the JMH [ 1] bench-
markingframework,whichrunsthebenchmarkforanalgorithm
in a separate forked JVM, letting the JVM JIT fully specialize to
that algorithm. Furthermore, it runs the benchmark multiple times
beforestartingmeasurements,toensurethattheJVMiswarmed
up. Finally, it ensures that the garbage collector is executed before
running a benchmark, so that garbage produced in a previous run
does not influence the new one.
Wehave executedthe benchmarkon aMacBookPro witha 2.7
GHz Intel Core i7 processor, 16 GB of 1600 MHz DDR3 memory,
andaSSD,runningmacOS10.12.6.Thebenchmarkwasexecuted
witha64-bitJREofversion1.8.0b144,with16MBofstackmemory,
and 4 GB of heap memory.
6.2 Results and Interpretation
Wenowshowthebenchmarkingresultsandinterpretthem.Itisnot
possibletodiscusstimemeasurementsforall60changes.Therefore
we aggregate the time taken for different kinds of changes and
show those instead. Figure 6shows the time measurements for
eachaggregatedchange,forboththePlutoandhybridalgorithm,
inacolumnchartwithlogarithmicscale.Wenowgoovertheresults
for each kind of change.
A) Initial build. First, we perform an initial build, building all
language specifications. To obtain the initial dependency graph,we use top-down building. Therefore, both the Pluto and hybrid
algorithm perform identically.
B) Editor changes. Weaggregatetherunningtimeforalleditor
changes: both opening new editors and editor text changes, for ex-
ampleprogramsandlanguagespecifications.Foralleditorchanges
combined, the hybrid algorithm is 11 seconds faster, providing a
speedupof1016%.Thespeedupishighbecausethesechangeshave
a small impact, and therefore are efficiently handled by the hybrid
algorithm.ItisimportanttoquicklyprocesseditorchangesinIDEs,
as programmers make many changes to editors and require fast
feedback cycles.
C) Example program file changes. We modify the files of several
example program, and add a new example program file. For these
changes combined, the hybrid algorithm takes 0.005 seconds, pro-
viding a 9 second (182133%) speedup. Again, these changes have a
small impact, and are therefore efficiently handled by the hybrid
algorithm,whereasthePlutoalgorithmstillrequirescheckingof
the entire dependency graph.
D) Styling specification change. We modify the styling specifi-
cationoftheCalclanguage,andaddastylingspecificationtothe
Tigerlanguage.Forthesechanges,thehybridalgorithmis8seconds
faster, providing a 1245% speedup. The impact of these changes
areslightlylarger:changestothestylingspecificationrequirere-
stylingofopeneditors,butarestillrelativelysmallerinimpactand
thus efficiently handled.
E) Adding language specification. We add the MiniJava language
totheworkspace,requiringittobebuilt,anditsexampleprograms
to be processed. Since this change causes many new tasks to be
executed,itsimpactislarge.Thehybridalgorithmperformsroughly
the same as the Pluto algorithm, providing only a 2.9 second (11%)
speedup because of reduced dependency graph checking.
F) Syntax specification small change. Wemodifylexicalsyntax
definitionoftheCalclanguagetoparsenumbersincorrectly,and
undo the change afterwards. This requires the parse table to be
rebuilt,andrequiresprocessingofCalc’sexampleprograms.The
hybridalgorithm providesa 4.5second(118%) speedup,becausea
smaller part of the dependency graph is checked.
G) Syntax specification cascading change. We modify the Calc
syntax definition in such a way that the resulting parser will failto parse all example programs, and also in such a way that new
ASTsignaturesneedtobegenerated.Fromthesyntaxspecification,
Spoofax generates AST signature files that the name and type anal-
ysisuses.Thesesignaturefileshavechanged,thereforerequiring
the name and type analysis specification to be recompiled. Finally,
all example programs must be reparsed and reanalyzed.
However,becauseexampleprogramscannotbeparsedanymore,
theyalsocannotbeanalyzedanymore,sincenameandtypeanaly-
sisrequiresanAST.Therefore,thedependencyfromtheprocess
example file task, to the task that analyzes the AST of an example
program, disappears. The Pluto algorithm first visits the processexample file task, which removes its dependency to the analysistask, and therefore never recompiles the name and type analysis
specification. However, the hybrid algorithm goes bottom-up to
firstrecompilethenameandtypeanalysisspecification,andonly
thenexecutestheprocessexamplefiletask,thereforeexecutinga
83
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. Scalable Incremental Building with Dynamic Task Dependencies ASE ’18, September 3–7, 2018, Montpellier, Franceaggregate runtime in seconds
1s10s100s
ABCDEFGH I JKL70.1
0.049.1
18.8
3.021.5
3.927.5
0.7 0.01.168.7 69.8
3.350.9
28.6
17.6
8.4 8.530.4
8.8 9.112.168.1pluto hybrid
0.005 0.7 0.00001
Figure6:Columnchartwithaggregatebenchmarktimemeasurements.Thex-axisrepresentthedifferentchanges(described
below), the y-axis represents the time taken in seconds in logarithmic scale. For each change, we show the time taken forthe Pluto algorithm and our hybrid algorithm. A = initial build, B = all editor changes, C = example program changes, D =stylingspecificationchanges,E=addinglanguagespecification,F=syntaxspecificationsmallchange,G=syntaxspecification
cascading change, H = syntax specification refactor, I = analysis specification changes, J = analysis specification refactor, K =
no changes, L = all files changed.
taskthatwasnotrequiredtobeexecuted.Inthiscase,thehybrid
algorithm was 13 seconds slower, causing a 61% slowdown.
Thisisatradeoffofthehybridalgorithm:ifadependencytoa
task disappears, the hybrid algorithm will still visit it. However,
these cases are very rare, only a single change triggers this kind of
behavior. For example, if at least one example program could be
parsed into an AST (possibly through error recovery), the analysis
specification has to be recompiled. We undo the change afterwards
to make example programs parse again.
H) Syntax specification refactor. WerefactorapartoftheMini-
Java syntax definition into another file, which results in a semanti-
callyequivalentparser.Thehybridalgorithmprovidesa14.5second
(483%)speedup,becauseitfirst rebuildstheparsetable,detectsthat
it did not change, and then cuts off the build early. Contrary to the
previous change, a bottom-up traversal here helps in cutting down
theincrementalbuildtime,bynoteventraversingtheunaffected
part of the dependency graph.
I) Analysis specification change. Wemodifythenameandtype
analysisspecificationoftheCalclanguage,suchthatitscopesbind-
ingsdifferently,andundothechangeafterwards.Becausechanging
thesespecificationshasamoderateimpact,thehybridalgorithm
providesamoderate9.7secondspeedup(52%).
J) Analysis specification refactor. We refactor a part of the Tiger
nameandtypeanalysisspecificationintoanotherfile.Eventhough
this results in a semantically equivalent analyzer, the change detec-
tionoftheSpoofax-PIEbuildscriptisnotsmartenoughtodetect
this.Becausecompilingthenameandtypeanalysisspecification,
andthenperformingconstraintsolvingforallTigerexamplepro-
grams, is expensive, this change has a large impact. Therefore, the
Pluto and hybrid algorithm perform nearly identically.K) No changes. Whentherearenochanges,thehybridalgorithm
essentially performs no work, completing in sub-millisecond time,
whilethePlutoalgorithmstillneedstochecktheentiredependency
graph,costing3.3secondsoftime.Thisistheconstantoverheadthat
even small-impact changes suffer from with the Pluto algorithm,
which the hybrid algorithm saves.
L) All files changed. Finally,wechangeallsourcefilesbyappend-
ing a space to the end of each file. Realistically, this kind of change
can happen when checking out a different branch in a source con-
trol management system such as Git. When all source files change,
usingabottom-upapproachmakesnosense,since(almostall)tasks
will be affected, while incurring overhead because of scheduling.
Therefore, we detect when more than 50% of source files (all re-
quiredfiles,forwhichthereisnogeneratortask)change,andrunatop-downbuildwiththePlutoalgorithminstead,thereforerunning
as fast as the Pluto algorithm does. This heuristic seems to work
well, but may require further tweaking.
Conclusion. Wecanconcludethat,forthisbuildscriptandwork-
space directory, our algorithm scales better with the impact of a
changethanthePlutoalgorithm,formanykindsofchanges.The
onlyexceptionsbeingwhenallfilesarechanged,forwhichafull
rebuild could be triggered, or when a dependency to an expensive
task is removed, which rarely happens.
6.3 Threats to Validity
A possible threat to validity is that we have benchmarked the algo-
rithms against a single build script. However, it is a complex build
script that represents the realistic scenario of interactive language
developmentinalanguageworkbench.Forexample,thebuildscript
84
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Gabriël Konat, Sebastian Erdweg, and Eelco Visser
requires dynamic file dependencies in order to track precise depen-
dencies which only become evident during a build. Furthermore, it
alsorequiresdynamictaskdependencies,inordertodispatchthe
correcttasksbasedontheconfigurationoftheworkspaceandeach
language specification.
Anotherpossiblethreatisthatwehavesynthesizedachainof
changes, instead of using existing change scenarios. However, we
have constructed 60 changes to different kinds of aspects; such
as changing an example program, and changing a file of the syn-
taxspecification;andwithvaryinglevelsofimpact,rangingfrom
changing the text in a single editor, to changing a file of the name
andtypespecification,whichtransitivelyaffectsmanyothertasks.
7 RELATED WORK
Thereisalargebodyofworkonincrementalbuildsystems.Make[ 25]
isanincrementalbuildsystemwithdeclarativebuildrulesbased
onfiles.Ithaslimitedsupportfordynamicfiledependencies,and
nopropersupportfordynamictaskdependencies.Becauseofthese
limitations,Makescaleswellforsimplebuildscripts,sinceitcan
firsttopologicallysortdependencies,iterateover thedependencies,
and incrementally execute affected tasks. While it is possible to
emulate dynamic task dependencies, this requires tedious Makefile
generation, encoding of all dependencies as files, and recursive
Make execution. Therefore, Make is not sufficient for more compli-
cated build scripts.
Many build systems follow a similar approach to Make, first
building a task DAG, and then executing it. For example, Gra-dle [
12], Bazel [6], Buck [5], PROM [ 14], Fabricate [ 11], Tup [24],
and Ninja [ 18] follow this approach, with slight variations. Gradle
is a build automation tool, programmable in the Groovy language,
that, like our hybrid algorithm, also supports values as inputs and
outputsoftasks.PROMreplacesdeclarativemakeruleswithlogicalprogramming,whilekeepingthesameincrementalbuildalgorithm.
Fabricate uses system tracing to automatically infer file dependen-
cies, but is only supported on Linux. Tup, like our hybrid build
algorithm, requiresa list ofchanged files asinput, instead ofscan-
ning all files, to more efficiently build the task DAG. Ninja, unlike
Make, detects changes to the commands of a rule, resulting in a
rebuild if the rule is changed. None of the above systems supports
dynamic file or task dependencies.
Somebuildsystemsintertwineincrementalexecutionwiththe
discoveryoffileandtaskdependencies.Pluto[ 3]isaJavalibrary
fordevelopingincrementalbuildscriptswithdynamicdependen-
cies. As discussed throughout this paper, Pluto uses a top-downalgorithm that does not scale to small changes over large depen-
dencygraphs.OMake[ 10]isabuildsystemwithMake-likesyntax,
but with a richer dependency tracking mechanism and a more
complicatedalgorithm.Ithaslimitedsupportfordynamicfilede-
pendencies through scanner rules that scan depfiles and register
their dependencies during execution. However, it does not support
dynamic task dependencies; all tasks dependencies are specified
staticallyinthebuildrules.Shake[ 21,22]isaHaskelllibraryfor
implementing buildscripts with incrementalexecution. It haslim-
itedsupportfordynamicfiledependencies,allowingneededfiles
tobediscovereddynamically,butgeneratedfiledependenciesmustbespecifiedstaticallyasthebuildtarget.Italsohaslimitedsupportfordynamictaskdependencies:Tasksarenamedbykeys,andthose
tasks can be required like files through their keys. However, these
tasks are not parameterized, nor can they return values, making
their use as dynamic task dependencies tedious.
Our work is also related to approaches on incremental comput-
ing. Datalog [ 2] is a logic programming language with incremental
solvers [7]. The are several differences between our hybrid algo-
rithm and incremental Datalog solvers. Datalog solvers can deal
with cycles, eagerly compute all facts, and use static dependencies
fromtheDatalogprogram,whereasthehybridalgorithm(andbuild
systems in general) disallow cycles, only compute demanded facts,
and use dynamic dependencies.
Adapton [ 8,9] is a library for on-demand (lazy) incremental
computation. Like the Pluto and our hybrid algorithm, Adapton
supports a form of dynamic task dependencies: dynamic compu-
tation dependencies which form a computation graph. Initially,
Adapton builds a full computation graph. Then, to achieve incre-
mentality, when a node in the computation graph is affected bya change, it transitively marks all dependent nodes by setting a
dirty flag. Then, when a computation result is demanded, it transi-
tivelyrerunsalldirtynodesthatarerequiredbythecomputation.
The downside of dirty flagging is that it is an over-approximation
of what actually needs to be executed, ignoring cases where the
output of a computation does not change. In build systems, where
many tasks may depend on a single compiler task, and where com-
putations include calling compilers that can run for seconds to
evenminutes,avoidingrecomputationwhendependenciesdonot
change,iscrucial.Forexample,whenwechangeasyntaxspecifi-
cation, but the resulting parse table does not change, dirty flagging
has already marked parsing all example files as dirty. Therefore,our hybrid algorithm checks outputs of task to cut off the build
early, instead of performing dirty flagging and propagation.
8 CONCLUSION
We have shown the need for an efficient, precise, and expressive
build system. Many build systems are efficient and precise, but not
expressive,makingcomplexbuildscriptdevelopmenttedious.Pluto,
a recent incremental build system that supports programmablebuild scripts with dynamic dependencies, is expressive, but doesnot scale with the impact of a change, because it requires a top-
down traversal over the entire dependency graph for each change.
To overcome this scalability problem, we have realized a hybrid
algorithm that mixes bottom-up building for scalability, and top-
down building for expressiveness through dynamic dependencies.
Wehaveevaluatedtheperformanceofourhybridalgorithmagainst
Pluto’salgorithm,withacasestudyontheSpoofaxlanguagework-
bench.Theevaluationdemonstratesthatthehybridalgorithm,with
the exception of one kind of change, indeed scales better with the
impactofachange,andisthereforefasterthanthePlutoalgorithm,
in particular for low-impact changes.
ACKNOWLEDGEMENTS
ThisresearchwassupportedbyNWO/EWFreeCompetitionProject
612.001.114 (Deep Integration of Domain-Specific Languages) and
NWOVICIProject(639.023.206)(LanguageDesigner’sWorkbench).
85
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. Scalable Incremental Building with Dynamic Task Dependencies ASE ’18, September 3–7, 2018, Montpellier, France
REFERENCES
[1][n.d.].JavaMicrobenchmarkingHarness(JMH). http://openjdk.java.net/projects/
code-tools/jmh/. [Online; accessed 27-April-2018].
[2]S.Ceri,G.Gottlob,andL.Tanca.1989. WhatYouAlwaysWantedtoKnowAbout
Datalog (And Never Dared to Ask). IEEE Trans. on Knowl. and Data Eng. 1, 1
(March 1989), 146–166. https://doi.org/10.1109/69.43410
[3]Sebastian Erdweg, Moritz Lichter, and Manuel Weiel. 2015. A sound and optimal
incremental build system with dynamic dependencies. In Proceedings of the 2015
ACMSIGPLANInternationalConferenceonObject-OrientedProgramming,Systems,
Languages,and Applications,OOPSLA2015, partofSPLASH 2015,Pittsburgh,PA,
USA, October 25-30, 2015, Jonathan Aldrich and Patrick Eugster (Eds.). ACM,
89–106. https://doi.org/10.1145/2814270.2814316
[4]Sebastian Erdweg, Tijs van der Storm, Markus Völter, Meinte Boersma, Remi
Bosman,WilliamR.Cook,AlbertGerritsen,AngeloHulshout,StevenKelly,Alex
Loh, Gabriël Konat, Pedro J. Molina, Martin Palatnik, Risto Pohjonen, Eugen
Schindler, Klemens Schindler, Riccardo Solmi, Vlad A. Vergu, Eelco Visser, Kevin
vanderVlist,GuidoWachsmuth,andJimivanderWoning.2013. TheStateof
the Art in Language Workbenches - Conclusions from the Language Workbench
Challenge. In Software Language Engineering - 6th International Conference, SLE
2013, Indianapolis, IN, USA, October 26-28, 2013. Proceedings (Lecture Notes in
Computer Science), Martin Erwig, Richard F. Paige, and Eric Van Wyk (Eds.),
Vol. 8225. Springer, 197–217. https://doi.org/10.1007/978-3-319-02654-1_11
[5]Facebook. [n. d.]. Buck: a fast build tool. https://buckbuild.com/. [Online;
accessed 27-April-2018].
[6]Google.[n.d.]. Bazel-afast,scalable,multi-languageandextensiblebuildsystem.
https://bazel.build/. [Online; accessed 27-April-2018].
[7]AshishGuptaandInderpalSinghMumick.1995. MaintenanceofMaterialized
Views: Problems, Techniques, and Applications. IEEE Data Eng. Bull. 18, 2 (1995),
3–18.http://sites.computer.org/debull/95JUN-CD.pdf
[8]Matthew A. Hammer, Joshua Dunfield, Kyle Headley, Nicholas Labich, Jeffrey S.
Foster,Michael W.Hicks, andDavidVan Horn.2015. Incrementalcomputation
withnames.In Proceedingsofthe2015ACMSIGPLANInternationalConference
on Object-Oriented Programming, Systems, Languages, and Applications, OOPSLA
2015, part of SPLASH 2015, Pittsburgh, PA, USA, October 25-30, 2015, Jonathan
Aldrich and Patrick Eugster (Eds.). ACM, 748–766. https://doi.org/10.1145/
2814270.2814305
[9]Matthew A. Hammer, Yit Phang Khoo, Michael Hicks, and Jeffrey S. Foster.
2014. Adapton:composable,demand-drivenincrementalcomputation.In ACM
SIGPLANConferenceonProgrammingLanguageDesignandImplementation,PLDI
’14, Edinburgh, United Kingdom - June 09 - 11, 2014, Michael F. P. O’Boyle and
Keshav Pingali (Eds.). ACM, 18. https://doi.org/10.1145/2594291.2594324
[10]Jason Hickey and Aleksey Nogin. 2006. OMake: Designing a Scalable BuildProcess. In Fundamental Approaches to Software Engineering, Luciano Baresi
and ReikoHeckel (Eds.).Springer BerlinHeidelberg,Berlin, Heidelberg,63–78.
https://doi.org/10.1007/11693017_7
[11]B. Hoyts and Simon Alford. 2009. fabricate. https://github.com/SimonAlfie/
fabricate. [Online; accessed 27-April-2018].
[12]Gradle Inc. [n. d.]. Gradle Build Tool. https://gradle.org/. [Online; accessed
27-April-2018].
[13]Lennart C. L. Kats and Eelco Visser. 2010. The Spoofax language workbench:
rules for declarative specification of languages and IDEs. In Proceedings of the
25thAnnualACMSIGPLANConferenceonObject-OrientedProgramming,Systems,
Languages, and Applications, OOPSLA 2010, William R. Cook, Siobhán Clarke,
andMartinC.Rinard(Eds.).ACM,Reno/Tahoe,Nevada,444–463. https://doi.
org/10.1145/1869459.1869497[14]Thilo Kielmann. 1991. PROM: A flexible, PROLOG-based make tool. Technical
ReportReportTI-4/91.InstituteofTheoreticalComputerScience,DarmstadtUni-
versity ofTechnology, Darmstadt,Germany. http://www.few.vu.nl/~kielmann/
papers/THD-SP-1991-04.pdf
[15]Gabriël Konat, Lennart C. L. Kats, Guido Wachsmuth, and Eelco Visser. 2012.
DeclarativeNameBindingandScopeRules.In SoftwareLanguageEngineering,
5thInternational Conference,SLE2012,Dresden, Germany, September26-28,2012,
Revised Selected Papers (Lecture Notes in Computer Science), Krzysztof Czarnecki
and Görel Hedin (Eds.), Vol. 7745. Springer, 311–331. https://doi.org/10.1007/
978-3-642-36089-3_18
[16]Gabriël Konat, Michael J. Steindorfer, Sebastian Erdweg, and Eelco Visser. 2018.
PIE:ADomain-SpecificLanguageforInteractiveSoftwareDevelopmentPipelines.
The Art, Science, and Engineering of Programming 2, 3 (2018). https://doi.org/10.
22152/programming-journal.org/2018/2/9
[17]EpperlyTKumfertG.2002. SoftwareintheDOE:TheHiddenOverheadof"The
Build". Technical Report. Lawrence Livermore National Laboratory.
[18]EvanMartin.[n.d.]. TheNinjabuildsystem. https://ninja-build.org/manual.html.
[Online; accessed 27-April-2018].
[19]Shane McIntosh, Bram Adams, and Ahmed E. Hassan. 2010. The evolution of
ANT build systems. In Proceedings of the 7th International Working Conference on
Mining Software Repositories, MSR 2010 (Co-located with ICSE), Cape Town, South
Africa, May 2-3, 2010, Proceedings, Jim Whitehead and Thomas Zimmermann
(Eds.). IEEE, 42–51. https://doi.org/10.1109/MSR.2010.5463341
[20] Peter Miller. [n. d.]. Recursive make considered harmful. ([n. d.]).
[21]Neil Mitchell. 2012. Shake before building: replacing make with haskell. In
ACM SIGPLAN International Conference on Functional Programming, ICFP’12,
Copenhagen,Denmark,September9-15,2012,PeterThiemannandRobbyBruce
Findler (Eds.). ACM, 55–66. https://doi.org/10.1145/2364527.2364538
[22]AndreyMokhov,NeilMitchell,SimonPeytonJones,andSimonMarlow.2016.
Non-recursivemakeconsideredharmful:buildsystemsatscale.In Proceedingsof
the 9th International Symposium on Haskell, Haskell 2016, Nara, Japan, September
22-23, 2016, Geoffrey Mainland (Ed.). ACM, 170–181. https://doi.org/10.1145/
2976002.2976011
[23]Pierre Néron, Andrew P. Tolmach, Eelco Visser, and Guido Wachsmuth. 2015.
A Theory of Name Resolution. In Programming Languages and Systems - 24th
EuropeanSymposiumonProgramming,ESOP2015,HeldasPartoftheEuropean
Joint Conferences on Theory and Practice of Software, ETAPS 2015, London, UK,
April 11-18, 2015. Proceedings (Lecture Notes in Computer Science) , Jan Vitek (Ed.),
Vol. 9032. Springer, 205–231. https://doi.org/10.1007/978-3-662-46669-8_9
[24]MikeShal.2009. BuildSystemRulesandAlgorithms. http://gittup.org/tup/build_
system_rules_and_algorithms.pdf . [Online; accessed 27-April-2018].
[25]Richard M. Stallman, Roland McGrath, and Paul D. Smith. 2016. GNU Make
manual. Free Software Foundation.
[26]Hendrik van Antwerpen, Pierre Néron, Andrew P. Tolmach, Eelco Visser, andGuido Wachsmuth. 2016. A constraint language for static semantic analysisbased on scope graphs. In Proceedings of the 2016 ACM SIGPLAN Workshop
onPartialEvaluationandProgramManipulation,PEPM2016,St.Petersburg,FL,
USA,January20-22,2016,MartinErwigandTiarkRompf(Eds.).ACM,49–60.
https://doi.org/10.1145/2847538.2847543
[27]EelcoVisser.1997. SyntaxDefinitionforLanguagePrototyping. Ph.D.Dissertation.
University of Amsterdam. Advisor(s) Paul Klint.
86
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. 