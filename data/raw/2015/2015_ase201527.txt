Static Analysis of JavaScript Web Applications
in the Wild via Practical DOM Modeling
Changhee Park
KAIST
changhee.park@kaist.ac.krSooncheol Won
KAIST
wonsch@kaist.ac.krJoonho Jin
KAIST
myfriend12@kaist.ac.krSukyoung Ryu
KAIST
sryu.cs@kaist.ac.kr
Abstract —We present SAFE WApp , an open-source static anal-
ysis framework for JavaScript web applications. It provides a
faithful (partial) model of web application execution environmentsof various browsers, based on empirical data from the main webpages of the 9,465 most popular websites. A main feature ofSAFE
WApp is the conﬁgurability of DOM tree abstraction levels
to allow users to adjust a trade-off between analysis performanceand precision depending on their applications. We evaluateSAFE
WApp on the 5 most popular JavaScript libraries and the
main web pages of the 10 most popular websites in terms of analy-sis performance, precision, and modeling coverage. Additionally,as an application of SAFE
WApp , we build a bug detector for
JavaScript web applications that uses static analysis results fromSAFE
WApp . Our bug detector found previously undiscovered
bugs including ones from wikipedia.org and amazon.com.
I. I NTRODUCTION
JavaScript was originally developed as a simple scripting
language to develop interactive and dynamic web pages, but
now it is used to construct large web applications with theevolution of web contents. Although JavaScript is the mostdominant programming language on the web [1], its quirkyfeatures make it difﬁcult to understand behaviors of complexJavaScript programs. Many researchers have developed var-ious program analysis techniques to alleviate this problem,but many of them have focused on analyzing stand-aloneJavaScript programs [28], [4], [13], which is not enough foranalyzing real-world web applications.
To analyze JavaScript web applications in the wild, model-
ing browser environments is critical since JavaScript programsoften reside in web pages and interact with users and browsersvia events. However, one of the main challenges is that nosingle standard document describes browser environments for-mally. While some commonly-used speciﬁcations are availableonline [6], [7], their descriptions are huge, informal, andincomplete and modeling all of them manually is tedious,time consuming, and error prone. Furthermore, non-standardand inconsistent behaviors of various browsers complicatemodeling. While previous approaches presented partial modelsof browser environments selected from several documents, theyare not applicable to real-world web applications because theysupport only subsets of JavaScript or limited models of webdocuments [4], [8], [9], [10], [11], [12].
In this paper, we present
SAFE WApp , an open-source frame-
work that statically analyzes JavaScript web applications andshow how to extend the existing static analyzer
SAFE [13]
to support an extensive model of browser environments. Bydoing so,
SAFE WApp extends the applicability of any clientapplications that are built on top of SAFE from stand-alone
JavaScript programs to web applications. To implement a prac-tical model of browser environments, we investigated 9,465popular websites and summarized uses of native JavaScriptobjects and APIs provided by most major web browsers.Based on extensive empirical data, we design a model ofbrowser environments. A main feature of
SAFE WApp is the
conﬁgurability of DOM tree abstraction levels in three ways,two from the literature [11], [12] and one new, which maintainsprecise tree structures of web documents. We show howDOM tree abstraction levels affect analysis performance andprecision with the analysis results of the 5 most popularJavaScript libraries and the main web pages of the 10 mostpopular websites. Furthermore, we implement a bug detectorcapable of detecting language-level bugs as a client applicationof
SAFE WApp and show that it detects previously undiscovered
bugs in the main web pages of popular websites. Note that ourapproach is not tied to its base analyzer,
SAFE , and thus it is
applicable to other static analyzers for JavaScript programs.
The contributions of this paper include the followings:
● We present empirical data from the 9,465 most pop-
ular websites to show the usage of native objects and
APIs that browsers support. This data will be helpful
to model browser environments practically.
● We explain how to extend a static analyzer thatsupports only stand-alone JavaScript programs to theone that supports web applications with a model ofbrowser environments practically. This approach isapplicable to other static JavaScript analyzers.
● We present
SAFE WApp ,a framework that statically
analyzes real-world JavaScript web applications. It
provides conﬁgurable DOM tree abstraction models
in three levels, two existing ones [11], [12] and anew one that captures DOM tree structures of webdocuments precisely. We present experimental resultsabout the effects of DOM tree abstraction levels onanalysis results of real-world web applications suchas JavaScript libraries and websites.
● To show the usefulness of
SAFE WApp , we implement
a bug detector as an application of SAFE WApp and
evaluate it on the main web pages of the 10 mostpopular websites. We found previously undiscovered
bugs in
wikipedia.org andamazon.com .
● We make SAFE WApp and the bug detector publicly
available [14].
2015 30th IEEE/ACM International Conference on Automated Software Engineering
978-1-5090-0025-8/15 $31.00 © 2015 IEEE
DOI 10.1109/ASE.2015.27552
function setLang(lang) {
var uiLang = navigator.language ||
navigator.userLanguage,
date = new Date();
if (uiLang.match(/ˆ\w+/) === lang) {
date.setTime(date.getTime() - 1);
} else {
date.setFullYear(date.getFullYear() + 1);
}
document.cookie = "searchLang=" + lang + ";expires=" +
date.toUTCString() + ";domain=" +location.host + ";";
}
Fig. 1: Main web page of wikipedia.org, along with some JavaScript code in the page (before ﬁxing the bug)
II. M OTIV A TING EXAMPLES
This section presents two examples motivating design
decisions of SAFE WApp . The ﬁrst example is the bug we found
fromwikipedia.org , which requires analysis of interactions
between JavaScript and DOM APIs. The second example
requires precise DOM modeling for precise analysis.
First, the JavaScript code of the setLang function in
Figure 1 is an excerpt from the main web page of Wikipediaalso shown in the Figure. A user can select a language in whichsearch results are displayed via the selection button next tothe search box; in Figure 1, the selected language is ‘English.’When the user changes the selected language to another onevia the button, it calls the
setLang function. The intended
semantics of setLang is as follows. If the selected language
is different from the default language of the browser in use,the function saves the information in a cookie on the user’scomputer and keeps it for a year; otherwise, it simply discardscookies, if any. When the user visits Wikipedia next time, if thecookie keeps the previously-selected language, the site uses itto set the default language in the selection button. Otherwise,it sets the default language to the browser’s default one.
However, we found that a bug in
setLang produces an
unintended behavior. When the if statement compares the
browser’s default language “ uiLang.match(/ˆ\ w+/) ” with
the selected language lang , the comparison always evaluates
to false! Note that the result of the match function is either
an object or null , while the value of lang is always a string.
Because the strict equals operator ( === ) always returns false
if the types of two operands are different, the conditionalexpression always evaluates to false, which always sets theexpiration date of the cookie to one year later. Consequently,whenever
setLang is called, the time in date sets to one
year later of the current time, and the cookie never expiresimmediately leaving the information on the user’s computer.
We reported the bug to the Wikipedia developers, and they
conﬁrmed the bug and ﬁxed it right away [?]. We can ﬁx thebug by using the equals operator
== instead of === , because
== implicitly converts two operands of different types. We
found that Wikipedia uses the strict mode recommended byECMAScript in their JavaScript code to enforce more checks,but the example shows that the checks are not enough to catchsuch a bug while a bug detector using
SAFE WApp can detect it.
Note that the modeling of both the event system and browserenvironments is necessary to catch the bug precisely. Withoutconsidering the event system, the
setLang call is unreachable
and without the precise type information of browser languages(
navigator.language ), we cannot detect the conditional
expression as a deﬁnite bug.
The second is the following pattern in web documents [15]:
var canvas = document.querySelector("#leftcol .logo")
While the document.querySelector call returns an ob-
ject ofHTMLCanvasElement by searching the DOM tree,
common approaches [11], [12] that model the DOM treeimprecisely fail to provide precise analysis results; they simplyreturn any HTML element, which includes other elementsas well resulting in imprecise analysis results. For moreprecise analysis results, more precise modeling of DOM isnecessary [3]. Hence,
SAFE WApp provides not only existing
DOM tree abstraction models in the literature but also a newprecise model of DOM trees; with the new model, it can returna single
HTMLCanvasElement object by searching an abstract
DOM tree as a result of the document.querySelector call
in an HTML document with the <canvas> tag element. In
Section IV, we show that such APIs for searching DOM treesare frequently used in real-world web applications, and inSection VII, we show how DOM tree abstraction levels affectstatic analysis results of JavaScript web applications.
III. J
AVA SCRIPT IN WEB APPLICA TIONS
We explain the execution model of JavaScript web appli-
cations and discuss challenges in analyzing them statically.
A. Execution of JavaScript Web Applications
A JavaScript web application runs in a web browser and
users can interact with it through user events such as mouse
and keyboard events. Figure 2 illustrates an execution of asimple JavaScript web application, which ﬁrst shows a pictureof eggs and then changes it to a picture of a chicken when auser clicks it. The source of the web application is an HTMLdocument consisting of a series of HTML tags. JavaScriptcode usually resides inside
<script> tags, either inlined as
in Figure 2 or imported from an external source as follows:
<script type="text/javascript"
src="sourcepath/sourcefile.js">
Such JavaScript code can access the enclosing HTML docu-ment and change its structure, contents, and display.
553Fig. 2: Execution of a sample JavaScript web application
To allow JavaScript code to manipulate HTML docu-
ments, web browsers provide the Document Object Model
(DOM), a tree representation of HTML documents. A node
in DOM usually represents an HTML tag and is treated asa JavaScript object with links to its parent, children, andsibling nodes. The tree diagram in Figure 2 shows a DOMtree for the HTML document in the Figure. Note that ac-tual DOM trees created by web browsers are often morecomplex than the one in the ﬁgure. The
changePicture
function inside the <script> tag of the HTML document in
Figure 2 shows an example where JavaScript code changesthe contents of its enclosing HTML document by manip-ulating DOM. It ﬁrst gets an
HTMLImageElement object
representing the <img> tag in the HTML document by calling
document.getElementById and it assigns the object to
imgobj . Then, it creates a new HTMLImageElement object by
callingdocument.createElement and designates the source
of the new image as the path to a new picture. Finally, itchanges the structure of DOM by replacing a child of thebody element
imgobj with the new object newimg .
Functions like getElementById andcreateElement are
not described by the ECMAScript speciﬁcation. They arelike APIs that browsers provide to enable JavaScript code to
access browser environments such as DOM trees. DOM objects
returned by such browser APIs correspond to HTML elements.They share some common properties such as links to their par-ents and children nodes, but some DOM objects have their ownproperties: for example, both objects for
HTMLImageElement
andHTMLDivElement have the parentNode property in
common, but only the objects for HTMLImageElement have
thesrc property. Browsers usually implement DOM objects
and browser APIs in native code for performance reasons.
Finally, most web applications run with a variety of events
from user interface events like keyboard and mouse events tobrowser behavioral events like load and change events. Theevent system enables developers to catch event triggers andto deﬁne actions to handle events by registering event handlerfunctions. For example,
changePicture is an event handler
function registered to the onclick attribute of the <img> tag
with the picture of eggs. When a user clicks the picture, theevent system calls
changePicture and changes the picture
to the picture of a chicken.B. Static Analysis Challenges
Precisely and correctly analyzing JavaScript web applica-
tions requires modeling of browser environments includingDOM, browser APIs, and the event system in a base analyzer.Without the modeling, for example, when
SAFE supporting
only stand-alone JavaScript analyzes a simple web applicationin Figure 2, it does not analyze the
changePicture call
because the function is unreachable without an event system;even if it can analyze the function call, it signals a run-timeexception at the ﬁrst line of the function body with undeclaredvariable access to
document becausedocument is an accessor
that browsers provide for the root element of the DOM tree;then it terminates the analysis because the rest of source partsare unreachable due to the run-time exception.
However, such modeling involves several challenges. First,
because no single standard speciﬁcation describes browserenvironments, it is not clear what to model among thousandsof properties related to DOM objects and browser APIs. Whilesome commonly-used speciﬁcations [6], [7] about browserenvironments are available, they are huge, informal, andincomplete. Moreover, modeling DOM objects only in thedocuments may be insufﬁcient because many browsers supportnon-standard features: for example, while the
Screen object is
not a part of any speciﬁcations, we found that more than 70%of the 10,000 most popular websites use it in their web pages.In addition, incompatibility between browsers makes it evenmore difﬁcult to select modeling targets: for example, whileInternet Explorer provides
attachEvent to register event
handlers, neither of Safari and Chrome provides it. Instead ofmodeling only subsets of certain documents, we model DOMobjects and browser APIs based on our extensive empiricalstudy. We present the empirical data in the next section.
Second, because execution of JavaScript code in HTML
documents may interleave with parsing of HTML documents,only a partial structure of a DOM tree may be visible in theJavaScript code of a certain
<script> tag and events may
occur while parsing HTML documents. To precisely analyzesuch an execution, we may need to incorporate HTML parsingwith static analysis, which requires a meta-circular analyzer.Instead, we simplify the execution model; we assume that allscripts are executed after completion of HTML parsing and allthe events happen after execution of the top-level code.
IV . P
RACTICAL DOM M ODELING
This section presents empirical data to identify frequently
used DOM objects and browser APIs. The purpose of thisempirical study is to lessen the burden of modeling efforts bysuggesting modeling priorities on DOM properties and DOMtree abstraction levels. While modeling mechanism itself is nota main focus of our work, automatic modeling mechanism as in
SAFE WAPI [2] can generate modeling from API speciﬁcations.
A. Method
We investigated what DOM-related ﬁelds and browser APIs
are commonly used in real-world JavaScript applications. Forthis, we instrumented WebKit
1, an open-source web browser
engine used in Safari and Chrome, to identify DOM-related
1http://www.webkit.org
554T ABLE I: Usage of ﬁelds/APIs deﬁned in DOM speciﬁcations
Fields APIs
Spec. Def. No use Def. No use
3 Core 120 67 (55.8%) 88 51 (58%)
2 HTML 288 126 (43.8%) 36 23 (63.9%)
2 Events 57 25 (43.9%) 14 4 (28.6%)
Total 465 218 (46.9%) 138 78 (56.5%)
T ABLE II: Usage of ﬁelds/APIs in main pages of 9,465 sites
Type>1,000 sites ≥100 sites≥10 sites≥1 site
Field 148 325 949 1,719
API 52 100 162 269
Total 200 425 1,111 1,988
property accesses. Speciﬁcally, WebKit has two modules,
JavaScriptCore and WebCore, which deal with JavaScriptcode execution and web page rendering, respectively. SinceJavaScriptCore communicates with WebCore when in need toaccess DOM properties, we can identify all the accesses byobserving the communications between two modules.
Using the instrumented WebKit, we made MiniBrowser, a
simple browser provided by WebKit, navigate to 9,465 sitesexcluding inaccessible 535 sites from the 10,000 most popularwebsites according to Alexa
2and stay for 1 minute per site
just loading the main web pages. Whenever MiniBrowservisits a new website, the instrumented WebKit dumps variousinformation such as the names of all DOM ﬁelds and APIsaccessed in the main web page for 1 minute. We also built atool to compute statistical data like the total number of accessesfor each ﬁeld or API and the number of websites where eachﬁeld or API is used.
B. Results
Usage of the Fields and APIs Deﬁned in Speciﬁcations.
First, we demonstrate that it is not necessary to model all the
ﬁelds and APIs deﬁned in various DOM speciﬁcations. Table Isummarizes the usage of the ﬁelds and APIs deﬁned in 3 kindsof DOM speciﬁcations in the W3C community: DOM Level3 Core, DOM Level 2 HTML, and DOM Level 2 Events,from top to bottom. For each speciﬁcation, the columns of thetable show, from left to right, the number of deﬁned ﬁelds,the number of the ﬁelds never used in any site, the number ofdeﬁned APIs, and the number of the APIs never used in anysite. As the last row shows, about half of the deﬁned ﬁelds andAPIs were never used during execution of JavaScript code inthe main web pages of 9,465 popular websites. Interestingly,even for the DOM Level 3 Core speciﬁcation, which deﬁnesa core subset of web APIs, more than a half of the ﬁelds andAPIs were never used. This result shows that most JavaScriptweb applications use only some subset of the DOM properties.
Modeling Priorities. While modeling all the properties
deﬁned in all DOM speciﬁcations would be most useful, itwould be practically helpful to set priorities between the DOMproperties so that one can incrementally model them in theorder of importance. Table II summarizes the numbers of theﬁelds and APIs used in the main web pages of the targetwebsites. The second column shows that 148 ﬁelds and 52APIs were found in more than 1,000 sites, and the ﬁfth column
2http://www.alexa.com/topsitesT ABLE III: 10 most frequently used DOM properties deﬁned in the
W3C DOM Level 3 Core speciﬁcation
Rank Interface Field Sites
1Document documentElement 8,116
2NodeList length 8,104
3 Node parentNode * 8,008
4 Node nodeType 7,718
5 Node firstChild * 7,669
6 Node ownerDocument 7,497
7 Node childNodes * 7,354
8 Node nodeName 7,297
9 Node lastChild* 6,835
10 Node nextSibling * 5,319
Rank Interface API Sites
1Document getElementById * 7,441
2Document createElement 7,425
3 Node appendChild * 7,393
4Document getElementsByTagName * 7,327
5 Node insertBefore * 7,182
6Element getElementsByTagName * 7,134
7Element getAttribute 7,060
8 Node removeChild * 7,018
9Element setAttribute 6,868
10Document createComment 6,427
shows that 1,719 ﬁelds and 269 APIs were found in more thanor equal to 1 site, which means that the total number of DOMproperties used in 9,465 websites are 1,988.
While modeling all 1,988 properties found in 9,465 web-
sites would be time-consuming and tedious, if we give a higherpriority to those found in more than 1,000 sites, the modelingbecomes manageable with 200 properties. After modeling themﬁrst, one can model other properties selectively depending onthe target applications. For instance, we modeled about 800properties using hand-written code; the model includes 196among 200 properties found in more than 1,000 sites; we didnot model 4 properties such as
HTMLDocument.write , which
require HTML parsing and possibly dynamic JavaScript sourceloading. We make the full list of the properties used in websitespublicly available [14].
DOM Tree Modeling. The abstraction level of concrete
DOM trees affects analysis precision and performance. Forsimple treatment of abstract objects, existing approaches ab-stract a DOM tree as either one single node object [11] ormultiple objects to keep separate abstract objects only fordifferent kinds of DOM elements [12]; both approaches giveup maintaining the original tree structure at the initial state.While the approaches can always keep small ﬁxed numbersof abstract objects for a DOM tree regardless of its originalstructure, they cannot provide precise analysis results forweb applications manipulating the tree structure [3]. On theother hand, if a model maintains the DOM tree structure byabstracting each node as a single abstract object, the analyzercan provide more precise analysis results with the cost of moresophisticated modeling work and a large number of abstractobjects depending on source HTML documents.
Observation on which ﬁelds and APIs are frequently used
in real-world web applications can help to decide the abstrac-tion level of concrete DOM trees. Table III shows the 10 mostfrequently used ﬁelds and APIs deﬁned in DOM Level 3 Corewith the numbers of the websites where they were found.The properties marked with
*indicate that they either search
or manipulate DOM trees. As the table shows, more than ahalf of the websites are using them, which implies that the
555Fig. 3: Overall structure of the SAFE WApp framework
DOM-related properties are being used signiﬁcantly in many
web applications. Therefore, a crude abstraction that does notmaintain DOM tree structures would lead to imprecise analysisresults in web applications. Based on empirical data, our modelprovides a precise DOM tree abstraction model but we make itconﬁgurable to other two aforementioned existing abstractionmodels allowing users to choose an appropriate one dependingon their applications. We provide more detailed explanation ofthe three DOM tree abstraction models in Section V -D.
V.
SAFE WA PPFRAMEWORK
Now, we present SAFE WApp built on top of an open-source
SAFE framework [16] as illustrated in Figure 3. Solid and
dashed boxes represent modules and data, respectively, andarrows show ﬂows of data between modules. The modules inthe shaded boxes indicate the ones in
SAFE and the others
outside the shaded boxes are new additions.
A. SAFE and Static Analyzer
We give a brief introduction to SAFE and its analyzer in
this section and refer the interested readers to its manual [17].
SAFE is an open-source analysis framework for stand-alone
JavaScript programs. It transforms a JavaScript source program
to an Abstract Syntax Tree (AST), an Intermediate Represen-tation (IR) with simpler language constructs than AST, anda Control Flow Graph (CFG) to enable various analyses ondifferent levels of representations. Its default static analyzer onCFGs supports ﬂow-sensitive and context-sensitive analyses ofJavaScript programs by faithfully modeling the semantics ofECMAScript 5 [18]. A
SAFE analysis computes the following
summary map for a program:
ˆs∈̂S=Node×Context→̂Heap
which maps a program point represented by a pair of a CFGnode and a context to an over-approximate abstract heapinformation. A variable or an object property in an abstract
heap,ˆh∈̂Heap, maps to an abstract value ˆvrepresented by a
6-tuple of lattice elements as follows:
ˆv∈̂V=̂Undef×̂Null×̂Bool×̂Number×̂String×℘(̂Loc)
where℘(̂Loc) is a ﬁnite set of abstract locations that map
to abstract objects in abstract heaps and the others are simple
abstract domains for primitive types,
Undefined ,Null ,Bool ,
Number , andString . Their deﬁnitions are available in the
SAFE manual [17]. For example, an abstract value ˆvthat may
betrue ornull is represented as follows:
ˆv=⟨/bot Undef,ˆnull,ˆtrue,/botNumber,/botString,∅⟩.With the domains, the default static analyzer performs
sound and elaborate analyses on CFGs of JavaScript programs
with the transfer function ˆF∈̂S→̂Sto compute a ﬁnal sum-
mary map ˆsﬁnalfrom the following least ﬁxpoint computation:
ˆsﬁnal=leastFix λˆs.(ˆsI⊔ˆSˆF(ˆs))
where the initial summary map ˆsImaps an initial program
point to the initial heap ˆhinitand all the other program points
to/botHeap . The analysis starts with ˆsIand updates the map
until it reaches a ﬁxpoint. The initial heap ˆhinitcontains
abstract value information of JavaScript built-in objects and
functions. In addition, the analysis supports various analysistechniques such as object recency abstraction [19] (distin-guishing recently allocated objects from summary objects at aprogram point), k-CFA [20] (distinguishing function calls with
klength of call strings that represent call history), and loop-
sensitivity [21] (distinguishing loop iterations during analysisusing loop contexts that contain loop information) to improveanalysis precision. The
SAFE analysis supports such multiple
analysis sensitivities by conﬁguring Context accordingly. Note
that SAFE WApp extendsˆhinitof the SAFE analyzer with more
information about DOM trees and browser APIs so that it cananalyze web applications. Without such information, when aninput program calls browser APIs, for example, the
SAFE an-
alyzer wrongly identiﬁes them as undeﬁned function accessesor non-function calls making further analysis unsound.
B. HTML Parser and Event System
The ﬁrst step to extend
SAFE for stand-alone JavaScript
programs to web applications is to provide a way to parse
HTML documents. Because the WebKit HTML parser isnot well structured or documented enough to provide neces-sary information about the HTML documents being parsed,
SAFE WApp uses a combination of two third-party HTML
parsers with different capabilities. SAFE WApp uses Jericho [22]
to extract JavaScript code and its source location from anHTML source and passes them to the original JavaScript parserin
SAFE . Then, it uses CyberNeko [23] to construct a DOM
tree from the HTML source and passes it to the DOMModeler
andDOMBuilder modules, which create abstract models of
browser environments and DOM trees respectively and passthem to the analyzer as shown in Figure 3.
Then, we model the event system of browser environments
to support interactions between web applications and users viaevents. While previous work [12] uses an event model whereload event dispatches preceded dispatches of other events,we found that this model may produce unsound analysisresults because dispatches of other events indeed can precedeload events. Hence, we choose a more conservative eventmodeling for soundness: after analyzing a given program, itanalyzes all event handlers registered by the program andsafely combines their analysis results. Note that users mayregister event handlers not only statically using HTML at-tributes such as
onload andonclick but also dynamically
using the addEventListener API. SAFE WApp maintains a
special abstract object, which serves as a table to keep allregistered event handlers including the ones registered dy-namically during analysis. The
EventCFGBuilder module
in Figure 3 adds an event execution loop at the end of theCFG of the program. The event loop represents program ﬂows
556of all possible execution sequences of event handlers. Since
combining analysis results may harm the analysis precision ofthe whole program,
SAFE WApp provides a conﬁgurable option
to enable or disable the event system.
C. DOM Prototype Objects and Browser APIs
To provide browser environments to the Analyzer module,
theDOMModeler module adds DOM prototype objects and
other built-in browser objects that have abstract browser APIs
to the initial heap of the analyzer. Note that, unlike class-basedlanguages like Java, JavaScript does not support classes andinheritance by subclassing but supports prototype-based objectinheritance. When looking up a property in an object, if theobject does not have the property, it looks up the property inthe objects in its prototype chain.
The
DOMModeler module creates abstract DOM prototype
objects that DOM node objects inherit and built-in browser ob-jects with browser APIs, constructs prototype relations amongthem, and puts them in the initial heap of the analyzer. Wefaithfully modeled, according to the DOM speciﬁcations fromthe W3C and WHA TWG communities, about 130 abstractobjects and 800 properties that include 196 among 200 prop-erties that we found in more than 1,000 sites in the empiricalstudy of Section IV -B. While the speciﬁcations also deﬁnesome interfaces that instance node objects in a DOM treeshould implement, they, however, do not clearly describe ahierarchy between DOM interfaces and objects implementingthem. For example, a
<div> tag in an HTML document creates
anHTMLDivElement instance object, which should implement
theHTMLElement interface; an object that implements the
HTMLElement interface should implement the Element in-
terface; likewise, an object that implements Element should
implement the Node interface. However, the speciﬁcations do
not describe how to implement such relations.
To provide the relationships between DOM objects in a pre-
cise and practical way, SAFE WApp models prototype relations
between DOM interfaces following the implementation modelof browsers rather than the speciﬁcations. In real implementa-tion, while APIs deﬁned in an interface are properties of theprototype object of the interface, ﬁelds deﬁned in an interfacemay not be properties of the corresponding prototype object.
For instance, the
appendChild API deﬁned in the Node
interface is a property of the Node.prototype object, but the
firstChild ﬁeld deﬁned in the same Node interface becomes
a property of all the instance node objects in a DOM tree.
D. DOM Tree Construction
TheDOMBuilder module constructs an abstract DOM
tree and adds it in the initial heap of the analyzer. SAFE WApp
provides conﬁgurable DOM tree abstraction levels in three
ways, two from the literature and one new:
● Model A keeps one single abstract node that approx-
imates all kinds of DOM nodes regardless of HTMLsource structures like the model that G
A TEKEEPER [11]
uses; all links to parent, children, and sibling nodesalways point to the one single abstract node.
● Model B keeps one single abstract node for nodes
in the same kind (for example, nodes with the sametag) but different abstract nodes for those in differentkinds, regardless of HTML source structures like themodel that T AJS [12] uses; all links to parent, children,and sibling nodes always point to all possible abstractnodes.
● Model C keeps a single abstract node for each DOM
node by cloning the concrete DOM tree from HTMLparsers; links to parent, children, and sibling nodespoint to precise single abstract nodes initially, but theymay be over-approximated during analysis.
While Model C provides the most precise DOM tree model, Bthe second, and A the least, Model A and B always keep thesame numbers of abstract objects for a DOM tree regardless ofan HTML source structure, which are usually smaller than thenumber of abstract objects in Model C; the number of abstractobjects for a DOM tree varies depending on HTML sourcestructures in Model C. Thus, three models can have trade-offs between analysis precision and performance. Smallernumbers of abstract objects make an analysis domain smaller,which helps the analysis to reach a ﬁxpoint earlier. Moreover,Model A and B make the implementation of abstract APIsfor DOM tree search and manipulation simpler than Model C.While Model C implements actual search and manipulationon abstract DOM trees for the APIs, Model A and B simplyreturn all possible abstract nodes for search and do nothing formanipulation, which improves analysis performance. We showthe effect of each model on analysis precision and performanceusing analysis results of real-world applications in Section VII.
VI. A
PPLICA TION OF SAFE WA PP
Now that SAFE WApp provides an extensive model of
browser environments, it extends the applicability of clientapplications built on top of
SAFE from stand-alone JavaScript
programs to web applications. V arious client applications canutilize analysis results of
SAFE WApp for program understand-
ing, debugging, and optimizations. In this paper, we presenta bug detector that detects JavaScript language-level bugs asan application of
SAFE WApp . The bug detector can detect the
following 7 bugs: 4 errors and 3 warnings:
● AbsentVar signals undeﬁned variable accesses, which
cause the ReferenceError exception in JavaScript.
● CallNonFun signals function calls with non-function
values, which cause the TypeError exception.
● NullOrUndef signals property accesses of null or
undefined , which cause the TypeError exception.
● BinaryT ype signals non-object values used in the right-
hand sides of the in orinstanceof operator, which
cause the TypeError exception.
● CondBranch signals conditional expressions with con-
stant values or applications of the === operator that
evaluate to always true or always false in if state-
ments; subtleties in correctly using == and=== oper-
ators can cause unintended behaviors as we showed inSection II.
●
ConvertUndefT oNum and PrimitiveT oObj signal suspi-
cious implicit type conversions from undefined to
557Fig. 4: Bug detector using analysis results form SAFE WApp
a number and from a primitive value to an object,
respectively.
Figure 4 illustrates the overall structure of the bug de-
tector; the shaded box indicates the bug detector with itsmain modules. It takes the CFG of a target program and itsanalysis results from
SAFE WApp as inputs and produces a bug
report as an output. As with CFGs in traditional compilersand analyzers, a CFG node in
SAFE WApp corresponds to a
basic block containing a list of instructions, and an instructioncontains expressions that have no side effects on heaps (andabstract heaps) during evaluation (and analysis). Recall thatthe
SAFE WApp analyzer computes a summary map ˆsfrom each
program point (a node and a context) to an abstract heap at theprogram point as an analysis result. In order to perform bugdetection efﬁciently, the bug detector ﬁrst trims unnecessaryinformation from the summary map ˆs. The
BugDetector mod-
ule reﬁnes ˆsto another one ˆsbthat maps a pair of an instruction
ior an expression eand a context cto an input abstract
heapˆhat the instruction ior expression ewhile traversing
the CFG by the T raverseCFG module. Then, using ˆsb, the C
module inspects all CFG nodes and calls the Imodule when
it inspects instructions in the nodes. Likewise, the Imodule
inspects instructions and calls the Vmodule when it inspects
expressions in the instructions. While inspecting instructionsand expressions, the
Imodule and the Vmodule call the
InstDetect module and the ExprDetect module, respectively, to
perform actual bug detection and pass detected bug informationto the
BugStorage module. Finally, the BugStorage module
collects all the bugs detected and reports them in a user-readable format with source locations.
Because false positives are one of the main reasons why
developers do not use static analysis tools [24], our bugdetector reports only deﬁnite bugs by default and provides anadditional developer mode to report all detected bugs that mayinclude more false positives. Thus, with a default mode, thebug detector uses the following 3 restrictions on bug detectionto reduce false alarms:
1) it does not consider CFG nodes in branches with
uncertain conditions;
2) it reports only such bugs that are detected in all
contexts; for example, if it detects a bug at the sameprogram point in one call-context but not in anothercall-context, it does not report the bug;
3) it reports bugs only with deﬁnite value information;
for example, if an abstract value ˆvmay be
null oran object, then the bug detector does not report the
NullOrUndef bug with the property access of ˆv.
Note that since SAFE WApp soundly over-approximates program
behaviors, bug detection with a developer mode will reportmore bugs possibly with more false positives.
Due to the space limitations, we present only the detection
rules for
NullOrUndef and BinaryT ype with a default mode
in this paper, and we refer interested readers for details tothe
SAFE WApp repository [16]. When evaluating a property
accesse.p, JavaScript ﬁrst evaluates the expression eto a
value and implicitly converts the value to an object. SAFE WApp
models such an implicit type conversion from a value to an
object with the instruction x∶=̂toObject( e), and the InstDetect
module of the bug detector inspects the instruction to detect
any NullOrUndef errors as follows:
InstDetect /llbracketx∶=̂toObject( e)/rrbracket(ˆsb)= signalBug(NullOrUndef)
if∀c∈Context∶∃ˆh∈̂Heap andˆv∈̂Vsuch that
ˆsb(x∶=̂toObject( e),c)=ˆh∧ˆFe(e)(ˆh,c)=ˆv∧
(ˆv.1=⊺ Undef∨ˆv.2=⊺ Null)∧ˆv.3=/bot Bool∧
ˆv.4=/bot Number∧ˆv.5=/bot String∧ˆv.6=∅
whereˆFe(e)(ˆh,c) evaluates the expression ewith the abstract
heapˆhand the context cto an abstract value, and ˆv.naccesses
then-th element in the tuple of the abstract values ˆv. The
rule signals the NullOrUndef bug only when the expression e
evaluates to either undefined ornull , not to other values,
in all contexts to minimize false positives.
To detect non-object values used in the right-hand sides of
thein orinstanceof operator, the ExprDetect module of the
bug detector inspects binary operation applications as follows:
ExprDetect /llbrackete1⊗e2/rrbracket(ˆsb)= signalBug(BinaryT ype)
if⊗∈{in,instanceof}∧
∀c∈Context∶∃ˆh∈̂Heap andˆv∈̂Vsuch that
ˆsb(e1⊗e2,c)=ˆh∧ˆFe(e2)(ˆh,c)=ˆv∧ˆv.6=∅.
The rule signals the BinaryT ype bug only when the right-hand
side expression e2evaluates to a non-object value ( ˆv.6=∅ )i n
all contexts to minimize reporting of false positives. In the nextsection, we present bug detection results of our bug detectoron 10 real-world applications.
VII. E
XPERIMENT AL EV ALUA TION
We evaluate SAFE WApp with the analysis results of popu-
lar JavaScript libraries and websites. Our implementation of
SAFE WApp and target programs are publicly available [14].
Table IV summarizes the evaluation results. The ﬁrst andsecond columns of the table show the 15 target programs of theevaluation and line numbers of their pretty-printed JavaScriptsources, respectively. The ﬁrst 5 targets are simple programsthat just load the 5 most popular JavaScript libraries accordingto W3Techs, and the remaining 10 targets are the main webpages of the 10 most popular websites according to Alexa thatwe collected using source saving functions of browsers. Weused JavaScript libraries because they have been the majortargets for JavaScript analysis [5], [25], [26], and we selectedweb sites because JavaScript code in web pages may be theclosest one to JavaScript web applications in the wild.
558T ABLE IV: Analysis results of the 5 most popular JavaScript libraries and main web pages of the 10 most popular websites with 3 different
DOM tree abstraction models. Model A and B are previously used by G A TEKEEPER [11] and T AJS [28], respectively, and Model C is proposed
in this paper. The analysis time is in seconds with the timeout of 3 hours denoted by . The analysis precision is measured with MD (multiple
dereferences), MC (multiple calls), and PR (non-constant property accesses).
Target LOCModel A Model B Model C
Time MD MC PR Time MD MC PR Time MD MC PR
jQuery 2.1.1 7,530  416/3,059 7/392 60/177  440/3,055 7/392 60/177 13.37 11/2,490 3/323 18/112
Modernizr 2.8.3 770 5.29 39/822 3/143 1/24 6.02 55/821 3/143 1/24 5.19 4/733 3/129 0/23
BootStrap 3.3.0 10,027  649/5,101 16/662 73/325  647/5,081 16/662 69/306  561/4,985 19/622 90/294
Mootools 1.5.1 6,756  64/305 5/38 6/11  92/533 13/65 8/28 359.05 33/3,268 6/389 9/147
Prototype 1.7.2 7,517 42.59 60/2,609 11/342 11/64 40.82 55/2,556 8/333 8/61 36.27 20/2,469 5/326 7/57
google.com 3,698  289/1,440 2/167 4/48  290/1,440 2/167 4/48 2,662.22 274/5,916 10/748 35/147
facebook.com 7,510  71/969 2/131 4/41  71/969 2/131 4/41  32/6,402 3/681 2/199
youtube.com 8,306  253/4,764 3/621 38/176  321/5,014 3/637 38/176  153/5,591 4/764 30/195
baidu.com 6,117  396/4,666 23/626 109/364  488/4,680 23/629 109/364  292/4,198 39/554 88/330
yahoo.com 16,852  230/3,508 4/417 33/537  241/3,532 4/320 33/537 7,298.93 153/8,876 5/700 17/638
wikipedia.org 382 6.90 19/495 6/98 3/24 8.62 44/495 5/98 3/24 127.01 36/458 5/91 2/22
amazon.com 7,076  833/4,747 16/669 32/114  862/4,744 16/669 32/114  144/4,403 14/638 23/108
twitter.com 15,982  291/6,143 11/664 47/214  408/6,314 16/697 77/243  418/8,402 50/987 84/411
taobao.com 6,300  766/6,352 33/869 80/216  811/6,367 33/870 80/216  105/5,388 8/781 40/185
qq.com 17,706  267/6,643 8/760 61/334  315/6,637 8/760 61/334  39/6,591 7/769 35/255
Average – – 309/3,441 10/439 37/177 – 342/3,482 10/438 39/181 – 151/4,678 12/566 32/208
Statically analyzing JavaScript code in web pages is full of
challenges. One big challenge, also common in all static anal-
yses, is dealing with dynamic code generation. JavaScript codein some websites is statically invisible since it is dynamicallygenerated by calling functions such as
eval andFunction
or loaded lazily by the <script> tag with JavaScript source
code using document.write ordocument.createElement
at run time. Because such code fragments are not availableat compile time but appear at run time, they may invalidatestatic analysis results. Among the 10 most popular websites,We detected 4
eval calls inyoutube.com ,baidu.com , and
qq.com during analysis. Since all calls are with constant string
arguments, we could easily replace the eval function calls
with other language constructs [27].
With the 15 target programs, we ﬁrst evaluate how DOM
tree abstraction levels affect analysis results with respect toperformance and precision. We compare the analysis resultsof three different DOM tree models that
SAFE WApp provides,
Model A, B, and C described in Section V -D. Note that sinceModel A and B are DOM tree abstraction models previouslyused by G
A TEKEEPER [11] and T AJS [28], respectively, the
evaluation results also allow us to compare existing modelsin the literature (Model A and B) and a new one (ModelC). Next, we discuss the modeling coverage of all detectedbrowser APIs during analysis, and we present bug detectionresults on the main web pages of the 10 most popular websitesusing our bug detector. For fair comparison, we used thesame conﬁgurations with 10 call-context sensitivity and loop-sensitivity, but different ones only for DOM tree models.We conducted all experiments on a Linux x64 machine with3.4GHz Intel Core i7 CPU and 32GB memory.
A. DOM Tree Abstraction
Table IV shows analysis results of the 15 target programs
by the analysis of
SAFE WApp with the timeout of 3 hours when
we use three different DOM tree abstraction models. The ﬁrst
columns in the sections of Table IV for Model A, B, andC show the time in seconds that
SAFE WApp took to analyze
target programs. When an analysis does not complete withinthe timeout, we denote its time as . The rest columns show
three metrics that we used to measure the analysis precision:
● MD: the number of object dereferences with multipleobject values (multiple dereferences) / the total numberof analyzed object dereferences
● MC: the number of calls with multiple function values(multiple calls) / the total number of analyzed calls
● PR: the number of object property accesses with aproperty name approximated as non-constant (non-constant property accesses) / the total number ofanalyzed object property accesses except for thosewith constant property names such as
o["name"]
The experimental results show that while Model A and Bdo not show signiﬁcant differences in analysis performanceand precision, Model C outperforms Model A and B in bothperformance and precision in most cases.
For the analysis performance, while using Model A and B
can ﬁnish analysis of only 3 targets–Modernizr, Prototype, and
wikipedia.org , using Model C can ﬁnish analysis of 4 more
targets–jQuery, Mootools, google.com , andyahoo.com .F o r
example, while analysis with Model A and B cannot analyzejQuery, the most popular JavaScript library with the marketshare of more than 90%, within the timeout of 3 hours, analysiswith Model C ﬁnishes analyzing jQuery in 13.37 seconds. Notethat
wikipedia.org is an outlier in analysis results. Even
though analysis with Model A and B can ﬁnish analyzing
wikipedia.org in less than 9 seconds, it took more than
2 minutes with Model C. Because Model C provides preciseDOM modeling, analysis using Model C involves overhead inmaintaining precise DOM models, which may be an overkillfor analyzing simple programs like
wikipedia.org .
As for the analysis precision, all three metrics MD, MC,
and PR on average (the last row of Table IV) show thatModel C has the least ratios of multiple dereference, multiplecall, and non-constant property accesses over correspondingtotal program points, although it has the most numbers oftotal program points in the ratios; for example, Model C has
559the least ratio 2.12% (12/566) on average in MC compared
to 2.29% (10/436) and 2.28% (10/438) in Model A and B,but it has the most number of total program points as 566compared to 436 and 438 in Model A and B, respectively.Note that the least ratios mean the most precise analysis resultsand the most numbers of total program points mean the bestanalysis coverage of target program points. We found thatModel C analyzes more program points than Model B andC with the same timeout in most cases, which implies thatModel C shows better analysis scalability in such cases; incase of
google.com , for example, we found that analyses
with Model A and B cover 10.79% and 10.83% of CFG nodes,respectively, while that with Model C covers 39.01% withinthe same timeout of 3 hours.
The results in Table IV indicate that the precise DOM
modeling in Model C can improve the analysis performancein some JavaScript web applications. Unlike analysis of C-likelanguages where precise analyses often sacriﬁce the analysisperformance, researchers [21], [5], [29] recently reported thathigh precision in static analysis of JavaScript applications canincrease the analysis scalability signiﬁcantly. For instance, lowprecision in analysis of higher-order function calls mixed withdynamic property accesses as in “
o[x](...) ” may lead to
many spurious function calls increasing analysis computationimmensely. Likewise, imprecise property values in DOM treesof Model A and B may harm the analysis scalability.
Finally, we investigated why
SAFE WApp with conﬁgurable
DOM tree models fails to complete the analysis of 8 targetprograms within the timeout. One reason was prevalent uses ofstatically indeterminate values such as
Math.random() and
browser environmental information. We observed that soundabstraction of such values as all possible ones would leadto state explosion during analysis. Another reason was thesound event system of
SAFE WApp , which considers all possible
execution sequences of event handlers where the worst ﬁxpointcomputation time of the analysis exponentially increases asthe number of registered event handlers increases. We foundthat
facebook.com registers 29 mouse event handlers only
with html attributes statically. We expect that user inputsfor statically indeterminate values and more elaborate eventsystems would alleviate the scalability problem.
B. Modeling Coverage
To evaluate the effects of the proposed modeling mecha-
nism, we measured the coverage of models encountered during
analysis. We ﬁrst identiﬁed “deﬁnite browser API calls” eachof which has a single function value during analysis of 15target programs using Model C within the timeout of 3 hours.Then, we checked whether API function calls encounteredduring analysis are covered in a hypothetical model whichincludes only the modeling of 52 APIs found in more than1,000 websites from the empirical study of Section IV. Wefound that the model covers all APIs detected in 4 targets;the worst case was
youtube.com where the model covered
18 APIs out of 24 encountered APIs (75.5%) and on averagethe model covers 90.33% of all APIs encountered in each tar-get program. The experimental results indicate that modelingbrowser APIs based on empirical data is a promising approach.C. Bug Detection
We present bug detection results in the main web pages of
the 10 most popular websites using the bug detector we havebuilt as an application of
SAFE WApp (Section VI). The bug
detector uses analysis results from SAFE WApp with the most
precise DOM tree abstraction (Model C) with the timeout of 3hours. It did not report any errors or warnings in
google.com
andbaidu.com but it reported 3 errors and 23 warnings in
the remaining 8 websites: 3 NullOrUndef ,1 9 CondBranch ,2
ConvertUndefT oNum , and 2 PrimitiveT oObj .
In addition to the bug in wkipedia.org we described in
Section II, we found another interesting bug in amazon.com
detected as a ConvertUndefT oNum warning as follows:
var isTouchDevice =
... || navigator.MaxTouchPoints>0| |. . .
where the code checks if a current device is a touchdevice by checking if the maximum number of touchpoints in a current device is greater than 0. How-ever, since browsers provide the maximum number oftouch points with
navigator.maxTouchPoints rather than
navigator.MaxTouchPoints , the code contains a typing error
with the capital M. Consequently, this bug causes the condi-
tion expression to always evaluate to false via the followingevaluation steps: ﬁrst,
navigator.MaxTouchPoints evaluates
toundefined , then the undefined value implicitly converts
to a number, NaN in this case, for the comparison with 0, and
N a N>0 always evaluates to false. The bug detector ﬁnds such
suspicious implicit conversion from undefined to a number
and signals the ConvertUndefT oNum bug. After we reported
the bug, Amazon is investigating it.
The bug detector ﬁnds suspicious conditional expressions
that always evaluate to the same value in conditional branches,and it signals
CondBranch warnings for such cases. For
example, if(true) {...} fromfacebook.com is such a
case. In this case, we can safely rewrite the if statement
to its true-branch statement preserving the semantics of theprogram. Note that detecting and rewriting ever-true or ever-false conditional branches may enable web page optimizationby reducing code size.
PrimitiveT oObj warnings signal suspicious implicit type
conversions from primitive values to objects. For example,
(+(new Date)).toString().slice(-4) fromtwitter.com
illustrates such a case. After creating an instance Date object,
the code implicitly converts the object to a positive numberby applying the
+operator, which subsequently converts to
aNumber object for the toString method call. While the
implicit conversion from a primitive number to an object inthis code may be intentional, since such conversions often leadto unexpected behaviors, the bug detector reports them as the
PrimitiveT oObj warning.
Finally, we manually inspected all reported bug messages
to check if they are true alarms. Using the developer modein various browsers, we compared the bug detection resultsand real execution results to identify false alarms, whichhave inconsistent messages with the real execution results.We found that 6 bug reports out of 26 messages were falsealarms. The false alarms mainly come from lazily loaded script
560code and incomplete analysis results due to timeout. Con-
siderY.ModulePlatform.init(...) fromyahoo.com where
Y.ModulePlatform is deﬁned in a script loaded lazily from
a different server. Since SAFE WApp does not have analysis
results of such lazily loaded code, the analyzer considers itsvalue as
undefined , which makes the bug detector iden-
tifyY.ModulePlatform.init as an illegal property ac-
cess ofundefined reporting NullOrUndef . We can eliminate
such false alarms if users provide lazily loaded scripts to
SAFE WApp before analyzing the code. Another false alarm
isthis.options.bufferSize<0 fromtwitter.com . Because
the SAFE WApp considers this.options.bufferSize as
undefined , the bug detector regards the code as a suspicious
implicit type conversion from undefined to a number, and it
signals the ConvertUndefT oNum warning. However, we found
that the property is actually deﬁned in an event handler, whichwas not analyzed due to the timeout of 3 hours; the bugdetector reported the false alarm since the
SAFE WApp analyzer
missed the event function during analysis,. We can eliminatesuch false alarms with longer timeout for analysis.
D. Threats to V alidity
Soundness and precision. Although we faithfully modeled
browser environments with frequently used APIs, web appli-
cations may use APIs not included in our modeling. In suchcases, because
SAFE WApp simply reports warning messages
for the API uses, the analysis results of web applicationsusing the APIs become unsound or imprecise. Systematicand reusable modeling techniques may reduce the modelingeffort and enhance the soundness and precision of analysisresults. Also, incomplete analysis results with timeouts mayproduce unsound results. More sophisticated modeling of theevent system considering possible orders among events couldimprove the scalability and precision of the analysis as wellas the soundness by completing the analysis within timeouts.
Bug detection. While
SAFE WApp could detect some pre-
viously undiscovered bugs with warning messages that maylead to unintended behaviors, it did not ﬁnd any true errors.However, because the target websites have been deployedand used by many people for long periods, it is highlylikely that all critical errors like run-time exceptions mayhave been already reported and ﬁxed. We believe that the
SAFE WApp bug detector would be more useful to detect bugs
in JavaScript web applications under development rather thanafter deployment. As
SAFE WAPI [2], an extension of SAFE ,
analyzes API speciﬁcations additionally to detect incorrectuses of APIs in JavaScript web applications, we believe thatintegrating
SAFE WAPI and SAFE WApp will enlarge a set of bugs
that it can detect.
VIII. R ELA TED WORK
GA TEKEEPER [11] combines a static points-to analysis of
JavaScript programs in the web and run-time checks forunresolved names during static analysis. It models a DOMtree and browser APIs as a single node object and as mock-up objects, respectively. On the contrary,
SAFE WApp is fully
static, and it supports the full JavaScript with the faithful modelof browser APIs frequently used in real websites. Note that
SAFE WApp incorporates the DOM tree model of G A TEKEEPER
as a conﬁgurable option.Lerner et al. [9] formally modeled the event system of
web browsers faithfully as speciﬁed in W3C DOM Level3 Events. The model includes the complex event dispatchmechanism with event capturing and event bubbling. However,their model supports restricted subsets of DOM objects and theJavaScript language only with event-related features. Note thatour event model does not need to consider the event capturingand bubbling mechanism since it abstracts all possible eventdispatch and event handler execution.
Jensen et al. extended T AJS with a DOM and browser
APIs modeling [12]. While their event modeling inspired ours,there are signiﬁcant differences between our approach andtheirs. First, they modeled browser environments based onselected speciﬁcations, but our modeling is based on extensiveempirical data. Second, their modeling supports only simpleDOM tree abstraction. T AJS abstracts HTML elements withthe same tags as one single abstract object having a simpleabstract domain for a DOM tree by sacriﬁcing its tree structure.Because of this simple abstraction, all parent, children, andsibling links of a node in a DOM tree point to all possible nodeobjects with imprecise information. Consequently, T AJS failsto give precise analysis results on simple programs that exploreand manipulate DOM trees [3]. On the contrary,
SAFE WApp
provides conﬁgurable DOM tree abstraction, which supportsnot only the T AJS model but also a new DOM tree abstractionthat captures the concrete DOM tree precisely at the initial stateof the analyzer. In Section VII, we showed that high precisionin DOM tree abstraction can signiﬁcantly improve the analysisscalability for real-world JavaScript web applications.
IX. C
ONCLUSIONS
We presented, SAFE WApp , an open-source static analysis
framework for JavaScript web applications. It supports thefull JavaScript language and features an extensive model ofbrowser environments. Unlike previous work based on a fewspeciﬁcations, our DOM model is based on empirical datacollected from the 9,465 most popular websites. It providesconﬁgurable DOM tree abstraction models in three levels, twoexisting models and one new model that captures the precisetree structure of a concrete DOM tree at the initial state ofanalysis. We evaluated how different DOM tree abstractionmodels affect the analysis performance and precision usingreal-world JavaScript web applications in the wild. The ex-perimental results showed that precise DOM tree abstractioncan signiﬁcantly improve the analysis scalability. On top of
SAFE WApp , we have built a bug detector capable of detecting
JavaScript language-level bugs as an application of SAFE WApp .
While investigating the main web pages of the 10 most popularwebsites using the bug detector, we found previously undis-covered bugs in
wikipedia.org andamazon.com . Since our
bug detector reports only deﬁnite bug messages by default, thenumber of bug messages was manageable as 26 in 10 targetprograms, and 76.9% of all bug messages were true alarms. Wemake the implementation of
SAFE WApp and the bug detector
open to the public.
ACKNOWLEDGMENT
This work is supported in part by National Research
Foundation of Korea (Grant NRF-2014R1A2A2A01003235),Samsung Electronics, and Google Faculty Research A ward.
561REFERENCES
[1] G. Richards, S. Lebresne, B. Burg, and J. Vitek, “An analysis of the
dynamic behavior of JavaScript programs,” in Proceedings of the 2010
ACM SIGPLAN Conference on Programming Language Design and
Implementation, 2010.
[2] S. Bae, H. Cho, I. Lim, and S. Ryu, “SAFEWAPI : Web API misuse
detector for web applications,” in ESEC/FSE ’14: Proceedings of the
22nd ACM SIGSOFT Symposium and the 13th European Conferenceon F oundations of Software Engineering. ACM, 2014.
[3] E. Andreasen and A. Møller, “Determinacy in static analysis for
jQuery,” in OOPSLA’14: Proceedings of the 29th Annual Object-
Oriented Programming Systems, Languages, and Applications, 2014.
[4] V . Kashyap, K. Dewey, E. A. Kuefner, J. Wagner, K. Gibbons,
J. Sarracino, B. Wiedermann, and B. Hardekopf, “JSAI: A staticanalysis platform for JavaScript,” in FSE ’14: Proceedings of the 22Nd
ACM SIGSOFT International Symposium on F oundations of SoftwareEngineering, 2014.
[5] M. Sridharan, J. Dolby, S. Chandra, M. Sch ¨afer, and F. Tip, “Cor-
relation tracking for points-to analysis of Javascript,” in ECOOP’12:
Proceedings of the 26th European Conference on Object-OrientedProgramming, 2012.
[6] W3C, “Document Object Model Activity Statement,” http://www.w3.
org/DOM/Activity.
[7] WHA TWG, “HTML Living Standard,” http://www.whatwg.org/specs/
web-apps/current-work/multipage/.
[8] P . A. Gardner, G. D. Smith, M. J. Wheelhouse, and U. D. Zarfaty, “Local
hoare reasoning about DOM,” in PODS’08: Proceedings of the 27th
ACM SIGMOD-SIGACT-SIGART Symposium on Principles of DatabaseSystems. ACM, 2008.
[9] B. S. Lerner, M. J. Carroll, D. P . Kimmel, H. Q.-D. La V allee, and
S. Krishnamurthi, “Modeling and reasoning about DOM events,” inWebApps’12: Proceedings of the 3rd USENIX Conference on WebApplication Development. USENIX Association, 2012.
[10] D. Y u, A. Chander, N. Islam, and I. Serikov, “JavaScript instrumentation
for browser security,” in POPL ’07: Proceedings of the 34th annual
ACM SIGPLAN-SIGACT Symposium on Principles of ProgrammingLanguages. ACM, 2007.
[11] S. Guarnieri and B. Livshits, “GA TEKEEPER: mostly static enforce-
ment of security and reliability policies for JavaScript code,” in SSYM
’09: Proceedings of the 18th Conference on USENIX Security Sympo-sium. USENIX Association, 2009.
[12] S. H. Jensen, M. Madsen, and A. Møller, “Modeling the HTML DOM
and browser API in static analysis of JavaScript web applications,” inESEC/FSE ’11: Proceedings of the 19th ACM SIGSOFT Symposium andthe 13th European Conference on F oundations of Software Engineering.ACM, 2011.
[13] H. Lee, S. Won, J. Jin, J. Cho, and S. Ryu, “SAFE: Formal speciﬁcation
and implementation of a scalable analysis framework for ECMAScript,”inFOOL’12: International Workshop on F oundations of Object Ori-
ented Languages, 2012.
[14] KAIST PLRG, “Research material,” http://plrg.kaist.ac.kr/pch.
[15] M. Madsen, B. Livshits, and M. Fanning, “Practical static analysis of
JavaScript applications in the presence of frameworks and libraries,”
inESEC/FSE 2013: Proceedings of the 2013 9th Joint Meeting on
F oundations of Software Engineering. ACM, 2013.
[16] KAIST PLRG, “SAFE: JavaScript analysis framework,” http://safe.
kaist.ac.kr, 2013.
[17] S. Ryu, J. Choi, W . Choi, Y . Ko, H. Lee, and C. Park, “The
SAFE speciﬁcation,” https://github.com/sukyoung/safe/blob/master/doc/manual/safe.pdf, 2015.
[18] ECMA, “ECMA-262: ECMAScript Language Speciﬁcation. Edition
5.1,” 2011.
[19] P . Heidegger and P . Thiemann, “Recency types for analyzing scripting
languages,” in ECOOP ’10: Proceedings of the 24th European Confer-
ence on Object-Oriented Programming, 2010.
[20] R. Mangal, M. Naik, and H. Y ang, “A correspondence between two
approaches to interprocedural analysis in the presence of join,” in ESOP
2014: Proceedings of the 23rd European Symposium on Programming.Springer, 2014.
[21] C. Park and S. Ryu, “Scalable and precise static analysis of JavaScript
applications via loop-sensitivity,” in ECOOP’15: Proceedings of the
European Conference on Object-Oriented Programming. SpringerLNCS, 2015.
[22] “Jericho HTML parser,” http://jericho.htmlparser.net.
[23] “Cyberneko HTML parser,” http://nekohtml.sourceforge.net.[24] B. Johnson, E. M.-H. Y oonki Song, and R. Bowdidge, “Why don’t
software developers use static analysis tools to ﬁnd bugs?” in ICSE’13:
Proceedings of the International Conference on Software Engineering,
2013.
[25] M. Sch ¨afer, M. Sridharan, J. Dolby, and F. Tip, “Dynamic determi-
nac y analysis,” in Proceedings of the ACM SIGPLAN Conference on
Programming Language Design and Implementation, 2013.
[26] A. Feldthaus and A. Møller, “Checking correctness of TypeScript inter-
faces for JavaScript libraries,” in Proceedings of the ACM International
Conference on Object Oriented Programming Systems Languages andApplications, 2014.
[27] S. H. Jensen, P . A. Jonsson, and A. Møller, “Remedying the eval
that men do,” in ISSTA 2012: Proceedings of the 2012 International
Symposium on Software Testing and Analysis. ACM, 2012.
[28] S. H. Jensen, A. Møller, and P . Thiemann, “Type analysis for
JavaScript,” in SAS ’09: Proceedings of the 16th International Sym-
posium on Static Analysis, 2009.
[29] E. Andreasen and A. Møller, “Determinacy in static analysis for
jQuery,” in OOPSLA’14: Proceedings of the 2014 ACM International
Conference on Object Oriented Programming Systems Languages andApplications. ACM, 2014.
562