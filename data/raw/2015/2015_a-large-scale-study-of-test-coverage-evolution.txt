A Large-Scale Study of Test Coverage Evolution
Michael Hilton
Carnegie Mellon University
Pittsburgh, PA, USA
mhilton@cmu.eduJonathan Bell
George Mason University
Fairfax, VA, USA
bellj@gmu.eduDarko Marinov
University of Illinois at
Urbana-Champaign
Urbana, IL, USA
marinov@illinois.edu
ABSTRACT
Statement coverage is commonly used as a measure of test suite
quality.Coverageisoftenusedasapartofacodereviewprocess:
if a patch decreases overall coverage, or is itself not covered, then
the patch is scrutinized more closely. Traditional studies of how
coveragechangeswithcodeevolutionhaveexaminedtheoverall
coverage of the entire program, and more recent work directly ex-
aminesthecoverageofpatches(changedstatements).Wepresent
anevaluationmuchlargerthanpriorstudiesandmoreoverconsider
anew,importantkindofchange—coveragechangesofunchanged
statements.Wepresentalarge-scaleevaluationofcodecoverage
evolution over 7,816 builds of 47 projects written in popular lan-guages including Java, Python, and Scala. We find that in large,
mature projects, simplymeasuring the change to statementcover-
age does not capture the nuances of code evolution. Going beyond
considering statement coverage as a simple ratio, we examine how
the set of statements covered evolves between project revisions.
We present and study new ways to assess the impact of a patch
on a project’s test suite quality that both separates coverage of the
patch from coverage of the non-patch, and separates changes in
coverage from changes in the set of statements covered.
CCS CONCEPTS
•Software and its engineering →Software testing and de-
bugging;
KEYWORDS
Software testing, code coverage, empirical study, flaky tests
ACM Reference Format:
Michael Hilton, Jonathan Bell, and Darko Marinov. 2018. A Large-Scale
StudyofTestCoverageEvolution.In Proceedingsofthe201833rdACM/IEEE
International Conference on Automated Software Engineering (ASE ’18), Sep-
tember3–7,2018,Montpellier,France. ACM,NewYork,NY,USA, 11pages.
https://doi.org/10.1145/3238147.3238183
1 INTRODUCTION
Codecoveragemetricsareoftenusedbydeveloperstoidentifyhow
well-tested an application is. There are a wide variety of coverage
metrics, including statement, branch, MC/DC, method, file, and
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ASE ’18, September 3–7, 2018, Montpellier, France
© 2018 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.3238183path coverage [ 10]. Statement coverage—the ratio of statements
executed by tests divided by total number of statements—is the
simplest but most commonly used.
Modern development workflows often use a continuous integra-
tion (CI) service to build every push and run their project’s tests.
As CI services have become widely adopted [ 25], ancillary services
that track additional metrics from CI, such as code coverage, are
also becoming more popular. Developers can configure CI services,
such as Travis [ 40], to post code coverage data to a service such as
Coveralls[ 19],whichmakesthedataeasilyavailabletodevelopers,
forinstancewhenreviewingpullrequests.Coverallsmaintainsa
recordofaproject’scoverageovertime.Additionally,Coverallscan
automatically update coverage badges that display the latest cover-
ageresultonaproject’shomepage[ 41].Thisgrowingpublicrecord
of coverage data, organically collected by developers, provides a
great opportunity for researchers to study real code coverage data.
To the best of our knowledge, we are the first researchers to study
coverage data collected and so widely shared by developers.
While the overall statement coverage of a test suite provides
some insight into its (in)completeness, it reduces the quality mea-
sure to a single ratio, making developers potentially miss valuable
informationabouttheirtestsuiteanditslimitations.Fordevelopers
oflarge,stableprojectsthathavealargenumberofstatements,it
isoftendifficulttorecognizeanynoticeablechangeinthismetric
fromonecommit(patch)toanother,e.g.,foraprojectwith1mil-
lion lines1of code, a change in coverage of even 100 lines would
onlyimpactcoveragebyonehundredthofonepercentagepoint.
Nonetheless,thesechangescanaddupovertime:althoughasin-
gle100-linepatchmaynotmakeanoticeablechangeincoverage,
many small patches can make such a change. Even more concern-
ing, coverage of some lines may change non-deterministically due
to inherent non-determinism in the tests [ 22,28,29]. Even in
smallerprojects,whereanincreaseintheoverallcoveragemight
bemorenoticeable,trackingonlythissimpleratiodoesnotcapture
whichstatements are covered [ 32]. In an extreme case, a project
with50%codecoveragecouldmaintainthatoverallcoveragewhile
completely flipping the set of statements covered. Coverage can
alsoincrease,seeminglyindicatingabettertestsuite,evenwhen
that is not necessarily the case, e.g., coverage might go up despite
a drop in the number of executed statements if code is removed,
decreasing the total number of statements even more.
One approach for gaining better insights from statement cov-
erage is to focus not on the coverage of the entiresystem under
test(SUT)but,instead,onlyonthe coverageofeachpatch (changed
statements) performed on the SUT [ 4,19,29,32]. Collecting patch
coverage can be useful because if a patch is not covered enough,
1This paper uses “line(s)” and “statement(s)” interchangeably.
53
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Michael Hilton, Jonathan Bell, and Darko Marinov
2b. Extract data from Coveralls API1b. GitHub + 
Coveralls mining1a. Literature 
search2a. Clone and build projects, collect 
coverage3. Analyze diffs and 
coverage per-build4. Visualize aggregate 
data
18 projects29 projects
2,456 builds5,360 builds47 projects, 
7,816 buildsIdentifying Projects Collecting Coverage Synthesizing ResultsGenerating Visualizations
Figure 1: Overview of methodology. Compared to prior studies: green is new; yellow is nearly an order of magnitude larger.
thendeveloperscaneasilyflagthispatchincodereviewandrequire
more tests to be added with the patch. However, even if a patch is
well covered, the impact of the patch on the non-patch (unchanged
statements) part of the SUT is not known a priori.
Priorempiricalworkhasevaluatedhowcoveragechangesduring
code evolution but for a relatively small number of projects and
builds. For example, Zaidman et al. [ 43] reported a high amount of
manuallaborwhenstudyingjust3projects(andcollectingcoverage
for a total of 30 builds), while Marinescu et al. [ 29] reported an
immense amount of infrastructure needed to collect coverage data
from just 6 projects (for a total of 1,222 builds). Further, while
prior work has investigated thechange in overall coverage, or the
coverageofpatches,nopriorempiricalstudyhasexaminedhowthe
setoflinescovered changes.EvenwhentheoverallSUTcoverage
appears stable, and the coverage of new patches is high, are the
actual lines covered still changing? Or, are there hidden changes to
coveragethatdevelopersshouldbeawareof,beyondcoverageof
the entire SUT and coverage of the patch?
To better understand codecoverage, how it changes, and how
developerscanbetterreasonabouttheircodeandtheir tests,we
present a large-scale longitudinal study of test coverage evolution.
Ourstudybuildsonpriorempiricalworkstudyingcodecoverage
but increases the number of projects (47, written in 7 different lan-
guages)andrevisionsofthoseprojects(7,816)byalmostanorder
ofmagnitude.Also,oursisthe firststudyofcodecoveragetocorre-
latethecoverageofindividuallinesofcoveragethroughoutproject
evolution, tracking how a line may become covered and then later
becomenotcovered.Further,oursisthefirststudytoutilizecode
coveragehistorythatdeveloperscollectonCoveralls[ 19](gathered
through the public API of the Coveralls service), in addition to
coverage metrics that we collect ourselves.
In this paper, we answer the following questions:
RQ1:Whatisthedistributionofpatchcoverageacrossrevi-
sions?Whatfractionofapatchiscoveredbytheregression
testsuite?Doprojectswithhighpatchcoveragealsohave
high overall coverage?
RQ2:Whatimpactdopatcheshaveonthecoverageofnon-
patch code? Do we see similar behavior across projects?
Does high patch coverage imply that a patch increases cov-
erage of non-patch code?
RQ3:Areallchangesequallyvisible? Doprojectshavechanges
that are occluded (hidden)?
RQ4: How does the set of covered lines change? Are there
hot-spots of coverage change, i.e., lines that flip between
being covered and uncovered throughout evolution?
RQ5: What kinds of changes to code drive changes to cov-
erage?Doescodecoveragechangemorebecauseoldcode
becomestested,orbecausenew,testedcodeisadded?Or,do
line deletions drive changes to code coverage?To answer these questions, we prepare an extensive dataset
of code coverage, develop a toolset for automated analysis, and
perform various analyses, making the following contributions:
•Dataset: Our dataset of code coverage information from
7,816 revisions of 47 projects is publicly available:
http://www.code-coverage.org
•Toolset: Ourtoolsetincludesthescriptsthatgatheredour
dataset and that can analyze the dataset, allowing otherresearcherstoperformsimilarexperimentsandbuildnew
tools that analyze coverage change.
•NovelCoverage: Wehighlighttheimportanceofmeasuring
change in coverage of unchanged code.
•Results: Weperformseveralanalysesandpresentnewfind-
ingsthatanswerthelistedresearchquestions.Onefinding
is thatwhichlines arecovered can varywidely in aproject,
even when the overall coverage appears to remain the same.
•Implications: Weidentifyimportantimplicationsfordevel-
opers,toolbuilders,andsoftwareengineeringresearchers
workingtomeasureandimprovetestquality.Forinstance,
wefoundthatchangestonon-codefilesoftenimpactcode
coverage,andhence,regressiontestselectiontoolsshould
track such dependencies to be safe.
2 METHODOLOGY
Researchershavepreviouslystudiedtheevolutionofcodecover-
age[21,29,43]bydownloadingsomeopen-sourceprojectsand,for
several revisions of these projects, compiling the code and running
testswhilecollectingcodecoverage.Ourmethodologybuildson
this approach but significantly expands the breadthof the study
by including almost an order of magnitude more projects (47) and
revisions (7,816). We leverage Coveralls [ 19], the increasingly pop-
ular service for tracking code coverage for open-source projects.
We also significantly extend the depthof the study by tracking the
change to coverage of individual statements across revisions.
Figure1showsanoverviewofourmethodology.Wefirstiden-
tified candidate projects to include in our study, selecting both
projectsstudied inrecentregressiontesting researchandprojects
thatusetheCoverallsservice.Wethencollectedcoverageforthese
projects, either running the test suites ourselves or collecting data
fromCoveralls.Wenextaggregatedthedatawithversion-control
historytotrackthecoverageofindividualcodelinesthroughout
project evolution. We finally summarize and visualize the results.
2.1 Identifying Projects
Automatically downloading, compiling, and executing tests for
open-sourceprojectsisoftennon-trivial.Someprojectsfailtocom-
pile (e.g. due to missing dependencies), and others require manual
configuration or installation of external dependencies. However,
54
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. A Large-Scale Study of Test Coverage Evolution ASE ’18, September 3–7, 2018, Montpellier, France
excludingprojectsthatrequiresomedegreeofmanualconfigura-
tioncouldbiastheprojectsincludedinastudy.Wereliedontwo
complementary approaches to gather a diverse set of projects.
Traditional Evaluation: We identified four recent research
papers[12,15,23,36]thathadexperimentswithsoftwareevolution
(specificallywithregressiontesting).Wetabulatedtheopen-source
projects studied in these experiments and tried to clone, build,
andtesteachofthem.Intotal,weselected29projects:11(ofthe32) from [
23], 5 (of the 10) from [ 15], 3 (of the 17) from [ 36], and
10 (of the 26) from [ 12]. We included all projects which (1) used
the Maven build system and (2) successfully compiled (on its most
recentcommit)withthecommand mvn package .Weallowedforup
tothirtyminutesoftroubleshootingperprojecttopotentiallyinstall
external dependencies required by the project as may have been
specifiedinREADMEfilesorerrormessagesduringthisprocess.
These 29 projects make up our traditional evaluation set.
In Vivoset:We broadened the scope of our evaluation by in-
cludingprojectswhichwe didnotcompileortestourselves,instead
leveraging coverage data collected and shared by the project devel-
opers themselves. Coveralls [ 19] is a free service that stores cover-
agedata,allowingdeveloperstotrackthecoverageoftheirprojects
overtime.Manyopen-sourceprojectsfromGitHubuseCoveralls
as part of their continuous integration (CI) pipeline: when develop-
erspushtheirchangestoGitHub,aCIservice(e.g.TravisCI[ 40])
automatically fetches these changes, compiles the project, runs the
testsuite, anduploadscoveragedatatoCoveralls.Whilesomeprior
work[12,14,27]hasusedtheoutputofCI services, likeTravisCI,
asadatasetforevaluation,wearenotawareofanypriorworkthat
used code coverage from services like Coveralls as we do. Reusing
coveragedatahasseveraladvantages:(1)wecanincludeprojects
thataremorecomplextobuild,forwhichdevelopershaveprovided
automated configuration scripts to a CI service; (2) we can include
projects writteninany languagesupported byCoveralls, because
it abstracts the actual collection of code coverage; and (3) we need
notexpendresourcescompilingandrunningtheseprojects’tests.
We refer to the data from Coveralls as our in vivoevaluation set,
because the coverage results come directly from the field.
To identify projects for our in vivodataset, we started by crawl-
ing GitHub to find projects that use both TravisCI and Coveralls
services. We searched GitHub by project language (including most
popular and more recent languages in our criteria), looking for
projects with configuration files that refer to Coveralls, collecting
the most-starred projects per language meeting our criteria. ForeachprojectthatreferredtoCoveralls,wequeriedtheCoveralls’public API [
20] to detect if the project indeed has publicly avail-
able coverage data on Coveralls. For each project that had data, we
checked the number of builds for which the project shipped cover-
age data to Coveralls, and the number of linesof code in the most
recentversionoftheproject.Wethenpickedarbitrarythresholds
tofilteroutprojectswithshorthistoriesonCoveralls(lessthan250revisionsbuiltandtested)ortriviallysmallprojects(lessthan1,000
lines of code total), leaving 19 projects.
2.2 Collecting Coverage
TraditionalEvaluation: Weconductedourtraditionalevaluation
bycompiling,testing,andcollectingcoverageoneachofthe250
most recent commits of the 29 projects that we had identified,successfully completing a total of 5,382 builds. We ran these builds
on a cluster of Ubuntu 14.04 virtual machines, running ApacheMaven 3.3.9 and Java 1.8.0_131. We collected coverage using the
matureJaCoCotool[ 5],configuredtocollectcoverageofallproject
codefiles.Ifabuildfailed,wedidnotseekoutmorebuilds,hencewe
may not have 250 successful builds of each project. We considered
othercoveragetools,Cobertura[ 18]andClover[ 17],butneither
fullysupportsJava8,andhence,wouldhavelimitedourstudyto
include only projects that do not use recent Java features.
In Vivoset:Coverallstermsofuserequestbroadlythatusersof
theirAPIdonotimposeanundueloadontheservice,andwedid
not want to abuse the service. Unfortunately, collecting our datarequired making many requests to the service: one per file, per-
revision,per-project.Hence,aprojectwith1,000fileswouldrequire
1,000 requests to collect detailed coverage of each file of a single
revision.Weself-imposedaratelimitof5,000requestsperhourand
restricted our data collection to only several days. We contactedCoveralls to inquire if they could make the data easier to obtain
(e.g., one request for all files in a revision) and to check that our
procedurewould notplacean undueloadontheir service,butwe
receivednoresponse.Hence,forthe19projects,wedownloaded
coverage data for only 2,575 builds—we skipped the remaining
builds to not abuse the service.
2.3 Determining Code Changes
The next step in our study required unifying the coverage data
with code change information. For each commit of each project,weneededtofindwhichlineswereadded,modified,orremoved
fromthepreviouscommit.Becauseourexperimentsincludeonly
projectsthatusetheGitversion-controlsystem,itwasrelatively
straightforwardtocollectcodechangeinformationusing git diff
. Using the diffalgorithm, we simplified the potentially rather
complexprocess oftracking linesthatmay havemoved orshifted
throughoutthecodebase[ 35].Wematchedeachcommitwithits
parentcommitforwhichwehaddata,usingGitinformationtotrack
branchingandensuringthateachcommitwasproperlymatched
with a prior commit from which it descended. We compare each
commit with its parent, obtaining the list of added and removed
lines. For the remaining (unchanged) lines, we built a mappingbetween the line numbers from the two commits, which is non-
trivial when new lines are added or old lines deleted from files,making it difficult to identify where a line from a prior commit
isinthenextcommit.Weused difftogeneratethesemappings,
invokingitforeachchangedfiletodeterminethenewlinenumber
of each line from the previous commit of that file.
2.4 Aggregating Results
Finally,weaggregatedcodecoverageandcodechangeinformation,
and generated visualizations by creating and running a series of R
scripts.Table 1showsasummaryofbasicstatisticsforeachproject.
For the remainder of this paper, we refer to projects by their ID
(the far left column). For each project, we report the programming
language, the prior paper or Coveralls (abbreviated as C.IO), the
numberofbuildsstudied,averagelinesofcodeacrosscommits,and
thetotalcommittimewindowthatourcoveragedataspans.The
Coveralls projects are mostly smaller (in LoC) than the rest, but
nonethelessaresimilarinoverallcoverage.Beforeaddressingour
55
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Michael Hilton, Jonathan Bell, and Darko Marinov
Table 1: Key statistics describing all of the projects included in this study.
Coverage % of Commits Changing: Avg. Patch Size (Lines)
Project Lang Source Builds LoCTime
range
(months) Start Sparkline End Test Source Both Neither Source Test All
P01apache/commons-collections java [24]18912,765 4084% 84%6%34%24% 36% 8953154
P02apache/commons-dbcp java [24]1645,662 1948% 51%13% 27%12% 48% 141437
P03apache/commons-exec java [12]212971 6563% 72%24% 17%13% 47% 132044
P04apache/commons-functor java [24]2482,693 6983% 97%11% 47% 8% 34% 116 78210
P05apache/commons-io java [24] 355,021 288% 87%26% 26%31% 17% 9779178
P06apache/commons-jxpath java [24]1999,633 9475% 77%8%33%13% 47% 74 9125
P07apache/commons-math java [24]21745,034 1690% 90%19% 39%32% 10% 314114935
P08apache/commons-net java [24] 539,210 130% 30%11% 40%11% 38% 40 461
P09apache/commons-validator java [24]1042,854 1077% 78%23% 36%21% 20% 441065
P10apache/empire-db java [24]24121,258 6014% 14%0%72% 3% 24% 158 1190
P11apache/httpcore java [12]22313,198 1877% 75%13% 36%39% 11% 1,249 3871,658
P12ARMmbed/mbed-ls python C.IO 60804 675% 78%2%65%30% 3% 271153
P13bitwalker/timex elixer C.IO 1282,615 1665% 68%2%50%31% 16% 23 679
P14broadinstitute/firecloud-orchestration Scala C.IO 1702,658 1364% 68%4%16%64% 16% 9395213
P15containers/virtcontainers go C.IO 2965,332 966% 61%1%33%42% 23% 1,276 511,664
P16coreos/alb-ingress-controller go C.IO 982,041 73% 21%0%50%27% 23% 509 34569
P17damianszczepanik/cucumber-reporting java [15]248794 1588% 99%9% 8%48% 34% 6064208
P18dask/dask python C.IO 29015,322 794% 92%5%21%54% 20% 4633114
P19doanduyhai/Achilles java [12]11111,008 956% 54%4%29%41% 26% 370201626
P20dropwizard/dropwizard java [12,36]2467,700 986% 87%9%10%24% 57% 132150
P21eBay/cors-filter java [15]204280 4594% 100%24% 27%17% 31% 354283
P22F5Networks/k8s-bigip-ctlr go C.IO 1035,621 576% 83%7%24%33% 36% 6848191
P23fasseg/exp4j java [15]233640 4089% 95%6%12%39% 43% 292 80382
P24Gillespie59/eslint-plugin-angular node C.IO 2121,213 19100% 100% 5%20%47% 28% 9930195
P25goldmansachs/gs-collections java [24]24938,242 1692% 93%20% 20%41% 19% 295292767
P26google/jimfs java [12]1003,401 4589% 91%11% 23%39% 27% 7582921,054
P27HazyResearch/deepdive Scala C.IO 1111,913 581% 73%0%17% 8% 75% 3129271
P28hector-client/hector java [12]1378,583 2535% 39%4%55%32% 9% 114 50195
P29ikawaha/kagome go C.IO 911,099 2780% 86%10% 33%29% 29% 111 29144
P30ilovepi/Compiler dotNet C.IO 961,874 187% 90%7%57%31% 4% 209 19238
P31jhy/jsoup java [15]2466,615 2876% 77%11% 23%41% 25% 331670
P32jknack/handlebars.java java [12]1003,935 983% 84%11% 30%40% 19% 192 26225
P33JodaOrg/joda-time java [24,36]24814,789 3590% 90%5%25%17% 53% 11 790
P34joel-costigliola/assertj-core java [12,36]24111,104 990% 90%15% 22%42% 22% 234315557
P35mailgun/kafka-pixy go C.IO 644,387 1380% 69%6%27%59% 8% 9832331,385
P36MITLibraries/topichub Scala C.IO 1022,466 1157% 60%7%25%43% 25% 3340112
P37platinumazure/eslint-plugin-qunit node C.IO 62628 22100% 100% 8% 6%27% 58% 5527102
P38PragTob/benchee elixer C.IO 148441 694% 94%7%29%44% 20% 5652119
P39raml-org/raml-java-parser java [15]2486,455 1686% 86%2%58%23% 17% 168 9605
P40ShiftForward/apso Scala C.IO 941,629 954% 59%7%19%29% 45% 301358
P41spatialmodel/inmap go C.IO 555,983 981% 83%5%24%36% 35% 273 98442
P42square/okhttp java [12]24711,854 1078% 78%10% 29%45% 15% 363372
P43square/retrofit java [24]1812,479 1756% 57%7%35%38% 20% 119102235
P44SteamDatabase/ValveResourceFormat dotNet C.IO 1792,794 2382% 73%2%80% 4% 13% 108 1147
P45terasolunaorg/terasoluna-gfw java C.IO 972,561 1799% 99%12% 4%16% 67% 1,4811,1882,921
P46undertow-io/undertow java [12]23851,388 960% 60%7%72%18% 4% 491264
P47zxing/zxing java [12]19815,440 2168% 76%5%34%16% 45% 31 7712
Total 47 projects, 384,412 LOC Average: 1668,178 2074% 76%9%32%30% 29% 224 93397
fiveresearchquestions,wepresentthreedemographicquestions,
DQs, that describe the overall composition of our dataset in terms
of patches and overall coverage.
DQ1:Dopatchestouchbothcodeandtests? Thisquestionmir-
rorsaquestionoftenstudiedinthecontextofcodecoverageand
miningsoftware repositories[ 29,43].Weexaminedeach patchof
eachproject,lookingatthefileschangedbyeachpatch.Wecate-
gorizedeachfileasatestcodefile,sourcecodefile,oranon-code
file. Code files were defined as ending with the correct suffix given
theprojectlanguage:.java,.scala,.go,.js,.ts,.cs,.ex,.exs,.py.Fol-
lowing prior work [ 43], code files were then categorized as test or
source code files if their path contained “test” or “.spec”. Table 1
presentstheresults.Similartopriorstudies[ 29],wefoundthatfew
commits modified only test files; far more common were commits
that modify both test and non-test files, or only non-test files.DQ2: Whatare the sizesof eachpatch?
This question also mir-
rors one posed previously [ 29]. If a project has primarily small
patches,thenthesepatchesareperhapseasierforhumanstoreasonabout.However,ifthosepatchesarelarger—hundreds,orthousandsoflines,theymayrequiredifferentapproachestobereasonedabout.To answer this question, again, we categorize files as “source code”
or“testcode,”andcomputethenumberofchangedlinesineachfile.
This includes all changes to these files and counts each edited line
asachange.Table 1showstheresults(“Avg.PatchSize(Lines)”),
including allchanged lines in the “all” column (in source code, test
code, or non-code files).
Our results strikingly differ from those of Marinescu et al. [ 29];
their study of six C/C++ programs reported a median number of
patchlinesrangingbetween4and7.Whilethedifferencemaybe
partly due to us counting allchanged lines (not only executable
statements), this alone is unlikely to lead to such a significant
differenceintheextremecasesofprojectssuchas P11,P15,and P45.
We believe that this indicates that many of the projects that we
studied were under substantially more active development thanthe mature projects in their study (GNU Binutils, Git, Lighttpd,Memcached, Redis, and
∅MQ). This finding also underscores the
importanceofsamplingadiversesetofprojectsinempiricalstudies.
DQ3: How does coverage change over time? Finally,wecalcu-
latedthecoverageforeachprojectacrossallcommitswestudied.
Table1reportstheaveragelinesofcode(LoC)andcoverageofeach
56
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. A Large-Scale Study of Test Coverage Evolution ASE ’18, September 3–7, 2018, Montpellier, France
P1P2P3P4P5P6P7P8P9P10P11P12P13P14P15P16P17P18P19P20P21P22P23P24P25P26P27P28P29P30P31P32P33P34P35P36P37P38P39P40P41P42P43P44P45P46P47
0 (0−25) (25−50] (50−75] (75−100) 1001234567891011121314151617181920212223242526272829303132333435363738394041424344454647
0% 25% 50% 75% 100%
Percent of builds satisfying patch coverage % at level indicated by color:
Figure2:Coverageofnewlinesineachpatch.Eachbarrepresentstheproportionofbuildswiththatcoveragelevel(asdenoted
by the color). The black bar indicates the average overallcoverage of each build per-project (against the percentage scale)
projectatthestartandendofourdataset,alongwitha sparkline
visualization showing how the coverage changed over time (scaled
to0-100%).Weseethatourdatasetcontainsadiversesetofprojects:
some with low coverage, others with high; some with little change,
otherswithmore.Formostprojects,coverageremainsrelatively
flat during the studied window, similar to prior results [29].
However, from the sparklines we see that some projects—in
particular P23,P27,and P44—havespikesintheircoverage,where
coverage drops significantly and then returns to its prior position.
After manual inspection, it appears that this is often caused by
broken tests: if a test fails early in its execution, then it does notcontinue to run and cover the statements that it would typically
cover.Unfortunately,whilewehadtestresultinformationfromour
own experiments, we did not have easy access to test results from
Coveralls to filter out failed tests.
It is perhaps unsurprising that we do not observe significant
changes to coverage, given that our projects are non-trivially large,
averaging 8,178 lines of code. The most visible spikes (e.g. P23,
P27) are in projects with the fewest lines of code, while the largest
projects ( P07,P25, and P46) appear nearly flat. Given that state-
mentcoverageissimplytheratioofexecutedstatementstototal
statements, increasing coverage by even one percentage point may
requirecoveringthousandsoflinesofpreviouslyuncoveredcode.
Hence,onaday-to-daybasis,developers(especiallyoflarge,mature
projects) are unlikely to see changes in total coverage.
3 RESULTS
RQ1: What is the distribution of patch coverage across revi-sions?
Since it is difficult to observe changes to overall project
coverage on a day-to-day basis, prior work [ 4,19,29,32] as well ascurrenttools[ 1–3,6,7]haveadvocatedthatdeveloperspayparticu-
larattentiontocoverageofpatches.Weusetheterm patch,commit,
andchange-setinterchangeably:aunitthatrepresentsadeveloper’s
changestocode(withoutattemptingtounderstandthenatureof
the change as a bug fix or new feature). Given that patches are
generally much smaller than the overall codebase, patch coverage
might be more meaningful to developers reviewing a patch.
To study the coverage of patches in thewild, we calculated the
coverage of all changed statements in each patch in our dataset.
To visualize these results, we binned each patch by its coverage,
choosing bins of 0%, (0%-25%), (25%-50%], (50%-75%], (75%-100%)
and 100% coverage of the patch. Figure 2shows the distribution of
patches in each bin, by each project. We also visualize the average
coverageacrossallversionsofallofthecodeineachprojectwitha
black bar. For example, for the project P01, almost 50% of the code
patcheshave100%coverage.However,theoverallcoverageofall
code across all builds for this project is 85%.
ThisvisualizationissimilartoonecreatedbyMarinescuetal.in
their study of patch coverage of six projects, with two distinctions:
(1)weaddtwomorebins(“0”and“100” tosegregatepatchesthat
are fully covered or not at all covered, rather than simply 0-25,25-50, 50-75, 75-100), and (2) we superimpose the overall project
coverage. Adding these two additional bins allows us to recognize
that, in fact, patches are often either entirely covered, or not at all
covered: it is far less frequent in the projects that we studied to
observe patches that were partially covered.
Whileitmightseemintuitivethathigherpatchcoverageimplies
higher overall coverage, when we look at our data, we did not
seeevidenceofthis.Fromthischart,wecanobservethathaving
morepatcheswithhighercoveragedoesnotalwaysindicatehigher
overall coverage. For example, when comparing P03and P02we
57
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Michael Hilton, Jonathan Bell, and Darko Marinov
P01P02P03P04P05P06P07P08P09P10P11P12P13P14P15P16P17P18P19P20P21P22P23P24P25P26P27P28P29P30P31P32P33P34P35P36P37P38P39P40P41P42P43P44P45P46P47
0 25 50 75 100
Patches with changes to code files:
Patches with no changes to code files:Increase
IncreaseNo impactNo impactDecreaseDecrease
Figure 3: For each patch, we show whether it increases, decreases, or has no impact on coverage of existing (non-patch) code.
The size of each bar represents the percent of patches in that bucket.
seethateventhough P02hasahigherpercentageofpatcheswith
more coverage, it has lower overall coverage than P03. To better
understand the relationship, we tested the correlation between
patchcoverageandoverallcoverage.WecomputedtheKendallTau
coefficientbetweenpatchcoverageandoverallcoverageforeach
patch. We found that there was no correlation between the two
variables [r =-0.01,p<0.01].
Finding: Patchcoveragevarieswidelybetweenprojects.Patch
coverage does not correlate with overall coverage.
RQ2: What impact do patches have on the coverage of ex-
isting (non-patch) code? While patch coverage considers how
well-tested a patch may (not) be, it surely cannot be the only cri-
teriausedtojudgetheimpactofthatpatch.Forinstance:apatch
might have 100% patch coverage, but applying that patch might
reduce the coverage of existing code.
Hence, to better understand the impact of each commit, we also
look at the effect that each commit has on the unchanged, existing,
non-patch codeintheproject.Wecategorizedtheimpactofeach
commitonexisting(non-patch)codeasanet-increasetothenumber
of existing lines covered, net-decrease, or having no impact. Upon
apreliminaryinvestigation,weobservedthatmanyofthecommits
whichincreasedordecreasedcoverageinnon-patchcodecontained
no changes to code themselves. Hence, we further separated each
ofthesegroupsintopatcheswithandwithoutchangestocodefiles.
This statistic is complementary to patch coverage: when reviewing
a patch, in addition to seeing that the patch is covered or not,developers can also see if this patch increases or decreases thecoverageoftherestofthecodebase.Ratherthanlookingattotalcoverage (of both the new and the existing code), by separating
the coverage of a patch from the coverage of existing code, we can
observeinstanceswhereoverallcoveragemightgoup(forinstance,
becauseapatchcontainedaverylargenumberofnewlycovered
lines),butcoverageofnon-patchcodemightgodown(becausethat
patch removes calls to existing code).
Figure3shows the impact of each commit on non-patch code
coverageforallcommitsforeachprojectinourcorpus.Itisinterest-ingtonotethatdifferentprojectshaveverydifferentprofiles.Some
projects,suchas P02havemanycommitstonon-codefileswhich
nonetheless have an impact on coverage. Other projects, such as
P47havealmostnosuchcommits,wheremostcommitsdotouch
code files and do impact coverage of existing code.
Uponmanualinspection,wefoundthatmanyofthesenon-code
changes involvechanging configurations. Thesechanges could be
causingchangestocoverageduetodifferencesbetweendifferent
versionsofAPIsorothernon codechanges. P46containedmany
non-code changes; one example commit message describes thechange as “Fix build on latest JDK9” and the only changes are to
theproject’spom.xmlfile[ 8].Thesechangestocoveragecouldalso
be due to non-determinism [22], rather than intentional changes.
Todetermineifthereisarelationshipbetweenpatchcoverage
andnon-patchcoverage,weperformastatisticalanalysis.Foreach
commit in our data, we look at all of the patches which have at
least one statementin their diff. We then computedthe change to
non-patchcoveragebycalculatingtheratiobetweenthenumber
of non-patch lines hit and the total number of non-patch lines.
WecomputedthePearson’scorrelationcoefficientbetweenpatch
coverage and non-patch coverage for each patch. We found no
58
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. A Large-Scale Study of Test Coverage Evolution ASE ’18, September 3–7, 2018, Montpellier, France
P01P02P03P04P05P06P07P08P09P10P11P12P13P14P15P16P17P18P19P20P21P22P23P24P25P26P27P28P29P30P31P32P33P34P35P36P37P38P39P40P41P42P43P44P45P46P47
0 25 50 75 100
0 1−10 11−100 101−1,000 1,001+
Figure 4: Percentage of commits (size of bar) with statements changing coverage (color of bar) even when the total project
coverage did not appear to change.
correlationbetweenthetwovariables[r =-0.004,p=0.79],concluding
thatcoverageofapatchisnotcorrelatedwiththepatch’simpact
to coverage of existing, non-patch code.
Finding: Patches often impact coverage of existing (non-
patch) code, and high patch coverage does not correlate with
increasing non-patch coverage.
RQ3:Areallchangesequallyvisible? Whendevelopersobserve
thatoverallcoveragehasnotchangedbetweendifferentbuilds,they
might naturally assumethat there have not been changesto what
their tests execute . However, it is possible that the linescovered
might change — perhaps drastically — even if the total project
coverageappearstobethesame.Wecallthesechanges occluded,
and study their prevalence in our dataset. To do so, we filtered our
data to examine only commits where there did not appear to beany change to coverage from the prior build (specifically, wherethe difference in coverage was less than 0.01 percentage points),
and then calculated the number of statements changing coverage.
Figure4showshowmanyoccludedchangesweobservedper-
project,per-commit:eachcoloredbarrepresentsarangeofoccluded
statements, and the size of the bar represents the percentage of
that project’s commits at that level. We observe that the number of
occludedchangesvarieswidelybyproject—theyareverypreva-
lent in some projects and uncommon in others. However, every
projecthadatleastonecommitwheretherewereoccludedchanges,
indicating that “steady” coverage does not imply “no change” to
codecovered.Welookedcloserat P25,P35and P46,whichalways
hadoccludedchanges.Wefoundthat P25containedalargeamount
ofgeneratedcodethatoftenchangedbetweencommits,butthesizeof that generated code remained stable, making coverage appear to
bestable.Wefoundthatgeneralnon-determinismin P35and P46
caused the lines covered to vary.
Finding: Even when patches appearto leave coverage un-
changed, the set of lines covered can still vary widely. Devel-
opers should not trust a seemingly steady coverage metric to
indicate that the samelines are continuously covered.
RQ4: How does the set of existing lines covered change? In
ourpriorquestions,weconsideredhowapatchiscoveredorhowitimpacts the coverage of existing code. Here, we study the coverageof individual lines changing over time. Each time that tests are run,
the coverage of a line might “flip” from covered to uncovered, or
uncoveredtocovered.Foreachcommit,weexamineeachflipped
lineinourdataset.Todoso,weusedthe difftooltoidentify(1)
alllinesthatexistin everyversionofeachprojectstudied,and(2)a
mapping foreach ofthose linesin each revisionto theequivalent
line number in the most recent revision. We used this global ID to
track the position of each line over time and then computed the
number of times that each of these lines flipped coverage. Figure 5
showsthedistributionofthenumberofflipsforeachoftheselines.
We see lines which only flip once, all the way up to a single line
whichflipscoverage128times.Alinewithahighflipcountislikely
covered non-deterministically, and hence, its coverage might be
lessimportantfordeveloperstofollowonaday-to-daybasis.We
notethat P25and P46(whichhadmanyoccludedchanges)alsohave
lines with many flips in coverage.
Werandomlyselectsomeofthelineswithmanyflipstobetter
understand why lines are flipping coverage. In one, a line in P20
59
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Michael Hilton, Jonathan Bell, and Darko Marinov
●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●●● ● ● ● ● ●● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ●● ● ● ●● ● ● ● ● ●● ● ● ● ● ● ● ●● ● ● ● ● ● ●● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ●● ● ● ● ● ●● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ●● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ●● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ●● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●●● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ●● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ●● ● ● ● ● ● ● ● ●● ● ● ● ●● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ●●● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ●● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●●● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●●● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ●●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ●● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ●● ●● ● ● ● ●● ●●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ●● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ●● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ●●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ●● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ●● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ●● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ●● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ●● ● ●● ●● ● ● ● ●● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ●● ●● ● ● ● ● ● ● ●● ●● ●● ● ● ●● ●●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ●● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ●● ● ● ●● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ●● ● ● ● ● ●● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ●● ● ●● ● ●● ●● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ●● ●● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ●● ● ● ● ●● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●●●● ● ● ● ● ●● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ●● ● ●● ● ● ● ● ● ●● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●●● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ●● ●● ● ● ● ●● ● ● ● ● ● ● ● ● ● ●● ● ● ● ●● ●● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ●● ● ●● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ●● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ●● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●
● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ●● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ●● ● ● ●● ● ● ● ● ●● ● ● ● ● ● ● ●● ● ● ● ● ● ●● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ●● ● ● ● ● ●● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ●● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ●● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ●● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●●● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ●● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ●● ● ● ● ● ● ● ● ●● ● ● ● ●● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ●●● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ●● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●●● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●●● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ●●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ●● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ●● ●● ● ● ● ●● ●●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ●● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ●● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ●●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ●● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ●● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ●● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ●● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ●● ● ●● ●● ● ● ● ●● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ●● ●● ● ● ● ● ● ● ●● ●● ●● ● ● ●● ●●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ●● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ●● ● ● ●● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ●● ● ● ● ● ●● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ●● ● ●● ● ●● ●● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ●● ●● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ●● ● ● ● ●● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●●●● ● ● ● ● ●● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ●● ● ●● ● ● ● ● ● ●● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●●● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ●● ●● ● ● ● ●● ● ● ● ● ● ● ● ● ● ●● ● ● ● ●● ●● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ●● ● ●● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ●● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ●● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●
P01P02P03P04P05P06P07P08P09P10P11P12P13P14P15P17P18P19P20P21P22P24P25P26P27P28P29P30P31P32P33P34P35P36P38P39P40P41P42P43P44P45P46P47
25 50 75 100 125
Figure 5: Distribution of how many times coverage flipped for unmodified lines throughout all revisions of each project,
showing only lines that changed coverage at least once. The x-axis displays the number of covered/uncovered transitions.
(DBIHealthCheck.java:31), the high-flip statement checks to see
if a database connection is still open at a regular time interval.In some cases, tests might complete before this health check isscheduled, causing it to not be executed. In another case, a line
inP08(TFTPServer.java:643),wefoundahigh-flipstatementthat
was dependent on a network socket’s state — and would detect
lost packets. The coverage of this line is dependent on whether
packetsarelostintransmissionduringthetestcase—whichoccurs
non-deterministically.
Finding: Lines may often flip between covered and uncov-
ered,suggestingnon-determinisminthetestsuite.Toolbuilders
should consider how to best track and represent this non-
deterministic coverage.
RQ5: What kindsof changes to code drive changesto cover-age?
Weconcludeourstudybyreturningtoproject-levelcoverage,
lookingat what kindsof changes causecoveragetochange. Atradi-
tional viewpoint might be that coverage increases because existing
linesofcodebecomecovered,andcoveragedecreasesbecausethoselinesarenolongercove red.However, ofcourse,lookingataspecific
revision of a project (compared to the prior), coverage can change
foravarietyofreasons.Forinstance,addingnewlineswillcause
coverage to increase or decrease, depending on the coverage of the
newlinesthatareaddedtothecode.Likewise,deletinglinescan
alsoimpactcoverage.Ifthedeletedlineswerecovered,itcancause
coveragetodecrease,andifthedeletedlineswerenotcovered,it
cancausecoveragetoincrease.Coveragecanalsochangedueto
change in coverage of unchanged lines.
Figure6showsalloftheseimpactfactorsforallrevisionsofeach
project.Byidentifyingthedifferentimpactfactorsandwhatroletheyplayineachprojects,wecanmakeobservationsabouthow
theprojects andtheir testcode are changingovertime, ratherthansimplyobserving“coverageincreased”or“coveragedecreased”.For
someprojects(e.g., P38)weobservethatover75%ofthechanges
to coverage are because of new lines being added. This suggests
that most of the code changes are coming from new development.
However,forotherprojects(e.g., P02),weobservethattheyexpe-
rience many changes when coverage is lost or added to existing
lines.Thisseemstopointtohigherlevelsofnon-determinismin
that project’s tests, especiallywhen there are a similar number of
changes adding and losing coverage. Comparing to Figure 5,w e
observethat projectswith lines thatflip coverageoften ( P02,P07,
P25,P42,P46) also have significant numbers of coverage changes
driven by changes to existing code.
Finding: Many factors have an impact on coverage: newly
coveringexistingstatementsisnotalwaystheprimarydriver
to coverage change.
4 DISCUSSION
In this section we discuss our findings, presenting implications
forDevelopers, Tool Builders andResearchers and discuss several
limitations of our study.
4.1 Implications
Developers: Betweensubsequentrevisions,thereisoftenverylit-
tle observable change in overall project coverage, especially for
large projects. Because of this, developers use tools [ 1–3,6,7] that
examine patch coverage. However, while knowing if a patch is
coveredornotclearlyhasvalue,developersshould notusepatch
coverage as a stand-in metric to evaluate the impact of a patch
60
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. A Large-Scale Study of Test Coverage Evolution ASE ’18, September 3–7, 2018, Montpellier, France
P01P02P03P04P05P06P07P08P09P10P11P12P13P14P15P16P17P18P19P20P21P22P23P24P25P26P27P28P29P30P31P32P33P34P35P36P37P38P39P40P41P42P43P44P45P46P47
0 25 50 75 100
Deleted tested lines
Added new lines that are not coveredCoverage lost on existing linesAdded coverage to existing linesAdded new lines that are coveredDeleted untested lines
Figure 6: Overview of key factors driving change to coverage of each project during the entire development period measured.
Size of bar represents how much that factor contributed to the net change in coverage. Green factors increase coverage, reddecrease coverage.
on the overall project coverage. We found that patches often im-
pactthecoverageofexistingnon-patchcode,andimportantly,that
having high patch coverage does notcorrelate with increasing the
overallcoverageofaproject.Developersshouldadjusttheircode
review processes to consider not only the patch coverage, but also
itseffectonnon-patchcodecoverage.Moregenerally,developersshould considerusing more detailedmetrics than justthe ratio of
statements covered to measure their code’s testedness.
Developersshouldbeawarethatevenifthe numberoflinescov-
eredremainsrelativelystatic,thesetofcoveredlinescangreatly
vary betweenruns. Ifthere isconcernthat aparticular partof the
project is covered, developers need to specifically track that the
relevant lines in that part are covered, because we found that therecanbeasignificantchurninthesetoflinescovered.Wefoundthat
insome projects,individual statementsmight changetheir cover-
ageveryoften—perhaps everysinglebuild.Hence,developerswho
closely track coverage must be aware of inherent non-determinism
in coverage. If developers have a better understanding of how and
wheretheircoverageisnotdeterministic,theymaybebetterpre-
pared to address other impacts of this non-determinism, such as
flaky test failures.
Tool Builders We observed that many commits do not involve
changestocodefiles,yetthesechangescanstillchangethecoverageofexistingcode,afindingwithimplicationsfortoolbuilderswhose
tools rely on code coverage (for instance, regression test selection
tools).Toolbuildersmustbeawareofallinputs(e.g.configanddatafiles, as well as non-determinism) that can impact test execution —
not only the code itself.
Ourstudyalsohasimplicationsfortoolbuilderscreatingcode
coveragetools.Otherresearchers[ 22,29,39]havealsoidentified
non-deterministicbehaviorwhenstudyingtests.Webelievethat
toolbuildersshouldbuildtoolstohelpdevelopersidentifywhich
testsaredeterministic,andwhicharenot.Currently,thereisnoway
for developers to identify if their tests are covering code in a deter-
ministic or non-deterministic manner without rerunning tests and
comparingverylowlevelcoveragedata,orwaitingforatesttofailinanon-deterministicmanner,andhavingtotrackdownthesource
oftheproblem.Tohelpdevelopersidentifynon-deterministicbe-
havior, tools should show developers which lines have changesin coverage (even unchanged lines), and which of those changesare non-deterministic (or at least potentially non-deterministic).
This information would be a valuable tool for developers when
debugging flaky test failures [12].
We also found that there are various reasons why coverage can
increaseordecrease.Currenttoolsshowthechangeincoverage,but they do not show whythere was a change. If developers are
awareofhowtheircoverageischanging,andtheyarenotexpecting
ittochangebasedontheirlatestcommit,theycanthenevaluate
whether their tests are flaky, or if their latest change impacted
thesystemcoverageinwaysthattheywerenotexpecting.Either
way,havingthisinformationcanhelpdevelopersbetterunderstand
their system, and the state of their automated test coverage. Code
61
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Michael Hilton, Jonathan Bell, and Darko Marinov
coverage tools should fuse code change information with code
coverage information, as the Operias tool [32] also proposed.
Researchers Our study was the first to make use of the Cov-
eralls service [ 19] to gather code coverage data. Code coverage
dataisnotoriouslyhardtocollect,becauseolderprojectversions
are often hard to compile and run, and collecting coverage takes
machinetime.Fortunately,Coverallsbothcollectsandmakesavail-
able real data from many different types of projects. This data can
be invaluable for researchers who wish to better understand code
coverage. By leveraging this data, researchers can use coverage
datawithouthavingtocollectandrunhistoricalversionsofsoft-
ware,whichmaybeverydifficultduetomissingdependenciesand
other infrastucture-related problems. We expect that analysis of
data from Coveralls can lead to new insights similar to how analy-
ses of GitHub and TravisCI [ 13,16,33,37,38,42,44] data enabled
researchers to obtain new insights into software development.
4.2 Threats to Validity
1) Construct: Are we asking the right questions? To ensure we are
askingtherightquestions,webaseanumberofourquestionson
previous research. For our new research questions, we posed these
questions before looking into our data, based on our anecdotal
experiencefromourowndevelopmentnoticingthatcodecoverage
can vary greatly.
2) Internal: Did we skew the accuracy of our results with how we
collected and analyzed information? We chose projects that were
used in previous research, enhanced with a set of large projects
with diverse demographics collected from Coveralls. To provide
confidencethatwehavenotskewedtheresultsandallowforgreaterscrutiny,wehavemadeallofthescriptsthatwewroteandthedata
we collected available with this paper.
3)External:Doourresultsgeneralize? Tohaveourresultsgeneralize
as much as possible, we selected a large and diverse set of projects
invarious languages,andfrom varioustypes ofapplications.Our
datasetisalmostanorderofmagnitudelarger(bothintermsofthe
number of projects and the number of builds) than prior related
studies,whichisencouraging.Alloftheprojectsareopensource,so
wecannotmakeanyclaimsabouthowourresultsmightgeneralize
to proprietary projects.
4) Replicability: Can others replicate our results? To support oth-
ers in replicating our results, we have made our data and the R
scriptsthatweusedtoprocessourdatapubliclyavailable.These
canall befound ontheproject’s companionwebsite: http://www.
code-coverage.org
5 RELATED WORK
Previous Coverage Studies. We are not the first researchers to
studycodecoverageofsoftwareprograms.Elbaumetal.[ 21]study
two systems using different types of code coverage metrics. The
authorsfindthattheimpactofchangesoncoverageinformation
canbedifficulttopredict,butcallsforfurtherstudyoftheeffects
of software evolution on coverage information is needed.
Zaidman et al. [ 43] study three systems and observe changes to
coverage.Thepaperreportsthatthereareperiodswhenthetests
and code evolve together, but there also are periods of intense test-
ing. The paper also suggests future work should include analyzing
more and larger cases to better understand test coverage evolution.The most related work to ours is from Marinescu et al. [ 29].
Theauthorspresentbothatoolanddatasetofcodecoverage.To
evaluate the tool, the paper uses six C/C++ systems. The paper
answersnineresearchquestions,threeofwhicharerepeatedinthis
paper.Marinescuetal.’sworkwasalsothefirsttospecificallyfocus
onpatch coverage,although otherresearchers [ 32]havedeveloped
tools to help developers visualize patch coverage. In this paper, we
examinebothpatchcoverageandalsonon-patchcoverage,anduse
a significantly larger dataset.
Other Coverage Work. Coverage has often been used as a
metricwhenstudyingsomepropertyofasystem.Kochharetal.[ 26]
find that code coverage has an insignificant correlation with thenumber of bugs that are found after the release of software atthe project level. Mokus et al. [
31] find that test effort increases
exponentiallywithtestcoverage,butthereductioninfieldproblemsincreaseslinearlywithtestcoverage.Theysuggestthattheoptimal
level of coverage for most projects is likely to be well short of
100%. Ahmed et al. [ 9] study the relationship between statement
coverage and mutation score. They find that both metrics have
only a weak negative correlation with bug-fixes. Memon et al. [ 30]
describe the challenge when dealing with a codebase the size of
Google’s, and how it is not possible for them to collect coverage at
thatscale.Pintoetal.[ 34]haveusedcoveragetostudyhowtests
evolve over time. One category of test evolution they identify is
coverage augmentation tests. Gao et al. [ 22] investigate differences
betweenunittesting,systemtests,andinvariantdetection.They
find that when executing system tests, there is often significantnon-determinism in the lines that are executed by each test. Our
results confirm this finding also.
6 CONCLUSIONS
Statement coverage is often used by developers to evaluate thequality of their test suites. However, by reducing coverage to a
singleratio,muchvaluableinformationislost.Whenworkingwith
alargematureproject,onlyverylargechangestothenumberof
lines covered will be detectable as a change in the overall coverage,
so moderate changes to the test suite may not be observable. Even
on smaller projects, viewing coverage as a simple ratio hides po-
tentialnon-determinismthatexistsintestsandchangestowhich
statementsare covered.Of course,manyof thesechangesto non-
patch code may be due to the genuine impact of code changes
too; interesting future work may try to identify changes due to
non-determinism versus those due to code changes, perhaps using
dynamictainttracking[ 11].Inthispaper,wefoundthatmeasuring
the change in the setof statements covered, and the impact of a
patch on the coverage of those statements allows developers much
more visibility into the impact of their changes. We have released
ourtoolsanddatasothatotherscanbenefitfromthemandbuildon
our work to obtain new insights that eventually lead to improving
quality of testing.
ACKNOWLEDGMENTS
WethankHayderAlHaddadandOwolabiLegunsenfordiscussions
aboutthiswork.DarkoMarinov’sgroupissupportedbyNSFgrants
CCF-1409423, CCF-1421503,CNS-1646305, and CNS-1740916; and
gifts from Google and Qualcomm.
62
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. A Large-Scale Study of Test Coverage Evolution ASE ’18, September 3–7, 2018, Montpellier, France
REFERENCES
[1] 2018. coverage-diffe. https://docs.codecov.io/v4.3.6/docs/coverage-diff .
[2] 2018. diff-cover. https://github.com/Bachmann1234/diff-cover.
[3] 2018. diff-coverage. https://github.com/ptone/diff-coverage.
[4]2018. git-coverage. http://stef.thewalter.net/git-coverage-useful-code-coverage.
html.
[5] 2018. JaCoCo Java Code Coverage Library. http://www.eclemma.org/jacoco/.
[6] 2018. jest-diff-coverage. https://github.com/Hylozoic/jest-diff-coverage.
[7] 2018. Patch-Status. https://github.com/codecov/support/wiki/Patch-Status.
[8]2018. Undertow.io commit a945c17f58cd809558950d858030379179dfdf82.
https://github.com/undertow-io/undertow/commit/
a945c17f58cd809558950d858030379179dfdf82.
[9]IftekharAhmed,RahulGopinath,CaiusBrindescu,AlexGroce,andCarlosJensen.
2016. Can Testedness Be Effectively Measured?. In FSE.
[10]Paul Ammann and Jeff Offutt. 2008. Introduction to Software Testing (1 ed.).
Cambridge University Press, New York, NY, USA.
[11]Jonathan Bell and Gail Kaiser. 2014. Phosphor: Illuminating Dynamic Data Flow
in Commodity Jvms (OOPSLA).
[12]Jonathan Bell, Owolabi Legunsen, Michael Hilton, Lamyaa Eloussi, Tifany Yung,
and Darko Marinov. 2018. DeFlaker: Automatically Detecting Flaky Tests. In
ICSE.
[13]MoritzBeller,GeorgiosGousios,andAndyZaidman.2017. Oops,MyTestsBroke
the Build: An Explorative Analysis of Travis CI with GitHub. In MSR.
[14]MoritzBeller,GeorgiosGousios,andAndyZaidman.2017. TravisTorrent:Synthe-
sizing Travis CI and GitHub for Full-Stack Research on Continuous Integration.
InMSR.
[15]J. Chen, Y. Bai, D. Hao, L. Zhang, L. Zhang, and B. Xie. 2017. How Do Assertions
Impact Coverage-Based Test-Suite Reduction?. In ICST.
[16]Jürgen Cito, Gerald Schermann, John Erik Wittern, Philipp Leitner, Sali Zum-
beri,andHaraldC.Gall.2017. AnEmpiricalAnalysisoftheDockerContainer
Ecosystem on GitHub. In MSR.
[17] clover. [n. d.]. Clover. https://www.atlassian.com/software/clover.[18] cobertura. [n. d.]. Cobertura. http://cobertura.github.io/cobertura/.
[19] Coveralls. [n. d.]. Coveralls.io. https://coveralls.io/.
[20]
coverallsapi. [n. d.]. coveralls API. https://coveralls.zendesk.com/hc/en-us/
articles/201774865-API-Introduction.
[21]Sebastian Elbaum, David Gable, and Gregg Rothermel. 2001. The Impact of
Software Evolution on Code Coverage Information. In ICSM.
[22]Z.Gao,Y.Liang,M.B.Cohen,A.M.Memon,andZ.Wang.2015. MakingSystemUserInteractiveTestsRepeatable:WhenandWhatShouldWeControl?.In ICSE.
[23]Milos Gligoric, Lamyaa Eloussi,and Darko Marinov. 2015. Ekstazi: Lightweight
Test Selection. In ICSE-DEMO.
[24]MilosGligoric,LamyaaEloussi,andDarkoMarinov.2015. PracticalRegression
Test Selection with Dynamic File Dependencies. In ISSTA.
[25]MichaelHilton,TimothyTunnell,KaiHuang,DarkoMarinov,andDannyDig.
2016. Usage,costs,andbenefitsofcontinuousintegrationinopen-sourceprojects.
InASE.[26]P.S.Kochhar,D.Lo,J.Lawall,andN.Nagappan.2017. CodeCoverageandPostre-
leaseDefects:A Large-ScaleStudyonOpenSource Projects. IEEETransactions
on Reliability (2017).
[27]AdriaanLabuschagne,LauraInozemtseva,andReidHolmes.2017. Measuringthe
CostofRegressionTestinginPractice:AStudyofJavaProjectsUsingContinuous
Integration. In ESEC/FSE 2017.
[28]Qingzhou Luo, Farah Hariri, Lamyaa Eloussi, and Darko Marinov. 2014. An
Empirical Analysis of Flaky Tests. In FSE.
[29]Paul Marinescu, Petr Hosek, and Cristian Cadar. 2014. Covrig: A Framework for
the Analysis of Code,Test, and Coverage Evolution inReal Software. In ISSTA.
[30]AtifMemon,ZebaoGao,BaoNguyen,SanjeevDhanda,EricNickell,RobSiem-
borski, and John Micco. 2017. Taming Google-scale Continuous Testing. In
ICSE-SEIP ’17.
[31]A.Mockus,N.Nagappan,andT.T.Dinh-Trong.2009. Testcoverageandpost-
verification defects: A multiple case study. In 2009 3rd International Symposium
on Empirical Software Engineering and Measurement.
[32]SebastiaanOosterwaal,ArievanDeursen,RobertaCoelho,AnandAshokSawant,
andAlbertoBacchelli.2016. VisualizingCodeandCoverageChangesforCode
Review. In FSE.
[33]Klérisson V. R. Paixão, Crícia Z. Felício, Fernanda M. Delfim, and Marcelo de
A. Maia. 2017. On the Interplay Between Non-functional Requirements and
Builds on Continuous Integration. In MSR.
[34]Leandro Sales Pinto, Saurabh Sinha, and Alessandro Orso. 2012. Understanding
Myths and Realities of Test-suite Evolution. In FSE.
[35] Steven P. Reiss. 2008. Tracking Source Locations. In ICSE.
[36]August Shi, Tifany Yung, Alex Gyori, and Darko Marinov. 2015. Comparing and
Combining Test-suite Reduction and Regression Test Selection. In ESEC/FSE.
[37]Mauricio Soto, Zack Coker, and Claire Le Goues. 2017. Analyzing the Impact of
Social Attributes on Commit Integration Success. In MSR.
[38]Rodrigo Souza and Bruno Silva. 2017. Sentiment Analysis of Travis CI Builds. In
MSR.
[39]FriedrichSteimann,MarcusFrenkel,andRuiAbreu.2013. ThreatstotheValidity
and Value of Empirical Assessments of the Accuracy of Coverage-based Fault
Locators. In ISSTA.
[40] travis. [n. d.]. Travis-ci.com. https://travis-ci.org/.
[41]AsherTrockman,ShuruiZhou,ChristianKästner,andBogdanVasilescu.2018.
AddingSparkletoSocialCoding:AnEmpiricalStudyofRepositoryBadgesin
the npm Ecosystem. In ICSE.
[42]ZahyVolfandEdiShmueli.2017. ScreeningHeuristicsforProjectGatingSystems.
InESEC/FSE.
[43]AndyZaidman,BartRompaey,ArieDeursen,andSergeDemeyer.2011. Studying
the Co-evolution of Production and Test Code in Open Source and Industrial
Developer Test Processes Through Repository Mining. Empirical Softw. Eng.
(2011).
[44]Yangyang Zhao, Alexander Serebrenik, Yuming Zhou, Vladimir Filkov, and Bog-
danVasilescu.2017. TheImpactofContinuousIntegrationonOtherSoftware
Development Practices: A Large-scale Empirical Study. In ASE.
63
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. 