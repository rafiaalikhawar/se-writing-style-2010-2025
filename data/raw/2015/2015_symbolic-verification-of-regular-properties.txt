Symbolic Verification of Regular Properties
Hengbiao Yu1,2∗, Zhenbang Chen1∗,J iW a n g1,2∗, Zhendong Su3, Wei Dong1
1College of Computer, National University of Defense Technology, Changsha, China
2StateKeyLaboratoryofHighPerformanceComputing,NationalUniversityofDefenseTechnology,Changsha,China
3Department of Computer Science, University of California, Davis, USA
{hengbiaoyu,zbchen,wj}@nudt.edu.cn,su@cs.ucdavis.edu,wdong@nudt.edu.cn
ABSTRACT
Verifying the regular properties of programs has been a significant
challenge. This paper tackles this challenge by presenting symbolic
regularverification (SRV)thatoffers significantspeedups overthe
state-of-the-art.SRVisbasedondynamicsymbolicexecution(DSE)
and enabled by novel techniques for mitigating path explosion: (1)
a regular property-oriented path slicing algorithm, and (2) a syner-
gisticcombinationofproperty-orientedpathslicingandguiding.
Slicing prunes redundant paths, while guiding boosts the search
for counterexamples. We have implemented SRV for Java and eval-
uatediton15real-worldopen-sourceJavaprograms(totaling259K
lines of code). Our evaluation results demonstrate the effectiveness
andefficiencyofSRV.Comparedwiththestate-of-the-art—pure
DSE,pureguiding,andpurepathslicing—SRVachievesaverage
speedups of more than 8.4X, 8.6X, and 7X, respectively, making
symbolic regular property verification significantly more practical.
CCS CONCEPTS
•Software and its engineering →Software verification and
validation;
KEYWORDS
Regularproperty;Verification;DynamicSymbolicExecution;Slic-
ing; Guiding
ACM Reference Format:
Hengbiao Yu, Zhenbang Chen, Ji Wang, Zhendong Su, and Wei Dong. 2018.
Symbolic Verification of Regular Properties. In ICSE ’18: ICSE ’18: 40th
International Conference on Software Engineering , May 27-June 3, 2018,
Gothenburg,Sweden. ACM,NewYork,NY,USA,11pages.https://doi.org/
10.1145/3180155.3180227
1 INTRODUCTION
Regular properties are ones that can be specified by finite state ma-
chines(FSMs)[ 22].Theyarewidelyusedforpropertyspecification
insoftwareanalysisandverification( e.g.,model-basedtesting[ 36],
∗Zhenbang Chen and Ji Wang are the corresponding authors. Hengbiao Yu and Zhen-
bang Chen contributed equally to this work.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5638-1/18/05...$15.00
https://doi.org/10.1145/3180155.3180227typestateanalysis[ 21],modelchecking[ 14],andperformanceanal-
ysis[33]).However,scalableregularpropertyverificationisdiffi-
cult,andpracticalverificationofregularpropertiesofreal-world
programs is a significant software engineering research challenge.
Two main lines of research exist on regular property verifi-
cation:staticanddynamic verification. Static verification (such
as[17,20,21])soundlyabstractsprogramsforverification,which
usuallyhashighcodecoverage,butsuffersfromfalsealarms.Dy-
namic verification (such as [ 2,12]), in contrast, executes the pro-
gram and monitors program executions online. Hence, dynamic
verification ensures completeness, i.e., every discovered violation is
real. However, dynamic approaches only verify a program’s behav-
ior under specific inputs, thus may miss bugs.
Symbolicexecution[ 10,23,30]achievestrade-offsbetweenstatic
and dynamic verification by using symbolic values for program ex-
ecution. A key step in symbolic execution is to explore all possible
caseswhenencounteringabranchviaforkingstatesorre-executing
the program. Compared with static and dynamic approaches, sym-
bolic execution achieves better precision or coverage, respectively.
Ourgoalistodevelopapracticaltechniqueforsymbolicregular
propertyverification.Atthehigh-level,itworksasfollows.Fora
regular property φand program P,a nevent inφ’s FSM represents
theexecutionofoneormorestatementsof P.Forexample,amethod
invocationmayproduceanevent.Hence, w.r.t.φ,anexecutionpath
pofPgenerates anevent sequence, denotedas Seq(p).I fSeq(p)is
empty,pis anirrelevant path ; otherwise, pisrelevant. To verify
thatPsatisfiesφ, we adopt symbolic execution to explore P’s path
space. If there exists a path pthat violates φ,i.e.,Seq(p)is accepted
by the FSMof ¬φ(denoted by FSM ¬φ), a violationis found, and p
is acounterexample path. Otherwise, Psatisfiesφ.
However,symbolicexecutionishinderedbytheproblemof path
explosion —exponentialpathspace w.r.t.thenumberofbranches
in the program. Thus, how to steer symbolic execution to (1) com-
pletelyexplorethepathspaceand(2)findcounterexamples assoon
as possible is critical. This paper tackles these challenges and in-
troducesascalableverificationtechnique,called symbolicregular
verification (SRV),forregularpropertiesviadynamicsymbolicex-
ecution (DSE) [ 23,41]. SRV is inspired by two key observations.
First, there usually exist a large number of irrelevant paths in P
w.r.t.the regular property φ. Second, many of the relevant paths
inPare equivalent, i.e., the paths having identical event sequence
w.r.t.φ. Therefore, during DSE, it is desirable to (1) prune both
irrelevantand equivalent relevant paths,and (2)explore counterex-
amplepathsasearlyaspossible.Doingthesecanboostsymbolic
verification to find counterexamples and finish path exploration
more promptly.
Toverifyaregularproperty φforaprogram,the keyideaofSRV
isto(1)sliceapath w.r.t.relatedstatementsof φ,whichresultsin
8712018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:09 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Hengbiao Yu, Zhenbang Chen, Ji Wang, Zhendong Su, and Wei Dong
prunedpathsrelatedtotheslicedbranches,and(2)use ¬φtoguide
the selection of branches to explore for finding counterexample
paths early. The main technical novelty of SRV is the design of a
slicealgorithmandaverificationframework.Thealgorithmisareg-
ular property-oriented slicing algorithm based on path slicing [ 27].
Besides control and data dependencies, our algorithm also exploits
property-relatedprograminformationtoperformslicing.Theal-
gorithm can slice the branches along which no counterexample
pathexists;besides,thebranchesalongwhicheachcounterexample
path has an equivalent previously explored path can also be sliced.
The verification framework combines regular property-oriented
path slicing and the property-oriented guiding technique [ 49]i na
synergisticmanner,inwhichthecombinedtechniquescomplement
and also boost each other.
We have implemented SRV for Java utilizing a regular property
guidedsymbolicexecutionengine[ 47]andadynamicslicingtool
Javaslicer[ 15].SRVhasbeenextensivelyevaluatedon15real-world
open-sourceJavaprogramsusingregularpropertiesinvolvingbothsingleormultipleobjects.TheevaluationresultsdemonstrateSRV’s
effectiveness and efficiency for regular property verification.
This paper makes the following main contributions:
•Aproperty-orientedpathslicingalgorithmthatcanprunepaths
forverification w.r.t.regularproperties.Theexploredpathsus-
ingourslicingalgorithmistwoordersofmagnitudelessthan
that using path slicing [27][16].
•AmethodthatenhancesregularpropertyguidedDSE[ 49]for
supporting multi-object regular properties.
•A DSE-based framework that integrates slicing and guiding for
practical regular property verification.
•AprototypeimplementationforJavathatsignificantlyoutper-
formsthestate-of-the-art:(1)successfullyverified 30 outof39
verification tasks on a total of 259K lines of code within 1 hour,
whilepureDSE,guiding,andpathslicingverified22/22/23tasks,
respectively; and (2) on the 30 successfully verified tasks, of-
fered more than 8.4X/8.6X/7X average speedups over pure DSE,
guiding, and path slicing, respectively.
Therestofthispaperisorganizedasfollows.Section2motivates
and illustrates symbolic regular verification (SRV) via a concrete
example,andSection3presentsthedetailsofSRV.Section4explains
ourimplementationandempiricalevaluationofSRV.Finally,we
survey related work (Section 5) and conclude (Section 6).
2 ILLUSTRATING EXAMPLE
This section uses an example to motivate and illustrate our sym-
bolicregularpropertyverificationtechnique.Figure1showsaJava
program snippet that uses an Iterator to access an ArrayList .
Theinputparametersarean ArrayList arr andanintegervariable
m. First, we increase mb y1i fmis greater than 10. Then, we obtain
arr’s iterator, and assign it to iter. The following forloop (Lines
6-9) finds the maximum value of the first half of arr, and stores it
inmax. Next, maxwill be removed from arrif its value equals 100.
The following whileloop (Lines 12-16) iterates arrby using the
iterator iter.Duringtheiteration,weupdatethevalueof maxto
thevalueofanelementiftheelementisbiggerthan max.Finally,
the addition of mandmaxis returned.1public int test(ArrayList<Integer> arr, int m){
2 if(m > 10) //{q0}
3 m++; //{q0}
4 int max=0; //{q0}
5 Iterator iter=arr.iterator(); //{q1∼q4}
6 for(int i = 0; i < arr.size()/2; i++){ //{q1∼q4}
7 if(arr.get(i).intValue() > max) //{q1∼q4}
8 max = arr.get(i).intValue(); //{q1∼q4}
9 }//{q1∼q4}
10 if(max == 100) //{q1∼q4}
11 arr.remove(max); //{q3,q4}
12 while(iter.hasNext()){ //{q1,q3,q4}
13 int temp = iter.next(); //{q3,q4}
14 if(temp > max) //{q3,q4}
15 max = temp; //{q3,q4}
16 }//{q4}
17 return m+max; //{q4}
18}
Figure 1: An example program.
For the motivation program, we are interested in the correct
usageofacollection’s Iterator ,i.e.,thecollectioncannotbemod-
ified while being iterated and the iterator should invoke method
hasNextbeforenext. Note that such a safety property involves
two objects.The property can be specified as a regular property
φ, and FSM ¬φis shown in Figure 2, where aandirepresent an
ArrayList object and the corresponding iterator object, respec-
tively. For brevity, we use a.updateto represent adding an element
toaorremovinganelementfrom a.Eventa.iteratordenotesthe
accessingof a’siterator.Weuse i.hasNextandi.nexttorepresent
invoking the method hasNextandnext, respectively. Obviously,
when the first half of ArrayList has an element that equals 100, a
violationof φoccurs,i.e.,the ArrayList removesanelementwhile
being iterated. In this paper, we assume that every event is atomic,
i.e., no other events may be generated during its execution.
q0 start q1 q2
q3 q4a.iteratora.update
i.hasNext
a.update
i.nexti.hasNext
a.updatei.next
i.hasNext |a.updatei.next
i.hasNext |i.next|a.update
Figure 2: The FSM of iterator bug involving multi-objects.
When using pure DSE to verify the program w.r.t.φ, it requires
many iterations to unfold the two loops. In addition, the branch at
Line2 doublesthehugepath space.Symbolicregularverification
(SRV) aims to finish the path exploration and find counterexample
pathsassoonaspossible.Fortheexampleprogramandtheproperty
φ,SRV(1)needsonly twoiterations tofinishthepathexploration
and (2) finds the first counterexample path in the second iteration.
SRV procedure consists of two stages. At the first stage, the
program is statically analyzed w.r.t.FSM¬φthrough a backward
872
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:09 UTC from IEEE Xplore.  Restrictions apply. Symbolic Verification of Regular Properties ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
data flow analysis to calculate the future behavior information,
calledPostset, of every program location. A Postsetof a location
loccontains some states of FSM ¬φ, and each state qindicates
that there mayexist a subsequent path pafterlocandSeq(p)
can drive FSM ¬φfromqto an accepted state. The comment of
each line in Figure 1 shows the Postsetof the location afterthe
line. For brevity, we use {qj∼qk}to represent {ql|j≤l≤k}.
For example, after Line 10, there exists a subsequent path pthat
Seq(p)=/angbracketleftupdate,hasNext,next/angbracketright,whichcandrive q1totheaccepted
state. Hence, the Postsetof the location after Line 10 contains q1.
At the second stage, the program will be analyzed via DSE. Dur-
ingDSE,the Postsetinformationcalculatedearlierwillbeusedto
select the paths to explore. Because DSE also runs the programconcretely, we can use the available runtime information to cal-
culatecertainhistoryinformation,called Preset,ofabranchtobe
explored. Same as Postset, thePresetof a branch balso contains
some states of FSM ¬φ. A stateqinPresetindicates that qcan be
reached from the initial state via the path from the beginning of
the program to b. Based on the historyandfutureinformation, we
can (1) prune the redundant program paths, which include irrel-
evantpaths,non-counterexamplepathsandtheequivalentpaths
ofpreviouslyexploredpaths;and(2)evaluatethepossibilityofa
branch for generating a counterexample path.
Whenapath pisexploredbyDSE,property-orientedpathslicing
is employed on pto slice the branches w.r.t.φ. Slicing uses static
dependence analysis [ 27] and the historyandfutureinformation to
reasonaboutpossiblyacceptedeventsequencesalongabranch.Ifa
branchb’s intersection of the PresetandPostsetis empty, it means
nocounterexamplepathalong bexists.Besides,ifallthecounterex-
ample paths along bhave equivalent pathsexplored previously, it
is also no need to explore b. Under both of these conditions, bwill
bepruned,whichresultsinpruningallthepathsalong b.Onthe
otherhand,wealsousetheintersectionofthe PresetandPostsetto
calculate the heuristic value of b. If the size of the intersection is
larger,thepossibilityofhavingacounterexamplepathalong bis
considered higher. Hence, bwill be selected with a higher priority.
ConsidertheprograminFigure1andtheFSM ¬φinFigure2.To
analyzetheprogramviaDSE,thetwoinputparametersaremade
symbolic variables. We assume that the Arraylist arr has a fixed
lengthandcontainstwoelements arr[0]andarr[1].Supposetheini-
tialinputto testis/angbracketleftarr={1,2},m=3/angbracketright.Thefirstiterationgenerates
theeventsequence /angbracketleftiterator ,hasNext ,next,hasNext ,next,hasNext/angbracketright,and
is not a counterexample path. Figure 3 shows the execution treeafter the first iteration, where dashedstates are candidate states
toexplore.The PresetandPostsetofacandidatebranchareabove
and below the branch, respectively. For example, b3corresponds
to the true branch of Line 10, and b3’sPresetandPostsetare{q1}
and{q1,q2,q3,q4}, respectively. The prunedcandidate branches
aredashedandgrey, while the remaining are dottedandblack.
Theslicingofthefirstpathprunesbranches b1,b4,andb5,which
means the paths along these pruned branches are redundant for
verification.Branch b1canbeprunedaccordingtopathslicing[ 27].
The reason is that there is no events transitively data or control
dependon m,whichmeanschangingthevalueof mcannotgenerate
new event sequences. On the other hand, the reason for prun-ingb
4andb5is the intersection of PresetandPostsetis empty,s0
s1
s3
s5
s7
s9s2
s4
s6
s8
s10Pre:{q0}
Pre:{q1}
Pre:{q1}
Pre:{q1}
Pre:{q1}Post:{q0}
Post:{q1∼q4}
Post:{q1∼q4}
Post:{q3,q4}
Post:{q3,q4}m≤10
arr[0]>0
arr[0]/nequal100
arr[0]≤arr[0]
arr[1]>arr[0]b1
b2
b3
b4
b5
Figure 3: Execution tree after the first iteration.
whichimpliesnocounterexamplepathsalongthesebranchesex-
ist. Both of b2andb3have the same result of intersecting Preset
andPostset. In this situation, SRV will select the deeper branch,
i.e.,b3, to explore. The path condition for generating the next
input ism≤10∧arr[0]>0∧arr[0]==100. Through solving
the new path condition, we assume that the generated input is
/angbracketleftarr={100,2},m=3/angbracketright.Theseconditerationgeneratesanaccepted
eventsequence /angbracketleftiterator ,update,hasNext,next/angbracketright.Thus,thepathis
a counterexample path.
s0
s1
s3
s5
s7
s9s4
s6Pre:{q1}Pre:{q1}
Pre:{q1}
Post:{q1∼q4}m≤10
arr[0]>0
arr[0]/nequal100
arr[0]≤arr[0]
arr[1]>arr[0]arr[0]==100b2
Figure 4: Execution tree after the second iteration.
Figure 4 shows the execution tree after the second iteration. For
brevity,weomittheprunedcandidatebranchesandstatesgenerated
in the first iteration. Note that the second path terminates in theaccepted state
s6, because a runtime property violation happens.
Forbranch b2,withthehelpofour property-orientedslicing method,
we can infer that all possible event sequences along b2accepted by
FSM¬φareequivalenttotheoneexploredintheseconditeration,
i.e.,/angbracketleftiterator ,update,hasNext,next/angbracketright. Hence,b2can be pruned.
In total, SRV needs two iterations to explore the full path space
andfindsthecounterexamplepathintheseconditerationregardless
ofarr’s size. If we use depth-first search (DFS) or breadth-first
search (BFS), the exploration will get stuck due to unfolding thetwo loops, failing to quickly find the counterexample path. If we
usepurepathslicing[ 27],onlybranch b1canbepruned,andthe
exploration will also get stuck due to the two loops. If we use pure
regular property guiding [ 49], it will find the counterexample path
during the second iteration, but no path pruning happens, hence it
fails to complete the path exploration.
873
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:09 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Hengbiao Yu, Zhenbang Chen, Ji Wang, Zhendong Su, and Wei Dong
3 SRV: SYMBOLIC REGULAR VERIFICATION
ThissectionpresentsthetechnicaldetailsofSRV.Itfirstpresents
theoverallsynergicverificationframework,thenthetwocombined
techniques, and finally discusses SRV.
3.1 Synergic Verification Framework
SRV’skeyinsightistouseslicing w.r.t.φtopruneredundantpro-
grampaths,andtheguidingmethodin[ 49]tofindcounterexamples
earlier. More precisely, in addition to the synergy between slicing
and guiding, (1) SRV’s property-oriented slicing method can prune
additional paths through exploiting the guiding information, i.e.,
PresetandPostset, compared with path slicing [ 27]; and (2) SRV
enhancestheguidingmethod[ 49]withthesupportofmulti-object
regularproperties.SRVaimsfor fullverification,whichmeansex-
ploringtheprogram’swholepathspacetosuccessfullyverifythe
program or find all inequivalent violations of the property.
Algorithm 1: DSE-based Regular Property Verification
SRV(P,M¬φ,I0)
Data:programP, FSMM¬φand an initial input I0
1begin
2worklist,X←∅;PC←true;I←I0;
3 Postset←ComputeFutureInfo( P,M¬φ);
4whiletruedo
5 (PC,pathc,Preset)←runAndMonitor(I ,M¬φ);
6 ifaccept(M¬φ,Seq(pathc))then
7 X←X∪{ LSeq(pathc)};
8 Report a counterexample path;
9 Rs←Slice(P,pathc,M¬φ,Preset,Postset);
10 update(worklist ,Rs,PC);
11 ifworklist =∅∨Timeoutthen
12 exit;
13 PC←Select(worklist ,Preset,Postset);
14 I←Solve(PC);
Algorithm1showstheoverallframework ofSRV.Theinputto
SRVconsistsofaprogram P,anFSM M¬φforthenegationofthe
regular property φto be verified and an initial input I0toP. The
algorithm first computes the Postsetinformation of Pw.r.t. M¬φ
(Line3,cf.Section3.2)thatwillbeusedbyslicingandguidinglater.
Itusesaworklisttostorethebranchestobeexploredand Xtostore
the accepted event sequences. During each iteration, the algorithm
runsPandchecksthepropertyonthefly(Line5, cf.Section3.3).Be-
sidesthepathcondition PC,thecurrentpath pathcisalsocollected
along with DSE. At the same time, the Presetinformation is also
calculatedforeachbranchalong pathcw.r.t.M¬φ(cf.Section3.3).
Ifpathcis a counterexample path (Line 6), we add LSeq(pathc),
i.e., the generated event sequence with program location [37] in-
formation, to Xand report pathc. Once a path is terminated, the
property-orientedpathslicingalgorithm Slice(cf.Algorithm2)is
invoked to prune branches along the path ( Line 9). Then,updateis
invoked to save new branches to worklist and prune the branches
inworklistaccording to the slicing result. Based on the heuristic
value of each branch ( cf.Section 3.5), Selectselects a branch to
generate the path condition for the next iteration ( Line 13). Theinputsofthenextiterationcanbegeneratedbyinvokingabackend
SMTsolver(Line14).Thealgorithmrepeatsthisprocessuntilthe
worklist becomes empty or timeout (Lines 11&12).
3.2 Statically Compute Future Information
For slicing and guiding, we calculate the Postsetfor each static pro-
gramlocation.Weimprovethe Postsetcalculationmethodin[ 49]in
twodimensions:(1)extendingtheflowfunctionsinIFDStosupport
multi-object regular properties; and (2) enhancing the data facts
and flow functions in IFDS to record encountered event sequences
foraprogramlocation.Foreachlocation l,thePostsetcontainstwo
typesofinformation:(1)fromwhichstatestherestprogramafter
lcandrive M¬φtoanacceptedstate;and(2)thegeneratedevent
sequences after lthat can drive a state to an accepted state.
More precisely, we first construct the reversed FSM (denoted
by←−−−M¬φ)[22]o fM¬φ, which accepts the reversed ones of M¬φ’s
accepted paths. For example, Figure 5 shows←−−−M¬φof the FSM in
Figure 2, and←−−−M¬φaccepts/angbracketlefti.next,a.iterator/angbracketrightthat is the reverse
of/angbracketlefta.iterator,i.next/angbracketrightaccepted by the FSM in Figure 2. Observe
that one state of←−−−M¬φmay correspond to a set of states of M¬φ.
For example, Figure 5’s FSM has a state {q1,q3,q4}, to which there
existsatransitionfromstate {q4}.Thetransitionmeansthereexists
a transition from state q1to stateq4in the FSM in Figure 2.
{q4} start {q1,q3,q4} {q1∼q4}
{q3,q4} {q0}i.nexta.update|i.hasNext
a.update|i.next
i.hasNexta.iteratora.update|i.hasNext|i.next
a.iteratori.next
i.hasNexta.update
Figure 5: The reversed FSM of iterator bug.
To calculate the Postset, we update the data facts during explor-
ingtheprogramstatementsaccordingtothetransitionsin←−−−M¬φand
merge the data facts at merging points in the control flow graph.
TaketheprograminFigure1forexample,andthereexistsadata
fact((o1,o2),{q3,q4})before exploring the statement at Line 11,
whereo1ando2correspondtothe ArrayList objectand Iterator
object, respectively. According to the transitions in Figure 5, the
datafactbecomes ((o1,o2),{q1∼q4})afterexploring o1.remove.Ac-
tually,thedatafact ((o1,o2),{q3,q4})alsoexploresthefalsebranch
that has no effect on the fact, because no events can be encoun-
tered in the branch. Hence, there exist two data facts at Line 10
through merging the data facts from the true and false branches,
i.e.,((o1,o2),{q1∼q4})and((o1,o2),{q3,q4}).
To make the Postsetanalysis inter-procedural, we carry out a
dataflowanalysisontheprogram’sinter-proceduralcontrolflow
874
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:09 UTC from IEEE Xplore.  Restrictions apply. Symbolic Verification of Regular Properties ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
graph (ICFG) w.r.t.←−−−M¬φ. The data flow analysis is implemented by
employing the IFDS framework [40].
For a multi-object property φinvolving kobjects, a data flow
fact in IFDS is an element (Ta,qr,b,s)in the domain/uniontext.1
1≤n≤kOn×
S×B×E(denoted by D), whereOis the set of the identities of
staticobjects, i.e.,thestaticlocationsofobjectcreations[ 37],Sis
the state set of the reversedFSM←−−−M¬φof¬φ,Bis the set of the
basic blocks in the program, and Eis the set of event sequences.
Forexample,adatafact ((o1,o2),{q},b,s)ofaprogramlocation l
means that 1) from state qthe program after lcan drive M¬φto
anacceptedstate,2)theeventsequence scanbegeneratedby o1
ando2afterl,and3)scandrive M¬φtoanacceptedstatefrom q.
The relationship between an event and its corresponding object
can be obtained through checking whether the class or interface
of the event corresponds to the type of the object. For example,
thereexistsadatafact ((o1,o2),{q1∼q4},b,/angbracketleftupdate,hasNext,next/angbracketright)
inthePostsetofLine10intheexampleprograminFigure1,where
o1ando2represent the identity of the ArrayList andIterator
objects,and bisthecorrespondingbasicblockofLine10.Obviously,
/angbracketleftupdate,hasNext,next/angbracketrightcan drive state q1to the accepted state of
the FSM in Figure 2, and updateis related to the ArrayList object,
whilehasNextandnextare related to the Iterator object.
Two different typed static objects o1ando2arerelatedif their
types are specified by φ. Take the motivation program for example,
anIterator object is related with an ArrayList object according
tothepropertyspecificationinFigure2.Withoutlossofgenerality,
we assume φspecifies two objects for brevity. There are four kinds
offlowfunctionsin IFDS: call-to-start, exit-to-return, call-to-return
andnormalfunctions. The normal and exit-to-return functions do
not have any influence on calculating Postset, and both of them
areidentityfunctions.Ifamethodinvocationstatementdoesnot
produceanyevent,itscall-to-startfunctionistheidentityfunction;
otherwise,itisa killallfunction[ 40]thatkillsallthedatafacts.The
call-to-return functionfcr:D→Dis the main one that drives the
calculation of Postset.
For a method invocation statement obj.meth(...) , if the state-
ment does not produce an event, its fcris the identity function.
Otherwise,supposetheidentitysetof objisOs,theproducedevent
ise1that can make the transition from q1toq2in←−−−M¬φ, and the
block of the statement is bn, thenfcris the smallest function [ 29]
satisfying the following conditions, where s1◦s2represents the
concatenation of sequences s1ands2:
•For each d∈domain(fcr)anddis((o1),q1,b,s): (1) ifo1/nelementOs
and no element in Osis related to o1, thend∈ranдe(fcr); (2)
ifo1∈Os, then((o1),q2,bn,/angbracketlefte1/angbracketright◦s)∈ranдe(fcr); (3) if there
existso2∈Os,ando2isrelatedto o1,then((o1,o2),q2,bn,/angbracketlefte1/angbracketright◦
s)∈ranдe(fcr)and also d∈ranдe(fcr). On the other hand,
ifdis((o1,o2),q1,b,s)and{o1,o2}∩Osis not empty, then
((o1,o2),q2,bn,/angbracketlefte1/angbracketright◦s)∈ranдe(fcr). All possible cases of re-
lated objects are considered.
•Iftheinitialstateof←−−−M¬φcanmakeatransitionto qeviae1,then
for eacho∈Os, we have ((o),qe,bn,/angbracketlefte1/angbracketright) ∈ranдe(fcr).
•Ifobjpoints to multiple static objects, i.e.,|Os|>1, then we
havedomain(fcr)⊆range (fcr). We adopt weak update [ 1]t o
achieve an over-approximation.When calculating the fixed point in IFDS, the first three parts
(Ta,q,b)of a data fact constitute the keythat identifies the data
fact.Hence,consideringthenumbersofstates,staticobjects,and
basicblocksarefinite,theterminationofIFDSisguaranteed.Given
astaticlocation,theremayexistsmultipledatafactswithasame
key, and these facts have different event sequences. Each of the
sequences is a possibly produced event sequence after the location.
Forexample,inFigure1,the PostsetbelowLine10containsfour
data facts with a same key ((o1,o2),{q1∼q4},b)but having the fol-
lowingfoureventsequences: /angbracketleftU,H,N/angbracketright,/angbracketleftU,H,N,H/angbracketright,/angbracketleftU,H,N,H,N/angbracketright,
/angbracketleftU,H,N,H,N,H/angbracketright,where U,HandNdenoteupdate,hasNextand
next,respectively, o1ando2aretheidentitiesofthe ArrayList and
Iterator objects, and bis the basic block of Line 10.
Forthefutureinformationofabranch br(denotedby Postset(br))
whoselocationis l,itssoundnessmeansthatthe Postsetoflincludes
thedata factsofall thepossiblecasesthat canreach anaccepted
state after executing the remaining program after l. The following
theorem gives a sufficient condition that makes Postsetsound.
Theorem 3.1. Given a program Pand a regular property φ,i fφ
is only parametric with objects, and the related objects of φwhen
runningPare not data-dependent on the inputs, Postset is sound.
Proof.Postsetis computed by IFDS framework, and the flow
functions result in an over-approximation when the event informa-
tion is computed soundly. If there are some events of the property
inwhichtherequirementsofvaluesexist, e.g.,thereturnvalueofa
method invocation must be true, it is beyond the capability of our
staticdataflowanalysis.Becausetheproperty φisonlyparametric
with objects, and we use pointer-to analysis to get the information
ofstaticobjects,theeventinformationcomputedbyourstaticanal-
ysis is static object sensitive. Furthermore, the related objects of φ
whenrunning Pdonotdependontheinputs.Hence,wecanobtain
sound results of computing events, and thus Postsetis sound. /square
3.3 Compute History Information
Different from Postset,Presetis calculateddynamically. The Preset
of a location contains the states that are reached via the execution
from the program entry to the location. Similar to the guidingmethod [
49], we adopt runtime verification [ 31] to calculate the
Presetinformation.Notethatweenhancethecalculationmethod
to support multi-object properties.
Aruntimeobjectisa sensitiveobject ifthecorrespondingclass
orinterfaceisspecifiedbytheproperty φ,e.g.,thesensitiveobjects
ofthepropertygivenbyFigure2includethe ArrayList objectand
theIterator object.Wecreateamonitortomonitorthemethod
invocations ofevery sensitive object, andrecord the currentstate
of each monitored object. Note that for a multi-object property,the monitors of related objects will be merged according to the
property specification. Presetis a set of monitors. Formally, we use
(Is,q)torepresentamonitor,where Isisasetofobjectidentities,
andqis a state of the FSM M¬φ. If any object’s method invocation
results in an event of M¬φ, the monitor performs a state transition
w.r.t. M¬φto compute Preset, which we formalize as
(Is,q1)o.e1−−−→(Is,q2) (1)
whereo∈Is,andstate q1∈M¬φistransitedtostate q2byevente1
generated by the method invocation on the object identified by o.
875
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:09 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Hengbiao Yu, Zhenbang Chen, Ji Wang, Zhendong Su, and Wei Dong
Foramulti-objectproperty,amonitor’ssensitiveobjectsarenot
created simultaneously. Suppose sensitive object oproduces event
e1,i fois related to the objects in Isw.r.t.the property φando/nelementIs,
following rule is used, where e1makes a transition from q1toq2:
(Is,q1)o.e1−−−→(Is∪{o},q2) (2)
Taketheseconditerationofthemotivationprogram( cf.Figure 4)
forexample,andsuppose o1ando2representtheidentitiesofthe
ArrayList andIterator objects,respectively.Obviously,theen-
countered event sequence at Line 11 is /angbracketlefto1.iterator,o1.remove/angbracketright.A s
a result, according to the FSM in Figure 2, the Presetof location
line 11 is ((o1,o2),q3).
For a given branch br, the soundness of history information
means that Presetcontains all the reached states from the initial
state via the path from the beginning of the program to branch b.
Theorem 3.2. Givenaprogram Pandaregularproperty φ,ifthe
sensitiveobjectsof Parenotdata-dependentontheinputs, Presetis
sound.
Proof.Recall that we compute the history information along
with DSE, and Presetis calculated as the reached state set of the
otherbranchof br,denotedby ¬br,executedinthecurrentpath.
Supposethecorrespondingeventsequenceto ¬bris/angbracketleft/angbracketrightor/angbracketlefte0,...,ei/angbracketright,
wherei≥0. Because the sensitive objects do not depend on the
inputs, the event sequence of bris the same as that of ¬br. Hence,
Presetofbrcontainsthe same reachedstatesof ¬br,which implies
the soundness of Preset. /square
Astaticobjectisidentifiedbyitscreationlocation.Werelatea
runtimeobjectwithastaticobjectbytheircreationlocations.Given
thePresetandPostsetof a branch br, thereintersection, denoted by
Preset(br)/intersectionsqPostset(br),isdefinedasfollows,where St(Is)represents
thesetofthecreationlocationsoftheobjectsidentifiedby Is,S(Ta)
denotesthesetofallelementsintuple Ta,andM(X1,X2)denotes
X1⊆X2∨X2⊆X1.
{q|∃(Is,q)∈Preset ,(Ta,qr,b,s)∈Postset•M(St(Is),S(Ta))∧q∈qr}(3)
Take the candidate branch b3in the first iteration of the motiva-
tionprogram( cf.Figure3)forexample.Thereexistsadatafact, i.e.,
((o1,o2),{q1∼q4},b,/angbracketleftU,H,N/angbracketright), in thePostsetbelow Line 10, where
o1ando2correspond to the identities of the static ArrayList and
Iterator objects,respectively.Thecomputed PresetatLine10is
((o/prime
1,o/prime
2),q1),whereo/prime
1ando/prime
2representthe ArrayList objectand
Iterator object, respectively. Clearly, the set of the creation loca-
tions ofo/prime
1ando/prime
2is equal to (o1,o2). Besides, since q1∈{q1∼q4},
we haveq1in the intersection of PresetandPostset.
3.4 Regular Property-Oriented Path Slicing
We now describe the algorithm for regular property-oriented path
slicing, which is based on path slicing [ 27]. Specifically, our slicing
algorithm enhances path slicing through exploiting the guiding
information, i.e.,PresetandPostset, to prune additional branches.
Before elaborating the slicing algorithm, we first give the defini-
tion of the equivalence relation of event sequences. An FSM Mis a
triple(Σ,Q,q0,δ,F),where Σistheeventalphabet, Qisthestate
set,q0istheinitialstate, δ:Q×Σ→Qisthetransitionfunction,
andFisthesetofacceptedstates.Aneventsequence s=/angbracketlefte1,...,en/angbracketright
(n≥1) is accepted by Mif for each ei, where 1 ≤i≤n, there
existsqi∈Qsuch that (qi−1,ei,qi)∈δ, andqn∈F.W eu s eR(s)to denote the event sequence after removing any event ekinsthat
makes a self-circled transition, i.e.,(qk−1,ek,qk)∈δandqk−1is
equal toqk.
Definition3.1. GivenanFSM Mandtwoacceptedeventsequence
s1ands2ofM,s1ands2areequivalent (denoted by s1≡Ms2)i ff
R(s1)=R(s2).
For example, the sequences /angbracketleftiterator ,update,hasNext,next/angbracketrightand
/angbracketleftiterator ,update,hasNext,next,hasNext/angbracketrightare equivalent w.r.t.the
FSM in Figure 2.
Algorithm 2: Regular Property-Oriented Path Slicing
Slice(P,pathc,M¬φ,Preset,Postset)
Data:programP, a pathpathc, and FSM M¬φ
1begin
2i←tail(L(pathc));S←∅;
3whilei/nequalnulldo
4 ifi is a branch instruction then
5 ifPreset(¬i)/intersectionsqPostset (¬i)/nequal∅then
6 T←Concatenate(¬ i);
7 if∃s1∈T,∀s2∈X•¬ (s2≡ML¬φs1)then
8 ifanye∈Seq(pathc)depends on i
∨¬i can reach any new event
9 then
10 S←S∪{ i};
11 else
12 ifanye∈Seq(pathc)depends on i then
13 S←S∪{ i};
14 i←before(i);
15returnS;
Algorithm 2 gives our regular property-oriented path slicing.
Theinputtothe algorithmconsistsoftheprogram Punderverifi-
cation, the current path pathc, and the FSM M¬φcorresponding to
thenegationoftheregularpropertytobeverified.Thealgorithm
processestheinstructionsin pathcinabackwardmanner,where
L(pathc)denotes the instruction list of pathc. Finally, all the re-
maininginstructionsarestoredin Sandreturned.Thebranches
not inSare pruned.
Forabranchinstruction iinL(pathc),weuse¬itorepresent i’s
branchnotexploredin pathc.Todecidewhether icanbepruned,
we exploit PresetandPostsetin two ways. First, considering that
bothPreset(¬i)andPostset(¬i)aresound,theemptinessoftheirin-
tersectionimpliesthatthereexistsnopathalong ¬ithatcanviolate
theproperty.Hence,wecanslicebranch iifPreset(¬i)/intersectionsqPostset(¬i)
is empty (Lines 5). Second, we also prune branch iif all possi-
ble accepted event sequences of ¬ihave an equivalent accepted
event sequence explored before (Lines 6&7). The Concatenate op-
erationconcatenatestheeventsequencebefore ¬i(recordedduring
running)andthepossibleeventsequencesafter ¬i(calculatedin
Postset), and produces an acceptedevent sequence set T.I fe v e r y
sequence in Thas an equivalent sequence in X(cf.Algorithm 1),
whichmeansthatallthepossibleacceptedeventsequencesalong ¬i
havebeenexploredinanequivalentmanner, icanbesliced.Wealso
use the criteria in path slicing [ 27] to further slice the instructions
876
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:09 UTC from IEEE Xplore.  Restrictions apply. Symbolic Verification of Regular Properties ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
thatcannotaltertheeventsequenceofthecurrentpath pathc,i.e.,a
branch instruction ican be sliced if there is no event in Seq(pathc)
transitivelydata-orcontrol-dependsonitandnoneweventcan
be reached along the direction of ¬i(Lines 8-10), similar rules also
apply to the remaining types of instructions (Lines 12&13).
Path slicing [ 27] also slices a program execution path in a back-
ward manner. More precisely, it keeps track of a set of variables
(calledlive set) that determines the feasibility of the suffix of the
path’seventsequenceandthelatestremainedinstruction(called
step location ). A branch instruction iwill be remained if one of
the following three conditions is satisfied. (1) ¬ican bypass the
step location ;and(2)thereexistsapathinthedirectionof ¬ithat
can modify the sensitive variables in live set; and (3) there exists
apathinthedirectionof ¬ithatcanreachanewevent.Actually,
thefirsttwoconditionscorrespondtotransitivedataandcontrol
dependence, respectively. On the other hand, a normal instruction
will be remained if it can modify the variables in live set.
Concatenation. The insight of concatenation isto infer the pos-
sibleacceptedeventsequencesofabranch brbasedon Preset(br)
andPostset(br). For an element (Ta,qr,b,s)inPostset(br),w eu s e
Aes(br,q)to represent the set of statically calculated event se-
quencesthatcandrive qtoanacceptedstate,whichcanbederived
fromPostsetas follows, where Dcis the set of calculated data facts
during data flow analysis and Dc⊆D.
Aes(br,q)={si|(Ta,qr,b,si)∈Dc∧q∈qr}(4)
Then, we define Concatenate( br)as the following set
{s1◦s2|∃q∈Preset(br)/intersectionsqPostset (br)•s2∈Aes(br,q)}(5)
wheres1istheeventsequencebefore br.Anaturalwaytoobtain
theacceptedevent sequencesalong bristoconcatenate theevent
sequenceproducedbefore brandtheeventsequencesin Aes(br,q).
In principle, to ensure the soundness of slicing, both s1and
Aes(br,q)need to be context and flow sensitive [ 37]. In practice,
Aes(br,q)is flow-sensitive, but not context-sensitive. We check
the equivalence relation w.r.t.alocation sensitive variant of M¬φ,
denoted by ML¬φ. The intuition is that the reasons of the bugs
causedbythesamestatementunderdifferentcontextstendtobe
thesame. ML¬φcanbecomputedaccordingtotheprogram Pintwo
steps.First,wecollectallpossiblestaticlocationsforeveryevent
by an inter-procedural control flow analysis. Second, we replace
every transition with the transitions of location sensitive events.
Intheillustrationexample,aftertheseconditeration( cf.Figure4),
theacceptedsequence /angbracketleftiterator 5,update11,hasNext 12,next13/angbracketrightisadded
toX.ML¬φis the FSM after replace the event of each transition in
Figure2bytheeventwithlocationinformation.Then,accordingto
thePresetandPostsetofb2,Preset(b2)/intersectionsqPostset (b2)only contains
q1. Based on the example in Section 3.2 ,Aes(b2,q1)has four event
sequences. Besides, the sequence before b2is/angbracketleftiterator 5/angbracketright. Hence,
Concatenate( b2)containsfouracceptedeventsequences,eachof
which is equivalent to /angbracketleftiterator 5,update11,hasNext 12,next13/angbracketrightw.r.t.
ML¬φ. Therefore, b2is pruned.
3.5 Branch Selection
For a regular property φ, only the relevant paths with specific
event sequences can violate φ. It is desirable to evaluate a branch’s
probability of generating the accepted paths w.r.t.M¬φ. Then, afterslicing,thebranchwithahigherprobabilitywillbeselectedfirst,
in order to find counter-example paths earlier. Same as the regular
property guided DSE [ 49], we usethe size of Preset/intersectionsqPostsetas the
main heuristic value forevaluating a branch. When two branches
havethesamesizeof Preset/intersectionsqPostset,thedeeperonewillbeselected
for efficient exploration.
3.6 Discussions
In principle, slicing and guiding are the orthogonal techniques that
are synergistically combinedin SRV. Slicing prunes irrelevant and
equivalentrelevantpathsduringDSE,whileguidingboostsfinding
counterexamplepaths.Bothareimportantforboostingverification.
Since slicing is used when a path is completed, the effectiveness of
slicing is related to how fast completed paths are generated. For
example,ifthereexistveryshortpathsinaprogram,BFSmaybeagoodchoice.Ontheotherhand,guidingisinsensitivetothesearch
strategy. Without any knowledge of the shape of the path space,
we integrate these two techniques with the DFS strategy.
Inadditiontotheircompatibility,slicingcanboosttheefficiency
of property guiding. Finding accepted paths may be hindered byexploring relevant paths due to the imprecision of the guidingmethod. With the help of slicing, after one path is explored, theequivalent ones of the path can be pruned. Therefore, compared
with pure guiding, SRV tends to find counterexamples faster.
Since slicing performs static analysis, its overhead may be high,
e.g.,whenthepathislongandthecontrolflowgraphiscomplex.To
improve the performance, we perform slicing selectively based on
thehistoryresultsofslicing.Theintuitionisthelocalityofprogram
paths,i.e.,ifabranchcannotbepruned,ittendsnottobepruned
either along the nearby paths. If the branch of any constraint in
the current path is pruned at last time or first encountered, slicing
would be carried out. With the help of such a lightweight dynamic
prediction, we can reduce the effort of slicing, achieving a good
balance between path pruning and slicing overhead.
Theorems3.1&3.2givesufficientconditionsforthesoundness
ofPresetandPostset, respectively. Even though, there still exist a
largenumberofpropertiesandprogramssatisfyingsuchconditions,
e.g., the ones used in our experiment. However, considering our
approach for computing the event sequences in Postsetis not con-
text sensitive, SRV is not sound, i.e., SRV may miss bugs resulting
from different contexts but having same static location. We believe
SRVispractical,becausetherootcausesforthebugsofthesame
statement under different contexts tend to be the same.
4 IMPLEMENTATION AND EVALUATION
WehaverealizedaprototypeofSRVbasedonaregularproperty
guided DSE tool [ 47], which is implemented on the DSE engine
JPF-JDart [ 26] and WALA [ 24] static analysis platform. We have
developed aproperty-oriented path slicerfor Java bytecodebasedon Javaslicer [15], i.e., a dynamic slicing [45] tool.
We evaluate SRV along two dimensions:
•EffectivenessandefficiencyofSRV
.CanSRVeffectivelyver-
ifyregularpropertiesforreal-worldJavaprograms?Howeffi-
cientisSRVcomparedwithDFS,pureguidingandpureslicing?
•Synergybetweenslicingandguiding .Canslicingboostguid-
ing in finding counterexample paths? How significant is the
improvement?
877
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:09 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Hengbiao Yu, Zhenbang Chen, Ji Wang, Zhendong Su, and Wei Dong
4.1 Evaluation Setup
Table 1 lists the programs in our evaluation, which are all real-
worldopen-sourceJavaprograms,totaling259Klinesofcode(LOC).
Rhino-a andsoot-ccomefromtheAshesbenchmark1suite. Jlex
is a Java lexical analyzer. Bloatis from the DaCapo benchmark
suite [6].BMPDecoder is a decoder for BMP files. Ftpclient is
an FTP client. The six programs, pobs,jpat,jericho,nano-xml ,
htmlparser and xml, are parser programs. The remaining, i.e.,
fastjason, jepandudl, are library programs.
Table 1: Programs in the experiments
Program LOCBrief Description
rohino-a 19799Javascript interpreter
soot-c 32358Static analysis editor
jlex 4400Lexical analyzer
bloat 45357Java bytecode optimization
bmpdecoder 531BMP file decoder
ftpclient 2436FTP client in Java
pobs 5488Java parser objects
jpat 3254Java string parser
jericho 25657Jericho HTML Parser
nano-xml 3317Non-validating XML parser
htmlparser 21830HTML parser in Java
xml 5138XML parser in Java
fastjson 20223JSON library from alibaba
jep 42868Mathematics library
udl 26896UDL language library
Total 259642 15 open source programs
As Table 2 shows, we applied SRV to verify widely-used regular
properties,includingbothsingle-andmulti-objectones.Properties
withsuperscript ∗aremulti-objectones;theremainingaresingle
object properties. In addition, we also verify some user-defined
properties.Forexample,thepropertywedefinedfor htmlparser
requiresthattheinputstringisintheJSPformat, i.e.,“<%...%>”.
Table 2: Regular properties in the experiments
Property Meaning
Enumeration Call hasMoreElements before nextElement
IteratorCall hasNext before next
Do not update the collection while iterating∗
ReaderDo not read a closed stream
No read if dependent input stream closed∗
WriterDo not write a closed stream
No write if dependent output stream closed∗
Socket Do not use a closed socket
Sincemostoftheprogramsareviolationfree,tofurtherevaluate
our method, wemutate [ 28] the programs.First, we collect allthe
branchstatementsalongDSE,thenwerandomlyselectabranchto
automaticallyinjectanevent, e.g.,acloseoperationforthe Reader
property. We generate three mutants for each program, except for
those with user-definedproperties. Note that such injections may
not necessarily lead to real violations.
An evaluation task comprises a program and a property. A task
wasruninfourmodes:DFS( D),pureguiding(G),purepathslicing
(S) and SRV ( S/prime). Under each mode, the time limit is 1 hour. All the
experiments are carried out on the identical servers, each of which
has 256GB RAM and four 2.13GHz XEON CPUs with 32 cores.
1http://www.sable.mcgill.ca/ashes/4.2 Evaluation Results
Table 3 lists evaluation results. The first column gives the verifica-
tion tasks, including the names of the programs and the verified
properties, where a multi-object property has a superscript ∗. The
secondcolumn Typeindicateswhetherananalyzedprogramhas
been mutated or not, with Orepresents the original program, and
bugitheithmutant.Thecolumn TotalTime(s) liststimeconsumed
for each verification task in four modes, where to represents time-
out. In our evaluation, completing a verification means having
exploredallthepathspace.Thetimeforfindingthefirstcounterex-
ample is shown in the column First Violation Time(s) , where no
meansnocounterexamplepathandnarepresentsunknowndueto
timeout.
Table 3 shows that SRV completes 30 tasks in 39, while DFS
(D), pure guiding (G) and pure slicing (S) complete 22, 22 and 23
tasks,respectively.Comparedwiththesealternatives,SRVachieves
36%, 36% and 30% improvement, respectively. For the successfully
verified 30 tasks, SRV at least has an average 8.4X, 8.6X, and 7X
speedupsoverDFS,pureguidingandpureslicing,respectively.2We
inspected the programs that SRV fails to verify, i.e.,jlex,rhino-a,
htmlparser andudl,andfoundthatthoseprogramshavecomplex
andsensitivecontrolflow.Mostpathsofthoseprogramsarerele-
vant,andonlyafewpathsarecounterexamplepaths.Asaresult,
the overhead of static analysis used in slicing and guiding becomes
very high, and only a small part of path space can be pruned.
0 5 10 15 20 25 30 35 40 45 50 55 6001020304050D
G
S
S’
Figure 6: Completed tasks under a time threshold.
Figure 6 shows the relationship between the number of com-
pleted verification tasks and the time threshold. The X-axis varies
the time threshold from five minutes to one hour, while the Y-axis
is the number of completed verification tasks. SRV can complete
the most tasks under a given time threshold. In addition, all the
completed30tasksbySRVarecompletedwithin5minutes,demon-
strating SRV’s efficiency.
To show the effectiveness of property guiding, we also collect
the time for finding the first counterexample path. For the tasks in
which violations exist, pure guiding is the most efficient to find the
firstviolation.Duetotheoverheadofslicing,SRVisslowerthan
pureguidinginmosttasks,buthasthesameorderofmagnitude
intime.BothSRVandpureguidingachieveordersofmagnitude
2A timeout is counted as 1 hour.
878
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:09 UTC from IEEE Xplore.  Restrictions apply. Symbolic Verification of Regular Properties ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Table 3: Experiment results of analysis time (D: DFS, G: pure guiding, S: pure path slicing, S/prime: SRV)
Program
(Property)TypeTotal Time(s) First Violation Time(s)
D G S S/primeD G S S/prime
soot-c
(Writer)O28.43 374.23 95.14398.98 NO NO NO NO
bug1 28.59 354.26 101.32 413.83 18.41 343.72 85.01413.71
bug2 27.61 358.01 97.06 389.1 19.39 346.6 81.62389.09
bug3 26.71 369.87 104.37 469.51 15.12 358.99 83.77469.39
soot-c
(Writer∗)O27.2 177.91 91.86214.85 NO NO NO NO
bug4 29.82 187.74 97.91219.26 NO NO NO NO
bug5 27.9 187.41 98.15 218.9 15.71 176.27 79.4216.47
bug6 29.2 174.32 103206.73 NO NO NO NO
bloat (Iterator) O24.49 48.1 57.56 66.97 10.13 36.02 35.250.14
bloat
(Iterator∗)O27.1 71.75 54.23 90.54 NO NO NO NO
bug1 29.2 71.81 102.07 128.85 NO NO NO NO
bug2 25.85 70.02 60.74 92.19 25.85 70.02 42.86 92.19
bug3 26.63 72.05 64.57 96.88 26.63 70.95 40.11 78.92
bmpdecoder
(Reader)O8.65 16.97 21.71 16.71 NO NO NO NO
bug1 9.18 17.45 19.79 22.04 NO NO NO NO
bug2 9.15 17.92 21.01 187.93 12.54 20.48 17.96
bug3 9.26 17.88 20.97 23.26 NO NO NO NO
ftpclient
(Socket)O12.44 37.08 37.83 49.78 NO NO NO NO
bug1 14.12 41.48 42.12 55.1 9.19 36.44 38.89 54.55
bug2 13.57 37.66 37.47 50.55 11.73 33.96 37.250.55
bug3 15.52 40.45 40.29 53.39 NO NO NO NO
jlex
(Reader)OTO TO TO29.48 NA NA NA NO
bug1 TO TO TO TO12.75 23.35 400.71 63.97
bug2 TO TO TO TO NA 14.58 NA27.04
bug3 TO TO TO TO NA NA NA NA
jlex
(Reader∗)OTO TO TO29.81 NA NA NA NO
bug4 TO TO TO TO NA 20.07 NA52.24
bug5 TO TO TO TO217.56 38.18 NA109.39
bug6 TO TO TO TO51.33 146.88 NA NA
rhino-a (Enumeration) OTO TO TO TO NA NA NA NA
jpat (UserDefined) OTO TO TO46.94 NA 23.36 NA43.99
nano-xml (UserDefined) OTO TO TO19.18 NA 14.02 NA19.16
pobs (UserDefined) OTO TO21.44 26.31 NA 14.96 20.79 23.07
jericho (UserDefined) OTO TO 53.727.66 NA 19.6 53.33 27.66
fastjason (UserDefined) OTO TO TO102.6 NA NA NA102.52
jep (UserDefined) O2590.38 1090.05 TO167.87 1439.06 29.72 NA167.84
htmlparser (UserDefined) OTO TO TO TO27.62 50.95 NA106.03
udl (UserDefined) OTO TO TO TO NA2829.57 NA NA
xmlparser (UserDefined) OTO TO TO24.89 NA 18.25 NA24.89
speedupsoverDFSandpurepathslicinginfindingthefirstcoun-
terexamples.Whenaviolationisverydeepandtherepossiblyexist
a large number of relevant paths, it cannot be detected without
slicing. For example, for fastjason , pure guiding fails to detect
aviolationwithinonehour,whileSRVneedsonly102.6seconds.
Withinonehour,guidingandSRVcanfindacounterexamplefor
23and22programsrespectively,whileDFSandpurepathslicing
can only find 15 and 13, indicating the effectiveness and efficiency
of guiding.
Pruningbrancheswithpositiveheuristicvaluescanboostfinding
counterexamples. For the 24 tasks with counterexamples found,
slicing can boost guiding by reducing the number of iterations
forfindingthefirstcounterexamplein7(29%)tasks.Notably,for
fastjason , SRV needs only 5 iterations, but all the other modes
failtodetectaviolationafterthousandsofiterations.Toinspecttheboosting of slicing to guiding further,we collect the information of
the pruned branches with positive heuristic values.
Figure7showstheimprovementbysynthesizingtheresultsof
allthetasks,wherethe X-axisisthepathorderforthefirst2000
paths, and the Y-axis is the number of the pruned branches with a
positiveheuristic valueforguiding. Asshownin thefigure,much
oftheboostinghappensduringtheearlystage, i.e.,inthefirst1500
paths, which indicates the necessity of selective slicing.
In addition, we collect the information about iterations, and the
resultsshowthatSRVusesthefewestiterationstocompletepath
exploration. Specifically, the iterations using our slicing algorithm
is two orders of magnitude less than that using path slicing [ 27].
Furthermore,weadjustthetimethresholdto24hoursforthefailed
tasks, and found that all the tasks were still failed to be verified,
except that program jepcan be verified in pure slicing mode.
879
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:09 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Hengbiao Yu, Zhenbang Chen, Ji Wang, Zhendong Su, and Wei Dong
 0 50 100 150 200 250 300
 0  500  1000  1500  2000Number of Pruned Branches
Path Order
Figure 7: Branch pruning of each path.
Threats to Validity. Threats to the validity of our results are
mainlyexternal.Theprogramsarerepresentativebecause(1)the
programs are of various types, such as parser and network ma-
nipulation; (2) the programs are of different sizes, i.e., from 0.5K
to 45K LOC, and 259K in total; and (3) they are commonly used
for evaluating Java program analyses [7, 21, 49]. Furthermore, the
verified regular properties are mainly common contracts [ 18]o f
Java programs. User-defined properties have practical meanings
w.r.t.functionalities. Although SRV is implemented and evaluated
forJava,itisgeneralandcanbeappliedtoprogramsinotherlan-
guages, such as C and C++. Finally, we set the time threshold to be
1hour,whichisfairlyenoughforaverificationtask.Increasingthe
timethresholdto24hoursonlyresultsinonemorecompletedtask.
5 RELATED WORK
TheclosestrelatedworktoSRVisregularpropertyguidedDSE[ 49]
and Woodpecker [ 16]. Different from the objective of [ 49],i.e.,
finding an accepted path as soon as possible, SRV aims to quickly
completethe pathexplorationof theprogram byemployingslic-ing to prune redundant paths, and the slicing can also reducethe iterations for finding counterexample paths. Compared with
Woodpecker [16], which uses path slicing [ 27] to prune redun-
dant paths for verifying system rules via symbolic execution, as
demonstratedbytheevaluationresults( cf.Section4.2),SRVismore
scalable because it can prune more paths and find violations faster.
Meta Compilation (MC) [ 19,20] is a scalable static approach
todetectingviolationsofpropertiesspecifiedbyastatemachinelanguage. MC is neither sound nor complete. ESP [
17] is a path-
sensitivestaticverifierforregular properties.ESPachievesstrong
scalability by merging symbolic states. However, ESP may produce
false alarms due to imprecise modeling of program statements.In[
21],astagedstatictypestateproperty[ 43]verificationframe-
work is proposed based on a parametric abstract domain. The false
alarmscanbeeliminatedgraduallybythestagedanalysis.Clara[ 7]
employs forward and backward data flow analysis to remove in-
strumentationsforruntimemonitoringoftypestateproperties.Our
guidingmethod makesthe backwardanalysis ofClarato beinter-
proceduralforcalculating Postset.Comparedwithstaticapproaches,
SRV enjoys completeness by trading scalability because it executes
the program under verification.
Dynamic methods are mainly from runtime verification [ 31].
Thebasicprocedureistogenerateamonitorforverificationfromaproperty, and the monitor is usually implemented via instrumenta-
tions to the program. The verification takes place at runtime based
on the information collected by instrumentations. Hence, dynamicapproaches verify a single program path. JavaMOP [
12] and Trace-
matches[ 2]arerepresentativetoolsforruntimeverificationofJava
programs. The calculation of Presetuses the idea of monitoring
inruntimeverification,andthemonitoringisimplementedatthe
virtualmachinelevel.Comparedwithdynamicapproaches,SRVem-
ploys DSE to explore the path space of the program systematically,
which improves code coverage and finds more bugs.
Software model checking has also been used for regular prop-
erty verification. SLAM [ 4] uses predicate abstraction [ 5] to obtain
an abstract model of a program. Then, at the model level, SLAMuses model checking to verify regular properties. When a coun-
terexample is found by model checking, it is reported when it is
a real violation; otherwise, the counterexample is used to refine
the abstract model. YOGI [ 38] improves SLAM by integrating DSE
to speed up mo del refinement and finding real counterexamples.
Compared with these approaches, SRV is lightweight and scalable
because it adopts efficient static analysis to boost verification.
Furthermore,guidingandpruningarecommonlyinvestigated
for improving the scalability of symbolic execution. For guiding
symbolic execution, different methods are proposed w.r.t.different
goals, including improving code coverage [ 9,10,32,42,44,46],
reachingaprogramlocation[ 3,11,34,48],targetingthedifferences
between two program versions [ 35,39], aiming at the unverified
path space [ 13], and generating a path satisfying a regular prop-
erty[49].Ontheotherhand,pruningpathspaceisalsoaneffective
methodtomitigatepathexplosion.Sameasguiding,theexisting
work on pruning also differs in their perspectives to decide redun-
dance, such as read-write information [ 8], assertion violation [ 25],
and rule violation [16]. SRV extends the existing work by the syn-ergy of guiding and pruning for verifying regular properties.
6 CONCLUSION
This paper presents symbolic regular verification, a practical DSE-
based technique for verifying regular properties. To improve scala-
bility, we introduce a synergistic combination of property-oriented
path slicing and guiding. SRV’s property-oriented path slicing
prunes redundant paths, while guiding helps finding counterexam-
plesquickly.Thetwocombinedtechniquesnotonlycomplement,
butalsostrengtheneachother.Wehavedevelopedaprototypeof
SRV for Java and evaluated it on real-world programs w.r.t.widely-
usedregularproperties.Ourextensiveevaluationdemonstratesthat
SRV is effective and efficient, and outperforms the state-of-the-art
significantly for regular property verification. Interesting future
workincludes(1)techniquestofurtherreduceslicingoverheadand
(2)furtherimprovementstoourtool’susability andfeasibilityfor
releasing to and benefiting the community.
ACKNOWLEDGEMENT
This research was supported by National Key R&D Program of
China (No. 2017YFB1001802) and NSFC Program (No. 61472440,
61632015,61690203,and 61532007).ZhendongSuwassupportedinpartbytheUnitedStatesNationalScienceFoundation(NSF)Grants
1528133 and 1618158, and by a Google Faculty Research Award.
880
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:09 UTC from IEEE Xplore.  Restrictions apply. Symbolic Verification of Regular Properties ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
REFERENCES
[1]A. V. Aho, R. Sethi, and J. D. Ullman. Compilers: Principles, Techniques, and Tools .
Addison-Wesley, 1986.
[2]C. Allan, P. Avgustinov, A. S. Christensen, L. J. Hendren, S. Kuzins, O. Lhoták,
O.deMoor,D.Sereni,G.Sittampalam,andJ.Tibble. Addingtracematchingwith
free variables to AspectJ. In OOPSLA, pages 345–364, 2005.
[3]D. Babić, L. Martignoni, S. McCamant, and D. Song. Statically-directed dynamic
automated test generation. In ISSTA, pages 12–22. ACM, 2011.
[4]T.BallandS.K.Rajamani. TheSLAMproject:debuggingsystemsoftwarevia
static analysis. In POPL, pages 1–3, 2002.
[5]T. Ball, R. Majumdar, T. Millstein, and S. K. Rajamani. Automatic predicate
abstraction of C programs. In PLDI, pages 203–213, 2001.
[6]S.M.Blackburn,R.Garner,C.Hoffmann,A.M.Khang,K.S.McKinley,R.Bentzur,
A. Diwan, D. Feinberg, D. Frampton, S. Z. Guyer, et al. The DaCapo benchmarks:
Java benchmarking development and analysis. In OOPSLA, pages 169–190, 2006.
[7]E. Bodden. Efficient hybrid typestate analysis by determining continuation-
equivalent states. In ICSE, pages 5–14, 2010.
[8]P. Boonstoppel, C. Cadar, and D. Engler. RWset: Attacking path explosion in
constraint-based test generation. In TACAS, pages 351–366, 2008.
[9]J.BurnimandK.Sen. Heuristicsforscalabledynamictestgeneration. In ASE,
pages 443–446, 2008.
[10]C. Cadar, D. Dunbar, and D. Engler. KLEE: Unassisted and automatic generation
ofhigh-coveragetestsforcomplexsystemsprograms. In OSDI,pages209–224,
2008.
[11]S. Chandra, S. J. Fink, and M. Sridharan. Snugglebug: a powerful approach to
weakest preconditions. In PLDI, pages 363–374, 2009.
[12]F.ChenandG.Rosu. MOP:anefficientandgenericruntimeverificationframe-
work. In OOPSLA, pages 569–588, 2007.
[13]M. Christakis, P. Müller, and V. Wüstholz. Guiding dynamic symbolic execution
toward unverified program executions. In ICSE, pages 144–155, 2016.
[14] E. M. Clarke, O. Grumberg, and D. Peled. Model checking. MIT press, 1999.
[15]Clemens Hammacher, Martin Burger, and Valentin Dallmeier. JavaSlicer. https:
//www.st.cs.uni-saarland.de/javaslicer/, 2008.
[16]H. Cui, G. Hu, J. Wu, and J. Yang. Verifying systems rules using rule-directed
symbolic execution. In ASPLOS, pages 329–342, 2013.
[17]M. Das, S. Lerner, and M. Seigle. ESP: path-sensitive program verification in
polynomial time. In PLDI, pages 57–68, 2002.
[18]M.B.Dwyer,G.S.Avrunin,andJ.C.Corbett. Patternsinpropertyspecifications
for finite-state verification. In ICSE, pages 411–420, 1999.
[19]D.Engler,D.Y.Chen,S.Hallem,A.Chou,andB.Chelf. Bugsasdeviantbehavior:
Ageneral approachto inferringerrors insystems code. In SOSP,pages 57–72,
2001.
[20]D. R. Engler, B. Chelf, A. Chou, and S. Hallem. Checking system rules using
system-specific, programmer-written compiler extensions. In OSDI, pages 1–16,
2000.
[21]S. J. Fink, E. Yahav, N. Dor, G. Ramalingam, and E. Geay. Effective typestate
verification in the presence of aliasing. In ISSTA, pages 133–144, 2006.
[22] A. Gill et al. Introduction to the theory of finite-state machines. 1962.
[23]P.Godefroid,N.Klarlund,andK.Sen. DART:directedautomatedrandomtesting.
InPLDI, pages 213–223, 2005.[24] IBM. T.J. Watson Libraries for Analysis (WALA). http://wala.sf.net/.[25]
J.Jaffar,V.Murali,andJ.A.Navas. Boostingconcolictestingviainterpolation.
InFSE, pages 48–58, 2013.
[26]K.Jayaraman,D.Harvison,V.Ganesh,andA.Kiezun. jFuzz:Aconcolicwhitebox
fuzzer for Java. In NASA Formal Methods, pages 121–125, 2009.
[27] R. Jhala and R. Majumdar. Path slicing. In PLDI, pages 38–47, 2005.
[28]R. Just, D. Jalali, L. Inozemtseva, M. D. Ernst, R. Holmes, and G. Fraser. Aremutants a valid substitute for real faults in software testing? In FSE, pages
654–665, 2014.
[29]U. P. Khedker, A. Sanyal, and B. Sathe. Data Flow Analysis - Theory and Practice.
CRC Press, 2009.
[30]J.King. Symbolicexecutionandprogramtesting. CommunicationsoftheACM,
19(7):385–394, 1976.
[31]M. Leucker and C. Schallhart. A brief account of runtime verification. J. Log.
Algebr. Program., 78(5):293–303, 2009.
[32]Y.Li,Z.Su,L.Wang,andX.Li. Steeringsymbolicexecutiontolesstraveledpaths.
InOOPSLA, pages 19–32, 2013.
[33]Y. Liu, C. Xu, and S.-C. Cheung. Characterizing and detecting performance bugs
for smartphone applications. In ICSE, pages 1013–1024, 2014.
[34]K.-K.Ma,K.Y.Phang,J.S.Foster,andM.Hicks. Directedsymbolicexecution. In
SAS, pages 95–111, 2011.
[35]P.D. MarinescuandC.Cadar. maketest-zesti:A symbolicexecutionsolution for
improving regression testing. In ICSE, pages 716–726, 2012.
[36]G. J. Myers, C. Sandler, and T. Badgett. The art of software testing. John Wiley &
Sons, 2011.
[37]F.Nielson,H.R.Nielson,andC.Hankin. PrinciplesofProgramAnalysis. Springer,
2015.
[38]A.V.Nori,S.K.Rajamani,S.Tetali,andA.V.Thakur. TheYOGIproject:Softwarepropertycheckingviastaticanalysisandtesting. In TACAS,pages178–181,2009.
[39]S.Person,G.Yang,N.Rungta,andS.Khurshid. Directedincrementalsymbolic
execution. In PLDI, pages 504–515, 2011.
[40]T. Reps, S. Horwitz, and M. Sagiv. Precise interprocedural dataflow analysis via
graph reachability. In POPL, pages 49–61, 1995.
[41]K. Sen, D. Marinov, and G. Agha. CUTE: a concolic unit testing engine for C. In
FSE, pages 263–272, 2005.
[42]H.SeoandS.Kim. Howwegetthere:acontext-guidedsearchstrategyinconcolic
testing. In FSE, pages 413–424, 2014.
[43]R. E. Strom and S. Yemini. Typestate: A programming language concept for
enhancing software reliability. IEEE TSE, (1):157–171, 1986.
[44]N.TillmannandJ.DeHalleux. Pex–whiteboxtestgenerationfor.NET. In TAP,
pages 134–153, 2008.
[45]F.Tip.Asurveyofprogramslicingtechniques. JournalofProgrammingLanguages,
1995.
[46]T.Xie,N.Tillmann,J.deHalleux,andW.Schulte. Fitness-guidedpathexploration
in dynamic symbolic execution. In DSN, pages 359–368, 2009.
[47]H.Yu,Z.Chen,Y.Zhang,J.Wang,andW.Dong. RGSE:aregularpropertyguided
symbolic executor for java. In FSE, pages 954–958, 2017.
[48]C.ZamfirandG.Candea. Executionsynthesis:atechniqueforautomatedsoft-
ware debugging. In EuroSys, pages 321–334, 2010.
[49]Y. Zhang, Z. Chen, J. Wang, W. Dong, and Z. Liu. Regular property guided
dynamic symbolic execution. In ICSE, pages 643–653, 2015.
881
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:09 UTC from IEEE Xplore.  Restrictions apply. 