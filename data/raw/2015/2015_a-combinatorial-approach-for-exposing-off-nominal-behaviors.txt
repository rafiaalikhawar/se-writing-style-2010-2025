A Combinatorial Approach for Exposing Off-Nominal Behaviors
Kaushik Madala
University of North Texas
Denton, Texas
kaushikmadala@my.unt.eduHyunsook Do
University of North Texas
Denton, Texas
hyunsook.do@unt.eduDaniel Aceituna
DISTek Integration, Inc.
Daniel.Aceituna@distek.com
ABSTRACT
Off-nominalbehaviors(ONBs)havebeenamajorconcerninthe
areas of embedded systems and safety-critical systems. To address
ONBproblems,someresearchershaveproposedmodel-basedap-
proaches that can expose ONBs by analyzing natural language
requirementsdocuments.Whiletheseapproachesproducedpromis-
ingresults,theyrequirealotofhumaneffortandtime.Inthispaper,toreducehumaneffortandtime,weproposeacombinatorial–based
approach, Combinatorial Causal Component Model (Combi-CCM),
whichusesstructuredrequirementspatternsandcombinationsgen-
eratedusingtheIPOGalgorithm.Weconductedanempiricalstudy
using several requirements documents to evaluate our approach,and our results indicate that the proposed approach can reduce
human effort and time while maintaining the same ONB exposure
ability obtained by the control techniques.
CCS CONCEPTS
•Computer systems organization →Embedded and cyber-
physicalsystems ;•Softwareanditsengineering →Require-
ments analysis;
KEYWORDS
Off-Nominal Behaviors, Requirements Verification, Combinatorial
Approach, Model-based Approach
ACM Reference Format:
KaushikMadala,HyunsookDo,andDanielAceituna.2018.ACombinatorial
ApproachforExposingOff-NominalBehaviors.In ProceedingsofICSE’18:
40th International Conference on Software Engineering , Gothenburg, Sweden,
May 27-June 3, 2018 (ICSE ’18), 11 pages.
https://doi.org/10.1145/3180155.3180204
1 INTRODUCTION
Off-nominalbehaviors(ONBs)areunexpectedorunintendedbehav-iorsofasystem[
1,7,12].ONBscanoccurforvariousreasonssuch
as human errors caused by not following the intended procedures,
components of a system being in conflicting states of operation,
andenvironmentalconditionsresultinginsuchconflictingstates.
ONBs have been a major concern in the areas of embedded sys-tems [
1], medical devices, autonomous robotic systems [ 43], and
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5638-1/18/05...$15.00
https://doi.org/10.1145/3180155.3180204safety-critical systems [ 2] because not addressing ONBs in these
application domains might result in hazardous accidents and even
catastrohpic results [ 29]. Unlike expected or nominal behaviors,
ONBs requires knowledge acquisition of missing requirements and
they are usually not specified in natural language (NL) require-
ments [12].
Some researchers have tried to address ONB problems [ 7,16,19,
44].Forexample,Jensenetal.[ 19]proposedamodel-drivendesign
that uses the concept of safety functions to handle ONBs, and a
studybyVermaetal.[ 44]utilizesoff-nominalbehaviortestcasesfor
airplane runway operations to expose possible ONBs. Iverson [ 16]
proposedasimulation–basedapproachthatcreatesaknowledge
basebygroupingrelatedbehaviorsinnominaldatasetsthatcontain
theacceptablebehaviorsofthesystem.Thecreatedknowledgebase
is used to identify ONBs by collecting behaviors that diverge from
the acceptable behaviors. Despite the progress this research has
achieved, there are some limitations with the existing approaches.
MostONBproblemshavefocusedonhowahumanoperatorreacts
to off-nominal situations within the operating environment rather
than from the system’s perspective. Also, ONB problems are often
addressed only after the system has been implemented, whose
solutionmayinvolvesubstantialredesigning,andadditionalcost,
because it is applied late in the development cycle.
Someworkhasbeendoneatrequirementsleveltoaddressthese
limitations. Causal Component Model (CCM) [ 1] and Enhanced
CausalComponentModel(ECCM)[ 33]wereproposedtoexpose
ONBs in NL requirements by converting the requirements into sys-
tem state transition rules and parsing them to find user-identified
undesired states that result in ONBs. However, CCM and ECCM
havesomedrawbacks.BothapproachesinvolveNLrequirements
to be converted into transition rules. Because common NL require-
ments often contain ambiguities [ 3], directly generating rules from
requirements can be an error-prone process and tracing back from
rules to NL requirements requires a lot of time and effort. Both
models, CCM and ECCM, suffer from these problems.
Toreducehumanerroraswellastoreducethenumberofstates
thatneedtobemanuallyanalyzedtoexposeONBs,inthispaper,we
propose a Combinatorial-Causal Component Model (Combi-CCM),
a component-driven model. Unlike CCM and ECCM, Combi-CCM
does not require writing rules from common natural language
requirements,butitrequiresuserstowriterequirementsbyfollow-
ingamodifiedversionofEasyApproachtoRequirementsSyntax
(EARS) requirements patterns [ 34,36]. The use of these patterns
forceselicitation,reducesambiguities[ 34],andmakeswritingrules
lesserrorprone.Oncetherequirementsarewrittentobeconsistent
with patterns, the rules are generated by a direct mapping. The
rules generated are component state transition rules, which will
be converted into system transition rules by rule expansion. While
theexpansioninCombi-CCMissimilartothatofCCMandECCM,
9102018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:44 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Kaushik Madala, Hyunsook Do, and Daniel Aceituna
the number of states that users need to examine to identify ONBs
is much smaller. Combi-CCM uses the combinatorial algorithm
IPOG [28] to reduce the number of system states that a person
needstoexaminewhileexposingONBs.TherulescausingONBs
are analyzed, and corresponding requirements are corrected via
reversemappingfromrulesbacktorequirementsinmodifiedEARS
patterns. To evaluate our proposed approach, we conducted an em-
pirical study using 7 requirements specifications, comparing CCM,
ECCM,andCombi-CCMwithandwithoutstateflattening,using
2-wayand3-waycombinations.Ourresultsshowthatthe2-way
combination of Combi-CCM performs well in identifying possible
ONBs, with a smaller number of states to be analyzed manually
than CCM, ECCM, and 3-way Combi-CCM.
The rest of the paper is organized as follows. Section 2 provides
brief descriptions of EARS patterns, CCM, and ECCM. Section 3
presentstheproposedapproach,andSection4detailstheexperi-
mentation, threats to validity, and results. Section 5 analyzes theresults and discusses limitations, and Section 6 discusses related
work. Section 7 presents conclusions and discusses future research
directions.
2 BACKGROUND
In this section, we briefly explain EARS requirements patterns,
CCM, ECCM and their model elements.
2.1 EARS Requirements Patterns
Commonnaturallanguageiswidelyusedforwritingrequirements.
However,commonNLcanbeambiguous,wordy,andhardtoan-
alyzeandformalize.Toaddresstheseissues,Mavinetal.[ 34,36]
proposedaneasyapproachtorequirementssyntax(EARS),namely
simplesentencepatternsforrequirements.Thesentencepatterns
includepatternsforgenericrequirements,ubiquitousrequirements
(requirementsthatneedtobetruealways),event-drivenrequire-
ments, state-driven requirements, unwanted behaviors require-
mentssuchasfailurehandlingrequirements,optionalfeaturere-
quirements, and complex requirements that are logical combina-tions of earlier stated requirements. An example of an EARS re-quirements pattern is "WHILE <in a specific state> the <system
name>shall<systemresponse>",whichisastate-drivenpattern.
It has been proven in various case studies [ 34–36] that EARS de-
creasesvagueness,wordiness,andambiguity,andincreasestesta-
bilityandverifiability.EARSrequirementspatternsaremoresuit-
ableforsystem-levelrequirementsthanrequirementswrittenfor
component-drivendevelopment.MotivatedbythebenefitsofEARS
patterns, we adapt state-driven and event-driven patterns into pat-
ternsthatcanbeusedforcomponent-drivendevelopment,asapart
of our proposed approach.
2.2 CCM and ECCM
BeforewediscussCCMandECCMapproaches,wewillexplainthe
model elements of CCM and ECCM.
2.2.1 Model Elements. CCM and ECCM include three major
modelelements:component,componentstate,andtransitioncon-
dition. A component is a part of a system that has a well-defined
functionality and can change states when transition conditions are
met. In the case of embedded systems and robots, a componentis a piece of hardware and its associated software. For example,in a robot system, the motor, actuator, and ultrasonic sensor are
components.
Every component has states. A component state describes the
currentconditionofacomponent.Forexample,amotorcanhave
two states: ‘off’ and ‘on’. A component state that has a parent state
is considered to be a sub-state of the parent state. For example,a motor’s ‘on’ state can have sub-states such as accelerate and
decelerate. States without parent states (abstract level of states) areconsideredtobeatlevel0andwithanincreasedlevelofsub-states,
thelevelvalueisincreased.Forexample,thelevelofthemotor’s
‘on’ state is 0 while its ’accelerate’ state is 1. A component state
is represented as Component name(State name). For example, a
motor’s‘on’stateisrepresentedasMotor(on).Ifacomponentstate
is a sub-state, we represent it as the component name followed by
a concatenation of ancestral states of the component state using a
period(.)asaseparator,appendedbythecomponentstateatthe
end. For example, the ‘accelerate’ state of the motor is represented
as Motor(on.accelerate).
Asystem state is a combination of concurrent component states,
as the behavior of various components together constitute the be-
haviorofasystem.Forexample,fortherobotsystemdescribeabove,asystemstatewouldbewrittenas(Motor(on),Actuator(active),Ul-trasonicSensor(nodetection)).A transitioncondition isacomponent
state that allows (or enables) the transition of another component
state or a trigger that results in a state transition of componentstates. A transition condition can be environmental, i.e., due to
humanfactorsorenvironmentalconditionssuchaspressureand
temperature;oritcanbesystemrelatedsuchasthetransitionof
acomponentstateduetoothercomponentstate(s)becauseofde-
pendency. An example of an environmental transition condition
isthetemperaturebeinggreaterthan100◦F,whichresultsinthe
transitionofthetemperaturesensorfromasafetoanoverheated
state. An example of a system transition condition is an ultrasonic
sensor detecting an object, which results in the transition of the
motorfrom‘on’to‘off’.Usingthemodelelements,rulesarewritten
in the pattern Transition Condition: Component(Current State) ->
Component(Next State).
2.2.2 CCM. CCM[1]isamodelingtechniqueusedtoexpose
ONBs. The major steps in CCM involve the conversion of common
NLrequirementsintocomponentstatetransitionrules.Theserules
arethenconvertedintonumericalformtofacilitatecomputation.
Thesenumericalrulesareinturnusedinruleexpansiontoconvert
component state transition rules to system state transition rules.Once the system state transition rules are generated, rules with
user-identifiedundesiredstatesareseparatedout.Theprocessof
identifying rules with undesired states is a semi-automatic process.
Theusermustexamineallpossiblesystemstatesandidentifythe
undesiredstatesthatresultinONBs;thesestatesarethenmappedtorulesautomatically.Oncetherulesareseparated,anyrulewithboth
the current and next state identified as undesired is omitted. For
restoftherules,stateprofilesforundesiredstatesintherulesare
determinedusingthestateprofilingalgorithm[ 1]tocheckwhether
the state is recoverable without human intervention. Any rule that
has an undesired next state that is not recoverable is considered anunrecoverablerule.Rulesthatarenotrecoverablearediscussedwith
stakeholders and subject experts, and corresponding requirements
are corrected.
911
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:44 UTC from IEEE Xplore.  Restrictions apply. A Combinatorial Approach for Exposing Off-Nominal Behaviors ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
ZĞƋƵŝƌĞŵĞŶƚƐ
ĚŽĐƵŵĞŶƚƐ
ŽŶǀĞƌƚ
ƌĞƋƵŝƌĞŵĞŶƚƐ
ŝŶƚŽDͲ
Z^ƉĂƚƚĞƌŶƐ
ĂŶĚŐĞŶĞƌĂƚĞ
ƌƵůĞƐ
ŽŵƉŽŶĞŶƚƐ͕
^ƚĂƚĞƐ͕ƐƵďͲƐƚĂƚĞƐ
ŝǀŝĚĞƌƵůĞƐ
ŝŶƚŽƌƵůĞƐĞƚƐ
ĂŶĚĞǆƉĂŶĚ
ƌƵůĞƐ
'ĞŶĞƌĂƚĞ
ƐƚĂƚĞ
ƉƌŽĨŝůĞƐ
ĂŶĚƉƌŽĨŝůĞ
ƌƵůĞƐ
WĞƌĨŽƌŵ
ĐŽƌƌĞĐƚŝǀĞ
ĂĐƚŝŽŶŽŶ
ƌĞƋƵŝƌĞŵĞŶƚƐ
DͲZ^
ƌĞƋƵŝƌĞŵĞŶƚƐĂŶĚ
ŽŵďŝͲDŝŶƉƵƚ
^ƉĞĐŝĨŝĐĂƚŝŽŶ
ǆƉĂŶĚĞĚ
ZƵůĞƐ
ZƵůĞƐƌĞƐƵůƚŝŶŐŝŶ
KEƐ
ŽƌƌĞĐƚĞĚDͲ
Z^ƌĞƋƵŝƌĞŵĞŶƚƐ
'ĞŶĞƌĂƚĞ
ƉŽƐƐŝďůĞ
ƐǇƐƚĞŵƐƚĂƚĞƐ
ǁŝƚŚŶͲǁĂǇ
ĐŽŵďŝŶĂƚŝŽŶ
ƵƐŝŶŐ/WK'
ŶͲǁĂǇ
ĐŽŵďŝŶĂƚŽƌŝĂů
ƐƚĂƚĞƐ
/ĚĞŶƚŝĨǇ
ƵŶĚĞƐŝƌĞĚ
ďĞŚĂǀŝŽƌƐ
ĂŶĚŐĞŶĞƌĂƚĞ
ĨŝůƚĞƌƐ
&ŝůƚĞƌƐŽĨ
KEƐϭ Ϯϱ
ϲ
ϯ ϰ
&ŝŶĂůŝǌĞĚ
DͲZ^
ƌĞƋƵŝƌĞŵĞŶƚƐEŽKEƐĨŽƵŶĚKEƐ
ĨŽƵŶĚ
Figure 1: Overview of the Proposed Approach
2.2.3 ECCM. ECCM is an enhanced version of CCM. If sub-
statesarepresent,ECCMunlikeCCM,doesnotrequirestateflat-
tening [8]. The state flattening [ 8] process involves removing hier-
archicalrelationshipsamongstatesandforcingthemtoberepre-
sentedatthesamelevel.Thisapproachinsteaddividesrulesinto
rule sets using the rule set generation algorithm (see Algorithm 1).
This helps alleviate the rule explosion problem and state explosion
problem [ 42]. In addition, ECCM requires users to identify unde-
siredstatesonlyfromalistofnonrecoverablestates.Therestofthe
approach is similar to CCM. CCM cannot accommodate sub-states
without performing state flattening, but ECCM can handle the con-
cept ofsub-states. Despitethe advantagesof theseapproaches, as
mentioned in Section 1, both CCM and ECCM requires a lot of
humaneffortandtime.Tohandletheselimitations,weproposeour
approach, Combi-CCM.
3 APPROACH
AnoverviewoftheproposedapproachisshowninFigure1.The
ovalsdenotetheprocesses/steps,therectanglesdenoteinputs/outputs,
and the cylinder represents database. The input to the approach is
therequirementsdocuments,andthefinaloutputisthefinalized
requirements in modified EARS patterns. The numbers next to the
ovals denote step numbers.
Beforewedescribeeachstepindetail,weprovideabriefoverview
of Combi-CCM. First, NL requirements are converted into require-
mentswritteninmodifiedEARSrequirementspatterns,orCCM-
EARSpatterns.Duringthisstep,components,states,andsub-states
are identified and stored in the database. The converted require-
ments are used to generate component state transition rules (Step
1).Thegeneratedrulesaredividedintorulesetsifsub-statesare
present.Therulesineachrulesetareexpandedtogeneratesystem
state transition rules (Step 2). While the rules are being expanded,
systemstatesaregeneratedusingIPOG[ 28],an-waycombinatorial
algorithm(Step3).Thegeneratedstatesaremanuallyanalyzedto
identify ONBs, and a filter for each ONB is created (Step 4). Filters
arenumerical patternsthat canidentify undesiredstates andthey
arefurtherexplainedlaterinthissection.Thefilters,alongwiththe
state profiles generated using the state profiling algorithm [ 1], are
used to identifyrules with ONBs thatrequire human intervention
toreturntoadesirablestate(Step5).Thecorrespondingrequire-
ments of these identified rules are found and corrected (Step 6).
Inthispaper,weusetheterms‘ONBs’and‘undesiredbehaviors’
interchangeably.Step 1: Convert requirements to CCM-EARS
patterns and generate rules
Mostrequirementsarewrittenincommonnaturallanguage[ 32].
Common NL requirements are often wordy, ambiguous [ 3], and
incomplete. EARS patterns [ 34,36] were proposed to address these
issues.EARSpatternsrefertosixrestrictedNLsentencepatterns
that were created to reduce the problems associated with common
NL requirements. Case studies [ 34–36] that used EARS indicate
that EARS patterns are less ambiguous, less vague, less complex,
and more verifiable than common NL requirements. Further, EARS
patternsfacilitatetherequirementselicitationprocessbyforcing
engineerstofillinmissinginformation.TouseEARSpatternsinour
approach,wemodifiedthembecauseEARSpatternsarenotsuitable
forcomponent-drivenrequirementsandwerenamedthemCCM-
EARS. In this paper, we modified only two EARS patterns because
theycancapturetheessentialelementsinbuildingacomponent-
driven state transition model. The rest of patterns are out of scope
ofthispaperastheyarenotusedinthebasicmodelthatwebuildin
our approach. The two EARs patterns we modified are as follows:
Event-Driven : WHEN <triддer><optionalprecondition >,
the<systemname >shall<systemresponse >.
State-Driven : WHILE <systemstate >, the<systemname >
shall<systemresponse >.
We converted them into the following CCM-EARS patterns:
Event-Driven (Fortransitionsresultingfromtriggersinvokedby
environmentalreasons):WHEN <environmentaltriддer >,the
<componentname >shalltransitionfrom <componentstate 1>
to<componentstate 2>.
State-Driven (For transitions resulting from dependency be-
tween components): IF <component 1name >is in<
component 1state>state, the <component 2name>shall tran-
sition from <component 2state1>to<component 2state2>.
Inadditiontothesetwopatterns,wecanalsoconvertrequire-
ments into a complex pattern similar to complex requirements
pattern of EARS, which contains a logical combination of the two
patternsincludingthelogicalcombinationsofpatterns.Forexample,
a sample complex pattern is “WHEN <environmentaltriддer >
AND<component 1name>is in<component 1state>state, the
<component 2name>shall transition from <component 2state1>
to<component 2state2>”. As a first step of exposing ONBs, we
consider common NL requirements, and find components, their
912
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:44 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Kaushik Madala, Hyunsook Do, and Daniel Aceituna
states,andsub-states,andtransitionconditionsusingwhichwecre-
aterequirementsthatfollowevent-driven,state-driven,orcomplex
CCM-EARSpatterns.CCM-EARSpatternsforcetheusertoelicit
requirements if details are missing in the pattern to be followed. In
addition,itiseasytoenforceconstraintsonCCM-EARSpatterns
thanthatonCCMrules.Thishelpsidentifytheunknowncompo-
nents,states,andsub-states.Theinformationaboutcomponents,
states, and sub-states is stored in the database and used later in the
generation of filters to expose ONBs.
An example of the conversion of requirements into CCM-EARS
patterns is illustrated as follows:
Requirements Sample 1:
(1)The robot system shall consist of a push-button switch, a
motor, an ultrasonic sensor, and a temperature sensor.
(2)The system can be turned off and on using the switch, which
also activates the motor.
(3)Thesystemmuststopiftheultrasonicsensordetectsanobject.
(4)The system must move only when the robot is on and the
temperature is safe, i.e., less than 100◦F.
Inthisexample,wehaveassumedtheswitchtohave‘off’and
‘on’states,unlikeastatelessswitch.Consideringthiscondition,the
requirements in Requirements Sample 1 can be converted into the
following CCM-EARS requirements:
CCM-EARS requirements for Requirements Sample 1:
(1)The robot system shall consist of a push-button switch, a
motor, a ultrasonic sensor and a temperature sensor.
(2)Whentheuserpressestheswitch,theswitchshalltransition
from off to on.
(3)When the user releasesthe switch,the switchshall transi-
tion from on to off.
(4)If the switch is in the off state, the motor shall transition
from on to off.
(5)If the switch is in the on state, the motor shall transition
from off to on.
(6)When an object is present, the ultrasonic sensor shall tran-
sition from no detection to detection.
(7)If ultrasonic sensor is in detection state, the motor shall
transition from on to off.
(8)Whenthetemperature islessthan100◦F,the temperature
sensor shall transition from overheated to safe.
(9)If the temperature sensor is in the safe state and the switch
is in the on state, the motor shall transition from off to on.
Once the CCM-EARS requirements are generated, they are con-
verted into rules. As mentioned in Section 2, a transition rule is of
the form Transition Condition: Component(Current State) -> Compo-
nent(Next State).
The state-driven pattern "IF <component1 name> is in <compo-
nent1state>state,the<component2name>shalltransitionfrom
<component2 state 1> to <component2 state 2>" will be converted
intotransitionruleofform component1name(component1state):
component2name(component2state1)->component2name(com-
ponent2 state 2).
The event-drivenpattern "WHEN <environmentaltrigger> the
<componentname>shalltransitionfrom<componentstate1>to
<componentstate2>"willbeconvertedintotransitionruleofformenvironmental trigger: component name (component state 1) -> com-
ponent name (component state 2).
In the case of the complex pattern, the environmental trigger/
component1 name(component1 state) will be followed by the con-
junction’AND’followedbyother environmentaltrigger/component3
name(component3 state) as transition condition until we specify all
conditionsinthecombination;thegenerationofcomponent(current
state) to component(next state) is similar to the aforementioned
transformations.
WhenweconverttheCCM-EARSrequirements(Requirements
Sample1) intotransitionrules, weobtainthe followingrules(dueto space limitations, we illustrate a small portion of rules):
Example Rules from CCM-EARS requirements for Re-quirements Sample 1:
(1) User(presses_switch): Switch(off) -> Switch(on) (rule 1)(2)
Temperature_Sensor(safe)ANDSwitch(on):Motor(off)
-> Motor(on) (Example of Complex pattern) (rule 8)
Algorithm 1: Generation of Rule Sets
input :A set of components in system C={C1,C2,C3, ... ,Cn}
A set of states at level 0 for each component
maxlevel, maximum level of sub-statesSets of sub-states for each component at level 1, 2, 3, ..., maxlevelRules R =
{R1,R2,R3,R4, ... ,Rw}
output:Rulesets
1rulesetnum = 0 ;
2 forcurrentlevel ←0tomaxlevel do
3i f currentlevel ==0then
4 foreach RuleRiin Rdo
5i fstates inRi∈any of component-states at level 0 then
6 Rulesets[rulesetnum] ←Rulesets[rulesetnum] ∪Ri;
7 rulesetnum ←rulesetnum+1;
8 else
9 foreach Component Ciin Cdo
10 ifComponent Cihas sub-states at level = currentlevel
then
11 foreachRuleRiin Rdo
12 ifcomponent in Ri==Cithen
13 ifstate inRi∈sub-states of Ciat level =
currentlevel then
14 truncate states with lower level
sub-states ;
15 Rulesets[rulesetnum] ←
Rulesets[rulesetnum] ∪Ri;
16 else
17 ifstates inRi∈any of states at level 0 then
18 Rulesets[rulesetnum] ←
Rulesets[rulesetnum] ∪Ri;
19 rulesetnum ←rulesetnum+1;
Step 2: Divide and expand the rules
Oncetherulesarewritten,ifthesystem’scomponentshavesub-
states, the rules can be divided into rule sets. The engineers, do-
main experts, and stakeholders are at libertyto decide whether to
considersub-statesseparatelyortoflattenthestatespace.Stateflat-
tening [8] refers to the process of removing hierarchical states and
representing all the states at the same level. For example, suppose
that a component Motorhas two states, ‘off’ and ‘on’, and that the
‘on’ state has two sub-states, ‘idle’ and ‘move.’ By applying state
913
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:44 UTC from IEEE Xplore.  Restrictions apply. A Combinatorial Approach for Exposing Off-Nominal Behaviors ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
flattening [ 8], we represent the states of Motoras ‘off,’ ‘idle,’ and
‘move.’Algorithm1[ 33]generatesrulesets. Riinthealgorithmrep-
resents rule number iin the list of transition rules (e.g., Transition
Condition:Component(CurrentState)->Component(NextState). Ci
represents ithcomponent in the system. The formal definitions of
model elements, and more details on rule set generation algorithm
can be found in [1] and [33], respectively.
Thealgorithmgeneratesonlyonerulesetifstateflatteningis
done forhierarchical states. The algorithmassigns levels tostates
basedonthehierarchy.Forexample,statesatlevel0arestateswith
noparentstates,whereasstatesatlevel1haveparentstatesthat
areatlevel0.Thealgorithmgeneratesrulesetsuntilalllevelsof
sub-statesarecovered(line2).Iflevel0statesarebeingexplored
(line3),any rulewithlevel0 statesintheinputset(line4)isadded
to the first rule set (lines 5 and 6). If the level of states is greater
than 0, i.e., if there are sub-states (line 8), the following series ofoperations are performed for each component (line 9). For eachlevel of sub-states of the component, if the component contains
sub-states at that level (line 10), a new rule set is created. Any rule
withsub-statesinthecomponentatthatlevel(lines11–13)isadded
tothenewruleset( line15).Ho wever,iftheoneofthestatesinthe
rule is at the current level while other state has the next level of
information, we truncate the other state to retain only the current
level of information (line 14). For the rules whose components are
notbeinginvestigated,onlytherulesthathavelevel0states(states
with no parents) are added to the rule set (lines 16–18).
We illustrate the algorithm using the following example.
Requirements Sample 2:
(1)User(presses_switch): Switch(off) -> Switch(on)
(2)User(releases_switch): Switch(on) -> Switch(off)
(3)Switch(on): Motor(off) -> Motor(on.idle)
(4)Switch(off): Motor(on) -> Motor(off)
(5)User(enters_location): Motor(on.idle) -> Motor(on.move)
(6)Destination(reached): Motor(on.move) -> Motor(on.idle)
AsmentionedinSection2,asub-stateisrepresentedbyconcate-
natingitsparents’statesfollowedbyperiod(.),andthenappending
sub-stateitself.Forexample,intheRequirementsSample2rules,
motorhas two outermost states: off and on. But in ‘on’ state, the
motor can be in ‘idle’ or ‘move’ state. These states are represented
in the rules as ‘on.idle’ and ‘on.move.’
ByapplyingAlgorithm1,ontheRequirementsSample2rules,
thealgorithmfirstconsidersruleswithatleastonestatewithno
parent state and forms the first rule set as follows:
Rule set 1 - for Requirements Sample 2:
(1)User(presses_switch): Switch(off) -> Switch(on)
(2)User(releases_switch): Switch(on) -> Switch(off)
(3)Switch(on): Motor(off) -> Motor(on)
(4)Switch(off): Motor(on) -> Motor(off)
From this example, we can observe that the algorithm truncates
anystatethathassub-stateinformationwhenanalyzingthepar-
ent states; i.e., in the rule Switch(on): Motor(off) -> Motor(on.idle),
‘on.idle’ is truncated to ‘on’ as ‘idle’ represents a sub-state.
Next,thealgorithmstartscheckingsub-statesforeachcompo-
nent, starting with Switch.Switchdoes not have any rules withsub-states, and thus Motoris examined. Because Motorhas sub-
states, a second rule set is formed as follows:
Rule set 2 - for Requirements Sample 2:
(1)User(presses_switch): Switch(off) -> Switch(on)
(2)User(releases_switch): Switch(on) -> Switch(off)
(3)Switch(on): Motor(off) -> Motor(on.idle)
(4)User(enters_location): Motor(on.idle) -> Motor(on.move)
(5)Destination(reached): Motor(on.move) -> Motor(on.idle)
Theadvantageofpartitioningintorulesetsisthatitreducesthe
ruleexplosionproblemthatcanoccurwhentransformingcompo-
nentstatestosystemstates.Flatteningstatesincreasesthepossible
numberofcombinationsofcomponentstates,therebyincreasing
thenumberofsystemtransitionrules.Partitioningintorulesets
allows to process a small number of component states at any given
time by restricting the state space, thereby reducing the number of
systemtransitionrulesthatwillbegenerated.Theruleswehave
generatedfortheexamplerequirementsinStep1aregroupedin
onlyonerulesetbecausethecomponentshavenosub-states.Once
the rule sets are generated, the rules in a rule set are converted
into numerical rules, in which component states are represented in
numerical form to make computation easier during rule expansion.
^ƚĂƚĞϭ ^ƚĂƚĞϮ ^ƚĂƚĞϯ
ŽŵƉŽŶĞŶƚ ϭϭ͕Ϭ͕Ϭ Ϯ͕Ϭ͕Ϭ ϯ͕Ϭ͕Ϭ
ŽŵƉŽŶĞŶƚϮ Ϭ͕ϭ͕Ϭ Ϭ͕Ϯ͕Ϭ Ϭ͕ϯ͕Ϭ
ŽŵƉŽŶĞŶƚϯ Ϭ͕Ϭ͕ϭ Ϭ͕Ϭ͕Ϯ Ϭ͕Ϭ͕ϯ
^ƵďƐƚĂƚĞ ϭ ^ƵďƐƚĂƚĞ Ϯ ^ƵďƐƚĂƚĞ ϯ ^ƵďƐƚĂƚĞ ϰ
Ϯ͘ϭ͕Ϭ͕Ϭ Ϯ͘Ϯ͕Ϭ͕Ϭ Ϯ͘ϯ͕Ϭ͕Ϭ Ϯ͘ϰ͕Ϭ͕Ϭ
^ƵďƐƚĂƚĞ ϭ^ƵďƐƚĂƚĞ Ϯ^ƵďƐƚĂƚĞ ϯ^ƵďƐƚĂƚĞ ϰ
Ϯ͘ϯ͘ϭ͕Ϭ͕ϬϮ͘ϯ͘Ϯ͕Ϭ͕ϬϮ͘ϯ͘ϯ͕Ϭ͕Ϭ Ϯ͘ϯ͘ϰ͕Ϭ͕Ϭ^ƵďƐƚĂƚĞƐŽĨϮ͕Ϭ͕Ϭ
^ƵďƐƚĂƚĞƐŽĨϮ͘ϯ͕Ϭ͕Ϭ
Figure 2: Numerical States Representation
The representation of states and sub-states in numerical form is
illustratedinFigure2.Therowsshowcomponentsandthecolumns
show states. Sub-states are listed in the columns within states. The
numerical states are generated by considering the ordinal position
of components and states. In the case of sub-states, the ordinalposition is concatenated with the parent state with period (.) asa separator. For example, (1, 0, 0), refers to state 1 of component
1, which is in a system that consists of 3 components and (1.2, 0,
0) represents sub-state 2 of state 1 of component 1. The value 0indicates that the component can be in any of its states. When a
specificvalueisassignedinsteadof0,theresultisasystemstateas
wehaveinformationaboutallthecomponents’states;i.e.,asystem
state is a combination of components’ states.
The first and eighth rules in Requirements Sample 1 are con-
verted into the following numerical rules:
Numerical rules of Requirements Sample 1:
(1)User(presses_switch): 1, 0, 0, 0 -> 2, 0, 0, 0
(2)0, 0, 0, 1 AND 2, 0, 0, 0: 0, 1, 0, 0 -> 0, 2, 0, 0
Ruleexpansionisperformedoncetherulesareconvertedinto
numericalrules.Themaingoalofruleexpansionistoconvertcom-
ponent state transitions into system state transitions. We followed
914
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:44 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Kaushik Madala, Hyunsook Do, and Daniel Aceituna
the same rule expansion process used in CCM [ 1] and ECCM [ 33].
When the transition rule has a component’s state(s) as a transition
condition,itimpliesthatthecomponentinthetransitioncondition
mustbeinthestatespecifiedforthetransitiontohappen.Itfurther
impliesthatthecurrentstateaswellasthenextstateofthesystem
must have that component in the specified state. To achieve this,
we perform absorption and propagation operations. Absorption
involves thetransferof stateinformation fromthe transitioncon-
dition to the current componentstate. When we apply absorption
to rule 8 in Requirements Sample 1, we obtain 0, 0, 0, 1 AND 2,
0, 0, 0: 2, 1, 0, 1 –> 0, 2, 0, 0. The propagation operation involves
moving the state information from the current state to the nextstate. After propagation, rule 8 becomes 0, 0, 0, 1 AND 2, 0, 0, 0:
2 ,1 ,0 ,1– >2 ,2 ,0 ,1 . Once absorption and propagation are done,
the transition conditions that have only the component’s states
will be converted into a notation of ‘T’ (’T’ refers to a transition
caused by system) concatenated with the rule number from the list
of rules with the component’s state(s) as their transition condition.
For example, rule 8 will be changed into T4: 2, 1, 0, 1 –> 2, 2, 0, 1.
Next, we perform expansion, which involves replacing zeroes in
the numerical states withall possible component state values that
makeupthesystem’sstatespace.Ifarulesethasacomponent’s
sub-states,wereplacethevalueofzeroeswithonlythevaluesof
sub-states of that component. For example, rule 8, after expansion,
generates the following rules:
Expansion of rule 8 in Requirements Sample 1:
(1)T 4 :2 ,1 ,1 ,1- >2 ,2 ,1 ,1
(2)T 4 :2 ,1 ,2 ,1- >2 ,2 ,2 ,1
Step 3: Generate possible system states with
n-way combination of component states
As mentioned early, traditional CCM and ECCM approaches re-
quireuserstoexaminealargenumberofstatesmanuallytofind
undesired states. Because the number of possible system states is a
Cartesianproductofcomponentstates,ifthetargetsystemislarge
and complex, the number of states that are to be checked manually
can be very large. For example, if a system has 20 components, 10
states each, then the Cartesian product of the states would be 1020.
Examining all these states manually would take substantial timeand human effort. Our goal is to reduce the number of states re-
quiring manual analysis thereby reducing human effort. To reduce
human effort, we use the IPOG algorithm to reduce the number
ofstatesthatneedtobemanuallyanalyzed.IPOGalgorithm[ 28]
is widely used in the combinatorial software testing community.
BecauseONBsoccurduetoconflictingcomponentstates,checkingann-waycombinationofcomponentstatesmustbeabletocoverall
types of behaviors between any ncomponents. For example, when
n=2,2-waycombination ensuresthatallpossiblecombinations of
component states between any two components are covered. In
general,2and3arewidelyusedfor nvalue[24,28].Forexample,for
RequirementSample1,whenweappliedtheIPOGalgorithmusing
2-waycombinations,only6statesneededtobeanalyzedinstead
of 16 states. Further, we can add constraints when we generatecombinations so that only sensible combinations are considered.
For example, if we consider a server and server communication as
twocomponentsofasystem,servercommunicationispossibleonlywhen the server is on, checking whether the server is communicat-
ingwhenitisoffisnotnecessary.Thus,unnecessarybehaviorscan
be omitted by using, in this case, the constraint, “server commu-
nicationcanbeincommunicatingstateonlyiftheserverisinon
state.”Thevalueof‘n’mustbechosenbasedonthedependencies
betweenthecomponents.Ifacomponentinteractswithallother
components in the system, then the ‘n’ value must be the number
of components. However, in reality, most systems do not function
such that each component is dependent on every other component.
Mostsystemshaveacomponentthatactsasacontroller,andthe
restofthecomponentsinteractwithit.Asaresult,the‘n’values
of 2 and 3 are sufficient to represent dependencies in most systems.
Our approach is meant for such systems. We plan to work on re-
ducingthenumberofstatesinwhichmultiplecomponentsmust
cooperate(e.g.,amultiplerobotcoordinationsystemformoving
heavy objects) as part of future work.
Step 4: Identify undesired behaviors and
generate filters
Once the n-way combinations of states are generated, the states
are analyzed to determine whether any system components of the
systemareinanyconflictingstates.Itispossibleforasinglesys-
tem state to exhibit multiple undesired behaviors, especially when
analyzing a complex system with large number of components. To
identify all the states in a system with undesired behaviors, we cre-
atefiltersofthesestates.Filtersarenumericalpatternsofundesired
statesandarerepresentedsimilartosystemstates.Anystatethatmatchesthe filteris anundesired stateand thefiltersare usedfor
exposing ONBs. If the state value of a particular component in the
filter is 0, then the state of that component is ignored when the
comparisonismade.Forexample,inRequirementsSample1,the
ONBidentifiedis motoris‘on’,when temperaturesensor is‘over-
heated’.Thecorrespondingfilterrepresentationis2 ,0,2.Thestates
thatmatchthisfilterinRequirementsSample1are:2 ,1,2and2,2,2.
These states are considered undesired states.
Step 5: Generate state profiles and profile rules
Afterruleexpansion,allthecomponentstatetransitionrulesare
converted into system state transition rules. Because our goal is to
notonlyexposeONBsbutalsofindthecauseofONBsandcheck
iftheyarerecoverable,wegeneratestateprofilesforeachsystem
state.Stateprofilesrepresentthein-degree(ID)andout-degree(OD)
of a state that result from environmental transition conditions (E)
as well as a component’s state(s) as transition conditions (T). State
profilingrequiresfindingTOD,TID,EOD,andEID,foreachstate.
Figure 3 illustrates state profiles for a given system state.
TODisthenumberofcomponent’sstatetransitionconditions
resulting in transition from the state being profiled. TID is thenumber of component’s state transition conditions resulting intransitiontothestatebeingprofiled.EODisthenumberofenvi-ronmental transition conditions resulting in transition from the
state being profiled. EID is the number of environmental transition
conditions resulting in transition to the state being profiled. These
values are calculated for each state by parsing through each rule
and checking the current state and the next state of the rule. If
the transition condition is environmental, then EOD of the current
state is incremented by 1 andEID of the nextstate is incremented
915
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:44 UTC from IEEE Xplore.  Restrictions apply. A Combinatorial Approach for Exposing Off-Nominal Behaviors ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
by 1. If the transition condition is system originated (coming from
component’s states), then TOD of the current state is incremented
by 1 and TID of the next state is incremented by 1.
^ǇƐƚĞŵ
^ƚĂƚĞ/
ŶǀŝƌŽŶŵĞŶƚĂů
ƚƌĂŶƐŝƚŝŽŶĐŽŶĚŝƚŝŽŶƐŶǀŝƌŽŶŵĞŶƚĂů
ƚƌĂŶƐŝƚŝŽŶĐŽŶĚŝƚŝŽŶƐK
d/ dK         	  
  
ƚƌĂŶƐŝƚŝŽŶĐŽŶĚŝƚŝŽŶƐ
         	  
  
ƚƌĂŶƐŝƚŝŽŶĐŽŶĚŝƚŝŽŶƐ
Figure 3: Representation of state profile
For example, let us consider the following expanded rules from
Requirements Sample 1:
(1)User(Releases): 1, 1, 1, 1 -> 2, 1, 1, 1
(2)T 4 :2 ,1 ,1 ,1- >2 ,2 ,1 ,1
Whenthefirstrulestatedaboveisparsed,becausethetransition
conditionhasanenvironmentalcause,theEODvalueofthesystem
state1,1,1,1isincrementedby1andtheEIDvalueof2 ,1,1,1is
incremented by 1. In the second rule, because the transition condi-
tion is system originated, the TOD value of 2 ,1,1,1 is incremented
by 1 and the TID of 2 ,2,1,1 is incremented by 1.
Thestateprofilesgeneratedalongwiththefiltersofundesired
behaviors that are generated by manual identification of undesired
behaviors (explained in Step 4) will be used to profile rules. Filters,
asstatedearlier,arepatternsthatrepresentundesiredstates.These
filters are used to find rules with undesired states and thereby
exposeONBs.Thisisdonebycheckingwhetherthecurrentsystem
stateornextsystemstateintherulematcheswiththepatternof
the filter. Any rule that has undesiredcurrent and next states will
be removed, and the corresponding requirement is corrected or
removed.Anyrulewithanextstateastheundesiredstatewillbe
analyzed further. If a rule contains only an undesired next state,
then the state profile of the undesired next state is examined to
determine whether its TOD is 0 or greater than 0. If TOD is 0, this
indicatesthattheundesiredstatecannotberecoveredautomatically
and human intervention is required because it has no component’s
state(asystemoriginatedcause),thatcantransitionintoadesirable
system state. We identify such rules as nonrecoverable rules.
WeillustratethisconceptusingRequirementSample1.Inthis
example, one of the undesired behaviors is that motoris ‘on’, when
temperaturesensor is‘overheated’.Toidentifystatesthatarerelated
to undesired behavior, we use filter 0 ,2,0,2. When we applied this
filter,wefoundarulethathastheundesirednextstate,whichis: T2:
2,1,1,2– >2,2,1,2. The TOD value of undesired state 2 ,2,1,2i s
zero, which implies that the rule leads to the nonrecoverable state.
Step 6: Perform corrective action
Once the nonrecoverable rules are identified, stakeholders, require-
mentsengineers,anddomainexpertsdiscussandanalyzethecausesofthoserulesandcorrecttheCCM-EARSrequirements.InRequire-mentsSample1,thenonrecoverablerulefoundinStep5wascaused
byrequirement5becausehaving“Switch(on)”withoutchecking
temperature sensor isletting motor to transition from ‘off’to ‘on’.
Tocorrectrequirement5,weomitteditastheexpectedbehavioris covered by requirement 9. Once the requirements are corrected,
the process is repeated until no undesired behaviors are found.
4 EMPIRICALSTUDY
To evaluate our proposed approach, we conducted an empirical
study to investigate the following research questions:
•RQ1: Does Combi-CCM reduce the number of system states
that should be analyzed manually compared to CCM and
ECCM?
•RQ2: Does a reduction in the number of states affect the
ONB exposure ability?
4.1 Objects of Analysis
We used 7 requirements specification documents to investigate our
research questions as follows:
(1)Automatic Delivery System (ADS) : Automatic Delivery
System[30]isa175–pagerequirementsdocument.There-
quirements specifications concern a robot asked with deliv-
eringpackages.Inthisstudy,weconsideredonlytherobot’s
behavioral requirements.
(2)AB Mail Robot (ABMR) : AB Mail Robot [ 38] is a 13–page
requirements document written for a course project. The
requirements specificationsconcern arobot asked withde-
livering mail from mailboxes to people. We have considered
behavioral aspects in this study.
(3)AutonomousRoboticVacuumCleaner(ARVC) :There-
quirementsspecificationsofAutonomousRoboticVacuum
Cleaner [ 39] is a 9–page document written for a course
project that lists requirements for a robot vacuum cleaner
that must be able to clean a room.
(4)Oddbotics : Oddbotics requirements [ 11] are a 46–page doc-
ument. The requirements specifications are for a robot that
musttocapturevideowhilemovingaroundinanenviron-
ment.
(5)DigitalHome Software(DHS) :Therequirementsspecifi-
cations for Digital Home Software [ 17] is a 15–page docu-
ment that details a complex system that helps automatically
controltemperature,humidity,aswellassmallappliances
usingamobileorotherpersonaldevice.Weconsideredonly
20 of 50 contact sensors to find and analyze ONBs.
(6)Pacemaker : Pacemaker specification [ 4,37] is a 35–page
document that describes the functionality of a pacemaker.
Thisdocumentiswidelyusedbyotherresearchers[ 15,18,
20,41]. In this study, we concentrate on the pulse genera-
tor component of pacemakers whose malfunction results in
complications to the patient.
(7)Excavator :Excavatorrequirements[ 1]wereusedforaCCM
case study. They consist of 8 sample requirements aboutan excavator, a real-world system, with details about the
operator safety features in an excavator.
4.2 Variables and Measures
Our study manipulated one independent variable, the modelingtechnique that exposes ONBs. We considered two control tech-niques (CCM and ECCM) and four heuristic techniques (Combi-CCM F2, Combi-CCM H2, Combi-CCM F3, Combi-CCM H3). A
description of these techniques can be found in Table 1.
916
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:44 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Kaushik Madala, Hyunsook Do, and Daniel Aceituna
Table 1: Independent Variables (Modeling Techniques)
Type Technique Description
ControlCCM CCM requires users to analyze all possible
system states to identify ONBs and deter-
mine the causes of these ONBs.
ECCM TheenhancedversionofCCM.ECCMgener-
atesrulesetsgivenhierarchicalstates.ECCM
requiresuserstomanuallyanalyzeonlynon-
recoverable states.
HeuristicCombi-CCM
F2This technique performs state flattening
when there are hierarchical statesand gen-
erates the states to be analyzed using 2-way
combinations.
Combi-CCM
H2This technique generates rule sets when
there are hierarchical states and generates
thestatestobeanalyzedusing2-waycombi-
nations.
Combi-
CCM
F3This technique performs state flattening
when there are hierarchical statesand gen-
erates the states to be analyzed using 3-way
combinations.
Combi-
CCM
H3This technique generates rule sets when
there are hierarchical states and generates
thestatestobeanalyzedusing3-waycombi-
nations.
The dependent variable for RQ1 is the number of states that
needs manual analysis, and for RQ2, the dependent variable is the
number of ONBs exposed by the techniques.
4.3 Experimental Setup and Procedure
To perform the experiment, we implemented the Combi-CCM tool
in Java. We used ACTS [ 47] to generate system states that a per-
son needs to analyze manually. The ECCM and CCM tools were
implemented in Java and C#, respectively.
The experimental procedure followed the approach explained in
Section 3. The common NL requirements of all the requirements
documents suitable for creating model are converted into CCM-
EARSrequirements1.These CCM-EARSrequirements areusedto
generaterulesbydirectlymappingsentencepatternstorulepat-
terns.Therulesarethendividedintorulesetsandruleexpansionisperformed.Theusercandecidewhethertoperformstateflattening
or not.In our experiment,we investigated research questionsbyconsidering techniques with and without state flattening. After
ruleexpansion,usingACTS,wegeneratedthesystemstatesthat
users would need to examine to find ONBs. In our experiment,
weusedboth2-wayand3-waycombinationstogeneratesystem
states. Based on the ONBs found by the users, filters are created.
These filters are used to expose rules with ONBs. The rules with
ONBs that are not automatically recoverable are reverse–mapped
to CCM-EARS requirements, and corresponding requirements are
corrected.
WhileCCMandECCMrequiretranslationofNLrequirements
into rules, it is an error-prone process and tends to create incor-
rectrules.Inordertohavefaircomparisonsbetweencontroland
heuristictechniquesintermsofhumaneffortreduction,weused
1Sample CCM-EARS requirements: https://goo.gl/VKPm4UthesamerulesgeneratedfromCombi-CCMforCCMandECCM.
CCMperformsruleexpansionusingtherules.CCMdoesnotdivide
rules into rule sets as it takes only flattened states as an input. The
usersmanuallyanalyzeallpossiblesystemstatesandidentifythe
undesiredstates.TheseundesiredstatesareusedtoexposeONBs.
SimilartoCombi-CCM,CCMusesstateprofilestocheckfortheau-
tomatic recoverability of a system; rules with ONBs that cannot be
addressed without human intervention are separated out, and cor-
responding common natural language requirements are addressed.
The ECCM approach is similar to CCM, but in ECCM, the rules are
dividedintorulesetswhenhierarchicalstatesarepresent,rather
thanflatteningstates.ECCMalsorequiresuserstogothroughonly
nonrecoverable states to identify undesired states.
4.4 Threats to Validity
Inthisstudy,weassumedthatthegeneratedCCM-EARsrequire-
ments are complete. This assumption might affect our ability todetermine ONBs. We can address this threat by checking the re-
quirements for completeness before the model is built. Further, the
identification of ONBs involves human judgment, which can be
subjective.Weplantomitigatethisthreatbyusingmultipledomain
experts during decision making.
4.5 Results
Inthissection,wepresenttheresultsofourstudyconsideringeach
research question.
4.5.1 Reduction of manually analyzed system states (RQ1). Our
first research question (RQ1) asks whether the Combi-CCM ap-
proach can reduce the number of system states compared to CCM
and ECCM. To answer this research question, we compared thetwo control and four heuristic techniques shown in Table 1. The
numberofstatesthatrequiremanualanalysisforeachtechnique
and requirements document is shown in Table 2.
From Table 2, we can observe that CCM produced the largest
numberofstatesthatrequiremanualanalysis.Forexample,CCM
produced46,656,000statesforADSandapproximately1022states
for DHS, which are prohibitively large numbers of states for man-
ual analysis. ECCM requires users to examine only nonrecoverable
states, which reduces the number of states for manual analysis.Heuristic techniques produced much smaller numbers of states
than the control techniques. Combi-CCM F2 produced the smallest
number of states, ranging from 6 to 108, among heuristics. Thenumber of states produced by Combi-CCM H2 ranges from 6 to
1,439. This technique produced a similar number of states com-
pared to Combi-CCM F2 for Oddbotics and Excavator, because
these requirements do not have sub-states, but it produced greater
number of states than Combi-CCM F2 for the rest of the require-
ments. Combi-CCM F3 produced a number of states ranging from
12 to 206. Combi-CCM F3 produced a smaller number of states for
ABMR, ARVC, and DHS than did Combi-CCM H2.
4.5.2 ONB exposure ability (RQ2). From the results in RQ1, we
learnedthatCombi-CCMwasabletosubstantiallyreducethenum-
ber of states that require manual analysis compared to control
techniques.However,ifCombi-CCMisnoteffectiveindetecting
ONBs,statereductionswouldnotbebeneficial.Thus,inRQ2,we
investigated whether a reduction in the number of states can affect
917
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:44 UTC from IEEE Xplore.  Restrictions apply. A Combinatorial Approach for Exposing Off-Nominal Behaviors ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Table2:NumberofSystemStatesBeingAnalyzedManually
Req.Doc. CCM ECCM Combi- Combi- Combi- Combi-
CCM CCM CCM CCM
F2 H2 F3 H3
ADS 46656000 3670016 26 110 141 410
ABMR 1728 34 12 40 34 114
ARVC 11664 615 15 72 66 205
Oddbotics 20736 10488 14 14 43 43
DHS ≈1022≈101438 1439 198 1622
Pacemaker 448 396 108 128 206 252
Excavator 32 12 6 6 12 12
ONBexposureability.Toanswerthisquestion,weexaminedthe
number of states created as part of addressing RQ1, and identified
the ONBs exposed by each technique. The number of ONBs found
using each technique is shown in Table 3.
CCMrequiresuserstoexamineallpossiblesystemstates;thus,
CCM expose all possible ONBs based on the knowledge of users.
Because it is not possible to know all the ONBs in the require-
ments (which would be analogous to exposing all the faults in the
program),inthisexperiment,weusethenumberofONBsfound
by CCM as a baseline. Table 3 shows that CCM exposed 4 ONBsin ABMR, 3 in ARVC, 4 in Oddbotics, 3 in Pacemaker, and 3 inExcavator. The ONB numbers for ADS and DHS were estimated
byconsideringONBvaluesfrom2-wayand3-wayheuristictech-
niques because they have too many states to manually examine.
The actual number of ONBs that we could find by analyzing all
those states might be larger than what we estimated.
ECCM did not detect as many ONBs as CCM. ECCM found
24 ONBs in ADS, 2 in ABMR, none in ARVC and Oddbotics, 40in DHS. The ONB numbers found by ECCM were smaller than
those from CCM, and for some cases, it failed to expose any ONBs.
WeconjecturethatthereasonforthisresultisthatECCMallows
users to check only nonrecoverable states. The technique does not
considerundesiredstatesthattransitionintootherundesiredstates.
Whenexaminingtheresultsfromheuristic techniques,allfour
techniques produced results similar to those of CCM, with one
exception, in ABMR. In ABMR, the 2-way techniques, Combi-CCM
F2 and Combi-CCM H2, produced a smaller number of ONBs than
CCM. In ABMR, one of the ONBs is caused by concurrent conflict-
ingstatesofthreecomponents;asaresult,2-waytechniquesdid
notcoverthe combination.Forallotherrequirementsdocuments,
heuristics found the same number of ONBs as CCM.
FromTables2and3,wecanobservethatheuristictechniques
withstateflatteningsuchasCombi-CCMF2andCombi-CCMF3
foundthesamenumberofONBswithasmallernumberofstates
comparedtothetechniquesthatdonotusestateflattening(Combi-
CCM H2 and Combi-CCM H3). To investigate whether it is always
preferabletousetechniqueswithstateflattening,wemeasuredthe
number of expanded rules for each technique as shown in Table 4.
TherulesinTable4areautomaticallyparsedandanalyzedbased
on undesired states found.
InTable4,thenumberofrulesthatneedtobeanalyzedusing
a heuristic techniques with state flattening is very large when
comparedtotheheuristictechniquethatdonotusestateflattening.
For example, as shown in Table 4, the number of expanded rules
estimatedtobeanalyzedusingtechniqueswithstateflatteningis
approximately 1025, whereas techniques without state flattening
require only 1017. If the system has no sub-states, techniques withandwithoutstateflatteningmustanalyzethesamenumberofrules,
as in Oddbotics and Excavator, with all the techniques requiring
to parse through 168,541 and 116 rules, respectively. These results
indicate that the benefits of state flattening depend on the number
ofcomponents,theirstates,andtheirsub-states.Forexample,inthe case of DHS, the total number of expanded rules generatedby replacing every unknown component state with all possible
componentstatesisapproximately1025,whichcanresultinrule
explosion and scalability problems. For such a case, it would be
wise not to use state flattening.
Table 3: Number of ONBs Found
Req.Doc. CCMECCM Combi- Combi- Combi- Combi-
CCM F2 CCM H2 CCM F3 CCM H3
ADS 2524 25 25 25 25
ABMR 42 3 3 4 4
ARVC 30 3 3 3 3
Oddbotics 40 4 4 4 4
DHS 10440 104 104 104 104
Pacemaker 33 3 3 3 3
Excavator 32 3 3 3 3
5 DISCUSSION AND LIMITATIONS
Weproposedourapproachtoreducehumaneffortsandtimeneeded
toidentifyONBsandcorrectrequirementstomakeasystemfool-
proof.OurapproachusedCCM-EARSrequirementspatternstocon-
vertcommonNLrequirementsintosimple,easy–to–understand,
and verifiable requirements. Based on our example in Section 3
and requirements we created as part of the study, we conclude that
CCM-EARS patterns help users with elicitation if requirements
have missing model elements or details. We also found that tracing
back from rules to CCM-EARS requirements is easier than tracing
back from rules to common natural language requirements. This is
because rules are created by mapping CCM-EARS patterns to rule
patterns, and tracing back to CCM-EARS requirements is done by
mappingrulepatternstorequirementspatterns.Further,wealso
found that CCM-EARS requirements can be reused for analysis
more easily compared to state transition rules or NL requirements.
Wecandrawthefollowingconclusionsfromtheresultsobtained
in our empirical study. First, overall, the results indicate that the
proposedapproachcanreducehumaneffortsandtimebyreducing
the number of states that need to be analyzed manually. Further,
the results also demonstrate that a system with Ncomponents
does not necessarily need N-way combinations to expose all ONBs
because, for most systems, not every component in the systeminteracts with other N-1components. Second, our results imply
that state flattening decreases the number of states that users need
to analyze but increases the number of expanded rules that require
machinepowerratherthanhumanpower.Inthecaseofapproaches
withoutstateflattening,thenumberofexpandedrulesdecreases,
but the number of states that require manual analysis increases.
Therefore,thereisatrade-offinselectingonetechniqueoverthe
other. Because the rules can be analyzed automatically, we can use
state flattening approaches as long as they do not result in rule
explosion problems due to flattening hierarchical states.
While Combi-CCM was able to reduce the number of states
that require manual analysis, the approach can face a scalability
problembecausegivenalargenumberofcomponentsandstates,
Combi-CCMcangenerateaverylargenumberofexpandedrules.
918
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:44 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Kaushik Madala, Hyunsook Do, and Daniel Aceituna
Table 4: Total Number of System Transition Rules to be Analyzed Automatically
Req.Doc. CCM ECCM Combi- Combi- Combi- Combi-
CCM F2 CCM H2 CCM F3 CCM H3
ADS 744163200 51806208 744163200 51806208 744163200 51806208
ABMR 36863 35836 36863 35836 36863 35836
ARVC 263087 136128 263087 136128 263087 136128
Oddbotics 168541 168541 168541 168541 168541 168541
DHS ≈1025≈1017≈1025≈1017≈1025≈1017
Pacemaker 9496 1880 9496 1880 9496 1880
Excavator 116 116 116 116 116 116
Onewaytoaddressthislimitationistogroupthecomponentsthat
interactwitheachotherandanalyzetheirbehaviors.Thissolves
the problem by restricting the state space being analyzed, thereby
reducing the number of system states being generated. Another
alternative is to identify the ONBs first and then expand the rules
thatidentifyONBs.Thiswouldreducethenumberofruleswemust
analyze considerably and thereby addresses scalability problems.
6 RELATEDWORK
Wecanrelateourworktotwotopics.Thefirsttopicismodelslicing,
and the second topic is the methods used to find and expose ONBs.
ModelSlicing: Manytechniqueshavebeenproposedformodel
slicing [22,27,45,46] to reduce the state space being analyzed.
Forexample,Wangetal.[ 45]proposedaslicingmethodforUML
state machinesusing hierarchical automata. The methodremoves
any concurrent states or hierarchies that are not relevant to the
automataandreducesstatespace.Anotherexampleistheslicing
methodproposedbyLano[ 27],whichdividesstatemachinemodels
into smaller and simpler models for analysis by considering the
slicing of the state machine at a higher level of abstraction.
While these methods reduce state space being analyzed, none
ofthemaresuitableforwhenrepresentingthecomponentstates
togetherassystemstates.Therefore,weusedacombinatorialap-
proach to reduce the number of states that people need to analyze.
ONB analysis: To date, different techniques have been proposed
tofindandexposeONBs.ManyresearchershaveanalyzedONBs
usingmodelingtechniquesormodelingframeworksatearlydesign
stages. For example, Kurtoglu et al. [ 25] proposed a functional-
failureidentificationandpropagation(FFIP)frameworktoassess
andevaluateONBsduringtheconceptualdesignstage.FFIPuses
component-drivenhierarchicalmodelinginwhichONBsarechecked
duringbehavioralsimulationusingfunctionalfailurelogic(FFL)[ 25].
Dayetal.[ 7]proposedamethodtomodelONBsusingSysML.Their
approachused SysMLactivity andstatediagrams tomodelONBs,
and then used FMEA [ 40] to analyze ONBs. Other examples in-
cludecorrectness,modeling,andperformanceofaerospacesystems
(COMPASS) approach [ 5], failure mode effects analysis (FMEA) [ 9,
40],failuremode,effectsandcriticalityanalysis(FMECA)[ 6,21],
faulttreeanalysis(FTA)[ 23,31],andprobabilityriskassessment
(PRA)[10].Inadditiontothesemethods,manysimulationbased
models [14, 16, 26] have been used to find ONBs.
Other researchers have used machine learning techniques to
identify ONBs [ 43]. For example, Vemuri et al. [ 16,43] proposed a
neural–networkbasedapproachtoclassifyONBsinrobotmanip-
ulators. In thier method, the robot first learns the series of ONB
conditions and then identifies similar ONBs during simulation.Some researchers have analyzed ONBs as part of testing by
considering them at the experimental design stage. For example,Foyle and Hooey [
13] proposed an off-nominal testing approach
tolocateONBsinsoftwareunderdevelopment.Inthisapproach,
off-nominaleventsbasedonhuman-systeminteractionsarelocated
and then used for testing.
While these techniques are able to find ONBs, none of these
methods provide a systematic way of finding ONBs, and all con-
siderONBsexclusivelyfromahumanpointofview.Unlikethese
approaches, we proposed an systematic approach that considers
off-nominalbehaviorsfromsystem’sviewpointmakingthesystem
more foolproof. The systematic approach we proposed can be used
as requirements acquisition, which can be later used to build a
better formal model.
7 CONCLUSION AND FUTUREWORK
Inthispaper,wehaveproposedCombi-CCM,acombinatorialap-
proachtoreducethenumberofstatesthatrequiremanualanalysistoexposeONBs.WehavealsointroducedtwoCCM-EARSpatterns
tohelpengineerstoelicitinformationwhenwritingcomponent-
driven requirements that are less ambiguous, less wordy, and more
verifiablethancommonnaturallanguagerequirements.Toevaluate
theeffectivenessofourapproach,weconductedanempiricalstudy
using7requirementsspecifications.Ourresultsindicatethatthe
useofcombinatorialtechniquescanreducethenumberofstates
thatrequiremanualanalysiswhilemaintainingtheabilitytoexpose
ONBs.From ourresults,wealso learnedthatwehave toconsider
a trade-off between the number of states that must be manuallyanalyzed and the number of expanded rules that must analyzed
when we choose an ONB detection technique.
WhiletheresultsfromCombi-CCMarepromisingwhencom-
paredto CCMandECCM, theapproachstill hassomelimitations,
asdiscussedinSection5.Aspartoffuturework,weplantoaddress
theselimitationsusingthestrategieswementionedinSection5.In
addition to addressing our limitations, we plan to create a broader
setofCCM-EARSpatternsthatcanaccommodateundesiredbehav-
ior requirements and other types of requirements that can be han-
dled by EARS patterns. We also plan to improve the combinatorial
approach so that it can generate fewer combinations of component
states retaining dependencies among components, especially for
systems that need multiple components to work simultaneously.
Finally, we plan to perform additional experiments using different
types and sizes of requirements documents to better understand
and improve Combi-CCM.
ACKNOWLEDGMENT
This work was supported, in part, by NSF CAREER Award CCF-
1564238 to University of North Texas.
919
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:44 UTC from IEEE Xplore.  Restrictions apply. A Combinatorial Approach for Exposing Off-Nominal Behaviors ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
REFERENCES
[1]D.AceitunaandH.Do.2015. Exposingthesusceptibilityofoff-nominalbehav-
iors in reactive system requirements. In IEEE 23rd International Requirements
Engineering Conference (RE). 136–145. https://doi.org/10.1109/RE.2015.7320416
[2]C.M.Belcastro.2012. ValidationandVerification(V&V)ofSafety-CriticalSystems
Operating under Off-Nominal Conditions. Springer Berlin Heidelberg, Berlin,
Heidelberg, 399–419.
[3]D.M.Berry.2007. Ambiguityinnaturallanguagerequirementsdocuments.In
Monterey Workshop. Springer, 1–7.
[4]Boston Scientific. 2007. PACEMAKER system specification. Technical Report.
Boston Scientific.
[5]Marco Bozzano, Alessandro Cimatti, Joost-Pieter Katoen, Viet Yen Nguyen,
Thomas Noll, and Marco Roveri. 2009. The COMPASS approach: Correctness,
modellingandperformabilityofaerospacesystems.In InternationalConference
on Computer Safety, Reliability, and Security. 173–186.
[6]Reliability Analysis Center. 1993. Failure Mode, Effects and Criticality Analysis
(FMECA). (1993). http://www.dtic.mil/dtic/tr/fulltext/u2/a278508.pdf
[7]J. Day, K. Donahue, M. D. Ingham, A. Kadesch, A. Kennedy, and E. Post. 2012.
Modeling Off-Nominal Behavior in SysML.. In AIAA Infotech. 19–21.
[8]X. Devroey, M. Cordy, P. Schobbens, A. Legay, and P. Heymans. 2015. State
machine flattening, a mapping study and tools assessment. In IEEE Eighth Inter-
national Conference on Software Testing, Verification and Validation Workshops
(ICSTW). 1–8.
[9]V. Estivill-Castro, R. Hexel, and D. A. Rosenblueth. 2012. Failure mode and
effects analysis (FMEA) and model-checking of software for embedded systems
by sequential scheduling of vectors of logic-labelled finite-state machines. In 7th
IETInternationalConferenceonSystemSafety,incorporatingtheCyberSecurity
Conference. 1–6. https://doi.org/10.1049/cp.2012.1510
[10]N. Fenton and M. Neil. 2014. Decision Support Software for Probabilistic Risk
Assessment Using Bayesian Networks. IEEE Software 31, 2 (Mar 2014), 21–26.
https://doi.org/10.1109/MS.2014.32
[11]E.Feuvrier-Danziger,C.Dunkers,M.Kosowski,andD.Marschner.2015. Odd-
botics. (2015). https://sites.google.com/site/mrsdproject201415teamd/documents/
presentations
[12]D.Firesmith.2012. TheNeedtoSpecifyRequirementsforOff-NominalBehaviors.
(2012). https://insights.sei.cmu.edu/sei
[13]D. C. Foyle and B. L. Hooey. 2003. Improving evaluation and system design
throughtheuseofoff-nominaltesting:Amethodologyforscenariodevelopment.
InWright State University. 397–402.
[14]G. C. Fraccone, V. Volovoi, A. E. Colón, and M. Blake. 2011. Novel air traffic
procedures:investigationofoff-nominalscenariosandpotentialhazards. Journal
of Aircraft 48, 1 (2011), 127–140.
[15]A. O. Gomes and M. V. M. Oliveira. 2011. Formal Development of a Cardiac Pace-
maker:FromSpecificationtoCode . SpringerBerlinHeidelberg,Berlin,Heidelberg,
210–225.
[16]D. L. Iverson. 2004. Inductive system health monitoring. In In Proceedings of The
2004 International Conference on Artificial Intelligence (IC-AI04), Las Vegas.
[17]M. Jackson. 2010. DigitalHome Software Requirements Specification. (2010).
http://fmt.isti.cnr.it/nlreqdataset/
[18]E.Jee,I.Lee,andO.Sokolsky.2010. AssuranceCasesinModel-DrivenDevelopment
ofthePacemakerSoftware. SpringerBerlin Heidelberg,Berlin,Heidelberg,343–
356.
[19]D. C. Jensen and I. Y. Tumer. 2013. Modeling and Analysis of Safety in Early
Design.Procedia Computer Science 16 (2013), 824 – 833. https://doi.org/10.1016/j.
procs.2013.01.086 2013 Conference on Systems Engineering Research.
[20]Z.Jiang,M.Pajic,andR.Mangharam.2011. Model-BasedClosed-LoopTesting
of Implantable Pacemakers. In IEEE/ACM Second International Conference on
Cyber-Physical Systems. 131–140. https://doi.org/10.1109/ICCPS.2011.28
[21]Y.Jou,K.Yang,M.Liao,andC.Liaw.2016. Multi-criteriafailuremodeeffectsand
criticality analysis method: a comparative case study on aircraft braking system.
International Journal of Reliability and Safety 10, 1 (2016), 1–21.
[22]H. Kim, D. Bae, V. Debroy, and W. E. Wong. 2011. Deriving Data Dependence
from/for UML State Machine Diagrams. In 5th International Conference on Secure
Software Integration and Reliability Improvement (SSIRI). 118–126.
[23]J. Kloos, T. Hussain, and R. Eschbach. 2011. Risk-Based Testing of Safety-Critical
EmbeddedSystems Drivenby FaultTree Analysis.In IEEEFourth International
Conference on Software Testing, Verification and Validation Workshops. 26–33.
https://doi.org/10.1109/ICSTW.2011.90[24]D.R.Kuhn,R.N.Kacker,andY.Lei.2016.Estimatingt-WayFaultProfileEvolution
During Testing. In IEEE 40th Annual Computer Software and Applications Confer-
ence (COMPSAC), Vol. 2. 596–597. https://doi.org/10.1109/COMPSAC.2016.110
[25]T.KurtogluandI.Y.Tumer.2008. Agraph-basedfaultidentificationandpropaga-
tion framework for functional design of complex systems. Journal of Mechanical
Design130, 5 (2008), 051401.
[26]T.Kurtoglu,I.Y.Tumer,andD.C.Jensen.2010. Afunctionalfailurereasoning
methodology for evaluation of conceptual system architectures. Research in
Engineering Design 21, 4 (01 Oct 2010), 209–234.
[27]K.Lano.2009. SlicingofUMLstatemachines.In Proceedingsofthe9thWSEAS
international conference on Applied informatics and communications. World Scien-
tific and Engineering Academy and Society (WSEAS), 63–69.
[28]Y. Lei, R. Kacker, D. R. Kuhn, V. Okun, and J. Lawrence. 2008. IPOG/IPOG-D:
efficienttestgenerationformulti-waycombinatorialtesting. SoftwareTesting,
Verification and Reliability 18, 3 (2008), 125–148. https://doi.org/10.1002/stvr.381
[29]N.G.Leveson.2004. Roleofsoftwareinspacecraftaccidents. Journalofspacecraft
and Rockets 41, 4 (2004), 564–575.
[30]L.Liu,B.Pan,T.Wang,Q.Li,M.Aktas,andM.Gamell.2012. AutomaticDelivery
System. (2012). http://eceweb1.rutgers.edu/~marsic/books/SE/projects/OTHER/
2012-g4-report3.pdf
[31]H.K.Lo,C.Y.Huang,Y.R.Chang,W.C.Huang,andJ.R.Chang.2005. Reliability
and Sensitivity Analysis of Embedded Systems with Modular Dynamic Fault
Trees. In TENCON - IEEE Region 10 Conference. 1–6. https://doi.org/10.1109/
TENCON.2005.300968
[32]M.Luisa,F.Mariangela,andN.I.Pierluigi.2004. MarketResearchforRequire-
ments Analysis Using Linguistic Tools. Requirements Engineering 9, 1 (2004),
40–56.
[33]K. Madala, H. Do, and D. Aceituna. 2017. Hierarchical Model Exploration for
ExposingOff-NominalBehaviors.In 14thWorkshoponModel-DrivenEngineering,
VerificationandValidation(MoDeVVa)co-locatedwithACM/IEEE20thInternational
Conference on Model Driven Engineering Languages and Systems (MODELS 2017).
[34]A. Mavi, P. Wilkinson, A. Harwood, and M. Novak. 2009. Easy approach to
requirements syntax (EARS). In 17th IEEE InternationalRequirements Engineering
Conference (RE). 317–322.
[35]A. Mavin. 2012. Listen, Then Use EARS. IEEE Software 29, 2 (March 2012), 17–18.
https://doi.org/10.1109/MS.2012.36
[36]A. Mavin and P. Wilkinson. 2010. Big Ears (The Return of "Easy Approach to
RequirementsEngineering").In 18thIEEEInternationalRequirementsEngineering
Conference (RE). 277–282. https://doi.org/10.1109/RE.2010.39
[37]McMaster University. 2007. Pacemaker Formal Methods Challenge. (April 2007).
http://sqrl.mcmaster.ca/pacemaker.htm
[38]M. Melin. 2010. Requirements Specification AB Mail Robot. (2010). http://www.
isy.liu.se/edu/projekt/tsrt10/2010/postrobot-2010/images/general_doc.pdf
[39]E. So, J. Ajtum, Y. Moy, and Y. L.Quach. 2005. Requirements Specification AB
Mail Robot. (2005). http://www.ecs.umass.edu/ece/sdp/sdp05/preston/sdp_data/
Requirement%20Specification.doc
[40]S.TengandS.Ho.1996. Failuremodeandeffectsanalysis:anintegratedapproachforproductdesignandprocesscontrol. Internationaljournalofquality&reliability
management 13, 5 (1996), 8–26.
[41]L.A.Tuan,M.C.Zheng,andQ.T.Tho.2010. ModelingandVerificationofSafety
Critical Systems: A Case Study on Pacemaker. In 4th International Conference on
SecureSoftwareIntegrationandReliabilityImprovement.23–32. https://doi.org/
10.1109/SSIRI.2010.28
[42]A. Valmari. 1998. The state explosion problem. Springer Berlin Heidelberg, Berlin,
Heidelberg, 429–528.
[43]A. T. Vemuri, M. M. Polycarpou, and S. A. Diakourtis. 1998. Neural network
based fault detection in robotic manipulators. IEEE Transactions on Robotics and
Automation 14, 2 (Apr 1998), 342–348. https://doi.org/10.1109/70.681254
[44]S. Verma, S. Lozito, K. Thomas, and D. Ballinger. 2008. Procedures for Off-
Nominal Cases: Very Closely Spaced Parallel Runway Operations. In IEEE/AIAA
27th Digital Avionics Systems Conference (DASC). 2.C.4–1âĂŞ2.C.4–11.
[45]J. Wang, W. Dong, and Z. Qi. 2002. Slicing Hierarchical Automata for Model
Checking UML Statecharts. Lecture Notes in Computer Science 2495 (2002), 435–
446.
[46]N. Yatapanage, K. Winter, and S. Zafar. 2010. Slicing behavior tree models for
verification. Theoretical Computer Science (2010), 125–139.
[47]L. Yu, Y. Lei, R. N. Kacker, and D. R. Kuhn. 2013. Acts: A combinatorial test
generationtool.In 2013IEEESixthInternationalConferenceonSoftwareTesting,
Verification and Validation (ICST). 370–375.
920
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:44 UTC from IEEE Xplore.  Restrictions apply. 