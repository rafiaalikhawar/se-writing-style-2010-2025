Verifying Arithmetic in Cryptographic C Programs
Jiaxiang Liu∗, Xiaomu Shi∗‡, Ming-Hsien Tsai†, Bow-Yaw Wang†and Bo-Yin Yang†
∗College of Computer Science and Software Engineering, Shenzhen University
†Institute of Information Science, Academia Sinica
{jiaxiang0924, xshi0811, mhtsai208 }@gmail.com, {bywang, byyang }@iis.sinica.edu.tw
Abstract —Cryptographic primitives are ubiquitous for mod-
ern security. The correctness of their implementations is crucial
to resist malicious attacks. Typical arithmetic computation
of these C programs contains large numbers of non-linear
operations, hence is challenging existing automatic C veriﬁ-
cation tools. We present an automated approach to verify
cryptographic C programs. Our approach successfully veriﬁes
C implementations of various arithmetic operations used in
NIST P-224, P-256, P-521 and Curve25519 in OpenSSL. During
veriﬁcation, we expose a bug and a few anomalies that have
been existing for a long time. They have been reported to and
conﬁrmed by the OpenSSL community. Our results establish
the functional correctness of these C implementations for the
ﬁrst time.
Keywords -program veriﬁcation; cryptographic programs;
functional correctness; OpenSSL
I. I NTRODUCTION
Cryptographic primitives are the foundation of modern
computer security. They are invoked for authentication, en-
cryption, and key exchange protocols, among others. Unlike
normal programs, typical cryptographic or security settings
always assume an adversary who would take advantage of
any mistakes and run out of his ways to induce errors so as
to launch attacks. As illustrated in [1], even a tiny bug can
have catastrophic impacts. Consequently, the correctness of
cryptographic primitives is of the utmost importance.
Cryptography programming however is far from easy.
Modern cryptography relies on complicated mathematical
constructions. Consider, for instance, Elliptic Curve Cryp-
tography (ECC) [2], [3]. Such cryptosystems are based on
arithmetic over large ﬁnite ﬁelds. Take the elliptic curve
Curve25519 [4] used in OpenSSH [5] as an example. It is
deﬁned over ﬁnite ﬁeld Z2255−19. Each ﬁeld element hence
belongs to the integer set {0,1,..., 2255−20}; sums and
products of two ﬁeld elements are computed by addition and
multiplication modulo 2255−19respectively. A point on
Curve25519 is a pair of ﬁeld elements (x,y)satisfying the
curve equation y2=x3+ 486662 x2+x, or the symbolic
point at inﬁnity . An operation on points called point addition
can then be deﬁned on top of those ﬁeld operations. With
point addition, a group is deﬁned over points on Curve25519.
Point multiplication further takes hundreds of point addition
operations. And it is required by the public-key primitives
‡Corresponding authorover Curve25519, such as those in the default key exchange
protocol in OpenSSH.
Reality is even more complicated than mathematics.
Observe that a ﬁeld element in Z2255−19can be represented
by a 255-bit number. Yet there are no computers with 255-
bit architectures available. In practice, a ﬁeld element is
represented by four 64- or ﬁve 51-bit numbers in 64-bit
architectures. Arithmetic over the ﬁnite ﬁeld has to be im-
plemented on such representations. In such implementations,
ﬁeld multiplication requires several 64-bit multiplication and
addition instructions. Carries must be propagated. Modular
computation must be performed. Cryptography programming
can be very challenging even for experienced programmers.
Curve25519 is but one elliptic curve in ECC. In the
widely used security library OpenSSL [6], cryptographic
primitives based on four different curves over different ﬁnite
ﬁelds are provided. In addition to Curve25519, three NIST-
recommended curves (P-224, P-256, and P-521) are used.
Each curve is deﬁned over its special ﬁnite ﬁeld. Each ﬁnite
ﬁeld has its dedicated C functions for ﬁeld arithmetic. One
wonders if there might be errors in these building blocks of
computer security. Indeed, the OpenSSL source code can
only be modiﬁed by a chosen group of 12 developers for
security purposes [7]. Restricting code commits can reduce
the probability but not remove the possibility of bugs in
the library. Concern about correctness of cryptographic C
programs in OpenSSL thus has some justiﬁcation.
Program veriﬁcation is an active research ﬁeld with
numerous promising ideas. One naturally hopes that all such
programs could be formally veriﬁed. Y et existing techniques
do not appear to be able to verify cryptographic C programs.
Motivating Example. Montgomery reduction [8] is a widely
used algorithm in cryptography programming. Let B=232.
Given integer inputs N,N/primeandTwithNN/prime+1≡0
(modB), Montgomery reduction is an efﬁcient way to
calculate TB−1modNwithout long division. Fig. 1 shows
a simpliﬁed Montgomery reduction algorithm. Observe that
division and modulo by Bare bit shifting and masking
operations respectively for Bis a power of 2. The algorithm
thus computes TB−1modNwith addition, multiplication,
bit shifting and masking operations. Long division by N
is indeed not needed. A reference C implementation is as
follows, where N< 231is assumed for simplicity.
5522019 34th IEEE/ACM International Conference on Automated Software Engineering (ASE)
978-1-7281-2508-4/19/$31.00 ©2019 IEEE
DOI 10.1109/ASE.2019.00058
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. Pre-condition: 0<N<B withN≡1( m o d2 ) ,0<N/prime<B
withNN/prime+1≡0( m o dB), and 0≤T<B N
Post-condition: REDC−(N,N/prime,T)×B≡T(modN)
function REDC−(N,N/prime,T)
m←((TmodB)N/prime)m o dB
t←(T+mN)/B
returnt
Figure 1. Montgomery Reduction
Table I
VERIFYING FUNCTION REDC() WITH SELECTED TOOLS
Conﬁguration Output
CPA-S EQ (SV-COMP2019 version1)
-default -heap 10000M TIMEOUT
-svcomp19 -heap 10000M TIMEOUT
PESC O(SV-COMP2019 version)
-svcomp19-pesco -heap 10000M -stack 2048k TIMEOUT
-svcomp19-pesco-linear -heap 10000MTIMEOUT-stack 2048k
UA UTOMIZER (SV-COMP2019 version)
--architecture 64bit TIMEOUT
SMACK (version 1.9.3)
--verifier boogie FALSE
--bit-precise --verifier boogie TIMEOUT
--verifier corral TIMEOUT
--bit-precise --verifier corral TIMEOUT
--verifier symbooglix FALSE
--bit-precise --verifier symbooglix UNKNOWN2
--verifier duality TIMEOUT
--bit-precise --verifier duality TIMEOUT
1typedef uint64_t u64 ;
2#define B ((u64)1 << 32)
3u64 REDC (u64 N ,u64 Np ,u64 T ){
4 const u64 btm32bits =0xFFFFFFFF ;
5 u64 m =( ( T&btm32bits )*Np)& btm32bits ;
6 u64 t =(T+m*N)> >3 2 ;
7 return t;
8}
The inputs N,NpandTare64-bit integers. Given N<231
and pre-conditions in Fig. 1, we would like to verify whether
REDC(N,Np,T) ×B≡T(mod N). We have tried automatic
C veriﬁcation tools including CPA-S EQ[9], P ESC O[10],
UA UTOMIZER [11], and SMACK [12] on a Linux machine
with 2-core 3.60GHz CPUs and 16GB RAM. No tool can
verify the 8-line C program in 15minutes (Table I). Two
FALSE’s are reported, but the counterexamples turn out to
be spurious. Real cryptographic C programs in OpenSSL
implement operations on ﬁeld elements with hundreds of
bits. Using existing veriﬁcation tools, it is very unlikely to
verify these programs within a reasonable time limit.
1The SV-COMP2019 versions of CPA-S EQ,P ESC Oand UA UTOMIZER
are downloadable at https://sv-comp.sosy-lab.org/2019/systems.php
2Due to a bug of the tool (see the issue at https://github.com/smackers/
smack/issues/427), SMACK did claim that REDC() was veriﬁed. The real
output is UNKNOWN.In order to verify cryptographic C programs, new tech-
niques are needed. In [13], the modeling language C RYP -
TOLINE and its tool for verifying cryptographic assembly
programs are proposed. We leverage the work by translating
LL VM IR programs to C RYPTO LINE and use its tool to verify
cryptographic C programs. More speciﬁcally, the following
steps are needed to verify cryptographic C programs:
1)Submit a cryptographic C program to Clang and
generate a program in LLVM IR.
2)Use our translator to convert the LLVM IR program
to a C RYPTO LINE program.
3)Specify properties about the C program in the generated
CRYPTO LINE program.
4)V erify whether the C RYPTO LINE program conforms
to the speciﬁcation with the C RYPTO LINE veriﬁcation
tool.
Using our translator, the 8-line reference C implementation
for Montgomery reduction (Fig. 1) is veriﬁed within 10sec-
onds. We then apply our approach to the cryptographic C pro-
grams for arithmetic operations over the four elliptic curves
(NIST P-224, NIST P-256, NIST P-521, and Curve25519)
in OpenSSL. 38 cryptographic C functions in OpenSSL are
veriﬁed. The largest function ( x25519_scalar_mult ) has
1153 LL VM IR instructions and is veriﬁed within 50 minutes
on a dedicated Linux server. The function implements the
critical step in the group operation on Curve25519. It takes
5 255-bit ﬁeld elements as inputs and returns 4 255-bit ﬁeld
elements as outputs. Its speciﬁcation consists of three non-
linear multivariate polynomial modulo equations over 45 (=
(5 + 4)×5) 64-bit variables. We are not aware of any other
similar technique at such a scale.
We would like to point out a bug found during veriﬁcation.
In the function felem_diff_128_64 for the NIST P-
521 curve, our approach exposes an overﬂow error in
the implementation. We have reported our ﬁndings to the
OpenSSL developer community. The community conﬁrmed
the bug and released a ﬁx3. To the credits of the community,
we only found one bug and minor anomalies in 3 C functions
out of 38. Yet programming errors did occur in this widely
used and inspected security library. One can never be too
careful about security libraries.
Our Contributions. We identify a useful subset of LLVM
IR (called LLVM CRYPTO ) to model intermediate repre-
sentations of cryptographic programs emitted from Clang.
LL VM CRYPTO contains the most common instructions used in
implementations of arithmetic operations. These instructions
however form the core of many public-key cryptographic
programs. Using LL VM CRYPTO , a number of cryptographic
programs are modeled.
Given an LL VM CRYPTO program, we develop a translator
to translate it into a C RYPTO LINE program. C RYPTO LINE is
3https://github.com/openssl/openssl/commit/
13fbce17fc9f02e2401fc3868f3f8e02d6647e5f
553
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. designed for cryptographic assembly programs, not LL VM IR.
In particular, C RYPTO LINE does not allow pointer arithmetic
found in LLVM CRYPTO . Such LLVM CRYPTO features are
translated to C RYPTO LINE automatically. A soundness
theorem is established for our translator. It guarantees that no
bug will be missed if a program is veriﬁed by our approach.
Our case studies include 38 C functions from NIST P-224,
P-256, P-521, and Curve25519 in OpenSSL. To the best of
our knowledge, this is the ﬁrst automated approach which
can verify the correctness of these cryptographic C programs.
We also expose a bug and two incorrect input assumptions
in the NIST P-521 implementations.
In the rest of the paper, after introducing LLVM CRYPTO
in Section II, we review C RYPTO LINE in Section III. The
translation is addressed in Section IV, while case studies are
detailed in Section V. Conclusion comes in Section VII.
II. LL VM CRYPTO –AS UBSET OF LLVM IR
LLVM [14] is an open-source project for modular com-
pilation and related technologies. It is based on a code
representation called LLVM IR (for LLVM Intermediate
Representation). V ery roughly, any C program is represented
in LLVM IR for code transformations and optimizations.
For cryptographic C programs, the full LLVM IR is
not necessary. We examine the intermediate representations
generated after architecturally independent optimizations
in Clang, and identify a useful subset of LLVM IR for
cryptographic C programs, called LLVM CRYPTO . In this
section, we present LLVM CRYPTO and give its formal
semantics.
A. Notations
LetN,N+andZdenote the set of non-negative, positive,
and all integers, respectively. We use [n]to denote the set
{0,1,...,n−1}forn∈N+.a÷bandamodbdenote the
quotient and non-negative remainder of adivided by b. That
is, we have a=b×(a÷b)+(amodb)with 0≤amodb<
b. Letf:A→Bbe a function. For a∈Aandb∈B,
deﬁne the function f[a←b]:A→Bby
f[a←b](x)=/braceleftbigg
b ifx=a
f(x)otherwise .
B. Syntax
LLVM IR is a strongly typed language. In addition to
variables and constants, it supports pointers and vectors. In
cryptographic C programs, arithmetic computation, bitwise
masking and shifting are widely used. We consider the subset
LLVM CRYPTO that is useful to the compilation of these
programs. The syntax of LLVM CRYPTO is shown in Fig. 2.
We usex,y,z,... for variables and p,q,... for pointers.
An argument ( Arg ) can be a variable or a number. Let
/lscript∈N+. An argument for a vector of size /lscript(Argv (/lscript)) can be a
vector variable or a sequence of /lscriptnumbers. In LL VM CRYPTO ,
operands and the result of each instruction can be 64-o rNum ::= 0|1|2|··· Var ::=x|y|z|···
Ptr::=p|q|··· Width ::= 64|128
Arg ::=Var|Num Argv (/lscript) ::= Var|Num/lscript
Inst ::=Var= add Width Arg Arg
|Var= addv < /lscriptxWidth >Argv (/lscript)Argv (/lscript)
|Var= sub Width Arg Arg
|Var= subv < /lscriptxWidth >Argv (/lscript)Argv (/lscript)
|Var= mul Width Arg Arg
|Var= mulv < /lscriptxWidth >Argv (/lscript)Argv (/lscript)
|Var= shl Width Arg Num
|Var= lshr Width Arg Num
|Var= and Width Arg Arg
|Var= load Width Ptr
|Var= loadv < /lscriptxWidth >Ptr
|store Width Arg Ptr
|storev < /lscriptxWidth >Argv (/lscript)Ptr
|Ptr= geteltptr Width Ptr Num
|Ptr=geteltptrv < /lscriptxWidth >Ptr Num Num
|Var= trunc Arg
|Var= zext Arg
|Var= insertelt < /lscriptxWidth >Argv (/lscript)Arg Num
Prog ::=Inst;|Inst;Prog
Figure 2. The Syntax of LLVM CRYPTO
128-bit values, speciﬁed by the instruction syntactically. For
instance, the instruction y= add 64a1a2adds the 64-bit
operands a1,a2together, and assigns the sum to the 64-bit
variabley. On the other hand, y= add 128a1a2has128-bit
operands and result.
Letw∈{64,128}.y= addv < /lscriptxw>a1a2computes
the element-wise sum of the vectors a1anda2, and assigns
the result to the vector variable ywhose/lscriptelements are of
bit width w. The instructions sub andmul , as well as their
vector versions subv andmulv , work similarly.
Two bitwise shifting instructions are deﬁned in LLVM -
CRYPTO .y= shlwan shifts the w-bit operand ato the
left byn<w bits, and stores the result as a w-bit value in
y. Instruction lshr on the other hand shifts to the right. The
bitwise AND instruction is y= andwa 1a2.
The instruction y= load wp loads the w-bit value
from pointer p. To load a vector of w-bit values, y=
loadv < /lscriptxw>pis used. The instructions store and
storev store values into the memory.
One can obtain the pointer to an element of a vector
stored in memory. q= geteltptr wpn makesqpoint
to then-thw-bit element of the vector designated by p.I f
ppoints to a vector whose elements are vectors of size /lscript,
q= geteltptrv < /lscriptxw>pn1n2setsqto the pointer at
then2-th element of the n1-th vector designated by p.
The instruction y= trunc atruncates the 128-bit value a
554
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. to the low 64bits and stores the result in the 64-bit variable
y.y= zextaextends the 64-bit operand ato128 bits.
Finally, the instruction y= insertelt < /lscriptxw>a1a2k
assigns to ythe/lscript-long vector identical to a1except that its
k-th element is a2wherek</lscript .A n LL VM CRYPTO program
is simply a sequence of instructions separated by semicolons.
There are no control-ﬂow instructions like branching in
LLVM CRYPTO . Those are avoided in typical cryptographic
programs for side-channel attack prevention.
Example. The ﬁle ecp nistp521.c in OpenSSL implements
the NIST P-521 elliptic curve over the prime p521=2521−1.
In this implementation, a ﬁeld element ais represented as
a0+a1×258×1+a2×258×2+···+a8×258×8using nine
64-bit limbsai’s. The following LLVM CRYPTO fragment
is extracted from the LLVM IR code of the C function
felem_diff64 . It subtracts a ﬁeld element yrepresented by
y0,...,y 8from the ﬁeld element xrepresented by x0,...,x 8.
The result is then stored in the memory designated by pout.
1:v0= sub 64 4611686018427387872 y0;
2:v/prime
0= add 64v0x0;
3:q0= geteltptr 64pout0;
4: store 64v/prime
0q0;
The fragment only shows the operations on the least signif-
icant limb. y0is subtracted from a constant at line 1. The
result is added to x0at line 2. Line 3 computes q0pointing
to the 0-th64-bit element of the memory designated by pout.
The calculation result v/prime
0is stored to the memory cell pointed
byq0at line 4.
An LL VM CRYPTO program is in SSA form (Static Single
Assignment ) if its variables and pointers are deﬁned at most
once. Any LLVM IR program generated from Clang is in
SSA form.
C. Semantics
Similar to its syntax, the semantics of LLVM CRYPTO is
designed for cryptographic C programs. Observe that ﬁeld
elements in OpenSSL are represented by unsigned integers.
Our semantics is hence deﬁned over unsigned numbers. We
moreover assume the underlying architecture is 64-bit for
simplicity. Each memory cell represents a value in [264].I t
is straightforward to modify the semantics of LL VM CRYPTO
for32-bit architectures.
We give a small-step semantics for LLVM CRYPTO . Let
σ∈V/defines(Var∪Ptr)→Nbe a valuation , andm∈M/defines
N→[264]amemory state .S/definesV×M is the set of states .
A valuation formalizes the values of variables and pointers.
The content of memory cells is modeled by a memory state.
Our semantics speciﬁes how a state transits to another by
executing each instruction. Fig. 3 gives the semantics of
LLVM CRYPTO .Givenσ∈V , we deﬁne the semantic function /llbracket•/rrbracketσfor
numbers, variables and pointers as follows.
/llbracketa/rrbracketσ=/braceleftbigga ifa∈Num
σ(a)ifa∈Var∪Ptr
From the state (σ,m), the instruction y= addwa 1a2
moves to the state (σ/prime,m)whereσ/primeupdates the value of y
to(/llbracketa1/rrbracketσ+/llbracketa2/rrbracketσ)m o d2w. The sum is truncated to wbits
by modulo 2w. Other variables in σremain unchanged in
σ/prime.
More notations are needed for vectors. For /lscript∈N+and
v∈Num/lscript,v[i]denotes the i-th element of vwheni∈[/lscript].
We also use the variable x[i]for thei-th element of the
vector variable x∈Var . Given a valuation σandn∈N, the
notationσ[ai←bi]n
i=0is short for σ[a0←b0]···[an←bn].
The semantics of y= addv < /lscriptxw>a1a2should now be
clear. It updates the vector variable ywith the element-wise
sum of vectors a1,a2; and each element sum is truncated to a
w-bit value. The semantics for subtraction and multiplication
is similar and omitted from Fig. 3 for clarity. The semantics
for bitwise instructions shl ,lshr andand is obvious.
In our memory model, addresses are natural numbers and
memory cells are elements in [264]because we assume a
64-bit architecture. Let m∈M be a memory state and
n,v∈N, we use the following notations for convenience:
m64(n)/definesm(n)
m64[n←v]/definesm[n←vmod 264]
m64(n)reads the memory cell located at the address n;
m64[n←v]updates the cell located at nwith the value v.
InLL VM CRYPTO , we also need to interpret two consecutive
memory cells as a 128-bit value. We choose the little-endian
representation in our semantics. Deﬁne:
m128(n)/definesm(n+1 )×264+m(n)
m128[n←v]/definesm[n←vL][n+1←vH]
wherevL=vmod 264andvH=(v÷264)m o d264. Hence
m128(n)reads a 128-bit value from the memory cells located
atn;m128[n←v]updates the memory cells located at n
with the 128-bit value v.
The semantics of y= loadwp can now be explained. It
updatesyby thew-bit value in the memory cell designated
byp. To load a vector of values, deﬁne size(w)/definesw÷64
for the number of memory cells needed for w-bit values. By
y= loadv < /lscriptxw>p, the vector variable yis updated with
/lscriptw-bit values from the memory cells designated by p. The
instructions store andstorev are deﬁned similarly
Ifppoints to a vector of w-bit values in memory, the
n-th element is located at /llbracketp/rrbracketσ+/llbracketn/rrbracketσ×size(w). This is
exactly what q= geteltptr wpn computes. geteltptrv
is deﬁned similarly when ppoints to a vector of vectors.
The semantics of instructions trunc andzext is straight-
forward. Finally, y= insertelt < /lscriptxw>a1a2kcopies
555
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. (σ,m )y= addwa 1a2−−−−−−−−−−− → (σ/prime,m)whereσ/prime=σ[y←(/llbracketa1/rrbracketσ+/llbracketa2/rrbracketσ)m o d2w]
(σ,m )y= addv < /lscriptxw>a1a2−−−−−−−−−−−−−−− → (σ/prime,m)whereσ/prime=σ[y[i]←(/llbracketa1[i]/rrbracketσ+/llbracketa2[i]/rrbracketσ)m o d2w]/lscript−1
i=0
(σ,m )y= shlwan−−−−−−−−− → (σ/prime,m)whereσ/prime=σ[y←(/llbracketa/rrbracketσ×2/llbracketn/rrbracketσ)m o d2w]
(σ,m )y= lshr wan−−−−−−−−−− → (σ/prime,m)whereσ/prime=σ[y←/llbracketa/rrbracketσ÷2/llbracketn/rrbracketσ]
(σ,m )y= andwa 1a2−−−−−−−−−−− → (σ/prime,m)whereσ/prime=σ[y←/llbracketa1/rrbracketσband /llbracketa2/rrbracketσ]
(σ,m )y= load wp−−−−−−−− → (σ/prime,m)whereσ/prime=σ[y←mw(/llbracketp/rrbracketσ)]
(σ,m )y= loadv < /lscriptxw>p−−−−−−−−−−−−− → (σ/prime,m)whereσ/prime=σ[y[i]←mw(/llbracketp/rrbracketσ+i×size(w))]/lscript−1
i=0
(σ,m )storewap−−−−−−−− → (σ,m/prime) wherem/prime=mw[/llbracketp/rrbracketσ←/llbracketa/rrbracketσ]
(σ,m )storev < /lscriptxw>ap−−−−−−−−−−−− → (σ,m/prime) wherem/prime=mw[/llbracketp/rrbracketσ+i×size(w)←/llbracketa[i]/rrbracketσ]/lscript−1
i=0
(σ,m )q= geteltptr wpn−−−−−−−−−−−−− → (σ/prime,m)whereσ/prime=σ[q←/llbracketp/rrbracketσ+/llbracketn/rrbracketσ×size(w)]
(σ,m )q= geteltptrv < /lscriptxw>pn 1n2−−−−−−−−−−−−−−−−−−−− → (σ/prime,m)whereσ/prime=σ[q←/llbracketp/rrbracketσ+/llbracketn1/rrbracketσ×/lscript×size(w)+ /llbracketn2/rrbracketσ×size(w)]
(σ,m )y= trunc a−−−−−−−→ (σ/prime,m)whereσ/prime=σ[y←/llbracketa/rrbracketσmod 264]
(σ,m )y= zext a−−−−−−−→ (σ/prime,m)whereσ/prime=σ[y←/llbracketa/rrbracketσ]
(σ,m )y= insertelt < /lscriptxw>a1a2k−−−−−−−−−−−−−−−−−−−− → (σ/prime,m)whereσ/prime=σ[y[i]←/llbracketa1[i]/rrbracketσmod 2w]/lscript−1
i=0[y[k]←/llbracketa2/rrbracketσmod 2w]
Figure 3. Semantics of LLVM CRYPTO
the vector a1of/lscriptw -bit values to yand then updates the
k-th element of ywith thew-bit value a2.
III. D OMAIN -SPECIFIC LANGUAGE CRYPTO LINE
CRYPTO LINE [13] is a domain-speciﬁc language for
cryptographic assembly programs and their veriﬁcation. It
is equipped with an automatic veriﬁcation tool. We brieﬂy
review the language and its veriﬁcation in this section.
A. The Language
CRYPTO LINE serves as an abstraction for cryptographic
assembly programs across different architectures. Details such
as registers and address modes are ignored in the language.
For simplicity, it only considers variables, numbers and
ﬂags. Typical arithmetic assembly instructions are modeled
in C RYPTO LINE. Fig. 4 gives the syntax of the language.
The semantics of C RYPTO LINE is parameterized by the bit
width of the underlying architecture. To be consistent with
LL VM CRYPTO , the semantics of C RYPTO LINE is explained
here for 64-bit architectures. All arguments ( Arg ) are hence
assumed 64-bit. The formal semantics can be found in [13].
AC RYPTO LINE state models the current values of vari-
ables and ﬂags ( clFlag ).Set is the assignment statement and
Cset is the conditional assignment. Carry and borrow ﬂags are
explicit in C RYPTO LINE.Addbxuv sets the sum of uandv
toxwith carry in b.Adc is the addition-with-carry statement.
Sub and Sbb are subtraction and subtraction-with-borrow
statements, respectively. Full multiplication Mulfxyuv
updatesxandywith the high and low 64 bits of the product
ofuandv, respectively. And is the bitwise AND statement.
Shlxun shifts the value of uto the left by nbits and
assigns the result to xif the high nbits ofuare all zero;
otherwise the C RYPTO LINE program goes into the error
state .clFlag ::=b|c|d|···
clExp ::= Arg|clExp +clExp|clExp−clExp
|clExp∗clExp
clPred ::= clExp =clExp|clExp≡clExp mod clExp
|clExp<clExp|clExp≤clExp|clPred∧clPred
clStmt ::= Set Va r A rg |Cset V ar clFlag Arg Arg
|Add clFlag V ar Arg Arg
|Adc clFlag V ar Arg Arg clFlag
|Sub clFlag V ar Arg Arg
|Sbb clFlag V ar Arg Arg clFlag
|Mulf V ar V ar Arg Arg |And V ar Arg Arg
|Shl V ar Arg Num |Split V ar V ar Arg Num
|Assert clPred |Assume clPred
clProg ::=/epsilon1|clStmt ;clProg
Figure 4. C RYPTO LINE Statements and Programs
Split is provided to model common patterns of assembly
code in cryptographic programs. The statement Splitxyun
splits the value of uinto two parts: the low nbits are moved
toyand the remaining high bits are moved to x.
For veriﬁcation purposes, C RYPTO LINE supports asser-
tions and assumptions. Predicates ( clPred )e1=e2and
e1≡e2mode3are algebraic properties. e1<e 2and
e1≤e2are range properties. Assert pred checks if the
predicate pred holds in the current state. If so, the execution
continues with the same state. Otherwise, it enters the error
state. Assume pred on the other hand assumes pred holds
at the current program location, thus the execution continues
with states satisfying pred . No predicate is satisﬁed in the
error state. A common usage for assertions and assumptions
is to add external information for veriﬁcation. Let us assume,
556
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. say,answer =4 2 at some program location but this predicate
is obscure. In C RYPTO LINE, a human veriﬁer can assert the
predicate and then assume it to pass the predicate to the
veriﬁcation tool. The assertion ensures the predicate indeed
holds at the location; the assumption then adds the predicate
as a lemma for veriﬁcation.
AC RYPTO LINE program is simply a sequence of C RYP -
TOLINE statements followed by semicolons.
B. V eriﬁcation with Speciﬁcations
In addition to programs, C RYPTO LINE allows to specify
pre- and post-conditions using predicates ( clPred ). Pre- and
post-conditions together compose speciﬁcations . Given a
CRYPTO LINE program with its speciﬁcation, we would like
to know if the program will end in a state satisfying the
post-condition whenever it starts from a state satisfying the
pre-condition. The C RYPTO LINE veriﬁcation tool checks
if a C RYPTO LINE program conforms to its speciﬁcation
automatically.
Example (continued) .According to the comments of
felem_diff64 in ecp nistp521.c, the pre-condition of the
program is the range property/logicalandtext8
i=0yi<259+214. Assume
that the nine consecutive memory cells designated by poutare
represented by variables addrp0,addrp1,..., addrp8
(explained later). The post-condition of the C RYPTO LINE
program generated from felem_diff64 is
((addrp0<x 0+262)∧···∧ (addrp8<x 8+262))
∧(radix 58(x0,x1,...,x 8)−radix 58(y0,y1,...,y 8)
≡radix 58(addrp0,..., addrp8)modp521)
whereradix 58(a0,a1,...,a 8)=a0+a1×258×1+a2×
258×2+···+a8×258×8denotes the ﬁeld element represented
byai’s. The ﬁrst part of the post-condition is a range property.
The second part is an algebraic property stating that the result
element is a difference between the inputs over the prime
p521.
IV . T RANSLA TING LL VM CRYPTO TO CRYPTO LINE
Given an LLVM CRYPTO program, we ﬁrst translate it
into a C RYPTO LINE program in order to verify with the
CRYPTO LINE veriﬁcation tool. The soundness property of
the translation means that the generated program captures
all behaviors of the input one, being an over-approximation
of it. We introduce the translation and discuss its soundness
in this section.
A. Symbolic Memory Addresses
In C RYPTO LINE and its semantics model, there are no
pointers or memory. But it is different in LLVM CRYPTO .
Both pointers and memory are considered, which is closer to
reality. We bridge this gap by representing memory addresses
symbolically then using these symbols to translate pointers.AssumeSVar={ p, q,...}is a set of symbolic variables .
A/definesSVar×Zis called the set of symbolic (memory)
addresses . A symbolic address ( p,o)∈Arepresents the
memory address having an offset ofrom the memory address
represented by ( p,0)∈A.I n LL VM CRYPTO , a pointer is only
allowed to be added with a constant offset. Hence we deﬁne
the addition +A:A×Z→Aas( p,o1)+Ao2/defines( p,o1+o2),
where ( p,o1)∈Aando2∈Z. This is sufﬁcient to model
pointer calculations in LLVM CRYPTO . For instance, the
following two instructions are commonly used for accessing
thei-th element of the array adesignated by pointer p:
q= geteltptr 64pi;
y= load 64q;
whereyis the value of a[i].I fprefers to the memory address
np,qwill have the value nq=np+iaccording to the
semantics. If npis symbolically represented by ( p,op), our
translation algorithm is sufﬁcient to calculate nq’s symbolic
address as ( p,oq)=( p,op)+Ai. Even though symbolic
addresses cannot capture complete information about memory
addresses, they reﬂect the relationships between the absolute
memory addresses. For example, the offset ibetweennpand
nqis preserved for their symbolic representations.
We deﬁne a pointer table ptas a mapping from pointers
Ptr to symbolic addresses A. It models the valuation of
pointers and helps alias analysis in the translation algorithm.
pt(p)models the memory address represented by p.
B. Translation Algorithm
Assume the pointer table ptmodels the valuation of
pointers before executing an LL VM CRYPTO instruction s. The
function I NST TOCLPROG (pt,s ) translates sinto a sequence
cpof C RYPTO LINE statements. It returns a pair /angbracketleftpt/prime,cp/angbracketright,
wherept/primemodels the valuation of pointers after executing
s.pt/primereﬂects the effect on pointers when executing swith
respect to the LLVM CRYPTO semantics. We then translate
ag i v e n LLVM CRYPTO program by sequentially applying
INST TOCLPROG () to each instruction. We summarize the
translation for 64-bit LLVM CRYPTO instructions as in Ta-
ble II.
The translation of arithmetic instructions is straightforward.
For example, the instruction add is translated to the statement
Add . Note that carries are not present in LLVM CRYPTO .
Hence the introduced carry ﬂag is discarded using a fresh
named. But the value of ddoes indicate the presence of over-
ﬂow when executing the add instruction. Since the instruction
add does not change pointers, ptremains the same after
executing add . The instruction y= addv < /lscriptx64>a1a2
adds two vectors a1anda2of length /lscript. It is equivalent to /lscript
add instructions on each pair of a1[i]anda2[i]. Hence we
have it translated to /lscriptAdd statements.
The translation of bitwise shifting is a little subtle. The
instruction shl has similar semantics as Shl, except that Shl
may cause an error that is undesired by shl . To avoid that,
557
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. Table II
SUMMARY OF INST TOCLPROG (pt,s ),THE 64-BIT CASE
Instruction s Output/angbracketleftpt/prime,cp/angbracketright
y= add 64a1a2 /angbracketleftpt, Adddya 1a2;/angbracketright
y= addv < /lscriptx64>a1a2 /angbracketleftpt, sequence of Add ’s/angbracketright
y= shl 64an /angbracketleftpt, Splitzdta(64−n);
Shlytn ;/angbracketright
y= lshr 64an /angbracketleftpt, Splityzdan;/angbracketright
y= and 64a1a2 /angbracketleftpt, Andya1a2;/angbracketright
y= load 64p /angbracketleftpt, Sety/llparenthesispt(p)/rrparenthesisV;/angbracketright
y= loadv < /lscriptx64>p /angbracketleftpt, sequence of Set’s/angbracketright
q= geteltptr 64pn /angbracketleftpt[q←pt(p)+An],/epsilon1/angbracketright
y= trunc a /angbracketleftpt, SetyaL;/angbracketright
y= zexta /angbracketleftpt, SetyLa;
SetyH0;/angbracketright
y= insertelt < /lscriptx64>a1a2k/angbracketleftpt, sequence of Set’s/angbracketright
the highnbits ofaare discarded ﬁrst by Split using the fresh
variablezd. Then the remaining low 64−nbits stored in the
temporary variable tcan be safely shifted to the left by n
bits. Similar translation is applied for lshr . The translation
forand is trivial.
To translate an instruction involving memory, the memory
cell is referred to using a C RYPTO LINE variable. Assume
that we have a one-to-one function /llparenthesis•/rrparenthesisV:A→Var .I t
converts each symbolic address into a C RYPTO LINE variable.
For example, /llparenthesis( p,1)/rrparenthesisV=addrp1in our implementation.
Now the translation for y= load 64pis straightforward.
yis assigned with the variable /llparenthesispt(p)/rrparenthesisV, which represents
the value in the memory cell indexed by p. The vector
version loadv is translated in the same way as addv . Again,
load does not change pointers, ptremaining unchanged.
The instructions store andstorev are treated similarly,
omitted in Table II.
When translating q= geteltptr 64pn, we obtain the
symbolic address pt(p)and add it with offset n×size(64) =
n. Then the value of qinptis updated with the result. No
CRYPTO LINE statement is required since it does not modify
variables or memory, hence cp=/epsilon1. The translation for
geteltptrv is similar and hence omitted.
Given any 128-bit LL VM CRYPTO variabley,t w oC RYPTO -
LINE variables yLandyHare used to represent its low and
high 64bits, respectively, in the translation. The same applies
to any number, thus any argument. Then it is straightforward
to translate instructions trunc andzext with Set statements.
As well, Set statements are used to translate insertelt by
copying each element of a1toywith thek-th element y[k]
assigned by a2.
For128-bit instructions, the idea is the same but more
technical. For instance, when translating a 128-bitadd ,t w o
64-bit Add ’s are required to mimic 128-bit addition. One
128-bitload needs two Set’s to copy two consecutive cellsfunction PROG TOCLPROG (prog )
Construct pt0with prog
Letprog =s1;s2;···;sn;
fori←1tondo
/angbracketleftpti,cpi/angbracketright← INST TOCLPROG(pti−1,si)
return (cp1cp2···cpn)
Figure 5. Translation of LLVM CRYPTO Programs
toyLandyH. The technicalities are not detailed here.
Given an LLVM CRYPTO program prog , a variable or a
pointer is undeﬁned if it is not assigned by any instructions
inprog . Undeﬁned variables (denoted by VarU) and pointers
(byPtrU) are usually the input variables and pointers of the
program.
Now the LLVM CRYPTO program translation is straight-
forward with I NST TOCLPROG (). The algorithm is depicted
in Fig. 5. We ﬁrst construct the initial pointer table pt0
as a mapping that maps each pj∈PtrUinprog ,t ot h e
symbolic address ( pj,0). All pj’s are distinct. With pt0, the
algorithm starts from the ﬁrst instruction s1. An updated
pointer table pt1and a fragment of C RYPTO LINE program
cp1are obtained. It then continues to translate the next
instruction s2withpt1.ptiis obtained at the i-th iteration.
It actually models the valuation of pointers after executing i
instructions of prog . Finally, all cpi’s are combined in order
as the output C RYPTO LINE program.
Example (continued) .Given the whole LL VM CRYPTO pro-
gram, we know that pout is an undeﬁned pointer. We let
pt0(pout)=( p,0)when constructing pt0. According to the
translation algorithm, pt2=pt1=pt0after translating lines 1
and 2. Line 3 is translated into no C RYPTO LINE statements,
but updates q0inpt3withpt3(q0)=pt2(pout)+A0=
( p,0). Let /llparenthesis( p,0)/rrparenthesisV=addrp0. The LLVM CRYPTO pro-
gram fragment is translated into the following C RYPTO LINE
program fragment by our algorithm:
1a: Subd0v04611686018427387872 y0;
2a: Addd1v/prime
0v0x0;
4a: Setaddrp0v/prime
0;
C. Soundness
Given an initial state (σ0,m0),a n LL VM CRYPTO program
iswell-formed if (1) all its undeﬁned variables and undeﬁned
pointers have their values in σ0; and (2) it is in SSA form.
We make an assumption on how programs access the
memory.
Separation Assumption. The memory is divided into several
isolated segments. Each segment πjcontains one base address
designated by an undeﬁned pointer pj∈PtrU. Letpt0(pj)=
( pj,0). Every address in πjisuniquely represented by the
symbolic address ( pj,o)for some o∈Zduring translation.
This assumption is indeed common in cryptographic
programs. Assume that a cryptographic arithmetic function
558
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. has two arrays aandbas parameters. Pointers paandpbare
the inputs pointing to their base addresses, i.e. the addresses
ofa[0]andb[0]. Then the address of a[i]can be, and is
always, calculated via pa. No one will do this via pb. The
separation assumption is inspired by separation logic [15].
Given an LLVM CRYPTO program prog with initial state
(σ0,m0),w eu s e (σi,mi)to denote the state after executing
the ﬁrstiinstructions. That is, for the i-th instruction si
ofprog ,w eh a v e (σi−1,mi−1)si− →(σi,mi). We deﬁne a
simulation relation /precedesorcurlybetween LLVM CRYPTO states (σ,m)
and C RYPTO LINE statesρ.(σ,m)/precedesorcurlyρreads as (σ,m)is
simulated by ρ.(σ,m)/precedesorcurlyρholds if the values of variables
and the content of memory in (σ,m)are correctly projected
intoρ. For example, given a 128-bit LL VM CRYPTO variable
x, its corresponding 64-bit representations xLandxHin
CRYPTO LINE should satisfy ρ(xL)+ρ(xH)×264=σ(x).
We prove the soundness property of our translation via
the following theorem:
Theorem 1. Given Separation Assumption and a well-
formed LLVM CRYPTO program prog with initial state
(σ0,m0). The generated CRYPTO LINE program clprog =
PROG TOCLPROG(prog)=( cp1···cpn)satisﬁes:
(i) for alli∈[0,n], there exists a CRYPTO LINE stateρi
ofclprog such that (σi,mi)/precedesorcurlyρi;
(ii) for alli∈[1,n]andρwith (σi−1,mi−1)si− →(σi,mi)
and(σi−1,mi−1)/precedesorcurlyρ, there exists ρ/primesuch that ρcpi− − →
ρ/primeand(σi,mi)/precedesorcurlyρ/prime.
Theorem 1 guarantees that after translation, (1) each state
of the input LLVM CRYPTO program has its corresponding
simulation C RYPTO LINE state(s) of the generated program;
(2) each execution trace of the input LL VM CRYPTO program
has its corresponding simulation trace(s) of the generated
CRYPTO LINE program. Therefore, all the behaviors of the
input program are captured by the generated one.
With Theorem 1, assume that the given LLVM CRYPTO
program prog hasninstructions. If a property Pllvm does
not hold in the ﬁnal state (σn,mn), then there must exist a
CRYPTO LINE stateρn(with (σn,mn)/precedesorcurlyρn) of the generated
program and a trace to ρn, such that the corresponding
property Pcldoes not hold in ρneither. In other words, if
the veriﬁcation tool veriﬁes that Pclholds in all possible
ﬁnal states ρn’s (even if (σn,mn)/negationslash/precedesorcurlyρn) along all possible
execution traces of the generated C RYPTO LINE program,
thenPllvm is guaranteed to hold in (σn,mn)of the input
prog . Therefore, if our veriﬁcation result shows that the
generated C RYPTO LINE program is correct with respect
to the speciﬁcation, it implies that the input LLVM CRYPTO
program is also correct. Hence the input C program is correct.
D. Implementation Heuristics
Although our translator is fully automatic, extra human
effort is sometimes needed to get the generated C RYPTO LINE
programs veriﬁed due to limitations of the C RYPTO LINEveriﬁcation tool. In our ﬁrst implementation of the translator,
we found that it took large amounts of human work to
verify the generated C RYPTO LINE programs. However, most
of the work was repetitive and tedious. We develop four
kinds of heuristics to reduce human efforts in the current
implementation, including heuristics for speciﬁc bitwise
shifting, for special and , for overﬂow/underﬂow, and for the
and -after- lshr pattern. The former two apply specialized
translation when the arguments of the input instruction have
speciﬁc values. The latter two are detailed as follows. We
stress that all the heuristics retain the soundness property of
our veriﬁcation results.
1) Heuristics for Overﬂow/Underﬂow: In the translation
ofadd ,sub andmul , we introduce carry/borrow ﬂags that
indicate the presence of overﬂow/underﬂow in the input
LLVM CRYPTO instructions. For example, when translating
y= add 64a1a2, the statement Adddya 1a2is used.
A new ﬂag dis introduced that indicates the presence of
overﬂow in add . But in most cases in cryptographic programs,
such an overﬂow will not happen thanks to the careful range
assumptions on inputs. Nevertheless, it is difﬁcult for the
CRYPTO LINE tool to deduce d=0 automatically and use
this information to verify speciﬁed properties. Our heuristic
hence automatically inserts the following two C RYPTO LINE
statements for each ﬂag dof such a kind during translation:
Assertd=0 ; Assumed=0 ;
The Assert statement tells C RYPTO LINE to check whether d
is0. If it is, then Assume utilizes this information to ease the
veriﬁcation. Only if it is not, an overﬂow may arise. Human
efforts hence are needed to investigate the problem.
This heuristic also applies to the translation of shl for
the same reason, to check whether the value of zdequals 0.
2) Heuristics for and -after- lshr :In cryptographic pro-
grams, a masking and instruction often follows an lshr
instruction to perform a splitting together. For instance, the
following pattern is common:
y1= lshr 64a51;
y2= and 64a0x7FFFFFFFFFFFF;
y1andy2get the high 13 bits and the low 51 bits, respectively,
ofa. By our translation algorithm, they are translated to:
Splity1zda51;
Andy2a0x7FFFFFFFFFFFF;
But C RYPTO LINE requires the extra information zd=y2to
pass the veriﬁcation. We implement heuristics to insert the
following statements automatically to help the veriﬁcation:
Assertzd=y2; Assumezd=y2;
Note that in practice, the instructions lshr andand
may not be adjacent. They may not have exactly the same
aas operands. And several pairs of lshr andand may
even interleave. It makes this and -after- lshr pattern more
559
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. complicated. The implemented simple heuristic only relates
and to the previous lshr . However, it works in most of
the scenarios we have encountered. A more precise analysis
of the pattern can further improve the automation of our
technique.
V. E V ALUA TION
We have implemented our translator on LLVM 3.7.0 and
successfully applied our approach to 38 C implementations
of arithmetic operations in cryptographic primitives of
OpenSSL 1.1.1. Among them, 35 are veriﬁed. One bug
and several anomalies are exposed and conﬁrmed in the
remaining 3 functions.
A. Experiment Setup
The veriﬁcation proceeded in the following way. Given
a C implementation of an arithmetic operation, ﬁrst we
compiled it into LL VM IR using Clang 3.7.0. Then the LL VM
IR code was translated by our translator to C RYPTO LINE
automatically. The very few instructions not supported by
LLVM CRYPTO required manual translation. The generated
CRYPTO LINE program was then veriﬁed by the veriﬁcation
tool. Some of them required human efforts to annotate the
program, like adding Assert ’s. The veriﬁcation was performed
on two machines respectively: a Mac laptop M1 running
OS X 10.11.6 with a 2-core 2.6GHz CPU and 8GB RAM,
and a Linux machine M2 running Ubuntu 16.04.5 with two
6-core 3.47GHz CPUs and 128GB RAM. Boolector 3.0.0 and
Singular 4.1.1 were utilized as SMT solver and ideal mem-
bership solver, respectively, for the C RYPTO LINE veriﬁcation
tool.
B. V eriﬁcation Tasks
The veriﬁed implementations include fundamental arith-
metic operations in Curve25519 and three NIST elliptic
curves (P-224, P-256 and P-521). Each curve has its own
special ﬁnite ﬁeld Zp:p=2255−19for Curve25519, p=
2224−296+1 for NIST P-224, p=2256−2224+2192+296−1
for NIST P-256, and p=2521−1for NIST P-521.
The ﬁeld elements of different bit widths over different
curves hence have different representations. Their arithmetic
implementations thus differ.
Most of the speciﬁcations of these arithmetic operations
came from the comments in OpenSSL source code. For
those without speciﬁcations written in the comments, we
determined their speciﬁcations from the context of their
usage inside OpenSSL. The pre-conditions of the veriﬁed
speciﬁcations are range properties on inputs. And the post-
conditions contain both algebraic and range properties relat-
ing outputs to the inputs. See the example in Section III-B .
The most complicated algebraic post-condition we have
veriﬁed is part of the Montgomery Ladderstep [16] in
Curve25519: X1×X5×(X2×Z3−Z2×X3)2≡
Z5×(X2×X3−Z2×Z3)2mod (2255−19). Each of X1,X2,X3,X5,Z2,Z3andZ5is a ﬁeld element represented
by ﬁve 64-bit limbs. Note that Montgomery Ladderstep is a
crucial step to compute point multiplication over Curve25519
efﬁciently and securely. It requires 18 ﬁeld operations that
are implemented as individual functions. Such complicated
algebraic properties involving large numbers cannot even be
speciﬁed in existing general-purpose C veriﬁcation tools, let
alone be veriﬁed by them.
C. Experiment Results
The results of the experiment are summarized in Table III.
In the table, the “loc-ir” column displays the number of
lines of LLVM IR code for each function, and “loc-cl” for
their C RYPTO LINE code. The “diff-*” columns show the
percentage of manual modiﬁcations in each C RYPTO LINE
program. “diff-0” is for our translator with no heuristics
implemented and “diff-h” is with all four heuristics. Note
that specifying pre- and post-conditions does not count,
but modifying one line (i.e. one statement) counts two:
one deletion and one addition. Finally, T1andT2are the
veriﬁcation time in seconds on M1 and M2, respectively.
They do not contain translation time from LLVM CRYPTO
to C RYPTO LINE. The translation for the largest target with
1153 instructions only took less than 5seconds. The others
took less than 2seconds. We highlight the results as follows:
1)For functions felem_diff_128_64 ,felem_mul and
felem_square in ecp nistp521 (marked with “-”),
our approach shows that they do not conform to
the speciﬁcations given in the OpenSSL source code
comments. More details are given in Section V-D.
2)Most of the veriﬁed tasks ( 71.4%,25of35) are ﬁnished
within only 5seconds even on M1. 32(91.4%) of them
take less than 20seconds. Two of those left require
around 1minute. The largest target in the experiment,
the Montgomery Ladderstep (the last row) makes M1
out-of-memory (marked with “OM”). It requires around
47minutes on M2. A further experiment showed that
this can be accelerated by parallelization supported by
CRYPTO LINE. The veriﬁcation time on M2 is then
reduced to 1288 seconds (around 21minutes) by using
option “ -jobs 6 ” to parallelize with 6threads. This
improves the scalability of our approach.
3)The “diff-*” columns show that the automation of our
approach is greatly improved by our heuristics. With
these heuristics, most of the tasks ( 65.8%,25of38) are
veriﬁed fully automatically. Almost all ( 92.1%,35of
38) need only less than 10% of manual modiﬁcations.
We believe that more heuristics can further reduce these
efforts and improve the usability of our tool.
D. Bug and Anomalies in ecp nistp521
The functions felem_diff_128_64 ,felem_mul and
felem_square in ecp nistp521.c implement subtraction,
multiplication and squaring on ﬁeld elements respectively.
560
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. Table III
EXPERIMENT RESULTS
function loc-ir loc-cldiff-0 diff-h T1T2
(%) (%) (s) (s)
ecp nistp224.c
felem diff 30 40 40.0 0.0 0.40 0.18
felem diff 128 64 30 60 26.7 0.0 0.85 0.73
felem mul 60 298 49.0 0.0 9.64 8.80
felem scalar 15 20 40.0 0.0 0.16 0.08
felem square 43 193 47.7 0.0 1.96 1.20
felem sum 22 24 33.3 0.0 0.23 0.10
widefelem diff 54 112 25.0 0.0 2.75 2.67
felem mul reduce 99 493 58.4 9.3 73.47 71.02
felem neg 47 145 49.0 9.0 1.07 0.57
felem reduce 75 246 50.0 7.7 4.56 3.94
felem square reduce 82 388 60.3 11.9 64.83 61.45
widefelem scalar 31 136 45.6 2.9 5.28 4.72
ecp nistp256.c
felem diff 30 64 25.0 0.0 2.09 2.11
felem scalar 16 74 43.2 0.0 0.55 0.31
felem small sum 26 44 18.2 0.0 0.39 0.31
felem sum 22 40 20.0 0.0 0.34 0.27
smallfelem mul 109 488 49.2 0.0 8.58 6.59
smallfelem neg 22 36 22.2 0.0 0.25 0.12
felem shrink 65 160 63.8 26.3 4.55 4.55
felem small mul 175 672 51.9 6.7 15.06 12.88
smallfelem square 74 330 51.5 1.2 4.55 3.25
ecp nistp521.c
felem diff64 61 81 44.4 0.0 0.84 0.49
felem diff128 61 126 28.6 0.0 17.59 18.30
felem neg 43 45 40.0 0.0 0.50 0.24
felem scalar 43 45 40.0 0.0 0.97 0.95
felem scalar64 35 45 40.0 0.0 1.12 1.15
felem scalar128 36 162 44.4 0.0 3.61 3.61
felem sum64 52 54 33.3 0.0 0.28 0.13
felem reduce 145 317 53.0 17.0 2.29 1.36
felem diff 128 64 70 126 28.6 0.0 - -
felem mul 289 1618 49.9 0.0 - -
felem square 158 892 51.1 0.0 - -
curve25519.c
fe51 add 32 30 33.3 0.0 0.18 0.07
fe51 sub 37 45 44.4 0.0 0.35 0.15
fe51 mul 124 617 51.5 2.7 17.67 14.52
fe51 mul121666 57 166 44.6 4.8 1.42 0.88
fe51 sq 94 432 51.4 3.2 9.67 7.57
x25519 scalar multa1153 5280 50.6 2.5 OM 2815.16
aOnly the Montgomery Ladderstep part is veriﬁed.
They all have input range assumptions given in the comments
as pre-conditions.
The veriﬁcation of these three functions failed with these
given pre-conditions. It turns out that the given range assump-
tions may cause unexpected overﬂows in the implementations.
These overﬂows then result in wrong returned values. Using
the output of the C RYPTO LINE veriﬁcation tool, we suc-
ceeded in locating the instructions with unexpected overﬂows.
Counterexamples were also constructed. A counterexample offelem_diff_128_64 shows that the unexpected overﬂow
really happens when it is invoked by point_double .
We reported our ﬁndings with the counterexamples to the
OpenSSL developer community. The community conﬁrmed
that the overﬂow in felem_diff_128_64 is a bug. They
then ﬁxed it in the commit 13fbce1. Besides OpenSSL 1.1.1,
this bug is hidden in various releases including 1.1.0, 1.0.2
etc. For felem_mul andfelem_square , the community
conﬁrmed that the range assumptions written in the comments
were wrong. New range assumptions were also given from
the community.
The new implementation of felem_diff_128_64 and the
new range assumptions of felem_mul andfelem_square
have been veriﬁed by our approach. The veriﬁcation of new
felem_diff_128_64 takes less than 5seconds on both
M1 and M2. felem_mul andfelem_square with new
assumptions take around 320 and80seconds respectively on
both machines.
E. Remark on Compiler Optimization
In the experiment, we found that there are vectorized in-
structions in the assembly output of x25519_scalar_mult
from Clang, even though the source code is sequential. It turns
out that compilers like Clang are able to perform surprisingly
non-trivial optimizations. It can vectorize a fragment of
sequential code. In the case of x25519_scalar_mult ,t w o
sequential additions a1+b1anda2+b2in C code are
optimized to a vector addition addv on vectors aandb,
whereacontainsa1,a2andbsimilarly. The vector addition
is further assembled to a vectorized assembly instruction if
the underlying architecture supports. This means the two
sequential C statements will be executed simultaneously in
the binary executable.
VI. R ELA TED WORK
To the best of our knowledge, this work presents the ﬁrst
attempt to verify existing cryptographic C code automatically.
We compare our approach with others in three categories.
A. General-Purpose C V eriﬁcation
Numerous techniques and well-developed automatic tools
such as [9]–[12], [17]–[21] are available for verifying C
code. The annual Competition on Software V eriﬁcation (SV-
COMP)4is a showcase for them. We have tried CPA-S EQ[9],
PESC O[10] and UA UTOMIZER [11] from the top three
winning in Overall category in SV -COMP 2019 [22] to verify
our 8-line motivating example. As shown, these general-
purpose veriﬁcation tools are not very suitable for verifying
bit-precise non-linear algebraic properties in cryptographic
programs. We specially mention SMACK [12] since it works
similarly as our approach. It converts LLVM IR programs
into Boogie programs [23], then chooses various veriﬁers
for Boogie to perform veriﬁcation. However, Boogie is
4https://sv-comp.sosy-lab.org/
561
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. not designed for cryptographic programs and there is no
veriﬁer developed for that purpose. F RAMA -C [24] allows
to verify algebraic properties by combining SMT-solving
and interactive theorem proving. However, the complicated
algebraic properties involving large numbers are difﬁcult or
even impossible to be speciﬁed in these general-purpose C
veriﬁcation tools.
B. V erifying Cryptographic C Code
gfverif [25] is an automatic tool used to verify a C im-
plementation of the Montgomery Ladderstep in Curve25519.
It needs to re-implement existing C programs using its con-
structs before veriﬁcation. gfverif veriﬁes fewer programs
than our approach because its constructs are more limited.
For example, it does not support 128-bit integers or algebraic
properties involving variable modulus. It cannot verify our
motivating example in Section I either. Cryptol/SAW [26]
automatically veriﬁes several cryptographic implementations
in C and Java against their reference implementations. How-
ever, the reference implementations are not proven correct.
F* [27] and V ale [28] implement arithmetic operations in
their languages, and verify the results using SMT solving
and manual proofs. Fiat-Crypto [29] is a project that tries to
synthesize correct-by-construction C code for cryptographic
primitives. But its veriﬁcation relies on manual proofs using
Coq [30]. A collection of hash functions, random number
generators and other operations [31]–[38] are formally and
manually veriﬁed using proof assistants like Coq. Note
that interactive theorem proving costs much more human
efforts than our approach. And our approach is able to
construct counterexamples when veriﬁcation fails, while
manual approaches cannot.
C. V erifying Cryptographic Assembly Code
In [39], the authors veriﬁed a hand-optimized assembly im-
plementation of the Montgomery Ladderstep in Curve25519
using SMT solvers and Coq. They have to annotate programs
extensively and manually. If SMT solving fails, human
veriﬁers have to use Coq to manually ﬁll the gap. The
work [40] models cryptographic assembly programs with
a domain-speciﬁc language BVCRYPTO LINE. Programs in
BVCRYPTO LINE can be veriﬁed automatically by a certiﬁed
approach. Extending BVCRYPTO LINE,C RYPTO LINE [13] is
equipped with automated tools for translation from assembly
code to C RYPTO LINE. Although the veriﬁcation is not
certiﬁed, it is much faster. Our approach is based on
CRYPTO LINE. Compared to them, our approach works at a
higher level and supports features like pointer arithmetic.
VII. C ONCLUSION
We have presented an automated approach to translation
and veriﬁcation of arithmetic functions in cryptographic C
programs. The case studies on real-world implementations
in OpenSSL suggest the applicability and scalability of ourapproach. We were assisted greatly by the useful comments
of OpenSSL developers in our experiments.
There are three obvious future directions. First, more
translation heuristics can be developed to ease the veriﬁcation
process. Second, speciﬁcations are written at the C RYPTO -
LINE level for the moment. It requires human veriﬁers to
have knowledge about the translation. Another direction is to
design a speciﬁcation language that allows veriﬁers to write
pre- and post-conditions at C source code. Finally, we have
only worked up to one iteration of an innermost loop (the
Montgomery Ladderstep). We could elevate the veriﬁcation
to a higher level of the cryptographic primitive (here, a point
multiplication on a curve) by checking loop invariants.
ACKNOWLEDGMENT
The authors would like to thank the anonymous referees
for their valuable comments and suggestions. This work is
supported by Academia Sinica under the Grant Numbers
AS-IA-104-M01 and AS-TP-106-M06; the Guangdong Sci-
ence and Technology Department under the Grant Number
2018B010107004; the Ministry of Science and Technology
of Taiwan under Grant Numbers 105-2221-E-001-014-MY3,
107-2221-E-001-004, 108-2221-E-001-009-MY2, 108-2221-
E-001-010-MY3; and the National Natural Science Foun-
dation of China under the Grant Numbers 61802259 and
61836005.
REFERENCES
[1] B. B. Brumley, M. Barbosa, D. Page, and F. V ercauteren,
“Practical realisation and elimination of an ECC-related soft-
ware bug attack,” in CT-RSA 2012 , ser. LNCS, O. Dunkelman,
Ed., vol. 7178. Springer, 2012, pp. 171–186.
[2] N. Koblitz, “Elliptic curve cryptosystems,” Mathematics of
computation , vol. 48, no. 177, pp. 203–209, 1987.
[3] V . S. Miller, “Use of elliptic curves in cryptography,” in
CRYPTO ’85 , ser. LNCS, H. C. Williams, Ed., vol. 218.
Springer, 1985, pp. 417–426.
[4] D. J. Bernstein, “Curve25519: New Difﬁe-Hellman speed
records,” in Public Key Cryptography - PKC 2006 , ser. LNCS,
M. Y ung, Y . Dodis, A. Kiayias, and T. Malkin, Eds., vol. 3958.
Springer, 2006, pp. 207–228.
[5] The OpenSSH website. [Online]. Available: https://www.
openssh.com/
[6] The OpenSSL website. [Online]. Available: https://www.
openssl.org/
[7] OpenSSL committers. Accessed: 2019-05-10. [Online]. Avail-
able: https://www.openssl.org/community/committers.html
[8] P . L. Montgomery, “Modular multiplication without trial
division,” Mathematics of computation , vol. 44, no. 170, pp.
519–521, 1985.
562
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. [9] D. Beyer and M. E. Keremoglu, “CPAchecker: A tool for
conﬁgurable software veriﬁcation,” in CA V 2011 , ser. LNCS,
G. Gopalakrishnan and S. Qadeer, Eds., vol. 6806. Springer,
2011, pp. 184–190.
[10] C. Richter and H. Wehrheim, “PeSCo: Predicting sequential
combinations of veriﬁers - (competition contribution),” in
25 Years of TACAS: TOOLympics , ser. LNCS, D. Beyer,
M. Huisman, F. Kordon, and B. Steffen, Eds., vol. 11429.
Springer, 2019, pp. 229–233.
[11] M. Heizmann, Y . Chen, D. Dietsch, M. Greitschus, A. Nutz,
B. Musa, C. Sch ¨atzle, C. Schilling, F. Sch ¨ussele, and A. Podel-
ski, “Ultimate Automizer with an on-demand construction of
Floyd-Hoare automata - (competition contribution),” in TACAS
2017 , ser. LNCS, A. Legay and T. Margaria, Eds., vol. 10206,
2017, pp. 394–398.
[12] Z. Rakamaric and M. Emmi, “SMACK: decoupling source
language details from veriﬁer implementations,” in CA V 2014 ,
ser. LNCS, A. Biere and R. Bloem, Eds., vol. 8559. Springer,
2014, pp. 106–113.
[13] A. Polyakov, M. Tsai, B. Wang, and B. Yang, “V erifying
arithmetic assembly programs in cryptographic primitives
(invited talk),” in CONCUR 2018 , ser. LIPIcs, S. Schewe
and L. Zhang, Eds., vol. 118. Schloss Dagstuhl - Leibniz-
Zentrum fuer Informatik, 2018, pp. 4:1–4:16.
[14] The LL VM compiler infrastructure project. [Online]. Available:
https://llvm.org/
[15] J. C. Reynolds, “Separation logic: A logic for shared mutable
data structures,” in LICS 2002 . IEEE Computer Society,
2002, pp. 55–74.
[16] P . L. Montgomery, “Speeding the Pollard and elliptic curve
methods of factorization,” Mathematics of computation , vol. 48,
no. 177, pp. 243–264, 1987.
[17] P . Schrammel and D. Kroening, “2LS for program analysis
- (competition contribution),” in TACAS 2016 , ser. LNCS,
M. Chechik and J. Raskin, Eds., vol. 9636. Springer, 2016,
pp. 905–907.
[18] D. Kroening and M. Tautschnig, “CBMC - C bounded
model checker - (competition contribution),” in TACAS 2014 ,
ser. LNCS, E. ´Abrah ´am and K. Havelund, Eds., vol. 8413.
Springer, 2014, pp. 389–391.
[19] M. Y . R. Gadelha, F. R. Monteiro, L. C. Cordeiro, and
D. A. Nicole, “ESBMC v6.0: V erifying C programs using k-
induction and invariant inference - (competition contribution),”
in25 Years of TACAS: TOOLympics , ser. LNCS, D. Beyer,
M. Huisman, F. Kordon, and B. Steffen, Eds., vol. 11429.
Springer, 2019, pp. 209–213.
[20] D. Beyer, T. A. Henzinger, R. Jhala, and R. Majumdar, “The
software model checker BLAST,” STTT , vol. 9, no. 5-6, pp.
505–525, 2007.
[21] B. Chimdyalwar, P . Darke, A. Chauhan, P . Shah, S. Kumar,
and R. V enkatesh, “V eriAbs: V eriﬁcation by abstraction (com-
petition contribution),” in TACAS 2017 , ser. LNCS, A. Legay
and T. Margaria, Eds., vol. 10206, 2017, pp. 404–408.[22] D. Beyer, “Automatic veriﬁcation of C and Java programs:
SV-COMP 2019,” in 25 Years of TACAS: TOOLympics , ser.
LNCS, D. Beyer, M. Huisman, F. Kordon, and B. Steffen,
Eds., vol. 11429. Springer, 2019, pp. 133–155.
[23] M. Barnett, B. E. Chang, R. DeLine, B. Jacobs, and K. R. M.
Leino, “Boogie: A modular reusable veriﬁer for object-oriented
programs,” in FMCO 2005 , ser. LNCS, F. S. de Boer, M. M.
Bonsangue, S. Graf, and W. P . de Roever, Eds., vol. 4111.
Springer, 2005, pp. 364–387.
[24] F. Kirchner, N. Kosmatov, V . Prevosto, J. Signoles, and
B. Yakobowski, “Frama-C: A software analysis perspective,”
F ormal Asp. Comput. , vol. 27, no. 3, pp. 573–609, 2015.
[25] D. J. Bernstein and P . Schwabe, “gfverif: Fast and easy
veriﬁcation of ﬁnite-ﬁeld arithmetic,” 2016, http://gfverif.
cryptojedi.org.
[26] A. Tomb, “Automated veriﬁcation of real-world cryptographic
implementations,” IEEE Security & Privacy , vol. 14, no. 6,
pp. 26–33, 2016.
[27] J. K. Zinzindohou ´e, K. Bhargavan, J. Protzenko, and B. Beur-
douche, “HACL*: A veriﬁed modern cryptographic library,”
inCCS . ACM, 2017, pp. 1789–1806.
[28] B. Bond, C. Hawblitzel, M. Kapritsos, K. R. M. Leino, J. R.
Lorch, B. Parno, A. Rane, S. Setty, and L. Thompson, “V ale:
V erifying high-performance cryptographic assembly code,” in
USENIX Security Symposium 2017 . USENIX Association,
2017, pp. 917–934.
[29] A. Erbsen, J. Philipoom, J. Gross, R. Sloan, and A. Chlipala,
“Simple high-level code for cryptographic arithmetic - with
proofs, without compromises,” in 2019 IEEE Symposium on
Security and Privacy (SP) . IEEE Computer Society, 2019,
pp. 73–90.
[30] The Coq Development Team, The Coq Proof Assistant
Reference Manual, version 8.9 , Jan. 2019. [Online]. Available:
http://coq.inria.fr
[31] R. Affeldt, “On construction of a library of formally veriﬁed
low-level arithmetic functions,” Innovations in Systems and
Software Engineering , vol. 9, no. 2, pp. 59–77, 2013.
[32] R. Affeldt, D. Nowak, and K. Yamada, “Certifying assembly
with formal security proofs: The case of BBS,” Science of
Computer Programming , vol. 77, no. 10–11, pp. 1058–1074,
2012.
[33] R. Affeldt and N. Marti, “An approach to formal veriﬁcation
of arithmetic functions in assembly,” in Advances in Computer
Science , ser. LNCS, M. Okada and I. Satoh, Eds., vol. 4435.
Springer, 2007, pp. 346–360.
[34] M. O. Myreen and M. J. C. Gordon, “Hoare logic for
realistically modelled machine code,” in TACAS , ser. LNCS,
O. Grumberg and M. Huth, Eds., vol. 4424. Springer, 2007,
pp. 568–582.
[35] M. O. Myreen and G. Curello, “Proof pearl: A veriﬁed
bignum implementation in x86-64 machine code,” in Certiﬁed
Programs and Proofs , ser. LNCS, vol. 8307. Springer, 2013,
pp. 66–81.
563
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. [36] A. W. Appel, “V eriﬁcation of a cryptographic primitive: SHA-
256,” ACM Transactions on Programming Languages and
Systems , vol. 37, no. 2, pp. 7:1–7:31, 2015.
[37] L. Beringer, A. Petcher, K. Q. Y e, and A. W. Appel, “V eriﬁed
correctness and security of OpenSSL HMAC,” in USENIX
Security Symposium 2015 . USENIX Association, 2015, pp.
207–221.
[38] K. Q. Ye, M. Green, N. Sanguansin, L. Beringer, A. Petcher,
and A. W. Appel, “V eriﬁed correctness and security of
mbedTLS HMAC-DRBG,” in CCS . ACM, 2017, pp. 2007–
2020.[39] Y .-F. Chen, C.-H. Hsu, H.-H. Lin, P . Schwabe, M.-H. Tsai, B.-
Y . Wang, B.-Y . Y ang, and S.-Y . Y ang, “V erifying Curve25519
software,” in CCS , G.-J. Ahn, M. Y ung, and N. Li, Eds. ACM,
2014, pp. 299–309.
[40] M.-H. Tsai, B.-Y . Wang, and B.-Y . Y ang, “Certiﬁed veriﬁcation
of algebraic properties on low-level mathematical constructs
in cryptographic programs,” in CCS , D. Evans, T. Malkin, and
D. Xu, Eds. ACM, 2017.
564
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. 