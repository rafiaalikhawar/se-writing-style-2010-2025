CodeMatch : ObfuscationWon’t ConcealYour RepackagedApp
Leonid Glanz,Sven Amann,Michael Eichberg, Michael Reif,Ben Hermann,JohannesLerch,and
Mira Mezini
TechnischeUniversitätDarmstadt
Germany
{glanz,amann,eichberg,reif,hermann,mezini}@cs.tu-darmstadt.de,lerch@st.informatik.tu-darmstadt.de
ABSTRACT
An established way to steal the income of app developers, or to
trick users into installing malware, is the creation of repackaged
apps.Theseare clonesofśtypicallyśsuccessfulapps.Toconceal
their nature, they are often obfuscated by their creators. But, given
that it is a common best practice to obfuscate apps, a trivial identi-
fication of repackaged apps is not possible. The problem is further
intensified by the prevalent usage of libraries. In many apps, the
size of the overall code base is basically determined by the used
libraries. Therefore, two apps, where the obfuscated code bases are
very similar,donot have to be repackagesofeachother.
To reliably detect repackaged apps, we propose a two step ap-
proach which first focuses on the identification and removal of
the library code in obfuscated apps. This approach ś LibDetect ś
relies on code representations which abstract over several parts
oftheunderlyingbytecodetoberesilientagainstcertainobfusca-
tion techniques. Using this approach, we are able to identify on
average 70% more used libraries per app than previous approaches.
After the removal of an app’s library code, we then fuzzy hash the
mostabstractrepresentationoftheremainingappcodetoensure
that we can identify repackaged apps even if very advanced ob-
fuscation techniques are used. This makes it possible to identify
repackagedapps.Usingourapproach,wefoundthat ≈15%ofall
apps inAndroid app stores are repackages.
CCS CONCEPTS
·Security and privacy →Software reverse engineering ;·
Software and its engineering →Software libraries and repos-
itories;·Applied computing →Systemforensics;
KEYWORDS
library detection, repackagedetection, obfuscation, code analysis
ACMReference format:
Leonid Glanz, Sven Amann, Michael Eichberg, Michael Reif, Ben Hermann,
Johannes Lerch, and Mira Mezini. 2017. CodeMatch : Obfuscation Won’t
ConcealYourRepackagedApp.In ProceedingsofESEC/FSE’17,Paderborn,
Germany,September 04-08,2017, 11pages.
https://doi.org/10.1145/3106237.3106305
Permissionto make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,
topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ESEC/FSE’17, September 04-08, 2017, Paderborn, Germany
©2017 Associationfor Computing Machinery.
ACM ISBN 978-1-4503-5105-8/17/09...$15.00
https://doi.org/10.1145/3106237.31063051 INTRODUCTION
Popularapps intheGooglePlayStore areinstalledonmillionsof
devices.Thisattractsmaliciousactorstocreatealtered,repackaged
versionsofthoseappstostealtheoriginalowner’srevenue,orto
trickusersandinfecttheirmobiledeviceswithmalware.Detecting
suchrepackagedappsisthereforenecessaryforasecureandviable
app market.
Several techniques for repackage detection have already been
proposed andcan be broadlyclassified as being code-agnostic[ 20,
42,43], graph-based [ 10,15,16,25,47], user-interface-based [ 17,
41], and code-signature-based [ 9,22,39,45,46]. TheCode-agnostic
approaches hashinternal filesofanapp withoutconsidering the
filecontentortype;asaresult,thehashescouldbeevadedbysingle
bit changes. Graph-based techniques derive the control-flow, data-
floworcallgraphoftheanalyzedappandmeasurethesimilarity
by comparing isomorphic sub-graphs of the derived properties.
Given that graph matching is a hard problem, these approaches
potentially suffer from scalability issues [ 15]. Those approaches
whichtrytoabstractfromtheconcretegraphstoachievescalability,
e.g.,byusingmetrics,sufferfromhighfalsepositiverates[ 10].User-
interface-based techniques also construct a graph, but use views as
nodesandthetransitionsfromoneviewtoanotherasedges.These
graphs can easily be fooled by changing or introducing pseudo-
views.Code-signature-based approaches create signatures based
on an apps’ code to address the weaknesses of the graph-based
approaches;the proposedapproach alsobelongs to this category.
Challenges. Achallengeforallexistingrepackagedetectiontech-
niquesare codetransformations. Developers regularly minify and
optimize their apps to increase performance. Additionally, they
obfuscatetheirappstoprotecttheirintellectualproperty.However,
attackersalsoapplyobfuscationtohidemaliciouscodeandtoevade
signature-baseddetectors, such as anti-virussoftware.
Currentrepackagedetectiontechniquescanonlyhandlebasic
forms of obfuscation such as one-by-one identifier renaming, re-
placingtypes,andreorderingoffieldsandmethods[ 7,31].More
sophisticated obfuscation techniques, such as moving classes be-
tweenpackagesorchangingAndroidAPIcallsarenotsupported.
Our evaluation of Google Play Store apps revealed that 60% [ 21]
are at least partially obfuscated and that at least 20% use more
advancedtechniques.Theeffectivenessofrepackagedetectionis
furtherinhibitedthroughtheprevalentreuseoflibrariesinapps.
Wangetal.[ 39]reportedthatmorethan60%ofthesub-packagesin
Android apps belong to library code. Hence, separating the library
code from the app code is necessary. Otherwise, apps which use
(nearly)thesamelibrariesautomaticallysharealargeportionofthe
overall code base and are always identified as repackages ś even if
638ESEC/FSE’17,September04-08,2017, Paderborn,GermanyLeonidGlanz, Sven Amann, MichaelEichberg,MichaelReif,
Ben Hermann, Johannes Lerch,andMiraMezini
theapps’codeiscompletelydifferent.Abasicapproachtofilterout
non-obfuscated librarycode isto use package white-lists[10,46].
Anotherchallengeforrepackagedetectiontoolsareappsgen-
eratedbyAppMakers,e.g.,apps-builder[ 8].Inthatcase,thevast
majorityofthecodebaseśthegenerator’slibrariesświllbethe
sameandtherestwillstillbeverysimilar.Currentapproaches,will
generallyflag such apps as repackages.
Proposed Approach. To address the identified challenges, we pro-
pose a method for repackage detection that consists of a library
detection technique LibDetect and an app matcher CodeMatch ,
whereby the latter uses the former.
LibDetect usesfivehierarchicallyorganizedrepresentations.The
firstoneistheoriginalbytecode.Theotherrepresentationseach
abstractoversomeadditionalaspects,suchastheusedidentifiers
or the control-flow. Hence, each higher level is less precise but po-
tentially enablesa higher recall. Asa result of theprecision/recall
trade-offourlibrarydetectioninternallyusesthefiverepresenta-
tionsstep-by-step.Ifalibrarymethodisonlymarginallyobfuscated,
our approach will identify the method using a less abstract rep-
resentationwhencomparedtomethodsthataremoreeffectively
obfuscated. After identifying the library methods we regroup them
tomatchthepotentialoriginallibraryclasses.Thisenablesusto
identify methods and classes which were moved across class/pack-
age boundaries. To evaluate the robustness of our representations,
we extracted roughly 200 sample library APKs from Maven Cen-
tral[32],obfuscatedthemwithastate-of-the-artobfuscator( Dex-
Guard[33]), and tried to reidentify the original library methods.
Fortheevaluationof LibDetect ,werandomlyselected1,000apps
andidentifiedthe libraries manually to establishagold standard.
Ourappmatcher CodeMatch usesfuzzyhashing[ 28]ofanapp’s
codetowithstandvarioussophisticatedobfuscationtechniquesand
optimizations, including; class relocating, slicing, duplication of
AndroidAPIsintheapp,codechangesandcodeoptimizationsthat
affectthedetection.Additionally,itorderstheapp’spackagesbased
onthesizeoftheirclasses.Thisaddressesthechallengesfacedby
DroidMOSS [46] dueto reorderingsofclassesandpackages.
To test if an app is repackaged, CodeMatch performs the follow-
ing steps: First, it filters apps which were generated using App
Makers;these2.4%ofallappscanreliablybefilteredusingawhite-
listofthemain-packageprefixes;theyarerequiredbyAndroid’s
signing process and cannot be obfuscated. Second, it filters the
library code of apps using LibDetect . Third, it filters apps which
haveless than≈300linesofcode;such appscannotbeclassified
reliablybyourapproach.Fourth,itgeneratesforeachappthemost
abstract/obfuscation-resilient representation and fuzzy hashes it.
Fifth,itcomparesthefuzzyhashesandifthesimilarityexceedsa
predefinedthreshold,the apps are markedas repackaged.
We prepared the evaluation of CodeMatch by fuzzy hashing the
descriptions of downloaded apps and randomly selecting 1,000
apppairs,whosefuzzy-hasheddescriptionsareatleast90%simi-
lar; we considered very similar descriptions as a first indicator for
repackaging.Afterwards,we installedandexecutedeachapp pair
toreconfirmtheirsimilaritymanually.Weusedtheseresultsasthe
groundtruth,toevaluatethefindingsof CodeMatch ,ViewDroid [41],
DroidMOSS [46],FSquaDra [42],andanrepackagedetectionthat
uses the centroid concept from physics[10].Additionally,weevaluatedtheeffectsof CodeMatch independent
ofLibDetect . To evaluate the effect that library detection has on
repackagedetection,weexecutedtwooftherepackagedetection
tools (DroidMOSS and Centroid-Based) additionally with LibDe-
tectandLibRadar aspre-filtersandcomparedtheresultswiththe
other tools. To evaluate the effect of CodeMatch in isolation, we
additionally run itwith alibrary white-list and with LibRadar. We
show that CodeMatch enables us to identify, in all library detection
configurations, up to 50% more obfuscated and repackaged apps
than the other approaches. In summary, we make the following
contributions:
•Five abstract code representationsthat enable library and
repackagedetectionwithdifferentprecision/recalltrade-
offs
•LibDetect , a technique to detect library code on a class
basisthatoutperformsthecurrentmostadvancedlibrary
detection tool LibRadar by70%.
•CodeMatch ,atechniquethatdetectsapprepackaging,which
usesLibDetect tofilteroutlibrariesbeforemeasuringthe
similarityofthe apps.
•Thefirstquantitativecomparativeevaluationofavailable
repackage detection approaches ( CodeMatch ,ViewDroid ,
DroidMOSS ,FSquaDra andacentroid-based approach)
Theremainderofthispaperisstructuredasfollows.Section2
presentstheattackermodel.Section3givesanoverviewofobfus-
cation techniques. Section 4 describes the state of the art. Section 5
presents the proposed approach. Section 6 discusses theresultsof
our evaluation. Section 7 examines threats to validity. Section 8
concludes the paper.
2 ATTACKER MODEL
We identified three kinds of attackers who create repackaged apps:
Attackersfromthefirstcategoryonlyapplybasicchanges/ob-
fuscations of an app that do not require a deep understanding and
configuration of obfuscators. Their primary goal is to avoid that
the repackaged app is identified by hash-based approaches. The
second category is able to make full usage of existing advanced
obfuscators to effectively hide their apps even if state-of-the-art
repackage detection approaches are used. The third category of
attackersare expertswhoare ableto apply customobfuscations.
Currentrepackagedetectiontoolsareabletoidentifyrepackaged
apps created by attackers from the first category. The proposed
approachś CodeMatch śisadditionallyabletoidentifyrepackaged
apps ofattackersfrom category two.
3 CODE OBFUSCATION
Webrieflyintroduceknownobfuscationtechniques,whichwere
seen in the wild [ 12,36,38] or are performed by known obfus-
cators [6,13,14,26,33,37,44]. Optimization techniques are also
included, because they introduce variance similar to obfuscation
and cause similar issues. Throughout the paper we will refer to
both techniques as obfuscationtechniques
Name Mangling. In general, meaningful identifiers, such as
field,method,class, andpackagenames,are replacedbymeaning-
less, small strings; e.g., ł Personž→łaaž. Package identifiers can
even be reduced to the empty string; this justputs all classes in
639CodeMatch : Obfuscation Won’t ConcealYourRepackagedApp ESEC/FSE’17,September04-08,2017, Paderborn,Germany
thedefaultpackage.Shorteningnamesalsoimprovestheoverall
performance dueto the smallercode size [6].
Modifier Changes. Field, method, and class modifiers can be
changed most of the time without affecting the semantics of a pro-
gram. The modifications range from basic changes, e.g., raising the
visibilityof classes orclass members (e.g., ł package private ž→
łpublicž) or adding/removing the finalmodifier, to more com-
plexones.E.g.,transforminganinstancemethodintoastaticone
requires an extraparameterto make the thisreference explicit.
StructuralChangestoaMethod’sImplementation. Avery
basictechniqueistoadd NOPs-i.e.,instructionswhichhavenoeffect
on the method’s semantics, but modify the structure of the code.
The primary effects are a larger method body and shifted jump
targets of jump instructions, such as, if,switchorgoto. More
involvedchanges,suchaschangingthekindofan if-instruction
(łif>ž→łif≤ž),generallyaffectthemethod’scontrol-flowgraph.
Code Slicing. Most applications do not use all features of the
libraries they include. Therefore, it is possible to remove unused
library code bycreating aslice ofessentialfunctionality.
Code Restructuring. Common obfuscaters move classes and
methods between packages, classes and methods. Such changes
affectallcallsitesrelatedto the changedclass structure.
MethodParametersManipulation. Reorderingorremoving/
adding unused method parameters affects both: the signature and
bodyofthemethod.Thisgenerallyrequiresacorrespondingupdate
ofallcallsites.
Constant Computation. Constant values are replaced by ex-
pressions that compute the constant; e.g. the constant 100is re-
placedbythecomputation 10*10.Amoreadvancedtechniqueis
the encryption ofstrings whichare then decryptedondemand.
FakeTypes. Alreadyexistingclasses,inparticularfromlibraries
such asthe AndroidSDK,are duplicatedand used withinthe pro-
gram instead of the original class; e.g., ł java.util.HashSet ž→
łcom.MySet ž. In more advanced cases a field’s primitive type is
changed;e.g.,from inttolong.
Code Optimization. Classic code optimizations also influence
thecode’sstructurewhenevermethodsareinlined,valuespropa-
gated,unusedvariables are removed,orcontrol-flowismodified.
HideFunctionality. Sophisticated obfuscators hide functional-
itybyencryption,recompilation,compression,andvirtualization
of selected classes (see Sharif et al. [ 36]). These techniques are cur-
rentlythemosteffectiveprotectionmechanisms,butgenerallyslow
downtheapp’sexecutiontime,needadvancedknowledgeofthe
app’sinternalstructure,orrequiremanualcodechangesandare,
therefore,rarelyusedinpractice.
4 STATEOFTHE ART
This section presents the state of the art in the area of library and
repackagedetection for Android applications.
4.1 LibraryDetection
Different repackage detection approaches [ 10,46] use common
librarywhitelists todetectandfilteroutlibrarycode.Whitelists
contain package names of known libraries and are compared with
packagenamescontainedinAndroidapps.Currentlythelargest
white list is collected by Li Li et al. [ 29]; it contains over 5,000different names of library packages. The problem with using white
listsisthatchangingjustonecharacterofalibrary’spackagename
can completely evade the library detection.
LibD[30]usesthesub-/super-packagerelation( inclusion)andthe
inheritance relation between classes across packages ( inheritance )
to construct one reference graph per library. These graphs can
thenbecomparedwithgraphsextractedfromanapp.Agraphis
constructedbyusing(sub-)packagenamesasnodesandinheritance
orinclusionrelationsasdirectededges.Whilethisapproachreduces
the information needed for comparing libraries to the package
level,itisvulnerabletochangesthatsplitormergepackages.Ifthe
package hierarchy is changed thegraph has a different number of
edges per node andcannotbe comparedwiththis approach.
LibRadar [31] is an approach for detecting library code in An-
droid apps. Given an app’s code, it extracts for each package a
feature vector consisting of the observed Android API calls. These
vectors are then hashed to get a fingerprint per package. These
fingerprintscanthenbecomparedagainstfingerprintsofknown
library packages. LibRadar is therefore resilient against the renam-
ingofpackages,butcannothandleobfuscationsthatmergeorsplit
packages that affectthe vector of API calls.
The goal of LibScout[7] is to identify the version of an Android
API that is used inobfuscated code. Itgenerates merkle-tree-hash
profiles in three steps. First, it replaces all types of a method signa-
turethatdonotbelongtotheAndroidAPIwithanłXžandthen
hashes the transformed signature. Second, the method signature
hashesaresortedandhashedattheclasslevel(classhashes).Third,
class hashes are again sorted and hashed per package (package
hashes).Finally,allhashesareusedtoidentifylibrarycode.Ifthe
package hash does not match, the class and the method hashes
areused.Ifnohashmatchesthecodeelementisdeclaredasnon-
librarycode.Thehashesaregeneratedfordifferentlibraryversions
to make it possible to identify a specific version. Since the compu-
tationofthetreehashinherentlyreflectstheimplicittreestructure
between packages, classes and methods, LibScout is not robust
against cross-class/-package code restructurings .
To recap, the discussion above indicates the need for better
library detection that is able to handle library instances with a
changed package hierarchy. Additionally, beyond white lists, Li-
bRadaris the only approach that can directly be used as a pre-step
to repackage detection. Both white lists and LibRadar have their
specificlimitationsmentionedabove.Moreover,neithertheynor
the other approaches exploit information about the method bodies.
These limitationslead to poor recall, as our empirical comparison
of these techniques against our new approach will reveal in Sec. 6.
4.2 RepackageDetection
DroidMOSS [46]usesanapp’sbytecodeinstructionnames(mnemon-
ics) without arguments to compute a fingerprint by fuzzy hashing
the entire mnemonic sequence in the given order. A white list is
used for library filtering. DroidMOSS is vulnerable to Code Restruc-
turingsbecause the fingerprintdepends onthe code order.
ViewDroid [41]detectsrepackagedcodebybuildingviewgraphs.
Itextractsall Activityclassesasviewnodesandallactionsasedges
e.g., button pushes or intent execution. The tool performs a sub-
graphsimilaritymeasurementtocompareviewgraphs,whichis
640ESEC/FSE’17,September04-08,2017, Paderborn,GermanyLeonidGlanz, Sven Amann, MichaelEichberg,MichaelReif,
Ben Hermann, Johannes Lerch,andMiraMezini
timeconsuming. ViewDroid isvulnerabletoinsertionoflibraries
with own views, because it does not filter libraries. Furthermore, it
canonlycompareappswithmorethanthreeviews.Inarandom
sample of1,000 apps,44 .3% hadless than 3views.
Cuixia et al. [ 17] developed a tool that represents code in the
samewayas ViewDroid ,butusesfixedsizevectorsofAPIcallcounts
per UI widget instead of whole views. The tool achieves a more
robust representation, but has the same drawbacks as ViewDroid .
FSquaDra [42] computes for allfilesreferencedinthe
MANIFEST.MF of an APK the hash values and compares them with
theextractedhashesofapotentiallyrepackagedapp. FSquaDra has
nolibrarydetectionandtheinsertionoflibrarycodewouldchange
theentirehashvalueofthecodefile.However,eventheadditionof
some (useless) resources (e.g., sound files or images) would change
the computedhashesandreduce the similaritywithotherapps.
Wukong[39]detectsrepackagedappsinthreesteps:First,ituses
LibRadar [31] to filter out library code. Second, it filters equivalent
appsbycomparingtwodifferentfingerprints.Whereasthefirstis
generatedthesamewayas LibRadar’sfingerprints,thesecondis
basedonthefrequencyofAPIcallsperpackage.Third,itgenerates
featurematriceswhichcontainoccurrencefrequenciesofallvari-
ablesindifferentcontexts,tocomparethemforrepackagedetection.
AsLibRadar is used in the first two steps, the approach also suffers
from the same drawbacks. Libraries that remain undetected during
step one potentially cause a high false positive/negative rate in the
detectionresults.Whenoneofthefingerprintsisfalselymatched
instep two,the repackageanalysisisnot executed.
DNADroid [15] filters out libraries by using package names and
classhashes.Afterthat, DNADroid extractsthedata-dependency
graph(DDG)ofeachappmethodandidentifiesrepackagedapps
bycomparingtheapp’sDDGswiththeDDGsofotherapps.The
library filtering step of DNADroid’s is vulnerable to renamings
affectingpackagenamesorclasshashes.Determiningsub-graph
isomorphismisgenerallycomputationallyexpensive[ 10],which
makesDNADroid unsuitableforrepackagedetectioninhugeapp
stores, such as łGoogle Play Storež.
AnDarwin [16] detectsrepackagedapps infoursteps:First,com-
parableto DNADroid ,itcomputestheDDGforeachmethod.Second,
itcomputesforeachDDGthefrequenciesofeachunderlyingin-
struction(e.g.,assignmentsoradditions).Third,tofilteroutlibrary
code it prunes vectors that occur more often among different apps
thanapredefinedthreshold.Finally, AnDarwin hasheseachremain-
ing vectorandcomparesthesehasheswith hashesofpotentially
repackagedapps[ 5].Theapproachfailstofilteroutlibrariesthat
are not usedfrequentlyenough according to the threshold.
TheapproachbyKaiChenetal.[ 10]constructsacontrolflow
graph per method and represents it as a centroid. The algorithm
filters out 73 popular libraries with a white list and matches the
centroids of the remaining methods pairwise. The advantage of
this approach is that similar centroids can be found efficiently, due
to the sorting capability of the centroids. However, it also has two
drawbacks.First,thedetectiondependsonthesortingorder,e.g.,if
wefilterfirstbytheinstructioncount,wepossiblymissmethods
thatareverysimilarbytheinvocationcount.Second,whenlibrary
codeisnotfilteredproperly(see4.1),itisconsideredasappcode,
whichrenderscomparedapps artificiallymore similar.Torecap:Eachrepackagedetectionapproachhasitsownspecific
drawbacks;all share problemsdue to limitationsof the library de-
tection in use. To address these problems, we designed CodeMatch ,
whichweevaluateagainst DroidMOSS ,ViewDroid ,FSquaDra ,and
thecentroid-baseapproachinSection6.For FSquaDra andView-
Droid,thesoftwarewaseitheravailableonlineorwasmadeavail-
able to use upon request. The code for DroidMOSS and for the
centroid-based approach was not available; but we were able to
re-implementthembasedontheinformationavailableintheirpub-
lications [ 10,46]. The remaining approaches could not be acquired
from their authors and we were not able to re-implement them
basedontheirpublications.
5 THE APPROACH
Our approach consistsof two parts: First, an approach ś LibDetect
ś for the identification and removal of library code from a given
Android app (APK). Second, an approach that takes the app’s code
ś after library removal ś to find repackages. Both parts rely on
abstract representations of the app’s code to handle obfuscation. In
Section5.1,wefirstpresentthedifferentcoderepresentationsbefore
we discuss LibDetect in Section 5.2, and CodeMatch in Section 5.3.
5.1 The AbstractRepresentations
Todealwithobfuscationofmethodsandclasses(seeSection3),we
usefivedifferentabstractrepresentationsofmethods.Therepre-
sentationsbuildupononeanother,eachabstractingoversomeaddi-
tionalelementsoftheoriginalbytecodecomparedtoitspredecessor.
Table1showswhichrepresentationaddresseswhichobfuscation
techniquesandTable2showsanexamplemethod compare(int,
int)inthe firstfourrepresentations.
Weusethe Bytecode(BC) ofamethodasis,toreliablyidentify
non-obfuscatedlibrary methods.
IntheAddresslessRepresentation(AR) weremove NOPsand
program counters and abstract over jump targets. In the latter
case, we replace forward jumps by łalongžand backward jumps by
łbackž.Takentogether,thisaddressesrespective StructuralChanges
to a Method’s Implementation . Furthermore, we remove allmethod
modifiersto address ModifierChanges .
IntheNamelessRepresentation(NR) weaddress NameMan-
glingandFake Types . For that, we remove method names from the
method signatures and invocation instructions and replace non-
Android-API type references in return, parameter, field, array, and
invocation instructions by lists of the types’ Android-API super-
types. These lists represent those parts of the type information
that cannot be obfuscated. We obtain them by walking up the type
hierarchies,collectingallinterfaceandclasstypesdefinedinthe
Android SDK/Java. After that, we order themalphabetically.
Table 3 compares the method signature’s AR and NR of Object
get(Key) declared by the app class MyHashMap , which is a clone
ofAndroid’s HashMap.Weassumethattheappclass Keyinherits
only from ObjectandthatMyHashMap inherits from
AbstractCollection ,Map, andObject. While the signature’s AR
contains the app-specific type information, its NR is identical to
that ofthe get()methodfrom Android’s HashMap.
641CodeMatch : Obfuscation Won’t ConcealYourRepackagedApp ESEC/FSE’17,September04-08,2017, Paderborn,Germany
Table 1:ComparisonofObfuscation to HandlingEntities.
Obfuscation BC AR NR SPR Fuzzy SPR LibDetect CodeMatch
NameMangling − − × × × × ×
Modifier Changes − × × × × × ×
Structural Changes to aMethod’sImplementation − × × × × × ×
CodeSlicing × × × × × × ×
CodeRestructuring − − − − − × ×
Method ParametersManipulation − − − × × × ×
Constant Computation − − − × × × ×
Fake Types − − × × × × ×
CodeOptimization − − − × × × ×
HideFunctionality − − − − − − −
Table 2: A compare(int, int) Method in BC, AR, NR, and
SPRRepresentation.
BC
0:iload_0
1:iload_1
2:if_icmpne→9
5:iconst_0
6:goto→19
9:iload_0
10:iload_1
11:if_icmpge→18
14:iconst_m1
15:goto→19
18:iconst_1
19:ireturnAR& NR
iload_0
iload_1
if_icmpne→along
iconst_0
goto→along
iload_0
iload_1
if_icmpge→along
iconst_m1
goto→along
iconst_1
ireturnSPR
load
load
if→along
const
if→along
load
load
if→along
const
if→along
const
return
Table 3:AMethod Signature’sARandNR.
AR NR
DeclaringType MyHashSet [HashSet,Object,Set]
MethodName get
Parameter Key [Object]
Return Type int int
In theStructure-Preserving Representation (SPR) we ad-
dressMethod-Parameters Manipulation by sorting parameters al-
phabetically by the parameter type lists from NR.We also address
Fake Types by removing all type information and the indexes from
loadandstoreinstructions.Forexample,theinstructions astore
anddstore_2 for storing an objector adouble, are both repre-
sentedby store.Weunifysize-dependentinstructions,suchas ldc
andldc_wand also drop all string constants, e.g., log messages, to
addressConstantComputation sthatexchangethese.Weprovidean
exhaustive mapping from bytecode instructions to their SPR repre-
sentationassupplementarymaterial[ 21].Furthermore,weimprove
ourhandlingof StructuralChangestoa Method’sImplementation
byrepresentingallcompareandjumpinstructionsby if.However,
the jumpdirection, i.e.,łalongž orłbackžiskept.IntheFuzzySPR weaddressstronger CodeOptimization s,Con-
stant Computation s andCode Slicing by fuzzy hashing the token se-
quencefromourSPRwith SSDEEP[28].Thisenablesustouncover
similarity in the presence of such variation. SSDEEP chunks the
inputsequencedependingonthetotalsequencelength,abstracts
eachchunktoasinglecharacter,andconcatenatesallcharacters
to a hash. It then repeats this process with doubled block size. The
resultingsignature consists of the twohashesandthe blocksize.
5.2LibDetect
LibDetect is a code-signature-based library-detection approach
which can detect a library even if the library was sliced down
to the required parts, library classes were moved to other pack-
ages,and/orinstancesofappclasseswereputintolibrarypackages.
This addresses shortcomings of existing approaches [ 10,29,31,46]
whichonlyidentifycompletelibrarypackages;searchingforcopies
oftheentirelibrarycodemaymisslibraryfragmentsandsimply
removing library packages may miss individual library classes and
mayaccidentallyremoveappcode. LibDetect searchesforcopiesof
librarymethodsandlateraggregatespotentialmatchestoclasses,
i.e.,LibDetect identifies library code at the granularity of classes.
Tomatchindividualmethods,weneedtodealwithobfuscationof
bothmethodsandclasses,asbotharereferencedfromwithinother
methods. Since obfuscation introduces variation in the method’s
code, we use our abstractions (Section 5.1) to counter its effects,
when we find library code with respect to a library database. In
this process, the degree of abstraction becomes a tradeoff between
precisionandrecall:Ifwematchanappmethodtoalibrarymethod
using a more concrete representation, it is more likely that the
match is correct and that we have fewer matches. However, we
mightmissbetterobfuscatedlibrarymethods.Usingamoreabstract
representation, we are more likely to find potential matches for
an app method, but may also falsely match the method with a
largernumberoflibrarymethods.The overallprocess isdepicted
inFigure 1.
Preparation. WhileAPKscontainDalvikBytecode,ourtooling
operatesonJavaBytecode.Therefore,weuseEnjarify[ 24]totrans-
form the Dalvik executable file (DEX) from the APK into a Java
archive(JAR).EnjarifyisthemostadvancedDEX-to-Java-Bytecode
transformercurrently available.
642ESEC/FSE’17,September04-08,2017, Paderborn,GermanyLeonidGlanz, Sven Amann, MichaelEichberg,MichaelReif,
Ben Hermann, Johannes Lerch,andMiraMezini
Figure 1:Toolchainto Identify Library Classes
Representation. We use the OPAL framework [ 19] to process the
JARfile.Foreachmethod,wegeneratethefiverepresentationsand
extractthefollowinginformation:thefully-qualifiednameofthe
method, its instruction count, its enclosing class and its defining
package. This information is subsequently used to improve the
precision when identifying library classes.
Lookup.To find library methods to which an APK’s method
mightcorrespond,weneedadatabaseofknownlibrarymethods
whichenablesanefficientlookup.Therefore,wehashallfiveab-
stractrepresentationsof knownlibrarymethodsusingtheSHA-1
function[ 18](thetwofuzzyhashesoftheSPR areprocessedindi-
vidually)andbuildanindexoverthehashesofeachrepresentation.
Theseindexespointto the methods’ metadata.
Algorithm1: Best-Matching Methods
Data:Methodm
Result:Matchingmethods
matches←lookup(m.FQN,m.BC);
ifmatches!=∅then return matches;
matches←lookup(m.FQN,m.AR);
ifmatches!=∅then return matches;
forreprin m.{ AR,NR,SPR,FuzzySPR 1,FuzzySPR 2}do
matches←lookup(repr);
ifmatches!=∅then return matches;
return∅;
GivenanAPK’smethod,weuseAlgorithm1tolookuppotentially-
matching library methodsin the reference database. The algorithm
looks for matches using our abstract representations in increasing
order of abstraction. The first twolookups searchthedatabase for
methodswiththesamefully-qualifiedname(FQN)andthesame
BC or AR as the APK’s method. This allows us to precisely iden-
tify library methods that are not or only slightly obfuscated. All
subsequent lookups ignore the declaring classes’ FQNs, to address
Name Mangling . We perform another lookup with the AR this way
andproceedwiththeotherrepresentations,untilwefindatleast
one match or otherwise declare the method as non-library code.
This way, we find potential matches even in the presence of strong
obfuscation,butidentify onlythe matches with the highestmatchconfidence.Additionally,weavoidunnecessarylargesetsofmethod
matches onmore abstract representations.
Figure 2: Aggregating Potentially-Matching Methods to Li-
brary Classes. The ellipsis are packages, rectangles are
classes and diamonds are methods. Green indicates library
andgrey missing elements.
Method/Class Matcher. In the last step, we aggregate the APK
methodsforwhichwefoundpotentially-matchinglibrarymethods
to library classes. Figure 2 shows the app’s structure, i.e., the pack-
ages,classes,andmethodsitcontains.Thecodeofeachincluded
librarycorrespondstoafragmentofthisstructure(b,cellipse,C,D,
Frectanglesandk,m,o,pdiamonds).Dueto CodeRestructuring ,this
fragment may have a different structure than the respective library
originally had. Also, due to Code Slicing (n’ diamond), elements of
the originallibrary mightbe missing.
The aggregation first searches for app packages that contain
code from library packages. For each app package it collects all the
app methodswith atleastone matchinglibrary method.For each
643CodeMatch : Obfuscation Won’t ConcealYourRepackagedApp ESEC/FSE’17,September04-08,2017, Paderborn,Germany
unique library package from any such matching library method,
itcountstheappmethodsthatmatchalibrarymethodfromthat
package.Werefertothiscountastheapp-to-library-methodcount.
Theaggregationthencontinuesforeachsuchlibrarypackagein-
dividually, in descending order of the app-to-library-method count.
Forexample,fromapppackage cinFigure2,twoappmethods o,p
matchmethodsfromthelibrarypackage c’andoneappmethod
match methods from the library package b’. Therefore, we first
processlibrary package candthen b.
For eachlibrarypackage,theaggregationcomputes amapping
from app classes to library classes. To this end, it considers only
potentially-matching library methods from that library package.
It maps each app class with the library class to which the high-
est number of methods match. If multiple classes match equally
many methods, the aggregation picks the library class with the
more-similar size in terms of bytecode instructions. Each library
class is mapped only once. For example, the app class Fin Fig-
ure 2 is mapped to the library class F’, because two of its methods
potentiallymatchmethodsfrom F’.
Finally, we filter out class mappings where the app class has
less than half as many bytecode instructions as the mapped library
class, to avoid false positives due to a few methods that occur
very frequently, especially in our abstract representations. The app
classesthat remaininthe mapping are reportedas library classes.
5.3CodeMatch
Figure 3depictsthe workflowof CodeMatch .
Preparation. This step is the same as for LibDetect (see Sec-
tion 5.2), except that we additionally extract the developer’s public
key (as herunique identifier) for the APK.
Library Slicing. After preparation, CodeMatch uses a library-
detectiontool,whichreportsdetectedlibrariesateitherpackage-or
class-levelgranularity.Itthenremovestherespectiveelementsfrom
theAPK’scodebase.Ifthelibrarydetectionreportsmultiplelibrary
classes,CodeMatch can be configured to abstract the reported class
names to wholepackages andremove theseinstead.
Filtering. Inadditiontothelibrarycoderemoval,wefiltertwo
kinds of apps that cannot reliably classified as repackages using
our approach. First,thosethatconsist mainlyoflibrary code, plus
at most≈300 lines of glue code [ 21]. We refer to such apps as
library apps . Second, apps generated using łApp makersž. App
makersgenerateappsby processinguser created ui designs.Apps
generatedbythesameAppmakergenerallyshareasimilarcode
base without necessarily being repackages. We filter these apps
usingawhitelistof40commonusedprefixesofknownAppmaker
frameworks. This list is the result of a web search for Android App
maker frameworks.
Representation. In contrast to library code,which maybe sliced
when only a part of the library’s functionality is used, an app’s
code is likely completely included in a repackage, as slicing would
breakitsfunctionality.Sincewealreadyremovedlibrarycodefrom
ourtargetAPK,weassumethattheremainingcodealmostentirely
corresponds to the potentially repackaged app’s code. Therefore,
wecanusetheidentifiedappcodeforthecomparisonwithotherapps’ code. To this end, CodeMatch represents each app class by
its own Android-API type list (as definedfor our NR), the type list
ofallitsfields,andourmost-abstractrepresentation,SPR,forall
its methods. We chose the SPR because we do not want to miss
methodsthat were similar beyond Code Optimization .
Toaddress CodeReordering ,wesortthefieldsaccordingtothe
type lists and the methods according to their instruction count. To
addressName Mangling of package and class names, i.e., to have a
name-independentorder ofclasses, wealsosort theentire classes
by their size, i.e., the sum of sizes of each field, the number of
methods,andthe instructioncount. Toaddress remaining smaller
differences that might have been introduced by obfuscation, we
fuzzyhash [28] the entire representation.
Comparison. Beforewecomparepotentiallyrepackagedapps,we
establish a threshold on the fuzzy-hash similarity, above which we
reportanalyzedappsasrepackaged.Wedeterminethisthreshold
byexecuting CodeMatch on1,000appsandsearchingforthebest
F1-score(harmonicmeanbetweenprecisionandrecall).Wegetthe
bestF1-score withathreshold of 30%.
To efficiently find potential repackages of an app, we build a
database of known apps which we processed as described in the
previous steps. Additionally, we indexed the respective developers’
public keys, to avoid reporting apps from the same developer as
repackages. We compare apps from different developers by the
fuzzy-hashed representation of the apps’ code using F2S2 [ 40],
whichefficientlyfindssimilaritymatchesbasedontheeditdistance
between fuzzy hashes. If the similarity score between the target
appandadatabaseappexceedsourthreshold,wereportapotential
repackage.
6 EVALUATION
The evaluation answers the following research questions:
RQ1How robust is our code representation against state of the
art obfuscation?(Section 6.1)
RQ2Howeffectiveis LibDetect comparedtootherlibrarydetec-
tionapproaches?(Section 6.2)
RQ3How effective is CodeMatch compared to other repackage
detection approaches?(Section 6.3)
In addition, we quantify the repackage share found by Code-
Matchinthe wild(Section 6.4).
6.1 RobustnessofCodeRepresentation
We assess the robustness of our code representations against ob-
fuscationbyapplying LibDetect toobfuscatedappsforwhichwe
knowthe libraries they use.
Setup.We downloaded all 193 APKs from Maven Central [ 32]
for which the build file (POM file) documents the used libraries.
We obfuscated these APKs with DexGuard [21], an extension of
ProGuard [6];theobfuscatorintegratedinto theAndroiddevelop-
ment environment and recommended by the Android developer
board [23]. Compared to ProGuard ,DexGuard adds more advanced
obfuscation techniques that we have also seen; in particular, string
encryption and fake types. We use DexGuard with the four pre-
set configurations: Renaming ,Optimization ,String encryption , and
644ESEC/FSE’17,September04-08,2017, Paderborn,GermanyLeonidGlanz, Sven Amann, MichaelEichberg,MichaelReif,
Ben Hermann, Johannes Lerch,andMiraMezini
Figure 3:Toolchainto Identify Repackaged Apps
allofthem Combined .DexGuard’sdefaultconfigurationenforces
Renaming ,because ofthat Renaming isalwaysenabled.
Duringtheobfuscationprocess DexGuard generatesadetailed
mapping which identifies the origin of every method. Using this
information, alongwith theinformationabout thelibraries stored
intheAPK’sPOMfile,weareabletoassesswhetheramethodis
correctlyclassifiedas belongingto alibrary.
Evaluation. Wefilteredallmethods( ≈26%)thathavelessthan10
instructions(e.g.,simplegettersandsettersordefaultconstructors);
such methods are indistinguishable after name mangling. After
that,wecheckedforeachmethodwhetheritis alibrarymethodor
notandatwhichabstractionlevel(cf.Algorithm1)themethodis
classifiedas alibrary method.
Results.Figure 4 shows how often LibDetect ’s method classi-
fication was able to correctly classify a method as belonging to
a library. For each configuration of DexGuard , the percentage of
foundmethodstototalmethodsperprojectisvisualizedusingstan-
dardbox-plots.Incaseof NameMangling weareabletocorrectly
classifymore than95% ofallmethods. Andeven if allobfuscation
techniquesare combinedwe stillidentifyover70% ofallmethods
correctly. These results show that the approach provides a good
starting pointfor alibrary detection.
Figure 5 shows the importance of each representation. It de-
picts at which abstraction level/representation an obfuscated li-
brary method was detected. As expected, BC and AR could not
find any library methods.Both rely on names, which are changed
bytheappliedobfuscationsinallconfigurations.However,these
representations are still valuable to identify methods that were not
obfuscatedśwhichare stillcommon inreal obfuscatedapps.
Interestingly, even if all obfuscation techniques are combined
the nameless representation (NR) already enables us to correctly
classify a method inthe vast majority ofcases ( >95%); this makes
NRthemostrelevantrepresentation.Nevertheless,therearealso
cases, where SPR and fuzzy SPR are needed to identify obfuscated
librarymethodsandthesecasesincreaseby0.5%perobfuscation
technique. Overall, the results indicate that our design decision to
consider the representations in increasing order of their level of
abstractionishelpful.
6.2 LibraryDetection
In this section, we present the results of comparing LibDetect with
otherlibrary detection approaches.
Figure4:DetectionRatesforDifferent DexGuard Configura-
tions.
Renaming Optimization StringEncryption Combined020406080100
Percentage
BC
AR
NR
SPR
Fuzzy SPR
Figure 5:Relevance ofRepresentations
Setup.We collected 8,000 Android related libraries: ≈7,000 from
MavenCentraland ≈1,000additionalJARscollectedmanuallyby
searching for package names from the common-library list of Li Li
et al. [29] and the package names of LibRadar ’s database [ 31] (cf.
shortdescriptionof LibRadar in4.1).TheMavenCentralJARswere
collected by analyzing the latest versions of the POM files with
dependenciestoAndroidAPIs(keywordłandroidžinthegroupids
of the dependency). Using all 8,000 libraries we build the reference
databaseas describedinSection 5.2.
For the evaluation of LibDetect in the wild, we randomly se-
lected 1,000 apps (99% confidence level; 5% confidence interval)
fromfiveappstores(Anzhi,GooglePlay,AppChina,HiApk,and
Freewarelovers) and measured the precision and recall of LibDe-
tect, the common library white list ( Common Libraries ) by Li Li
645CodeMatch : Obfuscation Won’t ConcealYourRepackagedApp ESEC/FSE’17,September04-08,2017, Paderborn,Germany
Common Libraries LibRadar LibDetect020406080100PercentagePrecision
Recall
F2
Figure 6: Average Precision and Recall of the Different Li-
brary Detection Approaches
et al. [29] andLibRadar [31]. We chose five different app stores
to avoid biases such as only small apps (Freewarelovers) or only
language-dependent apps (Anzhi). To determinethe groundtruth,
we first identified the libraries used by the apps through manual
code inspection. This enables us to assess both precision and recall.
Results.Figure 6 shows the average precision and recall of each
approach. CommonLibraries hasanaverageprecisionof99.6%and
arecallcloseto9.3% LibRadar hasanaverageprecisionof99.7%
and recall of 11.5 %. LibDetect has an average precision of 80.2%
andthe averagerecallis87.2%.
Discussion. Giventhatlibrarycodeisthemainreasonforfalse
positivesofcode-basedrepackage-detectionapproaches,identify-
ing as many library classes as possible (i.e., a high recall) is very
important.Toreflectthis,Figure6showstheharmonic-balanced
F2-measure, which weights recall higher than precision. We find
thatLibDetect identifiesthemajorityoflibrarycode( F2-measureof
85.7%)andthatitsignificantlyoutperformsthestate-of-the-arttool
LibRadar (RQ2).LibRadar’slowrecall 11.5% isdueto its package-
levelabstraction.Asdiscussedabove,thetoolmisseslibraryclasses
that are movedacrosspackage boundaries.
Acarefulanalysisofthefalsepositives/negativesof LibDetect re-
vealedthatthefalsepositivesareprimarilydueto Activity and
Listener -classes that occur often in UI-intensive apps and which
canbefoundinappcodeaswellasinlibrarycode.Theseclasses
oftenhaveverysimilarfunctionalityanddifferonlyintheirnames.
Hence,theyareindistinguishableto LibDetect,becausethe(original)
namesarenolongeravailable. LibDetect ’sfalsenegativesarecaused
bythefilteringofpotentiallyobfuscateddata-containerclassesofli-
braries;ingeneral,acontainerclassprimarilydefinesseveralfields
along with respective getters and setters and, as discussed, such
short methodsare filtered.
6.3 RepackageDetection
For the evaluation of CodeMatch , we collected all app descriptions
andtherespectivedeveloper’spublickeys(todifferentiatebetween
them) from an archive of the Google Play Store [ 27] and fuzzy-
hashedthedescriptionsofeachappwithSSDEEP[ 28].Afterwards,
we compared all fuzzy-hashed descriptions pairwise and randomly
selected1,000apppairs,whichhadatleast90%-similardescriptions
and were signed with different public keys. To identify which of
these pairs are actual repackages, we installed and executed theapp pairs on theemulator LeapDroid[ 35]. Subsequently, we man-
uallytaggedthem (astrulyrepackagedornot)by checkingtheir
similarityinthe following process:
(1)We checked whether the loading screen and main view
have the same structure andthe same icons.
(2)Incaseofdoubts,wethencheckedtheactions,whichcould
be performedfrom the main view.
(3)Ifwewerestillnotsureaboutthetag,wegeneratedfake
accounts, installed needed additional software, and per-
formedallactions that were possible.
(4)Iftheabovestepswereinsufficient,wealsoperformeda
visual inspection of the de-compiled code. If the code of
bothappswassimilar,weclassifiedtheappsasrepackages;
otherwiseas łme-toožproducts.
Following this process, we manually identified 377 app pairsas
actual repackages (true positives) and used all 1,000 app pairs to
evaluatetheprecisionandrecallof CodeMatch ,FSquaDra [42],View-
Droid[41],DroidMOSS [46], and a centroid-based approach [ 10] to
whichwe refer as Centroid.
To assess the effect of the different library-detection approaches
ontheoverallrepackagedetection,wefirstremovedall libraryapps
usingLibDetect,asdescribedinSection5.3.Theseappsaregenerally
falsely identified as repackaged apps by the other approaches as
theyhavenospecializedsupportforthiskindofappsandwewant
to avoid to biasthe results. We exclude library apps (mostly <300
LOC excluding library code), because it is practically impossible
to determine whether such apps are illegitimate repackages. For
example, most wallpaper apps only differ in the image, but are
generatedapps, ratherthanrepackages.
After that, we executed all repackage detectors that use some
library detection with all library detection approaches described in
Section6.2: LibRadar (LR),LibDetect (LD),andthe CommonLibraries
white list (WL). If a repackage detector was unable to classify a
repackagedapp,we counteditas false negative.
Results.Figure7presentstheaverageprecisionandrecallforthe
different combinations of repackage- and library detection tools.
Theresultsaregroupedbytherepackagedetectionapproachesand
sortedbythe averagerecall.
Combining LibDetect with any previous repackage-detection
approachresultsinanaverageprecisionof86%,whichisbetterthan
allcombinationsoftherespectiverepackage-detectionapproach
andany otherlibrary detection.
Allcombinationsof CodeMatch withanexistinglibrary-detection
approach performed at least as good as the combinations of the
respective library detection with any other repackage-detection
approach. However, CodeMatch +LibDetect achieves the highest
averagerecalland F1-score.
Overall,wecanconcludethat LibDetect leadstosignificantbetter
repackagedetectionresultsandsignificantlyimprovestheresults
ofCentroidwhen compared with the original results. Nevertheless,
CodeMatch +LibDetect gives the bestprecision andrecall.
6.4 App Data-Provision & Insights
We usedCodeMatch to assess the problem of repackaged apps in
thewild.Forthat,wedownloaded46,537appsfromfivedifferent
Androidappstoresandanalyzedhowmanyappsarerepackaged
646ESEC/FSE’17,September04-08,2017, Paderborn,GermanyLeonidGlanz, Sven Amann, MichaelEichberg,MichaelReif,
Ben Hermann, Johannes Lerch,andMiraMezini
DroidMOSS& WLDroidMOSS& LRDroidMOSS& LDFSquaDraViewDroid
Centroid& WLCentroid& LRCentroid& LD
CodeMatch & WLCodeMatch & LRCodeMatch & LD020406080100Percentage
Precision
Recall
F1
Figure 7: Average Precision, Recall and F1-Measure of the
DifferentRepackageDetection Approaches
Table 4:Analyzed Android AppsfromFive App Stores
AppStore Apps LibApps AppMaker Repackaged
Anzhi[1] 18,889 1,707 9.0% 72 0.4% 2,757 14.6%
Google Play [27] 17,751 371 2.1% 1,018 5.7% 3,510 19.8%
AppChina [2] 4,577 1,260 27.5% 21 0.5% 396 8.7%
HiApk[4] 4,472 1,106 24.7% 6 0.1% 608 13.6%
Freewarelovers [3] 848 583 68.8% 0 0% 20 2.4%
Total 46,537 5,027 10.8% 1,117 2.4% 7,291 15.7%
acrosstheindividualstores.Table4showsthedistributionofthe
apps across the stores. We obtained the APKs from AppChina,
HiApk, andFreewarelovers using DroidSearch[34].
Table4revealsthatupto5.7%oftheappsarecreatedusingApp
makers (see Section 5.3) andÐdepending on the storeÐbetween
2.1% and 68.8% of the apps are library apps with less than 300 lines
of app (glue) code. We filtered these apps before computing the
number of repackaged apps. Overall, 7,291 (15.7%) of the 46,537
apps are repackages. The problem seems to be most relevant for
the Google Play store;nearly 20%ofthe apps are repackages.
7 THREATS TO VALIDITY
Inthefollowing,wediscussthreatstovalidityrelatedtoourlibrary-
detection andrepackage-detection experiments.
We construct LibDetect ’s reference database from all libraries
inLibRadar ’s database, the latest Android related libraries from
Maven Central, all libraries from a public white lists [ 29] and a
popular-libraries list [ 11]. Nevertheless, the database may not con-
tainalllibrariesusedbyappsinourevaluationdatasets.Inthiscase,
LibDetect may fail to identify some library code and CodeMatch
mayincludethislibrarycodeintherepackagedetection.Bothcould
lead to other results than the reported ones, but ś given the size
andqualityofthedata setśthe overallerrorshouldbenegligible.
Assembling a large, up-to-date reference database for LibDe-
tectmightbeunpractical.Weargue,sinceweincludeonlypubliclibraries listed in public databases and lists, that assembling the
database could be fully automated, which would allow frequent
updateswithoutmanual effort.
TheevaluatedappsfromMavenCentralthatwechoseforlibrary
detection may not be representative for apps in general. We chose
theseappsbecausetheydocumentthelibrariesthattheydependon.
Thisallowedustoconstructagroundtruthfortheevaluationof
the library-detection tools (see Section 6.2). The experiment shows,
howwell LibDetect candiscover(library)codeembeddedinanapp,
after the entire app has been obfuscated. The impact of specific
apps onthe results oftheseexperiments should be rathersmall.
To evaluate the impact of obfuscation on library detection we
usedthe obfuscator DexGuard ,which appliesrenaming,optimiza-
tion,shrinking,andstringencryption.Tothebestofourknowledge
noexisting library detection handles more advancedtechniques.
Our ground-truth dataset for repackage detection may not be
representativeforappsingeneral.Wechoseoursamplefromthe
appsoffivedifferentappstores.Therefore,wefirstfilterthesetofall
pairs of apps from the stores for pairs with similar descriptions, as
describedinSection6.3.Thenweselectedarandomsampleof1,000
apppairs,whichisrepresentativeataconfidencelevelof99%anda
confidence interval of 5%. It is possible that this sampling strategy
introduces a bias, because repackages with dissimilar descriptions
are left out. However, the intent behind repackaging is to get users
to install the repackaged app instead of the original app, which
makes it likely that a similar description is used. Furthermore, the
app candidates were classified as repackaged or not-repackaged
throughamanualreviewbyoneoftheauthors(cf.Section6.3).Itis
possible that our primary criterion, the similarity of the apps’ user
interfaces, may lead to some wrong classifications. Due to the high
effort of reviewing 1,000 app pairs, it was infeasible to confirm the
reviewresults byadditionalreviewers.
8 CONCLUSION & FUTUREWORK
We presented an approach to detect repackaged apps that relies (1)
on a new advanced library detection approach and (2) the fuzzy
hashingoftheapp’scodetohandleadvancedcodeobfuscations.In
bothcases,werelyonahierarchyoffivedifferentcoderepresen-
tations. Each higher-level representation abstractsover additional
partsofthecodetocountermoreadvancedobfuscationtechniques.
Theevaluationdemonstratedtheeffectivenessoftheapproachin
matching code obfuscated using advanced obfuscators. The evalua-
tionfurtherrevealedthatśdependingonthelevelofobfuscationś
the differentrepresentations are necessary to matchcode.
Whenweappliedourtool CodeMatch torealworldappstaken
fromAndroidAppStores,wewereabletodeterminethat15%ofthe
apps can be foundinrepackagedform acrossdifferentapp stores.
Our implementionisavailable for download [21].
ACKNOWLEDGMENTS
This work was partially funded by the German Federal Ministry
of Education and Research (BMBF) within the Software Campus
projectEko, grant no. 01IS12054, the DFG as part of CRC 1119
CROSSING, as well as the Hessen State Ministry for Higher Educa-
tion,Researchandthe Arts (HMWK) within CRISP.
647CodeMatch : Obfuscation Won’t ConcealYourRepackagedApp ESEC/FSE’17,September04-08,2017, Paderborn,Germany
REFERENCES
[1]2017. AnzhiAppMarketplace. (2017). Retrieved01/11/2017fromhttp://www.
anzhi.com/
[2]2017. App China App Marketplace. (2017). Retrieved 01/11/2017 from http:
//www.appchina.com/
[3]2017. Freeware Lovers App Marketplace. (2017). Retrieved 01/11/2017 from
http://www.freewarelovers.com/
[4]2017. HiApkAppMarketplace. (2017). Retrieved01/11/2017fromhttp://www.
hiapk.com/
[5]AlexandrAndoniandPiotrIndyk.2006. Near-optimalhashingalgorithmsfor
approximate nearest neighbor in high dimensions. In 2006 47th Annual IEEE
SymposiumonFoundationsofComputer Science(FOCS’06) . IEEE,459ś468.
[6]EricLafortune at GuardSquare. 2017. ProGuard. (2017). Retrieved 01/11/2017
from http://proguard.sourceforge.net/
[7]MichaelBackes,SvenBugiel,andErikDerr.2016. ReliableThird-PartyLibrary
Detection in Android and its Security Applications. In Proceedings of the 2016
ACM SIGSAC Conference on Computer and Communications Security . ACM, 356ś
367.
[8]Apps Builder. 2017. Apps Builder. (2017). Retrieved 01/11/2017 from http:
//www.apps-builder.com
[9]Jian Chen, Manar H Alalfi, Thomas R Dean, and Ying Zou. 2015. Detecting
Android Malware Using Clone Detection. Journal of Computer Science and
Technology 30,5 (2015), 942ś956.
[10]KaiChen,PengLiu,andYingjunZhang.2014. Achievingaccuracyandscalability
simultaneouslyindetectingapplicationclonesonandroidmarkets.In Proceedings
ofthe 36thInternationalConference onSoftwareEngineering . ACM,175ś186.
[11]CodePath.2017. Must-HaveLibraries. (2017). Retrieved02/24/2017fromhttps:
//github.com/codepath/android_guides/wiki/Must-Have-Libraries
[12]Christian Collberg, Clark Thomborson, and Douglas Low. 1998. Manufacturing
cheap, resilient, and stealthy opaque constructs. In Proceedings of the 25th ACM
SIGPLAN-SIGACT symposium on Principles of programming languages . ACM,
184ś196.
[13]Licel Corporation. 2016. DexProtector Android Obfuscator. (2016). Retrieved
01/20/2017from https://dexprotector.com
[14]Licel Corporation. 2016. Stringer JavaObfuscator. (2016). Retrieved01/20/2017
from https://jfxstore.com/stringer/
[15]JonathanCrussell,ClintGibler,andHaoChen.2012. Attackoftheclones:De-
tecting cloned applications on android markets. In Computer SecurityśESORICS
2012. Springer, 37ś54.
[16]JonathanCrussell,ClintGibler,andHaoChen.2013. Scalablesemantics-based
detectionof similarandroid applications. In Proc. ofEsorics , Vol. 13.Citeseer.
[17]Yang Cuixia, Zuo Chaoshun, Guo Shanqing, Hu Chengyu, and Cui Lizhen. 2015.
UI Ripping in Android: Reverse Engineering of Graphical User Interfaces and its
Application. In 2015 IEEE Conference on Collaboration and Internet Computing
(CIC). IEEE,160ś167.
[18]DEastlake3rdandPaulJones.2001. USsecurehashalgorithm1(SHA1) . Technical
Report.
[19]MichaelEichbergandBenHermann.2014. Asoftwareproductlineforstaticanal-
yses:theOPALframework.In Proceedingsofthe3rdACMSIGPLANInternational
Workshop onthe State ofthe Art inJava ProgramAnalysis . ACM,1ś6.
[20]Parvez Faruki, Vijay Ganmoor, Vijay Laxmi, Manoj Singh Gaur, and Ammar
Bharmal. 2013. AndroSimilar: robust statistical feature signature for Android
malware detection. In Proceedings of the 6th International Conference on Security
ofInformationand Networks . ACM,152ś159.
[21]Leonid Glanz. 2017. CodeMatch Artifacts. (2017). Retrieved 06/30/2017 from
http://www.st.informatik.tu-darmstadt.de/artifacts/codematch/
[22]Hugo Gonzalez, Natalia Stakhanova, and Ali A Ghorbani. 2014. Droidkin: Light-
weightdetectionofandroidappssimilarity.In InternationalConferenceonSecurity
and Privacy inCommunication Systems . Springer, 436ś453.
[23]Google. 2017. Android Developers http://developer.android.com/tools/help/
proguard.html. (2017). Retrieved 01/11/2017 from http://developer.android.com/
tools/help/proguard.html
[24]Google. 2017. Enjarify. (2017). Retrieved 01/11/2017 from https://github.com/
google/enjarify
[25]WenjunHu,JingTao,XiaoboMa,WenyuZhou,ShuangZhao,andTingHan.2014.
Migdroid:Detectingapp-repackagingandroidmalwareviamethodinvocation
graph. In 201423rdInternational ConferenceonComputer Communicationand
Networks (ICCCN) . IEEE,1ś7.
[26]Smardex Inc. 2017. Allatori Java Obfuscator. (2017). Retrieved 02/20/2017 from
http://www.allatori.com[27]Jake J. 2017. PlayDrone Archive Snapshot 10/31/2014. (2017). Retrieved
01/11/2017 from http://archive.org/download/playdrone-snapshots/2014-10-31.
json
[28]Jesse Kornblum. 2006. Identifying almost identical files using context triggered
piecewisehashing. Digitalinvestigation 3 (2006), 91ś97.
[29] Li Li,Jacques Klein,YvesLe Traon,et al. 2016. Aninvestigation intothe use of
common libraries in android apps. In 2016 IEEE 23rd International Conference on
Software Analysis, Evolution, and Reengineering (SANER) , Vol. 1. IEEE, 403ś414.
[30]Menghao Li, Wei Wang, Pei Wang, Shuai Wang, Dinghao Wu, Jian Liu, Rui Xue,
andWeiHuo.2017. Libd:Scalableandprecisethird-partylibrarydetectionin
Android markets. In Proceedings of the 39th International Conference on Software
Engineering . IEEE Press,335ś346.
[31]Ziang Ma, Haoyu Wang, Yao Guo, and Xiangqun Chen. 2016. LibRadar: fast
andaccuratedetectionofthird-partylibrariesinAndroidapps.In Proceedings
ofthe38thInternationalConferenceonSoftwareEngineeringCompanion .ACM,
653ś656.
[32]ServicemarkofSonatypeInc.2017. MavenCentral. (2017). Retrieved01/11/2017
from http://search.maven.org/
[33]GuardSquare nv. 2017. DexGuard Android Obfuscator. (2017). Retrieved
02/20/2017from https://www.guardsquare.com/en/dexguard
[34]Siegfried Rasthofer, Steven Arzt, Max Kolhagen, Brian Pfretzschner, Stephan
Huber,EricBodden,andPhilippRichter.2015. Droidsearch:Atoolforscaling
androidapptriagetoreal-worldappstores.In ScienceandInformationConference
(SAI), 2015 . IEEE,247ś256.
[35]HuanRenandHuihongLuo.2017. LeapDroid. (2017). Retrieved01/11/2017from
http://www.leapdroid.com
[36]Monirul Sharif, Andrea Lanzi, Jonathon Giffin, and Wenke Lee. 2009. Automatic
reverse engineering of malware emulators. In Security and Privacy, 2009 30th
IEEE Symposiumon . IEEE,94ś109.
[37]PreEmptiveSolutions.2017. DashOJavaObfuscator. (2017). Retrieved02/20/2017
from http://www.preemptive.com/products/dasho
[38]Xabier Ugarte-Pedrero, Igor Santos, Pablo G Bringas, Mikel Gastesi, and
José Miguel Esparza. 2011. Semi-supervised learning for packed executable
detection.In NetworkandSystemSecurity(NSS),20115thInternationalConfer-
ence on. IEEE,342ś346.
[39]HaoyuWang,YaoGuo,ZiangMa,andXiangqunChen.2015. Wukong:Ascalable
and accurate two-phase approach to android app clone detection. In Proceedings
of the 2015 International Symposium on Software Testing and Analysis . ACM,
71ś82.
[40]ChristianWinter,MarkusSchneider,andYorkYannikos.2013. F2S2:Fastforensic
similarity search through indexing piecewise hash signatures. Digital Investiga-
tion10,4 (2013), 361ś371.
[41]Fangfang Zhang, Heqing Huang, Sencun Zhu, Dinghao Wu, and Peng Liu. 2014.
ViewDroid: towards obfuscation-resilient mobile application repackaging detec-
tion.InProceedingsofthe2014ACMconferenceonSecurityandprivacyinwireless
& mobilenetworks . ACM,25ś36.
[42]Yury Zhauniarovich, Olga Gadyatskaya, Bruno Crispo, Francesco La Spina, and
Ermanno Moser. 2014. FSquaDRA: fast detection of repackaged applications. In
IFIP Annual Conference on Data and Applications Security and Privacy . Springer,
130ś145.
[43]MinZheng,Mingshen Sun, and JohnCSLui.2013. Droidanalytics: asignature
based analytic system to collect, extract, analyze and associate android malware.
In2013 12th IEEE International Conference on Trust, Security and Privacy in
Computingand Communications . IEEE,163ś171.
[44]WuZhou, Zhi Wang, Yajin Zhou, and Xuxian Jiang. 2014. Divilar:Diversifying
intermediate language for anti-repackaging on android platform. In Proceedings
of the 4th ACM conference on Data and application security and privacy . ACM,
199ś210.
[45]WuZhou,YajinZhou,MichaelGrace,XuxianJiang,andShihongZou.2013. Fast,
scalabledetectionofpiggybackedmobileapplications.In Proceedingsofthethird
ACMconference onDataand application securityand privacy . ACM,185ś196.
[46]WuZhou,YajinZhou,XuxianJiang,andPengNing.2012. Detectingrepackaged
smartphone applicationsinthird-partyandroidmarketplaces.In Proceedingsof
thesecondACMconferenceonDataandApplicationSecurityandPrivacy .ACM,
317ś326.
[47]Yajin Zhou, Zhi Wang, Wu Zhou, and Xuxian Jiang. 2012. Hey, You, Get Off
of My Market: Detecting Malicious Apps in Official and Alternative Android
Markets..In NDSS, Vol. 25.50ś52.
648