A Symbolic Model Checking Approach to the Analysis of
String and Length Constraints
Hung-En Wang
Graduate Institute of Electronics Engineering
National Taiwan University
TaiwanShih-Yu Chen
Graduate Institute of Electronics Engineering
National Taiwan University
Taiwan
Fang Yu
Department of Management Information Systems
National Chengchi University
TaiwanJie-Hong R. Jiang
Graduate Institute of Electronics Engineering, Department
of Electrical Engineering
National Taiwan University
Taiwan
ABSTRACT
Strings with length constraints are prominent in software security
analysis.Recentendeavorshavemadesignificantprogressindevel-
oping constraint solversfor strings and integers. Most priormeth-
odsarebasedondeductionwithinferencerulesoranalysisusing
automata.Theformermaybeinefficientwhentheconstraintsin-
volve complex string manipulations such as language replacement;
thelatter maynotbe easilyextendedto handlelengthconstraints
andmaybeinadequateforcounterexamplegenerationduetoap-
proximation. Inspired by recent work on string analysis with logic
circuit representation, we propose a new method for solving string
withlengthconstraintsbyanimplicitrepresentationofautomata
with length encoding. The length-encoded automata are of infinite
states and can represent languages beyond regular expressions. By
converting stringand lengthconstraints into adependency graph
of manipulations over length-encoded automata, a symbolic model
checker for infinite state systems can be leveraged as an engine for
theanalysisofstringandlengthconstraints.Experimentsshowthat
our method has its unique capability of handling complex string
and length constraints not solvable by existing methods.
CCS CONCEPTS
•Software and its engineering →Formal software verifica-
tion;•Security and privacy →Logic and verification ;
KEYWORDS
length constraint, string analysis, symbolic model checking
ACM Reference Format:
Hung-En Wang, Shih-Yu Chen, Fang Yu, and Jie-Hong R. Jiang. 2018. A
SymbolicModelCheckingApproachtotheAnalysisofStringandLength
Constraints. In Proceedings of the 2018 33rd ACM/IEEE International Con-
ferenceonAutomatedSoftwareEngineering(ASE’18),September3–7,2018,
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,
topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ’18, September 3–7, 2018, Montpellier, France
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.3238189Montpellier, France. ACM, New York, NY, USA, 11pages.https://doi.org/10.
1145/3238147.3238189
1 INTRODUCTION
Formal analysis of string manipulating programs are crucial to de-
tect and rectify service applications. Many web service vulnerabili-
tiesareduetoimproperinputvalidationandsanitization.Anyerror
in validation and sanitization of user input can lead to a significant
vulnerabilityforawebapplication,andcanbeexploitedbymali-
cioususersall aroundtheworld.Inputvalidation andsanitization
inwebapplicationsiscrucialandchallengingsincecommunication
betweenthedifferentlayersofawebapplicationoccursthrough
directives (commands) that often embed user input and are writ-
teninmanylanguages,suchasXML,SQL,andHTML.Programs
that propagate and use malicious user inputs without validation
and sanitization, or with improper validation and sanitization, are
vulnerable to attacks such as XSS and SQL injection. In fact, to
datethesetwotypesofvulnerabilitiesinwebapplicationsareno-
torious,andtheyarewidelypublicized[ 1].Thisfactindicatesthe
intrinsicdifficultyofinputvalidationandsanitizationproblemsand
demonstrates the need for automated tool support that can help
programmersinpreventingvulnerabilitiesduetoerrorsinstring
manipulating programs. Even though many string constraint solv-
ingtechniques,e.g.,[ 2–9,11,12],havebeenproposed,analyzing
complex string manipulation programs remains challenging.
String constraint solving can be particularly hard when the con-
straints involve complex string operations and involve both string
and integer variables [ 13]. Specifically, it has been shown that solv-
ing string constraints with replace all and length constraints is un-
decidable [ 12,14]. Thereplace all operation is widely used in input
sanitization functions in Web applications. It defines the replace of
amatchpatternwithareplacementpatternforthesentencewithinagivensetoflanguage.Suchanoperationcanbeimplementedwith
finite state transducers [ 15,16] or automata [ 17], and hence can be
leveragedtosolvestringconstraintswithreplacement[ 8].While
anautomata-basedstringconstraintsolvertakesadvantageofau-
tomataconstructionforstringmanipulationsofunboundedstrings,
it often adopts regular abstraction to approximate solutions that
cannotberepresentedwithfinite-stateautomata.Thisregularap-
proximation limits the ability of presentations on relations among
string variables [ 18]. For example, to deal with length constraints,
623
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Hung-En Wang, Shih-Yu Chen, Fang Yu, and Jie-Hong R. Jiang
one approach is to derive and refine arithmetic automata, a.k.a.
lengthautomata,in[ 8,19]fromstringoperationstotracklength
relations during the computation. The constraint on length of each
stringvariablecanthenbederivedfromthearithmeticautomata
torefinethestringautomata.Thismethodoverapproximatesthe
relationoflengthsofstringvariablesinarithmeticautomata.On
the other hand, the SMT-based approaches, e.g., [ 2–7], for string
constraint solving are native to deal with length constraints. While
these DPLL(T)-based solvers handle a variety of string constraints,
including word equations, regular expression membership, length
constraints,and(morerarely)regular/rationalrelations;thesolvers
can not handle some string manipulations such as replace all. A
recent work that extends S3 [ 2] to S3P [ 20] addresses this issue
with recurrence to reason such operations. Later we show that
the recursive operation may cause non-termination, and lead to
non-robust results of constraint solving. Trau [ 11] integrates SMT
solvers with the CEGAR framework using flat automata to over
and under approximation the solution set.
In this work, we propose a new symbolic model checking ap-
proach to mixed string and integer constraint solving. A class ofinfinite state automata is introduced to encode length informa-tionwithinstringautomata.Alength-encodedautomatonkeepsthe length information of strings as integer values in its states.
Through manipulations over length-encoded automata, we can not
only model complex string operations, but also deal with length
constraints.Theconstructedlength-encodedautomatonatthesink
node of a dependency graph precisely characterize the correspond-
ing mixed string and integer constraints. Symbolic model checking
algorithmsforinfinitestatesystems canthenbeexploitedforlan-guage emptiness checking of the length-encoded automata.
BuildingupontheSLOGframework[ 9],theproposedmethod
is implemented as a tool, named Slent [ 10], to handle both string
and length constraints. We extend the circuit representation of
finite-stateautomata[9]to infinite-stateautomatabyaddinginte-
ger variables for tracking length information. We exploit software
modelcheckingalgorithms[ 21,22]asthebackendcomputationen-
gine.Experimentsshowtheuniqueadvantagesof Slentcompared
to modernstring constraint solvers, suchas S3P [ 20], Z3STR3 [ 3],
CVC4[4],Norn[7],ABC[8],andTRAU[ 11].Ourmethoduniquely
solves a number of complex benchmarks and can support coun-
terexamplegenerationofinputstringsaswitnesswhenthesetof
constraints under analysis is satisfiable.
2 OVERVIEW
To motivate, consider the following example of constraints
X1∈a∗,
X2∈b∗,
X3=X1.X2,
X4=replace(X3,a+b,ba),
Len(X1)=Len(X2),
Len(X1)>Len(X4),where the replace operator Y=replace(X,R1,R2)is a language-
to-language replace-all operation [ 17]1, which can be alternatively
defined by
((Y=X)∧X/nelement(Σ∗.R1.Σ∗))∨
((X=X1.X2.X3)∧(X1/nelement(Σ∗.R1.Σ∗))∧
(X2∈R1)∧(Y=X1.Y1.Y2)∧(Y1∈R2)∧
(Y2=replace(X3,R1,R2)),
and the Len operation constrains the length of a string variable.Note that the above constraints
(X3=X1.X2)and(Len(X1)=
Len(X2))ensurethat X3isinthelanguage anbn,forn≥0beingthe
lengths of X1andX2. ThenX4is obtained by performing language
to language replacement onX3. ForX4=replace(X3,a+b,ba),a
substring of the form amb, for some 1 ≤m≤n, in the middle
ofanbnwillbereplacedwith ba.Inthiscase,wehave Len(X4)=
2n−(m+1)+2>n=Len(X1),whichcontradictsthelastconstraint
Len(X1)>Len(X4). Hence the set of constraints is unsatisfiable.
Forrule-basedsolvers,solvingconstraintsinvolvingbothreplace-
all(incontrastto replace-first [23])andlengthoperationsisdifficult
for three reasons. First, the recursive definition of replace-all op-
erationmayinducenontermination[ 20].Second,intherecursive
definition of replace-all operation querying non-membership of
theform (X/nelementΣ∗.R.Σ∗),whereRisaregularexpression,isfunda-
mentally difficult for rule-based solvers. In fact, even the simpleexample
(X/nelementa∗)∧(X∈a∗a)can be difficult for solvers such
asCVC4[ 4],Z3STR3[ 3],andS3P[ 20]tosolve.Third,thelength
relation between strings before and after several string operations
is hard to be captured. For instance, let X1=“aa,”X2=“bb,”
X3=“aabb,” andX4=“abab” (obtained by replacing the middle
abinX3withba).Thenthefirstsymbol“ a"inX1isalsoremainedin
X4, and contribute to both the lengths of X1andX4. Such relations
on string lengths may be even more complicated and harder to
capture when more operations are involved between two strings.
Forautomata-basedsolvers,thereplacementoperationcanbe
naturally achieved by automata-based construction [ 17]. However,
the satisfying values of variables X1,X2,X3,X4in the above ex-
amplearenotregularduetotheconditionimposedbythelength
constraints. They cannot be represented precisely with finite-state
automata. To cope with length constraints, prior work [ 8,24] con-
structed automata for string constraints and for length constraints
separately.Thearithmeticautomataderivedfromlengthconstraints
were used to refine the string automata derived from string con-
straints.Nevertheless,therelationsamongvariablescannotbekept
precisely.Thisimprecisenessmayover-approximatethesolutions
to the above set of constraints and mistakenly conclude its satisfia-
bility.Inpriorwork[ 11],aCEGAR-basedframeworkwasproposed
usingflatautomataforconstraintrefinement.Withoutcapturing
the length relation between variables before and after replacement,
themethodmightnothaveproperrefinementtoguaranteetermina-
tion on the above example. Recent work [ 25] exploited alternating
automatatorepresentstringformulasconsistingofwordequations,
1The recursive replace-all operation defined in [ 20] specifies each to-be-replaced
substring being the leftmost possible candidate. In contrast, the replace-all operation
considered in this work follows [ 17]. It allows a to-be-replaced substring being at any
position, and thus may yield more replacement solutions than [ 20]. We refer to the
two replace-all definitions as replace-all-first of S3P and replace-all-any of Slent.
624
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. A Symbolic Model Checking Approach to the Analysis of ... ASE ’18, September 3–7, 2018, Montpellier, France
regular constraints, and rational constraints. Although it may han-
dle length constraints and relation among variables, its scope is
limitedtosomedecidablefragmentofformulas.Theaboveexample
isunfortunatelybeyondthedecidablefragmentasvariable X4by
the method would appear in two rational constraints.
Figure 1: Dependency graph for constraint solving.
In this work, we propose length-encoded automata to character-
ize string and integer constraints. We assume the string and length
constraints can be represented with a dependency graph, which
isatreethatspecifieshowthelength-encodedautomataarecon-
structedwithrespecttothegivenconstraints.Figure 1showsthe
dependency graph of automata construction corresponding to the
above example of constraints. In the graph, each source node (with-
out incoming edges) corresponds to a finite automaton accepting a
pre-specifiedregularlanguage,andeachinternalnodecorresponds
to an automata operation such as concatenation, replacement, etc.
For each internal node with operation Op, an automaton can be
constructedbyperformingtheoperationOponitsimmediateup-
stream automata. We introduce a new TrkLen operation to attach
anintegervariablegloballyseenbyallstatesofanautomatonto
track the length information. A non-epsilon transition of an au-
tomaton should incur a length increment by one, and thus theinteger indicates the length of the string currently taken by theautomaton. Such automata with length encoded integers are re-
ferred to as length-encoded automata. By setting the initial value of
anintegertozero,aftertakinganinputsequence,thefinalvalue
of the integer will be the length of this sequence. Note that the
length constraints and initialization of the length integers are only
imposed on the automaton, called sink automaton, at the sink node
(without outgoing edges) of the dependency graph before the final
languageemptinesscheckingIsEmp.Thesetoflengthconstraints
isimposedaspartoftheacceptingconditionofthesinkautomaton.
Inanautomataoperation,anintegercarriedbyanautomaton Ai,
which is involved in the operation, increases its value only when a
transition takes place among the states of Ai, and retains its value
when a transition takes place among the states of other automaton
Ajforj/nequali.Thereby,theproposedmethodcanpreciselycapturep
[n1]a
(a)
q
[n2]b
(b)
p
[n1]q
[n2]a
ϵb
(c)
Figure 2: Length-encoded automata for (a) A1,(b )A2, and (c)
A3.
complex length relations among different strings with replacement
involved.
Toillustratehowintegersarecarriedthroughautomataopera-
tions,weconsiderinFigure 1theconstructionofautomaton A3for
string variable X3, which is the result of concatenating string vari-
ablesX1andX2. Figure2(a) and (b) show the two length-encoded
automata A1andA2for variables X1andX2, respectively. Automa-
tonA1has one state pand recognizes the language a∗, andA2has
one state qand recognizes the language b∗. By length tracking, A1
isattachedwithaninteger n1,whosevalueincrementswhenever
anon-ϵ-transitiontakesplace amongstatessharing n1.Itrecords
thelengthoftheinputsequencetakenby A1sofar.Similarly, A2
is attached with an integer n2. In general, a state of an automaton
can possibly be attached with one or multiple integers, denoted
[ni1,...,nik], through a sequence of automata operations.
In Figure 2(c), automaton A3is constructed by concatenating
A1andA2.InA3,therearetwostates,state pattachedwith n1is
fromA1, and state qattached with n2is fromA2. The integer n1
(respectively n2)increasesitsvalueonlywhentheself-transitionon
statep(respectively q)takesplace.Essentially, n1countsthenumber
ofa’stakensofaronstate p,andn2countsthenumberof b’staken
625
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Hung-En Wang, Shih-Yu Chen, Fang Yu, and Jie-Hong R. Jiang
so far on state q.I fn1andn2are initialized to 0 and the constraint
n1=n2is added to the accepting condition, then automaton A3
accepts exactly the context free language {anbn|n∈N}. In fact,
even the context-sensitive language {anbmcndm|n,m∈N}can
be represented with the length-encoded automata.
3 PRELIMINARIES
Anautomaton is a 5-tuple (Q,Σ,I,O,T), whereQis a set of states,
Σis a finiteset of input alphabet, I⊆Qis the setof initial states,
O⊆Qis the set of accepting states, and T⊆Σ×Q×Qis the
transition relation. In this work, Qcan be an infinite state set. In
the sequel, we shall represent the initial states, accepting states,
and transition relation by their characteristic functions I:Q→B,
O:Q→B, andT:Σ×Q×Q→B, respectively, for Bbeing
the Boolean domain {false,true}. (A characteristic function χis
a propositional function representing a set Sby having χ(e)=1
(True) if e∈Sandχ(e)=0 (False) if e/nelementS.) We refer /vecx,/vecsand/vecs/prime
tothe input,current-state andnext-state variablesinthe Boolean
domain, and relatethe valuations of variables /vecx, denoted [[ /vecx]], and
thevaluationsofvariables /vecs,denoted [[/vecs]],totheinputalphabetand
state set, respectively.
An automaton can be either deterministic ornondeterministic,
dependingonwhetherornotthereisauniquenextstate q/prime∈Qthat
satisfiesT(σ,q,q/prime)for every input σ∈Σand current state q∈Q.
Weassumeanautomatoncanbenondeterministicandmayhave
ϵ-transitions.Forthesakeofconvenience,wereserveasymbolnot
inΣto represent “ ϵ", i.e., the empty input. For a given transition
relationT, we write Tϵto denote the transition relation derived
fromTwith an additional ϵself-transition added to each state.
Astring/vecσof length jover alphabet Σis a finite sequence σ1,
...,σjofinputsymbols,where σi∈Σfori=1,...,j.Thelength
of sequence /vecσis denoted as Len(/vecσ).Arunof an automaton is a
state-input alternating sequence q0,σ1,q1,σ2,...,σj,qj, which
satisfiesT(σi,qi−1,qi)=truefori=1,...,j. A string σ1,...,σj
is accepted by an automaton if there exists a run q0,σ1,q1,σ2,...,
σj,qjwithI(q0)=trueandO(qj)=true. Given an automaton
A, thelanguage ofA, denote as L(A), is the set of strings accepted
byA.
We define a length-encoded automaton to be an infinite state
automaton with its state set of the form Q=Qs×Qn, whereQs
is a finite set and Qn=Nkfor some non-negative integer kandN
beingthesetofnon-negativeintegers.Notethatwhen k=0,the
5-tuple degenerates to a finite automaton. Since both ΣandQsare
finite,theirconstituentelementsareBooleanencodedinthesequel.
Hence, the characteristic functions I,T,Ocan be represented with
first order logic formulas over Boolean and integer variables.
Thestringandintegerconstraintsconsideredinthisworkcan
beformallydefinedthroughthefollowingsyntacticconstruction
rules.Regular expression R....=ϵ|Σ|R.R|R∪R|R∗
|∼R
Automata A....=Reg2Aut( R)|TrkLen( A)
|Int(A,A)|Uni(A,A)
|Cat(A,A)|Del(A,ξ)
|Rep(A,AR,AR)|Rev(A)
|Pfx(A,n)|Sfx(A,n)
|Sub(A,n1,n2)
|TrkIdx(A,/vecσ,n)
Length constraint C....=c1n1+...+cmnm=c
|c1n1+...+cmnm>c
|/vecn=GetIntVars( A)
|C∧C|C∨C|¬C
Language query P....=IsEmp(A,C)
In the above expressions, Rrepresents a regular expression, A
representsanautomaton(possiblywithinfinitestates), ARrepre-
sents a finite state automaton accepting some regular language
R, andCrepresents an Boolean combination of linear arithmetic
constraints. Moreover, ξ∈Σis an input symbol, constant coeffi-
cientsareexpressedwithletter candci,andvariableparameters
are expressed with letter nandni. The regular expressions are
constructed with operators: concatenation “ .”, union “ ∪”, Kleene
star“∗”,andlanguagecomplement“ ∼”.Theautomataoperationsin-
clude regular expression to automata conversion Reg2Aut, length
tracking TrkLen, intersection Int, union Uni, concatenation Cat,
deletion Del, replacementRep, reverse Rev, prefixPfx, suffixSfx,
substring Sub, and index tracking TrkIdx, which are to be detailed
inSection 4.TheautomataoperationTrkLenintroducesaninte-
gervariabletotrackthelengthofeachstringacceptedby A.The
automata operation TrkIdx takes an automaton A, a string /vecσ, and
an integer parameter nas input, and introduces an integer variable
to track the position of the first occurrence of substring /vecσafter the
nthposition of each string accepted by A. The length constraint
operationGetIntVarsretrievestheintegervariablesintroduced
byautomata operationsTrkLenandTrkIdx.The languagequery
operation IsEmpty checks whether the language L(A)of the given
automaton Ais empty subject to the given length constraint C.
Given a set of string and integer constraints, we construct a
dependency graph whose sink length-encoded automaton corre-
spondstothesolutionsetoftheconstraints.Inthiswork,wefocus
on the set of string and integer constraints whose dependency
graph representation exists.
4 AUTOMATA MANIPULATION
We extend the prior method [ 9] using circuit representation for
finite state automata manipulation to length-encoded infinite state
automata manipulation. The new representation differs from [ 9]i n
that it includes the integer length variables in the inputs of the cir-
cuit,whichisthereforenolongerBoolean.Weshowhowautomata
operations,including lengthtracking, intersection, union,concate-
nation,deletion,replacement, reversion, prefix,suffix,substring, and
626
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. A Symbolic Model Checking Approach to the Analysis of ... ASE ’18, September 3–7, 2018, Montpellier, France
indextracking,canbeachievedunderourrepresentationofinfinite
state automata.
In the following discussions, we shall assume an automaton
A(orAi) (before length encoding) is represented as a Boolean
circuitofitscharacteristicfunctions T(/vecx,/vecs,/vecn,/vecs/prime,/vecn/prime),I(/vecs),andO(/vecs)
(orTi(/vecx,/vecsi,/vecni,/vecs/prime
i,/vecn/prime
i),Ii(/vecsi), andOi(/vecsi)fori= 1, 2, 3). Also without
lossofgeneralityweassumethat |/vecs1|=mand|/vecs2|=lforautomata
A1andA2, respectively, with m≤lin our following discussions
unless otherwise said.
4.1 Length Tracking
Given a finite state automaton Awith its three characteristic func-
tionsT(/vecx,/vecs,/vecs/prime),I(/vecs), andO(/vecs), where/vecx,/vecs, and/vecs/primeare the input,
current-state, and next-state variables, respectively, the length
tracked version, denoted ALin the sequel, of Acan be constructed
by operation TrkLen(A), which embeds an integer variable nto
count the numberof transitions in T. So the stateset of ALis aug-
mentedto [[/vecs]] ×N,andALbecomesaninfinitestateautomatondue
to the unbounded length value of n. The characteristic functions of
AL=TrkLen(A)can be obtained as follows.
TL(/vecx,/vecs,n,/vecs/prime,n/prime)=T(/vecx,/vecs,/vecs/prime)∧(((/vecx/nequalϵ)∧(n/prime=n+1))
∨((/vecx=ϵ)∧(n/prime=n)))
IL(/vecs)=I(/vecs)
OL(/vecs)=O(/vecs)
Therefore,aftertakinganon- ϵtransitionfromacurrentstate (/vecs,n)
toanextstate (/vecs/prime,n/prime),thevalueof n/primeequalsn+1.Otherwise,under
anϵtransition, the value of n/primestays the same as n.
Notice that the length tracking does not affect characteristic
functions IandO.Rather,wewillonlyinitializethelengthtracking
integer variables on the initial states and impose the length con-
straints over the length tracking integer variables on the accepting
states of the sink automaton of a dependency graph for the final
language emptiness checking, to be detailed in Section 4.12.
Note also that during the iterative automata construction ac-
cording toa dependencygraph, anautomaton mayhave multiple
lengthtrackingvariables /vecninheritedfromitsupstreamautomatain
thedependencygraph.Ifthelengthoftheautomatonneedstobe
considered, then a new tracking variable needs to be introduced in
additiontotheinheritedtrackingvariables.Thatis,ifanautoma-
tonAwith transition relation T(/vecx,/vecs,/vecn,/vecs/prime,/vecn/prime)for/vecn=(n1,...,ni)
and/vecn/prime=(n/prime
1,...,n/prime
i), then the transition relation TL(/vecx,/vecs,(n1,
...,ni+1),/vecs/prime,(n/prime
1,...,n/prime
i+1))ofALequalsT(/vecx,/vecs,/vecn,/vecs/prime,/vecn/prime) ∧ (((/vecx/nequal
ϵ)∧(n/prime
i+1=ni+1+1))∨((/vecx=ϵ)∧(n/prime
i+1=ni+1))).
4.2 Intersection
Giventwoautomata A1andA2,thethreecharacteristicfunctions
of automaton AInt=Int(A1,A2)that accepts language L(A)=
L(A1)∩L(A2)can be constructed as follows.
TInt(/vecx,/vecs,/vecn,/vecs/prime,/vecn/prime)=Tϵ
1(/vecx,/vecs1,/vecn1,/vecs/prime
1,/vecn/prime
1)∧
Tϵ
2(/vecx,/vecs2,/vecn2,/vecs/prime
2,/vecn/prime
2),
IInt(/vecs)=I1(/vecs1)∧I2(/vecs2),
OInt(/vecs)=O1(/vecs1)∧O2(/vecs2),࢞′࢔࢔′࢙࢙ ࢀ૚ࢀࣕ૛ࣕࢀࡺࡵࢀ
࢙૛ࡵ૚ ࡵ૛ࢀࡺࡵࡵ
ࡻ૚ ࡻ૛ࢀࡺࡵࡻ
࢙૚ ࢙૛ ࢙૚
Figure 3: Circuit construction of Int operation.
where/vecs=(/vecs1,/vecs2)and/vecn=(/vecn1,/vecn2). The corresponding circuit
construction is shown in Figure 3.
4.3 Union
Giventwoautomata A1andA2,thethreecharacteristicfunctions
of automaton AUni=Uni(A1,A2)that accepts language L(A)=
L(A1)∪L(A2)can be constructed by disjointly unioning the two
withstatevariablesbeingmergedandstatesbeingdistinguishedby
afreshnewauxiliaryBooleanvariable α,similartothemultiplexed
machine in [26], as follows.
TUni(/vecx,/vecs,/vecn,/vecs/prime,/vecn/prime)=(¬α∧¬α/prime∧
T1(/vecx,/angbracketleft/vecs2/angbracketrightm,/vecn1,/angbracketleft/vecs/prime
2/angbracketrightm,/vecn/prime
1))∨
(α∧α/prime∧T2(/vecx,/vecs2,/vecn2,/vecs/prime
2,/vecn/prime
2)),
IUni(/vecs)=(¬α∧I1(/angbracketleft/vecs2/angbracketrightm))∨(α∧I2(/vecs2)),
OUni(/vecs)=(¬α∧O1(/angbracketleft/vecs2/angbracketrightm))∨(α∧O2(/vecs2)),
where/vecs=(/vecs2,α),/vecn=(/vecn1,/vecn2), and the bracket “ /angbracketleft/vecs2/angbracketrightm” indicates
taking a subset of the first mvariables of /vecs2. Essentially the state
variables /vecs1ofA1are merged into /vecs2so that the first mvariables
of/vecs2are shared by both A1andA2. (Recall the assumption that
|/vecs1|≤| /vecs2|.)Moreover,the αbitofthestatevariables /vecsdistinguishes
the states of A1byα=0 and the states of A2byα=1. That is, a
stateq∈[ [ /vecs]]belongs to A1if its variable αvaluates to 0, and to A2
ifαvaluates to 1. The corresponding circuit construction is shown
in Figure 4.
4.4 Concatenation
Giventwoautomata A1andA2,thethreecharacteristicfunctionsof
theautomaton ACat=Cat(A1,A2)thatacceptstheconcatenated
627
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Hung-En Wang, Shih-Yu Chen, Fang Yu, and Jie-Hong R. Jiang
࢙૛࢙૛ᇱ࢞′࢔࢔ ࢀ૚ࢀ૛ࡵࡺࢁࢀ
ࢻࢻᇱࢻࢻᇱ
࢙૛ࡵ૚ࡵ૛ࡵࡺࢁࡵ
ࢻࢻ 
࢙૛ࡻ૚ࡻ૛ࡵࡺࢁࡻ
ࢻࢻ 
Figure 4: Circuit construction of Uni operation.
ࢀ࡭࡯ࢀ
࢙૛࢙૛ᇱ࢞′࢔࢔ ࢀ૚ ࢀ૛ࢻࢻᇱࢻࢻᇱ
〈࢙૛〉࢓ࡵ૚ࢀ࡭࡯ࡵ
ࢻ
࢙૛ࡻ૛ࢀ࡭࡯ࡻ
ࢻ
ࡻ૚ࡵ૛࢔=࢔ᇱࣕ=࢞࢔ ૛=࢔૛ᇱ࢔૚=࢔૚ᇱ
Figure 5: Circuit construction of Cat operation.
language L(A)=L(A1).L(A2)can be constructed as follows.
TCat(/vecx,/vecs,/vecn,/vecs/prime,/vecn/prime)=(¬α∧¬α/prime∧
T1(/vecx,/angbracketleft/vecs2/angbracketrightm,/vecn1,/angbracketleft/vecs/prime
2/angbracketrightm,/vecn/prime
1)∧
(/vecn2=/vecn/prime
2))∨
(α∧α/prime∧T2(/vecx,/vecs2,/vecn2,/vecs/prime
2,/vecn/prime
2)∧
(/vecn1=/vecn/prime
1))∨
((/vecx=ϵ)∧¬α∧α/prime∧O1(/angbracketleft/vecs2/angbracketrightm)∧
I2(/vecs/prime
2)∧(/vecn=/vecn/prime)),
ICat(/vecs)=¬α∧I1(/angbracketleft/vecs2/angbracketrightm),
OCat(/vecs)=α∧O2(/vecs2),
where/vecs=(/vecs2,α)and/vecn=(/vecn1,/vecn2). Thecorresponding circuitcon-
struction is shown in Figure 5.
4.5 Deletion
Given an automaton Aand a symbol ξ, the three characteristic
functions of the automaton ADel=Del(A,ξ)that accepts the
strings in L(A)with each occurrence of ξbeing eliminated fromthem can be constructed as follows.
TDelξ(/vecx,/vecs,/vecn,/vecs/prime,/vecn/prime)=(T(/vecx,/vecs,/vecn,/vecs/prime,/vecn/prime)∨((/vecx=ϵ)∧
T(ξ,/vecs,/vecn,/vecs/prime,/vecn/prime)))∧(/vecx/nequalξ),
IDelξ(/vecs)=I(/vecs),
ODelξ(/vecs)=O(/vecs).
4.6 Replacement
Given three automata A1,A2, andA3, forA2andA3being finite
state automata without length tracking, with ϵ/nelementL(A2), we con-
struct the automaton ARep=Rep(A1,A2,A3)that accepts the
language {(/vecσ1./vecτ1./vecσ2./vecτ2...)∈Σ∗|(/vecσ1./vecρ1./vecσ2./vecρ2...)∈L (A1),/vecσi/nelement
(Σ∗.L(A2).Σ∗),/vecρi∈L (A2)and/vecτi∈L (A3)foralli},thatis,replac-
ingL(A2)withL(A3)inL(A1). We extend the construction in [ 9]
based on [17].
Wefirstconstruct A/triangleleft⊿
1toacceptstringsin L(A1)withanysub-
string being flanked by two fresh new symbols /triangleleftand⊿as follows.
T/triangleleft⊿
1=((α=α/prime)∧(/vecx/nequal/triangleleft)∧(/vecx/nequal⊿)∧
T1(/vecx,/vecs1,/vecn1,/vecs/prime
1,/vecn/prime
1))∨
((/vecs1=/vecs/prime
1)∧(/vecn1=/vecn/prime
1)∧((¬α∧α/prime∧(/vecx=/triangleleft))∨
(α∧¬α/prime∧(/vecx=⊿)))),
I/triangleleft⊿
1=¬α∧I1(/vecs1),
O/triangleleft⊿
1=¬α∧O1(/vecs1).
Then we construct A4, a finite automaton without length track-
ing, to accept the language {/vecσ1/triangleleft/vecτ1⊿/vecσ2/triangleleft/vecτ2⊿.../vecσ/lscript|/vecτi∈
L(A2),/vecσi∈∼ (Σ∗.L(A2).Σ∗)}.
T4=(¬β∧¬β/prime∧(/vecx/nequal/triangleleft)∧(/vecx/nequal⊿)∧Th(/vecx,/vecsh,/vecs/prime
h))∨
(β∧β/prime∧(/vecx/nequal/triangleleft)∧(/vecx/nequal⊿)∧
T2(/vecx,/angbracketleft/vecsh/angbracketrightm,/angbracketleft/vecs/prime
h/angbracketrightm))∨
(¬β∧β/prime∧(/vecx=/triangleleft)∧Oh(/vecsh)∧I2(/angbracketleft/vecs/prime
h/angbracketrightm))∨
(β∧¬β/prime∧(/vecx=⊿)∧O2(/angbracketleft/vecsh/angbracketrightm)∧Ih(/vecs/prime
h)),
I4=¬β∧Ih(/vecsh),
O4=¬β∧Oh(/vecsh),
whereAhisanautomatonthatacceptsthelanguage ∼(Σ∗.L(A2).Σ∗).
OftenA2is known a priori, and the complement of Σ∗.L(A2).Σ∗
can be done in a preprocessing step.
628
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. A Symbolic Model Checking Approach to the Analysis of ... ASE ’18, September 3–7, 2018, Montpellier, France
Afterbuilding A5=Int(A/triangleleft⊿
1,A4),wecanfinishtheconstruction
of the replacement automaton ARepas follows.
TRep(/vecx,/vecs,/vecn,/vecs/prime,/vecn/prime)=(¬α∧¬α/prime∧T5(/vecx,/vecs5,/vecn5,/vecs/prime
5,/vecn/prime
5)∧
¬γ∧¬γ/prime∧I3(/vecs3)∧I3(/vecs/prime
3))∨
(¬α∧¬α/prime∧(/vecx=ϵ)∧(/vecs5=/vecs/prime
5)∧
(/vecn5=/vecn/prime
5)∧
¬γ∧γ/prime∧I3(/vecs3)∧I3(/vecs/prime
3))∨
(¬α∧¬α/prime∧(/vecs5=/vecs/prime
5)∧
(/vecn5=/vecn/prime
5)∧
γ∧γ/prime∧T3(/vecx,/vecs3,/vecs/prime
3))∨
(¬α∧α/prime∧(/vecx=ϵ)∧
T5(/triangleleft,/vecs5,/vecn5,/vecs/prime
5,/vecn/prime
5)∧
γ∧¬γ/prime∧I3(/vecs/prime
3)∧O3(/vecs3))∨
(α∧α/prime∧(/vecx=ϵ)∧
∃/vecy.[T5(/vecy,/vecs5,/vecn5,/vecs/prime
5,/vecn/prime
5)]∧
¬γ∧¬γ/prime∧I3(/vecs3)∧I3(/vecs/prime
3))∨
(α∧¬α/prime∧(/vecx=ϵ)∧
T5(⊿,/vecs5,/vecn5,/vecs/prime
5,/vecn/prime
5)∧
¬γ∧¬γ/prime∧I3(/vecs3)∧I3(/vecs/prime
3)),
IRep(/vecs)=¬γ∧I5(/vecs5)∧I3(/vecs3),
ORep(/vecs)=¬γ∧O5(/vecs5)∧I3(/vecs3),
where/vecs=(/vecs5,/vecs3,γ), and/vecn=/vecn5=/vecn1.
4.7 Reverse
Given an automaton A, the three characteristic functions of au-
tomatonARev=Rev(A)that accepts the set of reversed string of
/vecσ∈L (A)can be constructed as follows.
TRev(/vecx,/vecs,/vecn,/vecs/prime,/vecn/prime)=T(/vecx,/vecs/prime,/vecn,/vecs,/vecn/prime),
IRev(/vecs)=O(/vecs),
ORev(/vecs)=I(/vecs).
4.8 Prefix
Given an automaton A1, the three characteristic functions of au-
tomaton APfxk=Pfx(A1,k)that accepts the language L(A)=
{/vecσ|∃/vecρ.[/vecσ/vecρ∈L (A1)]∧len(/vecσ)=k}, can be constructed as follows.
TPfxk(/vecx,/vecs,/vecn,/vecs/prime,/vecn/prime)=(¬α∧¬α/prime∧Tϵ
1(/vecx,/vecs1,/vecn1,/vecs/prime
1,/vecn/prime
1)
∧((/vecx/nequalϵ∧(k/prime=k+1))∨
(/vecx=ϵ∧(k/prime=k))))∨
(¬α∧α/prime∧(/vecx=ϵ)∧(/vecs1=/vecs/prime
1)∧
(/vecn1=/vecn/prime
1)∧(k/prime=k))∨
(α∧α/prime∧(/vecx=ϵ)∧
∃/vecy.T1(/vecy,/vecs1,/vecn1,/vecs/prime
1,/vecn/prime
1)∧
(k/prime=k)),
IPfxk(/vecs)=¬α∧I1(/vecs1),
OPfxk(/vecs)=α∧O1(/vecs1),
where/vecs=(/vecs1,α)and/vecn=(/vecn1,k).Herekisusedtotrack len(/vecσ).If
thereisanyconstrainton k,itshouldbeinthearithmeticconstraintCimposedonthelanguageemptinesscheckingforthesinknode
of the dependency graph.
4.9 Suffix
Given an automaton A1, the three characteristic functions of au-
tomaton ASfxk=Sfx(A1,k)that accepts the language L(A)=
{/vecσ|∃/vecρ.(/vecρ/vecσ∈L (A1))∧len(/vecρ)=k}can be constructed as follows.
TSfxk(/vecx,/vecs,/vecn,/vecs/prime,/vecn/prime)=(¬α∧¬α/prime∧(/vecx=ϵ)∧
∃/vecy.[Tϵ
1(/vecy,/vecs1,/vecn1,/vecs/prime
1,/vecn/prime
1)∧
((/vecy/nequalϵ∧(k/prime=k+1))∨
(/vecy=ϵ∧(k/prime=k)))])∨
(¬α∧α/prime∧(/vecx=ϵ)∧(/vecs1=/vecs/prime
1)∧
(/vecn1=/vecn/prime
1)∧(k/prime=k))∨
(α∧α/prime∧T1(/vecx,/vecs1,/vecn1,/vecs/prime
1,/vecn/prime
1)∧
(k/prime=k)),
ISfxk(/vecs)=¬α∧I1(/vecs1),
OSfxk(/vecs)=α∧O1(/vecs1),
where/vecs=(/vecs1,α)and/vecn=(/vecn1,k).Similartotheconstructionof Pfx
operation,ifthereisanyconstrainton k,itshouldbeinthearith-
meticconstraint Cimposedonthe languageemptinesschecking
for the sink node of the dependency graph.
4.10 Substring
Given an automaton A, the automaton ASubi,k=Sub(A,i,k)for
i≤kthat accepts the language containing the set of substrings
{/vecσ2∈Σ∗|/vecσ1./vecσ2./vecσ3∈L (A),|/vecσ1|=i−1,and|/vecσ2|≤k−i}can be
derived by Sfx(Pfx( A,k−1),i−1).
4.11 Index Tracking
Givenanautomaton A,anon-emptystring /vecσ,andanintegerparam-
etern1, letATrkIdx /vecσ,n1=TrkIdx(A,/vecσ,n1)be an automaton that
accepts the language L(A)∩Σ∗./vecσ.Σ∗with an integer being added
to track the position of the first occurrence of substring /vecσafter
thekthpositionofeachstringacceptedby ATrkIdx /vecσ,n1.Automaton
ATrkIdx /vecσ,n1can be constructed as follows.
We first construct A1=Cat(TrkLen( AΣ∗),A/vecσ), whereAΣ∗and
A/vecσare the automata accepting languages Σ∗and/vecσ, respectively,
andlettheaddedintegerin TrkLen(AΣ∗)ben2.Next,weconstruct
A3=Int(A1,A2),whereA2acceptsthelanguage (∼ (Σ∗./vecσ.Σ∗)).Σ.
This construction ensures that no other /vecσpattern can appear be-
fore this /vecσpattern. We then build A4=Cat(A3,AΣ∗), andA5=
Cat(TrkLen( AΣ∗),A4), where the integer added in TrkLen(AΣ∗)
isn1.Tothisend,weknowthat n1+n2+1istheaskedindex,since
n2counts the number of symbols between the nth
1position and the
head of/vecσ. Finally, we have ATrkIdx /vecσ,x=Int(A,A5).
4.12 Language Emptiness Checking
Given an automaton Aand a length constraint Cover variables
/vecn, the language emptiness checking procedure IsEmp(A,C)ver-
ifies whether L(A)is empty subject to the length constraint C.
Essentially,theprocedureperformsreachabilityanalysisoverthe
629
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Hung-En Wang, Shih-Yu Chen, Fang Yu, and Jie-Hong R. Jiang
following infinite state transition system
TIsEmp(/vecx,/vecs,/vecn,/vecs/prime,/vecn/prime)=T(/vecx,/vecs,/vecn,/vecs/prime,/vecn/prime),
IIsEmp(/vecs,/vecn)=I(/vecs)∧(/vecn=/vec0),
OIsEmp(/vecs,/vecn)=O(/vecs)∧C(/vecn).
We exploit state-of-the-art software model checking algorithms
[21,22] for the computation.
5 COUNTEREXAMPLE GENERATION
WhentheanswertotheIsEmpqueryatthesinknodeofadepen-
dencygraphisnegative,itoftencorrespondstosomeprogramerror
or vulnerability. Tracking the counterexample backward from the
sink node to the input nodes of the dependency graph is crucial to
validate the system property violation with concrete inputs.
Apart from the length encoding, our automata construction
closelyfollows[ 9].Thecounterexamplegenerationprocessisal-
most the same as [ 9], except that there are additional satisfying
assignments to the length variables. Observe that once a length
variable is added to an automaton by operation TrkLen or TrkIdx
in the dependency graph, it will be carried all the way through
tothesinkautomaton.Thistransparencymakescounterexample
generationforthelengthvariablesimmediatefromthesatisfying
solution to the final length constraint.
Takingautomataconcatenationforexample,let ACat=Cat(A1,
A2), and(q1,c1,u1,v1),σ1,(q2,c2,u2,v2),σ2,...,(q/lscript,c/lscript,u/lscript,v/lscript)
be the counterexample run of automaton ACat, whereqi∈[ [ /vecs2]],
ci∈[ [α]],ui∈[ [ /vecn1]],vi∈[ [ /vecn2]],σi∈Σand(/vecs2,α,/vecn1,/vecn2)being
the state variables of ACatas construction in Section 4.4. Then
the counterexample runs of A1andA2can be generated by the
following rule.
A1:(p1
1,σ1,...,p1
i)A2:(p2
i+1,σi+1,...,p2
/lscript)
CatCexACat:(p1,σ1...,pi,σi,pi+1,σi+1,...,p/lscript)
where each pj=(qj,0,uj,vj)for allj≤i,pj=(qj,1,uj,vj)for
allj≥i+1,p1
j=(qj,uj)andp2
j=(qj,vj)for allj, andσi=ϵ.
Similarly,arunofanautomatonbuiltforsomeotheroperationcan
bedecomposedintorunsofitsparentautomataforcounterexample
backtracking.
6 EXPERIMENTAL EVALUATION
The proposed method was implemented as a tool, called Slent,
using IC3ia [ 21] as the backend symbolic model checker for empti-
ness checking on string and integer constraints. To evaluate the
effectivenessofourtool,Slentiscomparedagainststate-of-the-art
mixed string and integer constraint solvers, including ABC [ 8,24],
CVC4 [4], Norn [6], S3P [20], Trau [11], and Z3STR3 [3].2
NotethatsinceSloth[ 25]doesnotsupportlengthconstraint
solving in the current released version, it is excluded from the
comparison.Ontheotherhand,twosetsoftestcaseswereobtained
for evaluation, including those modified from the Kaluza [ 27] and
Stranger[ 28]benchmarks.Theexperimentswereconductedona
Linux machine with Intel 2.8 GHz CPU and 4 GB RAM.
2In the experiments, ABC was downloaded on 30-Jan-2018, CVC4 is version 1.5,
Nornisversion1.0.1,S3Pwasdownloadedon09-Aug-2017,Trauwasdownloaded
on 11-Dec-2017, and Z3 is version 4.6.1 for Z3STR3.Table 1: Solver statistics on Kaluza benchmarks.
solver time (s) #SAT #UNSAT #TO
ABC 255.76 1013 983 4
CVC4 88.89 1017 983 0
Norn 2025.30 1013 983 4
S3P 137.90 1015 983 2
Slent 1397.82 1013 983 4
Trau 123.85 1017 983 0
Z3STR3 56.46 1017 983 0
Thefirstexperimentwasconductedon2000testcasesrandomly
sampledfromtheKaluzabenchmarks,whichinvolvestringconcate-nationoperationsandlengthconstraints.Weexcludedbenchmarks
thatcontainanycyclicdependencyamongstringvariablesasnot
all solvers handle the cyclicity equally. The test cases are modified
andtranslatedtodependencygraphsasinputtoSlent.Weensured
the solvers work on the same set of string and integer constraints.
A timeout limit of 200 seconds was imposed on each test case.
Table1summarizesthe solver performance on the first exper-
iment. Columns “solver,” “time(s),” “#SAT,” “#UNSAT,” and “#TO,”
indicatethesolvername,overallruntime(excludingtimeoutcases),
number of reported SAT instances, number of reported UNSAT in-
stances, and number of timeout instances, respectively. The results
suggest that SMT-based solvers, including CVC4, S3P, and Z3STR3,
outperformothersolvers,includingautomata-basedsolversABC
and Slent, and SMT and automata-mixed solvers Norn and Trau,
ontheKaluzabenchmarks,whichinvolveonlysimplestringma-
nipulations.Slenttimedouton4casesduetotheexpensivereach-
ability analysis on infinite state automata.
The second experiment was conducted on 337 test cases from
the Stranger benchmarks that involve at least one replace-all op-
eration.Thetimeoutlimitissetto600secondsforeachtestcase.
The benchmarks were obtained from real web applications such
as Moodle and Php-Fusion; each case originally corresponds to a
dependencygraphforareportedvulnerabilitybyStranger[ 28],
specifying the flow of string operations on user inputs to a sen-sitive function. Among them, 236 cases involve string-to-string
(but no languageto language) replacement, and 101cases involve
language-to-language replacement. Because the Stranger bench-
marks contain no integer constraints, to evaluate mixed string and
integer constraint solving, we added length constraints of the form
Len(X)+Len(Y)/squarec, where predicate /square∈{=,<,>}, constant
c∈{10,20,30,40,50},Ycorresponds to the sink automaton, and
Xcorrespondstoanodeinthedependencygraphthatundergoes
the largest number of replace-all operations to reach the sink node.
The constraint solving hence involves relations between variables
beforeandafterreplacementoperationsasspecifiedintheprevious
motivatingexample.NoticethattheoriginalwebapplicationsofStranger benchmarks may contain length constraints, but the
lengthconditionsarenotcapturedduetothestringonlycapability
of Stranger. In this case, adding length constraints back couldreflect even more the real constraint complexity. We use the fol-
lowingcodesnippet(takenfromExample1of[ 29])tojustifythe
practicality of our manually created length constraints.
var y = goog.string.escapeString(x);
630
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. A Symbolic Model Checking Approach to the Analysis of ... ASE ’18, September 3–7, 2018, Montpellier, France
Table 2: Solver statistics on Stranger benchmarks with
string-to-string replacement.
solver time(s) #SAT #UNSAT #TO #abort
ABC 2282.84 109(31) 111(0) 0 16
S3P 605.79 30(0) 114(3) 22 70
Slent26692.55 88(0) 141(0) 7 0
Trau 687.49 54(2) 139(22) 5 38
Table 3: Solver statistics on Stranger benchmarks with
language-to-language replacement.
solvertime (s) #SAT #UNSAT #TO #abort
ABC977.80 46(2) 41(0) 1 13
Slent4413.25 44(0) 38(0) 19 0
catElem.innerHTML = '<button onclick= "createCatList(\''
+y+'\' ) " > '+x+'</button>';
wherecatElem.innerHTML istheconcatenationofsomeconstants
withtwostringvariables xandythathaveareplacerelation.To
restrict the size of the hyperlink, the length constraint in the form
len(x)+len(y)<c(as we created in experiments) needs to be
enforced besides string constraints. In practice, it is common to
restrict the size of output string variables in web applications.
For the 236 cases involving string-to-string, but no language-to-
language, replace-all operations, we compare Slent against other
solvers, including ABC, S3P and Trau, capable of solving such
constraints. Equivalent constraint formulas in the SMT format are
generatedfromdependencygraphsastestcases forthesesolvers.
As noted in Section 2, there is a difference of the replace-all opera-
tiondefinitionamongthesolvers.BothS3PandTraufollowthe
replace-all-first definition, whereas both ABC and Slent follow
thereplace-all-anydefinition.Thedifferenceoccurswhenthere-
placement candidates overlap. Taking the string “ aaa" for example,
supposethepattern“ aa"istobereplacedwith“ b”.Therearetwo
replacement candidates, underlined in “ aaa" and “aaa," which over-
lap in the second position. As a result, S3P and Trau produce “ ba"
asasolution,whereasABCandSlentproduce“ ba"and“ab”asa
solution.Nevertheless,intheStrangerbenchmarks,allthepat-
terns to be replaced are of the form, such as “ http://" and “.gif,"
thatexcludesoverlappedreplacementcandidates.Undersuchcir-
cumstances, all the solvers should have the same interpretationof the replace-all operation. Therefore the experiment is fair for
comparison.
Table2showsthestatisticsofsolverperformanceonthecases
involving string-to-string replace-all operation and length con-
straints.Thenumbersoffalsealarmsofeachsolverareshownin
theparenthesesintheentriesofColumns“#SAT”and“#UNSAT.”
Theinconsistentanswersamongthesolverswerecarefullyexam-
ined and verified. Solvers ABC, S3P, and Trau aborted on 16, 70,
and38 cases,produced 31,0,and 2false positivesamongthe SAT
cases, and produced 0, 3, and 22 false negatives among the UNSAT
cases,respectively.Incontrast,Slenttooklongertime,butman-
agedtosolvemoreinstancesthantheothersolversandraisedno
falsealarms.TheexperimentalresultssuggestthatSlentisreliableandrobustinsolvingcomplexmixedstringandintegerconstraints.For the 101 cases involving language-to-language replace-all op-
erations,wecompareSlentandABC,theonlytwosolverscapable
ofsolvingsuchconstraints.Table 3showstheresultsoncasesin-
volving language-to-language replacement with length constraints.
Slent managed tosolve 82out of101 instances withoutany false
alarms, whereas ABC aborted on 13 cases and produced 2 false
positives. Among the 19 timeout cases, Slent was able to solve 10
of them under an extended time limit of 1800 seconds. The experi-
mental results reconfirm the reliability and robustness of Slent in
solving complex mixed string and integer constraints.
7 RELATED WORK
String analysis has been studied extensively in recent years dueto itsimportance to detect string manipulationerrorsin modern
software, such as SQL/XSS vulnerabilities in web applications. We
review prior work that supports mixed string constraint solving
with length constraints involved.
There have been significant efforts on developing inference-rule
basedsolvers,suchasNorn[ 6,7],CVC4[4,5],Z3str3[ 3],andS3P
[20]. These SMT-based solvers use predefined inference rules and
search on the derivation tree for a solution. CVC4 [ 4,5]i sa nS M T
solverthatsupportssolvingconstraintswithdifferenttheories.It
is equipped with derivation rules that combine both string and
integers to facilitate the ability of solving mixed string constraints.
Norn[6,7]solvesmixedstringconstraintsbyfirstbranchingsearch
in the derivation tree, and then solving related integer constraints
beforeguessingstringsolutionsforeachbranch.Z3str3[ 3],the
successor of Z3str[ 23]and Z3str2[ 30], solvesmixed stringcon-
straints by leveraging interactions of different theory solvers in Z3
witheffectiveheuristics.Onerestrictionoftheaboveinference-rule
based solvers is to reason theories of complex string manipula-
tions such as the operation of replace-all. Among these rule-based
solvers,Z3str3andCVC4supportonlythereplacementofthefirstoccurrence.Norndoesnotsupportreplacement.S3P,thesuccessor
of S3 [2], is currently the only one that supports all string replace-
ment with recurrence of string operations. It utilizes evaluation on
node solution size in the derivation tree to find a minimal solution
for a satisfiable formula, which avoids unnecessary derivations on
branches. A recent work [ 31] targets on extending existing rule-
basedsolverstosupportmorecomplicatedstringconstraintsand
avoidsthedifficultiesinmodifyingthesearchstrategytocopewith
new rules. The proposed search-driven method first constructsautomata to restrict solution space of each variable by applying
automata-basedsolversonpartofthesupportedconstraints,then
searches for complete solutions with ant-colony optimization.
Different from rule based solvers, automata-based string con-
straintsolversuseautomatatocharacterizepossiblesolutionsof
a string constraint. String operations that can be handled with au-
tomata constructions, such as replace-all [ 17], can be natively han-
dledbyautomata-basedstringconstraintsolvers.However,using
finite-stateautomata,thesolverssufferfromapproximation/inex-
actnessinageneralsetting.Sincethesolutionsetofasetofcon-
straints may not be a regular language, under/over approximations
have tobe appliedto havethe solution setrepresented withfinite
automata. In the tool ABC [ 8,24], finite-state automata are con-
structed to characterize the solution set of each string variable and
631
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Hung-En Wang, Shih-Yu Chen, Fang Yu, and Jie-Hong R. Jiang
aniterativerefineprocessisappliedtostrengthenapproximation.
In the recent update of ABC [ 24], multi-track automata are used to
model relations among string variables. In contrast, we overcome
the limitation of automata-based string constraint solving using
infinite state automata. Essentially, we encode (unbounded) length
within string automata, and leverage symbolic model checking
techniques to resolve emptiness checking of these infinite-state
automata. Our method can precisely represent a large variety of
constraintsetsusinglength-encodedautomata.Forexample,the
context sensitive language {anbmcndm}can be represented under
our framework.
In the work [ 11], a new tool Trau is introduced, which is based
on a counter-example guided abstract refinement (CEGAR) frame-
work,andusingflatautomataforconstraintrefinement.Theframe-
workalternatesbetweensolvingunder-andover-approximation
of constraints, which are refined during the process in order tofind a non-spurious solution. Since the framework adopts underand over approximations, a wide variety of constraint set can be
supportedincludingtransducersandconstraintsaboutmembership
in context-free grammar.
In recent work [ 25], the tool Sloth solves string constraints
by constructing alternating finite automata (AFA) and introduce
synchronizeparameterstosplitautomatathroughconcatenation.
Comparedtotheirwork,ourlength-encodedautomataprecisely
representtheconstraintsetbeyondregularapproximationswith
lengthinformationbeingwellkeptintheautomatastructure.For
example,a simple instancethat is solvableby Slent but notSloth
isX2=replace(X1,R1,R2)∧Len(X2)+Len(X1)=10 for some
regular expressions R1andR2.
We note that the supported string logic fragments of [ 29] and
Slent are incomparable. That is, no one strictly contains the other.
For example, our method supp orts the reverse operation, which is
clearlynot arationalrelation andhasnotbe discussedin[ 25,29].
Moreover,beyondthe SLeclassof[29],weallowastringvariableto
appearonthelefthandsidesofstringequationsmultipletimes.On
theotherhand,welimitastringvariabletoappearontherighthand
sides of string equations at most once. Although characterizing the
string logic fragment that Slent corresponds to is out of the main
focus of this paper, it is an interesting question we planned to
address in the future.
There are different ways to count string lengths, e.g., in [ 29]
an explicit counter is used for proving complexity arguments. In
this work,we implicitly represent a counter byembeddingit into a
transition relation, and utilize it for formula construction targeting
practical applications.
For the replace-all operation, we adopt the notion in [ 17]. While
[32] and [17] are similar in using markers for constructions, the
replace-all definitions are different. Unlike the ones defined in [ 32]
requiring each match to be leftmost, the one in [ 17] does not have
the restriction.
In[33],emptinesscheckingofintersectionsoffiniteautomatais
considered. However, it does not support string operations.8 CONCLUSIONS
Wepresentanoveltechniquebasedonlength-encodedautomata
for solving string and integer constraints. Our solver Slent is par-
ticularlysuitableforsolvingcomplexstringandintegerconstraints.
As Slent precisely maintains the relation among string and length
variables,noapproximationisrequiredforconstraintsolvingun-
likeotherexistingautomata-basedmethods.Theexperimentshows
theuniquebenefitoftheproposedmethodonsolvingconstraints
withreplace-alloperationoverstringvariablesandwithcomplex
length relation. As Slent relies on off-the-shelf model checkers, it
benefitsfrommodelcheckeradvancements.Itsperformanceand
practicalitymaybeimprovedovertime.Forfuturework,weplan
to extend the proposed method to solve more complex constraints
involving cyclic dependencies among string variables.
ACKNOWLEDGMENTS
The authors are grateful to William Eiers for helping the experi-
mentswithABCoftheUniversityofCalifornia,SantaBarbara.This
workwassupportedinpartbytheMinistryofScienceandTechnol-
ogy ofTaiwan undergrants 104-2628-E-002-013-MY3,105-2221-E-
002-196-MY3, 105-2923-E-002-016-MY3, 106-2912-E-002-002-MY3,
and MOST 107-2221-E-004-002-MY2.
REFERENCES
[1]OWASP top 10 project. https://www.owasp.org/index.php/Top_10-2017_Top_10
(2017)
[2]Trinh, M.T., Chu, D.H., Jaffar, J.: S3: A symbolic string solver for vulnerability
detection in web applications. In: Proc. ACM SIGSAC Conference on Computer
and Communications Security. (2014) 1232–1243
[3]Berzish, M., Zheng, Y., Ganesh, V.: Z3str3: A string solver with theory-aware
branching. Computing Research Repository abs/1704.07935 (2017)
[4]Barrett, C., Conway, C.L., Deters, M., Hadarean, L., Jovanović, D., King, T.,
Reynolds, A., Tinelli, C.: CVC4. In: Proc. International Conference on Com-
puter Aided Verification (CAV). (2011) 171–177
[5]Liang,T.,Reynolds,A.,Tinelli,C.,Barrett,C.,Deters,M.: ADPLL(t)theorysolverforatheoryofstringsandregularexpressions. In:Proc.InternationalConference
on Computer Aided Verification (CAV). (2014) 646–662
[6]Abdulla, P.A., Atig, M.F., Chen, Y., Holík, L., Rezine, A., Rümmer, P., Stenman,
J.: String constraints for verification. In: Proc. International Conference on
Computer Aided Verification (CAV). (2014) 150–166
[7]Abdulla, P.A., Atig, M.F., Chen, Y., Holík, L., Rezine, A., Rümmer, P., Stenman, J.:
Norn:AnSMTsolverforstringconstraints. In:Proc.InternationalConference
on Computer Aided Verification (CAV). (2015) 462–469
[8]Aydin,A.,Bang,L.,Bultan,T.: Automata-basedmodelcountingforstringcon-
straints. In: Proc. International Conference on Computer Aided Verification
(CAV). (2015) 255–272
[9]Wang,H.E.,Tsai,T.L.,Lin,C.H.,Yu,F.,Jiang,J.H.R.: Stringanalysisviaautomata
manipulationwithlogiccircuitrepresentation. In:Proc.InternationalConference
on Computer Aided Verification (CAV). (2016) 241–260
[10] Slent: https://github.com/NTU-ALComLab/SLENT
[11]Abdulla, P.A., Atig, M.F., Chen, Y.F., Diep, B.P., Holík, L., Rezine, A., Rümmer,
P.: Flatten and conquer: A framework for efficient analysis of string constraints.
In: Proc. ACM SIGPLAN Conference on Programming Language Design and
Implementation (PLDI). (2017) 602–617
[12]Chen, T., Chen, Y., Hague, M., Lin, A.W., Wu, Z.: What is decidable about string
constraints with the replaceall function. Proc. ACM on Programming Language
2(POPL) (2018) 3:1–3:29
[13]Bultan,T.,Yu,F.,Alkhalaf,M.,Aydin,A.: StringAnalysisforSoftwareVerification
and Security. Springer (2018)
[14]Bjørner, N., Tillmann, N., Voronkov, A.: Path feasibility analysis for string-
manipulating programs. In Kowalewski, S., Philippou, A., eds.: Proc. Interna-
tional Conference on Tools and Algorithms for the Construction and Analysis of
Systems (TACAS). (2009) 307–321
[15]Minamide, Y.: Static approximation of dynamically generated web pages. In:
Proc. International World Wide Web Conference (WWW). (2005) 432–441
[16]Veanes,M.,Hooimeijer,P.,Livshits,B.,Molnar,D.,Bjorner,N.: Symbolicfinite
state transducers: Algorithms and applications. In: Proceedings of the 39th
632
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. A Symbolic Model Checking Approach to the Analysis of ... ASE ’18, September 3–7, 2018, Montpellier, France
Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming
Languages. POPL ’12, New York, NY, USA, ACM (2012) 137–150
[17]Yu, F., Alkhalaf, M., Bultan, T., Ibarra, O.H.: Automata-based symbolic string
analysis for vulnerability detection. Formal Methods in System Design 44(1)
(2014) 44–70
[18]Yu, F., Bultan, T., Ibarra, O.H.: Relational string verification using multi-track
automata. InternationalJournalofFoundationsofComputerScience 22(8)(2011)
1909–1924
[19]Yu, F., Bultan, T., Ibarra, O.H.: Symbolic string verification: Combining string
analysis and size analysis. In: Proc. International Conference on Tools and
Algorithms for the Construction andAnalysis of Systems (TACAS). (2009) 322–
336
[20]Trinh, M.T., Chu, D.H., Jaffar, J.: Progressive reasoning over recursively-defined
strings. In:Proc.InternationalConferenceonComputerAidedVerification(CAV).
(2016) 218–240
[21]Cimatti,A., Griggio,A.,Mover,S.,Tonetta, S.: IC3modulotheories viaimplicit
predicateabstraction. In:Proc.InternationalConferenceonToolsandAlgorithms
for the Construction and Analysis of Systems (TACAS). (2014) 46–61
[22]Hoder, K., Bjørner, N.: Generalized property directed reachability. In: Proc.
InternationalConferenceTheoryandApplicationsofSatisfiabilityTesting(SAT).
(2012) 157–171
[23]Zheng,Y.,Zhang,X.,Ganesh,V.: Z3-str:az3-basedstringsolverforwebappli-
cationanalysis. In:Proc.JointMeetingoftheEuropeanSoftwareEngineering
Conference and the ACM SIGSOFT Symposium on the Foundations of Software
Engineering (ESEC/FSE). (2013) 114–124
[24]Aydin, A., Bang, L., Eiers, W., Brennan, T., Gavrilov, M., Bultan, T., Yu, F.: Param-
eterized model counting for string and numeric constraints. Technical report,
University of California, Santa Barbara (2016)[25]Holík, L., Janku, P., Lin, A.W., Rümmer, P., Vojnar, T.: String constraints with
concatenation and transducers solved efficiently. In: Proc. ACM Symposium on
Programming Language 2(POPL) (2018) 4:1–4:32
[26]Jiang,J.H.R.,Brayton,R.K.:Ontheverificationofsequentialequivalence.IEEE
Trans. on Comp.-Aid Des. of Int. Cir. and Sys. 22(6), 686–697 (2003)
[27]Saxena, P., Akhawe, D., Hanna, S., Mao, F., McCamant, S., Song, D.: A symbolic
execution framework for javascript. In: Proc. IEEE Symposium on Security and
Privacy (S&P) . (2010) 513–528
[28]Yu, F., Alkhalaf, M., Bultan, T.: Stranger: An automata-based string analysis tool
for PHP. In: Proc. International Conference on Tools and Algorithms for the
Construction and Analysis of Systems (TACAS). (2010) 154–157
[29]Lin, A.W., Barceló, P.: String solving with word equations and transducers:
Towards a logic for analysing mutation XSS. In: Proc. ACM Symposium on
Programming Language (POPL). (2016) 123–136
[30]Zheng, Y., Ganesh, V., Subramanian, S., Tripp, O., Dolby, J., Zhang, X.: Effec-
tive search-space pruning for solvers of string equations, regular expressions
andlengthconstraints. In:Proc.InternationalConferenceonComputerAided
Verification (CAV). (2015) 235–254
[31]Thomé, J., Shar, L.K., Bianculli, D., Briand, L.C.: Search-driven string constraint
solvingforvulnerabilitydetection.In:Proc.InternationalConferenceonSoftware
Engineering (ICSE). (2017) 198–208
[32]Fu,X.,Li,C.C.: Modelingregularreplacementforstringconstraintsolving. In:
Proc. NASA Formal Methods (NFM). (2010) 67–76
[33]Gange,G.,Navas,J.A.,Stuckey,P.J.,Søndergaard,H.,Schachte,P.: Unbounded
model-checking with interpolation for regular language constraints. In: Proc.
International Conference on Tools and Algorithms for the Construction and
Analysis of Systems (TACAS). (2013) 277–291
633
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. 