Automatically Computing Path Complexity of Programs
Lucas Bang, Abdulbaki Aydin, and Tevï¬k Bultan
Department of Computer Science, University of California, Santa Barbara, CA 93106, USA
{bang,baki,bultan}@cs.ucsb.edu
ABSTRACT
Recent automated software testing techniques concentrate
on achieving path coverage. We present a complexity mea-
sure that provides an upper bound for the number of paths
in a program, and hence, can be used for assessing the dif-
culty of achieving path coverage for a given method. We
dene the path complexity of a program as a function that
takes a depth bound as input and returns the number of
paths in the control ow graph that are within that bound.
We show how to automatically compute the path complexity
function in closed form, and the asymptotic path complexity
which identies the dominant term in the path complexity
function. Our results demonstrate that path complexity can
be computed eciently, and it is a better complexity mea-
sure for path coverage compared to cyclomatic complexity
and NPATH complexity.
Categories and Subject Descriptors
D2.8 [ Metrics ]: Complexity Measures
General Terms
Algorithms, measurement.
Keywords
Path complexity, path coverage, automated testing.
This material is based on research sponsored by NSF un-
der grant CCF-1423623 and by DARPA under agreement
number FA8750-15-2-0087. The U.S. Government is autho-
rized to reproduce and distribute reprints for Governmental
purposes notwithstanding any copyright notation thereon.
The views and conclusions contained herein are those of the
authors and should not be interpreted as necessarily repre-
senting the ocial policies or endorsements, either expressed
or implied, of DARPA or the U.S. Government. Part of this
research was conducted while Tevk Bultan was visiting Ko c
University in _Istanbul, Turkey, supported by a research fel-
lowship from T UB_ITAK under the B _IDEB 2221 program.1. INTRODUCTION
Automated testing, i.e., automated generation of test cases,
has become a very active area of research. Part of the surge
in research activity in this area stems from the fact that, in
the last two decades, automated verication research has
mainly focused on bug nding techniques which resulted
in merging of automated verication and automated test-
ing research areas. Exhaustive exploration techniques such
as model checking [15, 35], static analysis techniques such
as extended static checking [13], and symbolic reasoning
techniques such as symbolic execution [24] combined with
advanced decision procedures [2, 8] have been eectively
adopted to automated testing [16, 31, 5, 6, 7, 30].
This blurring of the lines between automated verication
and testing resulted in new techniques that focus on path
coverage rather than more traditional testing criteria such
asstatement coverage ,branch coverage , and MC/DC cover-
age. Path coverage demands that all paths in the program
are explored during testing. This is not always possible since
some program paths may not be feasible. Moreover, in the
presence of loops and unbounded recursion, the number of
program paths may not be bounded. So, rather than tar-
geting full path coverage, many modern automated software
testing techniques try to cover paths up to a certain exe-
cution depth (where the execution depth can be increased
iteratively with iterative deepening) [30].
In this paper, we show how to compute the path com-
plexity of a program which provides an upper bound for the
number of execution paths in a program with respect to the
execution depth. As such, path complexity can be used to
assess the diculty of achieving path coverage with respect
to increasing depth. Path complexity focuses only on the
control ow structure and cannot determine the diculty of
nding input values that can exercise a certain branch con-
dition. However, due to this abstraction, path complexity
can be computed eciently as we demonstrate in this paper.
Path complexity of a program with an acyclic control ow
graph (i.e., no loops or recursion) is simply the number of
paths in that control ow graph. In the presence of cyclic
control ow graphs, path complexity of a program is a func-
tion that takes a single number nas input, which corre-
sponds to the execution depth, and evaluation of the path
complexity function gives the number of paths of the pro-
gram within that depth. In this paper, we show how to
compute the path complexity function using graph theoretic
techniques. Note that path complexity function could be a
complicated function with many terms and constants. We
also dene and show how to compute the asymptotic path
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proï¬t or commercial advantage and that copies bear this notice and the full citation
on the ï¬rst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciï¬c permission and/or a
fee. Request permissions from Permissions@acm.org.
ESEC/FSEâ€™15 , August 30 â€“ September 4, 2015, Bergamo, Italy
c2015 ACM. 978-1-4503-3675-8/15/08...$15.00
http://dx.doi.org/10.1145/2786805.2786863
61complexity which corresponds to the most signicant term in
the path complexity function. Using asymptotic path com-
plexity, we can classify programs as programs with constant,
polynomial, or exponential path complexity, and identify the
degree of the polynomial for programs with polynomial path
complexity and the base of the exponent for programs with
exponential path complexity.
Based on the techniques we present in this paper, we im-
plemented a tool for computing path complexity and asymp-
totic path complexity of Java methods. We rst extract the
control ow graph of each method from the Java bytecode
and then compute the path complexity and the asymptotic
path complexity on the control ow graph. Our current im-
plementation is intra-procedural where method calls are rep-
resented as single edges in the control ow graph, and during
path complexity analysis, the execution paths in the callee
method's body are not investigated. Our approach can be
extended to inter-procedural path complexity analysis by
combining control ow graphs of individual methods with
a procedure call graph. However, such an extension would
generate an over-approximation since it would also count
spurious paths where call and return sites do not match. A
context sensitive extension to path complexity analysis that
matches calls and returns would result in a more precise
inter-procedural analysis and would be a valuable extension
to the techniques we present in this paper.
Related Work.
There have been earlier eorts in assessing the diculty
of testing a program by analyzing the the control ow graph
(CFG) of the program. For example, cyclomatic complex-
itydetermines the number of linearly independent paths in
a given program by analyzing the CFG of the given pro-
gram [27, 21]. One testing strategy, called basis point test-
ing, is to exercise all such paths during testing. The upper
bound for number of test cases required for basis point test-
ing is given by the cyclomatic complexity. Moreover, it can
be shown that cyclomatic complexity also provides an up-
per bound for the minimum number of test cases required
for branch coverage and statement coverage. However, cy-
clomatic complexity does not consider the paths that are
subsumed by the other paths (i.e., if all the nodes in a path
is subsumed by the other paths, it is not considered).
Another complexity metric, called NPATH complexity , de-
termines the number of paths in a program (which may be
subsumed by each other) by restricting each loop execution
to one or zero executions [29, 28]. NPATH complexity can
increase exponentially with the length of the program and
can result in very large numbers. Neither cyclomatic nor
NPATH complexity are adequate measures for assessing dif-
culty of path coverage of a program since cyclomatic com-
plexity does not consider paths that are subsumed by other
paths and the NPATH complexity does not consider multi-
ple executions of loops.
In this paper, we are focusing on use of complexity met-
rics for assessing the diculty of testing a program. There
has been research on use of complexity metrics for assessing
other properties of programs, such as maintenance costs [22,
14] and number of errors [23]. We have not investigated use
of path complexity for such purposes but believe that these
are interesting future research directions.
There has been recent work on automated worst-case com-
plexity analysis [17, 18, 20, 19]. The main idea is to rstinstrument the loops in a program with auxiliary counters
that keep track of how many times a loop is executed. Then,
using invariant generation techniques, one infers invariants
that relate the values of these counters to the inputs of the
program. In eect, these discovered invariants provide the
complexity bound for the program since they demonstrate
how many times loops of a program are executed for a given
input value. Note that this is signicantly dierent than the
path complexity we investigate in this paper. In worst-case
complexity analysis the goal is to discover a relationship
between the input size and the length of execution paths,
whereas in path complexity analysis, the goal is to discover
a relationship between the execution depth and the number
of execution paths. Moreover, the path complexity anal-
ysis we present in this paper is a purely structural analy-
sis which ignores branch conditions, whereas the worst-case
complexity analysis discussed in [17, 18, 20, 19] requires so-
phisticated constraint analysis for invariant generation. Suc-
cess of this approach depends on the quality of the invariant
generation which is a dicult problem. For example, the
abstract interpretation based approach described in [20] is
semi-automated and requires user guidance during invariant
discovery process. In contrast, the path complexity anal-
ysis we present in this paper is fully automated, and it is
scalable.
The techniques we present in this paper for computing
path complexity of a program are based on algebraic graph
theory and analytic combinatorics techniques for counting
the number of paths in graphs [3, 32, 12]. In particular, we
use the transfer-matrix method based on generating func-
tions [32, 12]. Recently, generating functions have also been
used in model counting constraint solvers for determining
the number of solutions to a given string constraint [26, 1].
There has been some earlier work on path complexity of
programs [9]. However, the path complexity concept dis-
cussed in this earlier work denes the path complexity as
a relation between the input size and the number of exe-
cution paths rather than a relation between the execution
depth and the number of execution paths as we dene in
this paper. Furthermore, this earlier work does not present
an automated way of computing the path complexity.
The remainder of the paper is organized as follows. In Sec-
tion 2 we briey discuss and contrast cyclomatic, NPATH,
path and asymptotic path complexity. In Section 3 we present
the techniques for automatically computing path complex-
ity. In Section 4 we compare cyclomatic, NPATH, and asymp-
totic path complexity on several CFG patterns. We discuss
our implementation and experiments in Section 5 and pro-
vide our conclusions in Section 6.
2. OVERVIEW
In this section we use three example methods (shown
in Figure 1) from Java SDK to explain the following con-
cepts and their dierences: cyclomatic complexity intro-
duced in [27], NPATH complexity introduced in [29], and
the path complexity and asymptotic path complexity intro-
duced in this paper. In order to present all these concepts
in a uniform manner we use the control ow graph (CFG)
representation, i.e., given a program, we rst extract a CFG
from the program and then we compute these complexity
measures on the CFG. A CFG consists of a set of nodes
that correspond to basic blocks of the program. Nodes of
62private static void rangeCheck(int length, int fromIndex,
int toIndex) {
if (fromIndex > toIndex) {
throw new IllegalArgumentException(
"fromIndex(" + fromIndex + ") > toIndex(" + toIndex + ")");
}
if (fromIndex < 0) {
throw new ArrayIndexOutOfBoundsException(fromIndex);
}
if (toIndex > length) {
throw new ArrayIndexOutOfBoundsException(toIndex);
}
}
(a) java.util.Arrays.rangeCheck()
public Matcher reset() {
first = -1;
last = 0;
oldLast = -1;
for(int i=0; i<groups.length; i++)
groups[i] = -1;
for(int i=0; i<locals.length; i++)
locals[i] = -1;
lastAppendPosition = 0;
from = 0;
to = getTextLength();
return this;
}
(b) java.util.regex.Matcher.reset()
private static int binarySearch0(long[] a,
int fromIndex, int toIndex, long key) {
int low = fromIndex;
int high = toIndex - 1;
while (low <= high) {
int mid = (low + high) >>> 1;
long midVal = a[mid];
if (midVal < key)
low = mid + 1;
else if (midVal > key)
high = mid - 1;
else
return mid; // key found
}
return -(low + 1); // key not found.
}
(c)java.util.Arrays.binarySearch0()
Figure 1: Three example methods from Java SDK.
the CFG are connected with edges that correspond to con-
trol ow of the program (i.e., if there is an edge from node
1 to node 2, then, in some program execution, basic block
that corresponds to node 2 can be executed immediately af-
ter the basic block that corresponds to node 1). We assume
that each CFG has a unique entry node denoting the pro-
gram point where the execution starts, and a single exit node
denoting the program point where the execution terminates
(it is easy to convert CFGs that have multiple termination
points to this form by adding an extra node). Figures 2(a),
(b), and (c) show the CFGs for the methods shown in Fig-
ures 1(a), (b), and (c), respectively.
Cyclomatic Complexity.
Given a CFG, cyclomatic complexity computes the maxi-
mum number of linearly independent paths in the CFG from
the entry node to the exit node [27]. A set of paths through
a program are linearly independent if and only if each path
in the set contains at least one edge that is not included in
any other path in the set.For example, the method shown in Figure 1(a), with the
CFG shown in Figure 2(a), has at most 4 linearly inde-
pendent paths:hS;1;2;Ti,hS;1;3;4;6;Ti,hS;1;3;4;7;Ti,
hS;1;3;5;Tiwhere we identify each path by the sequence of
nodes visited during the execution of the path, and we use
Sto denote the entry point where the execution starts and
Tto denote the exit point where the execution terminates.
Since the maximum number of linearly independent paths
for the method shown in Figure 1(a) is 4, the cyclomatic
complexity of this method is 4.
On the other hand, the method shown in Figure 1(b),
with the CFG shown in Figure 2(b), has at most 3 linearly
independent paths: hS;1;2;4;5;7;Ti,hS;1;2;3;2;4;5;7;Ti,
hS;1;2;3;4;5;6;5;7;Ti, hence its cyclomatic complexity is
3. Note that, we can replace the last path in the set above
with the pathhS;1;2;3;2;3;4;5;6;5;7;Tiand the resulting
set of three paths will still be linearly independent. However,
we cannot have both hS;1;2;3;4;5;6;5;7;Tiand
hS;1;2;3;2;3;4;5;6;5;7;Tiin the set of linearly indepen-
dent paths since these two paths are not linearly indepen-
dent.
Finally, the method shown in Figure 1(c), with CFG shown
in Figure 2(c), has at most 4 linearly independent paths:
hS;1;2;3;Ti,hS;1;2;4;6;8;Ti,hS;1;2;4;6;9;7;2;3;Ti, and
hS;1;2;4;5;7;2;3;Ti. We can nd other sets of linearly in-
dependent paths for this method, but the cardinality of the
set of linearly independent paths can never be more than 4.
For this CFG, after 4 linearly independent paths, any other
path we add will not include any new nodes and, therefore,
will not be linearly independent.
Cyclomatic complexity can be computed easily from a
CFG by rst counting the number of edges (E), the num-
ber of nodes (N), and the number of connected components
(P) in the CFG. Then, the cyclomatic complexity is given
by the expression E N+ 2P. For example, for the CFG
shown in Figure 2(a) we have: E= 11,N= 9,P= 1,
and the cyclomatic complexity is 11  9 + 21 = 4. On
the other hand, for the CFG shown in Figure 2(b) we have:
E= 10,N= 9,P= 1, and the cyclomatic complexity is
10 9 + 21 = 3, and for the CFG shown in Figure 2(c)
we have:E= 13,N= 11,P= 1, and the cyclomatic
complexity is 13 11 + 21 = 4.
Cyclomatic complexity can be used for estimating the cost
of testing since it provides an upper bound for the minimum
number of test cases required for branch coverage. Hence, as
the cyclomatic complexity of a program increases, the cost
of achieving branch coverage for that program is likely to
increase. However, cyclomatic complexity is not very use-
ful for assessing diculty of achieving path coverage. For
example, the methods shown in Figure 1(b) and (c) con-
tain loops, hence, achieving path coverage during testing for
these methods will be dicult. However, cyclomatic com-
plexity of the method shown in Figure 1(b) is lower than the
cyclomatic complexity of the method shown in Figure 1(a),
and the cyclomatic complexity of the method shown in Fig-
ure 1(a) is same as the cyclomatic complexity of the method
shown in Figure 1(b). Hence, if we are targeting path cov-
erage, cyclomatic complexity is not a useful measure. Even
without a coverage criteria in mind, if we accept the fact
that testing programs with loops is harder than testing pro-
grams without loops, cyclomatic complexity is not a useful
metric for determining diculty of testing since it does not
distinguish between the back and forward edges in CFGs
63START
1
EXIT2 3
4 5
6 7(a) CFG for
java.util.Arrays.rangeCheck()
START
1
EXIT2
3 4
5
6 7(b) CFG for
java.util.regex.Matcher.reset()
START
1
EXIT2
3 4
5 6
78 9(c) CFG for
java.util.Arrays.binarySearch0()
Figure 2: Control Flow Graphs (CFGs) for the the three methods in Figure 1.
and, therefore, it is ambivalent to existence of loops in the
CFG.
Another reason for the inadequacy of cyclomatic complex-
ity as a metric for diculty of achieving path coverage is the
fact that cyclomatic complexity grows at most linearly with
the number of edges in the CFG. However, the number of
paths in a CFG can grow exponentially even without loops.
For example, consider the CFG of a program that consists
ofKif-then-else statements executed back to back. The
cyclomatic complexity of such a CFG structure would grow
linearly with respect to K, whereas the number of paths in
the CFG would grow exponentially, i.e., would be propor-
tional to 2K.
NPATH complexity.
NPATH complexity overcomes this short-coming of cyclo-
matic complexity by counting all acyclic paths in the CFG
without requiring them to be linearly independent [29]. For
example, the NPATH complexity of the method shown in
Figure 1(a), with the CFG shown in Figure 2(a), is 4, which
simply is the number of paths in the CFG. Since NPATH
complexity focuses on counting the number of paths in the
CFG, it is more suitable for assessing the diculty of achiev-
ing path coverage than cyclomatic complexity. However,
for CFGs with loops, NPATH complexity also makes a sim-
plifying assumption which makes it unsuitable for assess-
ing the diculty of achieving path coverage. In the pres-
ence of loops, NPATH complexity only counts the paths
that execute the loop body once or zero times. For ex-
ample, there are two loops in the method shown in Fig-
ure 1(b) with the CFG shown in Figure 2(b). NPATH
complexity counts the path that executes each loop zero
times (hS;1;2;4;5;7;Ti), it counts the two paths that ex-
ecute one loop one times and the other loop zero times
(hS;1;2;3;2;4;5;7;Ti,hS;1;2;3;2;4;5;6;5;7;Ti), and itcounts the path that executes each loop one time
(hS;1;2;3;2;4;5;6;5;7;Ti), resulting in 4 paths. So the
NPATH complexity of the method shown in Figure 1(c) is
4.
The method shown in Figure 1(c), with the CFG shown
in Figure 2(c), has a single loop that contains conditional
statements in the loop body (unlike the loops in the CFG
shown in Figure 2(b) which do not contain conditional state-
ments in the loop body). For the CFG shown in Figure 2(c),
the NPATH complexity takes into account the path that
executes the loop body zero times ( hS;1;2;3;Ti) the path
that executes the loop body once and takes the rst then-
branch (hS;1;2;4;5;7;2;3;Ti), the loop that executes the
loop body once and takes the rst else-branch and the sec-
ond then-branch ( hS;1;2;4;6;9;7;2;3;Ti), and, the loop
that executes the loop body once and takes the both else-
branches (hS;1;2;4;6;8;Ti). So, the NPATH complexity of
the method shown in Figure 1(c) is also 4.
NPATH complexity was originally dened through oper-
ations that are applied directly to structured programming
code [29]. However, we observe that NPATH complexity
can be restated in terms of the CFG in the following way:
NPATH is the number of paths in the CFG that use any edge
at most once. Thus, for any node u, the number of paths
fromuto the exit node is given by the recursive denition
NPATH (u;G) =X
euv2GNPATH (v;G euv) (1)
whereeuvis an edge from utovandG euvis the graph
obtained by deleting euvfromG. Thus, we can compute
NPATH (START;G ) using dynamic programming
techniques and applying the initial condition
NPATH (EXIT;) = 1.
Since NPATH complexity only considers execution of each
loop body once or zero times, it is not able to distinguish
64Table 1: Results of dierent complexity measures.
MethodCyclomatic
ComplexityNPATH
ComplexityPath
ComplexityAsymptotic
Complexity
java.util.Arrays.rangeCheck()
Figure 1 (a)4 4 4 (1)
java.util.regex.Matcher.reset()
Figure 1 (b)3 4 0:12n2+ 1:25n+ 3 (n2)
java.util.Arrays.binarySearch0()
Figure 1 (c)4 4 6:861:17n+ 0:221:1n+ 0:130:84n+ 2 (1:17n)
between loops that create a large number of paths from the
loops that do not create a large number of paths. More-
over, since NPATH complexity produces a single constant
number, it is not possible the distinguish CFGs that have
a constant number of paths from the ones that have an un-
bounded number of paths (i.e., the ones with loops). For
example, the NPATH complexities of the methods in Fig-
ure 1(a), (b) and (c) are all the same although two of them
contain loops and one of them does not contain a loop.
Path Complexity.
Path complexity is equal to the NPATH complexity for
the programs that do not contain loops or recursion, i.e., for
the programs with a constant number of paths, path com-
plexity just returns the number of paths. However, for the
programs with loops or recursion, path complexity is not a
constant number but a symbolic expression on a single vari-
ablenwhich denotes the execution depth. The expression
computed by the path complexity is an upper bound for the
number of paths in the program up to the depth n. I.e.,
substituting a constant value for nin the function returned
by the path complexity and then evaluating the function
results in a constant number that corresponds to an upper
bound for the number of paths in the program within that
execution depth.
For example, for the method shown in Figure 1(a), the
path complexity is 4. Since this method does not contain any
loops, its path complexity is equal to its NPATH complexity.
However, for the method shown in Figure 1(b), the path
complexity is 0 :12n2+1:25n+3. Here, we observe that
the number of paths in this method increases polynomially
with respect to the depth of execution.
On the other hand, for the method shown in Figure 1(c),
the path complexity is 6 :861:17n+ 0:221:1n+ 0:13
0:84n+2. I.e., for this method, the number of paths increases
exponentially with respect to the depth of execution.
Asymptotic Path Complexity.
The path complexity expressions could easily get extremely
complicated. In order to produce a more readable and un-
derstandable complexity measure, we also dene the asymp-
totic path complexity which simply extracts the dominant
term from the path complexity expression. So, the asymp-
totic path complexity of the method shown in Figure 1(a)
is (1), denoting that its number of paths are constant,
the asymptotic path complexity of the method shown in
Figure 1(b) is ( n2), denoting a quadratic growth in the
number of paths with increasing execution depth, and the
asymptotic path complexity of the method shown in Fig-
ure 1(c) is (1 :17n), denoting an exponential growth in the
number of paths with increasing execution depth.
The summary of dierent complexity measures for themethods shown in Figure 1 is shown in Table 1. We claim
that path complexity and asymptotic path complexity re-
ect the cost of achieving path coverage in testing better
than cyclomatic complexity and NPATH complexity.
3. COMPUTING PATH COMPLEXITY
In order to compute the path complexity of a method
within a program, we rst extract its control ow graph
(CFG). A CFG Gis a tuplehN;E;S;TiwhereNis the set
of nodes denoting basic blocks of the program, ENNis
the set of edges denoting the control ow among basic blocks,
S2Nis a unique node denoting the basic block where
the execution starts, and T2Nis a unique node denoting
the basic block where the execution terminates (programs
with multiple termination points can be represented with
CFGs in this format by creating an extra termination node).
Below, we assume that Sis always the node labeled with the
smallest number (i.e., 1) and Tis always the node labeled
with the highest number.
Once we have determined the control ow graph, we make
use of techniques from algebraic graph theory and analytic
combinatorics to count the number of execution paths [3, 32,
12]. Given a CFG G, using standard graph theory notation,
a pathis a sequence of edges in G,e1;e2;:::e n, and the
length of a path L() is the number of edges in the path.
Given a bound, n, on the execution depth, we produce a
closed-form solution function, path(n), that computes the
number of paths, , withL()n. Frompath(n), the
asymptotic behavior can be determined and used to catego-
rize the path complexity of the method from which the CFG
was derived.
In order to aid the reader, we demonstrate the technique
on a small example. Consider the CFG shown in Figure 3.
Denecount (n) to be the number of paths of exactly length
nandpath(n) to be the number of paths with length less
than or equal to n. That is,path(n) =Pn
i=1count (i). For
our small example graph, one can verify that count (n) is 1 if
n= 3k+ 2 for some non-negative integer kand 0 otherwise;
there is one path of length 2, one path of length 5, and so
on. The values of count (n) andpath(n) are listed in the
table shown in Figure 3 for values of nup to 9.
We dene the path count sequence of a graph G to be an
innite sequence a0;a1;:::;a i;:::where each ai=path(i).
In our running example, the path count sequence is f0;0;1;
1;1;2;2;2;3;:::g. Further investigation would indicate that
path(n) =bn+1
3cwherebxcis the integer oor function.
Asymptotically speaking, we can see that the number of
paths grows linearly, approximately asn
3, with the depth
boundn. We will demonstrate how such asymptotic anal-
ysis can be automated using the theory of integer sequence
generating functions.
651: START
2
5: EXIT 3
4ncount (n)path(n)
0 0 0
1 0 0
2 1 1
3 0 1
4 0 1
5 1 2
6 0 2
7 0 2
8 1 3
9 0 3
.........
Figure 3: An example CFG and corresponding path counts.
Generating Function for an Integer Sequence: For an integer
sequencefaigthat represents the bounded path counts of a
CFG, we can encode values of path(i) as the coecients of
a polynomial: an ordinary generating function (GF).
The ordinary generating function [32, 12] of the sequence
a0,a1,:::,ai,:::is the innite polynomial
g(z) =X
i0aizi: (2)
Althoughg(z) is an innite polynomial, it can be inter-
preted as the Taylor series of a nite rational expression [10].
I.e., we can also write g(z) =p(z)=q(z), wherep(z) andq(z)
are nite degree polynomials. If g(z) is given as such a -
nite rational expression, each aican be computed from the
Taylor series expansion of g(z):
ai=g(i)(0)
i!; (3)
whereg(i)(z) is theithderivative of g(z). We write [ zi]g(z)
for theithTaylor series coecient of g(z). This is what
makes a generating function useful; it is a compact nite
representation of an innite series.
Returning to our running example, we can write the gen-
erating function for path(n) both as a rational function and
as an innite Taylor series polynomial. The reader can ver-
ify the following equivalence by computing the coecients
via equation (3):
g(z) =z2
1 z+z3 z4
(4)
=z2+z3+z4+ 2z5+ 2z6+ 2z7+ 3z8+:::
Given the generating function for our CFG written as a
nite rational expression, we can take the nthTaylor series
coecient to determine the number of paths with length
bounded by n. For example, to compute the number of
paths with a length bound of 10, we can compute path(10) =
[z10]g(z) = 3.
In fact, we can use the generating function to derive a
closed-form function of nthat computes the desired coe-
cient. In the following, describe how to determine the gen-
erating function as a nite rational expression for a CFG,
extract a closed-form function for counting paths, and howto perform asymptotic analysis of that function.
Generating Function for a CFG: Given a CGF Gand length
n, we can compute the generating function g(z) such that
thenthTaylor series coecient of g(z) is equal to path(n).
From a CFG G, we construct the adjacency matrix (also
called the \transfer-matrix" [32, 12]) T, whereTijis 1 if
there is an edge from vitovjand 0 otherwise. In addition,
TjNj;jNj= 1, wherejNjis the number of nodes in G. Then
the generating function for path(n) is
g(z) = ( 1)jNj+1det(I zT:jNj;1)
det(I zT); (5)
where (M:i;j) denotes the matrix obtained by removing
theithrow andjthcolumn from M,Iis the identity matrix,
and det(M) is the matrix determinant.
The transition matrix T, and the terms ( I zT) and (I 
zT:n;1) for our running example are:
T=2
66640 1 0 0 0
0 0 1 0 1
0 0 0 1 0
0 1 0 0 0
0 0 0 0 13
7775;I zT=2
66641 z0 0 0
0 1 z0 z
0 0 1 z 0
0 z0 1 0
0 0 0 0 1  z3
7775;
(I zT: 5;1) =2
664 z0 0 0
1 z0 z
0 1 z0
 z0 1 03
775;
and applying equation (5) by taking the appropriate deter-
minants results in the generating function
g(z) =z2
1 z+z3 z4: (6)
This is precisely the same GF that counts paths in our ex-
ample CFG given in equation (4).
A Closed-form Solution: From a rational generating function
g(z) =p(z)=q(z) we can derive a closed-form function for
path(n) that is a sum of products of simple polynomial and
exponential terms. Given a generating function, the form
ofpath(n) is determined by the roots of the denominator
q(z) [11, 12].
Supposeq(z) is a polynomial of degree d. By the Fun-
damental Theorem of Algebra [25], q(z) has exactly droots
over the complex numbers, accounting for multiplicity. Ig-
noring multiplicity, suppose there are Ddistinct roots. Let
ribe theithdistinct root of q(z) andmibe the multiplicity
ofri. Thenpath(n) is given by
path(n) =DX
i=1mi 1X
j=0ci;jnj1
rin
; (7)
whereciare coecients that are determined by the rst d
terms of the Taylor series expansion of g(z). Sincepath(n) =
[zn]g(z) for alln, we can dene a system of dequations and
dunknowns. This system can be solved for the coecients
ci;jvia elementary linear algebra.
In our example, q(z) = 1 z+z3 z4and has four
roots. The root 1 is repeated and so there are three distinct
roots:r1=r2= 1 with multiplicity m1=m2= 2,r3=
66 1
2 ip
3
2with multiplicity m3= 1, andr4= 1
2 ip
3
2with
multiplicity m4= 1. In this particular case, it turns out
that1
r3=r3and1
r4=r4, whereris the complex conjugate
ofr. So our desired function becomes
path(n) =c1;0+c1;1n
+c2;0
 1
2 ip
3
2n
(8)
+c3;0
 1
2+ip
3
2n
The rst four terms of the Taylor series expansion of g(z)
area0=a1= 0 anda2=a3= 1. By evaluating path(n) at
n= 0;1;2;3 we can solve for the coecients ci;jto nd that
c1;0=4
3,c1;1=1
3,c2;0=1
6
ip
3 1
,c3;0=1
6
ip
3+ 1
.
Thus, we have
path(n) =4
3+1
3n
+1
6ip
3 1
 1
2 ip
3
2n
 1
6ip
3+ 1
 1
2+ip
3
2n
(9)
While it appears that this function may take on fractional
and complex values, for every value of n, any imaginary
terms conveniently cancel out and fractions combine to re-
sult in integers. In fact, one may verify that the resulting
functionpath(n) is equivalent to bn+1
3c. Furthermore, al-
thoughpath(n) has a seemingly complicated form, it can be
derived automatically from the transfer-matrix method and
the resulting generating function.
Upper Bounds: In order to perform asymptotic analysis of
path(n) we rst bound the complex terms. Because the
complex roots of q(z) always appear in conjugate pairs, we
can bound and combine them in pairs. For any complex
numberw,wn+wnis a real number. Furthermore  2jwjn
wn+wn2jwjn, wherejwjdenotes the complex norm of
w. Thus, we can replace each exponentiated complex root in
path(n) with its norm in order to get a sound upper bound.
We denote the upper bound on path(n) byupper (n).
In our example,jr3j=jr4j= 1. Performing the substitu-
tion and simplifying, we get
path(n)4
3+1
3n+1
6ip
3 1
1 1
6ip
3+ 1
1
=n+ 1
3=upper (n): (10)
Notice that this is the same result given in our initial in-
formal analysis of the example CFG, without the oor func-
tion. We plot the exact solution given in equation (9) and
the upper bound given in equation (10) together in Figure 4.
Asymptotic Analysis: We extract the asymptotic complexity
from the upper bound on path(n) using standard asymptotic
analysis, where f(n) = (g(n)) if and only if lim n!1f(n)
g(n)=
1 [34]. The asymptotic path complexity of our running ex-
ample can be described by upper (n) = (n).0 2 4 6 8 10 12 140246
135
Execution Path Length Bound nPath Complexity
Exact
Bound
Figure 4: Comparison of exact solution and upper bound.
We have been able to determine that the path complex-
ity of our example CFG grows linearly with the execution
depth. This same method outlined here works on more com-
plex CFGs as well, allowing one to determine if the path
complexity of a program is asymptotic to a constant, n,n2,
n3, and so on, or bnfor some exponential base b.
Numeric Approximation: In some instances, it is necessary
to perform numeric approximation for the roots of q(z). This
is due to the fact that there is no explicit formula for solving
polynomials with degree larger than 4. By the Abel{Runi
Theorem [33] a general solution does not exist for exactly
expressing roots in terms of the elementary algebraic oper-
ations of addition, subtraction, multiplication, division, ex-
ponentiation, taking roots, and so on. Note that this does
not mean that all polynomials of degree 5 or larger cannot
be solved exactly, but that there is no all-purpose method
for producing exact solutions.
On the other hand, the roots of any polynomial can be
approximated to within any desired nite precision using
standard numeric root-nding techniques [4].
Thus, when the degree of q(z) is greater than 4 we numeri-
cally approximate each root riby (ri). In our experiments
is such that we maintain at least 15 digits of precision.
Algorithm Overview: Now that we have described the math-
ematical theory behind path complexity, we give a high level
description of the path complexity analysis in Algorithm 1.
Algorithm 1 Computing path complexity of CFG G
1: Determine adjacency matrix Tof the CFG G.
2: Compute generating function via Eq. 5 as follows:
g(z) =p(z)
q(z)=( 1)n+1det(I zT:n;1)
det(I zT)
3: Compute roots of q(z) to determine path(n) via Eq. 7.
4: Solve for each ci;jinpath(n) using the rstjNjTaylor
series coecients of g(z), via Eq. 3, which gives path(n).
5: Determine upper bound on path(n) by replacing each
complex root wwithjwjand simplifying.
6: Determine asymptotic behavior of upper bound on
path(n).
67Table 2: Complexity measure comparison.
Pattern Control Flow GraphCyclomatic
ComplexityNPATH
ComplexityAsymptotic Path
Complexity
KIf-Else in sequence
11'
2(K-1)'
K K+ 1 2K2K
KIf-Else nested
1K
1'K+1
K' K+ 1 K+ 1 K+ 1
KLoop in sequence
1 2 K-1 K K+ 1 2K(nK)
KLoop nested
1 2 K-1 K K+ 1 K+ 1 (bn)
4. COMPARISON WITH OTHER
COMPLEXITY MEASURES
In Table 2 we give the cyclomatic, NPATH, and asymp-
totic path complexity expressions for four common program-
ming patterns. Given an integer constant K, we examine
the following: a sequence of Kconditional statements, fully
nested conditional statements to a depth of K, a sequence
ofKloops, and fully nested loops to a depth of K.
For these four patterns, cyclomatic complexity gives iden-
tical results, and it simply grows linearly with the number
of conditional or loop structures. Consequently, cyclomatic
complexity alone cannot distinguish the dierences in these
four patterns and is not a good measure of assessing the dif-
culty of achieving path coverage in testing these programs.
NPATH complexity does a slightly better job, but still
only reports a constant number that depends directly on
the size of the graph, not on the execution depth bound.
NPATH complexity cannot distinguish between Kcondi-
tional statements in sequence and Klooping statements in
sequence, both of which yield a constant value of 2Kfor a
givenK. Likewise, NPATH cannot distinguish between K
nested conditional statements and Knested looping state-
ments, both of which yield a constant value of K+ 1 for a
givenK. Because NPATH complexity counts paths in which
edges cannot be crossed more than once, it does not account
for all possible combinations of loop repetitions, and, there-
fore, is also not a good measure of assessing diculty of
achieving path coverage.
Among the three metrics, asymptotic path complexity is
the most useful in distinguishing between the complexity of
the four programming patterns. It produces four dierent
types of results. For Kconditional statements executed in
sequence it tells us that there are a constant number of pos-
sible executions and that the constant number is exponential
in the number of conditions. For nested conditions it tells us
that the number of paths is constant and that the number
of paths is linear in the number of conditions. For Kloops
in sequence asymptotic path complexity tells us that, as the
execution depth bound nincreases, the number of paths
grows polynomially as ( nK). Finally, for Knested loop
structures, we nd that as the depth bound nincreases, the
number of possible executions grows exponentially, as ( bn)
wherebis a constant number that depends on K.5. IMPLEMENTATION & EXPERIMENTS
In order to evaluate the path complexity algorithm, we
performed an experimental comparison with the two com-
plexity measurement method described in Section 2: Cyclo-
matic complexity and NPATH complexity.
We implemented Algorithm 1 in a tool called PAth Com-
plexity analyzer ( PAC ).PAC automatically computes the
path complexity and asymptotic path complexity of Java
methods. PAC accepts a Java class le or a jar of class les
as input and reports path complexity and asymptotic path
complexity for all methods of input Java class(es). PAC
has two main steps: (1) Control-ow graph (CFG) extrac-
tion, (2) Path complexity calculation. PAC is available for
download; see the Appendix for details.
We used the ASM1Java bytecode manipulation library to
generate CFGs using an intra-procedural analysis for each
method. PAC rst computes the basic blocks of a method.
A basic block is a sequence of code statements where there is
only one entry point and one exit point. In other words, none
of the instructions are the target of a jump instruction except
for the rst and none of the instructions are a jump/halt
instruction except for the last. PAC constructs CFGs using
basic blocks which results in compact CFGs.
We implemented Algorithm 1 based on the techniques
described in Section 3 using Mathematica2. Implement-
ing the algorithm in the Mathematica language allowed
us to leverage the built-in routines for symbolic manipula-
tion of matrices, polynomials, and complex expressions, as
well as numeric root nding methods. We also implemented
the computation of cyclomatic complexity and a version of
NPATH complexity based on the CFG as described in Sec-
tion 2.
To do a comparative evaluation we experimented with the
Java 7 SDK (Java benchmark) and the 34 Apache Com-
mons3libraries (Apache benchmark). We extracted 132 ;768
CFGs from the Java benchmark and 44 ;426 CFGs from the
Apache benchmark. We ran all the experiments on an In-
tel I5 machine with 2.5GHz X 4 processors and 32 GB of
memory running Ubuntu 14.04.
1http://asm.ow2.org/
2http://www.wolfram.com/mathematica/
3http://commons.apache.org/
68Table 3: Comparison of asymptotic complexity classication with cyclomatic and NPATH complexity values.
Path Comp.
ClassicationsAsym. Comp.
# methodsCyclomatic Complexity
# methodsNPATH Complexity
# methods
1 5 6 10 11 100>100 1 5 6 10 11 100 >100
C > 1 51959 43347 (83.4%) 6082 (11.7%) 2516 ( 4.8%) 14 ( 0.0%) 41001 (78.9%) 5541 (10.7%) 4441 ( 8.5%) 976 ( 1.9%)
(n) 9120 7321 (80.3%) 1296 (14.2%) 503 ( 5.5%) 0 ( 0.0%) 6721 (73.7%) 1298 (14.2%) 917 (10.1%) 184 ( 2.0%)
(n2) 693 308 (44.4%) 245 (35.4%) 140 (20.2%) 0 ( 0.0%) 181 (26.1%) 183 (26.4%) 252 (36.4%) 77 (11.1%)
(n3) 137 56 (40.9%) 44 (32.1%) 37 (27.0%) 0 ( 0.0%) 0 ( 0.0%) 39 (28.5%) 69 (50.4%) 29 (21.2%)
(ne);e4 55 0 ( 0.0%) 23 (41.8%) 32 (58.2%) 0 ( 0.0%) 0 ( 0.0%) 0 ( 0.0%) 13 (23.6%) 42 (76.4%)
(bn);1<b< 2 7776 2491 (32.0%) 2759 (35.5%) 2514 (32.3%) 12 ( 0.2%) 1954 (25.1%) 1700 (21.9%) 2674 (34.4%) 1448 (18.6%)
(bn);2b<3 735 392 (53.3%) 237 (32.2%) 102 (13.9%) 4 ( 0.5%) 296 (40.3%) 171 (23.3%) 210 (28.6%) 58 ( 7.9%)
(bn);3b<4 49 24 (49.0%) 11 (22.4%) 8 (16.3%) 6 (12.2%) 21 (42.9%) 8 (16.3%) 10 (20.4%) 10 (20.4%)
(bn);b4 30 0 ( 0.0%) 16 (53.3%) 13 (43.3%) 1 ( 3.3%) 0 ( 0.0%) 13 (43.3%) 7 (23.3%) 10 (33.3%)
Experimental Results.
We ran PAC for the Java SDK 7 and the Apache commons
libraries. The total execution time for the Java benchmark
is 2 hours 34 minutes 49 seconds with an average of 0.07 sec-
onds per class le. The total execution time for the Apache
benchmark is 53 minutes and 10 seconds with an average of
0.07 seconds per class le.
We compared PAC 's asymptotic path complexity with cy-
clomatic complexity and NPATH complexity. We dened
four complexity classes: 1) constant with value 1 ( C= 1),
2) constant with a value that is greater than 1 ( C > 1), 3)
polynomial( nk, withk1), and 4) exponential ( bn, with
n>1). Figure 5 shows the percentage of number of meth-
ods for each complexity class based on the PAC analysis
results. The Java and Apache benchmarks have similar dis-
tributions. More than half of the methods ( 60%) have
only 1 execution path for both benchmarks. I.e., there are
no jump instructions in those methods except for the method
exit. For the Java benchmark, 30 :1% of the methods have
a constant complexity value greater than one, and 9 :3% of
them have polynomial or exponential complexity. Similarly,
27% of the Apache benchmark methods have constant com-
plexity greater than one and 12 :12% of them have polyno-
mial or exponential complexity. We will omit the discussion
of the methods that have a single execution path as all com-
plexity measurements report the constant value 1. For the
rest of the discussion, we further dene ne-grained com-
plexity classes based on the degrees of the polynomials and
bases of the exponentials (rst column in Table 3) and give
the number of methods at each ne-grained class that are
classied by PAC (second column).
Java 7 SDK
C= 1
C > 1nkbn60.0%
30.1%5.3%4.6%Apache
C= 1
C > 1nkbn60.8%
27.0%6.7%5.5%
Figure 5: Distribution of the methods to four asymptotic
complexity classes: 1) single path ( C= 1), 2) constant num-
ber of paths greater than one ( C > 1), 3) polynomial ( nk,
k1), and 4) exponential ( bn,n>1).Table 3 shows the distributions of the cyclomatic and
NPATH complexity results over the ne-grained complex-
ity classes. We dened 4 bins for the values of cyclomatic
and NPATH complexity as shown in the table header. The
rst row represents the methods that have nitely many ex-
ecution paths (CFG contains only forward-edges). For this
case, reporting the actual number of execution paths is more
meaningful for path coverage rather than simply reporting
that it is a constant number. For this reason, PAC also re-
ports the actual number of execution paths in this complex-
ity class. PAC and NPATH complexity give the same result,
and cyclomatic complexity gives the same or a smaller num-
ber. NPATH complexity percentages for the bins [11  100],
[>100] are larger than cyclomatic complexity percentages
for the same bins. This is due to the fact that there can be
exponential growth in the number of execution paths with
the increase of forward-edges in a CFG, whereas cyclomatic
complexity only grows linearly with the number of forward-
edges. NPATH complexity is able to catch such exponential
cases as shown in the rst row of Table 2. By looking at
only that row, we can say that cyclomatic complexity is not
a good metric for assessing the diculty of achieving path
coverage.
The percentages of the corresponding bins in the ( C > 1)
row and ( n) row are close to each other both in cyclomatic
and NPATH complexity. Hence, we can say that neither cy-
clomatic complexity nor NPATH complexity is able to dif-
ferentiate between the methods with a constant number of
execution paths and the methods with unbounded number of
execution paths. As the degree of the polynomial increases,
the percentages in the bin [1  5] decreases. Similarly, as
the base of the exponential increases, the percentages in the
bin [1 5] decreases. This is because of the fact that, as
the complexity grows, we would expect more edges in the
CFG. Cyclomatic complexity always grows linearly with the
number of edges and NPATH complexity grows linearly or
exponentially with the number of edges. We can see that
the NPATH complexity shows a stronger increase in the per-
centages of higher range bins as the degree of polynomials
increases compared to the increase in the base of the expo-
nentials. This is due to that fact that, NPATH complexity
grows exponentially when the complexity is polynomial and
linearly when the complexity is exponential. Hence, NPATH
complexity is not a good measure for assessing the diculty
of achieving path coverage.
One other important point is that, cyclomatic complex-
ity and NPATH complexity only give a constant number
as a measurement of program complexity. The number it-
self does not give sucient information on diculty of path
coverage. There is always an overlap between dierent com-
69plexity classes in terms of number of methods in the same
range. For example, cyclomatic complexity reports values in
the bin [6 10] for 9 dierent complexity classes and NPATH
reports values in the bin [6  10] for 8 dierent complexity
classes. As a concrete example, PAC reports (n3) for the
method:
com.sun.org.apache.xerces.internal.impl.xs.XML
SchemaValidator$ValueStoreCache.initValueStoresFor
and (3n) for the method:
sun.java2d.loops.GraphicsPrimitive.satisfies
The corresponding cyclomatic complexity and NPATH com-
plexity reported for both methods are 8 which does not carry
enough information on actual diculty of achieving path
coverage for these methods.
We conducted the same comparison for all values of cy-
clomatic and NPATH complexity in C > 1, (n), (n2),
(bn);1< b < 2, and (bn);2b <3 complexity classes.
Figure 6 shows the frequencies of NPATH complexity and
cyclomatic complexity up to complexity measures of 100 in
order to visualize the distribution. Frequencies in Figure 6a
and Figure 6c for NPATH complexity follows similar trends
for the complexity classes C > 1 and (n). We can see a
similar trend between any two frequency graphs of NPATH
complexity. The frequencies of cyclomatic complexity val-
ues are also following the same trend as shown in Figures 6b,
6d, 6f, 6h, 6j. Figure 6 validates that cyclomatic complexity
and NPATH complexity are not successful in dierentiating
between methods in dierent complexity classes, and hence,
they are not good for assessing the diculty of achieving
path coverage.
Overall, our experimental results validate that path com-
plexity is a better measure for assessing diculty of achiev-
ing path coverage compared to to cyclomatic complexity and
NPATH complexity. Our results also show that path com-
plexity can be computed eciently.
6. CONCLUSIONS
We present path complexity and asymptotic path com-
plexity measures that provide an upper bound for the num-
ber of execution paths in a program. In order to compute
the path complexity, we rst extract the control ow graph,
and then use graph theoretic techniques to generate a path
complexity function that gives an upper bound for the num-
ber of execution paths within a given execution depth. Our
path complexity analyzer can be used for assessing the dif-
culty of achieving path coverage with respect to increasing
execution depth in the context of automated testing. Our
experiments on popular Java libraries demonstrate the ef-
fectiveness and eciency of the proposed approach. In the
future, we plan to extend our path complexity analyzer with
a context-sensitive inter-procedural analysis.20 40 60 80 1000510152025
NPATH complexity# methods 1000C > 1
(a)20 40 60 80 1000510152025
Cyclomatic complexity# methods 1000C > 1
(b)
20 40 60 80 1000123
NPATH complexity# methods 1000(n)
(c)20 40 60 80 1000123
Cyclomatic complexity# methods 1000(n)
(d)
20 40 60 80 100050100150
NPATH complexity# methods(n2)
(e)20 40 60 80 100050100150
Cyclomatic complexity# methods(n2)
(f)
20 40 60 80 1000246810
NPATH complexity# methods 100(bn) , 1< b < 2
(g)20 40 60 80 1000246810
Cyclomatic complexity# methods 100(bn) , 1< b < 2
(h)
20 40 60 80 100050100150
NPATH complexity# methods(bn) , 2b <3
(i)20 40 60 80 100050100150
Cyclomatic complexity# methods(bn) , 2b <3
(j)
Figure 6: Distribution of NPATH and cyclomatic complexity
values for the methods in dierent asymptotic complexity
classes.
707. REPLICATION PACKAGE
The source code for PAC as well as a web interface are
available from the University of California Santa Barbra Ver-
ication Lab (UCSB VLab) website:
http://www.cs.ucsb.edu/~vlab/PAC/ .
Source Code and Data. Our tool, PAC, and experimental
results have been successfully evaluated by the Replication
Packages Evaluation Committee and found to meet expecta-
tions. The replication package for PAC can be downloaded
as a compressed archive. Detailed instructions and scripts
are provided for running our tools. Please note that our path
complexity routines require a current installation of Math-
ematica . The package consists of ve major components.
1.CFG Extractor. This is an intra-procedural con-
trol ow graph extraction tool based on the ASM Java
bytecode manipulation library. Our command-line-
based application takes a directory of Java class les
(or a single Java class le) as input. It then com-
putes an intra-procedural control ow graph for every
method. The output is a directory of CFGs exported
to Graphviz dotformat.
2.Complexity Analyzer. Cyclomatic, NPATH, and
path complexities are computed with a set of Math-
ematica routines. A command-line-based script is
provided that takes a directory of control ow graphs
(or a single control ow graph) as input. The input
CFG's must be in Graphviz dot format. Each CFG is
imported into a Mathematica session and analyzed.
The results are output into a user-dened le of comma
separated values{see the following description of exper-
imental data.
3.Java Libraries. The Java 7 SDK and Apache Com-
mons libraries are provided as benchmark sets. The
CFG Extractor described above can be run on these
libraries in order to generate the control ow graphs
as input to the Complexity Analyzer.
4.Control Flow Graphs. All of the control ow graphs
generated from the Java libraries are provided.
5.Experimental Data. All experimental results for
Java 7 SDK and Apache libraries, as summarized in
Section 5, are also included. The results include the
cyclomatic complexity, NPATH complexity, path com-
plexity, asymptotic complexity, and complexity class
(constant, polynomial, or exponential) for every method
in the benchmark libraries.
Web Interface. A web interface for PAC is also avail-
able from the UCSB Verication Lab web page. The user
may upload a Java class le, multiple class les, a folder of
class les, or a .jar le. For every method in the submit-
ted les, a table is produced that describes the method's
cyclomatic complexity, NPATH complexity, path complex-
ity, asymptotic path complexity, and complexity class. The
complexity class is reported as either constant, polynomial,
or exponential.8. REFERENCES
[1] Abdulbaki Aydin, Lucas Bang, and Tevk Bultan.
Automata-based model counting for string constraints.
InProc. 27th Int. Conf. Computer Aided Verication
(CAV) , 2015.
[2] Clark W. Barrett, David L. Dill, and Aaron Stump. A
framework for cooperating decision procedures. In
Proc. 17th Int. Conf. Automated Deduction (CADE) ,
pages 79{98, 2000.
[3] N. Biggs. Algebraic Graph Theory . Cambridge
Mathematical Library. Cambridge University Press,
1993.
[4] R. Burden and J. Faires. Numerical Analysis . Cengage
Learning, 2010.
[5] Cristian Cadar, Daniel Dunbar, and Dawson R.
Engler. KLEE: unassisted and automatic generation of
high-coverage tests for complex systems programs. In
Proc. 8th Symp. Operating Systems Design and
Implementation (OSDI) , pages 209{224, 2008.
[6] Christoph Csallner and Yannis Smaragdakis. Check
'n' crash: combining static checking and testing. In
Proc. 27th Int. Conf. Software Engineering (ICSE) ,
pages 422{431, 2005.
[7] Christoph Csallner, Yannis Smaragdakis, and Tao Xie.
Dsd-crasher: A hybrid analysis tool for bug nding.
ACM Trans. Softw. Eng. Methodol. , 17(2), 2008.
[8] Leonardo Mendon ca de Moura and Nikolaj Bjrner.
Z3: an ecient SMT solver. In Proc. 14th Int. Conf.
Tools and Algorithms for the Construction and
Analysis of Systems (TACAS) , pages 337{340, 2008.
[9] Nishant Doshi. Approximation for the path complexity
of binary search tree. CoRR , abs/1404.4692, 2014.
[10] A. Erdelyi. Asymptotic Expansions . Dover, 1956.
[11] Philippe Flajolet and Andrew M. Odlyzko. Singularity
analysis of generating functions. SIAM J. Discrete
Math. , 3(2):216{240, 1990.
[12] Philippe Flajolet and Robert Sedgewick. Analytic
Combinatorics . Cambridge University Press, New
York, NY, USA, 1 edition, 2009.
[13] Cormac Flanagan, K. Rustan M. Leino, Mark
Lillibridge, Greg Nelson, James B. Saxe, and Raymie
Stata. Extended static checking for java. In Proc. 2002
Conf. Programming Language Design and
Implementation (PLDI) , pages 234{245, 2002.
[14] Georey K. Gill and Chris F. Kemerer. Cyclomatic
complexity density and software maintenance
productivity. IEEE Trans. Software Eng. ,
17(12):1284{1288, 1991.
[15] Patrice Godefroid. Model checking for programming
languages using verisoft. In Proc. 24th Symp.
Principles of Programming Languages (POPL) , pages
174{186, 1997.
[16] Patrice Godefroid, Nils Klarlund, and Koushik Sen.
DART: directed automated random testing. In
Proceedings of the 2005 ACM SIGPLAN Conference
on Programming Language Design and
Implementation (PLDI) , pages 213{223, 2005.
[17] Bhargav S. Gulavani and Sumit Gulwani. A numerical
abstract domain based on expression abstraction and
max operator with application in timing analysis. In
Proc. 20th Int. Conf. Computer Aided Verication
(CAV) , pages 370{384, 2008.
71[18] Sumit Gulwani, Sagar Jain, and Eric Koskinen.
Control-ow renement and progress invariants for
bound analysis. SIGPLAN Not. , 44(6):375{385, June
2009.
[19] Sumit Gulwani, Bill McCloskey, and Ashish Tiwari.
Lifting abstract interpreters to quantied logical
domains. In Proc. 35th Symp. Principles of
Programming Languages (POPL) , pages 235{246,
2008.
[20] Sumit Gulwani and Florian Zuleger. The
reachability-bound problem. SIGPLAN Not. ,
45(6):292{304, June 2010.
[21] Brian Henderson-Sellers, Yagna Raj Pant, and
June M. Vemer. Cyclomatic complexity: theme and
variations. Australasian J. of Inf. Systems , 1(1), 1993.
[22] Dennis G. Kafura and Geereddy R. Reddy. The use of
software complexity metrics in software maintenance.
IEEE Trans. Software Eng. , 13(3):335{343, 1987.
[23] Taghi M. Khoshgoftaar and John C. Munson.
Predicting software development errors using software
complexity metrics. IEEE Journal on Selected Areas
in Communications , 8(2):253{261, 1990.
[24] James C. King. Symbolic execution and program
testing. Commun. ACM , 19(7):385{394, 1976.
[25] S.G. Krantz. The Handbook of Complex Variables.
Birkh auser, 1999.
[26] Loi Luu, Shweta Shinde, Prateek Saxena, and Brian
Demsky. A model counter for constraints over
unbounded strings. In Proc. 2014 Conf. Programming
Language Design and Implementation (PLDI) ,page 57, 2014.
[27] Thomas J. McCabe. A complexity measure. IEEE
Trans. Software Eng. , 2(4):308{320, 1976.
[28] Beth McColl and James C. McKim. Evaluating and
extending npath as a software complexity measure.
Journal of Systems and Software , 17(3):275{279, 1992.
[29] Brian A. Nejmeh. NPATH: A measure of execution
path complexity and its applications. Commun. ACM ,
31(2):188{200, 1988.
[30] Corina S. Pasareanu, Willem Visser, David H.
Bushnell, Jaco Geldenhuys, Peter C. Mehlitz, and
Neha Rungta. Symbolic pathnder: integrating
symbolic execution with model checking for java
bytecode analysis. Autom. Softw. Eng. , 20(3):391{425,
2013.
[31] Koushik Sen, Darko Marinov, and Gul Agha. Cute: a
concolic unit testing engine for c. In Proc. 10th
European Software Engineering Conf. and 13th Int.
Symp. Foundations of Software Engineering
(ESEC/FSE) , pages 263{272, 2005.
[32] Richard P. Stanley. Enumerative Combinatorics:
Volume 1 . Cambridge University Press, New York,
NY, USA, 2nd edition, 2011.
[33] I. Stewart. Galois Theory, Third Edition . Chapman
Hall/CRC Mathematics Series. Taylor & Francis, 2003.
[34] J. Stewart. Calculus . Cengage Learning, 2007.
[35] Willem Visser, Klaus Havelund, Guillaume P. Brat,
Seungjoon Park, and Flavio Lerda. Model checking
programs. Autom. Softw. Eng. , 10(2):203{232, 2003.
72