Self-Protection of Android Systems from Inter-component
Communication Attacks
Mahmoud Hammad, Joshua Garcia, and Sam Malek
Department of Informatics
University of California, Irvine
Irvine, CA, USA
{hammadm, joshug4, malek}@uci.edu
ABSTRACT
The current security mechanisms for Android apps, both static
and dynamic analysis approaches, are insufficient for detection
andpreventionoftheincreasinglydynamicandsophisticatedsecu-
rityattacks.Staticanalysisapproachessufferfromfalsepositives
whereasdynamicanalysisapproachessufferfromfalsenegatives.
Moreover,theyalllacktheabilitytoefficientlyanalyzesystemswith
incremental changes—such as adding/removing apps, granting/re-
voking permissions, and dynamic components’ communications.
Eachtimethesystemchanges,theentireanalysisneedstobere-
peated,makingtheexistingapproachesinefficientforpracticaluse.
Tomitigatetheirshortcomings,wehavedevelopedSALMA,anovel
self-protectingAndroidsoftwaresystemthatmonitorsitselfand
adapts its behavior at runtime to prevent a wide-range of security
risks. SALMA maintains a precise architectural model, represented
asaMultiple-Domain-Matrix,andincrementallyandefficientlyana-
lyzesanAndroidsysteminresponsetoincrementalsystemchanges.
Themaintainedarchitectureisusedtoreasonabouttherunning
Android system. Every time the system changes, SALMA deter-
mines (1) the impacted part of the system, and (2) the subset of the
security analyses that need to be performed, thereby greatly im-
provingtheperformanceoftheapproach.Ourexperimentalresults
onhundredsofreal-worldappscorroborateSALMA’sscalability
andefficiencyaswellasitsabilitytodetectandpreventsecurity
attacks at runtime with minimal disruption.
CCS CONCEPTS
•Security and privacy →Software security engineering ;
KEYWORDS
Self-protecting system;Android security;Software Engineering
ACM Reference Format:
MahmoudHammad, JoshuaGarcia, andSam Malek.2018. Self-Protection
of Android Systems from Inter-component Communication Attacks. In
Proceedingsofthe201833rdACM/IEEEInternationalConferenceonAutomated
Software Engineering (ASE ’18), September 3–7, 2018, Montpellier, France.
ACM,NewYork,NY,USA, 12pages.https://doi.org/10.1145/3238147.3238207
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ASE ’18, September 3–7, 2018, Montpellier, France
© 2018 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.32382071 INTRODUCTION
Reusability is a major reason behind the meteoric rise in the popu-
larityoftheAndroidplatform[ 12]andtheincreasingnumberof
apps[10].Todeveloprichapps,Androidpromotesreusabilityof(1)
information and services provided by third-party apps, through its
flexibleInter-ComponentCommunication(ICC)model,and(2)sen-
sitive resources protectedby a permission-basedmodel. However,
sincetheinceptionofAndroid,theICCandthepermission-based
modelshavebecomethemainattackvectorforAndroidapps,which
can lead to serious security and privacy risks [23, 32,42,57].
Thecurrentstate-of-the-artsecurity mechanisms forAndroid
apps, both static and dynamic analysis approaches, are insufficient
fordetectingandpreventingtheincreasinglysophisticatedsecurity
attacks.Staticanalysisapproachessufferfromfalsepositivesdue
totheirover-approximationoftheanalyzedapps,e.g.,producing
warnings for vulnerabilities that are not executable at runtime.
On the other hand, dynamic analysis approaches suffer from false
negativesduetothe reachability problem,wherevulnerabilitiesare
missed due to inputs that fail to reach the vulnerable code.
Moreover,duetothecomplexanddynamicnatureofAndroid
systems(e.g.,adding/removinganapp,granting/revokingapermis-
sion, and dynamic class loading), their security posture changes
overtime.SimplyrepeatingtheentiresecurityanalysisofanAn-
droidsystem,eitherstaticallyordynamically,everytimethesystem
changes is prohibitively expensive for practical use.
To overcome the shortcomings of the current approaches, we
have developed SALMA, a novel self-protecting Android software
systemthat(1)continuouslymonitorstherunningAndroidsystem,
(2) incrementally and efficiently analyzes the security posture of
thesystem,and(3)dynamicallyenforcessecuritypoliciestopre-
ventsecurity attacksat runtime.SALMAleveragesstatic program
analysis to automatically derive the initial abstract representation,
i.e., a model, of an Android system. SALMA then monitors the
running system to keep the model synchronized with the running
system. Whenever the model changes, SALMA determines (1) the
impacted part of the system, and (2) the required security analyses
thatneedtobeperformed.Finally,SALMAadjustssecuritypolicies
and enforces them at runtime, thus ensuring the system is safe and
protected at all times.
SALMAmodelsthesystemasaMultiple-Domain-Matrix(MDM)
[49]—which provides an elegant, yet compact, representation of all
relationshipsamongprincipalelements,suchascomponentsand
permissions,inasystem.OurimplementationoftheMDMprovides
aflexiblewaytoloadandanalyzepartsofthesystem,improving
thescalabilityandefficiencyoftheoverallapproach.SALMAcanbe
used to protect Android systems without modification of the apps’
implementation logic, allowing our approach to be applied to all
existingAndroidapps.Ourevaluationof SALMAusinghundreds
of real-world apps corroborates its efficiency and scalability in
726
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Mahmoud Hammad, Joshua Garcia, and Sam Malek
analyzing evolving Android systems with minimal disruption to
apps and their services while thwarting security threats to keep
thesystemprotectedatalltimes.SALMAachieves70%-84%greater
detection of attacks than state-of-the-art approaches and 45%-85%
greater prevention of attacks than those approaches.
Therestofthispaperisorganizedasfollows.Section 2describes
the security attacks our approach can detect and prevent. The
research gap in the current security mechanisms for Android apps
ispresentedinSection 3.Section 4illustratesanAndroidsystemto
motivate our research. The approach and its implementation are
discussedinSections 5and6,respectively.Theevaluationresults
are presented in Section 7. Finally, the paper concludes with an
overview of the related literature and areas of future research.
2 ANDROID SECURITY ATTACKS
Inter-componentcommunication(ICC)inAndroidismainlyachieved
either by sending Intentsor using Unified Resource Identifiers
(URIs). An Intent is a message exchanged among apps, whose pay-
load includes an action to be performed along with the data that
supports that action. Component capabilities are then specified as
asetofIntentFilters thatrepresentthekindsofrequestshandled
byagivencomponent.Componentinvocationscomeindifferent
flavors, including explicit or implicit, and intra-app or inter-app.URIs are used to access or manipulate the encapsulated data in
Content Providers , the database components in Android apps.
Android’s ICC allows for late run-time binding between compo-
nents in the same or different apps, where the calls are not explicit
in the code, but instead are made through exchanging messages
thatcorrespondwithcertainevents,akeypropertyofevent-driven
systems. Android applies a permission-based model to protect sen-
sitiveresources,bothsystemresourcesandapplicationresources,
that each app is allowed to access. Since Android version 6, Googlechangedthepermissionmanagementsystemfromstatictodynamic,
allowing users to grant or revoke permissions at runtime.
The Android ICC interaction mechanism and the current per-
mission model of Android are the root cause of many security
vulnerabilities. They have become a vulnerable attack surface of
an Android system which threatens user privacy and has affected
millions of users [ 9]. These attacks are widely discussed in the
literature [ 22,23,28,29,32–34,42,44,64,70]. ICC attacks are se-
curityrisksfacilitatedby(1)incorrectlyormaliciouslyusingthe
message-passing system in Android or (2) misusing the permis-
sions in Android. SALMA provides self-protection against these
ICC attacks. This section briefly describes these attacks.
UnauthorizedIntentReceipt: Inthisattack,amaliciouscom-
ponent intercepts an implicit Intent by declaring an Intent Filter
that matches the sent Intent [ 23,44]. In such an attack, a malicious
component can access all enclosed data in the intercepted Intent
and, possibly perform a phishing attack [13].
IntentSpoofing: Insuchanattack,amaliciouscomponentcan
communicate with an exported component that is not expecting
such communication [ 23,44]. If a victim component blindly trusts
the received Intent, the malicious component can cause the victim
component to perform undesirable actions [36].
Privilege Escalation: This attack allows a malicious compo-
nent to indirectly perform a privileged task [ 22,34]. In this attack,
ifavulnerablecomponentpossessesapermissionwithoutappropri-
atelyprotectingitsinterface,amaliciouscomponentcanperform
a privileged task, such as sending a text message or tracking the
location of a user, by interacting with that vulnerable component.Identical Custom Permission: Any Android app can also de-
fineitsownpermissionsandusethemtoprotectitscomponents.
Eachpermissionmustdefineanameanda protectionlevel,where
eachlevel affectstheextentto whichapermissioncan begranted
or revoked. The notable protection levels for this paper are Normal
andSignature.A Normalpermission is automatically granted to
appsthatrequestthemwithoutaskingfortheuser’sapproval.A
Signature permission is granted to apps that are signed with the
same certificate as the app that declared the permission.
The custom permission model of Android contains a vulnera-
bility rooted in its design: "if two apps define the same custom
permission, whichever app is installed first is the one whose defini-
tion is used" [ 18]. A malicious app can exploit this vulnerability to
access a protected component with a custom permission by declar-
ing another permission with the same name as that legitimate one.
Passive Data Leak: Content Providers canbeusedforboth
intra-appdatapersistenceaswellassharingdataacrossapps.Ifthe
readaccesstoa Content Provider isnotproperlyguardedwith
apermission,otherappscanexploitthisvulnerabilitytodisclose
and leak sensitive data [42].
Content Pollution: Thisattackispossiblewhenthewriteac-
cesstoa Content Provider isnotproperlyguardedwithapermis-
sion [42]. Thisvulnerability allowsa malicious appto manipulate
sensitive data managed by a vulnerable app. The manipulated data
cancauseseveresideeffectssuchasalteringfirewallrulesorblock-
ing incoming calls.
3 RESEARCH GAP
ThecurrentsecuritymechanismsforAndroidapps,bothstaticand
dynamic analysis approaches, are insufficient for detecting and
preventing the increasingly dynamic and sophisticated attacks.
Static analysis approaches [ 48], [68], [46][50], [19], [70], [23],
[54],[34],[31],[47],[20],[60],[37],[38]sufferfromfalsepositives,
i.e., false alarms. The high number of false alarms generated by
such approaches lower their applicability. Moreover, static analysis
approaches face severe limitations when it comes to analyzing
obfuscatedordynamicallyloadedcode[ 57],thusinpracticealso
suffer from false negatives. Precise forms of static analysis also
require significant amounts of computing resources and can take a
substantial amount of time to execute.
Dynamic analysis approaches [ 30], [66], [17], [40], [27], [55],
[21] are not sound, and are thus prone to false negatives. These
approaches are susceptible to a variety of anti-debugging and anti-
monitoring defenses [ 15,24,26,35,43,56,58,59,62,67] as well as
timebombs [25],whichfurtherdecreasetheirefficacy.Furthermore,
dynamicapproachesaretediousandtimeconsuming,asexhaustive
execution of apps can take a substantial amount of time.
To overcome the limitation of pure static or pure dynamic anal-
ysis, Holla and Katti [ 39] discussed the need for hybrid Android
securityapproaches.Despitethat,fewapproachesproposedhybrid
techniques such as Dr. Android [ 41], SmartDroid [ 71], and Profile-
Droid [69]. Nevertheless, these tools provide detection capabilities
butnotpreventionmechanisms.Moreover,theyrequirechangesto
apps’ implementation logic which prevent their practical use.
AlloftheseapproachesperformcompleteanalysisofAndroid
systems,andhencelacktheabilitytoefficientlyanalyzesystemsas
changes occur—such as adding/removing apps, granting/revoking
permissions at runtime, or dynamically loading code. SALMA miti-
gatestheaforementionedshortcomingsthrough(1)continuously
monitoringtherunningsystem,(2)incrementallyandefficiently
727
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. Self-Protection of Android Systems from Inter-component Communication Attacks ASE ’18, September 3–7, 2018, Montpellier, France
analyzing the system against a broad-range of ICC security vulner-
abilities, and (3) enforcing adaptation tactics to prevent security
attacks at runtime with minimal disruption.
4 ILLUSTRATIVE EXAMPLE
Tofurthermotivateourresearchandillustrateourapproach,we
provide an example of an evolving Android system that consists
initially of two apps: SuperPhone and StayHealthy apps, illus-
tratedinFigure 1(a).The MakeCalls Activityinthe SuperPhone
allowsausertomakephonecallsanditstorescalls’informationinthe
CallsDB, a Content Provider component. The History queries
thestoredcallsin CallsDBandliststhemtoauser. StayHealthy
is a fitness app that allows users to log their daily workouts, via
Exercises ,andmeals,via Meals.BothoftheseActivitiesareacces-
siblefromthe HomeActivity.The LocTracker isaservicethatruns
in the background and tracks the user’s location upon receiving
an Intent. Exercises uses LocTracker to draw a route map of a
user’sworkout. StayHealthy alsoallowsausertosharehislogged
activities,eitherworkoutsormeals,withfriendsbysendingtextmessages. The
ShareService sends spatial data, i.e., tagged data
with the current user’s location, as a text message to the phone
number specified in the received Intent. Shareis being used by
both Exercises andMealsActivities.
TheShareServiceisavulnerableservicesinceitdoesnotcheck
if the calling component has the appropriate permissions, SMS
and Location in this example, before sending spatial data. Whereas
theLocTracker is a secure Service since it checks for the granted
permissions of the caller component. Such a check in Android can
be achieved using the checkCallingPermission API. Although
Shareis a vulnerable component in the Android system illustrated
in Figure 1(a), the current system is not actively threatened since
no component is exploiting this vulnerability.
At a later time, a user installs a new app called BrainTease
r, as shown in Figure 1(b).BrainTeaser is a malicious app that
challengesausertosolvemathematicalquestionsandthenmea-
suresherintelligencequotient(IQ).The IQtestActivitydisplays
questionsandcommunicateswiththe Qgenerator Servicetoget
thenextquestion. Qgenerator isamaliciouscomponentthat,once
started, communicates with the ShareService of the StayHealt
hyapp. Since Sharedoes not check if the caller components has
the required permissions, i.e., SMS and LOCATION permissions,
thiscomponentisvulnerabletoaprivilege-escalationICCattack.
Therefore,thecommunicationbetweenthe Qgenerator andShare
results in exploiting this vulnerability which allows Qgenerator
to leak the user’s location to any premium rate number without
having the proper permissions to perform such a task.
Theattackdescribedinthissectionisalegitimatescenariointhe
current implementation of the Android platform [ 19]. Moreover,
performingacompleteanalysisofallAndroidappsinthesystem
everytimethesystemchangesisneitherefficientnorpractical.We
showhow,througharuntimemonitoringandincrementalanalysis,
SALMA can efficiently and effectively mitigate such a threat.
5 APPROACH
Figure2depicts a high-level overview of SALMA—which contains
two layers, the protected layer and theprotecting layer. The pro-
tected layer consists of our modified Android framework and a set
of apps that a user installs on a device. The protecting layer real-
izestheIBMMAPE-Kcontrolloop[ 45].MAPE-Kconsistsoffour
componentsandaknowledgecomponent.The Knowledge contains
Figure 2: Overview of SALMA.
an architectural model of the system. The Monitorobserves the
systemandkeepsthemodelsynchronizedwiththerunningsystem.
TheAnalyzer assesses the system for security threats. The Planner
determinesthebestsecuritypolicies,a.k.a.adaptationtactics,tobe
enforced at runtime by the Executor.
Figure2depicts instantiations of each of the MAPE-K compo-
nentsintheprotectinglayer: MonitorExtractor&Synthesizer (MES),
whichisa Monitor;IncrementalSecurityAnalyzer (ISA),whichisan
Analyzer;PolicySynthesizer,whichisa Planner;andPolicyEnforcer,
whichisan Executor. MESautomaticallyobtainsandmaintainsa
preciseruntimearchitecturalmodelofanAndroidsystem.When
achangeoccursinthemaintainedruntimemodel,the ISA(1)de-
termines the impacted part of the system due to that change, (2)
runsasubsetofsecurityanalysesthatneedtobeperformed,and
(3) updates the security posture of the system by either adding
newpotentialsecurityattacksorremovingexistingthreats.After
that,Policy Synthesizer takes the analysis results computed by the
previouscomponentandconstructssecuritypoliciesintheform
ofEvent-Condition-Action(ECA)rules—whichthe PolicyEnforcer
enforces at runtime, through various effectors.
5.1 Model Extractor & Synchronizer (MES)
Similartootherself-*softwaresystems,SALMAleveragesanab-
stract representation of the software to manage and adapt the sys-
tematruntime.Priorresearchassumesthesemodelsaredeveloped
in advance. Given the rich app ecosystem of Android, this assump-
tion does not hold, since users can install a variety of apps that are
unknownapriori.Toaddressthischallenge, MESutilizesstaticand
dynamic analysis techniques to automatically obtain and maintain
a precise model of an Android system.
To obtain an architectural model of an Android system, MES
usesAPKtool[3], a reverse-engineering tool for Android APK files,
torecoveranapp’smanifestfile. MESthenparsesthefiletoextract
theapp’scomponents,theirproperties,theirprovidedinterfaces,
the required permissions, and the defined permissions, if any.
Parsingthemanifestfileisnotenoughtoobtainasystem’sar-
chitecture,sincealargeamountofinformationislatentintheapp’s
bytecode—including all ICCs, programmatically registered compo-
nents, or defined interfaces. ICC communications are facilitated
either by (1) sending Intents or (2) using URIs (see Section 2). To
obtainthisinformation, MESutilizesIC3[ 53],atoolthatextracts
Intentsand URIsalong withtheir informationfrom apps’bytecode.
MESdetermines the permissions enforced by components. In
Android, a component enforces permissions to either (1) protect
728
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Mahmoud Hammad, Joshua Garcia, and Sam Malek
Figure 1: An evolving Android system before, (a), and after, (b), installing BrainTeaser app.
access to the entire component or (2) restrict access to parts of the
component using permission checks in the code (e.g., use of the
checkCallingPermission API).MESextractsprotected accessof
components from the manifest file and restricted access to parts
of components from code. MESleverages prior work of architec-
tural modeling [ 63] to extract enforced permissions from an app’s
bytecode. Finally, MESdetermines permissions actually used by
components either to (1) access a protected Content Provider or
(2) call a protected API. To determine such permissions, regarding
to(1), werely on[ 38]that mapsa protected ContentProvider to
therequiredpermissiontoaccessthatContentProvider.Regarding
to(2),weleveragePScout[ 16]whichmapseachsensitiveAPIin
Android with the required permission to call that API.
MEScapturesthearchitectureofanAndroidsystemasa Multiple-
Domain-Matrix (MDM) [49], which is a matrix representation of all
relationshiptypes(i.e.,domains)amongprincipalelements,such
as components and permissions, in a system. An MDM consists of
multipleDesign-Structured Matrices (DSMs) [65]. Each domain is
modeled as a DSM—a simple matrix that captures the relationshipsofonetype.Forthepurposeofsecurityanalysis,SALMAmodelsan
Android system using seven domains, four component interaction
domains and three permission domains. As a concrete example,Figure3shows the derived MDM of the example illustrated in
Figure1(a).TokeeptheMDMvalidasthesystemchanges,MES
synchronizes the MDM with the running system.
The four component interaction domains in the MDM model of
Figure3representthevariouscomponent-to-componentcommuni-
cations. Each non-empty cell in these domains indicates that there
isacommunicationbetweentwocomponents,eitherbysendingIntents or using URIs to access the encapsulated data in Content
Providers. Rows representsender components; columns represent
receiver components. The explicitand theimplicitcommunication
domains show all component-to-component interactions using ex-
plicit and implicit Intents, respectively. Similarly, the data access
and the data manipulation domains show component-to-content
providerinteractionsforreading(i.e.,querying)andmodifying(i.e.,
updating, inserting, or deleting) stored data, respectively.
ThethreepermissiondomainsintheMDMmodelofFigure 3rep-
resentthevariouscomponent-to-permissionrelationships.Theper-
missionusagedomainshowsthatapermissionismakingprotected
API calls. The permission granteddomain shows that a permission
isgrantedtoacomponent Tbecauseitiseither(1)directlyusing
the permission; or (2) its parent app requests that permission, and
Tis interacting with another component that uses that permission.
The permission enforcement domain shows that a permission is
enforced by a component through its manifest file or in its code.ToderivetheMDMrepresentationofanAndroidsystem, MES
asynchronouslyinteractswiththe StaticAnalysisEngine (seeFig-
ure2), a cloud-based web service that leverages various static anal-
ysis tools [ 3,52,53,63] to extract a model of an Android system.
Once the Static Analysis Engine analyzes the requested app(s), it
returnsatuple S=(C,I,DBR,DBW ,P)totheMES.Inthetuple S,C
isasetofcomponents; IisasetofIntents; DBRisasetofdatabase
readaccesses; DBWisasetofdatabasewriterequests;and Pisa
setofpermissions.Usingthisextractedinformation(i.e.,tuple S),
andSALMA’sknowledgeoftheAndroidframeworkembodiedin
a set of definitions, formally presented below, it derives the MDM
representationofanAndroidsystem.The explicitcommunication
domain is derived using the following rule.
Definition 1 (Explicit Communication). Letc1andc2be two
arbitrarycomponentsinthesystem,i.e., {c1,c2}⊆C,ibeanIntent,
i.e.,i∈I. We say that c1can explicitly communicate with c2,i fiis
sentbyc1,i.e.,i.sender =c1,andc2isexplicitlyspecifiedintheIntent
ias a target component, i.e., i.tarдet =c2, and either both c1andc2
belongtothesameappor c1isgrantedthepermissionsenforcedby
c2:
communicate e(c1,c2)≡∃i∈I|i.sender =c1∧i.tarдet =
c2∧(appc1=appc2∨enforced c2⊆дrantedc1)
Theexplicitcommunication domain in Figure 3shows the re-
sultsofapplyingdefinition 1toallextractedIntents,i.e.,theset I.
According to definition 1, component 4 explicitly communicates
with component 5, since there is an explicit Intent sent by Hometo
Exercises (recall Figure 1(a)).
Similarly, the communications in the implicitcommunication
domain are derived using the following rule.
Definition 2 (Implicit Communication). Letc1andc2be two
arbitrarycomponentsinthesystem,i.e., {c1,c2}⊆C,ibeanIntent,
i.e.,i∈I.Wesaythat c1cancommunicatewith c2,ifiissentby c1,
i.e.,i.sender =c1,andc2isexportinganIntentFilterthatcanhandle
i, i.e.,match(i,c2.f), and either both c1andc2belong to the same
app orc1is granted the permissions enforced by c2:
communicate i(c1,c2)≡∃i∈I|i.sender =
c1∧match(i,c2.f)∧(appc2=appc1∨enforced c2⊆дrantedc1)
Thematch(i,c2.f)functioninDefinition 2performsIntentres-
olution [7] to check if there is an Intent Filter declared by c2that
can handle the Intent i. Theimplicitcommunication domain in
Figure3shows the results of applying Definition 2to all extracted
Intents,i.e.,theset I.AccordingtoDefinition 2,component5im-
plicitly communicates with component 7 since there is an implicit
Intent sent by Exercises in which LocTracker can handle (recall
Figure1(a)).
729
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. Self-Protection of Android Systems from Inter-component Communication Attacks ASE ’18, September 3–7, 2018, Montpellier, France
Figure 3: An MDM representation of the system illustrated in Figure 1(a). Each colored box in the MDM corresponds to the
matching colored app in Figure 1(a).
Thedataaccess andthedatamanipulation domainsarederived
using the following rules.
Definition3(DataAccess). Letcbeanarbitrarycomponentin
thesystem,i.e., c∈C,cpbeacontentprovider,i.e., cp∈C,anddbr
be a database read (query) request in the system, i.e., dbr∈DBR.W e
saythatccanaccessthestoreddatain cp,ifcsendsadatabasequery
(dbr)wheretheauthorityattributeof dbrmatchestheauthorityname
ofcp,andeither candcpbelongtothesameappor cisgrantedthe
enforced read access permission by cp.
access(c,cp)≡∃dbr∈DBR|dbr.sender =c∧dbr.authority =
cp.authority∧(appc=appcp∨readcp⊆дrantedc)
ToillustrateaninstanceofDefinition 3ontheextracteddatabase
requests,i.e., DBR,Figure1showsthatcomponent2accessesthe
stored data in component 3 —which is also reflected in Figure 3.
Definition 4 (Data Manipulation). Letcbe an arbitrary com-
ponent in the system, i.e., c∈C,cpbe a content provider, i.e., cp∈C,
anddbwbe a database write (insert, delete, or update) request in the
system, i.e., dbw∈DBW. We say that ccan access the stored data
incp,i fcsends a database manipulation request ( dbw) where the
authority attribute of dbwmatches the authority name of cp, and
eithercandcpbelong to the same app or cis granted the enforced
write access permission by cp.
manipulate (c,cp)≡∃dbw∈DBW|dbw.sender =
c∧dbw.authority =cp.authority∧(appc=appcp∨writecp⊆
дrantedc)
As an example of Definition 4, Figure 1depicts component 1,
MakesCall , updates the stored data in component 3, CallsDB—
which is further shown in Figure 3.
Table1shows a list of the events (i.e., changes in the system)
thatMEStracks.Inthispaper,werefertotheseeventsas significant
events. For each significant event, MESreceives a notification from
thesystemandupdatesthemodelaccordingly.Forexample,whena
userinstallsanewapp, MESreceivesasystemnotificationwiththe
ACTION_PACKAGE_ADDEDIntentaction.Inthiscase, MESob-
tainsthearchitectureofthenewapp,i.e., M=(C,I,DBR,DBW ,P),
from the Static Analysis Engine ; mergesMwithS; and applies Def-
initions1–4to add the new app to the current MDM. To avoid
substantial analysis time caused by running static analysis tools,Table 1: The Significant Events that SALMA Monitors.
ID Event ID Event
1 ADD_APP 5 NEW_IMPLICIT_COMM
2 REMOVE_APP 6 NEW_EXPLICIT_COMM
3 GRANT_PERMISSION 7 NEW_DATA_ACCESS
4 REVOKE_PERMISSION 8 NEW_DATA_MANIPULATION
theStatic Analysis Engine can analyze Android apps in advance
without waiting for a user to install an app.
In our running example, after a user installs the BrainTeaser
app(seeFigure 1(b)),MESupdatesthemaintainedmodel.TheMDM
illustratedinFigure 4displaystheresultsofmerging BrainTeaser
with the current MDM, presented in Figure 3. Figure 4shows that
IQtestexplicitlycommunicateswith Qgenerator ,whichimplic-
itly communicates with Share(see Figure 1(b)).
Tosynchronizethe runtimemodelwiththesystem, MESrelies
onreceivingsystemnotificationsfromthesensorsinFigure 2,indi-
catingsignificantchangesthatoccurinthesystem.Somesystem
notifications arealready implemented inthe Android framework,
such as ADD_APP andREMOVE_APP events. For these events, the
frameworksendsbroadcastIntentswith ACTION_PACKAGE_ADDED
andACTION_PACKAGE_REMOVED actions,respectively. Whileinall
othersignificantevents,seeTable 1,theframeworksilentlyexecutes
the event. Therefore, we have introduced new system-generatedbroadcast Intents to the Android platform. The new broadcasts
informMESofcertaineventswhenevertheyoccurinthesystem.
Eachsystem-generatedbroadcastIntentcontainsinformationaboutaparticularevent.Forexample,incaseausergrantsapermissionto
anapp,theframeworksendsa
GRANT_PERMISSION broadcastIntent
with the permission name and the application package name.
5.2 Incremental Security Analyzer (ISA)
Androidsystemsarehighlydynamicsoftwaresystems.Reanalyzing
the entire system every time a change occurs is neither efficient
norscalable.Therefore,ourapproachincrementallyanalyzesthe
system whenever a change in the system occurs. Our approach
leverages the fact that a change in the system (1) impacts only part
730
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Mahmoud Hammad, Joshua Garcia, and Sam Malek
Figure 4: An MDM representation of the system illustrated in Figure 1(b) . Each colored box in the MDM corresponds to the
matching colored app in Figure 1(b).
ofthesystemand(2)oftenrequiresrunningasubsetofthesecurity
analyses on the impacted part of the system. In Section 5.2.1,w e
describehowourapproachdeterminestheimpactedpartsofthe
systemafterachangeoccurs.Section 5.2.2describesthesecurity
rulesthatourapproachappliesontheimpactedpartsofthesystem
to detect the potential security attacks presented in Section 2.
5.2.1 Change Impact Analysis. This analysis consists of two
steps: (1) determining the impacted parts of the MDM and (2) iden-
tifyingthesubsetofthesecurityanalysisrules,formallyspecifiedin
Section5.2.2, that need to be considered. More specifically, in step
(1),ISAdeterminestheaffectedpartsofthesystembycalculating
ΔMDMe=MDMt2−MDMt1,wheret2isatimeafteranevent e
andt1 is a time before e.
Each cell in ΔMDMhas a value of either −1, 0, or 1.−1 means a
relationshipintheprevioussystemhasbeenremovedafter e,e.g.,e
istherevocationofapermission.0meansthereisnochangeinthat
relationshipbeforeandafter e.1indicatesthatanewrelationshipis
introduceddueto e.Forexample, emaybetheintroductionofanew
communication between two components appearing at runtime
due to installing a new app, updating an existing app, dynamically
loadedcode,orexecutionofobfuscatedcode.Fromtheaffectedrela-tionships, ISAdeterminestheimpacteddomains.Applying
ΔMDM
toourrunningsystem,describedinSection 1,revealsthatthecom-
municationsinrows9and10havebeenaddedtothesystemwhich
belong to the explicitand theimplicitcommunication domains.
Instep(2), ISAdeterminesthesubsetofthesecurityrulesthat
need to be considered in light of the affected domains. To that
end,ISAuses Table 2, which is a lookup table that maps each
Security Analysis with theInvolved Domains in thatanalysis. This
tablealsoshowsthesecurityanalysesthatneedtobeperformed
when a specific domain changes. For example, if the EXPLICIT
domainchanges,then ISAneedstoperformonly3securityanalyses
instead of all 6 analyses. In our running example where only the
explicitandtheimplicitdomainshavebeenchangedafterinstalling
BrainTeaser , Table2indicates that the security posture of the
system should be checked against the following security attacks:
Intent Spoofing, Unauthorized Intent Receipt, Privilege Escalation,
andIdentical Custom Permission.Table 2: Security analyses lookup table.
Security Analysis Involved Domain(s)
Intent Spoofing Explicit Implicit
Unauthorized Intent Receipt Implicit
Privilege EscalationExplicit Implicit
Granted Usage
Enforcement
Identical Custom PermissionExplicit Implicit
Granted Enforcement
Passive Data Leak Data Access Read Permission
Content Pollution Data Manipulation Write Permission
5.2.2 Security Rules. Thissectiondescribesthesecurityrules
thatSALMAappliesontheimpactedpartsofthesystem.Eachrule
whenappliedonaninteractionbetweentwocomponentswould
reveal if that interaction is vulnerable to a given security attack.
SecurityRule1(UnauthorizedIntentReceipt). Letcmbe
amaliciouscomponent, cvbeavulnerablecomponent,and cxbea
componentthat cvintendstosendanimplicitIntent ito.cvandcx
belong to the same app, and cxdeclares a provided interface, i.e., an
Intent filter, through which cvaims to communicate with cxusing
i. In an unauthorized Intent receipt, cmcan intercept ifromcvby
declaringaprovidedinterfacesimilartotheonedeclaredby cx.A s
such,cmmaygainaccesstoallencloseddatainanymatchingIntents
meant to be received by cx.
∃communicate i(cv,cm)|(appcv/nequal
appcm)∧∃communicate i(cv,cx)∧(appcv=appcx)
Security Rule 2 (Intent Spoofing). Letcmbe a malicious
component, cvbe a vulnerable component, and cxbe a component
intendingtocommunicatewith cv.cvandcxbelongtothesameapp.
cvdeclaresaprovidedinterface,i.e.,anIntentfilter,throughwhich
itaimstocommunicatewith cx.InIntentSpoofing, cmcansendan
Intent tocvover the Intent filter and force cvto perform a nefarious
action upon receipt of the Intent.
∃(communicate e(cm,cv)∨communicate i(cm,cv))|(appcv/nequal
appcm)∧∃communicate i(cx,cv)∧(appcv=appcx)
731
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. Self-Protection of Android Systems from Inter-component Communication Attacks ASE ’18, September 3–7, 2018, Montpellier, France
SecurityRule3(PrivilegeEscalation). Letpbeapermission,
cmbe a malicious component that is not granted p, andcvbe a
vulnerable component that is granted and uses pbut does not enforce
the use of pas requested by other components. In privilege escalation,
cmis able to indirectly obtain pby interacting with cv.
∃(communicate e(cm,cv)∨communicate i(cm,cv))|p∈
used(cv)∧p/nelementдranted(cm)∧p/nelementenforced (cv)
Security Rule 4 (Identical Custom Permission). Letpmbea
custompermissiondefinedbymaliciousapp appm,i.e.,pm.definedBy =
appm, andpvbe a custom permission defined by the vulnerable app
appv, i.e.,pv.definedBy =appv. Bothpvandpmhave the same
permissionname,i.e., pv.name =pm.name.cmisamaliciouscom-
ponent in appmthat is granted pm.cvis a vulnerable component
inappvthatenforces pv.Inanidenticalcustompermission, cmcan
communicate with cvsincepv.name =pm.name,e v e ni fpvandpm
are semantically different permissions.
∃(communicate e(cm,cv)∨communicate i(cm,cv)∨
access(cm,cv)∨manipulate (cm,cv))|appcm/nequalappcv∧pm∈
дranted(cm)∧pv∈enforced (cv)∧pv.name =
pm.name∧pm.definedBy /nequalpv.definedBy
Security Rule 5(Passive Data Leak). Letcpvbe a vulnerable
Content Provider that does not enforce a read access permission,
cmbeamaliciouscomponentthataccesses(queries)thestoreddata
incpv. In a passive data leak, cmcan passively disclose the sensitive
data stored in cpv.
∃access(cm,cpv)|enforcer(cpv)=∅
InDefinition 5,enforcer(cpv)referstothereadaccesspermis-
sion enforced by the Content Provider cpv. In our approach, for
each Content Provider component,weaddtwocolumnsinthe
permissiondomainsoftheMDM:oneforthereadaccesspermis-
sionandtheotheroneforthewriteaccesspermission.Forexample,
each permission domain in the MDM illustrated in Figure 4con-
tainstwopermissionsforthe CallsDBcomponent, C3Rfortheread
permission and C3Wfor the write permission.
SecurityRule6(ContentPollution). Letcpvbeavulnerable
Content Provider thatdoesnotenforceawriteaccesspermission,
cmbeamaliciouscomponentthatchanges(inserts,updates,ordeletes)
thestoreddatain cpv.Inthecontentpollutionattack, cmcaninap-
propriately manipulate the sensitive data stored in cpv.
∃manipulate (cm,cpv)|enforcew(cpv)=∅
InDefinition 6,enforcew(cpv)referstothewriteaccesspermis-
sion enforced by the Content Provider cpv.
Regarding our example, SALMA determines that the security
rules1,2,3, and4should be applied to all interactions in rows
and columns 9 and 10. Running these rules, mainly rule 3on the
communicationbetween Qgenerator andShare,revealsthatthe
implicit communication in row 10 and column 8 of Figure 4is
vulnerable to privilege escalation attack.
5.3 Policy Synthesizer and Policy Enforcer
AfterISAdetermines the security vulnerabilities in the system,
thePolicySynthesizer createscontext-sensitive securitypoliciesto
be executed at runtime. The created security policies, in our ap-
proach,followtheEvent-Condition-Action(ECA) rulesparadigm
suitable for rapid evaluation as the system executes. Our approach
createsECArulesthat,basedonaparticularsystemcontext,will
be executed to prevent security threats. More specifically, SALMAcreates ECA rules to prevent the communication between the two
componentsthatareinvolvedinanidentifiedsecurityvulnerability.
SALMAfurthertriestominimizethedisruptionthatthesecurity
policiesmaycause.Forexample,inthecaseofaprivilegeescalation
attack, SALMA creates a security policy to prevent a vulnerable
communication instead of revoking the escalated permission from
the vulnerable app, as proposed in [ 60]. The later solution disrupts
allcomponentsinthevulnerableappfromusingthatpermission
which may stop crucial services provided by the disrupted compo-
nents such as sending text messages or getting driving directions.
As a concrete example, since the communication between Qgen-
erator and Shareis marked as potential privilege escalation attack,
SALMA creates the following ECA rule.
Event:i∈ICCoccurs
Condition: i.senderPkд =BrainTeaser∧i.senderComp =
Qgenerator∧i.receiverPkд =StayHealthy∧i.receiverComp =
Share
Action:prevent
Policy Enforcer administers security policies at runtime through
various effectors that we have added to the Android runtime en-
vironment, as shown in Figure 2.Policy Enforcer applies security
policies by intercepting the ICCs (both the Intent-based and the
URI-basedcommunications)andtheresourceaccesstransactionsto
check if theyare allowed or not. ForIntent-based communication,
PolicyEnforcer canpreventorallowtransactions.FortheURI-based
ICC transactions, Policy Enforcer can prevent a component from
accessing or manipulating either (1) the entire Content Provider
specified in the URI or (2) a specific table or file in that Content
Provider.
6 IMPLEMENTATION
We have implemented SALMA and its constituent components for
our experiments and make it available online for reproducibility
and reuse purposes [ 11]. To keep an Android system’s architecture
synchronizedwiththerunningsystem,the StaticAnalysisEngine
is implemented as a cloud-based web service that leverages several
prior static analysis tools [ 3,16,52,53,63]. Each tool provides
specific information that SALMA uses to tailor the architecture of
the system.
MES,Policy Synthesizer, and Policy Enforcer are implemented
on top of the Android Open-Source Project (AOSP) [ 2] version 6
(Marshmallow),APIlevel23.AOSPistheopen-sourcerepositoryfor
theAndroidsystem.Theenforcementmechanismintroducedanew
package in the Android runtime environment. We also modified
other components such as ActivityManager, ContextWrapper, Con-
tentProvider, and PackageManager. The total framework changes
accountforapproximately600LOC.Thesechangesallowanyex-
istingAndroidapp usingversion6and belowtorun inourversion
of the Android runtime environment without modification. We
havesuccessfullyinstalledthemodifiedAndroidsystemimageona
Nexus 5X phone and an Android emulator using Android Fastboot
tools [5] and Android debug bridge [1].
7 EXPERIMENTAL EVALUATION
Our evaluation addresses the following research questions:
RQ1.How efficient is SALMA at incrementally analyzing the secu-
ritypostureofAndroidsystemscomparedtoacompleteanalysis
approach?
732
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Mahmoud Hammad, Joshua Garcia, and Sam Malek
RQ2How effective is SALMA at reducing the unnecessary dis-
ruptioncausedbytheenforcementofsecuritypoliciestoprevent
permission-induced ICC attacks?
RQ3.HoweffectiveisSALMAatdetectingandpreventingsecurity
attacks in real-world apps?
7.1 RQ1: Efficiency
For this experiment, we downloaded 984 apps comprising three
datasets: a dataset of 370 benign apps, randomly selected from
Google Play [ 6];a dataset of 389 vulnerable apps identified in prior
literature[ 48];andadatasetof225maliciousappsobtainedfrom
various malware repositories [4, 51,72].
To measure the efficiency of SALMA’s incremental analysis, we
compared the performance of SALMA with DELDroid [ 37,38],
a prior approach that similar to our work analyzes the architec-
ture of an Android system for ICC vulnerabilities and enforces the
determinedarchitectureatruntime.However,unlikeSALMA,DEL-
Droid is not capable of continuous monitoring and incremental
analysisofanevolvingAndroidsystem.Weranourexperiments
on a MacBook Pro with 2.2 GHz Intel Core i7 processor and 16 GB
1600MHzDDR3RAM.Werepeatedourexperiments10timesto
achieve a 95% confidence interval.
Figure5contains box-and-whisker plots comparing the analysis
timeofeachapproachasAndroidappsareaddedtothesystem.We
startedwithanAndroidsystemof120appsandaddedoneappatatimeuntilthesystemcontained150apps.Werandomlyselected120
apps from the benign dataset, 15 apps from the vulnerable dataset,
and 15 apps from the malicious dataset.
Everytimeanappisaddedtothesystem,SALMAincrementally
analyzes the system whereasDELDroid reanalyzes the entiresys-
tem.Asillustratedin Figure 5,theanalysistimeof SALMAtakes,
on average, 2 seconds to incrementally analyze an Android system
whenever a new app is installed. On the other hand, DELDroid
takes, on average, 75 seconds.
Figure5:Theanalysistimeof SALMAandDELDroidasAn-
droid apps are added to the system.
Figure6compares the analysis time of each approach with a
decreasingnumberofapps.Westartedwithabundleof150apps,
then we removed one app at a time until the system contained 120
apps.Theaverageanalysistimeof SALMAis0.2secondswhilethe
averageanalysistimeof DELDroidis35.3seconds.Duetospace
limitations, Figures 5and6show the analysis results of adding/re-
moving30apps,however,theproject’swebsite[ 11]containsthe
analysis results of an experiment of adding/removing 80 apps.
Due to the use of code obfuscation and dynamic class loading
inAndroidapps,notallcommunicationscanbediscoveredusing
Figure6:Theanalysistimeof SALMAandDELDroidasAn-droid apps are removed from the system.
staticanalysistools.Asaresult,somecommunicationappearsonly
at runtime, e.g., a new explicit or implicit communication. In such
scenarios,SALMAalsoincrementallyreanalyzesthesecuritypos-
tureofthesystemtodetermineifthenewcommunicationposes
any threat to the system. If so, SALMA prevents the new com-
munication. In addition to ADD_APPandREMOVE_APP , we assessed
the efficiency of SALMA with respect to other system events men-
tionedinTable 1.WefoundthatSALMAtakes,onaverageacrossall
events, 1.6 milliseconds while DELDroid takes, on average across
all events, 63.8 seconds. Due to space limitations, details of this
experiment and the evaluation results are reported at the project’s
website [11].
SALMA takes about two hours to statically analyze an Android
systemwith50appsanddetermineitsinitialarchitecturalrepre-
sentation.Thereafter, SALMAincrementallydetermines thearchi-
tectureoftherunningsystem.Table 3showstheperformanceof
SALMA in statically analyzing apps, merging/removing an appto/from the architectural model, and intercepting and checking
anICCtransactionagainstthestoredsecuritypolicies.Tofurther
improve efficiency, the static analysis time can be performed in ad-
vanced without waiting for a user to install an app. All other times
in Table3cannot be perceived as delays by users, which follows
recommendations from Android development guidelines [8].
Table 3: SALMA’s static analysis and runtime performance.
Static Merge app Remove app Validating
analysis to the model from the model ICC trans.
(minute) (second) (second) (second)
Average 2.3 0.024 0.026 0.025
Std Dev. 1.2 0.027 0.028 0.001
Overall, these results corroborate the efficiency and the scalabil-
ity of SALMA in incrementally analyzing Android systems.
7.2 RQ2: Disruption
Enforcing security policies at runtime by preventing permissio
n-induced ICC attacks may disrupt benign behaviors of an app.
Permission-inducedattacksaresecuritybreachesenabledbyper-
missionmisuse,i.e.,privilegeescalation,identicalcustompermis-
sions,contentpollution,andpassivedataleaks.Preventingpermission-
induced attacks can be applied at install-time or runtime [ 32].
733
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. Self-Protection of Android Systems from Inter-component Communication Attacks ASE ’18, September 3–7, 2018, Montpellier, France
Install-time approaches, such as Kirin [ 31], prevent the installa-
tion of vulnerable apps. Runtime prevention approaches can ei-
ther (1) prevent only the malicious communication whenever it
occurs,asperformedin SALMA,DELDroid[ 38],SEALANT[ 47],
and SEPAR [ 20]; or (2) revoke permissions of vulnerable apps at
runtime, as in TERMINATOR [60] and AppGuard [17].
For this experiment, we analyzed a bundle of 150 apps, the apps
used in RQ1, and found that 40 apps are vulnerable to various
permission-inducedattacks.Wethencomputedthe disruption in
eachvulnerableappcausedbytheenforcementofthevariousse-
curity policy mechanisms discussed earlier. Disruption of an app a
is computed using the following equation:
disruption (a)=|compsdisr(a)|
|compstot(a)|×100
Wherecompsdisr(a)is the set of components in app athat are
disruptedand compstot(a)arethesetofallcomponentsinapp a.
We consider a component cto be disrupted if cuses a permission p
involvedinapermission-inducedattack,since cwillbeunableto
provide its full services if pis revoked.
As an example, consider an app avwith 5 components where 3
ofitscomponentsusepermission ptoprovidetheirservices.One
component using pis vulnerable to a privilege-escalation attack.
In this case, to protect the user, the install-time approaches pre-
vent the installation of av, disrupting all of its components, i.e.,
disruption (av)=100%.Ontheotherhand,approachesthatrevoke
permission will revoke pto prevent the attack, resulting in 60%
disruptionofthatapp,i.e.,3componentswillnotbeabletoprovide
theirfullservicesduetothelackoftherequiredpermission p.How-
ever,SALMA,whichonlypreventsmaliciouscommunicationwhen
itoccurs,resultsin0%disruption,sinceallcomponentswillbeable
to provide their full services while keeping the system protected.
Figure7comparesthethreedifferentpermission-inducedpre-
vention mechanisms. The diagram shows that SALMA has 0.4%
disruption,meaningthatSALMAdoesnotdisturbcomponentsfrom
providing their services except in one identical custom permission
case. In that case, SALMA created a security policy to revoke acustom permission from the malicious app so it will not be able
to access the vulnerable app. On the other hand, the install-time
approachperformstheworst(100%),asitdoesnotallowinstalla-
tion of avulnerable app. Finally, revoking permissions atruntime
to prevent permission-induced attacks would result, on average
per app, in 32% disruption. Meaning that, on average, 32% of thecomponents in a vulnerable app will not be able to provide their
fullservicesduetothelackofrequiredpermissionseventhough
some of these components are not vulnerable or involved in any
Figure 7: Disruption results for each appvulnerability. Moreover, revoking permissions from apps at run-
time lead to crashes or unexpected behaviors due to inappropriate
handling of dynamic permissions in Android [61].
DELDroid,SEPAR,SEALANT,andSALMAallattempttopre-
ventmaliciouscommunicationwheneveritoccurs.However,unlike
SALMA, the other three approaches assume that all permissions
aregrantedtoallappsindefinitely.Thisassumptionincreasesthose
approaches false positives which, in turn, increases unnecessary
disruption. For example, a privilege-escalation vulnerability is not
exploitable unless the escalated permission is granted to the vul-
nerable app. Howev er, the three appr oaches prevent vulnerable
communication at all times, while SALMA prevents vulnerable
communicationonlywhenthesystemisatrisk,i.e.,thepermission
is granted to the vulnerable app.
7.3 RQ3: Attack Detection and Prevention
To evaluate SALMA’s ability to detect and prevent security threats,
we conducted a thorough evaluation using malicious and vulnera-
blereal-worldappswithknownsecurityattacks,andcomparedthe
detectionandpreventionresultsof SALMAwithstate-of-the-art
approaches. We included state-of-the-art approaches that are (1)publically available, (2) provide detection and prevention mech-
anisms, and (3) extend the Android framework. To that end, we
includedDELDroid[ 37,38],SEPAR[ 20],andSEALANT[ 47].DEL-
Droid determines the least-privilege architecture of an Androidsystem and enforces it at runtime. SEPAR provides an automatic
schemeforformalsynthesisandenforcementofAndroidICCsecu-
rity policies. SEALANT is a technique that combine static analysis
withdynamicmonitoringtodetectsecurityvulnerabilitiesinAn-
droid apps and prevent ICC attacks.
Toconductthisexperiment,weused 188 maliciousandvulner-
able apps for which the steps and inputs required to create the
attackswereknownanddocumented.Theseappshavebeenused
intheevaluationoftheincludedapproaches.Intotal,thesubject
appscontain94ICCattackswhere45ofthemarehiddenattacks,
i.e.,themaliciouscodeisnotpartoftheapps’bytescodebutinstead
is loaded at runtime using the dynamic class loading feature as
describedin[ 57],andtherest(49attacks)arenothiddenattacks,
i.e.,themaliciouscodeispartoftheapps’bytecode.Weraneachap-
proachonthesubjectapps,thendeployedtheappsontheAndroid
environment,andmanuallyexercisedallknownattacks.Wereport
the number of detected and prevented attacks for each approach.
TheAttack Detection column in Table 4show the evaluation
results of each approach for detecting the security attacks. For
example, SALMA and DELDroid detected all of the 20 privilege-
escalationinstancesthatarenotdynamicallyloaded,i.e.,nothidden
attacks, whereas SEPAR and SEALANT detected only 12 and 14
attacks,respectively.AccordingtoTable 4,SALMAisabletodetect
all 94 attacks, including the hidden attacks, with no false positives
or false negatives, while the detection rate of the other approaches
ranges from 16% to 30%. Given the reliance of the included ap-
proachesonstaticprogramanalysistodetectsecurityrisks,allof
them are unable to detect hidden attacks launched via dynamically
loadedcode,seethegrayareainTable 4.However,sinceSALMAin-
crementallyanalyzesthesecuritypostureofthesysteminresponse
to system changes, i.e., new inter-app communications added at
runtime (recall Section 7.1), SALMA is able to detect these attacks
at runtime.
TheAttackPrevention columninTable 4showstheevaluationre-
sultsofeachapproachforthwartingthesecurityattacksatruntime.
734
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Mahmoud Hammad, Joshua Garcia, and Sam Malek
Table 4: The ability of SALMA in detecting and preventing security attacks compared to the state-of-the-art approaches.
Attack TypeSecurity Attack # AttacksAttack Detection Attack Prevention
(Count) DELDroid SEPAR SEALANT SAlMA DELDroid SEPAR SEALANT SAlMANot hidden (49)Intent Spoofing 3 3 3 2 3 3 3 2 3
Unauthorized Intent Receipt 5 5 0 1 5 5 0 1 5
Privilege Escalation 20 20 12 14 20 20 12 14 20
Identical Custom Permission 7 0 0 1 7 0 0 1 7
Content Pollution 7 0 0 0 7 0 0 0 7
Passive Data Leak 7 0 0 0 7 0 0 0 7Hidden (45)Intent Spoofing 13 0 0 0 13 13 0 0 13
Unauthorized Intent Receipt 2 0 0 0 2 2 0 0 2
Privilege Escalation 9 0 0 0 9 9 0 0 9
Identical Custom Permission 7 0 0 0 7 0 0 0 7
Content Pollution 7 0 0 0 7 0 0 0 7
Passive Data Leak 7 0 0 0 7 0 0 0 7
Total attacks 94 28 15 18 94 52 15 18 94
Detection / Prevention Rate 30% 16% 19% 100% 55% 16% 19% 100%
SALMA is able to prevent all security attacks in Table 4at runtime
while the prev ention rate of the other approaches ranges from 15%
to 55%. Interestingly, DELDroid is able to prevent some of the ICC
attacksthatitdidnotdetect,becauseitpreventsallcommunications
that are not part of the statically determined architecture.
8 RELATED WORK
AttackDetection. Numerousstaticanalysisapproacheshavebeen
proposed in the literature for detecting ICC attacks in Android
systems [ 48],[68],[46],[50],[19],[70],[23], and [54]. COVERT [ 19]
presents an approach for compositional analysis of Android inter-
appvulnerabilities.DidFail[ 46]tracksdataflowsbetweenAndroid
components. Similarly, IccTA [ 48] leverages an Intent resolution
analysis to identify inter-component privacy leaks. Unlike SALMA,alloftheseapproachescannotdetectICCattacksconductedthrough
dynamic class loading.
Attack Prevention. DELDroid [ 37,38] is an approach that de-
termines the least-privilege architecture of an Android system and
enforces it at runtime. Similar to SALMA, DELDroid analyzes the
architecture of an Android system for ICC vulnerabilities and mod-
ifiestheAndroidplatformtoenforcethedeterminedarchitecture.
UnlikeSALMA,DELDroidisadesign-timesolutionthat(1)does
notchangethederivedarchitectureasthesystemevolves;(2)as-
sumes that all permissions are granted to apps indefinitely, which
increasesdisruption;and(3)assumesthatallhiddencommunica-
tions are malicious, which further contributes to disruption.
Otherapproaches,suchas[ 32],[31],[20],[47],and[60],statically
analyze Android apps and dynamically enforce security policies to
preventICCattacks.IPC-Inspection[ 32]isanOSmechanismfor
preventingprivilege-escalationattacksthatreducesthepermissionsassignedtoanappwhenitcommunicateswithanapphavingfewer
privileges.Kirin[
31]detectssecurityvulnerabilitiesbyonlyanalyz-
inganapp’sconfigurationfile.SEPAR[ 20]andSEALANT[ 47]rely
on the analysis results generated by COVERT [ 19] to prevent ICC
attacks at runtime. TERMINATOR [ 60] performs temporal analysis
forpreventingpermission-inducedICCattacks.Allofthesetools
do not update their models once the system changes.
Anothersetofapproachesleveragedynamicanalysistechniques
todetectandpreventsecurityattacks [ 21,27,40,55].AppFence[ 40]
preventsappsfromexfiltrationofdataoutsidethedevice.Quire[ 27]prevents privilege-escalation attacks from leaking data outside the
deviceusingtheInternetpermission.Saint[ 55]extendsthefunc-
tionalityofKirintoallowforinstall-timepermissionassignment
andtheirrun-timeuseasspecifiedinthepoliciesprovidedbyan
app’s developer. XManDroid [ 21] presents a solution for privilege-
escalationattacksbyrestrictingcommunicationatruntimebetween
applications that could lead to dangerous information flows. While
SALMA automatically analyzes the system and creates security
policiestopreventICCattacks,allofthesetoolsdependupondefin-
ing securitypolicies bydevelopers and theyrequire modifications
to apps’ implementation logic.
9 CONCLUSION
ThispaperpresentsSALMA,anautomatedself-protectingAndroid
system that monitors itself and adapts its behavior at runtime to
prevent ICC security risks. SALMA maintains a precise runtime
model, represented as a Multiple-Domain-Matrix (MDM), and incre-
mentallyandefficientlyanalyzesanAndroidsysteminresponseto
incrementalsystemchanges.Themaintainedarchitectureisused
toreasonabouttherunningAndroidsystem.Everytimethesystem
changes,SALMAdetermines(1)theimpactedpartofthesystem,
and(2)thesubsetofthesecurityanalysesthatneedtobeperformed,
therebygreatlyimprovingtheperformanceoftheapproach.Ourexperimentalresultsonhundredsofreal-worldappscorroborate
SALMA’s efficiency and scalability with minimal disruption.
Android components are increasingly shipped with native bi-
nariesthatareshowntohavememory-basedvulnerabilities(e.g.,
buffer overflow) [ 14]. Modeling native code in MDMs, building
associatedsecurityrulesfornative-codevulnerabilities,andmodel-
ing the interaction among managed and native code in MDMs can
provide further attack detection and prevention, but complicate
analyses and may lead to scalability issues. Such challenges are
interesting avenues of future work.
10 ACKNOWLEDGMENT
WethankHamidBagheriforhiscontributionstothiswork.This
work was supported in part by awards CCF-1252644, CNS-1629771,
and CCF-1618132 from the National Science Foundation, HSHQDC
-14-C-B0040 from the Department of Homeland Security, and FA95
501610030 from the Air Force Office of Scientific Research.
735
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. Self-Protection of Android Systems from Inter-component Communication Attacks ASE ’18, September 3–7, 2018, Montpellier, France
REFERENCES
[1]Android debug bridge. https://developer.android.com/studio/command-line/adb.
html, Accessed February 2018.
[2]Androidopensourceproject. https://source.android.com/ ,AccessedFebruary
2018.
[3] Apktool. https://ibotpeaches.github.io/Apktool/, Accessed February 2018.
[4]Contagio malware repository. http://contagiodump.blogspot.it, Accessed Febru-
ary 2018.
[5]Fastboot. https://source.android.com/source/running.html,AccessedFebruary
2018.
[6] Google play. https://play.google.com/store?hl=en, Accessed February 2018.
[7]Intent resolution. https://developer.android.com/guide/components/intents-
filters.html, Accessed February 2018.
[8]Keepingyourappresponsive. https://developer.android.com/training/articles/
perf-anr.html, Accessed February 2018.
[9]Nokiathreatintelligencereport. https://onestore.nokia.com/asset/200492/Nokia_
Threat_Intelligence_1H2016_Report_EN.pdf , Accessed February 2018.
[10]Number of available apps in the google play store. https://www.statista.com/
statistics/266210/number-of-available-applications-in-the-google-play-store/ ,
Accessed February 2018.
[11]Salma:Self-protectionofandroidsystemsfrominter-componentcommunication
attacks. https://www.ics.uci.edu/ seal/projects/salma/index.html, July 2018.
[12]Smartphoneosmarketshare,2017q1. http://www.idc.com/prodserv/smartphone-
os-market-share.jsp, Accessed February 2018.
[13]Somanyapps,somuchmoretimeforentertainment. http://www.nielsen.com/us/
en/insights/news/2015/so-many-apps-so-much-more-time-for-entertainment.
html, Accessed February 2018.
[14]B.Aloraini andM.Nagappan. Evaluatingstate-of-the-artfree andopensource
staticanalysistoolsagainstbuffererrorsinandroidapps. In SoftwareMaintenance
andEvolution(ICSME),2017IEEEInternationalConferenceon,pages295–306.IEEE,
2017.
[15]S.Arzt,K.Falzon,A.Follner,S.Rasthofer,E.Bodden,andV.Stolz. Howusefulare
existingmonitoringlanguagesforsecuringandroidapps? In SoftwareEngineering
(Workshops), pages 107–122. Citeseer, 2013.
[16]K. W. Y. Au, Y. F. Zhou, Z. Huang, and D. Lie. Pscout: analyzing the androidpermission specification. In ACM CCS , pages 217–228, Raleigh, NC, October
2012.
[17]M. Backes, S. Gerling, C. Hammer, M. Maffei, and P. von Styp-Rekowsky.
Appguard–enforcinguserrequirementsonandroidapps. In InternationalConfer-
ence on Tools and Algorithms for the Construction and Analysis ofSystems, pages
543–548. Springer, 2013.
[18]H. Bagheri, E. Kang, S. Malek, and D. Jackson. Detection of design flaws in
the android permission protocol through bounded verification. In International
Symposium on Formal Methods, pages 73–89, Oslo, Norway, June 2015. Springer.
[19]H.Bagheri,A.Sadeghi,J.Garcia,andS.Malek. Covert:Compositionalanalysisof
androidinter-apppermissionleakage. IEEETransactionsonSoftwareEngineering,
41(9):866–886, September 2015.
[20]H. Bagheri, A. Sadeghi, R. Jabbarvand, and S. Malek. Practical, formal synthesis
and automatic enforcement of security policies for android. In Int’l Conf. on
Dependable Systems and Networks (DSN), pages 514–525, Toulouse, France, June
2016. IEEE.
[21]S. Bugiel, L. Davi, A. Dmitrienko, T. Fischer, and A.-R. Sadeghi. Xmandroid:
A new android evolution to mitigate privilege escalation attacks. Technische
Universität Darmstadt, Technical Report TR-2011-04, 2011.
[22]S.Bugiel,L.Davi,A.Dmitrienko,T.Fischer,A.-R.Sadeghi,andB.Shastry. To-
wards taming privilege-escalation attacks on android. In NDSS, volume 17,
page 19. Citeseer, 2012.
[23]E.Chin,A.P.Felt,K.Greenwood,andD.Wagner. Analyzinginter-application
communication in android. In International Conference on Mobile Systems, Appli-
cations, and Services, pages 239–252, Bethesda, Maryland, June 2011. ACM.
[24]H.Cho,J.Lim,H.Kim,andJ.H.Yi. Anti-debuggingschemeforprotectingmobile
apps on android platform. The Journal of Supercomputing, 72(1):232–246, 2016.
[25]K. Coogan, S. Debray, T. Kaochar, and G. Townsend. Automatic static unpacking
of malware binaries. In Working Conference on Reverse Engineering, Washington,
DC, October 2009. IEEE.
[26]A. Danielescu. Anti-debugging and anti-emulation techniques. CodeBreakers
Journal, 5(1), 2008.
[27]M.Dietz,S.Shekhar,Y.Pisetsky,A.Shu,andD.S.Wallach. Quire:Lightweight
provenance for smart phone operating systems. In USENIX Security Symposium,
volume 31, page 3, 2011.
[28]A. Egners, U. Meyer, and B. Marschollek. Messing with Android’s permission
model. In Int’l Conf.on Trust,Security and Privacyin Computingand Communi-
cations, pages 505–514, Liverpool, United Kingdom, June 2012. IEEE.
[29]K. O. Elish, D. Yao, and B. G. Ryder. On the need of precise inter-app icc classifi-
cationfordetectingandroidmalwarecollusions. In ProceedingsofIEEEmobile
security technologies (MoST), in conjunction with the IEEE symposium on security
and privacy, 2015.
[30]W.Enck,P.Gilbert,S.Han,V.Tendulkar,B.-G.Chun,L.P.Cox,J.Jung,P.Mc-
Daniel, and A. N. Sheth. Taintdroid: an information-flow tracking system for
realtimeprivacymonitoringonsmartphones. ACMTransactionsonComputer
Systems (TOCS), 32(2):5, 2014.
[31]W.Enck,M.Ongtang,andP.McDaniel. Onlightweightmobilephoneapplica-
tion certification. In Proceedings of the 16th ACM conference on Computer andcommunications security, pages 235–245, Chicago, Illinois, November 2009. ACM.
[32]Z. Fang, W. Han, and Y. Li. Permission based Android security: Issues and
countermeasures. Computers & Security, 43:205–218, June 2014.
[33]A. P. Felt, E. Chin, S. Hanna, D. Song, and D. Wagner. Android permissions
demystified. In ACM conference on Computer and communications security, pages
627–638. ACM, 2011.
[34]A. P. Felt, H. J. Wang, A. Moshchuk, S. Hanna, and E. Chin. Permission re-delegation: Attacks and defenses. In USENIX Security Symposium, volume 30,
page 88, San Francisco, California, August 2011.
[35]M. N. Gagnon, S. Taylor, and A. K. Ghosh. Software protection through anti-
debugging. IEEE Security & Privacy, 5(3), 2007.
[36]J.Garcia,M.Hammad,N.Ghorbani,andS.Malek. Automaticgenerationofinter-
componentcommunicationexploitsforandroidapplications. In Proceedingsof
the201711thJointMeetingonFoundationsofSoftwareEngineering ,pages661–671.
ACM, 2017.
[37]M.Hammad,H.Bagheri,andS.Malek. DELDroid:Determinationandenforce-
ment of least-privilege architecture in android. Institute for Software Research,
University of California, Irvine. UCI-ISR-18-2.
[38]M. Hammad, H. Bagheri, and S. Malek. Determination and enforcement of least-
privilegearchitectureinandroid. In IEEEInternationalConferenceonSoftware
Architecture (ICSA), pages 59–68, Gothenburg, Sweden, April 2017. IEEE.
[39]S. Holla and M. M. Katti. Android based mobile application development and its
security. International Journal of Computer Trends and Technology , 3(3):486–490,
2012.
[40]P. Hornyack, S. Han, J. Jung, S. Schechter, and D. Wetherall. These aren’t thedroids you’re looking for: retrofitting android to protect data from imperious
applications. In Proceedings of the 18th ACM conference on Computer and commu-
nications security, pages 639–652. ACM, 2011.
[41]J. Jeon, K. K. Micinski, J. A. Vaughan, A. Fogel, N. Reddy, J. S. Foster, and T. Mill-
stein. Dr. android and mr. hide: fine-grained permissions in android applications.
InProceedingsofthesecondACMworkshoponSecurityandprivacyinsmartphones
and mobile devices, pages 3–14. ACM, 2012.
[42]Y. Z. X. Jiang and Z. Xuxian. Detecting passive content leaks and pollution in
androidapplications. In Proceedingsofthe20thNetworkandDistributedSystem
Security Symposium (NDSS), San Diego, CA, February 2013.
[43]Y. Jing, Z. Zhao, G.-J. Ahn, and H. Hu. Morpheus: automatically generating
heuristicstodetectandroidemulators. In Proceedingsofthe30thAnnualComputer
Security Applications Conference, pages 216–225. ACM, 2014.
[44]D.Kantola,E.Chin,W.He,andD.Wagner. Reducingattacksurfacesforintra-
applicationcommunicationinandroid.In ProceedingsofthesecondACMworkshop
on Security and privacy in smartphones and mobile devices, pages 69–80. ACM,
2012.
[45]J.O.KephartandD.M.Chess. Thevisionofautonomiccomputing. Computer,
36(1):41–50, 2003.
[46]W.Klieberetal.Androidtaintflowanalysisforappsets.In InternationalWorkshop
on the State of the Art in Java Program Analysis, Edinburgh, United Kingdom,
June 2014. ACM.
[47]Y.K.Lee,J.Y.Bang,G.Safi,A.Shahbazian,Y.Zhao,andN.Medvidovic. Asealant
for inter-app security holes in android. In Software Engineering (ICSE), 2017
IEEE/ACM 39th International Conference on, pages 312–323. IEEE, 2017.
[48]L.Li,A.Bartel,T.F.Bissyandé,J.Klein,Y.LeTraon,S.Arzt,S.Rasthofer,E.Bodden,
D.Octeau,andP.McDaniel. Iccta:Detectinginter-componentprivacyleaksin
android apps. In Int’l Conf. on Software Engineering, pages 280–291, Florence,
Italy, May 2015. IEEE.
[49]U. Lindemann and M. Maurer. Facing multi-domain complexity in product
development. In Thefutureofproductdevelopment.Springer,Berlin,Germany,
2007.
[50]L.Lu,Z.Li,Z.Wu,W.Lee,andG.Jiang. Chex:staticallyvettingandroidappsfor
component hijacking vulnerabilities. In conference on Computer and communica-
tions security, pages 229–240, New York, NY, October 2012. ACM.
[51]F. Maggi, A. Valdi, and S. Zanero. Andrototal: A flexible, scalable toolbox and
servicefortestingmobilemalwaredetectors. In WorkshoponSecurityandPrivacy
in Smartphones and Mobile Devices, pages 49–54, Berlin, Germany, November
2013.
[52]D. Octeau, S. Jha, and P. McDaniel. Retargeting android applications to java
bytecode. In InternationalSymposiumontheFoundationsofSoftwareEngineering,
page 6. ACM, 2012.
[53]D. Octeau, D. Luchaup, M. Dering, S. Jha, and P. McDaniel. Composite constant
propagation:Applicationtoandroidinter-componentcommunicationanalysis.
InInt’l Conf. on Software Engineering, pages 77–88, Florence, Italy, May 2015.
IEEE.
[54]D. Octeau, P. McDaniel, S. Jha, A. Bartel, E. Bodden, J. Klein, and Y. Le Traon.
Effectiveinter-componentcommunicationmappinginandroid:Anessentialstep
towardsholisticsecurityanalysis. In USENIXSec.Symp.,Washington DC,Aug.
2013.
[55]M. Ongtang, S. McLaughlin, W. Enck, and P. McDaniel. Semantically rich
application-centricsecurityinandroid. SecurityandCommunicationNetworks,
5(6):658–673, 2012.
[56]T. Petsas, G. Voyatzis, E. Athanasopoulos, M. Polychronakis, and S. Ioannidis.
Rageagainstthevirtualmachine:hinderingdynamicanalysisofandroidmalware.InProceedingsoftheSeventhEuropeanWorkshoponSystemSecurity,page5.ACM,
2014.
736
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Mahmoud Hammad, Joshua Garcia, and Sam Malek
[57]S. Poeplau, Y. Fratantonio, A. Bianchi, C. Kruegel,and G. Vigna. Execute this!
analyzingunsafeandmaliciousdynamiccodeloadinginandroidapplications.
InNDSS, volume 14, pages 23–26, San Diego, California, February 2014.
[58]J. Qiu, B. Yadegari, B. Johannesmeyer, S. Debray, and X. Su. A framework for
understanding dynamic anti-analysis defenses. In Proceedings of the 4th Program
Protection and Reverse Engineering Workshop, page 2. ACM, 2014.
[59]S. Rasthofer, I. Asrar, S. Huber, and E. Bodden. How current android malware
seeks to evade automated code analysis. In IFIP International Conference on
Information Security Theory and Practice, pages 187–202. Springer, 2015.
[60]A.Sadeghi,R.Jabbarvand,N.Ghorbani,H.Bagheri,andS.Malek. Atemporal
permissionanalysis andenforcement framework forandroid. In International
ConferenceofSoftwareEngineering(ICSE’18),Gothenburg,Sweden,May2018.
IEEE.
[61]A. Sadeghi, R. Jabbarvand, and S. Malek. Patdroid: permission-aware gui testing
of android. In Proceedingsof the 11thJoint Meetingon Foundations ofSoftware
Engineering (ESEC/FSE’17), pages 220–232. ACM, September 2017.
[62]G.Sarwar,O.Mehani,R.Boreli,andM.A.Kaafar. Ontheeffectivenessofdynamic
taint analysis for protecting against private information leaks on android-based
devices. In SECRYPT, volume 96435, 2013.
[63]B.Schmerl,J.Gennari,A.Sadeghi,H.Bagheri,S.Malek,J.Cámara,andD.Garlan.
Architecture modeling and analysis of security in android systems. In Euro-
pean Conference on Software Architecture, pages 274–290, Copenhagen, Denmark,
November 2016.
[64]W. Shin, S. Kwak, S. Kiyomoto, K. Fukushima, and T. Tanaka. A Small But Non-
negligible Flaw in the Android Permission Scheme. In Int’l Symp. on Policies forDistributed Systems and Networks, pages 107–110, Fairfax, VA, July 2010.
[65]D. V. Steward. The design structure system: A method for managing the design
of complex systems. IEEE transactions on Engineering Management , (3):71–74,
1981.
[66]K.Tam,S.J.Khan,A.Fattori,andL.Cavallaro. Copperdroid:Automaticrecon-
struction of android malware behaviors. In NDSS, 2015.
[67]T.VidasandN.Christin. Evadingandroidruntimeanalysisviasandboxdetec-
tion. InProceedings of the 9th ACM symposium on Information, computer and
communications security, pages 447–458. ACM, 2014.
[68]F. Wei, S. Roy, X. Ou, and Robby. Amandroid: A precise and general inter-componentdataflowanalysisframeworkforsecurityvettingofandroidapps.
InACM CCS, Scottsdale, Arizona, November 2014.
[69]X.Wei,L.Gomez,I.Neamtiu,andM.Faloutsos. Profiledroid:multi-layerprofiling
ofandroidapplications. In Proceedingsofthe18thannualinternationalconference
on Mobile computing and networking, pages 137–148. ACM, 2012.
[70]K.Xu,Y.Li,andR.H.Deng. Iccdetector:Icc-basedmalwaredetectiononandroid.
IEEE Transactions on Information Forensics and Security, 11(6):1252–1264, 2016.
[71]C. Zheng, S. Zhu, S. Dai, G. Gu, X. Gong, X. Han, and W. Zou. Smartdroid: an
automaticsystemforrevealingui-basedtriggerconditionsinandroidapplications.
InProceedingsofthesecondACMworkshoponSecurityandprivacyinsmartphones
and mobile devices, pages 93–104. ACM, 2012.
[72]Y.ZhouandX.Jiang. Dissectingandroidmalware:Characterizationandevolu-
tion. InIEEESymposiumonSecurityandPrivacy,pages95–109,SanFrancisco,
California, May 2012. IEEE.
737
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. 