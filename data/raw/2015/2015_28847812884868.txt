Code Anomalies Flock Together
Exploring Code Anomaly Agglomerations for Locating Design Problems
Willian Oizumi, Alessandro Garcia,
Leonardo da Silva Sousa, Bruno Cafeo
Informatics Department – PUC-Rio
Rio de Janeiro, Brazil
{woizumi, afgarcia, lsousa,
bcafeo}@inf.puc-rio.brYixue Zhao
Dept. of Computer Science - USC
Los Angeles, USA
yixuezha@usc.edu
ABSTRACT
Design problems aﬀect every software system. Diverse soft-
ware systems have been discontinued or reengineered due to
design problems. As design documentation is often informal
or nonexistent, design problems need to be located in the
sourcecode. Themaindiﬃcultytoidentifyadesignproblem
intheimplementationstemsfromthefactthatsuchproblem
is often scattered through several program elements. Previ-
ousworkassumedthatcodeanomalies–popularlyknownas
code smells – may provide suﬃcient hints about the location
ofadesignproblem. However, eachcodeanomalyalonemay
represent only a partial embodiment of a design problem.
In this paper, we hypothesize that code anomalies tend to
“ﬂock together” to realize a design problem. We analyze to
what extent groups of inter-related code anomalies, named
agglomerations, suﬃce to locate design problems. We ana-
lyze more than 2200 agglomerations found in seven software
systems of diﬀerent sizes and from diﬀerent domains. Our
analysis indicates that certain forms of agglomerations are
consistentindicatorsofbothcongenitalandevolutionaryde-
sign problems, with accuracy often higher than 80%.
1. INTRODUCTION
Design problems are structures that indicate violations of
key design principles or rules [38]. Every software system
suﬀers from design problems, introduced either during orig-
inal development or during evolution. Examples of design
problemsare Fat Interfaces [10, 38], Overused Interfaces [10,
38], and Scattered Concerns [10, 38]. These problems may
have diﬀerent degrees of severity, but all of them should be
detected and possibly removed from the source code. Soft-
ware systems have been often discontinued [22] or have had
to be fundamentally reengineered [12, 34, 40] when design
problems were allowed to persist in a system and to be com-
pounded by other design problems introduced later.
Design problems are introduced and allowed to remain in
a system because their localization in the source code is dif-
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
ICSE ’16, May 14-22, 2016, Austin, TX, USA
c2016 ACM. ISBN 978-1-4503-3900-1/16/05. . . $15.00
DOI:http://dx.doi.org/10.1145/2884781.2884868ﬁcult. As design documentation is often informal or nonex-
istent, code anomalies – popularly known as code smells [7]
– are used as surface indicators of design problems. Ex-
amples of code anomalies are Long Method, Feature Envy,
andGod Class. Even though each code anomaly can provide
somehinttodevelopers, italonemightnotsuﬃcetoindicate
the presence of a design problem. Each design problem is
rarely localized in a single anomalous element; instead, it is
scattered into diﬀerent code elements of the implementation
[30].
As an example, let us assume a developer is in charge of
identifying Fat Interfaces . He will need to go through all
code anomalies aﬀecting each interface in the program. In
particular, he will need to inspect all the classes that imple-
ment the interfaces in the source code. Then, he will have
to analyze all the clients of such classes. Furthermore, it is
hard and time-consuming to identify which code anomalies
he should focus. Even for small software systems, there are
hundreds of code anomalies [25] and thousands of possible
relationships to examine.
The relation between design problems and their coun-
terpart code anomalies is often complex. Unfortunately,
there is no understanding of which relationships between
code anomalies are frequent indicators of design problems
in an evolving program. There is a recent growing inter-
est in conceptually characterizing interactions between code
anomalies [1, 2, 30, 36, 44]. However, the relation of code
anomalies and design problems is rarely investigated. Em-
pirical studies only address how individual occurrences of
code anomalies emerge during software evolution [39] or af-
fect quality attributes [5, 13, 17, 18, 21, 32]. They do not
analyze how individual anomalies and their relationships in
the code might help developers to spot design problems.
In this paper, we hypothesize that code anomalies “ﬂock
together” in order to embody diﬀerent design problems in
the implementation. Therefore, we investigate whether and
how code anomaly relationships can help developers to lo-
cate design problems. To achieve this purpose, we propose
a strategy to identify groups of inter-related code anoma-
lies, i.e., code anomalies that “ﬂock together”. We call ag-
glomerations these groups of inter-related code anomalies.
We perform a multi-case study in order to investigate them,
focusing on agglomerations of code anomalies that are syn-
tactically or semantically related (Sections 3.2 and 3.3). We
analyze seven systems of diﬀerent sizes (8 KSLOC to 129
KSLOC) and from diﬀerent domains. Our analysis involves
a total of 5418 code anomalies and 2224 agglomerations.
2016 IEEE/ACM 38th IEEE International Conference on Software Engineering
   440
We investigate the circumstances under which agglomera-
tions are related (or not) to design problems. The analyzed
circumstances involve: (i) the statistical signiﬁcance of the
relation between agglomeration types and design problems,
(ii) the strength of this relation, and (iii) the extent to which
agglomerations manifest themselves at diﬀerent stages of a
system’s lifetime, i.e., in early vs. late versions of a system.
The aforementioned analysis results in several ﬁndings:
1. Overall, approximately 50% of the syntactic agglom-
erations are related to design problems. Their use can
help developers to discard almost 4000 non-agglomera-
ted code anomalies that are irrelevant to locate design
problems. In general, at least 3 code anomalies of each
syntactic agglomeration are related to the same design
problem in all the systems.
2. However, syntactic agglomerations do not suﬃce to
assist developers in locating all design problems. Se-
mantic agglomerations are much more consistent indi-
cators of design problems across our target systems.
On average, 80% of the semantic agglomerations are
related to design problems. Several design problems
in all the analyzed systems can only be revealed with
semantic agglomerations.
3. Analysis of history co-changes has been recently used
to identify design problems during software evolution
[35, 41, 42]. However, we observe this approach is
ineﬀective in locating a signiﬁcant proportion of de-
sign problems. The reason is that those problems are
“congenital”, i.e., they were already introduced in the
system’s initial version. Co-changes aﬀecting the cor-
responding anomalous elements might occur only in
later versions of a software system, but it is usually
too late to identify and remove congenital design prob-
lems. Many clients already depend on the anomalous
code elements that realize the design problem.
The paper is organized as follow. Section 2 presents the
background to understand the paper. Section 3 describes
the settings of our study, including the research questions
and the procedure for data collection and analysis. Sec-
tion 4 summarizes the main results of our study. Sections 5
and 6 present the related work and the threats to validity,
respectively. Finally, Section 7 concludes the paper.
2. BACKGROUND
This section presents the background required to under-
stand our study settings. Section 2.1 presents key concepts,
and Section 2.2 introduces a motivating example.
2.1 Code Anomalies and Design Problems
A code anomaly, popularly known as “code smell”, is a
micro structure in the program that represents a surface in-
dication of a design problem [7]. Examples of code anomaly
types vary from method-level smells, such as Long Method
andFeature Envy, to class-level smells, such as God Class,
Data Class ,Shotgun Surgery, and Divergent Change [7, 19].
Even in small programs, developers often have to face hun-
dreds or thousands of code anomaly instances. They need
to analyze all these anomalies in order to discard, postpone
or further consider them. In fact, multiple anomalies mayinteract in the source code structure, at which each one pos-
sibly represents a partial hint of a design problem. On the
other hand, many anomalies may not contribute at all in
helping developers to locate any design problem [23, 24, 25].
An important set of code anomalies actually represents
design problems. Design problems are structures that indi-
cateviolationofintendeddesignrulesorfundamentaldesign
principles, and they negatively impact design quality [8, 38].
Examples of relevant design problems are Fat Interface [26]
andUnwanted Dependencies [33]. The former is a general,
ambiguous entry point of a design component that provides
non-cohesive services, thereby complicating the logic of its
clients. This design problem violates the well-known prin-
ciples of cohesion, abstraction, and separation of concerns.
The latter represents the violation of a design rule that spec-
iﬁes that two design components should not communicate.
In this study, we focus on such design problems that af-
fect a system’s design decomposition into major sub-systems
(components)andtheirinterfaces. Suchdesignproblemsare
often targets of major maintenance eﬀorts [10, 34, 43], and
they are very often associated with design degradation that
leads to partial or full discontinuation of a software system
[12, 22, 34, 40]. Therefore, they should be removed as early
as possible from a system.
Design problems often aﬀect multiple code elements and
are hard to identify in the source code. Then, code anoma-
liesanalyzedindividuallymaynotbesuﬃcienttohelpdevel-
opers in diagnosing a design problem. Additionally, certain
anomaly types convey micro-structures that are the natu-
ral implementation solutions given the role of the code el-
ement. For instance, some types of classes (e.g., lexical-
analyzer classes) naturally address several concerns, while
some methods (e.g., command processing and dispatching)
arenaturallylong[19]. Thus, certaincodeanomaliesneither
cause nor contribute to the location of a design problem.
2.2 Motivating Example
Let us consider the example shown in Figure 1 extracted
from Apache OODT (Object Oriented Data Technology)
[27]. OODT is a data-grid system aimed at supporting
the management and storage of scientiﬁc data. OODT’s
Versioning component, which exports the Versioner inter-
face, is responsible for managing and storing versions of dif-
ferent Product types using diﬀerent storage strategies. All
classes implementing Versioner interface have to implement
thecreateDataStoreReferences method. One of the param-
eters of this method is a Product instance. Product class
can represent several types of structures, like ﬂat and hi-
erarchical. As there are no classes for each Product type,
each createDataStoreReferences implementation has to de-
cideifitisdealingwiththeright Producttype. Forexample,
theMetadataBasedFileVersioner class only deals with “ﬂat”
products.
Over time, OODT developers realized that there may be a
design problem located in the Versioning component. Scat-
tered changes involving this sub-system have been a major
source of maintenance eﬀort. They ran a static analysis in
order to identify code anomalies that point to the design
problem. The analysis output consisted of several dozens
of code anomalies scattered across several classes and meth-
ods of the Versioning component. They analyzed several
anomalies individually and decided to discard some of them,
as they did not represent a threat to the program structure.
441Finally,developerszeroinonafrequentlychangedmethod
ofBasicVersioner,called createDataStoreReferences. Infact,
this method is simultaneously aﬀected by four anomalies:
Long Method, Feature Envy, Shotgun Surgery andDivergent
Change. However, suchlocalanalysisdoesnotsuﬃcetocon-
cludewhetherthisispartofamajordesignproblem. OODT
developers begin looking for other anomalies at neighboring
methods and classes, i.e., those methods and classes that
have syntactic relationships with createDataStoreReferences
and BasicVersioner. They work their way “outward” by
navigating in the hierarchy structure, and they move up
to analyzing all clients of the Versioner interface, such as
GenericFileMngObjFactory andXmlRpcFileMngrClient.
Afterobservingalltheanomaliesaﬀectingthehierarchical
structure of Versioning and its direct clients, the develop-
ers are able to infer that the component is being aﬀected
by the Fat Interface problem: the Versioner interface is a
single entry point of the component, but only the anoma-
lies (e.g., Feature Envies ) scattered in its four implementa-
tions reveal the non-cohesive nature of the interface. Those
classes need to change every time that each of the diﬀerent
product types are changed (i.e., Divergence Changes ). The
scatteredoccurrencesof Shotgun Surgeries inthe Versioning
component’s clients reinforce the interface is providing sev-
eral non-cohesive services, which should be segregated into
separate interfaces. Each client also needs to change every
time the list of products and their details are changed. All
the components that are related to Versioner and have both
anomalies ( Feature Envy andShotgun Surgery ) are inside of
the dashed line in the Figure 1. These are the components
aﬀected by Fat Interface.
Thepresenceof Fat Interface inthe Versioning component
is causing other problems. While a Fat Interface decouples
components, it makes the component less understandable
and analyzable. Determining the actual services exposed
by such component requires inspecting its implementation
details. Furthermore, the generality of the interface also
makes it easier to misuse, since diﬀerent functionalities are
exposed by the same interface. Yet the only way this poten-
tially critical design ﬂaw can be discovered is by reﬂecting
upon multiple related code anomalies that are located in
syntactically related modules: the interface, its subclasses,
and the interface clients.
3. STUDY DEFINITION
Ourstudyinvestigateswhetherandhowinter-relatedcode
anomalies, referred to anomaly agglomerations , are related
to design problems. Section 3.1 describes and motivates our
research questions. Sections 3.2 and 3.3 present the types of
agglomerations we are investigating. Section 3.4 describes
the target systems of our study. Finally, Section 3.5 ad-
dresses the procedure for data collection and analysis.
3.1 Research Questions
Existing techniques [1, 30, 36] usually assume that in-
dividual anomalies suﬃce for assisting developers in locat-
ing design problems in the program. The previous section
showed that each design problem may be realized by vari-
ous inter-related code anomalies scattered in the program.
However,thereisnounderstandingwhethercertainanomaly
relationships can help developers in better locating design
problems than individual code anomalies. We are primarily
interested in groups of syntactically related code anomalies,
Figure 1: Fat interface aﬀecting Versioner implementation
i.e.,syntactic agglomerations for short (Section 3.2). Two
anomalies are syntactically related if their host program el-
ements are connected through method calls or inheritance
relationships. Weﬁrstinvestigatewhethersyntacticagglom-
erations often embody design problems in the source code.
If this hypothesis holds, the inspection of such agglomera-
tions can help developers in locating design problems. This
reasoning leads to our ﬁrst research question:
RQ1 Are syntactic anomaly agglomerations suﬃcient indi-
cators of design problems?
Syntactic agglomerations may not suﬃce to locate all de-
sign problems. Thus, other forms of code anomaly agglom-
erations may be required to locate design problems in the
source code (Section 3.3). Therefore, we address RQ1 by
analyzing the relation between diverse forms of agglomera-
tions and design problems in the context of seven software
projects. We also analyze this relation in early versions of
each project. Recent studies [2, 39] revealed that, most of
thetime, programsareaﬀectedbycodeanomaliessincetheir
creation. In addition, it might be that some design problems
are “congenital”, i.e., they manifest in the initial versions of
a program (Section 2.2). However, there is no understand-
ing about the relation between “early” code anomalies and
congenital design problems; and more importantly, between
anomaly agglomerations and design problems. This gap mo-
tivates our second research question:
RQ2 Whatproportionofdesignproblemsmanifestasanomaly
agglomerations in early versions of a program?
We address RQ2 by investigating the relation of design
problemsandcodeanomalyagglomerationsinearlyversions
of a system. If this relation holds, early detection of congen-
ital design problems can be improved by using code anomaly
442agglomerations. We address RQ2 by analyzing the available
initial versions of the analyzed software systems.
3.2 Syntactical Agglomerations
Asyntactic agglomeration isagroupofatleasttwoanoma-
lous code elements explicitly related in a program. A code
element is anomalous when it is aﬀected by one or more
code anomalies. In our study, we consider the following
code elements: classes, interfaces, methods, constructors,
and ﬁelds. An explicit relationship is established between
two anomalous elements when they have at least one of the
following dependencies: shared attribute, method call, class
extension or method overload. We classify syntactic ag-
glomerations according to their scope in the program: (i)
intra-component agglomerations , i.e., those entirely located
withinasinglecomponent, and(ii) inter-component agglom-
erations, i.e., those located in two or more components. In
our study, we consider each component is realized by a pack-
age in the analyzed Java programs (Section 3.4), unless the
system developers specify otherwise. Developers may state
a component is realized by a set of classes that are not nec-
essarily located in the same package.
Inter-Component Agglomeration is a syntactic ag-
glomeration that involves two or more design components,
with at least one anomalous code element located within
each of them. The example in Section 2.2 illustrates an
inter-component agglomeration in the OODT system. The
agglomeration is formed by anomalous code elements lo-
cated in three OODT components: Versioning, Utiland
System. In Figure 1, the inter-component agglomeration is
surrounded by the dashed black line, and the green circles
represent the code anomalies located in the syntactically re-
lated code elements that compose the agglomeration.
Listing 1 illustrates the algorithm (pseudo-code) for com-
puting inter-component agglomerations. The algorithm has
two parameters: (i) dc: a set of design components, and (ii)
agglomThreshold : a threshold value for the minimum ag-
glomeration size. First, the algorithm identiﬁes all anoma-
lous elements of a design component by using the function
getAnomalousElemsOfComp() (line 6). The anomalous el-
ements of the program are recorded in the anomalousE-
lemsattribute. The algorithm generates a graph ( graphIn-
terElems ) with the syntactic relationships (edges) between
anomalous elements (vertices) located in diﬀerent design
components (line 10 and lines 12–19). To ﬁnd the rela-
tionships between elements, the algorithm uses the function
isRelated() (line 15). In order to detect the agglomerations,
the algorithm ﬁnds the subgraphs within the graph in which
any two vertices are connected (the subgraph formed by the
relationships among the anomalous elements). Finally, only
theagglomerationswiththesizegreaterthan agglomThresh-
oldare included in the resulting set of inter-component ag-
glomerations, i.e., interAgglomerations (lines 25–29).
Intra-Component Agglomeration is a syntactic ag-
glomeration composed of anomalous code elements located
in the same design component. Given space constraints,
the algorithm is available in our on-line supplementary ma-
terial [31]. However, the algorithm for computing intra-
component agglomerations is similar to the previous algo-
rithm for identifying inter-component agglomerations. The
only diﬀerence is that the algorithm generates a graph with
the relationships (edges) between the anomalous elements
(vertices) within each design component.Listing 1: Inter-component Agglomeration Algorithm
1.public List {} getInterAgglomeration ( Set dc , int
agglomThreshold ){
2. InterAgglomerations = {}
3. anomalousElems = {}
4.
5.for( each design component dc in the program ){
6. anomalousElems . addAll ( getAnomalousElemsOfComp (dc)
)
7. }
8.
9.// Adding anomalous code elements as vertices in
the graph
10. graphInterElems = new graphInterElems (). addVertex
. addAll ( anomalousElems )
11.
12. for( each e1 in anomalousElems ){
13. for( each e2 in anomalousElems ){
14. // Creating the Inter - component graph
15. if( isRelated (e1 ,e2) && (e1. getDesignComponent
() != e2. getDesignComponent ())){
16. graphInterElems . addEdge (e1 ,e2)
17. }
18. }
19. }
20.
21. // Adding the connected components as
agglomerations
22. InterAgg = new InterAgg (). addAll (
getConnectedComponents ( graphInterElems ))
23.
24. // Selecting only agglomerations above the
predefined threshold
25. for( each a in InterAgg ){
26. if( size (a. getAnomalies ()) > agglomThreshold ){
27. InterAgglomerations .add(a)}
28. }
29. return InterAgglomerations
30. }
3.3 Semantic Agglomerations
Based on the example of Section 2.2, we hypothesized
that code anomalies might somehow interact through the
program structure because of the presence of a single de-
sign problem. In that example, the syntactic relationships
amongst the anomalous elements would be suﬃcient to help
developers in revealing the design problem. However, this
might not be the case for all occurrences of design prob-
lems. In some cases, design problems might be related to
semantically connected anomalies. Anomalies are seman-
tically connected if their host elements are addressing the
same concern. Concern is a property or functionality of in-
terest to the designers of a system, but it is not necessarily
modularized in a single component. In such cases, the se-
manticrelationshipmayhelpthedeveloperstolocatecertain
design problems better than the syntactic relationships.
LetusconsideranexampleextractedfromtheMobileMe-
dia system [45]. Mobile Media is a software product line to
derive applications that manipulate photos, videos and mu-
sic on mobile devices [45]. Figure 2 depicts a partial view
of three components of Mobile Media design: Controller,
Screens, and Sms. Classes of the Screenscomponent are
aﬀected by the Divergent Change anomaly, while classes of
theController andSmscomponents were infected by the
Divergent Change andShotgun Surgery anomalies. These
code anomalies did not represent isolate problems. Many of
theseclassesarenotsyntacticallyconnected, buttheirmeth-
ods partially address the same concern, called Photo Label
Management. Therefore, the anomalous code elements are
altogether realizing the design problem Scattered Concern ,
i.e., multiple components realizing a crosscutting concern
443[9, 24]. The realization of Photo Label Management should
be modularized in the Controller component. This problem
was the cause of major design refactorings along Mobile Me-
dia evolution. However, the design problem would be better
spotted if the scattered anomalies ( Divergent Changes and
Shotgun Surgeries )realizingthesameconcernareconsidered
altogether. In our study, we chose concern-based agglomer-
ation as a representative type of semantic agglomerations.
Figure 2: Scattered Concern in Mobile Media
Semantic Agglomeration is composed of anomalous
code elements realizing a single concern, which is not modu-
larized by design components. Examples of design-relevant
concerns can be classiﬁed in domain-speciﬁc concerns, such
asPhoto Label Management , or general-purpose concerns,
such as persistence, error handling, security and the like.
Semantic relationships between two or more code anomalies
occur when their host code elements are intended to (par-
tially) realize a single design’s purpose or concern, i.e., the
semantic relationship appears in code elements that imple-
ment the same concern and also have code anomalies.
Listing 2 presents the algorithm (pseudo-code) for detect-
ing semantic agglomerations. The full algorithm is available
in our supplementary material [31]. The basic idea of the
algorithm is searching for agglomerations for each concern
conthat satisﬁes the following conditions: (i) conis located
in one or more components (line 7), and (ii) at least one of
thesecomponentsisnotmainlydedicatedtorealize con(line
5). The components in (ii) are named weakly-dedicated com-
ponents. The identiﬁcation of weakly-dedicated components
is implemented by the function weakDedicatedComponents()
(line 5). This function computes, for each component realiz-
ing a concern, if code elements in the component are mostly
dedicated to realize other concerns. In other words, a com-
ponent dcis weakly dedicated to a concern con, if conis not
the main concern of the code elements within dc. Although
dcpartially implements con, the predominant concern of dc
is not con. The minimum degree of dedication is captured
based on a percentage threshold, named weakThreshold .
Thus, the main algorithm uses four inputs: a set of design
components dc, themappingsforeachconcern con, athresh-
old for the minimum agglomeration’s size agglomThreshold
(default = 1), and weakThreshold (default = 1). In our case
study, the developers provided the concern mappings (Sec-
tion 3.5), but the concerns can be automatically extracted
from the source code using an automatic concern locationTable 1: Characteristics of the Target Systems
System
Type Design KSLOC
HW
Web Framework Layers 8
MM
Software Product Line MVC 10
S1
Desktop Application Client-Server 122
S2
Desktop Application Client-Server 118
S3
Desktop Application Client-Server 93
S4
Web Application MVC 116
OODT
Middleware Layers 129
tool. Once the concerns are recovered, the algorithm can lo-
cate the code elements that implement an concern conand
also are infected by code anomalies (line 7). The anomalous
code elements contributing to weakly-dedicated components
of a crosscutting concern are grouped into an agglomeration
candidate (lines 8 to 9). If the agglomeration candidate
has a number of anomalies higher than the agglomThreshold
(line 11), then this agglomeration is included in the results
(line 12) and conﬁrmed as an actual agglomeration.
Listing 2: Semantic Agglomeration Algorithm
1.public List [] getSemanticAgglomeration ( Set dc , Set
con , int agglomThreshold , int weakThreshold ){
2. semanticAgglomerations = []
3.
4.for( each design concern con in the program ){
5. W = weakDedicatedComponents (con , weakThreshold )
6. agglomeration = []
7. if( size (W) > 0){
8. ae = getAnomalousElemsPerConcern (W, con)
9. agglomeration . addAll (ae)
10. }
11. if( size ( agglomeration ) > agglomThreshold ){
12. semanticAgglomerations . add ( agglomeration )
13. }
15. }
15. return semanticAgglomerations
16. }
3.4 Target Systems
In order to address the two research questions, we ana-
lyzed systems with a wide range of characteristics. We se-
lected 7 systems of diﬀerent sizes, leveraging diﬀerent design
styles, and spanning diﬀerent domains. Table 1 summarizes
the general characteristics of each system. We focused on
these systems because: (i) their designs had degraded, (ii)
they present a wide range of design problems, and (iii) their
developers were available to provide us with a reliable list
of design problems (which are causes of major maintenance
eﬀort) and the mappings of their design’s concerns.
The ﬁrst system is the Health Watcher (HW), a web
framework system that allows citizens to register complaints
about the health issues in public institutions [37]. The sec-
ond is Mobile Media (MM), an academic software product
line to derive applications that manipulate photos, videos,
and music on mobile devices [45]. The next four systems are
proprietary and, due to intellectual-property constraints, we
will refer to them as S1, S2, S3 and S4. S1 and S2 manage
activities related to production and distribution of oil. S3
manages the trading stock of oil, and S4 supports the ﬁ-
nancial market analysis. Finally, the last system is Apache
OODT, whose goal is to develop and promote the manage-
ment and storage of scientiﬁc data [27]. For all the tar-
get systems, several classes implement each component. In
OODT, for instance, each design component is implemented
by an average of 24 classes. There was always a 1-to-1 map-
444Table 2: Analyzed Design Problems
Name
Description Instances
F
at InterfaceInterface of a design component that oﬀers only a
general, ambiguous entry-point that provides non-cohesive
services, thereby complicating the clients’ logic.114
Un
wanted Dependency Dependency that violates an intended design rule. 2145
Comp
onent OverloadDesign components that fulﬁll too many
responsibilities.141
Cyclic
DependencyTwo or more design components that directly or
indirectly depend on each other.351
Delegating
AbstractionAn abstraction that exists only for passing messages from
one abstraction to another.35
Scattered
ConcernMultiple components that are responsible
for realizing a crosscutting concern.216
Ov
erused InterfaceInterface that is overloaded with many clients accessing
it. That is, an interface with "too many clients".39
Un
used AbstractionDesign abstraction that is either unreachable or
never used in the system.59
ping between components and packages in three systems:
MM, HW, OODT, S3 and S4. For S1 and S2, the developers
provided the set of classes implementing each component.
3.5 Data Collection Procedure
Thedatacollectionprocesscomprisedthefollowingactivi-
ties: (i) identifying design problems with help of the systems
developers, (ii) detecting code anomalies, concern mappings
andagglomerations, and(iii)correlatingagglomerationsand
design problems. Next, we describe each activity.
IdentifyingDesignProblems. Weproduceda“ground
truth” of design problems for each target system. We per-
formed two steps to incrementally develop the ground truth.
First, original developers of the systems provided us with an
initial list of design problems. They listed the problems and
explained the relevance of each one through a questionnaire
[31]. Theyreportedwhichwasthemaintenanceeﬀortcaused
by the presence of each design problem. They also described
which code elements were contributing to the realization of
each design problem. Second, we performed other steps to
validate the initial list for correctness and completeness. An
additional identiﬁcation of design problems was performed
using the source code and the system design. For systems
without design documentation, we relied on a suite of de-
sign recovery tools [9]. The procedure for deriving the list
of design problems with developers was the following: (i) an
initial list of design problems was identiﬁed using detection
strategies presented in [2], (ii) the developers had to con-
ﬁrm, refute or expand the list of identiﬁed design problems,
(iii) the developers provided a brief explanation about the
relevance of the design problem, and (iv) when we suspected
there was still inaccuracies in the list of design problems, we
asked the developers for further feedback. Table 2 describes
the types of design problems and number of instances iden-
tiﬁed in our sample of systems.
Concern Mappings. The initial lists of concerns and
their mappings in the source code were provided with the
assistance of systems’ developers. For each concern in their
initial lists, they provided a list of methods or classes realiz-
ing those concerns. Given the large size of certain systems,
developers could eventually not produce complete concern
mappings. Therefore, we also relied on the Mallet [28] tool.
Mallet is a concern location tool that explores topic mode-
ling in order to automatically generate a list of concerns
and identify the code elements realizing each concern in a
program. Then, we computed and compared two sets of
semantic agglomerations: one based on the concern map-
ping produced by developers, and the other based on the
concern mapping generated by Mallet. We will discuss the
comparison of such agglomerations in Section 4.2.Code Anomalies and Agglomerations. We conside-
red7typesofcodeanomalies: Data Class, Divergent Change ,
God Class, Shotgun Surgery, Feature Envy, Long Method
andLong Parameter List. They were selected because they
represent diﬀerent types of symptoms at class and method
levels. The detection of code anomalies was performed us-
ing well-known metrics-based strategies [19]. These detec-
tion strategies are similar to those typically used in previous
empirical studies (e.g. [23, 24, 25, 39]). Such strategies have
been proven to be eﬀective for detecting code anomalies in
other systems, with precision higher than 80% [2, 24]. Once
the anomalies were detected, we computed the syntactic and
semantic agglomerations. The detection of anomalies and
agglomerations were carried out with a tool, called Organic
[23]. Organic implements: (i) the 7 detection strategies for
code anomalies, and (ii) the algorithms for computing ag-
glomerations (Section 3.2 and Section 3.3). The results of
these steps are available at the supplementary material [31].
CorrelatingAgglomerationsandDesignProblems.
Asaforementioned, developersindicatedthelocationofeach
design problem. In order to answer our research questions,
we deﬁned a criterion for correlating design problems with
anomalies and agglomerations. A design problem is related
toanindividualcodeanomalyiftheformeriseitherpartially
orfullyrealizedbythecodeelementaﬀectedbytheanomaly.
Weconsiderthatadesignproblemandanagglomerationare
related if they co-occur in at least two code elements. Even
though agglomeration and design problem may be located
in more than two anomalous elements, our criterion con-
siders suﬃcient if they co-occur in two elements. Thus, an
agglomeration fails to indicate design problems when either
none or only one of its code anomalies is related to a design
problem. Finally, we computed the strength of the relation
between agglomerations and design problems, i.e., the num-
ber of anomalies in agglomeration that contributed (or not)
to a design problem (Section 4.1). We checked the statisti-
cal signiﬁcance of our results using the Fisher’s exact test
[6] and computing the Odds Ratio [4] with the R tool [3].
4. RESULTS AND ANALYSIS
This section presents the results and analysis of our study.
Section4.1discusseswhethersyntacticagglomerationsassist
the location of design problems. Then, Section 4.2 analyzes
to what extent syntactic agglomerations suﬃce to locate all
design problems and, if not, whether semantic agglomera-
tions can further improve this task. Section 4.3 discusses if
agglomerations can also be eﬀective to assist the location of
design problems in early versions of a system.
4.1 Exploring Syntactic Agglomerations
Before answering our ﬁrst research question, we reﬂect
upon the relation of syntactic agglomerations and design
problems. First, we check whether syntactic agglomerations
are more related to design problems than non-agglomerated
codeanomalies. Non-agglomeratedanomaliesare“detached”
anomalies that do not take part of any agglomeration.
The results are presented in the ﬁrst three columns of Ta-
ble 3. The ﬁrst column (named Agglomeration) lists the
agglomeration types analyzed in our study. The second col-
umn (named AG-DP) shows the amount of agglomerations
(for each category) related to design problems. The third
column (named NoAG-NoDP) presents the number of “de-
tached” anomalies that are irrelevant to locate design prob-
445Table 3: Contingency Table and Fisher’s Test Results
Agglomeration
AG-DP NoAG-NoDP p-value ORs
In
tra-component 247 3996 <0.001 5,669636
In
ter-component 167 4207 <0.001 4,878982
Syn
tactic 296 3759 <0.001 5,513531
Seman
tic 97 4463 <0.001 7,392637
All
312 4596 <0.001 2,999686
lems, i.e. they are not related to any design problem. We
discuss the data of the last two columns later in this section.
The data of the row “semantic” is discussed in Section 4.2.
Reducing the Search Space for Design Problems.
Table 3 conﬁrms that syntactic agglomerations are good in-
dicatorsofdesignproblems. Almost300syntacticagglomer-
ations are related to design problems. Each row shows how
many “detached” anomalies could be discarded when devel-
opersareexploringaspeciﬁctypeofsyntacticagglomeration
in order to look for design problems. For instance, if devel-
opers are inspecting inter-component agglomerations, they
will be able to: (i) ﬁnd 167 design problems in their systems,
and (ii) discard more than 4000 code anomalies returned by
their static analysis tools. This result suggests that syntac-
tic agglomerations can assist developers in locating design
problems. When identifying design problems in the source
code, the scope of analysis can be reduced to the list of code
anomalies taking part in the agglomeration, rather than an
unmanageable list of individual code anomalies.
Syntactic Agglomerations as Design Problems:
Strength of the Relation. Even though the previous
analysis is interesting, it does not consider that anomaly
agglomerations have higher probability of being related to
design problems than a single code anomaly, since agglom-
eration involves more code. The latter aﬀects a single code
element (a method or a class), while the former involves
at least two code elements. The size of an agglomeration
ranged from 2 to 9 in all systems. Therefore, we investigated
the strength of the relation between agglomerations and de-
sign problems. We performed further analyses to check to
what extent various code elements of the agglomeration are,
in fact, contributing to the realization of a design problem.
First, we calculated the Odds Ratio [4] for each type of
agglomeration (ORs column of Table 3), which shows how
much higher is the chance of code elements taking part in
agglomerations to be related to design problems than indi-
vidual anomalous elements. The chance of each anomaly
within a syntactic agglomeration being related to a design
problem is more than ﬁve times (5,513) higher than each
“detached” anomaly. Similar results are observed for both
intra-component and inter-component syntactic agglomer-
ations. Second, we also observe that almost all syntactic
agglomerations had at least 3 anomalous code elements si-
multaneously related to the same single design problem in
most of the systems. Thus, when ﬁxing a particular design
problem, developers are more likely to reveal several anoma-
lous code elements involved in the refactoring strategy.
SyntacticAgglomerationsasDesignProblems: Sta-
tistical Signiﬁcance. Finally, we used the Fisher’s exact
test to analyze the statistical signiﬁcance of the relation be-
tween syntactic agglomerations and design problems. The
fourth column (p-value) in Table 3 shows this correlation
for each agglomeration type. We assume a conﬁdence level
higher than 99% (p-value threshold = 0.001) as the thresh-
old value to the signiﬁcant level of the test. Applying thetest, we observe that for all agglomeration types the p-value
was lower than 0.001. There is a high correlation between
both forms of syntactic agglomerations and design problems
in the target systems. However, it does not necessarily mean
that syntactic agglomerations should not be complemented
with other forms of agglomerations to further improve the
locationofdesignproblems. Therefore, weexplicitlyaddress
our ﬁrst research question in the next section.
4.2 Do Syntactic Agglomerations Sufﬁce?
Even though syntactic agglomerations are statistically re-
lated to design problems, it is important to understand if
syntactic agglomerations alone suﬃce to locate all design
problems. Thus, this section addresses RQ1: “Are syn-
tactic anomaly agglomerations suﬃcient indicators of de-
sign problems?” In order to answer RQ1, we ﬁrst analyzed
the proportion of syntactic and semantic agglomerations
(un)related to design problems for each target system. We
compared how often syntactic and semantic agglomerations
relate to design problems. Table 4 shows, for each agglomer-
ationtype, thefollowingmeasures: (i) Precision, (ii) Recall,
and (iii) absolute number of design problems related to ag-
glomerations (DP). Moreover, for each agglomeration type,
Table 4 shows the median and the standard deviation for
the columns PandR. The numbers between parentheses in
theDPcolumns are discussed later in this section.
Precision indicates the fraction of identiﬁed agglomera-
tions that are correctly related to design problems. Recall
indicates the fraction of design problems successfully iden-
tiﬁed by agglomerations. We calculate precision and recall
measures using the following standard equations:
P=TP
TP+FP(1) R=TP
TP+FN(2)
where, TP(true positive) and FP(false positive) encom-
pass all agglomerations that, respectively, are or are not re-
lated to design problems. FN(false negative) occurs when
a group of code elements is aﬀected by a design problem,
but none of them is part of an agglomeration.
Table 4 shows the relation between agglomerations and
design problems in terms of precision and recall. The Syn-
tactic column indicates the aggregate results for both types
of syntactic agglomerations: intra-component (second col-
umn) and inter-component (third column). We highlight
that the values of the Syntactic column cannot be directly
obtained by the data in the previous columns. In other
words, the number of design problems in the fourth column
is not the result of summing the numbers of design prob-
lems for both types of syntactic agglomerations. The reason
is that there are intersections between instances of intra-
and inter-component agglomerations. That is, an inter-
component agglomeration might be composed of anomalies
that are also members of one or more intra-component ag-
glomerations. This happens because the search of each type
ofagglomerationoccursindependently. Thus, adesignprob-
lem might be related to more than one agglomeration.
Syntactic Agglomerations Suﬃce to Indicate Sev-
eral Design Problems. Table 4 indicates that inter-com-
ponentagglomerationsarehelpfulforlocatingmoreinstances
of design problems than intra-component agglomerations.
In four (out of seven) systems, at least almost half (45%) of
the inter-component agglomerations were related to design
problems. However, Table 4 also reveals that both types
of syntactic agglomerations are useful to locate diﬀerent de-
446Table 4: Relation of Agglomerations and Design Problems: Precision and Recall
Agglom. Intra-component Inter-component Syntactic Semantic
System P R DP P R DP P R DP (*) P R DP (**)
OODT 62% 30% 196 73% 83% 549 70% 97% 640 (535) 91% 65% 431 (201)
MM 42% 31% 12 82% 23% 9 57% 55% 21 (21) 100% 13% 5 (3)
HW 39% 11% 22 45% 87% 163 44% 87% 163 (141) 75% 100% 187 (24)
S1 43% 23% 64 51% 21% 58 47% 37% 104 (86) 81% 12% 34 (18)
S2 38% 9% 77 40% 7% 60 39% 13% 110 (83) 82% 5% 47 (21)
S3 38% 9% 76 39% 6% 58 38% 12% 109 (84) 75% 6% 50 (25)
S4 66% 89% 66 34% 60% 45 49% 93% 69 (27) 100% 13% 10 (6)
Median 42% 23% 45% 23% 47% 55% 82% 13%
SD0.118 0.281 0.182 0.349 0.109 0.368 0.107 0.370
* Number of design problems exclusively related either to intra-component or to inter-component agglomerations.
** Number of design problems exclusively related to semantic agglomerations.
sign problems in most systems. As we expected, these two
types of syntactic agglomerations are complementary. This
ﬁnding can be observed by comparing the numbers of the
sub-columns DP from the second to the fourth columns.
In the column Syntactic, there are additional numbers be-
tween parentheses close to the numbers of design problems
(sub-column DP). These numbers represent the amount of
designproblemsthatwereexclusivelyrelatedtoeitherintra-
component or inter-component agglomerations. Therefore,
the subsets of design problems related to intra- and inter-
component agglomerations in six systems are signiﬁcantly
diﬀerent. The only exception was the Health Watcher. The
reasonisthatallthedesignproblemsfoundinitwererelated
to the communication between two components.
Semantic Agglomerations are Consistent Indica-
tors.Semantic agglomerations were the most consistent
indicators of design problems. This ﬁnding is based on the
fact that semantic agglomerations were a good indicator of
design problems across all the systems. The 5th column
(ORs) of Table 3 shows that the chance of each anomaly
within a semantic agglomeration being related to a design
problem is more than seven times higher than each “de-
tached” anomaly. This likelihood is higher than anomalies
within syntactic agglomerations. In addition, semantic ag-
glomerations presented the highest correlation with design
problems, when compared to all other syntactic agglomera-
tions. For example, 91% of the semantic agglomerations in
OODT were related to 431 instances of design problems.
Semantic agglomerations are also often related to design
problems even for the other systems where the absolute
number of related design problems is lower: (i) the per-
centage of true positives was high (from 75% to 100%), and
(ii) the percentage of false positives was low (from 0% to
25%). Considering the data from all systems, we observed a
median of 82% of semantic agglomerations related to design
problems. The standard deviation of 10.74% is low as well.
That is, the percentage of semantic agglomerations related
to design problems was high in all the target systems. Re-
garding the absolute number of design problems (DP), the
semantic agglomerations were related to a high number of
design problems in all the systems.
Syntactic and Semantic Agglomerations are Com-
plementary. Considering each type of agglomeration, re-
call values were below 60% for most of the target systems
(Table 4). Our results suggests that this occurs because
syntactic and semantic agglomerations are complementary.
In the last column of Table 4 (DP), there are additionalnumbers between parentheses close to the numbers of de-
sign problems. These numbers represent the amount of
design problems exclusively related to semantic agglomer-
ations, i.e., design problems that could not be located only
with syntactic agglomerations. Figure 2 shows an example
of design problem located only in the context of semantic
agglomeration.
Approximately 50% of the design problems related to se-
mantic agglomerations have no relation to syntactic agglom-
erations in most of the systems. These design problems
were often cases of Scattered Concerns, Component Over-
load, Overused Interface andDelegating Abstraction. This
result suggests that semantic agglomerations are useful to
complete the location of several design problems. These de-
sign problems are also hard to be located by developers as
there is no syntactic relationship among the anomalous ele-
ments forming the agglomerations. However, existing work
only focuses on characterizing code anomalies based on their
syntactic relationships [1, 2, 30, 36]. Moreover, these design
problems cannot be detected through the use of only con-
cern location techniques. Several crosscutting concerns in
the analyzed systems are not harmful, i.e., their implemen-
tations did not contain code anomalies and they were not
actual sources of design problems.
Design Problems Indirectly Related to Agglom-
erations. We observed occurrences of design problems af-
fecting methods or classes that are indirectly related to ag-
glomerations even not participating of one. We observed
three recurrent patterns of indirect relation: two for meth-
ods and one for classes. The ﬁrst occurs when a method is
implemented inside a class that is part of an agglomeration.
The second is observed when a method is implemented in
a class that have another method in an agglomeration. Fi-
nally, the third occurs when a class have one or more meth-
ods in agglomerations. We expect an increase in the recall
values because, considering indirect relation, makes the cor-
relation rule less strict. For instance, in S3 the recall value
for semantic agglomerations increases from 6% to 51%. This
suggests that an agglomeration may be helpful to identify
design problems even without a direct relation. This be-
comes possible when developers analyze the full context of
agglomerations, instead of analyzing anomalies individually.
Reducing False Positives of Syntactic Agglomer-
ations. Even though syntactic agglomerations are often
related to design problems, developers would still have to
inspect and discard several irrelevant agglomerations. Ta-
ble 4 shows that the number of false positives is higher than
44760% in two systems. However, we observed that the com-
bined use of semantic and syntactic agglomerations would
signiﬁcantly reduce the number of false positives yielded by
the use of only syntactic agglomerations. If we only con-
sider syntactic agglomerations that intersect with semantic
agglomerations, the number of false positives for syntactic
agglomerations would be reduced to 21% or less in all the
systems. There is an intersection between a syntactic ag-
glomerationXandasemanticagglomerationYwhenatleast
one anomalous elements take part of both X and Y. In sum-
mary, the joint use of syntactic and semantic agglomerations
signiﬁcantly enhances the location of design problems.
FullAutomationofSemanticAgglomerations? The
computation of semantic agglomerations relies on mapping
of system concerns to indicate design problems. Tables 3
and 4 show the results for semantic agglomerations com-
puted with concern mappings produced by the systems’ de-
velopers. However, it is important to check whether seman-
tic agglomerations can also improve the location of design
problems when concern mappings are automatically gener-
ated. As mentioned in Section 3.5, we also relied on concern
mappings provided by Mallet in order to generate a second
set of semantic agglomerations. Comparing to the devel-
opers’ mapping, we noticed Mallet generates longer lists of
concerns and concern mappings. As a consequence, the use
of Mallet results in a higher number of semantic agglomera-
tions, which was related to more design problems than our
original computation (Table 4). Semantic agglomerations
generated with Mallet’s output lead to an average increase
of39.58%intheidentiﬁcationofdesignproblemswhencom-
pared to semantic agglomerations generated with develop-
ers’ mappings. The Mallet conﬁguration and all the detailed
results are available in our supplementary material [31].
4.3 Agglomerations as Congenital Problems?
This section addresses the RQ2: “What proportion of de-
signproblemsearlymanifestthemselvesasagglomerations?”
Earlymanifestationmeansthedesignproblemswerepresent
in the ﬁrst versions of a system. Therefore, they are likely
to represent “congenital” design problems, i.e., they were
introduced at design time. In order to answer this question,
we computed for all the systems: (i) the number of design
problems in the ﬁrst versions of our target systems, and (ii)
theproportionofdesignproblemsrelatedtoagglomerations.
Theanalysisofallinitialversionsrevealedthataconsider-
able number of design problems was introduced in the ﬁrst
version of each target system. As opposed to our expec-
tation, all the initial versions presented a high correlation
between agglomerations and design problems. We expected
most of the design problems would be “evolutionary”, i.e.,
theywouldbeintroducedduringthesystemevolution. How-
ever, the proportion of design problems related to agglomer-
ations in early versions was approximately 75% for MM, S1,
S2 and S4. The proportion for the other systems was close
to 65%. We also observed that a considerable proportion of
design problems are exclusively related to either syntactic
or semantic agglomerations already in the ﬁrst version.
These results show that change history analysis [11, 35,
41, 42] would not be an eﬀective solution to reveal many
instances of design problems. Many design problems are
congenital and they are already “born” as agglomerations.
It would be harder to remove them in later versions, when
eventually the agglomeration’s anomalous elements start tosuﬀer co-changes through the later versions. An example of
this case is the Fat Interface in the Versioning component in
OODT(Section2.2). Itwouldbecumbersometorestructure
theVersioner interface in later releases. The number of
client classes for this interface increased from one (in the
ﬁrst release) to more than ﬁfteen (last release).
Comparing Early and Late Versions. We also com-
pared the nature of design problems and agglomerations in
“early” and “late” versions of MM an HW systems. The
comparison of the diﬀerent versions of these two systems
serves to illustrate most of our ﬁndings. For instance, let
us consider the versions 1 and 8 of the MM system. Ver-
sion 1 of MM (0.8 KSLOC) is smaller than version 8 (10
KSLOC). Therefore, the number of code anomalies and ag-
glomerations is proportionally smaller in version 1. Even
with fewer code elements, the ﬁrst version already contained
23%oftheagglomerationspresentinversion8. Oneofthem,
for example, is related to the BaseController class. In the
ﬁrst version, this class was identiﬁed as part of an intra-
component agglomeration. That is, this anomalous class
was related to another anomalous code element of the same
component. This agglomeration was related to the Com-
ponent Overload problem. In the subsequent versions, this
agglomeration “expanded” to several code elements, includ-
ing those located in other components. More speciﬁcally,
in version 8, we identiﬁed that the same agglomeration be-
came an inter-component agglomeration, involving classes
that use the BaseController class. The inter-component ag-
glomeration was related to emerging instances of Fat Inter-
faceandOverused Interface problems.
For the HW system, we compared versions 1 and 10. In
this case, version 1 (6 KSLOC) was only somewhat smaller
than version 10 (8 KSLOC). However, as in the case of the
MM system, we observed again that some agglomerations
found in a late version had already started to form in the
ﬁrst version. The ﬁrst version already contained 39% of syn-
tactic and semantic agglomerations found in version 10. All
these observations suggest that agglomerations are eﬀective
to assist the identiﬁcation and removal of design problems
in the early versions of a system, which can prevent the in-
troduction of more severe problems in subsequent versions.
5. RELATED WORK
Do Individual Anomalies Suﬃce? Tufano et al. [39]
investigated when and why code smells are introduced in the
context of evolving systems. Kim et al. [18], Lozano et al.
[21] and Olbrich et al. [32] investigated the eﬀect of indi-
vidual code anomalies throughout the system’s evolution.
These studies analyzed whether the number of code anoma-
lies tend to increase over time, and how often they result
in code changes. There is also a large body of work aiming
at assessing the impact of individual occurrences of code
anomalies on certain software quality attributes. For in-
stance, Khomh et al. [16, 17] studied the relation between
code anomalies and software change proneness. They con-
cludedthatanomalousclassestendtobemorechange-prone.
In addition, corroborating with the work of Li and Shat-
nawi [20] and D’Ambros et al. [5], they also observed that
classes infected by code smells tend to be more fault-prone
than other classes [17]. Jürgens et al. [13] and Kapser et al.
[14] found that one speciﬁc code anomaly adversely impacts
onsoftwaremaintenance. Sjobergetal.[36]showedthatsin-
gle code anomalies were not related to maintenance eﬀort.
448Therefore, some of the results of these studies are controver-
sial regarding the usefulness of individual code anomalies as
indicators of software maintenance eﬀort. However, none
of the aforementioned studies have investigated the relation
between anomaly agglomerations and design problems.
Agglomerations and Design Problems. While many
authors investigated the impact of individual code anoma-
lies, a few studies have focused on inter-related code anoma-
lies. Abbes et al. [1] brought up the notion of interacting
code anomalies and they studied its eﬀects. They concluded
that classes and methods identiﬁed as God Classes andGod
Methods inisolationhadnoeﬀectonmaintenanceeﬀort, but
when appearing together, they led to a statistically signif-
icant increase in maintenance eﬀort. Yamashita and Moo-
nen [44] observed that inter-smell relationships negatively
aﬀect the maintenance. Macia [2] cataloged a set of patterns
of inter-related code anomalies. However, none of these au-
thors studied the impact of inter-related code anomalies on
designproblems, andnoneofthemcharacterizedorexplored
semantic relationships between code anomalies.
Architecturallyconnectedproblems. Therearesome
studies that explored architecturally connected ﬁles to spot
design problems in software systems. Kazman et al. [15] ex-
plored architecturally connected ﬁles to identify and quan-
tify architectural debts in large-scale systems. Similarly to
us, the authors identiﬁed design problems in the systems un-
der analysis. However, we focus on the relation among code
anomalies rather than the architectural connection among
ﬁles. Mo et al. [29] proposed the detection of recurring ar-
chitectural problems (called hotspot patterns) by the combi-
nation of history and architecture information. The hotspot
patterns identify error- and change-prone ﬁles, and pinpoint
speciﬁcarchitectureproblemsthatmaybetherootcausesof
bugs and changes. The author’s strategy to identify design
problems is also based on structural dependencies among
ﬁles. However, we showed that some design problems can-
notberevealedbasedonstructuraldependenciesonly. They
require to taken into account the semantic relation among
anomalous code elements during their identiﬁcation (Sec-
tion 3.3). In addition, the approaches mentioned above rely
on system’s revision history. Consequently, they cannot be
applied to early versions of the systems under analysis.
6. THREATS TO V ALIDITY
ConstructValidity. Themajorriskhereisrelatedtoer-
rorsintheidentiﬁcationofdesignproblemsandcodeanoma-
lies. The original developers reported the lists of design
problems they found to be relevant in their systems. The-
refore, these lists could be inaccurate and include irrelevant
design problems. To mitigate this threat, we recruited de-
velopers with extensive knowledge of their system’s design
and with previous experience on design reviews and source
code inspections. Moreover, we solicited a brief explanation
about the severity of the reported design problems. When-
ever we could not understand the nature and relevance of a
design problem, we asked for further clariﬁcation. We dis-
carded design problems that were not properly explained.
Regarding the code anomalies, we selected detection strate-
gies and thresholds that presented satisfactory results in a
previous study (Section 3.5). In any case, if these strategies
resulted in false positives or false negatives, they would have
asimilareﬀectonthecomputationofalltheagglomerations.
Conclusion Validity. The main threat for conclusionvalidity is the number of evaluated versions of each system.
A study involving several versions of each system is always
desired. However, it was impracticable in our study due to
the number of systems (7) and the limited availability that
original developers and architects had to participate in the
study. We tried to mitigate this threat by selecting, for each
diﬀerent system, versions in a diﬀerent lifecycle stage.
Internal and External Validity. The threats here con-
cern the degree to which the ﬁndings can be generalized to
the wider classes of subjects. In the experiment reported
upon here, these threats are somewhat mitigated by the
factthatweusedsystemswithdiﬀerentsizes, purposes(aca-
demic, commercialandopen-source)anddomains, thatwere
implemented using diﬀerent design styles and that suﬀered
from a diﬀerent set of design problems. Furthermore, the
target systems were developed by teams of diﬀerent sizes
and with diﬀerent levels of software development skills.
7. CONCLUDING REMARKS
Recent empirical studies [23, 24, 25] suggest that individ-
ualcodeanomaliesdonotsuﬃcetoidentifydesignproblems.
This ﬁnding represents a challenge for developers because
they often need to spot design problems exclusively based
on source code analysis, especially because of the lack of up-
to-date design documents [24]. In order to decide whether
and where a relevant design problem is prevailing in the
program, programmers ﬁrst need to know: (i) which are
the code anomalies realizing the design problem, (ii) how
these code anomalies are related to each other, and (iii)
how these anomaly relationships are connected to the de-
sign problem. The gathering of all this scattered knowledge
is time-consuming and error-prone.
In this work, we analyzed to what extent code anomaly
agglomerations can help developers to locate design prob-
lems. We conﬁrmed that code anomalies often “ﬂock to-
gether” in order to embody a design problem. We stud-
ied the relation of design problems with both syntactic and
semantic agglomerations in a longitudinal multi-case study
involving 7 systems. Syntactic agglomerations are relevant
indicators of design problems and help to discard an average
of 600 irrelevant anomalies per system. We also found the
combined use of syntactic and semantic agglomerations rep-
resents a more eﬀective approach for locating design prob-
lems. Many congenital and evolutionary design problems
were only related to semantic agglomerations. Moreover,
a considerable proportion of design problems are congeni-
tal and manifest as agglomerations in the implementation.
This result means that state-of-the-art solutions based on
change history analysis are not adequate to promptly detect
such problems. We plan to perform further investigations
with the twofold goal of: (i) identifying eﬃcient criteria for
ranking code anomaly agglomerations in order to prioritize
critical design problems, and (ii) conceiving a technique to
analysis how anomaly agglomerations relate to each other
throughout the software system histories.
8. ACKNOWLEDGMENTS
WethankprofessorCarlosJoséP.deLucenaandprofessor
Nenad Medvidović for the support during this research. The
research reported here was supported by the Capes Founda-
tion, Ministry of Education of Brazil, FAPERJ and CNPq.
4499. REFERENCES
[1] M. Abbes, F. Khomh, Y.-G. Guéhéneuc, and
G. Antoniol. An empirical study of the impact of two
antipatterns, blob and spaghetti code, on program
comprehension. In Software Maintenance and
Reengineering (CSMR), 2011 15th European
Conference on, pages 181–190, March 2011.
[2] I. M. Bertrán. On the Detection of
Architecturally-Relevant Code Anomalies in Software
Systems. PhD thesis, Pontiﬁcal Catholic University of
Rio de Janeiro (PUC-Rio), Rio de Janeiro, Brazil,
2013.
[3] V. Bloomﬁeld. Using R for Numerical Analysis in
Science and Engineering . Chapman & Hall/CRC The
R Series. Taylor & Francis, 2014.
[4] J. Cornﬁeld. A method of estimating comparative
rates from clinical data; applications to cancer of the
lung, breast, and cervix. Journal of the National
Cancer Institute , 11(6):1269–1275, June 1951.
[5] M. D’Ambros, A. Bacchelli, and M. Lanza. On the
impact of design ﬂaws on software defects. In Quality
Software (QSIC), 2010 10th International Conference
on, pages 23–31, July 2010.
[6] R. A. Fisher. On the interpretation of χ2 from
contingency tables, and the calculation of p. Journal
of the Royal Statistical Society , 85(1):pp. 87–94, 1922.
[7] M. Fowler. Refactoring: Improving the Design of
Existing Code. Addison-Wesley, Boston, MA, USA,
1999.
[8] S. G. Ganesh, T. Sharma, and G. Suryanarayana.
Towards a principle-based classiﬁcation of structural
design smells. Journal of Object Technology , pages
1–29, 2013.
[9] J. Garcia, I. Ivkovic, and N. Medvidovic. A
comparative analysis of software architecture recovery
techniques. In Automated Software Engineering
(ASE), 2013 IEEE/ACM 28th International
Conference on, pages 486–496, Nov 2013.
[10] J. Garcia, D. Popescu, G. Edwards, and
N. Medvidovic. Identifying architectural bad smells. In
Software Maintenance and Reengineering, 2009.
CSMR ’09. 13th European Conference on, pages
255–258, March 2009.
[11] T. Gîrba, S. Ducasse, A. Kuhn, R. Marinescu, and
R. Daniel. Using concept analysis to detect co-change
patterns. In Ninth International Workshop on
Principles of Software Evolution: In Conjunction with
the 6th ESEC/FSE Joint Meeting, IWPSE ’07, pages
83–89, New York, NY, USA, 2007. ACM.
[12] M. W. Godfrey and E. H. S. Lee. Secrets from the
monster: Extracting Mozilla’s software architecture. In
Proc. of the Second Intl. Symposium on Constructing
Software Engineering Tools (CoSET-00) , June 2000.
[13] E. Juergens, F. Deissenboeck, B. Hummel, and
S. Wagner. Do code clones matter? In Software
Engineering, 2009. ICSE 2009. IEEE 31st
International Conference on, pages 485–495, May
2009.
[14] C. J. Kapser and M. W. Godfrey. Cloning considered
harmful" considered harmful: Patterns of cloning in
software. Empirical Softw. Engg., 13(6):645–692, Dec.
2008.[15] R. Kazman, Y. Cai, R. Mo, Q. Feng, L. Xiao,
S. Haziyev, V. Fedak, and A. Shapochka. A case study
in locating the architectural roots of technical debt. In
Proceedings of the 37th International Conference on
Software Engineering - Volume 2, ICSE ’15, pages
179–188, Piscataway, NJ, USA, 2015. IEEE Press.
[16] F. Khomh, M. Di Penta, and Y. GuÃľhÃľneuc. An
exploratory study of the impact of code smells on
software change-proneness. In Reverse Engineering,
2009. WCRE ’09. 16th Working Conference on , pages
75–84, Oct 2009.
[17] F. Khomh, M. D. Penta, Y.-G. Guéhéneuc, and
G. Antoniol. An exploratory study of the impact of
antipatterns on class change- and fault-proneness.
Empirical Software Engineering , 17(3):243–275, 2012.
[18] M. Kim, V. Sazawal, D. Notkin, and G. Murphy. An
empirical study of code clone genealogies. In
Proceedings of the 10th European Software
Engineering Conference Held Jointly with 13th ACM
SIGSOFT International Symposium on Foundations
of Software Engineering, ESEC/FSE-13, pages
187–196, New York, NY, USA, 2005. ACM.
[19] M. Lanza, R. Marinescu, and S. Ducasse.
Object-Oriented Metrics in Practice . Springer-Verlag
New York, Inc., Secaucus, NJ, USA, 2005.
[20] W. Li and R. Shatnawi. An empirical study of the bad
smells and class error probability in the post-release
object-oriented system evolution. Journal of Systems
and Software, 80(7):1120–1128, 2007.
[21] A. Lozano and M. Wermelinger. Assessing the eﬀect of
clones on changeability. In Software Maintenance,
2008. ICSM 2008. IEEE International Conference on ,
pages 227–236, Sept 2008.
[22] A. MacCormack, J. Rusnak, and C. Y. Baldwin.
Exploring the structure of complex software designs:
An empirical study of open source and proprietary
code. Manage. Sci., 52(7):1015–1030, July 2006.
[23] I. Macia, R. Arcoverde, E. Cirilo, A. Garcia, and
A. von Staa. Supporting the identiﬁcation of
architecturally-relevant code anomalies. In Software
Maintenance (ICSM), 2012 28th IEEE International
Conference on, pages 662–665, Sept 2012.
[24] I. Macia, R. Arcoverde, A. Garcia, C. Chavez, and
A. von Staa. On the relevance of code anomalies for
identifying architecture degradation symptoms. In
Software Maintenance and Reengineering (CSMR),
2012 16th European Conference on, pages 277–286,
March 2012.
[25] I. Macia, J. Garcia, D. Popescu, A. Garcia,
N. Medvidovic, and A. von Staa. Are
automatically-detected code anomalies relevant to
architectural modularity?: An exploratory analysis of
evolving systems. In Proceedings of the 11th Annual
International Conference on Aspect-oriented Software
Development, AOSD ’12, pages 167–178, New York,
NY, USA, 2012. ACM.
[26] R. C. Martin. Agile Software Development: Principles,
Patterns, and Practices . Prentice Hall PTR, Upper
Saddle River, NJ, USA, 2003.
[27] C. A. Mattmann, D. J. Crichton, N. Medvidovic, and
S. Hughes. A software architecture-based framework
for highly distributed and data intensive scientiﬁc
450applications. In Proceedings of the 28th International
Conference on Software Engineering, ICSE ’06, pages
721–730, New York, NY, USA, 2006. ACM.
[28] A. K. McCallum. Mallet: A machine learning for
language toolkit. http://mallet.cs.umass.edu, 2002.
[29] R. Mo, Y. Cai, R. Kazman, and L. Xiao. Hotspot
patterns: The formal deﬁnition and automatic
detection of architecture smells. In Software
Architecture (WICSA), 2015 12th Working
IEEE/IFIP Conference on, pages 51–60, May 2015.
[30] N. Moha, Y. Guéhéneuc, L. Duchien, and A. Le Meur.
Decor: A method for the speciﬁcation and detection of
code and design smells. Software Engineering, IEEE
Transactions on , 36(1):20–36, Jan 2010.
[31] W. Oizumi. Opus research group: Supplementary
material, 2015. Availabel at http://www.les.inf.
puc-rio.br/opus/anomaliesFlockTogether.
[32] S. Olbrich, D. Cruzes, and D. I. Sjoberg. Are all code
smells harmful? a study of god classes and brain
classes in the evolution of three open source systems.
InSoftware Maintenance (ICSM), 2010 IEEE
International Conference on, pages 1–10, Sept 2010.
[33] D. E. Perry and A. L. Wolf. Foundations for the study
of software architecture. SIGSOFT Softw. Eng. Notes ,
17(4):40–52, Oct. 1992.
[34] S. Schach, B. Jin, D. Wright, G. Heller, and A. Oﬀutt.
Maintainability of the linux kernel. Software, IEE
Proceedings - , 149(1):18–23, Feb 2002.
[35] R. Schwanke, L. Xiao, and Y. Cai. Measuring
architecture quality by structure plus history analysis.
InProceedings of the 2013 International Conference
on Software Engineering, ICSE ’13, pages 891–900,
Piscataway, NJ, USA, 2013. IEEE Press.
[36] D. Sjoberg, A. Yamashita, B. Anda, A. Mockus, and
T. Dyba. Quantifying the eﬀect of code smells on
maintenance eﬀort. Software Engineering, IEEE
Transactions on , 39(8):1144–1156, Aug 2013.
[37] S. Soares, E. Laureano, and P. Borba. Implementing
distribution and persistence aspects with aspectj. In
Proceedings of the 17th ACM SIGPLAN Conference
on Object-oriented Programming, Systems, Languages,
and Applications , OOPSLA ’02, pages 174–190, New
York, NY, USA, 2002. ACM.
[38] G. Suryanarayana, G. Samarthyam, and T. Sharma.
Refactoring for Software Design Smells: Managing
Technical Debt . Morgan Kaufmann, 2014.
[39] M. Tufano, F. Palomba, G. Bavota, R. Oliveto,
M. Di Penta, A. De Lucia, and D. Poshyvanyk. When
and why your code starts to smell bad. In Proceedings
of the 37th International Conference on Software
Engineering, ICSE ’15, New York, NY, USA, 2015.
ACM.
[40] J. van Gurp and J. Bosch. Design erosion: problems
and causes. Journal of Systems and Software ,
61(2):105 – 119, 2002.
[41] S. Wong, Y. Cai, M. Kim, and M. Dalton. Detecting
software modularity violations. In Proceedings of the
33rd International Conference on Software
Engineering, ICSE ’11, pages 411–420, New York, NY,
USA, 2011. ACM.
[42] L. Xiao, Y. Cai, and R. Kazman. Titan: A toolset
that connects software architecture with qualityanalysis. In Proceedings of the 22Nd ACM SIGSOFT
International Symposium on Foundations of Software
Engineering , FSE 2014, pages 763–766, New York,
NY, USA, 2014. ACM.
[43] A. Yamashita and L. Moonen. Do code smells reﬂect
important maintainability aspects? In Software
Maintenance (ICSM), 2012 28th IEEE International
Conference on, pages 306–315, Sept 2012.
[44] A. Yamashita and L. Moonen. Exploring the impact
of inter-smell relations on software maintainability:
An empirical study. In Software Engineering (ICSE),
2013 35th International Conference on, pages
682–691, May 2013.
[45] T. J. Young. Using aspectj to build a software product
line for mobile devices. Master’s thesis, University of
British Columbia, 2015.
451