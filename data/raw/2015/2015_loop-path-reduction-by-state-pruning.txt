Loop Path Reduction by State Pruning
Jianxiong Gao
Electrical and Computer Engineering
University of Illinois at Urbana-Champaign
Champaign, Illinois, USA
gao2@illinois.eduSteven S. Lumetta
Electrical and Computer Engineering
University of Illinois at Urbana-Champaign
Champaign, Illinois, USA
lumetta@illinois.edu
ABSTRACT
Pathexplosionhasbeenaproblemforsymbolicexecutionforalong
time.Thekeytoavoidpathexplosionistolimitthenumberofpaths
generated within loops while maintaining high code coverage. Full
symbolic execution creates paths for every possible execution path.
Frequently, paths within loops do not contribute to code coverage.
Branches within loops may generate new states at every iteration.
The path explosion problem created by loops often stops symbolic
execution to reach deeper parts of the code.
Inthispaper,weproposeanewpathexplorationmethodthat
reduces the number of states needed to achieve high coverage.Our algorithm limits the number of new states created by first
prioritizingstates,andthenpruningthestatesthatdonotcontribute
to code coverage. Our algorithm does not require loop invariantinference/loop summarization, nor does it bound the number ofiterations of loop exploration. The proposed algorithm can thushandle a broader set of loops than previous approaches. In fact,
our algorithm is orthogonal to loop summarization techniques and
search-guide heuristics, so it complements the current methods.
We have implemented our algorithm using KLEE and tested
with 235 student-generated versions of a classroom assignment.
Our results show that our algorithm helps to achieve the samecoverage with speedup of 11.8
×for 117 out of the 235 programs,
while adding 15% max observed and 2% average overhead over the
50% of programs not benefiting from the technique. The maximum
speedup for a single program is 52.3×.
CCS CONCEPTS
•Software and its engineering →Software testing and de-
bugging;
KEYWORDS
Symbolic Execution, Loop Analysis
ACM Reference Format:
JianxiongGaoandStevenS.Lumetta.2018.LoopPathReductionbyState
Pruning. In Proceedings of the 2018 33rd ACM/IEEE International Conference
on Automated Software Engineering (ASE ’18), September 3–7, 2018, Mont-
pellier, France. ACM, New York, NY, USA, 6pages.https://doi.org/10.1145/
3238147.3240731
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ’18, September 3–7, 2018, Montpellier, France
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.3240731inti,j;
i=0 ;j=0 ;
//A,B: symbolic strings.
while(i< A . s i z e ( )
&& j < B.size()){
if(A[i] = = B[j]){
i++;
j++;}
else{
i=i −j+1 ;
j=0 ;
}
} (a) Substring matching program
if(j = = 1 & & i = = 3){ //Condition C
//Do something
} (b) Condition requires specific paths
Figure 1: Example Program
1 INTRODUCTION
Symbolic execution has been proven to be practical at identify-
ingprogramdefects.Insymbolicexecution,asetofinputsisfirst
marked as symbolic. Starting from an initial state, an interpreter
executes instructions symbolically. The state is updated by the
effect of each instruction. When the execution reaches a branch in-
struction, the conditions Cand¬Care evaluated by an SMT solver.
Whenbothconditionsaresatisfiable,thecurrentstateforksinto
twostates,withcondition Cand¬Caddedtooneofthetwonew
states as a constraint. Each execution state generated corresponds
toadifferentexecutionpath,andisexecutedindependently.The
execution continues until all of the states/execution paths have
terminated, or halts early due to either a time or a memory limit.
Thoughpowerful,thetimeandmemoryresourcesrequiredby
symbolic execution are linear in the number of possible execution
statesinthetestedprogram.Unfortunately,whenloopsarepresent,
thenumberofexecutionstatescanbeexponentialtothenumber
of loop iterations executed. The simple loop example shown in
Figure1a(taken from [ 13]) illustrates this problem: loop explosion.
To enhance symbolic execution, we must find a way to reduce the
time and memory cost of loop execution.
The motivation of our algorithm comes from our application of
symbolicexecutiononstudent-submittedprograms.Weusesym-
bolic execution to determine the correctness of student-submitted
programs,andtoprovidecounter-exampleswhenpossible.Students
can submit theirprograms for testing at anytime, and feedback is
generated within minutes of submission.
Weobservethatthesymbolicexecutiontimeneededtogener-
ate feedback depends heavily on the type of the assignment. For
assignments that require students to write loops, we have to limit
the size of the domain for symbolic variables in order to bound the
loop exploration.
838
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Jianxiong Gao and Steven S. Lumetta
S0
S0
S0
S0S01S00
S00S000S1
S1
S11S1S10
S10S101
Normal State Postponed State Ghost State
Figure 2: Execution Path Tree
The challenge is we need to symbolically explore the loops in
programs to an extent such that most bugs are exposed, while
minimizing the time required to finish symbolic execution. Ouralgorithm only explore loops when necessary to improve code
coverage. By reducing the number of states explored ,wespeedup
symbolic execution while maintaining the same code coverage and
defect detection capabilities.
The key contribution of this paper is that, even with loops that
generate large numbers of possible paths which are difficult to
summarize, we can simply avoid execution of most paths and still
achieve high code coverage. We emphasize that executing all possi-
blepaths througha loopis notthe purposeof symbolicexecution.
Rather,thepurposeistoachievehighcodecoverageandtogenerate
test cases that expose program defects.
We use Figure 1to show that it is not necessary to cover all pos-
sible paths to achieve high coverage. For the example in Figure 1a,
weonlyneedtwoexecutionstates,withoneofthestatesexecuting
throughthe ifbranch,andtheotherstateexecutingthroughthe
elsebranch, to cover the whole loop.
After both branches are explored, in later iterations when the
execution reaches the branch statement again, we can continue
theexecutionononeofthestates,whilekeepingtheotherstates
postponed. We explore the postponed states only when necessary.
By stopping the exploration of the p ostponed states, wecanspeed
up the symbolic execution by orders of magnitude. In the example
execution of 3 iterations shown in Figure 2, instead of exploring
23=8states,weonlyneedtoanalyze2states.Thestates S00,S01,
S10andS11shown in Figure 2are postponed states because the
pathstheycoverhavealreadybeencoveredbystates S0orS1.From
the example we can see that the number of postponed states islinear with the number of explored states. Herein only 2
(n−1)
postponed states are created (but not explored).
Weneedtoexplorethepostponedstatesonlywhenlaterparts
of the program cannot be all covered by the explored states. In
Figure1b,thebranchcanonlybecoveredbyspecificvaluesofiand
j, which depend on the execution result of the loop for a specificstate. With the two states explored initially in Figure 2(
S0and
S1), the code in Figure 1bcannot be covered. In other words, the
condition Cin Figure 1bcannot be satisfied given the 2 explored
states.Ouralgorithmthenpicksonestatefromthepostponedstatesto explore. We pick the state by first checking the constraints ofthe picked state
Csand the target condition C. A state is picked
only when there exists a solution that satisfies both constraints Cs
andC. The picked state is then changed from postponed to normal.
We iteratively repeat the process until the branch is either covered,
or proven uncoverable by exhaustively checking all the postponed
states.
Byusingpostponedstates,wecanachievethesamecodecov-
eragewhileexploringmuchfewerstates.Becausethepostponed
states get explored only when needed, their children states (ghost
states in Figure 2) may not get generated at all.
Therestofthispaperisasfollows:SectionIIbrieflysummarizes
currentloopanalysisalgorithms.SectionIIIdescribesouralgorithm
in detail. Section IV describes our experiments and analyzes the
results. We conclude in Section V.
2 BACKGROUND
2.1 Symbolic Execution
Symbolicexecutionstartsexecutingatargetprogramfromaninitial
executionstate.Aninterpreterexecutesinstructionsbyupdating
theexecution state.At branchinstructions, theconditionsto both
branches are evaluated by an SMT solver. When both condition
constraints are satisfiable, the execution state forks into two states,
withtheconstraintaddedtoeachstate.Anexecutionstatetermi-
nates at any terminal instruction, halt or abort, for example. All
executionstatesareexecutedindependently.Theprocedureends
whenthereareno moreexecutionstatestoexecute.Foreachexe-
cutionstate,asetofinputsthatsatisfiestheconstraintsofthestate
is generated as a test case.
2.2 Loop
In this paper we define loop as a single, strongly-connected sub-
graphofaprogram’scontrolflowgraph(CFG)suchthatthesub-
graphhasasingleentrypointandcontainsnopropersubgraphs
that are strongly-connected but not loops. With the assumption of
thereisno дotostatements,wedefinecyclesasstrongly-connected
componentsintheCFG.Aloopisaspecialkindofcyclethathas
only one entry node. The entry node of a loop is a node that domi-
natesallothernodesinsidetheloop.NodeAdominatesnodeBif
and only if node A belongs to every execution path from the start
node to node B.
Loopscanbenested,inwhichcasewerefertotheinnerloopasa
sub-loop. Loops cannot contain cycles that are not loops. Non-loop
cycles are excluded because the numbers of paths generated by
such CFG elements cannot be bounded. Fortunately, few programs
contain such elements.
We define the set of exit nodes of a loop L as CFG nodes outside
of L that have at least one parent node within L.
2.3 Loop Analysis
There are three main types of techniques discussed in previous
workaboutloopanalysis:LoopSummarization[ 13][11][14][1]
[5][3][2][8][7], Search-GuidingHeuristics [ 10][9][6][12] and
LoopUnwinding[ 4].Loopunwindingisthemostintuitivemethod,
in which each loop is unrolled for a bounded number of iterations.
Loop unwinding ignores any program behavior that occurs only
for iterations beyond the chosen unrolling bound.
839
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. Loop Path Reduction by State Pruning ASE ’18, September 3–7, 2018, Montpellier, France
1Map<Loop,Vector<LoopPath> > LPs
GenLoopInfo(LPs)
3StatePruningSearcher Searcher
Searcher = StatePruningSearcher(initialState)
5While !Searcher.done()
state=Searcher.PickState()
7ExecuteInstruction( state)
endFigure 3: Symbolic Execution Workflow
GenLoopInfo(Map<Loop, Vector <LoopPath> > LPs):
2Foreach Loop L in Program P
If L is not in LPs
4GenLoopPaths(L)
end
6end
GenLoopPaths(Loop L) :
8Foreach InnerLoop IL in L
GenLoopPaths(IL)
10end
vector<BasicBlock> exitNodes = GetExitNodes(L)
12LPs[L].pushback(GetPath(L,exitNodes))
endFigure 4: LoopPaths Initialization
2.3.1 Loop Summarization. Loop summarization uses a few states
toeffectivelyrepresentafamilyofexecutionstates.Eachexecution
path through the loop is summarized as a set of equations. the
exit states of the loop are calculated, with the set of equations, the
executionstateattheentranceoftheloop,theexecutionorderof
each path, and the number of iterations to be executed.
To calculate the number of iterations to be executed, a strong
loop invariant is needed. For the purpose of loop summarization, a
loopinvariantis strongenoughwhenthe numberofiterationsto
beexecutedcanbeinferred,orcalculatedinductivelygivenonly
the symbolic execution state at the entrance of the loop.
Tosummarizealoopwithasetofequations,allpathsthrough
the loop are first summarized. If there is only a single path or
periodically interleaved multi paths through the loop, an exact
equation is produced [ 13]. Otherwise, the equation is approximate.
Howeverloopsummarizationcannotbeappliedgenerallytoall
loops.TheloopinvariantofFigure 1a,forexample,isquitedifficult
(or impossible [ 13]) to find, because the result of the loop depends
ontheorderofexecution,whichinturndependsontheinputarray.
There is simply no pattern on how future execution state would be
basedoncurrentexecutionstate.Thusinordertocoverallpossible
execution states, new execution states still have to be generated
and explored.
2.3.2 Search-guiding Heuristics. Search-guidingheuristicsareused
to generate constraints that can cover specific chunks of code. Jan
andTrtík[ 9][10][6]computedanontrivialquantifier-freeneces-
sary condition on input values. Their technique is based on loop
summariesofpathsthroughtheloop,butaddressesonlysequentialandperiodicloops.Xieetal.[
12]developedatechniquethatusesa
fitness function to measure how close a target node is to a current
path.
Ouralgorithmisorthogonaltosearch-guidingheuristics.Infact,
search-guiding heuristics can be used to prune the states when
possible.Becausesearch-guidingheuristicsarenotthefocusofthis
paper, we used only basic heuritstics for pruning. With integration
of more advanced search-guiding heuristics, the performance of
our implementation can be further improved.1ExecuteInstruction( state):
Instruction ins = ∗state.pc
3BasicBlock bb = ins.parent
If ins == bb.head
5ProcessBasicBlock(bb)
end
7UpdateState(ins ,state)
ReturnFigure 5: Execute Instruction
ProcessBasicBlock(BasicBlock bb)
2If Unvisted(bb)
MarkVisited(bb)
4end
Loop SL = GetCurrentLoop( state)
6If SL
Vector<Ba sicBlock> exitNodes
8exitNodes = GetExitNodes(SL)
If bb in exitNodes
10LoopPath LP = state.sf.Loop Paths.top
LoopPath.pushback(bb)
12If LPs[SL].find( LoopPath)
LPs[SL].remove(LoopPath)
14end
state.sf.LoopPaths.pop()
16SL = GetCurrentLoop(state)
end
18If SL
state.sf.LoopPaths.top.pushback(bb)
20end
end
22If LoopHeadNode(bb)
Loop L = Get Loop(bb)
24If L == SL
LoopPath LP = state.sf.Loop Paths.top
26If LPs[L].find( LoopPath)
LPs[L].remove(LoopPath)
28end
LP.clear()
30Else
LoopPath LP = new LoopPath
32state.sf.LoopPaths.push(LP)
end
34endFigure 6: Process Basic Block
3 ALGORITHM DESCRIPTION
To give an overview of our implementation, our algorithm is dif-
ferent from the current symbolic execution designs in two aspects.
First, we define two types of execution states: normal states and
postponedstates.Normalstatesareexecutedaswithpriority,while
postponedstates are executedonly ifthey might enablecoverage
ofcodethatisotherwiseuncoverable.Westartbysettingtheinitial
state as a normal state. When new states are forked, our algorithm
determines what type of states the forked states are. We explain
the details on type of states in Section 3.4.1.
The second difference is that we stop the symbolic execution
process when two conditions are met: all normal states have termi-
nated, and all coverable code has been covered. A pieceof code is
coverableiftheconstraintsofanypostponedstatescomplywith
the constraints necessary to cover the code.
Figure3shows the workflow of our algorithm. We start by stati-
cally analyzing the program to gather information about loops and
all possible paths through each loop. The pseudo code for staticanalysis is shown in Figure 4and explained in Section 3.2.1.W e
then initialize the StatePruninдSearcher with the initial state. The
840
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Jianxiong Gao and Steven S. Lumetta
searcher determines when to finish execution by the donefunction.
When there is still code to be covered, the searcher picks a state
toexplorebythe PickState function.Whenexecutinganinstruc-
tion, the node and loop path coverage information is updated if
the instruction is the first instruction of its node. The pseudo code
for updating coverage information is shown in Figure 5and6, and
explained inSection 3.3. Newstates are createdat branch instruc-
tionsandaddedtothesearcherbycallingthe AddState functionof
the searcher.The pseudocode for the StatePruninдSearcher class
is shown in Figure 7and explained in Section 3.4.
3.1 Loop Path
Beforewesymbolicallyexecuteaprogram,weinitializetheloop
coverageinformationbysettingallpathsthroughallloopsasun-
visited.Therearetwodifferentpathsinaloop:HeadtoHead(H2H)
paths,orHeadtoExit(H2E)paths.Allpathsstartfromtheentry
node:Head. AnH2H pathis asimplecycle thatstarts andends at
theentrynode,witheachnodeanancestorofthenextnode.An
H2E path starts at the entry node and ends at one of the exit nodes
for the loop, without passing through the entry node again.
3.2 Data Structures Used
To determine the type of a state and when to stop symbolic exe-
cution,someadditionalinformationisstoredinexecutionstates.
3.2.1 List of Loops & Loop Paths. Beforesymbolicexecution,we
findallloopswithinaprogramthroughstaticanalysis(Figure 4).
We then identify all paths through each loop for a single iteration,
starting with innermost loops and working outward (line 10 of
Figure4).TheGetPathfunction(line13)abstractsanyinnerloop
as a switch instruction: the exit nodes of the inner loop are the
branches of the switch instruction. The result is stored in a hash
table, with the loop as the key and all possible paths of the loop as
value.
3.2.2 Loop Path Vector Stack. Thecurrentpathvectorstoresthe
nodes executed from the entry node to the current execution state.
To support nested loops, we use a stack (The state .sf .LoopPaths
variable in Figure 6) to contain information about the current path.
Wheneveraloopisexecuted,theinformationispushedontothe
path vector stack (Figure 6line 33). The loop info is popped off
the stack when the current state exits a loop (Figure 6line 14).
To support function calls, the path vector stack is placed on the
stackframe ( state .sfvariable in Figure 6) for each state. When
functions are called, a new stackframe with an empty loop info
stack is created.
3.3 Update Coverage Information
When the first instruction of a node is symbolically executed (lines
4-6ofFigure 5),wecheckifweneedtoupdatethecoveragestatistics.
Therearetwocoveragestatistics:nodecoverageandpathcoverage.
Ouralgorithmstopsexploringnewstateswhenallcoverablenodes
andpathsarecovered.Westartbycheckingifthenodehasbeen
visitedbefore.Ifnotyet,wethenmarkitasbeenvisited(line2-4
ofFigure 6).Forexecutionofloops,wecategorizethecurrentnode
into three types: entry node, exit node or internal node. Although
anexitnodeEofaloopLisnotpartofL,thelooppathcoverage
statisticshavetobeupdatedwhenEisreached.Anodecanhave
multipletypes.ForexampleanentrynodeofainnerloopcanbeClass StatePruningSearcher{
2private:
vector<State> normalStates
4vector<State> postponedStates
State candidateState
6
public:
8StatePruningSearcher(State s):
normalStates.pushback(s)
10candidateState=NULL
Return
12
Bool done() :
14If normalStates.size()
candidateState= normalStates. pick()
16Return true
end
18candidateState=NULL
Foreach B asicBlock bb in UncoveredFrontier
20Constraint C = getConstraint(bb)
Foreach State s in postponedStates
22Constraint SC = s.constraint
If SMTSolver.solve(SC && C)
24candidateState = s
postponedStates.remove(s)
26normalStates.pushback(s)
Return true
28end
end
30setUncoverable(bb)
end
32Return false
State PickState():
34Return c andidateState
36AddState(State s):
Loop SL = GetCurrentLoop( state)
38
If SL
40LoopPath currentLP = state.sf.Loop Paths.top
Foreach Lo opPath LP in LPs[SL]
42If currentLP == LP[0..cu rrentLP.size()]
normalStates.pushback(s)
44Return
end
46end
postponedStates.pushback(s)
48end
normalStates.pushback(s)
50Return
}Figure 7: StateSearcher
aninternalnodeoftheouterloop;anexitnodeofinnerloopcan
be either an internal node or the entry node of the outterloop.
3.3.1 Entry Node. When we encounter an entry node, there are
two possibilities: this is the first time we encounter the loop, or
wehaveexecutedaH2Hpaththroughtheloop.Wedifferentiate
the two by checking the top of the path vector stack. If the path
vector belongs to the loop of the entry node, a H2H path has been
executed.Inthiscase,wemarktheH2Hpathascovered(line26-28
of Figure 6). Otherwise the execution has entered a new loop, so
we push an empty path vector on to the path vector stack.
3.3.2 Exit Node. When an exit node is visited, we need to check if
thecurrentH2Epathhas beenvisitedornot.Ifnot,theH2Epath
is marked as visited by removing it from LPs, and then popped off
the path vector stack.
841
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. Loop Path Reduction by State Pruning ASE ’18, September 3–7, 2018, Montpellier, France
3.4 StatePruningSearcher
TheStatePruninдSearcher decides when to stop symbolic execu-
tion and which state to explore. The searcher determines if a node
is coverable or not. The symbolic execution stops when there is no
more coverable loop path or node for the current states. When the
searcher decides a node might be covered by a state, the state is
explored further.
3.4.1 Type of State. At branch conditions, if the constraints for
both branches are satisfiable, the current execution state continues
executionononebranch,andanewexecutionstateiscreatedto
cover the other branch. When an execution state forks into two
statesinsidealoop,thetypeofthenewstateisdeterminedusing
loopcoverageinformation.Thenewstateispostponedifthecurrent
pathisnotaprefixofanyuncoveredpath(line41-46ofFigure 7).A
stateispostponedonlyatthetimeofcreation.Normalstatesnever
change into postponed states.
3.4.2 Coverable Node. ThedonefunctionoftheStatePruningSearcher
class determineswhen tostop symbolic execution.The donefunc-
tionfirstchecksiftherearestillnormalstatesthathavenotfinished
execution (line 14-16 of Figure 7). If so, one of the normal states
ispickedbyadefaultsearchalgorithm(BFS,DFS,Interleaveetc.).
When there are no more normal states to explore, the searcher
checks for uncovered nodes.
Insteadoflookingforastatethatcoverstheuncoverednode,we
eliminatethestatesthatarenotabletodoso.The UncoveredFrontier
at line 19 of Figure 7represents uncovered nodes with one of its
ancestors covered. For each frontier node, the constraints to cover
the node is obtained, and checked against every postponed state
(line 19-31 of Figure 7). When the constraints to cover the frontier
nodecontradictswithallthepostponedstates,thenodeissetasun-
coverable and removed from the UncoveredFrontier . A postponed
state is promoted to a normal state if its constraints do not contra-
dict those of the frontier node(lines 25-26 of Figure 7). Once a state
is promoted back to normal state, it is executed normally until the
state halts. By changing the type of state we reduce the number of
times to check constraints with the SMT solver.
3.5 Discussion
The goal of our algorithm is to minimize the execution time while
maintaining the same code coverage. The normal states are the
states that are more likely to cover new nodes than the postponed
states,andthusaregivenpriorityinexecution.Postponedstates
arelesslikelytocontributetocodecoverage.Thedecisionabout
whether a state should be postponed is made at the time of state
creation.
Ouralgorithmisalsoorthogonaltocurrentsearch-guidingheuris-
tics techniques. Our implementation only checks if the constraints
of the target node contradict with the constraints of the postponed
state (line 23 of Figure 7). Search-guiding heuristics can be inte-
grated here to help in picking the right postponed state.
4 EXPERIMENTS
We implemented our design as a modification to KLEE version 1.3,
comparedwithunmodifiedKLEEversion1.3on235programs.Theprogramswerewrittenbystudentsinanintroductoryprogrammingclassasanassignment.Theprogramtookagameboardasanarray
of integers. The assignment asked students to count the number of
Figure 8: Execution Time StatePruning vs KLEE
times the number 1 appeared in the neighboring cells, with a given
location on the game board. We have removed duplicate programs
andprogramsthatdonotcontainanyloop.Theprogramsexamined
contain different numbers of loops, from 1 to 19. Students were
encouraged but not required to write nested loops.
ThenormalexecutionuseddefaultKLEEsettings.Thetimelimit
was set to 300 seconds for both configurations. For each configura-
tion,wesymbolicallyexecutedthetargetprogramthreetimes.The
data of the fastest execution was used.
4.1 Experiment Results
4.1.1 Validity. The number of branches covered for all different
configurationswasthesame.Tovalidateourresult,thetestcases
generated were used to re-execute the program. For all different
configurations, the decision was the same: either all tests passed or
bugdetected.Foralltheprogramswetested,allbugsdiscovered
were the same.
4.1.2 Runtime StatePruning vs KLEE. Wefirst comparetheexecu-
tiontimeofourimplementation(denotedStatePruning)withthe
unmodified KLEE (denoted KLEE). The result is shown in Figure 8.
From the figure we can see that for a large cluster of programsnear the y axis, StatePruning finishes execution in less than 25seconds, while KLEE takes from 25 to 150 seconds. For a secondcluster of programs along the
y=xaxis, StatePruning does not
improve performance. A couple of points lay near the y=300
border implied by the time limit (not includingKLEE termination
time). For three such programs, StatePruning finishes within 50
seconds, while KLEE times out.
The cluster near the y axis contains 117 different programs. The
maximumspeedupis52.3 ×.KLEErequiredatotalof8275.2seconds
tofinishwhileStatePruningrequired699.8seconds,speedingup
total execution time for the batch by 11.8×.
The execution time for all 235 programs is 17880.6 seconds, and
9583.8secondswith StatePruning.Theminimumspeedup (a slow-
down) for any program was 0.87×.
4.1.3 Number of States Explored StatePruning vs KLEE. We also
compared the number of states created by StatePruning and KLEE.
TheresultisshowninFigure 9.Thesizeofthepointsrepresentsthe
numberofprogramsatthepoint.From thefigurewecanseethat
842
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Jianxiong Gao and Steven S. Lumetta
Figure 9: Number of states explored StatePruning vs KLEE
Table 1: Number of loops for programs with 416 states in
KLEE and fewer than 205 StatePruning states
#o fL oo p s 1236891014151819
# of Programs 254331122121
a number of KLEE executions saturate at 416, 736 and 832 states.
The two programs to the right of the y=xline at (833,603) and
(568,468) both time out for both configurations.
There are 72 programs with 416 KLEE execution states and less
than 205 StatePruningexecution states. The number of loops con-
tained in these 72 programs is provided in Table 1. Most programs
havetwoloops,withthecodestructuresimilartotheoneprovided
in Figure 10.
Along the line y=x, there is a cluster of programs at the point
(416,416).ThedetaileddistributionofloopsislistedinTable 2.The
code structure is similar to the one provided in Figure 11, but with
a difference in the ordering of conditions. The result is that one of
thepaththroughthe loopisuncoverable, causingtheStatePruning
execution to exhaust every possible state, ending up with the same
number of states as the unmodified KLEE execution.
1foreach row around cell
ifrow within bound
3foreach col around cell
ifcol within bound
5ifnot self cell
ifvalue == 1
7 count++
Figure 10:
Common Structure1foreach row around cell
foreach col around cell
3ifnot self cell
ifrow within bound
5ifcol within bound
ifvalue == 1
7 count++
Figure 11:
Alternative Structure
5 CONCLUSION
Loop analysis for symbolic execution has been discussed in numer-ouspapersinthecontextofloopsummarization.Ourcontributionistotackletheproblemfromanotherangle.Insteadoftryingtocover
all the possible execution states, we try to only cover states that
contributetotheverificationoftheprogram.Wehaveimplementedouralgorithmandtestedouralgorithmover235realprograms.Our
experiment shows that we can achieve 11.8 ×speedup over half of
the tested programs, while maintaining 15% max observed and 2%Table 2: Number of loops for programs with 416 states in
KLEE and 416 StatePruning states
#o fL oo p s 12818
# of Programs 32722
average overhead over the 50% of programs not benefiting from
the technique.
The reduced execution time helps us to verify more programs
withinalimitedtime.Hereatouruniversitywehaveasystemto
check student submissions and provide feedback to them. Students
can submit their programs any time and expect to get feedback
within minutes. Many of the assignments use arrays as input data:
pictures, maps, game boards, etc. The reduction on loop execution
time is vital for our system to better support the students.
Wealsobelievethatourcurrentimplementationhasnotachieved
thefullpotentialofstatepruning.Thereareseveralfurtherpotential
improvementsthatcanbedone.Onedirectionforfutureworkis
to extend our work on state pruning methods. Another important
topicistodetectuncoverablepathsthroughloopmoreefficiently
to provide support for a larger family of programs.
REFERENCES
[1]Juan P. Galeotti, Carlo A. Furia, Eva May, Gordon Fraser, and Andreas Zeller.
2015. Inferring Loop Invariants by Mutation, Dynamic Analysis, and Static
Checking. IEEE Transactions on Software Engineering 41,10(oct2015),1019–1037.
https://doi.org/10.1109/TSE.2015.2431688
[2]Patrice Godefroid. 2012. Test Generation Using Symbolic Execution. DROPS-
IDN/3845 18 (jan 2012). https://doi.org/10.4230/LIPICS.FSTTCS.2012.24
[3]Patrice Godefroid and Daniel Luchaup. 2011. Automatic partial loop summa-rization in dynamic test generation. In Proceedings of the 2011 International
Symposium on Software Testing and Analysis - ISSTA ’11.ACMPress,NewYork,
New York, USA, 23. https://doi.org/10.1145/2001420.2001424
[4]StefanHuster,SebastianBurg,HannoEichelberger,JoLaufenberg,JürgenRuf,
ThomasKropf,andWolfgangRosenstiel.2015. EfficientTestingofDifferentLoop
Paths. Springer, Cham, 117–131. https://doi.org/10.1007/978-3-319-22969-0_9
[5]YudeLin,TimMiller,andHaraldSondergaard.2015. CompositionalSymbolic
Execution Using Fine-Grained Summaries. In 2015 24th Australasian Software
Engineering Conference. IEEE, 213–222. https://doi.org/10.1109/ASWEC.2015.32
[6]Jan Obdrzálek and Marek Trtík. 2011. Efficient Loop Navigation for Symbolic
Execution.. In ATVA, Vol. 11. Springer, 453–462.
[7]Prateek Saxena, Pongsin Poosankam, Stephen McCamant, and Dawn Song. 2009.
Loop-extended symbolic execution on binary programs. In Proceedings of the
eighteenth international symposium on Software testing and analysis - ISSTA ’09.
ACM Press, New York, New York, USA, 225. https://doi.org/10.1145/1572272.
1572299
[8]StephenF.SiegelandTimothyK.Zirkel.2012. LoopInvariantSymbolicExecution
for Parallel Programs. Springer, Berlin, Heidelberg, 412–427. https://doi.org/10.
1007/978-3-642-27940-9_27
[9] Jan Strejček and Marek Trtík. 2012. Abstracting path conditions. In Proceedings
of the 2012 International Symposium on Software Testing and Analysis - ISSTA 2012.
ACM Press, New York, New York, USA, 155. https://doi.org/10.1145/2338965.
2336772
[10]MarekTrtík.2011. AbstractingPathConditionsforEffectiveSymbolicExecution.
(dec 2011). arXiv:1112.4703 http://arxiv.org/abs/1112.4703
[11]XieXiaofeiandXie.2016. Staticloopanalysisanditsapplications.In Proceedings
of the 2016 24th ACM SIGSOFT International Symposium on Foundations of SoftwareEngineering - FSE 2016.ACMPress,NewYork,NewYork,USA,1130–1132. https:
//doi.org/10.1145/2950290.2983972
[12]Tao Xie, Nikolai Tillmann, Jonathan de Halleux, and Wolfram Schulte. 2009.
Fitness-guidedpath explorationin dynamicsymbolicexecution. In Dependable
Systems & Networks, 2009. DSN’09. IEEE/IFIP International Conference on.IEEE,
359–368.
[13]Xiaofei Xie, Bihuan Chen, Yang Liu, Wei Le, and Xiaohong Li. 2016. Proteus:
computingdisjunctive loopsummaryvia pathdependency analysis.In Proceed-
ings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of
Software Engineering - FSE 2016.ACMPress,NewYork,NewYork,USA,61–72.
https://doi.org/10.1145/2950290.2950340
[14]XiaofeiXie,YangLiu,WeiLe,XiaohongLi,andHongxuChen.2015. S-looper:
automaticsummarizationformultipathstringloops.In Proceedings of the 2015
International Symposium on Software Testing and Analysis - ISSTA 2015.ACMPress,
New York, New York, USA, 188–198. https://doi.org/10.1145/2771783.2771815
843
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. 