Rethinking Pointer Reasoning
in Symbolic Execution
Emilio Coppa, Daniele Cono D’Elia, and Camil Demetrescu
Department of Computer, Control, and Management Engineering
Sapienza University of Rome, Italy
{coppa, delia, demetres}@dis.uniroma1.it
Abstract —Symbolic execution is a popular program analysis
technique that allows seeking for bugs by reasoning over multiple
alternative execution states at once. As the number of states to
explore may grow exponentially, a symbolic executor may quickly
run out of space. For instance, a memory access to a symbolicaddress may potentially reference the entire address space,
leading to a combinatorial explosion of the possible resulting
execution states. To cope with this issue, state-of-the-art executorsconcretize symbolic addresses that span memory intervals larger
than some threshold. Unfortunately, this could result in missing
interesting execution states, e.g., where a bug arises.
In this paper we introduce M
EMSIGHT , a new approach to
symbolic memory that reduces the need for concretization, henceoffering the opportunity for broader state explorations and moreprecise pointer reasoning. Rather than mapping address instances
to data as previous tools do, our technique maps symbolic
address expressions to data, maintaining the possible alternative
states resulting from the memory referenced by a symbolic
address in a compact, implicit form. A preliminary experimentalinvestigation on prominent benchmarks from the DARPA Cyber
Grand Challenge shows that M
EMSIGHT enables the exploration
of states unreachable by previous techniques.
Blessed are the forgetful, for they get the better even of
their blunders.
Friedrich Nietzsche
I. I NTRODUCTION
Symbolic execution is a technique for program property ver-
iﬁcation largely employed in the software testing and security
domains [1]. By taking on symbolic rather than concrete inputvalues, multiple execution paths can be explored at once, witheach path describing the program’s behavior for a well-deﬁnedclass of inputs. Nonetheless, the number of paths to explorecan be prohibitively large, e.g., in the presence of unbounded
loops, or when a pointer to be dereferenced is represented by
a symbolic expression. We base our discussion on the simplerunning example reported in Figure 1.
1:void bomb(char *a, char i, char j) {
2: char boom;
3: a[i] = 23;
4: if (a[j] == 23) boom = 0;
5: else boom = 1;
6: assert(!boom);
7:}
Fig. 1. Motivating example: can we defuse the bomb?The function takes as inputs an array aand two indexes i
andj. We assume that acan point to a large memory area,
possibly the whole memory, and we do not pose any constraintoniandj. We are interested in characterizing inputs that
defuse the “bomb”, i.e., that do not trigger the assert
statement. Previous research and state-of-the-art tools typicallymodel memory as a mapping between concrete addresses andexpressions over concrete and symbolic values. In this setting,different scenarios become possible for handling a symbolicaddress when referencing memory.
A symbolic executor can concretize an address by using
one valid model for the symbolic expression under the currentpath constraints. This strategy naturally arises for instancein dynamic test generation, in which values from a concreteexecution are maintained at the same time. Previous researchhas however pointed out that concretization can fail to exerciseprogram branches and paths [2]. On the other hand, treating thememory as fully symbolic would allow an executor to reason
about all possible addresses either by forking the execution to
account for each concrete address matching an expression, or
by capturing the uncertainty on the address through nested ite
(i.e., if-then-else) expressions over its possible values.
Unfortunately, fully symbolic memory as described above
hardly scales in practice. Hence, state-of-the-art executors
often trade performance for soundness by implementing apartial memory model in which writes are always concretized,
while reads are modeled as in fully symbolic memory only in
the face of a manageable number (e.g., up to 1024 in [3]) ofpossible address values, and concretized otherwise.
To simplify the discussion of our example, let us assume that
the involved memory is initially zero-ﬁlled, so to avoid bombdefusing from pre-existing storage. Full concretization of both&a[i] and&a[j] would likely result in an assertion failure,
unless the same value is used for iandj. A partial memory
model would concretize the symbolic read too, as the memory&a[j] spans is large. Even when calling-context information
yields intervals of manageable size, the symbolic read a[j]
would account for each a+j address instance individually,
leading the executor to ﬁnd only one bomb-defusing input,i.e., the one in which concrete address a+j equals the value
chosen for a+i by the write concretization strategy. A fully
symbolic approach would instead reveal the property that allinputs in which i==j holds defuse the bomb.
978-1-5386-2684-9/17/$31.00 c/circlecopyrt2017 IEEEASE 2017, Urbana-Champaign, IL, USA
T echnical Research - New Ideas613
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:08:29 UTC from IEEE Xplore.  Restrictions apply. Fig. 2. Symbolic execution of the bomb example of Figure 1. Expressions &a,&i, and &jdenote the concrete addresses of the corresponding variables. The
bomb does not detonate only if the assert succeeds, i.e., if v/prime=0, that isv=2 3 , which happens for instance if αi=αj.
Contributions. In this work we discuss a different perspec-
tive in the design of symbolic pointer reasoning: we show
how to compactly associate values with symbolic addressexpressions rather than concrete addresses, and investigate
efﬁcient implementations of a fully symbolic memory usingapaged interval tree. Our approach, which we call M
EM-
SIGHT , natively accounts for state merging [4] – a mainstream
performance enabler in modern executors – and has been
integrated in the ANGR [5] framework. Preliminary results
show that M EMSIGHT allows for broader state exploration
on prominent benchmarks, revealing behaviors that previoustechniques would miss or use too much resources to identify.
II. T
ECHNIQUE
To illustrate how M EMSIGHT works, we start from a simple
base version and then we reﬁne it to make it more generaland efﬁcient in practice. We target a general setting in whicha symbolic engine maintains for each explored state a set of
path constraints πreﬂecting path choices taken at each branch
based on the values of symbolic inputs. An SMT solver is
invoked to check for path feasibility at branch instructionsand to retrieve models for symbolic values and expressions,e.g., to apply concretization. Data is stored in a memory objectaccessible through load and store operations over expressions
describing addresses. Unless otherwise stated, we assume thatall addresses and values are expressions over concrete and/orsymbolic terms. Furthermore, an engine may decide to merge
the effects from multiple paths into one to seek for efﬁciency,thus requiring a merge of the respective memories as well.
A. Base V ersion
We model symbolic memory Mas a set of tuples (e,v,t,δ ),
whereeis an expression that denotes an address and vis an
expression that denotes the value at address e. Attribute tis
the logical time at which the tuple was created and is used
by load operations to determine the latest value written at agiven address. To support merge of memories, we account for a
predicate δreﬂecting speciﬁc conditions under which the tuple
is valid:δis typically computed by the executor in terms of
diverging path constraints between the states to be merged.
The base version of our symbolic memory data structure is
shown in Algorithm 1. To explain how it works, consider againthe example of Figure 1. In order to determine whether thereis any bomb-defusing input, we set up a symbolic executor to
associate pointer awith symbolic value α
aand indexes iand
jwith symbolic values αiandαj, respectively.
The program’s effects on the symbolic state are illustrated
in Figure 2. To keep track of logical time, the state includes
a timertthat starts at zero. Initially, the memory Mincludes
the address-value mappings resulting from parameter passing.For the sake of compactness, we denote tuple (e,v,t,δ )as
e/mapsto→v|
δ=...
t=..., omitting tift=0, andδifδ=true.
Algorithm 1 MEMSIGHT – base version
M :=symbolic memory (initially empty)
t :=timer (initially 0)
1:function STORE (e,v):
2:t←t+1
3:M←M∪{(e,v,t,true) }
1:function LOAD (e):
2:v←0
3: forx∈Mby ascending timestamp do
4: v←ite(e=x.e∧x.δ, x.v, v )
5: returnv
1:function MERGE (δ,Sother,δother,ta):
2: for{x∈M|x.t > t a}do
3: M←M|x.δ←x.δ∧δ
4: for{x∈Sother.M|x.t > t a}do
5: x.δ←x.δ∧δother
6: M←M∪{x}
7:t←max(t,Sother.t)
614
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:08:29 UTC from IEEE Xplore.  Restrictions apply. 1) Memory Loading and Storing: To perform a[i] =
23, the program ﬁrst loads the values of variables aandi.
Aload(e)operation (Algorithm 1) builds an iteexpression
that attempts to match eagainst all addresses previously
assigned in M, considering the most recent tuples ﬁrst.
The “else” case of the innermost iteaccounts for unini-
tialized memory locations, which for the sake of simplicity
we consider set to zero by default in this base version. In
our example, load( &a) yieldsite(&a=&a,αa,ite(&a=
&i,αi,ite(&a=&j,αj,0))), which can be simpliﬁed to αa.
Similarly, load( &i) yieldsαi. The assignment is done by a
store(αa+αi,23)operation that adds (αa+αi,23,1,true ),
i.e.,αa+αi/mapsto→23|t=1,t oM after updating t.
The test if (a[j]==23) performs a load(αa+αj)
operation, which constructs an iteexpression vthat selects
the appropriate value at address αa+αj. This is done by ﬁrst
matching αa+αjagainst the most recent written symbolic
address, i.e., αa+αi, and later considering parameters &a,
&i, and &j. The execution then forks off a new state Sother =
{Mother,tother}for the “then” branch, where Mother is a
clone ofMandtother =t. This branch is taken iff v=2 3 .
2) State Merging: As the value of the boom variable de-
pends on the taken branch, a merge operation (Algorithm 1)
reconciles the states by fusing MandMother intoM. The
operation takes four parameters: δ=(v/negationslash= 23) is the path
condition of the “else” branch that kept on working on M;
Sother is the state resulting from the “then” branch, while
δother =(v= 23) is its path condition; ﬁnally, ta=1
is the timestamp of the least common ancestor of the two
branches. The merge updates all tuples added to Msince
the branch point at time taby guarding them with the “else”
branch condition δ(lines 2–3), and then adds to Mall tuples
added to Mother sinceta, guarding them with the “then”
branch condition δother (lines 4–6). In our example, this results
in tuples &boom/mapsto→1|δ=(v/negationslash=23)
t=2 and&boom/mapsto→0|δ=(v=23)
t=2
present in Mafter merging the states (Figure 2).
Finally, the program loads and returns the value of boom,
building the (simpliﬁed) expression v/prime=ite(v=2 3,0,1).
Symbolic execution can therefore conclude that any model of
v/prime=0, e.g., such that αi=αj, will defuse the bomb.
B. Reﬁnements
In its initial naive formulation, the proposed scheme suffers
from a few generality and performance issues. We discuss anumber of reﬁnements that lead to Algorithm 2.
1) Address Range Selection: One of the main drawbacks
of Algorithm 1 is that load andmerge operations need to
scan the entire memory, which can be highly time and space-consuming. We note that it is common for a symbolic addressto be constrained within a certain interval [3]. Hence, a moreeffective approach is to index each tuple (e,v,t,δ )with the
smallest range [a,b] that includes all possible values ecan
attain (line 6 of store in Algorithm 2). The range can be
computed by the SMT solver (lines 2–3). A load(e)operation
can therefore scan just the tuples whose ranges intersect withthe minimum and maximum values of e(lines 2–3, 8).2) Memory Cleanup: Algorithm 1 naively adds one tuple
at each store. A useful improvement is getting rid of older
tuples that are no longer needed: one approach is to remove
a tuple if its address is “equivalent” to the one being written(line 5 of store in Algorithm 2), i.e., they lead to the same
concrete address for any possible valuation of symbols.
3) Symbolic Uninitialized Memory: Identifying how a pro-
gram may behave when accessing uninitialized memory re-gions is crucial for testing and vulnerability exploitation. Inour base version, we have assumed that an uninitialized cellholds zero, which limits the precision of the analysis. Theload(e,v)operation of Algorithm 2 supports symbolic unini-
tialized memory by performing an implicit store that assigns a
new symbol to address eifeis not fully “covered” by address
expressions already in M(lines 4–6). A subtle issue is how
to make sure that accessing an uninitialized memory address
consistently yields the same symbolic value. More precisely,for any two load(e)=vandload(e
/prime)=v/primeoperations,
ifγis a valuation of symbols such that γ|=e=e/prime=x
and address xis uninitialized, then γ|=v=v/prime. To achieve
this property, we use a tie-breaking strategy based on negativetimestamps for tuples created by implicit stores. Observe thatour treatment of uninitialized memory shares similarities with
Algorithm 2 MEMSIGHT – improved version
M :=symbolic memory (initially empty)
π :=current path constraints
t :=positive timer (initially 0)
¯t :=negative timer (initially 0)
sat(ψ) /defines∃γ:γ|=ψ
equiv (e,e/prime,π)/definessat(e/negationslash=e/prime∧π)
range (M,a,b )/defines{x∈M|[x.a,x.b] ∩[a,b]/negationslash=∅}
1:function STORE (e,v):
2:a←min(e,π)
3:b←max(e,π)
4:t←t+1
5:M←M\{x∈range (M,a,b )|equiv (e,x.e,π )}
6:M←M∪{(a,b,e,v,t,true) }
1:function LOAD (e):
2:a←min(e,π)
3:b←max(e,π)
4: ifsat(π∧(∧x∈range (M,a,b )e/negationslash=x.e)) then
5: ¯t←¯t−1
6: M←M∪{(a,b,e,new symbol, ¯t,true)}
7:v←0
8: forx∈range (M,a,b )by ascending timestamp do
9: v←ite(e=x.e∧x.δ, x.v, v )
10: returnv
1:function MERGE (δ,Sother,δother,ta,¯ta):
2: for{x∈M|x.t > t a∨x.t < ¯ta}do
3: x.δ←x.δ∧δ
4: for{x∈Sother.M|x.t > t a∨x.t < ¯ta}do
5: x.δ←x.δ∧δother
6: M←M∪{x}
7:t←max(t,Sother.t)
8: ¯t←min( ¯t,Sother.¯t)
615
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:08:29 UTC from IEEE Xplore.  Restrictions apply. how constraint solvers deal with uninterpreted functions.
4) Multi-byte Load and Store: The solutions presented
in this section work with 1-byte memory objects. Multi-
byte operations can be supported by issuing separate store
andload operations for individual bytes and combining
the results. For instance, a load(e,sizeof(int)) can be
obtained by concatenating the values produced by load(e),
load(e+1 ) ,load(e+2 ) , and load(e+3 ) . This strategy
is adopted in several symbolic executors (e.g., KLEE1[6]).
C. Discussion
Previous work [2] hinted that certain bugs can only be
revealed when writes are modeled symbolically. However,classic approaches may not scale. For instance, [7] remarksthat “a repeated read and write using the same symbolic indexwould result in a quadratic increase in symbolic constraints or[...] the complexity of the stored symbolic expressions”.
Our solution offers a more compact encoding that does
not require an explicit enumeration – a possibly expensivetask for a solver [3] – of valid addresses to either fork thestate or build iteexpressions (Section I). As we discuss next,
range intersection operations can be ofﬂoaded to efﬁcient datastructures. Our example also suggests that reasoning overexpressions allows for an easier input class characterization.
III. I
MPLEMENTATION
In this section we describe a prototype implementation of
MEMSIGHT as a plugin of ANGR . We start by presenting
ANGR , and then describe the techniques implemented in our
prototype while seeking for efﬁciency.
A.ANGR
ANGR [5] is an open-source framework for binary analysis.
It provides a powerful platform-agnostic symbolic execution
engine that reasons on VEX bytecode and relies on Z3 asSMT solver.
ANGR recently participated in the DARPA Cyber
Grand Challenge and has received considerable attention from
many reverse engineering and security practitioners.
ANGR adopts a partial memory model in which iteexpres-
sions are constructed for a symbolic read if the spanned rangeis not too large. Z3 is queried for the maximum and minimum
values that the address can assume, and if they differ at mostby 1024,
ANGR will ask Z3 to enumerate all the solutions
and construct an iteaccordingly, otherwise the address will
be concretized. Optionally, write addresses can be treated assymbolic too, with a default threshold of 128 for range size.
In order to relieve the solver from the burden of repeated
queries and improve efﬁciency, a number of optimizations areimplemented in the
CLARIPY constraint-solving wrapper. To
improve scalability, ANGR implements an extended veritesting
merging strategy [4] that analyzes the control ﬂow graph todetermine at which places is proﬁtable to condense the effectsof separate chunks of code using iteconstraints.
1https://github.com/klee/klee/blob/master/docs/overview.B.MEMSIGHT Prototype
We devise M EMSIGHT as a plugin2implementing the mem-
ory abstraction required by the SIMUVEX symbolic engine of
ANGR , so it can easily be interchanged with the default plugin
for partial memory modeling. As the abstraction explicitlyaccounts for a merging primitive, strategies such as veritesting
can run on top of M
EMSIGHT with no extra effort required.
The ﬁrst practical challenge we have to overcome is sup-
porting range operations from Algorithm 2 efﬁciently. One
possibility is to maintain an interval tree to allow for efﬁcient
retrieval of all stored intervals that overlap with a given one.However, we should keep in mind that when a branch isencountered, an executor typically clones the state along withthe associated memory. To allow better space usage, we thuspropose a memory-wise paged interval tree. We partition the
address space in pages: a primary interval tree built on topof page indexes holds pointers to secondary interval trees thatcontain the tuples in M. Each tuple is contained in exactly
one secondary tree. The page size is empirically determinedto minimize the maximum tree size in the data structure. Boththe primary and the secondary trees are maintained using acopy-on-write strategy that minimizes the need for cloningand promotes memory sharing among different states.
Another crucial aspect to take into account is that the ma-
jority of memory accesses in a symbolic exploration typically
happen on concrete addresses. Capturing concrete stores in
an interval tree would result in maintaining information about
many ranges of size 1. We thus extend our representation witha concrete memory object that associates concrete addresseswith expressions representing values. Each expression is an-notated with a timestamp, so it can possibly be combined withvalues mapped to symbolic addresses during a load operation.For the sake of efﬁciency, concrete memory is implementedas a paged hashmap with copy-on-write cloning for pages,similarly as in
ANGR ’s default memory implementation.
IV . E V ALUATION
In this section we report on a preliminary investigation
of the practical impact of M EMSIGHT compared to previous
memory representations for symbolic execution.
A. Experimental Setup and Methodology
Our experiments are based on benchmarks from the Cromu-
lence (CROMU) DARPA performer group of the Cyber Grand
Challenge (CGC). Tests were conducted on a server equippedwith an Intel
R/circlecopyrtXeonR/circlecopyrtCPU E5-2630 v3 @ 2.40GHz with
16 cores and 64 GB RAM, running Linux CentOS 6.7. We
compare M EMSIGHT against three different ANGR memory
concretization strategies: 1) ANGR -CONC , which concretizes
all accessed symbolic addresses, 2) ANGR -PART (the default of
ANGR ), which concretizes all read addresses that span ranges
larger than 1024 and all written addresses, and 3) ANGR -FULL ,
2Our prototype was tested in ANGR v5.6 and is available at: https://github.
com/season-lab/memsight. Creating it has required a substantial implemen-
tation effort due to its complex interplay with the different layers of ANGR .
Along the way, we have discovered and ﬁxed a few subtle bugs in ANGR .
616
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:08:29 UTC from IEEE Xplore.  Restrictions apply. symbolic
store
Fig. 3. Example of symbolic store excerpted from the CROMU 00006 Cyber Grand Challenge benchmark.
which performs no address concretizations by raising the read
and write thresholds to an inﬁnite value.
We symbolically execute M EMSIGHT ,ANGR -CONC ,
ANGR -PART , and ANGR -FULL on the CROMU benchmarks
with a budget of 2 hours and 32 GB of RAM. To characterize
the breadth of the exploration enabled by the memory model
in use, we measure the number of explored paths. To makea meaningful comparison across different memory models, inour experiments symbolic execution explores states in roundsusing a ﬁrst-in-ﬁrst-out strategy: a new round starts only when
all states in the previous round have been explored. Hence, at
any round the set of explored paths with some concretizationstrategy is always a subset of the paths that would be exploredby performing fewer concretizations.
B. Case Study
We now discuss a real-world code example that shows how
M
EMSIGHT can maintain fully symbolic addresses in a con-
text where previous techniques are instead forced to concretize
them. CROMU 00006 is a service included in the DARPA
CGC suite that produces random numbers and generates chartsfor numeric data, including bar charts and sparklines. Thebenchmark dereferences pointers that span very large portionsof the address space. This arises for instance in functionread_data shown in Figure 3, which ﬁlls a buffer data
of symbolic size datum_cnt with values read from the
input. An inspection of the x86 binary code reveals thatthe dynamic stack allocation uint32 data[datum_cnt]
(line 2) makes the stack pointer register esp symbolic. Later
in the code (line 6), parameter passing on stack to functionread causes a store to the symbolic esp. The range of
possible addresses esp can assume at that point is as large
as 262,128 due to previous constraints on the maximum stacksize imposed by the program. This triggers concretization in
ANGR -PART , forcing the symbolic execution to reason on a
buffer of ﬁxed size3. Since the symbolic range for esp is very
large, ANGR -FULL fails to produce a result due to excessive
resource consumption. In contrast, M EMSIGHT keeps esp
symbolic, considering in the analysis all possible sizes of thedata buffer. As conﬁrmed by our experiments, the ability to
3We observed that, since the stack grows downward and ANGR concretizes
symbolic writes by default using the maximum possible address, then the
analysis ends up reasoning on the smallest, rather than the largest buffer size.
A segment-dependent concretization strategy would yield better results here.consider a buffer of variable size impacts the breadth of the
exploration, allowing M EMSIGHT to push symbolic execution
through states that remain hidden to ANGR -PART .
C. Experiments
The ﬁrst question we address is: how broad are the symbolic
address dereferences performed by the CROMU benchmarks?
To this aim, we measure the range of symbolic loads andstores throughout the analysis. This is a structural property of
the considered benchmarks independent of the chosen memorymodel. The left half of Table I reports the total number ofmemory accesses to a symbolic address with a range size
larger than 1 (# C
ONCR ) and the maximum size of the ranges
of symbolic addresses accessed by load and store operations
throughout the execution. Notice that for some benchmarksthe ranges are much larger than the thresholds one can affordto use in practice in partial memory models.
Our second question is: to what extent does concretization
restrict state explorations? The right part of Table I comparesthe number of distinct control ﬂow paths explored by thememory models we considered. To allow direct comparison,
the snapshot of the number of paths is taken at the same
exploration depth Kfor the same benchmark in all memory
versions. We ﬁrst observe that full concretization (
ANGR -
CONC ) may restrict the number of explorable paths, conﬁrming
the ﬁndings reported in [2], [3]. We also note that for somebenchmarks that exhibit large ranges for symbolic addresses, a
partial memory model (
ANGR -PART ) does not capture all ex-
plorable paths. Explicit fully symbolic memory ( ANGR -FULL )
fails to complete due to excessive resource requirements. Full
exploration is instead supported by M EMSIGHT , which can
visit a larger portion of the execution state space.
V. R ELATED WORK
A number of projects have addressed the problem of model-
ing symbolic pointers. The memory model of EXE [8] allowssymbolic reads by emulating pointers as offset referencesto array objects; concretization is used for multiple pointerdereferences, while symbolic writes are not discussed in detail.
KLEE [6] implements a similar strategy, but clones the
execution state when a pointer can refer to multiple objects,constraining the pointer to be within a single object in a clone.
SAGE [2] takes advantage of concrete values from dynamic
test generation to support symbolic pointers, conﬁning them
617
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:08:29 UTC from IEEE Xplore.  Restrictions apply. TABLE I
PRELIMINARY EXPERIMENTS ON THE CROMU C YBER GRAND CHALLENGE BENCHMARKS .
BENCHMARK #C ONCRMAX RANGE SIZE #P A T H SA TR O U N DK
LOAD STORE K ANGR -CONC ANGR -PART ANGR -FULL MEMSIGHT
CROMU_00001 230 0 9 481 1845 1845 2466 2466
CROMU_00006 6 24 262128 316 9 31 failed 34
CROMU_00009 638 8 9 1534 1131 1131 1715 1715
CROMU_00014 1800 0 9 1512 2251 2251 2315 2315
CROMU_00018 1696 400 770048 924 80 98 failed 433
CROMU_00024 1902 32 32 327 1563 1563 1980 1980
CROMU_00027 771 92 3888 3522 2142 2142 2192 2192
CROMU_00031 126 2295 56 899 299 1413 1413 1413
CROMU_00032 193 576 8192 642 3 3 51 51
CROMU_00033 1010 1020 1020 364 508 508 539 539
within the memory regions in which the corresponding con-
crete values fall. The work also discusses the relevance ofmultiple pointer dereferences and symbolic writes in testing.
MAYHEM [3] introduces partial memory modeling, and
proposes a number of clever optimizations such as value-
set analysis [9] and ﬁne-grained query caching to reduce the
burden on the SMT solver when assessing range sizes.
Our work shares several analogies with the segment-offset-
plane model proposed in [10], which stores data in separateplanes based on their type. Each plane holds a list of write
records, and a solver is invoked for each read operation to
check whether a stored expression collides with the given(typed) symbolic address. We believe our approach is moregeneral as it is not affected by the type safety of a language,it provides support for state merging that is compelling forscalability, and it explicitly accounts for uninitialized memory.
The framework presented in [11] to describe concretization
policies for symbolic values and addresses sheds light on aninteresting research problem, paving the way to a systematicstudy of concretization strategies and policy tuning. We also
believe that pointer concretization strategies might beneﬁt
from the delayed concretization technique with uninterpretedfunctions proposed in [12] to handle non-linear constraints.
VI. C
ONCLUSION
We believe that the key concept of generalizing a symbolic
memory so that it maps symbolic address expressions – rather
than just concrete addresses – to value expressions, can leadto further interesting developments.
The reﬁnements introduced in Algorithm 2 and the opti-
mizations applied to our prototype implementation can sig-niﬁcantly affect the performance of the basic version of theapproach. Nonetheless, the design space to explore in opti-mization is large, leaving signiﬁcant room for improvement.
As a ﬁrst observation, static analysis techniques such as
value-set analysis can be used to reﬁne ranges as in [3]
and ease constraint solving. Also, the expressions returnedbyload operations could be amenable to simpliﬁcation,
as expressions from recent symbolic writes may together
supersede other expressions stored earlier in the execution.Similarly, the paged interval tree may periodically be rebuilt
– or modiﬁed in a lazy fashion – to prune “outdated” values.
An executor might also decide to trade performance forsoundness at a later stage by concretizing certain symbolic
address expressions, or limiting the ranges they span usingspeculative heuristics. Investigating the beneﬁts of delayedpointer concretization in symbolic execution and possiblestrategies for it remains an interesting open question.
A
CKNOWLEDGMENTS
This work is partially supported by a grant of the Italian
Presidency of Ministry Council and by CINI CybersecurityNational Laboratory within the project FilieraSicura fundedby CISCO Systems Inc. and Leonardo SpA.
R
EFERENCES
[1] R. Baldoni, E. Coppa, D. C. D’Elia, C. Demetrescu, and I. Finocchi, “A
survey of symbolic execution techniques,” CoRR, vol. abs/1610.00502.
[Online]. Available: http://arxiv.org/abs/1610.00502
[2] B. Elkarablieh, P. Godefroid, and M. Y . Levin, “Precise pointer
reasoning for dynamic test generation,” in Proc. of ISSTA 2009. ACM,
2009. [Online]. Available: https://doi.org/10.1145/1572272.1572288
[3] S. K. Cha, T. Avgerinos, A. Rebert, and D. Brumley, “Unleashing
Mayhem on binary code,” in Proc. of SP 2012. IEEE Computer
Society, 2012. [Online]. Available: https://doi.org/10.1109/SP.2012.31
[4] T. Avgerinos, A. Rebert, S. K. Cha, and D. Brumley, “Enhancing
symbolic execution with veritesting,” in Proc. of ICSE 2014. ACM,
2014. [Online]. Available: https://doi.org/10.1145/2568225.2568293
[5] Y . Shoshitaishvili, R. Wang, C. Salls, N. Stephens, M. Polino,
A. Dutcher, J. Grosen, S. Feng, C. Hauser, C. Kr ¨ugel, and G. Vigna,
“SOK: (state of) the art of war: Offensive techniques in binary
analysis,” in Proc. of SP 2016. IEEE Computer Society, 2016.
[Online]. Available: https://doi.org/10.1109/SP.2016.17
[6] C. Cadar, D. Dunbar, and D. Engler, “KLEE: Unassisted and automatic
generation of high-coverage tests for complex systems programs,” in
Proc. of OSDI 2008. USENIX Association, 2008. [Online]. Available:http://dl.acm.org/citation.cfm?id=1855741.1855756
[7] N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang, J. Corbetta,
Y . Shoshitaishvili, C. Kruegel, and G. Vigna, “Driller: Augmenting
fuzzing through selective symbolic execution,” in NDSS 2016, 2016.
[8] C. Cadar, V . Ganesh, P. M. Pawlowski, D. L. Dill, and D. R. Engler,
“EXE: Automatically generating inputs of death,” in CCS 2006. ACM,
2006. [Online]. Available: https://doi.org/10.1145/1180405.1180445
[9] E. Duesterwald, Ed., Analyzing Memory Accesses in x86 Executables,
ser. CC 2004. Springer Berlin Heidelberg, 2004. [Online]. Available:https://doi.org/10.1007/978-3-540-24723-4
2
[10] M. Trt ´ık and J. Strej ˇcek, Symbolic Memory with Pointers, ser. ATV A
2014. Cham: Springer International Publishing, 2014, pp. 380–395.[Online]. Available: https://doi.org/10.1007/978-3-319-11936-6
27
[11] R. David, S. Bardin, J. Feist, L. Mounier, M.-L. Potet, T. D. Ta,
and J.-Y . Marion, “Speciﬁcation of concretization and symbolization
policies in symbolic execution,” in Proc. of ISSTA 2016. ACM, 2016.
[Online]. Available: https://doi.org/10.1145/2931037.2931048
[12] C. S. P ˘as˘areanu, N. Rungta, and W. Visser, “Symbolic execution with
mixed concrete-symbolic solving,” in Proc. of ISSTA 2011. ACM,
2011. [Online]. Available: https://doi.org/10.1145/2001420.2001425
618
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:08:29 UTC from IEEE Xplore.  Restrictions apply. 