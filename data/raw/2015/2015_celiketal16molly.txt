Build System with Lazy Retrieval for Java Projects
Ahmet Celik1, Alex Knaust1, Aleksandar Milicevic2, and Milos Gligoric1
The University of Texas at Austin1(USA), Microsoft2(USA)
{ahmetcelik,awknaust}@utexas.edu, almili@microsoft.c om, gligoric@utexas.edu
ABSTRACT
In the modern-day development, projects use Continuous
Integration Services (CISs) to execute the build for every
change in the source code. To ensure that the project re-
mains correct and deployable, a CIS performs a clean build
each time. In a clean environment, a build system needs
to retrieve the project’s dependencies (e.g., guava.jar). The
retrieval, however, can be costly due to dependency bloat:
despite a project using only a few ﬁles from each library, the
existing build systems still eagerly retrieve all the libra ries
at the beginning of the build.
This paper presents a novel build system, Molly, which
lazily retrieves parts of libraries (i.e., ﬁles) that are ne eded
during the execution of a build target. For example, the
compilation target needs only public interfaces of classes
within thelibraries and thetest target needs only implemen -
tation of the classes that are being invoked by the tests. Ad-
ditionally, Mollygenerates a transfer script that retrieves
parts of libraries based on prior builds. Molly’s design
requires that we ignore the boundaries set by the library
developers and look at the ﬁles within the libraries. We
implemented Mollyfor Java and evaluated it on 17 pop-
ular open-source projects. We show that test targets (on
average) depend on only 9.97% of ﬁles in libraries. A vari-
ant ofMollyspeeds up retrieval by 44.28%. Furthermore,
the scripts generated by Mollyretrieve dependencies, on
average, 93.81% faster than the Maven build system.
CCS Concepts: Software and its engineering →Software
notations and tools
Keywords: Build system; continuous integration service
1. INTRODUCTION
Continuous Integration (CI) [19], i.e., integrating all de-
veloper working copies into a shared mainline of source code
as often as multiple times a day, has been widely adopted as
part of agile software development [14] in general, and in ex -
treme programming [13] in particular. In theenvironmentof01234
Codec
IO
Math
Net
Pool
Lang
ClosureC
JXPath
Config
JGit
Retrofit
Guava
OkHttp
OrientDB
EmpireDB
DPatterns
CXF
ProjectRetrieval Ratio (Molly/Maven)Thread Count 2 4 8 16 32 64 128
Figure 1: Comparison of a baseline dependency re-
trieval (the transitive closure is computed and li-
braries are retrieved in parallel, as implemented by
Maven [9]) vs. the ideal case (all necessary ﬁles are
known upfront and these ﬁles are retrieved in par-
allel). Values on the “Retrieval Ratio” axis are pro-
portional to the baseline value (which is 1).
rapid code changes, CI was designed to prevent scenarios in
which a developer working copy signiﬁcantly diverges from
the mainline, to the point where integration becomes diﬃ-
cult and time consuming. In the modern-day development,
CI is typically performed by a dedicated service ( Continu-
ous Integration Service , CIS) after every push to the source
repository. Onesuchpublicservice, TravisCI [60], for exa m-
ple, is used by more than 300K projects today, and performs
approximately 130K builds daily [36].
To ensure that the project being developed remains de-
ployable after every push, a CIS has to perform a clean build
every time: starting from a clean state on disk, the latest
copy of the source code is fetched from the repository, de-
pendencies to other projects or libraries are retrieved, th e
project is compiled, and ﬁnally all tests are run.
In this paper, we focus on improving the dependency re-
trievalstep. The common ineﬃciency of this particular step
has been widely recognized [1,3,5,56,61,62]. (As an exam-
ple, it can take up to an hour to retrieve all 1,701 libraries
on which the Apache Camel project [6] depends.)
To motivate the problem further, consider Figure 1, where
we take 17 popular open-source Java projects, all using the
Maven [9] build system, and show how much faster, at least
in the ideal scenario, the dependency retrieval step can be.
This is the author’s version of the work. It is posted here for your personal use. Not for
redistribution. The deﬁnitive version was published in the following publication:
FSE’16 , November 13–18, 2016, Seattle, WA, USA
c2016 ACM. 978-1-4503-4218-6/16/11...
http://dx.doi.org/10.1145/2950290.2950358
643The baseline (denoted as value 1 on the yaxis) is the default
dependency retrieval implemented by Maven: the transitive
closure of libraries is computed ﬁrst, then, the resolved li -
braries are retrieved in their entirety. (We tried conﬁgur-
ing the size of the thread pool used by Maven for retriev-
ingdependencies—byusingthe -Dmaven.artifact.threads
option—butthischangehadnoimpactontheretrievaltime.)
In contrast, imagine if the full list of used libraries (e.g. ,
.jarﬁles) was known upfront—there would be no need for
any additional computation, and the ﬁles could be retrieved
massively in parallel. Further, imagine if not only the nece s-
sary libraries are known, buttheexact individualﬁles with in
those libraries (e.g., .classﬁles)—only those ﬁles could be
retrieved (still massively in parallel), saving both disk s pace
and total retrieval time. For the 17 projects listed in Fig-
ure 1, we statically computed the minimal set of necessary
ﬁles and measured the time it took to retrieve them in paral-
lel (later in the paper we show how this can be achieved fully
automatically by a general-purpose build system); when us-
ing 64 threads on a 4-core machine, the total retrieval time
is reduced by 93.81% on average.
Problem : Thekeycontributortoslow dependencyretrieval
is what we call dependency bloat . Thedependency footprint
of a project includes all libraries the project may possibly
use. Build systems (e.g., [8,9,12,32]) typically retrieve the
entire footprint eagerly, prior to executing concrete build
targets. In practice, however, often times not every librar y
(or part thereof) gets used during a concrete build. Reasons
are various: (1) a project may not use some of the transitive
libraries (e.g., very few projects that depend on JUnit use
JUnit’s dependency Hamcrest), (2) the compilation phase
needs only the APIs of classes rather than their implemen-
tation, (3)thecompilation phasemayfail, sothereisnonee d
to retrieve libraries used by any later phases (e.g., testin g),
and (4) even if all tests are successfully executed they may
use only a small fraction of ﬁles from the libraries.
Solution : To mitigate the dependency bloat problem in a
generic and application-agnostic way, we propose lazy de-
pendency retrieval . Provided that the host language com-
piler/runtime allows for dynamic library loading, the buil d
system ought to retrieve physical dependency artifacts (e. g.,
by retrieving them from a central repository) only when re-
quested by the compiler/runtime, that is, only when trig-
gered by execution of concrete build targets.
We also propose a variant of lazy dependency retrieval,
where boundaries set by library providers are ignored by
the build system, and instead, library content is retrieved
on individual ﬁle basis. We dub this technique elastic de-
pendencies . In our experiments, we observed that elastic
dependencies reduce the total size of retrieved content by
89.80% on average.
Finally, to further reduce the cost of dependency retrieval
forsubsequent builds, we use our infrastructure to main-
tain a ﬂattened list of resolved dependencies, called transfer
script, which helps us get closer to the ideal retrieval time
(Figure 1). Note that our infrastructure for lazy retrieval
is still needed during the subsequent builds to retrieve new
dependencies and update the ﬂattened list for future builds .
Implementation : We implemented a prototype of the pro-
posed technique in a novel build system for Java projects,
calledMolly. We implemented lazy dependency retrieval
and elastic dependencies by modifying both the Java com-
piler and the Java runtime.TheoryRunBeforeRunnerExternalResourceURLConverterMethodUtilsArrayConverter ObjenesisHelper
AndroidInstantiator
ObjectInstantiator
39/137commons-beanutils-1.9.2
0/314junit-4.12
IndexClasshsql-1.8.0.10
95/28612/35objenesis-1.3
TestAutoSaveListener
TestINIConﬁguration
Unused
Used by both tests
Figure 2: Dependencies for two tests in Conﬁg [7].
Evaluation : We evaluated Mollyon 17 popular open-
source Java projects. We report both empirical ﬁndings and
concrete improvements observed when using Molly:
•(empirical)averagetimespentondependencyretrieval:
59.46% of the total clean build time;
•(improvement) average reduction in dependency re-
trievaltime: 44.28% (duetolazydependencyretrieval);
•(improvement) average reduction in size of retrieved
dependencies: 89.80% (due to both lazy dependency
retrieval and elastic dependencies).
Mollyachieves signiﬁcant savings in both build time and
disk space, which, we believe, can have a profound impact
on reducing the cost of running and maintaining any CIS.
2. OVERVIEW
This section illustrates Mollythroughan example. First,
we introduce a project to build. Next, we walk through the
build process as carried out by both Maven (a widely used
buildsystem from Apache[9]) and Molly. We compare and
contrast compilation and execution models of the two, and
discuss the beneﬁts brought by Molly. Finally, we describe
the way Mollyobtains a transfer script.
Example Project :Config[7] is an Apache project for
parsing conﬁgurations from a variety of ﬁle formats. The
Configproject includes a Maven build script ( pom.xml) list-
ing all its dependencies. Each such dependency is a Maven
project too, containing its own build script specifying its
own dependencies. The most recent version of Configtran-
sitively depends on 269 libraries. Figure 2 depicts some of
them as boxes containing a few representative classﬁles (de -
noted as circles) and illustrates which of those classﬁles a re
used by two randomly chosen unit tests.
Assume that a developer of Configpushes a change to the
repository and a build is triggered by a CIS. We consider
the following three scenarios: (1) compilation of test sour ces
fails, (2) only one test is run, and (3) build succeeds. We
nextdescribe Mavenand Mollyandshowhowtheymanage
dependencies for these three scenarios.
644Maven Central
x.jar
X1.class
X2.classMolly Repository
x.jar
Xt
1.class
Xt
2.class
x−X1.jar
X1.class
x−X2.jar
X2.classBuild System
Runtime EnvironmentX1.classMaven Local
x.jar
X1.class
X2.class
Molly Localx.jar
X1.class
Xt
2.classcompile||test
trim
split
testmergecompile
mergesave
save
Figure 3: Molly’s architecture (solid lines) and a conventi onal build system (Maven) (dashed lines). Maven
eagerly retrieves x.jarprior to the compilation and test execution, whereas Molly l azily retrieves trimmed
x.jarat compile time and lazily retrieves necessary executable c ode at runtime, merging when convenient.
Maven: Maven automatically manages a project’s depen-
dencies based on the user’s speciﬁcation in the build script .
Speciﬁcally, Maven maintains the Maven Central Repos-
itory of publicly available libraries [10]. (We mined the
Maven Central Repository and discovered that it currently
includes 1,125,281 libraries, totaling 1,043GB.) Maven Ce n-
tral Repository allows library developers to autonomously
deploy their libraries to the repository. Consequently, th e
library developers determine the size and content of the li-
brary, and consumers of the library have no way of specify-
ing which parts of the library they need; they must use the
entire library, or none of it.
When a build is executed, Maven automatically retrieves
the necessary libraries for the executed target (based on
pom.xml). The retrieved libraries are saved in the local
repository on disk for later reuse. Note that if a project
uses CIS, the libraries are removed from the local reposi-
tory when the build ﬁnishes1. Figure 3 (dashed lines) il-
lustrates the Maven build model. When a user invokes a
target, Maven retrieves the dependencies eagerly, before the
execution of the target begins.
For our example scenarios, importantly, Maven retrieves
the same set of libraries regardless of which test is executed.
The retrieved libraries include boththeuser speciﬁed depe n-
dencies and transitive dependencies with their entire con-
tents. However, the failing compilation does not need the
executable code of the compiled ﬁles, but only their public
interfaces. The executed test TestINIConfiguration does
notneeddependencies(e.g., ObjenesisHelper ) usedbynon-
executedtests, andevenasuccessful builddoes notneedﬁle s
that are never used (e.g., IndexClass ).
Other popular build systems, including Ant + Ivy [8],
Bazel [12] (limited), Gradle [32], and sbt [53] follow a simi -
lar approach with respect to dependency retrieval from the
Maven Central Repository.
Molly:Mollyintroduces a novel execution model, shown
in Figure 3 (solid lines), which tightly couples the build sy s-
tem, the compiler, and the runtime environment. Unlike the
existing build systems, Mollyretrieves parts of libraries
lazily during the execution of the targets. Like other build
1Recently, several CISs, including Travis CI, introduced
simple caching support that packages dependencies into an
archive and uploads it to a remote storage service. However,
retrieving a large cache can be costlier than retrieving the
original dependencies [56]. Note that our work is comple-
mentary to caching and can reduce the cache size.systems, Mollymaintains its own central repository (the
two boxes that shown in Figure 3). The library developers
deploy the same libraries as they would to Maven Central
Repository. When a library is uploaded, Mollyruns its
preexecution phase , which splitsthe library into ﬁles and
trimsthe library to reduce it to its public API. Speciﬁcally,
Mollycreates one library for each classﬁle in the original
library (bottom second box from the left in Figure 3) and
then trims classﬁles from the original library, so that the
trimmed library consists only of the public interfaces of th e
original classﬁles (top second box from the left in Figure 3) .
For our running example, Config,Molly’s splitting step
will create 19,629 new libraries, and the trimming step will
reduce the size of the libraries by 46.63%.
When a user invokes a target, Molly, in itsexecution
phase, lazily retrieves only the classﬁles that are needed for
the execution and loads them into the main memory (third
bottom box from the left in Figure 3). Then, either in par-
allel with the execution or oﬄine (between two build runs),
Mollymergesretrieved classﬁles into libraries in the local
repository. (Note that merging is unnecessary for the execu -
tion of the build, but it is used to keep Mollytransparent
to the user). An additional advantage of Mollyis that it
makes the Molly Central Repository transparent to both the
library developers (as theydonothave tothinkhowthe best
to split their libraries) and users of the libraries (as they do
not have to worry about unnecessarily ﬁles being retrieved) .
In our three scenarios for Config,Mollyretrieves only
the interfaces of classﬁles needed to compile tests. If the
user executes only TestINIConfiguration ,Mollyretrieves
39 of 137 ﬁles (the numbers are shown below the boxes in
Figure 2) from commons-beanutils , and no ﬁles from either
Objenesis orhsql. If the user instead executes TestAu-
toSaveListener ,Mollyretrieves 12 of 35 classﬁles from
Objenesis , but none from commons-beanutils , and also
none from hsql. Even when the build succeeds, and all
tests are executed, Configonly uses 2,830/19,629 (14.42%)
of classﬁles. We present other results in Section 5.
During the build, Mollyobtains a transfer script for the
subsequent build; we discuss the details of the generated
scripts in Section 3.3. As described earlier, transfer scri pt
contains the ﬂattened list of ﬁles retrieved during the buil d.
If the script exists, it is executed at the beginning of the
build, and newly needed ﬁles are retrieved by Mollylazily
during the build execution.
6453. MOLLY PHASES
This section describes Molly’spreexecution phase (per-
formed when a library is deployed to Molly Central Reposi-
tory, Section 3.1), execution phase (performed when a build
target is executed, Section 3.2), and generation of the trans-
fer script (Section 3.3). We assume the standard seman-
tics for the Java classﬁles [59] and the Java runtime [37].
Throughout this section we provide the intuition for why
Mollypreserves the behavior of the original build.
3.1 Preexecution: Trimming and Splitting
In the preexecution phase, a library, L, is decomposed
into a compile-time component ( Lt) and the runtime com-
ponents ( L{r}). For each Java classﬁle in the library, z∈ L,
the compile time component of the classﬁle zt(s.t.,zt∈ Lt
andzt=trim(z)) should contain only the class’s public in-
terfaces(whichwedeﬁnelater inmoredetail). Each runtime
component Lrcontains exactly one of the classﬁles from the
original library (i.e., ∀z∈ L.∃Lrsuch that z∈ Lrand/negationslash ∃Lr′
such that z∈ Lr′).
3.1.1 Trimming Step
The objective of the trimming step is to decompose an ex-
isting library L, a container of compiled Java classﬁles, into
a new trimmed library, Lt, that can be substituted for L
during the compilation phase of any dependent. Addition-
ally, the trimfunction should extract a dependent-agnostic
interface of Lthat is smaller, delaying decisions about which
classes are really needed until runtime. The requirements o f
Ltare stated below:
1. For any project Pthat depends on L,Ltmay be sub-
stituted for Lat compile time.
2. The product of the compilation with Lt, will be iden-
tical to the product of the compilation with L.
3.Ltshould be the smallest possible library (in terms
of code fragment) that satisﬁes the above two require-
ments and each classﬁle passes the Java veriﬁcation.
Requirement 1 ensures that Ltis independent of a project
P, so that trim(L) =Lt, which may be expensive, is per-
formed only once per library. This requirement also guar-
antees that from the compiler’s perspective, Ltis identical
toL, so that the developers of Pcan substitute LtforLin
compilation. The second requirement guarantees that will
be possible to build PusingLtand later replace Ltwith
Lat runtime. The third requirement sets the optimization
goal for the trimming step: it should remove as much com-
piled code as possible, while still satisfying the ﬁrst two r e-
quirements. If Ltsatisﬁes these requirements, it will be a
physically smaller version of L, that can be transparently
substituted for Lat compile-time.
The trimming algorithm works by removing sections of
the compiled classﬁles that are not visible to its dependent s.
These can be broken up into two categories: executable code
andnon-visible members .
Rewrite rules : We deﬁne the trimfunction with a set of
rewrite rules. Each rule has the following form:
C[before→after]condition
whereCis the context, before/afterare Java statements
orclass members(e.g., ﬁeldsormethods)ortheemptystring
(denoted by ⊥), andcondition deﬁnes the applicability ofstatic{···}→⊥ (1)
< mod > Type f ···→⊥,ifprivate∈mod (2)
< mod > Type f =ExprType→
< mod > Type f =zero(Type)
ifprivate/\e}atio\slash∈modand (Type/\e}atio\slash=Pror (Type=Prand
(¬const(Expr) or{static,final}/\e}atio\slash∈mod))) (3)
< mod > Type m (···){···}→⊥ ,ifprivate∈mod(4)
< mod > Type m (···){···}→
< mod > Type m (···){return zero (Type)}
ifprivate/\e}atio\slash∈mod (5)
< mod > c (···){···}→⊥ ,ifprivate∈mod (6)
< mod > c (···){···}→ < mod > c (···){}
ifprivate/\e}atio\slash∈mod (7)
< mod > class M {···}→⊥ ,ifprivate∈mod (8)
Figure 4: Rewrite rules for the trimming phase.
< mod > Type m (···){···}→
< mod∪native > Type m (···);,ifprivate/\e}atio\slash∈mod (9)
Figure 5: Alternative rewrite rule for 5 in Figure 4.
the rule. Interestingly, our rules apply in any context, so
we always omit C. Additionally, we omit the condition
if a rule always applies. moddenotes a set of Java modi-
ﬁes,ExprTypedenotes any expression of the speciﬁed type,
Typedenotes any type, and Prdenotes primitive and String
types. We use fto refer to a ﬁeld, mto refer to a method,
andcto refer to a constructor. ···are positional param-
eters and their use on the right side follow the order on
the left side. Function zero(Type) returns default value for
the given Type (e.g., nullfor a reference type, 0 for int,
etc.). We deﬁne a predicate const(Expr) that holds iﬀ the
given expression is a constant expression (e.g., “string” f or
String type). The rewrite rules are shown in Figure 4. The
class members and statements that are never explicitly used
on the left side of the rules remain unchanged. Although
our implementation of Mollytrims Java classﬁles, we de-
ﬁne the rewrite rules on Java source level for the simplicity
of exposition. (Note that some rules cannot apply to Java
source code directly, and are mentioned below.) Most of the
rules are straightforward, so we explain the intuition behi nd
the rules on a high level and emphasize the rules that are
potentially less obvious.
Privateaccessmembers(ﬁelds, methods, constructors, and
inner and nested classes) of Lcannot be referenced by Pat
compile time duetoaccess modiﬁers. Followingthestandard
Java speciﬁcation, the trimfunction may safely remove all
privateﬁelds, methods, constructors, and classes of L, since
these may only be referenced in the classes in which they are
deﬁned. This is described by rules 2, 4, and 6. (Note that
private members can be accessed through the Java reﬂection
mechanism, but that belongs to the execution phase and we
describe it in Section 3.2.)
646Package-privateaccessmembers(ﬁelds, methods,construc -
tors, andclasses) areonlyaccessible withinthesamepacka ge
in which they are deﬁned. Unfortunately, it is not possible
to remove signatures of such members from Las a class C1
of project Pcan be in the same package as C2ofL, in which
case at compile-time, methods in C2should be able to refer-
ence package-private members of C1. Sinceprotected visibil-
ity implies package-private visibility, the trimmer also keeps
the signatures of protected (and obviously, publicmembers).
Bytecode instructions for anymethod andconstructor can
be replaced by a return statement with the appropriate de-
fault value (and no statement for the constructors and void
methods). This is speciﬁed with rules 5 and 7. Note that
performing the change on source code level would not be
compilable in cases when a super class deﬁnes a constructor
with non empty list of arguments. This is not an issue on
the bytecode level, as exception would not be thrown until
the class is instantiated. Figure 5 shows an alternative ap-
proach for trimming non-private methods: each method can
be made native, indicating that its implementation is pro-
vided via a non-Java binary using the Java Native Interface
(JNI), which can save several extra bytes per method.
There is a special treatment for non-private static ﬁnal
ﬁelds (rule 3). If a ﬁeld has both static(not bound to
object instances) and final(cannot be altered after initial-
ization) modiﬁers and const(Expr) holds for the expression
assigned to the ﬁeld, we do not rewrite the value of that
ﬁeld. For these ﬁelds, Java bytecode compilers may inline
the values of“constant”ﬁelds duringcompilation. The prob -
lem could happen either in compilation phase (e.g., if those
ﬁelds are used in a switch statement) or at runtime. Trim-
ming static blocks (rule 1) is straightforward on bytecode
level as the constant expressions have been assigned to the
ﬁnal static ﬁelds during the compilation.
Nested classes deﬁnedinside the scope of another class are
no exception to the visibility rules described above. Anony -
mous classes, deﬁned within the body of a method, are only
accessible within the scope they are deﬁned, and can be
treated as private classes and safely removed from L.
3.1.2 Splitting Step
Function split(L) creates one Lrper classﬁle in L. Cur-
rently, we do not consider the cases when a class C1depends
on another class C2for every possible execution, and C2is
used exclusively by C1, (e.g., a private inner class can al-
ways be in the same Lras the enclosing class). It is possi-
ble to perform static analysis to conservatively ﬁnd furthe r
cases when one class always depends on another. Optimiz-
ing for these cases would complicate the lookup of retriev-
able classes at runtime and require additional considerati on
in the merge step; this optimization is left for future work.
It must be possible to determine the corresponding Lr
fromztat runtime so that it can be lazily resolved and
correctly retrieved. Our solution to this is to concatenate
the fully qualiﬁed class name with the unique identiﬁer of
the library, creating a name unique in both Maven Cen-
tral Repository and in the Molly Central Repository. Ad-
ditionally, libraries frequently contain other artifacts (e.g.,
images); we make these artifacts available in Lt.
3.2 Execution: Retrieving and Merging
Although Pmay be compiled with the trimmed library
Lt, in order to execute Pit is necessary to obtain the orig-Input: zthe class attempting to be loaded
Input: RepoLocalset of local dependencies
Input: RepoRemoteset of remote split dependencies
Input: Mergeset class, dep. pairs to merge, initially ∅
1function DynamicLoad (z, RepoLocal, RepoRemote,
Mergeset)
2L←InitAndGetLibrary (RepoLocal,z.name)
3ifz.name/\e}atio\slash∈L.replaced then
4 z′←Retrieve (RepoRemote,L.id,z.name)
5 Mergeset ←Mergeset∪(L,z′)
6 return z′.src
7end if
8return z.src
9end function
10procedure AsyncMerge (Mergeset, RepoLocal)
11for all(z,L)∈Mergeset do
12L′←L\{zt}∪{z}
13L′.replaced←L′.replaced∪z.name
14 RepoLocal←RepoLocal\{L}∪{L′}
15 Mergeset ←Mergeset\{(z,L)}
16end for
17end procedure
Figure 6: DynamicLoad algorithm retrieves imple-
mentation of classes at runtime. AsyncMerge inte-
grates the retrieved classes into the libraries on local
disk concurrently, or at program end.
inal executable code of L. Requirement 2 of the trimming
ensures that the compiled output of PusingLtis identical
to the output of compilation with L, so one option would
be to fully replace LtwithLat run-time when any of the
classes is needed. It may be the case that Lis speciﬁed as
a dependency, but never used (dangling, or only necessary
for certain build targets). In this case this simple techniq ue
– replacement of LtwithL– would still be beneﬁcial.
However, as shown in the motivating example, Pwill
likely not require all classes of Lto execute. Each execu-
tion on an input of Prequires some subset of the classes of
L. LetLi⊆ Lbe the classes required during execution of
Pon input i. Then we can represent the complete partial
dependency ofPonDasLP=/uniontext
iLi. Ideally Pcould be
made to depend on LPinstead of L. But due to dynamic
dispatch, reﬂection, and other features of Java and other
languages, it is challenging to compute LPstatically [17].
Instead we build LPdynamically and incrementally, retriev-
ingLi’s lazily during execution. This is the point where the
build system, the compiler, and the runtime environment
cross cut. In the ﬁrst execution, the program is started
with the trimmed libraries retrieved during the compilatio n.
On subsequent executions, each library may be a mix of
trimmed and executable classes loaded in prior executions.
3.2.1 Retrieving Step
In order to dynamically load the executable classes, all
class loads must be intercepted. In Java this is possible by
providing a system classloader, a JVM agent (which trans-
forms all classes as they are loaded), or modifying the run-
time environment. The DynamicLoad algorithm depicted
in Figure 6 is called when the JVM attempts to load a class
z. The algorithm ﬁrst (line 2) obtains a local library that
should contain z. The library may already be in the lo-
cal repository if it was needed during the compilation (or
a prior run). If the library is not available locally, a new
library is created based on the build script; we assume that
647Input: RepoLocalset of local dependencies after build
Output:Sexecutable script that retrieves dependencies
1procedure GenScript (RepoLocal)
2for allL∈RepoLocaldo
3S+←$fetch(‘Lt.id)$
4S+←{$fetch(‘L.id,‘z.name)$|z.name∈L.replaced}
5end for
6end procedure
Figure 7: GenScript algorithm generates the trans-
fer script. The algorithm should be run after a clean
build, but it can be extended to incrementally up-
date the script.
the build script includes a mapping from a classﬁle to its
library. Note that the algorithm ensures that the class is re -
trieved even if it was not used in compilation (e.g., accesse d
through reﬂection). Second (line 3), the algorithm checks
ifzhas already been replaced with the executable class in
a previous execution, and therefore does not need to be re-
trieved. Otherwise, if only the trimmed version of the class
is present in the library or the class was not accessed previ-
ously, the underlying dependency resolution system is call ed
to retrieve the Lrdependency for z(line 4). This retrieved
classﬁle is then marked to be merged into its library and
returned to the JVM (lines 5 and 6).
3.2.2 Merging Step
After the executable version of a classﬁle is resolved and
retrieved by DynamicLoad , it is desirable to cache the
classﬁle for future executions. We perform the merge step
to keep Molly transparent to the user. (If CIS performs
clean builds, the merge step provides no value and it can be
skipped.) AsyncMerge , described in Figure 6, performs
this merging. For each (class, library) pair marked to
be merged, AsyncMerge removes the trimmed classﬁle (if
one exists) and includes the new classﬁle. Additionally, in
order to distinguish between trimmed and original classes, a
ﬁle inside of the library is updated to persist that the class
has been replaced. These new libraries will then be loaded
as RepoLocaland used as input to DynamicLoad for the
next execution of the program.
Performing AsyncMerge is expensive to execute, as the
library ﬁle must be completely rewritten to add a new class-
ﬁle. However, since the merged library is only relevant to
the subsequent executions, the merging may be done in the
background or postponed until JVM shutdown (which we
implement). In Maven [9] and other build systems, the re-
trieved libraries may be shared between diﬀerent programs,
however synchronization is required to make this work with
AsyncMerge . Finally, considering that class loading is in-
voked before any use of the class, under the assumption that
the network connection is always available, Mollyhas no
impact of the project’s behavior.
3.3 Obtaining the Transfer Script
Prior sections described the core Mollyfeatures that are
suﬃcienttobuildanyJavaproject. Retrievingasingle clas s-
ﬁle at a time during the build execution, however, can slow
down the build (Figure 1). The full power of Mollycan be
unleashed by generating a script that prefetches dependen-
cies used in prior builds. Figure 7 shows the algorithm to
generate the script. Note that the algorithm assumes that
a clean build has ﬁnished previously. For each library thatis in the local repository (after build execution), we inser t
fetchstatement for the trimmed version of the library, and
onefetchstatement for each non-trimmed classﬁle. (We
use standard notation from code generation community to
represent code fragments and holes [39].)
On local machines or on CISs, which do not use depen-
dency information to trigger builds and tests, the generate d
scriptScansimplybeusedpriortoeachexecutionanditcan
be updated as frequently as developers specify. Note that a
stale script does not aﬀect the correctness of the build, be-
causeMollywill retrieve newly added dependencies lazily
and unused dependencies have no impact on the build.
More generally, Scan be used as the complete list of
dependencies of the project, which can be used to trigger
build/tests [12,21,24,30]. In this case, the script needs t o
be updated after each build to ensure consistency.
4. IMPLEMENTATION
This section brieﬂy describes the implementation of our
Mollyprototype. (We only describe the implementation of
the steps that are relevant for our evaluation.)
Trimming Step : Trimming is performed on the bytecode
of classes within jar ﬁles using the ASM bytecode manipu-
lation framework [11]. The trimmer walks the class ﬁle tree,
applying the rewrite rules in Figure 4 to generate the class’ s
trimmed bytecode, which is then added to a new trimmed
jar. Non-classﬁles in the jar are passed through untouched,
and an additional ﬁle JarSplitter.MOLLY_META is added,
containing the unique identiﬁer of the artifact. The exis-
tence of this ﬁle is used during the retrieving step to deter-
mine whether the jar has been altered by Molly.
Splitting Step :Mollyprovides the splitter tool to split
an existing jar into individual class dependencies. The too l
creates a separate jar for each class, adding the JarSplit-
ter.MOLLY_META ﬁle as before. Packaging each class into a
separate jar allows for simpler integration with Maven, but
these could simply be stored as separate classﬁles or in a
database. This step is transparently run when a library de-
veloper deploys their libraries to the Mollyrepository.
Retrieving Step : WemodiﬁedOpenJDK’scompiler and
runtime (jdk8u74-b02) to implement this step. We currently
implement two variants of Molly: (2)Mollyj, which re-
trieves trimmed jars lazily during compilation and retriev es
the original jars duringexecution (amodiﬁcation of the ori g-
inal technique described in Section 3.2), and (2) Mollyf,
which retrieves trimmed ﬁles lazily during compilation and
retrievestheindividualﬁlesduringexecution(amodiﬁcat ion
of the original technique that uses the algorithm similar to
Figure 6 both in the compilation and runtime).
Weimplementedourcodeintheexceptionhandlingblocks
of the compiler, i.e., if a compiler cannot ﬁnd a class, we in-
tercepttheexceptionandretrievetheappropriatelibrary /ﬁle
(if the library/ﬁle is available). For the runtime environ-
ment, we do a simple lookup to check if the local class is
trimmed, and if so, the original class is retrieved. Mollyj
andMollyfcurrently retrieve jars and ﬁles sequentially.
5. EV ALUATION
To assess the usability of Mollyin the real world, we
answer the following research questions:
RQ1: What is the average size diﬀerence between a Java li-
brary (jar ﬁle) and its public API (trimmed jar)?
648Table 1: Details of evaluated open source projects.
Project URL SHA KLOC Jar # File # Jar Size [MB] Classﬁle Size [K B]
[ https://github.com/ ] Total Mean Max Mean Max
Codec apache/commons-codec e9da3d16 17.3 198 12896 24.93 0.13 1.93 2.14 31.83
IO apache/commons-io e8c1f057 27.2 211 13663 26.15 0.12 2.02 2.14 31.83
Math apache/commons-math 471e6b07 174.8 266 19175 34.67 0.13 1.93 2.07 31.83
Net apache/commons-net 4450add7 26.9 212 13678 26.20 0.12 2.02 2.15 31.83
Pool apache/commons-pool 14eb6188 13.4 181 11484 21.97 0.12 1.93 2.09 28.03
Lang apache/commons-lang 4777c3a5 66.0 218 14367 27.17 0.12 2.02 2.13 31.83
ClosureC google/closure-compiler 831be0a9 254.8 152 1114 119.57 0.13 2.26 2.04 28.03
JXPath apache/commons-jxpath f1dde173 24.5 175 12244 22.50 0.13 1.93 2.19 31.16
Conﬁg apache/commons-conﬁguration 8dddebf1 64.3 269 1962 935.60 0.13 2.02 2.09 31.83
JGit eclipse/jgit 070bf8d1 154.9 163 15793 25.84 0.16 2.90 2.02 24.36
Retroﬁt square/retroﬁt d26484c7 8.1 157 16060 34.88 0.22 12.95 1.95 24.36
Guava google/guava 76e7d7a8 243.5 249 38991 90.08 0.36 41.82 2.30 72.39
OkHttp square/okhttp 0cd6b186 47.0 177 17957 37.30 0.21 12.95 2.46 24.36
OrientDB orientechnologies/orientdb 27e798b4 290.0 248 3 5132 59.93 0.25 7.28 2.21 24.90
EmpireDB apache/empire-db 83c8fb2f 47.4 268 29989 55.00 0.21 3.20 2.21 62.66
DPatterns iluwatar/java-design-patterns 4f56f7b0 16.5 3 34 54167 91.67 0.27 5.53 1.89 52.49
CXF apache/cxf f3185100 589.2 1003 205730 430.12 0.41 38.28 4.99 14202.00
Average N/A N/A 121.52 263.59 31888.00 62.56 0.19 8.41 2.30 868.57
Σ N/A N/A 2065 4481 542096 1063 3 142 39 14765
RQ2: What portion of the dependency retrieval time can be
saved by lazy retrieval?
RQ3: What portion of the dependency retrieval time can be
saved by using transfer script?
RQ4: What is the space reduction that can be achieved by
lazy retrieval and elastic dependencies?
We use two machines for our experiments: (1) a 4-core
1.8GHz i7-4500U CPU with 8GB of RAM, running Ubuntu
Linux 14.04LTS (which we will refer to as boxc1), and (2) a
4-core 2.7GHz i7 CPU with 4GB of RAM, running Ubuntu
Linux 14.04LTS (which we will refer to as boxc2).
5.1 Projects Under Study
Table 1 shows the list of the projects used in our study,
all open source, widely used, written in Java, and built with
Maven. We selected these projects based on their popularity
on GitHub, build system, and build outcome. Note that our
experiments require projects that build successfully, in o rder
to obtain all their dependencies. (Due to some test failures ,
which were mostly caused by ﬂaky tests [27,44], we exclude
test execution for: Guava, OkHttp, OrientDB, and CXF.)
For each project, we show a short identiﬁer2, the project
URL, the git commit SHA used in the experiment, and the
number of lines of code (obtained using the cloctool). Note
that the diﬀerent versions of the same library are treated as
unique dependencies by Maven and are counted accordingly
in the table. Additionally, we include statistics about the
project’s unique dependencies: the number of libraries on
which the project depends (including transitive libraries ),
the number of ﬁles in these libraries, and the total, mean,
and maximum size of each library. The set of dependencies
also include all libraries that are used by Maven process
during the build (e.g., plugins and their dependencies). Th e
ﬁnal two columns examine the Java bytecode ﬁles within
the libraries, their mean and maximum size. Analysis of
the libraries shows that the mean size of the libraries, and
2Projects are sorted based on the number of test dependen-
cies, which is not included in the table.the sizes of classﬁles within the libraries is independent o f
the project size. To conﬁrm that sizes of libraries used by
the selected projects are not unusual, we mined the Maven
Central Repository, which includes 122,175 libraries (onl y
the latest versions of libraries), totaling 110GB. Althoug h,
the selected projects use libraries whose size is somewhat
higher than the median of libraries in the Maven Central
Repository, the selected projects include no outliers.
5.2 Trimming Step
Table 3: Average size
of trimmed jars.
Project Size [%]
Codec 55.26
IO 54.65
Math 53.86
Net 55.22
Pool 53.81
Lang 54.40
ClosureC 55.15
JXPath 54.45
Conﬁg 53.37
JGit 54.28
Retroﬁt 55.30
Guava 55.25
OkHttp 54.91
OrientDB 53.25
EmpireDB 54.61
DPatterns 57.02
CXF 53.42
Average 54.60Table 3 shows the average size
of trimmed libraries by apply-
ingthetrimmingalgorithm (Sec-
tion 3.1.1) to each project. We
ﬁrst compute the size of each
original library ( size(L)) and its
corresponding trimmed library
(size(Lt)). Next, we compute
theportionof Ltthatisin L, i.e.,
Size[%] = size(Lt)/size(L)∗
100. We then average Size[%]
values across all libraries for
each project and show these
values in the table. The ﬁ-
nal row computes the average
across projects. We can observe
that the size of trimmed libraries
diﬀers by only few percentage
points among the projects. In-
terestingly, we can see that the
reduction in size is the smallest
forDPatterns , which depends on classﬁles with smallest size
(Table 1, next to last column). In larger classﬁles, bytecod e
instructions take more space than the constant pool, so the
larger the classﬁle the more reduction may be obtained by
trimming. We observed, by manually inspecting trimmed
libraries, that a signiﬁcant portion of the compiled byteco de
is dedicated to the constant pool, which we do not alter.
A1: Trimmed libraries are, on average, 45.40% smaller
than the original libraries.
649Table 2: Comparison of Maven and Mollyjretrieval times. I2—build time, including compilation and test
execution, w/o dependency retrieval; ∆I[s]—dependency retrieval time; ∆I[%]—percent of time spent on
dependency retrieval.
Projectboxc1boxc2
Maven MollyjMaven Mollyj
I2[s] ∆ I[s] ∆ I[%] ∆ I[s] ∆ I[%]I2[s] ∆ I[s] ∆ I[%] ∆ I[s] ∆ I[%]
Codec 10.85 48.61 81.76 14.36 56.98 13.19 64.52 83.03 17.86 57.53
IO 101.10 50.30 33.22 13.58 11.84 105.89 65.19 38.10 14.83 12.28
Math 129.19 66.30 33.92 15.78 10.88 142.41 99.71 41.18 22.75 13.77
Net 62.20 51.90 45.48 15.95 20.41 65.10 76.61 54.06 14.00 17.70
Pool 300.19 47.24 13.60 6.67 2.17 297.81 59.60 16.68 13.71 4.40
Lang 26.95 53.21 66.38 16.76 38.35 33.13 67.02 66.91 16.15 32.77
ClosureC 60.68 34.65 36.35 13.53 18.23 63.16 53.16 45.70 10.71 14.50
JXPath 8.28 45.10 84.49 9.64 53.79 10.47 56.55 84.38 10.99 51.22
Conﬁg 35.91 65.24 64.50 21.67 37.63 40.60 79.86 66.29 19.23 32.14
JGit 141.20 50.27 26.25 13.11 8.49 156.05 56.05 26.43 16.69 9.66
Retroﬁt 13.89 45.41 76.58 10.46 42.95 16.93 57.56 77.27 13.37 44.12
Guava 30.90 77.73 71.56 24.00 43.72 36.39 102.40 73.78 30.65 45.72
OkHttp 8.19 49.37 85.77 11.40 58.19 9.83 65.17 86.89 14.81 60.09
OrientDB 49.57 60.26 54.87 17.73 26.34 57.22 81.49 58.75 25.04 30.44
EmpireDB 16.63 70.73 80.96 23.77 58.83 18.89 94.50 83.34 24.68 56.65
DPatterns 97.51 87.93 47.42 31.46 24.39 108.40 117.38 51.99 38.13 26.02
CXF 215.09 266.21 55.31 119.26 35.67 249.80 318.09 56.01 156.75 38.56
Average 76.96 68.85 56.38 22.30 32.29 83.84 89.11 59.46 27.08 32.21
Σ 1308 1170 N/A 379 N/A 1425 1514 N/A 460 N/A
5.3 Retrieval Time
Setup: Instead of using the existing Maven Central Repos-
itory, we installed empty Maven and Mollyrepositories on
a dedicated server exclusively available to us (denoted as
boxs), to provide for fairness and stable measurements. We
used the two machines described earlier as clients, which
resulted in two conﬁgurations: boxc1↔boxsandboxc2↔
boxs. In both conﬁgurations, the bandwidth between the
client and the server was 3.90 Mbits/sec (averaged over 10
repeated measurements using iperf).
To initialize the repositories on boxs, for each project
we executed mvn install once without any changes to the
project’s build script. This command retrieved all librari es
from the original Maven repositories, which we copied over
to our private Maven repository. Additionally, we executed
trim and split on each original library and added the result-
ing artifacts to our Mollyrepository.
First, we measure the time it takes to retrieve dependen-
cies from boxs. (All retrievals from this point on are from
boxs.) To do so, we measure Maven execution times of two
separate runs: ( I1), where we delete the local Maven repos-
itory and execute mvn install , and (I2), where we execute
mvn install -offline without cleaning the local reposi-
tory.I2, thus, is the time spentbuildingand executingtests,
while ∆ I=I1−I2, is thetimespentretrievingdependencies.
Second, wemeasurethetimeittakestoretrievedependen-
cies using Mollyj. Recall (Section 4) that Mollyjlazily
retrieves trimmed libraries during compilation and lazily re-
trieves the original libraries during the execution. (In th e-
ory, runningbuildwithlazyretrievalcouldincreasethebu ild
time ifmost of thelibraries are retrieved, because Mollyre-
trieves boththe trimmed and original libraries. However, w e
did not observed a slowdown for any project, because many
libraries are usually unused.) Exactly as we do for Maven,
we runMollytwice (without and with a local repository
present) to measure I1andI2, and then compute ∆ Ias the
diﬀerenceofthetwo. Notethat I2is expectedtobethesamefor both Maven and Molly(because they both perform ex-
actly the same build), which our experiment conﬁrmed.
Results : Table 2 shows the I2and ∆ Ivalues for Maven
andMollyjwhen running on both of our client machines.
The ﬁnal two rows show the average and sum. We see
that on both machines, Mollyjspends less time retriev-
ing dependencies: 32.29% vs. 56.38% on boxc1, and 32.21%
vs. 59.46% on boxc2. Based on these values, we compute
the average saving of retrieval time: 1 −(32.29/56.38 +
32.21/59.46)/2.
A2:Mollyjsaves, on average, 44.28% of retrieval time
compared to Maven.
5.4 Transfer Script Savings
In the introduction, we already described the ideal depen-
dency retrieval time (Figure 1): 93.81% of retrieval time ca n
be reducedon average by usingtransfer script (on boxc2; the
results on boxc1are almost identical), which can be obtained
fromMollyf. Note that the same ﬁgure shows that the ini-
tial retrieval time for Mollyfcan be several times that of
Maven due to the large number of HTTP requests, but that
disadvantage would be gone by the end of the second build.
A3: Transfer script can save 93.81% of retrieval time.
5.5 Lazy Retrieval Disk Savings
Table 4 shows the savings in terms of the size of retrieved
dependencies (and, therefore, disk space). The results are
split into two main columns: MollyjandMollyf. For
Mollyj, we show the total number of libraries retrieved
byMollyj(Jar #), and compare it with the total num-
ber of libraries retrieved by Maven (Jar [%]). (The num-
bers for Maven were reported in Table 1.) For Mollyf,
we show the total number of retrieved ﬁles (File #), com-
pare it with the total number of ﬁles in libraries retrieved
by Maven (File [%]), and compute the reduction of the to-
tal size of retrieved artifacts when compared with Maven
(Size [%]). Both MollyjandMollyfachieve consistent
savings across all the projects. This particular metric is e s-
650Table 4: Stats for Jars and Files retrieved by Mollyj
and Mollyf, respectively.
ProjectMollyjMollyf
Jar # Jar [%] File # File [%] Size [%]
Codec 81 40.91 1198 9.29 9.75
IO 86 40.76 1299 9.51 10.09
Math 100 37.59 1545 8.06 8.74
Net 87 41.04 1272 9.30 9.92
Pool 67 37.02 1146 9.98 10.45
Lang 91 41.74 1350 9.40 9.97
ClosureC 52 34.21 1794 16.10 15.37
JXPath 71 40.57 1348 11.01 12.34
Conﬁg 120 44.61 2830 14.42 15.36
JGit 78 47.85 2060 13.04 14.24
Retroﬁt 51 32.48 1764 10.98 8.59
Guava 82 32.93 1176 3.02 2.52
OkHttp 50 28.25 434 2.42 1.56
OrientDB 95 38.31 1348 3.84 2.43
EmpireDB 185 69.03 3267 10.89 11.07
DPatterns 145 43.41 11161 20.60 20.25
CXF 425 42.37 15545 7.56 10.76
Average 109.76 40.77 2972.76 9.97 10.20
Σ 1866 N/A 50537 N/A N/A
pecially important for distributed build systems [4,20], a s it
improves dependency caching [25,28,60]; we discuss this in
more detail in the next section.
A4:Mollyfuses only 9.97% of ﬁles used by Maven, and
Mollyjuses 40.77% of jars used by Maven; the reduction
in space with Mollyfis 89.80%, on average.
6. DISCUSSION AND FUTURE WORK
Amortization : Although Mollyprovides the most bene-
ﬁts in CIS environments with clean builds without caching,
Mollycan bring beneﬁts even when dependencies are (re-
motely) cached [2,56]. Not only is Mollyorthogonal to
caching, butMollymay improve the performance of caches
(particularly in a distributed environment), due to disk us -
age reduction. Additionally, if dependencies are cached,
there is no need to cache them eagerly, but they can be
cached when classﬁles are lazily retrieved. This amortizes
theretrieval time across several builds(ofmultiple proje cts).
It is important to mention that local caching (i.e., storing
the cache on the machine that executed the latest build of
the project) is non-existent in CISs. The reason may be ob-
vious: CISs use the same machines to runbuilds of hundreds
of thousandsofprojects (e.g., Travis CI is usedbymore than
300K projects [35,36]), and caching all dependencies for al l
projects on all machines is simply infeasible.
Transparency :Mollyis transparent to both library de-
velopers and library users. Speciﬁcally, as only the neces-
sary classes are retrieved, Mollyincentivizes library users
to make decisions about libraries based on the quality of
each library instead of its packaged size. At the same time,
library developers need not think about the sizes of their
libraries. Additionally, library developers need not manu -
ally separate public APIs and its implementation, which is
a non-trivial task.
Tracking : Maven Central Repository provides some statis-
tics about libraries that it hosts. Mollycould provide ad-
ditional valuable information to the library developers, e .g.,
the list of classﬁles that are most frequently used. The abil -
ity to track dependencies could be further used to optimizetesting and veriﬁcation [23,29,31,33,41,42,66] by tracki ng
for each test/property what classes are being used.
Compression : We combined the pack200 jar compression
tool [48], included with most JRE distributions, with the
Molly’s trimming algorithm. Combining both techniques
reduces most projects’ dependencies to 5-15% of their origi -
nalsize. Althoughcombining Mollyandpack200mayseem
attractive, we did not proceed with this combination due to
unpacking cost when the dependencies are retrieved, which
would be done in the execution phase. Unlike unpacking,
the packing could be done in the trimming step of the pre-
execution phase. This step is performed either oﬄine for
each dependency as it is built or as it is uploaded to the
repository, and hence is not a runtime overhead.
Future Work : We see several diﬀerent ways to extend
Molly, as well as a few opportunities for applying Molly’s
core lazy retrieval techniques in other domains. As for ex-
tendingMolly, to save more space, Mollycould track de-
pendencies at a granularity ﬁner than classﬁles (e.g., meth -
ods); to improve the running time, Mollycould specula-
tively prefetch classes and retrieve them in parallel (e.g. , if
classAis heavily used in methods of class B,Mollycould
start retrieving Aas soon as Bis requested). Beyond build
systems, OS package managers could implement a similar
approach to ours to retrieve parts of packages only upon re-
quest; the standard latex distribution on Linux systems is a
good example, since it contains a large number of packages
that most people never use.
7. THREATS TO V ALIDITY
External : The reported results may not generalize beyond
the projects used in our evaluation. To mitigate this threat ,
we chose active projects that diﬀer in the application do-
main, the number of developers, the number of lines of code,
the number of dependencies, and the number of authors.
Additionally, several projects used in our experiments hav e
been used in recent studies on regression testing and build
systems [15,16,29,55].
The results for parallel retrieval time (Section 5.4) may
diﬀer based on the machine (e.g., HD instead of SSD) and
networkconﬁgurations. Tomitigate thisthreat, we obtaine d
results on two machine, which consistently showed improve-
ment of the transfer script for retrieving dependencies ove r
Maven’s mechanism for retrieving dependencies.
Internal : Implementation of Mollyand our scripts may
contain bugs that may impact our conclusions. Molly’s
code base includes a number of tests that check the cor-
rectness of all phases of the proposed technique. We also
manually inspected the outputs of Mollyfor several small
and large examples.
Construct : For parallel retrievals, we used several values
to initialize the thread pool, such that each value is a power
of two. Our goal was to show the substantial speedup that
can be obtained with our approach rather than to ﬁnd the
optimal value of threads in the thread pool.
In our evaluation, we used the default Maven conﬁgura-
tion. As reported in Section 1, we also evaluated Maven
retrieval time for diﬀerent sizes of the thread pool, but we
observed no savings; we used the same set of values for the
thread pool size as for the evaluation of the transfer script s.
Although a number of diﬀerent build systems are avail-
able, we compared Mollyonly with Maven. Maven is still
one ofthemost popularbuildsystems for Javausedbymany
651open-source projects. In the future, we plan to further com-
pareMollywith other build systems. Note however that
every build system can beneﬁt from lazy dependency re-
trieval and elastic dependencies.
8. RELATED WORK
This section describes prior work related to Molly.
Software Remodularization and Target Decomposi-
tion: Software remodularization is a closely related area of
research attempting to cluster existing programs or depen-
dencies into more meaningful modules. The Bunch [46] tool
introduces using subsystem decomposition by graph parti-
tioning of static inter-project ﬁle dependencies. Bunch pr o-
vides diﬀerent search metrics to allow for diﬀerent tradeoﬀ s
between remodularization quality and performance. The
Decomposer and Reﬁner tools [63] build upon this approach
by forming the strongly connected components of an enor-
mous ﬁle dependency graph [52], using expected dependent
test triggers as a metric to partition the graph. Decomposer
splits dependencies into only two subdependencies, and the
chosen decomposition is tied to which dependents are avail-
able when the tool is run. Closely related work uses the
strongly connected components of the ﬁle dependencygraph
to statically remove unused ﬁle dependencies from the build
ﬁle within a project [67]. PoDoJA [18] seeks to minimize the
download cost of code using dynamic information to stat-
ically repackage the downloadable jars. PoDoJA monitors
theclasses usedinseveral executionscenarios, andoptimi zes
the average download size across scenarios using a genetic-
algorithm searchfor apartitioningoftheclasses withinaj ar.
In comparison, Mollyperforms lazy dependency retrieval
and elastic dependencies, which automatically reduce the
dependencies between the projects: project depends only
on the ﬁles from libraries that are used in one phase of the
build execution. Our approach does not require any changes
to libraries, and thus could help decoupling projects and re -
ducing regression testing cost, without requiring substan tial
eﬀort from developers.
Dependency Compression : Java packages code into jar
ﬁles which use the zip format for easy distribution. In addi-
tion to standard compression algorithm such as gzip or bz2,
specialized tools exist to shrink the size of jars. pack200 [ 48]
performs a lossy compression on a jar ﬁle by joining the
classes’s constant pools, removing debug information, and
applying the gzip algorithm. As discussed earlier, we ex-
perimented with combining pack200 and Molly, ﬁnding
that while pack200 achieves on average a reduction to 30%,
combining both approaches reduces to 5%-15%. Another
tool, ProGuard [49] strips unused code from jars and obfus-
cates the rest, achieving between 10% and 88% reduction
in jar size. Mollyoperates orthogonally to these compres-
sion tools, and combining the approaches achieves greater
trimmed library compression at the cost of uncompressing
overhead, which can be high for runtime deployment.
Build Systems : There are at least as many build systems
as programming languages [9, 24, 26, 32, 53, 54]. Further-
more, studies show build system maintenance accounts for
signiﬁcant overhead of project development [4,5,45,47,65 ].
Over time, build systems have evolved to be integrated with
a package manager that can resolve, retrieve, and install
library dependencies automatically, similar to tradition al
package management software [58]. Although, resolution of
dependencies with ﬁxed versions is used by Maven, thereis interest in taking advantage of a complex version resolu-
tion model [26,63]. The Spack [26] build system leverages a
constraint solver to determine the appropriate dependency
version for large HPC software projects. Mollyenhances
these eﬀorts by allowing the project to determine if changes
in the dependencyversion are relevant. Otherwork has sped
up Maven builds by delaying execution of the tests until all
modules are built [16]. Our work is orthogonal, as we look
how to optimize retrieval of dependencies regardless of the
target being executed. Bazel [12] can create a library that
includes only class APIs, however, the obtained classﬁles
cannot be loaded by the Java runtime environment as they
do not pass the Java veriﬁcation. This could be a limitation
ifMollyis implemented via the Java agent mechanism to
avoid modifying the Java runtime environment.
Dynamic Patching :Mollybuilds on work on dynamic
patching to insert executable code at runtime [50,51,57].
Java is designed to provide extensible dynamic loading [43] .
Research in dynamic patching has shown that executable bi-
narycode maybepatchedatruntimewithlowoverhead[34].
In a CORBA system [64], DLS implements a system and
repository for loading code dynamically from the web at
runtime [40]. DLS supports loading the appropriate imple-
mentation for the system, with fallback implementations.
Other Related Work : Java Web Start [38] is a tool for de-
ploying code from the web that is included in Oracle’s JRE.
The newest versions of WebStartallow for lazy downloading
of code at runtime, but only at the packaged jar level; these
jars are downloaded when the application is started. Molly
goes a step further by allowing lazy retrieval of individual
ﬁles within the dependency, and integrating automatically
into the project’s build system. Static analysis of a partia l
program [22] requires inference of missing types to enable
build of the partial program. Unlike work on analysis of a
partial program, Mollylazily retrieves the full implemen-
tation of types used during the build.
9. CONCLUSIONS
We presented Molly, a new build system, which tackles
the dependency bloat problem. Mollyretrieves dependen-
cies partially and lazily, i.e., only the necessary ﬁles, ex -
actly before they are needed (while remaining fully auto-
matic and completely transparent to the users). This is the
key advancement over the existing build systems which en-
ablesMollyto: (1) reduce the retrieval time by 44.28%,
(2) reduce disk space requirements by 89.80%, and (3) re-
duce retrieval time in typical cases by up to 93.81%. Molly
excels in scenarios typical for builds on continuous integr a-
tion services: the fast builds (due to transfer script) incr ease
the overall throughput, and the small dependency footprint
(due to lazy dependency retrieval and elastic dependencies )
enables more eﬃcient caching. We believe the cumulativeef-
fect ofthe savings achievedby Mollycan make a signiﬁcant
diﬀerence for any continuous integration service, especia lly
in the long run.
10. ACKNOWLEDGEMENTS
Wethankthefellow studentsofEE382V (Software Evolu-
tion) at The University of Texas at Austin for discussions on
the material presented in this paper. We also thank Rajeev
Alur, Nima Dini, Alex Gyori, Darko Marinov, John Micco,
and Marko Vasic for their feedback on this work.
65211. REFERENCES
[1] How not to download the Internet. http://blog.
sonatype.com/2011/04/
how-not-to-download-the-internet.
[2] WAD home page. https://github.com/Fingertips/
WAD/.
[3] Your Maven build is slow. Speed it up! http://
zeroturnaround.com/rebellabs/
your-maven-build-is-slow-speed-it-up/.
[4] B. Adams, K. De Schutter, H. Tromp, and
W. De Meuter. The evolution of the Linux build
system.Electronic Communications of the ECEASST ,
8:1–16, 2008.
[5] E. Aftandilian, R. Sauciuc, S. Priya, and S. Krishnan.
Building useful program analysis tools using an
extensible Java compiler. In International Working
Conference on Source Code Analysis and
Manipulation , pages 14–23, 2012.
[6] Apache Camel. https://github.com/apache/camel.
[7] Apache Commons Conﬁguration. https://github.com/
apache/commons-conﬁguration.
[8] Apache Ivy. http://ant.apache.org/ivy.
[9] Apache Maven. https://maven.apache.org.
[10] Apache Maven Central Repository. http://search.
maven.org.
[11] ASM home page. http://asm.ow2.org/.
[12] Bazel home page. http://bazel.io.
[13] K. Beck. Extreme programming explained: embrace
change. Addison-Wesley Professional, 2000.
[14] K. Beck, M. Beedle, A. Van Bennekum, A. Cockburn,
W. Cunningham, M. Fowler, J. Grenning,
J. Highsmith, A. Hunt, R. Jeﬀries, et al. Manifesto for
agile software development. 2001.
[15] J. Bell and G. E. Kaiser. Unit test virtualization with
VMVM. In International Conference on Software
Engineering , pages 550–561, 2014.
[16] J. Bell, E. Melski, G. Kaiser, and M. Dattatreya.
Accelerating Maven by delaying test dependencies. In
International Workshop on Release Engineering , pages
28–28, 2015.
[17] E. Bodden, A. Sewe, J. Sinschek, H. Oueslati, and
M. Mezini. Taming reﬂection: Aiding static analysis in
the presence of reﬂection and custom class loaders. In
International Conference on Software Engineering ,
pages 241–250, 2011.
[18] T. Bodhuin, M. Di Penta, and L. Troiano. A
search-based approach for dynamically re-packaging
downloadable applications. In Conference of the
Center for Advanced Studies on Collaborative
Research , pages 27–41, 2007.
[19] G. Booch. Object Oriented Design: With Applications .
Benjamin/Cummings Pub., 1991.
[20] Build in the Cloud: How the build system works.
http://google-engtools.blogspot.com/2011/08/
build-in-cloud-how-build-system-works.html.
[21] M. Christakis, K. R. M. Leino, and W. Schulte.
Formalizing and verifying a modern build language. In
International Symposium on Formal Methods , pages
643–657, 2014.
[22] B. Dagenais and L. Hendren. Enabling static analysis
for partial Java programs. In Conference onObject-Oriented Programming, Systems, Languages,
and Applications , pages 313–328, 2008.
[23] S. Elbaum, G. Rothermel, and J. Penix. Techniques
for improving regression testing in continuous
integration development environments. In
International Symposium on Foundations of Software
Engineering , pages 235–245, 2014.
[24] S. Erdweg, M. Lichter, and W. Manuel. A sound and
optimal incremental build system with dynamic
dependencies. In Conference on Object-Oriented
Programming, Systems, Languages, and Applications ,
pages 89–106, 2015.
[25] H. Esfahani, J. Fietz, Q. Ke, A. Kolomiets, E. Lan,
E. Mavrinac, W. Schulte, N. Sanches, and S. Kandula.
CloudBuild: Microsoft’s distributed and caching build
service. pages 11–20, 2016.
[26] T. Gamblin, M. LeGendre, M. R. Collette, G. L. Lee,
A. Moody, B. R. de Supinski, and S. Futral. The
Spack package manager: Bringing order to HPC
software chaos. In International Conference for High
Performance Computing, Networking, Storage and
Analysis, pages 40:1–40:12, 2015.
[27] Z. Gao, Y. Liang, M. B. Cohen, A. M. Memon, and
Z. Wang. Making system user interactive tests
repeatable: When and what should we control? In
International Conference on Software Engineering ,
pages 55–65, 2015.
[28] GitLab continuous integration. https://about.gitla b.
com/gitlab-ci/.
[29] M. Gligoric, L. Eloussi, and D. Marinov. Practical
regression test selection with dynamic ﬁle
dependencies. In International Symposium on
Software Testing and Analysis , pages 211–222, 2015.
[30] M. Gligoric, W. Schulte, C. Prasad, D. van Velzen,
I. Narasamdya, and B. Livshits. Automated migration
of build scripts using dynamic analysis and
search-based refactoring. In Conference on
Object-Oriented Programming, Systems, Languages,
and Applications , pages 599–616, 2014.
[31] B. Godlin and O. Strichman. Regression veriﬁcation:
proving the equivalence of similar programs. Journal
of Software Testing, Veriﬁcation and Reliability ,
23(3):241–258, 2013.
[32] Gradle build tool. https://gradle.org.
[33] T. A. Henzinger, R. Jhala, R. Majumdar, and
M. A. A. Sanvido. Extreme model checking. In
Veriﬁcation: Theory and Practice , pages 332–358,
2003.
[34] M. Hicks, J. T. Moore, and S. Nettles. Dynamic
software updating. In Conference on Programming
Language Design and Implementation , pages 13–23,
2001.
[35] M. Hilton, T. Tunnell, K. Huang, D. Marinov, and
D. Dig. Usage, costs, and beneﬁts of continuous
integration in open-source projects. In Automated
Software Engineering , 2016. To appear.
[36] It’s Travis CI’s 5th birthday, let’s celebrate with
numbers! https://blog.travis-ci.com/
2016-02-05-happy-ﬁfth-birthday-travis-ci.
[37] Java language and virtual machine speciﬁcations.
https://docs.oracle.com/javase/specs.
653[38] Java Web Start. http://www.oracle.com/technetwork/
java/javase/javawebstart/index.html.
[39] S. Kamin, L. Clausen, and A. Jarvis. Jumbo:
Run-time code generation for Java and its
applications. In International Symposium on Code
Generation and Optimization: Feedback-directed and
Runtime Optimization , pages 48–56, 2003.
[40] R. Kapitza and F. J. Hauck. DLS: a CORBA service
for dynamic loading of code. In On The Move to
Meaningful Internet Systems: CoopIS, DOA, and
ODBASE , pages 1333–1350. 2003.
[41] D. C. Kung, J. Gao, P. Hsia, J. Lin, and
Y. Toyoshima. Class ﬁrewall, test order, and
regression testing of object-oriented programs. Journal
of Object-Oriented Programming , 8(2):51–65, 1995.
[42] H. Kurshan, R. H. Hardin, R. P. Kurshan, K. L.
Mcmillan, J. A. Reeds, and N. J. A. Sloane. Eﬃcient
regression veriﬁcation. In International Workshop on
Discrete Event Systems , pages 147–150, 1996.
[43] S. Liang and G. Bracha. Dynamic class loading in the
Java virtual machine. SIGPLAN Notices ,
33(10):36–44, 1998.
[44] Q. Luo, F. Hariri, L. Eloussi, and D. Marinov. An
empirical analysis of ﬂaky tests. In International
Symposium on Foundations of Software Engineering ,
pages 643–653, 2014.
[45] S. McIntosh, B. Adams, and A. E. Hassan. The
evolution of Java build systems. Empirical Software
Engineering , 17:578–608, 2012.
[46] B. Mitchell and S. Mancoridis. On the automatic
modularization of software systems using the Bunch
tool.Transactions on Software Engineering ,
32(3):193–208, 2006.
[47] A. Neitsch, K. Wong, and M. Godfrey. Build system
issues in multilanguage software. In International
Conference on Software Maintenance , pages 140–149,
2012.
[48] Oracle. pack200 speciﬁcation. http://docs.oracle.c om/
javase/7/docs/technotes/guides/pack200/pack-spec.
html.
[49] ProGuard. http://proguard.sourceforge.net.
[50] M. Pukall, A. Grebhahn, R. Schr ¨oter, C. K ¨astner,
W. Cazzola, and S. G ¨otz. JavAdaptor: Unrestricted
dynamic software updates for Java. In International
Conference on Software Engineering , pages 989–991,
2011.
[51] T. Ritzau and J. Andersson. Dynamic deployment of
Java applications. In Java for Embedded Systems
Workshop , 2000.[52] C. Sadowski, J. van Gogh, C. Jaspan, E. S ¨oderberg,
and C. Winter. Tricorder: Building a program analysis
ecosystem. In International Conference on Software
Engineering , pages 598–608, 2015.
[53] sbt - the interactive build tool. http://www.scala-sb t.
org.
[54] SCons: A software construction tool. http://www.
scons.org.
[55] A. Shi, T. Yung, A. Gyori, and D. Marinov.
Comparing and combining test-suite reduction and
regression test selection. In International Symposium
on Foundations of Software Engineering , pages
237–247, 2015.
[56] Speeding up the build. http://docs.travis-ci.com/us er/
speeding-up-the-build.
[57] S. Subramanian, M. Hicks, and K. S. McKinley.
Dynamic software updates: A VM-centric approach.
InConference on Programming Language Design and
Implementation , pages 1–12, 2009.
[58] The Apt package manager. https://wiki.debian.org/
Apt.
[59] The class ﬁle format. https://docs.oracle.com/javas e/
specs/jvms/se7/html/jvms-4.html.
[60] Travis CI - test and deploy with conﬁdence. https://
travis-ci.com/.
[61] Travis CI - issue 1441. https://github.com/travis-ci /
travis-ci/issues/1441.
[62] Travis CI - issue 189. https://github.com/yegor256/
thindeck/issues/189.
[63] M. Vakilian, R. Sauciuc, J. D. Morgenthaler, and
V. Mirrokni. Automated decomposition of build
targets. In International Conference on Software
Engineering , pages 123–133, 2015.
[64] S. Vinoski. CORBA: integrating diverse applications
within distributed heterogeneous environments.
Communications Magazine , 35(2):46–55, 1997.
[65] X. Xia, X. Zhou, D. Lo, and X. Zhao. An empirical
study of bugs in software build systems. In
International Conference on Quality Software , pages
200–203, 2013.
[66] S. Yoo and M. Harman. Regression testing
minimization, selection and prioritization: A survey.
Journal of Software Testing, Veriﬁcation and
Reliability , 22(2):67–120, 2012.
[67] Y. Yu, H. Dayani-Fard, and J. Mylopoulos. Removing
false code dependencies to speedup software build
processes. In Conference of the Centre for Advanced
Studies on Collaborative Research , pages 343–352,
2003.
654