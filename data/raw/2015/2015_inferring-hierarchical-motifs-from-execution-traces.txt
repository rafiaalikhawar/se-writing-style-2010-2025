Inferring Hierarchical Motifs from Execution Traces
Saba Alimadadi∗
Northeastern University
Boston, MA, USA
saba@northeastern.eduAli Mesbah
University of British Columbia
Vancouver, BC, Canada
amesbah@ece.ubc.caKarthik Pattabiraman
University of British Columbia
Vancouver, BC, Canada
karthikp@ece.ubc.ca
ABSTRACT
Program comprehension is a necessary step for performing many
software engineering tasks. Dynamic analysis is effective in pro-
ducing execution traces that assist comprehension. Traces are rich
sourcesofinformationregardingthebehaviourofaprogram.How-
ever, it is challenging to gain insight from traces due to their over-
whelming amount of data and complexity. We propose a generic
technique for facilitating comprehension by inferring recurring
execution motifs. Inspired by bioinformatics, motifs are patternsin traces that are flexible to small changes in execution, and arecaptured in a hierarchical model. The hierarchical nature of the
model provides an overview of the behaviour at a high-level, while
preserving the execution details and intermediate levels in a struc-
tured manner. We design a visualization that allows developers to
observe and interact with the model. We implement our approach
inanopen-sourcetool,calledSabalan,andevaluateitthrougha
userexperiment.TheresultsshowthatusingSabalanimproves
developers’ accuracy in performing comprehension tasks by 54%.
CCS CONCEPTS
•Software and its engineering →Software maintenance tools ;
KEYWORDS
Program comprehension, behavioural model, hierarchical motifs
ACM Reference Format:
Saba Alimadadi, Ali Mesbah, and Karthik Pattabiraman. 2018. Inferring
Hierarchical Motifs from Execution Traces. In ICSE ’18: ICSE ’18: 40th Inter-
nationalConferenceonSoftwareEngineering,May27-June3,2018,Gothen-
burg, Sweden. ACM, New York, NY, USA, 12 pages. https://doi.org/10.1145/
3180155.3180216
1 INTRODUCTION
Programcomprehensionisanessentialfirststepformanysoftware
engineering tasks. Developers spend a considerable amount of
timeunderstandingcode.About50%ofmaintenanceeffortisspent
oncomprehensionalone[ 16].Unfortunately,codeunderstanding
is challenging. To understand code, developers typically start by
∗Work performed while a PhD student at the University of British Columbia (UBC).
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
©2018 Copyright held by the owner/author(s). Publication rights licensed to the
Association for Computing Machinery.
ACM ISBN 978-1-4503-5638-1/18/05...$15.00
https://doi.org/10.1145/3180155.3180216searching for clues in the code and the environment. Then they go
backandforthontheincomingandoutgoingdependenciesto relate
pieces of foraged information. Throughout the process, they collect
information they find relevant for understanding the code on an
“as-needed” basis [ 42]. However, developers often fail in searching
and relating information, and lose track of relevant information
whenusingsuchad-hocstrategies[ 70].Further,developersform
mentalmodelsofcode,thatareofteninaccurate[ 60].Thus,there
is a need for systematic and automated techniques for program
comprehension [46].
Dynamic analysis, which collects and utilizes data (traces) from
programexecution[ 20],isapopulartechniqueforprogramcom-
prehension.However,duetothe amountofinformationobtained
during the execution, the traces tend to become complex and over-
whelming,andthusdifficulttounderstand[ 17,80].Existingtech-
niques target this problem, e.g., by summarizing traces [ 32], struc-
turing and visualizing collected data [ 2,3,29], or inferring system
specifications[ 61].However,thefirsttechniquelosessomeofthe
data that may still be valuable, and the rest become overwhelm-
ingfordevelopersandarenotflexibletosmallvariationsofdata.
The problem can also be approached by finding patterns in the
execution. However, prior work in the area has predominantly
focused on generic and predefined design patterns, low-level archi-
tecturalrelationsbetweenprogramartifacts,orvisualizationsofall
detailsofexecution[ 3,13,35,43].Whileuseful,theseapproaches
donotcapturethebehaviouralpatternsthatareneitherdefinednor
known prior to analysis, but form and recur (with small variations)
throughouttheexecutionofaprogram.Eveninmoretraditional
programming languages, patterns in execution do not repeat ex-
actlyinthesamemannerorsamesequence.Further,presenceof
programminglanguagesfeaturessuchasdynamism,asynchrony
and non-determinism in the execution makes the analysis more
problematicandburdensome,andrendersconventionaltechniques
ineffective. Hence, program comprehension through dynamic anal-
ysis still remains challenging [20].
In this paper, we propose a novel technique for program com-
prehension by inferring a model of execution motifs. Motifs are
abstract and flexible recurring patterns in program execution that
serve a specific purpose in the functionality of the program. The
termisinspiredby sequencemotifs,whicharerecurringpatternsin
DNA sequences that have a biological function [ 24]. Our approach
discovers motifs from traces containing function executions and
events.Ourproposedalgorithmcomparesatraceobtainedfromaninteractionsessionagainstadatabaseofpreviously-collectedtraces.
Ititerativelyexaminessegmentsoftracesfordetectingsequences
of function executions that may recur in execution. It is tolerant of
small variations in different manifestations of each motif, allowing
abstraction in inferred motifs. The algorithm discovers hierarchies
7762018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden S. Alimadadi et al.
Email:
Address:
Occupation: Select one
...
Student...
Degree: Select oneA
B
SubmitI
———————-——
———————-—————————-—————————-—————————-—————————-—————————-—————————-—————————-—————————-—————————-—————————-——
———————-——
———————-—————————-—————————-—————————-—————————-——BII
———————-—————————-—————————-——
———————-——
———————-—————————-—————————-—————————-—————————-—————————-—————————-—————————-—————————-—————————-—————————-—————————-—————————-—————————-——A
window
validateEmail
checkAddress occupation studentFormsubmitIII
Figure 1: I: A sample registration form. II: A) Sample execu-
tiontrace,andB)hierarchyofinferredmotifs.III:Dynamic
call graph of example
between motifs as they emerge from details of execution. The hier-
archicalstructureofinferredmotifsrevealshowhigher-levelkey
pointsofexecutionareformed.Itallowsuserstohaveanoverviewofthetrace,whilestillhavingaccesstoallexecutiondetailsaswell
as all intermediate levels.
The main contributions of our work are as follows:
•We propose an automated approach for inferring a modelof program behaviour, which encompasses hierarchies ofabstract recurring motifs extracted from execution traces.
Our approach is inspired by techniques from bioinformatics,
wheresimilarchallengesariseininvestigatingsimilarities
in large sequences of DNA. The motifs facilitate program
comprehensionbyhighlightingthemaincharacteristicsof
behaviour, and abstracting the details and variations of exe-
cution.
•Wedesignandbuildavisualizationtechniqueforpresentingthemotifstodevelopers,toprovideassistancewithprogram
comprehension.Ourmethodiscomplementarytoexisting
toolsandtechniques,andisdesignedtobeutilizedalongside
existing programming environments.
•WeimplementourapproachinatoolcalledSabalanthat
supports JavaScript-based web applications. Our tool is non
intrusiveforgeneratingtraces,andinfersmodelsofrecur-
ring motifs from execution trace in an automated manner.
•We evaluate our approach through a controlled experiment
conductedwith14participants,onasetofreal-worldpro-
gram comprehension tasks. The results show that using Sa-
balan helps developers perform program comprehension
tasks 54% more accurately than other tools.
2 CHALLENGES AND MOTIVATION
Toassisttheprocessof searching, relatingandcollecting information,
many techniques collect execution traces, analyze them, and/or vi-
sualizetheresultsforthedevelopers.Despiteprovidingthegrounds
forpreciseanalyses,dynamictracesbecomeverylargeandcause
informationoverload.Further,theybecomeverycomplexdueto
dynamism, asynchrony and non-determinism in program execu-tion. These challenges render large traces ineffective in assisting
program understanding.1<form>
2Email: < input type ="email" id="email" >
3Address: < input type ="text" class="addr">
4Occupation: < div class ="dropdown" id="occupation" >
5<button class ="dropbtn" >
6 Choose one</ button>
7<div class ="dropdown-content" >
8 <a href="#">Academic</ a>
9 <a href="#">Industry</ a>
10</div>
11</div>
12<input type ="submit" value="submit" >Submit</ input>
13</form>
Figure 2: Initial DOM state of the running example.
1$("#email" ).addEventListener( "change" , validateEmail, false);
2$(".addr" ).click(checkAddress);
3$(".dropdown-content" ).addEventListener( "change" , occupation, ←/arrowhookright
false);
4function validateEmail () {
5// do stuff
6}
7function checkAddress() {
8// do more stuff
9}
Figure 3: [Partial] JavaScript code of the running example.
In this section, we use a simple example to illustrate these chal-
lenges (Figures 1–3). We selected JavaScript for the examples since
it is the lingua franca of web development. It has been recently
votedasthemostpopularprogramminglanguageonStackOver-
flow[75],andisthemostusedlanguageonGitHub[ 45].JavaScript
applicationsarehighlydynamic,asynchronousandeventdriven,
and heavily interact with the Document Object Model (DOM) and
theservercode[ 1].Thesefeaturescanhelpdemonstratetracecom-
plexity within small code segments. While our approach is general,
we use JavaScript in this paper to demonstrate it.
Overload by Information in Large Traces. The amount of in-
formation a trace carries matters due to the cognitive load that
understandingthetraceimposesondevelopers[ 19],e.g.,astudy
foundthatoneGBoftracedatawasgeneratedforeverytwosec-
onds of executed C/C++ code [ 68]. For modern applications, which
areoftendistributedamongmanynodeswithmanycomponents
involved, the traces become incomprehensible for developers very
quickly.Sometechniquestrytoaddresstheproblembyreducing
thetraceduring/afteritscollection[ 12,32,68]byfocusingonmore
important entities, or filtering the details of the executions. These
techniqueshavebeenabletomaketracesmoreusefulbydecreasing
the information contained in the traces [ 37]. However, even with a
technique that creates a smaller trace, the trace is still not neces-
sarily understandable for developers, as some of the data might be
lost or missed by developers.
Complex and Hidden Dependencies. Revealing abstract and
higher-levelpatternsthathighlightthekeypointsofaprogram’s
behaviourcanfacilitatecomprehension.Thefocusofthedeveloper
canbeguidedthroughahierarchyofrecurringpatternsofexecu-
tion,whileallcollectedinformationarestillpreservedforfurther
inquiry.However,extractingsuchpatterns(motifs)ischallenging
duetothedynamism,asynchronyandnon-determinisminprogram
execution, expecially in JavaScript applications.
777
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. Inferring Hierarchical Motifs from Execution Traces ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
First,therearemanycomplexandhiddendependenciesbetween
entities in the system, which can affect the execution. Understand-
ing the impact of a user action or asynchronous communication
with the server are examples of relations that are difficult, if not
impossible,tocapturefrommerelyanalyzingthecodeorthecall
graph. They act as media for connecting segments of execution
together, that otherwise would not be related in the code itself.Further, for a part of behaviour to be distinguished as a motif, it
should recur during the execution. Different executions of what is
conceptually the same motif, may vary in details and thus may not
convergetorevealthesamemotif.Thealterationsareintensified
whenprogramshaveuserinterfaces,aredistributed,orinvolvegen-
eraldynamism andasynchrony . However, suchvariations should
not prevent the analysis from recognizing the high-level blueprint
ofthebehaviouralmotiftheyallmanifest.Ananalysisthatisoverly
dependent on execution details may not allow higher-level motifsto reveal themselves.
Example. Consider the example shown in Figure 1, showing a
partofaformrequiredforregisteringauser.Specificeventsontheinputfieldsoftheformhavehandlersthatvalidatetheinputbefore
theformcanbesubmitted. verifyEmail() andcheckAddress()
(lines1–2ofFigure3)arehandlersfor emailandaddress fieldsof
part (A) of the form (lines 2–3 of Figure 2). The two function are
always executed together in a successful registration scenario, and
are a consistent part of the motif representing that scenario, due
totheirplacementintheDOM.However,thisrelationcannotbe
inferred from the code (Figure 3) or the call graph (Figure 1.III).
Moreover,asuccessfulsubmissionrequirespropersubmissionof
allthefields.However,theformcanchangeinsection(B)ofFigure1basedontheinputof
occupation (lines4–11ofFigure2).Iftheuser
choosesStudent, a drop-down menu appears and the appearance,
content,andfunctionalityoftheformchangesbasedonuser’sinput.However,theconceptualpurposeofsubmittingtheform,andhence
themotif,remainthesame.Shouldananalysisbetoodependent
on exact execution details, these two executions will be considered
different.However,amorerepresentativeanalysisshouldrecognizethatregardlessofoccupationoftheuser,theessenceofthemotifisthe same and it should support both options. There is often neither
priorknowledgenortemplatesoftheapplication-specificmotifs.
Hence,ausefulcomprehensionmethodshouldaccomodateadegree
of flexibility in inferring motifs, to allow abstract motifs to form
independently from unimportant contextual details.
3 OVERVIEW OF THE METHODOLOGY
For execution traces, such as the one depicted in Figure 1.II.A, our
goalistoinferahierarchyofitsrecurringmotifs,byutilizingthe
knowledge of previous executions of the application. The model of
extractedmotifsassistscomprehensionoftheprogrambehaviour
byfacilitatingthecycleof searching, relating,and collecting infor-
mation.Havingourproposedapproach,developersareabletogainanoverallunderstandingofthehighlightsofexecution,manifested
as motifs, at a glance. Further, they would have the means to un-
derstand the details of such motifs, their hierarchies, and relations
upon inquiry(Figure 1.II.B).Our approach takesadvantage ofpre-
cision of dynamic analysis, but prevents developers from being
trapped and overwhelmed by the execution details.Ourproposedapproachfirstinstrumentsandinterceptstheap-
plication on the fly, to obtain traces. Having a knowledge-baseof previously collected traces and a query trace, our algorithmthenextractsmotifsofdifferentlengthswithintraces,andinfers
hierarchies and relations of motifs. Our algorithm is inspired by
bioinformaticsalgorithmsforaligningbiologicalsequences.Finally,
ourapproachcreatesabehaviouralmodelfromthemotifsandtheir
relations, which we visualize for developers.
Execution Traces. To obtain the traces required for the algo-
rithm,we instrument theapplicationsandcollectdynamicexecution
information automatically. Our instrumentation allows our tech-
nique tointerceptall function executions and collect their context-
sensitive information. It also intercepts all events that can occur
duringtheexecution.Theiraddedknowledgecanassistthealgo-
rithm in inferring conclusions about motifs and their causal and
temporal relationswith (a)synchronousevents. Next,our approach
eliminates low-level details included in the raw trace, such as aux-
iliaryevents,low-levelandlibrarymethodcalls,andframework-
specificdetails.Theprunedtraceisthenusedastheinputtothealgorithm. Note that our method is non intrusive, and preserves
the original behaviour of the application under investigation.
4 ALGORITHM FOR INFERRING MOTIFS
In this section, we propose our algorithm for detecting motifs in
ordertocreate ahigher-levelmodelof behaviour.We definemotifs
asabstract andhierarchical sequencesoffunction executionsthat
recurthroughoutthelifetimeofanapplication.Whileeachmotif
eventuallysupportsconcretesequencesoffunctionexecutions,itisbynatureacompositeelement,andcanrepresentmorecomplicated
structures. We define a motif as an ordered set of two or more
members( m0tomi),whichinclude[sub-]motifs,abstractentities,
andcontext-sensitivefunctionexecutions.Theconfidenceofamotifineachofitsmembersisrepresentativeofthemannerthatmember
is observed within different executions of the motif, and is shown
asc0tocifor all motif’s members, respectively.
M={/angbracketleftm0,c0/angbracketright.../angbracketleftmi,ci/angbracketright|∞
i=1},mi::=function execution
|sub-motif
|abstract entity
Our approach draws the attention of developers to the main
observed motifs, presumed to represent highlights of behaviour,preventing their view to be obstructed by low-level details. The
underlyingmodelstillpreservesdetailsthatcanbedemandedby
users as necessary.
4.1 Inspiration from Analyzing Biological
Sequences
In designing the algorithm, we were inspired by bioinformatics,
where there is a constant need to explore, compare, and analyze
largedatasequences.Mostrelevanttoourapproachare sequence
alignment algorithms, which find similarities in sequences of DNA,
RNA,andproteinbyarrangingandcomparingthem[ 31].Webegin
ourcorealgorithmbyusingaheuristicforfindingexactmatches
betweentracesequences.Forcomparisonofthetracesequences,
weadapttheideaofBLAST(BasicLocalAlignmentSearchTool)
[4],alocalsequencealignment algorithmwhichwemodifytofitthe
778
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden S. Alimadadi et al.
k = 2k = 3
expandedbaz. 
..DB Traces
exact 
match
occupationvalidateEmail
checkAddress
bazbar
foo
bar
submit
barindes.html:11
removepopupchange
showPopupchange
transition
grouped
stacked
foo
bazoccupationvalidateEmail
checkAddressfoo
barQuery Trace
studentForm
submit
bar
change
transitionexact matchA B
... ... ...
Figure4:This figuredepictsaDBoftraces (A)andasample
query trace (B) of an application, on the left and right side,respectively. Exact matches of length 2 and 3 between thequery trace and different DB traces are marked.
domain of execution traces. We then expand the matches by maxi-
mizingsimilaritiesintheirneighbouringentitiesinthetraces.This
phase is accomplished using a dynamic programming algorithm in
order to allow more flexible and more abstract motifs. Throughout
this process, our method infers existing motifs and reveals their
relationsandhierarchies.Inthissection,weuseAlgorithms1–2
and Figures 4 – 5 to explain our algorithm. Our algorithm takes
theapplication( app)anditsknowledge-base( ΣΣdb)asinputand
returns the extracted motifs as output. Please note that we have
eliminated and/or merged many details for the sake of brevity. The
details can be found in the repository of our open-source tool [ 71].
4.2 Forming a Knowledge Base
Our algorithm requires a knowledge base of multiple previous
executions, i.e., a set of traces, named database (DB) traces (ΣΣdb),
whichcaninitiallybecollectedbyexecutingthetestsuite,crawling,
orexploratorytestingandexercisingtheapplicationmultipletimes.Duringeachinteractionsession,ourapproachcollectsatrace,called
thequery trace (Σq), which will be analyzed and compared against
all DB traces for finding its motifs. Each query trace is itself added
totheDBtracesafterthealgorithmisfinished.Thispartisdepicted
inlines2–4ofAlgorithm1.PartsAandBofFigure4displaysample
DB traces and query trace of the running example (Figure 3).
4.3 Finding Exact Matches
Next,thealgorithmfindsalltheexactmatchesoflength kbetween
thequerytraceandtheDBtraces.Westartbymatchesoflength
2 (function pairs). We then increment the length of exact matches
iteratively and repeat the search at each iteration, until we have
found all exact matches. Two sets of exact matches of length 2and 3 are shown in Figure 4, between 2 DB traces (part A) and
the query trace (partB). Lines 7–8 of Algorithm 1 iterateoverthe
query trace for finding matches of length k, and increment kat
each iteration. Lines 9–10 show that subsequences of length kare
extracted from the query trace at each iteration, and are compared
against all k-length subsequences of all DB traces to find matches.
4.4 Allowing Abstraction in Motifs
Inthenextstep,weexpandeachmatchtoprogresstowardsfinding
flexible and abstract motifs, that are tolerant of small alterations.
This technique decreases dependency on specific execution details,Algorithm 1 Finding exact matches and expanding them
1:procedure ExtractPatterns( app,ΣΣdb)⊿app: application under analysis, ΣΣdb:
algorithm knowledge base (DB traces)
2:modifiedApp←instrument( app)
3:rawTrace←intercept(modifiedApp)
4:Σq←prune(rawTrace)
5:k←2
6:motifs←ϕ
7:fori←k; i≤Σq.length; i ++ do
8: forj←0; j≤Σq.length - k; j ++ do
9: subQ←extractSubTrace (k,Σq,i,j)
10: matches←exactDbMatches( ΣΣdb, i, subQ)
11: form←0; matches.length; m ++ do
12: forn←0; n < matches[m].length; n ++ do
13: dir←initialExpansionDirection()
14: ΣI←⎡⎢⎢⎢⎢⎣qI
startqIend
dbIstartdbIend⎤⎥⎥⎥⎥⎦
15: ifexpandable( Σq,ΣΣdb[m]),ΣIthen
16: subDb←matches [m][n]
17: expandedQ←Σq.expand(sub q,ΣIq, dir)
18: expandedDb←ΣΣdb[m].expand(sub db,ΣIdb, dir)
19: dir←dirExpansion(toggle: true, ΣΣdb[m],Σq,ΣI)
20: k.increment()
21: motif←compare(expandedQ, expandedDb, k)
22: matches.push(motif, k)
23: motifs.add(motif)
24: ΣI←adjustExpansionIndices(dir)
25: end if
26: end for
27: end for
28: end for
29:end for
returnmotifs
30:end procedure
providesahigher-leveloverviewofthesemanticsoftheapplication,
andpermitsflexiblemotifsofvariablelengththatmayincludegaps.
Atthisstage,ouralgorithmiterativelyperformsthefollowing
steps.First,itselectstwomatchesfromexistingmatches,which
were determined as the result of previous step (Figure 4). Then,
ititerativelyexpandsthequeryandDBmatchesfrombothdirec-
tions,whilegraduallyincrementingthelengthofthemotifunder
investigation (Lines 11–27 of Algorithm 1). Figure 4 also shows an
expanded match of two [partially] different sequences, for measur-
ingtheirsimilarities(Figure4.A).Thisphasecontinuesuntilthe
accumulated penalty of gaps interrupts expansion of the motif.
Next,thealgorithmfindsa[sub-]sequenceofthosematchesthat
have the maximum similarity. At this step, we adapt a dynamic
programmingalgorithmcalled Smith-Waterman forfindingpatterns
in two molecular sequences [ 74]. This algorithm quantifies the
sequencealignmentprocessbyassigningscoresformatchesand
mismatches, and penalties for gaps. Aligned sequences are then
foundbysearchingforthehighestscoresinscoringmatrices.To
adapt this algorithm to our domain and compare similarities oftwo traces, we propose a similarity matrix that determines the
similarityoftwomembersintraces.Thesimilarityofthetracesare
determinedbyacombinationofsimilaritiesofalltheirmembers,
based on a dynamic programming heuristic.
Similarity Matrix. We propose a similarity measure for quanti-
fying the similarities between function executions in traces. Our
comparisonis basedontwo metrics,functionnamesand parame-
ters. We devise three scores for comparison: strong match, weak
match, and mismatch (leading to a carryover penalty). If two func-
tionsmatchintermsofnamesandparameternumberstheyarea
strong match. The match is weak if only the names are equal (and
not parameter numbers). The reason for considering parameter
779
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. Inferring Hierarchical Motifs from Execution Traces ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
submit
Expanded Match
submitstudentFormoccupationcheckAddres
svalidateEmail
DB
TraceDBTrace
validateEmail
checkAddress
occupation
submitQuery TracevalidateEmail
checkAddress
occupation
submitsubmitstudentFormoccupationcheckAddres
svalidateEmailQuery 
TraceQuery Trace
DB Trace
occupationvalidateEmail
checkAddress
submitoccupationvalidateEmail
checkAddress
studentForm
submit
DBTracevalidateEmail
checkAddress
occupation
submitsubmitstudentFormoccupationcheckAddres
svalidateEmailQuery 
Trace
submitstudentFormoccupationcheckAddres
svalidateEmail
DBTracevalidateEmail
checkAddress
occupation
submitQuery 
Trace


su
NOoccupationvalidateEmail
checkAddress
ABSTRACTA
C
DB
EF
Match? Pattern
Figure5:Thisfigurebrieflydepicts(A)theprocessoftaking
twoexpandedtracesubsets,(B,C)formingascoringmatrixbased on similarities between sub-traces, and (D, E) findingamatchinmannerthatmaximizesthesimilaritiesbetweensub-traces. The final motif can be seen in (F).
countasaseparatemetricisthenatureofJavaScript,whereafunc-
tion call does not need to be faithful to the function signature in
terms of arguments (known as function variadicity). Two function
executionsdonotmatchifbothmetricsaredifferent.Thestrong
andweakmatchesareassignedpositivescores,whilethemismatch
is assigned a negative score as it can represent gaps in the motif,
which can accumulate and disrupt a motif. The base scores for
matches and penalties are determined using empirical data.
Moreover, our matrix needs to support comparison of motifs, to
accommodateanotherextensionoftheoriginalalgorithm,which
permits hierarchies between motifs. The function execution mem-
bers of a motif are compared as explained above. Should a motif
containanabstractnode,thenallvalidexecutionsoftheabstract
nodeshouldbecomparedwiththeothersequence.Throughoutthe
processof comparingmotifs,our algorithminfers hierarchiesand
abstractions of motifs should they exist, as explained below.
Then, we perform our adaptation of the Smith-Waterman al-
gorithm on the two expanded sequences, as shown in line 2 of
Algorithm 2, which creates a scoring mechanism for comparing
thetwosequencesbasedonaone-by-onecomparisonofalltheir
entities, based on our similarity matrix. The result is a scoring
matrix of overall scores of comparing two sequences ( Mk+1,k+1).
This processis shown forthe two sequencesof the runningexam-
ple from the previous step in Figure 5.A–C. To find the common
motif in these sequences, we find the sub-sequences that hold the
highest collective similarity as a group. We start by finding the
highest score in the matrix (line 3 of Algorithm 2, Figure 5.D), and
then trace the matrix back, determining the aligned motif at this
stage (lines 4–10 & Figure 5.E). For navigating the motif back in
thematrix,ourdynamicprogrammingalgorithmchoosesthemaxi-
mumneighbouringscoreateachstep(line5).Basedontheselected
neighbour,thealgorithmdetermineswhetherthatmotifmember
comes from one or both of sequences, and whether an abstract
entityshouldbeinjectedtoshowdifferentalternativesofthemotif.
Themotif’sconfidenceinthatmemberisthenupdatedbasedonAlgorithm 2 Inferring motifs
1:procedure Compare(S1,S2,k) ⊿S1,S2: two trace sequences, k: sequence length
2:Mk+1,k+1←SmithWaterman (S1,S−2,k)
3:/angbracketleftBig
imax,jmax/angbracketrightBig
←maxScoreLocation (Mk+1,k+1)
4:whileimax> 0 andjmax>0do
5:dir←maxNeighbour(i max,jmax)
6: ifdir==diagthenmotif.insert(abstract( S1[imax],S2[jmax]))
7: elsemotif.insert(function( S1[imax]==S2[jmax]))
8: end if
9:/angbracketleftBig
imax,jmax/angbracketrightBig
←backTrack (Mk+1,k+1,S1,S2,dir)
10:end while
11:ifS2.type==motifthenbuildHierarchy( S2, motif)
12:end if
returnmotif
13:end procedure
how it is selected (lines 6–7 of Algorithm 2). The inferred motif of
therunningexample(Figure5.F)hasfivemembers,oneofwhich
isabstract.Theabstractmemberwasadvisedtoenablethemotif
to support both sequences shown in Figure 5.A, which have the
same functionality (registration), but are executed in a slightly dif-
ferent manner. The abstract member demonstrates that observing
thestudentForm functioninthemotifisarbitrary,andthemotif
caneitherbeobservedeitherwithfivetotalmembersincludingthe
function,orwithonlyfourmemberswhichdonotincludefunction.
4.5 Inferring Hierarchies of Motifs
Inthenextstep,wedeviseanotherextensiontotheoriginalalgo-
rithm,whichenablesustoinferandrevealhierarchicalrelations
between motifs. By definition, our motifs are composite entities,
which can contain other motifs as their members. During the anal-
ysis, our algorithm mayencounter cases where (1) the matchthat
isbeingcomparedisamotifitself,and(2)theexpansionleadsto
discovery of a new motif. In such cases, a hierarchical relation is
addedbetweenthetwomotifs.Thismeansthatnotonlythe[sub-
]motif was observed independently within the execution, but it
also contributes to the formation of the new and larger motif. Our
analysis follows a bottom-up approach, starting with function exe-
cutions as building blocks of the trace. It iteratively works the way
up to higher-level and more abstract motifs that allow flexibilityin execution. At each iteration of the algorithm, new motifs can
be revealed which may have hierarchical relations with existing
motifs. As such motifs emerge, our algorithm captures the process
of their formation and hierarchies in a model (Section 5).
In the running example, we first find an exact match with k=3,
which is a motif itself, but with no abstraction (Figure 4). Later,
duringexpansion,wefindthatthismotifisamemberofalarger
motif (Figure 5.F) with two other members (an abstract member
and a function execution). The algorithm creates a hierarchy (line
11of2),whichthenmanifestsinthemodel(Figure6),asanedge
from the new abstract motif (node 1) to the sub-motif (node 2).
5 CREATING AND VISUALIZING THE MODEL
In this section, we explain our methodology for inferring the hier-
archical model of behavioural motifs and visualizing it.
780
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden S. Alimadadi et al.
Vertices
Pattern
FunctionAbstract
DependentExclusive
AttributeWeak
StrongRegistration
validateEmail checkAddress occupation submit studentFormclick1
2 3
8Hierarchy Abstraction
Edges4 5 6 7
Figure 6: Sample model of the running example. The root
node (1) is the highest-level inferred motif. Node 2 is a sub-motif of node (1), marked by the hierarchical edge betweenthe two. Node 3 is abstract allowing variations of its childnodetooccurinthemotif.Theleavesof(nodes4–8)arecon-crete function executions in the trace.
5.1 Creating the Motif Model
Asmentionedabove,duringtheprocessofextractingmotifs,our
approach infers the hierarchies and other potential relations be-tween them. Such structural relations are preserved in a model,represented as a directed acyclic graph (DAG), which evolves as
the algorithm proceeds, as explained below.
Vertices. Verticesofthegraphcanbefunctions,motifs,abstract
entities,ordependentvertices. Functionverticesareatomicnodes
representing specific and context-sensitive function executions.
Motifvertices are semantically composite classes. Each motif con-
ceptually contains an ordered set of its members. Abstractvertices
arethemodel’smeansforsupportingflexibilityinmotifs.Should
there be alterations in different observations of a motif, an abstract
node is used for accommodating all valid cases. Dependent vertices
hold additional attributes of other types of vertices. and exist only
to provide more information about other vertices. e.g., an event
contributingtoafunctionexecutionisshownasadependentvertex.
Edges.Theverticesofthegraphareconnectedthroughdirected
andorderededges.Theedgesareresponsibleforconnectingmotifs
to their members. The direction of an edge is from a motif node
to its members, which are orderedbased on the time they were
observedintraces.Theedgesalsorepresentthe confidence ofthe
algorithm in the respective member (strong or weak), based on the
manner of observation of the member. Edges may contain other
specialattributes,dependingonitstypeandthepurposeitserves
in the model. For instance, the “edge exclusion” property is used to
show that only one of the variations of an abstract node is valid at
a given time.
Figure6representsthemodeloftherunningexampleofFigure1.
TherootoftheDAG(node1)isamotifrepresentingregistration.It
consist of three members: a sub-motif (2), an abstract node (3), and
afunctionexecution(8).Thefirstmemberisamotifitself,which
contains a sequence of three functions from the trace, marked 4–6.
Thestrongedge to the sub-motif (and from there to its children)
shows the high confidence of the algorithm in the sub-motif. Node
3 is an abstract node, acting as a place holder for valid versions of
the node, manifested in its children. This node exists due to the
variation in two observations of the motif (Figure 5.A). In the case
ofourexample,the exclusivetypeofthechild(7)edgedemonstrates
AB
E
DC
DB Motifs
Figure 7: A [modified] screenshot of visualization. (A):Query trace. (B): Inferred motifs depicted on the table. (C):Motifhierarchies.(D):Allmotifs.(E):Codepaneldisplayingselected function/motif code.
that occurrence of this node is optional in the motif ( studentForm
is observed or not). Further, the weakedge type displayed the al-
gorithmlowconfidenceinthisnode.Node8,thefinalmemberof
1, is an execution of function submit. All leaves of the DAG are
concrete function executions from the trace. Nodes at higher levels
of a graph involve abstractions and hierarchies, to represent the
incremental process of emergence of motifs from details of trace.
MotifRelations. Thehierarchiesthatformbetweenmotifsare
one type of relations that are preserved through the model. Thealgorithmalsodiscoversothertypesofrelationsbetweenmotifs,such astemporal orcausalrelations. The integration of all these
relations depicts how semantics of the program are shaped from
bottom (small specific motifs) to the top (larger and more abstract
motifsrepresentingkeypointsofbehaviour).Themotifsmaybe
semanticallyrelatedinmannersthatarenotquiteobviousfromthe
code. For instance, motif m1maycausemotifm2, or they may be
ordered (but not dependent) due to the design and the architecture
ofthe system.Queryingthe modelallows ustorevealpatternsof
motifsthemselvesandevendiscoverpatternsthatarenotknown
tothedeveloper,arecreatedunintentionally,orareimposedonthe
system by other factors such as third-party frameworks.
5.2 Visualizing the Model
Finally,wevisualizethemotifstofurtherassistprogramcomprehen-
sionbytakingadvantageofinformationvisualizationtechniques.
Our web-based visualization provides twomain views for display-
ing (1) the motifs recorded in a specific query trace, and (2) all
motifs discovered in the behaviour (DB traces).
Trace Motifs. To allow developers to focus only on a part of
behaviour that is of interest to them, this view displays motifsthat are found within the query trace, freshly recorded from aninteraction session (Figure 7, A and B). Section (A) of the figure
displays thepruned query trace, wheretime proceeds from topto
bottom.Section(B)displaysthemotifs,distinguishedbycolourand
index. The saturation of each cell of a motif displays the motif’s
confidenceinthatmember.Eachmotifmayrecurmultipletimesin
the same trace, or may contain hierarchies of motifs (Figure 7C).
AllMotifs. Thesecondviewismeanttoprovideaglobaloverview
ofapplicationbehaviourbydisplayingallitsmotifs,extractedfrom
all DB traces (Figure 7D). These motifs may display system use-cases, feature implementations, or other higher-level sequences
781
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. Inferring Hierarchical Motifs from Execution Traces ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
thatsomehowdescribethefunctionalityofthesystem.Theydonot
conform to a single trace, and thus each motif has its own separate
trace. In both views, hovering the mouse over each entity displays
moreinformationregardingthatentityinthetooltip.Clickingon
anentitydisplaysitsrespectivecode(functionormotif)onthecode
panel(Figure7E).Displayingonlythecoderelevanttothemotif,
allows developers to only focus on their specific task, without the
added burden of understanding the whole application.
6 IMPLEMENTATION: SABALAN
Weimplementedourapproachin anopen-sourcetool,calledSa-
balan. The entire tool is implemented in JavaScript. We create our
ownExpress.jsserverfor implementingthealgorithm,theinstru-
mentationunit,andthevisualization.Wedevelopthebioinformatics-
inspired algorithms from scratch for execution traces. We use a
proxytoautomaticallyinspectapplications[ 38].Forinstrumenting
thecode,wecreateanASTofthecode,modifyit,andserializeit
back into JavaScript [25–27]. Sabalan is publicly available [71].
7 EVALUATION
We empirically evaluate our approach by investigating the char-
acteristicsoftheextractedmotifs,aswellastheusefulnessofour
approach for developers and its overhead through the following
research questions.
RQ1.What are the characteristics of typicalmotifs inferred by Sa-
balan from execution traces?
RQ2.Does using Sabalan improve developers’ performance for
common comprehension tasks?
7.1 Motif Characteristics
To address RQ1, we performed our analysis on seven JavaScript
applications, listed in Table 1.
Design.We selected seven open-source JavaScript applications
fromGitHub(Table1).Theseapplicationscovervarioussoftware
domains and were selected based on their popularity and usage.
Basedoneachapplication’sspecifications,weselectedamethodfor
collectingitstraces(runningthetestsuiteordesigningscenarios
for exploratory testing). We provided the traces (DB and query) as
input, and analyzed their extracted motifs and investigated their
main characteristics. We measured the number of unique motifs
inferredfromalltracesforeachapplication,calculatedtheirlengths,
and analyzed their hierarchies. We registered the size of DB traces
in terms of number of different traces as well as the size of a trace.
Results andDiscussion. The resultsof the analysisare depicted
inTable1.Thesecondcolumndisplaysthenumberoflinesofcode
foreach application,while thethird columncontainsthe number
of motifs found in the applications. The next column representsthe number of DB traces collected for each application. Column
five, shows the average size of traces of each application, collected
by Sabalan in one-minute interaction sessions. Note that our tool
performsaleveloffilteringwhileloggingexecutiondetails.ColumnsixshowstheaveragetracesizecollectedbyGoogleChrome’sJava-
Script profiling and Timeline. It can be seen that the average trace
sizeusingSabalanis77KBs,whilewithoutSabalanthereisan
average of96 MBsofdata forthe sameinteraction session.These
values emphasize the extent of the information contained in theTable 1: Characteristics of traces and inferred motifs
Motif Length
Application LOC # of
M.#of
DBTrace
size
(KB)Raw
Trace
(MB)Avg Min Max #o funqH.
Phormer 6000 13 20 84 86 42 1 1 4
same-game 229 4 7 255 143 324 0
simple-cart 9238 4 19 45 67 428 3
browserQuest 36206 17 15 67 125 539 2
adarkroom 15612 6 15 41 40 426 2
doctored.js 3534 4 10 16 102 325 1
hextrix 5154 7 16 30 110 426 2
Average 10853 8 14.5 77 96 427 2
raw traces, even for modest-sized applications, which makes it
challenging for developers to analyze them. However, using ourapproach, developers have an average of 8 recurring high-levelmotifs for each interaction session, each with an average lengthof 4 (columns 7–9), to guide them through the understanding of
the behaviour. The last column displays the number of unique
hierarchicalrelationsbetweenuniqueinferredmotifs.Thenumbers
show the existence of hierarchies of motifs. Further assessment
ofthestructuresofmodelgraphsdepictthebottom-upformation
of higher-level key points of behaviour based on smaller motifs
through such hierarchies.
Thereareafewcasesintheresultswherethealgorithmwasnot
able to find many (meaningful) motifs, or any hierarchies. Upon
further investigation, we found that these applications rely heavily
on external and graphic libraries, which we had disabled in our
analysis. These features can be activated in the future if needed.
Animportantfactorthatcanimpacttheefficacyofthealgorithm
is therequirements of the DB traces. The number of initial traces in
the knowledge base, their coverage of the application’s functional-
ity,andtheirsimilarities(ordifferences),arefactorsthatcanimpact
the quantity and quality of the final motifs. We aimed to maximize
the features we covered with the DB traces. We stopped collecting
new DB traces when we observed that adding a trace did not affect
the inferred motifs (average of 14.5 DB traces per application).
7.2 Controlled Experiment
Next, we conducted a controlled experiment to assess the effective-
nessofourtechniquefordevelopersinpracticeandaddressRQ2.
We divided the participants into control and experimental groups.
Theexperimentalgroupusedourapproach,whilethecontrolgroup
usedthetooloftheirchoice.Theparticipantsaccomplishedaset
ofcomprehensiontasks,andtheirperformancewasmeasured.The
tasks were designed based on common software comprehension
activities[ 63].Wedefinedtheperformanceofadeveloperbythe
combination of time and accuracy of completing the tasks. Our
hypothesiswasthatusingourapproachwouldenhancedevelop-
ers’ performance in understanding the overall behaviour, main
use-cases, and recurring motifs of a web application.
7.2.1 Experiment Planning. The goal of our experiment is to
investigate the following research questions.
RQ2.1.Does using Sabalan decrease task completion durationfor
common comprehension tasks?
RQ2.2.Does using Sabalan increase task completion accuracy for
common comprehension tasks?
RQ2.3.IsSabalanbettersuitedforcertaintypesofcomprehension
tasks?
782
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden S. Alimadadi et al.
Table 2: Comprehension tasks used in the study.
Task Description Activity
T1.A Understanding all common usecases A1, A7, A9
T1.B Determining the most used scenarios A6, A7
T2.A Locating the implementation of a feature for reuse A1, A3
T2.B Estimating the quality of said implementation A4, A5, A8
T3 Understanding the addition of a new feature A1, A2, A3
Variable Selection. Our design involved one independent variable
(IV), the variable we controlled, which was the type of tool used,
i.e.,anominalvariablewithtwolevels.Werefertothefirstlevel
as Sabalan, since they had to use our tool. The second level repre-
sentedusage ofothertools, whichwerefer toasother.Our goal
wastomeasuredevelopers’performanceincompletingthetasks.
We quantified it using two variables, task completion durationand
accuracy (bothcontinuous),thatwereour dependentvariables(DV).
SelectionofObject. We chose Phormer photo gallery application
as our object [ 66], which has about 6,000 lines of code and over
43,000 downloads. It is an open-source PHP-based application that
allows users to store photos, categorize and rate them, and view
aslideshow.Sincewehadallocatedlimitedtimeforeachsession,
we had to choose an application that is simple, and yet exhibits
realistic motifs in its behaviour - these criteria are met by Phromer.
Selection of Subjects. We recruited 14 participants for our exper-
iment. They were all graduate students in computer science and
engineering, and many of them had professional software devel-opment experience. The participants consisted of 2 females and
12 males, aged between 23 and 35. Knowledge of programming
and familiarity with web development (and particularly JavaScript)
wereouronlyrequirementsforpickingtheparticipants.Overall,
ourparticipantshad1–10yearsofwebdevelopmentand1–18years
of software development experience, respectively.
Experimental Design. Ourexperimenthada“between-subject”
design.Toavoidthecarryovereffect,wedividedourparticipants
into two groups. The experimental group were given access to
Sabalan for performing the tasks, while the controlgroup used
GoogleChrome’sDeveloperTools(i.e.,DevTools)forcompleting
the session. All our participants were familiar with DevTools ac-
cordingtotheiranswerstothepre-questionnaireformandchoseto
useitduringtheexperiment.Nomemberoftheexperimentalgroup
were familiar with Sabalan prior to the study session. To avoid
bias in favour of one of the groups in terms of their proficiency
levels,wecollectedhistoricaldataaboutourparticipantspriorto
schedulingthesessions.Weassignedeachparticipantaproficiency
score,basedonacombinationofmetrics,includingtheirexperience
withsoftwaredevelopment,knowledgeofJavaScript,andhowthey
perceived theirown expertise. We balancedthe proficiency levels
in both experimental and control groups.
Experiment Tasks. Wedesignedfivecomprehensiontasks,out-
lined in Table 2, based on common program comprehension activi-
ties proposed by Pacione et al. [ 63]. As the name suggests, these
activities representfine-grainedactivities thatdevelopers needto
performforunderstandingsoftware,regardlessofthelanguageand
the platform used. Table 2 shows how each of our tasks covers one
ormoreactivities-allactivitiesarecoveredinourdesign.Moreover,
each task also included a mini questionnaire, which asked about
howparticipantsperceivedthedifficultyofthetask,therequired


0 50 100



Accuracy (%)


T1A−Ctrl
T1A−Exp
T1B−Ctrl
T1B−Exp
T2A−Ctrl
T2A−Exp
T2B−Ctrl
T2B−Exp
T3−Ctrl
T3−Exp
Total−Ctrl
Total−Exp
Figure 8: Notched box plots of accuracy results. Green plots
display experimental (Sabalan) group, and gold plots dis-
play the control group. Higher values are better.
time, andthe requiredexpertise levelfor accomplishingthe task.
We have made all the tasks and datasets publicly available [71].
7.2.2 Experimental Procedure. The procedure of the experimen-
tal sessions consisted of three main phases.
•Pre-study. Werequiredallparticipanttofillapre-questionnaire
form to gather some demographic data about them. Further,
weusedthedataregardingtheirexperience,programming
habits,andself-perceivedexpertiselevel,toassignpartici-
pants’expertisescores.Thescoreallowedustofairlybalance
theexpertiselevelsinbothexperimentalandcontrolgroups.
•Training. Atthisstep,theexperimentalgroupweregiven
a tutorial on Sabalan, which they were encountering forthe first time. Then both groups were given some time tofamiliarize themselves with the setting of the experiment.
We then started the tasks when the participants were ready.
•Tasks.Duringthisphase,theparticipantscompletedthefive
comprehensiontaskssummarizedinTable2.Basedonour
design,wewantedtomeasureboth durationandaccuracy
of completing the tasks. To measure time, we prepared each
taskonaseparatesheetofpaper.Westartedatimerwhenwe
handed atask sheetto aparticipant, and askedher toreturn
itto us(withthe answer)assoon asshehad completed the
task,whichiswhenwestoppedthetimer.Thisallowedus
torecordthetimetheyspentoneachtask.Weevaluatedthe
accuracyofeachtasklater,basedonrubricswehadprepared
prior to conducting the experiment.
Moreover, we wanted to gather some data regarding how
theparticipantsperceivedthetasks.Thus,weprovidedthem
withasetofmetatasks,thatquestionedthemabouttheper-
ceiveddifficulty,time-consumption,andrequiredexpertise
level for each task. Finally, the participants filled a post-
questionnaire form regarding their experience in the study.
7.2.3 Results. WefirstrantheShapiro-Wilktestonallcollected
datasets,todetermineiftheywerenormallydistributed.Fornor-
mally distributed data of accuracy we used two-sample t-tests. The
duration data did not pass the normality test and thus we used the
Mann-Whitney U test for it.
Fortheaccuracy,theresultsofrunningthetestsshowedasig-
nificant difference, with a high confidence, for the experimental
783
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. Inferring Hierarchical Motifs from Execution Traces ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
group using Sabalan (Mean=87.8%, STDDev=11.6%), compared
tothecontrolgroupusingChromeDevTools(Mean=50.5%,STD-
Dev=11.6%);( p−value=6.2e−05).Theaccuracyresultsareshown
inFigure8. Overall,usingSabalanincreaseddevelopers’accuracy
in performing comprehensiontasks by an average of54%, over other
tools.(RQ2.1). We further analyzed the impact of using Sabalan
in accuracy of individual tasks. The results of running the statis-
ticaltestsshowedsignificantdifferenceinfavourof Sabalanfor
all tasks, expect T3. The accuracy of results of T1A through T2B
weresignificantlyhigherusingSabalan.TheresultsfortaskT3,
although not statistically significant, were on average 23% more
accurate when participants used Sabalan.
For the times, the collected task completion duration data were
comparableforparticipantsofbothexperimentalandcontrolgroups.
Running thetests did notreveal any statisticallysignificant differ-
ence in task duration between the two groups (RQ2.2). Finally, we
analyzed the collected data from the questionnaire form partici-
pants filled regarding each task. They perceived the difficulty of
tasksfrom2.15to2.54,basedona5-pointLikertscale,whichshows
an average level of difficulty for all tasks. We compared the diffi-
cultyofeachtaskasperceivedbyparticipantswiththeresultsof
durationandaccuracyofthesametask.Wefoundnocorrelation
between the perceived difficulty ofa task by participants and how
they perform the task (using the Pearson correlation coefficient).
7.3 Discussion
The results of the experiment revealed that Sabalan improves de-
velopers’performanceincomprehensionbysignificantlyincreasing
their accuracy by 54% (RQ2.1). The results however did not show a
significant difference for duration (RQ2.2).
Domain Knowledge and Use-cases. One of the first steps to-
wardsprogramunderstandingisgeneralunderstandingofitsdo-
main and overall dynamic behaviour by identifying the compo-
nents that provide a solution to the domain. Our results show that
Sabalan significantly increases the accuracy of such tasks (T1).
This task consisted of two main parts, understanding the overall
behaviour and use-cases of the experimental object (T1.A), and
decidingontheirimportance(T2.B).UsingSabalansignificantly
improvedtheaccuracyofthesetwotasksby49%and78%,respec-
tively. The results show that using Sabalan not only provides a
more accurate overview of an application’s behaviour comparedto ad-hoc approaches, but also helps developers obtain a betterunderstanding of the importance and usage of the main system
components and their interactions (RQ2.3).
Feature Location. Feature location is one of the main tasks per-
formedduringprogramcomprehension,andhasmanyapplications,
suchasreuseandtesting.OurresultsshowthatusingSabalansig-nificantlyimprovedtheaccuracyoffeaturelocation(RQ2.1,RQ2.3).
The experimental group were able to find components involved in
the implementation of a feature and infer their relations 42% more
accuratelythanthecontrolgroup(T2.A).Theywerealso42%moreaccurateinestimatingthequalityoftheimplementationofthesaid
feature(T2.B).Investigatingtheanswersrevealedthatthecontrol
group missed many connections in the code that lead to discovery
of different parts of the implementation and thus failed to create
acompleteandaccuratemodeloftheinvolvedcode.Duetotheirincompleteunderstandingofthefeature,thecontrolgroupwasnot
abletoestimateandmeasurethe qualityoftherespectivepartof
application as well. The experimental group, however, could assess
thequalitybasedonthemoreaccuratemodelofthebehaviourthat
extracted the feature as a behavioural motif (RQ2.3).
SoftwareChangeandRoot-CauseDetection. Thelasttask(T3)
involvedunderstandingthesysteminordertomakeachange,by
findingtherootcauseofaparticularobservedbehaviour.Theexper-
imentalgroup wereableto performthetask 23%moreaccurately
withSabalan,althoughtheresultswerenotstatisticallysigifnifi-
cant (RQ2.1).Using Sabalan, theywereable to focuson a much
smallerpartofthecodethatwasrelevanttothefeaturethatneeded
change.However,becausewedonothavedebuggersupportwithin
Sabalan, using common debugging techniques such as setting
breakpoints and watching variables in such tasks required the par-
ticipants to frequently switch between the visualization and theapplication. We plan to integrate our prototype with a debugger
such as Chrome DevTools in the future.
Accuracy over Speed.The results did not show any significant
difference for task completion duration in favour of Sabalan. We
believe this is not a significant issue due to three reasons. First,
accuracy of performing a task is mor e important than its speed
[2]. The significant improvement of task completion accuracy with
Sabalan (54%), and the test’s high confidence in the result, em-phasize the challenges of comprehending traces, as well as the
usefulness of Sabalan in improvingdevelopers’performance for
completing said tasks. Investigating the answers further, we found
that many participants in the control group had finished the tasks,
assuming they had the right answers. While in fact, they were not
evenawarethattheyaremissingcrucialpartsoftheanswer,which
resulted in them having lower accuracy than Sabalan users. Next,
we believe that the unfamiliarity of our participants with Sabalan
mighthavecausedthemtospendmoretimetryingtouseit.This
theory is strengthened when we analyze individual tasks results.
Weobservedthattheexperimentalgrouphadtheworstspeedratio
compared to the control group for the first task (T1.A), after which
theyquicklyimproveandsurpassthecontrolgroupinlatertasks.
Finally, dividing the locus of attention may have also played a role
intheresults.Whilethecontrolgrouponlyfocusedonthebrowser,theSabalangrouphadtoswitchbackandforthbetweentheappli-
cation and the tool. We believe this can be solved by extending the
tool or integrating it into an existing programming environment.
Participants’ Perception of Tasks vs. Performance Reality.
Therewerenocorrelationsbetweenthedifficultyofataskasper-
ceived by participants, and their measured performance scores. All
participants deemed all tasks to be of moderate difficulty. However,
the control group scored significantly lower accuracy marks for all
tasks.Thisshowsthattheirinterpretationofthetaskrequirements
didnot matchthe realityof thetaskthey hadjust performed.The
results confirm the challenging nature of trace comprehension.
Performance Overhead. We used the experimental object of our
userstudy,Phormer,toobtaindataregardingtheadditionalover-
head of our approach, in 10 one-minute interaction sessions. We
measured three sources of potential performance overhead into ac-
count. The overhead caused by instrumentation phase, the imposed
overhead on execution of instrumented code and data collection,
784
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden S. Alimadadi et al.
and the overhead of analysisof traces and motif extraction, which
were respectively measured as 1.2, 0.1, and 2.1 seconds on average.
Thisisnegligibleforallpracticalpurposes,andisbarelynoticeable
during the interaction with the application. Thus, the performance
overhead of Sabalan was entirely acceptable for this application.
7.4 Threats to Validity
Theexternal threats ofconducting anexperiment suchas ours,
typicallyarisefromrepresentativenessoftasks,participants,and
object selected for the experiment. We mitigated the threat of task
selectionbydesigningourtaskssothattheycoveredallcommon
comprehensionactivitiesinPacioneet.al.[ 63],whicharerepresen-
tativeofroutinecomprehensiontasks.Avalidconcernisregarding
the representativeness of the participants of the developer popula-
tion, since we recruited students. We tried to address this concern
byrecruitingonlygraduatestudentswhohadpriorexperiencewith
JavaScript, many of whom had experience working in industry. To
address the threat of representativeness of the experimental object,
we chose an open source JavaScript application Phormer, [ 66] with
about 6,000 lines of code and over 43,000 downloads at the time
of conducting the study. An internal threat that concerns our
method is the bias towards assigning participants into control and
experimentalgroups,orthepopulation-selectionproblem,which
we addressed by balancing the expertise levels between the two
groups.Otherthreatscanariseduetothepossiblebiasoftheexam-iner(us)regardingthemeasurementofbothdurationandaccuracy
of task completion. We mitigated the time measurement threat by
designing a method for time measurement that both the partici-
pantandtheexamineragreedupon,namelyphysicallyexchanging
thetasksheetbetweentheparticipantandtheexaminer.Wemit-
igated the bias towards measuring accuracy by creating a rubric
prior to conducting the experiments, and abiding by the rubric for
markingthetasksinordertoaddressthisthreat.Thefinalthreat
we address is the tool used in the experiment. We chose Google
Chrome’s Developer Tools, which is very popular for client-side
webdevelopment, andall our participantswere previously familiar
with it (based on the pre-questionaire they filled out).
8 RELATED WORK
TraceAnalysisandVisualization. Severalpapersassistprogram
comprehension through dynamic analysis and visualization. Their
proposed techniques allow users to explore large traces [ 69], or
performreduction,compactionandpruningtechniquesontraces
[12,32–34,68]. A popular trend is using standard visual protocols,
suchasUMLdiagrams[ 13,22,76].Othersproposemorecustomized
visualization techniques through synchronized views [ 17], provide
program’s landscape focusing on communications [ 29], allow user
interactions with the visualization [ 65], visualize similarities in
traces [18], or present many other techniques for representing the
traces[10,21,28,39–41,48,69,72,77].Extravis[ 17]isthefirstsuch
technique that was quantitatively measured in a user study [ 19],
followedbyothers[ 11,61].Anothergroupofmethodscaptureand
analyzelow-levelinformationintracesusingtechniquessuchas
extracting behavioural units described in usecase scenarios [ 78],
profiling [ 43], dividing the trace into segments [ 67], identifying
feature-level phases by defining an optimization problem [ 7], orsimilar methods [ 15,23,64]. Heuzeroth et al. [ 35,36] propose to
find patterns in execution. Others aim at providing higher-level
representationsoftrace[ 2,3,80].However,unlikeourapproach,
these approaches do not infer a hierarchical behavioural model,
whichrevealsthekeypointsofbehaviour,whilestillpreservingthe
details, and permitting users to navigate them on demand. Further,
ourapproachinfersabstractmotifs,whichreducesthedependency
of our analysis on details, without losing the data.
FeatureLocation,Capture&Replay. Manypapershavefocused
on featurelocation [ 55,57,81]. Recordand replaytools aidunder-
standing and debugging [ 6,14,28,56,58,59,79] by providing a
deterministic replay of UI events without capturing their conse-
quences. Tracing techniques [ 5,37,62] collect traces of JavaScript
selectively.Somepapersfocusonvisualizationforhelpingprogram
understanding [ 5,62,81]. However,these methodsare committed
to preserving the exact sequence of events and replaying them.
Their analyses do not permit abstraction of implementation details
and inferring higher-level motifs. They are not concerned with cre-
atingabehaviouralmodelandprovidingahierarchicaloverview
of execution for assisting comprehension, unlike our work.
Specification Mining. Assistingcomprehensionbyminingsoft-
ware specifications from traces has been well explored [ 11]. Many
methodshaveassessed[ 49]orimprovedtheperformanceofminers,
by pruning and clustering traces [ 50], supporting equivalent states
[53,73],orfindinginconsistenciesinresourceutilizations[ 61].Oth-
erscomparedifferentmodelinferencetechniques[ 44],synergize
orcombinethem[ 47,52,54],orfacilitatedeclarationofalgorithms
[8,9]. Other work uses Markov models and analyzes them using
model checking [ 30]. Unlike our approach, these techniques do
not provide a hierarchical model of abstract recurring motifs of
programexecution.Specificationmininghasbeenimprovedwith
novel use of object hierarchies [ 51]. However, this technique only
supportsexistinghierarchiesbetweenJavaclassesandpackages,
and not application-specific motifs, which are not defined or speci-
fiedpriortoanalysis.Unliketheseapproaches,ouralgorithmallows
our analysis to abstract out the low-level details and tolerate small
changes, which allows recurring motifs of behaviour to emerge.
9 CONCLUDING REMARKS
In this paper, we proposed a generic technique for inferring a hier-
archical model of application-specific motifs from execution traces.
Our motifs, inspired by bioinformatics algorithms, are recurring
abstract patterns of execution that abstract out alterations and are
closertothehigher-levelfeaturesofasystem.Wedesignedavisual-
izationforourtechniquethatallowsuserstoobserveandquerythe
motifs for program understanding. Our technique is implemented
in a tool called Sabalan, which is publicly available. The results
of ouruser experiment showedthat usingthe systematic analysis
of Sabalanenabledparticipantstoperformcomprehensiontasks
54% more accurately than other state of art tools.
10 ACKNOWLEDGEMENTS
This work was supported in part by the Natural Sciences and Engi-
neeringResearchCouncil(NSERC)andaresearchgiftfromIntel
Corporation. We are grateful to all of the participants in our exper-
iment.
785
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. Inferring Hierarchical Motifs from Execution Traces ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
REFERENCES
[1]Saba Alimadadi, Ali Mesbah, and Karthik Pattabiraman. 2015. Hybrid DOM-
SensitiveChange ImpactAnalysisfor JavaScript.In Proceedingsof theEuropean
Conference on Object-Oriented Programming (ECOOP). LIPIcs, 321–345.
[2]Saba Alimadadi, Ali Mesbah, and Karthik Pattabiraman. 2016. Understand-
ing Asynchronous Interactions in Full-Stack JavaScript. In Proceedings of the
ACM/IEEE International Conference on Software Engineering (ICSE). ACM, 1169–
1180.
[3]Saba Alimadadi, Sheldon Sequeira, Ali Mesbah, and Karthik Pattabiraman. 2016.
Understanding JavaScript Event-Based Interactions with Clematis. ACM Trans-
actions on Software Engineering and Methodology (TOSEM) (2016), 17 pages.
http://salt.ece.ubc.ca/publications/docs/tosem16.pdf
[4]StephenF.Altschul,WarrenGish,WebbMiller,EugeneW.Myers,andDavidJ.
Lipman. 1990. Basic local alignment search tool. Journal of Molecular Biology
215, 3 (1990), 403 – 410.
[5]DomenicoAmalfitano,AnnaRitaFasolino,ArmandoPolcaro,andPorfirioTra-
montana.2014. TheDynaRIAtoolforthecomprehensionofAjaxwebapplica-
tions by dynamic analysis. Innovations in Systems and Software Engineering 10, 1
(2014), 41–57.
[6]Silviu Andrica and George Candea. 2011. WaRR: A tool for high-fidelity web
applicationrecordandreplay.In ProceedingsoftheInternationalConferenceon
Dependable Systems & Networks (DSN). IEEE Computer Society, 403–410.
[7]OmarBenomar,HouariSahraoui,andPierrePoulin.2014. Detectingprogram
executionphasesusingheuristicsearch.In InternationalSymposiumonSearch
Based Software Engineering. Springer, 16–30.
[8]IvanBeschastnikh,YuriyBrun,JennyAbrahamson,MichaelD.Ernst,andArvind
Krishnamurthy.2013. UnifyingFSM-inferencealgorithmsthroughdeclarative
specification.In SoftwareEngineering(ICSE),201335thInternationalConference
on. IEEE, 252–261.
[9]IvanBeschastnikh,YuriyBrun,JennyAbrahamson,MichaelD.Ernst,andArvind
Krishnamurthy. 2015. Using declarative specification to improve the under-
standing, extensibility, and comparison of model-inference algorithms. IEEE
Transactions on Software Engineering 41, 4 (2015), 408–428.
[10]Ivan Beschastnikh, Yuriy Brun, Michael D. Ernst, and Arvind Krishnamurthy.
2014. Inferring Models of Concurrent Systems from Logs of Their Behavior withCSight.In Proceedingsofthe36thInternationalConferenceonSoftwareEngineering
(ICSE 2014). ACM, 468–479.
[11]Ivan Beschastnikh, Yuriy Brun, Sigurd Schneider, Michael Sloan, and Michael D.
Ernst.2011. Leveragingexistinginstrumentationtoautomaticallyinferinvariant-
constrained models. In Proceedings of the 19th ACM SIGSOFT symposium and the
13th European conference on Foundations of software engineering. ACM, 267–277.
[12]Johannes Bohnet, Martin Koeleman, and Jürgen Döllner. 2009. Visualizing mas-
sivelyprunedexecutiontracestofacilitatetraceexploration.In IEEEInternational
WorkshoponVisualizingSoftwareforUnderstandingandAnalysis(VISSOFT).IEEE,
57–64.
[13]Lionel C Briand, Yvan Labiche, and Johanne Leduc. 2006. Toward the reverse
engineering of UML sequence diagrams for distributed Java software. IEEE
Transactions on Software Engineering 32, 9 (2006), 642–663.
[14]Brian Burg, Richard Bailey, Andrew J Ko, and Michael D. Ernst. 2013. Interactive
Record/Replay for Web Application Debugging. In Proceedings of the Symposium
on User Interface Software and Technology (UIST). ACM, 473–484.
[15]Jonathan E Cook and Zhidian Du. 2005. Discovering thread interactions in a
concurrent system. Journal of Systems and Software 77, 3 (2005), 285–297.
[16]ThomasA.Corbi.1989. Programunderstanding:Challengeforthe1990s. IBM
Systems Journal 28, 2 (1989), 294–306.
[17]Bas Cornelissen, Danny Holten, Andy Zaidman, Leon Moonen, Jarke J Van Wijk,
and Arie Van Deursen. 2007. Understanding execution traces using massive
sequence and circular bundle views. In IEEE International Conference on Program
Comprehension (ICPC). IEEE, 49–58.
[18]BasCornelissenandLeonMoonen.2007. Visualizingsimilaritiesinexecution
traces. In Proceedings of the 3rd Workshop on Program Comprehension through
Dynamic Analysis (PCODA). 6–10.
[19]BasCornelissen,AndyZaidman,andArievanDeursen.2011. Acontrolledexper-
imentforprogramcomprehensionthroughtracevisualization. IEEETransactions
on Software Engineering 37, 3 (2011), 341–355.
[20]BasCornelissen,AndyZaidman,ArievanDeursen,LeonMoonen,andRainer
Koschke.2009. Asystematicsurveyofprogramcomprehensionthroughdynamic
analysis. IEEE Transactions on Software Engineering 35, 5 (2009), 684–702.
[21]Wim De Pauw and Steve Heisig. 2010. Zinsight: A visual and analytic envi-
ronmentforexploringlargeeventtraces.In Proceedingsofthe5thinternational
symposium on Software visualization. ACM, 143–152.
[22]WimDePauw,ErikJensen,NickMitchell,GarySevitsky,JohnVlissides,andJeaha
Yang.2002. VisualizingtheExecutionofJavaPrograms. In SoftwareVisualization:
International Seminar, Stephan Diehl (Ed.). Springer Berlin Heidelberg, 151–162.
[23]Marcus Denker, Jorge Ressia, Orla Greevy, and Oscar Nierstrasz. 2010. Modeling
features at runtime. In International Conference on Model Driven Engineering
Languages and Systems. Springer, 138–152.[24]Patrik D’haeseleer. 2006. What are DNA sequence motifs? Nature biotechnology
24, 4 (2006), 423–425.
[25] escodegen 2017. Escodegen. https://github.com/estools/escodegen. (2017).[26] esprima 2017. Esprima. http://esprima.org/. (2017).[27] estraverse 2017. Estraverse. https://github.com/estools/estraverse. (2017).[28]
AsgerFeldthaus,MaxSchäfer,ManuSridharan,JulianDolby,andFrankTip.2013.
EfficientConstructionofApproximateCallGraphsforJavaScriptIDEServices.
InProceedingsofInternationalConferenceonSoftwareEngineering(ICSE).IEEE,
752–761.
[29]Florian Fittkau, Jan Waller, Christian Wulf, and Wilhelm Hasselbring. 2013. Live
trace visualization for comprehending large software landscapes: The ExplorViz
approach. In IEEE Working Conference on Software Visualization (VISSOFT). IEEE,
1–4.
[30]Carlo Ghezzi, Mauro Pezzè, Michele Sama, and Giordano Tamburrelli. 2014.
Mining behavior models from user-intensive web applications. In Proceedings of
the 36th International Conference on Software Engineering. ACM, 277–287.
[31]MartinGollery.2005. Bioinformatics:SequenceandGenomeAnalysis,2nded.
Clinical Chemistry 51, 11 (2005), 2219–2219.
[32]Abdelwahab Hamou-Lhadj and Timothy Lethbridge. 2006. Summarizing the
content of large traces to facilitate the understanding of the behaviour of asoftware system. In IEEE International Conference on Program Comprehension
(ICPC). IEEE, 181–190.
[33]AbdelwahabHamou-LhadjandTimothyCLethbridge.2004. Asurveyoftrace
explorationtoolsandtechniques.In ProceedingsoftheconferenceoftheCentre
for Advanced Studies on Collaborative research. IBM Press, 42–55.
[34]Abdelwahab Hamou-Lhadj, Timothy C Lethbridge, and Lianjiang Fu. 2004. Chal-
lenges and requirements for an effective trace exploration tool. In Proceedings of
the IEEE International Workshop on Program Comprehension. IEEE, 70–78.
[35]DirkHeuzeroth,ThomasHoll,GustavHogstrom,andWelfLowe.2003.Automatic
designpatterndetection.In ProgramComprehension,2003.11thIEEEInternational
Workshop on. IEEE, 94–103.
[36]DirkHeuzeroth,ThomasHoll,andWelfLöwe.2001. Combiningstaticanddy-
namicanalysestodetectinteractionpatterns.Univ.,Fak.fürInformatik,Bibliothek.
[37]Joshua Hibschman and Haoqi Zhang. 2015. Unravel: Rapid Web Application
Reverse Engineering via Interaction Recording, Source Tracing, and Library De-
tection.In ProceedingsofACMUserInterfaceSoftwareandTechnologySymposium
(UIST). ACM, 270–279.
[38] hoxy 2017. Hoxy Proxy. greim.github.io/hoxy/. (2017).[39]
KatherineE.Isaacs,AlfredoGiménez,IlirJusufi,ToddGamblin,AbhinavBhatele,
MartinSchulz,BerndHamann,andPeer-TimoBremer.2014. Stateoftheartof
performance visualization. EuroVis(2014).
[40]S Jayaraman, B Jayaraman, and D Lessa. 2016. Compact visualization of Java
program execution. Software: Practice and Experience (2016).
[41]BenjaminKarran,JonasTrumper,andJurgenDollner.2013. Synctrace:Visual
thread-interplay analysis. In IEEE Working Conference on Software Visualization
(VISSOFT). IEEE, 1–10.
[42]A. J. Ko, B. A. Myers, M. J. Coblenz, and H. H. Aung. 2006. An Exploratory
Study of How Developers Seek, Relate, and Collect Relevant Information during
SoftwareMaintenanceTasks. IEEETransactionsonSoftwareEngineering 32,12
(2006), 971–987.
[43]Johannes Koskinen, Markus Kettunen, and Tarja Systa. 2006. Profile-based
approach to support comprehension of software behavior. In IEEE International
Conference on Program Comprehension (ICPC). IEEE, 212–224.
[44]Ivo Krka, Yuriy Brun, and Nenad Medvidovic. 2014. Automatic mining of specifi-
cations from invocation traces and method invariants. In Proceedings of the 22nd
ACM SIGSOFT International Symposium on Foundations of Software Engineering.
ACM, 178–189.
[45]Alyson La. 2015. Language Trends on GitHub. https://github.com/blog/
2047-language-trends-on-github. (2015).
[46]Thomas D. LaToza, Gina Venolia, and Robert DeLine. 2006. Maintaining Mental
Models:AStudyofDeveloperWorkHabits.In Proceedingsofthe28thInternational
Conference on Software Engineering (ICSE). ACM, 492–501.
[47]Tien-Duy B Le, Xuan-Bach D Le, David Lo, and Ivan Beschastnikh. 2015. Syner-
gizingspecificationminersthroughmodelfissionsandfusions(t).In International
Conference on Automated Software Engineering (ASE). IEEE, 115–125.
[48]Shen Lin, François Taïani, Thomas C Ormerod, and Linden J Ball. 2010. Towards
anomaly comprehension: using structural compression to navigate profiling call-
trees. InProceedings of the 5th international symposium on Software visualization.
ACM, 103–112.
[49]David Lo and Siau-Cheng Khoo. 2006. QUARK: Empirical assessment of
automaton-based specification miners. In Working Conference on Reverse En-
gineering (WCRE). IEEE, 51–60.
[50]DavidLoandSiau-ChengKhoo.2006. SMArTIC:towardsbuildinganaccurate,
robust and scalable specification miner. In Proceedings of the 14th ACM SIGSOFT
international symposium on Foundations of software engineering. ACM, 265–275.
[51] David Lo and Shahar Maoz. 2009. Mining hierarchical scenario-based specifica-
tions.InInternationalConferenceonAutomatedSoftwareEngineering(ASE).IEEE,
359–370.
786
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden S. Alimadadi et al.
[52]David Lo and Shahar Maoz. 2012. Scenario-based and value-based specification
mining: better together. Automated Software Engineering 19, 4 (2012), 423–458.
[53]David Lo, Leonardo Mariani, and Mauro Pezzè. 2009. Automatic steering of
behavioral model inference. In Proceedings of the the 7th joint meeting of the
EuropeansoftwareengineeringconferenceandtheACMSIGSOFTsymposiumon
The foundations of software engineering. ACM, 345–354.
[54] David Lo, Leonardo Mariani, and Mauro Santoro. 2012. Learning extended FSA
fromsoftware:Anempiricalassessment. JournalofSystemsandSoftware 85,9
(2012), 2063–2076.
[55]James Lo, Eric Wohlstadter, and Ali Mesbah. 2013. Imagen: Runtime Migra-
tionofBrowserSessionsforJavaScriptWebApplications.In Proceedingsofthe
International World Wide Web Conference (WWW). ACM, 815–825.
[56]Magnus Madsen,Frank Tip, and OndřejLhoták. 2015. Static Analysis ofEvent-
Driven Node.js JavaScript Applications. In Proceedings of ACM SIGPLAN Con-
ferenceonObject-OrientedProgramming,Systems,Languages,andApplications
(OOPSLA). ACM, 505–519.
[57]JosipMaras,MajaStula,andJanCarlson.2013. GeneratingFeatureUsageScenar-
ios in Client-side Web Applications. In Proceeding of the International Conference
on Web Engineering (ICWE). Springer, 186–200.
[58]James Mickens, Jeremy Elson, and Jon Howell. 2010. Mugshot: Deterministic
Capture and Replay for Javascript Applications. In Proceedings of the 7th USENIX
Conference on Networked Systems Design and Implementation (NSDI’10). USENIX
Association, 159–174.
[59]Paula Montoto, Alberto Pan, Juan Raposo, Fernando Bellas, and Javier López.
2009. Automating navigation sequences in AJAX websites. In Proceedings of the
International Conference on Web Engineering (ICWE). Springer, 166–180.
[60]Gail C. Murphy, David Notkin, and Kevin Sullivan. 1995. Software Reflexion
Models:BridgingtheGapBetweenSourceandHigh-levelModels.In Proceedings
oftheACMSIGSOFTSymposiumonFoundationsofSoftwareEngineering(SIGSOFT).
ACM, 18–28.
[61]Tony Ohmann, Michael Herzberg, Sebastian Fiss, Armand Halbert, Marc Palyart,
Ivan Beschastnikh, and Yuriy Brun. 2014. Behavioral resource-aware model
inference. In Proceedings of the ACM/IEEE international conference on Automated
software engineering. ACM, 19–30.
[62]Stephen Oney and Brad Myers. 2009. FireCrystal: Understanding interactivebehaviors in dynamic web pages. In Proceedings of the Symposium on Visual
Languages and Human-Centric Computing. IEEE Computer Society, 105–108.
[63]Michael J Pacione, Marc Roper, and Murray Wood. 2004. A novel software
visualisation model to support software comprehension. In Proceedings of the
WorkingConferenceonReverseEngineering(WCRE).IEEEComputerSociety,IEEE,
70–79.
[64]VijayKrishnaPalepuandJamesA.Jones.2013. Visualizingconstituentbehav-
iors within executions. In IEEE Working Conference on Software Visualization
(VISSOFT). IEEE, 1–4.
[65]Michael Perscheid, Bastian Steinert, Robert Hirschfeld, Felix Geller, and Michael
Haupt.2010. Immediacythroughinteractivity:onlineanalysisofrun-timebe-
havior. In Working Conference on Reverse Engineering (WCRE). IEEE, 77–86.[66] Phormer 2017. Phormer PHP Photo Gallery. http://p.horm.org/er/. (2017).[67]
Heidar Pirzadeh and Abdelwahab Hamou-Lhadj. 2011. A novel approach based
ongestaltpsychologyforabstractingthecontentoflargeexecutiontracesfor
program comprehension. In IEEE International Conference on Engineering of
Complex Computer Systems (ICECCS). IEEE, 221–230.
[68]Steven P. Reiss and Manos Renieris. 2001. Encoding program executions. In pro-
ceedings of the International Conference on Software Engineering. IEEE Computer
Society, 221–230.
[69]ManosRenierisandStevenP.Reiss.1999. ALMOST:exploringprogramtraces.
InProceedingsofthe1999workshoponnewparadigmsininformationvisualization
andmanipulationinconjunctionwiththeeighthACMinternationconferenceon
Information and knowledge management. ACM, 70–77.
[70]M.P.Robillard,W.Coelho,andG.C.Murphy.2004. Howeffectivedevelopers
investigate source code: an exploratory study. IEEE Transactions on Software
Engineering 30, 12 (2004), 889–903.
[71] Sabalan 2017. Sabalan. https://github.com/saltlab/sabalan. (2017).
[72]RajaRSambasivan,IlariShafer,MichelleLMazurek,andGregoryRGanger.2013.
Visualizing request-flow comparison to aid performance diagnosis in distributed
systems. IEEEtransactionsonvisualizationandcomputergraphics 19,12(2013),
2466–2475.
[73]MatthiasSchur,AndreasRoth,andAndreasZeller.2013. Miningbehaviormodels
from enterprise web applications. In Proceedings of the Joint Meeting on Founda-
tions of Software Engineering. ACM, 422–432.
[74]T.F. Smith and M.S. Waterman. 1981. Identification of common molecular subse-
quences. Journal of Molecular Biology 147, 1 (1981), 195 – 197.
[75]Stack Overflow. 2017. Developer Survey. http://stackoverflow.com/research/
developer-survey-2017. (2017).
[76]Tarja Systä, Kai Koskimies, and Hausi Müller. 2001. Shimba–an environment for
reverse engineering Java software systems. Software: Practice and Experience 31,
4 (2001), 371–394.
[77]Jonas Trümper, Johannes Bohnet, and Jürgen Döllner. 2010. Understanding com-
plex multithreaded software systems by using trace visualization. In Proceedings
of the international symposium on Software visualization. ACM, 133–142.
[78]YuiWatanabe,TakashiIshio,andKatsuroInoue.2008. Feature-levelphasede-
tection for execution trace using object cache. In Proceedings of the international
workshop on dynamicanalysis: held in conjunction withthe ACM SIGSOFT Inter-
national Symposium on Software Testing and Analysis (ISSTA). ACM, 8–14.
[79]ShiyiWeiandBarbaraGRyder.2014. State-sensitivepoints-toanalysisforthe
dynamic behavior of JavaScriptobjects.In Proceedings of European Conference on
Object-Oriented Programming (ECOOP). Springer, 1–26.
[80]AndyZaidmanandSergeDemeyer.2004. Managingtracedatavolumethroughaheuristicalclusteringprocessbasedoneventexecutionfrequency.In Proceedings
oftheEuropeanConferenceonSoftwareMaintenanceandReengineering(CSMR).
IEEE, 329–338.
[81]Andy Zaidman, Nick Matthijssen, Margaret-Anne Storey, and Arie van Deursen.
2013. Understanding Ajax applications by connecting client and server-side
execution traces. Empirical Software Engineering 18, 2 (2013), 181–218.
787
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. 