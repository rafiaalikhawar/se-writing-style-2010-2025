VFix: V alue-Flow-Guided Precise Program Repair
for Null Pointer Dereferences
Xuezheng Xu∗, Y ulei Sui†, Hua Yan∗and Jingling Xue∗
∗School of Computer Science and Engineering, UNSW Sydney, Australia
{xuezhengxu, huayan, jingling}@cse.unsw.edu.au
†Faculty of Engineering and Information Technology, University of Technology Sydney, Australia
yulei.sui@uts.edu.au
Abstract —Automated Program Repair (APR) faces a key chal-
lenge in efﬁciently generating correct patches from a potentially
inﬁnite solution space. Existing approaches, which attempt toreason about the entire solution space, can be ineffective (byoften producing no plausible patches at all) and imprecise (byoften producing plausible but incorrect patches).
We present VF
IX, a new value-ﬂow-guided APR approach,
to ﬁx null pointer exception (NPE) bugs by considering asubstantially reduced solution space in order to greatly increasethe number of correct patches generated. By reasoning about thedata and control dependences in the program, VF
IXcan identify
bug-relevant repair statements more accurately and generatemore correct repairs than before. VF
IXoutperforms a set of 8
state-of-the-art APR tools in ﬁxing the NPE bugs in Defects4j
in terms of both precision (by correctly ﬁxing 3 times as manybugs as the most precise one and 50% more than all the bugscorrectly ﬁxed by these 8 tools altogether) and efﬁciency (byproducing a correct patch in minutes instead of hours).
Keywords-program repair, static analysis, null dereference
I. I NTRODUCTION
To reduce the maintenance cost of large-scale software, Au-
tomated Program Repair (APR) provides a promising solution
for automatically generating software patches to ﬁx software
bugs. Existing APR approaches proceed in two phases: (1)fault localization, which identiﬁes a set of suspicious, i.e.,repair statements, L, that may trigger a bug after exercising
at least one failing test case in a test suite, and (2) patch
generation, which generates a repair operation o∈Oby
applying a predeﬁned repair template (e.g., insertion anddeletion) on a suspicious statement /lscript∈Land then validates
the candidate patch by running the repaired program againstthe test suite. This generate-and-validate process repeats untilaplausible patch, i.e., one that passes all the test cases in
the test suite is found. A plausible patch is only correct iff it
results in the correct outputs for all possible program inputs.
Challenges. APR faces a key challenge in efﬁciently gener-
ating correct patches from a potentially inﬁnite solution space.Given a set of predeﬁned repair templates, existing search-based approaches usually generate an unbounded number ofrepair operations O(e.g., via brute-force mutations [38, 54,
78]) even for a single suspicious statement /lscript∈L. The
underlying search-space-explosion problem is further exacer-bated when all repair templates are instantiated over all thesuspicious statements in a program. The resulting solution1
2
3
4
5
67
8
9
10
1112boolean removeDomainMarker(…){
…
if(layer ==Layer.FOREGROUND){
markers =this.…Markers.get(…);
}else {
markers =this.…Markers.get(…); 
}
removed =markers.remove(…);
if(removed &&notify)
fireChangeEvent();
return removed;
}+if(markers==null) returnfalse;+if(markers==null) returnfalse;
+if(markers!=null)
NPE!
Correct Patch
Implausible PatchPlausible-but-incorrect PatchExecuted Statement
Unexecuted Statement
Crash Point
Fig. 1: An example with three patches, correct, plausible but
incorrect, and incorrect, for ﬁxing the NPE at l8.
spaceS=L×O=C∪I∪Xmay contain possibly inﬁnitely
many patches, where the ratio of the correct patches ∈C
over the incorrect patches (including implausible ones ∈Iand
plausible but incorrect ones ∈X) is extremely small. This can
seriously impede the efﬁciency and effectiveness of existing
APR approaches in ﬁnding correct patches.
Prior Work. To address this problem, existing efforts typ-
ically accelerate the repair process by ranking patches basedon their probabilities of being correct, i.e., exercising only thehigh-priority patches that are likely to be correct. Given a user-speciﬁed time budget, the solution space L×Ois thus reduced
to a subset L
/prime×O/prime, whereL/primeis often selected through a
fault localization tool via stress testing with a limited numberof test cases [4, 68, 88] and O
/primeis selected by adopting a
variety of heuristics, such as syntactic [24, 84] or semanticcode search [32], statistical analysis [31, 37, 81, 85], symbolicexecution [49, 53] and machine learning [44, 58].
Limitations. Without considering the data and control de-
pendences in a program, these patch-ranking approaches thatoperate on the entire solution space are still inadequate, as theycan be ineffective (by often producing no plausible patches atall) and imprecise (by often producing plausible but incorrectpatches). In addition, increasing the time budget used for ﬁxinga bug may increase the chances for obtaining a correct patch,but without any correctness guarantee in the presence of ahuge solution space [86]. As a result, the per-bug time budget
5122019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)
1558-1225/19/$31.00 ©2019 IEEE
DOI 10.1109/ICSE.2019.00063
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:36:43 UTC from IEEE Xplore.  Restrictions apply. is often set up a s3–5 hours [38, 54, 78, 81, 87] for heavy
testing.
Most APR approaches [24, 31, 32, 37, 81, 84, 85] adopt
a generic process to repair bugs without distinguishing their
types or categories. Thus, many repair operations that are
unable to repair a particular type of bugs are often generated,
but to no avail. For example, existing APR tools are ineffective
in ﬁxing Null Pointer Dereference (aka NullPointerException
(NPE)), one of the most common types of Java bugs [17],
representing 37.2% of all memory bugs in Mozilla and Apache
and over 40% of exceptions in Android [33, 41, 72]. However,
an APR approach is expected to increase both precision and
efﬁciency by being aware of the bug types, e.g., NPE, repaired
during its fault localization and patch generation.
NPE, as a representative bug type, is very difﬁcult to ﬁx
since choosing a right repair statement with a correct repair
operation is challenging. For the 15 NPEs in Defects4j
(a well-known benchmark suite often used for validating
APR [30]), existing tools, HDRepair [37], ACS [86], Cap-
Gen [81] and SimFix [28], can only correctly repair 1, 2, 2
and 4 NPEs, respectively, after having tried tens of thousands
of incorrect patches in hours per bug. This is because an NPE
and its bug-ﬁxing location can span across multiple functions
in large codebases [9], due to a wide variety of programming
mistakes, including missing null pointer checks [34, 58] and
object initialization [34], resulting in possibly inﬁnite many re-
pair operations at a large number of suspicious statements [43].
Insights .Static analysis is relatively unexplored for auto-
mated program repair. This paper aims to make one step for-
ward in investigating how to apply static value-ﬂow analysis,
which resolves both the data and control ﬂow of a program,
to help APR generate a precise solution space by increasing
the number of correct patches generated for repairing NPEs.
Figure 1 gives a real NPE from JFreeChart to demonstrate
how we can avoid a plausible but incorrect patch (due to an
imprecise L/prime) and an implausible patch (due to an imprecise
O/prime) if the data and control ﬂow information is considered.
When obtaining L/prime, the spectrum-based fault localization
tools [4, 83] usually record the execution traces for successful
and failed test cases and then contrast the two types of traces
by ranking the frequently executed statements that trigger
a bug [56]. Due to limited test cases, this coarse-grained
selection usually produces an imprecise L/primesince some l∈L/prime
may not represent a correct repair location [55]. In Figure 1,
markers may be null in both branches, /lscript4and/lscript6. However,
there is only one test case that triggers the bug at /lscript8, with
L/prime={/lscript2,/lscript3,/lscript4,/lscript8}containing the executed statements along
theifbranch but without the unexecuted ones, /lscript5−/lscript7(along
theelse branch) and /lscript9−/lscript12. All the statements in L/primeare
given the same priority to produce a ﬁx. However, applying
a ﬁx at any statement other than /lscript8will always generate an
incorrect patch, since the unexecuted /lscript6may also introduce an
NPE at/lscript8. For example, placing a ﬁx after /lscript4will generate a
plausible but incorrect patch as highlighted in yellow.
When obtaining O/prime, existing approaches [24, 31, 32, 37, 58,
81, 84, 85], which ignore data and control dependences, often
value-flow graph
Step 3-1
Step 3-2Step 2-2
Applying Value-Flow-Aware Repair Ops Selecting and Ranking Repair Locationsa buggy program & test cases
selected locations
candidate patches
Validation
succeedsfails
a correct patchValue-Flow Analysis
Patch GenerationCongestion CalculationDynamic Slicing
candidate statements
applicable operationsStep 1
Step 2
Step 3Step 2-1
ep 1VFix
Constructing a Value-Flow Graph
Fig. 2: The workﬂow of VF IX.
generate incorrect repair operations that either fail to pass a
test case or introduce new bugs. For example, a skip operation
is often applied, resulting in a null pointer check added
(highlighted in gray in Figure 1) to bypass the crash point at
/lscript8. However, removed , which is only initialized at /lscript8, is used
later at/lscript9. Thus, this /lscript8-bypassing skip operation will cause
an undeﬁned behavior at /lscript9, failing on some test cases. By
considering the static value-ﬂow information, we can generate
a correct ﬁx (same as the manual ﬁx in green) that never
accesses such an undeﬁned variable, by also avoiding hundreds
of attempts made by, e.g., dependence-unaware repair [48].
Our Solution .This paper introduces VF IX, a new value-
ﬂow-guided APR approach to ﬁxing NPEs by considering a
substantially reduced solution space in order to increase the
number of correct patches generated. VF IXenhances APR by
incorporating with data and control dependence information,
making it possible to identify bug-relevant repair statements
more accurately and generate more correct repairs than before.
VF IXis complementary to existing APR approaches, which
operate on an already reduced solution space S/prime=L/prime×
O/prime=C/prime∪I/prime∪X/prime,V F IXwill operate on a different one
Svf=Lvf×Ovf=Cvf∪Ivf∪Xvfto improve precision and
efﬁciency by including more correct patches and less incorrect
ones from the entire solution space S=L×O, such that
|Svf|/lessmuch|S/prime|,|Cvf|/greatermuch|C/prime|, and|Ivf∪Xvf|/lessmuch|I/prime∪X/prime|.
Figure 2 gives an overview of VF IX. A test suite for a given
NPE bug contains one failing test case (with several NPE-
triggering test cases for the same bug conceptually treated
as one). For the NPE-triggering test case given, VF IXﬁrst
constructs an inter-procedural value-ﬂow graph (VFG), a static
(value-ﬂow) slice of the program, to capture all the potential
NPE-triggering sources and other related NPE crash sites.
Then we formulate our fault localization problem by ﬁrst
identifying the set of suspicious statements, Lvf, as a portion
of the static slice dynamically executed by the NPE-triggering
test case, and then rank them by solving a graph congestion
calculation problem on the static slice [15, 16]. Given a repair
location, VF IXﬁnally produces a precise set of value-ﬂow-
aware repair operations ,Ovf, by ﬁltering out repair templates
or their sub-templates doomed to yield incorrect repair oper-
ations based on the dependence constraints established.
In summary, we make the following main contributions:
•We propose VF IX, a value-ﬂow-guided APR approach to
513
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:36:43 UTC from IEEE Xplore.  Restrictions apply. main(...){ 
Objectobj;
if(Cond1) 
obj= this .fs.get(...);
else
obj= this .bs.get(...); 
...
+if(obj!= null ){//our fix
Objectx=obj;
if(Cond2)
gtCC(x); 
if(Cond3)
gtCI(x);
+}
...
}
void gtCC(Object x){
x.bar(); 
}
void gtCI(Object x){
x.bar();
}1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20 Executed Statement
Unexecuted Statement
Crash PointENTRY main
if(Cond1) 
x=obj
if(Cond2) 
…
EXIT main1
3
Obj= this .bs.get(…) 6
8
9Obj= this .fs.get(…) 4
gtCC(x) x.bar1()16 10
if(Cond3)  11
gtCI(x) x.bar2()19 12
Executed Statement Unexecuted Statementreturn
callcall
return4 6
8
10
1612
19
Executed Value Flow
Unexecuted Value Flow
Sliced Value-Flow GraphPath 
Path 
Path 
Path 4 8 10 16
48 1 2 1 9
6 8 10 16
68 1 2 1 9
22 42222 Congestion
(d) Congestion calculation
8
10 124 6
Selected Repair Location
Skipped Statements
(a) A buggy program (b) Inter-procedural CFG (c) V alue-ﬂow graph (e) Repair operation
Fig. 3: A motivating example.
precisely and efﬁciently ﬁxing NPE bugs by considering
a substantially reduced solution space in order to increase
the number of correct patches made.
•We formulate our fault localization problem by ﬁrst
identifying the suspicious problems based on static value-
ﬂow analysis and dynamic execution and then rank them
by solving a graph congestion calculation problem.
•We have evaluated VF IXagainst a set of eight existing
APR tools in terms of their ability in ﬁxing the NPE bugs
inDefects4j .V F IXis more effective by correctly ﬁx-
ing 3x as many bugs as the most precise one, S IMFIX[28]
(12 bugs by VF IXvs. 4 bugs by S IMFIX), and 50%
more than all the bugs correctly ﬁxed by these eight tools
altogether. In addition, VF IXis also more efﬁcient by
producing a correct patch in minutes instead of hours, on
average. For 10 out of the 12 correctly ﬁxed bugs, VF IX
ﬁxes each bug by generating only one patch in a single-
pass validation. To further validate the effectiveness of
VF IX, we also evaluate VF IXusing another set of 15
NPEs in four open-source Apache projects. VF IXhas
successfully repaired 12 NPEs, with the ﬁxes that are
semantically equivalent to the developers’ ﬁxes.
II. A M OTIV A TING EXAMPLE
We use a program in Figure 3 to explain the three steps of
VF IX(Figure 2). In Figure 3(a), there is an NPE at /lscript16, where
xisnull , adapted from the real NPEs in JFreeChart . The
inter-procedural CFG in Figure 3(b) highlights the set of exe-
cuted statements (in gray), Ldyn={/lscript2,/lscript3,/lscript4,/lscript8,/lscript9,/lscript10,/lscript16},
by a test case that triggers the NPE, as obj = null after
/lscript4on retrieving a non-existent element from a map. VF IX
is able to generate exactly the same bug-ﬁxing patch as the
developer’s ﬁx (highlighted in /lscript7and/lscript13), as follows:
Step 1: Constructing a Value-Flow Graph. For the
crash site at /lscript16,V F IXbuilds an inter-procedural value-ﬂow
graph (VFG), which is essentially a static (value-ﬂow) slice,Gsta=(Lsta,E sta), shown in Figure 3(c), where Lsta=
{/lscript4,/lscript6,/lscript8,/lscript10,/lscript12,/lscript16,/lscript19}. The nodes (identiﬁed by line
numbers) in Lstarepresent variables and their edges capture
their def-use relations. Apart from /lscript4, the source for triggering
the NPE at /lscript16,Lstaalso includes another potential source /lscript6
for this NPE and a second potential crash point /lscript19.
Step 2: Selecting and Ranking Repair Locations. This
amounts to solving a fault localization problem. Given Ldyn
andLsta,V F IXcollects the suspicious statements on the
dynamic slice Lvf=Ldyn∩Lsta={/lscript4,/lscript8,/lscript10,/lscript16}, which is
a portion of the static slice executed by the bug-triggering test
case. VF IXthen ranks these statements by solving a value-ﬂow
congestion calculation problem on Gsta. The intuition behind is
to apply a repair operation to the most likely correct location
in order to avoid also some NPEs that are not triggered by
the given test suite, thus eliminating plausible but incorrect
patches. As illustrated in Figure 3(d), VF IXcalculates the
congestion value of each /lscript∈LvfonLstaby enumerating all the
paths from the sources in {/lscript4,/lscript6}to the sinks in {/lscript16,/lscript17}
on the VFG (Figure 3(c)). Thus, /lscript8, which has the highest
congestion value, is selected as the ﬁrst repair location.
Step 3: Applying Value-Flow-Aware Repair Operations.
VF IXgenerates the repair operations for a repair statement
based on the value-ﬂow information (to increase their success
rate). For /lscript8selected, VF IXconcludes that /lscript10and/lscript12are
dependent on /lscript8and thus adds a null pointer check that
encompasses /lscript8−/lscript12, as illustrated in Figure 3(e), delivering
a very ﬁrst patch that is identical to the manual ﬁx.
VF IXﬁxes the NPE bug in this example by selecting
precisely a repair location and a repair operation. Without our
value-ﬂow analysis, either /lscript4or/lscript16will likely be selected as a
repair location. Thus, another potential NPE-triggering source
/lscript6is ignored, producing a plausible but incorrect patch.
III. A PPROACH
We describe VF IX’s three steps for constructing static value-
ﬂow slices (Section III-A), selecting and ranking repair loca-
514
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:36:43 UTC from IEEE Xplore.  Restrictions apply. s∈STMT ::=p=q|p=q.f|p.f=q|p=newT|
p=null|return mp|p=q.m(− →r)r,p,q∈PTRf∈FIELD T∈CLASS
a,a/prime∈OBJm∈METHOD/lscript,/lscript/prime,/lscript/prime/prime∈LABEL
(a) A tiny Java-like language
Rule Statement /lscript Def-Use Information
NULL ASGN p=null /lscript∈Defp
NEWASGN p=newT/lscript ∈Defp
COPY p=q/lscript ∈Defp/lscript∈Useq
LOAD p=q.f /lscript ∈Defp/lscript∈Useq
a∈pts(q) /lscript∈Usea.f
STORE p.f=q/lscript ∈Useq/lscript∈Defa.f
a∈pts(p) /lscript∈Usep/lscript∈Usea.f
CALL p=q.m(− →r)/lscript∈Defp/lscript∈Useq
∀ri∈− →r:/lscript∈Useri
MTDENTRY m(− →r){} ∀ ri∈− →r:/lscript∈Defri
RET return mp/lscript ∈Usep[INTRA-POINTER]
/lscript∈DefpIntraDU (/lscript,/lscript/prime,p)/lscript/prime∈Usep
/lscriptp− →/lscript/prime
[INTRA-OBJECT]
/lscript∈Defa.fIntraDU (/lscript,/lscript/prime,a.f )/lscript/prime∈Usea.f
/lscripta.f− − →/lscript/prime
[INTER-POINTER] m/prime=dispatch (a,m )
/lscript:p=q.m(− →r)a∈pts(q)/lscript/prime:m/prime(− →r/prime)/lscript/prime/prime:retm/primep/prime
/lscriptq− →/lscript/prime∀ri∈− →r:/lscriptri− →/lscript/prime/lscript/prime/primep/prime
− →/lscript
[INTER-OBJECT]
/lscript∈Defa.fInterDU (/lscript,/lscript/prime,a.f )/lscript/prime∈Usea.f
/lscripta.f− − →/lscript/prime
(b) Intra-procedural def-use information statement-wise ( Def v(Use v) (c) V alue-ﬂow edges
denotes the set of deﬁnition (use) statements for a variable v)
Fig. 4: V alue-ﬂow graph construction.
tions based on static value-ﬂow slices (Section III-B), and de-
termining value-ﬂow-aware repair operations (Section III-C).
A. Constructing Static V alue-Flow Slices
Given a buggy program with one NPE crash site, VF IX
builds an inter-procedural value-ﬂow graph (VFG)Gsta=
(Lsta,E sta), a directed graph that captures all the potential
NPE-triggering sources and other related NPE crash sites,
whereLstais the set of nodes representing statements and Esta
is the set of edges representing their def-use relations.
Figure 4(a) gives a tiny Java-like language. Global variables
and static methods are handled in the standard manner.
Figure 4(b) lists the intra-procedural def-use information of
a variable or ﬁeld extracted directly from a statement. For
aN ULL ASGN ,N EWASGN or C OPY statement, its def-use
information is directly read off. For a L OAD or S TORE , the
def-use information for the objects indirectly accessed must
also be considered. Here, pts(v)denotes the points-to set of
vobtained from a demand-driven context-sensitive pointer
analysis [66]. At a S TORE , a weak update is assumed [69].
For a method call (C ALL ,M TDENTRY and R ET), the def-use
information for variables is directly available.
Figure 4(c) gives the rules for building the value-ﬂow
edges between two statements. To keep track of the intra-
procedural value-ﬂow for variables and ﬁelds, respectively,
[INTRA-POINTER] and [INTRA-OBJECT] ﬁnd the intra-
procedural deﬁnition sites /lscriptof a variable or ﬁeld from its use
site/lscript/primeviaIntraDU (Deﬁnition 1). [INTER-POINTER] and
[INTER-OBJECT] handle the inter-procedural value-ﬂow for
variables and ﬁelds, respectively. In [INTER-POINTER] , the
inter-procedural def-use relations for variables are obtained
directly via parameter/return passing. In [INTER-OBJECT]
(illustrated in Figure 5), the inter-procedural def-use relations
for ﬁelds are obtained via InterDU (Deﬁnition 2).bar(){
p.f =…;
zot();}zot(){
foo();
…}foo(){
…= q.f;
…}a.f
[INTER-OBJECT]1:
2:
3:ptsp= { a , a }
ptsq= { a }4:
5:6:
7:
Fig. 5: An inter-procedural value-ﬂow for ﬁeld a.f.
Deﬁnition 1 (Intra-Procedural Def-Use) .IntraDU (/lscript,/lscript/prime,v),
wherevis a variable or a ﬁeld, represents a def-use relation for
vfrom/lscriptto/lscript/primeon an intra-procedural control ﬂow path Pwith
no redeﬁnition of xin between, i.e., ∄/lscript/prime/prime∈P:/lscript/prime/prime∈Defv.
Deﬁnition 2 (Inter-Procedural Def-Use) .InterDU (/lscript,/lscript/prime,a.f )
represents a def-use relation for a.f from/lscriptto/lscript/prime(with both
in two distinct methods) on an inter-procedural control-ﬂow
pathP, which is discovered context-sensitively [66], with no
redeﬁnition of a.f in between, i.e., ∄/lscript/prime/prime∈P:/lscript/prime/prime∈Defa.f.
Example 1. Figure 5 shows a value-ﬂow for a.f across
bar() ,zot() andfoo() via the two callsites /lscript3and/lscript5.
Here,a.f is deﬁned at /lscript2:p.f=..inbar() and used at
/lscript7:..=q.f infoo() , wherep.f andq.f are aliases since
pts(p)∩pts(q)={a}, on the inter-procedural control-ﬂow
path/lscript2,/lscript3,/lscript4,/lscript5,/lscript6,/lscript7, with no redeﬁnition of a.f.
Letp.use ()be an NPE crash site, where pis null. We
obtain its static value-ﬂow slice Gsta=(Lsta,E sta)by solving
Gi+1=fvfg(Gi)iteratively, starting with G0={p}, until
a ﬁxed point is reached, where fvfgconsists of applying the
rules in Figure 4(c) to add ﬁrst all the (direct and indirect) defs
of the variables or ﬁelds in GitoGiand then all the (direct
and indirect) uses of the variables or ﬁelds in GitoGi.I ti s
understood that fvfgincludes the statement for a variable or
ﬁeld under consideration in Gi.
B. Selecting and Ranking Repair Locations
LetLdyn be the set of statements executed by the NPE-
triggering test case. To ﬁx this bug, it sufﬁces to consider only
515
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:36:43 UTC from IEEE Xplore.  Restrictions apply. Source Node
Sink Node
a
b
c
d
ef
g
h
ivfSource Sink VF -Path
a e a-b-c-d-e
a h a-b-c-h
a i a-b-c-d-i
f h f-g-c-h
f e f-g-c-d-e
f i f-g-c-d-i
(a)Gsta(Lvf={a,b,c,d,e }) (b) VF-Paths
Congestion Value 33642
Rank 43125
a b c d eCandidate Locations:
(c) Ranks
Fig. 6: An example for ranking repair locations.
the repair statements in the dynamic slice Lvf=Ldyn∩Lsta,
i.e., the portion of the static slice Lstadynamically executed.
VF IXthen ranks the repair statements in Lvfby solving
a congestion calculation (Deﬁnition 3) problem on Gsta. The
intuition behind is that a repair location with a higher con-
gestion value has a better chance to avoid also the other
related potential NPE bugs that are not discovered by the NPE-
triggering test case, thus reducing more effectively the number
of plausible but incorrect patches generated.
Deﬁnition 3. GivenGstafor a NPE bug, an /lscripts−/lscripttVF-path,
denoted VF-Path (/lscripts,/lscriptt), is a simple path (with no repeated
cycles), such that /lscriptsis a source and /lscripttis a sink in Gsta.
For a ﬁxed source-sink pair (/lscripts,/lscriptt), VF-Path-Set (/lscripts,/lscriptt)is
the set of all /lscripts−/lscripttVF-paths. The congestion value of a
node/lscriptin VF-Path-Set (/lscripts,/lscriptt)is given byN/lscripts,/lscriptt
/lscript
|VF-Path-Set (/lscripts,/lscriptt)|,
whereN/lscripts,/lscriptt
/lscriptis the number of /lscripts−/lscripttVF-paths that passes
through/lscript. The congestion value of a node /lscriptinGstais given
by/summationtext
/lscripts∈Src/summationtext
/lscriptt∈SnkN/lscripts,/lscriptt
/lscript
|VF-Path-Set (/lscripts,/lscriptt)|.
VF IXthen ranks the statements in Lvfin the non-increasing
order of their congestion values calculated for Gstabased on
the deﬁnition above. A reverse topological order in Gstais
used as a tie-breaker (with the statements in the same strongly
connected component (SCC) being ranked arbitrarily).
InGsta, a source node can be p=null or return null, a
potential source for causing a null dereference, and a sink node
can be a potential point for triggering a null dereference.
Example 2. Figure 6 illustrates how to select and rank repair
statements. For Gstagiven in Figure 6(a), we assume that Lvf=
{a,b,c,d,e }. Figure 6(b) displays its VF-Paths. Figure 6(c)
ranksa,b,c,d andebased on their congestion values.
Finally, Algorithm 1 is used to rank the candidate statements
inLvf. In actuality, it is only necessary to compute the
congestion value for a repair statement in Lvfin line 5.
C. Applying V alue-Flow-Aware Repair Operations
We ﬁrst discuss our NPE bug model and then introduce the
repair templates used for ﬁxing NPE bugs.Algorithm 1: Ranking Repair Locations
Input:Gsta=(Lsta,E sta)(a static slice)
Lvf(a set of repair statements)
Output: a linear ordering of the repair statements in Lvf
1Function RankingRepairLocations (Gsta,L vf)
2G/prime
sta=(L/prime
sta,E/prime
sta)←Gstawith all SCCs collapsed;
3 Let SRC/prime
stabe the set of source nodes in G/prime
sta;
4 Let SNK/prime
stabe the set of sink nodes in G/prime
sta;
5 foreach/lscript∈L/prime
stado
6 foreach/lscripts×/lscriptt∈SRC/prime
sta×SNK/prime
stado
7 N/lscripts,/lscriptt
/lscript←number of /lscripts−/lscripttVF-paths that
passes through /lscriptinG/prime
sta;
8 VF-Path-Set (/lscripts,/lscriptt)←set of/lscripts−/lscripttVF-paths
inG/prime
sta;
9 C/lscripts,/lscriptt
/lscript←N/lscripts,/lscriptt
/lscript
|VF-Path-Set (/lscripts,/lscriptt)|;
10 end
11 C/lscript←/summationtext
/lscripts∈SRC/prime
sta/summationtext
/lscriptt∈SNK/prime
staC/lscripts,/lscriptt
/lscript;
12 end
13Deﬁne a linear ordering of the statements in /lscript/prime∈L/prime
sta,
/greatermuchC, in increasing order of their congestion values, C/lscript,
by breaking ties with a reverse topological order;
14Replace each SCC {/lscript1,.../lscriptn}∈L/prime
stain/greatermuchCby
/lscript1,.../lscriptn, where/lscripti∈Lsta, in any arbitrary order;
15return/greatermuchCrestricted to the statements in Lvf;
1) NPE Bug Model: The majority of the NPE bugs that
happen at a crash site, v.use (), in real-world programs arise
in two scenarios: (1) vis not initialized on some path leading
tov.use (), and (2) a “null check” for v.use ()is missing (e.g.,
when retrieving an element that may not exist in a map as in
Figure 3). These two sources of NPEs are also acknowledged
elsewhere in developing repair templates [34, 86, 87].
In this paper, we focus on repairing these two kinds of
NPE bugs by assuming call-graph integrity (i.e., that API calls
are invoked correctly) and type integrity (i.e., that variables
are typed correctly in their declarations). In Section IV-F, we
discuss some NPE bugs caused due to such integrity violations.
2) Repair Operations: For the NPE bugs considered, we
summarize all candidate repair operations based on two repair
templates, i.e., initialization and skip , which are also used
by some existing APR tools [34, 86, 87]. The Initialization
template aims to initialize a null pointer by assigning a newly
created object while the skip template aims to avoid executing
an NPE-triggering statements and other related ones. In this
paper, we focus on how to use these two templates efﬁciently
and precisely under VF IX, our value-ﬂow analysis framework.
VF IX, as discussed in Section I, operates on the solution
spaceLvf×Ovf, whereLvfis the set of repair statements
identiﬁed in Section III-B and Ovfis the set of repair oper-
ations deﬁned in Figure 7. There are two sets of rules. The
set of rules in Figure 7(a) is responsible for extracting the
candidate variables or ﬁelds from a repair statement in /lscript∈Lvf
that may participate in a repair operation for /lscript. The set of
516
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:36:43 UTC from IEEE Xplore.  Restrictions apply. [V-ASSN-NULL]/lscript:p=null/lscript∈SRC vf
(/lscript,p,⊥)∈VF[V-ASSN]/lscript:p=q/lscript /∈SNK vf
(/lscript,p,q )∈VF[V-RET-NULL]/lscript:return null/lscript∈SRC vf
(/lscript,⊥,⊥)∈VF[V-RET]/lscript:returnp/lscript /∈SNK vf
(/lscript,⊥,p)∈VF
[V-LD-SNK]/lscript:p=q.f /lscript∈SNK vf
(/lscript,p,q )∈VF[V-ST-SNK]/lscript:p.f=q/lscript∈SNK vf
(/lscript,⊥,p)∈VF[V-CALL-SNK]/lscript:p=q.m(− →r)/lscript∈SNK vf
(/lscript,p,q )∈VF
[V-LD-INT]/lscript:p=q.f /lscript∈INT vf
(/lscript,p,q.f )∈VF[V-ST-INT]/lscript:p.f=q/lscript∈INT vf
(/lscript,p.f,q )∈VF[V-CALL-INT]/lscript:p=q.m(− →r)/lscript∈INT vf
(/lscript,p,q.m (− →r))∈VF
(a) Identifying the candidate variables or ﬁelds in a repair statement /lscript∈Lvffor repairing /lscript
[INIT-SIMP] [INIT-SRC]
(/lscript,x,y )∈VFy/negationslash=⊥c:y== null/lscript/prime:y=newT
/lscript⇒if(c){/lscript/prime};/lscript(/lscript,x,⊥)∈VF/lscript:=null=⇒/lscript/prime:x=newT/lscript :return null=⇒/lscript/prime:return new T
/lscript⇒/lscript/prime
[INIT-SNK] [SKIP-ONE] FSL(/lscript)={/lscript}
(/lscript,x,y )∈VF/lscript∈SNK vfx/negationslash=⊥∄/lscript/prime/prime∈Usey:/lscript/prime/primepDom /lscript c :y== null/lscript/prime:x=newT
/lscript⇒if(c){/lscript/prime}else{/lscript}(/lscript,x,y )∈VFy/negationslash=⊥/lscript/negationslash=return c:y!=null
/lscript⇒if(c){/lscript}
[SKIP-MULTI] FSL(/lscript)={/lscript,/lscript1,···,/lscriptn}n≥1 [SKIP-RET]
(/lscript,x,y )∈VFy/negationslash=⊥∄/lscript/prime∈FSL(/lscript):/lscript/prime=return c:y!=null
/lscript⇒if(c){/lscript,/lscript1,···,/lscriptn}(/lscript,x,y )∈VFy/negationslash=⊥c:y== null/lscript/prime:returnrr∈{newT,null,/epsilon1}
/lscript⇒if(c){/lscript/prime};/lscript
(b) Generating a repair operation for /lscript∈Lvf(/lscript⇒/lscript/primedenotes the code transformation from /lscriptto/lscript/primeandFSL (/lscript)is a forward slice of /lscript)
Fig. 7: Rules for applying value-ﬂow-aware repair operations.
rules in Figure 7(b) generates the repair operations in Ovfby
using six NPE-repairing templates, with three reﬁned from the
initialization template and the three from the skip template.
Let us ﬁrst consider the rules in Figure 7(a). As Lvfis a
portion of Gstarestricted to those dynamically executed by
the NPE-triggering test case, denoted Gvf, SRC vf, SNK vfand
INT vfrepresent the set of source, sink and intermediate nodes
inGvf, respectively. In particular, SNK vfis a singleton contain-
ing the NPE-triggering statement. For each repair statement
/lscript∈Lvf, we collect (/lscript,x,y )∈VF, wherexandyappear
in/lscript, to indicate that ymay be null on entry of /lscriptandx
may be null (or undeﬁned when /lscript∈SNK vf) on exit of /lscript.
[V-ASSN-NULL] ,[V-ASSN] ,[V-RET-NULL] , and [V-RET]
are self-explanatory, where /lscript∈SRCvfand/lscript/∈SNKvfare
redundant. For a load ( /lscript:p=q.f), store (/lscript:p.f=q), or
call (/lscript:p=q.m(− →r), there are two rules each, depending on
whether/lscriptis the actual NPE crash site or not.
Let us now examine the six NPE-ﬁxing templates given in
Figure 7(b) in greater detail. Due to the value-ﬂow information
collected (Figure 7(b)), we can now apply a template when
some value-ﬂow constraints are satisﬁed, thereby ﬁltering
out a particular incorrect template, and consequently, all the
incorrect repair operations instantiated from it.
a) Initialization: There are three templates,
[INIT-SIMP] ,[INIT-SRC] and [INIT-SNK] , which
serve to assign a new object to a potentially null pointer
(a variable or ﬁeld). Currently, when generating an object
initialization statement v= newT, the public default
constructor (if available) in class T, whereTis the declared
type ofvor a subtype, is used as in [20, 34]. In future work,
other non-default constructors can be considered similarly.
According to the premises of these templates, [INIT-SIMP]
applies to the statements handled by [V-ASSN] ,[V-RET] ,
[V-LD- *],[V-ST- *]and [V-CALL- *];[INIT-SRC]
applies to the statements handled by [V-ASSN-NULL] and
[V-RET-NULL] ; and [INIT-SNK] applies to the statementshandled by [V-LD-SNK] and[V-CALL-SNK] .
In[INIT-SIMP] ,a symay be null, we perform an initial-
ization for yguarded by a runtime null check for y.
In[INIT-SRC] , where a repair statement is =null or
return null, we simply add the missing initialization.
In[INIT-SNK] , where a repair statement /lscript(a load or a
call) suffers from a null dereference when y=null, causing
the result in xto be undeﬁned, we add an initialization of x
guarded again by a runtime null check for yand also skip /lscript.
However, we will only do so when ∄/lscript/prime/prime∈Usey:/lscript/prime/primepDom /lscript
holds, i.e., when ydoes not have any post-dominant use in
Useywith respect to /lscript. Otherwise, the repair operation for /lscript
will likely be incorrect even plausible. If xis of a primitive
typeT, thenT()returns the default value for Tas in C++.
b) Skip: There are also three templates, [SKIP-ONE] ,
[SKIP-MULTI] and[SKIP-RET] , which each insert a null
check at a repair location to skip the statements affected by the
null dereference. These three rules apply to all the statements
except for p=null and return null, which are handled
by[INIT-SRC] . In both [SKIP-ONE] and[SKIP-MULTI] ,
FSL(/lscript)represents the traditional forward slice computed at /lscript.
In[SKIP-ONE] ,a symay be null at a repair statement /lscript,
we skip/lscriptwith a null check y!=null (when FSL(/lscript)={/lscript}).
In[SKIP-MULTI] , we skip multiple statements that depend
on a repair statement /lscript(when FSL(/lscript)={/lscript,/lscript1,...,/lscript n} /negationslash=
{/lscript}). If/lscript,/lscript1,...,/lscript nare not consecutive, we choose to skip
the smallest code region encompassing these statements.
In[SKIP-RET] , we skip all the statements starting from /lscript
in the method mcontaining /lscript, by returning nothing ( /epsilon1)i fm’s
return type is void ,o r newTifTis primitive as discussed
for[INIT-SNK] , or one in {newT,null}ifTis a class.
In the case of multiple repair operations available at a
repair statement from both an initialization template and a skip
template, the skip template will be tried ﬁrst, reﬂecting how
such templates are used in real-world bug-ﬁxing scenarios.
517
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:36:43 UTC from IEEE Xplore.  Restrictions apply. TABLE I: NPEs in Defects4j
Project Description KLOC Bug IDs #NPEs
Chart Plotting Software 96 2, 4, 14, 15, 16, 25, 26 7
Lang Java Utility 22 20, 33, 39, 47, 57 5
Math Mathematics Lib 85 4, 70, 79 3
Time Calendar System 28 - 0
Total 231 15
Example 3. Let us revisit Figure 1 to select the re-
pair operations for the statement at /lscript8, the NPE-
triggering site. By [V-CALL-SNK] , we obtain (/lscript8,removed ,
markers )∈VF. The skip templates are considered ﬁrst. As
FSL(/lscript8)={/lscript8,/lscript9,/lscript10,/lscript11}contains/lscript11,areturn statement,
[SKIP-RET] applies, giving rise to the correct path shown
in Figure 1. Without our value-ﬂow analysis, [SKIP-ONE]
may be tried, resulting in the implausible patch also shown in
Figure 1. Thus, VF IXcan successfully avoid many incorrect
repair operations, thereby reducing the search space.
IV . E V ALUA TION
Our objective is to show that VF IXcan signiﬁcantly out-
perform the state of the art for repairing NPE bugs in terms of
both precision and efﬁciency (i.e., the time spent on generating
a correct patch). By comparing VF IXwith a set of eight
representative APR tools in ﬁxing all the 15 NPE bugs in
Defects4j (version 1.0.1), we ﬁnd that VF IXcan correctly
repair 3x as many NPEs as the most precise one, S IMFIX[28]
(12 bugs by VF IXvs. 4 bugs by S IMFIX) and 50% more
than all the NPEs correctly ﬁxed by all the eight APR tools
together. In addition, we have also validated the effectiveness
of VF IXusing another set of 15 NPEs in 4 open-source
Apache projects, VF IXhas successfully repaired 12 NPEs,
by generating the ﬁxes that are semantically equivalent to the
developers’ ﬁxes. VF IXrepairs 24 out of these 30 NPEs in
about 30 minutes, i.e., under 80 seconds per bug on average.
A. Implementation
We have implemented VF IXin SOOT [76] in about 11.5
KLOC of Java code, with our value-ﬂow analysis performed
in its Jimple IR. Given a program with a test suite consisting
of one NPE-triggering test case, VF IXrelies on SOOT’s built-
in CFGs and call graph to construct its static value-ﬂow slice
Lstaby using the rules in Figures 4(b) and (c). The points-to
information required is discovered by using a demand-driven
context-sensitive pointer analysis [66]. GZoltar [12] is used
to obtain an execution trace Ldynfor the program under the
NPE-triggering test case. Lvf=Lsta∩Ldynthen contains all
the repair statements localized. To generate patches, we use
JavaParser [3] to parse, analyze and transform the source code.
B. Experimental Setup
We use two sets of benchmarks. Table I lists the four out
of the ﬁve projects in Defects4j (version 1.0.1) [30], a
bug database widely used by the program repair community.
Note that Closure Compiler is excluded due to the lack
of a standard JUnit testing format. There are 15 NPE bugs,TABLE II: NPEs in Apache Projects
Project Description KLOC Bug IDs #NPEs
Pdfbox PDF Library 1282266, 2477, 2812
9 2948, 2951, 2965
2995, 3479, 3572
Felix OSGi Platform 25 4960, 5464 2
Collections Collection Handling 69 39, 360 2
Sling Web Framework 4 4982, 6487 2
Total 226 84 15
with 7 in Chart ,5i n Lang ,3i n Math a n d0i n Time .
We have selected this version since the experimental results
from many existing tools for it are available. Table II lists the
four large open-source Apache applications with also a total of
15 NPEs, Pdfbox (9),Felix (2),Collections (2) and
Sling (2). We have selected these 15 NPEs from their bug
repositories [2] since they have NPE-triggering test cases with
the correct patches accepted by developers. For each of these
30 NPEs, we use the test suite provided for the class where
the bug resides, which includes one NPE-triggering test case.
Our experiments were done on a machine with an Intel Core
i5 3.20 GHz CPU and 4GB memory, running Ubuntu 16.04
operating system with JDK 1.6.0 45 with the maximum heap
size of Java virtual machine set as 4 GB. Each program was
run ﬁve times and the average is reported in our evaluation.
C. Precision and Efﬁciency
Following [81, 86], we adopt a relatively strict deﬁnition
of correctness for a patch. A patch is correct iff it passes
all the test cases in the test suite and is also semantically or
syntactically equivalent to a human-written patch.
We compare VF IXwith eight representative APR tools,
seven general-purpose ones, JGENPROG [38, 48], JKALI [48,
55], N OPOL [48], ACS [86], C APGEN[81], HDR EPAIR [37]
and S IMFIX[28], and one specialized for NPEs, NPEF IX[22].
The results of the ﬁrst seven tools are taken from their papers.
The time budget per bug is 90 minutes for C APGEN and
HDR EPAIR , 180 minutes for JGENPROG ,JKALI and N OPOL ,
300 minutes for S IMFIX, and 30 minutes for ACS.
Figure 8 compares VF IXwith these APR tools in terms of
each tool’s capability in generating correct patches for the 15
NPE bugs in Defects4j .V F IXoutperforms these tools by
correctly repairing 12 out of the 15 NPE bugs.
1)VF IXvs. General-Purpose APR Tools: Among the seven
general-purpose APR tools, S IMFIXis the best in terms of
the number of correct patches generated, repairing 4 out of
the 15 NPEs, with one plausible but incorrect patch and
10 implausible patches produced. C APGEN and ACS each
ﬁx two NPEs. N OPOL and JKALI produce some plausible
patches, which are all incorrect. VF IXfails to generate correct
patches for three NPEs, as discussed further in Section IV-F. In
comparison with these general-purpose APR tools, VF IXhas
successfully repaired six out of the 15 NPE bugs exclusively.
2)VF IXvs.NPEF IX:NPEF IX, an APR tool developed to
repair NPE bugs, can generate 12 plausible patches but with
only two being correct. When ﬁxing a NPE bug, NPEF IX
considers only the NPE-triggering test case while ignoring the
518
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:36:43 UTC from IEEE Xplore.  Restrictions apply. Chart Lang Math
2 4 14 15 16 25 26 20 33 39 47 57 4 70 79
NPEFix
jGenProg
jKali
Nopol
ACS
CapGen
HDRepair
SimFix
VFix
Correct Plausible-but-incorrect Implausible
Fig. 8: Comparing the correctness of the patches generated
by VF IXand eight existing representative APR tools for
Defects4j . The numbers across are the bug IDs correspond-
ing to Column 4 in Table I. Only the applications containing
NPEs, i.e., Chart ,Lang andMath , are included here.
others in the test suite. This renders NPEF IXvulnerable to
over-ﬁtting with simple plausible yet incorrect patches such
as randomly replacing a null pointer with a non-null pointer.
Thus, the majority of its patches ( 10/12 = 83% ) are incorrect,
conﬁrmed by manual inspection, because they either introduce
new bugs or signiﬁcantly alter the program logic.
3)VF IXvs. Runtime Recovery Tools: Instead of providing
correct patches for bugs (including NPEs), some tools, such
as APPEND [20], RCV [45], and Ares [27], aim to prevent
crashes in order to continue program execution. These tools
seek a temporary recovery solution in a short time rather
than repeatedly generating and validating patches against a
test suite. To compare with APPEND [20], we have written
the patches for the 15 NPEs in Defects4j by following its
recovery policy (i.e., calling a default constructor or skipping
the null dereference if the default constructor is unavailable).
Only two bugs, Lang-20 andLang-47 , are ﬁxed correctly.
4)VF IX’s Patch Generation: Table III analyzes VF IX’s
efﬁciency and precision in repairing the 30 NPEs across the 8
projects, with a 10-minute time budget per bug. VF IXrepairs
a bug in three steps, Steps 1 – 3, as shown in Figure 2.
ForChart-2 ,Math-79 ,Pdfbox-2812 andMath-2951 ,
VF IXtimes out in Step 3 (marked as OOB). If these four
NPEs are included, VF IXtakes 4256 seconds (70.9 minutes) in
repairing the 30 NPEs, with 22.9%, 7.4% and 69.7% in Steps 1
– 3, respectively. Otherwise, VF IXtakes 1856 seconds (30.9
minutes) in repairing the 26 remaining NPEs, with 44.4%,
13.4% and 42.2% in Step s1–3 , respectively.
For the 30 NPE bugs, VF IXhas successfully generated
patches for 26 NPEs, in which 24 are correct and two are
incorrect, giving a precision of 92.3%. The high precision con-
ﬁrms the effectiveness of our value-ﬂow analysis. In addition,
VF IXis also efﬁcient as the ﬁrst patch is correct in 19 out
of 24 correct ﬁxes. This fast and precise patch generation is
attributed to the value-ﬂow-aware repair operations used. For
the four NPE bugs mentioned above, however, VF IXstill fails
to generate plausible patches within the time budget.TABLE III: Analyzing VF IX’s patch generation for repairing
the 30 NPEs across the 8 projects (with a 10-minute time
budget per bug). OOB denotes out-of-budget. A breakdown
of the times for its three steps (Figure 2) is given. A green
(red) box marks a correct (incorrect) patch, while a white box
marks a bug for which no plausible patch is generated.
Bug IDTime (secs) N-th patch
passing testCorrectnessStep 1 Step 2 Step 3 Total
Chart-2 37 16 OOB OOB ∞
Chart-4 45 14 34 93 1
Chart-14 41 14 32 87 1
Chart-15 48 13 46 107 1
Chart-16 1 381 0 3 1 1
Chart-25 41 13 37 91 1
Chart-26 4 334 9 9 5 1
Lang-20 1 431 3 3 0 2
Lang-33 1 541 7 3 6 1
Lang-39 1 431 6 3 3 1
Lang-47 1 331 6 3 2 3
Lang-57 1 231 2 2 7 1
Math-4 16 11 7 34 1
Math-70 13 8 9 30 2
Math-79 12 6 OOB OOB ∞
Felix-4960 2 371 9 4 9 1
Felix-5464 14 8 9 31 1
Collections-39 1 341 1 2 8 2
Collections-360 12 7 8 27 1
Pdfbox-2266 50 19 57 126 1
Pdfbox-2477 52 14 66 132 2
Pdfbox-2812 49 24 OOB OOB ∞
Pdfbox-2948 52 17 61 130 1
Pdfbox-2951 54 20 OOB OOB ∞
Pdfbox-2965 51 17 47 115 1
Pdfbox-2995 50 18 44 112 1
Pdfbox-3479 55 19 50 124 2
Pdfbox-3572 55 16 38 109 1
Sling-4982 1 211 6 2 9 1
Sling-6487 57 1 60 118 1
Total(with OOB)
(w/o OOB)976 314 2966 4256
824 248 784 1856
Fig. 9: The percentages of the number of repair statements
inLvffound by VF IXover the total number of suspicious
statements reported by the fault localization tool, GZoltar [12],
for the 12 NPEs in Defects4j ﬁxed by VF IX(with Chart ,
Lang andMath abbreviated to C,L, and M, respectively).
D.VF IX’s Reﬁned Solution Space
We provide some insights on why and how VF IXachieves
high precision and efﬁciency by reﬁning its solution space
Lvf×Ovfusing value-ﬂow analysis. We consider the 12 NPEs
inDefects4j that are ﬁxed by VF IX, as shown in Table III.
Figure 9 shows that VF IXhas achieved an average reduction
of 94.11% by moving away from the space of suspicious state-
ments selected by a general-purpose fault localization tool,
GZoltar [12], to Lvf. By leveraging the value-ﬂow information
for an NPE-triggering site, VF IXavoids many irrelevant repair
519
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:36:43 UTC from IEEE Xplore.  Restrictions apply. Fig. 10: The number of repair templates instantiated at each
bug-ﬁxing statement with and without value-ﬂow analysis for
the 12 NPEs in Defects4j ﬁxed by VF IX(with Chart ,
Lang andMath abbreviated to C,L, and M, respectively).
locations that would otherwise be selected by such bug-type-
unaware spectrum-based fault localization techniques.
Figure 10 shows how VF IXhas signiﬁcantly reduced the
number of repair operations in Ovfby comparing the number
of repair templates instantiated with and without our value-
ﬂow analysis at a statement where a correct ﬁx is made. In the
absence of value-ﬂow information, all six templates (given in
Figure 7) are used. By exploiting the value-ﬂow information,
VF IXhas cut this down to 2.58, resulting in a reduction of
57.0%, on average, avoiding unnecessary repair operations
tried and boosting the efﬁciency of patch generation.
E. Case Studies
We conduct two cases studies in Defects4j to show how
VF IXrepairs intra- and inter-procedural NPEs precisely and
efﬁciently within a reduced solution space Svf=Lvf×Ovf.
Figure 11(a) shows an NPE bug, Chart-4 , and its patch
generated by VF IX. The bug happens in /lscript4494 , where r
can be null. VF IXadds a null check in /lscript4493 and/lscript4452 to
encompass /lscript4494−/lscript4451 in an if branch by [SKIP-MULTI] .
By manual inspection, we found that this patch is identical
to the one committed by developers. The challenge here
lies in determining the end of the scope for the if-branch.
Closing it too early (e.g., right after /lscript4494 ) would leave some
variables that are data-dependent on the skipped statements to
be undeﬁned (e.g., cin/lscript4495 andain/lscript4499 ). Closing it too
late would introduce unnecessary control-dependencies on the
if-statement added (in /lscript4493 ), potentially altering the program
logic. Without value-ﬂow analysis, one would have to blindly
enumerate all possible mutations at a statement in order to ﬁnd
a correct ﬁx, which is computationally impractical. With value-
ﬂow analysis, resulting in a precise Ovf,V F IXcan correctly
identify the scope of the inserted if branch by [SKIP-MULTI] .
Figure 11(b) illustrates another NPE bug, Chart-16 ,
repaired by VF IX. This bug happens in /lscript574 as
this.category is not initialized in /lscript207 in the constructor
DefautlIntervalCategoryDataset(...) .G i v e n
/lscript574,Gstabuilt by VF IXcontains not only /lscript574 but also
/lscript690, another potential NPE crash site. For the given NPE-
triggering test case, Lvfcontains/lscript208 and/lscript574 (but not/lscript690
as it is not executed). VF IXﬁnds the correct patch, which4493
4494
4495
4496
4497
4498
4499
4450
4451
4452+if(r!=null ){
Collection c=r.getAnnotations();
Iterator I=c.iterator();
while (i.hasNext()){
XYAnnotation a =(XYAnnotation)i.next();
if(ainstanceof XYAnnotationBoundsInfo){
includedAnnotations.add(a);
}
}
+}
(a) An NPE, Chart-4 , correctly repaired with a precise Ovf
142
207
208
209
573
574
581
689
690
691DefaultIntervalC ategoryDataset(…) {
…
- this .categoryKeys = null ;
+ this .categoryKeys = new Comparable[0];
}
…
public int getCategoryIndex(…){
for(int i=0;i< this .categoryKeys.length;i++)
…
}
…
public int getColumnCount(){ 
return this .categoryKeys.length;
}
(b) An NPE, Chart-16 , correctly repaired with a precise Lvf
Fig. 11: Two case studies in Defects4j (with the patches
generated by VF IXshown by +anf -).
initializes this.category in/lscript208 by[INIT-SRC] . This
patch can be obtained only if the inter-procedural value-ﬂow
information is available. In addition, our ranking algorithm,
which prioritizes the repair statements Lvfprecisely by their
congestion values, is also instrumental here. As Gstacontains
both/lscript574 and/lscript690,/lscript208 is ranked ahead of /lscript574, enabling
VF IXto generate the correct ﬁx in /lscript208. Otherwise, adding
the same ﬁx just before /lscript574 is only plausible but incorrect,
as it fails to ﬁx the other NPE crash site in /lscript690.
F . Discussions
In this paper, we investigate how to apply value-ﬂow anal-
ysis to boost the precision and efﬁciency of APR. While we
focus on ﬁxing NPEs, the most common type of Java bugs,
our approach can also be effective in ﬁxing other types of bugs
such as use-after-free and memory leaks in C/C++ programs.
In practice, a test suite provided for a bug report may
not be comprehensive enough to enable the bug to be ﬁxed.
This paper shows that we can mitigate such deﬁciency by
augmenting a test suite with static value-ﬂow analysis.
Currently, VF IXfocuses on repairing a class of com-
monly occurring NPE bugs under the assumptions that
call-graph integrity and type integrity are preserved (Sec-
tion III-C). However, an NPE can occur when a wrong API
is called, resulting in a call-graph integrity violation. For
example, ﬁxing Math-70 inDefects4j would require
return solve(min, max) to be replaced by return
solve(min, max) , so that fbecomes correctly initialized.
In addition, an NPE can also occur due to an integer overﬂow,
caused possibly by a type integrity violation. For example,
ﬁxing the NPE bug, Math-79 inDefects4j , would require
the declared type of sum anddp in method distance()
of class MathUtils to be changed from int todouble .
520
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:36:43 UTC from IEEE Xplore.  Restrictions apply. Going beyond our current bug model will be an interesting
research topic.
V. R ELA TED WORK
A. Automated Program Repair
Existing APR approaches can be broadly classiﬁed into
two categories: general-purpose approaches , which can be
theoretically applied to all kinds of bugs, and bug-speciﬁc
approaches , which are designed for speciﬁc types of bugs.
General-purpose approaches are based on search algorithms or
driven by semantics-preserving transformations. Search-based
approaches typically adopt a generate-and-validate process
that generates candidate patches by exhaustively exploring the
solution space using, for example, genetic programming [38,
79] or random search [54], and then validates the patches
with a test suite. In practice, the large search space hinders
their efﬁciency and scalability. Therefore, much research has
been devoted to developing effective heuristics and repair
templates for narrowing down the scope and guiding the search
to generate correct patches efﬁciently. For example, AE [78]
reduces the search space by merging semantically equivalent
patches. P ROPHET [44] uses machine learning techniques
to guide patch generation by learning from correct patches.
CAPGEN [81] leverages the context information extracted
from a program’s AST to achieve ﬁne-grained patch prior-
itization. PAR [34] summarizes common ﬁx patterns from
human-written patches and performs the generate-and-validate
process within a domain conﬁned by these patterns. ACS [86]
focuses on synthesizing branch conditions, ranking patches
by analyzing documents, predicate statistics and dependencies
relations between variables. Semantics-driven approaches [35,
36, 49, 50, 53, 87] represent another class of program repair
techniques, which view a repair task as a program synthesis
problem and synthesize patches via constraint-solving. As
evaluated in Section IV, existing general-purpose approaches
are only marginally effective for repairing NPEs.
Bug-speciﬁc APR techniques restrict their scope to some
types of bugs only. For example, F OOT PAT C H [77] ﬁxes bugs
related to heap memory properties by employing separation
logic to reason about pointer semantics. M EMFIX[39] consid-
ers memory deallocation errors (e.g., memory leaks, double-
free and use-after-free bugs) using static analysis. There are
also others focusing on buffer overﬂows [60, 92], integer
overﬂows [13, 18], memory leaks [23, 89], error-handling
bugs [75] and concurrency errors [29, 29]. The work that
is the most closely related to ours is NPEF IX[22], which
generates patches for NPEs by capturing runtime information
with dynamic analysis. In contrast, VF IXrepresents a static
approach for ﬁxing NPEs by performing a systematic value-
ﬂow analysis to drastically reduce the search space in order to
avoid implausible and plausible but incorrect patches. As eval-
uated in Section IV, VF IXoutperforms NPEF IXsigniﬁcantly
in terms of both effectiveness and precision.B. V alue-Flow Analysis
Understanding the ﬂow of values in a program is funda-
mental in program analysis [61, 70]. By explicitly modelling
the deﬁnition-use relations among program variables, value-
ﬂow analysis enables or enhances a series of crucial tasks,
including compiler optimization [7, 67], pointer analysis [40,
51, 62, 69, 70, 73, 74], bug detection [14, 71], software
debugging [80, 82], and validation and veriﬁcation [19, 21].
In recent years, for example, the potential for value-ﬂow
analysis has been widely explored in detecting a variety
of critical bugs, including memory leaks [14, 71], uses of
uninitialized variables [46, 91], use-after-free errors [61, 90],
and information leaks [5, 26]. While many existing approaches
track the ﬂow of values iteratively at each program point along
the control-ﬂow [6, 57, 63, 64], VF IXuses a fully-sparse
value-ﬂow analysis for both variables and ﬁelds. This full-
sparsity leads to the efﬁciency of VF IX. To the best of our
knowledge, VF IXis the ﬁrst approach that exploits value-ﬂow
analysis to repair NPE bugs.
C. Mitigations Againist Null Pointer Dereferences
The NPEs that cause program crashes can be detected by
a variety of testing techniques such as fuzzing [1, 8, 10] and
symbolic execution [11, 25, 59]. To increase coverage, static
analysis has been investigated. X YLEM [52], for example, is a
representative static detector that has been shown to be effec-
tive in the industry. There also exist research efforts focusing
on verifying the absence of NPEs using static analysis, in both
whole-program [42, 65] and demand-driven [47] settings. In
addition, fault tolerance techniques for NPEs has also been
studied [20, 27, 45]. RCV [45], for example, processes the
interrupt signals triggered by NPEs at runtime with its own
handlers to allow a buggy program to continue execution.
VF IX, as an APR approach, can also beneﬁt from a more
precise static analysis for its fault localization.
VI. C ONCLUSION
This paper presents VF IX, a new value-ﬂow-guided APR
approach for ﬁxing NPE bugs by considering a substantially
reduced solution space in order to increase the number of
correct patches generated efﬁciently. We have formulated our
fault localiaztion problem as one of solving a congestion calcu-
lation problem based on static value-ﬂow analysis and dynamic
execution trace with respect to a given NPE-triggering test
case. We have formulated our problem of generating repair
operations as one of instantiating repair templates subject to
certain value-ﬂow constraints. VF IXis shown to generate more
correct patches more efﬁciently than the state of the art.
In future work, we plan to extend VF IXby repairing the
types of NPE bugs that are not currently covered by our bug
model. We also plan to generalize our value-ﬂow analysis
approach to repair other non-NPE bugs.
VII. A CKNOWLEDGMENTS
We would like to thank the anonymous reviewers for their
valuable comments. This research is supported by Australian
Research Grants DP180104169 and DE170101081.
521
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:36:43 UTC from IEEE Xplore.  Restrictions apply. REFERENCES
[1] American fuzzy lop (aﬂ) fuzzer. http://lcamtuf.coredump.cx/aﬂ.
[2] Apache projects issues. https://issues.apache.org/jira/projects.
[3] Javaparser. https://javaparser.org/.
[4] R. Abreu, P . Zoeteweij, and A. J. V an Gemund. On the accuracy
of spectrum-based fault localization. In TAICPART-MUTATION
’07, pages 89–98, 2007.
[5] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel, J. Klein,
Y . Le Traon, D. Octeau, and P . McDaniel. Flowdroid: Precise
context, ﬂow, ﬁeld, object-sensitive and lifecycle-aware taint
analysis for android apps. In PLDI ’14 , pages 259–269, 2014.
[6] D. Babic and A. J. Hu. Calysto: Scalable and precise extended
static checking. In ICSE ’08 , pages 211–220, 2008.
[7] R. Bod ´ık and S. Anik. Path-sensitive value-ﬂow analysis. In
POPL ’98 , pages 237–251, 1998.
[8] M. B ¨ohme, V .-T. Pham, M.-D. Nguyen, and A. Roychoudhury.
Directed greybox fuzzing. In CCS ’17 , pages 2329–2344, 2017.
[9] M. D. Bond, N. Nethercote, S. W. Kent, S. Z. Guyer, and K. S.
McKinley. Tracking bad apples: reporting the origin of null and
undeﬁned value errors. In OOPSLA 07 , pages 405–422, 2007.
[10] E. Bounimova, P . Godefroid, and D. Molnar. Billions and
billions of constraints: Whitebox fuzz testing in production. In
ICSE ’13 , pages 122–131, 2013.
[11] C. Cadar, D. Dunbar, D. R. Engler, et al. Klee: Unassisted
and automatic generation of high-coverage tests for complex
systems programs. In OSDI ’08 , pages 209–224, 2008.
[12] J. Campos, A. Riboira, A. Perez, and R. Abreu. Gzoltar: an
eclipse plug-in for testing and debugging. In ASE ’12 , pages
378–381, 2012.
[13] X. Cheng, M. Zhou, X. Song, M. Gu, and J. Sun. Intpti:
Automatic integer error repair with proper-type inference. In
ASE ’17 , pages 996–1001, 2017.
[14] S. Cherem, L. Princehouse, and R. Rugina. Practical memory
leak detection using guarded value-ﬂow analysis. In PLDI ’07 ,
pages 480–491, 2007.
[15] J. Chuzhoy. Routing in undirected graphs with constant con-
gestion. In STOC ’12 , pages 855–874, 2012.
[16] J. Chuzhoy, V . Guruswami, S. Khanna, and K. Talwar. Hardness
of routing with congestion in directed graphs. In STOC ’07 ,
pages 165–178, 2007.
[17] M. Cielecki, J. Fulara, K. Jakubczyk, and Ł. Jancewicz. Prop-
agation of jml non-null annotations in java programs. In PPPJ
’06, pages 135–140. ACM, 2006.
[18] Z. Coker and M. Haﬁz. Program transformations to ﬁx c
integers. In ICSE ’13 , pages 792–801, 2013.
[19] M. Das, S. Lerner, and M. Seigle. Esp: Path-sensitive program
veriﬁcation in polynomial time. In PLDI ’02 , pages 57–68,
2002.
[20] K. Dobolyi and W. Weimer. Changing java’s semantics for
handling null pointer exceptions. In ISSRE ’08 , pages 47–56,
2008.
[21] N. Dor, S. Adams, M. Das, and Z. Yang. Software validation
via scalable path-sensitive value ﬂow analysis. In ISSTA ’04 ,
pages 12–22, 2004.
[22] T. Durieux, B. Cornu, L. Seinturier, and M. Monperrus.
Dynamic patch generation for null pointer exceptions using
metaprogramming. In SANER ’17 , pages 349–358, 2017.
[23] Q. Gao, Y . Xiong, Y . Mi, L. Zhang, W. Yang, Z. Zhou, B. Xie,
and H. Mei. Safe memory-leak ﬁxing for c programs. In ICSE
’15, pages 459–470, 2015.
[24] Q. Gao, H. Zhang, J. Wang, Y . Xiong, L. Zhang, and H. Mei.
Fixing recurring crash bugs via analyzing q&a sites (T). In ASE
’15,pages 307–318, 2015.
[25] P . Godefroid, N. Klarlund, and K. Sen. Dart: Directed automated
random testing. In PLDI ’05 , pages 213–223, 2005.
[26] M. I. Gordon, D. Kim, J. H. Perkins, L. Gilham, N. Nguyen, and
M. C. Rinard. Information ﬂow analysis of android applicationsin droidsafe. In NDSS ’15 , page 110, 2015.
[27] T. Gu, C. Sun, X. Ma, J. L ¨u, and Z. Su. Automatic runtime
recovery via error handler synthesis. In ASE’16 , pages 684–695,
2016.
[28] J. Jiang, Y . Xiong, H. Zhang, Q. Gao, and X. Chen. Shaping
program repair space with existing patches and similar code. In
ISSTA ’18 , pages 298–309, 2018.
[29] G. Jin, L. Song, W. Zhang, S. Lu, and B. Liblit. Automated
atomicity-violation ﬁxing. In PLDI ’11 , pages 389–400, 2011.
[30] R. Just, D. Jalali, and M. D. Ernst. Defects4j: A database
of existing faults to enable controlled testing studies for java
programs. In ISSTA ’14 , pages 437–440, 2014.
[31] S. Kaleeswaran, V . Tulsian, A. Kanade, and A. Orso. Minthint:
automated synthesis of repair hints. In ICSE ’14 , pages 266–
276, 2014.
[32] Y . Ke, K. T. Stolee, C. Le Goues, and Y . Brun. Repairing
programs with semantic code search (T). In ASE ’15 , pages
295–306, 2015.
[33] S. W. Kent. Dynamic error remediation: A case study with null
pointer exceptions. University of Texas Masters thesis , 2008.
[34] D. Kim, J. Nam, J. Song, and S. Kim. Automatic patch
generation learned from human-written patches. In ICSE ’13 ,
pages 802–811, 2013.
[35] X.-B. D. Le, D.-H. Chu, D. Lo, C. Le Goues, and W. Visser.
Jﬁx: Semantics-based repair of java programs via symbolic
pathﬁnder. In ISSTA ’17 , pages 376–379, 2017.
[36] X.-B. D. Le, D.-H. Chu, D. Lo, C. Le Goues, and W. Visser. S3:
Syntax-and semantic-guided repair synthesis via programming
by examples. In ESEC/FSE’17 , pages 593–604, 2017.
[37] X. D. Le, D. Lo, and C. Le Goues. History driven program
repair. In SANER ’16 , pages 213–224, 2016.
[38] C. Le Goues, T. Nguyen, S. Forrest, and W. Weimer. Genprog:
A generic method for automatic software repair. TSE , 38(1):54–
72, 2012.
[39] J. Lee, S. Hong, and H. Oh. Memﬁx: static analysis-based repair
of memory deallocation errors for c. In ESEC/FSE’18 , pages
95–106, 2018.
[40] L. Li, C. Cifuentes, and N. Keynes. Boosting the performance of
ﬂow-sensitive points-to analysis using value ﬂow. In ESEC/FSE
’11, pages 343–353, 2011.
[41] Z. Li, L. Tan, X. Wang, S. Lu, Y . Zhou, and C. Zhai. Have
things changed now?: an empirical study of bug characteristics
in modern open source software. In ASID ’06 , pages 25–33,
2006.
[42] A. Loginov, E. Yahav, S. Chandra, S. Fink, N. Rinetzky, and
M. Nanda. V erifying dereference safety via expanding-scope
analysis. In ISSTA ’08 , pages 213–224, 2008.
[43] F. Logozzo and T. Ball. Modular and veriﬁed automatic program
repair. In OOPSLA ’12 , pages 133–146, 2012.
[44] F. Long and M. Rinard. Automatic patch generation by learning
correct code. In POPL ’16 , pages 298–312, 2016.
[45] F. Long, S. Sidiroglou-Douskos, and M. Rinard. Automatic
runtime error repair and containment via recovery shepherding.
InPLDI ’14 , pages 227–238, 2014.
[46] K. Lu, C. Song, T. Kim, and W. Lee. Unisan: Proactive kernel
memory initialization to eliminate data leakages. In CCS ’16 ,
pages 920–932, 2016.
[47] R. Madhavan and R. Komondoor. Null dereference veriﬁcation
via over-approximated weakest pre-conditions analysis. In
OOPSLA ’11 , pages 1033–1052, 2011.
[48] M. Martinez, T. Durieux, R. Sommerard, J. Xuan, and M. Mon-
perrus. Automatic repair of real bugs in java: A large-scale
experiment on the defects4j dataset. Empirical Software Engi-
neering , 22(4):1936–1964, 2017.
[49] S. Mechtaev, J. Yi, and A. Roychoudhury. Directﬁx: Looking
for simple program repairs. In ICSE ’15 , pages 448–458, 2015.
[50] S. Mechtaev, J. Yi, and A. Roychoudhury. Angelix: Scalable
522
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:36:43 UTC from IEEE Xplore.  Restrictions apply. multiline program patch synthesis via symbolic analysis. In
ICSE ’16 , pages 691–701, 2016.
[51] A. Milanova, A. Rountev, and B. G. Ryder. Parameterized object
sensitivity for points-to analysis for java. TOSEM , 14(1):1–41,
2005.
[52] M. G. Nanda and S. Sinha. Accurate interprocedural null-
dereference analysis for java. In ICSE ’09 , pages 133–143,
2009.
[53] H. D. T. Nguyen, D. Qi, A. Roychoudhury, and S. Chandra.
Semﬁx: Program repair via semantic analysis. In ICSE ’13 ,
pages 772–781, 2013.
[54] Y . Qi, X. Mao, Y . Lei, Z. Dai, and C. Wang. The strength
of random search on automated program repair. In ICSE ’14 ,
pages 254–265, 2014.
[55] Z. Qi, F. Long, S. Achour, and M. C. Rinard. An analysis
of patch plausibility and correctness for generate-and-validate
patch generation systems. In ISSTA ’15 , pages 24–36, 2015.
[56] M. Renieres and S. P . Reiss. Fault localization with nearest
neighbor queries. In ASE ’03 , pages 30–39, 2003.
[57] T. Reps, S. Horwitz, and M. Sagiv. Precise interprocedural
dataﬂow analysis via graph reachability. In POPL ’95 , pages
49–61, 1995.
[58] R. K. Saha, Y . Lyu, H. Y oshida, and M. R. Prasad. ELIXIR:
effective object oriented program repair. In ASE ’17 , pages
648–659, 2017.
[59] K. Sen, D. Marinov, and G. Agha. Cute: A concolic unit testing
engine for c. In ESEC/FSE’05 , pages 263–272, 2005.
[60] A. Shaw, D. Doggett, and M. Haﬁz. Automatically ﬁxing c
buffer overﬂows using program transformations. In DSN ’14 ,
pages 124–135, 2014.
[61] Q. Shi, X. Xiao, R. Wu, J. Zhou, G. Fan, and C. Zhang.
Pinpoint: Fast and precise sparse value ﬂow analysis for million
lines of code. In PLDI ’18 , pages 693–706, 2018.
[62] Y . Smaragdakis, M. Bravenboer, and O. Lhot ´ak. Pick your
contexts well: understanding object-sensitivity. In POPL ’11 ,
pages 17–30, 2011.
[63] J. Sp ¨ath, K. Ali, and E. Bodden. Ide al: Efﬁcient and precise
alias-aware dataﬂow analysis. In OOPSLA ’17 , page 99, 2017.
[64] J. Sp ¨ath, L. Nguyen Quang Do, K. Ali, and E. Bodden.
Boomerang: Demand-driven ﬂow-and context-sensitive pointer
analysis for java. In ECOOP ’16 , pages 22:1–22:26, 2016.
[65] F. Spoto. Precise null-pointer analysis. Software & Systems
Modeling , 10(2):219–252, 2011.
[66] M. Sridharan and R. Bod ´ık. Reﬁnement-based context-sensitive
points-to analysis for java. In PLDI ’06 , pages 387–400, 2006.
[67] B. Steffen, J. Knoop, and O. R ¨uthing. The value ﬂow graph:
A program representation for optimal program transformations.
InESOP ’90 , pages 389–405, 1990.
[68] F. Steimann, M. Frenkel, and R. Abreu. Threats to the validity
and value of empirical assessments of the accuracy of coverage-
based fault locators. In ISSTA ’13 , pages 314–324, 2013.
[69] Y . Sui and J. Xue. On-demand strong update analysis via value-
ﬂow reﬁnement. In FSE ’16 , pages 460–473, 2016.
[70] Y . Sui and J. Xue. SVF: interprocedural static value-ﬂow
analysis in llvm. In CC ’16 , pages 265–266, 2016.
[71] Y . Sui, D. Ye, and J. Xue. Static memory leak detection using
full-sparse value-ﬂow analysis. In ISSTA ’12 , pages 254–264,
2012.[72] S. H. Tan, Z. Dong, X. Gao, and A. Roychoudhury. Repairing
crashes in android apps. In ICSE ’18 , 2018.
[73] T. Tan, Y . Li, and J. Xue. Making k-object-sensitive pointer
analysis more precise with still k-limiting. In SAS ’16 , pages
489–510, 2016.
[74] T. Tan, Y . Li, and J. Xue. Efﬁcient and precise points-to
analysis: modeling the heap by merging equivalent automata.
PLDI ’17 , 52(6):278–291, 2017.
[75] Y . Tian and B. Ray. Automatically diagnosing and repairing
error handling bugs in c. In ESEC/FSE’17 , pages 752–762,
2017.
[76] R. V all ´ee-Rai, P . Co, E. Gagnon, L. Hendren, P . Lam, and
V . Sundaresan. Soot: A java bytecode optimization framework.
InCASCON ’99 , pages 13–, 1999.
[77] R. van Tonder and C. Le Goues. Static automated program
repair for heap properties. In ICSE ’18 , pages 151–162, 2018.
[78] W. Weimer, Z. P . Fry, and S. Forrest. Leveraging program equiv-
alence for adaptive program repair: Models and ﬁrst results. In
ASE ’13 , pages 356–366, 2013.
[79] W. Weimer, T. Nguyen, C. Le Goues, and S. Forrest. Automat-
ically ﬁnding patches using genetic programming. In ICSE’09 ,
pages 364–374, 2009.
[80] M. Weiser. Programmers use slices when debugging. Commu-
nications of the ACM , 25(7):446–452, 1982.
[81] M. Wen, J. Chen, R. Wu, D. Hao, and S.-C. Cheung. Context-
aware patch generation for better automated program repair. In
ICSE ’18 , 2018.
[82] R. Wism ¨uller. Debugging of globally optimized programs using
data ﬂow analysis. In PLDI ’94 , pages 278–289, 1994.
[83] W. E. Wong, R. Gao, Y . Li, R. Abreu, and F. Wotawa. A survey
on software fault localization. TSE , 42(8):707–740, 2016.
[84] Q. Xin and S. P . Reiss. Leveraging syntax-related code for
automated program repair. In ASE ’17 , pages 660–670, 2017.
[85] Y . Xiong, X. Liu, M. Zeng, L. Zhang, and G. Huang. Identifying
patch correctness in test-based program repair. In ICSE ’18 ,
pages 789–799, 2018.
[86] Y . Xiong, J. Wang, R. Yan, J. Zhang, S. Han, G. Huang, and
L. Zhang. Precise condition synthesis for program repair. In
ICSE ’17 , pages 416–426, 2017.
[87] J. Xuan, M. Martinez, F. Demarco, M. Clement, S. R. L.
Marcote, T. Durieux, D. L. Berre, and M. Monperrus. Nopol:
Automatic repair of conditional statement bugs in java pro-
grams. TSE , 43(1):34–55, 2017.
[88] J. Xuan and M. Monperrus. Learning to combine multiple
ranking metrics for fault localization. In ICSME ’14 , pages
191–200, 2014.
[89] H. Yan, Y . Sui, S. Chen, and J. Xue. Automated memory leak
ﬁxing on value-ﬂow slices for c programs. In SAC ’16 , pages
1386 – 1393, 2016.
[90] H. Yan, Y . Sui, S. Chen, and J. Xue. Spatio-temporal context
reduction: A pointer-analysis-based static approach for detecting
use-after-free vulnerabilities. In ICSE ’18 , pages 327–337,
2018.
[91] D. Ye, Y . Sui, and J. Xue. Accelerating dynamic detection of
uses of undeﬁned values with static value-ﬂow analysis. In CGO
’14, page 154, 2014.
[92] C. Zhang, T. Wang, T. Wei, Y . Chen, and W. Zou. Intpatch: Au-
tomatically ﬁx integer-overﬂow-to-buffer-overﬂow vulnerability
at compile-time. In ESORICS ’10, pages 71–86, 2010.
523
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:36:43 UTC from IEEE Xplore.  Restrictions apply. 