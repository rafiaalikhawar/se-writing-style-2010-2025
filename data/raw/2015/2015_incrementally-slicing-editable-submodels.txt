Incrementally Slicing Editable Submodels
Christopher Pietsch, Manuel Ohrndorf, Udo Kelter
Software Engineering Group
University of Siegen
Germany
fcpietsch, mohrndorf, kelterg@informatik.uni-siegen.deTimo Kehrer
Department of Computer Science
Humboldt-University of Berlin
Germany
ftimo.kehrerg@informatik.hu-berlin.de
Abstract ‚ÄîModel slicers are tools which provide two services:
(a) Ô¨Ånding parts of interest in a model and (b) displaying these
parts somehow or extract these parts as a new, autonomous
model, which is referred to as slice or sub-model. This paper
focuses on the creation of editable slices, which can be processed
by model editors, analysis tools, model management tools etc.
Slices are useful if, e.g., only a part of a large model shall be
analyzed, compared or processed by time-consuming algorithms,
or if sub-models shall be modiÔ¨Åed independently. We present a
new generic incremental slicer which can slice models of arbitrary
type and which creates slices which are consistent in the sense
that they are editable by standard editors. It is built on top of
a model differencing framework and does not require additional
conÔ¨Åguration data beyond those available in the differencing
framework. The slicer can incrementally extend or reduce an
existing slice if model elements shall be added or removed, even
if the slice has been edited meanwhile. We demonstrate the
usefulness of our slicer in several scenarios using a large UML
model. A screencast of the demonstrated scenarios is provided
at http://pi.informatik.uni-siegen.de/projects/SiLift/ase2017.
I. I NTRODUCTION
Document slicers are tools which provide two services: (a)
Ô¨Ånding ‚Äúinteresting‚Äù parts of an existing document and (b)
displaying these parts in appropriate form or producing a new
document which consists of these parts, which is referred to as
slice or sub-document. Slicing of programs has a long tradition
[1], [2]. Program slicers address a broad range of use cases
where a program slice with certain properties is required. They
put most emphasis on service (a): for a given, user-speciÔ¨Åed
slicing criterion, they Ô¨Ånd related program fragments. These
slicers can be regarded as highly specialized query processors.
Service (b) is of minor importance here.
With the advent of model-based software development
(MBSD), models rather than source code play the role of
primary software artifacts. Many similar use cases as known
from program slicing must be supported for model slicing.
Model slicing is, additionally, often motivated by a different
class of use cases where step (b), the construction of a new
document, is a main requirement and a big challenge. One
typical motivation are inefÔ¨Åcient model checkers, test suite
generators etc.; in order to reduce run-times, they are applied
to small slices (or sub-models) rather than to a large complete
model. Further motivations include transport of the slice and
integration into other system models, or independent editing
of parts of a model. These and similar motivations of model
slicing are addressed by the slicer presented in this paper.From a more technical point of view, producing a slice as
a new model can be regarded as a function call
Slice aSlice = slice(largeModel, slCrit);
slCrit is the slicing criterion provided by the user. Internally,
the computation of the slice roughly proceeds as follows:
ElementSet RME = select(largeModel, slCrit);
ElementSet extRME = extend(largeModel, RME);
Slice aSlice = createSl(largeModel, extRME);
The Ô¨Årst task, the selection, determines the set RME of re-
quested model elements (more speciÔ¨Åcally the sets of nodes
and edges of the abstract syntax graph of largeModel)
which must be present in the slice, e.g.,
‚Äì all direct and indirect super-classes of a given class ‚ÄúX‚Äù,
‚Äì the sequence-diagram named ‚ÄúX‚Äù of a system model, or
‚Äì the set of model elements violating a given OCL inivariant.
In many cases, Ô¨Ånding these requested model elements can
be expressed as a simple graph query using languages such as
OCL, XPath etc. The set RME does not normally conform to
the required properties of the slice, e.g., conformance to the
meta-model.
The second task, the extension, extends RME by further
model elements to make it displayable and editable in standard
visual editors for the given modeling language. For example,
assume that RME comprises the elements of a sequence dia-
gram of a large UML model and that label names of lifelines
or messages are derived from class deÔ¨Ånitions. Then extRME
must contain appropriate fragments of these class deÔ¨Ånitions.
A large number of model slicers has been developed. Most
of them work only with one speciÔ¨Åc type of models, notably
state machines and similar types of ‚Äúexecutable‚Äù models [3],
[4]. Other supported model types include class diagrams,
feature models and meta-models. Virtually all proposed slicers
only support the selection task. The selection function of
these slicers typically exploits the semantics of the models.
This implies that these approaches cannot be transferred to
model types which have different semantics or no execution
semantics at all. Moreover, they can only slice models with
a certain degree of syntactic and semantic correctness, i.e.,
models which conform to all basic and many advanced (but
not always all) constraints deÔ¨Åned in their meta model.
The only well-known more generally usable technique
which also supports the second step of generating a new model
978-1-5386-2684-9/17/$31.00 c2017 IEEEASE 2017, Urbana-Champaign, IL, USA
Tool Demonstrations913
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:30:50 UTC from IEEE Xplore.  Restrictions apply. is Kompren [5], which is actually a generator for model slicers.
A slicer generated by Kompren transforms a large model into
a smaller one, the slice. Kompren does not provide task-
speciÔ¨Åc queries for Ô¨Ånding ‚Äúinteresting‚Äù parts of a model based
on a ‚Äúslicing criterion,‚Äù but provides only general querying
facilities for models. The user must implement the search for
interesting parts and specify how to extend these parts to a
valid model by using a dedicated domain-speciÔ¨Åc language.
The user is responsible to guarantee that a slice exhibits
all desired properties. Moreover, slices are always created
from scratch, incrementally adapting a slice, an indispensable
feature for all use cases where slices are edited by developers,
is not supported.
In this paper, we present a new generic slicer with the
following novel features:
a) It is integrated within a suite of other modeling tools
which all assume a common notion of ‚Äúbasic consistency‚Äù of
models, which is basically given by the standard model editor.
Technically, we refer to this consistency level as ‚Äúeffective
meta model‚Äù [6] of the tool suite.
b) Our slicer guarantees that all slices produced conform
to the effective meta model, i.e. they are editable with the
standard model editor.
c) Our slicer does not need additional conÔ¨Åguration data.
It automatically conÔ¨Ågures itself using conÔ¨Åguration data
available in our tool suite.
d) Technically, our slicer is divided in two components: (a)
aserver, which accesses the whole model and which can run
on a powerful server hardware, (b) a client, which runs on a
workstation, maintains the slice and does not load or directly
access the whole model.
e) Our slicer is incremental in the sense that a slice can
be extended or reduced, more speciÔ¨Åcally, that arbitrary sets
of model elements can be added to, or removed from, RME
and the slice is automatically adapted. This adaptation is fully
automated if the slice is unchanged. If the slice has been
edited, possible conÔ¨Çicts are resolved interactively.
II. P ROBLEM MOTIVATION
In this section, we introduce a running example and motivate
the problem of slicing editable sub-models. Finally, we give a
formal deÔ¨Ånition of the notion of incremental slicing.
A. Running Example
We will use the Barbados Car Crash Crisis Management
System (bCMS) [7] as our running example. Figure 1 shows an
excerpt of the whole system model describing the operations
of a police and a Ô¨Åre department in case of a crisis situation.
The system is modeled from different viewpoints. The class
diagram models the static view of the system, i.e., its key
entities and their relationships. State machine and sequence
diagrams model the dynamic view of the system, i.e., its
runtime behavior.
The different diagrams are not, as one might think, inde-
pendent, in fact they depend on each other. Figure 2 shows an
excerpt of the UML meta-model illustrating the interrelations
Fig. 1. Excerpt of the system model of the bCMS case study [7].
of the different diagrams based on the abstract syntax. For in-
stance, a Lifeline in a sequence diagram usually represents
aProperty of aClass. An Operation of a class can
be used as the signature of aMessage (s. green-shaded
part in Figure 2). Analogously, a CallEvent that is used by
aTrigger of aTransition in a state machine diagram
must refer to an Operation of aClass (s. red-shaded part
in Figure 2).
B. Extending the Set RME
Assume a developer wants to extract a state machine (or a
part of it) from the complete model. In the abstract syntax
graph (ASG) of our model, a state machine is basically a
subtree of the containment tree which contains all states,
transitions etc. of this state machine. RME would thus be
deÔ¨Åned as the set of all ASG nodes in this subtree. If we
simply copy this subtree into a new empty model then the
resulting ASG contains all nodes speciÔ¨Åed in RME, but violates
the multiplicity constraint of the reference event between
Trigger andCallEvent because the CallEvent is not
part of the state machine (it is owned by the package), but a
‚Äúmandatory neighbor‚Äù. CallEvents are typical examples of
ASG nodes which implement a relationship between two sub-
models. They have no corresponding graphical object in the
visual representation of these sub-models and do not represent
914
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:30:50 UTC from IEEE Xplore.  Restrictions apply. Fig. 2. Excerpt of the UML meta-model.
a user-level concept of the modeling language. An average user
is hardly able or willing to manually deal with these ASG
nodes. Without them, however, an ASG can be considered
corrupted and will not be processed by an editor or analysis
tool (s. Section V for further scenarios).
The main aim of the extension of RME to a superset extRME
is to add these technically required ASG nodes.
C. Incremental Slicing
A slice initially created for a set of requested model ele-
ments RMEoldcan turn out to be inappropriate, most typically
because additional model elements are desired or because the
slice is still too large. One option to get a better slice is to
deÔ¨Åne a revised set RME, namely RMEnew, to discard the old
slice, and to recompute the slice for RMEnew. This option does
not work if the slice has been edited. A better approach is thus
to obtain a model patch which, if applied to the current slice,
adds or removes model elements as desired. If the slice is
unchanged such a patch can be applied successfully without
raising errors. If it has been edited, conÔ¨Çicts can occur, which
must be resolved appropriately.
There are two basic approaches for deÔ¨Åning the new slice.
One approach is to use a new slicing criterion and to compute
RMEnewasselect(largeModel, slCrit new).RMEold
andRMEnew implicitly deÔ¨Åne the sets of additional and
removable model elements:
addRME =RMEnewnRMEoldand
remRME =RMEoldnRMEnew.
Another approach is to let the user explicitly deÔ¨Åne the
setsaddRME andremRME by a suitable user interface. The
resulting slice does not necessarily have a compact slicing
criterion in the syntax accepted by the select function.
In both user interface designs, incrementally adapting an
existing slice boils down to an (internal) operation call
aSlice.incrAdapt(addRME, remRME);
The effect of the incrAdapt operation is conceptu-
ally as follows. Our current slice actually contains the el-
ements extend(RME old), the new slice should contain the
elements extend(RME new). The model patch which adapts
the slice to RMEnewmust thus effectively remove the elements
removedME and add the elements addedME, with
removedME = extend(RME old)nextend(RME new),
\
\
\ \Fig. 3. Added and removed model elements
addedME = extend(RME new)nextend(RME old),
s. red- and green-bordered areas in Figure 3. Note that
elements in the set RET = RME old\(extend(RME new)n
RME new), although speciÔ¨Åed as removable, are retained, be-
cause they are required in extend(RME new)(s. dark gray
part in Figure 3).
III. B ASIC DESIGN DECISIONS
In this section, we present basic design decisions of our
approach. We Ô¨Årst introduce the distribution model of our tool
architecture, before we present the basic idea of creating a new
slice and adapting an existing slice based on the principle of
document patching.
A. Distribution Model
If very large models are to be sliced for performance
reasons it would be counter-productive if the complete model
is required to be available in the workspace or even to be
loaded.
One basic design decision of our approach is therefore to
separate between a client and a server (s. Figure 4), which
can be physically distributed over different machines. The
complete large model resides on the server, typically in a
centrally hosted model repository. The slice exists in a local
workspace at the client site.
Complete
modelSlice1.
2.
4.
5.3.
6.Server Client
Fig. 4. Logical separation of our model slicer into client and server parts.
B. Creating a New Slice
A user requests the generation of a new slice Sby specifying
a set RME of requested model elements. Our approach is
open to any method for determining this set. Our approach
to construct Sin the client is to (a) calculate a creating patch
)S on the server side, (b) send it to the client, and (c)
apply it to the empty model . The resulting slice Scontains
all model elements in extRME (and thus the subset RME).
To that end, a basic design decision is to exploit existing
technologies for calculating and handling of consistency-
preserving edit scripts [8], a special form of model patches,
as it will be explained in more detail later.
915
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:30:50 UTC from IEEE Xplore.  Restrictions apply. C. Adapting an Existing Slice
To adapt a slice S, the client sends an invocation of
S.incrAdapt(addRME, remRME) to the server. The
server (a) determines the sets of elements removedME and
addedME as deÔ¨Åned in Section II-C, (b) constructs an adapting
patch S)S0, and (c) sends S)S0to the client, where it is
applied to the current slice S, which is transformed to S‚Äô. We
utilize again consistency-preserving edit scripts here.
By construction of our edit scripts, updating an unmodiÔ¨Åed
slice will never fail. However, if the slice has been edited in the
client local changes can be in conÔ¨Çict with changes speciÔ¨Åed
by the adapting patch. This problem also occurs when local
copies of models in workspaces are to be updated by changes
checked in into a repository. A solution to this problem,
which is based on the principle of model patching, has been
presented in [9]. This workspace update tool detects attempts
to overwrite local changes and enables users to intervene
and interactively handle the problem. It can be seamlessly
integrated with our approach to incremental model slicing.
IV. I MPLEMENTATION
This section outlines the implementation of our approach,
focusing on the server-side functionality for determining an
extended model element set, and for generating slice-creating
and slice-adapting edit scripts. We start by brieÔ¨Çy recalling
some basic background on consistency-preserving edit scripts.
A. Consistency-preserving Edit Scripts
Our approach uses consistency-preserving edit scripts [8]
as a special form of model patches. An edit script M1)M 2
obtained comparing two models M1andM2is a data struc-
ture which basically comprises a set of edit steps semiordered
by an acyclic dependency graph in which the nodes are edit
steps and the edges are dependencies between edit steps [8].
Applying M1)M 2toM1yieldsM2. An edit step is an edit
operation supplied with concrete arguments.
In our approach, edit operations are formally deÔ¨Åned as
in-place transformation rules on the ASG using the Henshin
model transformation language and system [10], [11]. Edit
operations must be consistency-preserving (CPEOs) in the
sense that they transform a model from one consistent state
to another. Consequently, an edit script based on CPEOs
constructs a consistent model.
Each modeling language has its own set of CPEOs; we
generate such a set from a meta-model using the (meta-)tool
presented in [6], [12]. The meta-models we actually use reÔ¨Çect
the actual consistency constraints enforced by the standard
editor of an environment, they are referred to as effective
meta-model. The effective meta-model differs from a ‚Äúperfect‚Äù
meta-model as deÔ¨Åned in language standards such as the UML
by removing many complex constraints, while all basic typing
constraints and many multiplicities remain. Some multiplicity
constraints may even be added [6]. For example, the effective
meta-model of the UML modeling tool Papyrus enforces all
multiplicity constraints shown in Figure 2. It tightens the
multiplicities [0..1] for sendEvent andreceiveEventto [1..1] since a Message must always have a send and
a receive end to be graphically displayable. Due to such
multiplicity constraints, CPEOs typically create (or delete)
several ASG nodes and related references as one inseparable
graph fragment. For example, a message is created (deleted)
together with its message ends.
A CPEO set Rgenerated by our generator [6] is complete in
the sense that every consistent model Mof the DSML deÔ¨Åned
by the input meta-model can be constructed, starting from the
empty model , by using creation CPEOs in R. A creation
CPEO is speciÔ¨Åed by a rule which creates ASG elements only.
Conversely, every consistent model Mcan be reduced to the
empty model by using deletion CPEOs available in R.
For every creation CPEO rthere is an inverse deletion
CPEOr 1such that, for every consistent model Mof
the given modeling language, applying the editing sequence
hr;r 1iyieldsMagain.
B. Generating an Slice-Creating Edit Script
For the sake of didactics, the pseudo-code for creating a
slice in Section I has suggested that, for a given set RME,
extRME is computed Ô¨Årst and then used to create the slice.
Our approach actually reverses this order. The basic idea is to
consider the large model Las created by an edit script )L
applied to an empty model and to identify a subset of )L
which creates all elements of RME. This subset is constructed
as follows:
(1) An edit script )L is created by comparing Lwith
the empty model . This script contains only edit steps which
create ASG fragments, i.e., each edit step refers to a creation
CPEO. As long as the large model Lremains unchanged,
this edit script can be cached on the server to avoid its re-
calculation for every client request.
(2) We identify the set ESRME of edit steps in )L which
create at least one requested model element. Model elements
appear as arguments in edit steps and can be easily found in
)L. The ASG fragment created by an edit step can contain
further elements not contained in RME.
(3) We determine the set ESpreRME of all edit steps in
)L on which at least one edit step of ESRME is directly
or indirectly dependent, i.e., which must precede the edit steps
inESRME .
Our edit script )S)L consists of the edit steps
ESRME andESpreRME identiÔ¨Åed in steps (2) and (3).
More formally, this edit script consists of the subgraph of the
dependency graph of )L containing all nodes of ESRME
and all required nodes and connecting edges according the
transitive closure of the ‚Äúrequired‚Äù relation, which is implied
by dependencies between edit steps.
)S creates, if applied to , a slice containing at least
all elements of RME, but actually more elements, namely
extRME. extRME is thus derived from )S, it is implicitly
computed together with )S.
C. Generating a Slice-adapting Edit Script
If an existing slice Sshall be adapted according to an op-
eration invocation S.incrAdapt(addRME, remRME), s.
916
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:30:50 UTC from IEEE Xplore.  Restrictions apply. Fig. 5. Graphical user interface of the SiLift slicing environment.
Section II-C, the adapting edit script S)S0is constructed as
follows. The sets ESRMEold andESpreRMEold of edit steps,
which create extend(RME old), are assumed to be still avail-
able. For RMEnew, the setsERMEnew andESpreRMEnew are
computed analoguously. Let
‚ÄìESextend(RME old)=ESRMEold[ESpreRMEold
‚ÄìESextend(RME new)=ESRMEnew[ESpreRMEnew
‚ÄìESrem=ESextend(RME old)nESextend(RME new)
‚ÄìESadd=ESextend(RME new)nESextend(RME old)
The edit script S)S0contains two sets of edit steps: (1)
the edit steps in set ESadd, with the same dependencies as in
)L, (2) for each edit step es2ESrem, its inverse edit step
es 1, with reversed dependencies as in )L. By deÔ¨Ånition,
there cannot be dependencies between edit steps in both sets,
so they can be executed in arbitrary order.
V. C ASE STUDY
In this section we demonstrate the usage of our slicer
using the running example introduced in Section II-A. The
implementation is based on the Eclipse Modeling technology
stack and re-uses the differencing and patching facilities of the
SiLift model versioning framework [8], [9], [13]. A download
option and a screencast of the demonstrated scenarios are
provided at the accompanying website [14].
A. Scenario 1: Retrieving a Fresh Slice from a Repository
The set RME can be speciÔ¨Åed in our tool with a tree-based
model browser, which is shown on the right-hand side of
Figure 5 and which operates on the server-side data. In the
Ô¨Årst scenario, we initially want the slice to contain the upper
region of the state machine PSCSystem (s. Figure 1). We
select the elements <State Machine> SM-PSCSystem,
<Region> Region1 and all of its children (s. Figure 5,
red label ‚Äú1‚Äù). Next, we create the slice by applying the
synchronization button in the toolbar (s. Figure 5, black label
‚Äú2‚Äù). The resulting edit script is opened in the interactive patch
view of SiLift [9] (s. left-hand side of Figure 5) and can be
applied onto the local UML model resource which is openedin the editor (s. center of Figure 5). Furthermore, the model
browser selects and highlights all implicitly added model ele-
ments created by the edit script (s. Figure 5, yellow label ‚Äú3‚Äù),
i.e. all model elements in extRMEnRME. In this scenario
several CallEvents are added. Each event references an
Operation of the class <Class> PSCSystem, thus the
class and its respective operations are also added to the slice
(not shown in the visible part of the model browser of Figure 5,
but in the editor window in the center; black label ‚Äú4‚Äù).
B. Scenario 2: Extending an UnmodiÔ¨Åed Slice
To extend our initial slice, we can select further ele-
ments in the model browser and synchronize our local model
again. A new edit script is calculated which contains only
the edit steps creating the additional selected elements (and
potentially further edit steps on which these edit steps de-
pend). For instance, selecting the subtree rooted at the ele-
ment <Region> Region2 of the state machine <State
Machine> SM-PSCSystem extends the statemachine such
that we obtain the state machine shown in Figure 1.
C. Scenario 3: Reducing an UnmodiÔ¨Åed Slice
We can also reduce our slice by deselecting elements in the
model browser. For instance, to revert our last modiÔ¨Åcation,
we can simply deselect the region <Region> Region2
including all of its children. As explained in Section III-C, de-
selected elements will not be deleted if they are still implicitly
selected. For instance, this is the case if we want to remove the
Operation authFSC() of the Class PSCSystem from
RME. Here, the Trigger of the Transition between the
states S.1.1.0 andS.1.1.1 still refers to that operation
via a CallEvent. Consequently, authFSC() can only be
removed together with the Trigger. This can be achieved
by explicitly deselecting the Trigger.
D. Scenario 4: Extending an Edited Slice
Scenario 4 assumes that the slice was edited as follows:
We add a new Operation reqComFSC(in severity:
917
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:30:50 UTC from IEEE Xplore.  Restrictions apply. Integer) in the Class PSCSystem. After that, we change
the reference operation of the CallEvent referred by the
Trigger of the Transition between the states Idle and
Authorising (cf. Figure 1). Subsequently, we remove the
Operation authFSC() for the respective Class.
After this, we want to extend our modiÔ¨Åed slice by
the sequence diagram shown in Figure 1. The application
of the edit operation creating the message reqComPSC
between the lifelines fscSystem: FSCSystem and
pscSystem: PSCSystem would fail now due to the miss-
ing input parameter value signature: Operation =
"PSCSystem.reqComFSC()". Here, we can exploit the
interactive workspace update facility of SiLift [9] by bind-
ing the new Operation reqComFSC(in severity:
Integer as parameter value. After that, the edit operation
can be successfully applied onto the modiÔ¨Åed local slice.
VI. R ELATED WORK
As already mentioned in the introduction, most existing
work on model slicing [3], [4], [15]‚Äì[17] focuses on the
selection step of the overall slicing process; the second step,
i.e., producing a new model which contains the selected
elements, has been only superÔ¨Åcially addressed or neglected
completely.
Exceptions of this are Kompren [5], which we already
discussed in the introduction, and the work of Debreceni et
al. [18], an approach for extracting view models from a larger
source model using a query language based on EMF-IncQuery.
Views are incrementally updated in response to changes in the
source model. Editing of the view model is not supported. As
with Kompren, the developer is responsible to guarantee that
the result of a user-deÔ¨Åned query is actually an editable sub-
model.
The extraction of consistent sub-models from larger models
has been addressed in the Ô¨Åeld of model decomposition, e.g.,
by the techniques presented in [19], [20]. However, they use
a Ô¨Åxed notion of consistency and cannot be adapted to a
modeling environment.
A model slicing approach which appears to work incre-
mentally is presented in [21] in the context of testing model-
based delta-oriented software product lines. However, their
notion of incrementality is different from ours. Rather than
incrementally adapting an extracted sub-model, the approach
incrementally processes the product space of a product line.
As in software regression testing, the goal is to obtain retest
information by utilizing differences between state machine
slices.
VII. C ONCLUSION
In this paper, we presented a novel model slicer support-
ing the generation of autonomous sub-models from a given
larger model. It automatically conÔ¨Ågures itself by exploiting
existing conÔ¨Åguration data of a modeling environment, and
has the following distinguishing features; (i) it guarantees
that extracted sub-models are editable in standard (visual)
editors of that modeling environment, and (ii) it is capable ofincrementally adapting edited slices. In our demo, we speciÔ¨Åed
a set of model elements to be contained in the slice using
an interactive repository browser. An interesting direction for
future work is to integrate our slicer with a graph query
processor or a dedicated processor for slicing criteria, which
are complementary to our approach.
ACKNOWLEDGMENTS
This work was partially supported by the DFG (German
Research Foundation) under the Priority Programme SPP1593:
Design For Future ‚Äì Managed Software Evolution.
REFERENCES
[1] M. Weiser, ‚ÄúProgram slicing,‚Äù in Proc. of ICSE‚Äô81. IEEE Press, 1981.
[2] B. Xu, J. Qian, X. Zhang, Z. Wu, and L. Chen, ‚ÄúA brief survey of
program slicing,‚Äù ACM SIGSOFT Softw. Eng. Notes, vol. 30, no. 2,
2005.
[3] K. Androutsopoulos, D. Clark, M. Harman, J. Krinke, and L. Tratt,
‚ÄúState-based model slicing: A survey,‚Äù ACM Computing Surveys, vol. 45,
no. 4, 2013.
[4] T. Gerlitz and S. Kowalewski, ‚ÄúFlow sensitive slicing for mat-
lab/simulink models,‚Äù in Proc. of WICSA‚Äô16. IEEE, 2016.
[5] A. Blouin, B. Combemale, B. Baudry, and O. Beaudoux, ‚ÄúKompren:
modeling and generating model slicers,‚Äù Springer SoSyM, vol. 14, no. 1,
2015.
[6] T. Kehrer, G. Taentzer, M. Rindt, and U. Kelter, ‚ÄúAutomatically deriving
the speciÔ¨Åcation of model editing operations from meta-models,‚Äù in
Proc. of ICMT‚Äô16. Springer, 2016.
[7] A. Capozucca, B. Cheng, N. GuelÔ¨Å, and P. Istoan, ‚ÄúOO-SPL modelling
of the focused case study,‚Äù in CMA @ MoDELS‚Äô11, 2011.
[8] T. Kehrer, U. Kelter, and G. Taentzer, ‚ÄúConsistency-preserving edit
scripts in model versioning,‚Äù in Proc. of ASE‚Äô13. IEEE, 2013.
[9] T. Kehrer, U. Kelter, and D. Reuling, ‚ÄúWorkspace updates of visual
models,‚Äù in Proc. of ASE‚Äô14. ACM, 2014.
[10] T. Arendt, E. Biermann, S. Jurack, C. Krause, and G. Taentzer, ‚ÄúHenshin:
advanced concepts and tools for in-place emf model transformations,‚Äù
inProc. of MoDELS‚Äô10. Springer, 2010.
[11] D. Str ¬®uber, K. Born, K. D. Gill, R. Groner, T. Kehrer, M. Ohrndorf,
and M. Tichy, ‚ÄúHenshin: A usability-focused framework for emf model
transformation development,‚Äù in Proc. of ICGT‚Äô17, 2017.
[12] M. Rindt, T. Kehrer, and U. Kelter, ‚ÄúAutomatic generation of
consistency-preserving edit operations for MDE tools,‚Äù in Demos @
MoDELS‚Äô14, ser. CEUR Workshop Proceedings, vol. 1255, 2014.
[13] T. Kehrer, U. Kelter, M. Ohrndorf, and T. Sollbach, ‚ÄúUnderstanding
model evolution through semantically lifting model differences with
silift,‚Äù in Proc. of ICSM‚Äô12. IEEE Computer Society, 2012.
[14] U. of Siegen, Software Engineering Group, ‚ÄúIncremental Slicer -
Tool Demonstration and Update Site,‚Äù 2017. [Online]. Available:
http://pi.informatik.uni-siegen.de/projects/SiLift/ase2017/index.php
[15] H. Kagdi, J. I. Maletic, and A. Sutton, ‚ÄúContext-free slicing of uml class
models,‚Äù in Proc. of ICSM‚Äô05. IEEE, 2005.
[16] J. T. Lallchandani and R. Mall, ‚ÄúA dynamic slicing technique for uml
architectural models,‚Äù IEEE Trans. Softw. Eng., vol. 37, no. 6, 2011.
[17] S. Nejati, M. Sabetzadeh, D. Falessi, L. Briand, and T. Coq, ‚ÄúA sysml-
based approach to traceability management and design slicing in support
of safety certiÔ¨Åcation: Framework, tool support, and case studies,‚Äù
Information and Software Technology, vol. 54, no. 6, pp. 569‚Äì590, 2012.
[18] C. Debreceni, ¬¥A. Horv ¬¥ath, ¬¥A. Heged ¬®us, Z. Ujhelyi, I. R ¬¥ath, and
D. Varr ¬¥o, ‚ÄúQuery-driven incremental synchronization of view models,‚Äù
inProceedings of the 2nd Workshop on View-Based, Aspect-Oriented
and Orthographic Software Modelling. ACM, 2014, p. 31.
[19] Q. Ma, P. Kelsen, and C. Glodt, ‚ÄúA generic model decomposition
technique and its application to the eclipse modeling framework,‚Äù
Springer SoSyM, vol. 14, no. 2, 2015.
[20] B. Carr ¬¥e, G. Vanwormhoudt, and O. Caron, ‚ÄúFrom subsets of model
elements to submodels,‚Äù Springer SoSyM, vol. 14, no. 2, pp. 861‚Äì887,
2015.
[21] S. Lity, T. Morbach, T. Th ¬®um, and I. Schaefer, ‚ÄúApplying incremental
model slicing to product-line regression testing,‚Äù in Intl Conf. on
Software Reuse. Springer, 2016.
918
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:30:50 UTC from IEEE Xplore.  Restrictions apply. 