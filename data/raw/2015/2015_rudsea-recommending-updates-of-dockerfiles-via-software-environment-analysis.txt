RUDSEA: Recommending Updates of Dockerfiles via Software
Environment Analysis
Foyzul Hassan
University of Texas at San Antonio
USA
foyzul.hassan@utsa.eduRodney Rodriguez
University of Texas at San Antonio
USA
rodney.rodriguez@utsa.eduXiaoyin Wang
University of Texas at San Antonio
USA
xiaoyin.wang@utsa.edu
ABSTRACT
Dockerfiles are configuration files of docker images which pack-
agealldependenciesofasoftwaretoenableconvenientsoftware
deployment and porting. In other words, dockerfiles list all envi-
ronment assumptions of a software application’s build and / orexecution, so they need to be frequently updated when the envi-ronment assumptions change during fast software evolution. In
thispaper, weproposeRUDSEA, anovelapproach torecommend
updates of dockerfiles to developers based on analyzing changes
on software environment assumptions and their impacts. Our eval-
uationon1,199real-worldinstructionupdatesshowsthatRUDSEA
canrecommendcorrectupdatelocationsfor78.5%oftheupdates,
and correct code changes for 44.1% of the updates.
CCS CONCEPTS
•Software and its engineering;
KEYWORDS
Dockerfiles, Software Environment, String Analysis
ACM Reference Format:
Foyzul Hassan, Rodney Rodriguez, and Xiaoyin Wang. 2018. RUDSEA: Rec-
ommending Updates of Dockerfiles via Software Environment Analysis. In
Proceedingsofthe201833rdACM/IEEEInternationalConferenceonAutomated
Software Engineering (ASE ’18), September 3–7, 2018, Montpellier, France.
ACM,NewYork,NY,USA, 6pages.https://doi.org/10.1145/3238147.3240470
1 INTRODUCTION
Modern software often depends on a large variety of environment
dependencies to be properly deployed and operated on production
machines. Databases, application servers, system tools, and sup-
portingfilesoftenneedtobewellinstalledandconfiguredbefore
software execution, and thus may cause tremendous effort andhigh risks during software deployment. This is not one-time butcontinuous cost due to the fast software evolution and delivery
nowadays.
A practical approach to alleviate this effort is to use container
images.Acontainerimageisastand-aloneandexecutablepackage
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ’18, September 3–7, 2018, Montpellier, France
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.3240470ofapieceofsoftwarewithallitsenvironmentdependencies,includ-
ingcode,runtime,systemtools,libraries,filestructures,settings,
etc.Itcanbeeasilyportedanddeployedtoothermachines,butis
muchlighter-weightthantraditionalvirtualmachineswhichcan
achieve similar goals.
Despite the large benefit brought by container images during
software deployment,they alsoincrease theeffort ofsoftware de-
velopers because they need to generate and maintain the image
configurationfileswhichdescribehowthecontainerimagescan
beconstructedwithallenvironmentdependencies,suchaswhat
tools and libraries should be installed and how the file structure
should be set up. A recently study [ 7] on Dockerfiles by Cito et
al. shows that in top projects a docker file is averagely revised 5.8
times each year (note that there can be multiple dockerfiles in one
project, and the average and maximum number ofdockerfiles per
project in our dataset is 4.9 and 41). Such a task can be tediousand error prone because (1) modern software typically relies on
many environment dependencies, and due to fast evolution of soft-
warerequirementsandunderlyingframeworks,suchdependencies
also need to be changed very frequently; (2) some environment
changes(e.g.,automaticsystemupdates,environmentchangesdur-
ing installation of irrelevant software) can happen without any
developeractionssodevelopersmayevennotbeawareaboutthem;
(3)developerscaneasilyneglectenvironmentdependenciesoftheir
software when they set up or change them because the changes
aremadeintheoperatingsysteminsteadofthesoftwareitself;and
(4) many environment dependencies (e.g., system tools, supporting
files)cannotbecheckedduringsoftwarecompilationbutonlyused
at runtime, so they can be easily missed during compilation andtesting (which is hardly thorough). Once an incomplete or erro-
neousimageconfigurationfileisbeingused,thecontainerimage
willalsobeincompleteorcontainserrors,whichmaycausefailures
in production machines.
Inthispaper,weproposeanoveltechnique,RUDSEA,tohelpde-
veloper update container image configuration files more easily and
withmoreconfidenceontheircorrectness.Specifically,basedonan
existingimagecontainerfile,RUDSEAfirsttrackstheaccessesto
the system environment from software source code and build con-
figurationfiles. Suchaccesses areextracted asenvironment-relatedcodescope.Then,foreachcodecommit,RUDSEAtracesitsimpact
onenvironment-related codescope andautomatically determines
whether certain items in the image configuration file should be
updated accordingly. Based on the type of code impact and con-
figuration items, RUDSEA further recommends the actual updates
thatshould bemade onthe items.Weimplementour techniqueforDocker
1,whichiscurrentlythedominatingframeworkincontainer
1https://www.docker.com/
796
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:27:29 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Foyzul Hassan, Rodney Rodriguez, and Xiaoyin Wang
imagesforbothsoftwareindustryandopensourcecommunity,and
theimageconfigurationfilesfordockerarecalled dockerfiles.Notef
that, although the implementation and evaluation of this research
focus on docker images and dockerfiles, the general approach is
applicable to other container images such as Kubernetes, OCI, etc.
ToevaluateRUDSEA,wecarriedoutanexperimentonadataset
of 375 dockerfiles in 40 software projects collected from GitHub.
Our evaluation shows that RUDSEA correctly recommends update
locations for 941 of 1,199 instruction updates in dockerfiles, with a
precisionof49.8%.Furthermore,RUDSEAisabletocorrectlyrec-
ommend the actual revision for 529 of the 1,199 dockerfile updates.
To sum up, this paper makes the following contributions.
•RUDSEA,anoveltechniqueonautomaticallyrecommendingupdatelocationsandcontentsfordockerfilesduringsoftware
evolution.
•Adatasetofdockerfilesandtheircorrespondinghistorical
versions as benchmarks for future research on this topic.
•An empirical evaluation of RUDSEA’s effectiveness on real
world dockerfiles.
Therestofthispaperisorganizedasfollows.First,wewillintro-
ducesomebackgroundknowledgeaboutdockerfilesinSection2.
Then, we describe our approach and detailed techniques in Section
3. After we present our evaluation results in Section 4, we discuss
some related works in Section 5 and concludes in Section 6.
2 BACKGROUND
In this section, we will introduce some background knowledge
about dockerfiles. A dockerfile typically consists of three parts.
The first part (From ) specifies an existing container image that the
configured image is based upon. Some examples of existing images
mayincludeacleanUbuntusystemofacertainversion,orapublicly
available image prepared with Java, Android SDK and databases.
Thesecondpart(ParserDirectives )describesrulessuchasescape
characters on parsing the rest of the dockerfile, and is optional.
Thethirdpart(EnvironmentReplacements )isthemainpartofthe
dockerfile,anddescribeshowtheimageshouldbeconstructedwith
a sequence of instructions. The major types of instructions are
listed below.
•RUN & WORKDIR : executing a system command or exe-
cutablewithintheworkingdirectoryspecifiedby WORKDIR.
•CMD & ENTRYPOINT : setting the default command (CMD )
tobeexecutedandarguments(ENTRYPOINT )tobeusewhen
executing the container image.
•LABEL:Settingenvironmentvariablesinthecontainerim-
age.
•EXPOSE: exposing a network port in the container image.
•ENV:definingavariabletobeusedintherestofthedocker-
file.
•ADD / COPY : add a new directory / file in the file system of
thecontainerimage,andcopydirectories/filesfromhosting
system to the image.
From the list, we can see that three types of instructions will
beupdatedfrequentlyduringsoftwareevolution,whichare RUN
instructions(updatingversionsoftools/librariestobeinstalled),
Labelinstructions (updating environment variables), and Add /
COPYinstructions(changingdefaultfilestructures).Bycontrast,other instructions are either typically stable (e.g., EXPOSE, CMD
& ENTRYPOINT ) or used only in the dockerfile itself (e.g., ENV).
Therefore,ourpaperfocusesontheupdatesof RUN,LABEL,and
ADD / COPY instructions.
3 APPROACH
As shown in Figure 1, our approach consists of two major compo-
nents. The first component extracts software code that is relatedto the items in dockerfiles. Here the software code base includes
sourcefiles,buildconfigurationfiles,andpropertyfiles.Thecore
part of this component is value dependency analysis, and we ap-
plyittobotholdandnewversionstoacquiretheresultsforboth
versions. The second component receives the analysis results of
two code versions and generates the actual updates. It leverages
changeimpactanalysistodeterminewhetherthecodechangemay
affect the environment-related code, and equivalence analysis to
check whether new code is added as the equivalent part of known
environment-related code.
3.1 Extracting Environment-related Code
Scope
The major challenge of extracting environment-related code is
thecomplicatedinterfacebetweensoftwareanditsenvironment.
While software libraries and their versions are typically listed in
build configuration files (e.g., makefile for GNU Make, pom.xml
for Maven, build.gradle for Gradle), references to file paths and
environment variables are often scattered in source code, build
configuration files, property files, etc. A thorough definition of all
possibleenvironmentinterfacesrequireshugemanualeffort,and
the definitioncan easily be out-of-date dueto quick evolution of
theunderlying development frameworks, buildconfigurationtools,
and their various plug-ins.
Toovercomethischallenge,RUDSEAusesadifferentsolution.
Ourintuitionisthat,alltheenvironmentrelatedcode,nomatter
howtheyinterfacewithenvironment,mustrefertothevaluesin
theitemsofdockerfiles.Notethathereweassumethattheoriginal
versionofthedockerfileisacorrectone.Simplyput,wecansearch
forthevaluesfromdockerfileitemsintheconstantstringvaluesin
various source files, since such values must be used when software
interfaces with the environment.
However,asimplekeywordsearchdoesnotwork,becausedevel-
opers frequently use string concatenations and value assignments
to generate runtime values from the string constants. For example,
the dockerfile may refer to a file path /home/project-name/foo/bar ,
whileinthesourcecode,thefilepathmaybeastringconcatenation
expressionsuchas "/home/" + project + "/" + module + "/bar/" ,
whereprojectandmodulearevariablesforflexibilityofchanging
sub-projectsandmodules.Insuchcases,theoriginalvalueswillnotbedetectablewithsimplekeywordsearch,butstringconcatenations
and assignmentsneed tobe considered.In our initialimplementa-
tionofRUDSEA,weconsideronlystringconcatenations,aswefind
thatotherstringoperationsarerarelyusedingeneratinglibrary
names, file paths, and environment variable values.
Therefore,RUDSEAusesatwo-stageapproach,whichfirstlo-
cates the initial string constants which are long enough substrings
of a dockerfile item. Then, RUDSEA performs value dependency
797
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:27:29 UTC from IEEE Xplore.  Restrictions apply. RUDSEA: Recommending Updates of Dockerfiles ASE ’18, September 3–7, 2018, Montpellier, France
Environment Code 
Extraction
Old Code 
VersionEnvironment-related 
Code ScopesNew Code 
Version
Change Impact 
Analysis
Equivalence 
AnalysisDockerfile 
Item UpdatesDockerfile
Items
Figure 1: RUDSEA Overview
analysis to compute additional values through manipulating these
initial string constants. As our analysis is light weight, we need
onlyaparserandknownstringconcatenationfunctions(whichare
typically only several, and very similar among all programming
languages)foreachprogramminglanguageusedinthesoftware
project.
3.1.1 Locating Initial String Constants. The first step of locating
initial string constants is to extract dockerfile item values from
dockerfiles.Toachievethis,weuseadockerfileparsertoextractallargumentvaluesof RUN,Label,and Add/COPY instructions.Since
RUNinstructionsoftentakeLinuxutilitycommands(e.g., mkdir,
apk-get install ) as their parameters, and such commands are not
necessarilyreferredinthesoftwarecodebase,wefilteroutallsuch
commands from dockerfile item values.
After collectingthe list ofdockerfile item values,RUDSEA ex-
tracts all string constants from the software code base, and verifies
whethertheirlengthisover3andisasubstringofanydockerfile
itemvalues.Ifso,thestringconstantisaddedtothesetofinitial
stringconstants.Inparticular,givenastringconstant str,andaset
of dockerfile item values D, Formula 1 presents a boolean function
envwhichcheckswhether strisaninitialstringconstant.Inthe
rest of the paper, the set of initial string constant is denoted as Init.
env(str)=len(str)≥3∧∃d∈D,d.contains(str)(1)
In the formula, we use len(x)to represent the length of string
x, andx.contains(y)to represent string yis a substring of x.W e
will use this check function also in our value dependency analysis
tomaketheabstractdomainbounded.Basedontheinitialstring
constants, RUDSEA performs value dependency analysis which
checks how string constants are combined with each other to form
more values, and tracks the string manipulation process.
3.1.2 Value Dependency Analysis. The value dependency analysis
inRUDSEAisastaticanalysisonstringconcatenationsandassign-
mentswithinthesoftwarecodebase.Valuedependencyanalysis
usesanabstractdomain <Γ,T>.Γisasetofmappingsfromthe
set of string variables Vin the software code base, to sets of string
values generated from the set of string constants ( S) in the code
base. Specifically, Γis defined in formula 2.
Γ={var→L|var∈V∧L⊂S∗} (2)
Foreachvaluein L,wealsotrackthelocationsofstringconstants
thatformeachvaluein T,sobasically Tisamappingfromastring
value inLto a set of program points.Why RUDSEA does not use automatons to represent string
values?In our value dependency analysis, to track string concate-
nations and assignments, we use a string set domain instead of an
automatonasinstringtaintanalysis[ 22]fortworeasonsasfollows.
First, string taint analysis (and also the original string analysis [ 5])
usestheMohri-Nederhofalgorithmtohandlestronglyconnected
components in string dependencies, and generates an approximate
automaton, which isa slow process and typicallyresultsin over-
approximation and affect analysis accuracy. Second, in string taint
analysis,thetracingfromoriginalstringconstantstothefinalstring
values is at character level, which makes it difficult to propagate
updates from original string constants to the final string values.
Despite the accuracy, efficiency, and straightforward tracing
providedbythestringvaluesetdomain,itsmajordrawback(and
why it cannot be used in general string analysis) is that it is not
bounded.Whenastringvariableiswrittenwithinanunbounded
looporrecursivemethod,thepossiblevaluesofthevariablecanbe
infinite.
In the specific application scenario of RUDSEA, we find that
thisproblemcanbesolved.Ourideaistousethe envfunctionto
bound the string value set in our domain. The intuition is that, if a
possiblevalueofastringvariabledoesnotsatisfy envfunction,it
will not be a reference to dockerfile item values, and thus can be
discarded. Therefore, given that dockerfile item values are finite,
allstringvaluesinourabstractdomainwillbeperfectlybounded
(withoutanyaccuracylossregardingreferencetodockerfiles)by
the dockerfile item values through envfunction. In particular, the
transfer functions of value dependency analysis on string initial-
ization,stringassignments,andstringconcatenationsaredefined
in
Once value dependency analysis converges at a fixed point, we
can tell for each variable, what are its possible values (satisfying
envfunctions) and the original string constants and string con-
catenations used in forming each value. If a string variable var
containsavalue valthatisidenticalwithanydockerfileitemvalue,
we will consider varand all the statements used in forming val
asintheenvironment-relatedcodescope.Specifically,wedenote
all the dockerfile item values generated from software code base
withvaluedependencyanalysisas Gen,andGenisformallydefined
inFormula3.Recallthat Disthesetofalldockerfileitemvalues
extracted from the dockerfiles.
Gen=/uniondisplay.1
var∈VΓ(var)∩D (3)
798
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:27:29 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Foyzul Hassan, Rodney Rodriguez, and Xiaoyin Wang
Then the environment-related code scope can be formally de-
fined as in Formula 4. Recall that Tis a part of our abstraction
domain which maps any string value in Γto program points in-
volvedingeneratingthevalue. GenandTwillbefurtherusedin
our Dockerfile change generation stage.
Scope =/uniondisplay.1
val∈GenT(val) (4)
3.2 Dockerfile Change Generation
Givenanewsoftwareversion,RUDSEA’sdockerfilechangeanal-
ysis tries to find out what updates on the code will affect items
indockerfiles.NotethatRUDSEAdoesnottakesinglecodecom-
mit as its input, because dockerfiles are often not updated until
a new release so there may be many code commits in between.
Environmentchangeanalysisincludethechangeimpactanalysis
whichexamineswhetherknownenvironment-relatedcodescope
willbeaffectedbythechanges,andtheequivalenceanalysiswhich
examines whether a new environment-related code scope is added.
3.2.1 Change Impact Analysis. Inthechangeimpactanalysis,RUD-
SEAwillperformvaluedependencyanalysisonthenewversion
of the software, and map the analysis results (string constants and
statements involving string concatenations / assignments) with
that from the original version with a file difference tool. In the rest
of this section, we denote Gen,T, andScopegenerated from the
value dependency analysis on the original version as Genold,Told,
andScopeold,while thecorresponding resultson thenewversion
asGennew,Tnew, andScopenew. We further define the set of vari-
ables that has at least one possible value in GenasGvar. We refer
to such variables as docker variables. Similarly, we have Gvarold
andGvarnew. Note that Gvaris formally defined in Formula 5.
Gvar ={var|var∈V∧Γ(var)∩Gen/nequal∅} (5)
Theintuitiveassumptionbehindourchangeimpactanalysisisas
follows. If a variable varhas a dockerfile item value in its possible
valueset Γ(var)(i.e.,varisadockervariable),itislikelytobeused
for environment interfacing. Therefore, if it holds a different set
of values in the new version, the new set of values are likely to be
also usedfor environment interfacingand should be added tothe
dockerfile.Furthermore,ifadockervariableisdeletedinthenew
version, thecorresponding dockerfile item value mayalso need to
bedeletedifnootherdockervariablesholdthesamevalueinthe
new version.
Asan example,consider avariable varhavinga possiblevalue
"/home/foo/bar" in the old version, and the value is a dockerfile
item value. In the new version, if the same variable has a possi-ble value
"/home/foo/bar2" , then it is likely that we should add
"/home/foo/bar2" to dockerfiles. In particular, if "/home/foo/
bar"is no longer in Γnew(var), we should replace "/home/foo/
bar"with"/home/foo/bar2" .If"/home/foo/bar" isstillin Γnew(var),
weshouldinsertanewinstructionthatperformsexactthesameop-
eration on "/home/foo/bar2" as on"/home/foo/bar" . If the variable
varisdeletedinthenewversion,andnootherdockervariableshas
"/home/foo/bar" in its possible values, the value should be deleted
from the dockerfile.Acomplicationinthisprocessiswhenaolddockervariable( var
inGvarold)holdsmultiplevaluesin Genold,orholdothervalues
thatarenotin Genold.Insuchcases,whenthepossiblevaluesof
varcontainssomenewvalueinthenewversion,itishardtotell
whicholdvaluethisnewvalueisreplacingorcomplementing.Our
solution is to compare their forming process stored in T. Given
a new value newvinΓnew(var), we compare Tnew(newv)with
each of the old values oldvinΓold(var), and map this new value
to an old value oldvwhose forming process Told(oldv)is most
similarto Tnew(newv).Specifically,wemeasuresimilaritybythe
size common program points between Told(oldv)andTnew(newv).
3.2.2 Equivalence Analysis. Whilechangeimpactanalysisisable
to recommend dockerfile updates related to existing dockerfile
item values. There are also other cases where a new environment
dependencyisadded.RUDSEAneedstoalsodetectthosecasesand
find out where the insertions need to be made.
Tosolvethisissue,wedevelopequivalenceanalysiswhichchecks
whichtwoprogrampointshavesimilarusageintheprogram.They
are considered equivalent program points. In our analysis, we con-
sider similar code inside one basic block or in different alternative
blocks (i.e., basic blocks within the same level in a conditional
statement).Examplesofalternativeblocksare ifandelseblocks
withinoneconditionalstatement,or caseblockswithinoneswitch
statement.
The intuition behind equivalence analysis is that if a writing
statement to a string variable equivis inserted as a equivalent
program point of a writing statement swhich writes to a docker
variablevarwith dockerfile item value val, the inserted writing
statement will be considered as a new docker variable, and its
possible values will be recommended for insertion into dockerfiles.
Foreachpossiblevalueof equiv,RUDSEArecommendsaninsertion
of a new instruction that performs exact the same operation on
equivas onval.
3.3 Implementation
We implemented the value dependency analysis of RUDSEA for
Java, PHP, and Gradle. To support Maven, simple property files,
andXMLpropertyfiles,wefurtherconvertalldependenciesand
propertydefinitioninsuchfilesasstringconstantassignments(i.e.,
assignmentofpropertyvaluetopropertyname,anddependency
valuestoaspecialvariable“dependency”),thustheycanbehandled
by the dockerfile-update generation component of RUDSEA.
4 EVALUATION
To evaluate the effectiveness of RUDSEA, we carried out an experi-
ment on a set of software projects with dockerfiles, and used their
version histories as ground truth to check how accurate RUDSEA’s
recommendation is. Specifically, we try to answer the following
two research questions.
•RQ1:HoweffectiveisRUDSEAonrecommendingupdate
locations in Dockerfiles?
•RQ2:HoweffectiveisRUDSEA onrecommendingupdates
in Dockerfiles?
•RQ3:WhatarethemajorreasonscausingRUDSEAtofail
on recommending correct updates?
799
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:27:29 UTC from IEEE Xplore.  Restrictions apply. RUDSEA: Recommending Updates of Dockerfiles ASE ’18, September 3–7, 2018, Montpellier, France
In the rest of this section, we introduce the dataset construction,
evaluation metrics, evaluation results, and threats to validity in the
following four subsections, respectively.
4.1 Dataset of Dockerfiles
WecollectedasetofDocker-usingopensourceprojectsinGithub2.
In particular, we searched through top Java and PHP projects by
numberofstarsandcheckwhethertheprojectcontainsdockerfiles.
Ifso,weaddedtheprojectintoourdataset.Westoppedafterwecol-
lected 20 PHP projects and 20 Java projects. Then, we checked thehistory of the dockerfiles in these projects. In some projects, dock-
erfiles have their own repository, so we gathered the dockerfilesfrom there. In some other projects, dockerfiles are attached with
eachrelease(sotheydonothaveaversionhistory),wecollected
all dockerfiles from all releases so that they form a version history.
From the version history of dockerfiles, we used diff to generate
ground truth updates of dockerfiles. We further removed all inter-
nal updates of dockerfiles (e.g., updates of comments, refactorings).
Finally,weacquiredadatasetof375externalupdatesofdockerfiles,eachofwhichcanbeascribedtooneormoreupdatesinthesource
code and / or build configuration files. In our evaluation, we usethe updates in the source code and / or build configuration filesas input, and the corresponding dockerfile updates as output. It
should be noted that each update may involve multiple instruction
updates.Intotal,thedockerfileupdatesinclude1,199instruction
insertions, revisions, and deletions.
One question should be studied is how large the dockerfiles
are,sothatwecanseehowdifficulttheupdatelocalizationis.To
answer this question, we further performed an empirical studyon our dataset. In the 40 Java and PHP projects, there are 197
dockerfilesintotal.Thenumberofdockerfilesinasingleproject
ranges from 1 to 41, and the average number is 4.9. The numberofvalidlines(excludingblankandcommentlines)indockerfiles
varies from 1 to 64 lines, and the average is 28 lines. Since there
are oftenmultiple dockerfiles inone project, theaverage number
of dockerfile lines in a project is 137 lines, and the number of lines
rangesfrom12linesto622lines.Althoughdockerfilesarerelatively
smallerthansourcecode,theyarecondenseformatted(i.e.,there
are often multiple commands to be executed in one line), and their
dependency on the code is latent. So the localization of updates is
still a difficult problem.
4.2 Metrics
Inourexperiment,weusethetraditionalmetricsofprecision,recall,
andF-scoretomeasuretheeffectivenessoftechniques.Weconsider
a recommended location to be correct, if the recommended instruc-
tiontobeupdatedisrevised,deleted,orhaveanotherinstruction
inserted before of after it in the real version history.
For a recommended update to be correct, we require the recom-
mendation has the same type (insertion, update, or deletion), same
instruction type, and argument value. Here we consider equivalent
updates as also correct. For example, recommending a same inser-
tionatadifferentlocationfromtherealinsertionisalsoconsidered
correct as long as the location difference does not cause difference
in semantics.
2The dataset is available at https://sites.google.com/site/rudseaproject/Table 1: Results on recommending update locations
Project # of Inst. Updates P (%)R (%)F (%)
PHP 72053.979.764.3
Java 47944.576.656.3
All 1,199 49.878.560.9
Table 2: Results on recommending updates
Project # of Inst. Updates P (%)R (%)F (%)
PHP 72028.742.634.3
Java 47927.046.334.1
All 1,199 28.044.134.3
4.3 Evaluation Results
To answer RQ1, we present our evaluation results in Table 1.I n
the table, we present the type of projects, the number of actual
instruction updates,precision, recall, and F-score inColumns 1-5,
respectively. From the table we can see that RUDSEA is able to
achieve high recall (averagely 78.5%) and acceptable precision (av-
eragely 49.8%) in recommending update locations. Note that, since
averagely less than four updates are performed in each commit,
achieving a precision at around 50% means that developers need to
inspect averagely eight locations, and finding four of them correct.
To answer RQ2, we present the results in Table 2with the same
format. From the table we can see that RUDSEA can achieve an av-
erage recall of 44.1% on recommending direct updates. This means
that RUDSEA can recommend exactly correct updates for 529 of
1,199 instruction updates, which may save a large amount of effort
ofdevelopers. Comparedwith therecallon locationrecommenda-
tion,we cansee thatforthe updatesRUDSEA successfullyrecom-
mends locations, about 56% (529) are exactly correct updates. To
answerRQ3,we studiedthe remaining412 incorrectupdates and
find the errors mainly fall into three categories.
First,RUDSEAmayinsertaninstructionatawronglocation.For
simplicity,whenRUDSEAfindsthatadockervariablehasanew
value which can be mapped to a dockerfile item value vin change
impact analysis or equivalence analysis, RUDSEA always insert an
extrainstructionaftertheinstructionhandling v.Sinceinstructions
in dockerfiles are executed in sequence, such an insertion location
may be wrong,especially when vis handled ina long instruction
concatenatedwith“&&”.Thiscategoryaccountsfor207incorrect
updates and we believe that most of them can be resolved by more
fine-grained rules on dockerfile insertions.
Second,althoughRUDSEAcorrectlyrecommendsaninsertion,
theinserted argumentmay notbecorrect. Developerssometimes
addextraparameterstothe RUNinstructionstheyadded,butRUD-
SEAisnotabletorecommendsuchparametersasitdoesnotun-
derstandtheirsemantics.Thiscategoryaccountsfor90incorrect
updates.
Third,whenadockervariablecannotbemappedtoavariable
in the new version, RUDSEA simply deletes dockerfile item values
in its possible value set from dockerfile. Some complicated version
updatesofthesoftwarecausedifficultiesinfindingcorrectmappingofvariablesbetweenversionsandthusRUDSEAmaydeleteavalue
that should be revised. This category accounts for 65 incorrect
updatesandwebelievethattheycanbepartlyresolvedbyusing
more precise version diff tools.
800
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:27:29 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Foyzul Hassan, Rodney Rodriguez, and Xiaoyin Wang
4.4 Threats to Validity
Themajorthreattotheinternalvalidityofourevaluationiswhether
thegroundtruthupdatesweusedinourexperimentareallcorrect.
Although we use real-world updates, developers may make erro-
neous updates or miss some updates, which may cause inaccuracy
in our results. Also, the implementation of RUDSEA may be not
perfect and involve bugs. The major threat to the external validity
is that our evaluation results apply to only the subject projects and
updates, or only Java / PHP projects. To reduce this threat, we use
projects from Github based on different programming languages.
5 RELATED WORK
Studies and Analyses ofDockerfiles. With the increase of soft-
ware complexity and components, managing of software depen-
dencies[12]andtestdependencies[ 13]hasbecomeanimportant
problem. Tufano et al. [ 19] studied on broken snapshots and likely
causes behind broken snapshots. Recent research work on scien-
tific artifact reproduction [ 4] discussed about the uses of Docker
toaddressthechallengeofoperatingsystemvirtualization,cross-
platform portability, and reusable software components. Cito etal. [
6] discussed about the rise of Docker adoption in industry,
and performed an empirical study on dockerfiles [ 7]. Rahman and
Williams [ 15] performed an empirical study on the type of defects
in dockerfiles. Docker is also used for lightweight virtualization
fordevelopersfordistributedapplication development,buildand
ship [11].
Analysis of Building Configuration Files. As build configura-
tionfilesaregettingcomplexanddiverse,researchonbuildconfigu-
ration file is getting importance that includes dependency analysis,
migrationofbuildsystemsandempiricalstudies.Tokeepconsis-
tency during revision, Adams et al. [ 1] proposed a framework to
generate dependencygraph ofbuild configurationfiles. Al-Kofahi
et al. [2] proposed a fault localization technique for make files, and
SYMake [ 18] uses a symbolic-evaluation-based technique to detect
common errors in Makefile. Following works by Zhou et al. [ 24]
andAl-Kofahietal.[ 3]trytofindconfigurationvaluesexercising
differentpartsofmakefiles.Shambaugh[ 16]developedaverifier
for puppet configuration script, and Sharma et al. [ 17] proposed
techniquestodetectbadsmellsinconfigurationfiles.Recently,Has-
san et al. studied the reproduction of building environments [ 8,9],
and performed AST level analysis to generate fix patch for build
configuration files [10].String analysis.
Stringanalysis[ 5]isastaticanalysistechnique
toestimatepossiblevaluesofstringvariables.Stringanalysishas
been applied to detecting vulnerabilities [ 22,23], repair web in-
terfaces [ 21], softwareinternationalization [ 20], inter-component
communication analysis [14], etc.
6 CONCLUSION AND FUTURE WORK
In this paper, we present RUDSEA, which is a novel approach to
recommendupdatesfordockerfilesduringsoftwareevolution.RUD-
SEA leverages tracks environment accesses from code to extract
environment-related scopes from the old software version and the
new software version. Then, RUDSEA generates updates from the
two versions of analysis results. Our evaluation on 40 projects and1,199 real-world instruction updates shows that RUDSEA can rec-
ommend correct update locations for 78.5% of the updates, and
correct updates for 44.1% of the updates, with moderate false posi-
tives.
ACKNOWLEDGMENT.
The authors are supported in part by NSF Awards CCF-1464425,
CNS-1748109, and DHS grant DHS-14-ST-062-001.
REFERENCES
[1]B.Adams,H.Tromp,K.DeSchutter,andW.DeMeuter.2007. Designrecovery
and maintenance of build systems. In ICSM. 114–123.
[2]Jafar Al-Kofahi, Hung Viet Nguyen, and Tien N Nguyen. 2014. Fault localization
for Make-Based build crashes. In ICSME. IEEE, 526–530.
[3]JafarAl-Kofahi,TienNNguyen,andChristianKästner.2016. EscapingAutoHell:
a vision for automated analysis and migration of autotools build systems. In
RELENG. 12–15.
[4]Carl Boettiger. 2015. An Introduction to Docker for Reproducible Research.
SIGOPS Oper. Syst. Rev. 49, 1 (Jan. 2015), 71–79.
[5]Aske Simon Christensen, Anders Møller, and Michael I Schwartzbach. 2003.
Precise analysis of string expressions. In SAS. Springer, 1–18.
[6]JürgenCito,PhilippLeitner,ThomasFritz,andHaraldC.Gall.2015. TheMaking
of Cloud Applications: An Empirical Study on Software Development for the
Cloud. In FSE. 393–403.
[7]Jürgen Cito, Gerald Schermann, John Erik Wittern, Philipp Leitner, Sali Zumberi,
andHaraldCGall.2017. AnempiricalanalysisoftheDockercontainerecosystem
on GitHub. In MSR. IEEE, 323–333.
[8]Foyzul Hassan, Shaikh Mostafa, Edmund SL Lam, and Xiaoyin Wang. 2017. Au-
tomatic building of java projects in software repositories: A study on feasibility
and challenges. In ESEM. 38–47.
[9]FoyzulHassanandXiaoyinWang.2017.Miningreadmefilestosupportautomaticbuildingofjavaprojectsinsoftwarerepositories:Poster.In ICSE,Poster.277–279.
[10]Foyzul Hassan and Xiaoyin Wang. 2018. HireBuild: An Automatic Approach to
History-Driven Repair of Build Scripts. In ICSE. 1078–1089.
[11]MuhamadFitraKacamarga,BensPardamean,andHariWijaya.2015. Lightweight
Virtualization in Cloud Computing for Research. In Intelligence in the Era of Big
Data, Rolly Intan, Chi-Hung Chi, Henry N. Palit, and Leo W. Santoso (Eds.).
439–445.
[12]Shaikh Mostafa, Rodney Rodriguez, and Xiaoyin Wang. 2017. Experience Paper:
A Study on Behavioral Backward Incompatibilities of Java Software Libraries. In
ISSTA. 215–225.
[13]Shaikh Mostafa and Xiaoyin Wang. 2014. An empirical study on the usage of
mocking frameworks in software testing. In QSIC.
[14]Damien Octeau, Daniel Luchaup, Matthew Dering, Somesh Jha, and Patrick
McDaniel. 2015. Composite Constant Propagation: Application to Android Inter-
component Communication Analysis. In ICSE. 77–88.
[15]AkondRahmanandLaurieWilliams.2018.Characterizingdefectiveconfiguration
scripts used for continuous deployment. In ICST. 34–45.
[16]RianShambaugh,AaronWeiss,andArjunGuha.2016. Rehearsal:aconfiguration
verificationtoolforpuppet.In InternationalConferenceonProgrammingLanguage
Design and Implementation. 416–430.
[17]Tushar Sharma, Marios Fragkoulis, and Diomidis Spinellis. 2016. Does your
configuration code smell?. In MSR. IEEE, 189–200.
[18]AhmedTamrawi,HoanAnhNguyen,HungVietNguyen,andTienN.Nguyen.
2012. SYMake: A Build Code Analysis and Refactoring Tool for Makefiles. In
ASE. 366–369.
[19]Michele Tufano, Fabio Palomba, Gabriele Bavota, Massimiliano Di Penta, Rocco
Oliveto,AndreaDeLucia,andDenysPoshyvanyk.2017. Thereandbackagain:
Can you compile that snapshot? Journal of Soft.: Evo. and Proc., 29, 4 (2017).
[20]Xiaoyin Wang, Lu Zhang, Tao Xie, Hong Mei, and Jiasu Sun. 2009. Transtrl: An
automaticneed-to-translatestringlocatorforsoftwareinternationalization.In
ICSE, Tool Demo. 555–558.
[21]XiaoyinWang,LuZhang,TaoXie,YingfeiXiong,andHongMei.2012. Automat-
ingpresentationchanges indynamicwebapplications viacollaborativehybrid
analysis. In FSE. 16.
[22]GaryWassermannandZhendongSu.2007. Soundandpreciseanalysisofweb
applications for injection vulnerabilities. In PLDI. 32–41.
[23]FangYu,MuathAlkhalaf,TevfikBultan,andOscarH.Ibarra.2014. Automata-
based Symbolic String Analysis for Vulnerability Detection. Form. Methods Syst.
Des.44, 1 (Feb. 2014), 44–70.
[24]ShuruiZhou,JafarAl-Kofahi,TienNNguyen,ChristianKästner,andSarahNadi.2015. Extractingconfigurationknowledgefrombuildfileswithsymbolicanalysis.
InRELENG. 20–23.
801
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:27:29 UTC from IEEE Xplore.  Restrictions apply. 