Optimizing Selection of Competing Services
with Probabilistic Hierarchical ReÔ¨Ånement
Tian Huat T an2Manman Chen1Jun Sun2Y ang Liu3
√âtienne Andr√©4Yinxing Xue3Jin Song Dong1
2SUTD (Singapore),1NUS (Singapore),3NTU (Singapore),4Universit√© Paris 13 (France)
ABSTRACT
Recently, many large enterprises (e.g., NetÔ¨Çix, Amazon) have de-
composed their monolithic application into services, and composedthem to fulÔ¨Åll their business functionalities. Many hosting services
on the cloud, with different Quality of Service (QoS) (e.g., avail-
ability, cost), can be used to host the services. This is an example
of competing services. QoS is crucial for the satisfaction of users.
It is important to choose a set of services that maximize the over-
all QoS, and satisfy all QoS requirements for the service compo-
sition. This problem, known as optimal service selection, is NP-
hard. Therefore, an effective method for reducing the search spaceand guiding the search process is highly desirable. To this end, weintroduce a novel technique, called Probabilistic Hierarchical Re-
Ô¨Ånement ( P
ROHR).P ROHR effectively reduces the search space
by removing competing services that cannot be part of the selec-tion. P
ROHR provides two methods, probabilistic ranking and hi-
erarchical reÔ¨Ånement, that enable smart exploration of the reduced
search space. Unlike existing approaches that perform poorly whenQoS requirements become stricter, P
ROHR maintains high perfor-
mance and accuracy, independent of the strictness of the QoS re-
quirements. P ROHR has been evaluated on a publicly available
dataset, and has shown signiÔ¨Åcant improvement over existing ap-
proaches.
1 Introduction
Web services provide an affordable and adaptable framework that
can produce a signiÔ¨Åcantly lower cost of ownership for the enter-
prises over time. Web services make use of open standards, such asWSDL [18] and SOAP [19], which enable the interaction among
heterogeneous applications. This facilitates the dynamic integra-tion among applications without costly and time-consuming pro-
gramming.
Enterprises make use of service composition to integrate multi-
ple services for complex interactions. The composed Web serviceis called a composite service, whereas the services that are used
in the composed Web service are called component services.F o r
each of the component services, there are usually many competing
services, that provide the same functionality but different levels ofQuality of Service (QoS) (e.g., response time, availability, cost) for
selection. We provide two examples on such competing services.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributedfor proÔ¨Åt or commercial advantage and that copies bear this notice and the full cita-tion on the Ô¨Årst page. Copyrights for components of this work owned by others thanACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-publish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission
and/or a fee. Request permissions from permissions@acm.org.
ICSE ‚Äô16, May 14-22, 2016, Austin, TX, USA
c/circlecopyrt 2016 ACM. ISBN 978-1-4503-3900-1/16/05. . . $15.00
DOI: http://dx.doi.org/10.1145/2884781.2884861)OLJKW
%RRNLQJ6HUYLFH
)%6&DU
%RRNLQJ6HUYLFH
&%6
+RWHO
%RRNLQJ6HUYLFH
+%65HSO\
8VHU5HTXHVW
IURP8VHU7UDYHO%\
5RDG
7UDYHO%\
$LU
Figure 1: Travel Agency Service (T AS)
1. Many big players in the market (e.g., NetÔ¨Çix, Amazon, and
Microsoft Azure) have adopted microservice architecture [3]
by decomposing their existing monolithic applications intosmaller, and highly decoupled services (also known as mi-
croservices). These services are then composed for fulÔ¨Ållingtheir business requirements. For example, NetÔ¨Çix decom-posed their monolithic DVD rental application into services
that work together, and that stream digital entertainment to
millions of NetÔ¨Çix customers every day. Services of NetÔ¨Çixare hosted in a cloud provided by Amazon EC2 [2], whichoffers about 40 instance types (e.g., t2.micro, c4.4xlarge) for
selection. All instance types provide the same functionality
while having different QoS.
2. Many enterprises outsource some of their business tasks to
external service providers (e.g., car booking service), for low-ering the cost of operations. However, many external ser-
vices may offer the same functionality, but with a different
level of QoS. Figure 1 shows an example of a simple compos-
ite service, named Travel Agency Service (T AS). If the user
requests to travel by road, the Car Booking Service (CBS)will be invoked to book a car for reaching the destination.
If the user requests to travel by air, the Flight Booking Ser-vice (FBS) will be invoked to book the Ô¨Çight for reaching
the nearest airport to the destination. In either case, the Ho-tel Booking Service (HBS) will be invoked to book the hotel.
Finally, the system replies to the user with the status of book-
ing. There may be many competing services for CBS, FBS
and HBS.
QoS attributes, such as response time, availability, cost, etc., pro-
vide quantitative indicators on non-functional aspects of the com-
posite service. The Service Level Agreement (SLA) is often used asan agreement between the composite service providers and the ser-
vice users; it speciÔ¨Åes the expected QoS level of the composite ser-vice. The SLA can be expressed as constraints over the QoS, e.g.,
the response time must be smaller than one second, or the availabil-ity must be higher than 99.99%. A composite service user typically
has limited knowledge on the internal structure of the compositeservice, and component services that are involved. The service user
is only concerned with the end-to-end QoS of the composite ser-
2016 IEEE/ACM 38th IEEE International Conference on Software Engineering
   85
vice, i.e., the QoS at the composite service level. The user require-
ments of QoS for the composite service can be speciÔ¨Åed as global
constraints. Our objective is to select a set of concrete services that
can satisfy the global constraints on the composite service, while
maximizing the end-to-end QoS.
Following the SOA principles, a composite service contains a set
of abstract services which have their functionalities deÔ¨Åned. Givenan abstract service (e.g., a hotel booking service), a concrete ser-vice (e.g., the Hilton Hotel booking service) is selected from a set
of competing services to realize the abstract service at runtime. Theproblem of selecting concrete services while maximizing end-to-
end QoS, known as the optimal selection problem, has received
considerable attentions over the last decade [9, 7, 11, 10, 37]. The
optimal selection problem becomes increasingly challenging as the
number of concrete services increases. Given a composite service
with 10 abstract services executed in a sequential manner, with
each abstract service having 10concrete service candidates, there
are10
10combinations to explore. In fact, it has been shown that
the problem is NP-hard [10].
To address the scalability problem, approaches based on select-
ing representative component services have been proposed. We de-
note the optimality of QoS for a concrete component service withrespect to other functional-equivalent services as local optimality.
Existing state-of-the-art representative services approaches [9, 7]provide search space reduction based on local optimality of the ser-vices. Although it has been shown to provide good performancefor a large number of candidates with less restrictive global con-
straints, it suffers from signiÔ¨Åcant performance degradation whenthe global constraints become more restrictive. The primary reason
is that they do not take the global constraints into account duringservice selection. In addition, the algorithm for selecting represen-tative services (i.e., k-means clustering) has high worst case com-
plexity (i.e., NP-hard).
In this work, we propose a novel approach, called Probabilistic
Hierarchical ReÔ¨Ånement (P
ROHR), to address this problem. The
key idea behind P ROHR is the usage of both global constraints
and local optimality to achieve search space reduction. P ROHR
is divided into three stages, i.e., preprocessing stage, probabilistic
ranking stage, and hierarchical reÔ¨Ånement stage. In the prepro-
cessing stage, the services that are veriÔ¨Åed impossible to be partof the optimal selection are pruned from the search space. Sub-
sequently, in the probabilistic ranking stage, services are ranked
according to both local optimality value and constraint satisfactionprobability. Intuitively, local optimality value and constraint satis-
faction probability of a service quantify the optimality of the ser-
vice, and the likelihood that the service can contribute to the con-
formance of global constraints respectively. Following that, in the
hierarchical reÔ¨Ånement stage, initial representative services fromthe top hierarchy of competing services are chosen. The number
of representative services is adjusted adaptively according to theconstraint satisfaction probability of representative services. The
representative services are then reÔ¨Åned iteratively with more ser-vices from lower hierarchies until a solution for optimal service se-
lection is found. In our approach, our representative selection has
much lower worst case complexity than the existing state-of-the-
art approaches [9, 7]. The complexity analysis of the algorithms is
provided in Section 3.5.
Our main contributions are summarized below.
1. We introduce a pruning method called constraint pruning,
that can effectively discard the service candidates that cannotsatisfy the global constraints.
2. We propose probabilistic ranking and hierarchical reÔ¨Ånementmethods, which enable smart exploration of search space byeffectively leveraging the information of global constraints
and QoS for competing services.
3. We evaluate the beneÔ¨Åts brought by the P
ROHR using a pub-
licly available dataset. The results have shown signiÔ¨Åcant
improvement over existing approaches.
Outline. Section 2 introduces the QoS compositional model and
necessary terminologies. Section 3 presents P ROHR. Section 4
provides the evaluation of our approach. Section 5 discusses ourapproach. Section 6 reviews related works. Finally, Section 7 con-
cludes, and outlines future work.
2 QoS-Aware Compositional Model
In this section, we deÔ¨Åne the QoS compositional model used in
this work. Following the SOA principles, service providers needto characterize their services to deÔ¨Åne both the offered function-
alities and the offered quality. An abstract service speciÔ¨Åes thefunctionality of the service without referring to any concrete ser-vice instance. An abstract service can be deÔ¨Åned as a service class
S={s
1,...,s n}which contains nfunctionally equivalent con-
crete services sithat can be used to realize the functionality speci-
Ô¨Åed by the abstract service. We use |S|to denote the total number
of concrete services in S. We use the notation /hatwideSto denote an ab-
stract service S/primethat is a subset of S, i.e.,S/prime‚äÜS.
An abstract composite service CS aspeciÔ¨Åes the compositional
workÔ¨Çows using a set of abstract services CS a=/angbracketleftS1,...,S n/angbracketright
for fulÔ¨Ålling the service requests. A concrete composite service
CS=/angbracketlefts1,...,s n/angbracketrightis deÔ¨Åned as an instantiation of abstract com-
posite service CS a=/angbracketleftS1,...,S n/angbracketright, where each abstract service
Siis replaced by a concrete service si‚ààSi. We use |CS a|to
denote the total number of abstract services in CS a.
For simplicity of illustration, we only consider the ‚Äútravel by
air‚Äù branch of the T AS example. This results in a compositionwhere services FBS and HBS are running sequentially. We will
use the modiÔ¨Åed T AS example as a running example in this work,
and henceforth, simply refer to it as the T AS example. For the T AS
example, there are two abstract services FBS and HBS. Suppose
that the concrete services for FBS and HBS are {f
1,f2,f3,f4}
and{h1,h2,h3,h4}respectively. Then the abstract composite ser-
vice TAS ais/angbracketleftFBS, HBS/angbracketright =/angbracketleft{f 1,f2,f3,f4},{h1,h2,h3,h4}/angbracketright,
and a possible concrete composite service of TAS acan be TAS =
/angbracketleftf1,h2/angbracketright.
2.1 QoS Attributes
In this work, we deal with QoS attributes that can be quantitatively
measured using metrics. In addition, we assume the values of QoS
attributes for services to be known; we discuss how the value can
be obtained in Section 5.
There are two classes of attributes: positive ones (e.g., avail-
ability) and negative ones (e.g., response time). Positive attributeshave positive effects on the QoS, and therefore they need to be
maximized. Conversely, negative attributes need to be minimized.For simplicity, we only consider negative attributes in this work,
since positive attributes can be transformed into negative attributesby multiplying their values with ‚Äì1. Given rQoS attributes of a
concrete component service s, we use an attribute vector Q
s=
/angbracketleftq1(s),...,q r(s)/angbracketrightto represent the QoS attribute values of service
s, whereqi(s)is theith QoS attribute value of s. Similarly, given a
concrete composite service CS , we use the attribute vector QCS=
/angbracketleftq/prime
1(CS),...,q/prime
r(CS)/angbracketrightto represent it, where q/prime
i(CS)is theith
end-to-end QoS attribute value of CS .
86The SLA often speciÔ¨Åes a set of constraints on the end-to-end
QoS. Such constraints deÔ¨Åne the lower bound for positive con-
straints (e.g., the availability must be higher than 99.99%) and theupper bound for negative constraint (e.g., the response time must
be less than 500 ms). Given a composite service CS with QoS
attribute vector Q
CS=/angbracketleftq/prime
1(CS),...,q/prime
r(CS)/angbracketright, the global con-
straints of CS can be represented as a vector CCS=/angbracketleftC1,...,C r/angbracketright
whereCi‚ààRandq/prime
i(CS)‚â§Ci. Without loss of generality, we
useCi=‚àûto denote the situation where q/prime
i(CS)is unconstrained.
2.2 QoS for Composite Services
We introduce four elementary compositional structures for com-posing the component services: sequential, parallel, loop and con-ditional. Sequential composition of services {s
1,...,s n}executes
the services sequentially, one after another. Parallel composition of
services{s1,...,s n}executes the services concurrently. A loop
executes a service s1repeatedly up to kiterations. Conditional
composition of services {s1,...,s n}executes exactly one of the
services according to the evaluation of the guard conditions, wherethe guards are mutually exclusive.
The end-to-end QoS is aggregated from the QoS on the compo-
nent services, based on the service compositional structures, and
the types of QoS attributes. Table 1 shows the aggregation func-
tions for response time, availability, and cost of component serviceswith respect to the compositional structures. The response time
r‚ààR
‚â•0is the delay between sending a request and receiving a
response. For the sequential composition, the response time of theservice composition is obtained by summing up the response time
of the component services. For the parallel composition, it is equal
to the maximum response time among the participating component
services. For the loop composition, it is calculated by summing
the involved component service ktimes, where kis the maximum
number of loop iterations. For the conditional composition, sincethe evaluation of guards is not known at design time, the maximum
response time of nservices is chosen as the response time of the
composite service. The availability a‚ààR‚à©[0,1]is the probabil-
ity of the service being available. For the sequential composition,
this implies that all the services are available during the sequential
execution; therefore, the availability of the composite compositionis the multiplication of the component services‚Äô availability. The
costc‚ààR
‚â•0is the price for utilizing a service. For the sequen-
tial and parallel composition, it is calculated by summing the cost
of participating component services. For other compositions, theiraggregation functions are similar.
Given an abstract composite service CS
a, a composite service
CS/prime
ais a subset ofCS a, denoted by CS/primea‚äÜCS a,i fCS/primeaand
CS ahave the same compositional structure, and every service class
ofCS/prime
ais a subset of the corresponding service class of CS a. For-
mally, CS/prime
a‚äÜCS aifCS/primeaandCS ashare the same compositional
structure C, with|CS/prime
a|=|CS a|and‚àÄSi‚ààCS/prime
a,‚àÄSj‚ààCS a:
(i=j)=‚áíSi‚äÜSj. Given a composite service CS a,areduced
abstract composite service ofCS a, denoted by /hatwidestCS a, is used to
represent any composite service CS/primea‚äÜCS a, e.g., an example of
/hatwideTAS ais/angbracketleft{f 1,f2},{h1,h2,h3}/angbracketright.
2.3 Optimality Function
Concrete services have multi-dimensional attributes, and we need
a methodology to facilitate their comparison in terms of their QoS.
In this work, we use a Simple Additive Weighting (SAW) tech-
nique [34] to obtain a score for multi-dimensional attributes. SAW
uses two phases: normalization and weighting, for producing the
score. The normalization stage normalizes the values of QoS at-
tributes so that they are independent of their units and ranges toQoS Attribute Sequential Parallel Loop Conditional
Response Timen/summationtext
i=1q(si)nmax
i=1q(si)k‚àó(q(s1))nmax
i=1q(si)
Availabilityn/producttext
i=1q(si)n/producttext
i=1q(si)(q(s1))kn
min
i=1q(si)
Costn/summationtext
i=1q(si)n/summationtext
i=1q(si)k‚àó(q(s1))nmax
i=1q(si)
Table 1: Aggregation function
allow comparison. The weighting stage allows users to specifytheir preferences on different QoS attributes. In the normaliza-
tion stage, a service compares its QoS attribute values with themaximum and minimum QoS attributes of other service candidates
within a service class. A composite service compares its aggre-gated QoS attributes with the maximum and minimum aggregated
QoS attributes. The maximum (resp. minimum) aggregated QoS at-
tributes can be obtained by aggregating maximum (resp. minimum)
QoS attributes from each service class. Formally, we have
G
min(k)=F(k)n
i=1(Lmin(i,k))
Gmax(k)=F(k)ni=1(Lmax(i,k))(1)
with
Lmin(i,k) = min
‚àÄs‚ààSiqk(s)
Lmax(i,k)= m a x
‚àÄs‚ààS iqk(s)(2)
whereGmin(k)andGmax(k)are the minimum and maximum ag-
gregated values for the kth QoS attribute for the composite service,
F(k)is the QoS aggregation function for attribute kwhich is given
in Table 1, Lmin(i,k)andLmax(i,k)are the minimum and max-
imum aggregated values for the kth QoS attribute for service class
i.
Suppose each service has rQoS attributes. The local optimality
functionLi(s)computes the local optimality value of a concrete
serviceswithin service class Si, wheres‚ààSi, as follows.
Li(s)=r/summationdisplay
k=1v(i,k,s)¬∑wk (3)
with
v(i,k,s)=‚éß
‚é®
‚é©Lmax(i,k)‚àíqk(s)
Lmax(i,k)‚àíL min(i,k)ifLmax(i,k)/negationslash=L min(i,k)
1 ifLmax(i,k)=L min(i,k)
wherewk‚ààR‚â•0is the weight of qkand/summationtextr
k=1wk=1 .
The global optimality function G(CS)computes the global op-
timality value of concrete composite service CS as follows.
G(CS)=r/summationdisplay
k=1v/prime(k,CS)¬∑wk (4)
with
v/prime(k,CS)=‚éß
‚é®
‚é©Gmax(k)‚àíq/prime
k(CS)
Gmax(k)‚àíG min(k)ifGmax(k)/negationslash=G min(k)
1 ifGmax(k)=G min(k)
wherewk‚ààR‚â•0is the weight of q/prime
kand/summationtextr
k=1wk=1 .
2.4 Problem Statement
We Ô¨Årst deÔ¨Åne the notions of feasible and optimal selection.
87Concrete
ServicesResponseTime (ms)Availability
f1/h1 100 0.85
f2/h2 300 0.92
f3/h3 500 0.95
f4 600 0.94
h4 600 0.8
(a) Concrete services of T AS)%6 +%6¬îPV
0LQUHVSRQVH
WLPHPV
(b) Service preprocessing
Figure 2: T AS Example
DEFINITION 1.Given an abstract composite service CS a=
/angbracketleftS1,...,S n/angbracketright, and global QoS constraints C=/angbracketleftC1,...,C r/angbracketrightfor
CS a,a feasible selection is a selection of concrete services CS,
such that CS contains exactly one service for each service class
SiinCS aandCS satisÔ¨Åes the global QoS constraints C, i.e.,
q/prime
k(CS)‚â§Ck.
DEFINITION 2.An optimal selection is a feasible selection of
concrete services CS that maximizes the global optimality value
G(CS).
Given an abstract composite service CS a, and a set of global
constraints C, we are interested in Ô¨Ånding the optimal selection
CS . To address this problem, a naive approach is to exhaustively
explore all combinations of concrete services for each service class.
However, given nservices in sequential composition, with each
of them having lcandidates, the total number of combinations is
ln. In fact, this problem is NP-hard, as it can be used to model a
known NP-hard problem, i.e., the multi-dimensional multi-choiceknapsack problem (MMKP) [26]. To allow runtime QoS-awareservice composition, it is desirable to Ô¨Ånd a near-optimal selection
at an acceptable cost, rather than Ô¨Ånding an exact solution to the
optimal selection problem at a very high cost [10].
One way to mitigate this problem is to select a subset of service
candidates each time, instead of working on all services candidates.This is efÔ¨Åcient especially when the number of service candidates
is large and hard to be handled. The question that arises is howto identify a set of representative service candidates that not only
satisfy the constraints, but also contribute to high global optimal-ity value. In this work, our goal is to address the optimal selec-
tion problem efÔ¨Åciently and effectively by progressively exploringsubsets of candidates that are likely to contribute to the optimal ornear-optimal selection.
TAS Example. We provide the details of non-functional proper-
ties on the T AS example, which will be used in the following sec-
tions. Each of the abstract services of TAS
ahas four concrete ser-
vices, where FBS ={f1,f2,f3,f4}and HBS ={h1,h2,h3,h4}.
The attribute vector of T AS example is in the form of QTAS=
/angbracketleftq/prime
1(TAS),q/prime
2(TAS)/angbracketright, where attribute q/prime
1provides the value of re-
sponse time, and attribute q/prime
2provides the value of availability. The
values of response time and availability of all concrete services aregiven in Figure 2(a). In addition, the global constraints for response
time and availability of T AS are 600 ms and 0.8 respectively.
3 Probabilistic Hierarchical ReÔ¨Ånement ( PROHR)
We introduce our method Probabilistic Hierarchical ReÔ¨Ånement in
this section. The workÔ¨Çow of P ROHR is illustrated in Figure 3.
PROHR is divided into three stages, i.e., preprocessing stage, prob-
abilistic ranking stage, and hierarchical reÔ¨Ånement stage. The de-
tails of each of the stages are introduced in the following subsec-
tions.3UREDELOLVWLF
5DQNLQJ+LHUDUFKLFDO
5HILQHPHQW3UHSURFHVVLQJ&RQFUHWH
FRPSRVLWH
VHUYLFH$EVWUDFW
FRPSRVLWH
VHUYLFH1RIHDVLEOHVHOHFWLRQ
Figure 3: Probabilistic Hierarchical ReÔ¨Ånement (P ROHR)
3.1 Preprocessing Stage
The global constraints play an important role in selecting the ser-vices. For example, it has been shown that the heuristic method
proposed in [9] has its performance degraded when the global con-straints become more restrictive. In this section, we show that theglobal constraints can be used as an effective means for pruning ser-
vice candidates. Consider the T AS example in Figure 2(b) whereFBS and HBS are running sequentially, and the T AS global con-
straint for response time is 600 ms. We know that the concreteservice that has the fastest response time for HBS is service s
/prime
1,
which has response time of 100 ms. Therefore, a service s‚ààFBS
must have a response time smaller than 500 ms, in order to fulÔ¨Åll
the global constraint for response time. We refer to a service thatmay fulÔ¨Åll the global constraints as a constraint-satisÔ¨Åable service.
Formally, given a composite service CS=/angbracketleftS
1,...,S n/angbracketright, and
global constraints CCS=/angbracketleftC1,...,C r/angbracketright, a service si‚ààSiis a
constraint-satisÔ¨Åable service if the following condition holds:
‚àÄk: F(k)
j‚àà{1,...,n}(vj)‚â§Ck (5)
with
vj=/braceleftBigg
qk(si)if j =i
Lmin(j,k)if j/negationslash=i
where F(k)is the QoS aggregation function for attribute k.F o r
example, given a service si‚ààSi, and suppose all QoS aggregation
functions F(k)are summations, then the condition becomes
‚àÄk:(qk(si)+/summationdisplay
j‚àà{1,...,n}\iLmin(j,k))‚â§Ck
We can safely prune all constraint-unsatisÔ¨Åable services as theycannot satisfy the global constraints. For the T AS example, con-crete services f
4andh4are the only concrete-unsatisÔ¨Åable ser-
vices, because some of their QoS attributes do not satisfy Condi-tion (5). In particular, it is the response times of f
4,h4and the
availability of h4that do not satisfy the condition.
In addition to pruning using global constraints, we also include
in the service preprocessing stage the pruning of non-skyline ser-vices [9]. Let us Ô¨Årst recall the notion of dominance.
D
EFINITION 3( D OMINANCE ).LetSbe a service class, and
s,s/primebe two services, where s,s/prime‚ààSands/negationslash=s/prime. Service sdom-
inates services/prime, denoted by s‚â∫s/prime, if the service sis at least
as good as service s/primein all QoS parameters and better than ser-
vices/primein at least one QoS parameter , i.e., ‚àÄk‚àà{1,...,|QS|}:
qk(s)‚â§qk(s/prime), and‚àÉk‚àà{1,...,|QS|}:qk(s)<q k(s/prime).
A service s‚ààSis denoted as a skyline service if there does not
exist a service in service class Sthat dominates s(i.e.,¬¨‚àÉs/prime‚ààS:
s/prime‚â∫s). In other words, a service s‚ààSis a non-skyline service,i f
there exists a service s/prime‚ààSthat dominates s.
It can be shown that we can safely prune non-skyline services
in service class CS , without affecting the result of optimal selec-
tion [7]. For our T AS example, concrete service h4is the only
non-skyline service.
88Algorithm 1: Service Preprocess (Preprocess)
input : Abstract composite service CS a=/angbracketleftS1,...,S n/angbracketright
output: Preprocessed abstract composite service
CS/prime
a=/angbracketleftS/prime
1,...,S/prime
n/angbracketright
1CS/prime
a‚Üê/angbracketleft ‚àÖ 1,‚àÖ2,...,‚àÖ n/angbracketright;
2f o ri=1 tondo
3S/prime/prime
i=ConstraintPruning( Si);
4S/prime
i=NonSkylinePruning( S/prime/prime
i);
5 CS/prime
a[i]‚ÜêS/prime
i;
6 return CS/primea;
Henceforth, we denote the pruning of constraint-unsatisÔ¨Åable
services and non-skyline services as constraint pruning and non-
skyline pruning respectively. The algorithm of service preprocess-
ing is shown in Algorithm 1. The abstract composite service CS/prime
a
is initialized with empty service classes (line 1), where ‚àÖidenotes
ith empty service class. After that, each service class of CS awill
be undergone constraint pruning (line 3) and non-skyline pruning
(line 4). The service class after pruning will be assigned to CS/prime
a
(line 5). Finally, abstract composite service CS/prime
awhich contains
the preprocessed service classes will be returned (line 6). In the
T AS example, the composite service TAS/prime
aafter service preprocess-
ing stage is /angbracketleft{f 1,f2,f3},{h1,h2,h3}/angbracketright.
After the initial preprocessing, we propose in the following a
ranking based method that can allow us to limit the selection to a
smaller set of services that have higher chance of contributing to
the optimal selection.
3.2 Probabilistic Ranking Stage
The local optimality value of a concrete service can reÔ¨Çect the qual-ity of a service. Nevertheless, it does not provide a direct indica-tion on how likely the concrete service can contribute to the con-formance of the global constraints. To address this problem, we
propose an estimation on the probability of the constraint satisfac-
tion of a concrete service. First, we introduce the notion of local
constraint. The objective of local constraint is to provide an esti-mation on the average constraint value that has to be fulÔ¨Ålled by
individual service classes. Given a global constraint C
i, we deÔ¨Åne
the local constraint cias follows, where nis the number of service
classes.
ci=‚éß
‚é™‚é™‚é™‚é®
‚é™‚é™‚é™‚é©Ci/n ifagg is sum
C1/n
i ifagg is mult ‚àßCi‚â•0
‚àí|C i|1/nifagg is mult ‚àßCi<0
Ci ifagg is min ,max(6)
Equation (6) is recursively applied to the compositional struc-
ture according to the aggregation functions ( agg ) ‚Äì either sum-
mation (sum ), multiplication (mult ), minimum (min ), or maxi-
mum (max ). Assume that Ciis a global constraint for cost. Given
the original T AS in Figure 1, which contains three services CBS,
FBS and HBS, we Ô¨Årst apply Equation (6) to the sequential struc-ture, which contains a conditional structure and HBS. The condi-
tional structure and HBS are both allocated with local constraint
C
i/2(since agg is sum is true). Subsequently, we recursively ap-
ply Equation (6) to the conditional structure, where CBS and FBS
are both allocated with Ci/2(since agg is max is true and the lo-
cal constraint for the conditional structure is Ci/2).
Given a composite service CS a=/angbracketleftS1,...,S n/angbracketright, and global
constraints of CS aasC=/angbracketleftC1,...,C r/angbracketright, the constraint satisfac-
tion probability of a service s‚ààSi, denoted by Pi(s), is calculatedV
V

VQV
V

VQV
V

VQ+LJKHVW5DQN
/RZHVW5DQN6U6U6U5RXQG ¬¢¬¢V¬≤¬¢V¬≤¬¢V¬≤¬≤
5RXQG ¬¢¬¢VV¬≤
 ¬¢VV¬≤
 ¬¢VV¬≤¬≤

5RXQGQ ¬¢¬¢VV¬´V Q¬≤
 ¬¢VV¬´V Q¬≤
 ¬¢VV¬´V Q¬≤¬≤
Figure 4: A scenario of hierarchical reÔ¨Ånement
as follows:
Pi(s)=Œ≥/parenleftBig r/summationdisplay
k=1pk(s)¬∑wk/parenrightBig
(7)
wherewk‚ààR+
0is the weight of pk(s),/summationtextr
i=1wk=1 andŒ≥‚àà
R‚à©[0,1]is the credibility factor (explained later). The calculation
ofpk(s)is divided into two cases. When qk(s)>c k, then
pk(s)=Dmax(i,k)‚àí(qk(s)‚àíck)
Dmax(i,k)(8)
with
Dmax(i,k)= m a x
‚àÄsi‚ààSi(qk(si)‚àíck)
and when qk(s)‚â§ck,pk(s)=1 . In the following, we explain the
details of Equation (7) and Equation (8).
In Equation (7), Pi(s)is calculated by using the SAW method
that is introduced in Section 2.3, followed by multiplying with the
credibility factor Œ≥. The credibility factor Œ≥is used to adjust the
value ofPi(s)based on how much we can trust Pi(s). We set
the value of credibility factor Œ≥to1/n, where nis the number of
service classes. The reason for this choice is that, with the incre-ment ofn,P
i(s)would be more dependent on the choices made
by other service classes. To estimate the probability more conser-vatively, we choose to lower the constraint satisfaction probability,
given that the number of service classes nincreases.
In Equation (8), q
k(s)>c ksigniÔ¨Åes that qk(s)has violated
the local constraint (reminded that negative attributes are assumedhere). The value of p
k(s)is decided by the value of qk(s).I fqk(s)
has a smaller value, it has a higher chance for satisfying the globalconstraints, hence the higher value of p
k(s). Given a service class
Si,Dmax(i,k)calculates the maximum difference between qk(si)
and the local constraint ck, wheresi‚ààSi.Dmax(i,k)serves the
purpose of normalizing the value of probability pk(s), such that
pk(s)‚ààR‚à©[0,1]. For the case of qk(s)‚â§ck, it indicates the
conformance of qk(s)to the local constraint, and we simply set
pk(s)=1 . In T AS, the constraint satisfaction probabilities for con-
crete services are P1(f1)=P 2(h1)=0.25,P1(f2)=P 2(h2)=0.5, and
P1(f3)=P 2(h3)=0.25.
Given a composite service CS a=/angbracketleftS1,...,S n/angbracketright, the proba-
bilistic ranking is performed by ordering the services in each ser-vice class S
iby the multiplication value of local optimality value
and constraint satisfaction probability of each service s‚ààSi, i.e.,
Li(s)¬∑Pi(s), in the descending order. We denote the ranked service
class asSr
i=/angbracketlefts1,...,s n/angbracketright, which is an ordered sequence of all
concrete services si‚ààSi. The ranked composite service contain-
ing the ranked services as CSr
a=/angbracketleftSr
1,...,Sr
n/angbracketright. For T AS example,
given the composite service TAS/prime
areturned by service preprocess-
ing, the ranked composite service TASr
a=/angbracketleft/angbracketleftf2,f1,f3/angbracketright,/angbracketlefth2,h1,h3/angbracketright/angbracketright,
where the values of Li(s)¬∑Pi(s)for concrete services f1(h1),
f2(h2), andf3(h3)are 0.125, 0.3, and 0.125 respectively.
3.3 Hierarchical ReÔ¨Ånement Stage
After obtaining the ranked composite service CSr
a, the next stage is
to perform service selection on CSr
a. We illustrate the dynamic ser-
89Algorithm 2: Optimization with P ROHR (P ROHR)
input : Abstract composite service to be solved CS a
input : Termination threshold for constraint-satisÔ¨Åability
/epsilon1‚ààR‚à©[0,1]
output: A feasible selection of concrete composite services
CS
1CS/prime
a‚ÜêPreprocess (CS a);
2CSr
a‚ÜêPRank (CS/primea);
3/hatwidestCSr
a‚Üê/angbracketleft ‚àÖ 1,‚àÖ2,...,‚àÖ n/angbracketright;
4round‚Üê1;
5 repeat
6/hatwidestCSra‚ÜêHReÔ¨Åne (CSr
a,/hatwidestCSr
a,/epsilon1,round );
7 CS‚ÜêOptimalSelection (/hatwidestCSra);
8i f CS/negationslash=‚àÖthen
9 return CS ;
10round‚Üêround +1 ;
11 until /hatwidestCSra=CSr
a;
12 return ‚àÖ;
vice selection with an example as shown in Figure 4. Consider that
CSr
a=/angbracketleftSr
1,Sr
2,Sr
3/angbracketright, where the services of each service class Sr
i
can be found in Figure 4. The hierarchical reÔ¨Ånement uses multi-
ple rounds of selection for selecting the service representatives. At
the Ô¨Årst round, one service is chosen from each service class; they
form a reduced composite service /hatwidestCSr
a=/angbracketleft/hatwiderSr
1,/hatwiderSr
2,/hatwiderSr
3/angbracketright, where
/hatwiderSr
1=/angbracketlefts11/angbracketright,/hatwiderSr
2=/angbracketlefts21/angbracketright, and/hatwiderSr
3=/angbracketlefts31/angbracketright. The reduced composite
service/hatwidestCSrais then solved, e.g., by MIP solver, for optimal selec-
tion (details will be given in Section 3.4). Note that the reduced
composite service /hatwidestCSr
acontains less services than CSr
a. There-
fore, the optimal selection can be performed more efÔ¨Åciently. If a
solution is found, then the result is returned to the user. Otherwise,
we proceed to next round by selecting more services from each ser-
vice class. The process is repeated until a solution is found or until
all services in the service classes have been explored. In the latter
case, the selection approach guarantees that it does not miss out a
solution if one exists.
The next problem is how to determine the number of represen-
tatives for each service class Sr
iat each round of selection: the
number of services should be large enough for Ô¨Ånding a solution tothe service composition, while small enough to allow for efÔ¨Åcient
computation. We propose to use constraint satisfaction probability
to address the problem. We Ô¨Årst extend the deÔ¨Ånition of constraint
satisfaction probability to a set of services. Given Sas a subset of
services from service class S
i, i.e.,S‚äÜSi, we deÔ¨Åne constraint
satisfaction probability of S, denoted as Pi(S), as the probability
that at least one of the services in Ssucceed in satisfying the global
constraints after composition. Pi(S)is calculated as follows:
Pi(S)=1‚àí/productdisplay
s‚ààS(1‚àíPi(s)) (9)
We observe that the reason that the optimal selection cannot pro-
duce a solution is due to global constraint violation. Therefore, the
capacity of the set of representatives Sshould be large enough, so
thatPi(S)can exceed /epsilon1, which is a parameter provided by the user
on the intended termination threshold.
Algorithm 2 presents the main P ROHR algorithm. Initially, the
input abstract composite service CS apasses through two initial
stages of P ROHR: service preprocess and service ranking, using
functions Preprocess andPRank respectively (lines 1, 2). Func-
tionPreprocess has been introduced in Algorithm 1, and functionAlgorithm 3: Hierarchical ReÔ¨Ånement (HReÔ¨Åne)
input : Abstract composite service CSr
a=/angbracketleftSr
1,...,Sr
n/angbracketright
input : Reduced abstract composite service
/hatwidestCSr
a=/angbracketleft/hatwiderSr
1,...,/hatwiderSrn/angbracketright
input : Termination threshold for constraint-satisÔ¨Åability
/epsilon1‚ààR‚à©[0,1]
input : Current round, round
output: Abstract composite service /hatwidestCSra/prime
, where
/hatwidestCSra‚äÜ/hatwidestCSra/prime
‚äÜCSr
a
1/hatwidestCSr
a/prime‚Üê/angbracketleft ‚àÖ 1,‚àÖ2,...,‚àÖ n/angbracketright;
2f o ri=1 tondo
3 serviceCount ‚Üê|/hatwiderSr
i|;
4 prob‚Üê1;
5f o r j=|/hatwiderSr
i|to|Sr
i|do
6 prob‚Üêprob¬∑(1‚àíPi(Sr
i[j]));
7 serviceCount ‚ÜêserviceCount +1 ;
8 p‚Üê2round‚àí1;
9i f (1‚àíprob )‚â•/epsilon11/pthen
10 break ;
11/hatwidestCSr
a/prime[i]‚Üê{sj‚ààSr
i|j‚àà[1,serviceCount ]};
12 return /hatwidestCSr
a/prime;
PRank sorts the services for each service class Si‚ààCS/prime
aby the
value ofLi(s)¬∑Pi(s), wheres‚ààSi, in the descending order.
The details of PRank can be found in Section 3.2. The reduced
abstract composite service /hatwidestCSr
ais initialized with empty service
classes (line 3), and the current round number round is initial-
ized to value 1 (line 4). After that, HReÔ¨Åne (see Algorithm 3)
is called to populate each service class of the reduced composite
function /hatwidestCSr
awith the representative services (line 6). Following
that, it is passed to the OptimalSelection function (line 7) for op-
timal selection, where the details will be introduced in Section 3.4.
The result of the optimal selection is stored in CS . If the optimal
selection is successful, i.e., when CS is not empty, the result is re-
turned (line 9); otherwise, we proceed to the next round of P ROHR.
This continues until all concrete services are explored, i.e., when
/hatwidestCSr
a=CSr
a(line 11). If the optimal selection cannot Ô¨Ånd a result,
an empty result is returned (line 12).
Algorithm 3 presents the dynamic selection algorithm. Initially,
the reduced abstract composite service /hatwidestCSr
a/primeis initialized with empty
service classes. For each service class (line 2), the serviceCount
is initialized to the number of services in service class /hatwiderSr
i(line 3),
and the accumulated probability prob is initialized with 1 (line 4).
Starting from index |/hatwiderSr
i|, we accumulate the constraint satisfac-
tion probability of service Sr
i[j], until it exceeds the threshold /epsilon11/p,
wherep=2round‚àí1(lines 5‚Äì10). Note that the threshold /epsilon11/pin-
creases with the number of rounds. The reason is based on the as-
sumption that if there exists an optimal selection, concrete services
in the optimal selection are likely to be ranked higher by the rank-ing algorithm in respective service classes. Therefore, at the start-
ing round, choosing a smaller amount of services that are rankedhigher from each service class will decrease the solving time for
the optimal selection. Conversely, the chance of getting a feasibleselection decreases when the number of rounds increases. Hence,
choosing a larger amount of services at later rounds will lead to
a faster exploration of all concrete services, especially in the case
where there does not exist a feasible selection.
Afterwards, the respective service classes in /hatwidestCS
r
a/primeare then pop-
90ulated with the representative services with the amount equals to
serviceCount (line 11). Finally, we return the reduced compos-
ite service /hatwidestCSr
a/prime, which contains the newly inserted representatives
(line 12).
For T AS, the number of services that are chosen at each round
depends on the termination threshold for constraint-satisÔ¨Åability /epsilon1.
If/epsilon1=0.4, then for the Ô¨Årst round, we get the reduced compos-
ite service /hatwideTASr
a=/angbracketleft/angbracketleftf2/angbracketright,/angbracketlefth2/angbracketright/angbracketright.OptimalSelection (/hatwideTASra)will
return a feasible selection TAS =/angbracketleftf2,h2/angbracketright, which is also the opti-
mal selection for T AS example. Since a feasible selection is found,
T AS terminates at the Ô¨Årst round of HReÔ¨Åne .I f/epsilon1=0.9, for the
Ô¨Årst round, we get /hatwideTASr
a=/angbracketleft/angbracketleftf2,f1,f3/angbracketright,/angbracketlefth2,h1,h3/angbracketright/angbracketright=TASr
a.
OptimalSelection (/hatwideTASr
a)will return the same optimal solution as
in the former case where /epsilon1=0.4. However, since there are more
concrete services, it might take longer time to solve for the latter
case where /epsilon1=0.9. We will investigate how different values of /epsilon1
affect the service selection process in Section 4.
3.4 Solving for Optimal Selection
In this section, we introduce the use of Mixed Integer Programming
(MIP) to realize the OptimalSelection at line 7 of Algorithm 2.
Mixed Integer Programming (MIP) is a technique for minimization
or maximization of an objective function subjected to a set of con-straints. A binary decision variable x
ijis used to represent the se-
lection of service candidates sij. If a service candidate is selected,
thenxijis set to 1, and to 0 otherwise. By Equation (4), an MIP
model can be speciÔ¨Åed as a maximization of the objective functionbelow:
r/summationdisplay
k=1Gmax(k)‚àíF(k)n
j=1/summationtext|Sj|
i=1qk(sij)¬∑xij
Gmax(k)‚àíGmin(k)¬∑wk (10)
subjected to the QoS constraints
(F(k)nj=1/summationtext|Sj|
i=1qk(sij)¬∑xij)‚â§Ck,1‚â§k‚â§r (11)
whererandnare the total number of attributes and service classes
respectively. In addition, since we only choose one service per
service class, the following constraint must be hold.
/summationtext|Sj|
i=1xij=1,1‚â§j‚â§n (12)
There are several tools or libraries that can be used to solve the MIPmodel, examples are Gurobi solver [20] and lpsolve solver [13]. Weomit the technical details of MIP , and refer the readers to [32]. Notethat to solve the above MIP model requires the linearization of the
objective function and the QoS constraints, the reader can refer [8]
for more details.
3.5 Complexity Analysis
In this section, we analyze the complexity of P ROHR (Algorithm 2).
Letnbe the number of service classes, mbe the number of com-
peting services for the service class with the largest number of com-peting services, and kbe the total number of QoS attributes for each
service.
Representative selection. The Preprocess function (Algorithm 1)
makes use of two functions ConstraintPruning and NonSkylinePrun-
ing. The complexity of ConstraintPruning fornservice classes
isO(nm) . The complexity of NonSkylinePruning fornservice
classes is O(nm¬∑logm)fork=2,3andO(nm¬∑(logm)
k‚àí2)for
k‚â•4[14, 23]. As a side note, we intentionally let ConstraintPrun-
ing run before NonSkylinePruning, because ConstraintPruning has
lower complexity ‚Äì after ConstraintPruning, some competing ser-
vices might be pruned, and it will result in faster NonSkylinePrun-
ing. The complexity of the PRank function is O(nm¬∑(logm)),since it only incurs sorting in each service class. The complexity of
iteratively invoking HReÔ¨Åne (Algorithm 3) is O(nm) , since it runs
iteratively until all competing services are included. To conclude,
the complexity for representative selection (i.e., Algorithm 2 with-
out the OptimalSelection function) is bounded by the complexity
ofNonSkylinePruning.
0 - 1 Integer Linear Programming Problem. OptimalSelection
function is essentially solvinga0-1integer linear programmingproblem, which is a well-known NP-complete problem. Therefore,
Algorithm 2 is NP-complete. The ultimate goal of the represen-
tative selection is to reduce the number of competing services re-
quired to be solved by the OptimalSelection function, in order to
improve the overall performance for Algorithm 2.
4 Evaluation
We conducted experiments to evaluate our approach to service se-
lection using P ROHR.
4.1 Research Quesions
We attempted to answer the following research questions (RQ1 ‚ÄìRQ4).
RQ1. How is the performance of P
ROHR in comparison to the
state-of-the-art?We analyze how different stages contribute to the performance of
P
ROHR. Firstly, we investigate how well service preprocessing
performs. In particular, what is the number of services that arepruned in the service preprocessing stage. Secondly, we also lookinto the performance of P
ROHR algorithm without the constraint
pruning preprocessing. The reason is to facilitate the comparison
with the state-of-the-art, as well as to enable us to evaluate how well
the probabilistic ranking and hierarchical reÔ¨Ånement work withoututilizing the constraint pruning preprocessing. Lastly, we evaluate
the performance of P
ROHR as a whole.
RQ2. How is the accuracy of the concrete services that are selected
by P ROHR?
We measure the accuracy using the following formula:
accuracy =G(CS heu)
G(CS exact)(13)
whereG(CS heu)andG(CS exact)are the global optimality values
of concrete services returned by heuristic method and exact methodrespectively.RQ3. How scalable is P
ROHR?
RQ4. How do different termination threshold values /epsilon1inÔ¨Çuence
the selection process of P ROHR?
4.2 Experiment Setup
Implementation. We implemented all algorithms in C#. For solv-
ing the mixed integer programming models, we used the Gurobi
solver [20]. The experiments were conducted on an Intel Core i7-
4600U CPU with 8 GB RAM, running on Windows 7.Experimental Setup. To answer the previous research questions,
we evaluate P
ROHR using a real-world dataset [4]. We compare
our methods with [9] which is the existing state-of-the-art for theoptimal selection of services, to the best of our knowledge. Foreffective comparison, we choose to use dataset of anti-correlated
distribution, as it presents the most challenging dataset for methodsthat make use of non-skyline pruning [9]. Note that both [9] andour methods utilize non-skyline pruning in the preprocessing stage.
Methods to compare. We compare the efÔ¨Åciency of the following
methods.
91500 1,500 2,500 3,500 4,500100100010000
Service Class SizeComputation Time (ms)(a) Performance
ProHR
ProHRSky
KMeans
Exact
500 1,500 2,500 3,500 4,5009095100
Service Class SizeAccuracy (%)(b) Accuracy
ProHR
ProHRSky
KMeans
Exact
500 1,500 2,500 3,500 4,5000200400
Service Class SizeComputation Time (ms)(c) Different ST
0.9
0.7
0.3
0.1
500 1,500 2,500 3,500 4,5000100200300
Service Class SizeComputation Time (ms)(d) Different ST (Worst-case)
0.9
0.7
0.3
0.1
Figure 5: Experiment results
500 1,500 2,500 3,500 4,50005,00010,000
Service Class SizeComputation Time (ms)ProHR
ProHRSky
KMeans
Exact
Figure 6: Worst-case performanceName Agg. Type Name Agg. Type
Response Time Sum - Compliance Mult +
Availability Mult + Best Practices Mult +
Throughput Min + Latency Sum -
Successability Mult + Documentation Mult +
Reliability Mult +
Figure 7: QoS attributes
Size 1,000 2,000 3,000 4,000 5,000
NonSkyline (%) 23.1 29.7 34.4 38.0 40.2
Constraint (%) 91.8 91.1 91.0 90.9 90.6
Preprocess (%) 92.1 91.5 91.7 91.8 91.6
Figure 8: Preprocess results
1.ProHR: Our method described in Section 3.
2.ProHRSky: Our method described in Section 3, with the modi-
Ô¨Åcation that only non-skyline pruning is used in the preprocessing
stage.3.KMeans: The hierarchical k-means clustering method proposed
in [9].
4.Exact :The standard global optimization problem for all service
candidates represented in the MIP model.
The reason for adding ProHRSky is because KMeans is also using
non-skyline pruning as their preprocessing method. Using the same
preprocessing method will allow both methods to reduce the sameamount of services at the preprocessing stage, therefore enable us
to compare the strength of the service selection algorithms for thesetwo methods.Dataset. We make use of the QWS dataset [4], which is a pub-
lic dataset collected from public registries, search engines and ser-vice portals, using a specialized Web crawler. The dataset con-tains 2,507 Web services and there are a total of 9 QoS attributesmeasured using commercial benchmark tools. More details on the
dataset can be found at [5, 6]. In our experiments, there are Ô¨Åve ser-vice classes. For each round of experiments, the concrete services
for the service classes are randomly chosen from the QWS dataset.
We generate 10 sets of QoS constraints Q={Q
1, ...,Q10}, where
i‚àó5% of the QWS services satisfy constraints Qi. For example, 5%
of the QWS services satisÔ¨Åes Q1. For each round of experiments,
we randomly select a QoS constraint from Q.
QoS Attributes. The details of these QoS attributes can be found
in Figure 7. The Name and Agg. columns in Figure 7 provide the
names of the QoS attributes and the aggregation functions (Sum-
mation (Sum), Multiplication (Mult ), Minimum (Min)) for those
attributes. The Type column shows whether these attributes are neg-
ative (‚Äì) or positive (+). We randomly partition the dataset into 10service classes and the QoS constraints are set randomly. We runeach experiment for 500 times and report the average values of the
metrics.
4.3 Experiments
We conduct several experiments (E1 ‚Äì E6) to answer the researchquestions (R1 ‚Äì R4). For experiments E1 to E4, we set the termina-
tion threshold at 0.9, and different termination thresholds are eval-
uated in experiments E5 and E6. For experiments E1 to E3, there
92exists a feasible selection that can satisfy the global constraints. We
report our Ô¨Åndings in the following.
E1: We record the number of services that have been pruned using
non-skyline pruning (NonSkyline), constraint pruning (Constraint ),
and the combination of both pruning methods (Preprocess). The
numbers reported are the percentage of services that are prunedwith respect to the total number of services. The experiment re-
sults can be found in Figure 8.Results. The non-skyline pruning has achieved 23.1% ‚Äì 40.2% re-
duction rate. As the dataset for experiment has anti-correlated dis-
tribution, and it is known that the non-skyline pruning does not per-form well in such dataset [9], therefore we can expect the method
to perform better for datasets of different distributions (e.g., corre-
lated distribution). For constraint pruning, it has achieved 90.6% ‚Äì91.8% reduction rate. The high reduction rate is attributed to thereason that a seemingly lenient global constraint of composite ser-
vice can result in a high expectation of the QoS attribute of compo-
nent services. For example, the global constraint of availability isset to 0.1, and since there are 10 service classes, the average avail-ability of the involved component services that need to fulÔ¨Åll theglobal constraint is (0.1)
1/10‚âà0.8. Therefore, it results in high
reduction rate when combined with the constraint reduction usingresponse time attribute. Another observation is that, when thesetwo pruning methods are combined (Preprocess), it can achieve a
reduction rate that is greater than any individual pruning method
applied alone.
E2: We compare the computation time with respect to the number
of services for each service class, which varies from 500 to 5000.
The experiment results can be found in Figure 5(a).Results. We notice that both ProHR and ProHRSky have signiÔ¨Åcant
improvement over Exact and KMeans methods. Since ProHRSky
and KMeans are both using the same preprocessing method (non-
skyline pruning), this result suggests that probabilistic ranking andhierarchical reÔ¨Ånement of ProHR have provided faster performance
over KMeans. Interestingly, although substantial number of ser-
vices have been pruned by constraint pruning, ProHR has only
achieved slight improvement of performance over ProHRSky. This
result suggests that the services that are pruned by constraint prun-
ing are ranked lower by probabilistic ranking algorithm, and ser-vices that are part of the feasible selection are ranked higher. There-
fore, the hierarchical reÔ¨Ånement effectively locates a feasible selec-tion by using a signiÔ¨Åcant smaller subset of the services in a service
class.
E3: We compare the accuracy with respect to the number of ser-
vices for each service class, which varies from 500 to 5000. The
experiment results can be found in Figure 5(b).Results. We notice that all methods achieve accuracy higher than
90%. For ProHR and ProHRSky, both have outperformed KMeans
by achieving almost 100% accuracy. This result shows that the ser-
vice ranking algorithm of ProHR has accurately ranked the service,
such that the feasible selection that has been chosen by the hierar-
chical reÔ¨Ånement algorithm is near-optimal or optimal selection.
E4: We compare the computation time with respect to the number
of services for each service class, which varies from 500 to 5000, in
the case where it does not exist a selection that can satisfy the global
constraints. The experiment results can be found in Figure 6.Results. We notice that KMeans has fast-growing computation
time. The reason is that KMeans appliesk-means clustering at each
round of selection, and it is known that k-means clustering is NP-hard in the worst case. Therefore, this makes the method sensitiveto the number of services. We also notice that ProHRSky outper-
forms KMeans signiÔ¨Åcantly. There are two reasons for this. Firstly,
ProHRSky only incurs sorting at the start of the selection, and it
does not incur extra operations between rounds of selection. Sec-ondly, the number of services that are used for selection increasessigniÔ¨Åcantly at each round; therefore, it effectively explores all ser-
vices in the service classes in a few number of rounds. ProHRSky
is slower than Exact due to the extra time that it spent on multi-
ple rounds of hierarchical reÔ¨Ånements before all concrete services
in the service classes are explored at the Ô¨Ånal round ‚Äì while for
Exact , it explores all services from the beginning. We also ob-
serve that ProHR outperforms Exact . This is attributed to the con-
straint pruning preprocessing in ProHR, since most of the services
are pruned by constraint pruning due to the strict global constraints
that make no feasible selection, and this let ProHR achieve higher
performance than Exact .
E5, E6: We compare ProHR using different termination thresholds
with respect to the number of services for each service class, which
varies from 500 to 5000, in the case where it exists (E5) and does
not exist (E6) a selection that can satisfy the global constraints re-spectively. The results of experiments E5 and E6 are shown in
Figure 5(c) and Figure 5(d) respectively.
Results. It suggests that the smaller the value of termination thresh-
old, the faster it tends to complete. For example, the dynamic selec-tion algorithm with termination threshold of 0.1 tends to complete
faster than the other termination thresholds. This result is due to
the fact that the smaller the termination threshold, the fewer ele-
ments will be chosen in each round by the dynamic selection algo-
rithm. We illustrate why this can end up in a faster searching time
using an example. Suppose the services that are part of a feasi-
ble selection are all ranked at Ô¨Åfth position in their service classes.Dynamic selection algorithm with termination threshold of 0.1 can
choose fewer services (say Ô¨Åve services) at a single round, while
dynamic selection algorithm with termination threshold of 0.9 can
choose more services (say ten services) at single round. Although
the services selected by dynamic selection algorithm for termina-
tion thresholds 0.1 and 0.9 both contain the feasible services, but
dynamic selection algorithm for termination thresholds 0.1 will be
solved faster by the MIP solver since it contains fewer services.
Nevertheless, there is a disadvantage for choosing a smaller termi-nation threshold. Experiment E6 has shown that the dynamic se-
lection algorithm with smaller termination threshold tends to Ô¨Ånishslower, since fewer items that are chosen at each round will lead to
more rounds to iterate before all concrete services in each serviceclass are explored. It is therefore a tradeoff to choose a smaller ter-
mination threshold over a larger one.
Answer to Research Questions. .To answer the research questions
RQ1‚ÄìRQ3, we can see that both ProHR and ProHRSky outperform
KMeans in terms of performance, accuracy and scalability from
experiments E1‚ÄìE4. Research question RQ4 is answered by the
analyses of experiments E5 and E6.Threats to V alidity .There are several threats to validity. The Ô¨Årst
threat to validity is due to the fact that competing services are se-
lected from 2,507 services offered by the QWS public dataset. Al-
though the number of services is reasonably large, there could stillbe observations that do not make obvious by the set of QoS at-
tributes we obtained from these services. The second threat to va-lidity is stemmed from our choice to use a few example values as
experimental parameters, that include global constraints and termi-nation thresholds, in order to cope with the combinatorial explosion
93of options. To address these threats, it is clear that more experi-
mentations with different datasets and experimental parameters are
required, so that we can further investigate the effects that has notbeen made obvious by our dataset and experimental parameters.
5 Discussion
Worst case scenario. For our method, the worst case scenario hap-
pens when no optimal service selection exists. In such a case, our
method would need to go through multiple rounds of hierarchicalreÔ¨Ånement (Algorithm 3) and MIP solving until all services are in-
cluded in representative services. We can then conclude the non-existence of optimal service selection. However, the non-existence
of optimal service selection is normally due to overly restrictiveglobal constraints, which no service selection is able to satisfy. This
signiÔ¨Åes that the preprocessing algorithm (Algorithm 1) may haveremoved most of the competing services from the beginning. This
makes our algorithm still perform well in the worst case scenario.We have evaluated P
ROHR in the worst case scenario in Section 4.
Estimation of QoS values. In practice, the values of QoS at-
tributes may be obtained from the SLA of the service; for example,Amazon EC2 has guaranteed that the monthly uptime percentageof their services would be at least 99.95% [1]. The QoS values can
also be estimated based on past invocations of the service, by usingmethods such as [38, 27]. Based on the observation from past in-
vocations, the user can use an appropriate estimation method, suchas expected value or i-th percentile, according to the requirements
of the user. If a user requires an estimation of QoS value that holds
for most of the time, the user can make use of the expected value of
the observed values. On the other hand, if the user requires a moreconservative estimation, the user can, for example, make use of theQoS value at the 90-th percentile (i.e., the QoS value is worse than
90% of all observed values).
Pareto optimal solution. Given two service selection CS
1and
CS 2, where both satisfy all global constraints, the selection CS 1
is said to dominate CS 2,i f‚àÄi:q/prime
i(CS 1)‚â§q/prime
i(CS 2)‚àß‚àÉj:
q/prime
i(CS 1)<q/prime
i(CS 2), wherei,j‚àà{1,...,k}, andkis the num-
ber of QoS attributes. CS is called a Pareto-optimal solution ifCS
is not dominated by any other CS/primethat satisÔ¨Åes the global con-
straints. Our method with weighed QoS attributes (Equation (10))
is provable to produce a Pareto-optimal solution. For the proof,
interested readers can refer to [25], Theorem 3.1.2. To obtain mul-tiple Pareto optimal solutions, the user can run our method for sev-
eral times, with different weights for each QoS attribute each time.
6 Related Work
The problem of QoS-aware Web service selection and composi-tion has received considerable attention during recent years. In [36,37], the authors present an approach that makes use of global plan-
ning to search dynamically for the best concrete services for servicecomposition. Their approach involves the use of mixed integer pro-
gramming (MIP) techniques to Ô¨Ånd the optimal selection of com-ponent services. Ardagna et al. [11] extend the MIP methods to
include local constraints. Cardellini et al. [15] propose a method-
ology to integrate different adaptation mechanisms for combining
concrete services to an abstract service, in order to achieve a greater
Ô¨Çexibility in facing different operating environments. Our work isorthogonal to aforementioned works, as it does not assume par-
ticular formulation of the MIP problems. Although the methodin aforementioned works efÔ¨Åciently for small case studies, it suf-
fers from scalability problems when the size of the case studiesbecomes larger, since the time required grows exponentially withthe size of concrete services.
Yuet al. [35] propose a heuristic algorithm that can be used to
Ô¨Ånd a near-optimal solution. The authors propose two QoS com-
positional models, a combinatorial model and a graph model. The
time complexity for the combinatorial model is polynomial, whilethe time complexity for the graph model is exponential. However
the algorithm does not scale with the increasing number of web ser-vices. To address this problem, Alrifai et al. [9] present an approach
that prunes the search space using skyline methods, and they make
use of a hierarchical k-means clustering method for representative
selection. The work of Alrifai et al. is the closest to ours. Our
approach has several advantages over their approach. Firstly, their
work does not take into account of the provided global constraints
for representative selection. Therefore, it does not scale well withrespect to the number of attributes, and the performance can be sig-
niÔ¨Åcantly degraded by providing restrictive constraints. Secondly,making use of k-means clustering for the purpose of representa-
tive selection can be expensive since the operation is NP-hard in
general, while in our work, the worst-case performance of repre-
sentative selection is much lower (see details in Section 3.5).
Dionysis et al. [12] propose a method that allows users to specify
their perception of quality in terms of user-deÔ¨Åned quality model.Their method is based on a k-means approach to match the user
deÔ¨Åned quality model to the search engine‚Äôs quality model auto-
matically. Their work focuses on providing intuitive quality ab-
straction, and is not related to the optimal selection of services.Stephan et al. [33] propose a QoS-based service ranking and se-
lection approach. Their approach ranks the services according totheir satisfactory scores and selects the optimal service that satis-
Ô¨Åes users‚Äô QoS requirements. Raed et al. [22] propose a method
that makes use of analytical network process (ANP) to calculatethe weight associated with each QoS attribute and rank the service
based on users‚Äô satisfaction degrees. [33] and [22] can only be used
to choose for a single optimal service that can satisfy the users‚Äô QoS
requirements. In contrast, our work aims to select a set of servicesthat are optimal for a service composition.
In [29, 24], we propose approaches to synthesize the local time
requirement for component services given the global time require-ment of composite service. In this work, we focus on the set of
component services that not only can satisfy the global QoS con-
straint, but also provide the overall optimal QoS for the compositeservice. In [31], we propose the usage of evolutionary algorithm
to optimize the selection of competing features in software productline. In this work, our focus is to optimize the selection of compet-
ing services in service composition.
This work is related to analysis of service composition. In [16,
17, 28], we propose a method that enables integrated veriÔ¨Åcation
of functional and non-functional properties of service composition.
In [30], we leverage genetic algorithm in calculating the optimal
recovery plan during service failure. In this work, our focus is on
optimizing the service selection in service composition.
7 Conclusion and Future Work
In this paper, we have addressed the optimal selection problem by
proposing a new technique, namely the Probabilistic Hierarchical
ReÔ¨Ånement (P ROHR). The technique considerably improves the
current service selection approaches, by considering only a sub-
set of representatives that are likely to succeed, before exploring a
larger search space. The full search space will be explored only if
all the smaller search spaces have failed to produce a result. The
evaluation has shown great improvement over the existing methods.
For future work, we plan to investigate how P ROHR can be ex-
tended to other search-based software engineering [21] problems.
948 References
[1] Amazon EC2 service level agreement.
http://aws.amazon.com/ec2/sla/.
[2] Amazon Elastic Compute Cloud (Amazon EC2).
https://aws.amazon.com/ec2/.
[3] Microservices.
http://microservices.io/patterns/microservices.html.
[4] The QWS dataset.
http://www.uoguelph.ca/~qmahmoud/qws/.
[5] E. Al-Masri and Q. H. Mahmoud. Discovering the best Web
service. In WWW, pages 1257‚Äì1258, 2007.
[6] E. Al-Masri and Q. H. Mahmoud. QoS-based discovery and
ranking of Web services. In ICCCN, pages 529‚Äì534, 2007.
[7] M. Alrifai and T. Risse. Combining global optimization with
local selection for efÔ¨Åcient qos-aware service composition.
InWWW, pages 881‚Äì890, 2009.
[8] M. Alrifai, T. Risse, and W . Nejdl. A hybrid approach for
efÔ¨Åcient web service composition with end-to-end qosconstraints. TWEB, 6(2):7, 2012.
[9] M. Alrifai, D. Skoutas, and T. Risse. Selecting skyline
services for QoS-based web service composition. In WWW,
pages 11‚Äì20, 2010.
[10] D. Ardagna and B. Pernici. Global and local qos guarantee in
Web service selection. In Business Process Management
Workshops, pages 32‚Äì46. Springer, 2006.
[11] D. Ardagna and B. Pernici. Adaptive service composition in
Ô¨Çexible processes. IEEE Trans. Software Eng.,
33(6):369‚Äì384, 2007.
[12] D. Athanasopoulos, A. Zarras, and P . V assiliadis. Service
selection for happy users: making user-intuitive quality
abstractions. In SIGSOFT FSE, pages 32‚Äì35, 2012.
[13] M. Berkelaar, K. Eikland, and P . Notebaert. Open source
(mixed-integer) linear programming system.
http://lpsolve.sourceforge.net/.
[14] S. B√∂rzs√∂nyi, D. Kossmann, and K. Stocker. The skyline
operator. In Proceedings of the 17th International
Conference on Data Engineering, April 2-6, 2001,
Heidelberg, Germany, pages 421‚Äì430, 2001.
[15] V . Cardellini, E. Casalicchio, V . Grassi, F. L. Presti, and
R. Mirandola. Qos-driven runtime adaptation of service
oriented architectures. In SIGSOFT FSE, pages 131‚Äì140,
2009.
[16] M. Chen, T. H. Tan, J. Sun, Y . Liu, and J. S. Dong. V eriWS:
a tool for veriÔ¨Åcation of combined functional andnon-functional requirements of web service composition. In
ICSE, pages 564‚Äì567, 2014.
[17] M. Chen, T. H. Tan, J. Sun, Y . Liu, J. Pang, and X. Li.
V eriÔ¨Åcation of functional and non-functional requirements ofweb service composition. In ICFEM, pages 313‚Äì328, 2013.
[18] R. Chinnici, J.-J. Moreau, A. Ryman, and S. Weerawarana.
Web services description language (wsdl) version 2.0.
http://www.w3.org/TR/wsdl20/.
[19] M. Gudgin, M. Hadley, N. Mendelsohn, J.-J. Moreau, H. F.
Nielsen, A. Karmarkar, and Y . Lafon. Simple Object AccessProtocol (SOAP) V ersion 1.2.
http://www.w3.org/TR/soap12/.
[20] I. Gurobi Optimization. Gurobi optimizer reference manual.
http://www.gurobi.com.
[21] M. Harman and B. F. Jones. Search-based software
engineering. Information & Software Technology,
43(14):833‚Äì839, 2001.
[22] R. Karim, C. Ding, and C.-H. Chi. An enhanced
PROMETHEE model for QoS-based Web service selection.
InSCC, pages 536‚Äì543, 2011.
[23] H.-T. Kung, F. Luccio, and F. P . Preparata. On Ô¨Ånding the
maxima of a set of vectors. Journal of the ACM (JACM),
22(4):469‚Äì476, 1975.
[24] Y . Li, T. H. Tan, and M. Chechik. Management of time
requirements in component-based systems. In FM, pages
399‚Äì415, 2014.
[25] K. Miettinen. Nonlinear multiobjective optimization,
volume 12. Springer Science & Business Media, 1998.
[26] D. Pisinger. Algorithms for knapsack problems. PhD thesis,
University of Copenhagen, 1995.
[27] M. Silic, G. Delac, and S. Srbljic. Prediction of atomic web
services reliability based on k-means clustering. In
ESEC/SIGSOFT FSE, pages 70‚Äì80, 2013.
[28] T. H. Tan. Towards veriÔ¨Åcation of a service orchestration
language. In SSIRI, pages 36‚Äì37, 2010.
[29] T. H. Tan, √â. Andr√©, J. Sun, Y . Liu, J. S. Dong, and M. Chen.
Dynamic synthesis of local time requirement for servicecomposition. In ICSE, pages 542‚Äì551, 2013.
[30] T. H. Tan, M. Chen, √â. Andr√©, J. Sun, Y . Liu, and J. S. Dong.
Automated runtime recovery for QoS-based servicecomposition. In WWW, pages 563‚Äì574, 2014.
[31] T. H. Tan, Y . Xue, M. Chen, J. Sun, Y . Liu, and J. S. Dong.
Optimizing selection of competing features viafeedback-directed evolutionary algorithms. In ISSTA, pages
246‚Äì256, 2015.
[32] L. A. Wolsey. Mixed integer programming. Wiley
Encyclopedia of Computer Science and Engineering, 2008.
[33] S. S. Y au and Y . Yin. QoS-based service ranking and
selection for service-based systems. In IEEE SCC, pages
56‚Äì63, 2011.
[34] K. Y oon and C. Hwang. Multiple attribute decision making:
an introduction. Sage Publications, Incorporated, 1995.
[35] T. Y u, Y . Zhang, and K. Lin. EfÔ¨Åcient algorithms for Web
services selection with end-to-end QoS constraints. TWEB,
1(1):6, 2007.
[36] L. Zeng, B. Benatallah, M. Dumas, J. Kalagnanam, and Q. Z.
Sheng. Quality driven Web services composition. In WWW,
pages 411‚Äì421, 2003.
[37] L. Zeng, B. Benatallah, A. Ngu, M. Dumas, J. Kalagnanam,
and H. Chang. QoS-aware middleware for Web servicescomposition. IEEE Trans. Software Eng., 30(5):311‚Äì327,
2004.
[38] Y . Zhang, Z. Zheng, and M. R. Lyu. Wspred: A time-aware
personalized qos prediction framework for web services. In
ISSRE, pages 210‚Äì219, 2011.
95