Synthesizing Tests for Detecting Atomicity Violations
Malavika Samak
Indian Institute of Science, Bangalore
malavika@csa.iisc.ernet.inMurali Krishna Ramanathan
Indian Institute of Science, Bangalore
muralikrishna@csa.iisc.ernet.in
ABSTRACT
Using thread-safe libraries can help programmers avoid the com-
plexities of multithreading. However, designing libraries that guar-
antee thread-safety can be challenging. Detecting and eliminating
atomicity violations when methods in the libraries are invoked con-
currently is vital in building reliable client applications that use the
libraries. While there are dynamic analyses to detect atomicity vi-
olations, these techniques are critically dependent on eective mul-
tithreaded tests. Unfortunately, designing such tests is non-trivial.
In this paper, we design a novel and scalable approach for syn-
thesizing multithreaded tests that help detect atomicity violations.
The input to the approach is the implementation of the library and
a sequential seed testsuite that invokes every method in the library
with random parameters. We analyze the execution of the sequen-
tial tests, generate variable lock dependencies and construct a set of
three accesses which when interleaved suitably in a multithreaded
execution can cause an atomicity violation. Subsequently, we iden-
tify pairs of method invocations that correspond to these accesses
and invoke them concurrently from distinct threads with appropri-
ateobjects to help expose atomicity violations.
We have incorporated these ideas in our tool, named I ntruder ,
and applied it on multiple open-source Java multithreaded li-
braries. I ntruder is able to synthesize 40 multithreaded tests across
nine classes in less than two minutes to detect 79 harmful atomicity
violations, including previously unknown violations in thread-safe
classes. We also demonstrate the e ectiveness of I ntruder by com-
paring the results with other approaches designed for synthesizing
multithreaded tests.
Categories and Subject Descriptors
D.2.5 [ Software Engineering ]: Testing and Debugging‚Äî testing
tools ; F.3.2 [ Logics and Meanings of Programs ]: Semantics of
Programming Languages‚Äî program analysis
Keywords
atomicity violation; dynamic analysis; concurrency1. INTRODUCTION
Designing scalable and reliable multithreaded applications is
challenging due to the complexities associated with multithread-
ing. Oftentimes, developers of such applications avoid the com-
plexities by using thread-safe [24] libraries. These libraries are
structured such that concurrent invocation of methods from mul-
tiple clients always corresponds to some linearization of the asso-
ciated invocations [24, 16, 12]. Moreover, such libraries limit the
use of synchronizations to provide better performance [3] for the
client applications. Maintaining thread-safety without sacriÔ¨Åcing
performance can be a demanding task. Therefore, even if a library
(or component) is only partially thread-safe, specifying the context
under which thread-safety violations occur will enable the users of
the library to take corrective action.
Atomicity violations [9] are an important class of concurrency
defects in multithreaded programs. Many static analyses [18, 1]
and dynamic analyses [6, 23, 8, 32, 2] are designed to detect such
violations. One of the many advantages of dynamic analyses (over
static analyses) is that they can be used to reproduce an erroneous
execution corresponding to a reported defect. While various as-
pects pertaining to dynamic analyses including precision [8, 2],
scalability due to the number of interleavings [32, 23] and repro-
ducibility [22] have been investigated rigorously, their e ectiveness
is critically dependent on the presence of defect revealing multi-
threaded tests. Designing such tests requires nuanced understand-
ing of the implementation and is therefore not easy.
ConTeGe[24] attempts to address this problem by adopting a
brute-force approach to automatically generate multithreaded tests
and detect a violation by analyzing failing executions. While an
important Ô¨Årst step, the number of possible multithreaded tests is
signiÔ¨Åcantly large and the probability of generating a defect reveal-
ing multithreaded test can be quite low. Firstly , the pairs of methods
that need to be invoked concurrently is a function of the number of
methods in the class. Secondly , appropriate parameters need to be
passed to such invocations so as to trigger the violation which can
be combinatorial in the number of parameters. This necessitates
the design of a directed approach to e ectively synthesize multi-
threaded tests for detecting atomicity violations. In previous work,
we have designed and implemented directed approaches to synthe-
size multithreaded tests to enable detection of deadlocks [26] and
races [28]. Just as a race detector [30, 7] or a deadlock detector [14]
cannot be used to detect atomicity violations [22, 8], the afore-
mentioned synthesizers cannot be deployed for generating tests to
enable detection of atomicity violations.
In this paper, we present a novel and scalable approach for syn-
thesizing tests to enable detection of atomicity violations in multi-
threaded libraries. The implementation of the library and a sequen-
tial seed test-suite form the input to our approach. The output is a
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission and/or a
fee. Request permissions from Permissions@acm.org.
ESEC/FSE‚Äô15 , August 30 ‚Äì September 4, 2015, Bergamo, Italy
c2015 ACM. 978-1-4503-3675-8/15/08...$15.00
http://dx.doi.org/10.1145/2786805.2786874
131set of multithreaded tests such that appropriate methods are invoked
concurrently in each test from di erent threads. The key insight of
our technique is the derivation of specialized constraints by analyz-
ing the sequential execution and generation of a multithreaded test
that will satisfy the derived constraints when executed. Analyzing
the execution of the synthesized test using an atomicity violation
detector can help reveal (and conÔ¨Årm) the underlying bugs.
Our approach operates by analyzing the execution of the sequen-
tial tests in the seed testsuite. We maintain a record of the syn-
chronized blocks, the objects on which the locks are held, the Ô¨Åeld
accesses and their corresponding types (read or write) within each
block. We construct a set of properties that need to be satisÔ¨Åed in
a sequential execution to help identify whether a pair of consec-
utive Ô¨Åeld accesses can become potential candidates for atomicity
violation. We analyze the recorded information and identify the po-
tential candidate pairs of consecutive Ô¨Åeld accesses. Furthermore,
we identify a remote [23] access for each such candidate pair that
could be potentially interleaved between the consecutive accesses
in a multithreaded execution.
After identifying the three Ô¨Åeld accesses that can constitute an
atomicity violation, we identify the methods that need to be in-
voked concurrently. The parameters to the invocations should sat-
isfy a few constraints such that the locks and accesses happen on
theappropriate objects for the defect to manifest. These constraints
are derived from the analysis of the sequential execution. To obtain
the concrete objects required for the invocations in the synthesized
multithreaded test, we execute the relevant sequential tests multiple
times, suspend their execution and collect the necessary objects af-
ter driving them to the required state. The synthesized tests can be
used by any of the atomicity violation dynamic detectors [22, 23,
32] to detect the violations.
We have implemented a tool, named I ntruder , that incorporates
these ideas and evaluated it on a number of open-source multi-
threaded Java libraries and components. Our experimental results
show that I ntruder is able to generate e ective multithreaded tests
that expose many atomicity violations. We use an atomicity viola-
tion detector based on CT rigger [23] to detect atomicity violations
by analyzing the synthesized tests. We analyzed nine classes with
our approach that resulted in the synthesis of 40 multithreaded tests
leading to the detection of 79 harmful atomicity violations. The
time taken for the entire process is less than two minutes with neg-
ligible memory overhead. We also compare I ntruder with C on-
TeGe[24], O men[26] and N arada [28] and show the ability of our
approach in enabling detection of atomicity violations.
The paper makes the following technical contributions:
We develop an approach to synthesize multithreaded tests to en-
able detection of atomicity violations in library code by using the
implementation of the library under consideration and a sequen-
tial seed test suite as input.
Our approach analyzes sequential execution traces, identiÔ¨Åes the
methods that drive objects to states conducive for triggering an
atomicity violation and reuses existing sequential tests to gener-
ate the objects for the multithreaded execution.
We provide a detailed discussion of the design and implemen-
tation of our approach and validate our approach by analyzing
many open-source Java libraries.
We demonstrate the e ectiveness of our approach in synthesizing
eective tests for detecting atomicity violations compared to the
tests synthesized by C onTeGe[24],O men[26] and N arada [28].2. MOTIVATION
In this section, we provide a real example from colt , a popular
high performance scientiÔ¨Åc and technical computing library imple-
mented in Java to motivate the problem addressed in the paper.
The class DynamicBin1D is documented to be thread-safe and
hence multiple clients can invoke APIs concurrently without hold-
ing any additional locks.
DynamicBin1D.java:
------------------
581 synchronized DynamicBin1D sampleBootstrap(
DynamicBin1D other, ..., BinBinFunction1D function) {
584 // since "resamples" can be quite large, we care
about performance and memory
585 int maxCapacity = 1000;
586 int s1 = size();
587 int s2 = other.size();
593 DynamicBin1D sample2 = new DynamicBin1D();
594 cern.colt.buffer.DoubleBuffer buffer2 =
sample2.buffered(Math.min(maxCapacity,s2));
599 // resampling steps
600 for (int i=resamples; --i >= 0; ) {
601 sample1.clear();
602 sample2.clear();
604 this.sample(s1,true,randomGenerator,buffer1);
605 other.sample(s2,true,randomGenerator,buffer2);
606 bootBuffer.add(function.apply(sample1,sample2));
607 }
611 }
438 synchronized void sample(int n,
boolean withReplacement, ...) {
442 if (!withReplacement) { // without
...
449 else { // with
450 Uniform uniform = new Uniform(randomGenerator);
451 int s = size();
452 for (int i=n; --i >= 0; ) {
453 buffer.add(this.elements.getQuick(
uniform.nextIntFromTo(0,s-1)));
454 }
456 }
457 }
134 synchronized void clear() {
137 if (this.elements != null) this.elements.clear();
141 }
DoubleArrayList.java:
---------------------
217 / *You should only use this method when you are
absolutely sure that the index is within bounds. */
222 public double getQuick(int index) {
223 return elements[index];
224 }
Figure 1: Motivating example.
Figure 1 presents partial implementations of two classes from the
library. The implementations of sampleBootstrap ,sample
andclear from DynamicBin1D are shown in the Ô¨Ågure. As
shown, all the three methods are synchronized . The implementa-
tion of getQuick from DoubleArrayList is also shown in
the Ô¨Ågure where the comment above the implementation emphat-
ically places the burden of using the appropriate index on the
caller of the method.
We claim that clients using DynamicBin1D can observe vio-
lation of atomicity properties depending upon the invoked methods
and the objects on which the methods are invoked. More speciÔ¨Å-
cally, executing the multithreaded program shown in Figure 2 can
132public void testAtomicity() {
DynamicBin1D bin1 = new DynamicBin1D(...);
DynamicBin1D bin2 = new DynamicBin1D(...);
...
Thread t1 = new Thread() {
void run() { bin1.sampleBootstrap(bin2,...); }
}
Thread t2 = new Thread() {
void run() { bin2.clear(); }
}
}
Figure 2: Multithreaded test to expose atomicity violation.
expose the atomicity violation in DynamicBin1D when the fol-
lowing happens:
The Ô¨Årst thread initiates the execution of
bin1.sampleBootstrap .
After other.size at line 587 is executed by the Ô¨Årst thread,
bin2.clear is executed from the second thread clearing all
the elements in bin2 . This should invalidate the value of s2
obtained at line 587.
Subsequently, when other.sample(...) at line 605 is in-
voked from the Ô¨Årst thread, the loop in sample at line 452 ide-
allyshould not execute but is executed for a few iterations (de-
pending upon s2) incorrectly.
Elements from this.elements at line 453 are obtained
using invalid indices as part of the execution of the
loop conÔ¨Çicting with the comments given at line 217 in
DoubleArrayList.java .
Designing this multithreaded test manually is a non-trivial task
because it requires a nuanced understanding of DynamicBin1D
and the associated classes. More speciÔ¨Åcally, we need to iden-
tify that the methods sampleBootstrap andclear need
to be invoked concurrently among the 35 methods present in
the class. Even though there are at least four parameters to
sampleBootstrap , the necessary constraint that needs to be
satisÔ¨Åed is that its Ô¨Årst parameter and the receiver of clear need
to refer to the same object. Moreover, there may be scenarios where
the execution does not crash hiding the presence of the error from
the user. For example, the distribution of the elements returned
from sample can become biased (non-uniform) invalidating the
relevant statistical computations. When we apply [24, 26, 28],
none of the tools are able to synthesize this multithreaded test au-
tomatically. This is because [24] is random (and the maximum
time to generate tests was set as Ô¨Åve hours), [26] is searching for
deadlocks and [28] is searching for races.
public void test() {
DynamicBin1D bin1 = new DynamicBin1D(...);
DynamicBin1D bin2 = new DynamicBin1D(...);
...
bin1.sampleBootstrap(bin2,...);
bin1.clear();
}
Figure 3: Sequential seed test.
Using the analysis described in the paper, we are able to automat-
ically synthesize the multithreaded test shown in Figure 2. The im-
plementation of the library along with a sequential seed test shown
in Figure 3 forms the input to our analysis. We observe that a se-
quential seed testsuite that invokes each method in the class under
consideration once with random parameters can be used to synthe-
size defect revealing multithreaded tests. Moreover, writing suchsequential seed tests is trivial. We emphasize that in the sequen-
tial test, we invoke clear withbin1 instead of bin2 and yet
are able to synthesize the required multithreaded test. We analyze
the execution traces of the seed tests to construct the multithreaded
test. The rest of the paper describes our analysis that results in this
construction.
3. DESIGN
Instrumentor
Test GeneratorVariable‚àílock
DependenciesInstrumented
Library, TestsDependenciesVariable‚àílock
Access Analyzer
Atomicity DetectorFeasibilty ScannerPC‚àíR Pair Synthesizer
Defects Multithreaded TestsScannedSequential Tests Library
Multithreaded
TestsPC‚àíR Pairs
PC‚àíR Pairs
Figure 4: Overall Architecture
The architecture of our tool, named I ntruder , which generates
multi-threaded tests to enable detection of atomicity violations is
presented in Figure 4. The entire process of synthesizing the tests
is accomplished by integrating multiple components. The imple-
mentation of the library under test and the sequential seed testsuite
form the input to the Instrumentor which performs the nec-
essary instrumentation to track the lock acquisitions and releases,
variable accesses, method invocations, etc. Access Analyzer
takes as input the instrumented library and the sequential tests, ex-
ecutes the tests and monitors the execution to output variable-lock
dependencies , where a dependency speciÔ¨Åes the relation between
the access and the various locks in the execution. The accesses
are further analyzed by the PC-R Pair Synthesizer to derive
a set of PC-R pair accesses1. The underlying intuition is that if
these accesses are performed on the same object such that two ac-
cesses (previous and current) happen consecutively when a library
method is invoked from one thread and another (remote) access
happens due to a method invocation from a di erent thread such
that the remote access interleaves with the other two accesses, then
an atomicity violation can manifest. Feasibilty Scanner an-
alyzes the generated pairs and eliminates the pairs where the re-
mote access cannot interleave due to a variety of factors including
being guarded by the same locks. Test Generator uses the
feasible PC-R method pairs and the variable lock dependencies to
synthesize the multithreaded tests to expose atomicity violations.
These tests can then be used by a third-party detector (e.g., A tom-
Fuzzer [22], CT rigger [23], etc) to detect atomicity violations. For
our experiments, we use an atomicity violation detector based on
CTrigger to expose atomicity violations.
3.1 Preliminaries
In this section, we provide the necessary background for our ap-
proach by describing a few primitives. To be able to synthesize
a test, it is necessary to identify the defective accesses, the abil-
ity of a client to inÔ¨Çuence accesses and its ability to drive objects
to states conducive for a defect to manifest. For this purpose, we
1PC-R stands for previous, current and remote [23].
133use the primitives symbol ,controllable andsetter deÔ¨Åned in
[28] and brieÔ¨Çy describe them here for the sake of completeness.
We provide the explanations on a running example from Figure 5.
We deÔ¨Åne a variable to be controllable if it references an object
within the implementation of a library that can be manipulated by
clients through library methods. The controllability of the variable
persists until it is reassigned to a reference that cannot be manip-
ulated by the client (e.g., a newly allocated object). For example,
in Figure 5, the variable xis controllable as it holds a reference to
this.f where this (and thereby this.f ) can be manipulated
by a client. We use a primitive controllable (var) to identify the
controllability of var.
class A {
B f = new B();
void sync foo() {
B x = this.f;
int c = x.getCount();
x.setCount(c+1);
}
void sync setF(B b) {
this.f = b;
}
}class B {
int count = 0;
int sync getCount() {
return count;
}
void sync setCount(int c) {
this.count = c;
}
}
Figure 5: Running example; synchronized is shortened to sync.
We deÔ¨Åne an assignment in the implementation of a library
method to be writeable provided both sides of the assignment are
controllable and the assignment is to a Ô¨Åeld. Intuitively, this pro-
vides a mechanism for the client to assign a reference of choice to
the Ô¨Åeld of an object which can be helpful in driving an object to
a desired state. For example, in Figure 5, the assignment of the
parameter to the Ô¨Åeld fin method setF is writeable because both
sides of the assignment are controllable and the Ô¨Åeld fof the ob-
ject is updated. In contrast, the assignment to xin method foo is
not writeable because it does not update a Ô¨Åeld. We deÔ¨Åne write-
able methods as the methods which contain writeable assignments.
Clients can invoke a sequence of these methods to drive the object
to a desired state. In the running example, the method setF is a
writeable method.
For our analysis, we will need to be able to assign some
Ô¨Åeld o:f1:f2:::fnto a desired object so that we can have two
dierent containers oand o0, such that o:f1:f2:::fi:::fn=
o0:f1:f2:::fi:::fn, while o:f1:f2:::fi,o0:f1:f2:::fifor some
i(0<i<n). To achieve this, we deÔ¨Åne a primitive
setter (x;y), where x=o:f1:f2:::fiandy=o:f1:f2:::fi:::fn,
to return a sequence of writeable methods that enable setting of
o:f1:f2:::fi:::fkto an object as speciÔ¨Åed by the client, where
i<kn. While ideally kshould be equal to n, even if kis some
value between iton, it satisÔ¨Åes the above mentioned requirement.
For the running example, setter (a,a.f) returns a unit length se-
quence setF that helps set a.f suitably.
We build aliases of variables for each method invocation afresh.
Irrespective of the value of the references used as parameters2dur-
ing a method invocation, each parameter is aliased with a fresh
symbol. We also perform a deep walk of various Ô¨Åelds of the pa-
rameters and associate them with fresh symbols. Subsequently, for
an assignment x:=y, we associate xto be aliased with the symbol
foryand its Ô¨Åelds to alias with the symbol associated with the Ô¨Åelds
ofy. In this manner, we maintain alias sets per program point. We
deÔ¨Åne a primitive symbol that takes a variable and returns its asso-
ciated symbol.
2We include the receiver as the Ô¨Årst parameter of the invocation.For example, if a client executes a.setF(b) twice consecu-
tively, then before the Ô¨Årst invocation of setF , the variables a,
a.f andbwill be aliased to three dierent symbols ( i0;i1;i2).
Therefore, symbol (a),symbol (a.f) and symbol (b) will return
i0,i1andi2respectively. After executing the assignment in setF ,
a.f andbbecome aliases. For the second invocation, even though
the references pointed by a.f andbare equal, the parameters and
their Ô¨Åelds are aliased with fresh symbols similar to the Ô¨Årst invo-
cation. This enables the analysis to di erentiate variables that are
aliases due to the design of the API (e.g., this.f andbbefore
returning from setF ) as compared to the design of the invoking
client (e.g., the two invocations of setF as shown above). For the
purposes of synthesizing tests, we are interested in the aliases due
to the design of the API.
For a symbol in, we deÔ¨Åne a set of relevant locks {i0;i1;:::; ing
where ii=symbol (o:f1:f2:::fi),i0=symbol (o) and ois an in-
put parameter. This is because there is a strong correspondence
between the locks in the relevant lockset with the symbol under
consideration. We explain this using the following method rand :
public void rand(U u) {
synchronized(u.f1) { ...access(u.f1.f2.f3)... };
}
a Ô¨Åeld u.f1.f2.f3 is accessed while a lock on u.f1 is held.
The relevant lock set for accessing Ô¨Åeld f3inu.f1.f2 is{u,
u.f1, u.f1.f2} which includes u.f1 . Even though, initially,
it appears that the above code is a safe way of accessing the Ô¨Åeld,
we emphasize that such constructs can be deceptive. If a client can
setu.f1.f2 to an object of its choice, then it can take two distinct
objects oando0and set o.f1.f2 ando0.f1.f2 to refer to the same
object. Subsequently, when rand (o) and rand (o0) methods are
invoked concurrently, o.f1ando0.f1dier and both threads enter
the synchronized region and simultaneously access o.f1.f2.f3
ando0.f1.f2.f3 which correspond to the same memory loca-
tion. To expose such subtle violations, we maintain the relevant
lock set where all possible preÔ¨Åxes of a dereference are considered
interesting.
The analysis underlying the implementation of the primitives,
controllable ,setter andsymbol is described elaborately in
[28]. We build an approach that leverages these primitives ap-
propriately. We now describe each component of I ntruder elab-
orately.
3.2 Instrumentor
The implementation of the library and the sequential tests form
the input to the Instrumentor . It instruments the library imple-
mentation to process the instructions corresponding to lock acqui-
sition and release, and Ô¨Åeld accesses. It also provides a mechanism
to identify the boundary between the client (in our case, sequential
tests) and the library implementation to enable initialization of ap-
propriate data structures for further analysis. This is to di erentiate
the method invocation in the library from another method within
it as opposed to invocation from the client. The initialization will
happen only in the latter scenario. The appropriately instrumented
code and tests form the input to the next phase of the analysis.
3.3 Access Analyzer
The main goal of this phase is to record all Ô¨Åeld accesses and
maintain information pertaining to the locks. We deÔ¨Åne two kinds
of locksets ‚Äì set of held locks for an access and set of consistently
held locks for a pair of accesses. The held locks specify the locks
held for the access. The consistently held locks specify the locks
held for the pair of consecutive accesses without being released
between the two accesses. Maintaining the set of consistently held
134locks enables further phases to identify possible locations to violate
atomicity.
TheAccess Analyzer executes the sequential tests on the in-
strumented code and appropriately processes the relevant instruc-
tions. It outputs a set of variable lock dependencies that corre-
sponds to each Ô¨Åeld access in the library. More speciÔ¨Åcally, it main-
tains the following structures, with the variable lock dependencies
(D) forming the Ô¨Ånal output.
H22S, where S=S ymbolN
HC22S ymbol;RL:S ymbol7!2S ymbol
AI:S ymbol7!2F, where F:Field7!fR;W;?gf N[?g
D22P, where P=S ymbolFieldfR;W;?gf R;WgHHC
Recall from Section 3.1 that a fresh symbol is associated with
each parameter. These symbols are from S ymbol (i0,i1, . . . ). When
a method is invoked from a client, the parameters and the various
Ô¨Åelds reachable from them are assigned fresh symbols from this set.
We deÔ¨Åne Hto maintain the information pertaining to the currently
held locks and also associate a timestamp pertaining to when the
lock is obtained. The timestamp is a counter which is incremented
on every lock acquisition and release and is obtained from the set
of natural numbers ( N).HCis the set of consistently held locks.
We also maintain a relevant lockset ( RL) that is a mapping from a
symbol to a set of symbols as discussed in Section 3.1.
We maintain a map pertaining to the access information ( AI). For
each symbol, it maintains information corresponding to all Ô¨Åelds in
the object associated with the symbol. The information for the Ô¨Åeld
include its most recent access kind (read, write or unknown) and
the timestamp of this access. Initially, all accesses are unknown
(?). We also maintain D, which is a set of tuples specifying the
variable lock dependencies for each access, where the six elements
in each tuple are as follows: the symbol of the referenced object,
the accessed Ô¨Åeld, the kind of the previous access, the kind of the
current access, the set of held locks, and the set of consistently held
locks for the current and previous accesses of the Ô¨Åeld.
Algorithm 1 genVarLockDependency
1:H ; 0
2: Initialize AIandRL;
3:s next executable instruction;
4:while s is not return from the client invoked method do
5: ifsis read( var,f ield ) and controllable(var) then
6: recordAccess (var;f ield;R)
7: else if sis write( var,f ield ) and controllable(var) then
8: recordAccess (var;f ield;W)
9: else if sis lock( var)then
10: Increment by one
11: Add ( symbol (var);) toH
12: else if sis unlock( var)then
13: Increment by one
14: Remove the element ( symbol (var);) from H
15: s next executable instruction;
When a library method is invoked from the client, Algorithm 1 is
applied. His initialized to empty and the timestamp reset to 0. We
also initialize AIandRLas mentioned previously. If the executed
instruction is a lock or a release, the timestamp is incremented and
His updated accordingly (lines 9-14). If the instruction is an access
to a controllable variable, then recordAccess (see Algorithm 2)
is invoked with the appropriate access kind (lines 5-8).In Algorithm 2, we obtain the symbol associated with the vari-
able that is being accessed using symbol . The consistently held
locks ( HC) is initialized to empty (line 1). Then, information per-
taining to the previous access of the Ô¨Åeld is obtained from AI(line
2). For all the currently held locks, we obtain the relevant held locks
(HR) based on RLandH3. Subsequently, between lines 4 to 6, for
each relevant held lock, we check whether the lock is acquired be-
fore the previous access of the currently accessed Ô¨Åeld and HCis
updated accordingly. The tuple pertaining to the access is added to
D(line 7) and the Ô¨Åeld access information is also updated (line 8).
Algorithm 2 recordAccess
Input: var: dereferenced variable, f ield : accessed Ô¨Åeld in var,:
access kind.
1:i symbol (var);Hc 
2: (p;p) AI[i][f ield ]//previous access kind and timestamp
3:HR locks (H)\RL[i]
4:foreach lock`inHRdo
5: iftimestamp (`;H)pthen
6: HC HC[symbol (`)
7:D D[D
i;f ield;p;;HR;HCE
8:AI[i][f ield ] (;)
We now illustrate the process when a.foo() is invoked for
some object afrom a sequential test on the code given in Figure 5.
Algorithm 1 is invoked and fresh symbols i0andi1are allocated.
i0andi1corresponding to objects referenced by aanda.f respec-
tively. AIis initialized to { i07! ff7!(?;?)},i17! fcount
7!(?;?)}}, and RLis initialized to { i07!fi0g,i17!fi1;i0g}.H
andare initialized to empty and zero respectively.
Table 1: State changes when a.foo() is invoked by client.
Instruction AI H
lock(a) f(i0;1)g1
read(this,f) {i07!ff7!(R;1)g,
i17!fcount7!(?;?)gg
lock(x) f(i0;1);2
(i1;2)g
read(x,count) {i07!ff7!(R;1)g;
i17!fcount7!(R;2)gg
unlock (x) f(i0;1)g3
lock(x) f(i0;1);4
(i1;4)g
write (x,count) {i07!ff7!(R;1)g;
i17!fcount7!(W;4)gg
unlock (x) f(i0;1)g5
unlock (a)  6
Table 1 presents the updated AI,Handwhile executing the
list of instructions. Before lock(a) is executed, is incremented
andHupdated to {( i0;1)}. When read(this,f) happens, AIis
updated to reÔ¨Çect the read offat timestamp equals one. Moreover
observe that even though the method getCount is within the li-
brary, the states are not reset because the invocation is also within
the library. The remaining rows are obtained similarly.
Table 2 presents the set of variable lock dependencies ( D) that
are created based on the accesses observed during the execution of
a.foo() . When read(this,f) happens, the symbol corre-
sponding to the variable this isi0, the Ô¨Åeld accessed is f, there
is no previous access of the Ô¨Åeld f, the current access is a read,
the set of held locks correspond to { i0} and Ô¨Ånally due to the ab-
sence of any previous access, the set of consistent locks is also { i0}.
3locks (H) returns the list of locks without the timestamp from H.
135Table 2: D: Tuples after executing a.foo() ;i0=a,i1=i0:f.
Instruction Variable-lock dependency ID
read(this,f)hi0;f;?;R;fi0g;fi0gi d1
read(x,count)hi1;count;?;R;fi0;i1g;fi0;i1gid2
write (x,count)hi1;count;R;W;fi0;i1g;fi0gi d3
When write (x,count) is performed, recordAccess Ô¨Ånds a
previous read access to count at=2. Moreover, it obtains the
relevant locks for i1to be { i1,i0} from RLand performs an inter-
section with the symbols associated with held locks { i1,i0} (line
3 of Algorithm 2). When it iterates over these locks, it Ô¨Ånds that
the lock associated with i1is obtained at =4 which is greater
than the timestamp for the previous access. In contrast, it detects
that the lock associated with i0is obtained at =1 which is less
than the timestamp for the previous Ô¨Åeld access ( =2). Hence,
the consistent lock set becomes { i0}. In other words, we derive that
some object represented by i0is held without being released for two
consecutive accesses of the Ô¨Åeld count .
The set of variable-lock dependencies that are recorded for each
access during the execution of the test is used subsequently to con-
struct a set of three accesses that contribute to an atomicity vio-
lation. We now discuss the synthesis of variable-lock dependency
pairs which can encode such access triplets.
3.4 PC-R Pair Synthesizer
For each variable lock dependency, we record the previous and
current access of the associated Ô¨Åeld. We will precisely use this
data along with the current access from a di erent variable lock de-
pendency to construct the set of three accesses. The process of de-
tecting atomicity violations using the previous ( p), current ( c) and
remote ( r) accesses was used successfully in CT rigger [23]. Even
though we do not have multiple threads (because the analysis is on
sequential executions) unlike CT rigger , we build our approach to
synthesize the PC-R pairs inspired by their formulation.
*a b
R(o, f)
W(o‚Äô, f)
W(o, f)*a b
R(o, f)
W(o‚Äô, f)
R(o, f)*a b
W(o, f)
R(o‚Äô, f)
W(o, f)*a b
W(o, f)
W(o‚Äô, f)
R(o, f)
Figure 6: Four pairs of variable-lock dependencies that can help
expose problematic interleavings.
Figure 6 presents four di erent pairs ( a;b) of variable lock de-
pendencies. Let us consider the Ô¨Årst pair of variable lock depen-
dencies (the left most in the Ô¨Ågure). The ain the Ô¨Årst pair speciÔ¨Åes
that there is a sequential test invoking a library method that reads
o:fconsecutively. Here pandcare reads. The bin the pair is
due to another invocation to a library method (possibly the same as
before) where there is one write access to o0:f. Here ris a write.
Even though the Ô¨Årst invocation accesses o:fand the second invo-
cation accesses o0:f(dierent memory locations), we observe that
if we synthesize a test that makes the second invocation such that
it also accesses o:ffrom a di erent thread, we can potentially ob-
serve an atomicity violation. Moreover, the previous access in the
second invocation is irrelevant because it is only necessary for one
problematic access to interleave with the Ô¨Årst invocation. There-
fore, the previous access in bis denoted as *. The other three pairs
of variable lock dependencies can be explained similarly.
Four other pairs (out of eight possible combinations) that are not
shown in the Ô¨Ågure cannot be used to introduce an atomicity vi-olation. For example, if the access in bin the right most pair (in
Figure 6) is a write instead of a read, then the interleaving cannot
cause an atomicity violation even if the memory locations are the
same [23]. Hence, we discard such pairs of variable lock depen-
dencies while synthesizing the PC-R pairs.
Algorithm 3 PC-R Pair Synthesizer
1:T 
2:forall ordered pairs a;b2Ddo
3: ifgetField (a)=getField (b)then
4: c current (a) ;p previous (a)
5: r current (b)
6: ifc=Randr=Wthen
7: ifp,?then add ( a;b) toT
8: else if c=Wthen
9: ifp=Randr=Wthen add ( a;b) toT
10: else if p=Wandr=Rthen add ( a;b) toT
Algorithm 3 presents the algorithm to synthesize the PC-R pairs.
It performs the analysis by considering all ordered pairs of depen-
dencies ( a;b) in D, where aandbare distinct. If the Ô¨Åelds as-
sociated with the dependencies are the same (fully qualiÔ¨Åed Ô¨Åelds
obtained using the auxiliary function getField ), it obtains p,cand
rusing the auxiliary functions current andprevious . It applies
the checks illustrated in Figure 6 and adds the ordered pair accord-
ingly (lines 6-10). The set of triplet accesses (represented as a pair)
will be available in Tat the end of the phase.
When this algorithm is applied on Dshown in Table 2, we get
T=f(d3;d3)g. This is because the Ô¨Åeld under consideration is
A.f.count , the p,candrareR,WandWrespectively. There are no
other pairs that satisfy the constraints speciÔ¨Åed in the algorithm.
3.5 Feasibility Scanner
The combination of accesses derived as mentioned above is nec-
essary to expose an existing atomicity violation. However, the anal-
ysis does not consider the locks that are held during the accesses
which can cause some of the combinations to become infeasible.
The underlying intuition with this phase is that if a lock `is held
forpandcaccesses without being released in the interim and a
lock`is also held for the access corresponding to r, then the PC-
R pair access becomes infeasible. In this section, we describe our
approach for identifying the feasibility of the derived PC-R pairs
from the previous phase based on their lock dependencies.
We deÔ¨Åne auxiliary function path which takes two symbols
as input and returns the path between their corresponding deref-
erences. For example, if the symbol xcorresponds to i0:f0:::fi
andycorresponds to i0:f0:::fi:::fn, then path (x;y) will return
fi+1:::fn. The auxiliary function type returns the fully qualiÔ¨Åed
type of the object corresponding to the input symbol.
For any dereference o:f1:f2:::fn, we deÔ¨Åne the preÔ¨Åx
o:f1:f2:::fn 1todominate the preÔ¨Åx o:f1:f2:::fn 2, and so on.
We deÔ¨Åne an auxiliary function dominant that takes two symbols,
Ô¨Ånds the associated dereferences and returns the dominating sym-
bol.?is dominated by all symbols. The dominant function is used
to determine the dominating lock for an access. The dominant lock,
if it exists, needs to be broken for an atomicity violation to mani-
fest. In other words, during the invocation of some method, if locks
ono:f1,o:f1:f2,:::,o:f1::::fiare acquired, and the atomicity vio-
lation needs to happen on o:f1::::fi:::fn, then all locks up to and
including o:f1::::fineed to be distinct to ensure concurrent access
when the methods are invoked from separate threads. However, at
least one of the subsequent Ô¨Åelds from o:f1::::fi:fi+1needs to re-
136fer to the same object so that the memory location on which the
violation needs to happen becomes shared.
Figure 7: Illustration for the need for detecting dominant locks.
We explain this using the illustration shown in Figure 7. We have
accesses of count such that di erent locks are held. The memory
locations associated with count are also di erent. For the atomic-
ity violation to manifest, the memory location for count needs to
be the same as shown in the modiÔ¨Åed pair in Figure 7(a). Also, the
locks need to be distinct so that the interleaving becomes possible.
Our approach needs to consider the dominant lock dependency so
that a useful test is generated. Otherwise, when the test is run, the
dominant lock guards the shared access preventing any detection.
Sometimes, detection of dominant locks helps identify when vio-
lation is never feasible. For example, in Figure 7(b) (based on the
code given in Figure 8), the dominating lock and the object contain-
ing the Ô¨Åeld are the same. Therefore, there is no way of modifying
the Ô¨Åelds to induce an atomicity violation.
Algorithm 4 Feasibility Scanner
1:TS 
2:foreach ( a;b)2Tdo
3: HC consistentLocks (a) ;HR heldLocks (b)
4: i symbol (a);j symbol (b)
5: dom ?
6: foreach pair;whereinHC;inHRdo
7: ifpath (;i)=path (;j) and type ()=type ()then
8: dom dominant (;dom)
9: ifdom=?then add ( a;b;?) toTS
10: else if dom,iandsetter (dom;i)) exists then
11: add ( a;b;setter (dom;i)) to TS
We now describe the approach of detecting feasibility by using
the information pertaining to held locks, consistent locks and the
associated dominant locks. Algorithm 4 takes as input the set of
synthesized PC-R pairs ( T) from the previous phase and outputs
the feasible PC-R pairs in the set ( TS). For every ordered pair ( a;b)
inT, it gets the consistent locks for the Ô¨Årst element aand the
held locks for the second element b. The consistent lock is neces-
sary for the Ô¨Årst element because it locks pandcaccesses whereas
held locks su ces for the second element. There can be multiple
consistent and held locks. Therefore, we identify the most domi-
nant lock that guards all the accesses (lines 5 - 8). The absence of
a dominant lock suggests that it is possible to interleave the PC-
R pair access appropriately. Therefore, we add the corresponding
PC-R pair to the set of feasible pairs (line 9). Furthermore, if the
dominant lock is not the same as the containing object and setter
(deÔ¨Åned in Section 3.1) exists to change the containing object so
that the dominating locks are broken, the PC-R pair also becomes
feasible (lines 10 - 11).
We illustrate this on the running example from Figure 5 and Ta-
ble 2. Tis given byf(d3;d3)g,HCisfi0gandHRisfi0;i1g, theaccessed Ô¨Åeld is count , the containing object is i1, and the dom-
inant lock ( dom) isi0. As there is a setter setF such that i0:f
(represented by i1) can be set by invoking the method on i0, the pair
under consideration becomes feasible and the next phase attempts
to synthesize a multithreaded test corresponding to this pair ‚Äì invo-
cation of method foo by two threads with appropriate objects.
class A {
...
C g = new C();
void sync bar() {
C y = this.g;
int size = y.getSize();
y.setSize(size+1);
}
void zee () {
C y = this.g;
y.incSize();
}
}class C {
int size = 0;
int sync getSize() {
return size;
}
void sync setSize(int s) {
this.size = s;
}
void sync incSize() {
this.size++;
}
}
Figure 8: ModiÔ¨Åed running example. The :::inArepresents the
deÔ¨Ånitions of f,foo andsetF from Figure 5.
We modify the running example to explain when the ordered
pairs can become infeasible. Figure 8 presents the additional meth-
ods in class Aand also presents the implementation of class C.
When two objects a‚Äôanda‚Äùof type Aare created and methods
bar andzee are invoked on them, the generated variable lock de-
pendencies are shown in Table 3. It shows the accesses of the Ô¨Åeld
gandsize from these two methods and the corresponding held
and consistent locks after applying Algorithm 1.
Table 3: D: set of tuples after executing a‚Äô.bar() and
a‚Äù.zee() where i2=a‚Äô,i3=i2:g,i4=a‚Äù,i5=i4:g.
Instruction Variable-lock dependency ID
read(this,g)hi2;g;?;R;fi2g;fi2gi d4
read(y,size)hi3;size;?;R;fi2;i3g;fi2;i3gid5
write (y,size)hi3;size;R;W;fi2;i3g;fi2gi d6
read(this,g)hi4;g;?;R;fg;fgi d7
read(y,size)hi5;size;?;R;fi5g;fi5gi d8
write (y,size)hi5;size;R;W;fi5g;fi5gi d9
When PC-R pairs are synthesized for the tuples shown in Table 3
and Table 2, we get the Ô¨Åve pairs shown in the second column of
Table 4. The associated method invocations are also given in the
Ô¨Årst column of the table. We have already discussed the feasibility
of (d3;d3) above. The second pair ( d6;d6) is not feasible because
there is a guard lock A:this (i2) when method bar is invoked.
Therefore, unless there is a mechanism to set the Ô¨Åeld this.g (i3),
the violation on Ô¨Åeld size in it is not possible. Because there is
no setter for this.g other than the constructor, the pair becomes
infeasible.
Table 4: Feasibility Scanner execution for modiÔ¨Åed running exam-
ple from Figure 8. F represents feasibility of PC-R pair.
Method PC-Rhi;ji dom F Reason
Pairs Pairs Guard Setter
foo,foo (d3;d3)hi1;i1i i03 A.this setF
bar,bar (d6;d6)hi3;i3i i27 A.this -
bar,zee (d6;d9)hi3;i5i?3 - -
zee,bar (d9;d6)hi5;i3i i57 C.this -
zee,zee (d9;d9)hi5;i5i i57 C.this -
The third pair ( d6;d9) is feasible because there is no lock that
is consistently held during the invocation of bar that is also held
137during the write in incSize . The only held lock is i5whose type
isCand the consistent lock i2‚Äôs type is A. Therefore, line 7 in Al-
gorithm 4 fails causing the pair to be feasible. In other words, the
write to size inincSize from one thread can potentially inter-
leave between the two accesses of size inbar from a di erent
thread. Interestingly, the reversal of this pair ( d9;d6) is infeasible
because the consistent lock is given by i5whose type is Cand the
held lock (when size is written in setSize frombar) isi3whose
type is also C. Because the consistent lock is the same as the object
whose Ô¨Åeld is being updated, the test of dom,ifails at line 10 in
the algorithm making this pair infeasible. The infeasibility of the
Ô¨Åfth pair can be explained on similar lines.
3.6 Test Generator
Every PC-R pair that is output by the previous phase is processed
to synthesize a multithreaded test. The pair references two meth-
ods (one method corresponding to the PC accesses, and the other
method corresponding to the R access) that need to be invoked by
two threads to expose a potential atomicity violation. However, re-
call that the PC accesses can happen on o:fand the R access can
happen on o0:f(see Section 3.4). Therefore, the parameters to these
invocations should be such that the accesses are to the shared loca-
tion. Synthesizing such parameters and writing a test is addressed
in this phase.
We use the sequential tests to generate the parameters for the
method invocations. This is because our analysis has already wit-
nessed invocations to the methods and objects of the necessary
types can be generated. This is achieved by re-executing the se-
quential test upto the required library invocation, suspending the
execution and collecting the actual parameters that will be passed
to the invocation. This results in the collection of objects that are
instantiated and driven to the required state appropriately. For each
PC-R pair, we execute the sequential tests twice to reach the corre-
sponding method invocations and collect the necessary objects.
Algorithm 5 Test Generator
1:foreach ( a;b;)2TSdo //is the setter
2: i symbol (a);j symbol (b)
3: ma getMethod (i) ;mb getMethod (j)
4: Oa collectObjects (ma);
5: Ob collectObjects (mb)
6: Osa collectSetterObjects (i);
7: Osb collectSetterObjects (j);
8: shareObjects (Osa;Osb;Oa;Ob)
9: Invoke setter methods sequentially with objects in Osa
10: Invoke setter methods sequentially with objects in Osb
11: Invoke mawith Oaandmbwith Obfrom distinct threads
Algorithm 5 depicts the outline where for every PC-R pair, we
obtain the two methods that need to be invoked concurrently (lines
2-3). Subsequently, we execute the relevant sequential tests upto
the method invocation and collect the objects for the invocation
(lines 4-5). The collected objects cannot be reused directly because
these invocations need not necessarily access the same memory lo-
cations. For example, if the Ô¨Åeld of the receiver is accessed in the
two method invocations, the sequential tests may be invoking the
methods on two di erent objects. On the other hand, blindly shar-
ing the required objects can prevent exposing the defect. This is
because there may be dominating locks before the access and when
the methods are invoked concurrently, interleaving may become in-
feasible.
We use the methods from the sequence returned by the setter
primitive (described in Section 3.1) to drive the corresponding ob-jects to the required state. These setters are already recorded for
each pair and available as . The objects for invoking the methods
in the sequence returned by setter is achieved by re-executing the
sequential test appropriately (lines 6-7). Subsequently, we share the
objects between the two methods corresponding to the PC-R pair
(line 8). If the setter methods require other parameters, the corre-
sponding parameter values in the sequential test are used accord-
ingly. Essentially, if there is an atomicity violation on o:f1:f2:::fn,
then we need to have the same reference to the Ô¨Åeld from di er-
ent object instances. After executing the setter methods which will
drive the objects to the desired states (lines 9-10), we invoke the
methods corresponding to the PC-R pair from two distinct threads
(line 11). The entire process of executing sequential tests, collect-
ing objects, sharing them appropriately and then concurrently exe-
cuting the methods forms the multithreaded test.
We will explain the process for the running example and use the
PC-R pair ( d3;d3) (see Table 4). The sequential test under consid-
eration is
A a = new A(); B b = new B();
a.setF(b); a.foo();
The corresponding symbols are hi1;i1iand the associated methods
arefoo andfoo respectively. The necessary objects for invoking
the methods are obtained, Oa=fa1gandOb=fa2g, where the se-
quential test is invoked twice and executed until the invocation of
foo with a1anda2being the object instances in the executions re-
spectively. setter (i0;i1) returnsfsetFgand needs to be executed
in the context of each method. Therefore, the setter objects are col-
lected as Osa=fa3;b3g, and Osb=fa4;b4g. These instances are
obtained by re-executing the sequential test (subscript denotes the
run number). Invocation of shareObjects at line 8modiÔ¨Åes
the sets to Osa=fa1;b3g;Osb=fa2;b3g;Oa=fa1g;Ob=fa2g. We
invoke a1:setF (b3) and a2:setF (b3) at lines 9and10respectively.
This results in the Ô¨Åeld fofdistinct objects a1anda2referenc-
ingb3. Two distinct threads invoke methods foo ona1anda2
respectively at line 11. This is the required test case which can be
analyzed by an existing atomicity violation dynamic detector [22,
23, 32].
4. EXPERIMENTAL VALIDATION
We have implemented I ntruder using the soot bytecode instru-
mentation framework [34] and evaluated it on many open source
multithreaded Java libraries, that include thread-safe classes. We
perform the experiments on Ubuntu-14.04 desktop running
on a 3.5 Ghz Intel Core i7 processor with 16GB RAM. Table 5
presents the information pertaining to the benchmarks used for
our experiments. colt is a high performance scientiÔ¨Åc comput-
ing library, openjdk is the Java development kit, Carbonado
is an extensible, high performance persistence abstraction layer,
CometD is a scalable HTTP-based event routing bus, eXo is a
open-source social-collaboration software, Batik is a toolkit for
applications to use images in SVG format, and OpenNLP is a ma-
chine learning based toolkit for processing natural language text.
The classes analyzed in the benchmarks are shown in the table. We
choose these classes based on whether the class is either declared
thread-safe or contains synchronized /volatile keyword in its imple-
mentation. We studied the e ectiveness of I ntruder in synthesiz-
ing atomicity violation revealing tests and also compared with other
multithreaded test synthesizers [24, 26, 28]. We used an atomicity
violation detector based on CT rigger [23] to analyze the executions
of the synthesized tests.
Table 6 presents the information on the number of synthesized
tests and the number of true atomicity violations present in the ref-
138Table 5: Benchmark Information.
Benchmark Version Class Name ID
Colt 1.2.0 DynamicBin1D C1
OpenJdk 1.7 StringBu er C2
Vector C3
Carbonado 1.2.3 SkipCursor C4
Cometd 2.7.0 TimesyncClientExtension C5
eXo 3.8.2 ApplicationStatistic C6
PortalStatistic C7
Batik 1.7 CompositeGraphicsNode C8
OpenNLP 1.5.3 PerformanceMonitor C9
erenced classes. The number of methods in the classes varies from
4 to 50. We build a sequential seed testsuite that invokes every
method in the class once and supply random objects based on the
type of the parameters to the invocations. The number of lines of
code in each class is given which correspond only to the starting
point of the method invocation. These invocations invoke methods
from other classes in the package.
Table 6: Experimental Results. T: Unique PC-R pairs, TS: Number
of synthesized tests, A: number of atomicity violations, TP: True
Positives.
Class |M|LoC Time(s) Pairs |T||TS||A||TP|
C1 35 313 33.9 269 44 11 33 24
C2 50 239 11.1 16 8 8 16 8
C3 43 431 12.7 10 6 6 12 6
C4 4 47 3.1 14 3 3 9 0
C5 7 60 3.6 2 1 1 2 2
C6 7 48 1.5 1 1 1 1 1
C7 6 45 1.4 1 1 1 1 1
C8 40 596 15.5 44 8 7 58 36
C9 6 92 2.4 2 2 2 1 1
Total 85.2 359 74 40 133 79
Executing the sequential seed testsuite and deploying I n-
truder results in the synthesis of a number of atomicity violation
revealing multithreaded tests in less than two minutes. This demon-
strates the scalability of our approach in that it intelligently invokes
the relevant combination of methods with appropriate objects from
a large state space. The number of PC-R pairs that are synthesized
for all the classes is 359 which includes a few redundant pairs. The
redundancy corresponds to multiple accesses of Ô¨Åelds due to loops,
similar pairs of accesses (e.g., Ô¨Åeld accesses with HandHCbeing
the same for di erent Ô¨Åelds), etc. We eliminate these redundan-
cies and the number of unique PC-R pairs ( |T|, output of PC-R
Pair Synthesizer ) is 74. Application of the Feasibility
Scanner reduces the overall number of pairs and triggers the gen-
eration of 40 tests. A signiÔ¨Åcant number of the pairs from C1are
reduced due to the presence of a guard lock (a common lock be-
tween the consistently held lock set of pandcand the held lock set
ofr) and the absence of setter methods to manipulate the internal
Ô¨Åelds.
The number of feasible PC-R pairs ranges from one to eight and
also corresponds to the number of multithreaded tests synthesized
by Intruder . These tests help expose 133 possible violations. On
careful observation, we Ô¨Ånd that the number of possible violations
is more than the number of tests (e.g., 33 possible violations with
11 tests for C1). This is because we had earlier eliminated redun-
dant PC-R pairs. Since, the violations exist on di erent Ô¨Åelds in the
classes in the context of the same method invocation, the defects are
reported accordingly. Out of the 133 possible defects, manual anal-
ysis reveals the presence of 79 true positives (atomicity violations).
This is because even if the interleaving is problematic (as shownin Figure 6), all violations do not lead to a user-observable faulty
behavior.
 0 20 40 60 80 100
C1 C2 C3 C4 C5 C6 C7 C8 C9percentage
benchmarksdefects
0123-5>5
Figure 9: Distribution of tests.
The distribution of tests as a function of the number of detected
(harmful) atomicity violations is given in Figure 9. We observe that
a minor percentage of the synthesized tests expose only benign vio-
lations (reported as zero defects) as mentioned above. In the case of
C1andC8, a few tests expose more than Ô¨Åve violations. Moreover,
for test cases that expose multiple violations, potentially a single
Ô¨Åx can help eliminate multiple violations. The implementation and
the raw experimental data (synthesized tests and bugs) are publicly
available4and we refer the reader to it for more details.
Table 7: Comparison with other test synthesizers. TO: Generated
test cases, TP: True positive atomicity violations.
Class ConTeGe Omen Narada
|TO||TP||TO||TP||TO||TP|
C1 9k 0 10 0 6 0
C2 1.3k 0 0 0 0 0
C3 31k 0 15 0 0 0
C4 274 0 0 0 0 0
C5 174 0 0 0 0 0
C6 172 0 0 0 0 0
C7 165 0 0 0 0 0
C8 10k 0 0 0 4 20
C9 1.2k 0 0 0 0 0
Total 53k 0 25 0 10 20
We also studied the e ectiveness of C onTeGe[24], O men[26]
and N arada [28] in enabling the detection of atomicity violations
and present our Ô¨Åndings in Table 7. Because C onTeGeemploys
a randomized approach, we set a limit on the number of su x
generations, an internal parameter to bound the tests. The tool is
self-contained and reports any violations without requiring an ex-
ternal detector to detect violations. For the sake of comparison, we
record the number of tests generated internally by C onTeGe. Un-
fortunately, it was unable to detect any atomicity violations even
after generating 53k tests and executing for Ô¨Åve hours approxi-
mately. While running it longer will likely expose more violations,
this demonstrates the drawbacks of employing randomization to
synthesize tests. O men synthesized 25 multithreaded tests corre-
sponding to C1andC3which reveal a few deadlocks but does not
expose any atomicity violations. When we apply N arada , it syn-
thesizes 10 multithreaded tests. While the six tests synthesized for
C1do not reveal any atomicity violations (detects a few races), the
four tests synthesized for C8expose 20 harmful violations. This
is coincidental because the concurrent method invocations expose
4http://www.csa.iisc.ernet.in/~sss/tools/intruder
139races apart from atomicity violations. Interestingly, this makes the
remaining 59 defects due to I ntruder more compelling. This is
because even though precaution is taken to avoid races by guard-
ing the Ô¨Åelds appropriately, the code is not robust enough to avoid
atomicity violations. O menand N arada fail to synthesize tests for
many classes due to the absence of potential deadlocks and races in
these classes respectively.
4.1 Discussion
In this paper, our primary focus is on detecting violations on
individual variables. The detection of atomicity violations due to
multiple variables requires an understanding of the set of variables
that need to be handled atomically [17]. Designing an approach
to synthesize tests to detect such atomicity violations is left for the
future.
We do not consider data Ô¨Çow constraints as part of our synthesis.
Consequently, this can potentially suppress the synthesis of a few
multithreaded tests. More speciÔ¨Åcally, if a seed test has multiple
instances of an object required by the multithreaded test, we choose
one object instance randomly5. Also, the setter could potentially
change the overall control Ô¨Çow of the methods under test due to
unintended state modiÔ¨Åcations. Despite these design choices, our
experimental results on the benchmarks show that I ntruder is able
to synthesize useful tests.
In our experiments, we used a sequential seed testsuite that in-
vokes every method in the class once with random objects as pa-
rameters to the corresponding invocations. We adopted this ap-
proach to demonstrate that even with such a simple sequential test-
suite, I ntruder is able to synthesize many atomicity violation re-
vealing multithreaded tests. Obviously, the quality of the multi-
threaded tests is dependent on the input sequential seed testsuite.
For example, if the code pertaining to an atomicity violation is
not covered by the sequential test, our approach will be unable to
synthesize a multithreaded test. Apart from developing a manual
sequential seed testsuite as described above, we can also generate
these testsuites using automatic test generators (R andoop [21], E vo-
Suite[10]). Another possibility is to use the testsuites that accom-
pany the implementation of the libraries. Previous experience [26]
shows that using tests generated using automated approaches or
manually designed by third-party developers is less e ective. Nev-
ertheless, we plan to elaborately study the impact of employing
various sequential seed testsuites on synthesizing e ective multi-
threaded tests as part of future work.
5. RELATED WORK
Synthesizing multithreaded tests to detect bugs in thread-safe li-
braries has been helpful in identifying many previously unknown
concurrency bugs [24, 26, 28]. In [24], the authors propose a ran-
domized approach for generating multithreaded tests and run the
test multiple times. If the concurrent execution results in an excep-
tion and the corresponding sequential execution succeeds, then a
potential thread-safety violation is detected. Even though, this ap-
proach can detect atomicity violations along with races and dead-
locks, a fundamental drawback of the approach is the randomized
nature of generating tests in an extremely large state space. B al-
lerina [20] generates multithreaded tests by concurrently invoking
random methods on the object under test. While useful in detect-
ing concurrency bugs, the approach is not suitable for synthesiz-
ing complex tests. For example, the test shown in Figure 2 cannot
5If two method invocations require the same object to be passed as
parameters, then our approach will use the same random object for
both invocations.be synthesized by B allerina as concurrent invocations on di er-
ent objects are required. C onSuite[33] is another e ective tool for
generating unit tests for concurrent classes but its deÔ¨Ånition of con-
currency coverage may not cover all possible atomicity violations.
Previously, we have designed and implemented multithreaded
test synthesizers for detecting deadlocks [26, 27] and races [28].
Unfortunately, these approaches cannot be used to synthesize tests
to detect atomicity violations. This is because the properties that
are being analyzed during a sequential execution are directed to-
wards deadlocks and races respectively. In Section 4, we also com-
pare I ntruder with C onTeGe[24], O men [26] and N arada [28],
and show that the synthesized tests by these tools are ine ective in
detecting atomicity violations.
There are a number of dynamic analyses that have been designed
to detect atomicity violations. A tomizer [6] integrates the ideas
from E raser [29] and Lipton‚Äôs theory of reduction [15] to identify
possible interference by other threads in an atomic block. V elo-
drome [8] is a sound and complete atomicity checker that reports
an error ithe observed trace is not conÔ¨Çict serializable. CT rig-
ger[23] uses minimum execution perturbation to expose low prob-
ability interleavings. D ouble Checker [2] uses two phases of dy-
namic analyses to enable precise detection of atomicity violations
eciently. P enelope [32] explores alternative schedules e ectively
to detect atomicity violations. A tomFuzzer [22] deploys fuzzing
techniques to detect the bugs. There are numerous other techniques
that are designed that address the problem of detecting atomicity
violations. In this paper, we propose an approach for synthesizing
tests that can form the input to any one of these techniques.
Static analysis techniques [18, 1] have also been applied to de-
tect concurrency bugs including atomicity violations. Employing
a dynamic technique provides an opportunity for the developer to
have a reproducer [22] which can enable reasoning about the cor-
rectness of the reported defect. Our approach helps generate the
necessary tests for such dynamic analyses. Other testing frame-
works like chess [19] that systematically explore the state space for
detecting bugs can greatly beneÔ¨Åt from our synthesized tests.
Many approaches have been designed for automatically generat-
ing tests [11, 31, 4, 5, 21]. These approaches have been developed
in the context of sequential programs that deploy a combination of
concolic testing and feedback directed test generation. In this pa-
per, we explore the synthesis of multithreaded tests by analyzing
sequential test executions. Frameworks for ease of writing mul-
tithreaded tests [13, 25] address a di erent dimension of detecting
bugs in multithreaded programs. These frameworks provide an eas-
ier interface for developers to specify the various interleavings to
be tested and help eliminate the non-determinism from the multi-
threaded tests. The tests generated by our implementation can be
subsequently refactored into these frameworks for regression test-
ing.
6. CONCLUSIONS
We motivate the need for e ective multithreaded tests to detect
atomicity violations in thread-safe libraries and components. We
design a lightweight approach that analyzes sequential executions
to synthesize defect-revealing multithreaded tests. We incorporate
the design as part of a tool, named I ntruder , and demonstrate that
it is able to synthesize 40 tests for multiple open-source Java li-
braries and helps in the detection of 79 (including previously un-
known) harmful atomicity violations.
1407. REPLICATION PACKAGE
The implementation and experimental results of I ntruder6has
been successfully evaluated by the Replication Packages Evalua-
tion Committee and found to meet expectations. The tool is pack-
aged as a bootable VM image and is structured as follows:
benchs
classes
lib
saved_output
C1
...
saved_output_vm
C1
...
scripts
test
test1
...
README.txt
benchs contains the benchmarks used for the evaluation of
Intruder along with the sequential seed tests written by us.
libcontains the supporting jar Ô¨Åles used by the tool and the
benchmarks.
tests contains simple test cases which correspond to various
aspects of Java multithreading.
7.1 Setup
There are two environmental variables, INTRUDER_CLASSPATH
and CTRIGGER , that need to be set appropriately. These variables
are initialized by executing source ./scripts/init.sh . By
default, the atomicity violation detection is turned o . The default
setting runs faster as it only synthesizes the multithreaded tests.
The atomicity violations exposed by the generated tests can be de-
tected by setting CTRIGGER toON.
7.2 Usage
Simple Test:
To test the tool, a simple test can be used by executing sh
./scripts/test2.sh . The source Ô¨Åles related to the test are con-
tained in tests/test2 . The library implementation provided for
this test contains one atomicity violation which should be detected
with the help of a test case that is generated. The generated output
is placed in ./output/test2 .
The total number of generated tests and the detected atomic-
ity violations are reported in summary.txt .
The generated multithreaded tests are named:
TestDriver<testNum>.java , where <testNum> is
the index of each test case.
The output of atomicity violation detection for test
case TestDriver<testNum>.java will be placed in
TestCase_<testNum>_output.txt .
6http://www.csa.iisc.ernet.in/~sss/tools/intruderBenchmarks:
To test a class C<id> , execute sh ./scripts/C<id>.sh .
The output will be placed in ./output/C<id> .
All the classes can be tested with a single command by exe-
cuting sh ./scripts/benchmark.sh .
Thread safety violations might be witnessed during the execution of
the generated tests and can lead to exceptions. The number of atom-
icity violations detected (when CTRIGGER =ON) is dependent on the
execution schedule and can vary from the numbers reported in the
paper. Also, the numbers reported in this paper are on bare metal
and the tool runs slower on the VM. Therefore we provide the saved
output of running the benchmarks on bare metal in saved_output .
We also provide the output of running the benchmarks on the VM
insaved_output_vm .
8. ACKNOWLEDGEMENTS
We thank the anonymous reviewers for their feedback which
helped improve the presentation of the paper. We thank Anuta
Mukherjee for implementing the atomicity violation detector used
in our experiments. We are grateful to Google India and Microsoft
Research India for providing travel support. This work is partially
supported by the Ministry of Human Resources and Development,
Government of India.
9. REFERENCES
[1] N. Ayewah and W. Pugh. The Google FindBugs Fixit. In
Proceedings of the 19th International Symposium on
Software Testing and Analysis , ISSTA ‚Äô10, pages 241‚Äì252,
2010.
[2] S. Biswas, J. Huang, A. Sengupta, and M. D. Bond.
Doublechecker: E cient sound and precise atomicity
checking. In Proceedings of the 35th ACM SIGPLAN
Conference on Programming Language Design and
Implementation , PLDI ‚Äô14, pages 28‚Äì39, 2014.
[3] J. Bogda and U. H√∂lzle. Removing unnecessary
synchronization in Java. In Proceedings of the 14th ACM
SIGPLAN Conference on Object-oriented Programming,
Systems, Languages, and Applications , OOPSLA ‚Äô99, pages
35‚Äì46, 1999.
[4] C. Cadar, D. Dunbar, and D. Engler. KLEE: Unassisted and
automatic generation of high-coverage tests for complex
systems programs. In Proceedings of the 8th USENIX
Conference on Operating Systems Design and
Implementation , OSDI‚Äô08, pages 209‚Äì224, 2008.
[5] C. Cadar and D. Engler. Execution generated test cases: How
to make systems code crash itself. In Proceedings of the 12th
International Conference on Model Checking Software ,
SPIN‚Äô05, pages 2‚Äì23, 2005.
[6] C. Flanagan and S. N. Freund. Atomizer: A dynamic
atomicity checker for multithreaded programs. In
Proceedings of the 31st ACM SIGPLAN-SIGACT Symposium
on Principles of Programming Languages , POPL ‚Äô04.
[7] C. Flanagan and S. N. Freund. Fasttrack: E cient and
precise dynamic race detection. In Proceedings of the 2009
ACM SIGPLAN Conference on Programming Language
Design and Implementation , PLDI ‚Äô09, 2009.
[8] C. Flanagan, S. N. Freund, and J. Yi. Velodrome: A sound
and complete dynamic atomicity checker for multithreaded
programs. In Proceedings of the 2008 ACM SIGPLAN
Conference on Programming Language Design and
Implementation , PLDI ‚Äô08.
141[9] C. Flanagan and S. Qadeer. A type and e ect system for
atomicity. In Proceedings of the ACM SIGPLAN 2003
Conference on Programming Language Design and
Implementation , PLDI ‚Äô03, pages 338‚Äì349, 2003.
[10] G. Fraser and A. Arcuri. EvoSuite: Automatic test suite
generation for object-oriented software. In Proceedings of
the 19th ACM SIGSOFT Symposium and the 13th European
Conference on Foundations of Software Engineering ,
ESEC /FSE ‚Äô11, pages 416‚Äì419, 2011.
[11] P. Godefroid, N. Klarlund, and K. Sen. Dart: Directed
automated random testing. In Proceedings of the 2005 ACM
SIGPLAN Conference on Programming Language Design
and Implementation , PLDI ‚Äô05, 2005.
[12] M. P. Herlihy and J. M. Wing. Linearizability: A correctness
condition for concurrent objects. ACM Trans. Program.
Lang. Syst. , 12(3):463‚Äì492, July 1990.
[13] V . Jagannath, M. Gligoric, D. Jin, Q. Luo, G. Rosu, and
D. Marinov. Improved multithreaded unit testing. In
Proceedings of the 19th ACM SIGSOFT Symposium and the
13th European Conference on Foundations of Software
Engineering , ESEC /FSE ‚Äô11, pages 223‚Äì233, 2011.
[14] P. Joshi, C.-S. Park, K. Sen, and M. Naik. A randomized
dynamic program analysis technique for detecting real
deadlocks. In Proceedings of the 2009 ACM SIGPLAN
Conference on Programming Language Design and
Implementation , PLDI ‚Äô09, 2009.
[15] R. J. Lipton. Reduction: A method of proving properties of
parallel programs. Commun. ACM , 18(12):717‚Äì721, Dec.
1975.
[16] P. Liu, O. Tripp, and X. Zhang. Flint: Fixing linearizability
violations. In Proceedings of the 2014 ACM International
Conference on Object Oriented Programming Systems
Languages and Applications , OOPSLA ‚Äô14, pages 543‚Äì560,
2014.
[17] S. Lu, S. Park, C. Hu, X. Ma, W. Jiang, Z. Li, R. A. Popa,
and Y . Zhou. MUVI: Automatically inferring multi-variable
access correlations and detecting related semantic and
concurrency bugs. In Proceedings of Twenty-Ô¨Årst ACM
SIGOPS Symposium on Operating Systems Principles , SOSP
‚Äô07, pages 103‚Äì116, 2007.
[18] S. McPeak, C. H. Gros, and M. K. Ramanathan. Scalable and
incremental software bug detection. In Proceedings of the
2013 9th Joint Meeting on Foundations of Software
Engineering , ESEC /FSE 2013.
[19] M. Musuvathi and S. Qadeer. Iterative context bounding for
systematic testing of multithreaded programs. In Proceedings
of the 2007 ACM SIGPLAN Conference on Programming
Language Design and Implementation , PLDI ‚Äô07, 2007.
[20] A. Nistor, Q. Luo, M. Pradel, T. R. Gross, and D. Marinov.
Ballerina: Automatic generation and clustering of e cient
random unit tests for multithreaded code. In Proceedings of
the 34th International Conference on Software Engineering
(ICSE) , pages 727‚Äì737. IEEE, 2012.
[21] C. Pacheco, S. K. Lahiri, M. D. Ernst, and T. Ball.
Feedback-directed random test generation. In Proceedings of
the 29th International Conference on Software Engineering ,
ICSE ‚Äô07, pages 75‚Äì84, 2007.[22] C.-S. Park and K. Sen. Randomized active atomicity
violation detection in concurrent programs. In Proceedings
of the 16th ACM SIGSOFT International Symposium on
Foundations of Software Engineering , SIGSOFT
‚Äô08/FSE-16, pages 135‚Äì145, 2008.
[23] S. Park, S. Lu, and Y . Zhou. CTrigger: Exposing atomicity
violation bugs from their hiding places. In Proceedings of the
14th International Conference on Architectural Support for
Programming Languages and Operating Systems , ASPLOS
XIV , 2009.
[24] M. Pradel and T. R. Gross. Fully automatic and precise
detection of thread safety violations. In Proceedings of the
33rd ACM SIGPLAN Conference on Programming Language
Design and Implementation , PLDI ‚Äô12, 2012.
[25] W. Pugh and N. Ayewah. Unit testing concurrent software. In
In ASE , 2007.
[26] M. Samak and M. K. Ramanathan. Multithreaded test
synthesis for deadlock detection. In Proceedings of the 2014
ACM International Conference on Object Oriented
Programming Systems Languages and Applications ,
OOPSLA ‚Äô14, pages 473‚Äì489, 2014.
[27] M. Samak and M. K. Ramanathan. Omen +: A precise
dynamic deadlock detector for multithreaded java libraries.
InProceedings of the 22Nd ACM SIGSOFT International
Symposium on Foundations of Software Engineering , FSE
2014, pages 735‚Äì738, 2014.
[28] M. Samak, M. K. Ramanathan, and S. Jagannathan.
Synthesizing racy tests. In Proceedings of the 36th ACM
SIGPLAN Conference on Programming Language Design
and Implementation , PLDI 2015, pages 175‚Äì185, 2015.
[29] S. Savage, M. Burrows, G. Nelson, P. Sobalvarro, and
T. Anderson. Eraser: a dynamic data race detector for
multithreaded programs. ACM Trans. Comput. Syst. ,
15(4):391‚Äì411, Nov. 1997.
[30] K. Sen. Race directed random testing of concurrent
programs. In Proceedings of the 2008 ACM SIGPLAN
Conference on Programming Language Design and
Implementation , PLDI ‚Äô08, pages 11‚Äì21, 2008.
[31] K. Sen, D. Marinov, and G. Agha. Cute: A concolic unit
testing engine for c. In Proceedings of the 10th European
Software Engineering Conference Held Jointly with 13th
ACM SIGSOFT International Symposium on Foundations of
Software Engineering , ESEC /FSE-13, pages 263‚Äì272, 2005.
[32] F. Sorrentino, A. Farzan, and P. Madhusudan. Penelope:
Weaving threads to expose atomicity violations. In
Proceedings of the Eighteenth ACM SIGSOFT International
Symposium on Foundations of Software Engineering , FSE
‚Äô10, pages 37‚Äì46, 2010.
[33] S. Steenbuck and G. Fraser. Generating unit tests for
concurrent classes. In Proceedings of the Sixth International
Conference on Software Testing, VeriÔ¨Åcation and Validation
(ICST) , pages 144‚Äì153. IEEE, 2013.
[34] R. Vallee-Rai, E. Gagnon, L. Hendren, P. Lam, P. Pominville,
and V . Sundaresan. Optimizing java bytecode using the soot
framework: Is it feasible? In In International Conference on
Compiler Construction, LNCS 1781 , pages 18‚Äì34, 2000.
142