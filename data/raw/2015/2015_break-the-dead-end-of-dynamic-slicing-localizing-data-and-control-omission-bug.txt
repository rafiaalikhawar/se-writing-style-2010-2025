Break the Dead End of Dynamic Slicing: Localizing Data and
Control Omission Bug
Yun Lin
National University of Singapore,
SingaporeJun Sun
Singapore University of Technology
and Design, SingaporeLyly Tran
Singapore University of Technology
and Design, Singapore
Guangdong Bai
Singapore Institute of Technology,
SingaporeHaijun Wang
Nanyang Technological University,
SingaporeJinsong Dong
National University of Singapore,
Singapore
ABSTRACT
Dynamic slicing is a common way of identifying the root cause
whenaprogramfaultisrevealed.Withthedynamicslicingtech-
nique, the programmers can follow data and control flow along the
program execution trace to the root cause. However, the technique
usually fails to work on omission bugs, i.e., the faults which are
causedbymissingexecutingsomecode.Inmanycases,dynamic
slicingover-skipstherootcausewhenanomissionbughappens,
leading the debugging process to a dead end. In this work, we con-
duct an empirical study on the omission bugs in the Defects4J bug
repository.Ourstudyshowsthat(1)omissionbugsareprevalent
(46.4%) among all the studied bugs; (2) there are repeating patterns
on causes and fixes of the omission bugs; (3) the patterns of fixing
omission bugs serve as a strong hint to break the slicing dead end.
Based on our findings, we train a neural network model on the
omission bugs in Defects4J repository torecommend where to ap-
proach when slicing can no long work. We conduct an experiment
byapplyingourapproachon3193mutatedomissionbugswhich
slicingfailstolocate.Theresultsshowthatourapproachoutper-
forms random benchmark on breaking the dead end and localizing
the mutated omission bugs (63.8% over 2.8%).
CCS CONCEPTS
•Software and its engineering →Software testing and de-
bugging; Maintaining software ;
KEYWORDS
debugging, program slice, omission error, empirical study
ACM Reference Format:
Yun Lin, Jun Sun, Lyly Tran, Guangdong Bai, Haijun Wang, and Jinsong
Dong.2018.BreaktheDeadEndofDynamicSlicing:LocalizingDataand
ControlOmissionBug.In Proceedingsofthe201833rdACM/IEEEInterna-
tional Conference on Automated Software Engineering (ASE ’18), Septem-
ber 3–7, 2018, Montpellier, France. ACM, New York, NY, USA, 11pages.
https://doi.org/10.1145/3238147.3238163
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ’18, September 3–7, 2018, Montpellier, France
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.32381631 INTRODUCTION
A software fault is observed when the defect is propagated from
the root cause through control and data flow. In order to track the
fault back to its root cause, programmers usually need to trace
throughincorrectdataandcontrolflowtolocatethebug.Fromthis
perspective,dynamicslicingisausefulandefficientapproachfor
debugging. Each time a programmer finds an unexpected step or a
step with variable of incorrect value, he or she can apply dynamic
slicing to locate the step responsible for it.
However,dynamicslicingcanonlytrackthroughtheexecuted
code. It means that it cannot locate bugs caused by missing execut-
ingsomecode,i.e.,theomissionbug[ 35].Whenanomissionbug
happens,dynamicslicingstartswithastepwithincorrectdataor
controlflowandstopsatastepwhereeverythingiscorrect,causing
adead end where slicing can no longer work.
Many research work [ 12,20,25,28,35] have been proposed
toenhancedynamicslicingforlocatingomissionbugs.Zhanget
al. [35] first proposed a force-execution technique to include more
results than reported by dynamicslicing. In their approach, they
force the program to exercise the branches of unexecuted code
toexposeimplicitdependenciesamongexecutedandunexecuted
code.Similartotheirwork,Wangetal.[ 28]proposedtheirrelevant
slicing algorithm on Java byte code trace, aiming to include the
relevant unexecuted code into the slicing result. In recent years,
Sakuaietal.[ 25]enhancedZhangandWang’swork[ 28,35]with
point-to-analysis technique.
However, all the above approaches have an underlying assump-
tion that the unexecuted code exist in the project (i.e., executionomission) so that they can analyze the source code and alter thecontrol flow towards them. Such an assumption may not always
hold in practice. Our empirical study (see Section 3) shows that the
miss-executed code in most of omission bugs does not exist in the
project (i.e., code omission).
In this work, we aim to understand omission bugs in a more
fundamentalway.Wewouldliketoanswerthequestionlikehow
prevalenttheomissionbugsare,howtheyarecaused,andwhether
they share some patterns guiding us to automate their localization.
To this end, we conduct an empirical study on omission bugs in
Defects4J bug repository. First, we confirm that omission bugs are
prevalent indeed, which accounts for 46.4% of our checked bugs.
Second, we find that the omission bugs caused by incorrect data
and control flow are very different in terms of their causes and
difficulty of being localized. Lastly, we observe that the number of
509
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:47:06 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Yun Lin, Jun Sun, Lyly Tran, Guangdong Bai, Haijun Wang, and Jinsong Dong
categories for causes of omission bugs are very limited, which is a
good indication for automating their localization.
Basedonourfindings,webuildaneuralnetworkmodeltopredict
where to break the dead end of an omission bug when slicing
can no longer work. We first collect the training data from the
omission bugs in Defects4J repository. Based on the most common
cause of omission bugs, we mutate 3193 omission bugs from 5
open source projects, the result shows that our model can achieve
84.1%, 66.5%, and 50.0% predication accuracy for various omission
bugs (more details at Section 5). Moreover, we conduct a simulated
debugging experiment, which simulates how programmer tracking
incorrect data and control flow through slicing to locate those
mutated omission bugs. Our results show that, equipped with our
prediction model for breaking the dead end of dynamic slicing,
our approach outperforms random benchmark on localizing the
mutated omission bugs (63.8% over 2.8%).
Inthispaper,wemake thefollowingcontributions:(1)Wecon-
duct an empirical study to comprehensively study the omission
bugs in Defects4J repository. We confirm their prevalence, provide
ataxonomyfortheircauses,andshowpatternstopotentiallyguide
the automation of their localization. (2) We build a tool for this
empirical study which can visualize, compare, and apply step-wise
slicingonthebuggyandfixedtraceforDefects4Jbugs.(3)Webuild
apredictionmodelforbreakingthedeadendofomissionbugwhen
slicing can no long work. (4) We conduct a simulated debugging
experiment to confirm the effectiveness of our prediction model.
2 OMISSION BUG CONCEPTS AND
EXAMPLES
Inthissection,wedefineomissionbugandshowmultipleexamples
of them. First, we assume a ground truth version (or fixed version)
ofthebuggyprogramsothatweknowthecorrectnessofitsexecut-
ing steps. More specifically, given a step on the trace of the buggy
program,weknow(1)whetheritshouldhappen,and(2)whether
thevalueofanyofitsusedvariablesiscorrect.Suchanassumption
canbefulfilledinpracticeeitherbyrequiringprogrammer’sfeed-
backorbycomparingthetracesofbuggyandfixedversionsofa
program.Inthisregard,comparingtothetraditionalomissionerror
defined for execution omission (i.e., bug due to missing executing
existingcode)[35],weextendthedefinitionfroma tracepointof
view which includes both execution omission [ 35] and code omis-
sion (bug dueto missing somecode). In thefollowing, wenote the
kth step on trace πasπk(k∈N,kstarts at 1).
Definition1. Data Dependency Path. Letπbeatraceand πd
andπrbetwostepsof πsuchthat r>d.Ifπddefinesavariable var
andπrusesvar,and theredoesnot existastep πkwhered<k<r
such that πkdefinesvar, we call the path from πdtoπras adata
dependency path with regard to var, noted as /angbracketleftπd,πu/angbracketright[var].I n
addition, we call πdas the data dominator ofπu.
Definition 2. Data Omission Bug. Given a data dependency
path/angbracketleftπd,πu/angbracketright[var],ifthevalueofvariable varisincorrecton πuand
correct on πd, then we say that a data omission bug, b, happens. We
call the path /angbracketleftπd,πu/angbracketright[var]asb’scritical path and variable varas
b’scritical variable.πl2 πl16 ... ... ...minimum
πl12...
Figure 1: Critical Path of Data Omission Bug
Data omission bug indicates the critical variable should have been
redefined before the end of critical path.Example.
Listing1shows an example of a data omission bug,
which comes from the 2nd bug of Chart project in Defects4J repos-
itory. The bug is caused by missing assigning values to minimum
andmaximumvariablesinacornercase(line8–11).Fromadebug-
ging point of view, the programmer may observe that the value of
minimumvariableisunexpectedtobe Infinity atline16andapply
dynamic data slicing to reach line 2 where minimumis initialized.
Figure1shows the critical path of such a data omission bug. We
noteπlnasthestepexecutingline n.Inthiscriticalpath,thecritical
variableis minimum.Moreover,itisadatadependencypathstarts
fromπl2where minimumisdefinedandendsat πl16where minimum
is used, and no step in between πl2andπl16redefines minimum.
1 public static Range iterateDomainBounds(...){
2 double minimum = Double.POSITIVE_INFINITY;
3 double maximum = Double.NEGATIVE_INFINITY;
4 ...
5 if(..) {
6 for (...) {
7 for (...) {
8 +if(!Double.isNaN(value)) {
9 + minimum = Math.min(minimum, value);
10 + maximum = Math.max(maximum, value);
11 +}
12 uvalue = getEndXValue(series, item);
13 }
14 }
15 }
16 if(minimum > maximum) {
17 return null;
18 }
19 ...
20 }
Listing 1: Example of Data Omission Bug
Definition3. Control Dependency Path. Giventwosteps πc,
πfsuch that c<f,πcexecuting ncandπfexecuting nf, we call
a path from πctoπfas acontrol dependency path ifnfcontrol-
depended1onnc, and, there does not exist a step πk(c<k<f)
executing nkandnfcontrol-depends on nk. We denote the condition
ofπcasconand the control dependency path as <πc,πf>(con).I n
addition, we call πcas the control dominator ofπk.
Definition4. Control Omission Bug. Givenacontroldepen-
dency path /angbracketleftπc,πk/angbracketright(con),i fπkshould not happen and πcis correct,
then we say that a control omission bug happens. We call such a
control dependency path /angbracketleftπc,πk/angbracketright(con)asbuд’scritical path.
Control omission bug indicates the control flow in between the
critical path should have been altered to avoid the step at its end.Example.
Listing2showsanexampleofacontrolomissionbug,
which comes from the 3rd bug of Math project in Defects4J reposi-
tory.Thebugiscausedbymissingthecodetoreturninacorner
case(line6–7).Fromadebuggingpointofview,theprogrammer
may observe that line 9 is unexpectedly executed and he can apply
dynamiccontrolslicingtoreachline3wherethecondition len !=
1A more detailed definition on static control dependency can be referenced in [21]
510
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:47:06 UTC from IEEE Xplore.  Restrictions apply. Break the Dead End of Dynamic Slicing: Localizing Data and Control Omission Bug ASE ’18, September 3–7, 2018, Montpellier, France
b.leniscorrectlyevaluatedto false.Thecriticalpathofsucha
control omission bug is showed in Figure 2.
1 public double linearCombination(){
2 ...
3 if(len != b.length)
4 throw new DimensionMismatchException(len, b.length);
5 ...
6 +if (len == 1)
7 +return a[0] * b[0];
8 final double[] prodHigh = new double[len];
9 double prodLowSum = 0;
10 ...
11 }
Listing 2: Example of Control Omission Bug
πl3 πl9 ... ... ...len != b.length
πl8...
Figure 2: Critical Path of Control Omission Bug
Definition 5. Occur Step and Dead End Step. Letpbe the
criticalpathofacontrolordataomissionbug, b,whichstartsat πs
and ends at πe, we callπsandπeas the dead end step andoccur
stepofbrespectively.
Definition6. Break Step. Letbbeanomissionbugontrace π,
andthetraceafter bisfixedbe π/prime.The break step ofbiseither(1)a
stepbeforewhichthefixisapplied2or(2)anincorrectstepinbetween
the occur step and the dead end step which allows programmers to
apply dynamic slicing for approaching the root cause.
Example. Figure3shows an example for the first and second
condition in Definition 6for Listing 1. In Figure 3, the upper trace
πis buggy, and the lower trace π/primeis obtained from applying the
fix.Each rectangleindicatesatrace stepanditsname πlnmeans
the line number nit visits. The dotted lines represent the matching
relation between two traces, the solid lines represent the data flow,
and the dash lines represent the control flow. In such case, πl12
(the grey rectangle with solid border) is regarded as the break step
accordingtothefirstcondition,asthefixisappliedbeforethisstep.
π’ l3πl3 πl12
π’ l8π’ l9π’ l10π’ l11π’ l12π’ l16πl16
... ... ... ...... ... ... ...minimum
minimum...πl8
Figure 3: Example of Break Step
Now,letusassumethatcodeinline8–11ofListing 1hasalready
existedinthebuggyversion(i.e.,theyarenotthefix)and πl3isstill
thedatadominatorof πl16withregardtovariable minimumbecause
2Note that it is possible to have more than one fix options for an omission bug, in
such case, we regard the step before which any possible fix option is applied as the
break step.)L[HG
9HUVLRQ%XJJ\
9HUVLRQ
熄7UDFH
&ROOHFWLRQ
熆'HEXJJLQJ
6LPXODWLRQ
熅7UDFH
0DWFKLQJ5HVXOW)L[HG
7UDFH%XJJ\
7UDFH
0DWFKLQJ
5HVXOWV
Figure 4: Study Setup
line9isnotexecuted.AsshowedinFigure 3,line8willbeexecuted
atπl8, which indicates that the condition !Double.isNaN(value)
is evaluated to be false. In such case, πl8is regarded as the break
step according to the second condition as it allows us to apply
dynamic slicing to further approaching the root cause.
3 EMPIRICAL STUDY
In order to have a thorough understanding of data and control
omission bugs, we conduct an empirical study on Defects4J reposi-
tory [11] with the following research questions:
•RQ1:Howprevalentaretheomissionbugswithregardto
all the bugs in repository.
•RQ2:Whatarethemainreasonsforomissionbugsinrepos-
itory?
3.1 Study Setup – Identifying Omission Bugs
Figure4showshowweprocesseachDefects4Jbuginourempirical
study.Defects4Jrepositorydescribeseachbugbyitsbuggyversion,
its fixed version, and the test cases which fail in the buggy version
and pass in the fixed version. Given a Defects4J bug and its failing
test case, we first collect the trace of its buggy version and that
of its fixed version (Step 1). Then, we leverage a trace matching
technique to align the steps between the buggy trace and the fixed
trace (Step 2). With the reference to the fixed trace, as indicated by
the matching results, we can know each step on the buggy trace
iseithercorrectorincorrectfromdata(readingwrongvariables)
or control (should not happen) point of view. Then, we simulate
programmers’debuggingprocessonthebuggytrace(Step3).More
specifically, starting from the end of the buggy trace where the
fault is revealed, we continuously conduct dynamic data slicing (if
a step reads incorrect variable) and dynamic control slicing (if astep should not happen). After the debugging process stops andthe root cause cannot be located in such a manner, we know the
dynamic slicing comes to a dead end and it is an omission bug.
3.1.1 Trace Collection and Matching. Whencollectingtheprogram
trace, we not only sequentially collect the executed statements, we
alsobuildthedataandcontroldependenciesforthetracesteps.WeimprovedZhang’scontrol-flowbasedtracematchingalgorithm[
30,
35] to make it work on two traces with different source code. Our
improvementistomatchtracestepswithregardtothecodechanges.
For example, if a ifkeyword is modified to a while, the steps
influenced by the if-condition should be matched to steps in the
firstiterationofthewhile-loop. Basedonthematchingresult,eachsteponthebuggytrace,whosesourcecodeisnotmodified,canfall
into either of the following categories:
511
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:47:06 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Yun Lin, Jun Sun, Lyly Tran, Guangdong Bai, Haijun Wang, and Jinsong Dong
Algorithm 1: Debugging Simulation
Input :a fault-revealing step stepfon the buggy trace
Output:a critical path pathc
1stepd,stepprev←stepf;
2whilestepdis not correct and stepd.sourceis not fixed do
3stepprev←stepd;
4ifstepdis data incorrect then
5 var←incorrect variable on stepd;
6 stepd←data_dom(stepd,var);
7else ifstepdis control incorrect then
8 stepd←control_dom(stepd);
9end
10ifstepdis correct then
11ifstepprevis data incorrect then
12 var←incorrect variable on stepprev;
13 return <stepd,stepprev >[var];
14else ifstepprevis control incorrect then
15 con←conditional expression on stepd;
16 return <stepd,stepprev >(con);
17end
18else
19returnnull ; //stepd.source is fixed
20end
•correct:the step can be matched with a step on the fixed
trace and all its read variables has the same value as its
matched step.
•data incorrect: the step can be matched with a step on the
fixed trace and some of its read variable has different value
from that of its matched step.
•control incorrect: the step cannot be matched with any
step on the fixed trace.
3.1.2 Debugging Simulation. Algorithm 1depicts how our debug-
ging simulation process identify omission bug. In the debugging
process, we continuously apply dynamic data or control slicing on
the buggy trace until the process goes into a dead end or finds the
rootcause.Weconsiderthebugisanomissionbugintheformer
case.
InAlgorithm 1,we startthesimulateddebuggingattheendof
thebuggytrace,whichiswherethefaultisrevealed.Ifthework-
ing step ( stepd) is data incorrect, we find its data dominator (see
Definition 2)bydynamicdataslicing(line4–6).Iftheworkingstep
iscontrolincorrect,wefinditscontroldominator(seeDefinition 3)
by dynamic control slicing (line 7–8). The process continues until
the working step is correct (i.e., dead end) or the source code is
modifiedasafix(line2).Intheformercase,weconsideranomis-
sion bug happens. We record the critical path (see Definition 2and
4)aseither /angbracketleftstepd,stepprev/angbracketright[var]or/angbracketleftstepd,stepprev/angbracketright(con)forthe
omission bug (line 10–17).
3.2 Implementation
We build an Eclipse plugin called Tregression to visualize the bugs
in Defects4J repository. A snapshot and demo video of our tool
is available on its Github website [ 1]. In our tool, we visualize
the buggy trace and its fixed trace on left and right panel. Users
canclickthesteponeithertraceto(1)checkitsreadandwrittenTable 1: Overview of Omission Bug Prevalence
Simulation ResultProjectTotalChartClosureLangMathMockitoTime
Omission
bugsControl 7524168667
Data 5129122443
Localizable
bugs14727442015127
Discarded
bugsNon-
deterministic013101116
Not applicable
for slicing017327130
Over-longtrace07913200112
Total 26133651063827395
variables, (2) compare its corresponding step on the other trace,
and(3) comparethecode beforeand afterthefix. Moreover,users
can apply dynamic data and control slicing operation on each step.
3.3 Study Result
3.3.1 RQ1: Omission Bug Prevalence. Table1showsanoverview
of omission bugs in Defects4J repository.
First,237outof395bugsareapplicableforthisstudy.Wediscard
158 bugs because of the following three reasons: (1) the bug is a
non-deterministic program (our trace matching algorithm requires
stable trace to replay the bug), (2) the buggy trace only contain
correct step, or (3) either the buggy trace or the fixed trace is over-
long(i.e.,over100Ksteps).Wejustifydiscardingthebugsdueto
the second and third reason as follows.
As for the second reason, Listing 3shows an example, which is
the simplified version of the 18th bug of Time project in Defects4J
repository.Inthisbug,thebuggyversionmissenclosingthemethod
invocation iGregorianChronology.getDateTimeMillis() with
try-catch block. It results in the termination of buggy version with
an exception at line 4. In contrast, the fixed version does not termi-
nateatline4andcontinueitsexecutiontoline6.Asaresult,every
stepinbuggytraceiscorrectexceptthatthetracemissessomesteps
(for catching the exception). In this case, our simulated debugging
approach is not applicable as the slicing technique cannot work.
Moreover, such bugs are also not our interested omission bugs.
1 public long getDateTimeMillis(...) {
2 ...
3 +try{
4 instant = iGregorianChronology.getDateTimeMillis
5 (year, monthOfYear, ...)
6 +}catch (IllegalFieldValueException ex) {
7 + ...
8 +}
9 ...
10 }
Listing3:ExampleoftheBugUnapplicableforSlicing
As for the third reason, we discard the bug with trace length
over100KforthelimitedscalabilityofexistingJavatracecollection
tool [16]. We will discuss more about this issue in Section 3.4.
Ofthe237bugswestudied,110bugs(46.4%)arereportedasomis-
sionbugsbyAlgorithm 1,i.e.,trackingincorrectdataandcontrol
cannot lead to the root cause. Of all the omission bugs we detected,
thecontrolomissionbugsaccountfor60.9%(67/110)andthedata
512
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:47:06 UTC from IEEE Xplore.  Restrictions apply. Break the Dead End of Dynamic Slicing: Localizing Data and Control Omission Bug ASE ’18, September 3–7, 2018, Montpellier, France
(a) Control Omission Bug
 (b) Data Omission Bug
Figure 5: Critical Path Length
(a) Control Omission Bug
(b) Data Omission Bug
Figure 6: Over-skipped Step Number
omission bugs account for 39.1% (43/110). Thus, we conclude that:
OmissionbugisprevalentamongalltheDefects4Jrepository,
and control omission bugs are of comparable proportion as data
omission bugs.
Moreover, we further investigate the critical path length and
over-skipped step number (i.e., distance between the break step
and the dead end step, see Definition 6) for each omission bug.
Critical path length indicates the worst effort for a programmerto manually break the dead end of an omission bug. In contrast,
over-skippedstepnumberindicatestheefforttobreakthedeadend
of an omission bug if a programmer sequentially check throughthe trace from the dead end step. Figure 5and Figure 6show the
distributionofcriticalpathlengthandover-skippedstepnumber
of control and data omission bugs respectively.
Inbothfigures,wecanobservethatcontrolomissionbugsshow
different characteristics from data omission bugs. First, both theaverage critical path length and the average over-skipped stepnumber in control omission bugs are smaller than that in dataomission bug. More specifically, average critical path length ofcontrol omission bugs is 138.9 and that of data omission bugs is
1095.5, in contrast, average over-skipped step number of control
omissionbugsis32.2andthatofdataomissionbugsis432.2.Second,asshowedinFigure 6b,onedataomissionbughasthephenomenon
of“under-skip”,thatis,therootcausehappens beforethedeadend
step.In summary, we conclude that:
In general, data omission bugs are harder to be localized than
control omission bugs. Moreover, seldom as it is, the root cause
ofthebugmayhappenbeforethedeadendstepindataomission
bugs.
3.3.2 RQ2: Omission Bugs Taxonomy. Forthose 110bugs, wefur-
ther studied how those omission is fixed in Defects4J repository.
ControlOmissionBugsTaxonomy. Fromasyntacticpointofview,
wesummarize5categoriesofcontrolomissionbugs,i.e.,missing
if-block, missing if-throw, invoking differentmethod, missing try-
catch block, and passing wrong parameter.Missingif-block.
Aconditionismissedinthecode.Thiscategory
includes missing if,for,whilecondition. Note that their block
bodies do not include throwstatement.
Missingif-throw. Aconditionismissedinthecode.Thiscategory
includesmissing if,for,whileconditionandtheirblockbodies
include throwstatement.
Invoking incorrect method. The control flow is unexpectedly
altered by calling an incorrect method. Thus, all the follow-up
stepsincurredbythatmethodinvocationarecontrolincorrect.A
typicalscenarioisthemisuseofpolymorphism,forexample,the
programmer forget to override a method in the superclass.Missing try-catch block.
Try-catch block can be considered as
analternativeofif-else-block.Missingatry-catchblockcanlead
programtocrashoutofunexpectedexception.Asanexamplein
Listing4(fromthe83thbugofMockitoproject),thebuggyprogram
is unexpectedly terminated in line 3 out of a CmdLineException.
1 public int parseArguments(Parameters params){
2 ...
3 - String param = params.getParameter(0);
4 + String param = null;
5 +try {
6 + param = params.getParameter(0);
7 +}catch (CmdLineException e) {}
8 }
Listing 4: Example of Missing Try-Catch Block
Passing wrong parameter. Forsuchacategory,anexpectedex-
ception does not happen because of passing wrong parameter dur-
ing a method invocation. Listing 5shows an example (from 4th
bug of Time project), the program is not supposed to run into line
10asanexpectedexceptionissupposedtohappenatline7.Trac-
ing throughdynamic controlflow leadsto line3, whichcauses an
omission bug.
1 public Partial with(...){
2 ...
3 if(...){
4 return;
5 }
6 ...
7 - Partial newPartial = new Partial(iChronology, newTypes, newValues);
8 + Partial newPartial = new Partial(newTypes, newValues, iChronology);
9 ...
10 return newPartial;
11 }
Listing 5: Example of Passing Wrong Parameter
Strictly,missingif-throwisaspecialcaseofmissingif-block,we
makethemexclusiveasthefollowreasons.Fromtheperspective
of occur step (see Definition 5, i.e., where the fault is revealed)
and where is the root cause, we divide the influence of a control
513
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:47:06 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Yun Lin, Jun Sun, Lyly Tran, Guangdong Bai, Haijun Wang, and Jinsong Dong
omission bug into intra-method and inter-method. If both occur
stepandrootcausearewithinamethod,weregardtheinfluence
asintra-method,otherwise,weregarditasinter-method.Thein-
fluenceofmissingif-blockisintra-method,whilethatofmissing
if-throwissometimesinter-method.Forexample,line8inListing 6
is unexpectedly executed because guess() method (line 7) misses
aif-throwinsideitsmethodbody.Insuchcase,wherethefaultis
revealed (i.e., occur step) is not within the same method of the root
cause, we regard its influence is inter-method.
1 public void testMath844(...){
2 ...
3 if(...){
4 return;
5 }
6 ...
7 guesser.guess();
8 }
Listing 6: Example of If-Throw
05101520253035404550
missing if-
blockmissing if-
throwinvoke
different
methodmissing try-
catch blockpass wrong
parameter
Figure 7: Solution for Control Omission Bug
Figure7showsthedistributionofallthesecategories.Wecan
see that the majority of control omission bug is caused by missing
if-block and missing if-throw while the rest ones are the minority.
Data Omission Bugs Taxonomy. Still from a syntactic point of
view,wesummarize4categoriesofsolutionfordataomissionbugs,
i.e., missingassignment, incorrect evaluatedcondition, incorrect
condition,invokingnewmethod,andmissingif-block.Itisstraight-
forwardtoseehowmissinganassignmentleadstoadataomission
bug. Thus, we explains other three categories.
1 private Cluster<T> getNearestCluster(...) {
2 ...
3 Cluster<T> minCluster = null;
4 for (Cluster<T> c : clusters) {
5 double distance = point.distanceFrom(c.getCenter());
6 if(distance < minDistance) {
7 minDistance = distance;
8 minCluster = c;
9 }
10 }
11 return minCluster;
12 }
Listing 7: Example of Incorrect Evaluated Condition
Incorrect evaluated condition. Incorrect evaluated condition al-
tersthecontrolflowtoavoidtheredefinitionofthecriticalvariable
(seeDefinition 2).Listing 7showsanexample(fromthe79thbug
of Math project). The value of variable minCluster at line 11 isnull, which is caused by the fact that the condition distance <
minDistance (line 6) never been true and line 8 is never executed.
Incorrect condition. Different from incorrect evaluated condition,
incorrectconditionavoidstheredefinitionofthecriticalvariable
becauseofincorrectbooleanexpressionincode.Listing 8shows
an example (from the 43th bug of Math project). The valuevari-
able (line 5) is not incremented due to incorrect comparison for
varianceImpl andvariance in code.
1 public void addValue(...){
2 ...
3 -if (!(varianceImpl instanceof Variance))
4 +if (varianceImpl != variance)
5 varianceImpl.increment(value);
6 ...
7 }
Listing 8: Example of Incorrect Condition
Miss invoking method. Missinvokingmethodcanberegarded
asa specialcase ofmissing assignment.The differencelies inthat
thenewmethodisusuallythelibrarymethodwhichassignsafield
insidea library class.Forexample,the invocationof java.util.-
Calendar.getTime() sets its fields[0] field.
024681012141618
missing
assignmentincorrect
evaluated
conditionincorrect
conditioninvoking new
method
Figure 8: Data Omission Bug Cateogry
Figure8showsthedistributionofallthesecategories.Compared
toFigure 7,thedistributionofcategoriesofdataomissionbugis
more even in the four categories.
In summary, we conclude that:
In general, there are lots of syntactic means to alter data and
controlflowtocreateomissionbugs.However,fromanempirical
point of view, the omission bugs are caused by only a limited
number of syntactic reasons.
3.4 Threats to Validity
The major threat to validity in this empirical study is that we miss
thebugswithtracelengthover100K.Thereasonisthatthestate-of-
the-arttracerecodingtechniques[ 16]donotscalewellforbuilding
very large Java trace model, including the read/written (library)variables of each trace step and the data and control dominance
relationshipsamongtracesteps.Fromthispoint,wemaymisssomeomission bug categories in those large traces. In the future, we aim
to build a more scalable trace recording technique to generalize
our findings. The other threat is that the “fix version” (i.e., ground
truth) of each omission bug is unique in this study. In the future,
514
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:47:06 UTC from IEEE Xplore.  Restrictions apply. Break the Dead End of Dynamic Slicing: Localizing Data and Control Omission Bug ASE ’18, September 3–7, 2018, Montpellier, France
weneedtoconductmorestudytocomparethebreakstepswhen
multiple fix options exist for an omission bug.
4 APPROACH
Asourempiricalstudyindicatesstrongpatternstoescapethedead
end of omission bugs, we propose to localize an omission bug in
a data-driven manner. In this section, we design a technique for
assistingslicing-baseddebugging.Morespecifically,weassumethatprogrammerscandebugasoftwarefaultbyprovidingtheirfeedback
(e.g.,dataorcontrolincorrect)ontracestepsandusingslicingto
graduallyapproachtherootcause.Whenthedeadendcausedby
omissionbughappens,i.e.,givenadataorcontroldependencypath
starting from step πsand ending by step πe, andπeis incorrect
whileπsis correct, we aims to recommend a trace step in between
πsandπe,
•wherethecriticalvariableshouldhavebeenassignedforthe
data omission bug, or
•wherecontrolflowshouldbealteredtoavoidtheunexpected
step for the control omission bug.
By observing the omission bugs in Defects4J repository, we first
manually feature engineer these bugs for predicting break stepsof omission bugs. More specifically, the prediction model takes
input as the features of the critical path of an omission bug and an
arbitrarytracestepand,outputstheprobabilityofthesteptoserveasthebreakstep. Tothisend,wechooseneuralnetworktoconduct
the predication for its rich expressiveness over other classification
models such as Naive Bayes [ 7] and SVM [ 10]. We train the neural
network model with the omission bugs in Defects4J repository,and test the model with our mutated omission bugs. We mutate
the omission bugs with regard to the omission bug taxonomy (see
Section3.3.2)sothatthemutatedomissionbugsareclosetoreal
ones.Ouraimistobuildamodelwhichcanfitwellinrealomission
bugs and generalize well in mutated the omission bugs.
4.1 Feature Engineering
Inthissection,weintroducethecommonfeaturessharedbycontrol
and data omission bug as well as their specific features.
4.1.1 Common Features. Givenatracestep s,andanomissionbug
b,thecommonfeaturesincludethelengthofcriticalpathandthe
syntactic features of the occur step, dead end step, the trace step s,
andtheircontexts.Thesyntacticfeatureofastep sdescribesthe
encodingoftheminimumASTnodecontainingthesourcelineof
s. The encoding is represented by a vector of boolean variables.
Encoding AST Node. WefirstcategorizingASTnodetypesinto
a taxonomy tree with regard to their similarity with each other. In
our implementation for Java programming language, we refer to
EclipseJavaAST document[ 27]for building thetaxonomytreefor
all the Java AST node types. A simplified tree is shown in Figure 9.
InFigure 9,underthetopvirtualnodes,therearetotally11nodesin
the second layer, representing abstract AST node such as variable
declaration and expression. The third layer has 92 nodes each of
whichrepresentsaconcreteASTnodesuchassinglevariabledecla-
ration and field access. Thus, we encode a AST node with a vector
withlengthof103(11+92),eachdimensionrepresentsaconcrete
nodeinthethirdlayeroranabstractnodeinthesecondlayer.Anyexpression variable declaration
single variable 
declarationfield access...
... ...
variable 
declaration 
fragmentassignment
Figure 9: Simplified Java Taxonomy Tree Example
AST node must fall in either of the nodes in the third layer (con-
crete nodes) along with its parent in the taxonomy tree. Therefore,
the corresponding two dimensions are set to 1 and all the otherdimensions are set to 0. The idea of using hierarchical structure
allowssimilarASTnodes(e.g.,assignmentandfieldaccess)toshare
training results.Encoding Syntax of Trace Step.
For a trace step s, we concern
6ASTnodes.TheyaretheASTnodesfor s,occurstep,deadend
step, as well as each of their AST parents in the code (readers may
refertoFigure 10astheparent-childrelationshipinAST).TheAST
parent indicates the context information. For example the occur
step (line 11) in Listing 7, we care about both the AST node type of
line 11 (i.e., return statement) and the AST node type of its context
(i.e., method declaration).
In summary, the common features concatenate all the above
features and vectors, and hav e1+6×(11+92) = 619 dimensions.
4.1.2 Specific Features for Control Omission Bugs. Forcontrolomis-
sion bug, we use AST walk and split data/control dependency to
embed the specific features of a trace step.
ASTWalk. Givenanomissionbug bwhoseoccurstep πoanddead
end step πd, and letπkbe a step between πoandπd, AST walk
indicatesthesyntacticproximityfromthesourcecodeof πktothat
ofπo.FromtheperspectiveofASTtraverse,the walkconsistsof
three directions, i.e., up, right, and down, in terms of AST of thecode. Taking the code in in Listing 7as example, the occur step
happens at line 11 and the break step is at line 6. The AST walk
fromline11toline6isshowedinFigure 10.InFigure 10,eachnode
representsanASTnode,itsnumberindicatesthelinenumberin
Listing7,andarrowsrepresentsthewalkdirection.Wecanseethat
the walk from line 11 to line 6 takes 0 ups, 1 rights, and 2 downs.
4
4for expression411return statement1method declaration
for bodyfor statement
5 6assignment if statement
Figure 10: AST Walk Example
515
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:47:06 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Yun Lin, Jun Sun, Lyly Tran, Guangdong Bai, Haijun Wang, and Jinsong Dong
Split Data andControl Dependencies. The break step of a con-
trol omission bug must lie in between the dead end step πcand
occurstep πk.Thus,lookingforsuchabreakstepissimilartolook-
ingforastep swhichcansplitthecodesothat /angbracketleftπc,s/angbracketrightisallowed
while/angbracketlefts,πk/angbracketrightistobeavoided.Thus,wetakethenumberofdataand
control dependencies between /angbracketleftπc,s/angbracketrightand/angbracketlefts,πk/angbracketrightas two features.
4.1.3 Specific Features for Data Omission Bugs. For data omission
bug (let its critical path be /angbracketleftπd,πu/angbracketright[var]), we introduce critical
conditionalstepandvariablesimilaritiestoembedthefeaturesofa
trace step.
Critical ConditionalStep. Thecriticalconditionalstepsarethe
tracestepson πwhereaconditionalexpressionisevaluatedand
thenegationofitsvaluecanleadtotheexecutionofredefining var.
Suchafeatureisabooleanvalue,i.e.,atracestepiseitheracritical
conditional step or not.Read and Written Variable Similarity.
Given a trace step s,w e
definefeaturestomeasurehowsimilaritsreadandwrittenvariables
to the critical variable var. Based on the variable type (i.e., field or
local variable), we use different number of dimensions to describe
similarityfeatures.Ifavariable varcisofdifferenttypewith var,
all its similarity dimensions are 0, otherwise, we use the following
rules to create a vector for varc:
•Field:Ifthecriticalvariableisafield,wehaveavectoroffour
booleandimensions,i.e.,(1)whether varcsharesthesame
parent(objectusing varcasitsfield)with var,(2)whether
theparentof varchasthesamedatatypewith var(e.g.,both
of themare fields in Calendar data type),(3) whether varc
isofthesamedatatypewith varc,and(4)whether varcis
of the same name with var.
•Local Variable: If the critical variable is a local variable,
we have have a vector of two boolean dimensions, i.e., (1)whether
varcis of the same data type with varc, and (2)
whethervarcis of the same name with var.
Note that a step may read or write multiple variables, each of
whichcanberepresentedbyavectorof kdimensions(e.g., kis4
ifthevariableisafieldand2ifthevariableisalocalvariable).In
such case, we select the most similar read (written) variable vector
as the read (written) variable similarity vector for s.
4.2 Neural Network Structure
Figure11showsourneuralnetworkstructure,whichhas1input
layer, 1 hidden layer, and 1 output layer. Different from traditional
fullyconnectednetwork,thenumberofneuronsinthehiddenlayer
corresponds to the number of “groups” in input features. For ex-
ample, the three dimensions in AST walk corresponds to a neuron
inthehiddenlayer(Group1inFigure 11),andthelast103dimen-
sionsofASTnodeencoding(Group9inFigure 11)correspondsto
another. Therefore, the network structures for control, field, and
local variable omission bugs are different from each other.
We design such a network not only for predicting, but for in-
terpretation as well. With such a network, the weight on each
edgefromhiddenlayertooutputlayerindicatesthesignificance
of each group to the final probability and the weight on each edge
from input layer to hidden layer indicates the significance of each
dimension to its group.... ... ......
probability 
neuronGroup1: 
AST Walk
Group9: 
Occur Step 
Syntax 
Embedding
Figure 11: Neural Network Structure
In this work, we use cross-entropy loss function to evaluate our
model during the model training. We use ReLu activation function
for hidden layer and Sigmoid activation function for output layer.
5 EVALUATION
Weconductourevaluationtoanswerthefollowingtworesearch
questions:
•RQ1:Whether our model can predict the break steps for
omission bugs accurately?
•RQ2:Enhanced dynamic slicing with our model, can we
localize the omission bugs efficiently?
5.1 Training Evaluation
With the findings of our empirical study, we define five types of
mutations,i.e.,removeanassignment,removeaif-condition(i.e.,
maketheif-bodyalwaysbeexecuted),negateaif-condition,remove
aif-throw,andremovethewholeif-block.Thesefivemutationtypes
cover the majority of causes described in Section 3.3.2, and they
are effective to cause omission bugs. We conduct the mutationon 5 Java open source projects, as showed in Table 2. The valid
mutation means the mutations successfully kill the test case and
cause omission bugs.
Table 2: Mutated Project Overview
Project Version LOC #Valid Mutation
Aapache-math 2.2 97449 186
Apache-lang 3.5 73423 1099
Jfreechart 1.2.0 148852 1457
Apache-collections 3.2.2 56134 373
Apache-cli 1.3.1 6552 78
Learning Settings. Given the inputs and network structure are
different for learning control omission bug, field omission bug, and
local variable omission bug, we tune their model with differentparameters, as showed in Table 3. We decide the parameters by
empiricaltrials.Notethatthetrainingprocessoftheneuralnetwork
isaprocesstoiterativelydecreasethelossvalueofcrossentropy
loss function. In this experiment, we use loss threshold instead of
iterationnumbertodecidewhenthelearningprocessstops.That
is, once the loss valueis below the threshold, the learning process
stops. We also attach random seed for repeating our approach.Learning Effect.
Table4shows our learning effect on control,
field, and local variable omission bug (i.e., COB, FOB, and LVOB
516
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:47:06 UTC from IEEE Xplore.  Restrictions apply. Break the Dead End of Dynamic Slicing: Localizing Data and Control Omission Bug ASE ’18, September 3–7, 2018, Montpellier, France
Table 3: Parameter Setting
omission bug\parameter Learning Rate Threshold Random Seed
Control Omission Bug 0.05 0.4 18
Field Omission Bug 0.1 0.65 20
Local Variable Omission Bug 0.05 0.5 0
in Table4). We compare learning effect in terms of true positive
rate(TPRate),truenegativerate(TNRate),andtotalaccuracy.In
general, our model achieve acceptable performance on control and
localvariableomissionbugs.However,themodeldoesnotperform
well on field omission bugs. Our observation indicates that the
difference between field omission bugs is much larger than control
and local variable omission bugs. In Table 4, the model achieves
poortruepositiveratio(27.3%)andgoodtruenegativeratio(76.5%)
ontrainingsetbutthesituationreversesontestingset,ormutationset.Itindicatesthatthedatadistributionoffieldomissionfluctuates
morethantheothertwoomissionbugs.Furthermore,weinvesti-
gateintotheseomissionbugsandfindthat,theinfluenceoffield
omissionbugsis usuallyinter-methodwhilethat ofcontrolomis-
sion bugs and local variable omission bugs is usually intra-method.
As a result, field assignment can happen almost anywhere along
the trace, which is more random than local variable assignment.
Table 4: Learning Effect
Omission Bug COBFOBLVOB
TrainingTP Rate 74.2%27.3%77.8%
TN Rate 88.5%76.5%77.1%
Total 84.3%51.9%76.0%
TestingTP Rate 87.1%82.4%57.5%
TN Rate 81.0%49.4%68.0%
Total 84.1%50.0%66.5%
FeatureSignificance. AsmentionedinSection 4.2,ourneuralnet-
workstructureisalsodesignedforinterpretationtounderstandhow
significant a feature is. The larger the absolute value a weight has,
themoreinfluenceithasonthepredicationresult.Thesignindi-
catesitspositiveornegativeimpactontheresult.Table 5showsthe
weightsforvariousomissionbugs.Forexample,controlomission
is more influencedby the feature of AST walkas well as syntactic
feature of occur step and dead end step. For the weight of AST
walk, i.e, -0.68, it indicates that the break step usually appears in
small walk from the occur step. Similarly, the weight 1.17 indicates
that being a critical conditional step is a strong indicator for being
a break step for a local variable omission bug. For syntactic fea-
tures,theyindicatethattheASTnodetypewithlarger(e.g.,0.62)
orsmaller(-0.62)indexusuallyhasstrongerinfluenceontheresult.
Given the limit of paper space, readers can refer to our website [ 2]
for our indexing for AST node.
5.2 Simulated Debugging Experiment
Based on our prediction model, we enhance the our simulateddebugging algorithm (Algorithm 1) by suggesting breaker steps
with our model. Algorithm 2describes our enhanced debugging
simulation algorithm. The algorithm takes three inputs, a fault-
revealingstep,thenumberofbreakstepswecanrecommendfor
an omission bug, and a work list that we keep other suggested
breakers.Algorithm 2: Enhanced Debugging Simulation
Input :a fault-revealing step stepfon the buggy trace, breaker
numberlimit, a stack for breaker steps worklist
Output:whether the find is found
1stepstop←oriдinal _simulated _debuддinд (stepf);
2ifstepdis the root cause then
3returntrue;
4end
5omission _buд←дet_omission _buд(stepstop);
6breakers ←recommend _breakers (omission _buд,limit);
7forbreaker ∈breakers do
8worklist .push(breaker )
9end
10whileworklist is not empty do
11breaker ←worklist .pop();
12enhanced _debuддinд _simulation (breaker ,worklist )
13end
14ifstackis emptythen
15returnfalse
16end
In Algorithm 2, when we detect an omission bug (line 5) by the
processdescribed inAlgorithm 1(line1, i.e.,dynamic slicing),we
get recommended break steps and keep them in the work list (line
5–6). Then, we retrieve a break step from the work list and restart
debugging from the step in the same way (the recursive call in line
12). The algorithm stops either because we localize the root cause
or the work list is empty.
Inthisexperiment,wetakearandomrecommenderasourbench-
mark.Therandomrecommenderindicatestheperformanceofomis-
sionbuglocalizationifthesimulatedprogrammerchoosearandom
stepasthebreakstep.Wedeemourapproachasineffectiveifits
performanceiscomparabletothatoftherandomrecommender. We
compare our approach with the benchmark by setting the number
of recommended break steps to 1, 3, and 5. That is, we recommend
top-1, top-3, and top-5 breakers in our prediction model while 1, 3,
and 5 random steps as breakers for benchmark (line 6). We run our
approachandrandomrecommenderonallthemutatedomission
bugs from open source projects, Table 6shows the results. Table 6
shows that our approach outperforms benchmark in all options on
alltypesofomissionbugs.WithregardtoTable 4,theperformance
of bug localization is highly relevant to model prediction accuracy.
Based on our prediction model, we can accurately localize the con-
trolomissionbugs evenwithtop-1option. Moreover,Table 6also
indicatesthatfieldomissionbugsisthemostdifficultomissionbug
tolocalize.Noteworthy,thoughourmodeldoesnotperformwell
for field omission bugs, we still improve the performance of the
benchmark significantly.
In summary, our evaluation shows that (1) our approach can
work well to localize certain specific omission bug such as control
and local variable omission bugs, (2) combined with our predic-
tionmodel,wecanbreakthedeadendofslicingandlocalizethe
omission bug more efficiently.
5.3 Threats to Validity
Onemajorthreatisthatweusesimulateddebuggingexperimentto
imitate how human programmer debug their code. It is essential to
517
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:47:06 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Yun Lin, Jun Sun, Lyly Tran, Guangdong Bai, Haijun Wang, and Jinsong Dong
Table 5: Feature Significance
Omission BugAST
WalkSplitDepCriticalConditional
StepRead
Var SimWrittenVar SimCriticalPath
LengthStep
SyntaxStepContext Occur StepSyntax Occur StepContext Dead EndStep Syntax Dead EndStep Context
Control Omission Bug -0.68-0.04/ / / -0.01 0.4-0.67 -0.08 0.34 0.62 -0.62
Field Omission Bug //0.038 0.24 0.69 -0.018 0.940.46 -0.32 0.56 -2.2 -0.03
Local Variable
Omission Bug//1.17 -0.87 0.42 0.93 -0.680.71 -0.29 -1.0 0.44 -0.1
Table 6: Simulation Result
Omission Bugtop-1 top-3 top-5
Model
BreakerRandomBreakerModelBreakerRandomBreakerModelBreakerRandomBreaker
Control
Omission Bug94.6%10.2%98.4%19.2%99.5%23.7%
FieldOmission Bug34.8%2.5%53.3%7.3%59.1%10.2%
Local Variable
Omission Bug50.9%14.2%72.5%30.0%82.2%38.0%
Total 63.8%8.2%76.6%16.9%81.1%21.5%
deliveratoolandcollectthefeedbackofhumanprogrammer.Inour
futurework,wewillconductacontrolleduserstudyonhowour
toolintegratedwithlearnedmodelcanhelphumanprogrammerin
theprocessofdebugging. Theotherthreatisthelimitednumber
ofmutationtypesforgeneratingmutatedbugs.Wechoosethose
mutation type based on the finding of our empirical study. The
experimentshowsthatthesemutationscangenerateomissionbugs
in a much more efficient way than traditional mutation such as
changingoperatorandnumbers.Nevertheless,moreexperiments
are necessary to generalize our findings with more dynamic types
of mutation.
6 RELATED WORK
OmissionErrorResearch. Manyresearchwork[ 12,20,25,28,35]
havepointedoutthatdynamicslicingcannotbeusedtolocalizethe
code“shouldhavebeen”executed.Toovercometheshortcomingof
the slicing technique, Zhang et al. [ 35] proposed a force-execution
techniqueandWangetal.[ 28]proposedtheirrelevantslicingalgo-
rithm to this end. Moreover, Qi et al. [ 20] proposed a solver-based
approach to localize the regression bug. By comparing the correct
versionoftheprogram,theirapproachcaninfercodeomissionerror
by encoding the buggy program, the correct program, and the test
case into a satisfiability problem. In recent years, Sakuai et al. [ 25]
enhanced Zhang and Wang’s work [ 28,35] with point-to-analysis.
Alltheabovetechniques havetheassumptionthattheomitted
codeexistsintheprojectsothattheycananalyzetheprogramto
leadthecontrolflowtocodethatshouldhavebeenexecuted.How-
ever, our empirical study showsthat their techniques only solve a
small portion of the whole omission bugs, i.e., data omission bugs
under the category of incorrect evaluated condition and incorrect
condition. Based on our study findings, we proposed a data-driven
approach to train the model to handle omission bugs in a more
comprehensive way.
RecordandReplayforDebugging. Ourapproachisanenhance-
ment for record and replay debugging, or time-travelling debug-
ging[5,13–15,18,19,24,31].Suchatechniqueallowstheprogram-
merstobuildadatacausalitychaintolocalizetherootcause[ 18,19,31].Moreover,basedontherecordedtrace,differentqueriescanbe
usedtolocalizetracesteps.Forexample,Ressiaetal.[ 24]proposed
an approach which can track steps by specific object instance.
The most relevant techniques are Whylineproposed by Ko et
al.[13–15]andMicrobat proposedbyLinetal.[ 16].Whylineallows
user to select auto-generated questions, including why or why notquestion on program output as well as the recorded program trace
and suggest the trace step based on slicing. Microbat asks four
typesofuserfeedbacktosuggestsuspicioustracestepanditcan
further learn these feedbacks to speed up reasoning the root cause.
Our approach is complementary to both techniques to improve the
localization of omission bugs.DeltaDebuggingandStatisticalFaultLocalization.
Animpor-
tantbranchofdebuggingresearchisdeltadebugging[ 6,9,17,20,32–
34] and statistical fault localization [ 3,4,8,23,26,29]. Zeller et
al. [32] first proposed the concept of delta debugging and apply
itonregressiontesting.Then,thetechniqueissoontoberefined
by Misherghi et al. [ 17] to improve the result and the concept is
soon applied to simplify test cases [ 34], isolate bug-causing vari-
able [6,33], and etc. We regard statistical fault localization as a
specialcaseofdeltadebugging,whichareusedtolocatebugsby
comparing a set of passed and failed test cases. The more timeexecuted by failed test cases, a more suspicious a line of code is,
andviceversa.Manymetricshavenproposedtorefinethestatis-
ticalfault localization [ 3,22,29]An overviewofspectrum-based
techniques can be checked in [4].
All the above approaches need a reference to infer where the
buglies.Similartoexistingdebuggingtechnique,wefirstusethe
correctversionofprogramasareferencetolookforomissionbugs.
However, by learning through a large number of bug corpus, we
can localize the omission bug without any reference.
7 CONCLUSION
In this work, we comprehensively studied omission bugs in De-fects4J repository and provide a taxonomy on how they can be
caused from a syntactic point of view. Based on the findings in our
empiricalstudy,webuildadeeplearningmodeltopredictthebreaksteps of both control and data omission bugs. In the future, we will
generalizeourstudyonmorebugswithlongertracesandfurther
improve the precision our prediction on break steps.
ACKNOWLEDGEMENT
Wethanktheanonymousreviewersfortheirvaluablecomments
and suggestions. This research is supported by the National Re-
search Foundation, Singapore (No. NRF2015NCR-NCR003-003).
518
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:47:06 UTC from IEEE Xplore.  Restrictions apply. Break the Dead End of Dynamic Slicing: Localizing Data and Control Omission Bug ASE ’18, September 3–7, 2018, Montpellier, France
REFERENCES
[1][n.d.]. TregressionGithubWebsite. https://github.com/llmhyy/tregression.([n.
d.]). Accessed Feb 2, 2018.
[2]2018. SliceBreaker Website for ASEsubmission. https://sites.google.com/view/
slicebreaker/home. (2018).
[3]Rui Abreu, Peter Zoeteweij, and Arjan J. C. van Gemund. 2009. Spectrum-Based
Multiple Fault Localization. In Proceedings of the 2009 IEEE/ACM International
Conference on Automated Software Engineering. 88–99.
[4]Rui Abreu, Peter Zoeteweij, Rob Golsteijn, and Arjan J.C. van Gemund. 2009. A
practical evaluation of spectrum-based fault localization. Journal of Systems and
Software82, 11 (2009), 1780 – 1792.
[5]Earl T. Barr and Mark Marron. 2014. Tardis: Affordable Time-Travel Debugging in
Managed Runtimes. Technical Report. http://research.microsoft.com/apps/pubs/
default.aspx?id=212395
[6]Holger Cleve and Andreas Zeller. 2005. Locating Causes of Program Failures. In
Proceedingsofthe27thInternationalConferenceonSoftwareEngineering.342–351.
[7]Nir Friedman, Dan Geiger, and Moises Goldszmidt. 1997. Bayesian Network
Classifiers. Mach. Learn. 29, 2-3 (Nov. 1997), 131–163. https://doi.org/10.1023/A:
1007465528199
[8]L. Gong, D. Lo, L. Jiang, and H. Zhang. 2012. Interactive fault localization
leveraging simple user feedback. In IEEE International Conference on Software
Maintenance. 67–76.
[9]Neelam Gupta, Haifeng He, Xiangyu Zhang, and Rajiv Gupta. 2005. Locating
Faulty Code Using Failure-inducing Chops. In Proceedings of the 20th IEEE/ACM
International Conference on Automated Software Engineering. 263–272.
[10]MartiA.Hearst.1998. SupportVectorMachines. IEEEIntelligentSystems 13,4
(July 1998), 18–28. https://doi.org/10.1109/5254.708428
[11]René Just, Darioush Jalali, and Michael D. Ernst. 2014. Defects4J: A Database
of Existing Faults to Enable Controlled Testing Studies for Java Programs. In
Proceedings of the 2014 International Symposium on Software Testing and Analysis
(ISSTA2014) .ACM,NewYork,NY,USA,437–440. https://doi.org/10.1145/2610384.
2628055
[12]AndrewJ.KoandBradA.Myers.2004. DesigningtheWhyline:ADebuggingInterfaceforAskingQuestionsAboutProgramBehavior.In Proceedingsofthe
SIGCHIConferenceonHumanFactorsinComputingSystems (CHI’04).ACM,New
York, NY, USA, 151–158. https://doi.org/10.1145/985692.985712
[13]AndrewJ.KoandBradA.Myers.2004. DesigningtheWhyline:ADebugging
InterfaceforAskingQuestionsAboutProgramBehavior.In Proceedingsofthe
SIGCHI Conference on Human Factors in Computing Systems. 151–158.
[14]Andrew J. Ko and Brad A. Myers. 2008. Debugging Reinvented: Asking and
AnsweringWhyandWhyNotQuestionsAboutProgramBehavior.In Proceedings
of the 30th International Conference on Software Engineering. 301–310.
[15]Andrew J. Ko and Brad A. Myers. 2009. Finding Causes of Program Output with
theJavaWhyline.In ProceedingsoftheSIGCHIConferenceonHumanFactorsin
Computing Systems. 1569–1578.
[16]Yun Lin, Jun Sun, Yinxing Xue, Yang Liu, and Jinsong Dong. 2017. Feedback-
based Debugging. In Proceedings of the 39th International Conference on Software
Engineering (ICSE’17).IEEEPress,Piscataway,NJ,USA,393–403. https://doi.
org/10.1109/ICSE.2017.43
[17]GhassanMisherghiandZhendongSu.2006. HDD:HierarchicalDeltaDebugging.
InProceedings of the 28th International Conference on Software Engineering . 142–
151.
[18]G.PothierandÃĽTanter.2009. BacktotheFuture:OmniscientDebugging. IEEE
Software26, 6 (2009), 78–85.
[19]GuillaumePothierandÉricTanter.2011. SummarizedTraceIndexingandQuery-
ing for Scalable Back-in-time Debugging. In Proceedings of the 25th European
Conference on Object-oriented Programming. 558–582.[20]DaweiQi,AbhikRoychoudhury,ZhenkaiLiang,andKapilVaswani.2009.Darwin:
AnApproachforDebuggingEvolvingPrograms.In Proceedingsofthe7thJoint
Meeting of the European Software Engineering Conference and the ACM SIGSOFT
Symposium on The Foundations of Software Engineering. 33–42.
[21]VenkateshPrasadRanganath,TorbenAmtoft,AnindyaBanerjee,JohnHatcliff,
andMatthewB.Dwyer.2007. ANewFoundationforControlDependenceand
SlicingforModernProgramStructures. ACMTrans.Program.Lang.Syst. 29,5,
Article 27 (Aug. 2007). https://doi.org/10.1145/1275497.1275502
[22]ManosRenierisandStevenP.Reiss.2003. FaultLocalizationWithNearestNeigh-
borQueries..In ProceedingsofInternationalConferenceonAutomatedSoftware
Engineering. 30–39.
[23]Thomas Reps, Thomas Ball, Manuvir Das, and James Larus. 1997. The Use of
Program Profiling for Software Maintenance with Applications to the Year 2000
Problem.In Proceedingsofthe6thEuropeanSOFTWAREENGINEERINGConference
Held Jointly with the 5th ACM SIGSOFT International Symposium on Foundations
of Software Engineering. 432–449.
[24]JorgeRessia,AlexandreBergel,andOscarNierstrasz.2012. Object-centricDebug-
ging. InProceedings of the 34th International Conference on Software Engineering.
485–495.
[25]Kouhei Sakurai and Hidehiko Masuhara. 2015. The Omission Finder for De-bugging What-should-have-happened Bugs in Object-oriented Programs. In
Proceedings of the 30th Annual ACM Symposium on Applied Computing (SAC ’15).
ACM, New York, NY, USA, 1962–1969. https://doi.org/10.1145/2695664.2695735
[26]R. Santelices, J. A. Jones, Yanbing Yu, and M. J. Harrold. 2009. Lightweight fault-
localization using multiple coverage types. In Proceedings of 31st International
Conference on Software Engineering. 56–66.
[27]Olivier Thomann Thomas Kuhn, Eye Media GmbH. [n. d.]. Ab-stract Syntax Tree. http://www.eclipse.org/articles/article.php?file=
Article-JavaCodeManipulation_AST/index.html. ([n. d.]).
[28]TaoWangandAbhikRoychoudhury.2008. DynamicSlicingonJavaBytecode
Traces.ACM Trans. Program. Lang. Syst. 30, 2, Article 10 (March 2008), 49 pages.
https://doi.org/10.1145/1330017.1330021
[29]XinmingWang,S.C.Cheung,W.K.Chan,andZhenyuZhang.2009. TamingCo-
incidental Correctness: Coverage Refinement with Conte xt Patterns to Improve
Fault Localization. In Proceedings of the 31st International Conference on Software
Engineering. 45–55.
[30]BinXin,WilliamN.Sumner,andXiangyuZhang.2008. EfficientProgramExecu-
tionIndexing.In Proceedingsofthe29thACMSIGPLANConferenceonProgram-
ming Language Design and Implementation (PLDI ’08). ACM, New York, NY, USA,
238–248. https://doi.org/10.1145/1375581.1375611
[31]Ding Yuan, Haohui Mai, Weiwei Xiong, Lin Tan, Yuanyuan Zhou, and Shankar
Pasupathy. 2010. SherLog: Error Diagnosis by Connecting Clues from Run-time
Logs.InProceedingsoftheFifteenthEditionofASPLOSonArchitecturalSupport
for Programming Languages and Operating Systems. 143–154.
[32]Andreas Zeller. 1999. Yesterday, My Program Worked. Today, It Does Not. Why?.
InProceedingsofthe7thEuropeanSoftwareEngineeringConferenceHeldJointly
with the 7th ACM SIGSOFT International Symposium on Foundations of Software
Engineering. 253–267.
[33]AndreasZeller.2002. IsolatingCause-effectChainsfromComputerPrograms.
InProceedingsofthe10thACMSIGSOFTSymposiumonFoundationsofSoftware
Engineering. 1–10.
[34]Andreas Zeller and Ralf Hildebrandt. 2002. Simplifying and Isolating Failure-
Inducing Input. IEEE Transaction on Software Engineering 28, 2 (2002), 183–200.
[35]XiangyuZhang,SriramanTallam,NeelamGupta,andRajivGupta.2007. Towards
LocatingExecutionOmissionErrors.In Proceedingsofthe28thACMSIGPLAN
Conference on Programming Language Design and Implementation (PLDI ’07).
ACM, New York, NY, USA, 415–424. https://doi.org/10.1145/1250734.1250782
519
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:47:06 UTC from IEEE Xplore.  Restrictions apply. 