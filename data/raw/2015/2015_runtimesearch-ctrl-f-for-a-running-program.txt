RuntimeSearch: Ctrl+F for a Running Program
Mat¬¥uÀás Sul ¬¥ƒ±r, Jaroslav Porub ¬®an
Technical University of Ko Àásice, Slovakia
Email: fmatus.sulir, jaroslav.porubang@tuke.sk
Abstract ‚ÄîDevelopers often try to Ô¨Ånd occurrences of a certain
term in a software system. Traditionally, a text search is limited
to static source code Ô¨Åles. In this paper, we introduce a simple
approach, RuntimeSearch, where the given term is searched in
the values of all string expressions in a running program. When a
match is found, the program is paused and its runtime properties
can be explored with a traditional debugger. The feasibility and
usefulness of RuntimeSearch is demonstrated on a medium-sized
Java project.
Index Terms‚Äîprogram comprehension; dynamic analysis; de-
bugger; text search; concept location
I. I NTRODUCTION
Currently, the programmers use the debugger available in
their IDE (integrated development environment) to execute
and step a program and inspect its state. On the other hand,
searching is typically performed on static source code, and it
does not utilize dynamic information.
A. Motivation
Suppose a developer needs to answer a common question
[1]: Where in the source code is the label displayed in the UI
(user interface) of a running program located?
Static source code search for the given term often does not
produce desired results, since only a portion of the strings
is located in the source code in a form of string constants.
Dynamically generated and localized strings, user input, data
obtained from other systems, and many other strings may not
present in the static source code of the application [2]. Instead,
the developer should ask: Which expression contains the given
string in its value at runtime?
A question like this could be possibly answered by writ-
ing custom scripts and queries in automated and scriptable
debuggers such as Coca [3], FrTime [4] or E XPOSITOR
[5]. However, we should take the reality of developers [6]
into account: The cost of learning to use a tool must be
lower than the expected beneÔ¨Åt of its application. Ideally, the
developer should use a tool immediately or only after minimal
training. Even when using existing tools like a textual search,
developers prefer simple queries compared to complicated,
sophisticated ones [7].
Considering the developer already found the source code
location related to the UI element, she will probably want to
examine it from the dynamic viewpoint ‚Äì inspect the concrete
values of variables at a speciÔ¨Åc moment, view the stack
frame, etc. Currently, searching and debugging are considered
separate actions accomplished with different tools. However,
according to multiple empirical studies, these two activities
are often interleaved. For example, based on the results ofa Ô¨Åeld study with professional developers, Damevski et al.
[7] argue there should be better integration between code
search, navigation and debugging. Wang et al. [8] studied
developers locating relevant parts of source code; two of three
search patterns the developers used encompassed running and
debugging the program.
After Ô¨Ånding and inspecting an initial point of investigation,
developers often aim to Ô¨Ånd other occurrences relevant to
this point. For instance, they try to determine where the data
from a certain variable Ô¨Çow [9]. In theory, this is easy to
accomplish using approaches such as dynamic program slicing
[10]. In practice, the data can Ô¨Çow through multiple third-
party systems and return back to the inspected application.
For example, a user input can be saved to a database, then
retrieved and displayed in another part of the application.
Classical program slicing approaches could fail to Ô¨Ånd such a
connection. Although cross-system slicing approaches emerge,
they suffer from performance issues [11] or are technology-
dependent [12].
B. Objective
With the mentioned considerations in mind, we designed
RuntimeSearch. It is a variation of a traditional textual search
in source code, but in this case, we are searching in the values
of expressions at runtime. A programmer enters a string which
she wants to locate. It can be, for instance, a UI label visible
in a running program for which she wants to Ô¨Ånd the source
code part displaying it; or a string which she hypothesizes is a
value of some unknown variable or expression. If the program
is not already running, it is launched. During the runtime, all
evaluated string expression values are being compared with the
searched term. When a match is found, the program execution
is paused and a traditional IDE debugger is opened. The
programmer can explore runtime properties of the program
like the call stack and current variable values. Then, she can
continue with debugging, running, or search some string again.
In essence, RuntimeSearch is an extension of a traditional
debugging process. In addition to standard debugging opera-
tions like Step In or Continue, a Find In Runtime action is
available. This runtime-search action provides a user interface
resembling a simple textual search dialog, which practically
all developers are familiar with. Therefore, the tool should
require almost no training.
A preliminary implementation is available and a case study
was performed to show the feasibility and usefulness of the
978-1-5386-2684-9/17/$31.00 c2017 IEEEASE 2017, Urbana-Champaign, IL, USA
Technical Research - New Ideas388
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:57:18 UTC from IEEE Xplore.  Restrictions apply. technique. The source code of RuntimeSearch is available
online1.
II. S EARCHING IN THE RUNTIME
First, we will describe RuntimeSearch from the user‚Äôs
(programmer‚Äôs) point of view. Next, we will look at its design
and implementation.
A. User‚Äôs View
The interaction and user interface of RuntimeSearch was
modeled with two principles in mind:
1) To look similar to a traditional textual search in source
code whenever it is possible. Since code searching is a
familiar operation for practically every programmer, this
should make learning the tool easy.
2) To integrate the approach with the debugging infrastruc-
ture already present in IDEs and used by developers.
Each runtime searching begins by triggering the action
‚ÄúFind in Runtime‚Äù in an IDE, which shows a query prompt,
where the developer enters the searched text. Subsequently,
the searching process is started in one of three ways:
If no program is currently being debugged, a new instance
is launched.
If a debugged program is paused, it is resumed.
If a debugged program is running, it is left running.
The string is searched from the moment it was entered
into a prompt until a match is found. When this happens,
the program is immediately paused using a programmatically
invoked breakpoint. This causes the IDE to highlight the
currently executed line and show current variable values. Fur-
thermore, all debugging features of the given IDE are available
‚Äì including the stack frames view, expression evaluation,
advanced object state inspections, etc.
When the programmer considers the current search result
irrelevant or wants to Ô¨Ånd the next occurrence, she triggers the
action ‚ÄúFind Next in Runtime‚Äù. In case she wants to change
the search string, she chooses the action ‚ÄúFind in Runtime‚Äù.
The process continues as already described.
If the developer does not want to search a string anymore,
she can continue debugging with traditional operations like
Step In and Step Over or resume the program. At any moment,
it is possible to search the string in the runtime if desirable.
One of many possible examples of the developer‚Äôs interac-
tion with RuntimeSearch is displayed in Fig. 1. However, the
process is not prescriptive and can be adapted to developer‚Äôs
speciÔ¨Åc needs. In section III, we will describe multiple usage
scenarios.
B. Principle
We look at a running program as a series of expression
evaluations. Consider the following Java source code excerpt:
String var = "text";
var = var.toUpperCase();
1https://github.com/sulir/runtimesearch
Start searching a string in runtime
A match is found, the program is pausedPut the program into some state
Interact with the program
Inspect the state and call stack, step the program,...
Continue debugging, terminate the program...need next occurrence
relevant code foundFig. 1. A possible example of RuntimeSeach utilization.
It produces the following expression values, in the given
order: ‚Äútext‚Äù (a string constant), ‚Äútext‚Äù (the value of the
variable var read on the second line), and ‚ÄúTEXT‚Äù (the return
value of the method toUpperCase).
The program is instrumented, so the result of every string
expression is captured and compared to the searched text.
Currently, only expressions of type String are captured ‚Äì
it makes the most sense to compare the searched text only to
strings. However, the approach is not limited to this behavior
and in the future, we could convert all objects to their string
representations using a toString-like method.
Namely, we capture the following String expressions:
constants, local variables, member variables, constructor calls,
and method calls returning values.
In our early implementation, the evaluated strings are
matched against the query using a simple string containment:
if the evaluated string contains the searched text, a match is
found. Again, this is not an inherent limitation of the approach.
It can be easily extended with standard text-search options
like ‚Äúmatch case‚Äù, ‚Äúwhole words only‚Äù, regular expression
matching, or advanced features like approximate (fuzzy) string
matching.
C. Implementation Details
Our RuntimeSearch implementation consists of a Java agent
(a piece of instrumentation code which can be attached to any
389
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:57:18 UTC from IEEE Xplore.  Restrictions apply. Java program) and a plugin for the IntelliJ IDEA IDE.
The agent is conÔ¨Ågurable through an argument ‚Äì a pattern
specifying what packages or classes should be instrumented.
This way, it is possible to specify, e.g., whether to include
only application or also system classes.
Instrumentation is performed at the bytecode level. In stack-
based virtual machines like the Java Virtual Machine, each ex-
pression evaluation is represented by an instruction pushing a
value on the operand stack, which can be used with advantage.
The IDE plugin is very lightweight and consists mainly of a
simple form and a module for communication with the agent.
III. C ASE STUDY
Now we will show how searching in the runtime can
be useful to perform navigation and debugging tasks. The
demonstration will be performed on Weka2‚Äì an open source
Java machine learning software. It is a Swing GUI (graphical
user interface) application with approximately 350,000 lines of
code. A short video with parts of the case study is available
online3.
A. Finding an Initial Point
One of the questions programmers ask during program
maintenance tasks is ‚ÄúWhere in the code is the text in this
error message or UI element?‚Äù [1] Weka includes a package
manager which displays a list of additional packages. Suppose
we want to Ô¨Ånd the code which retrieves package names, such
as ‚ÄúAffectiveTweets‚Äù. Searching the static source code for the
term ‚ÄúAffectiveTweets‚Äù does not give any results, since this
string was generated at runtime.
Therefore, we run the application in a debug mode and wait
until the main window appears. Then we trigger the ‚ÄúFind in
Runtime‚Äù menu in the IDE, enter the query ‚ÄúAffectiveTweets‚Äù
and press Find. After choosing the menu ‚ÄúPackage manager‚Äù
in Weka, the program automatically pauses and the IDE shows
us the currently executed line, containing the searched string
expression. We see the Ô¨Årst runtime occurrence of the string
‚ÄúAffectiveTweets‚Äù, i.e., its origin. Not only can we notice it
was read from a Ô¨Åle input stream (it is obvious by reading
the source code), but thanks to the IDE showing a string
representation of the stream object at runtime, we also see
its path in the Ô¨Åle system ‚Äì the name of the ‚Äúpackage list‚Äù Ô¨Åle
from which the string ‚ÄúAffectiveTweets‚Äù was read.
B. Searching for Occurrences
After quickly Ô¨Ånding the initial point of investigation, it is
up to us how to continue. We can explore the source code, Ô¨Ånd
static references, or debug the program. Another interesting
possibility is to search for all following runtime occurrences
of the string ‚ÄúAffectiveTweets‚Äù. This can be achieved by
repeatedly triggering the action ‚ÄúFind Next in Runtime‚Äù in
the IDE (e.g., using a shortcut) ‚Äì each time, a new occurrence
is found.
2https://sourceforge.net/projects/weka/
3https://sulir.github.io/runtimesearchThis way, we Ô¨Ånd many precise locations in source code
relevant to package name retrieval and displaying. This in-
cludes reading a package list Ô¨Åle, manipulation with an object
representing the given package, reading a version list Ô¨Åle,
GUI code displaying the package name, and various helper
methods. After each step, we are free to explore the current
runtime properties of the program to improve our under-
standing, or step into a method of interest. For example, if
we are interested how the version Ô¨Åle URL is determined,
we can step into the getConnection method while we are
in the method getRepositoryPackageVersions(String
packageName).
C. The Fabricated Text Technique
Instead of just ‚Äúpassively‚Äù searching for a string which
the application itself displayed, we can utilize an interesting
technique: Enter a made-up string into a text Ô¨Åeld and search
for its runtime occurrences. This allows us to track the data
Ô¨Çow of the string across program layers: from presentation
through model to persistence.
For instance, we open the Weka Bayes Network Editor,
start searching for a fabricated string like ‚ÄúNode987‚Äù in
the runtime using RuntimeSearch, and create a new node
named ‚ÄúNode987‚Äù in the Bayes Net editor. The debugger
will immediately pause at the GUI code processing the node
name. By searching for next occurrences, we are being navi-
gated through more or less speciÔ¨Åc node-processing and data
structure classes. After pressing the Save button in Weka
and continuing the search, we are navigated through methods
converting Bayes network nodes to XML representation and,
Ô¨Ånally, to the Ô¨Åle-saving method.
D. Non-GUI Strings
Until now, we were searching only for strings present in the
GUI in some way. However, RuntimeSearch is not limited to
such texts.
We created a simple layout in the Weka KnowledgeFlow
Environment, containing a DataGrid connected to a Database
Server, all with default settings. Weka KnowledgeFlow con-
tains an option to save the layout Ô¨Åle in the KFML format (an
XML dialect). We tried it, but it does not behave as expected ‚Äì
after selecting this option, a Ô¨Åle is saved as JSON (JavaScript
Object Notation) instead.
We view the content of the Ô¨Åle in a text editor and choose
an excerpt, such as the string ‚ÄúÔ¨Çow name‚Äù. We search for
this excerpt in the runtime using RuntimeSearch (Fig. 2,
part 1). After triggering the Save action in Weka (part 2 of
Fig. 2), the program is automatically paused. We inspect the
call stack: three methods at the top are located in a class
starting with ‚ÄúJSON‚Äù (Fig. 2, label 3). This means during
the execution of these methods, the wrong output format
is already selected. Therefore, we click on the fourth item
(label 4 in the Ô¨Ågure). Immediately, we see the cause of the
bug: The method saveFlow contains a hard-coded call to
JSONFlowUtils.writeFlow (see part 5 of Fig. 2).
390
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:57:18 UTC from IEEE Xplore.  Restrictions apply. Fig. 2. RuntimeSearch in action: The IDE plugin (1.), an action in Weka (2.),
IntelliJ IDEA debug window and source code view (3.‚Äì5.). See the main text
for full description.
This is a demonstration how RuntimeSearch facilitates
Ô¨Ånding where in the project is the layout-saving code located,
while immediately providing a context for debugging (the call
stack inspection and subsequent root cause identiÔ¨Åcation).
E. Hypothesis ConÔ¨Årmation
The strings searched so far were present either in the
GUI or in external resources like Ô¨Åles. RuntimeSearch can
go even further. During debugging, developers often form
hypotheses about program behavior [13]. If the programmer
has a hypothesis about a presence of a certain string in a
speciÔ¨Åc member variable, she can utilize Ô¨Åeld watchpoints in
common IDEs. However, if she does not know which variable
is concerned, or even whether it is a variable and not only a
temporary expression, runtime searching is very convenient.
If we want to open the Weka package manager from the
main menu while there is no network connection available,
nothing visible happens ‚Äì even no error message is displayed
in the GUI, which is certainly not user-friendly. We hypothe-
size Weka is trying to establish an HTTP connection to load
the package list, but it fails. We search for the string ‚Äúhttp://‚Äù
using RuntimeSearch and click the Package Manager menu
item in Weka. The debugger pauses at the URL creation code.
We Ô¨Ånd out the Ô¨Årst part of our hypothesis is conÔ¨Årmed: An
HTTP connection is created and tried to be opened. After
a few ‚ÄúStep Over‚Äù actions in the IDE, we see a thrown
UnknownHostException is caught, the stack trace is printed
to the standard error stream, but no GUI message window is
shown.
Similar hypotheses could be formed about SQL queries in
information systems, regular expressions in parsers, etc.
IV. P ERFORMANCE
As a form of a primitive benchmark, we measured the
execution time of all unit tests from the package ‚Äúweka.core‚Äùunder three circumstances: without instrumentation, with in-
strumentation but without searching, and while searching for
a short string during the whole execution. The execution
was performed in debug mode, and system classes were not
instrumented. A mean of three measurements was computed
for each condition.
The difference between the plain and instrumented execu-
tion was negligible (14.653 vs. 14.908 s). Searching incurred
reasonable overhead (38%), the measured time was 20.223 s.
The most prominent slowdown was noticed during the ‚Äútest
instantiation‚Äù phase, not included in the above times. During
the instrumented run, it lasted 8-9x more than in the plain one.
This can be attributed to high overhead of the class instrumen-
tation process itself. Note that this slowdown predominantly
affects startup time, further interaction with the application is
swift. Furthermore, this is only an implementation issue, and
using an alternative instrumentation library should improve the
performance signiÔ¨Åcantly.
V. R ELATED WORK
Related work includes unconventional code search tech-
niques, advanced or automated debuggers, and concept loca-
tion approaches.
A. Searching
A tool by Michail [14] builds a database containing the
associations between messages shown in GUI widgets and
their callbacks (along with other related functions). Then a
programmer can search for a message, and associated func-
tions are shown ‚Äì or vice versa. In contrast to RuntimeSearch,
their approach is static and requires separate support for each
GUI framework. Furthermore, our tool is not limited to GUI
messages.
Holmes and Notkin [15] describe an approach when the
‚ÄúÔ¨Ånd references‚Äù capability of an IDE is Ô¨Åltered using infor-
mation from dynamic analysis ‚Äì only methods executed in the
given scenario are returned. Compared to RuntimeSearch, they
do not capture nor search in the values of expressions.
SPOTTER [16] is a framework for the creation of custom
search processors in the Pharo environment. Although such
search processors have access also to runtime data, and in
theory, a tool similar to RuntimeSearch could be built, no such
search processor was described in the article.
DynamiDoc [17] writes Javadoc documentation above meth-
ods, directly into source code Ô¨Åles. It contains concrete ex-
amples of parameters, return values and state changes during
execution. It would be possible to use standard text search to
Ô¨Ånd the given value in the generated documentation.
B. Debugging
Automated debuggers like Coca [3] or a scriptable debugger
by Marceau et al. [4] perceive an executing program as a set of
events. They allow developers to write predicates describing
when the program should pause and scripts automatically
performing given actions. E XPOSITOR [5] adds time-traveling
capabilities to such scripts. Although these and similar systems
391
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:57:18 UTC from IEEE Xplore.  Restrictions apply. are more feature-rich than RuntimeSearch, we believe the
simplicity of our approach will allow developers to learn it
quickly, which should accelerate its possible industrial adop-
tion. Instead of writing scripts and queries, RuntimeSearch
offers a familiar user interface of a text search dialog and
applies it to runtime.
Whyline [18] allows developers to ask Why and Why Not
questions about the observed program behavior. For example,
we can click on a drawn square and ask why it has a speciÔ¨Åc
color. The relevant piece of code is shown, along with a
sequence of steps how the color was computed. Compared
to RuntimeSearch, Whyline operates not only with strings but
also with graphical elements in a program. However, it has
multiple limitations. First, it is ofÔ¨Çine, i.e., trace-based, which
seriously limits its practical adoption because of a massive
amount of data collected [18]. Second, it substitutes, not com-
plements the built-in IDE debugger which many developers
are already used to. Third, it uses identiÔ¨Åer names to suggest
possible questions, so it relies heavily on good naming.
With object-centric debugging [19], we can place break-
points on speciÔ¨Åc object instances at runtime. The breakpoints
are then triggered when this instance is manipulated in a
given way. For example, we could track a speciÔ¨Åc string
instance in a running program. However, to use object-centric
debugging, the program must be already paused and a speciÔ¨Åc
object instance must be manually selected. RuntimeSearch
automatically Ô¨Ånds such an instance.
C. Concept Location
In general, concept location (or feature location) is the
process of Ô¨Ånding where the given concept or feature is imple-
mented in the source code [20]. Feature location approaches
take a high-level description of a feature as an input, and
they produce a list of code elements contributing to this
functionality. In this sense, RuntimeSearch is not a feature
location approach. On the other hand, one of the possible uses
of our tool is to locate UI terms in the values of expressions in
the source code. Therefore, we can consider RuntimeSearch
an auxiliary tool useful in the concept location process.
Chen and Rajlich [21] present feature location as a guided
search across the program‚Äôs abstract system dependence graph.
Starting from a selected program element, the developer
regulates the feature location process by choosing relevant
nodes, while the computer controls the traversal. Similar to
RuntimeSearch, the technique is interactive and alternates
the control between a user and a computer. However, it is
purely static and it does not utilize information from dynamic
analysis.
Bohnet and D ¬®ollner [22] describe a feature location ap-
proach where execution traces are collected and visualized in
a form of a call graph. Then, the developer inspects the call
graph and selects speciÔ¨Åc points of interest. In a subsequent
run, values of parameters or variables are collected at the spe-
ciÔ¨Åc points, and the graph and source code is annotated with
them. Compared to RuntimeSearch, their approach requires
two separate instrumented executions. In their method, only asmall, manually selected portion of variable values is collected.
Finally, their tool is not integrated with an IDE and its ready-
to-use debugging capabilities.
Some feature location approaches (e.g., SITIR [23]) com-
bine dynamic analysis with information retrieval applied on
the source code ‚Äì this relies on the programmers using proper
identiÔ¨Åers. In contrast to them, we utilize the values of string
variables and expressions at runtime.
A feature location approach by Anwikar et al. [24] utilizes
concrete variable values in the analysis, but only in a very
limited way. First, the approach uses partial evaluation, and no
real program execution is performed. Second, the approach is
limited to ‚Äúfunction variables‚Äù in legacy software ‚Äì variables
which determine the type of an action to be performed,
containing one of a predeÔ¨Åned set of values.
FLAT3[25] and I3 [26] are advanced user interfaces for
feature location. Instead of providing a custom GUI, Run-
timeSearch tries to utilize existing IDE capabilities as much
as possible.
One of the open problems of dynamic feature location is the
selection of appropriate program inputs. Hayashi et al. [27]
propose a technique to guide the identiÔ¨Åcation of unexplored
scenarios. Since our technique does not aim for a complete
feature-code mapping, only for temporary queries, scenario
selection is much less of a concern. A developer executes a
program according to a scenario (s)he is interested in, and the
results are speciÔ¨Åc to this execution.
VI. C ONCLUSION AND FUTURE WORK
In this paper, we presented RuntimeSearch ‚Äì a simple search
engine which, instead of searching in the static source code,
searches in the values of all string expressions of a running
program. It applies a well-known ‚ÄúÔ¨Ånd text‚Äù metaphor in the
runtime. Our tool integrates into the debugging infrastructure
of an IDE and extends its capabilities.
In a case study on a 350 kLOC open source system, we
have shown how it can be used to locate an initial investigation
point in the program by Ô¨Ånding the location displayed in the
GUI. Next, we continued to Ô¨Ånd other occurrences of the
same string to Ô¨Ånd more (possibly) related pieces of code. Our
tool is helpful also during debugging, when the programmer
hypothesizes about the presence of a certain string in an
unknown variable.
The currently implemented version of RuntimeSearch is
very limited. The Ô¨Årst future research area is an improvement
of the matching options, e.g. regular expression or fuzzy string
matching. Ideally, a programmer would be able to enter a high-
level description of a feature and the program would pause
when the feature is executed, which could be regarded as
‚Äúfeature breakpoints‚Äù.
Sometimes we encountered a situation when multiple ‚ÄúFind
Next in Runtime‚Äù operations in a row pointed to the same
statement. This happened mainly in loops which contained the
searched string expressions in their body. Adding an option to
automatically skip such occurrences is an interesting future
392
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:57:18 UTC from IEEE Xplore.  Restrictions apply. work idea. Similarly, we could limit the search granularity by
pausing only at one occurrence during a method call.
Storing previous occurrences and thus enabling the ‚ÄúFind
Previous‚Äù operation could be useful too. Of course, the pre-
vious occurrences would be only static source code locations,
since storing runtime state would effectively mean building a
time-traveling debugger.
Searching only for String objects is limiting. Extension
to numeric values is a viable option. In many languages,
including Java, it is possible to convert an object to its string
representation using a method like toString(). This could
be used to perform a text search in various non-string objects.
In a small benchmark, the overhead of running instrumented
code without an active search was negligible after the start-
up (class-loading) period. Searching for a string incurred
and overhead of about 38%. Optimization and a thorough
performance evaluation are planned.
Finally, we plan to fully validate the approach using a
controlled experiment with human participants performing
software comprehension and maintenance tasks.
ACKNOWLEDGMENT
This work was supported by project KEGA 047TUKE-
4/2016 Integrating software processes into the teaching of
programming.
REFERENCES
[1] J. Sillito, G. C. Murphy, and K. De V older, ‚ÄúQuestions programmers
ask during software evolution tasks,‚Äù in Proceedings of the 14th ACM
SIGSOFT International Symposium on Foundations of Software Engi-
neering, ser. SIGSOFT ‚Äô06/FSE-14. New York, NY , USA: ACM, 2006,
pp. 23‚Äì34.
[2] M. Sul ¬¥ƒ±r and J. Porub ¬®an, ‚ÄúLocating user interface concepts in source
code,‚Äù in 5th Symposium on Languages, Applications and Technologies
(SLATE‚Äô16), ser. OpenAccess Series in Informatics (OASIcs), vol. 51.
Dagstuhl, Germany: Schloss Dagstuhl‚ÄìLeibniz-Zentrum fuer Informatik,
2016, pp. 6:1‚Äì6:9.
[3] M. Ducasse, ‚ÄúCoca: an automated debugger for C,‚Äù in Proceedings of
the 1999 International Conference on Software Engineering, May 1999,
pp. 504‚Äì513.
[4] G. Marceau, G. H. Cooper, S. Krishnamurthi, and S. P. Reiss, ‚ÄúA
dataÔ¨Çow language for scriptable debugging,‚Äù in Proceedings. 19th In-
ternational Conference on Automated Software Engineering, 2004., Sept
2004, pp. 218‚Äì227.
[5] Y . P. Khoo, J. S. Foster, and M. Hicks, ‚ÄúExpositor: Scriptable time-travel
debugging with Ô¨Årst-class traces,‚Äù in Proceedings of the 2013 Interna-
tional Conference on Software Engineering, ser. ICSE ‚Äô13. Piscataway,
NJ, USA: IEEE Press, 2013, pp. 352‚Äì361.
[6] S. P. Reiss, ‚ÄúThe paradox of software visualization,‚Äù in Proceedings
of the 3rd IEEE International Workshop on Visualizing Software for
Understanding and Analysis, ser. VISSOFT ‚Äô05. Washington, DC,
USA: IEEE Computer Society, 2005, pp. 59‚Äì63.
[7] K. Damevski, D. Shepherd, and L. Pollock, ‚ÄúA Ô¨Åeld study of how devel-
opers locate features in source code,‚Äù Empirical Software Engineering,
vol. 21, no. 2, pp. 724‚Äì747, 2016.
[8] J. Wang, X. Peng, Z. Xing, and W. Zhao, ‚ÄúAn exploratory study
of feature location process: Distinct phases, recurring patterns, and
elementary actions,‚Äù in Proceedings of the 2011 27th IEEE International
Conference on Software Maintenance, ser. ICSM ‚Äô11. Washington, DC,
USA: IEEE Computer Society, 2011, pp. 213‚Äì222.
[9] A. J. Ko, H. H. Aung, and B. A. Myers, ‚ÄúEliciting design requirements
for maintenance-oriented IDEs: A detailed study of corrective and
perfective maintenance tasks,‚Äù in Proceedings of the 27th International
Conference on Software Engineering, ser. ICSE ‚Äô05. New York, NY ,
USA: ACM, 2005, pp. 126‚Äì135.[10] H. Agrawal and J. R. Horgan, ‚ÄúDynamic program slicing,‚Äù SIGPLAN
Not., vol. 25, no. 6, pp. 246‚Äì256, Jun. 1990.
[11] D. Binkley, N. Gold, M. Harman, S. Islam, J. Krinke, and S. Yoo,
‚ÄúORBS: Language-independent program slicing,‚Äù in Proceedings of
the 22Nd ACM SIGSOFT International Symposium on Foundations of
Software Engineering, ser. FSE 2014. New York, NY , USA: ACM,
2014, pp. 109‚Äì120.
[12] H. V . Nguyen, C. K ¬®astner, and T. N. Nguyen, ‚ÄúCross-language program
slicing for dynamic web applications,‚Äù in Proceedings of the 2015 10th
Joint Meeting on Foundations of Software Engineering, ser. ESEC/FSE
2015. New York, NY , USA: ACM, 2015, pp. 369‚Äì380.
[13] L. Layman, M. Diep, M. Nagappan, J. Singer, R. DeLine, and G. Veno-
lia, ‚ÄúDebugging revisited: Toward understanding the debugging needs of
contemporary software developers,‚Äù in 2013 ACM / IEEE International
Symposium on Empirical Software Engineering and Measurement. Los
Alamitos, CA, USA: IEEE Computer Society, 2013, pp. 383‚Äì392.
[14] A. Michail, ‚ÄúBrowsing and searching source code of applications written
using a GUI framework,‚Äù in Proceedings of the 24th International
Conference on Software Engineering, ser. ICSE ‚Äô02. New York, NY ,
USA: ACM, 2002, pp. 327‚Äì337.
[15] R. Holmes and D. Notkin, ‚ÄúEnhancing static source code search with
dynamic data,‚Äù in Proceedings of 2010 ICSE Workshop on Search-driven
Development: Users, Infrastructure, Tools and Evaluation, ser. SUITE
‚Äô10. New York, NY , USA: ACM, 2010, pp. 13‚Äì16.
[16] A. Chis ¬∏, T. G ÀÜƒ±rba, J. Kubelka, O. Nierstrasz, S. Reichhart, and A. Syrel,
‚ÄúMoldable, context-aware searching with Spotter,‚Äù in Proceedings of the
2016 ACM International Symposium on New Ideas, New Paradigms, and
ReÔ¨Çections on Programming and Software, ser. Onward! 2016. New
York, NY , USA: ACM, 2016, pp. 128‚Äì144.
[17] M. Sul ¬¥ƒ±r and J. Porub ¬®an, ‚ÄúGenerating method documentation using
concrete values from executions,‚Äù in 6th Symposium on Languages,
Applications and Technologies (SLATE‚Äô17), ser. OpenAccess Series in
Informatics (OASIcs), vol. 56, 2017, pp. 3:1‚Äì3:13.
[18] A. J. Ko and B. A. Myers, ‚ÄúDebugging reinvented: Asking and answer-
ing why and why not questions about program behavior,‚Äù in Proceedings
of the 30th International Conference on Software Engineering, ser. ICSE
‚Äô08. New York, NY , USA: ACM, 2008, pp. 301‚Äì310.
[19] J. Ressia, A. Bergel, and O. Nierstrasz, ‚ÄúObject-centric debugging,‚Äù in
Proceedings of the 34th International Conference on Software Engi-
neering, ser. ICSE ‚Äô12. Piscataway, NJ, USA: IEEE Press, 2012, pp.
485‚Äì495.
[20] V . Rajlich and N. Wilde, ‚ÄúThe role of concepts in program compre-
hension,‚Äù in Program Comprehension, 2002. Proceedings. 10th Interna-
tional Workshop on, 2002, pp. 271‚Äì278.
[21] K. Chen and V . Rajlich, ‚ÄúCase study of feature location using
dependence graph,‚Äù in Proceedings of the 8th International Workshop
on Program Comprehension, ser. IWPC ‚Äô00. Washington, DC, USA:
IEEE Computer Society, 2000, pp. 241‚Äì247. [Online]. Available:
10.1109/WPC.2000.852498
[22] J. Bohnet and J. D ¬®ollner, ‚ÄúAnalyzing dynamic call graphs enhanced
with program state information for feature location and understanding,‚Äù
inCompanion of the 30th International Conference on Software Engi-
neering, ser. ICSE Companion ‚Äô08. New York, NY , USA: ACM, 2008,
pp. 915‚Äì916.
[23] D. Liu, A. Marcus, D. Poshyvanyk, and V . Rajlich, ‚ÄúFeature location
via information retrieval based Ô¨Åltering of a single scenario execution
trace,‚Äù in Proceedings of the Twenty-second IEEE/ACM International
Conference on Automated Software Engineering, ser. ASE ‚Äô07. New
York, NY , USA: ACM, 2007, pp. 234‚Äì243.
[24] V . Anwikar, R. Naik, A. Contractor, and H. Makkapati, ‚ÄúDomain-driven
technique for functionality identiÔ¨Åcation in source code,‚Äù ACM SIGSOFT
Software Engineering Notes, vol. 37, no. 3, pp. 1‚Äì8, May 2012.
[25] T. Savage, M. Revelle, and D. Poshyvanyk, ‚ÄúFLAT3: Feature location
and textual tracing tool,‚Äù in Proceedings of the 32nd ACM/IEEE Inter-
national Conference on Software Engineering - Volume 2, ser. ICSE ‚Äô10.
New York, NY , USA: ACM, 2010, pp. 255‚Äì258.
[26] F. Beck, B. Dit, J. Velasco-Madden, D. Weiskopf, and D. Poshyvanyk,
‚ÄúRethinking user interfaces for feature location,‚Äù in Proceedings of the
2015 IEEE 23rd International Conference on Program Comprehension,
ser. ICPC ‚Äô15. Piscataway, NJ, USA: IEEE Press, 2015, pp. 151‚Äì162.
[27] S. Hayashi, H. Kazato, T. Kobayashi, T. Oshima, K. Natsukawa,
T. Hoshino, and M. Saeki, ‚ÄúGuiding identiÔ¨Åcation of missing scenarios
for dynamic feature location,‚Äù in 2016 23rd Asia-PaciÔ¨Åc Software
Engineering Conference (APSEC), Dec. 2016, pp. 393‚Äì396.
393
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:57:18 UTC from IEEE Xplore.  Restrictions apply. 