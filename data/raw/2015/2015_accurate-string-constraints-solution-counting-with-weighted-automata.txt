Accurate String Constraints Solution Counting with
Weighted Automata
Elena Sherman
Computer Science Department
Boise State University
Boise, ID, USA
elenasherman@boisestate.eduAndrew Harris
Computer Science Department
Boise State University
Boise, ID, USA
DrewHarris665@u.boisestate.edu
Abstract —As an important extension of symbolic execution
(SE), probabilistic symbolic execution (PSE) computes execution
probabilities of program paths. Using this information, PSE can
prioritize path exploration strategies. To calculate the probability
of a path PSE relies on solution counting approaches for the
path constraint. The correctness of a solution counting approach
depends on the methodology used to count solutions and whether
a path constraint maintains a one-to-one relation with program
input values. This work focuses on the latter aspect of the solution
counting correctness for string constraints.
In general, maintaining a one-to-one relation is not always
possible, especially in the presence of non-linear constraints. To
deal with this issue, researchers that work on PSE for numerical
domains either analyze programs with linear constraints, or
develop novel techniques to handle solution counting of non-
linear constraints. For the string domain, however, previous
work on PSE mainly focuses on efﬁcient and accurate solution
counting for automata-based string models and has not inves-
tigated whether a one-to-one relationship between the strings
encoded by automata and input string values is preserved. In
this work we demonstrate that traditional automata-based string
models fail to maintain one-to-one relations and propose to
use the weighted automata model, which preserves the one-to-
one relation between the path constraint it encodes and the
input string values. We use this model to implement a string
constraint solver and show its correctness on a set of non-trivial
synthetic benchmarks. We also present an empirical evaluation of
traditional and proposed automata solvers on real-world string
constraints. The evaluations show that while being less efﬁcient
than traditional automata models, the weighted automata model
maintains correct solution counts.
Index T erms —probabilistic symbolic execution, string con-
straints, quantitative program analysis
I. I NTRODUCTION
Symbolic execution (SE) [1], [2] is a path-sensitive pro-
gram analysis technique that assists with ﬁnding program
defects [3]–[5], generating test cases [6]–[8] and detecting
vulnerabilities [9]–[11]. SE traverses each execution path of a
program with symbolic input values that represent all concrete
inputs of that program. During analysis, SE expresses program
variables as functions over symbolic values and at each
branching point SE creates a predicate over those symbolic
values and adds it to the path constraint. Hence, a path
constraint represents the restricted set of concrete input values
that can follow that branch. To test the feasibility of a branch
outcome, SE passes the path constraint to a satisﬁability solverto determine whether the newly added predicate is consistent
with the old predicates in the path constraint.
One of the valuable extensions of SE is probabilistic sym-
bolic execution (PSE) [12], which is a quantitative analysis.
PSE computes the probability with which a concrete program
execution could follow a given program path. Using these
probability values, PSE establishes a complete order on exe-
cution paths, which helps with sidestepping the path explosion
problem of SE. For example, researchers leveraged path pri-
orities to (a) analyze ﬁrst less probable paths, since testing
is more likely to miss them [12], (b) thoroughly examine
most commonly executed code for defects, and (c) establish
the reliability of software by comparing the probabilities of
successful and failed paths [13]. Similarly to SE, PSE explores
program paths, but at a branching point PSE computes the
sizes of the solution sets for the path constraints before the
branching point and after it, i.e., after the addition of a new
predicate. The ratio between the latter and the former deﬁnes
the probability for that branch outcome on that program path.
The fundamental premise of the correctness for such prob-
ability calculation is that the solution set of path constraints
must maintain a one-to-one relation with the set of concrete
inputs to a program. When this relation is broken, one cannot
be certain that PSE computes accurate probabilities. Conse-
quently, PSE might provide false reliability reports or miss
critical program defects. For example, for path constraints
over numerical domains this one-to-one relation breaks in
the presence of non-linear operations since it introduces non-
linear predicates in path constraints. While for the integer
domain this problem has yet to be addressed, researchers
investigated approaches to compute the size of a solution
set for an arbitrary function over real numbers [14], [15].
Thus, researchers working on advancing PSE for numerical
domains acknowledge this problem by either limiting the
applicability of their tools to linear constraints, or developing
new methodologies for solution counting1in the presence of
non-linear constraints.
Besides numerical programs, researchers use SE to de-
tect security vulnerabilities in string manipulating programs,
1We use this phrase instead of model counting since we reserve the term
“model” to discuss symbolic string modeling.
4402019 34th IEEE/ACM International Conference on Automated Software Engineering (ASE)
978-1-7281-2508-4/19/$31.00 ©2019 IEEE
DOI 10.1109/ASE.2019.00049
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:04 UTC from IEEE Xplore.  Restrictions apply. Symb state
x←X
-2≤X≤2
x←X-2
-2≤X≤2
x←X-2
-2≤X≤2
∧X-2==0Inputs Solution set
void m(int x)
F T{-2,-1,0,1,2 }{ -2,-1,0,1,2 }
x=x-2
{-2,-1,0,1,2 }{ -2,-1,0,1,2 }
if(x == 0)
{-2,-1,0,1}{ -2,-1,0,1}
4/5 4/5{2}{ 2}
1/5 1/5
(a)Symb state
x←X
-2≤X≤2
x←Y
-1≤Y≤1
x←Y
-1≤Y≤1
∧Y==0Inputs Solution set
void m(int x)
F T{-2,-1,0,1,2 }{ -2,-1,0,1,2 }
x=x/2
{-2,-1,0,1,2 }{ -1,0,1}
if(x == 0)
{-2,-2}{ -1,1}
2/5 2/3{-1,0,1}{ 0}
3/5 1/3
(b)Symb state
x←X
-2≤X≤2
x←X-2
-2≤X≤2
x←X-2
-2≤X≤2
∧evenInputs Solution set
void m(int x)
F T{-2,-1,0,1,2 }{ -2,-1,0,1,2 }
x=x-2
{-2,-1,0,1,2 }{ -2,-1,0,1,2 }
if(x%4 == 0)
{-1,0,1}{ -2,-1,0,1,2 }
3/5 5/5{-2,2}{ -2,0,2}
2/5 3/5
(c)
Fig. 1. Examples of exact counting (a), under-counting (b), and over-counting (c) for the integer domain.
such as password veriﬁcation, input sanitization and database
queries generation [16]–[18]. In this case SE’s path constraints
consist of expressions and predicates over symbolic strings.
In order to support such analysis several string constraint
solvers have emerged. They use different representations to
model symbolic strings, for example, JSA [19], Stranger
[20] use automata-based representation; Z3-str [21], S3 [22],
S3P [23] use a set of axioms and uninterpreted functions; some
solvers model them as bitvectors [24]–[26]. With the increased
interest in quantitive analysis of string manipulating programs
researchers extended string constraint solvers to support solu-
tion counting. For example, Stranger is extended to a solution
counting solver ABC [27], and S3P [23] to S3# [22]. PSE
for strings uses the solution count of a string path constraint
to determine the probability with which concrete executions
realize this path.
In this paper we focus on automata-based string con-
straint solvers since previous work on empirical evaluation
of Java string constraint solvers for SE [28] identiﬁed that
an automata-based solver such as Stranger or JSA is a better
suited for symbolically executing string manipulating Java
programs. Previous work on automata-based solution counting
focuses on developing efﬁcient approaches to accurately count
the solution set for a symbolic string constraint for a given
boundk. That is, counting the number of strings up to length
kin the language of a ﬁnite automaton. To do so, researchers
utilize either generating functions [27], [29] or caching [30],
which in addition to PSE, can be used in different contexts
such as quantitative information ﬂow [31]–[33]. The most
recent work introduces a multi-track automata symbolic string
model MT-ABC [34] that extends the ABC solver to enable
efﬁcient solution counting for mixed integer and numerical
constraints.
To the best of our knowledge, PSE for strings lacks research
on identifying conditions under which the one-to-one relation
between the input string values and the solution set of an
automaton is preserved and under what conditions it breaks.
Our work aims to ﬁll this gap by (1) stating the problem,
(2) examining the solution counting accuracy of traditional
automata-based symbolic string models, and (3) proposing the
improvement in accuracy with weighted automata models [35].To do so we extend JSA, i.e., automata-based string constraint
solver, to produce solution counts and compare it to our
implementation of weighted automata.
In this work we demonstrate that traditional automata
models inherently cannot maintain a one-to-one relation be-
tween the input string values and string constraint solution
counts. This relation either becomes non-injective leading to
over-counting , or becomes non-surjective leading to under-
counting . Our work contributes to the state-of-the-art of solu-
tion counting for symbolic string constraints as follows:
•It brings attention to under-counting and over-counting
problems for automata-based string models.
•It improves solution counting accuracy by employing the
weighted automata model to represent symbolic strings.
•It veriﬁes the correctness of weighted automata results by
comparing the answers with the actual solution counts.
•It evaluates accuracy and performance of traditional
automata and weighted automata models on real-world
benchmark.
II. O VERVIEW
To explain under-counting and over-counting in PSE, we
ﬁrst demonstrate them on PSE over integer variables. Note
that under-counting and over-counting problems differ from
under-approximating and over-approximating solution counts
of constraints. In the former, the model used to express
path constraints has either a non-surjective or a non-injective
relation with the input values, which causes under-counting or
over-counting, respectively, of the correct solution count. In
the latter, the model for expressing paths constraints maintains
a one-to-one relation with the input values, but the method
used to count the solutions in the model is approximate. In
other words, the former is due to poor quality of models used
to represent constraints, while the latter is due to inaccurate
counting techniques.
A. The Integer Domain
Consider Figure 1(a) that shows a diagram of PSE’s analysis
for a simple code snippet. On the left is the PSE’s execution
tree and on the right shaded in gray are symbolic states for
the input variable x. A symbolic state, which describes an
441
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:04 UTC from IEEE Xplore.  Restrictions apply. Symb state
0 A
b≤1
0 1A
A
b≤2
0 1 2A
A A
b≤4Inputs Solution set
void n(String s, String s1)
F T{ε,A}{ε,A}
s = s.concat("A")
s1=s1.concat("A")
{ε,A}{ A, AA}
s = s.concat(s1)
{ε,A}×{ε,A}{ AA,AAA,AAAA }
if(s.equals("AAA"))
{εε, AA,}{ A, AAAA }
2/4 2/3{εA, Aε}{ AAA}
2/4 1/3
(a)Symb. state
0 B
b≤1
0 1B
A
b≤2
0 1 2B
AB
A
b≤4Inputs Solution set
void n(String s, String s1)
F T{ε,B}{ε,B}
s = s.concat("A")
s1=s1.concat("A")
{ε,B}{ A, BA}
s = s.concat(s1)
{ε,B}× {ε,B}{ A, BA}2∪
{ABBA, BBAA }
if(s.contains("BB"))
{εε,εB, Bε}{ AA, BAA,
ABA, BABA }∅{ ABBA, BBAA }
0/4 2/6
(b)
Fig. 2. Examples of (a) under-counting and (b) over-counting of the Bounded model
incoming state into a program statement, consists of a sym-
bolic value of xand a path constraint over symbolic variables.
For example, before statement x=x- 2 the variable xhas
symbolic value Xwith the constraint -2 ≤X≤2.
The inner nodes of the execution tree have bottom and top
text lines. The bottom line is a program statement, e.g., x
=x-2 . The text on the top line shown in a bold font is
the list of concrete input values reaching that statement, and
the text in a regular font is the solution set encoded in the
corresponding path constraint. For example, the second node
with the statement x=x-2 has concrete input values
{-2,-1,0,1,2 }and the solution set of the incoming symbolic
state is{-2,-1,0,1,2 }. The top line of leaf nodes has the same
meaning, while the bottom one describes the actual (in a bold
font) and computed by PSE (in a regular font) probabilities.
After examining this execution tree, we can see that the
input values and the solution set match exactly for every
node. Upon taking a true branch of the conditional statement,
PSE updates the model for xand computes the probability as
|{2}|/|{-2,-1,0,1,2}|=1/5for the true branch and similarly
for the false branch. In each case, the concrete input values
and the solution set a one-to-one relation between them.
Now consider the second example in Figure 1(b), where the
second node has a division operation. To handle a non-linear
constraint, PSE introduces a new symbolic variable Yand
precisely estimate its bounds -1 ≤Y≤1. While such approach
works well for satisﬁability check, it introduces inaccuracy in
PSE’s solution counting since it breaks the one-to-one relation
between the input values and the solution set. On the entrance
to the branching node the input values set has ﬁve elements
while the solution count of the symbolic constraint -1 ≤Y≤1
is one. The relation between those two sets became non-
surjective. Thus, the solution set incoming into the conditional
statement if(x == 0) node differs from the input values,which causes PSE to predict a wrong branch as more likely to
be executed. We call cases when PSE has a decreased solution
count because two or more elements of the concrete input set
map to a single element of the solution set as under-counting .
Figure 1(c) demonstrates another case when PSE is unable
to handle modulo 4 operation, but can over-approximate it
witheven set. In this case, a solution count of the true branch
outcome contains an extra element 0, while the false branch
outcome contains all odd values and some even values. This
example demonstrates a case of solution over-counting , since
the solution sets of both branches have more elements than
the corresponding sets of the concrete values.
B. The String Domain
A symbolic string variable can be represented by a ﬁnite
automaton, where the language of the automaton is the solu-
tion set of the symbolic variable. For PSE, a string symbolic
variable is bounded by k, which is the bound on the length of
strings in its solution set. Therefore, if k≤2then all strings
with length two or less accepted by an automaton comprise the
solution set of that symbolic variable. We call this modeling of
symbolic strings, i.e., a possible cyclic ﬁnite automaton and a
boundk,a s Bounded . As PSE interprets program statements,
it not only updates the automaton but also the bound k.F o r
example, in the case of a concatenation of two strings k
increases, for character removal in a string kdecreases.
1) The Bounded Automata Model: Given alphabet Σand a
input string length bound k, we deﬁne the Bounded (B) model,
its initial values, and the model’s solution count scas:
Deﬁnition 1: The Bounded model is composed of a bound
b∈Nand an automaton A=(Q,Σ,E,q 0,F), whereQis a
set of states, a set of transitions E={(p,x,q)|p,q∈Q,x∈
Σ},q0∈Qis the start state and F⊆Qis a set of ﬁnal states.
442
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:04 UTC from IEEE Xplore.  Restrictions apply. A new symbolic value has Ainitwith language L(Ainit)=
Σ∗andb=k. The solution count is
sc(B)=|{x|x∈L(A)∧|x|≤b}|
To primarily focus on the ability of an automata model to
produce accurate solution counts, we consider the most precise
solution counting and automata manipulations algorithms.
Figure 2(a) illustrates how PSE computes probabilities with
the Bounded model. The diagram has the same layout as the
previous examples for the integer domain. To save some space
and omit duplicating information, we only depict the symbolic
state for svariable, since s1has an identical symbolic state
for the ﬁrst two statements. In this example, the initial bound
isk=1 andΣ={A}. Thus, s’s initial symbolic value is an
automaton with only one state, which is the start and ﬁnal state,
and has a self loop on A, i.e., its language is Σ∗. Therefore,
the input variables can hold either string εor"A". After
the concatenation operation with the string Ain the second
tree node, PSE produces a new automaton and increments
the bound to 2. Even though after this operation the input
set{ε,A}does not match the solution set {A,AA}of the
automaton, the one-to-one relation is preserved.
After the second concatenation with s1in the third node,
the set of input values is described as the cross product of the
input values for sands1with size four. However, the resulting
solution set of the automaton with b≤4produces only three
strings. When we apply s.equals("AAA") predicate, PSE
evaluates the probability of the true branch to 30%, while
the correct value is 50%. This is because Bounded lost an
extra count of the string AAA due to its inability to distinguish
between two AAA strings produced by the input tuples (ε,A)
and(A,ε). This type of behavior of the Bounded model
results in under-counting of the solution set.
When we extend the alphabet to {A,B}and assume that
input strings can only contain symbol B, then the Bounded
model can also over-count the solution set as we demonstrate
in Figure 2(b). After the last concatenation operation, in
addition to the expected {A,BA}2set of strings the model
also introduces two more spurious strings, which affect the
probability value of the outcome: instead of actual probability
of 0% for the true path PSE computes about 33%. Hence, the
above examples demonstrate that even though the Bounded
model for encoding symbolic strings is suitable for SE, it
might cause PSE to compute incorrect probabilities.
2) Acyclic Automata Model: We ﬁrst focus on improving
the Bounded model to eliminate over-counting as shown in
Figure 2(b). The reason for over-counting is the presence of
cycles in the automaton for the Bounded model. After the
concatenation operation with another symbolic string value,
it is impossible to determine whether a given preﬁx and the
sufﬁx of a string is accepted by the concatenated automata
individually. In the case of the spurious string ABBA , the
Bounded model has no means to enforce that ABandBA
should be accepted by the concatenated automata.
To avoid over-counting, we can create an automaton that
implicitly encodes all strings up to the bound k. We callvoid m(String s, String s1)
0 1B
s = s.concat("A")
0
12
BA
A
s = s.concat(s1)
0
12 4
3BA
AA
BA
(a)void m(String s)
0 1A,B
s = s.concat("A")
0
12
A,BA
A
s = s.delete(1,2)
0 2A,B
if(s.contains("A"))
F T
{B}{ B}
1/3 1/2{ε,A}{ A}
2/3 1/2
(b)
Fig. 3. Examples of the Acyclic model: (a) solving over-approximation and
(b) failing on deletion.
this the Acyclic model, since such automaton has no cycles.
Figure 3(a) shows the execution tree and symbolic states for
sinput variable, using the Acyclic model for k=1 and
Σ={A,B}to encode symbolic strings. To save space,
instead of the entire PSE tree, we depict sequentially its
nodes and the symbolic state they produce. After the method
header statement there is the initial Acyclic automata for
k=1. As the diagram demonstrates, after two concatenations
the resulting automaton encodes exactly four strings, which
matches the list of concrete inputs.
We deﬁne Acyclic (A) model for a given alphabet Σand
an initial bound kas well as its initial values and its solution
count (SC) as follows:
Deﬁnition 2: The Acyclic model is an automaton A=
(Q,Σ,δ,q 0,F)with the same elements as in Bounded.
A new symbolic value is Ainit with the language
L(Ainit)=Σk. The solution count is deﬁned as
sc(A)=|L(A)|
Compared to the Bounded model, Acyclic requires more
space for its encoding. For example, for the initial sym-
bolic value Bounded has only one state for any value of k,
while Acyclic requires k+1 states. Since the automaton of
the Acyclic model is more likely to have more states than
Bounded, then applying the string operations on the Acyclic
model would require more time to complete. That is, the PSE
with the Acyclic model would require more space and time
to analyze than the PSE with the Bounded model. However,
Acyclic uses the same algorithms for method operations and
predicates as for the Bounded model.
While eliminating the over-counting issue of the Bounded
model, the Acyclic model suffers with under-counting in
the presence of string modifying operations similar to
delete(int s, int e) as illustrated in Figure 3(b). In
our example, the delete operation adheres to its Java’s
443
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:04 UTC from IEEE Xplore.  Restrictions apply. StringBuffer API: if the second argument is greater than
the length of the string then the second argument is set to
that length; and if the ﬁrst and the second arguments are
the same then the string is not modiﬁed. Therefore, delete
operation with s=1 ande=2 on the automaton, does not
change the string A, but changes two other strings. This action
corresponds to the removal of the transition (1,A,2)from the
automaton. After this operation, the state 1 is marked as ﬁnal.
After determinizing the automaton, it has two states with the
transitions AandBbetween them. This modiﬁcation causes
two input values εandAto be represented with one solution
A. Such scenario leads to under-counting in solution counts,
which results in incorrect computations of the probabilities in
the leaf nodes. Thus, we need a better automata model that is
able to eliminate under-counting.
III. W EIGHTED AUTOMATA MODEL
Modern programming languages provide String APIs with
non-trivial string altering operations such as deletion of sub-
strings. Many of those methods are not injective, that is
when applied to two distinct strings those methods produce
the same output strings, which traditional automata cannot
distinguish. To address this deﬁciency we need to ﬁnd an
automata model able to encode a multiset of strings, that is a
model that remembers the count of identical strings. Through
literature search, we found that researchers working in natural
language processing, image processing and machine learning
also require automata that tracks multiplicity values of each
string and to do so, they use the weighted automata model [35].
Researchers have extensively studied the theory of weighted
automata [36], developed essential optimization algorithms
such as determinizaiton [37] and efﬁcient data-structured for
their implementations [38]. The novelty of our work is in the
application of weighted automata to PSE for strings.
The main difference between the traditional automata and
the weighted automata models is in the labeling of transitions
and the ﬁnal states. A transition of a weighted automaton is
described by a tuple (x,w), where the ﬁrst element represents
the symbol to transition on and the second element is the
weight of such transition. For example, a transition with label
(A,2)indicates that the weight of such transition is two, i.e.,
there are two transitions between the same states on the same
symbolA. Each ﬁnal state of a weighted automaton has a
weightwvalue assigned to it. It indicates that all strings
ending on this state appears wtimes in the language’s multiset.
The weight of a string deﬁnes the multiplicity value of the
string and is calculated as a product of the transition weights
and the weight of the ﬁnal state on the string’s accepting path.
In the case of a non-deterministic weighted automaton the
weight of the string is the sum of the weights of all string’s
accepting paths.
Figure 4 depicts two weighted automata with the same mul-
tiset language. For illustration purposes we use superscripts to
indicate weights. In this example the start state 02is also a
ﬁnal state and has the weight value of 2. It means that in
this automaton’s language the empty string appears twice. To0221
3B2
A2B10222
3B1
A1B1
Fig. 4. Two weighted automata with the same multiset language
{ε,ε,B,B,AB,AB }
compute the weight of string Bwe need to add the weights
of all its accepting paths in the weighted automata. In our
example each of the weighted automata has only one path:
from the state 02to the state 21with the transition weight of
2 for the ﬁrst one and from the state 02to the sate 22with
the transition weight of 1 for the second one. This results in
2×1=2 and1×2=2 weights, respectively. The weight of
stringAB is computed as 2·1·1for the ﬁrst automaton and
as1·1·2for the second one.
Formally, a weighted automaton is deﬁned over a semiring
S=(S,⊕,⊗,¯0,¯1), where the set Srepresents the weight
values,⊕,⊗are the addition and multiplication operations,
respectively, deﬁned on S, and¯0,¯1are the identity elements
for those operations. A semiring enforces distributivity of
multiplication over addition, but has no additive inverses. Now,
we present a formal deﬁnition of a weighted automaton.
Deﬁnition 3: A weighted automaton Aover a semiring S,i s
an 6-tuple A=(Q,Σ,E,q 0,F,ρ), whereQis a set of states,
q0∈Qis the start state, F⊆Qis a set of ﬁnal states, Eis a
set of weighted transitions {(p,x,w,q)|p,q∈Q,x∈Σ,w∈
S}andρ:F→Sis a ﬁnal states weight function.
For a given string X=x0x1...xnaccepted by Athrough
a pathp=(q0,q1,...,q n)such that qn∈F, the weight of
Xis calculated as follows:
wt(p)=ρ(qn)⊗/circlemultiplydisplay
0≤i<nwi:(qi,xi,wi,qi+1)∈E
The behavior of a weighted automaton for a given string wis
deﬁned as following:
A(X)=/circleplusdisplay
∀pforXwt(p)
Depending on a choice of the semiring, a weighted au-
tomaton can calculate different quantitative properties. Thus,
in the case of traditional automata the choice of semiring is
the ringB=(B,∧,∨,true,false )that only allows deciding
the acceptance of X, but ensures useful properties of tradi-
tional automata. For some optimization algorithms, such as
determinization, a semiring must be a weakly divisible semir-
ing, where all non- ¯0elements have inverses. Since applying
optimization algorithms are essential for weighted automata
applicability, in our implementation we use the positive ratio-
nal numbers Q+asS, which makes Q=(Q+,+,×,0,1)a
weakly divisible semiring.
A. Properties and Operations for Weighted Automata
Before we describe how we apply the weighted automata
for PSE, we brieﬂy discuss weighted automata unique proper-
ties [36] for general semirings and for our choice Q. First,
444
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:04 UTC from IEEE Xplore.  Restrictions apply. as demonstrated in [36] not all non-deterministic weighted
automata have a deterministic equivalent. However, for Qa
non-deterministic automaton has its deterministic equivalent.
Second, as illustrated in Figure 4, there is no unique minimal
deterministic automaton for a given string multiset. However,
if a weighted automaton is deﬁned over a weakly divisible
semiring such as Q, then this uniqueness property is preserved
through a weight pushing algorithm [37].
Weighted automata are also closed under traditional op-
erations such as union, concatenation, Kleene-closure, and
intersection operations. However, the complement operation
deserves a special discussion, as it is not deﬁned for an
arbitrary weighted automaton since unlike rings, semirings do
not have additive inverse, i.e., /circleminus. For traditional automata that
are deﬁned over the ring Ba complement operation is deﬁned.
But, for our application of weighted automata over Q,w e
cannot deﬁne a positive additive inverse in Q+. For example,
consider a value n∈Nthat describes the multiplicity number
of a string X, then it is unclear what would be the meaning
of complementing number of n.
Fortunately, a string solver does not require the explicit
deﬁnition of the complement operation. Solvers with tradi-
tional automata use the complement operation to compute
the difference of two automata, which in its turn used to
implement complex string methods such as the negation of
contains(String s) . As shown in [37], a difference
operation A1−A 2can be deﬁned for a weighted automaton A1
and a traditional automaton A2. Thus, before applying the dif-
ference operation on two weighted automata, we must change
A2to a traditional automaton by setting all its weights to one,
which is an inexpensive operation ( O(|F|+|E|)). However,
the implication of this simpliﬁcation is potential undercounting
of solutions if A2encoded strings with multiplicity of greater
than one.
B. The Weighted Automata Model
A PSE string solver consists of two parts: an underlying
model for representing a symbolic string and a collection
of algorithms for symbolic string manipulations. Since the
presence of cycles results in spurious strings as show in
Figure 2(b), we only consider the acyclic weighted automata
model (W) and deﬁne it as follows:
Deﬁnition 4: The acyclic Weighted model is deﬁned as
a weighted automaton A=(Q,Σ,E,q 0,F,ρ)overQwith
elements described in Deﬁnition 3 and an initial bound k.
A new symbolic value is Ainit with the language
L(Ainit)=Σkwith the string multiplicity set to one to deﬁne
a uniform distribution of input values.
The solution count is
sc(W)=/circleplusdisplay
∀X∈L(A)A(X)
In order to use the Weighted model in a string constraint
solver, we need to deﬁne a set of transfer functions that
imitate the effects of Java String APIs on weighted automata.
Commonly such transfer functions are deﬁned using classicalAlgorithm 1 Anε-transition between states pandqinA
1:function EFREETRANSITION (p,q,A)
2: if∃(p/prime,x,w,p )∈Ethen
3: for all (p/prime,x,w,p )∈Edo
4: w/prime←w
5: ifp∈Fthen
6: w/prime←w/prime⊗ρ(p)
7: end if
8: E←E∪{(p/prime,x,w/prime,q)}
9: end for
10: else
11: for all (q,x,w,q/prime)∈Edo
12: w/prime←w
13: ifq∈Fthen
14: w/prime←w/prime⊗ρ(q)
15: end if
16: E←E/unionmulti{(p,x,w/prime,q/prime)}
17: end for
18: ifq∈Fthen
19: ifp∈Fthen
20: ρ(p)←ρ(p)⊗ρ(q)
21: else
22: F←F∪{p}
23: ρ(p)←ρ(q)
24: end if
25: end if
26: end if
27: end function
automata operations such as union, intersection, negation and
concatenation. Previous research on weighted automata de-
ﬁnes these classical operations (except negation) on weighted
automata [37].
One commonly used operation in modeling transfer func-
tions is adding an ε-transition between two states. Those
transitions are later removed by ε-transition removal algo-
rithms. Similar to previous approaches [19], we create an
algorithm that models an ε-transition between two states
without introducing εtransitions, hence eliminating a need
forε-removal algorithm. Algorithm 1 shows the pseudocode
of our implementation. Basically, it considers two main cases:
when the “from” state phas incoming transitions and when
it does not. In the ﬁrst case, the incoming transitions to the
statepare copied to the incoming transitions of qand their
weights are adjusted depending on whether pis a ﬁnal state
or not. In the second case, the outgoing transitions of qare
copied to the outgoing transitions of pand their weights are
adjusted depending on whether qis a ﬁnal state. Also, pis set
as ﬁnal state and its weight is recalculated. The operation /unionmulti
is deﬁned as follows:
E1/unionmultiE2={(p,x,w,q)|(p,x,w,q)∈E1∧(p,x,w/prime,q)/∈E2,
or(p,x,w,q)∈E2∧(p,x,w/prime,q)/∈E1}∪
{(p,x,w,q)|(p,x,w 1,q)∈E1∧(p,x,w 2,q)∈E2,
w=w1⊕w2}
In addition, our transfer functions also use the operation
that converts a weighted automaton Ato a regular automaton
A↓by setting weights in edges and in accepting states to one.
445
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:04 UTC from IEEE Xplore.  Restrictions apply. That is,A↓=(Q,Σ,E↓,q0,F,ρ↓))where∀s∈Fρ↓(s)=1 ,
E↓={(p,x,1,q)|(p,w,1,q)∈E}.
Below we detail deﬁnitions of transfer functions that
model Java String APIs. Our implementation of the Weighted
solver uses Algorithm 1 and the intersection algorithm
of [37] for weighted automata and the negation algorithm
for traditional automata. For an unary automata operation
we assume it is applied to A1=(Q1,Σ,E1,q01,F1,ρ1).
Binary automata operations also uses a second automaton
A2=(Q2,Σ,E2,q02,F2,ρ2). The result of an operation is a
new automaton Ar.
replace(char a, char b) :
Ar=(Q1,Σ,Er,q01,F1,ρ1), where
Er=E\{(p,a,w,q)∈E}/unionmulti
{(p,b,w,q)|(p,a,w,q)∈E}
toLowerCase :
LetY⊂Σbe a set of upper case symbols and X⊂Σ
be a set of lower case symbols, and L:Y→X. Then
Ar=(Q1,Σ,Er,q01,F1,ρ1), where
Er=E\{(p,y,w,q)∈E|y∈Y}/unionmulti
{(p,L(y),w,q)|(p,y,w,q)∈E}
concatenate :
Ar=(Qr,Σ,Er,q01,Fr,ρr)is deﬁned in two steps:
1)Qr=Q1∪Q2,Er=E1∪E2,
Fr=F1∪F2\{p∈F1|∄(p/prime,x,w,p)∈E1orq02/∈F2}
ρr(s)=/braceleftBigg
ρ1(s)ifs∈Q1
ρ2(s)ifs∈Q2
2)∀p∈F1apply eFreeTransition( p,q02,Qr) (Alg. 1)
Fordelete) andsubstring operations, please refer
to our implementation2. In order to model Java String API
complex semantics for those methods the transfer function
algorithms are somewhat intricate. In general they require
ﬁrst to inﬂate an automaton by requiring that for paths up
to certain length all incoming transition to a state should be
from the same state. The algorithms traverse those paths,
delete some transitions and add ε-transitions.
Predicate methods modify A1differently depending
whether they are evaluated to true of false. Therefore, we
deﬁne the resulting automata for each of those cases: At
cfor
true andAf
cfor false.
isEmpty :
LetAεbe an automaton with L(Aε)={ε1}then
At
c=A1∩Aε,Af
c=(Q1,Σ,E1,q01,Ff
c,ρ1)where
Ff
c=F1\{q01}.
equals :
At
r=A1∩A2andAf
r=A1∩A2↓.
2https://github.com/BoiseState/string-constraint-countingAlgorithm 2 Eliminating denominators in weights.
1:function NORMALIZE (A)
2:Q←reverseBSFOrdering (Q)
3: whileQ/negationslash=∅do
4: p←Head (Q)
5: Deqeueu (Q)
6: D←∅
7: for all (p,x,w,p/prime)∈Edo
8: D←D∪Denominator (w)
9: end for
10: ifp∈Fthen
11: D←D∪Denominator (ρ(p))
12: end if
13: w/prime←LeastCommonMultiple (D)
14: ifp∈Fthen
15: ρ(p)←ρ(p)⊗w/prime
16: end if
17: for all (p,x,w,p/prime)∈Edo
18: w←w⊗w/prime
19: end for
20: for all (p/prime,x,w,p )∈Edo
21: w←w⊗(w/prime)−1
22: end for
23: end while
24: end function
contains :
Let the length of longest string accepted by A1iskand
deﬁneAkto be an automaton with L(Ak)=Σk, then
At
r=A1∩AkA2AkandAt
r=A1∩AkA2↓Ak
To improve the efﬁciency of weighted automata, previous
work [37] provides optimization algorithms such as ε-removal,
determinization and minimization algorithms. The ﬁrst two
algorithms are more complex than for traditional automata
since the weight of the transitions and the ﬁnal states should
be accounted for. The weighted minimization algorithm is
similar to the traditional one, because it interprets each pair
of a symbol and a weight, (x,w)as a single label. We
use determinization, minimization as in [37], and our weight
normalization algorithm (see Algorithm 2) to improve the
performance of the Weighted solver. This algorithm differs
from the weight pushing algorithm presented in [37], which
moves the weights of each path as much as possible toward
the initial state. The objective of the normalization algorithm
is to eliminate denominators. The basic idea is to propagate
backwards from the ﬁnal states to the start the denominators
of rational weights while updating weights of unexplored
transitions.
IV . E V ALUATION
Each automata model we introduce in this paper has its
advantages and disadvantages. Bounded represents a set of
strings more efﬁciently, but produces less accurate solution
counts. Compared to Bounded, Acyclic requires additional
states to encode a set of strings, but it can handle concate-
nations with better accuracy than Bounded. Yet, for other
operations Acyclic and Bounded tend to under-count. We
446
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:04 UTC from IEEE Xplore.  Restrictions apply. expect Weighted to be the most precise but at the same time
less efﬁcient, as algorithms for implementing string operations
and automata optimization have to reason about weights of
transitions and ﬁnal states. The goal of our evaluation is
to compare these three automata models by answering the
following questions:
1) How do the execution times of the models compare to
each other?
2) How accurate is solution counting for these models?
3) How do inaccurate solution counting of these models
inﬂuence the correctness path probabilities calculations?
4) How well the models scale to real string benchmarks?
In order to answer our research questions, we conduct two
kinds of evaluations: one on a set of synthetic benchmarks
and another on a set of real string constraint benchmarks.
While in both experiments we evaluate performance and
precision, we use the former to mainly test the correctness of
the Weighted automata model implementation and the latter
to obtain scalability data. Below we brieﬂy described our
implementation of automata models, and then we present the
evaluation data and discuss the results.
A. Automata Models Implementation
We implemented Bounded and Acyclic models by extending
Java String Analyzer (JSA) [19] version 2.1.-1, which is
implemented in Java. We modeled each Java string operation
with the most precise algorithms available for this classic
automaton as described in [28]. JSA has a highly optimized
representation of automata and efﬁcient implementations of
the core automata algorithms, such as determinization and
minimization.
Since weighted automata cannot be simply extended from
JSA, we implemented in Java the Weighted model and
its solver from scratch. Our implementation also includes
essential performance optimization algorithms such as
determinization, minimization and weight normalization as
described in the previous section. From Java String API,
we implemented the following string predicates: isEmpty ,
contains andequals and the following string operations:
concatenate , delete(int start, int end) ,
substring(int start, int end) ,replace(char
oldChar, char newChar) ,toLowerCase() , all of
which occur in the real string constraint benchmarks we used
in our evaluation.
Since our work primarily investigates the accuracy of the
models in the context of PSE, we implemented a brute-
force algorithm to compute solution counts. Comparing to the
advanced work on efﬁcient solution counting algorithms [27],
[29], this implementation is straight-forward and computes
accurate solution counts. For Bounded, it traverses automata
paths up to depth k, and for Acyclic and Weighted it traverses
the entire automaton and computes their solution counts as
we presented in their deﬁnitions. Even with our brute-force
implementation, the time spent counting solutions is negligible
comparing to the time spent analyzing string constraints.In addition to the three automata models, we also im-
plemented a concrete solver that produces accurate solution
counts of string constraints. We require the correct solution
counts to test our implementation of the Weighted solver. The
concrete solver explicitly tracks the set of input strings, and
invokes Java’s String APIs for operations or predicates that
appear in the string constraint. For example, to represent a
symbolic string with k=2 andΣ={a,b}, the Concrete
solver creates a map and populates its keys with strings ε,a,
b,aa,ba,abandbb, and values with the frequency with which
each string occurs, that is it models a multisite of strings. We
compute the solution count as the sum of all map’s values.
B. Synthetic Benchmark for Correctness Evaluation
Since the Concrete solver explicitly tracks the set of string,
we must limit the alphabet size, the bound kand the com-
plexity of strings constraints for that solver. In particular a
string constraint benchmark should have a small alphabet
size and a small initial bound. Moreover, a string constraint
should have no more than two concatenation operations of
symbolic strings, since the concatenation operation of two
symbolic strings dramatically increases the number of string
the Concrete solver has to track. Thus, processing symbolic
inputs with similar characteristic as in the RockYou1K data
set [39]6≤k≤16and|Σ|= 127 , i.e., all ASCII characters,
would be impossible for the Concrete solver.
A realistic benchmark with the aforementioned parameters
is not available. For this reason, we systematically generated
synthetic benchmarks, which have been proven to be effective
in testing compiler correctness [40] and ﬁnding defects in
symbolic execution engines [41]. We generated 11 benchmarks
with the total of 569 non-trivial string constraints. Each bench-
mark contains sequences of string operations and appends each
of them with one of the three predicates. The bound kvaries
between two and three, and the alphabet size is three except
for the benchmarks containing toLowerCase() operation,
which is set to six in order to include the upper and the
lower cases of the original three alphabet symbols. We also
ensure that no more than three concatenation operations of
symbolic strings occur in a constraint, otherwise the Concrete
solver times out. Parameters for operations and predicates are
randomly chosen from their valid values.
First, we present the execution time experiments as the ratio
of the solver’s execution time to the concrete solver execution
time. Table I captures the count of ratio in ﬁve intervals.
The ﬁrst interval (0,1)contains the number of constraints for
which an automata solver performs faster than the Concrete
solver, i.e., the ratio values are less than one. The second
interval[1,5]has counts for ratios between 1 and 5, that
is an automata model’s execution time is comparable to the
execution time of the Concrete solver. The next three columns
represent counts for moderate, signiﬁcant and large slowdowns
comparing the concrete solver. As we expected, Bounded has
an overall better performance – it executes faster on the largest
number of string constraints and has executions with large
performance slowdowns.
447
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:04 UTC from IEEE Xplore.  Restrictions apply. TABLE I
TIME PERFORMANCE FOR CORRECTNESS EXPERIMENT
Time ratio (0,1)[1,5](5,10](10,50]>50
Bounded 198 250 83 38 0
Acyclic 180 252 79 56 2
Weighted 89 190 124 139 27
●
Bounded Acyclic Weighted0.0 0.5 1.0 1.5 2.0
Automata ModelsSolution Count Ratio
Fig. 5. Solution accuracy ration for each automata model
Next, we present data to demonstrate the solution counting
accuracies of each model comparing to the Concrete one. We
focus on the solution count for a string constraint incoming
into a predicate, that is the solution count before a branch
since this number reﬂects the effect of string operations on
an automata model. We compute the ratio between value
computed by automata solvers and the values produced by the
Concrete solver, i.e., the correct values. Figure IV-B depicts
the results as box plots.
We see that our implementation the Weighted solver is
correct since all ratio values are exactly one. As we expected
Bounded both over-approximated and under approximate, de-
pending on operations present in a string constraint. Also, as
we anticipated Acyclic always under-approximates and never
exceeds the ratio value above 1. Overall, on the set of synthetic
benchmarks both Bounded and Acyclic models tends to under-
count that value by about1
3.
The last set of experiments investigate what effects those
inaccurate counts have on the computations of local and global
probabilities since both kinds of probabilities are used to
prioritize path explorations. The local probability is computed
by dividing the solution count of the path constraint after a
branch by the solution count of the path constraint before
the branch. To compute the global probability of a path PSE
divides the same number by the total number input strings to
a program, which is the same value for all path constraints.
Table II presents that data for accurate branch predication that
we separated in ﬁve different groups. The ﬁrst group “Miss”
tells whether an automata solver predicted a different branch
branch is more likely to be executed than what the concreteTABLE II
ACCURACY EV ALUATION FOR CORRECTNESS EXPERIMENT .
Prob.|Δ|Miss Exact (0%,10%] (10%,30%] >30%
Local probability
Bounded 4 405 145 15 0
Acyclic 4 406 147 12 0
Weighted 0 569 0 0 0
Global probability
Bounded 79 408 42 26 14
Acyclic 86 407 40 24 12
Weighted 0 569 0 0 0
solver predicted. That it the automata solver ”missed” the
correct branch prediction. The second group “Exact” contains
the number of instances when an automaton solver calculates
correct probabilities. The next three groups show ranges of
absolute differences between the probabilities of an automata
solver and the Concrete solver.
As data in Table II demonstrates, the Weighted solver
always computes the exact probabilities. Bounded mispredicts
four branches locally while for the rest predicting correct
outcomes, with 405 exact, 145 slightly deviating and 15 mod-
erately deviating for the actual probability values. For global
probabilities, the number of mispredicted branches increases
and for correctly predicted branches the numbers probabilities
with moderate and highly deviated from the actual values
increase. The Acyclic model follows a similar trend with no-
signiﬁcant differences.
The data show that branch misprediction does occur in the
traditional automata models and has a stronger presence in
global probabilities. Moreover, for the global probabilities the
magnitude of the absolute difference between their computed
and correct value can affect the order in which program paths
are explored by PBS.
Overall the study on synthetic benchmarks gives us con-
ﬁdence that the Weighted solver implemented correctly, and
hence we can use its solution counting as the correct value in
our larger study on real benchmarks. Moreover, this evaluation
shows that the traditional automata models commonly compute
incorrect solution count and it can lead to incorrect branch
predictions. Next, we perform similar experiments but on a
real program benchmarks on three automata-based solvers.
C. Real Benchmarks for Performance and Scalability Evalu-
ations
We use real benchmarks from previous work [28], where
the authors used dynamic symbolic execution to collect string
constraints from eight real Java programs that extensively
use string APIs. Each dynamic execution run results in a
benchmark containing several string constraints. Next, we ﬁlter
constraints in benchmarks by the method implemented in the
Weighted solver and remove a sequence of operations that do
not end in a predicate. These steps produced 30 BEA, 7 HCL,
14 JHP, 31 JXM, 28 MQG, and 24 NCL benchmarks with the
total of 6263 constraints.
For each benchmark, we set a realistic alphabet that contains
both upper and lower case symbols from the English alphabet
448
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:04 UTC from IEEE Xplore.  Restrictions apply. ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●
Bounded Acyclic0.0 0.2 0.4 0.6 0.8 1.0
Automata ModelsSolution Count Ratio
Fig. 6. Solution count accuracy ratio.
and augmented it with special characters if the benchmark uses
them. Hence, the majority of benchmarks have the alphabet
size between 52 and 61. With such large alphabet, and our
observations from the synthetic benchmark evaluations, we
limited values for the initial symbolic string bound kto
{3,5,7}. With the timeout threshold set to one hour to pro-
cessing a single benchmark, both Bounded and Acyclic were
able to compute 6263 constraints for each of the bound values.
However, the Weighted solver was able to compute 6083, 4159
and 100 constraints for kvalues 3, 5 and 7, respectively.
Since this is our initial implementation of the Weighted solver,
it deﬁnitely has many opportunities for optimizations of its
algorithms, or one can use more mature implementations such
as Vcsn [42], which is written in C++ and uses efﬁcient data
structures and algorithms proposed in [38].
We use the similar metrics to evaluate performances and
accuracies of three automata solvers for each bound k. Only
for the performance ratio calculation we use the execution time
of the Bounded solver and for the accuracy we use the solution
counts and probabilities of the Weighted solver in place of the
Concrete solver. Even though Bounded and Acyclic are able to
compute all 6263 constraints for each bound value, we present
data only for the constraints that Weighted was able to process.
We report in Table IV the execution time ratios of Acyclic
and Weighted solver to the Bounded model separated into
the same intervals as the data for the synthetic benchmarks.
We can see that with the increase of kAcyclic’s execution
time does not scale as well as Bounded. The time ratio values
for Weighted demonstrate how dramatically its execution time
increases as kgrowths.
The accuracy of solution counting is shown in Figure 6.
Note that box plots for both Bounded and Acyclic are the
same since real benchmarks do not have concatenation of
two or more symbolic string values, both solvers compute the
same solution counts before predicates. Once again, the data
demonstrates that traditional automata models are unable to
preserve accurate string counts.The data for the last experiment is presented in Table IV.
Again, the Bounded solver misses more branches than the
Acyclic solvers. One might ﬁnd it surprising since as demon-
strated in Figure 6, both solvers produce the same solution
count. The reason is that the Bounded solver tends to perform
inaccurate predicate operations that allow the same strings to
be propagated to both branch outcomes [28]. We can also
observe that with the growth of kthe number of mispredicted
branches decreases. This is because predicates in benchmark
constraints use a concrete string in their arguments, for exam-
ple,s.equals("p") . As the number of strings increases
withk, the proportion for strings that equal to “p” decreases,
thus the correct probabilities computed by Weighted and two
other models approach 0%. However, the number of exactly
calculated probabilities decreases with ksince the larger its
value, the larger is the difference in solution counts. As
before, inaccurate computations are more prevalent in global
probabilities.
Using the presented data we now can answer our research
questions. First, depending on the type of constraints and k
value some solvers might run faster than another. However,
overall we found that the Bounded solver outperforms other
solvers due to its smaller encoding size, with the Acyclic
solver being quite close to it. As expected, the Weighted solver
has the worst execution time, but the current implementation
has room for improvement. Moreover, both the Bounded and
the Acyclic models scale well with the increased symbolic
string length, while the scalability of the Weighted model
deteriorate as kincreases, still it has a much better scalability
than the Concrete solver.
For solution counting accuracy the Bounded solver can
both over-approximate and under-approximate the accurate
solution counts, the Acyclic solver under-approximates the
correct values and the Weighted model always computes the
exact counts. However, in a presence of constraints that use
concrete string values, both Bounded and Acyclic able to
compute correct counts.
For our benchmarks, the affects that solvers and their
incorrect solution counting have on probability calculations
is rather small, but still present for certain type of constraints.
For local probability calculations the most important aspect is
an incorrect identiﬁcation of more likely branch to be taken.
Usually such error is small – about 1.5% for Bounded and even
less than 0.2% for Acyclic. However, such effect is stronger
when calculating global probabilities because for Bounded up
to 30% of calculated probabilities have incorrect values, which
is important since global probabilities are used to create a total
order on program paths. We expect that on benchmarks that
use concatenations of several symbolic strings, or use symbolic
values in predicates those errors would be more signiﬁcant.
V. R ELATED WORK
Our work relates to several bodies of work. First of all,
similar to work presented in [27], [29], [30], [34], [43], our
research investigates solution counting in an automaton. While
the previous efforts focus on efﬁcient and accurate solution
449
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:04 UTC from IEEE Xplore.  Restrictions apply. TABLE III
TIME PERFORMANCE FOR REAL STRING CONSTRAINTS .
Time ratio (0,1) [1 ,5] (5 ,10] (10 ,50] >50
kbound 35 7 35 7 35 7 35 7 35 7
Acyclic 1489 812 33 4587 3338 64 79 3 00 0 00 0
Weighted 44 50 0 573 137 31 1266 488 3 3287 459 57 913 3025 9
TABLE IV
ACCURACY EV ALUATION FOR REAL STRING CONSTRAINTS .
Prob.Δ Missed Exact (0%,10%] (10% ,30%] >30%
kbound 35 7 35 7 35 7 35 7 357
Local probability
Bounded 91 14 0 5531 3024 98 440 1113 2 00 0 2 180
Acyclic 11 0 0 5611 3038 98 440 1113 2 00 0 2 180
Global probability
Bounded 198 120 0 4201 2030 98 1673 2009 2 50 0 600
Acyclic 118 106 0 4281 2044 98 1673 2009 2 50 0 600
count for a given automaton and a bound k, or handling mixed
string-numerical constraints, our work investigates how well
automata-based models can preserve the relation between the
input variables and the solution count of an automaton, which
is an essential property of PSE’s path constraints.
Similar to Kausler et al. [28], where the authors measured
accuracy of string constraint solver in the context of SE,
our work evaluates accuracy for an automata-based string
constraint solver in the context of PSE. Since the authors
empirically demonstrated that a string constraint solver can
misidentify an unsatisﬁable branch outcome as satisﬁable in
SE, it was not surprising for us to ﬁnd that automata-based
models miscalculate branch probabilities in PSE.
Our work addresses a problem similar to the one discussed
by Borges et al. in [14], [15] for the domain of real numbers.
Instead of approximating non-linear functions that appear in
PSE’s path conditions, the authors employ numerical analysis
techniques to compute their volumes. By doing so, the authors
enforce a one-to-one relation between the input values and
the solution set of a path constraint for real numbers. Unlike
Borges et al. we focus on enforcing a one-to-one relation for
symbolic strings.
We also connect our evaluation approach with recent on
work on testing symbolic execution engines by Kapus et
al. [41]. In their work researchers compare the results of con-
cretely executed paths with data computed by SE for the same
paths. This approach reveals many defects in implementation
of symbolic engines. Similar to their work, we compare the
probability values computed by PSE with the probability val-
ues produces from the actual concrete runs. Instead of ﬁnding
implementation defects in PSE, we detected the limitations of
commonly used automata-based string models to maintain a
one-to-one relation between the input values and the solution
set of an automaton.
VI. C ONCLUSION AND FUTURE WORK
We showed that traditional automata models are unable
to preserve one-to-one relation with the inputs strings. The
Bounded automata solver can both over and under approximatethe count, while the Acyclic solver under-approximates and the
Weighted solver permits accurate solutions counting. While
our implementation of the Weighted automata scales much
better than the explicit string counting, it is still slow to
handle larger sizes of symbolic strings. Depending on the
type of constraint Bounded and Acyclic solvers can compute
incorrect probabilities, which are more prevalent in global
probabilities calculations for which global probabilities is also
more sensitive to.
While we showed that using regular automata-based models
can lead to incorrect orderings in paths exploration in local and
even more signiﬁcant in global orderings, the question remains
open whether those incorrect ordering have an impact on PSE
applications. Thus, in the future we plan to evaluate whether
improvements in accuracy enable PSE-based veriﬁcation tools
to detect defects in string manipulating programs more ef-
ﬁciently. In addition, we plan to compare the accuracy of
our implementation to the state-of-the-art string string solution
counting solvers ABC [34] and S3# [22]. To do so, we ﬁrst
would like to improve the efﬁciency our Weighted solver and
explore avenues of reducing the alphabet size either from
program requirements or/and from a light-weight program
analysis.
Since our experiments show a trade-off between accuracy
and efﬁciency of automata models, for the future work we
also plan to include the classiﬁcation of potential string
constraint into categories. For example, for some type of string
constraint the Bounded model would be more efﬁcient yet
produce accurate results. However, if there are possibilities that
a constraint contains concatenations of two symbolic string
values, then using Acyclic perhaps would be a better idea.
For more complex constraints, especially when arguments of
string method contain another symbolic values, using either
of traditional models would lead to incorrect probabilities
calculations.
VII. A CKNOWLEDGMENTS
This work supported by the US National Science Founda-
tion under award CCF-1449636.
450
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:04 UTC from IEEE Xplore.  Restrictions apply. REFERENCES
[1] J. C. King, “Symbolic execution and program testing,” Commun.
ACM , vol. 19, no. 7, pp. 385–394, Jul. 1976. [Online]. Available:
http://doi.acm.org/10.1145/360248.360252
[2] L. A. Clarke, “A system to generate test data and symbolically execute
programs,” IEEE Transactions on Software Engineering , vol. SE-2,
no. 3, pp. 215–222, Sept 1976.
[3] C. S. P ˇasˇareanu, P. C. Mehlitz, D. H. Bushnell, K. Gundy-
Burlet, M. Lowry, S. Person, and M. Pape, “Combining unit-
level symbolic execution and system-level concrete execution for
testing nasa software,” in Proceedings of the 2008 International
Symposium on Software Testing and Analysis , ser. ISSTA ’08.
New York, NY , USA: ACM, 2008, pp. 15–26. [Online]. Available:
http://doi.acm.org/10.1145/1390630.1390635
[4] L. Li, C. Cifuentes, and N. Keynes, “Practical and effective symbolic
analysis for buffer overﬂow detection,” in Proceedings of the Eighteenth
ACM SIGSOFT International Symposium on F oundations of Software
Engineering , ser. FSE ’10. New York, NY , USA: ACM, 2010, pp. 317–
326. [Online]. Available: http://doi.acm.org/10.1145/1882291.1882338
[5] N. Rungta, E. G. Mercer, and W. Visser, “Efﬁcient testing of concurrent
programs with abstraction-guided symbolic execution,” in Proceedings
of the 16th International SPIN Workshop on Model Checking Software .
Berlin, Heidelberg: Springer-Verlag, 2009, pp. 174–191. [Online].
Available: http://dx.doi.org/10.1007/978-3-642-02652-2 16
[6] C. Cadar, D. Dunbar, and D. Engler, “Klee: Unassisted and
automatic generation of high-coverage tests for complex systems
programs,” in Proceedings of the 8th USENIX Conference on Operating
Systems Design and Implementation , ser. OSDI’08. Berkeley, CA,
USA: USENIX Association, 2008, pp. 209–224. [Online]. Available:
http://dl.acm.org/citation.cfm?id=1855741.1855756
[7] P. Godefroid, N. Klarlund, and K. Sen, “Dart: Directed automated
random testing,” in Proceedings of the 2005 ACM SIGPLAN Conference
on Programming Language Design and Implementation , ser. PLDI ’05.
New York, NY , USA: ACM, 2005, pp. 213–223. [Online]. Available:
http://doi.acm.org/10.1145/1065010.1065036
[8] K. Sen, D. Marinov, and G. Agha, “Cute: A concolic unit testing engine
for c,” in Proceedings of the 10th European Software Engineering
Conference Held Jointly with 13th ACM SIGSOFT International
Symposium on F oundations of Software Engineering , ser. ESEC/FSE-
13. New York, NY , USA: ACM, 2005, pp. 263–272. [Online].
Available: http://doi.acm.org/10.1145/1081706.1081750
[9] C. Kruegel, E. Kirda, D. Mutz, W. Robertson, and G. Vigna,
“Automating mimicry attacks using static binary analysis,” in
Proceedings of the 14th Conference on USENIX Security
Symposium - V olume 14 , ser. SSYM’05. Berkeley, CA, USA:
USENIX Association, 2005, pp. 11–11. [Online]. Available:
http://dl.acm.org/citation.cfm?id=1251398.1251409
[10] P. Saxena, D. Akhawe, S. Hanna, F. Mao, S. McCamant, and D. Song,
“A symbolic execution framework for javascript,” in Proceedings of
the 2010 IEEE Symposium on Security and Privacy , ser. SP ’10.
Washington, DC, USA: IEEE Computer Society, 2010, pp. 513–528.
[Online]. Available: http://dx.doi.org/10.1109/SP.2010.38
[11] Y . Zheng and X. Zhang, “Path sensitive static analysis of web applica-
tions for remote code execution vulnerability detection,” in 2013 35th
International Conference on Software Engineering (ICSE) , May 2013,
pp. 652–661.
[12] J. Geldenhuys, M. B. Dwyer, and W. Visser, “Probabilistic symbolic
execution,” in Proceedings of the 2012 International Symposium
on Software Testing and Analysis , ser. ISSTA 2012. New
York, NY , USA: ACM, 2012, pp. 166–176. [Online]. Available:
http://doi.acm.org/10.1145/2338965.2336773
[13] A. Filieri, C. S. P ˘as˘areanu, and W. Visser, “Reliability analysis
in symbolic pathﬁnder,” in Proceedings of the 2013 International
Conference on Software Engineering , ser. ICSE ’13. Piscataway,
NJ, USA: IEEE Press, 2013, pp. 622–631. [Online]. Available:
http://dl.acm.org/citation.cfm?id=2486788.2486870
[14] M. Borges, A. Filieri, M. d’Amorim, C. S. P ˘as˘areanu, and W. Visser,
“Compositional solution space quantiﬁcation for probabilistic software
analysis,” in Proceedings of the 35th ACM SIGPLAN Conference on
Programming Language Design and Implementation , ser. PLDI ’14.
New York, NY , USA: ACM, 2014, pp. 123–132. [Online]. Available:
http://doi.acm.org/10.1145/2594291.2594329[15] M. Borges, A. Filieri, M. d’Amorim, and C. S. P ˘as˘areanu,
“Iterative distribution-aware sampling for probabilistic symbolic
execution,” in Proceedings of the 2015 10th Joint Meeting on
F oundations of Software Engineering , ser. ESEC/FSE 2015. New
York, NY , USA: ACM, 2015, pp. 866–877. [Online]. Available:
http://doi.acm.org/10.1145/2786805.2786832
[16] F. Yu, T. Bultan, M. Cova, and O. H. Ibarra, “Symbolic string veri-
ﬁcation: An automata-based approach,” in Model Checking Software ,
K. Havelund, R. Majumdar, and J. Palsberg, Eds. Berlin, Heidelberg:
Springer Berlin Heidelberg, 2008, pp. 306–324.
[17] F. Yu, M. Alkhalaf, T. Bultan, and O. H. Ibarra, “Automata-based
symbolic string analysis for vulnerability detection,” F orm. Methods
Syst. Des. , vol. 44, no. 1, pp. 44–70, Feb. 2014. [Online]. Available:
http://dx.doi.org/10.1007/s10703-013-0189-1
[18] P. Hooimeijer, B. Livshits, D. Molnar, P. Saxena, and M. Veanes,
“Fast and precise sanitizer analysis with bek,” in Proceedings of
the 20th USENIX Conference on Security , ser. SEC’11. Berkeley,
CA, USA: USENIX Association, 2011, pp. 1–1. [Online]. Available:
http://dl.acm.org/citation.cfm?id=2028067.2028068
[19] A. S. Christensen, A. Møller, and M. I. Schwartzbach, “Precise
analysis of string expressions,” in Proceedings of the 10th
International Conference on Static Analysis , ser. SAS’03. Berlin,
Heidelber g: Springer-Verlag, 2003, pp. 1–18. [Online]. Available:
http://dl.acm.org/citation.cfm?id=1760267.1760269
[20] F. Yu, M. Alkhalaf, and T. Bultan, “Stranger: An automata-based string
analysis tool for php,” in Tools and Algorithms for the Construction and
Analysis of Systems . Springer, 2010, pp. 154–157.
[21] Y . Zheng, X. Zhang, and V . Ganesh, “Z3-str: a z3-based string solver for
web application analysis,” in Proceedings of the 2013 9th Joint Meeting
on F oundations of Software Engineering . ACM, 2013, pp.
114–124.
[22] M.-T. Trinh, D.-H. Chu, and J. Jaffar, “S3: A symbolic string solver for
vulnerability detection in web applications,” in Proceedings of the 2014
ACM SIGSAC Conference on Computer and Communications Security ,
ser. CCS ’14. New York, NY , USA: ACM, 2014, pp. 1232–1243.
[Online]. Available: http://doi.acm.org/10.1145/2660267.2660372
[23] ——, “Progressive reasoning over recursively-deﬁned strings,” in Com-
puter Aided V eriﬁcation , S. Chaudhuri and A. Farzan, Eds. Cham:
Springer International Publishing, 2016, pp. 218–240.
[24] N. Bjørner, N. Tillmann, and A. V oronkov, “Path feasibility analysis
for string-manipulating programs,” in Proceedings of the 15th
International Conference on Tools and Algorithms for the Construction
and Analysis of Systems,ETAPS 2009, , ser. TACAS ’09. Berlin,
Heidelberg: Springer-Verlag, 2009, pp. 307–321. [Online]. Available:
http://dx.doi.org/10.1007/978-3-642-00768-2 27
[25] A. Kiezun, V . Ganesh, S. Artzi, P. J. Guo, P. Hooimeijer, and
M. D. Ernst, “Hampi: A solver for word equations over strings,
regular expressions, and context-free grammars,” ACM Trans. Softw.
Eng. Methodol. , vol. 21, no. 4, pp. 25:1–25:28, Feb. 2013. [Online].
Available: http://doi.acm.org/10.1145/2377656.2377662
[26] F. B ¨uttner and J. Cabot, “Lightweight string reasoning in model ﬁnding,”
Software & Systems Modeling , pp. 1–15, 2013.
[27] A. Aydin, L. Bang, and T. Bultan, “Automata-based model counting
for string constraints,” in International Conference on Computer Aided
V eriﬁcation . Springer, 2015, pp. 255–272.
[28] S. Kausler and E. Sherman, “Evaluation of string constraint solvers in the
context of symbolic execution,” in Proceedings of the 29th ACM/IEEE
International Conference on Automated Software Engineering , ser.
ASE ’14. New York, NY , USA: ACM, 2014, pp. 259–270. [Online].
Available: http://doi.acm.org/10.1145/2642937.2643003
[29] L. Luu, S. Shinde, P. Saxena, and B. Demsky, “A model
counter for constraints over unbounded strings,” in Proceedings
of the 35th ACM SIGPLAN Conference on Programming
Language Design and Implementation , ser. PLDI ’14. New
York, NY , USA: ACM, 2014, pp. 565–576. [Online]. Available:
http://doi.acm.org/10.1145/2594291.2594331
[30] T. Brennan, N. Tsiskaridze, N. Rosner, A. Aydin, and T. Bultan,
“Constraint normalization and parameterized caching for quantitative
program analysis,” in Proceedings of the 2017 11th Joint Meeting
on F oundations of Software Engineering , ser. ESEC/FSE 2017. New
York, NY , USA: ACM, 2017, pp. 535–546. [Online]. Available:
http://doi.acm.org/10.1145/3106237.3106303
[31] M. Backes, B. Kopf, and A. Rybalchenko, “Automatic discovery and
quantiﬁcation of information leaks,” in Proceedings of the 2009 30th
451
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:04 UTC from IEEE Xplore.  Restrictions apply. IEEE Symposium on Security and Privacy , ser. SP ’09. Washington,
DC, USA: IEEE Computer Society, 2009, pp. 141–153. [Online].
Available: http://dx.doi.org/10.1109/SP.2009.18
[32] Q.-S. Phan, P. Malacaria, O. Tkachuk, and C. S. P ˘as˘areanu,
“Symbolic quantitative information ﬂow,” SIGSOFT Softw. Eng.
Notes , vol. 37, no. 6, pp. 1–5, Nov. 2012. [Online]. Available:
http://doi.acm.org/10.1145/2382756.2382791
[33] C. G. Val, M. A. Enescu, S. Bayless, W. Aiello, and A. J. Hu, “Precisely
measuring quantitative information ﬂow: 10k lines of code and beyond,”
in2016 IEEE European Symposium on Security and Privacy (EuroS P) ,
March 2016, pp. 31–46.
[34] A. Aydin, W. Eiers, L. Bang, T. Brennan, M. Gavrilov, T. Bultan,
and F. Yu, “Parameterized model counting for string and numeric
constraints,” in Proceedings of the 2018 26th ACM Joint Meeting on
European Software Engineering Conference and Symposium on the
F oundations of Software Engineering , ser. ESEC/FSE 2018. New
York, NY , USA: ACM, 2018, pp. 400–410. [Online]. Available:
http://doi.acm.org/10.1145/3236024.3236064
[35] M. Mohri, “Finite-state transducers in language and speech processing,”
Comput. Linguist. , vol. 23, no. 2, pp. 269–311, Jun. 1997. [Online].
Available: http://dl.acm.org/citation.cfm?id=972695.972698
[36] M. Droste and D. Kuske, “Weighted automata,” 2013.
[37] M. Mohri, Weighted Automata Algorithms . Berlin, Heidelberg: Springer
Berlin Heidelberg, 2009, pp. 213–254.
[38] A. Demaille, A. Duret-Lutz, S. Lombardy, and J. Sakarovitch, “Imple-
mentation concepts in vaucanson 2,” vol. 7982, 07 2013, pp. 122–133.
[39] M. Weir, S. Aggarwal, M. Collins, and H. Stern, “Testing
metrics for password creation policies by attacking large sets of
revealed passwords,” in Proceedings of the 17th ACM Conference
on Computer and Communications Security , ser. CCS ’10. New
York, NY , USA: ACM, 2010, pp. 162–175. [Online]. Available:
http://doi.acm.org/10.1145/1866307.1866327
[40] X. Yang, Y . Chen, E. Eide, and J. Regehr, “Finding and understanding
bugs in c compilers,” in Proceedings of the 32Nd ACM SIGPLAN
Conference on Programming Language Design and Implementation ,
ser. PLDI ’11. New York, NY , USA: ACM, 2011, pp. 283–294.
[Online]. Available: http://doi.acm.org/10.1145/1993498.1993532
[41] T. Kapus and C. Cadar, “Automatic testing of symbolic execution
engines via program generation and differential testing,” in
Proceedings of the 32Nd IEEE/ACM International Conference on
Automated Software Engineering , ser. ASE 2017. Piscataway,
NJ, USA: IEEE Press, 2017, pp. 590–600. [Online]. Available:
http://dl.acm.org/citation.cfm?id=3155562.3155636
[42] The LRDE research laboratory, “Vcsn,”
https://www.lrde.epita.fr/wiki/Vcsn, 2019, online; accessed 10 May
2019.
[43] M.-T. Trinh, D.-H. Chu, and J. Jaffar, “Model counting for recursively-
deﬁned strings,” in Computer Aided V eriﬁcation , R. Majumdar and
V. Ku n ˇcak, Eds. Cham: Springer International Publishing, 2017, pp.
399–418.
452
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:04 UTC from IEEE Xplore.  Restrictions apply. 