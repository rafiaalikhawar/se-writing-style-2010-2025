See discussions, st ats, and author pr ofiles f or this public ation at : https://www .researchgate.ne t/public ation/307909586
RECONTEST: Effective Regression Testing of Concu rrent Programs
Conf erence Paper  · August 2015
DOI: 10.1109/IC SE.2015.45
CITATIONS
29READS
258
3 author s, including:
Valerio T erragni
Univ ersity of A uckland
67 PUBLICA TIONS    886 CITATIONS    
SEE PROFILE
Shing-Chi Cheung
Hong K ong Univ ersity of Scienc e and T echnolog y
376 PUBLICA TIONS    9,806  CITATIONS    
SEE PROFILE
All c ontent f ollo wing this p age was uplo aded b y Valerio T erragni  on 08 Sept ember 2016.
The user has r equest ed enhanc ement of the do wnlo aded file.RECONTEST: Effective Regression Testingof Concurrent ProgramsValerio Terragni, Shing-Chi Cheung, Charles ZhangDepartment of Computer Science and EngineeringThe Hong Kong University of Science and Technology{vterragni, scc, charlesz}@cse.ust.hkAbstract—Concurrent programs proliferate as multi-core tech-nologies advance. The regression testing of concurrent programsoften requires running a failing test for weeks before catching afaulty interleaving, due to the myriad of possible interleavings ofmemory accesses arising from concurrent program executions. Asa result, the conventional approach that selects a sub-set of testcases for regression testing without considering interleavings isinsufﬁcient. In this paper we present RECONTESTto address theproblem by selecting the new interleavings that arise due to codechanges. These interleavings must be explored in order to uncoverregression bugs. RECONTESTefﬁciently selects new interleavingsby ﬁrst identifying shared memory accesses that are affectedby the changes, and then exploring only those problematicinterleavings that contain at least one of these accesses. We haveimplemented RECONTESTas an automated tool and evaluatedit using 13 real-world concurrent program subjects. Our resultsshow that RECONTESTcan signiﬁcantly reduce the regressiontesting cost without missing any faulty interleavings induced bycode changes.I. INTRODUCTIONRegression testing is known to be expensive when thesize of test suites grows over time as software evolves [14],[33]. For instance, under the incremental maintain-and-testprocesses (e.g.,nightly-build-and-test), the time required toexecute all test cases can easily exceed the affordable timebudget [8]. The deﬁciency of regression testing is exacerbatedwhen testing multi-threaded programs due to the much longerexecution time required to cover a reasonable amount of threadinterleavings(i.e., temporal order of a set of shared memoryaccesses). The most widely-adopted testing methodology forconcurrent programs isstress-testingthat requires runningthe same multi-threaded test many times to explore differentinterleavings. Thus, the cost of running a single multi-threadedtest is equivalent to thousands of sequential tests.To reduce the cost of regression testing, researchers haveproposed to select [14], [34], prioritize [10] or minimize [16]those sequential tests that might fail after program revisions.However, it is inadequate for concurrent programs to onlycover the changes of the sequential logic and forego theirramiﬁcations in the interleaving space. As such, a single multi-threaded test case alone can require weeks of testing beforemanifesting faulty interleavings [31].Like existing regression testing techniques for sequentialsoftware [47], a common approach to reducing regressiontesting cost is to avoid re-testing the unmodiﬁed portion ofthe program by assuming that all existing tests of the origi-nal program run correctly (P-Correct-for-T assumption[33]).Adapting to concurrent programs this assumption becomesthat all the interleavings manifested by any existing test suiteTof the original programPare assumed to bebenign.Suppose a test,t, is considered for regression testing afterrevising a concurrent programPtoP′. This paper studieshow to select thenew interleavingsthat can only be observedwhentruns withP′(denoted byP′(t)). Exploring only newinterleavings reduces the cost of regression testing becausemost interleavings remain unchanged after program revision.Achieving this goal requires to address the fundamentalchallenge of identifying the new interleavings without explor-ing the unchanged ones. Naively computing thedifference setof the interleaving spaces ofP′(t)andP(t)is apparently notfeasible due to it requires constructing the entire interleavingspace ofP′(t), which is exactly the cost we want to eliminate.Although there has been some effort in reducing theregressionveriﬁcationcosts for concurrent programs by reapplyingmodelcheckingtechniques (e.g., [30], [15]) as software evolves [46],[19]. To the best of our knowledge, there are few prior studieson how new interleavings can be effectively selected forregression testingconcurrent programs.In this paper, we presentREgression CONcurrency TESTing(RECONTEST), a regression testing framework for concur-rency bugs. The framework is inspired by two observations,which enable us to effectively exploreonlynew interleavings.Observation 1: New interleavings must contain at least oneshared memory access impacted by the revision. The impactcan happens in two ways. First, the access is observable inP′(t)but not inP(t)because is triggered by the added/mod-iﬁed statements or by a new execution path. An example isthe access generated at line 5 in Figure 1. Second, it is anaccess unaffected by the program modiﬁcations but there arechanges to itsConcurrency Context(CC), characterized by itslock acquire/release historiesand itshappens-before relationswith respect to other threads [23], e.g., line 8 in Figure 1.Intuitively, all accesses ofP′(t)with an affected CC couldinterleave in new ways with other accesses.Observation 2: A very small number of accesses are trulyaffected by program revisions. For a testt, a revision of aprogramPdoes not affect the CCs of most of the accessesappearing in the execution oft, nor does it generate manynew accesses. In our experiments with 13 real-world subjects,
2015 IEEE/ACM 37th IEEE International Conference on Software Engineering
978-1-4799-1934-5/15 $31.00 © 2015 IEEE
DOI 10.1109/ICSE.2015.45246
2015 IEEE/ACM 37th IEEE International Conference on Software Engineering
978-1-4799-1934-5/15 $31.00 © 2015 IEEE
DOI 10.1109/ICSE.2015.45246
2015 IEEE/ACM 37th IEEE International Conference on Software Engineering
978-1-4799-1934-5/15 $31.00 © 2015 IEEE
DOI 10.1109/ICSE.2015.45246
2015 IEEE/ACM 37th IEEE International Conference on Software Engineering
978-1-4799-1934-5/15 $31.00 © 2015 IEEE
DOI 10.1109/ICSE.2015.45246
we only found on average 1% of impacted accesses. As aresult, many accesses repeat and interleave with each other inthe same way atP(t)andP′(t), the interleavings involvingthese accesses can be safely skipped in the regression testingofP′(t)under the adaptedP-Correct-for-Tassumption.Leveraging these two observations, RECONTESTexploresnew interleavings in two phases: Phase I computes the impact-set of accesses introduced by program revisions, and PhaseII explores only those interleavings that contain at least oneimpacted access.The key idea ofRECONTESTis to use theimpact-set to infer new interleavings. As a result, new inter-leavings can be selected without ﬁrst exploring the entire inter-leaving space ofP′(t). Since the number of new interleavingscould be enormous, we guide the interleaving exploration bya concurrency coverage criterion. The criterion considered inour experiments is the set ofproblematic interleavingsthatmatch the access patterns violatingatomic-set serializability[43], which subsumes race conditions as well as single andmultiple variable atomicity violations [43], [40].These two phases addresses two research questions. 1) Isthere an efﬁcient mechanism to identify thetrulyimpactedaccesses? Note that existingchange-impact analysisspeciﬁcto the concurrency semantics [49], [19] cannot guarantee tocompute a sound or a complete impact-set. 2) Given an impact-set, is there a way to exploreonlythe problematic interleavingsinvolving the impacted accesses?RECONTESTaddresses the ﬁrst question using a change-impact analysis algorithm in Phase I to compute the impact-set based on theexecution tracesofP(t)andP′(t), collectedby aPredictive Trace Analysis(PTA) [37] technique. Thealgorithm considers a memory access to be impacted if itis observed only in the execution trace ofP′(t), or its CCobtained from the collected execution traces is altered afterprogram revision. The algorithm smartly handles two technicalchallenges: matching an event inP′(t)to its equivalence inP(t), and semantically comparing both the CCs of the pairof matched events inP′(t)andP(t). Phase II addressesthe second question by adapting theoff-lineinterleaving ex-ploration of PTA to searching problematic interleavings onlyamong those containing at least one impacted access. Theproblematic interleavings validated as feasible are outputtedby RECONTESTas warnings ofregression concurrency bugs.We implement RECONTESTas a fully automated prototypetool and evaluated it using 13 real-world Java concurrencybugs. The experiments show that our approach successfullydetected all these bugs with four orders of magnitude reductionover stress-testing and PTA. RECONTESTachieves reductionbecause the manifestation of most concurrency bugs are causedby problematic interleavings arising from a small set ofaccesses (at most four [28], [43]). There is a low probabilitythat these small set of accesses contain one of the few impactedones. It is conﬁrmed by our experiments that many (99%)problematic interleavings do not contain impacted accesses.RECONTESTselects under two generally valid assumptionsthe interleavings of all regression concurrency bugs exhibitedbyP′(t). We highlight our contributions as follows:●We present a dynamicChange-Impact Analysis(CIA)with a run time complexity linear to the length ofexecution traces (Section III).●We propose heap abstractions for comparing CC acrossthe two program executions before and after revision(Section III-B).●We present the ﬁrst algorithm to select problematic in-terleavings for the regression testing of concurrency bugswithout constructing interleaving spaces (Section IV).●We implemented a prototype tool of our approach andevaluated it on 13 real-world Java subjects (Section V).II. PRELIMINARIES:CONCURRENCYCONTEXT(CC)RECONTESTleverages the execution trace collected by PTAto compute the impact-set and to explore new interleavings.In the following, we introduce PTA, its execution trace model,CC deﬁnition and how it is encoded by RECONTEST.Predictive Trace Analysis (PTA)is a popular testingtechnique for concurrent programs (e.g., [37], [22], [17], [39]).PTA detects problematic interleavings in three steps: moni-toring, prediction and validation. In themonitoring step, PTAobserves an arbitrary concurrent program execution generatingan execution trace of memory accesses, locking, messagingand object creation operations. During the trace collectionPTA computes the CC of each memory access by leveragingthe concurrency operations collected. This is because PTAneeds CC information during the validation step for pruninginfeasible interleavings. In theprediction step, PTA analysesthe trace to explore problematic interleavings that could bemanifested in alternative executions by re-shufﬂing the orderof occurrences of the memory accesses to match problematicaccess patterns (e.g., [43]). Since the interleaving explorationis performedoff-line, many problematic interleavings so iden-tiﬁed can be infeasible. In thevalidation step, PTA, therefore,validates these interleavings with astatic lockset/happens-before checkerbased on the CC computed. Most PTAs alsore-execute the program to exercise the retained interleavings.An execution traceE=<ei>captures a multi-threadedprogram execution as a sequence of events. Let the events beuniquely labelled by indices in an ascending order accordingto their order of occurrences. A program changes its states viastatement execution and generates one of the following events.●MEM(th,loc,a):threadthaccesses a shared memory lo-cationloc,a∈{Write,Read}is the access type●ACQ(th,l):threadthacquires a lockl●REL(th,l):threadthreleases a lockl●SND(th,m):threadthsends a unique messagem●RCV(th,m):threadthreceives a unique messagem●OBJALLOC(th,o):threadthcreates an objectoIn our presentation, we useth(x)to denote the thread thatexecuted eventex, ands(x)to denote the statement thatgeneratedex.EMdenotes the ordered subsequence ofEcontaining only MEM events. The set of objects created byOBJALLOC events is denoted asO. A unique ID (denotedasid(o)) is generated each time when an objecto∈Oiscreated. An ACQ event is generated when a synchronized
247
247
247
247block or method is entered, and a REL event is generatedwhen exiting the block or method. In Java, the SND/RCVevents are generated at the call of:join(), start(), wait(),notify()andnotifyAll(). For example, ifo1.notify()on threadth1signalso1.wait()on threadth2, then eventsSND(th1,m)andRCV(th2,m)are generated wheremis a unique message.Deﬁnition 1.Givenex∈EM,t h eConcurrency Context (CC)ofex, denoted byCCx, speciﬁes how other events inEMcan interleave withe. It is deﬁned by 1) lockset ofex, 2) thehappens-before relations betweenexand other events inEM,and 3) the lock release history ofth(x)prior toex. Formally,CCxis deﬁned as a tuple<LSx,HBx,LRx>.LSxis the LockSet ofexthat contains the locks heldbyth(x)while executingex[35].LSx={l∈O∣∃ej=ACQ(th(j),l)∈E,/∃ek=REL(th(k),l)∈E,j<k<x, th(x)=th(j)=th(k)}.HBxdenotes the Happens-Before relations≺ofex.TheSND/RCV events together with the total order of events ofthe same thread deﬁnes≺[23] that is the smallest relationsatisfying the following conditions [36].●Ifeiandejare events from the same thread andeicomesbeforeejin the trace, thenei≺ej.●Ifeiis the sending (SND) andejis the receiving (RCV)of the messagem, respectively,ei≺ej.●≺is transitively closed.LRxdenotes the Lock Release history ofexcontainingthe REL events executed byth(x)prior the execution ofex.LRx={ek=REL(th(k),l)∈E∣k<x, th(x)=th(k)}.CC encoding.We adopt the following encoding in orderto compare CCs across executions. The inter-thread≺relationis often computed using avector clock[29] whose values arenot comparable across executions. Thus,HBxis encoded asthe ordered sequence of SND/RCV events generated byth(x)from its creation at the time when the eventexis generatedin the trace [18]. SND/RCV events are presented as a couple(o,type)whereo∈Ois themessage objectandtype∈{notify,notifyAll, wait, start, join}(e.g.,o1.notify()is encoded by (o1,notify())). A lock inLSxis encoded as ao∈Ofor lockobjects or a static reference for static locks (e.g.,A.class). ForencodingLRxwe leverage that events triggered by the samethread are totally ordered. Each lock inLSxis tagged by aboolean value whose value istrueif it exists a REL eventbetweenexand the previous MEM event performedth(x),andfalseotherwise.LRxis obtained by combining theLRxofall events generated byth(x)priorex. Section III-B presentsthe heap abstractions for comparing object’s semantics.III. PHASEI: CHANGE-IMPACTANALYSIS(CIA)A key regression testing’s step is to determine the effectsof source code modiﬁcations using softwareChange-ImpactAnalysis(CIA) [25]. Since there are few studies on the regres-sion testing of concurrent programs, most CIAs are obliviousto the concurrency semantics [25]. The only exceptions arepresented in CAPP [19] and SimRT [49], they analyze thesource code reporting statements that arepotentially impactedby code changes. They are inadequate for two reasons.1) Limitations of static CIAs.The impact sets derived bystatic CIAs are not sufﬁciently precise for regression testing [1]due to the inclusion of many infeasible behaviors arising frominaccurate pointer aliasing analysis [1], [25]. It was reportedthat 90% of the events in the impact sets derived by staticCIAs can be spurious [1].2) Limitations of dependency-based CIAs [4].Existingtechniques [19], [49] ﬁrst identify the changes that affectthe CCs of program entities (e.g., statements), denoted byCC-change, and then identify the entities affected by thosechanges. This approach is not practical because it requiresto enumerate a priori all possible CC-changes that could bemanifested in a program. As a result, existing techniques[19], [49] cannot guarantee to detect all affected entitiesbecause they have not considered the changes of happens-before relations (e.g., line 12 Figure 1) and the changes thatindirectly affect lock operations (e.g., line 18 Figure 1).RECONTEST’s CIAis a dynamic CIA at memory accesslevel and it does not require to identify CC-changes. Initially,it treats each change as a CC-change by assuming all accessesinP′(t)are potentially impacted. Thus, it does not miss anychanges that affect synchronization operations or happens-before relations. Then, it checks if the CC of each access inP′(t)istrulyaffected by comparing it with the CC occurredwhen executing the original version of the program. The checktakes three pieces of input information.●Achange-setthat contains the set of new statementsintroduced in the process of revisingPtoP′. Let∼denote anequivalencerelation deﬁned onP′×Psuchthats′∼sifs′denotes the statementsthat has notbeen modiﬁed in the process of revisingPtoP′.W eassume that∼relates each statement inP′to at most onestatement inP. Given a∼relation, change-set is deﬁnedas{s′∈P′∣/ ∃s∈P,s′∼s}⊆P′.●A regression test suiteTof re-testable multi-threadedtests. In subsequent discussion,tdenotes a test case inTandP(t)denotes the execution ofton programP.●For each testt∈T, a pair of execution tracesEandE′exhibited byP(t)and byP′(t), respectively.The output of Phase I is an impact-set containing MEMevents ofE′that could constitute new interleavings. Considerthe binary and symmetricexecution correspondencerelation[44] (denoted by≡) onE′M×EM, for aligning execution pointsacross executions. Without loss of generality, we assume thatif a statementsis executed in bothEMandE′M,∃e′y∈E′Mand∃ex∈EMsuch thate′y≡exands(y)=s(x)=s.Deﬁnition 2.GivenE′MandEM, theimpact-setcontainsevents inE′Mthat satisfy either of the following conditions:●a new event that is observable inE′Mbut not inEM;●an old event with a CC altered by code changes;More formally, impact-set={In∪Ic}⊆E′M, where:●In={e′y∈E′M∣s′(y)∈change-set∨/ ∃ex∈EM,e′y≡ex}●Ic={e′y∈E′M∣∃ex∈EM,e′y≡ex,CCx≠CCy}
248
248
248
248obj.m1();obj.m2();…..--++++--++++++++++--++++--++public class A{intx = 0, y = 0, z= 0; Object lock;public void m0(intval1,intval2){  y= val1; x = val2;z= val1*val2;}public void m1(){public synchronized void m1 (){x= get (..);synchronized (this) {m0(5,5); }}12345678910public synchronized void m2(){booleancond= true;booleancond= false;if(cond)o.notify();x++; }public intm3(Object lock){this.lock= new Object();  this.lock= lock;synchronized(this.lock) {if(x>5)returnx; return0;}}1112131415161718192021222324252627282930313233e′1e′2e′3e′4    e′5e′6    e′7 e′8e′9e′10E = P(t)W(x)W(y)W(x)W(z)W(x)W(x)R(x)R(x)W(x)W(y)W(x)W(y)W(x)W(x)W(x)R(x)W(x)W(y)Lock Release RLfalse     ≠truefalse     =     falseLockset LS{this}     =    {this}{this}     ≠{this}     =    {this}Happens Before HB≠{.notify}≠{.notify}Lockset LS{lock}     ≠{lock}line line
?83416162128308341616212831225++9999999IcInConcurrency Context (CC)e1e2e3e4    e5e6    e7 e8{ }   {}   { }   A obj= newA();Thread1Thread2…..…..…..obj.m3(new  B());obj.m4();…..test case tE′= P′(t)Outputpublic voidm4(){public synchronized voidm4(){synchronized(this) {x= 0;}synchronized(this) { y=0; } } Fig. 1. Phase I of RECONTEST. GivenPandP′,achange-set={5,6,9,12,18,25,27,29,30,32}and a testt, the output is the impact-set={In∪Ic}A. Running ExampleWe illustrate our approach with a running example. Figure 1shows a Java class. Inserted lines are denoted as“++”, whiledeleted lines as“−−”. Modiﬁed lines are characterized byinserted lines followed by deleted lines. Figure 1 also showsthe execution traces obtained from executing the test caset.“W(x)”denotes the memory access event of typeWriteonvariable x. Similarly,“R(x)”for typeRead. The changes haveintroduced a regression bug inP′(t), an atomicity violationis triggered if the interleaving<e′9,e′2,e′3,e′10>is manifested.ComputingInis relatively simple.Inrepresents two kindsof impacted MEM events. The ﬁrst kind are events thatcorrespond to a new operation because they are triggered bya new statement. For example,e′4, which is triggered by thechanged statement at line 5, belongs toIn. The second kind areevents executed only inP′. For instance,e′8(an execution ofline 22) is new because there is no event inEcorresponding tothe execution of line 22. After code changes, the test evaluatesthe branch condition at line 21 to a different result, and hencetraverses a different path executing line 22. Note that differentfrom standard CIA techniques [25], the impact-set excludesMEM events that access different data values. The triggeringof concurrency bugs depends on the exposure of erroneousinter-thread memory dependencies, which are irrelevant to thedata values of the shared memories involved [43], [48].The challenge here is how to computeIc, the set of MEMevents with an affected CC. To achieve that, we need to alignexecution points in two tracesEandE′.RECONTESTestab-lishes thate1≡e′1because the statement at line 8 is executedonly once inE. Thus,e′1is aligned toe1.RECONTESTinfersthate′1∈Icbecause its lockset is empty while the lockset ofe1is not. The eventse′2ande′3are not impacted because theirlocksets remain unaltered. Evente′5is impacted because theSND event (o.notify()in line 15) occurs only inP′(t). Hence,e′5has a different happens-before relation with other events inthe two tracesEandE′. Similarly,e′6is also impacted.The maintenance of lock release history is important. Anevent with an unchanged lockset and happens-before relationcan induce new interleavings if it has an affectedLR. Forexample,e′10is impacted (even if its lockset is the same ase8) due to there is a new release lock event generated at line29. After the lock has been released at line 29 inP′, eventsof other threads could acquire the lock and interleave betweene′9ande′10. Such event interleaving is not possible inP.Different from dependency-based CIAs, RECONTESTdoesnot rely on the dependency between changes and other pro-gram entities for computing the impact-set, it uses the change-set only for identifying new events (see Def. 2). For thisreason, deleted statements can be safely excluded from thechange-set. If deleting (or adding) statements affects subse-quent memory accesses (e.g., deleting line 7 affects the locksetofe′1), it will be captured by our CIA that scans all MEMevents inE′identifying those new or with an altered CC.Existing dependency-based CIA techniques [19], [49] spe-ciﬁc to concurrency semantic are inadequate. First, they con-sider only explicit changes of synchronization blocks as CC-changes. As a result, they miss the impacted evente′7becausethe change contains no “synchronized” keyword. Second,they misse′5ande′6due to ignoring changes that affectswait()/notify(). Third, they incorrectly includee′2,e′3ande′9inthe impact-set as they consider all statements inside a modiﬁedsynchronized block are impacted.B. Comparing CCs across ExecutionsWe have shown the simple case of CC comparison wherePhase I identiﬁes that two CCs are different when the havedifferent cardinality. For example,e′1has an affected CCbecauseLS′1is empty whileLS1contains one lock. In the casewhere both locksets to be compared have the same cardinalitysuch as the situation of evente′7ande6,RECONTESTrequiresheap abstractions to compare CC’s lock and message objectsacross executions. Aheap abstractionis a functionabsthatmap aconcrete objecto∈Oto anabstract object[26]. Theheap abstraction problem is challenging even for executionsgenerated by the same program version [21], [5]. Dynamicreferences of objects do not provide a useful abstractionbecause the memory addresses (or unique IDs) of objects haveno relation across executions. Static references are not usefuleither. Yet, existing solutions (e.g., [21], [5]) are inadequatebecause they rely on program’s structural properties, whichmay not preserve across revisions. To address this challenge,we propose twochange-resilient heap abstractions.
249
249
249
249Object identity abstraction. This abstraction is motivatedby the following observation. A common practice in object-oriented programming is to use theobject instanceas theintrinsic lockof synchronized methods or blocks. In Java,it is also common to usethisas the message object ofwait()/notify(). In these cases the object accessed by a MEMeventexis exactly the same object that characterizesCCx,which needs to be abstracted. The equivalence between theobject accessed byexand that inCCxprovides a useful meansof heap abstraction. For example, consider the eventse′2ande2in Figure 1.e′2does not belong to the impact-set. The locksetofe′2is the same as that ofe2. Both contain a lock appliedto the current object accessed bye′2ande2. Note that we areable to take advantage of this property for heap abstractionbecause RECONTESTonly requires to match the CCs of MEMevents generated by unaltered statements and that access thesame type of object. More formally, we deﬁne theobjectidentity abstractionas follows: Givenex∈EM,e′y∈E′Mwithsx∼sythat access two objects of the same typeoxandoy, respectively. Giveno1∈CCxando2∈CCy. Ifid(ox)=id(o1)andid(oy)=id(o2)thenabs(o1)=abs(o2).When this abstraction is not applicable because the lock ormessage objects to be abstracted are not the object instances(e.g., for the CC ofe′7), we propose a variant of k-CFA [38].Change resilient k-CFA (CS k-CFA).The k-CFA of anobjecto, denoted by k-CFA(o), is the sequence of statements<s>containing the allocation site ofoand the chain of thekmost recent call sites on the stack of the thread creatingo[38].We formulate CS k-CFA as follows. Givenex∈EM,e′y∈E′Mando1ando2∈Osuch thato1∈CCxando2∈CCyif thei-thelement of k-CFA(o1)is in∼relation with thei-thelement ofk-CFA(o2)thenabs(o1)=abs(o2). The formulation enablesus to compare the locksets ofe′7ande6. The two locks inLS′7andLS6have a distinct CS k-CFA abstraction: they areallocated in diverse locations. As a result,e′7is impacted.C. Aligning Execution PointsIn Figure 1, each statement is executed only once. Thus,we can trivially compute the≡relation as follows.e′y≡exifs(y)∼s(x)and they access the same type of object. However,in practice the same statement could be executed many timesduring the same execution. As a result, an evente′y∈E′couldhave more than one corresponding event inEtriggered bythe equivalent statement ofs(y). Although, we can preciselycompute the equivalence relation∼by aligning unmodiﬁedsource code lines, computing the execution correspondencerelation≡is a machine undecidable problem [44], [41].Our key observation:The derivation of impact-set does notrequire precise computation of the≡relation. The objectiveof Phase I is to identify those events inE′Mwhose CC differsfrom that of their potentially matching counterparts inEM.Note that there is no need to ﬁnd exactly which two pairsof matching events inE′MandEMhave different CCs. Thisobservation enables impact-set to be computed efﬁciently andwithout suffering from an imprecise≡relation. RECONTESTperforms the computation in two consecutive steps. Figure 2Step 2CC(s1)eAeBeCeDeE..e′Fe′Ge′He′Ie′L..A = F B = G CD = HLEICC(s2)s1~sʹ1s2~sʹ2? ~sʹ3s1A s1B s2C s2D s2E sʹ1F sʹ1G sʹ2H sʹ3Isʹ2L stmtCCstmtCCEe′Le′Iimpact-setEʹSTEP 1STEP 2Step 1Fig. 2. The evente′Lis impacted because has a new CC that is different fromall the CCs of the events in E generated by the equivalent statement ofs(L).The evente′Iis impacted because it is generated by a changed statement.shows an illustrative example. Step 1 scansEMto clusterall the CCs of MEM events generated by the same statement.For example,CC(s1)={A, B}contains all the unique CCs ofevents inEMtriggered bys1. Step 2 scansE′Mfor computingthe impact-set. It infers thate′F,e′Gande′Hare not impactedbecause their CCs are the same as those of their potentiallymatches inEM.e′Lis impacted because it has a new CC. Wecan use the clusters computed in Step 1 also for identifyingnew events.e′Iis impacted sinceCC(s(I))does not exist,thuss(I)∈change-set. Figure 3 shows the CIA algorithm.Step1: TraversingEM.For each statementsthat triggers atleast one event inEM, we deﬁne the setCC(s)that containsall the unique CCs of the events associated with statements.Formally,CC(s)={CCx∣ex∈E,s(x)=s,whereCCxistheCCofex}. For each MEM eventeyinEM,CCyis addedtoCC(s(y))(Lines 1 to 2).Step 2: TraversingE′M.The algorithm scans all MEMeventse′xinE′M(Line 3 to 10) and it retrievess∗theequivalent statement ofs(x)that access the shared variablesof the same type of object. Ifs∗isnull,e′xis a new event (Line6), otherwise the Algorithm checks ifCC(s∗)is empty or not.IfCC(s∗)is emptye′xis a new event (In) because no MEMevents inEMhave been generated bys. Otherwise, Line 9checks ifCCxis not inCC(s∗). If this is the case,e′xhas aCC that has not been witnessed in any event inEgeneratedbys∗. Thus,e′xis added toIc. We also update theCC(s∗)Algorithm 1:Change Impact Analysis (CIA)Input:E,E′and∼relation1foreachey∈EMdo// STEP 1 scannigEM2addCCytoCC(s(y));3foreache′x∈E′Mdo// STEP 2 scannigE′M4s∗←s∈P∣s(x)∼s;5ifs∗=nullthen6adde′xtoIn;7else ifCC(s∗)=∅then8adde′xtoIn;9else ifCCx/∈CC(s∗)then// Comparing CCs10adde′xtoIc; update(CC(s∗));11returnimpact-set=In∪IcFig. 3. RECONTEST’ Phase I. It has a time complexity ofO(∣EM∣+∣E′M∣)
250
250
250
250since the current newCCxof statements(x)has been alreadyconsidered, we consider each new CC at most two times [18].The time complexityof the algorithm is linear to the size ofE′MandEM, and it is polynomial in the maximum size ofCC(s)and the size of the largest CC ofE′MandEM.D. What Can Our CIA Guarantee?RECONTEST’s CIA guarantees that the impact-set derivedis precise and minimal under the two following assumptions.The computation of the∼relation is perfect.This isa reasonable assumption because it can be easily computedbased on the syntactically modiﬁed statements using a textdiff utility that aligns unmodiﬁed source code lines. Not thatthis assumption also implies that the change-set is perfect.CS k-CFA is precise.k-CFA does not guarantee precisioneven by setting k =∞[26]. However, for our purposes it worksin practice because it is very unlikely that developers replacean object with another object that has an identical CS k-CFA.IV. PHASEII:INTERLEA VINGSELECTIONRECONTEST’s Phase II reduces the regression testing costby limiting the search of problematic interleavings only amongthose containing at least one impacted event. This is becausethe inclusion of impacted events is anecessary property of anew interleaving(see Theorem 1). For example, the atomicityviolation<e′9,e′2,e′3,e′10>in Figure 1, can only be manifestedinP′(t)but not inP(t), in facte′10is an impacted event.A. Characterizing the Delta of the Interleaving SpaceWe useMto denote the set of all MEM events in an execu-tion traceE. An interleavingσofE, is a total order relationon a set ofM. Theinterleaving spaceofE, denoted asIS(E)is the set of all interleavings that maintain the sequential orderwithin each thread [27].σisfeasibleif it can be manifestedduring an actual execution,infeasibleotherwise.IS(E)is thesubset ofIS(E)containing only feasible interleavings. Twointerleavingsσ1andσ2areequivalent(denoted byσ1≈σ2)iff each statement that generated thei-thevent inσ1is in∼relation with the statement that generated thei-thevent inσ2.Deﬁnition 3.GivenE=P(t)andE′=P′(t), thedelta of theinterleaving space, denoted by∆IS(E′,E), contains the newinterleavings that can be observed inP′(t)but not inP(t).∆IS(E′,E)={σ1∈IS(E′)∣ / ∃σ2∈IS(E),σ1≈σ2}Theorem 1.An interleavingσofE′includes at least oneimpacted event ifσ∈∆IS(E′,E).Proof.It will be proved by contradiction. Let assume thatσ∈∆IS(E′,E)andσdoes not include events in the impact-set.By the deﬁnition, the following two conditions hold: (A)σdoes not includenewevents (σ∩In=∅) and (B)σdoesnot include events that changed their CC (σ∩Ic=∅). (A)implies that every event inσhas been also observed inE. (B)implies that these events did not changed their CC. Thus, ifσis feasible underP′it must be also feasible underP. Thisis a contradiction because we assumed thatσis only feasibleunderP′by assuming thatσis in∆IS(E′,E).Algorithm 2:Detecting Violations in∆IS(E′,E)Input: theimpact-setI , a memory locationloc, units of work.L′⊆E′∣L′contains MEM events that accesslocforeach threadsth1,t h2∣th1≠th2doforeachei∈{L′∩I}∣th(i)=th1doforeachej∈L′∣u(j)=u(i)doifi<jthenforeachek∈L′∣th(k)=th2doisV(ei,ek,ej);else ifi>j, ej∉Ithenforeachek∈L′∣th(k)=th2doisV(ej,ek,ei);else ifi==jthen//true one time per iforeachek∈{L′∖I}∣th(k)=th2doforeachew∈{L′∖I}∣u(w)=u(k),w>kdoisV(ek,ei,ew);Fig. 4. Phase II : PTA algorithm for detecting atomic-set serializabilityviolations only within the delta of the interleaving space.O(∣I∣∣E′M∣2)Theorem 1 implies that including at least one impactedevent is a necessary property of a new interleaving. However,the inclusion of impacted events is not a sufﬁcient condition,because even if aσincludes events with an altered CC,σcouldstill be infeasible inP′(t). Intuitively, the ramiﬁcation of anevent in the interleaving space can depend on other events, andtherefore it has to be checked case by case. For example, theatomicity violation<e′5,e′9,e′6>in Figure 1 remains infeasibleinP′(t)even ife′5ande′6are impacted. This is not an issuebecause we leverage Theorem 1 before pruning infeasibleinterleavings. As a result, under the assumption that theimpact-set is precise (see Section III-D), Theorem 1 enablesus to safely select all new interleavings using impacted events.B. Covering Atomic-Set Serializability ViolationsCharacterizing the delta of the interleaving space with theimpacted events is still insufﬁcient for reducing regressiontesting costs signiﬁcantly. This is because the number ofnew interleavings could still grow exponentially with theexecution length. RECONTESTrelies on concurrency coveragecriteria for covering representative interleavings and exposingconcurrency bugs. We consider those interleavings that matchproblematic access patternsviolatingatomic-set serializability[43].Atomic-setare groups of memory locations sharing aconsistency property. Code fragments expected to preservethe consistency of an atomic-set are calledunits of work.Atomic-set serializability requires that units of work must beserializablefor all the atomic-sets that they operate on [43].Due to atomic-set serializability violations involve a smallset of accesses(at most four [43]). There is a small chancethat these small set of accesses contain one of the impactedones. As a result, the number of violations in the delta of theinterleaving space is often small (see RQ1).C. Exploring the Delta of the Interleaving SpaceA naive solution that detects violations inE′and thenselects those that include impacted events does not help reduce
251
251
251
251W(x)R(x)W(x)P
P(t)P′(t)RECONTEST Phase II: Interleaving SelectionRECONTEST Phase I: CIA 
W(k)R(x)W(l)W(x)Inputimpactedchange-setExploringinterleavingscontaining  at least one impactedeventConcurrency Context(CC)ExcludedTo be testedP′....CIACCPTAMonitoringEE′Interleaving SpaceIS(E)IS(Eʹ)ΔIS(Eʹ,E)
t
tOR
t
Output
t
t
t
W(x)R(x)W(l)W(x)
W(x)R(x)W(l)W(x)PTAValidationP′Fig. 5. Overview of RECONTESTthe cost of detecting violations inE′because pruning ismade only after a violation is detected. Recall that Phase II’sobjective is toexplore and detect onlythose violations thatcontain impacted events. Therefore, RECONTESTcommencesthe interleaving exploration using the impacted event informa-tion. Note that this can be achieved because we are adoptingan off-line interleaving exploration. For each impacted event,it creates an incomplete interleaving that partially matches aproblematic access pattern. After that, it searches for com-patible events in the trace for completing the pattern. Figure4 shows the proposed algorithm for violations constituted bythree events [43], the algorithm for violations of four eventsis omitted because has a similar ﬂavour.u(x)denotes the unitof work ofex, the functionisVchecks if the type of memoryaccesses match a problematic pattern [43]. The feasibility ofthe violations detected is veriﬁed with the PTA validation step.The time complexityof detecting violations with PTA isin the worst caseO(∣E′M∣k)[18], wherekis the size of thelargest access pattern (k=4in our case [43]). Algorithm 2and its variant for patterns of four events has a worst timecomplexity ofO(∣I∣∣E′M∣k−1), whereI⊆E′Mis the impact-set.V. EVA L UAT I O NA. ImplementationTo evaluate our framework, we have implemented a proto-type of RECONTESTin Java1. Figure 5 shows an overviewof the prototype. The change-set is obtained using ChangeDis-tiller [13], an AST-based differencing tool for ﬁne-grain sourcecode change extraction. We made the following two modiﬁ-cations. First, we uniﬁed the output granularity at statementlevels. Second, we implemented a component that maintainsthe equivalence mapping of statements across two programversions because this feature is not available in the originaltool, which only reports the changed parts. The executiontracesE′andEare collected with the monitoring step ofAssetFuzzer [22] built upon the SOOT-based instrumentationphase of the CalFuzzer framework [20]. The memory locationsshared among multiple threads are identiﬁed by a precisedynamic thread escape analysis[20]. RECONTESTcomputesthe impact-set using the presented CIA in Algorithm 1. Itimplements the CS k-CFA abstraction withk=∞. Subse-quently, it explores the delta of interleaving space by analyzingE′using Algorithm 2. Atomic-sets and units of work are1The tool is available athttp://sccpu2.cse.ust.hk/recontest/index.htmlTABLE ISUBJECTS DESCRIPTION,SIZE OF THE TRACES AND OVERHEAD FORTRACE COLLECTION AND FOR COMPUTINGCCSubjectsPTA monitoring stepID Name SLOC ref.∣change-set∣∣E′M∣time overhead1 Groovy 361 GROOVY-1890 8949 2.93s 1.88x2 Airline 136 [9] 1055 2.44s 1.91x3 Log4j 2,598 CONF-1603 23130 2.79s 1.86x4 Pool 745 POOL-120 970274 3.95s 1.76x5 Lang 486 LANG-481 9310 4.82s 1.41x6 Vector1 835 JDK-4420686 7,836381 2.50s 1.83x7 SBuffer1 1,265 JDK-4810210 151,909 6.81s 1.34x8 SBuffer2 1,249 JDK-4790882 692,527 6.08s 1.15x9 Vector2 292 JDK-4334376 23,447 7.26s 3.14x10 Garage 554 [9] 2017 K 39.08s 15.88x11 Logger 39 K JDK-4779253 1,66139 K 34.22s 14.77x12 Xtango 2,097226150 K 20.22s 3.17x13 Cache4j 3,8973128570 K 90.55s 50.72xautomatically inferred using existing heuristics that have afalse positive rate between 2-4% [40]. The heuristics assumethat all instance ﬁelds of an object are members of an atomic-set, and that all public or protected methods are units of worksdeclared on this atomic-set. The output of RECONTESTis areport containing atomic-set serializability violations, whosefeasibility is veriﬁed with the traditional PTA validation step.B. Subjects DescriptionWe evaluated RECONTESTon 13 real concurrency bugs(Table I). For each bug, we collected the following: 1) acorrectand abuggyversion of the program, and 2) one third-partymulti-threaded test (likely a stress test) that can potentiallymanifest a failure-inducing interleaving only on the buggyversion. We cut the scale of interleaving exploration in the testby reducing the number of running threads and iterations. Thisis because RECONTESTonly needs to observe one possiblemulti-threaded execution. The interleaving space is exploredin Phase II by generalizing the observed execution.Table I describes the concurrency bug subjects. The “ref.”column gives the reference of their bug reports (if available).Groovy, Lang, Log4jandPoolare four popular programs.The buggy/correct versions and the tests were obtained atSIR4.Logger, SBuffer1, SBuffer2, Vector1andVector2areprograms from the JDK library. The buggy/correct versionswere collected from the JDK repository, while the tests were2Xtango:https://www.cs.drexel.edu/∼umpeysak/Xtango/3Cache4j:http://cache4j.sourceforge.net/4SIR:http://sir.unl.edu/portal/index.php
252
252
252
252TABLE IIEXPERIMENTAL RESULTS.COMPARISON OFRECONTEST WITH STRESS-TESTING ANDASSETFUZZER WITH A TIME BUDGET OF24HOURS.Phase IPhase IIAssetFuzzer [22]RQ1RECONTESTstress-testingRQ2 speed-upRQ3IDimpacted% time# violations time# violations timereductiontotal timetimestress-testing AssetFuzzer# f. viol153.06% 9ms162 8ms295 24ms1.82x2.95s11.90s4.06x 1.41x16216.36% 10ms157 18ms325 12ms2.07x2.47s2.70s1.09x 0.43x336.15% 16ms12 3ms224 145ms18.67x2.81s10.20s36.31x 7.63x7473.57% 42ms328 85ms3,040 122ms9.27x3.51s8.15s2.28x 0.96 x3510.97% 27ms5,322 47ms23,038 214ms4.33x4.90s5.83s1.19x 2.89x1661.31% 19ms74 150ms45,656 1.72s617x2.67s840s314.72x 10.20x270.20% 104ms1,102 55ms396,256 1.24s360x6.97s31s4.45x 7.81x181.50% 106ms151,214 434ms1,437,972 3.53s9.51x6.62s27s4.08x 6.54x4,87690.10% 122ms1,053 55ms144,354,356 961s137,088x7.44s1.5hr760.24x 5,429x3100.03% 409ms32,846 13.10s16,086,708 2.39hr490x52.59s352s6.69x 638x38110.19% 15.10s7,430 4.65s110,337 0.83hr14.85x53.97stime-out>1,601x 152x1120.14% 3.07s326,603 1.93s>236,340,709 time-out>724x25.23stime-out>3,425x>17,245x104130.02% 7.99s64,670 27.38s>116,616,808 time-out>1,803x126stime-out>686x>2,442x14adapted from the test harnesses used by CalFuzzer [20].The remaining four programsAirline, Cache4j, GarageandXtangoare benchmarks used in the evaluation of existingworks. For each of these four bugs, following the evaluationmethodology adopted by CAPP [19], we generated thecorrectversion. Column “SLOC” shows the size ofP′. The sizes rangefrom 136 to 39K lines. The ﬁfth column gives the numberof changed source code statements between the revisions. Itranges from 2 to 7,836. Column “∣E′M∣” shows the numberof MEM events obtained by running the test with the buggyversion. It ranges from 49 to 570K. The seventh columngives the time required to collectE′by the monitoring stepof AssetFuzzer,which includes the time to compute the CCfor each memory access.Recall that PTA computes CCs forpruning infeasible interleavings. The eight column indicatesthe overhead of the trace collection. It ranges from 1.15×to50.72×. The size ofEMhas been omitted since it has a similarsize toE′M. For fair comparisons we saved the execution traceson disk to conduct experiments on the same traces.C. Research QuestionsIn this paper, we propose the use of RECONTESTto reducethe regression testing cost of concurrent programs by searchingproblematic interleavings within the new interleavings inducedby code changes. Since we found no previous works with thesame goal, we compare RECONTESTwith stress-testing asbaseline. We also compare with traditional PTA that directlydetects atomic-set serializability violations inP′(t)using theoriginal AssetFuzzer. We do not compare our approach withorthogonal techniques that select test cases (e.g., [49]) becausewe assume thatallthe tests considered in our experiments aregiven. In fact, all the test cases have interleavings that exhibitregression concurrency bugs. Moreover, we compare the testefﬁciency of RECONTESTwith CAPP [19] that uses programchanges to prioritize schedules. We set atime-budgetof 24hours when analyzing each test, which is in line with realworld settings (e.g.,nightly-build-and-test). Our evaluationaims to answer the following four research questions:●RQ1. Effectiveness- How much interleaving space re-duction can be achieved by RECONTEST?●RQ2. Efﬁciency- How efﬁcient is RECONTEST? Doesthe overhead of pre-computing the impact-set out-weightsthe reduction in test effort?●RQ3. Correctness- Does our regression technique prac-tically achievesafetywhen selecting interleavings?●RQ4. Comparison with CAPP [19]- Which techniquedetect regression concurrency bugs faster?D. RQ1 - EffectivenessThe goal of this research question is to quantify the reduc-tion in interleaving space search. We compared the numberofpotential violationsinE′with those in∆IS(E′,E)(i.e.,those containing at least one impacted event). In other words,we compared the violations detected by the prediction stepof AssetFuzzer (sixth column of Table II) with those byAlgorithm 2 (fourth column). Note that the feasibility of theseviolations need to be veriﬁed by the validation step of PTA.Column “RQ1” shows the results, the reduction ranges from1.82×to more than 137,000×, with a geometric mean of 82×.RECONTESTachieves high reduction because the proportionof impacted memory accesses is generally very small. Thesecond column gives the proportion of impacted events inE′M.The proportion ranges from 0.02% forCache4jto 73.57% forPool, with a geometric mean of 1%.E. RQ2 - EfﬁciencyRQ2 studies if RECONTESTcan effectively reduce theinterleaving exploration cost for regression testing. The thirdcolumn of Table II gives the computation time for Phase I.It ranges from 9ms to 15s. As expected, Phase I has a lineartime complexity with respect to the execution traces length.The ﬁfth column reports the time to detect the violations thatcontain at least one impacted event (PTA prediction step) andto prune infeasible ones using thelockset/happens-before anal-ysis(PTA validation step). It ranges from 3ms to 27s. Around3% of this time was spent on the validation step. Similarly,the seventh column gives time required by AssetFuzzer for
253
253
253
253stress-testingAssetFuzzer (no E' overhead)RECONTEST Phase I + II (no E' overhead)24hr
Subject IDTime logscale0time-out
1 2         3          4          5          6          7          8          9         10        11       12        13Fig. 6. Efﬁciency comparison. Subjects ordered by length of execution traceand the corresponding interleaving exploration time in log scale.the prediction and validation steps. The ninth column showsthe total testing time of RECONTEST(Phase I + Phase II)including the overhead of collectingE′and computing CCs(PTA monitoring step Table I). We consider thatEis alreadyavailable, since we assume that it has been used for testingP(t). The tenth column reports the time for executing thegiven test repeatedly in a multi-core environment until eithera runtime exception or an assertion violation occurs. Sincethe interleaving exploration relies on the non-determinism ofthe scheduler, we ran stress-testing ten times and we took theaverage.Stress-testing failed to complete in 24 hours for the threesubjects with the longest traces, while AssetFuzzer for thetwo subjects with the longest traces. RECONTESTsuccessfullydetected and validated the concurrency faults of all the 13subjects in less than ﬁve minutes (ninth column). The eleventhand twelfth columns show in details the comparison results.Stress-testing (eleventh column).For fair comparisons weincluded the overhead of collectingE′and computing CCs,which is not required by stress-testing. Stress-testing is knownto be ineffective since it might repeatedly explore the sameinterleavings, while atomicity violations are hard to manifestbecause they have a low probability of occurrence [31].AssetFuzzer (twelve column).We did not included theoverhead of collectingE′and computing CCs (PTA moni-toring step Table I) since it is required by both AssetFuzzerand RECONTEST. Since PTA suffers from scalability issueswhen analyzing long execution traces [18], [11], AssetFuzzerefﬁciency degrades for the ﬁve subjects with the longesttraces. By exploring a smaller interleaving space (see RQ1),RECONTESTreduces the cost of detecting and validatingviolations, by 35×on average (geometric mean). Figure 6 plotsinbase-10 log scalethe interleaving exploration times. Foronly two subjects with short traces the overhead of Phase Iout-weights the reduction in test effort,AirlineandPool. Asshown in Figure 6, RECONTESTprovides an advantage withlong execution traces where, due to theinterleaving explosionproblem, concurrency testing becomes an expensive activity.F . RQ3 - CorrectnessSince it is difﬁcult to evaluate the correctness of theimpact-set, we evaluate the correctness based on the violationsreported by RECONTEST. We compared the violations in thefourth and sixth columns of Table II that are retained afterthe validation step. We removed any latent violations thatTABLE IIIRQ4 : EFFICIENCY COMPARISON WITHCAPP [19]SubjectsStateless CAPP [19]RECONTESTSIR#re-schedules×timet= totaltotal speed-upAirline3282 1.27s>4,181s2.47s>1,693×Groovy19 1.56s>29.71s2.95s>10×Lang4 3.40s>13.60s4.90s>2.77×Pool10 2.68s>26.86s3.51s>7.65×were present also inP(t), and we removed redundant bugreports. RECONTESTdid not miss anyregression concurrencybugs, it reported the same feasible violations reported byAssetFuzzer (column “RQ3” of Table II). This indicates thatthe impact set derived by RECONTEST’s CIA is sufﬁcientlyprecise to guarantee asafeselection of interleavings. All theviolations that have been detected by only AssetFuzzer areinfeasible inP(t)(underP-Correct-for-Tassumption) and,as expected, they remain infeasible inP′(t)(they are prunedby the validation step of PTA) because the CCs of the accessesinvolved in these interleavings have not changed.G. RQ4 - Comparison with CAPPCAPP [19] uses evolution information to prioritize enu-meration of schedules that perform preemption at changedcode. Although RECONTESTaddresses a different regressiontesting problem (interleaving selection), we want to evaluatewhich technique ﬁnds regression concurrency bugs faster.We compared RECONTEST’s performance with the publishedresults of CAPP [19]. We obtained the same subjects, programrevisions and tests from the SIR repository. Table III showsthe common subjects with a serializability violation. CAPP hasnot been evaluated using real time. We recovered an under-approximated measure by multiplying the execution time ofthe test case with how many re-executions the best CAPPheuristic (LOA [19]) has to explore before ﬁnding the bug.This measure ignores the unknown overheads of CAPP’sanalysis and the underline model checker. We compare it withtherealexecution time of RECONTESTincluding Phase I,Phase II and the overhead of collecting the execution trace.Table III shows the results. In average RECONTESTis morethan 25×faster. The speed-up is attributed to a more preciseand smaller impact-set as well as CAPP enumerates scheduleswhile RECONTESTselectively explores the interleaving space.H. Threats to Validity1) Could the experimental results be generalized?Wereduced these threats by considering real world subjects andreal and complex test cases, we included executions of halfmillion accesses.2) MightRECONTESThave different resultsif it was implemented upon other PTA techniques?This threatis not signiﬁcant. First, the violations that match an executiontrace are independent from the algorithm used for detectingthem. Second, the complexity of predicting the same type ofviolations does not change across different techniques [18],[11]. Moreover, RECONTESTis orthogonal to the reductionor bounding techniques applied during PTA analysis.
254
254
254
254I. Limitations and Future WorksAd-hoc synchronizations.Our current implementation (aswell as most PTAs) is not able to identify SND/RCV eventsgenerated by application level synchronization mechanisms,such as barrier and ﬂag operations [45]. This limitation isinherited from the underlying tool used to obtain theexecutiontrace[22]. In future work, we consider to adopt existingtechniques [42], [45] for detecting ad-hoc synchronizationsand generating SND/RCV accordingly. However, ad-hoc syn-chronizations are relatively uncommon as compared with theirstandard counterparts [45].Sensitivity of the trace.PTA generally assumes that allMEM events are observed by executingP′(t)once. However,executing a concurrent program using the same input by morenumber of times could occasionally exercise different parts ofthe code, but the marginal beneﬁt is usually too small to justifythe extra overhead [31], [6]. Recent work has reported thatthe ﬂuctuation in atomicity violation detection among multipleruns with the same input is at most 0.4% [6]. In future work,we plan to analyse multipleexecutions tracesand then ﬁlteringequivalent portions of traces for minimizing the analysis cost.VI. RELATEDWORKRegression testing.Few studies have been made to reducethe regression testing cost of concurrent programs [47]. Re-cently, Yu et al. presented the ﬁrst test case selection andprioritization framework, SimRT [49], speciﬁc for concurrentprograms and data races. However, selection only at test caselevels is insufﬁcient since it does not reduce the interleavingexploration cost of selected or prioritized test cases. RECON-TESTcould be used in conjunction with SimRT, by exploringthe interleaving space of the tests given by SimRT.Regression veriﬁcation.Researchers have presented solu-tions to reduceregression veriﬁcationcosts by applyingmodelchecking(e.g., CHESS [30], JPF [15]) incrementally. Thesetechniques re-use veriﬁcation results [24], [46], [3], [2] orprioritize the state-space exploration [19]. Formal veriﬁcationof concurrent programs remains too expensive for being usedin practice [21], even with thepartial order reduction[12] orcontext bounding[30]. Model checking exhaustively enumer-ates the interleaving space of a multi-threaded execution, thusit fails to scale for even small size programs (see RQ4).Concurrency testing.Many techniques have been proposedfor detecting atomicity violations (e.g., [37], [22], [17], [39]).However, applying them after each program revision is ex-pensive because the number of interleavings that could causeatomicity violations is often huge [18], [6]. Researchers haverecently proposed to avoid redundant analysis by detectinginterleaving space overlapacross inputs[48], [6]. MAPLE [48]aims to reduce validation costs of PTA. It detects problematicinterleavings in a given run and avoids to validate those thatwere earlier tested withdifferent inputs. This approach cannotbe applied across revisions because the interleavings that areinfeasible in the original program could become feasible afterrevisions. Moreover, MAPLE does not reduce the detectioncosts because pruning is only made after a problematic in-terleaving is detected. Deng et al. presented a technique thatguides atomicity detection only towards unique interleavingsacross inputs [6], [7]. In their preliminary position paper[7] they discuss, but do not evaluate, the opportunity ofapplying their technique also across software versions. Theycharacterize the delta of interleaving space with the set of pairof functions that are concurrent [6], [7]. However, a functionlevel approach is too coarse grained for precisely identifyingﬁne differences in the interleaving space. Note that all casesin Figure 1 are at memory access level. Computing the pair ofmemory accesses that are concurrent would be too expensive[6]. In contrast, RECONTESTefﬁciently characterizes the deltaof interleaving space at memory access level.Change-Impact-Analysis.Since concurrency-related mod-iﬁcations such as adding and removing locks are unlikelydataﬂow changes, most dataﬂow-based CIAs [25] are noteffective for concurrent programs. In Section III we havealready discussed the limitations of existing concurrency-related CIAs [49], [19]. By being static they fail to computeminimal sets [1]. The reasons are twofold. First, static CIAsconsider all possible behaviors of the software. This can bemuch optimized for regression testing concurrent programswhereas we are interested only in the behaviors of the programunder a speciﬁc test execution. Second, they consider someimpossible behaviors, due to the imprecision of the staticanalysis [1]. In contrast, our dynamic CIA does not sufferfrom these limitations. Moreover, existing concurrency-relatedCIAs [49], [19] cannot guarantee to detect all impacted events,due to they only consider changes of synchronization blocks.By ignoring changes that affect happens-before relations, theywould likely miss many impacted events. From our experimen-tal results, if we consider the impacted events of all subjectsas a whole, shared memory accesses with affected happens-before relations represent a considerable portion (55%).VII. CONCLUSIONIn this paper we presented RECONTESTto reduce theregression testing cost of concurrent programs by selectinginterleavings only within the delta of the interleaving space.We characterized the delta with an impact-set of memoryaccesses obtained by comparing execution traces. Our experi-mental results showed that RECONTESTsigniﬁcantly reducesthe cost of interleaving exploration during regression testingwithout missing faulty interleavings.In the future, we plan to evaluate RECONTESTon othertypes of concurrency bugs, such as deadlocks and orderviolations. We also intend to extend RECONTESTto addressthe test suite augmentation problem of concurrent programs.ACKNOWLEDGMENTSThis research is inspired by a discussion with Mary JeanHarrold. The research was partially funded by Research GrantsCouncil (General Research Fund 611813 and 621912) of HongKong.
255
255
255
255REFERENCES[1] Apiwattanapong, T., Orso, A. and Harrold, M.J. Efﬁcient and PreciseDynamic Impact Analysis Using Execute-After Sequences. InICSE,2005[2] Backes, J., Person, S., Rungta, N. and Tkachuk, O. RegressionVeriﬁcation Using Impact Summaries. InSPIN, 2013.[3] Beyer, D., Lowe, S., Novikov, E., Stahlbauer, A. and Wendler, P.Precision Reuse for Efﬁcient Regression Verication. InFSE, 2013.[4] Bohner, S.A. and Arnold, R.S. Software Change Impact Analysis. InIEEE-CS, 1996.[5] Cai, Y. and Chan, W. K. MagicFuzzer: Scalable Deadlock Detectionfor Large-Scale Applications. InICSE, 2012.[6] Deng, D., Zhang, W. and Lu, S. Efﬁcient Concurrency-Bug DetectionAcross Inputs. InOOPSLA, 2013.[7] Deng, D., Zhang, W., Wang, B., Zhao, P., and Lu, S. Understandingthe Interleaving-Space Overlap across Inputs and Software Versions.InHotPar, 2012.[8] Do, H., Mirarab, S., Tahvildari, L. and Rothermel, G. The Effects ofTime Constraints on Test Case Prioritization: A Series of ControlledExperiments.IEEE TSE, 2010.[9] Farchi, E., Nir, Y., and Ur, S. Concurrent Bug Patterns and How toTest Them.IPDPS, 2003.[10] Elbaum, S., Malishevsky, A.G. and Rothermel, G. Prioritizing TestCases for Regression Testing. InISSTA, 2000.[11] Farzan, A. and Madhusudan, P. The Complexity of Predicting Atom-icity Violations. InTACAS, 2009.[12] Flanagan, C. and Godefroid, P. Dynamic Partial-Order Reduction forModel Checking Software. InPOPL, 2005.[13] Fluri, B., Wuersch, M., PInzger, M. and Gall, H. Change Distilling:Tree Differencing for Fine-Grained Source Code Change Extraction.IEEE TSE, 2007.[14] Harrold, M.J., Jones, J.A., Li, T., Liang, D., Orso, A., Pennings, M.,Sinha, S., Spoon, S.A. and Gujarathi, A. Regression Test Selectionfor Java Software. InOOPSLA, 2001.[15] Havelund, K. and Pressburger, T. Model checking JA V A programsusing JA V A PathFinder.STTT, 2000.[16] Hsu, H.Y. and Orso, A. MINTS:A General Framework and Tool forSupporting Test-Suite Minimization. InICSE, 2009.[17] Huang, J. and Zhang, C. Persuasive Prediction of Concurrency AccessAnomalies. InISSTA, 2011.[18] Huang, J., Zhou, J. and Zhang, C. Scaling Predictive Analysis ofConcurrent Programs by Removing Trace Redundancy.TOSEM, 2013.[19] Jagannath, V., Luo, Q. and Marinov, D. Change-Aware PreemptionPrioritization. InISSTA, 2011.[20] Joshi, P., Naik, M., Park, C.-S. and Sen, K. CalFuzzer: An ExtensibleActive Testing Framework for Concurrent Programs. InCAV, 2009.[21] Joshi, P., Park, C.-S., Sen, K. and Naik, M. A Randomized DynamicProgram Analysis Technique for Detecting Real Deadlocks. InPLDI,2009.[22] Lai, Z., Cheung, S.C. and Chan, W.K. Detecting Atomic-Set Se-rializability Violations in Multithreaded Programs through ActiveRandomized Testing. InICSE, 2010.[23] Lamport, L. Time, Clocks, and the Ordering of Events in a DistributedSystem.CACM, 1978.[24] Lauterburg, S., Sobeih, A., Marinov, D. and Viswanathan, M. In-cremental State-Space Exploration for Programs with DynamicallyAllocated Data. InICSE, 2008.[25] Li, B., Sun, X., Leung, H. and Zhang, S. A Survey of Code-BasedChange Impact Analysis Techniques.STVR, 2013.[26] Liang, P., Tripp, O., Naik, M. and Sagiv, M. A Dynamic Evaluationof the Precision of Static Heap Abstractions. InOOPSLA, 2010.[27] Lu, S., Jiang, W. and Zhou, Y. A Study of Interleaving CoverageCriteria. InFSE, 2007.[28] Lu, S., Park, S., Seo, E. and Zhou, Y. Learning from Mistakes: AComprehensive Study on Real World Concurrency Bug Characteris-tics. InASPLOS, 2008.[29] Mattern, F. Virtual Time and Global States of Distributed Systems.InWDAG, 1989.[30] Musuvathi, M., Qadeer, S., Ball, T., Basler, G., Nainar, P.A., andNeamtiu, I. Finding and Reproducing Heisenbugs in ConcurrentPrograms. InOSDI, 2008.[31] Park, S., Lu, S. and Zhou, Y. CTrigger: Exposing Atomicity ViolationBugs from Their Hiding Places. InASPLOS, 2009.[32] Person, S., Yang, G., Rungta, N. and Khurshid, S. Directed Incremen-tal Symbolic Execution. InPLDI2011.[33] Rothermel, G. and Harrold, M.J. Analyzing Regression Test SelectionTechniques.IEEE TSE, 1996.[34] Rothermel, G. and Harrold, M.J. A safe, Efﬁcient Regression TestSelection Technique.TOSEM, 1997.[35] Savage, S., Burrows, M., Nelson, G., Sobalvarro, P. and Anderson, T.Eraser: A Dynamic Data Dace Detector for Multithreaded Programs.InSOSP, 1997.[36] Sen, K. Race Directed Random Testing of Concurrent Programs. InPLDI, 2008.[37] Sen, K. and Agha, G. Detecting errors in multithreaded programs bygeneralized predictive analysis of executions. InFMOODS, 2005.[38] Shivers, O. Control Flow Analysis in Scheme. InPLDI, 2009.[39] Sorrentino, F., Farzan, A. and Madhusudan, P. PENELOPE: WeavingThreads to Expose Atomicity Violations. InFSE, 2010.[40] Sumner, W.N., Hammer, C. and Dolby, J. Marathon: DetectingAtomic-Set Serializability Violations with Conﬂict Graphs. InRV,2012.[41] Sumner, W.N., and Zhang, X. Identifying Execution Points for Dy-namic Analyses. InASE, 2013[42] Tian, C., Nagarajan, V., Gupta, R. and Tallam, S. Dynamic Recogni-tion of Synchronization Operations for Improved Data Race Detec-tion. InISSTA, 2008.[43] Vaziri, M., Tip, F. and Dolby, J. Associating Synchronization Con-straints with Data in an Object-Oriented Language. InPOPL, 2006.[44] Xin, B., Sumner, W.N. and Zhang, X. Efﬁcient Program ExecutionIndexing. InPLDI, 2008.[45] Xiong, W., Park, S., Zhang, J., Zhou, Y. and Ma, Z. Ad HocSynchronization Considered Harmful. InOSDI, 2010.[46] Yang, G., Dwyer, M.B. and Rothermel, G. Regression Model Check-ing. InICSM, 2009.[47] Yoo, S. and Harman, M. Regression Testing Minimization, Selectionand Prioritization: A Survey.STVR, 2010.[48] Yu, J., Narayanasamy, S.,Pereira, C., and Pokam, G. Maple: ACoverage-Driven Testing Tool for Multithreaded Programs. InOOP-SLA, 2012.[49] Yu, T., Srisa-an, W. and Rothermel, G. SimRT: An AutomatedFramework to Support Regression Testing for Data Races. InICSE,2014.
256
256
256
256
View publication stats