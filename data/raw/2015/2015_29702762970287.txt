Visual Contract Extractor: A Tool for Reverse Engineering
Visual Contracts using Dynamic Analysis
Abdullah Alshanqiti, Reiko Heckel
Department of Computer Science,
University of Leicester, UK
amma2@leicester.ac.uk,
reiko@mcs.le.ac.ukTimo Kehrer
Department of Electronics, Information
and Bioengineering,
Politecnico di Milano, Italy
timobenjamin.kehrer@polimi.it
ABSTRACT
Visual contracts model the operations of classes, compo-
nents or services by pre- and post-conditions formalised as
graph transformation rules. They provide a precise but in-
tuitive notation to test, document and analyse software sys-
tems. However, due to their detailed level of specication
of data states and transformations, modelling a real appli-
cation is a complex and error-prone process.
Rather than adopting a top-down modelling approach,
we follow a dynamic bottom-up approach to reverse engi-
neer visual contracts from object-oriented programs based
on tracing the execution of operations. We developed the
Visual Contract Extractor (VCE), a dynamic analysis tool
which supports the reverse engineering of visual operation
contracts from Java programs. We explore the main fea-
tures of the tool using two case studies and discuss usage
scenarios ranging from traditional program understanding
to novel applications in the eld of model-based engineer-
ing. A screencast demonstrating the tool is provided at
https://www.youtube.com/watch?v=VtTx8UHgRGo.
CCS Concepts
‚Ä¢Social and professional topics !Software reverse
engineering; ‚Ä¢Software and its engineering !Dy-
namic analysis; Model-driven software engineering; Visual
languages; Software testing and debugging; Object oriented
development;
Keywords
Visual contracts, graph transformation, model extraction,
dynamic analysis, reverse engineering, specication mining
1. INTRODUCTION
Visual contracts (VCs) support high-level behaviour mod-
elling of software operations [27]. They consist of a pair
of conditions that describe a system's state, relevant to aspecic operation, before ( pre-condition ) and after ( post-
condition ) execution. The pre-condition species the con-
ditions which must be fullled such that the operation can
be executed, while the post-condition declaratively describes
its eects [16, 23]. Based on a formal representation as graph
transformation rules, VCs can be used for model-based or-
acle and test case generation [21], run-time monitoring [12],
as well as simulation and formal verication [10].
However, visual contracts are complex to be modelled
manually. Due to their detailed specication of data states
and transformations they are closer to the implementation
level than other modelling approaches such as state machines
or UML sequence diagrams. Therefore, reverse engineering
them from implementations, as a bottom-up approach, is
a promising alternative to top-down modelling of VCs, and
provides a valuable tool for program understanding. The ex-
traction of behavioural models from implementations can be
performed statically by examining the source code to cap-
ture all possible behaviours [8]. However, dynamic bind-
ing in object-oriented software aects the accuracy of static
methods, often leading to an over-approximation of eects
or dependencies.
Instead, we follow a dynamic approach to reverse engi-
neer visual contracts from object-oriented programs based
on tracing the execution of operations. To that end, we de-
veloped the Visual Contract Extractor (VCE), a dynamic
analysis tool which supports the reverse engineering of vi-
sual operation contracts from Java programs. The resulting
contracts give an accurate description of the observed object
transformations, their eects and pre-conditions in terms of
object structures, parameter and attribute values, and al-
low generalisation by learning multi-objects. Fundamental
concepts and techniques of our approach have been pub-
lished in previous work [1, 2, 3], while this paper focuses
on implementation and tooling. In addition, we discuss two
novel application scenarios for our tool in the eld of model-
based engineering, namely the use of visual contracts for
model-based (or visual) debugging as well as the automated
learning of complex model editing operations by examples.
The paper is structured as follows. Sect. 2 briey explains
the overall approach and the architecture of the proposed
tool. In Sect. 3, we explore the main features of the tool
using two case studies, focusing on its use in the context
of program understanding, while Sect. 4 discusses two novel
application scenarios in the eld of model-based engineer-
ing. Related work will be reviewed in Sect. 5, and Sect. 6
concludes the paper along with an outlook on future work.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission and/or a
fee. Request permissions from Permissions@acm.org.
ASE‚Äô16 , September 3‚Äì7, 2016, Singapore, Singapore
c2016 ACM. 978-1-4503-3845-5/16/09...$15.00
http://dx.doi.org/10.1145/2970276.2970287
816
2. EXTRACTION OF VISUAL CONTRACTS
Sect. 2.1 briey explains our overall approach, parts of
which have been published in previous work [1, 2, 3]. Sect. 2.2
provides an overview of our integrated tool, the Visual Con-
tract Extractor (VCE) , and its high-level architecture.
2.1 Approach
The extraction of visual contracts proceeds in three main
steps as illustrated in Fig. 1.
The rst step (A) extracts actual behaviour by tracing,
yielding an instance-level version of visual contracts, referred
to as contract instances orrule instances , from each opera-
tion invocation. We dynamically observe system execution
as proposed in [2]. The Java source code of a system is in-
strumented by weaving trace instructions using AspectJ [22].
When being executed, they result in a log recording object
creation, read and write access to objects and attributes,
etc. We construct contract instances from such a log that
capture the overall pre-condition and eect of the execution.
These contract instances describe only partial behaviour of
the system, i.e., the model obtained is valid for the scenario
that has been executed.
In step (B), we use our learning approach introduced in [3]
to generalise extracted contract instances. This depends for-
mally on typed attributed graph transformation rules [11]
and uses sub-graph matching algorithms for learning. For
each contract instance, we derive a so-called minimal rule ,
i.e., the smallest rule able to perform the given transforma-
tion. The generation of minimal rules results in a parti-
tioning of instances by eect: All instances with the same
minimal rule have the same eect, but possibly dierent pre-
conditions. To construct a maximal rule for each of these
partitions, we identify their common context elements, i.e.
a maximal rule contains all the context that is present in all
instances.
Finally, in step (C) we further increase generality of rules
by inferring multi-objects (MOs) [15] and attribute condi-
tions adopting the inference approach presented in [1]. Multi
objects support universal quantication over unknown con-
texts in a rule. In the case of iteration over collections, for
example, the set of minimal rules is potentially unbounded,
but many may only dier in the number of objects being
manipulated while performing the same actions across all of
them. Rules with MOs provide a concise way to specify con-
straints and actions across a set of objects of unknown car-
dinality. In order to derive attribute conditions, we use the
dynamic invariant detection tool Daikon [13] that takes the
actual data values of attributes and parameters, obtained
from the trace logs during the construction of rule instances,
as input and produces invariants in terms of logical formulae
over attribute and parameter variables as output. The pro-
duced invariants are used to increase the accuracy of gener-
alised contracts, particularly of maximal rules, by including
precise conditions on attributes and parameters.
In general, contracts extracted by our dynamic approach
will be neither correct, i.e. they may allow behaviour that is
not implemented by the system, nor complete, i.e. not all the
system's behaviour may be captured by the extracted con-
tracts [1]. Correctness depends on the selected scope, while
completeness is linked to code coverage obtained when exe-
cuting and observing the system. The degree of correctness
and completeness which needs to be achieved depends on
the particular use case of the VCE tool.
Figure 1: Overall picture of the VCE tool.
2.2 VCE‚Äôs Architecture
The architecture of the VCE tool, see Fig. 1, comprises
the following components: (A) The Tracer observing the
behaviour of selected classes using AspectJ and construct-
ing contract instances; (B) the Generaliser for generalising
contract instances to minimal and maximal rules; (C) the
Inferencer for learning MO rules and attribute conditions
using Daikon; (D) the Visualiser for selective display and
analysis of contracts; and (E) an Export facility, particularly
to the model transformation tool Henshin [4] for generating
executable contracts. VCE relies on a MySQL database as
back-end to eciently handle large (numbers of) contracts.
To selectively trace a huge Java program, the Tracer can
be congured i)by selecting the relevant classes to dene
the scope of object types, and ii)by identifying methods
of interest as each invocation of these methods will produce
a single contract instance, covering those objects which are
typed over the selected classes. In the remainder of the pa-
per, we focus on the Visualiser with its main usage scenario
of supporting program understanding, and on the Export
facilities of the tool, notably the export to Henshin.
Visualiser: The main task of the visualiser, see Fig. 2
for its main user interface, is to organise, browse and dis-
play extracted contracts. We support: i)The distinction
in colour and style between elements of the minimal and
maximal rule; dotted edges and nodes with coloured back-
ground (green for creation, red for deletion and light-golden
for nodes with updated attribute values) represent elements
of minimal rules, while nodes with white background and
solid edges are context elements; ii)the alternative display
of collections as to-* associations or using explicit collection
objects; iii)the selective visualisation of rules, e.g. the min-
imal rule or the pre-condition only, with the exibility to
change graph layouts; and iv)user interaction to conrm if
inferred features are correct.
Export: To interface with the tool, contracts can be ex-
ported to standard formats such as GXL or DOT graphs.
Most notably, VCE supports the export of generalised rules
to Henshin [4], a model transformation language and system
which is based on graph transformation concepts [11].
817(a)Visualisation of a contract instance
(b)Visualisation of a generalised rule
Figure 2: Graphical user interface of VCE's Visualiser component.
3. CASE STUDIES
In this section, we illustrate the main features of the VCE
tool using two case studies: NanoXML1, a non-validating
XML parser for Java which provides a light-weight way to
manipulate XML documents, and JHotDraw2, a customis-
able Java GUI framework for technical graphics editing. The
selected case studies are popular benchmarks for software
testing and analysis, and representative for the kind of sys-
tem our method is appropriate for, i.e., they show signicant
and dynamic object structures in their object-oriented core
model. In NanoXML this is the object representation of the
XML tree, for JHotDraw that of graphics objects.
1http://nanoxml.sourceforge.net/orig
2http://www.jhotdraw.org3.1 NanoXML
For conducting our experiments with NanoXML, we use
version 2.2.1 which consists of three packages and 24 Java
classes. We focus on classes XMLElement and XMLAt-
tribute , and select all XMLElement methods to generate
contracts from them. These classes provide the function-
alities to manipulate XML documents. We monitor execu-
tion of test cases generated by CodePro3, some of which are
modied manually to improve code coverage.
3.1.1 Visualisation of Contract Instances
Fig. 2 shows two screenshots of VCE's main user interface.
In (a), we present an instance extracted from an invoca-
3https://developers.google.com/java-dev-tools/codepro
818Figure 3: Object access and code locations.
tion of operation XMLElement.setAttribute(String, String,
String) , which represents, in a pair of object graphs, the pre-
and postcondition. This instance describes the creation of
a new XMLAttribute object and its incoming edge to link it
with the existing Vector object, and the update of attribute
Vector.size . The upper part of (a) gives information on the
operation signature, actual parameters and the extraction
process. In addition to the visual presentation of instance's
pre- and postcondition, i.e. relevant subsets of the program's
object graph before (left) and after (right) the invocation of
an operation, we provide information on the access to indi-
vidual objects with the corresponding locations in the source
code. They are available through a pop-up window like the
one in Fig. 3 activated by clicking on the XMLAttribute node
in the right-hand side of the instance in Fig. 2 (a).
3.1.2 Visualisation of Generalised Rules
Fig. 2 (b) shows how generalised rules are displayed. The
top left shows a list of all rules organised by their operation
signatures. When selecting, e.g., a maximal rule, all its con-
stituting contract instances will appear in the table, see the
top right of (b). The lower part shows the maximal rule for
XMLElement.addChildren(IXMLElement[]) .
An example of a rule with multi-object is shown in Fig. 4
as extracted from the maximal rule in Fig. 2 (b). Here,
one of the nodes of type XMLElement represents a multi-
object (shown with a 3D shadow). The rule allows to add an
arbitrary amount of XMLElement nodes as child of another
XMLElement , all the children being indexed by a Vector .
Figure 4: A generalised rule with multi-object.
3.1.3 Export to Henshin
Figure 5 shows the generalised rules extracted from our
experiments with NanoXML exported into the format of
the model and graph transformation framework Henshin [4].
In particular, a maximal rule extracted for operation add-
Child(..) is depicted in the visual syntax of the Henshin
transformation language. In general, this notation shows
transformation rules in an integrated form, the left- and
right-hand sides of a rule merged into a single graph. The
left-hand side (LHS) comprises all model elements stereo-
Figure 5: Export of generalised rules to Henshin.
typed by delete andpreserve , the right-hand side (RHS) con-
tains all model elements annotated by preserve andcreate .
The integration with Henshin allows i)to evaluate and ex-
ecute extracted contracts, and ii)to use the tool more widely
in the context of model-based engineering (see Sect. 4).
3.2 JHotDraw
For experimenting with JHotDraw, we use version 5.3
which has 243 classes. Concerning the tracing instrumen-
tation, we select all 243 classes to dene the scope of object
types, focusing on the top level methods for the manipula-
tion of drawings, such as *.addFigure(..) ,*.DeleteFigure(..) ,
*.copyFigure(..) ,*.DecoratorFigure(..) and all undoable ac-
tions in *.CommandMenu.actionPerformed(comExe) . We
use the GUI testing tool WindowTester4to generate test
cases by recording user interactions.
3.2.1 SimpliÔ¨Åcation of Complex Contract Instances
The VCE tool provides visualisation options that may
be employed to view complex contracts. As an example,
consider Fig. 6 which shows a very complex contract in-
stance, extracted from an invocation of DeleteFigure(..) af-
ter analysing 21429 objects. Details are shown in the upper
part of (a), and (b) gives an impression of the overall size
of the LHS (best viewed with maximal zoom). For better
understanding, such contract instances can be generalised
by inferring a rule with multi-objects and by just displaying
minimal elements, i.e., hiding context elements that have
no eects. As illustrated by the selective display shown in
Fig. 6 (c), which has been automatically generated by the
tool upon request, complexity can be reduced signicantly.
3.2.2 Rules with Attribute Conditions
Fig. 7 shows a maximal rule with inferred attribute con-
ditions extracted from addFigure(..) . Attribute conditions
are shown in a separate dialogue window for selected nodes.
For example, the 4th constraint in the popup window for
the selected LHS node of type BouncingDrawing states that
the value of its attribute theQuadTee must remain with no
change in the post graph: N12661L_Pre_theQuadTree ==
N12661R_Post_theQuadTree .
4. FURTHER APPLICATIONS
In the previous section, we illustrated how our tool can be
used to aid program understanding. Moreover, the integra-
tion with Henshin, turning visual contracts into executable
4https://developers.google.com/java-dev-tools/wintester
819(a)Large contract instance with trace information
(b)
LHS
(c)Selective display of a generalised rule
Figure 6: Large contract instance and generalised
rule extracted from DeleteFigure(..) .
transformation rules, allows us to evaluate and apply con-
tracts more widely, e.g. as proposed in the context of model-
based testing [16, 21].
In this section, we briey sketch two novel usage scenarios.
In Sect. 4.1, we discuss the usage of dynamically extracted
visual contracts for a new debugging paradigm which can
be considered as visual or model-based debugging. Sect. 4.2
proposes an approach to generate complex model editing
operations automatically from examples.
4.1 Visual Debugging
Traditional debugging, as supported by an IDE such as
Eclipse, allows programmers to interactively inspect and
trace the dynamic behaviour of a program. It requires to de-
ne, in advance, breakpoints to hold execution at a certain
point, allowing to observe and investigate accessed objects,
variables and their actual values. To apply this technique
for tasks such as localising faults, it needs sucient precision
in identifying breakpoints, which may be an intricate task.
Dening many breakpoints or a breakpoint inside a loop is
usually not practical, as it may lead to either stopping the
execution many times or observing similar details with mi-
nor dierences at each stop. In the worst case, programmers
single-step through instructions and observe changes to the
program state.
Using extracted visual contract instances can serve as an
alternative approach which can be considered as visual de-
bugging . The idea is to exploit the debugging interface pro-
vided by the Java Virtual Machine to generate program
snapshots which can be visually inspected. This raises the
level of abstraction from implementation-based debugging
to model-based debugging. Accompanying trace informa-
tion nally helps to localise faults in the source code.
The advantages of debugging at the model-level have been
discussed in the literature, e.g. in [28]. Existing approaches,
Figure 7: A rule with attribute conditions.
however, mainly focus on debugger frameworks for dedicated
domain-specic languages and are not applicable to main-
stream Java programs. The monitoring approach presented
in [14] shares similarities with our idea, but we plan to inves-
tigate the usability and scalability of using visual contract
instances as an IDE plug-in for debugging.
4.2 Learning Model Editing Operations
Complex editing operations such as model refactorings
are a valuable conguration parameter for many tools in
Model-driven Engineering (MDE), e.g. to continuously im-
prove model quality using refactoring tools [5], or to describe
the changes between two versions of a model in a meaningful
way [18, 9]. However, MDE platforms such as the Eclipse
Modeling Frameworkoer only a generic low-level API for
model modication. Likewise, editing operations generated
from meta-models, e.g. as proposed in [20, 19], are still prim-
itive. Complex operations can be implemented manually or
by specifying their eect as a model transformation. Both
approaches require a deep understanding of the meta-model
and its relation to the concrete syntax, thus being only ac-
cessible to tool developers and language designers.
Our approach can be used to learn complex editing op-
erations automatically from examples specied by domain
experts. An example of a complex editing operation, i.e. the
model states before and after a model refactoring, can be
specied using standard model editors. Example models are
transformed into the graph representation of the VCE tool,
generalised to transformation rules and nally exported to
Henshin. The exported transformation rules can be inte-
grated as complex editing operations in model editors.
In contrast to previous \model transformation by exam-
ple" proposals requiring manual processing or augmentation
of generated operations at the abstract syntax level [17], our
aim is to stick entirely to the concrete syntax notation do-
main experts are familiar with.
5. RELATED WORK
To the best of our knowledge, the work presented in this
paper is the rst that presents an integrated tool for inferring
visual contracts with advanced transformation rule features
from system's operations. From a broader perspective, tools
comparable to ours can be found in the wide eld of reverse
engineering. Among them, we particularly have to mention
tools for extracting models from implementation artefacts,
e.g. reverse engineering of UML sequence diagrams [30], ac-
tivity diagrams [26], entity data models from databases [24],
or graph grammars based on call graphs [29].
Technically, the generalisation of contract instances is re-
lated to the task of semi-automatically learning rules from
model transformations [17]. We go ahead by supporting in-
820ference of advanced rule features such as multi-objects and
attribute conditions. Moreover, we support a fully auto-
mated inference of transformation rules, while the process
presented in [17] relies on manual interventions, e.g. to adapt
inferred pre- and post-conditions.
Approaches for inferring invariants have been considered
in component-based verication [25] and software testing,
e.g. to address the test oracle problem [7] or to generate
logical test inputs [6]. We share with them the technique of
using dynamic invariant detection by Daikon [13].
6. CONCLUSION AND FUTURE WORK
The main contribution of this paper is an integrated tool
supporting the extraction and inference of visual contracts
from Java applications. It provides a rich front-end visu-
aliser for selectively displaying and browsing inferred rules
and is integrated with the model transformation tool Hen-
shin in order to generate executable contracts.
We illustrated how the tool supports the construction of
concise and comprehensive rules and how this can aid pro-
gram understanding in testing or maintenance scenarios. Fi-
nally, we discussed two novel applications of our tool in the
broader eld of model-based engineering, paving the way for
two directions of future work. Firstly, we intend to use con-
tract extraction to support visual debugging, evaluating its
eectiveness more comprehensively. Secondly, we will use
our tool for learning of complex domain-specic model edit-
ing operations. We believe that this technology can unlock
the potential for end-user customisation of model editors.
7. REFERENCES
[1] A. Alshanqiti and R. Heckel. Extracting visual contracts
from java programs. In Proc. 30th Intl. Conf. on Automated
Software Engineering , pages 104{114. IEEE, 2015.
[2] A. M. Alshanqiti and R. Heckel. Towards dynamic reverse
engineering visual contracts from java. Electronic
Communications of the EASST , 67, 2014.
[3] A. M. Alshanqiti, R. Heckel, and T. Khan. Learning
minimal and maximal rules from observations of graph
transformations. Electronic Communications of the
EASST , 58, 2013.
[4] T. Arendt, E. Biermann, S. Jurack, C. Krause, and
G. Taentzer. Henshin: Advanced concepts and tools for
in-place EMF model transformations. In Proc. 13th Intl.
Conf. on Model Driven Engineering Languages and
Systems , pages 121{135, 2010.
[5] T. Arendt and G. Taentzer. A tool environment for quality
assurance based on the eclipse modeling framework.
Automated Software Engineering , 20(2):141{184, 2013.
[6] S. Artzi, M. D. Ernst, A. Kie_ zun, C. Pacheco, and J. H.
Perkins. Finding the needles in the haystack: Generating
legal test inputs for object-oriented programs. In Proc. 1st
Workshop on Model-Based Testing and Object-Oriented
Systems , 2006.
[7] E. T. Barr, M. Harman, P. McMinn, M. Shahbaz, and
S. Yoo. The oracle problem in software testing: A survey.
IEEE Trans. Software Eng. , 41(5):507{525, May 2015.
[8] L. C. Briand, Y. Labiche, and J. Leduc. Toward the reverse
engineering of UML sequence diagrams for distributed java
software. IEEE Trans. Software Eng. , 32(9):642{663, 2006.
[9] J. B urdek, T. Kehrer, M. Lochau, D. Reuling, U. Kelter,
and A. Sch urr. Reasoning about product-line evolution
using complex feature model dierences. Automated
Software Engineering , pages 1{47, 2015.
[10] F. Dotti, L. Ribeiro, O. Santos, and F. Pasini. Verifying
object-based graph grammars. SoSyM , 5(3):289{311, 2006.[11] H. Ehrig, K. Ehrig, U. Prange, and G. Taentzer.
Fundamentals of Algebraic Graph Transformation .
Springer, 2006.
[12] G. Engels, M. Lohmann, S. Sauer, and R. Heckel.
Model-driven monitoring: An application of graph
transformation for design by contract. In Proc. 3rd Intl.
Conf. on Graph Transformations , pages 336{350, 2006.
[13] M. D. Ernst, J. H. Perkins, P. J. Guo, S. McCamant,
C. Pacheco, M. S. Tschantz, and C. Xiao. The daikon
system for dynamic detection of likely invariants. Science of
Computer Programming , 69(1-3):35 { 45, 2007.
[14] L. Hamann, O. Hofrichter, and M. Gogolla. Ocl-based
runtime monitoring of applications with protocol state
machines. In Proc. 8th European conference on Modelling
foundations and applications , pages 384{399, 2012.
[15] R. Heckel. Graph transformation in a nutshell. Electronic
notes in theoretical computer science , 148(1):187{198, 2006.
[16] R. Heckel and M. Lohmann. Towards contract-based
testing of web services. Electronic Notes in Theoretical
Computer Science , 116:145 { 156, 2005.
[17] G. Kappel, P. Langer, W. Retschitzegger, W. Schwinger,
and M. Wimmer. Model transformation by-example: a
survey of the rst wave. In Conceptual Modelling and Its
Theoretical Foundations , pages 197{215. Springer, 2012.
[18] T. Kehrer, U. Kelter, and G. Taentzer. A rule-based
approach to the semantic lifting of model dierences in the
context of model versioning. In 26th Intl. Conf. on
Automated Software Engineering , pages 163{172, 2011.
[19] T. Kehrer, M. Rindt, P. Pietsch, and U. Kelter. Generating
edit operations for proled UML models. In Proc. Intl.
Workshop on Models and Evolution , volume 1090 of CEUR
Workshop Proceedings , pages 30{39, 2013.
[20] T. Kehrer, G. Taentzer, M. Rindt, and U. Kelter.
Automatically deriving the specication of model editing
operations from meta-models. In Proc. 9th Intl. Conf. on
Model Transformations , pages 173{188. Springer, 2016.
[21] T. A. Khan, O. Runge, and R. Heckel. Testing against
visual contracts: Model-based coverage. In Proc. Intl. Conf.
on Graph Transformation , pages 279{293, 2012.
[22] G. Kiczales, E. Hilsdale, J. Hugunin, M. Kersten, J. Palm,
and W. G. Griswold. An overview of aspectj. In Proc. 15th
European Conf. on Object-Oriented Programming , pages
327{354. Springer, 2001.
[23] M. Lohmann, S. Sauer, and G. Engels. Executable visual
contracts. In IEEE Symposium on Visual Languages and
Human-Centric Computing , pages 63{70, 2005.
[24] A. Malpani, P. Bernstein, S. Melnik, and J. Terwilliger.
Reverse engineering models from databases to bootstrap
application development. In Proc. 26th Intl. Conf. on Data
Engineering , pages 1177{1180, 2010.
[25] L. Mariani and M. Pezz e. A technique for verifying
component-based software. Electr. Notes Theor. Comput.
Sci., 116:17{30, 2005.
[26] L. Martinez, C. Pereira, and L. Favre. Recovering activity
diagrams from object oriented code: an mda-based
approach. In Proc. Intl. Conf. on Software Engineering
Research and Practice , volume 1, pages 58{64, 2011.
[27] B. Meyer. Applying "design by contract". Computer ,
25(10):40{51, 1992.
[28] D. Pavletic, M. Voelter, S. A. Raza, B. Kolb, and
T. Kehrer. Extensible debugger framework for extensible
languages. In Reliable Software Technologies{Ada-Europe
2015, pages 33{49. Springer, 2015.
[29] C. Zhao, J. Kong, and K. Zhang. Program behavior
discovery and verication: A graph grammar approach.
IEEE Trans. Software Eng. , 36(3):431{448, 2010.
[30] T. Ziadi, M. A. A. Da Silva, L. M. Hillah, and M. Ziane. A
fully dynamic approach to the reverse engineering of UML
sequence diagrams. In Proc. Intl. Conf. on Engineering of
Complex Computer Systems , pages 107{116, 2011.
821