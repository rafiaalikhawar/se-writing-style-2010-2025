IntPTI: Automatic Integer Error Repair with
Proper-Type Inference
Xi Cheng∗, Min Zhou∗, Xiaoyu Song†, Ming Gu∗, Jiaguang Sun∗
∗School of Software, TNLIST, KLISS, Tsinghua University, China
†Electrical and Computer Engineering, Portland State University, USA
chengxi13@mails.tsinghua.edu.cn, {mzhou,guming,sunjg}@tsinghua.edu.cn, song@ece.pdx.edu
Abstract —Integer errors in C/C++ are caused by arithmetic
operations yielding results which are unrepresentable in certain
type. They can lead to serious safety and security issues. Due
to the complicated semantics of C/C++ integers, integer errors
are widely harbored in real-world programs and it is error-
prone to repair them even for experts. An automatic tool isdesired to 1) automatically generate ﬁxes which assist developers
to correct the buggy code, and 2) provide sufﬁcient hints to
help developers review the generated ﬁxes and better understand
integer types in C/C++. In this paper, we present a tool IntPTI
that implements the desired functionalities for C programs.IntPTI infers appropriate types for variables and expressions
to eliminate representation issues, and then utilizes the derived
types with ﬁx patterns codiﬁed from the successful human-written
patches. IntPTI provides a user-friendly web interface which
allows users to review and manage the ﬁxes. We evaluate IntPTI
on 7 real-world projects and the results show its competitive
repair accuracy and its scalability on large code bases. The demovideo for IntPTI is available at: https://youtu.be/9Tgd4A_FgZM.
Index T erms—integer error, type inference, ﬁx pattern
I. I NTRODUCTION
In C/C++ programs, integer arithmetic operations (e.g.
addition and assignment) may produce results that the certain
expression type cannot represent, and such values are conver-ted somehow to ﬁt the target type. Some conversions are well-deﬁned (e.g. unsigned wraparound) by the language standardbut others are undeﬁned (e.g. signed overﬂow). Integer errorsare generally caused by misuse of well-deﬁned conversions orundeﬁned behaviors due to developer’s empirical certainty ofexpected outcomes. Integer error is known to be one of themain threats to the safety and security of software system. Apotential total power loss in Boeing 787 Dreamliners [1] wascaused by the signed overﬂow of a 32-bit counter. Multipleinteger errors in Linux kernel can be exploited for denial-of-service attacks [2] or privilege escalations [3]. A CVE reportin 2007 [4] suggests that integer overﬂow error is the secondmost common vulnerability in the advisories for OS vendor.
Challenge. It is error-prone to correctly repair integer errors
even for experts due to the complicated semantics of integersin C/C++. The machine representation of an integer is a ﬁxed-size bit-vector restricted by its type-speciﬁc characteristics:
signedness and width. Generally, the semantics over ﬁxed-size
bit-vectors and Zare inconsistent. For example, (x−y>
0)⇐⇒(x>y)holds over Z, but no longer holds over ﬁxed-
size bit-vectors owing to the overﬂow in x−y. Even worse,
not all integer arithmetic operations are well-deﬁned. Althoughundeﬁnedness grants compilers freedom to generate efﬁcientcode by exploiting speciﬁc properties of a certain instructionset, it could lead to unexpected runtime behaviors acrossdifferent architectures or optimization levels. For example, anoverﬂow in signed addition silently wraparounds on x86 buttraps on MIPS [5].
Related Work. Numerous automatic solutions for integer
errors have been proposed, but they have various limitationsin real-world applicability. One thread of the related workfocuses on integer error detection by symbolic execution [6],[7], [8], static analysis [9] or code instrumentation [10], [11],[12]. These tools produce reports on where integer errors areand how to trigger them, but they are unable to guide deve-lopers to correct the buggy implementation. Generic programrepair techniques are proposed to automatically correct theimplementation with its speciﬁcations. They generate patchesthat address certain defects by, typically, validating heuristi-cally generated patches with test suites [13], [14], [15], [16],
[17], [18], or synthesizing desired expressions with respect to
constraints derived from test suites [19], [20], [21], [17]. Theeffectiveness of these tools, however, heavily relies on speciﬁ-
cations which are often insufﬁcient in practice. Moreover, even
the state-of-the-art generate-and-validate systems do not scaleto large software systems with thousands of potential defects
as they generally require hours to ﬁnd a plausible patch for
one real-world bug. Some tools are designed for integer errorsspeciﬁcally [22], [23]. They transform the internal integer
model of a program towards a safer model but an excessive
number of unnecessary changes are made in the program.
Approach. We present IntPTI, an automatic tool that ge-
nerates and applies ﬁxes for integer errors in C programs. It
aims to assist developers and testers to improve code qualityagainst integer errors. First, IntPTI preprocesses the source
ﬁles on the ﬂy in the building process. Next, IntPTI computes
the appropriate types (i.e. proper-types) for variables and
expressions to eliminate representation issues and generates
ﬁxes by utilizing proper-types. Then, users interact with IntPTI
via a web interface to review ﬁxes. Finally, accepted ﬁxes arecollected and applied to the source code. Users can beneﬁtfrom IntPTI as it proposes ﬁxes for possible integer errors
with proper explanations, which helps users to (1) locate the
new integer errors in code and repair them correctly, (2) better
understand the integer types in C language.
Our key approach is proper-type inference, which ﬁnds
appropriate types for expressions and variables such that each
expression has the type that covers all its possible values.
The goal of proper-type inference is achieved by static value
analysis (§II-B, which approximates possible values of ex-
978-1-5386-2684-9/17/$31.00 c/circlecopyrt2017 IEEEASE 2017, Urbana-Champaign, IL, USA
T ool Demonstrations996
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:31:33 UTC from IEEE Xplore.  Restrictions apply. τ::=ς|τ∗|void|struct{τc1;...τcn}|τ(τ,...τ)
e::=n|x|e.c|e♦e|(τ)e|∗e|&e|e:=e|f(e,...e)
Fig. 1. The core language syntax.
pressions) and type inference (§II-A, which computes types
for expressions and variables with respect to the proper-typeproperty and the well-typedness of program). Inferred typesare utilized to generate ﬁxes (§II-C) by common ﬁx patternscodiﬁed from the real world: sanity check, explicit type castingand declared type changing. For the scalability in real-world
projects, IntPTI adopts multi-entry analysis (§II-D) to run
proper-type inference in the compositional manner.
To demonstrate the accuracy and runtime efﬁciency of
IntPTI, we apply it to 7 widely-used open-source projects withknown integer vulnerabilities. The results show that IntPTI
succeeds in repairing 23 out of 25 defects. Furthermore, IntPTI
substantially addresses the limitations of existing tools as it: 1)
does not rely on speciﬁcations such as test suites, 2) generatesﬁxes with proper explanations of why the ﬁx is generatedand how it transforms the code, 3) reduces false-positives(i.e. ﬁxes that correspond to no genuine bugs) on the critical
program sites (where attacks are typically performed on the
subject programs) by 93.3% compared to the state-of-the-artapproach [22], and 4) scales to large code bases as it spends
no more than 11 minutes on Vim with over 244 KLOC.
Contribution. Main contributions are summarized as:
1) We propose a novel approach that automatically generates
ﬁxes under appropriate patterns via type inference.
2) We implement our approach as a tool IntPTI.I ti sd e -
signed for complex realistic C code bases and provides auser-friendly interface for users who are unfamiliar withprogram analysis techniques.
3) We evaluate IntPTI on 7 open-source projects. The results
show its competitive repair accuracy and runtime efﬁciency,
which substantiates that our tool is of practical concern.
II. A
PPROACH OVERVIEW
Generally, IntPTI repairs C integer errors by three main
steps: 1) static value analysis, 2) proper-type inference and3) ﬁx generation. For the scalability of IntPTI, multi-entry
analysis is employed to divide-and-conquer the ﬁx generationtask on the whole program.
A. Proper-Type Inference
We present a C-like kernel language shown in Fig. 1 to
formalize our discussion. The language models expressions
including integer literals, variables, structure members, binaryexpressions (the operator ♦can be arithmetic or logical),
cast expressions, pointer dereferences, address-of expressions,
assignments and library calls. There can be multiple kinds
of integer types varying on length and/or signedness. Each
expression has a type which can be integer type (ς ), pointer
type, structured type and function type. A program consists of
variable declarations and expressions. Let /llbracket·/rrbracket:E→2
Zmap
an expression to its possible values and /llparenthesis·/rrparenthesis:T→2Zmap
a type to values that it can represent. We say that τis the
proper-type of an arithmetic expression eif/llbrackete/rrbracket⊆/llparenthesisτ/rrparenthesis.To derive proper-types, we scan the program and collect
constraints on the types of expressions and variables by proper-type inference rules. All non-arithmetic expressions keep theiroriginal types. Rules for arithmetic expressions are listed inFig. 2. The type judgment Γ,Θ,Υ/turnstilelefte:τ/mapsto→Cdenotes that
given the context (Γ,Θ,Υ), the type of eis inferred as τalong
with the constraint set C. The context consists of the typing
hypothesis Γwhich maps variables to their declared types, Θ
that assigns arithmetic expressions with their enforced types,
andΥ=( /llbracket·/rrbracket,/llparenthesis·/rrparenthesis)where the former is computed by value
analysis (§II-B) and the latter is given by C language datamodel (e.g. data type width schemes, including LP32, ILP32,LP64, etc.) in use. The notation ς
1/precedesequalς2denotes that the byte
length of ς2is no less than that of ς1(namelyς2elevatesς1).
Emaps expressions to their original types.
We give brief explanations for some rules. In the B INARY -
ARITH rule, the type ςis required to 1) be eligible to represent
possible values of e1♦e2, 2) be the common type of ς1andς2
(namelyς1↑ς2) to preserve well-typedness. In the B INARY -
LOGICAL rule, however, operands of logical operation are
enforced to have their common type in order to prevent 1)implicit conversion in comparison and 2) overﬂow bug in eachoperand. The A
SSIGN -VAR rule elevates the declared type of
the variable to be assigned with respect to the right operand,while the A
SSIGN -N ONVAR rule enforces the non-variable
L-value to have its original type. In the L IBRARY -CALL rule,
argument expression is enforced to ﬁt its parameter type. Theoperand of an address-of operation keeps its original type toprevent memory issues after repair.
The collected constraints need further processing. First, for
each arithmetic variable xwe add a constraint D(x)/precedesequalΓ(x)
denoting that the new type of xelevates its original type
(whereDmaps variables to their original declared types).
Second, constraints of value inclusion such as n∈/llparenthesisς/rrparenthesisand
/llbrackete/rrbracket⊆/llparenthesisς
/prime/rrparenthesisare allowed to be violated with penalty wvsince
built-in integer types can only represent a limited range of inte-gers. Third, for each type elevation constraint ς
1/precedesequalς2,w ea d d
a matching equality constraint ς1=ς2with violation penalty
wpto minimize changes on types. Generally, wvshould be
substantially larger than wpto not overshadow necessary type
elevations. The conjunction of processed constraints is a partial
weighted MaxSMT problem [24]. A MaxSMT solver such asZ3 [25] ﬁnds a solution that satisﬁes all hard constraints (i.e.
ones with no penalties) while minimizing the total penaltyof violated constraints (albeit a local minima is derived in
general), or reports unsatisﬁable otherwise. There alwaysexists a solution Isuch that I(Γ) =D,I(Θ)(e)=E(e)
andI(ς
e)=E(e)whereςeis the type variable for e.
B. Static V alue Analysis
Static value analysis approximates values of expressions and
gives /llbracket·/rrbracketfor proper-type inference. Three analyses are mainly
used: interval analysis (which captures lower and upper boundsof expressions), pointer analysis (which analyzes points-torelations) and reaching deﬁnition analysis (which builds use-
def chains). Analyses share the derived information to achievebetter precision. For example, points-to relations are exploited
to approximate pointer dereferences more precisely. In interval
analysis, we extend the basic interval arithmetic [26] by 1)
997
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:31:33 UTC from IEEE Xplore.  Restrictions apply. VAR
Γ,Θ,Υ/turnstileleftx:ς/mapsto→{Γ(x)/precedesequalς}CONST
Γ,Θ,Υ/turnstileleftn:ς/mapsto→{n∈/llparenthesisς/rrparenthesis,E(n)/precedesequalς}BINARY -A RITH
Γ,Θ,Υ/turnstilelefte1:ς1/mapsto→C1Γ,Θ,Υ/turnstilelefte2:ς2/mapsto→C2♦is an arithmetic operator
Γ,Θ,Υ/turnstilelefte1♦e2:ς/mapsto→C1∪C2∪{/llbrackete1♦e2/rrbracket⊆/llparenthesisς/rrparenthesis,ς1↑ς2=ς}
BINARY -LOGICAL
Γ,Θ,Υ/turnstilelefte1:ς1/mapsto→C1Γ,Θ,Υ/turnstilelefte2:ς2/mapsto→C2♦is a logical operator
Γ,Θ,Υ/turnstilelefte1♦e2:ς/mapsto→C1∪C2∪{ς=E(e1♦e2),ς/prime=ς1↑ς2,/llbrackete1/rrbracket/negationslash⊆/llparenthesisς/prime/rrparenthesis⇐⇒Θ(e1)=ς/prime,/llbrackete2/rrbracket/negationslash⊆/llparenthesisς/prime/rrparenthesis⇐⇒Θ(e2)=ς/prime}
ASSIGN -VAR
x:=eΓ,Θ,Υ/turnstilelefte:ς/mapsto→C
Γ,Θ,Υ/turnstileleftx:ς/prime/mapsto→C∪{Γ(x)=ς/prime,/llbrackete/rrbracket⊆/llparenthesisς/prime/rrparenthesis}ASSIGN -N ONVAR
e1:=e2Γ,Θ,Υ/turnstilelefte2:ς/mapsto→Ce 1is not a variable
Γ,Θ,Υ/turnstilelefte1:ς/prime/mapsto→C∪{ς/prime=E(e1),/llbrackete2/rrbracket/negationslash⊆/llparenthesisς/prime/rrparenthesis⇐⇒Θ(e2)=ς/prime}
DEREF
Γ,Θ,Υ/turnstilelefte:ς1∗ /mapsto→C
Γ,Θ,Υ/turnstileleft∗e:ς2/mapsto→C∪{ς1/precedesequalς2}ADDRESS -O F
Γ,Θ,Υ/turnstilelefte:ς/mapsto→C
Γ,Θ,Υ/turnstileleft&e:ς∗ /mapsto→C∪{ς=E(e)}LIBRARY -CALL
Γ,Θ,Υ/turnstileleftf:τ(ς)/mapsto→C0Γ,Θ,Υ/turnstilelefte:ς/prime/mapsto→C1
Γ,Θ,Υ/turnstileleftf(e):τ/mapsto→C0∪C1∪{/llbrackete/rrbracket/negationslash⊆/llparenthesisς/rrparenthesis⇐⇒Θ(e)= ς}
Fig. 2. Rules of proper-type inference.
T ABLE I
THE DISTRIBUTION OF FIX PA TTERNS FOR CVE BUGS .
Pattern SC ETC DTC ET OTHER id
Count 486 42 75 56 28 668
implementing semantics of library calls relevant to numerical
operations such as abs, and 2) reﬁning intervals with respect
to path conditions and the use-def chain. Pointer analysis is
based on Andersen’s algorithm [27] and reaching deﬁnitionanalysis is based on classical data-ﬂow analysis [28].
C. Repair Generation
A case study is conducted on 668 selected CVE identiﬁers
as they contain sufﬁcient information on buggy code, security
impacts and upstream ﬁxes. They come from 210 differentapplications ranging from 2001 to 2017. We identify recurringsimilar patches (i.e. ﬁx patterns) and summarize them in TableI. The total occurrence of patterns is larger than the numberof identiﬁers because some contain multiple patterns. Thereare totally four common patterns. Sanity check (SC, 72.8%)guards a critical operation against erroneous values. Explicittype casting (ETC, 6.3%) enforces the type of an expression.Declared type changing (DTC, 11.2%) adjusts the declaredtype for a variable. Expression transformation (ET, 8.4%)rewrites an expression as an equivalent form under integerarithmetic, such as transforming x+y<8tox<8−y. Only
4.2% of ﬁxes have no common patterns. From the perspectiveof repair mechanism, SC restricts the expression to haverepresentable values while ETC and DTC elevate the precisionof expression and variable, respectively. ET can be reduced to
the combination of ETC and DTC since it is a workaround
to prevent overﬂow without adjusting the precision. Hence,proper-types are utilized to generate SC, ETC and DTC ﬁxes.
LetIbe the derived solution of proper-type constraints and
Fbe the set of candidate ﬁxes. We have 1) F
DTC
ς(x)∈F iff
I(Γ)(x)=ς /negationslash=D(x);2 )FSC
ς(e)∈F for(e,ς)∈I(Θ);3 )
FETC
ς(e)∈F iffI(ςe)=ς/negationslash=E(e). The notation F(e)is used
to collectively denote a SC ﬁx or an ETC ﬁx on e. We deﬁne
the dependency relation /triangleleftoverF, such that 1) F(e1)/triangleleftF(e2)
iffe1is a descendant of e2in the AST; 2) FETC
∗(e)/triangleleftFSC
∗(e);
3)FDTC
∗(x)/triangleleftFETC
∗(x).F1/triangleleftF2implies that the application
result of F2depends on that of F1.M(FETCς(e1♦e2)) = M(FETCς(e1))♦M(FETCς(e2))
M(FETCς((ς/prime)e)) = (ς )e
M(FETCς(e)) = (ς )e
M(FSCς(e1♦e2)) = check♦
ς(M(FSCς(e1),M(FSCς(e2)))
M(FSCς(e)) =/braceleftbigg
checkς(e)ς/precedesequalΣ(e)∧ς/negationslash=Σ (e)
e otherwise
Fig. 3. The expression transformation function M.
To apply the candidate ﬁxes in F, we iteratively choose a
ﬁxFthat depends on no other ﬁxes in Fand remove it from
F.I fFis a DTC ﬁx, we change the certain declared type;
otherwise, Fis applied by expression transformation function
M shown in Fig. 3 which lists the expression transformation
schemes ordered by the priority of application. Note that SC
ﬁxes can introduce two kinds of check functions: 1) conversioncheck check
ς(n) that returns niff it is representable in ς,
2) arithmetic check check♦
ς(n1,n2)that returns the result of
n1♦n2in mathematical arithmetic iff it is representable in ς.
D. Multi-entry Analysis
The scalability of our approach is restricted by static ana-
lysis and the capability of solver on complicated constraints.
To make our approach scale to large code bases, we adopt
multi-entry analysis to divide-and-conquer the whole-programreasoning. Firstly, the code base is decomposed into multiple
call graph components, each of which has an entry function
from which other functions in the component are reachable
by function calls. Next, we perform proper-type inference on
each component starting from its entry and then combine
their results. To guarantee the compatibility of sub-results,we enforce variables spanning multiple scopes (e.g. global
variables) to keep their original types. Furthermore, to reducethe precision loss brought by compositional analysis, weperform a function-wise pre-analysis to derive 1) function callcontext, 2) function and loop summary and 3) loop invariant.They are all based on interval abstract domain.
III. I
MPLEMENT A TION
The architecture of IntPTI is shown in Fig. 4. Given a
C project, IntPTI ﬁrstly preprocesses it and constructs its
control-ﬂows for analysis. Next, IntPTI approximates values
of expressions and collects proper-type constraints by running
bounded CPA algorithm with several analyses. Candidate
998
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:31:33 UTC from IEEE Xplore.  Restrictions apply. ,QW37,
&SURMHFWSUHSURFHVV
UHSDLUHG
FRGHFRQWURO
IORZEXLOGERXQGHG
&3$FDQGLGDWH
IL[HVSURSHUW\SH
LQIHUHQFH
IL[LQIR
VHULDOL]DWLRQIL[LQIR
VWRUHDFFHSWHG
IL[HVIL[
DSSOLFDWLRQ
ZHELQWHUIDFH
XVHUIL[UHYLHZORFDOVHUYHU
Fig. 4. The architecture of IntPTI.
ﬁxes are derived by solving the proper-type constraints using
Z3 [25]. Then, IntPTI starts a web interface for users to review
candidate ﬁxes. Finally, IntPTI transforms the code to apply
accepted ﬁxes.
Preprocessing. First, the compilation commands in Makefile
are captured by invocation order. Next, source ﬁles are prepro-
cessed by, in the case that the compiler in use is gcc, adding
the-Eﬂag to make the compiler stop after preprocessing and
replacing the output *.o ﬁles by the corresponding *.i ﬁles
which are self-contained source ﬁles with macros expandedand necessary declarations included. The *.i ﬁles compiled
into an executable or a library are organized as a task.
Bounded CPA algorithm. The static analysis algorithm used
inIntPTI is extended from CPA algorithm [29] for multi-entry
analysis. When the analysis reaches the boundary of currentcall graph component or maximum loop iteration or maximumloop nesting level, we summarize the upcoming functionor loop. The algorithm runs multiple analysis componentsincluding but not limited to the three main analyses. Eachanalysis is implemented under the CPA framework [29].
Syntactic elements of the standard C language need to be
handled carefully. Bitwise shift operations are approximatedcarefully for possible intentional wraparounds. For example,a left shift of an unsigned integer is always representablein its type as this kind of wraparound is usually served formodulo operation. The possible targets of a function pointerare derived by combining pointer analysis with type matching.If no targets can be found, certain function call is treated asa library call without implemented semantics. Type enforce-ments are imposed on critical program sites including functionarguments, array indexes, return values and the operands ofcondition expressions. Furthermore, memory regions allocatedby*alloc family are treated as arrays whose identiﬁers have
the [*alloc]-[line number ] format.
The heuristic for call graph decomposition in multi-entry
analysis is conﬁgurable by specifying the maximum levels ofcall stack, loop unrolling and loop nesting in the conﬁguration.
Proper-type inference. Proper-type constraints are encoded
under an extended SMT-LIB 2.0 format [30] over quantiﬁer-
free equality logic with uninterpreted functions [31]. Morespeciﬁcally, we use the declare-datatype command to
deﬁne an enumeration Iof integer types plus a dummy
typeOVERLONG which can represent every value in Z,
declare-fun commands to deﬁne a binary function over Ito
model↑, two binary predicates P,QoverIwherePmodels the{"UUID":"536335ff-f0a9-4b6b-aca0-358606f1fe9e","mode":"CAST","type":
"long int","startLine":3060,"endLine":3060,"startOffset":22,"
endOffset":23,"_defect":"overflow","_ary":2,"_op1":"i","_op2":"
o","_optr":"+","_sign":1,"children":[]}
Fig. 5. An example of a serialized ﬁx.
Fig. 6. The web interface for ﬁx review.
containment relation over /llparenthesisT/rrparenthesisandQmodels/precedesequal, and variables
(also0-ary functions) over Iencoding type variables such as ς,
Γ(x)andΘ(e)./llbrackete/rrbracketis encoded as the corresponding value of ς
inIwhereςis the type with the shortest byte length such that
/llbrackete/rrbracket∈/llparenthesisς/rrparenthesis,o rOVERLONG if suchςdoes not exist. /llparenthesisς/rrparenthesisis encoded
as the corresponding value of ςinI. We assert additional
constraints such that every type variable is prohibited to be
OVERLONG. To add a constraint with violation penalty w,w e
use the command (assert-soft [formula] :weight w)
and for others (without violation penalty), the assert com-
mand is used. Penalty values wpandwvcan be conﬁgured
by users and their default values are 1and100, respectively,
based on pilot experiments.
Fix info serialization. The candidate ﬁxes are serialized as
JSON data to be interchanged across a local server and web
interface. Fig. 5 shows a serialized ﬁx. The JSON objectfor a ﬁx stores its UUID, its mode ("SPECIFIER" for DTC,
"CAST" for ETC,"CHECK_ARITH" for arithmetic check and
"CHECK_CONV" for conversion check), its speciﬁed type, the
location of target code characterized by line number and offset,and the ﬁxes depending on the current ﬁx (as the value of"children"). Keys starting with “_” are mode-speciﬁc ﬁelds
providing more details on this ﬁx. For example, the reason forthe ﬁx shown in Fig. 5 is as follows: there is an overﬂow issueon the signed addition of iando.
Web interface. End users review candidate ﬁxes via the web
interface shown in Fig. 6. The ﬁle explorer ( 3/circlecopyrt) lists source
ﬁles of the current project. When a user selects a ﬁle, the code
viewer ( 5/circlecopyrt) displays its contents while the relevant candidate
ﬁxes are loaded in the ﬁx list ( 6/circlecopyrt). Indentions are used to
visualize the dependency relations over ﬁxes. The user canaccept or reject a ﬁx by toggling its button. For two ﬁxesF
1andF2such that F1/triangleleftF2, the interface enforces that F2
is toggled on only if F1is toggled on. By selecting a ﬁx,
the code viewer highlights the target code and scrolls to the
999
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:31:33 UTC from IEEE Xplore.  Restrictions apply. certain line, while the detail panel ( 4/circlecopyrt) shows the description
of the proposed ﬁx and the reason in natural language. For now
two working modes are supported and can be selected by thedropdown list at 1/circlecopyrt. In the global mode, all the candidate ﬁxes
are accepted and their statuses are locked. In the manual mode,however, all the candidate ﬁxes are rejected by default andusers can manually accept some of them. Finally, by clickingthe conﬁrmation button at 2/circlecopyrt, accepted ﬁxes are submitted to
IntPTI for code transformation.
Code transformation. Arithmetic checks and conversion
checks are implemented as a library libTsmartIntFix. To apply
a SC ﬁx, we insert the corresponding check function with its
declaration introduced. It is necessary to link this library tocompile the repaired code.
IV . E
XPERIMENT AL EV ALUA TION
The effectiveness of IntPTI can be assessed in the terms of
the following aspects:
1) What is the accuracy of IntPTI in repairing integer errors?
2) What is the runtime efﬁciency of IntPTI?
IntPTI is evaluated on 7 open-source projects: gzip 1.2.4,
Vim 7.4, grep 2.10, PostgreSQL 9.0.15, JasPer 1.900.5,
libarchive 3.1.2 and OpenSSL 1.0.1r. They are chosen for
evaluation because 1) they are written in C and contain known
integer vulnerabilities in the CVE database, 2) they coversvarious application domains including encoding and decoding,
text processing, database system, graphics and cryptography.
Repair accuracy should be measured by recall and precision.The former is evaluated by checking how many vulnerability
are successfully repaired after running IntPTI in the global
mode. The latter cannot be evaluated directly because we
have no complete knowledge on integer errors in realistic codebases. Thus, we compare the numbers of critical program sites(which are typical locations for ﬁxes) applied with ﬁxes byvarious tools.
All experiments are conducted on a workstation under 64-
bit Ubuntu 16.04, using Intel Core i7-6820HQ@2.70GHz CPUand 32GB memory. The maximum levels of the call stack and
loop nesting are set to 3 while loops are not unrolled (thusloop bodies are always reasoned by loop invariants). Constraint
penalties are set as default values. The data model employedis conﬁgured as ILP32 only if the target defects can only be
triggered under ILP32, or LP64 otherwise. The experimentalresults of IntPTI are shown in Table II.
Columns 1-4 show general information about the evaluation
programs. For PostgreSQL and OpenSSL, IntPTI directly
analyzes all source ﬁles under the speciﬁed location (such
as crypto/bn) because the target defects are not included in
any preprocessed task. KLOC and KLOC-P refer to the lines
of code before or after preprocessing, respectively. KLOC
excludes all header ﬁles.
Columns 5-11 assess the recall. Column CVE-ID lists CVE
identiﬁers for the defects. Some identiﬁers (such as CVE-
2014-2669) contain multiple buggy code fragments with si-
milar defect patterns. Column DM reports under which data
model (32 for ILP32 and 64 for LP64) certain defect can be
triggered. Column Op lists buggy operations (e.g. ×
udenotes
unsigned multiplication while “u2s” denotes the conversionfrom unsigned to signed). The following three columns count
the different kinds of ﬁxes. Column Freports whether certain
defect is correctly repaired. The results show that 23 out of
25 defects are repaired correctly. Two missed bugs are dueto ﬂow-insensitivity of proper-type inference. For example,the bug belonging to CVE-2017-5499 involves an signedmultiplication yielding an overﬂowed 64-bit integer which isthen passed to a critical site, and the proper-type inferencecannot capture the sequence of the overﬂowed multiplicationand the critical site.
Columns 12-17 report runtime efﬁciency results. Columns
CF, SU, VA,TI and FA report the time costs of control-
ﬂow build, summary computation, static value analysis, typeinference and ﬁx application, respectively. Static value analysiscosts the majority of total time (78.6% on average). It isremarkable that type inference costs only 4.8% of total time
and this result can be achieved because multi-entry analy-
sis decomposes the complicated whole-program proper-typeconstraints into fragments which can be solved efﬁciently.
Furthermore, IntPTI spends no more than 11 minutes on Vim,
the largest project (over 244 KLOC) used in the evaluation.
The last 3 columns evaluate the precision. The Baseline
column lists the total number of critical sites of integer
type. We compare IntPTI’s precision with CIntFix [23] and
Coker’s [22] because 1) they work on source code only
without requiring additional inputs, 2) they support various
kinds of integer errors. CIntFix changes every critical site (as
the Column Baseline shows) because it needs to make sure
whether a multi-precision integer value ﬁts the target built-in type on every critical site. Since we are unable to obtainthe artifact of Coker’s work after our request to authors, we
count the number of critical sites applied with ﬁxes as if the
add-integer-cast transformation is applied to all local variables,array subscripts and ﬁeld access expressions, and the replace-arithmetic-operator transformation is applied to all arithmeticexpressions and assignments, as the experimental settings inthe paper. The results show that Coker’s and ours makechanges on 34.8% and 2.3% of all critical sites, respectively.In fact, by considering user’s feedbacks, our false-positiverate can be further reduced. Coker’s and CIntFix focus on
transforming the internal integer model to a safer model, thusmassive false-positives could be generated.
CIntFix is also evaluated on the chosen projects. The results
show that CIntFix succeeds in repairing all 25 target defects
while the total time cost is 392.268s. It is insufﬁcient toconclude that CIntFix has better real-world applicability for
its superior performance on the recall and runtime efﬁciencybecause precision is crucial to user experience as the criteriafor static code analyzers. In fact, the recall and runtimeefﬁciency of our tool could be improved by changing all
integer types to 64-bit unsigned/signed integers and inserting
sanity checks on every arithmetic operations, which wouldmake it much more difﬁcult for users to review the ﬁxes and
ﬁnd possible integer defects in programs.
V. C
ONCLUSION
In this paper, we present IntPTI, an automatic repair tool
for integer errors in C programs. It integrates type inferencesynergically with static value analysis to compose constraints
1000
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:31:33 UTC from IEEE Xplore.  Restrictions apply. T ABLE II
EV ALUA TION RESULTS OF INTPTI.
General info Accuracy Performance (s) # Critical sites
Project Task KLOC KLOC-P CVE-ID DM Op ETC SC DTC F CF SU VA TI FA Σ Baseline Coker’s IntPTI
gzip gzip 5.22 17.09 2010-0001 64−u 2 0 1  1.459 3.352 33.224 0.522 0.471 39.028 1166 342 29
Vim vim 244.037 1195.8142017-6350 32/64 ×u 0 1 0 28.325 68.612 521.505 27.416 10.102 655.9605636719225 11502017-6349 32/64 ×u 0 1 0 
2017-5953 32×u 2 0 0  29.362 71.050 467.811 29.723 9.920 607.866 19202 1236
grep grep 40.577 132.4822012-5667 32/64 +s 3 1 1 4.276 7.250 14.384 1.329 1.165 28.404 4271 2004 782012-5667 32/64 u2s 0 0 1 
PostgreSQL contrib/hstore 2.94 43.2222014-2669 32×u 2 1 0 
3.325 1.279 7.154 2.110 1.173 15.041 1979 909 1142014-2669 32×u 2 1 0 
2014-2669 32×u 2 1 0 
2014-2669 32×u 2 1 0 
JasPerjasper 26.932 138.3482017-5499 32/64 ×s 0 0 0 
5.716 13.658 57.792 7.435 2.204 86.805 11514 4037 3512017-5500 32/64 /lessmuchs 0 1 0 
2017-5502 32/64 /lessmuchs 0 3 0 
2016-9387 32/64 ×s 2 1 0 
2016-9262 32/64 +s 0 0 1 
imgcmp 26.973 138.4 2017-5501 32/64 +s 3 1 0  5.489 10.626 12.582 7.088 2.193 37.978 11601 4045 355
libarchive bsdtar 77.424 398.7832016-6250 32/64 +s 3 0 3 
9.817 24.167 489.197 16.740 5.385 545.306 24184 8949 6452016-5844 32/64 ×s 0 2 0 
2016-5844 32/64 ×s 0 2 0 
2016-4300 32/64 +u 0 0 0 
OpenSSLcrypto/mdc2 0.305 4.456 2016-6303 32/64 +u 0 1 0  0.761 0.279 0.207 0.066 0.352 1.665 59 19 2
crypto/evp 11.305 258.012016-2106 32/64 +s 2 0 0 7.057 3.053 2.465 5.433 3.593 21.601 3750 1230 682016-2105 32/64 +s 2 0 0 
crypto/bn 13.777 78.6732016-0797 32/64 ×s 0 0 1 3.968 2.170 22.935 2.585 1.579 33.237 4745 1311 532016-0797 32/64 ×s 0 0 1 
on the types of variables and expressions for preventing
representation issues. It utilizes the solution of constraintswith common ﬁx patterns ETC, SC and DTC codiﬁed fromthe successful human-written patches. We have designed aweb interface which ﬁlls the gap between end users andthe tool to (1) help users better understand integer bugs and2) reduce unnecessary ﬁxes with user feedback. IntPTI is
evaluated on 7 real-world projects and the results show thatit is effective to repair various kinds of integer errors with
high runtime efﬁciency while avoiding unnecessary changeson critical program sites. The source code and experimental
data are publicly available at https://git.io/v99Jw.
A
CKNOWLEDGMENT
We thank the anonymous reviewers for their insightful com-
ments. This research was supported in part by NSFC Program(No. 61527812), National Science and Technology Major
Project (No. 2016ZX01038101), MIIT IT funds (Research and
application of TCN key technologies) of China, and The Natio-nal Key Technology R&D Program (No. 2015BAG14B01-02).
R
EFERENCES
[1] N. Y . Times, “F.A.A. Orders Fix for Possible Power Loss in
Boeing 787.” [Online]. Available: http://www.nytimes.com/2015/05/01/
business/faa-orders-ﬁx-for-possible-power-loss-in-boeing-787.html
[2] CVE, “CVE-2016-9793,” 2016. [Online]. Available: http://cve.mitre.
org/cgi-bin/cvename.cgi?name=CVE-2016-9793
[3] ——, “CVE-2016-9754,” 2016. [Online]. Available: http://cve.mitre.
org/cgi-bin/cvename.cgi?name=CVE-2016-9754
[4] S. Christey, B. Martin, M. Brown, A. Paller, and D. Kirby, “2011
CWE/SANS Top 25 Most Dangerous Software Errors,” 2011. [Online].Available: http://cwe.mitre.org/top25/
[5] C. Price, MIPS IV Instruction Set. MIPS Technologies, 1995.
[6] Y . Moy, N. Bjørner, and D. Sielaff, “Modular bug-ﬁnding for integer
overﬂows in the large: Sound, efﬁcient, bit-precise static analysis,” Tech.Rep. MSR-TR-2009-57, 2009.
[7] D. Molnar, X. C. Li, and D. Wagner, “Dynamic test generation to
ﬁnd integer bugs in x86 binary linux programs,” in USENIX Security
Symposium, 2009, pp. 67–82.
[8] S. Sidiroglou-Douskos, E. Lahtinen, N. Rittenhouse, P . Piselli, F. Long,
D. Kim, and M. C. Rinard, “Targeted automatic integer overﬂow disco-very using goal-directed conditional branch enforcement,” in ASPLOS,
2015, pp. 473–486.
[9] X. Wang, H. Chen, Z. Jia, N. Zeldovich, and M. F. Kaashoek, “Im-
proving integer security for systems with KINT,” in OSDI, 2012, pp.
163–177.[10] D. Brumley, D. X. Song, T. Chiueh, R. Johnson, and H. Lin, “RICH:
automatically protecting against integer-based vulnerabilities,” in NDSS,
2007.
[11] W. Dietz, P . Li, J. Regehr, and V . S. Adve, “Understanding integer
overﬂow in C/C++,” ACM Trans. Softw. Eng. Methodol., vol. 25, no. 1,
pp. 2:1–2:29, 2015.
[12] R. B. Dannenberg, W. Dormann, D. Keaton, R. C. Seacord, D. Svoboda,
A. V olkovitsky, T. Wilson, and T. Plum, “As-if inﬁnitely ranged integermodel,” in ISSRE, 2010, pp. 91–100.
[13] C. Le Goues, T. Nguyen, S. Forrest, and W. Weimer, “Genprog: A
generic method for automatic software repair,” IEEE Trans. Software
Eng., vol. 38, no. 1, pp. 54–72, 2012.
[14] W. Weimer, Z. P . Fry, and S. Forrest, “Leveraging program equivalence
for adaptive program repair: Models and ﬁrst results,” in ASE, 2013, pp.
356–366.
[15] Y . Qi, X. Mao, Y . Lei, Z. Dai, and C. Wang, “The strength of random
search on automated program repair,” in ICSE, 2014, pp. 254–265.
[16] D. Kim, J. Nam, J. Song, and S. Kim, “Automatic patch generation
learned from human-written patches,” in ICSE, 2013, pp. 802–811.
[17] F. Long and M. Rinard, “Staged program repair with condition synthe-
sis,” in ESEC/FSE, 2015, pp. 166–178.
[18] ——, “Automatic patch generation by learning correct code,” in POPL,
2016, pp. 298–312.
[19] H. D. T. Nguyen, D. Qi, A. Roychoudhury, and S. Chandra, “Semﬁx:
program repair via semantic analysis,” in ICSE, 2013, pp. 772–781.
[20] S. Kaleeswaran, V . Tulsian, A. Kanade, and A. Orso, “Minthint: auto-
mated synthesis of repair hints,” in ICSE, 2014, pp. 266–276.
[21] S. Mechtaev, J. Yi, and A. Roychoudhury, “Directﬁx: Looking for simple
program repairs,” in ICSE, 2015, pp. 448–458.
[22] Z. Coker and M. Haﬁz, “Program transformations to ﬁx C integers,” in
ICSE, 2013, pp. 792–801.
[23] X. Cheng, M. Zhou, X. Song, M. Gu, and J. Sun, “Automatic ﬁx for
C integer errors by precision improvement,” in COMPSAC, 2016, pp.
2–11.
[24] C. Ansótegui, M. L. Bonet, and J. Levy, “A new algorithm for weighted
partial maxsat,” in AAAI, 2010.
[25] L. M. de Moura and N. Bjørner, “Z3: an efﬁcient SMT solver,” in
TACAS, 2008, pp. 337–340.
[26] T. J. Hickey, Q. Ju, and M. H. van Emden, “Interval arithmetic: From
principles to implementation,” J. ACM , vol. 48, no. 5, pp. 1038–1068,
2001.
[27] L. O. Andersen, “Program analysis and specialization for the c program-
ming
language,” Ph.D. dissertation, University of Cophenhagen, 1994.
[28] F. Nielson, H. R. Nielson, and C. Hankin, Principles of program
analysis. Springer, 1999.
[29] D. Beyer, T. A. Henzinger, and G. Théoduloz, “Conﬁgurable software
veriﬁcation: Concretizing the convergence of model checking and pro-gram analysis,” in CA V, 2007, pp. 504–518.
[30] C. Barrett, A. Stump, and C. Tinelli, “The smt-lib standard version 2.0,”
SMT-LIB Initiative, Tech. Rep., 2012.
[31] D. Kroening and O. Strichman, “Equality logic and uninterpreted functi-
ons,” in Decision Procedures: An Algorithmic Point of View. Springer
Berlin Heidelberg, 2008, pp. 59–80.
1001
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:31:33 UTC from IEEE Xplore.  Restrictions apply. 