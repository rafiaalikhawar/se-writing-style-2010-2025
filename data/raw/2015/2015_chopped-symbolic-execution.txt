Chopped Symbolic Execution
David Trabish
Tel Aviv University
Israel
davivtra@post.tau.ac.ilAndrea Mattavelli
Imperial College London
United Kingdom
amattave@imperial.ac.ukNoam Rinetzky
Tel Aviv University
Israel
maon@cs.tau.ac.ilCristian Cadar
Imperial College London
United Kingdom
c.cadar@imperial.ac.uk
ABSTRACT
Symbolic execution is a powerful program analysis technique that
systematicallyexploresmultipleprogrampaths.However,despite
importanttechnicaladvances,symbolicexecutionoftenstrugglesto
reach deep parts of the code due to the well-known path explosion
problem and constraint solving limitations.
In this paper, we propose chopped symbolic execution,an o v e l
form of symbolic execution that allows users to specify uninter-
estingpartsofthecodetoexcludeduringtheanalysis,thusonlytargeting the exploration to paths of importance. However, theexcluded parts are not summarily ignored, as this may lead to
both false positives and false negatives. Instead, they are executed
lazily, when their effect may be observable by code under anal-ysis. Chopped symbolic execution leverages various on-demand
static analyses at runtime to automatically exclude code fragments
whileresolvingtheirsideeffects,thusavoidingexpensivemanual
annotations and imprecision.
Our preliminaryresults show that theapproach can effectively
improvetheeffectivenessofsymbolicexecutioninseveraldifferent
scenarios, including failure reproduction and test suite augmenta-
tion.
CCS CONCEPTS
•Software and its engineering →Software testing and de-
bugging;
KEYWORDS
Symbolic execution, Static analysis, Program slicing
ACM Reference Format:
DavidTrabish,AndreaMattavelli,NoamRinetzky,andCristianCadar.2018.
Chopped Symbolic Execution. In ICSE ’18: 40th International Conference on
Software Engineering, May 27-June 3, 2018, Gothenburg, Sweden. ACM, New
York, NY, USA, 11 pages. https://doi.org/10.1145/3180155.3180251
1 INTRODUCTION
Symbolic execution lies at the core of many modern techniquesto software testing, automatic program repair, and reverse engi-
neering[ 3,11,16,24,32,35].Atahigh-level,symbolicexecution
systematically explores multiple paths in a program by running
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
©2018 Copyright held by the owner/author(s). Publication rights licensed to the
Association for Computing Machinery.
ACM ISBN 978-1-4503-5638-1/18/05...$15.00
https://doi.org/10.1145/3180155.3180251thecodewithsymbolicvaluesinsteadofconcreteones.Symbolic
executionenginesthusreplaceconcreteprogramoperationswith
ones that manipulate symbols, and add appropriate constraints on
the symbolic values. In particular, whenever the symbolic executor
reaches a branch condition that depends on the symbolic inputs, it
determinesthefeasibilityofbothsidesofthebranch,andcreates
twonewindependent symbolicstates whichareaddedtoaworklist
to follow each feasible side separately. This process, referred to as
forking, refines the conditions on the symbolic values by adding
appropriateconstraintsoneachpathaccordingtotheconditions
on the branch. Test cases are generated by finding concrete values
for the symbolic inputs that satisfy the path conditions.T ob o t h
determine the feasibility of path conditions and generate concrete
solutionsthatsatisfiesthem,symbolicexecutionenginesemploy
satisfiability-modulo theory (SMT) constraint solvers [19].
The Challenge. Symbolic execution has proven to be effective at
findingsubtlebugsinavarietyofsoftware[ 3,11,12,25,39],and
has started to see industrial take-up [ 13,15,25]. However, a key
remaining challenge is scalability, particularly related to constraint
solving cost and path explosion [14].
Symbolicexecutionenginesissueahugenumberofqueriestothe
constraint solver that are often large and complex when analyzing
real-world programs. As a result, constraint solving dominates
runtimeforthemajorityofnon-trivialprograms[ 30,33].Recent
research has tackled the challenge by proposing several constraint
solvingoptimizationsthatcanhelpreduceconstraintsolvingcost[ 5,
12, 21, 27, 33–35, 41, 45].
Path explosion represents the other big challenge facing sym-
bolicexecution,andthemainfocusofthispaper.Pathexplosion
referstothechallengeofnavigatingthehugenumberofpathsin
real programs, which is usually at least exponential to the number
of static branches in the code. The common mechanism employed
bysymbolicexecutorstodealwiththisproblemistheuseofsearch
heuristics to prioritise path exploration. One particularly effec-
tive heuristic focuses on achieving high coverage by guiding the
explorationtowardsthepathclosesttouncoveredinstructions[ 10–
12,43].Inpractice,theseheuristicsonlypartiallyalleviatethepath
explosion problem, as the following example demonstrates.
Motivating Example. Theextract_octet() function, shown in
Figure 1, is a simplified version of a function from the libtasn1
librarywhichparsesASN.1 encodingrulesfroman inputstring.1
TheASN.1protocolisusedinmanynetworkingandcryptographic
applications, such as those handling public key certificates and
electronicmail.Versionsof libtasn1 before4.5areaffectedbya
heap-overflow security vulnerability that could be exploited via a
crafted certificate.2Unfortunately, given a time budget of 24 hours,
1https://www.gnu.org/software/libtasn1
2https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-3622
3502018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Trabish, Mattavelli, Rinetzky and Cadar
1int extract_octet(asn_t asn, char *str, int str_len) {
2 int len3, counter, counter_end, result;
3 int len2 = get_length(str, str_len, &len3);
4 counter = len3+1;
5 counter_end = str_len;
6 while (counter < counter_end) {
7 // call to get_length() leads to a heap overflow:
8 len2 = get_length(str+counter, str_len, &len3);
9 if(len2 >= 0) {
10 DECR_LEN(str_len, len2+len3);
11 append_value(asn, str+counter+len3, len2);
12 }else {
13 DECR_LEN(str_len, len3);
14 result = extract_octet(asn, str+counter+len3, str_len);
15 if(result != SUCCESS)
16 return result;
17 len2 = 0;
18 }
19 // str_len should have been decremented at the
20 // beginning of the while block
21 DECR_LEN(str_len, 1);
22 counter += len2+len3+1;
23 }
24 return SUCCESS;
25}
Figure 1: A simplified excerpt from the extract_octet rou-
tine in libtasn1. The invocation of get_length() in line 8
leadstoaheapoverflowbecause str_lenhasnotbeendecre-
mented before the call.
theanalysisofthe extract_octet() functionusingthestate-of-
the-artsymbolicexecutionengineKLEE[ 11]failstoidentifythe
vulnerability due to path explosion.
At each loop iteration (lines 6–23), the function decodes the
length of the current data element with get_length (line 8). Func-
tion get_length scans through the input string and decodes the
ASN.1fields.Then,theexecutioneitherrecursivelyiteratesoverthe
input string (line 14), or invokes append_value (line 11). Function
append_value creates the actual node in the Abstract Syntax Tree
(AST) by decoding the input string given the obtained length. This
functionscansoncemoreovertheinputstring,performsseveral
checks over the selected element, and allocates memory for the
node in the recursive data structure.
Path explosion in this function occurs due to several nested
function calls. Symbolically executing function get_length alone
with a symbolic string of ncharacters leads to 4 ∗ndifferent paths.
Function append_value increases even more the number of paths
andalsoaffectstheefficiencyofthesymbolicexecutionenginedue
to a huge number of constraint solver invocations. As a result, the
symbolic executor fails to identify the heap-overflow vulnerability
at line 8.
OurApproach. Identifyingthevulnerabilityfromtheentrypoint
ofthelibraryisnottrivial:Toreachthefaultyinvocationoffunc-
tion get_length ,theinputtriggeringthevulnerabilitytraverses
2,945callsto98differentfunctions,foratotalamountof386,727
instructions. Our key observation is that most of the functions
requiredduringtheexecutionare notrelevant forfindingthevul-
nerability.Thevulnerabilityoccursduetoanincorrectupdateof
theremainingbytesforparsing(line21),whichresultsinamemory
out-of-bound read when calling get_length . The bug thus occurs
incodewhichdealswiththeparsing,whichisindependentfromthefunctionsthat constructthecorrespondingASN.1 representation,
such as append_value . Therefore, we could have quickly reached
the bug if we had skippedthe irrelevant functions that build the
AST.
In this paper, we propose a novel form of symbolic execution
calledchopped symbolic execution that provides the ability to spec-
ifypartsofthecodetoexcludeduringtheanalysis,thusenabling
symbolic execution to focus on significant paths only. The skipped
codeisnottriviallyexcludedfromsymbolicexecution,sincethis
may lead to spurious results. Instead, chopped symbolic execution
lazily executes the relevant parts of the excluded code when ex-
plicitly required. In this way, chopped symbolic execution does not
sacrifice the soundness guarantees provided by standard symbolic
execution—except for non-termination of the skipped functions,
which may be considered a bug on its own—in that only feasible
pathsareexplored,buteffectivelydiscardspathsirrelevanttothe
task at hand.
We developed a prototype implementation of chopped symbolic
execution and report the results of an initial experimental eval-
uation that demonstrates that this technique can indeed lead to
efficient and effective exploration of the code under analysis.
Main Contributions. In summary, in this paper we make the
following contributions:
(1)We introduce chopped symbolic execution, a novel form of sym-
bolic execution that leverages a lightweight specification of
uninterestingcodepartstosignificantlyimprovethescalability
of symbolic execution, without sacrificing soundness.
(2)WepresentChopper,aprototypeimplementationofourtech-
nique within KLEE [11], and make it publicly available.
(3)We report on an experimental evaluation of Chopper in two
different scenarios: failure reproduction and test suite augmen-
tation,andshowthatchoppedsymbolicexecutioncanimprove
and respectively complement standard symbolic execution.
Thispaperisorganisedasfollows.Section2givesahigh-level
overviewofchoppedsymbolicexecution,andSection3presents
our technique in detail. Section 4 briefly discusses our implementa-
tioninsidetheKLEEsymbolicexecutionengine.Section5presents
theexperimentalevaluationofourtechnique,andinparticularit
showsthatchoppedsymbolicexecutioncanovercomethelimita-
tionsofstate-of-the-artsymbolicexecutors.Section6surveysthe
main approaches related to this work. Section 7 summarises the
contributions of the paper and describes ongoing research work.
2 OVERVIEW
In this section, we give a high-level overview of chopped symbolic
executionusingthesimpleprograminFigure2.Inparticular,Fig-
ure2ashowstheentrypointoftheprogram(function main),while
Figure 2c shows the uninteresting code which we would like to
skip (function f).
We start the chopped execution by executing mainsymbolically.
Whenastatereachesthefunctioncallfor fatline7,wecreatea
snapshotstate bycloningthecurrentstate,andskipthefunction
call.ThesnapshotstateisshowngraphicallyinFigure2b,where
each gray oval represents a symbolic execution state.
With a snapshot created, we then continue the execution on
thecurrentstate,butfromthispointwemustconsiderthatsome
351
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. Chopped Symbolic Execution ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
1struct point { int x, y, z;};
2
3int main() {
4 struct point p = {0, 0, 0};
5 int j, k; // symbolic
6
7 f(&p, k); // skip
8 if( j>0 )
9 if(p.y)
10 bug();
11 else
12 allgood();
13 return 0;
14}
(a)j>0 j≤0k>0 k≤0SnapshotRecovery
Dependent
k>0 k≤0Recovery’’
Dependent + 
Recovery’Dependent + 
Recovery’’Guiding constraints1
23
4 5p->y++Recovery’
Recovery’
6p.y=1return
7—
(b)15void f(struct point *p, int k) {
16 if( k%2 )
17 p->z++;
1819 if( k>0 )
20 p->x++;
21 else
22 p->y++;
23}
(c)
Figure 2: Graphical illustration of chopped symbolic execution on a simple example.
load instructions may depend on the side effects of the skipped
function f, i.e. the memory locations that fmay update. In our
example, the side effects of fare the memory locations pointed
toby p.z,p.x,and p.y,whichareupdatedatlines17,20,and22
respectively.(Wecomputethesideeffectsof fusingconservative
staticpointer analysis [4,26,37] before the symbolic exploration
starts, see §3.) We define those instructions that read from the side
effects of the skipped functions as dependent loads.
On some paths, symbolic execution does not encounter such
dependent loads. For example, the path following the elseside
of the branch at line 8 accesses neither p.xnorp.ynorp.z,s o
no further action is needed on those paths, and the exploration
may correctly terminate without ever going through the code of f.
Indeed,inrealprogramsthereareoftenpathsthatdonotdepend
on the skipped functions, and in such cases symbolic execution
immediatelybenefitsfromourapproach:irrelevantpathsaresafely
skipped, thus reducing path explosion.
However,onother pathssymbolicexecutionencounters depen-
dentloads.Thishappensforourexampleonthepathwhichexplores
thethenside of the branch at line 8, when it loads the value of
p.yat line 9. At this point, the current state needs to be suspended
until the relevant paths in function fare explored, and becomes a
dependentstate.Torecoverapath,wecreateanew recoverystate
which inherits the snapshot state generated before skipping fat
line 7 and start executing symbolically the function.
While symbolic execution is in the recovery state, if the exe-
cution forks, then the same fork is performed in the dependent
state.Furthermore,aswerun therecoverystate,anystorestothe
memory location read by the dependent load are also performed
in the dependent state. For example, if the symbolic execution of f
traversesthe elsebranchatlines21–22,thenthevalueof p.y(the
memorylocationpointedtoby p->y)issetto1inthedependent
statetoo.Iftherecoverystatereturnssuccessfully,thedependent
state is resumed successfully. If an error occurs while executing
the recovery state (e.g., an invalid memory access or a division by
zeroerror, whichcould haveoccurredif p->zwereset inline 17 to
4/p->y) the corresponding dependent state is terminated.
Whenweexecutearecoverystate,notallpathsmightbecom-
patible with the execution which the dependent state reached. Forexample, if line 8 were changed from if (j>0) toif (k>0) , then
the dependent state would have k>0 in its path condition, ren-
deringthedependentstateincompatiblewiththepathin fwhere
k≤0.
Onewaytofiltersuchincompatiblepathswouldbetoexecute
allpossiblepathsthorough fduringrecovery,andlaterfilterthe
ones that are incompatible with the dependent state. However,
this would potentially lead to the exploration of a large numberof infeasible paths. We thus designed a more efficient solution:
Eachstatemaintainsalistof guidingconstraints,whicharethose
constraints added since the call to the skipped function. In our
example, the guiding constraints for the dependent state are j>0.
Beforeweexecutearecoverystate,weaddthese guidingconstraints
fromthedependentstatetothepathconditionoftherecoverystate.Bydoingthis,weguaranteethateverypathexploredintherecovery
state is consistent with respect to its dependent state.
Duringrecovery,onecouldexecuteallpossiblepathsthrough
theskippedfunction fwhicharecompatiblewiththedependent
state,aswecouldintheexampleabove.However,forrealprograms
this could be unnecessarily expensive, as many paths do not influ-ence the dependent load which started the recovery. To avoid this
possible path explosion, and reduce the cost of constraint solving,
we aim to only execute the paths that could influence the depen-
dentload.Weaccomplishthisbystatically slicing[7,40,42,44]the
function fwithrespecttothestoreinstructionsthatwritetothe
memorylocationreadbythedependentload,thatis,thesideeffectsobservablefromthedependentload.Notethatfunction
fcouldcall
other functions, so the slicing is done for all these functions too. In
our example, the slicing would likely be able to completely remove
theifstatement at lines 16–17, which would halve the number of
exploredpaths,thusreducingpathexplosion.Itwouldalsolikelyremovethe
thensideofthe ifstatementatline19,whichinthis
case does not bring significant benefits, but it could, if that side of
thebranchwerereplacedbysay,anexpensiveloop.Slicingaway
these code parts is possible because they do not update p.yon
which the dependent load on line 9 relies.3
3In practice, the success of the slicing algorithm in reducing the size of the code
depends on the precision of the underlying pointer analysis.
352
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Trabish, Mattavelli, Rinetzky and Cadar
Figure 2b shows how chopped symbolic execution works on
ourexampleinagraphicalway.Torecapitulate,whenthecallto
fis reached at line 7, a snapshot state is created by cloning the
current state (step 1/circlecopyrtin the figure). Then, on the execution state
thatreachesline9,thecurrentstatebecomesadependentstateand
is suspended (step 2/circlecopyrt), and a recovery state is created by cloning
the snapshot state and adding the guiding constraints from the
dependent state (step 3/circlecopyrt). At this point, function fis statically
slicedwithrespecttothedependentload,inourcaseremovingthefirstifstatementandthe thenslideofthesecond ifstatement.Then,
the recovery state starts symbolically running the sliced version of
f. When execution is forked at line 19, then the dependent state is
alsoforkedalongthesameconstraints(steps 4/circlecopyrtand5/circlecopyrt).Oneofthe
forked recovery states (Recovery’) updates the location p->yon
whichourdependentloadrelieson,sothislocationisalsoupdated
in the corresponding dependent state (step 6/circlecopyrt). Finally, when a
recovery state terminates, it gets discarded (step 7/circlecopyrt), and symbolic
executionisresumedfromitsdependentstatesandothernormal
states in the program.
3 CHOPPED SYMBOLIC EXECUTION
In this section, we describe our technique in detail and provide the
backgroundregardingthemainstaticanalysisitemploys,namely
pointer analysis [4, 26, 37].
Algorithm 1 presents the key steps in chopped symbolic exe-
cution,whichwegraduallyexplain.Thealgorithmoperatesona
simple imperative C-like heap-manipulating language with assign-
ments, assertions, conditional jumps, dynamic memory allocation
andreclamation,andfunctioncallswithcall-by-valueparameter
passing.4Functionsmayhavepointerparameters.Thus,without
lossofgenerality,weassumethatfunctionsdonothaveareturn
value.5Tosimplifytheexplanation,wenowassumethatwemay
skipatmostonefunctioninvocationateveryexploredpath,and
discussthegeneralcasein§3.3.6Forthesamereason,wealsoas-
sume that the program does not dynamically allocate memory, and
discuss this aspect in §3.4.
Chopped symbolic execution begins by invoking function cse
with aninitial symbolic state (s0) and a set containing the names
of the functions that the user wishes to skip ( skipFunctions ). We
expect a symbolic state sto encode, among other properties, the
next instruction to be executed (denoted by nextInstruction (s)),
the activation record stack, and a (symbolic) description of the pro-
gramheap.Forexample,thechoppedsymbolicexecutiondescribed
in Section 2 begins with s0in which the stack contains only the
activation record of main, with the next instruction at line 4, an
empty heap, and skipFunctions ={f}.
At the beginning of the algorithm the worklistis empty (line 1),
andweinitializeitwith s0(line3).Then,astandardworklist-based
algorithmstartsexecutinguntileithertheworklistisempty(line4),
or the algorithm exhausts the time budget (elided). As usual, the
algorithmselectsasymbolicstate stoexploreoutoftheworklist
(line5).Unconventionally,however,theworklistonlyhasthestates
which are not suspended, as suspended states are blocked until the
4Our implementation operates on LLVM bitcode [29].
5A function with a return value can always be rewritten with an additional parameter
that points to the memory location of the return value.
6For completeness of presentation, Algorithms 1, 2 and 3 handle the general case.Algorithm 1 Chopped symbolic execution (simplified).
1:worklist←∅
2:function cse(s0,skipFunctions )
3:worklist←worklist∪{s0}
4:whileworklist /nequal∅do
5:s←select (worklist )
6:inst←nextInstruction (s)
7:switchinstdo
8:caseCall
9: f←targetFunction (s)
10: iff∈skipFunctions then
11: snapshot←createSnapshot (s)
12: s.skipped←s.skipped+(f,snapshot )
13: else
14: executeCall (s)
15: caseLoad
16: addr←getLoadAddress (s)
17: ifmayMod (s,s.skipped,addr )then
18: createRecoveryState (s,addr )
19: else
20: executeLoad( s,inst)
21: caseBranch
22: ifs.isRecoveryState then
23: dependentState←getDependent (s)
24: φ=condition (inst )
25: s/prime←fork (s,φ)
26: dependentState/prime←fork (dependentState ,φ)
27: iffeasible (s/prime)∧feasible (dependentState/prime)then
28: worklist←worklist∪{s/prime}
29: s/prime/prime←fork (s,¬φ)
30: dependentState/prime/prime←fork (dependentState ,¬φ)
31: iffeasible (s/prime/prime)∧feasible (dependentState/prime/prime)then
32: worklist←worklist∪{s/prime/prime}
33: worklist←worklist\{s}
34: else
35: executeBranch( s)
36: caseStore
37: addr←getStoreAddress (s)
38: executeStore (s,addr )
39: ifs.isRecoveryState then
40: updateDependentState( s,addr)
41: else
42: s.overwrittenSet←s.overwrittenSet∪{addr}
43: caseReturn
44: ifs.isRecoveryState∧returnInSkipped (s)then
45: terminate(recoveryState )
46: dependentState←getDependent (s)
47: resume(dependentState )
48: worklist←worklist∪{dependentState}
49: else
50: executeReturn( s)
51:end switch
353
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. Chopped Symbolic Execution ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Algorithm 2 Auxiliary function: createRecoveryState
1:function createRecoveryState(dependentState ,addr)
2:foreach (f,snapshot )∈dependentState .skippeddo
3:ifmayMod (dependentState ,(f,snapshot ),addr )then
4:suspend (dependentState )
5:gc←getGuidingConstraints (dependentState )
6:recoveryState←fork (snapshot ,gc)
7:recoveryState .isRecoveryState←true
8:slice (recoveryState ,addr )
9:linkDependent (recoveryState ,addr,dependentState )
10: worklist←worklist∪{recoveryState}
Algorithm 3 Auxiliary function: mayMod
1:function mayMod( s,funclist,addr)
2:foreach (f,snapshot )∈funclistdo
3:ifallocSite (s,addr )∈modSet (f)then
4:ifaddr/nelements.overwrittenSet then
5: returntrue
6:returnfalse
valueofthedependedloadisresolved(see§2).Thenextstepofthe
algorithm depends on the instruction type (line 7).
Handling Callinstructions (lines 8–14): A Callinstruction is
handled as illustrated by step 1/circlecopyrtin Figure 2 (see §2): First, the
algorithm determines the name fof the invoked function (line 9).
Then,iffisoneoftheskippedfunctions,thealgorithmcreatesa
snapshot of the current state s(line 11) and records the snapshot
state at the end of its list of skipped invocations (line 12). A skipped
invocation is represented as a tuple (f,snapshot )composed of the
name of a skipped function f, and asnapshot of the symbolic state
at the time fwas skipped.
Conversely, if fshould not be skipped, the algorithm handles
its invocation as usual in symbolic execution. For brevity, we omit
the standard handling of commands by symbolic execution.Handling Loadinstructions
(lines15–20):Choppedsymbolicexe-
cutionuses mayMod (s,s.skipped,addr ),showninAlgorithm3and
explained in§3.1, to determine whetherthe address from whicha
valueisread( addr)mighthavebeenmodifiedbyoneoftheskipped
functionsonthepathfollowedbythecurrentstate s.Ifso,theal-
gorithm generates recovery states by calling createRecovery−
State (s,addr ).Otherwise,the Loadinstructionishandledasusual
in symbolic execution (line 20).
Function createRecoveryState is shown in Algorithm 2. The
function handles Loadinstructions as illustrated by step 2/circlecopyrtin Fig-
ure2(see§2):Ititeratesoverthelistofskippedfunctions(line2),
andusesmayModtodeterminewhichoftheskippedfunctions f
mighthavemodified addr(line3).Onceitfindssuchafunction,the
currentdependentstateisimmediatelysuspended(line4).Thefunc-
tion then generates the corresponding recovery state recoveryState
byforking snapshot andbyaugmentingitspathconditionwiththe
guidingconstraints gc(lines5to7),i.e.thepathconstraintsaccumu-
lated inssince the snapshot state was created. The algorithm then
invokesastaticprogramslicertoremovefromtheskippedfunction
finstructions which cannot affect the address of the dependent
load (line 8); records that dependentState spawned recoveryStateto determine the value written in address addrofdependentState
(line 9); and pushes the recovery state into the worklist (line 10).
Handling Branchinstructions (lines21–35):Thealgorithmchecks
whether the current state sis a recovery state. If so, then the
Branchinstruction is handled as illustrated by steps 4/circlecopyrtand5/circlecopyrt
in Figure 2 (see §2): It first retrieves the (suspended) dependent
statedependentState , which spawned sas a recovery state (line 23).
It then determinesthe branch condition φ(line 24); forksboth the
current(recovery)state sandthedependentstate dependentState ,
and adds φto their path condition (lines 25–26). After the fork,
it checks whether the resulting states are feasible, i.e. their path
conditions are satisfiable (line 27), and if so, adds the new recovery
statetotheworklist(line28).Ifeitheroneisnotfeasible,thenewlyforkedrecoveryanddependentstatesaresimultaneouslydiscarded.
Lines 29–32 act similarly to lines 25–28, except that we use the
negation of the branch condition ¬φ. Finally, the original recovery
statesis removed from the worklist (line 33). If the state sis not a
recoverystate,thenthe Branchinstructionishandledasusualin
symbolic execution (line 35).Handling Storeinstructions
(lines 36–42): The algorithm exe-
cutesthe Storeinstructiononthecurrentstateintwosteps.First,it
performs the actual store (lines 37–38). If sis a recovery state, then
the algorithm invokes updateDependentState (line 40, function
body elided for space reasons) to update the dependent state, as
illustratedbystep 6/circlecopyrtinFigure2.Otherwise,if sisnotarecovery
state, it updates the set of overwritten addresses in the currentstate to record that a value was stored in
addrafter the skipped
invocation,andthusanyvaluetheymaywriteisnolongerrelevant
(line 42).
Handling Returninstructions (lines43–50):If sisarecoverystate
andtheReturninstruction is invoked inside the skipped function
(line 44), then the recovery is terminated and the instruction is
handled as illustrated by step 7/circlecopyrtin Figure 2 (see §2): Specifically,
the recovery state itself is discarded (line 45) and the dependent
state is resumed (lines 46–47). Otherwise, the Returninstruction is
handled as usual in symbolic execution (line 50).
3.1 Static Inference of Function Side-Effects
Theauxiliaryfunction mayMod (s,funclist,addr ),shownin Algo-
rithm 3, receives as parameters a symbolic state s, a list of skipped
invocations funclist, and an address addrwhich is the target of
aLoadinstruction, and determines whether one of the skipped
functionsin funclistmaystoreavaluein addr.Thefunctionmakes
this decision using a points-to graph computed by a preliminary
pointer analysis stage [26, 37].
Morespecifically,weperformawhole-programflow-insensitive,
context-insensitive, and field-sensitive points-to analysis which de-
termines, in a conservative way, the memory location each pointer
variablemaypointto.Inthisanalysis,memorylocationsareconser-vatively abstracted using their allocation sites : Every definition of a
localoraglobalvariableisconsideredtobeanallocationsite,as
well as every program point in which memory is allocated. For ex-
ample,iftheprogramcontains while (..) do L: p=malloc(4)
then we represent all the memory locations allocated in Lby a sin-
gle allocation site ASL. We then say that pmay point to allocation
siteASL,andiftheprogramcontains p=q,wesaythesameabout
354
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Trabish, Mattavelli, Rinetzky and Cadar
q.Thenodesofthepoints-tographofaprogramarethevariable
names and allocation sites, and its edges represent points-to rela-
tions:Anedgefromnode vtowmeansthatthememorylocation
represented by vmay hold a pointer to w.
Thepoints-tograph,whichiscomputedonceforeveryprogram,
conservatively represents all the possible points-to relations in any
possible program execution. Using the points-to graph, we use a
standard may-mod analysis (see, e.g., [ 1]), in which we find the
side effects of every function f, i.e. the set of possible locations,
represented by their allocation sites, that the function itself or any
function that it may (transitively) invoke, may modify.
Duringthechoppedsymbolicexecution,weinstrumentthesym-
bolicstatetorecordtheallocationsiteofeverymemorylocation.
Thisinstrumentation, togetherwiththe programpoints-tograph,
allows mayMod to determine whether a skipped function may
write to a given address. Recall that the pointer analysis is flow-
insensitive,andthusitmightrecordthataskippedfunctionmay
modify a location which is updated later on in the symbolic ex-ecution. More specifically, a
loadinstruction from address addr
isdependent on an invocation of a skipped function if and only if:
(1)addrisamongthelocationsthat maybemodifiedbytheskipped
function (according to the may-mod analysis), and (2) no stores to
thatlocationhappenedbetweentheskippedinvocationfunction
and the load. In particular, when the second condition does not
hold, no recovery is needed as the stores performed by the skipped
functionareirrelevant. mayMod ()utilisestheinformationgathered
during the symbolic execution regarding overwritten locations (al-
gorithm 1, line 42) to refine on-the-fly the detection of the relevant
side effects of skipped functions.
3.2 Multiple Recovery States
Insomecases,weneedtocreateseveralrecoverystatesduringa
single chopped symbolic execution.
For example, consider the following code fragment which re-
places lines 7 to 12 of the main()function in Figure 2:
7f(&p,k); // skip
8// next two branches depend on the side effects of f
9if(p.x)
10 p.z++;
11if(p.y)
12 p.z--;
If we wish to skip the invocation to f()then a recovery state
andadependentstatearecreatedateachofthebranchesonlines9
and 11. Note that the second dependent state is produced from
the first dependent one and that the resumed state encapsulatesthe changes made by the first recovery state. Assume that these
changes involve a modification of the value of p.xinside the k>0
branch at line 20. If the symbolic execution of the second recovery
state goes through the path in which p.yis updated ( k≤0), the
induced combined execution would be infeasible. To avoid this
undesirable situation, when a recovery state terminates, it adds the
newconstraintsaccumulatedinitspathconditiontothe guiding
constraints ofitsdependentstate.Theaddedconstraintsarethen
used in subsequent recovery states. In our example in Figure 2, the
constraint k>0ispropagatedfromthe firstrecoverystatetothe
first dependent state, thus ensuring that the symbolic execution of
the second recovery state does not follow an infeasible path.1struct point { int x, y;};
2void f1(struct point *p) {
3 p->y = 1;
4}
5void f2(struct point *p) {
6 if(p->y)
7 p->x = 1;
8}
9void g() {
10 struct point p;
11 f1(&p); // skip
12 f2(&p); // skip
13 if(p.x) {
14 // ...
15 }
16}
Figure 3: Multiple skipped functions.
3.3 Handling Multiple Skipped Functions
So far, we have assumed that every symbolic state has at most one
skipped invocation. When multiple invocations are skipped andmore than one may modify the dependent load address
addr,w e
needtodecidewhichfunctionstouseforrecoveryandinwhichorder. We solve this issue by executing the skipped invocationsaccording to their order along the path, thus ensuring that the
value stored in
addrat the end of the recovery process is indeed
the last value written there along the chopped path.
Anotherissuethatweneedtoaddresstosupportmultipleskipped
functions is that a skipped invocation might depend on the side
effectsofanearlierskippedfunction.Whenthishappens,weap-
ply our recovery approach in a recursive manner, and treat the
currentrecovery stateas a dependent state.For example,consider
the code in Figure 3. When the execution reaches the dependentload at line 13, we create a recovery state for
f2, since f1does
not modify the field x. When the created recovery state reaches
the load instruction at line 6, it identifies it as a dependent load.
Choppedsymbolicexecutionthencreatesanotherrecoverystate
whichexecutes f1.Oncetherecoveryof f1isterminated,wecan
continue with the recovery of f2.
To make the symbolic execution more efficient in these cases,
we maintain for each state a recovery cache. The recovery cache
records foreach skippedinvocation andslice, theresulting values
which were written by the skipped function during the recovery
process.Thisenablesustoavoidre-executingtherecoveryprocessincertaincases.Forexample,if
ghadread p->yaftertheinvocation
off2, we could have found the value of p->yin the cache.
3.4 Memory Allocations
LetusconsidertheexamplefromFigure4,wheretheskippedfunc-
tion fallocates memory with malloc. After skipping the function
callatline7,thechoppedsymbolicexecutionencounterstwode-
pendent loads at lines 8 and 9 and thus spawns two consecutive
recoverystates:onewhichexecutesonlyline3(asline4isremoved
by the static slicer), and one which executes lines 3 and 4. If we
allowed mallocto return two different addresses while executing
the recovery states, this could lead to an incorrect execution since
the second recovery would write to a different memory address.
To prevent this, and maintain consistency across recovery states
355
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. Chopped Symbolic Execution ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
1struct point { int x, y; } *p = NULL;
2void f() {
3 p = malloc(sizeof(struct point));
4 p->x = 0;
5}
6void g() {
7 f(); // skip
8 if(p)
9 if(p->x) {
10 // ...
11 }
12}
Figure 4: Example of skipped function with allocation.
originating from the same function call, we maintain a list of re-
turned addresses for each allocation site in f, which are identified
by theircall stack.This way, subsequent recovery stateswill use
this information while re-executing allocating instructions. Other
nondeterministic routines, such as random, can be handled in a
similar way.
3.5 Chopping-Aware Search Heuristic
Searchheuristicsarethe mainapproachtoreducepathexplosion
andsteersymbolicexecutiontouncoveredpathsforamoreeffec-
tive exploration [ 10–12,43], and chopped symbolic execution is
noexception.However,theseheuristicsdonottakeintoaccount
the particular nature ofthestates inchopped symbolicexecution,
particularly the distinction between normal and recovery states.
Weproposea chopping-awaresearchheuristic,whichattempts
to optimize the exploration of chopped symbolic execution. The
search heuristic favors the selection of normal states, which donot require any recovery, thus fostering code exploration. Sincealways favoring normal states over recovery states may lead tosaturation in code exploration, we allow the searcher to select arecovery state at a lower probability. Through experimentation,
we determined that choosing to execute a recovery state with a
probabilityof0.2producesthebestresults,andthisisthevaluewe
use in our evaluation.
Technically, we maintain two worklists, one for normal states
andone forrecoverystates. Whenthesymbolic executionengine
selects the next state to explore, it first selects a worklist according
tothespecifiedprobability,andonlythenextractsthenextstate.
As a result, it is possible to manage the two worklists according to
different heuristics.
3.6 Limitations
The current main limitation of the technique is related to symbolic
addresses.Handlingasymbolicaddressisdifficult,asitmayrefer
to multiple allocation sites, which in turn may lead to the recovery
ofseveraldifferentskippedfunctions.Moreover,choppedsymbolic
execution needs a concrete load address to update when stores are
performed to that address during recovery.
Choppedsymbolicexecutioncurrentlyfocusesonskippingfunc-
tions. However, the approach is more generic: In theory, we could
skip any arbitrarycode portion that preserves the control-flowof
the program. We are currently working on such an extension, par-
ticularly ondesigning an appropriateAPI forspecifying arbitrary
code portions to skip.4 IMPLEMENTATION
We implemented chopped symbolic execution into Chopper, an
extensiontotheKLEEsymbolicexecutionengine[ 11].Wemake
Chopper available at https://srg.doc.ic.ac.uk/projects/chopper/.
WeforkedKLEEfromcommit b2f93ff.AusercanrunChopper
byspecifying thelistof functionstoskip alongwith specific call
sites via command-line switches.
Choppercombinesstaticanalysis—inparticularmod-refanaly-
sisandslicing—withsymbolicexecution.SinceKLEEoperateson
LLVM bitcode, we rely on libraries that statically analyse LLVM
bitcode. In particular, we implemented a library for static analysis
that exposes APIs to KLEE, so new or better static analyses can be
integrated in Chopper with ease.
We compute mod-ref analysis by using the pointer analysis pro-
vided bySVF [ 38]. Inparticular, we rely ona flow-insensitive and
context-insensitive pointer analysis based on the Andersen algo-
rithm [4]. We compute static backward slicing using the DG static
slicer [20]. We modified the slicer to be able to generate slices of
arbitrary functions and not only of the entry point of the program.
Notethatstaticslicingiscomputedon-demand,whenarecovery
isrequired.Thesameslicemaybereusedformultiplerecoveries,
so each slice is computed only once.
5 EXPERIMENTAL EVALUATION
Ourevaluationaimstoprovidepreliminaryevidencethatthisnovel
form of symbolic execution can lead to significant scalability gains.
Morespecifically,weevaluateitseffectivenesswhenembodiedin
the following two scenarios:
(1)Failurereproduction ,wheretheresearchquestionweexplore
is:Howdoeschoppedsymbolicexecutionperformwithrespect
to standard symbolic execution in generating an input that
triggers a failure? In particular, can it reproduce more failures
thanstandardsymbolicexecution,orcanitreproducethesame
failures faster?
(2)Testsuiteaugmentation ,wheretheresearchquestionweex-
plore is: How does chopped symbolic execution perform when
steered to generate test cases that improve the structural cover-
age of code? Can chopped symbolic execution complement the
exploration of standard symbolic execution?
Note that our objective is not to claim that chopped symbolic
execution is generally a superior technique for a specific task—
and thus omits a direct comparison with other state-of-the-arttechniques for each scenario—but rather to assess the attainable
benefitsofchoppedsymbolicexecutionwhenappliedtotechniques
built upon symbolic execution engines.
WecompareChopperwithbaselineKLEE.WeusethesameKLEE
commit( b2f93ff)fromwhichwebasedChopper.Bothtoolsare
compiled with LLVM 3.4.2 [ 29] and use STP 2.1.2 as the constraint
solver[22].WeconductourexperimentsonserversrunningUbuntu
14.04,equippedwithan8-coreIntelprocessorat3.5GHzand16GB
of RAM.
5.1 Failure Reproduction
In thisexperiment weuse choppedsymbolic executionfor failure
reproduction.Inparticular,werunasymbolicexecutortogenerate
inputs that trigger known security vulnerabilities.
356
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Trabish, Mattavelli, Rinetzky and Cadar
Table 1: Security vulnerabilities and libtasn1 versions con-
sidered for reproduction.
Vulnerability Version C SLOC
CVE-2012-1569 2.11 24,448
CVE-2014-3467 3.5 22,091
CVE-2015-2806 4.3 28,115
CVE-2015-3622 4.4 28,109
Benchmarks. The subjects of this part of the evaluation are vul-
nerabilities taken from GNU libtasn1. As briefly discussed in the
introduction, GNU libtasn1is a library for serialising and deseri-
alisingdatainAbstractSyntaxNotationOne(ASN.1)format.For
example, libtasn1is used in GnuTLS to define X.509 certificates.
Weselectedthe libtasn1librarybecauseitscodeiscomplex,with
nested and deep function calls, and can be successfully analysed
by the KLEE symbolic executor. Table 1 lists the vulnerabilities
selected for our experiment, which are memory out-of-bounds ac-
cesses. Note that each vulnerability requires the reproduction of a
singlefailure,exceptforCVE-2014-3467,forwhichthevulnerability
canbeexploitedinthreedifferentcodelocations,soweconsider
three different failures. Therefore, in this experiment we aim to
reproduce a total of six failures.
Methodology. Weproceedwiththefollowingevaluationprocess:
(1)We manually create an execution driver for the libtasn1library
to exercisethe library from itspublic interface, simulating the
interactions of an external program (e.g., GnuTLS).
(2)Wemanuallyderivethesetoffunctionstoskipbyinspecting
thecodeandthevulnerabilityreportwhichusuallyincludesthe
stack trace and sometimes results from a dynamic analysis tool
(e.g., Valgrind[ 31]).For theselected casestudieswemanaged
to identify a candidate set of function to exclude in less than
30minutesperfailure,butadeveloperfamiliarwiththecode
should be able to do so faster.
(3)WeinvokeKLEEandChopperonthesubjectwithseveraldif-
ferent search heuristics for normal states (random, DFS, and
coverage-based7)andDFSforrecoverystates.Weuseatimeout
of 24 hours. We also configure the symbolic executors to termi-
nate the execution as soon as the vulnerability is identified. WedothatbyaddinganewoptiontoKLEEthat,givenalistofcodelocations, terminates the execution as soon as a vulnerability is
discovered at all locations.
Results.Table 2 summarises the high-level results of our failure
reproduction experiment. For each vulnerability and search heuris-
ticwereporttheeffectivenessofKLEEandChopperatreproducing
thefailureasthetimerequiredtogenerateaninputthattriggers
the vulnerability.
As can be seen, Chopper outperforms KLEE on all but one case
studybothintermsofnumberoffailuresreproducedandperfor-
mance, regardless of the search heuristic applied. Overall, KLEE
reproducesfourfailures,CVE-2014-3467 1,CVE-2014-3467 2,CVE-
2015-2806 and CVE-2015-3622, and only failure CVE-2014-3467 1
can be reproduced with all search heuristics. This latter case seems
7KLEE searchoptions dfs, random-state andnurs:covnew respectively.Table 2: Results for the failure reproduction experiment on
libtasn1. For each case we report either the time requiredforexplorationifthevulnerabilitywasreproducedsuccess-fully(in mm:ss),Timeout(ifexecutionisterminatedafter24
hours), or OOM (if the execution runs out of memory, withthe respective time at which this happened).
Vulnerability Search KLEE Chopper
CVE-2012-1569Random OOM (11:52) 02:27
DFS OOM (05:08) 03:29
Coverage OOM (11:28) 02:45
CVE-2014-3467 1Random 00:05 00:45
DFS 16:31 00:08
Coverage 00:03 00:58
CVE-2014-3467 2Random 1:02:13 06:18
DFS Timeout 00:09
Coverage 1:33:56 02:48
CVE-2014-3467 3Random Timeout 09:55
DFS Timeout 12:31
Coverage Timeout 09:50
CVE-2015-2806Random 1:07:46 02:18
DFS 2:46:13 12:04
Coverage OOM (38:56) 01:02
CVE-2015-3622Random Timeout 00:16
DFS Timeout 18:41
Coverage 20:25:20 00:18
to be relatively easy to identify, since KLEE requires only a few
seconds.Ontheothercases,KLEErequiresbetween1and20hours.
The problem of path explosion in KLEE is particularly visible in
CVE-2012-1569wherethesymbolicexecutorquicklyrunsoutof
available memory (4096 MB) and thus fails to reproduce the failure.
Incontrast,Choppercanidentifyallvulnerabilitiesandgener-
ates a test case to reproduce each failure in less than 20 minutes,and often much faster. Overall, for the vulnerabilities that KLEE
can also reproduce, Chopper can significantly beat KLEE in terms
of performance by at least an order of magnitude, with the only
exceptionof CVE-2014-3467 1whereChoppercan be slowed by the
cost of static analyses.
Table3summarisesthedetailedresultsofChopperforthefail-
ure reproduction experiment. For each vulnerability and searchheuristicwereportthe numberof snapshots andrecoverystates
generatedduringchoppedsymbolicexecution(SnapshotsandRe-
coveries,respectively),theexecutiontimesforChopperwithand
withoutslicing(Sliced FandFullF,respectively)aswellassta-
tistics on the generated slices, which includes the number of slices
generated (Num), and the total size of the original ( Fsize) and
sliced (S size) skipped functions in terms of LLVM instructions.
Table 3 shows that the number of skipped function calls (as
deduced by the number of snapshot states) and recovery states
varies with the nature of the case study, the skipped functions, and
the search heuristic. In the case of vulnerability CVE-2015-2806,Chopper could reproduce the failure without recovering. This is
the exemplar case that highlights the benefits of chopped symbolic
execution: While KLEE spent hours interpreting code unrelated
357
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. Chopped Symbolic Execution ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Table 3: Detailed results of Chopper for the failure reproduction experiment on libtasn1.
Vulnerability Search Snapshots RecoveriesFunction Slice
FullFSlicedFNumFSizeSSize
CVE-2012-1569Random 5,315 7,447 01:21 02:27 4 694 320 (46%)
DFS 381 1,078 00:10 03:29 4 694 320 (46%)
Coverage 6,258 9,053 01:53 02:45 4 694 320 (46%)
CVE-2014-3467 1Random 6,607 6,883 00:30 00:45 4 3,740 2,318 (62%)
DFS 656 1,003 00:07 00:08 4 3,740 2,318 (62%)
Coverage 5,642 7,357 00:50 00:58 4 3,740 2,318 (62%)
CVE-2014-3467 2Random 16,279 26,300 07:38 06:18 4 3,740 2,318 (62%)
DFS 656 1,003 00:11 00:09 4 3,740 2,318 (62%)
Coverage 10,147 18,916 04:43 02:48 4 3,740 2,318 (62%)
CVE-2014-3467 3Random 26,762 43,480 17:30 09:55 4 3,740 2,318 (62%)
DFS 38,696 61,113 17:07 12:31 4 3,740 2,318 (62%)
Coverage 30,947 42,797 17:13 09:50 4 3,740 2,318 (62%)
CVE-2015-2806Random 173,065 002:31 02:18 - - -
DFS 2,708,849 012:30 12:04 - - -
Coverage 36,549 001:04 01:02 - - -
CVE-2015-3622Random 584 8,980 00:25 00:16 6 1,269 343 (27%)
DFS 23,846 20,188 21:24 18:41 7 1,453 398 (27%)
Coverage 608 9,043 00:23 00:18 6 1,269 343 (27%)
with the failure, Chopper excluded the uninteresting code portions
and could proceed analysing only code of interest, consistently
identifyingthefailurewithallsearchheuristicsinaslittleasone
minute.
Table3alsoshowsthatthebenefitofslicingtheskippedfunc-
tions depends on the case study. For example, for the CVE-2014-
34673vulnerability, Chopper is on average 70% faster when slicing
theskippedfunctions.Conversely,Chopperperformsthebestwith-
out slicingin CVE-2012-1569.A plausibleexplanation isthat the
additional analyses requiredfor slicingwere moreexpensive than
directly analysing the functions. We plan to develop a lightweight
analysis to speculatively identify when to apply slicing on the
skipped functions.
5.2 Test Suite Augmentation
In this experiment we use chopped symbolic execution for test
suiteaugmentation.WedothatbyrunningChopperonasubject
program where we skip functions already exercised by an existing
testsuite.AsinitialtestsuitewerelyontestsgeneratedbyKLEE.
Inessence,wewanttoassesstheeffectivenessofchoppedsymbolic
executionincomplementingstandardsymbolicexecutionintest
generation, for the goal of increasing structural coverage.
Benchmarks. ThesubjectsofthispartoftheevaluationareGNU
BC2.27,LibYAML 0.1.5,andGNUoSIP4.0.0. BC8isanarbitrary-
precisioncalculatorthatsolvesmathematicalexpressionswrittenin
a C-style language. LibYAML9is a well-known library for parsing
and emitting data in YAML format, which is a human-friendly
dataserialisationstandard. oSIP10implementstheSIPprotocoland
providesaninterfaceforcreatingSIPbasedapplications.Wechoose
8https://www.gnu.org/software/bc
9https://pyyaml.org/wiki/LibYAML
10https://www.gnu.org/software/osipthese benchmarksbecause KLEE hasa hard timegenerating high-
coveragetests.Asaresult,thecodenotcoveredbyKLEEisusually
related to complex features, and we challenge Chopper to exercise
it. For each program, we rely on the program’s documentation and
personal experience with the subject to identify the best argument
configuration that can maximise coverage.
Methodology. Weproceedwiththefollowingevaluationprocess:
(1)We generate the initial test suite by running KLEE on each
subjectwiththecoverage-basedsearchheuristicandatimelimit
ofonehour.Weusethisconfigurationtomaximisestructural
coverageofthecodeunderanalysis,inparticularwefocuson
line and branch coverage.
(2)We compute the structural coverage obtained with the test
suites that KLEE generates using GNU GCov.11
(3)Weusethecoverageinformationandthecallgraphtoselectfor
eachprogramthesetoffunctionstoskip.Forexample,suppose
that function fcalls function дandh, and that fandhare
coveredbyatest.Weincludeinthesetoftheskippedfunctions
onlyh, sincefis required to reach uncovered function д.
(4)We invoke Chopper on the subjects with the coverage-based
search heuristic for normal states and DFS for the recovery
states. We use a timeout of one hour.
Results.Table 4 summarises the results of our test suite augmen-
tationexperiment.Foreachcasestudywereportthestructuralcov-
erageofasymbolicexecutoraspercentagesoflinesandbranches
coveredbyitsgeneratedtestsuite.ForKLEE+Chopperwereport
thestructuralcoverageresultswithandwithoutperformingslicing
(SlicedFand FullF, respectively).
Table 4 shows that Chopper effectively complements KLEE and
increases code coverage even on complex subjects. Specifically, on
11https://gcc.gnu.org/onlinedocs/gcc/Gcov.html
358
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Trabish, Mattavelli, Rinetzky and Cadar
Table 4: Line (L) and branch (B) coverage achieved by KLEE
and KLEE+Chopper for BC,LibYaml andoSIPin one hour.
ProgramKLEEKLEE+Chopper
FullF SlicedF
LBLBLB
BC 23.2% 15.6% 26.6% 19.9% 27.2% 20.8%
LibYAML 10.8% 4.2% 19.9% 11.5% 19.9% 11.5%
oSIP 5.7% 5.1% 9.8% 8.7% 9.8% 8.7%
BC,Chopperincreasedstatementandbranchcoverageby4%and
5.2%, respectively; on LibYAML it approximately doubled coverage;
and inoSIPit also led to significant gains.
InBC, Chopper managed to skip expensive functions that ini-
tializetheparsingoftheinputfileandreachedtheactualparsing
functions.Unfortunately,theanalysisquicklygotstuckinthepars-
ing routine due to timeouts in theconstraint solver, resultingin a
limited increase in coverage.
In the case of LibYAML we observed that KLEE spent almost
allitsbudgetanalysingonefunctionthatcontainscomplexlogic
responsibleforensuringthatthebuffercontainsenoughcharacters
forparsingwhilehandlingdifferentencodings,suchasUTF-8or
UTF-16. This function is invoked at the beginning of program
execution, and KLEEgot stuck in it,not being able toexecute any
subsequentlineofcode.Conversely,Chopperskippedtheexpensive
invocationandcontinuedtoexploreotherpartsofthecode.Our
chopping-awaresearchheuristicalsoallowedustorecoverpaths
insidetheexpensivefunctionwhilegivinghigher prioritytonon-
recovery states, in turn resulting in a more in-depth exploration of
the code.
A similar scenario was encountered in oSIP, where KLEE spent
aconsiderableamountofresourcesonawhitecharacterprocess-
ing routine which is invoked at the beginning of the execution.
By skipping this routine, Chopper was able to perform a deeper
exploration of the code.
As for the previous experiment, the benefit of slicing strictly de-
pendsonthecasestudy.Inthisexperiment,slicingisnotbeneficial
inLibYAML andoSIP, while it leads to increased coverage in BC.
5.3 Threats to Validity
Herewebrieflydiscussthecountermeasuresweadoptedtomitigatethe threats to validity. The internal validity depends on the correct-
nessofourprototypeimplementation,andmaybethreatenedby
the evaluation setting and the execution of the experiments. Wecarefully tested our prototype with respect to the original KLEE
baseline, and make it available for further inspection.
Threats to external validity may derive from the selection of
benchmarks.Wevalidatedourapproachonthreereal-worldsub-
jects. Different results could be obtained for different subjects. The
only way to further reduce the external validitythreatconsists in
replicating our study on more subjects. For this reason we make
ourexperimentalpackagepubliclyavailabletootherresearchers.12
12https://srg.doc.ic.ac.uk/projects/chopper/6 RELATED WORK
The research community has invested significant effort in address-
ing the path explosion challenge in symbolic execution, and this
paper aligns with this line of work.
As we already mentioned in the introduction, the most com-
mon and often most effective mechanism employed by symbolicexecutors are search heuristics, whose goal is to guide programexploration to the most promising paths in the program. Popu-
larheuristicsincluderandompathexploration[ 11],generational
search [25] and coverage-optimized search [ 10,12], to name just
a few. Unfortunately, search heuristics only partly alleviate path
explosion,andsymbolicexecution canstillgetstuckinirrelevant
parts of the code.
Anothereffectivetechniqueistotrytopruneequivalentprogram
paths [8,9]. For instance, if a path reaches a program point with a
setofconstraintsequivalenttothoseofapreviouspaththatreached
thatpoint,thenthesecondpath(andallpathsthatitwouldhave
spawned)canbeterminated.Thistechniqueissimilarinspiritto
our approach, but orthogonal, as it does nothing to prevent the
explorationofcodeirrelevanttothetaskathand.Choppedsymbolic
executioncanbecombinedwith pathpruning,inorder topruneboth irrelevant paths, as well as those relevant paths which are
equivalent to other relevant paths.
Merging paths can also help alleviate path explosion. Paths can
be merged either ahead-of-time [ 17,18] or at runtime [ 28,36]. A
particular type of path merging are function summaries, in which
paths within a function are merged into a summary that can bereused on subsequent invocations [
2,23]. Path merging can lead
to exponentialreduction in the numberof paths explored, butthe
cost is often offloaded to the constraint solver, which has to deal
with significantly harder constraints. Again, chopped symbolic
execution could be combined with path merging, in order to get
the benefit of both.
Chopped symbolic execution makes use of program slicing in
ordertoexploreonlytherelevantpartsofcodethroughtheskippedfunctions.Programslicinghasbeenexploredinsymbolicexecution
before, e.g., in the context of patch testing [6].
7 CONCLUSION
Choppedsymbolicexecutionisanovelformofsymbolicexecution
whichallows userstospecifyuninteresting partsofthecode that
can be excluded during analysis, thus focusing the exploration on
those paths most relevant to the task at hand. Our preliminaryevaluation shows that chopped symbolic execution can lead to
significant improv ements in scalability for different scenarios such
as vulnerability reproductionand test suite augmentation.Future
work can explore these scenarios and others in more depth, aim to
further automate the identification of functions to skip, and extend
the approach with the ability to skip arbitrary code fragments.
Acknowledgements. We thank the ICSE reviewers, Frank Busse
and Timotej Kapus for their useful comments on the paper. This
researchwassupportedinpartbytheUKEPSRCthroughgrants
EP/N007166/1 and EP/L002795/1, by Len Blavatnik and the Blavat-
nik Family foundation, Blavatnik Interdisciplinary Cyber Research
Center at Tel Aviv University and the Pazy Foundation.
359
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. Chopped Symbolic Execution ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
REFERENCES
[1]A.V.Aho,M.S.Lam,R.Sethi,andJ.D.Ullman. Compilers:Principles,Techniques,
and Tools. Addison Wesley, 2nd edition, 2006.
[2]S.Anand,P.Godefroid,andN.Tillmann. Demand-drivencompositionalsymbolic
execution. In Proc.ofthe14thInternationalConferenceonToolsandAlgorithms
for the Construction and Analysis of Systems (TACAS’08), Mar.-Apr. 2008.
[3]S.Anand,C.S.Păsăreanu,andW.Visser. JPF-SE:ASymbolicExecutionExtension
to Java PathFinder. In Proc. of the 13th International Conference on Tools and
Algorithms for the Construction and Analysis of Systems (TACAS’07), Mar.-Apr.
2007.
[4]L. O. Andersen. Program Analysis and Specialization for the C Programming
Language. PhD thesis, 1994.
[5]A.Aquino,F.A.Bianchi,C.Meixian,G.Denaro,andM.Pezzè. Reusingconstraint
proofsinprogram analysis. In Proc.ofthe InternationalSymposiumonSoftware
Testing and Analysis (ISSTA’15), July 2015.
[6]D. Babić, L. Martignoni, S. McCamant, and D. Song. Statically-directed dynamic
automatedtestgeneration. In Proc.oftheInternationalSymposiumonSoftware
Testing and Analysis (ISSTA’11), July 2011.
[7]D. Binkley and M. Harman. A survey of empirical results on program slicing.
Advances in Computers, 62:105–178, 2004.
[8]P. Boonstoppel, C. Cadar, and D. Engler. RWset: Attacking path explosion in
constraint-basedtestgeneration. In InternationalConferenceonToolsandAlgo-
rithms for the Construction and Analysis of Systems, 2008.
[9]S. Bugrara and D. Engler. Redundant state detection for dynamic symbolic
execution. In Proc. of the 2013 USENIX Annual Technical Conference (USENIX
ATC’13), June 2013.
[10]J.BurnimandK.Sen. Heuristicsforscalabledynamictestgeneration. In Proc.
of the 23rd IEEE International Conference on Automated Software Engineering
(ASE’08), Sept. 2008.
[11]C.Cadar,D.Dunbar,andD.Engler. KLEE:UnassistedandAutomaticGeneration
of High-Coverage Tests for Complex Systems Programs. In Proc. of the 8th
USENIX Symposium on Operating Systems Design and Implementation (OSDI’08),
Dec. 2008.
[12]C.Cadar,V.Ganesh,P.Pawlowski,D.Dill,andD.Engler. EXE:AutomaticallyGenerating Inputs of Death. In Proc. of the 13th ACM Conference on Computer
and Communications Security (CCS’06), Oct.-Nov. 2006.
[13]C. Cadar, P. Godefroid, S. Khurshid, C. Pasareanu, K. Sen, N. Tillmann, and
W. Visser. Symbolic Execution for Software Testing in Practice—Preliminary
Assessment. In Proc. of the 33rd International Conference on Software Engineering,
Impact Track (ICSE Impact’11), May 2011.
[14]C.CadarandK.Sen. SymbolicExecutionforSoftwareTesting:ThreeDecades
Later.Commun. ACM, 56(2):82–90, 2013.
[15]S. K. Cha, T. Avgerinos, A. Rebert, and D. Brumley. Unleashing Mayhem on
binarycode. In Proc.oftheIEEESymposiumonSecurityandPrivacy(IEEES&P’12) ,
May 2012.
[16]V. Chipounov and G. Candea. Reverse engineering of binary device drivers with
revnic. In Proc. of the 5th European Conference on Computer Systems (EuroSys’10),
Apr. 2010.
[17] P. Collingbourne,C. Cadar,andP. H.Kelly. Symboliccrosscheckingof floating-
pointandSIMDcode. In Proc.ofthe6thEuropeanConferenceonComputerSystems
(EuroSys’11), Apr. 2011.
[18]P. Collingbourne, C. Cadar, and P. H. Kelly. Symbolic crosschecking of data-parallel floating-point code. IEEE Transactions on Software Engineering (TSE),
40(7):710–737, 2014.
[19]L. De Moura and N. Bjørner. Satisfiability modulo theories: introduction and
applications. Commun. ACM, 54(9):69–77, Sept. 2011.
[20] DG website. https://github.com/mchalupa/dg.
[21]I.EreteandA.Orso. Optimizingconstraintsolvingtobettersupportsymbolic
execution. In Proc.oftheWorkshoponConstraintsinSoftwareTesting,Verification,
and Analysis (CSTVA’11), Mar. 2011.
[22]V.GaneshandD.L.Dill. Adecisionprocedureforbit-vectorsandarrays. In Proc.
of the 19th International Conference on Computer-Aided Verification (CAV’07), July
2007.
[23]P.Godefroid. Compositionaldynamictestgeneration. In Proc.ofthe 34thACM
Symposium on the Principles of Programming Languages (POPL’07), Jan. 2007.[24]P.Godefroid,N.Klarlund,andK.Sen. DART:Directedautomatedrandomtesting.
InProc. of the Conference on Programing Language Design and Implementation
(PLDI’05), June 2005.
[25]P.Godefroid,M.Y.Levin,andD.A.Molnar. Automatedwhiteboxfuzztesting. In
Proc.of the15thNetworkandDistributed SystemSecuritySymposium (NDSS’08),
Feb. 2008.
[26]M.Hind. Pointeranalysis:Haven’twesolvedthisproblemyet? In Proc.ofthe
2nd ACM SIGPLAN-SIGSOFT Workshop on Program Analysis for Software Tools
and Engineering (PASTE’01), June 2001.
[27]X.Jia,C.Ghezzi,andS.Ying. Enhancing reuseofconstraint solutionsto improve
symbolicexecution. In Proc.oftheInternationalSymposiumonSoftwareTesting
and Analysis (ISSTA’15), July 2015.
[28]V. Kuznetsov, J. Kinder, S. Bucur, and G. Candea. Efficient state merging in
symbolicexecution. In Proc.oftheConferenceonProgramingLanguageDesign
and Implementation (PLDI’12), June 2012.
[29]C.LattnerandV.Adve. LLVM:Acompilationframeworkforlifelongprogram
analysis &transformation. In Proc. ofthe 2nd International Symposiumon Code
Generation and Optimization (CGO’04), Mar. 2004.
[30]T. Liu, M. Araújo, M. d’Amorim, and M. Taghdiri. A comparative study of
incremental constraint solving approaches in symbolic execution. In Proc. of the
Haifa Verification Conference (HVC’14), Nov. 2014.
[31]N. Nethercote and J. Seward. Valgrind: A program supervision framework.
Electronic Notes in Theoretical Computer Science, 89(2), 2003.
[32]H. D. T. Nguyen, D. Qi, A. Roychoudhury, and S. Chandra. SemFix: Program
repair via semantic analysis. In Proc. of the 35th International Conference on
Software Engineering (ICSE’13), May 2013.
[33]H. Palikareva and C. Cadar. Multi-solver support in symbolic execution. In Proc.
of the 25th International Conference on Computer-Aided Verification (CAV’13), July
2013.
[34]D.M.Perry,A.Mattavelli,X.Zhang,andC.Cadar. Acceleratingarrayconstraints
insymbolicexecution. In Proc.oftheInternationalSymposiumonSoftwareTesting
and Analysis (ISSTA’17), July 2017.
[35]K. Sen, D. Marinov, and G. Agha. CUTE: A concolic unit testing engine for C. In
Proc. of the joint meeting of the European Software Engineering Conference and the
ACM Symposium on the Foundations of Software Engineering (ESEC/FSE’05), Sept.
2005.
[36]K.Sen,G.Necula,L.Gong,andW.Choi. Multise:Multi-pathsymbolicexecution
using value summaries. In Proc. of the joint meeting of the European Software
EngineeringConferenceandthe ACMSymposiumontheFoundationsofSoftware
Engineering (ESEC/FSE’15), Aug.-Sept. 2015.
[37]Y. Smaragdakis and G. Balatsouras. Pointer analysis. Found. Trends Program.
Lang., 2(1):1–69, Apr. 2015.
[38]Y.Sui andJ. Xue. SVF: Interproceduralstaticvalue-flowanalysisin LLVM. In
Proc.ofthe25thInternationalConferenceonCompiler Construction(CC’16),Mar.
2016.
[39]N. Tillmann and J. De Halleux. Pex: white box test generation for .NET. In Proc.
of the 2nd International Conference on Tests and Proofs (TAP’08), Apr. 2008.
[40]F.Tip.Asurveyofprogramslicingtechniques. JournalofProgrammingLanguages,
3(3):121–189, 1995.
[41]W.Visser,J.Geldenhuys,andM.B.Dwyer.Green:reducing,reusingandrecycling
constraints in program analysis. In Proc. of the ACM SIGSOFT Symposium on the
Foundations of Software Engineering (FSE’12), Nov. 2012.
[42]M. Weiser. Program slicing. In Proceedings of the 5th International Conference on
Software Engineering, ICSE ’81, pages 439–449, Piscataway, NJ, USA, 1981. IEEE
Press.
[43]T.Xie, N.Tillmann, J.Halleux,and W.Schulte. Fitness-guidedpath exploration
indynamicsymbolicexecution. In Proc.ofthe2009InternationalConferenceon
Dependable Systems and Networks (DSN’09), June 2009.
[44]B. Xu, J. Qian, X. Zhang, Z. Wu, and L. Chen. A brief survey of program slicing.
SIGSOFT Softw. Eng. Notes, 30(2):1–36, Mar. 2005.
[45]G. Yang, C. S. Păsăreanu, and S. Khurshid. Memoized symbolic execution. In
Proc. of the International Symposium on Software Testing and Analysis (ISSTA’12),
July 2012.
360
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. 