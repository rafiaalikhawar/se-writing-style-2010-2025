Detecting Semantic Merge ConÔ¨Çicts
with Variability-Aware Execution
Hung Viet Nguyen
ECpE Department
Iowa State University, USAMy Huu Nguyen
Ho Chi Minh City University of
Science, VietnamSon Cuu Dang
University of Technology
Sydney, Australia
Christian K√§stner
School of Computer Science
Carnegie Mellon University, USATien N. Nguyen
ECpE Department
Iowa State University, USA
ABSTRACT
In collaborative software development, changes made in parallel
by multiple developers may conÔ¨Çict. Previous research has shown
that conÔ¨Çicts are common and occur as textual conÔ¨Çicts or semantic
conÔ¨Çicts , which manifest as build or test failures. With many parallel
changes, it is desirable to identify conÔ¨Çicts early and pinpoint the
(minimum) set of changes involved. However, the costs of identify-
ing semantic conÔ¨Çicts can be high because tests need to be executed
on many merge scenarios.
We propose Semex, a novel approach to detect semantic conÔ¨Çicts
using variability-aware execution. We encode all parallel changes
into a single program, in which ifstatements guard the alternative
code fragments. Then, we run the test cases using variability-aware
execution, exploring all possible concrete executions of the com-
bined program with regard to all possible merge scenarios, while
exploiting similarities among the executions to speed up the process.
Variability-aware execution returns a formula describing all failing
merge scenarios. In our preliminary experimental study on seven
PHP programs with a total of 50 test cases and 19 semantic conÔ¨Çicts,
Semex correctly detected all 19 conÔ¨Çicts.
Categories and Subject Descriptors
D.2 [ Software Engineering ]: Testing and Debugging
General Terms
Algorithms, Reliability
Keywords
Variability-aware execution, semantic merge conÔ¨Çicts, n-way merge
1. INTRODUCTION
In collaborative software development, developers make changes
to their local copy of the project Ô¨Åles, retrieve changes from teammembers, and share the changes with them. When two or more
developers simultaneously make incompatible changes, a merge
conÔ¨Çict arises. Such conÔ¨Çicts put the codebase in an inconsistent
state and may delay the project. Due to the fear of merge conÔ¨Çicts,
developers tend to postpone merging, and this very behavior can
lead to real conÔ¨Çicts at a later time [4, 2].
Previous research has shown that conÔ¨Çicts are common and occur
as textual conÔ¨Çicts or semantic conÔ¨Çicts (i.e., build and test fail-
ures) [4]. Whereas textual conÔ¨Çicts are easy to detect by analyzing
changes in overlapping lines of code, semantic conÔ¨Çicts are more
difÔ¨Åcult to identify and resolve [9], as it requires to compile the
code and run the test suite. Brun et al. [4] reported that 33 % of the
399 merges that a VCS reported as clean merges actually contained
semantic conÔ¨Çicts. Thus, given a set of parallel changes, it is desir-
able to identify early the if any change subset contains a semantic
conÔ¨Çict , facilitating in quick accountability and corrective actions .
Several researchers have proposed mechanisms to raise aware-
ness of parallel changes to detect conÔ¨Çicts already during develop-
ment [12, 13, 1, 8]. An easy way to detect conÔ¨Çicts is to merge
changes and execute the test suite. In this context, speculative
merging actually performs merges among changes before they are
requested by developers to identify conÔ¨Çicts during parallel devel-
opment [4]. Unfortunately, the costs of speculative merging and
other approaches of conÔ¨Çict avoidance and conÔ¨Çict detection [5,
15, 3] becomes increasingly expensive as the number of changes
and branches grows because tests need to be executed on more and
more potential merge results. As any combination of changes may
conÔ¨Çict, the search space for Ô¨Ånding a minimal set of conÔ¨Çicting
changes is exponential. Even ignoring potential conÔ¨Çicts or Ô¨Åxes
among more than two changes (e.g., when a third change resolves
a conÔ¨Çict among two conÔ¨Çicting changes), comparing all pairs of
changes causes quadratic effort, which is expensive with branchma-
niabecoming a common phenomenon in many projects [2]. Delta
debugging [16] could identify a 1-minimal solution, but might not
Ô¨Ånd a global minimum.
We propose Semex, a novel approach to detect semantic conÔ¨Çicts
using variability-aware execution [10]. Semex exploits the fact
that many test executions are similar and rarely affected by the
various changes. First, we encode all parallel changes into a single
program with variability via n-way merging [6] in which we use
a Boolean patch variable to represent whether a given change is
applied to the original program. Second, we use variability-aware
execution to run the test cases. Variability-aware execution explores
all possible concrete executions of the combined program in parallel
with regard to all patch combinations and returns a propositional
This is the author‚Äôs version of the work. It is posted here for your personal use. Not for
redistribution. The deÔ¨Ånitive version was published in the following publication:
ESEC/FSE‚Äô15 , August 30 ‚Äì September 4, 2015, Bergamo, Italy
c2015 ACM. 978-1-4503-3675-8/15/08...
http://dx.doi.org/10.1145/2786805.2803208
926<?php
function A ($array ) {
     $ret = 0;
     foreach ($array as $value )
          $ret = $ret + $value ;
     return $ret;
}
function B ($array ) {
     $avg = A($array ) / count ($array );
     $variance = 0;
     foreach ($array as $value )
          $variance += ($value - $avg) * ($value - $avg);
     $variance = $variance / count ($array );
     return $variance ;
}
function C ($idx, $array ) {
     
     $sum = 0;
     foreach ($array as $value )
          $sum += $value ;
     return $array [$idx] / $sum ;
}
?>return $ret / count ($array ); P1
$avg = A($array ); P1
$sum = A($array );P2P3
<?php include "Sequence .php";
class SequenceTest extends PHPUnit _Framework _TestCase {
     public function testSequence () {
          $array = array (0, 1, 1, 2, 1);
          assertEquals (A($array ), 5);
          assertEquals (B($array ), 1.4);
          assertEquals (C(2, $array ), 0.2);
     }
} ?>if ($idx < 0 || $idx >= count ($array ))
     error _log("Index out of bounds !");(a) Sequence .php
(b) SequenceTest .php<?php
function A ($array ) {
     $ret = 0;
     foreach ($array as $value )
          $ret = $ret + $value ;
     if ($P1)
          return $ret / count ($array );
     else           
          return $ret;
}
function B ($array ) {
     if ($P1)
          $avg = A($array );
     else
          $avg = A($array ) / count ($array );
     $variance = 0;
     foreach ($array as $value )
          $variance += ($value - $avg) * ($value - $avg);
     $variance = $variance / count ($array );
     return $variance ;
}
function C ($idx, $array ) {
     if ($P3)
          if ($idx < 0 || $ idx >= count ($array ))
               error _log("Index out of bound !");
     if ($P2)
          $sum = A($array );
     else {
          $sum = 0;
          foreach ($array as $value )
               $sum += $value ;
     }
     return $array [$idx] / $sum ;
}
?>(c) Sequence .php (after variability -aware merging )
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
351
2
3
4
5
6
7
8
9assertEquals (A($array ), 1); P1
This assertion fails after the merge .Figure 1: A semantic merge conÔ¨Çict (parts a/b) and the resulting variability-aware merge by our approach in Section 3 (part c)
Table 1: Assertion results on different combinations of the in-
corporated changes by three developers P1,P2, and P3
P1 P2 P3 C(2, $array) assertEquals(C(2, $array), 0.2)
Yes Yes Yes 1 Fail
Yes Yes No 1 Fail
All 6 other cases 0.2 Pass
formula describing all subsets of those changes for which a test
case fails . The formula describes exactly which changes conÔ¨Çict,
including the minimum set. In our preliminary experimental study
on seven example PHP applications with a total of 50 test cases and
19 semantic conÔ¨Çicts, Semex correctly detected all 19 conÔ¨Çicts in
which the set of conÔ¨Çicting parallel changes reported are the actual
(minimum) conÔ¨Çicting changes. In this paper, we contribute:
1. A novel approach to detect semantic merge conÔ¨Çicts of parallel
changes using variability-aware execution
2. A preliminary experimental study showing the potential beneÔ¨Åt
of our approach for detecting semantic conÔ¨Çicts
2. MOTIV ATION
Consider a scenario of three developers collaborating on the same
simple PHP program in Figure 1a, which computes several statistics
for a sequence of numbers. SpeciÔ¨Åcally, function Ainitially com-putes the sum of the sequence, function Bcomputes its variance,
and function Creturns the ratio of a number in the sequence at a
given index over the sum of all numbers in the sequence. Suppose
that three developers P1,P2, and P3branch the current copy of the
program and make simultaneous changes in their local branches.
Developer P1changes the implementation of method Aso that it
now returns the average of the numbers in the sequence instead of
the sum. Developer P1also updates a call site of Ain method B
and its test code (Figure 1b) to reÔ¨Çect this change. At the same
time, developer P2recognizes that part of the code in method C
to compute the sum of the sequence has already been provided by
method A, without being aware that the implementation of Ahas
been modiÔ¨Åed by developer P1. Thus, P2replaces that piece of code
with a function call to A. Finally, developer P3adds an error message
for the case that the given array index in method Cis out of bounds.
If the three developers committed their changes to the main
branch, the changes would be merged without textual conÔ¨Çicts.
However, the merged version would contain a semantic error: the
assertion on line 7 of Figure 1b would fail if run on the merged
version since the code in function Cis intended to use the previous
version of function A. Note that the test case fails if and only if the
changes from developer P1andP2are both incorporated into the
main branch (see Table 1). Given multiple simultaneous changes, it
is nontrivial to identify a set of changes that directly cause a seman-
tic merge conÔ¨Çict since there could exist an exponential number of
subsets of the changes.
927Files in branch 1
Files in branch 2
Files in branch n1. Encoding 
Parallel ChangesVariability -aware 
merged files2. Variability -
Aware Execution Semantically 
conflicting filesFigure 2: Approach overview
Program with variability
Result for one
concrete programResult for all
concrete programsConcrete program
without variabilityconfigure program
variability -aware 
executionnormal 
execution
extract results
aggregate results
Figure 3: Variability-aware vs. brute-force execution [10]
3. APPROACH
We propose Semex, a novel approach to detect semantic conÔ¨Çicts
using variability-aware execution [10] (Figure 2), assuming textual
conÔ¨Çicts are already resolved. The key ideas are as follows. First, we
encode all parallel changes by using special Boolean variables called
patch variables torepresent whether a given change is applied to
the original program . The result of this step is an encoded program
with variability. To illustrate, we show the encoded program for our
motivating example in Figure 1c, in which the added ifconstructs
and the patch variables $P1,$P2, and $P3are used to encode the
changes made by the three developers. Then, to identify a semantic
conÔ¨Çict, a naive (brute-force) approach could execute the encoded
program with all possible values of the patch variables and identify
the sets of values that cause a test case to fail. To avoid the combi-
natorial explosion faced by such a brute-force approach, we instead
use variability-aware execution [10] to run the test cases. Our tool
explores all possible concrete executions of the encoded program
with regard to all possible values of the patch variables and produces
results equivalent to brute-force runs on all versions corresponding
to all combinations of the changes (Figure 3). When executed on a
test case for the encoded program, our variability-aware execution
engine returns a propositional formula describing all subsets of those
changes for which a test case fails. For instance, in our example, the
formula $P1 & $P2 describes all subsets containing changes from
P1andP2, which include the two sets fP1, P2 gandfP1, P2, P3 g.
Such a formula allows us to identify the minimum set of changes
that lead to the conÔ¨Çict. Let us detail these steps.
3.1 Encoding Parallel Changes
The goal of this step is to encode simultaneous changes by dif-
ferent developers into a single program with variability. We as-
sume that textual conÔ¨Çicts are detected Ô¨Årst by other merging tools.
Our algorithm proceeds next as follows. First, we perform n-way
comparison of nparallel versions (made by parallel changes) by
incrementally comparing pairs of versions (two-way comparison is
widely supported by advanced text-edit tools and version control
systems). The result is the alignment of code fragments in parallel
versions in which the common code fragments are aligned and code
fragments speciÔ¨Åc to a branch are shown as differences. Second,
given the aligned code fragments, we transform the original pro-gram into a new program with variability in which the shared code
fragments remain intact and the differences are surrounded by if/else
constructs with newly introduced patch variables representing the
changes made by developers. For example, on line 6 of Figure 1a,
developer P1changes return $ret intoreturn $ret / count($array) ;
we model this change with the corresponding ifstatement on lines
6‚Äì9 of Figure 1c. We encode the changes such that they form valid
statements. For a change that cannot be wrapped around with an if
statement, we use evalwith the change being used as the argument
ofeval. Note that for simplicity in our example, the patch variables
represent the change made by different developers . However, we
can also use such variables to guard Ô¨Åner-grained changes to detect
the conÔ¨Çicts among them.
3.2 Variability-Aware Execution
We next use variability-aware execution [10] to detect semantic
conÔ¨Çicts. Variability-aware execution explores all possible concrete
runs of the encoded program with regard to all possible values of the
patch variables. That is, it efÔ¨Åciently runs all possible versions (of
the original program) corresponding to all combinations of changes,
taking advantage of the shared code among all versions. When the
condition at an ifstatement is patch variable, it runs both branches
and maintains the values of variables in the branches separately.
After that, it merges alternative values of the same variable into a
Choice representation containing multiple concrete values depending
on a condition. Note that the values of potentially many other
variables remain unchanged after the ifstatement is execute, which
enables variability-aware execution to scale. To illustrate, let us
describe the run of the assertion on line 7 of Figure 1b:
Function call C(2, $array) is invoked (line 7, Figure 1b).
In function C, it runs the Ô¨Årst ifstatement with both values
(True/False ) of the patch variable $P3(lines 23‚Äì25, Figure 1c).
Next, it explores different branches of the second ifstatement.
It starts by executing the then clause (i.e., calling A($array ))
under the condition $P2 == True (line 27, Figure 1c).
In function A, it executes the forloop and then explores both
branches of the ifstatement at line 6. The returned value is a
Choice representation of two alternative values: Choice($P1,
1, 5) , i.e., the value is 1 when $P1 == True (the change by
developer P1is incorporated) and 0 otherwise.
Returning to line 27 of Figure 1c, $sum is assigned with the
returned value Choice($P1, 1, 5) under $P2 == True .
The engine continues to explore the elsebranch the ifstate-
ment at lines 29‚Äì31 and computes the value of $sum as 5
under condition $P2 == False .
After running the ifstatement at lines 26‚Äì32, our engine
computes the value of $sum asChoice($P2, Choice($P1, 1, 5),
5), which it then simpliÔ¨Åes as Choice($P2 & $P1, 1, 5) .
928Therefore, the returned value of function CisChoice($P2 &
$P1, 1, 0.2) (line 33, Figure 1c).
Returning to the assertion on line 7 of Figure 1b, the assertion
compares the returned value Choice($P2 & $P1, 1, 0.2) with
value 0.2 and our engine reports an assertion error under
condition $P2 & $P1 , which indicates that the test case would
fail if those changes from both P1andP2were incorporated.
The result of the above execution process successfully identiÔ¨Åes
a set of changes that directly cause a semantic merge conÔ¨Çict.
Variability-aware execution is similar to dynamic symbolic ex-
ecution [14] in that they both aim to explore all possible paths in
a program. However, variability-aware execution takes advantage
of the sharing of variables‚Äô values and does not backtrack after ex-
ecuting both branches of a conditional statement. It operates on
conditional concrete values instead of symbolic values (i.e., a vari-
able may have different values in different conditions, but all values
are concrete). Details on variability-aware execution can be found
in our prior work [10].
Limitations . Our encoding algorithm currently works for changes
to regular program statements (which can be encoded into a valid
piece of code within an introduced ifstatement). We have not
addressed the general cases where a change to a Ô¨Åeld/method dec-
laration is made. In addition, our n-way merging algorithm uses a
greedy approach based on two-way comparison. Alternatively, we
could explore advanced techniques for n-way merging [6, 11].
4. PRELIMINARY STUDY
Table 2: Subject programs for evaluation
Example Test cases Branches Semantic ConÔ¨Çicts
MathHelper 7 5 3
Queue1 8 5 3
Queue2 8 4 2
Product 7 4 3
Dog1 4 4 2
Dog2 4 5 2
Chess 12 5 4
Total 50 19
We performed a preliminary experimental study on seven example
PHP applications with a total of 50 test cases and 19 semantic
conÔ¨Çicts (Table 2). They are small programs, each with less than
100 lines of code. We constructed these conÔ¨Çicts based on the
categorized scenarios of semantic merge conÔ¨Çicts described by Fan
and Sun [7]. 14 out of 19 conÔ¨Çicts involve 3 branches; the other
involve 2 branches. Then, we manually created the test cases for
those programs. Our results showed that Semex was able to correctly
detect all 19 conÔ¨Çicts (the set of conÔ¨Çicting parallel changes reported
by Semex are the actual minimum conÔ¨Çicting changes).
5. CONCLUSION
In collaborative software development, semantic merge conÔ¨Çicts
may occur even when the parallel changes contain no textual con-
Ô¨Çicts. Therefore, it is desirable to identify early the actual (mini-
mum) set of changes that directly cause a semantic merge conÔ¨Çict.
We proposed Semex, a novel approach to detect semantic conÔ¨Çictsusing variability-aware execution. First, we encode all parallel
changes into a single program with variability in which special
Boolean variables represent the presence of the changes. Next, we
use variability-aware execution to run test cases on this merged
program. Semex then reports the condition indicating the set of min-
imum changes that cause a conÔ¨Çict. Our preliminary study showed
that our approach can achieve promising results.
6. ACKNOWLEDGMENTS
This project is funded in part by National Science Foundation
grants: CCF-1318808, CCF-1018600, CNS-1223828, CCF-1349153,
CCF-1320578, and CCF-1413927.
7. REFERENCES
[1] J. T. Biehl, M. Czerwinski, G. Smith, and G. G. Robertson.
Fastdash: A visual dashboard for fostering awareness in
software teams. CHI ‚Äô07, pages 1313‚Äì1322. ACM, 2007.
[2]C. Bird and T. Zimmermann. Assessing the value of branches
with what-if analysis. FSE ‚Äô12, pages 1‚Äì11. ACM, 2012.
[3] M. B√∂hme, B. C. d. S. Oliveira, and A. Roychoudhury.
Regression tests to expose change interaction errors.
ESEC/FSE 2013, pages 334‚Äì344. ACM, 2013.
[4] Y . Brun, R. Holmes, M. D. Ernst, and D. Notkin. Proactive
detection of collaboration conÔ¨Çicts. ESEC/FSE ‚Äô11, pages
168‚Äì178. ACM, 2011.
[5]P. Dewan and R. Hegde. Semi-synchronous conÔ¨Çict detection
and resolution in asynchronous software development.
ECSCW‚Äô07. Springer Verlag, 2007.
[6]S. Duszynski, J. Knodel, and M. Becker. Analyzing the source
code of multiple software variants for reuse potential. In
WCRE‚Äô11 , pages 303‚Äì307. IEEE, Oct 2011.
[7] H. Fan and C. Sun. Dependency-based automatic locking for
semantic conÔ¨Çict prevention in real-time collaborative
programming. SAC ‚Äô12, pages 737‚Äì742. ACM, 2012.
[8] R. Hegde and P. Dewan. Connecting programming
environments to support ad-hoc collaboration. ASE ‚Äô08, pages
178‚Äì187. IEEE Computer Society, 2008.
[9] S. Horwitz, J. Prins, and T. Reps. Integrating noninterfering
versions of programs. ACM Trans. Program. Lang. Syst. ,
11(3):345‚Äì387, July 1989.
[10] H. V . Nguyen, C. K√§stner, and T. N. Nguyen. Exploring
variability-aware execution for testing plugin-based web
applications. ICSE 2014, pages 907‚Äì918. ACM, 2014.
[11] J. Rubin and M. Chechik. N-way model merging. ESEC/FSE
2013, pages 301‚Äì311. ACM, 2013.
[12] A. Sarma, Z. Noroozi, and A. van der Hoek. Palantir: Raising
awareness among conÔ¨Åguration management workspaces.
ICSE ‚Äô03, pages 444‚Äì454. IEEE Computer Society, 2003.
[13] A. Sarma, D. Redmiles, and A. van der Hoek. Empirical
evidence of the beneÔ¨Åts of workspace awareness in software
conÔ¨Åguration management. FSE‚Äô08, pages 113‚Äì123. ACM,
2008.
[14] K. Sen, D. Marinov, and G. Agha. Cute: A concolic unit
testing engine for C. ESEC/FSE 2005, pages 263‚Äì272. ACM,
2005.
[15] J. Wloka, B. Ryder, F. Tip, and X. Ren. Safe-commit analysis
to facilitate team software development. ICSE ‚Äô09, pages
507‚Äì517. IEEE Computer Society, 2009.
[16] A. Zeller and R. Hildebrandt. Simplifying and isolating
failure-inducing input. IEEE Trans. Softw. Eng. ,
28(2):183‚Äì200, 2002.
929