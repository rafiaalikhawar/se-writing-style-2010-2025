CORRECT: Code Reviewer Recommendation at GitHub for
Vendasta Technologies
Mohammad Masudur Rahman?Chanchal K. Roy?Jesse RedlxJason A. Collinsy
University of Saskatchewan?, Canada, Vendasta Technologiesx, Canada, Google Inc.y, USA
{masud.rahman, chanchal.roy}@usask.ca?, jredl@vendasta.comx,
jasonco@google.comy
ABSTRACT
Peer code review locates common coding standard viola-
tions and simple logical errors in the early phases of soft-
ware development, and thus, reduces overall cost. Unfortu-
nately, at GitHub, identifying an appropriate code reviewer
for a pull request is challenging given that reliable informa-
tion for reviewer identication is often not readily available.
In this paper, we propose a code reviewer recommendation
tool{CORRECT{that considers not only the relevant cross-
project work experience (e.g., external library experience)
of a developer but also her experience in certain specialized
technologies (e.g., Google App Engine) associated with a
pull request for determining her expertise as a potential code
reviewer. We design our tool using client-server architecture,
and then package the solution as a Google Chrome plug-in.
Once the developer initiates a new pull request at GitHub,
our tool automatically analyzes the request, mines two rele-
vant histories, and then returns a ranked list of appropriate
code reviewers for the request within the browser's context.
Demo: https://www.youtube.com/watch?v=rXU1wTD6QQ0
CCS Concepts
Software and its engineering !Software notations
and tools; Code Review; Recommendation; Collaboration
in software development !Programming teams;
Keywords
Code reviewer recommendation, cross-project experience,
specialized technology experience, GitHub, pull request
1. INTRODUCTION
Peer code review is reported to be highly eective for lo-
cating coding standard violations or for performing simple
logical verications [1, 4, 12]. It also helps identify source
code issues (e.g., vulnerabilities) in the early phases of de-
velopment, and thus, reduces overall cost for the softwareproject [1, 4]. GitHub promotes a distributed and collabo-
rative software development through pull requests and code
reviews respectively. In GitHub, a developer forks from an
existing repository (i.e., project), works on certain module of
her interest, and then submits the changed les to the reposi-
tory using a pull request [6]. During pull request submission,
the developer is expected to choose one or more code review-
ers who would review the code carefully before accepting the
changes as a contribution. Unfortunately, choosing an ap-
propriate reviewer for a pull request is a signicant challenge
[2], and to date, GitHub does not provide any support for
this. Reliable information on reviewers' expertise (e.g., tech-
nology skill) is often not readily available, and it needs to be
carefully mined from the codebase. Thus, the task of iden-
tifying appropriate reviewers is even more challenging and
time-consuming for novice developers since they are neither
familiar well with the codebase nor are aware of the skills of
the hundreds of fellow potential reviewers. Such challenge
is prevalent not only in open source development but also in
the industrial environment where a company (e.g., Vendasta
Technologies) strives to maintain code quality in the com-
mercial software development and encourages collaborations
among the developers in the form of peer code reviews.
Fortunately, there have been several studies that recom-
mend code reviewers by analyzing past code review history
(e.g., line change history [2], review comments [16, 18]),
project directory structure [13, 14], and developer collab-
oration network [18]. In short, the existing studies mostly
rely on the work history of a developer (i.e., potential re-
viewer) within a particular project and her collaboration
history with other developers for determining her expertise.
However, no studies consider the cross-project experience or
the experience in various specialized technologies of a de-
veloper, and thus, they fall short in handling certain chal-
lenges. First, in industry, software developers often reuse
software components (e.g., libraries) that were previously
developed by themselves for cost-eective and faster devel-
opment. Thus, their contributions scatter throughout dif-
ferent projects in the code repositories of the organization.
Such contributions are a great proxy to their experience.
Unfortunately, the existing studies on code reviewer recom-
mendation completely ignore such information in expertise
determination, and their recommendations are merely based
on the contribution details within a particular project. Sec-
ond, underlying tools and technologies of software projects
are rapidly changing, and modern projects often involve dif-
ferent specialized and cutting edge technologies such as map-
reduce, task queues, urlfetch, memcache andpipeline .
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission and/or a
fee. Request permissions from Permissions@acm.org.
ASE‚Äô16 , September 3‚Äì7, 2016, Singapore, Singapore
c2016 ACM. 978-1-4503-3845-5/16/09...$15.00
http://dx.doi.org/10.1145/2970276.2970283
792
Hence, code reviewers for a pull request are expected to
have expertise in such technologies. However, neither min-
ing of the revision history of changed les nor mining of the
developer collaboration history, as the existing studies do,
might be sucient enough to ensure that. Thus, a technique
that can analyze both relevant cross-project experience and
specialized technology experience of a developer for a pull
request, is likely to overcome the above challenges.
In this paper, we present a novel code reviewer recommen-
dation tool{CORRECT{ for pull requests at GitHub. The
tool determines eligibility of a developer as code reviewer for
a pull request by analyzing her past work experience with (1)
external software libraries and (2) specialized technologies
used by the pull request. Reference to the external libraries
(i.e., software units external to the working project) in the
code generally suggests one's working experience with such
libraries, and we call it cross-project experience . Our key
idea is{ if a past pull request uses similar external software
libraries or similar specialized technologies to the current pull
request, then the past request is relevant to the current re-
quest, and thus, its reviewers are also potential candidates
for the code review of the current request .
We rst mine the external library and technology infor-
mation from current pull request using static analysis, and
then identify the relevant (i.e., similar) requests in terms of
library and technology similarities from the recently submit-
ted pull request collection. We then propagate the similar-
ity score for each relevant request to its corresponding code
reviewers as a proxy to the shared experience in external li-
braries and specialized technologies with the current request.
Thus, each of the candidates accumulates scores for all rel-
evant requests, and nally, the technique returns a ranked
list of code reviewers. We adopt a client-server architecture
for our recommendation system where the client module is
packaged as a Google Chrome plug-in (i.e., as per the speci-
cation of Vendasta Technologies), and the server module is
hosted as a web service. To summarize, our proposed tool
provides the following features to support Vendasta software
developers in the selection of appropriate code reviewers:
(a) automatically analyzes the technical details of a given
pull request, and recommends a ranked list of appro-
priate reviewers for its code review,
(b) automatically captures and leverages two expertise di-
mensions of a developer{ cross-project experience and
specialized technology experience {for determining her
expertise/eligibility as a code reviewer,
(c) oers customized recommendations for the developers
using open authentication of GitHub,
(d) complements the existing pull request submission util-
ity of GitHub through a Google Chrome plug-in, and
(e) provides a client-server architecture for seamless inte-
gration of our code reviewer recommendation service.
While this paper focuses on the tool aspect of our code
reviewer recommendation approach, we refer the readers to
the original paper [11] for further details.
2. MODERN CODE REVIEW (MCR)
Code review refers to a manual assessment of source code
that identies potential defects (e.g., logical errors) and qual-
ity problems (e.g., coding standard violations) in the code
[3]. In recent years, code review has been assisted with var-
ious tools, which is less formal and more popular than the
traditional review techniques [2]. Such code review is called
Figure 1: Code review interface at GitHub
Modern Code Review (MCR) [3]. It is widely adopted both
by the commercial organizations (e.g., Microsoft) and by the
open-source communities (e.g., Android, LibreOce). As
an example, developer jrans-va (i.e., green box, Fig. 1) re-
quests a development team{ cashlab (i.e., red box, Fig. 1){
for code review during the submission of the pull request
#1745. The request contains two commits associated with
ve changed source les. Two developers{ cgooding-va and
cberenik-va (i.e., blue boxes){ from the team analyze the
commits from the pull request, perform the code review,
and then post their feedback using comments (i.e., orange
boxes, Fig. 1). Unfortunately, despite assistance from the
static analysis tools [2], eective code review still remains a
challenge, and identifying appropriate reviewers for the code
review is even more challenging. To date, both reviewer se-
lection and code review are performed manually at GitHub.
Our tool recommends appropriate developers (e.g., cgooding-
va) for such code review task (e.g., Fig. 1) at GitHub.
3. CORRECT: PROPOSED TOOL
Fig. 2 shows the user interface of CORRECT where we
contribute in (d) browser's tool bar, (e)-(f) recommenda-
tion panel, and (g) pull request body panel. This section
discusses dierent technical features provided by our tool.
(1) Use Cases: CORRECT provides automatic recom-
mendation supports for two use cases of pull request based
collaborative software development as follows:
(i) Submission of a New Pull Request: During the
submission of a new pull request , a user (i.e., developer) com-
pares her project branch (e.g., AA-2453, Fig. 2-(a) ) with
the base repository (e.g., develop , Fig. 2-(a)), and then
looks for potential code reviewers. Our tool analyzes the
changed source code les (e.g., Fig. 2-(b)) using static anal-
ysis, and then suggests a ranked list of appropriate code
reviewers in the recommendation panel (e.g., Fig. 2-(e)).
(ii) Update of an Existing Pull Request: CORRECT
can also recommend code reviewers for an already submitted
pull request for which either no reviewers were assigned or
inappropriate reviewers were assigned. This could be really
helpful since inappropriate assignment of code reviewers of-
ten costs precious development time [14]. Our tool analyzes
the changed source les from the pull request using static
analysis, and then suggests the code reviewers.
793Figure 2: User interface of CORRECT Tool
(2) Automatic Mining of Relevant Artifacts: Our
tool automatically mines both version control history and
code review history of a software project for identifying ap-
propriate code reviewers for a given pull request as follows:
(i) Analysis of Changed Source Code Files: Once
either a branch (i.e., rst use case) or a pull request (i.e., sec-
ond use case) is selected, the tool collects all the changed les
from each of their commits from the version control history.
It accesses GitHub API end points for collecting the changed
les, and uses github-api1, a popular GitHub client library
for the API access. Since each request or branch might in-
volve a number of source code les, the tool only collects
the path of the changed les from the API, and then applies
that information to a local mirror of the GitHub repository
for performing further static analysis.
(ii) Analysis of Code Review History: Our tool
learns to recommend from past code reviews as was also
learnt by existing literature [2, 14, 16]. It thus collects code
review details of the 30 most recently submitted pull re-
quests using GitHub API [11]. Since online API access could
be time-consuming and could hurt the tool's performance,
we adopt parallelization in the API access. In particular,
we apply Java multi-threading to API access and further
analysis for each of the past pull requests from the history.
(3) Automatic Recommendation of Code Review-
ers: CORRECT returns a ranked list of ve code reviewers
for any given pull request (i.e., Fig. 2-(e)). The size of this
recommendation is customizable, and the recommendation
generally takes 10-15 seconds on average. The tool also pro-
vides additional insights to assist the user (i.e., developer)
in the selection of appropriate code reviewers for her pull re-
quest. In particular, it provides relative expertise estimates
(i.e., estimated by our original technique [11]) of the rec-
ommended reviewers on the external software libraries and
specialized technologies used by the pull request. Our tool
also provides several usability features as follows:
(i) Automated Use of Recommendation: Once code
reviewers are recommended in the recommendation panel,
1https://github.com/kohsuke/github-apithe user can copy and paste the reviewers in pull request
body panel (i.e., Fig. 2-(g)) by simply clicking Copy review-
ersbutton (i.e., Fig. 2-(f)). Then she can submit the request
by using Create Pull Request button (i.e., Fig. 2-(h)). The
tool also provides a Refresh button (i.e., Fig. 2-(f)) to help
the user start over the reviewer recommendation cycle.
(ii) Caching of Recommendation: Since we use a
stateless protocol{HTTP, caching is a convenient way to
improve the performance (i.e., response time) of the tool.
Our tool uses localStorage , a storage feature of Google
Chrome and other HTML5-capable browsers, to store the
most recently collected recommendation result. In the case
of repeated requests from the same page (i.e., branch or pull
request), CORRECT displays previously stored result from
localStorage database. The cache can also be cleared using
theRefresh button (i.e., Fig. 2-(f)) if the user desires.
(4) Personalization & Optimization: CORRECT uses
open authentication for GitHub API access, and thus, it has
the potential not only for personalized reviewer recommen-
dation but also for performance optimization as follows:
(i) Personalized Recommendation: Our tool cap-
tures a user's identity from the open authentication step,
and then customizes the code reviewer recommendation for
her. In particular, CORRECT discards self-reference (i.e.,
tool user herself as reviewer) from the recommendation list
at present. However, other social aspects (i.e., developer col-
laboration history) could also be leveraged for further per-
sonalization of the reviewer recommendation.
(ii) Performance Optimization: GitHub restricts API
access of an average registered user to a rate limit of 5,000
calls per hour. This restriction is likely to introduce Denial
of Service issue with a tool (i.e., accessing GitHub API) if
it is conned to one user account only, especially in an in-
dustrial context that involves frequent API access. Our tool
overcomes that challenge using open authentication where
the tool accesses the GitHub API on behalf of the logged in
tool user, and thus, the access rarely exceeds the rate limit.
7944. WORKING METHODOLOGY
Fig. 3 shows the schematic diagram of our proposed tool{
CORRECT. Our tool analyzes both version control history
and code review history of a software project, and then sug-
gests a ranked list of potential code reviewers for any given
pull request. This section discusses the internal structures
and working methodologies of the tool in brief while we refer
the readers to the original paper [11] for further details.
Working Modules: CORRECT adopts client-server ar-
chitecture, and it has two working modules{(1) recommen-
dation engine and (2) client module . We package the client
module as a Google Chrome plug-in and the recommenda-
tion engine as a web service. Once the plug-in is installed
successfully, it appears as a user icon at the web browser's
tool bar (e.g., Fig. 2-(d)). While the plug-in captures the
technical details of a pull request from the web browser, the
web service analyzes both the request and other relevant
artifacts from the histories, and derives code reviewer rec-
ommendation for the request. Both modules communicate
using REST and AJAX on top of HTTP.
Historical Data Collection: CORRECT collects 30
past CLOSED pull requests and their corresponding review
details from a project for recommending code reviewers for
a new pull request. We rst identify each of those pull re-
quests and extract their corresponding commits. Each of
these commits can be identied using their SHA-1 based
ID, and they generally contain one or more source les that
were changed together. We collect such changed les from
each of the selected past pull requests using GitHub API ac-
cess and local repository analysis. We repeat the same steps
for the new pull request, and collect the changed source les
to be submitted to the base repository.
We then analyze the code review details of each of the
past pull requests, and collect their corresponding reviewers
using GitHub API access. In particular, we collect both
the reviewers who were referred to during the submission
(e.g., rwiebe-va , Fig. 2-(g)) and the reviewers who actually
reviewed the pull request (e.g., cgooding-va , Fig. 1). Such
historical information provides the foundation (i.e., ground
truth) for the learning and evaluation of our tool.
Code Review Skill & Reviewer Ranking: Our key
idea is{ the developers who have reviewing experience on
similar (i.e., relevant) past pull requests are suitable candi-
dates for reviewing the current pull request to be submit-
ted [2, 14]. Once changed source code les and review de-
tails from the past pull requests are collected, we determine
their relevance to the current request based on their shared
external libraries (e.g., vapi, vform ) and adopted special-
ized technologies (e.g., taskqueue, ndb ) in the changed les.
In particular, we extract the external library or specialized
technology names from each pull request, and determine co-
sine similarity between the current request and each of the
past requests. We then propagate the similarity estimates
(as a proxy to review expertise) to the corresponding code re-
viewers of the past requests. Thus, according to CORRECT,
the software developers who have more experience on the at-
tached external libraries (i.e., cross-project experience) and
the adopted specialized technologies in the changed les of
the current pull request, are more appropriate for the code
review than the ones having less experience.
Example: Let us consider R3(Fig. 3) is a pull request
to be submitted, and the submitter is looking for one or
more code reviewers for the request. R1andR2are two
Figure 3: Working methodology of CORRECT,
taken from the original paper [11]
past requests similar to R3containing one or more changed
les. From Fig. 3, we see that each of R1andR2includes
three libraries, adopts three specialized technologies, and is
reviewed by a dierent set of developers. Similarly, R3also
includes three external libraries and adopts three specialized
technologies in the changed les. In order to recommend re-
viewers for R3, CORRECT rst determines the cosine sim-
ilarity between libraries and technologies of R3and those of
R1andR2. It then applies those scores to the correspond-
ing reviewers of R1andR2. Thus, the developers who have
the most review experience with similar past requests, bub-
ble up in the ranked list for code reviewers. From Fig. 3,
we see that reviewer Ascores the top (i.e., 1.17) within all
the reviewers according to our ranking algorithm, and thus,
reviewer Ais recommended as the code reviewer for the cur-
rent request{ R3. We recommend the top ve code reviewers
[2, 14] from such a ranked list for any given pull request.
5. A USE CASE SCENARIO
By means of a use case scenario, we attempt to explain
how our tool{CORRECT{can help a software developer in
choosing appropriate code reviewers for her pull request
from within the context of a web browser.
Suppose, a developer, Alice , has started to collaborate on
a new software project { SR{ of Vendasta Technologies. She
rst forks from the base project which provides her a local
copy of the project with complete access for code editing
and committing. She then starts to x a reported bug with
ID{SR-3869 { where she deletes 28 lines of code and adds 26
lines of code to the local project. When she is done with the
xation, it is found that the changes were made to ve source
code les bundled into two commits (i.e., Fig. 4). Then she
attempts to submit the changes to the base repository using
a pull request. Modern software companies like Vendasta
often have a mandatory requirement for code review in order
to maintain the code quality. Hence, she is also concerned
about submitting the changes of higher code quality. During
the pull request submission, she thus attempts to choose
a list of expert developers who would review the changes
before accepting them as a contribution to the base project.
To date, GitHub does not provide any support for this task,
and thus, she faces several challenges at this stage{(1) Who
is the most appropriate code reviewer for these changes? (2)
How to determine the code review skill of a developer? and
795Figure 4: Example use case: Commits & changed
source code les (to be submitted)
Table 1: Libraries & Technologies of Use Case
External Library Specialized Technology
vapi, vtax, vbcsdk, google.appengine.ext,
vautil, vbcsdk.keys, ndb, search,
vautil.validators.email google.appengine.api.search
(3) Can we possibly identify appropriate reviewers from the
past code reviews or version control history after all?
She might consider the original authors of the changed les
as reviewer candidates. However, this might not be practical
since the changed les might be authored by a number of
developers over the years who might not be even with the
company anymore. For this use case, we note that nine
developers authored the changed les. Alice still needs to
identify the most appropriate reviewers from those authors
by herself with little or no helpful insights about them, which
is a challenging task. The task is even more challenging for
Alice if she is novice and/or non-familiar with the fellow
developers or the code repositories of the company.
Now, let us assume that Alice has installed CORRECT
plug-in on her Chrome web browser, and she initiates a pull
request for submission. Our tool automatically collects the
changed source les from the forked project using GitHub
API access. Then it suggests her a ranked list of poten-
tial code reviewers by analyzing the most recently submit-
ted similar pull requests (i.e., with code reviews) from the
version control history of the base project. In particular,
the tool automatically extracts external library and special-
ized technology information (e.g., Table 1) from each of the
changed source les from each pull request, and then lever-
ages the extracted information for code reviewer recommen-
dation (Section 4). Besides ranking, the tool also provides
additional insights on the library and technology related ex-
perience of the code reviewers (i.e., Table 2) which help Al-
icechoose the right reviewers. For example, the top three
reviewers{ cberenik-va, cgooding-va andywang-va {in the rec-
ommended list have the maximum expected experience, and
she can condently choose them as the reviewers for her
changes. Thus, to overcome the challenges she faced previ-
ously, our tool (1) automatically suggests her a ranked list
of appropriate code reviewers for the pull request (to be sub-
mitted), (2) automatically captures and leverages external
library experience as well as specialized technology experi-
ence of the developers as suitable proxies to their code re-
view skills, and (3) automatically mines both version control
history and code review history using GitHub API access
for deriving the recommendation. In short, our tool does
all the heavy lifting for Alice in the background, and she
can just get the recommendation by simply clicking a but-
ton during the pull request submission. More interestingly,
CORRECT provides the recommendation within the con-
text of the web browser which helps her maintain the usual
work ow (i.e., within GitHub) and avoid the unexpected
context-switching. In the context of Vendasta Technologies,
we chose Google Chrome as the web browser. However, anyTable 2: Recommended Reviewers for Use Case
Reviewer Total Score Library Score Technology Score
cberenik-va 100% 64% 100%
cgooding-va 99% 100% 99%
ywang-va 75% 52% 76%
sgryschuk-va 8% 17% 8%
ksookoche-va 6% 0% 6%
browser plug-in capable of HTTP access can easily consume
our recommendation service.
6. EVALUATION & VALIDATION
One of the most eective ways for evaluating a code re-
viewer recommendation system is to consult with actual
code reviews and the reviewers assigned for them from a
codebase. We evaluate our technique using the real code
review data from Vendasta codebase. In particular, we use
13,081 pull requests and their code review details from Ven-
dasta as our oracle in evaluating CORRECT against a num-
ber of popular performance metrics. In order to further vali-
date our ndings and demonstrate its superiority, we experi-
ment using 4,034 pull requests from six open source systems
of three dierent programming languages, and compare with
the state-of-the-art technique. While we discuss our evalu-
ation and validation in brief as follows, the details can be
found in the original paper [11].
Evaluation using Vendasta Systems: We evaluate
our recommendation technique [11] using a collection of 13,081
pull requests from 10 subject systems (of Vendasta Technolo-
gies) and four state of the art performance metrics{ Top-K
Accuracy, Mean Reciprocal Rank, Mean Precision and Mean
Recall. CORRECT provides a Top-5 accuracy of 92.15%
and a Mean Reciprocal Rank of 0.67 with 85.93% precision
and 81.39% recall which are highly promising according to
relevant literature [2, 14, 16].
Comparison with the State-of-the-Art: We validate
the performance of our technique by comparing with Thong-
tanunam et al. [14], the state-of-the-art technique for code
reviewer recommendation which outperformed the earlier
techniques. Our technique{CORRECT{ provides 11.43%
improvement in Top-5 accuracy and about 10% improve-
ment in both precision and recall over the state-of-the-art.
Three statistical tests{ MWU, Cohen's d andGlass4{ also
suggest that such improvements are statistically signicant.
Experiments with Open Source Projects: Although
CORRECT was suciently evaluated using Python systems
from Vendasta, we conduct another experiment with six
open source projects from GitHub written in three dierent
programming languages{ Java, Python and Ruby { to gen-
eralize our ndings. In this case, CORRECT recommends
with a Top-5 accuracy of 85.20%, a Mean Reciprocal Rank
of 0.69, a Mean Precision of 84.76% and a Mean Recall of
78.73%. Comparison demonstrates that our technique out-
performs the state-of-the-art [14] with statistically signi-
cant margin. Further investigations also conrm that COR-
RECT does not show bias to any programming languages or
any project types{ open source and closed source .
Evaluation Plan with User Study: While CORRECT
is found promising based on empirical evaluation, we plan
to evaluate the tool using a user study involving professional
developers from Vendasta. The goal of the study is to de-
termine the usability and usefulness of the tool based on
actual developers' feedback. In the user study, we plan to
involve at least 10 developers working on 10 dierent run-
796ning projects. Each participant will install the tool, use
it for two controlled tasks (i.e., code reviewer assignment),
and then will evaluate the recommendation provided by the
tool with a predened rating scale. We would then collect
the numerical ratings as well as their qualitative feedback to
triangulate them with our empirical ndings.
7. RELATED WORK
Code Reviewer Recommendation : Existing studies
recommend code reviewers by analyzing mostly code review
or version control history [2, 13, 14, 16, 18] and developer col-
laboration networks [18]. Balachandran [2] proposes Review-
Botthat analyzes line change history of the aected source
lines from a given review request, and then identies code re-
viewers from that history for the request. However, existing
ndings suggest that most of the lines are generally changed
only once [14] which makes the line change history really
scarce and thus, the performance of ReviewBot is limited.
Thongtanunam et al. propose RevFinder [14] that identies
relevant review requests using File Path Similarity (FPS)
[13], and then recommends reviewers from those requests for
a review request at hand. RevFinder also outperformed ear-
lier techniques including ReviewBot [14]. On the other hand,
CORRECT identies relevant pull requests using external li-
brary similarity and specialized technology similarity which
are found to be more eective than File Path Similarity[14]
for estimating relevance between pull requests, and thus for
reviewer recommendation. In our earlier work [11], we show
that our technique outperformed RevFinder with statisti-
cally signicant performance improvements. Another recent
work [16] applies machine learning on past code reviews,
and combines textual similarity with File Path Similarity
[14]. Thus, it suers from similar issues as of RevFinder
such as pull request relevance issue, and that the learned
models could be biased to the subject systems under study.
The remaining technique{Yu et al. [18] analyzes past re-
view comments and developer collaboration networks for re-
viewer recommendation. While we use library and technol-
ogy similarity between pull requests for determining relevant
past requests, they use review comment similarity (i.e., tex-
tual similarity) for the same purpose. Besides, their idea is
still not properly evaluated or validated.
Expert Recommendation: Kintab et al. [9] identify
expert developers on a code fragment of interest by exploit-
ingcode similarity with other segments. Similar technique
is applied by da Trindade et al. [5] where they develop a
communication network among documents, source code and
developers, and then recommend dominant developers as ex-
perts. Yang [17] studies the developer network using code
review relationship , and identies core and peripheral devel-
opers using dierent network properties. There exist several
studies in the domain of bug triaging that analyze dupli-
cate bug reports [8] or apply IR-based traceability [10] tech-
niques for recommending appropriate developers for bug x-
ation. Several studies are also conducted on expert user rec-
ommendation at Stack Overow that analyze cross-domain
contributions [15] or question diculty [7] for expertise es-
timation. While these expert recommendation techniques
are somewhat similar to ours, their context of recommenda-
tion is dierent and thus, comparing ours with them is not
feasible. Of course, we introduced two novel and eective
expertise paradigms ( cross-project experience and special-
ized technology experience ) which were not exploited by anyof the recommendation systems. This makes our proposed
tool{CORRECT{ signicantly dierent from all of them.
8. CONCLUSION
To summarize, we propose a novel tool{ CORRECT{
for code reviewer suggestion for pull requests at GitHub
for Vendasta Technologies. It automatically captures the
experience of a developer with the external libraries (i.e.,
cross-project experience) and specialized technologies used
in a given pull request, applies such experiences as prox-
ies to code review skill of the developer, and then suggests a
ranked list of appropriate code reviewers. Our recommenda-
tion technique is substantially evaluated and validated using
empirical data. We package our solution as a web service and
a plug-in for Google Chrome browser. The tool can assist a
developer in choosing appropriate code reviewers during the
submission of a new pull request or during the update (i.e.,
reviewer assignment) of an existing pull request.
9. REFERENCES
[1] A. Bacchelli and C. Bird. Expectations, Outcomes, and Chal-
lenges of Modern Code Review. In Proc. ICSE , pages 712{721,
2013.
[2] V. Balachandran. Reducing Human Eort and Improving Qual-
ity in Peer Code Reviews using Automatic Static Analysis and
Reviewer Recommendation. In Proc. ICSE , pages 931{940, 2013.
[3] M. Beller, A. Bacchelli, A. Zaidman, and E. Juergens. Modern
Code Reviews in Open-Source Projects: Which Problems do they
Fix? In Proc. MSR , pages 202{211, 2014.
[4] A. Bosu, J. C. Carver, M. Haz, P. Hilley, and D. Janni. Identi-
fying the Characteristics of Vulnerable Code Changes: An Em-
pirical Study. In Proc. FSE , pages 257{268, 2014.
[5] C.C. da Trindade, Y.A.M. Barbosa, A.K.O. Moraes, J.O. de Al-
buquerque, and S.R.L. Meira. An Expert Recommender System
to Distributed Software Development: Requirements, Project
and Preliminary Results. In Proc. SBSC , pages 161{168, 2009.
[6] G. Gousios, M. Pinzger, and A. v. Deursen. An Exploratory
Study of the Pull-based Software Development Model. In Proc.
ICSE , pages 345{355, 2014.
[7] B. V. Hanrahan, G. Convertino, and L. Nelson. Modeling Prob-
lem Diculty and Expertise in Stackoverow. In Proc. CSCW ,
pages 91{94, 2012.
[8] K. Kevic, S.C. Muller, T. Fritz, and H.C. Gall. Collaborative Bug
Triaging using Textual Similarities and Change Set Analysis. In
Proc. CHASE , pages 17{24, 2013.
[9] G. Kintab, C. K. Roy, and G. Mccalla. Recommending Software
Experts using Code Similarity and Social Heuristics. In Proc.
CASCON , page to appear, 2014.
[10] M. Linares-Vasquez, K. Hossen, H. Dang, H. Kagdi, M. Gethers,
and D. Poshyvanyk. Triaging Incoming Change Requests: Bug
or Commit History, or Code Authorship? In Proc. ICSM , pages
451{460, 2012.
[11] M. M. Rahman, C. K. Roy, and J. Collins. CORRECT: Code Re-
viewer Recommendation Based on Cross-Project and Technology
Experience. In Proc. ICSE , pages 222{231, 2016.
[12] P.C. Rigby, B. Cleary, F. Painchaud, M. Storey, and D.M. Ger-
man. Contemporary Peer Review in Action: Lessons from Open
Source Development. TSE, 29(6):56{61, 2012.
[13] P. Thongtanunam, R. G. Kula, A. E. C. Cruz, N. Yoshida, and
H. Iida. Improving Code Review Eectiveness Through Reviewer
Recommendations. In Proc. CHASE , pages 119{122, 2014.
[14] P. Thongtanunam, R. G. Kula, N. Yoshida, H. Iida, and K. Mat-
sumoto. Who Should Review my Code ? In Proc. SANER , pages
141{150, 2015.
[15] R.l Venkataramani, A.l Gupta, A. Asadullah, B. Muddu, and
V. Bhat. Discovery of Technical Expertise from Open Source
Code Repositories. In Proc. WWW , pages 97{98, 2013.
[16] X. Xia, D. Lo, X. Wang, and Xiaohu Y. Who Should Review this
Change? Putting Text and File Location Analyses Together for
More Accurate Recommendations. In Proc. ICSME , 2015.
[17] Xin Yang. Social Network Analysis in Open Source Software
Peer Review. In Proc. FSE , pages 820{822, 2014.
[18] Y. Yu, H. Wang, G. Yin, and C. Ling. Reviewer Recommender
of Pull-Requests in GitHub. In Proc. ICSME , pages 609{612,
2014.
797