CANAL: A Cache Timing Analysis Framework via LLVM
Transformation
Chungha Sung
University of Southern California
Los Angeles, CA, USABrandon Paulsen
University of Southern California
Los Angeles, CA, USAChao Wang
University of Southern California
Los Angeles, CA, USA
ABSTRACT
Aunifiedmodelingframeworkfornon-functionalpropertiesofa
program is essential for research in software analysis and verifi-
cation, since it reduces burdens on individual researchers to im-
plement new approaches and compare existing approaches. We
present CANAL,aframeworkthatmodelsthe cachebehaviorsof
aprogrambytransformingitsintermediaterepresentationinthe
LLVMcompiler. CANALinsertsauxiliaryvariablesandinstructions
toallowstandardverificationtoolstohandleanewclassofcache
related properties, e.g., for computing the worst-case execution
timeanddetectingside-channelleaks.Wedemonstratetheeffec-
tivenessof CANALusingthreeverificationtools:KLEE,SMACK
and Crab-llvm. We confirm the accuracy of our cache model by
comparing with CPU cycle-accurate simulation results of GEM5.
CCS CONCEPTS
â€¢Software and its engineering â†’Software verification and
validation ;â€¢Securityandprivacy â†’Cryptanalysisandother
attacks;
KEYWORDS
cache,executiontime,sidechannel,verification,symbolicexecu-
tion, abstract interpretation, bounded model checking
ACM Reference Format:
Chungha Sung, Brandon Paulsen, and Chao Wang. 2018. CANAL: A Cache
TimingAnalysisFrameworkviaLLVMTransformation.In Proceedings of
the 2018 33rd ACM/IEEE International Conference on Automated Software
Engineering (ASE â€™18), September 3â€“7, 2018, Montpellier, France. ACM,New
York, NY, USA, 4pages.https://doi.org/10.1145/3238147.3240485
1 INTRODUCTION
Analyzingthe cachebehaviorsofaprogramisimportant,e.g.,for
computing theworst-case execution timeof areal-time system [ 5,
13]and detectinginformationleaks throughsidechannels [ 8,15].
However, existing verification tools are often designed only for
checking functional properties, e.g., assertions or pre- and post-
conditions.Forexample,noneoftheparticipantsofrecentsoftware
verificationcompetitions[ 2]canverify non-functional properties
suchasthoserelatedtotheexecutiontime.Althoughspecialized
toolshavebeendevelopedtohandlesuchnon-functionalproperties,
theyarerarelyopen-sourceoraswell-maintainedasmainstream
verificationtools.Asaresult,itisdifficultforindividualresearchers
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,
topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE â€™18, September 3â€“7, 2018, Montpellier, France
Â© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.3240485

	



	
		


	


			
 !
"##

$% 
	
	 
&	 '
'%
Figure 1: The overall flow of CANAL.
to implement new approaches for verifying such properties or
evaluate existing approaches.
Wefillthegapbydevelopinga lightweight cachemodelingframe-
work for standard verification tools, by transforming the LLVM
intermediate representation (IR) of a program to add self-modeling
capabilities. That is, we insert auxiliary variables and LLVM in-
structionsoverthesevariablestorecordandupdatecachestatistics
relatedto Load/Storeinstructionsduringtheprogramexecution.
By using the instrumented LLVM bitcode as input, standard (func-
tional) verification tools will have the capability of verifying a new
class of (non-functional) properties.
Our modeling framework, named CANAL, takes C/C++ code as
inputandemitsLLVMbitcodeasoutput.Thus,itcanbeusedby
anyLLVM-basedverificationtools.Forexample,symbolicexecu-
tion tools such as KLEE [ 4] may take the program instrumented
byCANALto detect side-channel leaks; bounded model check-
ers such as SMACK [ 14] may take the program instrumented by
CANALto conduct Must- and May-hit cache analyses; and static
analyzers based on numerical abstract interpretation, such as Crab-
llvm[10],maytaketheprograminstrumentedby CANALtocon-
ductworst-caseexecutiontime(WCET)analysis. CANALisavail-
able on GitHub1.
In the remainder of this paper, we shall explain how to combine
CANALwithKLEE,SMACKandCrab-llvmtoobtainthedesired
results.Wealsocompare CANALwiththeCPUcycle-accuratesimu-
lationresultsofGEM5[ 9],astandardmicro-architecturalsimulator,
to demonstrate the accuracy of our cache model.
2 TOOL OVERVIEW
Figure1shows the overall flow of CANAL, which takes the C/C++
code of a program and the cache configuration file of a target
computer as input, and returns the instrumented LLVM bitcode as
output. After compiling the C/C++ code into LLVM bitcode, it uses
a sequence of optimization ( opt) passes to insert, before or after
eachLoad/Storeinstruction,somenewinstructionsthatmodelthe
change of cache states due to these memory accesses. The inserted
instructions can be understood as invocations of two functions:
__CSIM_Load(addrInfo) and__CSIM_Store(addrInfo) , which
updates our model of the cache state whenever LoadorStoreis
executed; addrInfo denotes information of the memory location.
1Tool and benchmarks: https://github.com/canalcache/canal
904
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:47:05 UTC from IEEE Xplore.  Restrictions apply. ASE â€™18, September 3â€“7, 2018, Montpellier, France Chungha Sung, Brandon Paulsen, and Chao Wang
Inadditiontotheautomaticallyinsertedcallsto __CSIM_Load
and__CSIM_Store , the user of CANALmay specify properties us-
ingtheseauxiliaryvariables: __CSIM_num_hit ,__CSIM_num_miss ,
__CSIM_Load_ret ,and__CSIM_Store_ret .Theyrepresenttheac-
cumulative numbers of hits and misses along a program path, as
well as the cache status (hit or miss) associated with each mem-
ory access. By feeding the instrumented LLVM bitcode to standard
verification tools as input, CANALallows them to verify a new
classofnon-functionalproperties,suchasassertionsoverauxiliary
variables that model the cache behaviors of the program.
int main() {
__CSIM_init_cache();
char out[16];
aes_encrypt("hello world!", out);
__CSIM_print_stat();
}
Figure 2: CANAL as stan-
dalone cache simulator.Accuracy. To demonstrate
the accuracy of our cache
model,wecompareourresults
with the cache statistics re-
ported byGEM5. Towardthis
end, note that CANALmay
be usedas a standalone cache
simulator: if we compile the
LLVMbitcode instrumentedby CANALtoanexecutable andrunit
withaconcreteinput,itwillproducethecachestatisticsassociated
withthatparticularexecution.Figure 2showsthisusagecase,where
__CSIM_init_cache() and__CSIM_print_stat() areinsertedto
theoriginalCprogramtoinitializethecachestatesanddisplaythe
result,respectively.Thefunctionbodyof aes_encrypt() willbe
instrumented by CANALautomatically.
SincethecachestatisticsreportedbyGEM5includenotonlythe
main()function but also operating system code executed before
andafter,weneedtocreatetwoprogramversionsandthencom-
putetheirdifference.Oneoftheprogramsconsistsofthe main()
function and instructions inserted at the beginning and end ofthe
main()function to flush the cache, while the other program
consists of only these cache-flushing instructions with an empty
main()function body. By running these two programs and com-
putingthedifference,wehaveobtainedtheexactnumbersofcache
hits and misses reported by GEM5.
Table 1: Accuracy comparison: CANALversus GEM5
GEM5 CANAL
Name LoC Mem.access R.Miss W.Miss Time(s) R.Miss W.Miss Time(s)
Ary Acc 70 322,575 2,881 0 0.62 2,881 0 5.30
Bub.Sort 49 11,028,902 66,560 865 13.53 66,560 865 0.32
Ins.Sort 49 2,619,985 15,054 68 2.98 15,054 68 0.39
AES [1] 789 534 171 39 0.28 171 39 1.43
DES [1] 368 580 108 11 0.29 108 11 0.17
Table1shows the comparison of GEM5 and CANALfor five
example programs, including three sorting routines and two cryp-
tographic routines. The results are always identical. The sortingroutines exhibit a diverse range of memory-accessing behavior
based on input data (array of random integers). The cryptographic
routineshavesecurity-criticalcomputationsthatareoftentarget
ofside-channelattacks;theirinputsareanencryptedmessageof
â€œhelloworld!â€usingapredefinedencryptionkey.Toensurethatwe
trigger a rich set of cache behaviors during the experiments, we
configuredthecachetobe4-wayassociativitywithLRUreplace-
mentpolicy,64-bytelinesize,and1K-bytecachesize.Withalarger
cachesize,thesimulationspeedof CANALwillnotchangemuch
but there will be fewer cache conflicts.
3 APPLICATION SCENARIOS
We now demonstrate how CANALmay be used by KLEE, SMACK,
and Crab-llvm using five example programs taken from the SV-
COMPbenchmark[ 2]:copysome ,sanfoundry ,andstandard from
thearray-programs section,and gcdandsumfromthebit-vectors
section. We use a 4-way associative cache with LRU and 64-bytecache line while setting the cache size to 1 KB, 16 KB and 32 KB,
respectively. We set the timeout to one hour for each program.
3.1 Combined with Symbolic Execution Tools
Symbolic execution is a technique for systematically exploring fea-
siblepathsof aprogramandgeneratingtheir testinputs.Although
it has been used primarily for checking functional properties, with
CANAL, it can now be used to detect timing side-channel leaks.
Timing Side-channel Leaks. We say that a program P(k)with
sensitive input khas timing side-channel leaks if the execution
time ofPdepends on the value of k. That is, âˆƒk1,k2âˆˆdom(k):
Ï„(P,k1)/nequalÏ„(P,k2), wherek1andk2are values in the domain of
kandÏ„is the execution time. Even if the program executes the
same number (and type) of instructions, the execution time may
still differ if there are different numbers of cache hits/misses. Such
side-channel leaks may be detected by CANAL+ KLEE.
klee_make_symbolic(&input1);
klee_make_symbolic(&input2);
__CSIM_init_cache();
prog(input1);
h1 =__CSIM_num_hit;
m1 =__CSIM_num_miss;
__CSIM_init_cache();
prog(input2);
h2 =__CSIM_num_hit;
m2 =__CSIM_num_miss;
assert( h1==h2 && m1==m2 );
Figure 3: CANAL for tim-
ingsidechanneldetection.Figure3shows an exam-
ple,where input1andinput2
aremarkedassymbolicvalues
and used to run the program
prog()twice. After each ex-
ecution, the numbers of hitsand misses are stored in
h1,
m1,h2, andm2, respectively.
Finally, the assertion checksif
prog()is leak-free; that is,
âˆ€input1,input2 , the condi-
tion (h1==h2 && m1==m2 ) al-
ways holds. KLEE can be used to search for concrete values of
input1andinput2that violate the assertion.
Table2showstheresultsofrunningKLEEontheseprograms.
In each case, we manually modified the program to mark one or
more parameters as the sensitive input. Columns 3-5 show if a leak
is detected, together with the total number of tests generated and,
among them, the number tests that manifest the leak. Columns 6-8
show the time taken by KLEE for the different cache sizes.
Table 2: Results of the side-channel leak detection.
CANAL+ KLEE Time (s)
Name LoC Detection result Total-tests Leaky-tests 1K B 1 6K B 3 2K B
copysome 79 No leak 121 0 1.38 5.05 13.19
sanfoundry 95 No leak 81 0 1.32 2.16 2.82
standard 61 Leak 9 1 0.27 0.69 1.10
gcd 52 Leak 6 1 0.11 0.41 0.77
sum 56 Leak 6 1 0.07 0.38 0.74
3.2 Combined with Software Verification Tools
While symbolic execution is geared toward generating tests, verifi-
cation tools such as SMACK are geared toward generating proofs,
e.g., proving that an assertion holds under all test inputs. We show
howSMACKcanleverage CANALtoprovecacherelatedproperties.
Must-hits and Must-misses. One type of properties of interest
is assertions over auxiliary variables such as __CSIM_Load_ret
and__CSIM_Store_ret . For example, if a certain LoadorStore
instruction in the program always leads to a cache hit or miss,regardless of the program path and test input; in such a case, we
call it a Must-hit or a Must-miss.
CANALinstrument the LLVM bit-code in such a way that calls
to__CSIM_Load() and__CSIM_Store() setthevaluesofauxiliary
variables __CSIM_Load_ret and__CSIM_Store_ret toreflect the
cache status: truemeans the memory access leads to a hit, whereas
falsemeans it leads to a miss.
905
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:47:05 UTC from IEEE Xplore.  Restrictions apply. CANAL: A Cache Timing Analysis Framework via LLVM Transformation ASE â€™18, September 3â€“7, 2018, Montpellier, France
Figure4showsaprogramwherewecheckifreadof buffer[2]
is a Must-hit. Thus, we save the value of __CSIM_Load_ret imme-
diately after the read of buffer[2] to the variable named hand
add an assertion stating hshould always be true. If SMACK can
prove the assertion, we know the read of buffer[2] is a Must-hit.
Alternatively,wecanadd assert(h==false) anduseSMACKto
prove it is a Must-miss.
Sinceprogramverificationisundecidedingeneral(e.g.,equiv-
alent to the Turing-halting problem), SMACK may fail to prove
either assertion; in such a case, the result remains inconclusive. In
thisparticularexample,ho wever,SMA CKisabletofindaviolation
oftheMust-hitassertionandgenerateacounterexample.Thecoun-
terexample shows a scenario where buffer[0] andbuffer[16]
resides in two different 64-byte cache lines.
if (cond) buffer[0] = x;
else buffer[16] = y;
z = buffer[2];
h=__CSIM_Load_ret;
assert(h == true); // `Must-Hit'?
Figure 4: CANALfor must-
hit analysis.Table3shows the results
ofapplying CANAL+SMACK
toassertionswemanuallyin-
serted to check if a Load
orStoreinstruction in the
program is a Must-hit/miss.
Withloop-unrolling boundof
SMACK set to 10, and the
cachesizesetto1KB,SMACKsuccessfullyverifiedallassertions.
However,whenthecachesizewasincreasedto16KBand32KB,
SMACK started to timeout on some programs. This points out a
scalability limitation of SMACK, together with direction for future
work: improving the verification algorithms to make SMACK (and
similar tools) more scalable for non-functional properties.
Table 3: Results of the Must-hit analysis.
CANAL+ SMACK Time (s)
Name LoC Loop-unroll-bound Property Results 1K B 1 6K B 3 2K B
copysome 69 10 Must-miss Verified 226.87 TO TO
sanfoundry 75 10 Must-miss Verified 78.08 1055.55 TO
standard 38 10 Must-hit Verified 24.53 139.59 344.71
gcd 74 10 Must-miss Verified 22.88 142.78 375.27
sum 42 10 Must-miss Verified 36.53 257.68 723.21
3.3 Combined with Static Analysis Tools
Staticanalyzersbasedonnumericalabstractinterpretation[ 7],such
asCrab-llvm,cangenerateprograminvariants.Theseinvariants,
computed for each program location, are summaries over all paths
andinputvalues.Therefore,theycanbeusedtoestimatetheworst-
case execution time of a program. More specifically, by leveraging
CANAL,toolssuchasCrab-llvmcangenerateinvariantsinterms
of auxiliary variables such as (5 â‰¤__CSIM_num_Load_hitâ‰¤18).
if (cond) buffer[0] = 1;
else buffer[16] = 1;
buffer[5] = 1;
n_s_h = __CSIM_num_Store_hit;
n_s_m = __CSIM_num_Store_miss;
n_s = n_s_h + n_s_m;
__CRAB_assert(n_s_h > 1);
__CRAB_assert(n_s_m < 3);
__CRAB_assert(n_s == 2);
Figure 5: CANAL for com-
puting value ranges.Figure5showsan if-else
statement controlled by the
value of cond. Assume each
cache line contains 64 bytes,
the first 16 integers of the ar-ray fall into one cache line,
whereas the next 16 integers
starting with buffer[16] fall
intoanothercacheline.How-
ever, during static analysis,there is no way of knowing what the value of
condis; therefore,
one has to assume both branches may be taken.
When the Then-branch is taken, buffer[5] will be loaded to
the cache, which means the access to buffer[5] is a cache hit.
However, when the Else-branch is taken, buffer[5] will not be
loaded to the cache, which means the access to buffer[5] is a
cachemiss.Byusingnumericalabstractinterpretation,Crab-llvmcantakebothcasesintoconsiderationandcomputevalueranges
ofn_s,n_s_handn_s_m. For this example, in particular, the value
ranges would be [2,2] for n_s, [0,1] for n_s_h, and [1,2] for n_s_m.
Therefore,Crab-llvmcanprovethesecondandthethirdassertions,
while reporting a potential violation of the first assertion.
Inaddition,aninterestingapplicationofthevaluerangescom-
putedbynumericalabstractinterpretationistocomputetheworst-
case execution time (WCET), which depends on the maximum
number of cache misses along all program paths.
Table 4: Results of the numerical abstract interpretation.
CANAL+ Crab-llvm Time (s)
Name LoC S.Hit S.Miss L.Hit L.Miss 1K B 1 6K B 3 2K B
copysome 75 [1,âˆž] [2,âˆž] [1, âˆž] [0,âˆž]73.77 937.23 TO
sanfoundry 85 [0,âˆž] [3,âˆž] [4, âˆž] [1,âˆž]67.17 636.89 2416.82
standard 58 [0,âˆž] [1,âˆž] [1, âˆž] [0, 0] 13.06 528.53 2188.98
gcd 82 [0,âˆž] [2,âˆž] [6, âˆž] [0,âˆž]3.99 105.59 382.53
sum 54 [0,âˆž] [3, 3] [2, âˆž] [0, 0] 0.87 39.03 146.01
copysome-unroll 105 [22, 22] [4, 4] [43, 43] [0, 0] 91.62 452.34 1303.80
sanfoundry-unroll 168 [5, 15] [3, 3] [14, 29] [1, 5] 19.04 296.64 1149.54
standard-unroll 130 [10, 19] [2, 11] [20, 20] [0, 0] 21.11 279.30 985.24
gcd-unroll 107 [0, 13] [2, 3] [6, 27] [0, 0] 11.69 174.16 608.06
sum-unroll 123 [6, 12] [3, 3] [20, 32] [0, 0] 12.51 197.88 688.32
Table4shows the results of applying CANAL+Crab-llvm on the
exampleprograms.Columns3-6reportthevaluerangesofthetotal
numberStore-hits(S.Hit),Store-misses(S.Miss),Load-hits(L.Hit)
and Load-misses (L.Miss). Since these programs have loops and
Crab-llvmusesaggressiveover-approximationtoforcetermination
overloops,mostoftheupperboundsbecome +âˆž.Luckily,these
arefixed-boundloops,andafterweautomaticallyunrolledthese
loops, Crab-llvm obtained more accurate value ranges.
4 CACHE MODELING
We now briefly explain how cache is modeled inside CANAL.I t
isalightweight cachemodelinthatthemodelinginstructionsare
carefully designed to reduce the overhead of the verification tools.
Forexample,pointersaredifficulttohandlebyverificationtools;
therefore, we avoid using them in the instrumented code.
4.1 Pre-computing Address-to-Cache Mapping
Inside LLVM, we first obtain the memory address of each program
variable by analyzing the symbol table of the pre-compiled code.
Then, for the target computer architecture, we generate a memory
layout.Wetrytopre-computethepossibleaddressvalueforeach
load or store instruction in the program.
int var;//its cache `set' and `tag'
are 242 and 1, respectively
v a r=2 ;
__CSIM_Store(242, 1);
Figure 6: Pre-computed
â€˜setâ€™ and â€˜tagâ€™ values.If the address is a fixed
value, we compute its set
and tagfields in the cache,
and use these concrete val-ues to simplify the instanti-ation of
__CSIM_Load() and
__CSIM_Store() . Otherwise,
weresorttotheuseofif-elsestatementstodynamicallycompute
thesetandtagfields (more difficult to handle by verification tools).
Figure6showsasimplecasewheretheaddressof varisstatically
known,andthuswecanpre-computeits set(242)and tag(1).These
concretevaluesareusedtoinstantiate __CSIM_Store() .Although
CcodeisusedinFigure 6,thisisactuallyimplementedattheLLVM
bitcode level inside CANAL.
Figure7showsamorecomplexcase,wherethearrayisaccessed
using a variable i, and thus if-else statements are used to compute
thesetandtagofbuffer[i] .Althoughwecannotsimplifyasmuch
as in Figure 6, we can still pre-compute the value ranges of setand
tagbased on the address of the array. In particular, we can assume
the value range of setis [0,3] and the tagis always 242.
906
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:47:05 UTC from IEEE Xplore.  Restrictions apply. ASE â€™18, September 3â€“7, 2018, Montpellier, France Chungha Sung, Brandon Paulsen, and Chao Wang
4.2 Simplifying Updates of the Cache Statistics
buffer[i] = 20;
if (address_of_buffer + 4*i <
__CSIM_addr_of_cacheline01){
__CSIM_Store(242, 0);
} else if (address_of_test + 4*i <
__CSIM_addr_of_cacheline02){
__CSIM_Store(242, 1);
} else {
__CSIM_Store(242, 3);
}
Figure 7: Dynamically com-
puted â€˜setâ€™ and â€˜tagâ€™ values.To simplify the storageand update of cache sta-
tisticsso verificationtools
canhandlethemeasily,we
use a set of simple vari-ables as opposed to an ar-ray indexed by memory
addresses.Thiscandrasti-
cally reduce the complex-ity of the cache-modelinginstructions inside func-
tions__CSIM_Load() and__CSIM_Store().
function __CSIM_Store(set, tag) {
if (set == 0) {
if (__CSIM_cacheline00_taken &&
__CSIM_cacheline00_tag==tag){
// cache hit
__CSIM_num_Store_hit ++;
__CSIM_Store_ret = true;
} else if (...) {
// cache hit
...
} else {
// cache miss
__CSIM_num_Store_miss ++;
__CSIM_Store_ret = false;
// pick a new line based on
the update policy
...
}
} else if (set == 1) {
...
} else if (set == 2) {
...
}
...
}
Figure 8: Code snippet of
__CSIM_Store.Figure8shows the in-
ternals of __CSIM_Store() ,
which updates the cache sta-
tistics based on the valuesofsetandtag. Instead of us-
ingmonolithicarrayssuchas
cacheline[set].tag ,weuse
individual variables such as
__CSIM_cacheline00_tag.
The number 00 means the
cache line isassociated with
set0andway0,andtheauxil-
iary variable denotes the tag
saved at the line. When a
cache miss occurs, for exam-
ple, we update the value of
cacheline00_tag aswellas
the values of similar auxil-iary variables, and evicts a
victim. In this implementa-
tion, LRU policy is used to
computethevictim;butotherreplacementpoliciesmaybeincor-
porated into CANALeasily.
Implementations of __CSIM_Store() and__CSIM_Load() are
specifictoeachindividualprogramunderverification,andtherefore
they are generated by CANALautomatically.
5 RELATED WORK
CANALis the first LLVM-based lightweight cache modeling frame-
workdesignedspecificallyforsoftwareverificationtools.Although
thereareothercachesimulators[ 3,12]andCPUsimulatorssuch
asGEM5[ 9],theyarenot designedforthispurpose.Inparticular,
they cannot be used in the same way as CANALto afford existing
verification tools the capability of verifying a new class of cache
related non-functional properties.
There are also tools designed specifically for WCET analysis
based on cache analysis [ 5,6,13] and for detecting cache timing
side channels [ 8,11,15]. However, the modeling part of these tools
are tied up with the subsequent analysis part, and therefore cannotbeusedbyotherverificationtools.Furthermore,theanalysispartof
these tools is rarely open-source, and often not as well-maintained
asthemainstreamsoftwareverificationtools,whichareupdated
constantly to keep up with the competition [2].
Although our main contribution in this work is the lightweight
cachemodelingthatfacilitatesthesubsequentanalysisandverifica-
tion, there is still room for improvement in the analysis and verifi-
cation algorithms. Since cache timing behaviors are non-functionalproperties, they often have significantly different characteristics
from functional properties,andthusmaybenefitfromspecialized
algorithms to make verification more efficient and scalable.
Our implementation of CANALhas been tested on programs
fromtwodomains:real-timesoftwareandembeddedsoftware.In
both cases, theprogram structure and language constructsare rel-
atively simple. To handle C/C++ programs in other applicationdomains, more sophisticated static analyses may be needed, e.g.,to deal with pointer aliasing and complex loops during the pre-
computationofaddress-to-cachemappingandupdatesofthecachestatistics,inordertokeeptheapplicationofourLLVMbasedtrans-
formation efficient. We also plan to further refine our cache model,
e.g., to handle multi-threading as well as multi-level cache.
6 CONCLUSIONS
Wehavepresented CANAL,aframeworkformodelingcachebehav-
iorsofaprogrambasedonLLVMtransformations,whichallows
standard software verification tools to check cache timing proper-
ties. We demonstrated the accuracy of our cache model in CANAL
by comparing with the simulation results of GEM5, as well as the
effectivenessofcombining CANALwiththreeexistingtools(KLEE,
SMACK and Crab-llvm) in verifying cache related properties.
ACKNOWLEDGMENTS
ThisworkwassupportedinpartbyNSFundergrantsCNS-1617203
and CNS-1702824 and ONR under grant N00014-17-1-2896.
REFERENCES
[1]AES/DES in openSSL. https://github.com/openssl/openssl/tree/OpenSSL_0_9_7-
stable/crypto/. Accessed: 2018-04-18.
[2]Dirk Beyer. Software verification and verifiable witnesses. In TACAS, pages
401â€“416, 2015.
[3]M. Luisa CÃ³rdoba Cabeza, M. Isabel GarcÃ­a Clemente, and M. Luz Rubio.
CacheSim: A cache simulator for teaching memory hierarchy behaviour. In
SIGCSE/SIGCUE, 1999.
[4]Cristian Cadar, Daniel Dunbar, and Dawson Engler. KLEE: Unassisted and
automatic generation of high-coverage tests for complex systems programs. In
OSDI, pages 209â€“224, 2008.
[5]SudiptaChattopadhyayandAbhikRoychoudhury. Scalableandpreciserefine-
ment of cache timing analysis via model checking. In RTSS, pages 193â€“203,
2011.
[6]Duc-HiepChu,JoxanJaffar,andRasoolMaghareh. Precisecachetiminganalysis
via symbolic execution. In RTAS, pages 1â€“12, 2016.
[7]Patrick Cousot and Radhia Cousot. Abstract interpretation: A unified lattice
modelforstaticanalysisofprogramsbyconstructionorapproximationoffix-
points. In POPL, pages 238â€“252, 1977.
[8]Goran Doychev, Dominik Feld, Boris KÃ¶pf, Laurent Mauborgne, and Jan Reineke.
CacheAudit: A tool for the static analysis of cache side channels. In USENIX
Security, pages 431â€“446, 2013.
[9]Nathan Binkert et al. The Gem5 simulator. SIGARCH Comput. Archit. News,
39(2):1â€“7, August 2011.
[10]Graeme Gange, Jorge A.Navas, Peter Schachte, Harald SÃ˜ndergaard, and PeterJ.
Stuckey. Anabstractdomainofuninterpretedfunctions. In VMCAI,pages85â€“103,
2016.
[11]Shengjian Guo, Meng Wu, and Chao Wang. Adversarial symbolic execution for
detecting concurrency-related cache timing leaks. In FSE, 2018.
[12]Aamer Jaleel, Robert S Cohn, Chi-Keung Luk, and Bruce Jacob. CMP $im: A
pin-basedon-the-flymulti-corecachesimulator. In Workshop on Modeling, Bench-
marking and Simulation, co-located with ISCA, pages 28â€“36, 2008.
[13]Y-TSLi,SharadMalik,andAndrewWolfe. Cachemodelingforreal-timesoftware:
Beyond direct mapped instruction caches. In RTSS, pages 254â€“263, 1996.
[14] Zvonimir RakamariÄ‡and MichaelEmmi. SMACK: Decouplingsource language
details from verifier implementations. In CAV, pages 106â€“113, 2014.
[15]Meng Wu, Shengjian Guo, Patrick Schaumont, and Chao Wang. Eliminating
timing side-channel leaks using program repair. In ISSTA, pages 15â€“26, 2018.
907
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:47:05 UTC from IEEE Xplore.  Restrictions apply. 