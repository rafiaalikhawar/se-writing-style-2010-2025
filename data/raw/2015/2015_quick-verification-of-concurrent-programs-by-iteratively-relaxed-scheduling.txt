Quick V eriﬁcation of Concurrent Programs by
Iteratively Relaxed Scheduling
Patrick Metzler, Habib Saissi, Péter Bokor, Neeraj Suri
Technische Univeristät Darmstadt, Germany
{metzler, saissi, pbokor, suri}@deeds.informatik.tu-darmstadt.de
Abstract —The most prominent advantage of software ver-
iﬁcation over testing is a rigorous check of every possible
software behavior . However, large state spaces of concurrentsystems, due to non-deterministic scheduling, result in a slow
automated veriﬁcation process. Therefore, veriﬁcation introduces
a large delay between completion and deployment of concurrent
software.
This paper introduces a novel iterative approach to veriﬁcation
of concurrent programs that drastically reduces this delay. Byrestricting the execution of concurrent programs to a small
set of admissible schedules, veriﬁcation complexity and time is
drastically reduced. Iteratively adding admissible schedules after
their veriﬁcation eventually restores non-deterministic schedul-
ing. Thereby, our framework allows to ﬁnd a sweet spot between a
low veriﬁcation delay and sufﬁcient execution time performance.Our evaluation of a prototype implementation on well-known
benchmark programs shows that after verifying only few sched-
ules of the program, execution time overhead is competitive to
existing deterministic multi-threading frameworks.
I. I NTRODUCTION
Automated veriﬁcation of concurrent programs with non-
deterministic scheduling is known to be challenging: veriﬁca-
tion has to consider all possible schedules a concurrent pro-gram may be executed with, which may result in exponentiallymany states to be veriﬁed, known as state space explosion [1].
Partial order reduction (POR) is able to reduce the state
space of a concurrent program by identifying equivalenceclasses of program executions such that only one represen-tative of each class needs to be veriﬁed [2]–[4]. Such anequivalence class is called Mazurkiewicz trace or simply trace.
However, the reduced state space may still be of exponentialsize [3]. Hence, the high complexity of state space explorationfor concurrent systems remains and hinders a wide applicationof automated veriﬁcation (e.g., model checking) in industrialsoftware development.
In particular, veriﬁcation introduces a considerable delay
between completion and deployment of software. When de-velopment of a candidate program is complete, it may be
deployed only after the veriﬁer approved that it is correct
under all possible schedules. This veriﬁcation delay reaches
large values for benchmark programs even if state-of-the-artPOR is used [5], [6]. We conjecture that the veriﬁcation delayis unacceptably high for large areas of industrial softwaredevelopment. Nevertheless, individual traces can be veriﬁedquickly as can be seen when relating veriﬁcation time to thenumber of explored traces.In the area of concurrency testing, deterministic multi-
threading (DMT) can help to reduce the number of necessarytest cases. Several techniques exist to restrict scheduling suchthat (1) scheduling is deterministic for a particular inputand/or (2) only a reduced set of schedules may occur [7], [8].Such DMT techniques trade potential execution time overhead(compared to executing the unmodiﬁed program) for reduced
non-determinism that may simplify testing. However, these
approaches do not allow to control the schedule that will
occur in advance, which renders them unsuitable for automatedveriﬁcation of concurrent programs. We are not aware of
any existing tool or concept that allows to execute selectedschedules after they are successfully veriﬁed. Moreover, it
is not possible to adjust the amount of non-determinism inexisting DMT approaches.
We propose to make the amount of non-determinism and
thereby the veriﬁcation delay adjustable by using interme-diate veriﬁcation results and reducing non-determinism bydynamically constrained scheduling. In particular, instead of
waiting for veriﬁcation to complete, we propose to use inter-mediate veriﬁcation results that guarantee program correctnessfor one or more schedules. By generalizing the concept of
Mazurkiewicz traces [9] for symbolic model checking, we areable to use POR as a veriﬁcation technique with intermediate
veriﬁcation results. As soon as a single trace is veriﬁed, theprogram may be used inside a suitable execution environmentwith constrained scheduling. By continuously verifying andpermitting more traces, scheduling constraints are iteratively
relaxed and, as shown by our evaluation, execution time
overhead is reduced. Thus, execution time overhead can betraded for veriﬁcation delay.
We provide the following contributions. (1) We develop
a formal framework for iterative, automated veriﬁcation ofconcurrent programs. (2) We introduce the concept of symbolic
traces as an extension and generalization of Mazurkiewicz
traces to symbolic model checking. (3) We discuss implemen-tation issues for a suitable execution environment using ourprototype implementation for LL VM programs [10]. (4) We
show experimentally that only few traces need to be veriﬁed
to considerably reduce execution time overhead.
II. O
VERVIEW
We propose iteratively relaxed scheduling (IRS) for con-
current programs with non-deterministic scheduling as an
978-1-5386-2684-9/17/$31.00 c/circlecopyrt2017 IEEEASE 2017, Urbana-Champaign, IL, USA
T echnical Research - New Ideas776
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:03 UTC from IEEE Xplore.  Restrictions apply. V eriﬁer Execution
environment
(unconstrained
scheduling)
V erify
program
Program
can be
safely
used
(a) ConventionalV eriﬁer IRS Execution
environment
V erify
program
Submit initialschedule
Iterativelysubmit
additional
schedules
Permit allschedulesProgramcan be
safely
used
(b) IRS
Figure 1: The program veriﬁcation process (sequence diagram)
improvement over the conventional approach to program ver-
iﬁcation:
(1) Develop a program (or program update).(2) V erify the program.(3) The program can be safely used (with unconstrained
scheduling).
In case veriﬁcation is successful, correctness is ensured forall feasible schedules of the program. This guaranty comesat the price of a typically large veriﬁcation delay becauseof exponentially many schedules when unconstrained (non-deterministic) scheduling is used.
Instead of waiting until the program is veriﬁed for all
feasible schedules, we propose to start using the programalready after a use case-speciﬁc threshold of schedules hasbeen veriﬁed. Correctness is guaranteed by wrapping theprogram in an IRS execution environment, which permits only
veriﬁed schedules by constraining scheduling. We provide
details about IRS execution environments in Section III.Speciﬁcally, verifying a concurrent program with IRS proceedsas follows.
(1) Develop a program (or program update).
(2) Continuously verify individual schedules or sets of sched-
ules.
(3) As soon as one admissible schedule is available, the
program can be safely used inside an IRS executionenvironment.
(4) Additional veriﬁed schedules may be added during pro-
gram usage to relax scheduling constraints.
The difference between conventional veriﬁcation and IRS is
illustrated in Figure 1. While conventionally the veriﬁcationdelay corresponds to the full veriﬁcation time, IRS enables toadjust veriﬁcation delay and the amount of non-determinismin scheduling: the longer the veriﬁcation delay, the more
schedules are veriﬁed and the fewer scheduling constraintsare necessary to enforce that only admissible schedules mayoccur.
Constraining scheduling presumably introduces consider-
able execution time overhead. While execution time overhead
may be considerable, relaxing scheduling constraints is able toquickly reduce this overhead. Our experiments show that iter-atively relaxing scheduling constraints also iteratively reducesexecution time overhead, which we detail in Section V.
Given a positive relationship between relaxed scheduling
constraints and decreased execution time overhead, IRS maybe used to exploit the sweet spot between a short veriﬁcationdelay and small execution time overhead. In other words,IRS enables to use as much non-determinism in scheduling
as needed for execution time performance and no more non-
determinism than necessary in order to limit the veriﬁcation
delay.
An additional advantage of IRS over conventional program
veriﬁcation is that programs that show both correct and erro-
neous schedules can be used safely, as erroneous schedulesare never enabled. Such a program may be either correctedsuch that eventually, all schedules can be enabled, or leftunchanged such that the program is used with erroneous sched-ules disabled. In contrast, conventional veriﬁcation requires tocorrect the program so that the program is only available after
veriﬁcation is restarted and completed successfully. Please
note that it is well possible that a program that is used inside anIRS execution environment has erroneous schedules. However,program usage inside the IRS environment is always safeas only correct schedules are enabled. The only limitationin such a case is that the program cannot be used safely
with all schedules enabled (e.g., outside the IRS executionenvironment).
Several scenarios of how to use IRS are conceivable, e.g.:
(1) Safely deploy programs with large state spaces due to
concurrency that are infeasible to fully verify.
(2) In case a program update introduces a bug but correct
schedules can still be found, safely deploy the program
with erroneous schedules disabled until the bug is ﬁxed.
(3) For a given time budget for veriﬁcation (maximum veriﬁ-
cation delay), verify as much schedules as possible untilthe threshold is reached and deploy the program (withthe remaining schedules disabled). V eriﬁcation delay isreduced.
(4) For a given budget of execution time performance (e.g.,
maximum execution time overhead), start veriﬁcation andcontinuously test the execution time performance for theso far veriﬁed schedules. As soon as the program isfast enough, deploy the program (with the remainingschedules disabled). V eriﬁcation delay is reduced.
(5) In addition to (4), continue veriﬁcation after deployment
and continuously extend the set of veriﬁed and enabled
schedules. Execution time performance is increased afterdeployment. (It is required to update scheduling con-
777
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:03 UTC from IEEE Xplore.  Restrictions apply. straints online. With a suitable implementation, it is not
necessary to update the program itself.)
Depending on the speciﬁc requirements of a use case, it
may be suitable or even necessary to combine or extendthese scenarios. As we detail in Section IV, it is possible torealize an IRS execution environment completely inside anapplication program, without modifying the operating system.
In order to execute programs safely inside an IRS execution
environment (i.e., such that the speciﬁcation is never violated)while preserving usability (i.e., such that full program func-tionality is available), it must be ensured that intermediateveriﬁcation results correspond to scheduling constraints thatdescribe how to remain inside the known-to-be-safe statespace for arbitrary program inputs. Thereby, it is guaranteed
that the program is safely executed regardless of the current
input. While this requirement may be strong for programswith non-deterministic inputs, the same limitation applies forveriﬁcation of sequential programs.
Although there exist techniques to deterministically execute
concurrent programs (e.g., [7], [8], [11]) in order to supportconcurrency testing, IRS constitutes a novel approach to
verifying concurrent programs. To our best knowledge, all
existing DMT approaches depend on concrete program inputsfor enforcement of a deterministic execution: no guarantyis given about which schedule is used after a change inprogram inputs. However, program veriﬁcation requires correctbehavior for every possible program input. Consequently,using an existing DMT approach for veriﬁcation would requireto verify a program separately for each individual input, whichis typically infeasible.
III. A
PPROACH
A key requirement for a veriﬁcation technique to be useful
in conjunction with IRS is to yield meaningful intermediateveriﬁcation results. Otherwise, safe execution of the programwould have to wait until the program has been veriﬁed forall schedules and IRS would be reduced to conventionalveriﬁcation. Meaningful intermediate veriﬁcation results eithershow a counter example for program correctness or guaranteecorrectness under certain scheduling constraints. No additionalconstraints should be necessary such as constraints aboutprogram inputs or execution length, as a program may not befully operational under such constraints. Therefore, techniquessuch as explicit state model checking or bounded modelchecking are unsuitable for IRS.
Partial order reduction (POR) is a state space reduction
technique suitable for symbolic model checking [12], although
it is often presented for explicit-state model checking [4]–
[6]. We choose POR as a veriﬁcation technique to instantiateIRS and extend the notion of Mazurkiewicz traces to a novelconcept of symbolic traces in order to support symbolic
model checking with meaningful intermediate veriﬁcation re-
sults. An alternative technique for reducing the complexityof non-deterministic scheduling, iterative context bounding(ICB) [13], would equally ﬁt to produce meaningful interme-diate veriﬁcation results. However, to our knowledge, ICB has
not been applied to symbolic model checking before.
A. System Model
A (concurrent) program P is a transition system
(S,S
init,Σ,→)whereSis a ﬁnite set of states, Sinit⊆S
is a set of initial states (program intputs), Σis a ﬁnite set
of threads, and →P⊆(S×Σ)/arrowrighttophalfS is an acyclic transition
relation (for a given state and thread, there is at most one
successor state). We write s1t− →s2to denote (s1,t,s 2)∈→ .
Apartial execution ofPis an initial state (the program
input for this execution) and a sequence (s0,u)∈Sinit×Σ∗,
whereu=t1...t nsuch that there exist states s1,...,s nwith
s0t1− →s1···tn− →sn(s0may be omitted if it is clear from
the context or arbitrary). In order to uniquely describe each
occurrence tiof a thread in u, it is associated with an event
e∈Σ×Nsuch that e=(t,k)withk=|{tj:j<i∧tj=
ti}|, i.e.,especiﬁes the thread tiand the number of thread
occurrences of tithat occur before position iinu.
We assume the existence of a dependency relation for P
that induces a happens-before relation between events and anotion of Mazurkiewicz equivalence on partial executions [6],[9]. We extend the notion of Mazurkiewicz traces to symbolictraces as follows. A symbolic trace or simply traceoofP
is a graph o=(E
o,Co,→o)that represents a partial order,
the happens-before relation, of some partial execution uofP
and all partial executions that are Mazurkiewicz equivalent to
u. We say that uis a linearization ofo. Letu=t1...t n
be an arbitrary linearization of osuch that there exist states
s1,...,s nwiths0t1− →s1···tn− →sn.Eo={e1,...,e n}is a
set of events such that eicorresponds to tifor1≤i≤n.
Cois a set of sets of path constraints (that may be collected
during model checking). →o⊆Eo×Co×Eois an edge relation
between events annotated with path constraints such that for
every event ei∈Eoand every incoming edge of eiwith path
constraints C,sisatisﬁesC. We write traces(P)for a set of
traces that completely cover the state space of P, i.e., it is
sufﬁcient to verify all traces in traces(P)in order to decide
correctness of P.
B. Algorithm
Given a program P, we deﬁne an IRS execution environ-
ment that is able to (1) continuously receive representations ofadmissible traces from a veriﬁer and (2) schedule the programPsuch that only admissible executions occur. V eriﬁer and
execution environment of Pare deﬁned by Algorithm 1.
During execution of a program, the IRS execution envi-
ronment maintains that the current partial execution (s
0,u)
adheres to the scheduling constraints represented by someadmissible trace o, for which we write (s
0,u)/precedesorcurlyo.W e
formalize this notion for a sequence u=t1...t nwith
s0t1− →s1···tn− →snfor some states s0,...,s nandowith
eventsEo={e1,...,e m}as(s0,u)/precedesorcurlyoif
(1)uis empty or
778
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:03 UTC from IEEE Xplore.  Restrictions apply. Algorithm 1: IRS
Data:V– the set of admissible traces, initially empty
1V eriﬁer:
2 for each trace ointraces(P)do
3 verifyo;
4 ifois correct then
5 addoto the set of admissible traces V;
6Execution environment:
7 set the current partial execution (s 0,u) to the empty
sequence;
8 whilePhas not terminated do
9 choose some thread tfrom admissible (V,s 0,u);
10 execute the next event of t;
11 appendttou;
(2) there exists some ei∈Eothat represents t1and for
all incoming edges with path constraints C,s0does not
satisfyCand(s1,t2...t n)/precedesorcurlyremove(ei,o)
where remove(ei,o)isowitheiand all incoming and
outgoing edges of eiremoved. Intuitively, (s0,u)/precedesorcurlyocan be
checked as follows: if uis empty, the condition is satisﬁed, as
they do not contain any events that can violate any ordering
given by o.I fuis not empty, check whether the ﬁrst element
ofucorresponds to an event eiinothat has no incoming edge
that satisﬁes the current path constraints (i.e., no event has tobe scheduled before under the current program inputs). Thecondition is satisﬁed if uwithout its ﬁrst element adheres to
owithe
iand all adjacent edges removed.
For a given partial execution (s0,u)and a set of admissible
tracesV, we deﬁne the set of all threads that can be executed
next, without violating adherence to an admissible trace, asadmissible (V,s
0,u): ={t∈ΣP:∃o∈V.(s0,u·t)/precedesorcurlyo}.
When large fractions of a program’s state space are to be
explored, i.e., when Vcontains many traces, time and space
complexity of checking t∈admissible (V,s 0,u)and(s0,u)/precedesorcurly
omay be relevant. An efﬁcient implementation of Algorithm 1
may use, for example, a compact representation of multipletraces in a single data structure.
The execution environment representation of Algorithm 1
corresponds to the interleaving semantics of concurrent pro-grams. It does not show explicitly when threads wait forpermission to execute their next memory access. In a simpleimplementation, a thread waits before each memory access,which corresponds to one wait operation per loop iteration ofthe execution environment. For a possible implementation ofan execution environment, please refer to Section IV.
Correctness In order to use IRS for program veriﬁcation,
it is necessary to ensure that an IRS execution environmentpermits only correct traces, i.e., traces that show correctprogram behavior. For Algorithm 1, it is clear that onlyexecutions that adhere to a admissible trace may occur bythe deﬁnition of admissible ().1%20 = call i32 @getThreadId(%"class.indexer::WorkUnit"∗ %this)
2%21 = alloca i32
3store i32 %20, i32∗ %21
4%22 = load i32, i32∗ %21
5%23 = bitcast i32∗ %17 to i8∗
6call void @before_memory_access(i32 %22, i8∗ %23, i64 4, i32 1)
7%24 = cmpxchg i32∗ %17, i32 0, i32 %19 seq_cst seq_cst
8call void @after_memory_access(i32 %22)
Listing 1: A global memory access (cmpxchg) after inserting callbacks
directly before and after.
Progress Besides correctness, progress is required in order
to safely use a program inside an IRS execution environ-
ment with the same functionality as the unmodiﬁed program.Progress for an IRS execution environment expresses thatas long as a program has not yet terminated, there exists
a thread that can be scheduled next in coherence with a
admissible trace, i.e., admissible (V,s
0,u)is not empty. In
other words, progress means that IRS does not introduceadditional deadlocks into the program. Algorithm 1 providesprogress, as only complete traces are added by the veriﬁer.
IV . I
MPLEMENT A TION
We have implemented IRS in a C++ prototype that uses
the LL VM compiler infrastructure [10] to automatically in-strument LL VM-IR code and enforces a set of admissibletraces when executing the program. This design allows to
use IRS for programs that can be translated to LL VM-IR,e.g., C or C++ programs. After instrumenting a program and
linking to our IRS library, the program can be safely used(provided that at least one correct schedule is known) withoutmodifying the operating system or any other parameters of
the environment. We do not see fundamental obstacles to
implement IRS differently, e.g., inside a Java virtual machine(for programs that can be translated to Java bytecode) or witha customized scheduler inside the operating system.
Our implementation consists of an LL VM pass responsible
for instrumentation and a library that enforces speciﬁed tracesin instrumented code. The instrumentation inserts a callback tothe library directly before and after memory access instructions
(load, store, compare-and-swap). Only those memory accesses
are instrumented that directly access a global variable or wherethe address of the access depends (possibly transitively) onthe value of a global variable. Hence, the library sees threadexecutions as a sequence of events that contain exactly one
global memory access. We consider two events dependent if
they access the same memory location and at least one of themis a write operation.
Listing 1 shows the global memory access of the Indexer
benchmark [4] and how callbacks are inserted. Identiﬁers havebeen renamed for easier readability. Only line 7 (contain-ing the compare-and-swap instruction
cmpxchg ) is contained
in the original program. All additional lines are added by
our instrumentation. Before the memory access, thread ID,memory location and whether the access can modify thememory are reported by callback
before_memory_access to the
779
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:03 UTC from IEEE Xplore.  Restrictions apply. library, where the event is recorded. After the memory access,
callback after_memory_access signals that the memory access
is completed. At the beginning of the program, an additional“scheduler” thread is started, which collects recorded eventsand decides whether an event is currently admissible.
When a program thread enters the callback function before
a memory access, it checks whether it is necessary to wait foran other thread in order to follow the set of admissible traces.
Only if this is the case, synchronization with the schedulerthread is necessary. The program thread appends its currentevent to a queue of requests and waits on a C++ conditionvariable. Once the scheduler thread reads the request andthe corresponding event is admissible, the program thread issignaled and continues by locking the memory location ofthe current access, performing the memory operation, andrecording the executed event.
When testing our implementation, we found that as ex-
pected, locks and condition variables are responsible for alarge portion of execution time overhead. In order to reduce thenumber of locks, we introduced busy-waiting in the schedulerthread, which made synchronization between program threadsand the scheduler thread faster for most cases. However, insome cases, synchronization may also be much slower, whichmay be a disadvantage if execution time should never exceeda tight maximum. We expect further improvement by the useof more advanced lock-less synchronization.
Alternative implementation approaches that do not use an
additional scheduler thread are well conceivable and we expectimportant insights from comparing different implementation
approaches. For example, it might be overall faster to perform
scheduling tasks locally in program threads instead of thescheduler thread. Even if this duplicates work, execution timemight be improved by omitting synchronization.
V. E
XPERIMENT AL EV ALUA TION
We concentrate our experimental evaluation on supporting
the claim that iteratively relaxing scheduling constraints de-
creases execution time overhead. Experimentally validating
this claim would show that it is feasible to use IRS to adjustand ﬁnd a sweet spot between veriﬁcation delay and executiontime overhead. As development of our prototype is only in anearly stage, we do not provide a full experimental evaluation
but report preliminary results for two benchmark programs
Indexer [4] and Last Zero [6] that are used to evaluate PORalgorithms. These programs have been chosen because model-checking them with POR is well-studied. We use the Last Zerobenchmark with 15 worker threads, for which Abdulla et al.report 147456 traces and 1813s execution time for POR. For
Indexer, we use 15 threads, where Abdulla et al. report 4096
traces and 3155s execution time for POR [6].
Table I shows our experimental results. Each benchmark
is run without instrumentation (plain) and instrumented by
our prototype (IRS). The number of admissible traces isgradually increased. Each conﬁguration is run 1000 times. Wereport the median execution time and execution time overheadin comparison to the unmodiﬁed benchmark. Illustrating theTable I: E XECUTION TIME OVERHEAD OF IRS AND VERIFICA TION DELA Y
Benchmark #Traces Time (μs) Overhead Delay (s)
(interpolated)
Last Zero (IRS) 1 623 230% 0
Last Zero (IRS) 128 506 168% 2
Last Zero (IRS) 1024 486 157% 13
Last Zero (IRS) 16384 402 113% 201
Last Zero (plain) 147456 189 0% 1813
Indexer (IRS) 1 2614 1321% 1
Indexer (IRS) 16 2352 1178% 12
Indexer (IRS) 256 859 367% 197
Indexer (IRS) 2048 761 314% 1578
Indexer (plain) 4096 184 0% 3155
interplay of execution time overhead and veriﬁcation delay, weshow the linearly interpolated veriﬁcation delay for veriﬁcationtimes given by Abdulla et al. as an approximation of howlong a model checker would need to verify the correspondingnumber of traces.
For both benchmarks, execution time overhead can be
reduced considerably by permitting only a small portion ofall traces. For Last Zero, permitting less than 1% of all tracesreduces execution time overhead from 230% to 168%. ForIndexer, permitting 6% of all traces reduces execution timeoverhead from 1321% to 367%. However, execution timeoverhead is reduced less drastically when additional traces arepermitted. Nevertheless, execution time overhead with onlyfew admissible traces is competitive with the execution timeoverhead of up to about 700% and 300% reported for CoreDetand Dthreads [7].
VI. R
ELA TED WORK
Approaches that attempt to limit the amount of non-
determinism in the behavior of multi-threaded programs per-form deterministic multi-threading (DMT) and may be imple-mented using runtime systems [8], [11], [14], libraries [7], andOS modiﬁcations [15]. Liu et al. present Dthreads [7] as a re-placement for the multi-threading library Pthreads. For a given
input, Dthreads forces a deterministic execution by allowing
threads to execute in parallel, updating separate copies of theshared state. The separate copies are then merged back in adeterministic order once a synchronization point is reached. In[11], Cui et al. propose to enforce deterministic schedules byrecording initial executions and reusing the executed schedulesubsequently on compatible executions with similar inputs.Another deterministic approach is Parrot [8], which combinesa runtime environment with constrained scheduling with amodel checker for bug-ﬁnding. Only performance-critical partsof the program need to be model-checked that are manuallyexcluded from deterministic scheduling.
The main difference between these DMT approaches and
IRS is that the former support concurrency testing, while our
approach is suitable for program veriﬁcation by supporting
symbolic program inputs. Using existing DMT approaches for
veriﬁcation seems unrealistic as their scheduling constraintsdepend on concrete program inputs, which would requireto verify all possible inputs separately. Another limitation
780
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:03 UTC from IEEE Xplore.  Restrictions apply. of above described DMT approaches are ﬁxed scheduling
constraints that cannot be relaxed at runtime. In contrast,our approach allows to automatically and iteratively relaxscheduling constraints at runtime, eventually leading to allschedules (that are successfully veriﬁed) being permitted.Additionally, these DMT approaches either provide no fairnessin scheduling (completely deterministic execution) or providefairness for parts of the program by completely unconstrainedscheduling. IRS, in contrast, may provide controlled fairnessby enabling corresponding schedules and enabling them.
Another line of work deals with limiting the number of
context switches to facilitate concurrency bug detection and
concurrency testing. In [16] and [17], programs are model-checked using bounded model checking (BMC) where the
SMT formula is further constrained to allow only a certain
number of context switches. By doing so, they reduce thenumber of program executions that the SA T/SMT solver hasto consider. Musuvathi et al. [13] take this further by usingan iterative approach to context switch bounding (ICB). Theystart with an initial number of context switches, and iterativelyallow more to gain a higher conﬁdence in the correctness ofthe program. In this approach, the model checker implementsan explicit state space exploration strategy that systematicallyexplores all possible executions as long as a number of contextswitches is not exceeded. While these techniques only dealwith bug ﬁnding and concurrency testing, IRS proposes a
complete veriﬁcation deployment solution. Nevertheless, weexpect that the concept of ICB can be applied to symbolic
model checking as well and therefore could be used as averiﬁcation technique under IRS. To our knowledge, ICB hasnot yet been applied to symbolic model checking.
In addition to scheduling, a source of non-determinism
are relaxed memory models in modern architectures. Relaxedmemory models allow more feasible orderings than the morerestricted sequential consistency model (SC) leading to moreprogram behavior that has to be covered by the model checker.In [18], a memory monitoring approach is proposed to makesure that SC is maintained during the execution of a program.Fang et al. in [19] present an automated memory fenceinsertion technique to enforce SC using instrumentation atthe source code level. In both cases, the program can besafely veriﬁed under the assumption that SC holds with areduced state space. Similarly to IRS, these approaches restrictthe amount of non-determinism. However, in contrast to IRS,they are not able to dynamically adapt the amount of non-determinism and are restricted to non-determinism due torelaxed memory access.
VII. C
ONCLUSION
We propose a formal framework for iteratively relaxed
scheduling (IRS) as a method to make both veriﬁcationdelay and the amount of non-determinism in scheduling ofconcurrent programs adjustable. By enforcing scheduling con-
straints, multi-threaded programs can be safely used even if the
program has only partially been veriﬁed. We outline severalscenarios of how to use IRS to enable veriﬁcation of programswith intractably-large state spaces, enable safe deployment
of programs with erroneous schedules, handle veriﬁcationwithin a given time budget, manage execution time overhead,and increase execution time performance after deployment.Our preliminary experimental results suggest that iterativelyrelaxing scheduling constraints gradually reduces executiontime overhead.
A
CKNOWLEDGMENTS
We thank the anonymous reviewers for their constructive
comments. Research supported, in part, by H2020-644579(ESCUDO-CLOUD).
R
EFERENCES
[1] A. V almari, “The state explosion problem,” in Lectures on Petri Nets I:
Basic Models, Advances in Petri Nets, ser. LNCS, vol. 1491. Springer,
1996.
[2] E. M. Clarke, O. Grumberg, M. Minea, and D. Peled, “State space
reduction using partial order techniques,” International Journal on
Software T ools for T echnology Transfer (STTT), vol. 2, no. 3, 1999.
[3] P . Godefroid, Partial-Order Methods for the V eriﬁcation of Concurrent
Systems - An Approach to the State-Explosion Problem, ser. LNCS.Springer, 1996, vol. 1032.
[4] C. Flanagan and P . Godefroid, “Dynamic partial-order reduction for
model checking software,” in Symposium on Principles of Programming
Languages (POPL). ACM, 2005.
[5] G. Gueta, C. Flanagan, E. Y ahav, and M. Sagiv, “Cartesian partial-
order reduction,” in International SPIN W orkshop, ser. LNCS, vol. 4595.
Springer, 2007.
[6] P . A. Abdulla, S. Aronis, B. Jonsson, and K. F. Sagonas, “Optimal
dynamic partial order reduction,” in Symposium on Principles of Pro-
gramming Languages (POPL). ACM, 2014.
[7] T. Liu, C. Curtsinger, and E. D. Berger, “Dthreads: efﬁcient deterministic
multithreading,” in Symposium on Operating Systems Principles (SOSP).
ACM, 2011.
[8] H. Cui, J. Simsa, Y . Lin, H. Li, B. Blum, X. Xu, J. Y ang, G. A. Gibson,
and R. E. Bryant, “Parrot: a practical runtime for deterministic, stable,and reliable threads,” in Symposium on Operating Systems Principles
(SOSP). ACM, 2013.
[9] A. W . Mazurkiewicz, “Trace theory,” in Advances in Petri Nets, 1986.
[10] “The LL VM compiler infrastructure,” http://llvm.org.[11] H. Cui, J. Wu, J. Gallagher, H. Guo, and J. Y ang, “Efﬁcient deterministic
multithreading through schedule relaxation,” in Symposium on Operating
Systems Principles (SOSP). ACM, 2011.
[12] B. Wachter, D. Kroening, and J. Ouaknine, “V erifying multi-threaded
software with impact,” in F ormal Methods in Computer-Aided Design
(FMCAD). IEEE, 2013.
[13] M. Musuvathi and S. Qadeer, “Iterative context bounding for systematic
testing of multithreaded programs,” in Conference on Programming
Language Design and Implementation (PLDI). ACM, 2007.
[14] T. Bergan, O. Anderson, J. Devietti, L. Ceze, and D. Grossman,
“Coredet: a compiler and runtime system for deterministic multithreadedexecution,” in International Conference on Architectural Support for
Programming Languages and Operating Systems (ASPLOS). ACM,2010.
[15] A. Aviram, S. Weng, S. Hu, and B. Ford, “Efﬁcient system-enforced
deterministic parallelism,” in Symposium on Operating Systems Design
and Implementation (OSDI). USENIX Association, 2010.
[16] I. Rabinovitz and O. Grumberg, “Bounded model checking of concurrent
programs,” in International Conference Computer Aided V eriﬁcation
(CA V), ser. LNCS, vol. 3576. Springer, 2005.
[17] L. C. Cordeiro and B. Fischer, “V erifying multi-threaded software
using smt-based context-bounded model checking,” in International
Conference on Software Engineering (ICSE), 2011.
[18] S. Burckhardt and M. Musuvathi, “Effective program veriﬁcation for
relaxed memory models,” in International Conference Computer Aided
V eriﬁcation (CA V), ser. LNCS, vol. 5123. Springer, 2008.
[19] X. Fang, J. Lee, and S. P . Midkiff, “Automatic fence insertion for shared
memory multiprocessing,” in International Conference on Supercomput-
ing (ICS). ACM, 2003.
781
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:03 UTC from IEEE Xplore.  Restrictions apply. 