Verifying Simulink Stateï¬‚ow Model: Timed Automata
Approach
Yixiao Y ang1, Yu Jiang1;2, Ming Gu1, Jiaguang Sun1
School of Software, Tsinghua University, TNLIST, KLISS, Beijing, China1
Department of Computer Science, University of Illinois at Urbana-Champaign, USA2
ABSTRACT
Simulink Stateow is widely used for the model-driven devel-
opment of software. However, the increasing demand of rig-
orous verication for safety critical applications brings new
challenge to the Simulink Stateow because of the lack of
formal semantics. In this paper, we present STU, a self-
contained toolkit to bridge the Simulink Stateow and a
well-dened rigorous verication. The tool translates the
Simulink Stateow into the Uppaal timed automata for ver-
ication. Compared to existing work, more advanced and
complex modeling features in Stateow such as the event
stack, conditional action and timer are supported. Then,
with the strong verication power of Uppaal, we can not only
nd design defects that are missed by the Simulink Design
Verier, but also check more important temporal properties.
The evaluation on articial examples and real industrial ap-
plications demonstrates the eectiveness.
The abstract demo video address is :
https://youtu.be/TmsU1WRwSqo
The tool and code can be downloaded:
https://www.dropbox.com/sh/374gcfjfei4ywlt/AACF9xqijvY-8nteIhcShIy9a?dl=
0
CCS Concepts
Software and its engineering !Model-driven soft-
ware engineering;
Keywords
Simulink Stateow, Uppaal Timed Automaton, Verication
1. INTRODUCTION
Simulink Stateow is widely used for the model driven de-
sign of software systems, which provides well support for the
graphical Stateow model construction, interactive graphi-
cal model simulation, some basic design validation, and the
C, C++, and VHDL code generations [3]. It has been suc-cessfully applied to various industry and livelihood areas,
where Simulink Design Verier [10] are taking the responsi-
bility to uncover design defects of the Stateow model.
Motivation: However, for those safety-critical applications
such as medical devices and avionics, the model validation
technique used in Simulink Design Verier is still insucient
to ensure the correctness. Specically, the verication capa-
bility of Simulink Design Verier is limited to basic proper-
ties. It detects errors in the model that result in the integer
overow, array access violations, division by zero, and vio-
lation of requirement assertions described by Simulink veri-
cation block. Handling complex temporal properties (e.g.
something has to hold at the next state) of those applica-
tions is currently infeasible because of the limited descrip-
tive ability of Simulink verication block. More rigorous
formal techniques such as model checking should be applied
to check the correctness of the Stateow model.
Challenge: The major challenge for applying those formal
verication techniques to support a wider range of properties
is that the execution semantics of Stateow is too complex,
which is described in a 1366 pages user guide informally [12].
Advanced modeling feature such as event stack, event inter-
ruption, complex state activating and deactivating mecha-
nism, boundary transition, and transitional action etc., are
non-straightforward to formalize for verication. Although
there are some existing works on translation based veri-
cation of Stateow model, most are ecient and work well
covering the most related modeling features within their own
domains [4], and few address the temporal part and complex
event interrupt mechanism, which are hard to formalize but
really important in real model of applications.
Approach: We present STU, to automatically translate the
Simulink Stateow model into the Uppaal timed automata
[1, 13] for a more comprehensive formal analysis. Timed
automata is chosen because it can be used to model and
analyze the timing behavior of systems, and methods for
checking both safety and liveness properties of timed au-
tomata have been well developed and intensively studied in
Uppaal. The advanced Stateow modeling features ( Com-
posite State, Boundary Transition, Junction, Event, Condi-
tional Action, Transitional Action, Timer and implicit event
stack ) are addressed in the tool. With a wider coverage of
Stateow modeling features captured in STU, and the strong
verication capability of Uppaal, more comprehensive vali-
dation can be accomplished. Potential errors contained in
the Stateow that are missed in simulation or Simulink De-
sign Verier verication will be detected through Uppaal
verication.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proï¬t or commercial advantage and that copies bear this notice and the full citation
on the ï¬rst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciï¬c permission and/or a
fee. Request permissions from Permissions@acm.org.
ASEâ€™16 , September 3â€“7, 2016, Singapore, Singapore
c2016 ACM. 978-1-4503-3845-5/16/09...$15.00
http://dx.doi.org/10.1145/2970276.2970293
852
2. BACKGROUND
2.1 Simulink Stateï¬‚ow
The model in Fig. 1 is an example of a Simulink State-
ow diagram which covers most advanced modeling features.
The model realizes a counter task that, for every 2 seconds,
state Adispatches a `switch on' event, and for every `switch
on'event, state Bwill increase the variable xby 1. The
statementx=x+ 1 is a conditional action, so it will
be executed immediately when the event `switch on' is dis-
patched. On the other hand, the statement y=y+ 1
is a transitional action which can only be executed when a
valid path between two states is detected. So at the end of
execution, the value of yis only increased for one time to
1 and the value of xis 3. At the same time, the boolean
variable result is set to be true, because the activation of
state B2will trigger the activation of parent state Count
rst. During the activation of state Count , the entry action
result = true is executed.
[after(2,sec)]/{switch_on}Switch_on{x=x+1;}/{y=y+1;}
[x>=3][y>=3]
[result]Count
entry:result=trueContainer
entry:x=int32(0);y=int32(0);CLK=int32(0);result=false;during:CLK=CLK+1;
A
CA1 A2
C1 C2B
B1 B3
B2
Figure 1: A Stateow example for counter task
which covers most advanced modeling features.
More specically, Stateow model is an extended hierar-
chical state machine which contains sequential decision logic
and synchronization events to represent system behaviors.
There are mainly six frequently-used modeling elements:
State, Transition, Junction, event, Action and Timer.
State: It represents operating mode of the system. The
occurrence of an event will trigger the execution of State-
ow model by making states active or inactive depending
on conditions during simulation. The state can be dened
hierarchically, and may contain two types of decomposition
which are connected in parallel or serial. The serial decom-
posing state must have at least one default transition with
only one sub-state activated, while the parallel decomposing
state does not have any default transition with all sub-states
activated at one time. That is speaking, within a compos-
ite state (or a chart), no two exclusive serial sub-states can
be active at the same time, while any number of parallel
sub-states can be simultaneously activated.
Transition: It is the edge between two states or junctions,
representing the mode change from the source state to the
destination state. Each transition is attached with four char-
acterizations:
[event ] [condition ] [conditional action ]=[common action ]
Where event species explicit or implicit signal that trig-
gers execution of transition, condition is a boolean expres-
sion that allows the transition to be taken with value true,
theconditional action is the operation that is immediately
executed when the condition is met, and common action
is the operation that will be executed when the condition
is met and there is a non-interrupted valid path between
source state and target state. Each transition also has animplicit priority of execution, determined by the information
such as hierarchy level of destination state, and position of
transition source, etc.
Event: There are two types of event used to trigger execu-
tion of a Stateow diagram. An explicit event is dened by
users, and it can be an input from Simulink, an output to
Simulink, or local within a diagram. An implicit event is a
built-in event that broadcasts automatically during diagram
execution. Three commonly used implicit events are sys-
tem tick, enter(state name), and exit(state name): tick in-
dicates the moment when a Stateow diagram awakens, and
the other two occur when the specied state of state name
is entered or exited, respectively. Event broadcasting is a
common communication technique in Stateow.
Action: It contains two kinds of operation attached on tran-
sition ( conditional action and common action ), and three
kinds of operations attached on state ( entry action, during
action and exit action ).Entry action is executed when the
state is activated, During action is executed when the state
is already active and stays in, and Exit action is executed
when the state changes from active to inactive.
Junction: It contains two types, connective junction and
history junction , where the former enables the representa-
tion of dierent possible transition paths for a single transi-
tion, and the later represents historical decision points based
on historical data relative to state activity.
Timer: It is used to specify time related behaviors of sys-
tem, which is characterized as:
[TmOp (Num; Event )]
where TmOp contains three types of time related operation
before, after , and at,Num is the number used to quantify
the length of time period, and Event consists of three system
reserved keywords: sec, msec , and usec which represents
second, millisecond, and microseconds, respectively.
2.2 Uppaal Timed Automata
The model in Fig. 2 is an example of a network of timed
automata which covers most advanced modelling features.
The model consists of three parallel automata A, B and C.
A channel switch onis declared for synchronisation among
dierent automata, and a clock variable tis declared in
timed automaton Afor time modelling. Every two time
units, the action switch on!is synchronized with the action
switch on?, and the variable x will increase by 1 in automa-
tonB. If the value of x and y is smaller than 3, automaton B
will return to state B1immediately for next synchronization
from automaton A. After six time units, the transition from
stateB4toB2in automaton Bwould be triggered, and the
value of variable result should be set to be true, which would
immediately trigger the transition from C1toC2contained
in automaton C. Note that the state with the double cycle
is the initial state.
Formally, a timed automaton is a nite state machine ex-
tended with clock variables. It uses a dense-time model
/switch_on?/x:=x+1
y>=3/Â /y:=y+1A
A1 A2B
B1 B3
B2t>=2/Â switch_on!/t:=0
t<=2
x>=3/Â /y:=y+1,Â result:=true Â x<3,y<3/Â /result==true Â /Â Â /C
C1 C2B4Timed automata
Figure 2: Constructed timed automata for counter.
853where clock variables evaluate to real numbers, and all clocks
progress synchronously. It can be dened as a tuple consists
of six elements: ( L;l0;C;A;I;E ), where L is a set of lo-
cations,l0is the initial location, Cis a set of clocks, Ais
a set of actions, B(C) is a set of conjunctions over simple
conditions of the form x ./ c orx y ./ c (x;y2C, and
./2f<;;=;;>g),Iis a set of invariants on the location,
andELAB(C)2CLdenotes a set of transition
edges. The edge connects two locations with an action, a
guard and a set of clocks, formalized as ( l   !g;a;r l0) when
(l;a;g;r;l0)2E. The transition represented by an edge can
be triggered when the clock value satises the guard labeled
on the edge. The clocks may reset when a transition is taken.
A system can be modeled as a network of timed automata
in parallel with synchronous actions dened on channel ch.
The input action ch? represents receiving an event from the
channelch, while the output action ch! stands for sending an
event on the channel ch. Automata in the network execute
concurrently. They can communicate via shared variables,
as well as via events over those synchronous channels. In
the general case, an edge from location l1to location l2can
be described in a form ( l1   !g;;r l0), if there is no syn-
chronization over channels ( denotes an \empty" action),
or (l1     !g;ch;r l0). Here,chdenotes a synchronization
label over channel chwith2f !;?g, g represents a guard
for the edge and r denotes the reset operations performed
when the transition occurs.
3. MODEL TRANSFORMATION
The key challenges ot the semantics gap between Simulink
Stateow and Uppaal timed automata are :
(1) Simulink Stateow transition is driven by event, and
the execution order of every step of event is in deter-
ministic sequential manner, interruptible and recursive
with stack. While the Uppaal timed automata is exe-
cuted in parallel, and driven by the channel synchro-
nization without the support of stack.
(2) Simulink Stateow supports hierarchy structure which
is combined with recursive activation-deactivation mech-
anism, the transitional and conditional actions very
closely. While the Uppaal timed automata supports
single state and non-interrupt transition and action.
Since the semantics of timed automata is simpler than that
of Stateow, we need to deal with the priority, event stack,
transitional action, etc. with some simple constructs in Up-
paal timed automata, which is highly challenging than the
reverse translation from timed automata to Stateow [9].
To simulate the complex model and execution semantics of
Simulink Stateow, an array based data structure for event
and an entirely new cooperative mechanism are designed
and introduced.
3.1 Dynamic Event Stack Construction
In Stateow, the event dispatching and processing mecha-
nism is interruptible. However, in timed automata, there is
only synchronous channel among parallel automata and no
stack at all. The key idea to simulate Stateow event stack
mechanism is to build a virtual stack in Uppaal. We use a
structured array in Uppaal to build the event virtual stack.
The element of the array is a data structure dened in the
listing 1 below, which records all information related to an
event in Stateow. Each element in the structure node is
described as:Listing 1: The Denition of the Event Structure
Structure Event f
int Event ;
int Dest ;
int DestCrossPosition ;
int AutomatonType ;
bool Valid ;
g
1.Event is the variable used to label and distinguish dif-
ferent events in Stateow. We assign a unique integer
number to this variable for each Stateow event.
2.Dest is the variable used to map a Stateow event
to a corresponding Uppaal controller automata orig-
inated from a Stateow state with decomposition or
attached actions. This kind of state will be trans-
lated into four cooperative automata (controller, ac-
tion, condition and common automata) .
3.DestCrossPosition is the variable used to imply the
corresponding Uppaal controller automata state orig-
inated from Stateow cross-boundary transition.
4.AutomatonType is the variable used to map the event
to the four types of corresponding Uppaal automata.
5.Valid is the variable used to denote whether this event
is valid or not at present. If the event is on the top
of the stack and is invalid, the event will be deleted
by the extra daemon automata , which is responsible
for deleting invalid event on the top of the stack, and
dispatching the System Event when the stack is empty.
The virtual stack is the basic element to simulate Simulink
Stateow semantics. It is initialized as empty in the trans-
lated Uppaal timed automata, and is dynamically pushed
and popped during runtime simulation. When Simulink
Stateow generates an event within a transition or a state
operation, the translated Uppaal timed automata will take
a corresponding transition with an attached action to dis-
patch and push an Event element into the stack dynami-
cally. Each transition starting from an active state of con-
troller automata will check whether the Dest of the top ele-
ment of event stack equals to the label of automata or not.
If yes, the transition will be triggered, and the Event el-
ement will also be popped corresponding to the end of a
simulation cycle of Simulink Stateow. The procedures are
mainly accomplished through ve encoded functions Dis-
patchEvent(), PushEvent(), PopEvent(), EventSentToMe(),
and StackTopEvent() of timed automata.
3.2 State Transformation
For a regular simple state without decomposition or at-
tached actions, the transformation is straightforward. We
just directly map simple Stateow state sfto Uppaal timed
automata state su. But for those complex Stateow state
with decomposition or attached actions, we need to translate
it to four cooperative parallel automata:
1.Controller automata is used to simulate the event pro-
cessing mechanism within this complex Stateow state.
It controls how to dispatch the hierarchical active and
deactive related event by initializing, popping, and
pushing elements of the virtual stack.
8542.Action automata is responsible for handling the three
kinds of attached actions ( entry, during, exit ). For
the composite state without attached actions, this au-
tomata will not be generated.
3.Condition automata is used to execute the conditional
action, handle the junction, test the guard and priority
on each transition contained in this composite state,
and store the boolean results.
4.Common automata is used to execute the transitional
action, and read the guard related array initialized by
condition automata to execute the satised transition
contained in this composite state.
Controller automata: For the activation of state sfin
Stateow, it should estimate whether its upper-level state
slfis activated or not. If not, slfshould be activated rst,
this is especially true for cross-boundary transitions. In or-
der to simulate this semantics, the corresponding controller
automata should push an activation event corresponding to
statesfitself onto the stack rst, and recursively pushe the
activation event associated with the automata originated
fromslfonto the stack, until the top composite state ar-
rives. The deactivation of Stateow state, is a reversal of ac-
tivation procedure. In controller automata , these two tasks
are translated to two self-cycle transitions attached with ac-
tions StateActivationLogic() andStateDeactivationLogic() of
timed automata.
Action automata: For detail execution of entry, during ,
and exitaction attached on Stateow state, it will be cap-
tured by the translated action automata with three self-cycle
transitions. After the execution of controller automata on
the logic of state active or deactivate, action automata will
continually read the stack top event for the test of the guard.
The guard on the three transitions are StackTop().Event ==
ActivationEvent, StackTop().Event == DuringEvent and
StackTop().Event == DeactivationEvent. Then, the transi-
tion with satised guard will take, and corresponding action
statements in Stateow are translated to action statements
attached on the three transitions.
An example for the translated controller automata andac-
tion automata for a composite state Ais presented in Figure
3. For condition automata and common automata , they are
mainly used for Stateow transitions contained in composite
state, and will be described in the following paragraph.
3.3 Transition Transformation
Within Stateow, each transition is attached with four
characterizations: event, condition, conditional action , and
Condition
Automaton Â 
forÂ A
Common
Automaton Â 
forÂ A
Controller Â 
AutomatonforÂ A
Action
Automaton Â 
forÂ A
Figure 3: The controller and action automata for
a composite state transformation, capturing activa-
tion and deactivation.transitional action . We incorporate them into the condition
and common automata of the high-level composite state that
contains this transition as below.
1.event is transformed into a unique integer as described
in the event stack transformation.
2.condition is transformed into the guard of transition
in the corresponding condition automata .
3.conditional action is transformed into the action of
transition in the corresponding condition automata .
4.transitional action is transformed into the action of
transition in the corresponding common automata .
When there are multiple transitions starting from a State-
ow state, we should maintain the determinism execution se-
quence of Stateow in timed automata. First, we initialize
an int array PathSelect[ ] to store the priority of transition,
where the array index represents the depth of source state
or junction node of transition. As presented in Figure 4,
the depth of state or junction is dened as the minimum
transition number to a pre-state. Besides, a boolean array
PathGuard[ ] is initialized to store the condition test result
of every transition, where the array index is the idof State-
ow transition.
Condition
Automaton Â 
Common
Automaton Â 
Figure 4: The common and condition automata for
a composite state transformation, capturing internal
transition.
Condition automata: For a Stateow transition tf
1:sf
1!
sf
2with conditional action af
cand conditiongf, we build
condition automata as below. An intermediate state su
iis
added between the corresponding timed automata state su
1
andsu
2. Based on which, three automata transitions are
dened,tu
1:su
1!su
i,tu
2:su
i!su
2andtu
3:su
i!su
1.
The guard on transition tu
1isPathSelect [i] ==Priority ,
which ensures that the transition is executed by its prior-
ity order. The guard on transition tu
2is the conditiongf
from Stateow transition tf
1. The action on transition tu
2
is from conditional action af
cof the Stateow transition tf
1,
and an additional assignment of the boolean array element
PathJudge[i] with value true. In this way, conditional ac-
tion can be executed immediately whether there is a legal
transition path between two Stateow states or not. Tran-
sitiontu
3is used to roll back to the source state for further
test of transitions with lower property, and PathGuard[i] is
set as false to show that this transition could not be taken
incommon automata . Also, ifsf
2is a Stateow junction
node, a transition is added tu
4:su
2!su
1for roll back of non-
complete path. This roll back transition is controlled by the
guard pathSelect[i] == n , where i is the depth of the junc-
tion node, n is the number of outgoing transitions from the
855junction, and each negative test of the guard on outgoing
transition will increase the value of pathSelect[i] by 1. The
timer of Stateow is also captured in condition automata .
Time operation is based on event and is usually used as a
time related condition on transition.
Common automata: For a Stateow transition tf
1:sf
1!
sf
2, we build common automata to capture its transitional
actionaf
t, based on the array PathGuard[ ] initialized in con-
dition automata . Stateow transition tf
1is directly mapped
to an automata transition tu
1:su
1!su
2. The guard and ac-
tion on automata transition tu
1are from the expression Path-
Guard[ ] == true andtransitional action af
trespectively. It
is almost the same as the graphical structure of Stateow
model, with abbreviated guard and transitional action. An
example for the translated common automata andcondition
automata of the composite state Ais presented in Figure 4.
3.4 Tool Implementation
Based on above transition rules, we implement a tool for
automatically translation from Stateow to Uppaal timed
automata. The tool STU consists of a parser, transla-
tor, and storer, and is implemented in 14590 lines of java
code with two supporting libraries (JDOM used for read
and write XML le, and Antlr used for abstract syntax tree
construction and update), as presented in Figure 5. The
parser extracts Stateow model from Simulink project le
into memory. The translator transfers Stateow model and
reconstructs the abstract syntax tree in memory according
to transition rules. The storer outputs the updated abstract
syntax tree to Uppaal model le. The three parts are seam-
lessly integrated in STU to support the formal analysis of
Stateow model based on Uppaal, and can be downloaded
in the website presented in abstract.
Simulink
FileJDom
Stateflow
ModelTransferÂ 
LogicUppaal
File
Uppaal
ModelPaser
TranslatorStorer
JDom
Antrl Antrl AST
Figure 5: Translation tool design and integration.
4. TOOL EV ALUATION
In order to evaluate the tool, we apply it to some arti-
cial and real industrial Stateow models. The presented
Steteow models, translated timed automata, and proper-
ties specications could be downloaded in web-site presented
in footnote 1. Some implicit bugs in Stateow model that
can not be detected in Design Verier are detected in Uppaal
verication based on the translated timed automata.
The rst articial example is the switch on counter exam-
ple designed to count how many times the event switch on
happens. As presented in Figure 6, when the Stateow
model enters the composite state B, there is a potential error
of division by 0 contained in the transitional action z=x=y.
So, we may verify the property non-division by zero in De-
sign Verier, and the model passes the verication. But
according to manual analysis, the value of ywould be zeroafter 6 seconds. Design Verier failed to detect this implicit
but general bug contained in the model.
PotentialÂ divisionÂ byÂ zero
Figure 6: Manual model for validation testing
Then, we translate the Stateow model to timed automata
through the developed tool STU. The translation is accom-
plished within 0.01 seconds. In the translated timed au-
tomata, the integer variable yin Stateow is mapped to an
integer variable Chart y, and the junction node in Stateow
is mapped to a state with the name Process Chart Con-
tainer B.SSID49 . Then, property about error of division by
0 within this model can be described as in Table 1.
Table 1: Property List
Formula Time
E<>Process Chart Container B.SSID49
and Chart y == 0 and Chart x == 30.43s
Where \E <> " is a temporal keyword which means even-
tually,\Process Chart Container B.SSID49"is automata state
name corresponding to the Stateow junction node,\Chart x
== 3" is automata value test corresponding to the guard
\x==3" of Stateow transition from junction node to state
B2, and \Chart y == 0" is also automata value test corre-
sponding to the Stateow action z=x=yattached on the
transition from junction node to state B2. The property
consists of a serial combination of previous predicates, and
means that ymay be set to be 0 when the transition is
enabled, which will cause the error of division by 0. Veri-
cation result shows that the property is satised and the
error can be triggered within 0.43 second.
Then, we apply STU to a real industrial Stateow model
of the train communication control system and do some ver-
ication. The system consists of many multifunction vehicle
bus (MVB) controllers which interconnect devices within a
vehicle, and the rotated MVB master controller broadcasts a
master frame[6, 7, 15]. Given master rotation as an example,
the master transfer logic described in page 260 and Figure
105 of IEC 61375 are modeled as Stateow model. After
preliminary Stateow validation on two MVB controller in-
stances, we translate the main logic and some accompanied
Stateow models into 151 corresponding parallel timed au-
tomata within 0.1 seconds and verify the property described
in table 2 within 3 seconds. This property is derived from
real potential hazards of system failure. For example, in the
MVB master and slave rotation process, there may be in-
consistence such that two masters appear at the same time.
The property is violated during verication, which means
that there exists a path that two MVB controllers may si-
multaneously reach \Regular Master" state, or simultane-
ously reach \Standby Master" state. The rst situation will
lead to master collision and the second will lead to no master
856Table 2: Property List
Formula Time
A[ ] Process Chart OneMVB1(2) LOGIC
.Chart OneMVB1 LOGIC Rrgular Master
and
Process Chart OneMVB2(1) LOGIC
.Chart OneMVB2 LOGIC Standby Master2.349s
throughout train communication network. Through manual
analysis of counter examples demonstrated in Uppaal, we
trace back to the design defects of Stateow model, which
can be further traced back to the bugs in the standard.
Currently, any models that consist of the advanced model-
ing features mentioned in the introduction can be translated
by our tool. Because execution semantics of Stateow is de-
scribed in informal natural languages based on examples, it
is not possible to formally prove the equivalence and cor-
rectness of the transformation. We acquire correctness by
carefully compare simulation results of the translated model,
including the value and state sequence step by step, in the
same way as previous works.
5. RELATED WORK
Because Stateow has no formal semantics for rigours for-
mal verication, plenty of attempts have touched the topic
to assist Simulink Design Verier in acquiring correctness
of Stateow model, which can be classied into two cate-
gories, simulation-based techniques and verication-based
techniques. Many researchers have developed simulation
based tools for Simulink designs including Beacon Tester
[11], and AutoMOTgen [5] etc. For verication based tech-
niques, the main challenge is that Simulink Stateow lacks
a formal and rigorous denition of its semantics. Many re-
searchers have dened several types of formal semantics for
Stateow, and developed many specialized tools for trans-
lating subsets of model to pushdown automata [2], SMV [8],
PAT [4], Hybrid automata, hoare logic and SAL [14], which
can be veried through the corresponding supporting tools.
Most of them performs well within their own domain while
abstracting some domain unrelated modeling features. For
example, in SMV based translation, they focus and provide
a well-dened framework to ensure the function correctness,
while the hierarchical states and events are out of their con-
siderations.
6. CONCLUSION
In this paper, we present a tool for the translation of State-
ow model to timed automata, which covers many advanced
features such as conditional action, activation of composite
state, and timer etc. The translated timed automata model
can be input to Uppaal for simulation and verication di-
rectly. Then, many safety and liveness properties of the
original Stateow model can be veried by the Uppaal to
acquire higher reliability. The ongoing work mainly focus
on strengthening the useability of STU in the following two
aspects: (1) the conversion of randomized function in State-
ow is not supported yet. (2) the layout of the translated
Uppaal timed automata needs to be improved. (3) the au-
tomatic trace back tool should be developed.
7. ACKNOWLEDGMENTThis research is sponsored in part by NSFC Program (No.
91218302, No. 61527812), National Science and Technology
Major Project (No. 2016ZX01038101), Tsinghua University
Initiative Scientic Research Program (20131089331), MIIT
IT funds (Research and application of TCN key technologies
) of China, and the National Key Technology R&D Program
(No. 2015BAG14B01-02), Austrian Science Fund (FWF)
under grants S11402-N23 (RiSE/SHiNE) and Z211-N23.
8. REFERENCES
[1] R. Alur. Timed automata. In Computer Aided
Verication , pages 8{22. Springer, 1999.
[2] A. Bouajjani, J. Esparza, and O. Maler. Reachability
analysis of pushdown automata: Application to
model-checking. In CONCUR'97: Concurrency
Theory , pages 135{150. Springer, 1997.
[3] P. Caspi and etc. From simulink to scade/lustre to tta:
a layered approach for distributed embedded
applications. In ACM Sigplan Notices , volume 38,
pages 153{162. ACM, 2003.
[4] C. Chen, J. Sun, Y. Liu, J. S. Dong, and M. Zheng.
Formal modeling and validation of stateow diagrams.
International Journal on Software Tools for
Technology Transfer , 14(6):653{671, 2012.
[5] A. A. Gadkari, A. Yeolekar, J. Suresh, S. Ramesh,
S. Mohalik, and K. Shashidhar. Automotgen:
Automatic model oriented test generator for
embedded control systems. In Computer Aided
Verication , pages 204{208. Springer, 2008.
[6] Y. Jiang and Y. Yang. From stateow simulation to
veried implementation: A verication approach and a
real-time train controller design. In 2016 IEEE
Real-Time and Embedded Technology and Applications
Symposium (RTAS) . IEEE, 2016.
[7] Y. Jiang and H. Zhang. Design and optimization of
multi-clocked embedded systems using formal
techniques. IEEE Transactions on Industrial
Electronics , 62(2):1270{1278, 2015.
[8] K. L. McMillan. The smv system. In Symbolic Model
Checking , pages 61{85. Springer, 1993.
[9] M. Pajic, Z. Jiang, I. Lee, O. Sokolsky, and
R. Mangharam. Safety-critical medical device
development using the upp2sf model translation tool.
ACM Transactions on Embedded Computing Systems
(TECS) , 13(4s):127, 2014.
[10] SimulinkDesignVerier. http://www.mathworks.com.
[11] B. Tester. Applied dynamics international.
[12] I. The MathWorks. Stateow user guide.
[13] R. Wang and M. Gu. Formal modeling and synthesis
of programmable logic controllers. Computers in
Industry , 62(1):23{31, 2011.
[14] H. Wernli, M. Paulat, M. Hagen, and C. Frei. Sal-a
novel quality measure for the verication of
quantitative precipitation forecasts. Monthly Weather
Review , 136(11):4470{4487, 2008.
[15] H. Zhang and H. Zhang. Design of mixed
synchronous/asynchronous systems with multiple
clocks. IEEE Transactions on Parallel and Distributed
Systems , 26(8):2220{2232.
857