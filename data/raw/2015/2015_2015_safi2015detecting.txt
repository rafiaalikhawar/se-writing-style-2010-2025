Detecting Event Anomalies in Event-Based Systems
Gholamreza Saﬁ Arman Shahbazian William G.J. Halfond Nenad Medvidovic
Computer Science Department
University of Southern California
Los Angeles, CA, USA
{gsaﬁ,armansha,halfond,neno}@usc.edu
ABSTRACT
Event-based interaction is an attractive paradigm because its use
can lead to highly ﬂexible and adaptable systems. One problem
in this paradigm is that events are sent, received, and processed
nondeterministically, due to the systems’ reliance on implicit in-
vocation and implicit concurrency. This nondeterminism can lead
to event anomalies, which occur when an event-based system re-
ceives multiple events that lead to the write of a shared ﬁeld or
memory location. Event anomalies can lead to unreliable, error-
prone, and hard to debug behavior in an event-based system. To de-
tect these anomalies, this paper presents a new static analysis tech-
nique, DEvA , for automatically detecting eventanomalies. DEvA
has been evaluated on a set of open-source event-based systems
against a state-of-the-art technique for detecting data races in multi-
threaded systems, and a recent technique for solving a similar prob-
lem with event processing in Android applications. DEvA exhibited
high precision with respect to manually constructed ground truths,
and was able to locate event anomalies that had not been detected
by the existing solutions.
Categories and Subject Descriptors
D.2.7 [ Software Engineering ]: Distribution, Maintenance, and
Enhancement; D.2.5 [ Testing and Debugging ]: Diagnostics
General Terms
Design, Experimentation
Keywords
Event-based system, Android application, Event anomaly, Race de-
tection
1. INTRODUCTION
The event-based paradigm allows developers to design and build
systems that are highly ﬂexible and can be easily adapted [24, 53,
28, 21]. These advantages have made event-based systems (EBSs)
popular in a range of domains [16, 17]. However, the event-based
paradigm can also introduce complications due to the nature of the
underlying event processing. Events can be delayed, damaged, orlost because of environment problems, such as network errors or
hardware deﬁciencies. More generally, events can be consumed
nondeterministically, independent of their order of occurrence [31].
While directly enabling EBS ﬂexibility, this nondeterminism can
also lead to unpredictable system behavior.
In this paper we address one speciﬁc type of problem related to
event handling, event anomaly (EA) . An EBS has an EA when the
processing of two or more events results in accesses to the same
memory location (e.g., a variable containing state or data) and at
least one of those is a write access. The impact of an EA can
vary based on the role the affected variable plays in the EBS, but
could include undesirable behaviors ranging from inconsistent state
to data corruption. Detecting EAs is hard for several reasons:
Nondeterminism: When a tester suspects that an EBS contains an
EA, nondeterminism can make it difﬁcult to execute or repro-
duce the EA. This reduces the efﬁciency and effectiveness of
standard test-based detection techniques and popular spectrum-
based fault localization techniques.
Implicit Invocation: EBSs rely on callbacks, which are methods
registered with an event-notiﬁcation facility and called when the
notiﬁer receives an appropriate event. The resulting implicit
invocation makes it difﬁcult to identify the control-ﬂow of the
code when an event is received and processed.
Ambiguous Interfaces: Event callback methods often accept a ge-
neric Event type. They must examine the event’s attributes to
determine its actual type [26] and to dispatch the event appropri-
ately [32]. Ambiguous interfaces make it difﬁcult to determine
the event type that is responsible for an EA.
Implicit Concurrency: Different types of received events may re-
sult in different method invocations in an EBS, thereby introduc-
ing different execution paths. Each of these paths is independent
of the others and may be executed in any order, depending on
when the events are consumed [19]. The resulting implicit con-
currency makes it difﬁcult to identify when a variable may be
accessed by two different execution paths.
Implicit invocation, implicit concurrency, and ambiguous inter-
faces are useful mechanisms for EBSs. Together they allow EBSs
to be loosely coupled and to scale easily. At the same time, these
very mechanisms make it harder to determine execution order and
memory-access patterns in an EBS, whose interplay results in EAs.
As a consequence, it can be very challenging for developers to de-
tect EAs in EBSs.
Researchers have recognized the need for automatically discov-
ering EAs. For instance, CAFA [29] identiﬁes Use-After-Free (UF) ,
a common type of EA in Android applications, while W EBRA-
CER [47] and E VENT RACER [50] focus on detecting certain types
of EAs in client-side web applications. However, these techniques
are based on dynamic analysis; therefore, they offer no guarantees
This is the author’s version of the work. It is posted here for your personal use. Not for
redistribution. The deﬁnitive version was published in the following publication:
ESEC/FSE’15 , August 30 – September 4, 2015, Bergamo, Italy
c2015 ACM. 978-1-4503-3675-8/15/08...
http://dx.doi.org/10.1145/2786805.2786836
25of completeness and can only identify EAs that have been exposed
during an execution. Other approaches try to address the problem
of EAs by introducing new programming language constructs [34,
22]. However, these approaches are not applicable to existing sys-
tems that are written in general-purpose languages, such as Java.
Furthermore, they tend to consider callback handlers with explicitly
typed events as the potential source of anomalies, when for many
EBSs the cause of EAs is the processing of generically typed events
inside the handlers, followed by dispatching to different component
methods.
To address these limitations of existing techniques, we have de-
veloped a new static analysis technique that speciﬁcally targets
EBSs and can handle the semantics of implicit invocation, am-
biguous interfaces, and implicit concurrency. Our approach, called
DEvA (forDetecting EventAnomalies), builds on our recent work
on static analysis to identify ambiguous interfaces in EBSs [26] and
adds further analyses to identify variables that may be modiﬁed as
a result of receiving an event—a potential EA. We evaluated DEvA
on 20 open-source event-based applications and libraries from dif-
ferent domains. We compared DEvA ’s performance to two state-
of-the-art techniques, one targeting traditional data races in multi-
threaded systems and the other targeting UFanomalies in Android.
Our evaluation results show that DEvA has high precision and was
able to ﬁnd EAs that the other techniques were unable to detect.
DEvA was also fast, averaging one minute per application analy-
sis, which is signiﬁcantly faster than the previously proposed tech-
niques.
The remainder of the paper is organized as follows. Section 2
discusses a motivating example. Section 3 deﬁnes fundamental
concepts underlying EBSs and provides a formal deﬁnition of EAs.
Sections 4 and 5 detail DEvA and its evaluation. Section 6 sum-
marizes the related work. Section 7 concludes the paper. Finally,
Section 8 includes information about DEvA ’s implementation and
the replication package we have made available.
2. MOTIV ATING EXAMPLE
As a simple example, consider MyTracks , an Android applica-
tion developed by Google. MyTracks records the location, path,
distance, and elevation of a Google Maps user. Figure 1 shows a
portion of this application, speciﬁcally, the handlers for two events:
onLocationChangedAsync (line 5) processes LocationChanged-
Async events and onDestroy (line 12) processes Destroy events.
Destroy is a common event used for memory management that,
when it occurs, frees the memory assigned to an activity or service
of a given Android application.1
In the case of MyTracks , the EA occurs when both Destroy and
LocationChangedAsync events occur but Destroy is processed
ﬁrst. The onDestroy handler will free memory by setting the private
class variable providerUtils to null. At some point shortly there-
after, onLocationChangedAsync will attempt to access provider-
Utils , thus generating a null pointer exception. The cause of this
exception is an EA, since each of the two events results in an ac-
cess to the same memory location and one of them is a write access.
The example in Figure 1 is an instance of an EA known as Use-
After-Free (UF). Our approach, DEvA , was able to detect this EA,
but existing techniques, such as CAFA [29], were unable to do so
(see Section 5.) These types of EAs also occur in other real-world
systems, such as Firefox for Android [12, 11].
1Note that invoking onDestroy is not equivalent to performing garbage collection in
Android. onDestroy only provides an opportunity to clean things up before an activity
or service is destroyed: it can change the memory locations referenced by the activity
or service instance or free them by setting them to null, but it does not release the
instance.1public class TrackRecordingService
2 extends Service
3 implements LocationListener {
4...
5 private void onLocationChangedAsync(
6 Location location){
7 ...
8 Location lastRecordedLocation =
9 providerUtils.getLastLocation();
10 ...
11 }
12 public void onDestroy() {
13 Log.d(TAG,
14 "TrackRecordingService.onDestroy");
15 ...
16 providerUtils = null ;
17 ...
18 }
19 ...
20 }
Figure 1: Excerpt from the MyTracks Android application
3. FOUNDATIONS
In this section we deﬁne the underlying concepts and terminol-
ogy that we will use to describe DEvA in Section 4. We describe
how events are deﬁned in an EBS, and how we employ our re-
cent static analysis technique [26] to automatically identify differ-
ent event types in systems with ambiguous interfaces. Finally, we
provide a formal deﬁnition of event-based anomalies.
To illustrate our deﬁnitions, we will use the implementation of a
LoadBalancer component shown in Figure 2. LoadBalancer mon-
itors the state of a server. Whenever the load on the server rises
above a speciﬁed limit, it will stop responding to new requests. A
new request comes to LoadBalancer through a NewRequest event.
At lines 6 and 7 of Figure 2, LoadBalancer consumes this event
and decides whether to process it on the server or send a notiﬁ-
cation event to inform other parts of the system that the server is
overloaded. The limit for the load on the server is set whenever
LoadBalancer receives a SetLimit event. At lines 9-13, LoadBal-
ancer consumes this event, sets the limit, and checks if the new
limit is less than the previous one. If so, it informs other parts of
the system about the limit reduction.
3.1 Terminology
Our approach relies on control-ﬂow information in the form of a
control-ﬂow graph (CFG). A CFG is a directed graph in which each
node represents a basic block of code and each edge represents the
relationship between two blocks that at runtime may be executed
after one another. We also use the inter-procedural control-ﬂow
graph (ICFG), which is a directed graph that contains the CFGs of
a component’s different methods. If one method calls another, then
there is an edge in the ICFG between the method invocation point
and the entry node of the target method’s CFG.
The ICFG of LoadBalancer is shown in Figure 3. The nodes in
the ICFG correspond to the statements in Figure 2. We use this
graph to illustrate two more concepts. First, a CFG node Xiscon-
trol dependent on node Yif execution of Ydetermines whether X
will be executed. Consider the CFG of the handle method in the
LoadBalancer component, which is shown in Figure 3 starting at
node Entry in the top middle of the graph. Nodes 7 and 8 are con-
trol dependent on 6 being true but node 9 is not, since 9 will execute
for either condition of node 6. Second, a node Xisdata dependent
on node Yif there is a path in the CFG from YtoX,Xuses the
value of a variable that has been deﬁned at Y, and no other node
on that path redeﬁnes that variable [27]. In the LoadBalancer ex-
261public class LoadBalancer extends Component{
2 Long curLoad;
3 Long lmt;
4 Long preLmt;
5 public void handle(Event e){
6 if(e.getName().equals("NewRequest")){
7 manageCurrentLoad(e.getRequest());
8 }
9 if(e.getName().equals("SetLimit")){
10 preLmt = lmt;
11 lmt = Long.parseLong(e.getAttr("Limit"));
12 if(lmt < preLmt)
13 send( new Event("LimitReduced"));
14 }
15 }
16 public void manageCurrentLoad(Request r){
17 if(curLoad < lmt){
18 curLoad = curLoad + 1;
19 //Start processing new request
20 }
21 else
22 send( new Event("LoadTooHigh"));
23 }
24 }
Figure 2: Event-based load-balancing component
ample, node 12 is data dependent on node 11, since at line 12 in
Figure 2 the ifstatement uses the lmtvariable and lmtis deﬁned at
node 11.
To show all control- and data-dependency relationships between
different nodes of an ICFG, we can use the Program Dependence
Graph (PDG). In a PDG, the nodes represent basic blocks in the
program and edges represent control or data dependencies between
the nodes. Figure 4 shows the PDG for the example from Figure 2.
3.2 Consumed Events
Event-based systems (EBSs), also referred to as message-based
systems, are widely used in a range of application domains, from
user interface software to distributed systems. In an EBS, the pro-
cess of a component receiving an event and accessing the informa-
tion deﬁned in the event’s attributes is called event consumption .
At lines 9-11 of Figure 2, the event SetLimit is consumed, since
LoadBalancer receives the event and processes the event’s contents
by checking its “ Name ” and “ Limit ” attributes. An EBS compo-
nent’s entry point for event consumption is called a sink, or alter-
natively an event handler . In Figure 2, the handle method deﬁned
at line 5 is a sink. We say that LoadBalancer has an ambiguous
interface [26] since it receives all events via the same sink.
Identifying the types of events consumed by an EBS in the pres-
ence of ambiguous interfaces is challenging because all events han-
dled by a system arrive as a single, generic Event type. The actual
type of each event is determined at runtime by checking the at-
tributes contained within the event. Our recent work [26] resulted
in a static analysis technique, called Eos, that analyzes the imple-
mentation of an EBS to infer the set of event types it can consume
at runtime.
Eos leverages consumed event revealing (CER ) statements to in-
fer information about the consumed event types (CETs) of a compo-
nent. A CER statement is a method call that retrieves information
stored in an event without modifying the event’s attributes. A CET
is deﬁned by a set of attributes and their values, which can be in-
ferred from CER statements. Methods called by a CER statement
are of the following forms:
1.getAttr (a)represents methods retrieving the value of the at-
tribute named aof an event. As an example, consider getAttr
in Figure 2 at line 11.
Entry
6
8T
9F
ExitF10
11
12T
Thandle(Event e)
Entry
17
18 21
22T F
19
20
1413FmanageCurrentLoad(Request r)
7. Call 7. Call
7. return 7. return
ExitFigure 3: ICFG of LoadBalancer
2.retrieveSpeciﬁcEventInfo ()represents methods whose names
indicate the information the methods directly obtain about an
event; this is in contrast to getAttr (a), which relies on param-
eterato specify the information of interest. For example, in
Figure 2 at line 6 e:getName ()is used to retrieve the name
parameter of event e, while at line 7 e:getRequest ()is used
to retrieve the request parameter contained in e.
3.hasAttribute (a)represents methods that check whether an
event has a speciﬁc attribute with the name a.
4.m(e)indicates methods that accept an event eas an argument.
The explicitly declared type of the argument, required by the
programming language, reveals information about the type
of the event e, which may have been cast elsewhere in the
system before m()was invoked.
Eos identiﬁes CER statements in a component and aggregates
their information along the paths in the CFGs of the component’s
methods. The type information revealed by the CER statements
along each path is used to deﬁne a CET of the component. We
refer to the set of all event types that are consumed in a component
as its CET set. Eos also returns all of the nodes in the ICFG that
contain a CER statement that contributed to the deﬁnition of each
CET.
To illustrate, consider the LoadBalancer component from Fig-
ure 2. Its CET set consists of two event types. The ﬁrst event
type has two attributes, one with the name “ Name ” (whose value is
NewRequest ) and one with the name “Request”. The second event
type also has two attributes, “ Name ” (with the value SetLimit ) and
“Limit” .
3.3 Deﬁnition of Event Anomalies
An event consumption may cause an access to the state of a com-
ponent, which is represented by the component’s ﬁelds as well as
any shared, non-local variables. For example, in the LoadBalancer
component, variables curLoad ,lmtandpreLmt are its ﬁelds. An ac-
cess to a ﬁeld is either a read (i.e., use) or a write (i.e., deﬁnition).
When the consumption of two different CETs causes accesses to
the same ﬁeld, with at least one access being a write, a problem
27Entry
6
89
T10 12 11T
Entry
17
21 18 19 22TThandle(Event e)
manageCurrentLoad(Request r)
20T F1314
T7.call 7.call
7.return 7.returnTpreLmt
lmt
ExitExitFigure 4: PDG of LoadBalancer
may occur: the consumption order of the two events may be de-
pendent on the system’s environment and, therefore, the system’s
behavior may be nondeterministic. We refer to this potential prob-
lem as an event anomaly (EA) . The goal of our technique, DEvA , is
to identify and report such anomalies to developers.
LetComponents be the set of all components in a system. For a
given c2Components , we deﬁne Fcas the set of all of c’s ﬁelds.
Furthermore, cerExtract (e)is Eos’s function that extracts all CER
statements for an event e. There exists an EA in component cover
the ﬁeld f2Fcdue to event types e1;e22CET ciff the following
conditions hold:
1.e16=e2
2.9fX1;:::;XpgNodes (ICFG )j1i<p;Xi+1is control
or data dependent on X i^X12cerExtract (e1)
3.9fY1;:::;YqgNodes (ICFG )j1j<q;Yj+1is control
or data dependent on Y j^Y12cerExtract (e2)
4.Xpis a use or deﬁnition of f
5.Yqis a deﬁnition of f
The intuition behind this deﬁnition is that we can say an access
to a ﬁeld has been caused by an event consumption whenever the
occurrence of consumption determines that the access must hap-
pen (control dependency) or the consumption affects the value that
is stored in that ﬁeld (data dependency). The above deﬁnition has
three principal parts: (i)the CET set of a component (condition 1);
(ii)the control or data dependency paths from CETs to ﬁelds that
imply causality (conditions 2 and 3); and (iii)determining those
paths that access the same ﬁeld with at least one write access (con-
ditions 4 and 5). These three elements form the foundation of our
approach for extracting event anomalies, described next.
4. APPROACH
The goal of DEvA is to identify EAs in EBSs. To this end, we
have developed an automated static analysis technique that exam-
ines the implementation of a system and identiﬁes points in the
code where EAs may occur. Our approach identiﬁes all possible
EAs, regardless of their impact on the EBS. Determining the im-
pact of an EA is challenging, in part because it can vary signif-
icantly. For example, prior work has found that some races are
harmless and that removing them by introducing additional checksin the code can compromise the performance of the system [51, 43,
29]. On the other hand, EAs can lead to signiﬁcant reliability prob-
lems and could impact system scalability [18]. The determination
of the category into which an EA falls is generally a task for a sys-
tem’s engineers who must evaluate the EA’s impact on the EBS’s
functional and non-functional requirements.
The main inputs to our analysis are the implementation of an
EBS and a description of the framework used for processing events
in the system. The description must specify: (1) the list of all meth-
ods used as event sinks (in the case of an EBS with ambiguous in-
terfaces) or callback methods that serve as event sinks (in the case
of frameworks, such as Android, that rely on explicit event inter-
faces); (2) the base class used to implement events in the system;
and (3) the set of methods used as consumed event revealing (CER)
statements. All of the information in the description can be derived
from the API speciﬁcation of the underlying event-based frame-
work and only needs to be identiﬁed once per framework.
DEvA ’s analysis can be divided into three distinct phases. In
the ﬁrst phase— extraction —the analysis identiﬁes all of the con-
sumed event types (CETs) and ﬁelds accessed by each compo-
nent of the system. The second phase— causation —performs a
path-based analysis to determine if there is a connection between
the CETs and accessed ﬁelds. Finally, the third phase— joining —
identiﬁes CETs that will lead to an access of the same ﬁeld, that is,
a possible EA. The CETs and ﬁelds identiﬁed in the last phase are
returned to the developer for more investigation. In the remainder
of this section, we discuss each of the three phases in more detail.
4.1 Extraction
During this phase, DEvA identiﬁes two types of information about
the EBS that will be used in the later phases to identify anomalies.
The ﬁrst is the set of locations within each component where the
component’s ﬁelds are accessed either by a use or deﬁnition. The
second is the set of CETs accessed by each of the components.
DEvA identiﬁes a component’s ﬁeld accesses via a static intra-
procedural analysis of the component’s implementation. Formally,
we deﬁne a ﬁeld access as a tuple hf;niin which f2Fcis a ﬁeld of
component c(recall that Fcis the set of all ﬁelds of component c)
andn2Nmis a node in a method m’s control-ﬂow graph ( Nmrep-
resents the set of all nodes in method m’s CFG) that represents the
location in the code where the ﬁeld is used or deﬁned. DEvA gen-
erates two different sets, FUse mthat contains ﬁeld uses and FDefm
that contains ﬁeld deﬁnitions.
FDefm =fhf;nijf2Fc^n2Nm^ndeﬁnes fg
FUse m=fhf;nijf2Fc^n2Nm^n uses fg
To compute these sets, DEvA ﬁrst builds the CFG of each com-
ponent method. It then traverses the CFG and checks each node
to determine if it accesses a ﬁeld. To analyze a ﬁeld we performed
alias analysis that ﬁrst used class hierarchy analysis (CHA) to iden-
tify potential targets of a ﬁeld access and then used points-to anal-
ysis based on SPARK [33] to reﬁne the results.
To illustrate this step, consider the LoadBalancer component
shown in Figure 2 and its ICFG shown in Figure 3. The FDef and
FUse sets are shown in Table 1. In the handle method, since there
is a deﬁnition of ﬁeld preLmt at node 10 of the ICFG (correspond-
ing to line 10 in LoadBalancer ’s implementation) and a deﬁnition
of ﬁeld lmtat node 11, tupleshpreLmt ;10iandhlmt;11iare added
toFDefhandle . Also since there are two uses of ﬁeld lmtat nodes 10
and 12, and a use of ﬁeld preLmt at node 12 tupleshpreLmt ;12i,
hlmt;10iandhlmt;12iare added to FUse handle .
Our recently developed technique, Eos [26], is able to identify
CETs in EBSs that use ambiguous interfaces. Running Eos on the
28Table 1: LoadBalancer component information
Methods FDef FUse
handlefhpreLmt ;10i;hlmt;11igfhpreLmt ;12i;hlmt;12i
;hlmt;10ig
manageCurrentLoad fhcurLoad ;18igfhcurLoad ;17i;hcurLoad ;18i
;hlmt;17ig
LoadBalancer component would identify the two event types dis-
cussed in Section 3.2: the ﬁrst event with the attributes, Name and
Request , that are accessed using CER statements at lines 6 and 7
of Figure 2; and the second event with the attributes, Name and
Limit , that are retrieved using the CER statements at lines 9 and
11. In addition to the CET set, we extended Eos to also output
the code locations at which different attributes of each CET are re-
trieved, rather than just the name and value of each attribute. We
thus extract those locations and record them along with the name
of corresponding event in the CET set. Therefore, the CET set for
LoadBalancer will befh“NewRequest ”;6;7i;h“SetLimit ”;9;11ig.
Algorithm 1: Callback sink extraction
Input :Components ,Interfaces ,CET andS(sink)setsfor each
component
Output :Updated CET andS(sink)setsfor each component
1foreach i2Interfaces do
2 foreach c2Components do
3 ifc implements i then
4 add (c;i)to ImplementedInterf
5 if9f2Fcsuch that f and i have the same type t then
6 add (c;t;i)to Candidates
7foreach (c,i)2ImplementedInterf do
8 if9f2Fcof type t fand9(tf;t;i)2Candidates then
9 foreach m2Methods ido
10 add (m:name ,m:entry _node )to CET c
11 add m to S c
12 if9n2Methods c^n is called by a thread defined inside m
then
13 add (n:name ,n:entry _node )to CET c
14 add n to S c
Eos targets EBSs with ambiguous interfaces and is not able to
identify callback methods, which serve as sinks for explicitly typed
events in frameworks such as Android. Example callback sinks
in Android are onLocationChangedAsync andonDestroy from Fig-
ure 1. Standard callbacks, such as onDestroy , can be easily identi-
ﬁed in the code. However, custom, application-speciﬁc event sinks,
such as onLocationChangedAsync , must also be identiﬁed. Algo-
rithm 1 identiﬁes two common patterns of custom event sinks, and
uses these to identify sinks and CETs for Android applications. The
ﬁrst pattern comprises an interface i, a component c1that imple-
ments interface i, and a component c2that deﬁnes a ﬁeld variable
f1with the same type as interface i; in turn, c1should deﬁne a ﬁeld
variable f2with the same type as c2. Two components have the
same type when they are either instances of the same class or one
extends or implements the other. In this situation, whenever com-
ponent c1is instantiated, it will provide its “ this” reference via f2
to component c2, and c2will save the reference in f1. By doing
this, c2will be able to call methods that are declared in interface i
on component c1. The second pattern comprises a deﬁnition of a
thread inside a callback method and a call to another method inside
that thread to perform the required operation asynchronously.
Algorithm 1 ﬁnds the ﬁrst pattern by ﬁrst searching for all com-
ponents cthat implement a given interface i(lines 1-4) and stores
thehc;iituples in the ImplementedInterf set. After that, Algo-rithm 1 checks if a given component chas a ﬁeld variable of the
same type tas the interface i(lines 5-6) and stores the hc;t;iitu-
ple in the Candidates set. Finally, Algorithm 1 searches through
ImplementedInterf to check for all components cthat implement
an interface iand have a ﬁeld variable of type tf, such that tf’s class,
in turn, has a ﬁeld variable of type i(lines 7-8). In other words, Al-
gorithm 1 checks for tuples of the form htf;t;iiin the Candidates
set. If such a tuple is found, then the methods in interface iwill be
added to c’s sinks and the CET set (lines 9-11). Algorithm 1 ﬁnds
the second pattern by identifying methods called asynchronously
inside a thread, and adding them to the S(i.e., sink) and CET sets
of component c(lines 12-14). onLocationChangedAsync from the
MyTracks application of Figure 1 is an example of an asynchronous
callback in Android.
Algorithm 1 over-approximates callback sinks to detect all pos-
sible user-deﬁned callback methods and to avoid false negatives.
This over-approximation may cause some false positives in the man-
ner discussed in Section 5.6.
4.2 Causation
The second phase of DEvA ’s analysis identiﬁes whether ﬁeld ac-
cesses are dependent on the consumption of speciﬁc event types.
To this end, DEvA analyzes each ﬁeld access location to determine
if it is control or data dependent on CER statements that are used to
deﬁne a CET. The intuition is that if such dependencies exist, then
the ﬁeld access occurs, at least in part, due to the consumption of
an event type, and may be part of an EA.
Intuitively, one can think of this phase as analyzing the program
dependence graph (PDG) of a component. For each ﬁeld access,
DEvA performs a backwards traversal of the edges in the PDG. If
a CER statement is encountered during this traversal, then DEvA
identiﬁes the corresponding CET and the originating ﬁeld as being
connected. The phase outputs these connected CETs and ﬁelds.
For larger systems, generating and traversing a PDG is not scal-
able. Case in point, to naively analyze the subject systems used
in our evaluation (see Section 5), it would be necessary to gener-
ate PDGs for over 35 methods on average. This could consume
hours for a typical application. To address this issue, DEvA only
generates PDGs for a component’s sink methods, and then uses the
call graph (CG) of the system to identify methods that are reach-
able from each sink. A ﬁeld’s deﬁnition or use in method mthat
is reachable from sink smay be caused by an event’s consumption
if the invocation in sthat initiates the call to mis control or data
dependent on that consumption. We now detail the algorithms that
implement this approach.
The algorithm for this phase is shown as Algorithm 2. The in-
puts to this algorithm are the component cto be analyzed, the CETs
of the component ( CET c), the call graph of the component ( CGc),
and the FUse andFDef sets for each method in c. Note that CET c,
FUse , and FDef are the outputs of the ﬁrst phase discussed in Sec-
tion 4.1. The outputs of the algorithm are two sets, ConsumedToDef
andConsumedToUse , which contain tuples representing the ﬁelds,
and CETs that are linked by a dependency relationship. Each tu-
ple is of the formhf;n;eiwhere fis the ﬁeld, nis the location of
the ﬁeld’s access in the code, and eis the CET. The set Consumed-
ToDef contains tuples where nrepresents a deﬁnition of f, while in
ConsumedToUse n represents a use of f.
Algorithm 2 ﬁrst accesses a set Scthat contains all sink methods
inc. This set is deﬁned using method signatures for applications
with ambiguous interfaces, but is augmented with the results of Al-
gorithm 1 for Android applications. Then the algorithm iterates
over each method minc(lines 2–5). If mis a sink or it can be
reached from a sink in the call graph (line 3), then DEvA analyzes
29Algorithm 2: Causation
Input :c2Components ,CG c,CET c,8m2Methods c:FDefm;FUse m
Output :ConsumedToDefc,ConsumedToUse c
1LetSc= set of all c’s event sinks
2foreach m2Methods cdo
3 if(m2Sc)or(9s2Scso that m is reachable from s in CG c)then
4 ConsumedToDefc+ = ﬁeldAccessBackToConsumption (c;m;
FDefm;CET c)
5 ConsumedToUse c+ = ﬁeldAccessBackToConsumption (c;m;
FUse m;CET c)
Algorithm 3: ﬁeldAccessBackToConsumption
Input :c2Components ,m2Methods c,FieldAccesses ,CET c
Output :ConsumedtoAccess c
1LetNm= set of all nodes in m’s CFG
2LetcerNodes (e;m)where e2CET candm2Methods c=
fnjn2Nm^n2cerExtract (e)g
3LetSc= set of all of c’s event sinks
4LetSmSc= set of sinks that can reach minCG c
5LetStoM (s;m)= set of nodes in the CFG of s2Scthat can reach m
through direct or indirect calls
6foreach (f;n)2FieldAccesses do
7 foreach e2CET cdo
8 ifm2Scthen
9 if9l2cerNodes (e;m)such that n is directly or transitively
control or data dependent on l then
10 add (f;n;e)to ConsumedtoAccess c
11 else
12 foreach t2Smdo
13 foreach k2StoM (t;m)do
14 if9l2cerNodes (e;t)so that k is directly or transitively
control or data dependent on l then
15 add (f;k;e)to ConsumedtoAccess c
16return ConsumedtoAccess c
the ﬁeld accesses in mby calling ﬁeldAccessBackToConsumption
(lines 4 and 5). The function ﬁeldAccessBackToConsumption is
shown in Algorithm 3. At a high-level, ﬁeldAccessBackToCon-
sumption iterates over each ﬁeld access in m(line 6) and each event
inCET c(line 7) to determine if a dependency relationship exists be-
tween them. Within this iteration, there are two cases to consider.
The ﬁrst case (at line 8) is when mis a sink. In this case, DEvA
simply checks the PDG of mto see if the ﬁeld access is dependent
on any CER node for the current CET (line 9). If so, the tuple
representing the ﬁeld, location, and event type is added to the out-
put set (line 10). The second case (at line 11) is for any non-sink
method. DEvA begins by iterating over the set of all sink methods
Smthat can reach m(line 12). Within each t2Sm,DEvA also it-
erates over each node kthat is in tand can reach m(line 13). We
compute this reachability relationship by determining if kcan reach
an invocation in t’s CFG that, in turn, reaches mvia the call graph.
This relationship is encapsulated in the function SToM (line 5). If
kis dependent on a CER node, then this relationship is added to the
output set (lines 14 and 15). The intuition here is that the ﬁeld ac-
cesshf;nican be reached via a statement kthat is itself dependent
on a CER node.
Let us now consider an example for each of the two cases. To
illustrate the ﬁrst case, consider the handle method of the Load-
Balancer component from Figure 2. Since handle is a sink, ﬁeld-
AccessBackToConsumption will use the PDG (shown in Figure 4)
to extract those members of FDefhandle , listed in Table 1, that arecontrol or data dependent on a node that contains a CER statement.
Considerhlmt;11iin the PDG . Node 11 is connected to node 9,
which contains a node with a CER statement for the SetLimit
event; sohlmt;11;“SetLimit ”iwill be added to the return set. Next,
hpreLmt ;10iis also dependent on node 9, so hpreLmt ;10;“SetLimit
”iwill be added to the return set.
To illustrate the second case, consider the method manageCur-
rentLoad . Based on the ICFG in Figure 3, only node 7 in the sink
handle can reach manageCurrentLoad .StoM (handle,manageCurre
ntLoad) thus returns a singleton containing node 7. Based on the
PDG ofhandle (Figure 4), node 7 is control dependent on node 6,
which contains a CER statement of the NewRequest event. There-
fore, any deﬁnition or use inside the manageCurrentLoad method
is dependent on this event. Since FDefmanageCurrentLoad contains
hcurLoad ;18i, our algorithm will add hcurLoad ;18;“NewRequest ”i
to the return set for deﬁnition accesses of manageCurrentLoad .
After Algorithm 2 completes its analysis of the LoadBalancer
component from Figure 2, its output would be:
ConsumedToDefLoadBalancer =f
hlmt;11;“SetLimit ”i;hcurLoad ;18;“NewRequest ”i;
hpreLmt ;10;“SetLimit ”ig
ConsumedToUse LoadBalancer =f
hcurLoad ;17;“NewRequest ”i;hcurLoad ;18;“NewRequest ”i;
hlmt;17;“NewRequest ”i;hlmt;10;“SetLimit ”i;
hlmt;12;“SetLimit ”i;hpreLmt ;12;“SetLimit ”ig
4.3 Joining
DEvA ’s third phase analyzes the dependencies between CETs
and ﬁelds to determine which ones may lead to an EA. The intuition
is that if one CET–ﬁeld dependency writes to a ﬁeld and another
one either writes to or reads from that ﬁeld, then this is an EA.
The algorithm for this phase is shown in Algorithm 4. The in-
puts to the algorithm are ConsumedToDefcandConsumedToUse c,
which were generated in the second phase, and whose values for
LoadBalancer are shown at the end of Section 4.2. The goal of the
ﬁrst step (lines 1–4) of the algorithm is to remove uses that may re-
sult in false positives. This step is analogous to identifying reaching
deﬁnitions [15]: a deﬁnition of a given ﬁeld freaches a node nin
a CFG if there is a path in the CFG from the node at which fis de-
ﬁned to nwithout any other deﬁnition of fon that path. If there is a
deﬁnition of a ﬁeld that dominates a use of the same ﬁeld, then that
use cannot be involved in an EA condition with any other deﬁnition
of the ﬁeld. Domination occurs when all paths from the entry node
of a CFG to the location of ﬁeld f’s use include the node that de-
ﬁnes f. In that case, f’s use is removed from the ConsumedToUse
set at line 4 of Algorithm 4. To illustrate this ﬁrst step, consider the
deﬁnition of lmtat line 11 of Figure 2. This deﬁnition dominates
the use of lmtat line 12. Therefore, the use of lmtat line 12 will
be removed from ConsumedToUse LoadBalancer , after which we will
have:
ConsumedToUse LoadBalancer =f
hcurLoad ;17;“NewRequest ”i;hcurLoad ;18;“NewRequest ”i;
hlmt;17;“NewRequest ”i;hlmt;10;“SetLimit ”i;
hpreLmt ;12;“SetLimit ”ig
The second step of the algorithm (lines 5–9) iterates over each
CET–ﬁeld dependency where the ﬁeld access is a deﬁnition, and
checks whether there are any deﬁnitions or uses of the same ﬁeld
that can be triggered by the consumption of different CETs. Essen-
tially, this performs a join over two inputs when the ﬁeld in each
tuple is the same. If such CET–ﬁeld dependencies exist, then an
EA is detected, and a tuple containing the affected ﬁeld and the two
30Algorithm 4: Joining
Input :c2Components ,ConsumedToDefc,ConsumedToUse c,ICFG
Output :EventAnomalies c
1foreachhf;n;ei2ConsumedToDefcdo
2 foreachhf2;n2;e2i2ConsumedToUse c^f=f2^e=e2do
3 iff’s deﬁnition at node n kills all other deﬁnitions that reach
node n 2then
4 removehf2;n2;e2if rom ConsumedToUse c
5foreachhf;n;ei2ConsumedToDefcdo
6 foreachhf3;n3;e3i2ConsumedToDefc^f=f3^e6=e3do
7 addhf;e;e3ito EventAnomalies c
8 foreachhf4;n4;e4i2ConsumedToUse c^f=f4^e6=e4do
9 addhf;e;e4ito EventAnomalies c
event types is added to the output set. To illustrate the joining al-
gorithm, consider the ConsumedToDe f LoadBalancer set, reported at
the end of Section 4.2, and ConsumedToUse LoadBalancer after line 4
of Algorithm 4, reported earlier in this section. There is one CET–
ﬁeld dependency that deﬁnes lmt. This deﬁnition happens at line
11 and is caused by the SetLimit event. There is also one CET–
ﬁeld dependency that uses lmt. This use happens at line 17 and is
caused by the NewRequest event. These paths access the same ﬁeld
with one of them being a write access and are dependent on differ-
ent event types, introducing an EA. The output of Algorithm 4 for
LoadBalancer is, therefore,fhlmt;“SetLimit ”;“NewRequest ”ig.
5. EV ALUATION
We have empirically evaluated DEvA (1) to measure its accuracy
in extracting EAs; (2) to compare it with a state-of-the-art race de-
tection technique for multi-threaded systems; (3) to compare its
performance with a recently published race detection technique for
Android applications; and (4) to examine its execution time.
5.1 Subject Systems and Implementation
Table 2 contains information about the 20 subject systems we
have used in our evaluation; 18 of them are applications and the re-
maining two are widely used Android libraries (e.g., these libraries
are used in several of the Android applications from Table 2). All
subjects are implemented in Java, but are from different application
domains ( App Type ), of different sizes ( SLOC ), and use different
underlying mechanisms for consuming events ( Event Mechanism ).
In selecting these subjects, we ﬁrst located a corpus of suitable
systems that make use of events in their implementations. Two PhD
students examined a number of open-source applications and iden-
tiﬁed likely candidates by looking for possible instances of EAs.
Each system for which our preliminary examination indicated a
potential presence of EAs was then carefully analyzed by the two
students with the help of the Eclipse IDE to obtain the ground truth.
The generation of the ground truths took slightly more than 15
person-hours per system on average. As discussed in Section 4,
even seemingly harmless races may actually harm a system in sub-
tle ways [18], hence our ground truths contained all possible races
regardless of their impact on the EBSs.
A notable outlier among our subject systems is Project.net , which
is signiﬁcantly larger than the other systems. It partly uses event-
based interactions on its server side, but mostly relies on web-based
interactions. We only provided Project.net ’s event-based portion,
totaling around 10 KSLOC, as an input to DEvA . However, to pin-
point this portion, we had to analyze the entire system.
DEvA is implemented in Java and Scala, and it uses the Soot [55]
program analysis library to generate call graphs, control ﬂow graphs,
and program dependency graphs. To analyze EBSs that rely on am-Table 2: Systems used in the evaluation
App Name App Type SLOC Event Mechanism
Planner AI Planner [45] 6K c2.fw [38], Java events
KLAX Arcade Game [54] 5K c2.fw [38], Java events
DRADEL Software IDE [39] 11K c2.fw [38]
ERS Crisis Response [36] 7K Prism-MW [37]
Troops Simulator [37] 9K c2.fw [38]
Stoxx Stock Ticker [40] 6K REBECA [41]
JMSCHAT Chat System [8] 12K ActiveMQ, Java events
Project.net Project Mgmt [9] 247K Spring [10]
ToDoWidget ToDo List Recorder [5] 2K Android Events
FBReader Book Feed Reader [3] 34K Android Events
MyTracks Location Tracker [4] 13K Android Events
ZXing Barcode Scanner [2] 16K Android Events
Firefox Browser App [7] 58K Android Events
ConnectBot SHH Client [1] 23K Android Events
VLC Media Player [6] 101K Android Events
Browser Android Browser App 22K Android Events
Camera Android Camera App 13K Android Events
Music Android Audio Player 8K Android Events
android.support.v4 Support Library 7K Android Events
android.support.v7 Support Library 11K Android Events
biguous interfaces—in our case, this includes all non-Android ap-
plications from Table 2—we used an extension of Eos [26] for gen-
erating the required inputs for DEvA , as described in Section 3.2.
We ran DEvA on a quad-core Intel i7 2.80GHz system with 8GBs
of memory, running Windows 7 Professional.
5.2 Accuracy of EA Detection
To assess DEvA ’s accuracy in detecting EAs, we applied it on
the subject systems and compared its results to the ground truths.
If an anomaly reported by DEvA was not in the ground truth, we
counted it as a false positive; conversely, an anomaly in the ground
truth that was not reported by DEvA was counted as a false nega-
tive. Our results are summarized in Table 3. For all but three of
the systems, DEvA was able to ﬁnd each anomaly identiﬁed in the
ground truth. The three exceptions were KLAX , for which DEvA
yielded 2 false negatives, ToDoWidget , with 12 false negatives, and
MyTracks , with 1 false negative. DEvA did not report any results
that we had not found and conﬁrmed as EAs in our ground truths,
i.e., it had no false positives.
Table 3: Results of applying DEvA on the subject systems
System Anomalies Time ( s)
Planner 11 62
KLAX 12 62
DRADEL 447 122
ERS 37 54
Troops 30 75
Stoxx 1 66
JMSCHAT 3 29
Project.net 1 27
ToDoWidget 7 24
FBReader 74 58
MyTracks 73 65
ZXing 4 52
Firefox 39 81
ConnectBot 32 78
VLC 52 42
Browser 111 36
Camera 212 45
Music 65 33
android.support.v7 50 35
android.support.v4 109 59
In the cases of KLAX ,ToDoWidget , and MyTracks , the false neg-
atives occurred because these systems rely on non-standard mech-
anisms to access component state and communicate state changes.
For example, MyTracks dispatches an event by directly accessing
the event’s “what” attribute, while KLAX passes the entire current
state of the game from one component to another via a single event
with a single, very complex parameter. DEvA could be relatively
31easily modiﬁed to cover each of these exceptional cases. How-
ever, we have chosen not to do so for our evaluation because it will
always be possible to use other unforeseen, non-standard “hacks”
when generating and processing events so that DEvA or a similar
technique would not catch them without accounting for additional
special cases. DEvA relies on EBS engineers to exercise relatively
minimal discipline when developing their systems.
DEvA reported several hundred EAs across the 20 subject sys-
tems. As discussed above, DEvA was able to identify a great ma-
jority of the anomalies present in our ground truths, and it did not
yield any false positives: each reported anomaly did, in fact, reﬂect
implicitly-concurrent accesses to a component ﬁeld with at least
one access being a write. An EA may have one of three possible
outcomes:
1.It is clearly a bug. An example is the UFanomaly in the
MyTracks Android application from Figure 1.
2.It is clearly an undesirable nondeterministic behavior. An
example involves the GameOver event in KLAX, which can
be preempted by the GamePaused event, resulting in an ad-
ditional life for the player.
3.It is potentially an undesirable nondeterministic behavior.
An example is a Stoxx event that changes a threshold on a
stock’s price while another event requests a computation us-
ing the threshold and the stock’s change history.
While not all of the EAs reported by DEvA will have the same
effect, they all have the potential to cause undesired behavior in a
system and should be carefully examined by the engineers [18].
5.3 Comparison to Multi-Threaded Analysis
In a multi-threaded environment, a data race occurs when two
or more threads access the same memory location without proper
synchronization. Because this is similar to our problem, we inves-
tigated whether standard data race detection techniques could be
applied to ﬁnd EAs.
To determine whether this is the case, we studied the literature
on race detection and selected Chord [42] as a state-of-the-art static
analysis technique to apply on our subject systems. Chord was cho-
sen because it is the only technique of its kind that has a reliable,
actively maintained implementation. The purpose of this study was
to establish the extent of overlap between the outputs produced by
Chord andDEvA . The numbers of data races found by Chord are
shown in Table 4. Since Chord starts its analysis from a main
method and Project.net has no such method, Chord was unable to
analyze Project.net . Furthermore, we were unable to apply Chord
on Android applications because Chord is not designed to consider
the methods used in Android as event entry points.
Despite this, the comparative analysis was revealing. We found
that the result sets produced by Chord andDEvA do not overlap:
none of the EAs reported by DEvA were among the data races re-
ported by Chord , or vice-versa. DEvA was unable to detect any
of the data races in the subject systems for the simple reason that
it does not target traditional data races. Similarly, Chord does not
consider the conditions that result in EAs. This suggests that DEvA
and a static race detection technique such as Chord are comple-
mentary, and can be used effectively alongside each other.
A deeper analysis sheds further light on why the two techniques
yield such different results. EAs are caused by implicit concur-
rency. They are independent of the number of threads in a system
and may occur even in single-threaded EBSs. On the other hand,
data races only happen in the presence of at least two threads. EAs
detected by DEvA are potentially more dangerous in that it is harder
to track accesses to shared data when those accesses are impactedTable 4: Results of applying Chord on the subject systems
System Data Races
Planner 14
KLAX 115
DRADEL 0
ERS 1418
Troops 78
Stoxx 31
JMSCHAT 0
by a number of factors and actors in a distributed system: the lo-
cal state of the component processing an event, the network, event
routers and dispatchers, and all the other distributed components in
the EBS along with their respective states.
5.4 Comparison to Existing Android Analysis
We also evaluated DEvA against CAFA [29], a recent dynamic
analysis technique for detecting Use-After-Free (UF) EAs in An-
droid applications. In order to compare our approach with CAFA ,
we conﬁgured DEvA to report only UFanomalies among the EAs
it detects. We then applied DEvA on the same versions of applica-
tions used in CAFA ’s evaluation [29]. Table 5 shows the relevant
results. Note that the CAFA results did not include the two An-
droid support libraries shown in Table 2, so for this reason, they are
omitted from Table 5.
Table 5: Results of UFanalysis by CAFA andDEvA (note that
CAFA is unable to identify the other EAs shown in Table 3)
CAFA DEvA j CAFA DEvA
App Name All All jHarmful Harmful
ToDoWidget 8 1 j 8 1
FBReader 3 2 j 1 2
MyTracks 1 5 j 1 2
ZXing 1 0 j 0 0
Firefox 4 0 j 0 0
ConnectBot 1 2 j 0 1
VLC 0 4 j 0 1
Browser 1 23 j 0 1
Camera 1 0 j 1 0
Music 4 17 j 2 9
TheCAFA All andDEvA All columns include all UFanomalies
reported by the two techniques. As discussed by the authors of
CAFA , certain UFanomalies will not actually result in null-pointer
exceptions because of checks placed in the code [29]. Using the
classiﬁcation established for evaluating CAFA , the CAFA Harmful
andDEvA Harmful columns in Table 5 show the respective num-
bers of discovered UFanomalies that result in actual runtime ex-
ceptions.
For all but two of the applications, DEvA was able to identify
more harmful UFanomalies than CAFA . For two of the ten appli-
cations, Camera andToDoWidget ,CAFA performed better. In the
case of Camera ,CAFA reported a single harmful UFanomaly that
DEvA could not detect. After inspecting the source code of this
application, we were not able to locate CAFA ’s reported anomaly.
It is possible that the anomaly occurred because of problems in the
libraries that Camera uses, as CAFA did not analyze libraries sepa-
rately from the application, while DEvA did not analyze these par-
ticular libraries. DEvA also had seven false negatives in the case of
ToDoWidget . The reason was already discussed above: ToDoWid-
getrelies on non-standard mechanisms to access component state.
With regards to false positives, the performance of DEvA was
also stronger. CAFA reported non-harmful UFEAs in six out of
ten Android applications. As discussed in [29], these are false pos-
itives: they are not actual EAs. As conﬁgured for this comparative
evaluation, DEvA reported non-harmful UF anomalies in ﬁve of
the ten applications. However, these false positives were actually
32EAs (just not UFanomalies): while they will not produce runtime
null-pointer exceptions, they do result in nondeterministic applica-
tion behavior and it is therefore still important for the developers to
be aware of them. In summary, out of the combined 25 harmful UF
anomalies that were discovered by CAFA andDEvA in the analyzed
Android applications, CAFA was able to discover 13, while DEvA
was able to discover 17.
In addition to the comparison study described above, DEvA was
able to uncover a number of EAs in the two Android libraries we
analyzed (recall Table 3). Some of those were, in fact, harmful UF
anomalies. For example, DEvA reported a harmful anomaly in the
android.support.v4 library. This is a known bug [13], but to the best
of our knowledge, DEvA is the ﬁrst to identify the bug’s root cause.
This bug happens in the android.support.v4.app.DialogFragment
class due to the interaction between events ActivityCreated (pro-
cessed by the method onActivityCreated ) and DestroyView (pro-
cessed by onDestroyView ) over the ﬁeld variable mDialog . Because
the order of the two events is nondeterministic, onActivityCreated
is able to access mDialog after onDestroyView sets it to null.
Overall, the results of this study were very positive. When we
conﬁgured DEvA to identify only UFanomalies, DEvA was able
to uncover more such anomalies than a leading technique in eight
of the ten applications. The number of false positives yielded by
DEvA was lower and, while these were not necessarily UFanoma-
lies, they were actual EAs. Finally, DEvA was able to ﬁnd the root
cause of a previously unsolved bug in a widely used Android li-
brary.
5.5 Execution Time
Given our objective of constructing an efﬁcient technique, we
designed DEvA to generate and use only the subset of system in-
formation that is required for event-anomaly analysis. Thus, for
example, DEvA generates PDGs for component sink methods only,
and considers only those CETs that are consumed at a given sink
(recall Section 4).
Table 3 shows the execution Time required by DEvA to analyze
each subject system. These measurements include the time used by
Soot to generate call graphs, CFGs, and PDGs; the Soot analysis
averaged around 42 sper system. The analysis by DEvA ranged
between 24 sand 122 s, with an average of 55 s. This execution time
is reasonable, especially when we take into account that analyzing
each system manually took over 15 hours. As a further comparison,
CAFA ’s execution time for the ten Android applications shown in
Table 5 varied between 30 minutes and 16 hours; DEvA ’s maximum
execution time for the same applications was 81 seconds.
5.6 Limitations and Threats to Validity
We have identiﬁed three limitations in our evaluation. The ﬁrst
limitation is the largely manual construction of the ground truth ,
aided only by the code-search and visualization features of Eclipse.
Human error in this process could affect the reported results. We
tried to mitigate this issue by carefully validating the ground truth
through inspection, as reﬂected in the very long time required to
construct it. This is further mitigated by the comparison to CAFA ,
which indicates that, with the exception of the single application
that relies on a non-standard event-processing mechanism, DEvA
did not miss any harmful UFEAs. The second limitation is that, in
analyzing EBSs with ambiguous interfaces, Eos occasionally yields
a small number of false positives in reporting event types [26]. In
turn, this may affect DEvA ’s results. Note that Eos’s inaccuracy
did not have any impact on the Android systems we analyzed since
DEvA ’s Algorithm 1, rather than Eos, was used there. The third
limitation is that DEvA assumes that callback methods are deﬁnedin the source code of an Android application to handle events that
can occur nondeterministically. If this is not the case, DEvA will
report false positives.
Beyond the three limitations that are speciﬁc to DEvA , there
are at least two additional limitations that impact the accuracy of
static analysis techniques in general: aliasing and detecting feasi-
ble paths. Aliasing can take the form of data aliasing, in the case of
references to variables, or method aliasing, in the case of virtual in-
vocation. Data aliasing can affect data-ﬂow analysis, and virtual in-
vocation can affect call graph generation by introducing false edges
between methods. Inaccuracies in data ﬂow analysis and call graph
generations can affect the generation of ICFGs and PDGs. As we
discussed earlier, to generate ICFGs and PDGs, we relied on Soot,
but Soot is occasionally unable to analyze certain systems. In our
work, this happened with two components of the KLAX system, for
which Soot was unable to provide the PDG. In our subject systems,
virtual invocation is used for creating and building events, but not
for their consumption. This was the primary reason why aliasing
inaccuracies did not cause DEvA to report false positives. For the
ground truth we tried to detect infeasible paths by manual inspec-
tion of the subject systems’ code. We did not ﬁnd any infeasible
paths that would have resulted in falsely identiﬁed EAs by DEvA .
Checking the feasibility of paths in our subject systems was time
consuming, but doable, since the extent of branching after event
consumption was low in these systems.
6. RELATED WORK
Our research is related to several approaches that have been pro-
posed to aid the analysis of concurrent, distributed, and loosely-
coupled systems. We highlight the most closely related work.
Multi-Threaded Systems. Event anomalies bear resemblance to a
well-known problem in multi-threaded systems— data race . Data
races occur when two or more execution threads access the same
variable. If at least one of those threads writes to the variable, then
different runtime scheduling of the threads may result in errors.
Even though they are well known, data races are hard to ﬁnd and
debug because of the nondeterministic nature of the systems that
contain them. Race detection techniques for multi-threaded sys-
tems deal with explicit concurrency between threads. On the other
hand, DEvA is dealing with implicit concurrency that happens as a
result of nondeterminism in the order of event consumptions.
There are a number of dynamic race detection techniques for
multi-threaded systems [44, 25, 20]. Most of these techniques are
based on checking the happens-before relationship. This relation-
ship introduces a partial ordering among events in a system [31].
There are also dynamic race detection techniques that are based on
checking shared memory references and verifying proper locking
(lockset checking) on them [51]. Smaragdakis et al. [52] intro-
duced a sound dynamic analysis technique based on a generaliza-
tion of happens-before , called causally-precedes . Dynamic anal-
ysis techniques are dependent on the size of the execution trace
and cannot be applied to non-executable programs, such as libraries
[42].
Static analysis techniques are either ﬂow-sensitive versions of
lockset analysis [23], ﬂow-insensitive [48], or path-sensitive model-
based [49] techniques. Most static race detection techniques rely on
computationally complex analyses such as may-alias . Because of
this, they may suffer from precision, soundness, or scalability prob-
lems. Chord [42] is a ﬂow-insensitive analysis that makes use of
conditional-must-not-alias analysis instead of the may-alias analy-
sis to reason about shared memory locations. As described in Sec-
tion 5, we compared DEvA with Chord in our evaluation.
33Web Systems and Applications. There are techniques that try to
solve similar problems to ours in other domains. Zheng and Zhang
[57] proposed an approach to extract race problems that may hap-
pen in PHP-based web applications. Their approach is a static anal-
ysis that reports races that might happen as a result of atomicity vi-
olations in accessing external resources such as database tables or
ﬁles. Their approach also takes explicit concurrency into account.
Paleari et al. [46] proposed an analysis that also looks into atom-
icity violations occurring due to the inherent concurrency in web
applications. Their approach focuses on interactions between an
application and a DBMS. It logs SQL queries and looks for spe-
ciﬁc interleaving patterns in them. Since this is a dynamic analysis,
it is unable to detect races unless they occur in an execution.
Petrov et al. introduced W EBRACER [47], a dynamic analysis
technique for race detection in client-side web applications. W EB-
RACER deﬁnes the happens-before relationship to check for non-
deterministic accesses to the same object. Raychev et al.’s E VENT -
RACER [50] improved W EBRACER to decrease the number of re-
ported harmless races.
Event-Based Systems. Panini [34] is a language that uses asyn-
chronous typed events to make designing for modularity and con-
currency easier. P anini only considers the overlapping that may
happen between event-handler methods. Each event-handler con-
sumes a speciﬁc type of event, similarly to Android. A common
practice in event-based systems is that a component has a single
event handler, and inside that handler different events are processed
using dispatching and implicit invocation. Neither E VENT RACER
[50] nor P anini can support such systems. An added disadvan-
tage is that P anini is not applicable to legacy systems written in a
general-purpose language such as Java.
P [22] is a domain-speciﬁc language for event-driven asynchronous
systems. A program written in P consists of a set of state machines
that interact via events. There is no speciﬁc analysis built into P
for data races or event anomalies. Instead, a developer has to de-
sign policies inside state machines to avoid such situations using
P’s concepts such as deferred and ignored events.
Android Systems. CAFA [29] is a dynamic analysis technique tar-
geting Android applications. Android applications react to events
that originate from sources such as the user or Android kernel.
CAFA considers the causal order between events to check if a race
can happen because of the resulting memory accesses. CAFA fo-
cuses on uncovering a speciﬁc class of problems, UF, in which
a memory location is accessed by an event without proper refer-
ence checking after it is freed by another event. As discussed in
Section 5, we compared DEvA toCAFA over the same set of appli-
cations.
DroidRacer [35] is also a dynamic analysis technique for race
detection in Android applications. This technique is based on deﬁn-
inghappens-before relationships between Android events and pro-
vides a formal semantic model for Android concurrency by study-
ing the Android framework. However, DroidRacer neither sup-
ports user-deﬁned asynchronous callback events nor categorizes
races based on their harmfulness. Based on the evaluation results,about 50% of callback-related races reported by DroidRacer were
false positives.
GATOR [56] is a static analysis technique for Android applica-
tions that extracts user-deﬁned GUI-based callback methods. This
technique provides an ICFG of the analyzed Android application
that shows interactions between user-deﬁned GUI-based callbacks,
as well as Android’s onCreate andonDestroy life-cycle callbacks.
Unlike DEvA ,GATOR does not consider other kinds of user-deﬁned
callbacks, such as asynchronous callbacks, nor does it take into ac-
count the remaining life-cycle callbacks deﬁned by Android.
7. CONCLUSION
Event-based interaction is an attractive paradigm because of its
promise of highly ﬂexible systems in which components are decou-
pled and can “come and go” as needed. This ﬂexibility comes at a
price, however. Debugging EBSs can be particularly onerous. One
of the reasons is that the order in which events are sent, received,
and processed can be highly unpredictable. This is caused by im-
plicit invocation and implicit concurrency, which, in turn, may re-
sult in event anomalies (EAs).
Several existing approaches have targeted different facets of this
problem, but they have notable shortcomings that have motivated
our research. A long-standing class of data-race detection tech-
niques for concurrent systems is unable to deal with the implicit
concurrency and implicit invocation present in EBSs. Approaches
that target EBSs directly have tended (1) to rely on dynamic analy-
sis with its inherent limitations, (2) to use new language constructs
that cannot be applied to existing systems, or (3) to exploit domain-
speciﬁc characteristics that lend themselves to simplifying assump-
tions holding only in relatively narrow settings.
To address these problems, we have developed DEvA , a new
static analysis technique that targets EBSs. Our empirical evalu-
ation shows that DEvA is efﬁcient and scalable, while exhibiting
high precision with respect to the manually identiﬁed EAs in 20
subject systems. We have demonstrated that DEvA can be used in
tandem with existing analysis techniques, such as Chord [42]. A
comparison with CAFA [29], a recent technique that targets a spe-
ciﬁc class of EAs, UF, shows that, in most cases, DEvA is able to
detect a greater number of such anomalies in a fraction of the time.
There are a number of remaining research challenges that will
guide our future work. Some event anomalies may be harmful
only in certain scenarios or may even result in acceptable behaviors
(e.g., getting location data that is slightly stale when slowly walk-
ing). We intend to study the actual harmfulness of event anomalies
to ease the decision-making process for EBS developers. To this
end, we will explore coupling DEvA with our recent technique for
extracting accurate models of component behavior from runtime
traces [30]. Monitoring, storing, and enabling the replay of event
sequences in order to reproduce anomalies is another research di-
rection. The long-term goal of this work is to provide a suite of
ready-made remedies to different types of event anomalies, as well
as a set of automated wizards to guide developers in selecting and
applying these remedies.
348. REPLICATION PACKAGE
We have made available a package allowing independent replica-
tion of our results [14]. This package contains DEvA ’s implemen-
tation, the ground truths used for DEvA ’s evaluation, and all eval-
uation results presented in this paper. A manual describing how to
useDEvA is also included. The DEvA replication package has been
successfully evaluated by ESEC/FSE 2015’s Replication Packages
Evaluation Committee and found to meet the Committee’s expec-
tations.
DEvA uses conﬁguration ﬁles to set the environment to perform
its analysis. In Figure 5, part of the conﬁguration ﬁle for analyzing
theMyTracks Android application is shown. In this conﬁguration
ﬁle, at line 1, the maximun heap size for the JVM is set. Line 2
indicates the location of the jarﬁle that contains the source code of
the system that DEvA wants to analyze. mainComponent at line 4
indicates the component that is the entry point of DEvA ’s analy-
sis.ﬁleNameForRaceResults at line 7 indicates the location of the
output ﬁle for the list of event anomalies, and ﬁleNameForUFRac-
eResults at line 9 represents the location of the ﬁle for the list of
UF anomalies in the case of Android systems. middlewareID at
line 12 shows the mechanism the system under analysis uses for
event-based communications.
1jvm.xmx = 2g
2process.dir =
3 ${user.dir}/applications/MyTracks.jar
4mainComponent =
5 com.google.android.apps.mytracks.MyTracks
6
7fileNameForRaceResults =
8 ${user.dir}/results/MyTracks-detected-EAs.txt
9fileNameForUFRaceResults =
10 ${user.dir}/results/MyTracks-detected-UF.txt
11
12 middlewareID = Android
Figure 5: Portion of the MyTracks Conﬁguration used by DEvA
Figure 6 shows a view of DEvA ’s architecture. After providing
the conﬁguration ﬁle to DEvA , the Initializer component will load
the related part of the DEvA to perform the analysis. As we dis-
cussed in the paper, DEvA acts differently when dealing with An-
droid and non-Android systems. If the system that is under analysis
is an Android-based system, the Initializer will ask the Callback
Detector component to extract user-deﬁned callback methods. Af-
ter the Callback Detector ﬁnishes its job, it will provide the EA
Detector with the list of user-deﬁned callbacks as well as the call-
backs from the Android life-cycle. After this, the EA detector will
perform the analysis described in this paper to extract EAs, and will
print out the detected EAs in a ﬁle that is indicated in the conﬁgura-
tion ﬁle. It also provides these EAs to the UF Detector component
to extract use-after-free bugs for Android systems. The UFanoma-
lies will be stored in a ﬁle that is indicated in the conﬁguration ﬁle.
For non-Android systems, the Initializer will initiate Eosto ex-
tract information about event types. Eoswill provide this informa-
tion to the EA Detector . In turn, the EA Detector will extract EAs
and will report them in a ﬁle that is mentioned in the conﬁguration
ﬁle.
We have tested DEvA on Windows 7, 64 bit, JDK 1.8, IntelliJ
IDEA version 13.0.4, with Scala plugin version 0.26.327. We used
the Scala compiler version 2.11.6 with language level 2.10. In or-
der to use DEvA , it is necessary to ﬁrst download IntelliJ IDEA
(we used version 13.0.4) and install the Scala plugin 0.26.327 on it.
After this, one should download the zip ﬁle that contains DEvA ’ssource code from [14], unzip the downloaded ﬁle in the desired lo-
cation, and open the DEvA project in the IntelliJ IDEA environment
by browsing to that location.
For each of the systems that we studied in this paper, we have
provided a conﬁguration ﬁle in the replication package. Those con-
ﬁguration ﬁles can be found in the conﬁgFiles folder in the project
structure view of the IntelliJ IDEA environment. To run DEvA
on a system with the name MySystem , one must open the MySys-
tem.build.properties ﬁle, copy all of its contents, and paste them in
thebuild.properties ﬁle. After setting up the build.properties ﬁle,
one just needs to click on the Runbutton in the IntelliJ IDEA envi-
ronment.
To customize DEvA to run on a new system that uses an event-
based mechanism not supported by our replication package, one
needs to provide the necessary information for DEvA . To do this,
one must ﬁrst create a Scala object for the new mechanism in the
edu.usc.softarch.helios.middleware package that is part of the Ini-
tializer component. The Scala objects corresponding to the sup-
ported mechanisms can be found in that package, and can be used
as examples for the new mechanisms. After creating the needed
Scala object, one also needs to add the appropriate case line to the
edu.usc.softarch.helios.middleware.Middleware object.
Initializer
EosCallback 
Detector
EA Detector
UF
Detector
Flow of data for
Android systems
Flow of data for
Non-Android systems  ______
______
______
UFs______
______
______
EAs______
______
______
Source Code______
______
______
Configuration
---Output---Input
Figure 6: A view of DEvA ’s architecture
359. REFERENCES
[1] ConnectBot, Version 1.7.
http://code.google.com/p/connectbot/ , 2011.
[2] ZXing, Version 4.5.1.
http://code.google.com/p/zxing/ , 2011.
[3] FBReader, Version 1.9.6.1.
http://fbreader.org/FBReaderJ , 2012.
[4] MyTracks, Version 1.1.7.
http://code.google.com/p/mytracks/ , 2012.
[5] ToDoWidget, Version 1.1.7.
http://github.com/chrispbailey/ToDo-List-Widget ,
2012.
[6] VLC, Version 0.2.0. http://www.videolan.org/vlc/ ,
2012.
[7] Firefox, Version 25.
http://www.mozilla.org/en-US/firefox/fx/ , 2013.
[8] JMSChat. http://github.com/julentv/ChatJMS.git ,
2013.
[9] Project.net. http://www.project.net/ , 2013.
[10] Spring Framework.
http://projects.spring.io/spring-framework/ ,
2013.
[11] UF bug 1070795 in ﬁrefox for android. https:
//bugzilla.mozilla.org/show_bug.cgi?id=1070795 ,
2013.
[12] UF bug 923407 in ﬁrefox for android. https:
//bugzilla.mozilla.org/show_bug.cgi?id=923407 ,
2013.
[13] Discussion about the bug in android.support.v4.
http://stackoverflow.com/questions/12265611/
dialogfragment-nullpointerexception-support-library ,
2014.
[14] DEvA’s Replication Package. http:
//www-scf.usc.edu/~gsafi/FSE2015Replication/ ,
2015.
[15] A. Aho et al. Compilers, Principles, Techniques, and Tools .
Addison-Wesley, 1986.
[16] F. Biscotti et al. Market Share: AIM and Portal Software,
Worldwide, 2009. Gartner Market Research Report , April
2010.
[17] F. Biscotti and A. Raina. Market Share Analysis: Application
Infrastructure and Middleware Software, Worldwide, 2011.
Gartner Market Research Report , April 2012.
[18] H.-J. Boehm. Nondeterminism is unavoidable, but data races
are pure evil. In Proceedings of the 2012 ACM Workshop on
Relaxing Synchronization for Multicore and Manycore
Scalability , RACES ’12, pages 9–14, New York, NY , USA,
2012. ACM.
[19] J. Brederekea and R. Gotzheinb. Increasing the concurrency
in estelle. 1993.
[20] Y . Cai and W. K. Chan. Loft: Redundant synchronization
event removal for data race detection. In Proceedings of the
2011 IEEE 22Nd International Symposium on Software
Reliability Engineering , ISSRE ’11, pages 160–169,
Washington, DC, USA, 2011. IEEE Computer Society.
[21] G. Cugola, E. Di Nitto, and A. Fuggetta. The jedi
event-based infrastructure and its application to the
development of the opss wfms. Software Engineering, IEEE
Transactions on , 27(9):827–850, Sep 2001.
[22] A. Desai, V . Gupta, E. Jackson, S. Qadeer, S. Rajamani, and
D. Zufferey. P: Safe asynchronous event-drivenprogramming. In Proceedings of the 34th ACM SIGPLAN
Conference on Programming Language Design and
Implementation , PLDI ’13, pages 321–332, New York, NY ,
USA, 2013. ACM.
[23] D. Engler and K. Ashcraft. Racerx: effective, static detection
of race conditions and deadlocks. In ACM SIGOPS
Operating Systems Review , volume 37, pages 237–252.
ACM, 2003.
[24] P. T. Eugster, P. A. Felber, R. Guerraoui, and A.-M.
Kermarrec. The many faces of publish/subscribe. ACM
Comput. Surv. , 35(2):114–131, June 2003.
[25] C. Flanagan and S. N. Freund. Fasttrack: Efﬁcient and
precise dynamic race detection. In Proceedings of the 2009
ACM SIGPLAN Conference on Programming Language
Design and Implementation , PLDI ’09, pages 121–133, New
York, NY , USA, 2009. ACM.
[26] J. Garcia, D. Popescu, G. Saﬁ, W. G. J. Halfond, and
N. Medvidovic. Identifying message ﬂow in distributed
event-based systems. In Proceedings of the 2013 9th Joint
Meeting on Foundations of Software Engineering ,
ESEC/FSE 2013, pages 367–377, New York, NY , USA,
2013. ACM.
[27] M. J. Harrold, G. Rothermel, and S. Sinha. Computation of
interprocedural control dependence. In Proceedings of the
1998 ACM SIGSOFT International Symposium on Software
Testing and Analysis , ISSTA ’98, pages 11–20, New York,
NY , USA, 1998. ACM.
[28] M. Hauswirth and M. Jazayeri. A Component and
Communication Model for Push Systems. In ESEC/FSE .
Springer, 1999.
[29] C.-H. Hsiao, J. Yu, S. Narayanasamy, Z. Kong, C. L. Pereira,
G. A. Pokam, P. M. Chen, and J. Flinn. Race detection for
event-driven mobile applications. In Proceedings of the 35th
ACM SIGPLAN Conference on Programming Language
Design and Implementation , PLDI ’14, pages 326–336, New
York, NY , USA, 2014. ACM.
[30] I. Krka, Y . Brun, and N. Medvidovic. Automatic Mining of
Speciﬁcations from Invocation Traces and Method
Invariants. In Proceedings of the 22nd ACM SIGSOFT
Symposium on the Foundations of Software Engineering
(FSE14) , Hong Kong, China, November 2014.
[31] L. Lamport. Time, clocks, and the ordering of events in a
distributed system. Commun. ACM , 21(7):558–565, July
1978.
[32] T. D. LaToza and B. A. Myers. Developers Ask Reachability
Questions. In ICSE , 2010.
[33] O. Lhoták and L. Hendren. Scaling java points-to analysis
using spark. In Proceedings of the 12th International
Conference on Compiler Construction , CC’03, pages
153–169, Berlin, Heidelberg, 2003. Springer-Verlag.
[34] Y . Long, S. L. Mooney, T. Sondag, and H. Rajan. Implicit
invocation meets safe, implicit concurrency. In Proceedings
of the Ninth International Conference on Generative
Programming and Component Engineering , GPCE ’10,
pages 63–72, New York, NY , USA, 2010. ACM.
[35] P. Maiya, A. Kanade, and R. Majumdar. Race detection for
android applications. In Proceedings of the 35th ACM
SIGPLAN Conference on Programming Language Design
and Implementation , PLDI ’14, pages 316–325, New York,
NY , USA, 2014. ACM.
[36] S. Malek, N. Medvidovic, and M. Mikic-Rakic. An
extensible framework for improving a distributed software
36system’s deployment architecture. Software Engineering,
IEEE Transactions on , 38(1):73–100, Jan 2012.
[37] S. Malek, M. Mikic-Rakic, and N. Medvidovic. A
style-aware architectural middleware for
resource-constrained, distributed systems. IEEE Trans.
Softw. Eng. , 31(3):256–272, Mar. 2005.
[38] N. Medvidovic et al. The Role of Middleware in
Architecture-Based Software Development. Int. J. of Softw.
Eng. and Knowl. Eng. , 2003.
[39] N. Medvidovic, D. S. Rosenblum, and R. N. Taylor. A
language and environment for architecture-based software
development and evolution. In Proceedings of the 21st
International Conference on Software Engineering , ICSE
’99, pages 44–53, New York, NY , USA, 1999. ACM.
[40] G. Mühl. Large-Scale Content-Based Publish/Subscribe
Systems . PhD thesis, Darmstadt University of Technology,
2002.
[41] G. Mühl et al. Distributed Event-Based Systems .
Springer-Verlag New York, Inc., 2006.
[42] M. Naik, A. Aiken, and J. Whaley. Effective static race
detection for java. In Proceedings of the 2006 ACM
SIGPLAN Conference on Programming Language Design
and Implementation , PLDI ’06, pages 308–319, New York,
NY , USA, 2006. ACM.
[43] S. Narayanasamy, Z. Wang, J. Tigani, A. Edwards, and
B. Calder. Automatically classifying benign and harmful
data races using replay analysis. In Proceedings of the 2007
ACM SIGPLAN Conference on Programming Language
Design and Implementation , PLDI ’07, pages 22–31, New
York, NY , USA, 2007. ACM.
[44] R. O’Callahan and J.-D. Choi. Hybrid dynamic data race
detection. In Proceedings of the Ninth ACM SIGPLAN
Symposium on Principles and Practice of Parallel
Programming , PPoPP ’03, pages 167–178, New York, NY ,
USA, 2003. ACM.
[45] P. Oreizy, N. Medvidovic, and R. N. Taylor.
Architecture-based runtime software evolution. In
Proceedings of the 20th International Conference on
Software Engineering , ICSE ’98, pages 177–186,
Washington, DC, USA, 1998. IEEE Computer Society.
[46] R. Paleari, D. Marrone, D. Bruschi, and M. Monga. On race
vulnerabilities in web applications. In Detection of Intrusions
and Malware, and Vulnerability Assessment , pages 126–142.
Springer, 2008.
[47] B. Petrov, M. Vechev, M. Sridharan, and J. Dolby. Race
detection for web applications. In Proceedings of the 33rdACM SIGPLAN Conference on Programming Language
Design and Implementation , PLDI ’12, pages 251–262, New
York, NY , USA, 2012. ACM.
[48] P. Pratikakis, J. S. Foster, and M. Hicks. Locksmith:
Context-sensitive correlation analysis for race detection. In
Proceedings of the 2006 ACM SIGPLAN Conference on
Programming Language Design and Implementation , PLDI
’06, pages 320–331, New York, NY , USA, 2006. ACM.
[49] S. Qadeer and D. Wu. Kiss: keep it simple and sequential. In
ACM SIGPLAN Notices , volume 39, pages 14–24. ACM,
2004.
[50] V . Raychev, M. Vechev, and M. Sridharan. Effective race
detection for event-driven programs. In Proceedings of the
2013 ACM SIGPLAN International Conference on Object
Oriented Programming Systems Languages &#38;
Applications , OOPSLA ’13, pages 151–166, New York, NY ,
USA, 2013. ACM.
[51] S. Savage, M. Burrows, G. Nelson, P. Sobalvarro, and
T. Anderson. Eraser: A dynamic data race detector for
multithreaded programs. ACM Trans. Comput. Syst. ,
15(4):391–411, Nov. 1997.
[52] Y . Smaragdakis, J. Evans, C. Sadowski, J. Yi, and
C. Flanagan. Sound predictive race detection in polynomial
time. In Proceedings of the 39th Annual ACM
SIGPLAN-SIGACT Symposium on Principles of
Programming Languages , POPL ’12, pages 387–400, New
York, NY , USA, 2012. ACM.
[53] R. Taylor et al. A Component- and Message-Based
Architectural Style for GUI Software. IEEE TSE , 1996.
[54] R. N. Taylor, N. Medvidovic, K. M. Anderson, E. J.
Whitehead, Jr., and J. E. Robbins. A component- and
message-based architectural style for gui software. In
Proceedings of the 17th International Conference on
Software Engineering , ICSE ’95, pages 295–304, New York,
NY , USA, 1995. ACM.
[55] R. Vallée-Rai et al. Soot - a Java Bytecode Optimization
Framework. In Conference of the Centre for Advanced
Studies on Collaborative research , 1999.
[56] S. Yang, D. Yan, H. Wu, Y . Wang, and A. Rountev. Static
control-ﬂow analysis of user-driven callbacks in Android
applications. In International Conference on Software
Engineering , 2015.
[57] Y . Zheng and X. Zhang. Static detection of resource
contention problems in server-side scripts. In Proceedings of
the 34th International Conference on Software Engineering ,
ICSE ’12, pages 584–594, Piscataway, NJ, USA, 2012. IEEE
Press.
37