CARAMEL : Detecting and Fixing Performance
Problems That Have Non-Intrusive Fixes
Adrian Nistor1, Po-Chun Chang2, Cosmin Radoi3, Shan Lu4
1Chapman University,2University of Wisconsin–Madison,3University of Illinois, Urbana-Champaign,4University of Chicago
1anistor@chapman.edu,2pchang9@cs.wisc.edu,3cos@illinois.edu,4shanlu@cs.uchicago.edu
Abstract —Performance bugs are programming errors that slow
down program execution. While existing techniques can detect
various types of performance bugs, a crucial and practical aspect
of performance bugs has not received the attention it deserves:
how likely are developers to ﬁx a performance bug? In practice,
ﬁxing a performance bug can have both beneﬁts and drawbacks,
and developers ﬁx a performance bug only when the beneﬁts
outweigh the drawbacks. Unfortunately, for many performance
bugs, the beneﬁts and drawbacks are difﬁcult to assess accurately.
This paper presents C ARAMEL , a novel static technique that
detects and ﬁxes performance bugs that have non-intrusive
ﬁxes likely to be adopted by developers. Each performance
bug detected by C ARAMEL is associated with a loop and a
condition. When the condition becomes true during the loop
execution, all the remaining computation performed by the
loop is wasted. Developers typically ﬁx such performance bugs
because these bugs waste computation in loops and have non-
intrusive ﬁxes: when some condition becomes true dynamically,
just break out of the loop. Given a program, C ARAMEL detects
such bugs statically and gives developers a potential source-
level ﬁx for each bug. We evaluate C ARAMEL onreal-world
applications , including 11 popular Java applications (e.g., Groovy,
Log4J, Lucene, Struts, Tomcat, etc) and 4 widely used C/C++
applications (Chromium, GCC, Mozilla, and MySQL). C ARAMEL
ﬁnds 61 new performance bugs in the Java applications and 89
new performance bugs in the C/C++ applications. Based on our
bug reports, developers so far have ﬁxed 51 and 65 performance
bugs in the Java and C/C++ applications, respectively. Most of
the remaining bugs are still under consideration by developers.
I. INTRODUCTION
Software performance is critical for the success of a soft-
ware project. Performance bugs1are programming errors that
slow down program execution [7]. Performance bugs create
poor user experience, affect the user-perceived software qual-
ity, degrade application responsiveness, waste computational
resources, and lower system throughput [6], [39]. Even expert
programmers can introduce performance bugs, which have
already caused serious and highly publicized incidents [24],
[25], [38]. Well tested commercial products such as Internet
Explorer, Microsoft SQLServer, Visual Studio, and Acrobat
Reader are also affected by performance bugs [2], [37].
Several techniques [5], [11], [18], [20]–[22], [26], [43], [46],
[47], [50], [56], [58], [60]–[62] have been proposed to help
detect various types of performance bugs. However, there
1“Performance bug” is a well accepted term in some communities, e.g.,
Mozilla Bugzilla deﬁnes it as “A bug that affects speed or responsiveness” [7].
However, others believe “bug” requires speciﬁcations, and prefer to use the
terms “performance problem” or “performance issue”. We feel this is just a
naming issue and use the Mozilla Bugzilla term of “performance bug”.are still many performance bugs that cannot be detected by
existing techniques. Furthermore, a crucial and practical aspect
of performance bugs has not received the attention it deserves:
how likely are developers to ﬁx a detected performance bug?
In practice, when developers decide if they should ﬁx a
performance bug, developers face a difﬁcult choice between
the potential drawbacks and the potential beneﬁts of the ﬁx.
On one hand, similar to ﬁxing functional bugs, ﬁxing per-
formance bugs can have drawbacks. First, ﬁxing performance
bugs may introduce severe functional bugs, which may lead to
program crash or data loss. The risk of having such negative
and noticeable effects can make developers very cautious about
improving performance. Second, ﬁxing performance bugs may
break good software engineering practices, making the code
difﬁcult to read, maintain, and evolve. For example, ﬁxing
performance bugs may require breaking encapsulation, code
cloning, or specialization. Third, ﬁxing performance bugs
takes time and effort, especially if the ﬁx involves several soft-
ware modules or requires a complex implementation. Fourth,
ﬁxing performance bugs, which manifest for some inputs, may
slow down other code, for some other inputs, and developers
must decide which of these slowdowns—the slowdown caused
by the performance bug for some inputs, or the slowdown
caused by the ﬁx for some other inputs—is preferable.
On the other hand, ﬁxing performance bugs has beneﬁts,
i.e., it speeds up code. However, unlike ﬁxing functional bugs,
the beneﬁts of ﬁxing a performance bug are often difﬁcult to
assess accurately , especially when the ﬁx is complex. First,
the speedup offered by the ﬁx depends on the input, and
many inputs may not be sped up at all, because performance
bugs manifest only for certain inputs. Therefore, developers
need to estimate which inputs have which speedups, and how
frequent or important are these inputs in practice. Second, the
exact speedup offered by the ﬁx for an input is difﬁcult to
estimate without executing the code, and speedups of orders
of magnitude—i.e., speedups for which accurate estimates are
not necessary—are rare. Unfortunately, developers often have
access to only a few real-world inputs triggering a bug—or
none at all, if the bug was detected during development using
benchmarks, static tools, or code inspection—, and can ﬁnd it
difﬁcult to estimate the expected speedup for the rest of the
real-world inputs that may trigger the bug.
In practice, developers ﬁx performance bugs when the bene-
ﬁts outweigh the drawbacks. Speciﬁcally, developers are likelyto ﬁx performance bugs that have simple and non-intrusive
ﬁxes. Such ﬁxes are unlikely to introduce new functional bugs,
do not increase code complexity and maintenance costs, are
easy to understand and implement, and are unlikely to degrade
performance for other inputs. In other words, the choice
between beneﬁts and drawbacks is made easy for developers:
because the ﬁxes are simple and non-intrusive, ﬁxing the bugs
brings only beneﬁts.
This paper makes the following contributions:
Novel Perspective: Compared with previous work, this
paper has a unique perspective towards detecting performance
bugs: we focus on detecting bugs that are very likely to be ﬁxed
by developers . Following the above discussion, we propose
to detect performance bugs whose ﬁxes clearly offer more
beneﬁts than drawbacks to developers.
New Family of Performance Bugs: This paper identiﬁes a
family of performance bugs that developers are very likely to
ﬁx. Every bug in this family is associated with a loop2and a
condition. When the condition becomes true during the loop
execution, all the remaining computation performed by the
loop is wasted. In the extreme case when the condition is true
at the start of the loop execution, the entire loop computation
is wasted. Developers typically ﬁx performance bugs in this
family because (1) these performance bugs waste computation
in loops, and (2) these performance bugs have simple and non-
intrusive ﬁxes: when some condition becomes true, just break
out of the loop. Typically, these bugs are ﬁxed by adding one
line of code inside the loop, i.e., if (cond) break , which
we call a CondBreak ﬁx . We call cond aL-Break condition .
Important Performance Bugs: The performance bugs in
this family are important: developers of real-world applications
typically ﬁx these bugs. Developers are the ultimate arbiters
for what is useful and what is not useful for their project,
and developers typically think these bugs must be addressed.
Furthermore, these bugs are not all the performance bugs that
have non-intrusive ﬁxes, and our work is a promising ﬁrst step
in this important research direction.
Technique: This paper proposes C ARAMEL , a novel static
technique for detecting performance bugs that have Cond-
Break ﬁxes. C ARAMEL takes as input a program and outputs
loops that can be ﬁxed by CondBreak ﬁxes, together with
a potential ﬁx for each buggy loop. The ﬁxes proposed by
CARAMEL can be directly applied to source-code and are
easy to read by developers. C ARAMEL works on intermediate
code representation and analyzes each loop in ﬁve steps. First,
CARAMEL identiﬁes the loop instructions that may produce
results visible after the loop terminates. Second, for each
such instruction, C ARAMEL detects the condition under which
the instruction can be skipped for the remainder of the loop
without changing the program outcome. We call this condi-
tion an I-Break condition , similarly to the L-Break condition
described earlier for the entire loop. Third, C ARAMEL checks
if all instructions from step two can be skipped simultaneously
without changing the program outcome, i.e., if all I-Break
2We focus on loops because most computation time is spent inside loops
and most performance bugs involve loops [19], [23], [45], [56], [61].conditions can be satisﬁed simultaneously. The conjunction
of all I-Break conditions is the L-Break condition. Fourth,
CARAMEL checks if the computation waste in the loop is not
already avoided, i.e., if the loop does not already terminate
when the L-Break condition is satisﬁed. If all the previous
steps are successful, C ARAMEL reports a performance bug.
Fifth, C ARAMEL generates a ﬁx for the performance bug. The
ﬁx has the basic format if (cond) break , where cond is
the L-Break condition C ARAMEL computed in the third step.
Automatic Fix Generation: Automated bug ﬁxing is chal-
lenging in general [30], but C ARAMEL is able to automatically
generate ﬁxes for most bugs because C ARAMEL takes advan-
tage of two characteristics of the performance bugs it detects:
(1) the bugs have CondBreak ﬁxes, which can be inserted right
at the start of the loop, thus avoiding complex interactions with
other loop code, and (2) the L-Break condition in a CondBreak
ﬁx is a relatively simple boolean expression (Sections II, III).
Evaluation: Our main measure of success for C ARAMEL
is if real-world developers think the bugs found by C ARAMEL
are important, as quantiﬁed by the number of bugs ﬁxed. We
implement twoCARAMEL tools, one for Java, C ARAMEL -J,
and one for C/C++, C ARAMEL -C. We evaluate C ARAMEL -
J on 11 popular Java applications: Ant, Groovy, JMeter,
Log4J, Lucene, PDFBox, Sling, Solr, Struts, Tika, and Tomcat.
CARAMEL -J found 61 new real-world performance bugs of
which 51 bugs have already been ﬁxed by developers . We
evaluate C ARAMEL -C on 4 widely used C/C++ desktop and
server applications: Chromium, GCC, Mozilla, and MySQL.
CARAMEL -C found 89 new real-world performance bugs of
which 65 bugs have already been ﬁxed by developers . Of the
bugs not yet ﬁxed, 7 bugs are conﬁrmed and still under consid-
eration by developers and 16 bugs are still open. 7 bugs were
not ﬁxed because they are in deprecated code, old code, test
code, or auxiliary projects. Only 4 bugs were not ﬁxed because
developers considered that the bugs have small performance
impact or that the ﬁxes make code more difﬁcult to read.
CARAMEL has few false positives, 19 for C ARAMEL -J and
4 for C ARAMEL -C. Out of 150 bugs, C ARAMEL successfully
generates ﬁxes for 149 bugs.
II. W HATPERFORMANCE BUGS HAVECONDBREAK FIXES ?
We discuss below two bug characteristics that help un-
derstand what performance bugs have CondBreak ﬁxes. We
callresult instruction (RI) a loop instruction that may write
to variables live and memory reachable after the loop. RIs
are important in understanding performance bugs that have
CondBreak ﬁxes. For example, if all RIs in a loop do not
(need to) execute under a certain condition, the entire loop,
including all non-RIs, can be skipped.
(A) Where the Computation Is Wasted: A loop-related
performance bug can waste computation either in an entire
iteration or in parts of an iteration, in consecutive or arbitrary
iterations, in iterations at the start, end, or middle of the loop.
Such a bug can have a CondBreak ﬁx (i.e., break out of the
loop under a certain condition) if it wastes computation in
the entire iteration in one of the following three locations:
2(1) for every iteration in the loop, short as Every , (2) for every
iteration at the end of the loop, short as Late, or (3) for every
iteration at the start of the loop, short as Early . Bugs that waste
computation in category Every can be ﬁxed by breaking out
of the loop if the L-Break condition is satisﬁed at the loop
entrance, effectively skipping the entire loop. Bugs that waste
computation in category Late can be ﬁxed by breaking out of
the loop once the computation waste starts. Bugs that waste
computation in category Early can be ﬁxed by iterating from
the end of the loop and breaking out of the loop once the
computation waste starts. Bugs that waste computation only
in parts of an iteration or only in speciﬁc iterations cannot be
ﬁxed by CondBreak ﬁxes and are not the focus of C ARAMEL .
(B) How the Computation Is Wasted: In order for the
computation of an entire iteration to be wasted under a certain
condition, i.e., the L-Break condition, every RI in that iteration
has to fall into one of following three cases: (1) the RI is
not executed under the L-Break condition, short as No-Result ,
(2) the RI is executed, but, under the L-Break condition, its
result does not change the values used by computation after the
loop, short as Useless-Result , or (3) the RI is executed and its
result changes the values used by computation after the loop,
but, under the L-Break condition, this result does not affect
the perceived outcome of the program, short as Semantically-
Useless-Result . Identifying Semantically-Useless-Result RIs
usually requires developers’ expert knowledge, and the L-
Break conditions are likely difﬁcult to express in source-code.
CARAMEL focuses on No-Result and Useless-Result RIs.
Based on the above discussion, a loop can have a per-
formance bug ﬁxed by a CondBreak ﬁx if allRIs in the
loop belong to one of the six types shown in Figure 1. Note
that the three computation-waste locations in (A) effectively
describe which instances of an RI can be skipped in the
loop. We describe individual RIs of Types 1–4, i.e., the types
CARAMEL focuses on, in Sections II-A–II-D, and we present
how multiple RIs appear in the same bug in Section II-F. We
brieﬂy discuss Type X and Type Y in Section II-E.
Every Late Early
No-Result Type 1 Type 2 Type Y
Useless-Result Type X Type 3 Type 4
Fig. 1. Types of RIs
The bugs in the following examples are previously unknown
real-world performance bugs found by C ARAMEL . We re-
ported them to developers and the developers ﬁxed all of them.
A. Type 1 RIs
Figure 2 shows a performance bug from Groovy containing
a Type 1 RI. Line 3 is the ﬁx and it is notpart of the
original buggy code. The only RI in this loop is return
true (line 7), which writes the method’s return value and
also causes the code after the loop to not execute. When
argTypes is initialized to a non-empty array, the RI cannot
execute throughout the loop, the entire loop computation is
wasted, and the loop can just be skipped. The reason is that
argTypes is never modiﬁed inside the loop. When argTypes
is initialized to a non-empty array, both argTypes == nullandargTypes.length == 0 (line 5) are false throughout
the loop, which makes isZeroArg false, which makes match
(line 6) false, which in turn means the RI cannot execute.
1Class[] argTypes = ...
2for(Iterator i = methods.iterator(); i.hasNext();) f
3+ if (!(argTypes == null) && !(argTypes.length == 0)) break ; // FIX
4MethodNode mn = (MethodNode) i.next();
5boolean isZeroArg = (argTypes == null jjargTypes.length == 0);
6boolean match =mn.getName().equals(methodName) && isZeroArg;
7if(match) return true ;//RI
8g
Fig. 2. Type 1 RI in a Groovy performance bug
This RI is of Type 1 because, if the I-Break condition is
true at the start of the loop, the RI is not executed (category
No-Result) in any iteration of the entire loop (category Every).
The I-Break condition for the RI is that both argTypes ==
null andargTypes.length == 0 are false. The L-Break
condition is the same as the I-Break condition because there
is only one RI. The CondBreak ﬁx is the code added in line 3
(the+at the start of line 3 means the line is added), i.e., the
loop breaks when the L-Break condition is true. We discuss
ﬁxes equivalent to the CondBreak ﬁx in Section III-E.
B. Type 2 RIs
Figure 3 shows a performance bug from PDFBox containing
a Type 2 RI. There are three loops in this code and two RIs, as
shown in the ﬁgure. RI 1 is an RI for all three loops because
it writes alreadyPresent , which is live at the end of all
three loops. Similarly, RI 2 is an RI for loops 1 and 2. The
“...” in the ﬁgure replace some complicated control ﬂow and
method calls, which we skip for clarity. The “ ...” contain no
RIs. In this section, we focus our discussion on RI 2 because
RI 1 is of Type 3, which we will discuss in the next section.
Loop 3 does not have a bug, which we will further explain
in Section III-D. Loops 1 and 2 are both buggy, as explained
next for loop 1. Similar reasoning applies for loop 2.
1boolean alreadyPresent = false;
2while (itActualEmbeddedProperties.hasNext()) f//Loop 1
3+ if (alreadyPresent) break ; // FIX
4...//non-RIs
5 while (itNewValues.hasNext()) f//Loop 2
6 ...//non-RIs
7 while (itOldValues.hasNext() && !alreadyPresent) f//Loop 3
8 oldVal = (TextType) itOldValues.next();
9 if(oldVal.getStringValue().equals(newVal.getStringValue())) f
10 alreadyPresent = true;//RI 1
11 gg
12 if(!alreadyPresent) f
13 embeddedProp.getContainer().addProperty(newVal); //RI 2
14ggggg
Fig. 3. Type 2 RI in a PDFBox performance bug
For the ﬁrst few loop 1 iterations, alreadyPresent is
false, the condition on line 12 evaluates to true, and RI 2
executes and performs useful computation. However, once
alreadyPresent is set to true on line 10, the condition on
line 12 remains false for the remainder of the loop, and all the
remaining computation in the loop can just be skipped. The
reason is that the entire loop cannot assign alreadyPresent
to false. Consequently, once alreadyPresent becomes true
on line 10, it remains true and disables the execution of RI 2
for the remainder of the loop.
RI 2 is of Type 2 because, once the I-Break condition
becomes true, RI 2 is not executed (category No-Result) for
3the remaining loop iterations (category Late). The I-Break
condition for RI 2 is that alreadyPresent equals true. We
will explain in the next section that the I-Break condition for
RI 1 is also that alreadyPresent equals true. The L-Break
condition is the conjunction of the two I-Break conditions,
i.e.,alreadyPresent equals true. The CondBreak ﬁx is the
code added in line 3, i.e., the loop breaks when the L-Break
condition is true.
C. Type 3 RIs
Figure 4(a) shows a performance bug from Tomcat contain-
ing two Type 3 RIs, RI 1 and RI 2. Both RIs set variable elExp
to true. Once either RI is executed, the remaining computation
in the loop is unnecessary, at best setting elExp to true again.
1boolean elExp = ...
2while (nodes.hasNext()) f
3+ if (elExp) break ; // FIX
4ELNode node = nodes.next();
5if(node instanceof ELNode.Root) f
6 if(((ELNode.Root) node).getType() == ' $')f
7 elExp = true;//RI 1
8 gelse if (checkDeferred && ((ELNode.Root) node).getType()=='#'
9 && !pageInfo.isDeferredSyntaxAllowedAsLiteral() ) f
10 elExp = true;//RI 2
11ggg
(a) A Type 3 RI in a Tomcat performance bug
1valid &= child.validate(); //RI
(b) Type 3 RI in a Sling performance bug
Fig. 4. Type 3 RIs
RI 1 is of Type 3 because, once the I-Break condition be-
comes true, RI 1’s results for the remaining iterations (category
Late) do not change the values used by future computation
(category Useless-Result). Similar reasoning applies for RI 2.
The I-Break condition for RI 1 is that elExp equals true. RI 2
has the same I-Break condition. The L-Break condition is the
conjunction of the two I-Break conditions, i.e., elExp equals
true. The CondBreak ﬁx is the code on line 3, i.e., the loop
breaks when the L-Break condition is true.
Note that, for RI 1 and RI 2 to be of Type 3, elExp can have
any type, not necessarily boolean, as long as elExp is assigned
a constant. In fact, even if elExp is not assigned a constant,
there is still an alternative way to set elExp to a value that
does not change after some time, as shown in Figure 4(b). In
Figure 4(b), once valid is set to false, the semantics of the &=
operator ensures valid remains false. The I-Break condition
is that valid equals false.
D. Type 4 RIs
Figure 5(a) shows a performance bug from JMeter contain-
ing a Type 4 RI (line 6). The variable length keeps getting
overwritten by the RI. Consequently, all iterations before the
last iteration that writes length are wasted. The reason is
that computation after the loop will only see the last value
written to length . This last value does not depend on previous
iterations, except for the value of idx, which can be computed
when iterating from the end of the loop.
The RI is of Type 4 because its results for early iterations
(category Early) do not affect the values used by future com-
putations (category Useless-Result). The I-Break condition for
the RI is that length has been written in the loop when1intlength = ...
2for(intidx = 0; idx <headerSize; idx++) f
3@ for (intidx = headerSize - 1; idx >= 0; idx{ {) f//FIX
4Header hd = mngr.getHeader(idx);
5if(HTTPConstants.HEADER.equalsIgnoreCase(hd.getName())) f
6 length = Integer.parseInt(hd.getValue()); //RI
7+ break ; // FIX
8gg
(a) Bug and Alternative ﬁx
1intlength = ...
2+ boolean wasExecuted = false; // FIX
3for(intidx = 0; idx <headerSize; idx++) f
4@ for (intidx = headerSize - 1; idx >= 0; idx{ {) f//FIX
5+ if (wasExecuted) break ; // FIX
6Header hd = mngr.getHeader(idx);
7if(HTTPConstants.HEADER.equalsIgnoreCase(hd.getName())) f
8+ if (!wasExecuted) f//FIX
9+ wasExecuted = true; // FIX
10 length = Integer.parseInt(hd.getValue()); //RI
11+g//FIX
12gg
(b)CondBreak ﬁx
Fig. 5. Type 4 RI in a JMeter performance bug. The ﬁx in 5(a) is an
Alternative ﬁx. The CondBreak ﬁx is in 5(b).
iterating from the end of the loop. The L-Break condition is the
same as the I-Break condition because there is only one RI. For
clarity, the CondBreak ﬁx is shown separately, in Figure 5(b).
This ﬁx looks complex because we want to make the L-Break
condition (i.e., wasExecuted equals true) explicit in the code.
Differently from the Type 3 RI in Figure 4(a), the RI in this
example does not set length to a constant. Therefore, we have
to create an extra variable wasExecuted (lines 2, 5, 8, 9, 11)
to track whether length has been written. Figure 5(a) shows
a simpler, alternative ﬁx, that does not use wasExecuted . In
the alternative ﬁx, the reversed loop breaks the ﬁrst time when
the RI is executed (line7). The simpler, alternative ﬁx comes at
a price: it is correct only when the loop has one RI. Otherwise,
breaking out of the loop after one RI would incorrectly miss
the execution of remaining RIs.
E. Type X and Type Y RIs
A Type X instruction would be similar to RI 1 and RI 2
in Figure 4(a) if the value of elExp would be a constant true
before the loop started. In practice, C ARAMEL never found
such RIs. A Type Y RI cannot write to the same memory
locations in different loop iterations. Checking that all dynamic
instances of the same static instruction can only write to
disjoint memory locations requires complex static analysis,
and C ARAMEL does not perform such checks.
F . Bugs with Multiple RIs
A buggy loop can contain multiple RIs of the same or
different types. The only constraint is that a Type 4 RI cannot
co-exist with Type 2 or Type 3 RIs because the former requires
the bug ﬁx to skip iterations at the start of the loop and the
latter requires the bug ﬁx to skip iterations at the end of the
loop. In practice, we did not encounter Type 1 RIs co-existing
with other types of RIs. Some RIs can be of multiple types,
as shown next for RI 3 and RI 9. The L-Break condition is
the conjunction of all RIs’ I-Break conditions.
Figure 6 shows an example bug with multiple RIs from
PDFBox. Unlike the bugs in Figure 3 and Figure 4(a), this bug
has nine RIs that have different I-Break conditions. RI 1 and
4RI 2 are Type 2 RIs because once annotNotFound is set to
false (line 9), annotNotFound cannot become true again and
the condition on line 6 evaluates to false in the remaining loop
iterations. Similar reasoning applies for RI 4–8, sigField-
NotFound (line 14), and the condition on line 11. RI 3 and
RI 9 are simultaneously Type 2 (similarly to RI 1–2 and RI 4–
8, respectively) and Type 3. The I-Break conditions for RI 1–3
and RI 4–9 are annotNotFound equals false and sigField-
NotFound equals false, respectively. The L-Break condition
is the conjunction of all nine I-Break conditions, i.e., both
annotNotFound andsigFieldNotFound equal false.
1boolean annotNotFound = ...
2boolean sigFieldNotFound = ...
3for( COSObject cosObject : cosObjects ) f
4+ if (!annotNotFound && !sigFieldNotFound) break ; // FIX
5...// some non  RIs
6if(annotNotFound && COSName.ANNOT.equals(type)) f
7 ...//RI 1 and some non-RIs
8 signatureField.getWidget().setRectangle(rect); //RI 2
9 annotNotFound = false;//RI 3
10 g
11 if(sigFieldNotFound && COSName.SIG.equals(ft)&&apDict!= null)f
12 ...//RI 4, RI 5, RI 6, RI 7 and some non-RIs
13 acroFormDict.setItem(COSName.DR, dr); //RI 8
14 sigFieldNotFound= false;//RI 9
15gg
Fig. 6. Multiple RIs in a PDFBox performance bug
III. D ETECTING AND FIXING PERFORMANCE BUGS THAT
HAVECONDBREAK FIXES
We next present the high-level C ARAMEL algorithm (Sec-
tion III-A) and the algorithm steps (Sections III-B–III-E).
A. High-Level Algorithm
Figure 7 shows the high-level algorithm for C ARAMEL .
CARAMEL is a static technique that works on intermediate
code representation (IR). C ARAMEL receives as input the loop
to analyze and various information to help the static analysis,
e.g., the control ﬂow graph for the method containing the loop,
pointer aliasing information, and a call graph.
1void detectPerformanceBug(Loop l, Method m, AliasInfo alias) f
2SethInstruction iallRIs = getRIs(l, m, alias);
3SethCondition iallCond = new SethCondition i();
4for(Instruction r : allRIs) f
5 Condition one = typeOne(r, l, m, alias);
6 Condition two = typeTwo(r, l, m, alias);
7 Condition three = typeThree(r, l, m, alias);
8 Condition four = typeFour(r, l, m, alias, allRIs.size());
9 if(one.false()&&two.false()&&three.false()&&four.false()) return ;
10 allCond.putIfNotFalse(one, two, three, four);
11 g
12 if(satisedTogether(allCond) && notAlreadyAvoided(allCond, l)) f
13 String x = generateFix(allCond, l, m);
14 reportBugAndFix(x, allRIs, allCond);
15gg
Fig. 7. C ARAMEL high-level algorithm
CARAMEL works in ﬁve steps. First, C ARAMEL computes
the loop RIs using routine static analysis (line 2). Second,
for each RI r, CARAMEL checks if rbelongs to one of the
four types presented in Section II and computes r’s I-Break
condition accordingly (lines 4–10). If rdoes not belong to any
of the four types, all the conditions computed on lines 5–8 are
false and therefore the loop does not have a bug (line 9). If r
is of one of the four types, C ARAMEL saves for further use
r’s I-Break condition (line 10). Third, C ARAMEL checks if
all RIs can be skipped simultaneously without changing theprogram outcome, i.e., if the I-Break conditions for individual
RIs can be satisﬁed simultaneously (line 12). The conjunction
of the I-Break conditions is the L-Break condition. Fourth,
CARAMEL checks if the computation waste in the loop is not
already avoided, i.e., if the loop does not already terminate
when the L-Break condition is satisﬁed (line 12). Fifth, using
the L-Break condition, C ARAMEL generates a ﬁx (line 13) and
reports the bug (line 14). The bug report contains the ﬁx, and,
for each RI, the RI type and I-Break condition.
The above algorithm enables C ARAMEL to detect and ﬁx
performance bugs that involve multiple RIs, either of the same
or different types, similar to the bugs in Figures 3, 4(a), and 6.
This is because, after step two, C ARAMEL works only with a
collection of conditions, and C ARAMEL is not concerned with
how these conditions were obtained in step two.
Preliminary: Boolean Expressions: To compute the I-Break
conditions and the L-Break condition, C ARAMEL reasons
about boolean expressions. C ARAMEL represents and reasons
about a boolean expression as one or multiple Atoms connected
by boolean operators ( NOT,AND,OR). An Atom refers to
either a boolean variable or a boolean expression containing
non-boolean operators. Atoms do not contain other Atoms.
For example, an Atom could be a method call returning a
boolean value or a comparison between two integers. To keep
complexity low and scale, C ARAMEL does not reason about
operations inside Atoms. An Atom can be either true or false
butnotboth simultaneously.
For space limitations, we do not go into the details of how
CARAMEL works with boolean expressions, and we give only
a high-level overview for two techniques used by C ARAMEL .
These two techniques can be substituted by more sophisti-
cated techniques, such as symbolic execution. However, for
CARAMEL ’s purposes, these two techniques offer good results
at considerably reduced complexity. Technique T-PathExec
computes the execution condition of a loop instruction as the
disjunction of all path constraints that correspond to the acyclic
execution paths leading from the loop header to the instruction.
A path constraint is the conjunction of all branch conditions,
represented by Atoms and negated when necessary, along a
path. C ARAMEL uses T-PathExec in steps two and four of the
CARAMEL algorithm. Technique T-Instantiation computes,
for a boolean expression E(in DNF form) and some Atoms
set, the values of the setAtoms for which Eis guaranteed
false or true. Conversely, T-Instantiation determines if Emay
be true or false, irrespective of Atoms in set. T-Instantiation
tries all possible combinations of values for the setAtoms and
uses logic rules such as “False ANDUnknown equals False” to
determine the value of E. For example, for E = $Atom1 AND
$Atom2 andset = f$Atom1 g, T-Instantiation determines that,
when $Atom1 equals true, Eis Unknown, and, when $Atom1
equals false, Eis false. In the usage context of C ARAMEL ,
sethas few Atoms (e.g., when identifying Type 1 RIs, set
contains the loop-invariant Atoms in E, which is rarely more
than 3), and therefore T-Instantiation rarely tries more than
8 combinations. C ARAMEL uses T-Instantiation in steps two,
three, and four of the C ARAMEL algorithm.
5B. Detecting the Four RI Types
In the second step of the C ARAMEL algorithm, C ARAMEL
determines if a given RI (all RIs are known from step one)
belongs to one of the four types and, if so, the RI’s I-Break
condition. We describe here each type and the algorithm C AR-
AMEL uses to detect it. Identifying all RIs that belong to each
type would require complicated and non-scalable analysis. At
the same time, not all RIs that belong to each type are common
and have I-Break conditions that are easy to express in source-
code. C ARAMEL focuses on RIs whose type can be identiﬁed
using scalable analysis and whose I-Break conditions are easy
to express in source-code. C ARAMEL can miss some RIs that
belong to these four types, as explained below.
Type 1: An RI ris of Type 1 if there exists a condition
Csuch that rcannot execute throughout the loop if Cis true
when the loop starts. The I-Break condition for risC. To judge
whether rbelongs to Type 1, C ARAMEL searches for r’s I-
Break condition. Theoretically , the I-Break condition could
be composed of any variables and expressions that appear or
do not appear in the entire program. However, inferring or
searching for such generic I-Break conditions is difﬁcult. In
practice , CARAMEL considers only I-Break conditions that
(1) can be computed by analyzing the potential execution
paths that may reach rfrom the loop header and (2) are
composed of Atoms that can be proved to be loop-invariant
based on control and data-ﬂow analysis. Constraint (1) makes
detecting candidate I-Break conditions feasible and scalable,
while constraint (2) makes it easy to prove that a candidate
I-Break condition cannot change its value throughout the
loop execution. Additionally, constraint (1) ensures the I-
Break condition is easy to express in source-code, because
the candidate I-Break conditions contain only variables and
expressions already present in the loop.
The C ARAMEL algorithm uses T-PathExec to compute the
execution condition rExecCond forr, gets the loop-invariant
Atoms in rExecCond , uses T-Instantiation to get these Atoms’
values for which rExecCond is guaranteed to be false irrespec-
tive of the values of other Atoms in rExecCond , and constructs
r’s I-Break condition based on these Atom values.
Type 2: An RI ris of Type 2 if there exists a condition
Csuch that rcannot execute once Cbecomes true during the
loop execution. The I-Break condition for risC. Detecting
Type 2 and Type 1 RIs are similar and have similar challenges.
CARAMEL applies similar constraints when searching for r’s
I-Break condition, with only one difference for constraint (2).
For Type 2 checking, C ARAMEL only considers Atoms that
are assigned one constant in the loop. This constraint makes it
easy to prove that a candidate I-Break condition cannot change
its value after all its component Atoms are updated in the loop.
The C ARAMEL algorithm for detecting Type 2 RIs is
similar to the algorithm for detecting Type 1 RIs, with
two modiﬁcations. First, instead of identifying loop-invariant
Atoms in rExecCond , the Type 2 algorithm detects Atoms
inrExecCond that are assigned only one boolean constant
value in the loop. Second, when C ARAMEL computes theAtoms’ values for which rExecCond is guaranteed to be false,
CARAMEL takes into account that the Atoms identiﬁed above
can take only the corresponding constant values.
Type 3: An RI ris of Type 3 if, after a certain loop iteration,
rcan only write to the same output locations it wrote in
previous iterations and the values written are identical to the
existing values in these locations; we call these existing values
S. The I-Break condition is that the output locations contain
S. To judge whether rbelongs to Type 3, C ARAMEL exam-
ines r’s output locations and output values. Theoretically ,r
could be any instruction, including a call to a method with
complex control ﬂow that writes to many memory locations.
Reasoning about such a general ris difﬁcult. In practice ,
CARAMEL focuses only on RIs that (1) have a single output
location, (2) either write a constant (similar to Figure 4(a))
or perform the &=or|=operations (similar to Figure 4(b)),
which effectively correspond to Sbeing constants false or true,
respectively, and (3) have an output location that is not written
to in the loop with other values except S. Constraint (1) makes
it easy to detect rdoes not change its output locations, while
constraints (2) and (3) make it easy to prove that, after a certain
loop iteration, rcan only write S. Additionally, constraint (2)
ensures the I-Break condition is easy to express in source-code,
because Scan be identiﬁed statically.
The C ARAMEL algorithm uses straightforward static analy-
sis to implement the above checks.
Type 4: An RI ris of Type 4 if routputs values independent
of computation in early iterations, except for the loop index
computation, and if rcannot change its output locations. The
I-Break condition is that the values in the output locations
have been updated the ﬁrst time when iterating from the
end of the loop. To judge whether rbelongs to Type 4,
CARAMEL examines r’s output locations and output values.
Theoretically ,rcould be any instruction, including a method
call, and checking the above conditions for such a general r
is difﬁcult. In practice , CARAMEL focuses only on RIs that
(1) have a single output location, (2) appear in loops that have
no cross-iteration data dependency, except for the loop index
computation, and (3) appear in loops that have only one RI.
Constraint (1) makes it easy to detect that rdoes not change
its output locations and constraint (2) makes it easy to prove
that the output values are independent of computation in earlier
iterations. Additionally, constraint (3) ensures the ﬁx is similar
to the alternative ﬁx in Figure 5(a), instead of the CondBreak
ﬁx in Figure 5(b).
The C ARAMEL algorithm checks if the loop has one RI
and if no instruction in the loop body writes to memory or
variables live between iterations, except for the loop index.
C. Checking Whether RIs can be Skipped Simultaneously
In the third step of the C ARAMEL algorithm, C ARAMEL
checks if a scenario exists for which all RIs can be simultane-
ously skipped without changing the program outcome, i.e., all
RIs’ I-Break conditions can be satisﬁed simultaneously. The
L-Break condition enabling this scenario is the conjunction of
all I-Break conditions.
6Figure 8 gives a simpliﬁed example from Lucene of why
CARAMEL performs this check. The two RIs in this loop are
of Type 1 and have I-Break conditions roundNum < 0 equals
true and roundNum < 0 equals false, respectively. However,
this loop does not contain a performance bug because the
executions of the two RIs cannot be skipped simultaneously ,
i.e.,roundNum < 0 cannot simultaneously be true and false.
1introundNum = ...
2StringBuilder sb = ...;
3for(nal String name : colForValByRound.keySet()) f
4if(roundNum <0)f
5 sb.append(Format.formatPaddLeft("  ", template)); //RI 1
6gelse f
7 sb.append(Format.format(ai[n], template)); //RI 2
8gg
Fig. 8. Simpliﬁed code from Lucene. The RIs are of Type 1, but these RIs
do not create a performance bug.
To perform this check, C ARAMEL applies T-Instantiation
on the conjunction of selected I-Break conditions, effectively
checking there exists at least one combination of the involved
Atoms’ values that makes the conjunction true. C ARAMEL
optimizes this check by applying it on selected, instead of all
I-Break conditions, because the deﬁnitions of some RI types
already guarantee that their corresponding I-Break conditions
will never conﬂict with each other. For example, the I-Break
condition for a Type 3 RI cannot conﬂict with the I-Break
condition for a Type 1 RI. The reason is that the Atoms in the
I-Break condition of a Type 1 RI must be loop-invariant and
therefore cannot appear in a Type 3 RI’s I-Break condition.
D. Checking the Computation Waste is Not Already Avoided
In the fourth step of the C ARAMEL algorithm, C ARAMEL
checks the execution is not already exiting the loop when the
L-Break condition is true. Loop 3 in Figure 3 (lines 7–11)
is an example of why C ARAMEL performs this check. As
mentioned in Section II-B, loop 3 does not have a performance
bug and we now explain why. The only RI in loop 3 is RI 1
(line 10), which is of Type 3 and therefore it may seem loop 3
performs useless computation once alreadyPresent is set
to true. However, once alreadyPresent becomes true, the
loop exits ( !alreadyPresent , line 7), and therefore the loop
does not have a performance bug. C ARAMEL performs this
check using T-PathExec, which is used to detect the execution
condition for loop exits, and T-Instantiation, which is used to
detect if the paths to loop exits may be taken in the original
code when the L-Break condition is true.
E. Automatic Fix Generation
In the ﬁfth step of the C ARAMEL algorithm, C ARAMEL
generates source-code ﬁxes. Automatic bug ﬁxing is a difﬁcult
problem in general, but it is feasible for C ARAMEL because
CARAMEL focuses on bugs that have CondBreak ﬁxes.
CARAMEL generates ﬁxes in two steps. First, C ARAMEL
generates a source-code level L-Break condition composed of
source-code level variables declared and initialized outside of
the loop. Because the variable and method names are available
at the IR level, this process is straightforward in general. The
only challenge is that some Atoms in the L-Break condition
may involve variables that are not suitable for the ﬁnalsource-code ﬁx. Speciﬁcally, some variables are introduced by
compiler in the IR representation and do not exist in the source-
code, while some other variables are declared or initialized
inside the loop by developers and therefore cannot be used in
the ﬁx at the start of the loop. The solution is straightforward:
CARAMEL repetitively replaces these unsuitable variables with
their assigned expression. This step guarantees not to change
the value of the L-Break condition because of the way the
I-Break conditions are deﬁned in Section III-B.
Second, C ARAMEL formats the ﬁx according to the types
of the RIs, and computes the line number where the ﬁx is
to be inserted using line number information from the inter-
mediate source code representation. When the loop contains
RIs of Type 1, 2, or 3, the ﬁx simply inserts if (L-Break
condition) break after the loop header, as shown in the
Section II examples. In the special case when the loop contains
only Type 1 RIs, the ﬁx is if (L-Break condition ==
false) theLoop , effectively executing the loop only when
the L-Break condition is false. This alternative ﬁx is equivalent
with the CondBreak ﬁx, but is preferred by developers. When
the loop contains a Type 4 RI, C ARAMEL reverses the loop if
the loop has an integer index variable that is incremented by
one in the loop header, similar to that in Figure 5(a); otherwise,
CARAMEL reports ﬁx generation failure. General loop reversal
is difﬁcult to do automatically, but treating the above case was
enough to ﬁx the bugs we encountered in practice. C ARAMEL
can handle more cases for loop reversal in the future.
F . False Positives, False Negatives, and Incorrect Fixes
CARAMEL can have false positives, false negatives, and
can generate incorrect ﬁxes, though in practice these issues
were not signiﬁcant (Section V). These issues are typically
created by unsoundness or incompleteness in the underlying
static analysis framework. We discuss sources of false positive
in Section V-B. C ARAMEL can have false negatives because,
due to unsoundness in the static analysis, C ARAMEL can label
non-RI instructions as RI, and the spurious RIs can make
unnecessary loop computation look useful. In practice this was
not a major problem, as C ARAMEL found 150 new bugs in
15 widely used Java and C/C++ applications. Theoretically,
CARAMEL can generate an incorrect ﬁx for a real bug because,
due to incompleteness in the static analysis (Section V-B),
CARAMEL may not detect some RIs. If this happens, the L-
Break condition does not contain all the I-Break conditions
and the ﬁx causes the execution to exit the loop too early. In
practice C ARAMEL did not generate any incorrect ﬁx.
IV. T WOIMPLEMENTATIONS
We implement two CARAMEL tools, for both Java and
C/C++ programs, which we call C ARAMEL -J and C ARAMEL -
C, respectively. We implement C ARAMEL -J and C ARAMEL -
C using WALA [1] and LLVM [29] static analysis frame-
works, respectively. Implementing the high-level algorithms
in Section III-B takes into account the fact that the IRs
provided by WALA and LLVM are in SSA form. C ARAMEL -
J uses the pointer aliasing information provided by WALA.
7CARAMEL -C conservatively assumes that every write to heap
is an RI. The analysis in both C ARAMEL -J and C ARAMEL -
C is inter-procedural. The implementation closely follows
the presentation in the previous section. The only exception
is that C ARAMEL -C currently detects only bugs that have
one RI, and therefore C ARAMEL -C does not perform step
three in the C ARAMEL algorithm. We do not discuss further
implementation details due to space limitations.
V. E VALUATION
We evaluate C ARAMEL onreal-world applications from
Java and C/C++ using our two C ARAMEL implementations,
CARAMEL -J and C ARAMEL -C, respectively. We use 11 pop-
ular Java applications (Ant, Groovy, JMeter, Log4J, Lucene,
PDFBox, Sling, Solr, Struts, Tika, and Tomcat) and 4 widely
used C/C++ desktop and server applications (Chromium, GCC,
Mozilla, and MySQL). Figure 9 gives a short description of
these applications. We analyze the latest code versions of
these applications, except for Lucene, for which we use a
slightly older version, because C ARAMEL does not support
Java 7. Of all the Lucene bugs found by C ARAMEL , only two
bugs are in code that no longer exists in the latest version.
In total, C ARAMEL generates 173 bug reports. This section
ﬁrst presents the 150 new bugs found by C ARAMEL . It then
discusses the 23 false positives reported by C ARAMEL , the ﬁx
generation results, and C ARAMEL ’s running time. We conduct
the experiments on two Intel i7, 4-core, 8 GB machines,
running at 2.5 GHz and 3.4 GHz for the Java and C/C++
experiments, respectively.
L # App Description LoCClasses(J)
Files(C)Java1 Ant build tool 140,674 1,298
2 Groovy dynamic language 161,487 9,582
3 JMeter load testing tool 114,645 1,189
4 Log4J logging framework 51,936 1,420
5 Lucene text search engine 441,649 5,814
6 PDFBox PDF framework 108,796 1,081
7 Sling web app. framework 202,171 2,268
8 Solr search server 176,937 2,304
9 Struts web app. framework 175,026 2,752
10 Tika content extraction 50,503 717
11 Tomcat web server 295,223 2,473C/C++12 Chromium web browser 13,371,208 10,951
13 GCC compiler 1,445,425 781
14 Mozilla web browser 5,893,397 5,725
15 MySQL database server 1,774,926 1,684
Fig. 9. The applications used in experiments
A. New Bugs Found by CARAMEL
CARAMEL is very effective at detecting performance bugs.
CARAMEL ﬁnds a total of 150 new bugs , 61 bugs in Java
applications and 89 bugs C/C++ applications. Of these, 116
bugs, 51 and 65 in Java and C/C++, respectively, have already
been ﬁxed by developers . Of the bugs not yet ﬁxed, 7 bugs
are conﬁrmed and still under consideration by developers and
16 bugs are still open. 7 bugs were not ﬁxed because they are
in deprecated code, old code, test code, or auxiliary projects.
Only 3 bugs were not ﬁxed because developers considered that
the bugs do not have a signiﬁcant performance impact. Only 1bugwas not ﬁxed because developers considered that the ﬁx
hurts code readability.
We manually inspected all Java and C/C++ bugs reported by
CARAMEL and we ﬁnd they are similar. The only exception
is that C ARAMEL -C can currently detect only bugs with one
RI (Section IV), and therefore all the C/C++ bugs in this
evaluation have one RI. The bug examples shown so far in
the paper are from Java code. Figure 10 shows an example
bug from GCC, which contains a Type 3 RI. This bug was
conﬁrmed and ﬁxed by developers.
1bool irred invalidated = ...
2FOR EACH EDGE (ae, ei, e  >src >succs) f
3+ if (irred invalidated) break ; // FIX
4if(ae != e && ae  >dest != EXIT BLOCK PTR
5 && !bitmap bitp (seen, ae  >dest >index)
6 && ae  >ags & EDGE IRREDUCIBLE LOOP) f
7 irred invalidated = true;//RI
8gg
Fig. 10. A GCC performance bug found by C ARAMEL
Figure 11 shows the detailed results for the new bugs found
by C ARAMEL . The numbers in the table refer to the numbers
of distinct buggy loops, with each loop containing one or
multiple RIs. 16 out of the 61 Java bugs in Figure 11 contain
more than one RI. As explained in Section II-F, most of
these 16 bugs contain RIs of the same type, with only a few
bugs containing RIs of Type 2 and Type 3, as shown in the
table (the column headers show the type of the RIs in the
bug). C ARAMEL -C can currently detect only bugs with one
RI (Section IV), and therefore no C/C++ bug in Figure 11
contains multiple RIs.
ApplicationType 1 Type 2+3 Type 3 Type 4SUMRIs RIs RIs RIs
Ant 0 0 1 0 1
Groovy 2 0 7 0 9
JMeter 0 0 3 1 4
Log4J 0 0 5 1 6
Lucene 6 0 7 1 14
PDFBox 1 5 3 1 10
Sling 0 0 6 0 6
Solr 0 0 2 0 2
Struts 2 0 2 0 4
Tika 0 0 1 0 1
Tomcat 0 0 3 1 4
Chromium 0 0 13 9 22
GCC 1 0 21 0 22
Mozilla 0 0 20 7 27
MySQL 3 0 13 2 18
SUM: 15 5 107 23 150
Fig. 11. New bugs found by C ARAMEL
CARAMEL found bugs in all 15 applications in Figure 11,
including in GCC, which is highly tuned for performance and
has been developed for more than two and a half decades.
Indeed, all the bugs that we reported to GCC have already
been ﬁxed by developers .
CARAMEL found all four RI types in bugs. Looking at the
type breakdown in Figure 11, we see Type 3 RIs are more
frequent than RIs of other types. We manually inspect all the
bugs reported by C ARAMEL and we ﬁnd the bugs containing
Type 3 RIs typically appear in code performing a linear search
for objects that have certain properties, such as the bugs in
8Figure 4. This is a common operation in real-world code,
and therefore it presents more opportunities for developers to
introduce such bugs.
B. False Positives
CARAMEL reports few false positives, as shown in Fig-
ure 12. We manually inspect all false positives and ﬁnd three
causes. Complex Analysis false positives occur when C ARA-
MEL incorrectly judges, in step three of its algorithm, that
some L-Break conditions are satisﬁable. Such false positives
can be reduced by complex analysis, as described in this
section, but the number of such false positives does not justify
the added complexity. Concurrent false positives are caused by
expressions that appear to be loop-invariant, but that in reality
can be modiﬁed by a concurrent thread. Such false positives
can be reduced using static analysis [41] or heuristics [57].
Infrastructure false positives occur because WALA may give
incomplete results, as described later in this section.
Application Complex Aly. Concurrent Infrastructure
Ant 0 1 0
Groovy 0 0 0
JMeter 0 0 0
Log4J 0 2 0
Lucene 2 3 0
PDFBox 0 0 1
Sling 0 0 1
Solr 0 0 1
Struts 1 0 1
Tika 2 0 0
Tomcat 1 0 3
Chromium 0 0 0
GCC 1 0 0
Mozilla 2 0 0
MySQL 1 0 0
SUM: 10 6 7
Fig. 12. False positives and their cause
Figure 13 shows a Complex Analysis false positive from
Tomcat. Here, C ARAMEL detects that RI 1 and RI 2
are of Type 1 with I-Break conditions allRolesMode
== AllRolesMode.AUTH_ONLY_MODE equals false (line 5)
and allRolesMode == AllRolesMode.STRICT_AUTH_ON-
LY_MODE equals false (line 9), respectively. C ARAMEL incor-
rectly judges, in step three of its algorithm, that it is possible
to satisfy these two I-Break conditions simultaneously, and
CARAMEL reports a bug. However, this conclusion is wrong
because AllRolesMode is an enumeration with three values
and the loop is executed only when allRolesMode is not
equal to the third value. Therefore, when the loop executes,
allRolesMode can only have one of the two remaining values.
CARAMEL could avoid this false positive by employing a com-
plex analysis that takes into account the values enumeration
variables can take, and that determines the condition under
which the entire loop is executed.
Figure 14 shows a Concurrent false positive from Lucene.
Here, C ARAMEL detects Atoms channel.isClosed() and
thread == null (lines 1, 2) as loop-invariant, and therefore
concludes that the RI on line 2 is of Type 1. However, this1AllRolesMode allRolesMode = ...;
2for(inti = 0; i <constraints.length; i++) f
3SecurityConstraint constraint = constraints[i];
4if(constraint.getAllRoles()) f
5 if(allRolesMode == AllRolesMode.AUTH ONLY MODE) f
6 log.debug("Granting access for ..."); //RI 1
7 g
8 String[] roles = request.getContext().ndSecurityRoles();
9 if(roles.length == 0 && allRolesMode == AllRolesMode.
STRICT AUTH ONLY MODE) f
10 log.debug("Granting access for ..."); //RI 2
11ggg
Fig. 13. Complex Analysis false positive from Tomcat
conclusion is wrong because channel andthread are both
shared variables that can be modiﬁed by another thread, in
parallel with this loop’s execution. This is a typical custom
synchronization that can be detected by existing tools [57].
1while (!channel.isClosed()) f
2if(thread == null)return ;//RI
3tryfsleep(RETRY INTERVAL); gcatch (Exception e) f/ignored /g
4g
Fig. 14. Concurrent false positive from Lucene
The Infrastructure false positives appear because, to scale
to large programs, we instruct WALA to not analyze code
inside some libraries, e.g., java.awt andjavax.swing , as
recommended in WALA’s performance guidelines [1]. This
may cause WALA to give incomplete results, which may cause
CARAMEL to miss some RIs in step one of its algorithm.
C. Automatic Fix Generation
CARAMEL successfully generates ﬁxes for 149 out of 150
bugs. We manually inspected all these ﬁxes and conﬁrmed
all are correct. For one bug in Tomcat, C ARAMEL -J could
not generate a ﬁx due to a limitation in WALA. Speciﬁcally,
WALA does not always provide line number information
for assignment instructions. Therefore, for this Tomcat bug,
CARAMEL could not generate a ﬁx like the ﬁx in Figure 5(a),
because C ARAMEL did not know where to insert the break .
For the other bugs involving Type 4 RIs, WALA did not suffer
from this problem and C ARAMEL could generate ﬁxes. Note
that loop headers are notassignment instructions. Therefore,
generating ﬁxes immediately before or after loop headers,
which is how C ARAMEL generates ﬁxes for loops containing
other RI types (Section III-E), is not affected by this limitation.
We compare the ﬁxes generated by C ARAMEL with the
ﬁxes adopted by developers and ﬁnd they are similar, with
one exception. For bugs containing only one Type 3 RI,
CondBreak ﬁxes are different from manual ﬁxes, because
developers prefer to insert a break immediately after the RI.
CARAMEL could have easily followed developers’ style and
generated the same ﬁxes, if WALA was able to provide the line
number of the RI. However, as describe above, WALA cannot
guarantee to provide line number for assignment instructions,
and C ARAMEL chooses to generate the basic CondBreak ﬁxes,
inserted right after the loop header.
D. Overhead
Figure 15 shows C ARAMEL ’s running time in minutes.
Columns Sequential and Parallel give the time for the se-
quential and parallel version C ARAMEL using three threads,
9respectively. C ARAMEL ’s parallel version divides the loops
inNgroups, starts Nthreads, and lets each thread analyze
the loops in one group. C ARAMEL -J’s parallel execution takes
up to two hours, for all but three applications. Most of this
time is spent in WALA’s inter-procedural pointer analysis. We
consider this running time acceptable, because developers do
not need to write test code, like for a dynamic bug detection
technique, or devise complex usage scenarios, like for a
proﬁler. Furthermore, after the initial run, subsequent runs of
CARAMEL on the same code can focus only on code that has
changed, in the spirit of regression testing [59]. The speedup
of the parallel version over the sequential version is over 2.5X
for all but four applications, which shows C ARAMEL makes
effective use of modern multi-core machines. C ARAMEL -C
is much faster than C ARAMEL -J because C ARAMEL -C does
not use interprocedural pointer-alias analysis, but instead con-
servatively assumes that every write to heap is an RI. We did
not consider necessary to parallelize C ARAMEL -C because the
running time is small, ranging from several minutes for GCC
and MySQL up to one and a half hours for Chromium.
Application Sequential Parallel Speedup (X)
Ant 183 72 2.54
Groovy 345 128 2.70
JMeter 118 52 2.27
Log4J 108 45 2.40
Lucene 1068 417 2.56
PDFBox 106 38 2.79
Sling 355 190 1.87
Solr 1062 627 1.69
Struts 226 77 2.94
Tika 113 42 2.69
Tomcat 258 89 2.90
Chromium 85 n/a n/a
GCC 3 n/a n/a
Mozilla 52 n/a n/a
MySQL 10 n/a n/a
Fig. 15. C ARAMEL running time (minutes)
VI. D ISCUSSION
Importance of Bugs That Have CondBreak Fixes: The
importance of a bug is ultimately decided by developers: if the
developers think the bug is important enough to ﬁx, it means
that detecting and ﬁxing that bug is important. We evaluated
CARAMEL on 15 real-world applications, and 116 of the bugs
found by C ARAMEL are already ﬁxed by the developers.
Generality of Bugs That Have CondBreak Fixes: These
are deﬁnitely not all the bugs that have non-intrusive ﬁxes.
However, these bugs are general: 15 real-world applications,
written both in Java and in C/C++, contain such bugs. We hope
CARAMEL ’s promising results will motivate future research to
detect other performance bugs that have non-intrusive ﬁxes.
Estimating the Offered Speedup: CARAMEL is a static
technique and cannot easily estimate the speedup offered
by the bug ﬁx. Developers may appreciate such additional
information. However, as our results show, developers typically
ﬁx the bugs reported by C ARAMEL even without knowing the
exact speedup. Future work can try to estimate the speedup,
perhaps using techniques inspired by [9], [19].VII. R ELATED WORK
Improving Performance and Detecting Performance
Problems: Several techniques identify slow code [13], [21],
[36], [40], [56], [60], runtime bloat [5], [15], [43], [58],
or increasing execution time [11], [16], [61]. Siegmund et
al. [50] and Guo et al. [20] predict how conﬁguration options
inﬂuence performance, Trubiani et al. [53] consider uncertainty
in performance modeling, Malik et al. [33] detect devia-
tions in load tests, and Lu and Song [51] investigate design
points in performance statistical debugging. Other techniques
generate performance tests [8], [10], [18], [48], [62], detect
performance regression [47], latent performance bugs [26],
concurrency performance problems [32], [46], [52], and idle
time [4]. Unlike all these techniques, C ARAMEL makes the
novel design decision to focus on performance bugs that have
simple and non-intrusive ﬁxes. Speciﬁcally, C ARAMEL detects
performance bugs that have CondBreak ﬁxes. Such bugs are
not covered by previous work.
Automatic Bug Fixing: Several recent techniques have
been propose to automatically ﬁx bugs [30]. GenProg [17],
[55] uses genetic programming, LASE [28], [35], SysEdit [34],
and FixWizard [44] use edits similar to previous edits. Other
techniques [3], [12], [14], [27], [31], [42], [49], [54] repair
bugs using approaches such as SMT, semantic analysis, soft-
ware contracts, developer input, etc. Unlike these techniques,
CARAMEL automatically ﬁxes performance bugs. Furthermore,
taking advantage of the unique properties of the bugs it detects,
CARAMEL successfully ﬁxes 149 out of 150 bugs.
VIII. C ONCLUSIONS
Performance bugs affect even well tested software written
by expert programmers. In practice, ﬁxing a performance
bug can have both beneﬁts and drawbacks, and developers
ﬁx a performance bug only when the beneﬁts outweigh the
drawbacks. Unfortunately, the beneﬁts and drawbacks can be
difﬁcult to assess accurately. This paper presented C ARAMEL ,
a novel technique that detects and ﬁxes performance bugs that
have non-intrusive ﬁxes likely to be adopted by developers.
Speciﬁcally, C ARAMEL detects performance bugs that have
CondBreak ﬁxes: when a condition becomes true during loop
execution, just break out of the loop. We evaluated C ARA-
MEL onreal-world applications , including 11 popular Java
applications (Ant, Groovy, JMeter, Log4J, Lucene, PDFBox,
Sling, Solr, Struts, Tika, and Tomcat) and 4 widely used C/C++
applications (Chromium, GCC, Mozilla, and MySQL). C ARA-
MEL found 61 new performance bugs in the Java applications
and89 new performance bugs in the C/C++ applications. Of
these bugs, developers have already ﬁxed 51 performance
bugs in the Java applications and 65 performance bugs in the
C/C++ applications. C ARAMEL makes a promising ﬁrst step
in detecting performance bugs that have non-intrusive ﬁxes.
ACKNOWLEDGMENTS
This material is based upon work partially supported by
NSF under Grant Nos. CCF-1439091, CCF-1217582, CCF-
1054616, CNS-0958199, CCF-0916893, CCF-1442157, and
CCF-1439957, and the Alfred P. Sloan Foundation.
10REFERENCES
[1]WALA: T.J. Watson libraries for analysis. http://wala.sourceforge.net.
[2]Adobe Systems Inc. Known issues and bugs. http://helpx.adobe.com/-
acrobat/kb/known-issues-bugs-acrobat-reader.html.
[3]M. Alkhalaf, A. Aydin, and T. Bultan. Semantic differential repair for
input validation and sanitization. In ISSTA , 2014.
[4]E. A. Altman, M. Arnold, S. Fink, and N. Mitchell. Performance analysis
of idle programs. In OOPSLA , 2010.
[5]S. Bhattacharya, M. G. Nanda, K. Gopinath, and M. Gupta. Reuse,
recycle to de-bloat software. In ECOOP , 2011.
[6]R. E. Bryant and D. R. O’Hallaron. Computer Systems: A Programmer’s
Perspective . Addison-Wesley, 2010.
[7]Bugzilla@Mozilla. Bugzilla keyword descriptions.
https://bugzilla.mozilla.org/describekeywords.cgi.
[8]J. Burnim, S. Juvekar, and K. Sen. WISE: Automated test generation
for worst-case complexity. In ICSE , 2009.
[9]R. P. L. Buse and W. Weimer. The road not taken: Estimating path
execution frequency statically. In ICSE , 2009.
[10] F. Chen, J. Grundy, J. Schneider, Y. Yang, and Q. He. Automated
analysis of performance and energy consumption for cloud applications.
InICPE , 2014.
[11] E. Coppa, C. Demetrescu, and I. Finocchi. Input-sensitive proﬁling. In
PLDI , 2012.
[12] V. Dallmeier, A. Zeller, and B. Meyer. Generating ﬁxes from object
behavior anomalies. In ASE, 2009.
[13] D. C. D’Elia, C. Demetrescu, and I. Finocchi. Mining hot calling
contexts in small space. In PLDI , 2011.
[14] F. Demarco, J. Xuan, D. L. Berre, and M. Monperrus. Automatic repair
of buggy if conditions and missing preconditions with SMT. In CSTVA ,
2014.
[15] B. Dufour, B. G. Ryder, and G. Sevitsky. A scalable technique for
characterizing the usage of temporaries in framework-intensive Java
applications. In FSE, 2008.
[16] S. Goldsmith, A. Aiken, and D. S. Wilkerson. Measuring empirical
computational complexity. In FSE, 2007.
[17] C. L. Goues, M. Dewey-Vogt, S. Forrest, and W. Weimer. A systematic
study of automated program repair: Fixing 55 out of 105 bugs for $8
each. In ICSE , 2012.
[18] M. Grechanik, C. Fu, and Q. Xie. Automatically ﬁnding performance
problems with feedback-directed learning software testing. In ICSE’12 .
[19] S. Gulwani, K. K. Mehra, and T. M. Chilimbi. SPEED: Precise and
efﬁcient static estimation of program computational complexity. In
POPL , 2009.
[20] J. Guo, K. Czarnecki, S. Apel, N. Siegmund, and A. Wasowski.
Variability-aware performance prediction: A statistical learning approach.
InASE, 2013.
[21] S. Han, Y. Dang, S. Ge, D. Zhang, and T. Xie. Performance debugging
in the large via mining millions of stack traces. In ICSE , 2012.
[22] P. Huang, X. Ma, D. Shen, and Y. Zhou. Performance regression testing
target prioritization via performance risk analysis. In ICSE , 2014.
[23] G. Jin, L. Song, X. Shi, J. Scherpelz, and S. Lu. Understanding and
detecting real-world performance bugs. In PLDI , 2012.
[24] R. Johnson. More details on today’s outage, 2010.
https://www.facebook.com/notes/facebook-engineering/more-details-
on-todays-outage/431441338919.
[25] P. Kallender. Trend Micro will pay for PC repair costs, 2005.
http://www.pcworld.com/article/120612/article.html.
[26] C. E. Killian, K. Nagaraj, S. Pervez, R. Braud, J. W. Anderson, and
R. Jhala. Finding latent performance bugs in systems implementations.
InFSE, 2010.
[27] D. Kim, J. Nam, J. Song, and S. Kim. Automatic patch generation
learned from human-written patches. In ICSE , 2013.
[28] M. Kim and N. Meng. Recommending program transformations—
Automating repetitive software changes. In Recommendation Systems
in Software Engineering , pages 421–453. 2014.
[29] C. Lattner and V. Adve. LLVM: A compilation framework for lifelong
program analysis & transformation. In CGO , 2004.
[30] C. Le Goues, S. Forrest, and W. Weimer. Current challenges in automatic
software repair. Software Quality Journal , 21(3):421–443, 2013.
[31] P. Liu and C. Zhang. Axis: Automatically ﬁxing atomicity violations
through solving control constraints. In ICSE , 2012.[32] T. Liu and E. D. Berger. SHERIFF: Precise detection and automatic
mitigation of false sharing. In OOPSLA , 2011.
[33] H. Malik, H. Hemmati, and A. E. Hassan. Automatic detection of
performance deviations in the load testing of large scale systems. In
ICSE , 2013.
[34] N. Meng, M. Kim, and K. S. McKinley. Systematic editing: Generating
program transformations from an example. In PLDI , 2011.
[35] N. Meng, M. Kim, and K. S. McKinley. LASE: Locating and applying
systematic edits by learning from examples. In ICSE , 2013.
[36] H. Mi, H. Wang, Y. Zhou, M. R. Lyu, H. Cai, and G. Yin. An online
service-oriented performance proﬁling tool for cloud computing systems.
Frontiers of Computer Science , 7(3):431–445, 2013.
[37] Microsoft Corp. Connect. https://connect.microsoft.com/.
[38] D. Mituzas. Embarrassment, 2009.
http://dom.as/2009/06/26/embarrassment/.
[39] I. Molyneaux. The Art of Application Performance Testing: Help for
Programmers and Quality Assurance . O’Reilly Media, 2009.
[40] T. Mytkowicz, A. Diwan, M. Hauswirth, and P. F. Sweeney. Evaluating
the accuracy of Java proﬁlers. In PLDI , 2010.
[41] M. Naik, A. Aiken, and J. Whaley. Effective static race detection for
Java. In PLDI , 2006.
[42] H. D. T. Nguyen, D. Qi, A. Roychoudhury, and S. Chandra. SemFix:
Program repair via semantic analysis. In ICSE , 2013.
[43] K. Nguyen and G. H. Xu. Cachetor: Detecting cacheable data to remove
bloat. In ESEC/FSE , 2013.
[44] T. T. Nguyen, H. A. Nguyen, N. H. Pham, J. M. Al-Kofahi, and T. N.
Nguyen. Recurring bug ﬁxes in object-oriented programs. In ICSE ,
2010.
[45] A. Nistor, L. Song, D. Marinov, and S. Lu. Toddler: Detecting
performance problems via similar memory-access patterns. In ICSE ,
2013.
[46] J. Oh, C. J. Hughes, G. Venkataramani, and M. Prvulovic. LIME: A
framework for debugging load imbalance in multi-threaded execution.
InICSE , 2011.
[47] M. Pradel, M. Huggler, and T. R. Gross. Performance regression testing
of concurrent classes. In ISSTA , 2014.
[48] M. Pradel, P. Schuh, G. C. Necula, and K. Sen. EventBreak: Analyzing
the responsiveness of user interfaces through performance-guided test
generation. In OOPSLA , 2014.
[49] H. Samimi, M. Sch ¨afer, S. Artzi, T. D. Millstein, F. Tip, and L. J. Hen-
dren. Automated repair of HTML generation errors in PHP applications
using string constraint solving. In ICSE , 2012.
[50] N. Siegmund, S. S. Kolesnikov, C. K ¨astner, S. Apel, D. S. Batory,
M. Rosenm ¨uller, and G. Saake. Predicting performance via automated
feature-interaction detection. In ICSE , 2012.
[51] L. Song and S. Lu. Statistical debugging for real-world performance
problems. In OOPSLA , 2014.
[52] A. Tarvo and S. P. Reiss. Using computer simulation to predict the
performance of multithreaded programs. In ICPE , 2012.
[53] C. Trubiani, I. Meedeniya, V. Cortellessa, A. Aleti, and L. Grunske.
Model-based performance analysis of software architectures under un-
certainty. In QoSA , 2013.
[54] Y. Wei, Y. Pei, C. A. Furia, L. S. Silva, S. Buchholz, B. Meyer, and
A. Zeller. Automated ﬁxing of programs with contracts. In ISSTA , 2010.
[55] W. Weimer, T. Nguyen, C. L. Goues, and S. Forrest. Automatically
ﬁnding patches using genetic programming. In ICSE , 2009.
[56] X. Xiao, S. Han, D. Zhang, and T. Xie. Context-sensitive delta inference
for identifying workload-dependent performance bottlenecks. In ISSTA ,
2013.
[57] W. Xiong, S. Park, J. Zhang, Y. Zhou, and Z. Ma. Ad hoc synchroniza-
tion considered harmful. In OSDI , 2010.
[58] G. H. Xu, N. Mitchell, M. Arnold, A. Rountev, E. Schonberg, and
G. Sevitsky. Scalable runtime bloat detection using abstract dynamic
slicing. ACM Transactions on Software Engineering Methodology ,
23(3):23, 2014.
[59] S. Yoo and M. Harman. Regression testing minimization, selection and
prioritization: A survey. Software Testing, Veriﬁcation and Reliability ,
22(2):67–120, 2012.
[60] X. Yu, S. Han, D. Zhang, and T. Xie. Comprehending performance from
real-world execution traces: A device-driver case. In ASPLOS , 2014.
[61] D. Zaparanuks and M. Hauswirth. Algorithmic proﬁling. In PLDI , 2012.
[62] P. Zhang, S. G. Elbaum, and M. B. Dwyer. Automatic generation of
load tests. In ASE, 2011.
11