Multi-Granular Conflict and Dependency Analysis in Software
Engineering based on Graph Transformation
Leen Lambers
Hasso-Plattner-Institut Potsdam,
Germany
leen.lambers@hpi.deDaniel Strüber
Universität Koblenz-Landau,
Germany
strueber@uni-koblenz.deGabriele Taentzer, Kristopher
Born, Jevgenij Huebert
Universität Marburg, Germany
{taentzer,born,huebert}@mathematik.
uni-marburg.deABSTRACT
Conflictanddependencyanalysis(CDA)ofgraphtransformation
has been shown to be a versatile foundation for understanding
interactionsinmanysoftwareengineeringdomains,includingsoft-
wareanalysisanddesign,model-drivenengineering,andtesting.
In this paper, we propose a novel static CDA technique that is
multi-granularinthesensethatitcandetectallconflictsanddepen-
denciesonmultiplegranularitylevels. Specifically,weprovidean
efficient algorithm suite for computing binary,coarse-grained, and
fine-grained conflicts and dependencies: Binary granularity indi-
cates the presence or absence of conflicts and dependencies, coarse
granularityfocusesonrootcausesforconflictsanddependencies,
and fine granularity shows each conflict and dependency in full
detail. Doing so, we can address specific performance and usability
requirementsthatweidentifiedinaliteraturesurveyofCDAus-
agescenarios. Inanexperimentalevaluation,ouralgorithmsuite
computesconflictsanddependenciesrapidly. Finally,wepresent
a user study, in which the participants found our coarse-grained
resultsmoreunderstandablethanthefine-grainedonesreportedin
astate-of-the-arttool. Ouroverallcontributionistwofold: (i)we
significantly speedupthe computation of fine-grained and binary
CDAresultsand,(ii)complementthemwithcoarse-grainedones,
which offer usability benefits for numerous use cases.
CCS CONCEPTS
•Software and its engineering →Automated static analysis;
1 INTRODUCTION
Conflictsanddependencies arefundamentalphenomenainsoftware
engineering. Forexample,whenasoftwaresystemisdevelopedcol-
laboratively[ 61],achangeoperationcanfacilitateorprohibitother
changeoperations. Inconcurrentprogramming,conflictsmayarise
from data races [ 28,56] when a thread writes to a memory loca-
tion accessed by another thread. From unrecognized conflicts and
dependencies, severe consequences mayarise, rangingfrompro-
ductivityobstaclestofatalsafetyhazards. Therefore,thereisaneed
for techniques to detect conflicts and dependencies automatically.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthefirstpage. CopyrightsforcomponentsofthisworkownedbyothersthanACMmustbehonored. Abstractingwithcreditispermitted. Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE ’18, Gothenburg, Sweden
© 2018 ACM. 978-1-4503-5638-1/18/05...$15.00
DOI: 10.1145/3180155.3180258Graph transformation [17,18,53] has been shown to be a versa-
tilefoundationforsupportingconflictanddependencydetection
in software engineering, based on the following three principles:
First,graphsareusedforrepresentingstructuresofinterest,suchas
states of computation [ 1,7] or versions of the system structure [ 8].
Second,certainchanges,suchasstateorstructuremodifications,
aredescribedusinggraphtransformationrules. Third,theprovided
transformationspecificationisfedtothestatic conflictanddepen-
dencyanalysis (CDA)ofgraphtransformations[ 27,48]: Givenaset
oftransformationrules,allconflictsanddependenciesarisingfrom
a given pair of rules are identified. A conflict arises, for example, if
the first rule application deletes an element required by the second
ruleapplication. Akeybenefitofgraphtransformationisitsmature
formalfoundation,whichsupportsCDAtechniquesthatarecorrect
by design: all conflicts and dependencies can be detected.
Basedontheseprinciples,theCDAofgraphtransformationshas
enabled a large number of use-cases in software engineering, includ-
inganalysisanddesign,model-drivenengineering,andtesting. Forexample,graphtransformationscanbeusedtomodeltheexecution
behavior of Java programs in terms of preconditions and effectsontheobjectstructure;identifiedconflictsanddependenciesare
thenusedasoraclesfortestgeneration[ 1,54]. Insoftwareproduct
lineengineering,featureinteractionscanbedetectedbyspecifying
features as graph transformations and identifying conflicts and de-
pendencies with CDA [ 33]. In model-based refactoring [ 46], graph
transformations and CDA are used to find a suitable order of refac-
toringsteps. Onecontributionofthispaperisaliteraturesurvey
that overviews 25 papers describing such use-cases.
Althoughgenerallyhelpfulforthetaskathand,however,sev-
eral authors report that the used CDA technique showed severe
limitations. Inoursurvey,weidentifythreekeyrequirementsfor
animprovedCDAtechniqueforsoftwareengineering: itshallbe(i)
domain-independent tobe applicableto alarge varietyofsoftware
engineering domains, (ii) usablein the sense that it should display
areasonableamountofinformationtosupportunderstandability,
and (iii)efficientwhen applied to software projects of realistic size.
Toaddresstheserequirements, wepresentanovelstaticCDA
technique for software engineering based on graph transformation.
Thetechniqueisbasedonthenotionof granularity ofconflictsand
dependenciesintroducedin[ 10]: Often,theusermerelyrequires
toknowifagivenrulepaircaninduceconflictsordependencies
at all,while detailsare irrelevant(binary granularity ). Atthe next
level, the user wants to pinpoint certain elements that present the
rootcausesofconflictsordependencies(coarsegranularity ). Atthe
7162018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:36:22 UTC from IEEE Xplore.  Restrictions apply. final level, a complete description of each potential conflict and de-
pendency is required (fine granularity ). To enable an efficient com-
putation, we present an algorithm suite which can compute binary,
coarse-grained, and fine-grained results rapidly. The computation
offine-grained onesharnesses coarse-grainedones. Moreover, we
conducted a user study, in which the participants found coarse-
grainedanalysisresultsmoreunderstandableandeasiertowork
with than fine-grained ones reported by a state-of-the-art tool.
Insummary,thispaperpresentsa multi-granular CDA tech-
niquebasedongraphtransformation achievingthesamelevel
of (i) domain-independence as the state of the art, while providing
major (ii) understandability and (iii) performance improvements.
Specifically, we make the following contributions:
•Aliterature survey of existing CDA use-cases (Sec. 3),
focusing on granularity requirements.
•Aformalization of different granularity levels of con-
flict and dependencies (Sec. 4), for ensuring the well-
foundedness of our technique.
•Analgorithm suite supporting the computation of CDA
results at multiple granularity levels (Sec. 5).
•Animplementation evaluation , in which we study the
performance of our algorithm suite (Sec. 6).
•Auserstudy todeterminetheusefulnessofcoarse-grained
conflict results in comparison to fine-grained ones (Sec. 7).
With these contributions, we aim to improve on the state-of-
the-art CDA technique, critical pair analysis [ 42,59]( C P A ) .C P A
does not distinguish between granularity levels: Since its goal is to
provideallconflictsanddependencies,itsoutput—alistof critical
pairsdepictingeachconflictsituationinaminimalcontext—always
exhibits fine granularity. From the lack of support for differentgranularity levels, two main drawbacks arise. First, computing
allcriticalpairscanbecomputationallyvastlyexpensive. Second,
comprehending the critical pairs of a set of rules can be a daunting
task, since the list of critical pairs generally reflects numerous
options to combine the involved root causes.
Our work is the first to provide a general CDA technique for
graph transformations supporting multiple granularity levels. Ear-
lier usage scenarios either used CPA, or task-specific CDA tech-
niquesrelyingonthestructureoftheinvolvedrules[ 31,35]. Our
earlier work [ 10,40] serves as a formal foundation forthe current
one. We now amend the existingdeclarative definitions with con-
structive characterizations that supportefficient computations. To
the best of our knowledge, we provide the first, albeit preliminary,
empirical evidence regarding the usefulness of CDA techniques.
2 RUNNING EXAMPLE
Our running example deals with requirement elicitation for a web
shop,aservice-orientedsoftwaresystemthatenablesaretailerto
sell goods on a website. Customers can perform orders and inspecttheinformationongoodsandorders. Theretailerusestheavailable
information to manage its business processes. We focus on twobusiness processes, one for order management and one for data
mining, which we do not want to interfere with each other. This
means that activities of one process should not render activities of
the other process impossible; hence, conflicts between activities of
differentprocessesshouldnotoccur. Tobeabletoanalyzeconflicts,we specify activity requirements with graph transformation. A
transformation rule specifies pre- and post-conditions of activities.
Inourexample,weconsidertwoactivitiesoftheselectedbusi-
ness processes to be specified by rules: Rule returnUnpaidGood on
theleftofFig.1returnsa GoodintotheStockbydeletingthecorre-
sponding OrderItem andBillItem. In addition, the returned good is
removedfromthecustomer. Rule offerGiftspecifiesapatternfor
data mining which looks for an Orderwith at least two OrderItems.
TheCustomer ordering and owning these items is marked for a
GiftOffer. Note that a customer may own a good without having
itorderedandpaidsinceitmaybeagift. Bothrulesaredepicted
inanintegratedformwhereannotationsspecifywhichgraphel-
ements are deleted, preserved, and created. While the preserved
and deleted elements form the left-hand side (LHS) of a rule, the
preserved and created elements form its right-hand side (RHS).
Conflictandgranularityconsiderations. Toruntheselected
business processes for order management and fordata mining con-
currently, they shall not interfere with each other. This is the case
iftheiractivitiesdonotinterferepairwise(neglectinganypotential
control flow on activities). We focus our investigations on activity
returnUnpaidGood beingpartoftheordermanagementprocessand
offerGiftbeingsomedataminingactivity. Toinvestigateinterfer-
encesbetweenthesetwoactivities,weanalyzetworulesspecifyingthem. Ifanapplicationofthefirstrulerendersanapplicationofthe
secondruleimpossibleor,ifthesecondruleisstillapplicable,but
not at the original match anymore, a conflict occurs. To reduce the
amount of conflicts, we need to identify all their potential sources.
If the developer is just interested in knowing whether a given
pair of rules can induce a conflict, this information can be easily
giveninatablesuchasTable1wherea‘+’marksthataconflictfor
the given rule pair arises while ‘-’ marks that there is no conflict.
Rule 1 / Rule 2 returnUnpaidGood offerGift
returnUnpaidGood + +
offerGift - -
Table 1: Binary information about conflicts
To get acoarse understanding of conflicts, the developer may
beinterestedinknowingwhichruleelementscancauseconflicts.
Sincerules returnUnpaidGood andofferGiftspecifyactivitiesoftwo
processes that shall not interfere, we are especially interested inunderstanding all conflicts related to this rule pair. Two reasons
forconflicts areshowninthe middleofFigure1. Conflict-causing
elements are included in minimal graphs that describe the needed
overlapofparticipatingrules (depicted ontheleftand ontheright)
tocauseanactualconflictontheirapplications. Theuppergraph
specifies the deletion of an order item needed to offer a gift. The
loweroneshowsthedeletionofan owns-edgeneededtoofferagift.
Each of these graphs with their embeddings into rules are called
minimalconflictreasons. Overlappingtherulesalongsuchaconflict
reason yields two conflicting rule applications called critical pair.
For afine-grained representation of all conflicts, we also have
to consider all possible combinations of root causes. This means
that all possible compositions of minimal conflict reasons describe
furtherconflictsituationswhichwejustcall conflictreasons. One
exampleofsuchaconflictreasonisshowninFigure2,wherethe
order item as well as the targeting owns-edge for one and the same
717
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:36:22 UTC from IEEE Xplore.  Restrictions apply. Figure 1: Rules returnUnpaidGood andofferGift and two minimal conflict reasons – Coarse-grained information
goodaredeleted,bothneededtoofferagift. Thisgraphinducesone
ofaltogether6conflictreasonscausedbyrule returnUnpaidGood
on ruleofferGift. The conflict reasons not shown are analogous to
the three ones depicted in Figures 1 and 2. The remaining three
onesoverlap 5:OrderItem and6:GoodofrulereturnUnpaidGood with
3:OrderItem and4:Goodof ruleofferGift.
Figure2: Oneof6conflictreasonsofrule returnUnpaidGood
on ruleofferGift – Excerpt of fine-grained information
The state-of-the-art CDA which computes essential critical pairs
[42],however,yieldsmoreresultsforthisrulepair,namely10pairs
ofconflictingtransformations. While6ofthemdirectlycorrespond
to the ones discussed above, there are 4 further results which do
not show basically new conflict reasons but just nuances of the
consideredones. Hence,theexistingCDAprovidesanevenmore
fine-grained information about conflicts. Table 2 compares thenumbers of coarse and fine-grained results for our example, dis-
tinguishing our intended fine-grained analysis (indicated by ‘New
Fine’) from the existing CDA (indicated by ‘Ex. Fine’) . While
the entry for rule pair (returnUnpaidGood, offerGift) shows a mod-
erate increase of numbers, this is already more striking for rule
pair(returnUnpaidGood, returnUnpaidGood)demonstratingabigger
difference between numbers of coarse and existing fine-grained
conflict information (3 versus 19). In general, a lot of different criti-
cal pairs can exist and it may be tedious to go through all of them.
In Section 6,we found an example rulepair with 1588 ess. critical
pairs vs. 24 min. conflict reasons.
Rule 1 / Rule 2 returnUnpaidGood offerGift
returnUnpaidGood Coarse: 3 Coarse: 4
New Fine: 7 New Fine: 6
Ex. Fine: 19 Ex. Fine: 10
Table 2: Number of conflict reasons and ess. critical pairs,
resp., in coarse and fine-grained representations
Conclusion. Instead of overwhelming the user with a large
numberofconflictsasthestate-of-the-artfine-grainedCDAdoes,a multi-granular analysis supports a continuously deeper under-
standingofconflictswhereneeded. Inthisexample,rulepair(re-
turnUnpaidGood, offerGift) is of special interest since it may be
conflicting and specifies activities of two processes that should runindependentlyofeachother. Fromtheanalysis,wecandeducethatdataminingonunpaidgoodsmayleadtoinconsistencies. Toavoid
such conflicts, the activities may be adapted by, e.g., offering a gift
only for goods that have been already paid.
3 LITERATURE SURVEY
We conductedaliteraturesurveyto explorethe varietyofsoftware
engineeringdomainsinwhichcriticalpairanalysis(CPA)hasbeen
applied,thedesignatedstate-of-the-arttechniqueforconflictand
dependencyanalysis (CDA)based ongraphtransformation. First,
wepresentcollectedstatementstoperformanceandusabilityofthe
CPA. Then we elicit requirements regarding the actual granularity
level needed when performing CDA in specific use-cases.
To identify use-cases in the literature, we applied the search
clause"critical pair*" AND ("graph transformation" OR
"model transformation") to the five major CS online libraries
ofACM,IEE,Elsevier,Wiley,andSpringer,restrictingthesearchto
mentionsintitleandabstract. Thissearchyieldedaninitialbody
of 37 papers, to which we added 11 based on our knowledge about
CPAuses. Wediscardedthosethatfocusedontheoreticalresults,
and those represented by other papers in the same line of work on
the same overall use-case. We grouped the remaining 25 papers in
four main softwareengineering application domains (seeTable 3).
Performance and usability statements. In several papers
such as [13,23,44,62], the authors recognized severe performance
problemswhenusingthestate-of-the-artimplementationoftheCPA
in AGG [59]. They conclude that CPA does not scale for industrial
use. Oftenatoolargenumberofcriticalpairsiscomputedwhich
makesthe manualinspection oftheCPAresults nearlyimpossible.
Asonesolutiontoincreasetheperformanceandtodropthenumber
ofresults,authorstriedtoconstraintheallowedgraphs. Another
wayoutofthisdilemmawastoreplacethestaticCDAbyaruntime
check. However, these actions either change the kind of graphsconsidered or switch from static to dynamic analysis. From this
reviewof performanceandusability statements,weconcludethat
718
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:36:22 UTC from IEEE Xplore.  Restrictions apply. Granularity /
SE domainAnalysis and design
of software systemsMDE techniques Testing Optimization of
rule-based computations
Binary Graphparsing [ 12],Activity diagramvali-
dation[20],Editoperationrecognition[ 35],
Nondeterminism detection [23, 29]
Coarse-grained Consistencyvalidationofuse-cases[ 26],
service-based systems [ 38,41], context-
aware and adaptive systems [ 13,15,44],
activitydiagrams[ 20];Featureinterac-
tion detection [2, 33, 45, 62]Model versioning [ 39,60],
Refactoring recommendation
[46,50], Detecting & re-
solving model inconsisten-
cies [47]Test case gen-
eration [31]&
validation [54]
Fine-grained Verification of model trans-
formations [6, 30]
Table 3: Granularity requirements and software engineering domains of the CPA in literature survey
a highly performant static analysis is needed which produces a
concisesetofresultsthatiseasytoinspectmanually. Theessential
CPA [42], also available in AGG, was introduced as a first solution
to these requirements yielding a considerably smaller set of results
in asmaller amount oftime. We observed,however, that eventhe
essential CPA often returns too fine-grained results representing an
obstacle for performance as well as for usability when doing CDA.
Therefore, we analyze now the requirements w.r.t. the actual level
of granularity needed when performing CDA.
SEdomainsandgranularityrequirements. Wedescribeour
findings w.r.t. granularity requirements of the CPA use cases along
their application domains in SE as illustrated in Table 3.
Insoftware system design and analysis, the conformance of be-
havior models such as activity models and live sequence charts,
with the rule-based specification of activities (methods, operations,
or services) is investigated. The CPA is mostly used to find and un-
derstand conflicts and dependencies in the data flow and to reason
abouttheirplausibilityw.r.t. theconsideredsystem. Inthiscontext,
acoarse-grained CDA seems to be sufficient to start with.
Model-driven engineering (MDE) techniques are often specified
on the basis of model transformations. The CPA can be used to
detectandtoreasonabouttheplausibilityofconflictsanddependen-
ciesbetween specifiedtransformations. Inmodel versionmanage-
ment,theCPAismoreoverusedtoresolveconflictsbetweenmodel
changes. The coarse-grained analysis seems to be sufficient to find
conflictsanddependenciesbetweentransformationspecifications
here. Confluenceproofs, however,havetob eperformedbasedona
fine-grained analysis since these proofs are based on completeness
of the CPA results which is only given in the fine-grained case.
Intesting, the CPA is used for reasoning about and generat-
ing interesting test cases. A coarse-grained analysis of rule inter-
dependenciesseemsadequatetounderstandthespecifiedactivities.
Inoptimization of rule-based computations, the CPA has been
used to find out which rule pairs are conflicting or dependent at
all and to exploit this information for improving the computation.
The non-existence of conflicts or dependencies may allow compu-
tations without backtracking. Hence, binary information about the
existence of conflicts or dependencies is usually sufficient to either
avoid or deliberately postpone backtracking. For further optimiza-
tion, the elimination of existing conflicts or dependencies may be a
choice. Furtherinformation,i.e.,a coarse-grainedanalysis,isthen
needed to understand their causes and to modify rules accordingly.
Threats to Validity Regarding construct validity, we omit in-
vestigatingexpressivenessoftheanalyzedgraphtransformationsw.r.t. advancedtransformationfeaturessuchasnegativeapplication
conditions,whichisorthogonaltotherequiredgranularitylevel.
Theextensionofourtechniquetothesefeaturesisongoingwork.
While not being trivial, we are confident that this is possible, since
the underlying theory is given in a category-theoretical setting.
Conclusion. Wededucethefollowinggranularityrequirements
for CDA: (1) Binary granularity refers to the situation where the
relevant information is whether a conflict/dependency between
two graph transformations rules exists or not. Such informationis sufficient, e.g., to trim a solution space of possible alternatives.
(2)Coarse granularity refers to the situation where users need to
inspectindividualconflictsanddependencies,butdonotneedto
know the precise details of each possible conflict or dependency
situation. (3) Finegranularity isneededtoinspecteachconflictand
dependencysituationin-depth. Thisisnecessary,forexample,to
reason about confluence of a state transition relation. Our observa-
tions(inTable3)demonstratethatformostconsideredapplications
of conflict and dependency analyses, a binary or coarse-grainedanalysiswouldhavebeensufficientorwouldhaverepresenteda
goodstartingpointforanalysisthatcan–onlyifnecessary–stillbe
refinedtoamorefine-grainedone. Thesegranularityrequirements
support the need for a multi-granular approach to CDA.
4 CONFLICT AND DEPENDENCY CONCEPTS
We revisit conflict and dependency concepts for graph transforma-
tionwithvaryinggranularitylevelinSec.4.1. Asanewcontribu-
tion, we instantiate the binary, coarse and fine granularity level
(asidentifiedinSec.3)ofourmulti-granularCDAtechniquewith
adequate formal conflict and dependency concepts in Sec. 4.2.
4.1 Background
Werecallmainconceptsfromgraphtransformationwiththecon-
flictnotionunderlyingourwork[ 17,42]. Then,conflictanddepen-
dency concepts with varying granularity level are recalled [ 10,40].
Graph transformation. Representing complex structures as
graphs,graphtransformation isoneofthemainparadigmstode-
scribe their rule-based modification. A rulemainly consists of two
graphs: Lis the left-hand side (LHS) of the rule representing a pat-
ternthathastobefoundtoapplytherule. Aftertheruleapplication,
apatternequal to R, theright-hand side(RHS),hasbeencreated.
The intersection K=L∩Ris the part that is not changed, the part
thatistobedeletedisdefinedby L\K,while R\Kdefinesthepart
tobecreated. Tomakethedeletionpartofaruleagraph,weaddall
719
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:36:22 UTC from IEEE Xplore.  Restrictions apply. boundary nodes B⊆K, hence obtain deletion graph C=L\(K\B).
IfCis empty, the rule is called non-deleting.
Agraphtransformation Gr,m=⇒Hbetweentwographs GandH
is defined by first finding a match m, that is a mapping of the LHS
Lofrule rintoGsuchthat misinjectiveandfulfillsthe dangling
condition [17]: alladjacentgraphedgesofagraphnodetobedeleted
must be deleted as well. Second, we construct Hin two passes: (1)
build D:=G\m(L\K)), i.e., erase all graph elements that are to
be deleted; (2) construct H:=D∪m/prime(R\K)such that a new copy
of all graph elements that are to be created is added.
Example[Graphruleandtransformation] Figure3showsagraph
towhichrules returnUnpaidGood andofferGiftinFigure1areap-
plicable. Considering,e.g.,rule returnUnpaidGood theredandthe
grey parts form the LHS and the RHS consists of the green and the
grey parts. Hence, Kis represented by the grey part. Boundary
nodes are 1:Customer, 2:Order,4:Bill, and 6:Good. Deletion graph C
consists of the red rule part together with all boundary nodes.
Figure 3: Example graph to which rules returnUnpaidGood
andofferGift are applicable, with indicated matches
Therule’smatchesareindicatedbynumbers. Forexample, 1:Cus-
tomerof rulereturnUnpaidGood and2:Customer of ruleofferGift
are both mapped to 1,2:Customer. An ‘_’ indicates that this node is
notinthecorrespondingmatch. Notethatrule returnUnpaidGood
can be applied in two different ways to this graph. Since rule of-
ferGiftis non-deleting, the dangling condition is always fulfilled.
RulereturnUnpaidGood,however,deletestwonodes: 5:OrderItem
and7:BillItem. Theirimagesinthegrapharenotallowedtohave
danglingedges,i.e.,edgeswithoutoriginsintheLHS.Thisisthe
case here, hence both mappings fulfill the dangling condition.
Theeffectofapplyingrule returnUnpaidGood atthegivenmatch
isthedeletionofedge ownsfrom1,2:Customer to6,6:Goodaswell
asofnodes 5,5:OrderItem and7,_:BillItem withadjacentedges. In
addition, a new edge from 3,_:Stockto6,6:Goodis added.
Conflict. Givenagraph Gthereare,ingeneral,severalrulesap-
plicableatdifferentmatches. Apairoftransformations (Gr1,m1=⇒H1,
Gr2,m2=⇒H2)isinconflict ifthefirstruleapplicationdeletesgraph
elements used by the second one, i.e., if m1(C1\B1)∩m2(L2)is
not empty. Since matches are injective, we can build a conflict
part m−1
1(m1(C1\B1)∩m2(L2)) ⊆ C1that can be completed by
adding incident boundary nodes to a conflict graph S1, being a sub-
graph of the deletion graph C1of rule r1. Moreover, we have a
mapping e2=m−1
2◦m1ofS1into L2. Together with its embed-
ding into C1,aspan s1=(C1⊇←S1e2→L2)for rule pair (r1,r2)
canbedefinedwhichdistillsthecauseofaconflictandtherefore,is calledconflict reason forGr1,m1=⇒H1andGr2,m2=⇒H2. Given a
span s1=(C1⊇←S1e2→L2)for rule pair (r1,r2)and mappings
m1:L1→Gandm2:L2→Gwe say that these mappings overlap
ins1ifm1(S1)∩m2(e2(S1)) ⊆m1(L1)∩m2(L2).
Example [Conflict] In the graph in Figure 3 with the given matches
of rulesreturnUnpaidGood andofferGift, the resulting pair of trans-
formations is in conflict since m1(C1\B1)∩m2(L2)contains node
5,5:OrderItem withadjacentedgesandedge ownsfrom1,2:Customer
to6,6:Good, i.e. these elements are deleted by the first transfor-
mation and used by the second one. The corresponding conflict
reasonisgivenbytheconflictgraphinFigure2,itsembeddinginto
the deletion graph of rule returnUnpaidGood, and its mapping into
theLHSofrule offerGift. Bothembeddingsaregivenbynumbers
(compare Figures 1 and 2). We focus on the conflict graph of a
conflict reason while embeddings are just given by corresponding
numbers as explained above.
Conflictconcepts. Headingtowardsastaticconflictanalysis,
wedonotinvestigateeachpairofgraphtransformationsbutanalyze
rule pairs instead. Rule pair (r1,r2)is inconflictif there is any pair
of conflicting transformations applying rule r1and then r2.
We further concentrate on rule parts that may cause conflicts.
The minimal building bricks of conflict causes are called conflict
atoms. An atom is derived from an atom candidate being a span
a1=(C1⊇←A1e2→L2)for rule pair (r1,r2), where A1is a single
deletednodeoredgeincidentwithpreservednodes. Itisdeleted
bythefirstruleandusedbythesecondone. Adeletededgewithat
leastoneincidentdeletednodeisnotconsideredasatomcandidate,
since the edge is deleted together with the deleted node anyway.If a pair of transformations exists so that their match mappings
overlapontheatomcandidate,itiscalled conflictatom. Notethat,in
general, the matchesofsuch apairof transformationsmayoverlap
also in graph elements other than the conflict atom.
Aconflict reason s1=(C1⊇←S1e2→L2)for rule pair (r1,r2)
subsumesallatomsbeinginvolvedinaconflict. Amongtheconflict
reasonsfortworules,thereare minimalreasons describingminimal
compositions of atoms leading to conflict reasons.
In contrast to conflict reasons showing conflict-causing rule
overlaps,a criticalpair consistsoftwoconflicting transformations
applyingtworulesinaminimalcontext,whereallelementsstem
from L1orL2orboth. CriticalPairAnalysis(CPA)[ 27,48]isthe
state-of-the-art static CDA for graph transformation. The set of
critical pairs has the important property that it is complete: each
possible conflicting pair of transformations is represented by some
critical pair. Two important subsets of critical pairs being still
complete have been identified in the literature: An essential critical
pair[42] is one where the rules’ LHSs overlap merely deletion
graph elements of one rule with LHS elements of the other rule,i.e. only the conflict reason is overlapped. The rationale is that
overlappingadditionalpreservedelements(asdoneinregularCPA)doesnotcontributetonewconflicts. (Essential)Criticalpairscanbe
computedwiththestate-of-the-artimplementationoftheCPAin
AGG [59] and VeriGraph [ 5]. Aninitial conflict [40] is an essential
criticalpairwithoutisolatedboundarynodes. Thelatterarisewhen
a preserved node with incident deletion edges of the first rule isoverlapped with a node of the second rule without overlapping
720
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:36:22 UTC from IEEE Xplore.  Restrictions apply. any incident deletion edge of the first rule. Such overlaps do not
contribute to new conflicts. Initial conflicts represent currently
the most optimal subset of critical pairs fulfilling the completeness
property, but their detection has not been implemented yet.
Example [Conflict concepts]. Considering the conflict reason in
Figure 2, it is covered by two conflict atom graphs consisting of
node5,5:OrderItem and edge ownsfrom1,2:Customer to6,6:Good.
We can complete conflict atom 5,5:OrderItem to a minimal conflict
reason by adding both adjacent edges and their incident source or
target nodes. It is shown as top graph in Figure 1. The conflict
atomincludingthe ownsedgealreadyconstitutesaminimalconflict
reason shown underneath the top graph in Figure 1. Both together
form the conflict reason shown in Figure 2. Overlapping the LHSs
of both example rules at this conflict reason yields the graph in
Figure3. TheresultingLHSembeddingsintothisgraphareactually
rule matches since they fulfill the dangling condition (as shownabove). The corresponding transformations form a critical pair,
which is actually an initial conflict here.
Dependencyanddependencyconcepts. Forreasoningabout
dependencies,wheregraphelementsbeingproducedbythefirst
transformation are used by the second one, we simply consider the
dual concepts by inverting the first transformation of a conflicting
pair. Based on this analogy the concepts dependency between rules
and(minimal) dependency reason are defined accordingly.
4.2 Formalizing granularity levels
As suggested by the granularity requirements derived from our
literaturesurveyinSec.3,varioususe-casesmayrequireeitherfine-
grained, coarse-grained, and binary analysis results. To support all
of these granularity levels in our technique, we formalized each
granularitylevelwithappropriateconflictanddependencyconcepts
as outlined in this section. A full account of formal definitions,
characterizations and proofs is given in [43].
Overapproximation. Our survey (in Sec. 3) indicates serious
performanceproblemsin practicewhencomputingconflictinfor-
mation on a fine-grained level in the form of (essential) critical
pairs, as donein the state-of-the-artimplementation in AGG [ 59].
Thereforewe proposeasfirstimprovementa well-chosen overap-
proximation ofresultsthatiseasiertocompute. Itisbasedonthe
idea that, if there is a conflict for a pair of rules (r1,r/prime
2), then an
equivalent conflict exists for the rule pair (r1,r2)with r2being the
non-deletingvariant ofrule r/prime
2. Theotherdirectiondoesnothold,
since the dangling condition of rule r/prime
2could be violated then.
Mapping conflict concepts. Fig. 4 gives an overview of how
we further map conflict concepts to granularity levels.
Sinceinitialconflictsrepresentcurrentlythemostoptimalsubset
of critical pairs being still complete [ 40], we have chosen to return
allconflict reasons for(r1,r2)corresponding to initial conflicts as
newfine-grainedresults. Aninitialconflictfor (r1,r2)with r2being
non-deletingsimplycorrespondstotheoverlapofsuchaconflict
reason. As reported in Sec. 6, this choice represents a very good
trade-off between precision and performance.
Moving to the coarse-grained level, we selected minimal conflict
reasons, since our considered conflict reasons at the fine-grained
level are composed of minimal ones. The conflict graph of minimal
conflictreasonsforarulepair (r1,r2)with r2non-deletingcanbe
Figure 4: Conflict concepts & mapping to granularity
characterizedassubgraphofaso-calleddeletioncomponent. The
deletionpart L1\K1ofagivenrule r1mayconsistofseveraldis-
jointfragments,called deletionfragments. Completingadeletion
fragmenttoagraphbyaddingallincidentboundarynodesfrom B1
yieldsadeletioncomponent . Eachtwodeletioncomponentsoverlap
inboundarynodesonly;theunionofalldeletioncomponentscoin-
cides with the deletion graph C1of the rule. Deletion components
thus specify maximal partsof C1that need to be overlapped in or-
dertofindcorrespondingconflictingtransformations. Overlapping
more elements than present in a deletion component can neverlead to additional minimal conflict reasons since, if the dangling
condition of r1was not fulfilled before, it will never be fulfilled.
Example [Deletion components] RulereturnUnpaidGood in Figure 1
hasthreedeletionfragments: Node 5:OrderItem withadjacentedges,
node7:BillItem with adjacent edges, and edge ownsfrom node 1 to
node 6. For completing them to deletion components, boundary
nodes1:Customer, 2:Order,4:Bill, and 6:Goodareneeded.
Onthebinarylevel, wereportifa rulepairisconflicting, since
thismeansbydefinitionthatthereisatleastonepairofconflictingtransformations via these rules. In particular, we can check if there
isaminimalconflictreasonforthegivenrulepair (r1,r2)with r2
non-deleting, equivalent with the rule pair being conflicting.
Example[Granularitylevels] Twominimalconflictreasonsofrule
pair (returnUnpaidGood, offerGift) were discussed above. Hence,
thesetworulesareinconflict. Twofurtherminimalconflictreasons
ariseifnode5ofthefirstruleoverlapswithnode3ofthesecond
rule, and if node 6 of the first rule is overlapped with node 4 of the
secondone. Thesefourminimalreasonsformthecoarseanalysis
resultoftheconsideredrulepair. Togetherwithalltheirpossible
combinations, we get 6 conflict reasons being reported as “New
Fine” analysis result in Table 2.
Mapping dependency concepts. As mentioned before, a de-
pendency canbeunderstoodasdualconcepttoconflicts. Analogous
totheconflictcase,weoverapproximateproduce-usedependencies
by produce-read dependencies. Then dependencies between rules,
minimal dependency anddependency reasons are mapped to the
binary, coarse and fine granularity level accordingly.
5 ALGORITHM SUITE
We present an algorithm suite for computing binary, coarse and
fine-grainedconflicts. ItisimplementedinHenshin[ 3,57],amodel
transformationframeworkbasedongraphtransformationconcepts.
Given a pair of rules, we consider a non-deleting variant of
the second rule, supporting the overapproximation presented in
Section4.2. ThealgorithminFigure5computesminimalconflict
reasons(coarsegranularity). ThealgorithminFigure6usesthese
resultstocomputeallconflictreasons(finegranularity). Tosupport
use-cases where binary granularity is sufficient, we can stop the
computation as soon as one minimal conflict reason is discovered.
721
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:36:22 UTC from IEEE Xplore.  Restrictions apply. 1:functcomputeMinReasons( r1:Rule ,r2:Rule)
2:varreasons ←∅
3:for eachc←ComputeAtomCandidates( r1,r2)do
4: computeMinReasonsRecursively( r1,r2,c,reasons )
5:returnreasons
6:
7:functcomputeAtomCandidates( r1:Rule ,r2:Rule)
8:varcandidates ←∅
9:for eachel1←r1.conflictInducinдElements do
10: for eachel2←r2.lhs .occurenceOf (el1)do
11: varS1←newGraph({el1})
12: varembed r1←newMappinд ({el1/mapsto→el1})
13: varembed r2←newMappinд ({el1/mapsto→el2})
14: candidates +=newSpan(S1,embed r1,embed r2)
15:returncandidates
16:
17:functcomputeMinReasonsRecursively( r1:Rule ,r2:Rule ,s1:
Span ,reasons :Set<Span>)
18:var(G,m1,m2)←constructOverlap( r1,r2,s1)
19:varisCR s1←findDanдlinдEdдes (r1,m1).isEmpty ()
20:ifisCR s1thenreasons +=s1;return; else
21:for eachs2←extendSpan( r1,r2,s1,reasons )do
22: computeMinReasonsRecursively( r1,r2,s2,reasons )
23:
24:functextendSpan( r1:Rule ,r2:Rule ,s1:Span ,reasons :Set<Span>)
25:var(G,m1,m2)←constructOverlap( r1,r2,s1)
26:vardanдlinд ←findDanдlinдEdдes (r1,m1)
27:varfixinд←danдlinд .foreach(findFixinдEdдes (r1,r2,s1))
28:returnaддeдrate (fixinд .foreach(enumerateExtensions (s1)))
Figure 5: Computing minimal conflict reasons.
Computing minimal conflict reasons. For efficiency, we
use the characterization of minimal conflict reasons as introduced
in Sect. 4.2. The key idea is to compute first the set of all conflict
atom candidates (line 3). To this end, all conflict-inducing elements
ofr1are identified in line 9. Each match of such an element to
r2(line 10) is extended to a span (lines 11–14) yielding an atom
candidate. Next, we try to extend each atom candidate to minimal
conflict reasons (line 4) recursively and return the results (line 5).
Todetermineefficientlyifaparticularcandidatecanbeextended
to a minimal conflict reason recursively, we check if it gives rise to
a critical pair by computing the overlap graph Gof the rules’ LHSs
alongthecandidate(line18)andcheckingifthecorrespondingem-
beddings m1:L1→Gandm2:L2→Gare rule matches (line 19).
Sinceweassume r2tobenon-deleting, m2isautomaticallyamatch.
Weare finishedif m1isa matchas well(i.e. if r1canbe appliedat
embedding m1without producing dangling edges) meaning that
we found a reason (line 20). Otherwise, we extend candidate spans
inpotentiallyseveralways(line21),discardingfurtherextension
opportunities in case we identified a conflict reason. We computed
all extensions by function extendSpan() (line 24). A span s1has
to be extended if the rule’ LHS embeddings into a given overlap
graphdo notfulfillthe danglingcondition(line 25). Anextension
isperformedstepwisebyfirstidentifyingalldanglingedges(line
26). For each of them a set of fixing edges in r2is searched (line
27). Suitable candidates for this purpose are all adjacent edges ein
C1\S1ofe’s adjacent node in S1being identified by calling find-
FixingEdges(). For each fixing edge, function enumerateExtensions()
(line 28) yields a set of spans, each extending s1by an edge and its
adjacentnodeifnotpreviouslyincludedin s1. Allthesesetshave
to be aggregated to obtain the result (line 28). Since we know that
aminimalconflictreasonisalwayspartofadeletioncomponent,
wehaveastoppingcriterionfortheextensionprocess,aswecan
focus on adjacent edges when computing extensions.Computing conflict reasons. Starting from a set of minimal
conflictreasons,allconflictreasonscanbecomposedofthem. Func-
tionComputeConflictReason inFigure6picksanyminimalreason
mroutofagivenset(line4),addsitasreason(line5),andcomposes
itwiththeset subReasons ofallconflictreasonscomputedfromthe
remaining set of minimal reasons (lines 7–12). All conflict reasons
insubReasons arefirstofallconflictreasonsthemselves(line9)and
second to be composed with mrif composable (lines 11–12).
1:functcomputeConflictReasons( minReasons :Set<Span>)
2:varreasons ←∅
3:ifminReasons .nonEmpty ()
4:then varmr←minReasons .pickAny ()
5: reasons .add(mr)
6: ifminReasons .size≥2
7: then varsubReasons =computeConflictReasons (
8: minReasons .remove(mr))
9: reasons .add(subReasons )
10: for eachs:subReasons do
11: ifisComposable (mr ,s)
12: thenreasons .add(compose (mr ,s))
13:returnreasons
Figure 6: Computing conflict reasons.
Computingdependencyreasons. Weinvertrule r1,compute
all conflict reasons, and interpret them as dependency reasons.
Implementation. We implemented the algorithm suite for
the Henshin model transformation language, which is based ongraph transformation concepts and the Eclipse Modeling Frame-
work (EMF). Our implementation includes a comprehensive test
suite,inwhichthetestoracleisprovidedbycomputingfine-grained
conflicts in the state-of-the-art CDA framework AGG. Section 6
studies the performance of our implementation.
6 IMPLEMENTATION EVALUATION
We evaluated our analysis via comparison to the existing analysis
inAGG,focusingontworesearchquestions: RQ1:Howfastareour
coarseandfine-grainedanalysesinrelationtotheexistinganalysis
in AGG? RQ2: What is the degree of the overapproximation of the
multi-granular CDA technique?
We performed our evaluation on three subject rule sets, all
of them representing use-cases identified in Sect. 3: Refac is a
setofrefactoringrulesasusedinrefactoringrecommenders[ 46].
FMedit is a set of editing rules that was proposed in [ 58]a sa
benchmark for edit operation detection [ 35]. NanoXML is a set
of rules that was reverse-engineered from the Java code for asmall XML parser [
1] to provide an oracle for test case genera-
tion[54]. Theimplementationandevaluationartifactsareavailable
athttps://github.com/KristopherBorn/multiCDA.
RQ1.We considered the essentialCPA in AGG and compared
it with our computations of minimal conflict/dependency reasons
(MCR/MDR) as coarse-grained analysis and conflict/dependency
reasons (CR/DR) as fine-grained one. We analyzed delete-use-
conflictsbetweeneachrulepairconsideringanon-deletingversion
of the “use”rule in each case. Moreover, we preprocessedthe rule
set and meta-model such that they fit to the features supported by
AGG and by our implementation. In the results (Table 4), we ob-
served that our approach achieved a major speed-up from e.g. over
8 minutes to 5 seconds for 1681 rule pairs. In terms of quantity, we
see that the mean number of results dropped considerably for the
722
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:36:22 UTC from IEEE Xplore.  Restrictions apply. Runtime (m:ss.x) #Results (mean)
#Rule MCR CR ess.MCR CR ess.
Rule set pairsMDR DR CPAMDR DR CPA
Refac 64 0:00.3 0:00.3 0:08.7 1.0 1.4 2.6
FMedit 1681 0:05.3 0:16.3 8:41.1 0.5 1.3 2.6
NanoXML 1296 0:04.6 0:04.7 1:30.4 0.2 0.2 0.2
Table 4: RQ1 results from our coarse (MCR/MDR) and fine-
grained(CR/DR)vs. theexistinganalysisinAGG(ess. CPA).
Rule set prec.recall
Refac 0.88 1.0
FMedit 0.98 1.0
NanoXML 1.01.0
Table 5: Overapproximation results
larger cases, e.g. from 2.6 to 0.5 for FMedit rule pairs. There were
even more striking results for individual rule pairs. In the most
extremecase,wehad1588ess. criticalpairs,644conflictreasons,
and 24 min. conflict reasons. A trend towards excessive individual
casesisreflectedinahigherstandarddeviationofresults,which
in the FmEdit case amounted to 1.4 for coarse-grained, 18.2 for
fine-grained, and 49.1 for the essential CPA results.
RQ2.We computed the sets of essential critical pairs (ess. CPs)
for an original rule pair and the one for a pair where the second
rule is the non-deleting variant of the original one. Both sets of
ess. CPs have been filtered w.r.t. initial conflicts (dependencies).
Theprecisionisthepercentageofrulepairswithequalnumbersof
initial conflicts (dependencies). Since we do an overapproximation,
the recall is always 1.0, i.e., we do not miss a critical pair when
switching to the non-deleting rule variant. The precision, however,
happenstobesmallerthan1.0,i.e.,falsepositivescanoccur. Asthe
results in Table 5 show, the resulting precision is still acceptable.
Threadstovalidity. External validity can be questioned since
we focus on a limited number of rule sets being preprocessed ac-
cordingtounsupportedfeaturessuchasapplicationconditions[ 19]
andamalgamation[ 11]. Weintendtosupportmoretransformation
featuresinthefuture,thusenablingamorecomprehensivestudy
with more expressive subject rule sets.
7 USER STUDY
Thegoalofouruserstudyistotesttheusefulnessofourtechnique’s
output compared to that of its predecessor, critical pair analysis
(CPA).AsdiscussedinSection3,inmanyuse-cases,coarse-grained
results may provide a more suitable level of detail than the fine-grained ones produced by CPA. Focusing on such use-cases, weinvestigated the following research question: How useful are our
coarse-grained results compared to fine-grained ones?
Weconductedauserstudyinwhichcomprehensiontaskshad
to be solved based on conflict analysis results. The analysis results
wereembeddedas screenshotsinto anonline questionnaire. With
this web-based setup, we aimed to recruit a sufficient number of
participantswithappropriateexpertiseingraphtransformations.
Areplicationpackagewithalltasksanddatafromouruserstudy
is available at http://uni-marburg.de/y35ak.
Focusing on the usefulness concerns of user performance and
perception, our null hypotheses were as follows: (H0perf)Users
can solve comprehension tasks equally well using the given coarse-
and fine-grained results; (H0perc)Users perceive the usefulness of thegiven coarse- and fine-grained results as equal. We used a standard
experimental setup involving independent, dependent, and con-
trolledvariables. Granularitywastheindependentvariable. User
performance and perception were the dependent variables. We
controlled the used examples and the chosen visualization by keep-
ing them constant. All analysis results were shown in the result
visualization of AGG [59].
Methods,participants,materials. Ourstudydesignisa cross-
overstudy,avariantof within-subjectdesign [34]inwhichallpar-
ticipants are sequentially exposed to both treatments (here: coarse-
and fine-grained analysis results). We selected this design because
itminimizesthenumberofparticipantsnecessarytoidentifysta-
tisticallysignificantdifferencesbetweentheresulttypes. Themain
threattothevalidityforthisdesignarelearningeffects. Welater
discuss threats and adopted mitigation measures.
The experiment took place in Summer 2017. To recruit sub-
jectswithappropriateexpertise,weinvitedparticipantsofrecent
software engineering conferences focusing on model and graph
transformations, and authors of the papers surveyed in Sect. 3. Wesent invitations to 131 persons, 33 of which participated in the sur-
vey. Our overall sample consisted of 24 academic/scientists, 5 PhD
students, 3 practitioners, and 1 MSc student. To survey the shared
software-engineeringandgraph-transformationbackgroundofour
participants, we collected demographic data based on five-pointLikert scales. 30 respondents rated their experience with UML-based modeling 3 or higher (20 of them
≥4), like 32 did for their
graph-transformationexperience(in27cases ≥4),25participants
rated their experience as CDA users as 3 or higher (14 cases ≥4).
The questionnaire was made up of three parts: an instruction
part, an experimental part, and a survey part. The instruction part
used an example to revisit basics about conflicts of graph transfor-
mationsandfamiliarizetheparticipantswiththeusedvisualization.
Thecomprehension partincludedquestion-basedcomprehension
tasks. In the surveypart, we aggregated the demographic informa-
tion and asked the participants for their subjective experiences.
The instruction and comprehension parts used a common ex-
ample domain, namely the detection of conflicting requirements
during the development of an online shop. The rationale for choos-
ing this domain was twofold: First, it did not require expertise in a
specializedtechnicalenvironment. Second,itisbasedonause-case
in which we hypothesize that coarse-grained results are beneficial,
namely consistency validation of use-cases [ 26]. The example in
Sect. 2 is representative for this example domain and use-case.
In the comprehension part, each participant solved two tasks,
one for each granularity level. Each task included an example
rule pair, anumber of conflictanalysis results, and twoquestions:
First, whether any conflicts existed for the rule pair. Second, if the
firstquestionwasanswered“yes”,weaskedtonamethespecific
elements causing the conflicts. The rule pairs and their order were
thesameforeachparticipant. Theorderofthegranularitylevels
used to present the conflicts was assigned randomly. Based on the
questions, the task metrics were measured as follows: A correct
answerforthefirstquestionwasrewardedwith1point. Thesecond
questionwasmorecomplicated,whichwasreflectedin2pointsfor
a fully and 1 point for a partially correct answer. The time needed
to complete both tasks was measured using the questionnaire.
723
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:36:22 UTC from IEEE Xplore.  Restrictions apply. Table 6: User study results.
Conflict type Correctness Completion time Understandability Simplicity Effort
5=hard to understand 5=hard to solve tasks 5=much effort
Fine-grained 93.9 % (± 13.0 %) 7.7 min (± 6.6 min) 2.6/5( ±0.9) 2.5/5( ±1.0) 2.9/5( ±1.1)
Coarse-grained 91.9 % (± 14.5 %) 5.7 min (± 2.9 min) 2.0/5( ±0.9) 2.0/5( ±1.1) 2.0/5( ±0.9)
p = 0.42 p = 0.10 p = 0.004 p = 0.008 p ≤0.001
We tested the tasks in a prestudy with 10 participants, in which
we experimented with various difficulty levels. We aimed to bal-
ancecomplexity—thedrawbacksoffine-grainedresultsaremore
obviousforcomplexexamplesandtasks—andsimplicity,toavoid
participant exhaustion and to benefit completion rate. To this end,
we decided to drop additional tasks concerning dependency ana-
lysisandconflictrepair. Theactualtasksusedinourexperiment
were based on the conflict example shown in Sect. 2 (Task 1) and a
comparableone(Task2). Fine-grainedresultsrepresentessential
critical pairs, as provided by the state-of-the-art CDA tool AGG.
Coarse-grained results are those of our multi-granular CDA.
In the survey part, to measure user perception, the participants
wereaskedfortheirsubjectiveassessmentofbothgranularitylevels.
Three metrics were collected using five-point Likert scales: ratings
of understandability ("How easy was it to understand the results
of type X? "), difficulty of solving tasks ("‘How difficult was it to
answer the questions using the results of type X? "), and perceived
effort ("‘How much effort was required to answer the questions using
the results of type X? "’). Finally, we asked them for their overall
preferencebetweenbothgranularitylevelsonafive-pointLikert
scale. Additionalqualitativeinformationregardingthesubjective
assessment was collected using free-form text fields.
For statistical hypothesis testing, we used the Wilcoxon signed-
ranked test [ 22] and, where applicable, the paired-samples t-test
[63]. Wilcoxon is a standard nonparametrized test that supports
high-confidence inferences for paired data. The t-test providesgreater statistical power than Wilcoxon for normally distributed
data. We checked for normality using the Shapiro-Wilk test [55].
Figure 7: Correctness and completion time.
Results. Table 6 summarizes the results in terms of descrip-
tive and inferential statistics. The task metrics are visualized with
boxplotsinFig.7. Irrespectiveofwhethercoarse-orfine-grained
detection results were used, the vast majority of all participants
answered the tasks with full correctness scores. The mean time re-
quired to complete the tasks was shorter by 33 % (2 minutes) when
coarse-grained results were used. Yet, the completion times for the
fine-grainedcaseincludedtwoexcessivedatapointsof28and31
minutes,whichcanbeconsideredasoutliers. Afterremovingthem,
themeancompletiontimeforcoarse-grainedisstilllowerby0.6
minutes. Thecompletiontimesdidnotnotdiffertoastatistically
significant extent (p=0.10). In summary, since we cannot find a
significant effect on correctness and completion time, our first null
hypothesis H0perfcannot be rejected.Theperceptionmetricsofunderstandability,difficulty,andeffort
are visualized in Fig. 8. In all cases, the participants reported more
positive (70–79 % vs. 36–55 %), fewer negative (9–12% vs. 18–36
%),andfewerneutralscores(12–18%vs. 24–33%)whenworking
withthecoarse-graineddetectionresults: theyexperiencedbetter
understandability, ease ofsolving tasks, and less effort. The differ-
ences were strongly statistically significant (p ≤0.01). In summary,
our second null hypothesis H0percis rejected.
Figure 8: User perception and preference.
Finally, we asked for an overall subjective preference. Fig. 8
givesadistributionoverview: coarse-grainedresultsattractedmore
subjectivepreferencesthanfine-grainedones. Infact,theoverall
sample ismostly divided intotwo groups: those participantswith
a preference for the coarse-grained results (48%, 30 % of them with
a strong preference), and those without a preference (42 %).
In qualitative information collected using the questionnaire, we
found that the reasons for preferring were largely in line with our
motivation: Participants found that “less results provided a quicker
overview”,andthatcoarse-grainedresults “boildowntheproblemto
actual distinguish conflicts” . Some subjects extrapolated from our
taskstomorecomplexcases: “Assumingthatwehavealargersetof
rulesthatconflictwitheachother,I’dassumethatthe[fine-grained]results will become very complex and hard to understand ”.
Wealsofoundreasonswhythispreferencewasnotsharedunan-
imously. Someparticipantsfoundtheredundancyoffine-grained
beneficial as it “presented conflicts more consistently ” and felt that
coarse-grainedresultsdidnotmirrortheirunderstandingofcon-
flicts:“I believe that [fine-grained] displays all conflicts, whereas
[coarse-grained]onlydisplaysselectedconflicts.” Thisgroupofusers
maystillbenefitfromourfastercomputationoffine-grainedresults.
724
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:36:22 UTC from IEEE Xplore.  Restrictions apply. Threats to Validity. Construct validity. For our effort and un-
derstandability measurements, we rely on subjective ratings by the
participants. However,such subjectivemeasures arehighlycorre-
lated with objective measures of cognitive load [ 24]. Moreover, we
aimed to avoid participant bias in favor of the experimenters by re-
placingthenamesoftheusedtoolsandconceptswithpseudonyms.
Internal validity. The main threat in our within-subject design
are learning effects, in particular, since the same questions were
askedforeachanalysisresulttype(albeitfordifferenttasks). We
mitigated this threat by using counterbalancing, i.e., randomizing
the order in which the results were shown to the participants.
External validity. We addressed external validity by recruiting
asufficientlylargenumberofparticipantswithrelevantsoftware
engineering and CDA expertise. However, our web-based setup
requiredsometrade-offs: thesampleanalysisresultswererelatively
small(3–10entries)and wereshownusingscreenshotsinsteadof
in the actual tool. Generalizations to a greater variety of use-cases
arethreatenedsinceweconsideredasingledomainanduse-case.
While our discussion in Sect. 3 highlights key similarities to other
domains, a definitive verdict on the practical usefulness of coarse-
grained results is outside the scope of this paper.
Summary. Having identified use-cases in which the level of de-
tail offered by our coarse-grained results seems sufficient (Sect. 3),
we set out to empirically study their usefulness in one such use-
case. While we did not detect an effect on participants’ perfor-
mance,theparticipantsperceived coarse-grained resultsaseasier
to understand and work with than fine-grained ones. The relative
majority of participants preferred coarse-grained over fine-grained
results. Our user study complements significant performance bene-
fit achieved by our multi-granular computations and, to the best
of our knowledge, provides the first empirical evidence on the
usefulness of CDA for graph transformation.
8 RELATED WORK
Inthispaper,wehavepresentedageneric,multi-granularCDAtech-
niquebasedongraphtransformation(GT)whichisstaticallyanalyz-
ingtransformationrules;itisfullyautomaticandstate-independent.
We compare with other analysis techniques along these aspects.
FurtherGTanalysistechniques. Anotherstaticanalysis tech-
niqueforGTchecksforinvariants[ 7,9]. Incontrast, modelchecking
techniques forGT[21,51]needaninitialstartgraphandthengener-
ateforthisgraphandagivenrulesetacorrespondingstatespaceinorder to analyze more complex temporal logic properties. Whereas
bothkindsofanalysistechniquesarefullyautomatic,thereexist
alsointeractivetheoremprovingtechniques dedicatedtoGTthatare
able to prove partial correctness of graph programs [25, 49].
With respect to designing and performing analysis techniques
withdifferentgranularitylevels ,wecanrelateourworkinabroader
sensetotheworkon counterexampleguidedabstractionrefinement
(CEGAR)initiallydescribedin[ 14]andappliedtotheanalysisof
GTin [37]. Ourapproach containsa similarideain thesense that
weperformastepwiseanalysistechniquewithdifferentlevelsof
accuracyandterminatewiththelevelofaccuracythatisneeded.IntheCEGARapproachthedesiredlevelofaccuracyisobtained
if either the desired property for the analyzed system is success-fully verified or a real counterexample has been detected. In ourapproachtherecanbemanydifferentuse-casestobesatisfiedwith
acertainlevelofaccuracyoftheanalysisasdescribedindetailin
the literature review in Section 3.
Other genericCDA techniques. Besides GT there exist other
formal approaches which allow for static and dynamic CDA of
specifiedsystems. AChurch-Rosser-Checkerforequationalspecifi-
cationsinMaude[ 16]looksforcriticalpairsbetweenconditional
term rewriting rules and tries to join them. There are also logic-
basedapproachessuchas conditionaltransformations [36]provid-
ing static CDA techniques. These techniques are generic and there-
fore language-independent but the analysis techniques provided
arenotmulti-granular. Furtherlogic-basedapproachessuchas con-
straint networks andmodel checking approaches such as Alloy [ 32]
are not state-independent.
Language-specific CDA techniques. There are many sophis-
ticatedCDAtechniquesinthecontextofsequentialandconcurrent
programming. In the context of concurrent threads, conflicts arecalled
data races ; they occur if two different threads access the
same memory location and at least one of them is a write (see
e.g. [28,56]). Common challenges of these techniques are dynamic
object creation, dynamic thread creation, and references to ob-
jects[52]. Similarly,therehasbeenalonglineofworksdeveloping
data flow analyses to find dependencies between object changes
and accesses; for example, static taint analyses have been recently
developed for Android applications as e.g. FlowDroid [ 4]. These
CDAtechniquesdifferconsiderablytooursinseveralaspects: they
arenotgenericbuthavebeenspecificallydevelopedtofindbugs
in implementations. To the best of our knowledge, there are no
language-specificCDAtechniquesforreasoningaboutsoftwareen-
gineering activities. Language-specific CDA techniques are mostly
dynamic andtherefore state-dependent. Thisis oftennot suitable
for engineering activities such as refactorings which are speci-
fied state-independently. Moreover these CDAs are usually not
multi-granular so that gradual analysis time reduction and easy
understanding are not especially supported.
9 CONCLUSION
In this paper, we presented a novel static CDA technique for graph
transformation which can detect conflicts and dependencies in
software engineering on multiple granularity levels. Compared to
thestate-of-the-artCDA,wewereabletosignificantlyspeed-upthe
computation of fine-grained CDA results and to complement them
withcoarse-grainedonesofferingusabilitybenefitsfornumerous
use-cases. Our technique is especially advantageous for analyzing
interactions on complex and dynamic object structures as, e.g., for
feature interaction in software product line engineering.
Ourmulti-granularCDAtechniquecurrentlyusestransforma-
tion rules without advanced features such as application condi-
tions [19] and amalgamation [ 11], for which the state-of-the-art
CDA technique has been investigated already. In the future, weaim to support these more complex concepts in our techniqueas well. Due to the major speed-up we could achieve with our
multi-granularapproach,thistechniquehasnowthepotentialto
be applied in fields where performance plays a larger role.
Acknowledgements. Wewishtothankallparticipantsofthe
user (pre-)study for their participation and constructive feedback.
725
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:36:22 UTC from IEEE Xplore.  Restrictions apply. REFERENCES
[1]A.AlshanqitiandR.Heckel,“ExtractingVisualContractsfromJavaPrograms
(T),” inASE, 2015, pp. 104–114.
[2]Z.Altahat,T.Elrad,L.Tahat,andN.Almasri,“Detectionofsyntacticaspectinter-
actioninUMLstatediagramsusingcriticalpairanalysisingraphtransformation,”
CoRR, vol. abs/1312.6939, 2013.
[3]T. Arendt, E. Biermann, S. Jurack, C. Krause, and G. Taentzer, “Henshin: ad-
vanced concepts and tools for in-place EMF model transformations,” in MoDELS.
Springer, 2010, pp. 121–135.
[4]S.Arzt,S.Rasthofer,C.Fritz,E.Bodden,A.Bartel,J.Klein,Y.LeTraon,D.Octeau,
and P. McDaniel, “Flowdroid: Precise context, flow, field, object-sensitive and
lifecycle-aware taint analysis for android apps,” SIGPLAN Not., vol. 49, no. 6, pp.
259–269, Jun. 2014.
[5]G.G.Azzi,J.S.Bezerra,L.Ribeiro,A.Costa,L.M.Rodrigues,andR.Machado,
“The Verigraph System for Graph Transformation,” in Graph Transformation,
Specifications, and Nets. In Memory of Hartmut Ehrig. Springer, 2018, pp. 160–
178.
[6]L.Baresi,K.Ehrig,andR.Heckel,“Verificationofmodeltransformations: Acase
study with BPEL,” in TGC, 2007, pp. 183–199.
[7]B. Becker, D. Beyer, H. Giese, F. Klein, and D. Schilling, “Symbolic invariant
verificationforsystemswithdynamicstructuraladaptation,”in ICSE,2006,pp.
72–81.
[8]P.Bhattacharya,M.Iliofotou,I.Neamtiu,andM.Faloutsos,“Graph-basedanalysis
and prediction for software evolution,” in ICSE, 2012, pp. 419–429.
[9]C. Blume, H. J. S. Bruggink, and B. König, “Recognizable graph languages for
checking invariants,” ECEASST, vol. 29, 2010.
[10]K.Born,L.Lambers,D.Strüber,andG.Taentzer,“Granularityofconflictsand
dependencies in graph transformation systems,” in ICGT, 2017, pp. 125–141.
[11]K.BornandG.Taentzer,“Analgorithmforthecriticalpairanalysisofamalga-
mated graph transformations,” in ICGT, 2016, pp. 118–134.
[12]P. Bottoni, G. Taentzer, and A. Schürr, “Efficient parsing of visual languages
basedon criticalpairanalysisand contextuallayeredgraphtransformation,” in
VL/HCC, 2000, pp. 59–60.
[13]A. Bucchiarone, P. Pelliccione, C. Vattani, and O. Runge, “Self-repairing systems
modeling and verification using AGG,” in WICSA/ECSA, 2009, pp. 181–190.
[14]E. M. Clarke, O. Grumberg, S. Jha, Y. Lu, and H. Veith, “Counterexample-guided
abstraction refinement,” in CAV, 2000, pp. 154–169.
[15]S.Degrandsart,S.Demeyer,J.VandenBergh,andT. Mens,“Atransformation-
based approach to context-aware modelling,” Software & Systems Modeling,
vol. 13, no. 1, pp. 191–208, 2014.
[16]F.DuránandJ.Meseguer,“AChurch-RosserCheckerToolforConditionalOrder-
Sorted Equational Maude Specifications,” in WRLA, 2010, pp. 69–85.
[17]H. Ehrig, K. Ehrig, U. Prange, and G. Taentzer, Fundamentals of Algebraic Graph
Transformation,ser.MonographsinTheoreticalComputerScience. Springer,
2006.
[18]H. Ehrig, G. Engels, H.-J. Kreowski, and G. Rozenberg, Eds., Handbook of Graph
Grammars and Computing by Graph Transformation: Vol. 3: Applications, Lan-
guages, and Tools. World Scientific Publishing, 1999.
[19]H. Ehrig, U. Golas, A. Habel, L. Lambers, and F. Orejas, “M-adhesive transfor-
mation systemswith nested application conditions.part 2: Embedding, critical
pairs and local confluence,” Fundam. Inform., vol. 118, no. 1-2, pp. 35–63, 2012.
[20]C. Ermel, J. Gall, L. Lambers, and G. Taentzer, “Modeling with plausibility check-
ing: Inspecting favorable and critical signs for consistency between control flow
and functional behavior,” in FASE. Springer, 2011, pp. 156–170.
[21]A.H.Ghamarian,M.deMol,A.Rensink,E.Zambon,andM.Zimakova,“Mod-
elling and analysis using GROOVE,” STTT, vol. 14, no. 1, pp. 15–40, 2012.
[22]J. D. Gibbons and S. Chakraborti, “Nonparametric statistical inference,” in Inter-
national encyclopedia of statistical science. Springer, 2011, pp. 977–979.
[23]H. Giese, S. Hildebrandt, and L. Lambers, “Bridging the gap between formal
semanticsandimplementationoftriplegraphgrammars,” Software&Systems
Modeling, vol. 13, no. 1, pp. 273–299, 2014.
[24]D.GopherandR.Braune,“Onthepsychophysicsofworkload: Whybotherwith
subjective measures?” Human Factors, vol. 26, no. 5, pp. 519–532, 1984.
[25]A. Habel and K. Pennemann, “Correctness of high-level transformation sys-
tems relative to nested conditions,” Mathematical Structures in Computer Science,
vol. 19, no. 2, pp. 245–296, 2009.
[26]J.H.Hausmann,R.Heckel,andG.Taentzer,“DetectionofConflictingFunctional
Requirements in a Use Case-Driven Approach: A Static Analysis Technique
Based on Graph Transformation,” in ICSE, 2002, pp. 105–115.
[27]R. Heckel, J. M. Küster, and G. Taentzer, “Confluence of Typed Attributed Graph
Transformation Systems,” in ICGT, 2002, pp. 161–176.
[28]T.A.Henzinger,R.Jhala,andR.Majumdar,“Racecheckingbycontextinference,”
inPLDI, 2004, pp. 1–13.
[29]F.Hermann,H.Ehrig, U.Golas,andF.Orejas,“Efficientanalysis andexecution
ofcorrectandcompletemodeltransformationsbasedontriplegraphgrammars,”
inMDI, 2010, pp. 22–31.[30]F. Hermann, H. Ehrig, F. Orejas, and U. Golas, “Formal analysis of functional
behaviour for model transformations based on triple graph grammars,” in ICGT,
2010, pp. 155–170.
[31]S.Hildebrandt,L.Lambers,andH.Giese,“Completespecificationcoveragein
automatically generated conformance test cases for tgg implementations,” in
ICMT, K. Duddy and G. Kappel, Eds., 2013, pp. 174–188.
[32]D. Jackson, “Alloy: A lightweight object modelling notation,” ACM Trans. Softw.
Eng. Methodol., vol. 11, no. 2, pp. 256–290, Apr. 2002.
[33]P.Jayaraman,J.Whittle,A.M.Elkhodary,andH.Gomaa,“Modelcomposition
in product lines and feature interaction detection using critical pair analysis,” in
MoDELS, 2007, pp. 151–165.
[34]B.JonesandM.G.Kenward, Designandanalysisofcross-overtrials. CRCPress,
2014.
[35]T. Kehrer, U. Kelter, and G. Taentzer, “Consistency-Preserving Edit Scripts in
Model Versioning,” in ASE, 2013, pp. 191–201.
[36]G. Kniesel, “Detection and resolution of weaving interactions,” Trans. Aspect-
Oriented Software Development, vol. 5, pp. 135–186, 2009.
[37]B.KönigandV.Kozioura,“Counterexample-guidedabstractionrefinementfor
the analysis of graph transformation systems,” in TACAS, 2006, pp. 197–211.
[38]C.Krause,Z.Maraikar,A.Lazovik,andF.Arbab,“Modelingdynamicreconfig-
urations in reo using high-level replacement systems,” Sci. Comput. Program.,
vol. 76, no. 1, pp. 23–36, 2011.
[39]J. M. Küster, C. Gerth, and G. Engels, “Dependent and conflicting change opera-
tions of process models,” in ECMDA-FA, 2009, pp. 158–173.
[40]L. Lambers, K. Born, F. Orejas, D. Strüber, and G. Taentzer, “Initial conflicts and
dependencies: Criticalpairsrevisited,”in GraphTransformation,Specifications,
and Nets. In Memory of Hartmut Ehrig. Springer, 2018, pp. 105–123.
[41]L. Lambers, H. Ehrig, L. Mariani, and M. Pezzè, “Iterative model-driven develop-
ment of adaptable service-based applications,” in ASE, 2007, pp. 453–456.
[42]L.Lambers,H.Ehrig,andF.Orejas,“Efficientconflictdetectioningraphtrans-
formationsystemsbyessentialcriticalpairs,” Electr.NotesTheor.Comput.Sci.,
vol. 211, pp. 17–26, 2008.
[43]L. Lambers, D. Strüber, G. Taentzer, K. Born, and J. Hübert, “Multi-granular conflict and dependency analysis in software engineering basedon graph transformation: Extended version,” 2018, https://www.uni-
marburg.de/fb12/arbeitsgruppen/swt/forschung/publikationen/.
[44]P. Leenheer and T. Mens, “Using graph transformation to support collaborative
ontology evolution,” in AGTIVE, 2008, pp. 44–58.
[45]K. Mehner-Heindl, M. Monga, and G. Taentzer, “Analysis of Aspect-Oriented
Models Using Graph Transformation Systems,” in Aspect-Oriented Requirements
Engineering, A. Moreira, R. Chitchyan, J. Araújo, and A. Rashid, Eds. Springer,
2013, pp. 243–270.
[46]T. Mens, G. Taentzer, and O. Runge, “Analysing refactoring dependencies using
graphtransformation,” Softwareand SystemModeling, vol.6, no.3, pp.269–285,
2007.
[47]T. Mens, R. Van Der Straeten, and M. D’Hondt, “Detecting and resolving model
inconsistencies using transformation dependency analysis,” in MoDELS, 2006,
pp. 200–214.
[48]D.Plump,“CriticalPairsinTermGraphRewriting,”in MathematicalFoundations
of Computer Science, vol. 841, 1994, pp. 556–566.
[49]C.M.PoskittandD.Plump,“Verifyingmonadicsecond-orderpropertiesofgraph
programs,” in ICGT, 2014, pp. 33–48.
[50]F.QayumandR.Heckel,“Localsearch-basedrefactoringasgraphtransformation,”
inSSBSE, 2009, pp. 43–46.
[51]A. Rensink, Á. Schmidt, and D. Varró, “Model checking graph transformations:
A comparison of two approaches,” in ICGT, 2004, pp. 226–241.
[52] M. C. Rinard, “Analysis of multithreaded programs,” in SAS, 2001, pp. 1–19.
[53]G. Rozenberg, Ed., Handbook of Graph Grammars and Computing by Graph
Transformations, Volume 1: Foundations. World Scientific, 1997.
[54]O.Runge,T.A.Khan,andR.Heckel,“Testcasegenerationusingvisualcontracts,”
ECEASST, vol. 58, 2013.
[55]S.S.ShapiroandM.B.Wilk,“Ananalysisofvariancetestfornormality(complete
samples),” Biometrika, vol. 52, no. 3/4, pp. 591–611, 1965.
[56]Y. Smaragdakis, J. Evans, C. Sadowski, J. Yi, and C. Flanagan, “Sound predictive
racedetectioninpolynomialtime,” SIGPLANNot.,vol.47,no.1,pp.387–400,Jan.
2012.
[57]D.Strüber,K. Born,K. D.Gill, R.Groner, T.Kehrer,M. Ohrndorf,and M.Tichy,
“Henshin: Ausability-focusedframeworkforemfmodeltransformationdevelop-
ment,” in ICGT. Springer, 2017, pp. 196–208.
[58]D. Strüber, T. Kehrer, T. Arendt, C. Pietsch, and D. Reuling, “Scalability of Model
Transformations: Position Paper and Benchmark Set,” in BigMDE, 2016, pp.
21–30.
[59]G. Taentzer, “AGG: A graph transformation environment for modeling and
validation of software,” in AGTIVE, 2003, pp. 446–453.
[60]G. Taentzer, C. Ermel, P. Langer, and M. Wimmer, “Conflict detection for model
versioning based on graph modifications,” in ICGT, 2010, pp. 171–186.
[61]J. Whitehead, “Collaboration in software engineering: A roadmap,” in Future of
Software Engineering @ ICSE, 2007, pp. 214–225.
726
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:36:22 UTC from IEEE Xplore.  Restrictions apply. [62]J. Whittle, P. Jayaraman, A. Elkhodary, A. Moreira, and J. Araújo, “MATA: A
unified approach for composing UML aspect models based on graph transforma-
tion,”Transactions on Aspect-Oriented Software Development VI: Special Issue on
Aspects and Model-Driven Engineering, pp. 191–237, 2009.
[63]D. W. Zimmerman, “Teacher’s corner: A note on interpretation of the paired-
samples t test,” Journal of Educational and Behavioral Statistics, vol. 22, no. 3, pp.
349–360, 1997.
727
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:36:22 UTC from IEEE Xplore.  Restrictions apply. 