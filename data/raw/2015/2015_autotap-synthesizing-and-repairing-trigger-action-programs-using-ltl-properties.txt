AutoTap: Synthesizing and Repairing
Trigger-Action Programs Using LTL Properties
Lefan Zhang, Weijia He, Jesse Martinez, Noah Brackenbury, Shan Lu, Blase Ur
Department of Computer Science, The University of Chicago
{lefanz, hewj, jessjmart, brackenburyn, shanlu, blase}@uchicago.edu
Abstract â€”End-user programming, particularly trigger-action
programming (TAP), is a popular method of letting users express
their intent for how smart devices and cloud services interact. Un-fortunately, sometimes it can be challenging for users to correctlyexpress their desires through TAP . This paper presents AutoTap,a system that lets novice users easily specify desired propertiesfor devices and services. AutoTap translates these properties tolinear temporal logic (LTL) and both automatically synthesizesproperty-satisfying TAP rules from scratch and repairs existingTAP rules. We designed AutoTap based on a user study aboutproperties users wish to express. Through a second user study,we show that novice users made signiï¬cantly fewer mistakeswhen expressing desired behaviors using AutoTap than usingTAP rules. Our experiments show that AutoTap is a simple andeffective option for expressive end-user programming.
Keywords-End-user programming; trigger-action program-
ming; program synthesis; program repair
I. I NTRODUCTION
End-user programming enables users without programming
experience to customize and automate systems. An approach
that is particularly popular for automating IoT smart devicesand online services is trigger-action programming (TAP),which is supported by IFTTT [1], Mozillaâ€™s Things Gate-way [2], Samsung SmartThings [3], Microsoft Flow [1],OpenHab [4], Home Assistant [5], Ripple [6], Zapier [1], andothers. Some of these TAP services are widely used [7], [8].
In TAP , users create event-driven rules of the form â€œIF
atrigger occurs, THEN perform an action.â€ For example,
â€œIF a sad song comes on THEN turn the lights blue.â€Unfortunately, while novice users are able to successfullyexpress many automation behaviors using TAP interfaces [9],attempts to express more complex, yet commonly desired,behaviors often contain bugs [10]â€“[14]. These bugs encompasstiming errors [10], issues with control ï¬‚ow [15], conï¬‚ictingbehaviors [12], and incorrect user expectations [14]. As aresult, an important open question is how to help userswith no programming experience, and therefore no debuggingexperience, correctly express their wide variety of desired
behaviors in TAP . Otherwise, users will encounter frustrationand experience safety threats [16] from buggy TAP rules.
For example, imagine the simple and sensible desire to keep
the window closed when it is raining. With current interfaces,a user might create the straightforward TAP rule â€œIF it beginsto rain THEN close the windowâ€ (Figure 1a). Unfortunately,this rule is insufï¬cient. For example, while it is raining, adifferent rule might be triggered and open the window, or an
(a) A (buggy) TAP rule.
 (b) A proposed TAP property.
Fig. 1: The TAP rule (a) cannot guarantee the property (b).
oblivious person might open the window manually. To fullyexpress this desire therefore requires a complex set of rules.
To address this open question, we present AutoTap, a system
that provides easy end-user programming for smart devicesand online services with fewer chances for human mistakes.AutoTap expands TAP to allow users to specify throughgraphical interfaces not only rules, but also properties about
the system that should always be satisï¬ed. For example, fromthe running example, one could express the desired propertythat â€œit is currently rainingâ€ and â€œthe window is openâ€ shouldnever occur together (Figure 1b). In other words, instead ofrequiring users to explicitly write event-driven rules deï¬ninghow devices should behave, we let them simply specify whatproperties the system must satisfy.
If no relevant rules are provided, AutoTap automatically
synthesizes property-satisfying TAP rules from scratch. Forexample, given the property in Figure 1b, AutoTap willautomatically synthesize two TAP rules to satisfy this property:
â€¢IFit begins to rain WHILE the window is open THEN
close the window
â€¢IFthe window opens WHILE it is raining THEN close
the window
If initial rules are provided alongside the desired property,
AutoTap will automatically check these rules and, if necessary,repair them to prevent the system from violating the property.AutoTap thus minimizes the opportunity for TAP mistakes.The following two key components of AutoTap work togetherto achieve the above functionality:
1) A novel property-speciï¬cation interface: The key goal of
TAP is to empower novice users without programming knowl-
2812019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)
1558-1225/19/$31.00 Â©2019 IEEE
DOI 10.1109/ICSE.2019.00043
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:59:42 UTC from IEEE Xplore.  Restrictions apply. Fig. 2: An overview of AutoTap, which takes user-speciï¬ed
properties and (optionally) user-speciï¬ed TAP rules to auto-matically generate a set of TAP rules that satisfy the properties.
edge to automate and customize their devices and services. Au-
toTap therefore needs an interface that is both (a) expressive,
allowing users to specify most of their desired properties forsmart-device systems, and (b) easy-to-use, requiring minimal
training for non-technical home users to use correctly.
To this end, we ï¬rst conducted an online user study in
which 71 current users of smart devices each provided (infree text) ten properties they would want their devices tosatisfy (Section III). We qualitatively coded their responses,ï¬nding that nearly all the desired properties followed one ofseven templates. Subsequently, we implemented a graphical,click-only interface that mirrors the design of popular TAPrule-speciï¬cation interfaces [1]. This interface enables usersto specify properties following these seven templates withoutrequiring any text input. AutoTap then directly translatesproperties speciï¬ed in this interface to formulas in lineartemporal logic (LTL ) that can be used by AutoTapâ€™s other
components (Section IV). While prior work has proposedinterfaces for property speciï¬cation [17], no prior efforts fullysatisfy our requirements in the unique context of smart-devicesystems (Section VIII).
2) Novel synthesis techniques for TAP rules: We want
all programs synthesized by AutoTap to be (a) property-
compliant, guaranteeing the programmed devices satisfy thespeciï¬ed properties; (b) accommodating, not disabling any
device behaviors that originally satisfy the properties â€” cru-cial for human-centric systems; and (c) valid, following the
syntax of TAP rules and physical constraints of smart devices.For example, given the property in Figure 1b, generating onlyone of the two TAP rules presented earlier is accommodating,yet non-compliant. Generating TAP rules that prevent thewindow from ever opening even in sunny weather is compliant,yet not accommodating. Generating TAP rules that prevent rainis impossible, and therefore not valid.
To achieve these goals, AutoTap takes three steps, as shown
in Figure 2. First, it automatically builds a B Â¨uchi Automaton to
formally model desired properties and the smart-device systemitself, including any existing TAP rules. At this step, thenovel techniques we introduce simplify models and properlyrepresent time-related properties (Section V-A).Second, AutoTap leverages a unique feature shared by all
LTL safety properties to design a simple algorithm that iden-tiï¬es B Â¨uchi Automaton edges whose removal guarantees the
compliant and accommodating goals of synthesis (Sec. V-B).
Third, AutoTap designs an algorithm to systematically syn-
thesize valid new TAP rules or rule changes to remove Au-
tomaton edges identiï¬ed above, while making a best effort tokeep rules simple and thus intelligible for users (Section V-C).
These techniques are general. They are not limited to any
speciï¬c patch template. They apply to any LTL safety property,not just those that can be expressed using AutoTapâ€™s currentproperty-creation interface. Furthermore, while our interfacedesign focuses on smart devices, the same techniques applyto online services, such as the hundreds IFTTT supports [8].
These techniques are also novel. We cannot use previously
proposed synthesizers [18]â€“[20], which do not satisfy therequirements discussed above in the unique context of smart-device systems (Section VIII). A small but quickly growingliterature has begun to apply formal methods to TAP [21]â€“[24]. Our techniques move beyond this work in both thetarget and the solution. Some of this work only aims to detectproperty violations [24], while others only repair existing rules
by editing or adding conditions [21], [22] or triggers [23].Our techniques are the ï¬rst to also synthesize new rules from
scratch and to provide the accommodating guarantees, notdisabling any device behaviors that originally satisfy the de-sired properties â€” a crucial feature for human-centric systemsthat fundamentally cannot be provided using the ï¬xing-by-counterexample approach of previous work [21], [25].
Our evaluation of AutoTap includes several parts (Sec-
tion VI). We conducted a second user study in which 78participants were randomly assigned to use either a traditionalTAP rule interface or our AutoTap property interface. Theyused their assigned interface to express 7 behaviors randomlyassigned from a larger set of 14. For all14 behaviors, a larger
fraction of participants using the AutoTap property interfacecorrectly expressed the behavior than those using the tradi-tional TAP rule interface. We also benchmarked AutoTapâ€™sperformance, synthesizing TAP rules from scratch using thesets of correct properties collected in our study. AutoTapsuccessfully generated patches for 157 of these 158 sets.
To encourage replication and adoption, we are open-
sourcing the code for both AutoTap and our rule- and property-speciï¬cation interfaces. We are also releasing the anonymizeddata from our two user studies (with the permission of both ourIRB and participants) and our full survey instruments. All ofthese are available at https://www.github.com/zlfben/autotap.
II. B
ACKGROUND
A. Trigger-Action Programming (TAP)
In recent years, TAP has received a great deal of academic
attention in multiple areas: usability [9]â€“[11], [13]; novelinterfaces [26]â€“[28]; measurement [7], [8]; deployment [6],[29]; correctness [12], [21]â€“[24]; and security [15], [16],[30]. Furthermore, TAP has been deployed by Microsoft [1],Mozilla [2], IFTTT [1], Samsung [3], and others.
282
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:59:42 UTC from IEEE Xplore.  Restrictions apply. Systems generally follow one of two TAP rule struc-
tures [14]. The simpler variant connects a single trigger to
a single action: â€œIF event THEN action .â€ Each such statement
is a TAP rule , and a collection of rules forms a TAP program .
Events include state changes for devices, services, and sensors
(e.g., â€œit begins to rainâ€). Actions are actuations of devices
(e.g., â€œopen the windowâ€) or services (e.g., â€œsend an SMSâ€).
The more expressive variant differentiates events (actions
or state changes that occur in a moment, such as â€œit begins to
rainâ€) and states (conditions that remains true/false over time,
such as â€œit is rainingâ€). In this variant, triggers are a single
event optionally conditioned on one or more states as follows:
â€œIF event occurs WHILE devices are in a given state , THEN
ï¬re action ,â€ shortened as â€œIF event WHILE state(s) THEN
action .â€ In this paper, we use this more expressive EVENT-
STA TE-ACTION variant (also called EVENT-CONDITION-
ACTION), which balances usability and expressiveness. This
variant is used in Samsung SmartRules [3], Stringify [31],
Home Assistant [5], and academic studies [9], [10], [14], [32].
B. Transition Systems and Linear Temporal Logic (LTL)
AutoTap formally models smart devices and TAP programs
as transition systems [33]. Every transition system consists of
a set of states S; a set of events E(typically called actions
in TAP) that change the system from one state to another,
s1eâˆˆEâˆ’âˆ’âˆ’â†’s2; and a set of atomic propositions AP that reï¬‚ect
detailed properties of a state, with L(s)denoting the set of
atomic propositions associated with state s. A valid execution
is an inï¬nite sequence of states s0s1...,skâˆˆSand every
transition from one state to the next is valid, sieiâˆˆEâˆ’âˆ’âˆ’â†’si+1.
LTL formulas can represent a wide variety of execution
properties and are widely used in formal veriï¬cation [34].
An LTL formula Ï†is constructed from atomic propositions
with some operators: Ï†::=t r u e|ap|Â¬Ï†|Ï†1âˆ§Ï†2|XÏ†|Ï†1UÏ†2.
Informally, Â¬,âˆ§,XandUrepresent not,and,neXt, and Until,
respectively. In addition to these basic operators, F,Gand
W are common derived operators. Given an execution E=
s0s1...of a transition system, Esatisï¬es atomic proposition
apif and only if the initial state of Eis associated with ap
(i.e.,apâˆˆL(s0)). A transition system TS satisï¬es property
Ï†(TS|=Ï†) if all possible executions in TS satisfyÏ†.
III. U SER STUDY 1: M APPING DESIRED PROPERTIES
To understand what types of properties users commonly
desire for smart devices, we conducted an online user study.
Methodology : We designed a survey asking people who had
experience with IoT smart devices in their own homes to write
free-text properties they would want their devices and home to
satisfy. Speciï¬cally, we asked them to write â€œstatements about
internet-connected household devices that you believe should
be effective at all times, with only occasional exceptions, if
any.â€ To encourage diversity, we asked participants to imagine
their house was ï¬lled with 27 smart devices we listed. We
asked for ten statements, preferably ï¬ve that should always be
true and ï¬ve that should never be true in their smart home.We recruited participants on Amazonâ€™s Mechanical Turk
who reported having an internet-connected household IoT
device and living in the USA. We compensated $5 for the
study, which also included a section on experiences with buggy
behaviors in smart homes that is outside this paperâ€™s scope.
Through qualitative coding, we analyzed and grouped these
free-text desired properties into templates. Members of the
research team read through responses and iteratively proposed
templates. Two coders then independently categorized each
response ( Îº=0.62) and met to resolve discrepancies.
To encourage complex and diverse properties, we randomly
assigned half of participants to see four example properties
(e.g., â€œThe temperature in my bedroom should never be below
65 degreesâ€), while the other half did not see any examples.
While both participants who did and did not see examples
wrote properties following six of the seven templates, the
proportion of properties matching a given template differed
signiï¬cantly between these two groups ( Ï‡2,p=.003). Thus,
we always ï¬rst report the percentage among properties written
by participants who did not see examples, followed by the
percentage from those who did.
Results : We received 75 responses, discarding four who
gave off-topic responses or reported having no smart devices.
Of the resultant 71 participants, 64 % identiï¬ed as male and
36 % as female. The median age range was 25â€“34 (53 %),
and 9 % were age 45+. Among participants, 24 % reported a
degree or job in CS or technology. Participants most frequently
reported having internet-connected cameras (55 % of partic-
ipants), lights (54 %), thermostats (52 %), cooking devices
(18 %), door locks (15 %), and outdoor devices (8 %).
We found that seven templates captured the vast majority
of desired properties participants expressed. We differentiate
them based on whether they are conditional (i.e., conditioned
on at least one other clause), whether they rely on a duration
(i.e. expressing temporal bounds), and whether they are de-
scribed based on states and/or events. The small number of
remaining properties were either out of scope (e.g., requesting
new features) or too ambiguous to analyze reliably.
Below are the seven templates, each with the proportion of
responses that ï¬t that template from participants who did not
see examples and those who did, respectively. We also provide
a sample response from participants for each template.
a)One-State Unconditional (40.6%, 14.7%) :â€œSmart refrig-
erator should always be on.â€
b)One-Event Unconditional (24.1%, 14.5%) :â€œMy thermo-
stat should never go above 75 degrees.â€
c)One-State Duration (0.9%, 7.5%) :â€œMy smart lights
should stay on for at least 30 seconds each time.â€
d)Multi-State Unconditional (0.3%, 0.2%) :â€œNever run the
washing machine and the dish washer at the same time.â€
e)State-State Conditional (1.6%, 7.5%) :â€œThe stove should
always be off if no one is home.â€
f)Event-State Conditional (26.3%, 40.7%) :â€œMy smart win-
dow should never be opened while the AC is on.â€
g)Event-Event Conditional (5.3%, 13.8%) :â€œMy smart door
lock should always lock after I come in.â€
283
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:59:42 UTC from IEEE Xplore.  Restrictions apply. TABLE I: AutoTapâ€™s property templates. G,F,X, and Ware â€œalways Globallyâ€, â€œeventually in the Futureâ€, â€œneXtâ€, and
â€œWeakly untilâ€ LTL operators. state is a user-speciï¬ed atomic proposition or its negation. #andâˆ—relate to timing (Sec. V-A).
Property Type Input Template LTL Formula
One-State Unconditional[state ]should [always ]be active G(state )
[state ]should [never ]be active Â¬F(state )
One-Event Unconditional [event] should [never ]happen Â¬F(@event )
One-State Duration[state ]should [always ]be active for more than [time ] G(stateâ†’(state Wtimeâˆ—state ))
[state ]should [never ]be active for more than [time ] Â¬F(timeâˆ—state )
Multi-State Unconditional[state 1,...,state n]should [always ]occur together Â¬F(!(state 1â†”...â†”staten))
[state 1,...,state n]should [never ]occur together Â¬F(state 1âˆ§...âˆ§staten)
State-State Conditional[state ]should [always ]be active while [state 1,...,state n] G((state 1âˆ§...âˆ§staten)â†’state )
[state ]should [never ]be active while [state 1,...,state n]Â¬F(state 1âˆ§...âˆ§statenâˆ§state )
Event-State Conditional[event ]should [only ]happen when [state 1,...,state n] G(X@eventâ†’(state 1âˆ§...âˆ§staten))
[event ]should [never ]happen when [state 1,...,state n] Â¬F(state 1âˆ§...âˆ§statenâˆ§X@event )
Event-Event Conditional[event 1]should [always ]happen within [time ]after [event 2]G(@event 2â†’(time #event 2W@event 1))
[event 1]should [never ]happen within [time ]after [event 2]Â¬F(time #event 2âˆ§X@event 1)
Interface Entry Property Type
â€¢Multi-state Unconditional
â€¢One-State Unconditional
â€¢One-State Duration
â€¢State-State Conditional
â€¢One-Event Unconditional
â€¢Event-State Conditional
â€¢Event-Event Conditional
Fig. 3: Templates in AutoTapâ€™s property-speciï¬cation UI.
IV . A UTO TAP PROPERTY -SPECIFICA TION INTERFACE
AutoTap aims to synthesize TAP programs satisfying user-
speciï¬ed properties. This section discusses our design of a
property-speciï¬cation user interface that aims to be expressive,
easy to use, and also compatible with LTL, allowing an easy
translation from every speciï¬ed property into an LTL formula.
Property types : Table I summarizes the seven property
types we commonly observed in our ï¬rst user study. They
differ along three dimensions: whether the subject was a state
or an event; whether something should or should not happen;
and whether the desire was conditional or unconditional.
We note that any state-state conditional property can be
written as an equivalent multi-state unconditional property.
Further, some one-state duration properties have equivalent
event-event conditional properties. However, to better match
usersâ€™ mental models, we chose not to merge these types.
Every type of property in our interface has a straightforward
translation to an LTL formula, as shown in Table I. The
example in Figure 1a corresponds to a state-state conditional
property: â€œThe [window ]should always be closed when
[weather ]israining â€. It corresponds to an LTL formula
G(weather.raining â†’window.closed ).
Interfaces for property speciï¬cation : To not overwhelm
users, AutoTap lets them ï¬rst pick from three template cate-gories, as shown in Figure 3, and then customize that template
by selecting items from drop-down lists of devices, states, or
events. Users also select whether they desire certain situation
to always occur or never occur. This interface provides users
with the same vocabulary about devices, states, and events as
traditional TAP rule interfaces, as in Figure 1.
AutoTapâ€™s user interface design focuses on common user
desires. It does not aim to cover all possible properties a
user might think of, or all properties AutoTap synthesis can
handle. As an alternative, AutoTap also allows expert users to
specify safety properties directly in LTL. For example, imagine
someone has a smart light bulb and wants the â€œredâ€ color to
always be followed by â€œgreenâ€ or â€œyellow.â€ This desire is not
supported by the user interface above, yet can be described in
LTL as G(color.red â†’X(color.green âˆ¨color.yellow ))and
thus can be handled by AutoTap.
V. A UTO TAPTAP SYNTHESIS
Problem statement : Informally speaking, smart devices
continuously interact with unpredictable human users and
environments. Naturally, some interactions (sequences) might
cause undesirable device states or state sequences. AutoTap
aims to automatically synthesize TAP programs or program
patches so that all desirable situations remain intact (i.e.,
being accommodating ) and all undesirable situations become
disabled or transient (i.e., being property-compliant ).
Straw-man : One potential solution is to repeatedly attempt-
ing the following two steps, as illustrated by the dashed lines
in Figure 4: (1) propose a TAP program (patch); (2) try to
prove that this program guarantees satisfaction of the desired
properties, returning to Step 1 if not.
The second step can be done through model checking [21],
which typically uses a ï¬nite B Â¨uchi Automaton to represent
all possible executions of the system, checking if all these
executions satisfy a property Ï†by analyzing the automaton
graph. Unfortunately, given the large search space of potential
TAP programs, particularly when we synthesize programs
from scratch, how to conduct the ï¬rst step is unclear.
284
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:59:42 UTC from IEEE Xplore.  Restrictions apply. Fig. 4: AutoTap approach vs. straw-man approach
AutoTap approach: AutoTap takes a unique approach to
solving this problem in a general and systematic way. As
illustrated in Figure 4, it does not require iterative retries.
Step 1: Turn the given smart-device system, TAP rules (if
any), and the desired property Ï†into a B Â¨uchi Automaton A
accepting Ï†-violating executions, like what traditional model
checkers do internally.
Step 2: Figure out how to modify Aso that all Ï†-satisfying
executions are kept, which guarantees being accommodating,
and all originally accepted (i.e., Ï†-violating) executions disap-
pear, which guarantees being property-compliant.
Step 3: Find valid TAP program(s) that can make the
automaton changes suggested at Step 2.
The ï¬rst step is largely straightforward, but we need to care-
fully model timing-related properties and avoid unnecessarilylarge automata. Section V-A explains how we do so.
The second step is very challenging at ï¬rst glance. There
are innumerable ways to change an automaton A. It is hard to
know which changes are compliant, accommodating, and valid(e.g., changes that require modifying property Ï†and device
speciï¬cations are invalid). Section V-B will present a simplealgorithm that identiï¬es such compliant, accommodating, andvalid changes (i.e., a set of edges to cut in A), leveraging
a unique property of LTL safety properties. As Section IVexplained, the desired properties we commonly observed inour ï¬rst user study all map directly to LTL safety properties.
The third step, ï¬nding valid program changes
1that cor-
respond to a given automaton change, is challenging forgeneral programming languages. However, as we will explainin Section V-C, it can be done in a systematic way for TAP .
A. Step 1: Model Construction
AutoTapâ€™s inputs are: (1) safety properties Ï†in LTL, ob-
tained through the user interface presented in Section IV;
(2) TAP rules, if any; (3) speciï¬cations for every smart devicein the form of a transition system, as deï¬ned in Section II-B.We expect device speciï¬cations to be provided once by device
manufacturers or tool developers like us, yet used by alldevice
users. Our experiments used the speciï¬cations from SamsungSmartThings [35].
AutoTapâ€™s baseline model construction follows traditional
model-checking techniques [36]. First, a transition system isbuilt for a set of devices together with their TAP rules, ifany (e.g., Figure 5). Some events in the transition system are
1AutoTap does not differentiate program synthesis from patch synthesis, as
the former is a special case of the latter when the original program is null.
Fig. 5: Transition system for RAIN and a Win dow. Statements
in parentheses are Atomic Propositions held in each state.
controllable (e.g. â€œturn on the lightâ€), while others are not
(e.g. â€œstop rainingâ€). This distinction is kept by AutoTap forits synthesis phase.
2Then, this transition system is turned into
aB Â¨uchi Automaton Asthat accepts all executions allowed
in the smart-device system (e.g., Figure 6b). Next, AutoTapapplies Spot [37] to the LTL formula representing Â¬Ï†to get
aBÂ¨uchi Automaton A
Â¬Ï†that accepts all executions violating
Ï†(e.g., Figure 6a). Finally, AsandAÂ¬Ï†are combined into a
BÂ¨uchi Automaton Athat accepts all Ï†-violating executions in
the smart-device system (e.g., Figure 7).
Our discussion below focuses on two techniques we devel-
oped for AutoTap beyond typical baseline modeling.
Device selection: To avoid unnecessary complexity, Auto-
Tap selects devices Drelated to the given property Ï†to model.
To do so, AutoTap ï¬rst initializes Dwith all the devices that
appear in Ï†. AutoTap then iteratively expands Dwith devices
that can affect any device already in Duntil reaching a ï¬xed
point. Here, AutoTap considers one device to affect anotherdevice if these two both appear in a TAP rule r, with the
former in the trigger and the latter in the action.
Model timing information : AutoTap extends baseline
models to support timing-related propositions like â€œevent e
happened within the past t(seconds)â€, denoted as t#e , and
â€œap has been true for at least t(seconds)â€, denoted as tâˆ—ap.
AutoTapâ€™s property-speciï¬cation interface supports both.
AutoTap ï¬rst adds a count-down timer attribute timer(t#e )
ortimer(t*ap) into the transition system. The countdown
starts att, whenehas just occurred, or when a system state
associated with aphas just appeared. It ends at 0, indicating
ehas occurred or aphas been true for at least tseconds.
When the system reaches a state no longer associated withap, thetâˆ—aptimer immediately ï¬‚ips to âˆ’1. Consequently, a
state is associated with a t#e proposition if the corresponding
timer is positive. It is associated with t*ap if the corresponding
timer is0. Then, AutoTap introduces an environmental event
tick that counts down every positive timer uniformly. When
tick is applied to a state s, AutoTap ï¬nds the smallest value
of all the positive timers associated with sand counts down
every positive timer by that value. For example, if a state isassociated with three timers with values {0, 30, 100}, one tick
will direct the system to a state with these timers being {0,
0, 70}, and another tick will set all three timers to 0. This
count-down scheme helps AutoTap avoid unnecessary state-
2The device speciï¬cation we used [35] contains such information: capabil-
ities with â€œcommandsâ€ are controllable, while others can only be sensed.
285
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:59:42 UTC from IEEE Xplore.  Restrictions apply. (a) LTL property:
Â¬G(RAIN.on â†’
W in.closed )
(b) Device system: Window + RAIN
Fig. 6: B Â¨uchi Automata of our running example.
space explosions without losing accuracy, as counting down
timers by smaller values will not change any timing related
propositions (e.g., {0, 30, 100 }and{0, 25, 95}will have the
same set of time-related propositions).
Here, AutoTap uses its own design to handle timing-related
propositions for simplicity reasons: since AutoTap only cares
about two simple timed propositions t#eandtâˆ—ap, using more
complicated timing logic like MTL [38] and more complicated
timed automata [39] will only add unnecessary complexity to
AutoTap property checking and rule synthesis.
B. Step 2: Patching the Automaton
The ï¬rst step builds a B Â¨uchi Automaton Athat accepts
allÏ†-violating executions on smart devices. If no execution
can be accepted by A, usersâ€™ desire Ï†is already guaranteed.
Otherwise, this second step ï¬gures out how to change A.
Task : We ï¬rst clarify AutoTapâ€™s task at this step by re-
viewing some related background on B Â¨uchi Automata. By
deï¬nition [36], an execution is accepted by a B Â¨uchi Automaton
if and only if its corresponding path on the automaton visits
every accepting-node set an inï¬nite number of times. For
example, the automaton in Figure 6a has one accepting set
that consists of exactly one node, the double-circled one.
It accepts every execution with a preï¬x ending in a state
whereRAIN.on and !Win.closed are true, which guarantees
visiting the double-circled node an inï¬nite number of times.
Consequently, AutoTap must ï¬gure out how to change A
so that all (and only those) paths that inï¬nitely visit Aâ€™s
accepting-node set disappear. There are several challenges.
First, the change has to be valid , doable through possible
additions or revisions of TAP rules. Naming accepting nodes as
un-accepting is invalid. Deleting an edge in Ais usually valid,
as discussed in the next sub-section. Second, for arbitrary Ï†,i t
is difï¬cult to tell which edges we should cut. This edge-cutting
must not only eliminate every path that visits the accepting-
node set inï¬nitely (i.e., property-compliant ), but also keeps
intact every path that originally does not visit the accepting-
node set inï¬nitely (i.e., accommodating ).
Observation : AutoTapâ€™s algorithm is based on a key ob-
servation: as long as Ï†is an LTL safety property, Ahas no
edge connecting an accepting node to an un-accepting node.
This observation holds because, as long as Ï†is an LTL safety
property, we can always ï¬nd an AÂ¬Ï†whose only accepting
node has a single edge pointing to itself with condition 1.
Fig. 7: Combined B Â¨uchi Automaton of the running example.
(The top is the original. The bottom is after adding a rule.)
Once a path reaches this node, it will be stuck in this node
inï¬nitely,3just like the double-circled node in Figure 6a.
This property of AÂ¬Ï†then leads to the above observation
ofA. The reason is that, by combining the smart-device
automaton Asand the property automaton AÂ¬Ï†, every node in
Ais a cartesian product of two nodes, nsinAsandnÏ†inAÂ¬Ï†.
The accepting-node set of Aconsists of every node whose
corresponding node in AÂ¬Ï†is an accepting node. Furthermore,
if there exists an edge from n1ton2inA, there must exist an
edge from n1Â¬Ï†ton2Â¬Ï†inAÂ¬Ï†. Consequently, since there
is no edge connecting the accepting node back to any un-
accepting nodes in AÂ¬Ï†, there must be no edge connecting
accepting nodes back to un-accepting nodes in Aeither.
Algorithm : AutoTap identiï¬es all the edges that connect
an un-accepting node to an accepting node in A, informally
referred to as bridge edges , and suggests cutting all of them,
like the two edges in the middle of Figure 7.
This algorithm is simple , with complexity linear in the
number of edges in A.
This algorithm is compliant , preventing any property viola-
tions. The reason is that, after cutting all bridges, no execution
can ever touch accepting nodes, not to mention inï¬nitely.
Consequently, all Ï†-violating executions are eliminated.
This algorithm is also accommodating , preserving all the
system behaviors that do not violate Ï†. Recalling Section V-B,
Ï†-satisfying executions will not go through any bridges. Since
our algorithm only removes or redirects bridges, yet not other
edges, those executions are untouched.
C. Step 3: TAP Synthesis
At this third step, AutoTap needs to identify additions of,
or revisions to, TAP rules that can delete the bridges in A
identiï¬ed in Step 2. Mapping a B Â¨uchi Automaton change to
a program-code change is challenging for most imperative
programming languages, but is fortunately tractable for TAP .
Task : We ï¬rst clarify AutoTapâ€™s task by reviewing some
background on B Â¨uchi Automata.
InA, which is combined by the smart-device automaton
Asand the property-negation automaton AÂ¬Ï†, every edge e:
3Due to space constraints, we cannot include a complete formal proof.
Informally, given a B Â¨uchi Automaton of an LTL safety property, all nodes
corresponding to the last state of a violating preï¬x of the property can be
replaced with an accepting node with an edge 1pointing to itself. Those
nodes can be combined, giving us the B Â¨uchi Automaton AÂ¬Ï†we desire.
286
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:59:42 UTC from IEEE Xplore.  Restrictions apply. Fig. 8: Device automaton (a) changed to (b) by adding a rule.
n1apâˆ’ â†’n2is combined by an edge es:n1sapsâˆ’ âˆ’ â†’n2sin
Asand an edge eÂ¬Ï†:n1Â¬Ï†apÂ¬Ï†âˆ’âˆ’âˆ’â†’n2Â¬Ï†inAÂ¬Ï†.apis an
atomic proposition (AP) set describing what is accepted by
e, andeonly accepts what is accepted by both esandeÂ¬Ï†.
Ifapsconï¬‚icts with apÂ¬Ï†, edgeewould disappear from A.
To ease the discussion, we will informally refer to apas the
post-condition of n1and the pre-condition of n2.
Since the property Ï†and the corresponding AÂ¬Ï†cannot
be changed, AutoTap changes every bridge eâ€™s corresponding
edgeesinAs, which we also refer to as a bridge, removing
esor changing its apsso thatecan disappear from A.
Example: Before presenting AutoTapâ€™s general algorithm,
we use a concrete example to demonstrate how adding aTAP rule can change the smart-device automaton A
sand
correspondingly make some edges disappear in A.
Figure 8a is part of the automaton Asin Figure 6b that
models the weather (RAIN) and a smart window (Win) withno TAP rules. We can focus on node 1/circlecopyrt. Its preceding edge
indicates a pre-condition when it was not raining and the
window was open. Its succeeding edge 1/circlecopyrt@RAIN :ONâˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’ â†’
{RAIN.on, Win.open}2/circlecopyrt
indicates that the rain starts (@RAIN:ON) with the post-
condition being raining and window staying open. Note thatthis post-condition AP-set is the same as that of the bridgeinA
Â¬Ï†, illustrated in Figure 6a. Consequently, 1/circlecopyrtâ†’ 2/circlecopyrtis a
bridge in Asthat contributes to the red bridge edge in the
combined automaton Ain Figure 7.
Figure 8b shows the effect of adding a TAP rule. As high-
lighted in the ï¬gure, this ruleâ€™s triggering state Rain.off
AND Win.open exactly matches the pre-condition of
node 1/circlecopyrt. Its triggering event @RAIN.ON and rule action
@Win.OFF exactly match the events associated with edge 1/circlecopyrt
â†’2/circlecopyrtand edge 2/circlecopyrtâ†’ 4/circlecopyrt, respectively. Consequently, immedi-
ately after 1/circlecopyrtâ†’ 2/circlecopyrttakes place, this rule would automatically
push the system through the 2/circlecopyrtâ†’ 4/circlecopyrtedge, essentially making
the 1/circlecopyrtâ†’ 2/circlecopyrtedge transient, marked by â€œT â€ in Figure 8. By
changing the nature of 1/circlecopyrtâ†’ 2/circlecopyrt, its AP-set no longer matches
with that of the bridge edge in Figure 6a. Consequently, thecorresponding bridge edge in A(i.e., the red edge in Figure
7) will disappear.
1) AutoTap ï¬xing algorithm: We ï¬rst consider a simple
case where the bridge edge e
sinAshas only one predecessor
and one successor, as in Figure 9a. To cut its correspondingbridgeein the combined automaton A, we simply need to add
a TAP rule â€œIF e
1WHILEAP 1THENe2â€, where e1is the
event associated with the bridge, AP1is the pre-condition of


	



	

  
  

Fig. 9: Generalization of adding TAP rules.
the bridge, and e2is the event associated with the succeeding
edge. Like the example in Figure 8, this new rule will makestates associated with e
stransient, no longer able to combine
intoe. That is, bridge einAwill be successfully cut.
Reï¬ne trigger state: The baseline algorithm uses AP1, the
bridgeâ€™s pre-condition, as the trigger state of the synthesizedrule. In fact, it does not have to be. We want the new ruleto be triggered (1) at an original bridge edge, but (2) not at
any non-bridge situations. The former implies that the ruleâ€™strigger-state condition should be weaker than the bridgeâ€™spre-condition. For example, since the bridgeâ€™s pre-conditionin Figure 8 is RAIN.off AND Win.on, the trigger state
can be RAIN.off,o rWin.on,o rTRUE. The latter implies
that, in other places where the trigger event could happen,the pre-conditions should conï¬‚ict with the ruleâ€™s trigger state,preventing the rule from being unnecessarily triggered.
To achieve this goal, AutoTap processes not only the
bridgeâ€™s pre-condition AP
1, but also pre-conditions AP/prime
ias-
sociated with all other cases where the trigger event couldoccur. When there are multiple expressions satisfying theabove requirements, we turn this into a hitting set problem.We use a greedy algorithm to ï¬nd the smallest one.
Reï¬ne the triggered action: The baseline algorithm uses
e
2as the action of the synthesized rule because the bridge
edge only has a single successor and hence e2is the only
possible action taken in Figure 9. When the bridge has multiplesuccessors with multiple possible succeeding actions, AutoTapï¬lters out two types of actions: (1) actions that cannot beinitiated by smart devices (i.e., non-controllable events likeâ€œstop rainingâ€ discussed in Section V-A), and (2) actionscausing other property violations. If multiple actions pass theabove ï¬ltering, the only ranking AutoTap does currently isto downgrade an action that reverts the trigger event. Forexample, if the trigger event is turning on the air conditioner(AC), AutoTap will not suggest a rule that turns off the ACunless there are no other choices.
Revise existing rule: When the bridge edge e
sis associated
with an event that is automatically triggered by an existingTAP rule r, the baseline patch would immediately trigger one
TAP rule after another. A better solution is to revise rso
thatris no longer triggered in this bridge situation, yet is
still triggered in other situations. To achieve that, we split thegeneral rule rinto many edge-speciï¬c TAP rules by narrowing
râ€™s triggering state to only accept the pre-condition of every
speciï¬c edge. Then, we simply delete the edge-speciï¬c ruleassociated with the bridge edge and keep the remaining ones,
287
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:59:42 UTC from IEEE Xplore.  Restrictions apply. assuring minimum impact to the systemâ€™s behavior.
Rule merging: AutoTap can merge TAP rules with the same
trigger event and rule action, or even similar trigger states,
to make the program easier to understand without changingsystem behaviors. We omit the details due to space constraints.
VI. E
V ALUA TION
A. User Study 2: Specifying Rules vs. Specifying Properties
To evaluate usability questions regarding whether AutoTapâ€™s
property-driven approach enables novice users to express theirintent correctly and easily, we conducted a second onlineuser study. In this study, we compared participantsâ€™ abilityto express a series of reference tasks as TAP rules (usinga traditional rule-based interface) and participantsâ€™ ability toexpress the same series of tasks as properties (using AutoTapâ€™sinterface). We chose a rule-based TAP interface as our pointof comparison because such interfaces are widely used [8] andprior usability studies have shown that even novice users cancreate TAP rules successfully [9], [13], [28], [40].
Methodology: We again recruited participants from the
USA on Mechanical Turk, though for this study we did notrequire that they had previously used a smart device. Werandomly assigned each participant to one of the followinginterfaces, which they used for the duration of the study:
â€¢Rules: Participants created TAP rules using a web inter-face modeled closely after IFTTT (see Figure 1a).
â€¢Properties: Participants created properties using Auto-Tapâ€™s interface (see Figure 1b)
4.
The interfaces used identical events and states. In other words,if the rule interface had an â€œit begins to rainâ€ event groupedunder â€œweather,â€ so did the property interface.
Participants began the study by completing a short tuto-
rial on their assigned interface. The tutorial explained keyconcepts (e.g., the difference between events and states) andincluded attention-check questions. These questions automat-ically pointed out the right answer for anything participantsanswered incorrectly. We designed the two tutorials to haveparallel structure and share examples as much as possible.
Participants then used their assigned interface to complete 7
tasks randomly selected (and randomly ordered) from a largerset of 14. We developed each of the 14 tasks based on desiredproperties expressed in Study 1. However, we rewrote the tasksso that the wording of the task would not make obvious whichproperty template should be used. An example task follows:
Y ou have a Roomba robotic vacuum cleaner in your home, and
youâ€™ve given it a schedule for when it should clean the ï¬‚oor.However, when the curtains in your home are open, the drawstringlays on the ï¬‚oor and often causes the Roomba to get stuck onthe string. Y ou want to make sure this does not happen again.
4At the time of the study, our interface let users specify positive Event-State
Conditional properties through an â€œevent Eshould always happen while state
Sis trueâ€ template. Afterwards, we replaced â€œalwaysâ€ with â€œonlyâ€ to avoid
ambiguity, as shown in Table I and Figure 3. For participant answers using
this â€œalwaysâ€ template, we interpret them as â€œE should be triggered while S
becomes true,â€ in this way judging three participantsâ€™ answers to be correct.
Fig. 10: Correctness of properties and rules by task. P-values
are from Holm-corrected Ï‡2tests comparing the proportion of
statements correct when written using rules versus properties.
This task could be completed successfully with the rules â€œIF
Roomba becomes on WHILE the curtain is open, THEN close
the curtain;I F curtain becomes open WHILE Roomba is on,
THEN turn off Roombaâ€ or the property â€œRoomba is on should
NEVER be active WHILE curtain is openâ€. We constructed the
set of tasks so that at least two tasks could be completed witheach of the 7 property templates. Since many properties canbe expressed in multiple ways, though, most templates couldbe used for more than two tasks.
After each task, participants rated their conï¬dence in their
submission and perception of how difï¬cult it was to completethe task on ï¬ve-point scales. They also had the opportunity toexplain, in free text, any corner cases they had considered.After completing all 7 tasks, they ï¬lled out demographicsquestions and the standardized System Usability Scale.
We analyzed our data as follows. Since many tasks could
be completed in multiple ways, two researchers indepen-dently coded each response as â€œcorrect,â€ â€œpartially correct,â€or â€œcompletely incorrect,â€ meeting to resolve discrepancies.The â€œpartially correctâ€ category was used when a response didnot address a corner case. To compare categorical data (e.g.,the distribution of correct/incorrect responses), we used the Ï‡
2
test. To compare ordinal data (e.g., conï¬dence) we used theMann-Whitney U test. To correct p-values for multiple testing,we used the Holm method within each family of tests.
A key limitation is that the 14 tasks were not intended to
be a representative sample of all desired behaviors in TAPsystems. Because the tasks were based in part on Study 1,they likely over-represent behaviors that can be expressed asproperties. While our study can show whether some tasks areeasier to express as rules or safety properties, the proportionof tasks for which this is the case is not generalizable.
Results: A total of 81 Mechanical Turk workers participated
in Study 2. Three gave nonsensical free-response answers,leaving 78 valid participants.
For all 14 tasks, the percentage of correct responses was
higher for AutoTapâ€™s property-creation interface than for the
288
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:59:42 UTC from IEEE Xplore.  Restrictions apply. TAP rule interface. This difference was statistically signiï¬cant
for ï¬ve of these tasks (the bolded p-values in Figure 10). The
tasks for which we observed signiï¬cant differences gener-
ally required multiple rules to capture all corner cases. For
example, in the aforementioned Roomba task (Task 11 in
Figure 10), only one property is needed: â€œ the window curtains
are open SHOULD NEVER BE ACTIVE WHILE the Roomba
is on .â€ AutoTap automatically generates rules to satisfy this
property in all situations. However, two rules are required. One
possibility is a rule closing the curtains whenever the Roomba
turns on, and another turning off the Roomba whenever
the curtain is opened. Under 5% of participants wrote both
of these rules. While over 55% of participants who used
the property interface solved this task, one particular error
appeared commonly. The property â€œ the curtain is open AND
the Roomba is on SHOULD ALW AYS OCCUR TOGETHERâ€
inadvertently binds the two states, causing the Roomba to start
anytime the curtain is opened, misinterpreting the intent.
Participants often performed similarly with the rule and
property interfaces when both a single rule and a single
property sufï¬ced. For example, Task 3 (preventing a room
from getting too hot) required only one of each. Participants
performed similarly with either interface. AutoTapâ€™s prop-
erty interface was more successful when multiple rules were
needed to capture corner cases. Two tasks caused participants
great difï¬culty, even for properties. Task 7 required either two
properties or six rules. All participants missed corner cases.
Task 13 dealt with delaying vacuuming when guests were over,
requiring either two properties or two rules. Most participants
neglected to start the vacuuming after a delay.
We compared the System Usability Scale scores provided
by users to the rule interface and AutoTap property interface.
We found both interfaces to be â€œusableâ€, with mean scores of
70.4 and 63.2 respectively. This difference was not statistically
signiï¬cant (Mann-Whitney U= 590.5,p=.052).
B. TAP Program Synthesis
We further check if AutoTap can synthesize TAP rules from
scratch to accomplish all 14 tasks in this user study. In a less
challenging version, one of the authors (representing an expert
user) wrote properties for every task, and AutoTap successfully
synthesized TAP rules for all tasks.
In a more challenging version, we used allthe correct prop-
erties written by user-study participants (158 sets of properties
in total, with each from one participant targeting one task).
Sets contain 1.83properties on average. These properties were
transformed into LTL formulas following Table I. AutoTap
successfully generated TAP programs for 157 out of the 158
property sets, and all are guaranteed to satisfy corresponding
properties. The only set that AutoTap failed to synthesize is
for â€œWhen Bobbie is in the kitchen, the oven door should
be closedâ€ and â€œWhen Bobbie is in the kitchen, the oven
door should be locked.â€ If Bobbie enters the kitchen when
the oven door is open, the system needs to trigger two actions
immediately, both closing and locking the oven door. AutoTap
fails to ï¬nd a solution because it currently only considersTABLE II: How AutoTap ï¬xes buggy TAP programs. Sub-
scripts are the # of cases AutoTap patches revert the mutation.
Source #buggy TAP sets Successful Fixing
mutation: change trigger event 5 41
mutation: add condition 7 77
mutation: change condition 5 51
mutation: change action 4 30
mutation: delete rule 4 44
Total 25 2313
using a single action to redirect each bridge edge in the B Â¨uchi
Automaton. Future work can extend AutoTap to consider using
multiple actions to redirect a bridge, addressing this limitation.
We also checked how many TAP program candidates Au-
toTap generates for one property set. On average, AutoTap
generates 2.13candidates for one set, with a median of 1. The
largest set contains 27candidates. This is a special case as the
program consists of three rules. For every rule, the potential
action could be opening any one of three windows in a house.
Even in this case, end users will not face 27candidates at
once. They will only need to make a one-out-of-three choice
three times. As all candidates satisfy usersâ€™ desires, AutoTap
can also randomly pick one candidate.
C. TAP Program Fixing
We randomly take 10correct TAP program written by user-
study participants and apply a wide variety of mutations to
them, as shown in Table II. AutoTap successfully ï¬xes the
buggy TAP program to satisfy the given property in 23 out
of 25 cases, showing its generality across different types of
TAP bugs. The two cases where AutoTap fails are like the
following. The task is â€œthe thermostat should never be above
80â—¦Fâ€, and the rule is â€œIF thermostat goes above 80â—¦F, THEN
set thermostat to 81â—¦Fâ€, with the action randomly mutated
from â€œ set thermostat to 75â—¦Fâ€. Since the buggy rule triggers
itself recursively and AutoTap does not regard intermediate
triggering states as violating properties, AutoTap could not
identify the bridge edges and hence did not repair the program.
As also shown in Table II, AutoTap often generates a
patch to revert the add-condition mutation or the delete-rule
mutation, but not for all types of mutations. The reason is that
AutoTap only ï¬xes the part of a TAP program that violates
the safety property. If a rule becomes a non-violating different
rule after mutation, AutoTap will not revert the mutation back.
D. Handling Multiple Properties
Properties that share the same capabilities of devices some-
times interfere with each other. We evaluated AutoTap on
7scenarios where such things happened, with each scenario
combining different property sets in our user study together.
For example, one scenario could contain two properties â€œthe
living room window, the bedroom window and the bathroom
window should never be closed together ( Ï†)â€ and â€œthe living
room window should always be closed while it is raining ( Ïˆ)â€.
AutoTap simply combines different properties Ï†andÏˆ
together as Ï†âˆ§Ïˆ. It successfully handles all scenarios by
289
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:59:42 UTC from IEEE Xplore.  Restrictions apply. generating TAP programs to satisfy every multi-property sce-
nario unless the properties conï¬‚ict with each other. In the latter
case, AutoTap correctly reports that no TAP rules can possi-
bly guarantee all the properties. One example of conï¬‚icting
properties is â€œthe window should always be openâ€ and â€œthe
window should never be open when the air conditioner is on.â€
VII. T HREA TS TO AUTO TAPâ€™SVALIDITY
AutoTap is not guaranteed to generate patches for every LTL
safety property. Patches are generated by the current prototype
of AutoTap when (1) bridge edges are found, and (2) the
bridge can be cut with a single TAP rule. The 1 out of 158
cases where AutoTap fails to synthesize a TAP program in
Section VI-B violates the second assumption. The 2 out of 25
cases where AutoTap fails to ï¬x a TAP program in Section
VI-C violates the ï¬rst assumption. Both limitations can be
ï¬xed by future extensions to AutoTap. Furthermore, the ï¬rst
assumption does not hold if every state is accepting, meaning
that no matter what actions we take in the system, we cannot
prevent it from triggering a violation. The second assumption
does not hold when there are no controllable actions to escape
from a property violation. That is, only events out of our
control (e.g, changing the weather) help. These scenarios occur
when the system lacks critical functionality or the property
itself is conï¬‚icting, which is out of scope for AutoTap.
We focus on TAP instead of other smart-device languages
mainly because TAP is widely used [8] and easy for end-
users to understand [9]. AutoTap is not limited to TAP .
Cutting bridge edges that cause property violations can be
accomplished in other automation languages, too. In fact, we
feel that some bridges might be better ï¬xed by â€œdisabling
rulesâ€ that can conditionally disable actions.
AutoTap currently does not consider issues like actions
failing to complete or not taking effect immediately [14].
Handling these issues requires device manufacturers to provide
a more accurate model of the system. Furthermore, users
can still make mistakes in writing properties. Their properties
might not reï¬‚ect their real intent. Properties could even conï¬‚ict
with each other, which AutoTap does not currently resolve.
VIII. R ELA TED WORK
TAP program bug-detection and ï¬xing : AutoTap is in-
spired by previous work [21], [22] that applied formal methods
to detect violations to LTL or CTL policies in TAP programs.
Previous work searches potential TAP patches by changing
trigger-states of existing TAP rules in three ways: (1) deleting
a conjunction clause; (2) adding a conjunction clause that
appears in the LTL/CTL policy; or (3) modifying numerical
parameters. Consequently, they cannot synthesize patches that
change TAP rulesâ€™ trigger events or rule actions, not to mention
creating new TAP rules from scratch. The end-user property-
speciï¬cation interface of previous work [22] only accepts
â€œ[states ]shall not happenâ€, missing many common desires.
TrigGen [23] detects a speciï¬c type of bug in OpenHAB
TAP programs [4] â€“ missing triggers. It works by checking
what events not included in the trigger could possibly affect therule conditions. Researchers have also developed techniques
for either crowdsourcing TAP rules [28] or synthesizing TAP
rules from natural language [26], [27]. Our synthesis and repair
techniques are complementary to those techniques.
Program synthesis using formal methods : Synthesizing
a program from a formal speciï¬cation, or LTL synthesis ,
has been an open problem [34]. Most work in this area
synthesizes reactive systems based on formal speciï¬cations
[18]â€“[20], [34]. AutoTap is related to, but also fundamentally
different from, such work. AutoTap needs to synthesize TAP
rules, not just ï¬nite state models, and needs to accommodate
for an existing ï¬nite state model (i.e., the smart-device sys-
tem model). Degiovanni et al. proposed an algorithm that
synthesizes control-operation programs, which have similar
syntax as TAPs, to satisfy formal requirements [25]. Due to
the different usage contexts, their algorithm, which uses SA T
solvers to iteratively resolve counter-examples by changing
existing rulesâ€™ trigger states, cannot add new rules or preserve
existing property-compliant behaviors.
Property-speciï¬cation interfaces : Past work in require-
ments engineering investigated how to let engineers specify
desired software properties. KAOS provided guidelines that
helped engineers gradually summarize or break down vague
requirements into deployable speciï¬cations [41]. PSPWizard
provided an interface where developers could choose from a
comprehensive list of templates, ï¬ll in the blanks of the chosen
template, and then have their inputs translated into formal
speciï¬cations [17]. In contrast with those efforts, we employed
a user study to identify commonly desired properties in smart-
home scenarios. We then designed property-speciï¬cation tem-
plates for expressing those properties through a compact
graphical interface. AutoTap users specify properties through
only mouse clicks, which is suitable for non-technical users.
IX. C ONCLUSIONS
With the wide adoption of smart devices, helping users
correctly express their intent for how these devices should
interact is crucial. AutoTap helps users by allowing them
to directly specify properties they wish to hold, rather than
writing rules for exactly how devices should behave in order
to satisfy those properties. To achieve this goal, we ï¬rst
conducted a user study to map the properties users commonly
desire. We then designed an easy-to-use interface for property
speciï¬cation and a technique supported by formal methods to
automatically synthesize TAP programs or program patches
that guarantee the system satisï¬es the speciï¬ed properties.
X. A CKNOWLEDGMENTS
This material is based upon work supported by the Na-
tional Science Foundation under Grants CCF-1837120, OAC-
1835890, CNS-1764039, CNS-1563956, CNS-1514256, and
IIS-1546543, as well as gifts from the CERES Center. We
thank Abhimanyu Deora for help with the user interface and
Roshni Padhi for help with the user studies.
290
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:59:42 UTC from IEEE Xplore.  Restrictions apply. REFERENCES
[1] T. Klosowski, â€œAutomation showdown: IFTTT vs Zapier vs Microsoft
Flow,â€ LifeHacker, June 26, 2016.
[2] M. Hughes, â€œMozillaâ€™s new Things Gateway is an open home for your
smart devices,â€ TheNextWeb, February 7, 2018.
[3] W. Mossberg, â€œSmartThings automates your house via sensors, app,â€
Recode.net, 2014.
[4] openHAB, https://www.openhab.org/.
[5] Home Assistant, https://www.home-assistant.io/docs/automation/.
[6] R. Chard, K. Chard, J. Alt, D. Y . Parkinson, S. Tuecke, and I. Foster,
â€œRipple: Home automation for research data management,â€ in Proc.
ICDCSW , 2017.
[7] B. Ur, M. Pak Y ong Ho, S. Brawner, J. Lee, S. Mennicken, N. Picard,
D. Schulze, and M. L. Littman, â€œTrigger-action programming in the
wild: An analysis of 200,000 IFTTT recipes,â€ in Proc. CHI , 2016.
[8] X. Mi, F. Qian, Y . Zhang, and X. Wang, â€œAn empirical characterization
of IFTTT: Ecosystem, usage, and performance,â€ in Proc. IMC , 2017.
[9] B. Ur, E. McManus, M. Pak Y ong Ho, and M. L. Littman, â€œPractical
trigger-action programming in the smart home,â€ in Proc. CHI , 2014.
[10] J. Huang and M. Cakmak, â€œSupporting mental model accuracy in trigger-
action programming,â€ in Proc. UbiComp , 2015.
[11] L. Yarosh and P . Zave, â€œLocked or not?: Mental models of IoT feature
interaction,â€ in Proc. CHI , 2017.
[12] A. A. Nacci, B. Balaji, P . Spoletini, R. Gupta, D. Sciuto, and Y . Agar-
wal, â€œBuildingrules: A trigger-action based system to manage complex
commercial buildings,â€ in Adjunct Proc. UbiComp , 2015.
[13] J. Brich, M. Walch, M. Rietzler, M. Weber, and F. Schaub, â€œExploring
end user programming needs in home automation,â€ ACM TOCHI ,
vol. 24, no. 2, p. 11, 2017.
[14] W. Brackenbury, A. Deora, J. Ritchey, J. V allee, W. He, G. Wang,
M. L. Littman, and B. Ur, â€œHow users interpret bugs in trigger-action
programming,â€ in Proc. CHI , 2019.
[15] Q. Wang, W. U. Hassan, A. Bates, and C. Gunter, â€œFear and logging in
the Internet of Things,â€ in Proc. NDSS , 2018.
[16] M. Surbatovich, J. Aljuraidan, L. Bauer, A. Das, and L. Jia, â€œSome
recipes can do more than spoil your appetite: Analyzing the security
and privacy risks of IFTTT recipes,â€ in Proc. WWW , 2017.
[17] M. Lumpe, I. Meedeniya, and L. Grunske, â€œPSPWizard: machine-
assisted deï¬nition of temporal logical properties with speciï¬cation
patterns,â€ in Proc. ESEC/FSE , 2011.
[18] J. R. B Â¨uchi and L. H. Landweber, â€œSolving sequential conditions
by ï¬nite-state strategies,â€ Transactions of the American Mathematical
Society , vol. 138, pp. 295â€“311, 1969.
[19] N. Piterman, A. Pnueli, and Y . Saar, â€œSynthesis of reactive (1) designs,â€
inProc. VMCAI , 2006.
[20] E. Letier and W. Heaven, â€œRequirements modelling by synthesis of
deontic input-output automata,â€ in Proc. ICSE , 2013.
[21] C.-J. M. Liang, L. Bu, Z. Li, J. Zhang, S. Han, B. F. Karlsson, D. Zhang,
and F. Zhao, â€œSystematically debugging IoT control system correctness
for building automation,â€ in Proc. BuildSys , 2016.[22] L. Bu, W. Xiong, C.-J. M. Liang, S. Han, D. Zhang, S. Lin, and X. Li,
â€œSystematically ensuring the conï¬dence of real-time home automation
IoT systems,â€ ACM TCPS , vol. 2, no. 3, p. 22, 2018.
[23] C. Nandi and M. D. Ernst, â€œAutomatic trigger generation for rule-based
smart homes,â€ in Proc. PLAS , 2016.
[24] Z. B. Celik, P . McDaniel, and G. Tan, â€œSOTERIA: Automated IoT safety
and security analysis,â€ in Proc. USENIX ATC , 2018.
[25] R. Degiovanni, D. Alrajeh, N. Aguirre, and S. Uchitel, â€œAutomated goal
operationalisation based on interpolation and SA T solving,â€ in Proc.
ICSE , 2014.
[26] X. Chen, C. Liu, R. Shin, D. Song, and M. Chen, â€œLatent attention for
if-then program synthesis,â€ in Proc. NIPS , 2016.
[27] C. Quirk, R. Mooney, and M. Galley, â€œLanguage to code: Learning
semantic parsers for if-this-then-that recipes,â€ in Proc. ACL , 2015.
[28] T.-H. K. Huang, A. Azaria, and J. P . Bigham, â€œInstructablecrowd:
Creating if-then rules via conversations with the crowd,â€ in Proc. CHI
Extended Abstracts , 2016.
[29] J.-b. Woo and Y .-k. Lim, â€œUser experience in do-it-yourself-style smart
homes,â€ in Proc. UbiComp , 2015.
[30] E. Fernandes, A. Rahmati, J. Jung, and A. Prakash, â€œDecentralized action
integrity for trigger-action IoT platforms,â€ in Proc. NDSS , 2018.
[31] E. Oswald, â€œIFTTT competitor Stringify gets a major update,â€ TechHive,
June 22, 2016.
[32] A. Rahmati, E. Fernandes, J. Jung, and A. Prakash, â€œIFTTT vs. Za-
pier: A comparative study of trigger-action programming frameworks,â€
arXiv:1709.02788 , 2017.
[33] C. Baier and J.-P . Katoen, Principles of model checking . MIT press,
2008.
[34] R. Bodik and B. Jobstmann, â€œAlgorithmic program synthesis: Introduc-
tion,â€ International Journal on Software Tools for Technology Transfer ,
vol. 15, no. 5, pp. 397â€“411, Oct 2013.
[35] Samsung, â€œCapabilities reference,â€ https://docs.smartthings.com/en/
latest/capabilities-reference.html, Accessed February 2019.
[36] R. Gerth, D. Peled, M. Y . V ardi, and P . Wolper, â€œSimple on-the-ï¬‚y
automatic veriï¬cation of linear temporal logic,â€ in Proc. PSTV , 1995.
[37] A. Duret-Lutz, A. Lewkowicz, A. Fauchille, T. Michaud, E. Renault,
and L. Xu, â€œSpot 2.0a framework for ltl and Ï‰-automata manipulation,â€
inProc. ATVA , 2016.
[38] R. Koymans, â€œSpecifying real-time properties with metric temporal
logic,â€ Real-time systems , vol. 2, no. 4, pp. 255â€“299, 1990.
[39] R. Alur and D. L. Dill, â€œA theory of timed automata,â€ Theoretical
Computer Science , vol. 126, no. 2, pp. 183â€“235, 1994.
[40] G. Ghiani, M. Manca, F. Patern `o, and C. Santoro, â€œPersonalization
of context-dependent applications through trigger-action rules,â€ ACM
TOCHI , vol. 24, no. 2, p. 14, 2017.
[41] R. Darimont, E. Delor, P . Massonet, and A. van Lamsweerde,
â€œGRAIL/KAOS: An environment for goal-driven requirements engineer-
ing,â€ in Proc. ICSE , 1997.
291
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:59:42 UTC from IEEE Xplore.  Restrictions apply. 