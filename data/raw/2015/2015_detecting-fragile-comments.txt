Detecting Fragile Comments
Inderjot Kaur Ratol and Martin P . Robillard
School of Computer Science
McGill University
Montr ´eal, QC, Canada
{inderjot.ratol@mail,martin@cs}.mcgill.ca
Abstract —Refactoring is a common software development
practice and many simple refactorings can be performed au-
tomatically by tools. Identiﬁer renaming is a widely performedrefactoring activity. With tool support, rename refactorings can
rely on the program structure to ensure correctness of the
code transformation. Unfortunately, the textual references to the
renamed identiﬁer present in the unstructured comment textcannot be formally detected through the syntax of the language,
and are thus fragile with respect to identiﬁer renaming. We
designed a new rule-based approach to detect fragile comments.Our approach, called Fraco, takes into account the type of
identiﬁer, its morphology, the scope of the identiﬁer and the
location of comments. We evaluated the approach by comparingits precision and recall against hand-annotated benchmarks
created for six target Java systems, and compared the results
against the performance of Eclipse’s automated in-comment iden-
tiﬁer replacement feature. Fraco performed with near-optimal
precision and recall on most components of our evaluation dataset, and generally outperformed the baseline Eclipse feature. As
part of our evaluation, we also noted that more than half of the
total number of identiﬁers in our data set had fragile commentsafter renaming, which further motivates the need for research
on automatic comment refactoring.
Index T erms—Software evolution, refactoring, source code
comments, inconsistent code, fragile comments.
I. I NTRODUCTION
With the evolution and growth of a software system often
comes the need for internal improvements to its structure and
organization, known as refactoring [1]. Refactoring a system
helps maintain the quality of the code and increases com-prehensibility. Individual refactorings can take many forms,including renaming code elements, extracting statements into
a method, and changing a method’s signature. Renamingelements is, in particular, a very common type of refactoring
performed to maintain a set of names that reveal the purposeof the code elements to facilitate code comprehension [2].
Many refactorings can be fully or partly automated by
tools [3]. Examples include JetBrains Resharper [ 4] for C#
and Eclipse’s built-in refactoring tool [5] for Java. Such
tools support code transformation by automatically changinga system’s source code based on a selection from the catalogof refactorings and, when applicable, the parameterization ofthe refactoring. Studies show that renaming code elements isone of the most popular refactoring activities performed usingautomated refactoring tools [6], [7], [8].
Automating laborious refactoring tasks, such as renaming
identiﬁers, relies heavily on encoded knowledge of the rules of
the programming language to perform correct transformations.Unfortunately, references to a renamed identiﬁer in unstruc-tured comment text cannot be formally detected through the
syntax of the language, and are thus fragile with respect toidentiﬁer renaming. We use the term fragile comments to
refer to comments which, upon modiﬁcation to the code,become inconsistent. In one study of three different projects,the authors observed that 97% of the code changes made whilerefactoring also needed to change the comments to maintainconsistency [9]. Inconsistencies between code and commentsare a problem because programmers rely on comments tounderstand the code and relationships between the differentparts of code, its usage and to communicate amongst eachother [10], [11], [12]. To avoid introducing inconsistencies
between comments and code during refactoring, automatic
refactoring tools need additional support to detect fragilecomments and potentially update them.
Existing techniques for comment synchronization fall into
two camps. In the ﬁrst camp, we have simple approaches
based on exact lexical search and replacement. For example,the refactoring support in Eclipse’s Java development toolscomponent [13] provides an option to search-and-replaceoccurrences of a renamed identiﬁer in text strings includingcomments. Pure lexical approaches can be helpful in somecases, but their precision is too low to be useful in the
general case. In the case of semi-structured comments (e.g.,
when combined with the use of in-comment tags such as
@param in Java), text-replacement based approaches typically
work much better, but these constitute a small subset of allpossible comments that forms the easiest subset of identiﬁerreferences to detect. In the second camp, we have specialized
but domain-speciﬁc approaches that can detect inconsistenciesbetween comments and code for programming concepts like
synchronization, locking and memory allocation [14], [15],
[16]. Although domain-speciﬁc techniques can achieve impres-sive precision, they are limited to a specialized subset of allpossible types of comments.
With this paper, we advance the state-of-the-art of refac-
toring techniques by introducing Fraco, a general-purpose
tool-supported approach for detecting fragile comments whenrenaming identiﬁers in a Java source code. Fraco relies ona new rule-based algorithm that takes into account the type
of an identiﬁer, its morphology, the scope of the identiﬁer,
and the location of comments. By taking into account com-mon commenting practices and language rules, the approachavoids the limitation of naive text-replacement approaches that
978-1-5386-2684-9/17/$31.00 c/circlecopyrt2017 IEEEASE 2017, Urbana-Champaign, IL, USA
T echnical Research112
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:48:34 UTC from IEEE Xplore.  Restrictions apply. generate large amounts of false positives, while not including
any domain-speciﬁc rules that would limit the approach to asubset of comment types.
We evaluated Fraco by comparing its precision and re-
call against a manually-created benchmark of six target Java
systems, and compared the results against the performanceof Eclipse’s automated in-comment identiﬁer replacementfeature. The tool performed with near-optimal precision andrecall on most components of our benchmark, and generallyoutperformed the baseline Eclipse feature. As part of ourevaluation, we also noted that more than half of the totalnumber of identiﬁers in our data set had fragile commentsafter renaming, which further motivates the need for researchon automatic comment refactoring.
The contributions of this paper include a)a general and
language-independent formulation of the problem of fragile
comment detection; b)a tool-supported algorithm for the
automatic detection of renaming-induced fragile commentsin Java source code; c)a publicly-available
1benchmark of
fragile comments that can be used for independent research;
d)empirical data evaluating both the proposed algorithm and
a publicly-accessible tool available as part of the Eclipse IDE.
The remainder of this paper is organized as follows. In
Section IIwe illustrate the challenges of detecting fragile
source code comments. In Section IIIwe present a precise
formulation of the fragile comment detection problem thatcan be instantiated for different programming languages. In
Section IVwe describe our detection algorithm and tool for
the Java language. Sections Vand VIwe present the design
of the evaluation study and the results obtained. We describethe related work in Section VII and conclude in Section VIII.
II. M
OTIV A TION
We illustrate the challenge of detecting fragile comments
when renaming identiﬁers with three cases taken from thesource code of the Checkstyle project version 7.2 [17]. Weenhance the discussion with descriptions of the behavior ofEclipse’s in-comment identiﬁer replacement feature, which wewill refer to as Eccore (Eclipse Comment Refactoring).
Checkstyle deﬁnes a class
Check that is the base class
for various checking rules. Here the issue is that “check” isalso a very commonly used word when documenting methods,such as the one illustrated in Figure 1. If we wish to rename
class
Check toRule for example, a naive text replacement
feature, such as Eccore, will erroneously replace all commentsthat simply indicate that a method “checks” something, thusgenerating an outrageous number of false positives.
/**
*Check whether a class may be considered as
*a checkstyle module. Checkstyle’s modules are
*non-abstract classes [...]
*/
private static boolean isCheckstyleModule(Class<?>
loadedClass) {
Fig. 1. Example of false positive when renaming the class named Check .
1http://www.cs.mcgill.ca/ ∼swevo/FracoAnother challenge is to determine where to be permissive or
strict with case and word morphology. For example, Check-
style deﬁnes a public inner class Listener . If we wish to
rename Listener toObserver , a general case-insensitive
matching strategy would generate many false positives, while
a case-sensitive matching strategy (such as Eccore) wouldmiss important comments such as the use of the keyword
listener in Figure 2. In this case the fragile comment
detection technique needs to be sensitive to the scope of thecomments.
/**Represents a custom listener. */
public static class Listener {
private String className; /*Name of the listener */
/**@return the class name of listener. */
public String getClassname() {return className; }
}
Fig. 2. Example of false negatives when using case-sensitive matching.
As a ﬁnal example, we note that some comments can come
very close to referring to an identiﬁer without actually men-tioning the identiﬁer. Figure 3shows a typical case of identiﬁer
re-statement in plain language. In this situation, ﬂipping the
polarity of the boolean ﬁeld would require a renaming ofthe identiﬁer to something like
setUseInlineTags , which
would silently render the comment inconsistent with the code.
This case is also not detected by Eccore. These examples
/**
*Sets whether inline tags must be ignored.
*@param ignoreInlineTags whether inline tags
*must be ignored.
*/
public void setIgnoreInlineTags(boolean ignoreInlineTags){
Fig. 3. Example of indirect mentions of identiﬁers.
only illustrate a small subset of the situations where it isnon-trivial to accurately detect fragile comments. In general,the richness and variety of commenting practices means thatsimple text-replacement algorithms cannot adequately copewith the problem of detecting fragile comments.
III. P
ROBLEM FORMULA TION
The problem of fragile comment detection is cast in the
context of a software project which comprises a number of
program elements and a number of comment units.
Technically, a program element is any element that can be
deﬁned in a program. In this project, we are only concernedwith program elements that can be explicitly named. Conse-quently, in our problem formulation a program element has acorresponding declaration and identiﬁer. The declaration is
the program text that deﬁnes the program element, whereas theidentiﬁer is the part of the declaration that names the element.
Declarations fall into different categories based on the type ofelement they deﬁne (e.g., class, method, local variable).
Acomment unit is any bounded unit of text considered
to be comments according to the syntax of a programminglanguage. Block and line comments are the most commontypes of comment units. In the remainder of this paper,we refer to comment units simply as comments. Within a
comment, a phrase is any coherent set of characters. Note
113
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:48:34 UTC from IEEE Xplore.  Restrictions apply. that, when necessary, we distinguish between a phrase and
a phrase’s text. This distinction is necessary when commentshave multiple occurrences of some text of interest. We saythat a phrase in a comment refers to a program element if an
informed developer can determine that the phrase purposefully
and speciﬁcally refers to the element. We formalize thisconcept as the refersTo relation. For example, in Figure 4,
private Buffer buffer;
/**Reloads the existing buffer. */
public void reload() {
if(buffer != null) { buffer.load(); }}
Fig. 4. Examples of the refersTo relation
the phrase “buffer” in the comment block refers to the ﬁeld
buffer of the same class. In this case, the phrase “buffer” in
the comment can be said to refer to the ﬁeld buffer .
Conceptually, tuples /angbracketleftphrase, element/angbracketright that are members of
the refersTo relation fall into two categories:
Lexical match: The phrase’s text is the same as the text
of the declaration’s identiﬁer, with some tolerance for minorvariations (e.g., case sensitivity). It is important to note thatlexical matches do not necessarily imply a refersTo relation
because of synonymy: it is possible that a comment mentionsan identiﬁer that is shared by multiple program elements, orsimply refers to a general concept after which an identiﬁer isnamed (e.g., “ﬁle”).
Semantic match: The phrase semantically matches a program
element if the most likely interpretation of the phrase by an
expert is that it refers to the element. For pragmatic reasons,
we deﬁne semantic matches as the class of matches that aresemantic without being also lexical.
If a phrase refers to an element, we consider that the phrase
is at risk of being invalidated if the identiﬁer is renamed, andwe deem it fragile with respect to this identiﬁer. By extension,
a comment is considered fragile with respect to an identiﬁer
if it contains at least one fragile phrase.
Because the refersTo relation requires human judgment,
it can only be approximated by an automatic approach. To
distinguish between phrases that truly refer to an element
and phrases estimated to refer to an element, we deﬁne therelation matches which contains a tuple /angbracketleftphrase, element/angbracketright if
the corresponding algorithm estimates that the phrase refers tothe element.
Our proposed approach is therefore an implementation of
thematches relation, and its performance can be measured
on a per element basis. Given an element e, let refersTo(e)
be the set of all phrases that refer to this element, and let
matches(e) be the set of all phrases estimated to refer to
this element. The true set of fragile phrases for eis thus
refersTo(e) and a solution instance given by an algorithm
ismatches(e). With these deﬁnitions, we easily derive the
standard performance measures of precision P(e)and recall
R(e)for an implementation of matches:
P(e)≡|matches(e) ∩refersTo(e)|
|matches(e)|
R(e)≡|matches(e) ∩refersTo(e)|
|refersTo(e)|Although precision can be measured accurately, a major
obstacle to computing recall is that in the general case the
extent of refersTo(e) is not known.
IV . A PPROACH
Our approach is deﬁned in terms of a given program element
declaration. We divide the processing required to detect fragilecomments into four conceptual phases. First, we detect all
comments and link them to the input declaration (§IV-A). We
then ﬁlter out some comments based on the program’s scoping
rules (§IV-B). The remaining comments are then preprocessed
for textual analysis, along with the identiﬁer of the inputprogram element (§IV-C). Finally, we apply various matching
rules to the resulting data (§IV-D–§IV-F).
We implemented our approach for the Java programming
language, but we hypothesize that it should be straightforwardto adapt it to other programming languages. To facilitatefuture adaptations, we describe our approach in a language-
independent manner to the extent possible, and supply theJava-speciﬁc implementation details when applicable. How-
ever, we make no claim about the potential ease with whichthe approach can be adapted to other programming languages.We provide tool support for fragile comment detection in Javathrough an Eclipse plug-in called Fraco.
A. Detecting and Linking Comments
Intuitively, comments that are located meaningfully “close”
to a declaration should be treated differently from general
comments in the program. We capture this intuition with the
concept of comment locality. For a given declaration, the
comments in a system’s source code can thus be divided intotwo categories: local and global.
Local Comments: To qualify as a local comment for a declara-
tion, a comment must either be a header for the declaration, or
be lexically located within the declaration (which we refer toas an inner comment). A declaration can have zero or one
header comment. A comment is considered a declaration’s
header if it is located immediately above the declaration(without any consideration for white space in between). Asfor inner comments, only declarations that have a lexical body
can have inner comments. This includes classes and methods,
but excludes ﬁelds and local variables. The relation between an
inner comment and its corresponding declaration is transitive,so that, for example, inner comments for a method or innerclass are also considered inner comments for the declaring
class.
Global Comments: For a given declaration, all comments that
do not qualify as local comments automatically fall into the
global category. For example, given a class declaration, all
the comments that appear within or above other classes areconsidered global to the input declaration.
B. Scope-Based Filtering
In practice, the problem of searching for fragile comments
can be mitigated if we observe that the scoping rules of
the programming language greatly affect the likelihood that
114
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:48:34 UTC from IEEE Xplore.  Restrictions apply. a given comment may contain a phrase that refers to a given
declaration. For example, in a realistic Java code base it wouldbe surprising to see an in-line comment in a method referto a local variable deﬁned in a different method. We capturethis intuition by deﬁning the function applies which takes as
input a declaration and all the comments for a program, and
returns the subset of the comments where the declaration can
be expected to be visible.
The precise deﬁnition of the applies function is language-
dependent and must take into account both the scoping rules of
the language and practical knowledge of common commentingpractices for this language. We implemented the function forJava based on the Java Language Speciﬁcations, Java SE 8
Edition [18]. The implementation of the applies function can
be reduced to a lookup in a scope table, which we provide asan appendix.
C. Preprocessing
Both identiﬁers and comments must be preprocessed before
we can apply matching rules. The preprocessing steps for
identiﬁers and comments are similar, but for clarity we detailthem separately.
Identiﬁers: Conceptually an identiﬁer consists either of a
single term, or of multiple terms that can be distinguished
through typographical conventions. The ﬁrst step in prepro-cessing identiﬁers is to split them into terms. We split theidentiﬁers using camel casing rules, with an additional rule topreserve acronyms. After a compound identiﬁer is split intotwo or more terms, we tag each term with its part-of-speech(POS) tag and identify its lemma (word root). POS tagging andlemmatization are two common natural language processingtechniques used for text analysis.
A POS tag is a label that we associate with a word to
indicate its function (generally in a sentence, but also in a
sentence fragment, such as an identiﬁer). For example, inthe identiﬁer
addListener , upon tagging a single word at
a time, the term add would be tagged as a verb and the term
listener as a noun. We use the POS tagger of Stanford Core
NLP library [19] to perform POS-tagging. Comparing lemmasinstead of original words can help pave over non-essential
differences such as use of the singular or plural form of aword, or different conjugations of a verb. For lemmatization,we use Stanford Core NLP library’s Lemmatizer. The prepro-cessing step generates two dictionaries as output containing/angbracketleftterm,POS-tag/angbracketright tuples and /angbracketleftterm,lemma/angbracketright tuples respectively
for each term found in the identiﬁer.
Comments: We preprocess the comments by ﬁrst split-
ting them into sentences using rules based on the regular-
expressions we designed. Standard punctuation-based algo-
rithms do not work well for comments because of the commonpresence of source-code elements that include punctuation. Forthe purpose of sentence-splitting, block and in-line commentsare treated differently. The Javadoc block comments are splitinto sentences based on the list of delimiters we devised. It
includes period, comma, semi-colon, angle brackets and “#”.We do not split sentences using characters that are legal to usefor Java identiﬁers (e.g., underscore) to preserve any identiﬁers
present in the comments. We split in-line comments basedon periods and commas. Sentences are then further split intotokens using white space as a separator. Finally, tokens that
are detected (through a regular expression) to be compound
code terms (such as
addFigure ) are further split as identiﬁers.
However, we keep both the split and un-split version of thetoken because some matching rules work with the original
term (see below). After tokenization, we remove stop words(e.g., “the”, “an”) from the list of tokens obtained. Finally,we apply lemmatization to the tokens in the list. For POS-
tagging, the comments are tagged with the parts-of-speech ona sentence basis, i.e. a whole sentence is assigned the parts-
of-speech tags at once, whereas identiﬁer’s terms are taggedindividually.
D. Overview of Matching Rules
We implement the matches(e) function through a number of
matching rules. The matching rules can be roughly organized
into two categories: (mostly) lexical rules that target the text
of phrases and identiﬁers, and (more) semantic rules that seek
to match comments and identiﬁers that refer to the same thingdespite having different spelling. We organize the rules inthese two categories to facilitate the presentation, but it shouldbe noted that most matching rules are neither purely lexicalnor semantic, but involve a combination of features. Given anelement e, the approach returns the union of the results of both
lexical and semantic rules.
In the case of lexical matching, spelling and typographical
errors are technically a potential cause of false negatives. Weoriginally considered to mitigate this issue by including a rulethat implemented fuzzy lexical matching. We experimentedwith a pair-wise comparison of letters in both the identiﬁer
and matching phrase. However, none of the systems in our
development set contained a single instance of a referencebetween a phrase and an identiﬁer that was found throughfuzzy matching alone. For this reason we do not consider fuzzymatching to be necessary and left it out of the ﬁnal version ofthe approach.
E. Lexical Matching Rules
The assumption behind lexical matching is that if a phrase
has the same text as a element’s identiﬁer, it may refer to it. In
practice, however, returning all instances of phrases whose text
matches an identiﬁer produces a deluge of false positives due
to synonymy. Additionally, limiting the search to exact lexicalmatches misses cases where the name of some identiﬁers istransformed morphologically (e.g., used in the plural, suchas “receives the
Events ” which refers to class Event ). We
therefore devised a new algorithm for lexical matching of
program identiﬁers that takes into account the type of theidentiﬁer, its morphology, and the location of the comment
containing a phrase.
Table Iprovides a case-based speciﬁcation of the algorithm.
Each cell in the table details the matching variant for one of14 possible cases determined by the type of identiﬁer, whether
115
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:48:34 UTC from IEEE Xplore.  Restrictions apply. the identiﬁer is a single or compound term, and whether the
phrase to match is in a local or global comment. The matchingrules are expressed as predicates using the binary operators andfunctions detailed in Table II.
As it can be observed, more complex rules are necessary
to determine the correct matches for simple terms (e.g.,
add ,
copy ) due to their common use in program text which creates
a massive amount of ambiguity. We illustrate how to use the
matching rules through an example, assuming that we wantto determine the comments that are fragile with respect to thedeclaration of a method
copy declared in class Interval of
some given project and that the comment in Figure 5is under
consideration. We consider two cases: ﬁrst, if the comment is
a local comment for the method (i.e., its header block), andthen if the comment is a global comment that is not associated
with the method.
/**
*Make a copy of this interval.
*/
Fig. 5. Sample comment unit.
Considering the comment shown in Figure 5as a local
comment, we look at the Cell 2,3of Table I, which speciﬁes
that a phrase matches the identiﬁer if p≈i. The only phrase
in the comment that validates this predicate is copy because
copy≈copy , so the rule returns the only instance of the
string “copy” in the comment.
However, in the case where the comment is global, the
rule of Cell 1,3of Table Iapplies. The ﬁrst part of the rule
states that any matched phrase must be the same as theidentiﬁer (insensitive of case). However, in this case there is anadditional requirement. To limit false positives, it is necessarythat either the phrase be followed by parentheses, indicatingthe reference to a method, or the method’s declaring class mustbe found in the comment. Thus, the rule matches the instanceof the string “copy” because of its verbatim similarity with thedeclaration in question. But, if the comment did not include
the sufﬁx “of this interval”, the rule would return an emptyset for the comment.
F . Semantic Matching Rule
The lexical rules match identical or near-identical terms
pairwise. In many situations, a set of keywords in the text
of the comments can refer, as a whole, to an identiﬁer. Wedesigned a matching rule to capture this situation. Because thisrule is intended to match “units of meaning” in comments thatare likely to refer to an identiﬁer, we refer to it as “semantic”to distinguish them from the lower-level text matching rulesdescribed in the previous section. The semantic matching ruleis applicable only to the local comments.
Given all the (non-stopword) lemmas of an identiﬁer ob-
tained as described in IV-C, the approach looks for identical
lemmas in the text of the comment unit. If all lemmas arefound, the corresponding lemmas in the comment are returnedas the fragile phrase.
For instance, as shown in Figure 6, after preprocessing
the comment and identiﬁer which includes the removal ofstop words like “and”, the sentence contains 4 token-lemmasmatching the 4 term-lemmas of the identiﬁer. The imple-
/**
*Parses block comment as javadoc and prints its tree.
*@param node block comment begin
*@return string javadoc tree
*/
private String parseAndPrintJavadocTree(DetailAST node)
Fig. 6. Example from Checkstyle’s source code.
mentation of this semantic matching heuristic must take intoaccount some of the idiosyncracies of common commenting
practices that depend on the type of identiﬁer being matched.
Methods: There are two special cases for method identiﬁers:
(1) If a method’s identiﬁer has the word
get as its ﬁrst
term, the term can be matched with both the word get and the
tag@return or lemma return in a comment. The @return
tag signiﬁes the return of a value which aligns with the main
functionality of the getter methods and therefore justiﬁes theuse of
@return in place of the word get . For example, in
the code below the phrase /angbracketleftlast ,node/angbracketrightwould be returned:
/**
*@return the last node that was selected,
*or null if there are no Nodes selected.
*/
public Node getLastNode()
(2) If a method’s identiﬁer starts with is and has a local
comment of type Javadoc, for instance isSelected , the word
isis not matched and instead we look for the presence of the
word “true” or “false” immediately following the @return
tag. This strategy is a performance-motivated proxy for veri-fying that the method returns a boolean. For example, in thecode below the phrases /angbracketleft
member ,Enum/angbracketrightand/angbracketleftenum ,member/angbracketright
on line 2 and 4 respectively would be returned as fragile:
/**
*Checks if current AST node is member of Enum.
*@param ast AST node
*@return true if it is an enum member
*/
private static boolean isEnumMember(DetailAST ast)
Local V ariables: In one special case for matching formal
parameters, if the comment is a Javadoc comment, we match
the parameter’s name only against the tokens present in thetext related to its
@param tag, leaving out the rest of the text.
G. Tool Support
We developed our complete approach as an Eclipse plug-
in called Fraco. The plug-in seamlessly integrates the normal
Eclipse-based workﬂow. The detection of the matches output
is triggered whenever the user renames an identiﬁer using
Eclipse’s usual Rename refactoring feature. The results, i.e.
the fragile phrases with respect to the renamed identiﬁer, arereported as Eclipse warning markers, which by default appear
in the Problem View and as annotations in the gutter (sidebar)
of Eclipse’s Java editor. From the Problem View, a developercan click on a fragile comment warning to immediately access
the location of the fragile comment detected by our approach.
H. Development of the Approach
We developed the approach iteratively using three code
bases as a development set. The development set included
116
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:48:34 UTC from IEEE Xplore.  Restrictions apply. TABLE I
LEXICAL MA TCHING RULES .pREFERS TO THE INPUT AND iTO THE IDENTIFIER OF THE ELEMENT UNDER PROCESSING .EACH NON -HEADER CELL IN
THE BOTTOM TWO ROWS IS REFERRED AS Cell r,c WHERE rIS THE ROW NUMBER WITH V ALUE EITHER 1OR2AND cIS THE COLUMN NUMBER RANGING
FROM 1TO7. T HE OPERA TORS ARE DEFINED IN TABLE II.
Comment Type Types Methods Fields Locals
One term Multiple
termsOne term Multipleterms One term Multipleterms
GlobalComment(p˜ =i)∧(noun(p)∨
paren(p))p˜ =i(p≈i)∧
(decl(i, p) ∨
paren(p))p=i(p=i)∧
(upper(i )∨
decl(i, p))p=i p=i
Local Comment (p˜≈i)∧(noun(p)) p˜≈i p≈i p=i p≈i p=i p=i
TABLE II
OPERA TORS USED IN THE RULES OF TABLE I.W HEN A PHRASE pIS USED
AS INPUT ,WE ASSUME THA T ITS COMMENT -CONTEXT (T H ER E S TO FT H E
TEXT IN THE COMMENT )IS ALSO A V AILABLE TO THE OPERA TOR
(REPRESENTED AS cIN THE EXAMPLES ). W HEN AN IDENTIFIER iIS USED
AS INPUT ,WE ASSUME THA T ITS DECLARING ELEMENT IS ALSO
A V AILABLE TO THE OPERA TOR (REPRESENTED AS dIN THE EXAMPLES ).
Operator Description Positive Example
= Case-sensitive match Tag=Tag
≈ Case-insensitive match Tag≈tag
˜ =Case sensitive match thattolerates the plural formTag˜ =Tags
˜≈Case-insensitive match thattolerates the plural formtag˜≈Tags
noun(p)True if the POS tag of pis a
noun or proper noun (sensitiveto the language model used in
the POS tagger)noun( tag)
paren(p)True if pis immediately
followed by the opening andclosing round parenthesis
having number of tokens inbetween the parenthesis equal to
the number of declaration’s
arguments, if any.paren( read)
where c=
...read(File)... and
d=copy(String
file)
decl(i, p)True 1) If pis present in the i’s
declaring class. OR 2) If ﬁrstcondition is false, check if thesimple name of i’s declaring
class can be found in the samecomment as p, without
considering case.decl(copy, copy)
where c=...copy
this
interval... and
d=Interval
upper(i)True if iis all in upper case
charactersupper(SORTED)
Checkstyle, the Google Guava library, and JetUML. We man-
ually studied the relationship between the identiﬁers and com-
ments to form a collection of heuristics needed to detect thefragile comments. Initially, we tried lexical matching withoutthe additional constraints shown in Table I. As one would
expect, it created more false positives than correct matches. We
then integrated the concept of proximity between the identiﬁerand a comment and introduced the distinction as local and
global comments. This strategy curbed the number of false
positives to a great extent but not enough to achieve practicalusefulness. We then developed the identiﬁer type-sensitivevariants using POS tags, case-sensitivity and inclusion of theparent identiﬁer in certain cases, which helped us achieve per-
formance levels that aligned with practical usefulness. In thecase of the semantic matching rule, the use of lemmas yieldedthe desired results (no false positives) on the development set.
V. E
V ALUA TION STUDY DESIGN
The performance of Fraco can be evaluated in terms of the
metrics of precision and recall (see Section III) for a sample of
input identiﬁers. The design of our study comprises four main
components: a)The sampling of identiﬁers; b)The creation
of a benchmark for these identiﬁers; c)The computation of
baseline results; d)The computation of metrics.
A. Sampling
We wanted to evaluate the approach so as to cover a variety
of potential identiﬁer renaming situations. Because of theunderlying structure of programs and commenting practices, anaive random sampling approach is not appropriate in our case.First, in most software projects only a fraction of identiﬁers is
ever mentioned in comments. By sampling randomly, any ag-
gregated result would be heavily biased by the underlying priordistribution of identiﬁers in comments. Second, the proportionof different identiﬁers types (e.g., local variables vs. classes)is not uniform and so drawing from the general population
of identiﬁers is likely to lead to a glut of local variables,
thus degrading our ability to evaluate the performance of theapproach for other identiﬁer types. Finally, a constraint on thesampling is scalability and understandability of the underlyingsoftware, given that the resulting benchmark must be createdthrough manual code inspection (see §V-B ).
First, we selected six moderately-sized and well-commented
target systems (see Table III). While these systems offer a
diversity of application domain and open-source communities,their medium size and general-purpose application domainmakes it reasonable for external investigators to inspect.
Second, we deﬁned the target population of program
elements as only the elements that have at least one fragile
phrase. In principle this means all elements {e|refersTo(e )/negationslash=
∅}. However, as described in §III, refersTo can only be esti-
mated with matches, which means that our target population
is partially deﬁned in terms of the approach itself. In practice,
this imperfect and unavoidable situation is mitigated by the
high overlap between the output of refersTo andmatches.
Third, we used a stratiﬁed random sampling strategy to
achieve a diversity of program element types while keeping the
size of the data set to a manageable level. Stratiﬁed randomsampling protects against selection bias while ensuring thatall classes of interest are covered in a sampled population.
117
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:48:34 UTC from IEEE Xplore.  Restrictions apply. As part of this procedure, we randomly selected 100 elements
from each of the six systems in proportion to the number ofelements of each type in the target population (of elementswith at least one fragile comment).
Table IIIshows the number of identiﬁers in the sample for
each program element type. For each target system (row), the
table indicates the total number of program elements of a giventype, followed by the number (in parentheses) of programelements of this type for which at least one fragile phrasewas detected. In the right column for each element type, weindicate the number of program elements of that type in thesample. For example, for Log4j we detected 244 classes, ofwhich 116 had a non-empty result for matches, which is 33%
of all identiﬁers across all types (116 + 139 + 73 + 20) .
When piloting our evaluation on our development set, we
discovered that the performance of the semantic rule contribu-
tion to the matches relation had very low coverage. In other
words, there were relatively few cases where the semantic rule
yielded results. For this reason, we evaluated the semantic ruleseparately using a sample that consists of all elements in eachsystem (e.g. 244 classes of Log4j).
B. Benchmark
We created a benchmark for fragile comments that con-
stitutes a general contribution of this work. The benchmark
includes, for each element eas reported in Table III, the
full set refersTo(e ). The benchmark was created through
manual inspection by the ﬁrst author of this paper. For eachphrase returned as the results of the matches( e)relation for
an element e, the researcher made a binary decision as to
whether the phrase referred to the element’s identiﬁer ornot. The validation or invalidation of phrases as fragile is a
low subjectivity task given that comments are intended for
human consumption and therefore generally not ambiguous to
a human reader. In addition, we included the false negativesdiscovered through the computation of the approximations ofrecall as described in §V-D .
C. Baseline
Although the performance of our approach can be inter-
preted in absolute terms, we were interested in comparing itwith an existing baseline. Basic lexical matching is technicallyan option, but as described in §IV-H it performs so poorly
that it cannot reasonably qualify as a baseline for this typeof work. A more appropriate baseline is offered by Eclipse’srefactoring tool. Along with refactoring the code, Eclipse’srefactoring tool allows the user to select an option to replacethe textual matches present in comments when renaming an
identiﬁer. Hereinafter, for convenience, we refer to this feature
as Eccore (“Eclipse comment refactoring”). Eccore is onlyavailable for type and ﬁeld code elements (so not available
formethods and local variables). To use Eccore as a baseline
when conducting the evaluation, we programmatically renameall the applicable declarations (types and ﬁelds) and consider
all textual replacements to be fragile phrases.D. Metrics
We evaluate our approach using the standard metrics of
precision and recall. For a given program element e,w e
compute precision exactly a deﬁned in Section III. In general,
precision measures the degree of absence of false positives,
which in our case are phrases falsely reported as fragile.In contrast, recall measures the degree of absence of falsenegatives. In our case, false negatives correspond to fragile
phrases that remain undetected. Recall is not generally possible
to compute, since to compute refersTo(e )one would need to
manually inspect the entire source code of a system. For thisreason we must resort to approximations. The Eccore featureis applicable to class and ﬁeld identiﬁers and therefore, weuse the union of the sets of true positives for both approachesas the approximation of refersTo(e )in the denominator of the
recall equation. We denote this version of recall as Recall
∪.A s
Eccore is not applicable to methods and local variables, werequire an alternative strategy to estimate the recall, which,is done with a liberal equivalent deﬁned as follows. For agiven program element e, we perform a textual search for
all instances of the element’s identiﬁer in comments in the
same ﬁle ase, and identify any fragile phrase in the set.
We then take the union of the set of these fragile phrases
andmatches(e )as the equivalent of refersTo(e ). We refer to
this version of recall as Recall
∗. In general, we can expect
both of our approximations of recall to be an upper bound
approximation of the true recall of the approach.
E. Threats and Limitations
The threats to validity and limitations of our experimental
design are as follows. First, we deﬁne the population from
which we draw our sample of program identiﬁers as a functionof our approach, as described in §V-A . However, this will only
introduce bias as a function of the number of identiﬁers for
which our approach generates a)only false positives, or b)no
positives in the presence of false negatives. Case a) can be
precisely controlled and we veriﬁed that across all our targetprojects the sampling error is between 0 and 3 elements forall projects except for Spring Data Redis for which 8 elementsare erroneously part of the sample. Case b) is impossible todetermine reliably, but can be estimated to be very low giventhe high recall reported in the next section. There exists thethreat of investigator bias when deciding whether a match isa true positive or not as the investigator is familiar with theworking of Fraco. However, this threat is mitigated by the factthat the task is of low subjectivity, and that we released ourbenchmark publicly. Third, for the experiment to be useful weselected Java systems that were not only popular, but well-commented. Finally, as mentioned above, the computation ofrecall we designed is an approximation of a theoretical valuethat is not feasible to compute precisely. In consequence ofthese experimental conditions, the way to interpret the resultsin the next section is as an illustration of the potential ofthe approach in six distinct contexts, as opposed to a generalprediction of the operational performance of the tool.
118
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:48:34 UTC from IEEE Xplore.  Restrictions apply. TABLE III
COMPOSITION OF THE EV ALUA TION SAMPLE
Project Name V ersion Class Type Method Type Field Type Local Variable Type
Total (Pop.) Sample Total (Pop.) Sample Total (Pop.) Sample Total (Pop.) Sample
Log4j 1.2.17 244 (116) 33 853 (139) 40 640 (73) 21 776 (20) 6
JUnit 4.12 218 (96) 54 587 (72) 40 144(11) 6 377 (0) 0
Joda time 2.9.6 227 (118) 32 933 (223) 54 500 (52) 12 706 (18) 2
JFlex 1.6.1 71 (36) 28 297 (66) 40 250 (34) 20 307 (26) 12
Chronicle Map 3.11.0 265 (68) 42 784 (67) 41 342 (23) 14 473 (10) 3
Spring Data Redis 1.7.8 426 (194) 54 1199 (119) 33 624 (50) 13 689 (3) 0
VI. R ESULTS AND DISCUSSION
We report the results of our evaluation in three parts
organized to facilitate the interpretation of the data collected.
First, we present the results of the evaluation of the lexical
matching rules for methods and local variables (§VI-A). These
results must be interpreted in absolute terms because Eccoredoes not support replacement for identiﬁers of these types. Wethen report the results of the lexical matching rules for types
and ﬁelds (§VI-B), which we compare against Eccore’s. The
results of the ﬁrst two sections are based on the same sample.Since the comparison with baseline, i.e. Eccore, is done usingthe same sample, we annotated the precision results for boththe techniques separately and later compared the results ofboth techniques to calculate recall. Finally, we report on theresults of the semantic matching rule (§VI-C) which is based
on all of the identiﬁers in the target systems.
A. Lexical Matching of Methods and Local V ariables
Table IVshows the results of the evaluation of the lexical
matching rules for the methods and local variables. We note
that JUnit and Spring Data Redis do not have mentions of local
variable identiﬁers in the comments in the sample, so perfor-mance results in these cases are not available. For methodsthe precision is above 95% for all evaluation systems exceptSpring Data Redis. However, all of the false positives in SpringData Redis are caused by the artiﬁcial case where a commentrefers to a method that is being overridden, which is not alikely scenario in practice given that renaming an overridingmethod changes the behavior of the code. The recall
∗is
generally very good, with only Chronicle Map registering eightfalse negatives. Seven of these cases are caused by overloadingor other types of ambiguity related to arguments. For example,a method named
of(first,second) is not matched to an
in-comment reference of(...) . The eighth case was one of
confusion between a ﬁeld and method name. Local variablesare seldom referred to in comments. In our sample, we observeperfect recall
∗but equivocal precision for both JFlex and
Chronicle Map. For these systems, the precision is lower dueto the use of common English words like move as a local
variable identiﬁer, which generates natural ambiguity in therefersTo relation.
B. Lexical Matching of Types and Fields
Table Vshows the results of the evaluation of lexical match-
ing rules for types and ﬁelds. The results can be interpreted inthe same way as those in Table IVexcept that in this case we
use recall
∪as deﬁned in Section III. The main observation
for types is that it is relatively a simple problem to solve.
Eccore shows perfect precision across all projects and Fraco
only generates one false positive.
On the other hand, the recall of Fraco is superior for ﬁve out
of the six projects because of the additional context-sensitivetolerance for plurals and case-insensitive matching. For SpringData Redis, the recall
∪is lower due to some unexpected
uses of fully-qualiﬁed names. In the case of ﬁelds, Fraco
clearly dominates with perfect precision and very high recallfor all but one system. In contrast, Eccore ﬂounders in manysituations. For example, if both a ﬁeld and a method’s param-eter have the same identiﬁer, Eccore replaces the references
of the formal parameter as well. In a more egregious case,when we rename a ﬁeld named
itin Chronicle Map, Eccore
generates 244 false positives in various comments includingthe copyright block of ﬁles.
C. Semantic Matching
Table VIshow the precision of the semantic matching rule
for all identiﬁers that produced at least one match. We do not
attempt to compute the recall for semantic matching because itis not possible to reliably determine the extension of the set of
true positives. The main observation we can draw from theseresults is that although coverage is relatively low, precisionis again very high. The few false positives for methods weregenerated by the ﬁrst special case for the return values ofmethod identiﬁers (see §IV-F). However, the handful of false
positives generated by this rule are largely offset by the truepositives it properly captures. Finally, when we project theevaluation of the semantic matching rules back onto the sampleused for lexical rules, we conclude that the number of fragilephrases detected increases by ratios between 4.4% (JFlex) and51.8% (Chronicle Map).
VII. R
ELA TED WORK
The work to mitigate the problem of inconsistencies be-
tween comments and code can be split into three categories:preliminary attempts at comment-aware refactoring, research
ondetection of inconsistencies between code and comments,
and approaches to obviate the need for consistency mainte-nance by generating comments automatically.
A number of early proposals for comment-aware refactor-
ing have focused on the problem of retaining the comments
119
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:48:34 UTC from IEEE Xplore.  Restrictions apply. TABLE IV
RESULTS OF THE EV ALUA TION FOR IDENTIFIERS OF LOCAL V ARIABLES AND METHODS .THE COLUMNS INDICA TE THE NUMBER OF IDENTIFIERS
SEARCHED (IDS),THE NUMBER OF TRUE POSITIVES (TP), THE NUMBER OF FALSE POSITIVES (FN) THE NUMBER OF FILE -RELA TIVE FALSE NEGA TIVES
(FN), THE PRECISION (P), AND FILE -RELA TIVE RECALL (R*, DESCRIBED IN §V-D )
Project Name Method Type Local Variable Type
Ids TP FP FN P R* Ids TP FP FN P R*
Log4j 40 110 2 3 98 97 6 6 0 0 100 100
JUnit 40 102 0 1 100 99 0 0 0 0 NA NA
Joda time 54 214 0 1 100 99 2 2 0 0 100 100
JFlex 40 60 0 0 100 100 12 10 2 0 83 100
Chronicle Map 41 139 7 8 95 94 3 2 1 0 67 100
Spring Data Redis 33 57 16 0 78 100 0 0 0 0 NA NA
TABLE V
RESULTS OF THE EV ALUA TION FOR IDENTIFIERS OF TYPES AND FIELDS .SEETABLE IV FOR THE LEGEND .
Project Types Fields
IDs Eccore Fraco IDs Eccore Fraco
TP FP FN P R TP FP FN P R TP FP FN P R TP FP FN P R
Log4j 33 161 0 29 100 84 174 0 17 100 91 21 10 15 11 40 47 87 0 3 100 96
JUnit 54 372 0 65 100 85 407 1 46 99 90 6 4 0 3 100 57 7 0 0 100 100
Joda time 32 272 0 49 100 84 323 0 7 100 97 12 4 0 23 100 15 28 0 0 100 100
JFlex 28 138 0 103 100 57 223 0 29 100 88 20 28 107 0 20 100 26 0 2 100 93
Chronicle... 42 297 0 51 100 85 350 0 27 100 93 14 9 3 12 75 42 21 0 0 100 100
Spring... 54 225 0 17 100 93 223 0 52 100 81 13 11 49 6 18 65 17 4 0 80 100
TABLE VI
RESULTS OF THE SEMANTIC MA TCHING BASED ON ALL APPLICABLE IDENTIFIERS .
Project Name Class Type Method Type Field Type Local Variable Type
Ids TP FP P Ids TP FP P Ids TP FP P Ids TP FP P
Log4j 12 15 0 100 80 94 4 96 5 6 0 100 2 2 0 100
JUnit 26 39 0 100 73 85 1 98 0 0 0 NA 0 0 0 NA
Joda time 10 11 0 100 90 157 0 100 0 0 0 NA 0 0 0 NA
JFlex 9 9 0 100 41 54 1 98 2 2 0 100 2 2 0 100
Chronicle Map 17 27 1 96 9 11 0 100 1 1 0 100 2 2 0 100
Spring Data Redis 37 40 0 100 61 71 1 98 0 0 0 NA 0 0 0 NA
at their proper location in a declaration element’s abstract
syntax tree (AST), and to preserve their indentation [ 20],
[21]. Existing refactoring tools, like Eclipse’s, implement asimilar idea to keep the comments linked to the appropriate
code elements. However, these approaches neglect the possible
inconsistencies introduced between the modiﬁed source codeand existing comments. Eclipse [22] also comes with an in-comment text replacement feature we called Eccore, which
supports comment refactoring to a certain extent. As discussed
earlier, Eccore only detects and replaces identical lexicalmatches for two types of code-elements (types and ﬁelds),and so does not support name replacement for methods andlocal variables. Fraco detects fragile comments for all typesof code elements. In addition to the lexical matches detectedby Eccore, Fraco also detects phrases that involve multiplenon-contiguous tokens in the comments.
As for inconsistency detection, Tan et al. proposed a tech-
nique to automatically extract program rules to detect incon-sistencies related to locking mechanisms in source code [ 15].
They also devised an approach to extract information fromcomments to detect inconsistencies in source code relatedto speciﬁc programming concepts like memory allocationand synchronization [14]. Apart from detecting inconsisten-cies related to speciﬁcally targeted programming concepts,various approaches have been devised to keep the sourcecode of methods consistent with comments. @TComment is
a technique that detects inconsistencies between a method’sparameters tolerance of null values and its related Javadoccomments [23]. This approach is however constrained toJavadoc method parameter comments. Zhou et al. deviseda similar approach that detects inconsistencies between API
documentation and source code by extracting documentationfrom Javadoc comments and performing a static analysis ofthe code of methods [24]. Corazza et al. devised an approach
to detect the coherence between comments and a method’simplementation using information retrieval concepts. There arealso proposals that focus on a speciﬁc type of comments for
detecting inconsistencies. For example, Sridhara has developed
a tool to detect the fragility of “TODO” comments [16].All these techniques focus on a subset of either commenttypes or programming concepts. In contrast, Fraco supportsthe detection of the possible inconsistencies produced for allpossible types of comments upon renaming an identiﬁer for
any type of program element.
120
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:48:34 UTC from IEEE Xplore.  Restrictions apply. Automatic comment generation tools offer a different
solution to the problem of code-comment consistency mainte-
nance by relieving some of the manual work involved in thecreation (and thus maintenance) of comments. JSummarizer
generates comments for Java classes by utilizing the stereo-
types of classes and methods present in the class [25], [26].Sridhara et al. developed a tool for automatically generating
comments for methods based on the code of the method [27].
Autocomment automatically generates comments for methods
by utilizing the information mined from QA websites forcode fragments similar to those in the method [28]. Guo etal. propose an approach to automatically generate commentsfor design patterns [29]. Li et al. designed an approach to
automatically document test cases by identifying important
aspects of a test case and use templates to generate thedocumentation automatically [30]. Although they share ourgoal of providing high-quality comments to developers, theseapproaches involve a completely different strategy in that theydo not take into consideration the pre-existing relation between
code and comments.
VIII. C
ONCLUSION
This paper formalized the problem of detecting fragile
comments with respect to rename refactorings and proposeda novel rule-based approach for detecting fragile phrases in
source code comments by taking into account the type ofidentiﬁer being renamed, its morphology, the scope of theidentiﬁer and the location of the comments. By limitingthe input of the analysis to general programming languagefeatures and common naming conventions, our approach canremain general-purpose and detect fragile phrases in commentsof any type. Although our approach relies on language-independent principles, we developed a prototype for the Javaprogramming language as an Eclipse plug-in called Fraco.We evaluated Fraco on a sample of 600 identiﬁers takenfrom six medium-sized systems and, when possible, com-pared the results against Eccore, Eclipse’s identiﬁer referencereplacement feature. While detecting fragile comments fortype declarations, both Fraco and Eccore performed at par.However, when renaming ﬁelds, the performance of Eccoreshowed dramatic unreliability, with precision varying between20% and 100% between systems, and recall varying between
15% and 100%. In contrast, the more sophisticated rule set
of Fraco showed a precision of 100% for ﬁve of the sixsystems, and a recall above 90% for all test systems. WhileEccore currently does not even support the detection of fragilecomments when renaming methods and local variables, Fraco
was able to detect fragile phrases in these cases with precision
and recall of 95% or above for a majority of systems.
The two clear avenues for future work in this area are
comment repair and a broadening of the deﬁnition of semantic
matching. Currently, our approach detects fragile phrases with-out repairing them. Although it is unlikely that the problem
of repair is fully automatable for semantic matches, it willbe interesting to explore how to differentiate matches thatcan be reliably repaired from those that require developerassistance. As for semantic matching, our current approach
purposefully remains very close to the lexical layer because ittargets the invalidation of references to speciﬁc identiﬁers. Inthe greater context of software evolution research, the problemof detecting general inconsistencies between source code andunstructured text remains a major challenge, which we couldmodestly approach with an expansion of the semantic rules toinclude additional components such as synonym analysis andentity recognition.
A
PPENDIX
SCOPING RULES FOR THE applies FUNCTION
For an element declaration, the applies function can be
computed by inspecting the access modiﬁer of the declaredelement and its parent type (when applicable), looking upthe corresponding scope, and then returning all commentslinked to a declaration within the same scope. For example, aprivate type with no parent type maps to the class scope, so
applies would return all the comments in the same class. The
scope for all local variables (including formal parameters) isthe method scope, which includes only comments linked to
the variable’s declaring method.
Element Parent Type Scope
Types
public public global
public default or protected package
public private parent class
private any type parent class
protected private parent class
protected public or default or protected packagepublic None global
private None class
protected None package
default None package
Methods
public public global
public private parent class
public default or protected package
protected public or default or protected packageprotected private parent class
default public or default or protected packagedefault private class
private any type class
Fields
public private parent class
public default or protected package
public public global
private any type class
protected private parent class
protected default or protected or public package
ACKNOWLEDGMENTS
The authors are grateful to B. Goswami, C. Berger, the
members of the McGill Swevo lab, and the reviewers forinsightful comments. This work is funded by NSERC.
121
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:48:34 UTC from IEEE Xplore.  Restrictions apply. REFERENCES
[1] M. Fowler and K. Beck, Refactoring: improving the design of existing
code. Addison-Wesley Professional, 1999.
[2] D. Lawrie, C. Morrell, H. Feild, and D. Binkley, “Effective identiﬁer
names for comprehension and memory,” Innovations in Systems and
Software Engineering, vol. 3, no. 4, pp. 303–318, 2007.
[3] E. Murphy-Hill, C. Parnin, and A. P . Black, “How we refactor, and how
we know it,” IEEE Transactions on Software Engineering, vol. 38, no. 1,
pp. 5–18, 2012.
[4] “Jetbrains,” https://www.jetbrains.com/dotnet , veriﬁed on August 29,
2016.
[5] “Eclipse’s refactoring API’s documentation,” http://help.eclipse.
org/kepler/index.jsp?topic=/org.eclipse.jdt.doc.user/reference/
ref-menu-refactor.htm, veriﬁed on August 29, 2017.
[6] S. Negara, N. Chen, M. V akilian, R. E. Johnson, and D. Dig, “A com-
parative study of manual and automated refactorings,” in Proceedings of
the 27th European Conference on Object-Oriented Programming, 2013,
pp. 552–576.
[7] G. C. Murphy, M. Kersten, and L. Findlater, “How are Java software
developers using the Eclipse IDE?” IEEE Software, vol. 23, no. 4, pp.
76–83, 2006.
[8] M. V akilian, N. Chen, S. Negara, B. A. Rajkumar, B. P . Bailey, and R. E.
Johnson, “Use, disuse, and misuse of automated refactorings,” in Pro-
ceedings of the 34th International Conference on Software Engineering,
2012, pp. 233–243.
[9] B. Fluri, M. Wursch, and H. C. Gall, “Do code and comments co-
evolve? on the relation between source code and comment changes,” inProceedings of the 14th Working Conference on Reverse Engineering,
2007, pp. 70–79.
[10] D. Steidl, B. Hummel, and E. Juergens, “Quality analysis of source
code comments,” in Proceedings of the 21st International Conference
on Program Comprehension, 2013, pp. 83–92.
[11] Y . Padioleau, L. Tan, and Y . Zhou, “Listening to programmers Tax-
onomies and characteristics of comments in operating system code,” inProceedings of the 31st International Conference on Software Engineer-
ing, 2009, pp. 331–341.
[12] A. T. Ying, J. L. Wright, and S. Abrams, “Source code that talks: an
exploration of Eclipse task comments and their implication to repository
mining,” in Proceedings of the 2005 International Workshop on Mining
Software Repositories, 2005, pp. 1–5.
[13] “Eclipse documentation - current release Eclipse Neon,”
http://help.eclipse.org/neon/index.jsp?-topic=%2Forg.eclipse.jdt.doc.user%2Freference%2Fref-menu-refactor.htm, veriﬁed on August 29,
2017.
[14] L. Tan, D. Y uan, and Y . Zhou, “Hotcomments: how to make program
comments more useful?” in Proceedings of the 11th Workshop on Hot
Topics in Operating Systems, 2005, pp. 7–9.
[15] L. Tan, D. Y uan, G. Krishna, and Y . Zhou, “/* icomment: Bugs or
bad comments?*,” in Proceedings of the 21st Symposium on Operating
Systems Principles, 2007, pp. 145–158.
[16] G. Sridhara, “Automatically detecting the Up-To-Date status of ToDo
comments in Java programs,” in Proceedings of the 9th India Software
Engineering Conference, 2016, pp. 16–25.[17] “Checkstyle home page,” http://checkstyle.sourceforge.net/ , veriﬁed on
August 29, 2017.
[18] J. Gosling, B. Joy, G. Steele, B. Bracha, and A. Buckley, The
Java
R/circlecopyrtLanguage Speciﬁcation, Java SE 8 Edition, Feb 2015, https://
docs.oracle.com/javase/specs/jls/se8/html/index.html. V eriﬁed on August
29, 2017.
[19] C. D. Manning, M. Surdeanu, J. Bauer, J. R. Finkel, S. Bethard, and
D. McClosky, “The Stanford CoreNLP natural language processingtoolkit.” in Proceedings of the 52nd Annual Meeting of the Association
for Computational Linguistics: System Demonstrations, 2014, pp. 55–
60.
[20] P . Fritzson, A. Pop, K. Norling, and M. Blom, “Comment and indenta-
tion preserving refactoring and unparsing for Modelica,” in Proceedings
of the 6th International Modelica Conference, 2008, pp. 3–4.
[21] P . Sommerlad, G. Zgraggen, T. Corbat, and L. Felber, “Retaining
comments when refactoring code,” in Companion to the 23rd Annual
Conference on Object-Oriented Programming, Systems, Languages, and
Applications, 2008, pp. 653–662.
[22] “Eclipse home page,” https://eclipse.org/, veriﬁed on August 29, 2017.
[23] S. H. Tan, D. Marinov, L. Tan, and G. T. Leavens, “@tcomment:
Testing javadoc comments to detect comment-code inconsistencies,” inProceedings of the 5th International Conference on Software Testing,
V eriﬁcation and V alidation, 2012, pp. 260–269.
[24] Y . Zhou, R. Gu, T. Chen, Z. Huang, S. Panichella, and H. Gall,
“Analyzing APIs documentation and code to detect directive defects,”
inProceedings of the 39th International Conference on Software Engi-
neering, 2017, pp. 27–37.
[25] L. Moreno, J. Aponte, G. Sridhara, A. Marcus, L. Pollock, and K. Vijay-
Shanker, “Automatic generation of natural language summaries forJava classes,” in Proceedings of the 21st International Conference on
Program Comprehension, 2013, pp. 23–32.
[26] L. Moreno, A. Marcus, L. Pollock, and K. Vijay-Shanker, “JSummarizer:
An automatic generator of natural language summaries for Java classes,”
inProceedings of the 21st International Conference on Program Com-
prehension, 2013, pp. 230–232.
[27] G. Sridhara, E. Hill, D. Muppaneni, L. Pollock, and K. Vijay-Shanker,
“Towards automatically generating summary comments for Java meth-
ods,” in Proceedings of the International Conference on Automated
Software Engineering, 2010, pp. 43–52.
[28] E. Wong, J. Yang, and L. Tan, “Autocomment: Mining question and
answer sites for automatic comment generation,” in Proceedings of
the 28th International Conference on Automated Software Engineering,2013, pp. 562–567.
[29] J.-J. Guo, N.-L. Hsueh, W.-T. Lee, and S.-C. Hwang, “Improving soft-
ware maintenance for pattern-based software development: A commentrefactoring approach,” in Proceedings of the International Conference
on Trustworthy Systems and their Applications, 2014, pp. 75–79.
[30] B. Li, C. V endome, M. Linares-V ´asquez, D. Poshyvanyk, and N. A.
Kraft, “Automatically documenting unit test cases,” in Proceedings
of the International Conference on Software Testing, V eriﬁcation andV alidation, 2016, pp. 341–352.
122
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:48:34 UTC from IEEE Xplore.  Restrictions apply. 