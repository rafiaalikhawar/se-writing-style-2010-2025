Deep API Learning
Xiaodong Gu1, Hongyu Zhang2, Dongmei Zhang3, and Sunghun Kim1
1The Hong Kong University of Science and Technology, Hong Kong, China
guxiaodong1987@126.com hunkim@cse.ust.hk
2The University of Newcastle, Callaghan, Australia
hongyu.zhang@newcastle.edu.au
3Microsoft Research, Beijing, China
dongmeiz@microsoft.com
ABSTRACT
Developers often wonder how to implement a certain func-
tionality (e.g., how to parse XML les) using APIs. Obtain-
ing an API usage sequence based on an API-related natural
language query is very helpful in this regard. Given a query,
existing approaches utilize information retrieval models to
search for matching API sequences. These approaches treat
queries and APIs as bags-of-words and lack a deep under-
standing of the semantics of the query.
We propose DeepAPI , a deep learning based approach to
generate API usage sequences for a given natural language
query. Instead of a bag-of-words assumption, it learns the
sequence of words in a query and the sequence of associated
APIs. DeepAPI adapts a neural language model named
RNN Encoder-Decoder. It encodes a word sequence (user
query) into a xed-length context vector, and generates an
API sequence based on the context vector. We also augment
the RNN Encoder-Decoder by considering the importance
of individual APIs. We empirically evaluate our approach
with more than 7 million annotated code snippets collected
from GitHub. The results show that our approach generates
largely accurate API sequences and outperforms the related
approaches.
CCS Concepts
Software and its engineering !Reusability;
Keywords
API, deep learning, RNN, API usage, code search
1. INTRODUCTION
To implement a certain functionality, for example, how
to parse XML les, developers often reuse existing class li-
braries or frameworks by invoking the corresponding APIs.
Obtaining which APIs to use, and their usage sequence (the
method invocation sequence among the APIs) is very help-
ful in this regard [15, 46, 49]. For example, to \ parse XML
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full cita-
tion on the Ô¨Årst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission
and/or a fee. Request permissions from permissions@acm.org.
FSE‚Äô16 Nov 13‚Äì18, 2016, Seattle, WA, USA
c2017 ACM. ISBN 978-1-4503-2138-9.
DOI:10.1145/1235les" using JDK library, the desired API usage sequence is
as follows:
DocumentBuilderFactory:newInstance
DocumentBuilderFactory:newDocumentBuilder
DocumentBuilder:parse
Yet learning the APIs of an unfamiliar library or software
framework can be a signicant obstacle for developers [15,
46]. A large-scale software library such as .NET framework
and JDK could contain hundreds or even thousands of APIs.
In practice, usage patterns of API methods are often not
well documented [46]. In a survey conducted by Microsoft
in 2009, 67.6% respondents mentioned that there are obsta-
cles caused by inadequate or absent resources for learning
APIs [38]. Another eld study found that a major challenge
for API users is to discover the subset of the APIs that can
help complete a task [39].
A common place to discover APIs and their usage se-
quence is from a search engine. Many developers search
APIs from general web search engines such as Google and
Bing. Developers can also perform a code search over an
open source repository such as GitHub [3] and then utilize
an API usage pattern miner [15, 46, 49] to obtain the ap-
propriate API sequences.
However, search engines are often inecient and inaccu-
rate for programming tasks [42]. General web search en-
gines are not designed to specically support programming
tasks. Developers need to manually examine many web
pages to learn about the APIs and their usage sequence. Be-
sides, most of search engines are based on keyword match-
ing without considering the semantics of natural language
queries [17]. It is often dicult to discover relevant code
snippets and associated APIs.
Recently, Raghothaman et al. [36] proposed SWIM, which
translates a natural language query to a list of possible APIs
using a statistical word alignment model [12]. SWIM then
uses the API list to retrieve relevant API sequences. How-
ever, the statistical word alignment model it utilizes is based
on a bag-of-words assumption without considering the se-
quence of words and APIs. Therefore, it cannot recognize
the deep semantics of a natural language query. For exam-
ple, as described in their paper [36], it is dicult to distin-
guish the query convert int to string from convert string to
int.
To address these issues, we propose DeepAPI, a novel,
deep-learning based method that generates relevant API us-
age sequences given a natural language query. We formulate
the API learning problem as a machine translation prob-
lem: given a natural language query x=x1;:::;xNwherexiarXiv:1605.08535v3  [cs.SE]  14 Jul 2017is a keyword, we aim to translate it into an API sequence
y=y1;:::;yTwhereyjis an API. DeepAPI shows a deep
understanding of natural language queries in two aspects:
First, instead of matching keywords, DeepAPI learns
the semantics of words by embedding them into a vec-
tor representation of context, so that semantically re-
lated words can be recognized.
Second, instead of word-to-word alignment, DeepAPI
learns the sequence of words in a natural language
query and the sequence of associated APIs. It can dis-
tinguish the semantic dierences between queries with
dierent word sequences.
DeepAPI adapts a neural language model named RNN
Encoder-Decoder [14]. Given a corpus of annotated API
sequences, i.e.,hAPI sequence, annotation ipairs, DeepAPI
trains the language model that encodes each sequence of
words (annotation) into a xed-length context vector and
decodes an API sequence based on the context vector. Then,
in response to an API-related user query, it generates API
sequences by consulting the neural language model.
To evaluate the eectiveness of DeepAPI , we collect a
corpus of 7 million annotated code snippets from GitHub.
We select 10 thousand instances for testing and the rest
for training the model. After 240 hours of training (1 mil-
lion iterations), we measure the accuracy of DeepAPI using
BLEU score [35], a widely used accuracy measure for ma-
chine translation. Our results show that DeepAPI achieves
an average BLEU score of 54.42, outperforming two related
approaches, that is, code search with pattern mining (11.97)
and SWIM [36] (19.90). We also ask DeepAPI 30 API-
related queries collected from real query logs and related
work. On average, the rank of the rst relevant result is 1.6.
80% of the top 5 returned results and 78% of the top 10 re-
turned results are deemed relevant. Our evaluation results
conrm the eectiveness of DeepAPI .
The main contributions of our work are as follows:
To our knowledge, we are the rst to adapt a deep
learning technique to API learning. Our approach
leads to more accurate API usage sequences as com-
pared to the state-of-the-art techniques.
We develop DeepAPI1, a tool that generates API us-
age sequences based on natural language queries. We
empirically evaluate DeepAPI 's accuracy using a cor-
pus of 7 million annotated Java code snippets.
The rest of this paper is organized as follows. Section 2
describes the background of the deep learning based neu-
ral language model. Section 3 describes the application of
the RNN Encoder-Decoder, a deep learning based neural
language model, to API learning. Section 4 describes the
detailed design of our approach. Section 5 presents the eval-
uation results. Section 6 discusses our work, followed by
Section 7 that presents the related work. We conclude the
paper in Section 8.
2. DEEP LEARNING FOR SEQUENCE GEN-
ERATION
Our work adopts and augments recent advanced tech-
niques from deep learning and neural machine translation [8,
1available at: https://guxd.github.io/deepapi/
INPUT (t) OUTPUT (t)
CONTEXT (t)
CONTEXT (t -1)(a)RNN Structure
<EOS> Text File Read
<START>Hidden Layer
(Contexts)Output Layer
h1 h2 h3 h4y1 y2 y3 y4
y1 y2 y3
Read Text FileInput Layer (b)RNNLM for sentence estimation
Figure 1: Illustration of the RNN Language Model
14, 43]. These techniques are on the basis of Sequence-to-
Sequence Learning [43], namely, generating a sequence (usu-
ally a natural language sentence) conditioned on another se-
quence. In this section, we discuss the background of these
techniques.
2.1 Language Model
It has been observed that software has naturalness [16].
Statistical language models have been adapted to many soft-
ware engineering tasks [26] such as learning natural code
conventions [5], code suggestion [44], and code completion [37].
These techniques regard source code as a special language
and analyze it using statistical NLP techniques.
The language model is a probabilistic model of how to gen-
erate sentences in a language. It tells how likely a sentence
would occur in a language. For a sentence y, wherey=
(y1;:::;yT) is a sequence of words, the language model aims
to estimate the joint probability of its words Pr(y1;:::;yT).
Since
Pr(y1;:::;yT) =TY
t=1Pr(ytjy1;:::;yt 1) (1)
it is equivalent to estimate the probability of each word in
ygiven its previous words, namely, what a word might be
given its predecessing words.
AsPr(ytjy1;:::;yt 1) is dicult to estimate, most appli-
cations use \n-gram models" [11] to approximate it, that is,
Pr(ytjy1;:::;yt 1)wPr(ytjyt n+1;:::;yt 1) (2)
where an n-gram is dened as nconsecutive words. This
approximation means that the next word ytis conditioned
only on the previous n 1 words.
2.2 Neural Language Model
The neural language model is a language model based on
neural networks. Unlike the n-gram model which predicts
a word based on a xed number of predecessing words, a
neural language model can predict a word by predecessing
words with longer distances. It is also powerful to learn dis-
tributed representations of words, i.e, word vectors [30]. We
adopt RNNLM [29], a language model based on a deep neu-
ral network, that is, Recurrent Neural Network (RNN) [29].
Figure 1a shows the basic structure of an RNN. The neural
network includes three layers, that is, an input layer which
maps each word to a vector, a recurrent hidden layer which
recurrently computes and updates a hidden state after read-
ing each word, and an output layer which estimates the prob-
abilities of the following word given the current hidden state.
Figure 1b shows an example of how RNNLM estimates
the probability of a sentence, that is, the probability of each
word given predecessing words (Equation 1). To facilitate
understanding, we expand the recurrent hidden layer foreach individual time step. The RNNLM reads the words
in the sentence one by one, and predicts the possible fol-
lowing word at each time step. At step t, it estimates the
probability of the following word p(yt+1jy1;:::;yt) by three
steps: First, the current word ytis mapped to a vector yt
by the input layer:
yt=input (yt) (3)
Then, it generates the hidden state (values in the hidden
layer) htat timetaccording to the previous hidden state
ht 1and the current input yt:
ht=f(ht 1;yt) (4)
Finally, the Pr(yt+1jy1;:::;yt) is predicted according to the
current hidden state ht:
Pr(yt+1jy1;:::;yt) =g(ht) (5)
During training, the network parameters are learned from
data to minimize the error rate of the estimated y(details
are in [29]).
2.3 RNN Encoder-Decoder Model
The RNN Encoder-Decoder [14] is an extension of the ba-
sic neural language model (RNNLM). It assumes that there
are two languages, a source language and a target language.
It generates a sentence yof the target language given a sen-
tencexof the source language. To do so, it rst summarizes
the sequence of source words x1;:::;xTxinto a xed-length
context vector:
ht=f(ht 1;xt) (6)
and
c=hTx (7)
wherefis a non-linear function that maps a word of source
language xtinto a hidden state htat timetby considering
the previous hidden state ht 1. The last hidden state hTx
is selected as a context vector c.
Then, it generates the target sentence yby sequentially
predicting a word ytconditioned on the source context cas
well as previous words y1;:::;yt 1:
Pr(y) =TY
t=1p(ytjy1;:::;yt 1;c) (8)
The above procedures, i.e., fandpcan be represented us-
ing two recurrent neural networks respectively, an encoder
RNN which learns to transform a variable length source se-
quence into a xed-length context vector, and a decoder
RNN which learns a target language model and generates a
sequence conditioned on the context vector. The encoder
RNN reads the source words one by one. At each time
stampt, it reads one word, then updates and records a hid-
den state. When reading a word, it computes the current
hidden state htusing the current word xtand the previ-
ous hidden state ht 1. When it nishes reading the end-of-
sequence word <EOS>, it selects the last hidden state hTx
as a context vector c. The decoder RNN then sequentially
generates the target words by consulting the context vector
(Equation 8). It rst sets the context vector as an initial
hidden state of the decoder RNN. At each time stamp t, it
generates one word based on the current hidden state and
the context vector. Then, it updates the hidden state using
the generated word (Equation 6). It stops when generating
the end-of-sentence word <EOS>.The RNN Encoder-Decoder model can then be trained to
maximize the conditional log-likelihood [14], namely, mini-
mize the following objective function:
L() =1
NNX
i=1TX
t=1costit (9)
whereNis the total number of training instances, while Tis
the length of each target sequence. costitis the cost function
for thet-th target word in instance i. It is dened as the
negative log likelihood:
costit= logp(yitjxi) (10)
wheredenotes model parameters such as weights in the
neural network, while p(yitjxi) (derived from Equation 6
to 8) denotes the likelihood of generating the t-th target
word given the source sequence xiin instance iaccording
to the model parameters . Through optimizing the objec-
tive function using optimization algorithms such as gradient
descendant, the optimum value can be estimated.
3. RNN ENCODER-DECODER MODEL FOR
API LEARNING
3.1 Application of RNN Encoder-Decoder to
API Learning
Now we present the idea of applying the RNN Encoder-
Decoder model to API learning. We regard user queries as
the source language and API sequences as the target lan-
guage. Figure 2 shows an example of the RNN Encoder-
Decoder model for translating a sequence of English words
read text le to a sequence of APIs. The encoder RNN
reads the source words one by one. When it reads the rst
word read, it embeds the word into vector x1and computes
the current hidden state h1using x1. Then, it reads the sec-
ond word text, embeds it into x2, and updates the hidden
state h1toh2using x2. The procedure continues until the
encoder reads the last word leand gets the nal state h3.
The nal state h3is selected as a context vector c.
The decoder RNN tries to generate APIs sequentially us-
ing the context vector c. It rst generates <START>as the
rst word y0. Then, it computes a hidden state h1based on
the context vector candy0, and predicts the rst API Fil-
eReader.new according to h1. It then computes the next
hidden state h2according to the previous word vector y1,
the context vector c, and predicts the second API Buere-
dReader.new according to h2. This procedure continues un-
til it predicts the end-of-sequence word <EOS>.
Dierent parts of a query could have dierent importance
to an API in the target sequence. For example, consider-
ing the query save le in default encoding and the target
API sequence File.new FileOutputStream.new FileOutput-
Stream.write FileOutputStream.close , the word leis more
important than default to the target API File.new . In our
work, we adopt the attention-based RNN Encoder-Decoder
model [8], which is a recent model that selects the important
parts from the input sequence for each target word. Instead
of generating target words using the same context vector c
(c=hTx), an attention model denes individual cj's for
each target word yjas a weighted sum of all historical hid-
den states h1;:::;hTx. That is,
cj=TxX
t=1jtht (11)<START >h1 h2 h3 h4y1 y2 y3 y4
y1 y2 y3h1 h2 h3
x1 x2 x3
Read Text FilecEncoder RNN Decoder RNN
BuffereReader
.newFileReader
.newBuffereReader
.readBuffereReader
.close<EOS>
BuffereReader
.newFileReader
.newBuffereReader
.readBuffereReader
.closeh5y5
y4 InputOutput
HiddenFigure 2: An Illustration of the RNN Encoder-Decoder Model for API learning
where each jtis a weight between the hidden state htand
the target word yj, whilecan be modeled using another
neural network and learned during training (see details in
[8]).
3.2 Enhancing RNN Encoder-Decoder Model
with API importance
The basic RNN Encoder-Decoder model does not consider
the importance of individual words in the target sequence
either. In the context of API learning, dierent APIs have
dierent importance for a programming task [27]. For exam-
ple, the API Logger.log is widely used in many code snippets.
However, it cannot help understand the key procedures of a
programming task. Such ubiquitous APIs would be \weak-
ened" during sequence generation.
We augment the RNN Encoder-Decoder model to predict
API sequences by considering the individual importance of
APIs. We dene IDF-based weighting to measure API im-
portance as follows:
widf(yt) =log(N
nyt) (12)
whereNis the total number of API sequences in the train-
ing set and nytdenotes the number of sequences where the
APIytappears in the training set. Using IDF, the APIs
that occur ubiquitously have the lower weights while the
less common APIs have the higher weights.
We use API weight as a penalty term to the cost function
(Equation 10). The new cost function of the RNN Encoder-
Decoder model is:
costit= logp(yitjxi) widf(yt) (13)
wheredenotes the penalty of IDF weight and is set em-
pirically.
4. DEEPAPI: DEEP LEARNING FOR API
SEQUENCE GENERATION
In this section, we describe DeepAPI , a deep-learning
based method that generates relevant API usage sequences
given an API-related natural language query. DeepAPI
adapts the RNN Encoder-Decoder model for the task of API
learning. Figure 3 shows the overall architecture of Deep-
API. It includes an oine training stage and an online trans-
lation stage. In the training stage, we prepare a large-scale
corpus of annotated API sequences (API sequences with cor-
responding natural language annotations). The annotated
API sequences are used to train a deep learning model, i.e.,
the RNN Encoder-Decoder language model as described in
Code Corpus
Deep 
Learning
RNN 
Encoder -
DecoderAPI-related 
User Query
Suggested API 
sequencesNatural 
Language 
Annotations
 Training
Instances
API 
sequencesTraining
Offline trainingFigure 3: The Overall Workow of DeepAPI
Section 3. Given an API-related user query, a ranked list of
API sequences can be generated by the language model.
In theory our approach could generate APIs written in any
programming languages. In this paper we limit our scope to
the JDK library. The details of our method are explained
in the following sections.
4.1 Gathering a Large-scale API Sequence to
Annotation Corpus
We rst construct a large-scale database that contains
pairs of API sequences and natural language annotations
for training the RNN Encoder-Decoder model. We down-
load Java projects from GitHub [2] created from 2008 to
2014. To remove toy or experimental programs, we only se-
lect the projects with at least one star. In total, we collected
442,928 Java projects from GitHub. We use the last snap-
shot of each project. Having collected the code corpus, we
extracthAPI sequence, annotation ipairs as follows:
4.1.1 Extracting API Usage Sequences
To extract API usage sequences from the code corpus, we
parse source code les into ASTs (Abstract Syntax Trees)
using Eclipse's JDT compiler [1]. The extraction algorithm
starts from the dependency analysis of a whole project repos-
itory. We analyze all classes, recording eld declarations
together with their type bindings. We replace all object
types with their real class types. Then, we extract API se-
quence from individual methods by traversing the AST of
the method body:
For each constructor invocation new C (), we append
the API C.new to the API sequence.
For each method call o:m() whereois an instance of
a JDK class C, we append the API C.m to the API
sequence.
For a method call passed as a parameter, we append
the method before the calling method. For example,/*** 
* Copies bytes from a large (over 2GB) InputStream to an OutputStream .
* This method uses the provided buffer, so there is no need to use a
* BufferedInputStream .
* @paraminput the InputStream to read from
*  . . .
* @since 2.2
*/
publicstaticlongcopyLarge (finalInputStream input,
finalOutputStream output, finalbyte[] buffer) throwsIOException {
longcount =0;
intn;
while(EOF!=(n =input.read(buffer))) {
output.write(buffer, 0, n);
count +=n;
}
returncount;
}
API sequence: InputStream.read OutputStream.write
Annotation:  copiesbytes from a large inputstream to an outputstream .Figure 4: An example of extracting API sequence and
its annotation from a Java method IOUtils:copyLarge7
o1.m1(o2.m2(),o3.m3()), we produce a sequence C2.m2-
C3.m3-C1.m1, whereCiis the JDK class of instance
oi.
For a sequence of statements stmt 1;stmt 2;...;stmtt,
we extract the API sequence sifrom each statement
stmti, concatenate them, and produce the API se-
quences1-s2-...-st.
For conditional statements such as if ( stmt 1)fstmt 2;
gelsefstmt 3;g, we create a sequence from all pos-
sible branches, that is, s1-s2-s3, wheresiis the API
sequence extracted from the statement stmti.
For loop statements such as while( stmt 1)fstmt 2;g, we
produce a sequence s1-s2, wheres1ands2are API se-
quences extracted from the statement stmt 1andstmt 2,
respectively.
4.1.2 Extracting Annotations
To annotate the obtained API sequences with natural
language descriptions, we extract method-level code sum-
maries, specically, the rst sentence of a documentation
comment2for a method. According to the Javadoc guid-
ance3, the rst sentence is used as a short summary of a
method. Figure 4 shows an example of documentation com-
ment for a Java method IOUtils:copyLarge4in the Apache
commons-io library.
We use the Eclipse JDT compiler for the extraction. For
each method, we traverse its AST and extract the JavaDoc
Comment part. We ignore methods without JavaDoc com-
ments. Then, we select the rst sentence of the comment as
the annotation. We exclude irregular annotations such as
those starting with \TODO: Auto-generated method stub",
\NOTE:", and\test". We also lter out non-words and words
within brackets in the annotations.
Finally, we obtain a database consisting of 7,519,907 hAPI
sequence, annotation ipairs.
4.2 Training Encoder-Decoder Language
Model
2A documentation comment in JAVA starts with slash-
asterisk-asterisk (/**) and ends with asterisk-slash (*/)
3http://www.oracle.com/technetwork/articles/java/
index-137868.html
4https://github.com/apache/commons-io/blob/trunk/src/
main/java/org/apache/commons/io/IOUtils.java
<START>File.new
FileInputStream.new
StringBuilder.newFileReader.new
File.exists
File.mkdir 6
8
12DataInputStream.new
FileInputStream.read
FileInputStream.close6
16
22
38
5
14BufferedReader.read
79BufferedReader.new
StringBuilder.new
FileReader.close3
12
16
38
String.equals
‚Ä¶‚Ä¶
‚Ä¶Figure 5: An illustration of beam search (beam
width=2)
As described in Section 3, we adapt the attention-based
RNN Encoder-Decoder model for API learning. The RNN
has various implementations, we use GRU [14] which is a
state-of-the-art RNN and performs well in many tasks [8,
14]. We construct the model as follows: we use two RNNs
for the encoder - a forward RNN that directly encodes the
source sentence and a backward RNN that encodes the re-
versed source sentence. Their output context vectors are
concatenated to the decoder, which is also an RNN. All
RNNs have 1000 hidden units. We set the dimension of
word embedding to 120. We discuss the details of parame-
ter tuning in Section 5.4.
All models are trained using the minibatch Adadelta [51],
which automatically adjusts the learning rate. We set the
batch size (i.e., number of instances per batch) as 200. For
training the neural networks, we limit the source and target
vocabulary to the top 10,000 words that are most frequently
used in API sequences and annotations.
For implementation, we use GroundHog [8, 14], an open-
source deep learning framework. We train our models in a
server with one Nvidia K20 GPU. The training lasts 240
hours with 1 million iterations.
4.3 Translation
So far we have discussed the training of a neural language
model, which outputs the most likely API sequence given a
natural language query. However, an API could have multi-
ple usages. To obtain a ranked list of possible API sequences
for user selection, we need to generate more API sequences
according to their probability at each step.
DeepAPI uses Beam Search [21], a heuristic search strat-
egy, to nd API sequences that have the least cost value(computed
using Equation 13) given by the language model. Beam
search searches APIs produced at each step one by one. At
each time step, it selects nAPIs from all branches with
the least cost values, where nis the beam-width. It then
prunes o the remaining branches and continues selecting
the possible APIs that follow on until it meets the end-of-
sequence symbol. Figure 5 shows an example of a beam
search (beam-width=2) for generating an API sequence for
the query \read text le". First, `START' is selected as
the rst API in the generated sequence. Then, it estimates
the probabilities of all possible APIs that follow on accord-
ing to the language model. It computes their cost values
according to Equation 13, and selects File.new and FileIn-
putStream.new which have the least cost values of 6 and
8, respectively. Then, it ignores branches of other APIs and
continue estimating possible APIs after File.new andFileIn-putStream.new . Once it selects an end-of-sequence symbol
as the next API, it stops that branch and the branch is se-
lected as a generated sequence.
Finally, DeepAPI producesnAPI sequences for each
query where nis the beam-width. We rank the generated
API sequences according to their average cost values during
the beam search procedure.
5. EVALUATION
We evaluate the eectiveness of DeepAPI by measuring
its accuracy on API sequence generation. Specically, our
evaluation addresses the following research questions:
RQ1: How accurate is DeepAPI for generating
API usage sequences?
RQ2: How accurate is DeepAPI under dierent
parameter settings?
RQ3: Do the enhanced RNN Encoder-Decoder
models improve the accuracy of DeepAPI?
5.1 Accuracy Measure
5.1.1 Intrinsic Measure - BLEU
We use the BLEU score [35] to measure the accuracy of
generated API sequences. The BLEU score measures how
close a candidate sequence is to a reference sequence (usually
a human written sequence). It is a widely used accuracy
measure for machine translation in the machine learning and
natural language processing literature [8, 14, 43]. In our API
learning context, we regard a generated API sequence given
a query as a candidate, and a human-written API sequence
(extracted from code) for the same query as a reference. We
use BLEU to measure how close the generated API sequence
is to a human-written API sequence.
Generally, BLEU measures the hits of n-grams of a can-
didate sequence to the reference. It is computed as:
BLEU =BPexp(NX
n=1wnlogpn) (14)
where each pnis the precision of n-grams, that is, the ratio
of lengthnsubsequences in the candidate that are also in
the reference:
pn=# n-grams appear in the reference+1
# n-grams of candidate+1forn= 1;:::;N
(15)
whereNis the maximum number of grams we consider.
We setNto 4, which is a common practice in the Machine
Learning literature [43]. Each wnis the weight of each pn. A
common practice is to set wn=1
N.BPis a brevity penalty
which penalties overly short candidates (that may have a
higher n-gram precision).
BP=(
1 if c>r
e(1 r=c)ifcr(16)
whereris the length of the reference sequence, and cis the
length of the candidate sequence.
We now give an example of BLEU calculation. For a can-
didate API sequence fa-c-d-bgand a reference API sequence
fa-b-c-d-eg, their 1-grams are fa,b,c,dgandfa,b,c,d,eg. All
four 1-grams of the candidate are hit in the reference. Then,
p1=4+1
4+1= 1. Their 2-grams are fac,cd,dbgandfab,bc,cd,deg,
respectively. Then, p2=1+1
3+1=1
2as onlycdis matched.p3=0+1
2+1=1
3andp4=0+1
1+1=1
2as no 3-gram nor 4-
gram is matched. As their lengths are 4 and 5 respectively,
BP=e(1 5=4)= 0:78. The nal BLEU is 0 :78exp(1
4
log1 +1
4log1
2+1
4log1
3+1
4log1
2) = 41:91%
BLEU is usually expressed as a percentage value between
0 and 100. The higher the BLEU, the closer the candidate
sequence is to the reference. If the candidate sequence is
completely equal to the reference, the BLEU becomes 100%.
5.1.2 Extrinsic Measures - FRank and Relevancy Ra-
tio
We also use two measures for human evaluation. They are
FRank and relevancy ratio [36]. FRank is the rank of the
rst relevant result in the result list [36]. It is important as
most users scan the results from top to bottom.
The relevancy ratio is dened as the precision of relevant
results in a number of results [36].
relevancy ratio =#relevant results
#all selected results(17)
The value of both measures ranges from 0 to 100. The
higher the better.
5.2 Comparison Methods
We compare the accuracy of our approach with that of
two state-of-the-art API learning approaches, namely Code
Search with Pattern Mining [24, 46] and SWIM [36].
5.2.1 Code Search with Pattern Mining
To obtain relevant API sequences for a given a query, one
can perform code search over the code corpus using infor-
mation retrieval techniques [20, 24, 25, 28], and then utilize
an API usage pattern miner [15, 46, 49] to identify an ap-
propriate API sequences in the returned code snippets.
We compare DeepAPI with this approach. We use Lucene
[4] to perform a code search for a given natural language
query and UP-Miner [46] to perform API usage pattern min-
ing. Lucene is an open-source information retrieval engine,
which has been integrated into many code search engines [24,
36]. Much the same as these code search engines do, we treat
source code as plain text documents and use Lucene to build
source code index and perform text retrieval. UP-Miner [46]
is a pattern mining tool, which produces API sequence pat-
terns from code snippets. It rst clusters API sequences
extracted from code snippets, and then identies frequent
patterns from the clustered sequences. Finally, it clusters
the frequent patterns to reduce redundancy. We use UP-
Miner to mine API usage sequences from the code snippets
returned by the Lucene-based code search.
In this experiment, we use the same code corpus as used
for evaluating DeepAPI , and compare the BLEU scores
with those of DeepAPI .
5.2.2 SWIM
SWIM [36] is a recently proposed code synthesis tool,
which also supports API sequence search based on a nat-
ural language query. Given a query, it expands the query
keywords to a list of relevant APIs using a statistical word
alignment model [12]. With the list of possible APIs, SWIM
searches related API sequences using Lucene [4]. Finally, it
synthesizes code snippets based on the API sequences. As
code synthesis is beyond our scope, we only compare Deep-
API with the API learning component of SWIM, that is,
from a natural language query to an API sequence. In theirTable 1: BLEU scores of DeepAPI and related tech-
niques (%)
Tool Top1 Top5 Top10
Lucene+UP-Miner 11.97 24.08 29.64
SWIM 19.90 25.98 28.85
DeepAPI 54.42 64.89 67.83
experiments, SWIM uses Bing clickthrough data to build
the model. In our experiment, for fair comparison, we eval-
uate SWIM using the same dataset as we did for evaluating
DeepAPI . That is, we train the word alignment model and
build API index on the training set, and evaluate the search
results on the test set.
5.3 Accuracy (RQ1)
5.3.1 Intrinsic Evaluation
Evaluation Setup: We rst evaluate the accuracy of
generated API sequences using the BLEU score. As de-
scribed in Section 4.1, we collect a database comprising
7,519,907hAPI sequence, annotation ipairs. We split them
into a test set and a training set. The test set comprises
10,000 pairs while the training set consists of the remain-
ing instances. We train all models using the training set
and compute the BLEU scores in the test set. We calculate
the highest BLEU score for each test instance in the top n
results.
Results: Table 1 shows the BLEU scores of DeepAPI ,
SWIM, and Code Search (Lucene+UP-Miner). Each col-
umn shows the average BLEU score for a method. As the
results indicate, DeepAPI produces API sequences with
higher accuracy. When only the top 1 result is examined,
the BLEU score achieved by DeepAPI is 54.42, which is
greater than that of SWIM (BLEU=19.90) and Code Search
(BLEU=11.97). The improvement over SWIM is 173% and
the improvement over Code Search is 355%. Similar results
are obtained when the top 5 and 10 results are examined.
The evaluation results conrm the eectiveness of the deep
learning method used by DeepAPI .
5.3.2 Extrinsic Evaluation
To further evaluate the relevancy of the results returned
byDeepAPI , we selected 17 queries used in [36]. These
queries have corresponding Java APIs and are commonly
occurring queries in the Bing search log [36]. To demon-
strate the advantages of DeepAPI , we also designed 13
longer queries and queries with semantically similar words.
In total, 30 queries are used. These queries do not appear
in the training set. Table 2 lists the queries.
For each query, the top 10 returned results by DeepAPI
and SWIM are manually examined. To reduce labeling bias,
two developers separately label the relevancy of each re-
sulting sequence and combine their labels. For inconsistent
labels, they discuss and relabel them until a settlement is
reached. The FRank and the relevancy ratios for the top 5
and top 10 returned results are then computed. To test the
statistical signicance, we apply the Wilcoxon signed-rank
test (p<0.05) for all results of both approaches. A resulting
p-value less than 0.05 indicates that the dierences between
DeepAPI and SWIM are statistically signicant.
Table 2 shows the accuracy of both DeepAPI and SWIM.
The symbol `-' means no relevant result has been returned
within the top 10 results. The results show that DeepAPIis able to produce mostly relevant results. It achieves an av-
erage FRank of 1.6, an average top 5 accuracy of 80%, and
an average top 10 accuracy of 78%. Furthermore, DeepAPI
produces more relevant API sequences than SWIM, whose
average top 5 and top 10 accuracy is 44% and 47%, respec-
tively. For some queries, SWIM failed to obtain relevant re-
sults in the top 10 returned results. We conservatively treat
the FRank as 11 for these unsuccessful queries. Then, the
FRank achieved by SWIM is greater than 4.0, which is much
higher than what DeepAPI achieved (1.60). The p-values
for the three comparisons are 0.01, 0.02 and 0.01, respec-
tively, indicating statistical signicance of the improvement
ofDeepAPI over SWIM. In summary, the evaluation results
conrm the eectiveness of DeepAPI .
Table 2 also shows examples of generated sequences by
DeepAPI . We can see that DeepAPI is able to distinguish
word sequences. For example, DeepAPI successfully distin-
guishes the query convert int to string from convert string
to int . Another successful example is the query expansion.
For example, the query save an image to a le andwrite an
image to a le return similar results. DeepAPI also per-
forms well in longer queries such as copy a le and save it to
your destination path andplay the audio clip at the specied
absolute URL . Such queries comprise many keywords, and
DeepAPI can successfully recognize the semantics.
We also manually check the results returned by SWIM. We
nd SWIM may return partially matched sequences. For ex-
ample, for the query generate md5 hash code , SWIM returns
many results containing only Object.hashCode , which sim-
ply returns a hash code. SWIM also returns project specic
results without fully understanding the query. For exam-
ple, for the query \test le exists", SWIM returns \ File.new,
File.exists, File.getName, File.new, File.delete, FileInput-
Stream.new, FileInputStream.read, ..." , which is not only re-
lated to le existence test, but also to other project-specic
tasks. Such project specic results can also be seen for the
query create le . Compared with DeepAPI, SWIM performs
worse in long queries. For example, SWIM performs worse
in the query copy a le and save it to your destination path
than in the query copy le . This is because long queries
often have multiple objectives, which cannot be understood
by SWIM.
Still, DeepAPI could return inaccurate or partial results.
For example, for the query parse xml , it returns related APIs
InputSource.new, DocumentBuilder.parse . But it misses the
APIs about how DocumentBuilder is created ( Document-
BuilderFactory.newDocumentBuilder ). The reason could be
that an API sequence may be called in an inter-procedural
manner. When preparing the training set, we only consider
API sequences within one method. The API Document-
BuilderFactory.newDocumentBuilder could be called in an-
other method and is passed as a parameter. This causes
incomplete sequences in the training set. In the future, we
will perform more accurate program analysis and create a
better training set.
5.4 Accuracy Under Different Parameter Set-
tings (RQ2)
We also qualitatively compare the accuracy of DeepAPI
in dierent parameter settings. We analyze two parameters,
that is, the dimension of word embedding and the number
of hidden units. We vary the values of these two parameters
and evaluate their impact on the BLEU scores.Table 2: Queries for Human Evaluation (FR: FRank, RR5: top 5 relevancy ratio, RR10: top 10 relevancy ratio)
query (How to...)SWIM DeepAPIGenerated API sequence by DeepAPIFR RR5 RR10 FR RR5 RR10
convert int to string 8 0 10 2 40 90 Integer.toString
convert string to int 1 80 80 1100 100 Integer.parseInt String.toCharArray Character.digit
append strings 3 60 80 1100 100 StringBuilder.append StringBuilder.toString
get current time 1 80 80 10 10 10 System.currentTimeMillis Timestamp.new
parse datetime from string 9 0 10 1100 80 SimpleDateFormat.new SimpleDateFormat.parse
test le exists - 0 0 1100 100 File.new File.exists
open a url 1100 100 1100 100 URL.new URL.openConnection
open le dialog - 0 0 1100 80 JFileChooser.new JFileChooser.showOpenDialog JFileChooser.getSelectedFile
get les in folder 2 40 20 3 40 50 File.new File.list File.new File.isDirectory
match regular expressions 1100 100 1 80 90 Pattern.compile Pattern.matcher Matcher.group
generate md5 hash code 1 60 40 1100 100 MessageDigest.getInstance MessageDigest.update MessageDigest.digest
generate random number 7 0 10 1100 70 Random.new Random.nextInt
round a decimal value - 0 0 1100 100 Math.oor Math.pow Math.round
execute sql statement 2 80 80 1 80 60 Connection.prepareStatement PreparedStatement.execute PreparedState-
ment.close
connect to database 7 0 20 1100 90 Properties.getProperty Class.forName DriverManager.getConnection
create le 10 0 10 3 40 20 File.exists File.createNewFile
copy le 1100 100 2 20 10 FileInputStream.new FileOutputStream.new FileInputStream.read FileOutput-
Strem.write FileInputStream.close FileOutputStream.close
copy a le and save it to
-your destination path1 20 50 1100 100 FileInputStream.new FileOutputStream.new FileInputStream.getChannel File-
OutputStream.getChannel FileChannel.size FileChannel.transferTo FileInput-
Stream.close FileOutputStream.close FileChannel.close FileChannel.close
delete les and folders in a
-directory1100 90 1100 100 File.isDirectory File.list File.new File.delete
reverse a string 3 20 10 2 60 70 StringBuer.new StringBuer.reverse
create socket - 0 0 1 60 80 ServerSocket.new ServerSocket.bind
rename a le - 0 0 1100 100 File.renameTo File.delete
download le from url 2 60 80 1100 80 URL.new URL.openConnection URLConnection.getInputStream BueredIn-
putStream.new
serialize an object 1100 100 3 60 70 ObjectOutputStream.new ObjectOutputStream.writeObject ObjectOutput-
Stream.close
read binary le 4 40 70 1100 80 DataInputStream.new DataInputStream.readInt DataInputStream.close
save an image to a le 1 20 10 1 80 80 File.new ImageIO.write
write an image to a le 1 20 10 1100 90 File.new ImageIO.write
parse xml 1100 100 1 80 60 InputSource.new DocumentBuilder.parse
play audio 1100 100 1 60 80 SourceDataLine.open SourceDataLine.start
play the audio clip at the
-specied absolute URL1 40 50 1100 90 Applet.getAudioClip AudioClip.play
average >4.0 44 47 1.6 80 78
(a)Performance of dierent dimensions of word embedding
(b)Performance of dierent numbers of hidden units
Figure 6: BLEU scores of dierent parameter settings
Figure 6 shows the inuence of dierent parameter set-
tings on the test set. The dimension of word embedding
makes little dierence to the accuracy. The accuracy of
DeepAPI greately depends on the number of hidden units
in the hidden layer. The optimum number of hidden units
is around 1000.
5.5 Performance of the Enhanced RNN Encoder-
Decoder Models (RQ3)In Section 3, we describe two enhancements to the original
RNN Encoder-Decoder model, for the task of API learning:
an attention-based RNN Encoder-Decoder proposed by [8]
(Section 3.1) and an enhanced RNN Encoder-Decoder with
a new cost function (Section 3.2) proposed by us. We now
evaluate if the enhanced models improve the accuracy of
DeepAPI when constructed using the original RNN Encoder-
Decoder model.
Table 3 shows the BLEU scores of the three models. The
attention-based RNN Encoder-Decoder outperforms the ba-
sic RNN Encoder-Decoder model on API learning. The rel-
ative improvement in the top 1, 5, and 10 results (in terms
of BLEU score) is 8%, 5% and 4%, respectively. This re-
sult conrms the eectiveness of the attention-based RNN
Encoder-Decoder used in our approach.
Table 3 also shows that the enhanced model with the
new cost function leads to better results as compared to
the attention-based RNN Encoder-Decoder model. The im-
provement in the top 1, 5, and 10 results (in terms of BLEU
score) is 4%, 2% and 1%, respectively. Figure 7 shows that
the performance of the enhanced model are slightly dier-
ent under dierent parameter settings, with an optimum
of around 0.035. The results conrm the usefulness of
the proposed cost function for enhancing the RNN Encoder-
Decoder model.
6. DISCUSSION
6.1 Why does DeepAPI work?Table 3: BLEU scores of dierent RNN Encoder-
Decoder Models (%)
Encoder-Decoder Model Top1 Top5 Top10
RNN 48.83 60.98 64.27
RNN+Attention 52.49 63.81 66.97
RNN+Attention+New Cost Function 54.42 64.89 67.83
Figure 7: Performance of the Enhanced RNN Encoder-
Decoder Model under Dierent Settings of 
A major challenge for API learning is the semantic gap
between code and natural language descriptions. Existing
information retrieval based approaches usually have a bag-
of-words assumption and lack a deep understanding of the
high-level semantics of natural language and code. We have
identied three advantages of DeepAPI that address this
problem.
Word embedding and query expansion A signicant
dierence between DeepAPI and bag-of-words methods is,
DeepAPI embeds words into a continuous semantic space
where the semantically similar words are placed close to each
other. When reading words in a query, the model maps them
to semantic vectors. Words with similar semantics have
similar vector representations and have a similar impact on
the hidden states of the RNN encoder. Therefore, queries
with semantically similar words can lead to similar results.
Figure 8 shows a 2-D projection of the encoded vectors of
queries. These queries are selected from the 10,000 annota-
tions in the test set. For ease of demonstration, we select
queries with a keyword \le" and exclude those longer than
eight words. As shown in the graph, DeepAPI can success-
fully embed similar queries into a nearby place. There are
three clear clusters of queries, corresponding to \read/load
les",\write/save les", and \remove/delete les". Queries
with semantically related words are close to each other. For
example, queries starting with save,write , and output are
in the same \cluster" though they contain dierent words.
Learning sequence instead of bag-of-words The hidden
layer of the encoder has the memory capacity. It considers
not only the individual words, but also their relative posi-
tions. Even for the same word set, dierent sequences will
be encoded to dierent vectors, resulting in dierent API se-
quences. In that sense, DeepAPI learns not only the words,
but also phrases. While traditional models simply consider
individual words or word-level alignments. A typical exam-
ple is that, queries with dierent word sequences such as
convert int to string andconvert string to int can be distin-
guished well by DeepAPI .
Generating common patterns instead of searching
specic samples Another advantage of our approach is
that, it can learn common patterns of API sequences. The
decoder itself is a language model and remembers the likeli-hoods of dierent sequences. Those common sequences will
have high probabilities according to the model. Therefore,
it tends to generate common API sequences rather than
project-specic ones. On the other hand, the information
retrieval based approaches simply consider searching indi-
vidual instances and could return project-specic API se-
quences.
Though several techniques such as query expansion [18,
40, 50] and frequent pattern mining [49] can partially solve
some of the above problems, their eectiveness remains to be
improved. For example, it has been observed that expanding
a code search query with inappropriate English synonyms
can return even worse results as compared to the original
query [41]. Furthermore, few techniques can exhibit all the
above advantages.
6.2 Threats to Validity
We have identied the following threats to validity:
All APIs studied are Java APIs All APIs and related
projects investigated in this paper are JDK APIs. Hence,
they might not be representative of APIs for other libraries
and programming languages. In the future, we will extend
the model to other libraries and programming languages.
Quality of annotations We collected annotations of API
sequences from the rst sentence of documentation com-
ments. Other sentences in the comments may also be in-
formative. In addition, the rst sentences may have noise.
In the future, we will investigate a better NLP technique to
extract annotations for code.
Training dataset In the original SWIM paper [36], the
clickthrough data from Bing.com is used for evaluation. Such
data is not easy accessible for most researchers. For fair and
easy comparison, we evaluate SWIM on the dataset collected
from GitHub and Java documentations (the same for evalu-
ating DeepAPI ). We train the models using annotations of
API sequences collected from the documentation comments.
In the future, we will evaluate both SWIM and DeepAPI on
a variety of datasets including the Bing clickthrough data.
In the future, we will perform more accurate program anal-
ysis and create a better training set.
7. RELATED WORK
7.1 Code Search
There is a large amount of work on code search [10, 13,
17, 19, 25, 28]. For example, McMillan et al. [28] proposed a
code search tool called Portfolio that retrieves and visualizes
relevant functions and their usages. Chan and Cheng [13]
designed an approach to help users nd usages of APIs given
only simple text phrases. Lv et al. [25] proposed CodeHow,
a code search tool that incorporates an extended Boolean
model and API matching. They rst nd relevant APIs to a
query by matching the query to API documentation. Then,
they improve code search performance by considering the
APIs which are relevant to the query in code retrieval. As
described in Section 6, DeepAPI diers from code search
techniques in that it does not rely on information retrieval
techniques and can understand word sequences and query
semantics.
7.2 Mining API Usage Patterns
Instead of generating API sequences from natural lan-
guage queries, there is a number of techniques focusing ondelete/removesave/write
load/read
15 10 20 25 30 35 40454035302520Figure 8: A 2D projection of embeddings of queries using t-SNE[45]
mining API usage patterns [15, 31, 46, 49]. API usage pat-
terns are frequent API method call sequences. Xie et al. [49]
proposed MAPO, which is one of the rst works on mining
API patterns from code corpus. MAPO represents source
code as call sequences and clusters them according to simi-
larity heuristics such as method names. It nally generates
patterns by mining and ranking frequent sequences in each
cluster. UP-Miner [46] is an improvement of MAPO, which
removes the redundancy among patterns by two rounds of
clustering of the method call sequences. By applying API us-
age pattern mining on large-scale code search results, these
techniques can also return API usage sequences in response
to user's natural language queries.
While the above techniques are useful for understanding
the usage of an API, they are insucient for answering the
question of which APIs to use , which is the aim of Deep-
API. Furthermore, dierent from a frequent pattern mining
approach, DeepAPI constructs a neural language model to
learn usage patterns.
7.3 From Natural Language to Code
A number of related techniques have been proposed to
generate code snippets from natural language queries. For
example, Raghothaman et al. [36] proposed SWIM, a code
synthesis technique that translates user queries into the APIs
of interest using Bing search logs and then synthesizes id-
iomatic code describing the use of these APIs. SWIM has a
component that produces API sequences given user's natural
language query. Our approach and SWIM dier in many as-
pects. First, SWIM generates bags of APIs using statistical
word alignment [12]. The word alignment model does not
consider word embeddings and word sequences of natural
language queries, and has limitations in query understand-
ing. Second, to produce API sequences, SWIM searches API
sequences from the code repository using a bag of APIs.
It does not consider the relative position of dierent APIs.
Fowkes and Sutton [7] build probabilistic models that jointly
model short natural language utterances and source code
snippets. The main dierences between our approach and
theirs are two-fold. First, they use a bag-of-words model to
represent natural language sentences which will not recog-
nize word sequences. Second, they use a traditional proba-
bilistic model which is unable to recognize semantically re-
lated words.7.4 Deep Learning for Source Code
Recently, some researchers have explored the possibility
of applying deep learning techniques to source code [6, 32,
33, 37]. A typical application that leverages deep learning
is to extract source code features [32, 47]. For example,
Mou et al. [32] proposed to learn vector representations of
source code for deep learning tasks. Mou et al. [33] also
proposed convolutional neural networks over tree structures
for programming language processing. Deep learning has
also been applied to code generation [23, 34]. For exam-
ple, Mou et al. [34] proposed to generate code from natural
language user intentions using an RNN Encoder-Decoder
model. Their results show the feasibility of applying deep
learning techniques to code generation from a highly homo-
geneous dataset (simple programming assignments). Deep
Learning has also been applied to code completion [37, 48].
For example, White et al. [48] applied the RNN language
model to source code les and showed its eectiveness in
predicting software tokens. Raychev et al. [37] proposed
to apply the RNN language model to complete partial pro-
grams with holes. In our work, we explore the application
of deep learning techniques to API learning.
8. CONCLUSION
In this paper, we apply a deep learning approach, RNN
Encoder-Decoder, for generating API usage sequences for
a given API-related natural language query. Our empiri-
cal study has shown that the proposed approach is eective
in API sequence generation. Although deep learning has
shown promise in other areas, we are the rst to observe its
eectiveness in API learning.
The RNN Encoder-Decoder based neural language model
described in this paper may benet other software engineer-
ing problems such as code search and bug localization. In
the future, we will explore the applications of this model
to these problems. We will also investigate the synthesis of
sample code from the generated API sequences.
An online demo of DeepAPI can be found on our website
at: https://guxd.github.io/deepapi/.
9. REFERENCES
[1] Eclipse JDT. http://www.eclipse.org/jdt/.
[2] Github. https://github.com.[3] Github search. https://github.com/search?type=code.
[4] Lucene. https://lucene.apache.org/.
[5] M. Allamanis, E. T. Barr, C. Bird, and C. Sutton.
Learning natural coding conventions. In Proceedings of
the 22nd ACM SIGSOFT International Symposium on
Foundations of Software Engineering (FSE'14) , pages
281{293. ACM, 2014.
[6] M. Allamanis, H. Peng, and C. Sutton. A
convolutional attention network for extreme
summarization of source code. In Proceedings of the
International Conference on Machine Learning
(ICML'16) , 2016.
[7] M. Allamanis, D. Tarlow, A. Gordon, and Y. Wei.
Bimodal modelling of source code and natural
language. In Proceedings of The 32nd International
Conference on Machine Learning (ICML'15) , pages
2123{2132, 2015.
[8] D. Bahdanau, K. Cho, and Y. Bengio. Neural machine
translation by jointly learning to align and translate.
arXiv preprint arXiv:1409.0473 , 2014.
[9] L. Bottou. Large-scale machine learning with
stochastic gradient descent. In Proceedings of the 19th
International Conference on Computational Statistics
(COMPSTAT'10) , pages 177{186. Springer, 2010.
[10] J. Brandt, M. Dontcheva, M. Weskamp, and S. R.
Klemmer. Example-centric programming: integrating
web search into the development environment. In
Proceedings of the SIGCHI Conference on Human
Factors in Computing Systems , CHI'10, pages
513{522. ACM, 2010.
[11] P. F. Brown, P. V. Desouza, R. L. Mercer, V. J. D.
Pietra, and J. C. Lai. Class-based n-gram models of
natural language. Computational linguistics ,
18(4):467{479, 1992.
[12] P. F. Brown, V. J. D. Pietra, S. A. D. Pietra, and
R. L. Mercer. The mathematics of statistical machine
translation: Parameter estimation. Computational
linguistics , 19(2):263{311, 1993.
[13] W.-K. Chan, H. Cheng, and D. Lo. Searching
connected API subgraph via text phrases. In
Proceedings of the ACM SIGSOFT 20th International
Symposium on the Foundations of Software
Engineering , FSE'12, pages 10:1{10:11. ACM, 2012.
[14] K. Cho, B. Van Merri enboer,  C. G ul cehre,
D. Bahdanau, F. Bougares, H. Schwenk, and
Y. Bengio. Learning phrase representations using
RNN Encoder{Decoder for statistical machine
translation. In Proceedings of the 2014 Conference on
Empirical Methods in Natural Language Processing
(EMNLP'14) , pages 1724{1734, Doha, Qatar, Oct.
2014. Association for Computational Linguistics.
[15] J. Fowkes and C. Sutton. Parameter-free probabilistic
API mining at github scale. In Proceedings of the
ACM SIGSOFT 24th International Symposium on the
Foundations of Software Engineering (FSE'16) . ACM,
2016.
[16] A. Hindle, E. T. Barr, Z. Su, M. Gabel, and
P. Devanbu. On the naturalness of software. In
Proceedings of the 34th International Conference on
Software Engineering (ICSE'12) , pages 837{847.
IEEE, 2012.
[17] R. Holmes, R. Cottrell, R. J. Walker, andJ. Denzinger. The end-to-end use of source code
examples: An exploratory study. In Proceedings of the
IEEE International Conference on Software
Maintenance (ICSM'09) , pages 555{558. IEEE, 2009.
[18] M. J. Howard, S. Gupta, L. Pollock, and
K. Vijay-Shanker. Automatically mining
software-based, semantically-similar words from
comment-code mappings. In Proceedings of the 10th
Working Conference on Mining Software Repositories
(MSR'13) , pages 377{386. IEEE Press, 2013.
[19] I. Keivanloo, J. Rilling, and Y. Zou. Spotting working
code examples. In Proceedings of the 36th
International Conference on Software Engineering
(ICSE'14) , pages 664{675. ACM, 2014.
[20] J. Kim, S. Lee, S. Hwang, and S. Kim. Towards an
intelligent code search engine. In Proceedings of the
24th AAAI Conference on Articial Intelligence
(AAAI'10) , pages 1358{1363, 2010.
[21] P. Koehn. Pharaoh: a beam search decoder for
phrase-based statistical machine translation models.
InMachine translation: From real users to research ,
pages 115{124. Springer, 2004.
[22] M. Li, T. Zhang, Y. Chen, and A. J. Smola. Ecient
mini-batch training for stochastic optimization. In
Proceedings of the 20th ACM SIGKDD international
conference on Knowledge discovery and data mining
(KDD'14) , pages 661{670. ACM, 2014.
[23] W. Ling, E. Grefenstette, K. M. Hermann, T. Kocisky,
A. Senior, F. Wang, and P. Blunsom. Latent predictor
networks for code generation. arXiv preprint
arXiv:1603.06744 , 2016.
[24] E. Linstead, S. Bajracharya, T. Ngo, P. Rigor,
C. Lopes, and P. Baldi. Sourcerer: mining and
searching internet-scale software repositories. Data
Mining and Knowledge Discovery , 18:300{336, 2009.
[25] F. Lv, H. Zhang, J. Lou, S. Wang, D. Zhang, and
J. Zhao. CodeHow: Eective code search based on
API understanding and extended boolean model. In
Proceedings of the 30th IEEE/ACM International
Conference on Automated Software Engineering
(ASE'15) , pages 260{270. IEEE, 2015.
[26] C. Maddison and D. Tarlow. Structured generative
models of natural source code. In Proceedings of the
31st International Conference on Machine Learning
(ICML'14) , pages 649{657, 2014.
[27] C. McMillan, M. Grechanik, and D. Poshyvanyk.
Detecting similar software applications. In Proceedings
of the 34th International Conference on Software
Engineering (ICSE'12) , pages 364{374. IEEE, 2012.
[28] C. McMillan, M. Grechanik, D. Poshyvanyk, Q. Xie,
and C. Fu. Portfolio: nding relevant functions and
their usage. In Proceedings of the 33rd International
Conference on Software Engineering (ICSE'11) , pages
111{120. IEEE, 2011.
[29] T. Mikolov, M. Kara at, L. Burget, J. Cernock y, and
S. Khudanpur. Recurrent neural network based
language model. In Proceedings of the 11th Annual
Conference of the International Speech
Communication Association (INTERSPEECH'10) ,
pages 1045{1048, 2010.
[30] T. Mikolov, I. Sutskever, K. Chen, G. S. Corrado, and
J. Dean. Distributed representations of words andphrases and their compositionality. In Advances in
neural information processing systems (NIPS'13) ,
pages 3111{3119, 2013.
[31] E. Moritz, M. Linares-V asquez, D. Poshyvanyk,
M. Grechanik, C. McMillan, and M. Gethers. Export:
Detecting and visualizing API usages in large source
code repositories. In Proceedings of the IEEE/ACM
28th International Conference on Automated Software
Engineering (ASE'13) , pages 646{651. IEEE, 2013.
[32] L. Mou, G. Li, Y. Liu, H. Peng, Z. Jin, Y. Xu, and
L. Zhang. Building program vector representations for
deep learning. arXiv preprint arXiv:1409.3358 , 2014.
[33] L. Mou, G. Li, L. Zhang, T. Wang, and Z. Jin.
Convolutional neural networks over tree structures for
programming language processing. In Proceedings of
the Thirtieth AAAI Conference on Articial
Intelligence (AAAI'16) , 2016.
[34] L. Mou, R. Men, G. Li, L. Zhang, and Z. Jin. On
end-to-end program generation from user intention by
deep neural networks. arXiv , 2015.
[35] K. Papineni, S. Roukos, T. Ward, and W.-J. Zhu.
BLEU: a method for automatic evaluation of machine
translation. In Proceedings of the 40th annual meeting
on association for computational linguistics (ACL'02) ,
pages 311{318. Association for Computational
Linguistics, 2002.
[36] M. Raghothaman, Y. Wei, and Y. Hamadi. SWIM:
synthesizing what I mean: code search and idiomatic
snippet synthesis. In Proceedings of the 38th
International Conference on Software Engineering
(ICSE'16) , pages 357{367. ACM, 2016.
[37] V. Raychev, M. Vechev, and E. Yahav. Code
completion with statistical language models. In ACM
SIGPLAN Notices , volume 49, pages 419{428. ACM,
2014.
[38] M. P. Robillard. What makes APIs hard to learn?
answers from developers. IEEE Software , 26(6):27{34,
2009.
[39] M. P. Robillard and R. DeLine. A eld study of API
learning obstacles. Empirical Software Engineering ,
16(6):703{732, 2010.
[40] D. Shepherd, Z. P. Fry, E. Hill, L. Pollock, and
K. Vijay-Shanker. Using natural language program
analysis to locate and understand action-oriented
concerns. In Proceedings of the 6th international
conference on Aspect-oriented software development ,
pages 212{224. ACM, 2007.[41] G. Sridhara, E. Hill, L. Pollock, and K. Vijay-Shanker.
Identifying word relations in software: A comparative
study of semantic similarity tools. In Proceedings of
the 16th IEEE International Conference on Program
Comprehension (ICPC'08) , pages 123{132. IEEE,
2008.
[42] J. Stylos and B. A. Myers. Mica: A web-search tool for
nding API components and examples. In Proceedings
of the Visual Languages and Human-Centric
Computing (VLHCC'06) , pages 195{202, 2006.
[43] I. Sutskever, O. Vinyals, and Q. V. Le. Sequence to
sequence learning with neural networks. In Advances
in neural information processing systems (NIPS'14) ,
pages 3104{3112, 2014.
[44] Z. Tu, Z. Su, and P. Devanbu. On the localness of
software. In Proceedings of the 22nd ACM SIGSOFT
International Symposium on Foundations of Software
Engineering (FSE'14) , pages 269{280. ACM, 2014.
[45] L. Van Der Maaten. Accelerating t-sne using
tree-based algorithms. The Journal of Machine
Learning Research , 15(1):3221{3245, 2014.
[46] J. Wang, Y. Dang, H. Zhang, K. Chen, T. Xie, and
D. Zhang. Mining succinct and high-coverage API
usage patterns from source code. In Proceedings of the
10th Working Conference on Mining Software
Repositories (MSR'13) , pages 319{328. IEEE Press,
2013.
[47] S. Wang, T. Liu, and L. Tan. Automatically learning
semantic features for defect prediction. In Proceedings
of the 38th International Conference on Software
Engineering (ICSE'16) , pages 297{308. ACM, 2016.
[48] M. White, C. Vendome, M. Linares-V asquez, and
D. Poshyvanyk. Toward deep learning software
repositories. In Proceedings of the IEEE/ACM 12th
Working Conference on Mining Software Repositories
(MSR'15) , pages 334{345. IEEE, 2015.
[49] T. Xie and J. Pei. MAPO: Mining API usages from
open source repositories. In Proceedings of the 2006
international workshop on Mining software
repositories (MSR'06) , pages 54{57. ACM, 2006.
[50] J. Yang and L. Tan. Inferring semantically related
words from software context. In Proceedings of the 9th
IEEE Working Conference on Mining Software
Repositories (MSR'12) , pages 161{170. IEEE Press,
2012.
[51] M. D. Zeiler. Adadelta: an adaptive learning rate
method. arXiv preprint arXiv:1212.5701 , 2012.