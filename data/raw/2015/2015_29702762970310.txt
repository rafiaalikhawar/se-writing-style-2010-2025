Array Length Inference for C Library Bindings
Alisa J. Maas
University of
Wisconsin‚ÄìMadison
Madison, WI, USA
ajmaas@cs.wisc.eduHenrique Nazar√©
Universidade Federal de
Minas Gerais
Belo Horizonte, Brazil
hnsantos@dcc.ufmg.brBen Liblit
University of
Wisconsin‚ÄìMadison
Madison, WI, USA
liblit@cs.wisc.edu
ABSTRACT
Simultaneoususeofmultipleprogramminglanguages( polyglotpro-
gramming ) assists in creating eÔ¨Écient, coherent, modern programs
in the face of legacy code. However, manually creating bindings to
low-levellanguageslikeCistediousanderror-prone. WeoÔ¨Äerrelief
intheformofanautomatedsuiteofanalyses,designedtoenhancethe
quality of automatically produced bindings. These analyses recover
high-level array length information that is missing from C‚Äôs type
system. We emit annotations in the style of GObject-Introspection,
whichproducesbindingsfromannotationsonfunctionsignatures.
Weannotate each arrayargumentas terminated by aspecial sentinel
value, Ô¨Åxed-length, or of length determined by another argument.
These properties help produce more idiomatic, eÔ¨Écient bindings.
We correctly annotate at least 70%of all arrays with these length
types,andourresultsarecomparabletothoseproducedbyhuman
annotators, but take far less time to produce.
CCS Concepts
‚Ä¢Softwareanditsengineering !Automatedstaticanalysis;Soft-
ware libraries and repositories; Data types and structures; Soft-
ware maintenance tools; ‚Ä¢Theory of computation !Type struc-
tures;Pattern matching;
Keywords
FFI,foreignfunctioninterfaces,bindings,libraries,staticanalysis,
type inference
1. INTRODUCTION
In modern programs, writing code in a single language may
notalwayssuÔ¨Éce. Developersmaywishtowritenewcodeinone
programminglanguageyetuselegacycodewritteninanother,ormay
wishtoswitchamonglanguagesdependingonthetaskathand. This
leads programmers to produce polyglot programs that mix multiple
languages in a single application. Foreign function interfaces (FFIs)
support polyglot developers by letting high-level languages call into
low-level languages through a series of library bindings . These
bindingscanhide thetediousdetailsof convertingdatatypesfromone language to another. In the context of a cross-language function
call, thehostlanguage is the language supporting the callee, and the
guestlanguage is the language supporting the caller.
A well-written binding does more than just hide low level details
ofpolyglotprogramming. Itadditionallyexposeslow-levellanguage
functions in a way that is consistent with the style and idioms of
thehigh-level-language. Forexample, aCfunctionthat acceptsan
array usually also requires the array‚Äôs length as a separate argument.
A well-written, idiomatic binding hides such details, freeing the
programmer to simply pass the array.
However,creatingbindingsmanuallyistime-consumingandte-
dious. Additionally, human-created bindings frequently contain
errors(Section5.3.2),resultinginascarcityofhigh-qualitybindings.
Weareconcernedwithcreatinghigh-qualitybindingstoC,apopular
target for language bindings. However, the C type system lacks
high-level type information, complicating the automatic production
of high-quality bindings. For example, most high-level languages
clearly distinguish pointers (references) from lists, and the represen-
tation of a list includes its length. By contrast, C conÔ¨Çates arrays
withpointers. ACarrayissimplyarawpointertoallocatedmemory
that may extend beyond a single element, and the length of an array
isnotstoredaspartofitsrun-timerepresentation. EvenaCstring
is represented merely as the char ‚àópointing to its Ô¨Årst character.
Thus,Cdevelopersareleftontheirowntodeterminehowlarge
a given array is, and may adopt diÔ¨Äerent strategies in diÔ¨Äerent
functions. Three idiomatic strategies are particularly common:
1.The array ends with a special sentinel value that can never
appear as a regular array element. Such arrays are considered
to besentinel-terminated . Correct C programs should not
readpastthissentinelvalue. Cstringsarethemostcommon
example. EachstringinCisrepresentedasanarrayof char
ending with the sentinel character /quotesingle.ts1\0/quotesingle.ts1, or ASCII NUL.
2.Thelengthisstoredassomeothervaluemaintainedalongside
the array itself. For example, a function may take two argu-
ments: oneforthearray,andoneforthelength. Likewise,a
structure might store an array and its length in a pair of Ô¨Åelds.
3.Thelengthofthearrayisaconstant. AÔ¨Åxed-lengtharrayof
sizekrequiresanimplicitagreementbetweenthecallerand
thecallee: thecalleeprovidesanarrayofatleastsize k,and
the caller never accesses more than kelements from the array.
InC,thereisnowayforafunctiontoverifythatithasbeengiven
anarrayargumentofthecorrectlength. Alibrarybindingwritten
inahigh-levellanguagecouldperformthistask. Ideally,alibrary
binding for a function accepting a C pointer should allow the caller
to present a high-level array or string when appropriate. Our goal is
to automate the production of such language bindings.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission and/or a
fee. Request permissions from Permissions@acm.org.
ASE‚Äô16 , September 3‚Äì7, 2016, Singapore, Singapore
c2016 ACM. 978-1-4503-3845-5/16/09...$15.00
http://dx.doi.org/10.1145/2970276.2970310
461
deffoo(array, string, Ô¨ÅxedLen):
x = c_expectLenArg(array, len(array))
nulSafeArray = string.replace( /quotesingle.ts1\0/quotesingle.ts1,/quotesingle.ts1/quotesingle.ts1)
nulSafeArray.append( /quotesingle.ts1\0/quotesingle.ts1)
y = c_expectNulTerm(nulSafeArray)
z = c_expectFixedLen(Ô¨ÅxedLen)
return(x, y, z)
Listing 1: Calls using language bindings from Python to C
without length inference
deffoo(array, string, Ô¨ÅxedLen):
x = c_expectLenArg(array)
y = c_expectNulTerm(string)
z = c_expectFixedLen(Ô¨ÅxedLen)
return(x, y, z)
Listing2: CallsusinglanguagebindingsfromPythontoCwith
length inference
The remainder of this paper is organized as follows. Section 2
establishes the motivations for automating annotation inference,
and describes the annotation system that consumes our analysis
results. Section 3 reviews related work to set the context for our
novelapproach. InSection4weformalizeeachlengthidiom,and
present our approach in detail (for each distinct length idiom as well
as for combining results across uses). Experimental evaluations
in Section 5 assess the eÔ¨Äectiveness of our implementation when
applied to multiple real-world libraries. Section 6 discusses options
for future work and Section 7 concludes.
2. MOTIV ATION
Our work automatically recovers high-level information about ar-
rayargumentsinClibraryfunctions, enablingautomaticproduction
ofhigh-quality,idiomaticlanguagebindingstoC.SpeciÔ¨Åcally,we
provide analyses that recover C array argument lengths from LLVM
[12] bitcode. Prior work approaches the problem of determining
the lengths of C arrays with the motivation of discovering memory
vulnerabilitiesinlibraries,suchasbuÔ¨ÄeroverÔ¨Çowviolations. Our
focusonlanguagebindinggenerationallowsustofocusonextracting
programmer intentratherthandiscoveringbuggycode. Thisenables
us to recover more information about the intended length idiom,
which improves language bindings by freeing the caller to pass a
high-level string or array. Length information required by the callee
canbeextractedbythebinding,notthedeveloper. Thismakesthe
bindingmoreintuitive,andlessenstheriskthattheuserofthelibrary
binding might accidentally provide incorrect length information.
Listings1and2showthreecallstolanguagebindingsfromPython
to C. Assume that arrayis a list with arbitrary length, stringis a
NUL-terminated string, and Ô¨ÅxedLenis an array of exactly length
4. In each example, the binding hides some of the more frustrating
partsof makinganexternal call: allocatingspace forthe arrayand
copyingalloftheelementsover. NoticethatListing1containsan
additionalloopandallocationintheformofthe string.replace call.
The string must be NUL-terminated and not contain embedded NUL
characters, as the low-level C function expects. Without high-level
array type information available in the binding, the user is forced to
handlethismanually. Iftheuserisunsurewhetherthestringends
withaNULorcontainsembedded NULcharacters,shemighthave
to manually copy the characters to a separate array to ensure this.In Listing 2, the user directly passes the arrays and string without
extracting length information. In Listing 1, she must manually pass
the length of each array, even though the Python object representing
each array maintains length information. Extracting the length
information on the Python side is straightforward; the diÔ¨Éculty lies
in determining what length information the C code requires.
Although Listings 1 and 2 call functions whose names make
the expected length information abundantly clear, this is often
not obvious from the API. Programmers who wish to call a C
function must Ô¨Årst search for documentation, which may or may
not give an indication as to expected length conventions. Worse,
in many libraries, this documentation is sparse, out-of-date, or
non-existent. Developers may be forced to examine the source
code by hand, searching for evidence of one length convention or
another. We address this hidden work involved in manually creating
across-languagecallsuchastheoneinListing2. Tothatend,we
automatethisprocessusingstaticanalysis. Recoveringhigh-level
typeinformationaboutCarraysletsusproducelanguagebindings
that are more intuitive for users of high-level languages.
InthecaseofÔ¨Åxed-lengtharrays,weoÔ¨ÄersomebeneÔ¨Åtbeyond
amoreintuitivebinding: wecanproduceamoreeÔ¨Écientbinding
by stack-allocating arrays wherever possible. GObject-Introspection
supports annotations providing memory ownership information,
and these annotations can be inferred using work by Ravitch and
Liblit[19](see Section 3). This gives GObject-Introspection the
abilitytoknowwhenitissafememorymanagementtostack-allocate
arrays. However, only Ô¨Åxed-length arrays may be stack-allocated
in C. Stack allocated arrays avoid memory leaks due to incorrect
library usage and also reduce heap churn, simplifying the job of
the garbage collector. Bindings with stack-allocated arrays are also
more amenable to further analysis than bindings that use the heap.
One diÔ¨Éculty in automatically extracting length information
concerns the availability of code which uses the library, or client
code. Client code is a natural way to discover information about the
lengthsofarrays,bothatallocationpointsandatlibraryAPIcallsites.
Unfortunately, many libraries that would beneÔ¨Åt from an automated
languagebindinggeneratordonothaveeasilyaccessibleclientcode.
Itmightbepossibletousetestcodeinstead. However,amongthe
six libraries in our evaluation, gckhas no test suite, and libssh2‚Äôs
minimal tests do not cover its entire API. The remaining libraries
havetests,butwecannotspeaktotheirthoroughness. Further,we
expect that production of language bindings is most helpful early in
alibrary‚Äôsdevelopment.Atthistime,testsarelikelytobeincomplete
orevenmissing. Thus,wedonotassumeclientcodewillbepresent.
Ourhigh-levelgoalistocreatemoreautomatic,intuitivebindings:
morelike thoseinListing 2thanthose inListing1. Weexpectthis
to reduce frustration and ease the learning curve associated with
polyglot programming, for the developer producing the binding and
thedeveloperusingthebinding. Ifcreatingintuitivebindingsismade
easierfordevelopers,moredeveloperswillcreatelanguagebindings.
Ifmoreintuitivelanguagebindingsexist,moreprogrammerswillbe
able to eÔ¨Äectively make use of polyglot programming.
To that end, we emit annotations in a format read by GObject-
Introspection [ 9]. GObject-Introspection provides a suite of tools
thatreadinaseriesofannotationstoprovideanautomatic,idiomatic
languagebindingtoC.GObject-Introspectioncanproducelanguage
bindings to C from many high-level languages, including Python,
Java,Perl,andothers. Inadditiontoproducinglanguagebindings
toeachoftheselanguages,GObject-Introspectionstreamlinesthe
process of producing language bindings, making it possible to
createlanguagebindingsfromanarbitrarylanguagemoreeÔ¨Éciently.
Examples in this paper assume that the guest language is Python.
However,GObject-Introspection‚Äôsannotationsaremoregeneral,and
462our tool inherits its generality. While we are limited to GObject-
Introspection‚Äôs annotations, their annotations are fairly extensive,
and already have many users. The utility of a ready-made user base
and binding generator far outweighs the modest improvement in
precision we could get by creating our own system of more complex
annotations. Producinglengthannotationsautomaticallybypasses
some of the tedious work involved in writing language bindings,
which saves developer time. Further analyses could be combined
with ours to create the full set of GObject-Introspection annotations,
which are not limited to just array length annotations.
3. RELATED WORK
Ravitch et al. [20]automatically generate bindings based on
staticanalysisofC,whileRavitchandLiblit [19]analyzememory
ownershipinClibrariestoproducebindingsthatcorrectlyhandle
memorymanagement. Ourworkextractsarraylengthinformation,
not memory management models, from C. It could be used in
cooperation with these to produce better bindings. SALInfer [ 11]
statically analyzes C, in part to detect potential buÔ¨Äer overÔ¨Çows.
SALInferalsoproducesannotations, includinga‚Äúzterm‚Äùannotation
for strings, which it detects by recognizing writes of NULinto
buÔ¨Äers. SALInferoperatesovera completeprogram,andtherefore
is guaranteed to have access to the source code that writes NUL
into each sentinel-terminated array. We analyze library code, and
thereforecannotassumethatsentinelwritesarevisibletous. Furrand
Foster[4]describe a pair of tools that ensure type-safety of OCaml-
to-C and Java-to-C (JNI) bindings. These tools are complementary
to ours, as they statically checkproduced FFIs for safety, whereas
we automate part of the process of creating those FFIs. Lu et al.
[15]performaccesscorrelationinordertohuntconcurrencybugs.
In particular, they track constraint speciÔ¨Åcation, which includes
symboliclengthsofarrays. However,theyfocusonlyonglobalsand
structure Ô¨Åelds, in order to narrow in on concurrency bugs, while
we are interested ultimately in arguments of arrays.
CCured [ 18] retroÔ¨Åts run-time bounds checks into C code to
ensurememorysafety. CCuredidentiÔ¨Åespotentiallyunsafeaccesses
by using type inference rules that follow from physical subtyping
andlimitedmanualannotations. WeshareCCured‚Äôsdesiretouse
static inference to extend the limited type system of C. However,
our ultimate goals diÔ¨Äer, leading CCured to add run-time checks for
potentiallyunsafememoryaccesses. Incontrast,wemightignore
these accesses to extract high-level programmer intent. Further,
CCured requires some hand-crafted annotations; we require none.
A host of other work attempts to recover length information in
C, typically with the goal of statically detecting memory safety
violations. Wies et al.‚Äôs shape analysis [ 24] relies on complex
symbolic predicates to facilitate a precise approach. They require
precisioninordertoacceptonlysafememoryaccesses. Dhurjatietal.
[3]‚Äôsstaticanalysisenforcesmemorysafetywithout(programmer-
created)annotations,run-timechecks,orgarbagecollection. They
provide a region analysis to accomplish this. Our approach is more
heuristic, which may allow us to derive more information.
Alloftheseapproachesanalyzecompleteprograms,notlibrary
functions. Theyassumethatthecodebeinganalyzedisuntrustworthy,
while we assume that library code is correct (at least in intent). A
bug-hunting approach seeks inconsistencies in the way C length
informationistreated,andsocanonlydeterminethatanarrayisused
safely. Ourhigh-levelunderstandingofthelengthofanarraydoes
notrequirebug-freeimplementations. Weextractdeveloper intent,
which may still be recognizable despite implementation errors.
Le and SoÔ¨Äa [13]detect user-speciÔ¨Åed faults, and use path-
sensitivedatatoreducethenumberoffalsepositivespresentedto
the user. They categorize potentially vulnerable statements intoÔ¨Åve types, allowing their users to focus on relevant statements.
They recognize the burden on the programmer to provide length
information and wish to automate this process. SoftBound [ 16]
analyzesmetadatacreatedatruntimeinordertocatchunsafememory
accesses. SoftBoundusesstaticanalysis todeterminewhereto use
metadataatruntime,buttheyfocusonprogramtransformation. They
attempt to Ô¨Ånd every potentially unsafe memory access. Further,
they do not produce symbolic length types evident in the source
code; length information is stored at run time in metadata. We seek
a purely static approach, as we do not assume a complete program.
Rugina and Rinard [21]use an interprocedural bounds analysis
to determine memory safety, and has a wide variety of applications.
Their approach is similar to that of the symbolic range analysis
performedbyNazar√©etal. [17],whichweusetocomputeupperand
lowerboundsofarrayindicesinourtool. Nazar√©etal.‚Äôsapproachis
very lightweight, and appears to scale well to large programs, while
RuginaandRinard‚Äôsresultsindicatethattheremaybeissueswith
scalingtolargerprograms,suchasthelibrariesweintendtoanalyze.
Alvesetal. [1]provideanoptimizationtechniquetodisambiguate
pointers at run time. Their focus is towards producing superior
optimized code, and to this end they transform the code to make use
of run-time information. Although disambiguation of pointers is
very useful for our algorithm, we take a static approach, and thus
cannot make use of dynamic information.
SWIG[2]isaverypopulartoolprovidingadiÔ¨Äerentsetofbindings
from GObject-Introspection, and theoretically could beneÔ¨Åt from
our provided annotations as well. However, at this time, SWIG does
not support annotations identifying pointers as arrays, nor handle
the lengths of arrays. Thus we target GObject-Introspection instead.
4. APPROACH
This section is laid out as follows. Section 4.1 describes the
formaldeÔ¨Ånitionsofeachofourlengthproperties,andSection4.2
introduces the assumptions we leverage to approximate these length
properties. Sections4.3to4.5layouttheanalysesusedtorecover
lengthinformation,andSection4.6describesourmethodformerging
lengthpropertieswhenmorethanonestrategyappearstobeusedfor
encodingthelength. Section4.7discussesexpandingouranalysis
to structure Ô¨Åelds. Finally, Section 4.8 explains sources of false
positives and true negatives in our analyses.
4.1 Formal DeÔ¨Ånitions
Letabe one dynamic instance of a zero-based array in one
execution of a function in one particular run of the code under
analysis. Let access (a;i)betrueifthisspeciÔ¨Åcruneveraccesses aat
element i. Let allocated (a)bethetotalnumberofelementsallocated
in the block of memory containing a. Note that allocated (a)0
in all cases. Then deÔ¨Åne memsafe (a)as@iallocated (a)such
thataccess (a;i). This is the basic memorysafetyproperty , which
requires that anever be accessed beyond its allocated bounds.
WenowdeÔ¨Ånethelengthofanarrayargument ainthecontextof
a particular execution of function f. In each of the following cases,
assume Ô¨Årst that memsafe (a). Then:
Case 1:Letkbe the minimum non-negative integer such that
access (a;i)!i<k. Then ahas Ô¨Åxed-length k.
Case 2:Letnbeanargumentto f. Ifaccess (a;i)!i<n,then a
has symbolic-length n.
Case 3:Let!be some sentinel value. If 9nja[n]=!^80
i<n;a[i],!^8i>n;:access (a;i), then ais sentinel-
terminated by !.
463Jointly, we refer to these as the formal length properties of an
array. For ato have a property statically, it must have that property
in every possible execution of f. Thus, the valid static properties
ofaare the intersection of the properties across all executions of
funderallpossibleinputs. Itispossibleforanarraytohavemore
than one of these length types simultaneously. An array might have
a Ô¨Åxed-length, and always end with a NUL. Likewise, perhaps an
array has a symbolic-length whose actual value is always a constant.
Ingeneral,anarray‚Äôslengthmaybesomefunctionofothersymbolic
or constant values. However, empirically, this is very uncommon,
and we do not address this generalization.
All three of the above cases are undecidable in general. For
example, access (a;i)is quantiÔ¨Åed over all possible runs, on all
possibleinputs,while allocated (a)requiresknowingtheexactsizes
ofarrays,includingthosedynamicallyallocated. Inthecontextof
libraryAPIslackingclientcode,thisbecomesevenmorechallenging:
the allocation points may not even be present. These deÔ¨Ånitions
serve as useful Platonic ideals: perfect but unattainable. With these
in mind, we design static approximations that sacriÔ¨Åce soundness
and completeness in exchange for decidability and greater utility.
4.2 Key Ideas
We address the problem of extracting high-level properties about
the static lengths ofpointers representing arrays in C. Inparticular,
we recover whether each array argument to a C function is termi-
nated by a sentinel value, or discover the symbolic or constant value
representingthelength. Ourapproachfordoingsonecessarilyap-
proximatesthe(undecidable)formallengthproperties. Ourapproach
attimesover-approximatesandattimesunder-approximatesthese
properties. In order to more completely analyze libraries, we make
three key assumptions , which introduce these approximations.
1.Weassumethatfunctionswillnotbeintentionallyobfuscated,
and thatthedeveloperintendsforeacharrayargumentto
have at most one formal length property .
2.Weassumethatlibrarycodetreatsanargumentlikeasentinel-
terminated, symbolic-length or Ô¨Åxed-length array only if that
matches programmer intent. Due to this, if an argument
is ever treated as if it has a length property, it has that
property. TheformaldeÔ¨Ånitions(Section4.1)onlyascribe
apropertytoanarrayifitmusthavethatpropertyacrossall
possible executions. We ascribe properties to arrays if they
havethatpropertyinsomeexecution. Ourreasonsfordoing
this are twofold: computing the exact array length properties
is undecidable in the general case; and due to assumption 1.
3.We assume the memory safety property discussed in Sec-
tion 4.1. That is, we assume that all accesses to elements
from anarray aresafe . Leveragingthisassumption,were-
coverprogrammerintentofarraylength,evenincodewithout
the memory safety property (where behavior is technically
undeÔ¨Åned). While bug-hunting approaches analyze the
code you have, we analyze the code you think you have.
We donotassume that we have any access to client code that
uses a given library. Analyzing client code would allow us to make
use of arguments to mallocindicating the actual size of the array.
However,weintendforourtooltobeusefultodevelopersearlyin
the development process, when there may not yet be any client code
toanalyze. Further,theamountofworkrequiredforthedeveloper
to Ô¨Ånd client code, verify that it uses the library code as intended,
install the client code and then run our tool may be prohibitive, and
ourworkseekstomaketheprocessaseasyaspossibleforthelibrary
developer. Thus, we do not currently analyze client code.intsymbolicLength( int ‚àóarray, inty)
{
if(array[3] < 0)
returnarray[0];
intsum = 0;
for(inti = 0; i < y; i++)
sum += array[i];
returnsum;
}
Listing 3: Example function with an argument of symbolic
length
4.3 Symbolic Range Analysis
Ourtechniques(especiallythoseinSection4.4)relyheavilyon
determining upper bounds on indices into arrays. We accomplish
this using static range analysis. Range analyses attempt to statically
infer intervals that conservatively encompass all values a given
program variable can assume. The range analysis we use, which
is described and implemented by Nazar√© et al. [17], handles only
integer values and allows interval expressions to be symbolic.
For a practical explanation, consider Listing 3, with three integer
variables ( y,sum, andi) and one array variable ( array). Let ~y
representthestatically-inferredintervalacrosswhich yranges,and
likewise for ~sumand~i.yis regarded as an input, as are all
integerparameters,sincenothingisknownaboutthevaluestheycan
assume. In a numeric range analysis, this would typically mean that
it resides at the top of the interval lattice, which denotes a complete
absenceofinformation. Thiscanberepresentedby [ 1;1]. On a
symboliclattice,however,symbolicallyrepresentingvariablebounds
is possible. So, while very little is known about the actual numeric
valuesyassumes, denoting its interval as [y;y];y2Nis valid
and is what the symbolic range analysis does. Naturally, since iis
boundedbelowby 0andboundedaboveby y,~i=[0;y]. Through
variablerenaming, the analysisalsoinfersthatinsidethe forloop,
~i=[0;y 1]. The variable sumis repeatedly summed with
unknownvalues,sotheanalysisgivesitanabstractstateof [ 1;1].
Range analyses have a variety of applications, such as static
branch prediction or proving safety with regard to memory and
integer overÔ¨Çow. Nazar√© et al. use their analysis to check array
subscripts against the size of the arrays themselves, in an attempt
to statically prove the safety of load and store operations; i.e.,
the memory safety property for loads and stores. We instead use
subscript intervals to infer the intended lengths of the arrays they
index, as we explain in Section 4.4.
4.4 Symbolic- and Fixed-Length Detection
Atahighlevel,weinferthatarrayargument arrayhassymbolic
lengthyifatmosttheÔ¨Årst yelementsareaccessedfromit. Notethe
paralleltoourdeÔ¨ÅnitioninSection4.1. Weareattemptingtoidentify
exactlythelengthincase2. ConsiderthefunctioninListing3. This
functionaccessestheelements 0throughy 1fromarray. Notethat
arraycouldactuallyhavemorethan yelements;thiscodewouldstill
obeythememorysafetypropertyif yweresmallerthantheactual
lengthof array. Weexploitkeyassumption2whenwesaythat array
hassymboliclength y. Wecannotrecover allocated (arra y),butwe
can recognize the programmer‚Äôs intended length.
ToÔ¨Åndsymboliclengths,weconsiderthepossiblerangeofvalues
for each index into each pointer argument, array, in a function, f.
464intsymbolicLoop( int ‚àóarray, inty)
{
int ‚àóend = array + y;
intsum = 0;
while(array < end) {
sum += ‚àóarray;
array++;
}
returnsum;
}
Listing 4: Example function with an argument of symbolic
length containing a specialized loop
Assume that yis some integer argument to f. For our analysis to
conclude that arrayhas symbolic length y, some index must have
upperbound y 1,andallotherindicesmusteitherhaveasmaller
upper bound or a constant upper bound. This represents another
departurefromourdeÔ¨Ånitionofsymbolic-lengthfromSection 4.1.
Weapplyourdomainknowledgeinordertoassumethat ywillbe
largerthananyconstantinthegeneralcase. Wehavenotempirically
found any false positives arising from this assumption. In Listing 3,
wecanseethatthe forloopwillaccesspreciselyelements0through
y 1, while element 3is accessed outside the loop.
Withamoresophisticatedanalysis,wemightbeabletorecover
information such as ‚Äú arrayhas at least length 3and at least length
y‚Äù. However, the utility of this for producing language bindings
is limited to dynamic checks that the binding is being used cor-
rectly. While it provides some beneÔ¨Åt, it does not directly make the
productionoflanguagebindingsmoreautomaticormoreintuitive.
Further,GObject-Introspection,ourtargetbindinggenerator,does
notcurrentlysupportannotationsthatarecomplexenoughtoexpress
this. Notice that if our goal were to statically check for the memory
safety property, such information would be of great use. This would
allowustoinferthatinorderforthearrayaccesstobecorrect, array
must have size at least 3. We could then prove that arrayalways has
at least size 3, or Ô¨Ånd some input where the size is less than 3.
We use Nazar√© et al.‚Äôs Symbolic Range Analysis tool ( SRA) [17]
to determine upper bounds of array indices. However, SRA only
computes the upper bounds of integervalues; it does not handle
pointers ranges. We Ô¨Årst transform pointer arithmetic and pointer
comparisons into equivalent array-oÔ¨Äset indices, which SRA can
thenanalyze. Thistransformationreplacesanycodethatincrements
a pointer, array, with code incrementing an index, i, by the same
amount. Any operations accessing element jfromarrayare then
transformed to access element j+i. (In most cases, jis0.) This
transformation is interesting in two ways. First, it is an example
ofade-optimizationdonetomakethecodeeasiertoreasonabout
and analyze. Strength reduction, a common class of compiler
optimization,maygeneratecodethatincrementsanarray(interpreted
as a pointer to its data) rather than using array-oÔ¨Äset indices. We
essentially reverse this optimization in order to make more eÔ¨Äective
useofSRA. Second,ourtransformationpassmayproducecodethat
is less eÔ¨Écient than the original. However, this is unimportant as
the code is discarded after analysis without being run.
Wetakeanevenmorelenientapproachtodeterminingwhetheran
arraymayhaveasymboliclengthinthepresenceofloops. Foreach
loop,weÔ¨Åndcodethatcomparestheaddressofsomeelementofthe
arraytoaÔ¨ÅxedoÔ¨Äsetfromthearray( y),andbranchesoutoftheloop
uponreachingthatoÔ¨Äset. Ifeachiterationoftheloopmustcomplete
suchacheck,then arrayhassymboliclength y,regardlessofwhatguint g_str_hash (gconstpointer v)
{
const signed char ‚àóp;
guint32 h = 5381;
for(p = v; ‚àóp != /quotesingle.ts1\0/quotesingle.ts1; p++)
h = (h << 5) + h + ‚àóp;
returnh;
}
Listing 5: Real-world function with an argument sentinel-
terminated by NUL, taken from glib
happensoutsidetheloop. Forexample,inListing4,eachiterationof
thewhileloop must compare the current value of arrayto the initial
value of array +y. The whileloop terminates once they are equal.
This approach is a heuristic; it causes us to over-approximate the set
ofsymbolic-lengtharrayscomparedtothedeÔ¨Ånitionofsymbolic-
lengthfromSection4.1. Thisarisesbecauseofkeyassumption1. In
practice,itappearsthatCprogrammersfollowthisassumption,even
thoughthetypesystemdoesnotrequirethis. Wehavefoundnofalse
positives resulting from this heuristic in our empirical evaluation.
Fixed-lengtharraysareaspecialcaseofsymbolic-lengtharrays,
where every oÔ¨Äset from the array is constrained to be a constant. If
a non-constant oÔ¨Äset from the array is ever accessed, then the array
cannotbeÔ¨Åxed-length. Thesimilarityinourapproachesheremirrors
the similarity in our deÔ¨Ånitions of Ô¨Åxed-length and symbolic-length:
Cases 1 and 2 in Section 4.1.
4.5 Sentinel-Terminated Detection
PerSection4.1,anarrayisterminatedbyasentinelvalueifthat
value lies at the logicalend of the array. Note that this does not
necessarilymeanthatthesentinelvalueliesattheendofallocated
memory. Rather, any reads past the sentinel value have no semantic
interpretation. Sinceweassumecorrectcode,weexpectnottosee
any such reads. Listing 5 shows a real-world string hash function
that accepts a logical string, and treats it accordingly in the loop.
To identify sentinel-terminated arrays, we search for arrays that are
never read past the sentinel character. In Listing 5, the sentinel
character is /quotesingle.ts1\0/quotesingle.ts1, or ASCII NUL, and after the function processes a
NULcharacter, it never reads another element from the array.
Ouranalysisforsentinel-terminatedarraysleveragesloopstruc-
tures in order to detect the sentinel-terminated property. Consider a
function, f,withpointerargument array. Weexamineeachnatural
loop that accesses oÔ¨Äsets of array(directly or transitively), and
compute its set of mandatory sentinel checks of array.
Lettheentryoftheloopbe Lentry. Let check (array;i; !;b)bean
accessof arrayatoÔ¨Äset i,comparingthevalueatthisoÔ¨Äsetto !with
Booleanresult b. We consider check (array;i; !;b)tobe asentinel
checkofarraywhencontrolÔ¨Çowexitstheloopif bistrue. Thinking
in terms of a dynamic execution of the loop, the loop contains a
mandatorysentinelcheck wheneveryexecutionfrom Lentrylooping
back to Lentrycontains at least one sentinel check.
We determine whether a sentinel check of arrayis mandatory
using a depth-Ô¨Årst search through the loop body. If at least one
sentinelcheckof arraymustexecuteoneverypossibleiterationof
theloop,thenthislooptreats arrayassentinel-terminated. Perkey
assumption 2, if any loop treats arrayas sentinel-terminated, then
we annotate arrayas sentinel-terminated.
465>=unknown
Ô¨Åxed (1)
:::
Ô¨Åxed (maxConst )
notFixed
sentinel (!)

?=inconsistentsymbolic (0) symbolic (numArgs 1)
Figure1: Resultlatticeforanysinglearrayunderanalysisina
functionwith numArgs argumentsandnoconstantindexlarger
than maxConst . Ellipses notwithstanding, the lattice is Ô¨Ånite in
both width and height.
Notice a deviation from our formal deÔ¨Ånition of a sentinel-
terminated array in Section 4.1. Even with a mandatory sentinel
checkinaloop, NULcharactersmaybeskippedoverinthecourseof
an iteration. The loop counter could increment by some value other
than 1, or reads and writes outside the loop may occur. In this case,
theoretically,sentinelcharactersmightbepassedover. Duetokey
assumption 3, we ignore this possibility in order to arrive at a more
completeapproach. Suchanassumptionwouldbeunacceptableif
we were attempting to check the memory safety property.
4.6 Merging Length Types
To this point, we have discussed how to approximate whether an
arrayhaseachoftheformallengthpropertieswithinasinglefunction.
OurformaldeÔ¨ÅnitionoflengthtypesinSection4.1technicallyallows
foranycombinationofthethreelengthtypes. However,ourgoalisto
produce source-code level annotations that facilitate cross-language
bindings. We are interested in length properties that rely more on
developer intent than on the physical layout of the arrays in memory.
Forthisreason,andduetokeyassumption1(seeSection4.2),we
produce at most one annotation per argument, even if more than
onecouldapply. Ourgoalistoprovidethemosthelpfullanguage
bindings possible, so we make an eÔ¨Äort to produce the most helpful
annotation consistent with the analysis. Although multiple length
types may be correct, we attempt to determine the most general one,
based on the particular domain of language bindings for C libraries.
We also extend our analysis beyond individual procedures. In
ordertoaddressinternalcallsfromonelibraryfunctiontoanother,we
iterateuntilwereachaÔ¨Åxedpoint. Asweiterate,wecombineresults
from diÔ¨Äerent parts of our analysis to select at most one annotation
per array argument. We endeavor to select the most general (still
correct) annotation for each array argument. Figure 1 compactly
summarizesourschemefordeterminingwhichannotationsarethe
mostgeneral. Themostgeneralannotationisconsideredtobethe
greatest lower bound of this lattice. Our analysis is guaranteed to
terminate,becauseweonlyreplaceanannotationwithamoregeneral
annotation and there are a Ô¨Ånite number of possible annotations.
LetÔ¨Åxed (n)denoteaÔ¨Åxed-lengthtypewhere nistheÔ¨Åxedlength
ofthearray. Similarly, symbolic (n)representsasymbolic-length
typewhere nistheargumentnumberoftheargumentrepresentingthe length. The sentinel-terminated type with sentinel value NULis
represented as sentinel (!).
We also use three special length types: unknown,notFixed, and
inconsistent . These types do not correspond to annotations, but
representarrayswithintermediatetypes. unknown meansthatthe
argument is compatible with any length type. Often, this means that
there are no accesses to elements from the array at all. notFixed
meansthattheargumentiscompatiblewithanylengthtypeexcept
Ô¨Åxed (n)for any n. This can happen when any non-constant index
intothearrayispresent. Oftenthesenon-constantindicesarealso
symbolic length, but it is also possible that the length of the array
is determined in some other way. inconsistent means that multiple,
incompatible length types appear to be present. For example, the
array might be accessed up to locations nandm, which both are
additional arguments to the function. In this event, the most general
annotationwecanprovideisnoannotationatall,sinceneitherpiece
of length information is truly safe to present. The lattice is most
generalatthetop,whichisconsistentwithanylengthtype;itisleast
general at the bottom, which is consistent with no length type.
Forpurposesofproducingannotations,itismostusefultopresent
onlythesinglemostgenerallengthtype. Ournotionofgenerality
is the one that selects the single binding that exposes the most
functionality. When multiple length types are present, we take
the meet (u) in the lattice depicted in Figure 1. For example,
Ô¨Åxed (n)uÔ¨Åxed (m)yields Ô¨Åxed (max (n;m)). Ingeneral, Ô¨Åxed-
length types defer to any other kind of length: an array that is
treatedasbothÔ¨Åxed-lengthandsentinel-terminatedisassumedto
be sentinel-terminated;an array thatis treatedas having bothÔ¨Åxed
andsymboliclengthsisdeemedtohavesymboliclengthoverall. We
choosethistobethemostgeneralbecauseaÔ¨Åxed-lengtharraycan
alwaysbeusedwhereasentinel-terminatedorsymbolic-lengtharray
is used. The only requirement is that it be sentinel-terminated or
the length be passed as an argument as appropriate, and the binding
can hide this work. Symbolic lengths also subsume sentinels: for
alln,sentinel (!)usymbolic (n)=symbolic (n). Weconsider
symboliclengthtobemoregeneralbecauseasentinel-terminated
array has a length that might be passed as the symbolic-length.
On the other hand, a symbolic-length array need not end with
a terminating sentinel character, and worse, might contain the
sentinel character well before the logical end. The binding would
need to determine how to handle this, and may make the wrong
decision. Finally, mismatched symbolic lengths are incompatible:
symbolic (n)usymbolic (m)=inconsistent unless n=m. In
this event, we have no recourse: there is no way to determine which
ofthetwosymboliclengthswereintendedbythedeveloper,andany
assumption may cause a confusing binding to be created.
4.7 Structure Information
Cstructurescancontainpointerswhichhavethesameambiguities
as argument pointers, and can be analyzed similarly. Like C pointer
arguments, structure elements that are pointers also require their
length to be stored implicitly. This can be done in the form of an
additional structure Ô¨Åeld representing the length, or the structure
Ô¨Åeld can be sentinel-terminated, or may have a Ô¨Åxed, known size. A
structureÔ¨Åeld hasalengthproperty ifanyinstance ofthestructure
treats the Ô¨Åeld that way, as per key assumption 2. Once we have
determinedalengthpropertyforthestructureÔ¨Åeld,considerthatany
arrayargumentsstoredinitcouldbeaccessedwhereverthestructure
Ô¨Åeld is accessed. Thus, if a structure Ô¨Åeld element is ever treated
as Ô¨Åxed-length, sentinel-terminated or symbolic-length, then any
pointer arguments stored into that Ô¨Åeld must follow the same length
idiom (key assumption 1). This potentially allows us to retrieve
lengthinformationaboutarrayargumentsthatwouldotherwisebe
466impossibletodetermine,forexample,inasetterfunctiontakinga
pointer to a structure along with the data to store in the structure.
After determining the length properties of structure Ô¨Åelds (as in
Section 4), we search for store operations that store an array (either
an argument or structure Ô¨Åeld) into an annotated structure Ô¨Åeld. We
then propagate this length information to the stored array as well.
In theory, this also gives us more information about the structure
arguments to functions, as well. GObject-Introspection currently
doesnotsupportsuchannotationsonstructures,presumablybecause
mostfunctionsthatrequireastructurearenotpartoftheexternalAPI
thatwouldrequireabinding. Ifstructureannotationsareavailablein
the future, our tool should provide these with minimal modiÔ¨Åcation.
We implemented such an analysis and combined it with our
argumentanalyses. Thisdid allowus torecoverlength information
for a handful of array arguments that had previously not been
recovered, but it also slowed execution time massively. Further
detailsontheseresultscanbefoundinSection5.5. Thisoverheadis
likelybecauseofthevastnumberofstoresintostructureelements
in a sizable library. Further, it seems that many of the functions
beneÔ¨Åting from this new information were not part of the public
APIofthelibrary,meaningthattheenduserwillnotbeneÔ¨Åtfrom
annotating these arguments in the Ô¨Årst place.
4.8 Notes on Soundness and Completeness
Most length analyses, particularly those for verifying the memory
safety property, attempt to be sound or complete. Soundness
requires never erroneously reporting a length type; completeness
requires reporting all length types. We sacriÔ¨Åce both soundness and
completeness in favor of practical utility.
4.8.1 Practical Trade-Offs for Useful Bindings
We Ô¨Ånd a trade-oÔ¨Ä between two competing concerns. On the one
hand,Ô¨Åndingthephysicallengthsinmemoryofeacharrayargument
producesmoreusefulbindingsthanÔ¨Åndingthehighest-numbered
element a function will access. However, this often cannot be
staticallydeterminedwithoutintroducingunsoundness. Ontheother
hand, Ô¨Ånding the maximum array oÔ¨Äset is more frequently statically
discoverable. However, this can produce less useful bindings, since
the last used element may or may not correspond to the allocated
length of the array.
Asoundanalysiswouldnecessarilymisscaseswherearraysseem
tohavediÔ¨ÄerenttypesoflengthsindiÔ¨Äerentcontexts. Weassume
this is the result of analysis imprecision, rather than a violation
of key assumption 1: library writers treat arrays as though they
have only a single type of length. This allows us to report length
annotations where a sound analysis could not. A complete analysis,
on the other hand, would necessarily retrieve some incorrect length
information, which would produce incorrect bindings. We strive to
avoidproducingincorrectannotations,andsocannottakeacomplete
approach, either.
Therefore,wetakeanapproachwhichisneithersoundnorcom-
plete, and thus we may produce both false positives and false
negatives. RecallfromSection4.6thateacharrayhasamostgen-
eral correct annotation. Consider a false positive to be a function
argument annotation identifying an ‚Äúincorrect‚Äù length: i.e., any
annotationbutthemostgeneralcorrectone. A falsenegative failsto
attribute the correct annotation to a function argument that requires
an annotation. Note that a single annotation can be both a false
positiveandafalsenegativeifitidentiÔ¨Åesanincorrectannotation
in place of the correct one. For example, if an array has length
Ô¨Åxed (8), reporting length Ô¨Åxed (7)both identiÔ¨Åes an incorrect
annotationandfailstoidentifyacorrectannotation. Inonesense,
this is the harshest method of assessing false positives and falsenegativesthat we coulduse. Notonlydo we failto award‚Äúpartial
credit‚Äù forinferring truelengthproperties thatare lessgeneral, but
this incurs a false positive in addition to a false negative.
4.8.2 Sources of False Positives and False Negatives
Evenwithanunsoundandincompleteapproach,itisimportant
to clearly identify the kinds and causes of potential errors, and to
mitigate these risks as much as is practical. We Ô¨Ånd both false
positives and false negatives resulting from our tool, but false
positivesaremuchlesscommon. Weintentionallydesignedourtool
toproducemorefalsenegativesthanfalsepositives: afalsenegative
creates a binding that is less idiomatic but still usable, whereas a
falsepositivecanrenderanAPIunusable. Suchannotationsmay,for
example, unnecessarily hide arguments or overly restrict their types.
Our analysis is subject to imprecision resulting from pointer
aliasing, as we do not perform an alias analysis. This could result
inafalsepositiveifthearrayhasinconsistenttypesacrossaliases
(violatingkeyassumption1). Forexample,iftheÔ¨Årst y 1elements
areaccessedfrom array,andthe ythelementisaccessedonlythrough
analiasof array,wewouldincorrectlyreportthat arrayhassymbolic
lengthy. However,inpractice,wehavenotseensuchfalsepositives,
andbelievethistobeunusual. Thus,theadditionaltimeandspace
overheadrequiredforaliasdetectionisnotmerited. Aliasingalso
couldtheoreticallyresultinfalsenegatives,ifelementsfrom array
are accessed only via an alias. In that case, we will report that no
length information is available for array. This, also, has proved to
be rare in practice.
Wemayincurfalsenegativesinthepresenceofvariadicfunctions,
whichdonotacceptaÔ¨Åxednumberofarguments. Thelengthofa
variadiclistofargumentsisusuallydeterminedbyaformatstring.
While many arguments passed into variadic functions like printfare
strings, symbolic-length arrays, or Ô¨Åxed-length arrays, many are not.
It is possible to identify variadic arguments, but it is not possible to
determine their types without examining the format string, which
contains more complex type information than we support. Variadic
arguments serve as an extreme example of treating arguments as
havingdiÔ¨Äerenttypesdependingoncontext,sokeyassumptions1
and 2 do not apply.
Ourlastcausesoffalsepositivesandnegativesarisefromexternal
sources. SRA itself is unsound and incomplete, which may cause
ustoproducefalsepositivesandnegatives. Ourapproachcanalso
beincompleteiftheonlyevidenceforanargument‚Äôslengthisina
call to an external library function, whose code is not available to
analyze. Inthatcase,weallowtheusertoprovideasinputasetof
hand-created annotations.
5. EXPERIMENTAL EV ALUATION
WehaveimplementedtheanalysesdescribedinSection4using
LLVM 3.7 [ 12]. Our implementation focuses on the special case
where the sentinel value is a zero of any type, as this is the standard
way to represent C strings. This is motivated by our target for
language bindings, GObject-Introspection, which currently only
has annotation-level support for zero-terminated arrays. Our tool
operates on LLVM bitcode, and therefore is easily incorporated into
any Clang-compatible build or analysis tool chain. All experiments
wererunonone 2:67 GHzCPUofadesktopworkstationwith 24 GB
of RAM running Red Hat Enterprise Linux 7.
5.1 Test Subject Selection
We have evaluated our tool on the following libraries:
gckv3.18implementsPKCS#11,aformofpublickeycryp-
tography [6].
467Table 1: Library details. KLoC measures thousands of lines of source code, estimated with SLOCCount [23].
Number of Function Arguments
Name KLoC Number of Functions All Symbolic Fixed Sentinel Analysis Time (sec)
glib 151 1 ;813 4 ;092 77 12 483 211
gio 188 4 ;948 11 ;506 66 11 1 ;052 286
gck 15 247 719 26 0 12 7
telepathy-glib 151 917 2 ;016 25 0 155 275
libgit2 151 3 ;668 8 ;750 89 16 948 151
libssh2 39 349 1 ;266 125 6 81 14
Table 2: Rates of correct and incorrect analysis results in complete libraries
Rate of True Positives Rate of False Positives
Name Symbolic Fixed Sentinel Symbolic Fixed Sentinel
glib 0:7143 0 :9167 0 :8903 0 :0002 0 :0005 0 :0044
gio 0:8030 0 :7273 0 :7814 0 :0000 0 :0000 0 :0061
libgit2 0:7191 0 :8125 0 :8565 0 :0001 0 :0006 0 :0003
libssh2 0:7280 0 :8333 0 :8765 0 :0000 0 :0047 0 :0000
Arithmetic Mean 0:7411 0 :8224 0 :8512 0 :0001 0 :0015 0 :0027
giov2.46.2 is a virtual Ô¨Åle systems API [7].
glibv2.46.2 provides a framework for C libraries, including
utility functions and a struct-based object system [8].
libgit2v0.23.4 implements the Git core methods as a linkable
library [14].
libssh2v1.6.1isanimplementationoftheSSH2protocolin
an extensible C framework [10].
telepathy-glib v0.23.3 is a D-Bus framework for real-time
communication [22].
Most of these libraries are part of the GNOME Project [ 5] and
already have GObject-Introspection annotations, authored by the
librarywriters. Thenotableexceptionsare libgit2andlibssh2,neither
ofwhichisaGNOMElibrary. Theversionof libgit2weanalyzedhad
no GObject-Introspection annotations, though annotations appeared
in a later release. libssh2has no GObject-Introspection annotations
as of this writing, and no language bindings to our knowledge.
TheselibrariesassessourtechniqueoncodethatwasnotspeciÔ¨Åcally
writtenwiththeseannotationsinmind. Table1providesmoredetails
on our test subjects. To determine ground truth on the number of
symbolic-length, Ô¨Åxed-length, and sentinel-terminated arrays, we
manually inspected each library. Identifying whether a C argument
is an array or a pointer is a diÔ¨Écult task in its own right, and not
one we attempt. We therefore do not report the number of array
arguments in each function. All arguments that our tool infers to
possessalengthpropertymustbearrays: however,somearraysmay
not follow any of the length types we detect.
For each library, we made a reasonable attempt to identify and
analyze any dependencies, whether manually or with the help of
our tool. We were unable to analyze most of libc, due to many
importantfunctionsbeingimplementedinassemblyratherthanC.
Therefore,wemanuallyselectedseveralsuchimportantfunctions
and annotated them by hand. When analyzing each library, we
passed along information for all of its dependencies as generated by
our tool, and additionally included our hand-crafted annotations for
libc. Thus,somedependencyinformationmaybeincorrectwhereourtoolisimprecise. Wenotethetruepositiverateandfalsepositive
rateofeachtypeoflengthinformationinTables2and3. Thetrue
positiveratemeasurestheratioofcorrectannotationsproducedto
correct (and most general) annotations, whether produced or not.
The false positive rate measures the ratio of incorrect annotations
produced to arguments which should not have that annotation. A
higher true positive rate and lower false positive rate is desirable,
though we prioritize a lower false positive rate per Section 4.8.2.
5.2 Full Annotation Results
Forgio,glib,libgit2, andlibssh2, we manually annotated the
full library to use as a baseline for comparison. This provides a
completepictureofhowmanysentinel-terminated,symbolic-length,
and Ô¨Åxed-length arrays are in the libraries, but costs signiÔ¨Åcant
time. Indeed, our experience indicates that libraries comparable
in size to these take upwards of eight hours to manually annotate.
Table 2 summarizes our Ô¨Åndings. Over each of the full libraries, we
achieve a minimum true positive rate of 0:7for each type of length
property, indicating that we produce at least 70%of the correct
annotations. Every false positive for sentinel-terminated arrays
belongstoaclassofproblemsdiscussedfurtherinSection5.4. In
brief, each arises from a function that accepts an array argument
and a length argument, but treats the array as NUL-terminated if the
length is negative. Recall from Section 4.4 that we could introduce
falsepositivesifalibrarywriterevermixesconstantandsymbolic
indexes in a Ô¨Åxed-length array. However, only one library in our
suite contains such code, libssh2, and manual inspection veriÔ¨Åes the
two occasions when this occurs as truly symbolic-length arrays.
Ourresultsfor libssh2areofparticularinterest. libssh2appears
to have been built without awareness of GObject-Introspection
annotations. We see no evidence that polyglot interoperability
wasfactoredintothislibrary‚Äôsdesigninanyway. Yetouranalysis
performsaboutaswellhereasontheother(hand-annotated)libraries.
Furthermore, our true positive rate for sentinel-terminated arrays
is signiÔ¨Åcantly higher than for most other libraries. These results
indicate that our tool can support even libraries that were not
built with language bindings in mind. Our approach can help
developers retroÔ¨Åt GObject-Introspection bindings onto existing
libraries without requiring analysis-friendly design from the start.
468Table 3: Rates of correct and incorrect analysis results in external library APIs. gckandtelepathy-glib use no Ô¨Åxed-length arrays.
Rate of True Positives Rate of False Positives
Name Symbolic Fixed Sentinel Symbolic Fixed Sentinel
gck 0:8077 ‚Äî 1:0000 0 :0000 ‚Äî 0:0014
glib 0:7222 1 :0000 0 :8904 0 :0004 0 :0000 0 :0056
gio 0:6875 0 :5000 0 :7051 0 :0000 0 :0000 0 :0010
telepathy-glib 0:8800 ‚Äî 0:6839 0 :0000 ‚Äî 0:0032
telepathy-glib + hints 0:8800 ‚Äî 0:7806 0 :0000 ‚Äî 0:0037
Arithmetic Mean 0:7955 0 :7500 0 :8120 0 :0001 0 :0000 0 :0030
5.3 API Results
For libraries with existing GObject-Introspection language bind-
ings(gioandglib)andtheremaininglibraries( gckandtelepathy-glib ),
weexaminetheannotationsalreadypresentinthesourcecode. These
areproducedonlyforthesubsetofthelibraryintendedtobeexposed
to the end user in the form of an API. We manually examined those
functions in the API where our tool produced a diÔ¨Äerent annotation
thanthehumandid. Thismethodofdetermininggroundtruthisless
precise than manually determining the correct annotations for every
function argument in the library, but consumes much less time, and
allowsustodeterminehowwellweperformonthepartsofalibrary
that ultimately require the annotations: the API.
5.3.1 Automated Analysis
Table 3 shows our results on these libraries. For the most part,
our automated approach does quite well. Rates for symbolic lengths
generally improve upon those for complete libraries in Table 2.
The notable exception is the giolibrary, which exposes only eight
symbolic-lengtharraysinitspublicAPI. Our 67%truepositiverate
forsentinel-terminatedarraysin telepathy-glib islikewiseanomalous.
Thisis duetoheavy useofvariadicfunctions within telepathy-glib .
As discussed in Section 4.8.2, variadic functions pose a problem for
ouranalysis,asthetypeinformationmaybedependentonthecontent
ofaformatstring. Ourtoolhasnowayofreasoningabouthowto
extracttypeinformationfromformatstrings. Thus,weareunable
toannotateanyargumentswhosetypeinformationisdiscoverable
solely through the use of variadic functions. This accounts for most
incorrectly-analyzedsentinel-terminatedargumentsin telepathy-glib .
Notethatadevelopercouldprovideasetofmanuallyannotated
functionstorecoverfromthissituation. Whenwemanuallyanno-
tated ten functions that call variadic functions, the results improved
signiÔ¨Åcantly (see the ‚Äú telepathy-glib + hints‚Äù row of Table 3). More
manual annotations could provide a larger beneÔ¨Åt, but even this
amount improves upon our results. GObject-Introspection anno-
tations are basedon Ô¨Åxed argument positions, andcannot support
annotations of variadic arguments, but the library author could
annotate common functions that make calls to variadic functions.
5.3.2 Human Errors
We motivated this work with the claim that creating bindings
manually is tedious and error-prone. The numerous mistakes we
found in human-authored annotations support thisclaim. Humans‚Äô
errors are qualitatively diÔ¨Äerent from those produced by our tool.
Understanding this mismatch helps illustrate how our approach can
complement human eÔ¨Äorts.
Errors by human annotators seem to stem from inattention or
misinterpretation of functions in dependencies. One such mistake is
reportingthatanargumenthasasymboliclengthwhenitisonlyever
passedtoafunctioncallinsomedependency,whichdoesnottreat
theargumentthisway. Thishappensespeciallycommonlywhenthestatic inline gboolean
contains_non_ascii ( constgchar ‚àóstr, gint len)
{
constgchar ‚àóp;
for(p = str; len == 1 ? ‚àóp : p < str + len; p++) {
if((guchar) ‚àóp > 0x80)
returnTRUE;
}
returnFALSE;
}
Listing 6: Real-world function with inconsistent treatment of
an argument‚Äôs length, taken from glib
namesoftheargumentsaremisleadinglysuggestiveofasymbolic
lengthrelationshipbetweentwoarguments. Thesemistakesoccur
even when the documentation does not suggest that the writers of
thesedependenciesconsideredthemtobesymbolic-length. Inthese
cases, it is likely that the library writer did not Ô¨Ånd it worth the time
totrackdownthesource-levelannotationsineachdependencytosee
what the length type of the argument actually is. Rather, they relied
on the nameof the argument. Quantitatively, we cansee in Table 4
thathumansperformmarginallybetteroverall,buthaveahigherrate
of false positives for both symbolic-length and sentinel-terminated
arrays. Humans take much more time to produce these annotations,
while our analysis runs in under Ô¨Åve minutes on each library we
considered. One bug that we detected in the library giowas Ô¨Åxed
since the time we ran our analysis. We have submitted a bug report
for the remainder of the human errors our analysis detected in the
librarygio, which is awaiting action by the developers. 1
5.4 Empirical False Positives
Mostofourfalse positivesarisewhenanarrayexhibitsmultiple
length properties (violating key assumption 1), particularly in the
symbolic-length case. For example, in Listing 6, stringis treated as
sentinel-terminated by NULwhenlenis 1, and as having symbolic
lengthlenotherwise. Thisappearsquiteofteninreal-worldcode,ev-
identlyforeÔ¨Éciency;ifthecalleralreadyknowsthestring‚Äôslength,it
canpassthatdowntoavoidrecomputingitinthelibrary. Technically,
thesefunctionscanbeusedbycharacterarraysthatarenotstringsas
well,suchasarrayswithembedded NULs. Byproducingabinding
that only accepts strings, we remove functionality. Because our
analysis is not path sensitive, we are unable to identify that stringis
treated as NUL-terminated only under some circumstances. We see
thatstringistreatedassentinel-terminatedwhenitisusedinthecall
1https://bugzilla.gnome.org/show_bug.cgi?id=765063
469Table 4: Rates of correct and incorrect human-authored annotations in external library APIs
Rate of True Positives Rate of False Positives
Name Symbolic Fixed Sentinel Symbolic Fixed Sentinel
gck 0:8846 ‚Äî 1:0000 0 :0252 ‚Äî 0:0028
telepathy-glib 0:8800 ‚Äî 0:9484 0 :0045 ‚Äî 0:0620
Arithmetic Mean 0:8823 ‚Äî 0:9742 0 :0148 ‚Äî 0:0324
Table 5: Change in sentinel-terminated argument counts after
adding structure information analysis
NameAnalysis
Time (min)New True
PositivesNew False
Positives
gio >5;760 ‚Äî ‚Äî
glib 508 0 97
libgit2 2;376 5 10
libssh2 7 3 3
tostrlen, and infer that it must be sentinel-terminated, although the
strlencallisconditionalonthevalueof len. Wechosetocombine
analysis results using our Hasse diagram in Figure 1 in order to
combat this issue. We eliminate many of these false positives by
combining our sentinel-terminated and symbolic-length analyses,
and produce only the more general symbolic-length annotation. We
are unableto eliminate these falsepositives only whenour analysis
fails to detect that the array may have a symbolic length.
5.5 Structure Information Results
We extended our implementation to analyze structure Ô¨Åelds as
described in Section 4.7. We only found diÔ¨Äerent results in the
sentinel-terminated case, so we just report these results. Table 5
showsthatthis doesimprovesomecases,allowingusto discovera
few more sentinel-terminated arrays. However, the sheer number
of function arguments to annotate causes the global impact of these
improvementstobequitemodest,andweintroducenewfalseposi-
tivesasaresultofstructureÔ¨Åeldsbeingtreatedinconsistentlyacross
several functions. There do not appear to be many arrays whose
length information could be recovered by examining structures.
Further, the analysis now has far more work to do, making perfor-
mance a serious concern. We were unable to completely analyze all
ofthelibrariesinSection5.1duetotimeconstraintsanddependency
information. Most of the GNOME libraries depend on gliband
gio.gioanalysistimed outafterfourdays. Therefore, wecouldnot
analyzeanylibrariesdependenton gioandobtaincomparableresults
toourotherexperiments. Whilefurtherperformancetuningofour
implementation is possible, the results (see Table 5) suggest that the
marginal beneÔ¨Åts may not make structure analysis worthwhile.
6. FUTURE WORK
Whileourcurrentapproachsubstantiallyreducesthemanualwork
load of generating high-quality bindings, further improvements are
possible. Onepossiblefuturedirectionistoconsideranyclientcode
thatmaybeavailable. Thiswouldbeoptionalinputthatwouldallow
the user to supply representative client code that uses the library.
Onesourceoftheclientcodemightbethelibraryitself,whichoften
call into its own public API. This analysis would be substantially
diÔ¨Äerent from the one described here, as it could take allocation
points into account in the style of SALInfer [11].We could also expand our analyses to handle function pointers.
Function pointers may be passed as callbacks into a C function, and
the length idiom used by array arguments to the function may be
partiallyorcompletelydependentonthedeÔ¨Ånitionofthecallback.
In order for to analyze such functions, we would need to analyze all
the callbacks passed to such functions within a library.
We have been using GObject-Introspection annotations as our
ultimate analysis target. This ensures that our analysis Ô¨Åndings
can be put to good use, but also limits how much detail we try to
recover. We could track other kinds of length information, such
as determining when a function accepts a start pointer and end
pointer. We could also infer predicated type information, which
determinesthelengthinformationofaparticularargumentgiventhe
values of other arguments. For example, a predicated description
ofstringfrom Listing 6 would state that it is sentinel-terminated by
NULiflenis 1, or has symbolic length lenotherwise. GObject-
Introspectioncanneitherexpressnorusearraylengthssuchasthese,
butiftheyarecommonenoughinpractice,thatmayjustifyextending
GObject-Introspection to include them as well.
7. CONCLUSIONS
We have presented a system for automatically inferring developer
intentaboutarrayargumentlengths. Thistaskbearssomesimilarity
tothatofcheckingthatallarrayaccessesarememorysafe. However,
ourfocusonlanguagebindingsmandatesadiÔ¨Äerentdesign,tuned
to allow diÔ¨Äerent kinds of imprecision and to use heuristics that
would be unacceptable when checking for memory safety violations.
Instead of Ô¨Ånding mistakes, we are looking for trends in the kind of
length the library developer expects.
EmpiricalevaluationshowsthatweproducesigniÔ¨Åcantlyfewer
falsepositivesthanexistinghand-writtenannotations. Ourresults
alsoindicatethatourtoolperformswellevenwithlibrariesthatwere
not built with the goal of being accessible to other languages.
The challenge of producing high-quality bindings is large. Our
inferredarraylengthsprovideanimportantpieceofthatlargerpuzzle.
In cooperation with prior work by others, these analyses begin to
form a comprehensive suite that substantially reduces the manual
eÔ¨Äort needed to cross language boundaries. In so doing, we liberate
polyglot programmers to mix and use the best tools, languages, and
libraries available.
8. ACKNOWLEDGMENTS
ThisresearchwassupportedinpartbygrantsfromCAPEsand
CNPq;DARPAMUSE awardFA8750-14-2-0270;andNSF grants
CCF-0953478,CCF-1217582,CCF-1318489,andCCF-1420866.
Opinions, Ô¨Åndings, conclusions, or recommendations expressed
herein are those of the authors and do not necessarily reÔ¨Çect the
views of the sponsoring agencies. We would like to thank Peter
Ohmann, forinsightful comments andcontributions to theideas in
this paper.
4709. REFERENCES
[1] P. Alves, F. Gruber, J. Doerfert, A. Lamprineas, T. Grosser,
F. Rastello, and F. M. Q. a. Pereira. Runtime pointer
disambiguation. In Proceedings of the 2015 ACM SIGPLAN
International Conference on Object-Oriented Programming,
Systems, Languages, and Applications , OOPSLA 2015, pages
589‚Äì606, New York, NY, USA, 2015. ACM. . URL
http://doi.acm.org/10.1145/2814270.2814285.
[2] D. M. Beazley. Swig: An easy to use tool for integrating
scripting languages with c and c++. In Proceedings of the 4th
Conference on USENIX Tcl/Tk Workshop, 1996 - Volume 4 ,
TCLTK‚Äô96, pages 15‚Äì15, Berkeley, CA, USA, 1996. USENIX
Association. URL
http://dl.acm.org/citation.cfm?id=1267498.1267513.
[3] D. Dhurjati, S. Kowshik, V. Adve, and C. Lattner. Memory
safety without runtime checks or garbage collection. In
Proceedings of the 2003 ACM SIGPLAN Conference on
Language, Compiler, and Tool for Embedded Systems , LCTES
‚Äô03, pages 69‚Äì80, New York, NY, USA, 2003. ACM. . URL
http://doi.acm.org/10.1145/780732.780743.
[4] M. Furr and J. S. Foster. Checking type safety of foreign
function calls. ACM Trans. Program. Lang. Syst. , 30(4):
18:1‚Äì18:63, Aug. 2008. . URL
http://doi.acm.org/10.1145/1377492.1377493.
[5] The GNOME Project. GNOME, Nov. 2015. URL
https://www.gnome.org/.
[6] The GNOME Project. Gck library reference manual, Oct.
2015. URL https://developer.gnome.org/gck/3.18/.
[7] The GNOME Project. GIO reference manual, Nov. 2015.
URL https://developer.gnome.org/gio/2.46/.
[8] The GNOME Project. GLib reference manual, Nov. 2015.
URL https://developer.gnome.org/glib/2.46/.
[9] The GNOME Project. GObject-Introspection Annotations,
June 2015. URL https://wiki.gnome.org/Projects/
GObjectIntrospection/Annotations.
[10] S. Golemon, M. Gusarov, The Written Word, Inc., E. Fant,
D. Stenberg, and S. Josefsson. libssh2, Oct. 2015. URL
http://www.libssh2.org/.
[11]B. Hackett, M. Das, D. Wang, and Z. Yang. Modular checking
for buÔ¨Äer overÔ¨Çows in the large. In Proceedings of the 28th
International Conference on Software Engineering , ICSE ‚Äô06,
pages 232‚Äì241, New York, NY, USA, 2006. ACM. . URL
http://doi.acm.org/10.1145/1134285.1134319.
[12]C. Lattner and V. Adve. LLVM: A compilation framework for
lifelong program analysis & transformation. In Proceedings of
the International Symposium on Code Generation and
Optimization: Feedback-directed and Runtime Optimization ,
CGO ‚Äô04, pages 75‚Äì, Washington, DC, USA, 2004. IEEE
Computer Society. URL
http://dl.acm.org/citation.cfm?id=977395.977673.
[13]W. Le and M. L. SoÔ¨Äa. ReÔ¨Åning buÔ¨Äer overÔ¨Çow detection via
demand-driven path-sensitive analysis. In Proceedings of the7thACMSIGPLAN-SIGSOFTWorkshoponProgramAnalysis
for Software Tools and Engineering , PASTE ‚Äô07, pages 63‚Äì68,
New York, NY, USA, 2007. ACM. . URL
http://doi.acm.org/10.1145/1251535.1251546.
[14] The libgit2 contributors. libgit2, Oct. 2015. URL
https://libgit2.github.com/.
[15]S. Lu, S. Park, C. Hu, X. Ma, W. Jiang, Z. Li, R. A. Popa, and
Y. Zhou. Muvi: Automatically inferring multi-variable access
correlations and detecting related semantic and concurrency
bugs.SIGOPS Oper. Syst. Rev. , 41(6):103‚Äì116, Oct. 2007. .
URL http://doi.acm.org/10.1145/1323293.1294272.
[16] S. Nagarakatte, J. Zhao, M. M. Martin, and S. Zdancewic.
SoftBound: Highly compatible and complete spatial memory
safety for C. In Proceedings of the 30th ACM SIGPLAN
Conference on Programming Language Design and
Implementation , PLDI ‚Äô09, pages 245‚Äì258, New York, NY,
USA, 2009. ACM. . URL
http://doi.acm.org/10.1145/1542476.1542504.
[17]H. Nazar√©, I. MaÔ¨Ära, W. Santos, L. Barbosa, L. Gonnord, and
F.M.Quint√£oPereira. Validationofmemoryaccessesthrough
symbolic analyses. SIGPLAN Not. , 49(10):791‚Äì809, Oct.
2014. . URL http://doi.acm.org/10.1145/2714064.2660205.
[18] G. C. Necula, J. Condit, M. Harren, S. McPeak, and
W. Weimer. CCured: Type-safe retroÔ¨Åtting of legacy software.
ACM Trans. Program. Lang. Syst. , 27(3):477‚Äì526, May 2005.
. URL http://doi.acm.org/10.1145/1065887.1065892.
[19] T. Ravitch and B. Liblit. Analyzing memory ownership
patterns in C libraries. In P. Cheng and E. Petrank, editors,
InternationalSymposiumonMemoryManagement,ISMM‚Äô13,
Seattle, WA, USA - June 20 - 20, 2013 , pages 97‚Äì108. ACM,
2013. . URL http://doi.acm.org/10.1145/2464157.2464162.
[20]T. Ravitch, S. Jackson, E. Aderhold, and B. Liblit. Automatic
generation of library bindings using static analysis. In
M. Hind and A. Diwan, editors, Proceedings of the 2009 ACM
SIGPLAN Conference on Programming Language Design and
Implementation, PLDI 2009, Dublin, Ireland, June 15-21,
2009, pages 352‚Äì362. ACM, 2009. . URL
http://doi.acm.org/10.1145/1542476.1542516.
[21] R. Rugina and M. C. Rinard. Symbolic bounds analysis of
pointers, array indices, and accessed memory regions. ACM
Trans. Program. Lang. Syst. , 27(2):185‚Äì235, Mar. 2005. .
URL http://doi.acm.org/10.1145/1057387.1057388.
[22] The Telepathy Project. telepathy, Aug. 2014. URL
http://telepathy.freedesktop.org/.
[23] D. A. Wheeler. SLOCCount, June 2015. URL
http://www.dwheeler.com/sloccount/.
[24] T. Wies, V. Kuncak, K. Zee, A. Podelski, M. Rinard, T. Wies,
V. Kuncak, K. Zee, A. Podelski, and M. Rinard. Verifying
complex properties using symbolic shape analysis. In In
Workshop on heap abstraction and veriÔ¨Åcation , 2007.
471