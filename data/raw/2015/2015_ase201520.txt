String Analysis of Android Applications
Justin Del V ecchio, Feng Shen, Kenny M. Yee, Boyu Wang, Steven Y . Ko, Lukasz Ziarek
University at Buffalo, The State University of New Y ork
{jmdv, fengshen, kennyyee, bwang24, stevko, lziarek}@buffalo.edu
Abstract —The desire to understand mobile applications has
resulted in researchers adapting classical static analysis tech-
niques to the mobile domain. Examination of data and controlﬂows in Android apps is now a common practice to classifythem. Important to these analyses is a ﬁne-grained examinationand understanding of strings, since in Android they are heavilyused in intents, URLs, reﬂection, and content providers. Rigorousanalysis of string creation, usage, and value characteristics offersadditional information to increase precision of app classiﬁcation.
This paper shows that inter-procedural static analysis that
speciﬁcally targets string construction and usage can be used toreveal valuable insights for classifying Android apps. To this end,we ﬁrst present case studies to illustrate typical uses of stringsin Android apps. We then present the results of our analysis onreal-world malicious and benign apps. Our analysis examines howstrings are created and used for URL objects, Java reﬂection, andAndroid intents, and infers the actual string values used as muchas possible. Our results demonstrate that string disambiguationbased on creation, usage, and value indeed provides additionalinformation that may be used to improve precision of classifyingapplication behaviors.
I. I NTRODUCTION
Android is one of the most popular platforms for mobile
computing. Countless numbers of devices have been released
internationally and Android’s ofﬁcial app store, Google Play,contains more than a million apps. However, along with thispopularity comes an increase in malicious apps. It was reportedin 2013 that 97% of all mobile malware targeted Android [1]and this number has been sharply growing.
This increase in malware has led to the creation of many
static analysis tools for identifying malicious Android apps. Byidentifying malware prior to its release, these tools can offerenhanced security and privacy for end users who downloadand use Android apps. Many different types of analyses haveproven to be useful such as data and control ﬂow analysis [2,3, 4], call graph analysis [5], and sensitive API analysis [6, 7].These static analysis approaches provide awareness of potentialharms to users.
In this paper, we show that analysis of strings and how
they are created in Android apps can be useful in identifyingmalicious apps. The usefulness of string analysis is derivedfrom two aspects. First, Android apps heavily rely on strings inorder to perform potentially sensitive or malicious tasks, suchas reading contact information and device IDs, accessing stor-age, calling hidden APIs, and using remote servers. Second,string analysis is complementary to other types of analysis, andcontributes to improving their precision. For example, data andinformation ﬂow analysis can beneﬁt from additional stringanalysis if there is a ﬂow from the code that reads the device IDto the code that sends it out to a remote server. By employingadditional string analysis, data and information ﬂow analysiswill have a chance to differentiate which remote server theﬂow is intended for, and if it should be considered malicious.
In order to show the usefulness of string analysis, we
report our preliminary results in this paper. Our string analysisfocuses on analyzing Android-speciﬁc uses of strings; these in-clude strings for intents (Android’s messaging data structure),Java reﬂection, and network URLs. Our goal for analyzingthese strings is three-fold. First, we aim to verify if the valueof a string object indicates its intended use. For example, aURL, a class name used in reﬂection, or an obfuscated stringcan indicate the purpose of the code that uses them. Second,we aim to verify if the provenance of a string indicates itsintended use. For example, use of strings that come fromexternal sources such as conﬁguration ﬁles may be an attemptat subterfuge. Third, we aim to verify if construction of stringsprovides information on the complexity required in creation ofstrings, for example a multi-part string for a URL. Analysisof strings in the context of these types of characteristicscan provide a wealth of information useful in improvingthe precision of ﬂow analysis, especially with respect to theclassiﬁcation of malicious versus benign activities.
This paper has the following three contributions:
•We identify string analysis as an under-explored but stillquite useful type of analysis for Android apps.
•We present case studies that illustrate typical uses ofstrings in Android apps. These case studies also demon-strate the potential usefulness of string analysis.
•We report our preliminary results for URL, Java reﬂec-tion, and Intent string analysis. We have analyzed 517benign apps from Google Play and 1042 malicious appsfrom the MalGenome project [8]. We believe that ourresults provide enough evidence that string analysis canprovide additional, deciding features that can improveﬂow disambiguation.
The remainder of the paper is organized as follows. In
Section II we present motivating examples for URLs, AndroidIntents, and Java reﬂections. It identiﬁes how strings are usedin such operations and the value added of string analysis aswell as the inherent difﬁculties of the approach. We presentthe implementation and related algorithms in Section III.Preliminary results, validation, and threats against validityare presented in Section IV. Testing of the algorithm wasperformed on a corpus of both malicious and benign apps.Analysis of aggregate results identiﬁes drastic differencesbetween the employment of strings in operations for thesetwo types of apps. A deep dive for a selected set of resultsis provided. The studies reveal pertinent details about howmalicious apps are engineered and how they can be identiﬁed.Related work and future directions are presented in Section Vand Section VI, respectively.
2015 30th IEEE/ACM International Conference on Automated Software Engineering
978-1-5090-0025-8/15 $31.00 © 2015 IEEE
DOI 10.1109/ASE.2015.20680
II. M OTIV A TION
In Android apps strings are used pervasively to uniquely
identify Android-speciﬁc constructs, to specify ﬁles and net-
work addresses that an app uses, as well as to enumerateclasses and methods invoked dynamically through the Javareﬂection APIs. Understanding how strings are constructedin the code base as well as the concrete values the stringscontain is vital to the understanding of the apps themselves.Consider the following examples taken from real world apps,both malicious and benign.
A. URLs
Many developers make their data publicly available on
Internet servers and provide an interface for extracting slices
or sections of that data. URLs are heavily used in Android
apps to communicate between clients and servers. Some appsgather users’ phone data and send it to remote servers torequest service content. Malware also takes advantage of thispattern to perform harmful actions. In order to protect users’privacy, many analyses are currently tracking what data is sentoff the phone via the Internet. This, however, is not sufﬁcientbecause it is not trivial to distinguish malicious behaviorfrom benign behavior. To differentiate malicious and benignbehaviors, we must not only track what data is, but also where
data is sent and how. To do this, an analysis engine must be
able to track network URLs. The following example gives us
a brief idea on how a URL object is constructed and used in
an Android app.
private void execTask(){
...
str2 = "http://" + Base64.encodebook(
"2maodb3ialke8mdeme3gkos9g1icaofm",6 ,3 )+
"/mm.do?imei=" +this.imei;
...
httpString = str2 + "&mobile=" +this.mobile;
...
http=BaseAuthenicationHttpClient
.getStringByURL(httpString);
...
}
Code 1. Android URL Construction Example
In the example, the app ﬁrst creates a base URL string
and appends additional data ( e.g.,IMEI, Phone Number)t o
construct the complete URL object. Finally, the app sends the
string out via a HttpClient. Even though it is common to
append data to a URL string in benign apps, there are notable
differences in the above example. One key difference is theobfuscation (how) of the IP address of the URL (where) via
the encodebook method. Malicious apps show a far greater
tendency than benign apps to obfuscate the IP component.In the example, the URL object is also used to exﬁltrate the
mobile number and IMEI (what), operations benign apps do
not perform.
B. Android Intents
Intent is one of the most heavily used Inter-Component
Communication (ICC) mechanisms in Android. Android
Intent provides a nice way for benign apps to communicate,but Android malware can also take advantage of this toperform malicious behaviors. Researchers have spent agreat effort on analyzing Intent for Android ICC [9, 10].
To understand how an Android app works, we mustdiscover the relation of components connected by intents. Thefollowing code example shows how intents are used in an app.
public void onReceive(Context context,Intent intent){
if(intent.getAction().equals(
"android.intent.action.BOOT_COMPLETED")){
intent = new Intent("android.intent.action.RUN");
intent.setClass(context, zjService.class);
context.startService(intent);
}
...
while (true){
if(!intent.getAction().equals(
"android.provider.Telephony.SMS_RECEIVED"))
break;
intent = intent.getExtras();
...
msg[i] =
SmsMessage.createFromPdu((byte[])intent[i]);
this.sms_code = msg[i].getOriginatingAddress();
this.sms_body = msg[i].getDisplayMessageBody();
WriteRec(context, "zjsms.txt", this.sms_code +
"#" +this.sms_body);
...
}
}
...
private void uploadAllFiles(){
...
upload.uploadFile("http://"
+ getKeyNode("dom","dom_v")
+"/zj/upload/UploadFiles.aspx?askId=1&uid="
+ getKeyNode("uid","uid_v"),
"/com.creativemobi.DragRacing/files/zjsms.txt");
...
}
Code 2. Android System Intent Example
This example contains three types of intents. Firstly, the
app catches the system BOOT_COMPLETED intent and starts its
service zjService. Additionally, it monitors two other system
intents: SMS and OUTGOING_CALL. We only show the SMS
intent in the example. As observed from the example, eachintent has its own unique string which the program uses todifferentiate intents. There might be a large number of intentscontained in a single app. Thus, it is important to not onlyidentify all intents, but to infer connections between differentprogram components in order to understand the behavior of theapp. This is especially important for Android because manyAndroid malware apps take advantage of system intents tostart malicious code. The above example is from one of theknown Android malware. By monitoring the system intents,the app catches the incoming SMS andPhone Call and writes
to local ﬁles. Later, it uploads these ﬁles to a remote serverin the zjService. To understand the complete execution ﬂow
above, we must discover all the strings that deﬁne an intentﬁrst, and then build up the correct ﬂow of the program, whichis needed for future analysis (e.g., data ﬂow analysis).
681C. Java Reﬂection
Reﬂection is commonly used by programs to provide
runtime support and is used pervasively in Android. Since
reﬂection is a dynamic feature, it is usually not handledby static analyses. However, precision of static analysis iscritically hurt if reﬂection is ignored completely. In this case, itis important to ﬁnd the reﬂection statically deﬁned by strings.The following Jimple (intermediate representation used bySoot and our tool) code example shows how reﬂection is usedin Double Twist, a popular music player available in GooglePlay. Due to space constraints, we refer to V all ´ee-Rai et al. [11]
for more details on Soot and Jimple.
$r4 = <com.doubleTwist.util.l: String
a(String)>("c2VuZEJpbGxpbmdSZXF1ZXN0\n");
<com.doubleTwist.androidPlayer.lr: String i> = $r4;
$r4 = <com.doubleTwist.util.l: String
a(String)>("c2VuZEJpbGxpbmdSZXF1ZXN0\n");
$r5 = <java.lang.Class: Class
forName(String)>($r4);
$r2 = <com.doubleTwist.androidPlayer.lr: String i>;
$r6 = newarray (Class)[1];
$r6[0] = class "android/os/Bundle";
$r7 = $r5.<Class: reflect.Method
getDeclaredMethod(String,Class[])>($r2, $r6);
$r8 = <com.doubleTwist.audio.AudioVolumeService:
Object e()>();
$r9 = newarray (Object)[1];
$r9[0] = $r3;
$r8 = $r7.<java.lang.reflect.Method: Object
invoke(Object,Object[])>($r8, $r9);
Code 3. Android Reﬂection Example
As observed above, the app loads a reﬂection object using
an encrypted string. Then, it fetches the wanted method fromreﬂection by using another encrypted string and executes it bycalling invoke. Clearly, it performs some abnormal actions as
it obfuscates the class and method names loaded via reﬂection.This is one of the common patterns in malware we haveobserved during our string analysis.
III. I
MPLEMENTA TION
Our string analysis prototype is being built into BlueSeal, a
data ﬂow analysis framework we have developed [3]. It is pub-licly available, along with data sets, experimental results, andplotting scripts for download at http://blueseal.cse.buffalo.edu.BlueSeal itself is built on the Soot [11] bytecode optimizationframework. Our string analysis runs three phases as follows.
A. Interprocedural Analysis
The ﬁrst phase of our tool gathers relevant information
on strings used in intents, ﬁles, URLs, and Java reﬂection.
This is done through a backward inter-procedural ﬂow analysisoriginating at relevant invoke statements of API calls, whichthe tool takes as input. The analysis itself is mostly standard,but leverages functionality from BlueSeal to recreate theAndroid app’s call graph. The most important feature of ourimplementation is the capability to reconstruct complex strings.That is, it can reconstruct strings built by multiple string-related operations across different methods. This capabilitywould dovetail nicely with other tools such as IccTA [10] thatperforms single method string analysis. Due to the structure ofAndroid apps, not all method calls are in the default generatedcall graph. For more details on call graph reconstruction forAndroid, please refer to our previous work on BlueSeal [3].
B. Abstract Interpretation
The output of our ﬁrst phase is a set of backward ﬂows,
where each ﬂow is represented as a graph starting with a
single root. This root for a backward ﬂow graph is a stringargument used in intents, ﬁles, URLs, or Java reﬂection. Thus,each graph is effectively a backward slice of a program that
consists of the code used to construct a string of interest. Thisgives us an opportunity to analyze the structural properties
of how strings are created and used; we perform an abstractinterpretation over each graph in order to do this. As theresults presented in Section IV show, in many cases thisallows us to generate concrete string literals. Our abstractinterpretation engine understands basic Java string constructionAPIs including the StringBuilder class.
C. String Classiﬁcation
Once a graph is generated, we classify strings into multiple
categories. The goal of classiﬁcation is to provide multipletypes for strings which eventual clustering or disambiguationalgorithms could use to classify a string as benign or malicious.Currently, we classify strings into three categories as follows.
•Plain strings: This category includes strings constructed
using String andStringBuffer classes. These are per-
haps the most frequently used classes to build a string andinclude convenient methods such as replace, append,
andsubstring.
•Derived strings: This category includes strings origi-
nated from sources other than string literals found in thecode. For example, strings originated from toString,
Class.forName, or a string read from a conﬁgurationXML ﬁle all belong to this category.
•Intraprocedural or Interprocedural strings: This cate-
gory identiﬁes if a string is created within a single methodor across multiple methods.
In the future, we plan to test a number of different cate-
gories based on the inferred properties and code characteristicsthat our tool is currently able to extract. We currently countthe number of class and static ﬁelds used in the creationof the string, the number of methods called in the creationof the string, especially where aggregated strings show deepnesting of method invocations to retrieve string parts, andgraph patterns for constructed strings. The latter characteristicoffers the possibility to match obfuscated code against knowngraph patterns to determine likely intent and semantics ofoperations performed.
IV . R
ESULTS
Development and initial validation of the algorithm was
performed using unit test and gold standard Android appsobtained from GitHub. Unit test APKs were designed to testthe validity of the inter-procedural algorithm, especially withrespect to chaining string creation graphs for parameter andreturn values. Precision and recall metrics were developed for
682the gold standard GitHub apps with respect to total number of
URL objects created and for each created object the number of
method calls that contributed to the string’s creation.
The algorithm was next tested on a small subset of
the MalGenome apps. V alidation of results for MalGenomerequired a different test methodology, as source code wasnot available. All URL objects were identiﬁed by inspection
of Soot Unit objects. Manual tracing of string creation wasperformed to identify and resolve issues with the string anal-ysis algorithm. The initial version of output formats used inthe following aggregate analysis section were developed andperfected to capture necessary information. Manual inspectionof MalGenome apps solidiﬁed the string analysis algorithm im-plementation and this inspection process continued as analysisresults identiﬁed the need to capture additional information forcustomized output formats.
A. Benchmarks
Two sets of Android apps were used for benchmarking; the
MalGenome corpus of malicious apps consisting of 1042 apps
and the Google Play corpus consisting of 517 apps. Both setscomplement one another as they contain a broad spectrum ofapps from those relatively small in size (hundreds of KBs) tolarger apps that are in the tens of MBs. The string analysisalgorithm was ﬁtted with a threaded driver class that allowedfor multiple, concurrent analysis executions. The MalGenomecorpus was processed in six hours and Google Play in tenhours using a thread pool of size ﬁve. Interesting to note isthat across all equally-sized apps, Google Play apps take longerto process than malicious apps.
Multiple output formats were generated to enable the
aggregate analysis of results. These included a tabular view ofall strings detected by the analysis algorithm, a graphical viewof the Soot Units used in string creation, values and countsof all reﬂection and URL string values across all apps, and
counts of all method calls across all apps. These four outputtypes provided a great deal of information about string creationand contributed to identiﬁcation of the high level observationsdiscussed in the following subsections.
1) Creation of URLs: URL creation presents a wealth of
information that may be used to categorize the behavior ofMalGenome and Google Play apps. Consider Table IV-A1,which shows our tool’s results for URL parameters for both
MalGenome and Google Play apps. Provided are the topten parameters identiﬁed for URLs constructed in these apps
along with counts (Note that for brevity, we only presentjava.net.URL objects). Immediately it is evident that while
Google Play apps provide information about timestamp, plat-form, and app ID, malicious apps are interested in passinginformation with respect to IMSI, ICCID, and telephonenumber. Some overlap does exist between arguments where&timestamp and &p1 trace to Java Date objects used to collectthe timestamp when the URL is sent.
The tool captures URLs that are discrete strings as well
as strings that are a series of appends. Analysis on thediscrete strings yields a simple observation summarized inTable IV-A1. For the 1327 distinct, discrete strings identiﬁedfor Google Play apps, 83 used https. For the 413 identiﬁedfor MalGenome, only 3 used https. All three cases were callsTABLE I. T OPURL PARAMETERS
MalGenome Google Play
Parameter Total Parameter Total
&p1= 208 &c= 115
&imsi= 109 &uid= 48
&ca= 99 &game= 33
&ac= 99 &udid= 29
&shid= 99 &app id= 27
&err= 98 &s= 22
&tel= 96 &timestamp= 22
&iccid= 93 &sid= 21
&pid= 87 &locale= 21
&sim= 75 &platform= 20
TABLE II. U SAGE OF SECURE AND INSECURE HTTP :// C ONNECTIONS
http:// https://
Google Play 1244 83
MalGenome 410 3
to mainstream URLs—Facebook and MySpace. This simple
observation demonstrates that the authors of malicious apps areunconcerned with encryption of the actual transfer of content.
While unconcerned with encryption of the transfer of
content, malicious app developers are extremely concernedwith encryption of the IP addresses they connect to. Anexamination of Google Play apps revealed that there wereno instances of obfuscated or encrypted URL usage. The
same examination of MalGenome apps identiﬁed hundreds ofinstances of obfuscated or encrypted URL usage. Table IV-A1
demonstrates this, where the left column are methods thataccept obfuscated text (typically the IP portion of the address)and are used in URL string creation. Zhou et al. [12] discuss
some of these methods in greater detail.
There are numerous observations related to this table. The
Example column indicates that obfuscation results tend to fallinto two categories, those starting with the sequence ‘Hoip’and those that do not. This categorization corresponds to themethod signatures in the Method column where all methodsexcept encode andencodebook use ‘Hoip’ strings.
2) Reﬂection: We have run our string analysis on both
known MalGenome malware and Google Play apps to gatherstatistics on how malware and legitimate apps leverage Re-
flection. In Table IV-A2, we show the gathered statistics.Here, we only show the most common reﬂection strings basedon the occurrence count. We observed that the most commonlyused reﬂection strings are related to the Ads classes. As wemanually examine the apps, it turns out some of the appsleverage reﬂection to request Ads from different libraries.Another family of interesting reﬂection strings is found inwhat appears to be an ofﬁcial Apache HttpClient library usedby some apps. In this library, reﬂection is heavily used inmany different places. However, after comparing the codeto the ofﬁcial Apache library code, we have discovered thatthese two are completely different as the ofﬁcial library neveruses reﬂection. The last interesting class of apps that usereﬂection involves a known malicious family called Geinimi.
By examining the source code manually, we have discoveredthat the Geinimi code uses reﬂection to start a malicious
service, which steals sensitive data, including SMS, Device
IDandPhone Number, and sends it to a remote server.
683TABLE III. E NCRYPTED URL USAGE
Method Total Calls Spread Example
/angbracketleftcom.keji.danti.util.ap: String a(String)/angbracketright 489 163 HoiprJbh9C519IF5HxiL9I0h8cMNuezDrebh7
/angbracketleftcom.sec.android.providers.drm.Xmlns: String d(String)/angbracketright 356 178 HoiprJbh9CVN9wnQ0w7O84FePwnYPJShH
/angbracketleftcom.android.main.Base64: String encodebook(String,int,int)/angbracketright 264 22 kl4ofgsmgeje5gko99s1fc2ofm
/angbracketleftcom.sec.android.providers.drm.Onion: String a(String)/angbracketright 178 178 HoiprJbh9CVp9I0h8Cg1zKVO7CAO7CfaPJSQ
/angbracketleftcom.keji.util.pd: String a(String)/angbracketright 126 42 HoiprJbh9NDs9I0h8Cg1zKVO7CAO7CfaPJSQ
/angbracketleftcom.keji.util.pf: String d(String)/angbracketright 120 40 HoiprJbh9C519IF5HxiL9I0h8cMNuezDrebh7
/angbracketleftcom.android.battery.a.pf: String d(String)/angbracketright 43 43 HoiprJbh9C519IF5HxiL9I0h8cMNuezDrebh7
/angbracketleftcom.android.main.Base64: String encode(String,int)/angbracketright 16 2 alfo3gsa3nfdsrfo3isd21d8a8fccosm
/angbracketleftcom.android.Base64: String encode(String,int)/angbracketright 8 2 alfo3gsa3nfdsrfo3isd21d8a8fccosm
/angbracketleftac: String d(String)/angbracketright 4 2 HoiprJbh9C519IF5HxiL9I0h8cMNuezDrebh7
/angbracketleftcom.android.sf.adomb.Transitional: String d(String)/angbracketright 2 1 HoiprJbh9CVp9I0h8Cg1zKVO7CAO7CfaPJSQ
TABLE IV . R EFLECTION USAGE IN ANDROID
Reﬂection Class String Count
com.admogo.*(Ad) 2323
com.waps.*(Ad) 434
org.apache.commons.httpclient.* 369
com.geinimi.custom.GoogleKeyboard 342
com.google.ads.AdView 163
3) Intent: Analysis was performed on intents for both
MalGenome and Google Play with 4000 intent calls in the
former and 10000 calls in the latter. Results were analyzedby grouping the string argument values provided to intentsand sorting by frequency. Table IV-A3 shows the result of thisanalysis.
Several interesting conclusions can be drawn from the ta-
ble. The Google Play apps display an expected pattern of intentusage. The VIEW intent is indicated by Google documentationto be the most used intent with the documentation alsoindicating that SEND and MAIN are popular. Additionally,there are numerous intents related to billing, again expectedfor commercial apps.
The MalGenome apps show a very different usage pattern.
They also make use of the VIEW intent as expected. Secondmost popular is WEB
SEARCH, used to make URL connec-
tions. This intent ranks 39th in Google Play with 29 usages.Next most popular is APP
DEVELOPMENT SETTINGS, a
non-mainstream intent with few references on the Internet. NoGoogle Play apps use this intent. Next is the SEND intent,which communicates information between apps, also popularin the apps. The 5th and 6th ranked intents for MalGenomeare encrypted strings. As discussed earlier in this paper, useof these strings is clearly for malicious activities and isomnipresent in intents.
An analysis of Google Play apps was performed to identify
if those apps used encrypted strings. One app was identi-ﬁed, com.easy.batter.saver.apk, calling the encrypted
string through com.google.utils.NetworkUtil. Though
the namespace would indicate a trustworthy pedigree for themethod, it turns out that it is not part of any standard GoogleAPI with few references to its existence.
V. R
ELA TED WORK
To improve mobile app security and privacy, various
systems have been proposed. For example, TaintDroid [13]and V etDroid [6] apply dynamic taint analysis to monitorapps and detect runtime privacy leakage in Android apps.ScanDroid [14] aims to automatically extract data ﬂow policyfrom the manifest of an app, and then check whether dataﬂows in the apps are consistent with the extracted speciﬁcation.Alazab et al. [15] provide a dynamic analysis technique that
runs apps in a sandbox and detects malicious apps. Mock-Droid [16] is a tool that protects users’ privacy by supplyingmock data instead of sensitive data. Aurasium [17] providesuser-level sandboxing and policy enforcement to dynamicallymonitor an app for security and privacy violations. Notably,Aurasium does not require modiﬁcations to the underlying OS.CrowDroid [18] is an ofﬂine analysis over traces that can beleveraged to identify malicious apps through examining theirbehavior via crowdsourcing. Moonsamy et al. [19] provided
a thorough investigation and classiﬁcation of 123 apps usingstatic and dynamic techniques over the apps’ Java sourcecode. IccTA [10] and Epicc [9] are frameworks that performICC analysis to detect privacy leaks that may be careless ormalicious in nature. Our own work, BlueSeal [3], proposesa new permission mechanism that leverages static data ﬂowanalysis to discover sensitive data usage and improves Androidapp security. PiOS [20], a static analysis tool for iOS, leveragesreachability analysis on control-ﬂow graphs to detect leaks.ComDroid [21] and Woodpecker [22] expose the confuseddeputy problem [23] on Android.
VI. C
ONCLUSIONS AND FUTURE DIRECTIONS
In this paper we presented a tool for disambiguating strings
within Android apps. Our tool performs a string analysisover an Android app, creating a graph-based representationof the code blocks used in generating strings. An abstractinterpretation of the graph yields a set of potential constructedstrings. Our results indicate that many strings can be fullydisambiguated (quantiﬁed) statically within Android apps.Reasoning about the disambiguated strings gives additionalinsights into the structure and purpose of an Android app.
As part of our future work, we plan to integrate our string
analysis engine into BlueSeal [3], a static data ﬂow analysistool we have built. Based on our preliminary results, we believethat our string analysis engine will improve the precisionof BlueSeal’s ﬂow analysis, speciﬁcally in identifying ﬂowsthat are likely present in malicious code and, conversely,identifying when suspicious ﬂows are in fact benign.
A
CKNOWLEDGMENTS
This work has been supported in part by an NSF CAREER
award, CNS-1350883.
684TABLE V . T OPINTENT IDENTIFIERS IN ANDROID
Google Play MalGenome
Intent Total Intent Total
android.intent.action.VIEW 1866 android.intent.action.VIEW 1194
android.intent.action.SEND 1038 android.intent.action.WEB SEARCH 331
android.intent.action.MAIN 240 com.android.settings.APP DEVELOPMENT SETTINGS 266
android.media.action.IMAGE CAPTURE 198 android.intent.action.SEND 198
com.android.vending.billing.MarketBillingService.BIND 151 7xBDrIM1zvBOzKlOuCRIHcBlcy09KLuFiDRd3pMccY 179
com.android.music.musicservicecommand 150 7xBDrIM1zvBOzKlO7CMO8WB0iyiFl3MPqpzq 171
com.google.android.c2dm.intent.REGISTER 148 com.myplayer.toService 107
com.android.vending.billing.RESPONSE CODE 141 android.intent.action.CALL 81
com.android.vending.billing.PUR STA TE CHANGED 140 android.intent.action.MAIN 71
com.google.android.c2dm.intent.UNREGISTER 90 android.media.action.IMAGE CAPTURE 63
REFERENCES
[1] F.-S. Labs, “Threat report h2 2013,” https://www.f-secure.
com/documents/996508/1030743/Threat Report H2 2013.pdf,
2013.
[2] M. D. Ernst, R. Just, S. Millstein, W. Dietl, S. Pernsteiner,
F. Roesner, K. Koscher, P . B. Barros, R. Bhoraskar, S. Han,
P . Vines, and E. X. Wu, “Collaborative veriﬁcation of informa-tion ﬂow for a high-assurance app store,” in Proceedings of the
2014 ACM SIGSAC Conference on Computer and Communi-cations Security, ser. CCS ’14. New Y ork, NY , USA: ACM,2014.
[3] F. Shen, N. Vishnubhotla, C. Todarka, M. Arora, B. Dhandapani,
E. J. Lehner, S. Y . Ko, and L. Ziarek, “Information ﬂows as apermission mechanism,” in Proceedings of the 29th ACM/IEEE
International Conference on Automated Software Engineering ,
ser. ASE ’14. New Y ork, NY , USA: ACM, 2014.
[4] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel, J. Klein,
Y . Le Traon, D. Octeau, and P . McDaniel, “Flowdroid: Precisecontext, ﬂow, ﬁeld, object-sensitive and lifecycle-aware taintanalysis for android apps,” in Proceedings of the 35th ACM
SIGPLAN Conference on Programming Language Design andImplementation, ser. PLDI ’14. New Y ork, NY , USA: ACM,2014.
[5] L. Lu, Z. Li, Z. Wu, W. Lee, and G. Jiang, “Chex: statically
vetting android apps for component hijacking vulnerabilities,”inProceedings of the 2012 ACM conference on Computer and
communications security, ser. CCS ’12, 2012.
[6] Y . Zhang, M. Yang, B. Xu, Z. Yang, G. Gu, P . Ning, X. S.
Wang, and B. Zang, “V etting undesirable behaviors in androidapps with permission use analysis,” in Proceedings of the 2013
ACM SIGSAC Conference on Computer &#38; CommunicationsSecurity, ser. CCS ’13. New Y ork, NY , USA: ACM, 2013.
[7] A. P . Felt, E. Chin, S. Hanna, D. Song, and D. Wagner,
“Android permissions demystiﬁed,” in Proceedings of the 18th
ACM Conference on Computer and Communications Security,ser. CCS ’11. New Y ork, NY , USA: ACM, 2011.
[8] Y . Zhou and X. Jiang, “Dissecting android malware: Character-
ization and evolution,” in Security and Privacy (Oakland), 2012
IEEE Symposium on, 2012.
[9] D. Octeau, P . McDaniel, S. Jha, A. Bartel, E. Bodden, J. Klein,
and Y . Le Traon, “Effective inter-component communicationmapping in android with epicc: An essential step towardsholistic security analysis,” in Proceedings of the 22Nd USENIX
Conference on Security, ser. SEC’13. Berkeley, CA, USA:USENIX Association, 2013.
[10] L. Li, A. Bartel, T. F. Bissyande, J. Klein, Y . L. Traon, S. Arzt,
S. Rasthofer, E. Bodden, D. Octeau, and P . McDaniel, “Iccta:Detecting inter-component privacy leaks in android apps,”in2015 International Conference on Software Engineering
(ICSE), 2015, to appear. [Online]. Available: http://www.bodden.de/pubs/lbb+15iccta.pdf[11] R. V all ´ee-Rai, P . Co, E. Gagnon, L. Hendren, P . Lam, and
V . Sundaresan, “Soot-aj a v abytecode optimization framework,”inProceedings of the 1999 conference of the Centre for Ad-
vanced Studies on Collaborative research, ser. CASCON ’99.IBM Press, 1999.
[12] Y . Zhou and X. Jiang, “An analysis of the anserverbot trojan,”
2011.
[13] W. Enck, P . Gilbert, B.-G. Chun, L. P . Cox, J. Jung, P . McDaniel,
and A. N. Sheth, “Taintdroid: An information-ﬂow trackingsystem for realtime privacy monitoring on smartphones,” in Pro-
ceedings of the 9th USENIX Conference on Operating SystemsDesign and Implementation , ser. OSDI’10. Berkeley, CA, USA:
USENIX Association, 2010.
[14] A. P . Fuchs, A. Chaudhuri, and J. S. Foster, “Scandroid: Auto-
mated security certiﬁcation of android applications.”
[15] M. Alazab, V . Monsamy, L. Batten, P . Lantz, and R. Tian,
“Analysis of malicious and benign android applications,” inProceedings of the 2012 32nd International Conference onDistributed Computing Systems Workshops , ser. ICDCSW ’12.
Washington, DC, USA: IEEE Computer Society, 2012.
[16] A. R. Beresford, A. Rice, N. Skehin, and R. Sohan, “Mockdroid:
trading privacy for application functionality on smartphones,”inProceedings of the 12th Workshop on Mobile Computing
Systems and Applications , ser. HotMobile ’11. New Y ork, NY ,
USA: ACM, 2011.
[17] R. Xu, H. Sa ¨ıdi, and R. Anderson, “Aurasium: practical policy
enforcement for android applications,” in Proceedings of the
21st USENIX conference on Security symposium, ser. Secu-
rity’12, 2012.
[18] I. Burguera, U. Zurutuza, and S. Nadjm-Tehrani, “Crowdroid:
behavior-based malware detection system for android,” in Pro-
ceedings of the 1st ACM workshop on Security and privacy insmartphones and mobile devices, ser. SPSM ’11. New Y ork,NY , USA: ACM, 2011.
[19] V . Moonsamy, M. Alazab, and L. Batten, “Towards an under-
standing of the impact of advertising on data leaks,” Int. J. Secur .
Netw., vol. 7, no. 3, Mar. 2012.
[20] M. Egele, C. Kruegel, E. Kirda, and G. Vigna, “Pios: Detecting
privacy leaks in ios applications,” in NDSS. The Internet
Society, 2011.
[21] E. Chin, A. P . Felt, K. Greenwood, and D. Wagner, “Analyzing
inter-application communication in android,” in Proceedings of
the 9th International Conference on Mobile Systems, Applica-tions, and Services, ser. MobiSys ’11. New Y ork, NY , USA:ACM, 2011.
[22] M. C. Grace, Y . Zhou, Z. Wang, and X. Jiang, “Systematic
detection of capability leaks in stock android smartphones.” inNDSS. The Internet Society, 2012.
[23] N. Hardy, “The confused deputy: (or why capabilities might
have been invented),” SIGOPS Oper . Syst. Rev., vol. 22, no. 4,
Oct. 1988.
685