Detection and Repair of Architectural
Inconsistencies in Java
Negar Ghorbani, Joshua Garcia, and Sam Malek
School of Information and Computer Sciences
University of California, Irvine, USA
{negargh, joshug4, malek}@uci.edu
Abstract —Java is one of the most widely used program-
ming languages. However, the absence of explicit support for
architectural constructs, such as software components, in theprogramming language itself has prevented software developersfrom achieving the many beneﬁts that come with architecture-based development. To address this issue, Java 9 has introducedthe Java Platform Module System (JPMS), resulting in theﬁrst instance of encapsulation of modules with rich softwarearchitectural interfaces added to a mainstream programminglanguage. The primary goal of JPMS is to construct andmaintain large applications efﬁciently—as well as improve theencapsulation, security, and maintainability of Java applicationsin general and the JDK itself. A challenge, however, is thatmodule declarations do not necessarily reﬂect actual usage ofmodules in an application, allowing developers to mistakenlyspecify inconsistent dependencies among the modules. In thispaper, we formally deﬁne 8 inconsistent modular dependenciesthat may arise in Java-9 applications. We also present D
ARCY ,
an approach that leverages these deﬁnitions and static programanalyses to automatically (1) detect the speciﬁed inconsistentdependencies within Java applications and (2) repair thoseidentiﬁed inconsistencies. The results of our experiments, con-ducted over 38 open-source Java-9 applications, indicate thatarchitectural inconsistencies are widespread and demonstrate thebeneﬁts of D
ARCY in automated detection and repair of these
inconsistencies.
I. I NTRODUCTION
A software system’s architecture comprises the principal
design decisions employed in the system’s construction [1].
Although every system has an architecture, the architecture
of many systems is not explicitly documented, for instance in
the form of UML models. Ensuring that the architecture as
documented or intended, known as the prescriptive architecture,
matches the architecture reﬂected in the system’s implementa-
tion, known as the descriptive architecture, remains a major
challenge [1]. Architecture of a system is often conceptualized
in terms of high-level constructs, such as software components,connectors, and their interfaces, while programming languages
provide low-level constructs, such as classes, methods, and
variables, making it a non-trivial task to map one to the other.
Inconsistencies between prescriptive and descriptive ar-
chitectures are of utmost concern in any software project,since architecture is the primary determinant of a software
system’s key properties. One promising approach for abating
the occurrence of architectural inconsistencies is to make it
easier to bridge the gap between architectural abstractions and
their implementation counterparts. To that end, the software-
engineering research community has previously advocatedforarchitecture-based development , whereby a programming
language (e.g., ArchJava [2]) or a framework (e.g., C2 [3])
provides the implementation constructs for realizing the archi-
tectural abstractions.
In spite of this prior work in the academic community,
until recently, Java—arguably the most popular programming
languages over the past two decades—lacked extensive support
for architecture-based development. This all changed with the
introduction of Java Platform Module Systems (JPMS) in Java
9. Modules are intended to make it easier for developers toconstruct large applications, and improve the encapsulation,
security, and maintainability of Java applications in general as
well as the JDK itself [4].
Using Java’s module system, the developer explicitly spec-
iﬁes the system’s components (i.e., modules in Java) as
well as the speciﬁc nature of their dependencies in a ﬁle
called module-info . However, Java 9 does not provide any
mechanism to ensure the prescriptive architecture speciﬁed in
themodule-info ﬁle is in fact consistent with the descriptive
architecture of the implemented software, i.e., whether the
declared dependencies in the module-info ﬁle are accurately
reﬂecting the implemented dependencies among the system’s
components. Inconsistencies between the prescriptive anddescriptive architectures in Java 9 matter. The Java platformuses the
module-info ﬁle to determine the level of access
granted to each module, and to determine which modules
should be packaged together for deployment. As a result, in-
consistencies between prescriptive and descriptive architecture
in Java have severe security and performance consequences.
These inconsistencies also affect the engineers ability to use
the prescriptive architecture for understanding the system’s
properties or to make maintenance decisions.
In this paper, we formally deﬁne 8 modular inconsistencies
that may occur in Java-9 applications. We present D ARCY ,a n
approach that leverages these deﬁnitions and static analyses
to automatically (1) detect the speciﬁed inconsistencies within
Java applications and (2) repair them. D ARCY is also publicly
available [5].
The results of our experiments, conducted over 38 open-
source Java-9 applications, indicate that architectural inconsis-
tencies are widespread, and demonstrate the beneﬁts of D ARCY
in automated detection and repair of these inconsistencies.
DARCY found 124 instances of inconsistencies among 38
Java applications in our data set. By automatically ﬁxing
these inconsistencies, D ARCY was able to measurably improve
5602019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)
1558-1225/19/$31.00 ©2019 IEEE
DOI 10.1109/ICSE.2019.00067
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:17 UTC from IEEE Xplore.  Restrictions apply. various attributes of the subject applications’ architectures
by reducing the attack surface of applications by 60.33%,
improving their encapsulation by 23.03%, and producing
deployable applications that consume 14.02% less memory.
The remainder of this paper is organized as follows. Section
II introduces the module system of Java 9 and its design goals.
Section III formally speciﬁes the architectural inconsistencies
in the context of Java 9. Section IV provides details of
our approach and its implementation. Section V presents the
experimental evaluation of the research. Section VI includes
the threats to validity of our approach. The paper concludes
with an outline of related research and future work.
II. J AVA PLA TFORM MODULE SYSTEM
To aid the reader with understanding architectural speciﬁca-
tion in Java 9, we introduce the new module system for Java
9, called Java Platform Module System (JPMS). We overview
JPMS’s goals and the architectural risks that arise from its
misuse. We then discuss the details of modules in Java 9—
including module declarations and module directives.
A. JPMS Goals and Potential Misuse
JPMS enables speciﬁcation of a prescriptive architecture in
terms of key architectural elements—speciﬁcally components
in the form of Java-9 modules, architectural interfaces, and
resulting dependencies among components. JPMS aims to
enable reliable conﬁguration, stronger encapsulation, modu-
larity of the Java Development Kit (JDK) and Java Runtime
Environment (JRE) to solve the problems faced by engineers
when developing and deploying Java applications [6].
Software designers and developers can achieve strong
encapsulation in their Java-9 systems by modularizing them and
allowing explicit speciﬁcation of interfaces and dependencies.
Encapsulation in Java 9 is achieved by allowing architects
or developers to specify which of a Java-9 module’s public
types are accessible or inaccessible to other modules [7]. A
module must explicitly declare which of its public types are
accessible to other modules. A module cannot access public
types in another module unless those modules explicitly make
their public types accessible. As a result, JPMS has added
more reﬁned accessibility control—allowing architects and
developers to decrease accessibility to packages, reduce the
points at which a Java application may be susceptible to security
attacks, and design more elegant and logical architectures [8].
Prior to Java 9, the Java platform was a monolith consisting
of a massive number of packages, making it challenging to
develop, maintain, and evolve. Software developers could not
easily choose a subset of the JDK as a platform for their
applications. This results in software bloat and more potential
points of attack for malicious agents. With the introduction of
JPMS in Java 9, the Java platform is now modularized into
95 modules. Furthermore, many internal APIs are hidden from
apps using the platform [7], potentially reducing problems
involving software bloat and security.
Using JPMS in Java 9, Java developers can now create
lightweight custom JREs consisting of only modules they needfor their application or the devices they are targeting. As a
result, the Java platform can more easily scale down to small
devices, which is important for microservices or IoT devices
[9]. For example, if a device does not support GUIs, developers
could use JPMS to create a runtime environment that does not
include the GUI modules, signiﬁcantly reducing the runtime
memory size [8].
Although JPMS allows for speciﬁcation of prescriptive
architectures, the descriptive architecture of a Java application
may be inconsistent with the prescriptive architecture. Such
inconsistencies may arise due to architects or developers
misunderstanding of a software systems’ architectures (e.g.,
an architect mistakenly speciﬁes a more accessible interface
than he intended), or simply due to mistaken implementations
(e.g., a developer neglects to use a module’s interface, even
though the architect intended such a use). This can result in
(1) a poorly encapsulated architecture, making an application
harder to understand and maintain; (2) bloated software; or
(3) insecure software. In terms of security, for instance, one
of the potential problems is the granting of unnecessary
access to internal classes and packages, potentially resulting in
security vulnerabilities. In terms of software bloat, inconsistent
dependencies can compromise scalability and performance of
Java software (e.g., requiring many unnecessary modules from
the JDK).
B. Understanding Java 9 JPMS Modules
In JPMS, a module is a uniquely named, reusable group
of related packages, as well as resources (such as images
and XML ﬁles) [4]. Each module has a descriptor ﬁle,
module-info.java , which contains meta-data, including the
declaration of a named module. A named module should specify
(1) its dependencies on other modules, i.e., the classes and
interfaces that the module needs or expects, and should specify
(2) which of its own packages, classes, and interfaces are
exposed to other modules.
A module can be a normal module or an open module .A
normal module allows access from other modules at compile
time and run time to only explicitly exported packages; an
open module allows access from other modules (1) at compile
time to only explicitly exported packages and (2) at run time
to all its packages [10].
The module declaration ﬁle consists of a unique module
name and a module body. Any module body can be empty
or contain one or more module directives, which speciﬁes a
module’s exposure to other modules or the modules it needs
access to.
Figure 1 shows an example of a project with three modules:
bar,foo, and service . The declarations of each module
provided in its module-info.java ﬁle is described in Figure
1a. Figure 1b is a diagram that depicts the relationship between
the same modules based on dependencies in their declarations.
A module body can utilize combinations of the following
ﬁve module directives [10], which specify module interfaces
and their usage: the requires directive speciﬁes the packages
that a module needs access to, the exports and opens directives
561
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:17 UTC from IEEE Xplore.  Restrictions apply. make packages of a module available to other modules, the
provides directive speciﬁes the services a module provides, and
the uses directive speciﬁes the services a package consumes.
These directives can be declared as described below:
1module bar {
2 requires java.desktop;
3 requires service;
4
5 exports com.example.bar.lang;
6 exports com.example.bar.http tofoo;
7
8 provides com.example.service.Srv with com.example.
bar.impl.ImplService; }
9
10 module foo {
11 requires service;
12 requires java.logging;
13 requires transitive bar;
14
15 exports com.example.foo.utils;
16 exports com.example.foo.internal tobar;
17
18 opens com.example.foo.network;
19 opens com.example.foo.exnet tobar;
20
21 uses com.example.service.Srv;}
22
23 module service {
24 exports com.example.service;}
(a) Module declarations and their directives provided in their module-
info.java ﬁles.
(b) Speciﬁed dependencies between modules based on their directives
Fig. 1: Three example modules with their inter-dependencies
•The requires directive with declaration requires m2of
a module m1speciﬁes the name of a module m2that m1
depends on. m2can be a user-deﬁned module or a module
within the JDK. For example, in Figure 1, module bar
requires module java.desktop . The requires declaration of
a module m1may be followed by the transitive modiﬁer,
which ensures that any module m3that requires m1also
implicitly requires module m2. As an example, in Figure
1, module foo requires module bar and any module that
requires foo also implicitly requires bar.
•The exports directive with declaration exports pof a
module m1speciﬁes that m1exposes package p’s public
and protected types, and their nested public and protected
types, to all other modules at both runtime and compile
time. For example, in Figure 1, the module bar exports
the package com.example.bar.lang . We can also export a
package speciﬁcally to one or more modules by using theexports ptom2,m3, ..., mndeclaration. In this case, the
public and protected types of the exported package are only
accessible to the modules speciﬁed in the toclause.
As an example, in Figure 1, module foo exports
com.example.foo.internal to the module bar.
•Theopens directive with declaration opens pspeciﬁes that
package p’s nested public and protected types, and the
public and protected members of those types, are accessible
by other modules at runtime but not compile time. This
directive also grants reﬂective access to all types in p,
including the private types, and all its members, from
other modules. For example, in Figure 1, module foo
makes package com.example.foo.network available to
other modules only at runtime, including through reﬂection.
This directive may also be followed by the tomodiﬁer,
resulting in the opens ptom2,m3, ..., mndeclaration. In this
case, the public and protected types of pare only accessible to
the modules speciﬁed in the toclause. For instance, in Figure
1, module foo makes package com.example.foo.exnet
available only at runtime, including through reﬂection, to
the module bar. Unlike the other directives that can only be
used in the body of a module’s speciﬁcation, open can be
used in both the body of a module’s speciﬁcation and in its
header (i.e., before the module’s name). The latter usage is
a shorthand way of denoting all packages in the module are
open .
•The provides with directive with declaration
provides c1with c2,c3,. . . , cnof module m1speciﬁes that a
class c1is an abstract class or interface that is provided as a
service by m1. The with clause speciﬁes one or more service
provider classes for use with java.util.ServiceLoader .A
service is a well-known set of interfaces and (usually abstract)
classes. A service provider is a speciﬁc implementation of a
service. java.util.ServiceLoader<S> is a simple service-
provider loading facility. It loads a provider implementing
the service type S[11]. For instance in Figure 1, module bar
provides the abstract class com.example.service.Srv as
a service using the com.example.bar.impl.ImplService
class as the service’s implementation.
•The uses directive with declaration uses c1of a module
m1speciﬁes that m1uses a service object of an abstract
class or interface, c1, provided by another module. For
this purpose, the module should discover providers of the
speciﬁed service via java.util.ServiceLoader .A sa n
example from Figure 1, module foo uses the service object
of class com.example.service.Srv , which is provided by
module bar.
Note that, as depicted in Figure 1, both provides with and
uses directives need the module being declared to require
the service module as well.
III. I NCONSISTENT MODULE DEPENDENCIES
Based on the module directives described in the previous
section, inconsistencies may arise when using modules. Insuf-
ﬁciently speciﬁed dependencies (e.g., a module that attempts
to use a package it does not have a requires directive for)
562
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:17 UTC from IEEE Xplore.  Restrictions apply. are already checked by the Java platform. However, excess
dependencies , where a module either (1) exposes more of
its internals than are used or (2) requires internals of other
modules that it never uses, are not handled by Java. These
inconsistencies can affect various architectural attributes:
A1: Encapsulation and Maintenance —Requiring unneeded
functionalities of other modules increases the complexity of
the module unnecessarily, compromises its encapsulation, and
decreases its maintainability.
A2: Software Bloat and Scalability —Requiring unneeded
modules, especially from JDK, can result in bloated software,
which compromises scalability of the application.
A3: Security —Excessively exposing the internals of a module
can result in errors or security issues arising in the module.
To achieve a systematic and comprehensive coverage of
all types of inconsistent module dependencies, we studied all
potential inconsistencies resulting from developers’ misuse of
each type of module directive. In the remainder of this section,
we focus on specifying eight types of inconsistent dependencies
that may arise when using JPMS and the functions needed to
specify those dependencies.
Table I includes 11 functions that directly model different
variations of the ﬁve module directives in JPMS. To describe
a class loading a service using java.util.ServiceLoader
API, we deﬁne the LoadsService function. For actual code
usage among packages, as opposed to those speciﬁed through
module directives, we deﬁne the Dep function.
TABLE I: Functions describing dependencies based on module
directives of JPMS
Function Description
Req(m1,m2) Module m1requires module m2.
ReqJDK (m1,mjdk) Module m1requires the JDK module
mjdk.
ReqTransitive (m1,m2) Module m1requires transitive module
m2.
Exp(m,p) Module mexports package p.
ExpTo (m1,p1,{m2,m3,...}) Module m1exports package p1to the
set of modules {m2,m3, ...}.
Open (m) Module mis open.
Opens (m,p) Module mopens package p.
OpensTo (m1,p,{m2,m3,...}) Module m1opens package pto the set
of modules {m2,m3, ...}.
Uses (m,s) Module muses Service s.
ProvidesWith (m,s,{c1,c2,...}) Module mprovides service swith the
set of classes {c1,c2, ...}.
LoadsService (c,s) Class cloads Service svia the
java.util.ServiceLoader API.
Dep(p1,p2) Source code in package p1uses classes
of package p2.
Re f lDep (p1,p2) Source codes in package p1uses classes
of package p2via reﬂection.
By leveraging the functions in Table I, we introduce
eight types of excess inconsistent dependencies: requires,
JDK requires, requires transitive, exports(to), provides with,
uses, open, and opens(to) modiﬁers. For each inconsistentdependency type, there is a dependency explicitly deﬁned in
amodule-info ﬁle which is not actually used in the source
code of the module. Using these formal deﬁnitions, Section IV
detects and repairs the following inconsistent dependencies.
Inconsistent Requires Dependency : This scenario de-
scribes an inconsistent requires dependency in which (1)
module m1explicitly declares that it requires another module
m2and (2) no class of m1actually uses any class inside exported
packages of m2. As a result, this inconsistency mostly affects
attribute A1. It can also affect attribute A2.
Req(m1,m2)∧(∄p1∈m1,p2∈m2:Dep (p1,p2)) (1)
Inconsistent JDK Requires Dependency : This scenario de-
scribes an inconsistent requires dependency in which module
m1explicitly declares that it requires a module inside the
Java JDK, mjdk. However, none of the classes inside m1
uses any class inside exported packages of mjdk. Hence, it
affects attribute A1, and more importantly A2. We distinguish
this scenario from the previous one because an inconsistency
involving JDK modules has a greater effect on portability than
the previous more generic scenario.
Req(m1,mjdk)∧(∄p1∈m1,p2∈mjdk:Dep(p1,p2)) (2)
Inconsistent Requires Transitive Dependency : An excess
transitive modiﬁer in a requires dependency consists of
the following (1) a module m1explicitly declares in its
module-info ﬁle that it transitively requires another module
m2—which means any module that requires m1also implicitly
requires m2; and (2) no class of a module that requires m1
actually uses any class in m2. This type of inconsistency mostly
affects attribute A1, but also affects A2.
ReqTransitive (m1,m2)∧(∀m:Req(m,m1),
∀p∈m,∀p2∈m2:¬Dep(p,p2))(3)
Inconsistent Exports/Exports to Dependency : An inconsis-
tent exports dependency occurs when a module m1explicitly
exports a package p1to all other modules, while no package
in those other modules use p1.
Exp(m1,p1)∧(∀p/∈m1:¬Dep(p,p1)) (4)
For an exports to directive, this inconsistency occurs when m1
exports the package p1to a speciﬁc list of modules M, while
no class outside m1, or inside module list M, uses any class
inside p1.
ExpTo (m1,p1,M)∧(∀p∈M:¬Dep(p,p1)) (5)
These inconsistencies mostly affect attribute A3 by granting
unnecessary access to classes and packages. They also affect
attribute A1 due to complicating the architecture.
Inconsistent Provides With Dependency : An inconsistent
provides with dependency has two key parts: (1) a module
mexplicitly declares that it provides a service s, which is an
abstract class or interface that is extended or implemented
by a set of classes E={c1,c2,. . . , ck}inside m; and (2) none
of the classes inside other modules uses service svia the
java.util.ServiceLoader API. Consequently, this incon-
sistency type—similar to inconsistent requires dependency—
affects attribute A1 and A2 because the provides with depen-
563
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:17 UTC from IEEE Xplore.  Restrictions apply. dency necessitates a requires directive as well. Additionally,
this inconsistency type grants unnecessary access to a subset
of the application’s classes via the ServiceLoader API which
affects attribute A3.
ProvidesWith (m,s,E)∧(∀m/prime/negationslash=m:¬Uses (m/prime,s)) (6)
Inconsistent Uses Dependency : An inconsistent uses depen-
dency occurs when (1) a module mexplicitly declares in
itsmodule-info.java ﬁle that it uses a service sand (2)
none of the classes inside mactually use the service svia
thejava.util.ServiceLoader API. This inconsistency type,
similar to the previous type, will affect attribute A1 and A2,
due to adding an additional requires directive.
Uses (m,s)∧(∀c∈m:¬LoadsService (c,s)) (7)
Inconsistent Open Modiﬁer : An excess open modiﬁer occurs
in the following scenario: (1) a module mdeclares that it opens
all its packages to all other modules—recall from Section II-B
that unlike the other directives, open can be used in the header
of a module’s speciﬁcation to denote all its packages are open;
and (2) there is at least one package pinside mthat no
class outside mreﬂectively accesses. As a result, any such
package pis potentially open to misuse through reﬂection, e.g.,
external access to private members of a class that should not
be allowed by any other class. This inconsistency type will
affect attribute A3—and make the architecture inaccurate and
more complicated, affecting attribute A1.
Open (m)∧(∃p∈m:∀p/prime/∈m:¬Re f lDep (p/prime,p) (8)
Inconsistent Opens/Opens To : An inconsistent opens depen-
dency occurs when a module mdeclares that it opens a package
pto all other modules via reﬂection, while none of the classes
outside mreﬂectively accesses any classes of package p.
Opens (m,p)∧∀ p/prime/∈m:¬Re f lDep (p/prime,p) (9)
Similarly, for opens to , the tomodiﬁer speciﬁes a list of
modules Mfor which module mopens a package pto access
via reﬂection, while no package of mreﬂectively accesses p.
OpensTo (m,p,M)∧∀ p/prime∈M:¬Re f lDep (p/prime,p) (10)
For these inconsistency types, private members of pare open
to dangerous misuse through undesired access and reﬂection,
affecting attribute A3, and can also affect attribute A1 due to
unnecessarily complicating the architecture.
IV . D ARCY
In the previous section, we introduced various types of
inconsistent dependencies. This section describes how we
leverage these deﬁnitions to design and implement D ARCY .
Figure 2 depicts a high-level overview of D ARCY comprised
of two phases, Detection and Repair .D ARCY is implemented
in Java and Python.
A. Detection
The detection phase takes a Java application as input and
identiﬁes any instance of the eight inconsistent dependencies
described in Section III.
To identify actual dependencies of an input Java application,
DARCY relies on static analysis, represented as Class Depen-
dency Analysis in Figure 2. In the implementation of D ARCY ,
Fig. 2: A high-level overview of D ARCY
we leveraged Classycle [12] for Class Dependency Analysis .
More precisely, the information about actual dependencies in
the source code of the input application is collected by running
Classycle, which provides a complete report of all dependencies
in source code of a Java application at both the class and
package levels. We only need the extracted dependencies among
packages since the dependencies deﬁned in modules are at the
package level. Class Dependency Analysis’s results are stored
inActual Dependencies , which is a database component.
A Java application may contain multiple modules, each with
amodule-info ﬁle describing the module’s dependencies. For
extracting a prescriptive architecture, we developed Module-
Info Scanner which examines all module-info.java ﬁles
within the input Java application and extracts all speciﬁed
dependencies which are deﬁned at the package level. The
collected information of speciﬁed dependencies are stored in
another database component, Speciﬁed Dependencies .
Java Reﬂection Analysis leverages a custom static analysis
[13], which we have implemented using the Soot framework
[14], to identify usage of reﬂection in the input application. The
traces of any actual usage of reﬂection in the Java application
is then stored in Actual Dependencies .
Java Reﬂection Analysis extracts reﬂective invocations that
occur in cases where non-constant strings, or inputs, are used
as target methods of a reﬂective call. Reﬂective invocation of
a method, for both constructor and non-constructor methods,
occurs in three stages: (1) class procurement (i.e., a class with
the method of interest is obtained) (2) method procurement
(i.e., the method of interest to be invoked is identiﬁed), and
(3) the method of interest is actually invoked. Java Reﬂection
Analysis attempts to identify information at each stage.
1 ClassLoader cl = MyClass. getClassLoader();
2 try { Class c = cl.loadClass( "NetClass" );
3 ...
4 Method m = c.getMethod( "getAddress" ,...);
5 ...
6 m.invoke(...); }
7 catch {. . .}
Fig. 3: Reﬂective method invocation example
A simple example, based on those found in real-world apps,
of reﬂective method invocation, not involving constructors,
is depicted in Figure 3. In this example, a ClassLoader
forMyClass is obtained (line 1), which is responsible
for loading classes. The NetClass class is loaded using
564
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:17 UTC from IEEE Xplore.  Restrictions apply. thatClassLoader (line 2). The getAddress method of
NetClass (line 4)—which performs network operations—is
retrieved and eventually invoked using reﬂection (line 6).
Our analysis identiﬁes reﬂectively invoked methods us-
ing a backwards analysis. That analysis begins by identi-
fying all reﬂective invocations (e.g., line 6 in Figure 3).
Next, the analysis follows the use-def chain of the invoked
java.lang.reflect.Method instance (e.g., mon line
6) to identify all possible deﬁnitions of the Method in-
stance (e.g., line 4). Our analysis considers various methods
that return Method instances, i.e., using getMethod or
getDeclaredMethod ofjava.lang.Class . The anal-
ysis then records each identiﬁed method name. If the analysis
cannot resolve the name, this information is also recorded. In
this case, the analysis conservatively indicates that any method
of the package opened for reﬂection can be accessed.
For constant strings, the analysis attempts to identify the class
name that is being invoked. Similar to the resolution of method
names, the analysis follows the use-def chain of the java.
lang.Class instance from which a java.lang.Class
is retrieved (e.g., following the use-def chain of con line 4).
We model various means of obtaining a java.lang.Class
instance. For example, the class may be loaded by name using
aClassLoader ’sloadClass(...) method (e.g., line 2),
using java.lang.Class ’sforName method, or through a
class constant (e.g., using NetClass.class ). The analysis
then records the class name it can ﬁnd statically, or stores that
it could not resolve that name. Note that our analysis consid-
ers any subclass of ClassLoader . Our reﬂection analysis
involving constructors works in a similar manner by analyzing
invocations of java.lang.reflect.Constructor and
invocations of its newInstance method.
Similar to our analyses for reﬂectively invoked meth-
ods, We perform analyses for any set* methods
ofjava.lang.reflect.Field (e.g., setInt(...) )
orget*Field *methods of java.lang.Class (e.g.,
getDeclaredField(String) ).
For extracting the actual dependencies of type uses we
implemented ServiceLoader Usage Analysis which leverages
a custom static analysis using the Soot framework to identify
usage of java.util.ServiceLoader in the input appli-
cation. The traces of any actual usage of a service is then
stored in Actual Dependencies .
An application obtains a service loader for a given service
by invoking the static load method of ServiceLoader
API. A service loader can locate and instantiate providers of
the given service using the iterator orstream method
[15], through which an instance of each of the located service
providers can be created. As an example, Figure 4 depicts the
code that obtains a ServiceLoader forMyService (line
1). The ServiceLoader loads providers of MyService
(line 2) and can instantiate any of the located providers of this
service using its iterator—created by the for loop in line 3.
In this example, the service provider with the getService
method is desired (line 4).
Our analysis identiﬁes the usage of the ServiceLoader1 ServiceLoader<MyService> loader;
2 loader = ServiceLoa der.load (MyService. class );
3 for (MyService s : loader) {
4 if(s.getService != null ){... } }
Fig. 4: Service loader example
API using a backward analysis by following the use-def chain
ofServiceLoader instances (e.g., son line 4) to identify
all possible deﬁnitions of a ServiceLoader (e.g, line 2 in
Figure 4). The results of the ServiceLoader API usage is
then stored in Actual Dependencies .
Java Inconsistency Analysis ’s main goal is to identify all
types of inconsistency scenarios described in Section III. For
each directive in a module-info.java ﬁle, Java Inconsistency
Analysis explores actual and speciﬁed dependencies, stored in
their respective database components, to identify any occur-
rence of an inconsistent dependency deﬁned in Section III. If a
matching instance is found, Java Inconsistency Analysis reports
the identiﬁed architectural inconsistency, the module affected,
and the speciﬁc directive involved. The component then stores
the identiﬁed inconsistencies in Inconsistent Dependencies ,
which are then used in the repair phase.
B. Repair
To repair inconsistent dependencies, Module-Info Trans-
former deletes or modiﬁes the explicit dependencies deﬁned in
themodule-info ﬁles. Inconsistencies found in the previous
phase are all unnecessarily deﬁned dependencies among an
application’s modules and packages. Therefore, Module-Info
Transformer needs to omit those inconsistent dependencies
speciﬁed in the module-info ﬁles.
The result of the detection phase includes the type and
details of identiﬁed inconsistencies. For instance, in the case
of an inconsistent exports dependency, one result stored in
Inconsistent Dependencies includes the module in which this
dependency is speciﬁed, the type of the inconsistent dependency
(exports in this case), and the package that is unnecessarily
exported. The repair phase takes the results of the detection
phase as input. For each module, the repair phase ﬁnds the
related records of inconsistent dependencies deﬁned in that
module and modiﬁes the affected lines in module-info .
For this purpose, we leveraged ANTLR [16] to transform
themodule-info.java ﬁles to repair the inconsistent depen-
dencies. ANTLR is a parser generator for reading, processing,
executing, or translating a structured text. Hence, we generated
a customized parser using Java-9 grammar so that we can
modify it to check the records of inconsistent dependencies
found in the detection phase of D ARCY .
More precisely, we have implemented the generated parser so
that, if it ﬁnds any match between the tokens of module-info
ﬁles and the inconsistent dependencies, it skips or modiﬁes the
speciﬁc token with respect to the type of the inconsistency. As a
result, depending on the type of dependency, the corresponding
line in the module-info ﬁle is omitted or modiﬁed.
Module-Info Transformer repairs each type of inconsistent
dependency. In most cases, Module-Info Transformer deletes
565
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:17 UTC from IEEE Xplore.  Restrictions apply. the entire statement. However, for requires transitive ,
Module-Info Transformer only removes the token transitive .
In case of inconsistencies involving open module m(Equa-
tion 8 in Section III), the open modiﬁer is removed from the
header of the module declaration. However, there may be some
packages in mthat other modules reﬂectively access. For each
of these packages, Module-Info Transformer adds an opens to
statement thats make private members of the package accessible
to the modules that reﬂectively access the package. If there is
no package in mthat is reﬂectively accessed by other modules,
no statement will be added to the module’s body.
In certain situations, the D ARCY user may disagree with the
way it repairs and modiﬁes the speciﬁed dependencies because
DARCY is not aware of the architect’s or developer’s intentions.
For example, this situation may occur if the user wants to
develop a library and export some packages for further needs
or even allow other modules to reﬂectively access the internals
of some classes and packages. D ARCY warns the developers
and architects about potential threats caused by architectural
inconsistencies in their Java application, and allows them to
override D ARCY prior to application of repairs.
V. E V ALUA TION
To assess the effectiveness of D ARCY , we study the following
research questions:
RQ1: How pervasive are inconsistent, architectural dependen-
cies in practice?
RQ2: How accurate is D ARCY at detecting inconsistent,
architectural dependencies and repairing them?
RQ3: To what extent does D ARCY reduce the attack surface
of Java modules?
RQ4: To what extent does D ARCY enhance encapsulation of
Java modules?
RQ5: To what extent does D ARCY reduce the size of runtime
memory?
RQ6: What is D ARCY ’s runtime efﬁciency in terms of execu-
tion time?
To answer these research questions, we selected a set of
Java applications from GitHub [17], a large and widely used
open-source repository of software projects, all of which are
implemented in Java 9. For this purpose, we searched through
Java applications in GitHub and selected projects that contain a
module-info.java ﬁle. Our search covered about a hundred
pages of search results in the GitHub repository. To assess
module dependencies, projects needed to have more than one
module in their respective module-info.java ﬁles. Our ﬁnal
evaluation dataset resulted in 38 Java-9 applications, avoiding
any selection bias toward our approach.
A. RQ1: Pervasiveness
Table II shows, for each application, the total number of
inconsistent dependencies D ARCY found, modules, module
directives used, and inconsistent dependencies by type. 74%
of applications in our dataset (28 out of 38) have inconsis-
tent dependencies. Recall that even one existing inconsistent
dependency could cause undesired behaviors, or issues withencapsulation, security, or memory utilization (see Section III).
As depicted in Table II, most of the inconsistent dependencies
are of types exports orrequires because these two types of
directives are used more frequently than others. The high
frequency of inconsistent exports dependencies indicates that
granting unnecessary access to internal packages are quite
common in Java-9 applications, which could cause security
vulnerabilities. Among the inconsistent requires dependencies,
therequires JDK dependency occurred more than others, which
increases the risk of loading unnecessary JDK modules and
compromising portability.
Table II indicates that a few applications have inconsistent
dependencies of type provides with , and only one application
has an inconsistent uses dependency. In fact, these directives
are rare compared to other directives. For provides with and
uses , Java checks most of the requirements for avoiding
inconsistent dependencies at compile time. Therefore, the
possibility of deﬁning an inconsistent provides with and uses
dependencies decreases. Nevertheless, D ARCY covers the
inconsistent dependencies corresponding to these two directives
because they are risky and may appear more frequently in future
usage of Java 9.
B. RQ2: Correctness
To answer RQ2 for D ARCY ’s detection capability, we ran
the detection phase for each of the Java-9 applications in our
evaluation dataset to assess whether D ARCY can accurately
detect inconsistent dependencies. To that end, we manually
checked the inconsistent dependencies found by D ARCY to
ensure their correctness. More precisely, we compared the cor-
responding record in both Actual Dependencies and Speciﬁed
Dependencies to verify the correctness of the inconsistencies
discovered by the detection phase. The result, as described in
Table II, shows that all inconsistent dependencies found by
DARCY are correct.
To evaluate D ARCY ’s ability to correctly repair inconsisten-
cies, we ran the repair phase of D ARCY for each of the Java-9
applications in our evaluation dataset to assess whether D ARCY
repairs the detected inconsistencies without introducing any
unexpected behavior. To assess correctness of a repair, we (1)
check if each application compiles successfully after running
the repair phase and (2) if the application contains a test suite,
determine if the application obtains the same test passing rate ,
i.e., the ratio of the number of passing test cases to the total
number of test cases, both before and after repairs. We also ran
the detection phase after the repair actions. The result showed
zero inconsistencies within the transformed Java applications.
The results for compilation after repair are shown in Table
II, indicating that all the applications compiled successfully.
This conﬁrms that the inconsistent dependencies have been
repaired robustly in a way that does not prevent compilation of
the applications. Additionally, three applications in our study
contain a test suite. The passing rate for each of these test
suites remains the same both before and after D ARCY repairs,
demonstrating that D ARCY does not negatively affect expected
behavior of repaired applications.
566
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:17 UTC from IEEE Xplore.  Restrictions apply. TABLE II: Identiﬁed Inconsistencies and Robustness Results
No. Application # Modules # Directives # Total Inconsistencies Types % Correct Compiled Test Passing Rate (%)
Name Incons. R R.J. R.T E P U O Incons. (After Repair) Before After
1 sense-nine 6 31 9 2 2 - 2 - - 3 100 /check - -
2 number-to-text 3 11 1 - - - 1 - - - 100 /check 100 100
3 vstreamer 6 25 4 1 - - - - 3 - 100 /check - -
4 jigsaw-resources 2 5 1 - - - 1 - - - 100 /check - -
5 JavaUtils 6 36 29 - 14 9 6 - - - 100 /check - -
6 BunnyHop 2 28 17 - 1 2 11 - - 3 100 /check - -
7 java9-modules 2 5 1 - - - 1 - - - 100 /check - -
8 jwtgen 2 13 2 1 - - 1 - - - 100 /check - -
9 project-constantin 4 9 5 - - 1 4 - - - 100 /check 100 100
10 java-spi-example 6 26 4 - - 1 3 - - - 100 /check - -
11 codersonbeer-app 4 13 4 1 - - 2 - - 1 100 /check - -
12 rahmnathan-utils 3 14 7 - 1 - 6 - - - 100 /check - -
13 auto-sort 3 13 1 - - - 1 - - - 100 /check 97 97
14 java9-demo 4 10 1 - - - 1 - - - 100 /check - -
15 java9-modules-tlb 5 12 1 - - - 1 - - - 100 /check - -
16 java-9-lab 5 15 1 - - - 1 - - - 100 /check - -
17 meetup-16 4 14 6 - - - 3 3 - - 100 /check - -
18 java-9-bookstore 6 17 3 - - 2 - 1 - - 100 /check - -
19 springuni-java9 3 6 3 2 - - 1 - - - 100 /check - -
20 java-9-modularity 4 11 1 - - 1 - - - - 100 /check - -
21 java-9-spring-mvn 3 18 8 2 - - 6 - - - 100 /check - -
22 music-ui-start 3 15 4 - - 1 1 - - 2 100 /check - -
23 java9-labs 4 10 4 - - - 4 - - - 100 /check - -
24 practical-security 4 20 2 - 1 - 1 - - - 100 /check - -
25 java9-junit 3 13 1 - - - 1 - - - 100 /check - -
26 the-message 3 16 1 - - - 1 - - - 100 /check - -
27 jigsaw-tst 4 11 1 - - - 1 - - - 100 /check - -
28 TRPZ 4 19 2 - - - 1 - - 1 100 /check - -
C. RQ3: Security
To assess D ARCY ’s ability to enhance security, we consider
the attack surface of Java-9 applications. The attack surface
of a system is the collection of points at which the system’s
resources are externally visible or accessible to users or external
agents. Manadhata et al. introduced an attack-surface metric
to measure the security of a system in a systematic manner
[18]–[20]. Every externally accessible system resource can
potentially be part of an attack and, hence, contributes to a
system’s attack surface. This contribution reﬂects the likelihood
of each resource being used in security attacks. Intuitively, the
more actions available to a user or the more resources that
are accessible through these actions, the more exposed an
application is to security attacks [18]–[20].
For a Java-9 application, the main resource under considera-
tion is a Java module. As a result, we deﬁne the attack surface
of an application as the number of packages that are accessible
from outside its modules. To measure the attack surface of
Java-9 applications, we count the number of packages exposed
byexports (to) and open(s to) directives. These directives make
internals of packages accessible to other modules.
As shown in Table III, 25 out of 29 applications had an
average attack-surface reduction of about 60%. D ARCY was
able to totally eliminate the attack surface in 5 applications.1
Although eliminating the module-based attack surface does not
result in perfect security, D ARCY can maximize protection to
the asset (i.e., Java packages) through a module’s interfaces by
eliminating all unnecessary exports and opens directives of the
module—other attack vectors (e.g., IPC over network sockets)
1These applications are essentially software utilities or libraries including
different modules that provide functionalities for different situations, but do
not have any dependency on one another.TABLE III: Result for Attack-Surface Reduction
Application # exposed # exposed Attack Surface
Name pckg (before) pckg (after) Reduction (%)
sense-nine 6 1 83.33
number-to-text 4 3 25.00
jigsaw-resources 2 1 50.00
JavaUtils 7 1 85.71
BunnyHop 16 2 87.50
java9-modules 2 1 50.00
jwtgen 1 0 100
project-constantin 4 0 100
java-spi-example 6 3 50.00
codersonbeer-app 4 1 75.00
rahmnathan-utils 6 0 100
auto-sort 2 1 50.00
java9-demo 2 1 50.00
java9-modules-tlb 5 4 20.00
java-9-lab 3 2 33.33
meetup-16 4 1 75.00
springuni-java9 1 0 100
java-9-spring-mvn 6 0 100
music-ui-start 5 2 60.00
java9-labs 5 1 80.00
practical-security 4 3 25.00
java9-junit 4 3 25.00
the-message 10 9 10.00
jigsaw-tst 3 2 33.33
TRPZ 5 3 40.00
Avg. Attack Surface Reduction 60.33%
still remain but are out of scope for D ARCY . The relatively
large reduction of the attack surface in applications achieved
by D ARCY indicates that it can signiﬁcantly curtail security
risks in Java-9 applications.
D. RQ4: Encapsulation
To evaluate the ability of D ARCY to enhance the encapsula-
tion of Java-9 applications, we leveraged two metrics selected
from an extensive investigation by Bouwers et al. [21] about
the quantiﬁcation of encapsulation for implemented software
architectures. We selected metrics that involve architectural
dependencies and are appropriate for the context of modules
567
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:17 UTC from IEEE Xplore.  Restrictions apply. in JPMS and Java-9 applications.
The ﬁrst metric we selected is Ratio of Coupling (RoC) [22],
which measures coupling among an application’s modules.
For Java-9 modules, RoC is the ratio of the number of
existing dependencies among modules to the number of all
possible dependencies among modules . Ideally, the value of
RoC would be low, meaning that only a small part of all
possible dependencies among modules is actually utilized—
making it less likely that faults, failures, or errors introduced by
changes or additions to modules will propagate across modules.
The second metric we selected is a variant of Cumulative
Component Dependency (CCD) [23] which is the sum of all
outgoing dependencies for a component. For Java-9 modules,
outgoing dependencies are requires and uses dependencies of
each module. The speciﬁc variant we used is Normalized CCD
(NCD), which is the ratio of CCD for each module to the total
number of modules. Ideally, the value of CCD, or NCD, is
low, indicating lower coupling and better encapsulation.
TABLE IV: Results for Encapsulation Improvement
Application # Directives RoC NCD
Name (before) % Change % Change
sense-nine 31 29.03 16.00
number-to-text 11 9.09 -
vstreamer 25 16.00 20.00
jigsaw-resources 5 20.00 -
JavaUtils 36 80.56 79.31
BunnyHop 28 60.71 25.00
java9-modules 5 20.00 -
jwtgen 13 15.38 8.33
project-constantin 9 55.56 20.00
java-spi-example 27 15.38 5.56
codersonbeer-app 13 30.77 12.50
rahmnathan-utils 14 50.00 12.50
auto-sort 13 7.69 -
java9-demo 10 10.00 -
java9-modules-tlb 12 8.33 -
java-9-lab 15 6.67 -
meetup-16 14 42.86 -
java-9-bookstore 17 17.65 16.67
springuni-java9 6 50.00 40.00
java-9-modularity 11 9.09 12.50
java-9-spring-mvn 18 44.44 16.67
music-ui-start 15 26.67 10.00
java9-labs 10 40.00 -
practical-security 20 10.00 7.69
java9-junit 13 7.69 -
the-message 16 6.25 -
jigsaw-tst 11 9.09 -
TRPZ 19 10.53 -
Total # of Affected Systems (RoC) 28
RoC Reduction Avg. 25.34%
Total # of Affected Systems (NCD) 15
NCD Reduction Avg. 20.73%
Table IV presents the amount of RoC and NCD change in 28
Java-9 applications with inconsistent dependencies. Across all
28 applications, the amount of RoC is reduced by an average of
25.34%, and up to 80.56%. The amount of NCD is also reduced
in 15 applications by an average of 20.73%, and up to 79%.
These results indicate that D ARCY can successfully enhance the
encapsulation of Java-9 applications by a signiﬁcant amount.
E. RQ5: Software Bloat
To answer this research question, we measured the runtime
memory needed by each application before and after D ARCY ’s
repair phase. Recall the fact that in Java 9, with the JDK being
modularized, we are able to create a lightweight custom JavaRuntime Environment (JRE), reducing software bloat. More
speciﬁcally, the size of a custom JRE may be reduced after a
repair if the application has inconsistent dependencies of type
requires JDK (Equation 2 of Section III).
TABLE V: Results for Software-Bloat Reduction
Application JRE Size (MB) Runtime Memory
Name (before) (after) Reduction (%)
sense-nine 19.11 18.99 0.63
JavaUtils 39.24 30.66 21.87
BunnyHop 46.23 20.93 54.72
java-spi-example 41.40 38.9 6.04
rahmnathan-utils 15.61 15.60 0.12
practical-security 15.72 15.60 0.76
Avg. Memory Reduction 14.02%
Table V shows reduction of software bloat in terms of
runtime memory size of affected applications after removing
inconsistent requires JDK dependencies. According to the
results, the reduction is about 14% in 6 applications, and up to
55%. Such results are particularly substantial for deployment
and scalability goals in microservices or IoT devices that
contain very little memory.
F . RQ6: Performance
As described in Section IV, D ARCY builds on three tools,
Classycle [12], Soot [14], and ANTLR [16]. As a result, to
assess D ARCY ’s performance we answer RQ5 in terms of these
three underlying tools’ execution time.
TABLE VI: Results for Execution Time
Component Avg. Execution Time (ms)
Class Dependency Analyzer (Classycle) 7428
Java Reﬂection Analysis 328
ServiceLoader Usage Analysis 315
Java Inconsistency Analysis 250
Repair 453
Total 8774
Table VI describes the average execution times for D ARCY .
Results for Classycle are shown separately from results for
other components since the execution time is dominated by
Classycle. On average, D ARCY takes under 9 seconds for any
system to execute, which is highly time efﬁcient for both
detection and repair.
VI. T HREA TS TO VALIDITY
In terms of accuracy, the main threat to internal validity is
the risk of false positives or negatives of the static analysis
tools used in the implementation. False positives or negatives
in the results of the static analysis tools may cause D ARCY
to miss some inconsistencies in the detection phase or report
false inconsistencies, which may lead to compilation errors or
harming functionality of the application after the repair phase.
Since D ARCY takes Classycle’s results as an input for the Java
inconsistency analysis, it inherits all of Classycle’s limitations.
The accuracy of detecting the inconsistent dependencies is
affected by the accuracy of the static analysis tool we use.
However, Classycle has been used and in development for
over 11 years and leveraged by other state-of-the-art tools
for software architecture and antipattern analysis [24]–[30]. A
similar threat to internal validity exists for our use of Soot; how-
ever, Soot is a widely used [31], [32] and actively maintained
568
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:17 UTC from IEEE Xplore.  Restrictions apply. framework [33] for static analysis of Java programs. We further
manually determine whether every identiﬁed inconsistency is
correct to ensure that any unforeseen issues with underlying
static analyses do not compromise D ARCY ’s accuracy.
One of the main threats to external validity is the selection
and number of Java applications in the evaluation dataset. To
mitigate this threat, we selected open source Java-9 applications
from many developers and about a hundred pages of search
results on GitHub, one of the largest and most widely used
open-source repositories online. Another threat to external
validity is whether the types of inconsistencies we identify
comprehensively cover those that may exist. To alleviate this
threat, we considered the architectural inconsistencies based
on all types of module directives deﬁned in Java 9.
DARCY ’s evaluation on only one programming language,
i.e., Java, is another threat to external validity. This threat is
alleviated by the fact that Java is one of the most widely used
languages in the world [34], [35]. Furthermore, the general
idea behind D ARCY can be extended to any other languages
with modular programming constructs that utilize provides and
requires interfaces advocated by software architecture-based
development and design [36]–[38].
VII. R ELA TED WORK
The most closely related literature to D ARCY bridges
the gap between software architecture and implementation.
There are a variety of different types of strategies to address
this issue: focusing only on the descriptive architecture by
reverse engineering it; obtaining the descriptive architecture
and the prescriptive architecture, followed by checking their
conformance; ensuring that early in the software lifecycle
that the descriptive and prescriptive architectures conform by
providing architectural constructs in code; and approaches
that ensure conformance of the descriptive and prescriptive
architecture from the beginning and into maintenance.
Many approaches address the architecture-implementation
mapping issue by ignoring the prescriptive architecture and
simply trying to obtain the most accurate descriptive architec-
tures possible [28], [29], [39]–[46]. A large number of these
approaches rely on software clustering to determine components
from implementations [39], [40], [47]–[49].
A series of approaches detect inconsistencies between
architecture and implementation by reverse engineering the
descriptive architecture from the code and comparing it with
the prescriptive architecture [50]–[63]. Murphy et al. introduced
the software reﬂexion method which helps an engineer compare
prescriptive and descriptive architectures in a manual manner
[50]. A number of these approaches extend the reﬂexion method
with automated architecture recovery techniques [60]–[62].
Other approaches provide implementation-level constructs
that represent architectural elements (e.g., customizable
programming-language classes representing components) that
help ensure architectural conformance from a forward-
engineering perspective [2], [64]–[70]. Many of these ap-
proaches support various notions of software architectural
connectors or interfaces, rather than just components.Certain approaches achieve architecture-implementation map-
ping from both a forward-engineering (e.g., code generation)
and reverse-engineering perspective, i.e., round-trip engineering
[71]–[73]. 1.x-way mapping [71] allows manual changes to
be initiated in the architecture and a separated portion of
the code, with architecture-prescribed code updated solely
through code generation. 1.x-line mapping [72] extends 1.x-
way mapping to product-line development. Song et al. [73]
introduce a runtime approach for architecture-implementation
mapping from a roundtrip-engineering perspective.
DARCY is the ﬁrst approach that supports architectural-
implementation conformance checking in a mainstream pro-
gramming language using architectural constructs built directly
into the programming language by its creators. Furthermore,
our approach includes repair of non-conforming architectures,
rather than just determining inconsistencies. D ARCY is the only
approach for architecture-implementation mapping that focuses
on software bloat and attack-surface reduction.
The module system has been recently introduced in Java,
and the only existing framework similar to JPMS is OSGI
[74]. The major differences between OSGI and JPMS are
as follows. OSGI was not able to modularize the JDK,
preventing the construction of customized runtime images with
a minimized JDK, which JPMS enables. Additionally, OSGI
cannot handle reﬂective access to modules’ internal packages.
Similar dependency-analysis facilities for OSGI are limited to
removing unused dependencies of type import, which represents
the require dependency, and cannot cover the other 7 types of
inconsistencies in JPMS applications previously introduced in
section III. Therefore, there is no similar facility for OSGI that
repairs all types of inconsistent dependencies as D ARCY does.
VIII. C ONCLUSION
This paper formally deﬁnes 8 types of architectural incon-
sistencies in Java-9 applications and introduces D ARCY ,a n
approach for automatic detection and repair of these types of
inconsistencies. D ARCY leverages custom static analysis, state-
of-the art static analysis tools, and a custom parser generator in
its implementation to effectively detect and robustly repair archi-
tectural inconsistencies. The results of our evaluation indicates
a pervasive existence of architectural inconsistencies among
open source Java-9 applications. According to our experiment,
DARCY ’s automatic repair results in a signiﬁcant reduction of
the attack surface, enhancement of encapsulation, and reduction
of memory usage for Java-9 applications. In the future, we aim
to expand D ARCY to other programming languages and improve
it to (1) provide architectural visualization and (2) be used as
a plug-in for Java Integrated Development Environments (IDE)
which helps developers avoid architectural inconsistencies when
developing Java applications.
IX. A CKNOWLEDGEMENT
This work was supported in part by awards CCF-1252644,
CNS-1629771, CCF-1618132, and CNS-1823262 from the
National Science Foundation. We would like to thank Daniel
Popescu for informing us about JPMS before it was released
as part of Java.
569
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:17 UTC from IEEE Xplore.  Restrictions apply. REFERENCES
[1] R. Taylor, N. Medvidovic, and D. E.M., Software Architecture: F ounda-
tions, Theory, and Practice . John Wiley & Sons, 2009.
[2] J. Aldrich, C. Chambers, and D. Notkin, “Archjava: Connecting
software architecture to implementation,” in Proceedings of the 24th
International Conference on Software Engineering , ser. ICSE ’02.
New Y ork, NY , USA: ACM, 2002, pp. 187–197. [Online]. Available:
http://doi.acm.org/10.1145/581339.581365
[3] R. N. Taylor, N. Medvidovic, K. M. Anderson, E. J. Whitehead, Jr.,
and J. E. Robbins, “A component- and message-based architectural
style for gui software,” in Proceedings of the 17th International
Conference on Software Engineering , ser. ICSE ’95. New Y ork,
NY , USA: ACM, 1995, pp. 295–304. [Online]. Available: http:
//doi.acm.org/10.1145/225014.225042
[4] “Project Jigsaw,” http://openjdk.java.net/projects/jigsaw/, 2017.
[5] “Darcy web page [In accordance with the double-blind policy],” https:
//sites.google.com/view/darcy-project/home, 2018.
[6] K. Sharan, “The module system,” in Java 9 Revealed . Springer, 2017,
pp. 7–30.
[7] M. Reinhold, “JSR 376: Java Platform Module System,” Technical
report, Oracle Corporation. http://cr.openjdk.java.net/ mr/jigsaw/spec/,
Tech. Rep., 2014.
[8] P . Deitel, “Understanding Java 9 Modules,” https://www.oracle.com/
corporate/features/understanding-java-9-modules.html, 2017.
[9] P . J. Deitel and H. M. Deitel, Java 9 for Programmers . Prentice Hall,
2017.
[10] J. Gosling, B. Joy, G. Steele, G. Bracha, A. Buckley,
and D. Smith, “The Java Language Speciﬁcation Java
SE 9 Edition,” Technical report, Oracle Corporation.
https:https://docs.oracle.com/javase/specs/jls/se9/html/index.html,
Tech. Rep., 2017.
[11] “Oracle Corporation. API speciﬁcation for the Java Platform, Standard
Edition: Class ServiceLoader,” https://docs.oracle.com/javase/7/docs/api/
java/util/ServiceLoader.html.
[12] F.-J. Elmer, “Classycle: Analysing Tools for Java Class and Package
Dependencies,” How Classycle works , 2012.
[13] J. Garcia, M. Hammad, and S. Malek, “Lightweight, obfuscation-
resilient detection and family identiﬁcation of android malware,” ACM
Transactions on Software Engineering and Methodology (TOSEM) ,
vol. 26, no. 3, p. 11, 2018.
[14] R. V all ´ee-Rai, P . Co, E. Gagnon, L. Hendren, P . Lam, and V . Sundaresan,
“Soot: A Java bytecode optimization framework,” in CASCON First
Decade High Impact Papers . IBM Corp., 2010, pp. 214–224.
[15] “ServiceLoader (Java SE 9 & JDK 9),” https://docs.oracle.com/javase/9/
docs/api/java/util/ServiceLoader.html, 2018.
[16] “ANTLR,” http://www.antlr.org, 2018.
[17] “GitHub,” https://github.com, 2018.
[18] P . Manadhata and J. M. Wing, “Measuring a system’s attack surface,”
CARNEGIE-MELLON UNIV PITTSBURGH PA SCHOOL OF COM-
PUTER SCIENCE, Tech. Rep., 2004.
[19] P . K. Manadhata, K. M. Tan, R. A. Maxion, and J. M. Wing, “An approach
to measuring a system’s attack surface,” CARNEGIE-MELLON UNIV
PITTSBURGH PA SCHOOL OF COMPUTER SCIENCE, Tech. Rep.,
2007.
[20] P . K. Manadhata and J. M. Wing, “An attack surface metric,” IEEE
Transactions on Software Engineering , no. 3, pp. 371–386, 2010.
[21] E. Bouwers, A. van Deursen, and J. Visser, “Quantifying the encapsulation
of implemented software architectures,” in Software Maintenance and
Evolution (ICSME), 2014 IEEE International Conference on . IEEE,
2014, pp. 211–220.
[22] L. C. Briand, S. Morasca, and V . R. Basili, “Measuring and assessing
maintainability at the end of high level design,” in Software Maintenance,
1993. CSM-93, Proceedings., Conference on . IEEE, 1993, pp. 88–87.
[23] J. Lakos, “Large-scale c++ software design,” Reading, MA , vol. 173, pp.
217–271, 1996.
[24] M. R. Shaheen and L. du Bousquet, “Quantitative analysis of testa-
bility antipatterns on open source java applications,” QAOOSE 2008-
Proceedings , p. 21, 2008.
[25] R. Y okomori, N. Y oshida, M. Noro, and K. Inoue, “Extensions of
component rank model by taking into account for clone relations,” in
Software Analysis, Evolution, and Reengineering (SANER), 2016 IEEE
23rd International Conference on , vol. 3. IEEE, 2016, pp. 30–36.
[26] E. Constantinou, G. Kakarontzas, and I. Stamelos, “Towards open source
software system architecture recovery using design metrics,” in 2011
15th Panhellenic Conference on Informatics , Sept 2011, pp. 166–170.[27] D. M. Le, P . Behnamghader, J. Garcia, D. Link, A. Shahbazian, and
N. Medvidovic, “An empirical study of architectural change in open-
source software systems,” in Mining Software Repositories (MSR), 2015
IEEE/ACM 12th Working Conference on . IEEE, 2015, pp. 235–245.
[28] J. Garcia, I. Ivkovic, and N. Medvidovic, “A comparative analysis of
software architecture recovery techniques,” in Proceedings of the 28th
IEEE/ACM International Conference on Automated Software Engineering .
IEEE Press, 2013, pp. 486–496.
[29] T. Lutellier, D. Chollak, J. Garcia, L. Tan, D. Rayside, N. Medvidovi ´c,
and R. Kroeger, “Comparing software architecture recovery techniques
using accurate dependencies,” in Proceedings of the 37th International
Conference on Software Engineering-V olume 2 . IEEE Press, 2015, pp.
69–78.
[30] E. Constantinou, G. Kakarontzas, and I. Stamelos, “Open source software:
How can design metrics facilitate architecture recovery?” arXiv preprint
arXiv:1110.1992 , 2011.
[31] L. Hendren, “Uses of the Soot Framework,” http://www.sable.mcgill.ca/
∼hendren/sootusers/, 2018.
[32] P . Lam, E. Bodden, O. Lhot ´ak, and L. Hendren, “The soot framework
for java program analysis: a retrospective,” in Cetus Users and Compiler
Infastructure Workshop (CETUS 2011) , vol. 15, 2011, p. 35.
[33] “Soot GitHub Issue,” https://github.com/Sable/soot/issues, 2018.
[34] “TIOBE Index for August 2018,” https://www.tiobe.com/tiobe-index/,
2018.
[35] “The State of the Octoverse 2017,” https://octoverse.github.com/, 2018.
[36] R. van Ommering, F. van der Linden, J. Kramer, and J. Magee, “The
koala component model for consumer electronics software,” Computer ,
vol. 33, no. 3, pp. 78–85, March 2000.
[37] N. Medvidovic and R. N. Taylor, “A classiﬁcation and comparison
framework for software architecture description languages,” IEEE
Transactions on Software Engineering , vol. 26, no. 1, pp. 70–93, Jan
2000.
[38] K. Lau and Z. Wang, “Software component models,” IEEE Transactions
on Software Engineering , vol. 33, no. 10, pp. 709–724, Oct 2007.
[39] S. Ducasse and D. Pollet, “Software architecture reconstruction: A
process-oriented taxonomy,” IEEE Transactions on Software Engineering ,
vol. 35, no. 4, pp. 573–591, 2009.
[40] R. Koschke, “Architecture reconstruction,” in Software Engineering .
Springer, 2006, pp. 140–173.
[41] I. Ivkovic and M. Godfrey, “Enhancing domain-speciﬁc software
architecture recovery,” in Program Comprehension, 2003. 11th IEEE
International Workshop on . IEEE, 2003, pp. 266–273.
[42] M. W. Godfrey and E. H. Lee, “Secrets from the monster: Extracting
mozillas software architecture,” in Proceedings of Second Symposium on
Constructing Software Engineering Tools (CoSET00) . Citeseer, 2000.
[43] M. Mirakhorli, Y . Shin, J. Cleland-Huang, and M. Cinar, “A tactic-centric
approach for automating traceability of quality concerns,” in Software
Engineering (ICSE), 2012 34th International Conference on . IEEE,
2012, pp. 639–649.
[44] A. Shahbazian, Y . K. Lee, D. Le, Y . Brun, and N. Medvidovic,
“Recovering architectural design decisions,” in 2018 IEEE International
Conference on Software Architecture (ICSA) . IEEE, 2018.
[45] E. Constantinou, G. Kakarontzas, and I. Stamelos, “An automated
approach for noise identiﬁcation to assist software architecture recovery
techniques,” Journal of Systems and Software , vol. 107, pp. 142–157,
2015.
[46] D. Qiu, Q. Zhang, and S. Fang, “Reconstructing software high-level
architecture by clustering weighted directed class graph,” International
Journal of Software Engineering and Knowledge Engineering , vol. 25,
no. 04, pp. 701–726, 2015.
[47] M. Shtern and V . Tzerpos, “Clustering Methodologies for Software
Engineering,” Adv. Soft. Eng. , vol. 2012, pp. 1:1–1:1, Jan. 2012. [Online].
Available: http://dx.doi.org/10.1155/2012/792024
[48] O. Maqbool and H. Babri, “Hierarchical clustering for software archi-
tecture recovery,” IEEE Transactions on Software Engineering , vol. 33,
no. 11, 2007.
[49] R. A. Bittencourt and D. D. S. Guerrero, “Comparison of graph
clustering algorithms for recovering software architecture module views,”
inSoftware Maintenance and Reengineering, 2009. CSMR’09. 13th
European Conference on . IEEE, 2009, pp. 251–254.
[50] G. C. Murphy, D. Notkin, and K. J. Sullivan, “Software reﬂexion models:
Bridging the gap between design and implementation,” IEEE Transactions
on Software Engineering , vol. 27, no. 4, pp. 364–380, 2001.
570
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:17 UTC from IEEE Xplore.  Restrictions apply. [51] N. Medvidovic, A. Egyed, and P . Gruenbacher, “Stemming architectural
erosion by coupling architectural discovery and recovery.” in STRAW ,
vol. 3, 2003, pp. 61–68.
[52] A. V an Deursen, C. Hofmeister, R. Koschke, L. Moonen, and C. Riva,
“Symphony: View-driven software architecture reconstruction,” in Soft-
ware Architecture, 2004. WICSA 2004. Proceedings. Fourth Working
IEEE/IFIP Conference on . IEEE, 2004, pp. 122–132.
[53] L. O’Brien, D. Smith, and G. Lewis, “Supporting migration to services
using software architecture reconstruction,” in Software Technology and
Engineering Practice, 2005. 13th IEEE International Workshop on . IEEE,
2005, pp. 81–91.
[54] J. B. Tran, M. W. Godfrey, E. H. Lee, and R. C. Holt, “Architectural repair
of open source software,” in Program Comprehension, 2000. Proceedings.
IWPC 2000. 8th International Workshop on . IEEE, 2000, pp. 48–59.
[55] M. Abi-Antoun, J. Aldrich, D. Garlan, B. Schmerl, N. Nahas, and
T. Tseng, “Improving system dependability by enforcing architectural
intent,” in ACM SIGSOFT Software Engineering Notes , vol. 30, no. 4.
ACM, 2005, pp. 1–7.
[56] H. Yan, D. Garlan, B. Schmerl, J. Aldrich, and R. Kazman, “DiscoTect:
A System for Discovering Architectures from Running Systems,” in
Software Engineering, 2004. ICSE 2004. Proceedings. 26th International
Conference on . IEEE, 2004, pp. 470–479.
[57] N. Sangal, E. Jordan, V . Sinha, and D. Jackson, “Using dependency
models to manage complex software architecture,” in ACM Sigplan
Notices , vol. 40, no. 10. ACM, 2005, pp. 167–176.
[58] J. A. Diaz-Pace, J. P . Carlino, M. Blech, A. Soria, and M. R. Campo,
“Assisting the synchronization of ucm-based architectural documentation
with implementation,” in 2009 Joint Working IEEE/IFIP Conference on
Software Architecture (WICSA) & 3rd European Conference on Software
Architecture (ECSA) . IEEE, 2009, pp. 151–160.
[59] M. Seﬁka, A. Sane, and R. H. Campbell, “Monitoring compliance of
a software system with its high-level design models,” in Proceedings
of the 18th international conference on Software engineering . IEEE
Computer Society, 1996, pp. 387–396.
[60] R. Koschke and D. Simon, “Hierarchical reﬂexion models,” in null .
IEEE, 2003, p. 36.
[61] A. Christl, R. Koschke, and M.-A. Storey, “Equipping the reﬂexion
method with automated clustering,” in Reverse Engineering, 12th Working
Conference on . IEEE, 2005, pp. 10–pp.
[62] R. Koschke, P . Frenzel, A. P . Breu, and K. Angstmann, “Extending the
reﬂexion method for consolidating software variants into product lines,”
Software Quality Journal , vol. 17, no. 4, pp. 331–366, 2009.[63] A. Gurgel, I. Macia, A. Garcia, A. von Staa, M. Mezini, M. Eichberg, and
R. Mitschke, “Blending and reusing rules for architectural degradation
prevention,” in Proceedings of the 13th international conference on
Modularity . ACM, 2014, pp. 61–72.
[64] M. Caporuscio, H. Muccini, P . Pelliccione, and E. Di Nisio, “Rapid
system development via product line architecture implementation,” in
International Workshop on Rapid Integration of Software Engineering
Techniques . Springer, 2005, pp. 18–33.
[65] J. Grundy, “Multi-perspective speciﬁcation, design and implementation
of software components using aspects,” International Journal of Software
Engineering and Knowledge Engineering , vol. 10, no. 06, pp. 713–734,
2000.
[66] S. Malek, M. Mikic-Rakic, and N. Medvidovic, “A style-aware architec-
tural middleware for resource-constrained, distributed systems,” IEEE
Transactions on Software Engineering , vol. 31, no. 3, pp. 256–272, 2005.
[67] J. Aldrich, C. Omar, A. Potanin, and D. Li, “Language-based architectural
control,” in Proceedings of the International Workshop on Aliasing,
Capabilities and Ownership (IWACO) , 2014, pp. 1–11.
[68] A. Radjenovic and R. F. Paige, “The role of dependency links in
ensuring architectural view consistency,” in Seventh Working IEEE/IFIP
Conference on Software Architecture . IEEE, 2008, pp. 199–208.
[69] M. Shaw, R. DeLine, D. V . Klein, T. L. Ross, D. M. Y oung, and
G. Zelesnik, “Abstractions for software architecture and tools to support
them,” IEEE transactions on software engineering , vol. 21, no. 4, pp.
314–335, 1995.
[70] N. Ubayashi, J. Nomura, and T. Tamai, “Archface: a contract place where
architectural design and code meet together,” in Proceedings of the 32nd
ACM/IEEE International Conference on Software Engineering-V olume 1 .
ACM, 2010, pp. 75–84.
[71] Y . Zheng and R. N. Taylor, “Enhancing architecture-implementation
conformance with change management and support for behavioral
mapping,” in Proceedings of the 34th International Conference on
Software Engineering . IEEE Press, 2012, pp. 628–638.
[72] Y . Zheng, C. Cu, and R. N. Taylor, “Maintaining architecture-
implementation conformance to support architecture centrality: From
single system to product line development,” ACM Transactions on
Software Engineering and Methodology (TOSEM) , vol. 27, no. 2, p. 8,
2018.
[73] H. Song, G. Huang, F. Chauvel, Y . Xiong, Z. Hu, Y . Sun, and H. Mei,
“Supporting runtime software architecture: A bidirectional-transformation-
based approach,” Journal of Systems and Software , vol. 84, no. 5, pp.
711–723, 2011.
[74] “OSGI Alliance,” https://www.osgi.org/developer/speciﬁcations/.
571
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:17 UTC from IEEE Xplore.  Restrictions apply. 