Does Automated Refactoring Obviate
Systematic Editing?
Na Meng∗Lisa Hua∗Miryung Kim†Kathryn S. McKinley‡
∗The University of Texas at Austin†University of California, Los Angeles‡Microsoft Research
mengna09@cs.utexas.edu lisahua@utexas.edu miryung@cs.ucla.edu mckinley@microsoft.com
Abstract —When developers add features and ﬁx bugs, they
often make systematic edits—similar edits to multiple locations.
Systematic edits may indicate that developers should instead
refactor to eliminate redundancy. This paper explores this ques-tion by designing and implementing a fully automated refactoringtool called R
ASE , which performs clone removal.R ASE (1)
extracts common code guided by a systematic edit; (2) createsnew types and methods as needed; (3) parameterizes differencesin types, methods, variables, and expressions; and (4) insertsreturn objects and exit labels based on control and data ﬂow. Toour knowledge, this functionality makes R
ASE the most advanced
refactoring tool for automated clone removal.
We evaluate R ASE with real-world systematic edits and com-
pare to method based clone removal. R ASE successfully performs
clone removal in 30 of 56 method pairs (n=2) and 20 of 30method groups (n≥3) with systematic edits. We ﬁnd that scopingrefactoring based on systematic edits (58%), rather than theentire method (33%), increases the applicability of automatedclone removal. Automated refactoring is not feasible in the other42% cases, which indicates that automated refactoring does notobviate the need for systematic editing.
I. I NTRODUCTION
Developers often apply similar changes to multiple locations.
Systematic editing tools automate this task to reduce theprogramming burden of these tedious, error-prone changes.For instance, simultaneous text editing automates edit actionsin one context by replicating them in other pre-selectedcontexts [25]. Linked Editing [30] and Clever [27] keep trackof code clones and propagate changes from one clone to otherclones. Sydit [24] and Lase [23] infer context-aware abstracttransformations from user-selected examples, and then use thetransformations to apply custom changes to user speciﬁed orautomatically suggested locations. These systematic editingtools help developers to make coordinated changes in multiplelocations. However, this practice may encourage developers tocreate or maintain duplicated code, when perhaps programswould be easier to maintain and understand if developersinstead refactored their code. If programmers should alwaysrefactor, then systematic editing tools may be encouragingpoor practices. This paper examines this question, that is,if systematic edits are obviated by using automated cloneremoval refactoring.
We ﬁrst design and implement a new completely automated
refactoring approach R
ASE, which takes as input two or
more methods with systematic edits to scope target code, andthen performs clone removal.R
ASE combines extract method
(pg. 110 in [7]), add parameter (pg. 275 in [7]), introduceexit label, parameterize type, form template method (pg. 345
in [7]), and introduce return object refactorings to extract
and remove similar code. It creates an abstract refactoring
template that abstracts differences in types, methods, variables,
and expressions from the multiple locations. Based on thistemplate, as well as control and data ﬂow, R
ASE creates new
types and methods; inserts and assigns return objects and exitlabels; adds parameters to the new extracted method; andintroduces customized calls to it.
To our knowledge, R
ASE implements state-of-the-art refac-
toring with respect to its capability to factor and generalizecode. Existing clone removal refactoring tools only implementsome, but not all of the refactoring techniques in R
ASE [3, 12,
14, 21, 29]. Nor do they combine and study the effectivenessof automated clone removal. Furthermore, prior work that doesstudy clone removal did not actually construct an automated
refactoring tool to investigate the refactoring of systematicallychanged code [1, 5, 8, 16, 17]. The lack of automation inprior work introduces the possibility of subjectivity bias. Byautomating refactoring, our study substantially improves onprior methodology for determining the feasibility of cloneremoval refactoring.
We evaluate R
ASE on 56 real-world systematically edited
method pairs (n=2) from prior work [23, 24] and 30 systemati-cally edited method groups (n≥ 3) drawn from two open source
projects. R
ASE automatically refactors 30 of 56 method pairs
(54%) and 20 of 30 (67%) method groups when scoping withsystematic edits. R
ASE applies sophisticated refactorings with
all six techniques and in multiple different combinations of upto four techniques at once. On average, R
ASE automatically
applied 41 lines of edits in our examples, ranging from 6 to285, with modest code size increases of up to 18 lines ofcode, and reductions of up to 149 lines. Not surprisingly, R
ASE
is most effective at reducing code size for multiple methods.Manual transformation to attain the same results would requireinserting, deleting, or modifying up to 285 lines of code. Ourevaluation results add to the evidence that removing commoncode with variations is challenging in practice and needsautomated tool support.
We compare R
ASE scoped by systematic edits to R ASE
scoped by entire methods: scoping with systematic edits im-proves the feasibility of automatic clone removal compared tomethod-level scoping. With method-level scoping, R
ASE only
refactors 34% method pairs and 30% method groups. However,with systematic edit scoping, R
ASE refactors 54% method
2015 IEEE/ACM 37th IEEE International Conference on Software Engineering
978-1-4799-1934-5/15 $31.00 © 2015 IEEE
DOI 10.1109/ICSE.2015.58392
2015 IEEE/ACM 37th IEEE International Conference on Software Engineering
978-1-4799-1934-5/15 $31.00 © 2015 IEEE
DOI 10.1109/ICSE.2015.58392
2015 IEEE/ACM 37th IEEE International Conference on Software Engineering
978-1-4799-1934-5/15 $31.00 © 2015 IEEE
DOI 10.1109/ICSE.2015.58392
ICSE 2015, Florence, Italypairs and 67% method groups. Systematic edits thus are a good
clue for refactoring, rather than being obviated by method-level refactoring. However, R
ASE cannot automate refactoring
in 46% of pairs and 33% of groups mainly because of languagelimitations, semantic constraints, and lack of common code.We manually checked software version histories after system-atic edits and found that in many cases, systematically editedmethods are not refactored. They either co-evolve, diverge, orstay unchanged. Our tool evaluation and software repositoryobservations indicate that both automated systematic editingand refactoring are necessary to support software evolution.
This paper designs and implements an automated clone
removal refactoring algorithm and demonstrates refactoringfeasibility. Predicting refactoring desirability is a hard problem
because it depends on complex factors, such as code read-ability, the frequency and types of changes, future changesin requirements, and code size. Since R
ASE automates the
feasibility step and quantiﬁes code size impact, it should helpdevelopers determine refactoring desirability [4, 28, 33] andhelp with cost and beneﬁt analysis [22, 26, 34], but we leavethat investigation to future work.
In summary, this paper makes the following contributions.
•We design and implement R ASE, an advanced automated
clone removal tool. It takes methods with systematic editsas inputs and fully automates refactoring to extract com-mon code with variations in types, methods, variables,and expressions.
•Evaluation on real-world pairs and groups of methodsshows that R
ASE effectively automates clone removal in
many cases. This tool evaluation together with our manualsoftware repository examination reveals that refactoringis not always applicable or actually applied to every sys-tematically edited method. Thus, automated refactoringis unlikely to obviate systematic editing.
•Previous studies ﬁnd that clone refactoring is not neces-sary or feasible, but they did not construct an automatedrefactoring tool [1, 5, 8, 16, 17]. The lack of automa-tion introduces potential subjectivity bias. By automatingrefactoring, our study improves on the prior methodologyand shows that refactoring is often feasible.
II. M
OTIV ATING EXAMPLE
This section overviews our approach with an example basedon
org.eclipse.compare.CompareEditorInput revisions v-
20061120 and v20061218. Figure 1 shows a systematic editon two methods. The unchanged code is in black, addedcode is in blue with ‘+’, and deleted code is in red with
‘−’. The two methods perform very similar input processing
and experience similar edits: adding a variable declarationand updating statements. However, the changes involve usingdifferent type, method, and variable names:
IActionBars
vs. ISLocator ;getActionBars vs. getServiceLocator ;
findActionBars vs. findSite ;offset vs. offset2 ; and
actionBars vs.sLocator .
Given two changed methods, our refactoring tool (R ASE)
ﬁrst invokes L ASE [23], which creates an abstract edit script.1. public class CompareEditorInput {
2. private ICompareContainer fContainer;
3. private boolean fContainerProvided;4. private Splitter fComposite;5. public IActionBars getActionBars (int offset) {
6. if (offset == -1)7. return null;8.- if (fContainer == null) {
9.+ IActionBars actionBars = fContainer.getActionBars();
10.+ if (actionBars==null&&offset!=0&&!fContainerProvided){11. return Utilities.findActionBars(fComposite, offset);12. }
13.- return fContainer.getActionBars();14.+ return actionBars;15. }
16. public ISLocator getServiceLocator (int offset2) {
17.- if (fContainer == null) {
18.+ ISLocator sLocator = fContainer.getServiceLocator();19.+ if(sLocator == null&&offset2!=0&&!fContainerProvided){20. return Utilities.findSite(fComposite, offset2);21. }
22.- return fContainer.getServiceLocator();23.+ return sLocator;24. }
25.}
Fig. 1. An example of systematic changes based on org.eclipse.compare.-
CompareEditorInput from revisions v20061120 and v20061218
1. … …method_declaration(… …) {/nonmarkingreturn
2.    … …/nonmarkingreturn3.    INSERT: T$0 v$0 = fContainer.m$0(); /nonmarkingreturn4.    UPDATE: if (fContainer == null) {/nonmarkingreturn/nonmarkingreturn5.        TO: if (v$0==null && v$1!=0 && !fContainerProvided){/nonmarkingreturn6.      … …/nonmarkingreturn7.    }  /nonmarkingreturn8.    UPDATE: return fContainer.m$0();/nonmarkingreturn /nonmarkingreturn9.        TO: return v$0;/nonmarkingreturn10.}
Fig. 2. Abstract edit script inferred by L ASE
1. T$0 v$0 = fContainer.m$0();
2. if (v$0==null && v$1!=0 && !fContainerProvided) {
3. return Utilities.m$1(fComposite, v$1);4. }
5. return v$0;
Fig. 3. Abstract refactoring template of common code created by R ASE
The script describes abstractly the edit applied to both meth-
ods. It represents edit operations with AST node inserts,updates, moves, and deletes. Figure 2 shows the inferredabstract edit script for this example.
Given an edit script, RASE identiﬁes edited statements
related to the systematic changes. It uses the ranges of edits toscope its automated factorization and generalization, extractingthe maximum common contiguous clone which encompassesall systematically edited statements. If similar edits are sur-rounded by cloned statements, RASE expands the refactoringscope to the entire method. For our example, in Figure 1,
R
ASE selects lines 9-12, 14, 18-21, and 23 to refactor. Note
that R ASE includes the unchanged lines 11-12 and 20-21 in
order to extract syntactically valid ifstatements.
Next, R ASE creates an abstract refactoring template for the
selected code snippets by matching expressions and identiﬁersbetween them, as shown in Figure 3. It uses the original codewhen identiﬁers or expressions are identical and otherwiseabstracts them (e.g.,
offset vs.offset2 ). It records a map
of abstract names to their original concrete identiﬁers andexpressions to use later.
393
393
393
ICSE 2015, Florence, ItalyBased on the template, R ASE creates an executable refactor-
ing plan and applies it to transform code, as shown in Figure 4.
RASE performs a parameterize type refactoring because the
type variation T$0 must be handled to work correctly for
the different type variables. The method variations m$0 and
m$1require a form template method refactoring to invoke the
correct methods depending on the callers. The variation in the
use of a variable name v$1requires the corresponding variable
to be passed as a parameter to the extracted method. Thevariable wildcard
v$0does not need such processing, because
the variable is locally deﬁned and used, and thus invisible tothe extracted method’s callers. R
ASE performs static analysis
that determines identiﬁer scopes to differentiate these cases.
III. O PPORTUNISTIC REFACTORING
RASE takes systematically edited methods as input. It works
in two phases. Phase I scopes code regions for refactoring,analyzes variations between them, and outputs an abstract
refactoring template. Phase II constructs and then applies anexecutable refactoring plan by handling type, method, variable,and expression variations in the template and by analyzingcontrol ﬂow, data ﬂow, and the class hierarchies of originalmethods. R
ASE uses a combination of six different refactoring
operations to extract common code and parameterize differ-ences while preserving semantics.
A. Phase I: Abstract Template Creation
We use L
ASE to create an abstract edit script that describes the
input systematic changes [23]. L ASE represents the difference
between before and after versions with AST node inserts,
deletes, updates, and moves. It then extracts the commonchanges among all methods, and creates a generalized programtransformation. We call this transformation an abstract edit
script. It contains a code pattern describing the context wherethe edit is applicable, and a list of edit operations describinghow to make the edit. It also abstracts identiﬁers used inthe exemplar edits to generally represent those edits eventhough they manipulate different identiﬁers. Figure 2 showsan exemplar edit script.
To refactor code undergoing systematic edits, R
ASE iden-
tiﬁes the maximum code clone enclosing the edit in eachmethod’s new version. R
ASE requires contiguity in the code
clones, thus it identiﬁes a single AST node (and all its childsubtrees) or a set of contiguous subtrees under the same parentnode. These restrictions guarantee that there is only one entryto the code region and the cloned code can be extracted asa method. The maximum code clone identiﬁcation algorithmconsists of three steps: merge, abstract, and expand.
1) Merge: R
ASE creates an initial subtree set by identifying
all trees rooted at the edited code. For instance, if a return-statement is edited, R
ASE selects the return-statement itself.
However, given an edited condition in an if-statement, R ASE
selects the if-statement, which includes the conditional andthe subtrees rooted at the then-branch and else-branch. It thencreates a contiguous region of AST nodes by merging treesuntil there is a single tree left or a sequence of adjacentNewly created classes and methods through clone removal
1. public abstract class TemplateClass<T0>{
2. public T0 extractMethod(int v1, Splitter fComposite,3. ICompareContainer fContainer,4. boolean fContainerProvided){5. T0 v0 = m0(fContainer);6. if (v0 == null && v1 != 0 && !fContainerProvided){7. return m1(fComposite, v1);8. }
9. return v0;10. }
11. public abstract T0 m0(ICompareContainer fContainer);12. public abstract T0 m1(Splitter fComposite, int v1);13.}14.public class ConcreteTemplateClass0 extends15. TemplateClass<IActionBars>{16. public IActionBars m0(ICompareContainer fContainer){17. return fContainer.getActionBars();18. }
19. public IActionBars m1(Splitter fComposite, int v1){20. return Utilities.findActionBars(fComposite, v1);21. }
22.}23.public class ConcreteClass1 extends24. TemplateClass<ISLocator>{25. public ISLocator m0(ICompareContainer fContainer){26. return fContainer.getServiceLocator();27. }
28. public ISLocator m1(Splitter fComposite, int v1){29. return Utilities.findSite(fComposite, v1);30.}}
Modiﬁcations to the original methods
1. public class CompareEditorInput {
2. private ICompareContainer fContainer;3. private boolean fContainerProvided;4. private Splitter fComposite;5. public IActionBars getActionBars (int offset) {
6. if (offset == -1)7. return null;8. return new ConcreteTemplateClass0().extractMethod(9. offset, fComposite, fContainer,10. fContainerProvided);11. }
12. public ISLocator getServiceLocator (int offset2) {
13. return new ConcreteTemplateClass1().extractMethod(14. offset2, fComposite, fContainer,15. fContainerProvided);16.}}
Fig. 4. Code refactoring based on systematic edits
ones under the same parent node in the set. The merging
algorithm picks two subtrees, T1and T2with the longest
paths from the root, such as path( Root, N 1,N2,T1)and
path( Root, N 1,N3,T2). Note that N1,N2, and N3represent
parent and ancestor nodes of T1orT2.R ASE identiﬁes the
lowest common ancestor where the two paths diverge, N1in
this case. Next, it adds all subtrees of N1, such as trees rooted
atN2andN3, into the set of extractable code. For conciseness,
it also moves the original T1andT2out of the set because they
are now covered by the newly added trees. In this way, R ASE
makes the code regions to extract closer to each other. Bymerging subtrees iteratively, R
ASE ﬁnally forms the minimum
contiguous code region involved in the edit.
RASE relies on systematic edits to scope refactoring. If a
systematic edit only deletes code or it cannot ﬁnd edited codein any method’s new version, R
ASE will not refactor.
2) Abstract: RASE then tries to create an abstract template
to guide further refactoring. To successfully create such atemplate, R
ASE requires that (a) the code regions extracted
from different methods have the same number of statements,
394
394
394
ICSE 2015, Florence, Italyand (b) the statements are either identical or differ only in their
use of types, methods, variables, and expressions. Requirement(a) guarantees that the template reﬂects the skeleton of allextracted code. Requirement (b) guarantees that we extractsyntactically similar code.
R
ASE abstracts any differences in type names, method invo-
cations, variable names, and expressions in the target methodsby using wildcards
T$,m$,v$andu$respectively. It attempts
to establish a mapping between each concrete identiﬁer and theabstract version, making sure all methods consistently use anddeﬁne these identiﬁers. If not, R
ASE does not refactor them.
This analysis checks for syntactic equivalence and consistentdef-use relations between the methods.
3) Expand: To extract as much common code as possi-
ble between similarly changed methods, R
ASE expands the
identiﬁed code clones by tentatively including the subtrees’parent nodes or siblings. For instance, if the identiﬁed codeclones from different methods have similar parent nodes aswell as siblings, R
ASE expands the refactoring scope to the
tree rooted at the parent node, and then updates the abstracttemplate without invalidating any established concrete-abstractmappings. R
ASE applies Steps 3) and 2) iteratively until no
more common code is appended.
B. Phase II: Clone Removal Refactoring
Based on the abstract template and identiﬁer mappings de-
scribed in the previous section, R ASE leverages control and
data ﬂow analysis to determine how to extract common codeand parameterize differences without altering semantics. Itcreates and applies an executable refactoring plan, whichconsists of one or more of these six refactoring operations:
•extract method extracts common code into a method.
•add parameter handles variations in variables and ex-
pressions.
•parameterize type handles variations in types.
•form template method handles variations in method
calls.
•introduce return object handles multiple output vari-
ables of extracted code.
•introduce exit label preserves control ﬂow in the original
code.
Type V ariations: Given a type wildcard ( T$)i nt h e
abstract template, R ASE applies a parameterize type refac-
toring. It declares a generic type for the newly created classand modiﬁes each original location to call the extractedmethod with type parameters. We deﬁne this new term becauseFowler’s catalog does not include it and current refactoringengines, such as Eclipse, do not support it. Figure 5 shows anexample. When the target code differs in terms of type identi-ﬁers, R
ASE adds explicit type parameters to the new extracted
method. The applicability of this refactoring is affected bylanguage support for generic types. In our implementation forJava, the refactoring is not applicable, when any parameterizedtype creates an instance by calling its constructors (e.g.,
new
T()), performs an instanceof check (e.g., v instanceof T )
or gets the type literal (e.g., T.class ), because Java does notpublic void mA(IC c){    /nonmarkingreturn
  …/nonmarkingreturn  Insert e = getEdit(c);/nonmarkingreturn  …/nonmarkingreturn}/nonmarkingreturnpublic void mB(RC c){/nonmarkingreturn  …/nonmarkingreturn  Remove e = getEdit(c);/nonmarkingreturn  …/nonmarkingreturn}Code to extract
Code to extractclass C<T0, T1>{/nonmarkingreturn  public void extractMethod(     T1 c){/nonmarkingreturn    …/nonmarkingreturn    T0 e = getEdit(c);/nonmarkingreturn    …/nonmarkingreturn  }/nonmarkingreturn}/nonmarkingreturnpublic void mA(IC c){/nonmarkingreturn  new C<Insert,IC>()/nonmarkingreturn     .extractMethod(c);/nonmarkingreturn}/nonmarkingreturnpublic void mB(RC c){/nonmarkingreturn  new C<Remove, RC>/nonmarkingreturn     .extractMethod(c);/nonmarkingreturn}T$1 e = getEdit(c);
Generalize
Fig. 5. Parameterize type refactoring
public void add(){    /nonmarkingreturn  …/nonmarkingreturn  input.addCompareInput();/nonmarkingreturn  …/nonmarkingreturn}/nonmarkingreturnpublic void remove(){/nonmarkingreturn  …/nonmarkingreturn  input.removeCompareInput();/nonmarkingreturn  …/nonmarkingreturn}abstract class Template{/nonmarkingreturn  public void extractMethod(/nonmarkingreturn     …){/nonmarkingreturn    …/nonmarkingreturn    m(input);/nonmarkingreturn    …/nonmarkingreturn  }/nonmarkingreturn  public abstract void m(/nonmarkingreturn     Input input);/nonmarkingreturn}/nonmarkingreturnclass Add extends Template{/nonmarkingreturn  public void m(Input input){/nonmarkingreturn    input.addCompareInput();/nonmarkingreturn  } }/nonmarkingreturnclass Rem extends Template{/nonmarkingreturn  public void m(Input input){/nonmarkingreturn    input.removeCompareInput();  }/nonmarkingreturn}/nonmarkingreturnpublic void add(){/nonmarkingreturn  new Add().extractMethod(…);/nonmarkingreturn}/nonmarkingreturnpublic void remove(){/nonmarkingreturn  new Rem().extractMethod(…);/nonmarkingreturn
Code to extract
Code to extract
input.m$1();Generalize
Fig. 6. Form template method refactoring
public void foo(){    /nonmarkingreturn  …/nonmarkingreturn  String str1 = …;/nonmarkingreturn  …/nonmarkingreturn  String str2 = …;/nonmarkingreturn  System.out.println(str1 + str2);/nonmarkingreturn} Code to extractclass RetObj{/nonmarkingreturn  public String str1;/nonmarkingreturn  public String str2;/nonmarkingreturn  public RetObj(String str1, String str2){/nonmarkingreturn    this.str1 = str1;/nonmarkingreturn    this.str2 = str2;/nonmarkingreturn  }/nonmarkingreturn}/nonmarkingreturnpublic RetObj extractMethod(…){/nonmarkingreturn  …/nonmarkingreturn  return new RetObj(str1, str2);/nonmarkingreturn}/nonmarkingreturnpublic void foo(){/nonmarkingreturn  RetObj retObj = extractMethod(…);/nonmarkingreturn  String str1 = retObj.str1;/nonmarkingreturn  String str2 = retObj.str2;/nonmarkingreturn  System.out.println(str1 + str2);/nonmarkingreturn
Fig. 7. Introduce return object refactoring
public void bar(){    /nonmarkingreturn  while(!stack.isEmpty()){/nonmarkingreturn    … /nonmarkingreturn    elem = stack.pop();/nonmarkingreturn    if(elem == null)/nonmarkingreturn      continue;/nonmarkingreturn    if(elem.equals(known))/nonmarkingreturn      break;/nonmarkingreturn    push(elem.next());/nonmarkingreturn  }/nonmarkingreturn}Code to extractenum Label{CONTINUE, BREAK, FALLTHRU};public Label extractMethod(…){/nonmarkingreturn  …/nonmarkingreturn  elem = stack.pop();/nonmarkingreturn  if(elem == null)/nonmarkingreturn    return Label.CONTINUE;/nonmarkingreturn  if(elem.equals(known))/nonmarkingreturn    return Label.BREAK;/nonmarkingreturn
  return Label.FALLTHRU;/nonmarkingreturn
}/nonmarkingreturn
public void bar(){/nonmarkingreturn
  while(!stack.isEmpty()){/nonmarkingreturn    Flag flag = extractMethod(…);/nonmarkingreturn    if(flag.equals(Label.CONTINUE))/nonmarkingreturn      continue;/nonmarkingreturn    else if(flag.equals(Label.BREAK))/nonmarkingreturn      break;/nonmarkingreturn    push(elem.next());/nonmarkingreturn  }/nonmarkingreturn}
Fig. 8. Introduce exit label refactoring
support these cases. Even if developers may handle such cases
manually with smart tricks, the resulting refactored code wouldhave poor readability.
Method Call V ariations: Given a method wildcard (
m$)
in the abstract template, R ASE applies the form template
method (pg. 345 in [7]) refactoring. It creates uniform APIs
that encapsulate the variations and changes the extractedmethod to invoke these APIs instead. Figure 6 shows an
395
395
395
ICSE 2015, Florence, Italyexample. R ASE declares an abstract class which contains
the extracted method and a sequence of abstract methods.
Each abstract method corresponds to a method wildcard. Foreach original location, the refactoring declares a concreteclass extending the abstract class so that all abstract methodsare implemented to call the correct corresponding concretemethods. Each original location is modiﬁed to invoke theextracted method with the corresponding concrete class.
When a method wildcard represents a non-static method
and is invoked via an object (e.g.,
input.m$1() ), the cor-
responding method is declared to place the receiver ob-ject (e.g.,
input ) as an argument (e.g., m1(Input input )).
Then the actual method (e.g., input.addCompareInput() or
input.removeCompareInput() ) is invoked correctly inside
each newly deﬁned method. If any of the variant methodsdoes not have a modiﬁer
public in its method declaration, the
refactoring is not applied, because the method is not accessibleby newly deﬁned methods in the template class. If variantmethods have different numbers of parameters, e.g.,
foo(int
offset) vs.bar(Object obj, boolean flag) , the refactoring
is not applied. Although it is possible to create a long methodsignature by merging different input signatures, we believe theresulting code is too hard to read.
V ariable and Expression V ariations: Given variations in
variable names and expressions, R
ASE uses an add parameter
(pg. 275 in [7]) refactoring. We use data dependence analysisto identify variables which have local uses but no local deﬁ-nitions in the extracted code. We consider variable wildcards(
v$) as candidates for input arguments of the extracted method.
For each variable wildcard, we check whether it is purely localto the extracted code, meaning that it is declared, deﬁned,and used only in the extracted code. If so, R
ASE assigns it a
concrete identiﬁer and does not include the variable as an inputparameter, since it is invisible to caller methods. For example,
R
ASE declares the variable v$1in Figure 3 as a parameter but
does not include v$0because it is purely local.
We consider expression wildcards ( u$) as candidates for
input arguments of the extracted method. Since the wild-cards map to different AST node type expressions indifferent methods, each caller can pass appropriate ex-pressions as arguments. For instance, if
u$is mapped
togetConfiguration() in one method, but is mapped
tofCompareEditorInput.getConfiguration() in another
method, R ASE compares the types of both expressions. If the
types are the same, it declares an input parameter with thecommon type. If the types are different, R
ASE records the type
mapping and later applies parameterize type refactoring to
accommodate the variation. Compared with prior work [3, 14],which solves expression variations by declaring new methods,our approach creates cleaner code by avoiding extra methoddeclarations and invocations.
Return V alue: R
ASE uses data dependence analysis to
determine the variables that have local deﬁnitions and externaluses. It converts these variables to output variables of theextracted method. When there is more than one such variable,
R
ASE applies introduce return object refactoring. As shownin Figure 7, R ASE encapsulates all return values into one
object and inserts code at each call site to read appropriateﬁelds of the returned object. Fowler’s catalog does not includethis refactoring and current refactoring engines do not supportit.
Control Flow: R
ASE uses control ﬂow analysis to deter-
mine the statements that exit the code in addition to the fall-through exit in the extracted code, such as a
return ,break ,o r
continue . These non-local jump nodes either terminate execu-
tion or jump execution from one location to another. Naivelyputting them in the extracted method may cause compilererrors or incorrect control ﬂow. R
ASE applies introduce exit
label refactoring to correctly implement non-local jumps. It
replaces non-local jumps with exit label return statements andmodiﬁes each original location to interpret the return labels.Fowler’s catalog does not include this refactoring, nor is itimplemented in current refactoring engines, such as Eclipse.We borrow the approach from Komondoor and Horwitz’sprior work on automated procedure extraction [19]. Figure 8shows an example with multiple exits. R
ASE replaces a non-
local jump statement with a return statement to terminatethe execution of the current method and adds a return labelindicating the exit type. R
ASE inserts code at each call site to
handle non-local jumps correctly.
Placing Extracted Code: RASE uses class hierarchy
analysis to discover the relationship between classes declaringthe originally edited methods. The relationships help R
ASE
decide where to put the extracted method, and which inputparameters or output variables to add. For instance, if thesystematically changed methods are in the same class andthere are no method or type wildcards in the abstract template,
R
ASE places the extracted method in the same class. If the
methods are in sibling classes extending the same super class,
RASE puts the extracted method into their common super
class. If the methods are in classes which do not have any typehierarchy relation, R
ASE must put the extracted method into a
newly declared class. All ﬁelds that the extracted code readsfrom or writes to should be passed as input parameters andoutput variables separately, since they may not be accessibleto the extracted method deﬁned by the newly deﬁned class.For correctness, R
ASE checks that (1) all methods invoked by
the extracted method are declared as public , and (2) none of
the method calls are unmovable, such as super() .
IV . E V ALUATION
This section evaluates R ASE with systematic editing tasks.
It explores if automated refactoring eliminates the need forsystematic editing and if systematic editing guides the scopeof refactoring better or worse than method clones. It also takesa ﬁrst look at whether automated refactoring is desirable whenit is feasible.
Our data set consists of 56 similarly changed method pairs
and 30 similarly changed method groups. These real-worldsystematic editing tasks are drawn from version historiesof
JEdit , Eclipse compare ,jdt.core ,core.runtime ,debug ,
JFreeChart andelasticsearch . The method pairs are drawn
396
396
396
ICSE 2015, Florence, Italyfrom prior evaluation of systematic editing [23, 24]. Each pair
of methods have at least 40% syntactic similarity and shareat least one common AST edit operation. Most are multi-lineedits and require identiﬁer abstraction. Each method groupcontains at least three similarly changed methods. The data isavailable at http://cs.utexas.edu/˜mengna09/projects.html.
We use four variants of refactoring for our evaluation. The
default R
ASE refactors as much code as possible given a
systematic edit. R ASE minchooses the smallest amount of code
that includes the systematic edit. R ASE MArefactors the entire
method after the edit and R ASE MBrefactors the entire method
before the edit. We apply R ASE and its variants to the test
suites. Table I and Table II present the results.
In the tables, each task has a unique identiﬁer ID. If a task is
automatically refactored, we characterize the refactoring withedit operations (edits), refactoring types, and resulting code
size change (Δcode). R
ASE applies the following six refac-
toring types: E: extract method, R: introduce return object, L:introduce exit label, T: parameterize type, F: form templatemethod, and A: add parameter. N/A means refactoring isnot automated. We omit pairs with no refactoring in anyconﬁguration. In Δcode size column, a positive number
means that refactoring increases the code size and a negativenumber means that code size decreases.
A. Method Pairs
Default R
ASE (columns 2-4) automatically refactors 30 out of
56 cases. R ASE MA(columns 5-7 in the middle) is restricted
to the method scope after edits and automates refactoring for
nineteen cases, a strict subset of those refactored by R ASE.
RASE MB (columns 8-10 on the right) automates refactoring
of methods before editing for eighteen cases, all of which arerefactored by both R
ASEand R ASE MA. These 18 method pairs
are clones, which experience similar changes and produceclones. Case 2 is not handled by R
ASE MB, because the origi-
nal version has no statements in the method and thus no clonescan be extracted. This comparison shows that systematic editsbetter scope refactoring and increase refactoring opportunitiescompared to applying clone removal to the entire methodseither before or after edits.
R
ASE min extracts the minimum common code enclosing
systematic edits, as opposed to the maximum common codein default R
ASE. If we mark the minimum common code for
extraction, we may have fewer variations between counter-parts, which may cause less extra code added as necessary forspecialization. On the other hand, we may extract less codethan the actual commonality shared between changed methods,leaving redundant code after refactoring. The comparisonbetween R
ASE min and R ASE shows that R ASE min performs
differently from R ASE in eight cases. In seven of the eight
cases, R ASE minis less effective at reducing code size because
less common code is extracted. However in case 9, R ASE min
reduces code size more, because the extracted method doesnot include control ﬂow jumps, which eliminates the need forcode to interpret various ﬂow jumps.TABLE III
REASONS RASE DOES NOT REFACTOR 26CASES :M ETHOD PAIRS
Reason number of cases
Limited language support for generic types 7
Unmovable methods 5
No edited statement found 8
No common code extracted 6
TABLE IV
REASONS RASE DOES NOT REFACTOR 10CASES :M ETHOD GROUPS
Reason number of cases
Limited language support for generic types 2
Unmovable methods 0
No edited statement found 2
No common code extracted 6
In 6 out of the 30 cases, R ASE only uses the extract method
to perform its refactoring tasks. All the other cases need acombination of different types of refactoring. The code sizechange varies between an increase of 11 lines and a decreaseof 47 lines. R
ASE’s automated refactoring reduces the code
size in eight cases (27%) for the method pairs.
B. Method Groups
To explore whether our conclusions based on method pairs
generalize to multiple similarly changed methods, we apply
RASE to 30 systematically edited method groups. Each group
contains at least three methods and at most nine methods.We apply R
ASE MA,RASE MB, and R ASE min to the same
data set and compare refactoring capabilities. The results aremostly similar comparing Table I and Table II. The columnlabeled #in Table II shows the number of changed methods
in each group. R
ASE refactors 20 out of 30 cases. Similar
to Table I, we observe that R ASE automates refactoring more
than R ASE MA and R ASE MB.RASE produces more concise
code than R ASE minin 6 out of 30 cases. One difference from
the method pair results is that R ASE decreases code size more
consistently and frequently, reducing code size in 14 of the20 refactored cases (70%) and on average reducing code byeight lines. This result is expected because the refactored codeappears in just two methods with method pairs, whereas formethod groups, the refactored code originally appears in threeor more methods.
C. Reasons for Not Refactoring
We examined by hand the 26 method pairs that R
ASE did not
refactor and found four reasons, which Table III summarizes.
For seven cases, R ASE failed to refactor due to Java’s limited
support for generic types. It is very difﬁcult to convert somegeneralized statements like
v instanceof T$ ,T$.m$() , and v
= new T$() , into code that compiles.
For ﬁve cases, R ASE did not refactor because some state-
ments cannot be moved correctly into an extracted method.For instance, the super constructor
super(...) is only valid
in constructors and cannot be moved to any other method.
397
397
397
ICSE 2015, Florence, ItalyTABLE I
METHOD PAIRS :CLONE REMOV AL REFACTORINGS
RASE RASE min RASE MA RASE MB
ID edits types Δcode edits types Δcode edits types Δcode edits types Δcode
2 15 E, A -1 15 E, A -1 15 E, A -1 N/A
4 6E , A 2 6E , A 2 6E , A 2 6E 2
6 14 E, F 10 14 E, F 10 14 E, F 10 31 E, F 11
9 77 E, R -7 61 E -15 N/A N/A
10 24 E -4 20 E, L 8 24 E -4 15 E -1
11 20 E, F 8 20 E, F 8 20 E, F 8 14 E, F 10
12 31 E, F 11 31 E, F 11 31 E, F 11 14 E, F 10
13 38 E, F 2 32 E, F 4 38 E, F 2 29 E, F 5
18 42 E -10 7E 3 N/A N/A
19 61 E -15 21 E, R 13 61 E -15 61 E -15
22 285 E, F -47 285 E, F -47 285 E, F -47 288 E, F -48
29 56 E, L, R 4 45 E, L, R 9 N/A N/A
32 9E , A 1 6E 2 N/A N/A
34 24 E, A -4 24 E, A -4 N/A N/A
35 9E 1 9E 1 N/A N/A
36 36 E, A -8 36 E, A -8 N/A N/A
38 16 E 0 12 E 0 N/A N/A
40 20 E, L 8 20 E, L 8 N/A N/A
45 6E 2 6E 2 N/A N/A
46 6E , A 2 6E , A 2 6E , A 2 6E 2
47 20 E, L, R 8 20 E, L, R 8 N/A N/A
48 25 E, F, T 13 25 E, F, T 13 25 E, F, T 13 25 E, F, T 13
49 25 E, F, T 13 25 E, F, T 13 25 E, F, T 13 25 E, F, T 13
50 25 E, F, T 13 25 E, F, T 13 25 E, F, T 13 25 E, F, T 13
51 25 E, F, T 13 25 E, F, T 13 25 E, F, T 13 25 E, F, T 13
52 25 E, F, T 13 25 E, F, T 13 25 E, F, T 13 25 E, F, T 13
53 31 E, F 11 31 E, F 11 31 E, F 11 28 E, F 12
54 31 E, F 11 31 E, F 11 31 E, F 11 28 E, F 12
55 31 E, F 11 31 E, F 11 31 E, F 11 28 E, F 12
56 31 E, F 11 31 E, F 11 31 E, F 11 28 E, F 12
Average 35.5 2.4 31.5 4.1 39.4 4.0 38.9 4.9
Total automated 30 30 19 18
TABLE II
METHOD GROUPS :CLONE REMOV AL REFACTORINGS
RASE RASE min RASE MA RASE MB
ID # edits types Δcode edits types Δcode edits types Δcode edits types Δcode
16 137 E, A, F, T -7 137 E, A, F, T -7 137 E, A, F, T -7 137 E, A, F, T -7
24 30 E -10 30 E -10 30 E -10 10 E 2
43 17 E -1 10 E, A 4 N/A N/A
57 36 E, T -6 16 E 2 N/A N/A
68 42 E, T -6 42 E, T -6 N/A N/A
83 44 E, A, F -4 44 E, A, F -4 44 E, A, F -4 32 E, A, F 2
95 58 E, L, R 18 58 E, L, R 18 N/A N/A
10 3 38 E, F 14 38 E, F 14 38 E, F 14 19 E, A, F 13
11 4 20 E -4 10 E 2 N/A N/A
13 3 9E 3 9E 3 N/A N/A
15 3 32 E, A -10 28 E -8 N/A N/A
17 3 21 E -3 9E 3 N/A N/A
18 3 37 E -11 37 E -11 37 E -11 25 E -5
19 3 96 E, F 6 48 E, F, R 24 96 E, F 6 29 E, A, F, T 13
24 3 59 E, R -1 59 E, R -1 59 E, R -1 8E 2
25 3 26 E, R 14 26 E, R 14 N/A N/A
27 4 20 E, A -4 20 E, A -4 N/A N/A
28 3 24 E, T 0 24 E, T 0 24 E, T 0 12 E, A, T 0
29 9 211 E -149 211 E -149 N/A N/A
30 4 26 E, A -6 26 E, A -6 26 E, A -6 15 E, A, T 7
Average 49.2 -8.4 44.1 -6.1 54.5 -2.1 31.9 3.0
Total automated 20 20 9 9
Cases IDs from Meng et al. R ASE by default includes as much code as possible. R ASE min chooses the smallest scope that includes the systematic edit.
RASE MA refactors the entire method after the edit and R ASE MB refactors the entire method before the edit. The edits column is AST statement edit
operations for refactoring. Refactoring types are: E: extract method, R: introduce return object, L: introduce exit label, T: parameterize type, F: form
template method, and A: add parameter. R ASE uses all the refactoring types in many combinations. Both tables show R ASE automates refactoring in many
cases: 30 out of 56 pairs, and 20 out of 30 method groups, but not all. Systematic edits scope clone removal opportunities better (R ASE and R ASE min)
than methods (R ASE MA and R ASE MB).
398
398
398
ICSE 2015, Florence, ItalyAnother example is, when attempting to put an extracted
method into a newly declared class, calls to private methods
by the extracted method are not semantically valid because
private methods are only accessible for methods deﬁned in
the same class.
For eight cases, no edited statement is identiﬁed in the new
version of each changed method. R ASE depends on L ASE to
create an abstract edit script representing the input systematicchanges. If L
ASE fails to create such an edit script or the edit
script only deletes statements from old versions, R ASE cannot
locate code to extract, nor can it automate refactorings.
In six cases, the marked code snippets in different
methods are not generalizable to create an abstracttemplate. Four possible reasons explain this result. First,the code snippets contain different numbers of statements.Although some existing clone removal refactoring techniquesleverage program dependence analysis and heuristics toshift irrelevant variant code and put together extractablecode, these techniques cannot handle all the cases inthis category either, indicating the difﬁculty of fullyautomated refactoring [12, 21]. Second, the AST nodetypes of some extracted statements do not match, suchas
ExpressionStatement vs.ReturnStatement . Third, the
number of parameters in method calls do not match, such as
foo(v) vs.bar(a, b, c) . Although we may create a single
method by merging input signatures of different methods, theresulting code may have poor readability. Fourth, there is atleast one identiﬁer mapping conﬂict. For instance, identiﬁer
vis mapped to an identiﬁer ain one statement, but mapped
to another identiﬁer xin another statement. Ignoring these
conﬂicts to apply refactoring would incorrectly modify theprogram semantics. Similar to Table III, Table IV showsthat limited language support for generic types, no editedstatement, and no common code extracted are the three mainreasons.
In summary,
•Clone removal refactoring does not eliminate the need for
systematic editing.
•Scoping refactoring based on systematic edits improvesrefactoring applicability over refactoring the entire meth-ods, either before or after the edits.
•Extracting the maximum common code, instead of theminimum common code, usually creates a refactoredversion with a smaller code size.
D. Software evolution after systematic edits
To understand how R
ASE’s refactoring recommendations cor-
relate with developer refactorings, we manually examine how
developers evolved methods after these systematic edits bygoing through the version histories. For our test suite, theaverage time interval in the version history, starting at thesystematic editing version and ending at the latest version, is1.3 years. Table V shows the results for method pairs and Ta-ble VI for method groups. The Feasible column corresponds
to cases when R
ASE can automate clone removal refactoring
and Infeasible corresponds to the rest. The Refactored rowTABLE V
MANUAL EV ALUATION OF VERSION HISTORY AFTER SYSTEMATIC EDITS :
METHOD PAIRS
Feasible Infeasible
Refactored 40
UnrefactoredCo-evolved 26
Divergent 31 0
Unchanged 21 10
TABLE VI
MANUAL EV ALUATION OF VERSION HISTORY AFTER SYSTEMATIC EDITS :
METHOD GROUPS
Feasible Infeasible
Refactored 10
UnrefactoredCo-evolved 21
Divergent 40
Unchanged 13 9
shows cases when developers either by hand or with the help ofsome other tool refactored code later in the version history. Theother rows break down cases without developer refactoring.Co-evolved means the methods are systematically edited
at least one more time in later versions and may indicatethat refactoring is desirable. Divergent means the methods
evolved in divergent ways and may indicate that refactoring isundesirable. For example, one method was deleted or only onemethod changed. Refactoring Unchanged methods may not
be worthwhile because they are quite stable or it is prematureto judge desirability due to lack of information.
Table V shows that developers only refactored 4 out of
56 cases. R
ASE automates refactoring for the same 4 cases.
Additionally, R ASE refactors 26 cases which were not refac-
tored by developers. In this test suite, 47 cases have versionhistories and 9 do not because they were specially craftedto test systematic editing [24]. Among these 26 cases notrefactored by developers, 21 had no code changes, includingthe 9 without version histories. When code does not need tochange to ﬁx bugs or add features, developers are unlikelyto aggressively remove clones. In 3 of 26 cases, developersevolved code differently by either changing both methodsdifferently or deleting only one of the two methods. In 2 of 26cases, developers did not refactor code for some reason, butsimilarly changed code once again. Such repetitive systematicedits on method pairs may indicate refactoring is desirable.
There are six cases in which methods were co-evolved by
developers but are not automatically refactored by R
ASE. The
major reason is the code invokes certain methods which arenot accessible by an extracted method, contain non-contiguouscloned code, or have conﬂicting identiﬁer mappings. It is noteasy to automatically refactor these cases. If developers wantto refactor them, they need to ﬁrst apply some tricks to makethe common code extractable.
Table VI summarizes the version history for systematically
edited method groups and shows similar results to the methodpairs in Table V. Developers refactored one case, which R
ASE
also handles. Methods co-evolved in two cases and divergedin four cases, all of which R
ASE can refactor. There is one
399
399
399
ICSE 2015, Florence, Italycase where methods were co-evolved by only deleting code,
but R ASE does not refactor in this case.
Manually observing the version history reveals that there is
no obvious correlation between the feasibility of R ASEenabled
refactoring and manual refactorings performed by developerson systematically edited code, although there are cases whenautomatic and manual refactoring overlaps. Whether develop-ers refactor or not, they do not base their decision solely oncode similarity and similar edits. They consider other factors,such as readability, code size, future plans for features, and bugﬁxes. Although R
ASE cannot decide for developers whether
to refactor or not, by creating an executable refactoring plan,when developers decide to refactor, it helps reduce developerburden when applying code transformations.
To explore the reasons developers do not refactor while per-
forming systematic edits, we randomly pick several examplesand ask project owners for their expert opinion.
One developer is conservative about aggressive refactoring
and merging commonality between methods: “(I will not
refactor because) this pair of methods is not a pain pointduring maintenance/evolution of JDT. That particular classis very stable, and the readability of the code as it is nowoutweighs potential beneﬁts of refactoring. We have otherduplications, that are more likely to cause pain, e.g., by beingforgotten during maintenance. ...I n these classes, potential
gain might be greater , but then a refactoring to avoid re-dundancy would certainly introduce a signiﬁcant amount ofadditional complexity. We don’t typically refactor unless wehave to change the code for some bug ﬁx or new feature. ”
Another developer refactors more proactively to reduce
cloned code, but prefers reducing four duplicated methodsto two, instead of the single method that R
ASE suggests to
simplify the class hierarchy.
The feedback from developers illustrates that the decision
to remove clones depends on many criteria including codesimilarity, co-evolution events, the effectiveness of cloned codein bug ﬁxing and feature additions, the software architecture,readability, and maintainability of the resulting refactoredcode.
Based on our experience with software version history
and communication with developers, we envision R
ASE as
a refactoring recommendation tool when developers thinkabout refactoring duplicated code. R
ASE will help further
research on recommendations and cost/beneﬁt analysis ofclone removal. R
ASEshould also serve to complement existing
systematic editing tools because developers do not always ag-gressively reduce duplicated code but often maintain redundantcode for various reasons.
V. T
HREATS TO VALIDITY
Our results are based on 86 systematic editing examples.Further evaluation with more subject systems, longer versionhistories, and larger scope of systematic edits beyond themethod level remains as future work.
The refactoring capability of R
ASE is affected by the sys-
tematic editing tool—L ASE—it uses. Given multiple similarlychanged methods, if L ASE fails to generalize an abstract
edit script for them, R ASE cannot provide any refactoring
suggestion. The six types of refactorings implemented in R ASE
do not cover all possible code transformations applicable toclone removal. However, it is the state-of-the-art in terms ofthe number of clone removal refactorings it automates.
When handling variations in expressions, we promote ex-
pressions as input parameters of an extracted method. If thepromoted expressions cause side effect, such as
i++,w em a y
alter semantics in some cases, although the alteration is notobserved in our test suites.
R
ASE determines concrete refactoring transformations
based on an abstract template without considering the globalcontext such as the extent of code duplication across the entirecodebase or the class relationship among methods. There-fore, R
ASE may not suggest the best possible transformation.
However, R ASE is the ﬁrst automated tool that mechanically
examines if systematic edits in multiple locations indicaterefactoring opportunities.
Our results focus on automated refactoring feasibility in-
stead of desirability. We leave developers to decide whether
to refactor or not. We believe that it is difﬁcult to choosebetween systematically editing methods and reducing clonesto edit a single copy. To assess refactoring desirability, therefactoring cost/beneﬁt analysis should account for factorssuch as how frequently future systematic edits may occur to ﬁxbugs and add features, whether complexity increases, whetherit is worthwhile to reduce future edits, and whether the relatedmethods are likely to change and/or diverge in the future.
VI. R
ELATED WORK
Systematic Editing. Systematic editing tools automatically
apply similar changes to multiple locations. Simultaneous textediting tools replicate the exact same users actions in one coderegion to other user-selected code regions [25, 30]. Clone-Tracker takes the output of a clone detector as input, mapscorresponding lines in the clones, and then echoes edits in oneclone to another upon a user’s request [6]. The Clever versioncontrol system monitors code clones, detects changes to them,and then recommends edit propagation among clones [27].
S
YDIT infers an abstract AST edit script from an exemplar
changed method and applies it to user-selected methods [24].
LASE generalizes a partially abstract, context-aware edit script
from multiple examples, uses the edit script to ﬁnd additionaledit locations, customizes the edit script to each new location,and then applies the result [23]. All these systematic editingtools automate repetitive changes to multiple locations, whichmay encourage the bad practice of creating and maintainingcode duplications.
Clone Removal Refactoring. Based on code clones detected
by various techniques [13, 15, 20], many tools identify or
rank refactoring opportunities [2, 9]–[11, 32]. For instance,Balazinska et al. [2] deﬁne a clone classiﬁcation scheme basedon various types of differences between clones and automatethe classiﬁcation to help developers assess refactoring oppor-tunities for each clone group. Higo et al. and Goto et al. rank
400
400
400
ICSE 2015, Florence, Italyclones as refactoring candidates based on coupling or cohesion
metrics [9, 11]. Others integrate evolution information insoftware history to rank clones that have been repetitivelyor simultaneously changed in the past [10, 32]. While thesetools detect refactoring opportunities for clones, they do notautomatically refactor code.
A number of techniques automate clone removal refactor-
ings by factorizing the common parts and by parameterizingtheir differences using a strategy design pattern or a form tem-
plate method refactoring [3, 12, 14, 21, 29]. Similar to R
ASE,
these tools insert customized calls in each original location touse newly created methods. Juillerat et al. automate introduce
exit label and introduce return object refactorings supported by
R
ASE [14]. However, for variable and expression variations,
Juillerat et al.’s approach and CloRT [3] deﬁne extra methodsto mask the differences, while R
ASE passes these variations
as arguments of the extracted method. CloRT was applied toJDK 1.5 to automatically reengineer class level clones. Similarto our results, they ﬁnd this reengineering effort led to anincrease in the total size of code because it created numeroussimple methods. Hotta et al. use program dependence analysisto handle gapped clones—trivial differences inside code clonesthat are safe to factor out and such that they can apply theform template method refactoring to the code [12]. Krishnan et
al. use PDGs of two programs to identify a maximum commonsubgraph so that the differences between the two programsare minimized and fewer parameters are introduced [21] .Unlike R
ASE, none of these tools handle type variations when
extracting common code.Automatic Procedure Extraction. Komondoor et al. extract
methods based on the user-selected or tool-selected statementsin one method [18, 19]. The extract method refactoring in
the Eclipse IDE requires contiguous statements, whereas thesetools handle non-contiguous statements. Program dependenceanalysis identiﬁes the relation between selected and unselectedstatements and determines whether the non-contiguous codecan be moved together to form extractable contiguous code.Similar to R
ASE, Komondoor et al. apply introduce exit label
refactoring to handle exiting jumps in selected statements [19].Tsantalis et al. extend the techniques by requiring developersto specify a variable of interest at a speciﬁc point only [31].They use a block-based slicing technique to suggest a programslice to isolate the computation of the given variable. Theseapproaches are only focused on extracting code from a singlemethod. Therefore, they do not handle extracting commoncode from multiple methods and resolving the differencesbetween them as R
ASE does.
Empirical Studies of Code Clones. Many empirical studies
on code clones ﬁnd that removing clones is not necessarynor beneﬁcial [1, 5, 8, 16, 17]. Bettenburg et al. report thatonly 1% to 3% of inconsistent changes to clones introducesoftware errors, indicating that developers are currently able toeffectively manage and control clone evolution [5]. Kim et al.observe that many long-lived, consistently changed clones arenot easy to refactor without modifying public interfaces [17].These empirical studies show that removing code clones isnot always necessary nor beneﬁcial. While these studies uselonger version histories or larger programs than our evaluation,none of these studies, automatically refactor code to removeclones, as we do in this paper. Our work thus improvesover their methodology by eliminating human judgment whendetermining the feasibility of edits.
VII. C
ONCLUSIONS
Similar edits in similar code may indicate an opportunity toremove redundancy. To investigate this question, we designand implement R
ASE, an automated refactoring tool that
consists of six clone removal refactoring techniques: extract
method, parameterize type ,form template method, and add
parameter to tackle variations in types, methods, variables,
and expressions respectively; and introduce exit label and
introduce return object to handle non-local jumps and multiple
output variables.
By applying R ASE to real-world systematic editing tasks,
we observe that R ASE improves refactoring feasibility by
refactoring the region surrounding systematic edits as opposedto refactoring the entire method. This ﬁnding corroboratesthe community’s understanding that the evolutionary charac-teristics of clones may be a better indicator for refactoringneeds than the clones themselves. Despite this improvement,automated refactoring is feasible only in 58% of the cases inour test suite. We show it is very difﬁcult to automate cloneremoval for the remaining 42%. Hand examination indicatesthat language, semantics, and lack of common code are mainreasons when refactoring is infeasible, while refactoring is notalways applied by developers even if refactoring is feasible.We conclude that developers need tool support for bothsystematic editing and automated refactoring.
While R
ASE automates clone removal based on systematic
edits, the decision of whether to refactor or not depends onmultiple complex factors such as readability, maintainability,and types of anticipated changes. Systematic edits serve onlyas one factor. Therefore, they are not sufﬁcient to indicateclone removal is desirable. However, we believe that R
ASE’s
automated refactoring capability will support further researchon refactoring cost/beneﬁt analysis and recommendations.
A
CKNOWLEDGMENTS
This work was supported in part by the National Science
Foundation under grants CCF-1149391, CCF-1117902, SHF-0910818, CCF-1018271, CCF-0811524, CNS-1239498, and aGoogle Faculty Award.
R
EFERENCES
[1] L. Aversano, L. Cerulo, and M. D. Penta. How clones are maintained:
An empirical study. In CSMR ’07, pages 81–90, 2007.
[2] M. Balazinska, E. Merlo, M. Dagenais, B. Lague, and K. Kontogiannis.
Measuring clone based reengineering opportunities. In METRICS, page
292, 1999.
[3] M. Balazinska, E. Merlo, M. Dagenais, B. Lague, and K. Kontogiannis.
Partial redesign of java software systems based on clone analysis. In
WCRE, page 326, 1999.
401
401
401
ICSE 2015, Florence, Italy[4] G. Bavota, A. De Lucia, A. Marcus, R. Oliveto, and F. Palomba.
Supporting extract class refactoring in eclipse: The aries project. In Pro-
ceedings of the 34th International Conference on Software Engineering,
2012.
[5] N. Bettenburg, W. Shang, W. Ibrahim, B. Adams, Y . Zou, and A. E.
Hassan. An empirical study on inconsistent changes to code clones atrelease level. In WCRE, pages 85–94, 2009.
[6] E. Duala-Ekoko and M. P. Robillard. Tracking code clones in evolving
software. In ICSE, pages 158–167, 2007.
[7] M. Fowler. Refactoring: Improving the Design of Existing Code.
Addison-Wesley Professional, 2000.
[8] N. G ¨ode. Clone removal: Fact or ﬁction? In IWSC, pages 33–40, 2010.
[9] A. Goto, N. Yoshida, M. Ioka, E. Choi, and K. Inoue. How to extract
differences from similar programs? a cohesion metric approach. InIWSC, pages 23–29. IEEE, 2013.
[10] Y . Higo and S. Kusumoto. Identifying clone removal opportunities based
on co-evolution analysis. In IWPSE, pages 63–67, 2013.
[11] Y . Higo, S. Kusumoto, and K. Inoue. A metric-based approach to
identifying refactoring opportunities for merging code clones in a javasoftware system. J. Softw. Maint. Evol., 20(6):435–461, 2008.
[12] K. Hotta, Y . Higo, and S. Kusumoto. Identifying, tailoring, and
suggesting form template method refactoring opportunities with programdependence graph. 2011 15th European Conference on Software
Maintenance and Reengineering, 0:53–62, 2012.
[13] L. Jiang, G. Misherghi, Z. Su, and S. Glondu. Deckard: Scalable and
accurate tree-based detection of code clones. In ICSE, pages 96–105,
2007.
[14] N. Juillerat and B. Hirsbrunner. Toward an implementation of the ”form
template method” refactoring. SCAM, 0:81–90, 2007.
[15] T. Kamiya, S. Kusumoto, and K. Inoue. CCFinder: A multilinguistic
token-based code clone detection system for large scale source code.TSE, pages 654–670, 2002.
[16] C. Kapser and M. W. Godfrey. ”cloning considered harmful” considered
harmful. In WCRE ’06: Proceedings of the 13th Working Conference on
Reverse Engineering, pages 19–28, Washington, DC, USA, 2006. IEEEComputer Society.
[17] M. Kim, V . Sazawal, D. Notkin, and G. Murphy. An empirical study of
code clone genealogies. In ESEC/FSE, pages 187–196, 2005.
[18] R. Komondoor and S. Horwitz. Semantics-preserving procedure extrac-
tion. In POPL, pages 155–169, 2000.
[19] R. Komondoor and S. Horwitz. Effective, automatic procedure extrac-
tion. In IWPC, pages 33–, 2003.[20] J. Krinke. Identifying similar code with program dependence graphs. In
WCRE, page 301, 2001.
[21] G. P. Krishnan and N. Tsantalis. Refactoring clones: An optimization
problem. ICSM, 0:360–363, 2013.
[22] E. Mealy, D. Carrington, P. Strooper, and P. Wyeth. Improving usability
of software refactoring tools. In Proceedings of the 2007 Australian
Software Engineering Conference, 2007.
[23] N. Meng, M. Kim, and K. McKinley. Lase: Locating and applying
systematic edits. In ICSE, page 10, 2013.
[24] N. Meng, M. Kim, and K. S. McKinley. Systematic editing: Generating
program transformations from an example. In PLDI, pages 329–342,
2011.
[25] R. C. Miller and B. A. Myers. Interactive simultaneous editing of
multiple text regions. In 2002 USENIX Annual Technical Conference,
pages 161–174, 2001.
[26] M. Mortensen, S. Ghosh, and J. Bieman. Aspect-oriented refactoring of
legacy applications: An evaluation. IEEE T
 rans. Softw. Eng., 2012.
[27] T. T. Nguyen, H. A. Nguyen, N. H. Pham, J. M. Al-Kofahi, and T. N.
Nguyen. Clone-aware conﬁguration management. In ASE, pages 123–
134, 2009.
[28] D. Silva, R. Terra, and M. T. Valente. Recommending automated
extract method refactorings. In Proceedings of the 22Nd International
Conference on Program Comprehension, 2014.
[29] R. Tairas and J. Gray. Increasing clone maintenance support by
unifying clone detection and refactoring activities. Inf. Softw. Technol.,
54(12):1297–1307, 2012.
[30] M. Toomim, A. Begel, and S. L. Graham. Managing duplicated code
with linked editing. In VLHCC, pages 173–180, 2004.
[31] N. Tsantalis. Identiﬁcation of extract method refactoring opportunities
for the decomposition of methods. J. Syst. Softw., 84(10):1757–1782,
2011.
[32] N. Tsantalis and A. Chatzigeorgiou. Ranking refactoring suggestions
based on historical volatility. In Proceedings of the 2011 15th European
Conference on Software Maintenance and Reengineering , pages 25–34,
Washington, DC, USA, 2011. IEEE Computer Society.
[33] S. A. Vidal and C. A. Marcos. Toward automated refactoring of
crosscutting concerns into aspects. J. Syst. Softw., 2013.
[34] N. Zazworka, C. Seaman, and F. Shull. Prioritizing design debt
investment opportunities. In Proceedings of the 2Nd Workshop on
Managing Technical Debt, 2011.
402
402
402
ICSE 2015, Florence, Italy