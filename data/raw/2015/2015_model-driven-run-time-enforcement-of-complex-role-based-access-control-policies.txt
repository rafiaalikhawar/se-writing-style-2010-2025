Model-Driven Run-Time Enforcement of
Complex Role-Based Access Control Policies∗
Ameni Ben Fadhel
University of Luxembourg
Luxembourg
ameni.benfadhel@uni.luDomenico Bianculli
University of Luxembourg
Luxembourg
domenico.bianculli@uni.luLionel C. Briand
University of Luxembourg
Luxembourg
lionel.briand@uni.lu
ABSTRACT
A Role-based Access Control (RBAC) mechanism prevents unau-
thorized users to perform an operation, according to authorization
policieswhicharedefinedontheuser’srolewithinanenterprise.
Several models have been proposed to specify complex RBAC poli-
cies.However,existingapproachesforpolicyenforcementdonot
fullysupportallthetypesofpoliciesthatcanbeexpressedinthese
models, which hinders their adoption among practitioners.
Inthispaperweproposeamodel-drivenenforcementframework
forcomplexpoliciescapturedbyGemRBAC+CTX,acomprehensive
RBAC model proposed in the literature. We reduce the problem
ofmakinganaccessdecisiontocheckingwhetherasystemstate
(fromanRBACpointofview),expressedasaninstanceoftheGem-
RBAC+CTXmodel,satisfiestheconstraintscorrespondingtothe
RBAC policies to be enforced at run time. We provide enforcement
algorithmsforvarioustypesofaccessrequestsandevents,anda
prototypetool(MORRO)implementingthem.Wealsoshowhow
to integrate MORRO into an industrial Web application. The evalu-
ation results show the applicability of our approach on a industrial
system and its scalability with respect to the various parameters
characterizing an AC configuration.
CCS CONCEPTS
•Security and privacy →Access control ;•Software and its
engineering →Model-driven software engineering;
KEYWORDS
role-basedaccess control,enforcement,policies,model-driven en-
gineering
ACM Reference Format:
Ameni Ben Fadhel, Domenico Bianculli, and Lionel C. Briand. 2018. Model-
Driven Run-Time Enforcement of Complex Role-Based Access Control
Policies.In Proceedingsofthe201833rdACM/IEEEInternationalConferenceon
Automated Software Engineering (ASE ’18), September 3–7, 2018, Montpellier,
∗This work has received funding from the European Research Council under the
European Union’s Horizon 2020 research and innovation programme (grant agree-
ment No 694277), from the Luxembourg National Research Fund (FNR) (grant No FN-
R/P10/03), and from the University of Luxembourg (grant “ReACP”).
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ’18, September 3–7, 2018, Montpellier, France
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.3238167France.ACM,NewYork,NY,USA, 11pages.https://doi.org/10.1145/3238147.
3238167
1 INTRODUCTION
Access control (AC) systems have been used to restrict a user to
accesscriticalresourceswithinanenterprise.Oneofthemostused
ACmodelsisRole-basedAccessControl(RBAC),whichallowsa
usertoaccessa resourceortoperformanoperationbased onher
role, e.g., her job position within an enterprise.
The first RBAC model (RBAC96 [ 43]) defines (authorization)
policiesby mapping each user to a set of roles and each role to
a set of permissions; a permission is defined as an abstraction of
a set of operations that can be performed on a set of objects, i.e.,
resources.Therefore,auserisallowedtoperformonlytheopera-
tionsofthepermissionsassociatedwithherrole.Severalproposals
haveextendedRBAC96tosupportnewtypesofpolicies,suchas
delegation[ 18,46,54,56]andcontextual[ 3,9,10,28,42].Inaddi-
tion toextended RBACmodels, severalpolicy languageshave been
proposed to ease the specification of complex RBAC policies on
top of these models. In this paper we consider our recent proposal
ofanRBACmodel,calledGemRBAC+CTX[ 6,8],whichhasbeen
designed to be very expressive, by seamlessly integrating the vari-
oustypesofauthorizationpoliciessurveyedintheliteratureand
classifiedinataxonomy[ 6].Tothebestofourknowledge,theGem-
RBAC+CTXmodelistheonlyonesupporting allthepoliciestypes
classifiedin[ 6](prerequisite[ 2,43],cardinality[ 1],precedenceand
dependency[ 44],rolehierarchy[ 43],separationofduty(SoD)[ 45],
binding of duty (BoD) [ 48], delegation and revocation [ 18,54],
contextual [ 10,28]) and their different facets. Moreover, GemR-
BAC+CTXispairedwithahigh-levelpolicyspecificationlanguage,
GemRBAC-DSL [ 7], to encourage its adoption among practition-
ers. We formalized the policies supported by GemRBAC+CTX as
OCL(ObjectConstraintLanguage[ 39])constraints[ 6,8],toenable
theiroperationalization.Followingamodel-drivenapproach,we
defined the semantics of GemRBAC-DSL by mapping the language
constructs to the OCL constraints presented in [6, 8].
Abiggapbetweenthedefinitionofnew,richerRBACmodelsand
languagesandtheiradoptioninpracticeistheavailabilityofan en-
forcementmechanism :thelatterisacomponentthatreceivesauser
accessrequest(hereafterreferredtoas“ACrequest”)atruntime
and makes an access decision (allow /deny) based on the policies
configured for a system. The lack of enforcement mechanisms for
more expressive RBAC models has favored the adoption on a large
scale[38]ofthestandardRBAC96model,whichis,however,the
leastexpressivemodel.Forinstance,oneofourindustrialpartners—
developing communication solutions for manipulating sensitive
dataincriticalsituationssuchasnaturaldisastersorwars—needs to
248
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Ameni Ben Fadhel, Domenico Bianculli, and Lionel C. Briand
specify and enforce complex policies that involve the user’s context
(spaceandtime),thehistoryofoperationsperformedbytheuser,
androledelegations.Anexampleofsuchapolicy,inthecontextof
asylumseekersassistance,is: anoperatorwiththerole“coordinator”
can register asylum seekers only if he is located within a 20 miles
radius from the base camp, from 8am to 7pm.
Such policies are not supported by RBAC96, but can be speci-
fied usingGemRBAC+CTX(and expressedusingGemRBAC-DSL).
However, they cannot be enforced because there is no enforcement
mechanism forchecking the complex ACpolicies that aresupported
by the GemRBAC+CTX model. Indeed, state-of-the-art enforcement
mechanisms (such as [ 27,29,31,33–35,41,47,54]) support AC
models which are much less expressive than GemRBAC+CTX.
In this paper, we aim to fill this gap, by proposing an automated
mechanismtoenforcecomplexACpoliciesdefinedontopofthe
GemRBAC+CTXmodelandexpressedintheGemRBAC-DSLlan-
guage.Wefollowamodel-drivenengineering(MDE)[ 15]approach
forenforcementbasedonstandardizedtechnologiessuchastheUni-
fiedModellingLanguage(UML)andObjectConstraintLanguage
(OCL) [39]. More specifically, we reduce the problem of enforcing
RBAC policies to the evaluation of the corresponding OCL constraintson an instance of the GemRBAC+CTX model. One advantage of such
an approach is that the translation of GemRBAC-DSL policies into
OCL constraints is already defined [ 7]: by adopting a model-driven
approach, we can leverage the existing operationalization through
OCLconstraintsof GemRBAC-DSLpolicies.Moreover,OCLcon-
straint checking, given that OCL is a standard, is a consolidated
technologyimplementedinmaturetools,suchastheconstraint/-
query evaluator included in Eclipse OCL [19].
Our model-driven enforcement approach not only enforces poli-
cies uponreceiving a user request,but also providesa continuous
enforcementaftermakinganaccessdecision,byhandlingevents
corresponding to changes in the RBAC configuration, to guarantee
that a new configuration still fulfills the AC policies. The relevant
access decisions are re-evaluated whenever a new change, from
an AC point of view, occurs at the system state level (e.g., a user
changes location, or a new user is authenticated). For instance,
wheneverauserchangesherlocation,ourenforcementmechanism
checks whether her active roles should be deactivated (because of
hernewlocation).Thisenforcementisknownasusagecontrol[ 40]
in the area of AC.
Although there have been a few proposals for model-driven
enforcement [ 27,33,47], they adopt an RBAC model much sim-
pler than GemRBAC+CTX (and thus can deal with a limited setof AC policy types); moreover, they consider a subset of the ACrequests/events supported by our approach. Furthermore, defin-
ingalgorithmstopreciselydecidewhenandhowtoenforceOCL
constraints corresponding to GemRBAC-DSL policies, as well as
definingandengineeringanarchitecturetointegratetheconstraint
checker into a Web application, remain open questions that are
addressed in this paper.
Weimplementedourmodel-drivenenforcementmechanismina
prototype,calledMORRO.WeintegratedMORROintoaWebappli-cationdevelopedbyourindustrialpartner;followingtheguidelines
oftheXACMLstandardarchitecture[ 37],ourimplementationin-
cludesapolicyenforcementpoint(PEP)andapolicydecisionpoint
(PDP).Althoughtheproposedarchitecturehasbeendesignedbasedon our partner specifications, it can be generalized and integrated
into other Web applications. We evaluated MORRO in terms of ap-
plicabilityandscalability.TheevaluationresultsshowthatMORRO
can be adopted without considerably impacting the overall perfor-
mance (in terms of response time) of a Web application and that
MORROscaleslinearlywithrespecttothevariousparameters(e.g.,
the number of users and roles) characterizing an AC configuration.
Overall, the results confirm the feasibility of using a model-driven
approach to efficiently enforce complex RBAC policies.
To summarize, the main contributions of this paper are: 1) a
model-driven approach for enforcing access control policies de-
finedontopoftheGemRBAC+CTXmodel,includingalgorithms
specifyingwhenandhowthepolicyconstraintsareenforced;2)an
extensive empirical evaluation of our approach when integrated in
an industrial system, to assess its performance and scalability.
Thepaperisorganizedasfollows.Section 2presentsbackground
material.Section 3illustratesourmodel-drivenapproachforenforc-
ing GemRBAC+CTX policies. Section 4describes the integration
of the proposed approach into the architecture of an industrial
Webapplication.Section 5presentstheempiricalevaluationresults.
Section6reviewsthestateoftheart.Section 7concludesthepaper.
2 BACKGROUND: THE GEMRBAC+CTX
MODEL
TheGemRBAC+CTXmodel[ 6,8]isanextensionoftheRBAC96
model[43]thathasbeendesignedaftersurveyingthevarioustypes
of the authorization policies proposed in the literature. The restof this section gives an overview of the main entities of GemR-
BAC+CTX that are used in the subsequent sections.
The GemRBAC+CTX model, defined as a UML class diagram,
contains all the entities ( User,Role,Session,Permission )o ft h e
originalRBACmodel.TheseentitiesaremodeledasUMLclasses.
A permission is represented as a set of operations that can be
performed on a set of objects. The relations among these RBAC
entities are modeled as UML associations. Each role is assigned to
asetofpermissionsandtoasetofusers.Arolecanbeinherited
using a role hierarchy relation. The inheritance of role assignment
relationships can be defined using a role hierarchy policy ; a user
(or a role) assigned to a role (respectively permission) must also be
assigned to allits sub-roles (respectively sub-permissions) [43].
Asessionisamappingofoneusertoasubsetoftherolesthat
have been assigned to her; this mapping activates the role(s) for
a certain user. However, in some systems only a subset of the as-
signedrolescanbeactivated(e.g.,becauseoftheuser’slocation),
which are called enabled. Once a role is enabled, a user can request
its activation within a session. Both role enabling and activation
aremodeledasUMLassociationsbetweenthe RoleandSession
classes.Similarly,apermissionisenablediftheuserisallowedto
perform its associated operations.
In addition to assignment relations, authorization policies are
definedto restrictauser access.For instance,roleand permission
enabling/disablingcanberegulatedthroughprecedenceandcon-
textualpolicies. Precedencepolicies defineaprecedencerelationship
betweentheenablingofaroleandtheactivationofanotherrole;for
example,role studentisenabledonlyifa supervisor rolehasbeen
already activated. Contextual policies restrict a user to activate a
249
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. Model-Driven Run-Time Enforcement of Complex RBAC Policies ASE ’18, September 3–7, 2018, Montpellier, France
roleorperformanoperationassignedtoapermissionofherrolede-
pendingonherlocation[ 10](location-basedpolicy)andthecurrent
time[28](time-basedpolicy).Thecontext(i.e.,spatialandtemporal
information)ismodeledwithclass RBACContext ,whichcontainsa
TimeExpression and/oraLocation .TheGemRBAC+CTXmodel
supports policies with fine-grained temporal and spatial expres-sions, such as “the first Monday of each month, from April 9, 2018
to January 11, 2019” and“the first floor of building A”. A role is
disabledifitscorrespondingcontextualoraprecedencepolicyis
violated; a permission is disabled if its corresponding contextual
policy is violated.
TheGemRBAC+CTXmodelsupportsothertypesofauthoriza-
tionpolicies. Prerequisitepolicies defineapreconditiononuser-to-
role assignment, allowing a user to acquire a role only if she is
already assigned to another one [ 2,43]. Prerequisite policies can
alsobedefinedatthepermissionlevel,allowingaroletoacquire
a permission only if this role is already assigned to another per-
mission.Cardinality policies define a bound on the cardinality of
roleactivationandassignmentrelations[ 1];e.g.,apolicyoftype
cardinalityonroleactivationrestrictsauserfromactivatinganum-
ber of roles that exceeds a given threshold. Dependency policies,
complementary to the precedence ones, restrict the deactivation of
aroleifanotherroleisstillactive[ 44].Separationofdutypolicies
(SoD)define a mutual exclusion relation among roles, permissions,
orusers;theentitiesinvolvedinsuchrelationsarecalled conflicting ;
SoDpoliciescanbeeitherstaticordynamic. StaticSoD policiesdeal
with user-to-role and role-to-permission assignments; for example,
staticSoDonconflictingrolesspecifiesthatthesameusercannot
be assigned to mutually exclusive roles. Dynamic SoD policies deal
withuser-roleactivationthroughasession;inthiscase,auseris
allowedtoacquireconflictingrolesbutshecannotactivatethem
at the same time. Examples of this type of policy are dynamic SoD
on conflicting roles (DCR) or users (DCU) and history-based (His)
DSoD [6,45].Binding of Duty (BoD) policies are the dual of the
SoD ones and define a correlation between a set of permissions,
whicharecalled bounded;theyareusuallyusedinthecontextof
workflow systems, whose activities can be performed by different
userswithdifferentroles.Forexample,inrole-basedBoD,theop-
erationsallowedbytwoormorepermissionshavetobeperformed
by the same role [ 48]. To support history-based policies such as
dynamicSoDorBoD,operationsperformedbyauseronagiven
object in a certain context, are recorded and modeled as instances
of classHistory.Delegation policies allow a user to delegate or
transfer her role to another user [ 18,54]. A delegation is partial
if only a strict subset of the permissions associated to a role has
been delegated; total otherwise. Revocation policies allow a user to
revoke a delegated role [54].
AninstanceoftheGemRBAC+CTXmodelcorrespondstoasnap-
shot of the system state from an RBAC point of view, at a giventime point. For example, the object diagram in figure 1depicts
aninstanceoftheGemRBAC+CTXmodelthatrepresentsthefol-
lowingRBACentities:two Users,u1andu2;tw oRolesr1andr2;
twoPermission s,p1andp2;t w oOperation sop1andop2; four
Objects, o1,o2,o3ando4. Permission p1is assigned to role r1and
permission p2isassignedtorole r2throughrole-permissionassign-
mentassociations(RPA).Permission p1mapsoperations op1and
op2to objects o1ando2; similarly, permission p2maps operations1: Session
u1: Userr1: Role p2: Permissionu2: User
p1: Permission op1: Operation
op2: Operation o1: Objecto3: Object
o2: Objecto4: Object
r2: Role
Legend
RA: role activation
URA: user-role assignmentRPA: role-permission assignmentRA
RARPAURAURAURA
URA
RPA
cU1: 
RBACContextpU1: 
Location
Figure 1: An instance of the GemRBAC+CTX model repre-
senting a system state.
op1toobjects o3ando4.Moreover,bothroles r1andr2areassigned
both to user u1and to user u2through user-role assignment associ-
ations (URA). At the time when the snapshot has been taken, only
user u1isconnectedthroughhersession s1andhasactivatedher
assignedroles( r1andr2)asshownbytherole-activationassocia-
tions(RA).Thelocationofuser u1ismodeledwithobject cU1,an
instance of the RBACContext class with a Location object pU1.
ThepoliciessupportedbytheGemRBAC+CTXmodelhavebeen
formalized asOCL constraints[ 6,8],to enabletheir operationaliza-
tion.Forinstance,a DynamicSeparationofdutypolicy(DSoD) on
conflictingroles,suchas“ausercanactivateeitherrole r1orr2”,
is checked by verifying the following invariant (taken from [ 6]) of
the classSession, defined as an OCL constraint: Session, defined
as an OCL constraint:
1context Session invDSoD:
2letr1:Role = Role. allInstances ()
3 ->select(r:Role | r.idRole='r1'),
4r2:Role = Role. allInstances ()
5 ->select(r:Role | r.idRole='r2')
6in ifself.activeR oles -> includes (r2)
7 orself.activeRoles -> includes (r1) then
8 self.activeR oles -> includes (r2)
9 xorself.activeRoles -> includes (r1)
10 endif
The DSoD policy above can be checked on the model instance
showninfigure 1byevaluatingtheinvariant DSoDontheSession
object s1. In this case, the condition at lines 6–7istruebecause
bothroles r1andr2areactive.Therefore,wefollowthe thenbranch
andevaluate thebooleanexpressionat lines 8–9.Thisexpression
states that the list of active roles associated with session s1should
containeither r1orr2,butnotboth.Sincebothrolesareactive,the
expression evaluates to false, meaning that the policy is violated.
The OCL formalization of the RBAC policies has been used to
define the semantics of GemRBAC-DSL [ 7], a high-level policy
specificationlanguagebuiltontopof GemRBAC+CTX.Eachpolicy
expressed in GemRBAC-DSL is mapped to an OCL constraint to
operationalize its checking. For instance, the DSoD policy above
can be expressed in GemRBAC-DSL as:
PL1-DSoD: conflicting-roles-activation r1, r2;
We remark that GemRBAC-DSL does not express basic AC policies,
i.e., those encoded as a) role-to-user and role-to-permission assign-
ments, and as b) role-to-session activation or enabling relations;
GemRBAC-DSLassumesthatsuchpoliciesarealreadydefinedat
the model level as UML associations.
250
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Ameni Ben Fadhel, Domenico Bianculli, and Lionel C. Briand
Snap
Processor
access
decision
GemRBAC-DSL
policies…Before Deployment After Deployment (Run Time)
AC request
AC event
initialSnap SnapEnforcement Framework1
3.a
451
3
45
OCL
Constraints
TargetSnap…
OCL
Constraints 
(to evaluate)4
OCL
Checker
enforcement upon AC event enforcement upon AC request3.b
2.b
2.a3
X X2
Figure 2: Overview of the proposed model-driven frame-
work for policy enforcement.
3 MODEL-DRIVEN ENFORCEMENT OF
COMPLEX POLICIES
Thegoalofthispaperistoproposeanautomatedmechanismtoen-
force access control policies defined on top of the GemRBAC+CTX
modeland expressedusingtheGemRBAC-DSLlanguage.One ba-
sic idea to achieve this goal is to leverage the operationalization
throughOCLconstraintsof GemRBAC-DSLpoliciesproposedin[ 7],
to define a model-driven enforcement approach. At the base of this
approachthereis thereductionoftheproblemofenforcingGemRBAC-
DSLpoliciestotheevaluationofthecorrespondingOCLconstraints
on an instance of GemRBAC+CTX (which captures the system state
from an AC point of view). Adopting a model-driven approach for
enforcing GemRBAC-DSL policies has two main advantages: 1) the
possibility of building upon the existing translation of GemRBAC-
DSL policies into OCL constraints, which is already optimized for
efficient checking; 2) the reliance on OCL, which is a standard and
for which there exists mature constraint checking technology.
Nevertheless, putting such an approach in operation, requires
todefinealgorithmstopreciselydecidewhenandhowtoenforce
suchconstraints,aswellastooutlineanarchitecturethatdescribes
how to integrate the constraint checker into a Web application
architecture:theseareopenquestionsthatwillbeaddressedbythe
coming sections.
Figure2illustrateshowourapproachcanberealizedinanen-
forcementframework.Beforedeployingtheapplication,weassume
that a security admin has defined the initial system state from the
point ofview of AC. Thismeans that themain RBAC entities (i.e.,
users, roles, permissions, operations and objects) of the system
havebeendefined,togetherwiththeirassignmentrelations(e.g.,
assignment of permissions to the various roles). These entities,
representingthestaticRBACviewofthesystem,arecapturedin
an instance of the GemRBAC+CTX model called initialSnap.W e
also assume that the security admin has defined the AC policies
inGemRBAC-DSL.Thesepoliciesarethentranslatedintoasetof
OCLconstraints(withrespecttotheGemRBAC+CTXmodel)using
the translation defined in [7].
After deployment, when the system is executing, the enforce-
ment framework works as follows. Its inputs are:
•ThesetofOCLconstraintscorrespondingtotheGemRBAC-
DSL policies defined for the system.
•A snapshot Snapof the system state from the point of view
of AC, represented as a GemRBAC+CTX instance. This snapshotTable 1: Policies checked for each type of AC request/event
RPPrq RH AC AS Prec Dep S DCR DCU Obj Op His BoD CT CL Deleg Rev
RA /check/check /check
AR /check/check/check/check
RD /check/check /check /check /check
RR /check/check /check /check
AO /check/check /check /check /check/check
UA /check/check /check
ULC /check
UD /check
Legend. R: AC request/event. P: policy. Type of AC request/event: RA: role activation; AR: access
to a resource; RD: role delegation, RR: role revocation; AO: administrative operation; UA: user
authentication; ULC: user’s location change; UD: user disconnection. Type of policy: Prq: prereq-
uisite; RH: role hierarchy; AC: cardinality on role activation; AS: cardinality on assignment rela-tions; Prec: precedence; Dep: dependency; S: static SoD; DCR: dynamic SoD on conflicting roles;DCU: dynamic SoD on conflicting users; Obj: object-based DSoD; Op: operational-based DSoD,His: history-based DSoD; BoD: binding of duty; CT: time-based context; CL: location-based con-
text; Deleg: delegation; Rev: revocation.
captures both the static RBAC view of the system and the dynamic
RBACview(e.g.,activesessions,users’contexts);itisupdatedat
run time as the AC configuration evolves. Notice that right after
the start of the system execution, Snapcorresponds to initialSnap.
•The actual AC request that has to be enforced. It contains
(asinstancesofthecorrespondingclassesoftheGemRBAC+CTX
model) the Objectto accessand the Operation to performon it,
such as “GET /url/to/resource”.
Thevariousstepsoftheenforcementprocessareshowninfig-
ure2andaremarkedwithgreendashedlinesandcircles.Themain
component of the enforcement framework is the SnapProcessor.
OncetheframeworkreceivesanACrequest(step 1),theSnapPro-
cessorfirstanalyzestherequestbycheckingwhethertherequest
isvalid(step 2).Forinstance,ausercannotrequesttoactivatea
role that is not assigned to her. In case the request is not valid, the
access is denied and the access decision is returned (step 5).
Otherwise,iftherequestisvalid,the SnapProcessor buildsanew
snapshotofthesystemstate(step 3.a),startingfromthecurrent
statecapturedbythe Snap.Thisnewsnapshot,called TargetSnap
and also represented as an instance of the GemRBAC+CTX model,
captures the next system state (from the point of view of AC) as
iftheACrequesthadbeenallowed.Aftercreatingthe TargetSnap,
theSnapProcessor selects—based on the type and the parameters of
the AC request—the OCL constraints to evaluate (step 3.b), corre-
spondingtothepoliciestoenforce;thepoliciesselectionfollows
the rules encoded in the top part of table 1. The selected OCL con-
straints are evaluated by an OCL checker (step 4). In this way,
makinganaccessdecisionforanACrequest(step 5)isequivalent
toverifyingwhetherthe TargetSnap satisfiestheOCLconstraints
corresponding to the policies to enforce. If the constraints evaluate
totrue,itmeansthattheACrequestcanbeallowed,sinceitwillnot
violate any policy. Onthe contrary, when the constraints evaluate
tofalse, it means that allowing the request would violate one or
more of the policies defined for the system.
Our approach adopts also the usage control [ 40] concept for AC,
which aims to revise AC decisions (by re-enforcing AC policies)when a new update, from the point of view of AC, occurs at the
systemlevel.Forinstance,wheneverauserchangesherlocation,
ourenforcementmechanismre-evaluatesthe(OCLconstraintscor-
responding to the) location-based policies for this user, to check
251
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. Model-Driven Run-Time Enforcement of Complex RBAC Policies ASE ’18, September 3–7, 2018, Montpellier, France
Algorithm 1 Enforcement upon
receiving an AC request
Input: a= AC request,
Snap= current system state,
P= list of system policies
Output: a tuple/angbracketleftd,TargetSnap /angbracketright, where:
d= access decision,
TargetSnap = new system state
1:PLC←∅,TargetSnap ←null,d←null
2:ifvalidateRequest( a)then
3:TargetSnap ←buildTargetSnap( a,Snap)
4:PLC←selectPolicies( P,a)
5:elsed←false
6:ifdisnullthen d←check(TargetSnap ,PLC)
7:return/angbracketleftd,TargetSnap /angbracketrightAlgorithm 2 Enforcement
after an AC event occurs
Input: e= AC event,
Snap= current system state,
P= list of system policies
Output:USnap= updated system state
1:PLC←∅,USnap←null
2:USnap←updateState( e,Snap)
3:PLC←selectPolicies( P,e)
4:for each policy pinPLCdo
5:check(USnap,p)
6:ifpis not satisfied then
rectify(USnap,p,e)
7:returnUSnap
whetherthenewsystemstatesatisfiesthem.Thevariousstepsof
theenforcementprocessuponanACeventareshowninfigure 2
and are marked with blue solid lines and squared boxes. In our
case,weassumethattheenforcementframeworkwillreceive,from
an external component, a notification when an AC event occurs
(step1). Reacting to this notification, the SnapProcessor creates
theTargetSnap, obtained by updating (according to the received
event) the current system state captured by the Snap(step2.a).
TheSnapProcessor thenselects—basedonthetypeoftheACevent—
theOCLconstraintstoevaluate(step 2.b),correspondingtothe
policies to enforce; the policies selection follows the rules encoded
inthebottompartoftable 1.Finally,itchecks,bymeansoftheOCL
checker,whethertheselectedpoliciesarestillsatisfied(step 3).
If a policy violation is detected, the SnapProcessor updates the Tar-
getSnapbydisabling/deactivatingthecorrespondingrole(step 4);
the updated TargetSnap then becomes the new Snap(step5).
Thenextsubsectionsexplainhowour frameworkenforcesAC
policies when making an access decision for an AC request (sec-
tion3.1)andwhenhandlingnotificationsforACevents(section 3.2).
3.1 Making Access Decisions for AC Requests
The procedure for enforcing policies upon receiving an AC request
isshowninalgorithm 1.IttakesasinputanACrequest a,asnapshot
Snapcorresponding to the system state (from the point of view of
AC) at the time of the request, and the list Pof policies defined
forthesystem;itreturnsatuple,containingtheaccessdecision d
(a boolean value, with truecorresponding to “allow” and falseto
“deny”)andasnapshot TargetSnap (aninstanceof GemRBAC+CTX
correspondingtothenewsystemstateasiftherequesthadbeen
authorized).Besidesvariables dandTargetSnap ,theprocedureuses
an auxiliary variable PLC, representing the list of policies to check
for a specific type of the AC request and initialized to an empty
list. Both variables TargetSnap anddare initialized to null. Our
approach considers AC requests of type: role activation, access to a
resource,roledelegation, rolerevocation,and administrativeoperation
(i.e., assigning a role to a user or to a permission).
First,the SnapProcessor checksthevalidityoftherequestbycall-
ingoperation validateRequest (line2,correspondingtostep 2
in figure 2). The validity is determined based on the type of the
AC request as follows. In case of a role activation, the request is
valid if the role to activate is already enabled for the user whomadetherequest.Incaseofan accesstoaresource,therequested
permission (e.g., p) should be assigned to an active role rin the
current session of the user who made the request and should be
enabled; if the user who made the request acquired role rthrough
adelegation,thisdelegationshouldincludepermission p.Incase
of arole delegation, therole beingdelegated should beassigned to
theuserwhomadetherequestandnotassignedtotheuserwho
willreceivethedelegation.Incaseofan administrativeoperation,
the requested user (respectively, permission) should not belong
tothelistofusers(respectively,permissions)assignedtotherole
indicated in the request.
IftheACrequest aisnotvalid,the SnapProcessor setstheaccess
decisiondtofalse(line5). Otherwise, the SnapProcessor builds the
TargetSnap by calling operation buildTargetSnap (line3, corre-
sponding to step 3.ain figure2). This operation takes as input the
ACrequest aandthesnapshot Snap;itsbehaviordependsonthe
type of the AC request:
•Role activation. We consider a request of the form “user u1
requestingtoactivaterole r1”.First,weremoverole r1fromthelist
ofenabledroles.Then,weaddittothelistofactiverolesforuser
u1; if a precedence policy is specified for role r1, theSnapProcessor
enables the list of roles which should be enabled for other users,
according to the precedence relation.
•Access to a resource. We consider a request of the form user
“u1with role r1requesting to perform operation op1on object o1”.
TobuildTargetSnap ,weaddanewinstanceoftype History tothe
currentSnap. This instance records that user u1, while having role
r1, performed operation op1on object o1through permission p1.
•Role delegation . We consider a request of the form “user u1
requesting to delegate her role r1to user u2”. TheTargetSnap is
obtained by adding role r1to the list of delegated roles for user u2
and creating a new instance of class Delegation.
•Role revocation. We consider a request of the form “user u1
requesting to revoke delegation d1”; we also assume that user u2
acquired role r2through delegation d1(originated from u1). We
build the TargetSnap by removing role r2from the list of delegated
roles assigned to user u2, marking delegation d1asrevoked, and
recording the revoking user ( u1).
•Administrativeoperation.Weconsiderarequestoftheform
“adminrequestingtoassignrole r1touser u1”or“‘adminrequesting
to assign role r1to permission p1”. TheSnapProcessor builds the
TargetSnap byaddingtheappropriateassignmentrelation,i.earole-
to-user assignment or a role-to-permission assignment relation.
Afterbuildingthe TargetSnap ,theSnapProcessor extractsthelist
PLCofpoliciestocheckfromthesystempolicieslist Pbycalling
operation selectPolicies (line4, corresponding to step 3.bin
figure2). This operation determines the list of policies to check
based on the type (i.e., according to table 1) and the parameters
oftherequest.Forinstance,incaseofanACrequestoftype role
activation, the list PLCwill contain all the policies in Pwhose type
isindicatedinrow RA(i.e.,AC,DCR,DCU),andwhoseparameters
match at least one of the request parameters (i.e., the user who
made the request and the role to activate).
Then, if the accessdecision dhas not been set yet(i.e., it is null),
the algorithm invokes the OCL checker (operation checkat line6,
corresponding to step 4in figure2). This operation evaluates, on
252
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Ameni Ben Fadhel, Domenico Bianculli, and Lionel C. Briand
theTargetSnap , the OCL constraints corresponding to the policies
inPLC;theresultoftheevaluationwillcontaintheaccessdecision.
The algorithm ends by returning the tuple with both the access
decision dandthenewsystemstate TargetSnap (step5infigure2).
We recall that when the access is denied TargetSnap will benull.
3.2 Handling Notifications for AC Events
The procedure for updating the system state captured by the Snap
andenforcingpoliciesuponreceivinganotificationforanACevent
isshowninalgorithm 2.IttakesasinputanACevent e,asnapshot
Snapcorresponding to the system state (from the point of view of
AC) at the time of the notification, and the list of policies Pdefined
forthesystem;itreturnsasnapshot USnap,whichisaninstanceof
theGemRBAC+CTXmodelcorrespondingtotheupdatedsystem
state. Besides variable USnap(initialized to null), the procedure
usesanauxiliaryvariable PLC,representingthelistofpoliciesto
check for a specific type of event and initialized to an empty list.
Ourapproachconsiderseventsoftype userauthentication, user’s
location change, and user disconnection.
Upon receiving an event notification, the SnapProcessor first up-
dates the system state according to the received event by calling
operation updateState (line2,correspondingtostep 2.ainfig-
ure2).ThisoperationtakesasinputthereceivedACevent eandthe
currentsystemstatecapturedbythe Snap;itreturnstheupdated
stateinUSnap.The behaviorofoperation updatedependson the
type of the event e:
•Theuser authentication event corresponds to the case of a
userlogginginthesystem.Weassumethattheenforcementframe-
workreceivesthenotificationfromanauthenticationserver,which
checks the user credentials and allows her login. In this case, weupdate the state by adding a new instance of class
Session for
theauthenticated user,updatingtheuser’s location,andenabling,
within the newly added session, all the roles assigned to the user.
•Theuser’s location change event corresponds to the case of
a connected user changing her location. We assume that a geo-
localizationserverkeepstrackoftheuserposition;thisserversendsanotificationtotheenforcementframeworkwheneveraconnected
user changes her location. In this case, the state is updated by
updating the user’s location.
•Theuserdisconnection eventcorrespondstothecasewhena
user is experiencing network issues. We assume that the authen-tication server periodically checks for the online status of a userand sends a notification to the enforcement framework when it
detects that the user is offline1. In this case, we update the state by
removing the session of the disconnected user.
Afterwards,the SnapProcessor extractsthelist PLCofpoliciesto
check from the system policies list P, by calling operation select-
Policies (line3, corresponding to step 2.bin figure 2). This
operation determines the list of policies to check based on the type
(according to table 1) and the parameters of the received event
notification.For instance, incaseof a userauthentication event,the
listPLCwill contain all the policies in Pwhose type is indicated
in rowUA(i.e., CT, CL), and whose parameters match at least
1The case of a user sending a log out request to the authentication server is treated by
forwarding the request to the enforcement mechanism, which is then processed as
explained in section 3.1.one of the notification parameters. Then, for each policy pinPLC,
theSnapProcessor invokes the OCL checker (operation checkat
line5, corresponding to step 3in figure 2), to evaluate, on the
USnap,theOCLconstraint(s)correspondingto p.Iftheresultofthe
evaluationisfalse,itmeansthatthenewsystemstate(asdetermined
in response to the event e) violates policy p. Applying the usage
control concept, the SnapProcessor amends the USnap, by calling
operation rectify(line6, corresponding to step 4in figure 2);
the behavior of this operation depends on the type of the event e:
•User authentication. We consider a notification of the form
{u1,s1,loc},where u1istheuserbeingauthenticated, s1isthetoken
representingtheuser’ssession, locisthecurrentpositionoftheuser.
For each role renabled for user u1in session s1, theSnapProcessor
amendsUSnapby disabling role rin session s1.
•User’s location change. We consider a notification of the form
{u1,loc1,loc2},where u1denotestheuserand loc1andloc2corre-
spond,respectively,tothepreviousandthenewpositionofuser
u1.Foreachrole rassignedtouser u1,theSnapProcessor amends
USnapaccording to the state of role r: if it is enabled (respectively,
active),the SnapProcessor willdisable(respectively,deactivate)it
from all the sessions of user u1.
•User disconnection. We consider a notification of the form
{u1,s1},where u1istheuserbeingauthenticatedand s1isthetoken
representing the user’s session. For each role rassigned to user u1,
theSnapProcessor amendsUSnapbydisablinganddeactivatingrole
r1from all sessions in the system.
The algorithm ends by returning USnap(step5in figure2).
4 RUN-TIME ARCHITECTURE AND
IMPLEMENTATION
Wehaveintegratedtheenforcementframeworkpresentedinsec-
tion3into the architecture of a Web application developed by our
partner.Thisarchitectureincludes:a)aWebapplicationandaset
ofmicro-services,whichexposeresourcesaccessiblethroughthe
web interface; b) a geo-localization server, which records the users’
position;andc) anauthenticationserver,for authenticatingusers
based on their credentials.
To integrate our enforcement framework, we have added two
newcomponentstothisarchitecture:an authorizationserver and
aproxy.ThesecomponentsfollowstheguidelinesoftheXACML
standardarchitecture[ 37],whichprescribestousetwocomponents:
apolicyenforcementpoint (PEP)anda policydecisionpoint (PDP).In
this standard architecture, a user AC request is intercepted by the
PEP,whichwilltransformitintoanXACMLrequestandforwardit
to the PDP; the latter evaluates the request based on the authoriza-
tion policies. In our case, the PEP is the proxy, while the PDP is the
authorizationserver.The authorizationserver integratesthe Snap-
Processor andtheOCLCheckershowninfigure 2;itreceivesAC
requests and notification of AC events and enforces the policies as
described in section 3, making sure that only authorized users can
accesstheresourcesexposedbythesetofmicro-services.The proxy
isagatewaythatinterceptsuserACrequests:itfirstforwardsthem
to theauthorization server, which makes an access decision that is
returnedtothe proxy;iftheaccessdecisionis“allow”the proxyfor-
wards the original user request to the corresponding micro-service.
Inaddition,wehaveincludedastoragecomponentfortheaccess
253
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. Model-Driven Run-Time Enforcement of Complex RBAC Policies ASE ’18, September 3–7, 2018, Montpellier, France
controldata,whichcontainsthesnapshot Snap(givenininputto
andupdatedbythe authorizationserver )andtheGemRBAC+CTX
policies to enforce.
Although the resulting enforcement architecture has been de-
signed based on the architectural specifications provided by our
industrialpartner,itcanbegeneralizedandintegratedintoother
Web applications. More specifically, the proxycan be integrated
seamlessly within existing load balancers, which are very common
inWebapplications[ 16];theauthorizationserver andthestorage
are additional components that can be deployed on any Web appli-
cation server.
Implementation. The core of our framework is a component,
called MORRO ( MOdel-driven f Ramework for Run-time enforce-
ment of RBAC p Olicies), and includes the authorization server and
theproxy. MORRO has been implemented in Java with a micro-
servicebasedarchitectureusingtheSpringBoot[ 49]frameworkand
theZuuLproxyv.1.2.7[ 36].Theimplementationofthe authoriza-
tionserver usestheEclipseModelingFramework(EMF)andEclipse
OCL v.5.2 [19]. The Snapis expressed as an Ecore [20] model.
5 EVALUATION
In this section we report on the evaluation of MORRO when de-
ployed in a real Web application, with a complex AC configuration.
We assess the efficiency and applicability of MORRO by answering
the following research questions:
RQ1:HowlongdoestheauthorizationserverinMORROtaketo
processACrequests/events,whendeployedonarealindustrialsystem,
under various AC configurations?
RQ2:HowdotheaccessdecisiontimeandtheACeventprocess-
ing timeof theauthorizationserver inMORROscalewith respectto
changes of the various parameters potentially affecting the perfor-
mance of an AC configuration?
RQ3:What is the communication overhead between the autho-
rization server and theproxyin case of an AC request?
5.1 Evaluation Settings
We considered a real AC configuration used by our industrial part-
ner, consisting of 1648 users, 396 roles, 53 permissions, 300 objects
and 4 operations (create, read,update, and delete). We defined a
set of GemRBAC-DSL policies in collaboration with the security
engineers of our partner. We then determined the types of policies
used in the specification and, for each type, we considered a rep-
resentativeexampletoanswertheresearchquestionsmentioned
above.ToenableMORROtoenforcethem,weusedthemappingof
these policies to OCL constraints we previously proposed in [ 6,8].
WedeployedMORROontoamicro-service-basedarchitecture
provided by our industrial partner. This architecture was running
onadevelopmentmachineequippedwithadualCPUIntelXeon
E5-2640v2 2GHzand24GBofmemory;weusedthismachineto
run all the experiments. All time measurement were performed
by invoking the System.nanoTime() method of the standard Java
library, version 1.8.
Duetospacereasons,inthefollowingwepresentonlyasum-
maryoftheevaluationresults.Werefertothefirstauthor’sPhD
thesis[5,chapterIII]foracompletedescriptionofthepoliciesused
in the evaluation and for the detailed experimental results.5.2 Performance on an Industrial System
Methodology. To address RQ1, we measured the time taken by
the authorization server in MORRO to process different types of
AC requests and events. More specifically, in case of an AC request
we measured the access decision time, i.e., the time difference from
the time the authorization server receives the request to the time it
yields an access decision. In case of an AC event, we measured the
execution time needed to update the current system state (Snap ),
i.e.,thetimedifferencefromthetimetheauthorizationserverre-
ceivesanotificationforanACeventuntilthetimeitupdatesthe
current system state. Based on the AC configuration of the test
application defined by our industrial partner, we generated two
types of AC requests and two types of AC events. For each type of
request (respectively, event) the access decision time (respectively,
execution time) was assessed both on a basic configuration —i.e., an
ACconfigurationthatisonlydeterminedbyroleassignmentand
activation relations—and on configurations that add to the basic
configurationotherpoliciestobechecked.Thetypesofrequests
and events generated are:
•Accesstoaresource.Weconsidertwoscenarios:1)whenthe
role of the user making the request has been assigned and 2) when
asubsetofthepermissionsassignedtothisrolehasbeendelegated.
Asfortheconfigurations,inadditiontothebasicone,weuseone
with a history-based DSoD policy and another with a BoD policy.
•Role activation. The additional configurations use the cardi-
nality on role activation and the DCR policies.
•Userauthentication.Weconsidertwoscenarios,inwhichwe
distinguish whether the user’s position is known or not. The ad-
ditionalconfigurationsuseprecedence,location-based,andtime-
based policies.
•User’slocationchange.Weconsideroneadditionalconfigura-
tion with a location-based policy.
For all configurations we considered the worst-case scenario, with
the maximum allowed value for each system parameter (e.g., maxi-
mum number of roles assigned to a user).
Since MORRO runs on a Java-based environment, the measure-
ments of the running time are affected by various factors [ 23]. Fur-
thermore, the network-based communication between the proxy
andtheauthorizationserver introducessomenoise.Fortheserea-
sons, when measuring the access decision time for AC requests,
we sent ten AC requests, discarded the first one (since it is affected
by the loading time of the run-time libraries), and measured the
averagevalueovercheckingtheninesubsequentrequests.Asfor
measuringtheexecutiontimeforprocessingACevents,wewere
able to achieve stable results by sending only five notifications. As
above, since the first value is affected by the loading of the run-
timelibraries,wediscardeditandmeasuredtheaveragevalueoverprocessing the four subsequent notifications. In both cases, to keep
the same instance over the different runs, we designed the (initial)
ACconfigurationofthesystemsuchthattheOCLcheckeryields
false (denying the access request).
Results. We answer RQ1by summarizing the main results. The
access decision time within the authorization server is less than
64ms;thehighestvalueisobtainedwhileevaluatinganACrequest
of typeaccess to a resource for a configuration with a history-based
DSoD policy in a role delegation scenario. This value has to be
254
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Ameni Ben Fadhel, Domenico Bianculli, and Lionel C. Briand
analyzed in the context of Web applications which are accessed by
users from a browser. In modern Web applications, the complexity
ofeachsingleWebpagerequiresarelativelyhighnetworktime(i.e.,
the time needed by a browser to fetch all resources to be displayed
on a page); for example, a web page from Wikipedia requires on
average1880msof networking time [ 17]. Under this scenario, a
maximumoverheadof 64msduetotheACenforcementframework
wouldcorrespondtolessthan4%increaseoverthetotalnetworking
time, which is quite affordable in practice.
Theexecution time for processing a notification of an AC event is
less than 512ms; the highest value is obtained while evaluating an
ACrequestoftype userauthentication foraconfigurationwitha
precedencepolicyconsideringthecasewhentheuserpositionis
known. This value has also to be interpreted in the context of Web
applications. In such a context, an AC event is triggered by a user
action and its processing should be completed before the next user
request, so that the latter can be evaluated on the updated system
data(asmodifiedbytheACevent).Hence,theexecutiontimefor
processing the notification of an AC event should be less than the
time between the completion of a user request and the start of a
newone(i.e.,the thinktime ).TCP-W[ 51],acommonbenchmark
for Web applications, considers an average think time of 7s; the
maximum value for the execution time in our system ( 512ms)i s
well below this threshold.
5.3 Scalability
Methodology. To answer RQ2, we evaluated the scalability of the
authorization server. Scalability is concerned with analyzing thechange in access decision time (and AC event execution time) as
parametersincreaseinvalue,withrespecttodifferentscenariosand
configurations. Our goal is to use such information to draw con-
clusions on how our solution is likely to tackle even more complex
AC situations.
We considered the same AC requests and AC events used to
answerRQ1,andthecorrespondingscenariosandconfigurations.
To assess the effect of a parameter, we varied it while keeping
all the other relevant system parameters constant. The parameter
variedeitherbetweenarangeofvalueswithacertainstepincre-
ment,orthroughasetofpredefinedvalues;thelattercaseoccurred
for parameters that affect the evaluation of spatial and temporalpolicies. The snapshots of the system state corresponding to all
these configurations were generated using an internally developed,
parametrizedgenerator.Ineachexperimentalrun,wesentanAC
request or an AC event notification. In the case of AC requests, we
measured the access decision time; in the case of AC events, we
measuredtheexecutiontimeforprocessingtheevent.Inbothcases,
we measured these values following the same procedure described
in the answer to RQ1.
Results. For space reasons, here we only present the results
corresponding to one type of AC request and to one type of AC
event, on a specific configuration.
Table2reportsthe evaluationresults foran ACrequest oftype
access to a resource (AR) and for an AC event of type user authenti-
cation(UA).Weconsider1)anACrequestoftheform“ u1withrole
r1insession s1requestingtoperformoperation op1onobject o1”,
onaconfigurationwithahistory-basedDSoDpolicy( His),forbothTable2:Scalabilityof MORROundervarioussystemconfig-
urations.
AC
ConfParamValues Range Step
IncTime (ms)
lower upper min max Data trend
AR-His
-RLAb1 K 10K 1K 73 99 alc M: 84.30, SD: 8.53
d1 K 10K 1K 37 49 linear
e1 K 4K1K 56 74 alc M: 65.64, SD: 7.33
f1 K 10K 1K 39 85 linear
AR-His
-RLDb1 K 10K 1K 96 108 alc M: 100.75, SD: 4.05
d1 K 10K 1K 58 115 linear
e1 K 4K1K123 148 alc M:138.02, SD:10.63
f1 K 10K 1K 61 123 linear
UA-Prec
-ULg1 K 10K 1K199 339 linear
c1 K 5K1K845 1444 linear
a 10K 25K 5K891 1607 linear
UA-Prec
-KLg1 K 10K 1K233 452 linear
c1 K 5K1K1497 1628 linear
a 10K 25K 5K901 2017 linear
Parameters labels. a: #sessions in the system; b: #active roles in s1(current session
of the user who made the request); c: #active roles in all sessions. d: #logs associated
with conflicting roles; e: #objects within the set of logs; f: #operations in the system;
g: #roles assigned to user u1.
Configurationscenarioslabels.RLA:roleassignmentscenario;RLD:roledelegation
scenario; UL: the user location is unknown; KL: the user location is known.
scenarios of role assignment (RLA) and role delegation (RLD ); and
2) an AC event of type user authentication (UA), with a notification
of theform {u1,s1,loc}—where u1is theuser being authenticated,
s1is the token representing the user’s session, locis the current
positionoftheuser—onaconfigurationwithaprecedencepolicy
(Prec),fortwoscenarios,inwhichwedistinguishwhethertheuser’s
position is known (KL) or not (UL). Column AC Conf indicates for
each request/event the considered configuration and scenario. For
instance, the configuration on the first row (AR-His-RLA) corre-
sponds to the case of an AC request of type access to a resource on
a configuration with a “His ” policy while considering a role assign-
ment scenario. Column Paramindicates (with a label, see legend
at the bottom of the table) the parameter being assessed during
the run; column Values Range denotes the lower and upper bounds
oftherangeofvaluesthroughwhichtheparameterisvaried;the
stepincrementisshownincolumn StepInc;columnTimeindicates
the access decision time; columns minandmaxdenote the lowest
and the highest time values observed across runs; column Data
trendindicates the trend observed for the data points: in case of an
“almost constant” (referred to as alc) trend, we include the average
(columnM) and the standard deviation (SD ).
The answerto RQ2is thatthe access decisiontime and theexe-
cution time for processing a notificationof an AC event are either
linearwith respect to the parameters of the various configurations
oralmostconstant (i.e.,thereisnomuchvariationacrossruns,with
lowSD). Thesetrendscan beexplained intermsof theoperations
called in the OCL constraints (see [ 6,8]) evaluated for each policy.
Forexample,forthefirstconfiguration(“AC-His-RLA”)withparam-
eter“b”(thenumberofactiverolesinsession s1),theaccessdecision
timeisalmostconstant,i.e.,itdoesnotdependonparameter“b”:this
isduetothedefinition(in[ 6])oftheOCLconstraintcorresponding
tothehistory-basedDSoDpolicy),inwhichcheckingwhetherboth
conflicting roles are active in session s1is performed in a constant
255
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. Model-Driven Run-Time Enforcement of Complex RBAC Policies ASE ’18, September 3–7, 2018, Montpellier, France
time.Similartrendscanbeobservedfortheotherconfigurations,
for each type of AC request/event. Overall, these results imply that
our solution is applicable for even more challenging AC situations
with larger numbers of sessions, roles, and permissions.
The highest value for the access decision time we measured
was148ms,inthecaseofarequestoftype accesstoaresource,ina
configurationwitha Hispolicy,witharoledelegationscenario,with
10K objects within the set of logs. Along the lines of the discussion
forRQ1, such value would represent an 8% overhead with respect
to the average networking time (see [ 17]) for fetching a complex
Web page. Such an overhead is still acceptable when enforcing AC
policies in large systems.
The highest value for the execution time we measured was
2017ms, in the case of an AC event of type user authentication,
in a configuration with a precedence policy, with 25K active ses-
sions,withaknownuserlocation.Asalsodiscussedfor RQ1,this
valuewouldstillbebelowthethinktimethreshold( 7s)provided
by the TCP-W [ 51] benchmark.
5.4 Overhead of the Communication between
the Authorization Service and the Proxy
Methodology. To address RQ3, we measured the communication
overhead between the authorization service and the proxy, i.e., the
time takento dispatch an authorization request from theproxy to
theauthorizationserver,plusthetimetopropagatetheaccessdeci-
sionfromtheauthorizationserverbacktotheproxy.Wecomputed
this overhead as the difference between the access decision time
measured within the proxy and the access decision time measured
within the authorization server; the access decision time within
theproxyisthedifferencebetweenthetimeinstantatwhichthe
proxy receives an AC request from the user and the time instant at
whichtheproxyreceivesanaccessdecisionforthatrequestfrom
the authorization server.
Wemeasuredthisdifferenceforalltherequests/events,scenarios
and configurations mentioned in section 5.2.
Results. The answer to RQ3is that theoveralloverhead of the
communicationbetweenthe authorizationservice andthe proxy is
less than 60ms. When considering both the access decision time
withintheauthorizationserverandthecommunication overhead
between the authorization server and the proxy, the most taxing
AC request is one of type access to a resource, for a configuration
witha“His ”policy,withanaccessdecisiontimewithintheproxyof
107ms.Alongthelinesofthediscussionfor RQ1,suchvaluewould
representlessthan6%oftheaveragenetworkingtime(see[ 17])for
fetching a complex Web page. Furthermore, this value is far below
the threshold ( 200ms) indicated in the requirements specifications
of the Web application developed by our industrial partner.
6 RELATED WORK
Thisworkleveragesourpreviousworkonmodelingandspecifying
complex RBAC policies using the GemRBAC+CTX model [ 6,8]
and the GemRBAC-DSL language [ 7], including the operationaliza-
tion of RBAC policies as OCL constraints. This paper complements
and advances our previous work by providing an approach for the
enforcement of RBAC policies, which includes the description of
algorithms specifying when and how the policy constraints are en-Table3:SupportofACrequests/eventsinexistingpolicyen-
forcementapproaches(abbreviationsaredefinedinTable 1)
AC Request AC Event
RA AR RD RRAO UA ULC UD
Sohr et al. [47] ++--++--
Hummer et al. [27] -+------
Martinez et al. [33] ++------
Zhang et al. [54] --++----
Margheri et al. [31] -+------
Mourad et al. [34] -+------
Kallel et al. [29] ++--+-+-
Mariscal et al. [41] -+------
Mustafa et al. [35] ++--+-+-
Kirkpatrick et al. [30] -+---+--
Bhatti et al. [12] ++--+-+-
Ben David et al. [4] ++---+-+
MORRO (this work) ++++++++
forced,thedefinitionandengineeringofanarchitecturetointegrate
the constraint checker into a Web application, and an empirical
evaluationoftheperformanceandscalabilityoftheapproachwhen
integrated into an industrial system.
A work very close to our contribution has been proposed by
Sohretal.[ 47],whichimplementsthePDPasamodel-drivenau-
thorizationengine,inthecontextofWebservices.RBACpolicies
are expressed as OCL contraints using the USE tool, a validation
toolforUMLmodelsandOCLconstraints.SimilartoMORRO,to
make an access decision, the authorization engine checks whether
thesystemstate,representedasanUMLobjectdiagram,satisfies
theRBACpoliciesexpressedasOCLconstraints.Themaindiffer-
ence is that this work is based on the standard RBAC96 model,
which supports a limited subset of the policies that can be spec-
ified in GemRBAC+CTX (and enforced by our approach). More
precisely, the proposed enforcement mechanism supports only car-
dinality, prerequisite, and history-based SoD. Moreover, contextual
policies assume that the context is represented symbolically: i.e.,
fine-grainedspatial(e.g.,withrelativelocations)andtemporal(e.g.,
withintervals)policiesarenotsupported.Becauseoftheseintrinsic
limitationsintheunderlyingmodel,theenforcementmechanism
can deal with only a subset of the AC requests (access to a resource,
role activation, and administrative operation ) and events (user au-
thentication ) supported by MORRO. Furthermore, the approach
presented in reference [47] does not support usage control.
Other model-driven approaches for policy enforcement have
been presented in [ 27,33]. In the approach by Hummer et al. [ 27],
RBAC policies are written in a domain-specific language based on
UML activity diagrams and mapped to Business Process Execution
LanguageforWebservices(WS-BPEL)specificationstobeenforced
atruntime;however,thisworksupportsonlyseparationofduty
andbindingofdutypolicies.TheworkbyMartinezetal.[ 33]deals
with the generation of a PDP infrastructure from a specification
written in a policy language, using ATL model transformations. A
limitation shared by these model-driven approaches is that RBAC
policies are only enforced as a response to a user AC request of
typerole activation oraccess to a resource. Similarly, the work by
Zhang et al. [ 54] propose an enforcement framework that supports
only delegation and revocation policies.
256
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Ameni Ben Fadhel, Domenico Bianculli, and Lionel C. Briand
RecentworkbyMargherietal.[ 31]proposesaframeworkforthe
specification,analysis, and enforcement ofABAC [ 25] (attribute-
based access control) policies; RBAC can be seen as a specific case
of ABAC, where role is one of the attributes. In this work, both
AC requests and policies are expressed in a high-level language
calledFACPL;theyarethentranslatedintoconstraintstobesolved
using an SMT solver. Although this approach is at a high level con-
ceptually similar to ours (both approaches formalize the semantics
of AC policies as constraints, either in OCL or in SMT-LIB), the
underlyingACmodelsaredifferent.Asaconsequence,thetypesof
requestsandeventsuponwhichthepoliciesareenforcedarealso
different:theFACPL-based frameworkonlysupportsACrequests
of typeaccess to a resource and does not support the concept of us-
age control. Furthermore, its empirical evaluation considered only
one small case study and randomly generated policies, assessing
scalability only in terms of the number of attributes.
Other proposals deal with the generation of aspects from policy
specifications; the generated aspects are inserted into the applica-
tion to be executed at run time. Mourad et al. [ 34] propose the use
ofBPELaspectstoenforceACpoliciesinthecontextofwebservice
composition. Kallel et al. [ 29] generate enforcement aspects in As-
pectJfromanRBACspecificationwritteninTemporalZ.Mariscalet
al.[41]introduceanewUMLartifact,called role-slice,whichisused
to generatedaspects. Mustafa etal. [ 35] proposean authorization
engine in which policies written inaZs pe cification are translated
intoaJavaModelingLanguage(JML)specificationtobechecked
by a JML runtime assertion checker.
Alimitationsharedbyallapproachesmentionedaboveisthat
they do not adopt the usage control concept, meaning that the
proposed enforcement mechanisms cannot react to changes in the
RBAC configuration.
Other proposals deal with context-based usage control in RBAC.
Kirkpatricketal.[ 30]proposeaproximity-basedenforcementmech-
anismfortheGEO-RBAC[ 10]modelusingtheXACMLarchitecture.
However, this work does not consider role activation as a separate
request;whensubmittingarequesttoaccessaresource,theuserhas
tospecifytheroletoactivate.Althoughtheproposedmechanism
incorporates usage control, only policies supported by the GEO-
RBAC model,i.e., location-based anddynamic SoDon conflicting
roles,areenforced.Anauthorizationframeworkforenforcingtime-
based policies, based on the X-GTRBAC language and its model
GTRBAC [ 28] has been proposed by Bhatti et al. [ 12]. Policies writ-
tenintheX-GTRBAClanguageareenforcedusingaJava-basedGUI
application.BenDavidetal.[ 4]proposearun-timeenforcement
mechanism composed of a monitor and a change analyzer. Both
the running system and the RBAC policies are expressed using the
models@runtime paradigm [ 13] as a running architecture model.
By observing the system behavior, the monitor sends a notification
tothechangeanalyzerwheneverachangeisdetected.Uponthis
notification,thechangeanalyzerbuildsatargetarchitecturemodelthatwillbeusedtoevaluatetheRBACpolicies.Thisworkissimilartoourenforcementapproachastheybuildatargetmodeltoenforce
theRBACpolicies.However,thisapproachwasnotimplemented
and only assignment and activation relations are supported.
Table3summarizes to which extent the policy enforcement
approachesdiscussedabovesupportthevariousACrequests/eventspresented in section 3. As one can see, the MORRO framework
proposed in this paper is the only one that supports all of them.
In addition, none of the approaches discussed above provides
afullsupportforthecomprehensivesetofauthorizationpolicies
captured by GemRBAC+CTX. Although some approches [ 12,27,
29,30,33–35,41,47,54] provide a prototype implementation of
their enforcement mechanisms, none of these implementationsare available for a performance comparison; the only exceptionis the FACPL framework [
31] that, however, supports a differ-
ent AC model. Furthermore, only few of the aforementioned ap-
proaches [ 27,31,33,47] provide an empirical evaluation assessing
the access decision time; however, we could not compare these
approacheswith ours,sincethe underlyingRBACmodels andthe
application contexts are different.
While in this paper we have addressed the problem of enforcing
ACpolicies,thereisaseriesofwork,orthogonaltoours,thatfocuses
on testing and static verification of AC policies (and, in some cases,
theirimplementation), usingvarious techniquessuch asmutation
testing [11,32], model-based testing [ 53], model checking [ 21,55],
SAT solving [26], theorem proving [14], and static analysis [50].
7 CONCLUSION AND FUTURE WORK
Inthispaperwepresentedamodel-drivenenforcementframework
for policies defined on top of a comprehensive role-based access
control model (GemRBAC+CTX), which leverages the operational-
izationoftheaccesscontrolpoliciesasOCLconstraints.Wereduce
the problem of making an access decision to checking whethera system state (from an RBAC point of view) expressed as an in-
stance of the GemRBAC+CTX model satisfies the OCLconstraints
corresponding to the RBAC policies to be enforced. Policies are
enforced both when an AC request is made and when an AC event
is triggered; we provide the checking algorithms for both cases.
Weimplemented the coreof ourenforcement framework ina tool
calledMORROandprovidedanintegrationstrategyforatypical
industrial Web application, following the guidelines of the XACML
standard architecture. The evaluation results show that MORRO
canbe adoptedwithoutconsiderably impactingtheresponse time
ofaWebapplicationandthatMORROscaleslinearlywithrespecttothevariousparameterscharacterizinganACconfiguration.Overall,theresultsconfirmthefeasibilityofusingamodel-drivenapproach
to efficiently enforce complex RBAC policies.
AlthoughweconsideredtheGemRBAC+CTXmodelintheappli-
cationofourapproach,thelatterisgenericanddoesnotdependon
GemRBAC+CTX: it can be applied to any other AC model that can
be expressed in UML and whose policies can be expressed in OCL.
As part of future work, we plan to assess the end-to-end perfor-
mance of a system integrating MORRO under different evaluation
settings, such as a production configuration deployed on an elastic
cloud infrastructure. We also plan to optimize MORRO in termsof time efficiency by adopting cache-based enforcement [
24,52],
and in terms of space efficiency, by adopting the Kevoree Model-
ing Framework (KMF) [ 22], which is optimized for manipulating
models at run time on large distributed systems.
257
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. Model-Driven Run-Time Enforcement of Complex RBAC Policies ASE ’18, September 3–7, 2018, Montpellier, France
REFERENCES
[1]Gail-JoonAhn.2003. SpecificationandClassificationofRole-basedAuthorization
Policies. In Proc. of WETICE 2003. IEEE, Los Alamitos, CA, USA, 202–207.
[2]Gail-JoonAhnandM.E.Shin.2001. Role-basedauthorizationconstraintsspeci-
ficationusingObjectConstraintLanguage.In Proc.ofWETICE2001.IEEE,Los
Alamitos, CA, USA, 157–162.
[3]Subhendu Aich, Shamik Sural, and A.K. Majumdar. 2007. STARBAC: Spatiotem-
poralRoleBasedAccessControl.In Proc.oftheOTMConferences2007 (LNCS),
Vol. 4804. Springer-Verlag, Heidelberg, Germany, 1567–1582.
[4]Olivier-Nathanaël Ben David and Benoit Baudry. 2012. Toward a Model-driven
Access-controlEnforcementMechanismforPervasiveSystems.In Proc.ofMDSEC
2012. ACM, New York, NY, USA, 6:1–6:6.
[5]Ameni Ben Fadhel. 2017. Comprehensive Specification and Efficient Enforcement
of Role-based Access Control Policies using a Model-driven Approach . Ph.D. Disser-
tation. University of Luxembourg.
[6]Ameni Ben Fadhel, Domenico Bianculli, and Lionel Briand. 2015. A Comprehen-
sive Modeling Framework for Role-based Access Control Policies. J. Syst. Softw.
107 (September 2015), 110–126.
[7]AmeniBenFadhel,DomenicoBianculli,andLionelBriand.2016. GemRBAC-DSL:
AHigh-levelSpecificationLanguageforRole-basedAccessControlPolicies.In
Proc. of SACMAT 2016. ACM, New York, NY, USA, 179–190.
[8]Ameni Ben Fadhel, Domenico Bianculli, Lionel Briand, and Benjamin Hourte.
2016. AModel-drivenApproachtoRepresentingandCheckingRBACContextual
Policies. In Proc. of CODASPY 2016. ACM, New York, NY, USA, 243–253.
[9]ElisaBertino,PieroAndreaBonatti,andElenaFerrari.2001. TRBAC:ATemporal
Role-basedAccessControlModel. ACMTrans.Inf.Syst.Secur. 4,3(Aug.2001),
191–233.
[10]ElisaBertino,BarbaraCatania,MariaLuisaDamiani,andPaoloPerlasca.2005.
GEO-RBAC:ASpatiallyAwareRBAC.In Proc.ofSACMAT2005.ACM,NewYork,
NY, USA, 29–37.
[11]AntoniaBertolino,SaidDaoudagh,FrancescaLonetti,andEdaMarchetti.2016.
Testing Access Control Policies Against Intended Access Rights. In P r oc .o fS A C
2016. ACM, New York, NY, USA, 1641–1647.
[12]RafaeBhatti,ArifGhafoor,ElisaBertino,andJamesB.D.Joshi.2005. X-GTRBAC:
An XML-based Policy Specification Framework and Architecture for Enterprise-
wide Access Control. ACM Trans. Inf. Syst. Secur. 8, 2 (May 2005), 187–227.
[13]Gordon Blair, Nelly Bencomo, and Robert B France. 2009. Models@run.time.
Computer 42, 10 (2009), 22–27.
[14]Ivan Bocić and Tevfik Bultan. 2016. Finding Access Control Bugs in Web Ap-
plications with CanCheck. In Proc. of ASE 2016. IEEE, Los Alamitos, CA, USA,
155–166.
[15]MarcoBrambilla,JordiCabot,andManuelWimmer.2017. Model-DrivenSoftware
EngineeringinPractice,SecondEdition. Morgan&ClaypoolPublishers,California,
USA.
[16]V. Cardellini, M. Colajanni, and P. S. Yu. 1999. Dynamic load balancing on
Web-server systems. IEEE Internet Computing 3, 3 (May 1999), 28–39.
[17]EmmanuelCecchet,VeenaUdayabhanu,TimothyWood,andPrashantShenoy.
2011. BenchLab:AnOpenTestbedforRealisticBenchmarkingofWebApplica-
tions. InProc. of WebApps 2011. USENIX Association, Berkeley, CA, USA, 12.
[18]Jason Crampton andHemanth Khambhammettu. 2008. Delegationin Role-based
Access Control. Int. J. Inf. Secur. 7, 2 (2008), 123–136.
[19]Eclipse.2011.EclipseOCLTools. http://www.eclipse.org/modeling/mdt/?project=
ocl.
[20] Eclipse. 2013. Ecore. https://www.eclipse.org/ecoretools/.
[21]Kathi Fisler, Shriram Krishnamurthi, Leo A. Meyerovich, and Michael Carl
Tschantz. 2005. Verification and Change-impact Analysis of Access-control
Policies. In Proc. of ICSE 2005. ACM, New York, NY, USA, 196–205.
[22]François Fouquet, Grégory Nain, Brice Morin, Erwan Daubert, Olivier Barais,
Noël Plouzeau, and Jean-Marc Jézéquel. 2012. An Eclipse Modelling Framework
Alternative to Meet the Models@ Runtime Requirements. In Proc. of MODELS
2012 (LNCS), Vol. 7590. Springer-Verlag, Heidelberg, Germany, 87–101.
[23]Andy Georges, Dries Buytaert, and Lieven Eeckhout. 2007. Statistically Rigorous
JavaPerformanceEvaluation.In Proc.ofOOPSLA2007.ACM,NewYork,NY,USA,
57–76.
[24]Jeffrey Hieb, Jacob Schreiver, and James Graham. 2012. Using Bloom Filtersto Ensure Access Control and Authentication Requirements for SCADA Field
Devices. In Proc. of ICCIP 2012 (LNCS), Vol. 390. Springer, Heidelberg, Germany,
85–97.
[25]V.C.Hu,D.R.Kuhn,andD.F.Ferraiolo.2015. Attribute-BasedAccessControl.
Computer 48, 2 (Feb 2015), 85–88. https://doi.org/10.1109/MC.2015.33
[26]GrahamHughesandTevfikBultan.2008.Automatedverificationofaccesscontrol
policiesusingaSATsolver. Int.J.Softw.ToolsTechnol.Transf. 10,6(01Dec2008),
503–520. https://doi.org/10.1007/s10009-008-0087-9
[27]WaldemarHummer,PatrickGaubatz,MarkStrembeck,UweZdun,andSchahram
Dustdar.2013. EnforcementofEntailmentConstraintsinDistributedDervice-
based Business Processes. Inf. Softw. Technol. 55, 11 (2013), 1884–1903.[28]JamesBDJoshi,ElisaBertino,UsmanLatif,andArifGhafoor.2005.AGeneralized
TemporalRole-basedAccessControlModel. IEEETrans.Knowl.DataEng. 17,1
(January 2005), 4–23.
[29]Slim Kallel, Anis Charfi, Mira Mezini, Mohamed Jmaiel, and Karl Klose. 2009.
From Formal Access Control Policies to Runtime Enforcement Aspects. In Proc.
of ESSoS 2009 (LNCS), Vol. 5429. Springer, Heidelberg, Germany, 16–31.
[30]Michael S. Kirkpatrick and Elisa Bertino. 2010. Enforcing Spatial Constraints
for Mobile RBACSystems. In Proc. of SACMAT2010. ACM, NewYork, NY, USA,
99–108.
[31]A.Margheri,M. Masi,R.Pugliese,andF.Tiezzi.in press. ARigorousFramework
for Specification, Analysis and Enforcement of Access Control Policies. IEEE
Trans. Softw. Eng. (in press), 40.
[32]EvanMartinandTaoXie.2007. AFaultModelandMutationTestingofAccess
Control Policies. In Proc. of WWW 2007. ACM, New York, NY, USA, 667–676.
[33]Salvador Martínez, Jokin García, and Jordi Cabot. 2016. Runtime Support for
Rule-basedAccess-controlEvaluationThroughModel-transformation.In Proc.
of SLE 2016. ACM, New York, NY, USA, 57–69.
[34]Azzam Mourad, Sara Ayoubi, Hamdi Yahyaoui, and Hadi Otrok. 2010. New
approach for the dynamic enforcement of Web services security. In Proc. PST
2010. IEEE, Los Alamitos, CA, USA, 189–196.
[35]Tanveer Mustafa, Michael Drouineaud, and Karsten Sohr. 2010. Towards Formal
Specification and Verification of a Role-based Authorization Engine Using JML.
InProc. of SESS 2010. ACM, New York, NY, USA, 50–57.
[36] Netflix. 2014. Zuul. https://github.com/Netflix/zuul/.
[37]OASIS. 2005. eXtensible Access Control Markup Language (XACML) Version
2.0.
[38]Alan C. O’Connor and Ross J. Loomis. 2010. Economic Analysis of Role-Based
Access Control. Technical Report. RTI International for National Institute of
Standards and Technology.
[39] OMG. 2012. Object Constraint Language. http://www.omg.org/spec/OCL/.
[40]Jaehong Park and Ravi Sandhu. 2004. The UCONABC Usage Control Model.
ACM Trans. Inf. Syst. Secur. 7, 1 (Feb. 2004), 128–174.
[41]J.A. Pavlich-Mariscal, T. Doan, L. Michel, S.A. Demurjian, and T.C. Ting. 2005.
Role Slices: A Notation for RBAC Permission Assignment and Enforcement. In
Proc. of DBSec 2005. LNCS, Vol. 3654. Springer, Heidelberg, Germany, 40–53.
[42]Indrakshi Ray and Manachai Toahchoodee. 2007. A Spatio-temporal Role-Based
Access Control Model. In Proc. of DBSec 2007 (LNCS), Vol. 4602. Springer, Heidel-
berg, Germany, 211–226.
[43]Ravi S. Sandhu, Edward J. Coyne, Hal L. Feinstein, and Charles E. Youman. 1996.
Role-based Access Control Models. Computer 29, 2 (1996), 38–47.
[44]Basit Shafiq, Ammar Masood, James Joshi, and Arif Ghafoor. 2005. A Role-based
Access Control Policy Verification Framework for Real-time Systems. In Proc. of
WORDS 2005. IEEE, Los Alamitos, CA, USA, 13–20.
[45]Richard T. Simon and Mary Ellen Zurko. 1997. Separation of Duty in Role-based
Environments. In Proc. of CSFW 1997. IEEE, Los Alamitos, CA, USA, 183–194.
[46]KarstenSohr,MircoKuhlmann,MartinGogolla,HongxinHu,andGail-JoonAhn.
2012. Comprehensive two-level analysis of r ole-based delegation and revocation
policies with UML and OCL. Inf. Softw. Technol. 54, 12 (2012), 1396–1417.
[47]Karsten Sohr, Tanveer Mustafa, Xinyu Bao, and Gail-Joon Ahn. 2008. Enforcing
role-based access control policies in web services with UML and OCL. In Proc. of
ACSAC 2008. IEEE, Los Alamitos, CA, USA, 257–266.
[48]MarkStrembeckandJanMendling.2011. ModelingProcess-relatedRBACModels
withExtended UMLActivityModels. Inf.Softw. Technol. 53,5 (May2011),456–
483.
[49] Spring Tool Suite. 2014. Spring Boot. https://projects.spring.io/spring-boot/.
[50]FangqiSun,LiangXu,andZhendongSu.2011. StaticDetectionofAccessControl
VulnerabilitiesinWebApplications.In Proc.ofSEC2011.USENIXAssociation,
Berkeley, CA, USA, 11–11.
[51]Transaction Processing Performance Council. 2001. TPC Benchmark W (Web
Commerce) Specification v.1.7. www.tpc.org/tpcw/spec/tpcw_V17.pdf .
[52]Qiang Wei, Jason Crampton, Konstantin Beznosov, and Matei Ripeanu. 2011.
Authorization Recycling in Hierarchical RBAC Systems. ACM Trans. Inf. Syst.
Secur.14, 1, Article 3 (June 2011), 29 pages. https://doi.org/10.1145/1952982.
1952985
[53]DianxiangXu,LijoThomas,MichaelKent,TejeddineMouelhi,andYvesLeTraon.2012. A Model-based Approach to Automated Testing of Access Control Policies.
InProc. of SACMAT 2012. ACM, New York, NY, USA, 209–218.
[54]Longhua Zhang, Gail-Joon Ahn, and Bei-Tseng Chu. 2003. A Rule-based Frame-
work for Role-based Delegation and Revocation. ACM Trans. Inf. Syst. Secur. 6, 3
(2003), 404–441.
[55]Nan Zhang, Mark Ryan, and Dimitar P. Guelev. 2005. Evaluating Access Control
PoliciesThroughModelChecking.In Proc.ofISC2005 (LNCS),Vol.3650.Springer,
Heidelberg, Germany, 446–460.
[56]ZhikunZhang,JianguoXiao,HanyiLi,andYoupingGeng.2008. AnExtended
Permission-basedDelegationAuthorizationModel.In Proc.ofCSSE2008,Vol.3.
IEEE, Los Alamitos, CA, USA, 696–699.
258
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. 