SymbolicExecution ofProgrammableLogicController Code 
Shengjian Guo
VirginiaTech 
Blacksburg, VA, USA Meng Wu 
Virginia Tech 
Blacksburg, VA, USA Chao Wang 
UniversityofSouthern California 
LosAngeles, CA, USA
ABSTRACT 
Programmablelogiccontrollers(PLCs)arespecializedcomputers 
forautomatingawiderangeofcyber-physicalsystems.Sincethese 
systemsareoftensafety-critical,softwarerunningonPLCsneedto 
be free of programming errors. However, automated tools for test- 
ingPLC software are lacking despite the pervasive use ofPLCs in 
industry. Wepropose asymbolicexecutionbasedmethod,named 
S/y.sc/m.scPLC, for automatically testing PLC software written in pro- 
gramminglanguagesspeci/f_iedintheIEC61131-3standard. S/y.sc/m.scPLC
takesthePLCsourcecodeasinputandtranslatesitintoCbefore 
applyingsymbolicexecution,tosystematicallygeneratetestinputs 
that cover both paths in each periodic task and interleavings of 
these tasks. Toward this end, we propose a number of PLC-speci/f_ic 
reduction techniques for identifying and eliminating redundant in- 
terleavings.Wehaveevaluated S/y.sc/m.scPLConalargesetofbenchmark 
programs with both single and multiple tasks. Our experiments 
showthat S/y.sc/m.scPLCcanhandletheseprogramseﬃciently,andfor 
multi-task PLC programs, our new reduction techniques outper- 
formthestate-of-the-artpartialorderreductiontechniquebymore 
thantwoorders ofmagnitude.
CCSCONCEPTS
•Softwareanditsengineering →Softwareveri/f_icationandvali- 
dation;Software testing anddebugging;Software evolution;
KEYWORDS 
Symbolicexecution,Testgeneration,Partialorderreduction,Pro- 
grammablelogiccontroller, PLC, SCADA 
ACM Referenceformat: 
Shengjian Guo, Meng Wu, and Chao Wang. 2017. Symbolic Execution of 
Programmable Logic Controller Code. In Proceedings of 2017 11th Joint 
Meeting of the European Software Engineering Conference and the ACM 
SIGSOFT Symposium on the Foundations of Software Engineering, Paderborn,
Germany,September4-8,2017 (ESEC/FSE’17), 11pages.
https://doi.org/10.1145/3106237.3106245
1 INTRODUCTION 
Programmablelogiccontrollers(PLCs)arespecializedcomputers 
forautomatingelectro-mechanicalprocessesinawidevarietyof 
industrialapplications,includingfactoryassemblylines,transporta- 
tionsystems,andsmartpowergrids.PLCsareoftenequippedwith 
domain-speci/f_ic operating systems and virtual machines for exe- 
cutingsoftware code written in programming languages suchas 
Permissionto make digital or hardcopiesof all orpart ofthis work forpersonal or 
classroom use is granted without fee provided that copies are not made or distributed 
forpro/f_itorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation 
on the /f_irst page. Copyrights for components of this work owned by others than ACM 
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,
topostonserversortoredistributetolists,requirespriorspeci/f_icpermissionand/ora 
fee. Requestpermissions frompermissions@acm.org.
ESEC/FSE’17,September4-8,2017,Paderborn,Germany 
©2017Association forComputing Machinery.
ACM ISBN 978-1-4503-5105-8/17/09...$15.00 
https://doi.org/10.1145/3106237.3106245Structured Text (ST), Ladder Diagram (LAD), and Sequential Func- 
tionChart(SFC).SincePLCsoftwarecontrolcriticalinfrastructures 
(e.g.,the SCADA systems), design defects orimplementation bugs 
may lead to catastrophes. However, despite the already widespread 
use of PLCs, automated testing tools are still lacking. In this work,
we /f_ill the gap by developing a symbolic execution based tool for 
automaticallytesting PLCsoftware.
Symbolic execution is a popular technique for generating test 
inputs to systematically explore feasible paths of a program. Al- 
thoughsymbolicexecutionhasbeenappliedtomanyprogramming 
languages,priortothiswork,ithasneverbeenappliedtoPLCs.One 
reason is that PLC software are written in specialized and some- 
what archaic languages that diﬀerfrommainstream programming 
languages,thuslackingopen-sourcedevelopmenttools.Another 
reason is that PLC software are periodic programs that often do 
not terminate, and they involve multiple tasks running concur- 
rently with respect to each other. Tasks have diﬀerent priority 
levels,wherehigh-prioritytasksmaypreemptlow-prioritytasks,
but not vice versa. Thus, precise modeling of this non-conventional
execution semanticsisdiﬃcult.
We solve these problems by leveraging an open-source PLC 
compiler named Matiec[39 ] and a symbolic execution tool named 
Cloud9[19 ]. First, we leverage Matiecto translate each PLC task 
fromtheoriginallanguage(e.g.,ST)toC.TheCcodeisfunctionally- 
equivalentinthateachofitsprogrampathshasacorresponding 
pathintheoriginalPLCtask,whichensuresthattestsgenerated 
from the C code can be mapped back to the PLC. Second, we auto- 
maticallysynthesizeatestharness(i.e.,the main()functioninC)to 
invokePLCtasksasthreads.Threadsarefurtherconstrainedtopre- 
ciselymodelthepriority-basedpreemptiveschedulingasde/f_ined 
inthePLCprogramsemantics.Finally,weextend Cloud9tosym- 
bolicallyexecutethemulti-threadedCmodel.Thenewsymbolic 
execution procedure systematically generate test cases to cover 
bothpathsof eachperiodictaskandtheirinterleavings.
Figure1showsthe/f_lowof S/y.sc/m.scPLC,where PdenotesthePLC
program, and translation from Pto C is implemented in the Matiec
PLC compiler. Our symbolic execution procedure based on Cloud9
producestestcasesoftheform (in ,sch ),where in denotestheinput
dataandsch denotestheinterleaving schedule.Since Cloud9only
supportscoarse-grainedthreadscheduling,weextendedittoexe- 
cutemultithreadedCcode ata /f_inergranularity. Furthermore, we 
proposeseveralPLC-speci/f_icreductiontechniquesthatleveragethe 
periods and priorities of tasks as well as visited states to eﬃciently 
pruning redundant interleavings. Since these redundant interleav- 
ings are due to PLC-speci/f_ic program semantics, they cannot be 
removedby partial orderreduction techniques[23, 33,49].
One advantage of S/y.sc/m.scPLCas a tool is the /f_lexibility resulted 
from its separation of the modeling andanalysisphases. In the 
modelingphase,itfocusesoncapturingthesemanticsofaPLCpro- 
gramwritteninvariouslanguagesbyconstructingthefunctionally- 
equivalent C model. Each PLC language may be handled by a ded- 
icated front-end; multiple front-ends may be developed indepen- 
dently.Intheend,PLCtasks,regardlessofwhichlanguagesthey ESEC/FSE’17,September4-8, 2017, Paderborn, Germany Shengjian Guo,MengWu,andChao Wang 
PLC Program ( P)
and Properties Modeling in C Adding Test Harness 
and Constraints
Current Input
(in ,sch)PLC Symbolic Execution
based on KLEE 
Generate New 
Test Input Redundancy Pruning 
(period, priority, stateful) 
Figure1: SymPLC:The overall/f_lowof ourmethod.
were written in, are merged to the same C model that simulates 
the preemptive scheduling. In the analysis phase, S/y.sc/m.scPLCfocuses 
on executing the C model eﬃciently, without worrying about PLC 
languagecomplications.Theoverallarchitectureallows S/y.sc/m.scPLC
toeasily supportnewlanguages andexecution platforms.
Anotheradvantageof S/y.sc/m.scPLCistheeﬃciencyresultedfromthe 
PLC-speci/f_ic interleaving reduction techniques. Since these new 
techniquesare designedspeci/f_icallyforthePLCtaskscheduling,
they are more eﬀective than generic partial order reduction (POR) 
techniques. In the experiments section, we will show POR is often 
ineﬀective for removing redundant executions in PLC programs 
due to their semantic diﬀerences from thread interleavings. For 
example, in standard multithreaded programs, two threads with 
the same priority level are allowed to preempt each other, whereas 
in PLC programs, they are not allowed to preempt each other. Fur- 
thermore,PLCtasksareexecutedperiodically,whichmeansthey 
never terminate. Our new reduction techniques are designed to 
takeadvantage ofthese unique characteristics.
S/y.sc/m.scPLCisatestinputgenerationtool.Assuch,itdiﬀersfrom 
existingtoolsforsimulating,verifying,orsynthesizingPLCsoft- 
ware.Speci/f_ically,simulators[ 13 ,31 ,44 ]can executePLCcode in 
controlledenvironments,buttheyrequiretheuserstohandcraft 
testinputs.Incontrast, S/y.sc/m.scPLCautomaticallygeneratesthesein-
puts.Veri/f_icationtools[ 22 ,34 ,43 ]aredesignedtoformallyprove 
thecorrectness ofproperties in models of PLCsoftware, butthese 
formal models are at a much higher level of abstraction than the 
actual software code. In contrast, S/y.sc/m.scPLCdirectly executes the 
actualPLCcode.Synthesistools[ 17 ,18 ]havetheambitiousgoal 
of generating PLC code directly from formal speci/f_ications, thus 
bypassing the programmers completely. However, these tools only 
synthesizesmallprogramswithsingletasksduetoscalabilityprob- 
lems.Incomparison, S/y.sc/m.scPLCismorescalableandcanuniformly 
handlebothsingle-andmulti-taskPLCprograms.
Wehaveimplemented S/y.sc/m.scPLCandevaluatediton93PLCbench- 
markprograms,including49single-taskprogramsand44multi-task 
programs. In total, they consist of 26,713 lines of ST code, which 
translateto62,926linesofCcode.Propertiesareexpressedasas- 
sertions embedded in the source code. During our experiments, we 
evaluatedtheexecutiontimeof S/y.sc/m.scPLCaswellasitseﬀectiveness 
indetectingpropertyviolations.WealsocomparedourPLC-speci/f_ic 
reductiontechniqueswithstate-of-the-artPORtechniques;forcom- 
parison,weimplementedtheDPORalgorithm[ 23 ]in S/y.sc/m.scPLC.Our 
experimental results show that S/y.sc/m.scPLCcan eﬃciently generate
test cases for all benchmark programs, and for multi-task PLC pro- 
grams, in particular, our new reduction techniques signi/f_icantly 
outperform thestate-of-the-artPOR technique.
Tosummarize, we make the following contributions:•We develop a symbolic execution tool for PLC software by 
/f_irst translating the original PLC tasks to C code and then 
applyingsymbolicexecution togenerate the testinputs.
•We propose PLC-speci/f_ic reduction techniques for more 
eﬀectively eliminating redundant interleavings than state- 
of-the-artPOR techniques.
•Weimplementandevaluateourtechniquesonalargenum- 
berofbenchmarkprogramstodemonstratetheireﬃciency 
andeﬀectiveness.
The remainder of this paper is organized as follows. First, we 
illustratethemainproblemsoftestingPLCsoftwareinSection2.
Then, we present our new method for modeling the PLC program 
using a multi-threaded C in Section 3. We present the overall sym- 
bolic execution algorithm in Section 4, which is followed by the 
PLC-speci/f_icreduction techniques in Section 5. Our experimental 
evaluation is presented in Section 6. We review the related work in 
Section 7. Finally, we give ourconclusionsin Section 8.
2 MOTIVATINGEXAMPLES 
Inthissection,weuseexamplestoillustratebugsinPLCprograms 
andexplain why ournewmethod isnecessarytodetectthem.
2.1 Single-taskPLC Programs 
Figure2showsthreePLCprogramsthatimplementatwo-player 
game named Responder [16 ], where I0.0,I0.1andI0.2are inputs 
from the game host and two players, while Q0.0andQ0.1are 
outputs for the players. The program consists of two sections:
CONFIGURATION andPROGRAM.The CONFIGURATION sectiondeclares 
globalvariablesandallocatesresource(CPU)toatask.Forexample,
Task T1 isstartedevery10millisecondsandeachtimeitexecutes 
an instance named Gameof the program ProgA. The actual code of 
ProgA,providedinthe PROGRAMsection,hastwostatements.The 
/f_irst statement at Line 12 reads from I0.0,I0.1,Q0.0, and Q0.1and
then computes the new value for Q0.0, while the second statement 
computes thenewvalue for Q0.1.
Initially, all inputs, outputs, and global variables are set to false.
Thehoststartsthegamebysetting I0.0to true.Then,theplayers 
try to respond as quickly as possible by setting their inputs to true.
If the /f_irst player is faster, its output Q0.0becomes true, indicating 
she has won. But if the /f_irst player is slower, the second player’s 
outputQ0.1becomes true. After a player’s output becomes true, it 
should remain true until the hostsets I0.0backto false.
TheprograminFigure2(a)isbuggybecause,whenbothplayers 
respondatthesametime,theprogramisnotabletosetbothoutputs 
to true(indicating a tie). Instead, it is biased toward the /f_irst player 
–sincethePLCprogramisexecutedsequentially,i.e.,onelineafter 
another,Q0.0will be set to true/f_irst, which prevents Q0.1from 
beingsetto truesubsequently.
To/f_ixthisbug,wecouldintroducetwoauxiliaryglobalvariables 
M0.0andM0.1as shown in Figure 2 (b), to buﬀer the temporary 
outputsbeforeassigningthemto Q0.0andQ0.1,respectively.Thus,
settingM0.0to truedoes not prevent M0.1from becoming true. In- 
deed,whenthetwoplayersrespondatthesametime,bothoutputs 
will be set to true. Unfortunately, the revised program is still faulty.
Assume that both outputs have been set to trueat the end of the 
/f_irsttaskexecution because twoplayersresponded concurrently.
Since task T1 executes periodically, during the next task execution,
Q0.1being truewillforce Q0.0tobecome false,and Q0.0being true
will force Q0.1to become false. Thus, both outputs become falseat Symbolic ExecutionofProgrammable Logic ControllerCode ESEC/FSE’17, September4-8, 2017, Paderborn, Germany 
1CONFIGURATION PLC_Cell1
2 VAR_GLOBAL
3 I0.0:BOOL; I0.1: BOOL; I0.2: BOOL;
4 Q0.0:BOOL; Q0.1: BOOL;
5 END_VAR
6 RESOURCE CPU_Responder ON CPU001
7 TASKT1 ( INTERVAL := t#10ms, PRIORITY := 1); 
8 PROGRAM GameWITHT1 : ProgA; 
9 END_RESOURCE
10 END_CONFIGURATION
11 PROGRAM ProgA
12 Q0.0 := (I0.1 OR Q0.0)AND(NOTQ0.1)ANDI0.0 ;
13 Q0.1 := (I0.2 OR Q0.1)AND(NOTQ0.0)ANDI0.0 ;
14 END_PROGRAM
(a) The initial (buggy) implementation 
1VAR_GLOBAL
2...; M0.0: BOOL; M0.1: BOOL;
3END_VAR
4...
5PROGRAM ProgA
6 M0.0 := (I0.1 OR Q0.0)AND(NOTQ0.1)ANDI0.0 ;
7 M0.1 := (I0.2 OR Q0.1)AND(NOTQ0.0)ANDI0.0 ;
8 Q0.0 := M0.0; 
9 Q0.1 := M0.1; 
10 END_PROGRAM
(b) Revisedbutstill buggy implementation 
1PROGRAM ProgA
2 M0.0 := (I0.1 AND(NOTQ0.1)OR Q0.0)ANDI0.0 ;
3 M0.1 := (I0.2 AND(NOTQ0.0)OR Q0.1)ANDI0.0 ;
4 Q0.0 := M0.0; 
5 Q0.1 := M0.1; 
6END_PROGRAM
(c) The correctimplementation 
Figure2:Three implementations of PLC Responder inST.
the end of the second execution, which is not expected. Recall that 
the expected behavior is that both outputs remain true, until the 
hostends the game.
To /f_ix the second bug, we need to revise the code as shown 
in Figure 2 (c). Compared with the program in Figure 2 (b), the 
modi/f_icationisactuallyminor–wesimplyenlargethescopeofthe 
two logical-OR operators to include Q0.0andQ0.1. Because of this 
modi/f_ication, after Q0.0andQ0.1become true, they will remain 
trueduringallsubsequentexecutionsof T1 regardlessofthenew 
inputdata,until the host endsthe game bysetting I0.0to false.
ThesethreeexamplesshowthatevenasimplePLCprogramwith 
a single task may have subtle bugs in its implementation due to 
the non-conventional program semantics. Thus, automated testing 
tools suchas S/y.sc/m.scPLCwouldbe invaluable.
2.2 Multi-taskPLC Programs 
Figure 3 shows a PLC program with two tasks that implement a 
simpli/f_iedversionoftheroboticcontrollerfrom[ 15 ].The RESOURCE
sectioncontainsthetwotasks,bothofwhichareassignedtothe 
device CPU001.Task T1 hasashorterperiod( 100ms)andahigher 
priority, while task T2 has a longer period ( 200ms) and a lower 
priority. In PLCs, high-priority tasks may preempt low-priority 
tasks, but not viceversa. Assume tasks nevermiss theirdeadlines,
thenimplicitly,thetimingconstraintisthat T1 /f_inishesitsexecution 
within100msand T2 /f_inisheswithin200ms.Furthermore,thetasks 
are associatedwith ProgAandProgBde/f_inedbelow.
ThePROGRAMsectionsprovidethesourcecodeofthetasks,which 
share two global variables. In addition, ProgAreads from the input 
variableSensor_input , whereas ProgBdoes not read from any 
primary input.1CONFIGURATION PLC_Cell2
2 VAR_GLOBAL
3 Obstacle : BOOL:= 0; Forward : INT:= 50; 
4 END_VAR
5 RESOURCE CPU_main ON CPU001
6 TASKT1 ( INTERVAL := t#100ms, PRIORITY := 1); //High
7 TASKT2 ( INTERVAL := t#200ms, PRIORITY := 2); //Low
8 PROGRAM FastWITHT1 : ProgA; 
9 PROGRAM SlowWITHT2 : ProgB; 
10 END_RESOURCE
11 END_CONFIGURATION
12 
13 PROGRAM ProgA
14 VAR_INPUT
15 Sensor_input : INT;
16 END_VAR
17 Obstacle := 0; 
18 IF (Sensor_input <= 10) THEN
19 Obstacle := 1; 
20 Forward := -100; 
21 END_IF;
22 END_PROGRAM
23 
24 PROGRAM ProgB
25 IF (Obstacle = 0) THEN
26 Forward = 100; 
27 END_IF;
28 END_PROGRAM
Figure 3:A Multi-task PLCProgram inStructuredText.
/g1004/g373/g400 /g1005/g1004/g1004/g373/g400 /g1006/g1004/g1004/g373/g400 /g94/g286/g374/g400/g381/g396/g890/g349/g374/g393/g437/g410/g3/g1093/g3/g1005/g1004 /g94/g286/g374/g400/g381/g396/g890/g349/g374/g393/g437/g410/g3/g1092/g1089/g3/g1005/g1004 
/g75/g271/g400/g410/g258/g272/g367/g286/g3/g855/g1089/g3/g1005 
/g38/g381/g396/g449/g258/g396/g282/g3/g855/g1089/g3/g882/g1005/g1004/g1004 
/g38/g381/g396/g449/g258/g396/g282/g3/g855/g1089/g3/g1005/g1004/g1004 /g75/g271/g400/g410/g258/g272/g367/g286/g3/g1089/g3/g1004 /g75/g271/g400/g410/g258/g272/g367/g286/g3/g855/g1089/g3/g1004 
/g38/g381/g396/g449/g258/g396/g282/g3/g855/g1089/g3/g1009/g1004/g3 
Figure 4:Thetask interleavingthat fails theassertion.
ProgAisresponsibleforobstacledetection,e.g.,bysetting Forward
tothereversespeed-100whenthevalueoftheinput Sensor_input
indicates an obstacle ahead. ProgBcomputes the forward speed of 
therobotifnoobstacleisdetected.Thus,bothtasksmaywriteto 
thevariable Forward(Lines20and26).Theraceconditionwould 
cause a problemin the followingscenario:
•T1 runs /f_irstand Sensor_input isgreaterthan 10;
•T1 /f_inishesits /f_irstexecution of ProgA;
•T2 starts andproceeds tothe statementatLine 26,then it 
ispreemptedby T1 before writingto Forward;
•T1 detects an obstacle and sets Forwardto -100, and /f_in- 
ishesitssecondexecution of ProgA;
•T2 continuesthe execution of ProgB.
At this moment, the value of Forward is -100, and should have 
remained -100, but ProgBoverwrites it to 100 as illustrated by 
Figure 4. The erroneous value is not expected, and may result in 
the robothittingthe obstacle.
NotethatdetectingthekindofbugshowninFigure4isnoteasy,
sinceitrequiresacombinationoftherightinputdata( Sensor_input
being >10 inthe/f_irstexecutionof ProgAand≤10 inthesecond 
execution of ProgA) andtaskinterleaving( ProgBis preemptedby 
thesecondexecutionof ProgArightbeforethewriteto Forward).
Although in practice, simulators may be used to reproduce this 
bug after it is detected, the users are required to handcraft the ESEC/FSE’17,September4-8, 2017, Paderborn, Germany Shengjian Guo,MengWu,andChao Wang 
error-triggering input data in the /f_irst place, which is diﬃcult. Fur- 
thermore,simulatorsdonothavethecapabilityofsystematically 
exploring the space of task interleavings. Our S/y.sc/m.scPLCtool, in con- 
trast, solves the problemby automaticallyexploring the combined 
inputandinterleavingspace.Thus,giventhe source code ofthis 
PLCprogram, S/y.sc/m.scPLCwillgeneratenotonlythefailure-triggering
testdata but alsothe corresponding task schedule.
3 MODELINGPLCPROGRAM SEMANTICS 
We/f_irstpresentourmethodfortranslatingPLCtaskstoequivalent 
Ccode, andthen model theirexecution semantics usingthreads.
3.1 TranslatingPLCTasks toC 
Variables . PLCprograms have diﬀerentvariable types. Forexam- 
ple, the keyword VAR_INPUT de/f_ines read-only input variables,
VAR_OUTPUTde/f_inesoutput-onlyvariables,andVAR_EXTERNAL 
de/f_inestheglobalvariables.ThereareeightsuchusagetypesinIEC 
61131-3 standard, all of which are mapped by S/y.sc/m.scPLCto proper 
variablesintheCprogram.Thetranslationismostlystraightfor- 
wardexceptforinputs, whichrequire special handling.
Inputs. Variables such as sensor_i1 andsensor_i2 at Line 15 
in Figure 5 are primary inputs. They need to be fed a symbolic 
valueeverytimethecorrespondingtaskisactivated.Thisisaccom- 
plishedby calling the APIfunction symplc_mk_symbolic , which 
returnsasymbolicvalueforthevariable.Wealsoapplyvalue-range 
constraintsoverthesesymbolicvaluestoensurethattheyalways 
concretize to values allowed by their types. The use of symbolic 
values simulates the factthat input data maybe arbitrary.
Timers.ThebehaviorofPLCtimersisabstractedbytreatingthe 
output ofeach timerinvocation as a symbolic variable:it iseither 
trueor falsesincebothvaluesarepossibleatruntime.Itensures 
thatactionsdependingondiﬀerenttimeroutputsarealwayscov- 
ered. Although this modeling approach may introduce potentially 
redundant test cases, it has the advantage of not missing any valid 
testinput.Furthermore,weshallshowthattheredundanttestcases 
maybeeliminatedbyournewPLC-speci/f_icreductiontechniques 
implementedinside the symbolicexecution procedure.
Statements . The translation of PLC program statements from the 
ST language to C is straightforward because as a programming 
language, C is strictly more expressive than ST. Thus, any ST state- 
ment in the original program can be expressed by a corresponding 
Cstatement.Furthermore,sincethenumberofbuilt-infunctions 
inST(libraryfunctions)isfairlysmall,eachofthesefunctionsmay 
be replaced by a corresponding C function. In our implementation,
the translation from ST code to C code is carried out by the Matiec
PLC compiler, which has been designed to conform to the popular 
IEC 61131-3standard. In Figure 5, forexample, the program state- 
mentsofthePLCroboticcontrollerare translatedintotheCcode 
atLines 1-13.
3.2 ConstructingtheTest Harness 
The test harness is the main()function that treats PLC tasks as 
threadsandincorporatesthemtoacompleteCprogram.InFigure5,
for example, the test harness consists of Lines 14-38. There are two 
separate issues in simulating PLC tasks using threads. The /f_irst 
one is constructing a thread for potentially multiple invocations of 
each task (Lines 14-24). The second one is using these threads to 
simulatethe periodicexecution ofPLCtasks (Lines 25-38).1bool Obstacle = 0; intForward = 50; 
2voidProgA (intSensor_input){
3 Obstacle = 0; 
4 if (Sensor_input <= 10){ 
5 Obstacle = 1; 
6 Forward = -100; 
7 }
8}
9voidProgB (){
10 if (!Obstacle){
11 Forward = 100; 
12 }
13 }
14 voidthread1 () { 
15 intsensor_i1, sensor_i2;
16 symplc_mk_symbolic(&sensor_i1, ...);
17 symplc_mk_symbolic(&sensor_i2, ...);
18 ProgA(sensor_i1);
19 //symplc_task_boundary();
20 ProgA(sensor_i2);
21 }
22 voidthread2 () { 
23 ProgB();
24 }
25 intmain(void){ 
26 pthread_t t1, t2;
27 for(i=0; i<MAX_ITER; i++) {
28 //symplc_hyperperiod_begin();
29 pthread_create(&t1, 0, thread1, 0); 
30 pthread_create(&t2, 0, thread2, 0); 
31 //symplc_set_priority_n_period(t1, 1, 100);
32 //symplc_set_priority_n_period(t2, 2, 200);
33 pthread_join(&t1);
34 pthread_join(&t2);
35 //symplc_hyperperiod_end();
36 assert(Obstacle == (Forward == -100)); // property
37 }
38 }
Figure 5:The Multithreaded CModelof theSTProgram.
It is always feasible to simulate PLC task interleaving seman- 
tics using threads because threads have strictly more permissive 
interleavingsemantics.Thatis,allpossibleinterleavingsallowed 
by PLC tasks are included in the set of interleavings allowed by 
threads. However, threads may allow certain interleavings that are 
notpossibleinPLCs.Thus,weneedtoconstrainthethreadsinour 
CmodeltomakethemodelingofPLCtasksprecise.Towardthis 
end,the /f_irststep isto constructall threadsforahyper-period.
Hyper-period .PLCtasksinthesameprogrammayhavediﬀerent 
periods. For instance, in our running example, T1 has a period 
of 100ms and T2 has a period of 200ms. In this context, a hyper- 
periodisde/f_inedastheleastcommonmultiplieroftheperiodsof 
all tasks. Thus, the hyper-period of our running example is 200ms.
Clearly, within a hyper-period, T1 will be executed twice and T2 
will be executed once. The reason why we are interested in the 
hyper-periodisbecausetiming-relatedprogrambehaviorsrepeat 
themselvesaftereachhyper-period.Thus,focusingonanalyzing 
the tasks within each hyper-period is important. Furthermore, the 
hyper-periodwillbeusedtoreducethesymbolicexecutioncost.In 
theCmodel,weconstructonethreadforalltheexecutioninstances 
of each task in a hyper-period. That is why in Figure 5, thread1()
invokesProgAtwice, but thread2() invokesProgBonlyonce.
Periodic execution . Next, we construct a for-loop in the main()
functiontoexecuteallthreadsconcurrently.Eachiterationofthe 
for-loopcorrespondstoahyper-period.Thetotalnumberofiter- 
ationsisboundedbyauser-de/f_inedparameterMAX_ITER,since 
PLC programs in general are non-terminating programs. Within 
each hyper-period, we /f_irst create the threads and then set their 
parameters (periodand priority). These parameters will be passed 
tothesymbolicexecutionenginetoavoidexploringinterleavings Symbolic ExecutionofProgrammable Logic ControllerCode ESEC/FSE’17, September4-8, 2017, Paderborn, Germany 
thatarenotallowedbythePLCprogramsemantics.Asshownin 
Figure 5, we use special API functions to signal the boundary of 
thehyper-periodandboundaries oftasks within eachthread.
Assertions .Theassertionattheendofthehyper-periodrepresents 
the property to be checked. In PLC programs, developers may use 
theASSERTION(...)keywordtospecifyaproperty.Suchassertions 
aretranslatedintoassertionsintheCprogramstraightforwardly.
S/y.sc/m.scPLCalso allows its user to specify additional assertions, which 
areinsertedattheendofthehyper-period(e.g.,atLine36inFig- 
ure 5). Assertions are reachability properties because each assert(c) 
may be modeled as if(!c) ERROR , where ERRORis an error location.
During symbolic execution, if any error location is reached, the 
symbolic execution tool produces an error-triggering testcase.
4 SYMBOLICEXECUTION 
In this section, we formally de/f_ine PLC programs and then present 
theoverall symbolicexecution algorithm.
4.1 Multithreaded CModel 
ThemultithreadedCmodelofaPLCprogramconsistsofasetof 
periodic tasks T={T1,...,Tn}. Each task Ti∈T, where 1≤i≤
n, denotes an instance of a PLC program within a hyper-period.
Consider the program named ProgAin Figure 5, which has two 
instancesinahyper-period(Lines18and20).InourCmodel,these 
twoinstances are consideredas diﬀerenttasks in T.
Tasksshareaset GV ofglobalvariables.Each Tialsohasaset 
LV ioflocalvariables.Inaddition,each Timayreadfromaset PI of 
primaryinputs.Thus, Ticanbeviewedasasequentialprogramthat 
reads fromprimary inputs aswell as globalvariables, updates the 
globalvariables,andcomputestheoutputs.Sincetasksareexecuted 
periodically, in addition to being a sequential program, each Tihas
thefollowingattributes:
•Ti.tiddenotes the unique identi/f_ierofthe task;
•Ti.prioritydenotes the prioritylevel ofthe task;
•Ti.period denotes the execution periodof the task within a 
hyper-period;
•Ti.startTdenotes the starttimeofthe task’s period;
•Ti.endTdenotes the endtimeofthe task’speriod.
DuetoPLC’snon-conventionalinterleavingsemantics,foranytwo 
tasksTiandTj, where i/nequalj,
•if Ti.priority<Tj.priority,then Tjmaypreempttheexecu- 
tionof Tiatanytimebetween Ti.startTandTi.endT,but 
Ticannot preempt Tj;
•if Ti.priority=Tj.priority, neither task may preempt the 
othertask.
Thisisdiﬀerentfromthestandardinterleavingsemanticsofamulti- 
threadedprogram,wherethreadswiththesamepriorityareallowed 
topreempteachother.
The execution of task Tileads to a sequence of events t1,...,tk.
Foreaseofpresentation,weassumeeachevent t∈Tiinheritsall
attributes of the task Tiincluding tid,priority,period ,startT, and 
endT. In other words, t.startT andt.endT are the expected start 
time and end time of the period of the task Ti. In addition, we 
introduce t.task todenote the task Tithat generates the event t.
Some events in a PLC program are reads and writes of global 
variables,whileothersarecomputationsoverlocalvariables.Lo- 
caloperationsarefurtherdividedintobranchingstatementse.g.,Algorithm1 Symbolicexecution of a multi-taskPLCprogram.
Initially: Statestack S={};
RunS/y.sc/m.scPLC(s0) where s0is the initial state.
1:S/y.sc/m.scPLC( State s) { 
2:S.push(s);
3:if (sis an interleaving schedule node) 
4: foreach( event tthat is enabledand ¬R/e.sc/d.sc/u.sc/n.sc/d.sc/a.sc/n.sc/t.sc (s,t) ) 
5: s/prime←N/e.sc/x.sc/t.scS/t.sc/a.sc/t.sc/e.sc (s,t);
6: S/y.sc/m.scPLC(s/prime);
7:elseif (sis a sequential computation node) 
8: foreach( event twhosepath conditionissatis/f_iable ) 
9: s/prime←N/e.sc/x.sc/t.scS/t.sc/a.sc/t.sc/e.sc (s,t);
10: S/y.sc/m.scPLC(s/prime);
11:else
12: outputtestcaseif sis the endofan execution 
13:S.pop();
14:}
15:N/e.sc/x.sc/t.scS/t.sc/a.sc/t.sc/e.sc ( State s, Event t) { 
16:s.sel ←t;
17:Computenewsymbolicstate s/primebasedon sandt;
18:return s/prime;
19:}
20:R/e.sc/d.sc/u.sc/n.sc/d.sc/a.sc/n.sc/t.sc ( State s,Event t) { 
21:if (tis redundantaccording tothe theory ofPOR) 
22: return true;
23:return false;
24:}
if (c),andassignments l/v.alt=exp ,where exp maybearithmeticcom- 
putations,bit-stringoperations,booleanoperations,etc.Without 
loss of generality, we assume if (c)involves only local variables,
because if (exp (gv )), where /afii10069.ital/v.alt ∈GV , can always be replaced by 
l/v.alt=/afii10069.ital/v.alt ;if (exp (lv )),where l/v.alt∈LV iisanewlyaddedlocalvariable 
andif (exp (lv ))involvesonlylocalvariables.Thus,duringsymbolic 
execution, we only needtoconsidertwo types of events:
•interleavingschedule events,whichperformcontextswitches 
rightbefore global reads andwrites;
•sequential computation events, which are either if (c)or 
assignmentsoverlocal variables.
Onlyinterleaving schedule events may aﬀect the execution order.
Thus, we will focus on analyzing them to identify redundant inter- 
leavings. In contrast, sequential computation events are handled in 
the sameway asin standardsymbolicexecution tools.
4.2 OverallAlgorithm 
Algorithm 1 shows the overall procedure, which closely follows 
priortechniquesforsymbolicexecutionofmultithreadedprograms[ 6,
19 ,25 ,26 ].Here,Sisastackofsymbolicstates.Eachsymbolicstate 
s∈Sis a tuple /angbracketleftpcon ,M,enabled,sel /angbracketright, where pcon is the path con- 
dition,Mis the symbolic memory, enabledis the set of enabled 
events, and selisthe eventexecutedat s.
Initially,S/y.sc/m.scPLCstarts with the symbolic state s0. Then, de- 
pending on the type of the current state s, it either schedules a 
contextswitchorexecutesasequentialcomputation.Speci/f_ically,
if sis an interleaving schedule node (right before a global read 
orwrite), S/y.sc/m.scPLCisinvokedrecursivelytoexploreeachpossible 
scheduletogetherwiththesubsequentevents(Lines4-6).If sisa 
sequential computation node (local statement within a task), S/y.sc/m.sc/hyphen.sc
PLCis invoked recursively to explore each branch and assignment 
(Lines8-10).Uponreachingtheendofanexecution(Lines11-12),
S/y.sc/m.scPLCgeneratesthecorrespondingtestcaseandbacktracksfrom 
the current state.
Subroutine N/e.sc/x.sc/t.scS/t.sc/a.sc/t.sc/e.sc takesthecurrentstate sandtheevent 
tas input, and returns the newly computed symbolic state s/primeas 
output. For brevity, we omit the details of this symbolic execution ESEC/FSE’17,September4-8, 2017, Paderborn, Germany Shengjian Guo,MengWu,andChao Wang 
Algorithm 2 Deciding if event tchosen at sis redundant.
1:R/e.sc/d.sc/u.sc/n.sc/d.sc/a.sc/n.sc/t.sc ( State s, Event t) { 
2:if (tis redundantaccording tothe DPOR algorithm) 
3: return true;
4://Priority-basedreduction 
5:lett/primebe the lasteventin Sbefore reaching t;
6:if (t/primeis NULL) 
7: if (t.priorityis notthe highestin s.enabled)return true;
8:else
9: if (tis abouttopreempt t/prime)
10: if (t/prime.priority≥t.priority)return true;
11: if (t/prime.startT≥t.startT)return true;
12: //Period-basedreduction 
13: if (t/prime.tid /nequalt.tid )
14: if (t/prime.endT<t.startT)return true;
15: if (t/prime.startT≥t.endT)return true;
16: if (tis the lasteventin t.task)
17: if (∃th,tl∈Sthatth.tid== t.tidandthpreempted tl)
18: if (∃t/prime/prime∈Sthatt/prime/prime.taskinterleaved with t.task)
19: if (t/prime/prime.startT≥tl.endT)return true;
20:return false;
21:}
processsinceitremainsthesameasinstandardsymbolicexecution 
procedures in the literature.
Thechallengeismitigatingthecombinatorialblowupassociated 
with the event interleavings (Lines 4-6) because, in the worst case,
the number of interleavings is exponential in the number of global 
operations.Traditionaltechniquesformitigatingtheinterleaving 
explosion are based on partial order reduction (POR) [23 ,30 ,33 ,46 ,
49 ], which is to group interleavings into equivalence classes and 
thenpickarepresentativeinterleavingfromeachequivalenceclass 
while skipping the other (redundant) interleavings. In Algorithm 1,
this is implemented inside Subroutine R/e.sc/d.sc/u.sc/n.sc/d.sc/a.sc/n.sc/t.sc . However, POR 
doesnotconsidertheadditionalinterleavingconstraintsimposedby 
PLC tasks. As such, it is not eﬀective in mitigating the interleaving 
explosion problemin PLCprograms.
5 OUR PLC-SPECIFICREDUCTIONS 
Inthissection,wepresentthreenewreductiontechniquesdesigned 
totakeadvantageoftheuniquecharacteristicsofPLCprograms.
Speci/f_ically, they are related to leveraging information from (1) the 
priorities of tasks, (2) periods of tasks, and (3) previously visited 
programstates during symbolicexecution.
Algorithm 2showsourimplementation ofthe /f_irsttworeduc- 
tions.ThethirdreductionwillbepresentedinSection5.3.Here,the 
subroutine R/e.sc/d.sc/u.sc/n.sc/d.sc/a.sc/n.sc/t.sc returns trueif executing tfrom the state s
isredundant,whetheritisduetoDPORorinfeasibilityaccording 
tothePLCinterleavingsemantics.Withinthecurrenthyper-period,
wede/f_ine t/primetobethelasteventchosenbeforereaching s(Line5).
In thesubsequenttwosections, we illustratehowthese twotypes 
ofreductions make use of t/primein more details.
5.1 Priority-based Reduction 
In this new reduction, we impose three rules which directly follow 
theway PLCsschedule theirtasks:
(1)Theactivetaskwiththehighestprioritymustbescheduled 
tobeforeotheractivetaskswheneverahyper-periodstarts.
(2)Arunningtaskcanonlybepreemptedbyanotherrunning 
taskwith a strictly higherpriority;
(3)Ifahigh-prioritytaskstartsbeforetheperiodbeginningof 
alow-prioritytask,theremustbenointerleavingsbetween 
these twotasks.1RESOURCE CPU_main ON CPU001
2 TASKT1 ( INTERVAL := t#200ms, PRIORITY := 1); //High
3 TASKT2 ( INTERVAL := t#200ms, PRIORITY := 2); //Low
4 PROGRAM FastWITHT1 : ProgA; 
5 PROGRAM SlowWITHT2 : ProgB; 
6END_RESOURCE
Figure 6:Thecontrol/f_lowgraph of themodi/f_ied program.
WeencodetheserulesintoLines5-11ofAlgorithm2.First,when 
bothhigh-prioritytaskandlow-prioritytaskareenabledandready 
to run, the PLC should always run the high-priority task /f_irst. This 
corresponds to the conditions at Lines 5-6: if t/primedoes not exist,
it means tis the /f_irst event in the current hyper-period. At this 
moment, the PLC must choose the highest-priority task to execute.
Thus, if tis not the highest-priority task, R/e.sc/d.sc/u.sc/n.sc/d.sc/a.sc/n.sc/t.sc returns true.
Ontheotherhand,if t/primeexistsand tisabouttopreempt t/prime,we 
/f_irstleveragethetaskprioritiestoperformareduction,andthen 
leverage both the priorities and the periods to perform another 
reduction. Speci/f_ically, we checktwo the following conditions.
The /f_irst condition at Line 10 ensures that thas a strictly higher 
priority than t/prime, because PLCs only allow high-priority tasks to 
preemptlow-prioritytasksbutnotviceversa.Andtaskswiththe 
samepriorityarenotallowedtopreempteachother.Thesecond 
condition at Line 11 makes use of periods of the tasks. Note that 
at this point, we know t’s priority is higher than that of t/prime. The 
condition checks if the (expected) start time of the period of tis 
before the (expected) start time of the period of t/prime. If this is the 
case,theinterleavingisinfeasiblebecausethelow-priorityevent t/prime
should not have occurred before t(it should only be executed after 
the end of t’s period).
Consider the PLC program in Figure 3 again as an example,
but with an important modi/f_ication—setting the INTERVAL of T1 to 
t#200msinstead of t#100ms. Sincebothtasksnowneed t#200ms,
the hyper-period becomes 200ms, meaning ProgAandProgBare 
invoked once each in the new threads thread1andthread2, re- 
spectively.Thecontrol/f_lowof thesetwonewthreadsareshownin 
Figure 6, where nodes are the global reads or writes and solid lines 
are the control /f_lows. Recall that the primary input Sensor_input
is modeled as a symbolic variable, thus allowing both branches 
immediately after the node 1to be taken. In contrast, the branches 
immediatelyafterthenode 4dependonlyonthevalueoftheglobal 
variableObstacle .Symbolic ExecutionofProgrammable Logic ControllerCode ESEC/FSE’17, September4-8, 2017, Paderborn, Germany 
Table1:Interleavingsexploredbypriority-basedreduction.
ID All-Interleavings DPOR SymPLC ID All-Interleavings DPOR SymPLC 
11-4-5 yes yes 74-5-1 yes 
21-2-3-4 yes yes 84-1-5
31-2-4-3 94-1-2-5-3 yes 
4* 1-4-2-3-5 yes 10* 4-1-2-3-5 yes 
51-4-2-5-3 yes 11 4-1-5-2-3
61-4-5-2-3 yes 12 4-5-1-2-3 yes 
If it were a standard multithreaded program, each thread would 
beallowedtopreempttheotheroneatthecontrol/f_lownodes,thus 
leadingtoatotalof12interleavings,asshowninthesecondand/f_ifth 
columnsofTable1,labeled All-Interleavings .Amongthem,thetwo 
interleavingsmarkedwith*wouldviolatetheassertion.Afterapply- 
ingthe DPOR algorithm,for example, eightinterleavings would re- 
mainwhiletheotherfourwouldberemoved.Speci/f_ically, 1-2-4-3
isremovedbecauseitisequivalentto 1-2-3-4;1-4-5-2-3 isequiv- 
alent to 1-4-2-5-3 ;4-1-5is equivalent to 4-5-1; and 4-1-5-2-3
is equivalentto 4-5-1-2-3 .
However,applyingournewpriority-basedreductionwouldlead 
to signi/f_icantly fewer interleavings. In fact, only two interleavings 
would remain, which are shown by the red and blue dotted lines 
in Figure 6. This is because, according to our second rule, all six 
interleavingsinColumn2except 1-4-5and1-2-3-4areinfeasi- 
ble,becausethelow-prioritytask( T2 )preemptsthehigh-priority 
task. Similarly, according to our /f_irst rule, all six interleavings in 
Column6areinfeasible,becausewhenboth T1 andT2 areactive 
andready to run atthe beginning, the PLCs wouldalways choose 
toexecute the high-prioritytask( T1 ).
Since the erroneous interleavings (4 and 10) are not explored by 
S/y.sc/m.scPLC,and S/y.sc/m.scPLCterminatesaftertwohyper-periods(dueto 
the termination condition to be presented in Section 5.3), we have 
provedthe validityofthis assertion condition.
Our implementation uses an on-the-/f_ly computation to decide 
whetherthecurrentinterleavingisfeasible.Takethesecondruleas 
an example. Whenever an instruction accessing global variables is 
interpretedinthesymbolicexecutionengine,wecheckthepriority 
ofitstaskagainsttheoperationhistoryofcurrentexecution.Ifa 
preceding operation is from an active task whose priority is higher 
thanthecurrentone,thentheinterleavingresultedfromexecuting 
tat sshould be skipped. The /f_irstand the third rule are developed 
in a similarfashion.
In Figure 6, for instance, 4-5-1is determined to be infeasible 
immediately after the /f_irst node 4is reached by S/y.sc/m.scPLC, since the 
/f_irst rule is violated. Therefore, S/y.sc/m.scPLCbacktracks from node 4
while skippingthe interleavings numbered8-12entirely.
5.2 Period-based Reduction 
In this new reduction, we develop two rules over task interleaving:
(1)Two tasks are allowed to interleave only when their ex- 
pectedexecution periods overlapin time;
(2)Ifahigh-prioritytask Thpreemptsalow-prioritytask Tl,
Thmustnotinterleavewithanytaskwhoseperiodbegin 
timeis notearlierthan the periodendtime of Tl.
We implement these rules at Lines 13-19 of Algorithm 2. Recall 
thatt.startTandt.endTare the expected logical time when the 
periodof tbeginsandends(wearenotconcernedwiththeactual 
starttimeandendtimeof t,exceptthattheymustfallwithinthe 
period). Without these rules, any two operations from diﬀerent 1CONFIGURATION PLC_Cell1
2RESOURCE CPU_main ON CPU001
3 TASKT1 ( INTERVAL := t#100ms, PRIORITY := 1); //H-priority
4 TASKT2 ( INTERVAL := t#200ms, PRIORITY := 2); //M-priority
5 TASKT2 ( INTERVAL := t#300ms, PRIORITY := 3); //L-priority
6 PROGRAM FastWITHT1 : ProgA; 
7 PROGRAM ConstWITHT2 : ProgB; 
8 PROGRAM SlowWITHT2 : ProgC; 
9END_RESOURCE
10 END_CONFIGURATION
B2 B1
C1 C2B3
0                100             200             30 0             400              500             600 ms       /g100/g258/g400/g364/g3/g100 /g1006
/g100/g258/g400/g364/g3/g100 /g1007/g44/g455/g393/g286/g396/g3/g87/g286/g396/g349/g381/g282 
A3 A1 A6 /g100/g258/g400/g364/g3/g100 /g1005 A2 A4 A5
Figure7:Threeperiodictaskswithahyper-periodof600ms.
threads would have been allowed to execute concurrently in the 
same hyper-period. However, since each task must meet its own 
deadline, some of themcan neverrun concurrently.
Consider the program in Figure 7 as our example, which has 
threetasks T1 ,T2 andT3 withperiods100ms,200msand300ms,re- 
spectively.Thus,thehyper-periodis600ms,allowing T1 toexecute 
six times, T2 to execute three times, and T3 to execute twice. For 
easeofpresentation,letthesixinstancesof T1 bedenotedfrom A1
to A6, the three instancesof T2 be denotedfrom B1to B3, andthe 
twoinstances of T3 be denoted C1andC2.
Without the timing-related information, symbolic execution 
would have to explore all possible interleavings of these tasks,
including the obviously infeasible ones between A1andB2, for ex- 
ample,whichdonotoverlapintime.Theseinfeasibleinterleavings 
will be removedby applyingourreduction rules.
We/f_irstcomparethetaskIDsof t/primeandtinAlgorithm2–diﬀerent 
IDsmeanstheybelongtodiﬀerenttasks.ThenextruleatLine14 
is straightforward, since interleaving cannot occur if the two tasks 
do not overlap in time. In our running example, the period of A1is 
[0ms, 100ms] while the period of B2is [200ms, 400ms]. Obviously,
eventsin A1donotoccurconcurrentlywitheventsin B2.Similarly,
the periods of B3andC1do not overlap. Both of these two cases 
are handledby the conditions atLines 14-15ofAlgorithm2.
The second rule (Lines 16-19) is more subtle because the infeasi- 
bleinterleavingsarededucedviaaprecedinginterleaving,basedon 
both periods and priorities of involved tasks. As shown in Figure 7,
theperiod B2isexpectedtostartbefore A4.Thus,itappearsthat A4
may interleave with B2. However, if B2preempts C1in a particular 
execution, then B2must endbefore the endofthe periodof C1, to 
allowC1tomeetitsdeadline.Since B2wouldhaveendedbeforethe 
start of the period of A4, it cannot run concurrently with A4. Thus,
in this particularexample, A4andB2can no longerinterleave.
This example also illustrates the third reduction rule in Sec- 
tion 5.1:A3starts from the 200ms, while the earliest time B2can
startis200ms.Since T1 hasahigherpriority, and A3startsearlier
thanB2,theexecutionof A3cannotbeinterruptedby B2.Thus,any 
interleavingbetween themisguaranteedto be infeasible.ESEC/FSE’17,September4-8, 2017, Paderborn, Germany Shengjian Guo,MengWu,andChao Wang 
Algorithm 3 Nextstate computation withstateful reduction.
1:N/e.sc/x.sc/t.scS/t.sc/a.sc/t.sc/e.sc ( State s, Event t) { 
2:s.sel ←t;
3:Compute thenewsymbolicstate s/primebasedon sandt;
4:if (tis plc_hyperperiod_end) 
5: if (s/prime⊆visited)return NULL;
6: elsevisited←visited∪{s/prime};
7:return s/prime;
8:}
5.3 StatefulExploration
Now we present the state-based reduction. Recall PLC tasks are 
periodicandthusneverterminate.Furthermore,symbolicexecution 
bydefaultisgearedtowarddetectingbugsasopposedtoproving 
the correctness of properties. Thus, applying S/y.sc/m.scPLCwith a user- 
speci/f_ieddepthboundingeneralwillneverprovetheabsenceof 
bugs in a PLC program. However, information of already-visited 
statesmaybeleveragedtodetectearly-terminationconditions.This 
allows S/y.sc/m.scPLCto drastically reduce the number of test cases, as 
well as prove the correctness ofproperties.
Algorithm3showsthemodi/f_ied N/e.sc/x.sc/t.scS/t.sc/a.sc/t.sc/e.sc subroutineinAl- 
gorithm 1 that implements this method. At the end of each hyper- 
period,itchecksifthenewsymbolicstate s/primehasbeenvisitedpre- 
viously. If the answer is yes, it returns NULL instead of s/primewhich
forcesS/y.sc/m.scPLCtobacktrackimmediately.
Ingeneral,thestateofaPLCprogramisavaluationofallvari- 
ables as well as program counters (PC) of all tasks. However, since 
weareconcernedwiththeprogramstateonlyattheendofahyper- 
period(wherealltaskshaveendedandlocalvariablesareoutofthe 
scope),onlythevaluationofglobalvariablesneedstobeconsidered.
LetRbethesetofallreachablestatesofaPLCprogramattheend 
of the hyper-period. Ideally, S/y.sc/m.scPLCshould generate enough test 
cases to cover all states in R. We will show through experiments 
that, due to the nature of these PLC programs, the termination 
conditioncanoftenbemetafterafewhyper-periods.Italsomeans 
S/y.sc/m.scPLCshouldbedesignedtoterminateassoonasthesymbolic 
executionprocedurestopsgeneratingpreviouslyunexploredstates.
Consider a program named IndustrialAuto 4from [ 18 ], which 
containsa state machine whose state variable, CSTATE6, may take 
a number of values. A brute-force application of S/y.sc/m.scPLCwould 
resultinexponentiallymanyprogrampathsasthenumberofhyper- 
periodsincreases.Forexample,after/f_ivehyper-periods,thenumber 
of executions becomes 3176. In contrast, applying our new stateful 
reduction decreases the total number of executions down to 45.
Furthermore,sincethesymbolicexecutionproceduredetectsthe 
early-termination condition after 3 hyper-periods, all unfalsi/f_ied 
properties are consideredto be formally proved.
6 EXPERIMENTS 
We have implemented S/y.sc/m.scPLC based on the MatiecPLC com-
piler[39 ]andthe Cloud9symbolicvirtualmachine[ 19 ].Weused 
MatiectotranslateSTcodeofeachPLCtasktoANSIC,andthencre- 
ated a test harness to incorporate these tasks. We implemented the 
testharness generatorusing Python.The resultingmultithreaded 
C model was then executed by the extended Cloud9, which uses 
KLEE [12 ] internally for symbolic execution. We extended Cloud9
tohandle the PLC-speci/f_icprogramfeatures.
Our experiments answer the following research questions: (1) 
CanS/y.sc/m.scPLCeﬃcientlyhandlebothsingle-taskandmulti-taskPLC 
programs?Is S/y.sc/m.scPLCeﬀectivein detectingpropertyviolationsas wellasprovingtheircorrectness?(2)ArethePLC-speci/f_icreduction 
techniques(stateful,period,andpriority) eﬀectiveinreducingthe 
searchspace?Dotheyoutperformstate-of-the-artPORtechniques? 
For comparison purposes, we implemented the state-of-the-art 
dynamicpartial-orderreduction(DPOR)algorithm[ 23 ,33 ,49 ]in 
S/y.sc/m.scPLCtoidentify andremove redundantinterleavings.
We evaluated S/y.sc/m.scPLCon two sets of benchmark programs. The 
/f_irst set consists of 49 single-task PLC programs collected from 
various online sources [ 16 ,18 ,29 ]. The second set consists of 44 
multi-task PLC programs that implement several embedded con- 
trollers[ 14 ,15 ].EachPLCprogramhas30to3,418linesofSTcode,
which translate to 90 to 8,783 lines of C code. In total, they consist 
of 26,713 lines of ST code, which translate to 62,926 lines of C code.
The C code is /f_irst compiled to LLVM bitcode and then symboli- 
cally executed by the modi/f_ied Cloud9. Correctness properties are 
expressedasassertionsembedded intheprograms.Weconducted 
all our experiments on a computer with a 3.40 GHz CPU and 8 GB 
RAMrunning Ubuntu 12.04Linux.
6.1 Results onSingle-task PLCApplications 
Table2showstheexperimentalresultsonsingle-taskPLCprograms.
Sinceeachhyper-periodhasonetask,thenumberofiterationsis 
thesameasthenumberoftasksexecuted.Inthistable,Columns1– 
3 show the statistics of each benchmark program, including the 
name,thenumberoflinesoforiginalST code,andthenumberof 
linesofgeneratedCcode.Columns4-8showthedetailedresults 
of S/y.sc/m.scPLC,includingthemaximumnumberofiterationsreached 
(#.Iter), whether stateful reduction detected convergence (Conv),
thenumberoftests generated,execution timein seconds,andthe 
instruction coverage (#.ICov). The last three columns show the 
assertion checking results, including the number of undecided,
falsi/f_ied, andprovedassertions.
If S/y.sc/m.scPLC/f_indsanexecutionthatfailsanassertion,theasser- 
tion is falsi/f_ied. If S/y.sc/m.scPLCdoes not /f_ind such an execution before 
reaching early termination, the assertion is proved. Otherwise, the 
assertion remainsundecided.
Althoughsymbolicexecution isgearedtowardfalsifyingasser- 
tions,Table2showsthatourstatefulreductionisalsoeﬀectivein 
detectingterminationconditions.Asaresult, S/y.sc/m.scPLCcanprove154 
assertions(inadditiontofalsifying34assertions)andthereareonly 
18 undecided assertions. In contrast, without stateful reduction,
there wouldbe 172undecidedassertions.
Furthermore, the number of iterations ranges from 2 to 14, in- 
dicating that repeatedly executing the same PLC tasks after that 
many hyper-periods does not lead to new program states. Instead,
the main diﬃculty resides in covering the input space, which is 
whatsymbolic execution is designedfor.
The average Instruction Coverage for all benchmarks is 89.7%,
which did not reach 100% even for benchmarks that converged,
apparently because some of these instructionsare unreachable.
6.2 Results onMulti-task PLCApplications 
In this section, we show the performance diﬀerences between non- 
stateful and stateful exploration inside S/y.sc/m.scPLC, and then compare 
the various interleavingreduction techniques.
Table3showstheresultsonmulti-taskPLCprograms.Columns1- 
3 show the benchmark name and statistics of the hyper-period,
including the total number of tasks and global operations executed Symbolic ExecutionofProgrammable Logic ControllerCode ESEC/FSE’17, September4-8, 2017, Paderborn, Germany 
Table2:Results of S/y.sc/m.scPLC onsingle-task PLCprograms.
Program LOC#.Iter Conv #.Tests Time (s) #.ICov(%) Assertions 
ST C Undet. Falsi/f_ied Proved 
G4LTL_ST1 470 1,249 5 Y 305 36.2 89.1 0 0 1 
G4LTL_ST2 188 504 5 Y 316 13.2 87.5 0 0 1 
G4LTL_ST3 111 252 6 Y 116 4.9 87.3 0 0 2 
G4LTL_ST4 1,409 4,279 7 Y 1,498 140.2 44.5 0 1 1 
G4LTL_ST5 321 855 5 Y 240 9.6 97.8 0 0 2 
G4LTL_ST6 69 154 2 Y 67 2.5 98.5 0 2 1 
G4LTL_ST7 86 156 2 Y 272 1231.9 78.2 0 0 1 
G4LTL_ST8 488 1,661 8 Y 368 16.3 74.4 0 0 5 
G4LTL_ST9 577 914 10 Y 686 69.7 92.6 0 1 1 
G4LTL_ST10 257 435 6 Y 354 27.8 99.8 0 1 2 
IndustrialAuto1 45 145 2 Y 12 0.6 95.1 0 0 2 
IndustrialAuto2 43 150 2 Y 10 0.5 95.5 0 2 2 
IndustrialAuto3 206 379 4 Y 289 10.6 99.7 0 1 3 
IndustrialAuto4 65 172 3 Y 45 1.7 98.9 0 0 3 
IndustrialAuto5 105 273 3 Y 65 2.1 98.8 0 1 7 
IndustrialAuto6 126 276 6 Y 25 1.0 84.1 0 0 9 
IndustrialAuto7 126 275 5 Y 34 1.3 92.4 0 0 8 
IndustrialAuto8 199 485 13 Y 55 3.1 60.0 0 0 11 
IndustrialAuto9 2,444 8,291 14 Y 143 8.8 11.7 0 2 9 
IndustrialAuto10 1,195 3,266 12 No 5,084 >3600 34.3 15 1 0 
IndustrialAuto11 75 218 3 Y 23 0.9 97.8 0 0 8 
IndustrialAuto12 1,580 3,781 6 Y 3,216 813.1 99.9 0 0 14 
IndustrialAuto13 255 607 8 Y 130 4.9 61.5 0 1 6 
IndustrialAuto15 3,418 8,783 8 Y 1,349 151.8 65.7 0 1 11 
IEC-1 30 90 2 Y 6 0.4 83.2 0 0 1 
IEC-2 53 135 2 Y 619 25.6 97.9 0 1 1 
IEC-3 118 260 2 No 8,041 >3600 98.4 2 2 0 
IEC-4 66 173 6 Y 216 9.1 92.5 0 0 3 
IEC-5 32 72 2 Y 6 0.3 88.2 0 0 2 
IEC-6 52 140 2 Y 306 9.9 98.0 0 0 1 
IEC-7 173 474 3 Y 37 2.5 85.1 0 1 1 
LD-Program1 89 136 3 Y 1,084 64.5 79.1 0 0 4 
LD-Program2 336 403 2 No 10,508 >3600 67.0 1 0 0 
LD-Program3 92 135 11 Y 231 10.3 99.6 0 1 1 
LD-Program4 110 150 2 Y 601 29.9 74.9 0 1 2 
Mixer 181 251 4 No 5,088 >3600 88.6 0 2 0 
Evaporator 178 238 2 Y 287 11.9 81.7 0 1 3 
Hydraulic 118 128 2 Y 54 2.4 83.0 0 0 4 
Safe 215 313 2 Y 1,724 199.5 92.0 0 0 2 
Logic 234 322 2 Y 125 6.2 78.9 0 1 8 
Lift 187 169 2 Y 160 8.1 71.6 0 0 2 
Plastic 187 215 2 Y 360 22.6 75.1 0 0 2 
Bargraph 126 143 4 Y 4,316 429.6 98.0 0 0 2 
Jedyka 80 92 7 Y 132 4.5 99.5 0 2 0 
Glowny 70 86 4 Y 62 2.1 93.5 0 2 1 
IL-Tool 137 171 2 Y 362 20.4 99.2 0 1 2 
Shutter 83 125 4 Y 643 49.6 94.3 0 3 0 
Alarm 68 107 4 Y 326 22.4 99.5 0 1 1 
Fountain 50 95 9 Y 339 28.7 99.6 0 1 1 
Total 16,923 42,183 50,335 17,913 18 34 154 
in eachhyper-period, becausethey areclosely relatedtothe com- 
plexityoftheinterleavingexploration.Columns4-9showresults 
of S/y.sc/m.scPLCwithout stateful reduction, including the maximum 
numberofiterationsreached,thenumberoftestcasesgenerated,
the run time, and the assertion checking results. Columns 10-15 
show resultsof S/y.sc/m.scPLCwithstateful reduction. We set the time 
boundto10minutes andhyper-perioditeration boundto10.
Sincenon-stateful S/y.sc/m.scPLCcannotdetectconvergence,itdoes 
not prove properties. In contrast, stateful S/y.sc/m.scPLCcan prove prop- 
erties. Our results show that stateful S/y.sc/m.scPLConly needed a few 
hyper-periods to detect convergence. In contrast, non-stateful S/y.sc/m.sc/hyphen.sc
PLCfrequently timed out or generated more test cases (1.4 million 
versus 11K). Both detected 17 violations, but stateful S/y.sc/m.scPLCalso
proved27assertions, whereas non-stateful S/y.sc/m.scPLCdidnot.
Table 4 shows the result of comparing diﬀerent interleaving 
reduction techniques. Here, KLEE denotes the default symbolic 
execution algorithm in Cloud9augmented with the capability of 
handling threads. DPOR denotes the enhanced version of KLEE Table 3:Results of S/y.sc/m.scPLC on multi-task PLCprograms.
Program Hyper-period Non-Stateful Stateful
#.Task #.Ops #.Iter #.Test #.Time Assertions #.Iter #.Test #.Time Assertions 
Und Fal Pro Und Fal Pro 
nxt2.prog1 3 16 10 10 0.2 1 0 0 3 3 0.4 0 0 1 
nxt2.prog2 3 16 10 1027 2.8 0 1 0 2 7 0.4 0 1 0 
nxt2.prog3 5 27 10 59048 372.2 1 0 0 2 5 0.4 0 0 1 
nxt2.prog4 7 37 10 59767 >600 1 0 0 2 5 0.4 0 0 1 
nxt2.prog5 5 28 4 109,669 >600 0 1 0 2 43 0.7 0 1 0 
nxt2.prog6 7 38 4 71,631 >600 0 1 0 2 43 0.8 0 1 0 
nxt2.prog7 7 38 3 66,907 >600 1 0 0 2 91 1.4 0 0 1 
nxt3.prog1 5 15 5 43,313 >600 1 0 0 3 24 0.6 0 0 1 
nxt3.prog2 7 19 4 57,396 >600 0 1 0 2 93 1.2 0 1 0 
nxt3.prog3 8 28 4 15,080 >600 1 0 0 2 20 0.8 0 0 1 
nxtway01 6 42 5 41,629 >600 1 0 0 2 25 0.6 0 0 1 
nxtway02 6 46 3 35,449 >600 0 1 0 3 149 2.4 0 1 0 
nxtway03 9 62 3 33,809 >600 0 1 0 3 978 16.2 0 1 0 
nxtway04 9 66 4 26,988 >600 0 1 0 2 575 10.4 0 1 0 
nxtway05 6 38 9 11122 >600 1 0 0 3 11 0.6 0 0 1 
nxtway06 6 34 4 46,580 >600 0 1 0 3 860 12.1 0 1 0 
nxt.pi00 6 46 5 21,808 >600 0 1 0 2 55 1.2 0 1 0 
nxt.pi01 6 46 4 23,348 >600 1 0 0 2 98 1.7 0 0 1 
nxt.pi02 8 62 3 21,139 >600 0 1 0 2 368 6.5 0 1 0 
nxt.pi03 5 38 4 25,406 >600 0 1 0 3 179 2.9 0 1 0 
trans01 6 41 3 26,367 >600 0 1 0 3 502 7.9 0 1 0 
trans02 6 41 6 498 >600 1 0 0 4 27 0.9 0 0 1 
trans03 6 39 4 33,572 >600 0 1 0 5 2,638 38.7 0 1 0 
trans04 6 41 4 29,326 >600 1 0 0 3 73 1.4 0 0 1 
trans05 9 59 5 11582 >600 1 0 0 3 19 0.8 0 0 1 
attend01 6 35 5 34,658 >600 1 0 0 4 64 1.2 0 0 1 
attend02 6 42 3 32,932 >600 0 1 0 3 388 5.9 0 1 0 
attend03 6 48 4 20,723 >600 1 0 0 2 119 2.3 0 0 1 
attend04 6 39 4 23,537 >600 1 0 0 3 101 1.9 0 0 1 
att4_01 7 40 3 23,655 >600 1 0 0 3 855 14.5 0 0 1 
att4_02 7 33 4 32,505 >600 1 0 0 3 105 1.9 0 0 1 
race01 6 47 3 21,990 >600 0 1 0 2 166 2.6 0 1 0 
race02 6 38 5 17,730 >600 0 1 0 3 41 0.9 0 1 0 
race03 9 63 3 14,960 >600 1 0 0 2 275 6.7 0 0 1 
nobadmode01 6 34 4 22,915 >600 1 0 0 3 88 1.5 0 0 1 
nobadmode02 7 45 4 10,840 >600 1 0 0 3 86 2.3 0 0 1 
nobadmode03 6 52 3 14,051 >600 1 0 0 3 614 13.1 0 0 1 
nobadmode04 6 51 5 12,666 >600 1 0 0 3 102 2.2 0 0 1 
ctm01 7 123 7 47067 >600 1 0 0 9 131 2.2 0 0 1 
ctm02 7 120 5 82,330 >600 1 0 0 4 178 2.5 0 0 1 
ctm03 6 115 9 72,135 >600 1 0 0 5 82 1.2 0 0 1 
aso_01 11 67 2 20,269 >600 1 0 0 2 438 12.4 0 0 1 
aso_02 9 49 2 19,204 >600 1 0 0 2 90 2.9 0 0 1 
aso_03 9 53 3 26,610 >600 0 1 0 2 452 9.4 0 1 0 
Total 1,423,248 24,975 27 17 0 11,266 199 0 17 27 
whereweaddedtheimplementationofdynamicpartialorderre- 
duction. Among the three PLC-speci/f_ic reductions, Perioddenotes
ourperiod-basedreductiontechnique, Prioritydenotesourpriority-
based reduction technique, and Period+Priority denotes the full-
blown implementation ofour reduction in S/y.sc/m.scPLC. All methods 
shown in Table 4 were used in conjunction with the stateful re- 
duction.Foreachindividualmethod,weshowthenumberoftest 
cases generated and the total execution time in seconds. Since the 
timelimitwassetto10minutes, >600smeansthecorresponding
methodwas forced toterminate afterrunning outoftime.
As shown in the total numbers in the last row, the full-blown 
reductionimplementedin S/y.sc/m.scPLC,denoted (Period+Priority) ,sig- 
ni/f_icantlyoutperformedKLEEandDPOR,twostate-of-the-artsym- 
bolicexecutiontechniques.Speci/f_ically,thereductioninthenumber 
oftestcasesismorethantwoordersofmagnitude.Furthermore,
the full-blown reduction is signi/f_icantly more eﬃcient than Pe-
riod-based reduction (11,266 versus 1,433,944) or Priority-based
reduction (11,266 versus267,352) alone. Thismeans applying both 
PeriodandPrioritybasedreductionshas ledtosynergisticimpact.ESEC/FSE’17,September4-8, 2017, Paderborn, Germany Shengjian Guo,MengWu,andChao Wang 
Table4:Results of comparingthereductiontechniques.
Program KLEE [12] DPOR [23] PLC-speci/f_icReductions 
Period Priority Period+Priority 
#. Test Time (s) #. Test Time (s) #.Test Time (s) #.Test Time (s) #. Test Time (s) 
nxt2.prog1 43,960>600 135 1.6 135 1.6 3 0.4 3 0.4 
nxt2.prog2 44,200>600 19 0.5 19 0.5 7 0.4 7 0.4 
nxt2.prog3 44,595>600 5,644 62.2 3,839 39.5 24 0.6 5 0.4 
nxt2.prog4 45,683>600 47,652>600 35,531 452.3 40 0.7 5 0.4 
nxt2.prog5 50,067>600 52,666>600 47,422>600 144 1.5 43 0.7 
nxt2.prog6 44,442>600 46,521>600 45,867>600 528 5.1 43 0.8 
nxt2.prog7 44,383>600 46,280>600 45,394>600 827 9.8 91 1.4 
nxt3.prog1 47,159>600 48,111>600 44,560>600 250 3.3 24 0.6 
nxt3.prog2 52,490>600 54,248>600 41,011>600 5,792 59.9 93 1.2 
nxt3.prog3 45,842>600 54,851>600 25,527>600 3,117 37.8 20 0.8 
nxtway01 53,425>600 43,799>600 41,003>600 195 2.7 25 0.6 
nxtway02 51,317>600 45,304>600 45,633>600 1,646 22.2 149 2.4
nxtway03 51,609>600 35,932>600 39,562>600 35,445>600 978 16.2
nxtway04 60,785>600 45,557>600 38,916>600 31,045>600 575 10.4
nxtway05 51,589>600 38,140>600 39,562>600 713 10.1 11 0.6 
nxtway06 46,392>600 50,025>600 45,756>600 4,608 68.6 860 12.1
nxt.pi00 49,470>600 39,158>600 40,716>600 561 8.2 55 1.2 
nxt.pi01 49,978>600 40,446>600 39,212>600 1,226 16.9 98 1.7 
nxt.pi02 48,670>600 28,824>600 29,922>600 10,216 169.9 368 6.5
nxt.pi03 43,048>600 40,384>600 39,884>600 239 3.7 179 2.9
trans01 40,869>600 42,269>600 40,684>600 5,170 78.9 502 7.9
trans02 40,893>600 38,720>600 39,364>600 99 2.1 27 0.9 
trans03 36,714>600 43,546>600 43,602>600 11,112 168.6 2,638 38.7
trans04 38,568>600 35,123>600 25,535>600 357 5.3 73 1.4 
trans05 49,880>600 46,138>600 35,480>600 4,207 69.3 19 0.8 
attend01 43,298>600 54,320>600 57,849>600 222 3.1 64 1.2 
attend02 32,541>600 56,541>600 18,866>600 20,292 12.8 388 5.9
attend03 46,143>600 35,023>600 35,585>600 343 5.1 119 2.3
attend04 45,951>600 36,224>600 32,570>600 432 6.5 101 1.9
att4_01 47,312>600 40,691>600 36,861>600 2,391 37.2 855 14.5
att4_02 46,969>600 34,278>600 40,327>600 364 5.5 105 1.9
race01 45,610>600 38,334>600 37,424>600 500 7.2 166 2.6
race02 45,277>600 17,756 231.9 2,236 32.2 176 3.9 41 0.9 
race03 44,974>600 22,145>600 32,658>600 28,112>600 275 6.7
nobadmode01 49,094>600 46,622>600 40,932>600 314 4.6 88 1.5 
nobadmode02 43,561>600 51,877>600 6,616 144.6 16,862 346.7 86 2.3 
nobadmode03 43,525>600 49,719>600 48,408>600 2,745 49.9 614 13.1
nobadmode04 43,962>600 42,283>600 37,739>600 2,558 46.5 102 2.2
ctm01 51,345>600 51,810>600 776 11.4 846 10.9 131 2.2
ctm02 55,711>600 63,599>600 54,294>600 621 7.8 178 2.5
ctm03 49,343>600 51,875>600 41,839>600 97 1.3 82 1.2 
aso_01 42,260>600 39,386>600 10,582>600 20,607>600 438 12.4
aso_02 44,403>600 43,847>600 12,461>600 29,191>600 90 2.9 
aso_03 44,235>600 40,646>600 11,785>600 23,108>600 452 9.4
Total 2,041,542 26,400 1,786,468 24,296 1,433,944 22,822 267,352 4,895 11,266 199
7 RELATEDWORK 
Since PLCs are widely used in industry control applications, there 
existsomeintegrateddevelopmentenvironments(IDEs)andsimula- 
tors for PLCs. However, they are designed primarily for mimicking 
the behaviorofPLCdevices on hostcomputers. Althoughsimula- 
torsmaybeusedtotestaPLCprogram,theusermusthandcraftthe 
testinputs.Aswementionedearlier,manuallycreatinghigh-quality 
test inputs is diﬃcult. Furthermore, even with the test inputs, itis 
stillnecessarytoexplorethepossibletaskschedulesunderthese 
inputs. Unfortunately, simulators are not equipped to perform this 
task.S/y.sc/m.scPLC/f_illsthegapbyleveragingsymbolicexecutiontoauto- 
maticallygeneratehigh-qualitytestinputs,aswellassystematically 
coverthe possible interleavings.
There is also a large body of work on formal veri/f_ication of PLC 
applications[ 2,5,7–9,40 ,42 ,43 ].Inthiscontext,aformalmodel 
of the target PLC has to be constructed before it is analyzed by 
veri/f_icationtoolssuchasUPPAL[ 41 ]andNuSMV[ 1,5].Various 
optimizationsare alsoproposedtoincreasethe eﬃciencyofthese 
veri/f_ication tools [ 27 ,43 ,47 ,48 ]. However, there are several funda- 
mentaldiﬀerences between these model checkers and S/y.sc/m.scPLC.
First, constructing and tuning formal models are not easy. They 
requireexpertiseinformalmethodsandtheapplicationdomains,
thus limiting the practical use. Second, formal models are at higher abstractionlevelsthantheactualcode;thus,theyaremoresuitable 
for checking designdefects[ 20 ,36 ,43 ] than implementation bugs.
Finally,noneoftheexistingtoolshandlesmulti-taskPLCprograms;
indeed, they focus exclusively on single-task programs, perhaps to 
avoid the diﬃculty in modeling the concurrencysemantics.
In contrast, S/y.sc/m.scPLCrequires no formal model; instead, it relies 
on symbolic execution to directly checking the PLC software code.
S/y.sc/m.scPLCalso uniformly models both single-task and multi-task 
PLC programs. While symbolic execution has been routinely used 
fortestingsequentialandconcurrentprogramswritteninawide 
varietyofprogramminglanguages,tothebestofourknowledge,
ithasneverbeenappliedtomulti-taskPLCsbefore.Bohlenderet 
al. [11 ] applied concolic testing to single-task PLC programs but 
didnot considerthe interleaving of multiple tasks.
Our modelingofpreemptiveschedulingsemanticsis relatedto 
testing and verifying periodic programs. In this particular context,
Regehretal.[ 45 ]usedthreadstosimulatethebehaviorofinterrupt- 
drivenCprograms.Kroeningetal.[ 32 ]veri/f_iedCcodewithnested 
interruptsusingaboundedmodelchecker.Chakietal.[ 14 ,15 ]also 
developedseveraltoolsforverifyingperiodicCprograms.Although 
therearesimilarities,theseworksaresigni/f_icantlydiﬀerentbecause 
thesemanticsofPLCtasksdiﬀersfrombothinterruptsandthreads.
Furthermore, none of these prior works was related to symbolic 
execution, whichisthe focus ofourwork.
Our method for restricting task interactions based on priori- 
tieswasinspiredbytechniquesformodel checking real-timesoft- 
ware[ 4,10 ,21 ,28 ,37 ],whichencodenecessaryconditionsofthe 
schedulersemantics toincrease /f_idelityand reduce state-space ex- 
plosion. Similar approaches were also used in combination with 
symbolicexecution[ 38 ].Ourstatefulreductioncanbeviewedasan 
instance of the state-merging and matching technique in symbolic 
execution [ 3,25 ,26 ,35 ]. However, none of the existing techniques 
has been appliedtoPLCsoftware.
There are techniques for synthesizing PLC software from speci- 
/f_ications.Forexample,Chengetal.[ 17 ,18 ]synthesizedPLCcode 
fromlineartemporallogicspeci/f_ications. Gelenetal. [ 24 ]synthe- 
sizedPLCcodeforreal-timesupervisorycontrolofamanufacturing 
system. However, due to inherent limitations, so far, they can only 
producesmallprograms. S/y.sc/m.scPLCcanbeconsideredasacomple- 
mentary testingmethodtothese programsynthesis tools.
8 CONCLUSIONS 
Wehavepresentedasymbolicexecutiontoolforautomaticallytest- 
ingsingle-andmulti-taskPLCprograms.IttakesthePLCsource 
code as input, translates itinto Ccode, andthen appliessymbolic 
execution.Assuch,itcansystematicallyexplorefeasiblepathsof 
individual PLC tasks as well as their interleavings. Toward this 
end, our main contribution is developing a number of PLC-speci/f_ic 
reduction techniques foreliminating redundant interleavings. Our 
experimentsshowthatthetooliseﬃcientinhandlingalargenum- 
berofPLCbenchmarkprograms. Onmulti-taskPLCprograms, in 
particular, our newreduction techniques signi/f_icantly outperform 
the state-of-the-artpartial orderreductionstechnique.
ACKNOWLEDGMENTS 
ThismaterialisbaseduponresearchsupportedinpartbytheU.S.
National Science Foundation under grants CNS-1617203 and CNS-
1702824andtheU.S.OﬃceofNavalResearchunderawardnumber 
N00014-13-1-0527.Symbolic ExecutionofProgrammable Logic ControllerCode ESEC/FSE’17, September4-8, 2017, Paderborn, Germany 
REFERENCES
[1] Borja FernandezAdiego, Dániel Darvas, Enrique BlancoViñuela, Jean-Charles 
Tournier, Simon Bliudze, Jan OlafBlech, andVíctorManuel GonzálezSuárez.
Applying model checking to industrial-sizedPLCprograms. IEEE Trans.
IndustrialInformatics , 11(6):1400–1410, 2015.
[2]AlexanderAiken,ManuelFähndrich,andZhendongSu. Detectingracesinrelay 
ladderlogicprograms. In InternationalConference on ToolsandAlgorithmsfor 
ConstructionandAnalysisofSystems , pages 184–200, 1998.
[3] Saswat Anand,CorinaS. Pasareanu, and WillemVisser. Symbolicexecution 
with abstractsubsumptionchecking. In InternationalSPIN Workshop on Model 
Checking Software , pages 163–181, 2006.
[4] Luciano Baresi,Carlo Ghezzi,andLuca Mottola. On accurate automatic 
veri/f_ication of publish-subscribe architectures. In InternationalConference on 
Software Engineering , pages 199–208, 2007.
[5] BernhardBeckert, Mattias Ulbrich, BirgitVogel-Heuser, andAlexanderWeigl.
Regressionveri/f_ication forprogrammable logiccontrollersoftware. In 
InternationalConference on Formal Methodsand Software Engineering , pages 
234–251,2015.
[6] TomBergan, Dan Grossman, andLuis Ceze. Symbolicexecution of 
multithreadedprograms fromarbitrary programcontexts. In ACM SIGPLAN 
Conferenceon Object Oriented Programming,Systems,Languages,and 
Applications , pages 491–506, 2014.
[7]Sebastian Biallas, Jörg Brauer, and Stefan Kowalewski. Counterexample-guided 
abstraction re/f_inement for PLCs. In International Workshop on Systems Software 
Veri/f_ication , 2010.
[8] Sebastian Biallas,JörgBrauer, andStefan Kowalewski. Arcade.PLC:A 
veri/f_ication platformforprogrammable logiccontrollers. In IEEE/ACM 
InternationalConference On Automated Software Engineering , pages 338–341,
2012.
[9] Sebastian Biallas,MircoGiacobbe, and Stefan Kowalewski. Predicate 
abstraction for programmable logic controllers. In Formal Methods for Industrial 
Critical Systems-18th International Workshop , pages 123–138, 2013.
[10] ThomasBøgholm, HenrikKragh-Hansen,PeturOlsen, Bent Thomsen,and
KimGuldstrand Larsen. Model-basedschedulability analysis ofsafety critical 
hardreal-time Java programs. In InternationalWorkshop on JavaTechnologies 
forReal-time andEmbedded Systems , pages 106–114, 2008.
[11] DimitriBohlender, HendrikSimon, NicoFriedrich, Stefan Kowalewski,and 
Stefan Hauck-Stattelmann. Concolictest generationforPLC programs using 
coverage metrics. In InternationalWorkshop on Discrete Event Systems ,pages 
432–437,2016.
[12] CristianCadar, Daniel Dunbar, andDawson R. Engler. KLEE:unassisted and 
automaticgenerationofhigh-coveragetestsforcomplexsystemsprograms. In 
USENIXSymposium on Operating SystemsDesign and Implementation , pages 
209–224,2008.
[13] HenrikCarlsson, BoSvensson, FredrikDanielsson, andBengtLennartson.
Methods forreliable simulation-based PLCcode veri/f_ication. IEEE Trans.
IndustrialInformatics , 8(2):267–278, 2012.
[14] Sagar Chaki,Arie Gur/f_inkel, and NishantSinha. Eﬃcient veri/f_ication of 
periodic programs using sequential consistency and snapshots. In International
Conferenceon Formal Methodsin Computer-Aided Design , pages 51–58,2014.
[15] Sagar Chaki,Arie Gur/f_inkel, and Ofer Strichman. Time-boundedanalysisof 
real-time systems. In InternationalConference on Formal Methodsin 
Computer-Aided Design , pages 72–80, 2011.
[16]Gangchen,Xiaoyu Song,and MingGu. PLC programveri/f_icationand analysis 
usingthe coq theoremprover. ActaScientiarum Naturalium Universitatis 
Pekinensis , 46(1):30–34, 2010.
[17] Chih-HongCheng, Yassine Hamza, and HaraldRuess. Structural synthesisfor 
GXW speci/f_ications. In International Conference on Computer Aided Veri/f_ication ,
pages 95–117,2016.
[18] Chih-HongCheng, Chung-Hao Huang,HaraldRuess, and StefanStattelmann.
G4LTL-ST: automaticgenerationofPLCprograms. In InternationalConference
on ComputerAidedVeri/f_ication , pages 541–549, 2014.
[19] LiviuCiortea,CristianZam/f_ir, Stefan Bucur, Vitaly Chipounov,andGeorge 
Candea. Cloud9: A software testing service. Operating SystemsReview ,
43(4):5–10,2009.
[20] Dániel Darvas, IstvánMajzik,and Enrique BlancoViñuela. Formalveri/f_ication 
ofsafety PLCbasedcontrol software. In Integrated Formal Methods-12th 
InternationalConference , pages 508–522, 2016.
[21] XianghuaDeng, MatthewB. Dwyer, John Hatcliﬀ, Georg Jung,Robby, and 
GurdipSingh. Model-checking middleware-based event-driven real-time 
embeddedsoftware. In InternationalSymposium on Formal Methodsfor 
Components andObjects , pages 154–181, 2002.
[22]Jean-Marie Farines, Max Hering de Queiroz, Vinicius G. da Rocha, Ana Maria M.
Carpes, FrançoisVernadat, andXavierCrégut. A model-driven engineering 
approachtoformal veri/f_ication ofPLCprograms. In IEEE Conference on 
Emerging Technologies& Factory Automation , pages 1–8, 2011.
[23] CormacFlanagan and Patrice Godefroid. Dynamicpartial-orderreduction for 
model checking software. In ACM SIGACT-SIGPLAN Symposium on Principles of 
Programming Languages , pages 110–121, 2005.
[24] GökhanGelen andMurat Uzam. The synthesisand PLC implementationof 
hybridmodularsupervisors forreal time control ofan experimental manufacturingsystem. Journal ofManufacturing Systems , 33(4):535–550, 2014.
[25] Shengjian Guo, Markus Kusano,and ChaoWang. Conc-iSE:incremental 
symbolicexecution ofconcurrentsoftware. In IEEE/ACM International 
Conference On AutomatedSoftwareEngineering ,pages 531–542, 2016.
[26] Shengjian Guo, Markus Kusano,ChaoWang,Zijiang Yang, andAarti Gupta.
Assertion guidedsymbolicexecution of multithreadedprograms. In ACM 
SIGSOFT Symposiumon FoundationsofSoftware Engineering , pages854–865,
2015.
[27] C. G.Haba,R. Cociu,andL. Cociu. Mixedmode veri/f_ication ofPLCbased 
control systems. In InternationalSymposium on AdvancedTopics in Electrical 
Engineering ,pages 1–4,2011.
[28]Matthew Hoosier, Matthew B. Dwyer, Robby, and John Hatcliﬀ. A case study in 
domain-customizedmodel checking forreal-time componentsoftware. In 
InternationalSymposium on Leveraging ApplicationsofFormal Methods , pages 
161–180,2004.
[29]Karl-Heinz John and Michael Tiegelkamp. IEC 61131-3: programming industrial 
automation systems:concepts andprogramming languages, requirements for 
programming systems, decision-making aids . Springer Science & Business Media,
2010.
[30] VineetKahlon, ChaoWang, andAartiGupta. Monotonicpartial order 
reduction:An optimal symbolicpartial orderreduction technique. In 
InternationalConference on ComputerAided Veri/f_ication , pages398–413, 2009.
[31] Lock-Jo Koo,Chang MokPark, Chang Ho Lee,SangChul Park, andGi-Nam 
Wang. Simulation frameworkforthe veri/f_ication ofPLCprograms in 
automobile industries. InternationalJournal ofProduction Research ,
49(16):4925–4943,2011.
[32] Daniel Kroening,LihaoLiang, TomMelham,PeterSchrammel, andMichael 
Tautschnig. Eﬀective veri/f_ication oflow-level software with nestedinterrupts.
In Proceedings of the 2015 Design, Automation & Test in Europe Conference , pages 
229–234,2015.
[33] MarkusKusano and ChaoWang. Assertion guidedabstraction:acooperative 
optimizationfor dynamicpartial orderreduction. In IEEE/ACMInternational 
ConferenceOn AutomatedSoftwareEngineering ,pages 175–186, 2014.
[34] E.V.Kuzmin, Valery A. Sokolov,andD.A.Ryabukhin. Construction and 
veri/f_ication ofPLC-programs by LTL-speci/f_ication. Automatic Control and 
Computer Sciences , 49(7):453–465,2015.
[35] VolodymyrKuznetsov,Johannes Kinder,Stefan Bucur,andGeorge Candea.
Eﬃcient statemergingin symbolicexecution. In ACM SIGPLAN Conferenceon 
Programming Language Design and Implementation ,pages 193–204, 2012.
[36] TimLange, Martin R.Neuhäußer, andThomasNoll. Speeding upthe safety 
veri/f_ication ofprogrammable logiccontrollercode. In InternationalHaifa
Veri/f_ication Conference ,pages 44–60, 2013.
[37]Gary Lindstrom, Peter C. Mehlitz, and Willem Visser. Model checking real time 
Java using Java PathFinder. In InternationalSymposiumon Automated 
Technology forVeri/f_ication and Analysis ,pages 444–456, 2005.
[38] Kasper Søe Luckow, Corina S. Pasareanu, andBentThomsen. Symbolic 
execution andtimedautomatamodel checking fortiming analysis of Java 
real-time systems. EURASIPJ.Emb.Sys. , 2015:2,2015.
[39] IEC61131-3 compiler.URL:https://www.openhub.net/p/matiec.
[40] StephenE. McLaughlin,Saman A.Zonouz, Devin J. Pohly, and Patrick D.
McDaniel. A trusted safetyveri/f_ierforprocesscontrollercode. In Networkand
DistributedSystem Security Symposium ,2014.
[41] Houda Bel Mokadem,BéatriceBérard,V. Gourcuﬀ,O. De Smet, and J. Roussel.
Veri/f_ication of a timedmultitasksystemwithuppaal. IEEE Trans. Automation 
Scienceand Engineering , 7(4):921–932, 2010.
[42] Johanna Nellen, ErikaÁbrahám,and Benedikt Wolters. A CEGAR tool for the 
reachability analysis of PLC-controlledplantsusing hybridautomata. In 
FormalismsforReuse andSystems Integration , pages 55–78. 2015.
[43]Johanna Nellen, Kai Driessen, Martin Neuhäußer, Erika Ábrahám, and Benedikt 
Wolters. TwoCEGAR-basedapproachesforthe safety veri/f_ication of 
PLC-controlledplants. Information SystemsFrontiers , pages 1–26, 2016.
[44] Sang C.Park, Chang MokPark,Gi-NamWang, Jonggeun Kwak, andSungjoo 
Yeo. PLCStudio:Simulation based PLCcode veri/f_ication. In Proceedingsofthe 
2008 WinterSimulation Conference , pages 222–228,2008.
[45] John Regehrand NathanCooprider. Interruptveri/f_ication via thread 
veri/f_ication. Electr.Notes Theor.Comput.Sci. ,174(9):139–150, 2007.
[46] ChaoWang, Zijiang Yang, VineetKahlon, andAartiGupta. Peephole partial 
orderreduction. In InternationalConference on Tools and Algorithmsfor 
Construction and AnalysisofSystems , pages 382–396,2008.
[47] Mo Xia, Mian Sun,Guiming Luo, andXibin Zhao. Design andimplementation 
of automaticveri/f_ication for PLCsystems. In IEEE InternationalConference on 
Cognitive Informaticsand Cognitive Computing , pages 374–379, 2013.
[48]Litian Xiao, Mengyuan Li, Ming Gu, and Jiaguang Sun. A hierarchy framework 
on compositional veri/f_ication for PLC software. In IEEE International Conference
on SoftwareEngineering and ServiceScience ,pages 204–207, 2014.
[49] NalingZhang, MarkusKusano,andChaoWang. Dynamicpartial order 
reduction forrelaxedmemorymodels. In ACM SIGPLAN Conferenceon 
Programming Language Design and Implementation , pages 250–259, 2015.