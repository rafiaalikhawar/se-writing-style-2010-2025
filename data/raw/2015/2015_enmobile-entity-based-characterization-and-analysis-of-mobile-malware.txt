EnMobile: Entity-based Characterization and Analysis of Mobile
Malware
Wei Yang∗
University of Illinois at
Urbana-Champaign
weiyang3@illinois.eduMukul R. Prasad
Fujitsu Laboratories of America
Sunnyvale, California
mukul@us.fujitsu.comTao Xie†
University of Illinois at
Urbana-Champaign
taoxie@illinois.edu
ABSTRACT
Modernmobilemalwaretendtoconducttheirmaliciousexploits
throughsophisticatedpatternsofinteractionsthatinvolvemulti-
ple entities, e.g.,the mobile platform, human users, and network
locations.Suchmalwareoftenevadethedetectionbyexistingap-
proaches due to their limited expressiveness and accuracy in char-
acterizing and detecting these malware. To address these issues, in
this paper, we recognize entities in the environment of an app, the
app’sinteractionswithsuchentities,andtheprovenanceofthese
interactions, i.e.,theintentandownershipofeachinteraction,asthe
keytocomprehensivelycharacterizingmodernmobileapps,and
mobilemalwareinparticular.Withthisinsight,weproposeanovel
approach named EnMobile including a new entity-based character-
ization of mobile-app behaviors, and corresponding static analyses,
toaccuratelycharacterizeanapp’sinteractionswithentities.We
implement EnMobileand provide apractical application ofEnMo-
bile in a signature-based scheme for detecting mobile malware. We
evaluate EnMobile on a set of 6614 apps consisting of malware
fromGenomeandDrebinalongwithbenignappsfromGooglePlay.
OurresultsshowthatEnMobiledetectsmalwarewithsubstantially
higherprecisionandrecallthanfourstate-of-the-artapproaches,
namely Apposcopy, Drebin, MUDFLOW, and AppContext.
CCS CONCEPTS
•Programreasoning →Programanalysis ;•Systemssecurity
→Mobile security ;
ACM Reference Format:
Wei Yang, Mukul R. Prasad, and Tao Xie. 2018. EnMobile: Entity-based
Characterization and Analysis of Mobile Malware . In ICSE ’18: ICSE ’18:
40th International Conference on Software Engineering , May 27-June 3, 2018,
Gothenburg,Sweden. ACM,NewYork,NY,USA,11pages.https://doi.org/
10.1145/3180155.3180223
∗This author was an intern at Fujitsu Labs. of America for part of this work.
†ThisworkwassupportedinpartbyNationalScienceFoundationundergrantsno.
CCF-1409423, CNS-1513939, CNS1564274.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
©2018 Copyright held by the owner/author(s). Publication rights licensed to the
Association for Computing Machinery.
ACM ISBN 978-1-4503-5638-1/18/05...$15.00
https://doi.org/10.1145/3180155.31802231 INTRODUCTION
The explosive growth in mobile devices and mobile applications,
or ‘apps’, has spurred the growth of mobile malware. A case in
point is the number of unique Android malware samples, which in-
creasedfrom10.7millionsamplesin2015tomorethan19.2million
inDecember2016[ 3].Malwaredetectionbasedonbehaviorsisa
prominent class of malware-detection approaches where character-
istics of known malware samples are used as a basis of identifying
new malware [ 4,7,21,32,39,41–43,52]. These approaches typ-
ically work in two phases: malicious-behavior characterization
and malicious-behavior detection. Thebehavior-characterization
phase creates a specification of the malicious behaviors, in the
form of manually specified malware signatures or as automatically
minedmalwaremodels,inasuitablerepresentation.Inthebehavior-
detection phase, techniques based on static or dynamic program
analysisareusedtoanalyzeagivenmobileappforpossiblematches
against the specified signatures or mined models.
Limitationsofexistingapproaches. Existing malware detec-
tionapproaches[ 6,8,9,11,21,21,22,25,29,45,50,51]sufferfrom
the overfitting problem – these approaches are tailored to detect
onlythe malware samples used for deriving the signatures or mod-
els.Thetwomainreasonsarethe limitedexpressiveness andlimited
accuracy of these approaches.
Limited expressiveness. The existing approaches primarily use
information-leakingdataflows withintheappasthebasisofamali-
ciousbehavior.However,theexistingapproachestypicallyfailto
capturemalicious behaviorsinitiatedandcontrolled bymalicious
servers, such as initiating spams or launching denial-of-service
attacks.Intheseexploits,the intentisnotinformationleakage.Fur-
ther, a key indicator of the malicious intent in these cases is the
controlof the malicious interactions by an external server. With-
out a proper characterization for these key aspects, the existing
approaches turn to easily mutable features (shared across malware
samples of the same family) such as network addresses or other
string constants to detect these behaviors, allowing malware devel-
opers to easily change these features to evade detection.
Limited accuracy. The existing approaches fail to recognize and
expressend-to-end interactions between a malware sample and en-
tities in its environment. Instead they characterize segments ofthese interactions using implementation-specific structures (e.g.,
API methods,objects) asend-points. Forexample, consider asam-
ple of the GingerMaster malware with the following four-phase
malicious behavior: (1) the app retrieves and preprocesses a phone
number from the telephony manager (entity A); (2) the app writes
the preprocessed phone number into a temporary file (entity B);
(3) the app reads the preprocessed phone number from the same
3842018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:44 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Wei Yang, Mukul R. Prasad, and Tao Xie
temporary file (entity B); (4) the app sends the preprocessed phone
number to a (malicious) server (entity C). A typical malware sig-
nature based on the existing approaches would characterize this
behavior as four interactions. Further, the existing approaches see
the app interacting with someJava Fileobject in Phases 2 and 3,
withoutrecognizingthatsuch Fileobjectisthe samefilewritten
to and later read from.
Therefore,theexistingapproachescanproducefalsepositivesby
matching the preceding behavior with that of a benign app where
thepreprocessedphonenumberissavedtoafile,andnon-sensitive
informationreadfroma differentfileissenttoaserver.Inaddition,
theGingerMaster malwarefamilyhassevenvariations(i.e., differ-
entimplementations)duringtheperiodof2011–2013[ 46].These
variations can either skip Phases 2 and 3 by directly sending the
preprocessed phone number to the malicious server or replace the
temporary file entity in Phases 2 and 3 to be a temporary database.
Thus,theexistingapproachescanalsoproducefalsenegativesby
making their malware signature very specific to Phases 1-4.
Toaddresstheselimitationsoftheexistingapproaches,inthis
paper,wepresentanovelapproach,EnMobile.TheEnMobileap-
proachismotivatedbythefinding[ 8,46,52]thatmorethan90%of
currentmobilemalwarehaveacommand-and-control(C&C)archi-tecture,wherethemalwarereceiveandrespondtocommandsfrom
anexternalactor, e.g.,aremoteserver.Thus,EnMobileisbuiltto
directly characterize the underlying C&C structure of the malware.
In particular, EnMobile improves the existing malware-behavior
characterization in three main aspects.
Entity-basedcharacterization. Ratherthanusingimplementation-
specific structures (e.g., API methods, objects) or easily mutable
featuresinanapp,EnMobileexpressestheapp’sbehaviorsinterms
ofinteractionsamong entities.Entitiesareahostofactorsonthe
mobileplatformincludingmobilesystemcomponents(e.g., thetele-
phonymanager,SMSmanager,contacts provider), localon-device
resources(e.g., files,databases),othermobileappsandlibraries,hu-
manusers,andnetworklocations, etc.EnMobilerecognizesentities
throughtheiridentities.Forexample,fileswithdifferentnamesare
different entities.
Furthermore,introducing theconceptofentity allowssecurity
analyststoexpressanentityinteractioninan end-to-end fashion,
makingitmuchmoreindependentofspecificrealizationsofthat
interaction(e.g., specificsofPhases2and3in GingerMaster ),and
hencemorerobust.Forexample,forthe GingerMaster malwarefam-
ily,securityanalystscansimplyspecifytheend-to-endinformationflowfromthetelephonymanager(entity
A)tothemaliciousserver
(entityC), without enumerating all possible intermediate-point
entities (e.g., files, databases).
Flow-provenance predicates. Going beyond using information-
leakingdataflowswithintheapp,EnMobileenrichesinteractions
among entities with provenance information. Provenance in our
contextrefersto whocontrolstheflow,and why,i.e.,thespecific
intended purpose of the flow [ 18,23,38,50]. For example, the ex-
isting approaches may produce an information flow ( file/squiggleright
sendTextMessage ).Suchflowcanmatchboththebehaviorofsend-
ing contents of a file out through SMS (a benign action of sending
predefined messages) and the behavior of specifying which phone
numbersthattheSMSshouldbesentto(amaliciousactionofsend-
ing premium messages). To distinguish such scenarios, we proposeasetofdataflowpredicates(Section4.1.1)toreflecttheintended
purposeofaninformationflow(e.g., passingconfigurationparame-
tersvs.purelytransmittinginformationtoanotherentity),andaset
of controlflow predicates(Section 4.1.2) tospecify theownership
of information flows, i.e.,the entity that initiates or controls the
information flow.
Identification of entities and entity references. In order to charac-
terizeanapp’sbehaviorsdirectlyintermsofitsinteractionswith
entitiesof theapp,onechallenge istoextractthe correspondence
betweenanin-programobject(termedasan entityreference )and
the entity with which the object may interact in a given execution
context (e.g., calling context). To infer the entities that each Java
object can point to, we develop an identity-propagation algorithm
that conducts a flow- and context-sensitive analysis. It extends
and adapts modern taint analysis algorithms [ 9]. Our algorithm
needstocorrectlyresolvetwocorescenarios.First,multipleobjects
could point to the same entity. Second, a given program object can
interact with different entities under different execution contexts.
Asdiscussedearlier,malwaretypicallyperformmaliciousbehav-
iorssegmentedintomultiplephases(e.g., downloading,preprocess-
ing),storingintermediatecomputationresultsintemporaryfilesor
databases. This segmentation gives rise to multiple segments of in-
formationflow,punctuatedwithinteractionswithentities(e.g., files
ordatabases).Thesesegmentswouldneedtobe“stitchedtogether”
in order to be properly matched against a signature specified to
characterizetheend-to-endinteraction.Toaddressthechallenge,
weproposea flow-sensitive stitchingalgorithmtoensurethatthe
connected information flows are feasible in the actual execution.
This paper makes the following main contributions:
•Characterization. We identify malware interaction patterns
withentitiesandprovenanceinformationoftheinteractionsasa
corner stone of comprehensively characterizing mobile malware.
We also propose a novel signature-specification language, based
onthis characterization,that enablessecurity analyststocreate
robust, abstract specifications.
•Detection. We design static analyses to derive the entity-based
characterization by analyzing bytecode of a given app, including
identifying entities and entity references, extracting provenance
information for flows, and matching against signatures in the
face of segmented flows.
•Implementation and Evaluation. We present a practical im-
plementationofourapproach andevaluateitseffectiveness,on
a set of 6614 apps consisting of malware from Genome [ 52]
and Drebin [ 8] along with benign apps from Google Play. Our
resultsshowthatEnMobileachievessubstantiallyhigherpreci-
sionandrecallthanfourstate-of-the-artapproaches,namelyAp-
poscopy [21], Drebin [8], MudFLow [11], and AppContext [50].
2 RELATED WORK
Existingmalwaredetectionapproachescharacterizemalwarebe-
haviors by features that commonly exist in malware but not in
benign apps. These approaches include mining (MUDFLOW [ 11]),
clustering(CHABADA[ 25]),classification(AppContext[ 50]),graph
matching(Astroid[ 22],Apposcopy[ 21]),andnaturallanguagepro-
cessing(AsDroid[ 26],WHYPER[ 35])etc.Thepracticeofcopy-and-
paste is pervasive in the malware industry, resulting in many code
385
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:44 UTC from IEEE Xplore.  Restrictions apply. EnMobile: Entity-based Characterization and Analysis of Mobile Malware ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
clones in malware samples [ 16]. Because the same code snippet
hasappearedinmanymalwaresamples(butnotinbenignapps),
theseexistingapproachesmayregardnon-essentialfeatures(e.g.,
component type, file name, unrelated information flows) in code
clonesasdiscriminativefeatures.EnMobileprovidessecurityan-
alysts a way to directly characterize malware behaviors through
thehigh-levelinteractionsamongentitiesratherthanrelyingon
implementation-specific characteristics of the malware.
EnMobilealsofallsintothegeneralcategoryoftechniquesbased
on information flow analysis. Much work has been proposed to en-
hancestaticanalysisofmobileapps[ 12,13,15,24,28–31,33,34,38,
47–49]. Information flow analysis tracks whether privacy-sensitive
data(i.e., sources)flowstooutgoingchannelsorsensitiveoutlets
(i.e.,sinks). EnMobile complements existing analysis by adding
entity-basedcharacterizationtotheinformationflow.AAPL[ 30]
usesenhanceddataflowanalysistechniquestoincreasethenum-
ber of data flows that can be detected by information flow analysis
and then uses the peer-voting mechanism to lower the false pos-
itive rate to report illegitimate information leakages. AAPL fails
tohandleobfuscation techniques,suchasstring encryption,since
it employs constant propagation analysis. Further, it incurs high
false positive rate, by matching all sources with all potential sinks.
EnMobile resolves these two limitations by precisely computing
theidentityofanentity.SPARTA[ 20]andFlowDroid[ 9]aretwo
generalinformationflowanalysisframeworks.SPARTAenablesthe
flow-policycheckingbyprovidinganintegritytypesystemtoanno-
tate source code with information-flow type qualifiers. FlowDroid
isastatictaintanalysistoolforAndroidappsbasedonSoot[ 27]
and Heros [ 14]. EnMobile complements SPARTA and FlowDroid
byanalyzingalltypesofdataflowstodetectmaliciousbehaviors
that are not information leakage, e.g.,bot-driven C&C behaviors.
3 A MOTIVATING EXAMPLE
Weillustrateourapproachusingamalwareexample TrickMe,shown
in Figure 1. TrickMeis derived from several real pieces of malware.
Its C&C structure comes from Geinimi [ 2], its downloading behav-
iorsmimicAnswerbot[ 1],anditsinformationleakagebehaviors
followBeanBot[ 5].TrickMehasthreemaliciousbehaviors:sending
the user’s SMS to the C&C server through Internet, performing
clickfraudbasedoncoordinatesprovidedbytheC&Cserver,and
downloadingandrenamingmaliciouspayloads.Allthreebehaviors
resideinanActivitycomponent MainActivity ,TrickMe’sMAINAc-
tivity component, which is invoked when the malware is launched.
TrickMereceives commands and prepares necessary informa-
tion for future malicious behaviors in the onCreate method of
MainActivity (Figure1a).Itfirstopensanetworkconnectiontoa
maliciousserver(Lines3-5),andreadsamessagefromtheservertofile
server.xml (Line12).Itthenparsesthe server.xml intothefour
files commandFile ,coordinateFile ,downloadFile , and fileNameFile
(Line 13). Finally, it reads a list of SMSs into file infoFile (Line 14).
Inthe onStopmethodof MainActivity (Figure1b), TrickMelaunches
oneofthreedifferent maliciousbehaviorsbasedondifferentcom-
mandsreceived earlierfromthe server.Oncommand sendInfo it
sendsthecontentof infoFile totheserver,oncommand clickit
computesandclicksontheX-Ycoordinatescomputedbasedonthe
numbersin coordinateFile toincurclickfraud[ 17],andoncom-
mand installitdownloadsmaliciouspayloadsfromURLaddresses1public void onCreate(Bundle b) {
2...
3String v0 = "http://www.malicious.com";
4URL url = newjava.net.URL(v0); //<url, CON_1>
5HttpURLConnection n = url.openConnection(); //<n, CON_1>
6f_s =newFile("server.xml"); //<f_s, FILE_1>
7f_c =newFile("commandFile");//<f_c, FILE_2>
8f_info =newFile("infoFile");
9f_n =newFile("coordinateFile"); //<f_n, FILE_3>
10f_d =newFile("downloadFile");
11f_f =newFile("fileNameFile");
12read(f_s, n); // Reading message from n to f_s
13parse(f_s, f_c, f_n, f_d, f_f); //Parsing f_s into four files
14readSMS(f_info); ... }
(a)onCreate method of MainActivity
1public void onStop() {
2...
3for(String command: readLine(f_c)){
4if(command.equals("click")){
5float[] axis = getAxis(readLine(f_n));
6MotionEvent down = MotionEvent.obtain(...,0, axis[0],axis[1],0);
7MotionEvent up = MotionEvent.obtain(...,1, axis[0],axis[1],0);
8...
9Activity adActivity = ...; //<s,AdsPlatform>
10 Webview adView = adActivity.findViewbyID (...);
11 adView.dispatchTouchEvent(down);
12 adView.dispatchTouchEvent(up);
13}
14if(command.equals("sendInfo")){
15 sendFile("http://www.malicious.com",f_info);
16}
17if(command.equals("install")){
18 String [] filename = readLine(f_f);
19 inti=0 ;
20 for(String url: readLine(f_d)){
21 File f_i = newRandomAccessFile(filename[i++],"rw");
22 read(f_i,newjava.net.URL(url).openConnection());
23}}}...}
(b)onStopmethod of MainActivity
1publicString [] readLine(File file){ //<file, FILE_2>, <file, FILE_3>
2FileReader r = newFileReader(file); //<r, FILE_2>, <r, FILE_3>
3BufferedReader br = newBufferedReader(r); //<br, FILE_2>, <br, FILE_3>
4String line = br.readLine(); ...
5returnline; }
(c)readLine method of MainActivity
Figure 1: Motivating Example: TrickMemalware
listedin downloadFile ,andnamesthedownloadedfilesaccording
to the list of names in fileNameFile . The downloaded payloads are
used by TrickMeto launch other malicious behaviors.
Comparison of signatures in Apposcopy and EnMobile.
In a signature-based scheme for malware detection, such as Ap-poscopy [
21], security analysts can specify the control-flow and
data-flow properties shown in Figure 2 as the signature for the
TrickMemalware.
386
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:44 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Wei Yang, Mukul R. Prasad, and Tao Xie
activity(a), icc(SYSTEM, a, MAIN, _),
flow(a, URLConnection, a, file),flow(a, BufferedReader, a, URLConnection),flow(a, BufferedReader, a, file),flow(a, SMS, a, file)
Figure 2: Characterization of TrickMein Apposcopy [21]
The activity(a) predicate declares an activity component a.
The icc(SYSTEM, a, MAIN, _) predicate states an inter-component
communicationfromthesystemtotheactivity a,andthecontentof
the communication is a “MAIN” intent message. The flow(a, SMS,
a, file) predicate represents an information flow from source SMS
in component ato sink filein component a(Figure 1a, Line 14).
Althoughthespecifiedpredicatesdorepresentvalidinformation
flows and triggering events in TrickMe, these predicates are insuffi-
cientforrepresentingtheuniquecharacteristicsofthemalware,and
thereforemaybeunabletodifferentiatemalwarefromabenignapp.
Forexample,abenignSMSmanagerappcansynctheapp’sconfigu-
rationwithaserver( BufferedReader /squigglerightURLConnection ),(URLConnect
ion/squigglerightfile),andbackupSMSs( SMS/squigglerightfile)where/squigglerightindicatesan
informationflow.Suchanappalsopossessesthesamecontrol-flow
and data-flow properties as TrickMe, as per Apposcopy’s character-
ization, and would therefore be indistinguishable from TrickMe.
Figure3 presentsthe signatureof TrickMespecifiedby security
analystsinEnMobile.EnMobileenablesanaccuratecharacteriza-
tionof TrickMe,inthreerespects.First,EnMobileallowsdesignating
the entities that certain behaviors may be attributed to, thereby
precisely characterizingthe purposeof thebehavior. Forexample,
auniquebehaviorof TrickMeisitsuseofthe“command”readfrom
“commandFile”sentfromtheC&Cserver,todirectthelaunchingof
differentmaliciousbehaviors.Identifyingandimplicatingtheentity,theremoteC&Cserver,ratherthanthelocalfile“commandFile”(as
theexistingapproacheswoulddo),iskeytorecognizingthetrue
nature of this behavior.
Second,EnMobileallowsstitchingsegmentsoftheend-to-end
flowbehaviorexhibitedby TrickMe.Forexample,thesignaturein
Apposcopyincludesonlythebenign-lookingflows( SMS/squigglerightfile)
and ( BufferedReader /squigglerightURLConnection ), while EnMobile infers
these flows as segments of a larger, and potentially malicious flow
(i.e., Transmit*(s, n_2) ofUploadMessage in Figure 3 indicating
the behavior of sending SMSs to a web server).
Third, EnMobile detects malicious behaviors beyond informa-
tionleakage.EnMobilecapturesanumberofnon-leakagebehaviors
inTrickMe, such as click fraud, downloading and renaming files.
Capturingsuchbehaviorsrequiresanuancedcharacterizationof
information flows. As shown in our results (Section 6.3), character-
ization can significantly impact the accuracy of malware detection.
4 ENTITY-BASED CHARACTERIZATION
Broadly, EnMobile aims to characterize an app in terms of its
relevantinteractions with entities. To this end, it tracks and pre-
cisely characterizes information flows associated with the security-
sensitivebehaviorsofanapp.Wenextillustratesomepreliminaries
before presenting characterization in EnMobile.
Security-sensitive Behavior. A security-sensitive behavior is
aninvocationofasecurity-sensitivemethod.Weconsidertwotypesofmethodsassecuritysensitive:permission-protectedmethodsandTrickMe(a) :- Download(a), SendMessage(a), UploadMessage(a).
ClickAds(a):- Connection(n), AdsPlatform(s), SysUIEvent(e),
Config*(n, s, TOUCH), Control*(n, s, TOUCH), Trigger(e, s, TOUCH).
Download(a) :- Connection(n), SysUIEvent(e), Connection(n_i),
Initiate*(n, n_i), File(f_i), Initiate*(n, f_i), Transmit(n_i, f_i),
Trigger(e, f_i, WRITE), Control*(n, f_i, WRITE).
UploadMessage(a) :- Connection(n), SysUIEvent(e), Connection(n_2),
SmsInbox(s), Transmit*(s, n_2), Control*(n, n_2, WRITE),Trigger(e, n_2, WRITE).
Figure 3: Characterization of TrickMein EnMobile
othersource/sinkmethodsthatread/writeinformation.Permission-
protected methods are API methods that require permissions to
access security-sensitive resources and data. We use the list of
permission-protected methods specified in PScout [ 10], and the list
of source/sink methods specified in SuSi [ 36]. Further, we follow
PScout[10]tolabeleachsecurity-sensitivemethodcallwithone
ofasmallsetofabstractactions(e.g., SEND, RECEIVE, READ, WRITE ),
based on its overall behavior. These action labels are used in our
characterization (Section 4.1).
Entity.Anentityisanexternalresourcethatanappinteracts
withduringitsexecution.Entitiesmayincludenetworklocations
(e.g.,URLsorphonenumbers)externaltothedevicerunningthe
app,suchastheURLofaC&Cserver.Theymayalsoincludeon-
deviceintermediatestoragesites(e.g., files,databases)orspecific
Android system resources (e.g., the SMS Manager), with which
theappmayinteractduringexecution.Entitiesformthesources
(providing information) or targets/sinks (consuming information)
of information flows to/from the app. An entity is defined by a
tuple:<entity type ,entity identifier >.
Entitytype. Thetypeidentifiesthe category ofentity,suchasa
file or a network location ( File,UrlConnect ), as well as the type of
communication channel of the app with the entity, such as an SMS
communication with a phone number ( SmsTarget ) and a phone call
to a number ( PhoneTarget ).
Entityidentifier. Theidentifieristhenameoraddressoftheentity,
such as a file name, a URL, or a phone number, which together
with the entity type can be used to uniquely identify the entity. In
EnMobile, entity identifier values are stored and propagated in the
programvia(primitive-type orstring-type)constantsorsymbolic
expressions(involvingvariablesprovidedbytheexternalinput, e.g.,
network message, user input).
Entity reference. Anentityreferenceisanin-programobject
orvariablethatservesasaproxyoftheentitywithintheappand
throughwhichtheappcommunicateswiththeentity.Forexample,
variable f_s,inFigure1a,Line6,isareferenceofa Fileentitywith
identifier “server.xml”. An entity may have multiple references.
Conversely,asingleobject,suchastheAndroidSMSManager,may
instantiatedifferententities(e.g., SMSstodifferentphonenumbers)
at different points during the app’s execution.
4.1 Language Specification
We propose a language to characterize an app based on its inter-
actionswithentities.Oneuseofsuchcharacterizationistowrite
signatures for recognizing malware. Figure 3 shows a signature
characterizing the TrickMeexample.
387
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:44 UTC from IEEE Xplore.  Restrictions apply. Table 1: App-behavior description language
Type Syntax Definition
Event SysEvent(v), UiEvent(v), v: event of appropriate type
Predicate SysUiEvent(v) (one of three event types: System event, UI event, or System UI event)
Entity Entity(e), File(e), UrlConnect(e), e : entity of appropriate type
Predicate SmsTarget(e), SmsInbox(e) (partial list of potential entity types)
Transmit( esource ,etarдet ) esource: source entity, etarдet: target entity
Transmit*( esource ,etarдet ) Transmit*( es,et) :- Entity( ei), Transmit*( es,ei), Transmit( ei,et)
Data-flow Config(esource ,etarдet ,a) esource: source entity, etarдet: target entity, a: target entity’s action
Predicate Config*(esource ,etarдet ,a) Config*( es,et,a) :- Entity( ei), Transmit*( es,ei), Config( ei,et,a)
Initiate( esource ,etarдet ) esource: source entity, etarдet: target entity
Initiate*( esource ,etarдet ) Initiate*( es,et) :- Entity( ei), Transmit*( es,ei), Initiate( ei,et)
Control-flow Trigger(vtriддer ,etarдet ,a) vtriддer: triggering event, etarдet: implicated entity, a: security action
Predicate Control(econtrol ,etarдet ,a)econtrol: controlling entity, etarдet: controlled entity, a: security action
Control*( econtrol ,etarдet ,a) Control*( ec,et,a) :- Entity( ei), Transmit*( ec,ei), Control( ei,et,a)
ThecharacterizationisasetofDatalogrules.Eachrule,ofthe
form: head :- predicate1, predicate2, ... , is a horn clause,
definingapredicate headastheconjunction(logicalAND)ofone
ormoreotherpredicates(e.g., predicate1 ).Apredicateisarelation
name with variables or constants as arguments.
Table1providesaninformalspecificationofourproposedlan-
guage.It consistsoffourkindsof predicates,namely event,entity,
data-flow, and control-flow predicates, as described next.
Event predicate. Event predicates declare relevant events, as
one of three types: System,UI,o rSystem UI events. A system event
is one initiated by the system-state changes, e.g.,receiving an SMS,
aUIeventistriggeredbyinteractionsonanapp’sgraphicaluser
interface, and a system UI event is triggered by the interactions on
thedeviceinterfaces,suchaspressinganapp’sicononthesystem’s
screentolaunchtheapp.Thiscategorizationfollowspreviouswork
on Android testing [50].
Entity predicate. Entity predicates declare specific entities,
each of a specific type, with which the app interacts during its
execution. For example, in Figure 3, File(f)denotes a file entity f.
Table 1 lists a few examples of currently recognized types.
4.1.1 Data-flow predicates. Wemaketheobservationthatthe
intentofaninformationflowcanbedeterminedbasedonaspecific
parameter of the sink method that it flows into. The reason is that
eachparameterofa(sink)methodplaysaspecificroleinexecutingits behavior. Thus,our characterization categorizes eachparameter
ofasinkmethodintooneofthreetypes:(1) transmitparameters,
whichreceivedatatobewrittentoatargetentity,(2) configparam-
eters,whichareusedtoconfiguresecurity-sensitivebehaviors,and
(3)initiateparameters,whichcarryidentifiers, e.g.,thefilename,to
initializeatargetentity.Basedonthischaracterization,information
flowscanalsobecategorizedasTransmit,Config,orInitiate,and
representedusingthecorrespondingpredicatesasexplainedbelow.
Toimplementthischaracterization,wepre-compilelistsoftrans-
mit,config,initiateparametersandtheircorrespondingmethods
forcommonentitiesintheAndroidSDK,asaone-timeeffortfor
Android.Predicate Transmit (Transmit*). TheTransmit predicateen-
codes data transmission from a source entity esourceto a target
entityetarдet,wheretheappreadsinformationfrom esourceand
writes it to etarдet. An information flow satisfies a Transmit pred-
icate if it flows into a designated transmit parameter of a sinkmethod. For example, in the TrickMecharacterization (Figure 3),
predicate Transmit(n_i, f_i) encodesthebehaviorofdownloading
payloads from given URLs ( n_i) to files ( f_i).
We also define the predicate Transmit*( esource ,etarдet ),t o
represent information transitively flowing from esourcetoetarдet
throughasequenceof Transmit flows.Forexample,the Transmit*(s,
n_2)(Figure3)encodesthebehaviorofreadinganSMSfromSM-
SInbox s, storing it into file “f_info” (Line 14, Figure 1a) and subse-
quently forwarding it to a given URL n_2(Line 15, Figure 1b).
Predicate Config(Config*). This predicate encodes informa-
tionflowsfromasourceentity esourcetotargetentity etarдetiniti-
atedexclusivelyforconfiguringthebehaviorofasecurity-sensitiveaction
aperformedby etarдet.Similarto Transmit,thedefinitionis
extended to define predicates Config*, as per Table 1. For example,
inthe TrickMemalware,thenumbersavedinthe“coordinateFile”
is usedto configure the behaviorof dispatchTouchEvent (Lines 4-7
in Figure 1b), as the content in the “coordinateFile” is from net-
work connection n, the configuration relationship is represented
byConfig*(n, s, TOUCH) .
Predicate Initiate(Initiate*). This predicate represents a be-
haviorwheretheentityidentifier(e.g., afilename)ofatargetentity
etarдetisreadfromasourceentity esourceandflowsintoanini-
tialization statement used to instantiate etarдet.Initiatecan be
extendedtopredicate Initiate*,asdefinedinTable1.Inthe TrickMe
signature(Figure3),predicate Initiate*(n, f_i) representsthebe-
havior that file f_iis instantiated using its identifier read from file
“filenameFile”(Lines 18-22,Figure1b), whichitselfis downloaded
from network connection n(Lines 11-14, Figure 1a).
4.1.2 Control-flow predicates. Thesepredicatescapturethe“who ”
of security-sensitive behaviors, i.e.,which entity or event controls
them, a key determinant of the maliciousness of behaviors.EnMobile: Entity-based Characterization and Analysis of Mobile Malware ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
388
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:44 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Wei Yang, Mukul R. Prasad, and Tao Xie
Predicate Trigger.TheTriggerpredicate asserts that a given
security-sensitivebehavioristriggeredbyacertainevent.Specif-
ically, predicate Trigger(vtriддer ,etarдet ,A)is true if event
vtriддertriggerstheexecutionpathtoamethodcallperforming
an action A(e.g.,upload information), where etarдet(e.g.,URL
connection) is the target entity whose reference in the program
makes the security-sensitive method call. For example, the onStop
method of TrickMe(Figure 1b), which can be triggered by a System
UIeventsuchaspressingtheHOMEbutton,containsthreespecific
behaviors. The three Trigger(e,*,*) predicates in Figure 3 capture
this triggering relationship.
Predicate Control. TheControlpredicateassertsthatasecurity-
sensitive action a, performed by a reference of entity etarдet,i s
control-dependent on another entity econtrol. Specifically, pred-
icate Control(econtrol ,etarдet ,a)is true if and only if there
exists an information flow from a reference of econtrolto a con-
ditionalstatementguardingtheexecutionofasecurity-sensitive
methodcall,performingaction a.Controlcanalsobeextendedto
predicate Control*,asdefinedinTable1.Inthe TrickMeexample,the
command sent from URLConnection ncontrolsthe three malicious
behaviors. The predicates Control*(n, *, *) in Figure 3 encode
this control relationship.
5 ENTITY-BASED STATIC ANALYSIS
In this section, we present how EnMobile matches an Android
programagainstthegivenmalwaresignaturesspecifiedwiththe
entity-basedcharacterization.Atthemeta-level,suchprocesstakesfoursteps:(1)identifyentities(i.e., entitytypeandentityidentifier);
(2)mapentitiestoprogramobjects( i.e.,entityreferences);(3)extract
entity-basedflowfactsthroughanalysisonentityreferencesand
augment the extracted flow facts with provenance information; (4)
match the flow facts against the malware signatures.
5.1 Identifying Entities and Entity References
For the purpose of analysis, EnMobile categorizes entity references
into two types: initial entity reference and alias entity reference.
Normallyidentifyinganentityreferencedependsonaparameter
(e.g.,filename)inthestatementthatinitializesthereference.We
name such a parameter asan indicative parameter. If an indicative
parameter is a constant or external input (e.g., user input, network
message), we term the entity reference initialized by the parameterasinitialentityreference.Ifanindicativeparameterisavariablethat
in turn points to the initial entity reference (e.g., variable fileand
rinLines2-3,Figure1c),wetermtheentityreferenceinitialized
by the parameter as alias entity reference.
For brevity, we use only entities related to the SMS-sending
behavior in TrickMeas examples to illustrate the techniques in the
restofthissection.Foreachentityreferenceinvolvedinsending
SMS, we use red comments in Figure 1 to show the pair of theentity reference (i.e., variable) and the entity that the reference
pointsto.Forexample,in TrickMe,url,f_s,f_c,f_info,f_n,f_d,f_
fin Figure 1a are initial entity references, while nin Figure 1a and
r,brin Figure 1c are alias entity references.
Identifyingentities. EnMobile identifies entities via initial en-
tity references. In particular, EnMobile identifies the entity typethroughtheJava typesofinitialentityreferences. Forexample,in
Figure 1a, f_shas java Type Fileindicating the entity type as file.
EnMobile extracts the entity identifier through the indicative
parameteroftheinitialentityreference.Anindicativeparameter
can either be a constant or external input. For a constant identifier,
EnMobilerecordstheconstantvalueastheidentityoftheentity.For an external-input identifier, EnMobile computes a symbolicexpression as the identity of the entity. The symbolic expression
is computed by a combination of sources of the variable (constant
or user input) and the propagation paths from the sources to the
variable.Thereasonwhywechoosetocomputethesymbolicex-
pressioninsteadofusingconstantpropagationanalysistoinferthe
actual value of the identifier is to deal with the situations where
the identifier value goes through an encryption scheme.
Mapping entities to entity references. Initial entity refer-
ences are naturally mapped to entities after identifying the entities.
Mapping alias entity references to corresponding entities is still
challengingfortwo mainreasons.First,multiplereferences could
pointtothesameentity.InFigure1c, rand brpointtothefileentity
referred to by file. The identity of the entity can be propagated
from one reference to another as one reference is used to initialize
anotherobject.Second,anentityreferencemaypointtodifferent
entitiesunderdifferentexecutioncontexts.InFigure1c, rand br
can point to “commandFile”, “coordinateFile”, or “downloadFile” in
different executions.
We develop an identity propagation algorithm to compute the
entities that each alias entity reference points to. For a given ini-tial entity reference, the identity propagation computes a set of
entityreferencesthatpointtothesameentityastheinitialentity
reference;werefertothissetas referenceset.Theideaofidentity
propagation extends the idea of the taint propagation. The identity
taints are generated at each initial entity reference. Any entity ref-
erencebeingtaintedpointstothesameentityastheinitialentity
reference of the taint.
Table2informallypresentstheflowfunctionsusedintheidentity
propagation algorithm. A flow function of a statement maps the
set of dataflow facts inthat hold before the statement to the set of
dataflow facts outthat hold after the statement. Here a dataflow
fact is the reference set of identities. In identity propagation, the
flowfunctionmaps Iin(i.e.,referencesetbeforethestatement)to
Iout(i.e.,reference set after the statement). After the reference set
has been calculated for each identity, EnMobile iterates throughall identities and merges the reference sets if two identities areidentical (i.e., two identities with the same identifier value and
same type).
In the TrickMeexample, nin Figure 1a and r,brin Figure 1c are
aliasentityreferences.Theidentitytaint CON_1isgeneratedfrom
urlandpropagatedto nbyapplying i/circlecopyrt1.For rand br,theidentity
File_2first propagates from Line 3 in Figure 1b to variable file
on Line 1 in Figure 1c by applying iv/circlecopyrt. Then the identity further
propagates to rand brby applying i/circlecopyrt. Note that identity File_3
also propagates (Line 5 in Figure 1b) to file,r, and br. However,
becauseouranalysisiscontext-sensitive,thelaterinformation-flowanalysisisabletotellthatthevariable
commandonLine3inFigure1b
1URLis used to initialize a new HttpURLConnection object in the implementation
ofHttpURLConnectionImpl .
389
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:44 UTC from IEEE Xplore.  Restrictions apply. Table 2: Identity propagation logic
Statement Type Format Flow Functions Propagation Description
Entity Initialization x=new(ainit ,a0, ... ,an),n∈N i/circlecopyrtIouts=Iin∪x,ainit∈IinIndicative parameter →Left-hand side (LHS)
Assign x=y ii/circlecopyrtIouts=Iin∪x,y∈Iin Right-hand side (RHS) →LHS
Identity Setter x.set(y) iii/circlecopyrtIouts=Iin∪x,y∈Iin Tainted parameter →Caller object (e.g., y→x)
Call c.m(a0, ... ,an),n∈N iv/circlecopyrtIouts=Iin∪{a/prime
i},∀ai∈IinCaller parameter →Callee (Context switching)
Return returny;x=c.m(a0, ... ,an),n∈Nv/circlecopyrtIouts=Iin∪x,y∈Iin Returned object →LHS
istaintedbytheinformationfrom File_2,andvariable axis[]on
Line 5 in Figure 1b is tainted by the information from File_3.
We perform two customizations in our information flow anal-
ysis.First,thesourcesofouridentitypropagationarebasedona
certaintypeofvariables(i.e., certainprimitivetypeorstringtype
ofvariablesininitializationmethods)insteadofcertainmethods
(i.e.,source methods). So in addition to method matching, identity
generation requires an additional checking on method parameters.
Second,theidentitypropagationisfield-insensitivethroughcertain
methods (e.g., initialization methods, setter methods). For example,
in an identity setter method, an identity taint propagates from the
method parameter directly to the receiver object rather than to
the class field that is assigned by the taints in the setter method.
To address such difference, we feed predefined knowledge (e.g.,
initializationmethodsandparametersofentities)tohelpEnMobile
performidentitypropagationaccordingtothehigh-levelsemantics.
5.2 Augmenting with Provenance Information
We omit the description of extracting flow facts through entity
references given that this process is a standard information-flow
analysis.Inthissection,weillustratehowweaugmenttheextracted
flow facts with provenance information in two steps.
Classifying the type of information flows. In this step, we
classify the type of flows based on the three types of data flows de-
fined in Section 4. To differentiate the type of data flows, EnMobile
needstotrackwhichparameterofthesinkmethodistaintedinthe
computation. EnMobile first performs traditional information flow
analysis and takes the computed flows and sink variables as input,
andchecksthemwiththepredefinedmethodsignaturestodeter-
minewhethertheinformationflowis transmit, config,or initiate.
EnMobile takes lists of method signatures that contain the infor-
mation of transmit, config, and initiate parameters in the methods.
Foreachinformationflow,EnMobilederivestheflowtypebased
onthesinkvariablethattheinformationflowsinto.Forexample,
in theSmsManager.sendTextMessage method, the first parameter
(destinationAddress) indicates that the flow is a config flow, and
the third parameter (text) indicates that the flow is a transmit flow.
Computingcontrol-flowpredicates. Toidentifyevents vtriддer
thatcantrigger TargetEntity etarдet,wefirst locatethesecurity-
sensitive method called by references of etarдet. Each security-
sensitive method corresponds to an action of the entity (e.g., SEND
forsendTextMessage ). Then, we analyze the call path’s entrypoints
that lead to the method calls. The entrypoints are the top nodes in
the call graph of the app. EnMobile follows the inter-componentcommunications to link the
etarдet’s method call to the entry-
points, and the events vtriддercan be further inferred from the
entrypoints.To compute control dependencies among entities, EnMobile
tracks information flows from entities to conditional statements
through inter-procedure control-flow graphs. The value of a condi-
tional statement decides which program branch to take in runtime
executions, and thus decides invocations of methods on one of the
program branches. For a given method Minvoked by an entity
etarдet(Mcorresponds to Action A), EnMobile computes the in-
formation flows from all entities to conditional statements (that
controltheinvocationsof M).Ifaninformationflowfromanentity
econtroltotheconditionalstatementsexists,then econtrolcontrols
theAction Aofetarдet(i.e., Control ( econtrol ,etarдet ,A )holds).
5.3 Matching Against Signatures
To perform malware detection, EnMobile compares the set of flow
factsP(M)extracted from an app M, using the aforementioned
analysis,againstapre-compiledlibraryofsignaturesofknownmal-
ware.Specifically,foramalwaresignature S(asasetofpredicates)
fromthemalwarelibrary,thecomparisoncheckswhetherthepred-icates in
Sare a subset of the flow facts (also as a set of predicates)
inP(M),modulorenamingofvariables.Intheprocessofsignature
matching, EnMobile enumerates all feasible combinations of the
segmentedflowstomatchtheend-to-endcharacterizationsinthe
signatures. EnMobile determines the feasibility of combinations of
segmentedflowsbyincorporatingtheflow-sensitiveinformation
(i.e.,takingintoaccounttheorderofthestatements)intheextracted
flow facts. Please refer to our project website [ 19] for more details.
6 EVALUATION
We evaluate EnMobile in characterizing malware behaviors, by
investigating the following research questions:
RQ1:How effective is EnMobile in characterizing malicious be-
haviors in existing malware?
RQ2:Howdoentity-identityanalysisandricherdataflowpredi-
cates in entity-based characterization contribute to the ef-
fectiveness of malicious-behavior identification?
RQ3:What is the effectiveness of EnMobile compared to other
state-of-the-art approaches of malware detection?
6.1 Evaluation Setup
EvaluationSubjects .Oursubjectsetconsistsofamalwaredataset
and a benign app dataset. Our malware dataset starts with all mal-
warefromtheGenome[ 52]andDrebin[ 8]malwaredatasets,which
arecommonlyusedinmalwaredetectionresearch[ 11,21,25,26,
29,50]. The Malware Genome dataset comprises 1 ,260 malware
samples organized into 49 malware families. The Drebin datasetEnMobile: Entity-based Characterization and Analysis of Mobile Malware ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
390
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:44 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Wei Yang, Mukul R. Prasad, and Tao Xie
Table 3: Categorization of Malware by EnMobile
Malware Family #TEnMob(%) Base1 (%) Base2 (%) Appo(%)
FN FP FN FP FN FP FN FP
ADRD 91 0.0 0.0 2.3 0.0 0.0 0.0 36.40.0
AnserverBot 184 0.6 0.1 2.2 0.0 0.6 0.4 0.0 0.0
BaseBridege 331 10.4 0.233.40.2 10.40.5 50.00.1
Boxer 27 0.0 0.2 7.4 0.2 0.0 0.2 25.90.4
DroidDream 97 0.0 0.1 4.4 0.1 0.0 0.2 3.1 8.5
DroidDreamL 46 1.1 0.0 1.1 0.0 1.1 0.0 0.0 0.0
DroidKungFu 668 1.8 0.0 5.1 0.0 1.6 0.7 8.1 0.0
ExploitLotoor 7010.40.117.90.1 10.4 0.4 85.01.9
FakeDoc 1322.3 0.1 11.00.1 2.4 0.2 6.3 0.3
FakeInstaller 925 1.8 0.0 5.8 0.0 1.8 0.1 68.40.1
FakeRun 61 0.0 0.1 4.9 0.1 0.0 0.3 11.10.0
Gappusin 58 8.6 0.0 12.00.0 8.6 0.1 58.60.0
Geinimi 94 0.0 0.2 4.4 0.2 0.0 0.9 0.0 0.0
GingerMaster 342 3.8 0.1 7.1 0.1 3.8 0.2 70.40.0
GoldDream 70 0.0 0.0 1.6 0.0 0.0 0.0 3.2 0.0
Hamob 28 4.5 0.0 18.10.0 4.5 0.0 3.7 5.7
Iconosys 1520.6 0.0 2.6 0.0 0.6 0.2 69.70.0
Imlog 43 0.0 0.0 0.0 0.0 0.0 0.0 76.7 29.1
Jifake 29 0.0 0.0 3.4 0.0 0.0 0.0 50.00.5
KMin 1483.7 0.1 5.9 0.1 3.7 0.1 34.7 19.1
MobileTx 69 0.0 0.1 8.8 0.1 0.0 0.6 31.90.0
Opfake 6130.8 0.0 5.6 0.0 0.8 0.1 33.7 19.2
Pjapps 58 0.0 0.0 0.0 0.0 0.0 0.2 0.0 0.0
Plankton 6252.1 0.0 3.7 0.0 2.1 0.2 32.13.0
SendPay 59 6.9 0.0 8.6 0.0 6.9 0.0 22.47.9
SMSreg 41 0.0 0.0 9.8 0.0 0.0 0.3 16.2 44.6
YZHC 37 0.0 0.0 3.6 0.0 0.0 0.1 0.0 5.2
Average 188.82.2 0.1 7.1 0.1 2.2 0.2 29.5 5.4
#T = Total number of apps, EnMob = EnMobile, Appo = Apposcopy
FN = False negative rate, Base1 = EnMobile without entity identity
FP = False positive rate, Base2 = EnMobile without data-flow types
comprises5 ,560malwaresamplesorganizedinto178malwarefami-
lies.Weremovefamiliescontainingfewerthan20malwaresamples
as well as malware samples duplicated across Genome and Drebin,
yielding27familieswith5 ,098malwaresamplesintotal.Tocollect
benignapps,wedownloadedatotalof2 ,700apps(100randomly
selected apps for each of the 27 categories) from Google Play, as of
December 2016. We implement EnMobile using several third-party
staticanalysisframeworks,includingSoot[ 40],FlowDroid[ 9],and
AppContext [ 50]. To isolate and remove the effects of potential
limitationsoftheseframeworksonourconclusions,wefurtherpre-
runEnMobileonthecompletesubjectsetandfilteroutanyapps
that cause any of the third-party frameworks to throw exceptions
or time out. This step gives us a final analyzable dataset of 4897
malware samples and 1717 benign apps.
Giventhelargenumberofunanalyzablebenignapps(999),we
reassessthedistributionofourfinalbenignappdataset.Wefindthatitretains52to77appsineachGooglePlaycategory(originally100);
the size range (42KB to 51 ,192KB) of a final app’s file and the sizerange (16KB to 8 ,829KB) of a final app’s dex file (bytecode without
resource files) remain the same compared to the original dataset.
This distribution suggests that our benign app dataset remains
broadly representative of real benign apps even after removing
unanalyzable apps. All runs of EnMobile have been performed on
a desktop with 4 Intel Xeon 3 .2 GHz E3-1225 processors and 16 GB
of memory with a timeout of 20 minutes per app (the same default
timeout set by Apposcopy [21]).
MalwareSignatureLibrary. Forthepurposeoftheevaluation,
wedevelopalibraryofmalwaresignatures,oneperfamily,foreach
ofthe27malwarefamilies(Table3)inourdataset.Eachmalware
signature characterizes the malware samples of a given family,
usingthesignaturelanguageproposedinSection4.1.Thesignatureisconstructedbyexamining10randomlyselectedmalwaresamples
fromthefamilyand100randomlyselectedbenignapps.Specifically,
we first collect the security-sensitive behaviors (i.e., data-flow and
control-flowfacts)ofeachoftheapps.Fromthesebehaviors,the
behaviors common to all malware samples, but absent from the
benignapps,areidentifiedandexpressedinthesignaturelanguage.
Thesignature-creationprocedureentailsfewerthansixman-hours
ofeffortpernewmalwaresignature,asaone-timeeffortforeach
malware family.
6.2 RQ1: Entity-Based Characterization
To evaluate the effectiveness of EnMobile’s entity-based characteri-
zation on our malware dataset, we run EnMobile on all malware
samples and benign apps, except the ones used to develop the mal-
ware signatures. We evaluate the runs in terms of two metrics.
Forthefirstevaluationmetric,werecordwhichmalwarefam-
ily signatures (if any) each app matches2. Ideally, each malware
sampleshouldmatchitsfamily’ssignatureandnoothersignatures.
Note that this classification problem is qualitatively harder than
simply classifying a given app as malware or benign, and is thetrue test of the accuracy of a signature-based approach, such as
EnMobile. Column “EnMobile” in Table 3 shows the results of this
evaluation metric. Here, for a given malware family, false negative
rate (FN) refers to the percentage of malware samples (out of all
samples in the malware family) that are notmatched by EnMobile
tothatfamily’ssignature.Conversely,falsepositive(FP)refersto
thepercentageofapps(outofallbenignappsandmalwareof other
families) that are incorrectly matched by EnMobile to this family’s
signature.AsshowninTable3,EnMobilecaneffectivelyclassify
malware instances into their appropriate families with on average
2.2% false negatives and around 0.1% false positives. For most mal-
warefamilies,EnMobilehasunder5%falsenegativesand0.1%false
positives.
ThesecondevaluationmetricassessestheeffectivenessofEn-
Mobileandotherapproaches,inbroadlydifferentiatingmalware
from benign apps, i.e.,classifying malware as malware (vs. benign)
andbenignappsassuch(vs.malware).Suchmetricisincontrast
to the family-based classification in Table 3. As shown in columns
“EnMobile” in Table 4, here too EnMobile performs quite well, cor-
rectlyclassifyingover97%ofthemalwareand99%ofthebenign
2While theoretically possible, no apps ended up matching multiple signatures in our
current evaluation.
391
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:44 UTC from IEEE Xplore.  Restrictions apply. Table 4: Differentiating Malware and Benign Apps
Apps#Total #Analyzable #Analyzable EnMobile Base1 Base2 Appo
Apps. by EnMobile by Apposcopy Malicious Benign Malicious Benign Malicious Benign Malicious Benign
Benign 2716 1717 1592 1.0% 99.0% 0.9% 99.1% 4.8% 95.2% 59.1% 40.9%
Malware 5098 4897 4062 97.2% 2.8% 92.2% 7.8% 97.3% 2.7% 67.6% 32.4%
apps. Further, on manually inspecting the 1% (i.e., 17 out 1717) be-
nign apps being classified as malware, we find that 8 apps actually
possess malicious or highly suspicious behaviors. An example app
iscom.genericsnippet.funnyecards , which has now been removed
from Google Play. This example demonstrates EnMobile’s capabil-
ity to detect unknown suspicious, even potentially malicious, apps.
Theother9benignappsmisclassifiedbyEnMobilecontainsome
interestingsuspicious-lookingbehaviors;forexample,anappturns
a deprecated smartphone into a baby camera, sending SMS to par-
entswhenever thephone signalchanges.In futurework,we plan
touseappdescriptionstocheckwhethersuchsuspiciousbehaviors
are in fact desirable.
6.3 RQ2: Entity Identities and Flow Predicates
TwoofthekeycontributionsofEnMobileare(1)itsentity-based
characterization,builtontopofentity-identityanalysis(Section5.1),
and (2) the rich set of data-flow predicates (Section 4.1) to identify
malicious intents. In this research question, we assess the effec-
tivenessofthesespecificfeaturesbycomparingEnMobileagainst
twobaselineversions:EnMobilewithoutentity-identityanalysis
(Base1),andEnMobilewithoutrichdata-flowtypes(Base2).Note
thatthecoreinformationflowanalysisin bothBase1andBase2,and
indeedinEnMobileitself,isatleastaspreciseasthetypeand/orAPI-basedinformationflowanalysisinpreviouswork[
9,11,21,29,47],
albeit implemented in our own framework.
EnMobilewithoutentityidentities( Base1).TorealizeBase1,
weturnofftheentity-identityanalysisinEnMobile.Specifically,the
analysisretainsthetypeoftheentities,butignorestheidentitiesoftheentities inthe flows.Note thatwestill needto perform identity
propagation to some extent to infer the entity type for some entity
references.Indeed,withoutentityidentities,stitchingsegmented
information flows cannot be performed either.
For fair comparison, we also modify EnMobile’s malware signa-
ture library to make it suitable for Base1. Specifically, in each of
the signatures, we remove entity identities but retain entity types.
Further, we study malware reports from major anti-virus vendors
as well as flowsextracted by EnMobile to identify(segmented) in-
formationflowscommontoamajorityofthesamplesinamalwarefamily. We replace the original data-flow predicates, representing a
connected flow in the signature, with a set of predicates represent-
ing each of the segmented flows. When no flows match a majority
ofthemalwaresamples,weuseflowswiththebest(highest)match.
Table3(evaluatingcharacterizationofmalwarebyfamily)and
Table 4 (evaluating basic malware detection of malware vs. benign)
show a comparison of EnMobile (column EnMobile in both tables)
toBase1(columnBase1).TheresultsshowthatBase1, i.e.,EnMobile
withoutentityidentities,producesmorefalsenegativesformost
malwarefamilies(7 .1%onaveragevs.2 .2%forEnMobile)aswell
as in overall malware detection (7 .8% vs. 2.8% in Table 4).Onemainreasonisthatdifferentsamplesinamalwarefamily
typically have different implementations of the same end-to-end
flow,throughvariedsetsofsegmentedflows.Withoutthebenefit
of the entity-identity analysis, and the flow stitching that it en-
ables,nosinglesignaturecancharacterizeallsamplesofamalware
family,evenwith the preceding custom retrofitting of the signa-
ture library for Base1. These results demonstrate the benefit of our
entity-identity analysis for accurate malware characterization.
EnMobile without types of data flows (Base2 ).To realize
Base2,wesimplyrepresentthethreetypesofdataflowsasasingle
basic information flow, in both the signatures and in the extracted
flowfactsforeachapp.Wethenperformsignaturematchingbased
on the extracted flow facts and signatures.
AsshowninTables3and4,Base2producesmorefalsepositives
forsomemalwarefamiliesandincorrectlymarksmorebenignapps
as malware than EnMobile (4 .8% vs. just 1% in Table 4). The reason
is that the signatures lacking our provenance information incur
wrongmatchingofdataflows.Forexample,theanalysismaymatch
aTransmitflow(e.g., aflowsendinganSMS)withapossibleConfig
flow (e.g., a flow specifying the SMS recipient’s number).
6.4 RQ3: Comparison with Related Approaches
WecompareEnMobilewithfourrelatedstate-of-the-artapproaches:
onesignature-basedapproach(Apposcopy[ 21])andthreelearning-
basedapproaches(MUDFLOW[ 11],AppContext[ 50],andDrebin[ 8]).
Comparisonwithasignature-basedapproach(Apposcopy).
Apposcopyleveragesalistofmanually-specifiedsignatures(e.g.,
Figure 2) to match malware samples. Because Apposcopy provides
signatures for only several malware families in our dataset, we
use the following methodology to generate the best possible Ap-
poscopysignaturesuniformlyfor allmalwarefamilies.Wegenerate
Apposcopy signatures for each family by two means: (i) we follow
thesameprocedureasincreatingEnMobilesignaturestomanually
createanApposcopysignaturebasedon10malwaresamplesand
100 benign samples; (ii) we run Astroid [ 22], an automatic signa-
turegenerator forApposcopy, 10timesfor eachfamily. Eachtime
Astroid randomly selects five samples from the malware family
andproducesasignature.Wepickthebestsignature,intermsof
the least total number of FP and FN, from among the preceding 11
signatures,toreport theresults.AllrunsofApposcopy areonthe
same machine as EnMobile with the same timeout threshold per
app,i.e.,20 minutes.
Thelasttwocolumns(“Appo”)ofTables3and4reportthere-
sults of Apposcopy in detecting malware. As shown in Table 3,
ApposcopyperformsmuchworsethanEnMobileformostofthe
malware families, especially the malware families whose most mal-
ware samples are from the Drebin malware database. This degrada-
tioninperformanceislikelyduetotheevolutionofmalware.For
example,inthe Kminmalwarefamily,thefunctionalityofareceiverEnMobile: Entity-based Characterization and Analysis of Mobile Malware ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
392
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:44 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Wei Yang, Mukul R. Prasad, and Tao Xie
com.km.HoldMessage in some malware samples is replaced by a ser-
vice com.km.charge.CycleServic in some other malware samples.
This kind of evolution changes the type of the Android component
hosting the malicious behavior. Such changes can easily evade Ap-
poscopy’sdetectionbecauseApposcopy’ssignaturesheavilyrely
ontheinternalcomponentstructure(includingacomponent’stype)
to characterize malware. However, EnMobile does not suffer from
the same issue because such structural changes do not affect the
end-to-end communications among entities.
Comparisonwithlearning-basedapproaches. Wealsocom-
pare EnMobile with three state-of-the-art learning-based detection
approaches: AppContext [50], Drebin [8], and MUDFLOW [11].
Both AppContext and Drebin require a large number of mal-
waresamplesastrainingdatatotrainamachinelearningmodel.
However, many malware families have very few known samples –
only 42% of malware families have more than 5 samples [ 22]. So,
inadditiontoevaluatingAppContextandDrebinfollowingtradi-
tional ten-fold cross-validations ( O.in Table 5), we also evaluate
their effectiveness on a smaller training set ( S.in Table 5) by fol-
lowing the evaluation methodology used in Astroid [ 22]. As per
this methodology, instead of training malware from all families as
a whole, we perform the training and testing family by family. For
eachmalwarefamily,thetrainingsetconsists10randomlyselected
samples from the family, all samples from other malware families,
and a similar number of benign apps as in the original training set.
The testing set consists of the rest of samples from the malware
familyandtherestofbenignapps.Wereporttheaverageresults
of all families in Table 5.
MUDFLOW detects malware by identifying abnormal informa-
tion flows for each category of sensitive sources. To produce the
input that MUDFLOW accepts, we use FlowDroid [ 9] to extract
information flows from all of our subjects. To compute the final
result,wefeedtoMUDFLOWtheextractedinformationflows,with
sources and sinks of these information flows categorized using
SuSi [36], as well as the permission list of each app.
Table5showstheeffectivenessoftheexistingapproachesand
EnMobile. As shown in the table, EnMobile outperforms all the
existingapproaches.NotethatalthoughAppContextandDrebin
reach similar effectiveness as EnMobile when training with the
original dataset(i.e., 90% trainingdata and10% testingdata), their
effectivenessdegradesalotwhenusingasmallernumberoftraining
samples. This result is especially impressive for EnMobile, consid-
ering that the difference between the smaller and original training
datasets comes from much reduced malware samples in a single
malwarefamily.Thisresultisindicativeoftheoverfittingnature
of these learning-based approaches.It suggests that EnMobile can
be a great substitute for learning-based approaches, in malware
detection, when security analysts have access to only a small num-
berofmalwaresamples.EnMobilealsooutperformsMUDFLOW,
exhibiting much higher recall. The advantage of EnMobile over
MUDFLOWliesindetectingthosemalwaresamplesthathaveC&C
behaviors or behaviors of dynamic code loading (e.g., BaseBridge).
Becauseofthedynamicnatureofsuchbehaviors(i.e., theloaded
codeisunknownbeforetheexecution),traditionalinformation-flow
analysis often fails to detect these behaviors. EnMobile’s entity-
based characterization allows it to accurately identify the control-
lingentity ofthedownloadingbehavior andtheC&C nature oftheTable 5: Identificationof malware by variationsof AppCon-
text, MUDFLOW, Drebin, and Apposcopy
AppContext Drebin
MUDFLOW Apposcopy EnMobile
O. S. O. S.
P.(%)95.42 76.52 98.47 92.80 97.61 74.48 99.64
R.(%)97.65 95.15 97.48 89.21 53.46 67.60 97.24
P. = Precision, R. = Recall, O.= Result with Original Training Samples
S.= Result with Smaller Number of Training Samples
malware. Thus, EnMobile can outperform the existing approaches
byaccuratelyidentifyingthesemalwaresampleswithoutrequiring
detailed knowledge of the dynamically loaded code.
7 DISCUSSION
Limitations. Intentional obfuscations of entity identities may sab-
otageouranalysis.Forexample,creatinganaliasentitybyusing
symboliclinks(e.g., Ink,Shortcut),orusingdifferentcopiesofthe
sameencryptionschemetoencryptentityidentities.Inthesecases,
the malware may evade detection of EnMobile. However, since
these camouflage attempts have clear patterns and are likely to be
suspicious, other techniques such as dynamic analysis [ 37] can be
usedtocomplementEnMobile.Attackerscanalsohidemalicious
behaviors matched by our signatures into dynamic loaded code to
evade EnMobile’sdetection. However, securityanalysts canlever-
ageEnMobiletofurthercharacterizethebehaviorsofdynamiccode
loading to detect the evolved malware. In our evaluation, signa-
tures characterizing dynamic code loading can successfully match
malware of corresponding families (e.g., basebridge).
Threats to Validity. The tuning of malware signatures could
affecttheresultsoftheevaluation.TopreventEnMobile’ssignatures
from being overfitting for our subjects, when constructing the
malwaresignatures,westrictlyconstrainourselvesinanalyzingno
more than 10 malware samples per family. Also, EnMobile is based
onbehavioralsignaturesratherthansyntacticstructuresusedin
muchofpreviouswork[ 8,21,44],anddoingsofurthermitigates
against overfitting.
8 CONCLUSION
In this paper, we have presented EnMobile, a novel approach for
accurately characterizing mobile apps’ interactions with entities.
WehavedemonstratedapracticalapplicationofEnMobileforde-
tectingmalware.Ourevaluationresultssuggesttheeffectivenessof
EnMobile in characterizing differential characteristics of malware
andbenignapps,androbustnessofEnMobile’sspecification-driven
signatures (i.e., based on intrinsic definitions of malware) over
implementation-driven ones (i.e., based on features of low-level
programstructures).WeenvisionanumberofapplicationsofEn-
Mobile:withincreasingusesofIoTapps,EnMobilecanbeextended
for characterizing broader interactions between the physical world
and apps; for human-assisted app auditing, entity-based charac-terization can enhance security analysts’ understanding of app
behaviors.
393
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:44 UTC from IEEE Xplore.  Restrictions apply. REFERENCES
[1]Android.Answerbot. https://www.symantec.com/security_
response/writeup.jsp?docid=2011-100711-2129-99.
[2]Android.Geinimi. https://www.symantec.com/security_
response/writeup.jsp?docid=2011-010111-5403-99.
[3]In review: 2016’s mobile threat landscape brings diversity, scale, and
scope. http://blog.trendmicro.com/trendlabs-security-intelligence/2016-mobile-
threat-landscape/.
[4]Microsoft malware protection center. http://www.microsoft.com/security/portal
/threat/Threats.aspx.
[5]Security alert: New BeanBot SMS Trojan discovered.
http://www.cs.ncsu.edu/faculty/jiang/BeanBot/.
[6]Y.Aafer,W.Du,andH.Yin. DroidAPIMiner:MiningAPI-levelfeaturesforrobust
malware detection in Android. In Proc. SecureComm, pages 86–103, 2013.
[7] Antiy Labs. http://www.antiy.net/.
[8]D.Arp,M.Spreitzenbarth,M.Hubner,H.Gascon,andK.Rieck. DREBIN:Effective
and explainable detection of Android malware in your pocket. In Proc. NDSS,
2014.
[9]S.Arzt,S.Rasthofer,C.Fritz,E.Bodden,A.Bartel,J.Klein,Y.LeTraon,D.Octeau,
and P. McDaniel. FlowDroid: Precise context, flow, field, object-sensitive andlifecycle-aware taint analysis for Android apps. In Proc. PLDI, pages 259–269,
2014.
[10]K. W. Y. Au, Y. F. Zhou, Z. Huang, and D. Lie. PScout: Analyzing the Android
permission specification. In Proc. CCS, pages 217–228, 2012.
[11]V.Avdiienko,K.Kuznetsov,A.Gorla,A.Zeller,S.Arzt,S.Rasthofer,andE.Bodden.
Mining Apps for abnormal usage of sensitive data. In Proc. ICSE, pages 426–436,
2015.
[12]P.Barros, R.Just,S.Millstein,P. Vines,W.Dietl, M.d’Amorim,andM. D.Ernst.
Static analysis of implicit control flow: Resolving Java reflection and Android
intents. In Proc. ASE, pages 669–679, 2015.
[13]O.Bastani,S.Anand,andA.Aiken. Interactivelyverifyingabsenceofexplicit
information flows in Android apps. In Proc. OOPSLA, pages 299–315, 2015.
[14]E. Bodden. Inter-procedural data-flow analysis with IFDS/IDE and Soot. In Proc.
SOAP, pages 3–8, 2012.
[15]Y.Cao,Y.Fratantonio,A.Bianchi,M.Egele,C.Kruegel,G.Vigna,andY.Chen.
EdgeMiner: Automatically detecting implicit control flow transitions through
the Android framework. In Proc. NDSS, 2015.
[16]K. Chen, P. Wang, Y. Lee, X. Wang, N. Zhang, H. Huang, W. Zou, and P. Liu.
Finding unknown malice in 10 seconds: Mass vetting for new threats at the
Google-play scale. In Proc. USENIX Security, pages 659–674, 2015.
[17]J.Crussell,R.Stevens,andH.Chen. MAdFraud:InvestigatingadfraudinAndroid
applications. In Proc. Mobisys, pages 123–134, 2014.
[18]K. O. Elish, X. Shu, D. D. Yao, B. G. Ryder, and X. Jiang. Profiling user-trigger
dependenceforAndroidmalwaredetection. Computers&Security,pages255–273,
2015.
[19] EnMobile. https://sites.google.com/site/entitymobile/.
[20]M.D.Ernst,R.Just,S.Millstein,W.Dietl,S.Pernsteiner,F.Roesner,K.Koscher,
P.Barros,R.Bhoraskar,S.Han,P.Vines,andE.X.Wu. Collaborativeverificationofinformationflowforahigh-assuranceappstore. In Proc.CCS,pages1092–1104,
2014.
[21]Y.Feng,S.Anand,I.Dillig,andA.Aiken. Apposcopy:Semantics-baseddetection
of Android malware through static analysis. In Proc. FSE, pages 576–587, 2014.
[22]Y.Feng,O.Bastani,R.Martins,I.Dillig,andS.Anand. Automatedsynthesisof
semantic malware signatures using maximum satisfiability. In Proc. NDSS, 2017.
[23]Y. Fratantonio, A. Bianchi, W. Robertson, E. Kirda, C. Kruegel, and G. Vigna.
TriggerScope:TowardsdetectinglogicbombsinAndroidapplications. In Proc.
Security and Privacy (SP), pages 377–396, 2016.
[24]M.I.Gordon,D.Kim,J.Perkins,L.Gilham,N.Nguyen,andM.Rinard.Information-
flow analysis of Android applications in DroidSafe. In Proc. NDSS, 2015.
[25]A. Gorla, I. Tavecchia, F. Gross, and A. Zeller. Checking app behavior against
app descriptions. In Proc. ICSE, pages 1025–1035, 2014.
[26]J.Huang,X.Zhang,L.Tan,P.Wang,andB.Liang. AsDroid:Detectingstealthy
behaviors in Android applications by user interface and program behavior con-
tradiction. In Proc. ICSE, pages 1036–1046, 2014.[27]P. Lam, E. Bodden, O. Lhoták, and L. Hendren. The Soot framework for Java
program analysis: a retrospective. In Proc. CETUS, 2011.
[28]D. Li, Y. Lyu, M. Wan, and W. G. J. Halfond. String analysis for Java and Android
applications. In Proc. FSE, pages 661–672, 2015.
[29]L.Li,A.Bartel,T.F.D.A.Bissyande,J.Klein,Y.LeTraon,S.Arzt,S.Rasthofer,
E.Bodden,D.Octeau,andP.McDaniel. IccTa:Detectinginter-componentprivacy
leaks in Android apps. In Proc. ICSE, pages 280–291, 2015.
[30]K. Lu, Z. Li, V. P. Kemerlis, Z. Wu, L. Lu, C. Zheng, Z. Qian, W. Lee, and G. Jiang.
Checking more and alerting less: Detecting privacy leakages via enhanced data-
flow analysis and peer voting. In Proc. NDSS, 2015.
[31]L.Lu,Z.Li,Z.Wu,W.Lee,andG.Jiang. Chex:staticallyvettingAndroidapps
for component hijacking vulnerabilities. In Proc. CCS, pages 229–240, 2012.
[32] Virus Information - McAfee. http://home.mcafee.com/virusinfo/.
[33]D. Octeau, D. Luchaup, M. Dering, S. Jha, and P. McDaniel. Composite constant
propagation: Application to Android inter-component communication analysis.
InProc. ICSE, pages 77–88, 2015.
[34]D. Octeau, P. McDaniel, S. Jha, A. Bartel, E. Bodden, J. Klein, and Y. L. Traon.
Effective inter-component communication mapping in Android: An essential
step towards holistic security analysis. In Proc. USENIX Security, pages 543–558,
2013.
[35]R.Pandita,X.Xiao,W.Yang,W.Enck,andT.Xie. WHYPER:towardsautomating
risk assessment of mobile applications. In Proc. USENIX Security, pages 527–542,
2013.
[36]S.Rasthofer,S.Arzt,andE.Bodden. Amachine-learningapproachforclassifying
and categorizing Android sources and sinks. In Proc. NDSS, 2014.
[37]S.Rasthofer, S.Arzt, M.Miltenberger,and E.Bodden. Harvesting runtimevalues
in Android applications that feature anti-analysis techniques. In Proc. NDSS,
2016.
[38]J. Rubin, M. I. Gordon, N. Nguyen, and M. Rinard. Covert communication in
mobile applications. In Proc. ASE, pages 647–657, 2015.
[39]D.L.Shinder.Theprosandconsofbehavioralbased,signaturebasedandwhitelist
basedsecurity,2015. http://www.windowsecurity.com/articles-tutorials/misc_
network_security/Pros-Cons-Behavioral-Signature-Whitelist-Security.html.
[40]Soot:AframeworkforanalyzingandtransformingJavaandAndroidapplications.
http://sable.github.io/soot/.
[41]ThreatAnalysis-Sophos. https://www.sophos.com/en-us/threat-center/threat-
analyses.aspx.
[42] Security Threat - Symantec. https://www.symantec.com/security_response/.[43]
Threat Encyclopedia - Trend Micro. http://www.trendmicro.com/vinfo/us/
threat-encyclopedia/.
[44]VirusTotal - free online virus, malware and URL scanner.
https://www.virustotal.com/.
[45]A. Walenstein, M. Venable, M. Hayes, C. Thompson, and A. Lakhotia. Exploiting
similaritybetweenvariantstodefeatmalware. In BlackHatDCConference,March
2007.
[46]F. Wei, Y. Li, S. Roy, X. Ou, and W. Zhou. Deep ground truth analysis of current
Android malware. In Proc. DIMVA, pages 252–276, 2017.
[47]F. Wei,S. Roy,X. Ou, etal. Amandroid: A preciseand generalinter-component
data flow analysis framework for security vetting of Android apps. In Proc. CCS,
pages 1329–1341, 2014.
[48]S. Yang, D. Yan, H. Wu, Y. Wang, and A. Rountev. Static control-flow analysis of
user-driven callbacks in Android applications. In Proc. ICSE, pages 89–99, 2015.
[49]S. Yang, H. Zhang, H. Wu, Y. Wang, D. Yan, and A. Rountev. Static window
transition graphs for Android. In Proc. ASE, pages 658–668, 2015.
[50]W.Yang,X.Xiao,B.Andow,S.Li,T.Xie,andW.Enck.AppContext:Differentiating
maliciousandbenignmobileappbehaviorsusingcontext. In Proc.ICSE,pages
303–313, 2015.
[51]M. Zhang, Y. Duan, H. Yin, and Z. Zhao. Semantics-aware Android malware
classificationusingweightedcontextualAPIdependencygraphs. In Proc.CCS,
pages 1105–1116, 2014.
[52]Y. Zhou and X. Jiang. Dissecting Android malware: Characterization and evolu-
tion. InProc. Security and Privacy (SP), pages 95–109, 2012.EnMobile: Entity-based Characterization and Analysis of Mobile Malware ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
394
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:44 UTC from IEEE Xplore.  Restrictions apply. 