Static Control-Flow Analysis of User-Driven
Callbacks in Android Applications
Shengqian Yang, Dacong Yan, Haowei Wu, Yan Wang, and Atanas Rountev
Ohio State University
Email:fyangs,yan,wuhaow,wang10,rountev g@cse.ohio-state.edu
Abstract ‚ÄîAndroid software presents many challenges for
static program analysis. In this work we focus on the fundamental
problem of static control-Ô¨Çow analysis. Traditional analyses
cannot be directly applied to Android because the applications
are framework-based and event-driven. We consider user-event-
driven components and the related sequences of callbacks from
the Android framework to the application code, both for lifecycle
callbacks and for event handler callbacks.
We propose a program representation that captures such
callback sequences. This representation is built using context-
sensitive static analysis of callback methods. The analysis per-
forms graph reachability by traversing context-compatible in-
terprocedural control-Ô¨Çow paths and identifying statements that
may trigger callbacks, as well as paths that avoid such statements.
We also develop a client analysis that builds a static model
of the application‚Äôs GUI. Experimental evaluation shows that
this context-sensitive approach leads to substantial precision
improvements, while having practical cost.
I. I NTRODUCTION
In recent years the growth in the number of computing
devices has been driven primarily by smartphones and tablets.
For such devices, Android is the dominating platform. A recent
report estimates that more than 1.3 billion Android devices will
be shipped in 2015, and this number will be larger than the
combined number of all shipped Windows/iOS/MacOS PCs,
notebooks, tables, and mobile phones [1].
The widespread use of Android software presents numerous
challenges for software engineering researchers. One such
challenge is to establish a solid foundation for software
understanding, checking, and transformations. Static program
analysis is an essential component of such a foundation. In
this work we focus on a fundamental static analysis: control-
Ô¨Çow analysis . Data-Ô¨Çow analysis is based on some control-
Ô¨Çow representation, and our work also has direct implications
for the design of data-Ô¨Çow analyses.
Traditional control-Ô¨Çow analysis cannot be directly applied
to Android applications because they are framework-based and
event-driven. The application code and the Android platform
interact through callbacks : calls from the platform‚Äôs event
processing code to the relevant callback methods deÔ¨Åned in
the application code. A rich variety of callbacks is deÔ¨Åned by
the Android framework model, for events such as component
creation/termination, user actions, device state changes, etc.
We focus our analysis on a key aspect of this control Ô¨Çow:
the lifecycle and interactions of user-event-driven application
components . The Ô¨Årst step of our work is to formulate thiscontrol-Ô¨Çow analysis problem in terms of the traditional con-
cepts of interprocedural control-Ô¨Çow analysis [2], [3], thus
providing a foundation for reasoning about run-time semantics
and its static analysis approximations. In essence, the control-
Ô¨Çow analysis problem can be reduced to modeling of the
possible sequences of callbacks.
Next, we propose a program representation that captures
such callback sequences. This representation, referred to as a
callback control-Ô¨Çow graph (CCFG), together with the notion
ofvalid paths in this graph, is the output of the control-Ô¨Çow
analysis. We then present an algorithm for CCFG construc-
tion. The algorithm considers user-driven components such as
activities, dialogs, and menus, and analyzes the corresponding
lifecycle and event handling callback methods. The analysis of
each callback method (and the code transitively invoked by it)
determines what other callbacks may be triggered next. This
information provides the basis for CCFG construction.
The key technical insight for the design of our algorithm
is that a callback method must be analyzed separately for
different invocation contexts associated with it . For example,
an event handler method could process user events for several
different widgets, and may have a different behavior for each
separate widget. Our context-sensitive analysis employs a form
of graph reachability that traverses context-compatible control-
Ô¨Çow paths and identiÔ¨Åes statements whose execution may
trigger subsequent callbacks, as well as paths that avoid such
statements. Through examples and experimental studies, we
show the importance of this form of context sensitivity.
The proposed analysis can be a component of various
other static analyses (e.g., for software checking [4]‚Äì[17]). We
consider one such client: the automated generation of static
GUI models, which are important for program understanding
and test generation. The CCFG can be easily transformed
into a certain kind of GUI model used in prior work (e.g.,
[18]‚Äì[21]), and possible sequences of user GUI events can be
derived from valid paths in the model.
Using 20 applications, we performed an experimental eval-
uation whose results can be summarized as follows. First,
the analysis cost is suitable for practical use in software
tools. Second, the use of context-sensitive analysis results in
substantial precision improvements. Third, in six case studies,
we compared the produced GUI models against the ‚Äúperfectly-
precise‚Äù manually-constructed solution as well as the solution
from a dynamic analysis tool [22]. This comparison indicates
high analysis precision, with three of the case studies ex-hibiting perfect precision, and the rest providing insights into
potential precision improvements for future work.
Contributions. The contributions of this work are
Formulation of the control-Ô¨Çow analysis problem for
lifecycle and event handling callbacks
DeÔ¨Ånition of the CCFG, a program representation that
encodes the solution to this problem
Algorithm to build the CCFG through context-sensitive
control-Ô¨Çow analysis of callback methods
Technique to build and traverse static GUI models based
on the CCFG
Evaluation on 20 applications, as well as detailed case
studies using six of these applications
The CCFG deÔ¨Ånition and the analysis algorithms are novel
contributions: to the best of our knowledge, this is the Ô¨Årst ef-
fort to perform context-sensitive analysis of Android callback
behavior and to encode the resulting control-Ô¨Çow information.
This is also the Ô¨Årst work to perform fully-static generation
of GUI models for Android. The analysis implementation is
publicly available as part of the G ATOR analysis toolkit [23].
II. C ONTROL -FLOW ANALYSIS FOR ANDROID
Our work targets a fundamental problem: static control-Ô¨Çow
analysis. Since data-Ô¨Çow analysis must model the program‚Äôs
control Ô¨Çow (in addition to the data-Ô¨Çow domain), control-Ô¨Çow
analysis is also a key component of data-Ô¨Çow analysis.
A. Background
The standard program representation for such analysis is
theinterprocedural control-Ô¨Çow graph (ICFG). This graph
combines the control-Ô¨Çow graphs (CFGs) of the program‚Äôs
procedures. Nodes correspond to statements, and intraproce-
dural edges show the control Ô¨Çow inside a procedure. The CFG
for a procedure phas a dedicated start node spand a dedicated
exit nodeep. Each call is represented by two nodes: a call-site
nodeciand a return-site node ri. There is an interprocedural
edgeci!spfrom a call-site node to the start node of the called
procedurep; there is also a corresponding edge ep!ri. An
ICFG path that starts from the entry of the main procedure is
valid if its interprocedural edges are matched (i.e., each riis
matched with the corresponding ci) [2], [3].
The goal of control-Ô¨Çow analysis is to determine the set of
all valid paths. In an actual analysis, some abstractions of such
paths are typically employed. Still, at its essence, control-Ô¨Çow
analysis needs to Ô¨Ånd and abstract all valid paths.
For a framework-based platform such as Android, there is
no main procedure from which control-Ô¨Çow paths start. The
interaction between an application and the platform is through
callbacks: the high-level view of the control Ô¨Çow is as a
sequence of calls from (unknown) platform code to speciÔ¨Åc ap-
plication methods. This is a key challenging aspect of Android
control-Ô¨Çow analysis, and the focus of our work. Thus, we
consider abstracted ICFG paths in which only interprocedural
edges to/from callback methods are represented, and all other
edges are abstracted away. In this case, a path consists of
edgesci!smandem!riwhereciis a call-site node inthe platform code that invokes an application-deÔ¨Åned callback
methodm, andriis the return-site node corresponding to ci.
The Android framework deÔ¨Ånes thousands of callbacks for a
variety of interactions. We focus on an essential aspect of this
control Ô¨Çow: the lifecycle and interactions of user-event-driven
components. The components of interest are activities ,dialogs ,
andmenus . Each such component is represented by a separate
GUI window. We consider two categories of callbacks.
Lifecycle callbacks manage the lifetime of application com-
ponents. The most important examples are callbacks to man-
age activities. Lifecycle methods such as onCreate and
onDestroy are of signiÔ¨Åcant interest because management
of the activity lifecycle is an essential concern for developers
(e.g., to avoid leaks [11], [12], [20]). Lifecycle callbacks for
activities, dialogs, and menus deÔ¨Åne major changes to the
visible state and to the possible run-time events and behavior.
GUI event handler callbacks respond to user actions (e.g.,
clicking a button) and deÔ¨Åne another key aspect of the control
Ô¨Çow. These event handlers perform various actions, including
transitions in the application logic (e.g., terminating an activity
and returning back to the previous one). Control-Ô¨Çow analysis
of such handlers is essential for an event-driven platform.
For these two categories of callbacks, the execution of
a callback method micompletes before any other callback
methodmjis invoked. (As discussed later, mimay cause the
subsequent execution of mj.) Thus, the abstracted control-
Ô¨Çow paths are always of the form ci!smi;emi!ri;cj!
smj;emj!rj;ck!smk;emk!rk;::: and will be repre-
sented simply as mimjmk:::wheremiis the callback
method invoked by ci. Thus, in this work we are interested
in a version of control-Ô¨Çow analysis which produces all valid
sequences of method callbacks for component lifecycles and
event handling. We aim to model only a single application;
inter-application control Ô¨Çow is beyond the scope of this work.
B. Example from an Android Application
Figure 1 shows a simpliÔ¨Åed example derived from Open-
Manager [24], an open-source Ô¨Åle manager for Android. Class
Main deÔ¨Ånes an activity: an application component responsible
for displaying a GUI window and interacting with the user.
Method onCreate is an example of a lifecycle callback
method: it is invoked by the Android platform when the
activity is instantiated. The structure of the new window is
deÔ¨Åned by Ô¨Åle main.xml shown at the bottom of the Ô¨Ågure. In
this simpliÔ¨Åed example the layout contains four GUI widgets,
each one being a button with an image that can be clicked. The
call to setContentView at line 4 instantiates these widgets
(together with their LinearLayout container) and associates
them with the Main activity. The loop at lines 9‚Äì12 iterates
over the programmatic button ids and associates the buttons
with a listener object: the EventHandler created at line 5.
The listener class deÔ¨Ånes an event handling method
onClick , which is invoked by the Android platform when
the user clicks on a button. The button that was clicked is
provided as parameter vofonClick . The event handler may
start a new activity: an instance of DirectoryInfo (when v1 public class Main extends Activity {
2 private EventHandler mHandler;
3 public void onCreate() {
4 this.setContentView(R.layout.main);
5 mHandler = new EventHandler(this);
6 int[] img_button_id = {R.id.info_button,
7 R.id.help_button, R.id.manage_button,
8 R.id.multiselect_button};
9 for(int i = 0; i < img_button_id.length; i++) {
10 ImageButton b = (ImageButton)findViewById(
11 img_button_id[i]);
12 b.setOnClickListener(mHandler);
13 } } }
14 public class EventHandler implements
15 OnClickListener {
16 private final Activity mActivity;
17 public EventHandler(Activity activity) {
18 mActivity = activity;
19 }
20 public void onClick(View v) {
21 switch(v.getId()) {
22 case R.id.info_button:
23 Intent info = new Intent(
24 mActivity, DirectoryInfo.class);
25 mActivity.startActivity(info);
26 break;
27 case R.id.help_button:
28 Intent help = new Intent(
29 mActivity, HelpManager.class);
30 mActivity.startActivity(help);
31 break;
32 case R.id.manage_button:
33 AlertDialog.Builder builder = ...
34 AlertDialog dialog = builder.create();
35 dialog.show();
36 break;
37 default:
38 ...
39 break; } } }
main.xml:
<LinearLayout>
<ImageButton android:id="@+id/info_button"/>
<ImageButton android:id="@+id/help_button"/>
<ImageButton android:id="@+id/manage_button"/>
<ImageButton android:id="@+id/multiselect_button"/>
</LinearLayout>
Fig. 1: Example derived from OpenManager [24]
is the info button, line 25) or of HelpManager (when vis the
help button, line 30). In both cases, an Intent triggers the
activation; this is the standard Android mechanism for starting
a new activity. The call to startActivity posts an event on
the framework‚Äôs event queue. After onClick completes, this
event is processed, a callback to onCreate is executed on the
new activity, and a new window is displayed.
When vis the manage button, a new dialog window is
created and displayed at line 35. This window is an instance
of a AlertDialog and is used to show several selectable
items (e.g., to manage the running process, or to back up
applications to the SD card). The creation of the dialog is
performed through helper object builder . Finally, when v
is the multi-select button, the displayed window remains the
one associated with activity Main , but its visual representation
changes (line 38); details of this change are omitted.
Control-Ô¨Çow analysis for this application needs to cap-
ture the ordering relationship between onCreate and
onClick : the event handler method may be invoked imme-
diately after onCreate completes its execution. Similarly,
control-Ô¨Çow analysis needs to capture the ordering rela-tionship between onClick andDirectoryInfo.onCreate ,
HelpManager.onCreate , and AlertDialog.onCreate . In
addition, because it is possible that the default branch of the
switch statement is taken, the next callback after onClick
could be another invocation of onClick .
Note that the Ô¨Çow of control triggered by onClick is
context sensitive : depending on the widget (parameter v),
different sequences of callbacks may be observed. From prior
work on control-Ô¨Çow/reference analysis of object-oriented
programs (e.g., [25]‚Äì[27]), it is well known that context
sensitivity has signiÔ¨Åcant precision beneÔ¨Åts. One effective way
to introduce context sensitivity is to model the parameters
of a method invocation (including this ) [25]. Based on
this observation, we propose a new form of context-sensitive
control-Ô¨Çow analysis of callback methods. For this example, a
context-insensitive analysis would conclude that the execution
ofonClick could be followed by execution of any one of
the other four callbacks. However, a context-sensitive analysis
will report that, for example, onClick will be followed by
HelpManager.onCreate only when vwas the help button.
C. Problem DeÔ¨Ånition
Consider two sets of application methods: set Lof lifecycle
methods for activities, dialogs, and menus, as well as set Hof
GUI event handler methods. Sequences of callbacks to such
methods are the target of our analysis. In this work we focus on
certain lifecycle methods l2L: speciÔ¨Åcally, creation callbacks
(e.g., Activity.onCreate ) and termination callbacks (e.g.,
Activity.onDestroy ).
In the future we plan to extend the analysis with other
lifecycle callbacks based on standard ordering constraints [11].
In addition, callbacks related to other types of components‚Äî
such as services, broadcast receivers, and non-UI worker
threads‚Äîare of great interest to the static analysis community
(e.g., for security checking and leak detection), and context-
sensitive analysis for such callbacks is an important target for
future work. Such generalizations would require signiÔ¨Åcant
conceptual extensions to our current analyses.
We assume that relevant static abstractions have already
been deÔ¨Åned by an existing analysis of GUI-related objects
[28], [29]. We will refer to this analysis as G ATOR , using the
name of its public implementation [23]. The analysis tracks
the propagation of widgets and related entities (e.g., activities,
dialogs, listeners, layout/widget ids) by analyzing XML lay-
outs and relevant code (e.g., the calls to findViewById and
setOnClickListener in Figure 1). Its output contains a pair
of sets (W;V). Each window w2W (an activity, a dialog,
or a menu) is associated with a set of views v2V. Views are
the Android representation of GUI widgets, and are instances
of subclasses of android.view.View . A widgetv2V may
be associated with event handlers h2H.
The control-Ô¨Çow analysis output can be represented by a
callback control-Ô¨Çow graph (CCFG). There are three cate-
gories of graph nodes. A node (h;v)2HV indicates that
event handler hwas executed due to a GUI event on widget
v. A node (l;w)2LW shows that lifecycle method lwasonCreate,
Main
b1onDestroy,
Main
onClick,
ImageButton
[info_button]
onClick,
ImageButton
[help_button]onClick,
ImageButton
[manage_button]
onClick,
ImageButton
[multiselect_button]onCreate,
DirectoryInfo
onCreate,
HelpManager
onCreate,
AlertDialog
j1b2
onTextChanged,
TextViewonCheckedChanged,
RadioGroup
onDestroy,
DirectoryInfoj2Fig. 2: Callback control-Ô¨Çow graph
executed on window w. In addition, helper nodes are used to
represent branch and join points, as explained shortly. The start
node in the CCFG corresponds to the onCreate callback on
the main activity of the application. Each path starting from
this node deÔ¨Ånes a possible sequence of callbacks during the
execution of the application. An edge n1!n2shows that
the callback represented by n1may trigger the subsequent
execution of the callback represented by n2.
The CCFG for the running example is shown in Figure 2.
For illustration, we show a scenario where (1) the main activity
also has an onDestroy lifecycle method, (2) the details of
HelpManager andAlertDialog are not elaborated, and are
represented by the two dashed edges, (3) DirectoryInfo
has two event handlers as well as an onDestroy method,
and (4) handler onCheckedChanged may force termination
ofDirectoryInfo and return control back to Main .
To indicate that event handlers could be executed in any
order, branch nodes biand join nodes jiare introduced,
together with edges ji!bi. This technique is similar to
our early work on data-Ô¨Çow analysis approximations [30];
recent work [9] also uses a similar approach, as discussed later.
Both onDestroy methods are successors of the corresponding
branch nodes (rather than join nodes) to show that the user may
click the device‚Äôs BACK button to exit an activity immediately,
without triggering any event handler. Note that onDestroy in
DirectoryInfo is also a successor of onCheckedChanged ,
to show that this handler may force exit from DirectoryInfo
(e.g., by using a standard API call such as finish ).
This model is not complete: for example, if Main is the
current window and the screen is rotated, a new instanceofMain will replace the current one, and onCreate would
be called on it, which would require additional edges in the
graph. Such edges can be added for standard Android events
such as screen rotation, interruption due to a phone call, or
locking/unlocking the device screen [29]; for simplicity, we
do not consider them in this paper.
D. Prior Work
Existing work has addressed some aspects of this problem.
For example, FlowDroid [9] uses a static analysis that rep-
resents the possible orderings of lifecycle/event callbacks for
a single activity. The analysis encodes these orderings in an
artiÔ¨Åcial main method, and paths through this method corre-
spond to sequences of callbacks. This approach was designed
for a particular form of interprocedural taint analysis and does
not solve the general control-Ô¨Çow problem described above.
The key issue is that there is no modeling of transitions and
interactions involving multiple activities . For example, there is
no path through the main method to show that the execution
ofEventHandler.onClick may trigger the execution of
DirectoryInfo.onCreate ; the same is true for the other
twoonCreate methods. In addition, the approach does not
consider the widgets on which the event handlers operate,
nor does it model transitions to/from dialogs and menus, or
transitions due to window termination. The earlier SCanDroid
tool [4], which aims to model the sequence of callbacks to
event handlers [31], has similar limitations.
Another area of related work is the resolution of activity-
launch calls, such as the startActivity calls at lines 25 and
30 in Figure 1. Activity-launch APIs use an intent object to
specify the target activity; two examples are shown at lines 23
and 28 in the Ô¨Ågure. There are several existing techniques [4],
[5], [8], [14], [15], [32] for analysis of intent objects. By
itself, intent analysis cannot determine the edges in a CCFG
(shown in Figure 2). It needs to be combined with (1) context-
sensitive analysis of event handlers and their transitive callees,
(2) tracking of other window-launch calls (e.g., the call to
show at line 35), and (3) modeling of window termination
calls. One component of our control-Ô¨Çow analysis is an intent
analysis which is derived from prior work [8].
III. A NALYSIS ALGORITHM
A. Control-Flow Analysis of a Callback Method
A key building block of our approach is a context-sensitive
analysis of a callback m2L[H under a context c. Recall
that we use static abstractions for windows w2W (activities,
dialogs, and menus) and views v2V created by G ATOR . For
an event handler h2H, the context is a view v; for a lifecycle
callbackl2L, the context is a window w. The analysis is
outlined in Algorithm 1. This algorithm is then used by the
main control-Ô¨Çow analysis, as described in Section III-B.
Input and output. The algorithm traverses valid ICFG paths,
starting from the entry node of m‚Äôs CFG. When a trigger node
is reached, the traversal stops. A trigger node is a CFG node
that may trigger the subsequent execution of another callback;
the set triggerNodes of all such nodes is provided as input toAlgorithm 1: AnalyzeCallbackMethod( m,c)
Input :m: callback method
Input :c: context
Input :triggerNodes : set of ICFG nodes
Output :reachedTriggers ; : set of ICFG nodes
Output :avoidsTriggers : boolean
1feasibleEdges COMPUTE FEASIBLE EDGES (m; c )
2visitedNodes fentryNode (m)g
3nodeWorklist fentryNode (m)g
4avoidingMethods  ;
5while nodeWorklist6=;do
6 n removeElement (nodeWorklist )
7 ifn2triggerNodes then
8 reachedTriggers reachedTriggers[fng
9 else if nis not a call-site node and not an exit node then
10 foreach ICFG edge n!k2feasibleEdges do
11 PROPAGATE (k)
12 else if nis a call-site node and
n!entryNode (p)2feasibleEdges then
13 PROPAGATE (entryNode (p))
14 ifp2avoidingMethods then
15 PROPAGATE (returnSite (n))
16 else if nisexitNode (p)andp =2avoidingMethods then
17 avoidingMethods  avoidingMethods [fpg
18 foreach c!entryNode (p)2feasibleEdges do
19 ifc2visitedNodes then
20 PROPAGATE (returnSite (c))
21avoidsTriggers m2avoidingMethods
22procedure PROPAGATE (k)
23 ifk =2visitedNodes then
24 visitedNodes visitedNodes[fkg
25 nodeWorklist nodeWorklist[fkg
the algorithm. Examples of trigger nodes are shown at lines
25, 30, and 35 in Figure 1; other examples are provided in
Section III-B. An analysis output is the set reachedTriggers
of trigger nodes encountered during the traversal.
Another key consideration is to determine whether the exit
node ofmis reachable from the entry node of mvia a
valid trigger-free ICFG path. If so, the execution of mmay
avoid executing any trigger. In the example such a path exists
through the default branch. This path is necessary to determine
the CCFG edge from onClick toj1for the multiselect button.
This edge shows that when this button is clicked, onClick
may be followed by another invocation of onClick (or by app
termination). The algorithm outputs a boolean avoidsTriggers
indicating the existence of a trigger-free path.
Context sensitivity. Context sensitivity is achieved by per-
forming a separate pre-analysis‚Äîrepresented by the call to
COMPUTE FEASIBLE EDGES ‚Äîto determine the feasible ICFG
edges inmand methods transitively called by m. During the
traversal (lines 5‚Äì20 in Algorithm 1), only feasible edges are
followed. The choice of the feasibility pre-analysis depends on
the callback method and on the context. For example, when
onClick from the running example is analyzed, the context is
a static abstraction of the ImageButton instance provided as
parameter. Using the output from G ATOR , the id of this view
is also available. This allows C OMPUTE FEASIBLE EDGES to
resolve the return value of v.getId() at line 21 and to deter-mine which branch is feasible. The general form of this pre-
analysis is outlined in Section III-C. For a lifecycle callback
under the context of a window, the analysis can identify virtual
calls where this window is the only possible receiver, and can
determine more precisely the feasible interprocedural edges.
Algorithm design. The algorithm is based on the general
graph-traversal technique for solving interprocedural, Ô¨Ånite,
distributive, subset (IFDS) data-Ô¨Çow analysis problems [3].
We formulated an IFDS problem with a lattice containing
two elements:;and the singleton set fentryNode (m)g. The
data-Ô¨Çow functions are x:x (identity function, for non-trigger
nodes) and x:;(for trigger nodes). The resulting data-Ô¨Çow
analysis was the conceptual basis for Algorithm 1.
SetavoidingMethods contains methods pthat are proven
to contain a trigger-free same-level valid path from the entry
ofpto the exit of p. (In a same-level valid path, a call site has
a matching return site, and vice versa.) Thus, the execution of
pmay avoid any trigger. If a call-site node is reachable, and
it invokes such a method, the corresponding return-site node
is inferred to be reachable as well (lines 14‚Äì15). As another
example, whenever the exit node of pis reached for the Ô¨Årst
time (line 16), pis added to avoidingMethods and all call sites
cthat invokepare considered for possible reachability of their
return sites (lines 18‚Äì20). The set of avoiding methods is, in
essence, a representation of the IFDS summary edges [3].
B. CCFG Construction
CCFG construction uses the output from G ATOR . In this
output, an activity ais associated with widgets Views (a)V.
The activity could also be associated with an options menu
m2W ; such a menu is triggered by the device‚Äôs dedicated
menu button or by the action bar. Similarly, a view v2V
could have a context menu m, triggered through a long-click
on the view. Each menu mrepresents a separate window
with its own widget set Views (m), which typically contains
views (instances of MenuItem ) representing items in a list. A
dialogd2W is a separate window with some message to
the user, together with related choices (e.g., buttons for ‚ÄúOK‚Äù
and ‚ÄúCancel‚Äù). A dialog is associated with its own widget set
Views (d). A widgetvcould be associated with several event
handlers Handlers (v)H .
CCFG construction creates, for each w2 W , nodes for
the relevant callbacks. Lifecycle methods for creation and
termination of ware based on standard APIs. In the subse-
quent description we assume that wdeÔ¨Ånes both a creation
callbacklc(e.g., onCreate ) and a termination callback lt
(e.g., onDestroy ), but our implementation does not make this
assumption. For any h2Handlers (v)wherev2Views (w),
there is a CCFG node (h;v); we assume that at least one such
node exists for w. A branch node bwand a join node jware
also introduced.
Edge creation. Algorithm 2 deÔ¨Ånes the edges created for a
windoww. As illustrated in Figure 2, edges (lc;w)!bw!
(lt;w)show the invocations of lifetime callbacks; these edges
are created at lines 5‚Äì6 in Algorithm 2. The second edge
represents the termination of wwith the BACK button.Algorithm 2: CreateEdges( w)
Input :w: window
Input :(lc; w);(lt; w): lifecycle nodes for w
Input :f(h1; v1);(h2; v2); : : :g: event handler nodes for w
Input :bw; jw: branch/join nodes for w
Output :newEdges : set of CCFG edges for w
1newEdges ;
2htriggers ;avoidsi ANALYZE CALLBACK METHOD (lc; w)
3newEdges newEdges[TRIGGER EDGES (triggers ; lc; w)
4ifavoids then
5 newEdges newEdges[f(lc; w)!bwg
6newEdges newEdges[fbw!(lt; w)g
7foreach event handler node (h; v)do
8 newEdges newEdges[fbw!(h; v)g
9htriggers ;avoidsi ANALYZE CALLBACK METHOD (h; v)
10 newEdges newEdges[TRIGGER EDGES (triggers ; h; v )
11 ifavoids then
12 newEdges newEdges[f(h; v)!jwg
13ifwis not a menu then
14 newEdges newEdges[fjw!bwg
15else
16 newEdges newEdges[fjw!(lt; w)g
The termination of wcould also be triggered by event
handlers. Recall that for the running example, we assume
that handler onCheckedChanged calls finish on activ-
ityDirectoryInfo . This is an example of a termina-
tion trigger node, and our analysis creates an edge from
onCheckedChanged toonDestroy (at line 10 in Algo-
rithm 2, as elaborated below). Furthermore, if the handler‚Äôs
execution cannot avoid this trigger, the analysis would not
create the edge from onCheckedChanged toj2. For the
example, we assume that this termination trigger can be
avoided along some ICFG path; thus, there is an edge to j2
in Figure 2, created by line 12 in Algorithm 2.
For each handler hfor a viewvfromw‚Äôs widget set, an edge
bw!(h;v)is added to indicate the possible user actions and
the invoked handlers (line 8 in Algorithm 2). Together with the
back edgejw!bwcreated at line 14, this structure indicates
arbitrary ordering of user-triggered events. If wis a menu,
menu item selection immediately closes wand an edge from
jwto the termination callback is created instead.
Eachhis analyzed under context vusing Algorithm 1
(invoked at line 9). If avoidsTriggers is true, (h;v)!jw
is added to show that the execution of hmay retain the
current window w(rather than transition to a new one)
and user events will continue to trigger the event handlers
forw. The other outgoing edges for (h;v)are determined
by set reachedTriggers and are created by helper function
TRIGGER EDGES described below.
Algorithm 1 is also invoked for the creation callback lc(at
line 2) to determine which trigger statements are reachable.
Termination callback ltis assumed to contain no such triggers,
since its role is to clean up resources, rather than to trigger
window transitions. Edge creation for (lc;w), shown at lines
3‚Äì5, is similar to the edge creation for (h;v)at lines 10‚Äì12.
The set of edges produced by T RIGGER EDGES is based
on case-by-case analysis of trigger statements. Activity-launchcalls such as startActivity (e.g., lines 25 and 30 in
Figure 1) are analyzed with our Ô¨Çow- and context-insensitive
intent analysis, conceptually derived from a more expensive
prior analysis [8], but accounting for statement feasibility
(analogous to line 1 in Algorithm 1). The analysis focuses
on explicit intents because they are designed for use inside
the same application [33]. In our experience, it performed as
well as existing alternatives [8], [31]. Menu-launch calls such
asshowContextMenu as well as dialog-launch calls (e.g., line
35 in Figure 1), are resolved by G ATOR . Any such statement
triggers the launch of a new window w0. Correspondingly,
function T RIGGER EDGES produces edges (h;v)!(l0c;w0)
and (l0t;w0)!jwwhen invoked at line 10, and edges
(lc;w)!(l0c;w0)and (l0t;w0)!bwwhen invoked at line 3.
TRIGGER EDGES also accounts for the possibility that set
triggers contains a statement that terminates the current
window‚Äîe.g., a call to finish on an activity, or a call
todismiss on a dialog. If triggers contains a termination
statement for w, TRIGGER EDGES produces (h;v)!(lt;w)
or(lc;w)!(lt;w)to represent the possible Ô¨Çow of control.
Example. For the running example shown in Figure 1,
calling A NALYZE CALLBACK METHOD at line 9 with h=
onClick andv=ImageButton[info_button] will return
triggers =fs25gandavoids =false . Activity-launch state-
ments25, representing line 25 in Figure 1, is resolved to w0=
DirectoryInfo . As a result, edges (h;v)!(onCreate;w0)
and(onDestroy;w0)!j1are produced by T RIGGER EDGES .
If the call at line 9 is for h=onCheckedChanged ,triggers
will contain the call to finish that closesw0, resulting in an
edge to (onDestroy;w0)created by T RIGGER EDGES .
C. Detection of Feasible Edges
To detect which ICFG edges are (in)feasible under a partic-
ular context, we use constant propagation analyses formulated
as Interprocedural Distributed Environment (IDE) [34] analy-
sis problems. Due to space limitations, we outline the analyses
at a high level without providing all technical details.
Consider the analysis of a callback method munder context
c, performed by C OMPUTE FEASIBLE EDGES . The context
could be a widget vor a window w; both cases are handled,
although our experiments suggest that context sensitivity for
windowswhas minor effect on precision. First, this analysis
uses a form of interprocedural constant propagation to identify
each local variable that deÔ¨Ånitely refers to only one object.
This analysis employs (1) knowledge that a particular param-
eter ofmdeÔ¨Ånitely refers to c, and (2) additional reference
information obtained from G ATOR . The analysis considers all
methods transitively invoked by m; virtual calls are resolved
using class hierarchy information. After this constant propa-
gation, the computed information is used to reÔ¨Åne virtual call
resolution: if only one receiver object is determined to be pos-
sible, the call is resolved accordingly. Next, another interproce-
dural constant propagation analysis determines constant values
of integer and boolean type. For example, for an API call such
asx.getId() orx.getMenuItemId() , ifxdeÔ¨Ånitely refers
only to one particular view, the id for that view is treated as thereturn (constant) value of the call. Boolean expressions such
asx==y andx!=y are also considered, both for references and
for integers; switch statements are treated similarly. In a Ô¨Ånal
step, branch nodes whose conditions are found to be constants
are used to determine infeasible ICFG edges, which (together
with infeasible interprocedural edges at reÔ¨Åned virtual calls)
deÔ¨Ånes the output of C OMPUTE FEASIBLE EDGES .
Example. For the example in Figure 1, suppose we ana-
lyzeonClick under context ImageButton[info_button] .
The Ô¨Årst constant propagation analysis will determine that
vdeÔ¨Ånitely points to only this button. The second constant
propagation analysis will determine that v.getId() returns
the integer constant R.id.info_button . The output of the
analysis will be the set of ICFG edges corresponding to the
Ô¨Årst branch of the switch statement. Although in this simple
example the propagation is trivial, our analyses handle general
interprocedural propagation along valid ICFG paths, using
jump functions and summary functions [34].
D. Valid CCFG Paths
Not every path in the CCFG represents a valid sequence
of run-time invocations of callback methods. Consider again
the example in Figure 2, and suppose that another window
w, different from the ones shown in the Ô¨Ågure, contained
a handlerhwith startActivity call to trigger window
w0=DirectoryInfo . Edges (h;v)!(onCreate;w0)and
(onDestroy;w0)!jwwould be created to represent this
trigger statement. Clearly, a path that enters w0from Main
through edge (onClick;info_button )!(onCreate;w0),
but exitsw0back tow, through (onDestroy;w0)!jw, does
not correspond to a valid run-time execution.
In general, a valid CCFG path has matching edges :::!
(lc;w)and (lt;w)!:::. Each such pair is created at the
same time by T RIGGER EDGES and can be recorded as a
matching pair at that time. This condition is very similar to
the traditional one for valid ICFG paths. The implications for
static analyses are also similar to traditional ICFG control-
Ô¨Çow analysis. Standard techniques can be applied to focus
only on valid CCFG paths (or some over-approximation):
either by explicitly maintaining the sequence of unmatched
:::!(lc;w)edges, or by creating approximations of them,
in the spirit of k-call-site-string sensitivity [2], [25].
IV. C LIENT ANALYSIS : CONSTRUCTION OF GUI M ODELS
The control-Ô¨Çow analysis described above could be used as
a component of other static analyses (e.g., [4]‚Äì[17]). These
potential clients provide a number of interesting possibilities
for future work. Another possible use of the analysis is for
generation of GUI models , which are important for program
understanding and test generation. Various GUI models have
been employed (e.g., [18], [22], [35], [36]). Figure 3 shows
an example of the GUI models we consider. Nodes represent
GUI windows, and edges show possible transitions between
windows. Each transition is labeled by the GUI widget that
triggers it. Additional information for an edge is the type of
GUI event (e.g., click) and the event handler (e.g., method
Launcher
Main¬†BACK¬†
¬†ImageButton¬†
¬†[multiselect_button]¬†
DirectoryInfo¬†ImageButton¬†
¬†[info_button]¬†
HelpManager¬†ImageButton¬†
¬†[help_button]¬†
AlertDialog¬†ImageButton¬†
¬†[manage_button]¬†¬†BACK¬†¬†RadioGroup¬†
¬†TextView¬†¬†RadioGroup¬†Fig. 3: GUI model for the running example
onClick ). For simplicity, this information is not displayed
in Figure 3. ‚ÄúBACK‚Äù edges correspond to the device‚Äôs back
button. ‚ÄúLauncher‚Äù denotes the Android app launcher. Only
a subset of the edges are shown: for example, the edge from
HelpManager back to Main is not shown.
Such a model can serve as starting point for test generation.
For example, an existing automated test generation technique
for Android [19] requires the set of tuples (window w, GUI
widgetv, evente, handler method h), wherevis visible
whenwis active, and event eonvis handled by h. In
this earlier work such models are constructed manually. As
another example, a test generation approach for exposing leaks
in Android applications [20] requires this model as input; in
that work the models were also manually created. There are
other examples of model-based test generation for Android
where a GUI model is an essential prerequisite [18], [21], and
paths in the model correspond to GUI events in a test case.
This GUI model can be easily derived from the CCFG.
Edges to a creation callback (lc;w)in the CCFG represent
transitions to window win the model; the sources of these
edges describe the event handlers and widgets. Edges from
a termination callback (lt;w)represent returns from wto
the previous window. In some cases, the return is not to the
previous window, but to an earlier one; our analysis considers
which previous windows may be already closed, and direct
the edges accordingly. The predecessors of (lt;w)describe
which events trigger the return; when the predecessor is bw, the
event is ‚ÄúBACK‚Äù. Self-transitions in the GUI model (e.g., for
multiselect_button in Figure 3) are also easy to derive.
Each path in this model corresponds to a unique CCFG
path. A path in the model is valid only if its corresponding
CCFG path is valid. If the model is traversed to create test
cases (e.g., as in [20]), only valid paths should be traversed.
Our context-sensitive analysis is needed to avoid infeasible
edges in the GUI model. If a context- insensitive analysis were
used instead, it would conclude that the execution of onClick
could trigger each one of the four possible edges in the model,
regardless of the button being clicked. As a result, for example,
infeasible edges for manage_button toHelpManager and
DirectoryInfo would be created, as well as an infeasible
self-edge to Main . Overall, twelve infeasible edges would be
added to the GUI model for the running example.TABLE I: Characteristics of the analyzed applications and their CCFGs.
(a) Applications (b) CCFGs (c) Models (d) Times
Name Classes Methods Activities Menus Dialogs Nodes Edges OutDegree OutDegCI OutDegree OutDegCI CS [s] CI [s]
APV 68 413 4 4 5 86 156 1.16 3.07 4.23 10.85 10 8
Astrid 1228 5782 41 3 48 973 1889 1.14 1.15 12.32 12.36 75 57
BarcodeScanner 126 594 9 4 6 102 169 1.38 1.92 3.28 4.44 10 10
Beem 284 1883 12 6 5 121 186 1.14 2.20 2.57 5.24 12 12
ConnectBot 371 2366 11 8 17 197 317 1.20 1.20 3.20 3.20 28 25
FBReader 954 5452 27 9 8 271 2933 11.34 12.53 55.95 61.67 779 281
K9 815 5311 32 3 19 393 723 1.15 1.59 5.90 7.96 73 58
KeePassDroid 465 2784 20 11 9 288 682 2.01 2.47 12.82 17.18 22 20
Mileage 221 1223 50 15 9 522 914 1.34 1.70 5.41 6.64 11 11
MyTracks 485 2680 32 8 20 279 623 1.86 4.44 8.53 18.71 22 18
NPR 249 1359 13 12 6 560 1171 1.19 2.08 32.29 59.29 15 14
NotePad 89 394 8 3 10 126 251 1.30 2.91 5.48 10.38 9 9
OpenManager 53 237 6 2 9 110 183 1.10 2.30 4.31 9.06 7 6
OpenSudoku 140 726 10 6 18 168 305 1.41 3.50 3.12 7.26 10 8
SipDroid 328 2863 12 5 13 142 340 2.03 4.08 8.47 15.10 35 32
SuperGenPass 64 267 2 2 4 61 107 1.18 1.64 5.00 6.88 8 7
TippyTipper 57 241 6 3 0 61 94 1.00 1.24 4.13 5.13 6 6
VLC 242 1374 10 2 13 168 277 1.10 1.10 4.24 4.24 20 15
VuDroid 69 385 3 2 1 35 62 1.50 3.33 3.67 8.00 6 5
XBMC 975 6492 22 20 24 2275 6254 1.85 2.24 176.07 186.33 47 39
V. E XPERIMENTAL EVALUATION
We applied the analysis on 20 open-source Android appli-
cations used in prior work [17], [20], [28], [36], [37]. Our
goals were to (1) characterize the size and complexity of the
CCFG, (2) measure the beneÔ¨Åts of context sensitivity in the
analysis of event handlers, and (3) evaluate the precision of
the GUI models derived from the CCFG.
A. CCFG Construction
Table I(a) shows the number of application classes and
methods, as well as counts for different categories of windows.
Typically, an analyzed application has more than twenty win-
dows. The callback sequences and GUI models associated with
these windows cannot be practically analyzed by hand. This
complexity is also indicated in part (b) of the table: there are
typically more than a hundred CCFG nodes for an application,
where each node (except for branch/join nodes) represents a
callback under a particular context. The ordering constraints
for such callbacks are modeled by the output of our analysis.
Column ‚ÄúOutDegree‚Äù shows the average number of outgo-
ing edges for CCFG nodes corresponding to event handlers.
This number is an indication of the variability of behavior
for a handler (e.g., onClick in the running example). Our
context-sensitive analysis aims to model this variability more
precisely, by accounting for the handler‚Äôs context. To measure
the effects of context sensitivity, we also ran the analysis in
a context-insensitive mode, where context information was
ignored (i.e., the call to C OMPUTE FEASIBLE EDGES in Fig-
ure 1 was not used). Column ‚ÄúOutDegCI‚Äù shows the resulting
average number of outgoing edges. As the measurements in
the two columns show, there can be signiÔ¨Åcant precision
loss if context sensitivity is not used. This observation is
conÔ¨Årmed by part (c), which contains similar measurements
for the average number of outgoing edges for a node in the
static GUI model. (Back button edges were not included inthese measurements, since each forward edge implicitly has
a corresponding back button edge.) More generally, these
results indicate that callback analysis with context sensitivity
produces a more precise representation of the control Ô¨Çow.
Section V-B provides additional case studies on the beneÔ¨Åts
of context sensitivity for GUI models.
We investigated two programs with signiÔ¨Åcantly higher out-
degrees measurements in part (c), compared to the rest of the
programs: FBReader andXBMC . For FBReader , the culprit is
a utility method that is called by the handlers of about 37% of
the CCFG nodes. These nodes have signiÔ¨Åcantly higher out-
degrees than the rest. We examined a sample of such nodes,
and determined that around 60% of their outgoing edges are
feasible. The infeasible edges are due to the utility method:
in it, class hierarchy analysis is used to resolve a run()
call on a thread, which is overly conservative. While not
comprehensive, this examination indicated that FBReader has
a rich GUI with complex logic in event handlers, and this leads
to a large number of possible window transitions. For XBMC ,
the large number of edges is due to a known imprecision of
GATOR for this program [28]: because the analysis is context-
insensitive, there is spurious propagation of widgets.
Part (d) of the table shows the running times of the CCFG
construction analysis (including G ATOR analyses), both for
context-sensitive (CS) and context-insensitive (CI) algorithms.
The running times of the GUI model construction are not
shown, since they were negligible. Overall, the results indicate
that analysis running times are suitable for practical use in
software tools. The use of context-insensitive analysis typically
does not lead to signiÔ¨Åcant reductions in running time, and the
resulting precision loss does not seem justiÔ¨Åed.
B. Case Studies of GUI Model Construction
To obtain additional insights on the precision of the static
GUI models, case studies were performed on six applications:TABLE II: Edges in the GUI model.
Application Static (CS/CI) Precise Ripper Ripping time
APV 55/141 55 22 1h34m
BarcodeScanner 59/80 43 20 4h44m
OpenManager 69/145 56 43 6h51m
SuperGenPass 40/55 40 19 1h26m
TippyTipper 33/41 33 28 1h21m
VuDroid 22/48 18 14 44m
APV,BarcodeScanner ,OpenManager ,SuperGenPass ,
TippyTipper , and VuDroid . These applications have the
smallest number of windows in Table I, and were chosen to
allow comprehensive manual examination.
We compared our static approach with Android GUI Ripper
[22] (‚ÄúRipper‚Äù for short), a state-of-the-art tool for automated
dynamic exploration of an application‚Äôs GUI.1The public
version from the tool‚Äôs web page [39] was used for these
experiments. The ripping observes run-time widgets for the
current window, and Ô¨Åres events on them to cause GUI
changes. If a new GUI state is discovered, its widgets are
also considered for further events. In our experiments we let
Ripper run to completion; the running times are shown in
the last column of Table II. Each transition triggered during
the dynamic exploration was mapped to a window-to-window
transition edge, similar to the ones in the static model.
The results of this experiment are summarized in Table II.
We Ô¨Årst determined the set of GUI model edges based on
CCFG construction (column ‚ÄúStatic‚Äù). For precision compar-
ison, we present results for both context-sensitive (CS) and
context-insensitive (CI) construction of the CCFG. Next, we
performed a careful case study of each application. Each GUI
model edge reported by the context-sensitive analysis was
manually classiÔ¨Åed as ‚Äúfeasible‚Äù or ‚Äúinfeasible‚Äù. The number
of feasible edges is shown in column ‚ÄúPrecise‚Äù.
To determine this number, we tried to manually achieve run-
time coverage of the edge by triggering a transition from the
source window to the target window, using the widget and
GUI event for this edge. For infeasible edges, the source code
was examined to determine that no run-time execution could
cover this edge. Clearly, this manual examination presents a
threat to validity; to reduce this threat, the code was examined
by multiple co-authors. Below we describe details of some of
these studies, as they shed light on the sources of imprecision
of the proposed analysis. Column ‚ÄúRipper‚Äù shows how many
of the feasible edges could have been inferred from the
dynamic exploration performed by Ripper.
The following conclusions can be drawn from these results.
First, the overall precision of the context-sensitive static anal-
ysis is quite good. This leads to a small number of infeasible
edges, which is beneÔ¨Åcial for program understanding tools and
testing tools (e.g., to compute more precise GUI coverage
metrics). Second, one of the reasons for the good precision
1We initially also considered another dynamic exploration tool [32] but
observed that sometimes it achieved lower GUI coverage. We also attempted
to obtain the reverse engineering tool used in [36], but its proprietary
implementation could not be distributed outside of the company [38].is the use of context sensitivity. A context-insensitive analysis
would have increased the number of infeasible edges by more
than a factor of 8. Third, the dynamic exploration in Ripper
can miss signiÔ¨Åcant portions of the GUI. One reason is that the
exploration order may affect which widgets are available for
interaction. For example, in APV, buttons ‚ÄúClear Find‚Äù, ‚ÄúFind
Prev‚Äù, and ‚ÄúFind Next‚Äù will not be available until a search
action is Ô¨Ånished, and ‚ÄúFind Prev‚Äù and ‚ÄúFind Next‚Äù are not
available after ‚Äú‚ÄôClear Find‚Äù is clicked. As another example,
inOpenManager , if a Ô¨Åle is deleted before being copied,
related widgets and edges will be missed. As usual, static and
dynamic approaches both have their respective strengths and
weaknesses. For example, run-time state can be used to create
a Ô¨Åner-grain dynamic GUI model, with multiple nodes for the
same activity (based on widget states), which could potentially
improve program understanding and test generation.
For the three applications with infeasible edges, we per-
formed manual analysis to understand the sources of impreci-
sion. Some examples of such sources are described below.
VuDroid. This application displays PDFs and DjVu Ô¨Åles.
Class BaseViewerActivity deÔ¨Ånes several event handlers
shared by its two subclasses PdfViewerActivity and
DjvuViewerActivity . One of these handlers restarts the
current activity in full-screen mode by reusing the activity‚Äôs
intent. Since the handler is in the superclass, in our intent
analysis both intents Ô¨Çow to the ‚Äúrestart‚Äù call, and it appears
that each activity can trigger the other one, which cannot
actually happen at run time. This explains all four infeasible
edges in the model. If the event handlers in the superclass were
cloned in the subclasses, the imprecision would be eliminated.
BarcodeScanner. This application scans and processes eleven
types of barcodes. Depending on the barcode type, various
GUI widgets are displayed to the user. For example, for one
particular group of buttons, one subset of the group is used for
an address book barcode, while a different subset is used for
an email barcode. G ATOR cannot distinguish statically which
subsets are enabled for different barcode types, and concludes
that all buttons in the group are always used, and that all eleven
handlers may be invoked for each button. This imprecision is
responsible for 13 out of the 16 infeasible edges. It seems
unlikely that G ATOR can be generalized to handle this case,
since it would require an intricate combination of reference
analysis with context-sensitive treatment of formals, together
with interprocedural constant propagation for integers, and
loop unrolling for constant-bound loops. An intriguing pos-
sibility for such cases is a hybrid static/dynamic approach.
OpenManager. For this application, the main source of im-
precision is the context-insensitive nature of G ATOR . The
main activity of the application creates a dialog object and
initializes it in a switch statement. Different branches of the
switch correspond to different dialog layouts and widgets.
In the analysis, all these widgets are associated with that
one dialog object. The switch is based on the value of an
integer formal parameter, which deÔ¨Ånes the calling context of
the surrounding method. However, G ATOR does not employ
this context information. If the application code were slightlydifferent, with a separate dialog object being created for each
context, the number of edges in the model would be reduced
from 69 to 57. It would be interesting to consider context-
sensitive generalizations of G ATOR , employing ICFG traversal
techniques similar to the ones used for CCFG construction.
VI. R ELATED WORK
Control-Ô¨Çow analysis for Android. Static analysis to un-
derstand GUI-driven behavior is essential for modeling the
control/data Ô¨Çow of Android applications. The early work on
the SCanDroid security analysis tool [4], [31] includes control-
Ô¨Çow analysis and security permissions analysis for activities
and other Android components (e.g., background services).
The tool performs intent analysis and determines the inter-
component control Ô¨Çow based on it. The approach does not
employ static modeling/analysis for GUI objects, events, and
handlers that trigger the inter-component transitions, and uses
conservative assumptions about the GUI-related control/data
Ô¨Çow. Subsequent work on related security problems, which
also uses intent analysis and control-Ô¨Çow analysis [5], [6],
[8], has similar limitations. As described in Section II-D,
and indicated by our experiments, comprehensive and precise
control-Ô¨Çow analysis requires context-sensitive analysis of
event handlers and the actions taken by them (e.g., component
creation and termination).
SCanDroid‚Äôs static analysis is used in the A3E tool [32]
to construct an activity transition graph, which subsequently
guides run-time GUI exploration. In this graph nodes cor-
respond to activities and edges indicate transitions between
them. It is unclear how this analysis models arbitrary GUI
objects and handlers associated with an activity, and how
these handlers are analyzed. Similar limitations exist for
a static/dynamic analysis of UI-based triggers [7], where
security-sensitive behaviors are triggered dynamically based
on a static model of activity transitions. The static model
construction in this work is incomplete, since it is based on re-
strictive assumptions about event handlers and on rudimentary
analysis of these handlers. Our control-Ô¨Çow analysis provides
a more rigorous and general solution to this problem.
FlowDroid [9] is a precise Ô¨Çow- and context-sensitive taint
analysis which performs interprocedural control-Ô¨Çow and data-
Ô¨Çow analysis for Android. As part of this approach, the effects
of callbacks are modeled by creating a wrapper main method.
Our CCFG is conceptually similar, but without explicitly
creating a wrapper. In FlowDroid, artiÔ¨Åcial placeholder GUI
objects that may Ô¨Çow into these callbacks are created in
the wrapper method, while our approach propagates to the
callbacks the actual GUI objects. The tool does not model
the general propagation of GUI widgets and listeners, nor
does it analyze event handlers context sensitively. As discussed
in Section II-D, this analysis does not represent control Ô¨Çow
that spans multiple activities. In particular, information of the
form ‚Äúcallback mimay be followed by callback mj‚Äù cannot
be inferred when miandmjdo not belong to the same
activity. Control Ô¨Çow involving dialogs, menus, and windowtermination are also not handled. Providing the CCFG as input
to FlowDroid is an intriguing possibility for future work.
In CHEX [13], each callback method and all its transitive
callees are deÔ¨Åned as a code split, and split permutations are
used to derive the set of control-Ô¨Çow paths. Another security
analysis [40] also considers all possible permutations of call-
backs. AsDroid [14] analyzes event handlers of GUI objects
to detect stealthy behaviors, but does not systematically model
the GUI objects and their handlers, nor does it account for the
widget context of a handler. A proposed operational semantics
for activities [41] captures aspects of Android control Ô¨Çow, but
does not model associations between widgets and handlers,
and does not develop analysis algorithms. Apposcopy [15]
builds an inter-component call graph, as part of a malware
detection analysis, but it is unclear how it models GUI
widgets, events, and handlers. These existing techniques could
potentially be complemented by our CCFG.
The CCFG representation may be able to serve as basis for
data-Ô¨Çow analyses to check statically various other properties
of Android applications‚Äîfor example, the absence of leaks
[11], [12], [20]. Other examples include energy-related defects
(e.g., [10] needs to model the execution order of handlers),
errors due to invalid thread accesses to GUI objects [16], and
errors related to null references and non-termination [17].
GUI models for Android. Reverse engineering of GUI mod-
els has been studied by others (e.g., [42]‚Äì[44]) and has been
applied to Android (e.g., [22], [32], [36], [39], [45]). These
approaches are typically based on dynamic exploration. We
provide an alternative: a purely-static approach, which could
produce more comprehensive models. Of course, dynamically-
generated models can provide additional information that is
not available statically‚Äîfor example, whether certain widgets
are disabled in a particular state. On the other hand, static
analysis may expose behaviors that are only possible under
complex run-time conditions that are unlikely to be triggered
by automated dynamic exploration. The most natural direction
to pursue is a hybrid static/dynamic approach, and existing
work by Yang et al. [36] and Azim et al. [32] has already
considered this possibility. With the help of information com-
puted by static analysis (e.g., the events supported by a GUI
widget, or the possible GUI transitions related to a widget), the
dynamic analysis can be made more efÔ¨Åcient and complete.
Our static analysis is more general and comprehensive than
the static analyses from [32], [36], and could potentially be
integrated with their dynamic exploration.
VII. C ONCLUSIONS
This works contributes to a growing foundation of static
analyses for Android software. We develop a control-Ô¨Çow
representation of user-driven callback behavior, using new
context-sensitive analysis of event handlers. A client analysis
for GUI model construction is also presented. Our experimen-
tal results highlight the promise of the proposed techniques.
We believe that the CCFG (and its future generalizations)
could be a valuable program representation for developing a
variety of data-Ô¨Çow analyses for Android applications.REFERENCES
[1] Gartner, Inc., ‚ÄúWorldwide traditional PC, tablet, ultramobile and mo-
bile phone shipments,‚Äù Mar. 2014, www.gartner.com/newsroom/
id/2692318 .
[2] M. Sharir and A. Pnueli, ‚ÄúTwo approaches to interprocedural data
Ô¨Çow analysis,‚Äù in Program Flow Analysis: Theory and Applications ,
S. Muchnick and N. Jones, Eds. Prentice Hall, 1981, pp. 189‚Äì234.
[3] T. Reps, S. Horwitz, and M. Sagiv, ‚ÄúPrecise interprocedural dataÔ¨Çow
analysis via graph reachability,‚Äù in POPL , 1995, pp. 49‚Äì61.
[4] A. P. Fuchs, A. Chaudhuri, and J. S. Foster, ‚ÄúSCanDroid: Automated
security certiÔ¨Åcation of Android applications,‚Äù University of Maryland,
College Park, Tech. Rep. CS-TR-4991, 2009.
[5] E. Chin, A. P. Felt, K. Greenwood, and D. Wagner, ‚ÄúAnalyzing inter-
application communication in Android,‚Äù in MobiSys , 2011, pp. 239‚Äì252.
[6] M. Grace, Y . Zhou, Z. Wang, and X. Jiang, ‚ÄúSystematic detection of
capability leaks in stock Android smartphones,‚Äù in NDSS , 2012.
[7] C. Zheng, S. Zhu, S. Dai, G. Gu, X. Gong, X. Han, and W. Zou, ‚ÄúSmart-
Droid: An automatic system for revealing UI-based trigger conditions
in Android applications,‚Äù in SPSM , 2012, pp. 93‚Äì104.
[8] D. Octeau, P. McDaniel, S. Jha, A. Bartel, E. Bodden, J. Klein, and
Y . le Traon, ‚ÄúEffective inter-component communication mapping in
Android with Epicc,‚Äù in USENIX Security , 2013.
[9] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel, J. Klein,
Y . Le Traon, D. Octeau, and P. McDaniel, ‚ÄúFlowDroid: Precise context,
Ô¨Çow, Ô¨Åeld, object-sensitive and lifecycle-aware taint analysis for Android
apps,‚Äù in PLDI , 2014, pp. 259‚Äì269.
[10] A. Pathak, A. Jindal, Y . C. Hu, and S. P. Midkiff, ‚ÄúWhat is keeping my
phone awake?‚Äù in MobiSys , 2012, pp. 267‚Äì280.
[11] ‚ÄúStopping and restarting an activity,‚Äù developer.android.com/
training/basics/activity-lifecycle/stopping.html .
[12] P. Dubroy, ‚ÄúMemory management for Android applications,‚Äù in Google
I/O Developers Conference , 2011.
[13] L. Lu, Z. Li, Z. Wu, W. Lee, and G. Jiang, ‚ÄúCHEX: Statically vetting
Android apps for component hijacking vulnerabilities,‚Äù in CCS, 2012,
pp. 229‚Äì240.
[14] J. Huang, X. Zhang, L. Tan, P. Wang, and B. Liang, ‚ÄúAsDroid: Detecting
stealthy behaviors in Android applications by user interface and program
behavior contradiction,‚Äù in ICSE , 2014, pp. 1036‚Äì1046.
[15] Y . Feng, S. Anand, I. Dillig, and A. Aiken, ‚ÄúApposcopy: Semantics-
based detection of Android malware through static analysis,‚Äù in FSE,
2014, pp. 576‚Äì587.
[16] S. Zhang, H. L ¬®u, and M. D. Ernst, ‚ÄúFinding errors in multithreaded GUI
applications,‚Äù in ISSTA , 2012, pp. 243‚Äì253.
[17] E. Payet and F. Spoto, ‚ÄúStatic analysis of Android programs,‚Äù IST,
vol. 54, no. 11, pp. 1192‚Äì1201, 2012.
[18] T. Takala, M. Katara, and J. Harty, ‚ÄúExperiences of system-level model-
based GUI testing of an Android application,‚Äù in ICST , 2011, pp. 377‚Äì
386.
[19] C. S. Jensen, M. R. Prasad, and A. M√∏ller, ‚ÄúAutomated testing with
targeted event sequence generation,‚Äù in ISSTA , 2013, pp. 67‚Äì77.
[20] D. Yan, S. Yang, and A. Rountev, ‚ÄúSystematic testing for resource leaks
in Android applications,‚Äù in ISSRE , 2013, pp. 411‚Äì420.
[21] S. Yang, D. Yan, and A. Rountev, ‚ÄúTesting for poor responsiveness in
Android applications,‚Äù in MOBS , 2013, pp. 1‚Äì6.[22] D. AmalÔ¨Åtano, A. R. Fasolino, P. Tramontana, S. De Carmine, and
A. M. Memon, ‚ÄúUsing GUI ripping for automated testing of Android
applications,‚Äù in ASE, 2012, pp. 258‚Äì261.
[23] ‚ÄúG ATOR : Program Analysis Toolkit For Android,‚Äù web.cse.ohio-
state.edu/presto/software/gator .
[24] ‚ÄúOpenManager: File manager for Android,‚Äù github.com/nexes/
Android-File-Manager .
[25] D. Grove and C. Chambers, ‚ÄúA framework for call graph construction
algorithms,‚Äù TOPLAS , vol. 23, no. 6, pp. 685‚Äì746, 2001.
[26] A. Milanova, A. Rountev, and B. G. Ryder, ‚ÄúParameterized object
sensitivity for points-to analysis for Java,‚Äù TOSEM , vol. 14, no. 1, pp.
1‚Äì41, 2005.
[27] Y . Smaragdakis, M. Bravenboer, and O. Lhot ¬¥ak, ‚ÄúPick your contexts
well: Understanding object-sensitivity,‚Äù in POPL , 2011, pp. 17‚Äì30.
[28] A. Rountev and D. Yan, ‚ÄúStatic reference analysis for GUI objects in
Android software,‚Äù in CGO , 2014, pp. 143‚Äì153.
[29] D. Yan, ‚ÄúProgram analyses for understanding the behavior and per-
formance of traditional and mobile object-oriented software,‚Äù Ph.D.
dissertation, Ohio State University, Jul. 2014.
[30] A. Rountev, S. Kagan, and T. Marlowe, ‚ÄúInterprocedural dataÔ¨Çow
analysis in the presence of large libraries,‚Äù in CC, 2006, pp. 2‚Äì16.
[31] ‚ÄúSCanDroid: Security CertiÔ¨Åer for anDroid,‚Äù spruce.cs.ucr.edu/
SCanDroid/tutorial.html .
[32] T. Azim and I. Neamtiu, ‚ÄúTargeted and depth-Ô¨Årst exploration for
systematic testing of Android apps,‚Äù in OOPSLA , 2013, pp. 641‚Äì660.
[33] ‚ÄúIntents and intent Ô¨Ålters,‚Äù developer.android.com/guide/
components/intents-filters.html .
[34] M. Sagiv, T. Reps, and S. Horwitz, ‚ÄúPrecise interprocedural dataÔ¨Çow
analysis with applications to constant propagation,‚Äù TCS, vol. 167, no.
1-2, pp. 131‚Äì170, 1996.
[35] A. M. Memon, ‚ÄúAn event-Ô¨Çow model of GUI-based applications for
testing,‚Äù STVR , vol. 17, no. 3, pp. 137‚Äì157, 2007.
[36] W. Yang, M. Prasad, and T. Xie, ‚ÄúA grey-box approach for automated
GUI-model generation of mobile applications,‚Äù in FASE , 2013, pp. 250‚Äì
265.
[37] P. Zhang and S. Elbaum, ‚ÄúAmplifying tests to validate exception
handling code,‚Äù in ICSE , 2012, pp. 595‚Äì605.
[38] M. Prasad, ‚ÄúPersonal communication,‚Äù 2014.
[39] P. Tramontana, ‚ÄúAndroid GUI Ripper,‚Äù wpage.unina.it/
ptramont/GUIRipperWiki.htm .
[40] S. Liang, A. W. Keep, M. Might, S. Lyde, T. Gilray, P. Aldous, and
D. Van Horn, ‚ÄúSound and precise malware analysis for Android via
pushdown reachability and entry-point saturation,‚Äù in SPSM , 2013, pp.
21‚Äì32.
[41] E. Payet and F. Spoto, ‚ÄúAn operational semantics for Android activities,‚Äù
inPEPM , 2014, pp. 121‚Äì132.
[42] A. M. Memon, I. Banerjee, and A. Nagarajan, ‚ÄúGUI ripping: Reverse
engineering of graphical user interfaces for testing,‚Äù in WCRE , 2003,
pp. 260‚Äì269.
[43] A. M. Memon and Q. Xie, ‚ÄúStudying the fault-detection effectiveness
of GUI test cases for rapidly evolving software,‚Äù TSE, vol. 31, no. 10,
pp. 884‚Äì896, 2005.
[44] F. Gross, G. Fraser, and A. Zeller, ‚ÄúSearch-based system testing: High
coverage, no false alarms,‚Äù in ISSTA , 2012, pp. 67‚Äì77.
[45] P. Wang, B. Liang, W. You, J. Li, and W. Shi, ‚ÄúAutomatic Android GUI
traversal with high coverage,‚Äù in CSNT , 2014, pp. 1161 ‚Äì 1166.