Datalog-Based Scalable Semantic Diffing of Concurrent
Programs
Chungha Sung
University of Southern California
Los Angeles, CA, USAShuvendu K. Lahiri
Microsoft Research
Redmond, WA, USA
Constantin Enea
University Paris Diderot
Paris, FranceChao Wang
University of Southern California
Los Angeles, CA, USA
ABSTRACT
When an evolving program is modified to address issues related to
thread synchronization, there is a need to confirm the change is
correct,i.e.,itdoesnotintroduceunexpectedbehavior.However,
manually comparing two programs to identify the semantic differ-
ence is laborintensive and error prone,whereas techniques based
on model checking are computationally expensive.
To fill the gap, we develop a fastandapproximate static analysis
forcomputingsynchronizationdifferencesoftwoprograms.The
method is fast because, instead of relying on heavy-weight model
checking techniques, it leverages a polynomial-time Datalog-based
programanalysisframeworktocompute differentiating data-flow
edges, i.e., edges allowed by one program but not the other. Al-
though approximationis used ourmethod issufficiently accurate
duetocarefuldesignoftheDataloginferencerulesanditerativein-
creaseoftherequireddata-flowedgesforrepresentingadifference.
Wehaveimplementedourmethodandevaluateditonalargenum-
ber ofmultithreaded C programsto confirmits ability toproduce,oftenwithinseconds,thesamedifferencesobtainedbyhuman;in
contrast,priortechniquesbasedonmodelcheckingtakeminutes
or even hours and thus can be 10x to 1000x slower.
CCS CONCEPTS
â€¢Software and its engineering â†’Software verification and
validation;
KEYWORDS
Concurrency, semantic diffing, change impact, static analysis, race
condition, atomicity, Datalog
ACM Reference Format:
Chungha Sung, Shuvendu K. Lahiri, Constantin Enea, and Chao Wang.
2018. Datalog-Based Scalable Semantic Diffing of Concurrent Programs. In
Proceedingsofthe201833rdACM/IEEEInternationalConferenceonAutomated
Software Engineering (ASE â€™18), September 3â€“7, 2018, Montpellier, France.
ACM,NewYork,NY,USA, 11pages.https://doi.org/10.1145/3238147.3238211
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE â€™18, September 3â€“7, 2018, Montpellier, France
Â© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.32382111 INTRODUCTION
Whenanevolvingconcurrentprogramismodified,oftentimes,the
sequential program logic is not changed; instead, the modification
focusesonthreadsynchronization,e.g.,tooptimizeperformance
or remove bugs such as data-races and atomicity violations. Since
concurrencyishard,itisimportanttoensurethemodificationis
correctanddoesnotintroduceunexpectedbehavior.However,man-
ually comparing two programs to identify the semantic difference
isdifficult,andthesituationisexacerbatedinthepresenceofthread
interactions: changing a single instruction in a thread may have
a ripple effect on many instructions in other threads. Although
techniqueshavebeenproposedtocomputethesynchronizationdif-ference,e.g.,byleveragingmodelcheckers[
14],theyareexpensive
forpracticeuse.Forexample,comparingtwoversionsofaprogram
with 578 lines of C code takes half an hour.
To fill the gap, we develop a fastandapproximate static analysis
tocomputesuchdifferenceswiththegoalofreducinganalysistime
fromhoursorminutestoseconds.Weassumethetwoprograms
are closely related versions of an evolving software where changes
are made to address issues related to thread synchronization asopposed to the sequential computation logic. Therefore, same asin prior works [
14,44], we focus on synchronization differences.
However, our method is orders-of-magnitude faster because in-
steadofmodelcheckingweleverageapolynomial-timedeclarative
programanalysisframeworkwhichusesasetofDatalogrulesto
model and reason about thread interactions.
The reason why prior techniques are expensive is because they
insist on being precise. Specifically, they either enumerate inter-
leavings or use a model checker to ensure a semantic difference,
representedasasetofdata-flowedges,isallowedbyoneofthepro-gramsbutnotbytheother.However,thisingeneralisequivalenttoprogramverification,whichisanundecidableproblem[
43];evenin
cases where it is reduced to a decidable problem, the cost of model
checking is toohigh. Our insight isthat in practice, it isrelatively
easyfordeveloperstoinspecta givendifferencetodetermineifit
is feasible; what is not easy and hence requires tool support is a
systematicexplorationofbehaviorsofthetwoprogramstoidentify
all possible differences in the first place. Unfortunately, developing
such a tool is a non-trivial task; for example, the naive approach of
comparingindividualthreadinterleavingswouldnotworkdueto
the often exponential blowup in the number of interleavings.
Our method avoids the problem by being approximate in that
it does not enumerate interleavings. This also means infeasible
behaviors are sometimes included. However, our approximation is
carefullydesignedtotakeintoconsiderationtheprogramsemantics
656
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. ASE â€™18, September 3â€“7, 2018, Montpellier, France Chungha Sung, Shuvendu K. Lahiri, Constantin Enea, and Chao Wang
	

	

		


	
	


			


			
	

	








	

Figure 1: Overview of our semantic diffing method.
mostrelevanttothreadinteraction.Furthermore,theapproxima-
tioncanberefinedbyiterativelyincreasingthenumberofdata-flow
edgesusedtocharacterizeasynchronizationdifference.Weshall
show through experiments that our fastandapproximate analysis
method does not lead to overly inaccurate results. To the contrary,
the synchronization differences reported by our method closely
matchtheonesidentifiedbyhuman.Comparedtothepriortech-
niquebasedonmodelchecking,whichoftentakesminutesoreven
hours, our method can be 10x to 1000x faster.
Figure1showstheoverallflowofourmethod.Theinputconsists
of two versions of a concurrent program: P1is the original version,
P2is the changed version, and patch info represents their syntactic
difference, e.g., information about which instructions are added,
removed or modified. The output consists of a set of differences,
each of which is represented by a set of data-flow edges allowed in
oneoftheprogramsbutnottheother.Whendata-flowedgesare
allowed in P1but notP2, for example, they represent a removed
behavior.Conversely,whendata-flowedgesareallowedin P2but
notP1, they represent a new behavior introduced by the change.
Our method first generates a set of Datalog facts that encode
thestructuralinformationofthecontrolflowgraphs.Thesefacts
are then combined with inference rules that codify the analysis
algorithm. When the combined program is fed to a Datalog solver,
theresultingfixedpointcontainsnewrelations(facts)thatrepresenttheanalysisresult.Specifically,itcontainsdata-flowedgesthatmayoccurineachprogram.Bycomparingdata-flowedgesfromthetwo
programs, we can identify the semantic differences.
Sinceprogramverificationisundecidableingeneral,andwith
concurrency, it is undecidable even for Boolean programs [ 43],
approximation is inevitable. Our method makes two types of ap-
proximations.Thefirstoneisincheckingthefeasibilityofdata-flow
edges. The second one is related to the number of data-flow edges
used to characterize a difference, also referred to as the rankof
an analysis [ 14]. Although in the worst case, a precise analysis
means the rank needs to be as large as the length of the execution,
we restrict it to a small number in our method because prior re-
search [12,40] shows that concurrency bugs often can be exposed
by executions with a bounded number of context switches.
Since our method is approximate in nature, the usefulness de-
pendsonhowcloseitapproachesthegroundtruth.Ideally,wewanttohavefewfalsepositivesand fewfalsenegatives.Towardthisend,
we choose to stay away from the tradition of insisting the analysis
beingeither soundorcomplete whenonecannothaveboth.Fora
concurrentprogram,beingsoundoftenmeans existential abstrac-
tion: a data-flow edge is considered feasible (in all interleavings)
if it is feasible in an interleaving, and being complete often meansuniversal abstraction:adata-flowedgeisconsideredfeasibleonly
if it is feasible in all interleavings. Both cases result in extremelycoarse-grained approximations, which in turn lead to numerous
false positives or false negatives. Instead, we want to minimize the
difference between our analysis result and the ground truth.
We have implemented our method in a tool named EC-Diff,
which uses LLVM [ 9] as the front-end and Î¼Z[24]i nZ 3a st h e
Datalogsolver.Weevaluated EC-Diffon47multithreadedprograms
with13,500linesofCcodeintotal.Thesearebenchmarkswidely
used in prior research [ 1â€“7,11,13,23,38,47,50â€“52,55]: some
illustraterealconcurrencybugpatterns[ 52]andthecorresponding
patches [29] while others are applications from public repositories.
We applied EC-Diffto these benchmarks while comparing with
thepriortechniqueofBouajjanietal.[ 14].Ourresultsshowthat
EC-Diffcandetect,ofteninseconds,thesamedifferencesidentified
by human. Furthermore, compared to the prior technique based on
model checking, EC-Diffis 10x to 1000x faster.
To summarize, this paper makes the following contributions:
â€¢We propose a fastandapproximate analysis based on a
polynomial-timedeclarativeprogramanalysisframeworkto
compute synchronization differences.
â€¢We show why our approximate analysis is reasonably accu-
rateduetothecustom-designedinferencerulesanditerative
increase of the number of data-flow edges.
â€¢Weimplementourmethodinapracticaltoolandevaluate
it on a large number of benchmarks to confirm its high
accuracy and low overhead.
The remainder of the paper is as follows. First, we motivate our
workusingexamples inSection 2.Then,weprovidethe technical
background in Section 3before presenting our analysis method
in Section 4. This is followed by our procedures for interpreting
the analysis result and optimizing performance in Section 5.W e
present our experimental results in Section 6. Finally, we review
the related work in Section 7and give our conclusions in Section 8.
2 MOTIVATION
We use examples to motivate the need for conducting a differential
analysis. Programs used in these examples illustrate common bug
patterns(alsousedduringourexperimentsinSection 6).Ineach
example, there are two program versions: the original one may
violateahypothetical assertionandthechangedoneavoidsit.These
assertionsarehypothetical(addedforillustrationpurposesonly)
in the sense that our method does not need them to operate.
2.1 The First Example
Fig.2(a)shows a two-threaded program where the shared vari-
able xis initialized to 0. The assertion at Line 3 may be violated,
e.g., when thread1 executes the statement at Line 2 right after
thread2executes the statement at Line 5. The reason is because
no synchronization operation is used to enforce any order.
Assumethedeveloperidentifiestheproblemandpatchesitby
addinglocks(Figure 2(b)),theassertionviolationwillbeavoided.
Toseewhythisisthecase,considerthedata-flowedgefromLine5
to Line 2: due to the critical sections enforced by lock-unlock pairs,theloadof
xatLine2isnotaffectedbythestoreof xatLine5.For
example,ifthecriticalsectioncontainingLine5isexecutedfirst,
thesubsequent unlock(a) mustbeexecutedbeforethe lock(a) in
thread1, which in turn must be executed before Line 1 and Line 2.
657
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. Datalog-Based Scalable Semantic Diffing of Concurrent Programs ASE â€™18, September 3â€“7, 2018, Montpellier, France
thread1{
1:x=x+1 ;
2:if (x == 0)
3:assert(0);
}thread2{
4:x=1 ;
...
5:x=0 ;
}RF
RF
(a) Before change
thread1{
lock(a);
1:x=x+1 ;
2:if (x == 0)
3:assert(0);
unlock(a);
}thread2{
4:x=1 ;
...
lock(a);
5:x=0 ;
unlock(a);
}RF
RF
(b) After change
Figure 2: Example programs with synchronization differ-
ences (lock-unlock).
Since the store of xat Line 1 is the most recent, the load of xat
Line 2 will get its value, not the value written at Line 5.
Thus, the allowed data-flow edges are as follows: RF(L4,L2)
andRF(L5,L2) for the original program, and RF(L4,L2) for the
changedprogram.Thisnotionofcomparingconcurrentexecutions
was introduced by Shasha and Snir [ 44] and extended by Bouajjani
et al. [14], although in both cases, enumeration or model check-
ing techniques were used. In our work, the goal is to avoid such
heavyweight analyses while maintaining sufficient accuracy.
In addition to RFedges, there are other types of relations con-
sidered during our analysis, including program order, inter-thread
orderimposedbythread create,join,signal-wait aswellas store-store
order.Nevertheless,wheninterpretingthefinalresults,wefocus
on differences in the RFedges because they affect the externally
observable behavior of a program, e.g., characterized by assertions
and other reachability properties.
2.2 The Second Example
Fig.3showsamoresophisticatedexample:theuseof signal-wait,
whichisoftendifficultforstaticanalyzers.Sincethevariable xis
initialized to 0, when the critical section in thread1 is executed
before thread2,theloadof xatLine1willgetthevalue0,which
leads to the assertion violation in Fig. 3(a). Assume the intended
behaviorisfor thread2 tocompletefirst,aninter-threadexecution
ordermustbeenforced,e.g.,byusingthe signal-wait pairshown
inFig.3(b).Theassertionviolationisavoidedbecausetheloadof x
at Line 1 can only read from the store of xat Line 5.
Tocorrectlydeploythe signal-wait pair,avariablenamed cBool
needs to be added. If the operating system voluntarily schedules
thread2 first, thread1 needs to be aware â€“ by checking the value
ofcBoolâ€“ and then skips the execution of wait; otherwise, wait
maygetstuckbecausethecorresponding signalhasalreadybeen
fired (and lost). But if thread1is executed first, since cBoolhas
not been set, it will invoke waitwhich forces the corresponding
signalto be sent.
As for the data-flow edges, we can see that RF(L5,L1) and
RF(L3,L4) areallowedintheoriginalprogram,butonly RF(L5,L1)
isallowedinthechangedprogram. RF(L3,L4) isnotallowedbe-
causeLine4musthappenbeforeLine5,Line5musthappenbeforethread1{
lock(a);
1:if (x == 0)
2:assert(0);
3:y = foo(x);
unlock(a);
}thread2{
...
lock(a);
4:bar(y);
5:x=4 ;
unlock(a);
}RF
RF
(a) Before change
thread1{
lock(a);
if (!cBool)
wait(cond);
1:if (x == 0)
2:assert(0);
3:y = foo(x);
unlock(a);
}thread2{
...
lock(a);
4:bar(y);
5:x=4 ;
cBool = 1;
signal(cond);
unlock(a);
}RF
RF
(b) After change
Figure 3: Example programs with synchronization differ-ences (signal-wait).
mustHB {(1,2),(2,3),(1,3),(4,5)}
Fig2(a)mayHB mustHBâˆª{ (1,4),(1,5),(2,4),
(2,5),(3,4),(3,5),(4,1),(4,2),...}
MayRF {(4,1),(4,2),(5,1),(5,2)}
mustHB {(1,2),(2,3),(1,3),(4,5)}
Fig2(b)mayHB mustHBâˆª{ (1,4),(1,5),(2,4),
(2,5),(3,4),(3,5),(4,1),(4,2),...}
MayRF {(4,1),(4,2),(5,1)}
mustHB {(1,2),(2,3),(1,3),(4,5)}
Fig3(a)mayHB mustHBâˆª{ (1,4),(1,5),(2,4),
(2,5),(3,4),(3,5),(4,1),(4,2),...}
MayRF {(3,4),(5,1),(5,3)}
mustHB {(1,2),(2,3),(1,3),(4,5),
Fig3(b) (4,1),(4,2),(4,3),(5,1),(5,2),(5,3) }
mayHB mustHB
MayRF {(5,1),(5,3)}
Figure 4: Analysis steps for programs in Figs. 3(a)and3(b).
signal,and signalmusthappenbefore wait,whichresidesbefore
Lines 1-3 in thread1. Thus, there is a cycle (contradiction).
2.3 How Our Method Works
Ourmethoddiffersfrompriortechniqueswhichrelyoneitherenu-
merating interleavings and conducingpairwise comparison [ 44],
ormodelcheckingbasedtechniques[ 14].Botharecomputationally
expensive. Instead, we use lightweight static analysis.
Our method represents the control and data dependencies of
each program as a set of Datalog facts. We also design a set of
Dataloginferencerules,whichcaptureouralgorithmforderiving
new facts from existing facts. Leveraging a Datalog solver, we can
repeatedly apply the inference rules over the facts until a fixedpointisreached.WewillexplaindetailsofourDatalogfactsand
inference rules in Section 4.
658
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. ASE â€™18, September 3â€“7, 2018, Montpellier, France Chungha Sung, Shuvendu K. Lahiri, Constantin Enea, and Chao Wang
Fornow,considerthestepsofcomputingsynchronizationdif-
ferencesfortheprogramsinFig. 2andFig.3,whichareoutlined
by the tables in Fig. 4.
First,ourmethodcomputesmust-happen-before( mustHB)edges,
which represent the execution order of two instructions respected
by all thread interleavings. From mustHB, our method computes
may-happen-before (mayHB) edges, which represent the execution
orderrespectedbysomeinterleavings,e.g.,threadcontextswitches
not contradicting to mustHB.F r o m mayHB, our method computes
MayRFedges, which represent data flows (over shared variables)
from store instructions to the corresponding load instructions.
The MayRFedges are over-approximated in that, if an edge is
included in MayRF, the corresponding data flow mayoccur in an
execution.Butifanedgeisnotincludedin MayRF,weknowforsure
thecorrespondingdataflowisdefinitelyinfeasible.Forexample,in
Fig.4,MayRFhas four edges for Fig. 2(a)but only three edges for
Fig.2(b). RF(L5,L2) is no longer allowed in the changed program,
indicating it is a difference between the two programs.
For the example in Fig. 3, we compute mustHBbased on the
sequentialprogramorderand,inFig. 3(b),theinter-threadexecu-
tion order imposed by signal-wait. Then, from mustHBwe compute
mayHB,whichincludesedgesin mustHBandmore.ForFig. 3(a),since
there is no restriction on the inter-thread execution order, all pairs
of events are included, whereas for Fig. 3(b), there is only one-way
data flow. Finally, we compute MayRFbased on mayHB. There are
three edges for Fig. 3(a)but only two for Fig. 3(b).
2.4 The Rank of an Analysis
When comparing MayRFin these two examples, we identify the
difference as edges allowed in only one of the two programs, such
asRF(L5,L2)in Fig. 2andRF(L3,L4) in Fig.3.
However, even if MayRFedges are allowed individually, they
maynotoccurinthesameexecution.Forexample, RF(L5,L1) and
RF(L3,L4) inFig.3(a)cannotoccurtogether because, otherwise,
they form a cycle together with the program order edges. Our
method has inferences rules designed to check if two or more data-
flow edges can occur togetherâ€”this is referred to as the rank[14].
Withthenotionofrank,wecancaptureorderedsetsof MayRF
edges, as opposed to individual MayRFedges. Thus, even if the
MayRFrelation remains the same, there may be differences of high
ranks:twoormoreedgesfrom MayRFmayoccurtogetherin P1but
notinP2.Wewillpresentourmethodforcheckingsuchdifferences
in Section 5following the baseline procedure in Section 4.
3 PRELIMINARIES
3.1 Partial Trace Comparison
To compare the synchronizations of two concurrent programs, we
usethenotionofpartialtraceintroducedbyShashaandSnir[ 44]
and extended by Bouajjani et al. [ 14]. LetPbe a program and
Gbe the set of global variables shared by threads in P. For each
xâˆˆG, letW(x)denote a store instruction and R(x)denotes a load
instruction. Let Ibe the set of all instructions in the program. Any
binary relation over these instructions is a subset of IÃ—I.
For example, Ë†soâŠ†IÃ—Iis a relation that orders the store in-
structions; W1(x)<W2(x)meansW1âˆˆIis executed before W2âˆˆI.
Thus, in Fig. 2(a), (L1,L4),(L4,L1),(L1,L5),(L5,L1),(L4,L5)
belong to Ë†so, but (L5,L4)does not belong to Ë†sobecause it is not
consistent with the program order.Similarly, Ë†rfisarelationbetweenloadandstoreinstructions.In
Fig.2(a),wehave (L4,L2) and(L5,L2) inË†rf,meaningtheloadat
Line 2 may read from values written at Lines 4 and 5. Given Ë†soand
Ë†rf,wedefine Ë†setsasasetof subsetsofË†rfâˆªË†so,whereeachelement
ssâˆˆË†setshas at most kedges.
Edgesinssarefromeither Ë†rforË†soâ€“theycapturetheabstract
trace.Thenumber k,whichiscalledthe rank[14],isboundedby
the length of the trace.
Definition1(AbstractTracewithRank k).Anabstracttrace
with rank kis a tuple Ë†T=/angbracketleftË†so,Ë†rf,Ë†sets,k/angbracketright, whereË†soâŠ†{W1(x)Ã—
W2(x)|W1âˆˆI,W2âˆˆI,andW1<W2in some execution trace },
Ë†rfâŠ†{W(x)Ã—R(x)|WâˆˆIandRâˆˆI}, andË†setsâŠ†{ssâŠ†Ë†rfâˆª
Ë†so||ss|â‰¤k}.
Giventheabstracttraces Ë†T1andË†T2oftwoprograms P1andP2,
respectively, we define their difference as Î”=(Î”12,Î”21), where
Î”12=Ë†T1\Ë†T2andÎ”21=Ë†T2\Ë†T1. Next, we define what it means for
Ë†T1to be a refinement of Ë†T2, denoted Ë†T1âŠ†Ë†T2.
Definition 2 (Abstract Trace Refinement). Given two ab-
stract traces Ë†T1=/angbracketleftË†so1,Ë†rf1,Ë†sets1,k/angbracketrightandË†T2=/angbracketleftË†so2,Ë†rf2,Ë†sets2,k/angbracketright,w e
sayË†T1isarefinementof Ë†T2,denoted Ë†T1âŠ†Ë†T2,ifandonlyif Ë†so1âŠ†Ë†so2,
Ë†rf1âŠ†Ë†rf2, andË†sets1âŠ†Ë†sets2.
That is, when Ë†T1âŠ†Ë†T2, the abstract behavior of P1is covered by
that ofP2. And the difference ( Ë†T2\Ë†T1) is characterized by Ë†so2\Ë†so1,
Ë†rf2\Ë†rf1,andË†sets2\Ë†sets1.Finally,iftheabstracttracesof P1and
P2refine each other, we say they are rank-kequivalent.
Althoughcomparisonofabstracttracesinvolves Ë†soandË†rf,when
reportingthedifferences,wefocusonthe Ë†rfedgesonlybecause
they directly affect the observable behaviors of the programs. In
contrast, store-store ordering ( Ë†so) may not be observable unless
they also affect the read-from ( Ë†rf) edges.
3.2 Datalog-Based Analysis
Datalogisalogicprogramminglanguagebutinrecentyearshas
beenwidelyusedfordeclarativeprogramanalysis[ 10,15,16,21,
22,37,48,56]. The main advantage is that a Datalog program is
polynomial-time solvableand the corresponding fixed-pointcom-
putationmapsnaturallytofixed-pointcomputationsinprogram
analysisalgorithms.Inthiscontext,structuralinformationofthe
programisrepresentedasrelationscalledthe facts,whilethefixed-
point algorithm is expressed as recursive relations called the infer-
ence rules.
Consider a relation named PO (a,b), which represents the pro-
gramorderof twoimmediateadjacentinstructions aandb,while
HB(c,d)meanscmusthappenbefore d.First,wewritedownthe
Datalog facts based on the CFG structure:
PO(s1,s2),P O(s1,s3),P O(s2,s4),P O(s3,s4),P O(s4,s5).
Then, we write down the Datalog inference rules:
HB(a,b)â†PO(a,b)
HB(c,e)â†HB(c,d)âˆ§HB(d,e)
Here, the left arrow ( â†) separates the inferred Datalog facts on
the left-hand side from the existing Datalog fact(s) on the right-
hand side. The first rule says the program-order relation impliesthe must-happen-before relation. The second rule says the must-
happen-before relation is transitive.
659
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. Datalog-Based Scalable Semantic Diffing of Concurrent Programs ASE â€™18, September 3â€“7, 2018, Montpellier, France
ADatalogsolver,basedontheabovefactsandrules,willcompute
themaximalsetofedgesfortheHBrelation.Bysendingaqueryto
the Datalog solver, one may confirm that HB(s1,s5)indeed holds
whereas HB( s2,s3)does not hold.
4 CONSTRAINT-BASED SYNCHRONIZATION
ANALYSIS
Inthissection,wepresentourmethodforcomputingabstracttraces
ofasingleprogram.Inthenextsection,weleveragetheabstract
traces of two programs to compute their differences.
First,wedefinetheelementaryrelationsthatcanbeconstructed
directly from the CFG of a program.
â€¢St(s1,th1): Statement s1resides in Thread th1
â€¢Po(s1,s2): Statement s1is befores2in a thread
â€¢Dom(s1,s2): Statement s1dominates s2in a thread
â€¢PostDom( s1,s2):s1post-dominates s2in a thread
â€¢ThrdCreate( th1,s1,th2): Thread th1createsth2ats1
â€¢ThrdJoin( th1,s1,th2): Thread th1joins back th2ats1
â€¢CondWait( s1,v1):s1waits for condition variable v1
â€¢CondSignal( s1,v1):s1sends condition variable v1
â€¢Load(s1,v1): Statement s1reads from variable v1
â€¢Store(s1,v1): Statement s1writes to variable v1
â€¢InCS(s1,l1):s1residesinacriticalsectionguardedbylock( l1)â€“
unlock(l1) pair
â€¢SameCS(s1,s2,l1):s1ands2arein thesamecritical section
guarded by l1
â€¢DiffCS(s1,s2,l1):s1ands2are in different critical sections
guarded by l1
While traversing the CFG to compute the Po, Dom, and Post-
Dom relations, we take loops into consideration. For example, two
instructionsinvolvedwiththesameloopmaynothaveaDomor
PostDomrelation,butaninstructionoutsidetheloopcanhavea
Dom or PostDom relation with an instruction inside the loop.
Next,wedefineinferencerulesforcomputingnewrelationssuch
as MayHb, MustHb, and MayRf.
4.1 Rules for Intra-thread Dependency
To capture the execution order of instructions, we define the fol-
lowing relations: MayHb(s1,s2)meanss1may happen before s2in
someexecution,and MustHb( s1,s2)meanss1happensbefore s2in
allexecutions whenboth occur.Since theprogram orderin each
thread implies the execution order, we have the following rule:
MustHb(s1,s2)â†Po(s1,s2)
In this work, we assume sequential consistency but Datalog is capa-
ble of handling weaker memory models [32] as well.
By definition MustHb implies MayHb, which means
MayHb(s1,s2)â†MustHb(s1,s2)
4.2 Rules for Inter-thread Dependency
Whenaparentthread th1createsachildthread th2atthestatement
s1,e.g.,byinvoking pthread_create ,anystatement s2inthechild
thread must occur after s1.
MustHb(s1,s2)â†ThrdCreate (th1,s1,th2)âˆ§St(s2,th2)
Similarly, when a parent thread th1joins back a child thread th2at
s1, any statement s2inth2must occur before s1.
MustHb(s2,s1)â†ThrdJoin (th1,s1,th2)âˆ§St(s2,th1)thread1() {
a=1 ;
cond = true;
}thread2() {
while(!cond) {}x=a ;
}
Figure 5: Ad hocsynchronization (cond = false initially).
4.3 Rules for Signal-Wait Dependency
When a condition variable cis used, e.g., through signal(c) and
wait(c), it imposes an execution order.
MustHb(s1,s2)â†CondSignal (v1,s1)âˆ§CondWait (v1,s2)
However, the rule needs to be used with caution. In practice,
wait(c)is often wrapped in an if-condition as shown in Figure 3(b).
To be conservative, our method analyzes the control flow of these
threadsandappliestheaboveruleonlyafterdetectingtheusage
pattern. Since our method doesnot analyze the concrete values of
anysharedvariables,itdoesnotcheckiftheif-conditionisvalid.
Also, developers may use condition variables in a different way.
Thus,inourexperiments(Section 6),weevaluatedtheimpactof
this conservative approachâ€”assuming the if-condition is always
validâ€”to confirm it does not lead to significant loss of accuracy.
4.4 Ad Hoc Synchronization
We handle ad hocsynchronization similar to signal-wait. Fig. 5
shows an example where condis a user-added flag initialized to
0. The busy-waiting in thread2 ensures that a=1always occurs
before x=a.BytraversingtheCFGsofthesethreads,wecanidentify
the pattern; this is practical since the number of usage patterns
islimited.Afterthat,weaddaMustHbedgefrom cond=true to
while(!cond) . This is similar to adding MustHb edges for Cond-
Wait and CondSignal. As a result, we can decide the read-from
edge between x=aand the initialization of ais infeasible.
4.5 Transitive Closure
SinceMustHbistransitive,weusethefollowingruletocompute
the transitive closure:
MustHb(s1,s3)â†MustHb(s1,s2)âˆ§MustHb(s2,s3)
WheninstructionsinconcurrentthreadsarenotorderedbyMustHb,
we assume they may occur in any order:
MayHb(s1,s2)â†St(s1,th1)âˆ§St(s2,th2)âˆ§Â¬MustHb(s2,s1)
The MayHb relation is also transitive:
MayHb(s1,s3)â†MayHb(s1,s2)âˆ§MayHb(s2,s3)
4.6 Lock-Enforced Critical Section
For critical sections based on lock-unlock, we introduce rules based
on access patterns. First, we compute CoveredStore( s1,v1,l1),
meaning the store in s1is overwritten by a subsequent store in
the same critical section. Consider lk(a)â†’W1(v)â†’W2(v)â†’unlk(a),
whereW1(v)is a covered store and thus not visible to reads in
other critical sections protected by the same lock.
CoveredStore (s1,v1,l1)â†Store(s1,v1)âˆ§Store(s2,v1)
âˆ§PostDom (s2,s1)âˆ§SameCS(s1,s2,l1)
Similarly, CoveredLoad (s2,v1,l1)means the load of v1ins2is
covered and thus can only read from a preceding store in the same
660
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. ASE â€™18, September 3â€“7, 2018, Montpellier, France Chungha Sung, Shuvendu K. Lahiri, Constantin Enea, and Chao Wang
P1P2 P2P1
Figure 6: Differences of abstract traces: Î”12(left) and Î”21
(right).
critical section.
CoveredLoad (s2,v1,l1)â†Store(s1,v1)âˆ§Load(s2,v1)
âˆ§Dom(s1,s2)âˆ§SameCS(s1,s2,l1)
Consider lk(a)â†’W(v)â†’R(v)â†’unlk(a)as anexample: R(v)is cov-
ered by W(v)and thus cannot read from stores in other critical
sections protected by the same lock.
4.7 Read-from Relation
Finally, we compute NoRf (s1,s2)which means the read-from edge
betweens1ands2is infeasible.
NoRf(s1,s2)â†Store(s1,v1)âˆ§Store(s3,v1)âˆ§Load(s2,v1)
âˆ§MustHb(s1,s3)âˆ§MustHb(s3,s2)
That is, in W(x)â†’W(x)â†’R(x), the first store cannot be read
by the load. In addition to this generic rule, we have two more
inference rules:
NoRf(s1,s2)â†Store(s1,v1)âˆ§Load(s2,v1)âˆ§MayHb(s1,s2)
âˆ§CoveredLoad (s2,v1,l1)âˆ§DiffCS(s1,s2,l1)
Thisrulemeansifonestoremayhappenbeforeoneload,theloadis
covered, and the store is in a different critical section, the load can-
notreadfromthestore.Thisisbecauseanotherstorewilloverwrite
the value to be read.
NoRf(s1,s2)â†Store(s1,v1)âˆ§Load(s2,v1)âˆ§MayHb(s1,s2)
âˆ§CoveredStore (s1,v1,l1)âˆ§DiffCS(s1,s2,l1)
This rule means if a store is covered, i.e., overwritten by a subse-
quent store, the store cannot reach to any load in other critical
sections protected by the same lock.
We also compute MayRf (s1,s2)which means the load in s2may
read from the store in s1.
MayRf(s1,s2)â†Store(s1,v1)âˆ§Load(s2,v1)âˆ§MayHb(s1,s2)
âˆ§Â¬NoRf(s1,s2)
5 COMPUTING THE DIFFERENCES
In this section, we show how to compare abstract traces of the two
programs to identify the differences.
5.1 Symmetric Difference
Fig.6shows the Venn diagram of our method for computing the
differences when given the abstract traces of two programs. The
actual behaviors of programs P1andP2are represented by the
circles with solid lines. The approximate behaviors, in the form of
abstracttraces Ë†T1andË†T2,arerepresentedbythecircleswithdashed
lines. Conceptually, the symmetric difference is computed based
onÎ”12=Ë†T1\Ë†T2andÎ”21=Ë†T2\Ë†T1, and for each is presented as
pink-colored region in Fig. 6(left and right). The details of them
are presented in the remainder of this section.
To computethe difference, we definetwo relationsDiffP1 and
DiffP2 and rules for computing them:
DiffP1(s1,s2)â†MayRf(s1,s2,P1)âˆ§Â¬MayRf(s1,s2,P2)
DiffP2(s1,s2)â†MayRf(s1,s2,P2)âˆ§Â¬MayRf(s1,s2,P1)s1:W(x) s2:W(x)
s3:R(x)RF RFs4:R(x)
s1:W(x)s2:R(x)
s3:W(x)RF RF MustHB MustHB
Figure 7: Illustrating the first two rank-2 inference rules.
DiffP1 represents edges that may happen in P1but not in P2. Sim-
ilarly, DiffP2 represents edges that may happen in P2but not in
P1.If DiffP1isnotempty,therearemorebehaviorsin P1;andif
DiffP2 is not empty, there are more behaviors in P2.
Since the Datalog solver may enumerate all possible MayHb
edges (used to compute MayRf), and the number of MayHb edges
increases rapidly as the program size increases, we need to reduce
the computational overhead. Our insight is that, since we are only
concerned with synchronization differences in the end, as opposed
to behaviors of the sequential computation, we can restrict our
analysis to instructions that access global variables. Toward this
end,wedefine anewrelationnamed Access(v1,s1)whichmeans
s1accesses a global variable v1, and use it to guard the inference
rules for MayHb (and hence MustHb). It forces the Datalog solver
to consider only global accesses, which reduces the computational
overheadwithoutlosingaccuracy.Wedemonstratetheeffectiveness
of this optimization using experiments in Section 6.
5.2 Differences at Higher Ranks
The rules so far use individual read-from edges to characterize the
differences,whichisequivalentto rank-1analysis[ 14],butsome
programsmaynothaverank-1differencebuthavedifferencesof
higherranks.Todetectthem,weneedtocompute orderedsetsof
data-flow edges allowed in one program but not in the other.
To be specific, for rank-2, we extend the MayRf relation, which
wasdefinedovertwoinstructions(anedge),toMayRfsdefinedover
four instructions, to represent an ordered set of (two) read-from
edges.Similarly,weextendtheNoRfrelationtoNoRfs,whichis
alsodefinedoverfourinstructionstorepresentanorderedsetof
(two)read-from edges.
Previously, NoRf(s1,s2)meansthereisnoexecutiontracewhere
thestores1canbereadbytheload s2,whereas MayRf(s1,s2)means
theremayexistsomeexecutiontracethatallowsthe read-from edge
(s1,s2). Similarly, NoRfs((s1,s2),(s3,s4))means there is no execu-
tion trace where the two read-from edges(s1,s2)and(s3,s4)occur
togetherandinthatorder;and MayRfs(( s1,s2),(s3,s4))meansthere
mayexistsomeexecutiontracethatallowsthetwo read-from edges
to occur together and in that order.
First, we present our rules for computing NoRfs, which in turn
isusedtocompute MayRfs.Sinceitisnotpossibletoenumerate
all scenarios due to theoretical limitations, we resort to the mostcommon scenarios. Nevertheless, we guarantee that
NoRfsis an
under-approximation, and the corresponding MayRfsis an over-
approximation.
NoRfs((s1,s3),(s2,s3)) â†MayRf(s1,s3)âˆ§MayRf(s2,s3)
Thisruleisobviousbecause,asinFig. 7(left),inthesameexecution
trace a load ( s3) cannot read from two different stores ( s1,s2).
NoRfs((s1,s2),(s3,s4)) â†MayRf(s1,s2)âˆ§MayRf(s3,s4)
âˆ§MustHb(s2,s3)âˆ§MustHb(s4,s1)
661
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. Datalog-Based Scalable Semantic Diffing of Concurrent Programs ASE â€™18, September 3â€“7, 2018, Montpellier, France
lk(l1)
s1:W(x)
s4:R(x)
unlk(l1)lk(l1)
s2:R(x)
s3:W(x)
unlk(l1)RF
RFlk(l1)
s4:R(x)
unlk(l1)s1:W(x) lk( l1)
s2:R(x)
s3:W(x)
unlk(l1)RF
RF
PostDom
Figure 8: Illustrating rank-2 rules related to lock-unlock.
Thisruleisalsoobviousbecause,asshowninFig. 7(right),ifthetwo
read-from edgesformacycletogetherwiththemust-happen-before
edges, they lead to a contradiction.
NoRfs((s1,s2),(s3,s4)) â†SameCS(s1,s4,l1)âˆ§SameCS(s2,s3,l1)
âˆ§DiffCS(s1,s2,l1)
This rule is related to lock-unlock pairs. The rationale behind it can
beexplainedusingthediagraminFig. 8(left).Duetothe lock-unlock
pairs, there are only two possible interleavings: (1) if s1happens
befores2,s4musthappenbefore s3ands2,whichcontradictstothe
read-from edge (s3,s4); (2) ifs3happens before s4,s2must happen
befores1, which contradicts to the read-from edge (s1,s2). Thus,
the read-from edges cannot occur in the same execution trace.
Next, we define another rule related to lock-unlock pairs. In this
rule, we use PostDom (s3,s2)to mean, after s2is executed, s3is
guaranteed to be executed as well.
NoRFs((s1,s2),(s1,s4)) â†Store(s3,v1)âˆ§PostDom (s3,s2)
âˆ§DiffCS(s2,s4,l1)âˆ§SameCS(s2,s3,l1)
Therationalebehindthisrulecanbeexplainedusingthediagramin
Fig.8(right). Here, the loads and stores access the same variable. If
theread-fromedge (s1,s2)isaheadof (s1,s4)inthesameexecution
trace, the store in s3contradicts to the read-from edge (s1,s4).
Finally, we compute MayRFs based on NoRFs:
MayRFs((s1,s2),(s3,s4)) â† Â¬NoRFs((s1,s2),(s3,s4))
Itmeanstheread-fromedges( s1,s2)and(s3,s4)mayoccurtogether
andinthatorderinsomeexecutiontrace.WithMayRFs,wecom-
pute differences (DiffP1 and DiffP2) by replacing MayRf with
MayRFs.Ourmethodforcomputingdifferencesofrank3orhigher
are similar, and we omit the details for brevity.
5.3 Example for Rank-2 Analysis
Fig.9showsanexamplethatillustratestherank-2analysis.Here,
thread1 setstto0and xto1beforecreating thread2.Duetolock-
unlock pairs, the assertion cannot be violated in Fig. 9(a). However,
ifthelock-unlockin thread1isremovedasinFig. 9(b),theassertion
may be violated because, in between Lines 4 and 5, there may be a
context switch which was not allowed previously.
However, the synchronization difference cannot be captured by
anyindividual MayRFedge.Infact,thetableinFig. 10showsthat
the two programs have the same set of MayRFedges. In particular,
since there are two stores of x, the load at Line 2 may read from
both Line 1 and Line 5.
To capture the difference, we need rank-2 analysis.
â€¢Assume RF(L1,L4) occurs first, meaning thread2 acquires
thelockand thusprevents thread1 fromacquiringthesamethread1{
t=0 ;
1:x=1 ;
create(t2);
lock(a);
...
2:assert(x != t);
unlock(a);
}thread2{
...
lock(a);
4:t=x ;
...
5:x=2 ;
unlock(a);
...
}1:RF
2:RFRF
(a) Before change
thread1{
t=0 ;
1:x=1 ;
create(t2);
lock(a);
...
2:assert(x != t);
unlock(a);
}thread2{
...
lock(a);
4:t=x ;
...
5:x=2 ;
unlock(a);
...
}1:RF
HB2:RF
(b) After change
Figure 9: Example programs with rank-2 differences.
mustHB {(1,2),(1,4),(1,5),(4,5)}
Fig9(a)mayHB mustHBâˆª{ (2,4),(2,5),(4,2),(5,2)}
MayRF {(1,2),(1,4),(5,2)}
Rank2 {[(1,2)â†’(1,4)],[(1,4)â†’(5,2)]}
mustHB {(1,2),(1,4),(1,5),(4,5)}
Fig9(b)mayHB mustHBâˆª{ (2,4),(2,5),(4,2),(5,2)}
MayRF {(1,2),(1,4),(5,2)}
Rank2 {[(1,2)â†’(1,4)],[(1,4)â†’(5,2)],
[(1,4)â†’(1,2)]}
Figure 10: Steps of our analysis for the programs in Fig. 9.
lock until thread2 exits the critical section. It means the
store at Line 5 will set xto 2. Therefore, the load of xat
Line 2 will have to read from Line 5, not from Line 1. In
other words, RF(L1,L2) cannot occur after RF(L1,L4) in
the same execution.
â€¢Assume RF(L1,L2) occurs first and thread2 will not be
executeduntil thread1finishes.Inthiscase, RF(L1,L4) is
allowed since no store of xis in thread1.
Asaresult,theprograminFig. 9(a)allowstheorderedset{ RF(L1,L2) ,
RF(L1,L4)} but not the ordered set {RF(L1,L4), RF(L1,L2)}.
However,theprograminFig. 9(b)allowstheorderedset{ RF(L1,L4) ,
RF(L1,L2) } as well, due to the removal of the lock-unlock pairs
inthread1. Specifically, when RF(L1,L4) occurs at the start of an
execution, thread1 may execute Line 2 before thread2 execute
Line 5, which allows Line 2 to read the value of xfrom Line 1.
Our steps of conducting the rank-2 analysis, based on inference
rulespresentedsofar,areshowninFig. 10.Thereisnodifferencein
theMayRFsets;however,whencomparingtheorderedsetof MayRF
edges,wecanstillseethedifference.Tosupportthisanalysis,we
apply the aforementioned inference rules of rank 2, which checks
the existence of (1,4)â†’(1,2).
662
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. ASE â€™18, September 3â€“7, 2018, Montpellier, France Chungha Sung, Shuvendu K. Lahiri, Constantin Enea, and Chao Wang
6 EXPERIMENTS
We have implemented the method in a tool named EC-Diff, which
uses LLVM [ 9] as the frontend and Î¼Z[24] in Z3 as the Datalog
solveratthebackend.Specifically,weuseClang/LLVMtoparsethe
C/C++ code of multithreaded programs and construct the LLVM
intermediaterepresentation(IR).Then,wetraversetheLLVMIR
to generate program-specific Datalog facts. These Datalog facts,
whencombinedwithasetofprogram-independentinferencerules,
form the entire Datalog program. Finally, the Î¼ZDatalog solver is
used to solve the program, which repeatedly applies the rules to
the fact until a fixed point is reached. By querying relations in the
fixed point, we can retrieve the analysis result.
6.1 Experimental Setup
We usedtwo setsof benchmarks inour experiments.The firstset
ofbenchmarks consistsof41 multithreadedprograms, whichpre-
viously [29] have been used to illustrate concurrency bug patterns
found in real applications [ 1â€“7,11,13,23,38,51,52]. With these
programs, our goal is to evaluate how well the various types of
concurrency bugs are handled by our method, and how our results
comparetothatofthepriortechniquebasedonmodelchecking[ 14].
Forthesebenchmarks,thepriortechniqueisnotabletosoundly
instrument all applications. Therefore, we manually insert asser-
tions to be checked later by the CBMC bounded model checker for
detecting only one different edge.
The second set of benchmarks consists of 6 medium-sized appli-
cations from open-source repositories; they have also been used
previously [ 49,52] to evaluate testing and automated program re-
pairtools.Similarly,wearenotabletoapplythepriortechnique[ 14]
because it has limitations to instrument large size programs and it
is impossible for us to manually insert assertions. Nevertheless, wecanevaluatehowefficientournewmethod EC-Diffisonthesereal
applications. In total, our benchmarks has 13,500 lines of C code.
For each benchmark program, there are two versions, one of
whichistheoriginalprogramandtheotheristhechangedprogram.
Thesechangedprogramsarepatchescollectedfromvarioussources:
some are from benchmarks used in prior research on testing [ 49,
52]andrepair[ 29],whereasothersarefrombenchmarksusedin
differentialanalysis[ 14].Wealsocreatedfourprograms, case1-4,to
illustratemotivatingexamplesusedthroughoutthispaper.These
benchmark programs, together with our experimental data, the
LLVM-based tool, as well as data obtained from applying the prior
technique [14], have been made available online1.
Our experiments were designed specifically to answer the fol-
lowing research questions:
â€¢Isournewmethod,basedona fastandapproximate static
analysisasopposedtoheavy-weightmodelcheckingtech-
niques,accurateenoughforidentifyingtheactualsynchro-
nization differences in the benchmark programs?
â€¢Is our new method significantly more efficient, measured in
terms of the analysis time, than the prior technique based
on model checking?
In all these experiments, we used a computer with an Intel Corei5-4440 CPU @ 3.10 GHz x 4 CPUs with 12 GB of RAM, running
the Ubuntu-16.04 LTS operating system.
1https://github.com/ChunghaSung/EC-Diff6.2 Results on the First Set of Benchmarks
Table1shows our results on the first set of benchmarks, with 41
programsillustratingcommonbugpatterns.Columns1and2show
thenameandthenumberoflinesofC code.Column3showsthe
number of threads. Column 4 shows the type of bug illustrated by
the program. Specifically, Sync.means the bug is due to misuse
of locks, and thus to repair it, some lock-unlock pairs have been
added,removedormodified; Cond.meansthebugisduetomisuse
of condition variables, and thus to repair it, some signal-wait pairs
havebeenadded,removedormodified; Th.Order meansthebugis
related to thread creation and join and thus involves ThrdJoin or
ThrdCreate; and Order.means the bugis related to ordering of
instructionsimposedbyad-hocsynchronization.Notethat,ineach
of these benchmarks, there is some synchronization difference.
The remaining columns show the statistics reported by EC-Diff
as well as the prior technique [ 14]. Specifically, Column 5 shows if
EC-Diffdetected the synchronization difference. Column 6 shows
at which rank our analysis is conducted (Section 5): we iteratively
increasetherankstartingfrom1,untilasynchronizationdifference
is detected. To be efficient, we bound the rank to 3 during ourevaluation. Columns 7 and 8 show the number of differences in
Î”12=Ë†T1\Ë†T2andÎ”21=Ë†T2\Ë†T1. For a rank-1 analysis, it is the
numberofread-fromedges;forarank-2orrank-3analysis,itisthe
number of ordered sets of read-from edges. The next two columns
show the total number of MayHb edges (used to compute MayRf)
inP1andP2, respectively.
The last two columns compare the analysis time of our method
andthemodelcheckingtimeofthepriortechnique[ 14]tocheck
one different edge.
For each benchmark, we limit the run time to one hour.
Our results show EC-Diffoften finishes each benchmark in a
secondwhereasthepriortechniquecantakeupto2,384seconds
(rtl8169-2 ). In total, EC-Difftook less than 16 seconds whereas
thepriortechniquetookmorethan3hours.Intermsofaccuracy,
exceptforoneprogram, EC-Diffdetectedallthesynchronization
differences. This has been confirmed through manual inspection
wherethereporteddifferencesarecomparedwiththegroundtruth.
Sincewehaverandomlylabeledtheoriginalandchangedprograms
asP1andP2, some of the differences are in Î”12whereas the others
arereportedin Î”21.Intotal, EC-Difffound251differencesin Î”12
and 151 differences in Î”21.
The missed difference resides in rtl8169-3: after running the
rank-3 analysis, our method still could not find it. The reason isbecause the differentiating behavior involves a deadlock and the
patchthatremovedit.Weexplainwhyourmethodcannotdetect
it in Section 6.4.
6.3 Results on the Second Set of Benchmarks
Table2shows our results on the second set of benchmarks, con-
sisting of six medium-sized programs. Note that these programsarealreadyoutofthereachofthepriortechnique[
14]duetoits
requirementofmanualcodeinstrumentation;therefore,weonlyreport the statistics of applying EC-Diff. Again, the original and
modified programs are randomly labeled as P1andP2, respectively,
to facilitate evaluation.
IntotalEC-Difffound30differencesin Î”12and42differencesin
Î”21.Furthermore,allofthemwerefoundduringrank-1analysis,
and confirmed by manual inspection. What is impressive is thatthese differences were identified by sifting through a combined
663
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. Datalog-Based Scalable Semantic Diffing of Concurrent Programs ASE â€™18, September 3â€“7, 2018, Montpellier, France
Table 1: Experimental results on the first set of benchmark programs.
EC-Diff Prior Technique [14]
Name LoC Threads Type Difference Rank |Î”12||Î”21|# of mayHB in P1# of mayHB in P2Time (s) Time (s)
case1 52 3 Sync. yes 1 0 7 1,343 1,343 0.26 11.53
case2 53 3 Cond. yes 1 0 3 1,357 1,474 0.26 4.80
case3 67 3 Th.Order yes 1 2 0 546 482 0.19 46.64case4 94 3 Sync. yes 2 0 1 421 421 0.20 8.59
i2c-hid [14] 76 3 Sync. yes 1 1 0 2,570 2,570 0.28 27.28
i2c-hid-noa [14] 70 3 Sync. yes 1 1 0 1,573 1,573 0.26 7.48
r8169-1 [14] 65 3 Order yes 1 1 0 870 852 0.25 3.38
r8169-2 [14] 80 3 Order yes 1 1 0 873 839 0.25 2.17
r8169-3 [14] 105 4 Order yes 1 1 0 769 769 0.25 8.37
rtl8169-1 [14] 578 8 Order yes 1 1 0 60,741 60,691 0.89 1580.16
rtl8169-2 [14] 578 8 Order yes 1 1 0 60,741 60,741 0.89 2384.14
rtl8169-3 [14] 578 8 Order no 3 0 0 60,741 60,741 2.40 0.00
cherokee [52] 150 3 Sync. yes 1 0 2 1,148 1,148 0.31 7.59
transmission [52] 91 3 Cond. yes 1 1 0 690 613 0.29 6.89
apache-21287 [52] 74 3 Sync. yes 1 2 0 1,406 1,406 0.27 6.29
apache-25520 [52] 181 3 Sync. yes 2 8 0 3,206 3,206 0.33 23.81
account [11] 82 4 Cond. yes 1 0 2 3,701 3,881 0.30 13.46
barrier [11] 138 4 Cond. yes 1 3 0 7,289 6,655 0.26 150.54
boop [11] 134 3 Sync. yes 1 3 0 2,625 2,625 0.25 8.90
fibbench [11] 63 3 Cond. yes 1 0 71 5,248 6,321 0.28 1483.33
lazy [11] 76 4 Cond. yes 2 0 6 3,409 3,549 0.24 32.16
reorder [11] 170 5 Cond. yes 1 3 0 9,493 8,737 0.40 12.79
threadRW [11] 147 5 Cond. yes 1 2 0 9,092 8,552 0.30 7.57
lineEq-2t [13] 90 3 Sync. yes 2 0 8 2,905 2,905 0.30 23.34
linux-iio [13] 114 3 Sync. yes 1 3 0 5,851 5,851 0.31 24.13
linux-tg3 [13] 130 3 Cond. yes 1 2 0 15,979 15,160 0.63 617.01
vectPrime [13] 127 3 Sync. yes 2 2 0 35,014 35,014 0.52 2.22
mozilla-61369 [38] 84 3 Cond. yes 1 0 1 473 565 0.25 3.57
mysql-3596 [38] 92 3 Cond. yes 1 1 0 773 733 0.25 3.82
mysql-644 [38] 110 3 Cond. yes 1 0 2 1,343 1,434 0.33 5.40
counter-seq [23] 47 3 Sync. yes 2 0 2 1,135 1,135 0.26 18.13
ms-queue [23] 116 3 Sync. yes 2 2 0 5,754 5,754 0.59 29.01
mysql5 [29] 59 3 Sync. yes 2 0 4 1,283 1,283 0.20 22.92
freebsd-a [51] 176 4 Cond. yes 1 0 22 7,910 10,109 0.33 25.40
llvm-8441 [7] 127 3 Cond. yes 1 0 10 3,042 3,118 0.41 16.36
gcc-25530 [2] 87 3 Sync. yes 2 2 0 806 806 0.20 12.15
gcc-3584 [3] 83 3 Sync. yes 2 2 0 1,843 1,843 0.24 17.23
gcc-21334 [1] 136 3 Sync. yes 2 8 0 5,290 5,290 0.35 195.20
gcc-40518 [4] 102 3 Sync. yes 1 0 8 3,027 3,027 0.25 14.31
glib-512624 [5] 95 3 Sync. yes 1 198 0 5,748 5,748 0.32 âˆ—>3600.00
jetty-1187 [6] 69 3 Sync. yes 2 0 2 885 885 0.22 19.34
Total 251 151 338,913 339,849 15.57 >3h
âˆ—>3600.00 means verification of the edge in P1succeeded, but verification of the edge in P2timed out after an hour.
total of 24 million MayHb edges, and yet, the analysis of all pro-
gramstookonly140seconds.Theefficiencyis,inlargepart,due
to the restriction of our analysis on instructions that access global
variables as opposed to all instructions in the program (refer to the
last paragraph of Section 5.1). Otherwise, the number of MayHb
edges would have been orders-of-magnitude larger.
6.4 Discussion
Now, we answer the two research questions.
Q1:IsEC-Diffaccurateenoughforidentifyingsynchronizationdif-
ferences? The answer is yes. As shown in our experimental results,
EC-Diffproduced a large number of differences, the majority of
which are at rank 1, which means they are individual read-from
edgesallowedinonlyoneofthetwoprograms,while therestare
at rank 2. Although we do not guarantee that EC-Difffinds alldifferentiating behaviors, these detected ones have been confirmed
by manual inspection.
Given that these benchmarks contain real concurrency bug pat-
terns reported and analyzed by many existing tools for testing and
repair, the result of EC-Diffis sufficiently accurate. The success
inalargepartisduetothenatureoftheseprograms,wheretwo
versionsbehavealmostsameexceptforthethreadsynchronization.
In such cases, our approximate analysis can come really close to
the ground truth.
Q2: IsEC-Diffmore efficient than the prior technique based on model
checking? The answer is yes. As shown in our results, EC-Diffwas
10x to 1000x faster and, in total, completed the differential analysis
of 13,500 lines of multithreaded C code in about 160 seconds. In
contrast,thepriortechniquetookamuchlongertimetoanalyze
these programs.
664
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. ASE â€™18, September 3â€“7, 2018, Montpellier, France Chungha Sung, Shuvendu K. Lahiri, Constantin Enea, and Chao Wang
Table 2: Experimental results on the second set of benchmark programs.
EC-Diff
Name LoC Threads Type Difference Rank |Î”12|| Î”21|# of mayHB in P1# of mayHB in P2Time (s)
pbzip-1 [49, 52] 1,143 5 Th.Order yes 1 6 0 782,846 773,934 14.98
pbzip-2 [49, 52] 1,143 7 Th.Order yes 1 12 0 1,150,404 1,135,428 30.61
aget-1 [49, 52] 1,523 4 Cond. yes 1 4 0 1,099,047 1,078,695 9.41
aget-2 [49, 52] 1,523 6 Cond. yes 1 8 0 3,218,034 3,162,684 28.60
pfscan-1 [49] 1,327 3 Cond. yes 1 0 6 2,094,446 2,107,760 19.72
pfscan-2 [49] 1,327 5 Cond. yes 1 0 36 4,138,361 4,164,989 39.96
Total 30 42 12,483,138 1,242,3490 140.28
thread1() {
lock(a);
lock(b);
...unlock(b);unlock(a);
}thread1() {
lock(b);
lock(a);
...unlock(a);unlock(b);
}
Figure 11: Code from rtl8169-3: the original (left) and
changed (right) versions.
Thus, we conclude that EC-Diffis effective in identifying syn-
chronizationdifferencesinevolvingprograms.Inpractice,when
developers update a program to fix concurrency bugs or remove
performance bugs (e.g., by eliminating redundant locks), the differ-
ences in behavior are often reflected in (sets of) data-flow edges
being feasible in one version but not in the other version. Thus,computing these (sets of) data-flow edges can be a fast way of
checking if the changes introduce unexpected behaviors.
The Missing Case: Although EC-Diffdetected most of the actual
differences,itmissedonein rtl8169-3.Fig. 11showsthecodesnippet
ofthread1 from the original program ( P1on the left) and the
changed program ( P2on the right). The purpose of this patch is to
resolve a deadlock issue by changing the acquisition order of locks.
SinceEC-Difffocuses solely on data-flow edges, it is not able to
detectbehavioraldifferencesrelatedtolockingonly.Insomesense,
this is a limitation shared by techniques relying on the notion of
abstract traces [ 14,44]: the two programs do not have data-related
semanticdifferenceotherthanthefactthatadeadlockexistsinone
program but does not exist in the other program.
7 RELATED WORK
There has been prior work on statically computing the semantic
differences of sequential and concurrent programs.
For sequential programs, Jackson and Ladd [ 26]p r o p o s e da
method for computing the semantic differences by summarizing
andcomparingthedependenciesbetweeninputandoutput.God-
lineandStrichman[ 18]proposedtheuseofinferencerulestoprove
the equivalence of two programs. In the SymDiffproject, Lahiri et
al.[33,34]developedalanguage-agnosticassertioncheckingtool
for computing the differences ofimperative programs. In the con-
textofincrementalsymbolicexecution[ 42],variouschange-impact
analysistechniqueswereusedtoidentifyinstructionsthatareaf-
fected by code modification and use the information to compute
thecorrespondingtestinputs[ 39].However, thesemethodsarenot
directly applicable to concurrent programs.
For concurrent programs, Joshi et al. [ 28] proposed the use of
failurefrequenciesofassertionstocomparetwoprograms,while
the general framework of refinement checking [ 8] could also beappliedtotracesoftwoprograms.However,thesetechniquesare
limited to individual executions. Change-impact analysis [ 36] were
alsoappliedtoconcurrentprograms,e.g.,inregressiontesting[ 54],
prioritized scheduling [ 27,30], and incremental symbolic execu-
tion[19,53].However,thesetechniquesfocusonreducingthecost
oftestingandanalysisasopposedtoidentifyingthesynchroniza-
tion differences.
Aswe havementionedearlier, themostclosely relatedworkis
that of Bouajjani et al. [ 14], which computes the differences be-
tween partial data-flow dependencies of two concurrent programs
using a bounded model checker. However, the method is costly;
furthermore,itrequirescodeinstrumentationtoinsertassertions
so they can be verified using a model checker. For example, it took
about30minutesforaprogram(rtl8169)thatcanbeanalyzedby
our method in less than a second.
Our method relies on the Datalog-based declarative program
analysis framework, which previously has been applied to both
sequentialandconcurrentprogramsaswellaswebapplications[ 10,
15,17,19â€“22,25,35,37,41,45,48,56].Inthecontextofstaticanaly-
sisofconcurrentprograms,forexample,KusanoandWang[ 31,32]
used Datalog in a thread-modular abstract interpretation to check
the feasibility of inter-thread data-flow edges on sequentially con-
sistent and weaker memory models. Sung et al. [ 46] used a similar
techniqueformodelingpreemptionschedulingofinterruptsand
thus improving the accuracy of static analysis for interrupt-driven
programs. However, none of these existing methods computes the
synchronization differences of evolving programs.
8 CONCLUSIONS
Wehavepresenteda fastandapproximate staticanalysismethod
forcomputingthesynchronizationdifferencesoftwoconcurrent
programs. The method uses Datalog to capture structural informa-
tion of the programs, and uses a set of inference rules to codifythe analysis algorithm. The analysis result, computed by an off-the-shelf Datalog solver, consists of sets of data-flow edges that
are allowed by only one of the two programs. We implemented theproposedmethodandevaluateditonalargenumberofbenchmark
programs. Our results show the method is orders-of-magnitudes
faster than the prior technique while being sufficiently accurate in
identifying the actual differences.
ACKNOWLEDGMENTS
ThisworkwassupportedinpartbytheU.S.NationalScienceFoun-
dation(NSF)undergrantCCF-1722710,theOfficeofNavalResearch
(ONR)undergrantN00014-17-1-2896,theEuropeanResearchCoun-
cil(ERC)undertheEuropeanUnionâ€™sHorizon2020researchand
innovation program (grant agreement No 678177).
665
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. Datalog-Based Scalable Semantic Diffing of Concurrent Programs ASE â€™18, September 3â€“7, 2018, Montpellier, France
REFERENCES
[1] Gcc bug 21334. http://gcc.gnu.org/bugzilla/show_bug.cgi?id=21334.
[2] Gcc bug 24430. http://gcc.gnu.org/bugzilla/show_bug.cgi?id=25330.
[3] Gcc bug 3584. http://gcc.gnu.org/bugzilla/show_bug.cgi?id=3584.
[4] Gcc bug 40518. http://gcc.gnu.org/bugzilla/show_bug.cgi?id=40518.
[5] Glib bug 51264. https://bugzilla.gnome.org/show_bug.cgi?id=512624.
[6] Jetty bug 1187. https://jira.codejaus.org/browse/JETTY-1187.
[7] Llvm bug 8441. http://llvm.org/bugs/show_bug.cgi?id=8441.
[8]MartÃ­n Abadi and Leslie Lamport. The existence of refinement mappings. Theo-
retical Computer Science, 82(2):253â€“284, May 1991.
[9]Vikram Adve, Chris Lattner, Michael Brukman, Anand Shukla, and Brian Gaeke.
LLVA:ALow-levelVirtualInstructionSetArchitecture. In ACM/IEEEinterna-
tional symposium on Microarchitecture, Dec 2003.
[10]AwsAlbarghouthi,ParaschosKoutris,MayurNaik,andCalvinSmith. Constraint-
based synthesis of datalog programs. In International Conference on Principles
and Practice of Constraint Programming, pages 689â€“706, 2017.
[11]Dirk Beyer. Software verification and verifiable witnesses. In International
Conference on Tools and Algorithms for Construction and Analysis of Systems,
pages 401â€“416, 2015.
[12]Sandeep Bindal, Sorav Bansal, and Akash Lal. Variable and thread bounding for
systematic testing of multithreaded programs. In International Symposium on
Software Testing and Analysis, pages 145â€“155, 2013.
[13]Roderick Bloem, Georg Hofferek, Bettina KÃ¶nighofer, Robert KÃ¶nighofer, Simon
AuÃŸerlechner,andRaphaelSpÃ¶rk. Synthesisofsynchronizationusinguninter-
preted functions. In International Conference on Formal Methods in Computer-
Aided Design, pages 11:35â€“11:42, 2014.
[14]Ahmed Bouajjani, Constantin Enea, and Shuvendu K. Lahiri. Abstract Semantic
Diffing of Evolving Concurrent Programs, pages 46â€“65. Springer International
Publishing, Cham, 2017.
[15]Martin Bravenboer and Yannis Smaragdakis. Strictly declarative specification of
sophisticatedpoints-toanalyses. In ACMSIGPLANConferenceonObjectOriented
Programming, Systems, Languages, and Applications, pages 243â€“262, 2009.
[16]StevenDawson,C.R.Ramakrishnan,andDavidS.Warren. Practicalprogram
analysis using general purpose logic programming systems&mdash;a case study.
InACM SIGPLAN Conference on Programming Language Design and Implementa-
tion, pages 117â€“126, 1996.
[17]AzadehFarzanandZacharyKincaid. Verificationofparameterizedconcurrent
programsbymodularreasoningaboutdataandcontrol.In ACMSIGACT-SIGPLAN
Symposium on Principles of Programming Languages, pages 297â€“308, 2012.
[18]BennyGodlinandOferStrichman. Timeforverification. chapterInferenceRules
forProvingtheEquivalenceofRecursiveProcedures,pages167â€“184.Springer-
Verlag, Berlin, Heidelberg, 2010.
[19]ShengjianGuo,MarkusKusano,andChaoWang.Conc-iSE:Incrementalsymbolic
execution of concurrent software. In IEEE/ACM International Conference On
Automated Software Engineering, pages 531â€“542, 2016.
[20]Shengjian Guo, Markus Kusano, Chao Wang, Zijiang Yang, and Aarti Gupta. As-
sertion guided symbolic execution of multithreaded programs. In ACM SIGSOFT
Symposium on Foundations of Software Engineering, pages 854â€“865, 2015.
[21]ElnarHajiyev,MathieuVerbaere,andOegedeMoor. CodeQuest:Scalablesource
code queries withdatalog. In European Conference onObject-Oriented Program-
ming, pages 2â€“27, 2006.
[22]Nevin Heintze and Olivier Tardieu. Demand-driven pointer analysis. In ACM
SIGPLANConferenceonProgrammingLanguageDesignandImplementation,pages
24â€“34, 2001.
[23]MauriceHerlihyandNirShavit. TheArtofMultiprocessorProgramming. Morgan
Kaufmann Publishers Inc., San Francisco, CA, USA, 2008.
[24]Krystof Hoder, Nikolaj BjÃ¸rner, and Leonardo de Moura. muZ - an efficient
engineforfixedpointswithconstraints. In InternationalConferenceonComputer
Aided Verification, pages 457â€“462, 2011.
[25]SusanHorwitz,ThomasReps,andMoolySagiv.Demandinterproceduraldataflow
analysis. In ACMSIGSOFTSymposiumonFoundationsofSoftwareEngineering,
pages 104â€“115, 1995.
[26]Daniel Jackson and David A. Ladd. Semantic diff: A tool for summarizing the
effects of modifications. In International Conference on Software Maintenance,
pages 243â€“252, 1994.
[27]Vilas Jagannath, Qingzhou Luo, and Darko Marinov. Change-aware preemption
prioritization. In InternationalSymposiumonSoftwareTestingandAnalysis,pages
133â€“143, 2011.
[28]Saurabh Joshi, Shuvendu K. Lahiri, and Akash Lal. Underspecified harnesses
and interleaved bugs. In ACM SIGACT-SIGPLAN Symposium on Principles of
Programming Languages, pages 19â€“30, 2012.
[29]SepidehKhoshnood,MarkusKusano,andChaoWang. Concbugassist:Constraintsolvingfordiagnosisandrepairofconcurrencybugs. In InternationalSymposium
on Software Testing and Analysis, pages 165â€“176, 2015.
[30]MarkusKusanoandChaoWang. Assertionguidedabstraction:Acooperative
optimization for dynamic partial order reduction. In IEEE/ACM International
Conference On Automated Software Engineering, pages 175â€“186, 2014.
[31]Markus Kusano and Chao Wang. Flow-sensitive composition of thread-modular
abstract interpretation. In ACM SIGSOFT Symposium on Foundations of Software
Engineering, pages 799â€“809, 2016.[32]MarkusJ.KusanoandChaoWang. Thread-modularstaticanalysisforrelaxed
memorymodels. In ACMSIGSOFTSymposiumonFoundationsofSoftwareEngi-
neering, 2017.
[33]ShuvenduK.Lahiri,ChrisHawblitzel,MingKawaguchi,andHenriqueRebÃªlo.
SYMDIFF:Alanguage-agnosticsemanticdifftoolforimperativeprograms. In
International Conference on Computer Aided Verification, pages 712â€“717, 2012.
[34]Shuvendu K. Lahiri, Kenneth L. McMillan, Rahul Sharma, and Chris Hawblitzel.
Differentialassertion checking. In ACMSIGSOFT SymposiumonFoundationsof
Software Engineering, pages 345â€“355, 2013.
[35]Monica S. Lam, John Whaley, V. Benjamin Livshits, Michael C. Martin, Dzin-
tars Avots, Michael Carbin, and Christopher Unkel. Context-sensitive program
analysisasdatabasequeries. In ACMSIGMOD-SIGACT-SIGARTSymposiumon
Principles of Database Systems, pages 1â€“12, 2005.
[36]SteffenLehnert.Ataxonomyforsoftwarechangeimpactanalysis.In International
Workshop on Principles of Software Evolution and Annual ERCIM Workshop on
Software Evolution, pages 41â€“50, 2011.
[37]V. Benjamin Livshits and Monica S. Lam. Finding security vulnerabilities in java
applicationswithstaticanalysis. In USENIXSecuritySymposium,pages18â€“18,
2005.
[38]Shan Lu, Soyeon Park, Eunsoo Seo, and Yuanyuan Zhou. Learning from mis-
takes: A comprehensive study on real world concurrency bug characteristics. In
InternationalConferenceonArchitecturalSupportforProgrammingLanguagesand
Operating Systems, pages 329â€“339, 2008.
[39]Paul Dan Marinescu and Cristian Cadar. KATCH: High-coverage testing of
software patches. In ACM SIGSOFT Symposium on Foundations of Software
Engineering, pages 235â€“245, 2013.
[40]Madanlal Musuvathi, Shaz Qadeer, Thomas Ball, GÃ©rard Basler, Pira-manayagam Arumuga Nainar, and Iulian Neamtiu. Finding and reproducing
heisenbugsinconcurrentprograms. In USENIXSymposiumonOperatingSystems
Design and Implementation, pages 267â€“280, 2008.
[41]Mayur Naik, Alex Aiken, and John Whaley. Effective static race detection for
java. InACM SIGPLAN Conference on Programming Language Design and Imple-
mentation, pages 308â€“319, 2006.
[42]Suzette Person, Matthew B. Dwyer, Sebastian Elbaum, and Corina S. P Ë‡asË‡areanu.
Differential symbolic execution. In ACM SIGSOFT Symposium on Foundations of
Software Engineering, pages 226â€“237, 2008.
[43]G. Ramalingam. Context-sensitive synchronization-sensitive analysis is undecid-
able.ACM Trans. Program. Lang. Syst., 22(2):416â€“430, 2000.
[44]DennisShashaandMarcSnir. Efficientandcorrectexecutionofparallelprograms
that share memory. ACM Trans. Program. Lang. Syst., 10(2):282â€“312, 1988.
[45]Chungha Sung, Markus Kusano, Nishant Sinha, and Chao Wang. Static DOM
event dependency analysis for testing web applications. In ACM SIGSOFT Sym-
posium on Foundations of Software Engineering, pages 447â€“459, 2016.
[46]Chungha Sung, Markus Kusano, and Chao Wang. Modular verification of
interrupt-driven software. In IEEE/ACM International Conference On Automated
Software Engineering, pages 206â€“216, 2017.
[47]ChaoWang,YuYang,AartiGupta,andGaneshGopalakrishnan. Dynamicmodel
checkingwithpropertydrivenpruningtodetectraceconditions. In International
SymposiumonAutomatedTechnologyforVerificationandAnalysis,pages126â€“140,
2008.
[48]John Whaleyand MonicaS. Lam. Cloning-basedcontext-sensitive pointeralias
analysisusingbinarydecisiondiagrams. In ACMSIGPLANConferenceonPro-
gramming Language Design and Implementation, pages 131â€“144, 2004.
[49]YuYang,XiaofangChen,andGaneshGopalakrishnan. Inspect:Aruntimemodel
checker for multithreaded C programs. Technical report, University of Utah,
2008.
[50]Yu Yang, XiaofangChen, GaneshGopalakrishnan, andChao Wang. Automatic
discovery of transition symmetry in multithreaded programs using dynamic
analysis. In International SPIN Workshop on Model Checking Software, pages
279â€“295, 2009.
[51]Zuoning Yin, Ding Yuan, Yuanyuan Zhou, Shankar Pasupathy, and LakshmiBairavasundaram. How do fixes become bugs? In ACM SIGSOFT Symposium
andthe 13thEuropeanConference onFoundationsofSoftware Engineering,pages
26â€“36, 2011.
[52]Jie Yu and Satish Narayanasamy. A case for an interleaving constrained shared-
memorymulti-processor. In InternationalSymposium onComputer Architecture,
pages 325â€“336, 2009.
[53]Tingting Yu, Zunchen Huang, and Chao Wang. ConTesa: Directed test suite
augmentationforconcurrentsoftware. IEEETransactionsonSoftwareEngineering,
2018.
[54]Tingting Yu, Witawas Srisa-an, and Gregg Rothermel. SimRT: An automated
frameworktosupportregressiontestingfordataraces.In InternationalConference
on Software Engineering, pages 48â€“59, 2014.
[55]Tingting Yu, Tarannum S. Zaman, and Chao Wang. DESCRY: reproducing
system-level concurrency failures. In ACM SIGSOFT Symposiumon Foundations
of Software Engineering, pages 694â€“704, 2017.
[56]XinZhang,RaviMangal,RaduGrigore,MayurNaik,andHongseokYang. On
abstraction refinement for program analyses in datalog. In ACM SIGPLAN Con-
ference on Programming Language Design and Implementation, pages 239â€“248,
2014.
666
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. 