HybriDroid: Static Analysis Framework
for Android Hybrid Applications
Sungho Lee
KAIST
South Korea
eshaj@kaist.ac.krJulian Dolby
IBM Research
USA
dolby@us.ibm.comSukyoung Ryu
KAIST
South Korea
sryu.cs@kaist.ac.kr
ABSTRACT
Mobile applications (apps) have long invaded the realm of
desktop apps, and hybrid apps become a promising solution
for supporting multiple mobile platforms. Providing both
platform-speciﬁc functionalities via native code like native
appsanduserinteractionsviaJavaScriptcodelikewebapps,
hybrid apps help developers build multiple apps for diﬀerent
platforms without much duplicated eﬀorts. However, most
hybrid apps are developed in multiple programming lan-
guages with diﬀerent semantics, which may be vulnerable
to programmer errors. Moreover, because untrusted Java-
Script code may access device-speciﬁc features via native
code, hybrid apps may be vulnerable to various security at-
tacks. Unfortunately, no existing tools can help hybrid app
developers by detecting errors or security holes.
In this paper, we present HybriDroid , a static analysis
framework for Android hybrid apps. We investigate the se-
mantics of Android hybrid apps especially for the interoper-
ation mechanism of Android Java and JavaScript. Then, we
design and implement a static analysis framework that ana-
lyzes inter-communication between Android Java and Java-
Script. As example analyses supported by HybriDroid , we
implement a bug detector that identiﬁes programmer errors
due to the hybrid semantics, and a taint analyzer that ﬁnds
information leaks cross language boundaries. Our empirical
evaluation shows that the tools are practically usable in that
they found previously uncovered bugs in real-world Android
hybrid apps and possible information leaks via a widely-used
advertising platform.
CCS Concepts
•Theory of computation →Program analysis; •Software
and its engineering →Automated static analysis;
Keywords
Android,hybridapplications,staticanalysis,multi-langua ge
analysis, analysis framework1. INTRODUCTION
Mobile applications (apps) have become the major source
of digital media consumption [41], but supporting multiple
mobile platforms for each mobile app is a challenging task.
Users are spending more time with mobile apps than desk-
top programs [9], major internet companies consider mobile
apps“ﬁrst”[43], and several vendors develop their own mo-
bile platforms to serve mobile apps eﬀectively such as An-
droid by Google, iOS by Apple, and Tizen OS by Samsung
and Intel. However, in order to entice users on diverse plat-
forms, developers should develop mobile apps on the various
platforms, which increases the development time and cost
of mobile apps. Traditional approaches to support multiple
platforms for a single app is to build either one native app
for each platform or one web app for all platforms. Building
native apps duplicates programming of the same app logic
multiple times for diﬀerent platforms but they can access
platform-speciﬁc functionalities. One can build a single web
app that can run on any browsers, but such a web app can-
not access platform-speciﬁc information.
Taking advantage of both native apps and web apps, hy-
brid apps become a promising solution. They support user
interaction via JavaScript code like web apps, and they pro-
vide device-speciﬁc features via native code just like native
apps. By reusing the same user-interaction code for multiple
platforms, and accessing platform-speciﬁc capabilities via
native API calls, developers can build multiple apps for dif-
ferent platforms without much duplicated eﬀorts. Moreover,
various hybrid app development frameworks like Apache
Cordova(formerlyPhoneGap)[16]freedevelopersfromwrit-
ingplatform-speciﬁccode.OutSystemssurveyresultsinboth
2014 and 2015 reported hybrid apps as the most preferred
mobile app development [32, 39].
While hybrid apps simplify development eﬀorts, they in-
troduce additional diﬃculties at the same time. Because
most hybrid apps are developed in multiple programming
languages with diﬀerent semantics, app developers should
well understand such semantic diﬀerences. For example, An-
droid hybrid apps are written in both JavaScript for user in-
teraction and Java for Android-speciﬁc features; Java code
and JavaScript code interact with each other by foreign
function calls. Even though the statically typed Java and
extremely dynamic JavaScript have diﬀerent behaviors, the
oﬃcial Android documentation does not specify their inter-
actionthoroughly[21],whichmaybevulnerabletoprogram-
mer errors. Moreover, because untrusted JavaScript code
may access device-speciﬁc features via native code, hybrid
apps may be vulnerable to various security attacks [46].Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciﬁc permission and/or a
fee. Request permissions from Permissions@acm.org.
ASE’16 , September 3–7, 2016, Singapore, Singapore
c/circlecopyrt2016 ACM. 978-1-4503-3845-5/16/09...$15.00
http://dx.doi.org/10.1145/2970276.2970368
250
In this paper, we present HybriDroid , a static analysis
framework for Android hybrid apps. Among various hybrid
appsondiﬀerentplatforms,wefocusonAndroidhybridapps
because we can check our understanding of the Android hy-
brid semantics by investigating the publicly available An-
droid source code [19]. We inspect the semantics of Android
hybrid apps especially for the interoperation mechanism of
Java and JavaScript. Because even the Android documen-
tation does not fully specify the semantics, we identify the
semantics via extensive testing and conﬁrm the semantics by
studying the source code. Then, we design and implement a
staticanalysisframeworkthatanalyzesAndroidhybridapps
by constructing call graphs for both Java and JavaScript via
an on-the-ﬂy pointer analysis. Our implementation is built
on top of WALA [27], an open-source analysis framework
for Java and JavaScript. To show possible use cases of Hy-
briDroid, we present two tools: a bug detector that identi-
ﬁes programmer errors due to the hybrid semantics, and a
taint analyzer that ﬁnds information leaks cross language
boundaries. Our empirical evaluation shows that the tools
are practically usable in that they found previously uncov-
ered bugs in real-world Android hybrid apps and possible
information leaks via a widely-used advertising platform.
The contributions of this paper include the following:
●We specify the interoperation semantics of Java
and JavaScript in Android hybrid apps . It de-
scribes the core inter-language semantics, empirically
tested and conﬁrmed by source-code investigation.
●We present HybriDroid , an open-source static anal-
ysis framework for Android hybrid apps1.
●UsingHybriDroid , we develop practical tools that
detect previously uncovered issues in real-world
Android hybrid apps in the Google Play Store.
In the rest of this paper, we provide a brief overview of
the Android hybrid app semantics (Section 2), and describe
the details of the inter-language communication mechanism
(Section 3). Then, we discuss challenges in static analysis
of Android hybrid apps, present how we address them in
building HybriDroid (Section 4), and demonstrate two sam-
ple tools built on top of HybriDroid (Section 5). We show
that the tools are practically useful in detecting real-world
problems (Section 6), discuss the related work (Section 7),
and conclude (Section 8).
2. OVERVIEW
We provide a high-level description of the Android hy-
brid app semantics (Section 2.1), how JavaScript code is
evaluated from Java code (Section 2.2), and how Java and
JavaScript code communicate with each other (Section 2.3).
2.1 Android Hybrid App Semantics
An Android app consists of app components that can be
invoked individually, and an Activity is an app component
denoting a single screen with a user interface. An Activity
can show a web page to a user and support powerful web
browsing features via WebView[21] based on the Chromium
open-source project [22].
For example, Figure 1 shows a sample code that loads a
web page on a WebView. AWebViewinstance wvis created on
1HybriDroid isavailableathttps://github.com/wala/WALA.1public class MainActivity extends Activity {
2
3@Override
4protected void onCreate(
5 Bundle savedInstanceState) {
6 ...
7 WebView wv = new WebView(this);
8 wv.getSettings().setJavaScriptEnabled(true);
9 wv.setWebViewClient(new MWebViewClient());
10 wv.setWebChromeClient(new MWebChromeClient());
11 wv.loadUrl( "http://www.google.com" );
12 ...
13}
14
15class MWebViewClient extends WebViewClient {
16 @Override
17 public boolean shouldOverrideUrlLoading(
18 WebView view, String url) {
19 ...
20 }
21}
22
23class MWebChromeClient extends WebChromeClient {
24 @Override
25 public boolean onJsAlert(WebView view,
26 String url, String message,
27 JsResult result) {
28 ...
29 }
30}
31
32}
Figure 1: Loading a web page on WebView
line 7, and the next line allows the JavaScript code of wvto
be evaluated, which is disallowed by default. On line 11, the
loadUrlmethod of wvgets a string literal argument, which
denotes a web page url, and loads the web page on wv. In
addition to such web page urls, loadUrlcan take addresses
for local web pages denoting packed web pages in Android
hybrid apps as its arguments, and load them on WebViews. It
distinguishes the addresses for online web pages and those
for local web pages by the preﬁxes of the addresses: if the
addresses start with“ http://”or“https:// ,”they are online
web pages, and if they start with“ file:/// ,”they are local
web pages.
AWebViewruns on its own thread to load a web page; it ex-
ecutes the JavaScript code in the web page asynchronously
with Java code. Java code can access the status of a WebView
by calling callback methods implemented in the WebView-
ClientandWebChromeClient classes. The setWebViewClient
andsetWebChromeClient methods on lines 9 and 10, respec-
tively, register such instances.
TheWebViewClient class provides callback methods, which
are invoked when events that impact the rendering of the
content happen [21]. For example, the shouldOverrideUrl-
Loadingmethod (lines 16–20) is called when its ﬁrst param-
eterviewloads a new web page at its second parameter url.
One can intercept url loading by overriding this method.
TheWebChromeClient classprovidescallbackmethods,which
are called when events that may impact the browser UI
happen. For example, the onJsAlert method (lines 24–29) is
called when its ﬁrst parameter viewexecutes the JavaScript
alertfunction with the third string parameter message as
the argument of the alertfunction on a web page at its sec-
ond parameter url. The fourth parameter resultprovides a
way for JavaScript to indicate what Java should do such as
clicking a conﬁrm or cancel button of the dialog window.
2512.2 Execution of JavaScript from Java
In Android hybrid apps, Java initiates inter-operation be-
tween Java and JavaScript. Like the JavaScript evalfunc-
tion that creates code from a string value and evaluates the
generated code at run time, the WebViewclass provides meth-
ods that create JavaScript code from Java string values and
execute the code in the JavaScript environment.
TheWebViewclass provides two such methods: loadUrland
evaluateJavascript . TheloadUrl method not only loads a
web page, but also executes JavaScript code. If its argu-
ment string value starts with“ javascript: ,”the method rec-
ognizes the argument as JavaScript code and executes it in
the current JavaScript environment. Similarly, the evalu-
ateJavascript method creates JavaScript code from its ﬁrst
string argument, executes it in the current JavaScript envi-
ronment, and invokes its second callback argument with the
result of the JavaScript code.
2.3 Interaction between Java and JavaScript
The communication capability between the native Java
code and the JavaScript code enables JavaScript to access
platform-speciﬁc information. Android provides two kinds of
communication between Java and JavaScript: callback com-
munication and bridge communication.
Callback Communication.
Android hybrid app developers can use callback methods
provided by WebViewClient andWebChromeClient discussed in
Section 2.1 as channels for communication between Java and
JavaScript.Wecallthiskindofcommunication callback com-
munication . Developers ﬁrst choose speciﬁc events that they
useforinter-communication,andoverridethecallbackmeth-
ods corresponding to the selected events so that they can
receive the events when they occur. Then, JavaScript code
can invoke the events to invoke Java callback methods and
pass some information to Java as method arguments.
For example, if a developer uses the event that loads web
pages as a communication channel, the developer should im-
plement a subclass of WebViewClient and override the shoul-
dOverrideUrlLoading method for communication. When the
JavaScript code location.href("command") is executed, the
shouldOverrideUrlLoading method is invoked with the "com-
mand"argument as its urlparameter, and the developer can
handle"command" in Java. Similarly, if a developer uses the
alertevent as a communication channel, when the Java-
Script code alert("command") is executed, the onJsAlert call-
back method can handle "command" in Java.
Bridge Communication.
The second mechanism called bridge communication sup-
ports communication between Java and JavaScript directly
rather than exploiting callback methods intended for other
purposes. In the bridge communication mechanism, Java
code injects a Java object to the JavaScript environment
of aWebView, and JavaScript code running on the WebView
directly invokes methods of the Java object. More speciﬁ-
cally, the addJavascriptInterface method of WebViewinjects
its ﬁrst argument Java object to the JavaScript environment
with its second string argument as the JavaScript name of
the injected Java object. We call the injected Java object an
injected object . Then, JavaScript code can invoke methods
of injected objects; The bridge communication mechanism
does not allow JavaScript to access ﬁelds of injected objects.1class JSBridge {
2@JavascriptInterface
3public String send(String msg) {
4 return "OK";
5}
6
7public String getName() {
8 return "JSBridge" ;
9}
10}
11
12@Override
13protected onCreate(Bundle savedInstanceState) {
14...
15WebView wv = new WebView(this);
16wv.addJavascriptInterface(new JSBridge(),
17 "bridge" );
18wv.loadUrl(
19 "file:///android_asset/www/index.html" );
20...
21}
(a) Android Java code
1var result = bridge.send( "example" );
2var name = bridge.getName();
(b) JavaScript code in index.html
Figure 2: Bridge communication
Figure 2 presents an example code for bridge communi-
cation. The Java code shown in Figure 2(a) declares a class
namedJSBridge , which deﬁnes two methods sendandget-
Name(lines 1–10). It injects an instance of JSBridge as the
namebridgeinto the JavaScript environment by calling the
addJavascriptInterface method of a WebView(lines 16–17).
Then, the Android system creates a new JavaScript object
from the injected object and attaches it to the JavaScript
global object with the name bridgewhenever a web page is
loaded on the WebView. We call the created JavaScript object
abridge object . At the call site of the loadUrlmethod (lines
18–19), the index.html page located in the assets/www direc-
tory of the hybrid app is loaded on the WebView. TheWebView
loads the web page, makes a new JavaScript environment for
the web page, creates the bridge object, attaches it to the
global object of the JavaScript environment, and executes
the JavaScript code in the web page. When the JavaScript
code in the web page is as shown in Figure 2(b), the invo-
cation of the method sendof the bridge object passes the
argument "example" to the corresponding method of the in-
jected object, receives the result "OK", and assigns it to a
JavaScript variable result.
Note that because the addJavascriptInterface method en-
ables JavaScript code to control the Java environment, it
may open the gate to security vulnerabilities. Even the oﬃ-
cial Android documentation makes the following note [21]:
Use of this method in a WebViewcontaining un-
trusted content could allow an attacker to ma-
nipulatethehostapplicationinunintendedways,
executing Java code with the permissions of the
host application. Use extreme care when using
this method in a WebViewwhich could contain un-
trusted content.
Thus, since the Android version 17, JavaScript code can
access only such public methods of injected objects that
havethe JavascriptInterface annotation. InFigure2(a),the
252Figure 3: Bridge object initialization
method sendhas the JavascriptInterface annotation, but
the method getNamedoes not. Therefore, in Figure 2(b), the
method call of sendexecutes normally but the call of getName
throws the MethodNotFound exception on the Android version
17 or later. Unfortunately, even recent Android should allow
apps targeting old Android versions to use all public meth-
ods from JavaScript to support backward compatibility.
Because bridge communication supports interaction be-
tween Java and JavaScript more directly than callback com-
munication,weconsideronlythebridgecommunicationmech -
anism throughout this paper.
3. BRIDGE COMMUNICATION SEMANTICS
In this section, we describe the behavior of bridge com-
munication in detail. Because the oﬃcial Android documen-
tation does not specify the behavior thoroughly, we identify
the bridge communication semantics via extensive testing
and conﬁrm the identiﬁed semantics via source-code inspec-
tion of the Android system.
3.1 Initialization of Bridge Objects
As we discussed in Section 2.3, whenever a web page is
loaded on a WebView, the Android system creates a bridge ob-
ject for each injected object via the addJavascriptInterface
method. It maintains a mapping between names of bridge
objects and their corresponding injected objects. Thus, no
multiple injected objects have the same bridge name. On the
contrary, a single injected object may have multiple bridge
names, which implies that multiple bridge objects may rep-
resent a single injected object.
When creating a bridge object for an injected object, the
Android system generates a mock-up object for each pub-
lic method annotated with JavascriptInterface of the in-
jected object. We call such mock-up objects bridge methods .
A bridge object has bridge methods as its properties named
with the corresponding method names.
Figure 3 illustrates how bridge objects are initialized. The
left box shows Java code and the right box shows a graph
describing the JavaScript environment, where nodes denote
JavaScript objects and edges denote relations between ob-
jects and names. The (red) circle is the global object in
the JavaScript environment, a (blue) diamond represents a
bridge object, and (green) triangles represent bridge meth-
ods. A solid edge represents that its fromJavaScript objecthasitstoJavaScriptobjectasitspropertynamedastheedge
label. A dashed edge represents that its fromJavaScript ob-
ject refers to its toJava object. A dotted edge represents
that itsfromJava name is used in the JavaScript environ-
ment as its toproperty name. Note that the bridge object
(blue diamond) refers to the injected object in Java, but the
bridge methods (green triangles) do not refer to any meth-
ods in Java because Java methods are not objects. Thus, the
Androidsystemmaintainsonlythenamesof bridgemethods
without any mapping to their corresponding Java methods.
3.2 Unique Semantics of Bridge Objects
WhiletheAndroidsystemtreatsbridgeobjectsandbridge
methods similarly for normal JavaScript objects, bridge ob-
jects behave diﬀerently from normal JavaScript objects in
somecases.InJavaScript,objectscandynamicallyadd,delete ,
and modify their properties depending on the attributes
of the properties [13]. A property associates its name with
four attributes: [[Value]] ,[[Writable]] ,[[Enumerable]] , and
[[Configurable]] . If[[Writable]] is true, the value of the
property can change. If [[Enumerable]] is true, the prop-
erty will be enumerated in the condition expression of the
for-instatement. If [[Configurable]] is true, the property
can be deleted among other things. However, even though
bridge methods are properties of bridge objects and their
[[Writable]] ,[[Enumerable]] , and[[Configurable]] attributes
arealltrue,deletingandmodifyingbridgemethodsofbridge
objectsarenotallowed.Attemptstodeleteandmodifybridge
methods are silently ignored.
3.3 Function Calls in Bridge Communication
In Android hybrid apps, bridge method calls are diﬀer-
ent from normal JavaScript function calls. As we discussed
in Section 3.1, because Java methods are not ﬁrst-class ob-
jects, the Android system does not maintain mappings from
bridge methods to their corresponding Java methods. Thus,
when calling a bridge method, the Android hybrid mecha-
nism ﬁnds a target Java method using Java reﬂection with
the name of the bridge method. The evaluation of bridge
method calls proceeds as follows:
1. Check whether a given receiver object is a bridge ob-
ject. If it is not a bridge object, throw the NonInject-
edReceiver exception.
2. Find a list of Java methods using Java reﬂection with
the class name of the injected object corresponding to
the receiver object and the name of the bridge method.
Ifthelistisempty,throwthe MethodNotFound exception.
3. Find a target Java method from the method list us-
ing the number of arguments. If there is no method
with the same number of parameters (arity) , throw the
MethodNotFound exception.Ifmultiplemethodswiththe
same arity exist, select a method among them.
4. Convert the JavaScript argument values to their cor-
responding Java values.
5. Call the target Java method with the injected object
corresponding to the receiver as the thisobject and
converted argument values.
6. Convert the Java method result value to its corre-
sponding JavaScript value, and return the converted
JavaScript value back to the JavaScript environment.
253Table 1: Compatible types from JavaScript values to Java val ues
Object String bytecharshort intlongfloat double boolArray
Null ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓
Undefined ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗
String ✗ ✓ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗
Boolean ✗ ✓ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗
Number ✗ ✓ ✓ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗
Object ▲∗✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ▲†
Table 2: Compatible types from Java values to JavaScript valu es
Object String bytecharshort intlongfloat double boolArray void
JavaScript Value ▲‡✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✗ ✗
Note that bridge methods support method overloading
partially. Java supports overloading which allows multiple
method declarations with the same name when they have
diﬀerent arities or the same arity but diﬀerent parameter
types.However,JavaScriptdoesnotallowoverloading;when
therearemultiplefunctiondeclarationswiththesamename,
the last one overwrites all the former ones. On the contrary,
Android hybrid mechanism allows multiple bridge methods
with the same name only when they have diﬀerent arities as
the 3rd step in the above process speciﬁes. When multiple
methods with the same name and the same arity exist, the
Android system chooses a method among them as a target
method to call without any warning or exception.
One interesting point is that because a bridge method
maintains only the name of its corresponding Java method
without any information about the class that deﬁnes the
Java method, bridge method calls may produce unintuitive
results. For example, consider the following JavaScript code:
bridge2.foo = bridge1.receive;
bridge2.foo();
wherebridge1andbridge2are bridge objects that refer to
injected objects of class Aand class B, respectively; in ad-
dition, the class Adeﬁnes a public method named receive
with the JavascriptInterface annotation. Evaluation of the
ﬁrst line assigns the bridge method to the fooproperty of
bridge2. Then, evaluation of the second line invokes the
bridgemethodnamed receivewiththereceiverobject bridge2,
which makes the Java method named receive deﬁned in
the class Bas the target Java method to call. If the class
Bhappens to deﬁne a public method named receive with
theJavascriptInterface annotation without any parame-
ters, the method will be called. Otherwise, the Android sys-
tem throws the MethodNotFound exception.
3.4 Type Mismatch in Java and JavaScript
While Java is statically typed and JavaScript is not, the
evaluationprocessofbridgemethodcallsinvolvesconversion
of values between Java and JavaScript. The 4th step in the
bridge method call process speciﬁes that JavaScript values
denoting method arguments are converted to Java values,
and the 6th step speciﬁes that Java values denoting method
call results are converted to JavaScript values.
Wedescribesuchbidirectionalvalueconversionrulesbased
on our extensive testing and the Android source code inves-
tigation. When a JavaScript value of JavaScript type τ1ispassed as a method argument to a parameter of Java type
τ2, ifτ1is compatible with τ2the Android system uses the
value accordingly. In Table 1, when a JavaScript value of
JavaScript type τ1such as Null,Undefined ,String,Boolean,
Number, orObjectis passed to a parameter of Java type τ2,
the corresponding entry is marked ✓if they are compatible,
marked ▲if the compatibility depends on the JavaScript
value, and marked ✗if they are not compatible. Similarly,
Table 2 speciﬁes whether a Java value of type τ1is compat-
ible with any JavaScript value.
WhenJavaScripttypesarenotcompatiblewithJavatypes
(✗in Table 1), the Android system uses default values of
Java types [38]; when Java types are not compatible with
any JavaScript values ( ✗in Table 2), the Android system
usesundefined . The conditionally compatible cases are more
complex than the others. The ▲∗case is when a JavaScript
object is passed as an argument to a parameter of Java ob-
ject type τ2. If the JavaScript object is not a bridge object,
the Android system uses null. If it is a bridge object whose
corresponding injected object has type τ1, the Android sys-
tem checks the type compatibility between τ1andτ2. If they
are compatible, it uses the injected object as the argument;
otherwise, it throws an exception. When a JavaScript ar-
ray value is passed as an argument to a parameter of Java
object type τ2as in ▲†, ifτ2is an array type with the ele-
ment type τ3, the Android system checks the compatibility
of each element of the JavaScript array value and the type
τ3; otherwise, it throws an exception. Finally, when a Java
object value is returned to JavaScript as in the ▲‡case,
the Android system makes and returns a new bridge object
that refers to the Java object. Note that when the return
type of a Java method is an array type, the Android system
does not call the method but returns undefined , which is a
peculiar semantics requiring extreme care from hybrid app
developers.
4. CHALLENGES IN STATIC ANALYSIS OF
ANDROID HYBRID APPS
In this section, we describe challenges in statically analyz-
ing Android hybrid apps and how we address them. While
static analysis of Android apps alone or JavaScript apps
alone still has various open problems to solve, they are be-
yond the scope of this paper. Throughout this paper, we
focus on the issues in static analysis of bridge communica-
tion between Java and JavaScript.
254Figure 4: Modeling of JavaScript/Java environments
4.1 Multiple JavaScript Environments
BecauseAndroidhybridappsmayloadmultiplewebpages,
where each web page has its own JavaScript environment,
analysis of Android hybrid apps requires analysis of interac-
tions between a single Java environment and multiple Java-
Scriptenvironments.Letusconsidertwopossibleapproaches
for their analysis: 1) separately analyze each web page with
the Java environment, and 2) analyze all web pages with
the Java environment at the same time. The ﬁrst approach
is simpler than the second because each analysis considers
only one JavaScript environment, but it misses analysis of
various hybrid behaviors. While the JavaScript environment
of a web page can aﬀect the Java environment and vice versa
viabridgecommunication,whichimpliesthattheJavaScript
environment of one web page can also aﬀect that of another
web page, the ﬁrst approach cannot address such behaviors.
Thus, we take the second approach.
Figure 4 illustrates our modeling of multiple JavaScript
environments. To represent the JavaScript environment of
each web page separately, we model that each web page has
its own JavaScript global object (red circle) and the Java-
Script code in one web page can access only the global object
of the web page. In the Figure, (green) triangles represent
normal JavaScript objects, (blue) diamonds represent bridge
objects, and (purple) stars represent Java objects. Three
kinds of edges represent relationships between objects: 1)
solid undirected edges denote property relations, 2) dashed
directed edges denote that the frombridge objects refer to
thetoinjected objects, and 3) solid directed edges denote
that the fromobject can aﬀect the status of the toobject
directly or indirectly. Note that the JavaScript environment
of each web page is isolated by its own global object. The
JavaScriptenvironmentsof a.htmlandb.htmlcanaﬀecteach
other indirectly, because their bridge objects, aandb, refer
to the same injected object e. Also, the JavaScript envi-
ronment of b.htmlcan aﬀect that of c.html, because an in-
jected object freferred by a bridge object cinb.htmlcan
directly or indirectly aﬀect an injected object greferred by
d, a bridge object of c.html. On the contrary, the JavaScript
environment of c.htmlcan aﬀect the Java environment, but
it cannot aﬀect any other JavaScript environments.
Our modeling soundly abstracts the Android hybrid app
environments. We can further improve the modeling preci-
sion by reﬂecting asynchronous execution of JavaScript code
inmultiple WebViewsforexample.However,becauseourbase-
line analysis is ﬂow-insensitive as we describe in Section 5,
such modeling improvement belongs to our future work.4.2 Dynamically Obtained Source Code
One of the main diﬃculties in static analysis of Android
hybrid apps is the lack of the source code to analyze at com-
pile time. Often, apk archives of Android hybrid apps do not
contain the entire programs. While running, Android hybrid
apps download and show online web pages using their ad-
dresses at run time. Also, just as in other JavaScript web
apps, JavaScript code in Android hybrid apps may generate
code from string values dynamically. Because such dynami-
cally obtained code is not available statically, static ana lysis
of the code in apk archives alone cannot analyze such code.
To analyze dynamically obtained code statically as much
as possible, we perform a string analysis for Android hybrid
apps prior to its main analysis. The string analysis analyzes
string values used for the arguments of the loadUrlmethod,
and categorizes the analysis results into four cases: 1) local
web page addresses, 2) online web page addresses, 3) Java-
Script code, and 4) unknown. When the argument is a local
web page address, it is already available for static analy-
sis. When the argument is an online web page address, we
download the whole source code of the web page so that the
main static analysis can analyze it. When the argument is
JavaScript code, we include it in the analysis target of the
subsequent main analysis. Finally, when the argument is not
precisely known statically, we partially model it by making
the main analysis analyze all local web pages in the apk
archive. While this modeling is incomplete, it takes the best
eﬀort by analyzing all statically available local web pages.
The main analysis maintains mappings between the load-
Urlcall sites and their argument values to analyze each call
site precisely. Even when multiple WebViews load the same
web page, the JavaScript code in the web page may run dif-
ferently depending on the WebView in which the web page
is loaded, because each WebViewhas its own bridge objects.
Therefore, for call graph construction, we identify which
JavaScriptenvironmentsmapwhichbridgeobjectsusingthe
mapping of the loadUrlcall sites and their argument values.
4.3 Analysis Sensitivity for Multiple Languages
Thebestanalysissensitivityconﬁgurationdependsonsev-
eral aspects. More context-sensitive analyses may produce
more precise analysis results with more performance over-
head for C programs [37], object-sensitive analysis may work
well for Java programs [35], and more precise analysis may
evenimproveanalysisscalabilityforJavaScriptprograms[40].
Thus,itisnotyetclearwhichanalysissensitivitywouldwo rk
the best for Android hybrid apps.
In order to experiment with various analysis sensitivities
to better support the Android hybrid app analysis, we pro-
vide conﬁgurability of analysis sensitivities. Our analysi s
framework described in Section 5 supports various context-
sensitive analyses to construct call graphs. It also supports
diﬀerent sensitivities for analyses of Java and of JavaScript.
4.4 Semantics Speciﬁc to Android Versions
Analysis of Android hybrid apps should work diﬀerently
depending on the target Android versions of the apps. As we
discussed in Section 2.3, in the Android version 17 or later,
only public methods with the JavascriptInterface annota-
tion in injected objects are accessible from JavaScript code.
However, for backward compatibility, the Android system
allows apps targeting old Android versions to use all public
methods of injected objects from JavaScript code.
255Figure 5: Overview of HybriDroid
ToperformpreciseanalysisdependingontheAndroidver-
sions, we extract the target version of Android hybrid apps
speciﬁed in AndroidManifest.xml by decompiling their apk
archives using apktool [49]. The apktool is a reverse engi-
neering tool for Android apps, which decompiles Java class
ﬁles to Smali [6] code, decompiles resources to their original
forms, and assembles the app information into a ﬁle named
apktool.yml . Sinceapktool.yml contains various information
including the sdk, package, version, compression, and shared
library, we parse apktool.yml to extract the target Android
version of the app. Using the extracted target Android ver-
sion, the analysis identiﬁes accessible Java methods from
JavaScript code for constructing call graphs.
5.HybriDroid ANALYSIS FRAMEWORK
Now, we demonstrate HybriDroid , a static analysis frame-
work for Android hybrid apps, and show two sample tools
usingHybriDroid : a bug detector and a taint analyzer.
5.1 Architecture of HybriDroid
Weimplemented HybriDroid asanextensionofWALA[27],
which is an open-source static analysis framework originally
developed for Java bytecode, and now it supports JavaScript
programs and Android Java Dalvik bytecode. It provides
ﬂow-insensitive and context-sensitive analyses. While it can
analyze JavaScript and Java separately, it cannot analyze
interaction between JavaScript and Java. Thus, we use both
analysis modules for JavaScript and Java, and extend them
to analyze inter-communication between them.
Figure 5 presents the overall architecture of HybriDroid .
For simplicity, we omit basic WALA modules and show only
core modules of HybriDroid :String Analyzer ,Information Ex-
tractor,HybriDroid Scope Builder , andHybriDroid CallGraph
Builder. The ﬁgure also presents two add-on tools, Bug De-
tectorandTaint Analyzer , which utilize the analysis of inter-
communication between Java and JavaScript. Bug Detector
ﬁnds possible programmer errors in Android hybrid apps,
andTaint Analyzer tracks ﬂows of tainted data from sources,
origins of tainted data, to sinks, leaking points of tainted
data. We describe the tools in detail in next sections.
String Analyzer takes the input apk archive and statically
analyzesittoextractconcretestringvaluesusedastheargu-
ments of the loadUrlmethod as we discussed in Section 4.2.
It ﬁrst builds dependency graphs that represent how such
argument values are constructed using a backward slicing
technique [48]. Then, it computes string values of the load-Urlarguments using the dependency graph by ﬁxpoint iter-
ations. To focus on analysis of user-deﬁned code, we model
a set of built-in string operators such as appendandindexOf.
Information Extractor retrieves necessary information of
the Android hybrid apps as we described in Section 4.4. It
generates YML Data , which contains various information of
the target Android hybrid app in apktool.yml .
HybriDroidScopeBuilder takestheapkandthestringanal-
ysis result as inputs and builds a target analysis scope. Us-
ing the string analysis result String Information , it down-
loads missing web pages and saves each dynamically exe-
cuted JavaScript code. It collects all the dynamically exe-
cuted JavaScript code in addition to the Dalvik bytecode
and JavaScript code in local web pages, and builds a Hy-
briDroidScope thatincludesallthecollectedcode. HybriDroid
Scopealso contains the Android framework bytecode, Java
built-in bytecode, and built-in models provided by WALA.
HybriDroid CallGraph Builder takes both HybriDroid Scope
andYML Data as inputs and constructs a Call Graph for the
target Android hybrid app. It extends an existing WALA
modulethatconstructscallgraphs,andithandlesbridgeini-
tialization, bridge communication, and multiple JavaScript
environments as we discussed in Sections 3 and 4. Note that
it considers the target Android version of the hybrid app
fromYMLData to reﬂect the diﬀerent semantics of diﬀerent
Android versions. It constructs Call Graph s as the same data
structure with WALA so that HybriDroid can use existing
WALA analysis modules for analyzing inter-communication.
5.2 Bug Detector
Building Android hybrid apps may be more error-prone
than building native apps or web apps, because no develop-
menttoolslikeIntegratedDevelopmentEnvironments(IDEs)
exist for hybrid apps, and no documentation thoroughly
speciﬁesthedelicatesemanticsoftheirinter-communicati on.
The only possible way for developers to build high quality
apps seems to be extensive testing. Moreover, because An-
droid hybrid apps do not terminate abnormally when bugs
happenineither JavaorJavaScriptcodebutonlyshowerror
log messages, such bugs are diﬃcult for developers to catch.
To help developers ﬁnd such bugs, we implement Bug De-
tectoron top of HybriDroid . When the HybriDroid CallGraph
Builderconstructs call graphs, Bug Detector ﬁnds possible
errors and reports them. It can detect four kinds of sample
bugs:MethodNotFound ,TypeOverloadedBridgeMethod ,Not-
CompatibleTypeConversion , andMethodNotExecuted .
256MethodNotFound.
WhenaJavaScriptbridgemethodcallcannotﬁndanytar-
get Java method to call, Bug Detector reports the Method-
NotFound error, which may be due to three reasons. The
ﬁrst case is when a developer makes a typo in the bridge
method name or indeed calls an undeﬁned method of an in-
jected object. The second case is when a target Java method
is inaccessible either because it is private or it does not
have the JavascriptInterface annotation when the target
Android version is 17 or later. Finally, the third case is when
a bridge method call has a wrong number of arguments.
MethodNotExecuted.
Bug Detector reports the MethodNotExecuted error when
the return type of a target Java method is an array type. As
we discussed in Section 3.4, the Android hybrid mechanism
ignoressuchbridgemethodcallswithoutanywarning,which
is vulnerable to programmer errors.
TypeOverloadedBridgeMethod.
Because Android hybrid apps do not support overloading
with diﬀerent types of parameters as we discussed in Sec-
tion3.3, BugDetector reportsthe TypeOverloadedBridgeMethod
warning when a bridge method call invokes a Java method
that has multiple methods with the same name and number
of parameters but diﬀerent types. While Android does not
signal an error but chooses a method among the overloaded
methods, such semantics is unintuitive and error-prone.
IncompatibleTypeConversion.
BugDetector reportsthe IncompatibleTypeConversion warn-
ing when a bridge method call uses default values for Java
method arguments. As we discussed in Section 3.4, when
the types of JavaScript values are not compatible with Java
types, the default values of the corresponding Java types are
used instead. While Android does not signal any error in this
case, the semantics is undocumented and error-prone.
5.3 Taint Analyzer
In addition to the security vulnerabilities in Android apps
and JavaScript apps, Android hybrid apps may have new
kindsofsecurityvulnerabilitiesinvolvinginter-languagec om-
munication. One particular example is information leakage
from device features through advertising (ad) platforms [18].
Because ad platforms require various user-granted permis-
sions and the Android system simply enumerates required
permissions without actually separating execution of hybrid
app code from that of ad platforms, adversaries can deploy
malicious advertisement to steal private data for example.
To detect such information leaks that involve both Java
and JavaScript execution ﬂows, we implement Taint Ana-
lyzer, which tracks data and control ﬂows in bridge com-
munication. Speciﬁcally, it focuses on detecting information
leakage via ad platforms that themselves are hybrid apps.
Similarly for Bug Detector ,Taint Analyzer is built on top of
HybriDroid using the Interprocedural, Finite, Distributive,
Subset (IFDS) framework [42] provided by WALA.
Taint Policy.
Taint Analyzer propagates taint information according to
the value propagation semantics of Java, JavaScript, and
bridge communication. For collection values such as arrays,
lists, and maps, we over-approximate their value propaga-tionbyjoiningthetaintinformationofalltheirelements.For
example, when an array element contains a tainted value,
the analysis considers the entire array as tainted. Similarly,
when a native method is called with a tainted argument, the
analysis considers all the arguments and its result tainted.
Sources and Sinks.
In Android hybrid apps, sourcesandsinksmay exist cross
language boundaries. For example, when an app extracts a
user’s location and sends it over the network via JavaScript,
the source is in Java and the sink is in JavaScript. When an
app receives a password from a user and saves it via Java,
the source is in JavaScript and the sink is in Java.
In addition, because Android apps provide multiple lay-
ers of information ﬂows such as inter-app ﬂows and inter-
component ﬂows explicitly or implicitly, sources and sinks
may exist cross app boundaries. For example, when an app
uses anintentwith an action android.intent.action.PICK to
call the Galleryactivity of the Android default app, which
returns an image to the caller, the source exists in the An-
droid default app. In this case, instead of the Galleryactiv-
ity, we consider android.intent.action.PICK as the source.
Android-Speciﬁc Additional Control Flows.
In order to better analyze Android-speciﬁc ﬂows like im-
plicit control ﬂows via intents and ﬂows between sources and
sinks cross app and cross component boundaries, we extend
the base Android analysis of WALA with additional ﬂows.
More speciﬁcally, Taint Analyzer adds two kinds of additional
edges in call graphs: 1) to support more ﬂows between com-
ponents in a single app, it adds edges from all the activity
starting method calls like startActivity andstartActivity-
ForResult to all the activity creating methods onCreate ; and
2) to support more ﬂows between components in diﬀerent
apps, for each activity, it adds edges from its startActivi-
tyForResult calls to its onActivityResult to represent ﬂows
passing results from diﬀerent apps’ activities to the activity.
Note that because it adds extra edges on the underlying
pointer analysis results, previously unreachable method call s
in the pointer analysis results may become reachable due to
the extra edges. Since such method calls do not have any
edges to the method bodies of their corresponding callees
in the pointer analysis results, the analysis of Taint Analyzer
cannot analyze their method bodies. To add edges from such
method calls to the bodies of their callees, we perform the
Class Hierarchy Analysis (CHA) [12] from the receiver types
of the calls. Traversing class extension relations from the
static types of the receivers, it ﬁnds corresponding method
bodies, and adds edges from the calls to the bodies.
5.4 Discussion
We presented a static analysis framework for Android hy-
brid apps, but there remain rooms for improvement.
String Analysis Precision.
WhileString Analyzer is not the main contribution of this
paper, its analysis results aﬀect the analysis quality of Hy-
briDroid. Because we use a simple String Analyzer ,HybriDroid
may miss JavaScript code execution initiated by Java via
loadUrl, and it may also miss page loading via online web
pages. Note that HybriDroid is not tied to a speciﬁc string
analyzer, and it can adopt advanced string analyzers [10,
31].
257Table 3: Bug detection results
Rank Hybrid App Bug Type (#) #FP#TP Bug Cause (#) Time
1 – 100com.gameloft.android.ANMP.GloftDMHM MethodNotFound (1)01 Obfuscation (1) 2404 sec.
com.creativemobile.DragRacing MethodNotFound (1)10 3192 sec.
com.gau.go.launcherex MethodNotFound (2)20 5432 sec.
com.tripadvisor.tripadvisor MethodNotFound (1)01 Obfuscation (1) 4028 sec.
com.dianxinos.dxbs MethodNotFound (1)01 Obfuscation (1) 1924 sec.
10,000 – 10,100 com.magmamobile.game.LostWords MethodNotFound (1)10 475 sec.
20,000 – 20,100 com.daishin MethodNotFound (1)01Undeclared Method (1) 6572 sec.
100,000 – 100,100com.carezone.caredroid.careapp MethodNotFound (5)05Missing Annotation (5) 2357 sec.
com.pateam.kanomthai MethodNotFound (2)02Missing Annotation (2) 4209 sec.
com.acc5.l6 MethodNotFound (6)06Missing Annotation (6) 367 sec.
jp.cleanup.android MethodNotFound (1)10 253 sec.
ligamexicana.futbol MethodNotFound (2)20 253 sec.
200,000 – 200,100com.sysapk.weighter MethodNotFound (1)01Missing Annotation (1) 106 sec.
com.youmustescape3guide.free MethodNotFound (6)06Missing Annotation (6) 445 sec.
Total MethodNotFound (31)724Missing Annotation (20)
Obfuscation (3) 2287 sec.
Undeclared Method (1)
WebView Callback Supports.
As we discussed in Section 2, because bridge communica-
tion supports interaction between Java and JavaScript more
directly than callback communication, we consider only the
bridge communication mechanism in this paper. We may
want to further support callback communication.
Android Java and JavaScript Analysis.
Eventhough HybriDroid focusesoninter-languagecommu-
nication analysis, the analysis quality depends on the under-
lying analysis of Java and JavaScript. Because WALA sup-
ports only ﬂow-insensitive analyses and because it does not
support extensive DOM modeling, HybriDroid can further be
improved by using advanced baseline analyzers.
6. EV ALUATION
In this section, we show the usefulness of HybriDroid by
presenting previously uncovered issues detected by Bug De-
tector(Section 6.1) and Taint Analyzer (Section 6.2).
6.1 Real-World Bug Detection
To evaluate the quality of Android hybrid apps in terms of
the bugs deﬁned in Section 5.2, we collected real-world An-
droidappsusingPlayDrone,aGooglePlayStorecrawler[50].
Wedownloaded100appseachfromrankings1,10000,20000,
100000, and 200000, and chose hybrid apps that use bridge
communicationamongthem.Wecollectedall48hybridapps
from the ranks 1 to 100, and 10 hybrid apps each for the
other ranks, which amounts to 88 hybrid apps in total.
We analyzed these target hybrid apps with Bug Detector
and manually veriﬁed the reported bugs as summarized in
Table 3. The ﬁrst column presents the ranking groups, the
second column presents the apps that have reported bugs,
and the remaining columns present the bug types, the num-
bers of unique bugs, the numbers of false positives and true
positives, the causes of the bugs, and the time in seconds.
Among 88 target hybrid apps, the tool reports that 14
apps may contain 31 bugs. We observed that 9 apps con-
tain 24 true alarms and the other 5 apps contain 7 false
alarms. Surprisingly, all 24 true alarms are MethodNotFound .
We found that hybrid app developers use bridge commu-
nication carefully without manipulating bridge objects andbridge methods; they simply call bridge methods. Moreover,
most arguments to bridge methods are JavaScript strings.
Out of 24 true bugs, 20 bugs are caused by the missing
JavascriptInterface annotation, 1 bug is because of calling
an undeﬁned method, and 3 bugs are due to wrong obfusca-
tion. To protect Android apps from repackaging attacks [51],
developers often obfuscate their apps before deployment; be-
cause obfuscation changes names of classes, methods, and
ﬁelds to meaningless names, it may make reversing of the
apps diﬃcult. Google oﬃcially supports apk obfuscation by
ProGuard since April 2016 [23, 26]. However, because only
Java code is obfuscated, JavaScript code still accesses bridge
methods using their original names even after obfuscation in
Java. In order to avoid these bugs, developers should not ob-
fuscate the accessible Java methods from JavaScript.
We observed that all 7 false positives are due to the im-
precise string analysis. When the string analysis fails to ﬁnd
concrete values for the arguments of loadUrl, the tool re-
gards that all local web pages can be loaded, which may be
too conservative. We believe that a better string analysis
would improve the analysis precision of HybriDroid .
6.2 Private Data Leakage Detection
Toinvestigatesecurityissuesinadplatforms,wemanually
inspected all 48 hybrid apps in top 100 Android apps in the
Google Play Store. We found 19 ad platforms used by them,
identiﬁed 5 among them using bridge communication, and
observedthat3adplatforms(InMobi[1],Supersonic[3],and
Millennial Media [34]) require rather aggressive permissions
like external storage accesses and audio recording.
Among them, we closely examined InMobi, which exposes
powerful Java methods including makeCall ,sendMail ,take-
CameraPicture , andgetGalleryImage [11]. When a hybrid app
that integrates InMobi runs, InMobi fetches ads to the app.
ToanalyzetheInMobiadsourcecode,weextracttheHTML
and JavaScript code of the fetched ad using the Chrome re-
mote debugging tool [20]. The extracted JavaScript mraid.js
contains various functions that call Java methods as follows:
a.getGalleryImage = function() {
return sdkController.getGalleryImage("window.imraidv iew")
}
To evaluate whether Taint Analyzer detects possible privacy
leaks, we created a sample hybrid app that simply loads a
258local web page, which in turn just calls the getGalleryImage
function. We manually inspected the InMobi SDK source
codeandfoundthattheabove sdkController.getGalleryImage
method call leads to a Galleryactivity using an intent with
theandroid.intent.action.PICK action. Then, the Gallery
activity shows its image gallery. When a user selects one
image, the image is sent to the JavaScript environment by
calling another JavaScript function from mraid.js :
a.fireGalleryImageSelectedEvent = function(a, b, c) {
var d = new Image;
d.src = "data:image/jpeg;base64," + a;
d.width = b;
d.height = c;
window.imraid.broadcastEvent("galleryImageSelected" , d)
}
via aloadUrlmethod call. We conﬁrmed it by running the
samplehybridappwithanew fireGalleryImageSelectedEvent
function that logs its arguments.
We analyzed the sample hybrid app that uses the In-
Mobi platform via Taint Analyzer . For a taint source, we
takeandroid.intent.action.PICK ; for taint sinks, we consider
all JavaScript functions in mraid.js . The tool detected the
ﬂow from android.intent.action.PICK to JavaScript func-
tions and warned the possible data leakage successfully.
7. RELATED WORK
In this section, we discuss the literature on static analyses
of Android apps, JavaScript programs, and hybrid apps.
Static Analysis of Android Apps.
While Android apps provide multiple layers of informa-
tion ﬂows such as inter-app ﬂows and inter-component ﬂows
explicitly or implicitly, no existing static analyzers for An -
droid apps can precisely analyze various ﬂows in a scalable
manner yet [47]. Most Android analyzers are built on top of
either WALA or Soot[2]. Soot is an open-source Java and
Android app analysis framework, which provides call graph
construction, pointer analysis, and data-ﬂow analysis.
SCanDroid [17] is the ﬁrst WALA-based analyzer for An-
droid apps. It tracks data ﬂows including Inter-Component
Communication(ICC)andinter-appcommunicationtocheck
consistencyofsecurityspeciﬁcationinAndroidmanifestﬁles .
Droidel [7] provides an extensible Android analysis frame-
work based on WALA, which generates app-speciﬁc Android
framework stubs automatically.
Among various Soot-based Android analyzers, Epicc [36]
provides detection of ICC vulnerabilities [14] by analyzing
ICC via reducing ICC to the inter-procedural distributive
environment problem. To analyze more ﬂows in Android
apps, GATOR [44] considers GUI objects, events, and call-
back handlers to analyze inter-component control ﬂows in-
duced by them. FlowDroid [5] also expands the control ﬂows
by analyzing the activity life cycle precisely. DroidSafe [24]
improvesprecisionandaccuracyofAndroidinformationﬂow
analysis by accurate analysis stubs. Apposcopy [15] proposes
a new semantics-based detection of private data leakage in
Android apps by specifying semantic characteristics of mal-
ware families.
Although all the above tools focus on analysis of Android
apps alone, their research achievements will surely be appli-
cable to HybriDroid regardless of their base analyzers.Static Analysis of JavaScript Programs.
Static analysis of JavaScript programs have focused on
improving the analysis scalability. JSAI [29] is a JavaScript
abstractinterpreterusinganabstractmachine-basedseman-
tics, but it supports only limited modeling of built-in, DOM,
and browser APIs, which is not usable in analysis of real-
world JavaScript web apps. SAFE [30] supports analysis
of web apps using various JavaScript libraries, DOM and
browser APIs, and platform-speciﬁc APIs and it can ana-
lyze all existing versions of jQuery. TAJS [4] tracks string
values passed to the evalfunction, and it analyzes events
by considering all possible combination of event calls. How-
ever, SAFE and TAJS do not support Java analysis. Finally,
WALA supports both Java and JavaScript analysis. While
it provides only sound pointer analysis for Java programs,
it provides both sound propagation-based analysis and un-
sound ﬁeld-based analysis for JavaScript.
Even though the implementation of HybriDroid is based
on WALA, its design and the analysis between Java and
JavaScript are not tied to any speciﬁc of WALA.
Static Analysis of Hybrid Apps.
Recently, static analyses of hybrid mobile apps built us-
ing cross-platform frameworks that implement the Apache
Cordova library have been proposed. Jin et al.[28] intro-
duced JavaScript injection attacks via network communica-
tion in hybrid mobile apps based on the PhoneGap frame-
work,andproposedastaticdetectiontoolthatanalyzesonly
JavaScript code. Shehab and AlJarrah [45] reported secu-
rity issues in the app-level access control mechanism used in
Cordova-basedframeworks,anddevelopedasimpletoolthat
checks usage of PhoneGap plugins. Brucker and Herzberg [8]
built a static analyzer of hybrid mobile apps developed us-
ing Cordova. Unlike HybriDroid that analyzes ﬂows between
JavaScript and Java seamlessly, their tool builds control ﬂow
graphs of JavaScript and Java separately and adds edges be-
tween them using various heuristics.
8. CONCLUSION
Hybrid apps have become the most preferred app devel-
opment because they enjoy both platform-independent user
interaction via JavaScript and device-speciﬁc functionaliti es
via native code. At the same time, hybrid app developers
should be extremely careful in utilizing communication be-
tween languages with diﬀerent semantics and protecting pri-
vate data from malicious accesses. In this paper, we present
a static analysis framework for Android hybrid apps, Hy-
briDroid, which analyzes inter-communication between Java
and JavaScript. We show that HybriDroid is useful in detect-
ing programmer errors due to misunderstanding of inter-
language communication and possible private data leakage
throughadplatforms.Ourexperimentalresultsrevealed pre-
viously uncovered bugs and rooms for information leakage
due to powerful functionalities of ad platforms . We believe
thatHybriDroid will enable detection of various kinds of pro-
grammer errors and security vulnerabilities cross language
boundaries in Android hybrid apps.
Acknowledgment
This work is supported in part by National Research Foun-
dation of Korea (Grant NRF-2014R1A2A2A01003235) and
Samsung Electronics.
2599. REFERENCES
[1] InMobi. http://www.inmobi.com.
[2] Soot. https://sable.github.io/soot/.
[3] Supersonic: Mobile advertising.
https://www.supersonic.com.
[4] E. Andreasen and A. Møller. Determinacy in static
analysis for jQuery. In Proceedings of the Conference
on Object-Oriented Programming, Systems,
Languages, and Applications , pages 17–31, 2014.
[5] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel,
J. Klein, Y. Le Traon, D. Octeau, and P. McDaniel.
FlowDroid: Precise context, ﬂow, ﬁeld, object-sensitive
and lifecycle-aware taint analysis for Android apps. In
ACM SIGPLAN Notices , volume 49, pages 259–269,
2014.
[6] Ben Gruver. Smali.
https://github.com/JesusFreke/smali.
[7] S. Blackshear, A. Gendreau, and B.-Y. E. Chang.
Droidel: A general approach to Android framework
modeling. In Proceedings of the 4th ACM SIGPLAN
International Workshop on State of the Art in
Program Analysis , pages 19–25, 2015.
[8] A. D. Brucker and M. Herzberg. On the static analysis
of hybrid mobile apps. In Proceedings of the 8th
International Symposium on Engineering Secure
Software and Systems , pages 72–88. Springer
International Publishing, 2016.
[9] D. Chaﬀey. Mobile marketing statistics compilation.
http://www.smartinsights.com/mobile-marketing/
mobile-marketing-analytics/
mobile-marketing-statistics, 2015.
[10] A. S. Christensen, A. Møller, and M. I. Schwartzbach.
Precise analysis of string expressions. In Proceedings of
the 10th International Symposium on Static Analysis ,
pages 1–18, 2003.
[11] L. Constantin. Researchers: Mobile users at risk from
lack of HTTPS use by mobile ad libraries.
http://www.inmobi.com/company/news/
researchers-mobile-users-at-risk-from-lack-of-https-use-
by-mobile-ad-librar.
[12] J. Dean, D. Grove, and C. Chambers. Optimization of
object-oriented programs using static class hierarchy
analysis. In Proceedings of the 9th European
Conference on Object-Oriented Programming , pages
77–101, 1995.
[13] ECMA. ECMA-262: ECMAScript 2015 Language
Speciﬁcation, 6th Edition.
http://www.ecma-international.org/publications/ﬁles/
ECMA-ST/Ecma-262.pdf.
[14] W. Enck, D. Octeau, P. McDaniel, and S. Chaudhuri.
A study of Android application security. In
Proceedings of the 20th USENIX Conference on
Security, 2011.
[15] Y. Feng, S. Anand, I. Dillig, and A. Aiken.
Apposcopy: Semantics-based detection of Android
malware through static analysis. In Proceedings of the
22nd ACM SIGSOFT International Symposium on
Foundations of Software Engineering , pages 576–587,
2014.
[16] A. S. Foundation. Apache cordova.
https://cordova.apache.org, 2015.[17] A. P. Fuchs, A. Chaudhuri, and J. S. Foster.
SCanDroid: Automated security certiﬁcation of
Android applications. Technical Report CS-TR-4991,
Department of Computer Science, University of
Maryland, College Park, 2009.
[18] M. Georgiev, S. Jana, and V. Shmatikov. Breaking
and ﬁxing origin-based access control in hybrid
web/mobile application frameworks. In Network and
Distributed System Security Symposium , 2014.
[19] Google. Chromium.
https://code.google.com/p/chromium/codesearch.
[20] Google. Remote debugging on Android with Chrome.
https://developer.chrome.com/devtools/docs/
remote-debugging.
[21] Google. WebView. http://developer.android.com/intl/
ko/reference/android/webkit/WebView.html.
[22] Google. WebView for Android. https://developer.
chrome.com/multidevice/webview/overview.
[23] Google. Shirink your code and resources.
http://developer.android.com/intl/ko/tools/help/
proguard.html, 2016.
[24] M. I. Gordon, D. Kim, J. H. Perkins, L. Gilham,
N. Nguyen, and M. C. Rinard. Information ﬂow
analysis of Android applications in DroidSafe. In
Network and Distributed System Security Symposium ,
2015.
[25] K. E. Gray. Safe cross-language inheritance. In
European Conference on Object-Oriented
Programming , pages 52–75, 2008.
[26] GuardSquare. Proguard.
http://proguard.sourceforge.net.
[27] IBM. T.J. Watson libraries for analysis. http:
//wala.sourceforge.net/wiki/index.php/Main Page.
[28] X. Jin, X. Hu, K. Ying, W. Du, H. Yin, and G. N.
Peri. Code injection attacks on HTML5-based mobile
apps: Characterization, detection and mitigation. In
Proceedings of the 2014 ACM SIGSAC Conference on
Computer and Communications Security , pages 66–77.
ACM, 2014.
[29] V. Kashyap, K. Dewey, E. A. Kuefner, J. Wagner,
K. Gibbons, J. Sarracino, B. Wiedermann, and
B. Hardekopf. JSAI: A static analysis platform for
JavaScript. In Proceedings of the International
Symposium on Foundations of Software Engineering ,
pages 121–132, 2014.
[30] H. Lee, S. Won, J. Jin, J. Cho, and S. Ryu. SAFE:
Formal speciﬁcation and implementation of a scalable
analysis framework for ECMAScript. In Proceedings of
the International Workshop on Foundations of
Object-Oriented Languages , 2012.
[31] D. Li, Y. Lyu, M. Wan, and W. G. Halfond. String
analysis for Java and Android applications. In
Proceedings of the 10th Joint Meeting on Foundations
of Software Engineering , pages 661–672, 2015.
[32] O. Matters. Mobile app backlog is directly damaging
revenue in the enterprise.
http://www.hlmtemp35.com/cm/dpl/downloads/
articles/236/Mobile-Trend-Statistics-Survey-2014.pdf.
[33] J. Matthews and R. B. Findler. Operational semantics
for multi-language programs. In Proceedings of the
34th Annual ACM SIGPLAN-SIGACT Symposium on
Principles of Programming Languages , 2008.
260[34] M. Media. Mobile advertising and app monetization
platform. http://www.millennialmedia.com.
[35] A. Milanova, A. Rountev, and B. G. Ryder.
Parameterized object sensitivity for points-to analysis
for Java. ACM ToSEM , 14(1):1–41, 2005.
[36] D. Octeau, P. McDaniel, S. Jha, A. Bartel, E. Bodden,
J. Klein, and Y. Le Traon. Eﬀective inter-component
communication mapping in Android with Epicc: An
essential step towards holistic security analysis. pages
543–558, 2013.
[37] H. Oh, K. Heo, W. Lee, W. Lee, and K. Yi. Design
and implementation of sparse global analyses for
C-like languages. In Proceedings of the SIGPLAN
Conference on Programming Language Design and
Implementation , 2012.
[38] Oracle. The Java ™tutorials. https://docs.oracle.com/
javase/tutorial/java/nutsandbolts/datatypes.html,
1995.
[39] OutSystems. State of application development report:
Mobility, custom apps a priority for 2015. https://
www.outsystems.com/1/mobility-custom-apps-report,
2015.
[40] C. Park and S. Ryu. Scalable and precise static
analysis of JavaScript applications via loop-sensitivity.
InProceedings of the European Conference on
Object-Oriented Programming , 2015.
[41] S. Perez. Majority of digital media consumption now
takes place in mobile apps. http://techcrunch.com/
2014/08/21/majority-of-digital-media-consumption-
now-takes-place-in-mobile-apps, 2014.
[42] T. Reps, S. Horwitz, and M. Sagiv. Precise
interprocedural dataﬂow analysis via graph
reachability. In Proceedings of the 22nd ACM
SIGPLAN-SIGACT Symposium on Principles of
Programming Languages , pages 49–61, 1995.[43] M. Rosoﬀ. Facebook is oﬃcially a mobile-ﬁrst
company. http://www.businessinsider.com/
facebook-mobile-only-users-most-common-2015-11,
2015.
[44] A. Rountev and D. Yan. Static reference analysis for
GUI objects in Android software. In Proceedings of
Annual IEEE/ACM International Symposium on Code
Generation and Optimization , 2014.
[45] M. Shehab and A. AlJarrah. Reducing attack surface
on Cordova-based hybrid mobile apps. In Proceedings
of the 2nd International Workshop on Mobile
Development Lifecycle , pages 1–8. ACM, 2014.
[46] I. Software. Ensuring application security in mobile
device environments. http://www-01.ibm.com/
common/ssi/cgi-bin/ssialias?htmlﬁd=
WGW03009USEN&appname=WWWSEARCH.
[47] Sufatrio, D. J. J. Tan, T.-W. Chua, and V. L. L.
Thing. Securing Android: A survey, taxonomy, and
challenges. ACM Computing Survey , 47(4):58:1–58:45,
May 2015.
[48] F. Tip. A survey of program slicing techniques.
Journal of Programming Languages , 3(3):121–189,
1995.
[49] C. Tumbleson and R. Wi´ sniewski. APKTOOL.
http://ibotpeaches.github.io/Apktool.
[50] N. Viennot, E. Garcia, and J. Nieh. A measurement
study of Google Play. In ACM SIGMETRICS
Performance Evaluation Review , volume 42, pages
221–233, 2014.
[51] W. Zhou, Y. Zhou, X. Jiang, and P. Ning. Detecting
repackaged smartphone applications in third-party
Android marketplaces. In Proceedings of the 2nd ACM
Conference on Data and Application Security and
Privacy, pages 317–326, 2012.
261