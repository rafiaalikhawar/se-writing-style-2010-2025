DistIA: A Cost-Effective Dynamic Impact Analysis for
Distributed Programs
Haipeng Cai
School of Electrical Engineering and Computer
Science
Washington State University, Pullman, WA, USA
haipeng.cai@wsu.eduDouglas Thain
Department of Computer Science and
Engineering
University of Notre Dame, Notre Dame, IN, USA
dthain@nd.edu
ABSTRACT
Dynamic impact analysis is a fundamental technique for under-
standing the impact of speciﬁc program entities, or changes to them,on the rest of the program for concrete executions. However, ex-isting techniques are either inapplicable or of very limited utility
for distributed programs running in multiple concurrent processes.
This paper presents D
ISTIA, a dynamic analysis of distributed sys-
tems that predicts impacts propagated both within and across pro-cess boundaries by partially ordering distributed method-execution
events, inferring causality from the ordered events, and exploiting
message-passing semantics. We applied D
ISTIA to large distribut-
ed systems of various architectures and sizes, for which it on av-erage ﬁnishes the entire analysis within one minute and safely re-duces impact-set sizes by over 43% relative to existing options with
run-time overhead less than 8%. Moreover, two case studies initial-
ly demonstrated the precision of D
ISTIA and its utility in distribut-
ed system understanding. While conservative thus subject to falsepositives, D
ISTIA balances precision and efﬁciency to offer cost-
effective options for evolving distributed programs.
CCS Concepts
•Software and its engineering →Software evolution;
Keywords
Impact analysis; distributed systems; dynamic partial ordering
1. INTRODUCTION
Program changes drive the evolution of software systems, yet al-
so pose threats to their quality and reliability [55]. Thus, it is crucial
to understand potential consequences of those changes even before
applying them to candidate program locations. To accomplish thistask, developers need to perform impact analysis [9, 57, 62] withrespect to those locations, an integral step of modern software de-
velopment process [56]. In particular, for developers working with
concrete executions of the program, dynamic impact analysis [9,40]
is an attractive option as it narrows down the search space of suchimpacts to the speciﬁc context of those executions.Dynamic impact analysis has been extensively investigated [40],
resulting in a rich and diverse set of relevant techniques and tools(e.g., [4, 11, 13, 39]). However, most existing approaches addresssequential programs only, with fewer targeting concurrent yet cen-tralized software [25, 27, 35, 65] and very few applicable to dis-tributed systems. To accommodate the increasingly demandingperformance and scalability needs of today’s computation tasks,more distributed systems are being deployed than centralized ones,raising an urgent call for techniques, including impact analysis, for
cost-effective evolution of those systems [8, 24, 30].
Dynamic code analyses for distributed systems also have been
explored early on [18, 31, 34] and more in recent years [7, 44, 52],largely focusing on detailed analysis of program dependencies. How-ever, the majority of these approaches were designed only for pro-
cedural programs [7]. For distributed object-oriented programs,
backward dynamic slicing algorithms have been developed, yet it
is still unclear whether they can work with (and scale to) real-worldsystems [7, 44]. And for impact analysis, forward slicing would be
needed. Nevertheless, the ﬁne-grained (statement-level) analysis
used by slicing would be overly heavyweight for impact analysiswhich is commonly adopted at method level [4, 9, 11, 39, 40].
Unfortunately, developing a cost-effective dynamic impact anal-
ysis for real-world distributed systems remains challenging. One
major difﬁculty lies in the lack of explicit invocations or references
among decoupled components of those systems [27,30,64], where-as traditional approaches often rely on such explicit information tocompute dependencies for impact prediction. Lately, various anal-
yses other than slicing have also been proposed [24, 53, 64]. While
efﬁcient for static impact analysis, these approaches are limited to
systems of special types such as distributed event-based systems
(DEBS) [45], or rely on specialized language extensions like Even-tJava [19]. Other approaches are potentially applicable in a wider
scope yet depend on information that is not always available, such
as execution logs of particular patterns [41], or suffer from overly-coarse granularity (e.g., class-level) [24, 41, 53] and/or unsound-ness [46], in addition to imprecision, of analysis results.
We have developed D
ISTIA, a dynamic impact analysis for com-
monly deployed distributed systems where components communi-cate via socket-based message passing. We deﬁne a componen-t as the code that runs in a separate process from all other part-s of the system. By exploiting the happens-before relation [38]
between method-execution events and the semantics of message
passing among distributed components, D
ISTIA predicts impacts
of one method on others of a given system both within and acrossits concurrent processes. Our approach offers rapid results that
are safe [29] relative to the analyzed executions, while relying on
neither well-deﬁned inter-component interfaces nor message-typespeciﬁcations needed by peer approaches (e.g., those for DEBS).
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciﬁc permission and/or a
fee. Request permissions from Permissions@acm.org.
ASE’16 , September 3–7, 2016, Singapore, Singapore
c2016 ACM. 978-1-4503-3845-5/16/09...$15.00
http://dx.doi.org/10.1145/2970276.2970352
344
1 public class S{
2 Socket ssock = null ;
3 public S(intport) { ssock = new Socket(port); ssock.accept(); }
4 char getMax(String s) {...}
5 void serve() { Strin g s = ssock.readLine();
6 char r = getMax(s); ssock.writeChar(r); }
7 public static int main(String[] a) {
8 Ss= new S(33); s.serve(); return 0; }}
9 public class C{
10 Socket csock = null ;
11 public C(String host, intport) { csock = new Socket(host,port); }
12 void shufﬂe(String s) {...}
13 char compute(String s) { shufﬂe(s); csock.writeChars(s);
14 return csock.readChar(); }
15 public static int main(String[] a ){Cc= new C(’localhost’ ,33);
16 System.out.println( c.compute(a[0]) ); return 0; }}
Figure 1: An example distributed program Econsisting of two
components: S (server) and C (client).
We evaluate D ISTIA on six distributed Java programs, includ-
ing four enterprise-scale systems, and demonstrate that it is ableto work with large, complicated distributed systems using block-ing and/or non-blocking (e.g., selector-based [5]) communication.
In the absence of more advanced techniques, we compare with a
coverage-based approach [51], which reports as impacted all meth-ods covered in the utilized executions, as a safe baseline alternative,and measure the effectiveness of D
ISTIA against it. The results
show that D ISTIA can greatly reduce the size of potential impacts
to be inspected by over 43% on average, relative to the baseline, atthe mean cost of one minute to ﬁnish the one-time instrumentationand 65ms to query impacts, with run-time overhead less than 8%.
Since there is no automatic approach available for computing
ground-truth impacts, we manually evaluated the precision of D
IS-
TIA on randomly selected cases. We regard a method having any
statement data and/or control dependent on any statement of thequeried method (i.e., the query )a sa true positive , and the precision
as the fraction of predicted impacts that are true positives. Also, we
explored the usefulness of D
ISTIA in program comprehension in a
second case study. Our results suggest that developers using D IS-
TIA may expect an average precision of around 70% and consider-
able beneﬁts in understanding distributed programs and executions.
The main contributions of this work include:
•The ﬁrst dynamic impact analysis, D ISTIA, for distributed sys-
tems where components run in concurrent processes and com-municate only via socket-based message passing (Section 3).
•An open-source implementation of D
ISTIA working with di-
verse, large enterprise distributed systems that use either or
both of blocking and non-blocking communication (Section 4).
•An evaluation of D ISTIA showing its promising effectiveness
and scalability, and demonstrating its expected accuracy as wellas utility in understanding distributed programs (Section 5).
2. MOTIV ATION AND BACKGROUND
2.1 Motivating Example
When maintaining and evolving a distributed program which
consists of multiple components, the developer needs to under-stand potential change effects not only in the component where thechange is proposed, but also in all other components. To achievebetter ﬂexibility and scalability, the components that constitute a
distributed system are usually loosely coupled or entirely decou-
pled as a result of implicit invocations among them realized vi-a socket-based message passing. This design paradigm, however,greatly reduces the utility of existing impact-analysis techniques.
Consider the example program Eof Figure 1, which consists
of two components: a server and a client, implemented in classes STable 1: A full method event sequence of program E
Server process Client process
Method Event Timestamp Method Event Timestamp
S::main e 0C::main e 0
S::init e 1C::init e 1
S::init i 2C::init i 2
S::init x 3C::init x 3
S::main i 4C::main i 4
S::serve e 5C::compute e 5
Ec(C,S) -C::shuffle e 6
S::getMax e 10 C::shuffle i 7
S::getMax i 11 C::shuffle x 8
S::getMax x 12 C::compute i 9
S::serve i 13 Ec(C,S) -
Ec(S,C) -Ec(S,C) -
S::serve x 14 C::compute x 14
S::main i 15 C::main i 15
S::main x 16 C::main x 16
andC, respectively. The client simply retrieves the largest character
in a given string by sending the task to the server (line 13), which
ﬁnishes the task and sends the result back to the client (line 6). Sup-pose now the developer proposes to apply a new algorithm in theS::getMax method as part of an upgrade plan for the server and,
thus, needs to determine which other parts of the program may have
to be changed as well. Having an available set Iof inputs, the de-
veloper wants to perform a dynamic impact analysis to get a quickbut safe estimation of the potential impacts of the candidate change
with respect to the program executions on I. Note that static ap-
proaches would be largely disabled by the implicit communicationvia socket between these two components.
To accomplish this task, method-level dynamic impact-prediction
techniques of various cost-effectiveness tradeoffs (e.g., [4, 11, 13])
seem to be able to offer the developer many options. However, s-
ince there is no explicit dependencies between SandC, existing
approaches would predict impacts within the local component (i.e.,
where the changes are located; Sin this case) only. In consequence,
the developer would have to ignore impacts in remote components
(Cin this case), or make a worst-case assumption that all methods
in remote components are to be impacted.
Scope. As illustrated by E, the distributed system we address is
one in which components located at networked computers commu-
nicate and coordinate their actions only by passing messages [17]:
The components run concurrently in multiple processes without a
global clock , making it hard to infer impacts across components.
2.2 Dynamic Impact Analysis
Typically, a dynamic impact analysis technique inputs a pro-
gram P, an input set I, and a query set M (the set of methods
for which impacts are to be queried), and outputs an impact set (the
set of methods in Ppotentially impacted) of M when running I.
One representative such technique is based on the execute-after-sequences (EAS) [4], which computes impacts from the executionorder of methods. Given a query c, EAS considers all methods that
execute after cas potentially affected by cor by any changes to it.
To ﬁnd the execution order, EAS records two main method events
using two integers for each method m: the ﬁrst time mis en-
tered and the last time program control is returned into m. Then,
the analysis infers the execute-after relations according to the oc-
currence time of those events. In presence of multi-threaded ex-ecutions, EAS monitors also method returns and treats them asreturned-into events. For the concrete set of executions, no method-s that never executed after the query ccan be impacted by it; thus,
the results produced by EAS are safe (i.e., of 100% recall) relative
345to those executions [29]. However, the execute-after relation does
not always lead to impact relation since a method may execute after
the query yet has no any dependence on that query; thus, EAS is
imprecise due to its conservative nature [12].
On the other hand, the need for maintaining only little informa-
tion (i.e., the two integers per method) enables the high efﬁciencyof EAS. Therefore, despite of its known imprecision, impact anal-
ysis using execute-after relations like EAS remains a viable option,
especially for users who desire getting a safe approximation of im-pacts quickly, such as the developer in the above example scenario.In fact, to the best of our knowledge, EAS is still the most efﬁ-
cient dynamic impact analysis to date [11, 13, 14]. Thus, as the ﬁrst
attempt exploring efﬁcient dynamic impact analysis for distributedsystems, we start with an EAS-based approach in this work.
2.3 Timing in Distributed Systems
Adopting analyses like EAS for distributed systems is challeng-
ing, though, because the execution order of methods is not observedacross multiple processes in such systems due to the lack of a globalclock. A lightweight approach to clock synchronization, the Lam-
port timestamps (LTS) algorithm [38] employs logical clocks to
partially order distributed events over concurrent processes. Foreach process P
i, the LTS approach ﬁrst deﬁnes a logical clock Ci
which is a function that assigns a number Ci/angbracketlefta/angbracketrightto an event ain
Pi. Then, an event ahappens before another event bimplies the
number assigned to ais less than that assigned to b, or formally
a−→ b=⇒C/angbracketlefta/angbracketright<C/angbracketleftb/angbracketright (1)
which is called the clock condition . To maintain this condition, the
following rules [38] must be observed during the system execution:
•Each process Piincrements Cibetween any two successive
events that happen in Pi.
•If event ais that process Pisends a message m, then the mes-
sage contains a timestamp Tm=Ci/angbracketlefta/angbracketright.
•When a process Pjreceives a message m, it sets Cjgreater
than or equal to its current value and greater than Tm.
For our solution to impact analysis for distributed systems, the
LTS algorithm can be utilized to preserve the partial ordering of
distributed events across multiple processes running on separatedmachines. Further, this ordering would enable inferring causalitybetween methods hence the computation of impacts of one method
on others both within and across system components.
3. APPROACH
To achieve an efﬁcient dynamic impact analysis for distributed
programs, D ISTIA utilizes only lightweight run-time information
such as method execution order. We ﬁrst present the fundamentals
underlying our approach, including the deﬁnition of method events
used by D ISTIA and its rationale for impact prediction. Then, we
give an overview and illustration of the inner workings, followedby details on the analysis algorithms, of the D
ISTIA approach.
3.1 Fundamentals
3.1.1 Method-Execution Events
In the general context of distributed systems, an event is deﬁned
as any happening of interest observable from within a comput-er [38]. More speciﬁcally, events in a DEBS are often expressed
as messages transferred among system components and deﬁned by
a set of attributes [24,45]. While it also deals with message passingin distributed systems, D
ISTIA neither makes any assumption nor
reasons about the structure or content of the messages. Particular-ly for dynamic impact analysis, D
ISTIA monitors and utilizes two
major classes of events as deﬁned below:•Communication Event. A communication event ECis the
occurrence of a message transfer between two componentsc1andc2, denoted as E
C(c1,c2)i fc1initiates ECwhich
attempts to reach c2. Further, according to the direction
of message ﬂow, we distinguish two major subcategories ofsuch events: sending a message to a component and receiv-
ing a message from a component. We refer to the process
running the component that sends and receives the message
as the sender process and receiver process , respectively.
•Internal Event. An internal event E
Iis an occurrence of
method execution within a component c, denoted as EI(c).
Further, we differentiate three subcategories of internal events:
entering a method ,returning from a method , and returning
into a method , denoted as me,mx, and mi, respectively, for
the relevant method m.
For internal events, we capture both the return and returned-into
events for each method. However, we distinguish them during in-
strumentation only and treat them equally in the monitoring algo-rithm (Section 3.3.2). In sequential program executions, a method
mis potentially affected by any changes in the query cifm, or part
of it, executes after c, and monitoring method entry and returned-
into events sufﬁces for retrieving such execute-after relations; in
the case of concurrent (single-process) programs, however, mis
potentially affected by the changes also if m, or part of it, executes
in parallel with c, and method return events need to be monitored
as well in order to correctly identify the impact relations from in-
terleaving method executions in multiple threads, as shown in [4].
3.1.2 Basic Impact Inference
One challenge to developing D ISTIA is to infer impact relations
based on execution order in the presence of asynchronous events
over concurrent multiprocess executions. Fortunately, maintaininga logical notion of time per process to discover just a partial order-ing of method-execution events sufﬁces for that inference requiredin D
ISTIA. The impact relation between any two methods can be
semantically over-approximated by the happens-before relation be-
tween relevant internal events of corresponding methods; and thepartial ordering of the internal events reveals such happens-beforerelations [38]. Formally, given two methods m1andm2,w eh a v e
m1
e≺m2x/logicalordisplay
m1e≺m2i=⇒m1impacts m2 (2)
where≺denotes the happens-before relation. Without loss of gen-
erality, m1e≺m2xandm1e≺m2iimply that “ m2executes after
or in parallel with m1, thus m2may be affected by (any changes
in)m1", hence the impact relation between m1andm2.
Based on the above inference, for a given query c, computing the
impact set IS(c)o fcis reduced to retrieving methods, from multi-
process method-execution event sequences, that satisfy the partialordering of internal events of candidate methods as follows:
IS(c)={m|c
e≺mi∨ce≺mx} (3)
Note that only internal events are directly used for impact inference,
while communication events are utilized to maintain the partial or-dering of internal events in all processes. Also, while the impact
inference in D
ISTIA is conservative, it is sound [29] and only re-
quires lightweight dynamic analysis and computation.
3.1.3 Exploiting Message-Passing Semantics
The above basic inference leads to a safe yet possibly overly con-
servative approximation of dynamic impacts, because it is based
purely on happens-before relations between method events. How-ever, since message passing is the only communication channel be-tween processes in the systems we address (Section 2.1), a methodP
1min process P1would not be impacted by a method P2min
process P2ifP1never received a message from P2before the last
34601…... 20 …... 80 …...
m1(last)m2(first)
Process P 1
01…... 10 …... 95 …...
m3(first)m4(last)
Process P 2 97
m5(last)
Figure 2: Inter-process impact constrained by message passing.
execution event of P1m,e v e ni f P1mis ever executed after P2min
the whole-system method event partial ordering.
Figure 2 illustrates how message passing could constrain the im-
pact relation deﬁned by Equation 2. Each numbered cell represents
the ﬁrst or last execution event of a method with the number in-dicating the time (stamp) when that event occurs, and each emptycell represents a message receiving or sending event. The left and
right arrowed lines indicate the ﬁrst message passing from P
2to
P1andP1toP2, respectively. m1inP1was executed after, but
would not be impacted by, m3inP2since P2sent the ﬁrst message
toP1after the last time m1was executed. Similarly, m5would not
be impacted by m2.m4, however, is potentially impacted by m2
because m4was executed after P2received a message from P1.
More generally, considering the message-passing semantics, Pim
is potentially impacted by Pjm/primeonly if (1) the ﬁrst execution even-
to fPjm/primehappens before the last execution event of Pim, (2) Pj
sends at least one message to Pi, and (3) the last execution event
ofPimhappens after the ﬁrst message receiving event in Pifrom
Pj. Formally, let TF(m)andTL(m)denote the time (stamp) of
the ﬁrst and last execution event of a method m, respectively, and
TS(P)denote the time (stamp) of the event of receiving the ﬁrst
message from process P, we deﬁne a customized form of partial
order relation between two methods PimandPjm/primeas follows:
Pjm/prime≺Pim:=⎧
⎪⎪⎪⎨
⎪⎪⎪⎩T
L(Pim)≥TF(Pjm/prime), ifi=j
TS(Pj)/negationslash=null∧TL(Pim)≥
max(TF(Pjm/prime),TS(Pj)),ifi/negationslash=j(4)
With this constrained deﬁnition of ≺, a more precise impact in-
ference is obtained from Equation 3 since the potentially impactedmethods identiﬁed by the basic inference that do not satisfy the ad-ditional constraints (2) and (3) will be pruned. Again, given thescope of distributed systems we address, this pruning does not re-
duce the safety of resulting impact sets. To facilitate our discus-
sion and evaluation later on, hereafter we refer to D
ISTIA with and
without the pruning as its basic and enhanced version, respectively.
3.2 Technique Overview
3.2.1 Workﬂow
The overall workﬂow of our technique is depicted in Figure 3,
where the three primary inputs are the program Dunder analysis,
a set Iof program inputs for D, and a query set M.A n optional
input, a message-passing API list Lcan also be speciﬁed to help
DISTIA identify program locations where probes for communica-
tion events should be instrumented (as detailed in Section 4). Theoutput of D
ISTIA is a set of potential impacts of Mcomputed from
the given inputs in four steps as annotated in the ﬁgure.
The ﬁrst step instruments the input program Dfor both moni-
toring method-execution and message-passing events, and for syn-chronizing logical clocks among concurrent processes. This step
produces the instrumented version D
/primeofD. The second step ex-
ecutes D/primeon the given input set I, during which internal events
are produced and time-stamped by means of communication eventssuch that the partial order for all internal events is preserved. Mean-while, a message-receiving map is produced, where each entry indi-
Instrument D(using L)
for monitoring method execution and 
message-passing events while 
transferring logical clocks
Distributed 
Program D
Query 
Set MUser inputs
Program 
Input Set I
Instrumented Program D’
Run D’on I
for generating partially-ordered 
method-execution sequence and 
message-receiving map per process 
Message-passing 
API List L
Distributed Per-process Traces
Gather Traces
for facilitating impact 
computation
Compute 
Impacts
Centralized 
Traces
Impact Set 
of M
DISTIA output
 ޽
޾
߀޿
Figure 3: The overall workﬂow of D ISTIA, where the num-
bered steps are detailed in Section 3.2.1.
cates the sending process and time of a message-receiving event—
for each unique sending process only the ﬁrst such event is record-ed. In the third step , event traces generated in all processes are
gathered to the machine where the impact computation is to be per-
formed. The fourth step takes the query set M and centralized
traces to compute the impact set of Musing the impact inference.
3.2.2 Illustration
To illustrate the above process ﬂow, consider program Eof Fig-
ure 1. D ISTIA ﬁrst instruments Eand produces the instrumented
server and client components S/primeandC/prime. Then, suppose the com-
ponents are deployed on two distributed machines, and S/primestarts
before C/prime. When running concurrently, S/primeandC/primegenerate two
method-event sequences in two separate processes, as listed in full
in the ﬁrst two and last two columns in Table 1, respectively. Asshown, logical clocks are updated upon communication events. For
instance, the logical clock of the server process is ﬁrst updated to
10 upon the event E
c(C,S) originated in the client process, which
is greater by 1 than the current logical clock of the client process.Later, the client logical clock is updated to 14 upon E
c(S,C). The
internal events are time-stamped by these logical clocks while com-
munication events are not, as marked by ‘-’ (i.e., not applicable).
Next, suppose the query set M={S::serve },D ISTIA gathers
traces of the two processes and, by inferring impact relations fromthe time-stamped events, the basic version gives {S::getMax ,
S::serve ,S::main ,C::shuffle ,C::compute ,C::main }
as the impact set of M. By exploiting message-passing semantics,
the enhanced version prunes C::shuffle from this impact set
according to Equation 4. As demonstrated, D
ISTIA can predict
impacts across distributed components (processes). For example,
if the developer plans for a change to method serve in the server,
the methods compute andmain in the client, in addition to the
other two server methods, are potentially affected and, thus, needimpact inspection by the developer before applying that change.
3.3 Analysis Algorithms
3.3.1 Partial Ordering of Internal Events
Preserving the partial ordering of internal events is at the core of
the basic D ISTIA, for which we adopt the LTS approach [38] as
described before based on a logical notion of time.
Algorithm 1 summarizes in pseudo code the D ISTIA algorithm
for partially ordering internal events based on the original LTS. The
logical clock of the current process Cis initialized to 0 upon pro-
cess start, as is the global variable remaining , which tracks the
347Algorithm 1 Monitoring communication events
letCbe the logical clock of the current process
remaining = 0 // remained length of data to read
1:function SEND MESSAGE (msg )// on sending a message msg
2: sz= length of sz+ length of C+ length of msg
3: ifusing the enhanced version then
4: sz+= length of the sender process id sid
5: pack sz,C,sid , and msg , in order, to d
6: else
7: pack sz,C, and msg , in order, to d
8: write d
9:function RECV MESSAGE (msg )// on receiving a message msg
10: read data of length lintodfrom msg
11: ifremaining >0then
12: remaining -= l
13: return d
14: retrieve and remove data length kfrom d
15: retrieve and remove logical clock tsfrom d
16: remaining = k- length of k- length of ts-l
17: ifts > C then
18: C=ts
19: increment Cby 1
20: ifusing the enhanced version then
21: retrieve and remove sender process id sid from d
22: add ( sid ,C) to the message-receiving map if sid/∈its key set
23: remaining -= length of sid
24: return d
remaining length of data most recently sent by the sender process.
The rest of this algorithm consists of two parts, as are trigged uponthe occurrence of communication events during system executions.
The ﬁrst part is the run-time monitor S
END MESSAGE trigged
online upon each message-sending event. The monitor piggybacks
(prepends) two extra data items to the original message: the totallength sz of the data to send, and the present value of the local
logical clock C(of this sender process) (lines 2–7); then, it sends
out the packed data (line 8). The sender process id is also packed
in the enhanced version (lines 3–5).
The second part is the other monitor R
ECV MESSAGE , which is
trigged online upon each message-receiving event. After readingthe incoming message into a local buffer d(line 10), the moni-
tor decides whether to simply update the size of remaining dataand return (lines 11–13), or to extract two more items of data ﬁrst:
the new total data length to read, and the logical clock of the peersender process (lines 14–15). In the latter case, the two items are
retrieved, and then removed also, from the entire incoming mes-
sage. Next, the remaining data length is reduced by the length ofthe data already read in this event (line 16), and the local logicalclock (of this receiver process) is compared to the received one,
updated to the greater, and incremented by 1 (lines 17–19). In the
enhanced version, the sender process id is retrieved as well (line 21)
and a new entry is added to the message-receiving map if this is theﬁrst message received from that sender process (line 22). Lastly,the monitor returns the message as originally sent in the system
(i.e., with the prepended data taken away).
To avoid interfering with the message-passing semantics of the
original system, D
ISTIA keeps the length of remaining data (with
the variable remaining in the algorithm) to determine the right
timing for logical-clock (and sender id) retrieval. In real-world dis-
tributed programs (e.g., Zookeeper [3]), it is common that a re-
ceiver process may obtain, through several reads, the entire data
sent in a single write by its peer sender process. For example, a
ﬁrst read just retrieves the data length so that an appropriate size of
memory can be allocated to take the actual data content in a second
read. Therefore, not only is it unnecessary to attempt retrieving theprepended data items (data length and logical clock) in the secondread since the ﬁrst one should have already done so, but also suchAlgorithm 2 Computing impact sets
letP1,P2, ..., P nbe the nconcurrent processes of the system
letcbe the query method
1:locIS =∅,extIS =∅,comIS =∅
2:fori=1 to ndo
3: tsq= computeLocalImpact( c,locIS ,tr(Pi))
4: iftsq==null then continue
5: forj=1 to ndo
6: ifi== jthen continue
7: ifusing the enhanced version ∧S(tr(Pj))[Pi]==null then
8: continue
9: for each method m∈keyset(R(tr( Pj)))do
10: ifR(tr( Pj))[m]> = tsqthen
11: ifusing the enhanced version then
12: ifR(tr( Pj))[m]> = S(tr(Pj))[Pi]then
13: extIS∪={m}
14: else
15: extIS∪={m}
16: comIS =locIS ∩extIS
17: return locIS ,extIS ,comIS
attempts can break the original network I/O protocols. D ISTIA ad-
dresses this issue by piggybacking the length of data to send andtracking the remaining length of data to receive.
3.3.2 Monitoring Internal Events
The basic impact inference in D ISTIA relies on the execution or-
der of methods that is deduced from the timestamps attached to allinternal events, for which D
ISTIA monitors the occurrence of each
internal event. However, as proved in [4], recording the ﬁrst entry
and last returned-into (or return) events only is equivalent to tracing
the full sequence of those events for the dynamic impact analysis.Similarly, this equivalence also applies in D
ISTIA. Thus, instead
of keeping the timestamp for every internal-event occurrence (as
shown in Table 1), D ISTIA only records two key timestamps for
each method m: the one for the ﬁrst instance of me, and the one
for the last instance of miormx, whichever occurs later.
Accordingly, the online algorithm for monitoring internal events
uses two counters to record the two key timestamps for each method,
similar to what EAS does but different in that it does so in each pro-
cess rather than in just one process. Also, we use the per-process
logical clock, instead of a global integer as used by EAS, to up-
date the per-method counters during runtime. In the meanwhile,
the logical clock Ciof each process Piis maintained as follows:
•Initialize Cito 0 upon the start of Pi.
•Increase Ciby 1 upon each internal event occurred in Pi.
•Update Ciupon each communication event occurred in Pivia
the two online monitors shown in Algorithm 1.
Finally, for the ofﬂine impact computation in D ISTIA, the online
algorithm here also dumps per-process internal-event sequences
(i.e., the two timestamps for each executed method) as traces uponthe event of program termination (of each component). Addition-ally, in the enhanced version, the message-receiving map is alsoserialized as part of the per-process traces.
3.3.3 Impact Computation
During system executions, the online internal-event monitoring
algorithm generates event traces concurrently (and usually on dis-tributed machines). Since it computes impacts ofﬂine, D
ISTIA
gathers these traces after they are produced to one machine, and
computes impact sets there as outlined in Algorithm 2.
For a detailed analysis, we refer to the process where the query is
ﬁrst executed as local process versus all other processes as remote
process , and impacts in local and remote processes as local impacts
and remote impacts , respectively. For a given query c,D ISTIA
348computes its impact set as three subsets of interest: local impact
set,remote impact set , and their intersection referred to as common
impact set (denoted as locIS ,extIS , and comIS , respectively).
The algorithm takes candnper-process traces as input, and out-
puts the three subsets (line 17) all initialized as empty sets (line1). It traverses the nprocesses (loop 2–15) taking each as the lo-
cal process (line 2) against all others as remote processes (lines 5
and 6) to ﬁrst obtain the local impact set (line 3) and then the re-
mote impact set (loop 7–15) based on Equation 4. tr(P) denotes the
trace of process P,R(t) denotes the hashmap from each executed
method to its last execution event time in trace t,S(t) denotes the
hashmap from the id of each sender process to the event time when
the remote process receives the ﬁrst message from the sender, andkeyset(.) returns the key set of a hashmap. In the enhanced version,
if the (remote) process P
jnever received any message from the
(local) process Pi, no remote impacts would be found in Pj(lines
7–8). The subroutine computeLocalImpact identiﬁes meth-
ods whose last execution is not earlier than the ﬁrst execution of c
intr(Pi)as in EAS [4], and unionizes the local impact set in that
trace with locIS . It returns the ﬁrst execution event time tsqofcif
cis found in the input trace and null otherwise (line 4). With re-
spect to a single test, the impact-computation algorithm computesthe impact set of one method at a time; for multiple methods in thequery set, the result is the union of all the one-method impact setscomputed separately (e.g., in parallel). Similarly, the impact set for
multiple tests is the union of all per-test impact sets.
With the enhanced version, we focus on safely reducing only the
remote impact sets produced by the basic version. A complemen-tary approach would be to reduce local impacts, such as through
static-dependence-based pruning as in [11]. It is straightforward
to incorporate such approaches in D
ISTIA to further improve its
effectiveness, but that will largely increase the cost as well [13].
4. IMPLEMENTATION
DISTIA1consists of three main modules: an instrumenter, two
sets of run-time monitors, and a post-processor. Careful treatments
are crucial for a non-interfering implementation as recaped below.
4.1 Instrumenter
DISTIA instruments the input program such that all relevan-
t events are monitored accurately, which is crucial to the sound-
ness [29] and precision of D ISTIA. We used Soot [37] for the in-
strumentation in two main steps. First, D ISTIA inserts probes for
the three types of internal events in each method, for which wereused relevant modules of D
IVER [11], a hybrid impact analysis
that is built on Soot and uses method-execution traces also. The
second step is to insert probes for communication events, for which
DISTIA uses the list Lof speciﬁed message-passing APIs to identi-
fy probe points based on string matching: Lincludes the prototype
of each API used in the input system for network I/Os. If Lis not
speciﬁed, a list of basic Java network I/O APIs is used covering t-wo common means of blocking and non-blocking communication:
Java Socket I/O [50] and Java NIO [49] (both are socket-based ).
4.2 Run-time Monitors
The two sets of run-time monitors implement the two online al-
gorithms: the ﬁrst focuses on monitoring internal events and the
second is dedicated to preserving the partial ordering of them. The
ﬁrst set again reuses relevant parts of D IVER [11]. For the second
set, instead of invoking additional network I/O API calls to transferlogical clocks, the monitors take over the original message passing
1Code and study results are at https://chapering.github.io/distea/.so that they can piggyback the three extra data items (i.e., the data
length, logical clock, and sender id) to the original message.
Our experience comparing different instrumentation schemes sug-
gested that the piggyback strategy is more viable than inserting ad-ditional network I/O API calls, especially when dealing with sys-tems using selector-based non-blocking communications [5]. Forinstance, the ShiV ector tool [1, 8], which adopts the latter, works
with only two of our six subject programs (MultiChat and V olde-
mort). One reason as we veriﬁed is that, for a pair of an original calland the corresponding additional call, the two messages may notbe read in the same order by the receiver process as in which they
are sent by the sender process. As a result, an original message-
receiving call may encounter unexpected data in the message hencecausing network I/O protocol violations even system failures.
4.3 Post-processor
The post-processer is the module that actually answers impact-
set queries. To that end, it starts by gathering distributed traceswith a helper script which passes per-process traces to the ofﬂineimpact-computation algorithm. To compute the impact set follow-
ing Algorithm 2, the post-processor retrieves the partial ordering of
internal events by comparing the associated timestamps.
5. EV ALUATION
Our evaluation was guided by the following research questions:
•RQ1 How effective is D ISTIA compared to existing options?
•RQ2 How are the impacts distributed across process bound-
aries in the impact sets given by D ISTIA?
•RQ3 How efﬁcient and scalable is D ISTIA?
The main goal of this evaluation was to investigate the effective-
ness (RQ1) and efﬁciency (RQ3) of D ISTIA. We also intended to
examine the composition of D ISTIA impact sets concerning how
impacts propagate within and across constituent components (pro-cesses) in distributed systems (executions) (RQ2).
5.1 Experiment Setup
We evaluated D ISTIA on six distributed Java programs, as sum-
marized in Table 2. The size of each subject is measured by thenumber of non-comment non-blank Java source lines of code ( #S-
LOC ) and number of methods deﬁned in the subject ( #Methods )
that we actually analyzed. The last two columns list the type of
test input used in our study (one test case per type) and the numberof methods executed at least once in the respective test ( #Cov.M. )
which we all used as impact-set queries. The third and ﬁfth column-
s together also give the method-level coverage of the test inputs.
MultiChat [26] is a chat application where multiple clients ex-
change messages via a server broadcasting the message sent byone client to all others. NioEcho [61] is an echo service via whichthe client just gets back the same message as it sends to the serv-
er. Open Chord is a peer-to-peer lookup service based on dis-
tributed hash table [6]. ZooKeeper [3, 28] is a coordination ser-vice for distributed systems to achieve consistency and synchro-nization. V oldemort [2] is a distributed key-value storage system
used at LinkedIn. Freenet [63] is a peer-to-peer data-sharing plat-
form offering anonymous communication. Some of these systemsuse Socket I/O or Java NIO only, while others use both mechanism-s, for message passing among their components. For all subjects,we checked out from their ofﬁcial online repositories the latest ver-
sions or revisions as shown in (the parentheses of) Table 2.
We chose these subjects such that varied system scales and archi-
tectures, application domains, and uses of either and both of block-ing and non-blocking I/Os are all considered. We chose test inputs
to cover different types of inputs when possible, including system
349Table 2: Statistics of experimental subjects
Subject (version) #SLOC #Methods Test type #Cov.M.
MultiChat (r5) 470 37 integration 25
NIOEcho (r69) 412 27 integration 26
Open Chord (v1.0.5) 38,084 736 integration 354
ZooKeeper (v3.4.6) 62,450 4,813integration 749
system 817
load 798
V oldemort (v1.9.6) 163,601 17,843integration 2,048
system 1,242
load 1,323
Freenet (v0.7.0) 196,281 16,673 integration 2,477
test, integration test, and load test, which we assume exercise typi-
cal, overall system behaviour instead of a small speciﬁc area of thesource code. The integration tests were created manually, while the
other types of inputs come with the subjects in their repository.
In each integration test, we started two to ﬁve server and client
nodes on different machines and performed client operations thatcover main system services—specially for peer-to-peer systems,
we operated on all nodes, and for ZooKeeper we started a container
node in addition. For MultiChat and NioEcho, the client requestswere sending random text messages. For ZooKeeper, the orderedclient operations were: create two nodes, look up for them, checktheir attributes, change their data association, and delete them. For
V oldemort, the operations were: add a key-value pair, query the key
for its value, delete the key, and retrieve the pair again. For OpenChord, the operations were in order: create an overlay network onmachine (node) A, join the network on machines B and C, insert
a new data entry to the network on C, look up and then delete the
data entry on A, and list all data entries on B. For Freenet, we ﬁrstuploaded a ﬁle to the network with a note on node A, shared it tonodes B and C, then on B and C accepted the sharing request andthe note, followed by downloading the ﬁle and replying with a note.
5.2 Experimental Methodology
As mentioned earlier, we did not have existing dynamic impact
analysis to compare with D ISTIA. Similarly, we know of no avail-
able (dynamic) slicer working with real-world distributed systemslike our subjects. A possible alternative to D
ISTIA is a coverage-
based approach (referred to as MCov ) which takes all methods ex-
ecuted in remote processes as potentially impacted. In fact, MCov
is a realistic solution adapted for distributed systems from C OVER -
AGE IMP ACT [51], a major existing option for centralized programs.
Thus, we consider MCov as the baseline technique and the covered
(executed) sets of methods as baseline impact sets.
We considered every method of each subject as a query, yet
we report results only for queries executed at least once in oneprocess—only such queries have a non-empty impact set. For meth-
ods executed in more than one processes, we took them as separate
queries each per process. For each query, we measure the effec-tiveness of D
ISTIA by comparing the impacts it predicted to those
given by MCov in terms of impact-set size ratios, and examine the
composition of the impact set concerning its two subsets: local
impact set and remote impact set , while also analyzing the com-
mon impact set . Accordingly, we also measure the effectiveness of
DISTIA with respect to these subsets relative to the corresponding
MCov results. Finally, besides the impact querying time, we re-
port the instrumentation and run-time costs of D ISTIA, and storage
costs of event traces, all as efﬁciency metrics. We also compare theeffectiveness and efﬁciency of the basic versus the enhanced ver-sion. The machines used in our studies were all Linux workstations
with an Intel i5-2400 3.10GHz CPU and 8GB DDR2 RAM.5.3 Results and Analysis
5.3.1 RQ1: Effectiveness
Figure 4 shows the effectiveness of the basic D ISTIA, with one
plot depicting the data distribution for each subject and input type,
shown as the plot title (hereafter, the input type is omitted for sub-jects for which only an integration test is available and utilized).Each plot includes three box plots showing that data distribution
for one of three categories (on xaxis): the holistic impact set ( all)
and its two subsets ( local and remote ), with each underlying data
item indicating the effectiveness metric (on yaxis) for one query.
The total numbers of queries involved are shown in the parentheses.
The results indicate that even the basic version is much more ef-
fective than MCov , reducing the impact sets of the latter by 10%
up to over 45% in most cases (see the 75% quartiles). Comparedto the small subjects, the four large subjects see noticeably bettereffectiveness. Also, the ratios with respect to all (rightmost box-
plots) impact sets are mostly higher than those to the two subsets.
The reason is that the two subsets from both approaches have sub-stantial intersections, while the ones from D
ISTIA are consistently
smaller than those from MCov .
Complementary to the ﬁve-number summaries of Figure 4, Ta-
ble 3 (left seven columns) gives the mean effectiveness. Overall,
the basic D ISTIA reports on average only 69% of the impacts pro-
duced by MCov . In particular, the reductions in remote impact sets
are even higher, by 38% on average and well above 35% mostly
for the three largest subjects. This implies that, relative to the base-
line, developers can save the time that would be spent on inspectingover a third of the impacts propagated to remote processes. Togeth-er with the impact size ratios, the sizes of D
ISTIA impact sets (left
four columns) indirectly give the baseline impact-set sizes, imply-
ing the signiﬁcance of the large impact-set reductions by our tech-
nique. The bottom row shows the mean for all individual queriesacross the six subjects rather than the average of the means above.
The effectiveness of the enhanced version of D
ISTIA is high-
lighted against the basic version in Figure 5, where the height of
each bar indicates the mean (holistic-) impact-set size ratio to thesame baseline MCov with the associated variation indicated by the
cap above the bar. The means of the basic version correspond tothe seventh column of Table 3. For a fair comparison, both ver-
sions took exactly the same traces to compute the impact sets of
same queries, with the basic version simply ignoring the message-receiving maps in the traces during the impact-computation phase.
The results reveal that the pruning based on message-passing se-
mantics further reduced the baseline impact sets considerably be-
yond the basic version, by around 5% to over 50% on average forindividual subjects/inputs and 13.2% overall (the rightmost bars).The improvements also tend to be more signiﬁcant on larger sub-jects than on smaller ones. For each query, both versions constantly
produced the same local impact sets, which is expected as the en-
hancement prunes remote impacts only. In all, the enhanced D
IS-
TIA reported in its impact sets only 57% of the methods identiﬁed
by the baseline as potentially impacted, implying even greater sav-
ings in developers’ impact-inspection effort than the basic version.
5.3.2 RQ2: Impact-Set Composition
Figure 6 plots the impact-set composition for each individual
query numbered on the yaxis, where the xaxis indicates the per-
centage of three complementary sets, local ,remote , and common ,
for each subject and input type. The common sets have been re-
moved from the local and remote subsets, in this ﬁgure only, to help
clarify the composition. A ﬁrst observation is that remote impactsconstantly account for as large portions as local impacts in corre-sponding holistic impact sets. This ﬁnding suggests that impacts
35000.51
local remote allMultiChat (25)
00.51
local remote allNioEcho (27)
00.51
local remote allOpen Chord (663)
00.51
local remote allZooKeeper −integration (838)
00.51
local remote allZooKeeper −system (1150)
00.51
local remote allZooKeeper −load (1129)
00.51
local remote allVoldemort −integration (2395)
00.51
local remote allVoldemort −system (1552)
00.51
local remote allVoldemort −load (3875)
00.51
local remote allFreenet (4887)
Figure 4: Effectiveness of the basic D ISTIA expressed by the ratios ( yaxes, the lower the better) of its per-query impact-set sizes,
including those of the local and remote subsets ( xaxes), to the baseline, per subject and input type (with #queries in parentheses).
71.20%80.20% 79.49%
64.29%78.49%
63.20%70.78%62.26%
24.43%56.87% 56.79%
0%10%20%30%40%50%60%70%80%90%100%110%Basic Enhanced
Figure 5: Effectiveness of the enhanced (with data labels) versus the basic D ISTIA in terms of the means ( yaxes, the lower the better)
and their standard deviations (caps atop the bars) of per-query impact-set size ratios to the baseline, per subject/input and overall.
can propagate almost as extensively to remote processes as within
local ones in (the executions of) distributed programs, conﬁrming
the necessity of analyzing impacts beyond process boundaries.
Another ﬁnding is that, for almost all queries, there were same
methods potentially impacted in both local and remote processes.This implies that, in distributed systems, components often share
common functionalities. The sizes of common impact sets could be
a metric of coupling and code reuse among distributed components.In the majority of these ten cases, there were as many potentiallyimpacted methods shared by both local and remote processes asthose only appeared in either, suggesting that the component-level
code reuse is not only widely existent but also quite signiﬁcant.
The rightmost two plots show the composition with the enhanced
version in contrast to the results with the basic version (left to thevertical line) for the two best cases (ZooKeeper-load and V oldemort-
load) to highlight the effectiveness improvement. These two cases
are consistent with the two best seen in Figure 5. The enhanced re-
sults for other eight cases are omitted due to space limit, and basic
results are shown for all cases to partly explain/justify the enhance-ment gained via reducing the sizes of remote impact sets.
5.3.3 RQ3: Efﬁciency
Table 3 (the rightmost six columns) lists all relevant costs of the
basic D ISTIA for this study, including the time cost of (bytecode)
instrumentation, run-time overhead measured as ratios of the exe-
cution time of the original program ( Normal run ) over the instru-
mented one ( Instr . run ), and impact querying time.
The instrumenter took longer for larger subjects as expected, yet
remained within 3 minutes even on the largest system Freenet. Note
that this is a one-time cost (for the single program version analyzed
by D ISTIA) as the instrumented code can be executed on any in-
puts and used for computing any queries afterwards. Run-time andquerying costs are consistently correlated to subject sizes as well
as the type of inputs and the size of execution traces (last column),
with the worst case seen by ZooKeeper and V oldemort, respective-ly. Nevertheless, the run-time overhead is at worst 21% and the
longest querying time is less than one second.
Storage costs are also tightly connected to the type of inputs in
addition to subject sizes, of which the largest is less than 1MB for
the load test of V oldemort. In other cases, this cost is at most 0.5M-B, with an overall average of less than 0.3MB.
In all, the results suggest that the basic D
ISTIA is highly efﬁ-
cient in both time and space dimensions, and that it appears to be
readily scalable to large systems: It costs on average one minute forinstrumentation and 56ms for computing the impact set per query,with mean run-time overhead of about 7%.
Tracing the ﬁrst message-receiving events and utilizing them in
addition, the enhanced version is expected to incur higher time and
space costs. Y et, our results (not shown here) reveal that the in-creases are quite marginal and thus negligible: on overall average,the run-time and space overhead is less than 1% higher, and the
querying time is 9.8ms longer. Since both versions share the same
instrumenter, the instrumentation cost remains the same. Thus, inall, the enhanced version tends to be much more cost-effective.
5.4 Case Studies
To further investigate the effectiveness and practical utility of
DISTIA, we conducted two exploratory case studies. For space
reasons, we leave the details to a technical report on D ISTIA [15].
In the ﬁrst study, we randomly picked two queries of MultiChat
and three of V oldemort with an input for each query also random-
ly chosen from the tests used above. We then manually determinethe ground-truth impact sets of these queries to gauge the accura-cy of D
ISTIA results. Overall, D ISTIA had an average precision
of 56.9% with the basic version and of 71.2% with the enhanced
version, and both versions always had 100% recall for any query.
In the second study, we used the D ISTIA impact sets to help un-
derstand the inter-component interaction in NioEcho and ZooKeep-er: none of the authors had knowledge about internal workings of
these programs. We picked two queries from the client and three
3510 50 100510152025MultiChat
0 50 100510152025NioEcho
0 50 100200400600Open Chord
0 50 100200400600800ZooKeeper −integration
0 50 1002004006008001000ZooKeeper −system
0 50 1002004006008001000ZooKeeper −load
0 50 10050010001500Voldemort −integration
0 50 10050010001500Voldemort −system
0 50 1005001000150020002500Voldemort −load
0 50 1001000200030004000Freenet
local impact set remote impact set common impact set0 50 1002004006008001000ZooKeeper −load
0 50 1005001000150020002500Voldemort −load
Figure 6: Left to |: composition of impact sets given by the basic D ISTIA for all queries ( yaxes) expressed as the percentages ( xaxes)
of local, remote, and common impact sets in the whole impact set per query, for each subject and input type (atop each plot as thetitle). Right to |: composition of impact sets given by the enhanced D
ISTIA for two subjects/inputs with the best effectiveness gains.
Table 3: Mean effectiveness, time-cost breakdown, and storage costs of the basic D ISTIA
Subject & inputMean impact-set sizes Mean impact size ratios Time costs in millisecond (ms) Storage
costs
in KB Local Remote All Local Remote AllInstrumentation Normal
runInstr.
runRun-time
overheadQuerying
(stdev)
MultiChat 14.0 4.5 18.5 71.70% 85.03% 74.08% 12,817 5,461 5,735 5.02% 4 (2) 7
NioEcho 11.4 11.3 21.7 84.21% 83.60% 83.47% 13,365 3,213 3,619 12.64% 4 (2) 5
Open Chord 248.0 245.9 276.0 77.75% 77.09% 80.46% 14,533 4,856 4,931 1.54% 8 (5) 73
ZooKeeper-integration 284.1 265.5 492.1 66.90% 67.72% 67.04%
39,12437,239 38,396 3.11% 11 (2) 94
ZooKeeper-system 672.3 672.8 948.3 81.91% 74.89% 82.25% 15,385 18,565 20.67% 24 (6) 132
ZooKeeper-load 577.1 560.7 837.8 73.12% 62.86% 76.80% 94,187 98,891 4.99% 22 (5) 142
V oldemort-integration 654.6 578.1 1052.7 74.85% 65.87% 74.98%
132,53617,755 18,662 5.11% 22 (7) 315
V oldemort-system 522.1 478.6 842.9 67.41% 62.54% 67.97% 11,136 12,232 9.84% 19 (4) 197
V oldemort-load 286.9 709.9 967.6 49.37% 55.93% 75.06% 21,066 21,198 0.63% 29 (5) 782
Freenet 2787.8 2780.0 2956.6 57.56% 57.42% 60.64% 165,174 54,794 61,876 12.92% 114 (17) 527
Overall average 820.4 850.6 1037.8 63.74% 62.01% 69.99% 62,924.8 26,509.2 28,410.5 7.17% 56.2 (45.1) 227.4
from the server of NioEcho that looked relevant to messaging. The
remote impact sets clearly revealed how the client initiates a re-
quest handled by the server which later sent a response back to the
client. The case of ZooKeeper was much more complicated, yetexamining both the local and remote impacts of one fundamentaloperation getData [28] actually enabled us to identify the major
data transaction protocol between two nodes. In both cases, the
event ordering was essential for the interaction understanding. The
common impact sets, which reveal functionalities shared by com-ponents, also helped with the system structure comprehension.
5.5 Threats to Validity
The main threat to internal validity lies in possible implementa-
tion errors in D ISTIA and experiment scripts. To reduce this threat,
we did a careful code review for our tool and used the two smallestsubjects to manually validate their functionalities and analysis re-
sults. An additional such threat concerns possible missing (remote)
impacts due to network I/Os that were not monitored at runtime.However, we checked the code of all subjects and conﬁrmed thatthey only used the most common message-passing APIs monitored
by our tool when executing the program inputs we utilized. In gen-
eral, for arbitrary distributed systems, the soundness of D
ISTIA
relies on the identiﬁcation of all such API calls used in the system.
The main threat to external validity is that our study results may
not generalize to all other distributed programs and input sets. In
this study, we considered only limited number of subjects, which
may not represent all real-world distributed systems, and only sub-sets of inputs, which do not necessarily represent all behaviours ofthe studied systems. To reduce this threat, we have chosen subject
programs of various sizes and application domains, including the
four industry-scale systems in different areas. In addition, we con-sidered different types of inputs, including integration, system, and
load tests. Most of these tests came as part of the subjects except
for the integration tests, which we created according to the ofﬁcial
online documentation (quick-start guide) of these programs.
The main threat to construct validity is the metrics used for the
evaluation. Without directly comparable peer techniques in theliterature, we assumed that developers would use coverage-based
approach like MCov , as a representative alternative to D
ISTIA, to
narrow down the search space of potential impacts in the contex-t of distributed executions. To mitigate this threat, we examinedthe composition of each impact set and analyzed the effectiveness
with respect to its local and remote subsets in addition to that of the
holistic impact set to help demonstrate the usefulness of D
ISTIA.
Finally, a conclusion threat concerns the data points analyzed:
We applied the statistical analyses only to methods for which im-pact sets could be queried (i.e., methods executed at least once).
Also, the present study only considered potential changes in single
methods for each query, while in practice developers may plan forchanges in multiple methods at a time, which may lead to differ-ent results. To minimize this threat, we adopted the strategy for all
experiments and calculated the metrics for every possible query.
6. RELATED WORK
Dynamic Impact Analysis. The EAS approach [4] which par-
tially inspired D ISTIA is a performance optimization of its prede-
cessor P AT H IMP ACT [39]. Many other dynamic impact analysis
techniques also exist [40], aiming at improving precision [11], re-call [42], efﬁciency [10], and cost-effectiveness [13,14] over P
AT H IM-
PAC T and EAS. However, these techniques did not address dis-
tributed or multiprocess programs that we focus on in this work.
352Two recent advances in dynamic impact analysis, D IVER [11]
and the uniﬁed framework in [14], utilize hybrid program analysis
to achieve higher precision and more ﬂexible cost-effectiveness op-
tions over EAS-based approaches, but still target centralized pro-grams only. As a ﬁrst step, D
ISTIA sacriﬁces precision for high
efﬁciency. However, it would be interesting to adopt hybrid ap-proaches for distributed systems too. For instance, one may imme-
diately gain better analysis precision by ﬁrst using static dependen-
cies to prune false-positive impacts within each process, as D
IVER
did, and then propagating impacts across process boundaries by
means of the analysis algorithms used in D ISTIA. More aggressive
pruning may further be obtained by leveraging more and/or ﬁner-
grained interprocess dependencies, such as communication depen-dencies and synchronization dependencies [31, 44], as already ex-ploited by distributed-program slicing techniques [7].
Dependence Analysis of Parallel and Distributed Programs.
Using ﬁne-grained dependency analysis, a large body of work at-
tempted to extend traditional slicing algorithms to concurrent pro-grams [25, 35, 47, 65, 66] yet mostly focusing on centralized, andprimarily multithreaded, ones. For those programs, traditional de-
pendence analysis was extended to handle additional dependenciesdue to shared variable accesses, synchronization, and communica-
tion between threads and/or processes (e.g., [35, 47]). While D
IS-
TIA also handles multithreaded programs, it targets multiprocess
ones running on distributed machines, and aims at lightweight pre-
dictive impact analysis instead of ﬁne-grained slicing.
For systems running in multiple processes where interprocess
communication is realized via socket-based message passing, anapproximation for static slicing was discussed in [35]. V arious dy-
namic slicing algorithms have been proposed too, earlier for pro-
cedural programs only [16, 18, 27, 31, 34] and recently for object-oriented software also [7, 44, 52]. And a more complete and de-tailed summary of slicing techniques for distributed programs canbe found in [66] and [7]. Although these slicing algorithms were
rarely evaluated against large real-world distributed systems, it can
be anticipated that they would face scalability issues with large sys-tems based on the limited empirical results they reported and theheavyweight nature of their technical design.
In contrast to these ﬁne-grained (statement-level) analysis, D
IS-
TIA aims at a highly efﬁcient method-level dynamic impact analy-
sis that can readily scale to large distributed systems. A few morestatic analysis algorithms for distributed systems exist as well butfocus on other (special) types of systems, such as RMI-based Java
programs [59], different from the common type of distributed sys-
tems [17] D
ISTIA addresses. At coarser levels, other researchers
resolve dependencies in distributed systems too but for differentpurposes such as enhancing parallelization [54], system conﬁgura-
tion [32], and high-level system modeling [1, 8], or limited to stat-
ic analysis [24, 46, 53]. In contrast, D
ISTIA performs code-based
analysis while providing more focused impacts relative to concreteprogram executions than static-analysis approaches.
An impact analysis dedicated to distributed systems, Helios [53]
can predict impacts of potential changes to support evolution tasks
for DEBS. However, it relies on particular message-type ﬁlteringand manual annotations in addition to a few other constraints. Al-though these limitations are largely lifted by its successor Eos [24],
both approaches are static and limited to DEBS only, as is the lat-
est technique [64] which identiﬁes impacts based on change-typeclassiﬁcation yet ignores intra-component dependencies hence pro-vides merely incomplete results. While sharing similar goals, D
IS-
TIA targets a broader range of distributed systems than DEBS us-
ing dynamic analysis and without relying on special source-code
information (e.g., interface patterns) as those techniques do.Unlike our dependence-based approach, a traceability-based so-
lution [9] is presented in [60] which relies on a well-curated repos-itory of various software models. The dynamic impact analysis forcomponent-based software in [20] works at architecture level, dif-
ferent from ours working for distributed programs at code level.
Logging for Distributed Systems. Targeting high-level under-
standing of distributed systems, techniques like logging and miningrun-time logs [8, 41] infer inter-component interactions using tex-
tual analysis of system logs, relying on the availability of particular
data such as informative logs and/or patterns in them. D
ISTIA also
utilizes similar information (i.e., the Lamport timestamps) but in-fers the happens-before relation between method-execution eventsmainly for code-level impact analysis. Also, D
ISTIA automatically
generates such information it requires rather than relying on exist-
ing information in the original programs (e.g., logging statements).
The Lamport timestamp used is related to vector clocks [21, 43]
used by other tools, such as ShiV ector [1] for ordering distributed
logs and Poet [36] for visualizing distributed systems executions.While we could utilize vector clocks also, we chose the Lamport
timestamp as it is lighter-weight yet sufﬁces for our current designof D
ISTIA. In addition, unlike ShiV ector, which requires access-
es to source code and recompilation using the AspectJ compiler,
DISTIA does not have such constraints as it works on bytecode.
Tracing message-passing systems was explored before but for
different purposes, such as overcoming non-determinacy/race de-tection [48] and reproducing buggy executions [33]. Tools like
RoadRunner [22] and ThreadSanitizer [58] targeted multithread-
ed, centralized programs. None of these solutions work for large,diverse distributed systems without perturbations as D
ISTIA did.
Dynamic Partial Order Reduction (DPOR). DPOR has been
used to improve the performance of model checking concurren-
t software by avoiding the examination of independent transitions
[23]. Sharing the spirit of DPOR, especially distributed DPOR [67],
DISTIA synchronizes only the ﬁrst and last method-execution events
for more efﬁcient computation of partial ordering of methods with-
inprocesses, and exploits message-passing semantics to avoid partial-
ordering independent methods across processes.
However, unlike existing DPOR techniques which target multi-
threaded programs, D ISTIA focuses on multi-process, distributed
programs. On the other hand, DPOR may be adopted for dynam-
ic impact analysis of distributed programs with a few extensions
and/or accommodations. First, the execution conditions of meth-ods can be modeled as method-level states (versus statement-levelstates in the original DPOR). Also, to represent state transitions
across processes, the identiﬁes of parent processes need to be in-
corporated in thread identiﬁers. Finally, partial ordering algorithmslike L TS may be employed to determine transition dependence atprocess level.
7. CONCLUSION
We presented D ISTIA, the ﬁrst dynamic impact analysis for com-
mon distributed programs. By partially ordering method-execution
events and exploiting message-passing semantics, D ISTIA can safe-
ly predict for any query the potential impacts both within and acrossall processes. Through an evaluation on large real-world distribut-
ed programs, we have shown the high efﬁciency of D
ISTIA and its
superior effectiveness over existing options, and initially demon-strated its beneﬁts for distributed system understanding.
8. ACKNOWLEDGMENT
This work was partially supported by ONR Grant N000141410037
to the University of Notre Dame and the faculty start-up funds giv-en by Washington State University to the ﬁrst author.
3539. REFERENCES
[1] J. Abrahamson, I. Beschastnikh, Y . Brun, and M. D. Ernst.
Shedding light on distributed system executions. In
Companion Proceedings of the 36th InternationalConference on Software Engineering , pages 598–599, 2014.
[2] Apache. V oldemort. https://github.com/voldemort, 2015.[3] Apache. ZooKeeper. https://zookeeper.apache.org/, 2015.[4] T. Apiwattanapong, A. Orso, and M. J. Harrold. Efﬁcient and
precise dynamic impact analysis using execute-aftersequences. In Proceedings of IEEE/ACM International
Conference on Software Engineering , pages 432–441, 2005.
[5] C. Artho, M. Hagiya, R. Potter, Y . Tanabe, F. Weitl, and
M. Y amamoto. Software model checking for distributedsystems with selector-based, non-blocking communication.InProceedings of IEEE/ACM International Conference on
Automated Software Engineering , pages 169–179, 2013.
[6] Bamberg University. Open Chord.
http://sourceforge.net/projects/open-chord/, 2015.
[7] S. S. Barpanda and D. P . Mohapatra. Dynamic slicing of
distributed object-oriented programs. IET software ,
5(5):425–433, 2011.
[8] I. Beschastnikh, Y . Brun, M. D. Ernst, and
A. Krishnamurthy. Inferring models of concurrent systemsfrom logs of their behavior with CSight. In Proceedings of
IEEE/ACM International Conference on Software
Engineering , pages 468–479, 2014.
[9] S. A. Bohner and R. S. Arnold. An introduction to software
change impact analysis . Software Change Impact Analysis,
IEEE Comp. Soc. Press, pp. 1–26, June 1996.
[10] B. Breech, M. Tegtmeyer, and L. Pollock. A comparison of
online and dynamic impact analysis algorithms. In
Proceedings of European Conference on Software
Maintainance and Reengineering , pages 143–152, 2005.
[11] H. Cai and R. Santelices. Diver: Precise dynamic impact
analysis using dependence-based trace pruning. InProceedings of International Conference on Automated
Software Engineering , pages 343–348, 2014.
[12] H. Cai and R. Santelices. A comprehensive study of the
predictive accuracy of dynamic change-impact analysis.Journal of Systems and Software , 103:248–265, 2015.
[13] H. Cai and R. Santelices. A framework for cost-effective
dependence-based dynamic impact analysis. In International
Conference on Software Analysis, Evolution, and
Reengineering , pages 231–240, 2015.
[14] H. Cai, R. Santelices, and D. Thain. Diapro: Unifying
dynamic impact analyses for improved and variablecost-effectiveness. ACM Transactions on Software
Engineering and Methodology , 25(2):18, 2016.
[15] H. Cai and D. Thain. Distea: Efﬁcient dynamic impact
analysis for distributed systems. arXiv preprint
arXiv:1604.04638 , 2016.
[16] J. Cheng. Dependence analysis of parallel and distributed
programs and its applications. In Proceedings of Advances in
Parallel and Distributed Computing , pages 370–377, 1997.
[17] G. Coulouris, J. Dollimore, T. Kindberg, and G. Blair.
Distributed Systems: Concepts and Design . Addison-Wesley
Publishing Company, 5th edition, 2011.
[18] E. Duesterwald, R. Gupta, and M. Soffa. Distributed slicing
and partial re-execution for distributed programs. In
Languages and Compilers for Parallel Computing , pages
497–511. Springer, 1993.[19] P . Eugster and K. Jayaram. EventJava: An extension of Java
for event correlation. In Proceedings of European
Conference on Object-Oriented Programming , pages
570–594. Springer, 2009.
[20] T. Feng and J. I. Maletic. Applying dynamic change impact
analysis in component-based architecture design. In ACIS
International Conference on Software Engineering, ArtiﬁcialIntelligence, Networking, and Parallel/DistributedComputing , pages 43–48, 2006.
[21] C. J. Fidge. Timestamps in message-passing systems that
preserve the partial ordering. In Proceedings of the 11th
Australian Computer Science Conference , volume 10, pages
56–66, 1988.
[22] C. Flanagan and S. N. Freund. The roadrunner dynamic
analysis framework for concurrent programs. In Proceedings
of the 9th ACM SIGPLAN-SIGSOFT workshop on Program
analysis for software tools and engineering , pages 1–8, 2010.
[23] C. Flanagan and P . Godefroid. Dynamic partial-order
reduction for model checking software. In Proceedings of the
32Nd ACM SIGPLAN-SIGACT Symposium on Principles of
Programming Languages , pages 110–121, 2005.
[24] J. Garcia, D. Popescu, G. Saﬁ, W . G. Halfond, and
N. Medvidovic. Identifying message ﬂow in distributed
event-based systems. In Proceedings of ACM International
Symposium on the F oundations of Software Engineering ,
pages 367–377, 2013.
[25] D. Giffhorn and C. Hammer. Precise slicing of concurrent
programs. Automated Software Engineering , 16(2):197–234,
2009.
[26] GoogleCode. MultiChat.
https://code.google.com/p/multithread-chat-server/, 2015.
[27] D. Goswami and R. Mall. Dynamic slicing of concurrent
programs. In IEEE International Conference on High
Performance Computing , pages 15–26. 2000.
[28] P . Hunt, M. Konar, F. P . Junqueira, and B. Reed. Zookeeper:
Wait-free coordination for internet-scale systems. InProceedings of USENIX Annual Technical Conference ,
volume 8, page 9, 2010.
[29] D. Jackson and M. Rinard. Software analysis: A roadmap. In
Proceedings of the Conference on the Future of SoftwareEngineering , pages 133–145, 2000.
[30] K. Jayaram and P . Eugster. Program analysis for event-based
distributed systems. In Proceedings of International
Conference on Distributed Event-Based System , pages
113–124, 2011.
[31] M. Kamkar and P . Krajina. Dynamic slicing of distributed
programs. In Proceedings of IEEE International Conference
on Software Maintenance , pages 222–229, 1995.
[32] F. Kon and R. H. Campbell. Dependence management in
component-based distributed systems. IEEE concurrency ,
8(1):26–36, 2000.
[33] R. Konuru, H. Srinivasan, and J.-D. Choi. Deterministic
replay of distributed java applications. In International
Parallel and Distributed Processing Symposium , pages
219–227, 2000.
[34] B. Korel and R. Ferguson. Dynamic slicing of distributed
programs. Applied Mathematics and Computer Science ,
2(2):199–215, 1992.
[35] J. Krinke. Context-sensitive slicing of concurrent programs.
InProceedings of ACM International Symposium on the
F oundations of Software Engineering , volume 28, pages
178–187, 2003.
354[36] T. Kunz, J. P . Black, D. J. Taylor, and T. Basten. Poet:
Target-system independent visualizations of complex
distributed-application executions. The Computer Journal ,
40(8):499–512, 1997.
[37] P . Lam, E. Bodden, O. Lhoták, and L. Hendren. Soo t-aJ a v a
bytecode optimization framework. In Cetus Users and
Compiler Infrastructure Workshop , 2011.
[38] L. Lamport. Time, clocks, and the ordering of events in a
distributed system. Communications of the ACM ,
21(7):558–565, 1978.
[39] J. Law and G. Rothermel. Whole program path-based
dynamic impact analysis. In Proceedings of IEEE/ACM
International Conference on Software Engineering , pages
308–318, 2003.
[40] B. Li, X. Sun, H. Leung, and S. Zhang. A survey of
code-based change impact analysis techniques. Software
Testing, V eriﬁcation and Reliability , 23:613–646, 2013.
[41] J.-G. Lou, Q. Fu, Y . Wang, and J. Li. Mining dependency in
distributed systems through unstructured logs analysis. ACM
SIGOPS Operating Systems Review , 44(1):91–96, 2010.
[42] M. C. O. Maia, R. A. Bittencourt, J. C. A. de Figueiredo, and
D. D. S. Guerrero. The hybrid technique for object-orientedsoftware change impact analysis. In Proceedings of
European Conference on Software Maintainance and
Reengineering , pages 252–255, 2010.
[43] F. Mattern. Virtual time and global states of distributed
systems. Parallel and Distributed Algorithms ,
1(23):215–226, 1989.
[44] D. P . Mohapatra, R. Kumar, R. Mall, D. Kumar, and
M. Bhasin. Distributed dynamic slicing of Java programs.
Journal of Systems and Software , 79(12):1661–1678, 2006.
[45] G. Mühl, L. Fiege, and P . Pietzuch. Distributed event-based
systems , volume 1. Springer, 2006.
[46] G. C. Murphy and D. Notkin. Lightweight lexical source
model extraction. ACM Transactions on Software
Engineering and Methodology , 5(3):262–292, 1996.
[47] M. G. Nanda and S. Ramesh. Interprocedural slicing of
multithreaded programs with applications to Java. ACM
Transactions on Programming Languages and Systems ,
28(6):1088–1144, 2006.
[48] R. H. Netzer and B. P . Miller. Optimal tracing and replay for
debugging message-passing parallel programs. The Journal
of Supercomputing , 8(4):371–388, 1995.
[49] Oracle. Java NIO. http://docs.oracle.com/javase/7/docs/api/
java/nio/package-summary.html, 2015.
[50] Oracle. Java Socket I/O. http:
//docs.oracle.com/javase/7/docs/api/java/net/Socket.html,
2015.
[51] A. Orso, T. Apiwattanapong, and M. J. Harrold. Leveraging
ﬁeld data for impact analysis and regression testing. InProceedings of ACM International Symposium on the
F oundations of Software Engineering , pages 128–137, 2003.
[52] S. Pani, S. M. Satapathy, and G. Mund. Slicing of programs
dynamically under distributed environment. In Proceedingsof International Conference on Advances in Computing ,
pages 601–609. Springer, 2012.
[53] D. Popescu, J. Garcia, K. Bierhoff, and N. Medvidovic.
Impact analysis for distributed event-based systems. InProceedings of International Conference on DistributedEvent-Based Systems , pages 241–251, 2012.
[54] K. Psarris and K. Kyriakopoulos. An experimental evaluation
of data dependence analysis techniques. IEEE Transactions
on Parallel and Distributed Systems , 15(3):196–213, 2004.
[55] V . Rajlich. Changing the paradigm of software engineering.
Communications of the ACM , 49(8):67–70, 2006.
[56] V . Rajlich. Software evolution and maintenance. In
Proceedings of the Conference on the Future of Software
Engineering , pages 133–144, 2014.
[57] P . R oveg ard, L. Angelis, and C. Wohlin. An empirical study
on views of importance of change impact analysis issues.
IEEE Transactions on Software Engineering , 34(4):516–530,
2008.
[58] K. Serebryany and T. Iskhodzhanov. Threadsanitizer: data
race detection in practice. In Proceedings of the Workshop on
Binary Instrumentation and Applications , pages 62–71,
2009.
[59] M. Sharp and A. Rountev. Static analysis of object references
in RMI-based Java software. IEEE Transactions on Software
Engineering , 32(9):664–681, 2006.
[60] H. M. Sneed. Impact analysis of maintenance tasks for a
distributed object-oriented system. In Proceedings of the
IEEE International Conference on Software Maintenance ,
page 180, 2001.
[61] SourceForge. NioEcho. http:
//rox-xmlrpc.sourceforge.net/niotut/index.html#Thecode,
2015.
[62] Y . Tao, Y . Dang, T. Xie, D. Zhang, and S. Kim. How do
software engineers understand code changes?: anexploratory study in industry. In Proceedings of ACM
International Symposium on the F oundations of Software
Engineering , pages 51:1–51:11, 2012.
[63] The Freenet team. The Free Network.
https://freenetproject.org/, 2015.
[64] S. Tragatschnig, H. Tran, and U. Zdun. Impact analysis for
event-based systems using change patterns. In Proceedings
of ACM Symposium on Applied Computing , pages 763–768,
2014.
[65] J. Xiao, D. Zhang, H. Chen, and H. Dong. Improved program
dependence graph and algorithm for static slicing concurrent
programs. In Advanced Parallel Processing Technologies ,
pages 121–130. Springer, 2005.
[66] B. Xu, J. Qian, X. Zhang, Z. Wu, and L. Chen. A brief
survey of program slicing. ACM SIGSOFT Software
Engineering Notes , 30(2):1–36, 2005.
[67] Y . Y ang, X. Chen, G. Gopalakrishnan, and R. M. Kirby.
Distributed dynamic partial order reduction based
veriﬁcation of threaded software. In Model Checking
Software , pages 58–75. Springer, 2007.
355