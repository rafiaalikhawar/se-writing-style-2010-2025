Lightweight Speciï¬cation and Analysis of
Dynamic Systems with Rich Conï¬gurations
Nuno Macedo
HASLab, INESC TEC and
Universidade do Minho
nfmmacedo@di.uminho.ptJulien Brunel
DTIM, UFTMiP , ONERA
julien.brunel@onera.frDavid Chemouil
DTIM, UFTMiP , ONERA
david.chemouil@onera.fr
Alcino Cunha
HASLab, INESC TEC and
Universidade do Minho
alcino@di.uminho.ptDenis Kuperberg
TU Munich
denis.kuperberg@gmail.com
ABSTRACT
Model-checking is increasingly popular in the early phases
of the software development process. To establish the cor-
rectness of a software design one must usually verify both
structural and behavioral (or temporal) properties. Unfor-
tunately, most specication languages, and accompanying
model-checkers, excel only in analyzing either one or the other
kind. This limits their ability to verify dynamic systems with
rich congurations : systems whose state space is character-
ized by rich structural properties, but whose evolution is also
expected to satisfy certain temporal properties.
To address this problem, we rst propose Electrum, an
extension of the Alloy specication language with temporal
logic operators, where both rich congurations and expressive
temporal properties can easily be dened. Two alternative
model-checking techniques are then proposed, one bounded
and the other unbounded, to verify systems expressed in
this language, namely to verify that every desirable temporal
property holds for every possible conguration.
CCS Concepts
Software and its engineering !Specication lan-
guages; Model checking;
Keywords
Model-checking, formal specication language
Work funded by the European Regional Development Fund
(ERDF) through the Operational Programme for Compet-
itiveness and Internationalisation (COMPETE 2020) and
by National Funds through the Portuguese funding agency,
Funda c~ ao para a Ci^ encia e a Tecnologia (FCT) within project
POCI-01-0145-FEDER-016826. Research partly funded by
DGA/ANR project C x(ref. ANR-13-ASTR-0006) and fon-
dation STAE (IFSE, BRIefcaSE).1. INTRODUCTION
Software specication and verication is crucial at early
development phases, since it allows the developer to reason
about the system and its properties, and timely detect design
errors. Although a variety of frameworks has been proposed
to aid the developer in this task, the most successful ones
arelightweight , in the sense that they provide a simple yet
expressive and exible formal language { allowing the user
to specify dierent classes of systems and properties at dif-
ferent abstraction levels { and are accompanied by tools that
automate their analysis { providing quick feedback regarding
the correctness of the specication. In fact, such frameworks
have already reached a level of maturity that enables their
application in complex real world scenarios [ 2626].
Two classes of properties are particularly important to con-
sider: structural (orstatic ) properties, typically expressed
in some variant of rst-order logic, that address the well-
formedness of the system state, and behavioral (ordynamic )
properties, typically expressed in a temporal logic, that ad-
dress the evolution of the system state. Although not neces-
sarily in equal measure, most interesting systems will require
the specication and analysis of properties from both classes.
The analysis of distributed computing algorithms is a paradig-
matic class, whose behavioral properties are expected to be
checked for arbitrary network topologies, within a range
specied by particular structural properties. We denote such
components of the system state, that are initially arbitrary,
but remain unchanged as the system evolves, as congura-
tions . Another relevant class is that of software product
lines (SPLs), where each valid software product of a family,
specied by simple structural properties, amounts to a dif-
ferent conguration, each of which should be checked for the
behavioral properties.
Dynamic systems with rich congurations are the focus of
this work, and concretely, this class of systems exhibits the
following requirements:
R1 A clear distinction between the specication of the
system conguration and the system evolution;
R2 Congurations constrained by rich structural properties
(like inheritance, complex relationships between entities,
or reachability properties);
R3 A declarative specication of the system evolution (the
possible actions aecting the state), possibly underdierent idioms;
R4 The need to verify (temporal) safety and liveness prop-
erties about the specied system.
Thus, to be suitable to address this kind of problems, a
specication language should be suciently rich and exible
to support the denition of both structural and behavioral
properties, while still promoting the separation of concerns.
Moreover, it should be accompanied by eective tool sup-
port, to allow the automatic model-checking of the desired
temporal properties for every valid conguration.
1.1 Motivating Examples
To further clarify the class of problems we intend to address,
this section presents two motivating examples where all the
above characteristics are manifest.
Hotel room locking system.
This example regards the specication of a hotel room
locking system that uses disposable electronic keys [ 1818], that
relies on recodable locks that either unlock the door for the
currently coded key, or for its successor, at which point the
lock is recoded, rendering the previous key obsolete. The
front desk issues new keys for the appropriate room when
guests check-in. The front desk and the locking systems are
stand-alone (no communication between them): the system
works properly because keys are generated using the same
pseudo-random generator, with the initial seed of each room
lock being synchronized with the front desk a priori .
To abstract away the details, keys are interpreted as a
totally ordered set ( e.g., a set of natural numbers), and each
room is assigned a (disjoint) subset of such keys a priori :
given the currently coded key, the next valid one is the small-
est among its successors in this subset. The available rooms,
keys, and possible guests, together with a valid assignment of
keys to the rooms, constitutes a conguration of this system.
These remain constant as the system evolves, contrasting
with the dynamic components of the system ( e.g., the keys
currently coded in each lock) ( R1R1). Moreover, a valid cong-
uration is not arbitrary, but characterized by a precise set of
constraints ( R2R2). The dynamic components evolve as guests
check in and out, or enter a room with a fresh key, updating
the currently coded key of that room lock. These actions
can easily be specied in a declarative manner, for example
relying on pre- and post-conditions ( R3R3).
A safety property that is expected to hold ( R4R4) is that
guests cannot enter rooms in which they are not currently
registered. This property does not hold in some congura-
tions, as depicted in Fig. 11. Each state depicts the rooms
(square elements), guests (rounded corners) and the front
desk (the lower faceted rectangle). Bold typeface values are
part of the system conguration; the others change as the
system evolves, with the values that are modied at each
step underlined. Although this particular conguration leads
to a counter-example, the problem may go unnoticed if one
is required to perform the analysis for a specic (user-picked)
conguration ( e.g., whereR1 was assigned K1 andK2 and
R2 the remaining keys).
Distributed spanning tree algorithm.
This example concerns a simple distributed spanning tree
algorithm, that runs on an arbitrary (but connected) network
topology, building on the one proposed in [ 2828]. Here, adistinguished root node (possibly elected beforehand) starts
by assigning itself level 0. Nodes with assigned levels ( i.e.,
already in the spanning tree) broadcast their level to the
neighbors. When a node not yet in the spanning tree receives
one such message, it sets its level to one plus the level of
the sender, and records it as its parent node. The details of
message passing are abstracted away by allowing the system
to evolve by selecting an arbitrary node to act, among those
not in the spanning tree but with neighbors already so, and
arbitrarily choosing one of the latter as parent.
Here, a conguration consists of a set of nodes, a root node
among them, and a possible network topology, which may
take the shape of an arbitrary undirected connected graph,
while the dynamic aspects encompass the level and parent
structures of the tree being computed ( R1R1). The specication
of a valid topology requires a reachability constraint ( R2R2).
In general, the same topology may lead to several dierent
spanning trees, and this non-determinism can be captured
by declarative operations, where the selection of the process
to act, as well as its parent, is arbitrary within the stated
constraints ( R3R3). Both a safety and a liveness properties
are expected to hold for every network topology, i.e., system
conguration ( R4R4): the algorithm never introduces a cycle
in the parent structure, and a spanning tree of the whole
network is eventually computed, respectively.
Figure 22depicts a possible execution trace of the algorithm
for a specic conguration with four nodes ( P1toP4), root
nodeP2(bold circle), and network topology depicted with
dashed lines. The changing elements of the specication,
namely the level and parent of each node, are represented
in the lower-half of the respective circle and by solid arrows
leaving from them, respectively. Again, the values updated
in each step are underlined.
Elevator system SPL.
This example models an elevator system SPL inspired by
the one proposed in [ 2727] and extended in [ 77]. The model
consists of an elevator and a set of oors; at each oor there
is a button that calls the elevator, and inside it there is a but-
ton for each of the oors. The base system answers button
calls giving priority to the current direction: it only changes
direction when there are no more calls for the succeeding
oors. This behavior is however modied as additional fea-
tures are selected. For instance, a parking feature moves the
elevator to the rst oor when there are no button calls; an
idle feature forces the elevator to open the door when there
are no button calls; an executive oor feature prioritizes calls
to one of the oors over the others. Multiple interfering
features, under some restrictions, may be selected.
Here each conguration represents a valid product from
the SPL, that is, a selection of features, while the dynamic
component models the evolution of the system taking into
consideration those features ( R1R1). The selection of these
features is restricted by a feature diagram that denes simple
dependencies/conicts between the features, which can be
encoded as structural properties ( R2R2). For instance, since
the idle and the parking features have conicting behavior
their choice could be forced to be exclusive. The operations
must be suciently expressive to encode the behavior of the
system taking into consideration the selected features ( R3R3).
There are several safety and liveness properties that should
be checked about this specication ( R4R4). For instance, the
most basic liveness property states that a pressed buttonCheckin(G1,R1,K2)Checkout(G1)Checkin(G2,R1,K3)Entry(G1,R1,K2)R1{K1,K2,K3}K1R2{K4}K4G1{}G2{}R1 â†¦ âˆ…R2 â†¦ âˆ…R1 â†¦ K1R2 â†¦ K4R1 â†¦ G1R2 â†¦ âˆ…R1 â†¦ K2R2 â†¦ K4R1{K1,K2,K3}K1R2{K4}K4G1{K2}G2{}R1 â†¦ âˆ…R2 â†¦ âˆ…R1 â†¦ K2R2 â†¦ K4R1{K1,K2,K3}K1R2{K4}K4G1{K2}G2{}R1 â†¦ G2R2 â†¦ âˆ…R1 â†¦ K3R2 â†¦ K4R1{K1,K2,K3}K1R2{K4}K4G1{K2}G2{K3}R1{K1,K2,K3}K2R2{K4}K4R1 â†¦ G2R2 â†¦ âˆ…R1 â†¦ K3R2 â†¦ K4G2{K3}G1{K2}Figure 1: Execution trace for the hotel room locking system leading to a counter-example.
P2âˆ…P3âˆ…P1âˆ…P4âˆ…Act(P2)Act(P1)Act(P4)Act(P3)P20P3âˆ…P1âˆ…P4âˆ…P20P3âˆ…P11P4âˆ…P20P3âˆ…P11P42P20P32P11P42
Figure 2: Execution trace for the spanning tree algorithm.
will eventually be answered. These must be checked over
every possible feature combination. While some of these
are expected to always hold, some fail under certain feature
congurations. For instance, the above property will fail
with the executive oor feature, as calls to those oors will
be prioritized.
1.2 Contributions
Unfortunately, most formal specication languages (and
accompanying model-checkers) are not designed nor opti-
mized to analyze problems such as these. For example, most
standard model-checkers only perform well with xed cong-
urations, while languages more geared towards the analysis
of structural properties, usually without native support for
some sort of temporal logic, require the user to verify behav-
ioral properties through ad hoc mechanisms.
This paper aims precisely to ll this niche, and proposes a
language and model-checker tailored for the lightweight anal-
ysis of dynamic systems with rich congurations. Concretely,
we propose:
A formal specication language, inspired by Alloy [ 1818]
andTLA+[2020] (two of the most popular specication
languages nowadays), that simplies the specication of
systems exhibiting all the requirements dened above;
Two model-checking techniques, one bounded and the
other unbounded, to verify systems expressed in such
language, namely to verify that every desirable tempo-
ral property holds for every possible conguration.
The remainder of the paper is organized as follows. Sec-
tion22explores related languages and techniques, and justies
why they fall short when analyzing this class of problems.
Section 33presents the proposed language, its semantics, and
the proposed model-checking techniques. Their performance
is then evaluated in Section 44. Finally, Section 55draws
conclusions and points directions for future work.2. RELATED WORK
There are numerous approaches to the specication and
model-checking of systems. Here we focus on those whose
level of expressiveness and tool support come close to that
needed to handle systems with rich congurations, i.e., that
address some of the four requirements dened in Section 11.
Alloy [ 1818,1717,1919,55] is a lightweight formal specication
language with an object-oriented avor, which, paired with
its Analyzer, that provides support for automatic bounded
verication, has been increasingly adopted by software en-
gineering practitioners. The underlying formalism of Alloy
isrelational logic , rst-order logic enhanced with transitive
closure operations, that render the denition of structural
properties extremely simple. Thus, Alloy is naturally well-
suited to handle the R2R2requirement.
However, Alloy is inherently static, thus the verication
of behavioral properties usually relies on well-known idioms
that have emerged due to the language exibility. Such ad
hocspecication is error-prone and verbose, and forces devel-
opers to be concerned with particularities of the idiom rather
than with the properties that they actually wish to verify
(see for instance [ 3131,2222]), and as a consequence regular Alloy
is not well-suited to address R4R4. To overcome this limitation,
considerable research has been dedicated to enhance Alloy
with dynamic behavior [ 1212,55,2424,3030,88]. The main drawback
of these approaches is that they compromise the exibility
that the Alloy users are accustomed to, introducing syntactic
extensions that force them to adhere to specic idioms, and
consequently breaking the R3R3requirement. That is the case,
for instance, of DynAlloy [ 1212], an Alloy variant that resorts
to dynamic logic to specify behavior. Liveness properties,
which comprise a large class of behavioral properties, are
also not expressible in DynAlloy [ 1313], and thus R4R4is not
eectively addressed. Although expressible in regular Alloy
(via said idioms), verifying such properties with the Ana-
lyzer requires some insightfulness and care from the user, to
avoid the spurious counter-examples that usually occur with
naive encodings of bounded model-checking techniques [ 3030,88]. The technique from [ 2424] enhances Alloy with imperative
constructs, again undermining R3R3. In contrast, the tech-
nique proposed in [ 55] extends the relational logic of Alloy
with CTL temporal logic. Unfortunately, the system actions
must be specied with a xed idiom with an imperative-
avor, and thus falls short on the R3R3requirement. Moreover,
it disregards the rich structural properties introduced by the
signature type system from regular Alloy, undermining its
ability to address R2R2. Finally, even though all these works at-
tempt to enhance Alloy with dynamic properties, besides [ 2424]
that distinguishes between static and variable elds, none
properly address R1R1, since they do not distinguish between
the system conguration and the dynamic components that
evolve over time.
In contrast, temporal model-checkers are developed pre-
cisely to address the R4R4requirement. Among the most suc-
cessful formalisms is the temporal logic of actions (TLA) [ 2020],
a variant of temporal logic that introduces the notion of
action to model the evolution of the system. Actions are
essentially predicates that relate two consecutive states, spec-
ifying the acceptable steps that allow the system to evolve.
Thus, the TLA+specication language, built over this logic,
naturally handles R3R3, and has proven to be well suited to
specify systems with rich temporal properties. Moreover,
TLA+is accompanied by a set of eective tools, including
TLC, a model-checker that has proven eective on the ver-
ication of complex TLA+systems. However, in order to
be manageable by TLC, some additional restrictions are
imposed over the TLA+language, namely over the action
predicates, reducing its compliance with the R3R3requirement.
Unlike most model-checkers, TLA+does support the speci-
cation of rst-order logic properties, addressing R2R2to some
extent. However, unlike Alloy [ 1111], it lacks a type system
with inheritance, that greatly simplies the specication of
complex entities and their relationships. Moreover, due to
the nature of the model-checking procedure, rich structural
properties may severely hinder the performance of TLC since
the rst step of the procedure involves calculating every
possible initial state. While TLA+does provide a simple
mechanism to separate the system conguration from its
evolution (by allowing the distinction between variable and
constant parameters), TLC requires constant parameters
to be xed a priori by the user, limiting its ability to au-
tomatically explore all possible congurations and thus to
fully address R1R1. To circumvent this problem, congura-
tions must be encoded in regular variable parameters and
then (articially) constrained in the specication to remain
constant throughout the system evolution.
Thus, although both Alloy and TLA+exhibit powerful but
simple languages associated with eective and automated
tools, they excel in the verication of dierent classes of
systems, and none addresses all four requirements identied
above11. The number of available model-checking languages
and tools is too large to allow for an exhaustive comparison
here, but in general they are not better than Alloy or TLA+
at dealing with dynamic systems with rich congurations.
Most, like SPIN or the various SMV variants, do not even
support rst-order logic, making it very cumbersome to
specify complex structural properties. This related work
1An in-depth comparison of TLA+and Alloy, using the hotel
room locking system as running example, can be consulted
in [2121]. The specication of the running examples of this
paper in both those languages can also be found at [ 1515].focuses on Alloy and TLA+because we believe they are
quite close to excel at handling such systems, and, in fact,
the language here proposed combines their best aspects.
An alternative perspective to the problem of model-chec-
king multiple congurations arises from the area of SPLs,
a set of software products that share common base func-
tionalities. The variability between the products is dened
through the selection of features; acceptable feature combi-
nations (i.e., products) are dened through feature diagrams
that impose simple dependencies and conicts between them.
Model-checking an SPL involves checking the properties for
every acceptable product. Under our perspective, each of
these products represents a conguration of the system, re-
stricted by the (rather basic) structural properties entailed
by the feature diagram, that are to be checked for the tem-
poral properties. Several techniques are able to model-check
SPLs. Most, however, are not accompanied by high-level
specication languages that allow both the modeling of the
SPL and the feature diagram. One such language, with sup-
port for model-checking, is fSMV [2727,77], an extension to
SMV. It follows a compositional approach, in the sense that
each feature is implemented through modications to the
base system. FeatureAlloy , an extension to Alloy following
a similar approach, has also been proposed [ 11]. In contrast,
in annotative approaches the SPL is represented by a single
system whose behavior is dened by guards over the selected
features. One such language is fPromela [66], an extension to
the Promela language of SPIN. These approaches suer from
the expressiveness problems of the languages they extend
that have already been exposed previously in this section.
3. THE ELECTRUM FRAMEWORK
Considering the presented state-of-the-art, this work pro-
poses an extension of the Alloy specication language with
temporal logic operators { denoted Electrum { and associated
model-checking tools, that address all four characteristics
identied in Section 11.
3.1 Language
This section describes the proposed Electrum language
and its formal semantics in several steps, starting with an
informal overview in Section 3.1.13.1.1. To ease the presentation
of the semantics, Section 3.1.23.1.2 introduces an abstract syntax
for a representative subset of Electrum, whose semantics is
expressed in terms of a translation to a rst-order temporal
logic. For the sake of readability, this logic is described in
Section 3.1.33.1.3, before the translation itself in Section 3.1.43.1.4.
3.1.1 Overview
This section introduces Electrum, whose concrete syntax is
presented in Fig. 33. The language is inspired both by Alloy,
for its structural concepts, and by TLA+, for its ability to
freely dene actions as predicates with primed variables. The
specication of the examples in Electrum, as well as their
Alloy and TLA+versions, can be found here [ 1515].
Likewise Alloy, structure in Electrum is introduced through
the declaration of signatures which specify sets of uninter-
preted atoms. Hierarchical signatures can be introduced
byextension , in which case the sub-signatures must be dis-
joint, or through inclusion , in which case sub-signatures may
overlap with each other. Abstract signatures are comprised
only of the atoms of their sub-signatures. Finally, signatures
may be attached with multiplicities that restrict the num-ber of atoms that they may contain. Signature declarations
may also introduce elds with arbitrary, nite arity, that
represent relations between the various signatures. These
constructs are essentially those provided by the standard
Alloy language.
Contrary to Alloy, however, both signatures and elds
may be additionally tagged as variable , meaning that their
valuation may evolve in time. In contrast, non-variable
signatures and elds are assumed to be static, meaning that
their valuation remains xed throughout the evolution of the
system. Thus, Electrum provides a clear distinction between
the conguration of the system (static constructs) and its
evolution (variable constructs) ( R1R1).
Additional restrictions are introduced through the deni-
tion of paragraphs :facts (axioms) impose restrictions on the
specications and assertions denote properties that are to be
checked over the specication. Predicates and functions are
essentially reusable formulas and expressions, respectively.
Signatures may also be annotated with local facts, that apply
to every atom of the signature in every instant of time.
All these paragraphs are comprised of logical formulas that
borrow their expressiveness from Alloy (supporting universal
and existential quantications, as well as transitive closure
operations) and from TLA+(supporting classical temporal
operators22as well as primed expressions), and thus allow
both the specication of rich structural properties ( R2R2), the
denition of actions in a exible manner ( R3R3).
Verication commands (to be model-checked) are inte-
grated in the specication le (again, inspired by Alloy),
allowing the verication of rich temporal properties ( R4R4).
Check commands are passed an assertion and scopes for
the (static and variable) signatures and instruct the model-
checker to try to prove the assertion, while runcommands
instruct the model-checker to yield an example instance of the
specication if there is one (this way, it also shows whether
the specication is indeed consistent). The scopes bound
the maximum number of elements that a top-level signature
will at least contain and are described in more detail in Sec-
tion3.2.13.2.1. Remark that the model-checking techniques are
expected to explore every valid valuation of signatures and
elds up to the given bound33. It should be noticed that, for
a variable signature, the scope bounds the total number of
its instances over the complete life of the modeled system44.
Figure 44presents the hotel room locking system specied
in Electrum. Rooms, guests and keys are introduced by static
signatures, meaning that their valuation remains xed along
the system evolution. There is also a singleton signature FD
representing the front desk. There is only one static eld
keys , that represents the set of keys assigned to each room;
this distribution is constrained to be a partition by fact
DisjointKeys . Every other eld, denoting the key currently
coded for a room, and the registry of occupants and assigned
keys at the front desk, is variable. Actions are declared as
regular predicates that refer to the post-state by priming
2The keyword after was chosen to stand for the X(read:
\next") temporal operator because, in Alloy, next is a pred-
icate from a commonly used standard library for ordering,
and we wanted to preserve upward compatibility with Alloy.
3This contrasts with TLC conguration les which assign
concrete valuations to the constant parameters.
4As time may be unbounded, this is a way to retain decid-
ability while remaining faithful to the successful bounded
verication practice of Alloy.spec=module qualName [[name ,+]]importparagraph
import=open qualName [[qualName ,+]] [asname ]
paragraph=sigDecljfactDecljfunDecljpredDecl
jassertDecljcheckCmd
sigDecl=[var] [abstract ] [mult ]sig name ,+
[sigExt ]{varDecl ,}[block ]
sigExt=extends qualNamejinqualName [+qualName ]
mult=lonejsomejone
decl=[disj ]name ,+:[disj ]expr
varDecl=[var]decl
factDecl=fact [name ]block
assertDecl=assert [name ]block
funDecl=fun name [[decl ,]]:expr {expr }
predDecl=pred name [[decl ,]]block
expr=constjqualNamej@namejthisjunOp expr
jexpr binOp expr jexpr arrowOp expr jexpr [expr ,]
jexpr [!jnot]compareOp expr
jexpr (=>jimplies )expr else expr
jquant decl ,+blockOrBarj(expr )jblock
j{decl ,+blockOrBar }jexprâ€™
const=nonejunivjiden
unOp=!jnotjnojmultjsetjj *j^
jeventuallyjalwaysjafter
binOp=||jorj&&jandj<=>jiffj=>jimplies
j&j+j-j++j<:j:>j.juntiljrelease
arrowOp=[multjset]![multjset]
compareOp=inj=
letDecl=name =expr
block={expr}
blockOrBar=blockj|expr
quant=alljnojmult
checkCmd=check qualName [scope ]
scope=for number [but typescope ,+]jfor typescope ,+
typescope=[exactly ]number qualName
qualName=[this /] (name /)name
Figure 3: Concrete syntax of the Electrum language (addi-
tions w.r.t. the Alloy syntax are underlined).
variable expressions. Finally, the fact traces restricts the
acceptable states of the system: a state is either the initial
one or obtained from the application of the actions. Over
this specication, the assertion NoBadEntry veries whether
there are unwanted room entries. This assertion is referred
by the check command immediately below that instructs
the model-checker to test the assertion for a scope of at
most 3 elements per signature (it also denes the scope for
time instants if the analysis is performed by the bounded
model-checker, as will be described in Section 3.23.2).
The exibility of the language allows the adoption of varied
specication idioms that could be cumbersome in more rigid
specication languages. For instance, in the event idiom,
actions are embodied by model elements rather than by
predicates. This allows the developer to dene a hierarchy
of actions, allowing the sharing of parameters ( e.g., in the
room locking system, every action has a guest parameter)
and of constraints ( e.g., in the front desk actions, the frame
condition on the room coded keys is shared), resulting in
simpler and more manageable specications.
Figure 55depicts an excerpt of the hotel room locking
system specied with the event idiom in Electrum, where
each action is embodied by a variable signature: the presence
of an event atom in an instant denotes the occurrence of
that action. This excerpt is an alternative to the check-in
action predicate specied in Fig. 44. When dening these
event signatures, one must be aware of the bounded nature of
the universe in order to not restrict the application of actions.
Here, the multiplicity oneof the abstract Event signature,
from which the concrete events inherit, forces the existenceopen util/ordering[Key] asko
sig Key {}
sig Room {
keys: set Key,
var currentKey: one keys }
fact DisjointKeySets {
keys inRoom lone!Key }
one sig FD {
var lastKey: Room!lone Key,
var occupant: Room!Guest }
sig Guest {
var gKeys: Key }
fun nextKey[k: Key, ks: set Key]: set Key {
min[k.nexts & ks] }
pred checkin[g: Guest, r: Room, k: Key] {
g.gKeysâ€™ = g.gKeys + k
noFD.occupant[r]
FD.occupantâ€™ = FD.occupant + r !g
FD.lastKeyâ€™ = FD.lastKey ++ r !k
k = nextKey[FD.lastKey[r], r.keys]
all gg: Guest - g | gg.gKeysâ€™ = gg.gKeys
all r: Room | r.currentKeyâ€™ = r.currentKey }
: : :
pred init {
noGuest.gKeys
noFD.occupant
all r: Room | FD.lastKey[r] = r.currentKey }
fact traces {
init
always |some g: Guest, r: Room, k: Key |
entry[g, r, k] orcheckin[g, r, k] orcheckout[g] }
assert NoBadEntry {
always |all r: Room, g: Guest, k: Key |
entry[g, r, k] and some FD.occupant[r] =>
ginFD.occupant[r] }
check NoBadEntry for 3
but 5 Time // Time scope only for bounded verification
Figure 4: Hotel room locking system under Electrum.
of exactly one event at each instant, although the concrete
event signature to which it belongs may vary in time (this
also simplies the fact traces , that will only be required to
enforce the init constraint). Parameters of the actions are
embodied by the event-signature elds: since all the actions
in the hotel room locking system have a guest parameter,
this eld is dened at the top-level event signature. Another
abstract signature FDEvent represents every action that occurs
at the front desk, enforcing the frame condition on the door
locks' coded keys. The concrete event signatures then dene
the specic constraints that restrict their occurrence at each
instant. Note how, in the check-in action presented in Fig. 55,
the constraint is identical to the one dened in the predicate
idiom in Fig. 44(modulo the frame condition), and thus
no additional burden was imposed on the developer. The
remaining operations would be dened in a similar manner.
Figure 66depicts an excerpt of a possible specication of the
elevator SPL in Electrum to illustrate its potential to handle
systems with variability (the actions are omitted). Here,
features are simply declared as static signatures, a product
being simply a subset of those features. Conicts between
features are enforced through constraints over products. Theone var abstract sig Event {
g: Guest }
var abstract sig FDEvent extends Event { } {
currentKeyâ€™ = currentKey }
var sig Checkin extends FDEvent {
r: Room,
k: Key } {
g.gKeysâ€™ = g.gKeys + k
noFD.occupant[r]
FD.occupantâ€™ = FD.occupant + r !g
FD.lastKeyâ€™ = FD.lastKey ++ r !k
k = nextKey[FD.lastKey[r], r.keys]
all gg: Guest - g | gg.gKeysâ€™ = gg.gKeys }
Figure 5: Excerpt of the hotel room locking system under
Electrum in the event idiom.
abstract sig Feature {}
one sig FIdle, FExecutive, FPark extends Feature {}
sig Product inFeature {} {
FIdle + FPark not in this }
sig Floor {} {
one b: LandingButton | b.floor = this
one b: LiftButton | b.floor = this }
abstract sig Button { floor: one Floor }
sig LandingButton, LiftButton extends Button {}
var one sig Current inFloor {}
var lone sig Open, Up {}
var sig Pressed inButton {}
: : :
pred prop {
always {all f: Floor | floor.f&LiftButton inPressed =>
eventually { current = f && some Open } } }
check { FIdle = Product => prop } for 6but 10 Time
Figure 6: Excerpt of the of the elevator SPL under Electrum.
oors and the respective buttons { one landing and one
elevator button per oor { are also static and dened by
structural constraints. The remaining signatures depict the
variable components of the model. At each instant, one oor
marks the current position of the elevator; \lone" variable
signatures act as temporal Boolean variables, that denote
whether the elevator is open and moving in the upward
direction; nally, a set of buttons is selected as pressed at
each moment. Properties can then be checked for arbitrary or
particular products, e.g., the check command in the excerpt
checks whether calls from elevator buttons are eventually
answered for products that only implement the idle feature.
3.1.2 Electrum Kernel
Following the approach of [ 1818, App. C], we simplify the
presentation of the semantics of our framework by consid-
ering a stripped-down language, dubbed Electrum Kernel,
focusing only on formulas and relational terms. The abstract
syntax of Electrum Kernel is shown in Fig. 77. For constraints
and relational expressions, the translation from Electrum
is relatively straightforward and follows that of Alloy ker-
nel (specically, in formulas, the dual logical operators and
connectives may be dened in the obvious way).
In Electrum Kernel, the main concept is that of relation.
We assume the existence of a set Rofvariable relations, whichformula=not formulajafter formula
jalways formulajeventually formula
jformula until formulajformula and formula
jterm intermjall decl |formula
term=x2V arjr2R j ^termj term
jterm &termjtermtermjterm .term
jterm â€™j{decl+|formula }
decl=x:term
Figure 7: Electrum Kernel abstract syntax.
are declared with their arity. Signatures and elds declared
in Electrum are translated into Electrum Kernel relations
(unary relations in the case of signatures). We also assume
the existence of a set Varof rst-order variables. Additional
information expressed in signature and eld declarations in
Electrum (multiplicities, the fact that some signatures and
elds are static, signature hierarchy and local facts) must be
specied by formulas in Electrum Kernel (in our prototypes,
more ecient encodings are implemented).
In order to illustrate the translation from Electrum to
Electrum Kernel, let us consider the following example:
abstract sig A { r: some A }
var sig B,C extends A {}
In the corresponding Electrum Kernel specication, three
unary relations and one binary relation are declared.
Relations : A(1), B(1), C(1), r(2)
The fact that Ais not a variable signature is expressed
by the formula always Aâ€™ = A . The fact that Band Cex-
tend A, which is abstract, can be expressed by the formula
always (A = B + C and no B & C) .
Now, the typing and the multiplicity constraint related to
the eld rare expressed as follows:
always rinA!A
always all a: A | some a.r
Local facts are surrounded by an always operator after
translation, forcing them to hold in every instant of time.
3.1.3 FOLTL
The semantics of Electrum Kernel is expressed viaa trans-
lation into First-Order Linear Temporal Logic (FOLTL) [ 1616,
33]. Here we briey describe its syntax and semantics.
Denition 1. Given mutually-disjoint sets VandPof
(resp.) variables and predicates (with their arity), the syntax
of FOLTL formulas is given as follows55:
'=P(x1;:::;x k)jx1:=x2
j:'j'^'j8x:'jX'jG'jF'j'U'
withxi2VandP2P(of course,P(x1;:::;xk)is a formula
only if the arity of Pisk).
Derived constructs ( 9,_,)) can be dened in the obvious
way. X'(read \next '") means that 'is true in the next
instant, G'(read \always '") means that 'willalways be
true,F'(read \eventually '") means that 'will eventually
be true and 'U (read \'until ") means that 'is true and
remains true until  becomes true. The \release"' operator
can be derived from 'U in the usual way.
5The symbol:=stands for equality in FOLTL in order to
avoid notation clashes.FOLTL is provided with both unbounded and bounded
semantics. For the unbounded semantics, time is interpreted
over the set Nof non-negative integers. Each rst-order
variable is interpreted over the domain D.
Denition 2. Amodel for FOLTL is a pair M= (D;)
where: (1) the set Dis the domain of rst-order variables
and (2)maps each predicate P2Pat each instant i2N
to a relation (P;i)Dk, wherekis the arity of P.
The satisfaction of a formula by a model is then dened
as follows.
Denition 3. Given a modelM, a formula ', an instant
i2N, and an environment , mapping each free variable
xto an element in the domain D, the satisfaction relation
M;;ij='is dened inductively as follows.
M;;ij=x:=yif(x) =(y)
M;;ij=P(x1;:::;x n) if ((x1);:::; (xn))2(P;i)
M;;ij=:'ifM;;i6j='
M;;ij='_ ifM;;ij='orM;;ij= 
M;;ij=8x:'if for alla2D;M;[x7!a];ij='
M;;ij=X'ifM;;i+ 1j='
M;;ij=G'if for eachji;M;;jj='
M;;ij=F'if there isjis.t.M;;jj='
M;;ij='U if there exists jis.t.M;;jj= ;
and for allik<j;M;;kj=':
A formula'without free variables is satisable if and only
if there exists a model Msuch thatM;;;0j=', which is
simply denoted by Mj='.
The bounded semantics of FOLTL can be derived from the
unbounded one following the standard technique described
in [22]. In (bounded) models of size k(denoting traces with k
states),is partial function, with domain f0:::k 1g. If
such trace has a loop to time 0l<k 1,i.e., the value
of(s;k 1)is equal to the value of (s;l)for alls, then
the semantics is the same as in the unbounded case, after
unrolling the model to be dened over N. If the trace has
no loop, then the semantics has to be slightly adjusted, as
such traces cannot be considered valid models of (invariant)
formulas of type G'(as there could be a state after k 1that
violates'), and only of formulas of type F'(as discussed
in [22],GandFare no longer duals in a bounded semantics,
hence the inclusion of both in the language kernel).
Note that we do not follow the temporal semantics from
TLA+, which makes formulas invariant under stuttering
(for compositionality purposes), but use instead the classic
semantics of temporal logic, which allows to specify behaviors
that may not be invariant under stuttering.
3.1.4 From Electrum Kernel to FOLTL
The essence of the interpretation of Electrum Kernel into
FOLTL boils down to removing relational terms so that
we end up with formulas only. This is a standard approach
when embedding the relational logic of Alloy into FOL [ 1414,99].
Thus, the main operation consists in removing all membership
and inclusion statements present in Electrum Kernel formulas
and replacing them with corresponding FOLTL subformulas.
Hence the semantic map (denoted J K) relies on a function
[ 2  ]which, given a pair of a tuple of variables and a
term, yields a formula stating that the former is a member
of the latter. For the sake of readability, tuples are writtenJnotfK=:JfK
JafterfK=XJfK
JalwaysfK=GJfK
Jeventually fK=FJfK
Jf1untilf2K=Jf1KUJf2K
Jf1andf2K=Jf1K^Jf2K
Jt1int2K=8~ x:[~ x2t1])[~ x2t2]
where~ xarefresh variables;
Jallx:t|fK=8x:[x2t])JfK
[x2y] =x:=y
[~ x2r] =r(~ x)
[hx1;x2i2^t] = there are y1;:::;y nsuch that
y1:=x1^yn:=x2^^
i<n[hyi;yi+1i2t]
[hx1;x2i2t] = [hx2;x1i2t]
[~ x2t1&t2] = [~ x2t1]^[~ x2t2]
[~ x2t1t2] = [~ y2t1]^[~ z2t2]
with~ x=~ y~ z
[~ x2t1:t2] =9u:[~ yu2t1]^[u~ z2t2]
where~ x=~ y~ z, anduis afresh variable,
[~ x2t0] =X[~ x2t]
[~ x2f~ y:~tjfg] =^
16i6j~ xj[xi2ti]
^Jff~ y ~ xgK
whereff~ y ~ xgis the usual substitution.
Figure 8: From Electrum Kernel to FOLTL (cf.. Def. 44).
as vectors, their concatenation is denoted by juxtaposition
andjjstands for their length.
Denition 4. The formal semantics of Electrum Kernel
formulas into FOLTL formulas is dened by structural in-
duction according to Fig. 88.
3.2 Veriï¬cation
While Electrum supports the denition of both rich speci-
cations and properties to be checked over them, it is only
useful if accompanied by eective model-checking techniques.
Fitting the dual nature of the problem at hand, two distinct
approaches to the model-checking of Electrum specications
were explored: one bounded and another unbounded. Before
detailing these, we rst describe the commands provided by
Electrum for formal analysis.
3.2.1 Commands and scopes
As presented in Section 3.1.13.1.1, an Electrum specication
integrates execution commands for the model-checker. The
dierence between both verication approaches lies in the way
time is handled. In the bounded approach, time is internally
handled as a signature and is thus bounded the same way
as others, and in the other time is left unbounded. The
maximum number of time instants considered by the bounded
approach is also dened in the scope of the commands (which
is simply ignored by the unbounded approach).Then, given an Electrum model and a scope, every sig-
nature or eld is instantiated depending on the bound of
signatures. The model and the \run" (or \check") command
give rise to a formula 'Mand a formula 'r(or'c), re-
spectively. Finally, if the command is a \run", the formula
'M^'ris checked for satisability ; otherwise we check
whether'M)'cisvalid. In the following, we detail how
these verication problems translate in practice.
3.2.2 Bounded model-checking
The bounded semantics of FOLTL described in Section 3.1.33.1.3
can be directly encoded into Alloy itself, as described in [ 88],
by explicitly introducing a time signature with a total or-
der imposed over it to represent the trace; potential loops
are represented by a relation from the last time atom to a
previous one. Our bounded model-checker is implemented
using this alternative encoding, and deployed as a new ver-
sion of the Alloy Analyzer, to minimize the adoption time
by Alloy practitioners. This Analyzer not only generates a
single counter-example (depicted visually), but allows the
user to iterate over all possible counter-examples (within the
specied bounds) that broke the specied properties, thus
providing the user with a wider perception of what may be
the problems of the specication. Note that this bounded
model-checking procedure is iterative, checking the proper-
ties for increasing trace sizes up to the specied scope on
time, stopping along the way if a counter-example is found.
3.2.3 Unbounded model-checking
This technique is implemented in a prototype called the
Electrum Analyzer. It relies on a direct embedding into the
nuXmv tool66which implements various algorithms perform-
ing unbounded model-checking [ 44] (we currently rely on the
so-called \k-liveness" algorithm). Its free-software predeces-
sor, NuSMV, can also be used but it is far less ecient on
the examples we have studied so far. The principle of the
translation proceeds as described before, chaining a transla-
tion from Electrum to Electrum Kernel, then to FOLTL and
nally to LTL. Compared to the semantics presented in this
paper, several simple optimizations are also implemented
(smarter optimizations are left for future work).
Now, nuXmv expects a description of a transition system
and a formula to check on the latter, whereas an Electrum
model is essentially a formula specifying a set of transition
systems (that satisfy it). Hence the generated SMV model
does not contain an explicit transition system: (i) signatures
and elds give rise to \frozen" or plain variables depending
on their status (static or variable); (ii) various formulas re-
lated to the typing and inclusion of signatures and elds are
combined to form an \invariant" section in the le. This is
important as it allows to constrain and reduce the size of
the state space. A possible improvement would be to infer a
(non-deterministic) transition system and add a correspond-
ing SMV \assign" section, restricting the state space further.
Then, a so-called SMV \LTL specication" is produced that
represents the formula to be veried77.
Finally, it should be remarked that the present approach
allows to perform verication on an unbounded time horizon,
but it does not allow to perform scenario exploration, namely
6Available at https://nuxmv.fbk.euhttps://nuxmv.fbk.eu .
7This formula is in practice dualized (w.r.t. the description
in Section 3.2.13.2.1) as nuXmv expects specications expressed
as validity problems rather than as satisability ones.iterate over counter-examples, the same way the bounded
approach does. Therefore, regardless of practical performance
results, both approaches are complementary.
4. EV ALUATION
This section presents the empirical evaluation of our lan-
guage and the proposed model-checking techniques. Con-
cretely, we aim to assess how the performance of the proposed
bounded and unbounded checking techniques compare with
each other and with other existing, similar approaches.
To answer these questions, a detailed evaluation of the
proposed techniques under the examples from Section 1.11.1
is presented, as well as a summary of the results for an
additional specication with rich congurations.
Regarding the hotel room locking system, two versions are
considered: Hotel (1) checks the desired safety property
and thus leads to counter-examples, and Hotel (2) checks
the same property, but with an additional constraint that
prohibits any other action to occur between a guest checking
in and entering a room, and, as a result, is correct. Recall
nonetheless that the counter-example in Hotel (1) does not
occur with every conguration. In these examples, the size
of the model ndenotes the number of keys, rooms and guests
available in the universe. For the spanning tree algorithm, we
consider the following verication goals: Span (1) checks the
liveness property without enforcing fairness, thus producing
counter-examples; Span (2) checks for the liveness property
but with fairness enforced, and thus is correct; and Span
(3)checks for the safety property and does not generate
counter-examples. Here, model size ndenotes the number of
processes and tree levels in the universe. For the SPL example
we consider two check commands: Elevator (1) tests the
liveness property for products implementing only the idle
feature, which holds; Elevator (2) tests the property for
arbitrary products which does not hold. Here ndenotes the
exact number of oors.
Additionally we explore another distributed algorithm over
arbitrary topologies that is packaged with the Alloy Ana-
lyzer, whose specication was quite simplied with Electrum.
Concretely, we consider a distributed algorithm for the elec-
tion of a leader in a network with ring topology, inspired
by the specication presented in [ 1818]. This specication is
checked for two temporal properties: that at least one leader
is eventually elected (a liveness property) and that at most
one leader is elected (a safety property). Dierent versions
of the specication were considered: Ring (1) checks the
specication for liveness without fairness enforced, Ring (2)
checks for liveness with fairness, and Ring (3) checks for
safety, which holds.
As has already been stated in Section 22, the two existing
techniques that we believe are best suited to model-check
specications with rich congurations are Alloy and TLA+.
Since our bounded technique actually relies on Alloy, we will
focus on comparing the performance of our two techniques
with that of TLA+/TLC.
All tests were run multiple times using Alloy 4.2 with the
MiniSat solver and nuXmv 1.0.1, on a 1,8 GHz Intel Core i5
with 4 GB memory running OS X 10.10. TLC 2.05 was used
for the TLA+tests. Note that, for the unbounded approach,
we pre-process Electrum les to replace every command by
all possible combinations of the said command with exact
scopes . Then we generate as many corresponding SMV les,
and run nuXmv in parallel on all CPU cores using GNUparallel [2929], starting with the smallest scopes and stopping
immediately if a property is refuted.
4.1 Results
Figures 9a9aand10a10apresent the performance for the hotel
room locking system and the spanning tree algorithm for a
xed sizen= 4and increasing trace length tfor the bounded
scenario. Labels Hnand Snstand for the Hotel (n)and
Span (n)scenarios respectively, and BndandUbdstand for
the bounded and unbounded techniques.
In the unbounded technique the properties are checked
for arbitrary trace lengths, and thus their performance is de-
picted by a constant function in these graphs. Note also that
in the bounded scenario, each trace length aggregates the
time spent verifying the smaller traces, i.e., the time spent
to assess that a property holds for t= 4includes checking
the property for lengths 1, 2 and 3. In the scenarios where
there are counter-examples to be found, the performance of
the bounded technique stabilizes at the tvalue where that
counter-example nally occurs ( e.g., 5 for Hotel (1) ). This
is due to the iterative nature of the technique: once a counter-
example is found, the procedure is stopped and not run for
largertvalues. In contrast, when no counter-examples occur,
the technique must be run for every trace length value and
keeps increasing with t. The performance of the unbounded
approach is also better when there are counter-examples to
be found due to the parallelization of the procedure that
stops as soon as a counter-example is found. For the sce-
narios without counter-examples the procedure must check
the properties for every launched process. The bounded
technique outperforms the unbounded one for smaller trace
lengths, but their performance starts to converge as the t
value increases. This reinforces the common policy of relying
on bounded techniques to quickly discard trivial counter-
examples, and move on to unbounded techniques only when
the condence level is high enough.
In contrast, Figs. 9b9band10b10bpresent the performance of
the model-checking techniques for increasing model size n
and xed trace length t= 20 (for the bounded technique).
Again, for the bounded scenario the results aggregate the
time spent for trace lengths up to 20. At suchtvalue, the
performance of the two model-checkers is almost similar for
the considered examples, although the bounded technique
still outperforms the unbounded one. For Hotel (1) and
Span (1) , the performance of the bounded technique im-
proves atn= 3andn= 2, respectively, because these are the
sizes where counter-examples rst appear, and for smaller
sizes the properties must be checked for every trace length.
Table 11summarizes the evaluation for the explored exam-
ples and reinforces the conclusions discussed above. It also
presents the number of valid congurations for each of the
scenarios. Note how the hotel room locking system already
has 18960 valid congurations for n= 4. The Alloy Analyzer
has a powerful symmetry breaking algorithm that infers an
equivalence class within the search space, highly reducing
the number of explored models. For example, in the same
example, the number of non-symmetric congurations is only
520. By performing the bounded model-checking of Electrum
via an embedding into Alloy we take advantage of this mecha-
nism, hence the quite positive results for this technique. This
also points for interesting possible optimizations of the un-
bounded model-checking technique, namely its parallelization
based on unique non-symmetric congurations.(a) Fixed n= 4 and increasing t.
 (b) Fixed t= 20 and increasing n.
Figure 9: Performance tests for Hotel (1) andHotel (2) .
(a) Fixed n= 4 and increasing t.
 (b) Fixed t= 20 and increasing n.
Figure 10: Performance tests for Span (1) ,Span (2) andSpan (3) .
Spec. n #Cfg (sym) Type Holds Bnd (s) Ubd (s)
Hotel (1) 4 18960 (520) S  0.2 47.5
Hotel (2) 4 18960 (520) S X 31.2 3844.2
Span (1) 4 216 (16) L  0.0 14.5
Span (2) 4 216 (16) L X 35.1 803.9
Span (3) 4 216 (16) S X 36.4 125.8
Ring (1) 3 40 (9) L  0.0 3.4
Ring (2) 3 40 (9) L X 2.0 156.9
Ring (3) 3 40 (9) S X 31.9 35.2
Elevator (1) 3 1 (1) L  0.0 12.3
Elevator (2) 3 48 (48) L X 21.1 2246.8
Table 1: Summary of the performed tests (for t= 20 for the
bounded scenarios); S is for \safety", L is for \liveness".
For the comparison with TLC, we encoded the considered
examples in TLA+. In general, our model-checkers outper-
form TLC when there are counter-examples to be found.
For instance, for Hotel (1) withn= 4, TLC takes 545.2
seconds to generate a counter-example. In contrast, TLC
outperforms our unbounded technique when there are no
counter-examples. For instance, for Hotel (2) TLC takes
256.6 seconds to check that the specication is correct. Note
that our unbounded technique, unlike TLC which imposes
constraints on how actions can be specied, can handle ac-
tions specied in a very liberal declarative style. Nonetheless,
our experiments show that TLC is heavily aected by the
number of valid congurations (worsened by the fact that
it is not able to explore symmetry), since these aect the
number of initial states that must be explored. In fact, in the
hotel scenarios, for sizes higher than n= 4, TLC runs out of
memory when calculating the initial states. Our unbounded
model-checker is still able to terminate in such scenarios.5. CONCLUSION
This work proposed a language, Electrum, mixing the best
aspects of both Alloy and TLA+, currently two of the most
popular formal specication languages, and that we believe
hits the sweet spot for the specication of dynamic systems
requiring rich declarative specications (both of structural
aspects, namely congurations, and dynamics). Two model-
checking tools for this language were also developed, one
bounded and the other unbounded, that our preliminary
evaluation already showed to be competitive, performance
wise, with existing model-checkers, in particular TLC. The
bounded model-checker is useful at early analysis stages,
namely excelling at founding and iterating over counter-
examples, while the unbounded one, naturally slower, should
be used afterwards for further conrmation of the results.
In the future we intend to improve the Electrum frame-
work in two key aspects: rst, building on previous work
on scenario exploration [ 2525,1010,2323], we intend to improve
the counter-example generation and iteration features, by
allowing the user to parameterize the tool to prioritize certain
aspects, for example, showing rst counter-examples similar
to those found in previous versions of the specication; sec-
ond, we intend to improve the eciency of the unbounded
model-checking technique in order to take advantage of sym-
metry breaking, namely explore a \hybrid" verication ap-
proach where a bounded analyzer would compute in advance
(bundles of) non-symmetric static congurations, to be used
to optimize the LTL specications passed to each (parallel)
unbounded checking process.6. REFERENCES
[1] S. Apel, W. Scholz, C. Lengauer, and C. K astner.
Detecting dependences and interactions in
feature-oriented design. In ISSRE 2010 , pages 161{170.
IEEE, 2010.
[2] A. Biere, A. Cimatti, E. M. Clarke, and Y. Zhu.
Symbolic model checking without BDDs. In TACAS
1999, volume 1579 of LNCS , pages 193{207. Springer,
1999.
[3] T. Bra uner and S. Ghilardi. First-order modal logic.
Handbook of modal logic , 3:549{620, 2007.
[4] R. Cavada, A. Cimatti, M. Dorigatti, A. Griggio,
A. Mariotti, A. Micheli, S. Mover, M. Roveri, and
S. Tonetta. The nuXmv symbolic model checker. In
CAV 2014 , volume 8559 of LNCS , pages 334{342.
Springer, 2014.
[5] F. S. Chang and D. Jackson. Symbolic model checking
of declarative relational models. In ICSE 2006 , pages
312{320. ACM, 2006.
[6] A. Classen, M. Cordy, P. Heymans, A. Legay, and
P. Schobbens. Model checking software product lines
with SNIP. STTT , 14(5):589{612, 2012.
[7] A. Classen, M. Cordy, P. Heymans, A. Legay, and
P. Schobbens. Formal semantics, modular specication,
and symbolic verication of product-line behaviour. Sci.
Comput. Program. , 80:416{439, 2014.
[8] A. Cunha. Bounded model checking of temporal
formulas with Alloy. In ABZ 2014 , volume 8477 of
LNCS , pages 303{308. Springer, 2014.
[9] A. Cunha, A. Garis, and D. Riesco. Translating
between Alloy specications and UML class diagrams
annotated with OCL. Software & Systems Modeling ,
14(1):5{25, 2015.
[10] A. Cunha, N. Macedo, and T. Guimar~ aes. Target
oriented relational model nding. In FASE 2014 ,
volume 8411 of LNCS , pages 17{31. Springer, 2014.
[11] J. Edwards, D. Jackson, and E. Torlak. A type system
for object models. In FSE 2004 , pages 189{199. ACM,
2004.
[12] M. F. Frias, J. P. Galeotti, C. L. Pombo, and
N. Aguirre. DynAlloy: upgrading Alloy with actions. In
ICSE 2005 , pages 442{451. ACM, 2005.
[13] M. F. Frias, C. L. Pombo, J. P. Galeotti, and
N. Aguirre. Ecient analysis of DynAlloy specications.
ACM Trans. Softw. Eng. Methodol. , 17(1), 2007.
[14] A. A. E. Ghazi and M. Taghdiri. Relational reasoning
via SMT solving. In FM 2011 , volume 6664 of LNCS ,
pages 133{148. Springer, 2011.
[15] High-assurance Software Laboratory (HASLab) and
The French Aerospace Lab (ONERA). Electrumrepository. Available at
https://github.com/haslab/electrum/tree/FSE16https://github.com/haslab/electrum/tree/FSE16 ,
2016.
[16] I. Hodkinson, F. Wolter, and M. Zakharyaschev.
Decidable fragments of rst-order temporal logics.
Annals of Pure and Applied Logic , 106(1{3):85 { 134,
2000.
[17] D. Jackson. Automating rst-order relational logic. In
FSE 2000 , pages 130{139. ACM, 2000.
[18] D. Jackson. Software Abstractions: Logic, Language,
and Analysis . MIT Press, revised edition, 2012.
[19] D. Jackson, I. Shlyakhter, and M. Sridharan. A
micromodularity mechanism. In ESEC / FSE 2001 ,
pages 62{73. ACM, 2001.
[20] L. Lamport. Specifying Systems, The TLA+ Language
and Tools for Hardware and Software Engineers .
Addison-Wesley, 2002.
[21] N. Macedo and A. Cunha. Alloy meets TLA+: An
exploratory study. CoRR , abs/1603.03599, 2016.
[22] N. Macedo and A. Cunha. Least-change bidirectional
model transformation with QVT-R and ATL. Software
& System Modeling , 15(3):783{810, 2016.
[23] N. Macedo, A. Cunha, and T. Guimar~ aes. Exploring
scenario exploration. In FASE 2015 , volume 9033 of
LNCS , pages 301{315. Springer, 2015.
[24]J. P. Near and D. Jackson. An imperative extension to
alloy. In ABZ 2010 , volume 5977 of LNCS , pages
118{131. Springer, 2010.
[25] T. Nelson, S. Sagha, D. J. Dougherty, K. Fisler, and
S. Krishnamurthi. Aluminum: principled scenario
exploration through minimality. In ICSE 2013 , pages
232{241. IEEE/ACM, 2013.
[26] C. Newcombe, T. Rath, F. Zhang, B. Munteanu,
M. Brooker, and M. Deardeu. How Amazon Web
Services uses formal methods. Commun. ACM ,
58(4):66{73, 2015.
[27] M. Plath and M. Ryan. Feature integration using a
feature construct. Sci. Comput. Program. , 41(1):53{84,
2001.
[28]I. Shlyakhter, M. Sridharan, and D. Jackson. Analyzing
distributed algorithms with rst-order logic. available at
http://sdg.csail.mit.edu/pubs/alloy-distalg.pdfhttp://sdg.csail.mit.edu/pubs/alloy-distalg.pdf , 2002.
[29] O. Tange. Gnu parallel - the command-line power tool.
;login: The USENIX Magazine , 36(1):42{47, Feb 2011.
[30] A. Vakili and N. A. Day. Temporal logic model
checking in Alloy. In ABZ 2012 , volume 7316 of LNCS ,
pages 150{163. Springer, 2012.
[31] P. Zave. Using lightweight modeling to understand
Chord. SIGCOMM Comput. Commun. Rev. ,
42(2):49{57, 2012.