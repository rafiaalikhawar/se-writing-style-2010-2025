SMT-Based VeriÔ¨Åcation of Parameterized Systems
Arie GurÔ¨Ånkel
SEI/CMU, USA
University of Waterloo,
Canada
arie.gurnkel@uwaterloo.caSharon Shoham
Tel Aviv University, Israel
sharon.shoham@gmail.comYuri Meshman
Technion, Israel
syurim@gmail.com
ABSTRACT
It is well known that verication of safety properties of se-
quential programs is reducible to satisability modulo theory
of a rst-order logic formula, called a verication condition
(VC). The reduction is used both in deductive and auto-
mated verication, the dierence is only in whether the user
or the solver provides candidates for inductive invariants. In
this paper, we extend the reduction to parameterized sys-
tems consisting of arbitrary many copies of a user-specied
process, and whose transition relation is denable in rst-
order logic modulo theory of linear arithmetic and arrays.
We show that deciding whether a parameterized system has
a universally quantied inductive invariant is reducible to
satisability of (non-linear) Constraint Horn Clauses (CHC).
As a consequence of our reduction, we obtain a new auto-
mated procedure for verifying parameterized systems using
existing PDR and CHC engines. While the new procedure
is applicable to a wide variety of systems, we show that it is
a decision procedure for several decidable fragments.
CCS Concepts
Theory of computation !Automated reasoning;
Logic and verication; Verication by model checking;
Keywords
model checking, parameterized systems, safety verication,
invariant inference
This material is based upon work funded and supported by
the Department of Defense under Contract No. FA8721-05-
C-0003 with CMU for the operation of the SEI, a FFRDC
and by EU { Seventh Framework Programme (FP7) under
ERC grant agreements No. 321174-VSSC and No. 615688 {
ERC-COG-PRIME. Any opinions, ndings and conclusions
or recommendations expressed in this material are those of
the authors and do not necessarily reect the views of the US
DoD. [Distribution Statement A] This material has been ap-
proved for public release and unlimited distribution. Please
see Copyright notice for non-US Government use and distri-
bution. DM-00034261. INTRODUCTION
Many mutual exclusion algorithms, bus protocols, dis-
tributed algorithms, telecommunication protocols, and cache
coherence protocols are designed to be run by an arbitrary
number of threads or processes. Such protocols give rise to
parameterized systems , where the number of processes is a
parameter of the system. Any value of the parameter denes
an instance of the parameterized system.
In this work, we are interested in verifying safety prop-
erties of parameterized systems. Namely, we would like to
verify that the system is safe for any value of the parame-
ter. We consider parameterized systems where each instance
consists ofNidentical processes, executing asynchronously.
Safety holds if every conguration that is reachable from an
initial state via an execution of the system (with any number
of processes) satises the safety property.
Due to the unbounded number of processes, the set of pos-
sible congurations of the system is innite. Therefore, pa-
rameterized systems are a special case of innite-state tran-
sition systems. One of the most useful techniques for proving
safety of such systems, already advocated by Floyd [13], is
using inductive invariants . Given a set of initial congura-
tions Init, a transition relation Trand a safety property P,
we say that an invariant Invisinductive forhInit;Tr;Piif
Invsatises the following three conditions: (i) Init)Inv
(initiation ). (ii) Inv)P(safety ). (iii) Invis closed
under Tr, i.e., for every step of Trwhich starts in a con-
guration satisfying Inv,Invalso holds after executing Tr
(consecution ). It is well known that Pholds in all the con-
gurations that are reachable from Initvia steps of Trif and
only if there exists an inductive invariant for hInit;Tr;Pi(in
a suciently powerful language).
Our goal in this work is to nd inductive invariants that
prove safety of a parameterized system (for all values of the
parameter). To do so, we model the initial congurations
Init, the transition relation Tr, and the safety property P
of a parameterized system in rst-order logic (modulo the-
ory), and look for inductive invariants of the same form.
Since we consider instances of the system with an arbitrary
number of processes, we cannot x the set of processes in
the formulas describing Init,TrandP. Likewise, a typical
inductive invariant will not refer to a xed set of processes.
We, therefore, model process identiers as logical variables,
and allow for quantication over process identiers both in
Init,Tr,P, and in the invariants.
We observe that the verication condition of such a sys-
tem can be written as a set of Constrained Horn Clauses
(CHCs), where the invariant is given by an uninterpreted
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission and/or a
fee. Request permissions from Permissions@acm.org.
FSE‚Äô16 , November 13‚Äì18, 2016, Seattle, WA, USA
c2016 ACM. 978-1-4503-4218-6/16/11...$15.00
http://dx.doi.org/10.1145/2950290.2950330
338
predicate Inv(). The CHCs encode the initiation, safety
and consecution requirements, and contain quantied con-
straints . Searching for an inductive invariant then amounts
to solving the set of CHCs, i.e., nding an interpretation
ofInv() that satises all clauses. To tackle this problem,
we focus our attention on universally quantied invariants
(oruniversal invariants in short) where process identiers
are universally quantied. Despite their simplicity, univer-
sal invariants are powerful enough to prove safety of many
parameterized systems.
We show that under certain natural restrictions, searching
for a universal invariant with a xed number of universal
quantiers is reducible to the problem of solving quantier-
free CHCs. This reduction allows us to use existing CHC
solvers to nd universal inductive invariants.
As a consequence of our reduction, we obtain a new auto-
mated procedure for verifying parameterized systems using
existing PDR and CHC engines. Our procedure is applica-
ble to a wide variety of systems, and is a decision procedure
for several decidable fragments, including Petri nets.
Interestingly, in the case of one-quantier invariants, our
reduction produces Owicki-Gries proof rule [20]. For a larger
number of quantiers, our reduction generalizes Owicki-Gries.
Our main contributions are: (a) A safety verication con-
dition (VC) for parameterized systems in the form of CHCs
with quantied constraints. A solution to the CHCs is an
inductive invariant that certies safety of all instances of
the system. (b) Inference of universally quantied solutions
for the VC with a xed number of quantiers. We reduce
nding a solution with kuniversal quantiers to solving
quantier-free CHCs. (c) A sucient condition for a sys-
tem with innitely many processes to soundly approximate
a system with unbounded (but nite) number of processes.
(d) A procedure, by combining our technique with an iter-
ative search for a nite counterexample, for verifying safety
of parameterized systems, which is complete for interesting
decidable fragments. (e) An implementation and initial ex-
perience verifying interesting parameterized protocols.
2. OVERVIEW
In this section we provide a short overview of our approach
for safety verication of parameterized systems.
2.1 Motivating Example
Figure 1 presents an example of a parameterized system
which describes an arbitrary number of agents moving around
asynchronously. All agents run the code depicted in Fig-
ure 1. Each agent has a unique identier i, and its own copy
of the local variables, denoted v[i]. Agentionly changes its
own copies of the local variables, but its functionality also
depends on the local variables of other agents via univer-
sal global guards. In this example, an agent starts in state
CHOOSE. It then computes some (local) desired location
and changes its state to TRY. From TRY it changes its state
to WAIT and sets desired to itsnext location. However, this
change only happens under a global universal guard which
makes sure that the desired location is dierent than both
thecurr andnext locations of all the agents with higher
ids. Next, the agent changes to MOVE. This transition is
only enabled when next is dierent than both the curr and
next locations of all the agents with smaller ids. Finally, in
MOVE, the agent changes its curr location to next. Note
that the last two steps are not performed atomically: rstlocal
pc:fCHOOSE;TRY;WAIT;MOVEg;
curr;next;desired : Location
def proc(i):
do
pc[i] = CHOOSE :desired [i] :=;pc[i] := TRY;
pc[i] = TRY^8j:i<j)curr[j]6=
desired [i]^next[j]6=desired [i]:
next[i] := desired [i] ;pc[i] := WAIT ;
pc[i] = WAIT^8j:j <i)next[i]6=
curr[j]^next[i]6=next[j]:
pc[i] := MOVE ;
pc[i] = MOVE :
curr[i] :=next[i] ;pc[i]:= CHOOSE;
def init(i;j):
pc[i] = CHOOSE^curr[i] =next[i]^(i6=j)
curr[i]6=curr[j])
def bad(i;j):
i6=j^curr[i] =curr[j]
Figure 1: Collision avoidance [7].
the agent changes its state to MOVE, and only in the next
step it actually moves. The safety property requires that no
collisions occur.
This example has two sources of innity which make the
verication task challenging. First, the locations are taken
from an innite domain. Second, and more importantly, the
number of agents is unbounded. Fortunately, the theory of
Linear Integer Arithmetic allows SMT-based veriers to deal
with the rst source of innity. However, to tackle the sec-
ond obstacle and verify the system for anynumber of agents,
we need to consider quantied invariants that prove correct-
ness of all instances of the system simultaneously, while also
taking into account innite domains of variables.
2.2 Our Approach
We view the problem of nding an invariant for the pa-
rameterized system as the problem of nding a solution to
a set of Constrained Horn Clauses (CHCs) which capture
the initiation, consecution and safety requirements of an in-
ductive invariant. In order to formulate the problem in this
way, we model the initial states, the transitions and the bad
states using rst-order logic formulas. This modeling reveals
several subtle points that we discuss at length in Section 5.
Having formulated the set of CHCs, all that remains is to
solve it. However, since the solution we seek is quantied,
we cannot use o-the-shelf solvers. We, therefore, develop
a specialized approach targeted at nding simple universal
invariant . By universal we mean that the invariant is de-
nable by a formula with a prex of universal quantiers,
and by simple we mean that quantier-free body of the in-
variant does not use functions over the quantied variables.
For example, if iis a quantied variable, then i+ 1 is not
allowed in the body.
Our solution strategy is to (a) x the number of quan-
tiers expected in the invariant, (b) instantiate the quan-
tiers eagerly, and (c) use existing solvers for inference of
quantier-free safe inductive invariants to discover solutions
of the reduced CHC system. In the rest of this section, we
demonstrate this strategy on two special cases of one and
two quantiers. The general case is presented in Section 6.
One Quantier. When applying our search strategy for in-
339Init(i;i;v))I1(i;v)
I1(i;v)^Tr(i;v;v0))I1(i;v0) (1)
I1(i;v)^I1(j;v)^Tr(j;v;v0)^j6=i)I1(i;v0) (2)
I1(i;v)^I1(j;v)): Bad(i;j;v)
Figure 2: VC 1(T)for one-quantier invariants.
Init(i;j;v)^Init(j;i;v)^
Init(i;i;v)^Init(j;j;v))I2(i;j;v)
I2(i;j;v)^Tr(i;v;v0))I2(i;j;v0) (3)
I2(i;j;v)^Tr(j;v;v0))I2(i;j;v0) (4)
I2(i;j;v)^I2(i;k;v)^I2(j;k;v)^
Tr(k;v;v0)^k6=i^k6=j)I2(i;j;v0)(5)
I2(i;j;v)): Bad(i;j;v)
Figure 3: VC 2(T)for two-quantier invariants.
variants with one quantier, i.e., of the form 8i:I1(i;v), on a
systemT, we obtain the set of constraints VC 1(T) depicted
in Figure 2. VC 1(T) is based on a logical formulation of
Tthat uses quantied id variables in order to refer to arbi-
trary agents. Technically, the initial states are constraint via
a formula8i;j:Init(i;j;v) which allows the initial constraint
to refer to pairs of agents. The transition relation formula
has the form9i:Tr(i;v;v0), which reects the property that
some agent imoves in each step, and the bad states are
constraint by9i;j: Bad(i;j;v).
In systems with universally guarded commands, Tr(i;v;v0)
is itself a quantied formula. To complete the reduction to
a set of CHCs, we additionally instantiate the quantiers
inTr. The details are presented in Section 6, which also
addresses existentially guarded transitions.
VC 1(T) reduces the problem of nding a 1-quantier so-
lution of a set of linear CHC, to the problem of nding a
quantier-free solution of a set of non-linear CHC.
IfTrdoes not update any shared variable, as is the case
in the collision avoidance example, then (2) is unnecessary
and the set of CHCs is linear.
Relation to Owicki-Gries proof rule. VC 1(T) is a parametric
extension of the Owicki-Gries proof-rule for partial correct-
ness of concurrent programs [20]. In particular, (1) corre-
sponds to invariant preservation under a step of a process,
and (2) to preservation under an interference.
Two Quantiers. In practice, a one-quantier invariant is
useful only when Tritself does not contain any global tran-
sitions (i.e., transitions guarded by quantied guards). This
is not the case for the example in Figure 1, and VC 1(T) does
not have a solution.
We, therefore, extend our approach to two-quantier in-
variants of the form 8i;j:I 2(i;j;v). Figure 3 depicts the set
of constraints VC 2(T) obtained by our reduction. To sim-
plify the presentation, we again do not present additional in-
stantiations that result from universal or existential guards
inTr. These are explained in Section 6.
Similarly to VC 1, the clause (3) corresponds to local preser-
vation of the invariant, and the clauses (4) and (5) corre-spond to preservation under interference. As in VC 1(T), if
Trdoes not update any shared variables, as is the case in
the example in Figure 1, then (5) is removed and the system
VC 2(T) becomes linear.
VC 2(T) captures the common self-vs-other proof pattern
in verication of parameterized systems. That is, it can
express reasoning about arbitrary many processes that re-
duces to reasoning about the current process self and its
environment as abstracted by some other process. More
rened capturing of the environment is possible with ad-
ditional quantiers. Intuitively, each additional quantier
corresponds to exposing an additional process in the envi-
ronment. By solving VC 2(T), an inductive invariant with 2
universal quantiers is found for the example in Figure 1.
Completeness. While our approach is in general incomplete,
it is complete in interesting special cases. Specically, we
show that for parameterized systems that form monotonic
transition systems (such as Petri nets), iterating our ap-
proach with increasing number of quantiers is guaranteed
to terminate and nd an inductive invariant. This matches
known decidability results for such systems.
3. BACKGROUND
In this section, we give a brief overview of notation and
other key concepts used in the paper.
We writexfor a vector of elements hx1;:::;x mi,xifor
theith element of xandjxjfor the length of x. For a
formula'and a variable x, we write'(x) to denote that x
is free in'. Note that 'might have other free variables in
addition to x. For a term aofarray sort, we write a[i] for
theith element of a((select a i) in SMT-LIB syntax),
anda[i:=v] for an array obtained from aby replacing the
ith element by v((store a i v) in SMT-LIB syntax). For
a vectora=ha1;:::;a miofarray terms we write a[i] as a
shorthand for the vector ha1[i];:::;a m[i]i.
Constrained Horn Clauses. LetTbe a rst-order theory
over some signature including equality, and VandPbe
sets of variables and predicates, respectively. A Constrained
Horn Clause (CHC) is a formula:
8V(^p1(x1)^^pk(xk))h(x));fork0
whereis a (possibly quantied) constraint in T;xi;xV
are (possibly empty) vectors of variables; pi(xi) is an appli-
cationp(t1;:::;t n) of ann-ary predicate symbol p2P for
rst-order terms ti; andh(x) is either dened analogously
topior isP-free (i.e., noPsymbols occur in h).
his called the head of the clause and ^p1(x1)^^pk(xk)
is called the body. A clause is linear if its body contains at
most one predicate symbol, and non-linear otherwise. For
simplicity of presentation, we usually omit the outermost
universal quantier. Unless otherwise specied, we assume
that the theoryTis the standard SMT combination of the
theories of Linear Integer Arithmetic and Arrays.
A setCof CHCs is satisable modulo a theory T(with
a canonical model MT) if there exists an extension Jof
MTthat interprets all of the predicate symbols in Psuch
that each clause c2Cis true underJ. In this case, we
say thatJis asolution ofC. In practice, we are interested
inT-denable solutions. For simplicity of presentation, we
identify the solution with the FO formulas that dene the
interpretation of the predicate symbols in P(when exist).
For example, we say that the solution is p(x;y) =x > y ,
340hproci::=def proc (i) :dohgcmdsi
hgcmdsi::=hguardi:hcmdi guraded command
j hgcmdsijhgcmdsi nondeterministic choice
hguardi::='`(i;v) local guard
j 9j ./i:' g(i;j;v) existential global guard
j 8j ./i:' g(i;j;v) universal global guard
hcmdi::=`[i] :=expr assignmnet to local variable
jb:=expr assignment to shared variable
j hcmdi;hcmdi sequential composition
Figure 4: Syntax of a process: '`(i;v)denotes a for-
mula over Local (v)[i]andShared (v);'g(i;j;v)denotes
a formula over Local (v)[i],Shared (v), andLocal (v)[j];
`denotes a local variable, while bdenotes a shared
variable;expr denotes an expression over Shared (v)
andLocal (v)[i].
meaning that the solution is a FO model Jsuch thatJ(p) =
f(x;y)jx<yg.
Universal Horn Clauses (UHC) extend CHC by allowing
universal quantication over predicates from Pthat appear
in the body. Satisability and solution of UHC are dened
analogously to CHC.
4. SAFETY OF PARAMETERIZED SYSTEMS
In this section, we present our syntax, semantics, and the
safety verication problem of parameterized systems.
4.1 Syntax
We consider parameterized systems that consist of an ar-
bitrary number of copies of a given process Pwith a (global)
initial condition Initand a (global) error condition Bad.
Processes. A processPis dened by a set of variables vand
a set of guarded commands, with the meaning that these
guarded commands reside in a loop, where in each iteration
one of the commands whose guard evaluates to true is chosen
non-deterministically and is executed atomically. The pro-
cess is parameterized by an identier, denoted i. Figure 4
presents the syntax of a process (explained next).
Variables. As a generalization of several interaction modes
between copies of the process, we consider two classes of
variables in P: (i) local variables , denotedLocal (v), and
(ii)shared variables , denotedShared (v). Technically, all
copies ofPshare the same copy of the shared variables,
while each copy of Phas its own copy of each local variable.
Local variables are accessed via a process id, e.g., v[i] orv[j].
We allow processes to read (but not write) local variables
of other processes. Thus, the local variables can be further
sub-divided into process-private (not read by others) and
distributed-shared (written by one, read by others). How-
ever, this distinction is irrelevant for our purpose.
Each copy of Pinteracts with the other copies via shared
variables or global guards that examine the local variables of
other processes in a restricted manner, as explained below.
Universal and Existential Guards. Global guards are either
existential or universal, and do not explicitly refer to specic
process indices. We assume a static topology and a linear
order on the process indices, where a process can only distin-
guish between the processes with greater or smaller indices.
Formally, a global guard has the form Qj ./ i:' (i;j;v),
where Q2f9;8g,./2f<;>;6=g, and'(i;j;v) is a formulaoverLocal (v)[i],Shared (v), andLocal (v)[j]. IfQ=8, the
guard is called universal , and if Q=9, the guard is called
existential . The relation ./refers to the order between the
copies of the process induced by the linear topology. An
existential guard 9j ./ i:' is satised by the ith copy of
Pi there exists a copy jofPthat satises j ./ i and
whose local state together with the local state of isatises
'. Similarly, a universal guard 8j ./i:' is satised by the
ith copy ofPi the local state of each of the copies jofP
that satisfy j ./i satises'.
Other guards are called local. In particular, if-then-else
commands are written using local guards. Note that local
guards can refer to shared variables. We classify guarded
commands as local orglobal based on their guards.
Initial and Bad States. The description of a parameterized
system includes a description of the initial states, as well as
a description of the bad states:
def init(i;j) :'init(i;j;v)def bad(i;j) :'bad(i;j;v)
where'(i;j;v) is a formula over Shared (v),Local (v)[i] and
Local (v)[j]. Informally, the initial condition 'inithas to
hold for all pairs of processes in the initial state, while a bad
condition is satised if some pair of processes satisfy 'bad.
4.2 Asynchronous Operational Semantics
Each value n2Ndenes an instance of the parameterized
system which consists of ncopies ofP, which are linearly
ordered. We refer to each process via an index 0 i
n 1. The semantics of the instance is given by a transition
system, denoted Tn(P) (or simply TnwhenPis clear from
the context), dened as follows.
LetLdenote the set of local states, i.e., Lconsists of all
possible valuations of the local variables Local (v), and letG
denote the set of global states, which consists of all possible
valuations of shared variables Shared (v).
The states of Tnare given by congurations. A congu-
ration ofTnis a tuplec2LnGofnlocal states from L
and a global state in G. Indexnin the tuple, denoted c[n],
represents the global state, shared by all the processes, and
for 0in 1, theith index in the tuple c, denotedc[i],
represents the local state of the ith copy of P. We denote
the set of all congurations of TnbyCn, i.e.Cn=LnG.
The transitions of Tn, denoted TRn, correspond to the ex-
ecution of guarded commands by the individual processes.
Therefore, TRn=Sn 1
i=0TRi
n, where TRi
nCnCnis the
set of transitions of process i. Each transition of process i
corresponds to the execution of a guarded command. Tech-
nically, a guarded command induces the transition ( c;c0)2
TRi
nifcsatises the guard at i(as dened below), c0[i] and
c0[n] are updated based on the command, and c0[j] =c[j]
for everyj6=i. Satisfaction of local guards by process iis
dened as usual: csatises a local guard 'atiif (c[i];c[n])
satisfy'(wherec[i] is an interpretation for Local (v)[i] and
c[n] is an interpretation for Shared (v)).csatises a global
guard Qj ./i:' atiif
Q=8and for every 0 jn 1 s.t.j ./ i ,
(c[i];c[j];c[n]) satisfy', or
Q=9and there exists 0 jn 1 s.t.j ./ i and
(c[i];c[j];c[n]) satisfy',
wherec[i],c[j], andc[n] are interpretations of Local (v)[i],
Local (v)[j], andShared (v), respectively.
341We dene the set of initial congurations of Tn, denoted
CI
n, as the set of all congurations c2Cnsuch that (c[i],c[j],
c[n]) satisfy'initfor every 0i;jn 1, and similarly, we
dene the set of badcongurations, denoted CB
n, as the set
of all congurations c2Cnsuch that (c[i],c[j],c[n]) satisfy
'badfor some 0i;jn 1.
Parameterized Systems as Innite State Transition Systems.
The semantics of a parameterized system dened by Pis
the innite-state transition system T(P) = (C;TR), where
C=S
n1Cnis the set of congurations of all instances and
TR=S
n1TRnis the set of transitions of all instances. We
lift the denition of initial and bad states to T(P) similarly:
CI=S
n1CI
nandCB=S
n1CB
n. WhenPis clear from
the context, we simply write Tinstead ofT(P).
Safety. Traces in a transition system are dened in the usual
way, as sequences of states (congurations) where each two
consecutive states are connected by the transition relation.
A transition system (e.g., TnorT) issafeif there is no trace
from an initial state to a bad state. Tis safe if and only if
Tnis safe for every n1.
5. VERIFICATION CONDITIONS FOR PA-
RAMETERIZED SYSTEMS
In this section, we provide verication conditions for veri-
fying the safety of a parameterized system in the form of sets
of Constrained Horn Clauses (CHC), such that the verica-
tion condition is satisable i the system is safe. Further,
a solution of the CHCs provides a witness of safety in the
form of an inductive invariant.
We present two variants of the verication condition. One,
calledN-aware, explicitly encodes the number of processes
via a logical variable. Another, called N-oblivious, ignores
this number, and can be thought of as encoding a system
with innitely many processes.
In the following, we denote formulas used in the N-aware
formulation by F, and formulas used in the N-oblivious
formulation by F!. We write Fto denote either of them.
Logical Variables. Given a process P, to model the parame-
terized system using logical formulas, we introduce a logical
variable for every variable v2vand adopt the same nota-
tion for it. The variables that correspond to v2Local (v)
are of sort array , and the shared variables v2Shared (v)
inherit their sorts from the program. For the N-aware veri-
cation condition, we add to the set of variables a variable N
of sort integer that captures the (arbitrary) number of pro-
cesses. We denote by uthe set of variables which consists of
bothvandNin theN-aware formulation, and consists of v
only in the N-oblivious formulation. We introduce variables
(e.g.,i;j) of sort integer to refer to process identiers.
Arrays conveniently represent congurations of instances
of the parameterized system with any number of processes.
Transition Relation Formula. As usual, formulas represent-
ing transitions are dened over two copies of the variables,
where the rst (unprimed) copy refers to the state before
the transition and the second copy (primed) refers to the
\next" state obtained after the transition. We denote by v0
the copy of vused to describe the next-state variables. A
next-state copy of Nis not needed, since we consider static
topologies. Therefore, in the N-aware formulation, u0stands
for (v0;N).role formula
local transition 9i:'
lgrd(i;u)^Trcmd(i;v;v0)
universal transition 9i:8j:'
ugrd(i;j;u)^Trcmd(i;v;v0)
existential transition 9i:9j:'
egrd(i;j;u)^Trcmd(i;v;v0)
initial condition 8i:8j:Init(i;j;u)
error condition 9i:9j:Bad(i;j;u)
Figure 5: Quantied formulas representing tran-
sitions, initial states and bad states of parameter-
ized systems. Fstands for either F, representing
theN-aware formulation, in which case ustands for
(N;v), or forF!, representing the N-oblivious for-
mulation, in which case ustands for v.
notation denition
'
lgrd(i;u)range(i)^'`(i;v)
'
ugrd(i;j;u)range(i)^(range(j)^j ./i)'g(i;j;v))
'
egrd(i;j;u)range(i)^range(j)^j ./i^'g(i;j;v)
Init(i;j;u)range(i)^range(j))'init(i;j;v)
Bad(i;j;u)range(i)^range(j)^'bad(i;j;v)
Figure 6: Quantier-free formulas used in the log-
ical formulation of parameterized systems. In the
N-aware formulation, range(i),i2[0;N), while in
theN-oblivious formulation, range(i),>.
We associate every command cmd with a quantier-free
transition relation formula, denoted Trcmd(i;v;v0). The for-
mula Trcmd, dened over i;v;v0, captures the semantics of
the command when executed by process iwhile all other pro-
cesses are idle. That is, Trcmd(i;v;v0) encodes the values of
Local (v0)[i] andShared (v0) based on the update performed
bycmd, and implies that for every v2Local (v) and for
everyj6=i,v0[j] =v[j]. For example, for the command
next[i] :=desired [i];pc[i] := WAIT from Figure 1, Trcmdis
next0=next[i:=desired [i]]^pc0=pc[i:= WAIT]^
curr0=curr^desired0=desired
Note thatNdoes not appear in these formulas since com-
mands do not explicitly refer to N. Thus, these formulas are
the same both in the N-aware and in the N-oblivious case.
From the command formulas, a transition relation for-
mula is constructed for each guarded command of P, de-
scribing the eect of some process executing the guarded
command. The formulas for both the N-aware case and the
N-oblivious case are listed in Figure 5 and Figure 6. Formu-
las corresponding to local guarded commands have the form
9i:(i;u;u0), formulas corresponding to universal guarded
commands have the form 9i:8j:(i;j;u;u0), and formu-
las corresponding to existential guarded commands have the
form9i:9j:(i;j;u;u0), whereis quantier-free. The N-
aware, respectively N-oblivious, transition relation formula
of the parameterized system, denoted Tr(u;u0), is the dis-
junction of these formulas over all guarded commands of P.
Initial and Bad States Formulas. The initial and bad states
formulas are shown in Figures 5 to 6. They have the form
8i:8j:Init(i;j;u) and9i:9j:Bad(i;j;u), respectively, where
Init(i;j;u) and Bad(i;j;u) are quantier-free. Abusing
notation, we also refer to the quantied formulas above as
Init(u) and Bad(u), respectively.
342Note that the N-oblivious formulation corresponds to re-
moving the range constraints on id variables in Tr,Initand
Bad. For example, it does not require that i2[0;N) in the
denition of Trand that that j2[0;N) in the formulas for
global guards. Intuitively, the N-oblivious formulas encode
a transition system whose congurations consist of innite
sequences of local states. This can be thought of as letting
innitely many processes interact.
5.1 VeriÔ¨Åcation Conditions for Safety
LetTbe a parameterized transition system, and let u,
Init(u),Tr(u;v0),Bad(u) be dened as above, where 2
f;!ganduis dened accordingly.
Definition 5.1. For2f;!g, the verication condi-
tionVC(T)forTis dened via the following set of CHCs
over variables u;u0and over the predicate Inv (u).
Init(u))Inv(u)
Inv(u)^Tr(u;u0))Inv(u0)
Inv(u)): Bad(u)
TheN-aware verication condition, denoted VC(T), is ob-
tained when=anduis(v;N). TheN-oblivious veri-
cation condition, denoted VC!(T), is obtained when =!
andu=v. We omit Twhen it is clear from the context.
Note thatVCis dened over a set of variables which
includesN, while the set of variables of VC!excludesN.
By splitting the disjunction in Tr(u;u0) into multiple
clauses and pulling out quantiers when possible, the veri-
cation condition VC(T) can be equivalently rewritten into
the set of UHCs depicted in Figure 7 (note that Initand
'
ugrd might contain universal quantiers).
The following lemma shows that VCcaptures the safety
of the parameterized transition system.
Lemma 5.1.VC(T)is satisable i Tis safe.
It is tempting to claim (and is often implicitly assumed in
other works) that VC!(T) issatiTis safe. Unfortunately,
this is incorrect, as demonstrated by the following examples.
Example 1 (Unsoundness). Consider the process P
from Figure 8. Initially, all copies of the process are in lo-
cationI(\initial"). From location Ithe process makes an
unconditional move to location T(\trying"). If all other pro-
cesses are in T, the process moves to E(\error"). The bad
states are a process in an error location. Clearly, the system
is unsafe for any number of processes. However, VC!is
sat. A satisfying interpretation for Inv includes all innite
congurations where a nite prex consists of IandTloca-
tions, while the innite sux (which is of course nonempty)
consists ofIlocations, thus blocking the universal transition
that leads to error. As a side note, we point out that in
this example no interpretation for Inv that satises VC!is
expressible by a universally quantied formula.
Example 2 (Unsoundness). Consider the process from
Figure 9. The process has a Boolean variable b. Initially,
each copy of the process nondeterministically selects a Boolean
value forb. If all processes have completed their selection
and in addition8i;j:i6=j)b[i]6=b[j], then process i
can move to an \error" location. If two processes reach an\error" location, a bad state is encountered. Clearly, Tis
unsafe since T2is unsafe (whereas Tnfor everyN > 2is
safe). However, VC!issat. Specically, the solution is:
Inv= (8i;j:i6=j)(pc[i]6=E_pc[j]6=E))^
(8i:pc[i]6=I)b[i]2[0;1])^
(8i;j:(pc[i] =E^i6=j))(pc[j]6=I^b[i]6=b[j])):
These examples show that in the general case, the N-
aware andN-oblivious variants of the verication conditions
do not coincide. Specically, the N-oblivious formulation
might be satisable even though the system is not safe.
One way to x the unsoundness is to restrict the system.
Definition 5.2 (Weak Monotonicity). We say that
Tisweakly monotonic if there exists a quantier free for-
mula (i;Local (v))such that (8i:'init(i;j;v))j= (j;Local (v)),
and for every formula 'g(i;j;v)that appears in a global uni-
versal guard,  (j;Local (v))j='g(i;j;v).
Intuitively, Tis weakly monotonic if no universal guard can
be blocked by a process in an initial state (as witnessed by
the formula  (j;Local (v))). For example, if processes have
an initial location, then  (i;Local (v)) can state that process
iis in its initial location.
Weak monotonicity ensures that adding additional pro-
cesses which remain in their initial state does not disable
any global universal transition. In particular, if there are
no universal guards, then Tis weakly monotonic. Note that
the classical notion of monotonicity [1, 12] is stronger as it
would require that adding additional processes in any lo-
cal state would not disable any global universal transition,
which essentially forbids universal guards altogether.
Lemma 5.2. IfTis weakly monotonic, then VC!(T)is
satisable i Tis safe.
Proof. ()): Consider a solution (model) JforVC!(T).
We need to show that Tis safe. Assume to the contrary that
it is unsafe. Then there exists n2Nsuch that there exists
an error trace in Tn. We construct a corresponding trace
over innite congurations, where each innite congura-
tion in the trace agrees with the corresponding nite one on
the prex of the conguration of length n, and the sux
of the innite conguration corresponds to processes that
have not moved since their initialization. The existence of
such a trace contradicts the fact that JsatisesVC!(T).
We construct the corresponding trace inductively. The rst
conguration consists of an arbitrary extension of the initial
conguration that satises the initial condition. To extend
the trace we consider the guarded command that is being
executed. If it is a local or an existential command, then the
same command is enabled also in the innite conguration.
If it is a universal command, then weak monotonicity ensures
that it is also enabled in the innite conguration where the
additional processes remained in their initial state.
((): Suppose Tis safe. To show that VC!issatit
suces to show that the system dened over innite con-
gurations is safe. Assume to the contrary that it is not.
Then there is a (nite) error trace which consists of innite
congurations. We use it to construct an error trace for Tn
for somen2N, in contradiction. To dene the value nfor
whichTnis unsafe, we consider all the indices of processes
that move along the trace, as well as the indices of all the
witnesses to existential guarded commands. We dene nto
343Init(u))Inv(u)
Inv(u)^'
lgrd(i;u)^Trcmd(i;v;v0))Inv(v0) for every local guraded command
Inv(u)^(8j:'
ugrd(i;j;u))^Trcmd(i;v;v0))Inv(v0) for every universal guarded command
Inv(u)^'
egrd(i;j;u)^Trcmd(i;v;v0))Inv(v0) for every existential guarded command
Inv(u)): Bad(u)
Figure 7: Verication condition for safety of a parameterized system.
def proc(i):
do
pc[i] =I:pc[i] :=T;
8j6=i:pc[j] =T:pc[i] :=E
def init(i;j):pc[i] =I;
def bad(i;j):pc[i] =E;
Figure 8: Parameterized system demonstrating un-
soundness of VC!.
def proc(i):
do
pc[i] =I:pc[i] :=D;b[i] := 1 ;
pc[i] =I:pc[i] :=D;b[i] := 0 ;
(8j6=i:pc[i] =D^pc[j]6=I^b[j]6=
b[i]) :pc[i] :=E;
def init(i;j):pc[i] =I;
def bad(i;j):i6=j^pc[i] =E^pc[j] =E;
Figure 9: Parameterized system demonstrating un-
soundness of VC!.
be the maximum over all these indices. With this choice of
n, we can now consider the trace which consists of the in-
nite congurations truncated to congurations of length n.
This is a legal trace of Tn, as every local and universal guard
that was enabled in the innite conguration is clearly en-
abled in its sub-conguration, and every existential guard
that was enabled is still enabled since the witness process is
also present in the conguration.
Corollary 5.1. Under the weak monotonicity condition,
VC(T)is satisable if and only if VC!(T)is satisable.
Note that the systems described in Example 1, Example 2,
and Figure 1 are notweakly monotonic.
6. INFERRING UNIVERSAL INV ARIANTS
In this section, we present an approach for determining
whether the verication condition VC(T) has a model de-
nable by a universally quantied FO-formula (or, equiva-
lently, whether there is a safe inductive universally quan-
tied invariant for T). More precisely, we consider models
denable by simple universally quantied formulas:
Definition 6.1. A formula'(u)is asimplek-universal
formula if'(u)8i1;:::;i k:'QF(i1;:::;i k;u), where'QF
is a quantier-free formula such that the variables i1;:::;i k
are not used as arguments of functions in 'QF.
Our strategy for determining the existence of a simple
universal invariant is to (a) x the number of quantiersexpected in the invariant, (b) instantiate the quantiers ea-
gerly, and (c) use existing solvers for inference of quantier-
free safe inductive invariants to discover models of the re-
duced system. The two special cases of one and two-quantiers
were already discussed in Section 2. We now present the
general case, prove its soundness and investigate its com-
pleteness.
Letk1 be the number of universal quantiers in the
(simple) universal invariant we seek. That is, we consider
solutions where Inv(u) is of the form
Inv(u) =8i1;:::;i k:Invk(i1;:::;i k;u):
To reduce the search for a quantied solution to a search
for a quantier-free one, we dene an operator Uk, parame-
terized by a number k, that takes a UHC system VC(e.g.,
VC =VCorVC =VC!) and returns a CHC system
Uk(VC) such that Uk(VC) has a quantier free solution i
VChas a simple k-universal solution. Ukperforms three
transformations: restriction ,case splitting , and instantia-
tion, which are described next.
We describe each transformation on each individual clause
ofVC separately. We show the case of the consecution
clauses only. The initiation and safety clauses are handled
similarly (when applicable). Let gcmd be a guarded com-
mand with the corresponding consecution clause
Inv(u)^gcmd(i;:::))Inv(u) (6)
wheregcmd is dened as '
lgrd(i;u)^Trcmd(i;v;v0),8j:
'
ugrd(i;j;u)^Trcmd(i;v;v0),'
egrd(i;j;u)^Trcmd(i;v;v0),
whenevergmcd is local, universal, or existential, respectively
(see Figure 7).
Restriction. The rst transformation replaces the predicate
Invby a predicate Invkthat is universally quantied with
kquantiers. Formally, the result of the restriction trans-
formation of (6) is
(8i1;:::;i k:Invk(i1;:::;i k;u))^gcmd(i;:::))
Invk(i1;:::;i k;u) (7)
Clearly, (7) has a quantier-free-denable model i (6) has
a model denable using kuniversal quantiers.
Case Splitting. Recall that in the formula gcmd(i;:::), the
next-state variables v0are indexed only by i(whereas, in
a global guard, the current-state vvariables might also be
indexed by another variable). Intuitively, this captures that
local variables of a process are changed only by its own
moves. The case-splitting transformation splits the conse-
cution premise (7) for gcmd intok+ 1 premises. Intuitively,
each new premise represents a dierent process making a
transition and changing its state. The rst kpremises con-
sider the steps of the processes that the invariant refers to
344(hence, they can change local and shared variables), while
thek+1 premise considers an interference from another dif-
ferent interfering process. Note that the interfering process
can only aect the shared variables.
Formally, case-splitting transforms the clause (7) into k
clauses, for 1jk:
(8i1;:::;i k:Invk(i1;:::;i k;u))^gcmd(ij;:::))
Invk(i1;:::;i k;u0) (8)
Additionally, if gcmd might update a shared variable, case-
splitting adds the ( k+ 1)st interference clause:
(8i1;:::;i k:Invk(i1;:::;i k;u))^
gcmd(ik+1;:::)^^
1jkij6=ik+1)
Invk(i1;:::;i k;u0) (9)
The case-split VChas a quantier-free solution i the re-
strictedVChas a quantier-free solution. This follows from
the logical equivalence between the two sets of CHCs. In
particular, whenever gcmd does not update any shared vari-
ables, the interference clause (9) is unnecessary. Intuitively,
this means that gcmd can cause no interference when exe-
cuted by some other process.
Case-splitting is motivated by obtaining clauses with fewer
free variables. This is benecial for the instantiation step
performed next, since the set of possible instantiations de-
pends on the free variables.
Instantiation. The restriction and case-splitting transforma-
tions result in a VCthat contains universal quantiers in
the body. The instantiation transformation applies a nite
eager instantiation to the remaining universal quantiers.
The result is a quantier-free CHC VCthat can be solved
by existing CHC solvers.
We begin with the following denitions:
Definition 6.2 (Instantiation Elements). Given a
clausec, the set of instantiation elements forc, denoted
C(c), is the smallest set Xthat contains (i) the variables
i1;:::;i kwhenver Inv k(i1;:::;i k;u)is the head of c, (ii) ev-
ery termxthat appears as index to some array logical vari-
able corresponding to a local program variable in c, and (iii) ev-
ery termysuch thaty./x (orx./y ) is incforx2X.
Intuitively, C(c) includes all variables that are used to index
an array or compared with a variable already in C(c). Note
that in the N-aware formulation, 0 and Nare inC(c).
Definition 6.3 (Full Instantiations). Letk2Nand
letCbe a nite set of instantiation elements. We dene -
nite instantiations FI(k;C) =Ckto be the set of all k-tuples
constructed from C.
Note thatFI(k;C) also contains tuples in which the same
term appears multiple times.
Definition 6.4 (Reduced Instantiations). Letk2
N,Cbe a nite set of instantiation elements, and be an
arbitrary total order on terms. We dene reduced instantia-
tionsRI(k;C) =fhy1;:::;y ki2Ckj8i;j:i<j)yiyjg
to be the set of all strictly -increasing k-tuples constructed
fromC.Note that the denition of RI(k;C) is parameterized by the
choice of the term order . For example, if C=fx;ygand
xy, thenRI(2;C) =f(x;y)g.
The instantiations transformation is applied on each clause
cof the VC that contains universal quantiers. All occur-
rences of (8i1;:::;i k:Invk(i1;:::;i k;u)) are replaced by
(V
i2RI(k;C(c))Invk(i;u)); and all other universally quanti-
ed formulas8i:'(i;u) are replaced by their complete in-
stantiations (V
i2FI(jij;C(c))'(i;u). The latter include (a) the
transition relation formulas for universal guarded commands,
where only one variable is instantiated (and therefore the
full instantiations are the same as the reduced ones), and
(b) the initial states formula, where pairs of variables are
instantiated.
Example 3.Consider the consecution clause (8)obtained
fromVC!after case splitting. If the clause corresponds to a
universal guarded command, we obtain from it the following
clause inUk(VC!):
Invk(i1;:::;i k;v)^^
1hkTrugcmd (ij;ih;v;v0))
Invk(i1;:::;i k;v0)
where Tr ugcmd (ij;ih;v;v0) = (ih./ ij)'g(ij;ih;v))^
Trcmd(ij;v;v0). Here, reduced instantiations are used for
Invk, resulting in one instantiation, and full instantiations
are used for the transition relation formula (in fact the in-
stantiation where ih=ijcan be removed since it simplies
totrue due to the structure of Tr ugcmd (ih;ij;v;v0)). Note
that the obtained clause is linear .
From a consecution clause that corresponds to an existen-
tial command, we obtain the following clause in Uk(VC!):
^
i2RI(k;C(c))Invk(i;v)^Tregcmd (ij;x;v;v0))Invk(i1;:::;i k;v0)
whereC(c) =fi1;:::;i k;xg, hence there are k+ 1 instan-
tiations inRI(k;C(c)), and Tr egcmd (ij;x;v;v0) =x./i j^
'g(ij;x;v)^Trcmd(ij;v;v0). In this case, the obtained clause
isnon-linear .
Lemma 6.1. The fully and reduced instantiated VCs are
equi-satisable.
Proof. Since the reduced instantiations are a subset of
the full instantiations, one direction follows trivially.
For the other direction, consider a quantier-free solu-
tionM(x;u) for Invkof the fully instantiated VC with
x=hx1;:::;x ki. To transform Minto a solution Hof
the reduced instantiated VC, we dene
Y=fy=hy1;:::;y kij81ik:91jk:yi=xjg
andH(x;u) =V
y2YM(y;u). That is, Yis the set of all
k-tuples constructed from x1;:::;x k(including tuples that
have repetitions, i.e., yi=yj), andHis the reexive sym-
metric closure of M. We have that (V
x2RI(k;C)H(x;u))
(V
x2FI(k;C)M(x;u)).
Each conjunct of H(x;u) corresponds to M(y;u) fory2
Y, whose permutations are all part ofV
x2FI(k;C)M(x;u).
Therefore, each premise with the head M(y;u) and body
(V
x2RI(k;C)H(x;u))^gcmd(i;:::) follows by a proper re-
naming of the variables in y. Hence,His a solution of the
reduced instantiated VC.
345If the instantiated VChas a quantier-free solution, then
the original VChas ak-universal solution. However, the
opposite direction is not true in general.
The reduced instantiations of Invkreduce an exponen-
tial number of instantiations, jC(c)jk=jFI(k;C(c)j, to jC(c)j
k
=jRI(k;C(c)j. In the typical case, jC(c)j k=O(1)
which makes the number of reduced instantiations jC(c)jO(1).
For example, if C(c) =fi1;:::;i kg, then the number of in-
stantiations is just 1, resulting in linear constraints. This is
the case for all the clauses that correspond to local guarded
commands and for all the clauses that correspond to univer-
sal guarded commands in VC!, except for the interference
clauses. The interference clauses have an additional instan-
tiation element, resulting in k+ 1 instantiations. Clauses
corresponding to existential guarded commands also have
additional instantiation elements.
Example 4.Having presented the general reduction for
k-universal invariants, we now revisit the special cases of
one-quantier and two-quantier invariants that were pre-
sented in Section 2. The sets of constraints displayed in Fig-
ure 2 and Figure 3 correspond to U1(VC!)andU2(VC!)
respectively, for the case where all transitions in Thave lo-
cal guards (but may update shared variables). Universal and
existential guards would be handled by U(VC!)as demon-
strated in Example 3. For example, for a universal guarded
command, the constraint (3)in Figure 3 would become
Inv 2(i;j;v)^Tr(i;j;v;v0))Inv 2(i;j;v0):
For an existential command, constraint (3)would become
Inv 2(i;j;v)^Inv 2(j;k;v)^Inv 2(i;k;v)^
Tr(i;k;v;v0))Inv 2(i;j;v0):
In the rest of the section, we establish the soundness and
relative completeness of the transformation Uk(VC).
Soundness. The soundness of the transformation Uk(VC)
follows directly from the soundness of each of the steps. This
claim is robust | it applies both to the N-awareVCas
well as to the N-obliviousVC!.
Lemma 6.2. LetVC be one ofVCorVC!. IfUk(VC)
has a quantier-free solution, then VC has a solution with
kuniversal quantiers.
The proof of Lemma 6.2 is straightforward: If H(i;u) is a
solution of Uk(VC), then8i:H(i;u) is a solution for VC.
In the rest of this section, we show one of our main results
| under the transformation Uk,N-obliviousVC!soundly
approximates N-awareVC. Thus, in many cases a simpler
formulation VC!(i.e., fewer instantiations) is sucient.
Lemma 6.3. IfUk(VC!)has a quantier-free solution,
thenUk(VC)has a quantier-free solution.
Proof. The proof is constructive. Given a quantier-free
solutionH(i1;:::;i k;v) for Invk(i1;:::;i k;v) inUk(VC!),
we construct a quantier-free solution S(i1;:::;i k;N;v) for
Invk(i1;:::;i k;N;v) inUk(VC).Sis dened as follows:
S= (k^
j=1ij2[0;N)))H:
That is, each identier variable ij(1jk) is restricted
to the legal range of process identiers.To show that Sis a solution to Uk(VC), we need to
show that it satises all clauses. We prove the claim for the
consecution premises (the proof of the other clauses is sim-
ilar). Consider a consecution premise cinUk(VC) with
head Invk(i1;:::;i k;N;v) and letbe an assignment that
satises the body. If the value of at least one of i1;:::;i k
inis not in the range [0 ;N), thensatisescvacuously.
Assume all index variables are in range, and let c0be the cor-
responding premise from Uk(VC!). We consider two cases:
(a)ccorresponds to a local or existential guarded command.
Then any additional range constraints in its body are con-
joined with the body. Since the body is satised by , they
all hold. Therefore, under ,csimplies to c0and the claim
follows; (b) ccorresponds to a universal guarded command
(this is the interesting case that was the source of unsound-
ness before). Here, the body of calso contains conjuncts of
the form (j2[0;N)^j ./i)'g(i;j;v)), where the range
conditions are antecedents in implications. However, since
in each such implication jis an instantiation element (see
Denition 6.2), its range condition also appears as a con-
junct in the body, and by our assumption that the body is
satised by , so does the range condition. (Further, the in-
stantiations where jis 0 orNdo not exist in c0). Therefore,
under, again,csimplies to c0and the claim follows.
Lemma 6.3 implies the following corollary that establishes
thatVC!approximates VCunder theUktransformation.
Corollary 6.1. IfUk(VC!)has a quantier-free solu-
tion, thenVChas ak-universally quantied solution.
This allows us to verify the example in Figure 1 with VC!,
even though it is not weakly monotonic.
Relative completeness. While the soundness of our approach
does not rely on the restriction to simple universal invari-
ants, completeness does.
Lemma 6.4. IfVChas ak-universal simple solution,
thenUk(VC)has a quantier-free solution.
The proof of this lemma follows from the fact that the
syntax of processes ensures that Init,Trand Bad do not
use identier variables as arguments to functions. This and
the restriction to simple invariants is sucient to guarantee
that our set of instantiations is complete.
7. SAFETY VERIFICATION
Safety verication of parameterized systems is in general
undecidable. In this section, we extend the technique of Sec-
tion 6 to a semi-algorithm for the problem (i.e., our proce-
dure might not terminate). We show that for certain classes
of systems (e.g., Petri nets), our procedure is in fact a deci-
sion procedure.
Our procedure is shown in Algorithm 1. It combines a
search for a simple k-universal safe inductive invariant with
a search for a counterexample in a k-process instance of the
system. Initially, kis 1 and it is increased in each itera-
tion. The search for a simple k-universal invariant is done
as described in Section 6 based on VC!. The search for a
counterexample is done by an o-the-shelf model checker.
In practice, we use CHC solver for both steps.
Termination. Algorithm 1 might not terminate due to sev-
eral reasons. First, solving the CHCs generated by Ukmight
346k:= 1 ;
while truedo
Invk(i1;:::;i k;v) := Solve(Uk(VC!(T))) ;
ifInvk(i1;:::;i k;v)6=nullthen
return \inductive invariant found:
8i1;:::;i k:Inv (i1;:::;i k;v)"
res:= ModelCheck( Tk) ;
ifres=cexthen
return \counterexample found for kprocesses"
k:=k+ 1
Algorithm 1: Procedure for safety verication of param-
eterized systems.
be undecidable. Second, even safety verication of a single
instance of the system might be undecidable. These issues
are alleviated if we restrict ourselves to nite state processes.
However, even if both inner steps of Algorithm 1 are de-
cidable, the procedure might not terminate. The reason is
that it is possible that a parameterized system is safe (i.e., no
counterexample exists in any instance), but it has no simple
universal invariant. In this case, both searches performed
by Algorithm 1 diverge. Fortunately, there are classes of
systems for which this phenomenon is impossible. In such
cases, we obtain a decision procedure for safety verication.
An example of such a class of systems is when the param-
eterized system forms a monotonic transition system with
respect to the subsequence ordering over congurations [1].
In particular, parameterized systems with local and exis-
tential transitions (but no universal transitions) meet the
monotonicity condition [2]. An important subclass of such
systems is Petri nets.
8. IMPLEMENTATION AND EV ALUATION
We have implemented a prototype of our technique in
Python. The input is a description of a parametric sys-
tem as a collection of guarded commands. The output is
an inductive invariant or a counterexample. Our input lan-
guage is similar to the input language of Cubicle [9] and
is more liberal than the syntax of Figure 4 used for the for-
mal presentation in the paper. Given a parametric system,
our implementation computes a verication condition as a
set of UHCs, reduces it to CHCs using the transformations
described in Section 6, and solves them using Spacer [19].
We have experimented with several small but challeng-
ing protocols including the collision avoidance protocol from
Figure 1, dining philosophers, and several variants of Lam-
port's bakery mutual exclusion algorithm. In all these cases,
we were able to successfully compute a 2-universal inductive
invariant in a few seconds. Further work is necessary to tune
our implementation for more challenging benchmarks.
9. RELATED WORK
There is a large body of work on verication of concurrent,
distributed, and parameterized systems. We refer the reader
to [5] for a recent survey. Below, we compare our approach
only with the most closely related work.
Our technique can be seen as an adaptation of the view
abstraction of Abdulla et al. [2] (and, in this, similar to dy-
namic cut-o of Kroening et al. [17], invisible invariants of
Zuck et al. [21], and environment abstraction of Clarke et
al. [8]). When our procedure converges, the constructed in-
variant is a view abstraction of the original system, wherethe size of the view is determined by the number of quanti-
ers. However, the details of the technique are very dif-
ferent. In particular, our approach naturally extends to
innite-state processes, such as processes with integer local
and shared variables without the need for a separate nite-
state abstraction. While such variables might not appear
directly in the protocol, they are convenient for verication
purposes. For example, it is common to abstract the num-
ber of processes in a particular state by an integer counter,
which introduces a shared integer variable in the model.
Our reduction from universal Horn clauses to CHC is in-
spired by the eager quantier instantiation of Bjrner et
al. [4]. Our key insight is in the use of problem-specic
restrictions to dramatically reduce the number of the neces-
sary instantiations, while maintaining completeness. In par-
ticular, we require exponentially fewer instantiations than [4].
In that, our formulation is similar to that of Hojjat et al. [16].
In the paper, we reduce verication of parameterized sys-
tems to CHC satisability and leave the choice of the CHC
solver open. In the evaluation, the resulting CHCs are solved
by a CHC solver Spacer [19, 18]. This combination is sim-
ilar to the MCMT [14] approach, and, in particular, to the
Barb algorithm [10] of Cubicle [9]. The key similarities
and dierences are highlighted below. Spacer is a CHC
solver based on the generalization of the IC3 model checking
algorithm [6]. Similar to Barb , it combines abstract back-
ward and concrete forward reachability computations. Un-
likeBarb , the backward reachability is under-approximated
using Model Based Projection [19] and is generalized using
interpolation and over-approximation of forward reachable
states [3, 15]. This makes our algorithm less susceptible to
the syntactic description of the model under analysis. For
example, generalizations are not restricted to the predicates
that are obtained by quantier elimination in the compu-
tation of backward reachability. As an added bonus, when
the problem is safe, Spacer always produces an easy-to-
validate certicate. On the other hand, Cubicle requires
a non-trivial certicate generation procedure [11]. So far,
we have used Spacer as a black-box. We leave exploring
the many possible optimizations of the Spacer algorithm
for this domain for future work.
10. CONCLUSION
In this paper, we present an SMT-based approach for ver-
ifying parameterized systems { systems consisting of asyn-
chronous composition of Nidentical processes. We show
that a verication condition of a parameterized system is
captured by a rst-order formula as a conjunction of con-
strained Horn clauses with constraints in the combined the-
ory of Linear Integer Arithmetic and (quantied) theory of
Arrays. Since satisability of such CHCs is undecidable,
we develop a technique for inferring universally quantied
solutions. Our approach yields a novel procedure for au-
tomated verication of parameterized system using existing
SMT-based CHC solvers such as Spacer [19]. Interestingly,
the constraints, that we derive systematically, match and
extend the well-known Owicki-Gries proof rules to the pa-
rameterized setting. While the paper is focused on asyn-
chronous composition of identical process, the main ideas
extend to process groups and to synchronous composition.
34711. REFERENCES
[1] P. A. Abdulla, K. Cerans, B. Jonsson, and Y. Tsay.
General decidability theorems for innite-state
systems. In Proceedings, 11th Annual IEEE
Symposium on Logic in Computer Science, New
Brunswick, New Jersey, USA, July 27-30, 1996 , pages
313{321, 1996.
[2] P. A. Abdulla, F. Haziza, and L. Hol k. All for the
price of few. In Verication, Model Checking, and
Abstract Interpretation, 14th International
Conference, VMCAI 2013, Rome, Italy, January
20-22, 2013. Proceedings , pages 476{495, 2013.
[3] N. Bjrner and A. Gurnkel. Property directed
polyhedral abstraction. In Verication, Model
Checking, and Abstract Interpretation - 16th
International Conference, VMCAI 2015, Mumbai,
India, January 12-14, 2015. Proceedings , pages
263{281, 2015.
[4] N. Bjrner, K. L. McMillan, and A. Rybalchenko. On
Solving Universally Quantied Horn Clauses. In Static
Analysis - 20th International Symposium, SAS 2013,
Seattle, WA, USA, June 20-22, 2013. Proceedings ,
pages 105{125, 2013.
[5] R. Bloem, S. Jacobs, A. Khalimov, I. Konnov,
S. Rubin, H. Veith, and J. Widder. Decidability of
Parameterized Verication . Synthesis Lectures on
Distributed Computing Theory. Morgan & Claypool
Publishers, 2015.
[6] A. R. Bradley. SAT-Based Model Checking without
Unrolling. In Verication, Model Checking, and
Abstract Interpretation - 12th International
Conference, VMCAI 2011, Austin, TX, USA, January
23-25, 2011. Proceedings , pages 70{87, 2011.
[7] S. Chaki and J. R. Edmondson. Model-Driven
Verifying Compilation of Synchronous Distributed
Applications. In Model-Driven Engineering Languages
and Systems - 17th International Conference,
MODELS 2014, Valencia, Spain, September 28 -
October 3, 2014. Proceedings , pages 201{217, 2014.
[8] E. M. Clarke, M. Talupur, and H. Veith. Environment
Abstraction for Parameterized Verication. In
Verication, Model Checking, and Abstract
Interpretation, 7th International Conference, VMCAI
2006, Charleston, SC, USA, January 8-10, 2006,
Proceedings , pages 126{141, 2006.
[9] S. Conchon, A. Goel, S. Krstic, A. Mebsout, and
F. Za di. Cubicle: A Parallel SMT-Based Model
Checker for Parameterized Systems - Tool Paper. In
Computer Aided Verication - 24th International
Conference, CAV 2012, Berkeley, CA, USA, July
7-13, 2012 Proceedings , pages 718{724, 2012.
[10] S. Conchon, A. Goel, S. Krstic, A. Mebsout, and
F. Za di. Invariants for nite instances and beyond. In
Formal Methods in Computer-Aided Design, FMCAD
2013, Portland, OR, USA, October 20-23, 2013 , pages61{68, 2013.
[11] S. Conchon, A. Mebsout, and F. Za di. Certicates for
parameterized model checking. In FM 2015: Formal
Methods - 20th International Symposium, Oslo,
Norway, June 24-26, 2015, Proceedings , pages
126{142, 2015.
[12] A. Finkel and P. Schnoebelen. Well-structured
transition systems everywhere! Theor. Comput. Sci. ,
256(1-2):63{92, 2001.
[13] R. W. Floyd. Assigning meanings to programs. In
Proceedings of Symposium on Applied Mathematics ,
number 32, 1967.
[14] S. Ghilardi and S. Ranise. MCMT: A model checker
modulo theories. In Automated Reasoning, 5th
International Joint Conference, IJCAR 2010,
Edinburgh, UK, July 16-19, 2010. Proceedings , pages
22{29, 2010.
[15] K. Hoder and N. Bjrner. Generalized property
directed reachability. In Theory and Applications of
Satisability Testing - SAT 2012 - 15th International
Conference, Trento, Italy, June 17-20, 2012.
Proceedings , pages 157{171, 2012.
[16] H. Hojjat, P. R ummer, P. Subotic, and W. Yi. Horn
Clauses for Communicating Timed Systems. In
Proceedings First Workshop on Horn Clauses for
Verication and Synthesis, HCVS 2014, Vienna,
Austria, 17 July 2014. , pages 39{52, 2014.
[17] A. Kaiser, D. Kroening, and T. Wahl. Dynamic cuto
detection in parameterized concurrent programs. In
Computer Aided Verication, 22nd International
Conference, CAV 2010, Edinburgh, UK, July 15-19,
2010. Proceedings , pages 645{659, 2010.
[18] A. Komuravelli, N. Bjrner, A. Gurnkel, and K. L.
McMillan. Compositional Verication of Procedural
Programs using Horn Clauses over Integers and
Arrays. In Formal Methods in Computer-Aided
Design, FMCAD 2015, Austin, Texas, USA,
September 27-30, 2015. , pages 89{96, 2015.
[19] A. Komuravelli, A. Gurnkel, and S. Chaki.
SMT-Based Model Checking for Recursive Programs.
InComputer Aided Verication - 26th International
Conference, CAV 2014, Held as Part of the Vienna
Summer of Logic, VSL 2014, Vienna, Austria, July
18-22, 2014. Proceedings , pages 17{34, 2014.
[20] S. Owicki and D. Gries. Verifying properties of parallel
programs: An axiomatic approach. Commun. ACM ,
19(5):279{285, May 1976.
[21] A. Pnueli, S. Ruah, and L. D. Zuck. Automatic
deductive verication with invisible invariants. In
Tools and Algorithms for the Construction and
Analysis of Systems, 7th International Conference,
TACAS 2001 Held as Part of the Joint European
Conferences on Theory and Practice of Software,
ETAPS 2001 Genova, Italy, April 2-6, 2001,
Proceedings , pages 82{97, 2001.
348