Locking discipline inference and checking
Michael D. ErnstAlberto Lovato‚Ä†Damiano Macedonio‚Ä°Fausto Spoto‚Ä†;‚Ä°Javier Thaine
University of Washington, USA‚Ä†Universit√† di Verona, Italy‚Ä°Julia Srl, Italy
mernst@cs.washington.edu, alberto.lovato@univr.it, damiano.macedonio@juliasoft.com,
fausto.spoto@univr.it, jthaine@cs.washington.edu
Abstract
Concurrency is a requirement for much modern software, but the
implementation of multithreaded algorithms comes at the risk of
errors such as data races. Programmers can prevent data races
by documenting and obeying a locking discipline, which indicates
which locks must be held in order to access which data.
This paper introduces a formal semantics for locking speciÔ¨Åca-
tions that gives a guarantee of race freedom. A notable difference
from most other semantics is that it is in terms of values (which
is what the runtime system locks) rather than variables. The paper
also shows how to express the formal semantics in two different
styles of analysis: abstract interpretation and type theory. We have
implemented both analyses, in tools that operate on Java. To the
best of our knowledge, these are the Ô¨Årst tools that can soundly infer
and check a locking discipline for Java. Our experiments compare
the implementations with one another and with annotations written
by programmers, showing that the ambiguities and unsoundness of
previous formulations are a problem in practice.
1. Introduction
Concurrency allows computations to occur inside autonomous
threads, which are distinct processes that share the same heap mem-
ory. Threads increase program performance by scheduling parallel
independent tasks on multicore hardware and enable responsive
user interfaces [23]. However, concurrency might induce problems
such as data races (concurrent access to shared data), with conse-
quent unpredictable or erroneous software behavior. Such errors
are difÔ¨Åcult to understand, diagnose, and reproduce at run time.
They are also difÔ¨Åcult to prevent: testing tends to be incomplete due
to nondeterministic scheduling choices made by the runtime, and
model-checking scales poorly to real-world code.
The standard approach to prevent data races is to follow a lock-
ing discipline while accessing shared data: always hold a given
lock when accessing a given shared datum. It is all too easy for
a programmer to violate the locking discipline. Therefore, tools
are desirable for formally expressing the locking discipline and for
verifying adherence to it [10, 33].
The book Java Concurrency in Practice [22] (JCIP) proposed the
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission
and/or a fee. Request permissions from permissions@acm.org.
ICSE ‚Äô16, May 14 - 22, 2016, Austin, TX, USA
c2016 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ISBN 978-1-4503-3900-1/16/05. . . $15.00
DOI: http://dx.doi.org/10.1145/2884781.2884882syntax @GuardedBy to express a locking discipline and ensure thread-
safety. The intention is that when a locking discipline is expressed
with @GuardedBy , then ‚ÄúNo set of operations performed sequentially
or concurrently on instances of a thread-safe class can cause an
instance to be in an invalid state‚Äù; a thread-safe class is one that
‚Äúuse[s] synchronization whenever accessing the [shared, mutable]
state‚Äù. This annotation has been widely adopted; for example,
GitHub contains about 35,000 uses of the annotation in 7,000 Ô¨Åles
(https://github.com/search?l=java&q=GuardedBy&type=Code).
In an appendix, JCIP proposed a speciÔ¨Åcation for @GuardedBy .
One of our contributions is our observation that this widely-used
speciÔ¨Åcation is ambiguous; indeed, different tools interpret it in
different ways [36, 40]. A more important observation is that the
speciÔ¨Åcation is incorrect: every interpretation of it permits data races
and therefore violates its design goal. Another of our contributions
is a formal speciÔ¨Åcation for @GuardedBy that satisÔ¨Åes its design goals
and prevents data races. (This paper describes the semantics and
gives examples, but for reasons of space, the full formal development
appears in a companion paper [14].) We have instantiated this
speciÔ¨Åcation in two styles of analysis: abstract interpretation and
type-based analysis.
We have also implemented two tools that implement our speciÔ¨Åca-
tion. One tool uses type-checking to validate @GuardedBy annotations
that are written in Java source code. The other tool uses abstract
interpretation to infer valid @GuardedBy annotations for unannotated
programs. Our techniques are not speciÔ¨Åc to Java and generalize
to other languages. It is not the goal of these implementations to
detect race conditions or give a guarantee that they do not exist. The
inference tool determines what locking discipline a program uses,
and the checking tool determines whether a program obeys a given
locking discipline, without judging whether the discipline is too
strict or too lax for some particular purpose.1
In an experimental evaluation, we compared these tools to one
another and to programmer-written annotations. Our evaluation
shows that programmers who use the @GuardedBy annotation do not
necessarily do so consistently with JCIP‚Äôs rules, and even when they
do, their programs still suffer data races.
An informal deÔ¨Ånition of @GuardedBy is that when a program-
mer writes @GuardedBy(E )on a program element, then a thread may
use the program element only while holding the lock E. Namely,
the documentation for JCIP‚Äôs @GuardedBy [27] states: ‚ÄúThe Ô¨Åeld or
method to which this annotation is applied can only be accessed
when holding a particular lock‚Äù. Section 2 illustrates important am-
biguities in this informal deÔ¨Ånition. All of these need to be resolved
by a formal deÔ¨Ånition. The most important problem with JCIP‚Äôs
deÔ¨Ånition is that it provides name protection rather than value protec-
1The desired locking discipline is unknowable: some race conditions are benign, a
programmer may intend locking to be managed by a library or by clients, locking may
not be necessary for objects that do not escape their thread, etc.
2016 IEEE/ACM 38th IEEE International Conference on Software Engineering
   1133
tion [9]. Name protection is Ô¨Åne for primitive values, which cannot
be aliased in Java. Value protection is needed in order to prevent
data races on reference values, due to aliasing and because the Java
Language SpeciÔ¨Åcation deÔ¨Ånes locking in terms of values rather
than names [25]. Unfortunately, most tools that check @GuardedBy
annotations use JCIP‚Äôs inadequate deÔ¨Ånition and therefore permit
data races. Our deÔ¨Ånition prevents data races by providing value
protection: if a reference ris guarded by E, then for any value v
stored in r,v‚Äôs Ô¨Åelds are only accessed while the lock Eis held. (At
run time, a lock expression Eis held on a given thread at a given time
ifjava.lang.Thread.holdsLock(E) evaluates to true on that thread at
that time.) Checking and inference of this deÔ¨Ånition requires track-
ing values vas they Ô¨Çow through the program, because the value
may be used through other variables and Ô¨Åelds, not necessarily r.
Since this is relevant for reference values only, this article considers
value protection for reference variables and Ô¨Åelds only.
The contributions of this paper include:
A sound semantics for @GuardedBy that guarantees the absence
of data races, unlike the interpretation adopted by previous def-
initions and tools. The semantics is deÔ¨Åned in terms of uses of
values (objects) rather than uses of names (variables).
Two instantiations of the locking discipline semantics, using the
formalisms of abstract interpretation and type systems. Two
independent implementations for Java: as a modular type analysis
and as a whole-program abstract interpretation.
Case studies of programmers‚Äô use of @GuardedBy in practice. Previ-
ous speciÔ¨Åcations of the annotation have been vague, and we note
places where the programmers‚Äô interpretation does not provide
a guarantee against data races. Furthermore, we note where pro-
grammers have written annotations that are incorrect, illustrating
the need for tools like ours.
A practical comparison of the strengths of the two complementary
and independent implementations above: modular type-based and
global abstract interpretation.
The rest of this paper is organized as follows. Section 2 justiÔ¨Åes
the need for a locking discipline in concurrent programs. Section 3
describes the type system approach. Section 4 presents the abstract
interpretation approach. Section 5 shows experiments with imple-
mentations of both approaches. Section 6 presents related work.
Finally, Section 7 concludes.
2. Locking discipline semantics
This section shows how a locking discipline can enforce mutual
exclusion and the absence of data races; lays out the design space for
a locking discipline semantics; and discusses why such a semantics
should provide value protection rather than name protection.
2.1 Dining philosophers example
To illustrate how to specify a locking discipline, consider the
traditional dining-philosophers example. More examples are given
later. A group of philosophers sit around a table; there is a fork
between each pair of philosophers; and each philosopher needs its
left and right forks to eat. The locking discipline provides each
fork with a lock, and a philosopher must hold the lock in order to
use the fork; this guarantees mutual exclusion and the absence of
race conditions. (To prevent deadlock, the locks are acquired in
increasing order, but that is not a concern of this paper.)
Figure 1 shows Java code for the fork. The fork contains mutable
information (which philosopher holds it) in order to demonstrate
how a locking discipline can protect access to a mutable Ô¨Åeld. A
philosopher (Figure 2) is modeled as a thread whose runmethod re-
peatedly thinks, locks its two forks, eats, and unlocks the forks. The1 public class Fork implements Comparable<Fork> {
2 private static int nextId = 0;
3 private final int id = nextId++;
4 // who is holding the fork, or null if on the table
5 private Philosopher usedBy = null;
6
7 void pickUp(Philosopher philosopher) {
8 this.usedBy = philosopher;
9 }
10
11 void drop() {
12 this.usedBy = null;
13 }
14
15 public int compareTo(@GuardedBy("itself") Fork other) {
16 return id - other.id;
17 }
18
19 public synchronized String toString() {
20 if (usedBy != null)
21 return "fork " + id + " used by " + usedBy.getName();
22 else
23 return "fork " + id + " on the table";
24 }
25 }
Figure 1: A fork, possibly held by a philosopher.
26 public class Philosopher extends Thread {
27 private final @GuardedBy("itself") Fork left;
28 private final @GuardedBy("itself") Fork right;
29
30 Philosopher(String name, @GuardedBy("itself") Fork left,
31 @GuardedBy("itself") Fork right) {
32 super(name);
33 // a fixed ordering avoids deadlock
34 if (left.compareTo(right) < 0) {
35 this.left = left; this.right = right;
36 } else {
37 this.left = right; this.right = left;
38 }
39 }
40
41 public void run() {
42 while (true) {
43 think();
44 synchronized (left) {
45 left.pickUp(this);
46 synchronized (right) {
47 right.pickUp(this);
48 eat();
49 right.drop();
50 }
51 left.drop();
52 }
53 }
54 }
55
56 private void think() { ... }
57
58 @Holding({ "left", "right" })
59 private void eat() { ... }
60 }
Figure 2: A philosopher.
code illustrates a situation in which classes cooperate to implement
a synchronization policy, rather than the less challenging case of all
code being in the same class.
In Java, each object is associated with a monitor [25, ¬ß17.1] or
intrinsic lock. A synchronized statement or method locks the moni-
tor, and exiting the statement or method unlocks the monitor. Java
also provides explicit locks, which our theory and implementations
handle, but which this paper omits for brevity.
The @GuardedBy type qualiÔ¨Åers express the locking discipline. In
the semantics that we will introduce in this article, the type qualiÔ¨Åer
@GuardedBy("itself") on a variable‚Äôs type states that the variable
holds a value vwhose non- final Ô¨Åelds are only accessed at moments
1134when v‚Äôs monitor is locked by the current thread.
Our tools infer and verify the @GuardedBy annotations in these
Ô¨Ågures. The @GuardedBy("itself") type qualiÔ¨Åers on Ô¨Åelds left and
right guarantee that philosophers use their forks only after properly
locking them. The unlocked access to the final Ô¨Åeld idon line 16
of Ô¨Åg. 1 does not violate the @GuardedBy("itself") speciÔ¨Åcation.
2.2 Design space for locking discipline semantics
Recall the informal deÔ¨Ånition of @GuardedBy : when a programmer
writes @GuardedBy(E )on a program element, then a thread may use
the program element only while holding the lock E. This deÔ¨Ånition
suffers the following ambiguities related to the guard expression E.
1.May a deÔ¨Ånite alias of Ebe locked? Given a declaration @GuardedBy
("lock") Object shared;, is the following permitted?
Object lockAlias = lock;
synchronized (lockAlias) {
... use shared ...
}
2.IsEallowed to be reassigned while locked? Given a declaration
@GuardedBy("lock") Object shared;, is the following permitted?
synchronized (lock) {
lock = new Object();
... use shared ...
}
What about other side effects to E? Given a declaration @GuardedBy
("anObject.field") Object shared; , are the following permitted?
synchronized (anObject.field) {
foo(); // might side-effect anObject and reassign field
... use shared ...
}
synchronized (anObject.field) {
foo(); // might side-effect but not reassign field
... use shared ...
}
3.Should Ebe interpreted at the location where it is deÔ¨Åned or at
the location where it is used? Given a declaration
class C {
@GuardedBy("this") Object field;
...
}
are the following permitted?
C c;
synchronized (this) {
... use c.field ...
}
synchronized (c) {
... use c.field ...
}
The latter use assumes contextualization, such as viewpoint adap-
tation [13].
The informal deÔ¨Ånition suffers further ambiguities in the inter-
pretation of the program element being guarded . These can be sum-
marized by asking, what is a ‚Äúuse‚Äù of the shared program element?
Is it any occurrence of the variable name or only certain opera-
tions; do uses of aliases count, and are reassignment and side effects
permitted? More relevantly, does the @GuardedBy annotation spec-
ify restrictions on uses of a variable name (‚Äúname protection‚Äù), or
restrictions on uses of values (‚Äúvalue protection‚Äù)?
Current deÔ¨Ånitions of @GuardedBy do not provide guidance about
any of the ambiguities regarding the lock expression. Thus, there
is a danger that different tools interpret them differently, including
unsound interpretations that do not prevent data races. There is also1 public class Observable {
2 private @GuardedBy("this") List<Listener> listeners
3 = new ArrayList<>();
4 public Observable() {}
5 public Observable(Observable original) { // copy constr.
6 synchronized (original) {
7 listeners.addAll(original.listeners);
8 }
9 }
10 public void register(Listener listener) {
11 synchronized (this) {
12 listeners.add(listener);
13 }
14 }
15 public List<Listener> getListeners() {
16 synchronized (this) {
17 return listeners;
18 }
19 }
20 }
Figure 3: An implementation of the observer design pattern in which
locking is performed on the container Observable object. This imple-
mentation suffers data races. The implementation satisÔ¨Åes the name-
protection semantics for @GuardedBy, but not the value-protection se-
mantics.
a danger that programmers will assume a different deÔ¨Ånition than a
tool provides, and thus do not obtain the guarantee they expect.
Current deÔ¨Ånitions of @GuardedBy are clearer about what consti-
tutes a use of the program element ‚Äî any access to (that is, lexical
occurrence of) the name. This deÔ¨Ånition provides name protection,
but unfortunately it does not prevent data races. A program that
obeys this locking discipline might not be thread-safe and may still
suffer data races, as illustrated below. Therefore, any deÔ¨Ånition that
provides name protection is in general incorrect, because it does not
satisfy the stated goals of the @GuardedBy annotation.
2.3 Name protection and value protection
Name protection and value protection are distinct and incompa-
rable. Neither one implies the other. To illustrate the differences,
consider an implementation of the observer design pattern [20],
which is a key part of model-view-controller and other software
architectures. Figures 3 and 4 are patterned after the implementa-
tion found in the Java JDK. An Observable object allows clients to
concurrently register listeners. When an event of interest occurs, a
callback method is invoked on each listener.
Synchronization is required to avoid data races. Synchronization
in the register method and copy constructor prevents simultane-
ous modiÔ¨Åcations of the listeners list, which might result in a
corrupted list or lost registrations. Synchronization is needed in
thegetListeners() method as well, or otherwise the Java memory
model would not guarantee the inter-thread visibility of the regis-
trations. In Ô¨Åg. 3, synchronization is performed on the container
object, and in Ô¨Åg. 4, synchronization is performed on a Ô¨Åeld.
Figure 3 satisÔ¨Åes all interpretations of the name protection seman-
tics: every use of listeners occurs at a program point where the
current thread locks its container.2Nevertheless, a data race is pos-
sible, since two threads could call getListeners() and later access
the returned value concurrently. This demonstrates that the name
protection semantics does not prevent data races. Figure 3 does not
satisfy the value-protection semantics (which prevent data races),
because the return type of getListeners() is not compatible with
thereturn statement. Figure 3 could be made to satisfy the value-
protection semantics by annotating the return type of getListeners()
as@GuardedBy("this") , which would force the client program to do
2It also satisÔ¨Åes an interpretation of @GuardedBy that does not do contextualization or
viewpoint adaptation, since the constructor is implicitly synchronized on this.
11351 public class Observable {
2 private @GuardedBy("itself") List<Listener> listeners
3 = new ArrayList<>();
4 public Observable() {}
5 public Observable(Observable original) { // copy constr.
6 synchronized (original.listeners) {
7 listeners.addAll(original.listeners);
8 }
9 }
10 public void register(Listener listener) {
11 synchronized (listeners) {
12 listeners.add(listener);
13 }
14 }
15 public @GuardedBy("itself") List<Listener> getListeners() {
16 synchronized (listeners) {
17 return listeners;
18 }
19 }
20 }
Figure 4: An implementation of the observer design pattern in which
locking is performed on the listeners Ô¨Åeld.
its own locking and would prevent data race.
Figure 4 speciÔ¨Åes a different locking discipline. First consider
the value-protection semantics. @GuardedBy("itself") means that
all dereferences (Ô¨Åeld accesses) of the value of listeners occur
while the current thread locks that value. The annotation on the
return type of getListeners() imposes the same requirement on
clients of Observable . The Ô¨Åeld listeners could have been anno-
tated @GuardedBy("listeners") , but the syntax for the return type of
getListeners() would have been more complex, thus the @Guarded-
By("itself") syntax. Figure 4 also satisÔ¨Åes the name-protection
semantics. Depending on how the semantics handles aliasing and
side effects, the semantics may prevent clients of this program from
suffering data races.
Figure 4‚Äôs choice of locking the Ô¨Åeld rather than the container
permits additional Ô¨Çexibility. Consider the following client code:
List<Listener> l = new Observable(original).getListeners();
... use l ...
At the use of l, there is no syntactic handle for the container, and
it might even have been garbage-collected. Instead, the annotation
@GuardedBy("itself") is perfectly meaningful for l.
Regardless of other choices for the semantics of @GuardedBy , the
name-protection and value-protection variants are not comparable:
neither entails the other. In Ô¨Åg. 5, Ô¨Åeld xis declared as @Guarded-
By("itself") . This annotation holds in the value-protection seman-
tics, since its value is only accessed at line 11 inside a synchroniza-
tion on itself, but not in name-protection semantics: xis used at
line 8. Field yis@GuardedBy("this.x") for name protection but not
for value protection: its value is accessed at line 14 via w. In some
cases the semantics do coincide. Field zis@GuardedBy("itself")
according to both semantics: its name and value are only accessed at
line 11, where they are locked. Field wis not @GuardedBy according
to any semantics: its name and value are accessed at line 14.
2.4 DeÔ¨Ånition of @GuardedBy
We can now state our semantics for the @GuardedBy annotation. In
this article, by dereference of a value vwe mean the access of a
non- final Ô¨Åeld of v. The key idea is that values are protected rather
than names, and that dereferences of vare considered uses of v.
Suppose that the type of expression xcontains the qualiÔ¨Åer @Guard-
edBy(E ). A program satisÔ¨Åes the locking discipline if, at program
point pwhere the program dereferences a value that has ever been
bound to x, the program holds the lock on the value of expression
E. Furthermore, the value of Emust not change (in any thread)
during the time that the thread holds the lock. The protection is1 public class K {
2 private K1 x = new K1();
3 private K2 y = new K2();
4 private K1 z;
5 private K2 w;
6
7 public void m() {
8 z = x;
9 w = new K2();
10 synchronized (z) {
11 y = z.f;
12 w = y;
13 }
14 w.g = new Object();
15 }
16 }17 class K1 {
18 K2 f = new K2();
19 }
20
21 class K2 {
22 Object g = new Object();
23 }
name value
var protection protection
x ‚Äì @GB("itself")
y@GB("this.x") ‚Äì
z@GB("itself") @GB("itself")
w ‚Äì ‚Äì
Figure 5: Comparison of name-protection and value-protection seman-
tics for @GuardedBy (abbreviated as @GB).
shallow, since it applies to the value that xevaluates to, not to all
values reachable from it. There is no restriction on copying values,
including passing values as arguments (including as the receiver) or
returning values.
This deÔ¨Ånition resolves the ambiguities noted in section 2.2. A
deÔ¨Ånite alias of the guard expression Eis permitted to be locked.
The guard expression is not allowed to be reassigned to a different
value while locked. Side effects to the guard value are permitted,
since they do not affect the monitor. The lock expression undergoes
viewpoint adaptation so that it makes sense in the context of use.
A use of the program element is a dereference of any value it may
hold, regardless of aliasing, reassignment, and side effects.
We have formalized this deÔ¨Ånition, and also an alternate one that
provides name protection, as a structural operational semantics in
the style of Plotkin [41]. Our formalization includes a deÔ¨Ånition of
a data race and a proof that our deÔ¨Ånition prevents data races. For
reasons of space, the formal development appears in a companion
paper [14].
A set of @GuardedBy annotations expresses a locking discipline.
An inference tool infers a maximal locking discipline that the pro-
gram satisÔ¨Åes. A checking tool veriÔ¨Åes that the program satisÔ¨Åes
its locking discipline. Every program trivially satisÔ¨Åes the empty
locking discipline.
2.5 DeÔ¨Ånition of @Holding
The @GuardedBy annotation is sufÔ¨Åcient for expressing a locking
discipline. Inferring or checking a locking discipline requires rea-
soning about which locks are held at any given point in the program.
Our implementations provide a @Holding(E )annotation to express
these facts explicitly to aid in program comprehension or modular
checking.3It annotates a method declaration to indicate that when
the method is called, the current value of E(possibly viewpoint-
adapted) is locked. An example appears on line 58 of Ô¨Åg. 2.
3. Locking discipline checking
We have expressed our semantics as a type system. Then, we im-
plemented the type system as a modular static analysis that veriÔ¨Åes
a locking discipline expressed as Java @GuardedBy and @Holding an-
notations. It is publicly available at http://checker-framework.org/ .
If the type-checker issues no warnings for a given program, then
it guarantees that the program satisÔ¨Åes the locking discipline; that
is, a value that is held in an expression of @GuardedBy type in the
program is never dereferenced unless the values of all the lock
expressions indicated in the @GuardedBy annotation are locked by the
thread performing the dereference, at the time of the dereference.
3JCIP overloads the name @GuardedBy for two distinct purposes as a Ô¨Åeld annotation and
a method precondition. For clarity, this paper always refers to the latter as @Holding.
1136@GB({E1,E2}) ... 
‚ä• 
‚ä• @GB({}) @GB(E1) @GB(E2) Figure 6: The subtype hierarchy of the @GuardedBy type qualiÔ¨Åers in
the locking-discipline type system. E1andE2are lexically distinct ex-
pressions.
Our approach is standard for a static analysis. The goal is to
determine facts about values, but the program is written in terms
of variables and expressions. Therefore, the analysis computes an
approximation (an abstraction) in terms of expressions. Our static
analysis simultaneously computes two approximations. (1) The
analysis approximates the values that each expression in the pro-
gram may evaluate to. (2) The analysis approximates the locks that
the program currently holds. The implementation represents these
approximations using annotations such as @GuardedBy and @Holding.
Both abstractions are sound, so that if the type system approves
a program, the program satisÔ¨Åes the locking discipline; however,
the abstraction is conservative, so the type system might reject a
program that never suffers a race condition at run time.
3.1 Type qualiÔ¨Åers and hierarchy
The type system contains a single parameterized type qualiÔ¨Åer,
@GuardedBy . Figure 6 shows the subtype hierarchy. One surpris-
ing feature is that no two @GuardedBy annotations are related by
subtyping. If Eset16=Eset2 , then @GuardedBy(Eset1) and @Guard-
edBy(Eset2) are siblings in the type hierarchy. It might be expected
that @GuardedBy("x", "y") Tis a supertype of @GuardedBy("x") T. The
Ô¨Årst type requires two locks to be held, and the second requires only
one lock to be held and so could be used in any situation where
both locks are held. Our type system conservatively prohibits this
in order to prevent type-checking loopholes that would result from
aliasing and side effects ‚Äî that is, from having two references, of
different types, to the same data. If our analysis incorporated a more
precise analysis of such effects, its type hierarchy could be enriched.
@Holding is not part of the type hierarchy because it is a method
pre-condition rather than a type qualiÔ¨Åer.
3.2 Typing rules
The type system enforces the usual object-oriented subtyping
rules at assignments, method calls, overriding method declarations,
etc. It also enforces behavioral subtyping [32] for @Holding precon-
ditions in overriding method declarations.
Throughout its lifetime, a value is only ever referenced by expres-
sions with the identical @GuardedBy type qualiÔ¨Åers (modulo viewpoint
adaptation), and this ensures that the value is never dereferenced
without the appropriate lock expressions being held.
The receiver type of a Ô¨Åeld dereference or method invocation
must be @GuardedBy(...) (that is, not>which indicates that the set
of locks guarding the receiver is unknown or ?which indicates a
null receiver), and for Ô¨Åeld dereferences, all the locks in the type
must be held. In addition, a method invocation type-checks only if
all the locks mentioned in any @Holding precondition are held at the
method call.
The Lock Checker supports other features, such as side effect
speciÔ¨Åcations and type qualiÔ¨Åer polymorphism both without ( @Poly-
GuardedBy ) and with ( @GuardSatisfied ) a guarantee that the value‚Äôs
guarding locks are held at the time of the call. For complete type-
checking rules for all features, see the Lock Checker manual [8].The Lock Checker inherits additional features from the Checker
Framework ( http://CheckerFramework.org/ ) on which it is built: sound
analysis of Java reÔ¨Çection [4], Ô¨Çow-sensitive type inference [39],
and more. The type analysis is context-insensitive. Call-graph con-
struction is done by javac. Points-to information is approximated
by types (any possibly-aliased expressions have the same type), and
in addition utilizes a custom type-theoretic alias analysis [4, 8].
3.3 Held lock expressions analysis
The Lock Checker conservatively and Ô¨Çow-sensitively estimates
the lock expressions that are held at each point in a program. That
is, it computes a set of expressions whose locks are deÔ¨Ånitely held.
This process can be viewed as local type inference.
The Lock Checker considers a lock expression held starting when
the lock expression is used to acquire a lock, or
a@Holding annotation asserts that the lock is held.
entering the scope of an if (java.lang.Thread.holdsLock(E)){...}
test.
The Lock Checker conservatively assumes different lock expressions
may evaluate to different values; it does not track aliasing among
lock expressions, but as shown in Ô¨Åg. 6 requires lock expressions
to be syntactically identical. The Lock Checker considers a lock
expression no longer known to be held when
the lock is released (explicitly or due to scoping), or
the lock expression may be side-effected, or
exiting the scope of a Thread.holdsLock test.
The analysis makes conservative approximations about when an
expression may be side-effected. A non-Ô¨Ånal Ô¨Åeld whose guard is
not locked may be havoced at any time by another thread. A call to
a method not explicitly annotated as side-effect free is considered
to side-effect any mutable lock expression. This is like other type-
checkers built on the Checker Framework and was not an undue
burden in our experiments.
3.4 Modular analysis and libraries
Our type analysis is modular: it analyzes each procedure in isola-
tion. This makes the analysis scalable and permits separate compi-
lation. A modular analysis requires a summary for each procedure
that is called by the one being analyzed. The Lock Checker uses
the programmer-written annotations as this speciÔ¨Åcation. The type
analysis is sound for reÔ¨Çection, but unanalyzed code is trusted, us-
ing signatures/summaries for natives and unanalyzed libraries. The
Lock Checker ships with trusted annotations for relevant parts of
the JDK.
To verify uses of Java‚Äôs monitor locks, the annotations as de-
scribed so far are sufÔ¨Åcient. Because monitor locks are held through-
out the dynamic scope of a synchronized statement or invocation of a
synchronized method, a routine cannot affect the locks held, from the
point of view of the caller, and the @Holding method annotation can
specify a single set of held locks. For explicit locks, the summary
needs to be able to indicate different locks held on method entry and
method exit. For an analysis focused on deadlocks, the summaries
need to be even more complex [48], but deadlock detection and
prevention is outside the scope of this paper.
4. Locking discipline inference
Our abstract-interpretation-based, whole-program inference has
been implemented inside the Julia static analyzer [30]. It uses four
static analyses to infer @GuardedBy annotations (Ô¨Åg. 7), as described
in this section. Inference of @Holding is based on similar techniques
1137JarsCreation points
analysis
Definite aliasing
analysisDefinite locked expression
analysisLocking discipline
Inference@GuardedBy
AnnotationsFigure 7: The structure of the abstract interpretation inference.
but is simpler. Creation points and deÔ¨Ånite aliasing analysis have
been previously published [45, 37], including technical details of
their abstract domains, and hence sections 4.1 and 4.2 only describe
their use for the inference of a locking discipline. DeÔ¨Ånite locked
expression analysis and locking discipline inference are described
in sections 4.3 and 4.4. These four static analyses are sound, up to
the use of reÔ¨Çection and native methods, where the analysis conser-
vatively assumes the method may return any value of any known
type, but optimistically assumes that the call has no side effects.
Soundness and the use of a deÔ¨Ånite aliasing analysis entail that our
analysis never mistakenly infers a Ô¨Åeld/variable as @GuardedBy(E) .
However, it might fail to infer some @GuardedBy(E) annotations that
actually hold in the program, since the aliasing analysis might be
approximated or since Emight be too complex or the creation points
analysis might be too coarse. Also note that an inference tool in-
fers not what the programmer intended, but what the programmer
implemented.
Julia only infers Emade up of Ô¨Ånal Ô¨Åelds and the special variable
itself , which refers to the same value being protected. This is a
common, safe programming practice and caused no problems in our
case studies.
4.1 Creation points analysis
Creation points analysis is an instance of class analysis [47]
and its Ô¨Årst use in Julia is to build the call-graph of the program
under analysis. Julia implements a concretization of Parlsberg and
Schwarzbach‚Äôs class analysis [38, 45]. For each variable and Ô¨Åeld of
reference type, creation points analysis infers an overapproximation
of the set of program points where the value bound to that variable or
Ô¨Åeld might have been created. This is a concretization since it does
not track types of values, but rather their creation point, from which
the type can be derived. The approximation of local variables in this
analysis is Ô¨Çow-sensitive, while the approximation of object Ô¨Åelds is
Ô¨Çattened, context-insensitive [45]. Hence this analysis is sound for
concurrent programs. For efÔ¨Åciency, allocation sites and function
call sites are not context-sensitive (it is a 0-CFA analysis [45]).
The use of creation point analysis in the inference of @GuardedBy
is for computing an overapproximation of run-time values, since
two variables that hold the same object (value) must have the same
creation point, while the converse does not hold in general. Figure 8
shows the result of Julia‚Äôs creation points analysis at some selected
points of the program of Ô¨Ågs. 1 and 2 and a client program that
creates forks and philosophers and starts the philosopher processes.
It reports where the values of the variables at those program points
and of the Ô¨Åelds of the objects have been created by a newstatement.
For instance, the Ô¨Ågure shows that variable other at line 16 contains
a value of type Fork that can only be created in the driver program.
The same holds for the values held in Ô¨Åelds left and right of all
Philosopher objects in memory. Figure 8 also reports the creation
points of the objects passed to the Java library, including the implicit
argument (receiver) of getName , which will be needed later. Note
that, in Java bytecode, those arguments are held in stack variables,
hence the creation points analysis computes that information. In
this simple example, the approximation is always a singleton, but
in general it could be a set of creation points. If the line numberslines variable/Ô¨Åeld creation points
8,12,16 this {Fork@80}
20,21,23 this {Fork@80}
16 other {Fork@80}
35,37 this {Philosopher@84}
- Philosopher.left {Fork@80}
- Philosopher.right {Fork@80}
21,21,23 arg. to String.concat {k;p}
21 arg. to Thread.getName {Philosopher@84}
Figure 8: Creation points analysis of our example. Creation point p
stands for a generic creation point inside the Java library code; kstands
for an object held in the constant pool.
lines deÔ¨Ånite aliases of locked value
19 { this}
44 {this.left}
46 {this.right}
lines deÔ¨Ånite aliases of the container of the Ô¨Åeld
8,12,20 {this}
Figure 9: Expression aliasing analysis of our example.
are dropped from column creation points, one gets a class analysis.
That extra information makes it into a creation points analysis.
4.2 DeÔ¨Ånite aliasing analysis
This analysis infers, at each program point and for each local vari-
able, expressions that are deÔ¨Ånitely aliased with that variable [37].
DeÔ¨Ånite means that aliasing must hold at the program point, however
it is reached. This analysis is limited to alias expressions built from
variables and Ô¨Ånal Ô¨Åelds (or Ô¨Åelds that are never modiÔ¨Åed after being
initialized). Hence this analysis is sound for concurrent programs.
In particular, we are interested in deÔ¨Ånite aliases of values used in
thesynchronized statements in our example. Those values are held
in a stack variable in bytecode, whose deÔ¨Ånite aliases are shown in
Ô¨Åg. 9, as computed by the analysis. Note that the approximation is
semantic. For instance, the analysis would not change if one mod-
iÔ¨Åed the code at line 44 into Fork f = left; synchronized (f) ...
Later, it will be useful to know the deÔ¨Ånite aliases of the container
Ein each Ô¨Åeld access expression E:fwhere fis a non- final Ô¨Åeld.
Figure 9 provides that information for our example as well.
4.3 DeÔ¨Ånite locked expressions analysis
This analysis computes, at each program point, a set of expres-
sions that are deÔ¨Ånitely locked by the current thread at that point.
It uses the result of the deÔ¨Ånite aliasing analysis as a prerequi-
site. It works as a data Ô¨Çow analysis. Namely, let Lpbe a set of
deÔ¨Ånite locked expressions at each given program point p. The
analysis builds an inclusion constraint for every statement. In most
cases, those constraints just propagate the approximation, such as
from line 42 to line 43: L42L43. Where a synchronization oc-
curs, the set of deÔ¨Ånitely locked expressions is instead enlarged
with the deÔ¨Ånite aliases of the locked value, as previously com-
puted by the deÔ¨Ånite alias analysis (Ô¨Åg. 9). This is the case at
line 44: L44[fthis.leftg L45. At the end of the synchroniza-
tion, the analysis builds a constraint that conservatively kills all
deÔ¨Ånitely locked expressions whose type is compatible with that
of the unlocked expression, such as at line 50 of our example:
L50nfl2L50jlhas type Forkg L51. The analysis is interproce-
dural. Namely, deÔ¨Ånitely locked expressions are renamed at method
1138lines deÔ¨Ånitely locked expressions
8,12,20,21,23 { this}
16,35,37 {}
Figure 10: DeÔ¨Ånite locked expressions analysis of our example.
call, such as at line 45, to implement parameter passing:
8
>><
>>:l
a17!this
a27!philosopherl2L45;the receiver of pickUp
is deÔ¨Ånitely aliased to a1,
the parameter of pickUp
is deÔ¨Ånitely aliased to a29
>>=
>>;L7
Analysis of monitors is simpliÔ¨Åed because in Java a callee cannot
unlock a monitor taken by its caller, nor lock a value without unlock-
ing it before returning to the caller (section 3.4). Hence method calls
can be safely approximated as no-ops: L43L44. The same prop-
erty is enforced by the Java Virtual Machine and a violation leads
to an IllegalMonitorStateException . However, the implementation
of this check is not mandatory. For simplicity, we assume that it is
implemented or that the analyzed code is generated from Java. This
simpliÔ¨Åcation does not apply to explicit locks implemented through
classes in the standard Java libraries. For them, a side-effects anal-
ysis is used to determine if they might ever be modiÔ¨Åed during a
method call. For simplicity, this article only describes the inference
for Java monitors.
In general, programmers do not modify the value of the expres-
sions that they use as locks, such as this.left , and this is the case
in our example. However, the analysis copes with the unusual
case of Ô¨Åeld updates that affect the locked expressions. For in-
stance, if line 45 were modiÔ¨Åed to left = right and left made
non- final , then Julia would build a constraint that conservatively
kills all potentially affected locked expressions: L45nfl2L45j
left occurs in lgL46. However, the analysis would be unsound if
Ô¨Åeld updates were allowed from a concurrent thread. For this reason,
we preferred to keep the analysis sound and, like some other work,
only allow final Ô¨Åelds in the inferred deÔ¨Ånitely locked expressions.
After inclusion constraints have been built for each pair of consec-
utive statements and from callers to callees, the analysis computes a
Ô¨Åxpoint of the resulting set-constraint. Since this is a deÔ¨Ånite anal-
ysis, a maximal Ô¨Åxpoint is computed. The result for our example,
projected on some program points, is shown in Ô¨Åg. 10.
4.4 Inference of the locking discipline
Once the three previous supporting analyses have been performed,
Julia infers @GuardedBy(E )annotations for Ô¨Åelds and method param-
eters (Ô¨Åg. 7). This amounts to Ô¨Ånding expressions Esuch that the
non- final Ô¨Åelds of all possible values ever held in those Ô¨Åelds or
parameters are only accessed at a program point where Eis locked
by the current thread. Julia uses creation points as a conservative
approximation of the identity of run-time values. Objects created at
distinct creation points must be distinct, while the converse might
not hold. Namely, it uses the following algorithm to infer the @Guard-
edBy annotations for a Ô¨Åeld or parameter x:
1.it uses the creation points analysis to determine an overapproxi-
mation Cof the creation points of the values ever held in x;
2.it computes the set of program points where a Ô¨Åeld of an object
created at Cmight be accessed, that is, A=fpja non- final Ô¨Åeld
fis accessed at pasEp:fand the set Cp
Epof all possible creation
points of Epatpis such that Cp
Ep\C6=/0g;
3.for each p2A, it computes a set of expressions that are deÔ¨Ånitely
locked there, using itself as a shorthand for the expression itself:Lp=fE[Ep7!itself]jEis a deÔ¨Ånite alias of Epatp
andEis deÔ¨Ånitely locked at pg;
4. it computes L=T
p2ALp;
5.it infers the annotations @GuardedBy("E") for each E2Lwhere no
variable occurs, but for itself.
Consider for instance Ô¨Åeld left in Ô¨Åg. 2. According to the creation
point analysis (Ô¨Åg. 8), we have C=fFork@80g . Access to non- final
Ô¨Åelds occur as this.usedBy at lines 8;12;20and we have C8
this=
C12
this=C20
this=fFork@80g (Ô¨Åg. 8). Hence A=f8;12;20g. At
those program points, this is obviously a deÔ¨Ånite alias of itself
(Ô¨Åg. 9). According to Ô¨Åg. 10, the expression this is always locked
at 8, 12 and 20. Then Lp=fthis[ this7!itself]g=fitselfg for
each p2A, and hence L=fitselfg . Therefore, Julia infers the
annotation @GuardedBy("itself") for Ô¨Åeld left.
4.5 Calls to library methods
The algorithm sketched in section 4.4, at its step 2, requires to
check all program points Awhere a non- final Ô¨Åeld in accessed.
This includes the program points inside the libraries as well. Hence
the inference of @GuardedBy("itself") for Ô¨Åeld left above should be
corrected by considering in Aalso the program points outside the
application shown in Ô¨Ågs. 1 and 2 and the driver program. However,
as already sketched in section 3.4, a simplifying and computationally
effective alternative solution is to consider only program points A
inside the application under analysis, as long as we also include in
Athe program points where a value is passed to the libraries. That
is, point 2 of the algorithm from section 4.4 can be modiÔ¨Åed to
2.it computes the set of program points A=fpin the application
ja non- final Ô¨Åeld fis accessed at pasEp:for an expression
Epis passed as an argument to libraries and the set Cp
Epof all
possible creation points of Epatpis such that Cp
Ep\C6=/0};
By applying this inference algorithm, to Ô¨Ågs. 1 and 2 and the
driver program, Julia infers the @GuardedBy annotations in Ô¨Ågs. 1
and 2.
5. Experiments
We performed experiments to understand how programmers cur-
rently use @GuardedBy and to evaluate the utility of our semantics.
Our implementations of the abstract-interpretation-based inference
for locking disciplines (section 4) and of the type-system-based
checker for locking disciplines (section 3) were written by different
people and they share no code, so the fact that they agree provides
extra conÔ¨Ådence that they correctly implement the semantics.
5.1 Subject programs and methodology
We chose 15 open-source subject programs that use locking
(Ô¨Åg. 11). The programmers had partially documented the lock-
ing discipline in 5 of them. We counted not only @GuardedBy and
@Holding annotations but also commented annotations and English
comments containing the string ‚Äúguard‚Äù. The programmers some-
times used comments to document a locking discipline without
adding a compile-time and run-time dependency on the @GuardedBy
annotation. However, the documented locking discipline may be
incorrect because it was not checked by any tool.
We determined a goal set of correct annotations, i.e. those whose
locking discipline the program obeys. To determine this set, we
manually analyzed every annotation written by the programmer or
inferred by Julia.4We retained every annotation from either set
4There might exist other correct annotations that neither Julia, the original programmer,
nor we are aware of.
1139Programmer-written Inference
Project Version LoC @GuardedBy @Holding time
BitcoinJ 0.12.2 102458 46 14 238
Daikon 5.2.24 169710 0 0 1596
Derby Engine 10.11.1.1 119594 12 9 4077
Eclipse ECJ 4.4 161701 0 0 924
Guava 18.0 118190 64 72 621
Jetty Server 9.2.6.v20141205 59611 0 0 109
Velocity 1.7 54549 0 0 94
Zookeeper 3.4.6 75475 0 0 118
Catalina 8.0.15 121959 0 0 472
Coyote 8.0.15 71527 1 0 110
Dbcp 8.0.15 53181 16 0 84
Jasper 8.0.15 67380 0 0 105
Jni 8.0.15 32682 0 0 49
Util 8.0.15 42115 0 0 58
Websocket 8.0.15 39928 0 0 75
Figure 11: Subject programs. The last 7 are part of Tomcat. LoC is
the approximate number of lines of code reached by Julia during the
analysis. It is the count of the entries in the line number table of each
class analyzed, plus 3 for each method or constructor. Inference time is
measured in seconds.
Goal Programmer-written Inference Type-checking
name value value value
Project # # P% R% P% R% # P% R% # P% R%
BitcoinJ 4746 87 85 30 30 7 100 15 6 100 86
Daikon 50 - 0 - 0 1 100 20 1 100 100
Derby Engine 1612 83 63 58 44 6 100 38 6 100 100
Eclipse ECJ 60 - 0 - 0 6 100 100 6 100 100
Guava 2264 19 55 14 41 5 100 23 5 100 100
Jetty Server 10 - 0 - 0 1 100 100 1 100 100
Velocity 40 - 0 - 0 4 100 100 4 100 100
Zookeeper 50 - 0 - 0 5 100 100 5 100 100
Catalina 20 - 0 - 0 2 100 100 2 100 100
Coyote 24 1 100 4 0 0 23 100 100 23 100 100
Dbcp 2016 88 70 56 45 6 100 30 6 100 100
Jasper 70 - 0 - 0 7 100 100 7 100 100
Jni 10 - 0 - 0 1 100 100 1 100 100
Util 40 - 0 - 0 4 100 100 4 100 100
Websocket 90 - 0 - 0 9 100 100 9 100 100
Figure 12: Experimental results for @GuardedBy annotations. The
table lists the number of annotations written by the programmer, in-
ferred by Julia, and veriÔ¨Åed by the Lock Checker. Goal is the number
of goal annotations. The precision (R%) and recall (R%) are given
separately when annotations are interpreted according to the name-
protection or value-protection semantics. For the type-based analysis,
the goal is the inference results of the abstract interpretation. Compu-
tations whose denominator is zero are reported as ‚Äú-‚Äù.
such that the program is guaranteed not to suffer a data race on the
annotated program element. (We did not observe any data races that
appeared to be intentional.) Then, we compared the goal annota-
tions to both the programmer-written and the inferred ones. This
comparison was not syntactical: annotations that are conceptually
the same or are expressing the same thing are considered equal.
As is standard for an information retrieval problem [44], we report
results in terms of precision (number of correct reported annotations
divided by total number of reported annotations) and recall (number
of correct reported annotations divided by total number of goal
annotations). Precision and recall are measurements between 0%
and 100% inclusive, and larger numbers are better.
5.2 Inference experiments
We used Julia to infer the locking discipline in terms of @Guard-
edBy and @Holding with value-protection semantics.5Experimental
results for @GuardedBy annotations appear in Ô¨Åg. 12, and results for
@Holding appear in Ô¨Åg. 13. Programmers made signiÔ¨Åcant numbers
5Julia has two modes and can also infer annotations for name protection, but this article
focuses on value protection.Programmer-written Abstract interp. Type-based analysis
Project Goal OGoal # Corr P% R% OR% # Corr P% R% # Corr P% R%
BitcoinJ 113 45 14 14 100 12 31 113 113 100 100 112 112 100 99
Daikon 3 0 0 0 - 0 - 3 3 100 100 3 3 100 100
Derby Engine 121 13 9 7 78 6 54 120 120 100 99 119 119 100 99
Eclipse ECJ 1 0 0 0 - 0 - 1 1 100 100 1 1 100 100
Guava 126 45 72 38 53 30 84 110 110 100 87 110 110 100 100
Jetty Server 4 0 0 0 - 0 - 4 4 100 100 4 4 100 100
Velocity 20 0 0 0 - 0 - 20 20 100 100 20 20 100 100
Zookeeper 16 0 0 0 - 0 - 16 16 100 100 16 16 100 100
Catalina 98 0 0 0 - 0 - 98 98 100 100 98 98 100 100
Coyote 13 0 0 0 - 0 - 13 13 100 100 13 13 100 100
Dbcp 18 0 0 0 - 0 - 18 18 100 100 16 16 100 89
Jasper 2 0 0 0 - 0 - 2 2 100 100 2 2 100 100
Jni 1 0 0 0 - 0 - 1 1 100 100 1 1 100 100
Util 4 0 0 0 - 0 - 4 4 100 100 4 4 100 100
Websocket 4 0 0 0 - 0 - 4 4 100 100 4 4 100 100
Figure 13: Experimental results for @Holding annotations. Numbers
are as in Ô¨Åg. 12, but @Holding means the same thing in both the
name- and value-protection semantics. The number of correct anno-
tations (Corr) is given together with the precision and recall. OGoal
(for ‚Äúomission-tolerant goal‚Äù) is the number of goal annotations whose
guard expression the programmer used elsewhere, and OR% is the pro-
grammer recall based on the omission-tolerant goal set.
of mistakes (as shown by low precision) and omitted signiÔ¨Åcant
numbers of annotations (as shown by low recall).
Programmer mistakes. In every program where programmers doc-
umented a locking discipline, they wrote incorrect annotations that
express a locking discipline that the code does not satisfy. For exam-
ple, Guava‚Äôs LocalCache and MapMakerInternalMap classes incorrectly
useSegment.this as a guard expression. Julia infers the correct guard
this. In other cases, a lock is acquired only at write accesses but
not at read accesses to a variable. This can lead to corrupted data
reads for data larger than 32 bits (i.e. long and double values, that
on some machines are accessed in two steps). For 32-bit data, it
can lead to inconsistent multiple reads of a variable because the
Java memory model permits delayed publication. An example is
in the Guava class SerializingExecutor : the Ô¨Åeld private boolean
isThreadScheduled is annotated as @GuardedBy("internalLock") , but
it is read without protection at line 135, despite being always written
after acquiring the lock.
The most common programmer mistake, however, was creating
external aliases to a value. If a reference to a variable‚Äôs value
leaks, then a data race can occur even if a lock is held whenever
the variable is read or written. In other words, in the presence of
aliasing the value-protection semantics provides no guarantee. This
is a natural problem, given the lack of automated checking and even
the lack of a mention of the danger of aliasing in references such
as JCIP [22], where only instance conÔ¨Ånement is mentioned. An
example is BitcoinJ Ô¨Åeld PaymentChannelClient.conn . It is always
accessed holding a lock inside the class, but the Ô¨Åeld is initialized
with a parameter of a public constructor. So there exists an external
alias to the object that can potentially be used to access the object
without protection.
Programmer omissions. The private BitcoinJ method Payment-
ChannelServer.truncateTimeWindow(long) is inferred to be @Holding(-
"lock") , and is indeed called always with lock held. Nevertheless,
the programmer didn‚Äôt write the annotation.
In Apache Velocity, a template engine, Julia Ô¨Ånds four objects that
are @GuardedBy("itself") : the Ô¨Åeld XPATH_CACHE , in XPathCache , is
accessed in a synchronized(XPATH_CACHE) block; the Ô¨Åeld SimplePool
pool, in ParserPoolImpl , uses methods putand getofSimplePool ,
that modify the object‚Äôs state inside a synchronized(this) block; the
receivers of the same two methods are thus guarded as well.
Inference mistakes. Julia‚Äôs output was correct: its precision is
100%, just as for any sound tool that infers deÔ¨Ånite information.
1140Inference omissions. There are two reasons that Julia fails to infer
a correct programmer-written locking discipline: either (1) the pro-
gram‚Äôs correctness is too subtle for Julia to reason about, or (2) the
locking discipline is inexpressible in the value-protection semantics.
(1) Julia incompleteness: Julia missed 1 @Holding in Derby Engine
and 16 in Guava because methods in the Monitor ,AbstractService ,
and ServiceManager classes use complex reasoning, ensuring for
instance that a call to a method happens only in Ô¨Çows of execution
where the lock is held by the executing thread. At the moment Julia
does not understand these tricks.
Julia only allows itself and Ô¨Ånal Ô¨Åelds in a guard expression.
This is sufÔ¨Åcient but not necessary to ensure that the guard expres-
sion evaluates to the same value throughout the scope of the guard
(section 2.4). Programmers usually use variables in guard expres-
sions (sometimes correctly, sometimes incorrectly). As future work,
we plan to support the container this in guard expressions, which
still protects against data races if it is never aliased.
(2) Value-protection semantics inÔ¨Çexibility: Only one example
seems a genuine value-protection programmer-written annotation
that is not inferred by Julia. The static Ô¨Åeld in Dbcp
private static Timer _timer; //@GuardedBy("EvictionTimer.class")
is always accessed in synchronized static methods, it never escapes,
and is assigned with _timer = AccessController.doPrivileged(new
PrivilegedNewEvictionTimer()) . The doPrivileged method is na-
tive, and executes the runmethod of the PrivilegedNewEvictionTimer
class, that simply returns a new Timer object. The guard refers to the
class object and is permitted under the value-protection semantics.
5.2.1 Omission-tolerant results
We computed two sets of recall numbers for programmer-written
@Holding annotations (Ô¨Åg. 13). First, we determined the overall
recall, based on the full set of goal annotations. Second, we deter-
mined the recall based on a reduced set of goal annotations. The
reduced, or omission-tolerant, set contains only @Holding annota-
tions whose guard expressions appear in @GuardedBy annotations that
the programmer wrote. This latter metric considers only locks that
the programmer deemed signiÔ¨Åcant enough to document.
The rationale for reporting two different measurements is that
there are two different reasons that a @Holding annotation might be
missing from the programmer-written set:
The programmer wrote @GuardedBy on some variable vbut omitted
@Holding(v) . This incomplete speciÔ¨Åcation of the locking disci-
pline for vis a programmer error. For example, the programmer
correctly annotated the unary method Wallet.maybeUpgradeToHD
as@Holding("keychainLock") in BitcoinJ, but didn‚Äôt annotate the
no-argument overloaded version.
The programmer omitted @GuardedBy on some variable vand also
omitted @Holding(v) . It is conceivable that the programmer only
intended to write speciÔ¨Åcations for some guarded variables and
intentionally omitted the @GuardedBy annotation on other variables.
The OR% measurement assumes every such omission was inten-
tional, even though the practice is undesirable because someone
calling or modifying the code could misuse it. For example,
Julia infers @Holding("enumConstantCache") for Guava‚Äôs private
method Enums.populateCache , which needs it for a call to put. In-
deed, the only invocation of populateCache is in a synchronized
(enumConstantCache) block. Nevertheless, the programmer did not
annotate it as @GuardedBy("enumConstantCache").
5.3 Type-checking experiments
5.3.1 MethodologyIn order to run the type-checking approach, we performed the fol-
lowing steps for each target program: (1) Remove all the programmer-
written @GuardedBy and @Holding annotations from the program‚Äôs
source code. Leave all programmer-written @SuppressWarnings anno-
tations, as they are trusted. (2) Insert the Julia-inferred annotations
in the program‚Äôs source code. These use the value-protection seman-
tics, which is what the Lock Checker veriÔ¨Åes. (3) Repeatedly run
the Lock Checker and edit the annotations or the code to eliminate
the warning (e.g., add a missing annotation), until the Lock Checker
issues no more warnings.
A set of @GuardedBy and @Holding annotations is veriÔ¨Åed by the
Lock Checker if the Lock Checker issues no warnings when only
those annotations are present in the source code.
5.3.2 Type-checking results
Figures 12 and 13 describe the annotations that were veriÔ¨Åed
by the Lock Checker. Overall, there were 5 annotations that were
inferred by Julia but could not be veriÔ¨Åed by the Lock Checker.
One was due to a difference in the tools‚Äô abstraction (static approx-
imations to the semantics). That annotation is @Holding("#1.lock")
on BitcoinJ‚Äôs method Transaction.isConsistent(TransactionBag,
boolean) , where #1refers to the Ô¨Årst parameter of the method. Since
TransactionBag is an interface, the expression #1.lock is not legal
Java (interfaces cannot contain Ô¨Åelds) and cannot be processed by
the Lock Checker. Julia‚Äôs whole-program, closed-world analysis
determined that every implementing class has a Ô¨Åeld named lock.
If the TransactionBag interface were modiÔ¨Åed to include a getLock()
method, the Lock Checker would be able to resolve the expression
#1.getLock().
The other 4 other differences were due to limitations of the Java 8
language syntax. Julia inferred a @GuardedBy annotation on the re-
ceiver parameter of a method declaration of an anonymous inner
class, and @Holding annotations on the constructors of anonymous
inner classes. These parts of the program are implicit ‚Äî they can-
not be written in the Java source code. Therefore, there was no
way to communicate this information to the Lock Checker, which
reads and veriÔ¨Åes annotations in source code. An example is that
Julia inferred that the constructor of the anonymous class within
BitcoinJ method PaymentChannelClient.incrementPayment should be
annotated with @Holding("#1.lock") and its receiver with @Guarded-
By("itself.lock").
5.4 Abstract interpretation vs. type-checking
The abstract interpretation approach allows a codebase to be an-
notated from scratch, producing valuable documentation and also
permitting the type-checking approach to verify the absence of bugs
relevant to the locking discipline described by these annotations,
whereas a pure type-checking approach can only verify annotations
already present in the code. In a codebase completely free of annota-
tions, the type-checking approach will issue no warnings, regardless
of any bugs that might be present.
Type-checking is a compositional analysis. Given a speciÔ¨Åcation
of the locking discipline expressed as annotations, it can verify part
of a program and ensure that subclasses or other extensions are
consistent with the intended design. By contrast, inference learns
from uses, so it needs enough uses (if there are no uses, no @Guard-
edBy annotations are necessary), and the uses must be bug-free.
Without heuristics such as statistical analysis, it cannot be used for
bug-Ô¨Ånding, which requires a speciÔ¨Åcation; Julia implements such a
statistical analysis.
A speciÔ¨Åc observation is the need to extend the syntax of the
type system to handle expressions that are not legal Java, such as
#1.lock as described in section 5.3.2. We also observed the need to
1141extend the Java language itself to make explicit locations that were
previously implicit. Java 8 already made an important step toward
this by permitting a programmer to optionally write the receiver
formal parameter explicitly ‚Äî a change that was motivated by the
desire to write type annotations on the receiver [29]. That capability
was essential in our case studies, where 49 out of the 87 inferred
annotations were on receivers.
It is interesting that these new syntax limitations became clear
only with the integration with an inference tool that inferred all
possible guards, even though the Lock Checker has been publicly
available in the Checker Framework distribution since June 2009
(over 70 monthly releases before the current writing). We speculate
that this is an issue of ‚Äúout of sight, out of mind‚Äù: Java programmers
didn‚Äôt think about annotations on those locations and so they did not
specify them. The programmers also may have simply suppressed
type-checking errors related to those locations.
6. Related work
Despite the need for a formal speciÔ¨Åcation for reasoning about
Java‚Äôs concurrency and for building veriÔ¨Åcation tools [10, 33, 5], we
are not aware of any previous tool built upon a formalization of the
semantics of Java‚Äôs concurrency annotations [22]. The JML (Java
Modeling Language) monitors_for statement [42, 31] corresponds
to the JCIP @GuardedBy annotation [22], together with its limitations:
name protection and semantic ambiguities. Currently, [42] requires
to write such annotation, manually, in source code, together with
other, non-obvious annotations about the effects of each method.
Once that hard manual task is done, the JML annotations can be
model-checked, which is only proved to work on small code.
Warlock [46] was an early tool that checked user-written speciÔ¨Å-
cations of a locking discipline, including annotations for variable
guards and locks held on entry to functions. ESC/Modula-3 [12]
and ESC/Java [18] provided similar syntax and checked them via
veriÔ¨Åcation conditions and automated theorem-proving, an approach
also applied to other concurrency problems [17]. All these tools are
unsound and do checking rather than inference. Similarly to our
inference, [35] infers locking speciÔ¨Åcations by generating the set
of locks which must be held at a given program location and then
checking the lockset intersection of aliasing accesses. It is based on
possible rather than deÔ¨Ånite aliasing and hence is unsound.
Our approach is a pure, Ô¨Çow-sensitive type system. A heavier-
weight alternative is a type-and-effect system, which can prevent
not just race conditions but also deadlocks [15, 1]. It can associate
guards not just with variables but also with speciÔ¨Åc side effects [34].
Most approaches, including ours, explicitly associate each vari-
able with a lock that guards access to it. An alternative is to use
ownership types and make each Ô¨Åeld protected by its owner, which
is not necessarily the object that contains it [7, 11]. This approach is
somewhat less Ô¨Çexible, but it can leverage existing object encapsu-
lation speciÔ¨Åcations and can be extended to prevent deadlocks [6].
These concepts can also be expressed using fractional permis-
sions [49]. Grossman [26] extended type-checking for data races to
Cyclone, a lower-level language, but did not implement or experi-
mentally evaluate it.
Previous inference techniques include unsound dynamic infer-
ence of lock types [2, 43] and sound inference via translation to
propositional satisÔ¨Åability, for most of Java [16]. In [28], a trace
of execution events is recorded at runtime, then, ofÔ¨Çine, permuta-
tions of these events are generated under a certain causal model of
scheduling constraints. This leads to a fast, but unsound, bug-Ô¨Ånding
technique for concurrency problems. By contrast, our approach is
sound, more precise, and more scalable. Improving our aliasing
analysis [3] would improve the recall of our implementations.Type systems have been applied to other concurrency problems,
such as atomicity [19]. Deadlocks are generally handled by impos-
ing a lock ordering: if all locks are acquired in the given order, then
no deadlock occurs. Recent type systems permit the lock ordering
not to be static throughout the program [21, 24].
JCIP [22] does not mention aliasing, but it does mention instance
conÔ¨Ånement. JCIP notes that instance conÔ¨Ånement only works with
an ‚Äúappropriate locking discipline‚Äù, but does not deÔ¨Åne the latter
term. Our use of aliasing is less restrictive and more Ô¨Çexible, and
our analysis is effective without a separate instance conÔ¨Ånement
analysis.
7. Conclusion
A locking discipline makes concurrent programming manageable.
Used properly, it guarantees the lack of data races. Used improperly
(with vague deÔ¨Ånitions or no mechanical checking), it is error-prone
at best and misleading at worst.
Current deÔ¨Ånitions of locking disciplines and their implementa-
tions suffer from many ambiguities; furthermore, they often specify
name protection rather than value protection, even though name pro-
tection does not in general provide a guarantee of freedom from race
conditions. These ambiguities and unsoundness are a real issue in
practice. We have formalized and proved a value-protection seman-
tics, eliminating both the ambiguities and the unsoundness. Our lock-
ing discipline formalism is a common language for discussing data
races and can also be used to express value protection. The leap from
name to value semantics may be desirable in other domains as well.
Our case studies of real-world code show that programmers of-
ten make mistakes (precision 19‚Äì100%, recall 6‚Äì84%): they write
locking-discipline speciÔ¨Åcations that their programs do not follow,
and they fail to write ones that their programs do follow. Program-
mers seem to often assume an unsound name-protection semantics
for the locking-discipline speciÔ¨Åcations. We have shown that the
value-protection semantics is more restrictive and possibly harder to
use; but the more accurate documentation and the reduction in bugs
should be worth it.
Two popular analysis approaches are abstract interpretation and
type-checking. We have implemented one of each type of tool. Each
tool is based on a Ô¨Årm semantic foundation that guarantees no data
races (modulo standard assumptions, such as regarding native code).
Abstract interpretation is generally assumed to be more powerful and
precise, but we have quantiÔ¨Åed the differences, leading to insights
about the analysis approaches. In the future, others will be able
to make a more informed decision between the approaches. The
two tools have completely independent implementations, and the
fact that their results agree, up to differences in their underlying
analysis, lends conÔ¨Ådence to our semantics and implementations.
Our inference tool can also Ô¨Ånd bugs by reporting when a value is
usually but not always accessed when a lock is taken. Our tools are
scalable, robust, and publicly available, so programmers can take
advantage of them today.
Acknowledgments. This material is based on research sponsored by
DARPA and the United States Air Force under contracts FA8750-12-2-
0107, FA8750-12-C-0174, and FA8750-15-C-0010. The U.S. Government
is authorized to reproduce and distribute reprints for Governmental purposes
notwithstanding any copyright notation thereon.
References
[1]M. Abadi, C. Flanagan, and S. N. Freund. Types for safe locking: Static
race detection for Java. ACM Transactions on Programming Languages
and Systems, 28(2):207‚Äì255, March 2006.
[2] R. Agarwal, A. Sasturkar, and S. D. Stoller. Type discovery for
Parameterized Race-Free Java. Technical Report DAR-04-16, Computer
Science Department, SUNY at Stony Brook, September 2004.
1142[3] A. Aiken, J. S. Foster, J. Kodumal, and T. Terauchi. Checking and
inferring local non-aliasing. In PLDI 2003, Proceedings of the ACM
SIGPLAN 2003 Conference on Programming Language Design and
Implementation, pages 129‚Äì140, San Diego, CA, USA, June 9‚Äì11,
2003.
[4] P. Barros, R. Just, S. Millstein, P. Vines, W. Dietl, M. d‚ÄôAmorim, and
M. D. Ernst. Static analysis of implicit control Ô¨Çow: Resolving Java
reÔ¨Çection and Android intents. In ASE 2015: Proceedings of the 30th
Annual International Conference on Automated Software Engineering,
pages 669‚Äì679, Lincoln, NE, USA, November 11‚Äì13, 2015.
[5] D. Bogdanas and G. Rosu. K-Java: A complete semantics of Java. In
ACM SIGPLAN-SIGACT POPL, pages 445‚Äì456, Mumbai, India, 2015.
[6] C. Boyapati, R. Lee, and M. Rinard. Ownership types for safe
programming: Preventing data races and deadlocks. In Object-Oriented
Programming Systems, Languages, and Applications (OOPSLA 2002),
pages 211‚Äì230, Seattle, WA, USA, October 28‚Äì30, 2002.
[7] C. Boyapati and M. Rinard. A parameterized type system for race-free
Java programs. In Object-Oriented Programming Systems, Languages,
and Applications (OOPSLA 2001), pages 56‚Äì69, Tampa Bay, FL, USA,
October 14‚Äì18, 2001.
[8]The Checker Framework Manual: Custom pluggable types for Java.
http://CheckerFramework.org/.
[9] D. G. Clarke, J. M. Potter, and J. Noble. Ownership types for Ô¨Çexible
alias protection. In Object-Oriented Programming Systems, Languages,
and Applications (OOPSLA ‚Äô98), pages 48‚Äì64, Vancouver, BC, Canada,
October 20‚Äì22, 1998.
[10] J. C. Corbett, M. B. Dwyer, J. Hatcliff, and Robby. Expressing
checkable properties of dynamic systems: the Bandera SpeciÔ¨Åcation
Language. Software Tools for Technology Transfer, 4(1):34‚Äì56, 2002.
[11] D. Cunningham, S. Drossopoulou, and S. Eisenbach. Universes for race
safety. In VeriÔ¨Åcation and Analysis of Multi-threaded Java-like
Programs (VAMP), pages 20‚Äì51, Lisbon, Portugal, September 3, 2007.
[12] D. L. Detlefs, K. R. M. Leino, G. Nelson, and J. B. Saxe. Extended
static checking. SRC Research Report 159, Compaq Systems Research
Center, December 18, 1998.
[13] W. Dietl, S. Drossopoulou, and P. M√ºller. Generic Universe Types. In
ECOOP 2007 ‚Äî Object-Oriented Programming, 21st European
Conference, pages 28‚Äì53, Berlin, Germany, August 1‚Äì3, 2007.
[14] M. D. Ernst, D. Macedonio, M. Merro, and F. Spoto. Semantics for
locking speciÔ¨Åcations. Submitted for publication. Available as CoRR
abs/1501.05338, 2015.
[15] C. Flanagan and S. N. Freund. Type-based race detection for Java. In
PLDI 2000, Proceedings of the ACM SIGPLAN 2000 Conference on
Programming Language Design and Implementation, pages 219‚Äì232,
Vancouver, BC, Canada, June 18‚Äì23, 2000.
[16] C. Flanagan and S. N. Freund. Type inference against races. In
Proceedings of the Eleventh International Symposium on Static
Analysis, SAS 2004, pages 116‚Äì132, Verona, Italy, August 26‚Äì28, 2004.
[17] C. Flanagan, S. N. Freund, and S. Qadeer. Thread-modular veriÔ¨Åcation
for shared-memory programs. In 11th European Symposium on
Programming, pages 262‚Äì277, Grenoble, France, April 2002.
[18] C. Flanagan, K. R. M. Leino, M. Lillibridge, G. Nelson, J. B. Saxe, and
R. Stata. Extended static checking for Java. In PLDI 2002, Proceedings
of the ACM SIGPLAN 2002 Conference on Programming Language
Design and Implementation, pages 234‚Äì245, Berlin, Germany,
June 17‚Äì19, 2002.
[19] C. Flanagan and S. Qadeer. A type and effect system for atomicity. In
POPL 2003, Proceedings of the 30th Annual ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages, pages 338‚Äì349,
New Orleans, LA, January 15‚Äì17, 2003.
[20] E. Gamma, R. Helm, R. E. Johnson, and J. Vlissides. Design Patterns.
Addison-Wesley, Reading, MA, 1995.
[21] P. Gerakios, N. Papaspyrou, and K. Sagonas. A type and effect system
for deadlock avoidance in low-level languages. In TLDI 2011: The sixth
ACM SIGPLAN Workshop on Types in Language Design and
Implementation, pages 15‚Äì28, Austin, TX, USA, January 25, 2011.
[22] B. Goetz, T. Peierls, J. Bloch, J. Bowbeer, D. Holmes, and D. Lea. Java
Concurrency in Practice. Addison-Wesley, 2006.
[23] A. G√∂ransson. EfÔ¨Åcient Android Threading. O‚ÄôReilly Media, June 2014.
[24] C. S. Gordon, M. D. Ernst, and D. Grossman. Static lock capabilities for
deadlock freedom. In TLDI 2012: The seventh ACM SIGPLANWorkshop on Types in Language Design and Implementation, pages
67‚Äì78, Philadelphia, PA, USA, January 28, 2012.
[25] J. Gosling, B. Joy, G. Steele, G. Bracha, and A. Buckley. The Java
Language SpeciÔ¨Åcation. Addison Wesley, Boston, MA, Java SE 8
edition, 2014.
[26] D. Grossman. Type-safe multithreading in Cyclone. In TLDI 2003: The
ACM SIGPLAN Workshop on Types in Language Design and
Implementation, pages 13‚Äì25, New Orleans, LA, USA, January 18,
2003.
[27] JSR 305 @GuardedBy speciÔ¨Åcation. https://jsr-305.googlecode.com/
svn/trunk/javadoc/javax/annotation/concurrent/GuardedBy.html.
[28] J. Huang, Q. Luo, and G. Rosu. GPredict: Generic predictive
concurrency analysis. In ICSE‚Äô15, Proceedings of the 37th International
Conference on Software Engineering, pages 847‚Äì857, Florance, Italy,
May 20‚Äì22, 2015.
[29] JSR 308 Expert Group. Annotations on Java types. http://download.
oracle.com/otndocs/jcp/annotations-2014_01_08-pfd-spec/,
January 8, 2014. Proposed Final Draft.
[30] The Julia static analyzer. http://www.juliasoft.com.
[31] G. T. Leavens, E. Poll, C. Clifton, Y . Cheon, C. Ruby, D. Cok, P. M√ºller,
J. Kiniry, P. Chalin, D. M. Zimmerman, and W. Dietl. JML Reference
Manual, May 31, 2013.
[32] B. H. Liskov and J. M. Wing. A behavioral notion of subtyping. ACM
Transactions on Programming Languages and Systems,
16(6):1811‚Äì1841, November 1994.
[33] B. Long and B. W. Long. Formal speciÔ¨Åcation of Java concurrency to
assist software veriÔ¨Åcation. In IPDPS, page 136, Nice, France, April
2003.
[34] Y . Lu, J. Potter, and J. Xue. Structural lock correlation with ownership
types. In 22nd European Symposium on Programming , pages 391‚Äì410,
Rome, Italy, March 19‚Äì22, 2013.
[35] M. Naik, A. Aiken, and J. Whaley. Effective static race detection for
Java. In PLDI 2006, Proceedings of the ACM SIGPLAN 2006
Conference on Programming Language Design and Implementation,
pages 308‚Äì319, Ottawa, Canada, June 12‚Äì14, 2006.
[36] NASA. Java PathFinder. http://babelfish.arc.nasa.gov/trac/jpf.
[37] D. Nikolic and F. Spoto. DeÔ¨Ånite expression aliasing analysis for Java
bytecode. In 9th International Colloquium on Theoretical Aspects of
Computing (ICTAC 2012), pages 74‚Äì89, Bangalore, India, September
2012.
[38] J. Palsberg and M. I. Schwartzbach. Object-oriented type inference. In
Conference on Object-Oriented Programming, Systems, Languages, and
Applications, pages 146‚Äì161, Phoeniz, AZ, USA, October 1991.
[39] M. M. Papi, M. Ali, T. L. Correa Jr., J. H. Perkins, and M. D. Ernst.
Practical pluggable types for Java. In ISSTA 2008, Proceedings of the
2008 International Symposium on Software Testing and Analysis, pages
201‚Äì212, Seattle, WA, USA, July 22‚Äì24, 2008.
[40] V . Pech. Concurrency is hot, try the JCIP annotations.
http://jetbrains.dzone.com/tips/concurrency-hot-try-jcip,
February 2010.
[41] G. D. Plotkin. A structural approach to operational semantics. Journal
of Logic and Algebraic Progamming, 60-61:17‚Äì139, July‚ÄìDecember
2004.
[42] E. Rodr√≠guez, M. Dwyer, C. Flanagan, J. Hatcliff, G. T. Leavens, and
Robby. Extending JML for modular speciÔ¨Åcation and veriÔ¨Åcation of
multi-threaded programs. In ECOOP 2005 ‚Äî Object-Oriented
Programming, 19th European Conference, pages 551‚Äì576, Glasgow,
Scotland, July 27‚Äì29, 2005.
[43] J. Rose, N. Swamy, and M. Hicks. Dynamic inference of polymorphic
lock types. In Workshop on Concurrency and Synchronization in Java
Programs (CSJP), pages 18‚Äì25, St. John‚Äôs, Newfoundland, Canada,
July 25‚Äì26, 2004.
[44] G. Salton. Automatic Information Organization and Retrieval.
McGraw-Hill, 1968.
[45] F. Spoto and T. P. Jensen. Class analyses as abstract interpretations of
trace semantics. ACM Transactions on Programming Languages and
Systems, 25(5):578‚Äì630, 2003.
[46] N. Sterling. Warlock: A static data race analysis tool. In Proceedings of
the Winter 1993 USENIX Conference, pages 97‚Äì106, San Diego, CA,
USA, January 5‚Äì29, 1993.
[47] F. Tip and J. Palsberg. Scalable propagation-based call graph
1143construction algorithms. In Object-Oriented Programming Systems,
Languages, and Applications (OOPSLA 2000), pages 281‚Äì293,
Minneapolis, MN, USA, October 15‚Äì19, 2000.
[48] A. Williams, W. Thies, and M. D. Ernst. Static deadlock detection for
Java libraries. In ECOOP 2005 ‚Äî Object-Oriented Programming, 19th
European Conference, pages 602‚Äì629, Glasgow, Scotland, July 27‚Äì29,
2005.
[49] Y . Zhao and J. Boyland. Assuring lock usage in multithreaded programs
with fractional permissions. In ASWEC‚Äô09: 20th Australian Software
Engineering Conference, pages 277‚Äì286, Gold Coast, Australia,
April 15‚Äì17, 2009.
1144