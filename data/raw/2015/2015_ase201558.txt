Conﬁguration-Aware Change Impact Analysis
Florian Angerer∗Andreas Grimmer∗Herbert Pr ¨ahofer†Paul Gr ¨unbacher∗
∗Christian Doppler Laboratory MEVSS†Institute for System Software
Johannes Kepler University Linz, Austria
{ﬂorian.angerer, andreas.grimmer, herbert.praehofer, paul.gruenbacher}@jku.at
Abstract —Understanding variability is essential to allow
the conﬁguration of software systems to diverse requirements.
V ariability-aware program analysis techniques have been pro-posed for analyzing the space of program variants. Such tech-niques are highly beneﬁcial, e.g., to determine the potentialimpact of changes during maintenance. This paper presents aninterprocedural and conﬁguration-aware change impact analysis(CIA) approach for determining possibly impacted products whenchanging source code of a product family. The approach furthersupports engineers, who are adapting speciﬁc product variantsafter an initial pre-conﬁguration. The approach can be adaptedto work with different variability mechanism, it provides moreprecise results than existing CIA approaches, and it can beimplemented using standard control ﬂow and data ﬂow analysis.Using an industrial product line we report evaluation results onthe beneﬁt and performance of the approach.
Keywords—Change impact analysis, program analysis, mainte-
nance, conﬁguration.
I. I NTRODUCTION
Variability plays an essential role in software systems,
which need to be conﬁgured to meet a wide range of cus-
tomer requirements. Dealing with variability, however, leadsto many challenges for developing, maintaining, testing, andanalyzing systems. For instance, developers need to ensurethat different software variants behave as expected. However,it has been shown that generating and analyzing all possi-ble system variants is computationally infeasible, even forsmall systems [1]. Research on variable software systems hasprogressed signiﬁcantly. For instance, researchers in softwareproduct lines and feature-oriented software development havedeveloped family approaches [2] that allow analyzing thewhole space of software variants by exploiting commonalitiesbetween variants. Such approaches have been shown to bevery effective, particularly for program analysis [1]. Manyexisting approaches assume that the source code is annotateddirectly with variability information, which is the case, e.g.,in annotation-based product lines that use preprocessors [3].However, other variability mechanisms, such as testing con-ﬁguration options loaded from a ﬁle or provided via programarguments, play an equally important role and analysis supportis also needed for such cases.
An important application area for program analysis is
change impact analysis (CIA), i.e., the identiﬁcation of thepotential consequences of a change, or the estimation of whatneeds to be modiﬁed to accomplish a change [4]. Our aimis to improve support for CIA of variable software systems,an area of high practical relevance, particularly for clone-and-own product lines [5], [6]. In this paper, we thus presentan interprocedural and conﬁguration-aware CIA approach thatuses and propagates variability information. Our approach canhandle load-time conﬁguration options representing softwarevariability. While some program analysis approaches (e.g., [7])can handle such runtime variability by attaching path con-ditions to system dependence graphs (SDGs) to improve theprecision of slices, their scalability to large programs is limited,as path conditions need to be extracted for nearly everyconditional statement. Our approach thus uses a conditional
system dependence graph (CSDG), an extended representationof an SDG we presented in earlier work [8].
We demonstrate the beneﬁts of our approach using two
use cases derived from an analysis of development practicesof our industry partner [9], [10]: We illustrate how the ap-proach facilitates development and maintenance in domain
engineering by supporting software engineers that need to
determine the impact of changing a set of source code elementsof a product family. Speciﬁcally, we demonstrate how ourconﬁguration-aware CIA allows to automatically determinethe set of possibly impacted products. Such analysis hasmajor beneﬁts for software evolution: for instance, it helpsreducing regression testing to the affected product variants. Itfurther simpliﬁes software deployment, as updates only needto be rolled out to customers affected by certain changes.We further show how our approach supports development
and maintenance in application engineering by supporting
software engineers changing a speciﬁc product variant, whichneeds to be adapted after deriving it from a product line. This isa frequent case in clone-and-own product lines [5], [6], whenengineers customize and extend the software to the speciﬁcrequirements of customers. Again, manual CIA would be error-prone and infeasible due to the high conﬁgurability of manylarge systems in this case.
The contribution of this paper is an interprocedural CIA
approach, which annotates potentially impacted elements withvariability information to determine the set of affected productsafter a change. Speciﬁcally, our conﬁguration-aware CIA pro-vides the following beneﬁts compared to existing techniques:(i) the approach can be adapted to work with different variabil-ity mechanisms. Our technique does not assume that the source
code is directly annotated with variability information, i.e.,unlike existing approaches it does not assume an annotation-based mechanism that is resolved at compile-time. Instead,it can handle conﬁguration options that remain constant afterbeing loaded during the startup of an application. (ii) The
approach provides more precise results than existing CIA.Speciﬁcally, it discovers contradicting product conﬁgurationsand determines source code that can never be executed. Thisallows reducing the size of the change impact. (iii) The
approach uses standard control ﬂow and data ﬂow analyses.We avoid the use of new control and data ﬂow analyses toease the implementation of the approach in different contexts.
2015 30th IEEE/ACM International Conference on Automated Software Engineering
978-1-5090-0025-8/15 $31.00 © 2015 IEEE
DOI 10.1109/ASE.2015.58385
Our paper is organized as follows: Section II illustrates the
research problem using a small example. Section III presents
our conﬁguration-aware CIA approach and its implementation.Section IV shows the results of evaluating the approach regard-ing its beneﬁt and performance. Section V presents relatedwork. Section VI rounds out the paper with a conclusion andan outlook on future work.
II. P
ROBLEM ILLUSTRATION
Change impact analysis allows to automatically determine
and systematically review the possibly impacted source codefor changes. However, state-of-the-art CIA techniques [11]–[14] do not consider load-time variability. For example, List-ing 1 shows an illustrative program example that can be con-ﬁgured by enabling or disabling the conﬁguration options c0
andc1. Existing CIA techniques do not provide information
about the product variants that are affected by a change.Even this small conﬁgurable program shows that manuallydetermining the set of affected products is difﬁcult due tomany dependencies as can be seen in the simpliﬁed SDG forListing 1 shown in Figure 1. Assume a developer changing thereturn statement in line 37, represented as a node in the lower-right corner of the SDG. Existing CIA techniques follow theforward edges and mark all visited nodes as possibly impactedby the intended change, i.e., the nodes labeled
return d.
bar() *d.bar() ,return 2*d.bar() ,int res = obj.foo(
d)and System.out.println(res) are in the set of impacted
statements.
Performing conﬁguration-aware analysis is much harder, as
one needs to consider if the statements are executed and thedata ﬂows are valid under certain conditions. For example, thestatements
object = new B(); return; and object = new
C(); depend on the conditions c0and¬c0∧c1. Therefore,
the bodies of classes BandCalso depend on these condi-
tions. In class D, an additional local condition ¬c1appears.
Hence, statement return 1;is only executed if the condition
(c0∨¬c0∧c1)∧¬c1holds, while statement System.out.
println(res) is executed if ¬c0holds. However, combining
and simplifying both conditions results in false , i.e., changing
the statement return 1;has no impact on the statement
System.out.println(res) .
Researchers have already developed variability-aware pro-
gram analysis techniques considering the variability of aprogram, e.g., when performing data ﬂow analysis [1]. How-ever, many current techniques assume source code to beannotated with variability information, that is resolved duringcompilation by only considering the syntactic structure of aprogram. But many product lines and conﬁgurable softwaresystems use further mechanisms to deal with variability. Anexample are conﬁguration options, which are loaded and thenevaluated in many different locations of a program. Thereare some approaches, e.g., [15], that are able to considerruntime variability but they do not differ between conﬁgurationthat remains constant over execution and regular control ﬂowof a program. In the example in Listing 2 the value of aconﬁguration option is stored in a local variable (line 5),which is used subsequently to decide which other conﬁgurationoption to load (line 7). Currently available analysis techniquescannot handle such situations as they assume a strict separationof the variability mechanism from program control ﬂow, i.e.,1class Main {
2 static Properties p = Properties.load("conf.prop")
3 static boolean c0 = "on".equals(p.getProperty("c0"));
4 static boolean c1 = "on".equals(p.getProperty("c1"));
5
6 public static void main(String[] args) {
7 A obj = new A();
8 Dd=new D();
9 if(c0) {
10 obj = new B();
11 return;
12 }else if(c1) {
13 obj = new C();
14 }
15 int res = obj.foo(d);
16 System.out.println(res);
17 }
18 }
1920 class A{
21 int foo(D d) {
22 return 2;
23 }
24 }
25 class Bextends A{
26 int foo(D d) {
27 return d.bar() *d.bar();
28 }
29 }
30 class Cextends A{
31 int foo(D d) {
32 return 2*d.bar();
33 }
34 }
35 class D{
36 int bar() {
37 if(!c1) return 1;
38 return 0;
39 }
40 }
Listing 1: Small conﬁgurable program.
1class Main {
2 static Properties prop = Properties.load("conf.prop")
34 public static void main(String[] args) {
5 boolean c0 = "on".equals(prop.getProperty("F"));
6 boolean c1;
7 if(c0) {
8 c1 = "on".equals(prop.getProperty("X"));
9 }else {
10 c1 = "on".equals(prop.getProperty("Y"));
11 }
1213 A obj;
14 if(c1) {
15 obj = new A1(); // indirectly depends on c0
16 }else {
17 obj = new A2(); // indirectly depends on c0
18 }
19 obj.foo();
20 }
21 }
Listing 2: Inﬂuence of conﬁguration options on program
execution.
they do not consider that the execution of the statements in
lines 15 and 17 also depends on the conﬁguration option c0.
In this small example it is obvious that the execution of thestatements in lines 15 and 17 also depends on conditions c0∧c1
and¬c0∧¬c1. Finally, the call in line 19 also depends on
both conﬁguration options since the reaching objects dependon both conﬁguration options.
386_ int res   =  obj.foo(d)    main
A obj = new A()
obj = new B()System.out.println(res) D d = new D() IF c0
IF c1
obj = new C()B.foo C.foo
D.barreturn d.bar() * d.bar() return 2 * d.bar()
IF !c1
return 0 return 1return A.foo
return2
Fig. 1: SDG for the small conﬁgurable program in Listing 1.
III. A PPROACH
Change impact analysis (CIA) is commonly performed by
following edges in a system dependence graph (SDG) [16].
An SDG consists of nodes representing concrete and abstractprogram elements and edges encoding control and data depen-dencies between the elements. To make the CIA conﬁguration-aware, the variability of the program must be representedin the SDG. In this work, we use a conditional system
dependence graph (CSDG), an extension of the SDG that
represents variability in form of presence conditions [8]. Sincethe CSDG uses presence conditions, a conﬁguration-awareCIA can be performed that also considers the different productconﬁgurations.
Presence conditions are attached to edges in the CSDG
and have the following interpretation. An edge labeled with apresence condition is only valid if the presence condition issatisﬁed with respect to a concrete product conﬁguration. Ifthe execution of a program element depends on a particularproduct conﬁguration, the presence condition attached to acontrol edge represents the conditional execution of that pro-gram element. Analogously, a presence condition attached toa data dependence edge means that the data ﬂow only existsin the product variant satisfying the presence condition.
Figure 2 gives an overview of our approach. First, the
SDG is created and initial presence conditions are obtainedby analyzing the source code giving an initial CSDG. Thenthe presence conditions are propagated over the edges. Once/;#23/;#23#23/;#23#23#23/;#23/;#23#23#23#23/;#23#23#23#23#23/;#23#23#23#23/;#23#23#23#23#23#23/;#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23
/;#23/;#23#23
/;#23#23#23/;#23/;#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23/;#23#23#23/;#23/;#23#23#23#23/;#23#23#23#23#23/;#23#23#23#23/;#23#23#23#23#23#23/;#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23
/;#23#23
/;#23#23#23/;#23#23#23#23/;#23#23/;#23#23#23#23#23/;#23#23/;#23#23
/;#23#23/;#23#23
/;#23#23#23/;#23#23#23#23/;#23#23/;#23#23#23#23/;#23/;#23#23#23#23#23/;#23/;#23#23#23#23#23#23#23#23/;#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23/;#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23
/;#23#23
/;#23#23#23/;#23#23#23#23/;#23#23/;#23#23/;#23#23
/;#23#23/;#23#23/;#23#23#23/;#23#23#23#23/;#23#23/;#23#23#23#23/;#23/;#23#23#23#23#23/;#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23
/;#23#23 /;#23#23
Fig. 2: The three main steps of our approach: building the CSDG,
propagating the conditions, and computing the change impact.
the edges are labeled with the propagated presence conditions,
the change impact can be computed by following the edgesand collecting nodes also considering the variability of thesystem. The following Sections III-A, III-B, and III-D willpresent these different steps in detail.
We implemented our conﬁguration-aware change impact
analysis approach in Java based on the Soot analysis frame-work [17]. We use Soot’s control ﬂow, data ﬂow and pointeranalysis to build the SDG. The propagation algorithm operateson the SDG and is therefore largely language independent.However, the statements represented by an SDG node must beinvestigated to know how the conﬁguration propagates throughthe program. Our current implementation uses binary decisiondiagrams (BDDs) to represent presence conditions.
A. Analyzing programs for conﬁguration options
Our approach extracts variability information from source
code. It is therefore required to know how variability is imple-
mented in a software system. Our approach speciﬁcally targetsload-time conﬁguration options, a frequently used mechanismfor implementing variability, which is applicable regardless ofthe programming language used. The conﬁguration options areusually stored in conﬁguration ﬁles which are loaded in thestart-up phase. The options are stored in program variables,which deﬁne the program’s behavior but remain constantduring program execution. Our approach is not limited to thisform of variability, but can easily be adapted to work withother variability implementation mechanisms analogously.
In the following we assume that conﬁguration options are
encoded in the form of Boolean conﬁguration conditions indi-
cating if particular options are enabled. Our approach analyzesthe source code of a system to ﬁnd statements which load(and possibly combine) conﬁguration options to store themin program variables, i.e., statements that assign conﬁguration
conditions toconﬁguration variables. Those conﬁguration con-
ditions become presence conditions attached to edges in the
SDG as they are propagated as shown next.
B. Propagating conﬁguration conditions
Our approach propagates presence conditions and the val-
ues of conﬁguration variables along control and data edges in
the CSDG to determine the effective conditions that apply tocertain program elements (e.g., statements). For example, whenchanging the statement in line 37 of Listing 1, one needs toknow the condition that effectively applies to this statement.This seems to be easy at ﬁrst sight, as the statement isdirectly protected by a branch statement testing a conﬁgurationvariable. However, the actual condition may be even stricter,
387... ...
x := fB
...[...,{(x,fA)}]
 [...,{(x,fB)}] 
(a) Updating a reaching condition set by a new
conﬁguration condition introduced by assigningconﬁguration variable x.x := fA x := fB
stmt
......
[..., {(x, fA)}] [..., {(x, fB)}]
 [..., {(x, fA || fB)}] [...]
(b) Joining reaching condition sets. The twoincoming deﬁnitions of conﬁguration variable x
are combined disjunctively....
IF f0
stmt[C,...]
 [C && f0, ...] 
(c) Introducing a presence condition on a controledge. The branch statement tests variable f0and
therefore causes the presence condition to beupdated.
... ...
...
...[f0, ...] [f1, ...]
 [f0 || f1, ...] 
(d) Joining presence conditions. The presenceconditions f0andf1are combined disjunctively
as the control ﬂow merges....
IF !x
stmtx := f0 && f1
[true, ...]
 [!(f0 && f1), ...] [..., {(x, f0 && f1)} ]
(e) Introducing and using new conﬁguration vari-ables. The reaching condition (x, f 0∧f1)is
used by branch statement IF !x. Therefore, a
new presence condition is created by negatingthe reaching condition.... ...
stmt
......
[f0, {}] [f1, {}]
 [C0 && (f0 || f1),{}] [C0,...]
(f) Propagating presence conditions to data de-pendence edges. The outgoing edge will onlybe valid if the statement is executed, i.e., C0is
satisﬁed, and if at least one incoming data edgeis valid, i.e., f0∨f1is fulﬁlled.
Fig. 3: Basic cases of propagating presence conditions. The newly created presence conditions are shown in framed text boxes.
especially if the method bar() is only executed under a certain
condition.
The effective conditions for statements can be computed by
propagating the conditions along edges and combining them
if a node has more than one incoming edge. As explainedpreviously, our approach can handle load-time conﬁgurationoptions, i.e., during propagation we need to know whichconﬁguration conditions can be used at a particular point ina program. This can be achieved using a kind of reachingdeﬁnition analysis for conﬁguration variables based on thecontrol and data dependence edges of the SDG.
Therefore, propagation works with pairs [P, RC ], where
Pis the presence condition that applies to an edge and RC
is the set of reaching conditions deﬁning which conﬁgurationvariables carry which conﬁguration conditions. The pairs arepropagated along the edges. Reaching conditions are propa-gated based on data dependencies and presence conditions arepropagated based on control dependencies. We will explain thepropagation approach by explaining six basic cases shown inFigure 3.
(a) Updating reaching condition sets. This case deals with
propagating a reaching condition set across a node introducinga new conﬁguration condition (cf. Figure 3a). The reachingcondition set of the outgoing data dependence edge is updatedwith the new deﬁnition for variable x, i.e., (x, fB) over-
writes deﬁnition (x, fA).
(b) Joining reaching condition sets. In this case a node has
two incoming and one outgoing data dependence edge. Thereaching conditions are combined using a union operation, butreaching conditions for the same variables (x, fA) and(x,
fB) are combined using a logical ORoperator (cf. Figure 3b).
(c) Introducing presence conditions on control edges. In
this case a branch node tests a conﬁguration condition (Fig-ure 3c). The incoming edge to node IF f0 will only be
executed if condition Cis satisﬁed. However, the branch node
further tests a conﬁguration condition f0. Hence, the control
dependence successors will only be executed if this node isexecuted and if the generated presence condition is satisﬁed.Therefore, the outgoing edge leading to the node representingthe then-branch is labeled with presence condition C& &f 0 .
Similarly, the edge to the node representing else-branch islabeled with Cand the negation of f0.
(d) Joining presence conditions. In this propagation case
a node has multiple incoming control dependence edges, each
388carrying distinct presence conditions (cf. Figure 3d). The pres-
ence conditions of the input edges are combined disjunctivelyand the combined condition is then applied to every outgoingedge.
(e) Introducing and using new conﬁguration variables.
Figure 3e shows the transformation from a reaching conditionto a presence condition. A new conﬁguration variable xis
introduced, which stores a combination of two conﬁgurationconditions f0andf1. A data dependence edge propagates this
deﬁnition to an if-statement using the variable xin its branch
condition. Thus, the outgoing control edge is labeled with apresence condition !(f0 && f1).
(f) Propagating presence conditions to data dependence
edges. The last case shows how presence conditions on in-
coming control and data dependence edges are propagated toan outgoing data dependence edge (cf. Figure 3f). First, thepresence conditions of incoming control dependence edgespropagates to all outgoing data dependence edges, as the datadependence of the node only occurs if the node is executed.Therefore, the outgoing data dependence edge gets a presencecondition C0in the example. Secondly, there are incoming
data dependence edges with presence conditions f0andf1.
However, the statement can only be executed if one of theseedges provides data. The outgoing data dependence edge isthus only valid if the statement is executed and if there isincoming data, i.e., the condition C0∧(f0∨f1)is satisﬁed.
C. Propagation semantics
We provide a formal deﬁnition of the propagation seman-
tics in terms of a data ﬂow problem. This allows us to infer twoproperties: (i) the algorithm will terminate since all data ﬂowproblems are ﬁxpoint problems; (ii) the runtime behavior of thealgorithm is the same as for other data ﬂow problems, i.e., inthe worst case the runtime complexity is O(n
3). However, an
important difference to other data ﬂow problems, like reachingdeﬁnitions, is that our problem is deﬁned on the CSDG andnot on the control ﬂow graph. In order to describe a data ﬂowproblem, we deﬁne insets and outsets for the CSDG nodes.
Since we propagate both, the presence conditions and thereaching conditions, we separate these two aspects to simplifythe formulation.
Equations 1–4 formally describe the propagation semantics
of the presence conditions. We distinguish presence conditionsfor control and for data dependence edges, as they are propa-gated differently. The symbol p
ctrl innis the incoming con-
trol dependence presence condition and symbol pdata innis
the incoming data dependence presence condition for node n.
Accordingly, pctrl out nandpdata out nare the outgoing
sets. The set ctrl preds nrepresents the control dependence
predecessors and data preds nrepresents the data dependence
predecessors of a CSDG node n. As shown in Equations (1)
and (2) the presence condition of an incoming edge is thedisjunction of the presence conditions of the outgoing edgesof predecessors, both for control edges and data edges.
p
ctrl inn=/logicalordisplay
pred∈ ctrl preds npctrl out pred (1)
pdata inn=/logicalordisplay
pred∈ data preds npdata out pred (2)pctrl out n=pctrl inn∧ext(rcinn,n) (3)
pdata out n=pctrl inn∧pdata inn (4)
Equation (3) deﬁnes the propagation of presence conditions
for outgoing control edges, i.e., the presence condition ofthe incoming edge is ANDed logically with ext(rc
inn,n).
Function ext(rcinn,n)provides the conﬁguration conditions
node nintroduces, e.g., by a branch condition (cf. Figure 3c),
which is dependent of the incoming reaching condition setrc
inn. Equation (4) ﬁnally deﬁnes the presence condition for
the outgoing data dependence edge as an and-combination ofthe presence condition of the incoming control edge and datadependence edge (cf. Figure 3f).
Equations 5–6 formally describe the propagation semantics
of the reaching conditions. Recall that reaching conditions aresets of conﬁguration variable deﬁnitions, i.e., sets of pairsRC⊆ConfV ariables ×Conditions where ConfV ariables
is the set of conﬁguration variables and Conditions is the set
of all possible conﬁguration conditions.
rc
inn=/circleplusdisplay
pred∈ data preds nrcout pred (5)
rcout n=(rcinn/circleminusrckill(n))⊕rcgen(n) (6)
The operators ⊕and/circleminusare similar to the set union op-
erator∪and set difference operator \, but also consider
introducing and killing of conﬁguration conditions. We deﬁneoperator⊕to form the union of two given reaching condition
sets rc
1andrc2but deﬁnitions affecting the same variables
are joined by combining the condition disjunctively. For ex-ample,{(x, f0),(y, f1)}⊕{ (x, f1),(z,f2)}={(x, f0∨
f1),(y, f1),(z,f2)}. Thus, Equation (5) deﬁnes the reaching
condition set of an incoming data dependence edge as the⊕combination of the outgoing predecessor data dependence
edges.
Equation (6) deﬁnes the case when the statement of an
CSDG node modiﬁes the reaching conditions set (cf. Fig-ure 3a). If the statement redeﬁnes the value of a conﬁgurationvariable, all pairs of the incoming reaching conditions set forthis variable are killed and a new pair with the new valueis generated. Therefore, we deﬁne the operation rc
1/circleminusrc2for
two reaching conditions sets rc1andrc2by removing all pairs
(x, c1)from rc1if there is a pair (y, c2)∈rc2with x=y.
Function rcgen(n)returns the deﬁnitions (x, c) introduced by
node n, e.g., a deﬁnition introduced by a node representing an
assignment of a conﬁguration condition cto a conﬁguration
variable x. The function rckill(n)is the set of deﬁnitions
which are possibly killed by node n, i.e., any deﬁnition to a
variable x, which is overwritten by n.
D. Computing the Conﬁguration-Aware Change Impact
We can now perform the conﬁguration-aware CIA, using
our algorithm to propagate conditions to every CSDG node.We expect that in most cases changes will affect only a subsetof the source code. Propagating the conditions globally and inadvance would thus be wasteful for determining the changeimpact. Therefore, our conﬁguration-aware CIA algorithmpropagates presence conditions only in the required domain asfollows: we ﬁrst determine the backward slice, starting withthe nodes for which we want to compute the change impact,
389i.e, the CIA criterion. We then propagate the conditions within
the computed backward slice such that presence conditionare attached to all incoming edges of the CIA criterion. Theactual change impact analysis is performed in the third stepstarting with the CIA criterion by propagating the conditionsaccording to the propagation rules. However, we need to knowthe presence conditions and reaching conditions for all nodesin the change impact to compute the correct conditions. Wethus mark all nodes with incoming edges that have no presenceconditions yet. After collecting these nodes, we compute abackward slice to determine the ﬁnal propagation domain.Finally, we apply the propagation algorithm in this domain andlabel all edges in the change impact with the correct conditions.In this way we assure that we do not miss any conditions andavoid doing a global propagation across the entire CSDG.
IV . E
V ALUATION
Our evaluation investigates the beneﬁts regarding complex-
ity reduction and the performance of the conﬁguration-awareCIA approach in two use cases: (i) development and mainte-nance in domain engineering, i.e., for determining the differentproduct variants affected by a change; and (ii) development andmaintenance in application engineering, i.e., for determiningcode affected by a change made to a speciﬁc product variant.Speciﬁcally, we use product families of our industry partnerto explore the following research questions:
RQ1. How beneﬁcial is the conﬁguration-aware CIA for
maintaining a product line? Our approach is highly beneﬁcial
in situations of high variability complexity. We thus estimatethe beneﬁt by computing the degree and complexity of vari-ability information a domain engineer needs to consider whendetermining the impact on product variants after changing codein a product line.
RQ2. How beneﬁcial is the conﬁguration-aware CIA for
maintaining a speciﬁc product variant? This situation is com-
mon in clone-and-own product lines. Some of the variabil-ity has already been resolved, e.g., by setting conﬁgurationoptions. However, developers still need to adapt and ﬁne-tune the product variant to meet speciﬁc customer needs. Weestimate the beneﬁt by computing the increased precision ofthe change impact, as a smaller change impact will reduce thedevelopment effort.
RQ3. Is the performance of the conﬁguration-aware CIA
sufﬁcient for realistic maintenance tasks? A major problem
of static program analysis is high run time complexity. Weperform benchmarking to show the practicality and suitabilityof the approach in realistic maintenance tasks.
A. Case Study and Code Base Selected for the Evaluation
To investigate these research questions, we applied our tool
to real-world software systems provided by our industry part-
ner Keba AG (http://www.keba.com), a medium-sized com-pany developing and producing tools, hardware, and softwarefor the industrial automation domain. One of their systems isKePlast [18], a comprehensive solution for the automation ofinjection molding machines. The core of KePlast is a con-ﬁgurable control software framework which is implementedin a proprietary dialect of the IEC 61131-3 standard [19],a widely-adopted programming language standard for im-plementing industrial automation systems. KePlast exists inmultiple different product families addressing different marketsegments. Keba uses a custom-developed product conﬁgurationtool to select components from their KePlast platform basedon customer requirements. The selected components are thenadapted and extended by application engineers to meet speciﬁccustomer needs not yet covered by the platform. In this stage,the derived software is still conﬁgurable by using load-timeconﬁguration options, the variability mechanism targeted byour approach.
As a baseline for our evaluation we derived product variants
from KePlast’s families, which contain a maximum number offeatures selectable together in the product conﬁguration tool.These maximum products do not contain the full code baseof the product line, but are an approximation good enough forthe purpose of our study. In particular, we used 9 differentstill conﬁgurable product variants with a size ranging from 53
kLOC (family4)t o302 kLOC (family2).
Furthermore, these maximum product variants of a family
indeed have commonalities and differences. In the case of ourindustry partner’s product families, the common code, i.e. themandatory features, is a substantial part of the source codebecause it includes implementations for basic data structuresand algorithms used in all product variants. We therefore con-centrate on the variable part of the analyzed product familiesto obtain data that is most relevant for our research questions.Speciﬁcally, we only considered change impacts containing atleast one presence condition. This was the case for 27% of
all change impacts in our case study (median across productfamilies).
B. Tool Implementation and Adaptation
KePlast has been developed in a proprietary dialect of the
IEC 61131-3 standard, for which no parser or compiler suitable
for program analysis was available. We thus ﬁrst had to createa parser frontend using the parser generator CoCo/R [20] andan abstract syntax tree (AST) to represent the parsed sourcecode. Our AST implementation is based on Modisco [21], animplementation of the OMG ASTM standard that deﬁnes anAST meta model. Based on the AST, we generate Jimple codewhich is the input for the analysis framework Soot [17]. Adetailed description of our parser and analysis is available asa technical report [22].
The result of a CIA is a subgraph of the CSDG. We
thus also implemented a graph viewer based on the Eclipse
framework, which uses D3.js (http://d3js.org) to visualize the
results for developers. Our change impact visualization allowsto interactively expand the change impact. Users can inspectdetails like types, source code locations, presence conditions,and many other attributes of the nodes.
C. RQ1 – Domain engineering
As argued above, the beneﬁt of the conﬁguration-aware
CIA depends on the complexity of the variability information
and the contradictions of the presence conditions, which al-low pruning the change impact. Recall that in our approachvariability information is propagated based on the program
3900  5 k10 k15 k20 k25 k30 k35 k40 k
 0  0.1  0.2  0.3  0.4  0.5  0.6  0.7  0.8  0.9  1Number of change impacts
Portion of nodes with variability informationfamily0 (98 kLOC)
family1 (86 kLOC)
family2 (302 kLOC)
family3 (71 kLOC)
family4 (53 kLOC)
family5 (75 kLOC)
family6 (67 kLOC)
family7 (72 kLOC)
family8 (266 kLOC)
(a) RQ1 – Variability Complexity.0  2 k4 k6 k8 k10 k12 k14 k16 k18 k
 1  2  4  8  16  32Number of change impacts
Number of interacting variables
(b) RQ1 – Variability Interaction Order.
0  5 k10 k15 k20 k25 k30 k35 k40 k
 0  0.1  0.2  0.3  0.4  0.5  0.6  0.7  0.8  0.9  1Number of change impacts
Portion of contradicting nodes
(c) RQ1 – Contradicting Conditions Ratio.100  1 k10 k100 k
 0  0.1  0.2  0.3  0.4  0.5  0.6  0.7  0.8  0.9  1Number of change impacts
Relative size of the reduced change impact to original size
(d) RQ2 – Relative Change Impact Size.
Fig. 4: Results for RQ1 and RQ2 computed by applying our tool to a set of real-world product families provided by our industry partner.
dependencies and is therefore usually not visible directly in
the source code.
We deﬁne three metrics to characterize the variability of a
code base.
The V ariability Complexity is the ratio of edges with
variability information to the total number of edges within achange impact. Our approach is more beneﬁcial if more edgesare annotated with variability information, as this would makea manual CIA even harder.
The V ariability Interaction Order measures the average
number of involved distinct conﬁguration options in the vari-ability information. This is computed by counting the numberof distinct conﬁguration options in a single presence conditionand computing the mean of these numbers over all edges. Forexample, if the two presence conditions a∧band¬a∨care in
a change impact, the interaction measure would be
2+2
2=2.
This metric thus represents the interaction between differentconﬁguration options. The beneﬁt of the approach increaseswith the order of the variability interaction, as manuallyanalyzing complex interactions is hard to infeasible.
Contradicting Conditions Ratio. The propagation of pres-
ence conditions may result in contradicting presence condi-tions, which can never become valid, regardless of the productconﬁguration. Such invalid edges allow removing statementsfrom the change impact. Our measure is the ratio of invalidedges to the total number of edges. A higher value is betterbecause the change impact is smaller and more precise.Method. We performed the conﬁguration-aware CIA for
every single statement in the selected product families. Thiswas done in two phases: in phase 1 we built the CSDG forthe product family. This included parsing the source code,performing control ﬂow, data ﬂow and pointer analysis to buildthe SDG, and extracting the initial conditions from the sourcecode. In phase 2 we performed the conﬁguration-aware changeimpact analysis as outlined in Section III-D. Speciﬁcally, weiterated over allstatement nodes in the CSDG and performed
a conﬁguration-aware CIA.
Results. Figure 4a shows the results of our evaluation
for the metric V ariability Complexity. The x-axis shows the
complexity values, i.e, the portion of nodes with variabilityinformation. We grouped the values into intervals of width 0.1.
Thus the x-axis represents intervals ]0.0,0.1[,[0.1,0.2[, ...,
[0.9,1.0]– an interval is denoted by its middle value on the x-
axis. The y-axis is the number of change impacts contained ina certain interval. The chart shows the cumulative distributionof change impacts for these groups. For example, the datapoint at 0.65of the family2 says that approximately 25,000
change impacts had a variability complexity value in interval]0.0,0.7[. Therefore, a presence condition was available for up
to70% of the statements in the change impact.
Figure 4b shows the results for metric V ariability Interac-
tion Order. The x-axis shows the average number of conﬁgu-ration options involved in the presence conditions of a changeimpact. The y-axis is the number of change impacts that have acertain average number of involved conﬁguration options. For
391example, the family6 has a peak at x=4, i.e., around 6,000
change impacts involve on average 4conﬁguration options.
Figure 4c shows the results for metric Contradicting Con-
ditions Ratio. The x-axis shows the portion of nodes that are
invalid because of a contradicting condition. We again groupedthe values into intervals of width 0.1. The x-axis therefore
represents intervals ]0.0,0.1[,[0.1,0.2[, ..., [0.9,1.0]–a n
interval is denoted by its middle value on the x-axis. The y-axisagain represents the number of change impacts as in Figure 4a.The chart shows the cumulative distribution of change impactsfor these groups. For example, in family2 atx=0.15the size
of33,000change impacts could be reduced by up to 20%.
Discussion. The results of metric V ariability Complexity
shown in Figure 4a show that the approach is beneﬁcialgiven the complexity of variability in real-world systems. Thegraph shows a cumulative distribution function. The steepera line the more variability information is available in thecomputed change impacts. The chart also shows that largerproduct families provide even more variability information.For example, consider family2, the largest product family in
our study. It ﬁrst grows moderately until 0.45but then it starts
to grow faster, i.e., 50% of the statements in most change
impacts had variability information available. When combiningthe data in Figure 4a to one value, we see that overall thechange impacts have 50%-60% presence conditions available
on average (median). We therefore conclude that our approachis even more beneﬁcial in larger systems, as more variabilityinformation needs to be considered.
The results for metric V ariability Interaction Order shown
in Figure 4b show a similar picture. Dealing with interactionsinvolving 2or3conﬁguration options is already quite cumber-
some. The results show that the majority of all change impactshad presence conditions with up to 5conﬁguration options
involved on average. Other empirical studies have shown aninteraction degree of 2or3to be common [23], similar to
our results. However, there were also quite a few changeimpacts with higher numbers of 10to35conﬁguration options
perpresence condition, an order that is almost infeasible to
comprehend by developers.
In Section IV-A we described that our analysis is performed
on product families which have already been partially conﬁg-ured and can be compiled. Therefore, the product families’source code does not contain any mutually exclusive featureimplementations. So regarding the Contradicting Conditions
Ratio we did not expect a signiﬁcant increase of the pre-
cision of change impacts by ﬁnding contradicting presenceconditions. This did in fact happen for the analyzed productfamilies family0, family4, and family5. We see no increase in
the corresponding lines in Figure 4c, i.e., we could not removeany statements from the change impacts. However, we stillcould increase the precision of change impacts in the otherproduct families. For example, the difference between the lasttwo data points of family2 shows that it was even possible to
ﬁnd approximately 2,000change impacts whose size could be
reduced by 90–100%.
D. RQ2 – Application engineering
For this use case we perform CIA for a speciﬁc product
conﬁguration, i.e., we remove elements from the result thathave not been used in this speciﬁc conﬁguration. Again,we distinguish between change impacts with and withoutvariability information, because the latter one covers mostcommonly just library code, which is less interesting in termsof variability. We deﬁne metric Relative Change Impact Size
to measure the reduced numbers of edges in the changeimpact after evaluating the presence conditions compared tothe original change impact. The original change impact is theconﬁguration-aware change impact but ignoring the presenceconditions.
Method. Analogously to the method for RQ1, we per-
formed the conﬁguration-aware CIA for every single statementof our product families (phase 1). However, for answeringRQ2, we created concrete product conﬁgurations by randomlygenerating Boolean values for each known conﬁguration option(phase 2). When computing the change impact, the presenceconditions were then evaluated using these randomly generatedvalues for the conﬁguration options. We measured the reduc-tion of the change impact size compared to its original size.This was repeated 10 times with different generated values tocompute an average for the Relative Change Impact Size.
Results. Figure 4d shows the results for RQ2. Each line
corresponds to one of the analyzed product families. The x-axis and y-axis represent the same as in Figure 4a. The resultsare again grouped into intervals of width 0.1. For example,
the data point at x=0.85offamily4 means that the size of
approximately 800 change impacts has been reduced by 10%
to20%.
Discussion. We observe that evaluating the presence con-
ditions after computing the change impacts reduces the sizeto90% in most cases. Figure 4d shows a sharp edge at
the end of all lines, which means most change impacts arein the last group. We expected these numbers to be moredistributed across the other groups. But there are also manychange impacts that could be reduced to less than 80% of their
original size. To answer RQ2, we conclude that evaluating thepresence conditions yields noticeable beneﬁt for maintenancebecause fewer statements have to be considered, although weexpected to do better.
E. RQ3 – Performance
One major problem of static program analysis techniques
is commonly their analysis time. We therefore measured the
analysis time of our tool when analyzing our industry partner’sproduct families.
Method. The performance evaluation needs to consider both
building the CSDG and performing the conﬁguration-awareCIA. We already showed in [22] that building the CSDG,including the time needed to do all required analyses, is ina nearly linear relation to the size of the analyzed software.The same is true for the peak memory consumption. In thisevaluation, we thus report performance results for the technicalcontributions of this paper. We therefore measured the size ofall conﬁguration-aware change impacts and the time requiredto compute them (cf. phase 2 of RQ1 and RQ2).
Results. The results of this evaluation part are shown in
Figure 5. A cross in the chart represents a change impact. Thex-axis lists the size of the change impacts in terms of included
392 0 500 1000 1500 2000 2500 3000 3500
 0  20000  40000  60000  80000  100000  120000  140000Time [ms]
Size of change impact [#statements]
Fig. 5: RQ3 – Average time required to compute conﬁguration-aware
change impacts of a speciﬁc size.
statements. The y-axis shows the time required to compute the
change impacts in milliseconds. The performance evaluationhas been executed on an Intel Core i7-4770, 3.40 GHz, 16 GBDDR3-RAM machine running MS Windows 7 64-bit.
Discussion. The results show that the computation of a
change impact is fast and never takes longer than 3.5seconds.
It also seems that the time required to compute a changeimpact does not depend on its size because we cannot observeany linear or higher-order dependency on the change impactsize. We assume the time is dominated by the ﬁrst step ofthe CA-CIA algorithm, i.e., computing the backward sliceto determine the possible inﬂuencing presence conditions.However, computing the change impact is negligible comparedto the time required to build the SDG which took between 30
and270seconds [22].
F . Threats to V alidity
There is a potential bias caused by the selection of
product families in a speciﬁc application domain that havebeen developed in a speciﬁc programming language. We thuspresent detailed evaluation results and avoid generalizationsof how well the approach would work for other programminglanguages and PLs. However, our evaluation focuses on load-time conﬁguration options, a variability mechanism that iswidely used in all programming languages. Also, given thatcompanies typically do not provide access to data about theirproduct lines we believe that our evaluation results are valuableand promising.
Speciﬁcally, our evaluation is based on partially conﬁg-
ured product families, that have been derived from a productline by selecting all features deﬁned in a custom-developedconﬁgurator. We could not analyze the full code base of theproduct line, as the variability information is stored implicitlyin the conﬁgurator. As a result the evaluation is based on aless conﬁgurable code base, e.g., certain alternative featuresare not included. However, this means that the results wouldbe even more favorable for the full code base.
A prerequisite of our approach is that the mechanism for
implementing variability in source code is known. This couldbe a problem in software projects without any conventions forthis aspect, as extracting the initial conditions might not bepossible. However, related work [24] indicates that most ofthe time it is known how variability is realized. Furthermore,Reisner et al. [25] show that open source systems heavily useconﬁguration options to implement variability.
The analyzed product families are executed in a runtime
environment that provides library functions, whose implemen-tation is unknown. This is also a source of imprecision whenbuilding the CSDG. However, such system functions occurin almost all execution environments and must be handledappropriately. Our implementation handles this problem byassuming the worst case if something is not known. Forexample, if a system variable returns a reference to a variableand this reference cannot be determined, we assumed thatevery reference may be returned. This is the common strategyto preserve soundness but sacriﬁces precision.
We have taken several measures to mitigate the risk of in-
correct computations: we use the data ﬂow and pointer analysisof the widely used Soot tool suite to build the SDG, so we havea high conﬁdence that this part of the implementation producescorrect results. Furthermore, the part of our implementationthat extracts variability information from source code hasalready been reviewed by a developer of our industry partnerin a qualitative process in our previous work [8]. Finally, weperformed unit testing and manual reviews for the results basedon test input.
V. R
ELATED WORK
We structure our comparison to related work into work
concerning (i) tracking conﬁguration options, (ii) variability-aware program analysis, and (iii) program slicing and changeimpact analysis.
Tracking conﬁguration options. Lillack et al. [26] devel-
oped an approach for tracking load-time conﬁguration options.They use a modiﬁed taint analysis to determine source codedepending on conﬁguration options and also compute presenceconditions for the code. The propagation phase of our algo-rithm is comparable to their taint analysis, but their tool com-putes a different information. They create mappings betweenconﬁguration options and source code statements whereas ourapproach globally propagates variability information and pro-vides this information for an arbitrary change impact. Lillacket al. implemented their approach in a tool called LOTRACK
by modifying Soot’s taint analysis. The implementation ofour approach works at a higher level, i.e. the CSDG, andis therefore less dependent on the analysis implementationsrequired to build the CSDG. We think this is an importantproperty because modifying existing implementations is oftendifﬁcult and error prone.
Xu et al. [27] introduce a tool named SPEX that analyzes
a program’s source code to infer constraints for conﬁgura-tion options by tracking the data-ﬂow of each conﬁgurationvariable. They also use program slicing to reduce the domainto consider but only on a conﬁguration variable’s data ﬂowgraph. The reduced domain is then used to infer constraintsfor conﬁguration options by analyzing the statements usingthem. This is related to our approach, as we also analyze howa conﬁguration variable is used, by considering the data ﬂowgraph of the variable. However, their two-phase algorithm mayinfer invalid constraints, whereas the ﬁxpoint algorithm we use
393computes an over-approximation, i.e., the results are sound but
may provide false positives.
V ariability-aware program analysis. Several authors have
presented analysis techniques considering program-level vari-ability mechanisms. Variability-aware program analysis tech-niques exploit the similarities among individual variants toreduce program analysis effort. K ¨astner et al. [3] present the
tool TypeChef, which parses unpreprocessed C source code
and encodes the variability in the abstract syntax tree usingpresence conditions. Brabrand et al. [28] present an approachto automatically lift standard intraprocedural dataﬂow analy-ses to feature-sensitive analyses. A lifted analysis can thenanalyze the whole program space of a preprocessor-basedproduct line at once. Liebig et al. [1] provide variability-aware type checking and a variability-aware liveness analysisfor preprocessor-based product lines, also based on encodingvariability using Boolean formulas. They also use a ﬁxpointalgorithm to compute the result for single program elements,as in all dataﬂow analyses. The work introduces the patterns ofearly joining and late splitting, which is crucial for scalability.
While we also use these patterns to keep the number ofexplicitly stored result data minimal, our approach differswith respect to when the variability information is added.The above approaches extract variability information from avariable AST, then build a variable control ﬂow graph (CFG)and ﬁnally carry out the variability-aware analysis. In ourcase, the variability information is added in the last step afterbuilding SDG. However, considering variability in the AST andCFG could further increase the precision of building the CSDGand therefore improve the overall results of our analysis. Butsince in our context variability is mainly implemented usingrun-time conﬁguration options instead of
#IFDEF directives, we
do not need variability-aware parsing.
K¨astner et al. [29] provide comprehensive support for
creating feature models, locating feature code based on manualseeds, and rewriting code into conditional compilation andfeature modules. Our approach also employs program analysistechniques to build the CSDG. However, our goal is not tolocate or rewrite feature code, although the propagation of thepresence conditions could be used for feature location.
Zhang and Ernst [30] present the ConfDiagnoser approach
which uses static analysis, dynamic proﬁling, and statisticalanalysis to reveal the root cause of conﬁguration errors. Ourapproach also exploits static analysis techniques and usesconﬁguration ﬁles as input, however, we do not focus ondetermining conﬁguration options leading to an error. Reisneret al. [25] empirically analyze how conﬁguration options affectprogram behavior. In particular, the authors use symbolicevaluation to discover how run-time conﬁguration optionsaffect line, basic block, edge, and condition coverage fordifferent subject programs. We also compute the inﬂuenceof conﬁguration options to statements. Our approach is notlimited to compute the impact when changing a conﬁgurationoption, but works with arbitrary statements.
Program slicing and change impact analysis. Our approach
builds on earlier CIA research like Arnold et al. [4], orprogram slicing approaches as summarized in Xu et al. [31].In particular, the implementation of our approach is basedon the interprocedural program slicing technique describedby Horwitz et al. [16]. The approach presented in this paperfurther uses the CSDG we have presented in our previouswork [8]. In contrast to most existing change impact analysisapproaches, our approach extracts and propagates conditionsover the CSDG, similar to Snelting [15], who aims at in-creasing the accuracy of slices by eliminating impossibleexecution paths. This is done by extracting path conditionsfrom all conditional statements and employing an SMT solverto eliminate infeasible paths. In contrast, we only extractconditions considering conﬁguration variables and only dealwith variability that can be represented by Boolean formulas.Since we extract fewer conditions and can use a SAT solver forreasoning, our approach can deal with much larger programscompared to data reported by [7].
VI. C
ONCLUSIONS AND FUTURE WORK
This paper presented a conﬁguration-aware change impact
analysis approach, which is based on program slicing tech-niques and a conditional system dependence graph (CSDG),an extension of an SDG. The approach can deal with load-time conﬁguration options. It propagates presence conditionsrepresenting the variability of the analyzed software system.We implemented the approach based on the Soot analysisframework [17]. We additionally built a front end for Sootfor an industry partner’s software systems and programminglanguage. We then evaluated the beneﬁt and performance ofour approach on 9 product families of the industry partnerto investigate the distribution and complexity of variabilityinformation and the required analysis time.
Regarding RQ1 we found high variability complexity
demonstrating the beneﬁt for our approach in industrial-sizesystems. Speciﬁcally, in more than 50% of all computedchange impacts, 50% to60% of the impacted nodes carried
variability information. Regarding Variability Interaction Or-der, we also observed very high interaction orders of up to35 conﬁguration options. With respect to RQ2, the evaluationshowed a noticeable beneﬁt because fewer statements haveto be considered in maintenance tasks. Regarding RQ3, theruntime performance of building the SDG and computing thechange impacts allows the use of our technique in typicaldevelopment and maintenance tasks.
As future work, we plan to formalize our approach using
the framework by Midtgaard et al. [32], which allows toderive variability-aware analyses for software product lines.We want to show that our conﬁguration-aware CIA can bederived from a standard CIA approach. Furthermore, we alsoplan to extend our tool to support multi-language softwaresystems as outlined in [33]. This is important for industrialsoftware systems, which often comprise subsystems writtenin different languages. For instance, it is common practice toload conﬁguration options in one subsystem and communicatethis information to other subsystems using different languages.Performing a conﬁguration-aware CIA in such an environment,will require extensions to our approach allowing to jointlyanalyze the subsystems.
A
CKNOWLEDGMENT
This work has been conducted in cooperation with
Keba AG and has been supported by the Christian DopplerForschungsgesellschaft, Austria.
394REFERENCES
[1] J. Liebig, A. von Rhein, C. K ¨astner, S. Apel, J. D ¨orre, and C. Lengauer,
“Scalable analysis of variable software,” in Proc. of the 2013 9th Joint
Meeting on F oundations of Software Engineering (ESEC/FSE’13),N e w
York, NY , USA, 2013, pp. 81–91.
[2] T. Th ¨um, S. Apel, C. K ¨astner, I. Schaefer, and G. Saake, “A Classiﬁ-
cation and Survey of Analysis Strategies for Software Product Lines,”ACM Computing Surveys (CSUR), vol. 47, pp. 1–45, 2014.
[3] C. K ¨astner, P. G. Giarrusso, T. Rendel, S. Erdweg, K. Ostermann, and
T. Berger, “Variability-aware parsing in the presence of lexical macrosand conditional compilation,” in Proc. OOPSLA, 2011, pp. 805–824.
[4] R. S. Arnold, Software Change Impact Analysis. Los Alamitos, CA,
USA: IEEE Computer Society Press, 1996.
[5] L. Linsbauer, F. Angerer, P. Gr ¨unbacher, D. Lettner, H. Pr ¨ahofer,
R. Lopez-Herrejon, and A. Egyed, “Recovering feature-to-code map-pings in mixed-variability software systems,” in Proc. of the 30th Int’l
Conf. on Software Maintenance and Evolution (ICSME ’14), 2014.
[6] J. Rubin and M. Chechik, “A Framework for Managing Cloned Product
Variants,” in Proc. of the 35th Int’l Conf. on Software Engineering (ICSE
2013), 2013, pp. 1233–1236.
[7] C. Hammer, J. Krinke, and G. Snelting, “Information ﬂow control for
Java based on path conditions in dependence graphs,” in Proc. IEEE
Int’l Symposium on Secure Software Engineering, 2006, pp. 87–96.
[8] F. Angerer, H. Pr ¨ahofer, D. Lettner, A. Grimmer, and P. Gr ¨unbacher,
“Identifying Inactive Code in Product Lines with Conﬁguration-AwareSystem Dependence Graphs,” in Proc. of the 18th Int’l Software Product
Line Conf. (SPLC 2014), Florence, Italy, 2014.
[9] D. Lettner, F. Angerer, H. Pr ¨ahofer, and P. Gr ¨unbacher, “A Case
Study on Software Ecosystem Characteristics in Industrial AutomationSoftware,” in Proc. of the Int’l Conf. on Software and Systems Process
(ICSSP 2014), Nanjing, China, 2014.
[10] D. Lettner, F. Angerer, P. Gr ¨unbacher, and H. Pr ¨ahofer, “Software
Evolution in an Industrial Automation Ecosystem: An ExploratoryStudy,” in Proc. Int’l Euromicro Conf. on Software Engineering and
Advanced Applications, Verona, Italy, 2014.
[11] K. C. K. Chen and V . Rajich, “RIPPLES: tool for change in legacy
software,” Proc. IEEE Int’l Conf. on Software Maintenance. ICSM 2001,
2001.
[12] J. J ´asz, A. Besz ´edes, T. Gyim ´othy, and V . Rajlich, “Static execute
after/before as a replacement of traditional software dependencies,” inIEEE Int’l Conf. on Software Maintenance, ICSM, 2008, pp. 137–146.
[13] S. Bohner, “Extending software change impact analysis into COTS
components,” 27th Annual NASA Goddard/IEEE Software Engineering
Workshop, 2002. Proceedings., 2002.
[14] S. Black, “Computing ripple effect for software maintenance,” Journal
of Software Maintenance and Evolution: Research and Practice, vol. 13,
no. 4, pp. 263–279, 2001.
[15] G. Snelting, “Combining slicing and constraint solving for validation of
measurement software,” in Static Analysis SE - 23, ser. Lecture Notes
in Computer Science, R. Cousot and D. Schmidt, Eds. Springer BerlinHeidelberg, 1996, vol. 1145, no. Springer, pp. 332–348.
[16] S. Horwitz, T. Reps, and D. Binkley, “Interprocedural slicing using
dependence graphs,” ACM Transactions on Programming Languages
and Systems (TOPLAS), vol. 12, no. 1, pp. 26–60, 1990.
[17] P. Lam, E. Bodden, O. Lhot ´ak, and L. Hendren, “The Soot framework
for Java program analysis: a retrospective,” in Cetus Users and Compiler
Infastructure Workshop (CETUS 2011), 2011.
[18] D. Lettner, M. Petruzelka, R. Rabiser, F. Angerer, H. Pr ¨ahofer, andP. Gr ¨unbacher, “Custom-developed vs. model-based conﬁguration tools:
Experiences from an industrial automation ecosystem,” in Proc. of the
17th Int’l Software Product Line Conf. (SPLC ’13 Workshops).N e wYork, NY , USA: ACM, 2013, pp. 52–58.
[19] IEC, “IEC 61131-3, programmable controllers - part 3: Programming
languages,” 2003. [Online]. Available: http://www.iec.ch/
[20] A. W ¨oß, M. L ¨oberbauer, and H. M ¨ossenb ¨ock, “LL(1) conﬂict resolution
in a recursive descent compiler generator,” in Modular Programming
Languages, ser. Lecture Notes in Computer Science. Springer BerlinHeidelberg, 2003, vol. 2789, pp. 192–201.
[21] H. Bruneliere, J. Cabot, G. Dup ´e, and F. Madiot, “Modisco: A model
driven reverse engineering framework,” Information and Software Tech-
nology, vol. 56, no. 8, pp. 1012–1032, 2014.
[22] A. Grimmer, F. Angerer, H. Pr ¨ahofer, and P. Gr ¨unbacher, “Developing a
Multi-language Program Analysis Approach for Industrial AutomationSystems: Experiences and Lessons Learned,” Christian DopplerLaboratory MEVSS, Johannes Kepler University Linz, TechnicalReport, 2015. [Online]. Available: http://tinyurl.com/odrkkoe
[23] S. Apel, S. Kolesnikov, N. Siegmund, C. K ¨astner, and B. Garvin, “Ex-
ploring Feature Interactions in the Wild: The New Feature-interactionChallenge,” in Proc. of the 5th Int’l Workshop on Feature-Oriented
Software Development, ser. FOSD ’13. New York, NY , USA: ACM,2013, pp. 1–8.
[24] T. Berger, S. She, and R. Lotufo, “Variability Modeling in the Real :
A Perspective from the Operating Systems Domain,” Measurement, pp.
73–82, 2010.
[25] E. Reisner, C. Song, K.-K. Ma, J. S. Foster, and A. Porter, “Using
symbolic evaluation to understand behavior in conﬁgurable softwaresystems,” in Proc. of the 32nd ACM/IEEE Int’l Conf. on Software
Engineering-V olume 1. ACM, 2010, pp. 445–454.
[26] M. Lillack, C. K ¨astner, and E. Bodden, “Tracking Load-time Conﬁgura-
tion Options,” in Proc. of the 29th ACM/IEEE Int’l Conf. on Automated
Software Engineering, ser. ASE ’14. New York, NY , USA: ACM, 2014,pp. 445–456.
[27] T. Xu, J. Zhang, P. Huang, J. Zheng, T. Sheng, D. Yuan, Y . Zhou, and
S. Pasupathy, “Do Not Blame Users for Misconﬁgurations,” in Proc. of
the Twenty-F ourth ACM Symposium on Operating Systems Principles,ser. SOSP ’13. New York, NY , USA: ACM, 2013, pp. 244–259.
[28] C. Brabrand, M. Ribeiro, T. Tol ˆedo, and P. Borba, “Intraprocedural
Dataﬂow Analysis for Software Product Lines,” in Proc. of the 11th
Annual Int’l Conf. on Aspect-oriented Software Development , ser.
AOSD ’12. New York, NY , USA: ACM, 2012, pp. 13–24.
[29] C. K ¨astner, A. Dreiling, and K. Ostermann, “Variability mining: Con-
sistent semi-automatic detection of product-line features,” IEEE Trans.
Software Eng., vol. 40, no. 1, pp. 67–82, 2014.
[30] S. Zhang and M. D. Ernst, “Automated diagnosis of software conﬁgura-
tion errors,” in 35th Int’l Conf. on Software Engineering, San Francisco,
CA, USA, 2013, pp. 312–321.
[31] B. Xu, J. Qian, X. Zhang, Z. Wu, and L. Chen, “A brief survey of
program slicing,” SIGSOFT Softw. Eng. Notes, vol. 30, no. 2, pp. 1–36,
Mar. 2005.
[32] J. Midtgaard, C. Brabrand, and A. Wasowski, “Systematic Derivation
of Static Analyses for Software Product Lines,” in Proc. of the 13th
Int’l Conf. on Modularity, ser. MODULARITY ’14. New York, NY ,USA: ACM, 2014, pp. 181–192.
[33] F. Angerer, “Variability-aware Change Impact Analysis of Multi-
language Product Lines (Doctoral Symposium Paper),” in Proc. of
the 29th ACM/IEEE Int’l Conf. on Automated Software Engineering(ASE’14). New York, NY , USA: ACM, 2014, pp. 903–906.
395