Repairing Crashes in Android Apps
Shin Hwei Tan∗
Southern University of Science and Technology
shinhwei@hotmail.comZhen Dong
National University of Singapore
zhen.dong@comp.nus.edu.sg
Xiang Gao
National University of Singapore
gaoxiang@comp.nus.edu.sgAbhik Roychoudhury
National University of Singapore
abhik@comp.nus.edu.sg
ABSTRACT
Android apps are omnipresent, and frequently suffer from crashes
— leading to poor user experience and economic loss. Past work
focused on automated test generation to detect crashes in Android
apps.However,automatedrepairofcrasheshasnotbeenstudied.
In this paper, we propose the first approach to automatically re-
pairAndroidapps,specificallyweproposeatechniqueforfixing
crashes in Android apps. Unlike most test-based repair approaches,
wedonotneedatest-suite;insteadasinglefailingtestismeticu-
louslyanalyzedforcrashlocationsandreasonsbehindthesecrashes.
Ourapproachhingesonacarefulempiricalstudywhichseeksto
establish common root-causes for crashes in Android apps, and
then distills the remedy of these root-causes in the form of eight
generictransformationoperators.Theseoperatorsareappliedusingasearch-basedrepairframeworkembodiedinourrepairtool Droix.
Wealsoprepareabenchmark DroixBench capturingreproducible
crashesinAndroidapps.Ourevaluationof DroixonDroixBench
reveals that the automatically produced patches are often syntacti-
callyidenticaltothehumanpatch,andonsomerareoccasioneven
better than the human patch (in terms of avoiding regressions).
These results confirm our intuition that our proposed transforma-
tions form a sufficient set of operators to patch crashes in Android.
CCS CONCEPTS
•Software and its engineering →Automatic programming ;
Software testing and debugging; Dynamic analysis ;
KEYWORDS
Automated repair, Android apps, Crash, SBSE
ACM Reference Format:
Shin Hwei Tan, Zhen Dong, Xiang Gao, and Abhik Roychoudhury. 2018.
Repairing Crashes in Android Apps. In ICSE ’18: ICSE ’18: 40th International
Conference on Software Engineering , May 27-June 3, 2018, Gothenburg, Swe-
den.ACM,NewYork,NY,USA,12pages.https://doi.org/10.1145/3180155.
3180243
∗Thisworkwasdoneduringtheauthor’sPhDstudyatNationalUniversityofSingapore
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5638-1/18/05...$15.00
https://doi.org/10.1145/3180155.31802431 INTRODUCTION
Smartphones have become pervasive, with 492 millions sold world-
wideintheyearof2011alone[ 21].Userstendtorelymoreontheir
smartphonestoconducttheirdailycomputingtasksassmartphones
arebundledwithvariousmobileapplications.Hence,itisimportant
to ensure the reliability of apps running in their smartphones.
Testing and analysis of mobile apps, with the goal of enhancing
reliability,havebeenstudiedinpriorwork.Someoftheseworks
focusonstaticanddynamicanalysisofmobileapps[ 2,7,18,56],
while other works focus on testing of mobile apps [ 3,4,30,31,43].
To further improve the reliability of mobile applications, several
approachesgobeyondautomatedtestingofappsbyissuingsecurity-related patches [
6,39]. While fixing security-related vulnerabilities
isimportant,asurveyrevealedthatmostoftherespondentshave
experiencedaproblemwhenusingamobileapplication,with62percent of them reported a crash, freeze or error [
1]. Indeed, fre-
quentcrashesofanappwillleadtonegativeuserexperienceandmayeventuallycauseuserstouninstalltheapp.Inthispaper,we
study automated approaches which alleviate the concern due to
app crashes via the use of automated repair.
Recently, several automated program repair techniques have
been introduced to reduce the time and effort in fixing softwareerrors [
24,28,35,40,42,52]. These approaches take in a buggy
program Pand some correctness criterion in the form of a test-
suiteT, producing a modified program P/primewhich passes all tests in
T.Despiterecentadvancesinautomatedprogramrepairtechniques,
existing approaches cannot be directly applied for fixing crashes
found in mobile applications due to various challenges.
Thekeychallengeinadoptingautomatedrepairapproachesto
mobileapplicationsisthatthequalityofthegeneratedpatchesis
heavilydependentonthequalityofthegiventestsuite.Indeed,anyrepairtechniquetriestopatcherrorstoachievetheintendedbehav-
ior. Yet, in reality, the intended behavior is incompletely specified,
oftenthroughasetoftestcases.Thus,repairmethodsattemptto
patch a given buggy program, so that the patched program passes
alltestsinagiventest-suite T(Wecallrepairtechniquesthatuse
test cases to drivethe patch generation process test-driven repair ).
Unsurprisingly,test-drivenrepairmaynotonlyproduceincomplete
fixes but the patched program may also end up introducing new
errors,becausethepatchedprogrammayfailtestsoutside T,which
werepreviouslypassing[ 45,49].Meanwhile,severaluniqueproper-
tiesof testcasesfor mobileapplicationspose uniquechallengesfor
test-driven repair. First, regression test cases may not be available
foragivenmobileapp A.Whilepriorresearchesonautomatedtest
generationformobileappscouldbeusedforgeneratingcrashing
1872018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:51:40 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Shin Hwei Tan, Zhen Dong, Xiang Gao, and Abhik Roychoudhury
inputs,regressiontestinputsthatensurethecorrectbehaviorsof
Aareoftenabsent.Secondly,insteadofsimpleinputs,testinputs
formobileappsareoftengivenasasequenceofUIcommands(e.g.,
clicksandtouches)leadingto crashesintheapp.Meanwhile,GUI
tests are often flaky [ 29,36]: their outcome is non-deterministic
for the same program version. As current repair approaches rely
solely on the test outcomes for their correctness criteria, they may
not be able to correctly reproduce tests behavior and subsequently
generate incorrect patches due to flaky tests.
Anotherkeychallengeinapplyingrecentrepairtechniquesto
mobile applications lies on their reliance on the availability of
source code. However, mobile applications are often distributedas standard Android .apk files since the source code for a given
version of a mobile app may not be directly accessible nor actively
maintained.Moreover,whilepreviousautomatedrepairtechniques
areappliedforfixingprogramsusedbydevelopersandprogram-
mers, mobile applications may be utilized by general non-technical
users who may not have any prior knowledge regarding source
code and test compilations.
Wepresentanovelframework,called Droixforautomatedrepair
of crashes in Android applications. In particular, our contributions
can be summarized as follows:
Android repair: WeproposeanovelAndroidrepairframework
that automatically generates a fixed APK given a buggy APK and
aUI test.Android applicationswerenot studiedinprior workin
automated program repair, butvarious researches on analysis [ 2,
7,18,56] and automated testing [ 3,4,30,31,43] illustrate the
importance of ensuring the reliability of Android apps.
Repairing UI-based test cases: Differentfromexistingrepairap-
proaches based on a set of simple inputs, our approach fixes a
crash with a single UI event sequence. Specifically, we employtechniques allowing end users to reproduce the crashing event
sequence by recording user actions on Android devices instead of
writing test codes. The crashing input could be either recorded
manually byusers or automatically generatedby GUI testingap-
proaches [30, 47].
Lifecycle-aware transformations Ourapproachisdifferentfrom
existing test-driven repair approaches since it does not seek tomodify a program to pass a given test-suite. Instead, it seeks torepair the crashes witnessed by a single crashing input, by em-ploying program transformations which are likely to repair the
root-causes behind crashes. We introduce a novel set of lifecycle-
aware transformations that could automatically patch crashing
androidappsbyusingmanagementrulesfromtheactivitylifecycle
and fragment lifecycle.
Evaluation: We propose DroixBench, a set of 24 reproducible
crashes in 15 open source Android apps. Our evaluation on 24
defects shows that Droix could repair 15 bugs, and seven of these
repairs are syntactically equivalent to the human patches.
2 BACKGROUND: LIFECYCLE IN ANDROID
Different from Javaprograms, Android applications donot have a
single main method. Instead, Android apps provide multiple entry
pointssuchas onCreate andonStartmethods.Viathesemethods,
Android framework is able to control the execution of apps and
maintain their lifecycle.onCreate()
onStart()
onResume()
onPause()
onStop()onActivityCreated()
onDestroy()onCreateView()onCreate()onAttach()
onStop()onPause()onResume()onStart()
onDetach()onDestroy()onDestroyView()Activity 
launched
Activity
running
Activity
shutdown Fragment is destroyedonRestart()Created
Started
Resumed
Paused
Stopped
DestroyedFragment is activeFragment is added
User navigates 
to the activity
User returns 
to the activityApp process
killedUser navigates 
to the activity
App with higher
priority need memory
The fragment
returns to the 
layout from back stackAnother activity comes 
into the foreground
The activity is 
no longer visible
The activity is finishing or 
being destroyed by the systemUser navigates backward 
or fragment is 
removed/replacedFragment is added to 
the back stack, 
then removed/replaced
Activity lifecycle Fragment lifecycle
Figure 1: Activity Lifecycle, Fragment Lifecycle and the Activity-
Fragment Coordination
Figure1showsthelifecyclesofactivityandfragmentinAndroid.
EachmethodinFigure1representsalifecycle callback,amethod
that getscalled given achange ofstate. Lifecycle transitionobeys
certainprinciples.Forinstance,anactivitywiththepausedstate
could move to the resumed state or the stopped state, or may be
killed by the Android system to free up RAM.
Afragment isaportionof userinterfaceorabehaviorthat can
beputinanActivity.Eachfragmentcanbemodifiedindependentlyofthehostactivity (activitycontainingthefragment)byperforming
a setof changes. Fora fragment, itgoes through morestates than
anActivityfrombeinglaunchedtotheactivestate,e.g., onAttach
andonCreateView states.
Thecommunicationbetweenanactivityandafragmentneeds
toobeycertainprinciples.Afragmentisembeddedinanactivity
and could communicate with its host activity after being attached.
The allowed states of a fragment are determined by the state of
its host activity. For instance, a fragment is not allowed to reach
theonStartstate beforeits host activity entersthe onStartstate. A
violation of these principles may cause crashes in Android apps.
3 A MOTIVATING EXAMPLE
Weillustratetheworkflowofourautomatedrepairtechniqueby
showinganexampleapp,anditscrash.ThecrashoccurredinTran-
sistor,aradioappforAndroidwith63starsinGitHub.According
tothebugreport1,Transistorcrasheswhenperformingtheevent
sequence shown in Figure 2: (a) starting Transistor; (b) shutting it
downbypressingthesystembackbutton;(c)startingTransistor
again and changing the icon of any radio station. Then, it crashes
with a notification “Transistor keeps stopping”(d). Listing 1 shows
thelogrelevanttothiscrash.ThestacktraceinformationinListing1
suggests that the crash is caused by IllegalStateException.
1https://github.com/y20k/transistor/issues/21
188
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:51:40 UTC from IEEE Xplore.  Restrictions apply. Repairing Crashes in Android Apps ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
(a) Open Transistor (b) Press back
(C) Open again and change an icon (d) Crashed with a notification
Figure 2: Continuous snapshots of a crash in Transistor.
Our automated repair framework, Droix performs analysis of
the Activity-Fragment coordination (dashed lines in Figure 1) and
reportspotentialviolationsinthecommunicationbetweenafrag-
ment and its host activity. Our manual analysis of the source code
forthis appfurtherreveals that thecrashoccurs becausethefrag-
ment attempts to call an inherited method startActivityForResult
atline482,whichindirectlyinvokesamethodofitshostactivity.
However, the fragment is detached from the previous activity dur-
ingtheterminationoftheappandneedstobeattachedtoanew
activityintherestartingapp.Themethodinvocationoccursbefore
thenewactivityhasbeencompletelycreatedandleadstothecrash.
FATAL EXCEPTION: mainProcess: org.y20k.transistor , PID: 2416
java.lang.IllegalStateException:
Fragment M ainActivityFragment {82e1bec} not attached to Activity
at android ... startActivityForResult( Fragment.java:925)
at y20k... selectFromImagePicker(MainA ctivityFragment.java:482)
Listing 1: Stack trace for the crash in Transistor
if(getActivity()!= null)
482: startActivityForResult(pickImageIntent , REQUEST_LOAD_IMAGE) ;
Listing 2: Droix’s patch for the crash in Transistor
startActivityForResult(pickImageIntent , REQUEST_LOAD_IMAGE) ;
482:mActivity.st artActivityForResult(pickImageIntent ,
REQUEST_LOAD_IMAGE) ;
Listing 3: Developer’s patch for the crash in Transistor
Droix defines specific repair operators based on our study of
crashes in Androidapps and the AndroidAPI documentation (see
Section 4). One of the transformation operators identified through
our study, GetActivity-check , is designed to check if the ac-
tivity containing the fragment has been created. The condition
getActivity()!=null prevents the scenario where a fragment
communicates with its host activity before the activity is created.
Listing 2 shows the patch automatically generated by Droix.
Withthepatch,method startActivityForResult willnotbein-
vokedifthehostactivityhasnotbeencreated.Therelatedfunction
(i.e., changing station icon) works well after our repair. In con-
trast,althoughthedeveloper’spatchdoesnotcrashonthegiven
input, it introduces regressions. Listing 3 shows the developer’s
patch where mActivity is a field of the fragment referencing its
host activity. When restarting the app, this field still points tothepreviouslyattachedactivity.Thedeveloper’spatchexplicitlyinvokes
startActivityForResult method of the previously at-
tachedactivityinsteadofthenewlycreatedactivity.Afterapplying
theDeveloper’spatch,auserreportsthatthesystembackbutton
nolonger functionscorrectlywhen changingthestation icon(i.e.,
pressing the back button does not close the app but mistakenly
opensawindowforselectingimages).Specifically,theuserreports
thefollowingeventsequencewhentheappfailstofunctionprop-
erly: open Transistor →tap to change icon →press
back twice→open Transistor →tap to change icon →
press back twice . Wetest theAPK generated byDroix with this
eventsequence,andweobservethatourfixedAPKdoesnotexhibitthefaultybehaviorreportedbytheuser.Hence,webelievethatthe
patch generated by Droix works better than the developer’s patch.
4 IDENTIFYING CAUSES OF CRASHES IN
ANDROID APPLICATIONS
To study the root causes of crashes in Android apps, we man-
ual inspect Android apps on GitHub and API documentation (as
priorworkhasshowedsuccessinfindingbugsviaAPIdocumen-
tation [48]). Our goal is to identify a set of common causes for
Android crashes. We first obtain a set of popular Android apps by
crawling GitHub and searching for the word “android app” written
in Java using the GitHub API2. For each app repository, we search
forclosedissues(resolvedbugreport)withtheword“crash”.We
focusonclosedissuesbecausethoseissueshavebeenconfirmedby
the developers and are more likely to contain fixes for the crashes.
From the list of closed issues on app crashes, we further extract
issuesthatcontainatleastonecorrespondingcommitassociated
withthecrash.Thefinaloutputofourcrawlerisalistofcrashes-
relatedclosedissuesthathavebeenfixedbythedevelopers.Overall,
ourcrawlersearchesthrough7691GitHubclosedissueswhere1155
(15%) of these issues are related to crashes. The relatively high per-
centage of crash-related issues indicates the prevalence of crashes
inAndroidapps.Amongthese1155issues,107oftheseissuesfrom
15 different apps have corresponding bug-fixing commits. We man-
ually analyzed all issues and attempted to answer two questions:
Q1:What arethe possible root causesand exceptions that leadto
crashes in Android apps?
Q2:How does the complexity of activity/fragment lifecycle affect
crashes in Android apps?
Westudy Q2becauseasurveyofAndroiddeveloperssuggests
that the topmost reasons (47%) for NullPointerException in An-
droid apps occur due to the complexity of activity/fragment life-
cycle[18].Ourgoalistoidentifyasetofgenerictransformations
that areoften usedby Androiddevelopers in fixingAndroid apps.
To gain deeper understanding of the root causes of each crash (Q1)
andtoidentifytheaffectofactivity/fragmentlifecycleonthelikeli-
hoodofintroducingcrashes(Q2),wemanuallyexaminelifecycle
management rules in the official Android API documentations3.
Our study shows that the most common exceptions are:
•NullPointerException (40.19%)
•IllegalStateException (7.48%)
2https://developer.github.com/v3/
3https://developer.android.com/guide/components/activities/activity-lifecycle.html
189
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:51:40 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Shin Hwei Tan, Zhen Dong, Xiang Gao, and Abhik Roychoudhury
Table 1: Root cause of crashes in Android apps
Category Specific reason Description GitHub Issues (%) Frequent Exception Type Category Total (%)
LifecycleConfiguration changes activity recreation during configuration changes 5.61 NullPointer
14.02Stateloss transaction loss during commit 2.80 IllegalState
GetActivity activity-fragment coordination 2.80 IllegalState
Activity backstack inappropriate handling of activity stack 1.87 IllegalArgument
Save instance uninitialized object instances in onSaveInstance() callback 0.93 IllegalState
ResourceResource-related resource type mismatches 10.28 NullPointer16.82Resource limit limited resources 4.67 OutOfMemory
Incorrect resource retrieve a wrong resource id 1.87 SQLite
CallbackActivity-related missing activities 7.48 NullPointer
17.76View-related missing views 6.54 NullPointer
Intent-related missing intents 3.74 NullPointer
Unhandled callbacks missing callbacks 2.80 NullPointer
OthersMissing Null-check missing check for null object reference 12.15 NullPointer
52.34External Service/Library defects in external service/library 8.41 NullPointer
Workaround temporary fixes for defect 4.67 IndexOutOfBound
API changes API version changes 2.80 SQLite
Others project-specific defects 24.30 -
Thehighpercentageof NullPointerException confirmswiththe
findings of prior study of Android apps [18].
Table 1 shows the common root causes of crashes in Android
apps we investigated. Column “Category" in Table 1 describes the
high-level causes of the crashes, while the “Specific reasons" col-
umngivesthespecificcausesthatleadtothecrash.Thelastcolumn
(Category Total (%)) presents the total percentage of issues that fits
intoaparticularcategory.Overall,14.02%ofcrashesinourstudy
occur due to the violation of management rules for Android Activ-
ity/Fragment lifecycles. The reader can refer to Section 5 on the
explanationoftheselifecycle-relatedcrashes.Meanwhile,16.82%of
the investigated crashes are due to improper handling of resources,
includingresourceseithernotavailable(Resource-related)orlim-
itedresourceslikememory(Resourcelimit).Furthermore,improper
handling of callbacks contributes to 17.76% of crashes. Note that
this“Callback"categorydenotesimplementation-specificproblemsofdifferentcomponentsinAndroidlibrary(e.g.,Activity,Viewand
Intent).Among40.19%ofNullPointerExceptionsthrowninthese
crashing apps, only 12.15% is related to missing the check for null
objects (Missing Null-check). Interestingly, 4.67% of the GitHub is-
sues include comments by Android developers acknowledging the
factthatthepatchissuedaremerelytemporaryfixes(Workaround)
for these crashes that may require future patches to completely
resolve the crash.
Overall, Table 1 shows that the complexity of activity/fragment
lifecycle and incorrect resource handling are two general causes
of crashes in Android apps. Moreover, “Missing Null-check" in the
“Other" category also often leads to crashes in Android apps.
5 STRATEGIES TO RESOLVE CRASHES
Our manual analysis of crashes in Android apps identifies eight
programtransformationoperatorswhichareusefulforrepairing
thesecrashes.Table2givesanoverviewofeachoperatorderived
throughouranalysis.As“MissingNull-check"isoneofthecommon
causes of crashes in Table 1, we include this operator (S7: Null-check) in our set of operators. Another frequently used operator
(5%) that fixes crashes that occur across different categories inTable 1 is inserting exception handler (S8: Try-catch) which we
alsoincludeintooursetofoperators.WenowproceedtodiscussTable 2: Supported Operators in Droix
Operator Description
S1: GetActivity-checkInsert a condition to check whether the activity containing
the fragment has been created.
S2: Retain object Store objects and load them when configuration changes
S3: Replace resource id Replace resource id with another resource id of same type.
S4: Replace methodReplace the current method call with another method callwith similar name and compatible parameter types.
S5: Replace cast Replace the current type cast with another compatible type.
S6: Move stmt Removes a statement and add it to another location.
S7: Null-check Insert condition to check if a given object is null.
S8: Try-catch Insert try-catch blocks for the given exception.
other program transformation operators in Table 2 and the specific
reasons of crashes associated with each operator in this section.
Retain stateful object Configuration changes (e.g., phone rota-
tion and language) cause activity to be destroyed and recreated
which allowsapps to adaptto new configuration(transition from
onDestroy()→ onCreate() ). According to Android documenta-
tion4, developer could resolve this kind of crashes by either (1)
retainingastatefulobjectwhentheactivityisrecreatedor(2)avoid-ingtheactivityrecreation.Wechoosethefirststrategybecauseitis
more flexible as it allows activity recreations instead of preventing
theconfigurationchangesaltogether.Listing4presentsanexample
that explains how we retain the Optionobject by using the saved
instance after the configuration changes to prevent null reference
of the object (S2: Retain object).
public void onCreate(B undlesavedInstanceState) {
super.onCreate(s avedInstanceState);
setRetainInstance( true);// retain this fragment
}
// new field for saving the object
private static Option saveOption;
public View onCreateView(LayoutInflater inflater ,
ViewGroup conta iner , Bundle s avedInstanceState) {
// saving and loading the object
if(option!= null){ saveOption = option; }
else{ option = saveOption; }
switch (option.g etButtonStyle()) { //crashing point
Listing 4: Example of handling crashes during configuration
changes
4https://developer.android.com/guide/topics/resources/runtime-changes.html
190
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:51:40 UTC from IEEE Xplore.  Restrictions apply. Repairing Crashes in Android Apps ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Commit transactions Each fragment can be modified indepen-
dently of the host activity by performing a set of changes. Each
set of changes that we commit(perform requested modifications
atomically) to the activity is called a transaction. Android docu-
mentation5specifiesrulestoprohibit committingtransactionsat
certain stages of the lifecyle. Transactions that are committed indisallowed stages will cause the app to throw an exception. Forexample, invoking
commit() after onSaveInstanceState() will
leadto IllegalStateException sincethetransactioncouldnotbe
recorded during this stage. We employ two strategies for resolving
the incorrect commits: (S6: Move stmt) moving commit() to a le-
gal callback (e.g., onPostResume()), (S4: Replace method) replacing
commit() with commitAllowingStateLoss().
Communicationbetweenactivityandfragment Thelifecycle
ofafragmentisaffectedbythelifecycleofitshostactivity6.For
example,inFigure1,whenanactivityiscreated( onCreate() ),the
fragmentcannotproceedbeyondthe onActivityCreated() stage.
Invoking getActivity() in the illegal stage of the lifecycle will
return null,sincethehostactivityhasnotbeencreatedorthefrag-
ment is detached from its host activity. A NullPointerException
maybe throwninthe followingexecution.We employtwostrate-
giesforresolvingthisproblem:(S1:GetActivity-check)inserting
condition if(getActivity()==null) , and (S6: Move stmt) mov-
inggetActivity() to another stage (when the host activity is
created and the fragment is not detached from the host activity) of
the fragment lifecycle.
Retrieve wrong resource id Androidresources are the additional
filesand staticcontentused inAndroidsource code(e.g.,bitmaps,
andlayout)7.Aresourceid isoftheform R.x.ywherexrefersto
the type of resource and y represents the name of the resource.
Theresourceidis definedin XMLfilesand itisthe parameterof
several Android API (e.g., findViewbyId(id) andsetText(id) ).
Android developers may mistakenly use a non-existing resource
idwhichleadsto Resources$NotFound exception.Listing5shows
a scenario where the developers change the string resource id (S3:
Replace resource id).
intmsgStrId = R.s tring.confirmation_remove_alert;
intmsgStrId = R.s tring.c onfirmation_remove_file_alert;
Listing 5: Example of handling crashes due to wrong resource id
Incorrect type-cast of resource ToimplementUIinterfaces,an
Android API8(findViewById(id) ) could be invoked to retrieve
widgets (view) in the UI. As each widget is identified by attributes
defined in the corresponding XML files, an Android developer
may misinterpret the correct type of a widget, resulting in crashes
due to ClassCastException . We repair the crash by replacing the
type cast expression with correct type (S5: Replace cast). Listing 6
shows an example where the ImageButton object is incorrectly
type caster.
mDefinition=(TextView) findViewById(R.id. definition);
mDefinition=(ImageButton) findViewById(R.id. definition);
Listing 6: Example fix for incorrect resource type-cast
5https://developer.android.com/reference/android/app/FragmentTransaction.html
6https://developer.android.com/guide/components/fragments.html7https://developer.android.com/guide/topics/resources/accessing-resources.html
8https://developer.android.com/reference/android/app/Activity.html6 METHODOLOGY
Figure3presentstheoverallworkflowofDroix’srepairframework.
Droixconsistsofseveralcomponents:atestreplayer,aloganalyzer,
amutantgenerator,atestchecker,acodechecker,andaselector.
Given a buggy APKPand UI event sequences Uextracted from its
bug report, Droix produces a patched APKP/primethat passes Uand has
the minimum number of properties violations.
Droixfixesacrashusingatwo-phaseapproach.Inthefirstphase,
Droixgeneratesaninstrumented APKItologallexecutedcallbacks.
With the instrumented APK, Droix replays the UI event sequences
Uonadevice.Theloganalyzerparsesthelogsdumpedfromthe
execution,extractsprogramlocations Locsfromthestacktrace,and
identifies test-level property Rtorigusing the recorded callbacks.
Inthesecondphase,Droixdecompiles APKPtotheintermedi-
aterepresentation.Then,ourmutantgeneratorproducesasetof
candidate apps (stored in the mutant pool) by applying a set of
operators at each location linLocs. For each operator op, our code
checkerrecordscode-levelproperty Rccandbasedontheprogram
structure of land the information in thrown exception. For each
candidate APKC,Droixreinstalls APKContothedeviceandreplays
UonAPK C. Then, our log analyzer parses the dumped logs that
includetheexecutioninformationofcallbackmethodstoextract
new buggy locations and information of test-level property Rtcand.
Givenasinput RtcandforAPKC,thetestcheckercompares Rtorig
withRtcandtocheckif APKCintroducesanynewpropertyviola-
tions.Finally,ourevaluatoranalyzes RtcandandRccandtocompute
the number of property violations and passes the results to the
selector, which chooses the best app as the final fixed APK.
6.1 Test with UI Sequences
Existing techniques in automated program repair typically rely on
unit tests [ 32] or test scripts [ 28,35,53] to guide repair process. As
additionalUItestsforcheckingcorrectnessareoftenunavailable,
Droix uses user event sequences (e.g., clicks and touches) as input
torepairbuggyapps,whichintroducesnewchallenges:(1)these
eventsequencesareoftennotincludedaspartofthesourcecode
repository and reproducing these event sequences is often time-
consuming;(2)ensuringthatarecordedsequencehasbeenreliably
replayed multiple times is difficult as UI tests tend to be flaky(the
test execution results may vary for the same configuration).
ToreducemanualeffortinobtainingUIsequences,Droixsup-
portsseveralkindsofeventsequences,including:(1)asetofactions
(e.g.,clicks,andtouches)leadingtothecrashwhichcanberecorded
using monkeyrunner9GUI,(2)asetofAndroidDebugBridge(adb)
commands10, and (3) scripts with a mixture of recorded actions
and adb commands. Non-technical users could record their actions
with monkeyrunner whileAndroiddeveloperscouldwriteadbcom-
mands to have better control of the devices (e.g., rotate screen).
DroixemploysseveralstrategiestoensurethattheUItestout-
come is consistent across different executions [ 36]. Specifically, for
each UI test, Droix automatically launches the app from the home
screen, inserts pauses in between each event sequence, terminates
9Monkeyrunner contains API that allows controlling Android devices:
https://developer.android.com/studio/test/monkeyrunner/index.html
10ADB is a command-line tool that are used to control Android devices:
https://developer.android.com/studio/command-line/adb.html
191
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:51:40 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Shin Hwei Tan, Zhen Dong, Xiang Gao, and Abhik Roychoudhury
OperatorsLog analyzerBuggy APK
Logs
UI sequenceMutant 
generatorDecompiler
Evaluator
SelectorCode checkerTest checkerMutant
Bug report
Mutants pool
Te
dh k
APKsFixed APKDroix
Bug locations
ViolationsViolations
Figure 3: Droix’s Android Repair Framework
Table 3: Code-level and Test-level Properties Enforced in Droix
Level Type Description
Code-levelWell-formedness Verify that a mutated APK is compilable and the structural type of the program matches the requires context of the selected operator.
Bug hazard Checks whether a transformation violates Java exception-handling best practices.
Exception Type Checks whether a transformation matches a given exception type. (e.g., Insert Null-check should be used for fixing NullPointerException exclusively)
Test-levelLifecycle Checks that the event transition matches with the activity and fragment lifecycle model (Figure 1).
Activity-Fragment Checks that the interaction between a fragment and its parent activity matches the activity-fragment coordination model (dashed lines in Figure 1)Commit Checks that a commit of a fragment’s transactions is performed in the allowed states (i.e., after an activity’s state is saved).
the apps after test execution, and brings the android device back to
home screen (ensure that the last state of the device is the same as
the initial state of the device). Moreover, Droix executes each UI
testforatleastthreetimesinwhicheachtestexecutionhaspauses
of different duration (5, 10, 15 seconds) inserted in between events.
6.2 Fault Localization
Our fault localization step pinpoints faulty program locations lead-
ingtothecrash.Sinceourapproachdoesnotrequiresourcecode
nor heavy testsuite, we leverage stack trace information forfault
localization. The stack trace contains (1) the type of exceptions
being thrown, (2) the specific lines of code where the exception is
thrown,and(3)thelistofclassesandmethodcallsintheruntime
stackwhentheexceptionoccurs.Weusestacktraceinformation
for fault localization because (1) this information is often included
inthebugreportofcrashes(whichallowsustocomparetheactual
exception thrown with the expected exception) and (2) prior study
has shown the effectiveness of using stack trace to locate Java run-
time exceptions [ 44]. The stack trace information is given to our
search algorithm for fix localization. When searching for complex
fixes, once a fix using initial stack trace is generated, it may enable
other crashes, leading to new stack traces and new fixes.
6.3 Code Checker and Test Checker
Instead of relying solely on the UI test outcome, Droix enforcestwo kinds of properties: code-level properties (properties that are
checked prior to test execution) and test-level properties (properties
thatareverified during/aftertestexecution).Theseproperties are
important because (1) they serve as additional test oracles for vali-
datingcandidate apps;and (2)theycould compensatefor thelack
of passing UI tests.
Table3showsdifferentpropertiesenforcedinDroix. Bughazard
isacircumstancethatincreaseslikelihoodofabugbeingpresent
inaprogram[ 13].ArecentstudyofAndroidappsrevealsseveralexception handling bug hazards and Java exception handling best
practices [ 18]. Given an exception Ethat leads to a crash, our code
checker categorizes Eas either a checked exception, an unchecked
exception,oranerrortodetermineifwecouldinsertahandler(try-
catchblock)for E.AccordingtheJavaexceptionhandlingbestprac-
tice“Errorrepresentsanunrecoverableconditionwhichshouldnot
behandled”,hence,ourcodecheckerconsidersinsertinghandler
forruntimeerrorsahardconstraintandeliminatessuchpatches.In
contrast, inserting handlers for unchecked and checked exceptions
are encoded as soft constraints that could affectthe score of a mu-
tant. Meanwhile, we encode the well-formedness property and the
exceptiontypepropertyashardconstraintsthatshouldbesatisfied.
Given a previous lifecycle callback prevand a current lifecy-
cle callback curr, our test checker verifies if prev→currobeys
the activity/fragment lifecycle management rules (Figure 1). Droix
considers all test-level properties as soft constraints because these
propertiesmaynotbedirectlyrelatedtothecrash(e.g.,resource-
related crashes).
Algorithm 1: Patch generation algorithm
Input: Buggy APK P, Operators Op, Population size PopSize , UI test U,
Program Locations Locs
Input: Fitness Fit:<Patch,Rc,Rt>→Z
Result: APK that passes Uand contains least property violations
Pop←initialPopulation (APK P,PopSize );
while∄C∈Pop.Cp a s s e sU do
Mutants←Mutate (Pop,Op,Locs );// apply Op atl∈Locs
/* select mutant with least RcandRtviolations */
Pop←Select (Mutants ,PopSize ,Fit );
end
6.4 Mutant Generation and Evaluation
Droixsupportseightoperatorsderivedfromourstudyofcrashesin
Androidapps(Section4).Table2showsthedetailsofeachoperator.
192
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:51:40 UTC from IEEE Xplore.  Restrictions apply. Repairing Crashes in Android Apps ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Algorithm 1 presents our patch generation algorithm. Droix
leverages ( μ+λ) evolutionary algorithm with μ=40 andλ=20.
Givenasinputpopulationsize PopSize,fitnessfunction Fit,anda
list of faulty locations Locs, our approachiteratively generates new
mutants by applying one of the operators listed in Table 2 at each
locationin Locs,evaluateseachmutantbyexecutingtheinputUI
eventsequences U,andcomputesthenumberofcode-levelproperty
Rcand test-level property Rtviolations. The generate-and-validate
process terminates when either there exists at least one mutant in
thepopulationthatpasses Uorthetimelimitisexceeded.Ourpatch
generation algorithm differs from existing approaches that use
evolutionaryalgorithm[ 24,53]inwhichweuseadifferentpatch
representation and fitness function. Specifically, each mutant is an
APK in our representation. Instead of using the number of passing
testsasthefitnessfunction,ourfitnessfunction Fitcomputesthe
number of code-level and test-level property violations.
7 IMPLEMENTATION
OurAndroidrepairframeworkleveragesvariousopensourcetools
tosupportdifferentcomponents.Specifically,ourloganalyzeruses
Logcat11, a command-line tool that generates logs when events
occuronanAndroiddevice.Weimplementtheeightoperatorsin
Table 2 on top of the Soot framework (v2.5.0) [ 25]. Soot is a Java
optimization framework that supports analysis and transformation
of Java bytecode. Dexpler, a module included in Soot leveragesan Dalvik bytecode disassembler to produce Jimple (a Soot rep-resentation) which enables reading and writing Dalvik bytecodedirectly [
11]. We use the Dexpler module in Soot for our decom-
piler component inFigure 3.Tosupport the“S4: Replacemethod"
operator, weuse the Levenshtein distance toselect a method with
similar method name and compatible parameter types. Our imple-
mentation for the “S3: Replace resource id" operator uses Android
resourceparserinFlowDroid[ 7]toobtainaresourceidofthesame
type. As each compiled APK needs to be signed before installation,
we use jarsigner12for signing the compiled APK. We re-install
the signed APK onto the device using adb commands13. Instead of
uninstallingandre-installing eachsignedapp,appre-installation
allows us to keep the app data (e.g. account information and set-
tings) to save timein re-entering the required information during
subsequent execution of U.
8 SUBJECTS
Whiletherearevariousbenchmarksusedinevaluatingtheeffective-
ness of automated testing of Android applications [ 4,5,15,30] and
theeffectivenessofrepairapproachesforCprograms[ 27,50,57],
arecentstudy[ 16]showedthatthecrashesinthesebenchmarks
cannot be adequately reproduced by existing Android testing tools.
Meanwhile, Android-specific benchmark like DROIDBENCH [ 7]
does not contain real Android apps and it is designed for evalu-
atingtaint-analysistools.AlthoughempiricalstudiesonAndroid
apps [12,18] investigated the bug reports of real Android apps,
11https://developer.android.com/studio/command-line/logcat.html
12http://docs.oracle.com/javase/7/docs/technotes/tools/windows/jarsigner.html
13https://developer.android.com/studio/command-line/adb.htmlnoneofthesestudiestrytoreplicatethereportedcrashes.There-
fore, all existing benchmarks cannot be used for evaluating the
effectiveness of analyzing crashes in Android apps.
We introduce a new benchmark, called DroixBench that con-
tains 24 reproducible crashes in 15 real-world Android apps. Apart
from evaluating Droix, this benchmark could be used to assessthe effectiveness of detecting and analyzing crashes in Android
apps. To facilitate future research on analysis of crashes, we made
DroixBench publicly available at: https://droix2017.github.io/.
DroixBenchisanewsetofAndroidappsforevaluatingDroix.
AppsusedforderivingtransformationoperatorsinSection4are
excluded from DroixBench to avoid the overfitting problem in the
evaluation. Specifically, we modified our crawler to find the most
recentissues(bugreports)onAndroidappscrashesonGitHub.Our
goal is to identify a set of reproducible crashes in Android apps.
To reduce the time in manual inspection of these bug reports, our
crawler excludes (1) issues without any bug-fixing commits (which
isessentialforcomparingpatchquality);(2)unresolvedissues(to
avoid invalid failures); and (3) non-Android related issues (e.g., iOS
crashes).Thisstepyieldsmorethan300GitHubissues.Wefurther
exclude defects that do not fulfill the criteria below:Device-specificdefects.
Weeliminatedefectsthatrequirespecific
versions/brands of Android devices.
Resource-dependent defects. We eliminatedefectsthatrequire
specific resources (e.g., making phone calls) as we may not be able
to replicate these issues easily on an Android emulator.Irreproducible crashes.
We eliminate crashes that are deemed
irreproducible by the developers.
9 EVALUATION
WeperformevaluationontheeffectivenessofDroixinrepairing
crashesonrealAndroidappsandwecomparethequalityofDroix’s
patch with the quality of the human patch. Our evaluation aims to
address the following research questions:
RQ1How many crashes in Android apps can Droix fix?
RQ2How is the quality of the patches generated by Droix com-
pared with the patches generated by developers?
9.1 Experimental Setup
We evaluate Droix on 24 defects from 15 real Android apps in
DroixBench. Table 4 lists information about the evaluated apps.
The “Type” column contains information about the specific type
of exception that causes the crash, whereas the “TestEx” column
representsthetimetakeninsecondstoexecutetheUItest.Overall,
DroixBenchcontainsawidevarietyofappsofvarioussizes(4-115K
lines of code) and different types of exceptions that lead to crashes.
AsDroixreliesonrandomizedalgorithm,weusethesamepa-
rameters (10 runs for each defect with PopSize=40 and a maximum
of 10 generations) as in GenProg [ 26] for our experiments. In each
run,wereportthefirstfoundamongthelowestscore(minimum
property violations) patches. Each run of Droix is terminated after
onehourorwhenapatchwithminimalviolationsisgenerated.All
experiments were performed on a machine with a quad-core Intel
Corei7-5600U2.60GHzprocessorand12GBofmemory.Allapps
are executed on a Google Nexus 5x emulator (Android API25).
193
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:51:40 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Shin Hwei Tan, Zhen Dong, Xiang Gao, and Abhik Roychoudhury
Table 4: Subject Apps and Their Basic Statistics
App Name Description Version LOC Type TestEx(s)
Transistor radio players1.2.3 4K NullPointer 42.1
1.1.5 4K IllegalState 40.1
Pix-art photo editor1.17.1 54K NullPointer 37.21.17.0 60K NullPointer 42.0
PoetAssistantpoet writing
helper1.18.2 12K NullPointer 42.31.10.4 6K SQLite 60.9
Anymemo flashcard learning10.10.1 29K NullPointer 50.5
10.9.922 33K NullPointer 83.9
AnkiDroid flashcard learning2.8.1 73K IllegalState 50.6
2.7b1 73K ClassCast 37.2
Fdroidopensoure apprepository0.103.2 50K IllegalState 38.7
0.98 38K SQLite 37.3
Yalp app repository 0.17 11K NullPointer 57.4
LabCoat GitLab client 2.2.4 45K NullPointer 49.2
GnuCashfinance expensetracker2.1.4 42K IllegalArgument 32.0
2.1.3 40K NullPointer 37.22.0.5 37K IllegalArgument 42.2
NoiseCapture noise evaluator0.4.2b 10K NullPointer 42.50.4.2b 10K ClassCast 41.2
ConnectBot secure shell client 1.9.2 26K OutOfBounds 57.4
K9 email client 5.111 115K NullPointer 42.2
OpenMF Mifosx client 1.0.1 75K IllegalState 134.0
Transdroid torrents client 2.5.0b1 37K NullPointer 45.9
Beem communication tool 0.1.7rc1 21K NullPointer 61.3
For each defect, we manually inspect the source code of human
patched program and the source code decompiled from Droix’s
patched program. If the source code of automatically patched pro-
gramdiffersfromthehumanpatchedprogram,wefurtherinves-
tigatetheUIbehaviorofpatchedprogramsbyinstallingboththe
human generated APK and the automatically generated APK onto
the Android device. For each APK, we manually perform visual
comparison of the screens triggered by a set of available UI actions
(clicks, swipes) after the crashing point.
Definition1. Giventhesourcecodeofhumanpatchedprogram
Srchuman,the codeof anautomaticallygenerated patch Srcmachine,
the compiled APK of human patched program APKhuman, the com-
piledAPKofautomaticallygeneratedpatch APKmachine,wemea-
sure patch quality using the criteria defined below:
(C1) Syntactically Equivalent. Srcmachineis“SyntacticallyEquiv-
alent” ifSrcmachineandSrchumanare syntactically the same.
(C2) Semantically Equivalent. Srcmachineis“SemanticallyEquiv-
alent” ifSrcmachineandSrchumanare not syntactically the same
but produce the same semantic behavior.
(C3) UI-behavior Equivalent. APKmachineis“UI-behaviorEquiv-
alent”toAPKhuman, iftheUI-state atthe crashingpoint afterap-
plying the automated fix is same as the UI-state at the crashing
pointafterapplyingthehumanpatch.TwoUI-stateareconsidered
tobesameiftheirUIlayoutsaresame,thesetofeventsenabledare
same,andtheseeventsagain(recursively)leadtoUI-equivalent
states. UI-behavior equivalence of APKhumanagainstAPKmachine
is checked manually in our experiments.(C4) Incorrect. Welabela APKmachineas“Incorrect"if APKmachine
leads to undesirable behavior (e.g., causes another crash) but this
behavior is not observed in APK human.
(C5) Better. We label a APKmachineas “Better" when APKhuman
leads to regression witnessed by another UI test URwhereas
APKmachinepassesUR.
Formally, C1=⇒C2∧C2=⇒C3, hence, a generated patch
thatissyntacticallyequivalenttothehumanpatchissuperiorto
both semantically equivalent patch and UI-behavior equivalentpatch. We note that, in general, checking whether a patch is se-mantically equivalent to the human patch (
C2) is an undecidable
problem.Ho wever,in ourmanualanalysis,thecorrectbehaviorfor
all evaluated patches are well-defined. While C1andC2investigate
thebehaviorofpatchesatthesource-codelevel,weintroduce C3
tocomparethebehaviorofpatchesattheGUI-level.Weconsider
C3because our approach uses GUI tests for guiding the repair pro-
cess.Furthermore,sinceourapproachdoesnotrequiresourcecode,
direct manual checking of source code may be sometimes tedious.
9.2 Evaluation Results
Table5showsthepatchqualityresultsforDroix.The“Time”col-
umninTable5indicatesthetimetakeninsecondsacross10runs
for generating the patch before the one-hour time limit is reached.
Onaverage,Droixtakes30minutestogenerateapatch.Meanwhile,the“Repair”columndenotesthenumberof plausiblepatches (APKs
that pass the UI test) generated by Droix. Overall, Droix generates
15 plausible patches (rows marked with√) out of 24 evaluated de-
fects.Ouranalysisofthe9defectsthatarenotrepairedbyDroix
reveals that all of these defects are difficult to fix because all the
corresponding human patches require at least 10 lines of edits.
The “Fix type” column in Table 5 shows the operator used in
eachpatch(RefertoTable2forthedescriptionofeachoperator).
The “Null-check" operator is the most frequently used operators
(used in six patches and 4/6=67% of these patches are syntactically
equivalenttothehumanpatches).Theseresultsmatchwiththehighfrequencyof“Null-check"operatorinourempiricalstudy(Table1).Interestingly,wealsoobservethatthe“GetActivity-check"operator
tendstoproducehighqualitypatchesbecausethisoperatoraims
to enforce the “Activity-Fragment" property that checks for the
coordination between the host activity and its embedded fragment.
The “Syntactic Equiv.” column in Table 5 shows the patches
that fulfill C1, while the “Semantic Equiv.” column denotes patches
thatfulfill C2.Similarly,the“UI-behaviorEquiv”columndemon-
strates the number of fixed APKs that fulfill the C3 criteria. Par-
ticularly, we consider the patch generated by Droix for Anymemo
v10.9.922as“SemanticallyEquivalent”becausebothpatchesusean
objectofthesametyperetainedbeforeconfigurationchangesto
fixa NullPointerException buttheobjectisretainedindifferent
programlocations(i.e.,notsyntacticallyequivalent).Meanwhile,
Droix generates three APKs that are UI-behavior equivalent tothe human generated APKs. Interestingly, we observed that al-though the human patches for these defects require multi-lines
fixes,thebugreportsfortheseUI-behaviorequivalentpatchesin-
dicate that specific conditions are required to trigger the crashes
(e.g., mSpinner.getSelectedItemId()!=INVALID_ROW_ID forthe
GnuCashv2.0.5 defect).Asthese conditionsaredifficult totrigger
194
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:51:40 UTC from IEEE Xplore.  Restrictions apply. Repairing Crashes in Android Apps ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Table 5: Patch Quality Results
App Version Time (s) Fix type Repair Syntactic Equiv. Semantic Equiv. UI-behavior Equiv. Others
Transistor1.2.3 616 -
1.1.5 987 GetActivity-check√better(⊕)
PixArt1.17.1 1164 -1.17.0 1525 Null-check √/triangle
PoetAssistant1.18.2 955 Null-check√/triangle
1.10.4 3600 -
Anymemo10.10.1 2104 -10.9.922 1336 Retain Object √⊙
AnkiDroid2.8.1 3600 -2.7b1 3600 Try-catch √text missing(×)
Fdroid0.103.2 2293 Replace method√⋆
0.98 518 -
Yalp 0.17 2970 -
LabCoat 2.2.4 2074 Null-check√⋆
GnuCash2.1.3 360 -2.0.5 1492 Try-catch √/triangle
2.1.4 3600 -
ConnectBot 1.9.2 572 Try-catch√text missing(×)
NoiseCapture0.4.2b 340 Null-check√⋆
0.4.2b 520 Replace cast√⋆
K9 5.111 1718 Try-catch√crash(×)
OpenMF 1.0.1 3600 GetActivity-check√⋆
Beem 0.1.7rc1 2378 Null-check√⋆
Transdroid 2.5.0b1 1315 Null-check√⋆
24 15 7 1 3 4
fromtheUIlevel,synthesizingpreciseconditionsisnotrequired
for ensuring UI-behavior equivalent.
The“Others”columninTable5includesonepatchthatisbet-
ter than the human patch (marked as ⊕) and three patches that
areincorrect(markedas ×).WeconsiderthepatchforTransistor
v1.1.5 to be better than human patch as it passes regression test
stated in the bug report whereas the human patch introduces a
newregression(SeeSection3fordetailedexplanations).Fortwo
of the incorrect patches, we notice that some texts that appear
on the screen of human APKs are missing in the screen of fixed
APKs (text missing). Meanwhile, the crash in k9 v5.111 occurs due
to an invalid email address for a particular contact. In this case,
the human APK treats the contact as a non-existing contact while
the patched APK displays the contact as unknown recipient andcrashes when the unknown recipient is selected. We think that
boththehumanAPKandthepatchedAPKcouldbeimproved(e.g.,
prompttheusertoenteravalidemailaddressinsteadofignoring
thecontact).AlthoughthepatchgeneratedbyDroixfork9violates
the bug hazard property (catching a runtime exception), we select
this patch as no other patches are found within the time limit.
Droixfixes15outof24evaluatedcrashes,sevenofthese
fixesarethesameasthehumanpatches,onerepairissemanti-
cally equivalent, three are UI-behavior equivalent. In one rare
case, we generate better repair.
10 THREATS TO VALIDITY
Weidentifythefollowingthreatstothevalidityofourexperiments:
Operators used. WhilewederiveouroperatorsfromfrequentlyusedoperatorsinfixingopensourceappsandfromAndroidAPI
documentation, our set of operators is not exhaustive.
Reproducing crashes. We manually reproduce each crash in our
proposedbenchmark.AswerelyonAndroidemulatorforrepro-
ducingcrashes,thecrashesinourbenchmarkarelimitedtocrashes
thatcouldbereliablyreproducedonAndroidemulators.Crashes
that require specific setup (e.g., making phone calls) may be more
challenging or impractical to replay.Crashes investigated.
As we only investigate open source An-
droid apps in our empirical study and in our proposed benchmark,
our results may not generalize to closed-source apps. We focus on
open source apps because our patch analysis requires the availabil-
ityofsourcecodes.Nevertheless,asDroixtakesasinputAndroid
APK,itcouldbeusedforfixingclosedsourceapps.Weleavethe
empirical evaluation of closed source apps as our future work.Patch Quality.
During our manual patch analysis, at least two
of the authors analyze the quality of human patches versus the
quality of automatically generated patches separately and meet to
resolve any disagreement. As most bug reports include detailed
explanationsofhumanpatchesandtheexpectedbehaviorofthe
crashing UI test, the patch analysis is relatively straightforward.
11 RELATED WORK
Testing and Analysis of Android Apps. Manyautomatedtech-
niques(AndroidRipper[ 4],ACTEVE[5],A3E[9],Collider[ 23],Dyn-
odroid[30],FSMdroid[ 47],Fuzzdroid[ 43],Orbit[56],Sapienz[ 31],
Swifthand[ 15],andworkbyMirzaeietal.[ 37])areproposedtogen-
eratetestinputsforAndroidapps.Ourapproachisorthogonalto
theseapproachesandthetestsgeneratedbytheseapproachescould
195
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:51:40 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Shin Hwei Tan, Zhen Dong, Xiang Gao, and Abhik Roychoudhury
serveasinputstoourAndroidrepairsystem.Severalapproachesfo-
cusonreproducingcrashesinJavaprojects[ 14,46,55].Meanwhile,
CRASHSCOPE[ 38]automaticallydetectsandreproducescrashesin
Androidapps. Ourbenchmarkwith24 reproducible crashescould
beused forevaluatingthe effectivenessofthese approaches.Simi-
lar to Flowdroid [ 7], we implement ourfix operators on top of the
Soot framework, and we use activity lifecycle information for our
analysisofAndroidapps.Insteadofconsideringonlytheactivity
lifecycle as in Flowdroid, we also encode fragment lifecycle and
activity-fragmentcoordinationastest-levelproperties.RERAN[ 22]
could precisely record and replay UI events on Android devices,including gestures (e.g., multitouch). While our approach allowsUI sequences in forms of scripts recorded in the user interface,the record-and-replay mechanism in RERAN could allow Droixto handle more complex UI events. Although our code checker
incorporates some Java exception handling best practices listed in
recentstudyofAndroidapps[ 18],ourempiricalstudyofcrashes
that occur in Android apps goes beyond prior study by performing
a thorough investigation of the common root causes of Android
crashes.
Automated Program Repair. Several techniques (Angelix [ 35],
ASTOR[33],ClearView[ 41],Directfix[ 34],GenProg[ 26],PAR[24],
Prophet [ 28], NOPOL [ 54],relifix[49]) have been introduced to
automaticallygeneratepatches.Thereareseveralkeydifferences
of our Android repair framework compared to other existing re-
pair approaches. Firstly, instead of relying on the quality of the
test suite for guiding the repair process, our approach augmentsa given UI test with code-level and test-level properties for rank-ing generated patches. Secondly, existing approaches could nothandle flaky UI tests as they may misinterpret the test outcomeof UI tests and may mistakenly produce invalid patches. Finally,
our repair framework modifies compiled APK and each test execu-
tionisperformedremotelyonAndroidemulators,whereasother
approaches modify source code directly where each test is being
executedonthesameplatformasothercomponentsoftherepair
system.OtherstudiesforautomatedrepairusebenchmarkforCprograms [
27,50,57,58], whereas Droixbench contains a set of
reproducible crashes for Android apps. QACrashFix [ 19] and work
by Azim et al. [ 8] use Android apps as dataset for experiments,
without any Android-specific study of cause for crashes. Their
repair operators are Android-agnostic. Specifically, QACrashFix
merely add/delete/replace single node in the Abstract Syntax Tree,
wheareas work by Azim et al only inserts fault-avoiding code that
is similar to workaround identified in our study in Section 4. Toeliminate invalid patches, anti-patterns are proposed as a set of
forbidden rules that can be enforced on top of search-based repair
approaches [ 51]. Although our code-level and test-level properties
could be considered as different forms of anti-patterns that are
examinedpriortoandaftertestexecutions,weusetheseproper-
tiesforselectingmutantsthatviolatefewerpropertiesinsteadof
eliminating these mutants. Similar to Droix that uses stack traceinformation for fault localization, the work of Sinha et al. uses
stack trace information for locating Java exceptions [ 44]. However,
their approach only supports analysis of NullPointerException ,
whereas our approach could automatically repair different types of
exceptions.Other Repairs of Android Apps EnergyPatch fixes energy bugs
inAndroidappsusingarepairexpressionthatcapturestheresource
expression and releases system calls [ 10]. The battery-aware trans-
formations proposed in [ 17] aims to reduce power consumption
of mobile devices. Several approaches generate security patches
for Android apps [ 39,59]. While energy bugs and security-related
vulnerabilities may cause crashes in Android apps, we present a
generic framework for automated repair of Android crashes, focus-
ing on crashes that occur due to the misunderstanding of Android
activity and fragment lifecycles.UIRepair.
FlowFixerisanapproachthatrepairsbrokenworkflow
in GUI applications that evolve due to GUI refactoring. SITAR uses
annotatedevent-flowgraphforfixingunusableGUItestscripts[ 20].
Although Droix takes as input UI test, it automatically fixes buggy
AndroidappsratherthantheinputsthatcrashtheGUIapplications.
12 CONCLUSIONS AND FUTURE WORK
We study the common causes of 107 crashes in Android apps. Our
investigationrevealsthatappcrashesoccurduetomissingcallback
handler(17.76%),improperhandling ofresources(16%),andviola-
tionsofmanagementrulesfortheAndroidactivityandfragment
lifecycles(14%).BasedonouranalysisofpatchesissuedbyAndroiddeveloperstofixthesecrashesandtheAndroidAPIdocumentations
that specify the correct usage of Android API, we derive a set of
lifecycle-awaretransformations.Toreducetimeandeffortinfixing
crashes in Android apps, we also introduce Droix, a novel Android
repairframeworkthatautomaticallygeneratesafixedAPKwhen
given as input a buggy APK and UI event sequences. To encour-
age future research of Android crashes, we propose DroixBench, a
benchmarkthatcontains24reproduciblecrashesoccurringin15
open source Android apps. Our evaluation on DroixBench demon-
strates that Droix could generate repair for 63% of the evaluated
crashes and seven of the automatically generated patches are syn-tactically equivalent to the human patches.
Althoughourrepairframeworkcurrentlyperformsanalysisand
mutation of Android apps on desktop machine while executing UI
tests on an Android emulator, in the future, it is feasible to havea standalone repair system that could be installed as an app thatautomatically fixes crashes occurring in other apps on Android
devices.SinceourGUIinterfacedoesnotassumeanyprogramming
knowledge, our repair framework could potentially benefit general
non-technicaluserswhowouldliketohavetheirownversionsof
fixed apps instead of waiting for the official releases. Moreover, as
weobservethatmanycrashesoccurduetothemisunderstanding
of activity/fragment lifecycle that are specified in the Android API
documentations,wethinkthatDroixcouldbeusedasapluginthat
automatically provides management rule violations together with
patchsuggestionstoassistdevelopersinunderstandingAndroid
API specifications.
ACKNOWLEDGEMENT
This research is supported by the National Research Foundation,
Prime Minister’s Office, Singapore under its Corporate Laboratory
at UniversityScheme,National Universityof Singapore, andSin-
gapore Telecommunications Ltd. The first author thanks Southern
University of Science and Technology for the travel support.
196
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:51:40 UTC from IEEE Xplore.  Restrictions apply. Repairing Crashes in Android Apps ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
REFERENCES
[1]2017. What Consumers Really Need and Want. https://goo.gl/puYdkG. (2017).
Accessed 2017-03-27.
[2]SharadAgarwal,RatulMahajan, AliceZheng,andVictorBahl.2010. Diagnosing
mobileapplicationsinthewild.In Proceedingsofthe9thACMSIGCOMMWorkshop
on Hot Topics in Networks. ACM, 22.
[3]Domenico Amalfitano, Anna Rita Fasolino, and Porfirio Tramontana. 2011. Agui crawling-based technique for android mobile application testing. In Soft-
ware Testing, Verification and Validation Workshops (ICSTW), 2011 IEEE Fourth
International Conference on. IEEE, 252–261.
[4]Domenico Amalfitano, Anna Rita Fasolino, Porfirio Tramontana, SalvatoreDe Carmine, and Atif M Memon. 2012. Using GUI ripping for automated test-
ingofAndroidapplications.In Proceedingsofthe27thIEEE/ACMInternational
Conference on Automated Software Engineering. ACM, 258–261.
[5]SaswatAnand,MayurNaik,MaryJeanHarrold,andHongseokYang.2012. Auto-
mated concolic testingof smartphone apps. In Proceedings ofthe ACM SIGSOFT
20th International Symposium on the Foundations of Software Engineering. ACM,
59.
[6]AlessandroArmando,AlessioMerlo,MauroMigliardi,andLucaVerderame.2013.
Breaking and fixing the android launching flow. Computers & Security 39 (2013),
104–115.
[7]Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bodden, Alexandre Bar-
tel,JacquesKlein,YvesLeTraon,DamienOcteau,andPatrickMcDaniel.2014.
Flowdroid: Precise context, flow, field, object-sensitive and lifecycle-aware taint
analysis for android apps. Acm Sigplan Notices 49, 6 (2014), 259–269.
[8]Md Tanzirul Azim, Iulian Neamtiu, and Lisa M Marvel. 2014. Towards self-
healing smartphone software via automated patching. In Proceedings of the 29th
ACM/IEEE international conference on Automated software engineering. ACM,
623–628.
[9]TanzirulAzimandIulianNeamtiu.2013. Targetedanddepth-firstexploration
for systematic testing of android apps. In Acm Sigplan Notices, Vol. 48. ACM,
641–660.
[10]A.Banerjee,L.K.Chong,C.Ballabriga,andA.Roychoudhury.2017. EnergyPatch:
RepairingResourceLeakstoImproveEnergy-efficiencyofAndroidApps. IEEE
Transactions on Software Engineering PP, 99 (2017), 1–1. https://doi.org/10.1109/
TSE.2017.2689012
[11]Alexandre Bartel, Jacques Klein, Yves Le Traon, and Martin Monperrus. 2012.
Dexpler: Converting Android Dalvik Bytecode to Jimple for Static Analysis with
Soot. InProceedings of the ACM SIGPLAN International Workshop on State of
theArtinJavaProgramAnalysis (SOAP’12) .ACM,NewYork,NY,USA,27–38.
https://doi.org/10.1145/2259051.2259056
[12]PamelaBhattacharya,LiudmilaUlanova,IulianNeamtiu,andSaiCharanKoduru.2013. Anempiricalanalysisofbugreportsandbugfixinginopensourceandroid
apps. InSoftware Maintenance and Reengineering (CSMR), 2013 17th European
Conference on. IEEE, 133–143.
[13]Robert V Binder. 2000. Testing object-oriented systems: models, patterns, and tools.
Addison-Wesley Professional.
[14]N. Chen and S. Kim. 2015. STAR: Stack Trace Based Automatic Crash Reproduc-
tion via Symbolic Execution. IEEE Transactions on Software Engineering 41, 2
(Feb 2015), 198–220. https://doi.org/10.1109/TSE.2014.2363469
[15]Wontae Choi, George Necula, and Koushik Sen. 2013. Guided gui testing ofandroid apps with minimal restart and approximate learning. In Acm Sigplan
Notices, Vol. 48. ACM, 623–640.
[16]Shauvik Roy Choudhary, Alessandra Gorla, and Alessandro Orso. 2015. Au-
tomatedtestinputgenerationforandroid:Arewethereyet?(e).In Automated
SoftwareEngineering(ASE),201530thIEEE/ACMInternationalConferenceon.IEEE,
429–440.
[17]JürgenCito,JuliaRubin,PhillipStanley-Marbell,andMartinRinard.2016.Battery-
awaretransformationsinmobileapplications.In AutomatedSoftwareEngineering
(ASE), 2016 31st IEEE/ACM International Conference on. IEEE, 702–707.
[18]Roberta Coelho, Lucas Almeida, Georgios Gousios, Arie Van Deursen, and
Christoph Treude. 2016. Exception handling bug hazards in Android. Empirical
Software Engineering (2016), 1–41.
[19]Qing Gao, Hansheng Zhang, Jie Wang, Yingfei Xiong, Lu Zhang, and Hong Mei.
2015. Fixing recurring crash bugs via analyzing q&a sites (T). In Automated
Software Engineering (ASE), 2015 30th IEEE/ACM International Conference on.
IEEE, 307–318.
[20]Zebao Gao, Zhenyu Chen, Yunxiao Zou, and Atif M Memon. 2016. Sitar: GUI
test script repair. Ieee transactions on software engineering 42, 2 (2016), 170–186.
[21]LaurenceGoasduffandChristyPettey.2012. Gartnersaysworldwidesmartphone
salessoaredinfourthquarterof2011with47percentgrowth. VisitedApril (2012).
[22]LorenzoGomez,IulianNeamtiu,TanzirulAzim,andToddMillstein.2013.RERAN:
Timing-andTouch-sensitiveRecordandReplayforAndroid.In Proceedingsof
the2013 InternationalConference onSoftwareEngineering (ICSE ’13).IEEE Press,
Piscataway, NJ, USA, 72–81. http://dl.acm.org/citation.cfm?id=2486788.2486799
[23]Casper S. Jensen, Mukul R. Prasad, and Anders Møller. 2013. Automated Testing
withTargetedEventSequenceGeneration.In Proceedingsofthe2013InternationalSymposium on Software Testing and Analysis (ISSTA 2013). ACM, New York, NY,
USA, 67–77. https://doi.org/10.1145/2483760.2483777
[24]Dongsun Kim, Jaechang Nam, Jaewoo Song, and Sunghun Kim. 2013. Automatic
patch generation learned from human-written patches. In ICSE’ 2013. IEEE Press,
802–811.
[25]PatrickLam,EricBodden,OndrejLhoták,andLaurieHendren.2011. TheSoot
frameworkforJavaprogramanalysis:aretrospective.In CetusUsersandCompiler
Infastructure Workshop (CETUS 2011), Vol. 15. 35.
[26]ClaireLeGoues,MichaelDewey-Vogt,StephanieForrest,andWestleyWeimer.
2012. A Systematic Study of Automated Program Repair: Fixing 55 out of 105
Bugs for $8 Each. In Proceedings of the 34th International Conference on Software
Engineering (ICSE ’12). IEEE Press, Piscataway, NJ, USA, 3–13.
[27]Claire Le Goues, Neal Holtschulte, Edward K Smith, Yuriy Brun, PremkumarDevanbu, Stephanie Forrest, and Westley Weimer. 2015. The ManyBugs and
IntroClassbenchmarksforautomatedrepairofCprograms. IEEETransactions
on Software Engineering 41, 12 (2015), 1236–1256.
[28]Fan Long and Martin Rinard. 2016. Automatic Patch Generation by Learning
CorrectCode.In Proceedingsofthe43rd AnnualACMSIGPLAN-SIGACTSympo-
siumonPrinciplesofProgrammingLanguages (POPL’16).ACM,NewYork,NY,
USA, 298–312.
[29]Qingzhou Luo, Farah Hariri, Lamyaa Eloussi, and Darko Marinov. 2014. AnEmpirical Analysis of Flaky Tests. In Proceedings of the 22Nd ACM SIGSOFT
InternationalSymposiumonFoundationsofSoftwareEngineering (FSE2014).ACM,
New York, NY, USA, 643–653. https://doi.org/10.1145/2635868.2635920
[30]Aravind Machiry, Rohan Tahiliani, and Mayur Naik. 2013. Dynodroid: An Input
GenerationSystemforAndroidApps.In Proceedingsofthe20139thJointMeeting
on Foundations of Software Engineering (ESEC/FSE 2013). ACM, New York, NY,
USA, 224–234. https://doi.org/10.1145/2491411.2491450
[31]KeMao,MarkHarman,andYueJia.2016. Sapienz:Multi-objectiveAutomated
Testing for Android Applications. In Proceedings of the 25th International Sympo-
siumonSoftwareTestingandAnalysis (ISSTA2016) .ACM,NewYork,NY,USA,
94–105. https://doi.org/10.1145/2931037.2931054
[32]Matias Martinez,Thomas Durieux, Romain Sommerard, Jifeng Xuan, andMartin
Monperrus.2016. AutomaticrepairofrealbugsinJava:Alarge-scaleexperiment
on the Defects4J dataset. Empirical Software Engineering (2016), 1–29.
[33]MatiasMartinezandMartinMonperrus.2016. ASTOR:AProgramRepairLibrary
for Java (Demo). In Proceedings of the 25th International Symposium on Software
Testing and Analysis (ISSTA 2016). ACM, New York, NY, USA, 441–444. https:
//doi.org/10.1145/2931037.2948705
[34]SergeyMechtaev,JooyongYi,andAbhikRoychoudhury.2015. Directfix:Looking
for simple program repairs. In Proceedings of the 37th International Conference on
Software Engineering-Volume 1. IEEE Press, 448–458.
[35]Sergey Mechtaev, Jooyong Yi, and Abhik Roychoudhury. 2016. Angelix: Scalable
multilineprogrampatchsynthesisviasymbolicanalysis.In SoftwareEngineering
(ICSE), 2016 IEEE/ACM 38th International Conference on. IEEE, 691–701.
[36]AtifM.MemonandMyraB.Cohen.2013. AutomatedTestingofGUIApplications:
Models, Tools, and Controlling Flakiness. In Proceedings of the 2013 International
Conferenceon SoftwareEngineering (ICSE ’13).IEEEPress,Piscataway,NJ,USA,
1479–1480. http://dl.acm.org/citation.cfm?id=2486788.2487046
[37]Nariman Mirzaei, Sam Malek, Corina S. Păsăreanu, Naeem Esfahani, and Riyadh
Mahmood. 2012. Testing Android Apps Through Symbolic Execution. SIGSOFT
Softw. Eng. Notes 37, 6 (Nov. 2012), 1–5. https://doi.org/10.1145/2382756.2382798
[38]Kevin Moran, Mario Linares-Vásquez, Carlos Bernal-Cárdenas, Christopher Ven-
dome,and DenysPoshyvanyk. 2016. Automaticallydiscovering, reportingand
reproducing android application crashes. In Software Testing, Verification and
Validation (ICST), 2016 IEEE International Conference on. IEEE, 33–44.
[39]CollinMulliner,JonOberheide,WilliamRobertson,andEnginKirda.2013. Patch-
droid: Scalable third-party security patches for android devices. In Proceedings of
the 29th Annual Computer Security Applications Conference. ACM, 259–268.
[40]Hoang Duong Thien Nguyen, Dawei Qi, Abhik Roychoudhury, and Satish Chan-
dra. 2013. SemFix: Program repair via semantic analysis. In Proceedings of the
2013 International Conference on Software Engineering. IEEE Press, 772–781.
[41]Jeff H. Perkins, Sunghun Kim, Sam Larsen, Saman Amarasinghe, Jonathan
Bachrach, Michael Carbin, Carlos Pacheco, Frank Sherwood, Stelios Sidiroglou,
Greg Sullivan, Weng-Fai Wong, Yoav Zibin, Michael D. Ernst, and Martin Rinard.
2009. Automatically Patching Errors in Deployed Software. In SOSP. 87–102.
[42]YuhuaQi,XiaoguangMao,YanLei,ZiyingDai,andChengsongWang.2014. The
Strength of Random Search on Automated Program Repair. In Proceedings of the
36thInternationalConferenceonSoftwareEngineering(ICSE).ACM,NewYork,
NY, USA, 254–265.
[43]SiegfriedRasthofer,StevenArzt,StefanTriller,andMichaelPradel.2017. Making
Malory Behave Maliciously: Targeted Fuzzing of Android Execution Environ-
ments.In Proceedingsofthe39thInternationalConferenceonSoftwareEngineering
(ICSE’17).IEEEPress,Piscataway,NJ,USA,300–311. https://doi.org/10.1109/
ICSE.2017.35
[44]Saurabh Sinha, Hina Shah, Carsten Görg, Shujuan Jiang, Mijung Kim, and
Mary Jean Harrold. 2009. Fault Localization and Repair for Java Runtime
197
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:51:40 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Shin Hwei Tan, Zhen Dong, Xiang Gao, and Abhik Roychoudhury
Exceptions. In Proceedings of the Eighteenth International Symposium on Soft-
ware Testing and Analysis (ISSTA ’09). ACM, New York, NY, USA, 153–164.
https://doi.org/10.1145/1572272.1572291
[45]Edward K Smith, Earl T Barr, Claire Le Goues, and Yuriy Brun. 2015. Is the cure
worse than the disease? overfitting in automated program repair. In Proceedings
of the 2015 10th Joint Meeting on Foundations of Software Engineering. ACM,
532–543.
[46]Mozhan Soltani, Annibale Panichella, and Arie van Deursen. 2017. A guided
geneticalgorithmforautomatedcrashreproduction.In Proceedingsofthe39th
International Conference on Software Engineering. IEEE Press, 209–220.
[47]Ting Su. 2016. FSMdroid: Guided GUI Testing of Android Apps. In Proceedings of
the 38thInternational Conference on SoftwareEngineering Companion (ICSE ’16).
ACM, New York, NY, USA, 689–691. https://doi.org/10.1145/2889160.2891043
[48]Shin Hwei Tan, Darko Marinov, Lin Tan, and Gary T. Leavens. 2012. @tCom-
ment: Testing Javadoc Comments to Detect Comment-Code Inconsistencies. In
Proceedings of the 2012 IEEE Fifth International Conference on Software Testing,
VerificationandValidation (ICST’12).IEEEComputerSociety,Washington,DC,
USA, 260–269. https://doi.org/10.1109/ICST.2012.106
[49]Shin Hwei Tan and Abhik Roychoudhury. 2015. Relifix: Automated Repair
ofSoftwareRegressions.In Proceedingsofthe37thInternationalConferenceon
Software Engineering - Volume 1 (ICSE ’15). IEEE Press, Piscataway, NJ, USA,
471–482. http://dl.acm.org/citation.cfm?id=2818754.2818813
[50]ShinHweiTan,JooyongYi,Yulis,SergeyMechtaev,andAbhikRoychoudhury.
2017. Codeflaws: A Programming Competition Benchmark for Evaluating Auto-
matedProgramRepair Tools.In Proceedingsofthe 39thInternationalConference
onSoftwareEngineeringCompanion(ICSE-C’17).IEEEPress,Piscataway,NJ,USA,
180–182. https://doi.org/10.1109/ICSE-C.2017.76
[51]ShinHweiTan,HiroakiYoshida,MukulRPrasad,andAbhikRoychoudhury.2016.
Anti-patterns in search-based program repair. In Proceedings of the 2016 24thACM SIGSOFT International Symposium on Foundations of Software Engineering.
ACM, 727–738.
[52]W. Weimer, Z.P. Fry, and S. Forrest. 2013. Leveraging program equivalence
for adaptive program repair: Models and first results. In Automated Software
Engineering (ASE).
[53]WestleyWeimer,ThanhVuNguyen,ClaireLeGoues,andStephanieForrest.2009.
Automatically finding patches using genetic programming. In ICSE. 364–374.
[54]J.Xuan,M.Martinez,F.DeMarco,M.Clement,S.LamelasMarcote,T.Durieux,
D.LeBerre,andM.Monperrus.2016. Nopol:AutomaticRepairofConditional
Statement Bugs in Java Programs. IEEE Transactions on Software Engineering PP,
99 (2016), 1–1.
[55]JifengXuan,XiaoyuanXie,andMartinMonperrus.2015. Crashreproductionvia
test case mutation: Let existing test cases help. In Proceedings of the 2015 10th
Joint Meeting on Foundations of Software Engineering. ACM, 910–913.
[56]WeiYang,MukulRPrasad,andTaoXie.2013. Agrey-boxapproachforautomated
GUI-model generation of mobile applications. In International Conference on
Fundamental Approaches to Software Engineering. Springer, 250–265.
[57]Jooyong Yi, Umair Z. Ahmed, Amey Karkare, Shin Hwei Tan, and Abhik Roy-choudhury.2017. AFeasibilityStudyofUsingAutomatedProgramRepairforIntroductory Programming Assignments. In Proceedings of the 2017 11th Joint
MeetingonFoundationsofSoftwareEngineering (ESEC/FSE2017).ACM,NewYork,
NY, USA, 740–751. https://doi.org/10.1145/3106237.3106262
[58]Jooyong Yi, Shin Hwei Tan, Sergey Mechtaev, Marcel Böhme, and Abhik Roy-
choudhury.2017. Acorrelationstudybetweenautomatedprogramrepairand
test-suite metrics. Empirical Software Engineering (2017), 1–32.
[59]MuZhangandHengYin.2014.AppSealer:AutomaticGenerationofVulnerability-
Specific Patches for Preventing Component Hijacking Attacks in Android Appli-
cations. In NDSS.
198
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:51:40 UTC from IEEE Xplore.  Restrictions apply. 