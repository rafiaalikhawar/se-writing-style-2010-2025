ReScue: Crafting Regular Expression DoS Attacks∗
Yuju Shen
State Key Lab for Novel Software
Technology, Nanjing University
Nanjing, China
denny.syj@hotmail.comYanyan Jiang
State Key Lab for Novel Software
Technology, Nanjing University
Nanjing, China
jyy@nju.edu.cnChang Xu
State Key Lab for Novel Software
Technology, Nanjing University
Nanjing, China
changxu@nju.edu.cn
Ping Yu
State Key Lab for Novel Software
Technology, Nanjing University
Nanjing, China
yuping@nju.edu.cnXiaoxing Ma
State Key Lab for Novel Software
Technology, Nanjing University
Nanjing, China
xxm@nju.edu.cnJian Lu
State Key Lab for Novel Software
Technology, Nanjing University
Nanjing, China
lj@nju.edu.cn
ABSTRACT
Regular expression (regex) with modern extensions is one of the
most popular string processing tools. However, poorly-designedregexes can yield exponentially many matching steps, and lead
toregexDenial-of-Service(ReDoS)attacksunderwell-conceived
string inputs. This paper presents ReScue, a three-phase gray-box
analytical technique, to automatically generate ReDoS strings to
highlightvulnerabilitiesofgivenregexes.ReScuesystematically
seeds (by a geneticsearch), incubates (by another geneticsearch),
and finally pumps (by a regex-dedicated algorithm) for generat-ing strings with maximized search time. We implemenmted theReScue tool and evaluated it against 29,088 practical regexes in
real-worldprojects.TheevaluationresultsshowthatReScuefound
49%moreattackstringscomparedwiththebestexistingtechnique,
and applying ReScue to popular GitHub projects discovered ten
previously unknown ReDoS vulnerabilities.
CCS CONCEPTS
•Securityandprivacy →Softwareandapplicationsecurity ;
Domain-specific security and privacy architectures ;•Software and
its engineering →Search-based software engineering ;Soft-
ware defect analysis ;Software testing and debugging ;
KEYWORDS
Regular expression, denial of service, ReDoS, genetic algorithm
ACM Reference Format:
Yuju Shen, Yanyan Jiang, Chang Xu, Ping Yu, Xiaoxing Ma, and Jian Lu.
2018.ReScue:CraftingRegularExpressionDoSAttacks.In Proceedingsof
the 2018 33rd ACM/IEEE International Conference on Automated Software
Engineering(ASE’18),September3–7,2018,Montpellier,France. ACM,New
York, NY, USA, 11pages.https://doi.org/10.1145/3238147.3238159
∗Yanyan Jiang and Chang Xu are the corresponding authors.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ’18, September 3–7, 2018, Montpellier, France
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.32381591 INTRODUCTION
Regularexpression(regex),amini-programforstringpatternmatch-
ing, extraction, and replacing, has been one of the most popular
stringprocessingtools.Featuredwithvariousgrammaticalexten-
sions(e.g.,lookarounds,namedgroups,atomicgroups,backrefer-
ences, conditionals, and possessive quantifiers [ 16]), regexes are
widelyusedincrawlers,texteditors,webapplications,searchen-
gines, databases, command-line utilities, to name but a few.
However,poorly-designedregexescanyieldexponentiallymany
matching steps [ 19], leading to timeout consequences, despite that
a regex’s matching usually terminates in polynomial or even lin-
ear time of its concerned pattern and given input’s (a string’s)length. Such timeout-triggering inputs can easily result in algo-
rithmicdenial-of-service(DoS)attacks,aka.ReDoSattacks[ 13,25].
A recent report [ 40] showed that hundreds of popular websites
are threatened by ReDoS, and it is thus natural and necessary to
validate regexes against such possible vulnerabilities.
ThispaperpresentsReScue,athree-phasegray-boxanalytical
technique, for automatically detecting ReDoS vulnerabilities, i.e.,
finding a timeout-triggering input string for a given regex. With
suchatool,developersorthird-partysoftwarequalityteamscan
perform ReDoS security checks early in the software development.
ThedifficultyofautomatedReDoSdetectionismainlyattributed
tothecomplexityofmodernregex languageextensions.Aformal
languageofmodernregexesisbeyondthedescriptionrangeofa
Thompson NFA [ 6,8,44]. Transforming such regexes to automata
isalready achallenge [ 3],and henceexisting staticanalyzers(e.g.,
pumping analysis [ 25,34,35], transducer analysis [ 41], NFA am-
biguity analysis [ 45], or adversarial automata construction [ 48])
areneithersoundnorcompleteinhandlingtheseextensions.On
the other hand, state-of-the-art dynamicanalyzers (e.g., black-box
fuzzers like SlowFuzz [ 31]) lack the understanding to the actual
regexmatchingprocedureandcommonlyfallshortwhenReDoS
vulnerability is hidden in deep states of a regex’s matching.
This paper tackles the ReDoS detection problem by observing
thatthemostpracticalwaytoimplementaregexengineistoadopt
thee-NFA + backtracking searching approach1(e-NFA stands for
extendednon-deterministicfinite-stateautomata),andthatregexes
canthusbeeffectivelyanalyzedbymerely focusingon e-NFAstates.
1Popularregexenginesaremostlyimplementedinthisway,e.g.,thebuilt-inregex
modules in Java [3], Python [15, 27], JavaScript [11], etc.
225
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Y. Shen, Y. Jiang, C. Xu, P. Yu, X. Ma, and J. Lu
In particular, an e-NFA state and its corresponding recursion stack
distinctlydetermineanintermediatestateintheregex-matching
process, and the whole search time in the matching is proportional
tothenumberof e-NFAstatesevertraversed(matchingsteps )during
thematchingprocess[ 16].Weobservethattofacilitateasuccessful
ReDoS attack, reaching a particular statein ane-NFA is of the
mostimportance,andthatsuchstateinformationissufficientfor
guiding an effective ReDoS search. With such observations, the
recursionstack(whichisengine-dependentanddifficulttoencode)
can be safely removed from consideration in the ReDoS detection,
andtargetedReDoSstringscanstillbeeffectivelygeneratedbya
geneticalgorithmfocusingmerelyonsearch profilingdata(thusapplicable to almost all major regex engines with only marginal
non-intrusive changes).
This motivates for our proposal of a gray-box search-based algo-
rithm for systematically finding an input string that maximizes the
number of matching steps using regex search profiling data, as the
following three phases explain:
•Theseeding phase takes a regex (and its e-NFA) as input and
uses a genetic (seeding) algorithm to search for a diverseset of seed strings that can best cover the
e-NFA’s states.
We adopt existing search-based techniques [ 9,20,21,29]
and leverage a new genetic representation by maintaining a
string’seffective prefix andredundant suffix to better charac-
terize the string’s matching procedure.
•Theincubatingphase germinatestheseedstringsusingasim-
ilar genetic algorithm (but with a different fitness function)
tosearchforthoseattackstringcandidates,whichmaximizetheratiosbetweenthematchingstepssofarandtheirstring
lengths. This incubating phase resembles existing gray-box
search techniques [24].
•Thepumping phase trims and enhances the slowest string
candidateintheincubatedpopulationbyalocalsearchalgo-
rithm for eventually crafting a malicious input string that
willresultinasignificantnumberofmatchingstepsinthe
given regex’s matching, triggering a real ReDoS attack in
practice.
Weimplementedourthree-phasetechniqueasReScueinJava,
a ReDoS detection tool that can thoroughly analyze given regexes
for their ReDoS vulnerabilities, requiring merely slight profilingchanges to the concerned regex engines. We evaluated ReScue
using29,088regexesandcomparedReScueagainstfourstate-of-
the-art ReDoS detection techniques. We also applied ReScue to
highly starred GitHub projects for ReDoS vulnerability detection.
The evaluation results show that ReScue found 49% more Re-
DoS strings compared with the best existing technique, and has
acomparabletimecostwithexistingnativeCimplementationof
fuzzing [31], even if our profiled Java regex engine is one or two
magnitudesslower.TheapplicationtoGitHubprojectsfoundten
previously unknown ReDoS vulnerabilities.
In summary, this paper made the following contributions:
•Weproposedathree-phasetechniqueforautomaticanalysis
ofregexesandsystematicdetectionoftheirReDoSvulner-
abilities. The technique can be applied to all mainstream
regex engines based on e-NFA and backtracking, to the best
of our knowledge.•We implemented ReScue in Java and evaluated it using real-
world regexes. The evaluation results show that ReScue
outperformedstate-of-the-arttechniquesanddetectedpre-
viously unknown ReDoS vulnerabilities in popular open-
source projects.
Therestofthepaperisorganizedasfollows.Weprovideback-
ground of regex and ReDoS in Section 2followed by the algorithm
description in Section 3. The implementation of the ReScue tool
is discussed in Section 4and its evaluation results are presented
in Section 5. Related work is discussed in Section 6and finally
Section7concludes the paper.
2 BACKGROUND
2.1 Regexes, Regex Engines, and ReDoS
Regular expression (regex), a mini-program for compact description
offormallanguages[ 6,8],wasoriginatedin1950s[ 26]andbecomes
one of the most popular string processing tools. In the years of
development,practitionersextendedregexeswithrichfeaturesto
facilitate powerful and elegant handling of string pattern matching
tasks:characterclasses,lookarounds,namedgroups,atomicgroups,backreferences,etc.Empoweredwiththeseextensions,regextoday
is one of the most handy string processing tools.
Regexpatternmatchingisconductedwiththesupportofa regex
engine. Since regexes with extensions are context-aware2, a mod-
ernregexcouldnolongerbeconvertedtoadeterministicornon-
deterministic finite-state automaton (as opposed to the classical
textbookcase[ 8]).Asaresult,regexenginesmusthaveto search
forregexmatches,andthusthestate-of-the-artregexenginesadopt
a similar algorithmic framework as follows:
(1)Convertingthegivenregexintoadatastructurewhichex-
tendsanon-deterministicfiniteautomaton(i.e.,an e-NFA),
inwhicheachvertexrepresentsapatternmatchingrelated
operation, and
(2)Conducting a backtracking search to find whether there
exists any path that matches the given input string.
Such a framework runs in polynomial (or even linear) time in
mostcases.However,inrarecasesofa non-match,allpossiblepaths
would be examined and a regex engine can run in exponential time
of the input string’s length. For example, a regex from RegLib [ 36]:
^<\!\-\-(.*)+(\/){0,1}\-\->$
recognizescommentsinanHTMLfile.Patternmatchingwithsuch
a particular regex is usually fast even if the input is of a megabyte
length. However, a Python regex engine can get stuck with the
following shortinput string3:
<!--!--!--!--!--!--!--!--IamReDoS
Therefore, when regexes are used to process untrusted inputs
(e.g.,formssubmittedbyanInternetuser),suchtime-out-triggering
casescanmakesoftwarevulnerabletoDenial-of-Serviceattacks,
orReDoSattacks.
2For example, the regex (?!ˆ1?$|ˆ(11+)\1+$) tests whether the expression consists
of a prime number of 1s.
3Thedevelopermisplaceda (.*)+intheregex,anditcanbeexpandedin O(2n)many
ways in representing a string of length n.
226
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. ReScue: Crafting Regular Expression DoS Attacks ASE ’18, September 3–7, 2018, Montpellier, France
ReScue
Seeding Phase Incubating Phase Pumping PhaseNFA
RegexEmpty
Set
Coverage
Fitness
FunctionGASeed
Set
Ratio
Fitness
FunctionGA PopulationEffective Substring
Candidate
Trim
Pump
Figure 1: Overview of the ReScue technique for automated ReDoS string generation.
2.2 Automated Detection of ReDoS
Vulnerabilities
Regexesareusuallyembeddedinapieceoflargesoftwareandlack
thoroughtestingoranalysis.Theyarethus notdefendedagainst
ReDoSattacks[ 40].Afewregexenginesprovidematchinglimits
(e.g.,PCRE[ 22])toalleviatetheimpactofReDoS.However,even
such a minimal effort is not widely adopted in practice4, not to
mention that setting a time limit cannot fully tackle the ReDoS
issue when a server is flooded with timeout-triggering regexes.
Therefore,anautomatedtoolforfindingReDoSstringsbecomes
adesirablesolutiontowarndevelopersofsuchpotentialvulnera-
bilities (and then refactoring the concerned regexes) early in the
software development [ 40]. Depending on whether actual regex
matchingsare conducted,suchatool iseither static(basedpurely
on the given regex) or dynamic (based on the profiling results of
regex matchings).
StaticReDoSanalysesfindvulnerableconstructs(viastaticrules
orpatterns)inthe e-NFArepresentationofaregex[ 25,34,35,41,
45,48]. Such analyses can be sound and complete for certain kinds
ofregexes,butcaneasilyreportfalsepositiveattackstringsormiss
ReDoSvulnerabilities.Takingthebackreferenceasanexample,itisextremelydifficulttoknowwhatitsvaluecanbeinabackreference
(e.g.,\1) without actually conducting the regex matching.
Dynamic ReDoS analyses, on the other hand, conduct actual
regexmatchingandusethematchingresultstoguidefurthergener-
ation of potentially vulnerable strings, e.g., fuzzing [ 31]. Therefore,
a dynamic analyzer usually seamlessly handles regex extensions
and reports only true positive ReDoS strings. The major drawback
of dynamic analysis is that finding a timeout-triggering string is it-
selftime-consuming,andthusexistingblack-boxtechniquesguided
byacost-effectivenessvaluecanmissReDoSvulnerabilitiesthat
require a certain cost-ineffective prefix to trigger.
Our ReScue presented in this paper exploits both the static
knowledgeofaregex(thepumpablepropertyofregexes)andthe
genetic search (guided by the profiling data collected along with
the regex’s matching process).
4For example, even popular editors like Atom and LibreOffice hang or crash when
regexmatchinggetstimeout,e.g.,conductingpatternmatchingof (.+)+#bythetime
of this paper being written.3 THE RESCUE ALGORITHM
Thissectionelaboratesonourthree-phaseReScuealgorithmfor
automated ReDoS detection, as illustrated in Figure 1.
3.1 Methodology Overview
The ReDoS detection is a searchproblem, i.e., given a regex r,a n
alphabet Σ(e.g., English alphabet and symbols), and a maximal
input length/lscript, finding
ReDoS(r,Σ,/lscript)=argmax
s∈Σ1∪...∪Σ/lscriptRegexMatchTimer(s).
Thesearchtime RegexMatchTime dependsnotonlyontheinput
regexandtheinputstring,butalsoontheunderlyingregexengine
implementation (e.g., the regex search algorithm and supported
regexextensions).Thecomplexityofaregexengineimplementa-
tionmakesstaticregexanalysistechniques[ 25,34,35,41,45,48]
neither sound nor complete. Our evaluation later shows that these
techniques reported false positives and found less true positive
ReDoS vulnerabilities when applied to a practical regex engine. On
theotherhand,existingheuristicsearchtechniques(e.g.,black-box
fuzzing[31])mayalsofailtorecognizeReDoSvulnerabilities.Such
search algorithms are usually guided by the cost-effectiveness of a
string,i.e.,thesearchtimedividedbythestring’slength.Whenthe
ReDoSvulnerabilityrequiresalesscost-effectiveprefixtotrigger,
thesearchislikelytobetrappedinlocaloptimumsolutions,leaving
the ReDoS vulnerability undetected.
Theselimitationsofexistinganalysisofsearchtechniquesmo-
tivate us to design our ReScue technique to dive into the actualregex search procedure for an effective ReDoS string generation.
ReScue consists of three phases:
(1)Theseedingphase explores the regex engine’s behaviors
undervariousinputs.Inparticular,theseedingphasefocuses
onreachingasmany e-NFAstatesoftheregexaspossible,
regardless of the search time.
(2)Theincubating phase searchesfor ReDoS candidatestrings
with maximized search time, as guided by a cost-effective
measurementonthebasisoftheseedstringsgeneratedinthe
firstphase.Theincubatingphaseworksonthehypothesis
thatReDoSstringscanbegeneratedbysuccessivelyapplying
mutation and crossing over operations to the seeds.
227
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Y. Shen, Y. Jiang, C. Xu, P. Yu, X. Ma, and J. Lu
(3)Thepumping phasefinallyenhancestheReDoScandidate
strings by a local search of removing ReDoS-irrelevant char-
acters and copying/pasting part of a string to obtain a truly
ReDoS string of maximized search time.
Our three-phase ReScue technique inherits several important
ideas from existing work. Both the seeding and incubating phases
belong to genetic search extensively studied in the search-based
software engineering domain [ 9,20,21,29,30]. In particular, the
incubating phase is guided by the cost-effectiveness and resembles
the black-box time complexity attack fuzzing [ 31]. The pumping
phasegeneralizestheideaofstaticanalysisforfindingpumpable
constructsinaregex[ 25]toadynamiclocalsearchproblem.Putting
themtogetherplusaseedingphaseforgeneratinguseful“artifacts”
in crafting ReDoS strings yields our ReScue technique, which is
elaborated on as follows.
3.2 Notations and Definitions
3.2.1 Strings,Regexes,andRegexPatternMatching. Weusewidely
usednotationsfordescribingstringsandregexes[ 5,23].Astringsis
asequenceofcharactersfromanalphabet Σ.s(i)∈Σdenotesthe i-
thcharacterinstring s(1≤i≤|s|),ands(i:j)denotesthesubstring
s(i)s(i+1)...s(j).Theemptystringisdenotedby ε.Forexample,
givens=“ReDoS”,s(3)=“D”ands(4:5)=“oS”. Two strings xand
ycanbeconcatenated,yielding x·yorsimply xy.Concatenating
x=“hello”andy=“world”yieldsxy=“helloworld” .
Aregular expression ris the string representation of a formal
language (i.e., a set of strings) L(r)⊆Σ∗. For
rhello=“ˆ(?=hello)[a-z]{5}” ,
L(rhello)={“hello”}5.
Given a string sand a regex r, the regex pattern matching prob-
lemisequivalenttotestwhetherthereexistsasubstring s(i:j)∈L(r).
Anotherrelevantproblemisthelanguageinclusiontestonwhether
s∈L(r), and regex matching can be reduced to the testing of
language inclusion.
3.2.2 e-NFA for Regex Matching. Modern regex engines usually
first compile a regex to an extended non-deterministic finite au-
tomaton(e-NFA), which is usually implemented in a modern regex
engine[16].Ane-NFAcanberegardedasagraph G(V,E)inwhich
each vertex v∈Vdenotes an e-NFA state, and each matching step
(node)v∈Visassociatedwith anengine-specificfunction fvto
performstatetransitioninregexmatching.Forexample,theJava
regex engine constructs the e-NFA shown in Figure 2forrhello.
Theregexengineconductsamatchingbymaintainingitsmatch-
ing stateS, usually a stack (either explicitly or implicitly by recur-
sion) storing a sequence of /angbracketleftvi,pi,ti/angbracketrightwherevi∈Vis ane-NFA
state, 0≤p≤|s|is a position in s6, and some engine-dependent
statesti. Initially, S0={/angbracketleftv0,0,⊥/angbracketright}wherev0∈Vis the initial
e-NFA state.
Ineachmatchingstep,theregexenginepops /angbracketleftv,p,t/angbracketrightfromthe
matching stack, and pushes fv(s,p,t)onto the stack ( sis the in-
put string). Multiple values of /angbracketleftv,p,t/angbracketrightmay be pushed to represent
non-deterministic choices. This stack-based mechanism provides
versatile supports forregexextensions. Successfulmatching ofa
5“(?=)”is the lookahead extension of regex.
6This potentially unbounded storage makes regex with extensions context-aware.v0:Begin^
v1:Lookahead (?=...)
v2:GroupHead (
(Index Storage)
v3:Slicehello
v4:GroupTail )
(Index Storage)
v5:NodeExitv6:Repeat{5,5}
v7:CharClass a-z
v8:NodeAcc
Figure 2: The compiled e-NFA of regex ^(?=hello)[a-z]{5}
single character is simply done by pushing /angbracketleftv/prime,p+1,t/angbracketright, while a
failed matching pushes nothing (which is equivalent to backtrack-
ing).fv(s,p,t)of lookahead and repetition nodes in Figure 2are
defined as follows:
(1)ForNodev1(lookahead), it pushes /angbracketleftv6,p,⊥/angbracketrightthen/angbracketleftv2,p,⊥/angbracketright
suchthatwhenthematchinggroup(Node v2–Nodev5)is
successfully matched, the matching restarts at Nodev6.
(2)ForNodev6(repetition),dependingonthecurrentrepetition
countt,/angbracketleftv8,p,⊥/angbracketrightis pushed when t=0 for matching the
subsequent parts, otherwise /angbracketleftv7,p,t−1/angbracketrightis pushed for a
repeated matching with a count of t−1.
Therefore, the regex matching procedure is sophisticated due
to the runtime stack (e.g., there can be transitions from v4tov6
even if they are not connected in G, as opposed to the classical
NFA [8]). However, the e-NFA + backtracking mechanism also
providesguidancetowardseffectivesearchforanalyzingregexes
using a genetic algorithm.
3.2.3 RegexMatchingTraces. Thoughtheregexmatchingpro-
cedure is sophisticated and engine-dependent, all known regex
enginescanbemodifiedtoproduce positionaltrace (orsimply trace)
during matching, which is denoted by
τr(s)={/angbracketleftx0,p0/angbracketright,/angbracketleftx1,p1/angbracketright,...,/angbracketleftxm,pm/angbracketright}
wherexi∈Vis ane-NFA state and 0 ≤pi≤|s|is a position in the
inputstringdenotingthestartingpositionofthenextstringpattern
matching. /angbracketleftxi,pi/angbracketrightdenotes that the i-th regex matching attempt
is to find a match when picharacters in shave been matched
ate-NFA state xi. Essentially, the trace is obtained by discarding
theengine-dependentstates( ti)inthematchingprocedure. τr(s)
encodes sufficient information to guide an effective genetic search
towards ReDoS strings in ReScue.
Forrhello, thee-NFA shown in Figure 2, ands1=“helloworld”
ands2=“hellopanda” , conducting regex matching in Java yields
the same traces τrhello(s1)=τrhello(s2):
{/angbracketleftv0,0/angbracketright,/angbracketleftv1,0/angbracketright,/angbracketleftv2,0/angbracketright,/angbracketleftv3,0/angbracketright,/angbracketleftv4,5/angbracketright,/angbracketleftv5,5/angbracketright,/angbracketleftv6,0/angbracketright,/angbracketleftv7,0/angbracketright,/angbracketleftv5,1/angbracketright,
/angbracketleftv7,1/angbracketright,/angbracketleftv5,2/angbracketright,/angbracketleftv7,2/angbracketright,/angbracketleftv5,3/angbracketright,/angbracketleftv7,3/angbracketright,/angbracketleftv5,4/angbracketright,/angbracketleftv7,4/angbracketright,/angbracketleftv5,5/angbracketright,/angbracketleftv8,5/angbracketright}.
228
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. ReScue: Crafting Regular Expression DoS Attacks ASE ’18, September 3–7, 2018, Montpellier, France
For two traces τr(s1)={/angbracketleftxi,pi/angbracketright}andτr(s2)={/angbracketleftx/prime
i,p/prime
i/angbracketright},w e
considerτr(s1)andτr(s2)equivalent inregexmatchingif |τr(s1)|=
|τr(s2)|andxi=x/prime
ifor all 1 ≤i≤|τr(s1)|. Therefore, s1=
“helloworld” ands2=“hellopanda” haveequivalenttracesinmatch-
ing against rhello.
Furthermore, we define the effective prefix EP(s)=s(1:k)where
k=max
/angbracketleftx,n/angbracketright∈τr(s)(n),andtheredundantsuffix RS(s)=s(k+1:|s|)isthe
restpartof s.Obviously, s=EP(s)RS(s).Wedistinguishbetween EP
andRSbecauseregexenginessometimesfirstchecktherestlength
oftheinputstringtoshortpaththesearching,anddeletingsuch
tails may lead to an irreproducible trace. For example, the effective
prefixes of both “helloworld” and“hellopanda” are“hello”.
Finally, a byproduct of regex compilation is a set of string slices
Σslice,whichcontainssubstringsof rusedintheregexmatching
procedure.Forexample, Σsliceforrhellois{“hello”}(corresponding
tothevertex v3).Stringsin Σsliceareusefulintheoffspringproduc-
tion (by mutation or crossover operators) in a genetic algorithm.
3.3 The Genetic Search Framework
Boththeseedingphaseandtheincubatingphasearegeneticsearch,
whichsharethesameclassicalgeneticalgorithmframework[ 47].A
geneticalgorithmsearches foroptimalsolutionsin asearchspace
by representing each solution as an individual (a chromosome-
alike data structure) and maintaining an evolving population of
individuals.
Given an initial population, the genetic algorithm iteratively
breeds offspring (by cross-over andmutation operators) and pro-
duces a new generation of population under the guidance of the
principle of natural selection: an individual of a higher fitness func-
tionvalue has a higher chance to survive.
Boththeseedingphaseandtheincubatingphasesharethesame
genetic representation and offspring generation but differ in the
initial population, the fitness function, and the selection strategy.
3.3.1 Genetic Representation. We directly use a string to repre-
sent each individual in the population
P={s1,s2,...,sn}(si∈Σ∗)
because a string naturally resembles a genome. Each generation
ofthepopulationproducesitsoffspringbyrandommutationand
cut-concatenationofstrings,andthenewgenerationisbredbythe
selection under a fitness function f(s,P).
3.3.2 Offspring Generation. Given a population P, its offspring
are generated by crossing over and mutating the strings in P.
Thecrossoveroperator χ(s1,s2)interleavestheeffectiveprefixes
ofs1ands2. In particular, χ(s1,s2)randomly splits EP(s1)=x1y1,
EP(s2)=x2y27, and returns
χ(s1,s2)={x1y2RS(s2),x2y1RS(s1)}.
Intuitively,the effectiveprefixesEP( s1)andEP(s2)areinterleaved
(x1y2andx2y1) with their suffixes appended.
Themutationoperator μ(s)returnsarandommutantof s,where
u∈Σ∪Σsliceisarandomstring(eitherarandomcharacterin Σor
a random string constant in the regex’s corresponding automaton):
7If not otherwise stated, the random selection of x∈Xreturns each xwith the same
probability of 1/|X|.•Appending uin EP(s);
•Inserting uto a random position in EP( s);
•Deleting a random substring in EP( s);
•Duplicating a random substring in EP( s);
•Reversing a random substring in EP( s).
It is worth noting that both χandμoperate on the effective
prefixEP(s)and keeps RS(s)unchanged, because the redundant
suffixRS(s)has not been involved in the matching procedure. Nev-
ertheless,keepingasufficientlylong RS(s)isalsonecessarybecause
theregexenginemaycheckwhether RS(s)issufficientlylongfora
successful matching.
Then the offspring are generated by applying χandμto ran-
domly selected individuals in the population P, and newly gen-
eratedoffspringwhosetraceisequivalenttoanexisting τr(s)for
s∈Pisconsideredredundantandisimmediatelydiscarded.Fur-
thermore,wegavetheindividualsofhigherfitness f(s,P)values
a higher probability in generating offspring (by crossover or muta-
tion):
Pr[s∈Pis chosen] =f(s,P)/summationtext.1
s/prime∈Pf(s/prime,P).
3.4 The Seeding Phase: Searching for Diverse
e-NFA States
Theseedingphasetriestofindapopulation Pseedofstringsthat
coversasmany e-NFAstatesaspossibleandbasically ignoresthe
search time8.
The initiate population of the seeding phase P0consists of con-
stantstrings Σsliceintheautomatonplussomerandomstringsin
the alphabet of Σ.
Abinaryfitnessfunction fseed(s,P)isusedintheseedingphase,
whichsummarizeswhetherthematchingtrace τr(s)coverssome
uniquee-NFA states in the population P. Formally, let V(s)=/uniontext.1
/angbracketleftx,n/angbracketright∈τr(s)vdenotethesetoftraversed e-NFAstatesintheregex
matching procedure,
fseed(s,P)=⎧⎪⎪ ⎨
⎪⎪⎩1,∃v∈V(s).v/nelement/uniontext.1
s/prime∈P\{s}V(s/prime);
0,otherwise.
Afteranewpopulation P/primecontainingcrossedoverandmutated
strings is generated, the seeding phase selects a minimal set of
stringsP⋆⊆P/primeas the population in the next iteration, which
satisfies/uniontext.1
s∈P⋆V(s)=/uniontext.1
s∈PV(s).P⋆is generated by sequentially
considering each s∈Pand discarding the strings without any
uniquely covered e-NFA state in V(s).
3.5 The Incubating Phase: Searching for ReDoS
Candidates
The incubating phase “incubates” the seeds to find a population of
strings of maximized regex matching time. Therefore, the initial
population of the incubating phase P0=Pseed.
8In contrast to the existing technique that directly searches towards a larger running
time [31], we use the seeding phase to find ReDoS strings of a long cost-ineffective
prefix.
229
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Y. Shen, Y. Jiang, C. Xu, P. Yu, X. Ma, and J. Lu
Algorithm 1: The pumping algorithm
Input:A stringsand a designated length /lscript(|s|≤/lscript)
Output:A pumped ReDoS string
1begin
2strim←s;
3fori←|S|to1do
4 s/prime←strim(1:i−1)strim(i+1:|strim|);// try to remove the
i-th character
5 iffincub(s/prime)≥fincub(s)then
6 strim←s/prime;
7s←strim;
8m←0;i⋆←0;j⋆←0;
9fori←1to|s|do
10 forj←i+1to|s|do
11 s/prime←s(1:i−1)·s(i:j)2·s(j+1:|s|);// repeating s(i:j)
twice
12 iffincub(s/prime)>mthen
13 m←fincub(s/prime);i⋆←i;j⋆←j;
14k←/floorleftBig/lscript−|s|
j⋆−i⋆+1/floorrightBig
;// maximum allowed number of pumps
15returns(1:i⋆−1)·s(i⋆:j⋆)k·s(j⋆+1:|s|);
The fitness function in the incubating phase
fincub(s)=|τr(s)|
|s|
measurestheaveragecost-effectivenessofeachcharacterin s.Such
afitnessfunctionnaturallyguidesthesearchtowardsReDoSstrings
(short strings costing a substantial amount of matching steps).
Furthermore, wesimultaneously maintain a diversepopulation
to avoidbeing stuckat a local optimum. Givena newlygenerated
population P/prime, let
¯f=1
|P/prime|/summationdisplay.1
s∈P/primefincub(s)
be the average of fitness function values, we first select
P⋆={s∈P/prime|fincub(s)≥¯f}
toincludeanystringfitterthantheaverage,andthenaddbacka
minimal set of strings to maintain exactly the same e-NFA state
coveragebyenumeratingallstrings s∈P/primeandadding stoP⋆if
V(s)/notsubseteql/uniontext.1
s⋆∈P⋆V(s⋆).
3.6 The Pumping Phase: Enhancing ReDoS
Candidates for a Successful Attack
The pumping phase selects such incubated string of the highest
cost-effective ratio
s⋆=argmax
s∈Pfincub(s)
andpumpsit into a highly effective input string for slowing down
theregexmatchingprocedure.Theidea(andthename)hasbeen
inspired bythe Pumping Lemma,which isalso used inthe static
detection of ReDoS vulnerabilities [25]:PumpingLemma[ 33].Foranyregularlanguage L,thereisa p≥0
such that any string w∈Lof|w|≥pcan be written as w=xyz,
wherey/nequalεandthestrings xz,xyz,xyyz,... constructedbyrepeating
yzero or more times are still in L.
In other words, there may exist a substring that can be repeated
and does not affect the matching results9. Therefore, the pumping
phase trims those unnecessary characters in s⋆and pumps a care-
fully chosen substring to finally reach a string that requires a large
number of matching steps, as shown in Algorithm 1.
The trimming algorithm (Lines 2–6) removes unnecessary char-
actersbytryingtoremoveeachsinglecharacterandcheckswhether
sucharemovalyieldsahigherfitness fincubvalue(Line5).Trim-
mingisalsousedtoreducethelengthoftheredundantsuffix RS(s).
Then the pumping algorithm (Lines 8–15) enumerates all sub-
strings in s(i:j)and tries to pump one once yielding
s/prime=s(1:i−1)·s(i:j)2·s(j+1:|s|),
and finally pumps the most profitable substring (Lines 14–15) to
obtain our ReDoS string.
4 IMPLEMENTATION
We implemented ReScue in Java. The implementation has approxi-
mately 3,000 lines of Java code and 500 lines of Python scripts10,
and is composed of the following components:
(1)A modified version of Java 8 regexstandard library for col-
lecting profiling data τr(s).
(2)Animplementationofthegeneticalgorithmsdescribedin
Section3.
(3)A series of scripts for handle miscellaneous tasks, e.g. regex
extraction and syntax translation.
4.1 The Modified regexLibrary
The Java regexstandard library compiles a regex into an e-NFA,
ande-NFA’s state transitions are implemented by calling an e-NFA
state (represented by an instance of class Node)’s corresponding
matchmethod.Theslices Σsliceareextractedfromthe Slicenodes.
Thematchingtrace τr(s)iscollectedalongwiththeregexmatch-
ingeachtimewhenthe matchmethodofa Nodeinstanceisinvoked.
Inthematchingprocedure,wealsokeeptrackofalistof /angbracketleftxi,pi/angbracketright
and maintain the pivot index k, which splits the effective prefix
and the redundant suffix for string s, i.e.,k=|EP(s)|. Such col-
lected information suffices for conducting our three-phase ReDoS
vulnerability detection.
4.2 The Genetic Algorithm Implementation
Weadopttheearlyexitmechanisminboththeseedingandincubat-
ingphaseswhenmatching ragainstastring s∈Prequiresmore
than 105matching steps to terminate, and directly move on to the
pumpingphase.This treatmentpreventsthesearchfromhanging
when regex matching is extremely time-consuming.
Theparametersforthegeneticsearcharesettotypicalvaluesin
existing literatures [ 14,38,39]. In both the seeding and incubating
9EvenifthePumpingLemmadoesnotholdforextendedregexes,suchapumpable
structure may exist for crafting ReDoS strings. The pumping phase searches for such
structures by enumerating substrings in s.
10The ReScue tool is publicly available at https://2bdenny.github.io/ReScue/.
230
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. ReScue: Crafting Regular Expression DoS Attacks ASE ’18, September 3–7, 2018, Montpellier, France
Table 1: The regex sets for evaluation.
Name Number Description
RegLib [35] 2,992Online regex examples from
RegExLib.com
Snort [35] 12,499regexes extracted from the SnortNIDS for data packet filtering
Corpus [7] 13,597regexes from scraped pythonprojects
phases, we set the population size |P|=200. The crossover rate is
setto5%andthemutationrateissetto10%.Bothphasesterminate
after 200 iterations in case that the early exit mechanism is not
triggered.
The pumping phase also adopts the early exit mechanism. If
repeatingasubstring s(i:j)yieldsmorethan106matchingsteps(10 ×
largercomparedwiththeearlyexitthresholdintheseedingand
incubatingphases),thepumpingphaseexitsearlierbyreturning
theresultsofpumping s(i:j).Finally,ifapumpedstringyieldsmore
than 108matching steps, we consider that ReScue has successfully
generated a ReDoS string.
4.3 Miscellaneous Utilities
Though we implemented the tool in Java, we also implemented
scriptsforextractingregexesfromsourcecodewritteninotherpro-
gramminglanguages(inparticular,Python,JavaScript,andPHP),
and converting the extracted regexes into the Java regex syntax.
These scripts further helped us check the regexes from popular
GitHub open source projects, and all detected vulnerabilities are
discussed later in Section 5.4.
5 EVALUATION
The evaluation mainly concerns the following two aspects of ReS-
cue:
•(Effectiveness ) Is ReScue effective in detecting ReDoS vul-
nerabilities? Does it outperform existing techniques? Can
itdetectReDoSvulnerabilitiesinreal-worldprojects,even
written in other programming languages?
•(Efficiency ) Can ReScue run within a reasonable amount of
time?
5.1 Experimental Settings
We collected threesetsof regexes(29,088 regexes intotal) from the
evaluation of existing ReDoS vulnerability detection techniques, as
listed in Table 1, and the following techniques are compared:
•ReScue presented in this paper.
•SlowFuzz[ 31],adynamicgeneticfuzzingtechniqueforfind-
ing an input that maximizes the running time.
•RXXR2 [25,35], a static ReDoS vulnerability analyzer based
on pumping analysis.
•Rexploiter [ 48], another static ReDoS vulnerability analyzer
based on pumping analysis.
•NFAA [45], a static analyzer based on matching malicious
patterns in regexes.Foreachregex,weruneachevaluatedtechniqueunderthede-
fault setting to obtain a ReDoS string of maximum length /lscript=128,
andtheresults(theReDoSstringandthestatistics)arecollectedfor
evaluation and comparison. This size represents a typical scenario
inhandlinguntrusteduserinputs(e.g.,afieldinaWebformthat
is constrained by a moderate length limit). We consider an output
ReDoS string successfully exploiting the ReDoS vulnerability (true
positive) if it takes more than 108matching steps when applied to
the Java 8 regex engine.
We set a ten minute time limit to the genetic search in both
ReScue and SlowFuzz. When the search exceeds the time limit,
ReScue terminates regardless of its running phase while SlowFuzz
outputs the current population.
Eachtechnique’ssupportedregexextensionsareshowninTa-
ble2.RXXR2,Rexploiter,andNFAAparseaninputregexusinga
built-in parserand are independent ofthe underlyingregexengine.
In other words, these techniques output a potentially vulnerable
stringregardlessoftheactualmatchingprocedure,andmaypro-
duce false positives.
For SlowFuzz, we chose the one with the largest matching steps
astheReDoSstringinSlowFuzz’sfinal-roundpopulation.SlowFuzzisimplementedinCandlinkedwiththe(unmodified)PCRE2regexengine,whichisdifferentfromourevaluationenvironment.Tobest
alleviate such a difference for a fair comparison, we also appliedReScue generated ReDoS strings to the PCRE2 engine for cross
validation of the effectiveness.
Wealsoevaluatedtheeffectivenessofeachphase(seeding,in-
cubating,andpumping)inReScuebytemporarilydisablingeach
phaseandstudythecorrespondingnumberofsuccessfullygener-
ated ReDoS strings.
Allexperimentswereconductedonaserveroffourhexa-core
Intel Xeon X7460 processors (24 cores in total) and 64GB RAM
running Ubuntu 16.04.
5.2 Effectiveness Evaluation Results
5.2.1 Overall Results. The overall evaluation results are shown
inTable3.ConsideringtheJava8regexengine,allReDoSstrings
generatedbyalltechniquesfoundthat227regexesarevulnerable
(thereexistsastringofnomorethan /lscript=128charactersbutcosting
more than 108matching steps).
ReScuefound186(82%)ofthesevulnerabilitiesandsignificantly
outperformsalltheothertechniques.Thebestexistingtechnique
RXXR2 found 125 (accounting for 55% of all the known vulnerable
regexes) vulnerabilities. Compared with RXXR2, ReScue found
49% more vulnerabilities. SlowFuzz also successfully identified 101
vulnerableregexes,butisevenlesseffectivecomparedwithRXXR2.
Wealsoobservedthatstaticanalysesreportfalsepositives(dy-
namicanalysessearchtowardsthevulnerabilitycriteriaandalways
report true positives). The best existing technique RXXR2 reported
39% false positive cases, and Rexploiter and NFAA only reported a
tinyfractionoftruepositives.Thissupportedourclaimthatmodern
regex engines are complex and static analyses fall short.
Wecross-validatedthegeneratedReDoSstringstothePCRE2
regex engine (implemented in C), which is highly optimized and is
severalmagnitudesfasterthantheJavastandard regexlibrary.The
PCRE2 behaves quite differently than the Java regex engine, and
231
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Y. Shen, Y. Jiang, C. Xu, P. Yu, X. Ma, and J. Lu
Table 2: Supported regex extensions of each evaluated technique.
Features ReScue SlowFuzz RXXR2 Rexploiter NFAA
Set operations [a-z]&&[^aeiou] × /check × × ×
Lookarounds (?=) (?!) (?<=) (?<!) /check/check ×× ×
Backreferences ()\1 /check /check /check × ×
Non-capturing groups (?:) /check/check/check ××
Named groups /check /check × × ×
Atomic groups (?>) /check/check ×× ×
Conditionals ()?(?(1)) × /check × × ×
Greedy quantifiers {m,n} {n} {m,} /check/check/check /check/check
Lazy quantifiers ?? *? +? {}? /check /check /check /check /check
Possessive quantifiers ?+ *+ ++ {}+ /check/check ×× ×
Table 3: The overall evaluation results. #Vul. denotes the
number of vulnerabilities found and #FP denotes the num-
ber of false positives (output strings that costs less than 108
matching steps).
Technique #Vul.#FPTP Rate Avg Time (s)
ReScue 186 (82%) - - 0.6128
SlowFuzz 101 (44%) - - 0.5965
RXXR2 125 (55%) 8061% 0.0025
Rexploiter 30 (13%) 2152 1.3% 0.4073
NFAA 0 (0%) 714N/A 2.1546
Summary 227 (100%)
Table 4: The evaluation results of removing a phase. The
Coveragecolumncontainstheaverage e-NFAstatecoverage.
Variant #Vul.Avg Time (s) Coverage
ReScue 186 (82%) 0.6128 90.23%
without seeding 152 (67%) 0.5061 57.84%
without incubating 99 (44%) 0.1273 89.76%
without pumping 49 (22%) 0.5705 90.31%
almost all Java ReDoS strings quickly terminate on PCRE2. Consid-
eringtheReDoSstringsforJavafoundbySlowFuzzandReScue,
only 6/101 (SlowFuzz) and 8/186 (ReScue) exceed a matching time
of 1ms, and the median matching time of ReScue is merely 25%
longer than SlowFuzz.
Ontheotherhand,theJavaregexengineislessoptimized,whose
behaviorresemblestheJavaScript/Pythonregexengine.Thoughwe
cannot evidently prove that ReScue is more effective in finding Re-
DoSinstancesthanSlowFuzzforPCRE2,usingsuchalessoptimized
engine facilitates us finding previously unknown vulnerabilities
that cannot be detected by any evaluated technique.
Finally, the evaluation results also show that ReScue cannot
detectalltheseknownvulnerabilities.Thoughfinding82%ofthem
is a quite promising r esult, there is still space for improvement and
we will address this in the future work.
5.2.2 Effectiveness of the Phases. By removing a single phase in
ReScue,weevaluatedtheeffectivenessofeachphase.Theresultsare shown in Table 4, indicating that all the seeding, incubating,
and pumping phase contributed to the effectiveness of ReScue.
Removal of the seeding phase has the least impact (18% less
vulnerabilities detected) on the effectiveness. The seeding phase
pays an additional 0.1 seconds time cost to drastically improvethe
e-NFA statecoverage, whichisworthy inanalyzingcomplex
regexes and finding potential vulnerabilities hidden in the deep
states of a regex.
At first glance, one might thought that the seeding phase is not
very much useful in ReScue, however, recall that in the incubat-
ing phase, we force the population to maintain a high NFA state
coverage, i.e., the incubating phase subsumes the seeding phase to
someextend.Furthermore,bothseedingandincubatingphasesuse
the identical genetic representation and mutation/cross-over op-
erators, the seeding phase uniquely contributed to 18% of ReScue
discovered ReDoS strings.
Removal of the incubating has a significant impact on the effec-
tiveness. This is expected because the incubating phase searches
towards a string to maximize the matching efficiency, which is the
core of a dynamic algorithmic complexity fuzzer [31].
Removal of the pumping phase has the largest impact on the
effectivenesssimplybecausewesetamuchsmallerthresholdintheincubatingphase(10
5matchingsteps)comparedwiththethreshold
of a successful ReDoS attack (108matching steps, which is usually
reached in the pumping phase). In contrast, SlowFuzz [ 31] directly
searches for a algorithmic complexity because (1) the PCRE2 en-gine is hundreds times faster than the instrumented Java regex
engineinReScue;and(2)SlowFuzz’snativeCgeneticsearchim-
plementation, including mutation/cross-over operators, is much
moreefficientthanReScue.ReScueusesthepumpingalgorithmto
alleviate the issues caused by the relatively inefficient implementa-
tion. The 49 ReDoS strings found by ReScue without pumping are
consideredrelativeeasycasesthat ReDoScouldbetriggeredbya
simple fuzzing.
Withoutincubatingorpumpingphases,ReScuewouldbeless
effective than existing techniques in finding ReDoS vulnerabili-ties. The incubating phase creates ReDoS attack candidates, and
thesestringsarebeingfurtherenhancedbytheregex-designated
pumping algorithm. Therefore, we believe that the effectiveness
of ReScue is truly attributed to our carefully designed three-phase
regex-aware algorithms.
232
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. ReScue: Crafting Regular Expression DoS Attacks ASE ’18, September 3–7, 2018, Montpellier, France
0 100 200 300 400 500 600100102104
Running Time (s)# Regexes
Figure 3: The histogram of ReScue runtime over all evalu-
ated regexes
5.3 Efficiency Evaluation Results
The fifth column of Table 3shows the average time of process-
ingaregex,andFigure 3displaysthedetailedruntimehistogram
statisticsof ReScue.ReScuehasacomparablerunningtimewith
SlowFuzz(lessthanonesecondperregex),eveniftheJavaregex
engine with our profiling modifications is magnitudes slower than
thenativeCregexenginePCRE2.Webelievethatsuchefficiency
is due to our regex-designated algorithms, which quickly generate
cost-effective ReDoS strings.
5.4 Case Study: ReDoS in Popular GitHub
Projects
We searched the GitHub for highly starred Python and JavaScript
projectsthatcontaineither editor,web app,ordatabase inthe
project description. We downloaded 50 projects, scanned them
forregexes,andtestedtheseregexesusingReScueinthedefault
setting.
ReScue found ten previously unknown ReDoS vulnerabilities or
defects in these projects and we reported them in the projects’ cor-
respondingissuetrackingsystems.Sixreportshavebeenconfirmed
and several have already been fixed by the respective developer.Some confirmed cases and (simplified) ReScue generated ReDoS
strings are discussed as follows.
Meteor(39k stars) is a JavaScript App Platform. One of its regexes,
which is used to recognize comments in an HTML document, is
found vulnerable by ReScue:
1var_HashHTMLBlocks = function (text) {
2text = text.replace(
3/(\n\n[␣]{0,3}<!(--[^\r]*?-- \s*)+>[␣\t]*(?=\n{2,}))/ g
4, hashElement);
5// vulnerable to "\n\n<!--\n\n<!--------<\n\n<!--...->]Vx0
\n\n\n------!!<\ n\n\n\n]-----<!]Vx0\n\n-------<!"
This complex regex uses regex grammar extensions (the ?=
lookaround)andthusstaticanalysesfailtoparseit.Furthermore,
theReDoSvulnerabilityrequiresbothacertainprefixandacertain
suffix to trigger, making a black-box fuzzing fall short. None of
the evaluated techniques can detect this vulnerability except for
ReScue.tui.editor (6.3k stars) is a JavaScript WYSIWYG Markdown Edi-
tor. ReScue found that its syntax highlighting component may be
significantly slowed down under particular input combinations:
1const strikeRegex = /^[~~](.*[\s\n]*.*)*[~~]$/ ;
2// vulnerable to "~&aF~&aF~&aF~&aF~&aF~&aF~&aFxDHD#"
3...
4const Strike = CommandMana ger.command ('markdown', {
5...
6hasStrikeSyntax (text) {
7 return strikeRegex.test(text);
8},
9...
10}
ace(17k stars) is the Ajax.org Cloud9 code editor written in
JavaScript.Theregexforsyntaxhighlightingmayalsobestuckand
thus impair the entire application:
1this.removeCapturingGroups = function (src) {
2 varr = src.replace(
3 /\[(?:\\.|[^\]])*?\]|\\.|\(\?[:=!]|(\()/ g,
4 function ( x ,y ){ return y ? "(?:" : x;}
5);
6// vulnerable to "[[@[[@[@[_\>\?\|)\\>\?\|)\\>\?\|)
\\...>\?\|)\>\?\|\x<,T'@[x<,T'@[_"
7 return r;
8};
Open States (0.5k stars) is a Python crawler for gathering official
PDFfilesontheInternet.Afterscanningallregexesinthesource
code,ReScuefoundtwovulnerableregexes,andoneisshownas
follows:
1defscrape_lower(self):
2text = ...
3days = ...
4 forday in enumerate (days[1:]):
5 ifday[0] % 2 == 0:
6 date = day[1]
7 else:
8 events = re.split( r'\n((?:\w+\s?)+)\n' , day[1])
9 # vulnerable to "\na097a097a...097a4199613918"
Therefore,amaliciousWebpagemaysetupacraftedPDFfile
and hang the crawler.
Insummary,webelievethattheevaluationresultsconfirmedthe
effectiveness and efficiency of ReScue in detecting ReDoS vulnera-
bilities.TheJavaimplementationfound49%morevulnerabilities
compared with the best evaluated technique, and has a comparable
running time with a native C black-box fuzzer. The tool also de-
tected cross-language ReDoS vulnerabilities in popular real-world
projects.
6 RELATED WORK
6.1 Regex and ReDoS
Regex is widely used in real-world software projects. For exam-
ple, a survey of regex usage [ 7] shows that regex occurs in 42%
Python projects. Current regexes have multiple flavors and also
have different implementations of their matching engines [ 16,18].
However, some regex grammars depend heavily on a backtrack-
ingalgorithmandhavenotconsideredcarefullytheirunderlying
formalization [ 4,35]. This fact, on one hand, makes e-NFA + back-
tracking irreplaceable, and on the other hand, sometimes makes
these matching engines suffer from ReDoS.
233
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Y. Shen, Y. Jiang, C. Xu, P. Yu, X. Ma, and J. Lu
ReDoS[19,46]isoneformofalgorithmiccomplexityattacks[ 13],
and this kind of attacks can be used to craft low-bandwidth denial-
of-service threats, and even be used to attack some intrusion detec-
tion systems [2, 13,37].
6.2 Existing ReDoS Detection Techniques
Due to the existence of such ReDoS vulnerabilities, researchers
have proposed various techniques for detecting potential ReDoS
vulnerabilities before given regexes are fed to their matching en-
gines. Existing ReDoS detection tools can be mainly classified into
two types, as we discuss below.
6.2.1 StaticAnalysis. Thislineofworkisdedicatedtoformalize
regex grammars and statically search attack patterns from them.However, up to now there is still no static analysis tool that can
formalizeallregexgrammarsandsupportcompleteReDoSanalysis.
We introduce several representative tools below.
RXXR2[34,35]isaReDoSstaticanalysistooldevelopedfrom
RXXR[25].Theauthorsproposedageneralattackstringpattern
intheformof(prefix, pumpablestring, suffix).To usethispattern,
they convert given regexes into an e-NFA structure, and with an
efficientpatternmatchingalgorithm,theysearchforinstancesof
this pattern in the e-NFA. However, due to the restrictions of their
proposed e-NFA converter, regexes with extended grammars is out
of the scope of their analyses.
Rexploiter [ 48] is a tool that not only detects ReDoS vulner-
abilities but also conducts taint-propagation analysis to exclude
user-input unreachable regexes. However, this tool builds on a sim-
ilar NFA-alike structure as in RXXR2, and this foundation makes it
also unable to parse extended regexes.
Weidemanet. al.[45]usea staticanalysismethodbased onthe
pNFA[3,4]todevelopanNFAAtoolfordetectingReDoSvulner-
abilitiesforregexes.pNFAisanewautomatonmodel,whichcan
describenotionslike backreferencesandnamedgroups.However,
new attack string patterns based on this model need exploration
and improvement.
Sugiyama et. al. [ 41] propose detecting ReDoS vulnerabilities by
simulatingtheregexmatchingprocessbyatreetransducer.They
showthattreetransducingisformallyequivalenttoregexmatching,andthatReDoSvulnerabilitiescanbedetectedbyanalyzingthetree
transducer’s size increment with trials of manual inputs. However,
sincethisprocessreliesonhumanknowledge,itisnotsubjectto
automation.
6.2.2 Dynamic Fuzzing. This line of work takes the idea of fuzz
testing[17,32]fromthesoftwaretestingcommunity.Withthesup-
portofruntimeanalysis,thiskindoftoolleavestheregexparsingto
existing regex matching engines, and is devoted only to generating
time-consuming strings for exposing potential ReDoS vulnerabili-
ties. We also introduce several representative tools below.
SlowFuzz [ 31] is a general algorithmic complexity attack tool
based on dynamic fuzzing. It uses an evolutionary fuzzer (based
on LibFuzzer [ 32]) to search for those inputs that can trigger a
large number of edges in the control flow graph of the programunder testing. However, due to its generic nature, SlowFuzz has
no knowledge about regex structures, and this fact can cause some
deep states of the program unreachable, leading to false negatives.SDLFuzzerisanotherdynamicfuzzerforReDoSdetection[ 42,
43], developed by Bryan Sullivan from Microsoft in 2010. However,
this tool has no longer been maintained and has no further update
since then. Therefore, the tool does not support many extended
regexgrammars,e.g.,lookarounds,namedgroups,atomicgroups,
backreferences, and lazy or possessive quantifiers.
6.3 ReDoS Prevention or Alleviation
ReDoSattackscanalsobepreventedoralleviatedbytwotreatments,
namely, equivalent regex conversion and regex matching speedup,
as we discuss below.
6.3.1 Equivalent Regex Conversion. This treatment tries to find
equivalentinvulnerableregexestoreplacetheoriginalonesthatare
vulnerable to ReDoS attacks. For example, Cody-Kenny et. al. [ 10]
proposeapplyinggeneticalgorithmstofindanequivalentregexthat
describes the same language as the given original regex and at the
sametimeisfreeofanyReDoSvulnerability.Thentheoriginalregex
canbesafelyreplacedwithout affectingfunctionalities.However,
one limitation is that due to the lack of a testing input set that
canenumerate allstringsin thelanguage, theapproachmay not
guarantee the equivalence between the newly generated regex and
its corresponding original regex.
6.3.2 RegexMatchingSpeedup. Speeduptreatmentsforregex
matching are possible for special cases where regexes contain only
simple grammars, whose matching can be optimized by dedicated
techniques. For example, matching for basic regexes can be sig-
nificantly speed up by parallel algorithms [ 28], GPU-based algo-
rithms [49], state-merging algorithms [ 1], and techniques that con-
vert NFAs to DFAs [ 12]. We note that this can only alleviate the
ReDoSvulnerabilityproblem,buttheconcernedregexesthemselves
are still subject to complexity attacks.
7 CONCLUSION
This paper presents ReScue, a three-phase technique, to automati-
cally detect regular expression Denial-of-Service (ReDoS) vulnera-
bilities. ReScue seeds, incubates, and finally pumps an initial popu-
lationofstringstoobtainaReDoSattackstringwhosematching
timeismaximized.TheevaluationresultsshowthatReScueoutper-formsstate-of-the-arttechniquesindetectingReDoSvulnerabilities
andfoundpreviouslyunknownvulnerabilitiesinpopularGitHub
open-source projects. Finally, the evaluation results also suggestthat there is space for improvement. We plan to further enhance
thethree-phasealgorithmsformoreeffectivedetectionofReDoS
vulnerabilities.
ACKNOWLEDGMENTS
Theauthorswouldliketothanktheanonymousreviewersfortheir
commentsandsuggestions.ThisworkissupportedinpartbyNa-
tional Key R&D Program (Grant #2017YFB1001801), National Basic
Research 973 Program (Grant #2015CB352202), National Natural
ScienceFoundation(Grants#61690204,#61472174)ofChina,and
theCollaborativeInnovationCenterofNovelSoftwareTechnology
and Industrialization, Jiangsu, China.
234
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. ReScue: Crafting Regular Expression DoS Attacks ASE ’18, September 3–7, 2018, Montpellier, France
REFERENCES
[1]Michela Becchi and Srihari Cadambi. 2007. Memory-efficient regular expression
searchusingstatemerging.In Proceedingsofthe26thIEEEInternationalConference
on Computer Communications (INFOCOM ’07). 1064–1072. https://doi.org/10.
1109/INFCOM.2007.128
[2]UdiBen-Porat,AnatBremler-Barr,HanochLevy,andBernhardPlattner.2012. On
thevulnerabilityofhardwarehashtablestosophisticatedattacks.In International
ConferenceonResearchinNetworking (Networking’12).135–148. https://doi.org/
10.1007/978-3-642-30045-5_11
[3]Martin Berglund, Frank Drewes, and Brink Van Der Merwe. 2014. Analyzing
Catastrophic Backtracking Behaviorin Practical Regular Expression Matching.
InProceedings of the 14th International Conference on Automata and Formal Lan-
guages (AFL ’14). 109–123.
[4]MartinBerglundandBrinkvanderMerwe.2017. Onthesemanticsofregular
expression parsing in the wild. Theoretical Computer Science 679 (May 2017),
69–82.https://doi.org/10.1016/j.tcs.2016.09.006
[5]AnneBrüggemann-Klein.1993. Regularexpressionsintofiniteautomata. The-
oreticalComputerScience 120,2(Nov.1993),197–213. https://doi.org/10.1016/
0304-3975(93)90287-4
[6]Cezar Câmpeanu, Kai Salomaa, and Sheng Yu. 2003. A formal study of practical
regular expressions. International Journal of Foundations of Computer Science 14,
06 (Nov. 2003), 1007–1018. https://doi.org/10.1142/S012905410300214X
[7]Carl Chapman and KathrynT Stolee. 2016. Exploringregular expression usage
and context in Python. In Proceedings of the 25th International Symposium on
Software Testing and Analysis (ISSTA ’16). 282–293. https://doi.org/10.1145/
2931037.2931073
[8]Noam Chomsky. 1956. Three models for the description of language. IRE Trans-
actions on Information Theory 2, 3 (Oct. 1956), 113–124. https://doi.org/10.1109/
TIT.1956.1056813
[9]John Clarke, Jose Javier Dolado, Mark Harman, Rob Hierons, Bryan Jones, Mary
Lumkin, Brian Mitchell, Spiros Mancoridis, Kearton Rees, Marc Roper, et al .
2003. Reformulating software engineering as a search problem. IEE Proceedings -
Software150, 3 (June 2003), 161–175. https://doi.org/10.1049/ip-sen:20030559
[10]Brendan Cody-Kenny, Michael Fenton, Adrian Ronayne, Eoghan Considine,
ThomasMcGuire,andMichaelO’Neill.2017. Asearchforimprovedperformance
inregularexpressions.In ProceedingsoftheGeneticandEvolutionaryComputation
Conference (GECCO ’17). 1280–1287. https://doi.org/10.1145/3071178.3071196
[11]ErikCorry,ChristianPHansen,andLasseRHNielsen.2009. Irregexp,Google
Chrome’s New Regexp Implementation. https://blog.chromium.org/2009/02/
irregexp-google-chromes-new-regexp.html
[12]RussCox.2007. Regularexpressionmatchingcanbesimpleandfast(butisslowin
Java, Perl, Php, Python, Ruby, ...). Technical Report.
[13]ScottACrosbyandDanSWallach.2003. DenialofServiceviaAlgorithmicCom-
plexity Attacks. In Proceedings of the 12th USENIX Security Symposium (USENIX
Security ’03). 29–44. https://dl.acm.org/citation.cfm?id=1251356
[14]Yuan-Shun Dai, Min Xie, Kim-Leng Poh, and Bo Yang. 2003. Optimal testing-
resource allocation with genetic algorithm for modular software systems. Jour-
nal of Systems and Software 66, 1 (April 2003), 47–55. https://doi.org/10.1016/
S0164-1212(02)00062-6
[15]PythonSoftwareFoundation.2018. regex(PyPI). https://pypi.org/project/regex/
[16]Jeffrey E F Friedl. 2006. Mastering Regular Expressions: Understand Your Data and
Be More Productive (3th ed.).
[17]Patrice Godefroid, Michael Y Levin, David A Molnar, et al .2008. Automated
whitebox fuzz testing. In Proceedings of the 16th Annual Network and Distributed
System Security Symposium (NDSS ’08) . 151–166. http://www.isoc.org/isoc/
conferences/ndss/08/papers/10_automated_whitebox_fuzz.pdf
[18]Jan Goyvaerts. 2018. Popular Tools, Utilities and Programming Languages That
Support Regular Expressions. https://www.regular-expressions.info/tools.html
[19]Jan Goyvaerts. 2018. Runaway Regular Expressions: Catastrophic Backtracking.
https://www.regular-expressions.info/catastrophic.html
[20]Mark Harman and Bryan F Jones. 2001. Search-based software engineering.
InformationandSoftwareTechnology 43,14(Dec.2001),833–839. https://doi.org/
10.1016/S0950-5849(01)00189-6
[21]Mark Harman, S Afshin Mansouri, and Yuanyuan Zhang. 2012. Search-basedsoftware engineering: Trends, techniques and applications. ACM Computing
Surveys(CSUR) 45,1,Article11(Nov.2012),61pages. https://doi.org/10.1145/
2379776.2379787
[22]PhilipHazel.2017. BacktrackingLimitofPCREMatch. http://www.pcre.org/
current/doc/html/pcre2api.html
[23]John E Hopcroft, Rajeev Motwani, and Jeffrey D Ullman. 2006. Introduction to
Automata Theory, Languages, and Computation (3rd ed.).
[24]MohdEhmerKhan,FarmeenaKhan,etal .2012. Acomparativestudyofwhite
box,blackboxandgreyboxtestingtechniques. InternationalJournalofAdvanced
ComputerScienceandApplications 3,6(2012),12–15. https://doi.org/10.14569/
ijacsa.2012.030603
[25]JamesKirrage,AsiriRathnayake,andHayoThielecke.2013. Staticanalysisfor
regularexpressiondenial-of-serviceattacks.In Proceedingsofthe7thInternationalConferenceonNetwork andSystemSecurity (NSS’13).135–148. https://doi.org/
10.1007/978-3-642-38631-2_11
[26]Stephen Cole Kleene. 1951. Representation of Events in Nerve Nets and Finite
Automata. Technical Report.
[27]AndrewMKuchling.2018. RegularExpressionHow-To. https://docs.python.
org/3/howto/regex.html
[28]Cheng-Hung Lin, Chen-Hsiung Liu, and Shih-Chieh Chang. 2011. Accelerating
regular expression matching using hierarchical parallel machines on GPU. In
Proceedings of the 2011 IEEE Global Telecommunications Conference (GLOBECOM
’11). IEEE, 1–5. https://doi.org/10.1109/GLOCOM.2011.6133663
[29]Phil McMinn. 2004. Search-based software test data generation: A survey. Soft-
ware Testing, Verification and Reliability 14, 2 (June 2004), 105–156. https:
//doi.org/10.1002/stvr.294
[30]Carlos Pacheco, Shuvendu K Lahiri, Michael D Ernst, and Thomas Ball. 2007.
Feedback-directedrandomtestgeneration.In Proceedingsofthe29thInternational
Conference on Software Engineering (ICSE ’07). 75–84. https://doi.org/10.1109/
ICSE.2007.37
[31]Theofilos Petsios, Jason Zhao, Angelos D Keromytis, and Suman Jana. 2017.
Slowfuzz:Automated domain-independentdetectionofalgorithmic complexity
vulnerabilities.In ProceedingsoftheInternationalConferenceonComputerand
Communications Security (CCS ’17). 2155–2168. https://doi.org/10.1145/3133956.
3134073
[32]LLVMProject.2018. libFuzzer:Alibraryforcoverage-guidedfuzztesting. https:
//llvm.org/docs/LibFuzzer.html
[33]Michael O Rabin and Dana Scott. 1959. Finite automata and their decision
problems. IBMJournalofResearchandDevelopment 3,2(April1959),114–125.
https://doi.org/10.1147/rd.32.0114
[34]Asiri Rathnayake. 2015. Semantics, analysis and security of backtracking regular
expression matchers. Ph.D. Dissertation. Advisor(s) Thielecke, Hayo. http:
//etheses.bham.ac.uk/6011/
[35]AsiriRathnayakeandHayoThielecke.2014. Staticanalysisforregularexpression
exponential runtime via substructural logics. (2014). arXiv:arXiv:1405.7058
[36]JurajHajduch(SK).2007. RegExLib:Aregularexpressionlibrary. http://www.
regexlib.com/REDetails.aspx?regexp_id=2598
[37]RandySmith,CristianEstan,andSomeshJha.2006. Backtrackingalgorithmic
complexity attacksagainst a NIDS.In Proceedings ofthe 22ndAnnualComputer
Security Applications Conference (ACSAC ’06). 89–98. https://doi.org/10.1109/
ACSAC.2006.17
[38]Mozhan Soltani, Annibale Panichella, and Arie van Deursen. 2017. A guided
geneticalgorithmforautomatedcrashreproduction.In Proceedingsofthe39th
International Conference on Software Engineering (ICSE ’17). 209–220. https:
//doi.org/10.1109/ICSE.2017.27
[39]Praveen Ranjan Srivastava and Tai-hoon Kim. 2009. Application of genetic
algorithm in software testing. International Journal of Software Engineering and
Its Applications 3, 4 (Oct. 2009), 87–96.
[40] Cristian-Alexandru Staicu and Michael Pradel. 2018. Freezing the web: A study
of redos vulnerabilities in javascript-based web servers. In 27th USENIX Security
Symposium (USENIX Security ’18).
[41]Satoshi Sugiyama and Yasuhiko Minamide. 2014. Checking time linearity of
regularexpressionmatchingbasedonbacktracking. IPSJOnlineTransactions 7
(Nov. 2014), 82–92. https://doi.org/10.2197/ipsjtrans.7.82
[42]BryanSullivan.2010. NewTool:SDLRegexFuzzer. https://cloudblogs.microsoft.
com/microsoftsecure/2010/10/12/new-tool-sdl-regex-fuzzer
[43]BryanSullivan.2010. RegularExpressionDenialofServiceAttacksandDefenses.
https://msdn.microsoft.com/en-us/magazine/ff646973.aspx
[44]Ken Thompson. 1968. Programming techniques: Regular expression search
algorithm. Commun.ACM 11,6(June1968),419–422. https://doi.org/10.1145/
363347.363387
[45]Nicolaas Weideman, Brink van der Merwe, Martin Berglund, and Bruce Watson.
2016. Analyzing matching time behavior of backtracking regular expression
matchersbyusingambiguityofNFA.In ProceedingsoftheInternationalConference
on Implementation and Application of Automata (CIAA ’16). 322–334. https:
//doi.org/10.1007/978-3-319-40946-7_27
[46]Adar Weidman. 2017. Regular Expression Denial of Service - ReDoS. https:
//www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS
[47]DarrellWhitley.1994. Ageneticalgorithmtutorial. Statisticsand Computing 4,2
(June 1994), 65–85. https://doi.org/10.1007/BF00175354
[48]Valentin Wüstholz, Oswaldo Olivo, Marijn JH Heule, and Isil Dillig. 2017. Static
detection of DoS vulnerabilities in programs that use regular expressions. In
ProceedingsoftheInternationalConferenceonToolsandAlgorithmsfortheCon-
struction and Analysis of Systems (TACAS ’17). 3–20. https://doi.org/10.1007/
978-3-662-54580-5_1
[49]Xiaodong Yu and Michela Becchi. 2013. GPU acceleration of regular expression
matching for large datasets: Exploring the implementation space. In Proceedings
of the ACM International Conference on Computing Frontiers . Article 18, 10 pages.
https://doi.org/10.1145/2482767.2482791
235
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. 