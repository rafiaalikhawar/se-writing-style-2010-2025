A Static Verification Framework for Message Passing in Go using
Behavioural Types
Julien Lange
University of Kent
j.s.lange@kent.ac.ukNicholasNg
ImperialCollege London
nickng@imperial.ac.ukBernardo Toninho
Imperial College London
b.toninho@imperial.ac.ukNobukoYoshida
ImperialCollege London
n.yoshida@imperial.ac.uk
ABSTRACT
The Go programming language has been heavily adopted in indus-
tryasalanguagethatefficientlycombinessystemsprogramming
withconcurrency.Go’sconcurrencyprimitives,inspiredbyprocess
calculisuchasCCSandCSP,featurechannel-basedcommunication
and lightweight threads, providing a distinct means of structuring
concurrentsoftware.Despiteitspopularity,theGoprogramming
ecosystemofferslittletonosupportforguaranteeingthecorrect-
ness of message-passing concurrent programs.
Thisworkproposesapracticalverificationframeworkformes-
sage passing concurrency in Go by developing a robust static anal-
ysisthatinfersanabstractmodelofaprogram’scommunication
behaviour in the form of a behavioural type , a powerful process
calculitypingdiscipline.Wemakeuseofouranalysistodeploya
model and termination checking based verification of the inferred
behavioural type that is suitable for a range of safety and liveness
propertiesofGoprograms,providingseveralimprovementsover
existingapproaches.Weevaluateourframeworkanditsimplemen-
tationon publicly available real-world Go code.
CCSCONCEPTS
•Theoryofcomputation →Verificationbymodelchecking ;
Typetheory ;Processcalculi; •Softwareanditsengineering →
Model checking ;Automated static analysis ;Softwareverifica-
tion;Concurrent programming languages ;
ACM Reference Format:
JulienLange,NicholasNg,BernardoToninho,andNobukoYoshida.2018.A
StaticVerificationFrameworkforMessagePassinginGousingBehavioural
Types.In ICSE’18:ICSE’18:40thInternationalConferenceonSoftwareEn-
gineering,May27-June3,2018,Gothenburg,Sweden. ACM,NewYork,NY,
USA, 12 pages. https://doi.org/10.1145/3180155.3180157
1 INTRODUCTION
Modern programming languages have evolved with the ever in-
creasing need for highly available, interactive software services ,
providing programmers with frameworks that facilitate the devel-
opmentof suchintricatecommunicating systems.Amongstthese
languages, the Go programming language created at Google in
2007targetsthe development of concurrent software systems by
integrating channel-based concurrency and lightweight threads as
ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
© 2018 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-5638-1/18/05.
https://doi.org/10.1145/3180155.3180157distinctivelanguagefeatures,greatlyinspiredbyadvancesinformal
languagesforconcurrencytheoryknownas processcalculi [43].Go
enablesprogrammerstowritestatically-typedconcurrentsoftware,
andhasbeenusedsuccessfullyinarangeofindustrialsettingssuch
as Uber [ 45] and Dropbox’s infrastructure [ 15], the Docker [ 14]
software container platform, the Kubernetes [ 27] cluster manager,
amongothers [9, 41].
However,beyonditssimplestatictypesystem,Goprovidesfairly
fewassurancesonthecorrectnessofconcurrentcode.Atcompile
time,Goonlyenforcesthatmessagesexchangedviacommunication
channels adhere to thedeclared channel payload types, providing
nowayofdetectingcommonconcurrencyerrorssuchasdeadlocks
orundeliveredmessages.Atruntime,Gooffersonlyatoyglobal
deadlockdetector.Thisisinsharpcontrastwiththerichbodyof
workonprocesscalculi-basedverification,whereaplethoraoftype-
based and logic-based techniques enable reasoning about safety
andliveness properties of interactive systems.
Given the foundations of Go’s message-passing concurrency
in process calculi, our work aims to bridge the divide between
thefoundationsandprogrammingpracticesbyapplyingmodern
process calculi based verification techniques to real-world Go con-
current programming. Concretely, we propose a static verification
framework for concurrency and message-passing communication
usingconcurrentbehaviouraltypes [24],whichhavebeendeveloped
extensively in concurrency theory since the early 90s.
To achieve this, we crucially address the substantial concep-
tual gap that exists between a formal mathematical language (a
process calculus) and a general purpose programming language
withconcurrencyfeatures.OurapproachanalysesgeneralGosour-
ce code and distills from programs behavioural types that serve
as a faithful modelof its message-passing concurrent behaviour.
Our behavioural types consist of a simplified form of concurrent
processes which are reminiscent of Concurrent Communicating
Systems (CCS) [ 34] or Communicating Sequential Processes (CSP)
[22] (which inspired the design of the Go language). Given such a
formallygroundedmodel,wemaythenapplyarangeofprocesscal-
culi oriented verification techniques to Go. Specifically, we convert
Gosourcecodeintoastaticsingleassignment(SSA)formwhich
provides a fine-grained view of the concurrency primitives used in
programs in a quasi-functional form [ 2], enabling our behavioural
typeinference.Wethenemploymodelcheckingandtermination-
checking techniques to automatically verify safety and liveness
properties such as deadlock-freedom and communication safety.
Asignificantadvantageofourapproachoverpreviousworks[ 30,
36,40]is thatour inferenceprocedure covers amuch largerpart of
the Go language allowing for the automatic extraction of an accu-
ratemodelofaprogram’sconcurrency-relatedfeatures,resultingin
amore preciseanalysiswithreduced numbersoffalse alarmsand
"$.*&&&UI*OUFSOBUJPOBM$POGFSFODFPO4PGUXBSF&OHJOFF SJOH
This work is licensed under a Creative Commons
Attribution International 4.0 License.
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June3, 2018, Gothenburg, Sweden JulienLange, NicholasNg, Bernardo Toninho, and Nobuko Yoshida
1 funcprod(ch chan int ){
2 fori: =0 ;i<5 ;i + +{
3 ch <- i // Send i to ch
4}
5close(ch)// No further values accepted at ch
6}
7 funccons(ch1, ch2 chan int ){
8 for{
9 select {
10 casex := <-ch1: print(x)// Either input from ch1
11 casex := <-ch2: print(x)// or input from ch2
12 }
13}
14}
15 funcmain() {
16ch1, ch2 := make(chan int ),make(chan int )
17 goprod(ch1)
18 goprod(ch2)
19cons(ch1,::ch1)
20}
Figure 1: Partially deadlocked Producer-Consumer in Go.
undetectederrors.Ourintegrationwithageneralpurposemodel
checker also enables us to modularly verify arbitrary safety and
livenessproperties,overthemoresingle-mindednatureofprevi-
ously proposedtechniques, aswell astake advantageof advances
in model checking to provide better performance scaling.
ConcurrentProgramminginGo. Weprovideanoverviewof
the Goprogramming language withan emphasis onthe challenges
ofconcurrentprogrammingandhowourverificationframework
can check for common concurrency errors in programs.
Go is a language with message-passing concurrency features
and lightweight threads (known as goroutines ). The key feature
of Go’s concurrency primitives is the predominance of channel-
basedcommunication over shared memory based communication
amongst threads. In Go, a channel consists of a (typed) buffer that
canbeusedbyanarbitrarynumberofthreadsforreadandwrite
operations.Channelsare synchronous bydefault(i.e.blockingon
readsandwrites)butcanbemadeasynchronousbyspecifyinga
buffersizeduringchannelcreation.Asynchronouschannelsprovide
non-blocking sends whilethe bufferis not full.
We introduce theGo programming language with the program
inFigure1whichimplementsaproducer/consumerconcurrentpat-
ternwithtwoproducersandoneconsumerthread,communicating
over a pair of synchronous channels. The producer code (lines 1-6)
is written as a function that takes as a parameter a channel chthat
cancarrypayloadsoftype int.Aproducermerelysendsaninteger
value over the given communication channel ch(writtench <- i
in Go, where iis the value to be sent) a predetermined number of
times(encodedasa forloop)andthen closesthechannel,signalling
thatno further values are to be sent.
The consumer code (lines 7-14) is specified as a function taking
twochannels ch1andch2(oneperproducer).The consfunction
consists of a common Go idiom known as a for-select loop: a po-
tentially infinite loop (the parameterless foron line 8) containing
a selective communication construct (line 9). The behaviour of
selectis such that the consumer waits for an input on either ch1
orch2(inputs in Go are written <-ch). Whenever communication
is available, the appropriate caseis selected. The consumer printsGo
Source
codeInference
Go SSABehavioural
types
Model
Checker
mCRL2[10]
Termination
Checker
KITTeL[17]
Figure 2: The Godel Checker [31] workflow.
the received integer from either producer. Despite the channels
being closed by the producers, the consumer’s inputs still succeed.
Finally,theprogramentrypoint( maininlines15-20)setsupthe
producersandconsumerbycreatingthetwosynchronouschannels
ch1andch2(line16),spawningtwoproducersinparallel(achieved
by the goprefix to the function calls, which creates a goroutine
that runs in parallel with the main program executing the prod
function)and then runningthe consfunction.
Common concurrency errors in Go. We describe common
errors in channel-based Go programming, as well as limitations of
Go’s built-in runtime detector:
Channel safety errors: Once a channel is closed, receive actions
always succeed (receiving messages in-flight or a default value for
the payload type), but all send and close actions performed on the
channel raise a runtime error. Hence, channels should be closed at
mostonceand no message should be sent on closed channels.Global deadlocks:
The Goruntimecontains a globaldeadlock
detector that signalsa runtime errorwhen allgoroutines in apro-
gramarestuck(i.e.deadlocked).Howeveritisoftenthecasethat
when certain libraries are imported (such as the commonly used
netlibrary for networking) the global deadlock detector is silently
disabled[5], i.e. all global deadlocks are just ignored.
Partial deadlocks: It is often the case that a program’s commu-
nicationcannotprogressdespite someofitsgoroutinesnotbeing
stuck. This is known as a partialdeadlock or as a failure of live-
ness. For instance, the consfunction above is being executed with
thewrongchannels ( ch1twice instead of ch1andch2), due to a
programmererror.Runningtheprogramresultsinasystemthat
is notlive, since the second producer is not interacting with the
consumer – the outputs are never matched with their respective
inputs. Since only a subset of the goroutines are stuck, these errors
cannotbe detected by the Go runtime.
AstaticverificationframeworkforGo. Thispaperproposes
astaticanalysistoolchaindubbedGodelChecker[ 31],whichcan
automatically detect safety and liveness errors in real-world Go
programs.TheworkflowispresentedinFigure2,consistingofthree
layers: given a Go program we first perform (1) behavioural type
inference (detailed in § 3) that extracts a behavioural type model
for the program (§ 2). In this stage, we use the SSA (static single
assignment) package from the Go project and apply a control flow
analysis to obtain behavioural types. We then apply (2) a model
checkingtool,mCRL2[10],totheextractedbehaviouraltypes(§4).
Thisenablesustochecktypeswithafinitestate-space(i.e. finite
control)fortheabsenceofglobaldeadlocks,aswellasseveralGo
specific safety properties (including channel safety). Finally, to
pinpointpotentiallyproblematicloopsandaccuratelydetectpartial

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. A Static Verification Framework for Message Passing in Go using Behavioural Types ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
deadlocks,weaugmentourapproachwithaterminationanalysis
for loops in the original Go source code using a term-rewriting
based tool, KITTeL[17] (§ 5). We show benchmarks for (publicly
available)Go programs and compare with existing tools (§ 6).
2 BEHAVIOURAL TYPES FOR GO
This section introduces behavioural types [24] for concurrent Go
(whichareinferedasanabstractmodelofGo–see§3)andtheir
relationshipwithGoprograms,followingourpreviousworkin[ 30].
Behaviouraltypesareatypingdisciplineinwhichtypesexpress
thepossibleactionsofaprograminafine-grainedway[ 24].When
applied to communication and concurrency, behavioural types act
as an abstract specification of all communication actions that may
be performed in a program. Moreover, behavioural types are an
executable specification. They have a natural operational meaning
and evolve throughout program execution.
The syntax of types is given below, it extends the types defined
in [30] with general sequencing. The types abstract away data
elements, singling out the concurrency specific features such as
spawning of threads (i.e. goroutines ), creation of communication
channels,send and receive actions, and selective communication.
α/colonequalu|u|τ T/colonequal{ti(˜yi)=Ti}i∈IinS
T,S/colonequalα;T|T;S|T⊕S|/binampersand{αi;Ti}i∈I|(T|S)|0
|(newna);T|closeu;T|t/angbracketleft˜u/angbracketright|⌊a⌋n
k|a⋆
Communication is specified with the αprefix, where αcan beu,
denotingasendonchannel u,u,denotingthedualreceiveactionon
channeluandτ,denotingasilentinternalstep( uiseitheraconstant
channeloravariable). T;Smodelsthesequentialcompositionof
TandS. The construct closeusignals that channel uis to be
closed.Werepresentconditionalbranchingwiththe T⊕Sconstruct,
denotinga non-deterministic internalchoicebetween TandS.Thus,
our type level analogue of conditional branching does not depend
ondatabutrathersimulatestheabilitytotakeeitherbranchofa
conditionalthrougha non-deterministic step.
We model Go’s selective communication with /binampersand{αi;Ti}i∈I. The
construct waits for the availability of one of the αicommunication
actions.Whensomeaction αjbecomesavailable,itisexecutedand
thecommunicationevolvestobehaviour Tj(discardingtheother
options).Whenmorethanonecommunicationactionisavailable,
one is chosen non-deterministically. Since τactions are always
available to fire, we can use a τaction in a select construct to
model timeouts or default behaviours when no other actions are
available. The parallel composition construct T|Sdenotes the
parallelexecutionof TandS;theconstruct 0denotesnobehaviour.
ChannelsinGoaresynchronousbuffersbydefault,butmayalso
becreatedwith a bound,achievingasynchronous communication.
Send actions are non-blocking until the number of messages in
the buffer reaches the bound and, dually, receive actions on empty
buffersareblockinguntilamessageisavailable. (newna);Tdenotes
the creation of a channel a(with a bound n) which can be used
locally in T. If the bound nis set to 0, then ais a synchronous
channel. We often write (newa);Tfor(new0a);Tand assume that
the scope of aextends as far to the right as possible.
Construct t/angbracketleft˜u/angbracketrightdenotes a function call with parameter ˜u.W e
oftenidentifyalist ˜uwithitsunderlyingsetandwrite x∈˜uifxisaelementof ˜u.Weusethefollowingtwo runtimeconstructstodefine
the semantics of types in § 4: ⌊a⌋n
krepresents a communication
channel at a(wherenis the maximum capacity of the queue and k
is the current number of messages in it) and a⋆represents a closed
channela.
The type of a program, sometimes written {ti(˜yi)=Ti}i∈IinS,
is a set of (potentially mutually recursive) definitions Tiwith a
distinguishedprogram entrypoint S.Recursivedefinitionscanbe
parameterisedbycommunicationchannelsandrepresentthe gor-
outinesthatare executedinthe program.Foreachtype definition
ti(˜yi)=Tiwe assume that the free names of Tiare included in ˜yi.
Example 2.1 (Type for Consumer-Producer and their Properties).
The behavioural type for the program of Figure 1 is given below.
/braceleftbig
prod(ch)=ch;prod/angbracketleftch/angbracketright⊕closech
cons(ch1,ch2)=/binampersand{ch1;cons/angbracketleftch1,ch2/angbracketright,ch2;cons/angbracketleftch1,ch2/angbracketright}
main()=(newch1,ch2);(prod/angbracketleftch1/angbracketright|prod/angbracketleftch2/angbracketright|cons/angbracketleftch1,ch1/angbracketright)/bracerightbig
inmain/angbracketleft/angbracketright
Definition prod(ch)specifiesthetypeforthe Producer function,
while cons(ch1,ch2)stands for the type of the Consumer function,
andmain/angbracketleft/angbracketrightis the type of the program entry point (i.e. the main
function).Noticehowtheimperativecontrolstructuresaretrans-
formed into recursive definitions and the data elements are erased.
For instance, the type prodspecifies the behaviour of performing
aninternalchoice(denotedbythe ⊕construct)betweensending
onchand recursing or closing the channel chandterminating.
Given that behavioural types act as a form of executable specifi-
cations,itisnaturaltoconsiderpropertiesof typesintermsoftheir
executions, as well as their relationship with program properties.
2.1 BehaviouralProperties of Types
The property of global deadlock-freedom (GDF) entails that if
a communication action is available to fire, the type can alwaysmake progress, meaning that a type as a whole is never globally
stuck. For instance, the type
mainin Example 2.1 satisfies GDF
since the communication actions in subcomponents prod/angbracketleftch1/angbracketright
andcons/angbracketleftch1,ch1/angbracketrightcanalwaysmakeprogress,despitethefactthat
actionsin prod/angbracketleftch2/angbracketrightare always stuck.
Thepropertyof liveness,alsoknownas partial deadlock free-
dom,isstrictlystrongerthanGDF,giventhateverylivetypeisalso
GDF. It states that allcommunications that can become enabled
in a type can always eventually fire. For instance, replacing the
call to cons/angbracketleftch1,ch1/angbracketrightwith cons/angbracketleftch1,ch2/angbracketrightmakes the type main/angbracketleft/angbracketright
in Example 2.1 satisfy liveness. We note that in the presence of
internalchoice(i.e.conditionalbranching),livenessrequiresthat
communicationactionsin bothbranchesmust eventually succeed,
but when facing external choice (i.e. the selectconstruct), only
branches that can be selected are required to eventually succeed.
For instance, the following single-producer variant of main/angbracketleft/angbracketrightalso
satisfieslivenesseventhoughthe ch2branchintheselectconstruct
can never be taken: (newch1,ch2);(prod/angbracketleftch1/angbracketright|cons/angbracketleftch1,ch2/angbracketright).
In § 4, we formally define the above properties, as well as other
properties that are verified in our work, in the modal μ-calculus.

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June3, 2018, Gothenburg, Sweden JulienLange, NicholasNg, Bernardo Toninho, and Nobuko Yoshida
1funcmain() {
2ch :=make(chan int )// Create channel
3 gosendFn(ch) // Run as goroutine
4x := recvVal(ch) // Ordinary func call
5 fori: =0 ;i<x ;i + +{
6 print(i)
7}
8close(ch)// Close channel ch
9}
10 funcsendFn(c chan int ){
11c< -4 2 // Send on channel c
12}
13 funcrecvVal(c chan int )int{
14 return <-c// Receive from channel c
15}
Listing1: A simple concurrent program in Go.
2.2 Relationshipbetween Types and Programs
Inouranalysis,aconditionalisabstractedasanon-deterministic
choice between the two alternative behaviours present in the then
andelsebranches.Thiscoarseabstractionintroducesasubtlein-
teractionbetweennon-terminatingprogrambehaviourand data-
dependent communication wrt. liveness [ 30, § 5] (we note that this
issuedoesnotaffectGDForChannelSafety).Forinstance,consider
the following Go program:
1funcsend(n int,cchan int ){
2 ifn%2 == 0 { // Conditional (send if n is even)
3 c< -n // Send to channel c
4}
5send(n, c)
6}
7funcrecv(c chan int ){
8 for{// Infinite loop
9 x: =< - c // Receive from channel c
10}
11}
12 funcmain() {
13c: =make(chan int )
14 gosend(3, c)
15 gorecv(c)
16}
Thetypeforthefunction send(lines1-6)is send(c)=c;send/angbracketleftc/angbracketright⊕
send/angbracketleftc/angbracketright.Similarly,thetypefor recv(line9)is recv(c)=c;recv/angbracketleftc/angbracketright.
The type for the program above is deemed live since the then
branchoftheconditionalin sendcanalwayseventuallybereached
throughrecursion,ensuringthattheinputsin recvarematched.
However, in the program the thenbranch of the conditional can
never be reached and so the inputs in recvcannot succeed.
Thisexampleissymptomaticofamismatchbetweentypeand
program liveness in the presence of infiniteexecutions that flow
throughaconditional.Notethatitisnotthecasethatthesimple
existence of non-termination makes the liveness analysis unsound
[30, § 5]. For instance, for the example in § 1, type liveness implies
programliveness,despitethepresenceofnon-termination,since
there is no communication contingent on a data-dependent test.
In § 5, we address this issue by deploying a lightweight termina-
tion analysis of iterative behaviour in our framework.packagemain
t0 =makechan int 0
gosendFn(t0)
t1 = recvVal(t0)
jump30
t5 =phi[0: 0, 1: t3] #i
t 6=t 5<t 1
ift6goto1else23
t2 = print(t5)
t 3=t 5+1
jump31
t4 = close(t0)
return2for.loopfor.donefuncmain()
entry
returnsend c < −42
return0funcsendFn(c)
entry
return
t0 = <−c
return t00funcrecvVal(c)
entry
return
Block of instructionsn
Function boundary
Package boundary
Figure 3: SSA IR built from Listing 1.
3 BEHAVIOURAL TYPE INFERENCE
We detail one of the main contributions of our work: the devel-
opment and formalisation of a procedure that infers, whenever
possible, behavioural types from Go source code. The inference
consistsoftwokeysteps:(1)theconversionofGosourcecodeto
astaticsingleassignment(SSA)intermediaterepresentation(IR),
using the ssapackage from the Go standard library; and (2) the
extraction of the communication structure as behavioural types
from SSA blocks.
3.1 From Go source code to SSA IR
Thessapackage[ 4]representssourcecodeinSSAformandpro-
vides a high-level API for manipulating Go source code progra-
matically. Go programs are organised as packages which consist
of package variables and functions (also definable within bodies of
functions). Each function is transformed into a list of blocksof SSA
instructions,withone block marked as the function entry point .
Figure 3 gives a graphical view of the SSA representation of the
programinListing1.EachofthethreeGofunctions main(),sendFn
(), andrecvVal() becomes a set of blocks (graphically, a dotted
box represents the scope of the function). The last instruction of a
blockisalwaysacontrolflowinstruction( if,jump,orreturn)
connectingtheblocktoitssuccessors(ifany).Thesuccessorrelation
isshowninthegraphvia edgesconnectingblockswithinafunction.
There are also entryandreturnarrows for function entry and exit
respectively, implicit from the SSA IR. Table 1 summarises the
instructionsof interest to our inference.
Communicationinstructions. Go’s channel-based communi-
cationconstructsareactualprimitivelanguageconstructs.Thus,the
keyoperationssuchaschannelcreation make(chanT),cf.line2
from Listing 1, sending and receiving values over channels, ch
<- value and<-chrespectively (lines 11 and 14), spawning of
goroutines( gosendFn() inline3),andclosingchannels,i.e. close

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. A Static Verification Framework for Message Passing in Go using Behavioural Types ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Table 1: Key SSA instructions used by our type inference.
makechanTS Create channel of type Tand sizeS
localchanT Declare channel of type T
ch <−v Sendvto channel ch
<−ch Receive from channel ch
select b[ <−t0 ,t1<−v]Non-deterministicselect
close(ch) Close channel ch
jump1 Enter block 1
ift0goto1else2Ift0then enterblock 1else block 2
return Exit function
F() Call function F
goF() SpawnFas goroutine
∗ t 0=t 1 Storet1intoaddress t0
phi[Blki:vi]i∈InEdges Selectviif predecessor block is Blki
operation(line8),areall explicitintheSSAIR.Asaresult,identi-
fying the channel operations that match with the corresponding
behavioural types is straightforward.
Select instructions. Non-deterministic selective communica-
tion ( select) also appears explicitly in the SSA representation but
requires a more intricate representation. We illustrate the struc-
tureof the SSA representation of the select block from Listing 2 in
Figure4.Listing2showsasimplefunction myselect(c) whichcon-
sists of a select construct featuring three cases: the first is guarded
byareceiveactiononchannel c,thesecondisguardedbyatimeout,
and the last is the default case (executed if none of the other cases
are ready to be executed). The SSA IR of myselect(c) consists
of6blocks.Block 0istheentrypointofthefunction,containing
theSSAinstructionforselect.Notethattheinstruction select
nonblocking [<−c,<−t0]contains only two cases. The de-
faultcaseisidentifiedbythekeyword nonblocking ;ifaselect
does not specify a default case its SSA representation becomes
select blocking [<−c,<−t0]. We note that timeouts are
implemented in Go as channels (e.g., t0) that receive a message
afterapredeterminedtime.Thismessageisplacedintothechannel
by theruntime andnot by auser-level send.The statement t2 =
extract t1 #0 determines the index of the case which will
be executed and stores it in t2. Block0ends with an if-then-else
construct, which is the first of an if-then-else chain identifying
whichcaseoftheselectistobeexecuteddependingonthevalueof
t2.Blocks2and4representthebodiesofthefirsttwocases,respec-
tively.Block 5containsthebodyofthedefaultcase(thedefaultcase
is always the last block of the chain); if a select statement does not
specifyadefaultcase,thenthisblockcontainsa“panic”instruction
whichcannotbeexecutedinnormalcircumstances.Finally,block
1represents the code that follows the select statement.
Phiinstructions. Another key SSA instruction is phi[Blki:
vi]i∈InEdgeswhichisusedtoselectbetweentwoormorevariables
when merging the control flow into one SSA block. An example
of such an instruction is given in block 3of Figure 3 where the
instruction is used to select the value of variable t5(the index of
theforloop)dependingonwhetherthepredecessorofblock 3is
block0orblock1.Theformercorrespondstotheinitialisationstep1funcmyselect(c chan int ){
2 select {
3 casemsg := <-c:
4 print("received: " , msg)
5 case<-time.After(time.Second):
6 print("timeout: ready in 1s" )
7 default :
8 print("default: always ready" )
9}
10}
Listing 2: A select statement in Go.
t0 = time.After(3:time. Duration)
t1 =select nonblocking [<−c,<−t0]
t2 = extract t1 #0 // case index
t 3=t 2= =0
ift3goto2else30
t 4=t 2= =1
ift4goto4else53//receive
(...)
jump12
//timeout
(...)
jump14
//default
(...)
jump15//cont.
(...)
return1funcmyselect(c)
returnentry
Figure 4: Simplified SSA IR built from Listing 2.
of the loop (in which case the index is 0), the latter corresponds to
an execution of the body of the loop.
Conventions. Given an SSA statement s, e.g.,t0 =make
chan int 0,theleft-hand-side(LHS)isthepartofthestatement
on the left of the =symbol (the variablet0). The key features of
the SSA representation are that, within the scope of a function,
all the LHS of the statements in the blocks of that function are
pairwise distinct. Also, the static typing information is available
foreachstatement.Inaddition,variablesdeclaredatthepackage
level are initialised in a special init()function. Variables that are
accessed by anonymous functions appear in the header of the SSA
representation of that function as free variables.
3.2 Extractingtype definition bodies
InStep(2)we soundlyapproximate,wheneverpossible,thecommu-
nicationbehaviourofGoprogramswiththetypelanguage.First,
foreachSSAblock nineachfunction fun(˜x),wegenerateatype
signature of the form fun n(˜y,˜t,˜v)where:
˜yisasubsequenceof ˜xwhereeach yin˜yisachannelparameter
˜tis a list of channelvariables that appear in the LHS of the
statementsinthepredecessorsofblock nanddonotappear
in the LHS in block n
˜visalistof globalchannel variables(declaredoutsideoffunction
fun, e.g., package level variables).
We store all signatures in an environment Δand write Δ(fun,n)
for the signature of block nin function fun.

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May27-June 3, 2018, Gothenburg, Sweden JulienLange, NicholasNg, Bernardo Toninho, and Nobuko Yoshida
function genFunction (fun,n,k,ρ,Γ)
switchs←statement at line kdo
caset=makechanTSdo
genFunction (fun,n,k+1,ρ;(newSt),Γ[t/mapsto→t])
caset=local chanTdo
genFunction (fun,n,k+1,ρ,Γ[t/mapsto→⊥ ])
caset<−vor<−tort'=<−tdo
genFunction (fun,n,k+1,ρ;mkPrefixΓ(s),Γ)
caseclose(t) do
genFunction (fun,n,k+1,ρ;close Γ(t),Γ)
casereturndo return ρ;0
casejumpido return ρ;mkJumpΓ(fun,i)
caseif_gotoielsejdo
returnρ;(mkJumpΓ(fun,i)⊕mkJumpΓ(fun,j))
caseselectb[д1,...,дj]do
ρc←mkJumpΓ(fun,n+1)
foriin[1,...,j]do
ρi←mkPrefixΓ(дi)
ρ/prime
i←mkJumpΓ(fun,n+2∗i)
ifb=nonblocking then
ρd←mkJumpΓ(fun,n+1+2∗j)
return /binampersand{ρi;ρ/prime
i;ρc}i∈{1,...,j}∪{τ;ρd;ρc}
else return /binampersand{ρi;ρ/prime
i;ρc}i∈{1,...,j}
caseF(˜x)ort=F(˜x)do
iftis a channel then abort
elsegenFunction (fun,n,k+1,ρ;mkCall Γ(F,˜x),Γ)
casegoF(˜x)do
ρ/prime←genFunction (fun,n,k+1,◦,Γ)
returnρ;(mkCall Γ(F,˜x)|ρ/prime)
case∗ t 0=t 1 ort0 = ∗t1 do
ift1is a channel then
genFunction (fun,n,k+1,ρ,Γ[t0/mapsto→Γ(t1)])
elsegenFunction (fun,n,k+1,ρ,Γ)
casephi[Blki:vi]i∈InEdgesdo
if∃i∈InEdges:viis a channel then abort
elsegenFunction (fun,n,k+1,ρ,Γ)
otherwise do genFunction (fun,n,k+1,ρ,Γ)
Algorithm1: Pseudo-code of genFunction
3.2.1 Core procedure: genFunction .We present the core al-
gorithm,the genFunction procedure,whichgeneratesatypeab-
straction from an SSA block. The procedure takes five parameters:
fun, the name of the function being considered; n, the identifier of
theblock; k,thelinenumberwithinblock n;ρ,thetypewehave
constructed thus far; and Γ, a context which maps each channel
variablenameto its representative .
Thecontext ΓiscrucialinourdevelopmentasGoallowschannels
to be aliased (i.e., several variables may contain a reference to
thesamechannel)andchannelvariablestobeoverwritten,e.g.,a
channelvariablemayrefertodifferentchannelsatdifferentpointof
theexecutionofaprogram,ormaybedeclaredandonlyinitialised
at a later point. We keep track of aliased channels by assigning
a unique representative to each newly created channel. We write
Γ[t/mapsto→t/prime]forthecontext Γwherethemappingfrom tisupdated
tot/prime. We assume that Γ[t/mapsto→t/prime]isundefined ift∈dom(Γ)and
Γ(t)/nequal⊥in order to disallowchannel overwriting.Algorithmfor genFunction .Ouralgorithmreliesonauxiliary
(partial)functions for thetranslationsfrom statements to types:
mkPrefixΓ(s)send/receive actions and select guards
mkJumpΓ(fun,j)jumpstatements
mkCall Γ(fun,˜x)functioncalls
Eachfunctionusescontext Γtogeneratecommunicationactions
and type definition calls, respectively.
Algorithm 1 gives the implementation of genFunction which
iterates over the lines of block nin function funand makes a case
analysis depending on the structure of the statement sfound at
linek.Theprocedurereturnsabehaviouraltypeor abortswhen-
ever an invocation to auxiliary functions is undefined or when the
algorithm reaches an “abort” statement, since in these cases we
cannot guarantee a sound approximation of program behaviour. In
particular, the algorithm aborts if a channel variable is overwritten
(a new channel is assigned to it).
Channel creation/declaration. Ifsis a channel creationstate-
ment, variable tbecomes the representative name for this channel
and we update the environment with Γ[t/mapsto→t]. The SSA repre-
sentation guarantees that tis unique in function fun. We create
the corresponding new channel type construct and recursively call
genFunction over the next line. If sis a channel declaration state-
ment,weupdatetheenvironmentwith Γ[t/mapsto→⊥ ].Notethat tcan
only be used after it is initialised.
Send/receive. Ifsis a send or receive statement, we translate it to
a type construct with a call to mkPrefixΓ(s), defined below:
mkPrefixΓ(s)=⎧⎪⎪⎪⎨
⎪⎪⎪⎩uifs=t<−vandΓ(t)=u
uifs∈{<−t,t'=<−t}andΓ(t)=u
τifs=<−tandtis atimeoutchannel
Timeoutchannelsarededicatedchannelscreatedatcompiletime
to encode timeouts, they are never added in the context Γ.
Closeismappedtoitsrespectivetypeprimitive,viacontextlookup.
Return.Wereturnthetypebuiltsofarappendedwiththetermi-
nation construct.
Jump.We translate a jump statement into a type function call
through the auxiliary function defined below, which uses the glob-
ally availablesignature environment ( Δ).
mkJumpΓ(fun,j)=⎧⎪⎪⎪⎨
⎪⎪⎪⎩fun
j/angbracketleft˜y,Γ(˜t),˜v/angbracketrightifΔ(fun,j)=fun j(˜y,˜t,˜v)
and∀t∈˜t:Γ(t)/nequal⊥
⊥ otherwise
mkJumpΓ(fun,j)models a jump to another block within the same
enclosingfunctionhencethereisnoneedtorenametheparameters
northe“global”variablesfromthefunctionsignature(sincethey
arefixedwithinthescopeofthefunction).Instead,theinternally
declared variables are replaced by their representatives using Γ.
The function mkJumpΓ(fun,j)is undefined if any of the ˜targu-
ments maps to an uninitialised channel in order to guarantee that
thesecannotbeoverwritteninthedefinitionof fun.The˜yand˜v
arguments are assumed to be initialised by the parent function.
Conditional constructsarealsotranslatedstraightforwardlyusing
⊕and type definition call.
Select.Ifsis aselectconstructthen sis followed by a chain of
blocks linked by if-then-else statements, which encode the branch-
ing structure of the select, as explained in § 3.1. The jump to the

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. A Static Verification Framework for Message Passing in Go using Behavioural Types ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
function genBody(fun,n)
fun n(˜y,˜t,˜v)←Δ(fun,n)
Γ←[x/mapsto→x]x∈˜y,˜t,˜v
returngenFunction (fun,n,0,◦,Γ)
function genEquations ()
return{Δ(fun,n)=genBody(fun,n)|(fun,n)∈dom(Δ)}
inmain 0/angbracketleft/angbracketright
Algorithm2: Pseudo-code of the overall algorithm.
continuationoftheselectstatementisstoredin ρc,whiletheguard
andbodyofeachcaseisstoredinto ρiandρ/prime
i,respectively.Ifthe
selectstatementcontains adefaultcase( b=nonblocking ),we
additionallytranslatethelastblockofthechainintoatypefunction
call. The guard and body of each case is then appended with the
type function call corresponding to the continuation and all the
componentsare packaged into an external choice construct.Function calls.
Ifsis a function call, we create a corresponding
type definition call using the auxiliary function mkCall Γ(fun,˜x),
whichdefined as follows:
mkCall Γ(fun,˜x)=⎧⎪⎪⎪⎨
⎪⎪⎪⎩fun
0/angbracketleftΓ(˜x),˜v/angbracketrightifΔ(fun,0)=fun 0(˜y,˜v)
and∀x∈˜x:Γ(x)/nequal⊥
⊥ otherwise
Notethattheargumentsarereplacedbytheirrepresentativesac-
cording to Γand the function is undefined if any of them refers to
an uninitialised channel.
Goroutines. Ifsspawns a new goroutine, we proceed similarly to
the function call case but place the call in parallel with its continu-
ation,whichiscomputedthroughacallto genFunction ,starting
withan empty behavioural type (denoted by ◦).
Aliasing. Ifsstores achannelvariable into another, we update the
context with Γ[t0/mapsto→Γ(t1)](which is undefined if Γ(t0)/nequal⊥).
Phi.Ifsisaphistatement,weproceedonlyifitdoesnotoverwrite
channels– we discuss how to lift this restriction in § 5.
We skip all other statements as they do not pertain to communi-
cationor concurrency.
3.2.2 Top-level procedure: genEquations .Finally,wegenerate
the body of type definitions using the genFunction procedure and
thus obtain a set of recursive equations as required. Algorithm 2
gives the overall generation process. We iterate over each type
signature (and therefore each SSA block) to generate a type im-plementationstartingwithacontext
Γwhichisinitialisedtothe
identityfunctionforeachoftheparameters.Thealgorithmreturns
a set of (possibly mutually recursive) type definitions, whose entry
point is the program entry point, e.g., main 0/angbracketleft/angbracketright.
Example 3.1. Consider the Go program from Listing 1 and its
SSA representation in Figure 3. The set of type definitions infered
from this example is given below.
main 0()=(newt0);(sendFn 0/angbracketleftt0/angbracketright|recvVal 0/angbracketleftt0/angbracketright;main 3/angbracketleftt0/angbracketright)
main 1(t0)=main 3/angbracketleftt0/angbracketright
main 2(t0)=closet0;0
main 3(t0)=main 1/angbracketleftt0/angbracketright⊕main 2/angbracketleftt0/angbracketright
sendFn 0(c)=c;0
recvVal 0(c)=c;0Note that the spawning of the goroutine sendFn(ch) becomes a
parallelcompositionof the main thread with sendFn 0/angbracketleftt0/angbracketright.
Example 3.2. Consider the Go program from Listing 2 and its
SSA representation in Figure 4. Its inferred type definitions are
given below.
myselect 0(c)=/binampersand/braceleftbig
c;myselect 2/angbracketleftc/angbracketright;myselect 1/angbracketleftc/angbracketright,
τ;myselect 4/angbracketleftc/angbracketright;myselect 1/angbracketleftc/angbracketright,
τ;myselect 5/angbracketleftc/angbracketright;myselect 1/angbracketleftc/angbracketright/bracerightbig
myselect i(c)=0 fori∈{1,2,4,5}
myselect 3(c)=myselect 4/angbracketleftc/angbracketright⊕myselect 5/angbracketleftc/angbracketright
The type’s entry point is myselect 0(c)andmyselect 3(t0)is un-
used. Note how each branch of the select consists of the sequential
compositionofaguard,atypefunctioncallcorrespondingtothe
body of the branch, and a call to the continuation myselect 1/angbracketleftt0/angbracketright.
4 MODEL CHECKING BEHAVIOURAL TYPES
We present our model checking based analysis of the finite control
fragmentofbehaviouraltypes.Weproceedinthreesteps:(1)we
generate a (finite) labelled transition system (LTS) for the types
fromasetofoperationalsemanticsrules;(2)wedefinepropertiesof
thestatesoftheLTSintermsoftheimmediateactionsbehavioural
types can take; and (3) we give safety and liveness properties ex-
pressed in the modal μ-calculus[28].
The notionof finitecontrol hasseveral definitionsin thelitera-
ture[8,11]butisgenerallyunderstoodtorefertohaving finitely
manyreachablestates(possiblyup-tosomeequivalencerelation).
Here we adopt the definition of finite control used by the mCRL2
toolchain[ 10]:typescannotfeatureparallelcompositionorchannel
creation operators under recursion, which is a sufficient condition
to guarantee a finite state space. For instance, types of the form
t(˜x)=t/angbracketleft˜x/angbracketright|Tort(x)=(newa);t/angbracketlefta/angbracketrightarenotfinite control as the
formergeneratesinfinitelymanyinstancesoftype t(˜x)whilethe
latter generatesinfinitely manychannels.
Semantics of types. Before proceeding to Step (1), i.e., the
generationofalabelledtransitionsystem(LTS)frombehavioural
types, we introduce the semantics of types. The semantics follows
standard definitions from CCS and CSP, accounting for the con-
structs that are specific to the Go programming language. The
labels,ranged over by αandβ, have the form:
α,β/colonequala|a|τ|τa|cloa|cloa|a⋆|•a|a•
and theirmeaning is given in Table 2.
We assume types are in normal form , with all channel creations
at the outermost top level. In a finite control setting we can always
soundly rewrite types to satisfy this normal form using the equiva-
lences defined in Figure 6. Thus, a program’s type is always of the
form:
{ti(˜yi)=Ti}i∈Iin(newn0a0)...(newnkak);t0/angbracketleft/angbracketright
wheretheseveral Ticontainnochannelcreations.Wealsomake
use of the following transition which initialises all the channels
accordingly and write Afor theset of all initialised channels:
{ti(˜yi)=Ti}i∈Iin(newn0a0)...(newnkak);t0/angbracketleft/angbracketright
τ−→{ ti(˜yi)=Ti}i∈Iin(t0/angbracketleft/angbracketright | ⌊a0⌋n0
0|...|⌊ak⌋nk
0)

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June3, 2018, Gothenburg, Sweden JulienLange, NicholasNg, Bernardo Toninho, and Nobuko Yoshida
a;Ta−→Ta;Ta−→Tτ;Tτ−→T
closea;Tcloa−−−−→T⌊a⌋n
kcloa−−−−→a⋆a⋆a⋆
−−→a⋆
i∈{1,2}
T1⊕T2τ−→Tiαj;Tjαj−−→Tjj∈I
/binampersand{αi;Ti}i∈Iαj−−→Tj
Tα−→T/prime
T|Sα−→T/prime|STα−→T/prime
T;Sα−→T/prime;S0;Sτ−→S
α∈{a,a⋆,a•}Tα−→T/primeSβ−→S/primeβ∈{•a,a}
T|Sτa−−→T/prime|S/prime
T≡αT/primeTα−→T/prime/prime
T/primeα−→T/prime/primeT{˜a/˜x}α−→T/primet(˜x)=T
t/angbracketleft˜a/angbracketrightα−→T/prime
Tcloa−−−−→T/primeScloa−−−−→S/prime
T|Sτ−→T/prime|S/primek<n
⌊a⌋n
k•a−−→⌊a⌋n
k+1k≥1
⌊a⌋n
ka•
−−→⌊a⌋n
k−1
Figure 5: Semantics of types.
0;T≡TT|S≡S|TT|(T/prime|S)≡(T|T/prime)|S
T|0≡TT≡αT/prime⇒T≡T/prime
(newna);(newmb);T≡(newmb);(newna);T
(newna);0≡0(newna);a⋆≡0(newna);⌊a⌋n
k≡0
T|(newna)S≡(newna)(T|S)(a/nelementfn(T))
Figure 6: Structural congruence for types.
We give the semantic rules for behavioural types in Figure 5,
adapted from [ 30], whereTα−→T/primedenotes that Treduces to T/prime
by producing α, according to the rules in Figure 5. In the first
line,therulesrespectivelymodelsend,receiveandsilentactions.
Inthesecondline,therulesrespectivelymodelcloseactions,the
closure of channel aand a closed buffer sending default values.
In the third line, the rules respectively model a silent transition
representing an internalchoice and an externalchoice. The fourth
line gives the standard rules for parallel and general sequencing.
The rule in the fifth line models the synchronisation between a
type or buffer firing a send-like action (i.e., a send action, a closed
buffer,oranon-emptyasynchronousbuffer)andareceiveactionor
a non-full buffer. The sixth line gives standard rules to deal with α-
equivalenceandunfoldingofdefinitioncalls.Intheseventhline,the
rules respectively model the synchronisation of a type and a buffer
atoeffectivelyclose a,andtheactionofadding(resp.removing)an
elementin(resp.from)abuffer,where nisthecapacityofthequeue
andkis the number of messages currently stored in the queue. We
have omitted symmetric rules for parallel and synchronisations.
In Step (1), given a finite control type in normal form, we con-
struct afinitelabelled transition system which represents allpossi-
ble executions of t0/angbracketleft/angbracketright, i.e., the entry point type under all the name
restrictions.TheLTSof t0/angbracketleft/angbracketrightisatuple T=(S,t0/angbracketleft/angbracketright,−→,A)suchthat
Sis a set of states implicitly labelled by behavioural type terms
(we often identify labels and states), t0/angbracketleft/angbracketright ∈ Sis the initial state,Table 2: (Predicate) labels
a/a send / receive on channel a
τa synchronisationover a
τ silent action
cloa/cloarequest to close a/ closinga
a⋆channelais closed
•a/a•push/ pop on buffer a
˜o waiting to synchronise over the actions in ˜o
a;T↓aclosea;T↓cloa
a;T↓aa⋆↓a⋆∀i∈{1,...,n}:αi↓oi
/binampersand{αi;T}i∈{1,...,n}↓{o1...on}
T↓o
T;T/prime↓oT↓aT/prime↓aorT/prime↓a⋆
T|T/prime↓τaT{˜a/˜x}↓ot(˜x)=T
t/angbracketleft˜a/angbracketright↓o
T↓aαi↓a
T|/binampersand{αi;Si}i∈I↓τaT↓aorT↓a⋆αi↓a
T|/binampersand{αi;Si}i∈I↓τa
k<n
⌊a⌋n
k↓•ak≥1
⌊a⌋n
k↓a•T↓aT/prime↓•a
T|T/prime↓τaT↓a•αi↓a
T|/binampersand{αi;Si}i∈I↓τa
T↓o
T|T/prime↓oT↓oa/nelementfn(o)
(newna);T↓oT↓oT≡T/prime
T↓o
Figure 7: Barb predicates for types.
A⊆{τ}∪{τa|a∈A }is the set of labels, and −→⊆ S× A×Sis
the transition relation Tα−→T/primewhere the label αcan be either a
silent move, i.e., τ, or a synchronisation over a channel, e.g., τa.
Propertiesofbehaviouraltypestates. InStep(2),wedefine
predicates over the state labels of the LTS defined above. Thisallows us to analyse what actions a given state (or type) can fireimmediately. Concretely, we define a family of predicates of the
formT↓oorT↓˜owhichholdsif Tisreadytofireaction oorone
of the actions in ˜o, witho,oi∈{a,a,τa,cloa,a⋆,•a,a•}. Table 2
explains the meaning of each label and Figure 7 gives the defining
rules of the predicates T↓oandT↓˜o. Essentially, T↓oifTis
immediatelyreadytofireaction o(witho/nequalτ)andT↓˜oifTcontains
anexternalchoicewhichdoesnotfeatureabranchguardedby τ(i.e.,
τ/nelement˜o). We have, e.g., ¬(τ;T↓o)for anyoand¬(/binampersand{τ;T1,a;T2}↓˜o)
for any˜o, which is an important subtlety for defining accurate
safety and liveness properties.
Liveness and safety properties. In Step (3), we encode live-
ness and channel properties (including those discussed in § 2.1) in
theμ-calculus [ 28] extended with the atomic propositions on state
labels defined in Step (2).
Aμ-calculusformula ϕisinterpretedonapointedLTS,i.e.,an
LTS with a starting state T, we write T|=TϕifTsatisfiesϕin
the LTST. Namely, formula /latticetopholds for every T(while⊥never
holds).Theconstruct [α]ϕisamodaloperatorthatissatisfiedif,for
eachα-derivative T/primeofT(i.e.T/primeisreachablefrom Tbyperforming
actionα), the formula ϕholds inT/prime. The dual modality is /angbracketleftα/angbracketrightϕ
which holds if there is an α-derivative T/primeofTsuch that ϕholds
inT/prime. Construct νx.ϕ(resp.μx.ϕ) is the standard greatest(resp.

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. A Static Verification Framework for Message Passing in Go using Behavioural Types ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Ψ(ϕ)def=νx.(ϕ∧[A]x) [Always]
Φ(ϕ)def=μy.(ϕ∨/angbracketleftA/angbracketrighty) [Eventually]
ψtdef=/angbracketleftA/angbracketright/latticetop [Noterminal]
ψcdef=μy.[A]y [No cycle]
ψдdef=(/logicalandtext.1
a∈A↓a∨↓a)=⇒/angbracketleftA/angbracketright/latticetop [No global deadlock]
ψladef=(/logicalandtext.1
a∈A↓a∨↓a)=⇒Φ(/angbracketleftτa/angbracketright/latticetop) [Liveness (a)]
ψlbdef=(/logicalandtext.1
˜a∈P(A)↓˜a)=⇒Φ(/angbracketleft{τa|a∈˜a}/angbracketright/latticetop)[Liveness (b)]
ψsdef=(/logicalandtext.1
a∈A↓a⋆)=⇒¬ ( ↓a∨↓cloa)[Channel safety]
ψedef=(/logicalandtext.1
a∈A↓a•)=⇒Φ(/angbracketleftτa/angbracketright/latticetop)[Eventual reception]
Figure 8: μ-calculusformulae.
smallest)fixpointoperator(binding xinϕ).Theatomicproposition
↓o(resp.↓˜o)holdsiff T↓o(resp.T↓˜o).Givenasetofactions A⊆A,
we write [A]ϕfor/logicalandtext.1
α∈A[α]ϕand/angbracketleftA/angbracketrightϕfor/logicalortext.1
α∈A/angbracketleftα/angbracketrightϕ.
We now describe several properties which can be verified using
the model checker mCRL2[10]. Below we refer to the formulae
giveninFigure8.Givena μ-calculusformula ϕ,formula Ψ(ϕ)holds
ifϕholds for all reachable states, while formula Φ(ϕ)holds ifϕ
holdsinsomereachablestate.Formula Ψ(ψt)holdsif no terminal
stateis reachable in T, i.e., the behavioural types only exhibit
infiniteexecutions;duallyformula ψcholdsifthereare no cycles
inT, this property is useful as it implies that liveness of types
correspondswithlivenessofprograms(cf.§2.2).Formula Ψ/parenleftbigψд/parenrightbig
modelsthe global deadlock-freedom propertydiscussedin§2.1,
i.e., the formula holds if for each state TinTifTis ready to
executeasendorreceiveaction,then Thasasuccessor.Formula
Ψ/parenleftBig
ψla∧ψlb/parenrightBig
models the livenessproperty (cf. § 2.1). It holds if
for all state TinT(i)i fTis ready to send/receive on a, there is
alwayseventuallyasynchronisationon a(cf.ψla),and(ii)ifThasa
selectconstruct,whichdoesnotcontaina τ-branch,thereisalways
eventually a synchronisation over one of the channels guarding
the construct (cf. ψlb). Formula Ψ(ψs)models the channel safety
property, i.e., no send nor close action is executed on a channel
that is already closed. Formula Ψ(ψe)models eventual reception ,
whichguarantees that when a channel is not empty, the head of its
buffercan eventually be consumed.
5 IMPLEMENTATION
Wepresentthe GodelChecker toolchainofFigure2whichconsists
of two core components: an inference tool and a type verifier.
Inference tool. The type inference tool implements the core
algorithmsdescribedin§3,withadditionaladjustmentstosupport
analysisof real world Go programs, which we discuss below.Uninitialised channels:
Uninitialised channels (or nil channels)
can be used in Go, but they always block on communication. To
modelthisbehaviour,weprefixanycommunicationonanunini-
tialised channel with a (newa)construct(with afresh).
Composite data structures: Our tool supports channels that are
storedin structsbyflattening suchconstructsintoseveralchan-
nels. We only support structures that store finitely many channels
(e.g., arrays or linked-list of channels are not supported).Uniform representation of functions: Auniformrepresentation
ofcallableobjectsisusedasanabstractionwhenobtainingthetype
signature of an SSA block. This allows us to support return values
and closures by uniformly converting return values and closure
bindingas additional function parameters.
Channels in phi instructions: We support SSA instructions to
merge control flow ( phi) when they refer to channels by adding a
parameter to the type definition of its enclosing block and modify-
ing functioncalls accordingly.
Type verifier. The type verifier transforms the inferred be-
haviouraltypesintoanLTSandpropertiesinto μ-calculusformulae
followingthemethodologyin§4forthe mCRL2modelchecker,and
also into input for the KiTTeLterminationanalyser.
Model checking: Once a behavioural type has been inferred from
Go source code, we translate it straightforwardly to the mCRL2
language[ 19].Beforegeneratingthe μ-calculusformulaedescribed
in § 4, we analyse the model so to build the smallest formulae
possible.Finally,werunthe mCRL2modelcheckerforeachformula
and return the result to the user.
Termination checking: To address the mismatch between types
and programs detailed in § 2.2 we deploy a termination analysis of
loops,usingthe KITTeLterminationanalyser[ 16].Thetooltargets
Cprogramsandisbasedonintegertermrewriting.Thechoiceof
this particular analyser amounts to the syntax of Go being close to
C, its usability and performance.
Theanalysistakesadvantageoftheinferenceprocedureof§3
to collect the locations and parameters of loops in a given pro-
gram,whicharethencheckedfortermination.Ouranalysischecks
that the loop parameters are enough to make each loop eventually
terminate, regardless of the non-loop code within the loop itself.
This enables us to pinpoint program locations where liveness of
types may not entail the analogue property in the program – if
the termination analysis identifies the program as terminating, the
liveness properties on types and programs coincide [30, § 5].
The analysis generates all loops in the original Go program as a
setofCfunctions, ignoringallotherGostatements.EachCfunction
(and thus,each loop)is then individually checked fortermination.
Sinceloopscanbenested,ouranalysistakesthisintoaccountby
replicatingthenestinginthegeneratedCfunctions.Forinstance,
for the followingcode snippet,
1funcf(nint){
2 fori: =0 ;i<n ;i + +{
3 forj := 0; j < 10; j++ { ... }
4}
5}
ourtoolgeneratesasingleCfunction fcontainingthetwoloops.
Staticallyunknown valuesin loopparameters (e.g. theparameter n
offunction fabove)aregeneratedasparametersoftherespectiveC
functions.Thisforcestheterminationcheckertoverifytermination
for allpossible values of the unknown parameter. Such values can
appearduetousagesoffunctionarguments,valuescontainedin
dynamic data structures or communicated data.
Our analysis relies on the following: loops in Go programs gen-
eratetypeswithconditionalbranchingcombinedwithrecursion;
most programs use traditional imperative control flow features su-
ch as for loops, for-range loops (i.e. loops over a fixed finite data
structure)andfor-selectloops(i.e.aninfiniteloopwitha select

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June3, 2018, Gothenburg, Sweden JulienLange, NicholasNg, Bernardo Toninho, and Nobuko Yoshida
Table 3: Go programs verified by our framework and comparison with existing static deadlock detection tools.
Godel Checker dingo-hunter [36] gopherlyzer [40] GoInfer/Gong [30]
Programs LoC# statesψдψlψsψeInfer Live Live+CS Term Live TimeDF TimeLive CS Time
1mismatch [36] 29 53×× /check/check 620.7 996.8 996.7 /check× 639.4× 3956.4 ×/check616.8
2fixed[36] 27 16 /check/check/check/check 624.4 996.5 996.3 /check /check 603.1 /check 3166.3 /check/check 601.0
3fanin[36, 39] 41 39 /check/check/check/check 631.1 996.2 996.2 /check /check 608.9 /check 19.8 /check/check 696.7
4sieve[30, 36] 43∞ n/a -- - n/an/a -n/a -/check/check 778.3
5philo[40] 41 65×× /check/check 6.1 996.5 996.6 /check× 34.2× 27.0×/check 16.8
6dinephil3 [13, 33] 553838 /check/check/check/check 645.2 996.4 996.3 /checkn/a -n/a -/check/check 13.2 min
7starvephil3 473151 ×× /check/check 628.2 996.5 996.5 /checkn/a -n/a -×/check3.5 min
8sel[40] 22103×× /check/check 4.2 996.7 996.6 /check× 15.3× 13.0×/check 50.5
9selFixed [40] 22 20 /check/check/check/check 4.0 996.3 996.4 /check /check 14.9 /check 3168.3 /check/check 13.1
10jobsched [30] 43 43 /check/check/check/check 632.7 996.7 1996.1 /checkn/a -/check 4753.6 /check/check 635.2
11forselect [30] 42 26 /check/check/check/check 623.3 996.4 996.3 /check /check 611.8n/a -/check/check 618.6
12cond-recur [30] 37 12 /check/check/check/check 4.0 996.2 996.2 /check /check 9.4n/a -/check/check 14.7
13concsys [42] 118 15×× /check/check 549.7 996.5 996.4 /checkn/a -× 5278.6 ×/check521.3
14alt-bit [30,35] 70112 /check/check/check/check 634.4 996.3 996.3 /checkn/a -n/a -/check/check 916.8
15prod-cons 28106 /check×/check/check 4.1 996.4 1996.2 /check× 10.1× 30.1×/check 21.8
16nonlive 16 8 /check/check/check/check 630.1 996.6 996.5 timeout ⊗ 613.6n/a -⊗/check613.8
17double-close 15 17 /check/check ×/check3.5 996.6 1996.6 /check /squaremultiply 8.7/squaremultiply 11.8 /check× 9.1
18stuckmsg 8 4 /check/check/check ×3.5 996.6 996.6 /checkn/a -n/a -/check/check 7.6
19dinephil5 61∼1M /check/check/check/check 626.5 41.2 sec 41.4 sec /checkn/a -n/a -timeout >48 hrs
20prod3-cons3 4057493 /check/check/check/check 465.1 40.9 sec 40.9 sec /checkn/a -n/a -timeout >48 hrs
21async-prod-cons 33164897 /check/check/check/check 4.3 47.7 sec 89.4 sec /checkn/a -n/a -timeout >48 hrs
22astranet [26] ∼18k1160 /check/check/check/check 2512.5 70.4 sec 75.0 sec /checkn/a -n/a -n/a -
Column 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
CS: Channel Safe, Term: Termination check, DF: Deadlock-free, timeout: Termination check timeout (likely does not terminate), /squaremultiply: False Alarm, ⊗: Undetected liveness error.
thatcanbreaktheloop–the Consumer functionofFigure1)instead
of recursion; we assume that loop indices are not modified in loop
bodies and that no goto-likeconstructsare used in a loop.
Since the analysis only takes into account loop parameters, a
loopthatindefinitelyblocks(e.g.duetocommunication)maybe
identified as terminating. However, if our analysis identifies the in-
ferredtypesaslive andtheterminationcheckvalidatestheprogram,
both termination and program liveness are guaranteed.
6 EVALUATION
Table 3 lists several benchmarks of our tool against other static
deadlock detection tools for Go (a detailed comparison of these
tools is given in § 7). The benchmarks were run with go1.8.3 on
an 8-core Intel i7-3770 machine with 16GB RAM on a 64-bit Linux.
The model checker we used was mCRL2 v201707.1.
The results for Godel Checker are shown in columns 4–12. Col-
umn4showsthenumberofstatesintheinputLTSasameasure-
mentoftherelativecomplexityofeachprogram(proportionaltothe
number of concurrency-related operations rather than the number
of lines of code). Columns 5–8 shows the core formulae of Figure 8
in § 4, i.e. no global deadlock ( ψд), liveness( ψl), channel safety( ψs)
and eventual reception ( ψe). A/checkmark means thatthe considered
tool reports that the property holds. For example, in the case of
GodelChecker ,a/checkmarkundercolumn ψдmeansthattheformula
Ψ/parenleftbigψд/parenrightbigevaluates to true. In the case of GoInfer/Gong a/checkmark
undercolumn Livemeansthatthetoolreportstheprogramtobe
live, as defined in [ 30]. A×mark indicates that the considered tool
reports that the property in question does not hold. Columns 9–12
list the running time of GodelChecker , where Column 10 lists the
inferencetime,Columns10and11arethemodelcheckingtimes
forliveness,andbothlivenessandchannelsafety,respectively.The
totalruntimecanbeobtainedbyaddingColumn9toColumn10or
11.Unlessotherwisestated,alltimesareinmilliseconds.Column12 (Term) shows the result of the termination check, which proves
theterminationofloopsinthegivenprogram,ortimesoutafter
15s. A program that times out is conservatively assumed not to
terminate.
Columns 13–14 pertain to the dingo-hunter tool from [ 36].
The time includes both communicating finite state machine extrac-
tion and their analysis, but does not include building the global
graphand only checks for liveness. Columns 15–16 pertain to the
gopherlyzer tool [40], which only checks for global deadlock-
freedom(mostprogramshadtobemanuallyadjustedinordertobeacceptedbythistool–see§7fortheseverepracticallimitationsof
thetool).Columns17–19refertothe
GoInfer/Gong toolfrom[ 30].
Thetimesincludebothtypeinferenceandanalysisstages,which
only accounts for liveness and channel safety checks. Most pro-gramsinTable3aretakeneitherfromotherpapersonthestatic
verificationofGoprograms[ 30,36,40]orfrompubliclyavailable
source code. Programs 7, and 15–22 are benchmarks introduced
by this work. Programs that are unsupported by a tool are marked
withn/a. Table 3 includes all the benchmarks from previous works,
exceptfor3non-finitecontrolexamplesfrom[ 30]whichourtool
cannotanalyse(i.e.,like sieve)andhtcatfrom[36]whichisman-
ually transformed to be supported by dingo-hunter .
Programs1–7aretypicalconcurrentprogramsfromthelitera-
ture. The sieveprogram is not finite control (it spawns an infinite
numberofthreads),thusitcanonlybeanalysedby GoInfer/Gong .
Program 6 is a (three) dining philosophers program where the first
forkcanbereleased,whileProgram7isthetraditionaldeadlock-
ingversion(Program19isasProgram6butwith5philosophers).
dingo-hunter does not support Programs 6, 7, and 19 due to dy-
namicallyspawnedgoroutines,while gopherlyzer doesnotsup-
portthemduetoanestedselectstatement. GoInfer/Gong analyses
themcorrectly, but is much slower than GodelChecker .

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. A Static Verification Framework for Message Passing in Go using Behavioural Types ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Programs 8–12 consist of idiomatic Go patterns which are all
handled correctly and quickly by our tool. Program 13 is a publicly
available program which is not live. Program 14 is an implemen-
tationofthealternatingbitprotocol.Program15istheProducer-
Consumerexamplefrom§1,whichisnotlive.Alltoolswereableto
verifythissimpleprogram.Program16demonstratesthemismatch
between type and program liveness, where the type is live but due
to an erroneous loop the program does not terminate and causes a
partial deadlock.The termination check identifiesthis as possibly
non-terminating, while GoInfer/Gong incorrectly identifies it as
live.Program17closesachanneltwicewhichflagsaviolationof
channelsafetyin GodelChecker andGoInfer/Gong .Interestingly,
dingo-hunter detects a deadlock (a false alarm) due to its repre-
sentation of channel closure as a message exchange, but not due to
thedoubleclose. gopherlyzer alsodetectsadeadlockincorrectly
due to the samereason. Program 18 is a program that violatesthe
eventual reception property bysendingan asynchronousmessage
thatis never received – none of the earlier tools can detect this.
Programs 19–22 demonstrate the scalability of our approach.
Program22isaconcurrentdatastreammultiplexer,forhandling
multipleindependentdatastreamsinasingleTCPconnection.It
consists of 16k lines of code of which only a small portion relate
to concurrency (which is the case with common concurrent Go
applications). The program is not natively finite control since it
spawnsrequesthandlersasgoroutinesinaloop.Notingthatrequest
handlers do not interact with each other, we modified the program
to handle requests sequentially and enable our analysis.
We note that while the execution time for small programs is
slightly higher than the other tools (but still under 2 seconds),
Godel Checker is amore general toolsince it canverify arbitrary
propertiesexpressibleinthe μ-calculusandourpreciseinference
allows us to reduce both the false alarms and, crucially, undetected
liveness errors . The verification times also suffer from the initiali-
sation of mCRL2(the tool uses 3 binaries). In small programs the
running times are generally dominated by this fact, which is the
reason why the times are quite similar. This is amortised in pro-
gramswithlargestatespaces(cf.secondpartofTable3),wherethe
efficiency of mCRL2produces gains of several orders of magnitude
overgopherlyzer andGoInfer/Gong whileperformingmorede-
tailed analyses. We note that a significant portion of the inference
time is due to the translation into SSA by the ssapackage.
Limitations. Asexplainedin§3,ourinferencedoesnotsupport
channelvariableoverwriting,i.e.,weonlysupport immutable chan-
nel variables. In addition, it does not support channels in dynamic
datastructures–suchasarrays,slices(variablesizedarrays)and
dictionaries – or recursively defined data structures (e.g. linked
lists).However,ourtoolensuresthatsuchdatastructuresdonot
containchannelsandcanbesafelyignored,signallinganerroroth-
erwise. We also require channel buffer sizes to be statically known.
While the inference is agnostic to the finite control limitation of
themodelcheckingtool,ifatypeisinferredsuccessfully,itmust
be finite control in order for our type verifier to produce an output.
We note that these limitations are also present in the other tools
mentioned in this section ( GoInfer/Gong supports infinite state
systemsby performing a bounded verification).7 RELATED WORK AND CONCLUSION
Applyingprogramanalysestoreal-worldsoftware. Theerror-
prone nature of concurrent software has led to a plethora of works
on automated verification of concurrency via program analysis.
However, these works mostly target lock-based concurrency (such
as those based on Java Pathfinder [ 3,21,38,44] or abstract inter-
pretation [ 29]) and so are of a fundamentally different nature than
ourwork targetting message-based concurrency in Go.
Verification of Go programs. Despite the young age of Go, it
has received some attention from the research community. The
workof[36]istothebestofourknowledgethefirsttotacklestatic
verification of Go programs. Their work uses multiparty session
types[23]andtheirconnectiontocommunicatingautomata[ 12,32]
tocheckforlivenessinGobyextractingcommunicatingfinitestate
machinesfromsourcecode.However,theirworkcannotsupport
dynamic spawning of goroutines (requiring all goroutines to be
executing before any communication takes place) nor asynchrony.
This severely limitsthe applicability of their work.Their analysis
alsodoesnotcovermanyfeaturesofGowhichresultsincrashesin
theanalysis,such as phiinstructionsand uninitialised channels.
Using a form of regular expressions with a fork construct, the
workof[40]capturesthreadspawningin synchronous Goprograms.
Theiranalysisisextremelylimited:itdoesnotsupportasynchrony,
closingchannelsnorselectivecommunicationwithnon-trivialcase
bodies.Moreover,theirworkusesthe gurutooltomanuallyobtain
aliasinginformationinordertoidentifychannels,andassumesthat
allfunctionscanbeinlined.Asaresult,theirtoolfailstoanalyse
programs that cannot be trivially inlined — e.g. programs with
aliasedchannelorrepeatedusagesofthesamefunction—ruling
outmost usefulprograms.
Ourpreviouswork[ 30]infersbehaviouraltypesfromGocode
whicharechecked forliveness andsafety properties using a tech-
niqueakintoboundedsymbolicexecution.The GoInfer/Gong tool
explicitlyexecutesthetypeLTSwhichhasscalabilityissueswith
large state spaces (see § 6) and is specialised for liveness and chan-
nelsafety,whereasourtoolcancheckforamuchwiderrangeof
propertiesofinterest(ingeneralwecanverifyanypropertythat
can be represented as a μ-calculus formula). The type inference
of[30](whichwasnotformaliseduntilthiswork)didnothavefull
support for closures nor general sequencing, needed to accurately
represent most imperative programming patterns.Behaviouraltypes.
There is a vast body of work on behavioural
typesforconcurrency(see[ 1,24]forgeneralsurveys).Themain
contrast between our work and most of those in [ 1,24] is that
we usebehaviouraltypes asa componentin alarger analysisthat
can automatically check for a range of safety and liveness prop-
erties, instead of focusing solely on forms of deadlock-freedom.
The work [ 7] proposes a framework combining a behavioural type
analysis with model checking. Their work uses the π-calculus as a
source language and extracts CCS-like behavioural types based on
[25],whichcanthenbecheckedforpropertieswrittenasanLTL
formula.Themainlimitationoftheirworkistherequirementof
explicittypeannotationsinprocesses.Moreover,itisnotclearhow
to represent our notions of global and partial deadlock-freedom
(as well as channel safety) as a general LTL formula. LTL formulas
can use “always” and “eventually” modalities to describe reachable

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May27-June 3, 2018, Gothenburg, Sweden JulienLange,NicholasNg, Bernardo Toninho, and Nobuko Yoshida
states,but cannotmentionspecific communicationactions which
requires non-obvious encodings. Note that most previous works
[7,24]aredevelopedinthecontextofprocesscalculiandarenot
applicableto a general purpose language.
Concludingremarks. We have presented a static verification
frameworkforchannel-basedconcurrencyinGowhichwehaveimplementedinthe
Godel Checker tool.Asshownin§6,ourin-
ference procedure allows us to accurately cover a broader classof Go programs without the need for annotations or significant
user input. By integrating our approach with a general purpose
modelchecker,weareabletomodularlyverifyarbitrarysafetyandlivenessproperties.Comparedtootherexistingtools,ourapproach
providessignificantlybetterperformanceforlargerprograms,veri-
fyingmorepropertiesandwithbetteroutcomesintermsofboth
false alarms and,crucially, undetected liveness errors.
Given the general nature of our inference procedure, our frame-
work is not necessarily limited to mCRL2, nor model checking tech-
niques in general. For future work we plan to use other process
calculi verification techniques such as [ 37], as well as other model
checkersforconcurrencysuchas[ 18].Also,thegeneralideaforour
inference canin principlebe applied toother concurrency-centric
languagesthatrelyonsomeformofSSA-likeintermediaterepresen-
tation. We plan to apply our techniques to the Erlang language via
theCoreErlang[ 6]intermediaterepresentation.Wealsoplantoad-
dresstheOpenCL2.0heterogeneousprogrammingframework[ 20]
which provides pipeobjects (akin to Go channels) that are used for
inter-kernelcommunicationsand are prone to deadlocks.
ACKNOWLEDGMENTS
TheworkispartiallysupportedbytheEPSRC(grantsEP/K034413/1,
EP/K011715/1,EP/L00058X/1,EP/N027833/1,andEP/N028201/1)
REFERENCES
[1]DavideAncona,VivianaBono,MarioBravetti,JoanaCampos,GiuseppeCastagna,
Pierre-Malo Deniélou, Simon J. Gay, Nils Gesbert, Elena Giachino, Raymond Hu,
Einar Broch Johnsen, Francisco Martins, Viviana Mascardi, Fabrizio Montesi,
Rumyana Neykova, Nicholas Ng, Luca Padovani, Vasco T. Vasconcelos, and
NobukoYoshida.2017. BehavioralTypesinProgrammingLanguages .Foundations
and Trends in Programming Languages, Vol. 3(2-3). Now Publishers Inc. 95–230
pages.
[2]Andrew W. Appel. 1998. SSA is Functional Programming. SIGPLAN Notices 33, 4
(1998), 17–20. https://doi.org/10.1145/278283.278285
[3]CyrilleArtho,MasamiHagiya,RichardPotter,YoshinoriTanabe,FranzWeitl,and
MitsuharuYamamoto.2013. Softwaremodelcheckingfordistributedsystems
with selector-based, non-blocking communication. In ASE. 169–179.
[4]The Go Authors. 2013. package ssa. http://golang.org/x/tools/go/ssa. (2013).
http://golang.org/x/tools/go/ssa.
[5]BradFitzpatrick.2015. go 1.5.1linux/amd64 deadlock detectionfailed. (9 2015).
https://github.com/golang/go/issues/12734.
[6]Richard Carlsson, Björn Gustavsson, Erik Johansson, Thomas Lindgren, Sven-Olof Nyström, Mikael Pettersson, and Robert Virding. 2000. Core Erlang 1.0
languagespecification. Information TechnologyDepartment, Uppsala University,
Tech. Rep (2000).
[7]SagarChaki,SriramK.Rajamani,andJakobRehof.2002. Typesasmodels:model
checkingmessage-passing programs. In POPL. 45–57.
[8]Witold Charatonik, Andrew D. Gordon, and Jean-Marc Talbot. 2002. Finite-
Control Mobile Ambients. In ESOP. 295–313. https://doi.org/10.1007/
3-540-45927-8_21
[9] CoreOS 2017. CoreOS. https://coreos.com/. (June 2017). https://coreos.com/.
[10]Sjoerd Cranen, Jan Friso Groote, Jeroen J. A. Keiren, Frank P. M. Stappers, Erik P.
de Vink, Wieger Wesselink, and Tim A. C. Willemse. 2013. An Overview of
themCRL2ToolsetandItsRecentAdvances . SpringerBerlinHeidelberg,Berlin,
Heidelberg, 199–213. https://doi.org/10.1007/978-3-642-36742-7_15
[11]MadsDam.1996.ModelCheckingMobileProcesses. InformationandComputation
129, 1 (1996), 35–51. https://doi.org/10.1006/inco.1996.0072[12]Pierre-MaloDeniélouandNobukoYoshida.2012. MultipartySessionTypesMeet
Communicating Automata. In ESOP (LNCS) , Vol. 7211. Springer, 194–213.
[13]E.W.Dijkstra.1965. Cooperatingsequentialprocess. ProgrammingLanguages
(1965), 43–112.
[14] Docker 2017. Docker. https://www.docker.com/. (June 2017).
[15]2014. Open Sourcing our Go Libraries. https://blogs.dropbox.com/tech/2014/07/
open-sourcing-our-go-libraries/. (July 2014).
[16]StephanFalke,DeepakKapur,andCarstenSinz.2011. TerminationAnalysisof
C Programs Using Compiler Intermediate Languages. In RTA. 41–50.
[17]Stephan Falke, Deepak Kapur, and Carsten Sinz. 2012. Termination Analysis
ofImperativeProgramsUsingBitvectorArithmetic . SpringerBerlinHeidelberg,
Berlin, Heidelberg, 261–277.
[18]Thomas Gibson-Robinson, Philip Armstrong, Alexandre Boulgakov, and A.W.
Roscoe. 2014. FDR3 — A Modern Refinement Checker for CSP. In Tools and
AlgorithmsfortheConstructionandAnalysisofSystems(LectureNotesinComputer
Science), Vol. 8413. 187–201.
[19]Jan Friso Groote and Mohammad Reza Mousavi. 2014. Modeling and Anal-
ysis of Communicating Systems . MIT Press. https://mitpress.mit.edu/books/
modeling-and-analysis-communicating-systems
[20] Khronos OpenCL Working Group. 2015. The OpenCL Specification Version 2.0.
https://www.khronos.org/registry/OpenCL/specs/opencl-2.0.pdf. (2015).
[21]KlausHavelundandThomasPressburger.2000. ModelCheckingJAVAPrograms
using JAVA PathFinder. STTT2, 4 (2000), 366–381.
[22] Tony Hoare. 1985. Communicating Sequential Processes . Prentice Hall.
[23]Kohei Honda, Nobuko Yoshida, and Marco Carbone. 2008. Multiparty Asyn-
chronous Session Types. In POPL’08. ACM, 273–284. A full version in JACM:
63(1-9):1–67, 2016.
[24]Hans Hüttel, Ivan Lanese, Vasco T. Vasconcelos, Luís Caires, Marco Carbone,
Pierre-MaloDeniélou,DimitrisMostrous,LucaPadovani,AntónioRavara,Emilio
Tuosto,HugoTorresVieira,andGianluigiZavattaro.2016.FoundationsofSession
TypesandBehaviouralContracts. ACMComput.Surv. 49,1,Article3(April2016),
36 pages.
[25]Atsushi Igarashi and Naoki Kobayashi. 2004. A generic type system for the
Pi-calculus. Theor. Comput. Sci. 311, 1-3 (2004), 121–163.
[26]Ilya Biin.2017. AstraNet. (August 2017). https://github.com/zenhotels/astranet.
[27]K8S 2017. Kubernetes: Production-Grade Container Orchestration. https://
kubernetes.io/. (June 2017). https://kubernetes.io/.
[28]DexterKozen.1983. ResultsonthePropositionalmu-Calculus. Theor.Comput.
Sci.27 (1983), 333–354. https://doi.org/10.1016/0304-3975(82)90125-6
[29]DanielKroening,DanielPoetzl,PeterSchrammel,andBjörnWachter.2016.Sound
static deadlock analysis for C/Pthreads. In ASE. 379–390.
[30]JulienLange,NicholasNg,BernardoToninho,andNobukoYoshida.2017. Fencing
offGo:LivenessandSafetyforChannel-basedProgramming.In POPL2017 .ACM,
748–761.
[31]Julien Lange, Nicholas Ng, Bernardo Toninho, and Nobuko Yoshida. 2017. Godel
Checker. (2017). http://mrg.doc.ic.ac.uk/tools/godel-checker/.
[32]JulienLange,EmilioTuosto,andNobukoYoshida.2015. FromCommunicating
Machines to Graphical Choreographies. In POPL. ACM, 221–232.
[33]Jeff Magee and Jeff Kramer. 1999. Concurrency: State Models & Java Programs .
John Wiley & Sons, Inc., New York, NY, USA.
[34]Robin Milner. 1980. A Calculus of Communicating Systems . Lecture Notes in
Computer Science, Vol. 92. Springer.
[35]Robin Milner. 1989. Communication and Concurrency . Prentice-Hall, Inc., Upper
Saddle River, NJ, USA.
[36]NicholasNgandNobukoYoshida.2016. Staticdeadlockdetectionforconcurrent
go by global session graph synthesis. In CC. 174–184.
[37]Luca Padovani.2014. Deadlock and Lock Freedom in the Linear π-Calculus.In
CSL-LICS’14 ,ThomasA.HenzingerandDaleMiller(Eds.).ACMPress,72:1–72:10.
https://doi.org/10.1145/2603088.2603116
[38]CorinaS.Pasareanu,WillemVisser,DavidH.Bushnell,JacoGeldenhuys,PeterC.
Mehlitz, and Neha Rungta. 2013. Symbolic PathFinder: integrating symbolic
executionwithmodelcheckingforJavabytecodeanalysis. Autom.Softw.Eng.
20, 3 (2013), 391–425.
[39]Sameer Ajmani. 2014. Go Concurrency Patterns: Pipelines and cancellation.
(2014). https://blog.golang.org/pipelines.
[40]KaiStadtmüller,MartinSulzmann,andPeterThiemann.2016. StaticTrace-Based
Deadlock Analysis for Synchronous Mini-Go. In APLAS. 116–136.
[41]Nick Stenning. 2017. Building a new router for GOV.UK. https://gdstechnology.
blog.gov.uk/2013/12/05/building-a-new-router-for-gov-uk/. (June 2017). https:
//gdstechnology.blog.gov.uk/2013/12/05/building-a-new-router-for-gov-uk/.
[42]Stillwater Supercomputing. 2017. Collection of Golang concurrency patterns.
(June 2017). https://github.com/stillwater-sc/concurrency.
[43]TheGoAuthors.2017.EffectiveGo.(June2017). https://golang.org/doc/effective_
go.html.
[44]Willem Visser, Klaus Havelund, Guillaume P. Brat, and Seungjoon Park. 2000.Model Checking Programs. In The Fifteenth IEEE International Conference on
Automated Software Engineering, ASE 2000 . 3–12.
[45]KaiWei.2016. HowwebuiltUberengineering’shighestquerypersecondservice
using Go. https://eng.uber.com/go-geofence/. (2016).

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. 