The Interactive Veriﬁcation Debugger:
Effective Understanding of Interactive Proof Attempts
Martin Hentschel
TU Darmstadt
Darmstadt, Germany
hentschel@cs.tu-
darmstadt.deReiner Hähnle
TU Darmstadt
Darmstadt, Germany &
Università degli Studi di Torino
Torino, Italy
haehnle@cs.tu-
darmstadt.deRichard Bubel
TU Darmstadt
Darmstadt, Germany
bubel@cs.tu-
darmstadt.de
ABSTRACT
The Symbolic Execution Debugger (SED) is an extension
of the Eclipse debug platform for interactive symbolic exe-
cution. Like a traditional debugger, the SED can be used
to locate the origin of a defect and to increase program un-
derstanding. However, as it is based on symbolic execution,
all execution paths are explored simultaneously. We demon-
strateanextensionoftheSEDcalledInteractiveVeriﬁcation
Debugger (IVD) for inspection and understanding of formal
veriﬁcation attempts. By a number of novel views, the IVD
allows to quickly comprehend interactive proof situations
and to debug the reasons for a proof attempt that got stuck.
It is possible to perform interactive proofs completely from
within the IVD. It can be experimentally demonstrated that
the IVD is more eﬀective in understanding proof attempts
than a conventional prover user interface. A screencast ex-
plaining proof attempt inspection with the IVD is available
at youtu.be/8e-q9Jf1h_w.
CCS Concepts
•Software and its engineering →Software veriﬁca-
tion; Formal software veriﬁcation; Software testing and
debugging;
Keywords
Symbolic Execution, Debugging, Program Execution Visu-
alization, Veriﬁcation, Proof Understanding
1. INTRODUCTION
One of the most time-consuming and challenging steps in
deductive, semi-automatic software veriﬁcation is to under-
stand why a proof attempt fails. Reasons for failure include,
of course, buggy programs or speciﬁcations. It is also possi-
blethattheautomateddeductioncomponentisnotpowerfulenough to ﬁnd a proof. In either case the user needs to de-
velop suﬃcient understanding of the current proof situation
to be able to ﬁx the program/speciﬁcation or to perform
adequate interactive proof steps.
To reason about programs requires to explore their full
behavior. One way to do so is to use symbolic execution [2,
3, 10, 11]. Deductive veriﬁcation based on symbolic execu-
tion is, for instance, implemented in the veriﬁcation systems
KeY [1], KIV [15], and VeriFast [8]. Our work is based on
KeY which permits to verify correctness of Java programs
speciﬁed with the Java Modeling Language (JML) [13].
Symbolic execution is a general static analysis technique
that can be also used to realize an interactive debugger with
the usual functionality such as stepwise execution and the
inspection of states. In fact, this had been suggested al-
ready in [10, 11]. The big advantages of a debugger based
on symbolic execution are (i) it can start a session at any
program point without setting up an initial state and (ii) all
feasible execution paths are explored simultaneously. Such a
tool was realized in the form of the Symbolic Execution De-
bugger1(SED) [5]. It is an extension of the Eclipse debug
platform for symbolic execution into which any symbolic
execution engine can be integrated. By default, the SED
integrates KeY as its symbolic execution engine.
In this tool demo we present an extension and a new use
case of the SED for the inspection, understanding, and com-
pletion of interactive proof attempts. We call our SED ex-
tension Interactive Veriﬁcation Debugger (IVD) to distin-
guishitfromthepreviousversionsoftheSED.Thedebugger-
like inspection of proof attempts is particularly advanta-
geous for novice users who lack background in formal veri-
ﬁcation. It is realized by several new views that present the
information contained in a proof attempt in a way that is
familiar to software developers. For instance, the program
behavior explored in a partial proof is visualized as a sym-
bolic execution tree and hides all the logical reasoning steps.
In addition, the truth status of the formulas that were evalu-
ated in the underlying proof can be traced and visualized. If
desired, the full KeY proof with all details can be inspected
and continued interactively. Statistical evidence that the
IVD indeed increases the eﬀectiveness of proof attempt in-
spections is presented in [6].
We proceed with a demonstration of how to create and
manage proofs in Eclipse (Section 2) followed by their in-
1www.key-project.org/eclipse/SED
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciﬁc permission and/or a
fee. Request permissions from Permissions@acm.org.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ASE’16 , September 3–7, 2016, Singapore, Singapore
ACM. 978-1-4503-3845-5/16/09...$15.00
http://dx.doi.org/10.1145/2970276.2970292
846
spection2(Section 3) and interactive completion3(Section 4)
with the IVD. Finally, we discuss related work (Section 5)
and conclude (Section 6).
2. CREATING AND MANAGING PROOFS
We use the IVD with KeY as the underlying theorem
prover to inspect veriﬁcation proofs of Java code. The rec-
ommended way to create and manage proofs is to allow
Eclipse to automatically maintain them for you. This func-
tionality is oﬀered by the Eclipse extension KeY Resources4
[7]. Each time when the source code under veriﬁcation is
modiﬁed, KeY Resources determines which proofs might be
aﬀected by the change and re-veriﬁes them. This ensures
that source code, speciﬁcations and proofs are always in
sync. Source code markers, placed as closely as possible to
the veriﬁed code element, are used to present proof results
to the user.
InFigure1theactiveeditorinthecentershowsthesource
code of method add. Its formal speciﬁcation appears as
structured comments expressed in JML and inlined into the
code. JML semantics stipulates that by default a method
is called in a state where its parameters of reference type
(here: a) are not null. The method contract ensures that
(i) an array is returned, (ii) whose length is greater by one
compared to the given array, (iii) the last element of the
returned array is the new value, and (iv) all other array val-
ues of the returned value are identical to the values of the
original array at the same position. In addition, addwill
not throw an exception ( normal_behavior ) and not change
any existing location ( assignable \nothing ). However, it
is not forbidden to create objects and change locations on
them. A loop invariant required for veriﬁcation is speciﬁed
as well. The warning marker at the method declaration in-
dicates that the current proof attempt was not successful.
An Eclipse quick ﬁx called Debug proof can be used to in-
spect the proof attempt with the IVD. Eclipse’s Java editor
does not support JML out of the box. JML-speciﬁc syn-
tax highlighting and editing facilities are provided by our
Eclipse extension JML Editing.5
The project icon in view Package Explorer indicates that
the source code is part of a KeY Project , an extended Java
Project(provided by KeY Resources) where proofs are au-
tomatically maintained.
Alternatively to KeY Resources, KeY itself can be used to
create and perform proof attempts. This is only manageable
for small projects with very few proofs. For large projects it
is not recommended, because it requires a lot of automizable
user interaction and proofs aﬀected by a change must be
identiﬁed manually.
All this shows that the IVD ﬁts nicely into the existing
tool chain for veriﬁcation with KeY.
3. INSPECTING PROOFS
The IVD displays the full behavior of the program under
veriﬁcation explored by using symbolic execution during the
2A screencast explaining proof attempt inspection with the
IVD is available at youtu.be/8e-q9Jf1h_w.
3A screencast explaining interactive veriﬁcation with the
IVD is available at youtu.be/IV-dEnpCLkI.
4www.key-project.org/eclipse/KeYResources
5www.key-project.org/eclipse/JMLEditingcurrent proof attempt in the views Debug(as a tree struc-
ture) and Symbolic Execution Tree (visualized, see Figure 2).
Diﬀerent icons highlight the function of each symbolic exe-
cution tree node. Details of the currently selected node are
shown in view Properties .
The views Debug,Symbolic Execution Tree and the active
editor are automatically synchronized. In addition, source
codestatementsreachedduringsymbolicexecutionarehigh-
lighted in the active editor. This provides a compact sum-
mary of the source code that was symbolically executed in
the current proof attempt. A proof is successful, if and only
if each symbolic path ends with a termination node and no
node in the symbolic execution tree is marked by an icon
crossed out in red (for not being veriﬁed).
In Figure 2 the proof attempt of addis inspected with the
IVD. An icon crossed out in red at the selected node indi-
cates that the loop invariant does not hold initially. The
JML loop speciﬁcation consists of three parts: (i) the loop
invariant must hold initially and has to be preserved in each
loop iteration, (ii) the decreasing clause, also called variant,
a strictly positive numerical expression that must be de-
creased in each loop iteration, and (iii) the assignable clause
describing the locations that may be changed by the loop.
To identify which part of the loop speciﬁcation is violated,
the truth status assigned to each expression in the current
proof can be traced [4]. This is visualized in view Properties
(tab Loop Invariant ). Each open proof goal (here only one) is
displayed as an implication with (i) the proof obligation to
verify (right side of the arrow ==>), and (ii) additional con-
straints under which the proof obligation is evaluated (left
side of the arrow). Formulas are colored according to their
truth status in the proof. Here, the prover evaluated the
formula i < a.length to false. Indeed, the loop invariant
does not hold in case the array is empty, a typical oversight.
After correcting the loop invariant the proof (Figure 3)
is still not successful, as indicated in the termination node
at the end of add’s execution. Tracing the truth status in
view Properties (tab Postcondition ) shows that two formulas
are neither evaluated to true nor to false. These are the uni-
versally quantiﬁed postcondition and the formula describing
the assignable clause.6We can immediately exclude the lat-
ter, because the implementation of addonly changes the
result array, which is allowed.
Hence, the postcondition must be the reason why the
proof remains open. View Variables shows the symbolic state
at the selected termination node. View Properties (callout in
Figure 3) shows additional constraints on symbolic values.
But the constraints say nothing about the array index i_0
which represents a generic loop iteration. We conclude that
the loop invariant is too weak to prove the postcondition.
As a solution, the loop invariant could be strengthened with
\forall int j; j >= 0 && j < i; result[j] == a[j] .
4. COMPLETING PROOFS
So far, we used the IVD in auto-active style [14] by adjust-
ing code or speciﬁcations to interact with the prover. KeY’s
program logic Java DL extends ﬁrst-order logic and is un-
decidable. Hence, it is sometimes necessary to assist the
6At the moment, the implication is displayed in Java DL,
the program logic used by KeY. The rendering of JML in
Java DL is easy to read with a little practice.
847Figure 1: A quick ﬁx allows to debug a proof attempt maintained by KeY Resources with the SED
Figure 2: Loop invariant is marked as not veriﬁed, because it could be proven not to hold
prover. In KeY this is done by applying rules interactively
before restarting the automated proof search strategy.
Consider Figure 4 where the proof attempt of method
searchis inspected with IVD. The method implements a
search of argument content in the given array a. The search
starts at the index given as argument start. If the contentis not found in a, then -1 is returned instead of the found
index. The precondition requires that startis a valid ar-
ray index. The postcondition expresses the functionality of
search. In addition, the loop invariant (i) bounds the loop
counter variable ito valid array indices, and (ii) expresses
that at previously visited indices the content was not found.
848Figure 3: Termination node marked as not veriﬁed: the loop invariant is too weak to prove postcondition
Body Preserves Invariant branch condition
Currently selected Loop Body Termination node
Figure 4: Prover was not able to verify universally quantiﬁed loop invariant automatically
The symbolic execution tree indicates that the loop in-
variant is not preserved on the Body Preserves Invariant
branch, which represents an arbitrary loop iteration (icon
crossed out in red in loop body termination node). Truthstatus tracing in the Properties view tells us that the univer-
sally quantiﬁed loop invariant was not completely evaluated
(it is uncolored). The reason here is that the prover needs
guidance to ﬁnd the proof. View Proofin Figure 4 shows,
849similar as in the legacy user interface of KeY, the full proof
tree (bottom left), including the implication corresponding
to the currently selected proof node (to its right). Rules are
applied from that window in the same way as in KeY, via
the context popup menu of a selected subexpression.
The automated proof strategy had tried out already many
rules which results in a complex proof goal. Instead of in-
specting that complex implication, we choose to prune the
proof tree. The context menu item Prune Proof cuts oﬀ right
after the node where symbolic execution ends and the failed
proof attempt of the loop invariant begins. Next, we ap-
ply the proof macro Full Auto Pilot which splits each part
of the proof obligation to verify into a separate branch. In
addition, branches that cannot be closed automatically are
cut back to their initial state. These are best practices in
KeY to understand a failed proof attempt.
The implication to prove after a few simpliﬁcation steps
is shown in Figure 5. With some practice, an opportunity
to create a contradiction on the left side of the arrow can be
spotted. The two formulas involved in it are highlighted in
Figure 5 on top and inside the callout. The contradiction is
easilyprovableonceweinstantiatetheuniversallyquantiﬁed
formula in the callout with j_2by applying rule allLeftHide .
It instantiates a universally quantiﬁed formula and hides
it, thus making work for the prover easier. We restart the
automated proof search by executing macro Close Provable
Goals Below . It has the advantage that in case the proof
could not be found automatically, the proof tree is cut back
to its original state. But here, the prover was successful.
Now we take again advantage of IVD’s views. One branch
isstillmarkedasnotveriﬁed. Themarkeratthetermination
node tells that the postcondition could not be automatically
proven(notshown). Thesamecontradictionasbeforeisalso
present in this branch and it can be made explicit by guiding
the prover in the same manner as before. However, before
running the Close Provable Goals Below macro, we have to
set the arithmetic treatment in the view Symbolic Execution
SettingstoModel Search . This tells the proof search strategy
to systematically search for a model.
Finally, the proof is closed and we can save it via the
toolbar of view Proof. KeY Resources will then detect the
change and update the result marker accordingly.
5. RELATED WORK
The IVD is based on the SED [5] which is intended to
inspect, visualize and debug programs, however, the SED
completely lacks the capability to inspect and understand
interactive veriﬁcation proofs as described in this tool demo.
The Boogie Veriﬁcation Debugger [12] and the symbolic
debugger part of the VeriFast IDE [9] can inspect the states
on a symbolic path that could not be veriﬁed. Like the
IVD, these tools present the memory and assumptions of
each selected state to the user. IVD permits to inspect all
symbolic execution paths explored by a proof at once. In
addition, truth status tracing is available to narrow down
the unveriﬁed parts of a proof goal. In contrast to Boogie
and VeriFast, which run in batch mode, KeY interleaves
automated theorem proving with user interaction which is
supported as part of IVD.
Other veriﬁcation tools based on symbolic execution (e.g.,
KIV [15], VeriFast [8]), could proﬁt from an SED integration
similar to the IVD.6. CONCLUSION
We demonstrated a new use case for debuggers based on
symbolic execution: the inspection and understanding of
general, interactive proof attempts. The IVD tool is im-
plemented on top of the SED and tightly integrates with
Eclipse and the infrastructure needed for veriﬁcation. The
IVD presents a proof attempt using diﬀerent views, which
makes it a powerful assistant for proof understanding tasks.
Its usage and best practices are presented in tutorial style
by way of two non-trivial, fully executable Java examples.
Whenveriﬁcationtargetsaresimpleenoughfortheprover
to run in auto-active style [14], the IVD hides the logical
reasoning completely . This is particularly suited for novice
users with little experience with logic and automated proof
search. It makes the learning curve for using interactive
veriﬁcation systems considerably less steep. This increased
eﬀectivity of the IVD compared with a conventional user
interface can be experimentally proven [6].
Completely auto-active proofs are, however, not always
possible. Sometimes an interactive prover needs guidance
to ﬁnish a proof. This is supported as well in the IVD by a
view that oﬀers nearly the same functionality as the original
user interface of the underlying KeY prover.
We stress that the SED is a platform for debuggers based
on symbolic execution into which, in principle, any symbolic
execution engine can be integrated. A consistent tool chain
andtheabilitytopresentresultsofastaticanalysisbasedon
symbolic execution in a user friendly way that is familiar to
developers is of fundamental importance for usability. We
encourage system builders to proﬁt from the SED and to
integrate their tools similar to the IVD.
7. ACKNOWLEDGMENTS
We thank Anna Marie Filighera, Leonard Götz, Viktor
Nikolas Pfanschilling and Seena Vellaramkalayil for their
contributions to the IVD. Parts of this paper were written
duringaresearchstayofthesecondauthoratandsupported
by University of Torino.
8. REFERENCES
[1] W. Ahrendt, B. Beckert, D. Bruns, R. Bubel, C. Glad-
isch, S. Grebing, R. Hähnle, M. Hentschel, M. Herda,
V. Klebanov, W. Mostowski, C. Scheben, P. Schmitt,
and M. Ulbrich. The KeY Platform for Veriﬁcation and
Analysis of Java Programs. In D. Giannakopoulou and
D.Kroening,editors, Veriﬁed Software: Theories, Tools
and Experiments , volume 8471 of LNCS, pages 55–71.
Springer, 2014.
[2] R. S. Boyer, B. Elspas, and K. N. Levitt. SELECT—
A formal system for testing and debugging programs
by symbolic execution. ACM SIGPLAN Notices ,
10(6):234–245, June 1975.
[3] R. M. Burstall. Program proving as hand simulation
with a little induction. In Information Processing ’74 ,
pages 308–312. Elsevier/North-Holland, 1974.
[4] M. Hentschel. Integrating Symbolic Execution, Debug-
ging and Veriﬁcation . PhD thesis, TU Darmstadt, Jan.
2016. http://tuprints.ulb.tu-darmstadt.de/5399/.
850Figure 5: Contradiction in the antecedent
[5] M. Hentschel, R. Bubel, and R. Hähnle. Symbolic Exe-
cution Debugger (SED). In B. Bonakdarpour and S. A.
Smolka, editors, Runtime Veriﬁcation, 14th Interna-
tional Conference, RV, Toronto, Canada , volume 8734
ofLNCS, pages 255–262. Springer, 2014.
[6] M. Hentschel, R. Hähnle, and R. Bubel. An Empir-
ical Evaluation of Two User Interfaces of an Interac-
tive Program Veriﬁer. In S. Apel and S. Khurshid, ed-
itors,Proc. 31st IEEE/ACM International Conference
on Automated Software Engineering (ASE), Singapore .
ACM Press, Sept. 2016.
[7] M. Hentschel, S. Käsdorf, R. Hähnle, and R. Bubel. An
InteractiveVeriﬁcationToolMeetsanIDE. InE.Albert
and E. Sekerinski, editors, Integrated Formal Methods ,
volume 8739 of LNCS, pages 55–70. Springer, 2014.
[8] B. Jacobs and F. Piessens. The VeriFast program ver-
iﬁer. Technical Report CW-520, Department of Com-
puter Science, Katholieke Universiteit Leuven, Aug.
2008.
[9] B. Jacobs, J. Smans, and F. Piessens. A Quick Tour
of the VeriFast Program Veriﬁer. In K. Ueda, editor,
Programming Languages and Systems , volume 6461 of
LNCS, pages 304–311. Springer, 2010.
[10] S.KatzandZ.Manna. Towardsautomaticdebuggingof
programs. In Proceedings of the International Confer-ence on Reliable software, Los Angeles , pages 143–155.
ACM Press, 1975.
[11] J. C. King. Symbolic execution and program test-
ing.Communications of the ACM , 19(7):385–394, July
1976.
[12] C. Le Goues, K. R. M. Leino, and M. Moskal. The
Boogie Veriﬁcation Debugger. In Proceedings of the 9th
International Conference on Software Engineering and
Formal Methods , SEFM’11, pages 407–414, Berlin, Hei-
delberg, 2011. Springer-Verlag.
[13] G. T. Leavens, E. Poll, C. Clifton, Y. Cheon, C. Ruby,
D. Cok, P. Müller, J. Kiniry, P. Chalin, D. M. Zimmer-
man, and W. Dietl. JML Reference Manual , May 31,
2013. Draft Revision 2344.
[14] K. R. M. Leino and M. Moskal. Usable Auto-Active
veriﬁcation. In T. Ball, L. Zuck, and N. Shankar, ed-
itors,Usable Veriﬁcation Workshop (UV), Redmond,
WA, USA , 2010.
[15] W. Reif, G. Schellhorn, K. Stenzel, and M. Balser.
Structured speciﬁcations and interactive proofs with
KIV. In W. Bibel and P. Schmitt, editors, Automated
Deduction — A Basis for Applications , volume 9 of Ap-
plied Logic Series , pages 13–39. Springer, 1998.
851