Static Detection of Asymptotic Resource
Side-Channel Vulnerabilities in Web Applications
Jia Chen Oswaldo Olivo Isil Dillig Calvin Lin
The University of Texas at Austin, United States
jchen@cs.utexas.edu oswaldo.l.olivo@gmail.com isil,lin@cs.utexas.edu
Abstract —Web applications can leak conﬁdential user informa-
tion due to the presence of unintended side-channel vulnerabili-
ties in code. One particularly subtle class of side-channel vulner-abilities arises due to resource usage imbalances along different
execution paths of a program. Such side-channel vulnerabilities
are especially severe if the resource usage imbalance is asymptotic.
This paper formalizes the notion of asymptotic resource side-
channels and presents a lightweight static analysis algorithm
for automatically detecting them. Based on these ideas, we have
developed a tool called S
CANNER that detects resource-related
side-channel vulnerabilities in PHP applications. SCANNER has
found 18 zero-day security vulnerabilities in 10 different webapplications and reports only 2 false positives. The vulnerabilitiesuncovered by S
CANNER can be exploited using cross-site search
attacks to extract various kinds of conﬁdential information, suchas a user’s medications or purchase history.
I. I NTRODUCTION
Web applications have become enormously popular due to
the ubiquity of the Internet and the existence of rich devel-
opment frameworks. Hence, in today’s Internet-rich world,most people perform their daily activities, including bankingand e-commerce, using web applications. Unfortunately, thisgrowing popularity of privacy-sensitive applications has also
led to a surge of illegal activities by hackers trying to steal
conﬁdential data.
To secure private data, web applications currently rely on
a combination of network-level security mechanisms, such asencryption and ﬁrewalls, as well as application-level protection
techniques (e.g., credential checks and session handling).
While these mechanisms provide some degree of privacyassurance, they do not prevent the application from leakingconﬁdential data through unintended communication channels,known as side channels.
Many side-channel leaks in web applications are related to
resource usage (e.g., time or space). As an example, considera health-related web application whose response time variessigniﬁcantly, depending on whether the user is taking a certainmedication. In this case, the server response time can revealconﬁdential information about the ailments of speciﬁc users.For instance, recent work [21] has shown that timing andresponse-size side-channel vulnerabilities can be exploitedusing cross-site search attacks in which the attacker submits
a cross-site query with the user’s credentials and observes thetime it takes for the browser to respond to the query.
The large bulk of existing side-channel attacks (usually
against codes that carry out cryptographical computation)exploit minor imbalances in resource usage [29], [22], [37].
Such attacks rely on the assumption that the attacker is able
to precisely measure the time it takes to execute simple nativeoperations like integer comparison on the target machine.However, despite recent advances in statistical measurementtechniques [34], minor differences in resource usage are dif-ﬁcult to observe in web-oriented settings. On the other hand,
if the attacker is given the ability to amplify the imbalance in
resource usage, then the vulnerability becomes much easier toexploit. For example, consider an application whose responsesize is constant if the answer to a security-sensitive queryis negative but linear in the size of the input otherwise. Inthis case, an attacker can observe a substantial difference inresponse size by supplying a sufﬁciently large input to theapplication. We refer to such vulnerabilities that exhibit anasymptotic difference in resource usage as asymptotic resource
side-channel vulnerabilities.
In this paper, we introduce and formalize asymptotic re-
source side-channels, a class of vulnerabilities that can be ex-ploited in settings where the attacker cannot precisely measureresource usage (e.g., web applications). To help developerssafeguard their applications against such vulnerabilities, wealso present a novel static analysis for automatically detectingasymptotic side channels. Our analysis employs a lightweight
program abstraction that combines taint information with a
coarse summary of resource usage. In particular, our analysisdifferentiates between variables that are untainted, secret-tainted, and user-tainted, and summarizes the resource usageof each code fragment as zero, constant, or unbounded. Thekey idea underlying our analysis is to identify branch condi-
tions that are secret tainted and where the resource usage is
unbounded along one branch but not the other. As we showexperimentally, our proposed program abstraction is effectiveat detecting asymptotic side-channel vulnerabilities with a lowfalse positive rate and can uncover exploitable vulnerabilitiesin real-world web applications.
We have implemented our proposed static analysis in a tool
called S
CANNER1for analyzing PHP applications. While the
techniques we describe in this paper can be used to detectany resource-related asymptotic side-channel vulnerability, ourimplementation focuses on two kinds of resources, namely,time and response size . In addition to pinpointing vulnerable
components, S
CANNER further aids security analysts by iden-
1SCANNER stands for Side Channel ANalyzER
978-1-5386-2684-9/17/$31.00 c/circlecopyrt2017 IEEEASE 2017, Urbana-Champaign, IL, USA
T echnical Research229
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. tifying conﬁdential database ﬁelds that may be leaked due to
the detected vulnerability. Furthermore, S CANNER helps users
assess the severity of the uncovered vulnerability by semi-automatically generating a Javascript exploit that performs across-site search attack.
We evaluate S
CANNER on 10 open-source PHP applications
and show that it uncovers 18 side-channel vulnerabilities and
reports only 2 false positives. Furthermore, we are able to
exploit these vulnerabilities using cross-site search attacks andshow that the attacker can extract various kinds of conﬁdentialdata, such as a user’s purchase history, medical records, and
bids placed by the user. We have reported the vulnerabilitiesto the developers and many of them have been ﬁxed by thedevelopers at the time of this submission.
II. F
ORMALIZATION OF ASYMPTOTIC RESOURCE
SIDE-CHANNELS
In this section, we formally deﬁne the class of side-channel
vulnerabilities studied in this paper and justify our decision tofocus on this subclass.
Deﬁnition 1: (Resource Side-Channel Vulnerabilities) Let
h,ldenote high and low inputs of a program, respectively,
and letR
P(i)denote the resource usage of program Pon
inputi. We say that program Phas a resource side-channel
vulnerability if:
∃h1,h2,l. R P(h1,l)/negationslash=RP(h2,l)
The above deﬁnition above is effectively an instantiation of
the well-known non-interference policy [39] with respect to
resource usage2As in traditional non-interference terminology,
high variables represent secret values, while low variables
denote values that are not security-sensitive. Hence, accordingto the above deﬁnition, a resource side-channel vulnerabilityarises if it is possible to observe different resource usageswhen program Pis run on the same low input but different
high inputs. Hence, an adversary can glean information aboutthe secret simply by observing the program’s resource usage.
Since Deﬁnition 1 does not specify the kind of resource,
it is quite general and can be instantiated in a variety of
ways to yield different classes of side-channel vulnerabilitiespreviously discussed in the literature. For instance, if theresource of interest is CPU cycles, then this vulnerabilitycorresponds to a timing side channel. On the other hand, if we
instantiate R
Pwith power consumption, then the vulnerability
could be exploited to cause a power monitoring attack.
However, since non-interference is a very strong condition
that is violated by almost any program, we believe that such an
approach is not practical. For instance, consider a program thathas a very minor resource imbalance (e.g., a few CPU cycles)
across two different execution paths. While such a program hasa resource side-channel vulnerability according to Deﬁnition 1,
2While the term “non-interference” was originally coined by Goguen and
Meseguer [23], our deﬁnition follows the one adopted by the language-based
security community [39], [8], [41].it is very unlikely to be exploitable because an attacker cannot
reliably observe this minor imbalance in resource usage.3
Motivated by the observation that standard non-interference
is too strong of a policy to reason about exploitable resource
side channels, we instead focus our attention on asymptotic
resource side channels, which can be reliably exploited by
attackers:
Deﬁnition 2: (Asymptotic Resource Side-Channel Vulner-
abilities) Lethdenote the high inputs of a program, and let
RP(I)denote the resource usage of program Pon inputI.W e
say that program Phas an asymptotic resource side-channel
vulnerability if:
∃h1,h2.R P(h1)/negationslash=Θ (RP(h2))
In this deﬁnition, observe that the low inputs are uncon-
strained, so RP(h1)andRP(h2)are both functions of low
inputsl. Thus, this deﬁnition states that it is possible to ﬁnd
a pair of secrets h1andh2for which the resource usage of P
will be asymptotically different with respect to the low-inputs.Since the attacker can control the program’s low inputs, hecan easily tell whether the secret is h
1orh2by running the
program on arbitrarily large values of the low input.
Observe that every asymptotic resource side-channel vul-
nerability also satisﬁes Deﬁnition 1, but not vice versa. Weillustrate the differences between Deﬁnitions 1 and 2 usingthe following two examples.
Example 1: Consider the following code snippet:
foo(int n) {
if (secret) {
for(inti=0 ;i<n ;i++) consume(1);
} else consume(1);
}
Letconsume( x)be a statement that consumes xunits of
resource. If the value of secret istrue, then the resource
usage of foo isn. On the other hand, if secret isfalse,
then the resource usage is 1. Since, n/negationslash=Θ ( 1 ) , this program
contains an asymptotic side-channel vulnerability according to
Deﬁnition 2.
Example 2: Consider the following code snippet:
bar(int n) {
if(secret) consume(2); else consume(1); }
Here, function bar contains a vulnerability according to
Deﬁnition 1 because the resource usage of the program differsdepending on whether secret is true or false. However, this
function does not exhibit an asymptotic vulnerability because
R
P(H1)andRP(H2)only differ by a constant.
This second example illustrates why we choose to focus
on the subclass of vulnerabilities given by Deﬁnition 2 asopposed to Deﬁnition 1: Because the difference in resource
3In fact, even if we restrict ourselves to resource-heavy operations, such
as database queries, Deﬁnition 1 still seems to be too strong in practice.
To justify this claim, we implemented an analysis that reports all instances
of Deﬁnition 1 for resource-heavy operations (speciﬁcally, database queries).Even under this restrictive scenario, the analysis reported 285 warnings for the
10 PHP applications used in our evaluation. Our timing measurements for a
subset of these reports reveal that the overwhelming majority of the warnings
are not exploitable under realistic database states (because there is signiﬁcant
overlap between timing measurements for positive and negative queries).
230
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. usage is very small in Example 2, it is, in practice, quite
hard to exploit this imbalance due to various kinds of noisein the program’s execution environment (e.g., network trafﬁc).Hence, our approach deliberately targets vulnerabilities thatcan be ampliﬁed by the attacker through carefully craftedinputs. In fact, previous work [21] has argued that one of thetools for exploiting side channel vulnerabilities is to “amplify
the side channel by inﬂating communication or computation”.
This trick only works if the program contains an asymptotic
imbalance in resource usage rather than a constant difference.
Unfortunately, in practice it is still difﬁcult to statically rea-
son about worst-case resource usage, and existing techniquesfor reasoning about complexity typically do not scale to largeprograms [25], [24], [26], [12]. Hence, to analyze realistic webapplications with a low false positive rate, we further restrictour attention to the following subclass of asymptotic side-channel vulnerabilities that can be detected using lightweightstatic analysis:
Deﬁnition 3: (Constant-Superconstant Resource Side-
Channel Vulnerabilities) Leth,ldenote the high and low
inputs of a program, and let R
P(I)represent the resource
usage of program Pon input I. Program Phas a constant-
superconstant resource side-channel vulnerability if:
∃h1,h2.R P(h1)=O(1)∧RP(h2)/negationslash=O(1)
In other words, we are interested in detecting a subclass
of asymptotic side-channel vulnerabilities where the resourceusage is constant for some values of the secret but a function ofLfor other values of the secret. Note that, in this deﬁnition,
R
P(h2)/negationslash=O(1)implies that the resource usage is a non-
constant function of Lwhen the high inputs are ﬁxed to
h2. Our detection algorithm targets this speciﬁc subclass
of vulnerabilities because it is possible to ﬁnd instances ofDeﬁnition 3 in a practical way without requiring heavy-weightresource usage analysis.
III. S
TATIC DETECTION OF ASYMPTOTIC RESOURCE SIDE
CHANNEL VULNERABILITIES
We now turn our attention to the static analysis algorithm
for detecting asymptotic (i.e., constant-superconstant) vulnera-bilities. We ﬁrst explain the key ideas underlying our algorithmand then provide a more formal description of the analysis.
A. Key Ideas
The key idea underlying our static analysis is to look for two
different paths π
1,π2in the program such that π1,π2satisfy
the following conditions:
1) Paths π1,π2differ on the value of the secret
2) Resource usage of π1is a function of low input l
3) Resource usage of π2isnotdependent on l
To see how these conditions relate to Deﬁnition 3, observe
that condition (1) partitions the high inputs into two disjoint
classesH1,H2such that h1∈H1satisﬁes the predicates on
pathπ1, whileh2∈H2satisﬁes the predicates in path π2.
Furthermore, condition (2) states that ∀h2∈H2.R P(h2)/negationslash=
O(1), while condition (3) ensures ∀h1∈H1.RP(h1)=O(1).Expression E:=c|v|E1⋆E 2(⋆∈{+,−,...})
Condition C:=E1◦E2(◦∈{<,>,=})
|¬C|C1∧C2|C1∨C2
Statement S:= consume( E)|source(v,label)
|v:=E|S1;S2
|C?S1:S2|while (C )do S
Fig. 1. Language used for describing our analysis
Our static analysis combines two kinds of taint information
(namely, secret taint and input taint ) with a coarse summary
of resource usage for each program fragment. Input taintinformation is used to summarize the resource usage of eachcode snippet as zero, constant, or potentially inﬁnite, wherethe last value indicates that resource usage is controlled bythe attacker. In contrast, secret taint information is used todetermine if two program paths differ with respect to someconﬁdential data. Combining these two crucial pieces of infor-mation, our analysis reports an error if it encounters a secret-tainted condition such that the resource usage is potentiallyinﬁnite along one branch, but not in the other.
Example 3: Consider again the code from Example 1, which
contains an if statement whose branch condition is secret-tainted. The resource usage in the else branch is constantand does not depend on user input. On the other hand, theresource usage in the then branch can be made arbitrarilylarge because the loop bound nisinput-tainted. Since the
resource usage inside the loop body is non-zero and the loopbound is input-tainted, we summarize the resource usage ofthe then branch as potentially inﬁnite. The analysis reportsa potential vulnerability for this example because there is asecret tainted branch-condition, where the resource usage ispotentially inﬁnite along one branch, but not the other.
B. F ormal Description of Static Analysis
We formally describe our algorithm on the simpliﬁed im-
perative programming language shown in Figure 1. In addition
to the standard assignment (v :=E), sequencing (S
1;S2),
conditional (C ?S1:S2), and looping constructs, this
language also contains the following statements that model
resource consumption and taint introduction:
•Resource consumption: The statement consume( E)models
the consumption of Eunits of resource, where Eis an
integer expression. For example, if the resource of interest
is memory, then each memory allocation can be modeledusing a consume statement in our language.
•Taint introduction: The statement source(v,label) models
the tainting of variable vwith label label. where label is
eitherH(for high) or L(for low). For instance, source(v,H)
indicates that variable vis assigned to a secret value. In
practice, taint sources with label Hmodel database queries
that retrieve security-sensitive data (e.g., password). On theother hand, taint sources with label Lrepresent operations
that accept some input from the user.
231
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. Γ/turnstileleftc:⊥
Γ/turnstileleftv:Γ (v)
Γ/turnstileleftE1:η1Γ/turnstileleftE2:η2
Γ/turnstileleftE1⋆E2:η1/unionsqη2
Fig. 2. Rules for determining taint values of expressions E
As mentioned earlier in Section III-A, our static analysis
combines two different program abstractions to effectively
detect asymptotic resource side channel vulnerabilities:
•Taint abstraction: Each variable has a taint value drawn from
the domain T={⊥,L,H,/latticetop}, where⊥denotes lack of
taint,L,Hrepresent input- and secret-taint respectively, and
/latticetoprepresents both input and secret taint. We impose the
partial order ⊥/subsetsqequalH,L/subsetsqequal/latticetop .
•Resource abstraction: We summarize the resource usage
of each program fragment as a value drawn from the set
R={0,1,∞} where0indicates no resource usage, 1
indicates constant (but not necessarily unit) resource usage,
and∞indicates that the resource usage cannot be statically
bounded (i.e., because it is controlled by the user). We deﬁnea⊕operation on elements of set R={0,1,∞}as follows:
∀x∈R.x⊕∞=∞
∀x∈R.x/negationslash=∞⇒x⊕1=1
∀x∈R.x=0⇒x⊕0=0
We also deﬁne a total order /followson setRas∞/follows1/follows0.
Finally, given Δ
1,Δ2∈R, we write Δ1/greatermuchΔ2ifΔ1=∞
andΔ1/followsΔ2.
Using these program abstractions, we can describe our
analysis using rules of the form Γ/turnstileleftS:Γ/prime,Δ,χ where:
•Taint environments Γ,Γ/primemap program variables to a taint
valueη∈{ ⊥,L,H,/latticetop};
•Δ∈{0,1,∞}summarizes resource usage of statement S;
•χis a boolean value indicating whether or not a vulnerability
is present in S
Hence, the meaning of the judgment Γ/turnstileleftS:Γ/prime,Δ,χ is:
“If we execute statement Sin an environment that satisﬁes
Γ, then the resource usage of Sis given by Δand the taint
environment after SisΓ/prime. Furthermore, if χis true, then Smay
contain an asymptotic resource side channel vulnerability”.
We describe our static analysis using the inference rules
shown in Figures 2, 3, and 4. First, the helper rules fromFigure 2 and Figure 3 allow us to determine the taint value η
for each expression Eand predicate Cunder taint environment
Γ. According to the rules in Figure 2, constants are not tainted(⊥), and the taint value for each variable vis given by Γ.F o r
composite expressions of the form E
1⋆E2, the taint value is
given by the join of the values of E1andE2. For instance,
ifE1has taint HandE2has taint ⊥, then the taint value
ifE1+E2isH/unionsq⊥=H. The rules for determining taint
value of predicates are similar to those for expressions and are
shown in Figure 3.Γ/turnstileleftE1:η1Γ/turnstileleftE2:η2
Γ/turnstileleftE1◦E2:η1/unionsqη2
Γ/turnstileleftC:η
Γ/turnstileleft¬C:η
Γ/turnstileleftC1:η1Γ/turnstileleftC2:η2op∈{ ∧,∨}
Γ/turnstileleftC1opC2:η1/unionsqη2
Fig. 3. Rules for determining taint values of predicates C
Let us now consider the main analysis rules presented in
Figure 4. Here, rule (1) describes the analysis of a taint
source of the form source(v,label) . In this case, the new taint
environment Γ/primeis obtained from Γby updating the taint value
ofvtolabel.
Rule (2) describes the analysis of consume( E)statements
that model resource usage. Recall that resource usage isdeﬁned to be ∞if expression Ecan be made arbitrarily large
by an attacker. Hence, we ﬁrst use the helper judgments from
Figure 2 to determine the taint value ηofE.I fη=L, then the
resource usage of this statement is ∞but constant otherwise.
Rule (3) describes taint propagation for assignments of the
formv:=E. As before, we use the helper rules from Figure 2
to determine the taint value ηofEand update the taint
environment by assigning vtoη.
Rule (4) shows how we analyze sequence statements S
1;S2.
Observe that the resource usage of this statement is obtained
by adding the resource usage Δ1ofS1andΔ2ofS2using
the⊕operation deﬁned earlier. Furthermore, S1;S2contains
a vulnerability if either S1orS2has a vulnerability; hence
we take the disjunction of χ1andχ2.
Rule (5) for conditionals is a bit more involved. Recall that
C?S1:S2exhibits a side-channel vulnerability if Cdepends
on the secret and S1andS2have different resource usages.
Hence, to determine if there is a vulnerability, we ﬁrst check
the taint value ηofCusing Figure 3. Clearly, if η/negationslash/supersetsqequalH , the
statement does not introduce a vulnerability; hence χ=false
under this scenario. On the other hand, if Cis secret-dependent
(i.e.,η/supersetsqequalH ), then an asymptotic side-channel vulnerability
arises if the resource usage Δiis∞in one branch but constant
or zero in the other branch. Hence, χistrue ifΔ1/greatermuchΔ2or
Δ2/greatermuchΔ1, but it is false otherwise.
Continuing with rule (5), let us consider the taint values
after analyzing C?S1:S2underΓ. If the taint environment
afterSiis given by Γi, then the value of each variable v
afterC?S1:S2is given by Γ1(v)/unionsqΓ2(v). Hence, the join
operation Γ1/unionsqΓ2on taint environments takes the pairwise
join for each variable.
Finally, let us consider the resource usage of the statement
C?S1:S2, where the resource usage of each Siis given
byΔi. SinceS1andS2cannot execute at the same time, the
resource usage of C?S1:S2ismax(Δ 1,Δ2), which is in
fact the same as Δ1⊕Δ2.
The ﬁnal rule in Figure 4 describes the analysis of loops.
First, the assumption Γ/turnstileleftS:Γ,Δ,χ at the second line of Rule
232
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. (1)Γ/prime=Γ [v/mapsto→label]
Γ/turnstileleftsource(v,label):Γ/prime,0,false
(2)Γ/turnstileleftE:ηΔ=/braceleftbigg
∞ifη/supersetsqequalL
1 otherwise
Γ/turnstileleftconsume( E):Γ,Δ,false
(3)Γ/turnstileleftE:η
Γ/turnstileleftv:=E:Γ [v/mapsto→η],0,false
(4)Γ/turnstileleftS1:Γ1,Δ1,χ1Γ1/turnstileleftS2:Γ2,Δ2,χ2
Γ/turnstileleftS1;S2:Γ2,Δ1⊕Δ2,χ1∨χ2
(5)Γ/turnstileleftC:ηΓ/turnstileleftS1:Γ1,Δ1,χ1
Γ/turnstileleftS2:Γ2,Δ2,χ2
χ=/braceleftbigg
(Δi/greatermuchΔj)i fη/supersetsqequalH
false otherwise
Γ/turnstileleft(C?S1:S2):Γ 1/unionsqΓ2,Δ1⊕Δ2,χ1∨χ2∨χ
(6)Γ/turnstileleftC:ηΓ/turnstileleftS:Γ,Δ,χ
Δ/prime=⎧
⎨
⎩∞ ifΔ=∞∨ (Δ/follows0∧η/supersetsqequalL)
1 ifΔ=1∧η/negationslash/supersetsqequalL
0 otherwise
Γ/turnstileleftwhile(C)do S:Γ,Δ/prime,χ∨(η/supersetsqequalH∧Δ/prime=∞)
Fig. 4. Rules describing our static analysis
(6) states that taint environment Γis a ﬁxed-point, hence, the
taint environment after the loop is also Γ. Now, let us consider
the resource usage of the loop while(C)doS. Clearly, if the
resource usage of the body Sis∞(resp.0), then the resource
usage of the loop is also ∞(resp.0). However, if the resource
usage of Sis constant (i.e., Δ=1 ), then the resource usage
of the loop depends on the taint value ηof predicate C.I n
particular, if η/supersetsqequalL, then the number of loop executions can
be controlled by the attacker, causing the resource usage to be
statically unbounded. Hence, if Δ=1 , resource usage Δ/primeof
the loop is ∞ifη/supersetsqequalL butΔ/prime=1 otherwise.
The last issue to consider in the loop rule is whether there
is a vulnerability. First, observe that the loop may have avulnerability if the loop continuation condition Cis secret-
dependent. In particular, if Cdepends on a secret, the attacker
might be able to learn the secret by observing the number oftimes the loop executes, which in turn can be inferred fromthe program’s resource usage. To understand whether the loopintroduces a vulnerability, observe that while(C)doScan
be rewritten as C?(S;while(C)doS) : skip. Clearly, the
resource usage of the else branch is 0, and since Δ
/prime/followsequalΔ, the
resource usage of the then branch is precisely Δ⊕Δ/prime=Δ/prime.
Thus, the loop has a vulnerability if η/supersetsqequalH andΔ/prime=∞.
IV . D ESIGN AND IMPLEMENTATION OF SCANNER
A.SCANNER Basics
SCANNER analyzes PHP applications and detects two spe-
ciﬁc kinds of vulnerabilities involving time and response-
size. Speciﬁcally, timing side channel vulnerabilities allow
Detection
moduleDiagnosticmodule
ExploitgeneratorLeaked
database
attributes
Javascript
exploitSCANNER
Fig. 5. Workﬂow of the S CANNER tool
the attacker to infer conﬁdential data by observing server
response times. In contrast, response-size side channels enable
the attacker to glean secret information by observing the size
of the response.
The workﬂow of the S CANNER tool is shown in Figure 5.
Internally, the S CANNER tool consists of three different mod-
ules that perform complementary tasks:
•The detection module performs static analysis to ﬂag po-
tential asymptotic timing and response-size side-channelvulnerabilities. In essence, this module implements an in-stantiation of the algorithm described from Section III fortwo speciﬁc resource types.
•The error diagnostic module performs additional static anal-
ysis to report descriptive warnings. In particular, this module
identiﬁes conﬁdential database ﬁelds that may be leaked by
the application due to the uncovered vulnerabilities.
•The exploit generation module performs backwards sym-
bolic execution to semi-automatically generate a Javascriptprogram that can be used to exploit the uncovered vulnera-bility using a cross-site search attack.
S
CANNER is itself written in PHP and consists of ∼5,000
lines of code. Our implementation uses the Z3 SMT solver [18]to solve the constraints collected during its symbolic executionphase for semi-automated exploit generation.
B. Detection Module
S
CANNER ’s detection module extends the static analysis
described in Section III in two important ways: First, since
PHP programs are not annotated with source and consume
statements, we must reason about taint introduction and re-moval as well as resource consumption at the level of PHPstatements. Second, our implementation is interprocedural andmust deal with object-oriented features of the PHP language.
Annotations. To use S
CANNER , web developers need to
annotate database ﬁelds that are considered to be conﬁdential.
In particular, rather than directly annotating the source code,
SCANNER users need to provide a separate ﬁle containing the
security-sensitive attributes of each database table.
T aint sources. Our implementation considers two kinds of
taint sources, namely, user inputs and database operations.
User inputs are taint sources with label Land correspond to
reads from pre-deﬁned PHP arrays, such as GET, POST, and
SESSION. In contrast, taint sources with label Hcorrespond
to database queries that retrieve private data from a database.
Given a list of conﬁdential database attributes, S CANNER
automatically infers whether or not a given SELECT statement
is a taint source.
233
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. Sanitization. Recall that asymptotic resource side-channel at-
tacks take advantage of the fact that the attacker can arbitrarily
inﬂate resource usage by providing sufﬁciently large inputs.Hence, if the application sanitizes user input by bounding its
size to a small value, then the attacker can no longer inﬂate
resource usage. In our implementation, we consider checksthat impose an upper bound on string length to be sanitizers.
Similarly, string operations (e.g., substr) that limit the size
of the resulting string are also considered to be sanitizers.
Resource consumption. In our implementation, consume state-
ments from our formalization are instantiated in different ways
depending on the type of side-channel vulnerability. For timingvulnerabilities, we consider every instruction to consume oneunit of resource; hence, resource usage only becomes ∞if a
loop bound is tainted by user input. For response-size vulnera-bilities, resource consumption corresponds to print statements.For instance, the resource usage of a statement echo $foo is
∞iffoo is tainted by user input, but has unit cost otherwise.
Interprocedural analysis. Even though we omit function calls
from the formalization, our implementation is interproceduraland detects vulnerabilities that arise due to interactions be-
tween different functions. Speciﬁcally, our analysis computes
function summaries of the form (Γ,Γ
/prime,Δ), whereΓis the
input taint environment, Γ/primeis the output taint environment,
andΔrepresents resource usage of the procedure. The input
and output taint environments used in the summary for fonly
mention memory locations that are accessible in f; hence,
these summaries are re-usable. That is, if we analyze functionfunder the same input environment Γ, we can reuse its
summary rather than re-analyzing the implementation of f.
C. Error Diagnostic Module
The static analysis described so far only allows S
CANNER
to detect the existence of a possible side-channel vulnerability.
To help the user understand the severity and implications ofthe uncovered vulnerability, S
CANNER performs an additional
static analysis. Speciﬁcally, S CANNER ’serror diagnostic mod-
uleoutputs the set of conﬁdential database attributes that may
be leaked by the application. For instance, if S CANNER ’s out-
put includes Employees.Age, this means that the attacker
can infer something about the age an employee stored in theEmployees database table.
To provide such diagnostic information, S
CANNER performs
a backwards static analysis that utilizes the information pro-duced by the vulnerability detection module. Speciﬁcally, theinput to the error diagnostic module is the predicate of a
conditional branch along which there is a resource usage
imbalance. Given such a predicate C,S
CANNER then collects
all secret-tainted variables used in Cand performs backwards
symbolic execution to trace each variable vto the database
query that caused vto become tainted. Conﬁdential database
attributes that are mentioned in the WHERE clause of the query
are then reported as being potentially leaked.
D. Exploit Generation Module
To further help programmers understand and assess the
detected vulnerability, S CANNER also generates a Javascriptprogram that can be used to launch a cross-site search attack
to exploit the vulnerability. We ﬁrst provide some relevantbackground on cross-site search attacks, and we then explainhow S
CANNER semi-automatically generates attack scripts.
Adversary model and XS Search attacks. Recent work has
shown that cross-site search attacks can effectively exploit
side-channel vulnerabilities in web applications [21]. XS-Search attacks require a very weak adversary model in whichthe attacker runs a malicious website but does not have man-in-the-middle or eavesdropping capabilities.
In this scenario, the attacker ﬁrst tricks an unsuspecting user
into executing a malicious script, for instance, by visiting the
attacker’s website or clicking on a link in a phishing emailmessage. Now, the malicious script automatically submitsa cross-site request with the user’s legitimate credentials.Since web browsers allow a script to implement handlers for
events triggered by cross-site requests, the malicious script canperform resource usage (e.g., timing) measurements between
events and send this information back to the attacker.
4Hence,
if the underlying website contains a side-channel vulnerability,
then the attacker can glean conﬁdential information about thevictim by inﬂating certain parameters used in a database query.
Backwards symbolic execution. The goal of S
CANNER ’s ex-
ploit generation module is to (semi-automatically) synthesize
Javascript programs that trigger the vulnerable component
of the web application. In particular, because the vulnerablecomponent may only be triggered under certain values ofthe URL parameters, our goal is to generate low inputs thatexercise the vulnerable functionality.
Towards this goal, S
CANNER starts from the vulnerable
component Cand performs backwards symbolic execution to
collect all path constraints that are necessary for the executionto reachC. The output of the symbolic execution engine is an
SMT formula φsuch that a satisfying assignment to φyields
concrete values of the URL parameters that are sufﬁcient to
trigger the vulnerable functionality.
We emphasize that S
CANNER ’s support for generating
exploits is only semi-automatic: While our analysis infers
the exact URL parameters needed to trigger the vulnerable
functionality, the high inputs are merely placeholders that mustbe inﬂated by the user to amplify resource usage.
V. E
V ALUATION
We evaluate S CANNER by analyzing 10 widely-used open-
source PHP applications. These applications include Word-Press and Joomla (content management systems), OpenClinic(a medical records system), Gallery (a web-based photo al-bum organizer), OpenCart, ZeusCart, and osCommerce (e-commerce), WeBid (an online auction software), and HotCRPand OpenConf (conference management systems). Some ofthese applications contain information that is clearly security-sensitive, such as medical records, account balances, and
4Observe that response-size side-channels can also be exploited using
timing measurements since response parsing times are dependent on the
response size.
234
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. TABLE I
SUMMARY OF OUR EXPERIMENTAL RESULTS .
Application Lines Files Functions Number Timing Response Size False Lines of Analysis
of Code of Callsites Vulnerabilities Vulnerabilities Positives Annotations Time (min:sec)
OpenConf 24,581 133 152 4,493 0 0 0 39 1:52
OpenClinic 30,849 180 526 6,766 0 2 0 27 1:09
WeBid 48,753 336 652 8,042 1 1 0 53 4:01
HotCRP 57,799 125 2,540 18,367 0 3 1 32 3:47
Joomla 59,820 2,563 14,259 124,894 0 2 0 22 5:11
Gallery 62,699 505 1,959 16,027 0 0 0 13 8:26
osCommerce 86,663 702 195 22,273 0 0 0 53 10:13
OpenCart 156,322 1,014 3,717 53,010 1 0 0 98 27:48
ZeusCart 166,400 612 8,798 23,354 5 0 0 44 31:06
Wordpress 298,643 577 5,866 60,717 0 3 1 15 49:57
Total 992,529 6,747 38,664 337,943 7 11 2 396 143:30
TABLE II
INFORMATION INFERRED BY THE ATTACKER
Application ID Information Leaked
OpenClinic 1 Does X have a medical record?
OpenClinic 2 Has X been prescribed medication Y?
WeBid 3 Does X have product Y on their watchlist?
WeBid 4 IsX bidding on product Y?
OpenCart 5 Has X bought downloadable product Y?
ZeusCart 6 Has X bought downloadable product Y?
ZeusCart 7 Does X have an order with amount Y?
ZeusCart 8 Has X bought anything between dates X and Y?
ZeusCart 9 Does X’s order Y have processing status Z ?
ZeusCart 10 IsY the account status for user X?
HotCRP 11 IsX an author of a submitted paper?
HotCRP 12 IsX the title of a submitted paper?
HotCRP 13 IsZ the abstract of a submitted paper?
Wordpress 14 Has X sent a private comment to the admin?
Wordpress 15 IsX the e-mail of a commentator in a post?
Wordpress 16 IsX the private comment sent to the admin?
Joomla 17 Has X authored a private article?
Joomla 18 IsX the title of a private article?
purchase histories. Some of the applications we analyzed also
provide well-documented privacy guarantees for informationthat may be considered security-sensitive. For example, Word-
press explicitly states that email addresses of users will not be
disclosed.
We run our experiments on a server laptop with Ubuntu
14.04, a dual-core 2 GHz processor, 8 GB of RAM, and theApache 2.4.18 web server, connected to a campus wireless
network. The client is a desktop machine running Ubuntu14.04, with a dual-core 3 GHz processor, 8 GB of RAM, and
the Firefox browser (version 44.0).
A. Overview of Results
Table I gives statistics about the analyzed programs and
summarizes the results of our evaluation. As shown in Ta-
ble I, the analyzed programs are quite large and containbetween 24K and 298K lines of code. S
CANNER ’s running
time on these applications is quite reasonable, with the largest
application taking 49 minutes to analyze. Most importantly,
SCANNER reports a total of 20 vulnerabilities, 18 of which
are indeed exploitable. Among the vulnerabilities uncoveredTABLE III
SUMMARY OF TIMING RESULTS FOR POSITIVE AND NEGATIVE QUERIES .
TIMES ARE IN MILLISECONDS .
ID Positive Query Negative Query
Avg Time Std Dev Avg Time Std Dev
1 1,523.71 64.85 2,020.32 137.60
2 1,655.69 29.84 2,358.24 119.24
3 96.27 10.23 513.35 22.67
4 2,593.63 113.80 1,225.34 18.47
5 265.13 16.21 29.27 4.44
6 329.26 14.68 32.61 8.85
7 4,241.29 821.32 630.82 80.96
8 4,580.50 121.90 668.72 62.65
9 4,616.64 130.10 676.79 99.84
10 3,740.37 468.63 798.55 64.92
11 1,612.79 204.89 343.49 167.43
12 1,758.41 93.46 271.01 17.87
13 2,000.76 318.38 317.93 64.06
14 839.20 56.08 502.07 43.62
15 801.15 15.35 483.67 64.28
16 796.30 37.07 467.50 30.85
17 1,172.84 243.14 486.17 27.92
18 1,090.41 135.98 488.25 47.94
by S CANNER , 7 are timing side-channel vulnerabilities, and
the rest are response-size side channels.
Table II summarizes the information that the attacker can
learn by exploiting the underlying vulnerabilities uncovered
by S CANNER . The leaked information is in the form of
yes/no queries. However, we emphasize that the underlying
vulnerabilities actually allow an attacker to infer lage parts ofa database table by using these binary conditions as an oracle.For example, the vulnerability in OpenClinic can be exploited
to infer all medications prescribed to a user. Similarly, an
attacker can the use the vulnerability in OpenCart to learnall e-books purchased by a user or the vulnerability in WeBidto infer all bids of a user. Hence, these programs violate multi-run security [9].
B. Exploiting Vulnerabilities by Measuring Response Times
We now describe how the vulnerabilities uncovered by
S
CANNER can be exploited to infer the information listed in
Table II. Since we do not assume that the attacker has man-in-
235
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. the-middle capabilities, we use cross-site search attacks5to
exploit these vulnerabilities (although it may also be possible
to exploit these vulnerabilities using other means). Note thataccording to our adversary model, the attacker is not ableto directly measure the exact size of the server’s response.Instead, he could perform time measurement through thevictim’s browser to indirectly infer the response size, sincelonger responses generally takes more time to load. As a result,both time and response size side channel of a web applicationcan be exploited by measuring server response times on theclient side.
Table III shows server response times when the answer
to the queries listed in Table II is positive and negative,
respectively. Since each of the vulnerabilities is caused by anasymptotic imbalance in resource usage, wecan amplify the
difference between positive and negative queries by supplying
artiﬁcally inﬂated search queries (e.g., a query containing avery large search string). The average and standard deviationmetrics in this table correspond to the collection of 100samples, with URL request sizes of at most 90K characters.
As we can see from the data in Table III, the response
times vary signiﬁcantly for positive and negative queries. Forinstance, OpenCart has an average response time of 265 ms ifuserXhas bought product Ybut 29 ms otherwise. Similarly,
WeBid has a response time of 2594 ms vs.1225 ms, depending
on whether user Xis bidding on product Y. Since response
times vary signiﬁcantly for all the queries from Table II, it ispossible for an attacker to exploit the vulnerabilities uncoveredby S
CANNER .
In the next two subsections, we describe in detail two
representative vulnerabilities uncovered by S CANNER .
C. Response-size Side-Channel in OpenClinic
Our ﬁrst example is a response-size side-channel vulnera-
bility found in OpenClinic, which is an open-source medicalrecords system. This vulnerability reveals information aboutwhether a patient has a medical record in the system.
Description of vulnerability. The OpenClinic application con-
tains a medical record search page, which allows authorized
users to search for medical records matching a given querystring. The important point is that logical connectives areallowed to be included in the query string, and if the con-nective is set to “OR”, then the database query will returnall rows for which the patient name matches any of the
keywords in the search string. If the table does not con-tain patients matching the query, then the application printsNo results found for X, where Xis the search string
provided by the user. On the other hand, if there is a recordmatching the query, then the application displays the patient’s
record, whose length is independent of the search string.Therefore, one can learn whether the patient has a medicalrecord or not by simply observing whether the response size
is linear or constant with respect to the input string.
5Please see Section IV-D for background on cross-site search attacks.Note that the attacker cannot directly see the patient’s record
since (a) he does not have access to the user’s credentials, and(b) the same-original policy (SOP) prevents scripts containedin the attacker’s website from directly accessing data inOpenClinic. However, since the attacker can perform timemeasurements in the victim’s browser, he can observe thedifferences in time to infer the differences in response size.
Sample exploit. The attacker could inﬂate the query string by
appending a long sufﬁx (e.g., “aaaaaaaa...”) after the patient
of interest using the “OR” connective. If the patient name isin the database, the query will succeed and a short responsewill be returned. Otherwise, since the query string has beenintentionally inﬂated by the attacker and also reﬂected by theserver, the attacker can tell that a negative answer to the querywill be associated with a much longer response length.
Possible ﬁx. It is easy to ﬁx the vulnerability in this code by
not including the search string in the response message. For
instance, the code would no longer be vulnerable if the serveralways responded “No results found for user” if the queriedpatient were not found. Alternatively, the code could sanitizethe search keyword by ensuring that it does not contain more
than a certain number of characters.
D. Timing Side-Channel in ZeusCart
Our second example is a timing side-channel vulnerability
that S
CANNER found in the ZeusCart e-commerce system.
Description of vulnerability. At a high level, ZeusCart allows
a user with the right credentials to search order histories,
which may include information like customer name, order ID,and the corresponding order status. If there is no matchingpurchase, the user quickly gets an empty results table in
constant time. Otherwise, the application performs additionalsanitization over the input whose running time is linear in the
size of the query string. Since there is a signiﬁcant differencein response times depending on whether a user has a speciﬁcorder status, an attacker who does not have login credentials
can infer the existence of speciﬁc purchases by speciﬁc users
by performing timing measurements in the victim’s browser.
Sample exploit. Since the query string is controlled by the
user, the attacker can inﬂate one of the query parameters
to amplify the running time. For instance, the attacker mayappend many white spaces to the user name parameter, andin cases where there is a matching purchase, the attackercan observe a signiﬁcant increase in running time of theapplication. Speciﬁcally, as shown in Table III, positive queriestake 3740ms on average, while negative queries take 799ms.
Possible ﬁx. One possible ﬁx for this vulnerability is to sanitize
the query string by ensuring that it does not exceed a certain
number of characters. This modiﬁcation would ensure that theresponse time is bounded by a constant.
E. Threats to V alidity
Timing Measurement. In our evaluation, we use a speciﬁc
machine and network environment when conducting timing
measurements for positive and negative queries. Of course,
236
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. these measurements could be substantially different if the
exploits were executed on other platforms. However, becausethe resource usage imbalances detected by S
CANNER are
always asymptotic, it is possible for the attacker to further
inﬂate the resource imbalance by providing even larger inputs.
Application Selection. Another threat to validity is that we
evaluate our technique on 10 PHP applications; hence, our
benchmarks may not be representative of many other real-world PHP applications. Nevertheless, we believe these ap-plications constitute a good test-bed for our approach: Many
of the projects we picked (e.g. Wordpress, Joomla) are well-
known popular web applications with thousands of stars onGithub, and their security has been widely audited by the open-source community.
VI. P
OSSIBLE DEFENSES AGAINST ASYMPTOTIC
RESOURCE SIDECHANNEL VULNERABILITIES
The most straightforward way to eliminate the class of
vulnerabilities discussed in the paper is to ensure that theattacker cannot inﬂate the resource usage imbalance between
two execution paths that differ in the value of the secret. One
simple way to achieve this goal is to sanitize user input bychecking that its size cannot exceed some small, reasonablebound. Another (perhaps more robust) ﬁx is to eliminate theasymptotic dependence on user input whenever possible. Forinstance, in the case of vulnerabilities that concern responsesize, a good rule of thumb is to make sure that the responsedoes not contain the entire user input.
If the vulnerability occurs in a component that requires user
or adminisrator credentials, another way to mitigate the vulner-ability is to disallow cross-site read requests or employ anti-
CSRF mechanisms. However, it is unrealistic to completely
disallow cross-site read requests in many cases, and anti-CSRFdefenses are typically only deployed against state-changingrequests. Furthermore, even in the presence of anti-CSRFdefenses, a response-size side channel still allows an attackerwith trafﬁc-monitoring capabilities to launch de-anonimization
attacks and perform some sensitive data inference[43].
VII. L
IMITATIONS OF OUR APPROACH
SCANNER comes with a number of limitations that may
result in both false positives as well as false negatives. First,the taint analyses described in Section III and implemented
in S
CANNER only propagate explicit ﬂows (i.e. taint is only
propagated due to assignments). Hence, our analysis can misssome resource side-channel vulnerabilities that arise due to
implicit ﬂows. For instance, consider the following function:
void foo(int input) {
i n tc=0 ;i f(secret)c=1 ;
if(c) consume(input); else consume(1); }
This code has an asymptotic side-channel vulnerability since
the resource usage is constant in one branch but user-controlledin the other one. However, S
CANNER will not report this
vulnerability because there is no explicit ﬂow from secret
toc. This limitation can be circumvented by tracking implicit
ﬂows, albeit at the risk of introducing more false positives.Second, many of the vulnerabilities uncovered by S CANNER
are exploited using XS search attacks (recall Section IV-D).
However, if the application employs anti-CSRF mechanismsand the vulnerable component requires log-in credentials, thenthe reported vulnerabilities may not be exploitable using XSsearch attacks. In fact, the false positives reported in Table Iare both caused by S
CANNER ’s inability to reason about anti-
CSRF measures.
Third, our analysis only detects a subclass of resource side-
channel vulnerabilities where the resource usage is constant in
one execution path but dependent on the user input in anotherexecution path (recall Deﬁnition 3). However, it is nonethelesspossible to exploit a constant, but very large, imbalance inresource usage. The techniques presented in this paper do notaddress such vulnerabilities.
VIII. R
ELATED WORK
Static analysis for web security. There has been much previous
work on static analysis for web security. Most of thesetechniques focus on automated detection of XSS and SQLinjection vulnerabilities [31], [44], [46], [28], [4], [45], [33].Dahse and Holz also consider second-order XSS and SQLi
vulnerabilities and propose a static analysis for automatically
ﬁnding them [17]. In constrast to these approaches, our workfocuses on identifying privacy vulnerabilities caused by anobservable resource usage imbalance in the program.
Side channels in web applications. While side-channel leaks
have been known for decades, the ﬁrst thorough study of side-
channel leaks in web applications is presented by Chen etal [15]. Subsequent works include Chapman and Evans’ black-box testing [14], which is a pure dynamic analysis, and Side-buster [48], which uses a hybrid of static and dynamic analysis.Our approach differs from them in several ways: First, whilethose tools detects privacy leaks caused by an imbalance in thenumber of requests exchanged between a client and the server,it does not reason about side-channel leaks originating fromindividual requests. Second, the vulnerabilities discovered bythe aforementioned tools can only be exploited by an attackerwho is able to sniff network trafﬁc, which requires the attackerto be in the same network path as the victim. In contrast, ourapproach detects vulnerabilities that can be exploited remotelythrough cross-site search attacks.
W eb timing attacks. Felten and Schneider present one of the
ﬁrst case studies on web timing attacks [20]. In later work,
Brumley and Boneh show how to extract private keys fromweb servers running OpenSSL using timing attacks [11]. Bortzand Boneh describe web timing attacks in which they obtainvalid usernames and items in users’ shopping carts [10].
In more recent work, Gelernter and Herzberg introduce
cross-site search attacks as a mechanism for exploiting side-
channel vulnerabilities [21]. Van Goethem et al. show how toexploit multimedia tags in HTML5 to estimate response sizesduring web timing attacks[42]. Recently, Van Goethem et al.have shown how a weakness in the Quota Management API inJavascript can be used to infer response sizes at the byte level
237
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. of granularity, allowing an attacker to de-anonimize Twitter
users and obtain medical information from WebMD[43]. Inthis work, we use known attack techniques (speciﬁcally, [21],[42]) to assess the severity of the vulnerabilities uncoveredby our approach. However, we emphasize that our workaims to detect application-speciﬁc vulnerabilities rather thandescribing a new class of web timing attacks.
Analysis for side-channel vulnerabilities. There has been sig-
niﬁcant research effort on verifying non-interference, includ-
ing techniques based on self-composition [8], product pro-
grams [7], [41], and Cartesian Hoare Logic [40]. In contrast to
these techniques, our approach focuses on asymptotic resourceside-channel vulnerabilities and detects them using lightweightstatic analysis rather than heavy-weight veriﬁcation techniquesthat require the inference of precise loop invariants.
Pasareanu et al. have recently proposed a symbolic exe-
cution technique for generating inputs that maximize differ-ences in timing and memory usage between multiple programruns [37]. Their technique does not differentiate betweenconstant and asymptotic differences, and their evaluation isperformed on small programs (e.g., modular exponentiation)rather than large-scale web applications.
Another related approach is CacheAudit [19], which ana-
lyzes x86 binaries with a given cache conﬁguration. CacheAu-dit computes an overapproximation of the number of bitsleaked by the application on a simpliﬁed machine model. Theirprimary focus is hardware-level cache adversaries, whosecapabilities do not align with those of application-level webadversaries. For instance, it is easier for web adversaries toexploit multi-run vulnerabilities [9], while it is harder for themto measure nanosecond-level timing differences.
Language-based information ﬂow. There is a large body
of work on language-based solutions for ﬁnding violations
of the non-interference principle and quantifying informationleak [3], [16], [35], [32]. However, these techniques do notdetect privacy vulnerabilities due to convert channels, such astiming or response size.
Zhang et al. [47] propose a language-based approach for
tracking side-channel leakage. Their approach requires the
program to be written in their proposed language, whereas our
goal is to analyze existing web applications. Barthe et al. [6]propose a type-based solution to verify the absense of side-channels, but their technique is tailored towards cryptographicimplementations and simply rejects programs that do not
execute in constant time.
T aint analysis. A common approach for tracking informa-
tion ﬂow in existing applications is to use taint analysis.
Hence, there is a large body of work on taint analysis forlanguages like Java (e.g. FlowDroid [2]) and C++ (e.g. Flow-Tracker [38]). While our work leverages taint information,our main contribution is an algorithm for statically identifying
asymptotic resource side channels. Our implementation doesnot leverage mature taint analysis tools like FlowDroid, as wetarget web applications written in PHP.Multi-run security. The amount of information that is leaked
due to a side channel vulnerability is often related to the
adversary’s ability to aggregate secret information across mul-tiple executions. K ¨opf and Basin [30] develop an information-
theoretical model that quantiﬁes information leakage involvingmultiple adaptive interactions between the victim and theadversary. Birgisson and Sabelfeld [9] propose an alternativemodel based on knowledge sets and show how to enforce 1-bit multirun security. Pasareanu et al. [37], [5] use symbolicexecution and model counting to compute single-run informa-tion leakage bounds and reason about kruns o by applying
their single-run technique to the k-composition of the original
program. While our analysis does not quantify leakage, thevulnerabilities uncovered by S
CANNER in our evaluation can
be exploited to infer signiﬁcant chunks of a database (seeSection V-A). We leave it to future work to develop analysesthat can quantify information leakage through asymptotic side
channels across multiple program runs.
Static analysis for resource usage. There is a signiﬁcant body
of work on static analysis for determing worst-case resource
usage of programs [25], [24], [26], [12], [36], [1], [27], [13].
However, many of these analyses are quite heavyweight anddo not address privacy implications of resource usage. Sincethe focus of our paper is detecting asymptotic resource side-
channels, we can effectively detect security vulnerabilities
using a lightweight program abstraction that combines taintinformation with a coarse summary of resource usage.
IX. C
ONCLUSIONS
In this paper, we introduced asymptotic resource side chan-
nels and described a static analysis for detecting them. Our
method uses an effective, but lightweight program abstraction
that combines taint information with a summary of resource
usage. We have used our tool S CANNER to analyze 10 open-
source PHP applications and found 18 exploitable securityvulnerabilities. We believe that S
CANNER can help web appli-
cation developers by automatically uncovering easy-to-exploit
vulnerabilities in their applications.
Acknowledgement. This material is based on research spon-
sored by DARPA award FA8750-15-2-0096 as well as NSF
Award CCF-1712067. The U.S. Government is authorized toreproduce and distribute reprints for Governmental purposesnotwithstanding any copyright notation thereon. The viewsand conclusions contained herein are those of the authorsand should not be interpreted as necessarily representing theofﬁcial policies or endorsements, either expressed or implied,of the U.S. Government.
R
EFERENCES
[1] E. Albert, P. Arenas, S. Genaim, G. Puebla, and D. Zanardini, “Cost
analysis of java bytecode,” in European Symposium on Programming .
Springer, 2007, pp. 157–172.
[2] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel, J. Klein, Y . L.
Traon, D. Octeau, and P. D. McDaniel, “Flowdroid: precise context,
ﬂow, ﬁeld, object-sensitive and lifecycle-aware taint analysis for androidapps,” in Proceedings of the 35th ACM SIGPLAN Conference on
Programming Language Design and Implementation. ACM, 2014, pp.259–269.
238
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. [3] M. Backes, B. K ¨opf, and A. Rybalchenko, “Automatic discovery and
quantiﬁcation of information leaks,” in Symposium on Security and
Privacy. IEEE Computer Society, 2009, pp. 141–153.
[4] D. Balzarotti, M. Cova, V . Felmetsger, N. Jovanovic, E. Kirda,
C. Kruegel, and G. Vigna, “Saner: Composing static and dynamic
analysis to validate sanitization in web applications,” in Symposium on
Security and Privacy. IEEE, 2008, pp. 387–401.
[5] L. Bang, A. Aydin, Q.-S. Phan, C. S. P ˘as˘areanu, and T. Bultan, “String
analysis for side channels with segmented oracles,” in Proceedings of
the 2016 24th ACM SIGSOFT International Symposium on F oundationsof Software Engineering, ser. FSE 2016. ACM, 2016, pp. 193–204.
[6] G. Barthe, G. Betarte, J. Campo, C. Luna, and D. Pichardie, “System-
level non-interference for constant-time cryptography,” in Proceedings of
the 2014 ACM SIGSAC Conference on Computer and CommunicationsSecurity, ser. CCS ’14. ACM, 2014, pp. 1267–1279.
[7] G. Barthe, J. M. Crespo, and C. Kunz, “Relational veriﬁcation using
product programs,” in FM 2011: F ormal Methods. Springer, 2011, pp.
200–214.
[8] G. Barthe, P. R. D’Argenio, and T. Rezk, “Secure information ﬂow by
self-composition,” in Computer Security F oundations Workshop, 2004.
Proceedings. 17th IEEE. IEEE, 2004, pp. 100–114.
[9] A. Birgisson and A. Sabelfeld, “Multi-run security,” in European Sympo-
sium on Research in Computer Security. Springer, 2011, pp. 372–391.
[10] A. Bortz and D. Boneh, “Exposing private information by timing web
applications,” in World Wide Web. ACM, 2007, pp. 621–628.
[11] D. Brumley and D. Boneh, “Remote timing attacks are practical,” in
USENIX Security Symposium. USENIX Association, 2003.
[12] Q. Carbonneaux, J. Hoffmann, and Z. Shao, “Compositional certiﬁed
resource bounds,” in Proceedings of the 36th ACM SIGPLAN Conference
on Programming Language Design and Implementation. ACM, 2015,pp. 467–478.
[13] E. C ¸i c¸ek, G. Barthe, M. Gaboardi, D. Garg, and J. Hoffmann, “Relational
cost analysis,” in Proceedings of the 44th ACM SIGPLAN Symposium on
Principles of Programming Languages, ser. POPL 2017. ACM, 2017,
pp. 316–329.
[14] P. Chapman and D. Evans, “Automated black-box detection of side-
channel vulnerabilities in web applications,” in Proceedings of the 18th
ACM Conference on Computer and Communications Security, ser. CCS
’11. ACM, 2011, pp. 263–274.
[15] S. Chen, R. Wang, X. Wang, and K. Zhang, “Side-channel leaks in web
applications: A reality today, a challenge tomorrow,” in Symposium on
Security and Privacy. IEEE Computer Society, 2010, pp. 191–206.
[16] D. Clark, S. Hunt, and P. Malacaria, “A static analysis for quantifying
information ﬂow in a simple imperative language,” J. Comput. Secur .,
vol. 15, no. 3, pp. 321–371, 2007.
[17] J. Dahse and T. Holz, “Static detection of second-order vulnerabilities
in web applications,” in USENIX Security Symposium. USENIX
Association, 2014, pp. 989–1003.
[18] L. De Moura and N. Bjørner, “Z3: An efﬁcient smt solver,” in Tools and
Algorithms for the Construction and Analysis of Systems. Springer,
2008, pp. 337–340.
[19] G. Doychev, D. Feld, B. Kopf, L. Mauborgne, and J. Reineke, “Cacheau-
dit: A tool for the static analysis of cache side channels,” in Presented
as part of the 22nd USENIX Security Symposium (USENIX Security 13).
USENIX, 2013, pp. 431–446.
[20] E. W. Felten and M. A. Schneider, “Timing attacks on web privacy,” in
Computer and Communications Security. ACM, 2000, pp. 25–32.
[21] N. Gelernter and A. Herzberg, “Cross-site search attacks,” in Pro-
ceedings of the 22nd ACM SIGSAC Conference on Computer and
Communications Security.
 ACM, 2015, pp. 1394–1405.
[22] D. Genkin, I. Pipman, and E. Tromer, “Get your hands off my laptop:
Physical side-channel key-extraction attacks on pcs,” in Proceedings of
the 16th Cryptographic Hardware and Embedded Systems - Interna-tional Workshop, 2014, pp. 242–260.
[23] J. Goguen and M. Jose, “Security policies and security models,” in
Symposium on Security and Privacy. IEEE Computer Society Press,
1982, pp. 11–20.
[24] S. Gulwani, “Speed: Symbolic complexity bound analysis,” in Computer
Aided V eriﬁcation. Springer, 2009, pp. 51–62.
[25] S. Gulwani, K. K. Mehra, and T. Chilimbi, “Speed: precise and efﬁ-
cient static estimation of program computational complexity,” in ACM
SIGPLAN Notices, vol. 44, no. 1. ACM, 2009, pp. 127–139.[26] J. Hoffmann, K. Aehlig, and M. Hofmann, “Multivariate amortized
resource analysis,” in ACM SIGPLAN Notices, vol. 46, no. 1. ACM,
2011, pp. 357–370.
[27] J. Hoffmann, A. Das, and S.-C. Weng, “Towards automatic resource
bound analysis for ocaml,” in Proceedings of the 44th ACM SIGPLAN
Symposium on Principles of Programming Languages, ser. POPL 2017.
ACM, 2017, pp. 359–373.
[28] N. Jovanovic, C. Kruegel, and E. Kirda, “Pixy: A static analysis tool
for detecting web application vulnerabilities,” in 2006 IEEE Symposium
on Security and Privacy (S&P’06). IEEE, 2006, pp. 6–pp.
[29] P. C. Kocher, “Timing attacks on implementations of difﬁe-hellman, rsa,
dss, and other systems,” in Advances in Cryptology. Springer-Verlag,
1996, pp. 104–113.
[30] B. K ¨opf and D. Basin, “An information-theoretic model for adaptive
side-channel attacks,” in Proceedings of the 14th ACM Conference on
Computer and Communications Security, ser. CCS ’07. New York, NY ,USA: ACM, 2007, pp. 286–296.
[31] V . B. Livshits and M. S. Lam, “Finding security vulnerabilities in java
applications with static analysis,” in USENIX Security Symposium, 2005.
[32] P. Malacaria, “Assessing security threats of looping constructs,” in
Principles of Programming Languages. ACM, 2007, pp. 225–235.
[33] M. C. Martin, V . B. Livshits, and M. S. Lam, “Finding application errors
and security ﬂaws using PQL: a program query language,” in OOPSLA.
ACM, 2005, pp. 365–383.
[34] T. D. Morgan and J. W. Morgan, “Web timing attacks made practical,”
Black Hat, 2015.
[35] A. C. Myers, L. Zheng, S. Zdancewic, S. Chong, and N. Nystrom,
“Jif: Java information ﬂow,” Software release. Located at http://www.
cs. cornell. edu/jif, vol. 2005, 2001.
[36] J. Navas, M. M ´endez-Lojo, and M. V . Hermenegildo, “User-deﬁnable
resource usage bounds analysis for java bytecode,” Electronic Notes in
Theoretical Computer Science, vol. 253, no. 5, pp. 65–82, 2009.
[37] C. Pasareanu, Q.-S. Phan, and P. Malacaria, “Multi-run side-channel
analysis using symbolic execution and max-smt,” in Computer Security
F oundations Symposium. IEEE, 2016.
[38] B. Rodrigues, F. M. Quint ˜ao Pereira, and D. F. Aranha, “Sparse
representation of implicit ﬂows with applications to side-channel detec-
tion,” in Proceedings of the 25th International Conference on Compiler
Construction, ser. CC 2016. ACM, 2016, pp. 110–120.
[39] A. Sabelfeld and A. C. Myers, “Language-based information-ﬂow secu-
rity,” IEEE Journal on selected areas in communications, vol. 21, no. 1,
pp. 5–19, 2003.
[40] M. Sousa and I. Dillig, “Cartesian hoare logic for verifying k-safety
properties,” in Proceedings of the 37th ACM SIGPLAN Conference on
Programming Language Design and Implementation, ser. PLDI ’16.ACM, 2016, pp. 57–69.
[41] T. Terauchi and A. Aiken, “Secure information ﬂow as a safety problem,”
inInternational
 Conference on Static Analysis. Springer-Verlag, 2005,
pp. 352–367.
[42] T. Van Goethem, W. Joosen, and N. Nikiforakis, “The clock is still
ticking: Timing attacks in the modern web,” in Computer and Commu-
nications Security. ACM, 2015, pp. 1382–1393.
[43] T. Van Goethem, M. Vanhoef, F. Piessens, and W. Joosen, “Request
and conquer: Exposing cross-origin resource size,” in USENIX Security
Symposium. USENIX Association, 2016, pp. 447–462.
[44] G. Wasserman and Z. Su, “Static detection of cross-site scripting
vulnerabilities,” in Proceedings of the 30th International Conference on
Software Engineering, 2008.
[45] G. Wassermann and Z. Su, “Sound and precise analysis of web appli-
cations for injection vulnerabilities,” in PLDI. ACM, 2007, pp. 32–41.
[46] Y . Xie and A. Aiken, “Static detection of security vulnerabilities in
scripting languages,” in Usenix Security, 2006.
[47] D. Zhang, A. Askarov, and A. C. Myers, “Language-based control
and mitigation of timing channels,” in Proceedings of the 33rd ACM
SIGPLAN Conference on Programming Language Design and Imple-
mentation, ser. PLDI ’12. ACM, 2012, pp. 99–110.
[48] K. Zhang, Z. Li, R. Wang, X. Wang, and S. Chen, “Sidebuster:
Automated detection and quantiﬁcation of side-channel leaks in webapplication development,” in Computer and Communications Security.
ACM, 2010, pp. 595–606.
239
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. 