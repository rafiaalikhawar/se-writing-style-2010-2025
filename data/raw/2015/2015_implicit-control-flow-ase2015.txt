Static Analysis of Implicit Control Flow:
Resolving Java Reﬂection and Android Intents
Paulo Barros†René JustSuzanne MillsteinPaul Vines
Werner Dietl‡Marcelo d’Amorim†Michael D. Ernst
†Federal University of Pernambuco
Recife, PE, Brazil
{pbsf,damorim}@cin.ufpe.brUniversity of Washington
Seattle, WA, USA
{rjust,smillst,plvines,mernst}@cs.washington.edu‡University of Waterloo
Waterloo, ON, Canada
wdietl@uwaterloo.ca
Abstract —Implicit or indirect control ﬂow is a transfer of
control between procedures using some mechanism other than
an explicit procedure call. Implicit control ﬂow is a staple design
pattern that adds ﬂexibility to system design. However, it is
challenging for a static analysis to compute or verify properties
about a system that uses implicit control ﬂow.
This paper presents static analyses for two types of implicit
control ﬂow that frequently appear in Android apps: Java
reﬂection and Android intents. Our analyses help to resolve where
control ﬂows and what data is passed. This information improves
the precision of downstream analyses, which no longer need to
make conservative assumptions about implicit control ﬂow.
We have implemented our techniques for Java. We enhanced
an existing security analysis with a more precise treatment of
reﬂection and intents. In a case study involving ten real-world
Android apps that use both intents and reﬂection, the precision
of the security analysis was increased on average by two orders
of magnitude. The precision of two other downstream analyses
was also improved.
I. I NTRODUCTION
Programs are easier to understand and analyze when they
use explicit control ﬂow: that is, each procedure call invokes
just one target procedure. However, explicit control ﬂow is
insufﬁciently ﬂexible for many important domains, so implicit
control ﬂow is a common programming paradigm. For example,
in object-oriented dispatch a method call invokes one of multiple
implementations at run time. Another common use of implicit
control ﬂow is in design patterns, many of which add a level of
indirection in order to increase expressiveness. This indirection
often makes the target of a procedure call more difﬁcult to
determine statically.
Implicit control ﬂow is a challenge for program analysis.
When a static analysis encounters a procedure call, the analysis
usually approximates the call’s behavior by a summary, which
conservatively generalizes the effects of any target of the call.
If there is only one possible target (as with a normal procedure
call) or a small number that share a common speciﬁcation (as
with object-oriented dispatch), the summary can be relatively
precise. But if the set of possible targets is large, then a
conservative static analysis must use a very weak speciﬁcation,
causing it to yield an imprecise result.
The imprecision is caused by a lack of information about
possible call targets and about the types of data passed as
arguments at each call. The goal of this paper is to provide
a sound and sufﬁciently precise estimate of potential call
targets and of the encapsulated data communicated in implicit
invocations, in order to improve the precision of downstream
program analyses.
Our evaluation focuses on a particular domain — Android
mobile apps — in which implicit invocation signiﬁcantlydegrades static analysis. In our experience [1], the largest
challenge to analyzing Android apps is their use of reﬂection
and intents, and this led us to our research on resolving implicit
invocation. We are not aware of a previous solution that handles
reﬂection and intents soundly and with high precision.
Reﬂection permits a program to examine and modify its
own data or behavior [2]. Our interest is in use of reﬂection
to invoke procedures. For example, in Java an object mof
type Method represents a method in the running program; m
can be constructed in a variety of ways, including by name
lookup from arbitrary strings. Then, the Java program can
call m.invoke(...) to invoke the method that mrepresents.
Other programming languages provide similar functionality,
including C#, Go, Haskell, JavaScript, ML, Objective-C, PHP,
Perl, Python, R, Ruby, and Scala.
Android intents are the standard inter-component communi-
cation mechanism in Android. They are used for communication
within an app (an app may be made up of dozens of
components), between apps, and with the Android system.
An Android component can send or broadcast intents and can
register interest in receiving intents. The Android architecture
shares similarities with blackboard systems and other message-
passing and distributed systems.
By default, a sound program analysis must treat reﬂection
and intents conservatively — the analysis must assume that
anything could happen at uses of reﬂection and intents, making
its results imprecise. We have built a simple, conservative, and
quite precise static analysis that models the effects of reﬂection
and intents on program behavior. The key idea is to resolve
implicit control and data ﬂow ﬁrst to improve the estimates of
what procedures are being called and what data is being passed;
as a result, those constructs introduce no more imprecision into
a downstream analysis than a regular procedure call does.1
Both control ﬂow and data ﬂow are important. For reﬂection,
our approach handles control ﬂow by analyzing reﬂective calls
to methods and constructors to estimate which classes and
methods may be manipulated, and it handles data ﬂow via
an enhanced constant propagation. For intents, our approach
handles control ﬂow by using previous work [3] to obtain
component communication patterns, and it handles data ﬂow
by analyzing the payloads that are carried by intents.
We have implemented our approach for Java. We evaluated
our implementation on open-source apps, in the context of
three existing analyses, most notably an information ﬂow
type system for Android security [1]. Most Android apps use
reﬂection and/or intents, so accurately handling reﬂection and
1Our approach does not change the program’s operations, either on disk or
in memory in the compiler; see Section III-B.intents is critical in this domain. Unsoundness is unacceptable
because it would lead to security holes, and poor precision
would make the technique unusable due to excessive false-
positive alarms. The reﬂection and intent analyses increased
the precision of the information ﬂow type system by two orders
of magnitude, and they also improved the precision of the other
two analyses. Furthermore, they are easy to use and fast to run.
Our implementation is freely available in the SPARTA toolset
(http://types.cs.washington.edu/sparta/), including source code
and user manual, and the reﬂection analysis is also integrated
into the Checker Framework (http://checkerframework.org/).
The rest of this paper is structured as follows. Section II
presents two motivating examples. Sections III and IV present
our analyses that resolve reﬂection and intents. Section V
formally analyzes the typing rules. Section VI evaluates how
the reﬂection and intent analyses improve the precision of
downstream analyses. Section VII shows how the type inference
rules reduce programmer effort. Section VIII discusses related
work, and Section IX concludes.
II. M OTIVATING EXAMPLES
Our work improves the precision of a downstream static
analysis, by eliminating false positive warnings in cases of
implicit control ﬂows. Imprecision due to implicit control
ﬂow affects every static analysis. For concreteness, consider
a noninterference type system [4], which guarantees that the
program does not leak sensitive data.
The noninterference type system distinguishes high-security-
level values from low-security-level values; for brevity, High
and Lowvalues. The static property checked is that values in
High variables are not assigned to Lowvariables, which would
leak sensitive data. Variables and expressions marked High may
hold a Lowvalue at run time; this is also expressed as Low<:
High, where the symbol “<:” denotes subtyping. To use this
type system, a user annotates each type with High orLow, the
default being Low. The type system is conservative: if it issues
no warnings, then the program has no interference and running
it does not leak any High data to Lowcontexts.
When run on the Android app Aard Dictionary (http://
aarddict.org/), the noninterference type system issues false
positive warnings due to its conservative handling of implicit
control ﬂows. When our reﬂection and intent analyses are
integrated into it, the type system remains sound but no
longer issues the false positive warnings. The examples in
this section use a noninterference type system, but other type
systems suffer similar false positives. Our reﬂection and intent
analyses also help other downstream analyses, as demonstrated
in Section VI-D.
A. Reﬂection
Some calls to Method.invoke return a High value at run time.
Thus, the signature of Method.invoke (line 15 of Figure 1)
must have a High return type; any other return type in the
summary would be unsound. Some calls to Method.invoke always
return a Lowvalue. The conservative signature of Method.invoke
causes false positive warnings in such cases.
Figure 1 illustrates the problem in Aard Dictionary . The
component ArticleViewActivity uses an ActionBar , which is a
feature that was introduced in version 11 of the Android API.
In order to prevent run-time errors for a user who has an older
version of Android (and also to enable the app to compile when1 class ArticleViewActivity extends Activity {
2 void onCreate(Bundle savedInstanceState ) {
3 if (android.os.Build.VERSION.SDK_INT >= 11) {
4 // Android version 11 and later has Action Bar
5 Method getActionBar =
6 getClass ().getMethod (" getActionBar ");
7 @Low Object actionBar = getActionBar .invoke(this);
8 ...
9 }
10 }
11 }
12
13 // Library annotations:
14 class Method {
15 @High Object invoke(Object obj , Object ... args) {...}
16 }
17 class Activity {
18 // Only exists in Android SDK 11 and above.
19 @Low ActionBar getActionBar () {...}
20 }
Fig. 1. A noninterference type-checker produces a false positive warning
on line 7, where the return type of Method.invoke , of type High, is assigned
to variable actionBar which has declared type Low. The call on line 7 always
returns a Lowvalue at run time (even though other calls to invoke may in general
return a High value), so the assignment is safe. When the noninterference type
system is augmented by our reﬂection analysis, it no longer issues the false
positive warning.
a developer is using an older version of the Android API), this
app uses reﬂection to call methods related to the ActionBar . The
noninterference type-checker issues a false positive due to the
use of reﬂection; our reﬂection analysis (Section III) eliminates
the false positive warning.
B. Android intents
An Android component might send a High value via an
intent message to another component; therefore, the summary
for methods that retrieve data from an intent (lines 26–27 of
Figure 2) must conservatively assume that the data is a High
value. This conservative summary may cause false positive
warnings when the data is of type Lowat run time.
Figure 2 shows another example from Aard Dictionary . The
components DictionaryMain and WordTranslator use Android
intents to communicate. Android intents are messages sent
between Android components, and those messages contain
“extras”, which is a mapping of keys to objects. Component
DictionaryMain creates an intent object i, adds Low-security extra
data to i’s extras mapping, and on line 7 calls the Android
library method startActivity to send the intent. The Android
system then calls WordTranslator.onCreate , which is declared on
line 12. The noninterference type-checker issues a false positive
due to the use of intents; our intent analysis (Section IV)
eliminates the false positive warning.
III. R EFLECTION RESOLUTION
Reﬂection is a metaprogramming mechanism that enhances
the ﬂexibility and expressiveness of a programming language.
Its primary purpose is to enable a program to dynamically
exhibit behavior that is not expressed by static dependencies
in the source code.
Reﬂection is commonly used for the following four use
cases, among others. (1) Provide backward compatibility by
accessing an API method that may or may not exist at run
time. The reﬂective code implements a fallback solution so the
app can run even if a certain API method does not exist, e.g.,
on older devices. (2) Access private API methods and ﬁelds,1 class DictionaryMain extends Activity {
2 void translateWord (int source , int target , String word){
3 Intent i = new Intent(this , WordTranslator .class);
4 i.putExtra (" source", source);
5 i.putExtra (" target", target);
6 i.putExtra (" word", word);
7 startActivity (i);
8 }
9 }
10
11 class WordTranslator extends Activity {
12 void onCreate(Bundle savedInstanceState )
13 Intent i = getIntent ();
14 @Low int source = i. getIntegerExtra (" source ");
15 @Low int target = i. getIntegerExtra (" target ");
16 @Low String word = i. getStringExtra (" word ");
17 showResult(translate(source , target , word));
18 }
19 String translate(int source , int target , String word)
{...}
20 Intent getIntent () {...}
21 void showResult(String result) {...}
22 }
23
24 // Library annotations:
25 class Intent {
26 @High Integer getIntegerExtra (String key) {...}
27 @High String getStringExtra (String key) {...}
28 }
Fig. 2. A noninterference type-checker produces false positive warnings on
lines 14–16, where the return type of get*Extra , of type High, is assigned to
variables with declared type Low. The calls on lines 14–16 always return a
Lowvalue at run time (even though other calls to get*Extra may in general
return a High value), so the assignments are safe. When the noninterference
type system is augmented by our intent analysis, it no longer issues the false
positive warnings.
which offer functionality beyond what is provided by the
public API. (3) Implement design patterns such as duck typing.
(4) Code obfuscation to make it harder to reverse-engineer
the program, e.g., code that accesses premium features
that require a separate purchase. The Android developer
documentation encourages the use of reﬂection to provide
backward compatibility and for code obfuscation, and 39%
of apps in the F-Droid repository [5] use reﬂection.
Not all uses of reﬂection can be statically resolved, but
our experiments show that many of them can. Whenever the
developer runs a code analysis, it is beneﬁcial to the analysis
if as much reﬂection as possible is resolved, in order to
reduce false positive warnings. Obfuscation is not compromised,
because analysis results, annotations, and other information
that is used in-house by the developer need not be provided to
users of the software.
Approach for reﬂection resolution: Without further informa-
tion about what method is reﬂectively called, a static analysis
must assume that a reﬂective call could invoke any arbitrary
method. Such a conservative assumption increases the likelihood
of false positive warnings.
At each call to Method.invoke , our analysis soundly estimates
which methods might be invoked at runtime. Based on this
estimate, our analysis statically resolves the Method.invoke call —
that is, it provides type information about arguments and return
types for a downstream analysis. The results are soundly deter-
mined solely based on information available at compile time.
The reﬂection resolution consists of the following parts:
1) Reﬂection type system : Tracks and infers the possible
names of classes, methods, and constructors used by
reﬂective calls. (Section III-A)2) Reﬂection resolver : Uses the reﬂection type system to
estimate the signatures of methods or constructors that
can be invoked by a reﬂective call. (Section III-B)
A. Reﬂection type system
Our reﬂection type system reﬁnes the Java type system
to provide more information about array, Class ,Method , and
Constructor values. In particular, it provides an estimate, for
each expression of those types, of the values they might evaluate
to at run time.
For expressions of type Class , there are two possible type
qualiﬁers, @ClassVal and @ClassBound , representing either an
exact Class value or an upper bound of the Class value. For
example, @ClassVal("java.util.HashMap") indicates that the Class
object represents the java.util.HashMap class. Alternatively,
@ClassBound("java.util.HashMap") indicates that the Class object
represents java.util.HashMap or a subclass of it.
For expressions of type Method and Constructor , the type
qualiﬁer indicates estimates for the class, method name, and
number of parameters. For example,
@MethodVal(cn="java.util.HashMap",
mn={"containsKey", "containsValue"},
np=1)
indicates that the method represents either HashMap.containsKey
orHashMap.containsValue , with exactly 1 parameter. Likewise,
the MethodVal type may have more than one value for the class
name or number of parameters. The represented methods are the
Cartesian product of all possible class names, method names,
and numbers of parameters. For a constructor, the method
name is “ <init> ”, so no separate @ConstructorVal type qualiﬁer
is necessary.
The MethodVal type is imprecise in that it indicates the
number of parameters that the method takes, but not their
type. This means that the type system cannot distinguish
methods in the uncommon and discouraged [6] case of method
overloading. This was a conscious design decision that reduces
the verbosity and complexity of the annotations, without any
practical negative consequences. In our experiments with more
than 300,000 lines of Java code, this imprecision in the type
system never prevented a reﬂective call from being resolved.
Our implementation caps the size of a set of values at 10.
This cap was never reached in our case studies. If a programmer
writes, or the type system infers, a set of values of size larger
than 10, then the type is widened to its respective top type.
A top type indicates that the type system has no estimate for
the expression: the type system’s estimate is that the run-time
value could be any value that conforms to the Java type. The
top type is the default, and it is represented in source code as
the absence of any annotation.
1)Type checking: The reﬂection type system enforces stan-
dard type system guarantees, e.g. that the right-hand side of an
assignment is a subtype of the left-hand side. These typing rules
follow those of Java, they are standard for an object-oriented
programming language, and they are familiar to programmers.
Therefore, we do not detail them in this paper. The reﬂection
type system and our implementation are compatible with all
Java features, including generics (type polymorphism).
2)Type inference: Programmers do not need to write type
annotations within method bodies, because our system performs
local type inference. More speciﬁcally, for local variables,
casts, and instanceof expressions, the absence of any annotatione:String valis the statically computable value of e
e:@StringVal( val)
e:int valis the statically computable value of e
e:@IntVal( val)
e:@IntVal( p)
new C[ e]:@ArrayLen( p)
new C[]{ e1,..., en}:@ArrayLen( n)
Fig. 3. Inference rules for @StringVal ,@IntVal , and @ArrayLen .
fqnis the fully-qualiﬁed class name of C
C.class :@ClassVal( fqn)
s:@StringVal( n)
Class.forName( s):@ClassVal( n)
fqnis the fully-qualiﬁed class name of the static type of e
e.getClass() :@ClassBound( fqn)
(e:@ClassBound( n)_e:@ClassVal( n))
s:@StringVal( µ)p:@ArrayLen( p)
e.getMethod( s,p):@MethodVal( cn=n,mn=µ,np=p)
e:@ClassVal( n)p:@ArrayLen( p)
e.getConstructor( p):@MethodVal( cn=n,mn="<init>",np= p)
Fig. 4. Selected inference rules for the @ClassVal ,@ClassBound , and @MethodVal
annotations. Additional rules exist for expressions with similar semantics but
that call methods with different names or signatures, and for ﬁelds/returns.
indicates that the type system should infer the most precise
possible type from the context. For all other locations — notably
ﬁelds, method signatures, and generic type arguments — a
missing annotation is interpreted as the top type qualiﬁer.
The local type inference is ﬂow-sensitive. It takes advantage
of expression typing rules that yield more precise types than
standard Java type-checking would.
a)Estimates for values of expressions: We have de-
signed and implemented a dataﬂow analysis that infers and
tracks types providing an estimate for the possible values of
each expression. Our implementation goes beyond constant
folding and propagation: it evaluates side-effect-free methods,
it infers and tracks the length of each array, and it computes a
set of values rather than just one. For example, @ArrayLen({3,4})
indicates that at run time the array has length 3 or 4. Figure 3
shows selected inference rules. The reﬂection type system builds
on top of this dataﬂow analysis.
b)Inference of @ClassVal and @ClassBound :The re-
ﬂection type system infers the exact class name ( @ClassVal ) for
aClass literal ( C.class ), and for a static method call (e.g., Class
.forName(arg) ,ClassLoader.loadClass(arg) , . . . ) if the argument
has a sufﬁciently precise @StringVal estimate. In contrast, it
infers an upper bound ( @ClassBound ) for instance method calls
(e.g., obj.getClass() ).
An exact class name is necessary to precisely resolve
reﬂectively-invoked constructors since a constructor in a
subclass does not override a constructor in its superclass.
Either an exact class name or a bound is adequate to resolve
reﬂectively-invoked methods because of the subtyping rules foroverridden methods.
c)Inference of @MethodVal :The reﬂection type system
infers MethodVal types for methods and constructors that have
been created via Java’s Reﬂection API. A nonexhaustive
list of examples includes calls to Class.getMethod(String name,
Class<?>... paramTypes) and Class.getConstructor(Class<?>...
paramTypes) . For example, the type inferred for variable
getActionBar on line 5 of Figure 1 is
@MethodVal(cn="ArticleViewActivity", mn="getActionBar", np=0) .
Although Figure 1 uses raw (non-parameterized) types, our
inference supplies the missing type argument information.
d)Inference of ﬁeld types: For private ﬁelds, our type
inference collects the types of all assignments to the ﬁeld, and
sets the ﬁeld type to their least upper bound (lub). If the lub
is not a subtype of the declared type, this step is skipped and
a type-checking error will be issued at some assignment. The
same mechanism works for non-private ﬁelds, but the entire
program has to be scanned for assignments. At the end of
type-checking, the type-checker outputs a suggestion about the
ﬁeld types. The user may accept these suggestions and re-run
type-checking to obtain more precise results; we did so in our
experiments. Field type inference works for every type system,
not just those related to reﬂection.
e)Method signature inference: Similarly to ﬁeld type
inference, private method parameters are set to the lub of
the types of the corresponding arguments, and private method
return types are set to the lub of the types of all returned
expressions, when those are consistent with the declared types.
For non-private methods, the entire program is scanned for
calls/overriding and the type-checker outputs suggestions.
Figure 4 shows selected inference rules for the reﬂection
type system.
B. Reﬂection resolver
Prior work (see Section VIII) commonly re-writes the source
code or changes the AST within the program analysis tool,
changing a call to Method.invoke into a call to the method
that is reﬂectively invoked before analyzing the program. This
approach interferes with the toolchain, preventing the code from
being compiled or run in certain environments. This approach is
also at odds with the very purpose of reﬂection: the program no
longer adapts to its run-time environment and loses properties
of obfuscation. A ﬁnal problem is that an analysis may discover
facts that cannot be expressed in source code form.
Our reﬂection resolver operates differently: it leaves the
program unmodiﬁed but narrows the procedure summary —
the speciﬁcation of parameter and return types used during
modular analysis — for that particular call site only. When
the downstream analysis requests the summary at a call
toMethod.invoke , it receives the more precise information
rather than the conservative summary that is written in the
library source code. This transparent integration means that the
downstream analysis does not need to be changed at all to be
integrated with the reﬂection analysis.
C. Example
Recall the example of Figure 1. When the noninterference
type system analyzes getActionBar.invoke(this) on line 7, it
uses a method summary (like a declaration) to indicate the
requirements and effects of the call. Ordinarily, it would use
the following conservative declaration for Method.invoke :@High Object invoke(Object recv, Object ... args)
However, the reﬂection type system inferred that the type
of variable getActionBar is@MethodVal(cn="ArticleViewActivity",
mn="getActionBar", np=0) . In other words, at run time, the
invoked method will be the following one from class
ArticleViewActivity :
@Low ActionBar getActionBar ()
Thus, the noninterference type system has a precise type, Low,
for the result of the invoke call. The reﬂection resolver provides
the following precise procedure summary to the downstream
analysis, for this call site only:
@Low Object invoke(Object recv, Object ... args)
As a result, the type system does not issue a false positive
warning about the assignment to variable actionBar on line 7.
The summary contains not just reﬁned procedure return
types as shown above, but also reﬁned parameter types, enabling
a downstream analysis to warn about clients that pass arguments
that are not legal for the reﬂectively-invoked method. It would
be possible to reﬁne the Java types as well as the type qualiﬁers
(for instance, to warn about possible run-time type cast errors
or to optimize method dispatch), but our implementation does
not do so.
If the reﬂectively-called method or constructor cannot be
resolved uniquely, the reﬂection resolver determines the least
upper bound of all return values and the greatest lower bound
of all parameter and receiver types.
IV. A NDROID INTENT ANALYSIS
An Android app is organized as a collection of components
that roughly correspond to different screens of an application
and to background services.2Some apps consist of dozens of
components. Intents are used for inter-component communi-
cation, both within an app and among different apps. Intents
are similar to messages, communicated asynchronously across
components. Sending an Android intent implicitly invokes a
method on the receiving component, just as making a reﬂective
procedure call implicitly invokes a method. The use of intents is
prevalent in Android apps: all top 50 popular paid apps and top
50 popular free apps from the Google Play store use intents [7],
the top 838 most popular apps contain a total of 58,989 inter-
component communication locations [3], and intents are a
potential target for attackers to introduce malware [7].
Intents present two challenges to static analyses: (i) control
ﬂow analysis, or determining which components communicate
with one another, and (ii) data ﬂow analysis, or determining
what data is communicated. Both parts are important. An
existing analysis, Epicc [3], partially solves the control ﬂow
challenge. Section IV-A describes how our implementation uses
Epicc to compute component communication. Our key research
contribution is to address the data ﬂow challenge, which has
resisted previous researchers. Section IV-B presents a novel
static analysis that estimates the data passed in an Android
intent.
The structure of Android intents: In addition to attributes
that specify which components may receive the intent, an intent
contains a map from strings to arbitrary data, called “extras”.
The extras map is used to pass additional information that is
2Activity, Service, BroadcastReceiver, and ContentProvider are the four kinds
of Android components. See http://developer.android.com/guide/components/
fundamentals.html#Components.needed to perform an action. For example, an intent used to
play a song contains the song’s title and artist as extras. An
invocation of the putExtra method adds a key–value entry to the
intent map, which can be looked up via the getExtra method
call. Without loss of generality, we will consider that every
intent attribute is an entry in the map of extras. The use of
extras is prevalent in Android: of the 1,052 apps in the F-Droid
repository [5], 69% use intents with extra data. Figure 2 shows
the common use case of an Android app sending and receiving
an intent containing extras.
A. Component communication patterns
To precisely analyze the types of data sent through intents,
our analysis requires sendIntent calls to be matched to the decla-
rations of onReceive methods they implicitly invoke. We express
this matching as a component communication pattern (CCP): a
set of pairs of the form hsendIntent (a;i);onReceive (b;j)i. Each
pair in the CCP indicates that components aandb, possibly
from different apps, may communicate through intents iand
j, which intuitively denote the actual arguments and formal
parameters of the implicit invocation.
To precompute an approximated CCP, our current
implementation uses APKParser [8], Dare [9], and Epicc [3].
Our implementation inherits Epicc’s limitations. Note, however,
that Epicc’s limitations are not inherent to our intent analysis,
and they would disappear if we used a better analysis to
compute CCP. As better CCP techniques become available,
they can be plugged into our implementation. IC3 [10] is
Epicc’s successor, created by the same research group. We
attempted to use IC3, but we discovered a soundness bug:
dynamically-registered Broadcast Receivers were not being
analyzed. The IC3 authors have conﬁrmed but not ﬁxed the
bug3, so we used Epicc instead. We now discuss sources of
imprecision and unsoundness due to Epicc.
Epicc’s sources of imprecision. Epicc’s lack of support for
URIs leads to imprecision since intents with the same action
and category but different URIs are conservatively considered
equal. As expected of a static analysis, Epicc also cannot
handle cases where dynamic inputs determine the identity of
receiver components. Epicc also handles this conservatively: all
components are considered possible receivers. Furthermore, the
points-to and string analyses used by Epicc are also sources of
imprecision. Even with these limitations, all mentioned in [3],
Epicc reports 91% precision in a case study with 348 apps.
Epicc’s sources of unsoundness. Epicc unsoundly assumes
that Android apps use no reﬂection. We used the type system of
Section III to circumvent this limitation; see Section VI. Epicc
also unsoundly assumes that Android apps use no native calls,
a standard limitation of static analysis that is shared by IC3.
Recall that while ﬁnding CCP is necessary, it is not
sufﬁcient. Since acceptable solutions exist for ﬁnding CCP,
the focus of our intent analysis is the unsolved problem of
estimating the payloads of intents, which is discussed below.
B. Intent type system
This section presents a type system for Android intents.
The type system veriﬁes that the type of data stored within an
intent conforms to the declared type of the intent, even in the
presence of implicit invocation via intents.
3https://github.com/siis/ic3/issues/1For simplicity, this paper abstracts all methods that send
intents as the method sendIntent , and all methods that receive
an intent as the method onReceive . For example, in Figure 2,
startActivity() , called on line 7, is an example of a sendIntent
method, and the method getIntent() , declared on line 20, is an
example of an onReceive method.
The type system veriﬁes that for any sendIntent method call
and any onReceive method declaration that can be invoked by
the call site, the intent type of the argument in the sendIntent
call is compatible with the intent type of the parameter declared
in the onReceive method signature.
1)Intent types: We introduce intent types, which hold key–
type pairs that limit the values that can be mapped by a key.
Syntax of intent types. This paper uses the following syntax
for an intent map type:
@Intent("K1"!t1, ..., "Kn"!tn) Intent i = ...;
where { "K1" ,. . . ,"Kn" } is a set of literal strings and { t1,. . . ,tn}
is a set of types. The type of variable iabove consists of a
type qualiﬁer @Intent(...) and a Java type Intent . The regular
Java type system veriﬁes the Java type, and our intent type
system veriﬁes the type qualiﬁer.
The actual Java syntax used by our implementation is
slightly more verbose than that in this paper:
@Intent(@Entry(key="K1", type="t1"), ...,
@Entry(key="Kn", type="tn")) Intent i = ...;
Semantics of intent types. If variable iis declared to have an
intent type T, then two constraints hold. (C1) The keys of ithat
are accessed must be a subset of T’s keys. It is permitted for
the run-time value of variable ito have more keys than those
listed in T, but they may not be accessed. It is also permitted
for the run-time value of variable ito have fewer keys than
those listed in T; any access to a missing key will return null.
(C2) For every key kinT, either kis missing from the run-time
key set of i, or the value mapped by kin the run-time value of
ihas the type mapped by kinT. This can be more concisely
expressed as8k2domain (T):i[k]:T[k], where “:” indicates
typing and null is a value of every non-primitive type.
Example. The example below illustrates the declaration and
use of intent types. The symbols @A,@B, and @Cdenote type
qualiﬁers, such as @High and @Low of the noninterference type
system. On the left is the type hierarchy of these type qualiﬁers.
(C1) and (C2) are the two constraints described above.
@Intent("akey" !@C) Intent i = ...
@A @A int e1 = i.getIntExtra("akey"); // legal
/ \ @C int e2 = i.getIntExtra("akey"); // legal
@B @C @B int e3 = i.getIntExtra("akey"); // violates (C2)
i.getIntExtra("otherKey"); // violates (C1)
2)Type system rules: Figure 5 shows the typing rules for
the intent type system. These rules are organized into three
categories, according to their purpose. Subtyping rules deﬁne a
subtyping relation for intent types, well-formedness rules deﬁne
which constructions are acceptable, and typing judgment rules
deﬁne the types associated with different language expressions.
a)Subtyping (ST): Intent type t1is a subtype of intent
type t2if the key set of t2is a subset of the key set of t1and,
for each key kin both t1andt2,kis mapped to the same type.
@Intent("akey" !t, "anotherkey" !t) Intent i1 = ...;
@Intent("akey" !t) Intent i2 = ...;
@Intent("anotherkey" !t)) Intent i3 = ...;
i2 = i1; // legal
i1 = i3; // illegalSubtyping
(ST)8k2keys(t2):k2keys(t1)^t1[k] =t2[k]
t1<:t2
(CP)8k2keys(t2):k2keys(t1)^t1[k]<:t2[k]
t1<copyable t2
Well-formedness
(OR)No precondition
void onReceive (ti)
Typing judgments
(SI)8onReceive (b;j):hsendIntent (a;i);onReceive (b;j)i2CCP
i:ti j:tj ti<copyable tj
sendIntent (a;i):int
(PE1)e:t v:t[k] k2keys(t) s:@StringVal( k)
e:putExtra (s;v):t
(PE2)e:t k=2keys(t)eis unaliased s:@StringVal( k)
e:putExtra (s;v):t
(GE)e:t k2keys(t) s:@StringVal( k)
e:getExtra (s):t[k]
Fig. 5. Type system for Android intents. Standard rules are omitted.
The mapped types must be exactly the same; use of a
subtyping requirement t1[k]<:t2[k]instead of equality t1[k] =
t2[k]would lead to unsoundness in the presence of aliasing.
The example below illustrates this problem. (On the left is the
type qualiﬁer hierarchy.)
@C String c;
@A @Intent("akey" !@B) Intent i1;
/ \ @Intent("akey" !@A) Intent i2;
@B @C i2 = i1; // illegal
i2.putExtra("akey", c);
It would be incorrect to allow the assignment i2 = i1 in this
example, even though the assignment is valid according to
standard object-oriented typing. In this case, the call to putExtra
would store, in the object pointed by i1, a value of incorrect
type at key akey. This happens because the references i1and
i2are aliased to the same intent object.
b)Copyable (CP): Copyable is a subtyping-like rela-
tionship with the weaker requirement t1[k]<:t2[k]. It may be
used only when aliasing is not possible, which occurs when
onReceive is invoked by the Android system, as explained in
the (SI) rule below.
c)Declarations of onReceive (OR): A declaration of
onReceive always type-checks. The standard Java overriding
rules do not apply to declarations of onReceive : the intent type
of the formal parameter of onReceive is not restricted by the type
of the parameter in the overridden declaration. This is allowable
because by convention onReceive is never called directly but
rather is only called by the Android system. The type-checker
prohibits direct calls to onReceive methods; this constraint is
omitted from Figure 5 for brevity.d)Calls to sendIntent (SI): AsendIntent call can be
viewed as an invocation of one or more onReceive methods. A
sendIntent call type-checks if its intent argument is copyable to
the formal parameter of each corresponding onReceive method.
CCP (see Section IV-A ) is used to determine each onReceive
method of a sendIntent call. The type comparison uses the
copyable relation, not subtyping. This is sound because the
Android system passes a copy of the intent argument to
onReceive , so aliasing is not a concern.
e)Calls to putExtra (PE): If the receiver of a putExtra
call might have aliases, then the argument’s type must be a
subtype of the type with the speciﬁed key in the map. This
prevents an alias from modifying an intent in such a way that
it violates the type of another alias. For example:
@Intent("akey" !@Low) Intent a = new Intent();
@Intent() Intent b = a;
@High String hs = ...;
b.putExtra("akey", hs); // does not type-check
a.getExtra("akey");
If the receiver has no aliases, then the key is permitted to be
missing from the map type.
f)Calls to getExtra (GE): The rule for getExtra is
straightforward.
For both the PE and GE rules, the call ( putExtra orgetExtra )
type-checks only if the key is a statically computable expression,
according to the dataﬂow analysis of Section III-A 2. For all
1,052 apps in the F-Droid repository, 93% of all keys could be
statically computed.
3)Type inference: Annotations are rarely required within
method bodies, because the intent type system performs ﬂow-
sensitive local type inference. Consider the following example:
@Intent Intent i = new Intent(); // i has type @Intent()
i.putExtra("akey", h); // i now has type @Intent("akey" !@High)
i.putExtra("akey", l); // i now has type @Intent("akey" !@Low)
Because the receiver expression of these putExtra calls is an
unaliased local variable, its type can be reﬁned by adding
the key–type pair from the putExtra call. We implemented a
modular aliasing analysis that determines whether an expression
is unaliased.
Figure 6 shows two cases for the putExtra type inference
rules for intent types. For both cases, the key argument of
the putExtra call must be a statically computable expression
(Section III-A 2) and the receiver expression must be unaliased.
For the ﬁrst case, if the intent type of the receiver expression
does not have a key–type pair with the same key passed as
an argument, then the intent type is reﬁned with the new key
mapping to the type of the value passed as argument. For the
second case, if the intent type already has a key–type pair with
the same key, then the type in this key–type pair is replaced by
the type of the value passed as an argument. A further standard
condition (omitted from Figure 6 for brevity) is that the new
intent type must be a subtype of the declared type.
C. Example
Recall the example of Figure 2. A noninterference type-
checker would report false-positive warnings on lines 14–16
because the type system is unable to deduce that all extra
data from the corresponding intent is of type Low. A developer
can express this intended design by annotating the method
WordTranslator.getIntent (inherited from class Activity ):
@Override
@Intent("source" !@Low, "target" !@Low, "word"!@Low)
Intent getIntent() { return super.getIntent(); }e:putExtra (s;v)e:tv:sk62keys(t)
eis unaliased s:@StringVal( k)
e:t[fk!sg
e:putExtra (s;v)e:t[fk!_gv:s
eis unaliased s:@StringVal( k)
e:t[fk!sg
Fig. 6. Flow-sensitive type inference rules for intent types: the conclusion
shows the type of eafter the call to putExtra . Standard rules are omitted.
The startActivity(i) statement on line 7 still type-checks after
this change because the type-checker reﬁnes the type of ito
@Intent("source" !@Low, "target" !@Low, "word"!@Low) as
a result of the putExtra calls on lines 4–6.
The copyable typing rule enforces that the intent variable
iin method DictionaryMain.translateWord() has a compatible
type with the return type of WordTranslator.getIntent() .
By extending the noninterference type system with our
intent type system and adding the correct annotations to the
return type of WordTranslator.getIntent() , the Aard Dictionary
example type-checks and the developer is assured that the
program does not contain security vulnerabilities that could
leak private data. Note that any developer-written annotations
in the program are checked, not trusted.
V. F ORMAL ANALYSIS
Our implementation works on Java code: it does not analyze
native calls. For efﬁciency, it relies on trusted annotations for
system libraries. These are standard limitations of a static
analysis. Section IV-A notes other limitations regarding the
estimation of component communication patterns.
Modulo these limitations, our analysis is sound. That is, if
a program type-checks, then the type of any expression is a
sound estimate of its possible run-time values.
For reﬂection, this means that the value for a Class orMethod
expression is contained within the set of possible values in its
type, and likewise for array lengths.
For intents, this means that if an expression has a type with
an intent key–type pair, then at run time the expression’s value
is an intent whose extra data maps the key to a value of that
type, or the key does not appear in the map.
Equally importantly, the resolution preserves any soundness
property for a downstream analysis. If the downstream analysis
is sound when using the conservative library annotations, then
it remains sound when using more precise summaries supplied
by the reﬂection and intent resolvers.
It is possible to state formal type-correctness, progress, and
preservation theorems for our type systems. The theorems are
standard and their proofs are straightforward.
VI. I MPROVING A DOWNSTREAM ANALYSIS
We evaluated our work in two ways. First, this section
reports how much our reﬂection and intent analyses improve
the precision of a downstream analysis, which is their entire
purpose. Second, Section VII measures how well our type
inference rules reduce the programmer annotation burden.
The purpose of resolving reﬂection and intents is to improve
the precision of a downstream analysis. Section VI-B measures
the improvement in precision, and Section VI-C shows the
programmer effort required to achieve the improved precision.App LOC Reﬂection Intent uses # of annotations
meth cons put get IFC reﬂ int
AbstractArt 4,488 1 0 1 1 317 0 1
arXiv 3,643 14 0 70 17 130 0 13
Bluez IME 4,523 4 2 124 42 285 0 16
ComicsReader 6.612 6 0 1 2 381 1 6
MultiPicture 7,496 1 0 17 12 511 0 17
PrimitiveFTP 4,026 2 0 1 1 321 0 1
RemoteKeyboard 5,723 1 0 3 4 580 0 4
SuperGenPass 2,125 1 0 15 14 181 0 8
VimTouch 8,881 1 0 7 6 2,424 2 7
VLCRemote 5,097 1 0 12 21 453 0 22
Total 52,614 32 2 251 120 5,583 3 95
Fig. 7. Selected subject apps from the F-Droid repository. The number of
reﬂective invocatons is given for Method s and Constructor s, and intent uses
count the number of putExtra and getExtra calls. The last three columns show
the annotation overhead for the technique IFC+INT+RR. The column IFC
shows the number of @Source and @Sink information ﬂow annotations. The
column reﬂ shows the number of @MethodVal and @ClassBound annotations (no
@ClassVal annotations were required). The column int shows the number of
@Intent annotations.
A. Subject programs and downstream analysis
We used open-source apps from the F-Droid repository [5]
to evaluate our approach. F-Droid contains 1,052 apps that
have an average size of 9,237 NCNB LOC.
We randomly sampled 10 apps (Figure 7), excluding
unusually simple apps ( <2 kLOC, or no use of reﬂection
or intents) and unusually complex apps ( >15 kLOC). Each of
the 10 apps contains on average 5,261 LOC, 3 reﬂective method
or constructor invocations, and 37 calls to putExtra orgetExtra .
Our evaluation uses three downstream analyses. Sec-
tions VI-B –VI-C discuss the Information Flow Checker (IFC);
for reasons of space, Section VI-D brieﬂy discusses the other
two case studies. IFC is a type system and corresponding type-
checker that prevents unintended leakage of sensitive data from
an application [1]. Given a program and an information-ﬂow
policy (a high-level speciﬁcation of information ﬂow, expressed
as source–sink pairs), IFC guarantees that no other information
ﬂows occur in the program. IFC is sound: it issues a warning if
the information ﬂow type of any variable or expression does not
appear in the information-ﬂow policy. IFC is also conservative:
if it issues a warning, then the program might or might not
misbehave at run time.
We evaluated the effectiveness of our techniques by studying
the following two research questions.
B.How much do our reﬂection and intent analyses improve
the precision of IFC?
We measured the precision and recall of IFC’s static estimate
of possible information ﬂows. To compute precision and recall,
we manually determined the ground truth: the actual number
of ﬂows that could occur at run time in an app.4Precision is
the number of ground-truth ﬂows, divided by the total number
of ﬂows reported by the analysis. Recall is the number of real
ﬂows reported by the analysis, divided by the total number of
ground-truth ﬂows.5We conﬁrmed that IFC has 100% recall
both with and without the reﬂection and intent analyses, i.e.,
IFC is sound and misses no real ﬂows.
4This enormous manual effort is the reason we did not run the experiments
on all 1,052 F-Droid apps. It would be easy to run our analyses on all the
apps, but doing so would not indicate whether our analyses were useful.
5Since IFC is sound, it reports every ground-truth ﬂow.
Precision (%)
AbstractArtarXivBluezIMEComicsReaderMultiPicture PrimitiveFTPRemoteKeyboardSuperGenPassVimTouchVLCRemote020406080100IFC, IFC+RR IFC+INT IFC+RR+INTFig. 8. Comparison of precision among techniques.
To evaluate this research question, we compared the
precision of the following techniques.
IFC-unsound makes optimistic assumptions about every
reﬂective and intent-related call. Its recall is only 95% — it
unsoundly misses 5% of the information ﬂows in the apps,
which makes it unacceptable for use in the security domain.
Its precision was 100%, for this set of apps.
IFC treats reﬂection and intents conservatively. Data in an
intent may be from any source and may ﬂow to any sink. Data
used as an argument to a reﬂective invocation may ﬂow to
any sink, and data returned from a reﬂective invocation may
be from any source. In the absence of reﬂection and intents,
IFC is an effective analysis with high precision, as shown by
IFC-unsound. However, for our subject programs, which use
reﬂection and intents, IFC’s precision is just 0.24%.
IFC+RR augments IFC with reﬂection resolution and can
therefore treat data that is used in reﬂection precisely when the
reﬂection can be resolved. Data in intents, however, is treated
conservatively. Since all apps send intents, which may trigger
the use of any permissions, reﬂection resolution alone does not
help; the average precision remains 0.24%. In a (non-Android)
program that does not use intents, IFC+RR would outperform
IFC.
IFC+INT augments IFC with intent analysis. It reports
precise information ﬂows for method calls involving intents.
Differently from intent invocations, reﬂective calls are only
allowed to use permissions listed in the app’s manifest.
Therefore, data passed to a reﬂective invocation is treated
as ﬂowing to any sink the app may access. Similarly, data
returned from a reﬂective invocation is treated as if it could have
come from all sources listed in the manifest. However, since
Epicc generates CCP and unsoundly assumes that reﬂective
calls do not invoke sendIntent methods, IFC+INT must issue a
warning any time a method is reﬂectively invoked. For each such
warning, the developer must manually verify that the reﬂective
method does not invoke sendIntent . The average precision is
53%.
IFC+INT+RR augments IFC with both reﬂection resolution
and intent analysis. When reﬂection resolution cannot resolve
a method or when it resolves a method to sendIntent , it still
issues a warning. The precision is 100% for each of these
randomly-chosen apps, but might be smaller for other apps.
Figure 8 plots the precision for the sound techniques. We
manually veriﬁed that sendIntent is never invoked reﬂectively
in any app. IFC+INT has perfect precision for 4 apps that usereﬂection for control ﬂow but not data ﬂow — data returned
from reﬂective calls is not sent to a sensitive sink and no
sensitive information is passed as an argument to a reﬂective
method call. For the other 6 apps, IFC+INT is more precise
than IFC, but still reports ﬂows that cannot happen at run time.
For these apps, the reﬂection resolver is needed to reach 100%
precision as reported by IFC+INT+RR. The results conﬁrm
that both techniques, reﬂection resolution and intent analysis,
are necessary and that they are complementary and synergistic.
We attempted to compare our approach with IccTA [11].
IccTA crashed when run on 1 of the 10 apps. For the other 9
apps, IccTA outputted some static analysis data, but no data
regarding information ﬂows. We contacted the IccTA authors
about these issues but didn’t hear back from them.
C. What is the annotation overhead for programmers?
Figure 7 shows the annotations required to type-check
each app. Less than 2% as many annotations are required due
to reﬂection and intents, compared to annotations related to
information ﬂow (the downstream analysis). In cases of missing
or incorrect annotations, both analyses issue user-friendly
warnings that pinpoint and explain the type inconsistency. The
average time to add each annotation was roughly one minute,
for an author of this paper.6Thus, the annotation overhead is
small in absolute and relative terms, especially considering the
signiﬁcant improvements in precision shown above.
Part of the need for annotations is because the downstream
analysis is a modular analysis — a type-checker that veriﬁes
programmer-written types. If the downstream analysis were a
whole-program analysis such as pointer analysis, type inference,
or abstract interpretation, these would not be necessary. Other
annotations are needed to express facts that no static analysis
can infer; in these cases, human intervention is unavoidable.
D. Precision improvements for other downstream analyses
We demonstrated the generality of our approach by in-
tegrating our reﬂection and intent analyses with two other
downstream analyses. The Nullness Checker [12] veriﬁes the
absence of null pointer dereferences: if the Nullness Checker
issues no errors for a given program, then that program is
guaranteed to not throw a NullPointerException at runtime. The
Interning Checker [12] veriﬁes equality tests: if the Interning
Checker issues no errors for a given program, then all reference
equality tests (i.e., ==) are over canonicalized data, and thus are
consistent with .equals() . Like every analysis, these analyses
suffer false positives due to reﬂection and intents.
Reﬂection resolution improved the precision of the Nullness
Checker for 3 of the 10 apps. There were no reference equality
tests over values returned by a reﬂective method invocation,
and therefore reﬂection resolution did not improve the precision
of the Interning Checker for these apps.
The intent analysis improved the precision of the Interning
Checker for 2 of the 10 apps. The intent analysis does not
improve the precision of the Nullness Checker, because
getExtra can return null if a key does not exist in an intent map.
The intent type system does not guarantee the existence of a key
in an intent map — only that if it exists, it has a certain type.
6A developer who is familiar with the subject programs might take less
time. The developer would need to learn to use IFC, but we have found that
doing so is straightforward for someone who understands information ﬂow.VII. E VALUATION OF TYPE INFERENCE
As shown in Section VI-C , programmers have to write very
few annotations to aid the reﬂection and intent analysis. This
section explains why, by evaluating our type inference rules.
A. Reﬂection resolution
In addition to the 10 subject apps of Section VI-A , we
arbitrarily selected 25 apps from F-Droid that use reﬂection.
Using the entire set of 35 apps, we evaluated the reﬂection
resolution by answering the following three research questions.
1)How is reﬂection used in practice?: The 35 apps contain
142 invocations of reﬂective methods or constructors. 81% are
used to provide backward compatibility, 6% access a non-public
API, and 13% are for other use cases.
2)How often can reﬂection be resolved at compile time?:
Our reﬂection resolution resolved 93% of instances of reﬂective
method or constructor invocations. It failed on the other 7%
because the reﬂectively invoked method or constructor cannot
be determined statically by any analysis. As an example, the
RemoteKeyboard app uses reﬂection for extensibility and duck
typing: the user can conﬁgure the class name for a shell
implementation, and the app reﬂectively invokes a factory
method on this class. Moreover, these shell implementations do
not have a common interface that deﬁnes the factory method,
rendering static reﬂection resolution impossible.
3)How effective is type inference for reﬂection resolution?:
To enable modular reﬂection resolution, a developer may have
to write type annotations in a program.
For 52% of reﬂective invocations, our intra-procedural type
inference (Section III-A 2) determined the exact method that is
reﬂectively invoked without requiring a single annotation.
For 32% of reﬂective invocations, our ﬁeld type inference
determined the exact method that is reﬂectively invoked. A
common example is the initialization of a private ﬁeld of type
Class orMethod . These ﬁelds are only assigned once but are
initialized within a method that provides exception handling.
For 9% of reﬂective invocations, our method signature
inference inferred the exact method that is reﬂectively invoked.
An example is the use of a helper method that manipulates
String s and returns an object of type Method .
The other 7% of reﬂection invocations cannot be resolved
by any static analysis (for an example, see Section VII-A2).
Figure 7 gives the number of developer-written annotations
that were required. Recall that all annotations in an app are
checked, not trusted. Thus, use of developer-supplied annota-
tions does not compromise the soundness of our approach.
4)Bug detection: Our reﬂection resolver revealed a bug in
the arXiv app. The reﬂection resolver reported an unresolvable
method even though the class name, method name, and the
number of parameters were precisely inferred. The bug was a
misspelled method name, and it prevented a menu from being
updated. The developer conﬁrmed the bug.
B. Intent type inference
To measure the effectiveness of the intent type inference
(Section IV-B 3), we used a similar approach as when measuring
the reﬂection resolution type inference: we determined the num-
ber of sent intents with extras that required no annotations and
compared it with the overall number of sent intents with extras.For 67% of the cases, our intra-procedural inference
determined that the sent intent had no aliases and precisely
inferred the type of the sent intent. For those cases, developer-
written annotations are not necessary.
For 21% of the cases, the intent is returned by a method
in the app, and our inference correctly infers the return type.
For 12% of the cases, the sent intent was stored in a ﬁeld.
Our alias analysis (Section IV-B 3) treated such intents as
possibly-aliased, so the intent type cannot be reﬁned using
the putExtra rule.
VIII. R ELATED WORK
An extended version of this paper is available [13].
A. Reﬂection
The most common approach for improving precision of a
static analysis in the presence of reﬂection is proﬁling from
an observed set of executions, assuming that the observed
program exercises all possible behaviors [14]–[16]. For example,
Averroes [17] can use TamiFlex [16] when building call
graphs, to unsoundly improve precision over its conservative
defaults. All of these approaches that use dynamic information
are unsound. By contrast, our approach is sound: it makes
conservative assumptions about any occurrence of reﬂection
that it cannot handle.
In some special cases, reﬂection can be resolved based on
assumptions about the run-time execution context. For example,
Zhang’s GUI error detection tool [18] builds reﬂection-aware
call graphs for Android applications, based on the contents of
conﬁguration ﬁles at compile time. This approach is sound if
the same conﬁguration ﬁles will be installed at run time as at
analysis time. This is the same assumption made by Epicc [3] to
handle inter-component communication, which our system uses.
A few static analyses partially handle reﬂection. Javari [19]
introduces a new API to invoke reﬂection that does a single
dynamic check of the method signature rather than of the object.
Programs using that API can be soundly type-checked. Our
approach could eliminate that special API and the run-time
check. Li et al. [20] developed an unsound self-inferencing
reﬂection resolution to improve the precision of a pointer
analysis for Java programs. They additionally analyzed how
reﬂection is used in open-source Java applications. In contrast,
our approach is sound and our evaluation focuses on the use
of reﬂection in Android apps.
B. Android
We evaluated our reﬂection and intent analyses in the con-
text of detecting and preventing malicious behavior in mobile
apps [7], [21]–[31]. We discuss some closely related work.
SCanDroid [21] applies data ﬂow analysis to check security
properties in Android apps. It analyzes intra-component and
inter-component information ﬂows for vulnerabilities. The
analysis cannot handle interactions between apps and provides
limited support to handle intent extras, making no distinction
between the ﬂows of permissions that result from the entries
of an intent. Several other techniques came after it [7], [24]–
[29], [32], improving precision and recall of reported warnings.
However, to the best of our knowledge, no later technique has
focused on handling the important aspect of data encapsulation
in intents. Our technique is complementary to push-button
static analysis techniques such as SCanDroid: our analysisrequires a small number of annotations from the developer
but requires less examination of false positives and provides
stronger guarantees. It preserves soundness, achieves good
precision, and remains easy to use.
FlowDroid [32] is a technique that performs taint analysis on
Android apps with the goal of ﬁnding security vulnerabilities.
FlowDroid does not support Android’s implicit intents nor
reﬂection. In experiments, the tool achieved 83% precision and
93% recall for apps containing different types of vulnerabilities.
Our implementation currently relies on Epicc [3] to approx-
imate the set of component pairs that actually communicate.
See Section IV-A for a discussion.
Our implementation has been publicly available since
December 12, 2013. In forthcoming work, IccTA [11] adopts
a similar approach that performs static taint analysis in the
presence of inter-component communication. IccTA’s reﬂection
resolution is much more limited than ours: it only processes
string constants. Although IccTA is applied to taint analysis,
IccTA is neither sound nor complete; by contrast to our work, it
provides no security guarantees to its user and is not applicable
in the context of high-assurance app stores [1]. Even if the
analysis ﬂaws were addressed, IccTA would remain vulnerable
because its taint model uses an insufﬁcient set of sensitive
sources and sinks. Another difference is the evaluation: we
measured the precision and recall of our information-ﬂow
analysis on real Android apps and achieved 100% precision and
recall, but IccTA was evaluated on 22 examples hand-crafted
by its authors, where it achieved 96% precision and recall.
C. Other
Xiao et al. [33] proposed a semi-automatic approach to
analyze TouchDevelop mobile app scripts for privacy. Their
workﬂow is similar to ours: users annotate APIs and code, and
the analyzer uses a dataﬂow analysis to check conformance
of inferred ﬂows against a speciﬁcation of the app. However,
their static analysis does not handle implicit control ﬂows.
Our work has some similarities to call graph construction in
object-oriented programs [34], [35]. Dynamic dispatching can
be viewed as an implicit control ﬂow mechanism, much as Java
reﬂection and Android intents can. Most call graph construction
algorithms do whole-program pointer analysis. Our approach
is modular but relies on user annotations. A whole-program
type inference or pointer analysis could eliminate the need for
programmers to write annotations.
IX. C ONCLUSIONS
We have presented novel analyses for two programming
paradigms — Java reﬂection and Android intents — that are
useful to programmers but challenging for static analysis. Our
analyses statically resolve reﬂection targets and intent payloads.
Though sound and conservative, they achieve high precision in
practice, as conﬁrmed by experiments on real-world Android
apps. Our implementations are publicly available as open
source, and they can be integrated with an arbitrary downstream
analysis to improve its precision.
Acknowledgments. This material is based on research sponsored by DARPA
under agreement number FA8750-12-2-0107. The U.S. Government is au-
thorized to reproduce and distribute reprints for Governmental purposes
notwithstanding any copyright notation thereon. This work was partially
supported by FACEPE fellowship IBPG-0751-1.03/13 and by a Microsoft
SEIF’13 award.REFERENCES
[1] M. D. Ernst, R. Just, S. Millstein, W. Dietl, S. Pernsteiner, F. Roesner,
K. Koscher, P. Barros, R. Bhoraskar, S. Han, P. Vines, and E. X. Wu,
“Collaborative veriﬁcation of information ﬂow for a high-assurance app
store,” in Proceedings of the 21st ACM Conference on Computer and
Communications Security (CCS) , Scottsdale, AZ, USA, November 4–6,
2014, pp. 1092–1104.
[2] B. C. Smith, “Procedural reﬂection in programming languages,” MIT
Laboratory for Computer Science, Cambridge, MA, Tech. Rep. MIT-
LCS-TR-272, January 1982.
[3] D. Octeau, P. McDaniel, S. Jha, A. Bartel, E. Bodden, J. Klein, and
Y . Le Traon, “Effective inter-component communication mapping in
Android with Epicc: An essential step towards holistic security analysis,”
in22nd USENIX Security Symposium , Washington, DC, USA, August 14–
16, 2013, pp. 543–558.
[4] D. M. V olpano and G. Smith, “A type-based approach to program
security,” in TAPSOFT ’97: Theory and Practice of Software Devel-
opment, 7th International Joint Conference CAAP/FASE , Lille, France,
April 14–18, 1997, pp. 607–621.
[5] F-Droid, “Free and open source Android app repository,” http://f-droid.
org, Feb 2014.
[6] J. Bloch, Effective Java Programming Language Guide . Boston, MA:
Addison Wesley, 2001.
[7] E. Chin, A. P. Felt, K. Greenwood, and D. Wagner, “Analyzing inter-
application communication in Android,” in Proceedings of the 9th
International Conference on Mobile Systems, Applications, and Services ,
Bethesda, MD, USA, June 29–July 1, 2011, pp. 239–252.
[8] “APKParser,” https://code.google.com/p/xml-apk-parser/.
[9] D. Octeau, S. Jha, and P. McDaniel, “Retargeting Android applications
to Java bytecode,” in FSE 2012, Proceedings of the ACM SIGSOFT
20th Symposium on the Foundations of Software Engineering , Cary, NC,
USA, November 13–15, 2012, pp. 6:1–6:11.
[10] D. Octeau, D. Luchaup, M. Dering, S. Jha, and P. McDaniel, “Composite
constant propagation: Application to Android inter-component commu-
nication analysis,” in ICSE’15, Proceedings of the 37th International
Conference on Software Engineering , Florance, Italy, May 20–22, 2015.
[11] L. Li, A. Bartel, T. F. Bissyandé, J. Klein, Y . Le Traon, S. Arzt,
S. Rasthofer, E. Bodden, D. Octeau, and P. McDaniel, “IccTA: Detecting
inter-component privacy leaks in Android apps,” in ICSE’15, Proceedings
of the 37th International Conference on Software Engineering , Florance,
Italy, May 20–22, 2015.
[12] M. M. Papi, M. Ali, T. L. Correa Jr., J. H. Perkins, and M. D. Ernst,
“Practical pluggable types for Java,” in ISSTA 2008, Proceedings of the
2008 International Symposium on Software Testing and Analysis , Seattle,
WA, USA, July 22–24, 2008, pp. 201–212.
[13] P. Barros, R. Just, S. Millstein, P. Vines, W. Dietl, M. d’Amorim,
and M. D. Ernst, “Static analysis of implicit control ﬂow: Resolving
Java reﬂection and Android intents (extended version),” University of
Washington Department of Computer Science and Engineering, Seattle,
WA, USA, Tech. Rep. UW-CSE-15-08-01, August 2015.
[14] M. Tatsubori, “Living with reﬂection: Towards coexistence of program
transformation by middleware and reﬂection in Java applications,” in
6th JSSST Workshop on Programming and Programming Languages
(PPL2004) , Gamagohri, Aichi, Japan, March 11–13, 2004.
[15] B. Livshits, J. Whaley, and M. S. Lam, “Reﬂection analysis for Java,”
inThird Asian Symposium on Programming Languages and Systems ,
Tsukuba, Japan, November 2005, pp. 139–160.
[16] E. Bodden, A. Sewe, J. Sinschek, H. Oueslati, and M. Mezini, “Taming
reﬂection: Aiding static analysis in the presence of reﬂection and
custom class loaders,” in ICSE’11, Proceedings of the 33rd International
Conference on Software Engineering , Waikiki, Hawaii, USA, May 25–27,
2011, pp. 241–250.
[17] K. Ali and O. Lhoták, “Averroes: Whole-program analysis without the
whole program,” in ECOOP 2013 — Object-Oriented Programming,
27th European Conference , Montpellier, France, July 3–5, 2013, pp.
378–400.
[18] S. Zhang, H. Lü, and M. D. Ernst, “Finding errors in multithreaded GUI
applications,” in ISSTA 2012, Proceedings of the 2012 International
Symposium on Software Testing and Analysis , Minneapolis, MN, USA,
July 17–19, 2012, pp. 243–253.[19] M. S. Tschantz and M. D. Ernst, “Javari: Adding reference immutability
to Java,” in Object-Oriented Programming Systems, Languages, and
Applications (OOPSLA 2005) , San Diego, CA, USA, October 18–20,
2005, pp. 211–230.
[20] Y . Li, T. Tan, Y . Sui, and J. Xue, “Self-inferencing reﬂection resolution
for Java,” in ECOOP 2014 — Object-Oriented Programming, 28th
European Conference , Uppsala, Sweden, July 30–August 1, 2014, pp.
27–53.
[21] A. P. Fuchs, A. Chaudhuri, and J. S. Foster, “SCanDroid: Automated
security certiﬁcation of Android applications,” University of Maryland,
Tech. Rep. CS-TR-4991, November 2009.
[22] W. Enck, P. Gilbert, B.-G. Chun, L. P. Cox, J. Jung, P. McDaniel,
and A. N. Sheth, “TaintDroid: an information-ﬂow tracking system for
realtime privacy monitoring on smartphones,” in USENIX 9th Symposium
on OS Design and Implementation , Vancouver, BC, Canada, October 4–6,
2010.
[23] P. Hornyack, S. Han, J. Jung, S. Schechter, and D. Wetherall, “These
aren’t the droids you’re looking for: Retroﬁtting Android to protect
data from imperious applications,” in Proceedings of the 18th ACM
Conference on Computer and Communications Security (CCS) , Chicago,
IL, USA, October 18–20, 2011, pp. 639–652.
[24] M. Egele, C. Kruegel, E. Kirdaz, and G. Vigna, “PiOS: Detecting privacy
leaks in iOS applications,” in 18th Annual Symposium on Network and
Distributed System Security , San Diego, CA, USA, February 7–9, 2011.
[25] M. Grace, Y . Zhou, Z. Wang, and X. Jiang, “Systematic detection
of capability leaks in stock Android smartphones,” in 18th Annual
Symposium on Network and Distributed System Security , San Diego,
CA, USA, February 6–8, 2012.
[26] C. Gibler, J. Crussell, J. Erickson, and H. Chen, “AndroidLeaks:
Automatically detecting potential privacy leaks in Android applications
on a large scale,” in Proceedings of the 5th International Conference on
Trust and Trustworthy Computing , Vienna, Austria, June 13–15, 2012,
pp. 291–307.
[27] C. Mann and A. Starostin, “A framework for static detection of privacy
leaks in Android applications,” in Proceedings of the 2012 ACM
Symposium on Applied Computing , Trento, Italy, March 27–30, 2012,
pp. 1457–1462.
[28] M. Grace, Y . Zhou, Q. Zhang, S. Zou, and X. Jiang, “RiskRanker: Scal-
able and accurate zero-day Android malware detection,” in Proceedings
of the 10th International Conference on Mobile Systems, Applications,
and Services , Low Wood Bay, UK, June 26–28, 2012, pp. 281–294.
[29] Y . Zhou, Z. Wang, W. Zhou, and X. Jiang, “Hey, you, get off of my
market: Detecting malicious apps in ofﬁcial and alternative Android
markets,” in 18th Annual Symposium on Network and Distributed System
Security , San Diego, CA, USA, February 6–8, 2012.
[30] L. K. Yan and H. Yin, “DroidScope: Seamlessly reconstructing the OS
and Dalvik semantic views for dynamic Android malware analysis,” in
21st USENIX Security Symposium , Bellevue, WA, USA, August 8–10,
2012.
[31] R. Xu, H. Saïdi, and R. Anderson, “Aurasium: Practical policy enforce-
ment for Android applications,” in 21st USENIX Security Symposium ,
Bellevue, WA, USA, August 8–10, 2012.
[32] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel, J. Klein, Y . Le Traon,
D. Octeau, and P. McDaniel, “FlowDroid: Precise context, ﬂow, ﬁeld,
object-sensitive and lifecycle-aware taint analysis for Android apps,” in
PLDI 2014, Proceedings of the ACM SIGPLAN 2014 Conference on
Programming Language Design and Implementation , Edinburgh, UK,
June 9-11, 2014, pp. 259–269.
[33] X. Xiao, N. Tillmann, M. Fähndrich, J. De Halleux, and M. Moskal,
“User-aware privacy control via extended static-information-ﬂow analysis,”
inASE 2012: Proceedings of the 27th Annual International Conference
on Automated Software Engineering , Essen, Germany, September 5–7,
2012, pp. 80–89.
[34] F. Tip and J. Palsberg, “Scalable propagation-based call graph construc-
tion algorithms,” in Object-Oriented Programming Systems, Languages,
and Applications (OOPSLA 2000) , Minneapolis, MN, USA, October 15–
19, 2000, pp. 281–293.
[35] A. Le, O. Lhoták, and L. Hendren, “Using inter-procedural side-effect
information in JIT optimizations,” in Compiler Construction: 14th
International Conference, CC 2005 , Edinburgh, Scotland, April 2005,
pp. 287–304.