Study and Refactoring of Android Asynchronous
Programming
Yu Lin, Semih Okur
Computer Science Department
University of Illinois at Urbana-Champaign, USA
fyulin2, okur2g@illinois.eduDanny Dig
School of Electrical Engineering and Computer Science
Oregon State University
digd@eecs.oregonstate.edu
Abstract ‚ÄîTo avoid unresponsiveness, a core part of mobile
development is asynchronous programming. Android provides
several async constructs that developers can use. However, devel-
opers can still use the inappropriate async constructs, which result
in memory leaks, lost results, and wasted energy. Fortunately,
refactoring tools can eliminate these problems by transforming
async code to use the appropriate constructs.
In this paper we conducted a formative study on a corpus
of 611 widely-used Android apps to map the asynchronous
landscape of Android apps, understand how developers retroÔ¨Åt
asynchrony, and learn about barriers encountered by developers.
Based on this study, we designed, implemented, and evaluated
ASYNC DROID , a refactoring tool which enables Android devel-
opers to transform existing improperly-used async constructs
into correct constructs. Our empirical evaluation shows that
ASYNC DROID is applicable, accurate, and saves developers effort.
We submitted 30 refactoring patches, and developers consider
that the refactorings are useful.
I. I NTRODUCTION
According to a Gartner report [9], by 2016 more than 300
billion apps for smartphones and tablets will be downloaded
annually. Android is the dominant platform, by 4x over the next
largest platform and 1.7x over all the others combined [16].
Previous studies [37], [49] have shown that unresponsiveness
is the number one bug that plagues Android apps. To avoid
unresponsiveness, app developers use asynchronous program-
ming to execute CPU-bound or blocking I/O operations (e.g.,
accessing the cloud, database, Ô¨Ålesystem) in background and
inform the app when the result becomes available.
In order to make asynchronous programming easier, An-
droid provides three major async constructs: AsyncTask ,
IntentService andAsyncTaskLoader .AsyncTask
is designed for encapsulating short-running tasks while the
other two are good choices for long-running tasks. However, as
our formative study on a corpus of 611 shows, AsyncTask
is the most widely used construct, dominating by a factor of
3x over the other two choices combined.
However, if improperly used, AsyncTask can lead to
memory leaks, lost results, and wasted energy. Our previous
study [36] found that developers usually hold a reference to
a GUI component in an AsyncTask , so that they can easily
update GUI based on task results. However, there are several
instances in which the Android system can destroy and recreate
a GUI component while an AsyncTask is running: when a
user changes the screen orientation, or navigates to another
screen on the same app, switches to another app, clicks the‚ÄúHome‚Äù button and navigates back, etc. If the AsyncTask is
still running and it holds GUI reference, the destroyed GUI
cannot be garbage collected, which leads to memory leaks.
On the other hand, if an AsyncTask that Ô¨Ånished its job
updates a GUI component that has already been destroyed
and recreated, the update is sent to the destroyed GUI rather
than the recreated new one, and cannot be seen by the user.
Thus, the task result is lost, frustrating the user. Moreover,
the device wasted its energy to execute a task whose result
is never used. As pointed out by many forums [1], [4], [6],
this problem is widespread and is critical for long-running
tasks. IntentService andAsyncTaskLoader do not
have the above limitations because they do not hold a reference
to GUI and instead use a radically different mechanism to
communicate with the GUI. To avoid the above problems of
AsyncTask , developers must refactor AsyncTask code into
enhanced async constructs such as IntentService .
However, manually applying this refactoring is non-trivial
due to drastic changes in communication with GUI. This is a
challenging problem because a developer needs to transform a
shared-memory based communication (through access to the
same variables) into a distributed-style (through marshaling
objects on special channels). First, the developer needs to
determine which objects should Ô¨Çow into or escape from
IntentService . Unlike AsyncTask , the objects that Ô¨Çow
into or escape from IntentService should be serializable.
Determining this requires tracing the call graph and type
hierarchy. Second, the developer needs to rewire the channels
of communication. Whereas AsyncTask provides handy
event handlers for callback communication, IntentService
does not. IntentService and GUI can only communi-
cate through sending and receiving broadcast messages. This
requires developer to replace event handlers with semantic-
equivalent broadcast receivers, which is tedious. Third, the
developer needs to infer where to register the broadcast
receivers. Registering at inappropriate places can still lead
to losing task results.
In this paper we Ô¨Årst present a formative study to understand
how developers use different Android async constructs. We
analyzed a corpus of 611 most popular open-source Android
apps, comprising 6.47M SLOC. To further put the study
results in a broader context, we then surveyed 10 expert
Android developers. The formative study answers the following
questions:
RQ1: How do Android developers use asynchronous pro-
1gramming? Mapping the landscape of usage of async constructs
in Android is useful for researchers, library designers, and
is educational for developers. We found that 161 (32%) of
the studied apps use at least one asynchronous programming,
resulting in 1893 instances. Out of these, AsyncTask is the
most widely used.
RQ2: How do Android developers retroÔ¨Åt asynchrony into
existing apps? Must asynchrony be designed into a program,
or can it be retroÔ¨Åtted later? What are the most common
transformations to retroÔ¨Åt asynchrony? Answering this question
is important for software evolution researchers, as well as tool
builders. We found widespread use of refactorings, both from
sequential code to async, and from basic async to enhanced
async. We found the following code evolution scenario: devel-
opers Ô¨Årst convert sequential code to AsyncTask , and those
that continue to evolve the code for better use of asynchrony
refactor it further into enhanced constructs.
RQ3: How do expert developers interpret the disparity
in usage of async constructs? Answering this question can
provide educational value for developers. We found that
experts think AsyncTask is being overused at the expense
of other enhanced async constructs, and many inexperienced
Android developers do not know its problem. They also suggest
AsyncTask should only be considered for short-running
tasks (i.e., less than a second). They suggest that the current
guides and examples of IntentService are not enough, and
point out the need for refactoring tools to help unexperienced
developers use and learn about the enhanced async constructs
and the different style of communicating with the GUI.
Inspired by the results of our formative study, we designed,
developed, and evaluated ASYNC DROID , an automated refac-
toring tool that transforms shared-memory into distributed-style
communication in the context of Android async programming.
ASYNC DROID refactors AsyncTask intoIntentService .
We developed ASYNC DROID as an Eclipse plugin, thus it
offers all the convenience of a modern refactoring tool: it
enables the user to preview and undo changes and it preserves
formatting and comments. To use it the programmer only needs
to select an AsyncTask instance, then ASYNC DROID veriÔ¨Åes
that the transformation is safe, and rewrites the code if the
preconditions are met. However, if a precondition fails, it warns
the programmer and provides useful information that helps the
programmer Ô¨Åx the problem.
This paper makes the following contributions:
Problem Description: To the best of our knowledge, we are
the Ô¨Årst to propose solving the generic problem of converting
shared-memory into distributed-style communication through
refactoring. We do this in the context of Android async
programming.
Formative study: To the best of our knowledge, this paper
presents the Ô¨Årst quantitative and qualitative study to (i) map
the asynchronous landscape of Android, (ii) understand how
developers retroÔ¨Åt asynchrony, and (iii) learn about barriers
encountered by developers.
Algorithms: We designed the analysis and transforma-
tion algorithms to address the challenges of refactor-
ing from shared-memory communication (as used in
AsyncTask ) to distributed-style communication (as used inIntentService ). The algorithm determines the incoming
and outgoing objects in/from IntentService , replaces
event handlers with broadcast messages and receivers, and
infers where to register broadcast receivers.
Tool: We implemented the algorithms in ASYNC DROID , a
refactoring tool built on top of Eclipse refactoring engine.
Evaluation: We evaluated ASYNC DROID empirically, by
refactoring 97 AsyncTasks in 9 popular open-source Android
projects. We evaluate ASYNC DROID from three aspects. First,
45% of the AsyncTasks pass the refactoring preconditions,
and with minor manual changes another 10% AsyncTasks
can pass preconditions. This means the refactoring is highly
applicable. Second, ASYNC DROID changed 3386 SLOC in
77 Ô¨Åles in total, determined that 148 variables Ô¨Çow into
or escape from IntentService , moved 14 methods into
IntentService , and marked 18 types as serializable. This
task is very large and challenging to be performed manually,
butASYNC DROID performs each refactoring in a few seconds.
This shows that ASYNC DROID can save developer effort. Third,
we submitted 30 refactoring patches in 5 projects. 2 projects
replied and considered our changes to be correct, and they
accepted 9 refactorings. This shows ASYNC DROID is valuable.
The tool and subjects for our study and evaluation are
available at: http://mir.cs.illinois.edu/ yulin2/asyncdroid/
II. B ACKGROUND ON ANDROID
An Android app consists of four types of components:
activity ,service ,broadcast receiver andcontent provider . In
this paper, we focus on the Ô¨Årst three components. Activities
contain GUI widgets and represent the GUI screens that are
shown to users. Services do not provide GUI but perform
invisible operations (e.g., playing music). Broadcast receivers
provide a channel for activities andservices to communicate.
Similar to many other GUI frameworks such as Swing [13]
and SWT [17], Android uses an event-driven model. Events in
Android include lifecycle events (e.g., activity creation), user
actions (e.g., button click, menu selection), sensor inputs (e.g.,
GPS, orientation change), etc. Developers deÔ¨Åne event handlers
to respond to these events. For example, onCreate handler
is a lifecycle event handler and is invoked automatically by the
OS when an activity creation event occurs, while onClick
handler of a button is invoked when user clicks the button.
Android framework uses a single thread model to process
events [3]. When an application is launched, the system creates
aUI thread , in which it will run the application. This thread
is in charge of dispatching UI events to appropriate widgets
or lifecycle events to activities. It puts events into a single
event queue, dequeues events, and executes event handlers.
By default, all the event handlers deÔ¨Åned in the above three
components are processed by the UI thread one by one. Thus,
if any handler executes CPU or IO bound operations such as
network access, the UI thread will be blocked and no further
events can be processed. This will lead to unresponsiveness.
To avoid unresponsiveness, developers should exploit asyn-
chrony and schedule long-running tasks on background threads.
Android provides three major async constructs: AsyncTask ,
IntentService andAsyncTaskLoader .
2GUI update	 ¬†background       task	 ¬†
doInBackground	 ¬†
GUI	 ¬†
onPreExecute	 ¬†
background	 ¬†thread	 ¬†
OS/Library	 ¬†
CPU/IO operations	 ¬†
publishProgress	 ¬†
onProgressUpdate	 ¬†
onPostExecute	 ¬†
GUI update	 ¬†
GUI update	 ¬†AsyncTask.execute	 ¬†
AsyncTask	 ¬†(a) Where is AsyncTask code executing?
background       task	 ¬†
onHandleIntent	 ¬†
GUI	 ¬†
background	 ¬†thread	 ¬†
OS/Library	 ¬†
CPU/IO operations	 ¬†
onReceive	 ¬†
startService	 ¬†registerBroadcast       Receiver	 ¬†
sendBroadcast	 ¬†
Intent	 ¬†Service	 ¬†
Broadcast	 ¬†Receiver	 ¬†
GUI update	 ¬†
(b) Where is IntentService code executing?
Fig. 1: Flow of Android async constructs
A.AsyncTask
AsyncTask provides a doInBackground method for
encapsulating asynchronous work. It also provides four
event handlers which are run in the UI thread. The
doInBackground and these event handlers share variables
through which the background task can communicate with UI.
Figure 1(a) shows the Ô¨Çow of AsyncTask . AnAsyncTask
is started by invoking execute method. UI thread Ô¨Årst
executes onPreExecute handler. Then doInBackground
method is executed in a background thread . While the
task is executing, it can report its progress to the UI
thread by invoking publishProgress and implementing
onProgressUpdate handler. Finally, UI thread executes the
onPostExecute handler after doInBackground Ô¨Ånishes.
onPostExecute takes the task result as its parameter.
Notice that user can also cancel an AsyncTask . If a task
is canceled, onCancel handler will be executed instead of
onPostExecute .
Figure 2(a) shows a real-world example from owncloud-
android app, which is an Android client for a cloud server.
LogActivity starts a LoadingLogTask at line 11. The
task reads some Ô¨Åles in doInBackground (lines 31, 32)
and returns a string (line 35). onPostExecute takes this
string and uses it to update a text view (line 21). Notice that
LoadingLogTask is declared as a non-static inner class, so
it holds a reference to LogActivity .
Though AsyncTask is an easy-to-use construct, it is
ideally used for short tasks. Otherwise, the three problems
introduced in Sec. I (memory leaks, lost results, wasted energy)
can occur.B.IntentService
IntentService belongs to the Service component, but
its encapsulated operations are executed in a background
thread instead of UI thread. Figure 1(b) shows the Ô¨Çow of
IntentService . Service is started when startService
is invoked. Then onHandleIntent method is executed in a
background thread. Unlike AsyncTask ,IntentService
uses a distributed-style programming to communicate with UI
thread. To get the task result, the GUI that starts the service
should register a broadcast receiver. After the task is Ô¨Ånished,
IntentService sends its task result via sendBroadcast
method. Once the registered receiver receives (i.e., the GUI)
this broadcast, its onReceive method will be executed on
UI thread, so it can get the task result and update GUI.
Figure 2(b) shows an equivalent implementation of
LogActivity using IntentService . The background
task from Fig. 2(a) is now put into onHandleIntent method
(line 31). The result is wrapped by an Intent object, which
is marshalled and sent via broadcast (lines 34, 35). Intent is
analogous to a hash map whose key is a string and value is a seri-
alizable object (i.e., implements java.io.Serializable
orandroid.os.Parcelable ). It is the only medium
through which different components (e.g., service andbroadcast
receiver ) can exchange data. Finally, onReceive unwraps the
result and updates the text view (line 21). Notice that to register
a receiver, the developer should provide a Ô¨Ålter (represented by
a string) to specify which broadcast the receiver can receive.
For example, line 2 deÔ¨Ånes a Ô¨Ålter ‚ÄúFILTER‚Äù. Lines 8 and 29
use it to register receiver and send broadcast.
Since IntentService is not affected by the destruction
of the GUI objects that started it, it does not suffer from the
problems introduced in Sec. I. Thus, it can be safely used for
both short or long tasks.
C. AsyncTaskLoader
AsyncTaskLoader is built on top of AsyncTask ,
and it provides similar handlers as AsyncTask . Unlike
AsyncTask ,AsyncTaskLoader is lifecycle aware: An-
droid system binds/unbinds the background task with GUI
according to GUI‚Äôs lifecycle. Thus, it can also solve the prob-
lems we mentioned in Sec. I. However, AsyncTaskLoader
is introduced after Android 3.0, and it only supports two GUI
components: activity andfragment .
III. F ORMATIVE STUDY OF ANDROID ASYNCHRONY
We want to assess the state of practice async programming
in open-source Android apps. To obtain a deep understanding
of asynchronous programming practices in Android, we answer
three research questions. We now answer each of these
questions, by Ô¨Årst presenting the methodology and corpus,
and then the results.
RQ1: How do Android developers use asynchronous pro-
gramming?
To answer this question, we studied allasync constructs
provided by the standard Android libraries: AsyncTask ,
IntentService ,AsyncTaskLoader and also the legacy-
style Java Thread .
31public class LogActivity extends Activity {
2
3
4 private String mLogPath = FileStorageUtils.getLogPath();
5 protected void onCreate() {
6 ...
7 LoadingLogTask task = new LoadingLogTask(view);
8
9
10
11 task.execute();
12 }
13 private class LoadingLogTask extends AsyncTask {
14 private TextView textView;
15 private Exception exception;
16 public LoadingLogTask(TextView view){ textView = view; }
17 public void onPostExecute(String result) {
18
19
20 if(exception == null ) {
21 textView.setText(result);
22 }else Log.i(exception.getMessage());
23 }
24
25
26
27 public String doInBackground(String[] args) {
28
29
30 try {
31 File file = new File(mLogPath);
32 ...
33
34
35 return text;
36 }catch (Exception e) {
37 exception = e;
38
39
40 return null ;
41 }}}}
(a) Using AsyncTask1public class LogActivity extends Activity {
2 public static final FILTER = "LogActivity_receiver";
3 private LoadingLogReceiver receiver;
4 private String mLogPath = FileStorageUtils.getLogPath();
5 protected void onCreate() {
6 ...
7 receiver = new LoadingLogReceiver(view);
8 this .registerReceiver(receiver, new IntentFilter(FILTER);
9 Intent intent = new Intent( this , LoadingLogService. class );
10 intent.putExtra("mLogPath", mLogPath);
11 this .startService(intent);
12 }
13 private class LoadingLogReceiver extends BroadcastReceiver {
14 private TextView textView;
15 private Exception exception;
16 public LoadingLogReceiver(TextView view){ textView = view; }
17 public void onReceive(Context context, Intent intent) {
18 String text = intent.getStringExtra("RV");
19 Exception exception = (Exception)intent.getSerializableExtra("exception");
20 if(exception == null ) {
21 textView.setText(text);
22 }else Log.i(exception.getMessage());
23 }}}
24 public class LoadingLogService extends IntentService {
25 private String mLogPath;
26 private Exception exception;
27 public void onHandleIntent(Intent intent) {
28 this .mLogPath = intent.getStringExtra("mLogPath");
29 Intent result = new Intent(LogActivity.FILTER);
30 try {
31 File file = new File(mLogPath);
32 ...
33 result.putExtra("exception", exception);
34 result.putExtra("RV", text);
35 sendBroadcast(result);
36 }catch (Exception e) {
37 exception = e;
38 result.putExtra("exception", exception);
39 result.putExtra("RV", null );
40 sendBroadcast(result);
41 }}}
(b) Using IntentService
Fig. 2: Asynchronous code from owncloud-android app.onCreate method starts a background task to read a log Ô¨Åle, and
the result is shown in a TextView . (a) and (b) shows two semantic-equivalent implementations using AsyncTask and
IntentService , respectively.
Corpus-1. To collect representative Android apps, we chose
Github [11]. To distinguish Android apps in Github, we Ô¨Årst
searched all apps whose README Ô¨Åle contains the ‚ÄúAndroid‚Äù
keyword. Because we want to analyze recently updated apps, we
Ô¨Åltered for apps which have been modiÔ¨Åed at least once since
July 2014. Then, we sorted all these apps based on their star
count and gathered the top 500 apps. To make sure that these
apps have Android projects, we check whether every app has
at least one ‚ÄúAndroidManifest.xml‚Äù Ô¨Åle, which every Android
project must contain in its root directory. After all Ô¨Ålters, our
code corpus has 500 Android apps, comprising 4.69M non-
blank, non-comment SLOC (as reported by SLOCCount [14]).
Methodology. We built a tool, ASYNC ANALYZER to automat-
ically analyze the usage of async constructs in our corpus.
ASYNC ANALYZER uses Eclipse API for syntactic analysis. It
builds an abstract syntax tree (AST) for each source Ô¨Åle and
traverses ASTs to gather the usage statistics for the four async
constructs. Doing the analysis at the level of ASTs and not at
TABLE I: Usage of async constructs in the Corpus-1
# Instances # App App%
AsyncTask 938 97 19%
Thread 655 110 22%
IntentService 182 30 6%
AsyncTaskLoader 118 14 3%the textual level, improves the accuracy in several ways.
First, it is immune to noise generated by text that matches
names of the async constructs (e.g., import statements, com-
ments, variable names, etc.) but does not represent an instance
of an async construct. Second, it correctly accounts for
the ways in which developers instantiate async constructs:
via anonymous inner classes (e.g., myAsyncTask = new
AsyncTask(...) ) and via class subtyping (e.g., class
MyService extends IntentService .
Results. Table I tabulates the usage statistics of async constructs.
The three columns show the total number of construct instances,
the total number of apps with instances of the construct, and
the percentage of apps with instances of the construct.
As we see from the table, AsyncTask is the most popular
async construct in our corpus, based on the total number of in-
stances. However, if we count the total number of apps that use
at least one of these constructs, then the legacy-style Thread
is the most popular, despite the fact that Android already
provides three special async constructs. AsyncTaskLoader
andIntentService are not as popular as the other two.
RQ2: How do Android developers retroÔ¨Åt asynchrony into
existing apps?
Next we analyze how developers introduce async constructs
into their apps. We want to determine whether developers
introduced async constructs when (i) implementing new features
4TABLE II: How developers introduce AsyncTask and
IntentService in the Corpus-2
Type # Instances
Newly added AsyncTask 277
Refactor sequential code to AsyncTask 103
Refactor Thread toAsyncTask 18
Newly added IntentService 205
Refactor sequential code to IntentService 13
Refactor Thread toIntentService 18
Refactor AsyncTask toIntentService 9
Refactor AsyncTaskLoader toIntentService 5
(i.e., asynchrony was added to a new program element when
writing code from scratch), (ii) refactoring from existing
sequential code, (iii) refactoring from another existing async
construct.
In order to be able to detect transitions between basic and
enhanced async constructs, we need to Ô¨Ånd projects where
developers are aware that the enhanced constructs exist. Thus,
we use 2 different corpora to study IntentService and
AsyncTaskLoader , respectively:
Corpus-2. We collected 93 random open-source Android
apps from Github, comprising 1.54M SLOC, which use both
AsyncTask andIntentService constructs in their latest
snapshot.
Corpus-3. We collected 18 random open-source Android apps,
comprising 0.24M SLOC, which use both AsyncTask and
AsyncTaskLoader constructs in their latest snapshot.
Methodology. In order to identify transitions, we study not
only the latest version of the code, but also the Ô¨Årst version
where developers introduce async constructs. To do this, we
automatically searched the commit history of our corpora
through Gitective API [10], identiÔ¨Åed the commits that add
import statements to AsyncTask ,AsyncTaskLoader , or
IntentService . After automatically Ô¨Ånding commits that
introduce these async constructs, we manually inspected the
versions before and after such commits in order to understand
how these async constructs are introduced.
Results. Tables II and III show how AsyncTask ,
IntentService , and AsyncTaskLoader are introduced.
The results show that in many cases developers refactor
sequential code to AsyncTask . This observation conÔ¨Årms
our previous Ô¨Åndings [36]. However, the refactorings for
IntentService andAsyncTaskLoader mostly come
from other async constructs. This shows the following code
evolution scenario: developers Ô¨Årst convert sequential code to
AsyncTask , and those that continue to evolve the code for bet-
ter use of asynchrony refactor it further into IntentService
orAsyncTaskLoader .
RQ3: How do expert developers interpret the disparity in
usage of async constructs?
To shed light into this question, we conducted a survey
with expert Android developers.
Methodology. To Ô¨Ånd expert developers, we used Stack-
OverÔ¨Çow [15], which is the pioneering Q&A website forTABLE III: How developers introduce AsyncTask and
AsyncTaskLoader in the Corpus-3
Type # Instances
Newly added AsyncTask 73
Refactor sequential code to AsyncTask 24
Refactor Thread toAsyncTask 2
Newly added AsyncTaskLoader 15
Refactor sequential code to AsyncTaskLoader 3
Refactor AsyncTask toAsyncTaskLoader 10
Refactor Thread toAsyncTaskLoader 3
programming. In StackOverÔ¨Çow, users are sorted by their points
that they received from their answers for questions which are
associated with some tags. We contacted the top 10 users for
the ‚Äúandroid-async‚Äù tag and these 10 people are the ones who
answered the questions related to Android async programming
most. On average, each of them answered 2095 questions on
StackOverÔ¨Çow. We got replies from 5 of them, including the
author of a popular Android programming book [40].
Results. We asked three questions and summarized the experts‚Äô
answers below:
Q1) Why are there still lots of legacy-style Thread uses
even though Android provides three dedicated async constructs?
First, Thread construct has been around since the begin-
ning and many Android developers formerly developed Java
apps. Developers are very familiar with Thread and they do
not have time to learn something new, thus they continue using
it. Second, Thread is suitable for other scenarios, such as
parallelism and scheduled tasks.
Q2) Why are there many more AsyncTask uses than the
other two enhanced constructs even though AsyncTask may
lead to memory leaks, lost task results, and wasted energy?
They all agree that AsyncTask ‚Äúis being overused ‚Äù at
the expense of the other two enhanced constructs. As a main
reason, they invoke a historical account ‚Äú AsyncTask was
advertised to the developers a lot in Android documentation ‚Äù
and it ‚Äú got a lot of good press early on ‚Äù. On the other hand,
they thought ‚Äú many developers coming from desktop do not
realize the async nature of the Android memory management ‚Äù.
They also mention that AsyncTaskLoader has been around
only for a short time and is harder to implement, and Google
has not provided production-level examples of code that use
IntentService andAsyncTaskLoader .
As a guidance on Android async programming, they suggest
thatAsyncTask orThread should only be considered
for short tasks (i.e., less than one second). For the work
that will take more than a second, developers should use
IntentService .
Q3) Do you think that developers can beneÔ¨Åt from a
refactoring tool from AsyncTask toIntentService ?
They concluded that the technical challenges make the
automation really hard: ‚Äú it would be a very difÔ¨Åcult task, so the
end solution may appear very complicated ‚Äù, ‚Äúthat would be
quite a challenge to do automatically ‚Äù. One also said that ‚Äú it
may help beginner, but senior developers still like using their
5preferred way of writing async ‚Äù and another said ‚Äú it would
have to be very compelling for users to take their existing code
and change it - especially to something they do not already
understand ‚Äù.
IV. R EFACTORING ASYNC TASK TO INTENT SERVICE
Based on our Ô¨Åndings from Sec. III, developers tend to
choose AsyncTask for Android async programming. How-
ever,AsyncTask is not Ô¨Åt for long-running tasks, where devel-
opers should use IntentService orAsyncTaskLoader .
Inspired by these Ô¨Åndings, we propose ASYNC DROID , an
automated refactoring tool that transforms shared-memory into
distributed-style communication in the context of Android async
programming. ASYNC DROID refactors existing AsyncTask
intoIntentService . It helps developers migrate the inap-
propriately used AsyncTasks toIntentServices . Addi-
tionally, by looking at transformations performed (e.g., using
Eclipse‚Äôs preview refactoring feature), developers can educate
themselves on how to transform between AsyncTasks to
IntentServices .
A. Refactoring Challenges
There are three main challenges that make it hard to execute
the refactoring quick and Ô¨Çawlessly by hand. First, the developer
needs to determine which objects should be transferred into
IntentService andBroadcastReceiver , and how to
transfer them. Second, the developer should establish channels
to enable communication between IntentService and GUI.
Third, the developer must register the receiver properly in order
to receive the computation result from the established channel.
Transfer Objects from/to IntentService .As shown in
Sec. II, the non-local objects required by AsyncTask are
passed as method arguments or can be directly accessed as
Ô¨Åelds from the outer class. However, the objects that Ô¨Çow
into and escape from IntentService have to be wrapped
and sent via an Intent object. Similar to distributed-style
programming, objects transferred in this way are required to
be serializable [2].
For example, at line 31 in Fig. 2(a), Ô¨Åeld mLogPath
Ô¨Çows into doInBackground method. Thus, it should be
transferred to IntentService during refactoring (line 10
in Fig. 2(b)). Determining objects transfer requires a nontrivial
inter-procedural analysis of the code: the developer must
trace (i) the call graph to Ô¨Ågure out which objects Ô¨Çow into
IntentService andBroadcastReceiver , and (ii) type
hierarchy to check if the objects can be serialized.
Establish Channels for Communication. AsyncTask pro-
vides four handlers that enable developers to interact with GUI.
Background task and handlers exchange data by accessing the
shared memory. However, IntentService sends broadcast
toBroadcastReceiver to communicate with GUI. Thus,
the developer needs to rewire the channels of communi-
cation. To achieve this, one must split AsyncTask into
IntentService andBroadcastReceiver . Splitting an
AsyncTask includes moving the related Ô¨Åelds and methods
intoIntentService andBroadcastReceiver , which
requires to trace the call graph. Additionally, the developer has
to write extra code for sending broadcast, which makes the
refactoring more tedious.Where to Register the Receiver. In order to receive the
computation result from the channels, the GUI needs to register
aBroadcastReceiver . A naive approach is to register
at the original call site where the AsyncTask is created.
For example, in Fig. 2(a), the task is created in onCreate
at line 7. While using IntentService in Fig. 2(b), the
receiver is registered at the same place in onCreate (line
8). This approach only works when the original call site is
already in a lifecycle event handler, such as onCreate method.
Lifecycle events are guaranteed to be triggered by OS during
GUI recreation, so the receiver can be registered automatically.
However, if the call site is not in a lifecycle event handler,
the receiver cannot be registered unless the event is triggered
again after GUI recreation. For example, the call site can be in
theonClick listener of a button, so the receiver can only be
registered when the user clicks the button. If the GUI containing
the button is recreated while the background task is running, the
recreated GUI cannot receive the broadcast unless the button is
clicked again. Thus, the developer also needs to infer where to
register BroadcastReceiver during the refactoring. This
is a non-trivial insight for developers, because online documents
only show basic Android asynchronous programming scenarios,
where this is not a concern.
B.The Canonical Form of AsyncTask Code and Refactoring
Preconditions
A key insight in designing refactorings is that there is a
canonical form for input code [30], [42]. This canonical form
adheres to the preconditions of the refactoring, so that the
result of the transformation is indeed correct. This means that
if the input code is not in canonical form, it is necessary to
transform into canonical form before performing the refactoring.
ASYNC DROID has several preconditions, which together dictate
the canonical form which the source code must adhere to for
a successful transformation:
P1:All variables that Ô¨Çow into or escape from
doInBackground are or can be marked as serializable.
This is required because such variables need to be transferred
toIntentService and BroadcastReceiver via
marshalling/unmarshalling.
P2:All the methods invoked in doInBackground should also
be accessible by IntentService .Because most AsyncTasks
are declared as non-static inner classes, they can call methods
from the outer class. Since IntentService is not an inner class,
it needs to be able to call the same set of methods from the
outer class, so their visibility needs to be appropriate.
P3:The refactored task is directly extended from AsyncTask
and is not subclassed. This precondition prevents the refactoring
from breaking the inheritance relation and affecting other
AsyncTasks that are not refactored in the type hierarchy.
P4:AnAsyncTask instance is only used when invoking
AsyncTask.execute .For example, if a task instance is
used as a method argument or return value, ASYNC DROID
halts the refactoring to avoid changing the design contract of
the method. On the other hand, AsyncTask deÔ¨Ånes some
methods that are not supported by IntentService (e.g.,
AsyncTask.cancel ). If these methods are invoked on the
task instance, A SYNC DROID halts the refactoring.
6Figure 2(a) is a valid example of a target program that
meets all these preconditions, thus it can be refactored by
ASYNC DROID . We will see in Sec. V how many real-world
programs readily meet these preconditions.
C. The Refactoring Algorithm
ASYNC DROID takes the following steps to refactor an
AsycnTask toIntentService .
Analyzing Transferred Objects. Since doInBackground
andonHandleIntent are semantic-equivalent methods that
enclose background task, ASYNC DROID needs to analyze
doInbackground to determine which objects should be
transferred.
We deÔ¨Åne the Target Class ,Incoming Variables andOutgo-
ing Variables forIntentService as following:
DeÔ¨Ånition 1 (Target Class ( TC)):The top-level or static
inner class that creates and starts the AsyncTask .
DeÔ¨Ånition 2 (Incoming Variables ( IV)):The set of non-
local variables Ô¨Çow into doInBackground , which have to
be transferred to IntentService , is:
FTC[Ftask[Args task[LVTCM where:
FTCis the set ofTC‚Äôs Ô¨Åelds when the AsyncTask is a
non-static inner class of TC
Ftask is the set of AsyncTask ‚Äôs Ô¨Åelds that are initialized
in its constructors or onPreExecute handler
Args task are the arguments of AsyncTask.execute
method
LVTCM is the set of Ô¨Ånal local variables declared in
theTC‚Äôs method where the task is created, when the
AsyncTask is an anonymous inner class of TC
Notice that collecting IVrequires inter-procedural analysis
since doInBackground may invoke other methods deÔ¨Åned
inTCor the AsyncTask .
DeÔ¨Ånition 3 (Outgoing Variables ( OV)):The set of
variables that escape from doInBackground and
need to be transferred from IntentService to
BroadcastReceiver , is:
FM
TC[FM
task[RV where:
FM
TCis the set ofTC‚Äôs Ô¨Åelds that are modiÔ¨Åed in
doInBackground method
FM
task is the set of AsyncTask ‚Äôs Ô¨Åelds that are
modiÔ¨Åed in doInBackground method and used in
onPostExecute
RV is the return value of doInBackground method
An example ofOVis the return value text and a Ô¨Åeld
exception in Fig. 2(a) (lines 35, 37). FM
TCandFM
task are
OVbecause IntentService and GUI holds and operates
on different copies of objects due to (de)serialization. They
should be written back in BroadcastReceiver otherwise
the modiÔ¨Åcations are lost. Note that there is no way to write
back modiÔ¨Åed incoming LVTCM orArgs task due to the
communication mechanism of IntentService . However,we never Ô¨Ånd a case in practice where these two types of IV
are modiÔ¨Åed. A reasonable explanation is that modifying them
in a background thread can introduce data races.
As mentioned in Sec. IV-A , the objects in the IVandOV
set are required to be serializable. ASYNC DROID traverses the
type hierarchy and checks the serializability of an variable type
based on its deÔ¨Ånition [12]: a type is serializable if it implements
java.io.Serializable and all of its Ô¨Åelds‚Äô types are
serializable, unless the Ô¨Åeld is transient .ASYNC DROID also
refactors a type to implement java.io.Serializable if
its Ô¨Åelds conform to the deÔ¨Ånition but it has not implemented
yet. Note that when refactoring a type to be serializable,
ASYNC DROID also checks the serializability of all its subtypes
to guarantee the transformation is safe, and it only refactors
the type deÔ¨Åned in source code, not libraries. If any of the
IVandOVare not serializable or cannot be refactored, the
refactoring fails precondition P1.
Generating and Starting IntentService .First, for
the target AsyncTask ,ASYNC DROID creates a corre-
sponding IntentService class. The method body of
onHandleIntent is moved from doInBackground . Un-
likeAsyncTask ,IntentService class cannot be a non-
static inner class. Thus, ASYNC DROID creates it as an indepen-
dent class. ASYNC DROID creates a Ô¨Åeld for each variables in
IVandOV.ASYNC DROID adds statements to unwrap objects
inIVfromIntent at the beginning of onHandleIntent
(line 28 in Fig. 2(b)) . At every exit of doInBackground ,
ASYNC DROID creates an Intent to carryOV, and sends it
via broadcast (lines 33 to 35 and 38 to 40 in Fig. 2(b)).
Second, since doInBackground can invoke methods
deÔ¨Åned in AsyncTask orTC‚Äôs methods, ASYNC DROID
copies such methods into IntentService class. Note that
ASYNC DROID moves such methods instead of copying if
doInBackground is the only caller. However, if any of
such methods are in library code and cannot be copied, the
refactoring fails P2.
Finally, ASYNC DROID rewrites the call sites of
AsyncTask.execute into startService . This
includes creating the Intent object to wrap the IV(lines
9-11 in Fig. 2(b)).
Notice that in Android, starting a service or sending a
broadcast requests a Context object. ASYNC DROID checks
if (i)TCitself is a subclass of Context and (ii)TCcontains a
visible Context Ô¨Åeld or local variable, or a visible method that
returns a Context object. ASYNC DROID uses such Context
if there is any, otherwise the refactoring stops.
Creating and Registering Receiver. AsyncTask com-
municates with GUI through handlers. However, to re-
ceive task result from IntentService , the devel-
oper needs to establish a channel by registering a
BroadcastReceiver on GUI. ASYNC DROID rewrites the
target AsyncTask intoBroadcastReceiver class. It
keeps all the Ô¨Åelds, constructors and handlers deÔ¨Åned in
AsyncTask , and rewrites onPostExecute handler into
BroadcastReceiver.onReceive (lines 17 in Fig. 2(b)).
ASYNC DROID also inserts statements at the beginning of
onReceive to unwrapOV and writes them back to cor-
responding variables (lines 18, 19 in Fig. 2(b)).
7As discussed in Sec. IV-A , to avoid losing task result during
GUI destroying and recreation, the receiver should be registered
in lifecycle event handlers. ASYNC DROID declares the receiver
as a Ô¨Åeld ofTC(line 3 in Fig. 2(b)). It tries to move the
receiver creation and registration into TC‚Äôs lifecycle event
handlers unless they are already there. The following example
shows an AsyncTask that executes in a button‚Äôs onClick
listener. ASYNC DROID register the receiver in onCreate
lifecycle handler during refactoring instead of in the onClick
listener:
void onCreate()f
button.setOnClickListener() f() >fnew MyAsyncTask(...).execute(); gg
g
+
BroadcastReceiver receiver;
void onCreate()f
receiver = new MyBroadcastReceiver(...);
registerReceiver(receiver, ...);
button.setOnClickListener() f() >fstartService(...);gg
g
Note that aTCcan have multiple lifecycle event handlers.
ASYNC DROID registers the receiver in the handler that is
invoked Ô¨Årst by the system (e.g., onCreate ). A receiver
can be moved if and only if (i) the TCcontains lifecycle
event handlers, (ii) all variables transferred to the receiver are
still visible to it after moving, and (iii) the variables used by
receiver‚Äôs constructor are not redeÔ¨Åned in other lifecycle event
handlers. Rule (ii) guarantees syntax correction while rule (iii)
preserves the semantics of the refactoring. ASYNC DROID raises
a warning when a receiver cannot be moved.
A Ô¨Ålter is required when registering receiver. The Ô¨Ålter
speciÔ¨Åes which broadcast a receiver can receive. ASYNC DROID
concatenatesTCclass name and receiver name as Ô¨Ålter name,
and uses it to register receiver and send broadcast (lines 2, 8
and 29 in Fig. 2(b)).
Dealing with other AsyncTask handlers. In addition to
onPostExecute ,AsyncTask provides three other han-
dlers. Note that the generated BroadcastReceiver keeps
all these three handlers. For onPreExecute ,ASYNC DROID
inserts an invocation to this handler before starting the service.
ForonProgressUpdate ,ASYNC DROID Ô¨Årst rewrites
the call site of publishProgress intosendBroadcast ,
with the Ô¨Ålter set to ‚ÄúProgressUpdate‚Äù:
void doInBackground(...)fpublishProgress(arg); g
+
void onHandleIntent(...)fintent.setAction(‚ÄùProgressUpdate‚Äù);
intent.putExtra(‚ÄùtaskProgress‚Äù, arg); sendBroadcast(intent); g
Then in onReceive ,ASYNC DROID adds a branch to
intercept the ‚ÄúProgressUpdate‚Äù broadcast, and invokes
onProgressUpdate :
void onProgressUpdate(...) f...g
void onReceive(Context context, Intent intent) f...// code from onPostExecute g
+
void onProgressUpdate(...) f...g
void onReceive(Context context, Intent intent) f
if(intent.getAction().equals(‚ÄùProgressUpdate‚Äù)) f...; onProgressUpdate(...); g
else ...// code from onPostExecute g
ASYNC DROID ignores onCancelled handler, since An-
droid does not support canceling IntentService . Tasks
that invoke AsyncTask.cancel fails P4.TABLE IV: Nine popular Android projects from Github.
Project Name SLOC # AsyncTask # IntentService
owncloud-android 54918 6 0
open311-android 6642 5 0
prey-android-client 15361 8 1
SMSSync 16706 10 2
opentripplanner 11766 7 0
UltimateAndroid 228154 10 0
AntennaPod 38430 24 0
WhatAndroid 23643 20 0
TextSecure 40819 18 0
Total 436439 102 3
D. The Refactoring Implementation
We have implemented the refactoring as a plugin in the
Eclipse IDE, on top of Eclipse JDT [8] and refactoring
engine [7]. To use ASYNC DROID , the developer selects the
doInBackground method in the AsyncTask she wants to
transform, and then chooses CONVERT TOINTENT SERVICE
option from the refactoring menu.
V. E VALUATION
To empirically evaluate whether ASYNC DROID is useful,
we answer the following evaluation questions.
EQ1. Applicability: How applicable is the refactoring?
EQ2. Effort: How much programmer effort is saved by
ASYNC DROID when refactoring?
EQ3. Accuracy and Value: How accurate is ASYNC DROID
when performing a refactoring? Do developers think that the
refactorings performed by A SYNC DROID are useful?
A. Experimental Setup
To answer the above questions, we apply ASYNC DROID on
nine popular Github open-source Android projects. We selected
projects that use AsyncTask predominantly.
Table IV provides statistics about these projects. We
report the size (in SLOC), the number of AsyncTask and
IntentService instances that are used in each project.
For each project, we applied the ASYNC DROID to every
AsyncTask , except for the ones that have already been used
inService or retained Fragment . The lifecycle of such
AsyncTasks is independent of GUI‚Äôs lifecycle, so the they
do not suffer from the problems described in Sec. I.
We recorded several metrics for each refactoring. To
measure the applicability, we counted how many instances
met the refactoring preconditions and thus can be refactored.
We also analyzed the reasons why the remaining instances
cannot be refactored by ASYNC DROID . To measure refactoring
effort, we recorded the number of input and output variables
(IV,OV), serialized types, moved/copied methods and moved
receivers. We also counted the number of Ô¨Åles and SLOC that
are changed. To verify the accuracy and value, we manually
examine the correctness of all the refactored code. We also
sent 30 refactorings in 5 projects to developers and let them
judge the correctness and usefulness.
8TABLE V: Results of applying A SYNC DROID toAsyncTask in nine Android projects.
Project Name Applicability Effort # Task
Objects
Passed ConditionalPassed Failed P1 P2 P4 # IV #OV MovedMethodsSerializedTypesMoved &unmovedReceiversFilesMod.SLOCMod.
owncloud-android 1 2 3 4 1 2 6 5 1 0 2/0 3 193 3
open311-android 5 0 0 0 0 0 6 10 3 10 3/0 11 395 5
prey-android-client 7 1 0 1 0 0 11 9 5 2 4/2 10 392 8
SMSSync 1 0 6 6 0 0 0 1 0 0 1/0 1 41 1
opentripplanner 2 2 3 4 1 0 8 8 4 3 0/10 14 679 10
UltimateAndroid 5 1 4 2 2 2 6 6 0 0 4/0 7 310 8
AntennaPod 4 4 16 15 4 16 8 8 1 2 4/3 11 418 8
WhatAndroid 9 0 8 6 0 1 11 10 0 0 9/0 9 411 9
TextSecure 10 0 3 3 0 0 25 10 0 1 3/0 11 547 10
Total 44 10 43 41 7 21 81 67 14 18 30/15 77 3386 62
IV: incoming vars; OV: outgoing vars; P1: allIVandOV can be serializable; P2: all methods invoked by doInBackground are accessible in
IntentService ;P4:AsyncTask is only used when invoking AsyncTask.execute .
B. Results
Table V shows the result of applying ASYNC DROID on the
AsyncTask s in our corpus of 9 Android projects.
Applicability. We totally refactored 97 AsyncTask s in the
nine projects. Columns 2 and 4 show the number of instances
that pass and fail the refactoring preconditions. There are
44AsyncTasks that pass the preconditions, while 43 fail
the preconditions. This is not a limitation of ASYNC DROID ,
but such cases can not be converted from shared-memory to
distributed-style. Column 3 shows another 10 AsyncTasks
that fail the preconditions. However, these instances can
be refactored into canonical form with other well-known
refactorings (such as demoting Ô¨Åelds to local variables) so
thatASYNC DROID can refactor them. We show these instances
in the ‚Äúconditional pass‚Äù column.
We discovered two common transformations that convert
code into canonical form. First, an unserializable object
contained inIVbut not inOV, can be converted into a local
variable in doInBackground as long as it is only used by
doInBackground :
UnserializableObject object = new UnserializableObject(...);
void doInBackground(...)fobject.method();g
+void doInBackground(...)f
UnserializableObject object = new UnserializableObject(...); object.method(); g
Second, an AscynTask that is executed on a ThreadPool ,
can be changed to execute on a plain thread since
IntentService does not support ThreadPool s:
AsyncTask task = new AsyncTask()f...g; task.executeOnExecutor(...);
+
AsyncTask task = new AsyncTask()f...g; task.execute(...);
For refactorings that conditional-pass or fail the precondi-
tions, we analyzed which preconditions they violate. Columns
5 to 7 shows the number of instances that fail P1,P2andP4.
Note that one refactoring can violate multiple preconditions.
The result shows most failed refactorings violate P1. The
main reason is that the unserializable types in IVorOVare
declared in third-party libraries (such as network or database). Asource-to-source transformation tool like ASYNC DROID cannot
transform third-party binary code.
Preconditions P2and P4are violated mainly due to
methods cancel orexecuteOnExecutor that are invoked
either in doInBackground (thus failing P2) or on the task
instance (thus failing P4). Since these methods are speciÔ¨Åc to
AsyncTask andIntentService does not support them,
ASYNC DROID cannot transform those cases. For P3, we only
Ô¨Ånd one violation in WhatAndroid , so we do not show them
in Table V due to lack of space.
In terms of applicability, ASYNC DROID successfully refac-
tored 45.3% AscynTasks directly in nine projects. There are
10.3% AscynTasks that can also be refactored after convert-
ing them to canonical form. This shows that ASYNC DROID
has a high level of applicability.
Effort. We estimate the effort based on the 54 AsyncTasks
that pass or conditional pass the preconditions. In the last
column, we show the number of task instances that are created
for the 54 AsyncTasks . 62 task instances are created in
total, which means most AsyncTasks are used only at one
place. This observation conÔ¨Årms our previous study [36]:
developers tend to tightly bind an AsyncTask to only one
GUI component.
Columns 8 and 9 show the number of IVandOVfor each
project. For the 54 AsyncTasks , there are 81IVand 67
OV. Detecting them needs inter-procedural analysis. Moreover,
wrapping them into Intent object is also tedious.
Column 10 shows the methods that need to be moved
or copied into IntentService . We Ô¨Ånd 14 methods that
should be put into IntentService . Note that searching
these methods also needs inter-procedural analysis. Column 11
shows the number of types that are refactored to be serializable.
On average, each refactoring marks 0.33 types as serializable.
However, checking serializability is tedious since it requires
traversing the type hierarchy for each Ô¨Åeld.
Column 12 shows the number of BroadcastReceivers
that are moved into lifecycle event handlers by ASYNC DROID
(left side of slash), and that have to be moved but ASYNC DROID
9cannot move (right side of slash). Notice that for each
task instance, ASYNC DROID creates a corresponding receiver.
Therefore, it creates 62 receivers in total: 30 are moved, 15
cannot be moved, and the remaining 18 are already in lifecycle
event handlers. For the 15 unmoved receivers, GUI component
can lose task result if GUI destroying and recreation occurs
during task running, thus A SYNC DROID raises a warning.
Columns 13 and 14 show the number of Ô¨Åles and SLOC
that are changed during the 54 refactorings. On average, each
refactoring changes 1.43 Ô¨Åles and 63 SLOC. ASYNC DROID
helps developers change several SLOC, and such changes are
non-trivial. Thus, we conclude that ASYNC DROID can save
developers‚Äô effort.
Accuracy and Value. By manually examining the 54 refactored
instances applied by ASYNC DROID , we determined that no
compilation errors were introduced and the original semantics
ofAsyncTask are preserved.
We also submitted 30 refactorings in 5 projects to developers
through Github pull request. Given the large size of changes
in the patches that we submitted (on average a patch touching
10 Ô¨Åles with 403 additions and 210 deletions), we expected
that developers might not reply - as previous studies [35], [41]
show that open-source developers are more likely to respond
to small patches.
Despite this, by May 2015, we received replies from 2
projects. WhatAndroid [18] developers accepted the 9 refac-
torings we submitted by saying: ‚Äú this is an interesting set of
changes, AsyncTask can deÔ¨Ånitely be a pain to deal with ‚Äù and
‚Äúthese tasks are a good Ô¨Åt for migration to IntentServices and I
will migrate over to IntentServices ‚Äù.AntennaPod [5] developers
said their AsyncTasks are short: ‚Äú most of our tasks read
or write data from the database and should Ô¨Ånish well under
100ms ‚Äù. They think AsyncTasks work Ô¨Åne for their short-
running tasks while IntentService makes the code more
verbose. This shows that ASYNC DROID can produce accurate
and valuable results.
VI. R ELATED WORK
Performance analysis and testing for mobile apps. Liu et
al. [37] empirically study performance bug patterns in Android
apps, and conclude that executing long-running operations in
main thread is the main culprit. Berardinelli et al. [24] introduce
a framework for modeling and analyzing the performance
of context-aware mobile software systems. Arijo et al. [19]
propose a model-based approach to analyze the performance
of mobile apps, in which they represent state changes by graph
transformation. Muccini et al. [39] analyze the challenges
in testing mobile apps, including performance and memory
testing. Lillack et al. [34] propose an approach to track
load-time conÔ¨Åguration for Android apps, which can help
with tuning performance of Android apps. Yan et al. [48]
propose a test generation approach to detect memory leaks
for Android apps. However, our work is complementary to
previous approaches: we assume that developers have already
used the above techniques to detect responsiveness problems in
their apps, and now we enable developers to Ô¨Åx these problems
via refactoring for async programming.
Empirical study on concurrency, refactoring and API
usage. Li et al. [33] study and categorize bug characteristicsin modern software. Their result shows concurrency and
performance related bugs can have a severe impact on software.
Bavota et al. [23] investigate to what extent refactoring activities
induce faults. There are also several empirical studies [26], [29],
[31], [43] on the usage of libraries or programing language
constructs. Dyer et al. [28] analyzes 31k open-source Java
projects to Ô¨Ånd uses of new Java language features over time.
Buse et al. [25] propose an automatic technique for synthesizing
API usage examples and conduct a study on the generated
examples. Our previous work [35], [41] studies the misuses of
concurrent constructs in Java and C#. Our formative study on
usage of async constructs is similar with other studies in the
literature, but on different topics. In this work, we study how
developers use Android async constructs.
Refactoring for concurrency, parallelism and asynchrony.
The refactoring community has been recently pushing refac-
toring technology beyond its classic realm (i.e. in improving
software design) into improving non-functional qualities such
as performance through parallelism and concurrency. Schafer
et al. [45] propose a refactoring for replacing Java built-in
locks with more Ô¨Çexible locks. Wloka et al. [47] present a
refactoring for replacing global state with thread local state.
Schafer et al. [44] examine whether classic refactorings can be
safely applied to concurrent programs. Our group implemented
several implemented several concurrency-related refactorings
to improve throughput [27], [32], [46]. Our previous work [36]
presents a refactoring for Android developers to extract syn-
chronous code from UI thread into async code that inverts
the Ô¨Çow of control. In this work, we go one step further
and investigate a new scientiÔ¨Åc challenge: converting between
shared-memory communication with the UI into a distributed-
style as encompassed in two Android async constructs.
Compiling shared-memory to distributed-memory. Several
compiler techniques [20]‚Äì[22], [38], [50] have attempted
to translate shared-memory program to distributed-memory
program. However, these techniques target high performance
distributed computing. In our work, we presented a refactoring
from a shared-memory construct to a distributed-style construct
in the context of Android asynchrony.
VII. C ONCLUSIONS
Asynchronous execution of long-running tasks is crucial
for the now ubiquitous mobile and wearable apps. Despite
signiÔ¨Åcant efforts to educate Android app developers on how
to use async programming, developers can improperly use the
primary construct, AsyncTask , which can lead to memory
leaks, lost results, and wasted energy.
In this paper we take stake of the usage of async constructs
in a corpus of 611 widely-used Android apps. We discovered
that developers refactor their sync code into AsyncTask , and
some go further into using safer (but more complex) async con-
structs. To aid developers when converting to these constructs,
we designed, implemented, and evaluated ASYNC DROID . It
is a refactoring that converts from AsyncTask which uses a
shared-memory style of communication to IntentService
which uses a distributed style of communication. Our empirical
evaluation shows that ASYNC DROID is applicable and accu-
rate, and it saves effort. Developers already accepted several
refactorings generated by ASYNC DROID , which shows that it
is valuable.
10VIII. A CKNOWLEDGMENTS
We would like to thank Michael Hilton, Mihai Codoban,
Kendall Bailey, Shane McKee and Sruti Srinivasa for their
feedback on earlier versions of this paper. This research is
partly funded through NSF CCF-1439957 and CCF-1442157
grants, a SEIF award from Microsoft, and a gift grant from
Intel.
REFERENCES
[1] ‚ÄúActivitys, Threads and Memory Leaks,‚Äù May 2015, http://www.
androiddesignpatterns.com/2013/04/activitys-threads-memory-leaks.
html.
[2] ‚ÄúAndroid Intents and Intent Filters,‚Äù May 2015, http://developer.android.
com/guide/components/intents-Ô¨Ålters.html.
[3] ‚ÄúAndroid Processes and Threads,‚Äù May 2015, http://developer.android.
com/guide/components/processes-and-threads.html.
[4] ‚ÄúAndroid‚Äôs AsyncTask,‚Äù May 2015, http://steveliles.github.io/android s
asynctask.html.
[5] ‚ÄúAntennapod repository.‚Äù May 2015, https://github.com/AntennaPod/
AntennaPod.
[6] ‚ÄúThe dark side of AsyncTask,‚Äù May 2015, http://bon-app-etit.blogspot.
com/2013/04/the-dark-side-of-asynctask.html.
[7] ‚ÄúEclips Refactoring Engine,‚Äù May 2015, https://www.eclipse.org/articles/
Article-LTK/ltk.html.
[8] ‚ÄúEclipse Java development tools (JDT),‚Äù May 2015, http://www.eclipse.
org/jdt/.
[9] ‚ÄúGartner.‚Äù May 2015, http://www.gartner.com/newsroom/id/2153215.
[10] ‚ÄúGiTective,‚Äù May 2015, https://github.com/kevinsawicki/gitective.
[11] ‚ÄúGitHub,‚Äù May 2015, https://github.com.
[12] ‚ÄúJava Serializability,‚Äù May 2015, http://docs.oracle.com/javase/1.5.0/
docs/guide/serialization/spec/serial-arch.html.
[13] ‚ÄúJDK Swing Framework,‚Äù May 2015, http://docs.oracle.com/javase/6/
docs/technotes/guides/swing/.
[14] ‚ÄúSLOCCount,‚Äù May 2015, http://www.dwheeler.com/sloccount/.
[15] ‚ÄúStack OverÔ¨Çow.‚Äù May 2015, http://stackoverÔ¨Çow.com.
[16] ‚ÄúTablet Sales.‚Äù May 2015, http://www.gartner.com/newsroom/id/
2954317.
[17] ‚ÄúThe SWT Toolkit,‚Äù May 2015, http://eclipse.org/swt/.
[18] ‚ÄúWhatandroid repository.‚Äù May 2015, https://github.com/Gwindow/
WhatAndroid.
[19] N. Arijo, R. Heckel, M. Tribastone, and S. Gilmore, ‚ÄúModular perfor-
mance modelling for mobile applications,‚Äù in Proceedings of the 2nd
ACM/SPEC International Conference on Performance Engineering , ser.
ICPE ‚Äô11, 2011, pp. 329‚Äì334.
[20] P. Banerjee, J. Chandy, M. Gupta, J. Holm, A. Lain, D. Palermo,
S. Ramaswamy, and E. Su, ‚ÄúThe paradigm compiler for distributed-
memory message passing multicomputers,‚Äù IEEE Computer , vol. 28, pp.
37‚Äì47, 1994.
[21] A. Basumallik and R. Eigenmann, ‚ÄúTowards automatic translation of
openmp to mpi,‚Äù in Proceedings of the 19th Annual International
Conference on Supercomputing , ser. ICS ‚Äô05, 2005, pp. 189‚Äì198.
[22] ‚Äî‚Äî, ‚ÄúOptimizing irregular shared-memory applications for distributed-
memory systems,‚Äù in Proceedings of the Eleventh ACM SIGPLAN
Symposium on Principles and Practice of Parallel Programming , ser.
PPoPP ‚Äô06, 2006, pp. 119‚Äì128.
[23] G. Bavota, B. D. Carluccio, A. D. Lucia, M. D. Penta, R. Oliveto, and
O. Strollo, ‚ÄúWhen does a refactoring induce bugs? An empirical study,‚Äù
inProceedings of the IEEE International Working Conference on Source
Code Analysis and Manipulation , ser. SCAM ‚Äô12, 2012, pp. 104‚Äì113.
[24] L. Berardinelli, V . Cortellessa, and A. D. Marco, ‚ÄúPerformance modeling
and analysis of context-aware mobile software systems,‚Äù in Proceedings
of the International Conference on Fundamental Approaches to Software
Engineering , ser. FASE 10, 2010, pp. 353‚Äì367.
[25] R. P. L. Buse and W. Weimer, ‚ÄúSynthesizing API usage examples,‚Äù
inProceedings of the 34th International Conference on Software
Engineering , ser. ICSE ‚Äô12, 2012, pp. 782‚Äì792.[26] O. Calla ¬¥u, R. Robbes, E. Tanter, and D. R ¬®othlisberger, ‚ÄúHow developers
use the dynamic features of programming languages: The case of
Smalltalk,‚Äù in Proceedings of the 8th Working Conference on Mining
Software Repositories , ser. MSR ‚Äô11, 2011, pp. 23‚Äì32.
[27] D. Dig, J. Marrero, and M. Ernst, ‚ÄúRefactoring sequential Java code for
concurrency via concurrent libraries,‚Äù in Proceedings of the International
Conference on Software Engineering , ser. ICSE ‚Äô09, 2009, pp. 397‚Äì407.
[28] R. Dyer, H. Rajan, H. A. Nguyen, and T. N. Nguyen, ‚ÄúMining billions
of AST nodes to study actual and potential usage of Java language
features,‚Äù in Proceedings of the 36th International Conference on
Software Engineering , ser. ICSE 2014, 2014, pp. 779‚Äì790.
[29] M. Grechanik, C. McMillan, L. DeFerrari, M. Comi, S. Crespi,
D. Poshyvanyk, C. Fu, Q. Xie, and C. Ghezzi, ‚ÄúAn empirical investigation
into a large-scale java open source code repository,‚Äù in Proceedings of
the 2010 ACM-IEEE International Symposium on Empirical Software
Engineering and Measurement , ser. ESEM ‚Äô10, 2010, pp. 11:1‚Äì11:10.
[30] W. G. Griswold, ‚ÄúProgram restructuring as an aid to software mainte-
nance,‚Äù Ph.D. dissertation, University of Washington, Seattle, WA, USA,
1992.
[31] S. Karus and H. Gall, ‚ÄúA study of language usage evolution in open
source software,‚Äù in Proceedings of the 8th Working Conference on
Mining Software Repositories , ser. MSR ‚Äô11, 2011, pp. 13‚Äì22.
[32] F. Kjolstad, D. Dig, G. Acevedo, and M. Snir, ‚ÄúTransformation for
class immutability,‚Äù in Proceedings of the International Conference on
Software Engineering , ser. ICSE ‚Äô11, 2011, pp. 61‚Äì70.
[33] Z. Li, L. Tan, X. Wang, S. Lu, Y . Zhou, and C. Zhai, ‚ÄúHave things
changed now?: An empirical study of bug characteristics in modern open
source software,‚Äù in Proceedings of the 1st Workshop on Architectural
and System Support for Improving Software Dependability , ser. ASID
‚Äô06, 2006, pp. 25‚Äì33.
[34] M. Lillack, C. K ¬®astner, and E. Bodden, ‚ÄúTracking load-time conÔ¨Åguration
options,‚Äù in Proceedings of the 29th ACM/IEEE International Conference
on Automated Software Engineering , ser. ASE ‚Äô14, 2014, pp. 445‚Äì456.
[35] Y . Lin and D. Dig, ‚ÄúCheck-then-act misuse of Java concurrent collections,‚Äù
inProceedings of the International Conference on Software Testing,
VeriÔ¨Åcation and Validation , ser. ICST ‚Äô13, 2013, pp. 164‚Äì173.
[36] Y . Lin, C. Radoi, and D. Dig, ‚ÄúRetroÔ¨Åtting concurrency for android
applications through refactoring,‚Äù in Proceedings of the 22Nd ACM SIG-
SOFT International Symposium on Foundations of Software Engineering ,
ser. FSE 2014, 2014, pp. 341‚Äì352.
[37] Y . Liu, C. Xu, and S. Cheung, ‚ÄúCharacterizing and detecting performance
bugs for smartphone applications,‚Äù in Proceedings of the International
Conference on Software Engineering , ser. ICSE ‚Äô14, 2014, pp. 1013‚Äì
1024.
[38] S.-J. Min and R. Eigenmann, ‚ÄúOptimizing irregular shared-memory ap-
plications for clusters,‚Äù in Proceedings of the 22Nd Annual International
Conference on Supercomputing , ser. ICS ‚Äô08, 2008, pp. 256‚Äì265.
[39] H. Muccini, A. Di Francesco, and P. Esposito, ‚ÄúSoftware testing of
mobile applications: Challenges and future research directions,‚Äù in
Proceedings of the 7th International Workshop on Automation of Software
Test, ser. AST ‚Äô12, 2012, pp. 29‚Äì35.
[40] M. Murphy, The Busy Coder‚Äôs Guide to Android Development . Com-
monsWare, 2009.
[41] S. Okur, D. Hartveld, D. Dig, and A. Deursen, ‚ÄúA study and toolkit for
asynchronous programming in C#,‚Äù in Proceedings of the International
Conference on Software Engineering , ser. ICSE ‚Äô14, 2014, pp. 1117‚Äì
1127.
[42] W. F. Opdyke, ‚ÄúRefactoring object-oriented frameworks,‚Äù Ph.D. disserta-
tion, University of Illinois at Urbana-Champaign, Champaign, IL, USA,
1992.
[43] C. Parnin, C. Bird, and E. Murphy-Hill, ‚ÄúAdoption and use of Java
generics,‚Äù Empirical Softw. Engg. , vol. 18, no. 6, pp. 1047‚Äì1089, Dec.
2013.
[44] M. Sch ¬®afer, J. Dolby, M. Sridharan, E. Torlak, and F. Tip, ‚ÄúCorrect
refactoring of concurrent Java code,‚Äù in Proceedings of the 24th European
Conference on Object-oriented Programming , ser. ECOOP‚Äô10, 2010, pp.
225‚Äì249.
[45] M. Sch ¬®afer, M. Sridharan, J. Dolby, and F. Tip, ‚ÄúRefactoring Java
programs for Ô¨Çexible locking,‚Äù in Proceedings of the International
Conference on Software Engineering , ser. ICSE ‚Äô11, 2011, pp. 71‚Äì80.
11[46] M. Vakilian, D. Dig, R. Bocchino, J. Overbey, V . Adve, and R. John-
son, ‚ÄúInferring method effect summaries for nested heap regions,‚Äù in
Proceedings of the IEEE/ACM International Conference on Automated
Software Engineering , ser. ASE ‚Äô09, 2009, pp. 421‚Äì432.
[47] J. Wloka, M. Sridharan, and F. Tip, ‚ÄúRefactoring for reentrancy,‚Äù in
Proceedings of the ACM SIGSOFT Symposium on The Foundations of
Software Engineering , ser. FSE ‚Äô09, 2009, pp. 173‚Äì182.
[48] D. Yan, S. Yang, and A. Rountev, ‚ÄúSystematic testing for resource leaks
in Android applications,‚Äù in Proceedings of the IEEE 24th International
Symposium on Software Reliability Engineering , ser. ISSRE 13, 2013,pp. 411‚Äì420.
[49] S. Yang, D. Yan, and A. Rountev, ‚ÄúTesting for poor responsiveness in
Android applications,‚Äù in Proceedings of the International Workshop on
the Engineering of Mobile-Enabled Systems , ser. MOBS ‚Äô13, 2013, pp.
1‚Äì6.
[50] J. Zhu, J. HoeÔ¨Çinger, and D. Padua, ‚ÄúCompiling for a hybrid program-
ming model using the lmad representation,‚Äù in Proceedings of the 14th
International Conference on Languages and Compilers for Parallel
Computing , ser. LCPC ‚Äô01, 2003, pp. 321‚Äì335.
12