DroidStar: Callback Typestates for Android Classes
Arjun Radhakrishna∗
MicrosoftNicholas V. Lewchenko
University of Colorado BoulderShawn Meier
University of Colorado Boulder
Sergio Mover
University of Colorado BoulderKrishna Chaitanya Sripada
University of Colorado BoulderDamien Zufferey
Max Planck Institute for Software
Systems
Bor-Yuh Evan Chang
University of Colorado BoulderPavol Černý
University of Colorado Boulder
ABSTRACT
Event-drivenprogrammingframeworks,suchasAndroid,arebased
on components with asynchronous interfaces. The protocols for
interactingwiththesecomponentscanoftenbedescribedbyfinite-
state machines we dub callback typestates. Callback typestates are
akintoclassicaltypestates,withthedifferencethattheiroutputs
(callbacks) are produced asynchronously. While useful, these spec-
ifications are not commonly available, because writing them is
difficult and error-prone.
Our goal is to make the task of producing callback typestates
significantlyeasier.Wepresentacallbacktypestateassistanttool,
DroidStar, that requires only limited user interaction to produce
acallbacktypestate.Ourapproachisbasedonanactivelearning
algorithm,L∗.Weimprovedthe scalability ofequivalencequeries
(a key componentof L∗), thus makingactive learning tractable on
the Android system.
We use DroidStar to learn callback typestates for Android
classesbothforcaseswhereoneisalreadyprovidedbythedocu-
mentation, and for cases where the documentation is unclear. The
results show that DroidStar learns callback typestates accurately
and efficiently. Moreover, in several cases, the synthesized callback
typestates uncovered surprising and undocumented behaviors.
KEYWORDS
typestate, specification inference, Android, active learning
ACM Reference Format:
ArjunRadhakrishna,NicholasV.Lewchenko,ShawnMeier,SergioMover,
Krishna Chaitanya Sripada, Damien Zufferey, Bor-Yuh Evan Chang,
andPavolČerný.2018.DroidStar:CallbackTypestatesforAndroidClasses.
InICSE ’18: ICSE ’18: 40th International Conference on Software Engineer-
ing,May27-June3,2018,Gothenburg,Sweden. ACM,NewYork,NY,USA,
11 pages. https://doi.org/10.1145/3180155.3180232
∗ThisworkwasdonewhileArjunRadhakrishnawasemployedattheUniversityof
Pennsylvania.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
©2018 Copyright held by the owner/author(s). Publication rights licensed to the
Association for Computing Machinery.
ACM ISBN 978-1-4503-5638-1/18/05...$15.00
https://doi.org/10.1145/3180155.31802321 INTRODUCTION
Event-drivenprogrammingframeworksinteractwithclientcode
usingcallinsandcallbacks.Callinsareframeworkmethodsthatthe
client invokes and callbacks are client methods that the framework
invokes.Theclient-frameworkinteractionisoftengovernedbya
protocol that can be described by a finite-state machine we callcallback typestate. Callback typestates are akin to classical types-
tates [36], with the key difference that their outputs (callbacks) are
producedasynchronously.Ourgoalistomakethetaskofproducing
callback typestates significantly easier for developers.
Asanexampleofacallbacktypestate,consideratypicalinter-
actionbetweenaclientapplicationandtheframeworkwhenthe
client wants to use a particular service. The client asks for the ser-
vicetobestartedbyinvokingan startService() callin.Afterthe
framework receives the callin, it asynchronously starts initializing
theservice.Whentheserviceisstartedandreadytobeused,the
framework notifies the client by invoking a onServiceStarted()
callback. The client can then use the service. After the client fin-
ishesusingtheservice,itinvokesa shutdownService() callinto
ask the framework to stop the service.
Callback typestates. Callbacktypestatesareusefulinanumber
ofways,buttheyarenotoriouslyhardtoproduce.First,callback
typestatesareaformofdocumentation.Theytellclientapplication
programmersinwhatordertoinvokecallinsandwhichcallback
to expect. Android framework documentation for some classes
already usespictures very similar tocallback typestates (Figure1).
Second, callback typestates are useful in verification of client code.
They enable checking that a client uses the framework correctly.
Third,eventhoughweinferthecallbacktypestatesfromframework
code, they can be used for certain forms of framework verification.
Forinstance,onecaninfertypestatesfordifferentversionsofthe
framework, and check if the interface has changed.
Callback typestates are very hard to produce manually. On one
hand,inspectingcodetoseeinwhatsituationacallbackarrives,and
what callins are enabled after that is error-prone. Even developers
familiar with the framework often miss corner-case behaviors. On
theotherhand,obtainingthecallbacktypestatewithmanualtesting
ishard.Onewouldneedtorunallsequencesofcallins,mixedinsequence with the callbacks they produce. We systematize this
testing approach using an active learning algorithm.
Callback typestate assistant DroidStar .We present a tool that
makesproducingcallbacktypestatessignificantlyeasier.Ourtar-
getuserisadeveloperwhowroteanAndroidclassthatinteracts
11602018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Radhakrishna et al.
asynchronouslyusingcallbackswithclientcode.DroidStarisa
comprehensive framework for semi-automatically inferring call-
back typestates. The required user interaction happens in multiple
steps.Inthefirststep,theuserprovidescodesnippetstoperformlo-
cal tasks, such as code for class initialization and code for invoking
eachcallin(similarlyasinunittests).Thisissufficientaslongas
certainwidelyapplicableassumptionshold.First,weassumethat
eachsequenceofcallinsproducesasequenceofcallbacksdetermin-
istically(thisassumptionfailswhenforinstanceacallbackhasa
parameter that is ignored at first by DroidStar but that influences
the typestate). Second, we assume that the resulting typestate is
finite. If these assumptions fail, in the following steps, DroidStar
askstheuserforasolutiontotheproblem.Forinstance,onewayto
removenon-determinismistorefineonecallbackintotwoseparate
logical callbacks, based on the parameter values. This design al-
lowsDroidStartooffertheusercontroloverthefinalresultwhile
requiringonlylimited,local,insightfromtheuser.DroidStaris
available for download at https://github.com/cuplv/droidstar
Approach. We present a method for inferring typestates for An-
droidclasses.However,ourmethodisequallyapplicableinother
contexts.ThecorealgorithmisbasedonAngluin’sL∗algorithm[ 5]
adaptedtoMealymachines[ 32].Inthisalgorithm,alearnertriesto
learn a finite-state machine — in our case a callback typestate — by
asking a teacher membership and equivalence queries. Intuitively,
a membership query asks for outputs corresponding to a sequence
of input callins, and the equivalence query asks if the learned type-
state is correct. We note that the teacher does not need to know
the solution, but only needs to know how to answer the queries.
Thekeyquestionweanswerishowtoimplementoraclesforthe
membership and equivalence queries. We show how to implement
membership queries on Android classes using black-box testing.
Ourmaincontributionhereisanefficientalgorithmforimplement-
ing the equivalence query using membership query. The insighthere is that the number of membership queries can be bounded
byafunctionofanewboundwecallthe distinguisherbound.W e
empirically confirmed that for Android classes, the distinguisher
boundissignificantlysmallerthanthestateboundusedinprevi-
ous work [ 12,16]. Given that the number of required membership
queriesdependsexponentiallyonthedistinguisherbound,thenovel
bound is what enables our tool to scale to Android classes.
Results. WeuseDroidStartosynthesizecallbacktypestatesfor16
AndroidframeworkclassesandclassesfromAndroidlibraries.The
results show that DroidStar learns callback typestates accurately
andefficiently.Thisisconfirmedbydocumentation,codeinspec-
tion,andmanualcomparisontosimpleAndroidapplications.The
running time of DroidStar on these benchmarks ranged between
43secondsand72minutes,withonly3benchmarkstakingmore
than10minutes.Theusefulnessofthedistinguisherboundwasalso
confirmed.Concretely,usingpreviouslyknownbounds,learning
thecallbacktypestateforoneofourexamples(MediaPlayer)would
take more than a year, whereas with the distinguisher bound, this
example takes around 72 minutes. Furthermore, by inspecting our
typestates, we uncovered corner cases with surprising behavior
that areundocumented andmight even be considered asbugs in
somecases.Forinstance,forthecommonlyusedAsyncTaskclass,if
execute() iscalledafter cancel() butbeforethe onCancelled()
Figure 1: Part of MediaPlayer’s callback typestate from https://developer.
android.com/reference/android/media/MediaPlayer.html
callbackisreceived,itwillnotthrowanexceptionbutwillnever
causetheasynchronoustasktoberun.Section6presentsourresults
in more detail.
Contributions. Thecontributionsofthispaperare:(a)Weintro-
duce the notion of callback typestates and develop an approach,
basedontheL∗algorithm,toinferthem.(b)Weshowhowtoimple-
ment efficiently membership and equivalence oracles required by
the L∗algorithm. (c) We evaluate our approach on examples from
the Android framework, and show its accuracy and effectiveness.
2 WORKFLOW AND ILLUSTRATIVE
EXAMPLE
WeusetheAndroidFramework’s MediaPlayer classtoexplainthe
standard workflow for inferring callback typestate using Droid-
Star.Thisclassishighlystateful—itsinterfaceincludesmanymeth-
odsthatareonlymeaningfulorenabledinoneortwoparticular
player states—and makes extensive use of callins and callbacks
to handle the delays of loading and manipulating large media
files. These properties make callback typestate a perfect fit; in fact,
MediaPlayer has one of the very few examples where we found a
completecallbacktypestatespecificationintheAndroidlibraries
documentation. This callback typestate is shown in Figure 1.
InFigure1,callinsarerepresentedbysinglearrowsandcallbacks
by double arrows. Let us look at one part of the protocol that
governsthe client-frameworkinteraction.Theclient firstinvokes
the callin setDataSource() , and the protocol transitions to the
Initialized state. In this state, the client can invoke the callin
prepareAsync() , and the protocol transitions to the Preparing
state. Inthe Preparing state, theclient cannot invokeany callins,
buttheframeworkcaninvokethe onPrepared() callback,andthen
the protocol transitions to the Prepared state. At this point, the
client can invoke the start() callin, and the media startsplaying.
1161
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. DroidStar: Callback Typestates for Android Classes ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Our goal is to semi-automatically infer the callback typestate
from the figure using the tool DroidStar. The developer interacts
with DroidStar in several steps, which we describe now.
2.1 Developer-Provided Snippets
To apply DroidStar to the MediaPlayer class, the developer pro-
vides a number of code snippets detailed below that act as an inter-
face through which the tool can examine MediaPlayer instances.
Test object and environment instantiation. The main callback
typestate inference algorithm of DroidStar works roughly by re-
peatedly performing tests in the form of sequences of method calls
on an object of the given class, i.e., the MediaPlayer . Each test
mustbeginwithanidentical,isolated,classobject,andifnecessary,
a standard environment. In the first step, the developer provides a
snippet to initialize such an object and environment. In the case of
MediaPlayer ,thissnippetisassimpleasdiscardingtheprevious
instance, creating a new one with new MediaPlayer() , and regis-
teringthenecessarycallbacklisteners(explainedinthe Callback
instrumentation paragraph below). In some cases this snippet is
morecomplex.Asanexample,wecannotcreatenewinstancesof
theBluetoothAdapter class, so for that class this snippet would
need to bring the existing instance back to a uniform initial state.
Callindeclaration. Thenextstepistodeclarethealphabetof“in-
putsymbols”thatrepresentthecallinsintheinterfaceofourclass—
thefinal callbacktypestatewill be writtenusingthese symbols—
and map each symbol to the concrete code snippet it represents. In
most cases, there is a one-to-one correspondence between input
symbols and callin methods. For example, the code snippets associ-
ated with the input symbols prepare,prepareAsync , and startare
prepare();, prepareAsync();, and start();, respectively.
In some cases, such as when a callin takes a parameter, the
developer may instead map a symbol to a setof code snip-
pets representing alternative forms of the input which are sus-
pected to have different behavior. In the MediaPlayer class, the
setDataSource() callin method takes a URL argument. The de-
veloper might (rightly) believe that depending onthe validity and
reachabilityofthegivenURL,thebehaviorofthecallininthetypes-tatemaydiffer.Inthiscase,thedevelopermayprovidethetwosnip-
pets setDataSource(goodURL); and setDataSource(badURL);
for the same callin. DroidStar will consider both snippets for
generatingtests,andfurther,itwillindicateiftheybehavediffer-
ently with respect to the typestate. In case a difference is detected,
the “non-determinism” is handled as explained later in this section.
The complete set of input symbols which would be declared
andmappedforthe MediaPlayer classaresetDataSource, prepare,
prepareAsync, start,stop,reset,release, and pause.
Callback instrumentation. As for the callin methods, which act
astheinputsymbolsinthecallbacktypestate,thecallbackmethods
act as the output symbols in the callback typestate. The developer
specifies the set of output callback symbols and associated snip-pets to detect when callbacks occur. In most cases, this involvedadding the listeners for the callbacks in the initialization snippet
asmentioned above. Inthe MediaPlayer class,the outputsymbols
areonCompleted andonPrepared.2.2 Automated Callback-Typestate Inference
Once the developer provides the input and output symbols and the
associatedsnippets,DroidStarattemptstoautomaticallylearnthe
callback typestate following the framework of the L∗algorithm.
L∗inference. In L∗, the learner tests sequences of inputs until she
can form a consistent hypothesis automaton. Each such test (or
sequenceofinputs)iscalledamembershipquery.Onceahypothesis
automaton is produced, an equivalence query is performed; i.e.,
the hypothesis automaton is checked for equivalence with the true
callbacktypestate.Ifthetwoareequivalent,wearedone;otherwise,acounter-exampletestisreturnedfromwhichthetoollearns.Thisprocessrepeatsuntiltheproducedhypothesisautomatoniscorrect.
ForMediaPlayer , the first set of membership queries each con-
sist of a single different callin. Of these, only the query containing
setDataSource() succeeds. The learner continues with longer
membership queries while building the hypothesis automaton. For
instance, it learns that prepareAsync() and prepare() do not
lead to the same state: it is possible to invoke the start() after
prepare() ,butnotafter prepareAsync() .Oncetheclientreceives
the callback onPrepared() ,start() may be called. The learner
thushypothesizesatransitionfromthe Preparing tothe Prepared
ononPrepared() .Oncethehypothesisiscomplete,thelearnerasks
the equivalencequery. Initially,a counter-example toequivalence
isreturnedusingwhichthelearnerrefinesitshypothesis.Thefinal
solution is found after 5 equivalence queries.
Answering Equivalence Queries. The equivalence query, i.e.,
checking if a learned callback typestate is in fact the true callback
typestateisundecidableingeneral.However,assumingaboundonthesizeofthetypestate,theequivalencequerycanbeimplemented
using further testing. However, equivalence queries are still expen-
siveandtomakethempracticalwepresentannewoptimization
based on a distinguisher bound. We can observe in Figure 1 that for
anypairofstatesthereisatransitioninonestatewhichleadstoan
errorintheother.Thiscorrespondstoadistinguisherboundof1.
SmalldistinguisherboundsarisebecausetypestatesarenotrandomautomatabutpartofanAPIdesignedforeaseofuseandrobustness.SuchAPIsarecodeddefensivelyandarefail-fast[
35],i.e.,errorsare
not buffered but reported immediately. Each state in the typestate
hasaspecificfunctionandanassociatedsetofcallinsandcallbacks.
In automata terms, the alphabet is roughly the same size as the
number of states and each state has only a few transitions, making
anytwostateseasytodistinguish.InSection4.3,weexplainhow
tousethedistinguisherboundtoimplementequivalencequeries
and discuss why distinguisher bounds are small in practice.
2.3 Obstacles to Inference and Solutions
The L∗based callback typestate inference algorithm makes several
assumptionsaboutthebehavioroftheclassthatdonotalwayshold.DroidStarisdesignedtodetecttheseviolationsofassumptionsand
notifythedeveloper.Here,wediscusstwosuchassumptions,the
exceptionalsituationsthatarisewhentheassumptionsareviolated,
andtheadditionaldeveloperinterventionneededtohandlesuch
cases.
Non-determinism. In input-output automata learning theory,
non-determinismmakeslearningimpossible.Non-determinismis
1162
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Radhakrishna et al.
the possibility of the same sequence of input callins producing dif-
ferentsequencesofoutputcallbacksacrosstests.Non-determinism
maybeduetovarious controllable andnon-controllable factors.Con-
trollablefactorsincludecaseswherebehaviordependsonifafile
exists,ifaURLisreachable,etc.Ontheotherhand,non-controllable
factors include random number generators, device sensors, etc. Inpractice, most of the non-determinism was controllable.
The main technique for handling non-determinism is via refine-
mentofinputoroutputalphabets.Here,asinglecallinorcallbackis
split into multiple "logical" inputs or outputs.
(a) Controllable non-determinism can be eliminated by incor-
porating the controlling factor into the inputs. For example, inthe
SQLiteOpenHelper class, the behavior of the constructor
callinchangesdependingonifafile exists. Ho wever,aftersplitting
the callin into two separate callins constructor/fileExists and
constructor/noFileExists , the behavior of each of each callin
becomes deterministic with respect to these callins.
(b)Anothersourceofnon-determinismiswhenthesamecallback
is used to notify logically different events. For example, a classmay use a generic
onComplete callback which is passed a status
parameter that can have the values “Success” and “Failure”. Based
onthisvalue,differentfurthercallinsareenabled,leadingtonon-
determinism.Here,thedevelopermaymanuallyrefinethecallbackintotwooutputsymbols
onEvent/Success andonEvent/Failure ,
and the behavior is deterministic with respect to these.
Insummary,forcontrollablenon-determinism,theonusisonthe
developertoidentifythesourceofthedetectednon-determinism
andprovidearefinementoftheinputoroutputalphabetandcorre-spondingcodesnippetstocontrolthesource.Nogeneraltechnique
exists to handle non-controllable non-determinism, but specific
cases can be handled using techniques shown in Section 5.
Non-regularity. Another basic assumption that L∗based infer-
ence algorithm makes is that the callback typestate under con-
sideration is regular. This assumption is commonly violated inrequest-response style behavior of classes where the number of
responses(outputcallbacks)invokedisexactlyequaltothenumberofrequests(inputcallins).Oursolutiontothisproblemistorestrictthelearningtoasubsetoftheclassbehavior,suchasinputswithatmostonependingrequestcallinusingalearningpurpose[
1].These
restrictions makes the behavior regular and amenable to learning.
3 THE CALLBACK TYPESTATE LEARNING
PROBLEM
We introduce formal models of interfaces, define the callback type-
statelearningproblem,andpresentanimpossibilityresultabout
learning typestates. Callback typestates have both inputs (corre-
spondingtocallins)andoutputs(correspondingtocallbacks).Inau-tomatatheory,callbacktypestatescanbeseenasinterfaceautomata.
Interface automata [ 14] area well-studied model of automatathat
canproduceoutputsasynchronouslyw.r.t.inputs.Weusethename
callbacktypestatestoemphasizethattheyareageneralizationof
typestates as used in the programming languages literature.
3.1 Definitions and Problem Statement
Asynchronousinterfaces. LetΣiandΣobethesetofcallinsand
callbacksofanasynchronousinterface.Weabstractawayparameterand return values of callins and callbacks, and model a behavior of
theinterfaceasa traceτi=σ0...σn∈(Σi∪Σo)∗.TheinterfaceI
isgivenby /angbracketleftΣi,Σo,Πi/angbracketrightwhere Πi⊆{Σi∪Σo}∗istheprefix-closed
set of all feasible traces of the interface.
Interface automata. We use interface automata [ 14] to represent
asynchronous interfaces. An interface automaton Ais given by
/angbracketleftQ,qι,Σi,Σo,ΔA/angbracketrightwhere: (a) Qis a finite set of states,( b ) qι∈Q
istheinitialstate,( c) ΣiandΣoarefinitesetsof inputandoutput
symbols, and (d) ΔA⊆Q×{Σi∪Σo}×Qare a set of transitions.
AtraceτaofAis given by σ0...σnif∃q0...qn+1:q0=qι∧
∀i.(qi,σi,qi+1)∈ΔA.Traces(A) is the set of all traces of A.
Problem statement. Given an interface I=/angbracketleftΣi,Σo,Πi/angbracketright, thecall-
backtypestatelearningproblem istolearnaninterfaceautomaton A
suchthat Πi=Traces(A).Weallowthelearnertoaska membership
oracleMOracle[ I]membershipqueries.Fora membershipquery,the
learnerpicks mQuery =i0i1...in∈Σ∗
iandthemembershiporacle
MOracle[ I]returns either: (a) a trace τa∈Πiwhose sequence of
callins is exactly mQuery,o r(b )⊥ if no such trace exists.
3.2 The Theory and Practice of Learning
Typestates
Ingeneral,itisimpossibletolearncallbacktypestatesusingonly
membership queries; no finite set of membership queries fixes
a unique interface automaton. However, callback typestates canbe effectively learned given extra assumptions. We now analyze
the causes behind the impossibility and highlight the assumptions
necessary to overcome it.
Unbounded asynchrony. Membershipqueriesalonedonottell
usiftheinterfacewillemitmoreoutputs(callbacks)atanypoint
in time. Hence, we assume:
Assumption 1: Quiescence is observable.
Thisassumptioniscommonlyusedinioco-testingframeworks[ 37].
In our setting, we add an input waitand an output quiet, where
quietis returned after a waitonly if there are no other pending
callbacks. In practice, quietcan be implemented using timeouts,
i.e., pending callbacks are assumed to arrive within a fixed amount
of time. If no callbacks are seen within the timeout, quietis output.
Example 3.1. Usingwaitandquiet, in the MediaPlayer
example, we have that setDataSource() ·prepareAsync()
·onPrepared() ·wait·quietis a valid trace, but
setDataSource() ·prepareAsync() ·wait·quietis not.
Behavior unboundedness. For any set of membership queries,
letkbe the length of the longest query. It is not possible to find
out if the interface exhibits different behavior for queries much
longerthan k.Thisisatheoreticallimitation,butisnotaproblemin
practice [ 7]; most callback typestates are rather small ( ≤10 states).
Assumption 2: An upper bound on the size of
the typestate being learned is known.
Non-determinism. We need to be able to observe the systems’
behaviors to learn them and non-determinism can prevent that.
Therefore, we assume:
Assumption 3: The interface is deterministic.
We assume that for every trace τaof the interface, there is at most
one output o∈Σosuch that τa·o∈Πi. In practice, the non-
determinismproblemissomewhatalleviatedduetothenatureof
1163
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. DroidStar: Callback Typestates for Android Classes ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
callback typestates (see Section 5). See [ 1] for a detailed theoretical
discussion of how non-determinism affects learnability.
Example 3.2. Consider an interface with traces given by
(input·(out1|out2))∗.Allmembershipqueriesareasequenceof
input’s;however,itispossiblethatthemembershiporaclenever
returnsanytrace containing out2.Inthatcase,nolearnerwillbe
able to learn the interface exactly.
4 LEARNING CALLBACK TYPESTATES
USING L∗
GivenAssumption 1 andAssumption 3 , we first build a “syn-
chronousclosure”ofanasynchronousinterface(Section4.1).Then,
we show how to learn the synchronous closure effectively given
Assumption 2 (Section 4.2 and 4.3).
4.1 From Asynchronous to Synchronous
Interfaces
UsingAssumption1 and3, we build a synchronous version of an
interfaceinwhichinputsandoutputsstrictlyalternatefollowing
[1]. For synchronous interfaces, we can draw learningtechniques
from existing work [1, 5, 25, 32].
Define˜Σi=Σi∪{wait}and˜Σo=Σo∪{quiet,λ,err}. The
purposeoftheextrainputsandoutputsisdiscussedbelow.Forany
τs∈(˜Σi·˜Σo)∗,wedefine async(τs)=τa∈(Σi∪Σo)∗whereτais
had from τsby erasing all occurrences of wait,quiet,λ, anderr.
Synchronousclosures. Thesynchronousclosure Isofanasynchro-
nous interface I=/angbracketleftΣi,Σo,Πi/angbracketrightis given by /angbracketleft˜Σi,˜Σo,Πs/angbracketrightwhere˜Σi
and˜Σoare as above, and Πs⊆(˜Σi·˜Σo)∗is defined as the smallest
set satisfying the following:
ϵ∈Πs
τs∈Πs∧async(τs)·i∈Πi=⇒τs·i·λ∈Πs
τs∈Πs∧async(τs)·o∈Πi=⇒τs·wait·o∈Πs
τs∈Πs∧async(τs)·i/nelementΠi=⇒τs·i·err∈Πs
τs∈Πs∧o∈Σo∧async(τs)·o/nelementΠi=⇒τs·wait·quiet∈Πs
τs∈Πs∧τsends inerr=⇒τs·i·err∈Πs
Informally, in Is: (a) Each input is immediately followed by a
dummy output λ; (b) Each output is immediately preceded by a
waitinput wait;(c)Anycalltoaninputdisabledin Iisimmediately
followedbyan err.Further,alloutputsafteran errareerr’s.(d)Any
call towaitin a quiescent state is followed by quiet.
GivenMOracle[ I]andAssumption1 ,itiseasytoconstructthe
membership MOracle[ Is].Notethatdueto Assumption 3 ,there
is exactly one possible reply MOracle[ Is](mQuery) for each query
mQuery.Further,bytheconstructionofthesynchronousclosure,
the inputs and outputs in MOracle[I s](mQuery) alternate.
Mealy machines. We model synchronous interfaces using the
simpler formalism of Mealy machines rather than interface au-
tomata. A Mealy machine Mis a tuple /angbracketleftQ,qι,˜Σi,˜Σo,δ,Out/angbracketrightwhere:
(a)Q,qι,˜Σi, and˜Σoare states, initial state, inputs and outputs,
respectively, (b) δ:Q×˜Σi→Qis atransition function, and
(c)Out:Q×˜Σi→˜Σois anoutput function. We abuse notation
and write Out(q,i0...in)=o1...onandδ(q,i0...in)=q/primeif
∃q0,...,qn+1:q0=q∧qn+1=q/prime∧∀0≤i≤n:δ(qi,ii)=
qi+1∧Out(qi,ii)=oi. A sequence i0o0...inon∈(˜Σi·˜Σo)∗is a
traceofMifOut(qι,i0...in)=o0...on.We oftenabusenotationand write M(i0...in)instead of Out(qι,i0...in). We denote by
Traces(M) the set of all traces of M.
4.2 L∗: Learning Mealy Machines
For the sake of completeness, we describe the classical L∗learning
algorithm by Angluin [ 5] as adapted to Mealy machines in [ 32].
A reader familiar with the literature on inference of finite-state
machines may safely skip this subsection.
Fixanasynchronousinterface Ianditssynchronousclosure Is.
In L∗, in addition to a membership oracle MOracle[ Is], the learner
has access to an equivalence oracle EOracle[Is]. For an equivalence
query,thelearnerpassesaMealymachine MtoEOracle[Is],and
is inturn returned:(a) A counterexample input cex=i0...insuch
thatM(cex)=o0...onandMOracle[ Is](cex) /nequali0o0...inon,o r
(b)Correctif no such cexexists.
The full L∗algorithm is in Algorithm 1. In Algorithm 1, the
learner maintains: (a) a set SQ⊆˜Σ∗
iofstate-representatives (ini-
tially set to {ϵ}), (b) a set E⊆˜Σ∗
iofexperiments (initially set to ˜Σi),
and(c)an observationtable T:(SQ∪SQ·˜Σi)→(E→˜Σ∗o).Theob-
servation table maps each prefix wiand suffix etoT(wi)(e), where
T(wi)(e)isthesuffixoftheoutputsequenceof MOracle( wi·e)of
length|e|.Theentriesarecomputedbythesub-procedure FillTable.
Intuitively, SQrepresentMyhill-Nerodeequivalenceclassesof
theMealymachinethelearnerisconstructing,and Edistinguish
between the different classes. For SQto form valid set of Myhill-
Nerodeclasses,eachstaterepresentativeextendedwithaninput,
should be equivalent to some state representative. Hence, the algo-
rithm checks if each wi·i∈SQ·˜Σiis equivalent to some w/prime
i∈SQ
(line 3) under E, and if not, adds wi·itoSQ. If no such wi·iexists,
thelearnerconstructsaMealymachine MusingtheMyhill-Nerode
equivalenceclasses,andqueriestheequivalenceoracle(line5).If
the equivalence oracle returns a counterexample, the learner adds
asuffixofthecounterexampleto E;otherwise,itreturns M.Forthe
full description of the choice of suffix, see [30, 32].
Theorem 4.1 ([ 32]).Let there exist a Mealy machine Mwith
nstates such that Traces(M)is the set of traces of Is. Then, given
MOracle[ Is]andEOracle[Is],Algorithm1returns Mmakingatmost
|˜Σi|2n+|˜Σi|n2mmembership and nequivalence queries, where mis
the maximum length of counterexamples returned by EOracle[Is].I f
EOracle[I s]returns minimal counterexamples, m≤O(n).
4.3 An Equivalence Oracle Using Membership
Queries
Given a black-box interface in practice, it is not feasible to directly
implement the equivalence oracle required for the L∗algorithm.
Here,wedemonstrateamethodofimplementinganequivalence
oracleusingthemembershiporacleusingtheboundednessassump-
tion (Assumption 2 ). As before fix an asynchronous interface I
and its synchronous closure Is. Further, fix a target minimal Mealy
machineM∗such that Traces(M∗)is the set of traces of Is.
Statebounds. Astatebound ofBStateimpliesthatthetargetMealy
machineM∗has at most BStatestates. Given a state bound, we can
replaceanequivalencecheckwithanumberofmembershipqueries
using the following theorem.
1164
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Radhakrishna et al.
Algorithm 1 L∗for Mealy machines
Input:Membership oracle MOracle, Equivalence oracle EOracle
Output: Mealy machine M
1:SQ←{ϵ};E←˜Σi;T←FillTable( SQ,˜Σi,E,T)
2:whileTruedo
3:while ∃wi∈SQ,i∈˜Σi:∄w/prime
i∈SQ:T(wi·i)=T(w/prime
i)do
4: SQ←SQ∪{wi·i};FillTable( SQ,˜Σi,E,T)
5:M←BuildMM( SQ,˜Σi,T);cex←EOracle(M)
6:ifcex=Correctthen return M
7:E←E∪AnalyzeCex(cex ,M);FillTable( SQ,˜Σi,E,T)
8:function BuildMM( SQ,˜Σi,˜Σo,T)
9:Q←{ [wi]|wi∈SQ};qι←[ϵ]
10: ∀wi,i:δ([wi],i)←[w/prime
i]ifT(wi·i)=T(w/prime
i)
11: ∀wi,i:Out([wi],i)←oifT(wi)(i)=o
12:return/angbracketleftQ,qι,˜Σi,˜Σo,δ,Out/angbracketright
13:function AnalyzeCex(M,cex)
14:for all0≤i≤|cex|andwp
i,ws
isuch that wp
i·ws
i=
cex∧|wp
i|=1do
15: wp
o←M(wp
i);[wp/prime
i]←δ([ϵ],wp
o)
16: wso←last|ws
i|ofOut(MOracle( wp/prime
i·ws
i))
17: ifwp
o·wso/nequalOut(MOracle(cex)) then return ws
i
18:procedure FillTable(SQ,˜Σi,E,T)
19:for allwi∈SQ∪SQ·˜Σi,e∈Edo
20: T(wi)(e)←Suffix ofOut(MOracle( wi·e))of length |e|
Theorem 4.2. LetMandM/primebe Mealy machines having kand
k/primestates,respectively,suchthat ∃wi∈˜Σ∗
i:M(wi)/nequalM/prime(w/prime
i).Then,
thereexistsaninputword w/prime
ioflengthatmost k+k/prime−1suchthat
M(w/prime
i)/nequalM/prime(w/prime
i).
The proof is similar to the proof of the bound k+k/prime−2 for
finite automata (see [ 33, Theorem 3.10.5]). We can check equiv-
alence of M∗and any given Mby testing that they have equal
outputsonallinputsoflengthatmost kM+BState−1,i.e.,using
O(|˜Σi|BState+k−1)membershipqueries. Whilethissimplealgorithm
is easy to implement, it is inefficient and the number of required
membership queries make it infeasible to implement in practice.
Other algorithms based on state bounds have a similar problems
withefficiency(seeRemarkinSection4.3).Further,thealgorithm
doesnottakeadvantageofthestructureof M.Thefollowingdis-
cussion and algorithm rectifies these short-comings.
Distinguisherbounds. Adistinguisherbound ofBDist∈Nimplies
thatforeachpairofstates q∗
1,q∗
2inthetargetMealymachine M∗
canbedistinguishedbyaninputword wioflengthatmost BDist,
i.e.,Out∗(q∗
1,wi)/nequalOut∗(q∗
2,wi).Intuitively,asmalldistinguisher
boundimpliesthateachstateis“locally”different,i.e.,canbedis-
tinguished from others using small length input sequences. The
following theorem shows that a state bound implies a comparable
distinguisher bound.
Theorem 4.3. State bound kimplies distinguisher bound k−1.
Small distinguisher bound. In practice, distinguishers are much
smaller than the bound implied by the state bound. For the media-
player, the number of states is 10, but only distinguishers of length1 are required. This pattern tends to hold in general due to the
following principles of good interface design:
•Clearseparationoftheinterfacefunctions. Eachstateinthe
interfacehasaspecificfunctionandaspecificsetofcallins
andcallbacks.Thereislittlereuseofnamesacrossstate.The
typestate’s alphabet is roughly the same size as the number
of states.
•Fail-fast. Incorrect usage of the interface is not silently ig-
nored but reported as soon as possible. This makes it easier
todistinguishstatesasdisabledcallinsleaddirectlytoerrors.
•Nobuffering.Morethanjustfail-fast,agoodinterfaceisin-
teractiveandtheeffectofcallinsmustbeimmediatelyvisible
rather than hidden. A good interface is not a combination
lockthatrequiresmanyinputsthataresilentlystoredand
only acknowledged at the very end.
Thisobservationalsoisnotspecifictocallbackstypestatesandit
has been already observed for libraries [11].
Equivalencealgorithm. Algorithm2isanequivalenceoraclefor
Mealymachinesusingthemembershiporacle,givenadistinguisher
bound.First,itcomputesstaterepresentatives R:Q→˜Σ∗
i:foreach
q∈Q,δ(qι,R(q))=q(line 1). Then, for each transition in M, the
algorithmfirstcheckswhethertheoutputsymboliscorrect(line5).
Then, the algorithm checks the “fidelity” of the transition up to the
distinguisherbound,i.e.,whethertherepresentativeoftheprevious
state followed by the transition input, and the representative of
the next state can be distinguished using a suffix of length at most
BDist.Ifso,thealgorithmreturnsacounterexample.Ifnotransition
shows a different result, the algorithm returns Correct.
Two optimizations further reduce the number of membership
queries: (a) Quiescence transitions. Transitions with input waitand
outputquietneed not be checked at line 7; it is a no-op at the
interfacelevel.(b) Error transitions. Similarly, transitionwiththe
outputerrneednotbecheckedasanyextensionofanerrortrace
can only have error outputs.
Remark. NotethatifAlgorithm2isbeingcalledfromAlgorithm1,
thestaterepresentativesfromL∗canbeusedinsteadofrecomputing R
in line 1. Similarly, the counterexample analysis stage can be skipped
intheL∗algorithm,andtherelevantsuffixcanbedirectlyreturned
(suffixin lines 10 and 11; and iin line 5).
Theorem4.4. Assumingthedistinguisherboundof BDistforthe
target Mealy machine M∗, either (a) Algorithm 2 returns Correct
and∀wi∈˜Σ∗
i:M(wi)=M∗(wi), or (b) Algorithm 2 returns a
counterexample cexandM(cex) /nequalM∗(cex). Further, it performs at
most|Q|·|˜Σi|BDist+1membership queries.
Remark (Relation to conformance testing algorithms).
Notethattheproblembeingaddressedhere,i.e.,testingtheequivalence
of a given finite-state machine and a system whose behavior can
beobserved,isequivalenttotheconformancetestingproblemfrom
themodel-basedtestingliterature.However,severalpointsmakethe
existing conformance testing algorithms unsuitable in our setting.
Popularconformancetestingalgorithms,liketheW-method[ 12]
and the W p-method [ 16], are based on state bounds and have an
unavoidable O(|˜Σi|BState)factorinthecomplexity.Inourexperiments,
thelargesttypestatehad 10statesand 7inputs.The O(|˜Σi|BState)factor
leads to an infeasible (i.e., >108) number of membership queries.
1165
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. DroidStar: Callback Typestates for Android Classes ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Algorithm 2 Equivalence oracle with distinguisher bound
Input:Mealy machine M=/angbracketleftQ,qι,˜Σi,˜Σo,δ,Out/angbracketright, Distinguisher
boundBDist, and Membership oracle MOracle
Output: CorrectifM=M∗,o rcex∈˜Σ∗
is. t.M(cex) /nequalM∗(cex)
1:forallq∈QdoR(q)←wi|δ(qι,wi)=qs.t.|wi|isminimal
2:for allq∈Q,i∈˜Σido
3:wi←R(q)·i
4:ifOut(q,i)/nequallast symbol of Out(MOracle( wi·i))then
5: returnR(q)·i
6:q/prime←δ(q,i);w/prime
i←R(q/prime)
7:suffix←check(wi,w/prime
i)
8:ifsuffix /nequalCorrectthen
9: ifM(R(q)·i·suffix) /nequalOut(MOracle( R(q)·i·suffix))
then
10: returnR(q)·i·suffix
11: else return R(q/prime)·suffix
12:returnCorrect
13:function check(wi,w/prime
i)
14:for allsuffix∈˜Σ≤BDist
ido
15: wo←Out(MOracle( wi·suffix))
16: w/primeo←Out(MOracle( w/prime
i·suffix))
17: ifthe last|suffix|symbols of woandw/primeodifferthen
18: returnsuffix
19:returnCorrect
However, since distinguisher bounds are often much smaller than
state bounds, O(|˜Σi|BDist)membership queries are feasible (i.e., 103).
The W- and W p-methods cannot directly use distinguisher bounds.
The other common algorithm, the D-method [ 20,22], does not
apply in our setting either. The D-method is based on building a
distinguishing sequence, i.e., an input sequence which produces a
different sequence ofoutputs from every single state inthe machine.
However,forcallbacktypestates,suchsingledistinguishingsequences
do not exist in practice. For similar reasons, conformance testing
algorithms such as the UIO-method [31] do not apply either.
Inthislight,webelievethatAlgorithm2isanovelconformance
testing algorithm useful in specific settings where resets are inexpen-
sive and systems are designed to have small distinguisher bounds.
4.4 Putting It All Together
We now present the full callback typestate learning solution.
Theorem 4.5. Given a deterministic interface Iwith observable
quiescence and the membership oracle MOracle[ I]. Assume there
existsaninterfaceautomaton Awithnstateswithdistinguisherbound
BDistmodelingthetypestateof I.Interfaceautomaton Acanbelearned
withO(|Σi|·n3+n·|Σi|BDist)membership queries.
Proof sketch. Starting with an asynchronous interface Iand
a membership oracle MOracle[ I], usingAssumption 1 andAs-
sumption3 wecanconstructthemembershiporacle MOracle[ Is]
for the synchronous closure IsofI. Given the distinguisher bound
(orastateboundusing Assumption2 andTheorem4.3),wecan
constructanequivalenceoracle EOracle[Is]usingAlgorithm2.Ora-
clesMOracle[ Is]andEOracle[Is]canthenbeusedtolearnaMealy
machineMwiththesamesetoftracesas Is.ThisMealymachinecan be converted into the interface automata representing the call-
backtypestateof Iby:(a)Deletingalltransitionswithoutput err
and all self-loop transitions with output quiet, and (b) Replacing
all transitions with input waitwith the output of the transition.
5 ACTIVE LEARNING FOR ANDROID
We implemented our method in a tool called DroidStar. In this
sectionwedescribehowitworks,thepracticalchallengeswefaced
when working with Android, and our solutions to overcome them.
DroidStarisimplementedasanAndroidapplicationandlearns
callback typestates from within a live Android system.
5.1 Designing an Experiment
To learn a typestate, a DroidStar user creates a test configuration
(an extensionofthe LearningPurpose class)providing necessary
information about a Java class under study. If known, the distin-
guisherboundcanbeprovidedheredirectly;otherwise,itcanbe
obtainedfrom Assumption 2 byTheorem4.3.The instrumented
alphabet, also defined here, specifies an abstract alphabet for the
learningalgorithmandtranslationbetweentheabstractalphabet
andconcretecallins/callbacksoftheclassunderstudy.Severalotheroptionsareavailableforadjustingthelearning,themostimportant
being the quiescence timeout which determines Assumption 1.
5.2 Observing Asynchronous Callbacks
In our approach we assume bounded asynchrony (Assumption
1) and, therefore, we can observe when the interface does not
produce any new output (quiescence). We enforce this assumption
onarealsystemwithtimeouts:themembershipqueryalgorithm
waitsforanewoutputforafixedamountoftime tmax,assuming
that quiescence is reached when this time is elapsed. However,
Android does not provide any worst case execution time for the
asynchronous operations and we rely on the user to choose a largeenough
tmax. The membership query also assumes the existence of
a minimum time tminbefore a callback occurs. This ensures that
we can issue a membership query with two consecutive callins (so,
without a waitinput in between), i.e., we have the time to execute
the second callin before the output of the first callin.
ConsidertheMediaPlayerexamplefromSection2.Themember-
shipquery setDataSource(URL) ·wait·prepareAsync() ·wait
may not return the onPrepared() iftmaxis violated, i.e., if the
callbackdoesnotarrivebeforethetimeout,andwhiletestingitis
possiblethatthe prepareAsync() ·start()mightnotreturnan
error as expected if the lower bound tminis violated. To avoid such
issueswetrytocontroltheexecutionenvironmentandparameters
to ensure that callbacks occurred between tminandtmax. In the
MediaPlayer case, we must pick the right media source file.
5.3 Checking and Enforcing Our Assumptions
The simplest experiment to learn a class’s callback typestate ties
a single input symbol to each of its callins and a single output
symbol to each of its callbacks. However, many Android classes
have behaviors which cause this simple experiment to fail and
require more detailed experiments to succeed.
Themainchallengeswhendesigninganexperimentare(a) Non-
deterministic behaviors, i.e., the state of the device and external
1166
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Radhakrishna et al.
ctor getRDB onCreate
onCreate
ctor/fe
ctor/nfegetRDB
getRDBonCreate
onCreate
Figure 2: Eliminating non-determinism in SQLiteOpenHelper
eventsmayinfluenceanapplication.Theseelementsareinherently
non-deterministic; however, non-determinism violates Assump-
tion3.(b)Theparameterspace requiredtodriveconcretetestcases
to witness amembership query is potentiallyinfinite. Though we
have ignored callin parameters till now, they are a crucial issue
fortesting.(c)Theprotocolwearelearningmaynotbearegular
language. Note that this is a violation of Assumption 2.
Non-Deterministic Behavior. Non-deterministic behavior is dis-
allowed by our Assumption3 . However, to make this assumption
reasonable we must make non-determinism straightforward to
eliminate when it arises. We explain two primary classes of non-
deterministic behaviors and strategies to eliminate these behaviors.
The first class is related to controllable inputs and the second to
uncontrollable ones (such as inputs from the device sensors).
Because the learning algorithm cannot learn from non-
deterministic systems, DroidStar will terminate if such behav-
ior is detected. To assist in this process, DroidStar will report a
non-deterministic behavior is detected and display the disagreeing
sequences to the user. It detects this by caching all membershipqueries as input/output sequence pairs. When a new trace is ex-
plored, DroidStar checks that the trace prefixes are compatible
with the previously seen traces.
In the first case, a hidden (not modeled) controllable input influ-
ences the typestate. We resolve this non-determinism by manually
adding the input value and create a finer alphabet that explicate
the previously hidden state of the environment. For example, inthe class
SQLiteOpenHelper , the getReadableDatabase() may
eithertriggera onCreate() callbackornot,dependingonthepa-
rametervaluetoapreviouscallin( constructor )wasthenameof
anexistingdatabasefile.Hence,thebehaviorofthecallinisnon-
deterministic,dependingonthestatusofthedatabaseondisk.In
theSQLiteOpenHelper example,wesplitthe constructor callin
intoconstructor/fileExists andconstructor/noFileExists
andpasstherightparametervaluesineachcase.Withthisextra
modeling we can learn the interface automaton, since the execu-tion
getReadableDatabase() ends in two different states of the
automaton (see Figure 2).
Thesecondclassistheeffectoftheuncontrollableinputsona
typestate. Such effects, by definition, cannot be controlled or made
explicit prior to the call. We can sometimes to remove this non-
determinism by merging different outputs, considering them to be
the same. This is the dual of the previous solution.
An example is the SpeechRecognizer , for which calling
startListening() produces different callbacks depending on the
environment. As the environment cannot be reasonably controlled,
wemergeoutputstogotothesamestate.Ifoutputsareerroneously
merged, the non-determinism will propagate and continue to man-
ifest. Thus there is no risk of unsound results.Handling Callin Parameters. While parameter-less callins such
asstart() and stop()are common in Android classes, many
parameterizedcallinsexist.Becauseinputsymbolsneedtobelisted
in the experiment definition, the full range of parameter values
cannot be explored. In practice, we found that parameters often
havelittleeffectonthetypestateautomaton.Incaseswherethey
do affect the automaton, multiple input symbols can be defined to
representthesamemethodcalledwithseveraldifferentparameters.
This solution is similar to splitting on environmental effects when
dealing with non-determinism.
LearningfromNon-RegularLanguages. Anintrinsiclimitation
ofL∗isthatitlearnsonlyregularlanguages.However,someclasses
expose non-regular protocols. Common cases include situations
wherearequestcallininvoked ntimestriggerexactly nresponsecall-
backs. In the SpellCheckerSession class, callin getSuggestion()
and callback onGetSuggestions() follow this pattern.
However,eveninsuchcases,itcanbeusefultobuildaregularap-
proximation of the typestate. For example, restricting the typestate
to behaviors where there is at most one pending request (a regular
subset) provides all the information a programmer would need.
Hence, in such cases, we use the technique of learning purposes [1]
to learn a regular approximations of the infinite typestate.
6 EMPIRICAL EVALUATION
We evaluated our interface-learning technique, as implemented
in DroidStar, by using it to generate callback typestates for 16
classes,sampledfromtheAndroidFrameworkandpopularthird-
party libraries. DroidStar is available at https://github.com/cuplv/
droidstar. For these experiments, DroidStar was run on an LG
Nexus 5with Android frameworkversion 23. Ourevaluation was
designed to answer the following questions:
(1) Does our technique learn typestates efficiently?
(2)Whatsizedistinguisherboundsoccurinpractice?Dothey
support the small distinguisher bound hypothesis?
(3)Do the callback typestates we learn reveal interesting or
unintended behavior in the interfaces?
Methodology. Foreachexperimentalclass,wemanuallyidentified
areducedalphabetofrelevantcallinsandcallbacksandprovided
them (along with other necessary information as explained in Sec-
tion5)toDroidStarthroughinstancesofthe LearningPurpose .
Relevant callins and callbacks for these experiments were those
which, according to the available documentation, appeared to trig-
ger or depend on typestate changes (enabling or disabling of parts
oftheinterface).Eachinstanceconsistedof50 −200linesof,mostly
boiler-plate, Java or Scala code.
Toevaluateefficiency,wemeasuredtheoveralltimetakenfor
learning,aswellasthenumberofmembership(MQ)andequiva-
lencequeries(EQ).Thenumberofqueriesislikelyabettermeasure
ofperformancethanrunningtime:therunningtimedependson
externalfactors.Forexample,inthemediaplayertherunningtime
depends on play-length of the media file chosen during testing.
Wevalidatedtheaccuracyoflearnedcallbacktypestatesusing
two approaches. First, for classes whose documentation contains a
picture or a description of what effectively is an callback typestate,
wecomparedourresulttothedocumentation.Second,forallother
1167
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. DroidStar: Callback Typestates for Android Classes ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
classes we performed manual code inspection and ran test apps to
evaluate correctness of the produced typestates.
We used a distinguisher bound of 2 for our experiments; further,
we manually examined the learned typestate and recorded the
actual distinguisher bound. For our third question, i.e., does the
learnedcallbacktypestaterevealinterestingbehaviors,wemanually
examined the learned typestate, compared it against the official
Android documentation, and recorded discrepancies.
6.1 Results
We discuss the results (in Table 1) and our three questions.
Question 1: Efficiency. The table shows that our technique is rea-
sonably fast: most typestates learned within a few minutes. The
longestonetakes71minutes,stillapplicabletonightlytesting.The
numbers for membership queries are reported as X(Y)—Xis the
number of membership queries asked by the algorithm, while Y
is the number actually executed by the membership oracle. This
numberislowerasthesamequerymaybeaskedmultipletimes,
but is executed only once and the result is cached. For each bench-
mark, the accuracy validation showed that the produced typestate
matched the actual behavior.
Question 2:DistinguisherBounds. Asmentionedbefore,weuseda
distinguisher bound of 2 for all experiments. However, a manual
examinationofthelearnedcallbacktypestatesshowedthatabound
of 1 would be sufficient in all cases except the SQLiteOpenHelper
andthe OkHttpCall whereboundsof2arenecessary.Thissupports
ourconjecturethat,inpractice,interfacesaredesignedwitheach
state having a unique functionality (see Section 4.3).
Question 3: Interesting Learned Behavior. Of the three questions,
ourexperimentstoexaminethelearnedcallbacktypestateforin-
terestingbehaviorturnedouttobethemostfruitful,uncovering
several discrepancies, including corner cases, unintended behavior
and likely bugs, in the Android framework. These results reaffirm
the utility of ourmain goal of automatically learningcallback type-
state,andsuggestthatlearningtypestatecanservevaluableroles
in documentation and validation of callback interfaces.
In2cases,thelearnedtypestateanddocumentedbehaviordif-
feredincertaincornercases.Wecarefullyexaminedthedifferences,
by framework source examination and manually writing test appli-
cations,andfoundthatthelearnedtypestatewascorrectandthe
documentationwasfaulty.In5othercases,webelievetheimple-
mented behavior isnot the intended behavior, i.e.,these are likely
bugsintheAndroidimplementation.Thesediscrepanciesmostly
fall into two separate categories:
Incorrect documentation. In such cases, it turned out that the dis-
crepancy is minor and unlikely to produce bugs in client programs.
Raceconditions. Severallikelybugswereduetoaspecificcategoryof
race conditions. These interfaces have (a) a callin to start an action
and a corresponding callback which is invoked when the action
issuccessfullycompleted;(b)acallintocancelanalreadystarted
action and a corresponding callback which is invoked if the action
issuccessfullycancelled.Whenthestartactionandcancelaction
callins are called in sequence, the expectation is that exactly one of
the two callbacks are called. However, when the time between the
two callins is small, we were able to observe unexpected behaviors,
including neither or both callbacks being invoked.Start Cancelling
Running Cancelling’ Completedexecute() execute()cancel()
cancel() onCancelled()onCancelled()cancel()
cancel()
onPostExecute()
Figure 3: Learned typestate of the AsyncTask class
6.2 Selected Experiments
Of our 16 benchmarks, we briefly explain 5 here. The remaining
experiments are discussed in the technical report [29]1.
MediaPlayer. This is the class from the example in Section 2. The
learned typestate differs from the existing documentation. The
learnedtypestate:(a)hasthe pause()callinenabledinthe“play-
backcompleted”state,and(b)showsthat onPrepared() isinvoked
even after the synchronous callin prepare() . Though undocu-
mented, these behaviors are unlikely to cause any issues.
AsyncTask. The AsyncTask class turns arbitrary computations
into callback operations with progress tracking and results are de-
livered via callbacks. For our experiment, the computation is a sim-
ple timer. A constructed AsyncTask object performs its task when
itreceivesthe execute() callin,andtheneitherreturnstheresults
withthe onPostExecute() callback,orreturnsan onCancelled()
ifcancel() is called first. The object is single-use; after it has
returned a callback it will accept no further execute() commands.
Ourexperimentrevealedanunexpectededge-case:if execute()
is after cancel() but before the onCancelled() callback is re-
ceived, it will not throw an exception but will never cause the
callback task to be run. The learned interface is in Figure 3.
SpeechRecognizer. This classprovides an exampleof uncontrol-
lable environmental non-determinism. The particular callback that
signalstheendofthespeechsession—eitheran onResults() oran
onError() —isdeterminedbytheenvironment(inparticular,the
soundaroundthephoneduringthetest).Inthiscase,toreducethe
systemtoadeterministiconewecanlearn,wesupposedthatthe
state after an onResults() oronError() is the same and merged
the two callbacks into a single onFinished() symbol.
Our results revealed two interesting corner cases for the or-
dering of inputs. First, if an app calls cancel() between call-
ingstartListening() and receiving the onReadyForSpeech()
callback (represented by our “starting” output symbol), calling
startListening() again will have no effect until after a certain
amountoftime,asshownbythe waittransitionfromstate“Can-
celling”to“Finished”.Delaysinreadinesslikethiscanbegenerally
consideredbugs;ifasystemwillnotbereadyimmediatelyforin-
putsitshouldprovideacallbacktoannouncewhenthepreparations
are complete, so as not to invite race conditions.
Oursecondcornercaseiswheretheappcalls stopListening()
astheveryfirstinputonafreshSpeechRecognizer.Thiswillnot
throw an exception, but calling startListening() at any point
after will fail, making the object effectively dead.
1http://arxiv.org/abs/1701.07842
1168
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Radhakrishna et al.
Class name LP LoC statesTime (s) MQEQMQ per EQ BDist(needed)
AsyncTask 79 5 49 372 (94) 1356 (0) 2 (1)
BluetoothAdapter 161 121273 839 (157) 2420 (16) 2 (1)
CountDownTimer 94 3134 232 (61) 1224 (0) 2 (1)
DownloadManager 84 4136 192 (43) 1190 (0) 2 (1)
FileObserver 134 6104 743 (189) 2351 (8) 2 (1)
ImageLoader (UIL) 80 5 88663 (113) 2650 (33) 2 (1)
MediaCodec 152 83711354 (871) 1973 (482) 2 (1)
MediaPlayer 171 10426213553 (2372) 52545 (384) 2 (1)
MediaRecorder 131 82481512 (721) 11280 (545) 2 (1)
MediaScannerConnection 72 4200 403 (161) 2163 (57) 2 (1)
OkHttpCall (OkHttp) 79 6463 839 (166) 2812 (13) 2 (2)
RequestQueue (Volley) 79 4420 475 (117) 1460 (0) 2 (1)
SpeechRecognizer 168 73460 1968 (293) 3646 (35) 2 (1)
SpellCheckerSession 109 6133 798 (213) 4374 (8) 2 (1)
SQLiteOpenHelper 140 8 431364 (228) 2665 (6) 2 (2)
VelocityTracker 63 2 981204 (403) 11156 (0) 2 (1)
Table 1:DroidStar experimental results.
SQLiteOpenHelper. Thisclassprovidesamorestructuredinter-
face for apps to open and set up SQLite databases. It has callbacks
for different stages of database initialization, allowing apps to per-
form setup operations only as they are needed. When a database is
openedwith getWritableDatabase() ,acallback onConfigure()
is called, followed by an onCreate() if the database didn’t exist
yet or an onUpgrade() ifthedatabasehadalowerversionnumber
thanwaspassedtotheSQLiteOpenHelperconstructor,allfollowed
finallybyan onOpen() whenthedatabaseisreadyforreading.The
database can then be closed with a close().
Our experiment observed the callbacks when opening databases
indifferentstates(normal,non-existent,andoutofdate)andper-
forming the close() operation at different points in the sequence.
Wefoundthatoncethe getWritableDatabase() methodiscalled,
calling close() will not prevent the callbacks from being run.
VelocityTracker. Thisclasswasaspecialcasewithnoasynchro-
nous behavior; it was a test of our tool’s ability to infer traditional,
synchronous typestates. The class has a recycle() method that
we expected to disable the rest of the interface, but our tool found
(and manual tests confirmed) that the other methods can still be
calledafterrecycling.Thedocumentation’swarningthat“Youmust
not touch the object after calling [recycle]” is thus not enforced.
7 RELATED WORK
Workswhichautomaticallysynthesizespecificationsofthevalid
sequences of method calls (e.g. [ 3,4,18,34]) typically ignore the
asynchronous callbacks.
Static analysis has been successfully used to infer typestates
specifications(importantly,withoutcallbacks)[ 3,23,34].Thework
in[3]infersclassicaltypestatesforJavaclassesusingL∗.Incontrast,
our approach is based on testing. Therefore, we avoid the practical
problemofabstractingtheframeworkcode.Ontheotherhand,the
use of testing makes our L∗oracles sound only under assumptions.
Similarly,[ 19]usesL∗toinferclassicaltypestates,includingranges
of input parameters that affect behavior. However, their tool is
based on symbolic execution, and thus would not scale to systems
as large and complex as the Android Framework.Inferring interfaces using execution traces of client programs
using the framework is another common approach [ 2,4,13,17,28,
38,40,41]. In contrast to dynamic mining, we do not rely on the
availabilityofclientapplicationsorasetofexecutiontraces.The
L∗algorithm drives the testing.
Theanalysisofevent-drivenprogrammingframeworkshasre-
centlygainedalotofattention(e.g.[ 6,9,10,26]).However,none
of the existing works provide an automatic approach to synthesize
interfacespecifications.AnalysesofAndroidapplicationsmostly
focus oneither statically proving programcorrectness or security
properties [ 6,9,15,21,39] or dynamically detecting race condi-
tions [8,24,27]. These approaches manually hard-code the behav-
ior of the framework to increase the precision of the analysis. The
callback typestate specifications that we synthesize can be used
here, avoiding the manual specification process.
Our work builds on the seminal paper of Angluin [ 5] and the
subsequent extensions and optimizations. In particular, we build
onL∗forI/Oautomata[ 1,32].Theoptimizationsweuseinclude
thecounterexamplesuffixanalysisfrom[ 30]andtheoptimizations
for prefix-closed languages from [ 25]. The relation to conformance
testingmethods[ 12,16,20,22,31]hasbeendiscussedinSection4.3.
8 CONCLUSION
We have shown how to use active learning to infer callback types-
tates.Weintroducethenotionofdistinguisherboundwhichtake
advantageofgoodsoftwareengineeringpracticestomakeactive
learning tractable on the Android system. Our method is imple-
mentedinthefreelyavailabletoolcalledDroidStar.Thispaper
enablesseveralnewresearchdirections.Weplantoinvestigatemin-
ing parameters of callins from instrumented trace from real user
interactions,aswellastheinferenceofstructuredtypestates(for
instance, learning a typestate as a product of simpler typestates).
ACKNOWLEDGMENTS
ThisresearchwassupportedinpartbyDARPAunderagreement
FA8750-14-2-0263. Damien Zufferey was supported in part by the
European Research Council Grant Agreement No. 610150 (ERC
Synergy Grant ImPACT (http://www.impact-erc.eu/)).
1169
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. DroidStar: Callback Typestates for Android Classes ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
REFERENCES
[1]F. Aarts and F. Vaandrager. Learning I/O automata. In CONCUR 2010, pages
71–85, 2010.
[2]M. Acharya, T. Xie, and J. Xu. Mining interface specifications for generating
checkable robustness properties. In Software Reliability Engineering, 2006. ISSRE
’06. 17th International Symposium on, pages 311–320, Nov 2006.
[3]R. Alur, P. Černý, P. Madhusudan, and W. Nam. Synthesis of interface specifica-
tions for Java classes. In POPL, pages 98–109, 2005.
[4]Glenn Ammons,RastislavBodík, andJames R.Larus. Miningspecifications. In
POPL, POPL ’02, pages 4–16, New York, NY, USA, 2002. ACM.
[5]Dana Angluin. Learning regular sets from queries and counterexamples. Inf.
Comput., 75(2):87–106, 1987.
[6]Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bodden, Alexandre Bartel,
JacquesKlein, YvesLe Traon,Damien Octeau,and PatrickMcDaniel. FlowDroid:
Precise context, flow, field, object-sensitive and lifecycle-aware taint analysis for
Android apps. page 29, 2014.
[7]Nels E. Beckman, Duri Kim, and Jonathan Aldrich. An empirical study of object
protocols in the wild. In Mira Mezini, editor, ECOOP 2011 – Object-Oriented
Programming, pages 2–26, Berlin, Heidelberg, 2011. Springer Berlin Heidelberg.
[8]Pavol Bielik, Veselin Raychev, and Martin T. Vechev. Scalable race detection for
android applications. In OOPSLA, pages 332–348, 2015.
[9]SamBlackshear,Bor-YuhEvanChang,andManuSridharan. Selectivecontrol-
flow abstraction via jumping. pages 163–182, 2015.
[10]Yinzhi Cao, Yanick Fratantonio, Antonio Bianchi, Manuel Egele, Christopher
Kruegel, Giovanni Vigna, and Yan Chen. Edgeminer: Automatically detecting
implicit control flow transitions through the android framework. In NDSS, 2015.
[11]GuidoDeCaso,VictorBraberman,DiegoGarbervetsky,andSebastianUchitel.
Enabledness-based program abstractions for behavior validation. ACM Trans.
Softw. Eng. Methodol., 22(3):25:1–25:46, July 2013.
[12]T. S. Chow. Testing software design modeled by finite-state machines. IEEE
Transactions on Software Engineering, SE-4(3):178–187, May 1978.
[13]Valentin Dallmeier, Christian Lindig, Andrzej Wasylkowski, and Andreas Zeller.
Mining object behavior with adabu. In Proceedings of the 2006 International
Workshop on Dynamic Systems Analysis, WODA ’06, pages 17–24, New York, NY,
USA, 2006. ACM.
[14] L. de Alfaro and T. Henzinger. Interface automata. In FSE, pages 109–120, 2001.
[15]YuFeng,SaswatAnand,IsilDillig,andAlexAiken. Apposcopy:Semantics-based
detection of Android malware through static analysis. pages 576–587, 2014.
[16]S. Fujiwara, G. v. Bochmann, F. Khendek, M. Amalou, and A. Ghedamsi. Test
selectionbasedonfinitestatemodels. IEEETransactionsonSoftwareEngineering,
17(6):591–603, Jun 1991.
[17]MarkGabelandZhendongSu. Javert:Fullyautomaticminingofgeneraltemporalpropertiesfromdynamictraces. In Proceedingsofthe16thACMSIGSOFTInterna-
tional Symposium on Foundations of Software Engineering, SIGSOFT ’08/FSE-16,
pages 339–349, New York, NY, USA, 2008. ACM.
[18]MarkGabelandZhendongSu. Onlineinferenceandenforcementoftemporal
properties. In ICSE, ICSE ’10, pages 15–24, New York, NY, USA, 2010. ACM.
[19]DimitraGiannakopoulou,ZvonimirRakamarić,andVishwanathRaman. Sym-boliclearningofcomponentinterfaces. In Proceedingsofthe19thInternational
ConferenceonStaticAnalysis,SAS’12,pages248–264,Berlin,Heidelberg,2012.
Springer-Verlag.
[20]Guney Gonenc. A method for the design of fault detection experiments. IEEE
Trans. Computers, 19(6):551–558, 1970.
[21]Michael I. Gordon, Deokhwan Kim, Jeff Perkins, Limei Gilham, Nguyen Nguyen,
and Martin Rinard. Information-flow analysis of Android applications in Droid-
Safe. 2015.
[22]F.C.Hennie. Faultdetectingexperimentsforsequentialcircuits. In 5thAnnual
SymposiumonSwitchingCircuitTheoryandLogicalDesign,Princeton,NewJersey,
USA, November 11-13, 1964, pages 95–110, 1964.
[23]Thomas A. Henzinger, Ranjit Jhala, and Rupak Majumdar. Permissive interfaces.
InProceedings of the 10th European Software Engineering Conference Held Jointly
with 13th ACM SIGSOFT International Symposium on Foundations of Software
Engineering, ESEC/FSE-13, pages 31–40, New York, NY, USA, 2005. ACM.
[24]Chun-HungHsiao,JieYu,SatishNarayanasamy,ZiyunKong,CristianoL.Pereira,GillesA.Pokam,PeterM.Chen,andJasonFlinn. Racedetectionforevent-drivenmobile applications. In PLDI, PLDI ’14, pages 326–336, New York, NY, USA, 2014.
ACM.
[25]H.Hungar,O. Niese,and B.Steffen. Domain-specificoptimization inautomata
learning. In CAV, pages 315–327, 2003.
[26]MagnusMadsen,FrankTip,andOndřejLhoták. Staticanalysisofevent-driven
node.js javascript applications. In OOPSLA, OOPSLA 2015, pages 505–519, New
York, NY, USA, 2015. ACM.
[27]Pallavi Maiya, Aditya Kanade, and Rupak Majumdar. Race detection for android
applications. In PLDI 2014, page 34, 2014.
[28]Michael Pradel and Thomas R. Gross. Automatic generation of object usage
specifications from large method traces. In ASE, pages 371–382, 2009.[29]Arjun Radhakrishna, Nicholas Lewchenko, Shawn Meier, Sergio Mover, Kr-ishna Chaitanya Sripada, Damien Zufferey, Bor-Yuh Evan Chang, and Pavol
Černý. Learning asynchronous typestates for android classes. CoRR,
abs/1701.07842, 2017.
[30]Ronald L. Rivest and Robert E. Schapire. Inference of finite automata using
homing sequences. Inf. Comput., 103(2):299–347, 1993.
[31]Krishan K. Sabnani and Anton T. Dahbura. A new technique for generating
protocol test. In SIGCOMM ’85, Proceedings of the Ninth Symposium on Data
Communications,BritishColumbia,Canada,September10-12,1985,pages36–43,
1985.
[32]Muzammil Shahbaz and Roland Groz. Inferring mealy machines. In FM 2009:
FormalMethods,SecondWorldCongress,Eindhoven,TheNetherlands,November
2-6, 2009. Proceedings, pages 207–222, 2009.
[33]J.Shallit. ASecondCourseinFormalLanguagesandAutomataTheory. Cambridge
University Press, 2008.
[34]SharonShoham,EranYahav,StephenFink,andMarcoPistoia. Staticspecification
mining using automata-based abstractions. In ISSTA, ISSTA ’07, pages 174–184,
New York, NY, USA, 2007. ACM.
[35] J. Shore. Fail fast [software debugging]. IEEE Software, 21(5):21–25, Sept 2004.
[36]R.StromandS.Yemini. Typestate:Aprogramminglanguageconceptforenhanc-
ing software reliability. IEEE Trans. Software Eng., 12(1):157–171, 1986.
[37]Frits W. Vaandrager. On the relationship between process algebra and in-
put/output automata. In Proceedings of the Sixth Annual Symposium on Logic in
Computer Science (LICS ’91), Amsterdam, The Netherlands, July 15-18, 1991 , pages
387–398, 1991.
[38]N. Walkinshaw and K. Bogdanov. Inferring finite-state models with temporal
constraints. In Proceedingsofthe200823rdIEEE/ACMInternationalConferenceon
Automated Software Engineering, ASE ’08, pages 248–257, Washington, DC, USA,
2008. IEEE Computer Society.
[39]Fengguo Wei, Sankardas Roy, Xinming Ou, and Robby. Amandroid: A precise
and general inter-component data flow analysis framework for security vetting
of android apps. In SIGSAC, pages 1329–1341, 2014.
[40]JohnWhaley,MichaelC.Martin,andMonicaS.Lam. Automaticextractionof
object-oriented component interfaces. In Proceedings of the2002 ACM SIGSOFT
International Symposium on Software Testing and Analysis, ISSTA ’02, pages 218–
228, New York, NY, USA, 2002. ACM.
[41]JinlinYang,DavidEvans,DeepaliBhardwaj,ThirumaleshBhat,andManuvirDas.Perracotta:Miningtemporalapirulesfromimperfecttraces. In Proceedingsofthe
28thInternationalConferenceonSoftwareEngineering,ICSE’06,pages282–291,
New York, NY, USA, 2006. ACM.
1170
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. 