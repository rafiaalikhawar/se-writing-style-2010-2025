General LTL Speciﬁcation Mining
Caroline Lemieux Dennis Park Ivan Beschastnikh
Department of Computer Science
University of British Columbia
caro.lemieux@gmail.com, emaildpark@gmail.com, bestchai@cs.ubc.ca
Abstract —Temporal properties are useful for describing and
reasoning about software behavior, but developers rarely write
down temporal speciﬁcations of their systems. Prior work oninferring speciﬁcations developed tools to extract likely programspeciﬁcations that ﬁt particular kinds of tool-speciﬁc templates.
This paper introduces Texada, a new temporal speciﬁcation
mining tool for extracting speciﬁcations in linear temporal logic
(LTL) of arbitrary length and complexity. Texada takes a user-
deﬁned LTL property type template and a log of traces asinput and outputs a set of instantiations of the property type
(i.e., LTL formulas) that are true on the traces in the log.Texada also supports mining of almost invariants: properties with
imperfect conﬁdence. We formally describe Texada’s algorithmsand evaluate the tool’s performance and utility.
I. I NTRODUCTION
Specifying and reasoning about the temporal behavior of
programs has been extensively studied [15], [16], [26]. One
relatively recent idea is to mine a set of traces generated by a
program to derive likely temporal speciﬁcations of the program,
an API, or some other aspect of the software [1], [11], [19],
[38], [46], [47]. For example, consider Figure 1, which listsa set of traces modeled after the
/var/log/secure.log ﬁle in
OSX. These traces satisfy the temporal property “ guest login
is always followed by authorized ”, which indicates that either
the guest account has no password, or guest logins always
succeed. Mined speciﬁcations cannot replace manually written
speciﬁcations created by an expert since a property mined from
program traces could be a false positive1. Nevertheless, as
many programs lack formal speciﬁcations, mined speciﬁcations
are valuable and have been shown to be useful for a wide
assortment of tasks, such as testing [10], malware detection [9],
data structure repair [12], supporting program evolution [11],
[17], and debugging [21], [36], [37], [46].
We present Texada, a tool that implements algorithms to
mine linear temporal logic (LTL) [16] properties of arbitrary
length and complexity. Note the property “ guestlogin is
always followed by authorized ” mined from the log in
Figure 1 can be expressed in LTL as G(guest login →
XFauthorized) . Unlike prior speciﬁcation mining tools that
extract a speciﬁc set of pre-deﬁned templates [19]–[21], [46],
[47], Texada (1) mines speciﬁcations described by an arbitrary,
user-deﬁned, LTL template, and (2) can mine speciﬁcationsthat satisfy user-deﬁned support and conﬁdence thresholds.
While it is unclear how to adapt prior miners to extract
new patterns, such as the “1 cause-2 effect precedence chain
between two events” ( pprecedes s,tbetween qand r) [15],
Texada handles this pattern and all other LTL-based patterns by
design. We show that Texada’s property types are sufﬁcient to
1The property “ guest login is always followed by authorized ” would be
a false positive if a guest login in which the guest mistyped her password (and
failed to authenticate) is missing from the log.login attempt
auth failedlogin attemptauth failedlogin attemptauth failedlogin attemptauthorized
login attemptauth failedlogin attemptguest loginauthorizedlogin attemptguest loginauth failedauthorized
Log:
Property type:
TexadaTrace 1 Trace 2 Trace 3 Trace 4
Property instances:or  “    always followed by     ” G(x→XF y )
G(guest login →XFauthorized)x y
Fig. 1: (Top) Example inputs to Texada, including an authentication
log and a property type. (Bottom) Texada’s mined property instances
output: a set of LTL formulas based on the property type input template
that evaluates to true on each trace in the input log.
capture both existing temporal speciﬁcation taxonomies, like in
Perracotta [47] and Dwyer et al. [15], as well as speciﬁcation
templates used in custom-built miners like Synoptic [7].
Texada can also mine almost invariants, or temporal
properties that are falsiﬁed at some, but not all, locations
in the input traces. Texada provides two controls for this: the
conﬁdence threshold allows a user to control the degree to which
a mined property can be violated and the support threshold
allows a user to control the minimum number of times that a
property was validated. For example, if “ aalways followed by
b” is mined from a log, the user may interpret this property
differently depending on its support (i.e. the number of aevents
in the log): the more aevents there are, the less likely that “ a
always followed by b” is true by chance. More concretely, the
property G(guest login →XFauthorized) in Figure 1 has
conﬁdence of 1 on each trace in the ﬁgure, but a support of 0 on
traces 1 and 3, and a support of 1 on traces 2 and 4. As another
example, the property Fauthorized (eventually authorize
appears in the trace), has conﬁdence of 0.75 over the entire
log. Texada allows users to specify the support and conﬁdence
thresholds that all mined properties must satisfy. Mining of
almost invariants is supported by other speciﬁcation miners [11],
[18], [31], [47]. Our contribution is the generalization of the
calculation of these statistics to arbitrary LTL properties.
Texada takes two inputs (Figure 1): (1) log:at e x tﬁ l e
containing multiple traces, where each trace is a totally orderedsequence of string events, and (2) property type: an LTL formula
whose atomic propositions are variables. Texada’s output is a set
of LTL formulae, or property instances, that are instantiations
of the input property type. In a property instance, the variable
atomic propositions in the property type are replaced with eventsfrom the log. Texada guarantees that for the given support and
conﬁdence thresholds (1) every returned property instance is
valid on each of the input traces in the input log and (2) it
returns all valid property instances of the input property type.
2015 30th IEEE/ACM International Conference on Automated Software Engineering
978-1-5090-0025-8/15 $31.00 © 2015 IEEE
DOI 10.1109/ASE.2015.7181
Our work makes the following contributions:
⋆We present two algorithms, a linear miner and a map miner,
for mining arbitrary LTL speciﬁcations from logs of program
behavior. We also present an algorithm to compute support,
support potential, and conﬁdence statistics of arbitrary LTL
properties. These algorithms are implemented in the Texada
tool, which is released as open source [40] and includes
ready-to-use property types from [7], [15], [47].
⋆We evaluate Texada’s performance and show that it outper-
forms the specialized temporal property miner in Synoptic [7].
Texada runs in seconds on logs with hundreds of execution
traces with each trace containing thousands of events.
⋆We evaluate Texada’s utility by using it to (1) mine patterns
from a log of website activity studied by two previoustools [23], [35]. We ﬁnd that Texada-generated propertyinstances are concise and help to focus attention on therelevant properties with particular structure. (2) We use
Texada to conﬁrm expected properties of a solution to the
Sleeping Barber problem [13]. And, (3) we combine Texada
with Daikon [17] to infer likely data-temporal properties.
II. F ORMAL BACKGROUND
We begin by formally describing what we mean by a log,
a trace, and an event.
Deﬁnition 1 (Log, trace, and event) .The alphabet of events
is a ﬁnite alphabet of strings. An ordered sequence of events
is a trace, and a set of traces is a log.
We use the term event variable to denote a place holder for
an event. In this paper we use the beginning of the alphabet
to denote events (e.g., a,b,c) and the end of the alphabet to
denote event variables (e.g., x,y,z).
We use Linear Temporal Logic [16] to compactly specify
speciﬁcation templates, which we call property types.L T L
statements assert certain conditions over time and use the
operators until (U), next (X), eventually (F), always (G), weak
until (W), release (R), and strong release (M). In this paper
LTL will refer to a restricted version of Propositional TemporalLogic (PLTL), in which the non-temporal parts of formulae are
built from atomic propositions and the usual logic operators
∧,∨, and¬. We deﬁne LTL formulae in a manner similar to
Emerson [16].
Deﬁnition 2 (LTL formula) .An atomic proposition, p,i sa n
LTL formula. If pand qare LTL formulae, so are p∧q,¬p,
pUq, and X p.
We can then deﬁne all other logic operators, like ∨and→.
Any non-temporal formula is true on a trace if it is true on the
ﬁrst event of the trace. The other temporal operators follow:
-Until: pUq, holds if there is an event in the trace where
qholds and if pis true on all events up to the ﬁrst event
where qholds.
-Next: Xp, holds if pis true on the event immediately
following the trace’s ﬁrst event.
-Finally/Eventually: Fp≡true Up, holds if there exists a
future event in the trace where pis true.
-Globally/Always: Gp≡¬ F(¬ p), holds on a trace if pholds
on all events in the trace.
The operators W,R, and Mare variations of until and are
deﬁned as in [2]. Standard LTL semantics assume an inﬁnite
sequence of events. Since Texada mines speciﬁcations fromﬁnite traces, we redeﬁne the LTL semantics to ﬁt our context
(see end of this section).
A property type captures the temporal relationships between
a set of event variables and (optionally) a set of events.
Deﬁnition 3 (Property type) .Aproperty type is an LTL formula
in which all of the atomic propositions are either event variables
or events.
For example, the property type G(x→XFy)represents
the “ xis always followed by y” relationship between xand y.
Referring to events in a property type allows us to, amongst
other things, establish scope. For example, if we are interested
in expressing “ xis always followed by y” between open ﬁle
(denoted of) and close ﬁle (denoted cf), then we can use these
events in the property type to create a scope (as in [15]):
G((of∧¬cf∧Fcf)→(x→(¬cf U(y∧¬cf))) Ucf
A property instance corresponds to a property type and has
identical LTL structure, but with each event variable in the
property type replaced by an event. Following Beschastnikh et
al. [5], we call the map which associates each variable with
an event a binding. For example, a property instance of the
“xis always followed by y” property type in a program trace
may be “ open ﬁle is always followed by close ﬁle”, i.e.,
G(open file→XFclose file).
Deﬁnition 4 (Property instance) .LetΠbe a property type.
Then, πis a property instance ofΠ(or an instantiation ofΠ)
ifπis an LTL formula that is identical to Πin structure and
in which all of the atomic propositions are events.
Deﬁnition 5 (Binding) .Let Ebe an alphabet of events and
letVbe a ﬁnite set of event variables. Then, a binding2is a
function b:V→E.
Applying a binding to the variables in a property type creates
a property instance corresponding to that binding: applying
{x→open file, y→close file} toG(x→XFy)creates
the property instance G(open file→XFclose file) .W e
use “property” in place of “property instance” and “property
type” when the context makes it clear which one we mean.
We say that a binding and its corresponding property
instance are valid on a log if the property instance holds on
each trace in the log. Generally, we are interested in mining all
of the valid property instances. But, we may also be interested
in those instances that are most likely (e.g., because a log is
incomplete or contains anomalous or buggy executions). To
help with these cases we generalize the notion of validity.
Deﬁnition 6 (Trace support potential) .The support potential
of a property instance πon a trace tis the number of time
points of twhich could falsify π.
Deﬁnition 7 (Trace support) .The support of a property instance
πon a trace tis the number of time points of twhich could
falsify π,b u tdo not falsify π.
To explain these further, consider checking Ga on some
trace. One way to do this is to iterate along the trace and
check whether the event at each position is a. If at any time
point¬ais found to be true, Gais falsiﬁed. Therefore, for Ga,
2A binding may bind multiple variables in Vto the same event. This may
produce trivial results: for example, G(x→Fy), a common formulation of
always followed by, is true any time xand ybind to the same event. This is
why in this paper we use XF yinstead of F y, i.e., G(x →XFy).
821 functiontexada(property type string prop s,log L,thresholds T)
2 // Returns: valid property instances of prop sonL.
3 letvalid instances =[ ]
4 prop =parse−property−type (prop s)
5 traces =parse−log(L )
6 for binding ingen−binding( prop.vars ,traces.events)
7 prop instance =instantiate (prop, binding)
8 valid =check (prop instance, traces, T)
9 if(valid )valid instances.add( prop instance)
10 return valid instances
Fig. 2: A high-level description of Texada. The two versions of the
check function (line 8) are listed in Figures 3 (linear miner) and
Figure 6 (map miner).
the evaluation of aat each position in the trace is potentially
falsiﬁable. So the support potential for this property instance
is the length of the trace, and its support is the number of
positions in the trace at which aappears. In general, the number
of falsiﬁable time points depends on both the structure of the
property instance and the sequence of events in the trace. We
elaborate further on falsiﬁable time points in Section IV-A.
We use trace conﬁdence to denote the ratio of trace support
to trace support potential (if both are 0, conﬁdence is 1). A
conﬁdence of 1 means that the instance is not falsiﬁed at any
time point. We say that a property instance is vacuously true
if its support and support potential are both 0. The global
support and global support potential of a property instance is
the sum of its support/support potential over all traces in the
log; global conﬁdence is the ratio of global support to global
support potential. We use the terms support, support potential,
and conﬁdence when it is clear from the context if we mean
the trace-based or global versions.
We can now formulate Texada’s objective. Texada takes as
inputs a log, a property type, and support, support potential,
and conﬁdence thresholds3. Texada outputs a set of property
instances such that each instance has support/support potential/-
conﬁdence greater than or equal to the corresponding threshold.
Finite trace semantics. To check a property on a ﬁnite
trace we effectively transform the ﬁnite trace into an inﬁnite
trace by appending an inﬁnite sequence of terminal events
ω. This extension deﬁnes exactly the inﬁnite trace we are
checking on, so more advanced adaptations of LTL to ﬁnitetraces are not necessary [3]. For many property types, this
extension does not affect the validity of the property instances.For example, consider checking “
ais immediately followed by
b,”G(a→Xb), on a ﬁnite trace which ends in a. Adding ωs
to the end of this trace does not change the invalidity of this
property instance on that trace: ωis¬bandωimmediately
follows aso the property remains invalid. However, Texada
evaluates Gato true on a ﬁnite trace consisting solely of a
events. This is despite the fact that on the extended trace, i.e.,
aa...aωω...,Gadoes not hold. It this case Texada checks
aUωinstead of Ga. Effectively, Texada determines the validity
of the property instances before ω. Instead of requiring the user
to incorporate this additional ωbound into the property type,
Texada implicitly evaluates the property type as if it contained
theωbound.
3When these thresholds are omitted, Texada uses the default conﬁdence
threshold of 1, and support and support potential thresholds of 0. The user
may specify the trace or global versions of each of these three thresholds.III. T EXADA DESIGN OVERVIEW
Figure 2 lists the pseudocode for Texada’s algorithm. We
overview the design behind this code and then explain Texada’s
two property checking algorithms in Sections IV and V.
(1) Representing a property type. Texada parses an input
property type into a tree structure whose leaves are atomic
propositions (line 4 of Figure 2). Figure 4(c) shows an example
of such a tree. Texada traverses this tree when checking the
validity of a property instance.
This style of checking contrasts with other pattern-mining
tools that use automata to represent temporal properties
(e.g., [7], [35], [39]). Critically, we use the tree representation
to memoize and re-use evaluation results (see Section VI).
Since the sub-trees of two different property instances may be
identical, the memoization signiﬁcantly speeds up the checking
of many (potentially thousands of) similar property instances.
(2) Representing a trace. Texada parses each input trace into
one of two representations (line 5 of Figure 2): (1) a linear
array form, or (2) a map form in which each event is mapped
to a sorted list of trace locations where the event appears. For
example, the linear form of the trace a,a,b,bis[a,a,b,b,ω].
Its map form is {a→[0,1],b→[2,3],ω→[4]} . The map form
allows the property checking algorithm to avoid traversing
sections of the trace that do not contain relevant events.
(3) Representing the space of property instances. In line 6
of Figure 2 Texada iterates over the set of property instances
(represented by bindings of variables Vto events E). Texada
considers all possible bindings4, or the space of all |V|-element
permutations of E. Texada generates instantiations dynamically,
which bounds space usage.
(4) Checking property instances over traces. Finally, Texada
checks the validity of each property instance on all traces in
the log (line 8, Figure 2) before moving on to the next instance.
Thecheck function on line 8 has two variants, one for each of
the two trace representations (linear/map).
IV . L INEAR MINER
A natural way to evaluate a property instance on a linear
trace is to iterate over the trace and recursively evaluate each
operator according to its semantics (Section II). The core section
of this linear checking algorithm is listed in Figure 3.
We describe the algorithm by checking a property instance
on trace 2 in Figure 1. The linear trace representation is listed
in Figure 4(a) and the property instance we will check is:
(¬authorized Wguest login) ∧
G(guest login →XFauthorized)
This is the “ guest login always followed by authorized ”
property with the added restriction that authorized cannot
occur before guest login (the CauseFirst pattern in Table I).
Internally, Texada represents this property as a tree (Figure 4(c))
and checks this property instance by traversing this tree. The
root of the tree is ∧; to check it, we check its children on the
ﬁrst event of the trace (see Figure 3, lines 7–8).
Left sub-tree of ∧:To check ¬authorized Wguest login ,
we follow the checking code for Uin Figure 3, lines 25–34 (but
asWis a weak until, we will return true on line 29). We begin
4Texada explores the space of permutations generated without replacement
by default, and has a ﬂag to consider permutations with replacement.
831 functioncheck−linear(property instance prop, trace t)
2 // Returns: true if prop holds on t, false otherwise.
3
4 // Operations that do not require trace traversal:
5 if(prop isevent)
6 return (t.ﬁrst˙event() == prop)
7 else if (prop == p∧q)
8 returncheck−linear( p,t)& &check −linear(q, t)
9 else if (prop == p∨q)
10 returncheck−linear( p,t)||check−linear(q, t)
11 else if (prop ==¬p)
12 return !check−linear( p,t)
1314 // Operations that require trace traversal:
15 else if (prop == X p)
16 if(t.ﬁrst˙event().is˙terminal())
17 // this creates the inﬁnite sequence of terminal events.
18 returncheck−linear( p,t)
19 returncheck−linear( p,t.next˙event())
2021 else if (prop == G p)
22 if(t.ﬁrst˙event().is˙terminal()) return true
23 returncheck−linear( p,t)& &check −linear( prop, t
.next˙event())
2425 else if (prop == pUq)
26 if(t.ﬁrst˙event().is˙terminal())
27 // If we get here, we have not seen q:
28 // need q to occur for until to hold.
29 return false
30 else if (qholds on t)return true
31 else if (¬pholds on t)return false
32 // Here, p and !q hold, so we need to look
33 // for a !p or q further down the trace.
34 returncheck−linear( prop, t.next˙event())
Fig. 3: A section of the linear checking algorithm.
traversing the linear representation of the trace in Figure 4(a)
at the ﬁrst event, which is login attempt . Since this does
not evaluate to true on guest login nor on¬(¬authorized) ,
we check (¬authorized Wguest login) on the next event.
Here we return true because guest login has been reached
without violating ¬authorized.
Right sub-tree of ∧:In general, to check Gpwe must check
pon each event in the trace (Figure 3, lines 21–23), recursing
until¬pis found or the trace ends. The implication operator
p→qworks like ¬p∨q, short-circuiting if ¬pis found. So, to
check G(guest login →XFauthorized)) , we recurse down
the trace. When we reach guest login , we need to check the
implication, XFauthorized . At this point the Xoperator takes
a step along the trace. Then, checking Fauthorized involves
stepping down the trace once more until we ﬁnd authorized .
We ﬁnd it at position 4 and return that XFauthorized holds.
Continuing, we ﬁnd the Gsub-property is not violated, and
the full property holds on this trace (it does not hold on the
log in Figure 1 as it is violated in trace 3).
Boolean operators omitted from Figure 3, such as the →,↔,
and⊕are implemented by combining the results of checking
pand qwith the corresponding operator, as with the other
boolean operators. Evaluation can short-circuit on ∧,∨, and→
operators. The Woperator evaluation is identical to Uexcept
that it evaluates to true in the base case.
In both the linear miner and the map miner (Section V),
we take special care to check property types at the end of the
trace to satisfy the ﬁnite trace semantics (see Section II). Most
operators have a simple boolean base case for the terminal
eventω. The next operator, Xp, requires a more extensive baseW∧
→G
guest
login¬
authorized guestlogin
authorizedX
F1
2345  
ω
login attempt →[0],
guest login →[1],
auth failed →[2],
authorized →[3]login attempt
guest login
auth failed
authorized
(a)
(b)
(c)
Fig. 4: (a)Linear and (b)map representations of trace 2 from Figure 1.
(c)Syntactic tree for property: (¬authorized Wguest login) ∧
G(guest login →XFauthorized).
case, since evaluating Xponωrequires evaluating ponω
(creating the appearance of an inﬁnite trace). This evaluation
terminates because the formula tree for any pis ﬁnite, thus
Texada will eventually reach an event at a leaf node, whose
checking does not recurse.
A. Computing support and support potential
The linear miner returns property instances that are never
falsiﬁed. We now describe an algorithm to calculate the trace
support for a property instance. Interestingness measures of
temporal properties have been considered previously [11], [27].
However, these measures were restricted to property types of theform “
ais always followed by b”o r“ aalways precedes b”, or
nested variations of these. Texada computes an approximation
of support and support potential for arbitrary LTL formulae,
whose deﬁnitions are not captured in this previous work.
Figure 5 lists the pseudocode for the support algorithm5.I t
has the same recursive structure as the linear mining algorithm
in Figure 3, but instead of combining boolean values, the
calculation in the recursive call combines counts. The support
potential algorithm (not shown for space reasons) deviates from
the support algorithm in Figure 5 at the atomic propositions:
support returns 1 at satisﬁed falsiﬁable time points while support
potential returns 1 at alltime points.
Key challenge: equivalence of p→qand¬p∨q.Note
that the support calculation for ∨in Figure 5 differs signiﬁcantly
from Figure 3. This is because the equivalence of p→qand
¬p∨qis central to our notion of falsiﬁability. For example,
we would like the support of “ ais always followed by b”,
G(a→XFb) , to be the number of time points at which aoccurs
and is eventually followed by b, and the support potential to
be the total number of time points at which aoccurs. For
this formula, the absence of ¬adesignates a falsiﬁable time
point. However, since a formula like G(a∨b)can be re-written
asG(¬a→b)orG(¬b→a), it is unclear which side of the
implication should determine falsiﬁability.
The algorithm uses a helper function called interval (not
listed), which takes a proposition and returns the intervalon which this proposition must be checked. This function
returns the interval containing only t.ﬁrst event() on atomic
propositions, the interval from t.ﬁrst event() to the terminal
5In our implementation, the algorithm for linear property instance checking
is bundled with support and support potential calculation. We explain them
separately to simplify our presentation.
841 functionsupport(instance prop, trace t)
2 // Returns: the number of atomic proposition evaluations on twhich
3 // could have falsiﬁed prop on which prop was satisﬁed
4
5 if(prop isevent)
6 if(t.ﬁrst˙event() == prop) return 1
7 return 0
89 else if (prop == p∨q)
10 // if a child with an earlier interval is satisﬁed,
11 // then the property instance is vacuously true
12 if(interval (p,t)>interval (q,t))
13 if(qissatisﬁed byt)return 0
14 returnsupport( p,t)
15 else if (interval (p,t)<interval (q,t))
16 if(pissatisﬁed byt)return 0
17 returnsupport(q, t)
18 else
19 if(both pand qare satisﬁed byt)return 0
20 else if (support( p,t)>=support(q, t)returnsupport( p,t)
21 returnsupport(q, t)
2223 else if (prop ==¬p)
24 if(t.ﬁrst˙event() != p)return 1
25 return 0
2627 else if (prop == Gq)
28 if(t.ﬁrst˙event().is˙terminal()) return 0
29 returnsupport(q, t)+support( prop, t.next˙event())
3031 else if (prop == Fq)
32 if(t.ﬁrst˙event().is˙terminal()) return 0
33 else if (qholds ont)returnsupport(q, t)
34 returnsupport( prop, t.next˙event())
3536 else if (prop == Xq)
37 if(t.ﬁrst˙event().is˙terminal()) return 0
38 returnsupport(q, t.next˙event())
Fig. 5: A section of the support calculation algorithm.
event on G,F,U, the interval of X’s child node (in the formula
tree) pushed by one on X, and the union of the interval of the
children of ∧and∨on these operators. An interval iis smaller
than another interval jifiand jare disjoint and ioccurs ﬁrst.
Getting back to the always followed by example, G(¬a∨
XFb) : since the interval for ¬ais strictly before the interval
for XFb , we execute lines 15-17 in Figure 5 and return the
support of XFb . Here, the algorithm approximates which side’s
falsiﬁcation indicates a falsifying time point by comparing the
temporal “order” of each side, given by the interval calculation.
The other operators are simpler. The support of Gpis the
sum of support of pat each event. Property instances are in
negative normal form6,s ot h e¬pevaluation treats pas an
atomic proposition. The operators not listed for space reasons
correspond in structure to the linear checking algorithm.
Overall, the linear miner and support/support potential
algorithms have a simple recursive structure. Next, we describe
the map miner, which was designed to reduce linear scanning
over traces and reduce redundant computation.
V. M AP MINER
The map miner uses the map trace representation (e.g. Fig-
ure 4(b)). The map-based property instance checker leverages
a key property of LTL: an LTL formula describes the sequence
of events relative to each other. The map checker, therefore,
6Prior to calculating support, Texada converts property instances into negative
normal form, pushing the logical not operators to the leaves.1 functioncheck−map(property instance prop, index i)
2 // Returns: true if prop holds starting at i, false otherwise.
3 // Omitted: boolean connectives, and operators F, R.
45 if(prop == X p)
6 // Special case for the end of the trace.
7 if(i==omega
pos)
8 returncheck−map( p,i)
9 // Else, move forward and check p
10 returncheck−map( p,i+1)
1112 if(prop == G p)
13 fi r s t
not p=ﬁrst−occurrence(¬ p,[i,omega pos−1])
14 // If !p never occurs, G(p) holds.
15 if(fi r s t not p==false) return true
16 return false
1718 if(prop == pUq)
19 // Find q.
20 fi r s t
q=ﬁrst−occurrence (q,[i,omega pos−1]);
21 // If q never occurs, until does not hold.
22 if(fi r s t q==false) return false
23 fi r s t not p=ﬁrst−occurrence(¬ p,[i,omega pos−1])
24 // If !p never occurs, until holds.
25 if(fi r s t not p==false) return true
26 // Make sure !p did not occur before q.
27 if(fi r s t not p<fi r s t q)return false
28 return true
Fig. 6: A section of the map miner checking algorithm.
can skip over the trace between the relevant events (using the
map trace representation). As we will show in Section VII-B ,
this makes the map checker much more efﬁcient than the linear
checker, especially on long traces.
The miner is structured as three functions: check-map ,ﬁrst-
occurrence , and last-occurrence . Each one takes a node in the
property instance tree (e.g., Figure 4(c)) and an interval in the
trace, and then traverses the sub-tree rooted at the node. The
check-map function (Figure 6) traverses the tree to implement
operator semantics on a node given the validity of the node’s
sub-trees in the trace at certain positions. This function returns
a boolean and evaluates non-temporal operators identically to
check-linear (Figure 3, lines 7–12).
Temporal operators are implemented by using the ﬁrst and
last occurrence information provided by the ﬁrst-occurrence
and last-occurrence functions. ﬁrst-occurrence (Figure 7)
returns the ﬁrst position in some interval where a sub-formula
rooted at a node in the property instance tree evaluates to true,
or returns false if no such position exists. For example, in
lines 13–16 of Figure 6, the check-map function evaluates Gp
at index iin the trace by using the result of ﬁrst-occurrence
(¬p,[i,omega pos−1]). Ifﬁrst-occurrence returns false, then
¬pnever occurs after i, which means that Gpis true on this
interval; otherwise G pis false on this interval.
When ﬁrst-occurrence is called with an event node (i.e.,
a leaf in the sub-tree) it runs a binary search on the sorted
positions list associated with the event (stored in the map trace
representation) to ﬁnd the ﬁrst occurrence of the event in a given
interval (line 5 in Figure 7). However, ﬁrst-occurrence must
also traverse the sub-tree when it is called with a non-leaf node.
Lines 8–20 in Figure 7 detail the case of ﬁrst-occurrence
(pUq,intvl ):ﬁrst-occurrence makes a recursive call ﬁrst-
occurrence (q, intvl), and uses the returned position in a call
tolast-occurrence (¬ p,[intvl.start, j]). Then the ﬁrst position
where pUqholds in this interval is the point at which there
are no longer any ¬pevents until qor where qoccurs (if q
851 functionﬁrst−occurrence(instance prop, interval intvl )
2 // Returns: ﬁrst index in intvl where prop is true, false otherwise.
3
4 if(prop isevent)
5 returnbinary−search (prop, intvl )
67 else if (prop == pUq)
8 // Find ﬁrst position where qis true.
9 fi r s t
q=ﬁrst−occurrence(q, [intvl .start, omega pos−1])
10 // Until needs qto occur.
11 if(fi r s t q==false) return false
12 // Find the last ! pthat occurs before the ﬁrst q
13 last not p=last−occurrence(¬ p,[intvl .start, fi r s t q−1])
14 // If ! pdoes not occur before the ﬁrst q,pUqholds
15 // on the ﬁrst element of the interval.
16 if(last not p==false) return intvl .start
17 // If the last ! pbefore qis after the end of our original
18 // interval, pUqholds nowhere on that interval.
19 if(last not p≥intvl .end) return false
20 return last not p+1
Fig. 7: Pseudocode for a section of the ﬁrst-occurrence function that
facilitates the check-map function in Figure 6.
is the start of the trace, pUqholds trivially since there is
nowhere for ¬pto occur before q). We omit last-occurrence
for space reasons, but it looks similar to ﬁrst-occurrence.
Returning to the example used in the linear miner descrip-
tion, consider checking the same CauseFirst property instance
in Figure 4(c). We check the same trace, this time using the
map representation listed in Figure 4(b). check-map starts at
the root node, ∧, and recursively checks its two children.
Left sub-tree of ∧: To check ¬authorized Wguest login
we follow Figure 6, lines 19–28 (with line 22 returning
true for the W operator). We ﬁnd the ﬁrst occurrence of
guest login : 1. Then, we ﬁnd the ﬁrst occurrence of
¬(¬authorized) ≡authorized : 3. Since guest login oc-
curs before authorized (1<3), we return true.
Right sub-tree of ∧: To check G(guest login →
XFauthorized)) we ﬁnd the ﬁrst occurrence of
¬(guest login → XFauthorized) ≡(guest login ∧
XG¬authorized) . We do this by ﬁnding the ﬁrst occurrence
ofguest login and of XG¬authorized on our desired
interval; if they do not co-occur, we repeat the process on
an interval with a later start point. Since both do not occurat one point in the trace, we ﬁnd no ﬁrst occurrence of
(guest login ∧XG¬authorized) and ﬁnd the right sub-tree
to be true. Both sub-trees of ∧are true, so the property holds.
VI. C HECKING STA TE MEMOIZA TION
As Texada may check thousands of bindings for a given
property type, it will check many LTL formulae with similar
syntactic trees. This results in redundant computation. Texada
uses memoization to reduce such duplicate computation. A
beneﬁt of the tree representation of property types is that we can
re-use the result of evaluating one instantiation in evaluating a
similar instantiation. This is possible because two instantiations
will frequently have identical sub-formulae, or sub-trees. For
example, Figure 8 shows two property instances of the property
type “ xis always followed by yafter wuntil z” [15] with
nearly identical syntactic trees. The Tsub-tree in Figure 8
corresponds to the sub-formula (a→(¬e U(b∧¬e))) We),
which is common to both property instances.
We have implemented a memoization strategy in the map
checker to store the result of evaluating first−occurrenceG(d∧¬e→ ) G(c∧¬e→ )∧¬U→∧→G
W
e e e c¬
a b¬
e∧→G
ed¬
(a) TT T
(b) T
Fig. 8: (a)Syntactic tree for G(c∧¬e→((a→(¬e U(b∧¬e))) We)),
(b)Syntactic tree for G(d∧¬e→((a→(¬e U(b∧¬e))) We)).
The tree on the right differs in a single node (left-most terminal d
node). Therefore, we can determine the truth value of the highlighted
sub-tree by using a memoization of the computation of an identical
sub-tree that appears on the left.
and last−occurrence on a subformula for a given in-
terval. We started with memoizing these functions as theyare frequently invoked. We plan to extend memoization toother intermediate checking state in our future work. Our
implementation retains memoized state until the mining process
completes. Our evaluation in Section VII-B indicates that on
short formulas the memoized state is small compared to that
of the input log, which must be maintained in memory.
VII. E V ALUA TION
In this section we show that Texada generalizes over prior
work (Section VII-A ), that it is fast (Section VII-B ), and that
it is useful (Section VII-C, VII-D, and VII-E).
A. Expressiveness of property types
Our survey of related work indicates that Texada property
types are sufﬁcient to capture both the various temporal
speciﬁcation taxonomies, like in Perracotta [47] and Dwyer et
al. [15], as well as speciﬁcation templates used in the numerous
custom-built miners like Synoptic [7].
Perracotta [47] is a tool to mine eight different kinds of
temporal properties. These properties cover common program
patterns. For example, Perracotta’s Response pattern represents
a pattern in which an action xis followed by a response y.
Table I lists the property patterns mined by Perracotta and the
corresponding Texada LTL property types.
Dwyer et al. [15] deﬁned a set of LTL speciﬁcation
patterns based on a survey of a variety of speciﬁcations. A
speciﬁcation pattern in their formulation consists of a pattern
and a scope over which the pattern must be true. Table II
lists two speciﬁcation patterns as property types. All of the
speciﬁcation patterns trivially translate to Texada property types.
Synoptic [7] is a tool to infer an FSM model from a log
of system behavior to support programmer comprehension. Its
algorithm relies on the mining of three temporal property types
listed in Table III. These properties have also been used to
infer more accurate models in InvariMint [5] and CSight [6].B. Performance evaluation
We evaluated Texada’s performance on a machine running
64-bit Ubuntu 14.04 TLS with 8GB RAM and an Intel i5
86TABLE I: Property patterns mined by the Perracotta tool [47] and
their equivalent property types in Texada.
Pattern Reg. Ex. LTL
Response y*(xx*yy*)* G(x→XFy)
Alternating (xy)* (¬y Wx)∧G((x→X(¬x Uy))∧
(y→X(¬y Wx)))
MultiEffect (xyy*)* (¬y Wx)∧G(x→X(¬x Uy))
MultiCause (xx*y)* (¬y Wx)∧G(x→XFy)∧
G(y→X(¬y Wx))
EffectFirst y*(xy)* G((x→X(¬x Uy))∧
(y→X(¬y Wx)))
CauseFirst (xx*yy*) (¬y Wx)∧G(x→XFy)
OneCause y*(xyy*)* G(x→X(¬x Uy))
OneEffect y*(xx*y)* G(x→XFy)∧G(y→X(¬y Wx))
TABLE II: Two example speciﬁcation patterns from [15], each one
demonstrates a different scope.
Pattern ; Scope LTL
presponds to s,t; after q G(q→G((s∧XFt)→
X(¬ tU(t∧Fp))))
never p; between qand r G((q∧¬r∧Fr)→(¬pUr))
TABLE III: Property patterns used in Synoptic [7] and their equivalent
LTL property types in Texada.
Pattern LTL
Always followed by G(x→XFy)
Always precedes Fy→(¬y Ux)
Never followed by G(x→XG(¬y))
Haswell quad-core 3.2GHz processor. Texada is implemented
in about 7,500 lines of C++, depends on the Boost library7, and
uses the SPOT library [14] to parse and traverse LTL property
types. For all performance experiments comparing to Synoptic,
we use Texada revision a410 [40].
We ﬁrst compare Texada’s linear and map miners against the
temporal miner in Synoptic [7], which mines the three temporal
property types in Table III8. Synoptic mines instances of these
property types from the input log and guarantees that they are
satisﬁed in the inferred FSM model. Synoptic is an interesting
point of comparison because although it is implemented in Java,it is highly optimized for mining the three temporal properties.
We were interested to see if Texada’s general property miners
could out-perform Synoptic’s specialized miner. For a proper
comparison, these experiments used a conﬁdence threshold of
1 and a support threshold of 0.
We generated a set of random synthetic logs, each with a
speciﬁc number of traces, unique events, and trace length.
We ran Texada’s map miner, linear miner, and Synoptic’s
miner (using the --onlyMineInvariants option) 5 times on each
log input and report the average runtime. We compared the
Texada miners against Synoptic’s miner along three dimensions:
varying the number of traces (Figure 9), the length of the
traces (Figure 10), and the number of unique events (Figure 11).
These three dimensions determine both Synoptic’s and Texada’s
performance. The take-away from these experiments is that on
the three Synoptic invariant types in Table III the map miner
dominates the linear miner and the Synoptic miner.
Varying the number of traces (Figure 9) . The trace length
was held constant at 10,000 and the number of unique events
was held constant at 50. Synoptic threw an OutOfMemory-
Error at 260 traces. All three miners exhibit a linear slow-
down indicating a ﬁxed performance penalty to processing an
7http://www.boost.org
8Synoptic is one of the few miners that was available to us for evaluation.additional input trace.
Varying trace length (Figure 10) . The number of traces per
log was held constant at 20, and the number of unique events
was held constant at 100. This ﬁgure is similar to Figure 9
in that all miners slow down linearly. The linear miner hasthe worst performance since each additional event in a trace
requires further recursion (e.g., for the Goperator for “always
followed by” property in Table III).
Varying number of unique events (Figure 11) . The number
of traces per log was held constant at 20 and the length ofa trace was held constant at 10,000. The linear miner doesespecially poorly with an exponential slow down, while the
Synoptic and map miners have similarly good performance.
The above results indicate that the map miner generally
outperforms the linear miner. This is because the map miner
often avoids recursive trace traversal that the linear miner isforced to perform. However, we did ﬁnd property types on
which the map miner performed worse than the linear miner. We
are working to further characterize their relative performance.
Varying support and conﬁdence thresholds. Texada’s code
is optimized for the default thresholds of support of 0 and
conﬁdence of 1. For example, the linear miner can short-circuitfurther recursion along the trace for some of the operators
9. Non-
default support and conﬁdence thresholds disable most of these
optimizations. This is because to calculate the exact support
or support potential of a property instance, Texada must count
all possible falsiﬁable time points. We found that decreasing
the trace conﬁdence threshold generally increases runtime. In
Figure 12 we see that increasing the support threshold causes a
variety of effects while mining the always followed by, always
precedes, and never followed by properties10. In each case an
increase in support threshold causes an initial jump in runtime,followed by a ﬂat section and sometimes a decrease in runtime.
Introducing the support threshold forces Texada to stop short-
circuiting on the evaluation of several operands; however, oncethe support threshold is set too high, the property instance willfail the threshold on some trace. At this point Texada will begin
to short-circuit evaluation by moving to the next instantiation,
instead of checking the current instantiation on the remaining
traces in the log. Note that this trace short-circuiting is unsafe
if thresholds are speciﬁed at the global level, as this forces
evaluation over the entire log.
We discuss the advantages of introducing support and conﬁ-
dence thresholds despite the large runtime cost in Section VII-C .
Beneﬁt of memoization. To evaluate the effect of memoization,
we carried out an experiment with three instantiations of the
property “ poccurs at most twice between qand rand soccurs
at most twice between qand r” [15]. We selected this property
type because we found that the map checker was slower than
usual in evaluating instances of this type. To compare the
runtime of the map checker with and without memoization we
slowed down the checker by using a log containing a single,
especially long, trace that we synthesized. The trace consisted
of 36 million events, sampled at random from a set of 10 eventtypes. We measured the runtime in checking 3 instantiations
11:
9Some examples of short-circuiting: if one branch is found to be false in
evaluating ∧,i f¬poccurs in evaluating Gp, or if a property instance is found
to be false on one trace in the log.
10These properties were mined on a randomly-generated log over 18 events
with 20 event traces, each with 10,000 events.
11We used Texada revision df18 [40]
87 0 10 20 30 40 50 60
 0  50  100  150  200  250  300Time (s)
Number of traces per logSynoptic
Linear miner
Map miner
Fig. 9: Time to mine the three Synoptic property types using Synoptic
and Texada’s linear and map miners for logs with varying numbers
traces per log.
 0 10 20 30 40 50 60 70 80 90 100
 0  5000  10000  15000  20000  25000  30000  35000Time (s)
Number of events per traceSynoptic
Linear miner
Map miner
Fig. 10: Time to mine the three Synoptic property types using Synoptic
and Texada’s linear and map miners for logs with varying number of
events per trace.
A,B, and C. We designed the bindings for these so that the
memoized state of Band Cwould help in evaluating A, and
vice-versa. However, evaluating Bwould not help in evaluating
C, and vice-versa.
We ran the map checker on A,B, and Cin four conﬁgu-
rations: (1) [A,B,C]with memoization, (2) [A,B,C], clearing
memoized state after checking A, (3)[B,C,A]with memoization,
(4)[B,C,A], clearing memoized state after checking C.W er a n
each conﬁguration 100 times and report the average runtime.
The two orders that do not clear memoized state had nearly
identical runtimes of about 5.7s, indicating that for this example
the checking order does not matter. We believe that this will
generally hold true since we memoize the evaluation of every
sub-formula. The two orders that cleared the memoized state
also had similar runtimes of about 6.1s. In this experiment,
memoization decreased the total runtime by 7%. In practice,
we expect the speed-up to be signiﬁcantly higher as many more
(than just three) instantiations would share the memoized state.
Memory use in these experiments peaked at 342MiB and
was primarily used to store the input trace. The experiments
generated 14 KiB of memoized state, or 5 KiB per propertyinstance. Mining all possible instances of the same propertytype (with four variables) over the same log (over 10 event
types) requires checking 5,040 property instances12. At the rate
of 5 KiB per property instance, this process will generate about25 MiB of memoized state. We aim to improve on the memory
use of memoized state by developing expiration policies to
regularly delete memoized state that is not going be reused.
C. Mining patterns of user activity
To evaluate Texada’s utility we applied it to a web log used
to evaluate the BEAR framework [23] and Perfume [35]. This
log records web requests for a real estate website on which
12The default conﬁguration is to generate bindings without replacement: no
two variables are bound to the same event. 0 50 100 150 200 250
 0 100  200  300  400  500  600  700  800  900  1000Time (s)
Unique eventsSynoptic
Linear miner
Map miner
Fig. 11: Time to mine the three Synoptic property types using Synoptic
and Texada’s linear and map miners for logs with varying number of
unique events.
 0 2 4 6 8 10 12 14 16
 0  200  400  600  800  1000Time (s)
Trace support thresholdG(x->XFy)
G(x->XG!y)
Fy -> (!y U x)
Fig. 12: Time to mine each Synoptic property with the Texada linear
miner given different trace support thresholds.
users browse or search for houses and apartments to rent or buy.
Each request has a timestamp and an anonymized IP address;
we use these to interpret the log as separate executions of the
web-site, one execution per client who accesses the site, where
events are the visited site pages.
We reused the event types from the BEAR study by pre-
processing the log to remove irrelevant events, like those
generated by web crawlers, and by assigning semanticallyidentical events to the same label. The pre-processed logcontained about 12,000 lines, with 13 different events. We
used Texada revision e436 [40] to mine the property types in
Table II with the linear miner. In the analysis we ignored 4
rarely occurring events to simplify inspection. Due to space
constraints we discuss the implications of a select set of mined
property instances. The log had no ground truth to compare
our results to, but we believe the following results show utility.
For each result below we report a runtime that is an average
over 5 runs.
1. Fnews page→(!news page Unews article)
Visits to news article always precede visits to the news page.
(Texada runtime: 1.6s, instances returned: 15, support threshold:
8,000, conﬁdence threshold: 0.98.) This is an instantiation of
“xalways precedes y” in Table III and has 0.99 conﬁdence and
9,605 support. This instantiation suggests that the news articles
generate much more initial interest than the news page, andthat this page is only accessed by users who have taken the
time to access an article and want more content. It may indicate
the news page needs to be redesigned for broader appeal.
2. G(sales page→XF(¬sales anncs))
After visiting a sales page, the sales announcement pages is
always visited. (Texada runtime: 7.5s, instances returned: 3,conﬁdence threshold: 0.80.) This is an instantiation of “
xis
always followed by y” in Table III and has 0.87 conﬁdence and
88TABLE IV: Number of instances of G(x→XG(¬y)) mined from the
BEAR log with the linear miner using varying global support and
global conﬁdence thresholds. The cell highlighted in the upper left
corresponds to the default Texada thresholds.
aaaaaasupp.conf.1 0.95 0.9 0.85 0.8 0.7 0.5 0.3 0.1
0 11 120 141 150 165 169 182 182 182
200 5 105 122 127 142 145 155 155 155
500 2 96 111 116 130 133 143 143 143
5,000 0 87 100 105 118 121 130 130 130
15,000 0 7 17 8 8 19 09 39 99 99 9
50,000 0 4 75 1 5 35 96 16 46 46 4
100,000 0 2 93 2 3 33 53 73 93 93 9
200,000 0 1 71 8 1 92 12 12 12 12 1
2,232 support. We expect users interested in buying or selling
a property to navigate from the main sales page to the sales
announcements. However, the lower conﬁdence of the property
suggests there may be a block to easy navigation between the
two. The sales page could be revised to better funnel users
towards announcements.
3.G(search →G((news article∧XFrenting anncs)→
X(¬renting anncs U(renting anncs∧Fsales anncs))))
Users who visit news article pages eventually visit a sales
announcement page. (Texada runtime: 12.8s, instances returned:
158) We ran this property with conﬁdence threshold 1 and
support threshold 0. This is an instantiation of “ presponds
tos,tafter q” in Table II. This property says that after a
search, every time a user accesses a news article and then a
renting announcement, the user will then subsequently access
a sales announcement (something that does not happen every
time users visit a renting announcement after search). This may
indicate that news articles impact users’ navigation, which can
prompt work on news article accessibility.
The support and conﬁdence thresholds allow the user to
focus on the most likely instantiations. The ﬁltering effect due
to support and conﬁdence is illustrated in Table IV, where
increasing global conﬁdence and support thresholds decreases
the number of instances of the never followed by property foundon the BEAR log. We also see that high support automaticallyﬁlters out low-conﬁdence properties; the bottom row of the table
shows that there were no additional properties with support at
least 200K and a conﬁdence value below 0.8. The properties
in the bottom row likely include the key patterns in the log.
Two features distinguish the above properties from results
derived using other tools on the same log [23], [35]. (1)Texada-
generated properties are concise and allow a developer to focus
on and ﬁlter by a set of relevant events without needing to
understand other events in the trace. (2)The properties have a
well-deﬁned LTL structure stipulated by the property type.
D. V alidating expected behaviour
The sleeping barber problem is a classic concurrency
problem attributed to Edsger Dijkstra [13]. In the problem
a barber alternates between cutting hair, sleeping, and checking
for customers in his waiting room. If a customer walks in and
ﬁnds the barber sleeping, the customer wakes up the barber
and gets a haircut. If the customer walks in and the barber is
cutting hair, the customer waits in the waiting room if there isspace, otherwise the customer leaves. When the barber is done
cutting hair, he checks if there are customers in the waitingroom. If there are, then he cuts one of the customer’s hair;
otherwise, he goes to sleep. In our version of the problem, eachcustomer desires a certain number of haircuts.
Our solution is based on a solution by Teemu Kerola and
represents the barber and each customer as a thread. The
implementation tracks the state of the barber and each customer
and prints the state of each thread whenever (1) a customer
enters, (2) a customer exits, (3) a customer receives the desired
number of haircuts, and (4) the barber retrieves a customerfrom the waiting room. We treat the barber’s and customers’
states as events. The resulting trace includes multiple events foreach of the above time points. We call this a multi-propositional
trace: multiple atomic propositions (customer and barber states)
are logged at each time point.
We checked a log from ﬁve runs of our solution to the
sleeping barber problem. The runs had seven customers, each
of which desired two haircuts. There were 38 unique events
in the 4874 lines long log, with traces having 892–1036 lines
(99-115 time points). We used Texada to conﬁrm that desired
properties hold over these runs. This analysis is not a proof of
correctness, but as we show below, it can reveal bugs.
No two customers receive haircuts at the same time.
Instantiations of the G(x→¬ y)will test this property when x
and yare bound to Customer-i-GettingHairCut and Customer-
j-GettingHairCut , respectively, with distinct iand j. Running
this property with the map option took 0.064 seconds and
outputted 424 property instances. We ﬁltered these instances
to ﬁnd those of the form G(Customer-i-GettingHairCut →
¬Customer- j-GettingHairCut ), for all distinct i,jpairs, demon-
strating no violations of the mutex in these runs.
Each customer receives 2 haircuts. We check this property
by conﬁrming that each customer transitions to the Getting-
HairCut state from another state exactly twice. A property thatexpresses this is an extension of the Bounded Existence property
with global scope [15]: (¬x W(xW(¬x W(xWG¬x))))∧
F(x∧XF(¬x∧XFx)). The ﬁrst half of this property assures
that all transitions to xoccur at most twice, and the second
half assures that these transitions occur at least twice13.
With the map miner, Texada took 0.031s to check this
property, returning 13 property instances. These instances bind
xtoCustomer-i-Waiting and Customer-i-GettingHairCut for
alli, except Customer-4. Examining the log, we found that
in one trace, Customer-4 transitioned to the GettingHairCut
state only once. The second time the customer was observed to
enter, to be the only one in the waiting room when the barber
checked it, and to exit the barbershop. This turned out to bea bug in our logging code, not the implementation: no timepoint was logged during the haircut for Customer-4. Texada
helped us ﬁnd this bug.
For this example we have also used Texada to validate the
property Customers are served in the order in which they sit
down. In addition, we used Texada in a similar way to validate
an implementation of the dining philosophers problem. We
omit these for space reasons.
E. Mining data-temporal properties
Texada can be used to develop more advanced program
analyses. We prototyped a tool that combines Texada with
Daikon [17] (a tool to infer likely data invariants from program
traces). Our prototype infers likely data-temporal properties.
13This is an example of an LTL property that is checkable with Texada, but
which may be easier to specify as an automaton.
89As an example, consider a Queue class with ﬁelds size and
capacity , which represent the current size and the maximum
size of the queue, respectively. For this class Daikon may infer a
data invariant like size≤capacity . With Texada, we can infer
temporal relations between these data invariants. For example,
theQueue may also have an isFull ﬂag. While Daikon can infer
a data invariant like (isFull ==true)⇐⇒ (size ==capacity)
at some program points, a more powerful property can be for-
mulated temporally: (isFull ==false) U(size ==capacity) .
That is, “ isFull isfalse until size is equal to capacity ”; it
is an instance of “ xholds until ybecomes true”. This data-
temporal property captures an important correctness condition:
the queue is not ﬂagged as full until it reaches capacity.
We prototyped a version of a tool to mine data-temporal
properties. It works as follows. First, it uses one of Daikon’s
frontends to instrument a program to collect data tracesfrom a set of program executions (e.g., the program’s testsuite). Then, it uses Daikon to infer likely data invariants
from these traces. The Daikon invariants are spliced into the
control ﬂow of the data traces, matching invariants with their
corresponding program points. This generates a set of totally
ordered invariant traces (which are multi-propositional, asdeﬁned in Section
VII-D ). Finally, the tool runs Texada on
these traces to generate data-temporal properties.
We applied this technique to QueueAr, a program dis-
tributed with Daikon that implements the Queue class discussed
above. We used QueueAr’s test suite to generate invarianttraces, one per
Queue instance. Using Texada we mined:
¬“this.currentSize ≥1”W“ this.currentSize ==0”
This instantiation reﬂects an important (but expected) property
of the queue’s test suite: the Queue is always created empty.
We think that data-temporal properties can be useful in
test-case generation and for bug detection. Evaluation of data-
temporal properties is part of our future work.
VIII. R ELA TED WORK
The problem of checking an LTL formula on a ﬁnite trace
has been considered by van der Aalst et al. [42]; their algorithm
is similar to Texada’s linear checker. There are also efﬁcient
techniques for checking an LTL formula on a single trace using
Alternating Finite Automata [39]. However, the generated AFA
depends on both the property instance and the trace, making the
approach not scalable to our context, which requires checking
a large set of LTL properties across many traces.
Many speciﬁcation mining tools have appeared in prior
work [38]. Existing tools mine LTL properties, but unlike
Texada, these are designed to mine a particular set of property
types. The Perracotta tool by Yang et al. [47] mines several
two variable response patterns and chains alternating properties
together to form multi-variable properties. It also supports
approximate inference to ﬁlter out uninteresting properties. Lo
et al. extend Yang et al.’s work with a miner that produces
quantiﬁed temporal rules that capture data ﬂow relationships
among events [33]. Li et al. [28] extend Perracotta to minesimple LTL patterns from traces and merge these to analyze
digital circuits. These same LTL patterns are mined between
data invariants in [4], [8]. Although prior work has not explicitlymined temporal relationships between data invariants, there has
been work on augmenting models, such as FSMs and Live
Sequence Diagrams, with data invariants [30], [34], [45].
Weimer et al. [46] mine alternating and response pat-terns on exceptional control-ﬂow to effectively identify bugs.
Javert [19] also mines alternating patterns, along with resource
ownership patterns (i.e., (ab*c)*) and composes them intomore complex properties. Reger et al. use a similar pattern-composition technique [24] and extend it to accommodate
imperfect traces [25]. Gabel et al. [20] improve the efﬁciency
of mining the alternating and resource allocation patterns by
using BDDs to represent property types. Like all these miners,
Texada is a dynamic analysis technique and may produce
false positives. One promising approach to validate minedspeciﬁcations of programs whose code is available is to use
deductive speciﬁcation inference [22].
A number of tools mine association rules (response patterns
between events sets): DynaMine [29] examines revision historyof a program and observes program behaviour to ﬁlter behaviour
and to avoid blow-up of potential patterns. Thummalapentaet al. [41] mine such rules to infer exception-handling rules.
Lo et al. [11] develop an algorithm to mine response patterns
between sequences of events.
InvariMint [5] is a declarative model inference speciﬁcation
approach that requires an algorithm designer to specify model
inference algorithms as parameterized FSM templates with
bindings functions that resemble Texada property types. Texada
can be used to mine the legal bindings in InvariMint.
Recent work on inferring various types of models from
source code, execution traces, and log ﬁles, relies on temporal
properties [6], [7], [32], [44]. For example in [44] temporalproperties are speciﬁed manually by a user to guide speciﬁ-cation mining, and in [6], [7] a set of properties are mined
automatically from the input traces. Texada can improve both
types of work — the Texada-mined property instances can be
presented to the user for selection, or used en masse.
The recursive-descent-parsing-style checking of LTL in
Texada does not work for classic LTL with inﬁnite trace
semantics. The standard way to check an LTL formula isto derive a B
¨uchi Automaton [43] and to intersect it with
the model. Using existing model-checking tools out-of-the-
box (e.g., SPOT [14]) for speciﬁcation mining is not typically
possible because of the mis-matched trace semantics.
IX. C ONCLUSION
Texada is a general LTL miner that is a swiss army knife
of property mining. It replaces a suite of tools that are based
on speciﬁc templates and supports tasks ranging from log
exploration to property validation. We presented two algorithmsin Texada that mine arbitrary LTL properties, and an algorithm
to compute the support and conﬁdence for an arbitrary LTL
property. Our evaluation demonstrates that Texada is fast and
can outperform Synoptic, an existing special-purpose miner. Wealso demonstrated Texada’s utility by mining properties from a
web log of user activity, by validating expected properties of a
solution to the Sleeping Barber problem, and by mining data-
temporal properties from traces of Daikon invariants. Property
types in Texada encompass those proposed in prior work and
can capture a wide variety of temporal patterns. We encourage
other researchers to build their software analyses on top of
Texada, which is open sourced [40] and includes 67 pre-deﬁned
property types from prior work [7], [15], [47].
ACKNOWLEDGMENTS
This research is funded by an NSERC discovery award and
an NSERC USRA award.
90REFERENCES
[1] G. Ammons, D. Mandelin, R. Bod ´ık, and J. R. Larus. Debugging
temporal speciﬁcations with concept analysis. In Proceedings of the
ACM SIGPLAN 2003 Conference on Programming Language Design
and Implementation, PLDI ’03, pages 182–195, New Y ork, NY , USA,
2003. ACM.
[2] C. Baier and J.-P . Katoen. Principles of Model Checking. The MIT
Press, 2008.
[3] A. Bauer, M. Leucker, and C. Schallhart. The Good, the Bad, and the
Ugly, But How Ugly Is Ugly? In Runtime V eriﬁcation, pages 126–138.
Springer Berlin Heidelberg, 2007.
[4] M. Bertasi, G. Di Guglielmo, and G. Pravadelli. Automatic generation
of compact formal properties for effective error detection. In 2013
International Conference on Hardware/Software Codesign and System
Synthesis (CODES+ISSS), pages 1–10, Sept 2013.
[5] I. Beschastnikh, Y . Brun, J. Abrahamson, M. D. Ernst, and A. Krishna-
murthy. Using declarative speciﬁcation to improve the understanding,
extensibility, and comparison of model-inference algorithms. IEEE
Transactions on Software Engineering (TSE), 41(4):408–428, April 2015.
[6] I. Beschastnikh, Y . Brun, M. D. Ernst, and A. Krishnamurthy. Inferring
models of concurrent systems from logs of their behavior with csight.
InProceedings of the 36th International Conference on Software
Engineering, ICSE 2014, pages 468–479, New Y ork, NY , USA, 2014.
ACM.
[7] I. Beschastnikh, Y . Brun, S. Schneider, M. Sloan, and M. D. Ernst.
Leveraging existing instrumentation to automatically infer invariant-
constrained models. In SIGSOFT FSE, pages 267–277, 2011.
[8] M. Bonato, G. Di Guglielmo, M. Fujita, F. Fummi, and G. Pravadelli.
Dynamic Property Mining for Embedded Software. In Proceedings of the
Eighth IEEE/ACM/IFIP International Conference on Hardware/Software
Codesign and System Synthesis , CODES+ISSS ’12, pages 187–196, New
Y ork, NY , USA, 2012. ACM.
[9] M. Christodorescu, S. Jha, and C. Kruegel. Mining Speciﬁcations ofMalicious Behavior. In Proceedings of the 6th Joint Meeting of the
European Software Engineering Conference and the ACM SIGSOFT
Symposium on The F oundations of Software Engineering, ESEC-FSE
’07, pages 5–14, New Y ork, NY , USA, 2007. ACM.
[10] V . Dallmeier, N. Knopp, C. Mallon, S. Hack, and A. Zeller. Generating
test cases for speciﬁcation mining. In International Symposium on
Software Testing and Analysis (ISSTA), pages 85–96, Trento, Italy, 2010.
[11] S.-C. K. David Lo and C. Liu. Mining temporal rules for software
maintenance. Journal of Software Maintenance and Evolution: Research
and Practice, 20(4):227–247, 2008.
[12] B. Demsky, M. D. Ernst, P . J. Guo, S. McCamant, J. H. Perkins, and
M. Rinard. Inference and enforcement of data structure consistencyspeciﬁcations. In International Symposium on Software Testing and
Analysis (ISSTA), pages 233–243, Portland, ME, USA, July 2006.
[13] E. W. Dijkstra. Cooperating sequential processes. 1968.
[14] A. Duret-Lutz and D. Poitrenaud. Spot: an extensible model checking
library using transition-based generalized b ¨uchi automata. In Proceedings
of the 2004 Annual International Symposium on Modeling, Analysis, and
Simulation of Computer and Telecommunications Systems (MASCOTS),
pages 76–83, Oct 2004.
[15] M. B. Dwyer, G. S. Avrunin, and J. C. Corbett. Patterns in property
speciﬁcations for ﬁnite-state veriﬁcation. In Proceedings of the 21st
International Conference on Software Engineering, ICSE ’99, pages
411–420, New Y ork, NY , USA, 1999. ACM.
[16] E. A. Emerson. Handbook of Theoretical Computer Science, V olume
B: F ormal Models and Semantics, chapter Temporal and Modal Logic,
pages 995–1072. J. van Leeuwen, ed., North-Holland Pub. Co./MIT
Press, 1990.
[17] M. D. Ernst, J. Cockrell, W. G. Griswold, and D. Notkin. Dynamically
discovering likely program invariants to support program evolution.
IEEE Transactions on Software Engineering (TSE), 27(2):99–123, 2001.
[18] D. Fahland, D. Lo, and S. Maoz. Mining branching-time scenarios.
InProceedings of the Conference on Automated Software Engineering
(ASE), pages 443–453, Nov 2013.
[19] M. Gabel and Z. Su. Javert: Fully automatic mining of general temporal
properties from dynamic traces. In ACM SIGSOFT International
Symposium on F oundations of Software Engineering (FSE), Atlanta,
GA, USA, 2008.[20] M. Gabel and Z. Su. Symbolic Mining of Temporal Speciﬁcations.InProceedings of the 2008 International Conference on Software
Engineering, 2008.
[21] M. Gabel and Z. Su. Online inference and enforcement of temporalproperties. In Proceedings of the 32Nd ACM/IEEE International
Conference on Software Engineering - V olume 1, ICSE ’10, pages
15–24, New Y ork, NY , USA, 2010. ACM.
[22] M. Gabel and Z. Su. Testing mined speciﬁcations. In ACM SIGSOFT
International Symposium on F oundations of Software Engineering (FSE),
Cary, NC, USA, 2012.
[23] C. Ghezzi, M. Pezz `e, M. Sama, and G. Tamburrelli. Mining behavior
models from user-intensive web applications. In ACM/IEEE International
Conference on Software Engineering (ICSE), Hyderabad, India, 2014.
[24] H. B. Giles Reger and D. Rydeheard. A Pattern-Based Approach to
Parametric Speciﬁcation Mining. In Proceedings of the 28th IEEE/ACM
International Conference on Automated Software Engineering. ASE
2013, November 11-15 2013.
[25] H. B. Giles Reger and D. Rydeheard. Automata-based Pattern Mining
from Imperfect Traces. In Proceedings of the Second International
Workshop on Software Mining. ASE 2013, November 11-15 2013.
[26] L. Lamport. Time, clocks, and the ordering of events in a distributed
system. CACM, 21(7):558–565, 1978.
[27] T.-D. B. Le and D. Lo. Beyond support and conﬁdence: Exploring
interestingness measures for rule-based speciﬁcation mining. In Software
Analysis, Evolution and Reengineering (SANER), 2015 IEEE 22nd
International Conference on, pages 331–340, March 2015.
[28] W. Li, A. Forin, and S. A. Seshia. Scalable Speciﬁcation Miningfor V eriﬁcation and Diagnosis. In Proceedings of the 47th Design
Automation Conference, DAC ’10, pages 755–760, New Y ork, NY , USA,
2010. ACM.
[29] V . B. Livshits and T. Zimmermann. Dynamine: Finding common error
patterns by mining software revision histories. In Proceedings of the
10th European Software Engineering Conference held jointly with 13th
ACM SIGSOFT International Symposium on F oundations of Software
Engineering, pages 296–305. ACM, September 2005.
[30] D. Lo and S. Maoz. Scenario-based and value-based speciﬁcation mining:
Better together. In IEEE/ACM International Conference on Automated
Software Engineering (ASE), pages 387–396, Antwerp, Belgium, 2010.
[31] D. Lo, S. Maoz, and S.-C. Khoo. Mining modal scenario-based
speciﬁcations from execution traces of reactive systems. In Proceedings
of the Twenty-second IEEE/ACM International Conference on Automated
Software Engineering, ASE ’07, 2007.
[32] D. Lo, L. Mariani, and M. Pezz `e. Automatic steering of behavioral
model inference. In European Software Engineering Conference and
ACM SIGSOFT International Symposium on F oundations of Software
Engineering (ESEC/FSE), 2009.
[33] D. Lo, G. Ramalingam, V . P . Ranganath, and K. V aswani. Mining
quantiﬁed temporal rules: Formalism, algorithms, and evaluation. Sci.
Comput. Program., 77(6):743–759, 2012.
[34] D. Lorenzoli, L. Mariani, and M. Pezz `e. Automatic generation of
software behavioral models. In ACM/IEEE International Conference on
Software Engineering (ICSE), 2008.
[35] T. Ohmann, M. Herzberg, S. Fiss, A. Halbert, M. Palyart, I. Beschastnikh,
and Y . Brun. Behavioral Resource-Aware Model Inference. In
Proceedings of the 26th IEEE/ACM International Conference On
Automated Software Engineering (ASE), September 2014.
[36] M. Pradel and T. R. Gross. Leveraging test generation and speciﬁcationmining for automated bug detection without false positives. In ACM/IEEE
International Conference on Software Engineering (ICSE), 2012.
[37] M. Pradel, C. Jaspan, J. Aldrich, and T. R. Gross. Statically checking
API protocol conformance with mined multi-object speciﬁcations. In
ACM/IEEE International Conference on Software Engineering (ICSE),
2012.
[38] M. Robillard, E. Bodden, D. Kawrykow, M. Mezini, and T. Ratchford.
Automated API Property Inference Techniques. Software Engineering,
IEEE Transactions on, 39(5):613–637, May 2013.
[39] V . Stolz and E. Bodden. Temporal Assertions Using AspectJ. Electron.
Notes Theor . Comput. Sci., 144(4):109–124, May 2006.
[40] Texada. https://bitbucket.org/bestchai/texada.
91[41] S. Thummalapenta and T. Xie. Mining exception-handling rules as
sequence association rules. In Proceedings of the 31st International
Conference on Software Engineering, ICSE ’09, pages 496–506, Wash-
ington, DC, USA, 2009. IEEE Computer Society.
[42] W. van der Aalst, H. de Beer, and B. van Dongen. Process Mining and
V eriﬁcation of Properties: An Approach Based on Temporal Logic. In
R. Meersman and Z. Tari, editors, On the Move to Meaningful Internet
Systems 2005: CoopIS, DOA, and ODBASE, volume 3760 of Lecture
Notes in Computer Science, pages 130–147. Springer Berlin Heidelberg,
2005.
[43] M. V ardi. An automata-theoretic approach to linear temporal logic. In
F. Moller and G. Birtwistle, editors, Logics for Concurrency, volume
1043 of Lecture Notes in Computer Science, pages 238–266. Springer
Berlin Heidelberg, 1996.
[44] N. Walkinshaw and K. Bogdanov. Inferring ﬁnite-state models withtemporal constraints. In IEEE/ACM International Conference on
Automated Software Engineering (ASE), pages 248–257, L’Aquila, Italy,
September 2008.
[45] N. Walkinshaw, R. Taylor, and J. Derrick. Inferring Extended Finite
State Machine Models from Software Executions. Empirical Software
Engineering, pages 1–43, 2015.
[46] W. Weimer and G. C. Necula. Mining temporal speciﬁcations for error
detection. In Proceedings of the 11th International Conference on Tools
and Algorithms for the Construction and Analysis of Systems, TACAS’05,
pages 461–476, Berlin, Heidelberg, 2005. Springer-V erlag.
[47] J. Yang, D. Evans, D. Bhardwaj, T. Bhat, and M. Das. Perracotta: Mining
temporal API rules from imperfect traces. In ACM/IEEE International
Conference on Software Engineering (ICSE), pages 282–291, Shanghai,
China, 2006.
92