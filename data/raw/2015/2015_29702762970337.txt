Static Race Detection for Device Drivers:
The Goblint Approach
Vesal Vojdani
University of Tartu, EstoniaKalmer Apinis
University of Tartu, EstoniaVootele R√µtov
University of Tartu, Estonia
Helmut Seidl
Technische Universit√§t
M√ºnchen, GermanyVarmo Vene
University of Tartu, EstoniaRalf Vogler
Technische Universit√§t
M√ºnchen, Germany
ABSTRACT
Devicedriversrelyonfine-grainedlockingtoensuresafeaccessto
shareddatastructures. Forhumantesters,concurrencymakessuch
codenotoriouslyhardtodebug; forautomatedreasoning,dynami-
cally allocated memory and low-level pointer manipulation poses
significantchallenges. Wepresentaflexibleapproachtodatarace
analysis, implemented in the open source Goblint static analysis
framework that combines different pointer and value analyses in
ordertohandleawiderangeoflockingidioms,includinglocksal-
locateddynamicallyaswellaslocksstoredinarrays. Tothebestof
ourknowledge,thisisthemostambitiouseffort,havinglastedwell
overtenyears,tocreateafullyautomatedstaticracedetectiontool
that can deal with most of the intricate locking schemes found in
Linuxdevicedrivers. Ourevaluationshowsthattheseanalysesare
sufficiently precise, but practical use of these techniques requires
inferringenvironmentalanddomain-specificassumptions.
CCS Concepts
‚Ä¢Theory of computation !Program analysis; ‚Ä¢Software and its
engineering !Software safety;
Keywords
Concurrency,racecondition,abstractinterpretation
1. INTRODUCTION
Amultiple access data race occursinaconcurrentprogramwhen
differentthreadssimultaneouslyattempttoaccessasharedmemory
locationandoneoftheaccessesisawriteoperation. Withoutproper
synchronization, the result of such accesses areunpredictable. As
a problem notoriously hard to debug, there has been plenty of ef-
forttodetectsuchbugsstatically[23,24,34,46]. However, fully
automatedstaticanalyzershavehadlimitedsuccessinchallenging
settings,suchasanalyzingdevicedrivers.
The basic approach to race detection is to track the set of locks
definitely held by each thread, and so ensure that all accesses todata mtx
list
prev nextdata mtx
list
prev nextdata mtx
list
prev next
nodelist
next prevlist_lock
Figure 1: Mixed-granularity locking scheme.
sharedmemorylocationsareprotectedbyacommonlock. Thisso-
called lockset algorithm wasfirstappliedinadynamicsetting[14].
Thereare, however, seriousdifficultieswhenadaptingthisideato
the static analysis of Linux device drivers. In low-level C code,
locks can be placed within heap-allocated data structures, as de-
picted in Figure 1. Elements within a linked list have their own
locks protecting their data fields; however, the linked list itself is
protectedbyalistlock. AstheLinuxkernellistshavetheirfields
embedded into the container struct, we have different portions of
thesamestructurebeingprotectedwithdifferentlocksofdifferent
granularity. Sincepreciseshape-analysisiscostlyforthelow-level
linkedlistsprovidedbytheLinuxlistAPI[25,26],weuseacom-
bination of aliasing and points-to analyses each targeting locking
schemesofdifferentgranularities.
Linuxcodealsofeaturescomplicatedcontrolflow. Conditional
locking, possibly failing locks, and value-dependent synchroniza-
tion have been reported as major sources of false alarms for race
detectors[37,46]. Theseconstructsrequirethatthevaluesofpro-
gram variables be taken into account in a concurrent setting. Fur-
ther,whenlocksarestoredinarrays,weneedrelationalanalysesto
correlatelockindiceswiththedatatheyprotect.
We present an algorithm for static race detection that can deal
with value-dependent synchronization, and we then extend this to
deal with several locking schemes for dynamically allocated data.
Most crucially, the approach we present in this paper is paramet-
ric on the precise analyses used. Race freedom is a conditional
propositionthatrequiresthecombinationofmay-aliasinformation
with must-equality information. We show how such information
canbecombinedinamodularandgenericfashion. Thisextensibil-
ityhasallowedustokeepimprovingtheframework,adaptingitto
different concurrency models, as well as considering increasingly
complicatedlockingidioms.
The algorithm described in the paper was implemented in the
Goblinttool,whichwasusedtoevaluatetheapproach. TheGoblint
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission and/or a
fee. Request permissions from Permissions@acm.org.
ASE‚Äô16 , September 3‚Äì7, 2016, Singapore, Singapore
c2016 ACM. 978-1-4503-3845-5/16/09...$15.00
http://dx.doi.org/10.1145/2970276.2970337
391
isanexhaustivebugdetectiontool: itreliesonsounddataflowanal-
ysesusingabstractdomainstoconservativelyover-approximatethe
behavior of the system. Thus, when the analyzer is satisfied, we
have high confidence in the correctness of the analyzed code, but
thenaturaldrawbackisthatwemayhavemanyspuriouswarnings.
To get a realistic impression of its ability, we chose as our analy-
sis targets all Linux character device drivers which our front-end
librarycoulddigest. Theresultsshowthatonaveragelessthan5%
of memory locations are ruled potential races where the access is
directlyinthesourcecodeofthedriver. Whilewewerenotableto
excludethesecasesaspotentialracesuponmanualinspection,we
did not find any races in currently maintained device drivers that
wewereconvincedcouldleadtoacrashorcorruptionofdata. For
apracticallyusefultool,westillneedtoreducethenumberoffalse
alarms by taking domain-specific and environmental assumptions
intoaccount. Insummary,thispapermakesthefollowingcontribu-
tions:
Wepresentasoundconcurrencyabstraction,basedon privati-
zation,thatcandetectracesandcomputethevalueofinteger
variables(Section3).
Weextendtheprivatizationapproachfromstaticintegersvari-
ables to generic heap regions. We present a race detection
algorithm parametric on may- and must-alias analyses that
can deal with a wide range of locking schemes (Sections 4
and5).
Wehaveimplementedthisapproachintheopen-sourceGob-
lintanalyzer1andevaluatedthisapproachonasetofdevice
drivers(Section6).
Wewillbeginbypresentingtheconsistencymodelthatarchitecture-
independentcodeintheLinuxkernelmayassume. Thiswillmake
our analysis much clearer because there is a correspondence be-
tween what our analysis computes and the configurations of the
model. Section4illustratesourapproachwithmanyexamples.
2. CONSISTENCY MODEL
The Linux operating system supports many different architec-
tures,eachwithdifferingmodelsofmemoryconsistency. Outside
architecture-specific code, we can make few assumptions about
when read and write operations are visible to different threads. In
thissection,wedescribeamodelofconcurrentexecutionthatonly
makestheconsistencyassumptionssatisfiedbyallarchitectures.
AsweanalyzeLinuxkernelmodulesseparately,wemodeleach
driverasanopenprogramoperatinginahostileenvironment. Each
module contains an initialization function where execution of the
modulebegins. Thisfunctionwilleventuallyregisterasetofcall-
backfunctionsandinterrupthandlerswiththeenvironmentwhich
can then call these exported functions at will. From the moment
these functions are registered, we assume they can potentially run
inparallel. Inreality,therearemorerefinedschedulingconstraints;
e.g., probe functions and open/close run sequentially for each de-
vice. Althoughourconcurrencymodelover-approximatesthedata
flow, we can still consider more refined may-run-in-parallel infor-
mationwhenreportingdataraces,aswillbeseeninExample5.
In our model, whenever the kernel calls the operations of the
devicedriver,theassociatedcallbackfunctionrunsinanewthread
instance. FollowingtheterminologyofDeligiannisetal.[13],the
registeredfunctionsformthesetofthread templates T. Thecode
of each thread template t2 Tis given as a control flow graph
1https://github.com/goblint/analyzer.Gt= (N;E;nt)whereNis the set of program points, ntthe
start point of this thread template, and each edge (u;l;v )2Eis
a transition labeled with either an elementary command sor one
oftheprimitiveconcurrencyoperationsforacquiringandreleasing
mutexes:
l::=sjlock(m)junlock (m):
Sincethispaperfocusesexclusivelyonlock-basedsynchronization,
we do not include in our formalism any constructs for threads to
waitoneachotherwithouttheuseofmutexes,suchaswaitqueues,
eventsandconditionalvariables.
As an unbounded number of instances of each thread template
may run in parallel, the set of thread identifiers is I=T N.
Henceforth,whenweusetheword‚Äúthread‚Äù,wespecificallymean
thesethreadinstancesidentifiedbytheelementsin I. Thus,inour
formalmodel,weassumethatafterexecutionofsomeinitialization
code, we have an infinite set of threads Iready to run in parallel.
Thesethreadsissueinstructionsthatinvolvememoryaccesses, in-
cluding the synchronization operations. In a multi-processor sys-
tem, such instructions are not completed instantly. The following
recountsthestandardterminology.
Definition 1. Aninstructionis completed with respect to another
threadwhen that thread can read the new value, in the case of a
store,ornolongerinfluencetheresult,inthecaseofaread. Anin-
structionis completed whenitiscompletedwithrespecttoallother
threads. There has to be some memory consistency between the
views of each thread; this is determined by the consistency model
ofthearchitecture.
Asmentionedabove,wehavetoassumetheweakestconsistency
model common to all supported architectures. The Linux mem-
orymodelonlyprovidestheguaranteesof release consistency [15].
Under this consistency model, synchronization operations are dis-
tinguished as acquire and release operations, and they only serve
asone-waybarriers. Forexample,memoryoperationsissuedafter
an acquire will be completed after the acquire operation has com-
pleted;however,memoryoperationsissuedbeforetheacquiremay
be completed after the acquire operation has completed. We de-
scribe the model at a high level, leaving the details of the cache
coherence protocol and its implementation to indeterminism. We
onlyenforcethat,atworst,cachesneedtobeflusheduponrelease
andinvalidateduponacquire.
LetLdenotetheaddressspace,i.e.,thesetofmemorylocations,
available to the program. To reduce notational overhead, we treat
local variables as thread-local globals in this formalization. The
state of a single-threaded program could be described by its pro-
gramcounter,indicatingthelocation u2Nofthenextcommand
tobeexecuted,andamappingfrommemorylocationstotheirval-
ues. Astheintra-threadsemanticsisoflittleinteresttous,weshall
justviewmemorylocationsasholdingintegervalues. Thestateof
memoryisthusrepresentedasamappingin D=L !N.
The state of executing a multi-threaded program is represented
inourmodelbythelocalstatesofeachofthethreadsin Iaswell
as shared state œÜ2 D, representing, e.g., physical memory or
the value at the home node, depending on the architecture. In our
model, commands are issued in their intra-thread order, although
the order in which they complete is non-deterministic. The state
of an individual thread i2 Iis thus characterized by its program
counterui, indicating the command it is about to issue, and the
thread‚Äôslocal(possiblycached)viewofmemory i2 D. Inorder
to formalize the consistency model, we also associate with each
thread, the set of lock addresses it has acquired i22Las well
asthesetofaddresses wi22Lwhosecachedvaluesareyettobe
392Table 1: Summary of notation (mnemonic aid for entire paper, not self-contained).
Concretemodel Abstractanalysis
‚Éó u:I !Nprogramcounterforeachthread u:N computesinvariantforeachprogrampoint.
‚Éó :I ! D memoryviewofeachthread  :N!Dprivatizedstateatthatprogrampoint.
‚Éó :I ! 2Llocksheldbyagiventhread. :N!2Msmust-setof(symbolic)locksatthatpoint.
‚Éó w:I ! 2Lpendingwrites(dirtycache) :G!2Mrcommon(relative)locksduringaccess.
œÜ:D mainmemory. 	:D globalinvariant.
flushed to main memory. The components of the concrete model
are summarized in Table 1, which also shows the corresponding
analysisabstractionofeachcomponent.
Wemodeltheexecutionasanon-deterministictransitionsystem.
A configuration d0= (‚Éó u0;‚Éó 0;‚Éó 0;‚Éó w0;œÜ0)is an initial configura-
tion if‚Éó u0maps each thread to an entry of a function, ‚Éó 0maps all
threads to the empty lockset, ‚Éó w0states that no thread has pending
cachewrites,and 0=œÜ0isapossiblestateofmainmemoryafter
runningtheinitializationcode. Let D0denotethesetofinitialcon-
figurations. Givenaninitialstate,thesystemevolvesaccordingto
thefollowingtransitions.
Atanymoment,anythread i2 Icanbechosenandthestateof
the system is updated. We adopt the following notational conven-
tiontodescribethesetransitions:
(‚Éó u;‚Éó ;‚Éó ;‚Éó w;œÜ )!(‚Éó u‚Ä≤;‚Éó ‚Ä≤;‚Éó ‚Ä≤;‚Éó w‚Ä≤;œÜ‚Ä≤):
Weuseprimedsymbolstodenotethepost-state,andwewillspec-
ifyonlythechangestothepost-state,assumingthesemapsremain
thesameforanyvaluenotexplicitlymentionedinthedescriptions
below. There are two kinds of transitions in our system: one cor-
respondstotheCPUissuinganinstructionandtheotheraretransi-
tionssimulatingarbitrarybehaviorsofthememorysubsystem. We
firstconsiderthelatterrules.
Flush.Anypendingwrites x2wimaybeflushedtomainmem-
orysuchthat œÜ‚Ä≤(x) =i(x)andw‚Ä≤
i=win fxg.
Invalidate. Clean locations in the cache xÃ∏2wimay be invali-
dated at any time. We model this by immediately updating
thevalueinthecache ‚Ä≤
i(x) =œÜ(x).
In real systems, and in our analysis implementation, cache invali-
dationonlysetsaflagandthecacheisonlyupdateduponanactual
readrequest. Thismodelisstillsuitabletoprovethesoundnessof
ouranalysisbecauseitisanon-deterministicmodelthatallowsthe
refreshingofthecacheatanytime.
The CPU transitions will update the program counter as it is-
suesinstructions. Forathread i,assumethereisanoutgoingedge
(ui;l;v)2Efrom its current program counter uito some other
nodev. If the instruction lcan be issued in the current configu-
ration, we take that transition and set u‚Ä≤
i=v. We now consider
the effect of issuing ordinary as well as synchronization actions.
We assume an intra-thread semantic function for basic statements
JsK:D ! D. This may be a partial function; for example, if s
is a conditional guard the transition is only defined when the in-
putstatesatisfiestheconditionof s. Weobtainthesetofreadand
write accesses while evaluating that instruction using the function
JsKa:D ! 2Lwherea2 fr;w; rwgindicatestheaccessesweare
interestedin.
Statements. IfJsKiis defined, we update the thread-local view
‚Ä≤
i=JsKi. Wealsomarkanyupdatedlocationsasdirtyin
thecachew‚Ä≤
i=wi[JsKwi.Acquire.Ifthelockmisavailable,i.e., mÃ∏2‚à™
jj,weset‚Ä≤
i=
i[ fmgandweinvalidateallcleancachelocations: 8xÃ∏2
wi:‚Ä≤
i(x) =œÜ(x).
Release.If we have the lock, i.e., m2i, we release the lock
‚Ä≤
i=in fmgand flush all pending writes: 8x2wi:
œÜ‚Ä≤(x) =i(x)andw‚Ä≤
i=‚àÖ.
The side condition for acquire, which only permits the acquisi-
tionofalockifnothreadalreadyholdsit,ensuresnon-interleaving
execution of critical sections protected by the same lock. The re-
lease transition requires that a thread holds the lock it attempts to
release. AccordingtothesemanticsoftheKernelmutexsubsystem,
attempting to reacquire a lock one already holds results in a dead-
lock,whileattemptingtoreleasealockonedoesnotholdresultsin
afailure;bothcasesleadtostuckstatesinoursemantics.
Definition 2. The set of reachable configurations Dis the tran-
sitive reflexive closure of the transition relation applied to the set
ofinitialconfigurations,i.e.,
D=fdj 9d02D0:d0!dg:
Definition 3. There is a race in configuration (‚Éó u;‚Éó ;‚Éó ;‚Éó w;œÜ )at
locationx2 Lifdistinctthreads iandjmaybothissueinstructions
accessing that location, i.e., (ui;s1;_)2Eand(uj;s2;_)2E
withx2Js1Krwi\Js2Krwj. Wesaythereisaraceatlocation
x2 Lifthereexistsaconfiguration d2Dcontainingaraceat x.
Here,wedonotdistinguishbetweenreadorwriteaccesses. This
distinction,thoughpracticallyimportant,isnotconceptuallyinter-
esting and would make the subsequent analysis far more cumber-
sometodescribe.
3. VALUE AND MUTEX ANALYSIS
Computingwhetherthereexistracesinaprogrambasedonthe
semanticsdescribedpreviouslyisinfeasible. Thenumberofinter-
leavings grows exponentially with the number of statements even
forjusttwothreads. Inwhatfollows,ourgoalistoprovideefficient
analyses that can detect races, first assuming memory locations L
arelimitedtoasetoffixedintegervariablenames G,andthengen-
eralizingtoabstractionsofarbitrarymemorylocationsinSection5.
Thegeneralapproachistosetupaconstraintsystemthatuses ab-
stractsemanticsinstead,wherethesolutionoftheconstraintsystem
providesusreliableinformationaboutdataraces.
ConsidertheprograminFig.2. Themainthreadsetstheglobal
variablexto1andstartstwothreads. Globally,thesharedvariable
xhas value 1. This invariant, however, is locally violated by the
first thread while it holds the lock. The other thread relies on the
invariant to hold whenever it acquires the lock; otherwise, it sets
xto an error value. Verifying that this program is free from races
requirestheinferenceoftheinvariant,buttheinvariantcanonlybe
soundlydeducediftheprogramcanbeshowntobefreefromraces.
This means that the invariants and data races are to be inferred at
thesametime.
3931t1 2 3 4 5
6t2 7 8 9
1011lock(m)
x=x+ 1
x=x 1
unlock(m)
lock(m)
if(xÃ∏= 1)
if(x= 1)unlock(m)
unlock (m)x= 1
Figure 2: Example program in our model.
Our abstract semantics contains a global lockset mapping , a
globalinvariant 	,andforeachprogrampoint,asetoflocks as
well as a privatized mapping of the variables to their abstract val-
ues . Inourimplementation, thismappingprimarilystoreslocal
variables, but we will focus here on the framework for analyzing
sharedglobalvariablesthatareprivatized,andthustreatedaslocal
variables, within critical sections. The analysis itself is succinctly
expressed as a constraint system. We will present this top-down,
first showing the entire system and only then defining the func-
tionsusedintheconstraints. Forallprogrampoints u2N,edges
(u;s;v )2E,sharedglobals x2G,andstartpoints ntwitht2 I,
wehavethefollowingconstraints.
(v; v)‚äíJsK‚ôØ(u; u) (1)
(nt; nt)‚äí(‚ä§; 0) (2)
‚äímfs(u; u) (3)
	‚äísyncs(u;; u; u) (4)
 u‚äísyncs(u;; u;	) (5)
Thefirsttwoconstraintsareconcernedwiththeintra-threadbe-
havioroftheprogram. Weassumethatwehaveasoundvalueand
lockset analysis that give the abstract intra-thread semantics of an
individual instruction as JsK‚ôØ. This function is applied in the first
constraint to the privatized state  uand the obtained values must
be taken into account by the local state and lockset at the destina-
tionnode. Thesecondconstraintmakessurethreadsstartwiththe
proper initial values. Since we track must-sets of locks, the order-
ingisreversedwith ‚ä§=‚àÖand?=M;thelock-setsareinitially
empty.
Thethirdconstraintupdatesthemapthatspecifieswhichglobals
areprotectedbywhichlocks. Thisisdoneusingthemutexfunction
mfsalongsideinterpretationofaninstruction sintheabstractstate
 . Thus,weneedtoconstrainthelocksetoftheaccessedvariables
JsK‚ôØ
rw withthecurrentlockset .
mfs: (D2M)!G!2M
mfs( ;)x={
ifx2JsK‚ôØ
rw 
?otherwise.
As the bottom value here is M, we effectively leave the locksets
fortheuntouchedglobalsalone.
The last two constraints correspond to the flushing and invali-
dation actions of the concrete model. Here the privatized values
of unprotected globals are synchronized with the global invariant.Table 2: Fixpoint computation of the example.
u u(x)u (x)comment
1 1 ‚àÖ MStartwith 0andM
2 1 fmgMlockisacquired
3 2 fmgfmgprotectedaccessto x
4 1 fmgfmgxisstillprotected
5 1 ‚àÖfmgonlynow 5(x)‚äë (x)
6 1 ‚àÖfmgStartwith 0‚äî (x)
7 1 fmgfmglockisacquired
8 ?M fmgconditionxÃ∏= 1isfalse
9 ?M fmgdeadcode: notarace!
10 1 fmgfmgconditionx= 1maybetrue
11 1 ‚àÖfmglockisreleased
1 1 ‚àÖfmgre-computefirstthread
2 1 fmgfmg2(x)\(x)Ã∏=‚àÖstillholds
3 2 fmgfmgFixpoint!
Forthis,weneedanoperatorthatdeterminesthesetofglobalspro-
tectedbysomelockset accordingtothegloballocksetmap :
prot() =fx2Gj\(x)Ã∏=‚àÖg:
Wethendefineasynchronizationfunctionthatreturnsnon-bottom
valuesfromamap  ‚Ä≤fortheunprotectedglobalsthatareaccessed
byastatement sinstate :
syncs(;; ; ‚Ä≤)x=
{
 ‚Ä≤xifx2JsK‚ôØ
rw andxÃ∏2prot()
?otherwise.
Usingthisfunction,thelasttwoconstraintssynchronizethepriva-
tizedinformationwiththeglobalinvariant  ontheportionofthe
sharedstatethatmaynotbeprotectedatagivenprogrampoint.
Wesolvethesystembyfixpointiteration. Theconstraintsystem
is monotonic because as the locksets are constrained, fewer and
fewervariablesareprivatized. Wecansolvethesystembyiterating
fromtheleastelementasshowninthefollowingexample.
Example 1. The process of solving the constraint of the exam-
plefromFig.2isshowninTable2. Foreachprogrampoint u,the
values u(x)anduhavetobe(re-)computedforacommon (x).
The value (x)will start off as the set of all mutexes Mand can
only decrease. The integer variable is initially unreachable ?and
thelocksetistheemptyset. First,wecomputethethreevaluesfor
eachrowgoingfromtoptobottomofthetableinthenaturalorder
oftheprogrampointlabels. Afterthefirstiterationweseethatwe
mustcomputeprogrampoints1and2again,astheyhavenotbeen
consideredfor (x) =fmg. However,noneoftherespectiveval-
ues u(x)andunorthestartingpointofthread2willchange. We
have,therefore,foundtheleastsolutionoftheconstraintsystem.
Having computed the least solution to the above constraint sys-
tem we will flag all global variables with an empty lockset as po-
tentiallyracing:
race =fx2Gj(x) =‚àÖg:
Next,wewillformallyrelateourabstractsemanticswiththecon-
crete model. This will be done using a concretization function 
that maps abstract states Sinto sets of concrete states Dthat are
representedby S. Forthiswerequirethattheanalysisweusealso
394providetheirconcretizationfunction‚Äîwhichwewillalsocall .
Notethatthemainconcretizationfunction willnotnecessarilybe
monotonic. Wedonotrequiremonotonicityaswewillonlyuseit
toshowsoundnessofsolutionsoftheconstraintsystem.
LetS= (;; ;	)be a solution to the above constraint sys-
tem. Aconfiguration (‚Éó u;‚Éó ;‚Éó ;‚Éó w;œÜ )2(S)iffthefollowingcon-
ditionshold:
For each thread i, whose program counter is now ui, the
mutexesacquiredaresoundlyapproximatedbytheanalysis,
uii,andthelocksetsdonotoverlap,i.e., i\jÃ∏=‚àÖ
onlyifi=j.
The global invariant contains the values for all unprotected
globals:
8xÃ∏2‚à™
j2Iprot(uj) :œÜ(x)2(	(x)):
Thewaythread iviewsmemoryiscorrectlyrepresentedfor
allglobalsitmayaccessorforwhichithaspendingwrites:
8x2prot(ui)[race [wi:i(x)2( ui(x)):
The set of pending writes wimust include all updated pro-
tectedglobals:
fx2prot(ui)ji(x)Ã∏=œÜ(x)g wi:
Theanalysisdoesnotcareaboutvaluesthatcannotbeaccessedby
thegiventhreads. Also,theglobalinvariantonlypartiallyspecifies
the values of main memory. Within a critical section, the state of
main memory could have any value as this does not influence the
value of the computation after synchronization points. Thus, we
mayincludesomeconfigurationsinourinterpretationoftheanaly-
sisresultthatarenottrulyreachable,butwhatreallymattersisthat
wearecertaintoincludeallreachableconfigurations.
Theorem1 (Soundness). IfSis the least solution to the above
constraint system and D is the set of reaching configurations, we
haveD(S).
Proofidea. AsDistheleastsetclosedunderthetransitionsde-
finedintheprevioussection,wewouldneedtoshowthatthecon-
cretizationofouranalysisresults (S)isalsoclosedundereachof
the transition rules. We will briefly describe the key observations
thataformalsoundnessproofwouldrelyon. Forordinaryinstruc-
tions, constraints(3) and(5)ensure thatallvalues accessibleby a
threadatprogrampoint uaresoundlyover-approximatedinthepri-
vatizedstate  u. Theresultingcomputation,therefore,remainsin
(S)aslongasourintra-threadtransferfunctionsaresound.
Let us also consider a release action. In this case, a previously
protectedlocationmaynowbeunprotectedandotherthreadsmay
potentiallyaccessit. Wedidnotrequireprotectedvaluestoberep-
resented by our global invariant, but the value is correctly repre-
sentedinthelocalstate  u. Aswerequirethatprotectedlocations
with differing cached values mark such locations as dirty, the out-
standing write will complete, and by constraint (4) that value is
propagatedintotheglobalinvariant. Conversely,duringanacquire
action,someglobal xmaynowbeprotectedbyathread i. Inthat
case,thevalueof xiseitheralreadyrepresentedin  u,orwehave
xÃ∏2wi,sothecachemustbeinvalidated,andbyconstraint(5),the
local state will take the correct value of xfrom the global invari-
ant.
Theorem2 (Racefreedom). LetS= (;; ;	)be a solu-
tion to the constraint system. For any global x2G, if there is a
race atx, we havex2race .Proof.For there to be a race at variable xthere would need to
be some reachable configuration where two different threads both
issue instructions accessing x. Given that their locksets may not
overlap and our analysis is sound, (x)would be constrained by
twosetswithnoelementsincommon,ensuring (x) ‚àÖ.
Theanalysiscanbeinstantiatedwithdifferentabstractdomains
andourframeworkallowtheseanalysestobebothpath-andcontext-
sensitive. Path-sensitivityisimportantinordertodealwithcondi-
tional locking or potentially failing locking operations. For this,
we use a property-simulation abstract domain [12]. The relevant
property is the set of definitely held locks, so we never join lock-
sets;instead,wetrackthevalueabstractionforallpossiblelocksets.
In this way, an operation like r=try_lock(m)will split the state,
reflectinginthereturnvalue rwhetherthelockisacquiredornot.
We have not included function calls and local variables in this
framework because our treatment is fairly standard and relies on
the entry and combine operators used in the functional approach
to inter-procedural analysis [41]. Applying the flow-insensitive
treatment of shared globals in a context-sensitive setting requires
computingpartialglobalinvariants[39],asweonlywantconsider
thecontextsthatareencounteredduringanalysis,resultinginside-
effectingconstraintsystems[3].
4. A GENERAL APPROACH
We now extend the notion of a memory location from a set of
static variables to static identifiers that represent disjoint portions
of shared memory locations. We do not rely on a fixed heap ab-
straction;instead,ourgoalistoarriveataflexibleframeworkthat
combinesdifferentanalyses. WemayeventakeamoreEinsteinian
viewofspaceandencodetemporalinformationaswell. Generally
speaking,racefreedomisaconditionalpropositionoftheform:
‚ÄúIftwoaccesses mayconflict,
certainsafetyconditions musthold.‚Äù
Forexample,iftwoaccessexpressionsmayalias,theircorrespond-
ing lock expressions must alias. There are, however, other justi-
fications for excluding races that fit within this paradigm. We let
each analysis contribute to either side of the conditional: a thread
uniquenessanalysisprovidesanadditionalsafetyguaranteeexclud-
ingraces,whileahappens-beforeanalysiscanrefinethenotionof
whenaccessesmayconflict.
Instead of the set Gof variables from a fixed set of names, we
nowmovetoanabstractdomain G,representingmainlymay-alias
equivalenceclasses. Combiningmay-aliasinformationisstraight-
forward: given two analyses that soundly partition memory into
may-aliasequivalentclasses,theirCartesianproductwillalsoform
a sound partitioning. Our privatization framework requires that
we not only answer pairwise may-alias queries, but that we give
acanonicalrepresentativeforeachaddressexpression. Thisispro-
vided by, e.g., by region-based shape analyses [19, 38]. We refer
to the canonical representative of a heap region as the ownerof
that region. In order to correlate regions with locks, owners must
refer to unique memory locations that can be described statically.
Such descriptions, however, may depend on parameters, such as
the base address and integer offsets, to specify concrete locations
intheheap.
Example 2. Considerthefollowingexampleofper-elementlock-
ing. Theassumptionhereisthattheparameterisentirelyunknown
to us; still, it should not be hard to establish that the program is
race-freeforanyelementoftype node.
395struct node { mutex mtx; int data; }
thread t(struct node *p) {
lock (&p!mtx);
p!data++;
unlock (&p!mtx);
}
Wehavenobetterdescriptionoftheregionthisaccessbelongsthan
its type and the field that was accessed. For the lock, we have to
keepasymboliclockset fp!mtxg,andifatthetimeofaccess,we
canestablish thatthe basepointers areequal, weconvert thesym-
boliclocksettoarelativelockset f‚ãÜ.mtxgbyreplacingreferences
torealvariableswithsymbolichostvariables. Forthisexample,we
get
(node.data) =f‚ãÜ.mtxg:
This will serve to decouple our may- and must-alias information,
so that we can map an arbitrary may-alias equivalence class to a
locksetanduse ‚ãÜtorefertoindividualelementsofthisequivalence
class.
Example 3. Thisideacanalsobeappliedtodealwitharray-based
locking. Ifwehaveanarrayoflocksthatisusedstatically,wecould
simplyaddconcreteindexestothelockset. Ifwecanestablishan
equality,though,wereplacetheindexwithasymbolicindex. Con-
sider a simple program now with an array of locks protecting an
arrayofdata:
mutex mtxs[1024]; thread t1(int i) {
int data[1024]; lock (&mtxs[i]);
data[i]++;
unlock (&mtxs[i])
}
We will now replace anything established an equal by an integer
must-equalityanalysiswithsymbolicindices:
(data[‚ä§]) =fmtxs[‚ãÜ0]g:
Example 4. We say that a thread is unique if only a single in-
stanceofagiventhreadtemplateiseverspawned. Wecanassume
thatauniquethread talwaysholdsamutex mt. Thereisaclassic
exampleintheIntelThreadCheckertutorialwherethethreadcre-
atedbyparameter iistheonlythreadthataccesseselement data[i].
int data[1024]; int main() {
int i = 0;
thread t(int i) { while (i < 1024)
data[i]++; spawn(t, i);
} }
Givenananalysisthatensures itakesuniquevaluesineachiteration
ofthewhileloop,wecanverifythisexamplebyreducingitthecase
abovewherethearrayisprotectedbyanarrayoflocks:
(data[‚ä§]) =fmt[‚ãÜ0]g:
Example 5. Asimilarapproachenablesustomakeuseofdomain-
specificknowledge. Considerfollowingtwofunctions:
void open(file *f){ void close(file *f){
g++; g--;
f!data++; f!data--;
} }
Assumethatthereisanenvironmentalguaranteethatforeachfile f,
thesefunctionsarecalledsequentiallywithopenalwayspreceding
aclose;however,differentfilesmaybeopenedconcurrently. Basedmtxs slots t
Figure 3: Medium-grained locking scheme [38].
onthisinformation,weareabletodeducethateachaccessto fin
function openis protected by the lock mopen[‚ãÜ0]and that accesses
tof!datainopenandclosecannot race as they are time-wise
disjoint:
(file.data;open) =fmopen[‚ãÜ0]g
(file.data;close ) =fmclose[‚ãÜ0]g
Weneedtheuniquenessmutextoexpressthattherecanbenocon-
current opens and the time-regions to express that open and close
maynothappenconcurrently. Notethatnosuchguaranteesareex-
tendedtotheglobalvariable g,sowehave (g;‚ä§) =‚àÖ,meaning
thattheaccesscanhappeninanytimeperiod.
Example 6. Letusnowconsiderdynamicallyallocatedstructures.
Wecanextendper-elementlockingjustaseasilytoallocation-site
abstraction,butwenowneedtoconsiderlocksthatprotectanentire
datastructure,suchasalinkedlist. Asouralgorithmisparametric
onhowthesemay-aliasequivalenceclassesareobtained,wedonot
needtocareifwearedealingwithmay-points-tosetsortheresult
of a more sophisticated heap analysis. We do, however, need the
heapanalysistoexportarrayindexexpressions.
Consider now a synchronized hash table (Figure 3). When the
pointertstartstotraverseacertainbucket,ourpointeranalysismay
beabletosaythatthisbelongstotheregiondescribedby slots[i].
lock (&mtxs[i]);
t = slots[i] !next;
while (t != null) {
t!data++;
t = t !next;
}
unlock (&mtxs[i]);
Wemaythennotethatthe iusedwhentfirstenteredthememory
region slots[i]is equal to the index used when acquiring the lock
locks [i]. Ifaregionanalysiscandeterminewhenthesebucketsare
disjoint, we can essentially reduce this case to the previous exam-
ple:
(R(slots[‚ä§]);ln.data) =fmtxs[‚ãÜ0]g
To incorporate this analysis into our framework, the analysis pro-
videsthesymbolicindexexpressionoftheregionthatapointerbe-
longsto. Whenweaccess t!data,theregionanalysisknowsthat
t2R(slots[i])andtheindexexpression imustbemadeavailable
toourframework,sowecanmakesureitcorrespondstotheindex
usedwhenacquiringalock.
Example 7. Thefollowingexample,althoughcontrived,willclar-
ifytheintuitionbehindourapproach. Assumethatthedatafieldof
ourstructisitselfanarrayandwenowhaveamatrixoflocks:
396lock (&mtxs[i][0]);
t = slots[i] !next;
lock (&mtxs[i][j+1]);
t!data[j]++;
unlock (&mtxs[i][j+1]);
unlock (&mtxs[i][0]);
Thefirstlockofeachrowisreservedfortheslots,sotherestofthe
locksareoffsetbyone. Itisworthseeinghowthisisexpressedin
ourlocksets:
(R(slots[‚ä§]); ln.next) =fmtxs[‚ãÜ0][0]g
(R(slots[‚ä§]); ln.data[‚ä§]) =fmtxs[‚ãÜ0][‚ãÜ1+ 1]g
When we access t!data[j], we are given the list of index expres-
sions [i;j], which we use to check against the expressions used
when acquiring the locks. Our framework does not know that i
is part of the region and jis the offset of the access, but relies on
whatever combination of may-alias analyses we use to be consis-
tent(inawaymadepreciseinthenextsection)wheneveraskedfor
thelistofindexexpressions.
Example 8. Finally,weconsiderourintroductoryexamplefrom
Figure1,wherewehavearegionofmemorythatprotectsthelock
field embedded into elements whose data fields are protected by
theirownmutexes.
struct node { int data; int mtx;
struct list_head list; }
Assumewehaveaglobalmutex list_lockandagloballistof
nodes ndlist. We may be iterating through ndlist, attempt-
ingtofindthelastnodehavingagivenvalue:
struct node *find( int id){
struct list_head *lp = ndlist.next;
struct node *np, *res;
lock (&list_lock);
while (lp != &ndlist) {
np = container_of(lp, list);
lock (&np !mtx);
if(np!data == id) res = np;
unlock (&np !mtx);
lp = lp !next
}
unlock (&list_lock);
return res;
}
In this case, we will have the following common locksets while
executingthefindfunction:
(R(ndlist ); lh.next) =flist_lockg
(R(ndlist ); node.data) flist_lock;‚ãÜ.mtxg
The above function returns the found node, which the user may
accesswithoutthelistlock,restrictingthelocksetfurther:
(R(ndlist ); node.data) =f‚ãÜ.mtxg
The access to the list fields, however, is not influenced by this ac-
cessbecauseboththefieldandthetypeforthataccessaredifferent.
Forthisexample,wedidnotactuallyusetheregioninformation,
butthemomentwehaveanotherlistusingthekernelAPIlisttype
lh, we would be accessing the same fields for all lists in the pro-
gram. Ifwewanttoverifycaseswheredifferentlistsareprotected
bydifferentlocks,weneedthiscombinationofregionanalysiswith
field-sensitivityandtypeinformation.5. SYMBOLIC AND RELATIVE LOCKS
We now formalize the ideas from the previous section. The set
G, a product of individual partitioning domains, serves as a more
generalnotionofglobals. Ourfundamentalassumptionisthatthe
heapanalysesaresuchthatwheneverwehavesomeabstraction  
ofaconcreteheap œÜ,wecanconceptuallymapaconcretememory
locationltoauniqueownerandalistofindexvalues own(œÜ; )l2
GN. While we use these indices to analyze races, our value
analysisisnotsensitivetoindices;i.e.,wecomputeasingleabstract
valuethatmustover-approximatetheentireregion.
The critical change to our lockset analysis is rather the sets we
trackforeachprogrampoint: wenowtrack symbolic locks Ms: an
expression of the form lock(adr)will thus add the expression adr
to the symbolic lockset. For an unlock of adr‚Ä≤, we must remove
alllocksthatmaypossiblyaliaswith adr‚Ä≤. Thesyntaxforaddress
expressionsweconsiderisasfollows:
adr ::=&Ajpjadr.fjadr.[e]
wherefisafieldselectorand eisanindexexpression. InCsyntax,
theleft-associativeinfixoperator‚Äú .‚Äùisdefinedby:
adr.f=&adr!f adr.[i] =&(*adr)[e]
Notethattheprefixaddress-ofoperatorhasalowerprioritythanthe
postfix operators. The above expressions are thus purely address
computationswhereweapplyoffsetstoabasepointer; nopointer
isdereferencedduringevaluation.
Example 9. The following is the C translation of two example
addressexpressions:
(&A).f.[e].g &A.f[e].g
p.f.[e].g &p!f[e].g
In the case of actual dereferences our front end introduces tempo-
raryvariables;forexample,theexpression lock (&p!f!mtx)
istranslatedintothestatements t = p !f;lock (&t!mtx).
Oursymboliclocksetanalysisadds t.mtxtothelocksetandrelies
on our must-equality analysis [40] to track the equality t_=p!f.
Wecanthenusethatequalitytoassociateanaccess p!f!data
withthesymboliclock t.mtx;however,wedonotadd p!f!mtx
tooursymboliclocksetbecausethisaddresshasnotaconstantoff-
settoitsbasepointer p.
Recallthatthekeymappinginourracedetectionalgorithmwas
:G!2M, which maps a shared variable to the set of locks
always held while accessing that shared variable. The notion of a
shared variable is now expanded to these owners in G. We will
againmapeachownertoasetoflocks, butoursymboliclocksets
mayrefertolocalvariables. Fortheglobalmappingofalwaysheld
locks, we interpret the locks relative to its owner. A relative lock
is an address expression just like our symbolic locks, except the
base pointer may be either a global variable or a designated host
variable:
adr ::=&Aj‚ãÜjadr.fjadr.[e‚ãÜ]
Similarly,integerexpressions e‚ãÜmaynotrefertolocalintegervari-
ablesbutinsteadusespecialvariables ‚ãÜ0;‚ãÜ1;:::whenlockexpres-
sionsandaccessexpressionshavematchingindices,suchasinEx-
ample3.
In order to apply the privatization-based race detection frame-
workfrominSection3,weneedafunction relthattranslatessym-
boliclocksetstorelativelocksets,usingpointerandintegerequality
397information. Assuming the soundness of this translation, the spe-
cial constants are treated as uninterpreted symbols and do not dif-
ferfromconcretenames. Althoughthestructureofsharedowners
x2Gisopaquetous,wewillrequiretheaccessfunctionprovided
bythedomain JsKrwtonowreturnatupleoftheform (x;es),which
containsadditionallythelistofrelevantexpressions.
Wenowdiscussthemodificationstotheauxiliaryfunctionsused
toconstrain . Atthetimeofanaccess,wehavesymboliclocksets
thatcontainreferencestothecurrentstateoflocalvariables. These
valuesdonotmakesenseglobally,sothefunctiongivingustheset
ofcommonlyheldlocksmustperformatranslation. Wewillagain
presentdefinitionstop-down,usingoperationsthatwillbedefined
aftertheiruse. Wefirstgivetheredefinedthemutexmapfunction
foraccessedvariables:
mfs: (D2Ms)!G!2Mr
mfs( ;)x={
rel( ;es;)if(x;es)2JsK‚ôØ
rw 
? otherwise
TheonlydifferencefromSection3istheuseofthetranslationfunc-
tionrelthatperformsthetranslationfromsymbolictorelativelock-
sets:
rel: (DE2Ms)!2Mr
rel( ;es;M) =fm‚Ä≤2Mrj 9m2M: [es;‚Éó‚ãÜ] m=m‚Ä≤g
The semantic substitution operator [x;r] ereplaces every subex-
pressione‚Ä≤inewithrwhenever j=e‚Ä≤_=x. Justaswithsyntactic
substitutions,wecanliftthisdefinitiontoapairoflistsbycompos-
ing the individual substitutions corresponding to each element of
thezippedlist:
[[a1;:::;an];[x1;:::;xn]] = [an;xn] ‚ó¶    ‚ó¶ [a1;x1] 
Intuitively, we apply the semantic substitution to each element of
therelativelocksandkeeponlythosewhereallreferencestolocal
variableshavebeensubstituted. Notethatthisissoundaslongas
ourequalityanalysisissound,butwemayfailtoestablishanequal-
ity,inwhichcaseouranalysiswillflagthisaccessasunprotected.
Thesynchronizationfunctionwillalsohavetoconvertsymbolic
locksetstorelativeonesinordertochecktheintersectionwiththe
setoflocksthatarealwaysheldwhenaccessingthatsharedregion:
syncs(;; ; ‚Ä≤)g=
{
 ‚Ä≤xif(x;es)2JsK‚ôØ
rw andgÃ∏2prot(rel( i;es;))
?otherwise
Withthesemodificationsinplace,theconstraintsystemremainsex-
actlythesameasbefore. Wewillnowgivesomeintuitionaboutthe
semantics of privatization in the context of relative locksets. This
isbestappreciatedbyconsideringanexampleofper-elementpriva-
tization.
Example 10. We will again use a simplistic integer example of
aninvariantbeingtemporarilyviolatedwithinacriticalsection.
for (i = 0; i++; i < 100) {
lock (&mtxs[i]);
data[i]++; // invariant violated
data[i]--; // invariant restored
unlock (&mtxs[i]);
}
Assume five different threads execute this code. Then, at a given
moment,eachthreadmighthaveprivatizedaspecificindexofthearray. Wenowdescribethemeaningofouranalysisresultsforsuch
programs.
In order to relate the invariant-based semantics using symbolic
locksets with the concrete model, our concretization must now be
abletohandlesymboliclocksets. First,symboliclocksetsmustbe
subsumedby the concrete lockset after being evaluated in the cor-
responding concrete state, i.e., 8i2 I :JuiKii. If we
look back at the definition in Section 3, we must now rewrite the
concretizationconditionstoallowarbitrarylocationsinsteadofthe
fixednames. Mainly,weneedtoadapt prot()tothisnewsetting.
Ourmemoryabstractionsaresuchthatconceptuallyeachconcrete
memorylocationcorrespondstoapair (x;is)2GN. Wemust
determinewhetherthesespecificindices isofregionxareprotected
intheconcretestate bythesymboliclocks . Forthis,wecheck
whether the indices match a symbolic lockset if variables are re-
placedwiththeirconcretevaluesfrom . Wecanoverloadthefunc-
tion relforthis,keepinginmindthatwearenowrelativizinglocks
inaconcretesettingtogivemeaningtoouranalysisresults. Wethus
determinewhetheralocationisprotectedusing prot(rel(;is;)).
Thisiseffectivelytheonlychangeneeded: recallthatwecompute
asingleinvariantforeachregionandonlyallowindicestobepri-
vatizedwithincriticalsections.
Theorem3 (HeapSoundness). Given a heap abstraction that
relates memory locations l2 L to indexed regions, we have D
(S)also for heap-manipulating programs.
Proofidea. Themainthreattosoundness,comparedtothesim-
ple case, is to ensure that distinct locks mtx[3]andmtx[7]are not
relativized into the same relative lock mtx[‚ãÜ1]when accessing the
same location. Assume we have two accesses to the same region
with index expressions es1andes2in states1and2, holding
symbolic locks m1andm2that were relativized to the same lock.
If the index expressions coincide, we have Jes1K1=Jes2K2.
Thisequality,togetherwiththefactthatrelativemutexeshavehad
all their variables successfully substituted, allows us to make the
criticalinference:
[es1;‚Éó‚ãÜ]1m1= [es2;‚Éó‚ãÜ]2m2=) Jm1K1=Jm2K2
That is, relative locks coincide when accessing the same location
only if the corresponding concrete locks coincide. This is essen-
tially the only additional idea in our proofs of soundness and race
freedom.
6. EXPERIMENTAL EVALUATION
Ourbenchmarksuiteconsistsof26devicedrivers‚Äîallcharac-
terdevicedriversofthe4.0versionoftheLinuxkernelthatCIL[33],
the front-end library for Goblint, can digest. The size of the pro-
grams in the suite range from 96 to 3184 lines of Physical Source
LinesofCode(SLOC)generatedusingDavidA.Wheeler‚Äôs‚ÄòSLOC-
Count‚Äô. The performed analysis integrates value, points-to, (sym-
bolic) lockset, region, thread (uniqueness), and symbolic equality
analyses‚Äîasdescribedintheprevioussection. Additionally,the
analysiswasconfiguredtobepath-andcontext-sensitive[2,45]to
increaseprecision.
Ahigh-leveloverviewoftheanalysisresultsisshowninTable3.
Foreachanalyzeddriverwenotetheanalysistime,numberofmem-
ory locations found safe, and two categories of potentially unsafe
locations. Tendriverswereanalyzedinunderonesecondeach,13
driverswereanalyzedinbetweenoneandtensecondseach,andthe
threeremainingdriversrequiredtentoabout75secondseach. Our
statisticsisbasedonmemorylocations, ratherthanaccesssitesor
pairsofaccesses,whichmayseemmorenaturalmeasures. Thisis
398Table 3: Overview of analysis results for each driver
Race
Driver Time Safe Indirect Direct
hangcheck-timer.c 0.5s 6120
mem.c 0.8s 28 05
dtlk.c 3.1s 12 29 19
efirtc.c 0.8s 106 00
genrtc.c 0.9s 107 02
lp.c 1.1s 21 845
toshiba.c 1.1s 111 00
nvram.c 0.8s 111 01
misc.c 0.5s 120 6 10
applicom.c 2.3s 134 148
ipmi_poweroff.c 1.1s 6 142 11
random.c 73.6s 97 65 31
rtc.c 1.0s 170 204
scx200_gpio.c 0.4s 5 188 1
ttyprintk.c 0.6s 2 193 3
apm-emulation.c 1.2s 178 29 12
ppdev.c 1.3s 119 129 14
raw.c 0.9s 18 264 3
pc8736x_gpio.c 1.0s 112 195 2
ipmi_watchdog.c 12.9s 63 245 13
hpet.c 2.9s 59 292 22
tlclk.c 0.9s 299 886
ipmi_devintf.c 3.4s 247 196 8
ipmi_msghandler.c 26.0s 0 460 98
bsr.c 1.0s 592 19 10
sonypi.c 8.7s 276 350 27
because our analysis framework tracks abstract values associated
with each abstract memory location, so even a single unprotected
accessmeansthatwemaynotprivatizethatregionofmemory. We
therefore count the location as unprotected, although all other ac-
cessestothatabstractlocationmaybeproperlysynchronized. The
abstract description of a memory location depends on the precise
analysesuse. Wethereforereportracesusingastandardallocation
site abstraction of the heap. Although the analyzer may use finer
heap abstractions to distinguish accesses to different objects allo-
catedatthesamesite,theseareallgroupedforourstatisticstomake
theresultscomparablewhenenablingdifferentheapanalyses.
Apotentialraceisconsidered directifitisseenasunsafebased
on direct accesses, i.e., when a location is accessed directly by an
expressioninthesourcecode,e.g.,byanassignmenttothelocation.
Anindirectrace,ontheotherhand,isreportedwhensafetycannot
beguaranteedwhenweadditionallyconsiderindirectaccesses. An
indirectaccesscanhappenifapointertothelocationispotentially
passedtoan externfunction‚Äîafunctionforwhichtheanalyzer
doesnothavethesourcecode.
One source of indirect accesses comes from the use of various
containerdatastructures, where, forexample, theAPIcallthatin-
serts an object into the container may theoretically access all ob-
jects in the container. Another example of indirect accesses is the
private_data field in the filestructure of Linux. In that
use-case, pointers to the driver‚Äôs private data are inserted into the
structureandpassedaroundwithit. Thatmeansthatdataracefree-
domisguaranteedonlybyconvention.
Directracesreportedhereareeitherrealdataracesorfalsepos-
itivesthatgenerallyariseduetotheuseofunsupportedprotection
mechanisms,additionalassumptionsontheenvironment,orsimply0200400600
Drivers(sameorderasTable3)Nr. ofracesdirectrace
indirectrace
safe
Figure 4: Distribution of direct and indirect races
analysisprecisionloss. Proportionsofsafelocationsversusdirect
and indirect races can be seen in Fig. 4. On average 5% of loca-
tionsarereportedasdirectraces‚Äîwecountthisasasuccess. The
number would even drop to 3.3% if the outliers random.c and
ipmi_msghandler.c were removed. These two differ from
restofthedriversinthebenchmarksuitineithertheirassumptions
orcodecomplexity. Thefirst, random.c ,doesnotexposemost
of its non-static functions outside the Linux kernel. Instead, most
ofthefunctionsareusedwithinthekernelcodetogenerateentropy.
ItseemsthatinthemajorityofthelocationswhereGoblintdetects
a data-race, the responsibility for thread safety is left to the caller.
Asthecomputationofentropyisapproximateandsecurityonlyre-
quires lower bounds on this value, it is likely that such races are
benign and at worst only fail to count added entropy. Increasing
precision, in this case, would require more domain-specific infor-
mationabouttheenvironmentinwhichthefunctionsareused.
Themodule ipmi_msghandler.c hasahighercomplexity
thanmostothercharacterdevicedrivers. Itusesadvancedpatterns
thatGoblintdoesnotyetsupport,e.g.,Read-Copy-Update,atomic
readandupdateoperations,andper-elementlockingwherethelock
hasanon-constantoffsettoitsbasepointer. Lockingpatternsthat
Goblintcanfollowarenotadheredtoin‚Äúunregister‚Äù,‚Äúpanic‚Äù,and
‚Äúinitialization‚Äùmodes,whererunninginitializationseveraltimesis
avoided by a boolean flag whose safety is unclear. In addition to
that, the usage of variables suggests that some of its input are as-
sumedtobenotsharedandshouldnotbeaccessedatthesametime.
Effective analysis of this driver requires more effort to handle the
advancedpatternsandintegrationofinformationabouttheenviron-
mentitisusedin.
Thenumberofindirectracesisonaveragemuchlargerthanthe
numberofdirectraces. Infact,onaverage47%outofalllocations
areruledindirectraces. Fourteenofthe26drivershadasignificant
portionofthememorylocationsescaped. Theseissueswecountas
a failure of our tool in its current form, but not necessarily failure
oftheapproach,asthesafetyofAPIfunctionsisnotautomatically
derivable. Onesolutionwouldbemanualannotations.
Next, we evaluate the benefit that adding advanced features to
Goblinthasbrought. Table4showsdataforallmodulesthatwere
affectedbyswitchingthespecificfeaturesonandoff. Outofthe26
drivers,19useonlystaticlocksandsevenadditionallyusesomerel-
ativelockingpattern. Theadditionofsymboliclockingisabletode-
creasethenumberofreportedracesinonly ipmi_msghandler.c .
But additionally there are several near misses. In lp.c, the ex-
ported function lp_release does not acquire the relative lock
399Table 4: Contributions of features
Directracecountforfeatureset
Driver Base +Region +Symb. +Both
apm-emulation.c 15 1215 12
hpet.c 26 2226 22
ipmi_devintf.c 10 8108
ipmi_msghandler.c 140 114 127 89
ppdev.c 20 1420 14
random.c 38 3733 31
lp_table[minor].port_mutex ,contrarytothepatternes-
tablishedbyotherfunctions‚Äîthiswouldmakethreememoryloca-
tionswithdirectracessafe. Relativelocking,weconclude,isused
in complicated drivers and needs to be supported, but its analysis
practicallyrequirestakingenvironmentalassumptionsintoaccount.
A slightly better situation is with dynamic lists ‚Äî six drivers use
dynamic lists and five of them get fewer warnings when enabling
regionanalysis. Butalsotheretheresultscouldbebetterifmoreen-
vironmentalassumptionscouldbediscoveredandusedintheanal-
ysis.
Weconcludethatflexible,genericcombinationofexistinganal-
yses can be decently successful for analyzing data races in open
programs. Toreachthislevel,weneededtopaycloseattentionto
precisionwhenimplementingsupportforpopularlockingpatterns.
Atthispoint,however,thelimitingfactoristheenvironmentofthe
module. Adding more and more specific features will have a mi-
nor effect if safety hinges on the convention of use of the module.
A similar observation was made by Logozzo et al. [27], who sug-
gestinferringassumptionsaspreconditionsandanalyzesubsequent
versionsofthesoftwareunderthoseassumptions. Wewouldneed
assumptionsaboutwhethercertainthreadsmayruninparallel.
7. RELATED WORK
Wewillfocushereonautomatedstaticapproachestoracedetec-
tion. TheAstre√©analyzer[11]hasinrecentyearsbeenextendedto
analyzeconcurrentprograms[31]. Theconcurrencyabstractionis
basedonthreadspropagating influences tootherthreads[29];effec-
tively,thiscomputesaflow-insensitiveinvariantfortheglobalstate
very similar to our privatization framework and is proven sound
withrespecttothereorderingofcommandsthatareallowedinweak
memorymodels. Min√©[30]furtherextendstheframeworktotake
relationalinvariantsintoaccount. Wedidnotpropagaterelational
invariantsinthispaper,butthesearestraightforwardinoursetting
withanexplicitglobalinvariant. Astre√©ensurestheabsenceofall
runtime errors and also detects race conditions, but it is not clear
howtheydealwithdynamicallyallocatedlocks;intheirformalex-
positions,afinitesetoflocksisassumed.
Whoop[13]isarecentracedetectiontoolthatcombinesracede-
tection with a precise bug detector to eliminate false alarms. The
static race detector works by instrumenting the program such that
symbolic execution can generate the proof obligations needed to
verify race freedom. It does not consider dynamically allocated
locks. Otherracedetectors,includingLocksmith[34],CoBE[24],
and Relay [46], focus only on aliasing analyses, ignoring abstrac-
tion of integer variables. We share some similarity with these ap-
proaches. The composition of may-alias analysis is exploited in
CoBE to speed up pointer alias analyses by running them in a se-
quencefrommorecoarse-grainedtomorefine-grainedKahlon[22].
Relay uses symbolic locksets for procedure summarization. They
also use the term ‚Äúrelative locksets‚Äù to summarize the effect of afunction on the set of definitely held locks; that is not related our
useoftheterm.
Compared to state-of-the-art race detection tools for C, our ap-
proach has the following advantages. We can handle both value-
dependentsynchronizationpatternsandconsiderdynamicallyallo-
cated locks. In particular, we handle per-element locking without
theneedforprogrammerannotations. TheLocksmithanalyzeruses
existentialtypesforthis,butreliesonprogrammerannotations[35].
We can also handle medium-grained locking, such as a linked list
being protected by a list lock. This feature is unique to Goblint
among all race detection tools we have tested, including commer-
cial tools. Last, but certainly not least, we can analyze locking
schemesinvolvingarraysoflocks,asmayoccurinasynchronized
hashtable. ForJava,NaikandAiken[32]propose conditional must-
not aliasing todealwithlockingschemesofvariouslevelsofgran-
ularity.
The analysis of heap-manipulating multi-threaded programs is
anactivefieldofresearchinitsownright. Mostconcurrentshape
analyses algorithms, e.g. [4, 9, 28, 44], focus primarily on prov-
ingpropertiessuchasmemorysafety,datastructureinvariants,and
linearizability for small but complex concurrent implementations
of data structures. The basic idea of our approach resembles the
thread-modular shape analysis of Gotsman et al. [17]. That analy-
sis, however, relies on a-priori race-detection and lock set compu-
tation to enable sequential shape analysis of concurrent programs.
In contrast, we jointly analyze values and establish race freedom.
More lightweight pointer analyses have also been developed that
alsocombinewithintegervalues[5,10,16,18,36].
Forstaticdevicedriververification,themethodofchoiceseems
tobesoftwaremodelcheckers,whereSLAM[6]hasmadeitsway
into the Windows Driver Framework, and for Linux, the Linux
DriverVerification(LDV)projecthaveextendedtheBLASTmodel
checker[7]withpointeranalysestoanalyzedevicedrivercode[42].
Fromourperspective,themostrelevantworkaremethodsformodel
checkingconcurrentprograms[20,21,43],butthefocussofarhas
notbeenondetectingraceconditionsandsequentialconsistencyis
assumed. TheLDVprojectreportsondevelopingaracedetection
tool on top of the CPAChecker framework [8]. This is an extensi-
ble framework that combines model checking and static analysis,
featuring automatic abstract domain selection [1]. Ideas from this
paper could be integrated into that framework, allowing more ex-
pensiveanalysestobeonlyusedforcomplicatedidioms.
8. CONCLUSION
We have presented the analysis framework Goblint. The con-
cept of global invariants refined by a notion of privatization en-
ablesustorealizereasonablypreciseyetscalableanalyzersofmulti-
threaded C programs. We applied this approach to realize precise
and efficient data race analyzers. On top of a generalization of
locksetanalysis,dedicatedanalysesareprovidedwhichcoverspe-
cificprogrammingidiomssuchasvalue-dependentlockingorper-
elementlocking. Wearguethat,duetotheflexibilityofthegeneral
framework,additionalanalysescaneasilybeprovidedtocatchfur-
therlockingpatterns;however,inferringenvironmentalconstraints
maynowbethemostpromisingwayforward.
9. ACKNOWLEDGEMENTS
ThisworkwassupportedbyinstitutionalresearchgrantIUT2-1
fromtheEstonianResearchCouncilandITEA3ProjectASSUME
(‚ÄúAffordableSafe&SecureMobilityEvolution‚Äù). Wearegrateful
totheanonymousreviewersformanysuggestedimprovementsand
someveryhardquestions.
40010. REFERENCES
[1]S. Apel, D. Beyer, K. Friedberger, F. Raimondi, and A. v.
Rhein. DomainTypes: Abstract-DomainSelectionBasedon
VariableUsage. In Hardware and Software: Verification and
Testing,pages262‚Äì278.LNCS8244,Springer,2013.
[2]K. Apinis. Frameworks for analyzing multi-threaded C .
PhD thesis, Institut f√ºr Informatik, Technische Universit√§t
M√ºnchen,June2014.
[3]K.Apinis,H.Seidl,andV.Vojdani.Side-EffectingConstraint
Systems: A Swiss Army Knife for Program Analysis. In
APLAS‚Äô12,pages157‚Äì172.LNCS7705,Springer,2012.
[4]H. Attiya, G. Ramalingam, and N. Rinetzky. Sequential ver-
ification of serializability. In POPL‚Äô10, pages 31‚Äì42. ACM
Press,2010.
[5]G. Balakrishnan and T. Reps. Recency-abstraction for heap-
allocated storage. In SAS‚Äô06, volume 4134 of LNCS, pages
221‚Äì239.Springer,2006.
[6]T.BallandS.K.Rajamani. TheSLAMProject: Debugging
SystemSoftwareviaStaticAnalysis. In POPL‚Äô02,pages1‚Äì3.
ACMPress,2002.
[7]D. Beyer, T. A. Henzinger, R. Jhala, and R. Majumdar. The
softwaremodelcheckerBlast. International Journal on Soft-
ware Tools for Technology Transfer ,9(5-6):505‚Äì525,2007.
[8]D.Beyer,T.A.Henzinger,andG.Theoduloz. ProgramAnal-
ysis with Dynamic Precision Adjustment. In ASE‚Äô08, pages
29‚Äì38,2008. .
[9]C. Calcagno, D. Distefano, and V. Vafeiadis. Bi-abductive
resource invariant synthesis. In APLAS‚Äô09, volume 5904 of
LNCS,pages259‚Äì274.Springer,2009.
[10]B.-Y.E.ChangandX.Rival. Relationalinductiveshapeanal-
ysis. In POPL‚Äô08,pages247‚Äì260.ACMPress,2008.
[11]P. Cousot, R. Cousot, J. Feret, L. Mauborgne, A. Min√©,
D. Monniaux, and X. Rival. The ASTR√âE analyzer. In
ESOP‚Äô05,LNCS3444,pages21‚Äì30.Springer,2005.
[12]M. Das, S. Lerner, and M. Seigle. ESP: path-sensitive pro-
gramverificationinpolynomialtime. In PLDI‚Äô02,pages57‚Äì
68.ACMPress,2002.
[13]P.Deligiannis,A.F.Donaldson,andZ.Rakamariƒá. Fastand
Precise Symbolic Analysis of Concurrency Bugs in Device
Drivers. In ASE‚Äô15, pages 166‚Äì177, Washington, DC, USA,
2015.IEEEComputerSociety.
[14]D.EnglerandK.Ashcraft. RacerX:effective,staticdetection
ofraceconditionsanddeadlocks.In SOSP‚Äô03,pages237‚Äì252.
ACMPress,2003.
[15]K. Gharachorloo, D. Lenoski, J. Laudon, P. Gibbons,
A. Gupta, and J. Hennessy. Memory Consistency and Event
Ordering in Scalable Shared-memory Multiprocessors. In
ISCA‚Äô90,pages15‚Äì26.ACM,1990.
[16]D.Gopan,T.Reps,andM.Sagiv. Aframeworkfornumeric
analysis of array operations. In POPL‚Äô05, pages 338‚Äì350.
ACMPress,2005.[17]A. Gotsman, J. Berdine, B. Cook, and M. Sagiv. Thread-
modular shape analysis. In PLDI‚Äô07, pages 266‚Äì277. ACM
Press,2007.
[18]S.Gulwani,T.Lev-Ami,andM.Sagiv.Acombinationframe-
workfortrackingpartitionsizes.In POPL‚Äô09,pages239‚Äì251.
ACMPress,2009.
[19]B.HackettandR.Rugina. Region-basedshapeanalysiswith
tracked locations. In POPL‚Äô05, pages 310‚Äì323. ACM Press,
2005.
[20]T.A.Henzinger,R.Jhala,andR.Majumdar. RaceChecking
byContextInference. In POPL‚Äô04,pages1‚Äì13.ACMPress,
2004.
[21]O.Inverso,T.L.Nguyen,B.Fischer,S.L.Torre,andG.Par-
lato. Lazy-CSeq: AContext-BoundedModelCheckingTool
for Multi-threaded C-Programs. In ASE‚Äô15, pages 807‚Äì812,
2015.
[22]V.Kahlon. Bootstrapping: atechniqueforscalableflowand
context-sensitive pointer alias analysis. In PLDI‚Äô08, pages
249‚Äì259.ACMPress,2008.
[23]V. Kahlon, Y. Yang, S. Sankaranarayanan, and A. Gupta.
Fastandaccuratestaticdata-racedetectionforconcurrentpro-
grams. In CAV‚Äô07, volume 4590 of LNCS, pages 226‚Äì239.
Springer,2007.
[24]V.Kahlon,N.Sinha,E.Kruus,andY.Zhang. Staticdatarace
detectionforconcurrentprogramswithasynchronouscalls.In
ESEC/FSE‚Äô09 ,pages13‚Äì22.ACMPress,2009.
[25]J. Kreiker, H. Seidl, and V. Vojdani. Shape analysis of low-
level C with overlapping structures. In VMCAI‚Äô10 , volume
5944of LNCS,pages214‚Äì230.Springer,2010.
[26]O.Lee, H.Yang, andR.Petersen. Adivide-and-conquerap-
proach for analysing overlaid data structures. Formal Meth-
ods in System Design , 41(1):4‚Äì24, Apr. 2012. ISSN 0925-
9856,1572-8102.
[27]F. Logozzo, S. K. Lahiri, M. F√§hndrich, and S. Blackshear.
Verificationmoduloversions: Towardsusableverification.In
PLDI ‚Äô14,pages294‚Äì304.ACMPress,2014.
[28]R. Manevich, T. Lev-Ami, M. Sagiv, G. Ramalingam, and
J. Berdine. Heap decomposition for concurrent shape analy-
sis. In SAS‚Äô08,volume5079of LNCS,pages363‚Äì377,2008.
[29]A. Min√©. Static analysis of run-time errors in embedded
critical parallel C programs. In ESOP‚Äô11, pages 398‚Äì418.
Springer,2011.
[30]A. Min√©. Relational thread-modular static value analysis by
abstractinterpretation. In VMCAI‚Äô14 ,volume8318of LNCS,
pages39‚Äì58.Springer,2014.
[31]A.Min√©,L.Mauborgne,X.Rival,J.Feret,P.Cousot,D.K√§st-
ner,S.Wilhelm,andC.Ferdinand. TakingStaticAnalysisto
theNextLevel: ProvingtheAbsenceofRun-TimeErrorsand
DataRaceswithAstr√©e. In ERTS‚Äô16,2016.
[32]M.NaikandA.Aiken.Conditionalmustnotaliasingforstatic
race detection. In POPL‚Äô07, pages 327‚Äì338. ACM Press,
2007.
401[33]G. C. Necula, S. McPeak, S. P. Rahul, and W. Weimer. Cil:
An infrastructure for C program analysis and transformation.
InCC‚Äô02, volume 2304 of LNCS, pages 213‚Äì228. Springer,
2002.
[34]P.Pratikakis,J.S.Foster,andM.Hicks. Locksmith: Context-
sensitivecorrelationanalysisfordetectingraces. In PLDI‚Äô06,
pages320‚Äì331.ACMPress,2006.
[35]P.Pratikakis,J.S.Foster,andM.Hicks.Existentiallabelflow
inference via CFL reachability. In SAS‚Äô06, volume 4134 of
LNCS,pages88‚Äì106.Springer,2006.
[36]R. Rugina and M. C. Rinard. Symbolic bounds analysis of
pointers, array indices, and accessed memory regions. ACM
Trans. Prog. Lang. Syst. ,27(2):185‚Äì235,2005.
[37]M.D.Schwarz,H.Seidl,V.Vojdani,andK.Apinis. Precise
analysisofvalue-dependentsynchronizationinprioritysched-
uledprograms. In VMCAI‚Äô14 , volume8318of LNCS,pages
21‚Äì38.Springer,2014.
[38]H. Seidl and V. Vojdani. Region analysis for race detection.
InSAS‚Äô09, volume 5673 of LNCS, pages 171‚Äì187. Springer,
2009.
[39]H.Seidl,V.Vene,andM.M√ºller-Olm. Globalinvariantsfor
analyzing multithreaded applications. Proc. of the Estonian
Academy of Sciences: Phys., Math. ,52(4):413‚Äì436,2003.
[40]H.Seidl,V.Vojdani,andV.Vene. Asmoothcombinationof
linearandHerbrandequalitiesforpolynomialtimemust-aliasanalysis. In FM‚Äô09, volume 5850 of LNCS, pages 644‚Äì659.
Springer,2009.
[41]M. Sharir and A. Pnueli. Twoapproaches to interprocedural
dataflowanalysis. InN.JonesandS.Muchnick,editors, Pro-
gram Flow Analysis: Theory and Applications , pages 189‚Äì
234.PrenticeHall,1981.
[42]P.E.Shved,V.S.Mutilin,andM.U.Mandrykin. Experience
of improving the blast static verification tool. Programming
and Computer Software ,38(3):134‚Äì142,May2012.
[43]E. Tomasco, O. Inverso, B. Fischer, S. L. Torre, and G. Par-
lato. VerifyingConcurrentProgramsbyMemoryUnwinding.
InTools and Algorithms for the Construction and Analysis of
Systems, pages 551‚Äì565. LNCSS 9035, Springer Berlin Hei-
delberg,2015.
[44]V.Vafeiadis. RGSepactioninference. In VMCAI‚Äô10 ,volume
5944of LNCS,pages345‚Äì361.Springer,2010.
[45]V.VojdaniandV.Vene.Goblint: Path-sensitivedataraceanal-
ysis. Annales Univ. Sci. Budapest., Sect. Comp. ,30:141‚Äì155,
2009.
[46]J.W.Voung,R.Jhala,andS.Lerner. RELAY:staticracede-
tectiononmillionsoflinesofcode. In ESEC/FSE‚Äô07 ,pages
205‚Äì214.ACMPress,2007.
402