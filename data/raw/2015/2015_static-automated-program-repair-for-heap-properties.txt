Static Automated Program Repair for Heap Properties
Rijnard van Tonder
School of Computer Science
Carnegie Mellon University
rvt@cs.cmu.eduClaire Le Goues
School of Computer Science
Carnegie Mellon University
clegoues@cs.cmu.edu
ABSTRACT
Static analysis tools have demonstrated effectiveness at finding
bugsinrealworldcode.Suchtoolsareincreasinglywidelyadopted
toimprovesoftwarequalityinpractice.AutomatedProgramRepair
(APR)hasthepotentialtofurthercutdownonthecostofimproving
software quality. However, there is a disconnect between these
effectivebug-findingtoolsandAPR.RecentadvancesinAPRrely
on test cases, making them inapplicable to newly discovered bugs
or bugs difficult to test for deterministically (like memory leaks).
Additionally,thequalityofpatchesgeneratedtosatisfyatestsuiteis
akeychallenge.Weaddressthesechallengesbyadaptingadvances
inpracticalstaticanalysisandverificationtechniquestoenablea
newtechniquethatfindsandthenaccuratelyfixesrealbugswithout
test cases. We present a newautomated program repair technique
using Separation Logic. At a high-level, our technique reasonsover semantic effects of existing program fragments to fix faults
relatedtogeneralpointersafetyproperties:resourceleaks,memoryleaks,andnulldereferences.Theprocedureautomaticallytranslates
identifiedfragmentsintosource-levelpatches,andverifiespatch
correctnesswithrespecttoreportedfaults.Inthisworkweconduct
the largest study of automatically fixing undiscovered bugs in real-
world code to date. We demonstrate our approach by correctly
fixing 55 bugs, including 11 previously undiscovered bugs, in 11
real-world projects.
CCS CONCEPTS
•Software and its engineering →Error handling and recov-
ery;Maintaining software; Software defect analysis;
KEYWORDS
Automated Program Repair, Separation Logic
ACM Reference Format:
RijnardvanTonderandClaireLeGoues.2018.StaticAutomatedProgramRe-
pair for Heap Properties. In ICSE ’18: ICSE ’18: 40th International Conference
onSoftwareEngineering,May27-June3,2018,Gothenburg,Sweden. ACM,
New York, NY, USA, 12 pages. https://doi.org/10.1145/3180155.3180250
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
©2018 Copyright held by the owner/author(s). Publication rights licensed to the
Association for Computing Machinery.
ACM ISBN 978-1-4503-5638-1/18/05...$15.00
https://doi.org/10.1145/3180155.31802501 INTRODUCTION
Software bugs are expensive and time-consuming [ 15,43], moti-
vating research to find and fix them automatically. Research in
automatedprogramrepair(APR)holdspromiseforreducingsoft-
ware maintenance costs due to buggy code. Considered broadly, a
programrepair issimplyatransformationthatimprovesaprogram
with respect to some abstract domain that describes correct versus
incorrect program behavior. The vast majority of modern repair
techniques(e.g.,[ 29,33,37,39,41,49])usetestcasestoconstruct
this domain. Tests are appealing because they are intuitive and
widely-usedinpractice(moresothan,e.g.,formalspecifications)
and can straightforwardly indicate whether a given change im-
provestheprograminquestion(i.e.,byturningapreviouslyfailing
test case into a passing one).
However,testsarelimitinginseveralways,especially(though
not exclusively) for APR. Writing good tests is nontrivial [ 43],
renderingsomereal-worldsuitesaweakproxyforpatchcorrect-
ness [51]. APR techniques and humans alike can overfit to even
high quality tests, producing patches that do not generalize to the
true desired functionality change [ 53]. Developers must write a
deterministic, reproducible test case corresponding to a bug under
repairtousetest-drivenAPR.Thisusecaseisparticularlyapplicable
to, e.g., regressions, but is limiting for previously-unknown defects.
Morefundamentally, testsare onlysuitable forfinding and guid-
ing the repair of certain kinds of bugs.Some bug types are simply
difficult to test for in a finite, deterministic way [ 40]. Consider con-
currencyerrorsorresourceormemoryleaks:Figure1ashowsan
example memory leak from Swoole1(line 11), which may be fixed
by adding a call to the project-specific resource allocation wrapper
sw_free(Figure 1b). Alternatively, consider the code in Figure 2a,
from error-prone .2The call to resolveMethod on line 3 can return
NULL, leading to a possible null pointer exception on line 6. A
developercommittedafix(withatest)thatinsertsacalltoacus-
tomerrorhandler( checkGuardedBy ,line5).However,the verysame
mistakehadbeenmadeonlines10–12,inthesame switchstatement,
butwasnotfixedforanother18months.Evenwhenbugsarede-
terministicallyreproducible,testsusuallycannotidentifyrecurring
mistakes like this.
FindingandfixingthesetypesofbugsmotivatetheuseofQA
techniques beyond testing. Considerable recent progress has been
made in expressive, high quality static analyses that can cost effec-
tively find real bugs like these examples in real programs [ 5,14].
Companies like Ebay [ 25], Microsoft [ 14], Facebook [ 17], and oth-
ers are publicizing their development and use of static analysis
1Swooleis a popular event-driven networking engine for PHP, https://github.com/
swoole/swoole-src
2error-prone is an open-source static analysis tool, https://github.com/google/
error-prone
1512018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:50:07 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Rijnard van Tonder and Claire Le Goues
1swHashMap * hmap =
2 sw_malloc( sizeof(swHashMap));
3if(!hmap) {
4 swWarn( "malloc[1] failed." );
5 return NULL;
6}
7swHashMap_node *root =
8 sw_malloc( sizeof(swHashMap_node));
9if(!root) {
10 swWarn( "malloc[2] failed." );
11 return NULL;// returns, hmap not freed
12}
(a)Memoryleak:forgettingtofreememorybeforereturnin Swoole.
1#define sw_free(ptr)
2if(ptr) {
3free(ptr);
4ptr=NULL;
5swWarn( "free");
6}
(b) sw_freewraps a call to free.
Figure 1: Fixing a memory leak in the Swooleproject
tools in engineering practice. Some bug-finding tools, like error-
proneorFindbugs[8]evenprovide“quickfix”suggestionsforcertain
bug classes, simplifying the process of repairing them. Developers
find such suggestions very useful [ 9], and indeed their absence has
beenidentifiedasabarriertouptakeandutilityofstaticanalysis
tools [27]. However, the suggestions present in current tools are
simple,generic,andusuallysyntactic(e.g.,recommendingtheaddi-
tionof staticorfinalmodifierstovariableorfunctiondeclarations).
Moreover, they provide no semantic correctness guarantees.
Weproposeanewtechniquethatautomaticallygeneratespatches
forbugsinlargeprojectswithoutaneedforeithertestsordevel-
operannotation,forasemanticallyrichclassofbugsthatcanbeidentified by recent, sophisticated static bug-finding techniquesbased onSeparation Logic [
10,11,13,21]. Our key insightlies in
thenovelwayweadapt localreasoning [44,46,62],“theworkhorse
of a number of automated reasoning tools” [ 45], to pull out rel-
evant parts of program state, and then search for repairing code
fromelsewhereinthesameprogram.Atahighlevel,ourtechnique
searches for and adapts program fragments satisfying a generic,
pre-specifiedsemanticeffectthataddressagivenbugclass(such
as “if the file is open in the precondition of a program fragment, it
shouldbeclosedinthepostcondition”toaddressresourceleaks,liketheoneshowninFigure1a).Thesefixeffectsaregeneric,andneed
onlybespecifiedonceperbugclass.Theyarealsolanguage-and
API-agnostic, which means our approach applies off-the-shelf to
multiplesourcelanguages,anditspatchesautomaticallyconformto
the programming conventions in a given project (e.g., constructing
apatchusingaproject-specificcustomresourcehandlerlike sw_free
for memory leaks, if available, or free, if not), without requiring
any additional customization.
We instantiateourapproach inatoolcalled FootPatch,an ex-
tension to the Infer [ 17]3static analysis tool. Infer finds bugs by
automatically inferring Separation Logic assertionsover program
3https://github.com/facebook/infer1caseIDENTIFIER: {
2MethodSymbol mtd =
3 resolver.resolveMethod(node , id.getName());
4// method may be null
5+ checkGuardedBy(mtd != null, id.toString());
6return bindSelect(computeBase(c ontext, mtd), mtd);
7}
8caseMEMBER_SELECT: {
9...
10MethodSymbol mtd =
11 resolver.resolveMethod(node , id.getName());
12// same problem!
13return bindSelect(computeBase(c ontext, mtd), mtd);
14}
(a) Developers fixed the potential null pointer exception on line 6;
18monthslater,theyaddressedtheverysimilarbugonlines12–13.
1public static void checkGuardedBy( boolean cnd,
2String fmtStr, Object... fmtArgs) {
3if(!cnd) {
4 throw new IllegalGuardedBy(S tring.format( fmtStr,
fmtArgs));
5}
6}
(b) error-prone’s custom guard handler.
Figure 2: Fixing a null dereference in Google’s error-prone tool.
statements.Infer reasonsovera semantic,analysis-orientedInter-
mediateLanguage(IL),andappliestolarge,real-worldprograms
written in multiple source languages. Separation Logic can be used
to encode a variety of desirable correctness properties [ 17,22]. We
situateourapproachbyextendinganalysesthatfindbugsrelated
totheviolationofpointersafetyproperties,thefocusofInfer.In
thispaper,werestrictourfocustoconstructingadditivepatchesfor
resource leaks, memory leaks, and null dereferences. We discuss
directions for generalizing our technique in Section 4.5.
Our approach provides several important benefits over previous
techniques for automatic patch generation or fix suggestion. By
integrating directly into the static analysis workflow, our approachaddressesdifferenttypesofbugsthanarehandledbymostdynamic
APRtechniques,andcanencouragetheadoptionoftheserobust
static bug finding tools in practice [ 27]. Because of the way our
approach uses compositional specifications, it can produce fixes
that are significantly semantically richer than existing static “quick
fix” suggestions. FootPatch can construct repairs that cross proce-
dure boundaries, entail multiline fixes, and are robust to program-
specificcustomizationlikewrapperAPIs.Thesebenefitsareevident
in the above examples, both of which FootPatch can repair au-
tomatically.Note,forexample,acallto checkGuardedBy doesnoton
its own constitute a repair, as it simply checks the results of a
boolean expression. FootPatch can determine that the function
implements the desired behavior because it searches over composi-tional function call results. Additionally, both bug fixes use custom
resource wrappers, which are often desirable as fixes because they
areconsistentwiththeconventioninotherpartsoftheprogram.
For example, sw_freewraps the freefunction, and performs addi-
tional, non-interfering operations by setting the pointer to null
152
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:50:07 UTC from IEEE Xplore.  Restrictions apply. Static Automated Program Repair for Heap Properties ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
andloggingadebugmessage.Finally,unlikepreviousrepairtech-
niques that build on more formal abstract domains [ 19,30,35,48],
our approach scales to real-world programs, automatically instan-
tiatesandappliesitspatches,andreliesonaprincipledsemantic
treatment to argue patch correctness and prevent patch overfitting.
Thatis:FootPatchdemonstratesapromisingandpreviouslyun-
derdeveloped application of end-to-end identification and repair of
previously undiscovered bugs in real programs.
Our contributions are the following:
•Program Repair with Separation Logic. We present a
repair technique using Separation Logic to ensure a desired
correctnesspropertybasedonpointersafety.Theabstract
domainprovidesabasisforreasoningaboutexplicitsemantic
effects introduced by patch fragments, and enables a formal
argument for semantic patch correctness.
•RepairExtractionandApplicationFormalism. Wefor-
malize the search and extraction of program fragments with
respect to a repair specification, and define the conditions
forpatchgenerationandautomaticpatchapplicationwith
respect to a detected bug.
•Evaluation. We present an evaluation on popular software
projects. Our approach fixes 24 resource leaks, 7 memory
leaks, and 24 null dereferences in popular Java and C pro-
grams,including11previouslyundiscoveredbugs.Weare
unaware of any prior repair tool that supports multiple lan-
guages under a single analysis. Our implementation runs onbig projects (
>200 kLOCs). Run time ranges from 7 seconds
to21minutesperproject,toperformbothfindingandfixing
bugswithintheproject.Forapplicableprojects,ourexper-
iments show that the majority of correct patches (53) are
found by searching for repair candidates that are callgraph-
local to the bug, and expanding repair search to the project
globally fixes 2 additional bugs. We observe a false positive
rate of only 5% for fixes. Moreover, we demonstrate anecdo-
talevidencethatourtechniquecanleadtheoriginalstatic
analysis to discover more bugs after performing repair.
•Open Source Repair Tool. We implement our technique
inatool calledFootPatch,builton topoftheopensource
Infer static analyzer.4
Section 2 provides background theory underpinning our ap-
proach. Section 3 details our repair approach using Separation
Logic.Section4evaluatesFootPatch,atoolthatimplementsour
approach. Section 5 discusses related work; Section 6 concludes.
2 PRELIMINARIES
We build our approach on top of the analysis engine used in In-
fer [16], an open source framework that uses Separation Logic and
Hoare-stylereasoning toscalablyfindbugs,particularlythose re-
latedtoheaporpointererrors.Thisanalysisabstractsaprogram
to an intermediate language, and then symbolically interprets it to
find paths that may lead to particular property violations (like null
pointerdereferences).Thissectionoutlinesbackgroundconcepts
underpinning our approach and the analysis it extends: the ab-
stract program model and SeparationLogic assertions (Section 2.1),
4https://github.com/squaresLab/footpatchE::=x|nil|c
B::=E=E|E/nequalE
S::=x:=E|x:=[E]|[E]:=E|x:=new()|dispose(E)
C::=S|C;C|if(B){C}else{C}|while(B)[I]{C}|x:=f(− →E)
P::=·|f(− →E){local−→E;C;return E};P
(a) A simplified Smallfoot grammar, for illustration.
H::=E/mapsto→E
Σ::=H1∗···∗ Hn|emp
Π::=B1∧···∧ Bn|true|false
P,Q::=Π∧Σ|ifBthen PelseP
(b) The assertion language grammar.
Figure 3
theframeinferenceprocedurefordiscoveringspecifications(Sec-
tion 2.2), and an overview of how theconcepts fit together to findbugs statically in real-world programs (Section 2.3).
2.1 Program Model and Assertion Language
Infer and our analysis both begin by abstracting a source program
in one of several languages (e.g., Java, C, C++) to the Smallfoot
IntermediateLanguage(SIL)[ 10].SILisanintermediateanalysis
language that represents source programs in a simpler instruction
set describing the program’s effect on symbolic heaps. This is par-
ticularlysuitableforstaticanalysesthatfindbugsrelatedtopointer
safety properties.
Program Model. Figure 3a shows a simplifed Smallfoot grammar
to illustrate the overall program model. A SIL program Pis a set of
procedures [ 11,12,18]. SIL procedures have single return values
and do not access global variables. Procedures consist of a series
ofcommands (C,inFigure3a),whichmodelactionsthatgenerate
assertionsoversymbolicheaps(describednext).Thestoragemodel
is fairly standard [ 18,47]:Heapis a partial function from locations
Loctovalues Val(forsimplicity,locationsarepositiveintegersand
valuesareintegers): Heapdef=Loc/arrowrighttophalfVal.Stackisafunctionfrom
variables to values Stackdef=(Var∪LVar)/arrowrighttophalfVal. Variables are
twodisjointsets:asetofprogramvariables Varandasetoflogical
variables LVar.Aprogram Stateissimplythecombinationofits
heap and stack: Statedef=Stack×Heap.
Assertions. SILcommandsprimarilycaptureeffectsoversymbolic
heaps,whichcomprisetheabstractdomainfordetectingfaulting
conditions (e.g., memory leaks, resource leaks, null dereferences).5
Theseeffectscanbedescribedviapre-andpostconditionsexpressed
inSeparationLogic,whichdecoratetheSILcommandsaccordingly.
Figure 3b shows the assertion language grammar. The grammar
encodesheapfactsusingpoints-toheappredicatesoverprogram
andlogicalvariables(i.e., E/mapsto→E).Heappredicatesareconsidered
“separate” sub-heaps (or heaplets), whose separation is denoted by
5Symbolicheapsenableadecidableproofsystemforentailmentsunderaprescribed
semantics [10]; we elide details for brevity.
153
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:50:07 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Rijnard van Tonder and Claire Le Goues
theseparatingconjunction ∗(read“andseparately”).Theseparat-
ingconjunctionimpliesthatthetwosub-heapsaredisjoint.Pure
booleanpredicatesoftheform B1∧···∧Bnassertconditionalfacts
over heap predicates (e.g., E=nil).
Givenourfocusonrepair,assertionsarerelevantinsofarasthey
describe semantic effects of statements (as predicates) on the heap.
We denote by E /Mapstochar⇒alloceda predicate allocedonE(e.g., we may
represent it in the grammar by the assertion E/mapsto→x∧trueforx
fresh). For simplicity, this notation may assume a program variable
evaluates to a heap location (such as hmap); we do this with the
understandingthatstoresandheapsaretypicallytreatedseparately
in the storage model [18].
2.2 Frame Inference
Akeynoveltyinourworkisthewayweextend frameinference [11]
to find bug repairs; we thus briefly overview frames and frame in-
ferenceinthiscontext.Infer’sSeparationLogic-basedanalysisuses
Hoare-stylereasoningtofindspecificationviolations.Itdoesthisatscalebysummarizingtheeffectsofindividualtermsinaprocedure,andthencomposingthemintoprocedure-levelspecifications. Local
reasoning [44,46] is used to summarize the effects of those individ-
ual terms. Local reasoning is enabled by the fact that a programcommand can often affect only a sub-part of the heap. For exam-
ple, the statement hmap = sw_malloc(sizeof(swHashMap)) is modeled as
affecting only hmap; the rest of the heap is unaffected by the alloca-
tion. The fact that sub-states can change in isolation is modeled by
theseparatingconjunction.Theunchangedpartoftheheapfora
command is its frame; the parts of the heap a command changes is
known as its footprint.
Thus,frame inference, which automatically infers command
frames such that they can be composed efficiently into proce-
duresummaries[ 18]6iskeytoanumberofautomatedreasoning
tools [45]. By discovering the unchanged heap portion of an op-
eration, frame inference discovers footprints, expressed as small
specifications of program terms [11, 22, 42].
Moreformally,theFrameRulecodifiesthenotionofreasoning
over local behavior:
{P}C{Q}
{P∗F}C{Q∗F}Frame Rule
TheFrameRuleallowsanalysisofacommand Cwithaspecifica-
tion{P}C{Q}and a heap state Hto proceed, without considering
unaffectedpartsof H(theframe F),ifitcanbeseparatedintoparts
{P∗F}.Frameinference[ 11,18,20]discoversaframe Fthatallows
the Frame Rule to fire, enabling local reasoning over the footprint.
We can summarize frame inference as follows. Let Frame (H,S)be
theframeinferenceprocedurethatreturnsaframe F(ifitsucceeds)
for a given heap state Hand a specification Sof a command (ex-
pressed in the grammar of Figure 3b). The procedure consists of a
proofsystemusingsubtractionandnormalizationrulestopartition
the heapHintoS∗F. We refer to previous work for the complete
algorithm and proof system [11].
6For completeness, this compositional analysis also infers anti-frames, or the missing
partsoftheheapsstate.Anti-frameinferenceallowstheanalysistodealwithunknown
calling contexts and increases precision by propagating intermediate results. Anti-
frame inference is not critical to our approach.2.3 Finding bugs using Separation Logic
Thepreviouslydescribedreasoningenablesscalable,compositional
static bug finding with minimal developer effort (in the form of,
e.g.,annotationsorcustomization)overreal-worldcodebases.Infer
implements these by ideas by converting source programs into SIL,
and then infers specifications (described as symbolic heaps) for SIL
programfragments.ItdiscoversbugsbysymbolicallyexecutingSIL
commandsoversymbolicheaps,accordingtoasetofoperational
rulesthatupdatesymbolicheapassertions[ 11].Thegeneralgoal
ofthisstaticanalysisistodiscoverprogrampathswithsymbolic
heaps that violate heap-based properties.
Infercurrentlysupportsdetectingawidenumberofheap-related
bugs using Separation Logic: resource leaks, memory leaks, null
dereferences,aswellasexperimentalsupportforbufferoverflow
detection, thread safety, and taint-style information flow bugs (e.g.,
detecting SQL injections for unsanitized values) [ 3,4]. While we
believeourapproachgeneralizestothesebugtypes,inthiswork
focusonpointer-safetypropertiesofheapsforrepair,specifically
resourceleaks,memoryleaks,andnulldereferences,asthesupport
fortheminInferismostmature.Weleaveextensionofourapproach
to further classes of bugs for future work.
Toillustrate,considerthememoryleakdescribedinFigure1a.
Infer disovers this error by identifying the path through line 11
where the variable hmapis allocated but notfreed before becoming
dead. When it discovers such an error, the symbolic interpreter
entersaspecialstate, fault.Wedenotethisformallyby C/lscript,σ/leadsto
fault, meaning that the interpretation step /leadstofor instruction Cat
location/lscriptin symbolic state σresults in a fault. For this example,
hmapisstillallocatedinthesymbolicheap(denotedbythepredicate
alloced, i.e.,{hmap /Mapstochar⇒alloced}) at the location/lscript=11 when it
becomes dead: return/lscript,{hmap /Mapstochar⇒alloced}/leadstofault.7At this
point, our approach takes over from the bug-finding analysis, to
seek a potential fix.
3 REPAIR WITH SEPARATION LOGIC
ThissectionpresentsourprogramrepairtechniqueusingSepara-
tion Logic. Section 3.1 formalizes our notion of repair with respect
to heap-based property violations. In Section 3.2 we formalize the
search procedure to discover candidate patch code, drawn from
existingprogramfragments(i.e.,fromelsewhereintheprogramun-
der repair). In Section 3.3 we describe the application of candidate
fragments in source code, in terms of where to introduce a change
and how we filter out invalid candidates. We illustrate throughout
by referring to the motivating example in Figure 1.
3.1 Formulating Repair
Fundamentally,anyprogramtransformation(forrepairorother-
wise) is composed of either one or a combination of two primitive
operations: addition and removal of program terms. Taking Sep-
aration Logic as the abstract domain, a bug fix corresponds to a
program transformation that leads to a fault-avoiding interpreta-
tionin the analysis with respect to the property in question. We
presentlyconsider only additiveprogram transformations, anddo
not perform removal operations, because the types of bugs we
consideraretypicallycausedbythe lackofcertainoperationson
7Forillustration,weconsideronlythepredicateon hmap,ignoringtherestofthestate.
154
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:50:07 UTC from IEEE Xplore.  Restrictions apply. Static Automated Program Repair for Heap Properties ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
explicit heap content (e.g., resource release, freeing memory, or
checking nullness of return values). For instance, developers of-
tenforgettoinsertmissingchecks[ 6,60].Bug-fixingchangesfor
thesetypesofbugsthuscorrespondtoinsertingmissingstatements
(e.g., checks, initializations, or cleanup handlers). Other types of
repairs are certainly valuable, in this domain and others, but we
leave discovery of them to future work.
The central repair question is thus: Does there exist a fragment
?Cthat can be used to transform the program such that the fault
state is no longer triggered? We express this formally as follows:
Definition3.1. ProgramRepair. LetHBadbetheheapconfigu-
rationthatresultsinafaultunderinterpretationofacommand Cat
location/lscript.Arepairisanadditivetransformation Tonaprogram P
thattransitionsthefault-inducingpredicateintheheapstate HBad
toaheapstate HGoodthatpreservesafault-avoidinginterpretation
forCat/lscript. A repair satisfies:
C/lscript,HBad/leadstofault =⇒T/lscript/prime,H∗/leadstoC/lscript,HGood/negationslash/leadstofault
The additive transformation Tis a program fragment (operating
on the program heap Hat some point/lscript/prime) that induces a desired fix
effecton the heap, producing HGoodat/lscript. The fix effect precisely
defines what it means to avoid the faultstate.
Weencodethetransformation T(i.e.,thefixeffect)asaHoare-
styletriplethatwecallaRepairSpecification.Wespecify Tas
twosingletonheaps(i.e.,asinglepoints-torelationasinFigure3b):
Fmappingtoa fixablepredicateoveraplaceholdervariable pvarin
the precondition, and a corresponding F/primemapping to a fixedpred-
icate over that placeholder pvarvariable in the postcondition. F
andF/primeexpressthedesiredsymbolictransitionontheabstractpred-
icates. For example, F={pvar /Mapstochar⇒alloced},F/prime={pvar /Mapstochar⇒freed},
specifies a generic fix effect for memory leaks over placeholder
variablepvar. Note that such fix effects are generic to entire bug
classes.Byexpressingrepairovertheabstractdomaindescribing
whatthecode does,thisfixeffectspecificationapproachismulti-
language and resilient to syntactic customizations (like APIs or
wrapper functions).
Definition 3.2. Repair Specification . A Repair Specifica-
tionRis a specification containing a program term repair frag-
mentCR(acommand CintheSmallfootgrammar)thateffectsa
state transition from an error heap configuration Fto a fixed heap
configuration F/prime,denoted{F}CR{F/prime},viaanatomicupdateofan
abstract predicate.
Inthispaper,wemanuallyspecifyappropriate FandF/primecorre-
sponding to the general bug classes in question. Defining a mecha-
nismtoautomaticallydetermine FandF/prime(e.g.,byformallyderiving
it from a violation reported by an analysis) is an interesting andplausible research direction that we leave for future work. Note
however,thatfixeffectsaregenerictoanentirebugclass,andthus
need only be specified once per analysis type to be applied to a
givenprogram.Moreover,thestaticanalysisprovidesadegreeof
confidence in the choice of FandF/prime: a poor choice will not ensure
a fault-avoiding interpretation for a particular fault, and will be
detected by analysis of the transformed program.
Our implementation provides default fix effects for the bug
classes we consider that suffice for many off-the-shelf projects,requiringcustomization onlywhen aprojectuses aparticularorunique paradigm for handling, e.g., custom exceptions. Extend-ing our technique to new static checkers (employing automated
semantic reasoning as found in Infer) could similarly involve speci-
fying default fix effects for patching them, eliminating the need for
developer-provided specifications for many real-world projects.
3.2 Searching for Repairs
RepairQueries. Differentautomatedtechniquescandiscoverre-
pairs,includingprogramsynthesis[ 30]orsyntacticprogrammuta-
tion[33].Ourtechniquedoessobysearchingoverexistingprogram
fragments, whichcan oftenexhibit thedesired semantic effectsto
fix faults [ 30,31,37]. Using existing program fragments also pre-
serves program-specific syntactic structure and semantic shapethat accompany a fix, and may decrease the risk of overfitting
repairs[29].Wethussearchforprogramfragments CRintheSmall-
foot IL from across the rest of the program with a Repair Query.A
Repair Query encodes the desired semantic transition and returns
satisfying Repair Specifications.
We illustrate this overall framing with respect to our running
example in Figure 4: The computation in (1) shows the seman-
tic change that must be induced by some ? C/lscriptto preserve a fault-
avoiding interpretation, fixing the memory leak bug in question.
Thecomputationin(1)informstherepairquestionlabeled(2)in
Figure 4. The specification in (2) describesa desired program frag-
ment ?Cthat induces the desired fix effect on symbolic variable
pvar,whichisallocatedonpreconditionto? C,andfreedonpost-
condition. Note that this fix effect is flexible, and could describe
fix code such as freemodeled in generic C or the custom sw_free
function. A Repair Query seeking to repair a file resource leak,
ontheotherhand,couldfindfragmentssuchas closeorfclosein
C, or f.close() for a file fmodeled in Java. Although the fix effects
must be either inferred or specified, their portability across mul-tiple programs and languages amortizes the manual burden andrepresents an important improvement over the labor required to
usetest-basedAPRtechniques,whichrequireatriggeringtestcase
per bug under repair.
?C/lscript/prime,{map /Mapstochar⇒alloced}/leadstoreturn /lscript,{map /Mapstochar⇒freed}/negationslash/leadstofault(1)
{pvar /Mapstochar⇒alloced}?C{pvar /Mapstochar⇒freed}(2)
Figure 4: Modeling repair search.
We call (2) the Repair Query, a Hoare triple containing a “hole”
foraninstruction Cthatinducesthedesiredsemanticchangeunder
the standard partial correctness interpretation. For example, the
fixingfragment sw_free(map); correspondsintheILtoacommand
Cof the form{map /Mapstochar⇒alloced}call(·){map /Mapstochar⇒freed}, with the
concrete program variable mapbound to pvar.
SemanticSearchConstraints. ARepairQueryexpressesa sym-
bolictransitiononthe abstractpredicates,providingabasic struc-
ture that expresses fixes in terms of desired semantic heap prop-erties. So far, our example Repair Query specifies
CRprogram
fragments that perform strictly the desired symbolic transition,
155
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:50:07 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Rijnard van Tonder and Claire Le Goues
disallowingany CRthatmayintroduceextrasemanticeffects.How-
ever,as apracticalconsideration,it maybedesirable tosearchfor
program fragments that introduce extra semantic effects in addi-
tion to the fixing effect. For example, sw_freeperforms cleanup and
logging in addition to resource freeing; in other cases, such side
effects may be benign, or undesirable.
Fortunately,Separation Logic allowsus toelegantly relaxstrict
Repair Queries by explicitly allowing for and then capturing extra
semanticeffectsbeyondthedesiredfixeffect.Thisproducesarepair
search method that can be parameterized by extra semantic effects,
explicitly partitioning such effects from the fixing effect (absent
a priori knowledge to the fixing effect). Such a search returns re-laxed Repair Specifications of the form
{F∗P}CR{F/prime∗Q},
where(potential)extrasemanticeffectsareboundinthepre-( P)
or postcondition ( Q) respectively. Finding satisfying Repair Speci-
fications comes with an analogous extension of a Repair Query,
i.e.,{F∗P}?C{F/prime∗Q}.
Pertinently, wecanuse frameinference inanovel waytosolve
twoimportant(anddistinct)purposesintheprogramrepairsearch
problem:(1) Checkwhether agiven specificationsatisfiesa repair
query, and (2) discover the extra semantic effects not part of the
fix.Thatis,supposesomecommand Chasafootprint,expressedas
{SP}C{SQ}.Ourfirstgoalistocheckwhetherthefootprintsatisfies
the Repair Query,which we do with respect to corresponding pre-
and postconditions FandF/prime. Our second goal is to partition the
footprintintothefixingtransitionsandextrasemanticeffectsfor
pre- and postconditions, respectively.
Our key insight is to perform the frame inference procedure
Frame(Section2)onthe footprintprecondition(resp.postcondition)
withrespecttothe RepairQuery precondition(resp.postcondition).
Formally, Cis a candidate repair fragment when the following
entailments hold:
In the precondition:
Frame(SP,F)=P=⇒SP/turnstileleftF∗P (3)
Respectively, in the postcondition:
Frame(SQ,F/prime)=Q=⇒SQ/turnstileleftF/prime∗Q (4)
We achieve(1)becausethe entailmentdoesnothold (framein-
ferencefails)when Fisnotsatisfiedbythequery.Ifframeinference
succeeds, it pulls out P(resp.Q), discovering the extra semantic
effectsinthefootprintof C,achieving(2).Ourapproachissound
and decidable by the frame inference procedure [11].
Assume Fcontainsthespecificationsinferredoverallindivid-
ualcommandsinaprogram.Algorithm1:FindCandidates( R,F)
soundlyreturnsallcandidateRepairSpecificationsforquery R.
InLine4and5ofAlgorithm1,weusetheframeinferenceproce-
dureFrame,tomatchcandidatefragmentswitharepairqueryas
theconjunctionofmatchingpre-andpostconditions.NotethattheprocedurereturnstheentireRepairSpecificationbecauseweuse
assertions in the precondition for repair application (Section 3.3).
3.3 Applying repairs: from logic to programs
A Repair Specification in the abstract domain must be translated
to a syntactic program fragment in the source program. Every
intermediate language (IL) instruction corresponds to a line in the
originalprogramsource.Whenacandidateprogramfragmentis
translatedfromILtosource,werenametheprogramvariableboundAlgorithm 1: Find Candidate Repair Fragments
1Match( S,R);
2let{RF}?CR{RF/prime}=Rin
3let{SP}C{SQ}=Sin
4ifFrame( SP,RF)=RP/nequalfail⇒SP/turnstileleftRF∗RP
5∧Frame( SQ,RF/prime)=RQ/nequalfail⇒SQ/turnstileleftRF/prime∗RQthen
6 return{RF∗RP}?CR{RF/prime∗RQ}[C/?CR]
7else
8 returnfail
9end
10
11FindCandidates( R,F);
12C:=∅// Candidates
13foreach S∈Fdo
14 ifMatch( S,R)=C/nequalfailthen
15 C:=C∪C
16 end
17end
18return C
topvarinthefixingfragmenttothatofthefault-inducingvariable,
if necessary. This substitution is the only syntactic transformation
that we apply on source fragments. Beyond this renaming, we
must decide where to insert repairs, and check translated code
for compatibility given associated heap assumptions and available
variables and type information (available in the IL).
Determining Repair Location. Repairtechniques typicallyrely
ondynamicfaultlocalizationtechniquestodetermineplacementor
manipulationofcode[ 7].Bycontrast,werelyonthestaticanalysis
to localize faults: When the symbolic interpreter enters a fault
state, it provides a location /lscriptwhere the fault occurs.
In general, the fault class bears on the choice of where to apply
a repair fragment. For null dereferences, we speculate that a devel-
opermighttypicallyexpectachangebeforethenulldereference
(e.g., a check), whereas for resource leaks we expect a change after
the point at which the resource is last used (e.g., closing a file).
UsingInfer,anulldereferencereportsthelocation /lscriptimmediately
precedingthedereference.Forresourceleaksandmemoryleaks,
the location/lscriptis the point where the resource (resp. memory) goes
out of scope without being closed (resp. freed). We make the de-
sign choice to insert a repair fragment CRdirectly preceding the
program term at location /lscript, satisfying
CR/lscript/prime,HBad/leadstoC/lscript,HGood/negationslash/leadstofault
WerefertotheexampleinSection1tomotivateourchoice.Our
approach places the sw_freecall at line 11 in Figure 1a. The first
motivationisthatrepairlocationistypicallyrestrictedtofewalter-
natives;theonlyothercorrectchoiceofplacementisline10.The
location/lscriptthus offers the most immediate (and sometimes strictly)
correctchoice.Thesecondmotivationisthatamongmultipleplace-
ment locations, the semantic effects of repair remain the same. For
example, placing sw_freeat line 10 in Figure 1a. produces the same
effectsincethe swWarn(...) statementdoesnotaffecttheheap.Thus,
althoughthereisnouniversallycorrectchoiceforrepairplacement,ourdomainofrepairbenefitsfromageneralstrategythatpreserves
semantic correctness. Determining the ideal placement of patches
156
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:50:07 UTC from IEEE Xplore.  Restrictions apply. Static Automated Program Repair for Heap Properties ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
withrespect tonon-semanticattributes mayvaryby context,and
maybesubjecttostylisticconventionsandhumanjudgmentthat
go beyond the scope of this work.
Determining Patch Compatibility. Patch compatibility deter-
mines whether we caninsert a syntactic program fragment at a
particular program point ( /lscript, in our case). FootPatch performs
two compatibility checks. The first addresses bugs that can have
multiple candidates. For example, memory may be freed by the
standardClibrary freecall,orawrapperfunctionsuchas sw_free
asinListing1b.WhenmultiplecandidatefragmentsinSILmatches
the desired semantic effect (based on predicates that do not con-
sidertypes),FootPatchprioritizespatchgenerationbymatching
type informationof acandidate fragment’s variableand thefault-
inducing variable. This means that FootPatch prefers sw_freeover
freein our example, because we can infer the type of hmapto be
swHashMap * , which matches the same type of mapin the candidate
fixing fragment sw_free(map) . FootPatch falls through to matching
candidateswithgenerictypes(i.e., void *forC)ifitcannotmatch
specifictypes.Althoughtypinginformationcouldbeusedtorefine
patches for null dereferences, we ignore typing information in this
case, since any object can be compared to null.
Recompilation serves as our second compatibility check, en-
suring (a) that syntactically malformed patches fail (due to poorIL-to-source translation or fault locations), and (b) that program
fragmentswithunboundfreevariablesareinvalidated.Forinstance,
the fix for the bugs in Figure 2 binds to the variable idthat is in
scope. If idwerenotin scope, patch generation fails. Relatedly,
FootPatch allows capture of program variables (beyond the fault-
inducing variable) in fixing fragments if they are available (such as
idwhich is in scope).
4 EVALUATION
This section describes our the results of using FootPatch to fix
bugsinreal-worldprograms.Section4.1describesourexperimental
setup. Section 4.2 describes overall repair results, where we use
FootPatchtofix55bugsin11projects.InSection4.3wediscuss
patch quality, and particularlyits relationship to Infer’s underlying
static analysis and our other design decisions. Section 4.4 analyzes
FootPatch’srepairdiscoveryforresourceleaks,memoryleaks,and
nulldereferencesinthecontextofourgeneralformalism(Section3).
Section 4.5 provides limitations and further discussion.
4.1 Setup
Implementation. Based on the techniques described above, we
implemented an automatic bug repair tool called FootPatch ex-
tending the Infer static analyzer. FootPatch works on multiplesource languages (we evaluate on programs in C and Java; Inferalso supports C++ and ObjectiveC) because, like Infer, it reasons
over programs translated into SIL. FootPatch uses the same predi-catesintheILirrespectiveofsourcelanguage,meaningitcanapply
directly to new languages as support for them is added to Infer.
FootPatchusesthreegeneralspecificationsforrepairingnull
dereferences, resource leaks, and memory leaks; Figure 5 provides
a simplified representation. The specifications are implemented as
OCaml functions that match pre/post conditions on heap state and{pvar /Mapstochar⇒Null}?C{_ /Mapstochar⇒Exne} (5)
{pvar /Mapstochar⇒/angbracketleftFile, Acquired/angbracketright} ?C{pvar /Mapstochar⇒/angbracketleftFile, Release/angbracketright} (6)
{pvar /Mapstochar⇒/angbracketleftMemory, Acquired/angbracketright} ?C{pvar /Mapstochar⇒/angbracketleftMemory, Release/angbracketright} (7)
Figure 5: Repair Specifications.
predicates (referencing Infer’s datatypes). Note that this specifi-cation mechanism is not intrinsic to the technique (i.e., it is pos-
siblewriteaDSLforexpressingsuchspecifications).FootPatch
performs type matching for determining patch compatibility, (Sec-
tion 3.3) by extending specifications (6) and (7) in Figure 5 with an
optionalguardclause“ whenpvar.type =t”ifwecandeterminethe
typetofafaultingvariable.Ingeneral,sincesimpleexpressionsdo
not model semantic effects of interest to the bug types in question,
we restrict repair queries to calls and branch statements in the IL.
Data and experimental parameters We ran our experiments
on an Ubuntu 16.04 LTS server, with 20 Xeon E5-2699 CPUs and
20GBofRAM.Table1includesprojectswhich(a)successfullybuilt
on our system, (b) could be analyzed by Infer, and (c) generatedpatches. Our project selection represents a convenience sample,
intended to substantiate our claims about FootPatch applicability
to real bugs in real and actively developed open-source systems;
we include discussion of sources of failures and other technique
limitations in Section 4.5. We evaluate on 8 C programs and 3 Java
programsaveraging64kLOC.WeinitiallydevelopedFootPatch
basedonexistingbugsin error-prone and jfreechart andnewbugs
found in swoole. The rest of the projects are C and Java repositories
onGitHubthatareeither(a)randomlysampledfromthetopone
thousandmostpopularrepositories(byuserfavorites/stars)forC
and Java respectively, or (b) contain any combination of the terms
“leak”,“resource”,“memory”,“file”,or“fix”intheircommitmessages.
Projects in our sample are excluded if they fail to compile in our
environment, if they cannot be analyzed by Infer, or if FootPatch
did not find patches (either because no bugs were found or due to
some other failure).
WeevaluatedFootPatchintwomodestocharacterizeitssearch
behavior.In callgraph-local mode,FootPatchsearchesovercan-
didatesfromthecallgraphoffunctionswhereInferreportsabug.
Thismodetrackswhethercandidatesarefoundlocaltothefunction
containing the bug, local to the file containing the bug, or from an
external file. In global mode, FootPatch searches over all (disjoint)
callgraphs. Global mode subsumes callgraph-local mode and, inour experiments, only discovers additional repair candidates inexternal files not included in the local callgraph. Global mode is
naturally more time-intensive, but may identify additional patches;
comparing the two modes allows a more precise understanding of
the importance of locality in searching for bug fixes within a given
program. In all results discussion, ΔGL indicates the increment
searching globally has over searching locally.
4.2 Repair results
Table 1 show results for each project. “Bugs” indicates the number
ofbugsdetectedbyInferofthegiventype.Itispossibleformultiple
semanticfragmentstorepaireachtypeofbug,foundatdifferent
locationsintheSILcallgraph.Foreachbugtypeperprogram,“MaxCands” shows maximum number of IL repair candidates before the
157
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:50:07 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Rijnard van Tonder and Claire Le Goues
Time Bug Max
Project Lang kLOC (s) ΔGL Type BugsCands ΔGLFixesΔGLFPΔGL
Swoole C 44.5 20 +83Res. Leak† 7 1+ 6 1+ 2 0+ 0
Mem. Leak† 20 3+ 0 6+ 0 3+ 0
lxc C 63.0 51 -Res. Leak 3 5- 1- 0-
Mem. Leak 813 - 0- 1-
Apktool Java 15.0 584 +92 Res. Leak †19 3+ 2 1+ 0 0+ 0
dablooms C 1.2 9 +0 Res. Leak † 7 2+ 0 7+ 0 0+ 0
php-cp C 9.0 20 +5 Res. Leak † 4 3+ 1 1+ 0 0+ 0
armake C 16.0 10 +13 Res. Leak † 5 7+ 4 4+ 0 0+ 0
sysstat C 24.9 28 +10 Res. Leak 110 +0 1+ 0 0+ 0
redis C 115.0 79 +121 Res. Leak † 8 8 +10 6+ 0 0+ 0
rappel C 2.1 7 +3 Mem. Leak †1 6+ 0 1+ 0 0+ 0
error-prone Java 149.0 262 +602 Null Deref 11 66 +0 2+ 0 0+ 0
jfreechart Java 282.7 1,268 - Null Deref 53221 - 22 - 0-
Table 1: Bugs repaired with FootPatch. “Bugs” is the number of bugs detected by Infer’s static analysis. “Max Cands” is the
maximumnumberofILrepaircandidatesforthebug(pre-compatibilitycheck).“Fixes”arethenumberofuniquepatchesfix-
inguniquebugs(postcheck). †indicatesoneormorefixesforpreviouslyundiscoveredbugs.“ ΔGL”isthechangeinassociated
column when using the global search space.
compatibilitycheckwhichdetermineswhetherapatchcandidateis
suitable syntactically. FootPatch emits the first compatible patch
producedfromthecandidates.“Fixes”showsthenumberofunique
patches that fix true semantic errors. Conversly, “FP” shows thenumber of unique patches that fix false positive bug reports; we
discuss patch quality and correctness in Section 4.3.
In total, we discover 24 fixes for resource leaks, 7 fixes for mem-
oryleaks,and24fixesfornulldereferences.The“Time”columns
ofTable1shows totaltimerequiredtobothfindandpatchallbugs
ofalltypesconsideredinthatprogram.Performancerangesfrom
7secondsto22minutesoverallprojects(notethatFootPatchper-
formance is intertwined with Infer’s analysis time). The jfreechart
experiment failed to terminate in global mode because the Infer
analysisphase ranoutofmemory; lxcfailedto buildintheglobal
configuration.
Global mode ( ΔGL) discovers only 2 additional fixing patches.
This patch fixes a resource leak due to discovering a close-like
function that is not present in the local search. Our results suggest
thatlocalizingsearchforfixingfragmentsisaneffectivestrategy
forrepair.Thisisconsistentwithempiricalresultsthatsuggestthat
code is redundant locally, especially within a module [55].
4.3 Patch quality
Patch correctness and success. All produced patches ensure a
fault-avoiding interpretation; in practice, we apply each patch gen-
eratedbyFootPatchandrerunthestaticanalyzertoseeifthepatch
removesthebug(alldid).Wherepossible,weranaproject’stest
suiteafterapplyingourpatchestovalidatethatourchangesdonot
breaktests.Wesuccessfullyranthetestsuitesfor Apk-tool,armake,
and error-prone ,whichpass.Twoprojectscontainednotests,andthe
remaining six test suites could not be successfully configured/built.
A “fix” in Table 1 produces a patch that addresses a true posi-
tivebug report from the static analysis. To be useful in practice,
analyses approximate [ 34]. Infer is no exception, and it sometimes1 fp = fopen(rdbfilename, "r");
2 ...
3 if(memcmp(buf, "REDIS" ,5) != 0) {
4 rdbCheckError( "Wrong signature t rying to load
DB from file" );
5+ fclose(fp);
6 return 1;
7 }
8 rdbver = atoi(buf+5);
9 if(rdbver < 1 || rdbver > RDB_VERSION) {
10 rdbCheckError( "Can't handle RDB format
version %d" ,rdbver);
11+ fclose(fp);
12 return 1;
13 }
14 ...
Figure6: fpcanbeleakedonatleasttwopaths(lines6and12),but
Infer short circuits the analysis and only reports the leak on line 6
bydefault.WithFootPatch,theleakisfixedatline6,allowsInfer
tofindtheanotherresourceleak,whichisthenalsofixedatline11.
skipsinferringspecificationsforafunctionduetoananalysistime-
out, continuing with partial results. This can lead to false positives.
FootPatch uses Infer’s results to perform patching, and cannot
distinguish between true and false positives (if it could, it wouldbe a better analysis than Infer; this task is outside its scope). A
manual inspection of Infer’s reports indicate that its false positives
generallyarosewhenitfailedtoanalyzeloopsorcleanupfunctionsdue to time out. Due to the complexity of
jfreechart it is difficult to
preciselydeterminehowmanyoftheInfer-reportednullderefer-
encesarefalsepositives.However,ourmanualinspectionofdidnot
reveal obvious errors in reasoning behind the produced patches.
False positives that produced patched bugs are listed in column
“FP”ofTable1.Ingeneral,thefalsepositiverateislow,intheorder
of5%,wherefixesareproducedforfalsepositiveerrorreports(“FP”
column) compared to fixes for true positives (“Fixes” column).
158
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:50:07 UTC from IEEE Xplore.  Restrictions apply. Static Automated Program Repair for Heap Properties ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
1intfd = open(filename , O_RDONLY);
2...
3swString *content = swString_new(filesize);
4if(!content) {
5+ close(fd); // FootPatch repair
6 return NULL;// function returns with fd not closed
7}
8...// continues with norm al operation
Figure 7: Resource Leak: forgetting to close a file.
Ontheotherhand,Infermayfindbugsthatdonotresultinafix
(therearetypicallymore“Bugs”than“Fixes”inTable1).FootPatch
finds 54 fixes out of 145 bugs (excluding false positives). Patch
generationfailswhennorepaircandidatecanbefoundforthebug.
Generally, this happens when (a) Infer’s analysis times out (e.g.,
duetoloops),leadingtoincompletefunctionspecificationsorshort
circuited analysis that miss fixing fragments, (b) Infer does not
resolve program variables associated with a bug report, (c) no type
compatiblefragmentsarediscovered,or(d)memorytimeoutsoccur
for parallel analysis processes, short circuiting analysis results.
Patchlocation. As motivated in Section 3.3, FootPatch heuristi-
cally places fix code at the line where Infer reports the violation.
Forresourceandmemoryleaks,feasiblerepairlocationsarecon-
strained by the number of lines at which the resource is no longer
in use, but before it is officially dead. In our data, the maximum
numberofpossiblecorrectlocationsacrossall31fixingpatchesfor
resource/memory leaks is3, while the average is1.7. This implies
littleopportunitytovaryplacementoutsideofourconvention,sim-
ilartoourmotivatingexampleinFigure1a.Fornulldereferences,
checks may plausibly be placed anywhere between the point at
whichanobjectbecomesnullanditsdereference.Ourinspection
based on Infer’s bug reports revealed that the number of locations
ranges from 1 to 30, which poses more variability for placement.Patches reveal more bugs.
An especially interesting implication
ofunifyingbugdetectionandrepairisthepotentialforthelatter
to extend the capabilities of the former. In our experiments, Foot-
Patch generated patches for the redisproject that then allowed
Infertofindtwoadditionaluniquebugs.Figure6showsasnippetof
the code in question. The fpfile pointer leaks on at least two paths
(lines 6 and 12). Before patching, Infer only reports a resource-leak
forthevariable fp,becauseit“shortcircuits”itsanalysisoncethe
first leak is detected. After FootPatch inserts fclose(fp); on line
5,Inferreportsthesecondleakonline11.RerunningFootPatch
yieldsanadditionalfixonline11.Tothebestofourknowledge,this
isthefirstdemonstrationthatautomatedpatchinghasthepotential
to improve static analysis.
4.4 Fixing by semantic effects
ResourceandMemoryLeaks. Resourceleaksoftenoccurwhena
functionreturnsprematurelyduetoanerror[ 6,59].Figure7shows
aleakofanunreleasedfilehandleinthe Swoole8project.FootPatch
uses the Repair Query {pvar /Mapstochar⇒/angbracketleftFile, Acquired/angbracketright} ?C{pvar /Mapstochar⇒
/angbracketleftFile, Release/angbracketright} from(6),Figure5,todiscovera close(fd); elsewhere
in the program. This demonstrates the importance of the compati-
bilitycheck,whichguardsagainstapplyingalternative“close”op-
erations (e.g., fclose) by using typing information. The pull request
8Swooleis the 34th most popular C project on GitHub at the time of writing.basedonthepatchinFigure7wasaccepted,9animportantmile-
stone for end-to-end automatic repair of a previously undiscovered
bug.
Notethat,althoughconceptuallysimilartoresourceleaks,mem-
oryleaksdeserveseparatesemantictreatmentbecausetheytend
to occur in programs written in languages that are not garbagecollected. Anecdotally, memory leaks may entail more complexfixes in terms of semantic effects. All resource leak patches con-
formtostrictRepairSpecifications(meaningtheyonlyaffectthe
heaplocationofinterest).However,fixingfragmentsformemory
leaksmayentailextrasemanticeffects.Oneexamplefragmentis
swHashMap_node_free(hmap, root); fromthe Swooleproject,whichfrees
a data member rootthat is in the table hmap. A necessary precon-
ditiontoinsertingthisfragmentforfreeing rootisthat hmapbein
scope (which it is, where it is used in our produced patches). Weobtain such a fragment by relaxing the Repair Query to allow
extrasemanticeffects.Oneimplicationofrelaxingrepairsisthat
applicationmaybecontextual,andsubjecttoadditionalcompati-
bilitychecks(e.g.,scopeandvariablecapture)withrespecttoextrasemanticeffects.Insummary,ourresultsshowthatFootPatchthemajority of leak fixes conform to strict Repair Specifications, but
enables more complex fixes when relaxing the repair constraint.
Null dereferences. The FootPatch patch for the null derefer-
ence(s) in Figure 2 throws an exception when an object is null.
However, in general, multiple semantic fix effects may address a
givennulldereference:initializinganullobject,returningorthrow-inganexceptionwhenanobjectisnull,orpredicatingexecutionona conditionthat anobjectis notnull. More thanone ofthese forms
may be correct with respect to a preserving a non-null property,
and in general we cannot decide which one is preferred [35].
We therefore experimented with Repair Specification queries
inFootPatchovermultipleSILcommandstodiscovernullderefer-
ence fixes (i.e., function calls entailing nullness checks, conditional
expressions).Ourapproachalleviatestheproblemofmultiplepo-
tentialfixesbyrelyingonexistingcodetoguiderepair.Forexample,
for jfreechart , FootPatch produces 22 patches from a candidate
which throws an exception when the object is null. This may be
thedesirablefix,aswitnessedbyhuman-writtenfixesforthe error-
pronebug [2]. Regardless, from a semantic perspective, FootPatch
finds candidate fixes from the existing project that removes the
fault with respect to the analysis.
4.5 Limitations and discussion
FootPatch currently fixes resource leaks, memory leaks, and null
dereferences;thesebugsareamaturefocusofInfer’sanalysisdo-
mainandarecommoninpractice[ 16,17].Givenbothourunder-
lying technique, which addresses general heap-based properties,
and the continual addition of new analyses to Infer [ 4],weexpect
FootPatch to generalize to, for example, information flow bugs.
FootPatch currently requires a simple manual fix specification,
generally per bug type. This formulation provides flexibility to ad-
dressparticularattributesoverdiversebugclassesandlanguages.
The manual effort is competitivewith effort required to produce a
test per bug, required by dynamic repair techniques. Moreover, we
9https://github.com/swoole/swoole-src/commit/e12c7db38c9737234695d35d9
159
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:50:07 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Rijnard van Tonder and Claire Le Goues
recognize an opportunity for automatically inferring fixing effects
with the aid of a static analyzer, for future work.
FootPatch does not consider the full diversity of possible fixes
for theconsidered defects, especiallyfor nulldereferences(we in-
vestigated checking nullness and throwing an exception, accepted
ways forfixing thesebugs, but notinstantiating newobjects gener-
ally). Our approach currently inspects only semantic patch charac-
teristics,ignoring,forexample,stringconstantsinanerrormessage.
We leave such considerations to future work.
Beyondfalsepositives,Infercanproduceinaccuratefaultloca-
tions, impacting the validity of FootPatch patches. Approximate
locations are acceptable for bug reports, and approximate patches
maystillbeinformative[ 57],buttrulyautomatedprogramrepair
requires precise locations. This can be addressed practically by
improving the accuracy of IL-to-source translation during analysis.
We do not explicitly compare our technique to prior repair tech-
niques.Overall,FootPatchisorthogonal(andthusdifficulttocom-
pare)topriordynamicrepairtechniques.Twoofourbugclasses,
resourceandmemoryleaks,aredifficulttotestfordeterministically,
andthusunderaddressedinthecurrentrepairliterature.Theredoes
exist work addressing repair of null dereferences, which are easier
to expose via tests. We attempted to run and fix the null deref-erences in Apache Commons Math considered by NOPOL [
61].
However, Infer’s analysis skips a number of intermediate calls, and
failstodetectthenulldereferencescoveredintheassociatedtest
suite.Practically speaking,we findthat testsfor nulldereferences
considered in prior work (such as Defects4J [ 28]) simply cover
differentnulldereferencebugsfromInfer.Thishighlightsoneprop-
erty of static analysis for repair: analysis may miss bugs that could
becoveredbytests,butmaysimultaneouslyfindthoseincorner
casesthathumansneglectedtotest.Relatedtechniquesbasedon
verification [ 35] lack detailed breakdown of bugs to inform a com-
parative study, and is intended to provide patch suggestions to adeveloper, which lacks automatic patch application. We are un-
aware of “quick fix” suggestions from existing static tools [ 1,2,27]
that target semantic bugs like those we consider.
5 RELATED WORK
Workinautomaticprogramrepairoverthepastdecadepredomi-
nantly use test cases to validate correctness. Generate-and-validate
orheuristicrepairtechniquesexploresearchspacesoftemplated
repairs as applied to the abstract syntax tree program level; this in-
cludes techniques like GenProg [ 33], RSRepair [ 50], and HDRepair
[32]whichtraversethespaceusingclassicsearchalgorithmslikege-
neticprogrammingorrandomsearch.OthertechniqueslikeAE[ 58]
SPR [37] and Prophet [ 36] use predefined transformation schemas
andprobabilisticmodelsontheASTtodiscoverandapplycandi-
date syntacticfragments. Ata highlevel, such techniquesoperate
on ASTs to indirectly achieve a desired semantic effect that fixes
abugwithrespecttoatestsuite.Constraint-orsemantics-based
approaches reason about semantics more directly, synthesizing
fragmentsusinginput-output pairstocodifyanotion ofprogram
semantics [ 38,39,41,61]. SearchRepair [ 29] lies between these
approaches, using input-output pairs to search over a semantic
encodingofcandidaterepairfragments(andisperhapsclosestin
spirittoourapproach).Thesetechniquesallsharethepropertythattheyusetestcasestodefinepatchcorrectnessandguideasearch
towardsasemantically-desirablefix;asaresult,theyalsorequire
developer labor to specify those tests; are limited to fixing bugs
that are deterministically testable, and may overfit to the provided
tests [54]. The main point of contrast with our work is that our
approachisstatic,andthereforecannotoverfittoprovideddynamic
witnessesofdesiredbehavior.Inthepreviousbodyofwork,proper-
tiesarenotspecifiedformally,butimpliedbytestcases.FootPatch
instead considers a logic-encoding and semantic implications ofusing a program fragment for satisfying repair specification. We
argue that our focus on explicitly codifying semantic effects offers
additional protection against patch overfitting.
Verification-based approaches, using formal specifications, have
used LTL specifications [ 26,56], SAT approaches [ 23], deductive
synthesis [ 30], contracts [ 35], and model checking for Boolean pro-
grams [24,52] to perform repair. At a high level, our approach
relates to the approach by Logozzo et al. [ 35] which uses auto-
maticallyinferredassertionsoverabstractdomains,andrelieson
an abstract interpretation-basedstatic analyzer to discoverfaults;
however,they do not consider automatically applyingpatches. In
contrast,ourapproachisnewinreasoningoveranabstractdomain
based in Separation Logic (repairing pointer safety violations) and
formalizesamechanismforautomaticpatchapplication.Overall,
verification-basedprogramrepairlackapplicationtocommonbugs
in real-world programs.
6 CONCLUSION
WepresentedanewstaticAPRtechniqueusingSeparationLogic
to reasonaboutsemantic effectsof programfragments, including
a novel application of local reasoning and the frame rule to find
bug-fixingpatchesfromexistingcode.Ourtechniqueovercomes
significant challenges compared to test-based repair techniques,
including the ability to repair previously undiscovered bugs, bugs
that are difficult to expose via testing, and repeated semantic er-rors. We implemented our approach in a tool called FootPatchthat builds on top of a Separation Logic-based analysis to target
bugrepairforheap-relatedproperties;wedemonstrateonresource
leaks, memory leaks, and null dereferences, and anticipate that
the approach is extendable. FootPatch correctly fixes 55 bugs, in-
cluding 11 undiscovered bugs in 11 projects. Moreover, FootPatch
achieves significant speedup over test-based repair, works on large
codebases, and targets multiple source languages. Unlike other for-
mal approaches for program repair, FootPatch works end-to-end
onexistingcodebasesanddoesnotrequireformalannotationor
special coding practices. Its reliance on principled semantic reason-
ing provides additional evidence of generated patch correctness.
FootPatchthusrepresentsanimportantstepinbridgingthegap
betweengroundedverificationtechniquesandtrustworthyauto-
matic program repair for real-world software, opening potentially
promising avenues in automatic program improvement.
7 ACKNOWLEDGMENTS
This work is partially supported under NSF grant number CCF-
1563797. All statements are those of the authors, and do not neces-
sarily reflect the views of the funding agency.
160
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:50:07 UTC from IEEE Xplore.  Restrictions apply. Static Automated Program Repair for Heap Properties ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
REFERENCES
[1]2017. FindBugs Static Analyzer. https://github.com/findbugsproject/findbugs.
(2017). Online; accessed 26 August 2017.
[2]2017. Google Error-prone bug-fixing commit. https://github.com/google/
error-prone/commit/3709338. (2017). Online; accessed 16 January 2017.
[3]2017. Infer bug types. http://fbinfer.com/docs/infer-bug-types.html. (2017).
Online; accessed 11 May 2017.
[4]2017. Infer experimental checkers. http://fbinfer.com/docs/
experimental-checkers.html. (2017). Online; accessed 11 May 2017.
[5]2017. Infer Static Analyzer. http://fbinfer.com/. (2017). Online; accessed 11 May
2017.
[6]2017. Resource Leak in C. http://fbinfer.com/docs/infer-bug-types.html#
RESOURCE_LEAK. (2017). Online; accessed 16 January 2017.
[7]RuiAbreu,PeterZoeteweij,andArjanJ.C.vanGemund.2007.OntheAccuracyof
Spectrum-basedFaultLocalization.In Testing:AcademicandIndustrialConference
Practice and Research Techniques - MUTATION (TAICPART-MUTATION ’07). 89–
98.
[8]NathanielAyewah,DavidHovemeyer,J.DavidMorgenthaler,JohnPenix,and
William Pugh. 2008. Using Static Analysis to Find Bugs. IEEE Software 25, 5
(2008), 22–29.
[9]Titus Barik, Yoonki Song, Brittany Johnson, and Emerson R. Murphy-Hill. 2016.
From Quick Fixes to Slow Fixes: Reimagining Static Analysis Resolutions to
EnableDesignSpaceExploration.In IEEEInternationalConferenceonSoftware
Maintenance and Evolution (ICSME ’16). IEEE Computer Society, 211–221.
[10]JBerdine,CCalcagno,andPeterWO’Hearn.2005. Smallfoot:ModularAutomatic
AssertionCheckingwithSeparationLogic.In FormalMethodsforComponents
and Objects (FMCO ’05). 115–137.
[11]JoshBerdine,CristianoCalcagno,andPeterWO’hearn.2005.SymbolicExecution
with Separation Logic. In Asian Symposium on Programming Languages and
Systems (APLAS ’05). 52–68.
[12]Josh Berdine, Cristiano Calcagno, and Peter W. O’Hearn. 2012. Verification
Condition Generation and Variable Conditions in Smallfoot. CoRRabs/1204.4804
(2012).
[13]JoshBerdine,ArlenCox,SaminIshtiaq,andChristophM.Wintersteiger.2012.
DiagnosingAbstractionFailureforSeparationLogic-BasedAnalyses.In Computer
Aided Verification (CAV ’12) . 155–173.
[14]AlBessey,KenBlock,BenChelf,AndyChou,BryanFulton,SethHallem,Charles
Henri-Gros, Asya Kamsky, Scott McPeak, and Dawson Engler. 2010. A Few
BillionLines ofCode Later:UsingStatic AnalysistoFind Bugsinthe RealWorld.
Commun. ACM 53, 2 (Feb. 2010), 66–75.
[15]TomBritton,LisaJeng,GrahamCarver,PaulCheak,andTomerKatzenellenbogen.
2013.Reversible Debugging Software . Technical Report. University of Cambridge,
Judge Business School.
[16]Cristiano Calcagno and Dino Distefano. 2011. Infer: An Automatic Program
VerifierforMemorySafetyofCPrograms.In NASAFormalMethods (NFM’11).
459–465.
[17]Cristiano Calcagno, Dino Distefano, Jérémy Dubreil, Dominik Gabi, Pieter
Hooimeijer,MartinoLuca,PeterW.O’Hearn,IrenePapakonstantinou,JimPur-
brick,andDulmaRodriguez.2015. MovingFastwithSoftwareVerification.In
NASA Formal Methods (NFM ’15). 3–11.
[18]CristianoCalcagno,DinoDistefano,PeterW.O’Hearn,andHongseokYang.2011.
CompositionalShapeAnalysisbyMeansofBi-Abduction. J.ACM58,6(2011),
26:1–26:66.
[19]Loris D’Antoni, Roopsha Samanta, and Rishabh Singh. 2016. Qlose: Program
RepairwithQuantitativeObjectives.In ComputerAidedVerification (CAV’16).
383–401.
[20]DinoDistefanoandIvanaFilipovic.2010. MemoryLeaksDetectioninJavabyBi-
abductive Inference. In Fundamental Approaches to Software Engineering (FASE).
278–292.
[21]Dino Distefano, Peter W O’Hearn, and Hongseok Yang. 2006. A Local Shape
Analysis Based on Separation Logic. In International Conference on Tools and
Algorithms for the Construction and Analysis of Systems. 287–302.
[22]Dino Distefano and Matthew J Parkinson J. 2008. jStar: Towards Practical Verifi-
cation for Java. ACM Sigplan Notices 43, 10 (2008), 213–226.
[23]Divya Gopinath, Muhammad Zubair Malik, and Sarfraz Khurshid. 2011.
Specification-Based Program Repair Using SAT. In Tools and Algorithms for
the Construction and Analysis of Systems (TACAS ’11). 173–188.
[24]Andreas Griesmayer, Roderick Bloem, and Byron Cook. 2006. Repair of Boolean
ProgramswithanApplicationtoC. ComputerAidedVerification (2006),358–371.
[25]CieraJaspan,I-ChinChen,andAnoopSharma.2007. UnderstandingtheValueofProgramAnalysisTools.In Object-orientedProgrammingSystemsandApplications
(OOPSLA ’07). 963–970.
[26]BarbaraJobstmann,AndreasGriesmayer,andRoderickBloem.2005. Program
Repair as a Game. In Computer Aided Verification (CAV ’05). 226–238.
[27]Brittany Johnson, Yoonki Song, Emerson Murphy-Hill, and Robert Bowdidge.
2013. WhyDon’tSoftwareDevelopersUseStaticAnalysisToolstoFindBugs?.
InInternational Conference on Software Engineering (ICSE ’13) . 672–681.[28]René Just, Darioush Jalali, and Michael D Ernst. 2014. Defects4J: A Database
of Existing Faults to Enable Controlled Testing Studies for Java Programs. In
International Symposium on Software Testing and Analysis (ISSTA ’14). 437–440.
[29]Yalin Ke, Kathryn T. Stolee, Claire Le Goues, and Yuriy Brun. 2016. Repairing
Programs with Semantic Code Search. In International Conference on Automated
Software Engineering (ASE ’15). 295–306.
[30]EtienneKneuss,ManosKoukoutos,andViktorKuncak.2015. DeductiveProgram
Repair. In Computer Aided Verification (CAV ’15). 217–233.
[31]Xuan Bach D Le, David Lo, and Claire Le Goues. 2016. History Driven Program
Repair. In Software Analysis, Evolution, and Reengineering (SANER ’16). 213–224.
[32]Xuan-Bach D. Le, David Lo, and Claire Le Goues. 2016. History Driven Program
Repair. In Software Analysis, Evolution, and Reengineering (SANER ’16). 213–224.
[33]ClaireLeGoues,MichaelDewey-Vogt,StephanieForrest,andWestleyWeimer.
2012. A Systematic Study of Automated Program Repair: Fixing 55 out of 105
Bugs for $8 Each. In International Conference on Software Engineering (ICSE ’12).
3–13.
[34]BenjaminLivshits,ManuSridharan,YannisSmaragdakis,OndrejLhoták,JoséNel-
sonAmaral,Bor-YuhEvanChang,SamuelZ.Guyer,UdayP.Khedker,Anders
Møller,andDimitriosVardoulakis.2015. Indefenseofsoundiness:amanifesto.
Commun. ACM 58, 2 (2015), 44–46.
[35]Francesco Logozzo and Thomas Ball. 2012. Modular and Verified Automatic Pro-
gram Repair. In Conference on Object-Oriented Programming, Systems, Languages,
and Applications (OOPSLA ’12). 133–146.
[36]Fan Long and Martin Rinard. 2016. Automatic Patch Generation by Learning
Correct Code. In Principles of Programming Languages (POPL ’16). 298–31.
[37]Fan Long and Martin C. Rinard. 2016. An Analysis of the Search Spaces for
Generate and Validate Patch Generation Systems. In International Conference on
Software Engineering (ICSE ’16). 702–713.
[38]SergeyMechtaev,JooyongYi,andAbhikRoychoudhury.2015. DirectFix:Looking
for Simple Program Repairs. In International Conference on Software Engineering
(ICSE ’15). 448–458.
[39]Sergey Mechtaev, Jooyong Yi, and Abhik Roychoudhury. 2016. Angelix: Scal-
ableMultilineProgramPatchSynthesisviaSymbolicAnalysis.In International
Conference on Software Engineering (ICSE ’16). 691–701.
[40]Nicholas Nethercote and Julian Seward. 2003. Valgrind: A Program Supervision
Framework. Electronic notes in Theoretical Computer Science 89, 2 (2003), 44–66.
[41]Hoang Duong Thien Nguyen, Dawei Qi, Abhik Roychoudhury, and Satish Chan-
dra.2013.SemFix:ProgramRepairviaSemanticAnalysis. InternationalConference
on Software Engineering, 772–781.
[42]Huu Hai Nguyen, Cristina David, Shengchao Qin, and Wei-Ngan Chin. 2007.
Automated Verification of Shape and Size Properties via Separation Logic. In
InternationalWorkshoponVerification,ModelChecking,andAbstractInterpretation
(VMCAI ’07). 251–266.
[43]NationalInstituteofStandardsandTechnology.2002. TheEconomicImpactsof
InadequateInfrastructureforSoftwareTesting. TechnicalReportNISTPlanning
Report 02-3. NIST. http://www.nist.gov/director/prog-ofc/report02-3.pdf
[44]Peter O’Hearn. 2007. Resources, Concurrency, and Local Reasoning. Theoretical
Computer Science 375, 1-3 (2007), 271–307.
[45]Peter W. O’Hearn. 2015. From Categorical Logic to Facebook Engineering. In
Symposium on Logic in Computer Science. 17–20.
[46]PeterW.O’Hearn,JohnC.Reynolds,andHongseokYang.2001. LocalReasoning
aboutProgramsthatAlterDataStructures.In InternationalWorkshoponComputer
Science Logic (CSL ’01). 1–19.
[47]Matthew J. Parkinson and Gavin M. Bierman. 2005. Separation Logic and Ab-
straction. In Symposium on Principles of Programming Languages (POPL ’05).
247–258.
[48]Yu Pei, Carlo A. Furia, Martin Nordio, Yi Wei, Bertrand Meyer, and Andreas
Zeller.2014. AutomatedFixingofProgramswithContracts. IEEETransactions
on Software Engineering 40, 5 (2014), 427–449.
[49]Jeff H Perkins, Sunghun Kim, Sam Larsen, Saman Amarasinghe, Jonathan
Bachrach, Michael Carbin, Carlos Pacheco, Frank Sherwood, Stelios Sidiroglou,
Greg Sullivan,et al.2009. AutomaticallyPatching Errorsin DeployedSoftware.
InSymposium on Operating Systems Principles (SIGOPS ’09) . 87–102.
[50]Yuhua Qi, Xiaoguang Mao, Yan Lei, Ziying Dai, and Chengsong Wang. 2014.
The Strength of Random Search on Automated Program Repair. In International
Conference on Software Engineering (ICSE) . 254–265.
[51]Zichao Qi, Fan Long, Sara Achour, and Martin Rinard. 2015. An Analysis of
Patch Plausibilityand Correctness for Generate-and-validatePatch Generation
Systems.In InternationalSymposiumonSoftwareTestingandAnalysis (ISSTA’15).
24–36.
[52]Roopsha Samanta, Oswaldo Olivo, and E Allen Emerson. 2014. Cost-Aware
Automatic Program Repair. In Static Analysis Symposium (SAS ’14). 268–284.
[53]Edward K. Smith, Earl T. Barr, Claire Le Goues, and Yuriy Brun. 2015. Is the
CureWorsethantheDisease?OverfittinginAutomatedProgramRepair.In Joint
Meeting on Foundations of Software Engineering (ESEC/FSE ’15). 532–543.
[54]Edward K Smith, Earl T Barr, Claire Le Goues, and Yuriy Brun. 2015. Is the
CureWorsethantheDisease?OverfittinginAutomatedProgramRepair.In Joint
Meetingof theEuropeanSoftwareEngineering ConferenceandtheSymposium on
the Foundations of Software Engineering (ESEC/FSE ’15). 532–543.
161
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:50:07 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Rijnard van Tonder and Claire Le Goues
[55] Zhaopeng Tu, Zhendong Su, and Premkumar Devanbu. 2014. On the Localness
of Software. In Foundations of Software Engineering (FSE 2014). 269–280.
[56]Christian von Essen and Barbara Jobstmann. 2015. Program Repair without
Regret.Formal Methods in System Design 47, 1 (2015), 26–50.
[57]WestleyWeimer.2006. PatchesAsBetterBugReports.In GenerativeProgramming
and Component Engineering (GPCE ’06). 181–190.
[58]WestleyWeimer,ZacharyPFry,andStephanieForrest.2013. LeveragingProgram
EquivalenceforAdaptiveProgramRepair:ModelsandFirstResults.In Automated
Software Engineering (ASE ’13). 356–366.
[59]WestleyWeimerandGeorgeC.Necula.2005. MiningTemporalSpecifications
for Error Detection. In Tools and Algorithms for the Construction and Analysis ofSystems (TACAS ’05). 461–476.
[60]WestleyWeimerandGeorgeC.Necula.2008. ExceptionalSituationsandProgram
Reliability. ACM Transactions on Programming Languages and Systems 30, 2,
Article 8 (March 2008), 51 pages.
[61]JifengXuan,MatiasMartinez,FavioDemarco,MaximeClément,SebastianLame-
las Marcote, Thomas Durieux, Daniel Le Berre, and Martin Monperrus. 2017.
Nopol: Automatic Repair of Conditional Statement Bugs in Java Programs. IEEE
Transactions on Software Engineering 43, 1 (2017), 34–55.
[62]Hongseok Yang and Peter O’Hearn. 2002. A Semantic Basis for Local Reasoning.
InInternationalConferenceonFoundationsofSoftwareScienceandComputation
Structures (FoSSaCS). 402–416.
162
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:50:07 UTC from IEEE Xplore.  Restrictions apply. 