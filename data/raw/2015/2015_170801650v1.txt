BDCI: Behavioral Driven Conflict Identification
Fabrizio Pastore, Leonardo Mariani, Daniela Micucci
University of Milano-Bicocca, DISCo
Milan, Italy
{pastore,mariani,micucci}@disco.unimib.it
ABSTRACT
Source Code Management (SCM) systems support software evolu-
tion by providing features, such as version control,
branching, and conflict detection. Despite the presence of these
features, support to parallel software development is often lim-
ited. SCM systems can only address a subset of the conflicts that
might be introduced by developers when concurrently working on
multiple parallel branches. In fact, SCM systems can detect textual
conflicts , which are generated by the concurrent modification of the
same program locations, but they are unable to detect higher-order
conflicts, which are generated by the concurrent modification of
different program locations that generate program misbehaviors
once merged. Higher-order conflicts are painful to detect and ex-
pensive to fix because they might be originated by the interference
of apparently unrelated changes.
In this paper we present Behavioral Driven Conflict Identifica-
tion (BDCI), a novel approach to conflict detection. BDCI moves
the analysis of conflicts from the source code level to the level of
program behavior by generating and comparing behavioral models.
The analysis based on behavioral models can reveal interfering
changes as soon as they are introduced in the SCM system, even if
they do not introduce any textual conflict.
To evaluate the effectiveness and the cost of the proposed ap-
proach, we developed BDCI f, a specific instance of BDCI dedicated
to the detection of higher-order conflicts related to the functional
behavior of a program. The evidence collected by analyzing multiple
versions of Git and Redis suggests that BDCI fcan effectively detect
higher-order conflicts and report how changes might interfere.
CCS CONCEPTS
•Software and its engineering →Software configuration man-
agement and version control systems ;Software verification and
validation ; Collaboration in software development;
KEYWORDS
Software evolution, conflict detection, specification mining, testing.
This work has been partially supported by the H2020 Learn project, which has been
funded under the ERC Consolidator Grant 2014 program (ERC Grant Agreement n.
646867).
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
ESEC/FSE’17, September 4–8, 2017, Paderborn, Germany
©2017 Copyright held by the owner/author(s). Publication rights licensed to Associa-
tion for Computing Machinery.
ACM ISBN 978-1-4503-5105-8/17/09. . . $15.00
https://doi.org/10.1145/3106237.3106296ACM Reference Format:
Fabrizio Pastore, Leonardo Mariani, Daniela Micucci. 2017. BDCI: Behavioral
Driven Conflict Identification. In Proceedings of 2017 11th Joint Meeting of the
European Software Engineering Conference and the ACM SIGSOFT Symposium
on the Foundations of Software Engineering, Paderborn, Germany, September
4–8, 2017 (ESEC/FSE’17), 12 pages.
https://doi.org/10.1145/3106237.3106296
1 INTRODUCTION
Software development often requires working with multiple ver-
sions and multiple development branches in parallel [ 38]. For exam-
ple, developers may need to implement a bug fix without interrupt-
ing the development of new features. This is often done by creating
a new development branch dedicated to bug fixing, which is later
merged with the main branch. The use of the branching logic gives
flexibility to developers, but also introduces issues. In particular,
merge operations might be extremely painful due to any conflicting
and interfering changes that need to be correctly managed in the
merged version. For instance, Brun et al. reported that 24% of merge
operations in open source projects generate textual conflicts, build
problems, and test failures [ 12]; Kasi et al. analyzed four popular
open source projects hosted on GitHub and concluded that conflicts
occur regularly, with a frequency ranging from 34% to 54% of the
merge operations [ 27]; Microsoft developers reported that most of
the time dedicated to merge operations is spent on resolving con-
flicts and verifying correctness [ 8]. The relevance of the problem
is further confirmed by the results of a recent survey conducted
internally to Microsoft, which indicates that novel solutions for
conflict detection and resolution are perceived as extremely useful
in practice [29].
Source Code Management (SCM) systems support developers
during their activity providing features such as version control,
branching, and conflict detection [16, 19, 38]. When two branches
are merged, SCM systems can detect and report textual conflicts , that
is, changes occurring in different branches but targeting the same
locations in the source files. Since resolving these conflicts might
require significant effort, especially when done after many changes
have been accumulated on the individual branches [ 9], workspace
awareness has been investigated as a possible solution [ 3,7,15,17].
The key idea is to make developers aware of the ongoing changes
implemented by the other developers in their workspaces so that
they can timely react in case of potential textual conflicts.
These techniques are useful but are limited to textual conflicts
and cannot detect higher-order conflicts [6,11]. A higher-order
conflict takes place when merging two program versions in two
different branches produces a faulty program without causing any
textual conflict [ 6,11,12,24,31]. This happens when changes af-
fecting different program locations interfere. For example, if two
developers independently modify the implementation of a programarXiv:1708.01650v1  [cs.SE]  4 Aug 2017ESEC/FSE’17, September 4–8, 2017, Paderborn, Germany Fabrizio Pastore, Leonardo Mariani, Daniela Micucci
for sorting the items in a collection by changing the type of ele-
ments that can be added to the collection in one case, and changing
the sorting algorithm in the other case, the two changes, although
targeting different areas of the code, might not integrate well. This
may occur because the new version of the sorting algorithm might
be unable to properly sort the new types of items that can be added
to the collection. These cases are particularly hard to detect because
cannot be recognized by simply considering the changed lines of
code, but it is necessary to take into account the semantics of the
program.
Detecting and resolving higher-order conflicts is painful and
time consuming on one side [ 24], but also extremely actual and
important on the other, due to the increasing popularity of modern
SCM systems1, such as Git [ 18], that encourage the use of the
branching logic, and thus facilitate the introduction of both textual
and higher-order conflicts.
Some approaches address higher-order conflicts by enriching
workspaces with the capability to report concurrent changes to de-
pendent artifacts, such as changes to related classes [ 13,23,42,43].
These techniques may facilitate the detection of higher-order con-
flicts, but require developers to manually check all the reported
changes to determine if they generate any actual higher-order con-
flict. Moreover, reporting to users any potential conflict, even result-
ing from indirect dependencies, may generate many false alarms,
while reporting potential conflicts resulting only from direct depen-
dencies may miss several higher-order conflicts.
Speculative merging has been proposed to mitigate these issues
and more efficiently address higher-order conflicts [ 11,12,21]. The
underlying assumption is that interfering changes should result in
test failures. Thus, to detect higher-order conflicts, the code in the
developers’ workspaces is merged locally with the code extracted
from other parallel development branches and then locally built
and tested.
Speculative merging extensively uses the resources in the devel-
opers’ machines for the merge, build, and test operations and its
effectiveness depends on the fault-detection capability of the test
cases. A poor or limited set of tests and assertions might severely
limit its effectiveness. Moreover, when a test failure is reported,
developers still have to manually inspect the concurrent changes
to understand how they interfere, and this might be expensive for
non-trivial changes. Online continuous integration systems, such
as Travis [ 44], provide speculative merging as a service, thus elimi-
nating the problems related to the consumption of computational
resources on developers’ machines. However, except for resource
consumption, these systems are still affected by the same limitation
than speculative merging, that is, its capability to detect higher-
order conflicts depends on the number and extensiveness of the
checks (e.g., the assertions) implemented in the test cases.
In this paper we present Behavioral Driven Conflict Identification
(BDCI), a multi-branch server-side dynamic analysis technique that
detects higher-order conflicts in parallel development branches by
explicitly deriving and analyzing a representation of the program
behavior . The key idea is that by implementing conflict detection at
the level of the program behavior, it is possible to detect interfering
1According to recent surveys, 62% of the Debian projects use modern SCM envi-
ronments [ 47], and 40% of the medium and large enterprises surveyed in [ 35] use
Git.changes at the place where the interference can be observed , regardless
the place where the changes have been implemented. For instance,
changes to apparently unrelated classes may cause interference in
a same program location. This interference might be hard to detect
by looking at program dependencies, but it is easy to detect when
looking at the program behavior because both code changes would
affect exactly the same behavior.
BDCI leverages specification mining [ 14,30] to automatically
generate models that represent the behavior of the program, and
model analysis [ 33] to both determine how the behavior of the
program has changed along each branch and compare the mod-
ified behaviors to identify higher-order conflicts. The identified
higher-order conflicts are returned to developers as soon as they
are introduced in parallel branches, well before they produce mis-
behaviors in the merged version, allowing developers to timely
address conflicts when they are still easy to fix.
Since BDCI compares mined models to identify higher-order
conflicts, its effectiveness is not dependent on the assertions imple-
mented in the test cases, as in speculative merging, but it simply re-
quires the availability of some test inputs to run the program. Thus,
BDCI can even work with automatically generated test cases. More-
over, BDCI provides a richer output compared to state of the art
solutions. In fact, BDCI indicates how each change has affected the
behavior of the program, generating information useful to quickly
resolve higher-order conflicts. Finally, although this paper focuses
on the functional behavior of a program, the concept of analysis
defined in BDCI can be potentially exploited to investigate how
changes impact other classes of behaviors, such as performance or
security-related behaviors.
The empirical results obtained by analyzing multiple changes in
the Git and Redis open source projects show that BDCI can reveal
higher-order conflicts that cannot be detected with speculative
merging.
The main contributions of this paper are:
•The definition of BDCI, a novel and general approach to the
detection of higher-order conflicts.
•The definition of BDCI f, a specific instance of BDCI dedi-
cated to the detection of higher-order conflicts on the func-
tional behavior of a program.
•The release of a freely available implementation of
BDCI f, which can be downloaded from http://www.lta.disco.
unimib.it/tools/bdci .
•An empirical validation that provides evidence of the effec-
tiveness of BDCI f.
The paper is organized as follows. Section 2 introduces the BDCI
approach and presents BDCI f. Section 3 introduces a running ex-
ample. Section 4 describes how BDCI fgenerates models of the
functional behavior of a program. Section 5 presents how BDCI f
uses the generated models for the detection of higher-order con-
flicts. Section 6 presents the empirical results. Section 7 discusses
related work. Section 8 provides concluding remarks.
2 BDCI
BDCI raises conflict detection from the source code level , as done
in current SCM systems, to the behavioral level by deriving and
comparing models that represent the behavior of the software. TheBDCI: Behavioral Driven Conflict Identification ESEC/FSE’17, September 4–8, 2017, Paderborn, Germany
Branch1Branch2Branch3
code 
version 1code version 2
code version 5code version 3code version 4
Branch4
Branch1Branch2Branch3
behavioral 
model 
version 1behavioral model version 2
behavioral model version 5behavioral model version 3behavioral model version 4
Branch4
behavioral 
changesBranch1Branch2Branch3
behavioral 
model 
version 1behavioral model version 2
behavioral model version 5behavioral model version 3behavioral model version 4
Branch4
higher-order conflicts + 
info about the behaviors 
responsible for the conflictPhase 1 
Model GenerationPhase 2 
Model Analysis
Figure 1: The BDCI approach.
way BDCI analyzes behavioral changes is similar to the way source
code changes are handled by regular SCM systems. A commit oper-
ation may introduce some changes that modify the behavior of the
software, thus causing changes in the behavioral models. Changes
introduced in parallel development branches can hence be com-
pared according to their effect on the models. In particular, if the
changes introduced in two parallel development branches affect
the same behaviors in the models, the developers will likely expe-
rience an interference once the code in these branches is merged.
BDCI timely detects and signals these dangerous situations to the
developers by analyzing the behavior of parallel software versions.
The BDCI approach consists of two phases, the model gener-
ation phase and the model analysis phase. These two phases are
executed sequentially and might be activated according to different
strategies. For instance, they can be executed after a new version is
committed to the SCM system, to detect higher-order conflicts be-
tween the committed version and the other versions in the parallel
development branches, after a pull-request or a merge operation , to
detect conflicts between the changes accumulated in two specific
branches (pull-requests and merges are the operations typically
used to merge contributions from different developers), or every
night , to detect conflicts among the versions committed during the
day and the ones in the other parallel branches.
Figure 1 shows the BDCI approach applied to a software system
developed along four different branches created from a common
base version.
In the model generation phase , BDCI mines the models useful to
detect higher-order conflicts using a specification mining solution.
Depending on the aspect that is investigated, these models could
target a specific class of program behaviors. For instance, models
may potentially represent the functional behavior, the performance,
the security-related behavior of an application, or a combination of
them. BDCI generates behavioral models for all the versions that
must be compared and analyzed, that is, the base version (version 1
in Figure 1) and the latest versions on the parallel branches (versions
2 to 5 in Figure 1).
In the model analysis phase , BDCI identifies behavioral changes
and higher-order conflicts relying on the models obtained in the
model generation phase. In particular, BDCI first identifies behav-
ioral changes by comparing the model of the base version to the
models of the versions in the parallel branches. BDCI then detects
higher-order conflicts by identifying the parallel branches that
modified the same behaviors. Figure 1 shows the comparisons per-
formed between version 5 and the versions in the other parallel
branches.Model analysis naturally detects changes that interfere according
to the aspect represented in the models. If the models represent the
functional, performance, or security behavior of the application,
the higher-order conflicts will consequentially target the functional,
performance, or security behavior of the application, respectively.
In addition to reporting the presence of higher-order conflicts,
BDCI reports information about the program behaviors responsible
for the conflict. Note that interfering changes may often produce
observable effects in program locations that are different from the
places where the code has been modified. BDCI always returns
information about the higher-order conflicts by referring to the
locations where they produce observable effects that can be exploited
by developers to drive the conflict resolution process.
In this paper we focus on detecting higher-order conflicts related
to the functional behavior of a program. In particular, we show how
BDCI can be used to discover interfering changes that may result
in annoying functional faults when merged into a same program
version. This specific instance of BDCI is called BDCI f. Hereafter,
we will use the term BDCI when describing general aspects, and
the term BDCI fwhen referring to the specific instance of BDCI
for detecting higher-order conflicts in the functional behavior of a
program.
To capture the functional behavior of an application,
BDCI ffocuses on function pre- and post-conditions. In particular,
BDCI fuses the Daikon specification mining technique to discover
properties that represent the values that can be assigned to function
parameters [ 14], and the Z3 theorem prover to identify changes
and conflicts between sets of properties associated with different
program versions [ 33]. Hereafter, we will interchangeably use the
terms models and properties, because program properties, and in
particular pre- and post-conditions, are the kind of models derived
by BDCI f.
Figure 2 graphically illustrates how BDCI fworks, with specific
reference to a software project with four parallel development
branches all created from the same base version, version 1. We
present BDCI fconsidering the case it is executed after a commit
operation. When executed after a pull-request or overnight, BDCI f
simply runs the described analysis on all the relevant program
versions. We suppose version 5 is the latest version committed
to the SCM system. For simplicity, we present the analysis only
considering one property about the parameter port .
In the model generation phase , BDCI fuses Daikon to derive
properties for both the version under analysis (version 5 in the
example) and the latest versions available in the other parallel
branches (versions 2, 3, and 4 in the example).ESEC/FSE’17, September 4–8, 2017, Paderborn, Germany Fabrizio Pastore, Leonardo Mariani, Daniela Micucci
Branch1Branch2Branch3
version 1version 2
version 5version 3
port>0version 4
port ≥2Branch4
port>1port>0port ≥0
Higher-Order Conflict Detection for Version 5:
version 5Behavioral Changes (with respect to version 1):
version 2
port>0         port>1version 3
No changeversion 4
port>0         port ≥2version 5
port>0         port ≥0
Legend
Changed intoPhase 1: Model Generation Phase 2: Model Analysis
version 5 vs 2
port>1
behavioral
changeversion 2
port>0
no 
behavioral 
change
no conflict
(refactoring on version 2)version 5version 5 vs 3
port>1
behavioral
changeversion 3
port ≥0
behavioral 
change
higher-order conflict
(non-equivalent  changes)version 5version 5 vs 4
port>1
behavioral
changeversion 4
port ≥2
behavioral 
change
no conflict
(equivalent changes)Legend
Mined by 
Daikon 
Figure 2: The BDCI fapproach.
BDCI falso derives properties for version 1, which is the latest
common ancestor version of the compared versions. This is neces-
sary because BDCI freveals higher-order conflicts by comparing the
program properties changed in version 5 to the properties changed
in versions 2, 3, and 4, one at time. The set of changes relevant
to a comparison between two program versions in two different
branches consists of all the changes that have been accumulated on
the individual branches. The effect of these changes on the behavior
of the application can be determined by comparing the properties
mined for the versions under analysis to the properties mined for
their latest common ancestor version. Since in the example all the
versions are obtained from version 1, version 1 is the latest common
ancestor version.
The left side of Figure 2 shows the four branches, the five pro-
gram versions, and the properties derived for parameter port . Since
Daikon mines program properties from traces collected during tests
execution, we assume that test cases are available under the SCM
system.
In the model analysis phase , represented on the right side of
Figure 2, BDCI ffirst determines the behavioral changes and then
identifies the higher-order conflicts. To determine the behavioral
changes, BDCI fcompares the properties derived for each program
version in the parallel branches, versions 2 to 5 in the example,
to the properties derived for the latest common ancestor version,
version 1 in the example. The top-right side of Figure 2 shows
the behavioral changes identified by BDCI f. Only the changes in
version 2 do not affect the property port>0, which holds both in
version 1 and version 2 (this may happen for example in the case
of pure refactorings).
A higher-order conflict occurs when the same property is changed
in two different parallel branches. To discover if version 5 intro-
duced a higher-order conflict, BDCI fcompares the behavioral
changes introduced in version 5 to the behavioral changes in the
other parallel branches. The right-bottom part of Figure 2 reports
the outcome of the comparison of version 5 to versions 2, 3, and 4.The comparison between version 5 and version 2 reports no
conflicts because the property has been changed in a branch only,
while the parallel modification of a same behavior is necessary for
the generation of a higher-order conflict.
Since version 5 and version 4 are characterized by parallel changes
that affect the same property in the same way, that is, they lead to
new properties that are equivalent, the comparison between these
two versions does not produce any conflict. In our empirical experi-
ence, we observed this case several times. The most frequent reason
for parallel and equivalent changes is the deployment of a same
patch to a critical fault on all the active development branches.
Finally, a higher-order conflict is reported by the comparison
between version 5 and version 3. The changes in version 5 modify
the values that can be assigned to parameter port from port>0to
port>1. While the changes in version 3 modify the values that can
be assigned to parameter port from port>0toport≥0. Changes in
versions 5 and 3 could thus interfere on variable port and generate
unpredictable results once merged. BDCI automatically identifies
and reports this dangerous situation.
3 RUNNING EXAMPLE
To illustrate BDCI fwe use the simple example of higher-order
conflict shown in Figure 3. The example consists of three program
versions: the Base Version , and two derived versions, Version 1 and
Version 2 , implemented in two parallel development branches. Both
Version 1 and Version 2 are derived from the Base Version, which
represents their latest common ancestor version.
The Base Version is composed of three C functions. The
getSaving function takes a price per unit, a quantity , and a
discount as parameters and computes the money saved thanks
to the discount. Some operations are delegated to auxiliary func-
tions. The getTotalPrice function computes the total price (in
cents) for the considered quantity of items taxes included. The
getDiscountedPrice applies the discount rate to the total price.
Version 1 implements a new policy for the discount, that is, the
discount is applied only if the price of the items is higher than 1000BDCI: Behavioral Driven Conflict Identification ESEC/FSE’17, September 4–8, 2017, Paderborn, Germany
int discount = 10;
int getTotalPrice(int price, int quantity) {  int totalPriceWithoutVat = price * quantity;  int vat = 10;  return totalPriceWithoutVat + ((totalPriceWithoutVat * vat) / 100);}
int getDiscountedPrice(int price) {     return price - ((price * discount) / 100);}
int getSaving(int price, int quantity) {     int totalPrice = getTotalPrice(price, quantity);     int discountedPrice = getDiscountedPrice(totalPrice);     return totalPrice - discountedPrice;}int discount = 10; 
int getTotalPrice(int price, int quantity) {   int totalPriceWithoutVat = price * quantity;   int vat = 10;   return totalPriceWithoutVat + ((totalPriceWithoutVat * vat) / 100);}
int getDiscountedPrice(int price) {//*** BEGIN CHANGE ***  if(price > 100)     return price - ((price * discount) / 100);  else return price;//***END CHANGE ***}int getSaving(int price, int quantity) {     int totalPrice = getTotalPrice(price, quantity);     int discountedPrice = getDiscountedPrice(totalPrice);     return totalPrice - discountedPrice;}int discount = 10; 
int getTotalPrice(int price, int quantity) {//*** BEGIN CHANGE ***       return price * quantity;//*** END CHANGE ***}
int getDiscountedPrice(int price) {   return price - ((price * discount) / 100);}
int getSaving(int price, int quantity) {   int totalPrice = getTotalPrice(price, quantity);   int discountedPrice = getDiscountedPrice(totalPrice);   return totalPrice - discountedPrice;}Base Version Version 1 (derived from Base Version)Version 2 (derived from Base Version)
Figure 3: An example of a higher-order conflict.
cents (i.e., 10 euros), taxes included. In Figure 3 the changed code is
the one between the comments *** BEGIN CHANGE *** and *** END
CHANGE *** .
Version 2 implements the new requirement of computing sav-
ings without considering taxes. Thus, the code that sums taxes to
the total price is removed from the getTotalPrice function. The
changed code is again indicated with *** BEGIN CHANGE *** and
*** END CHANGE *** .
Note that Version 1 and Version 2 are correct programs that
properly implement the respective requirements. Also note that
the two parallel changes considered in the example target different
functions, and thus do not produce any textual conflict when Ver-
sion 1 and Version 2 are merged together (the functions could even
be in different files). However, merging Version 1 with Version 2
does not produce a correct program. The merged version would
apply the discount to prices with a value greater than 1000 taxes ex-
cluded, while the requirement specifies that taxes must be included
in the computation. Merging these two programs requires adapting
the condition in the getDiscountedPrice function to work with
prices that do not include taxes.
A regular SCM system would merge Version 1 and Version 2
without generating any conflict. A continuous integration system
running regression test cases, as well as speculative merging [ 11,12,
21], could reveal the problem in the merged version only if the test
cases (1) cover the faulty situation and (2) include proper oracles
that can detect the effect of the higher-order conflict, and only
after the code has been merged. In the next sections, we show how
BDCI fcould report this higher-order conflict to the developers
as soon as Version 1 and Version 2 have been created and before
they are merged. Compared to speculative merging, BDCI fonly
requires the existence of test cases covering the change without
requiring any oracle in the test case. For this reason, contrarily to
speculative merging, if test cases that cover the changes are not
present in the program test suite, BDCI fcan straightforwardly
work with automatically generated test cases.4 MODEL GENERATION
In the model generation phase, BDCI generates behavioral models
for all the program versions that must be compared during the
analysis phase. Depending on the policy used to execute BDCI,
the set of program versions that must be compared might slightly
change. For instance, when executed after a pull-request, BDCI
compares the latest program versions available in the branches that
must be merged, and when executed overnight, BDCI compares the
latest program versions available in all the active branches.
In every case, BDCI compares pairs of versions. For this reason,
this section and the next section present BDCI fby describing how
it compares Version 1 to Version 2 for the example program shown
in Figure 3. The general case where multiple versions are compared
can be obtained by iteratively comparing pairs of versions.
BDCI fuses Daikon as model generator [ 14]. Daikon generates
Boolean expressions that represent the values that can be assigned
to program variables. It takes a set of variable values observed
at a given program point as input, and outputs a set of program
properties that hold at the same program point. For instance, if the
getTotalPrice function is executed multiple times with a positive
price and a positive quantity , Daikon can mine that its return
value is always positive. In order to obtain the samples necessary to
run Daikon, BDCI fassumes test cases are available under the SCM
system, which is a standard practice in version control, especially
when a SCM system is equipped with continuous integration capa-
bilities [ 32,44]. In the model generation phase, BDCI fbuilds the
system, runs the test cases, collects the values assigned to program
variables at several program points, and invokes Daikon to obtain
the program properties.
Generating properties for every program location in the code
requires collecting and processing a huge amount of data, and this
is not feasible for non-trivial programs. To restrict the focus of
the analysis, BDCI fexploits the knowledge of the changes imple-
mented in each branch. In particular, it automatically determines
the functions that have been modified by running the Unix diff pro-
gram [ 28] against the compared versions and their latest common
ancestor version.
As monitoring points, BDCI fselects all the functions that might
be directly influenced by the identified changes. More precisely,ESEC/FSE’17, September 4–8, 2017, Paderborn, Germany Fabrizio Pastore, Leonardo Mariani, Daniela Micucci
BDCI fcollects data from the entry points and the exit points of all
the functions that include modified statements, the callers and the
callees of these functions. This simple criterion can be computed
efficiently, guarantees the selection of a reasonably small set of
program points, and focuses the analysis on the program locations
that are likely to be affected by the changes. In principle, more
sophisticated techniques could be used to select monitoring points,
such as program slicing techniques [ 45]. However, we preferred
to design a technique that is simple, fast, and returns a small set
of observation points, rather than a technique that might return
a large list of program locations that might make the analysis too
expensive or even infeasible.
BDCI fconsiders entry and exit points to focus on function pre-
and post-conditions, which are expected to have a quite stable
behavior across versions, and ignores the body of functions where
extensive changes might easily occur. The functions with a changed
signature are not compared directly, but are compared using the
callers and callees of these functions as observation points.
In the running example, BDCI fcollects data about the
getDiscountedPrice , because its body has been modified in Ver-
sion 1, the getTotalPrice function, because its body has been mod-
ified in Version 2, and the getSaving function, because it invokes
the modified functions. The same three functions are monitored in
the Base Version, Version 1, and Version 2.
BDCI fbuilds all program versions relevant to the analysis (in
the example, the Base Version, Version 1, and Version 2) and runs
the tests available under SCM to collect data. Data collection is
performed by intercepting the execution at the entry and exit points
of the selected functions and logging the values of all the variables
in the scope of that locations.
Finally, BDCI fruns Daikon on the collected data to derive the
pre- and post-conditions. Table 1 reports the post-conditions that
BDCI fcan derive for the three monitored functions. The post-
conditions in Version 1 and Version 2 that differ from the Base
Version are reported in boldface with gray background. We omit
pre-conditions because they are not relevant to the discussion of the
running example. The label retindicates a function return value.
Table 1: Post-conditions of the monitored functions
Version getTotalPrice getDiscountedPrice getSaving
Base Version ret>price ret <price ret >10
Version 1 ret>price ret≤price ret≥0
Version 2 ret≥price ret<price ret≥10
5 MODEL ANALYSIS
The model analysis phase identifies higher-order conflicts by (1)
identifying the behavioral changes in the versions that must be
compared (Version 1 and Version 2 in the running example), and
then (2) determining if the compared versions have changed the
same behaviors .
To determine the behavioral changes, BDCI compares the models
derived for the versions under analysis against the model derived
for their latest common ancestor version. In the running example,
BDCI fchecks equivalence between the pre- and post-conditions
derived for the getTotalPrice , the getDiscountedPrice , and thegetSaving functions in Version 1 and 2, and the pre- and post-
conditions derived for the same functions in the Base Version.
According to the post-conditions reported in Table 1, the changes
in Version 1 affect the post-conditions of the getDiscountedPrice
and the getSaving functions. While the changes in Version 2 af-
fect the post-conditions of the getTotalPrice and the getSaving
functions.
To determine if changes generate any higher-order conflict,
BDCI fidentifies the pre- and post-conditions changed in both
versions. We call the set of these pre- and post-conditions the in-
terfering region . A non-empty interfering region may indicate the
presence of a higher-order conflict. In the running example, the
interfering region for Version 1 and Version 2 is not empty and
consists of the post-condition of function getSaving .
BDCI freports a higher-order conflict only in the case the two
versions behave differently, that is, when the two versions both
differ from the base version and differ from each other. To determine
if the interfering region indicates that the two software versions
behave differently, BDCI fchecks the equivalence of the pre- and
post-conditions in the interfering region. In the running example,
the post-conditions of function getSaving in Versions 1 and 2 are
not equivalent, and BDCI freturns a higher-order conflict.
Note that the knowledge of the changed properties represents a
useful information to fix the higher-order conflict. In this case, the
changed properties clearly show that: (1) the changes in Version
1 affect the computation of the discount (see the changed post-
condition of function getDiscountedPrice in Table 1), (2) the
changes in Version 2 affect the computation of the total cost (see
the changed post-condition of function getTotalCost in Table 1),
and (3) these two changes interfere with the computation of the
saving (see the two changed post-conditions of function getSaving
in Table 1). This is a valuable information for developers, who can
inspect the code directly pointing at the functions that originate the
conflict with the knowledge of how and where the changes interfere .
Finally, since higher-order conflicts can be identified as soon as
the two versions appear in the SCM system, before they are merged
together, developers can timely repair problems thus preventing the
risk of experiencing failures with the merged code where the effect
of multiple changes can significantly complicate failure analysis.
6 EMPIRICAL EVALUATION
In this section, we evaluate the effectiveness and the costof BDCI f.
We investigate the effectiveness by comparing BDCI fto state of
the art methods based on speculatively merging [ 10,11,20,21].
In particular, we performed two studies. The objective of the first
study is to investigate if BDCI fcan reveal real higher-order conflicts
that cannot be detected with speculative merging. To this end, we
analyzed 35 parallel changes in the Git [ 18] version history, and 10
parallel changes in the Redis [ 39] version history, for a total of 45
parallel changes analyzed. We found 7higher-order conflicts in Git
and 1 higher-order conflict in Redis that could not be revealed with
speculative merging due to the limited capability of the test cases
to detect behavioral changes.
To compare BDCI fand speculative merging not only on the
revealed higher-order conflicts but also on the missed higher-order
conflicts, we performed a second study. Since we do not knowBDCI: Behavioral Driven Conflict Identification ESEC/FSE’17, September 4–8, 2017, Paderborn, Germany
in advance all the higher-order conflicts present in third-party
software, we used conflicts injected in Git for this study. Results
show that the two approaches are complemental.
Finally, we investigate cost by reporting data about the runtime
cost of the technique.
In the following, we briefly describe our prototype implemen-
tation, we report the studies with injected and real higher-order
conflicts, and we conclude discussing threats to validity.
6.1 Prototype Implementation
Our prototype implementation targets C programs and consists of
two main components, the model generation component and the
model analysis component. The model generation component iden-
tifies the functions that must be monitored for a given set of changes
under analysis, implements the monitoring infrastructure for col-
lecting runtime data on top of both the RADAR framework [ 36,37]
and the PIN tool [ 25], and integrates Daikon [ 14] to generate func-
tions pre- and post-conditions.
The model analysis component implements the identification of
changed pre- and post-conditions, and integrates the Z3 theorem
prover [ 33] to check equivalence between properties. Our prototype
implementation and the rest of the experimental material can be
downloaded from http://www.lta.disco.unimib.it/tools/bdci .
6.2 Real Conflicts
To investigate how BDCI fperforms with real cases we analyzed
several parallel changes from the Git [ 18] and Redis [ 39] version
history. For our experiments we selected merges of non trivial
complexity (the changes in a branch must be distributed among
at least 10 different files) that do not include a major redesign of
the system (we limit to 500 the maximum number of functions
modified by the changes in a branch). For the Git case study we
selected all the merges with the above characteristics merged after
Sept. 2013, for the Redis case study we selected merges pushed to
the repository after Feb 2015. To avoid the analysis of unrelated
changes, we focused on changes that either target dependent code
(changes of statements that use and define the same variables) or
are followed by a fix commit. Some of the selected cases produced
either textual conflicts, which could be detected with standard
applications for version control, or test failures, which could be
detected with speculative merging. In addition to these cases, the
selected portion of the version history of the analyzed applications
included a total of 35 cases for Git and 10 cases for Redis, which
might potentially produce higher-order conflicts not detected with
state of the art techniques. We used these cases as benchmark for
BDCI fto evaluate its capability to detect higher-order conflicts
that could not be detected with speculative merging.
Table 2: Results with real higher-order conflicts
Application Parallel Changes HOC Returned Spurious HOC Actual HOC
Analyzed
Git 35 9 2 7
Redis 10 1 0 1
Total 45 10 2 8
Note that every selected case includes a large number of perva-
sive changes that must be analyzed with BDCI f. In fact, the averagenumber of functions that have been changed in two branches un-
der comparison is 162 with a maximum of 489 for Git, and 114
changed functions with a maximum of 301 for Redis. Although the
pervasiveness of the changes represents a challenging aspect for
techniques that compare program versions, BDCI fcoped well with
this magnitude of changes, as suggested by the results that have
been obtained.
We analyzed these 45 cases by running BDCI fwith the test
suites provided with the programs and we discovered a total of
10 higher-order conflicts that could not be detected by speculative
merging, as shown in Table 2. Out of the 10 higher-order conflicts, 2
conflicts were spurious anomalies. These conflicts could be quickly
discarded because caused by variables that can be legally assigned
with conflicting values in two distinct development branches. In
our case, the higher order conflict was caused by a file descriptor
variable that legally changed its value in two parallel branches. More
interestingly, we discovered 8 problematic higher-order conflicts,
7 in Git and 1 in Redis. To confirm the presence of a problem in
these 8 cases, we implemented a test case that covers the change
and passes when executed in the versions before the merge, but
fails after the merge operation. We thus confirmed that BDCI fhas
been able to discover 8 unknown higher-order conflicts out of the
45 merge operations that have been analyzed. We also manually
analyzed the rest of the changes without finding any additional
higher-order conflict, further confirming the accuracy of BDCI f.
To give evidence of the qualitative effectiveness of BDCI f, here
we briefly discuss the 8 higher-order conflicts that have been iden-
tified.
Five higher-order conflicts affect the functionality that prints the
content of the packets processed by Git to the standard output. The
changes in the two branches both affect the heading printed by the
function packet_trace . The merged version masks the effect of
the changes performed in one of the branches. BDCI fdetected this
interference from the pre-condition of function trace_strbuf_fl ,
which is used in packet_trace . A similar problem affects function
rdbCheckThenExit that is used by Redis to trace errors in the Redis
database management system.
Out of the two remaining higher-order conflicts, one affects
function get_wcwidth , which computes the length of a Unicode
character. The changes in the compared branches affect this func-
tion, producing an interference in the merged code. BDCI fcould
detect this problem from the pre-condition of function bisearch ,
which is used in get_wcwidth . The last higher-order conflict af-
fects functions cmd_clone andcheckout that present different post-
conditions in the three versions of the software. This behaviour
depends on changes in function wait_or_whine .
6.3 Injected Conflicts
To generate higher-order conflicts in a controlled way, we started
from two non-conflicting changes targeting depending code blocks
and located in two parallel branches in Git2, and we systematically
mutated one of these changes (i.e., the set of statements that can be
mutated is restricted to the statements changed in a branch) using
the Milu mutation testing tool [ 26]. Since mutations always alter
2For reference, the date and time of the Git versions that we used are 11/1/2006 13:57
and 11/1/2006 13:41.ESEC/FSE’17, September 4–8, 2017, Paderborn, Germany Fabrizio Pastore, Leonardo Mariani, Daniela Micucci
Table 3: Results with injected higher-order conflicts
Analyzed CaseGenerated Properties Changed Outcome
Base Version in Version in pre/post-conditions BDCI f Spec. Merge
Version Branch 1 Branch 2 Version in Version in Number of HOC HOC
(same/del/new) (same/del/new) Branch 1 Branch 2 Conflicts Detected Detected
Base case 156 158 (114/42/44) 156 (156/0/0) 13 0 0 - -
Case 1 (SSDL) 11 8 (7/4/1) 11 (11/0/0) 1 0 0 NO YES
Case 2 (OCNG) 29 16 (6/23/10) 29 (29/0/0) 6 0 0 NO YES
Case 3 (CRCR) 156 157 (110/46/47) 156 (156/0/0) 14 0 0 NO NO
Case 4 (CRCR) 29 17 (9/20/8) 29 (29/0/0) 6 0 0 NO YES
Case 5 (CRCR) 29 17 (9/20/8) 29 (29/0/0) 6 0 0 NO YES
Case 6 (SSDL) 137 126 (79/58/47) 137 (137/0/0) 12 0 0 NO YES
Case 7 (OCNG) 29 26 (24/5/2) 29 (29/0/0) 4 0 0 NO YES
Case 8 (CRCR) 156 157 (114/42/43) 156 (156/0/0) 13 0 0 NO YES
Case 9 (CRCR) 156 157 (114/42/43) 156 (156/0/0) 13 0 0 NO YES
Case 10 (CRCR) 156 157 (114/42/43) 156 (156/0/0) 13 0 0 NO NO
Case 11 (SSDL) 144 142 (107/37/35) 145 (138/6/7) 13 1 1 YES NO
Case 12 (CRCR) 156 157 (114/42/43) 158 (155/1/3) 13 2 2 YES NO
Case 13 (CRCR) 156 157 (114/42/43) 156 (155/1/1) 13 2 2 YES NO
Case 14 (CRCR) 156 157 (114/42/43) 158 (155/1/3) 13 2 2 YES NO
Case 15 (CRCR) 156 157 (114/42/43) 158 (155/1/3) 13 2 2 YES NO
Case 16 (CRCR) 156 157 (114/42/43) 156 (155/1/1) 13 2 2 YES NO
Case 17 (CRCR) 156 157 (114/42/43) 156 (155/1/1) 13 2 2 YES NO
Case 18 (CRCR) 156 158 (114/42/44) 158 (155/1/3) 13 2 2 YES NO
Case 19 (SSDL) 156 158 (114/42/44) 137 (129/27/8) 13 4 3 YES YES
Total 9 9
the statements already modified by a change, the mutated program
includes the same logical change than the original program, but with
a slightly modified semantics induced by the mutation. Of course,
not all the mutants result in a higher-order conflict. Sometimes
the mutation does not interfere with the changes implemented by
the version in the other parallel branch. We manually analyzed the
resulting mutants and after discarding equivalent, redundant, and
mutants that do not produce higher-order conflicts, we ended up
with a total of 19 cases, each consisting of two program versions
that include parallel changes that produce a higher-order conflict.
We analyzed all the cases using both BDCI fand speculative
merging. For BDCI f, we executed the analysis and collected data
about the generated properties and the detected higher-order con-
flicts. For speculative merging, we merged the two program ver-
sions, built the code, executed the test cases, and used test failures
as detectors of higher-order conflicts. Since no test case in the Git
test suite was designed to cover the changed statements, we used a
set of manually designed test cases that cover the changes in the
analyzed branches to run the program.
Table 3 shows the results that we obtained. Column Analyzed
Case lists the cases that have been analyzed. The first row represents
the base case with no mutation, and thus with no higher-order
conflicts. The successive rows list the 19 analyzed cases. Between
brackets we report the mutant operator that has generated the
case under analysis (see Agrawal et al. for a quick reference about
mutant acronyms [1]).
Column Generated Properties reports statistics about the number
of pre- and post-conditions that BDCI fhas generated for the Base
Version , and the versions in the two branches, distinguished as
Version in Branch 1 andVersion in Branch 2 . For the two compared
versions, we also report the number of unchanged ( same ), dropped
(del), and newly ( new) identified properties between brackets. Note
that these columns report data about the number of individual
properties that compose pre- and post-conditions.
Results show that BDCI fhas been able to derive hundreds of
properties about the values that can be assigned to program vari-
ables, intuitively suggesting that the mined models well cover thebehavior of the application for the selected functions. The effect
of the changes on these properties varies a lot, depending on the
nature of the change. The changes for the Version in Branch 1 signif-
icantly modify the values that can be assigned to program variables,
resulting in several properties that are dropped and newly mined.
The changes for the Version in Branch 2 mostly alter the execu-
tion flow, with little effect on function parameters, thus only few
properties are affected by the changes. In particular, no property
changes in cases from Case 1 to Case 10, and only few properties
change in cases from Case 11 to Case 19.
Column Changed pre/post-conditions indicates the number of pre-
and post-conditions that have been changed in each version. It is
possible to notice that BDCI fhas been always able to generate a
small but useful number of pre- and post-conditions that suitably
captured the semantics of the change for the Version in Branch
1, while it succeeded partially with the Version in Branch 2. As
already mentioned, this is due to the nature of the change that
mostly affects the control flow, while the properties used by BDCI f
to discover higher-order conflicts mostly capture the data-flow of a
program.
Finally, column Outcome reports results about the higher-order
conflicts returned by BDCI fand speculative merging. In the case
of BDCI f, we also report the number of higher-order conflicts
returned by the technique, which intuitively represents the amount
of information available to developers to identify the source of the
conflict. The last row indicates the total number of higher-order
conflicts detected by BDCI fand speculative merging.
Both BDCI fand test execution had similar effectiveness reveal-
ing 9 higher-order conflicts each. However, the set of revealed
conflicts is complemental, each technique revealed 8 higher-order
conflicts that the other technique has not been able to reveal and
only 1 higher-order conflict has been revealed by both approaches.
Two higher-order conflicts have not been detected by any technique
due to the lack of test cases covering the behaviors that produce
the higher-order conflicts.
The complementarity between BDCI fand speculative merging
is due to the intrinsic characteristics of these approaches. WhenBDCI: Behavioral Driven Conflict Identification ESEC/FSE’17, September 4–8, 2017, Paderborn, Germany
Model Generation
Model Analysis
Total Time
Time (minutes)
Figure 4: Runtime cost of BDCI f(horizontal box-plot).
the interference in the behavior of the application produced by the
higher-order conflict alters the execution flow and propagates to the
output of the application, such as for cases from Case 1 to Case 10,
the conflict can be easily detected by the checks performed by the
test cases on the output values produced by the tested program, but
it might be harder to reveal with BDCI f. This happens because, due
to the altered execution flow, some functions are not executed and
some properties are not generated anymore, thus reducing the set of
pre- and post-conditions that can be compared. In a sense, changes
that significantly alter the execution flow might leave BDCI fwith
too few pre- and post-conditions that can be compared. Although
BDCI fhas not revealed these cases, they can still be potentially
addressed with BDCI, for instance by deriving models that capture
the sequences of operations that are executed by a program in
addition to the values that can be assigned to program variables.
Incorporating this kind of information in the models generated by
BDCI fis part of our future work.
When the higher-order conflict is tricky to detect, such as for
cases from Case 11 to Case 19, test cases may fail to reveal it. For
instance, tests may fail to propagate the wrong behavior to the
output, or they may check output variables that are not affected by
the interference, as happen for cases from 11 to 19. On the contrary,
BDCI fdetects interfering behaviors using behavioral models, so
it is usually enough to execute the changes to obtain models that
capture their semantics, without any need of propagating the effect
of the interference to the output. In a nutshell, BDCI fdoes not
need test cases, but only test inputs, that is BDCI needs the runtime
data to generate behavioral models, but it never exploits the oracles
in the test cases. Thus, BDCI might be applied to systems and
components that are not maintained together with the test cases,
as long as test inputs can be generated automatically. Contrarily,
using test cases to exploit higher order conflicts strongly depends
on the effectiveness of the test cases.
Overall, the complementarity between BDCI fand speculative
merging might be exploited to effectively address most of the higher-
order conflicts . In fact, the union of the two approaches, which
simply corresponds to both running the test cases and analyzing
the behavior of the program with BDCI f, reveals 17 out of the 19
(89%) higher-order conflicts considered in the evaluation.
6.4 Efficiency
We executed the experiments on a machine equipped with an In-
tel(R) Xeon(R) CPU @ 2.53GHz. We measured the runtime cost of
model generation and model analysis, as well as the total runtime
cost. Figure 4 shows a box-plot of the runtime cost.In general, model generation requires less, although comparable,
time than model analysis. The major costs affecting model genera-
tion are the execution of the test cases, the monitoring overhead,
and the many calls to Daikon. Model analysis requires several calls
to Z3 to compare the pre- and post-conditions, to both identify
behavioral changes and higher-order conflicts.
The overall runtime cost of BDCI fhas ranged between 22 and
35 minutes, with a mean value of 31 minutes. These results suggest
that BDCI fcan be regularly applied to test overnight sessions, to
pull-requests, and to sporadically analyze commit operations.
6.5 Threats to Validity
The main threats to internal validity are about the correctness of
our prototype implementation. We are confident on the correctness
of our BDCI fimplementation because we executed the tool on
several sample cases first, to eliminate obvious faults. In addition,
for all the results reported in the paper, we manually analyzed the
considered case and the output produced by BDCI f, thus reducing
the probability that incorrect results are reported.
The main threats to external validity are about the generalizabil-
ity of our findings. We experienced BDCI fwith a number of parallel
changes in non-trivial programs and used both real and injected
conflicts for the evaluation. The injected conflicts have been ob-
tained by modifying real changes in parallel branches, which should
mitigate the risk of generating unrealistic cases. Although addi-
tional evidence should be obtained to fully generalize the results,
the empirical evidence obtained so far already suggests that BDCI f
could be a useful solution to improve the capability of detecting
higher-order conflicts early in the development process.
7 RELATED WORK
The problem of coordinating multiple developers and multiple
teams working on a same project is well-known in software engi-
neering. Coordination issues cover many abstraction levels, from
the provisioning of basic functionalities, such as computer-mediated
communication, to the provisioning of integrated operations, such
as continuous coordination [ 41]. In this paper we focus on the
problem of revealing the code-level conflicts that may result from
parallel developers activity.
This problem has been already addressed with two main classes
of solutions: techniques for detecting textual (ordirect ) conflicts and
techniques for detecting higher-order (orindirect ) conflicts. Tech-
niques for detecting higher-order conflicts can be further distin-
guished in techniques using structural information and techniques
using behavioral information.
Detection of Textual Conflicts. The ability to detect textual
conflicts is a fundamental feature of every SCM system [ 16,19,38],
such as SVN [ 2] and Git [ 18]. These SCM systems, although popular,
are not only limited to textual conflicts but can only detect conflicts
reactively, that is once two versions have been merged.
Since resolving conflicts as soon as they have been introduced in
the software is definitely easier than fixing them late once software
versions have been merged [ 9], several techniques for proactive
detection of textual conflicts have been defined [ 3,7,15,17]. The key
idea is that conflict detection should be executed early before the
code is merged, for instance every time a new version is committedESEC/FSE’17, September 4–8, 2017, Paderborn, Germany Fabrizio Pastore, Leonardo Mariani, Daniela Micucci
to the SCM system or even when developers save changes locally to
their workspaces. The result of the analysis can be made available
directly in the developer workspace, to make developers aware of
the ongoing activities and possible conflicts [22].
Some well-known techniques for proactive-detection of textual
conflicts are FASTDash [ 7], which can prevent potential conflicting
situations by providing a visual presentation of the developers’
activities on shared files; BSCW [ 3], which provides a web-based
shared workspace that integrates versioning facilities; Celine [ 15],
which uses a hierarchical workspace to scale to very large projects;
and Elvin [17], which provides awareness of direct conflicts.
BDCI is also a proactive conflict detection technique that can
detect conflicts as soon as they are introduced in the SCM sys-
tem. Compared to these techniques, BDCI is not limited to tex-
tual conflicts, which are usually easy to detect, but is designed
to address higher-order conflicts, which are more challenging to
detect [6, 11, 40].
Detection of Higher-Order Conflicts using Structural In-
formation. Higher-order conflicts are conflictual changes that do
not cause textual conflicts but produce syntactic or semantic prob-
lems in the merged version of the program. These conflicts are
particularly difficult to detect [6, 11, 40] and painful to fix [9, 24].
Several techniques addressed the problem of detecting
higher-order conflicts by computing a representation of the de-
pendencies between the components in a program, for instance
using a program dependency graph or an abstract syntax tree. This
representation is used to track the changes implemented by the
developers and detect possible conflicts, such as concurrent changes
on dependent artifacts.
The notable solutions implementing this approach differ on the
representation of the program dependencies used to identify poten-
tial conflicts. CollabVS [ 13] uses a program call graph; TUKAN [ 43]
uses a program def-use graph; Palantír [ 42] uses a program depen-
dency graph; and Syde [23] uses an abstract syntax tree.
Program dependencies are an important source of information
for potential conflicts, but not all changes on dependent artifacts
result in higher-order conflicts, and reporting any potential con-
flict, including the ones originated by indirect dependencies, might
overwhelm users of false alarms. While reporting only changes to
directly dependent artifacts may miss important and tricky con-
flicts. BDCI overcomes these issues by working on the behavior of
the program, rather than on program dependencies. In this way,
BDCI can exactly establish how and where a change impacts on the
behavior of the program and precisely determine if two concurrent
changes, even in remotely dependent code fragments, may cause
interferences once merged.
Detection of Higher-Order Conflicts using Behavioral In-
formation. Reporting the potential conflicts by looking at the pro-
gram dependencies still requires developers to analyze the program
changes in details to determine the presence of actual conflicts. As
done in BDCI, a few other techniques tried to improve the detection
of higher-order conflicts by looking at the impact of changes.
In particular, Safe-commit [ 46] runs test cases in the background
to proactively identify the changes that can be safely committed;
Crystal [ 10,11] and WeCode [ 20,21] speculatively execute merge
operations locally to the developer’s workspace, and run the buildand test processes, to discover interfering changes. Specific strate-
gies can be adopted to reduce the cost of test executions [ 34]. These
techniques share with BDCI the idea to look at the behavior of the
program to reveal higher-order conflicts. However, they only check
the portion of the program behavior that is already checked by the
oracles in the test cases (e.g., assert statements). Thus, they can
discover a conflict only if it causes a test failure.
BDCI further elaborates the idea of working at the behavioral
level to detect conflicts by explicitly generating a representation
of the program behavior and studying the impact of concurrent
changes on this representation. While the strategy based on test
case execution only checks the input-output behavior of a program,
the strategy based on behavioral models implemented in BDCI can
detect interfering changes independently on the output generated
by a program and the oracles in the test cases. The empirical results
reported in this paper provide evidence of the complementarity
between these approaches.
Finally, when the tasks that developers must execute are known a-
priori and tracked by the development infrastructure, the Cassandra
approach can be used to recommend developers task orders that
minimize the chance to introduce conflicts [ 27]. BDCI targets the
frequent case this knowledge is not available, and supports the
detection of the conflicts that cannot be prevented by looking at
task ordering.
Detection of Higher-Order Conflicts in Non-Code
Artifacts. Recently, the detection of higher-order conflicts gained
attention also in the context of collaborative software design, where
higher-order conflicts target design models rather than source code.
FLAME [ 4,5] is a recently defined technique for proactive detec-
tion of higher-order software design conflicts. Although targeting a
different context, it would be interesting to consider the possibility
to extend FLAME with a conflict detection analysis working on the
model semantics, similarly to what BDCI does for the code.
8 CONCLUSIONS
Multi-branch development of software applications might be chal-
lenging and requires proper methods and tools to be performed
efficiently. Modern SCM systems, such as Git [ 18], encourages the
use of the branching logic, but also increases the number of conflicts
that might be introduced while working on multiple concurrent
branches.
While the detection and resolution of textual conflicts is ex-
tensively supported, the detection and resolution of higher-order
conflicts is still painful and only partially supported. In this paper
we presented Behavioral Driven Conflict Identification (BDCI), an
approach that introduces the novel idea to raise conflict detection
from the source code level to the behavioral level . The approach lever-
ages two key technologies: specification mining , to automatically
generate models that represent the behavior of the software, and
model analysis , to identify the behaviors modified in each branch
and the changes that might result in misbehaviors once merged.
BDCI is a general approach that can be potentially applied to
multiple aspects of the software under analysis. In this paper we
presented a specific instance of BDCI , namely BDCI f, that shows
how this analysis can be used to reveal higher-order conflicts that
may impact on the functional behavior of an application.BDCI: Behavioral Driven Conflict Identification ESEC/FSE’17, September 4–8, 2017, Paderborn, Germany
9 ARTIFACT DESCRIPTION
Our artifact includes the data necessary to replicate the results
obtained with BDCI ffor Redis and Git. The artifact is available
for download at the following URL: https://drive.google.com/drive/
folders/0B8J_pv7c6buveTUxQkdnOXBoclk. Up to date information
about the BDCI toolset can be found at http://www.lta.disco.unimib.
it/tools/bdci/.
The artifact consists of a Virtualbox3virtual machine with in-
stalled Ubuntu, BDCI including its dependencies, a set of scripts for
re-executing BDCI on each subject, and the rest of the data neces-
sary to replicate the results reported in this paper. In particular, the
virtual machine includes the source code, the test cases, and the
intermediate results generated by BDCI f(e.g., the data recorded
while running the test cases, and the models inferred with Daikon)
for each set of versions that has been analyzed. The intermediate
results can be used to execute the model analysis phase without
having to execute the test cases and generate the models.
In general, our artifact can be exploited for multiple purposes:
•It enables other researchers to replicate the results reported
in the paper.
•It provides a significant amount of data collected during the
execution of the test cases available with Git and Redis. Such
data can be used for different research purposes by other
researchers.
•It provides a set of scripts that can be adapted to run BDCI
on different program versions.
•It provides a set of changes that introduce behavioral con-
flicts. These changes can be reused by other researchers to
evaluate their techniques.
9.1 Structure of the Artifact
The artifact is organized as a Virtualbox virtual machine with four
virtual disks: one disk contains BDCI fand the operating system,
one disk can be used as working directory to run the analysis, and
the other two disks contain the data for Git and Redis. The virtual
machine is large, it occupies 100Gb of disk space after download.
The data and the results generated for each case considered in
our experiments have been compressed in a tar.gz archive and needs
to be decompressed before running the analysis.
9.2 Replicability
Each case corresponds to a folder in the artifact. Each folder contains
the script replicate.sh that can be executed to run the analysis.
The output of the analysis is saved in the file bdci.out . Note that
each folder already contains the pre-computed bdci.out file. The
filebdci.out is overwritten when replicate.sh is executed.
In the following we succinctly report the results generated by
BDCI f. For each case, we report conflicts using the syntax
Model x<->y: (model for x) <->(model for y)
where x and y could be 0, 1, or 2, where 0 indicates the base version
of the software, and 1 and 2 indicate the two versions developed
in parallel. The part Model x<->y identifies the two versions with
incompatible models, while the part after : reports the models. We
use the identifiers as shown in the dataset to identify cases.
3www.virtualbox.com9.2.1 Git cases 171, 173, 181, 194, 197. These cases produce
higher-order conflicts that affect the functionality that prints the
content of the packets processed by Git to the standard output.
Figure 5 shows the output generated by BDCI ffor these five cases.
The changes in the two branches affect the heading printed by
the function packet_trace . BDCI fdetects this interference from
the pre-condition of function trace_strbuf_fl , which is used by
function packet_trace .
HIGHER-ORDER CONFLICT: function tr ace _strbuf _f l_ENTER
Model 0<->1: (and (and (and (not ( = data 0)) (not ( = file 0)) ) (not ( = key 0)) ) (=
line 46) )<->(and (and (and (not ( = data 0)) (not ( = file 0)) ) (not ( = key 0)) ) (=
line 80) );
Model 0<->2: (and (and (and (not ( = data 0)) (not ( = file 0)) ) (not ( = key 0)) ) (=
line 46) )<->(and (and (and (not ( = data 0)) (not ( = file 0)) ) (not ( = key 0)) ) (=
line 74) );
Model 1<->2: (and (and (and (not ( = data 0)) (not ( = file 0)) ) (not ( = key 0)) ) (=
line 80) )<->(and (and (and (not ( = data 0)) (not ( = file 0)) ) (not ( = key 0)) ) (=
line 74) );
Figure 5: Results for Git cases 171, 173, 181, 194, 197.
9.2.2 Git case 1357. Figure 6 shows the output generated by
BDCI f. This case is charachterized by a higher-order conflict that
affects function get_wcwidth , which computes the length of a Uni-
code character. BDCI fdetects this problem from the pre-condition
of function bisearch , which is used in function get_wcwidth .
HIGHER-ORDER CONFLICT: function bisearch_ENTER
Model 0<->1: (and (= max 122) (not ( = table 0)) )<->(and (or (= max 51) (= max
231)) (not ( = table 0)) );
Model 0<->2: (and (= max 122) (not ( = table 0)) )<->(and (= max 119) (not ( = table
0)) );
Model 1<->2: (and (or (= max 51) (= max 231)) (not ( = table 0)) )<->(and (= max
119) (not ( = table 0)) );
Figure 6: Results for the Git case 1357.
9.2.3 Git case 131. Figure 7 shows the output generated by
BDCI f. The functions cmd_clone andcheckout can return differ-
ent values in different branches. This behaviour depends on the
changes in function wait_or_whine . This may create problems in
callers that process the returned values.
HIGHER-ORDER CONFLICT: function cmd_clone_EXIT
Model 0<->1: (= return 0)<->(or (= return 0) (= return 128));
Model 0<->2:(= return 0)<->(or (= return 0) (= return 1));
Model 1<->2: (or (= return 0) (= return 128))<->(or (= return 0) (= return 1));
Figure 7: Results for the Git case 131.
9.2.4 Redis case 76. Figure 6 shows the output generated by
BDCI f. The conflict targets function rdbCheckThenExit , which is
used to trace errors in the Redis database management system. A
change in the caller code makes the function log a different line
number in case of errors (see the values associated with parameter
where ). This could create issues in tools that process log files.
HIGHER-ORDER CONFLICT: function rdbCheckThenExit_ENTER
Model 0<->1: (= where 1385)<->(= where 1498);
Model 0<->2: (= where 1385)<->(= where 1400);
Model 1<->2: (= where 1498)<->(= where 1400);
Figure 8: Results for the Redis case 76.ESEC/FSE’17, September 4–8, 2017, Paderborn, Germany Fabrizio Pastore, Leonardo Mariani, Daniela Micucci
REFERENCES
[1]H. Agrawal, R. A. Demillo, B. Hathaway, W. Hsu, W. Hsu, E. W. Krauser, R. J.
Martin, A. P. Mathur, and E. H. Spafford. 1989. Design Of Mutant Operators For The
C Programming Language . Technical Report. Department of Computer Science,
Purdue University.
[2]Apache. visited in 2017. SubVersion. https://subversion.apache.org. (visited in
2017).
[3]W. Appelt. 1999. WWW Based Collaboration with the BSCW Systems. In Proceed-
ings of the International Conference on Current Trends in Theory and Informatic
(SOFSEM) .
[4]J. Y. Bang. 2015. Proactive detection of higher-order software design conflicts .
Ph.D. Dissertation. Faculty of the USC Graduate School University of Southern
California.
[5]J. Y. Bang and N. Medvidovic. 2015. Proactive Detection of Higher-Order Software
Design Conflicts. In Proceedings of the Working IEEE/IFIP Conference on Software
Architecture (WICSA) .
[6]J. Y. Bang, D. Popescu, and N. Medvidovic. 2012. Enabling Workspace Awareness
for Collaborative Software Modeling. In Proceedings of the CSCW Workshop on
The Future of Collaborative Software Development (FutureCSD) .
[7]J. T. Biehl, M. Czerwinski, G. Smith, and G. G. Robertson. 2007. FASTDash: A
Visual Dashboard for Fostering Awareness in Software Teams. In Proceedings of
the SIGCHI Conference on Human Factors in Computing Systems (CHI) .
[8]C. Bird and T. Zimmermann. 2012. Assessing the Value of Branches with What-if
Analysis. In Proceedings of the ACM SIGSOFT International Symposium on the
Foundations of Software Engineering (FSE) .
[9]K. Brown, S .P. Berczuk, and B. Appleton. 2002. Software Configuration Manage-
ment Patterns: Effective Teamwork, Practical Integration . Pearson Education.
[10] Y. Brun, R. Holmes, M.D. Ernst, and D. Notkin. 2011. Crystal: Precise and Unob-
trusive Conflict Warnings. In Proceedings of the ACM SIGSOFT Symposium and
the European Conference on Foundations of Software Engineering (ESEC/FSE), Tool
Demo Track .
[11] Y. Brun, R. Holmes, M.D. Ernst, and D. Notkin. 2013. Early Detection of Collabo-
ration Conflicts and Risks. IEEE Transactions on Software Engineering (TSE) 39,
10 (2013), 1358–1375.
[12] Y. Brun, R. Holmes, M. D. Ernst, and D. Notkin. 2011. Proactive Detection of
Collaboration Conflicts. In Proceedings of the ACM SIGSOFT Symposium and the
European Conference on Foundations of Software Engineering (ESEC/FSE) .
[13] P. Dewan and R. Hegde. 2007. Semi-synchronous conflict detection and resolution
in asynchronous software development. In Proceedings of the European Conference
on Computer-Supported Cooperative Work (ECSCW) .
[14] Michael D. Ernst, Jake Cockrell, William G. Griswold, and David Notkin. 2001. Dy-
namically Discovering Likely Program Invariants to Support Program Evolution.
IEEE Transactions on Software Engineering (TSE) 27, 2 (2001), 99–123.
[15] J. Estublier and S. Garcia. 2005. Process Model and Awareness in SCM. In Pro-
ceedings of the International Workshop on Software Configuration Management
(SCM) .
[16] J. Estublier, D. Leblang, A. van der Hoek, R. Conradi, G. Clemm, W. Tichy, and D.
Wiborg-Weber. 2005. Impact of Software Engineering Research on the Practice of
Software Configuration Management. ACM Transactions on Software Engineering
and Methodologies (TOSEM) 14, 4 (2005), 383–430.
[17] G. Fitzpatrick, S. Kaplan, T. Mansfield, D. Arnold, and B. Segall. 2002. Supporting
Public Availability and Accessibility with Elvin: Experiences and Reflections. In
Proceedings of the International Conference on Computer Supported Cooperative
Work (CSCW) .
[18] GitHub. visited in 2017. Git. https://git-scm.com. (visited in 2017).
[19] R. E. Grinter. 1995. Using a Configuration Management Tool to Coordinate
Software Development. In Proceedings of Conference on Organizational Computing
Systems (COCS) .
[20] M. L. Guimaraes and A. R. Silva. 2010. Towards Real-time Integration. In Pro-
ceedings of the ICSE Workshop on Cooperative and Human Aspects of Software
Engineering (CHASE) .
[21] M. L. Guimaraes and A. R. Silva. 2012. Improving early detection of software
merge conflicts. In Proceedings of the International Conference on Software Engi-
neering (ICSE) .
[22] Carl Gutwin and Saul Greenberg. 1996. Workspace Awareness for Groupware. In
Proceedings of the Conference Companion on Human Factors in Computing Systems
(CHI) .[23] L. Hattori and M. Lanza. 2010. Syde: A Tool for Collaborative Software Devel-
opment. In Proceedings of the International Conference on Software Engineering
(ICSE) .
[24] S. Horwitz, J. Prins, and T. Reps. 1989. Integrating Noninterfering Versions of
Programs. ACM Transactions on Programming Languages and Systems (TOPLAS)
11, 3 (1989), 345–387.
[25] Intel. visited in 2017. PIN - A Dynamic Binary Instrumentation Tool. https:
//software.intel.com/en-us/articles/pintool. (visited in 2017).
[26] Y. Jia and M. Harman. 2008. Milu: A Customizable, Runtime-Optimized Higher
Order Mutation Testing Tool for the Full C Language. In Proceedings of the
Testing: Academic and Industrial Conference - Practice and Research Techniques
(TAIC PART) .
[27] B. K. Kasi and A. Sarma. 2013. Cassandra: Proactive Conflict Minimization
Through Optimized Task Scheduling. In Proceedings of the International Confer-
ence on Software Engineering (ICSE) .
[28] Linux. visited in 2017. Linux diff. http://linux.about.com/library/cmd/blcmdl1_
diff.htm. (visited in 2017).
[29] D. Lo, N. Nagappan, and T. Zimmermann. 2015. How Practitioners Perceive the
Relevance of Software Engineering Research. In Proceedings of the 10th Joint
Meeting on Foundations of Software Engineering (FSE) .
[30] D. Lorenzoli, L. Mariani, and M. Pezzè. 2008. Automatic Generation of Software
Behavioral Models. In Proceedings of the International Conference on Software
Engineering (ICSE) .
[31] L. Mariani, D. Micucci, and F. Pastore. 2014. Early Conflict Detection with Mined
Models. In Proceedings of the International Symposium on Software Reliability
Engineering (ISSRE), Fast Abstract .
[32] M. Meyer. 2014. Continuous Integration and Its Tools. IEEE Software 31, 3 (2014),
14–16.
[33] Microsoft. visited in 2017. Z3 Theorem Prover. https://github.com/z3prover/z3/
wiki. (visited in 2017).
[34] H. V. Nguyen, M. H. Nguyen, S. C. Dang, C. Kastner, and T. N. Nguyen. 2015.
Detecting Semantic Merge Conflicts with Variability-Aware Execution. In Pro-
ceedings of the joint Meeting of the European Software Engineering Conference
and the ACM SIGSOFT Symposium on the Foundations of Software Engineering
(ESEC/FSE), NIER Track .
[35] K. Noyes. visited in 2017. Git Turns 8, Sees Wide Adoption in
the Enterprise. http://www.linux.com/news/enterprise/systemsmanagement/
715287-git-turns-8-enterprise-wide-adoption/. (visited in 2017).
[36] F. Pastore, L. Mariani, and A. Goffi. 2013. RADAR: A Tool for Debugging Regres-
sion Problems in C/C++ Software. In Proceedings of the International Conference
on Software Engineering (ICSE), Tool Demo .
[37] F. Pastore, L. Mariani, A. Goffi, M. Oriol, and M. Wahler. 2012. Dynamic Analysis
of Upgrades in C/C++ Software. In International Symposium on Software Reliability
Engineering (ISSRE) .
[38] D. E. Perry, H. P. Siy, and L. G. Votta. 2001. Parallel Changes in Large-scale
Software Development: An Observational Case Study. ACM Transactions on
Software Engineering Methodologies (TOSEM) 10, 3 (2001), 308–337.
[39] Redis Labs. visited in 2017. Redis. http://www.redis.io. (visited in 2017).
[40] A. Sarma, D. Redmiles, and A. van der Hoek. 2008. Empirical Evidence of the
Benefits of Workspace Awareness in Software Configuration Management. In
Proceedings of the ACM SIGSOFT International Symposium on Foundations of
Software Engineering (FSE) .
[41] A. Sarma, D. Redmiles, and A. van der Hoek. 2010. Categorizing the Spectrum of
Coordination Technology. IEEE Computer 43, 6 (2010), 61–67.
[42] A. Sarma, D. Redmiles, and A. van der Hoek. 2012. Palantir: Early Detection of
Development Conflicts Arising from Parallel Code Changes. IEEE Transactions
on Software Engineering (TSE) 38, 4 (2012), 889–908.
[43] T. Schümmer and J. M. Haake. 2001. Supporting distributed software development
by modes of collaboration. In Proceedings of the European Conference on Computer-
Supported Cooperative Work (ECSCW) .
[44] Travis. visited in 2017. Continuous Integration Service. http://www.travis-ci.com.
(visited in 2017).
[45] M. Weiser. 1984. Program Slicing. IEEE Transactions on Software Engineering
(TSE) 10, 4 (1984), 352–357.
[46] J. Wloka, B. Ryder, F. Tip, and X. Ren. 2009. Safe-commit Analysis to Facilitate
Team Software Development. In Proceedings of the International Conference on
Software Engineering (ICSE) .
[47] Z. Zacchiroli. visited in 2017. VCS usage for Debian source packages. http:
//upsilon.cc/~zack/stuff/vcs-usage/. (visited in 2017).