StubDroid: Automatic Inference of Precise
Data-Ô¨Çow Summaries for the Android Framework
Steven Arzt
Secure Software Engineering Group
EC SPRIDE, Technische Universit√§t Darmstadt
Darmstadt, Germany
steven.arzt@cased.deEric Bodden
Software Engineering Group
Paderborn University & Fraunhofer IEM
Paderborn, Germany
eric.bodden@uni-paderborn.de
ABSTRACT
Smartphone users suer from insucient information on how
commercial as well as malicious apps handle sensitive data
stored on their phones. Automated taint analyses address
this problem by allowing users to detect and investigate how
applications access and handle this data. A current prob-
lem with virtually all those analysis approaches is, though,
that they rely on explicit models of the Android runtime li-
brary. In most cases, the existence of those models is taken
for granted, despite the fact that the models are hard to
come by: Given the size and evolution speed of a modern
smartphone operating system it is prohibitively expensive to
derive models manually from code or documentation.
In this work, we therefore present StubDroid , the rst
fully automated approach for inferring precise and ecient
library models for taint-analysis problems. StubDroid au-
tomatically constructs these summaries from a binary dis-
tribution of the library. In our experiments, we use Stub-
Droid -inferred models to prevent the static taint analysis
FlowDroid from having to re-analyze the Android runtime
library over and over again for each analyzed app. As the
results show, the models make it possible to analyze apps
in seconds whereas most complete re-analyses would time
out after 30 minutes. Yet, StubDroid yields comparable
precision. In comparison to manually crafted summaries,
StubDroid 's cause the analysis to be more precise and to
use less time and memory.
Categories and Subject Descriptors
F.3.2 [ Logics and Meanings of Programs ]: Semantics
of Programming Languages { Program analysis
Keywords
Static analysis, summary, library, framework model, model
inference
During the time this research was conducted, Eric Bodden
was at Fraunhofer SIT & Technische Universit at Darmstadt.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full cita-
tion on the Ô¨Årst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission
and/or a fee. Request permissions from permissions@acm.org.
ICSE ‚Äô16, May 14-22, 2016, Austin, TX, USA
c2016 ACM. ISBN 978-1-4503-3900-1/16/05. . . $15.00
DOI:http://dx.doi.org/10.1145/2884781.28848161. INTRODUCTION
Over the past years, the Android operating system has be-
come the most prevalent platform in the smartphone market,
with a market share of more than 79% [7]. Applications for
the platform are provided by many vendors. As of now, there
are more than one million applications available through
the ocial Google Play store alone, and numerous other
app markets exist as well. With these numbers, the quality
and security of Android applications has become a major
concern which can no longer be addressed by manual code
inspection. Indeed, researchers have already proposed vari-
ous static code-analysis tools for Android, mostly addressing
data-ow problems [1{6, 8, 12, 13, 20]. Analyzing the appli-
cation alone, however, is insucient, as applications make
heavy use of the Android framework's application program-
ming interface. In version 4.2, Android oers over 110,000
public methods and the number constantly grows with every
new release. For an analysis to be precise, it must not only
analyze the application code, but also consider the eect of
these library methods on data ows inside the application.
Existing approaches to static analysis deal with library
methods in one of three ways. The rst class of analyses
precisely models a subset of these framework methods man-
ually [1,3{5,8,13,20], while the second class analyzes the en-
tire android framework together with every application [12].
The third class uses simple rules of thumb such as \taint
return value of call if one or more arguments are tainted",
which are expected to cover the most common cases [6]. All
of these approaches exhibit serious drawbacks.
Providing hand-written models for the framework is cum-
bersome to implement and requires manual re-evaluation of
(and possibly changes to) the model for every new frame-
work version, which is a prohibitive eort given the size of
the code to be understood and modeled. CHEX [13], for in-
stance, opts to not analyze the framework together with the
application, and instead resorts to externally-dened mod-
els. However, the source of the models is mostly left open,
eectively burdening the user with this non-trivial task.
Including the framework in the automated code analysis
evades this manual eort, but it introduces an often pro-
hibitive overhead on the code analysis in terms of the over-
all code size to be analyzed. The Android operating system
consist of millions of lines of code, thereby greatly exceed-
ing the size of usual applications to be analyzed, causing
the analysis to spend signicantly more time in analyzing li-
brary code than in analyzing application code, i.e., the code
that is of actual interest to most analyses. In previous work
on FlowDroid [1], we found such an approch to induce a sig-
2016 IEEE/ACM 38th IEEE International Conference on Software Engineering
   725
nicantly increased analysis time|for every single app, over
and over again.
Applying rules-of-thumb instead of a proper library im-
plementation or external model evades the problems of high
runtime overhead and high manual eort. However, it re-
mains unclear to what extent these rules actually cover all
important libraries, or whether false-negatives may occur
due to missing taint propagations. Worse, if these rules are
designed to avoid false-negatives, they necessarily need to
over-approximate the behavior of method calls and can thus
lead to an increased number of false-positives. Recall that
these rules are oblivious to the individual callees, but aim
at a generic model for all library calls.
In conclusion, none of the approaches presented so far
solves the challenge of handling libraries during static anal-
ysis to full satisfaction. In this work, we thus present Stub-
Droid , the rst fully automated approach for inferring taint-
ow models from binary library distributions such as the
Android framework. StubDroid rst performs a taint anal-
ysis on selected public methods. We demonstrate this for
the collections API, which is the most commonly used part
of the framework. StubDroid then generalizes the result-
ing source-to-sink data-ow mappings and stores them in a
summary le. When a static client-side taint analysis later
processes the invocation of a framework method within the
code of an Android app, the analysis can simply plug in the
information from the summary le, and short-circuit further
analysis of the framework call and all its transitive callees.
While seemingly simple, a signicant challenge lies in estab-
lishing summaries that are eld sensitive and handle alias-
ing, and in treating correctly the various callbacks that the
framework code might use to interact with the application.
Furthermore, note that the generated summaries are inde-
pendent of any concrete client application. They must thus
abstract from all possible state or call sequences while still
retaining maximum precision.
We show that on commodity hardware it is usually pos-
sible to generate library summaries in under three minutes
per framework class|a one-time eort. Using StubDroid 's
summaries for conducting a taint analysis on client applica-
tions with the FlowDroid taint tracking tool [1] can improve
the analysis performance by over 90%. For many applica-
tions, the use of summaries even enables the analysis, as
the full analysis of those apps would time out after spend-
ing 30 minutes and consuming tens of gigabytes of memory if
summaries were not used. StubDroid avoids these blowups
because, opposed to client analyses, its analysis can focus on
one framework entry-point method at a time. To summa-
rize, this paper presents the following original contributions:
StubDroid , a method for automatically generating
correct and precise models of the Android framework
methods with respect to taint analysis,
a full open-source implementation of the above,
as an artifact, taint summaries for various important
Android APIs, and
an evaluation of the peformance eect of summary us-
age in the FlowDroid taint-analysis tool.
StubDroid 's full source code and the library summaries
generated with it are publicly available as an open-source
project at: http://blogs.upb.de/sse/tools/stubdroid/The remainder of this paper is structured as follows. In
Section 2 we motivate why simple rules of thumb are not
sucient to handle library methods in a taint analysis. Sec-
tion 3 shows what taint summaries for a method look like
and also introduces the concept of access paths which Stub-
Droid uses to model eld references. Section 4 explains
StubDroid 's architecture for generating and applying sum-
maries, before we report on our summary-computation pro-
cess in detail in Section 5. Section 6 focuses StubDroid 's
callbacks handling, before we go into the process of applying
summaries in Section 7. In Section 8, we report on the per-
formance and correctness of StubDroid . Section 9 presents
related work and Section 10 concludes the paper.
2. MOTIV ATING EXAMPLE
Using summaries, static analyses can gain considerable
performance improvements. A summary, plugged in at a
call site, not only renders unnecessary the analysis of any
direct callees, but also of all of the methods called tran-
sitively. A summary thus truncates a whole call tree and
replaces it by a single leaf containing the summarized data-
ow facts. Even the summary for a simple method such as
HashSet.add() will shortcut the analysis of about a dozen
methods. When analyzing the client program, the whole
tree is attened into a single rule: \For a HashSet sand an
element x, ifxis tainted, then sis tainted after executing
s.add(x) ." Given that HashSet.add() is used many times in
many applications, this can save considerable analysis time.
It is important, however, that summary rules are su-
ciently precise, as imprecisions can carry over into the anal-
ysis result and can again degrade analysis performance. Ad-
hoc rule sets often fail to distinguish dierent elds of the
same object or dierent parameters of the same method call.
A simple generic rule as above generally taints, whenever in-
voking any method o.m(x) with a tainted parameter x, the
base variable o. As we show in Listing 1, such a coarse
model can easily yield imprecisions, and therefore false pos-
itives. In this example, upon processing the constructor call
at line 16, the analysis would taint the variable p, and im-
plicitly all elds reachable through it. In the example, this
would cause a false positive at line 17: as the return value of
getO1() is retrieved from the tainted reference p, this return
value is (falsely) considered tainted as well.
In some cases, too simplistic rules can also lead to false
negatives such as in the example in Listing 2. In this ex-
ample, oos.writeObject(..) (line 4) writes data to out,
via an internal eld reference. The standard rule set would
mark oosas tainted as well as all elds reachable through
it, but not out. But the data is leaked through out, caus-
ing analyses using such a summary to miss the ow to the
sink. A sound summary must thus be able to encode that
the call to oos.writeObject(..) has an implicit side-eect
on (internal elds of) out.
As these examples show, too simplistic rules can lead to
serious cases of over and under-tainting. Nevertheless, sim-
plistic rules are the current state of the art [1,5,13,20]. The
only simple alternative to summaries, however, would be to
analyze the complete Android SDK together with every app
being inspected. Past experience as well as our experiments
in Section 8.3 show, however, that the performance penalty
of such an approach is prohibitive. StubDroid thus seeks
to pre-compute precise summaries ahead of time, in an auto-
mated one-time eort. These summaries can then speed up
7261public class Pair {
2 private Object o1 , o2;
3
4 public Pair ( Object p1 , Object p2) {
5 this .o1 = p1;
6 this .o2 = p2;
7 }
8 public Object getO1 () {
9 return this .o1;
10 }
11 public void setComplex ( Data a) {
12 this .o1 = a.b.c;
13 }
14 public static void main ( String [] args ) {
15 String s = source ();
16 Pair p = new Pair ( "not tainted " , s);
17 sink (p. getO1 ());
18 }
19}
20public class Data { public Data2 b; }
21public class Data2 { public Object c; }
Listing 1: Complex Data Structure and Method
1public void doLeak () {
2 ByteArrayOutputStream out = new
ByteArrayOutputStream ();
3 ObjectOutputStream oos = new
ObjectOutputStream (out);
4 oos. writeObject ( source ());
5 oos. close ();
6 sink (out. toByteArray ());
7}
Listing 2: Complex Data Structure and Method
any subsequent analysis runs without jeopardizing precision,
and while reducing memory consumption.
3. SUMMARY MODEL
Assume the Pair class from Listing 1 to be part of a li-
brary. The summary for the Pair class' constructor needs
to model that data ows from the rst parameter to the
eld this.o1 , i.e., that this.o1 inherits the taint state of
the rst parameter. The same connection exists between the
second parameter and the eld this.o2 . There is, however,
no connection between the two elds or between the rst
parameter and eld this.o2 .
The taint summaries generated by StubDroid take the
form of rules. Given a certain incoming taint, they model the
eect of a certain method call on this taint. The constructor
of the Pair class can therefore be described using two rules:
1.this.o1 is tainted if parameter 1 is tainted. (R1)
2.this.o2 is tainted if parameter 2 is tainted. (R2)
When applying a summary, the rules are used to perform
a xed-point iteration on the set of tainted variables at the
call site that invokes the summarized method. Every taint
state that is not explicitly changed by a summary rule is
kept unchanged. (There are no strong updates.)
In Listing 1, which calls the constructor of Pair with only
Parameter 2 tainted, summary rule (R2) is applicable, while
rule (R1) is not. Thus, o2is marked as tainted for the
current instance of Pair while o1remains untainted.Note that summaries can also model eects on private
elds of objects. While those elds are invisible to applica-
tion code, they can be used to model object state, akin to
ghost elds in JML [11]. This makes summaries eld sensi-
tive, which is important for maintaining precision. The Pair
class in the example contains a method getO1() returning
this.o1 . The return value of this method thus inherits the
taint state of this.o1 , which is distinct from the taint state
ofthis.o2 . Without eld sensitivity, one could not distin-
guish between the taint states for the two elds, and a false
positive would occur at line 17.
Highly precise data-ow analysis tools such as FlowDroid
or Andromeda [19] work by tracking not only elds but so-
called access paths . An access path is of the form l:f:g where
lis a local variable or parameter and fandgare eld ac-
cesses. Access paths can have dierent lengths up to a user-
customizable maximum, at which they are truncated. An
access-path of length 0 is a simple local variable or param-
eter, e.g., l. Truncated access paths act as placeholders for
all runtime objects reachable through them, and end with
an asterisk, e.g., l:f: for all objects reachable through l:f
(including l:fitself, but also l:f:g,l:f:h, ...).
To retain this level of precision, StubDroid 's summaries
are also based on access paths, with a customizable maximal
length. A taint-summary rule thus always taints an acess
path given that a certain incoming access path is tainted.
One would thus write the above rules more precisely as:
1.this.o1.* is tainted if parameter 1.* is tainted.
2.this.o2.* is tainted if parameter 2.* is tainted.
In all rules, the asterisk character acts as a placeholder.
Assume an application calls the constructor of Pair as in:
Data d = new Data (); d.f.g = source ();
Pair p = new Pair ( "not tainted " , d);
In this example, rule 2 applies. It will, however, not simply
taint this.o2.* , but copy over the sux of the access path,
tainting instead this.o2.f.g . More formally, the asterisk
on both sides of a rule references the same universally quan-
tied variable (8x:this.o1. xis tainted if parameter 1. xis
tainted). In result, StubDroid 's summaries can retain the
client analysis' precision as long as the library summary was
generated with at least the same maximal access-path length
that is also used to analyze the application. By default,
access paths are truncated at length 5, the same default
that also the FlowDroid client analysis uses. Longer access
paths can require signicantly more computation time dur-
ing summary generation, but are possible by simply chang-
ing the StubDroid conguration. In previous work, we
found FlowDroid's default length of 5 to be suciently pre-
cise in practice [1].
4. ARCHITECTURE
Figure 1 shows the general workow involving StubDroid .
StubDroid generates one summary le per library class,
from a binary distribution of the respective library. At this
stage, no application code is present. We assume that appli-
cations only interact with libraries through public methods
and elds, rather than applying reection to access private
members. Therefore, all public methods (and only those)
need to be summarized.
727StubDroid, applied per API methodStubDroid, applied per API methodLibrary 
Bytecode
Source/sink 
spec.Taint Tracking 
(FlowDroid)Result
postprocessing
analysis client, here FlowDroidShortcut-rule 
handlerTaint analysisapplication
bytecodeLibrary
Summariesperformed once for entire library applied to each analyzed appFigure 1: StubDroid's Process and Architecture
The summary generator cannot anticipate in which order
or with which parameters the library method will later be
called inside the application code. The generated summaries
must work in all possible apps and usage contexts. There-
fore, StubDroid must assume all possible call sequences,
must abstract from all library state and parameters be-
fore a method call, and must then analyze the eect of the
method on these abstract descriptions as explained in Sec-
tion 3. StubDroid can thus analyze the eects of every API
method in isolation, which helps the tool to keep its memory
requirements low despite the analysis' high precision.
StubDroid generates summaries as XML les, one le
per library class. The generated summary les can after-
wards be used during the analysis of an arbitrary number
of applications. At this stage, the library code no longer
needs to be available, as the summaries are self-contained.
When using the libraries during an analysis, the XML les
are loaded on demand. A client-side summary storage keeps
track of all classes for which summaries are available. Only
when a taint can potentially reach a eld or method of a
certain class, the summary le for this class is requested
from the storage and loaded into memory. This greatly re-
duces memory consumption if summaries for large (or many
dierent) libraries are available on disk.
In our particular implementation, StubDroid uses the
FlowDroid open-source data-ow tracker [1] for generating
and as a client applying library summaries. Nevertheless,
the summaries are encoded in generic XML, which makes
them usable also for other taint-analysis clients. We based
StubDroid on FlowDroid, because it is precise (context-,
eld-, object-, and ow-sensitive) as well as easily extend-
able. Further, as FlowDroid is based on Soot [10], it can
be run on Java source code, Java bytecode, and Android's
Dalvik bytecode1.StubDroid inherits these capabilities.
To integrate library summaries into its taint analysis, Flow-
Droid oers the concept of so-called Taint Wrappers . Those
wrappers implement shortcut rules that circumvent the anal-
ysis of certain callee methods. To enable FlowDroid to pro-
cessStubDroid 's summaries, we implemented shortcut-rule
handling as a taint wrapper which obtains the summary
rules directly from the summary storage.
5. SUMMARY GENERATION
StubDroid generates data-ow summaries and must thus
conduct a data-ow analysis on the library's bytecode or
source code. As explained before, StubDroid analyzes the
library by focusing on one API method at a time. Given such
a method, StubDroid conducts a taint analysis starting at
a number of dierent potential data sources. In general,
every access path within the method in question must be
considered a source. This includes all access paths involving
1The new ART runtime uses the same bytecode as Dalvik.parameters, the this reference for instance methods, but
also all visible static elds. Every access to one of these
access paths becomes the left-hand side of a summary rule.
For example, in Listing 1, the constructor of the Pair class
induces rules for the access paths this.* ,p1.* and p2.*.
Further, note that this.* is used as a source instead of
the combination of this.o1.* and this.o2.* .StubDroid
starts with such more abstract top-level access paths only,
and reconstructs on demand which elds have actually been
used. We will detail this later. Using longer access paths
to start with would require StubDroid to consider all ac-
cess paths reachable through the above base variables, which
could cause a combinatorial blowup.
StubDroid , further considers every method return as a
sink at which the summarized ow is concluded.2The sum-
mary rules are generated by comparing the taint state of
access paths before and after the execution of the method to
be summarized. Every taint derived from one of the source
access paths that reaches the end of a method must be trans-
lated into a summary rule. In the example from Listing 1,
a ow derived from p1.* reaches the end of the constructor
method as a taint this.o1.* . This leads to the genera-
tion of rule (R1) from Section 3. Note that identity ows
are not encoded, e.g., no rule is generated for the ow that
starts with o1.* and ends with the same o1.* at the end of
the method. This is because generally StubDroid does not
support strong updates to kill ows. All taints that existed
at the beginning of a method are implicitly assumed to still
exist also after the summarized method's invocation. We
will consider strong updates in future work.
As the sources are only top-level access paths, rule gen-
eration is not trivial. Assume that at the end of method
setComplex from Listing 1, an access path this.o1.* is
tainted. As taint is linked to the source a.*, not a.b.c.* ,
this can lead to all of the following rules:
this.o1.* is tainted if a.*is tainted.
this.o1.* is tainted if a.b.* is tainted.
this.o1.* is tainted if a.b.c.* is tainted.
To restrict the rules it needs to generate, StubDroid
must nd the concrete elds that were accessed during taint
tracking. This is achieved by analyzing the concrete taint-
propagation path backwards. The taint analysis is cong-
ured to record every statement that inuenced a taint, i.e.,
for which the tainted access path changed during the prop-
agation. For method setComplex , this generates the follow-
ing taint-propagation path. (The temporary variables are
artifacts of the Jimple-representation [10] that StubDroid
operates on.)
2Exceptional method returns are ignored in the current im-
plementation, but do not pose any specic further challenges
aside from the implementation eort.
7281<method id= " test . Pair : void
setComplex ( test . Data )" >
2 <flows >
3 <flow isAlias = " true " >
4 <from sourceSinkType = " Parameter "
ParameterIndex ="0"
5 BaseType = " test . Data "
6 AccessPath = "[ test . Data : test . Data2
b, test . Data2 :
java . lang . Object c]"
7 AccessPathTypes ="[ test .Data2 ,
java . lang . Object ]" />
8 <to sourceSinkType =" Field "
9 BaseType = " test . Pair "
10 AccessPath = "[ test . Pair :
java . lang . Object o1]"
11 AccessPathTypes ="[ java . lang . Object ]"
taintSubFields =" true " />
12 </flow >
13 </flows >
14</method >
Listing 3: Taint Summary for Pair.setComplex()
tmp$0 = this .a;
tmp$1 = tmp$0 .b;
tmp$2 = tmp$1 .c;
this .o1 = tmp$2 ;
As the path shows, the taint this.o1.* was derived from
tmp$2.* which in turn was derived from tmp$1.c.* etc.
Note that this backwards-analysis makes taints more pre-
cise. Whenever an assignment denes the base variable of
the current taint, its right-hand side replaces the current
base variable of the access path. On the second statement,
the taint tmp$1.c.* is mapped to tmp$0.b.c.* , because
the second statement denes tmp$1 astmp$0.b . In other
words, StubDroid uses assignments to extend the access
path with the eld information from the right-hand side of
the assignment. With the rst statement, the nal result
ofthis.a.b.c.* is reconstructed. This is the most precise
source access path for the new rule. Therefore the actual
rule that StubDroid computes is: this.o1.* is tainted if
a.b.c.* is tainted.
5.1 XML File Storage
StubDroid stores its summary facts in one XML le per
class. This allows clients to load summaries on demand.
Only when a taint reaches a method declared in a specic
class, that class' summary le must be loaded. Listing 3
shows the summary of the setComplex() method from the
example class in Listing 1. A summary le contains method
elements which in turn contain flow elements, one per pair
of source and sink between which the method causes a data
ow. For each ow, StubDroid stores the source ( from) and
the sink ( to) in terms of the method's interface. Sources and
sinks dierentiate between method parameters, elds, and
return values. Method parameters are referenced by index.
Fields are represented by their full signature. If not the
parameter or eld itself, but an access path starting at the
respective element is referenced, the elds on the access path
are stored as an ordered list of full eld signatures.
Additonally, StubDroid further stores the propagated
types of all elds referenced in a ow summary. While the
normal eld signature only contains the declared type of1int charToInt ( char c) {
2 int[] vals = new int [] { 0, 1, 2, 3, 4,
... };
3 int idx = ( int) c;
4 return vals [ idx - 48];
5}
Listing 4: Implicit Flow Sample Code
the eld, the taint analysis also provides StubDroid with
an (often more precise) type propagated along with the re-
spective taint. When applying the summary, this allows
StubDroid to inject these precise runtime types back into
the client's taint analysis. This is useful as some clients use
type information to rene call-graph information on the y.
A library method, for instance, might be declared to return
java.lang.Collection , but always return a more precise
type HashSet . In this case, the taint analysis can make use of
this information: when seeing a call c.add(..) on a tainted
collection c, if the client knows that cis aHashSet then it
can resolve the add-call precisely to HashSet.add(..) .
5.2 Summaries and Implicit / Native Flows
The computation of library summaries is based on a taint
analysis which can either only be performed for explicit data
ows through assignments, or also for implicit ows through
control-ow dependencies. Listing 4 shows an implicit data
ow within a method for converting characters containing
digits to integers. The conversion functions in the Oracle
JDK and the Android platform are implemented in a simi-
lar fashion. Method charToInt does not directly assign the
parameter value to the result value, but still the result de-
pends on the parameter, and a summary should contain a
rule which taints the result value if the parameter is tainted.
StubDroid oers dierent possibilities to handle such
cases. The FlowDroid data-ow tracking tool that Stub-
Droid uses internally supports computing implicit ows just
like \normal" explicit ows if the respective option is en-
abled. In many cases, however, implicit ows do not fully
leak the data in question but rather leak information about
that data. Determining whether this information leak is
problematic is a hard semantic problem [9]. Given that
tracking of implicit ows is also expensive, we thus recom-
mend not to track them and instead specify manual sum-
maries for the small number of relevant data-type conversion
methods by hand. These are basic JDK methods such as In-
teger.toDecimalString() that are hardly ever extended or
changed. This is how we use StubDroid in our daily work
and how we conduct our experiments.
Similar problems occur when libraries reference native
code. In the Oracle JDK's ConcurrentHashMap implementa-
tion, for instance, native code is used for fast non-blocking
access to the underlying data structures. Since the Flow-
Droid, and thus StubDroid , cannot analyze native code,
we created summaries for such methods manually. Note that
StubDroid does not support sanitizers or ows across ex-
ternal resources such as les. We leave this to future work.
6. CALLBACKS
In general, Java (and Android) methods can contain call-
backs in which a library method invokes client code. We
distinguish generic callbacks such as toString() from the
special case of Android lifecycle callbacks.
7291public String append ( String inStr ,
IAppender appender ) {
2 return "Hi" + appender . getString ( inStr );
3}
Listing 5: Callback Example
6.1 Generic Callbacks
Every library method can invoke methods on objects passed
in from application code to call back into the client code,
see Listing 5. A correct summary of method append(..)
requires knowledge about the concrete implementation of
IAppender (more concretely: of IAppender.getString() )
passed to append(..) . Without this knowledge, one has to
manually choose an approximation. An under-approximation
of the eects of the call to getString() would assume its
return value never to be tainted. An over-approximation,
though, would assume the return value always to be tainted.
A probably more useful approximation would be to assume
the return value of getString() to only be tainted if the
inStr parameter is tainted when append(..) is called. Even
such an approximation might be incorrect, though, depend-
ing on the concrete possible implementations of IAppender .
To handle such callbacks precisely, StubDroid adopts the
principle of component-level analysis introduced by Rountev
et. al. [16]. During the analysis of a method to be summa-
rized, one may reach call sites for which the library itself
contains no callees. We call these call sites gaps. The sum-
mary rules presented so far connect interface components
of the respective library method, e.g., link a parameter to
a return value. With callbacks, ows may start and end
at gaps as well. A gap can be thought as a \hole" inside
a summarized method ow. StubDroid cannot make any
assumptions as to what transformations are made to a taint
abstraction inside a gap. It can only summarize the part
of the ow that is inside the library method until it reaches
the gap. For all possible outgoing taints, it can then again
summarize how they ow further inside the library method.
In other words, a call to a gap method is treated like an ad-
ditional interface of the method to be summarized. In the
example of Listing 5, this leads to the following rules:
<Gap1>Parameter0.* is tainted if inStr.* is tainted
Return.* is tainted if <Gap1>Return.* is tainted
Note that StubDroid must generate rules for every pos-
sible outgoing taint of the gap method. In the example, only
the return value of the gap method getString is used within
append . If, however, a gap method is, for instance, called
with a heap object as a parameter and that object is used
later on, this must also be represented by a ow. This ow
would then account for gap implementors that taint elds in-
side the heap object they received as a parameter. In short,
all possible ways in which a taint can be passed back from
a callee to its caller can lead to new ow rules.
When the summary is later applied to a target program,
the gaps must be lled with either a dierent summary or
with the results of analyzing client code. StubDroid rst
attempts to nd other summaries that can ll the gaps in
question without any interaction with the client analysis. If
unsuccessful, it passes the taint information at the gap's call
site to the client analysis to nd additional implementations
of the gap method in client code. This allows the client anal-
ysis to focus on the client code alone when lling gaps. Thell-ins applied to gaps can in turn have new gaps which must
be lled using the same principle. The xed-point iteration
stops if there are no open (i.e., unlled) gaps remaining.
6.2 Android Lifecycle Methods
Lifecycle methods allow the Android platform to control
applications. In general, the Android OS is much more
tightly coupled with its applications than a normal Java
VM with its programs. Android applications do not con-
tain a main method, but instead derive classes from certain
pre-dened system classes and overwrite so-called lifecycle
methods which allow the the Android middleware to, for in-
stance, start, pause, or resume applications when necessary.
Currently Android comprises four dierent types of com-
ponents : Activities, Services, Broadcast Receivers, and Con-
tent Providers. All of them have distinct lifecycles, dening
ways for the operating system to inuence the execution
of the respective component. Nevertheless, the semantics
of all four lifecycles is rather self-contained and well doc-
umented. The framework essentially just calls the imple-
mented fraction of the lifecycle methods in a predened,
well-known order. The most complex lifecycle is the one
of the activity component type, and even this one contains
fewer than a dozen methods. We therefore leave the simu-
lation of lifecycle-induced call-backs to the summary client.
In our experiments, we use the concrete client FlowDroid,
which handles lifecycle methods by simulating their eects
through a generated dummy main method that simulates
the lifecycle of the Android application [1, Section 3].
Notications are special callbacks that allow the Android
operating system to notify applications of system events like
a battery shortage or an incoming text message. Sensors like
GPS are also modeled through callbacks in the application:
When the user moves around, a special interface in the appli-
cation is called with the new coordinates of devices. These
callbacks can be invoked by the operating system at any
time while the respective host component is running, and
they are provided through about 200 special-purpose inter-
faces. With our implementation we provide a list of these
callback interfaces. To obtain a complete and precise list
of callback methods, it is therefore sucient to match all
methods contained in interfaces in this list against the list
of interface methods implemented in the target program.
Clients must then simulate a call to all such methods at a
well-known point in the lifecycle, at which the app is known
to be in its running state. These callbacks only depend on
external events like incoming SMS messages, and not on the
behavior of the application under analysis. Thus, they can
occur at any time while the app is running.
These observations conveniently reduce the problem of
modeling the framework to analyzing the eects of frame-
work methods called by the application without impeding
correctness or precision of the obtained analysis results. Our
previous publication on FlowDroid describes in detail how
one can generate sound dummy-main methods that respect
callbacks in Android [1]. A similar methodology must be
followed for other Android client analyses.
7. APPLYING SUMMARIES IN CLIENTS
After the summaries have been computed once, they can
be used in an arbitrary number of taint analyses on client
programs or Android apps. The library code is then no
longer required. StubDroid integrates into FlowDroid us-
7301void doLeak () {
2 Data data = new Data ();
3 data .b.c.d = source ();
4 Pair p = new Pair ( "foo" ," bar " );
5 p. setComplex ( data );
6 sink (p. getO1 ().d);
7}
Listing 6: Client Program for Pair Class
ing the concept of Taint Wrappers . Taint wrappers are
handlers for shortcut rules. In FlowDroid, they model ex-
ternal domain knowledge through an interface exposed by
the taint-tracking engine. Whenever a method call is pro-
cessed, the registered wrapper is asked whether it contains
an explicit taint-propagation rule for the callee. StubDroid
provides FlowDroid with a specialized taint wrapper im-
plementation to inject the summary data during analysis.
While this concept is specic to FlowDroid, other tools like
CHEX [13] have similar extension points for explicit (li-
brary) method models and could thus use StubDroid 's
summaries in a similar fashion.
Assume the pair class from the motivating example in
Listing 1 to be used in the program in Listing 6. This user
code constructs an object of type Data and taints its eld
b.c.d . The data object is then passed to the setComplex()
library method. This method is not part of the user code,
but requires one to apply a library summary. Conceptually,
the method copies the contents of the eld b.ctothis.o1 .
Therefore, the object containing the tainted data is returned
bygetO1() and leaked in line 6. Note that in this example
the actual tainted data is stored in a sub-eld dwhich is
never touched by the library implementation.
Recall the summary for the setComplex() method com-
puted in Sec. 5: this.o1.* is tainted if Parameter 0.b.c.*
is tainted. As explained in Section 3, the asterisk serves
as a placeholder. When applying the summary rule to the
example client code, StubDroid will therefore match the
asterisk with the actual elds of the longer incoming access
path and derive the more precise rule this.o1.d.* is tainted
ifParameter 0.b.c.d.* is tainted.
This rule can then easily be matched against the incom-
ing taint. FlowDroid will query the taint wrapper for the ac-
cess path data.b.c.d.* .StubDroid matches the argument
variable data against Parameter 0 and then applies the rule.
It reports p.o1.d.* back to the taint analysis. Note that the
rules directly create new taints on access paths. If the client
code direct read the eld p.o1 instead of calling a getter
method, this would be captured by the taint on p.o1.d.* .
7.1 Aliasing
Library methods and user-code methods may both taint
heap objects which may, in turn, have aliases both inside
and outside of the library. The example in Listing 7 uses
aPair object to store a Data object. The code then re-
trieves this data object as d1, and taints one of its inner
elds. Afterwards, the same object is retrieved again as d2
before the data is read out and leaked. If the Pair class
were not a library class but a part of the client code, Flow-
Droid could directly nd the leak. In FlowDroid, whenever
a tainted value is assigned to a heap object, the data-ow
engine automatically starts a backwards tracking to nd
aliases. In the example, it would inter-procedurally prop-1public void leakWithAliasing () {
2 Pair p = new Pair ( new Data () , null );
3 Data d1 = ( Data ) p. getO1 ();
4 d1.b.c = source ();
5 Data d2 = ( Data ) p. getO1 ();
6 leak (d2.b.c);
7}
Listing 7: Library Summary Client with Aliases
agate the access path d1.b.c.* backwards to check whether
this access path or some prex of it is referenced on the
right side of an assignment. All discovered aliases are then
forward-propagated as rst-class taints.
In Listing 7, however, the class Pair is abstracted away
using a library summary. Therefore, FlowDroid cannot de-
termine that d1.b.c.* aliases with p.o1.b.c.* . The rela-
tionship between p.o1 and d1is encoded in getO1() , but
when the backwards propagation reachs the call to getO1() ,
there is no callee to process. Therefore, such aliasing rela-
tionships must also be encoded in the summaries. For this
reason, taint wrappers in FlowDroid provide an extension
for aliasing. Alias summaries in StubDroid are just like
ow summaries, only with an inverse propagation rule. For
Pair.getO1() , there is already a rule: return.* is tainted if
this.o1.* is tainted. Since the rule deals with heap objects,
however, it can also be applied backwards: If return.* is
tainted afterwards, this.o1.* may have been tainted be-
fore. In this direction, it encodes a may-alias relationship.
The nal taint propagation in the example hence works as
follows: When p.getO1() is called rst, nothing inside the
pobject is tainted yet, so the rule does not yet apply. When
FlowDroid queries StubDroid 's taint wrapper for aliases of
d1.b.c.* ,StubDroid can apply the inverse of the rule and
return a taint on p.o1.b.c.* to FlowDroid. This taint is
then propagated forward. In Line 5, the normal summary
rule for getO1() then applies and d2.b.c.* gets tainted.
Therefore, FlowDroid can now detect the leak in Line 6.
To allow for more exibility and some corner-cases (such
as strings which are immutable), StubDroid stores a ag
alongside every summary rule that indicates whether the
ow may be inverted in order to answer alias queries.
7.2 Handling Incomplete Summaries
Note that taint wrappers can also be used with incom-
plete summaries. This is useful if libraries cannot be fully
analyzed since, for instance, they depend on native code.
In this case, analyzing the Java-based parts is still valuable,
though it needs to be complemented with additional approx-
imations. The FlowDroid client, for instance, supports two
modes that determine how calls to methods are handled for
which no summary is available.
In the so-called conservative mode, the return value of a
method call is always considered as tainted if the base object
on which the method is invoked (or any eld inside it) is
tainted. In the example this would lead to a sound analysis
even if the summary for the getData() method was missing,
but may come at the cost of reduced precision. Similarly,
thehashCode() and equals() methods can also be over-
approximated with simple rules even if there is no summary
for them for a certain class.
FlowDroid also supports the exclusive ag which allows
a taint-wrapper implementation to claim the taints it gener-
731ates for a specic call site and incoming taint as complete. If
the wrapper declares itself as exclusive, the analysis will not
consider the callee's implementation even if it is available.
By default, the StubDroid taint wrapper is exclusive for
all methods for which it has at least one summary fact in its
input XML le, because this indicates that the respective
class has been fully analyzed by StubDroid and thus all
existing data ows have been summarized.
8. EV ALUATION
The summaries generated by StubDroid are maximally
useful if they substantially reduce the time required to run
the target analysis on a client program, if they do not re-
duce the precision of the analysis result (thus avoiding false
positives), and if they are sound, i.e., do not introduce any
false negatives. Our setup for computing the performance
measures is explained in Section 8.1. The time required to
compute a library summary is evaluated in section 8.2. Sec-
tion 8.3 addresses the performance gains of using summaries
and shows that StubDroid substantially reduces the time
required for performing static analysis. In Section 8.4, we
nally discuss the soundness and precision of our approach.
8.1 Experimental Setup
All performance experiments were carried out on a compu-
tation server featuring 40 virtual Xen CPU cores backed by
Intel Xeon E5-4640 cores in physical hardware. The server
was running Ubuntu 14.04 and Oracle's JVM version 1.7 in
its default settings. Only the maximum heap size was set to
15 GB for summary generation and to 150 GB for analyzing
apps. The large heap size for the app analysis was chosen to
allow for a fair comparison with approaches that analyze the
full Android library together with every app. Note that this
may make some analyses perform less aggressive garbage
collection than usual and thus report higher memory values
than they would in more constrained scenarios.
To analyze the Android platform, we used an android.jar
le manually built from a Galaxy Nexus device running An-
droid 4.3. This is because the android.jar les included in
the Android SDK as distributed by Google contain stub im-
plementations only, which raise NotImplementedException s
in every method. (They are only used to allow Android
apps to link against the library interfaces.) As StubDroid
is not only applicable to Android apps, but also to normal
Java programs, we also evaluated it on the Java 8 (version
1.8.0 05) runtime library.
To evaluate the performance of StubDroid both in terms
of summary application and summary generation, we com-
puted summaries for the Android and the JDK implemen-
tations of the Java collections API. These classes are widely
used in almost all applications, which is why modeling them
is of high priority. Furthermore, these classes are rather
large, and are thus suitable for assessing the scalability of the
approach. The same holds for the string-processing classes,
especially java.lang.StringBuilder which is used, e.g., to
concatenate strings. With summaries for these two types of
libraries, FlowDroid can successfully analyze most applica-
tions. All reported timings were averaged over 10 runs. The
raw data is available on our project web page.
8.2 Summary Generation Performance
Generating the library summaries is a one-time eort that
only needs to be repeated when the library is updated, whichis rare in comparison to how often client applications using
the library are analyzed. Nevertheless it is important that
the summary generation is practically feasible. In Table 1,
we report performance numbers on both the Android SDK
and the Oracle JDK.
Our results show that StubDroid usually nishes in un-
der three minutes per class for common Java collection APIs.
For some of the concurrent collection implementations, the
generation can take up to slightly over ten minutes. In these
cases, the summaries generated by StubDroid are also con-
siderably larger than those for their non-concurrent coun-
terparts. This happens because the concurrent implemen-
tations need to assign additional internal synchronization
elds which also become part of the summary and increase
the complexity of the data ows in the respective methods.
Even though summaries could be centrally pre-computed
on large servers, the memory requirements of StubDroid
are modest. All summaries could be created within the
15 GB of heap space allotted, most of them using much
less memory than available. This even applies to the large
concurrent-collection classes such as the skip-lists.
Note that the Android and Oracle implementations of a
particular class only share the specication, but not any
source code. The versions shipped with the Android OS are
especially optimized for resource-constrained devices. The
dierences are especially apparent in the number of ows
generated for each class in Table 1. For java.util.Priority
Queue ,StubDroid detects more than twice as many ows
in the JDK implementation than in the one from Android.
8.3 Analysis Performance
We next evaluate how StubDroid can impact the perfor-
mance of a client taint analysis. We therefore ran FlowDroid
on a number of Android test apps in three dierent modes:
Full analysis mode. In this mode, the full Android
library was placed on the classpath and analyzed to-
gether with the app. Library summaries were not used.
Hand-written summaries. In this mode, FlowDroid
is run with its default hand-written summaries. This
mode acts as a base-line as it corresponds to running
the original FlowDroid implementation.
StubDroid mode. In this mode, only library stubs
were placed on the classpath and StubDroid 's sum-
maries were used to model the taint propagation over
library call sites.
The hand-written summaries that FlowDroid uses by de-
fault not only cover the collection APIs but also a few other
Android APIs such as cursors or intents. To allow for a fair
comparison we generated StubDroid summaries for those
APIs as well. The results in Table 2 show that StubDroid
oers a performance that is comparable to FlowDroid's de-
fault hand-written summaries with a similarly high memory
consumption; both analysis modes have comparable cost. In
comparison to analyzing the full library implemenation to-
gether with every app, summaries provide a major decrease
in runtime and memory consumption. In many cases, it even
makes the analysis feasible; analyzing the app together with
the full library implementation times out after 30 minutes.
The rst two apps in Table 2 were taken from the Droid-
Bench [1] micro-benchmark suite. (We chose those two apps
of the suite that actually use library methods.) These apps
are rather small, so the discrepancy between the size of the
732Class Generation Time (s) Number of Flows Memory (MB)
Oracle JDK Android Oracle JDK Android Oracle JDK Android
java.util.ArrayDeque 45.82 52.76 82 88 1,086.52 2,203.27
java.util.ArrayList 37.95 42.52 72 72 1,086.52 2,323.40
java.util.HashMap 34.38 27.86 92 78 3,125.93 1,910.82
java.util.HashSet 51.46 45.04 140 81 3,125.93 1,910.82
java.util.LinkedHashMap 35.45 31.77 81 74 3,213.93 1,983.74
java.util.LinkedList 61.87 66.55 130 120 2,688.00 2,468.69
java.util.PriorityQueue 65.36 37.17 731 246 2,415.65 1,984.09
java.util.Stack 57.46 65.49 86 87 1,663.25 1,980.43
java.util.Vector 54.86 62.77 87 98 1,841.91 2,101.82
java.util.[...].ConcurrentHashMap 88.24 71.18 116 144 4,027.54 2,323.40
java.util.[...].ConcurrentLinkedQueue 64.23 35.58 36 40 1,509.77 1,761.86
java.util.[...].ConcurrentLinkedDeque 74.67 71.72 883 887 4,072.54 3,372.84
java.util.[...].ConcurrentSkipListMap 352.56 766.33 2206 2262 5,765.34 3,968.78
java.util.[...].ConcurrentSkipListSet 397.02 960.48 2234 3221 4,966.98 3,644.88
java.util.[...].DelayQueue 147.63 86.32 1745 807 4,864.34 3,106.15
java.lang.StringBuer 92.06 81.73 397 309 1,212.16 2,621.19
java.lang.StringBuilder 86.35 81.72 443 305 1,617.32 2,425.11
Average 102.79 152.18 562 525 2,760.80 2,475.96
Table 1: Summary Generation Times for Android and JDK APIs
app and the size of the library is signicant. If no summaries
are used, the analysis spends most of its time in the library.
The other apps in the table are real-world applications taken
from the Google Play Store.
Data-ow analysis is especially useful to nd privacy vi-
olations in potentially malicious applications. Many mal-
ware apps steal the user's unique device identier (IMEI),
his phone number, or other personally-identiable values.
To assess how StubDroid can help with nding such data
thefts, we assess how it impacts the performance of Flow-
Droid on 258 apps from four dierent malware families in-
side the well-known Malware Genome Project [21]. Table 3
shows the average runtimes for each malware family. Due to
space constraints, we only report values for the largest and
most prevalent malware families. The column TO states the
number of apps for which the analysis timed out after ve
minutes. In cases where all runs timed out, measurements
are naturally not available (n/a). In cases where some runs
timed out but not others, the numeric values indicate the
average for the runs that did not time out.
The data in Table 3 indicates that analyzing the complete
library together with every single app is infeasible and leads
to timeouts in almost all cases. Using summaries, on the
other hand, allows all but a handful of apps to be analyzed
in under one minute. These time and memory savings, how-
ever, also depend on the precision of the summaries. For
theDroidDream Light malware there are cases in which the
hand-written summaries incur a higher memory consump-
tion than analyzing the full library. This is because the
imprecise summaries lead to severe over-tainting during the
analysis. The precise summaries computed by StubDroid
do not show this memory explosion. Thus, StubDroid can
considerably save time and memory in comparison to a full
analysis as well as in comparision to the hand-written rule
sets currently used by most static data-ow analyses.
Note that FlowDroid cannot complete the analysis of large
applications when congured to analyze the full library im-
plementation together with the app. In the very same hard-
ware conguration, computing the summaries and then an-
alyzing the app with these summaries does, however, com-
plete in a reasonable amount of time. This is primarily be-cause the summaries are computed with one API method
as entry point after the other, drastically reducing the peak
memory requirements.
8.4 Relative Soundness and Precision
A summary approach such as StubDroid can only be
as precise and as sound as the analysis on which it is based.
We thus rather check that StubDroid preserves analysis re-
sults, by comparing the data-ow results of two setups: (1)
FlowDroid applied to apps including the complete library
implementation and (2) FlowDroid applied to apps without
the runtime library but with StubDroid 's summaries in-
stead. Ideally the same results should be achieved. Recall
thatStubDroid creates summaries that are applicable to
arbitrary client programs. It therefore abstracts from con-
crete call sequences and states. It is important to evaluate
whether this generalization leads to a loss of precision or
soundness. We performed these comparisons on all apps
from Tables 2 and 3 on which the full analysis terminated.
We conrmed that all ows detected by FlowDroid that in-
volved StubDroid -summaries were equal to a full analysis
of the target app plus the library. This means that replacing
the library implementation with StubDroid 's summaries
does not incur any penalty in precision or soundness.
In the Hamburg Casino app, FlowDroid's hand-written
summary rules caused 15 false positives out of 36 ows in
total (41,7%) due to a single overly aggressive rule. Another
rule caused 1 false positive out of 3 ows (33,3%) in the
Broncos News app. The StubDroid summaries avoided all
of these false positives.
9. RELATED WORK
In this Section, we compare StubDroid to existing ap-
proaches for summarizing library behavior (Section 9.1) and
show a variety of existing work that can directly benet from
the summaries computed by StubDroid (Section 9.2).
9.1 Existing approaches for library summaries
The IFDS [15] framework, on which also FlowDroid is
based, already computes low-level method summaries to im-
prove eciency if the same method is called multiple times in
733Application Full Hand-Written StubDroid
Time (s) Memory (MB) Time (s) Memory (MB) Time (s) Memory (MB)
ArrayAccess1 21.13 458.19 5.75 128.10 5.63 132.66
HashMapAccess1 21.37 493.88 5.99 173.70 5.96 174.75
Alipay 45.10 6,271.49 5.57 1,727.78 5.51 1,640.99
Avira Antivirus Timeout Timeout 48.72 3,908.80 38.18 2,662.60
Broncos News Timeout Timeout 4.90 1,571.53 4.86 1,373.82
Hamburg Casino Timeout Timeout 57.73 3,352.54 48.17 3,856.88
OpenTable Timeout Timeout 81.51 7,596.06 78.01 5,669.13
Wikipedia 46.87 3,884.95 1.48 270.01 1.59 445.81
Table 2: Summary Application Performance (Benign Applications)
Full Hand-Written StubDroid
Family Apps TO Time (s) Mem (MB) TO Time (s) Mem (MB) TO Time (s) Mem (MB)
ADRD 22 22 n/a n/a 0 6.70 3,669.00 0 1.84 1,004.86
BaseBridge 121 115 25.03 1,210.95 7 17.53 525.03 0 6.54 311.30
DroidDream Light 46 45 63.30 1,222.58 0 7.41 7,309.21 0 5.26 451.32
Geinimi 69 69 n/a n/a 0 29.79 849.36 1 6.91 281.52
Table 3: Summary Application Performance (Malware), TO = # of apps where analysis timed out
the same program. These summaries, however, are linked to
the concrete context of the client analysis. Therefore, there
is no easy way to serialize and re-use these summaries for
multiple analysis runs, let alone dierent analyses. Naeem
and Lhot ak present a method for summarizing alias-analysis
information [14], but no further data-ow relationships. Stub-
Droid handles aliasing along with data ows. Aliases of
objects that get tainted inside a library are modeled as rst-
class taints which avoids a separate summary concept. Alias-
ing relationships with objects in the client program must be
computed anew for every client when applying the library
summary, so no further summarization is possible.
Zuhu et al. [22] analyze implementations of clients to au-
tomatically infer library specications. As they state, how-
ever, this requires an external oracle (e.g. a user consulting
the documentation) to verify every generated specication
candidate since the library code is not regarded at all. Stub-
Droid on the other hand is fully automatic and directly
analyzes the library implementations.
Rountev et al. [16] construct library summaries for IDE [17]
data-ow analyses by rst conducting a data-ow analysis on
the library and then abstracting away redundant data-ow
facts that are internal to the library. Rountev's approach,
however, does not discuss how summaries can actually be
abstracted in such a way that they can be persisted and can
become useful for dierent clients. In fact, it appears that
in their experiments the implementation stores and reuses
summaries only within one and the same analysis process.
F4F [18] by Sridharan et al. is a system for performing
taint analyses on framework-based web applications. It pro-
vides a specication language for modelling both the frame-
work behavior and information from conguration les. Sam-
ple generators for such specications are given for a number
of web application frameworks. While F4F focuses on dis-
patch logic between web pages and accesses to user controls
on them, StubDroid analyzes and summarizes data ows
in basic framework methods and is fully automated. No
specialized specication generator must be developed and
maintained when the target framework changes.
9.2 Approaches beneÔ¨Åting from summaries
Library summaries are required for various analysis tools
such as CHEX [13], which scans applications for potentialcases of datamisuse, e.g., when security vulnerabilities al-
low unauthorized access to an application's internal data.
Apposcopy [3] detects Android malware based on semantic
signatures describing data ows and inter-component com-
muncations. This requires a precise ow detection which in
turn needs precise library models. FlowDroid [1] is a data-
ow tracker that can also analyze the library code together
with the target application, but gains massive performance
benets from using library summaries as shown in this pa-
per. AppSealer [20] is a tool for automatically patching com-
ponent hijacking vulnerabilities in Android applications. It
combines static and dynamic data-ow analyses to nd vul-
nerable components to be patched. Library methods are
handled using a coarse-grained default rule (\return value of
method call is tainted if at least one parameter is tainted")
with a few hand-written exceptions. Scandal [8] statically
detects leaks of privacy-sensitive data in Android applica-
tions. The authors manually modeled the behavior of 220
commonly used Android framework methods to maintain
precision. StubDroid automatically computes the library
summaries required by these tools without the need for man-
ual inspection of the library code. DroidSafe [5] requires the
analyst to manually develop library stubs as Java code that
are simplied versions of the original implementations. The
authors have created 550 stub classes by hand which is a con-
siderable eort that could be evaded by using StubDroid 's
data-ow summaries instead.
10. CONCLUSIONS
We have presented StubDroid , the rst fully automated
approach for inferring library specications from binary dis-
tributions, e.g. of the Android operating system. The ap-
proach handles callbacks and aliasing. We have shown that
the generated summaries are complete, precise, and help
static taint analyses to save substantial computation time
and memory. As future work, we we plan to further increase
the performance of StubDroid and to apply it to other
commonly-used libraries for Android app development.
Acknowledgements.
This work was supported by the BMBF within EC SPRIDE
and by the DFG priority program Reliably Secure Software
Systems (RS3).
73411. REFERENCES
[1] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel,
J. Klein, Y. Le Traon, D. Octeau, and P. McDaniel.
Flowdroid: Precise context, ow, eld, object-sensitive
and lifecycle-aware taint analysis for android apps. In
Proceedings of the 35th ACM SIGPLAN Conference
on Programming Language Design and
Implementation, page 29. ACM, 2014.
[2] W. Enck, P. Gilbert, B. gon Chun, L. P. Cox, J. Jung,
P. McDaniel, and A. Sheth. Taintdroid: An
information-ow tracking system for realtime privacy
monitoring on smartphones. In OSDI , pages 393{407,
2010.
[3] Y. Feng, S. Anand, I. Dillig, and A. Aiken.
Apposcopy: Semantics-based detection of android
malware. Technical report, Stanford University, 2013.
submitted for publication.
[4] A. P. Fuchs, A. Chaudhuri, and J. S. Foster.
Scandroid: Automated security certication of android
applications. Manuscript, Univ. of Maryland,
http://www. cs. umd.
edu/avik/projects/scandroidascaa , 2(3), 2009.
[5] M. I. Gordon, D. Kim, J. Perkins, L. Gilham,
N. Nguyen, and M. Rinard. Information-ow analysis
of android applications in droidsafe. In Proc. of the
Network and Distributed System Security Symposium
(NDSS). The Internet Society , 2015.
[6] W. Huang, Y. D. A. Milanova, and J. Dolby. Scalable
and precise taint analysis for android. Technical
report, Technical report, Department of Computer
Science, Rensselaer Polytechnic Institute, 2015.
[7] International Data Corporation. Worldwide quarterly
mobile phone tracker 3q12, Nov. 2012. http://www.
idc.com/tracker/showproductinfo.jsp?prod nid=37.
[8] J. Kim, Y. Yoon, K. Yi, and J. Shin. ScanDal: Static
analyzer for detecting privacy leaks in android
applications. In H. Chen, L. Koved, and D. S. Wallach,
editors, MoST 2012: Mobile Security Technologies
2012, Los Alamitos, CA, USA, May 2012. IEEE.
[9] D. King, B. Hicks, M. Hicks, and T. Jaeger. Implicit
ows: Can't live with 'em, can't live without 'em. In
R. Sekar and A. Pujari, editors, Information Systems
Security , volume 5352 of Lecture Notes in Computer
Science , pages 56{70. Springer Berlin Heidelberg,
2008.
[10] P. Lam, E. Bodden, O. Lhot ak, and L. Hendren. The
soot framework for java program analysis: a
retrospective. In Cetus Users and Compiler
Infastructure Workshop (CETUS 2011) , 2011.
[11] G. T. Leavens, A. L. Baker, and C. Ruby. Jml: A
notation for detailed design. In Behavioral
specications of Businesses and Systems , pages
175{188. Springer, 1999.
[12] S. Lortz, H. Mantel, A. Starostin, T. B ahr,
D. Schneider, and A. Weber. Cassandra: Towards acertifying app store for android. In Proceedings of the
4th ACM Workshop on Security and Privacy in
Smartphones & Mobile Devices , pages 93{104. ACM,
2014.
[13] L. Lu, Z. Li, Z. Wu, W. Lee, and G. Jiang. Chex:
Statically vetting android apps for component
hijacking vulnerabilities. In Proceedings of the 2012
ACM Conference on Computer and Communications
Security , CCS '12, pages 229{240, New York, NY,
USA, 2012. ACM.
[14] N. A. Naeem and O. Lhot ak. Faster alias set analysis
using summaries. In J. Knoop, editor, Compiler
Construction , volume 6601 of Lecture Notes in
Computer Science , pages 82{103. Springer Berlin
Heidelberg, 2011.
[15] T. Reps, S. Horwitz, and M. Sagiv. Precise
interprocedural dataow analysis via graph
reachability. In POPL '95 , pages 49{61, 1995.
[16] A. Rountev, M. Sharp, and G. Xu. Ide dataow
analysis in the presence of large object-oriented
libraries. In L. Hendren, editor, Compiler
Construction , volume 4959 of Lecture Notes in
Computer Science , pages 53{68. Springer Berlin
Heidelberg, 2008.
[17] M. Sagiv, T. Reps, and S. Horwitz. Precise
interprocedural dataow analysis with applications to
constant propagation. In TAPSOFT '95 , pages
131{170, 1996.
[18] M. Sridharan, S. Artzi, M. Pistoia, S. Guarnieri,
O. Tripp, and R. Berg. F4f: Taint analysis of
framework-based web applications. In Proceedings of
the 2011 ACM International Conference on Object
Oriented Programming Systems Languages and
Applications , OOPSLA '11, pages 1053{1068, New
York, NY, USA, 2011. ACM.
[19] O. Tripp, M. Pistoia, P. Cousot, R. Cousot, and
S. Guarnieri. Andromeda: Accurate and scalable
security analysis of web applications. In FASE 2013 ,
pages 210{225, 2013.
[20] M. Zhang and H. Yin. Appsealer: Automatic
generation of vulnerability-specic patches for
preventing component hijacking attacks in android
applications. Proceedings of the 21st Network and
Distributed System Security (NDSS) Symposium , 2014.
[21] Y. Zhou and X. Jiang. Dissecting android malware:
Characterization and evolution. In SP '12 , pages
95{109, Washington, DC, USA, 2012. IEEE Computer
Society.
[22] H. Zhu, T. Dillig, and I. Dillig. Automated inference
of library specications for source-sink property
verication. In C.-c. Shan, editor, Programming
Languages and Systems , volume 8301 of Lecture Notes
in Computer Science, pages 290{306. Springer
International Publishing, 2013.
735