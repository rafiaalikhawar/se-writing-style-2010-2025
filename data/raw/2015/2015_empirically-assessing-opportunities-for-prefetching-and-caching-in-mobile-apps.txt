Empirically Assessing Opportunities for
Prefetching and Caching in Mobile Apps
Yixue Zhao
University of Southern California
Los Angeles, California, USAPaul Wat
University of Southern California
Los Angeles, California, USA
Marcelo Schmitt Laser
University of Southern California
Los Angeles, California, USANenad Medvidović
University of Southern California
Los Angeles, California, USA
ABSTRACT
Networklatencyinmobilesoftwarehasalargeimpactonuserexpe-
rience,withpotentiallysevereeconomicconsequences.Prefetching
and caching have been shown effective in reducing the latenciesin browser-based systems. However, those techniques cannot be
directly applied to the emerging domain of mobile apps because of
thedifferencesinnetworkinteractions.Moreover,thereisalackof research on prefetching and caching techniques that may be
suitableforthemobileappdomain,anditisnotclearwhethersuch
techniques can be effective or whether they are even feasible. This
papertakesthefirststeptowardansweringthesequestionsbycon-
ductingacomprehensivestudytounderstandthecharacteristics
ofHTTPrequestsinover1,000popularAndroidapps.Ourwork
focusesontheprefetchabilityofrequestsusingstaticprogramanal-
ysis techniques and cacheability of resulting responses. We find
that there is a substantial opportunity to leverage prefetching and
caching in mobile apps, but that suitable techniques must take intoaccountthenatureofapps’networkinteractionsandidiosyncrasiessuchasuntrustworthyHTTPheaderinformation.Ourobservationsprovideguidelinesfordeveloperstoutilizeprefetchingandcaching
schemes in app development, and motivate future research in this
area.
CCS CONCEPTS
•Software and its engineering →Software performance;
KEYWORDS
prefetching,caching,mobileapps,networklatency,empiricalstudy
ACM Reference Format:
Yixue Zhao, Paul Wat, Marcelo Schmitt Laser, and Nenad Medvidović. 2018.
EmpiricallyAssessingOpportunitiesforPrefetchingandCachinginMobile
Apps. In Proceedings of the 2018 33rd ACM/IEEE International Conference on
Automated Software Engineering (ASE ’18), September 3–7, 2018, Montpellier,
France.ACM,NewYork,NY,USA, 11pages.https://doi.org/10.1145/3238147.
3238215
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ’18, September 3–7, 2018, Montpellier, France
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.32382151 INTRODUCTION
There are over 5 billion mobile phone users and millions of mobile
appstoday[ 22].Thelatencyinmobileappshasbeenshowntohave
a large impact on user experience and potentially severe economic
consequences [ 43]. The main cause of user-perceived latency is
the network, since the majority of mobile apps fetch data from the
Internet regularly [ 33].1Moreover, mobile devices rely on wireless
networks, which can exhibit intermittent connectivity and low
bandwidth [21].
Optimizingnetworkperformancehaslongbeenstudiedindis-
tributedsystems,andprefetchingandcachingtechniqueshavebeen
shownasahigh-rewardwaytoreducenetworklatency:theycanby-passtheperformancebottleneck(networkspeed)andmasklatency
by returning a response to a request from a local cache immedi-
ately[21].Whileprefetchingmakesuseofbuilt-incachingschemes,
caching-onlytechniquesarealsowidelyemployed(e.g.,[ 31,46]).In
thiswork,westudythetworelatedphenomenaseparately: prefetch-
abilityinvolves prefetching plus caching, while cacheability in-
volves only caching.
The research on prefetching and caching techniques in the web
browserdomainhasyieldedalargebodyofwork[ 12,26,28,34,36,
38,40,43]. However, the resulting techniques cannot be applied to
mobileappsduetotheirdifferentrootcausesofnetworklatency.In
the browser domain, the bottleneck for latency is resource loading
sincealargenumberofresources—usuallyfilessuchasimages—are
needed within each HTTP request [ 42]. In the mobile app domain,
eachrequestonlyfetchesasingleresponse,andadditionalrequestsneedtobeissuedexplicitlytofetchfurtherresources[
23,49].Thus,
prefetching and caching techniques in the browser domain tar-
getsubresources withinasinglerequest [ 26,34,40,43],while the
researchinthemobileappdomainfocusesonseparateHTTPre-
quests [46, 49].
Mobile users currently spend more than 80% of their time in
mobile apps, rather than using mobile browsers [ 14]. Aside from a
couple of exceptions, there has been a lack of research on prefetch-
ing and caching techniques that may be suitable for the mobileapp domain. In fact, it is currently not clear whether such tech-
niquescanbeeffectiveorwhethertheyareevenfeasibleinpractice.CacheKeeper[
46]madeaninitialefforttostudytheredundantweb
traffic in mobile apps and proposed an OS-level caching service.
However, the resulting service was only evaluated on 10 apps. Fur-
thermore,CacheKeeper’sperformancehighlydependsontheflaws
1In this context, we define latency as the response time of an HTTP request.
554
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Yixue Zhao, Paul Wat, Marcelo Schmitt Laser, and Nenad Medvidović
in the web caching strategies employed in the original app, and
its broader utility is unclear. Our previous work PALOMA [ 48,49]
used program analysis to identify HTTP requests that should be
prefetchedin mobileapps. Wehighlightedseveral programanaly-
sis challenges that can improve prefetching if addressed. However,
PALOMAwasevaluatedon32apps.Itisthusuncleartowhatextent
PALOMAwillbeeffectiveatalargerscale,andwhetheraddressing
the identified program analysis challenges is worthwhile.
The dearth and shortcomings of previous work motivated us to
conduct a more extensive empirical study that aims to understand
the characteristics of HTTP requests in mobile apps. In this paper,
we report our results from the automated analysis of 1,687 most
popularAndroidapps,spreadacross33appcategories.Ourworkfo-cusesontheprefetchabilityofrequests(PALOMA’sproblemspace)
and cacheability of resulting responses (CacheKeeper’s problem
space).WefoundthatalargenumberofHTTPrequestsusedinrealappsareprefetchableandtheresponsestothoserequestscacheable.
This has the potential for significant reductions in user-perceived
latency,whichwould,inturn,rendertheuseofcertainmobileapps
even more attractive.
Atthesametime,ourstudyhighlightedtheneedtocarefullycon-
sider which requests should be prefetched and which data cached,
for two reasons. First, we empirically demonstrated the frequentlack of discipline with which developers use the relevant HTTP
headers in mobile (specifically, Android) apps, making those head-
ersmisleading.Second,weshowedthatresponsestocertainHTTP
requests that seem like good candidates for caching may yield
incorrect app behaviors due to cache staleness.
Our study is the first to provide extensive empirical evidence
regardingthe opportunitiesforprefetching andcachingin mobile
apps. It is also the first to identify concrete shortcomings in the
currentappdevelopmentpracticesthatareguaranteedtohinder
solutionsthatmayotherwiseseemeasyandintuitive.Asaresult,
the study has the potential to motivate significant future research
in this area. In this paper, we have identified several promising
research directions.
The remainder of the paper is organized as follows. Section 2
overviewstheHTTPprotocolanditsuseinthemobileappdomain.
Section3motivates and states our research questions. Section 4
describesourcollectionandprocessingofthesubjectapps.Section 5
discussesourfindingsandSection 6describesthethreatstotheir
validity. A discussion of related work and conclusions round out
the paper.
2 BACKGROUND
In this section, we overview aspects of the HTTP protocol thatare relevant to prefetching and caching. We then illustrate with
concrete examples of how developers perform network operations
in mobile apps, with a particular focus on Android.
2.1 HTTP Protocol
Previous studies have shown that mobile apps spend between 34%
and 85% of their time fetching data from the Internet [ 33]. The
majorityofappsrunoverHTTP[ 15],whererequestsaresentby
clients and responses returned by servers.AnHTTP request consistsofanHTTPmethod,thedestination
of the resource to fetch (i.e., the URL), and request headers andbody, both of which are optional. The HTTP method—
GET,POST,
DELETE,etc.—needstobespecifiedbydeveloperswhensendinga
request.Optionalrequestheadersallowtheclienttopassadditional
information to the server [ 17], such as Accept-Language: en-US .
The request body contains the resource to send to the server, but is
only needed for “write” HTTP methods, such as POST.
HTTP 1.1 [ 18] defines eight methods. Some of them, such as
DELETE, are not suitable for prefetching because they may change
the server’s state contrary to the user’s intention. Only the GET
andHEADmethodsareconsidered“safe”,inthattheyresultinthe
retrieval of data and do not have any side-effects on the server [ 19,
20]. TheHEADmethod is similar to GET, except that its response
does not contain a message body [ 19]. Thus,GETrequests are of
particular interest in our study.
AnHTTP response consists of a status code, a status message,
and response headers and body, both of which are optional. The
statuscodeandstatusmessageindicatewhethertherequestwas
successfulornot,andwhy.Theresponsebodycontainsthefetchedresourcefromtheserver.Responseheaderscontainadditionalinfor-
mation that is often used by developers to decide on their caching
strategies. For example, the Expires header specifies when the re-
sponsewillbecomestale,while Cache-Control headercontainsthe
informationpertainingto cachingmechanismssuchas no-cache
andmax-age.Interestingly,asobservedinourstudy(seeSection 5),
thoseheaderscannotalwaysbetrustedbydevelopers,andsome-
times they are missing altogether.
1URL url = newURL("http://www.ase.com/post");
2URLConnection conn = url.openConnection();
3conn.setRequestMethod("POST");
4conn.setRequestProperty("Accept-Language", "en-US");
5OutputStreamWriter wr = newOutputStreamWriter(conn.getOutputStream());
6wr.write("post_data_to_send");
7wr.flush();
8InputStream responseStream = conn.getInputStream();
9Map headerMap = conn.getHeaderFields();
Listing1:SendingaPOSTrequestusingtheURLConnectionlibrary
1OkHttpClient client = newOkHttpClient();
2Request request = newRequest.Builder()
3 .url("http://www.ase.com/post")
4 .addHeader("Accept-Language", "en-US")
5 .post("post_data_to_send")
6 .build();
7Response response = client.newCall(request).execute();
8Headers headers = response.headers();
Listing 2: Sending a POST request using the OkHttp library
2.2 HTTP Libraries Used in Mobile Apps
In Android apps, developers use off-the-shelf HTTP libraries tointeract with servers. Listing 1and Listing 2demonstrate how
developers send HTTP requests and receive responses using the
twomostpopularHTTPlibrariesforAndroid: URLConnection and
OkHttp.
WhensendingHTTPrequests,developersneedtospecifythe
URLoftheresourcetobefetched(Listing 1:line1,Listing 2:line3),
HTTPmethod(Listing 1:line3,Listing 2:line5),requestheaders
555
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. Empirically Assessing Opportunities for Prefetching and Caching in Mobile Apps ASE ’18, September 3–7, 2018, Montpellier, France
(line4inbothListings),andrequestbody(Listing 1:line6,Listing 2:
line 5). Only the URL is mandatory and GETmethod will be used
by default if the HTTP method is not specified (e.g., if line 3 in
Listing1andline5inListing 2areremoved).WhenreceivingHTTP
responses, developers can retrieve the response body (Listing 1:
line8,Listing 2:line7)aswellastheresponseheaders(Listing 1:
line 9, Listing 2: line 8) that may contain caching information.
3 RESEARCH QUESTIONS
The goal of this paper is to understand whether prefetching and
caching can be applied to the mobile app domain effectively, in
ordertoreduceuser-perceivedlatency.Weformulatednineresearch
questions (RQs) to this end. These RQs target the prefetchability of
HTTP requests, cacheability of HTTP responses, and redundancies
among HTTP requests.
3.1 Prefetchability of HTTP Requests
Our objective is to assess the extent to which requests in mobile
apps are prefetchable. Prefetchable requests are read-only requests
that have no side-effects on the server state. As discussed above
(Section2.1), in the context of the HTTP protocol these are GET
requests [ 19]. Furthermore, we study whether the prevalence of
prefetchablerequestsvariesacrossdifferentappcategories.Such
variationsmayallowidentifyingappcategoriesthatareparticularly
suitable for prefetching.
We formulate three research questions to this end:
•RQ1– What is the number of GETrequests per app?
•RQ2– What is the percentage of GETrequests among all
HTTP requests in mobile apps?
•RQ3– How prevalent are GETrequests across different app
categories?
3.2 Cacheability of HTTP Responses
A prefetchable request may not be cacheable if the response to the
requestchangesovertime(e.g.,inthecaseofweatherdata).Insuch
cases,thecachedresponsemaybestaleandservingitwouldlead
to incorrect app behavior. To determine when a response becomes
stale,orwhetherarequestiscacheableatall,developershavetorely
on the header information specified in the response, specifically,
ExpiresandCache-Control (recall Section 2.1). However, there
are no standard rules for developers to follow when constructing a
response, leaving open the possibility that header information may
be unreliable or even missing.
To investigate this, we formulate four additional research ques-
tions:
•RQ4– How prevalent are Expiresheaders?
•RQ5–A r eExpires headers trustworthy?
•RQ6– How prevalent are Cache-Control headers?
•RQ7–A r eCache-Control headers trustworthy?
3.3 Identifying Truly Redundant HTTP
Requests
Cachingisonlyeffectivewhenthereexistredundantrequestsfor
the same resource. An HTTP request is redundant if a previous
request specified the same HTTP method and URL, and yieldedthesameresponse;thelaterrequestisredundantbecausetheorigi-
nalresponsecouldhavebeenstoredlocallyandreused.Previous
work[46]suggestsanopportunityformobileapp-basedcaching
techniques, in that it identified the presence of redundant HTTP
traffic and showed that implementations of web caching are inade-
quateformobileapps.Ourworkgoesbeyondidentifyingredundant
HTTP requests and tries to assess the intent behind them. A set of
ostensibly redundant requests could be generated on purpose (e.g.,
toretrieveupdatedweatherinformation),andthusmaynotbe truly
redundant. If a caching scheme fails to consider this, it will lead
to cache staleness. We thus consider the actual responses to the
candidateredundantrequests,aimingtodistinguishamongthem
and provide better insights for future caching techniques in mobile
apps.
With this in mind, we formulate the last two research questions:
•RQ8– How prevalent are redundant HTTP requests?
•RQ9–Aretheidentifiedostensiblyredundantrequeststruly
redundant?
4 DATA COLLECTION
This section details (1) the workflow we used for data collection,
(2) the criteria behindour selection of subject apps, (3)app instru-
mentation, (4) our collection of data via runtime testing, and (5)the reasons for eliminating certain apps from the subject set be-
fore conducting further analysis. All of the raw data regarding our
subject apps and the corresponding code are publicly available [ 9].
4.1 Data Collection Workflow
Figure1illustratestheworkflowweimplementedforcollectingthe
data needed to answer the nine research questions stated above.
The initial subject apps were downloaded from the Google Play
Store(Section 4.2).Theappswereautomaticallyinstrumentedbased
on the information extracted from HTTP library documentation
and the decompiled code of several sample apps (Section 4.3). The
instrumented apps were automatically tested using randomly gen-erated inputs to produce logs that contain the information needed
to answer RQ 1–RQ4,RQ6,and RQ 8(Section4.4).Wemanually ex-
aminedtheappsthatcouldnotbetestedduetoproblemssuchas
installationfailuresandruntimecrashes,toidentifytherootcauses
of the problems (Section 4.5). Finally, we automatically sent GET
requeststothesubjectappsatdifferenttimeintervals,toanswer
RQ5,R Q7, and RQ 9(Sections 5.2and5.3).
4.2 Initial Set of Subject Apps
Wedownloaded1,687top-rankedappsacross33categoriesfrom
the Google Play Store in the United States. 1,308 of the apps could
be processed by Soot [ 37], a state-of-the-art tool for instrumenting
Androidapps,asfurtherdiscussedinSection 4.3.Thesizesofthose
1,308 apps vary between 16 KB and 103.4 MB. The total number of
HTTP requests per app varied between 0 and 1,243 in our tests, as
described in Section 4.4.
Table1summarizestheinformationaboutthe1,308subjectapps.
The table shows the maximum and average numbers of HTTP
requestsperappforeachcategory;theminimumnumberofHTTP
requestsineverycategoryis0andwethusomititfromthetable.
Finally,theright-mostcolumnshowsthenumberofappsineach
556
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Yixue Zhao, Paul Wat, Marcelo Schmitt Laser, and Nenad Medvidović
Figure 1: Our data collection workflow. The App Profiling, App Instrumentation, App Testing, and Send GET Requests compo-
nents perform automated tasks.
category that sent at least four HTTP requests in our tests, as well
as the percentage of such apps compared to the total number of
apps in the given category. The reason behind highlighting this
subset of the 1,308 subject apps will be explained in Section 4.5.
4.3 App Instrumentation
Each subject app went through an automated instrumentation pro-
cess offline that used Soot [ 37] to insert code that captures infor-
mation about HTTP requests and responses. This information is
primarilylocatedintheHTTPheaders.Capturingsuchinformation
inthebrowserdomainisstraightforwardbecauseHTTPrequests
and responses are managed in a unified way. On the other hand,mobile apps presented a challenge: we first had to identify how
theHTTPrequestsandresponsesarehandledindifferentHTTP
libraries (recall Section 2.2); only then could we instrument the
corresponding code to capture this information automatically.
It was thus necessary to determine what libraries most apps use
tosendHTTPrequests.WefirstidentifiedasetofpopularHTTP
libraries, including URLConnection [7],OkHttp[4],Volley[8],
andRetrofit [5].We thenanalyzed asampleof thesubjectapps’
bytecodes and checked the package names against the libraries.
For example, the presence of the string “java.net.URLConnection”
generally indicates the use of the URLConnection library.
The data gathered from our analysis point to URLConnection
andOkHttpasthemostpopularHTTPlibrariesusedinthesubject
apps. This is unsurprising: URLConnection is the standard built-in
library of the Android framework, and it has been augmented with
OkHttpsinceAndroidv.4.4(KitKat).Wethusdecidedtofocuson
URLConnection andOkHttpin our study.
We then performed a more detailed analysis of how our subject
apps use these two libraries. We recorded the runtimes of those
methods that are importedfrom URLConnection andOkHttp, and
narrowedourfocustomethodsthataremosttime-consuming.The
rationale isthat those are mostlikely to be themethods related to
sending requests and receiving responses over the network.
In addition, we inspected the decompiled code of the subject
apps,aswellasthedocumentationandsourcecodeoftheHTTP
libraries used in the apps, to identify the actual usage of HTTPrequestsandresponses.Thereasonforthisadditionalinspection
isthatdeveloperssendrequestsandreceiveresponsesinvarious
ways, even when using the same HTTP library. Listings 1and2
inSection 2onlydemonstrateonecommonwayofusingeachof
the two HTTP libraries. While recommended in thelibraries’ docu-
mentation, there is no requirement or guarantee that developers
will followthis guidance intheir apps. Furthermore,the examples
Table 1: App information for each category among initial
subjects
Category #Apps Max #Req Avg #Req #Apps (#Req ≥4)
1. Art & Design 11 14 2.27 3 (27.27%)
2. Auto & Vehicles 29 6 1.07 4 (13.79%)
3. Beauty 11 1243 120.82 6 (54.55%)
4. Books & Reference 40 108 11.58 16 (40%)
5. Business 55 87 5.71 17 (30.91%)
6. Comics 55 319 20.84 19 (34.55%)
7. Communications 40 96 3.98 8 (20%)
8. Dating 16 334 29.94 6 (37.5%)
9. Education 55 62 4.98 17 (30.91%)
10. Entertainment 28 134 12.36 11 (39.29%)
11. Events 8 53 14.13 5 (62.5%)
12. Finance 61 150 15.97 27 (44.26%)
13. Food & Drink 28 188 16.43 13 (46.43%)
14. Games 37 59 12.59 25 (67.57%)
15. Health & Fitness 41 14 3.44 15 (36.59%)
16. House & Home 25 149 17.96 8 (32%)
17. Libraries & Demo 45 22 0.6 1 (2.22%)
18. Lifestyle 21 82 12.48 12 (57.14%)
19. Maps & Navigation 54 206 8.37 8 (14.81%)
20. Medical 59 63 2.8 10 (16.95%)
21. Music & Audio 43 44 5.47 14 (32.56%)
22. News & Magazines 49 802 37.71 26 (53.06%)
23. Parenting 24 28 2.54 5 (20.83%)
24. Personalization 31 288 29.61 11 (35.48%)
25. Photography 43 58 7.72 14 (32.56%)
26. Productivity 68 119 8.31 24 (35.29%)
27. Shopping 46 198 21.54 22 (47.83%)
28. Social 48 108 10.4 23 (47.92%)
29. Sports 43 146 19.42 18 (41.86%)
30. Tools 54 130 6.44 16 (29.63%)
31. Travel & Local 63 208 14.33 27 (42.86%)
32. Video Players & Editors 47 134 5.89 8 (17.02%)
33. Weather 30 123 14.7 12 (40%)
Total 1308 1243 50.20 451 (34.48%)
557
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. Empirically Assessing Opportunities for Prefetching and Caching in Mobile Apps ASE ’18, September 3–7, 2018, Montpellier, France
in the documentation are at the source code level, while our in-
strumentation using Soot [ 37] is at the bytecode level. This meant
that we needed to understand the actual usage of those two HTTP
librariesatthebytecodelevel.Withtheadditionalinspection,we
were able to identify the actual methods used for sending requests
and receiving responses in the apps, allowing us to instrument the
codetocapturethepreciseinformationneededforourstudy.For
example,line9inListing 1definesheaderMap thatcontainsallof
the header information; our instrumentation then inserts a method
after line 9 to capture the headers relevant to our study, such as
Expires header.Itisimportanttonotethattheinstrumentedapps’
primary functionality is left unchanged in this process.
4.4 App Testing
Aftertheinstrumentation,eachappwassubjectedtorandominput
testingthroughAndroidDebugBridge(adb)[ 1].WeusedtheUI/Ap-
plication exerciser tool Monkey [ 6] to generate random streams of
userevents,suchasclicks,touches,andswipes.Weusedrandom
events in this study for two reasons: (1) to avoid bias introduced
byparticularuserbehaviorsand(2)togeneratelargevolumesof
runtime requests automatically, which would not be practical if
we reliedon ahuman user.This isfurther discussedin Section 6.
TheappswererunontheNoxPlayerAndroidemulator[ 3].Each
testconsistedof3,000eventsunderWiFinetworksettings.Wealso
exploredtestingwith1,000,5,000,and10,000events.Wefoundthat
3,000 was the smallest number of events that yielded a represen-tative number of HTTP requests triggered at runtime across the
subjectapps;neither5,000nor10,000eventsresultedinasignificantincreaseinHTTPrequests,while1,000eventsprovedtobetoofew
to adequately exercise the relevant functionality in the apps.
Alltestswereprecededbyafreshinstallationofthegivensubject
app, andthe appwas removedfrom theemulator aftereach test’s
conclusion. This minimized the chances of errors caused by any
interference between apps or by previously saved settings.
4.5 Final Set of Subject Apps
TheobjectiveofourstudyistodeterminewhetherandwhenHTTP
requests should be prefetched and their responses cached. In some
cases,thenumberofHTTPrequeststriggeredinourtestswasvery
low,suggestingthatprefetchingandcachinginsuchappswould
notbebeneficial.Todeterminethenatureof“lownetworkusage”
appsandtheunderlyingreasonsbehindthedataweobtained,we
manuallyinspectedeachapp,startingwiththosethatdonottrigger
any requests.
Atotalof623outofthe1,308subjectappstriggerednorequests.
We identified six recurring reasons behind this:
(1) The app’s installation failed.(2) The app crashed upon launching.(3)
The app’s version was incompatible with the NoxPlayer
Android emulator [3].
(4)The app was obfuscated so that the methods relevant to
HTTP requests were not captured by our instrumentation.
(5)The app required external information before it could be
used, such as a bank PIN (commonly required in the Finance
category)oravehiclelicenseplate(commonlyrequiredin
theAuto & Vehicles category).(6)The app only contained static content and did not rely on
the network.
Note that, while we could not automatically test the above apps,
many of them may, in fact, trigger HTTP requests at runtime. The
only exception are apps from the last category. The automated
nature of our app testing prevented us from determining the exact
numbers of apps that fell in each of the above six categories. Amanualinspectionofarandomsampleoftheappssuggeststhat,
with a 95% confidence level, no more than 50% of the 623 apps
contained only static content.
Anadditional234ofthe1,308subjectappstriggered1-3requests
at runtime. We observed a common pattern among these apps.
Namely,regardlessofthetypeofapp,thoserequeststendedtobe
one or more of the following:
(1) Load an application-specific configuration file.(2) Log in with Facebook using Facebook GraphRequest.
(3)
Use monitoring services, such as Crashlytics orGoogle
Analytics.
FurthermanualtestingoftheseappsyieldednoadditionalHTTP
requests beyond the above three. This finding shows a common
usageofpopularthird-partyservicesinmobileappdevelopment,
whoseimpactonappperformanceshouldalsobetakenintoaccount
in terms of overhead, data usage, and energy consumption.
Wewereunabletoidentifyanypatternssuchastheaboveinapps
thattriggeranyothernumberofrequests.Thus,thebelowanalysis
ofprefetchability andcacheability is based on 451 of our subject
appsthattriggerfourormorerequestsatruntime,corresponding
to the right-most column of Table 1.
5 RESULTS AND DISCUSSION
This section describes the results of our analysis, framed by the
nineresearchquestionsfromSection 3,anddiscussesthelessons
learnedfromtheresults.Table 2summarizestheinformationabout
the final set of 451 subject apps in each category that are analyzed
in this section. Note that the app categories are numbered 1-33, to
aidthedepictionandunderstandingofthefiguresintheremainderof this section. Among the 451 apps, the number of HTTP requestsrangedbetween4(thecut-offnumberforouranalysis,asdiscussed
above)and1,243,withtheaverageslightlyabove35requestsper
app.
5.1 Prefetchability of HTTP Requests
RecallfromSection 3thatwetrytoanswerthreeresearchquestions
regardingtheprefetchabilityofHTTPrequests.Specifically,weare
interested in GETrequests, which are the primary candidates for
prefetching.
•RQ1– What is the number of GETrequests per app?
•RQ2– What is the percentage of GETrequests among all
HTTP requests in mobile apps?
•RQ3– How prevalent are GETrequests across different app
categories?
To answer the above questions, we instrumented and tested our
subject apps using the procedure described in Section 4. We calcu-
latedthetotalnumberof GETrequestsobservedduringourtesting,
558
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Yixue Zhao, Paul Wat, Marcelo Schmitt Laser, and Nenad Medvidović
and the percentage of GETrequests among all HTTP requests trig-
gered at runtime in each app. We subsequently grouped the results
by app category. Figure 2depicts the minimum, maximum, and
average numbersofGETrequests per app (RQ 1) across the differ-
ent categories (RQ 3). Figure 3depicts the minimum, maximum,
andaverage percentages ofGETrequestsas comparedtoall HTTP
requests (RQ 2) in each app category (RQ 3).
Ourdataindicatethat GETrequestsarepervasiveacrossall33app
categories.AsshowninFigure 2,sevencategoriescontainedapps
that sent 150 or more GETrequests. On average, an app sent 28 GET
requests,andthoserequestscomprised68%ofallHTTPrequests
sentbytheapp.AsshowninFigure 3,severalcategories— Beauty
(94%), Comics(87%), Entertainment (88%), and Events(87%)—had
veryhighpercentagesof GETrequests.Onlytwocategories—Dating
(43%) and Tools(44%)—had slightly fewer than 50% of GETrequests.
Theseresultssuggestthatthereisasignificantopportunityto
exploit prefetching among the 451 subject apps that sent 4 or more
HTTP requests. It was surprising to see that 102 apps, spanning
29ofthe33categories,sentonly GETrequests.Certaincategories
are potentially more suitable for prefetching than others. This is
a by-product of the types of functionality that are typical in agiven category. The nature of apps in “stable” domains, such asArt & Design orLibraries & Demo, is such that they may be able
Figure 2: Minimum (bottom edges), maximum (top edges),and average (horizontal dashes) numbers ofGETrequests in
apps across the 33 app categories. Apps in 7 categories hadmaximums higher than 150 (numbers displayed beside thecorrespondingbars).Notethattheaverageforappcategory3 is also higher than 150, and thus not shown.
Figure 3: Minimum (bottom edges), maximum (top edges),and average (horizontal dashes) percentages ofGETrequests
in apps across the 33 app categories.to operate with less remotely accessed data than apps in more
“dynamic” domains such as News & Magazines orShopping. This
suggeststhatprefetchingandcachingtechniquesmaybenefitfrom
leveraging knowledge regarding an app’s domain.
Table2:Appinformationforeachcategoryamongfinalsub-
jects
Category #Apps Min. #Req Max. #Req Avg. #Req
1. Art & Design 3 4 14 8.33
2. Auto & Vehicles 4 4 6 4.75
3. Beauty 6 4 1243 220.33
4. Books & Reference 16 4 108 27.94
5. Business 17 4 87 17.24
6. Comics 19 4 319 59.58
7. Communications 8 4 96 19
8. Dating 6 5 334 78.83
9. Education 17 4 62 15.06
10. Entertainment 11 6 134 30.73
11. Events 5 11 53 22.2
12. Finance 27 5 150 35.59
13. Food & Drink 13 4 188 33.46
14. Games 25 4 59 18
15. Health & Fitness 15 4 14 8.13
16. House & Home 8 4 149 55.38
17. Libraries & Demo 1 22 22 22
18. Lifestyle 12 4 82 21
19. Maps & Navigation 8 8 206 54.88
20. Medical 10 4 63 14
21. Music & Audio 14 5 44 16.14
22. News & Magazines 26 4 802 70.88
23. Parenting 5 4 28 12
24. Personalization 11 6 288 82.73
25. Photography 14 4 58 23
26. Productivity 24 4 119 22.67
27. Shopping 22 4 198 44.14
28. Social 23 4 108 20.35
29. Sports 18 7 146 45.67
30. Tools 16 4 130 21.44
31. Travel & Local 27 4 208 32.11
32. Video Players & Editors 8 4 134 33.63
33. Weather 12 7 123 36.17
Total 451 4 1243 35.28
5.2 Cacheability of HTTP Responses
As discussed in Section 3, the cacheability of HTTP responses is
a function of the presence of Cache-Control andExpireshead-
ers, and their trustworthiness. To that end, we try to answer the
following four research questions.
•RQ4– How prevalent are Expires headers?
•RQ5–A r eExpires headers trustworthy?
•RQ6– How prevalent are Cache-Control headers?
•RQ7–A r eCache-Control headers trustworthy?
Toanswertheabovequestions,weinstrumentedthesubjectapps
tocaptureresponseheaders (recallSection 4.3)andcalculate the
numbers of occurrences of the two relevant headers. To determine
whethertheheaderofagivenrequestistrustworthy,wemadeeach
request4times:atinitialtime t,t+10, t+30,and t+60seconds.
This allowed us to determine whether later responses reflect what
is specified in the header of the original response.
For example, let us assume that the original request is sent at
time(t)andthattheresponseheadercontains Expires: time(exp) .
559
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. Empirically Assessing Opportunities for Prefetching and Caching in Mobile Apps ASE ’18, September 3–7, 2018, Montpellier, France
Figure 4: Minimum (bottom edges), maximum (top edges),
andaverage(horizontaldashes) numbers ofExpiresheaders
in each app category. Apps in 11 categories had maximumshigher than 30 (numbers displayed beside or above the cor-responding bars).
Figure 5: Minimum (bottom edges), maximum (top edges),and average (horizontal dashes) percentages of the Expires
headers for each app category.
Figure 6: Minimum (bottom edges), maximum (top edges),and average (horizontal dashes) percentages of trusted
Expiresheaders in each app category.
We will mark the header as untrustworthy if it falls into any of the
following three cases, where xis the time period after the original
request is sent:
(1)time(exp) <=time(t)
(2) (time(t) <time(exp) ≤time(t+x))
∧(response@(t) =response@(t+x))
(3) (time(exp) >time(t+x))
∧(response@(t) /nequalresponse@(t+x))
Figure 7: Minimum (bottom edges), maximum (top edges),and average (horizontal dashes) numbers ofCache-Control
headersineachappcategory.Appsin14categorieshadmax-imums higher than 30 (numbers displayed beside or abovethe corresponding bars).
Figure 8: Minimum (bottom edges), maximum (topedges), and average (horizontal dashes) percentages of
Cache-Control headers in each app category.
Figure 9: Minimum (bottom edges), maximum (top edges),and average (horizontal dashes) percentages of trusted
Cache-Control headers in each app category.
In our case, xis any of 10 s,3 0 s,o r6 0 s. The first case indicates
a scenario where the response expires before the request is evensent. The second case indicates a scenario where the response is
supposed to have expired, but ithas remained unchanged. Finally,
the third case indicates a scenario where the response should have
remained the same, but it changed.
Weusetheanalogousalgorithmtodeterminewhetherthe Cache-
Controlheaderistrustworthy,basedonthe max-agefieldspecified
within the header.
560
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Yixue Zhao, Paul Wat, Marcelo Schmitt Laser, and Nenad Medvidović
Figure4shows the minimum, maximum, and average numbers
oftheExpiresheadersincludedinHTTPresponsesforeachapp
category(RQ 4).Figure5showstheminimum,maximum,andav-
erage percentagesof the Expiresheaders amongall theresponse
headers in each app category (RQ 4). Figure6shows the percent-
ages of the trustworthy Expiresheaders among all the Expires
headers (RQ 5). Figures 7,8, and9show the analogous information
for theCache-Control header (RQ 6,RQ7).
Fromtheresults,wecanconcludethatthe Expires headersand
Cache-Control headers are not always included in the responses,
andtheyarenotalwaystrustworthy.The Cache-Control header
tendstobeusedmorereliablythanthe Expires header.Acrossthe
33 app categories, 53% of the response headers contain Expires
on average, while 65% contain Cache-Control . Only an average
of 25% of the Expiresheaders are trustworthy, while 77% of the
Cache-Control headersaretrustworthy.Whilethereareindividual
appsamong oursubjectswhere eachof thetwoheaders wasused
in a completely trustworthy manner (100%), there were an even
greater number of apps where the opposite was true (0%).
These results strongly suggest that developers should not de-
pend on the response headers to determine their caching schemes.
Unfortunately,therearecurrentlynoreliablealternativesforthe
mobile app domain. However, this presents a research opportunity
toinvestigatemoreintelligentapproaches.Onestrategythatsug-
gests itselfbased on ourstudy would involve learning the correct
informationtoincludeintheheadersbasedonhistoricaldata.Such
a technique could then automatically suggest app modifications, in
order to fix the “buggy” headers.
5.3 Identifying Truly Redundant HTTP
Requests
AsdiscussedinSection 3,redundantHTTPrequestsaregoodcandi-
datesforprefetchingandcaching.However,certainHTTPrequests
are only ostensibly redundant in that they seem identical but actu-
ally yield different responses. Our final two research questions aim
to shed light on this issue.
•RQ8– How prevalent are redundant HTTP requests?
•RQ9–Aretheidentifiedostensiblyredundantrequeststruly
redundant?
In our analysis, we have specifically focused on GETrequests, as
discussed previously.
To answer the above questions, upon completion of testing a
givenapp(byexecutingthe3,000eventsasexplainedinSection 4.4),
weidentifytheostensiblyredundantrequestsineachapp.Wethen
runascriptthatexecutestheappbysendingeachidentifiedrequest
four times: at initial time t,t+10, t+30, and t+60 seconds. We
checkwhethertheresponseschangeduringthisinterval.Thishelps
to identify HTTP requests that are truly redundant; the responses
to those requests are thus suitable candidates for caching.
Figure10shows the minimum, maximum, and average percent-
agesoftheidentifiedostensiblyredundantrequestsascomparedto
the total number of requests in each app category (RQ 8). Figure11
showstheminimum,maximum,andaverageexpirationtimesfor
the identified requests (RQ 9). A request’s expiration time is the
timeatwhichitsresponseisdifferentfromtheresponsereceivedfortheinitialrequestattime t.Finally,Figure 12showsthemini-
mum,maximum,andaveragepercentagesofthe trulyredundant
requests (RQ 9).
AsFigure 10shows,redundantrequestscompriseasignificant
proportion of all HTTP requests across most of the app categories.
Incertainapps,nearly100%oftherequestsareredundant,while
the average across all apps is ≈20%. By themselves, these results
would suggest considerable cacheability potential.
This is further bolstered by some of the results in Figure 11,
whichpointstoseveralappsinwhichtheHTTPrequestsdidnot
Figure 10: Minimum (bottom edges), maximum (top edges),
andaverage(horizontaldashes)percentagesof ostensibly re-
dundant requests in each app category.
Figure 11: Minimum (bottom edges), maximum (top edges),and average (horizontal dashes) expiration times for the re-
dundant requests in each app category.
Figure 12: Minimum (bottom edges), maximum (top edges),and average (horizontal dashes) percentages of trulyredun-
dant requests in each app category.
561
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. Empirically Assessing Opportunities for Prefetching and Caching in Mobile Apps ASE ’18, September 3–7, 2018, Montpellier, France
expire even after the full 60s. However, this is somewhat deceptive:
The average request expiration time was 12s across the 33 app
categories;itwasexactly10sforseveralofthecategories;andonly
two categories—Food & Drink and House & Home —had average
expiration times over 20s. Since 10s was the shortest interval used
in our study, these results suggest that most redundant requests
expirewithinarelativelyshorttimeperiod.Thisshouldbetaken
into account when devising caching schemes for mobile apps.
Finally, Figure 12shows that, on average, an overwhelming ma-
jorityofostensiblyredundantrequestsare truly redundant across
the 33 app categories. This means that the ostensibly redundant
requestdidnotexpireatoneormoreofthe10s,30s,and60scheck-
points. In a number of individual apps, all ostensibly redundant
requestsaretrulyredundant(themaximumvalueof100%),while
their average for app categories is as high as 92%. This observation
showsalargeopportunityforcachingredundantrequestsinmobile
apps.
5.4 Implications
Our study provides evidence that prefetching and caching can
be beneficial in a large number of mobile app scenarios. At the
sametime,wecameacrossseveralappsinwhichprefetchingand
caching are unlikely to have significant, or any, benefits. At theleast, these include the several hundred apps from our originalset of subjects that only provide static content or make very few
(1-3) HTTP requests. In fact, it is possible that the number of these
appssurpassesthe451appsthatdorelyonthenetworkandthat
we included in our final set of subjects (recall the discussion in
Section4.5). This outcome was at least somewhat surprising, given
the long history of research on data prefetching and caching in
distributedsystems,ofwhichmobileappsareonlyamorerecent
example.
Adeeperanalysishelpstoidentifyseveralreasonsbehindthis.
Forexample,inhindsightitmayhavebeenexpectedthatappsfrom
theLibraries & Demo orVideo Players & Editors categories provide
static content, such as PDF viewers, organizers, digital books, and
video players. On the other hand, we did not expect to find almost
as much static content in Auto & Vehicles. We already discussed in
Section4.5thatanumberofappsfromthiscategoryrequiredlogin
by suppling a license plate number. An additional, large numberofappsalsocontainedpurelystaticcontent,suchasinstructions
onhowtoperformcarmaintenance.Thisisreflectedinourdata:
under 14% ofthe Auto & Vehicles apps made itinto our final set of
451 subjects (recall Table 1).
Another issue was presented by apps that used network com-
municationthatwaseithernotbasedonHTTPorextensivelyused
HTTPmethodsotherthan GET.Forexample,anumberofappsin
theCommunications categoryprovideinstantmessagingcapabil-
ities (including VoIP), while others actually implement browsers.
Maps & Navigation provideGPSapplicationsthatdiffersignificantly
from typical HTTP services. Yet another example are Financeapps.
Even though 44% of these apps made it into our final set of sub-
jects,alotofthemarebankingappsthatpredominantlyperform
push-type operations, making them ill-suited for prefetching.
Even within the 451 final subject apps, there are clearly some
for which the benefits of prefetching and caching may be marginal.Gamespresented an interesting case. Over2
3of the apps in this
category made it into our final set of subjects since they used suffi-
ciently large numbers of HTTP requests. These apps also exhibited
veryhigh Cache-Control trustworthiness.Ontheotherhand,as
expected, their requests tended to expire very quickly and to have
littleredundancy.Therefore,whileagameappmaybeidentifiedasacandidateforprefetching,theresultingcacheddatawouldbecome
stale very quickly. In turn, this would possibly lead to incorrect
app behavior or, just as bad, constant thrashing of the prefetching
facilities that would cripple the app’s performance.
Theseissuescanbefurtherillustratedwithasomewhatcrude
analysisofanaverageappfromoursubjectset.Theaverageapp
sent 28GETrequests (recall Section 5.1) as a result of the 3,000
automaticallygeneratedUIevents.20%ofthoserequestsweretruly
redundant(recallSection 5.3).Thatmeansthatupto6 GETrequests
were prefetchable. Our previous work PALOMA [ 49] measured the
processing of a single HTTP request to take slightly over 800ms
under network conditions similar to ours. This would mean that
an average app among our subjects would save only 4s by caching
andreusingtheresultsoftheoriginalrequest,assumingthatthe
cache does not become stale.
Whilewemustbecognizantofapps,suchasthoseabove,that
arenotespeciallyamenabletoprefetchingandcaching,severalsce-
narios in our study paint a much more favorable picture. Consider
the app from category 3 (Beauty ) that issued 1,243 GETrequests
(recallFigure 2),allofwhicharetrulyredundant(corresponding
to the maximum value for app category 3 in Figure 12). Even if we
assumethattheresultofeachredundantrequestcanonlybereusedoncebeforeitexpires(recallfromFigure 11thattheexpirationtime
forappcategory3is10s),thatstillyields621requestsforwhichthe
results can be reused from the local cache. Assuming once again
the same executionconditions as PALOMA’s,this would result in
massive execution-time savings, totaling 497s or 8.5 minutes.
In summary, there is a notable opportunity for prefetching and
caching in the mobile app domain. At the same time, the resulting
techniquesmusttakeintoaccountthecharacteristicsofdifferent
app categories and different HTTP requests. Otherwise, the em-ployed techniques may yield undesired outcomes, such as cache
staleness, non-trivial performance overhead, and incorrect app be-
haviors.
6 THREATS TO VALIDITY
Ourstudyisbasedontop-ranked,freeAndroidapps.Therefore,our
results may not hold for paid apps or lower-ranked apps. However,
over 90% of the Android apps in the Google Play Store are free [ 2].
Furthermore, top-ranked apps are used most widely. This suggests
that our results should have broad applicability.
Weexcludedfromournumericalanalysistheappsthattrigger
fewerthanfourHTTPrequestsat runtime.Ho wever,part oftheob-
jective of our study was to explore this problem space. Specifically,
weidentifiedthereasonsbehindtheapps’lownumbersofrequests
(recallSection 4.5).Furthermore,weacknowledgedexplicitlythat
the exclusion of these apps from the final set of subjects limits the
applicability of our findings (recall Section 5.4).
Our study is based on apps that use the HTTP protocol and
two HTTP libraries ( URLConnection andOkHttp). Our findings
562
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Yixue Zhao, Paul Wat, Marcelo Schmitt Laser, and Nenad Medvidović
are unlikely to be directly applicable to other protocols for net-
work communication, and they may not carry over to other HTTP
libraries. However, most mobile apps, and in particular Android
apps,relyonHTTP[ 15].Furthermore,ourfocusisonthefunda-
mental characteristics of HTTP requests and responses, and those
characteristicsdonotchangeacrossdifferentHTTPlibraries.In-
cluding other libraries would naturally result in the inclusion ofgreater numbers of subject apps. However, given the popularityof the HTTP libraries we selected, our results should be widely
representative among Android apps.
In our process for answering RQ 5,R Q7, and RQ 9, we sent out
sets of four requests, at times t,t+10, t+30, and t+60 seconds
(recall Sections 5.2and5.3). As shown in Figure 11, redundant
requeststendtoexpireat t+10orsoonthereafter.Thisindicates
that t+60 is a sufficiently long period to identify truly redundant
requestsinmostcases.Furthermore,mobileuserstendtousean
appforrelativelyshortperiods,sothatprefetchingandcachingfar
in advance is not necessary and is likely to yield cache staleness.
While choosing different time intervals would likely not lead to
differentresults,finer-grainedintervalsmaygiveustighterbounds
on request expiration times.
Finally, our app usage information was obtained via automated
generationofUIevents,asopposedtologgingrealuserevents.ThismayresultinnumbersandsequencesofHTTPrequeststhatarenotrepresentativeofactualappuse.However,thepurposeofourstudy
wastoanalyzeallpossibleHTTPrequeststhatcouldbepotentially
triggeredatruntime,and3,000randomeventswereshowntobe
able to generate representative HTTP requests, as discussed inSection4.4. Given the nature of the study and the large number
ofappsweaimedtoanalyze,itwouldhavebeenunreasonableto
attempttofindactualusersforeachapp,whileourresultswould
potentially suffer from user-specific biases and idiosyncrasies in
engaging the app. On the other hand, mimicking actual users with
humanswhoareunfamiliarwiththeappsinquestion,whichwould
have been a more likely alternative, would have suffered from the
same potential problem as our automated testing. Furthermore,all of our research questions focus on individual HTTP requests
rather than their sequences. Thus, real user traces would notlead
todifferentresultscomparedtorandomordersofruntimeevents.
Finally, neither actual nor novice human users would have beenable to repeatedly and reliably generate large numbers of events
(3,000perappexecutioninthemainportionofourstudy,andup
to 10,000 per execution in the preliminary analysis).
7 RELATED WORK
Web prefetching and caching are entrenched techniques to reduce
network latency since the Internet was born and have attracted
alargebodyofworkinbrowserdomain,includingmeasurement
studies to understand web performance and identify performance
bottlenecks [ 16,24,30–32,42], literature reviews and quantita-
tive studies to compare fundamental prefetching and caching al-gorithms [
12,39,43], leveraging prefetching and caching tech-
niques at different levels, such as studying user browsing behav-
iors [25,36], providing API support for developers [ 26], restructur-
ing page load process [ 28,40], providing server or infrastructure
support [10, 13,34,35,47].The recent surge of mobile devices has attracted researchers to
study prefetching and caching techniques in the context of mobile
browsersandmobileapps.Withthefoundationofthetraditional
research in browser domain, mobile browser performance soon
became a crowded research area [ 24,27,35,40,41,43], but the
researchonmobileappsisstillinitsinfancy.Thisisunfortunate
because mobile users currently spend more than 80% of their time
in mobile apps rather than mobile browsers [ 14]. In mobile app
domain, Cachekeeper [ 46] studied the redundant HTTP traffic and
proposed an OS-level caching service for HTTP requests on smart-
phones.PALOMA[ 49]usedprogramanalysistoaddress“what”and
“when”toprefetchcertainHTTPrequestsinmobileapps.However,
thosetechniqueswereonlyevaluatedonasmallnumberofapps
andtheperformancedependsontheflawsofwebcachingschemes
employed in the original apps, thus it is not clear to what extent
thosetechniques will beeffectiveinpractice. Thoseshortcomings
ofexistingapproachesmotivatedus toconductanin-depthstudy
that aims to understand the characteristics of HTTP requests in
ordertoguidefutureresearchinmobileapps.Otherexistingworks
thatfocusonmobileappperformancearecomplementarytoour
focus, such as pre-launching mobile apps [ 29,44,45], balancing
Quality-of-Service(QoS)tosuggest“howmuch”toprefetch[ 11,21],
identifying performance bottlenecks [33].
8 CONCLUSION
In this paper, we presented the results of an extensive empirical
studyaimedatunderstandingthecharacteristicsofHTTPrequests
andresponsesinmobileapps.Weformulatednineresearchques-
tionswiththefocusonthe prefetchability ofHTTPrequestsand
cacheability of HTTP responses. Our overarching objective is to
fillinthegapbetweenthewell-studiedbrowserdomainandcom-
paratively less-explored mobile app domain, by motivating and
providing guidelines for future research in this area.
Ourresultssuggestthatprefetchingandcachingcanbeuseful
across a wide range of mobile apps and scenarios, but they are
not universally applicable and their benefits will vary. Certain app
categoriesaremoreamenableforprefetchingandcaching.However,
thereisanon-trivialamountofvariationevenamongdifferentapps
within a single cateogry. While our analysis reported in this paper
doesnotprovidedefinitiveanswerstoquestionsof what, when,and
how much to prefetch/cache,it providesa process, tools,and data
thatform afoundationfor answeringthosequestions muchmore
precisely than has been possible thus far.
ACKNOWLEDGMENT
TheauthorsthankWilliamG.J.Halfond,JiapingGui,andtherest
of their research group at the University of Southern California
forprovidinguswiththeAPKsforoursubjectapps.Thisworkis
supported by the U.S. National Science Foundation under grants
no.CCF-1618231andCCF-1717963,U.S.OfficeofNavalResearch
under grant no. N00014-17-1-2896, and by Huawei Technologies
Co., Ltd.
563
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. Empirically Assessing Opportunities for Prefetching and Caching in Mobile Apps ASE ’18, September 3–7, 2018, Montpellier, France
REFERENCES
[1]2018. Android Debug Bridge. https://developer.android.com/studio/
command-line/adb
[2]2018. Distribution of free and paid Android apps in the
Google Play Store. https://www.statista.com/statistics/266211/
distribution-of-free-and-paid-android-apps/
[3] 2018. NoxPlayer. https://www.bignox.com/
[4] 2018. OkHttp Documentation. http://square.github.io/okhttp/
[5] 2018. Retrofit Documentation. http://square.github.io/retrofit/
[6]2018. UI/Application Exerciser Monkey. https://developer.android.com/studio/
test/monkey.html
[7]2018. URLConnectionClassDocumentation. https://docs.oracle.com/javase/7/
docs/api/java/net/URLConnection.html
[8] 2018. Volley overview. https://developer.android.com/training/volley/
[9]2018. Thewebsiteoftherawdataandthecodeofouranalysis. https://github.
com/felicitia/PALOMA-Analysis/tree/empirical
[10]VictorAgababov,MichaelBuettner,VictorChudnovsky,MarkCogan,BenGreen-
stein, Shane McDaniel, Michael Piatek, Colin Scott, Matt Welsh, and Bolian Yin.
2015. Flywheel: Google’s Data Compression Proxy for the Mobile Web.. In NSDI,
Vol. 15. 367–380.
[11]PaulBaumannandSilviaSantini.2017. EveryByteCounts:SelectivePrefetching
forMobileApplications. Proc. ACM Interact. Mob. Wearable Ubiquitous Technol.
1, 2, Article 6 (June 2017), 29 pages. https://doi.org/10.1145/3090052
[12]Christos Bouras, Agisilaos Konidaris, and Dionysios Kostoulas. 2004. Predictive
Prefetching on the Web and ItsPotentialImpact in the Wide Area. World Wide
Web7, 2 (June 2004), 143–179. https://doi.org/10.1023/B:WWWJ.0000017208.
87570.7a
[13]Michael Butkiewicz, Daimeng Wang, Zhe Wu, Harsha V Madhyastha, and Vyas
Sekar. 2015. Klotski: Reprioritizing Web Content to Improve User Experience on
Mobile Devices.. In NSDI, Vol. 1. 2–3.
[14]Dave Chaffey. 2018. Mobile Marketing Statistics compilation. https:
//www.smartinsights.com/mobile-marketing/mobile-marketing-analytics/
mobile-marketing-statistics/
[15]ShuaifuDai,AlokTongaonkar,XiaoyinWang,AntonioNucci,andDawnSong.
2013. Networkprofiler: Towards automatic fingerprinting of android apps. In
INFOCOM, 2013 Proceedings IEEE. IEEE, 809–817.
[16]JeffreyErman,AlexandreGerber,MohammadHajiaghayi,DanPei,Subhabrata
Sen,andOliverSpatscheck.2011. Tocacheornottocache:The3Gcase. IEEE
Internet Computing 15, 2 (2011), 27–34.
[17]RoyFielding.1999. RFC2616,partofHypertextTransferProtocol–HTTP/1.1.
https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html
[18]RoyFielding.1999. RFC2616,partofHypertextTransferProtocol–HTTP/1.1.
https://tools.ietf.org/html/rfc2616#section-5.1.1
[19]RoyFielding.1999. RFC2616,partofHypertextTransferProtocol–HTTP/1.1.
https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html
[20]RoyFielding.1999. RFC2616,partofHypertextTransferProtocol–HTTP/1.1.
https://tools.ietf.org/html/rfc2616#section-9
[21]BrettDHiggins,JasonFlinn,ThomasJGiuli,BrianNoble,ChristopherPeplin,
and David Watson. 2012. Informed mobile prefetching. In Proceedings of the
10th international conference on Mobile systems, applications, and services.ACM,
155–168.
[22]SIMON KEMP. 2018. Digital in 2018. https://wearesocial.com/blog/2018/01/
global-digital-report-2018
[23]Ding Li, Yingjun Lyu, Jiaping Gui, and William GJ Halfond. 2016. Automated
energy optimization ofhttp requests for mobileapplications. In 2016 IEEE/ACM
38th International Conference on Software Engineering (ICSE). IEEE, 249–260.
[24]X. Liu, Y. Ma, Y. Liu, T. Xie, and G. Huang. 2016. Demystifying the Imperfect
Client-SideCachePerformanceof MobileWebBrowsing. IEEE Transactions on
Mobile Computing 15, 9 (Sept 2016), 2206–2220. https://doi.org/10.1109/TMC.
2015.2489202
[25]DimitriosLymberopoulos,OrianaRiva,KarinStrauss,AkshayMittal,andAlexan-
dros Ntoulas. 2012. PocketWeb: Instant Web Browsing for Mobile Devices. In
Proceedings of the Seventeenth International Conference on Architectural Support
for Programming Languages and Operating Systems (ASPLOS XVII) .ACM,New
York, NY, USA, 1–12. https://doi.org/10.1145/2150976.2150978
[26]JamesWMickens,JeremyElson,JonHowell,andJayRLorch.2010. Crom:Faster
Web Browsing Using Speculative Execution.. In NSDI, Vol. 10. 9–9.
[27]Javad Nejati and Aruna Balasubramanian. 2016. An in-depth study of mobile
browserperformance.In Proceedings of the 25th International Conference on World
Wide Web. International World Wide Web Conferences Steering Committee,
1305–1315.
[28]Ravi Netravali, Ameesh Goyal, James Mickens, and Hari Balakrishnan. 2016.
Polaris:FasterPageLoadsUsingFine-grainedDependencyTracking..In NSDI.
123–136.[29]AbhinavParate,MatthiasBöhmer,DavidChu,DeepakGanesan,andBenjaminM
Marlin.2013. Practicalpredictionandprefetchforfasteraccesstoapplications
onmobilephones.In Proceedings of the 2013 ACM international joint conference
on Pervasive and ubiquitous computing. ACM, 275–284.
[30]FengQian,JunxianHuang,JeffreyErman,ZMorleyMao,SubhabrataSen,and
OliverSpatscheck. 2013. Howtoreducesmartphone trafficvolumeby 30%?.In
International Conference on Passive and Active Network Measurement.Springer,
42–52.
[31]Feng Qian, Kee Shen Quah, Junxian Huang, Jeffrey Erman, Alexandre Gerber,
ZhuoqingMao,SubhabrataSen,andOliverSpatscheck.2012. Webcachingon
smartphones: ideal vs. reality. In Proceedings of the 10th international conference
on Mobile systems, applications, and services. ACM, 127–140.
[32]FengQian,SubhabrataSen,andOliverSpatscheck.2014. Characterizingresource
usageformobilewebbrowsing.In Proceedings of the 12th annual international
conference on Mobile systems, applications, and services. ACM, 218–231.
[33]Lenin Ravindranath, Jitendra Padhye, Sharad Agarwal, Ratul Mahajan, Ian Ober-
miller, and Shahin Shayandeh. 2012. AppInsight: Mobile App Performance
Monitoring in the Wild.. In OSDI, Vol. 12. 107–120.
[34]Sanae Rosen, Bo Han, Shuai Hao, Z Morley Mao, and Feng Qian. [n. d.]. Push or
request:Aninvestigationofhttp/2serverpushforimprovingmobileperformance.
InProceedings of the 26th International Conference on World Wide Web. 459–468.
[35]Vaspol Ruamviboonsuk, Ravi Netravali, Muhammed Uluyol, and Harsha V. Mad-
hyastha.2017. Vroom:AcceleratingtheMobileWebwithServer-AidedDepen-
dency Resolution. In Proceedings of the Conference of the ACM Special Interest
Group on Data Communication (SIGCOMM ’17). ACM, New York, NY, USA, 390–
403.https://doi.org/10.1145/3098822.3098851
[36] N. Swaminathan and S. V. Raghavan. 2000. Intelligent prefetch in WWW using
clientbehaviorcharacterization.In Proceedings 8th International Symposium on
Modeling, Analysis and Simulation of Computer and Telecommunication Systems
(Cat. No.PR00728). 13–19. https://doi.org/10.1109/MASCOT.2000.876424
[37]RajaVallée-Rai,PhongCo, EtienneGagnon,Laurie Hendren,PatrickLam, and
Vijay Sundaresan. 1999. Soot - a Java Bytecode Optimization Framework. In
Proceedings of the 1999 Conference of the Centre for Advanced Studies on Collabo-
rative Research (CASCON ’99).IBMPress,13–. http://dl.acm.org/citation.cfm?
id=781995.782008
[38]Haoyu Wang, Junjun Kong, Yao Guo, and Xiangqun Chen. 2013. Mobile web
browser optimizations in the cloud era: A survey. In 2013 IEEE 7th International
Symposium on Service Oriented System Engineering (SOSE). IEEE, 527–536.
[39]Jia Wang. 1999. A Survey of Web Caching Schemes for the Internet. SIGCOMM
Comput. Commun. Rev. 29, 5 (Oct. 1999), 36–46. https://doi.org/10.1145/505696.
505701
[40]XiaoSophiaWang,ArvindKrishnamurthy, andDavidWetherall.2016. Speeding
up Web Page Loads with Shandian.. In NSDI. 109–122.
[41]Zhen Wang, Felix Xiaozhu Lin, Lin Zhong, and Mansoor Chishtie. 2011. How
effective ismobile browsercache?. In Proceedings of the 3rd ACM workshop on
Wireless of the students, by the students, for the students. ACM, 17–20.
[42]Zhen Wang, Felix Xiaozhu Lin, Lin Zhong, and Mansoor Chishtie. 2011. Why
are web browsers slow on smartphones?. In Proceedings of the 12th Workshop on
Mobile Computing Systems and Applications. ACM, 91–96.
[43]ZhenWang,FelixXiaozhuLin,LinZhong,andMansoorChishtie.2012. Howfar
can client-only solutions go for mobile browser speed?. In Proceedings of the 21st
international conference on World Wide Web. ACM, 31–40.
[44]Ye Xu,MuLin, HongLu,Giuseppe Cardone,NicholasLane, ZhenyuChen,An-
drewCampbell,andTanzeemChoudhury.2013. Preference,contextandcommu-
nities: a multi-faceted approach to predicting smartphone app usage patterns. In
Proceedings of the 2013 International Symposium on Wearable Computers.ACM,
69–76.
[45]Tingxin Yan, David Chu, Deepak Ganesan, Aman Kansal, and Jie Liu. 2012. Fast
applaunchingformobiledevicesusingpredictiveusercontext.In Proceedings
of the 10th international conference on Mobile systems, applications, and services.
ACM, 113–126.
[46]Yifan Zhang, Chiu Tan, and Li Qun. 2013. CacheKeeper: a system-wide webcachingserviceforsmartphones.In Proceedings of the 2013 ACM international
joint conference on Pervasive and ubiquitous computing. ACM, 265–274.
[47]BoZhao,ByungChulTak,andGuohongCao.2014. Mobile web browsing using
the cloud. Springer.
[48]Y. Zhao.2017. Toward Client-CentricApproaches forLatency Minimizationin
MobileApplications.In 2017 IEEE/ACM 4th International Conference on Mobile
Software Engineering and Systems (MOBILESoft). 203–204. https://doi.org/10.
1109/MOBILESoft.2017.34
[49]YixueZhao,MarceloSchmittLaser,YingjunLyu,andNenadMedvidovic.2018.
LeveragingProgramAnalysistoReduceUser-PerceivedLatencyinMobileAp-
plications. In Proceedings of the International Conference on Software Engineering
(ICSE).
564
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. 