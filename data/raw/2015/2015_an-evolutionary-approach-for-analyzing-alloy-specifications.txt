An Evolutionary Approach for Analyzing Alloy Specifications
Jianghao Wang
Department of Comp. Sci. & Eng.
University of Nebraska, Lincoln, USA
jianghao@huskers.unl.eduHamid Bagheri
Department of Comp. Sci. & Eng.
University of Nebraska, Lincoln, USA
bagheri@unl.eduMyra B. Cohen
Department of Comp. Sci. & Eng.
University of Nebraska, Lincoln, USA
myra@cse.unl.edu
ABSTRACT
Formal methods use mathematical notations and logical reasoning
topreciselydefineaprogram’sspecifications,fromwhichwecanin-
stantiatevalidinstancesofasystem.Withthesetechniqueswecanperformamultitudeoftaskstochecksystemdependability.Despite
theexistenceofmanyautomatedtoolsincludingonesconsidered
lightweight,theystilllackastrongadoptioninpractice.Atthecrux
ofthisproblem,isscalabilityandapplicabilitytolargerealworld
applications. In this paper we show how to relax the completeness
guaranteewithoutmuchloss,sincesoundnessismaintained.We
haveextendedapopularlightweightanalysis,Alloy,withagenetic
algorithm. Our new tool, EvoAlloy, works at the level of finite
relationsgeneratedbyKodkodandevolvesthechromosomesbasedon the failed constraints. In a feasibility study we demonstrate that
we can find solutions to a set of specifications beyond the scope
wheretraditionalAlloyfails.Whilesmallspecificationstakelonger
withEvoAlloy,thescalabilitymeanswecanhandlelargerspec-
ifications.Ourfuturevisionisthatwhenspecificationsaresmall
we can maintain both soundness and completeness, but when this
fails, EvoAlloy can switch to its genetic algorithm.
CCS CONCEPTS
•Softwareanditsengineering →Formalmethods ;Software
verification;
KEYWORDS
Formal analysis, Evolutionary algorithms, Relational logic.
ACM Reference Format:
JianghaoWang,HamidBagheri,andMyraB.Cohen.2018.AnEvolutionary
ApproachforAnalyzingAlloySpecifications.In Proceedingsofthe201833rd
ACM/IEEEInternationalConferenceonAutomatedSoftwareEngineering(ASE
’18), September 3–7, 2018, Montpellier, France. ACM, New York, NY, USA,
6pages.https://doi.org/10.1145/3238147.3240468
1 INTRODUCTION
Softwarehasembeddeditselfinourdailylives,andisnowessen-
tial for communication, healthcare, transportation, and even home
comfort.Yetatthesametime,softwarecontinuestofail,andma-
licioususersexploitweaknessesofsystems[ 1].Fifteenyearsago
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ’18, September 3–7, 2018, Montpellier, France
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.3240468the National Institutes of Standards reported that a poor software
quality infrastructure was costing the US upwards of $59 Billion
annually [ 2], and an equally ominous report from Tricentis in 2017
estimated the annual financial loss due to software failures world-
wide at $1.7 Trillion [ 3]. While many efforts have been made to
improveoursoftwareengineeringtechniques,andtodevelopbetter
software validation methods, these problems still persist. Recent
highly publicized bugs like the Toyota acceleration problem and
the heartbleed bug as well as the explosion of Android exploits [ 4]
show that we stilllack sufficient techniques to verify andvalidate
our software.
One class of techniques that have been used to tackle depend-
ability are those which fall into the category of formal methods,
withtheirstrengthresidinginthemathematicalconceptsleveraged
to prove the correctness of dependability properties. Most notably,
lightweight formal methods, such as those based on bounded veri-
fication, have recently received a lot of attention due to their auto-
mated, yet formally precise analysis capabilities, which reduce the
burdenontraditionalformalverificationtechniques.Thisspansa
widerangeofsoftwareengineeringandsecuritydomains,including
softwaredesign[ 5,6],codeanalysis [ 7],securityanalysis [ 4],test
casegeneration[ 8]andtradeoffsynthesisandanalysis[ 9,10].Such
techniques often transform the system specification into a satisfia-
bility problem, and delegate the task of solving it to a constraint
solver. The analysis is then conducted by exhaustive enumeration
over the bounded scope of specification instances.
Despite significant advances, we still find ourselves lacking
strong adoption of formal techniques. At the crux of this prob-
lem,isscalabilityandapplicabilityforlargereal-worldapplications.
Boundedverificationtechniquesareatoncebothsoundandcom-
pleteforthegivenanalysisbound,butthecompletenessmeansthatonlargesystemstheyeitherfailorneedtobereducedinscope.An
alternative approach to solving problems that grow exponentially
hasbeentousesearch-basedtechniquesormorespecificallyevo-
lutionaryalgorithms[ 11].Thesealgorithmsheuristicallyexplore
large complex solutions spaces and converge on single solution,
rendering them sound but incomplete.
In this paper, we present a novel tradeoff that provides a new
roadtowardsscalability.Ourvisionisthatwhenthesearchspace
ofspecificationsaresmall,wecanusethefullpowerofaconstraint
solver and maintain both soundness and completeness. When this
fails, we switch on evolutionary algorithms [ 12] promising to scale
to real-world problems without sacrificing soundness.
To assess the feasibility of the approach, we develop EvoAlloy,
an extension to the existing lightweight formal analysis tool, Al-
loy [13]. EvoAlloy delegates the task of finding satisfying models
to an analysis engine using a genetic algorithm (GA), one of themost popular types of evolutionary algorithms. They have been
showntobeusefulforpinpointingsolutionsinalargesearchspace.
820
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Jianghao Wang, Hamid Bagheri, and Myra B. Cohen
1abstract sig FSObject {}
2sigDir extends FSObject {
3contents: setFSObject
4}
5sigFile extends FSObject {}
6one sig Root extends Dir {}
7
8factHierarchy {
9// Root has no parent
10 nocontents.Root
11// All FSObjects are reachable from Root
12FSObject inRoot.∗ contents
13// Each FSObject has at most one parent
14 allobj: FSObject | lonecontents.obj
15}
16predmodel {
17 someFile
18}
19runmodel for 2 File , 2 Dir
Listing 1: An Alloy specification example describing a
simple model of file system.
WehavechosentheAlloyplatformasanexemplarforourstudy
sinceitisawidely-used,open-sourcetoolformodelingandanalysis
of software systems, has an active development community, and
suffersfromexactlythescalabilityproblemsaddressedbythiswork.
We make research artifacts developed in this study and experimen-
tal data available to the research and education community [ 14].
The preliminary results corroborate the feasibility of the approach,
and denote that this direction of research is promising.
The remainder of this paper is organized as follows. Section 2
uses an illustrative example to describe the intuition behind our
techniqueaswellasthenecessarybackground.Section 3overviews
ourapproachtowardsachievingamorescalableanalysistechnique.
Section4presentsthepreliminaryresultsobtainedinourexperi-
ments. Sections 5and6outline related research and conclude.
2 ILLUSTRATIVE EXAMPLE
This section motivates our research and illustrates the EvoAl-
loytechniqueusingasimpleexample.Section 3presentsamore
detailed discussion of our approach.
ConsidertheAlloy specification forasimplifiedmodelofa file
system, shown in Listing 1. Essential data types are specified in
Alloy by their type signatures (sig), and the relationships between
themarecapturedbythedeclarationsof fieldswithinthedefinition
of each signature. The running example defines 4 signatures (lines
1–6): File system objects, FSObjects, are partitioned into Dirand
Filetypes,with Rootdefinedasasingletonextending Dir.Each Dir
may have a set of contents of typeFSObject.
Facts(fact)areformulasthattakenoarguments,anddefinecon-
straints that every instance of a specification must satisfy, thus
confining the instance space of the specification. The formulas can
befurtherstructuredusingpredicates(pred)andfunctions(fun),
which are parameterized formulas that can be invoked. The Hierar-
chyfactparagraph(lines8–15)statesthatthe Rootdirectoryhas
no parent, and it cannot be a subdirectory for any other directory;
that each single file and directory should be reachable from the
Rootdirectory; and that each file and directory belongs to at most
one parent directory.Analysis of specifications written in Alloy is completely auto-
mated, but bounded up to user-specified scopes on the size of type
signatures. In particular, to make the state space finite, certainscopes need to be specified that limit the number of instances of
eachtypesignature.The runspecification(lines16–19)thenasks
for instances that contain at least one File, and specifies a scope
thatbounds thesearchforspecificationinstanceswith atmosttwo
elements for both FileandDirtop-level signatures.
In order to analyze such a relational specification bounded by
the specified scope, both Alloy Analyzer and EvoAlloy then trans-
late it into a corresponding finite relational model in a language
called Kodkod [ 15]. Listing 2partially shows a Kodkod translation
of Listing 1. A model in Kodkod’s relational logic is a triple consist-
ingofauniverseofelements(alsocalled atoms),asetofrelation
declarations including their lower and upper bounds specified over
the model’s universe, and a relational formula, where the declared
relations appear as free variables [15].
ThefirstlineofListing 2declaresauniverseoffouruninterpreted
atoms.Inthissection,weassumeaninterpretationofatoms,where
the first two ( F1andF2) represent Fileelements, the next one (R1)
representsa Rootelement,andthelastone(D1)representsa Direle-
ment.Notethattheabbreviatedatomnamesarechosenforreadabil-ity,anddonotindicatetype,asinKodkodallrelationsareuntyped.
Lines3–6staterelationalvariablesalongwiththeirlowerand
upperboundsandtheirsize.SimilartoAlloy,formulasinKodkod
are constraints defined over relational variables. Kodkod further
allowsspecifyingascopeovereachrelationalvariablefromboth
above and below by two relational constants. In principle, a rela-tional constant is a pre-specified set of tuples drawn from a uni-
verse of atoms. Consider the Rootdeclaration (line 3), its upper
andlowerboundsbothcontainjustoneatom, R1,asitisdefined
as a singleton set in Listing 1. The upper bound for the variable
contents⊆Dir×FSObject (line6)isaproductoftheupperbound
setforitscorrespondingdomainandco-domainrelations,takingev-
ery combination of an element from both and concatenating them.
Formula constraints are in the form of a conjunction of several
sub-formulas,i.e., F=∧subformulas .Asanexample,theformula
at the last line of Listing 2represents this form for the constraints
specifications in our running example.
The Kodkod’s model finder then leverages off-the-shelf SAT-
solvers to explore within such upper and lower bounds defined for
each relational variable to find instances of a formula, which are
bindingsoftheformula’srelationalvariablestorelationalconstantsinawaythatmakestheformulatrue .EvoAlloy, however,delegates
the task of model finding currently performed by computationally-
expensiveconstraintsolverstoananalysisenginebasedongenetic
algorithms.
Figure1a delineates a genetic representation of the problem,
whereacandidatesolutionisrepresentedasa chromosome,a.k.a.an
individual, consisting of a vector of genes. Evolutionary algorithms
are meta-heuristic optimization techniques that mimic the process
of natural genetic variation and selection into a computational
problem[ 12].Eachchromosomecontainsageneforeachrelational
variablewithinthespecificationunderanalysis.Eachgenehasa
domainofvaluescalled alleles.Here,allelesaredefinedasasetoftu-
plesdrawnfromauniverseofuninterpretedatomswithintheupper
and lower bounds defined for each relation (Listing 2, lines 3–6).
821
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. An Evolutionary Approach for Analyzing Alloy Specifications ASE ’18, September 3–7, 2018, Montpellier, France
1{F1,F2,R1,D1}
2
3Root: (1 ,1) :: {{R1} ,{R1}}
4File: (0,2) :: {{} ,{{F1},{F2}}}
5Dir: (0,1):: {{},{{D1}}}
6contents: (0,8):: {{} ,{{R1,R1},{R1,D1},{R1,F1},{R1,F2},{D1,R1},{D1,D1},{D1,F1},{D1,F2}}}
7
8(allo: Root + Dir + File | lone(Dir.contents.o)) && ...
Listing 2: Kodkod representation of the Alloy module of Listing 1.
Figure 1: EvoAlloy’s (a) representation of a chromosome,
(b) two produced chromosomes for the specification of List-
ing1,(c)crossoverstepforcreatinganewchromosome,and
(d) mutation step.
Ageneticalgorithmstartswithaninitial population ofrandomly
created chromosomes.Figure 1b demonstratestwo sample chromo-
somesproducedforourrunningexample.Eachchromosomeinthis
casehas4genesthatcorrespondtothespecification’srelations,i.e.,Root,File,Dir,andcontents,fromlefttoright,respectively.Asolu-
tionisfoundbyiterativelyevolvingpopulationofchromosomes.
Evolutionary search entails two types of operators, i.e., crossover
andmutation. Crossover among two selected chromosome parents
is carried out to breed new chromosomes. A crossover is oftenconductedbyblendingasubsetofeachparent’sgeneticmakeup.Figure1c represents EvoAlloy’s crossover step for creating off-
spring.
InEvoAlloytherecombinationofthetwoparentscreatetwo
offspring.Forthesakeofsimplicityandasitsufficestomakethe
ideaconcrete,herewejustdemonstrateoneoffspring.Thediagram
shows a single-point crossover, i.e., a random point within the
middlerangeofachromosome;EvoAlloyyeteffectivelyiscapable
ofexploitingdifferenttypesofcrossoveroperators.Finally,some
genesinthepopulationwillbe mutatedusingagivenmutationrate.
Figure1dillustratesapplyingamutationoperatortoachromosome
that gives rise to a randomized change in the chromosome. In fact,
mutation randomly selects a percentage of genes in the population
andmodifieseachbyassigningadifferenttuplefromwithinthat
gene’s domain.
Figure 2: An Alloy modelinstancederivedautomat-
ically from the chromo-
some shown in Fig. 1d.The evolutionary search us-
ing genetic operators is carried
on up to an identification ofa satisfactory solution or anend criterion is met. EvoAl-
loyreliesinpartontheKodkod
analysisenginetogettherela-
tions that fail within each chro-
mosome along with the num-ber of failed subformulas to
drivethesearchtowardsthose
which have no violations. Fig-
ure2illustrates a satisfying
model instance produced byEvoAlloy from the chromo-
some shown in Fig. 1d.
Theaboveexampleprovidesanintuitivedescriptionofmodel
finding using both Alloy and EvoAlloy. However, in practice con-
straint solving, despite significant advances, continues to be a bot-
tleneck in analyses relying on such technologies, including the
traditionalAlloyAnalyzer.Togainfurtherconfidenceinthecor-
rectness of their models, Alloy users must re-analyze them withlarger and larger scopes. Yet, the cost of the constraint-solving
technologies underlying Alloy is exponential in those bounds, pre-
venting the analysis beyond only trivial bounds. The magnitude
offormulastendstoincreaseexponentiallyinthesizeofthesys-
tem to be analyzed, making it less practicable to employ constraint
solving in analyzing realistic complex systems. There is a need for
mechanisms that facilitate efficient application of formal analyzers
in rapidly growing domain of software systems.
ThenextsectionoverviewsourapproachtoextendAlloywith
anevolutionaryalgorithmtowardsachievingamorescalablemodel
finding technique.
3 EVOALLOY
Figure3shows an overview of EvoAlloy, and explains how it
can bypass the computationally intractable part of the existing
AlloyAnalyzer.Ontheleft,theAlloyAnalyzerreadsinanAlloy
specificationandtranslatesitintoarelationalmodel,then passes
that to Kodkod (a finite relational model analyzer) [ 15]. For each
relation, Kodkod uses the scopes and signature bounds from Alloy,
andconcretizesthesetoboundtheproblemspecification.TheuseofKodkodinAlloyhasalreadyprovidedscalabilitybeyonditsoriginal
implementation,becauseitcanhelpreasonaboutpartialmodels.
To transform such a finite relational model into a Boolean logic
formula,KodkodrenderseachrelationasaBooleanmatrix,inwhichany tuple within the bounds of the given relation maps to a unique
Booleanvariable[ 16].Relationalconstraintsarethencapturedas
822
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Jianghao Wang, Hamid Bagheri, and Myra B. Cohen
Figure 3: Schematic view of EvoAlloy
BooleanconstraintsoverthetranslatedBooleanvariables.Itthen
translates the resulting Boolean formula to CNF, and passes the
CNF to an off-the-shelf SAT solver to obtain a solution. Last, the
Alloy interpreter translates the SAT result into a solution instance.
Ourinsightistoutilizetheboundedrelationalmodeltomake
the genetic algorithm scalable fortwo reasons. First, applying the
geneticalgorithmontheKodkodlevel,ratherthanthehigherAlloy
level,ismoreefficientasbothtightrelationalboundsandpartial
modelslimitthespaceofconcreteinstancesthatneedtobeexplored
by the search engine. Second, translating a Kodkod model to a
propositional formula and then to CNF introduces many auxiliary
variables [ 15,17]. The explosion in the number of variables affects
the scalability of the genetic algorithm approach.
OurGAextensionisthusinsertedbetweenKodkodandtheAlloy
interpreter, as depicted in Figure 3. At the highest level, EvoAl-
loy’s GA extension takes in the model from Kodkod and outputs a
satisfying solution to the Alloy interpreter. The box at right shows
the steps EvoAlloy follows to do this.
TheGAemployedinthisworkisdelineatedinAlgorithm 1.The
initialpopulation ofourindividualsismadeupofrandomassign-
ment of values to each relational variable, from within the legal
relations and their bounds. The scope of each relational variable is
defined by two relational constants, called upperandlowerbounds,
respectively.Theupperboundrepresentsthewholesetoftuples
thatarelationalvariablemaycontain,andalowerboundrepresents
apartialsolutionforagivenmodel.Everyrelationinasatisfying
solution,thus, mustcontainalltuples inthelowerbound, andno
tuplethatisnotintheupperbound.Intheinitialpopulation,we
randomly assign a value to each relation from within the speci-
fiedbounds.Inessence,eachchromosomewithinthepopulation
represents a potential Alloy solution.
Fitnessismeasuredbyassessingthechromosomeandmonitoring
how close it gets to satisfying constraints of the target specifica-tion. To verify each individual, we employ the APIs provided by
theKodkodmodelfinder;italsohasabuilt-inabilitytoidentifya
minimalunsatisfiablecorewhentheindividualdoesnotsatisfythe
specificationconstraints. Essentially, if anyconstraint is omitted
fromtheidentifiedcore,theresultingsetofconstraintswouldbe
satisfiable. With each subsequent iteration, we breed new chromo-
somes through combining chromosomes selected with a likelihood
proportional to their fitness value, and then mutating the resulting
ones (e.g., arbitrarily change some of its tuples).Algorithm 1 The genetic algorithm applied in EvoAlloy
1:Popcurrent←generate random population
2:repeat
3:Popnew←elite (Popcurrent ,e)
4:P/prime,P/prime/prime←permute (Popcurrent )
5:i←0
6:while|Popnew|/nequal|Popcurrent|/2do
7: Popnew←Popnew∪select (P/prime[i],P/prime/prime[i])
8: i←i+1
9:end while
10:while|Popnew|/nequal|Popcurrent|do
11: p1,p2←pickParents (Popnew )
12:/angbracketleftc1,c2/angbracketright←crossover (p1,p2,probcrossover )
13: c1←mutation (c1,Probmutation )
14: c2←mutation (c2,Probmutation )
15: Popnew←Popnew∪{c1,c2}
16:end while
17:Popcurrent←Popnew
18:untilsolutionfound ORmaximumresourcesspent
The remainder of this section describes the details of EvoAlloy.
3.1 Problem Representation
The initial step in developing any evolutionary algorithm is to
decide on a genetic representation of a candidate solution to theproblem. This entails defining a chromosome and the mapping
from it to the original problem context. In our case, a chromosome
is represented as a vector shown in Figure 1a, where each index
in the vector denotes a gene. It can be seen as a tuple-string of
lengthn, where nis the number of relations within the problem
specification. Each single gene refers to the value assignment of
exactly one relation. Given an Alloy specification S, we define a
function fS:Relation (S)→Nthat maps each relation rof the
specification Sinto a vector index assigned to that relation. Analo-
gously, we define f−1
S:N→Relation (S)as a function that maps
agivenvectorindextotherelationitrepresents.Notethatthecho-sen representation has a fixed size for a given problem, determined
by the number of relations within the problem specification under
analysis. This representation influences variation operators, i.e.,
crossover and mutation, discussed below.
3.2 Fitness Function
The fitness function is a decisive factor of evolutionary algorithms.
It measures the solution-quality of a chromosome, and acts as a
means to differentiate chromosomes in proportion to the extent of
their contribution toa solution. EvoAlloy considers twofactors in
assessing the fitness of chromosomes: Formula constraints ( ci) and
relations ( ri). The fitness of a chromosome chromis determined as
follows:
f(chrom )=/summationdisplay
ci∈ConstsTc(ci,chrom )+/summationdisplay
ri∈RelsTr(ri,chrom )
where Tc(ci,chrom )equals one if ciis not satisfied by chrom;
anditevaluatestozerootherwise.Similarly, Tr(ri,chrom )equals
one if riis not satisfied by chrom; it evaluates to zero otherwise.
Whenachromosomeforagivenspecificationsatisfiesallitscon-
straints defined over its relational variables, we identify it as an
823
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. An Evolutionary Approach for Analyzing Alloy Specifications ASE ’18, September 3–7, 2018, Montpellier, France
ideal chromosome with a fitness score of 0. The fitness function
establishestruth-invariance,astheAlloyspecificationissatisfied
provided that all the relations and formulas thereof are satisfied.
3.3 Selection
The Algorithm on lines 3–9 explains the process by which EvoAl-
loy selects chromosome variants to pass to the next generation. It
leverages both elitism and unbiased tournament selection strate-
gies [18] to select half of population members in a new generation
from the current generation. The select group of chromosomes
establishes the next mating pool. Specifically, it first picks a config-
urablenumber( e)ofchromosomeswithbestfitnessvalues.Theuse
ofelitismpreventsthelossofthecurrentfittestmembersofthepop-
ulation. The new generation is then half-filled with chromosomes
produced by the unbiased tournament selection, which forms two
distinct permutations of the population and conducts a pairwise
comparison to select one chromosome from each pair of compared
chromosomes. The use of unbiased tournament selection promises
to eliminate the loss of diversity due to chromosomes not being
sampled,typicallyoccurredinthetraditionaltournamentselection.
3.4 Crossover
Theinitialstepinproducingnewchromosomesforthenextgen-
eration is crossover. It picks two chromosomes from the popula-
tion, and produces two new chromosomes by mixing their genetic
makeup.TheemployedcrossoveroperatorinEvoAlloyisessen-
tially the well-known two-point crossover. Because the lengths of
thetwochromosomesarethesame,thecutpointsareuniformly
chosenwithinthechromosomes’length.Thecrossovercreatestwo
offspring,whereitswapseverytupleassignedtothegenesbetween
the two points of the parent chromosomes.
3.5 Mutation
To counter genetic drift [ 19] and recover lost genes, crossover is
often used along with mutation to achieve a diverse population of
chromosomes. Mutation simply alters parts of the genetic makeup
of a chromosome with a probability threshold that is configurable.
EvoAlloy mutates genes with various creation,transformation and
removaloperators.
The creation operator basically generates a new tuple-string
from within the upper and lower bounds specified for the relation
associated with a given gene currently containing no tuple. Thenumberofaddedtuplesisrandomwithaminimumofoneandaconfigurable upper threshold. Transformation operators includechanging one tuple to another and inserting a new tuple-stringat a random index. The removal operator omits the tuple-stringassigned to a gene. In other words, the gene becomes empty, if
permitted by its given lower bound.
4 EXPERIMENTAL EVALUATION
WehaveimplementedEvoAlloyasanopen-sourceextensiontothe
Alloyanalysisengine.Torealizethegeneticalgorithmsdiscussed
inthepriorsections,EvoAlloymodifiesboththeAlloyAnalyzer
and its underlying finite relational model finder, Kodkod [ 15]. The
modifications lie in realizing the facility to producing the initial
population of chromosomes and next generations, assessing satisfi-
abilityofeachchromosomewithinthepopulation,collectingthein-
formation necessary in measuring fitness values, and transformingchromosome-level model instances into high-level Alloy models.
The EvoAlloy prototype is available at the project website [14].
To assess the effectiveness of EvoAlloy, we compare it with
the state-of-the-art Alloy Analyzer (version 4.2). In addition, we
considerarandomexplorationapproach, RD,thatneitherappliesa
GA nor leverages constraint solvers. Rather, it randomly generates
candidate solutions following the rules implied by the bounds of
specifications relations. We set RDto generate 10,000 candidates.
ObjectsofAnalysis. Ourobjectsofanalysisarespecificationsthat
varyintermsofsizeandcomplexityandaredistributedwiththe
Alloy Analyzer (cf. Table 1).Chordmodels the chord distributed
hash table lookup protocol; comspecifies Microsoft component
object model query interface and aggregation mechanism; sync
is a model of a generic file synchronizer; fileSystem specifies a
generic file system; and lifespecification models John Conway’s
gameoflife.Toperformthecomparisonexperiments,wegradually
increased the scope of analysis on each of our object specifications.
ExperimentalSetup. ForourGAparametersweransomeinitial
experimentstoheuristicallytunethesetoworkacrossmorethan
one subject. We leave a full evaluation of tuning as future work.
Weuse32asthepopulationsize.Weconfiguredthealgorithmto
perform a two-point crossover with a crossover probability of 50%,
andsetthemutationrateto80%.Formutation,weusetheaddition
operator10%ofthetime,thetransformationoperators60%ofthe
time, and the creation operator 30% of the time. To control for vari-
ance, we ran the technique three times, and report the average. We
didthisseparatelyoneachofthefivespecificationsunderconsider-
ation. All of the experiments were conducted on an 8-core 2.0 GHz
AMDOpteron6128system,withan8GBofmemorywasdedicated
to the running technique to keep extraneous variables constant.
Weused twostoppingcriteria: reachinga (1)asatisfying solution
or (2) exceeding the given maximum memory.
ResultsandInterpretation. Table1reportstheanalysistimeinsec-
ond taken from EvoAlloy, the Alloy Analyzer (AA), and Random
(RD) over the increasing analysis scope acrossobjectspecifications.
The scope of analysis is specified on the horizontal axis.
AsTable1shows,foreachspecification,EvoAlloyoutperforms
the state-of-the-art Alloy Analyzer in terms of scalability, and the
difference in the analysis capability is more pronounced for the
largeranalysisscopes.Therandomapproach,exceptinonecase,
i.e.,thesyncspecificationwiththeanalysisscopeof5,wasnotable
tofindanysatisfyingsolution.Thisconfirmsthatonehasalmostno
chance to come up with a valid Alloy solution with a pure random
search.WealsoseethatforsmallerscopesAlloyoftenoutperformsEvoAlloy,butasthescopeofanalysisincreases,EvoAlloyismore
effective than the Alloy Analyzer. For instance, for chord, Alloy
failsatscope45,butEvoAlloyfindsasolutionuptoascopeof125.
Indeed, higher analysis scope is accompanied by a larger search
space,whichcanamplifytherelativeeffectivenessofaGA-based
approach, like EvoAlloy. With com, EvoAlloy goes beyond Alloy
and solves scope 25, but fails afterwards due to out of memory. We
believethatbettertuningandamorecompactwaytostorefinite
Kodkod models will allow us to keep improving the analysis.
Insummary,thepreliminaryresultsprovidetheevidencethat
thelineofresearchonexploringthesynergybetweenevolutionary
algorithms and lightweight formal analyzers is worth pursuing.
824
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Jianghao Wang, Hamid Bagheri, and Myra B. Cohen
Table 1: The analysis time in second taken from EvoAlloy (EA), Alloy Analyzer (AA), and Random (RD) over the increasing
analysis scope across objects of study; dashes indicate the approach terminates without finding a solution.
SpecAnalysis Scope
5 25 45 65 85 105 125
RDAAEARDAAEARDAAEARDAAEARDAAEARDAAEARDAAEA
com —114——313———————————————
sync 122—43—136—3111—5530—23543—29474
fileSys —13—88—2326—63176—203333—363680——1501
chord —32—9416——241——299——391——705——1496
life —33—780—26624—931000—2053412——4389——6850
5 RELATED WORK
There is a large body of research on using evolutionary algorithms
tosolvesoftwareengineeringproblems[ 11].EvoAlloyfallswithin
this class of solutions. Concolic Walk combines linear constraint
solvingwithtabusearchtosolvecomplexarithmeticpathcondi-
tions [20]. ACO-Solver uses the Ant Colony Optimization to solve
complex string constraints [ 21]. The work of Godefroid and Khur-
shid [22] is perhaps the most closely related work to ours. It uses a
geneticalgorithmtoguideasearchintheanalysisofconcurrent
reactive systems towards errors like deadlocks and assertion viola-
tions.Incontrastwithallofthispriorwork,theproblemaddressed
in this paper addresses bounded analysis of large-scale solution
spaces specified in relational logic. Among other things, it requires
thedevelopmentofbothoriginalchromosomeencodingsandfit-
nessfunctionsappropriateformodelsspecifiedinAlloy’srelationallogic.Tothebestofourknowledge,EvoAlloyisthefirstevolution-
arytechniqueforautomatedanalysisofboundedrelationallogic
specifications.
The widespread use of Alloy has lead to a number of extensions
to its underlying analyzer [ 23,24]. Among others, Uzuncaova and
Khurshid [ 25] partition a specification into base and derived slices,
inwhichasolutiontothebaseslicecanbeextendedtoproducea
solutionfortheentirespecification.Rosneretal.[ 26]presentatech-
nique,Ranger,thatleveragesalinearorderingofthesolutionspacetosupportparallelanalysisoffirst-orderlogicspecifications.Thesetechniquesrelyonleveragingmultiplicityofcomputingtoimprove
theefficiencyoftheAlloyanalyzer,whereasEvoAlloyisgeared
towards the application of genetic algorithms to foster exploration
of large, complex solution spaces.
6 CONCLUSIONS AND FUTURE WORK
Inthispaperwehaveprovidedaproof-of-conceptforEvoAlloyto
demonstrate its potential benefit and power. However, it is still
early in its development and it suffers from some limitations. First,
thefitnessfunctionprovidesstrongguidanceearlyinthesearch,
but needs refinement when the solution gets close. We plan toexperiment with additional fitness functions and to consider an
adaptiveapproachthathasbeenusedinpriorworkonevolutionary
algorithmsfor constraintbasedproblems. Second,wehave found
that the parameter tuning (e.g., mutation, crossover) is sensitive to
thespecificspecificationbeingsolved.Weplantoexplorethisissue
further; recent work on self-tuning and hyperheuristic algorithms
may help us in this context. Last, we still depend on loading the
entire Kodkod model which may limit us as we scale to even larger
systems. We plan to examine ways to store in a more efficient way.ACKNOWLEDGEMENT
This work was supported in part by an NSF EPSCoR FIRST award,
and awards CCF-1755890 ,CCF-1618132 andCCF-1745775 from the
National Science Foundation.
REFERENCES
[1]Symantec Corp., “2012 norton study: Consumer cybercrime estimated at $110
billion annually,” Sep. 2012. [Online]. Available: $http://www.symantec.com/
about/news/release/article.jsp?prid=20120905_02$
[2]RTI,“Theeconomicimpactsofinadequateinfrastructureforsoftwaretesting,”
National Institute of Standards & Technology, Technical Report 7007.011, 2002.
[3]Tricentis Corp., “2017 tricentis software fail watch report,” 2017. [Online].
Available: https://www.tricentis.com/software-fail-watch/
[4]H. Bagheri, A. Sadeghi, R. Jabbarvand, and S. Malek, “Practical, formal synthesis
and automatic enforcement of security policies for android,” in Proceedings of
DSN, 2016, pp. 514–525.
[5]H. Bagheri and K. Sullivan, “Model-driven synthesis of formally precise stylized
software architectures,” Form. Asp. of Comput., vol. 28, no. 3, pp. 441–467, 2016.
[6]——, “Bottom-up model-driven development,” in Proceedings of ICSE, 2013, pp.
1221–1224.
[7]M. Taghdiri and D. Jackson, “Inferring specifications to detect errors in code,”
Automated Software Engineering, vol. 14, no. 1, pp. 87–121, 2007.
[8]N. Mirzaei, J. Garcia, H. Bagheri, A. Sadeghi, and S. Malek, “Reducing Combina-
toricsinGUI TestingofAndroidApplications,”in ProceedingsofICSE,2016,pp.
559–570.
[9]H. Bagheri, C. Tang, and K. Sullivan, “Trademaker: Automated dynamic analysis
of synthesized tradespaces,” in Proceedings of ICSE, 2014, pp. 106–116.
[10]——, “Automated Synthesis and Dynamic Analysis of Tradeoff Spaces for Object-
Relational Mapping,” IEEE Transactions on Software Engineering, vol. 43, no. 2, pp.
145–163, Feb. 2017.
[11]M. Harman, S. A. Mansouri, and Y. Zhang, “Search-based software engineering:
Trends, techniques and applications,” ACM Comput. Surv., vol. 45, no. 1, pp. 11:1–
11:61, Dec. 2012.
[12]A.E.EibenandJ.E.Smith, IntroductiontoEvolutionaryComputing. SpringerVer-
lag, 2003.
[13]D. Jackson, Software Abstractions, 2nd ed. MIT Press, 2012. MIT Press, 2012.
[14]“EvoAlloy web page,” 2018. [Online]. Available: https://sites.google.com/site/
evoalloy2018/
[15]E.TorlakandD.Jackson,“Kodkod:Arelationalmodelfinder,”in Proceedingsof
TACAS, 2007, pp. 632–647.
[16]E. Torlak, “A constraint solver for software engineering: Finding models and
cores of large relational specifications,” PhD Thesis, MIT, Feb. 2009.
[17]T.Nelson,S.Saghafi,D.J.Dougherty,K.Fisler,andS.Krishnamurthi,“Aluminum:Principledscenarioexplorationthroughminimality,”in ProceedingsofICSE,2013,
pp. 232–241.
[18]A.SokolovandD.Whitley,“Unbiasedtournamentselection,”in Proceedingsof
GECCO, 2005, pp. 1131–1138.
[19]A. Rogers and A. Pruegel-Bennett, “Genetic drift in genetic algorithm selection
schemes,” IEEE Transactions on Evolutionary Computation, 1999.
[20]P.DingesandG.A.Agha,“Solvingcomplexpathconditionsthroughheuristic
search on induced polytopes,” in Proceedings of FSE, 2014, pp. 425–436.
[21]J.Thomé,L.K.Shar,D.Bianculli,andL.C.Briand,“Search-drivenstringconstraint
solving for vulnerability detection,” in Proceedings of ICSE, 2017, pp. 198–208.
[22]P. Godefroid and S. Khurshid, “Exploring Very Large State Spaces Using Genetic
Algorithms,” Int. J. Softw. Tools Technol. Transf., vol. 6, no. 2, pp. 117–127, 2004.
[23]E.Torlak,M.Taghdiri,G.Dennis,andJ.P.Near,“Applicationsandextensions
ofalloy:past,presentandfuture,” MathematicalStructuresinComputerScience,
vol. 23, no. 4, pp. 915–933, 2013.
[24]H. Bagheri and S. Malek, “Titanium: Efficient Analysis of Evolving Alloy Specifi-
cations,” in Proceedings of FSE, 2016, pp. 27–38.
[25]E. Uzuncaova and S. Khurshid, “Constraint prioritization for efficient analysis of
declarative models,” in Proceedings of FM, 2008, pp. 310–325.
[26]N.Rosner,J.H.Siddiqui,N.Aguirre,S.Khurshid,andM.F.Frias,“Ranger:Parallel
analysisofalloymodelsbyrangepartitioning,”in ProceedingsofASE,2013,pp.
147–157.
825
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. 