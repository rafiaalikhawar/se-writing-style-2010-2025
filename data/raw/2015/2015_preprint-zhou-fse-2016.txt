API Deprecation: A Retrospective Analysis and
Detection Method for Code Examples on the Web
Jing Zhou and Robert J. Walker
Laboratory for Software ModiÔ¨Åcation Research
Department of Computer Science
University of Calgary
Calgary, Canada
{jing.zhou, walker}@lsmr.org
ABSTRACT
Deprecation allows the developers of application programming in-
terfaces (APIs) to signal to other developers that a given API item
ought to be avoided. But little is known about deprecation practices
beyond anecdotes. We examine how API deprecation has been used
in 26 open source J AVA frameworks and libraries, Ô¨Ånding that the
classic deprecate‚Äìreplace‚Äìremove cycle is often not followed, as
many APIs were removed without prior deprecation, many depre-
cated APIs were subsequently un-deprecated, and removed APIs
are even resurrected with surprising frequency. Furthermore, we
identify several problems in the information commonly (not) pro-
vided to help API consumers transition their dependent code.
As a consequence of deprecation, coding examples on the web‚Äî
an increasingly important source of information for developers‚Äî
can easily become outdated. Code examples that demonstrate how
to use deprecated APIs can be difÔ¨Åcult to disregard and a waste of
time for developers. We propose a lightweight, version-sensitive
framework to detect deprecated API usages in source code exam-
ples on the web so developers can be informed of such usages be-
fore they invest time and energy into studying them. We reify the
framework as a prototype tool (D EPRECATION WATCHER ). Our
evaluation on detecting deprecated A NDROID API usages in code
examples on S TACK OVERFLOW shows our tool obtains a precision
of 100% and a recall of 86% in a random sample of 200 questions.
CCS Concepts
Software and its engineering !Software libraries and repos-
itories; Documentation;
Keywords
API deprecation, deprecation practices, web-based documentation,
Deprecation Watcher.
1. INTRODUCTION
Software developers use existing frameworks and libraries to save
development time and effort. Application programming interfaces(APIs) are the exposed interfaces of underlying software items that
are intended to be reused by such developers. Ideally, frameworks
and libraries keep their APIs unchanged and only add new APIs or
change the underlying implementation of existing APIs. In real-
ity, frameworks and libraries evolve over time for the same reasons
as any software [21], and this evolution sometimes causes non-
backwards compatible changes to their APIs. Any sudden elimi-
nation of an API would cause difÔ¨Åculties for the API‚Äôs consumers,
sodeprecation of an API temporarily maintains backward compat-
ibility while urging API consumers to transition to better alterna-
tives. Unfortunately, we know little about deprecation in practice,
the problems that it will cause for developers, and what could be
done to improve the situation.
Information about deprecation [8, 10, 14, 18, 31, 38, 40] is gen-
erally anecdotal or based on assumptions that are either without
supporting evidence or of dubious generality. There has been much
work on general API evolution, focusing on migrating client code
away from breaking API [6, 8, 11, 14, 18, 26, 27, 29, 39, 41],
but this says nothing about deprecation practices. Some work has
considered developer reactions to deprecation [13, 16, 22, 24, 34],
notes issues only in passing with deprecation [8, 18], or fails to
consider how deprecation evolves [20]. Work has been proposed
to link web-based code examples to concrete APIs [9, 37], but this
fails to consider the presence of multiple, simultaneous API ver-
sions, only some of which contain deprecated items.
When an API is deprecated, it is assumed that API consumers
will be aware of it. According to a survey of over 3000 MSDN
developers, developers indicate that they learn about new APIs pri-
marily through web search instead of via ofÔ¨Åcial documentation.
Web searches often take a developer to sites like S TACK OVER-
FLOW or software development blogs, which have a high cov-
erage of API for many frameworks [28]. Those sites often of-
fer concrete code examples on how to use APIs, complementing
ofÔ¨Åcial documentation. However, those examples are rarely up-
dated, becoming a source of confusion and frustration when they
refer to deleted or deprecated APIs. Even the ofÔ¨Åcial documen-
tation is not always updated: for example, the A NDROID method
startManagingCursor(Cursor) in class android.app.ListActivity has
been deprecated since API level 11 yet it is still used in an example
in the class documentation as of API level 21 [1].
Our work seeks to address these shortcomings: (1) by perform-
ing an in-depth, retrospective analysis to investigate deprecation
practices in 26 open source J AVA systems (690 versions in total),
and (2) by providing a tool, D EPRECATION WATCHER , that in-
forms developers of the presence of deprecated APIs in web-based
code examples. The tool aims to be fast and conservative, only
announcing the presence of deprecated API usages when this isdeÔ¨Ånite. We evaluate our tool by comparing its ability to detect
deprecated API usages in real posts on S TACK OVERFLOW involv-
ing the A NDROID API, with classiÔ¨Åcations performed manually.
The remainder of the paper is organized as follows. Section 2
presents a motivational scenario for detecting web-based usages
of deprecated APIs. Section 3 presents our retrospective study
on API deprecation by tracking how API deprecation occurred
and changed over time. In Section 4 we propose a lightweight,
version-sensitive framework to identify deprecated APIs in web-
based source code examples, implemented as our prototype tool
DEPRECATION WATCHER . Section 5 presents our evaluation of
DEPRECATION WATCHER . Section 6 presents a discussion about
our work and its implications. Section 7 discusses related work
The contributions of this paper are: (1) a retrospective analysis
of 26 open source J AVA systems over 690 versions in total to deter-
mine how deprecation is used in practice and over time; and (2) a
lightweight framework to detect deprecated API usages in source
code examples on the web, with its associated prototype tool.
2. MOTIV ATION
Imagine an A NDROID developer who wants to capture a picture
from a webview on an A NDROID device. Like a lot of develop-
ers [28], instead of searching in the ofÔ¨Åcial A NDROID documenta-
tion, he decides to look for help on the web. He switches from his
work environment (A NDROID STUDIO ) to a web browser and starts
a G OOGLE search with the search terms ‚Äúandroid capture picture
webview.‚Äù The top four results for this query returned by G OOGLE
are all from S TACK OVERFLOW .1The developer selects the Ô¨Årst
link [19] to see that the title of the question (‚ÄúCapture picture from
android webview‚Äù) matches his query almost exactly and that the
question was marked as solved. A quick glance at the webpage
shows that the question has 4 upvotes, has been starred by 10 peo-
ple, and that the accepted answer has 12 upvotes and was written
by someone with a high reputation. The question has also been
viewed more than 8200 times since it was asked. It seems like the
accepted answer would address this developer‚Äôs problem too (see
Figure 1) so the developer decides to look into it.
After spending a few minutes to understand the code, the devel-
oper considers integrating it into his own work, as the code blocks
seem self-contained, without external dependencies. Therefore the
developer should be able to do little to no modiÔ¨Åcation of his own
code before he can start integrating the example code.
However, once he starts to integrate the code, A NDROID STUDIO
warns him that the new code contains deprecated APIs. Specif-
ically, three methods in the code example have been deprecated:
setPictureListener() and capturePicture() in class android.webkit.
WebView and onNewPicture() in class android.webkit.WebView.
PictureListener . The setPictureListener() andonNewPicture() meth-
ods were deprecated in API level 12 and capturePicture() in API
level 19, but the developer uses API level 21. The developer de-
cides to Ô¨Ånd the replacements for the deprecated APIs, starting
with setPictureListener() . This time, he resorts to the ofÔ¨Åcial A N-
DROID documentation to see if this API has been replaced by an-
other one. However, the ofÔ¨Åcial documentation [2] for method
setPictureListener() merely states, ‚ÄúThis method was deprecated in
API level 12. This method is now obsolete.‚Äù
The developer again decides to search the web to see how others
might have solved this problem. He uses the keywords ‚Äúandroid
setpicturelistener obsolete‚Äù to do another search. However, this
time the top result from G OOGLE is a S TACK OVERFLOW post [7]
that merely refers back to the ofÔ¨Åcial documentation.
1All data collected as of 21 September 2015.
Figure 1: Answer addressing developer‚Äôs need? [33]
Having wasted much time, the developer decides to undo the
changes to his code, and return to his Ô¨Årst search instead of looking
for replacements to the deprecated APIs. He clicks the second link
in the G OOGLE search results [23]. The answer to the question
states that the answer was found in another S TACK OVERFLOW
post. So again the developer goes to that answer. After evaluating
the code example here, he decides to use it and he succeeds.
At this point, the developer has wasted a signiÔ¨Åcant amount of
time and energy, making multiple false starts. If he had been able to
know whether a code example contains usages of deprecated APIs
and furthermore, which APIs used there are deprecated, he could
have either avoided spending time understanding the code example
by immediately searching anew for alternatives or begun looking
for the replacements of the deprecated APIs early on.
3. A RETROSPECTIVE ANALYSIS
Our Ô¨Årst goal is to study how API deprecation has been used in
JAVA third party frameworks and libraries. In particular, we focus
our study on the deprecation of API methods and constructors be-
cause they tend to change more often than other API kinds (as seen
in anecdotes and informal investigations). Henceforth, ‚Äúdeprecated
APIs‚Äù refers exclusively to deprecated API methods and construc-
tors unless otherwise speciÔ¨Åed. We address Ô¨Åve research questions:
RQ1 . Is API deprecation underused?
RQ2 . How are deprecated APIs documented?
RQ3 . How often does un-deprecation occur?
RQ4 . How often are deprecated APIs removed later?
RQ5 . When do deprecated APIs get removed?
Section 3.1 describes our criteria to choose the systems used in the
study. Section 3.2 describes our process to gather API deprecation
data. And lastly, Section 3.3 describes our data analysis address-ing the research questions. Detailed data, results, and graphics are
available elsewhere.2
3.1 Selection of Frameworks and Libraries
We used MVNR EPOSITORY ,3a search engine for M AVEN projects
on M AVEN CENTRAL REPOSITORY ,4to select libraries used in this
study. We selected only projects that are J AVA third party frame-
works or libraries, based on the following criteria. First, we chose
open source frameworks and libraries because their source and bi-
nary code are relatively easier to obtain than closed source ones;
source and binary code of a framework or library can help us con-
struct an API change history and pinpoint when exactly an API
gets deprecated and when a deprecated API gets removed. Second,
we chose frameworks and libraries that are well known and widely
used by J AVA developers; changes to the APIs in those frameworks
and libraries affect a large number of developers. All the frame-
works and libraries we chose were from the most popular projects
on MVNR EPOSITORY .5The ranking is based on how many other
projects on M AVEN CENTRAL REPOSITORY depend on it. Third,
we chose libraries that have existed for at least 6 years so that API
deprecations would have time to change in some manner.
We selected 26 J AVA open source third party frameworks and
libraries, for a total of 690 versions, for our study. The average
number of releases for the systems in our study is 26.5 while the
average time span for the systems is 10 years. With the exception
of three systems ( JDOM, LOGBACK and NEKO HTML), the Ô¨Årst
versions of the systems all start from 1.0 or later in our study.
3.2 Data Gathering
To track deprecated APIs, we considered the questions: (1) when
was an API deprecated, and (2) what happened to the API later?
Our process of gathering deprecation data follows. We down-
loaded as many versions of the libraries as possible from their of-
Ô¨Åcial website if an ofÔ¨Åcial archive was available there. When an
ofÔ¨Åcial archive was not available, we downloaded the source and
binary code of the libraries from the M AVEN CENTRAL REPOSI -
TORY instead. We used source and binary code because they are
the most reliable sources of this information.
After obtaining the library versions, we used two tools to process
them: (1) QD OX6(a parsing tool for J AVAcode that can extract var-
ious information about the code entities therein) to parse the anno-
tations and J AVADOC of the entities in every version of the libraries
to get a list of deprecated APIs in each version; and (2) C LIRR7
(a tool to check J AVA libraries for binary and source compatibility
between versions) to Ô¨Ånd important API changes.
We note also that, on M AVEN CENTRAL REPOSITORY , a sin-
gle framework or library can correspond to multiple artifacts, e.g.,
COMMONS COLLECTIONS corresponds to two different artifacts.
We calculated API changes across such boundaries.
3.3 Data Analysis
RQ1. Is API deprecation underused?
We found that all the systems in our study deprecated some APIs
during the studied development spans, illustrating that API depre-
cation in J AVA third party frameworks and libraries is a common
practice. However, we also found that Ô¨Åve systems only depre-
2http://lsmr.org/data/deprecation-watcher/
3http://mvnrepository.com/
4http://central.sonatype.org/
5http://mvnrepository.com/popular , accessed in March 2015
6http://qdox.codehaus.org/
7http://clirr.sourceforge.net/cated APIs in one version ( COMMONS -LOGGING ,MAVEN -MODEL ,
MAVEN -PLUGIN -API,NEKO HTML, SLF4J); the number of depre-
cated APIs in these versions is also small.
We found that the limited use of API deprecation cannot be at-
tributed to the fact that these systems have already stabilized before
reaching the version that is the Ô¨Årst version used in our study. For
instance, NEKO HTML only deprecated one API even though its
Ô¨Årst version used in our study is 0.1. It has also removed 32 APIs
in 57 versions over the course of 12 years, which is in sharp con-
trast with the number of its deprecations. In the majority of the
systems, removed APIs outnumber deprecated APIs signiÔ¨Åcantly
and in many cases the two sets do not overlap. We found that API
deprecation is indeed underused since many APIs were removed
without prior deprecation.
RQ2. How are deprecated APIs documented?
Deprecation messages are important for developers to decide what
to do with deprecated APIs. A deprecation message that links to
the replacement of the deprecated API helps developers migrate to
the new one. A deprecation message can also offer other relevant
information about the deprecation such as the rationale for the dep-
recation and when the deprecated API is expected to be removed.
To analyze how library developers use deprecation messages, we
extracted the deprecation messages associated with every depre-
cated API; not all deprecated APIs came with a message but we
found that the majority of them did. When an API does not have
an associated message, we consider its deprecation message to be
empty. We found that 12 of the 26 systems changed some of their
deprecation messages in a later version. In such cases, we use the
revised deprecation messages. We manually examined the depre-
cation messages to answer the following questions.
How often do deprecation messages refer to a concrete replace-
ment? We manually classiÔ¨Åed deprecation messages into four cat-
egories based on whether a concrete replacement is given: without
replacement ,no mention of a replacement ,a vague replacement ,
anda concrete replacement . The difference between the Ô¨Årst two
categories is that the deprecation message in the former speciÔ¨Åcally
states that there is no replacement for the deprecated API while the
latter signiÔ¨Åes the absence of any statement. A vague replacement
offers only a general sense for a migration path.
We found that, on average, only 55.1% of all deprecation mes-
sages offered concrete replacements for the deprecated APIs. Only
two systems (C OMMONS IO and NEKO HTML) offered concrete
replacements for all of their deprecated APIs, but NEKO HTML
only deprecated one API in total. For 27.0% (7 out of 26) of the
systems, concrete replacements were speciÔ¨Åed for less than 20% of
their deprecated APIs. Six out of the 7 systems did not refer to a
concrete replacement for any of their deprecated APIs.
How often do deprecation messages offer explanations? Knowing
why a certain API has been deprecated helps developers make in-
formed decisions. Deprecation messages were classiÔ¨Åed into two
categories: with explanation andwithout explanation .
We found that on average, only 9.1% of the deprecation mes-
sages offered an explanation for the deprecated API. In fact, close
to half (11 out of 26) of the systems offered no explanation for any
of their deprecated APIs. The GSON library has the highest per-
centage overall of messages containing an explanation, but still at
a mere 50%. Our results show that developers of these systems
tend not to explain their decisions in deprecation messages; since
IDEs like E CLIPSE can display deprecation messages for depre-
cated APIs, developers fail to utilize the most convenient place to
communicate their decisions.How often do deprecation messages specify a time frame for dele-
tion? Knowing when an API will be removed in the future af-
fects the priority that developers assign to various changes needed
to their projects. We classify API deprecation messages into three
categories: no removal plan ,a vague removal plan , and a concrete
removal plan .A vague removal plan merely states that the depre-
cated API will be removed in the future, while a concrete removal
plan offers the speciÔ¨Åc future version.
We found that on average, only 5.7% of the deprecation mes-
sages in the systems offered a concrete removal plan for the dep-
recated APIs. The majority (19 out of 26) of the systems did not
specify any plan for any of their deprecated APIs. Only 27.0% (7
out of 26) of the systems had concrete plans for the removal of
some of their deprecated APIs.
In summary, our results for RQ2 show that API producers do not
make use of deprecation messages well enough to help API con-
sumers migrate from deprecated APIs. Less than a quarter of the
systems speciÔ¨Åed all replacements of the deprecated APIs. Further-
more, most systems do not offer explanations for their API depre-
cations, nor specify when deprecated APIs will be removed.
RQ3. How often does un-deprecation of APIs occur?
APIs are sometimes un-deprecated. We tracked deprecated APIs
in each library over time to see if they stopped being marked as
deprecated in a later version. The results show that almost half (12
in 26) of the systems have un-deprecated some of their APIs during
the time span examined in our study. By manually examining these
cases, we observed that in most cases the un-deprecated APIs still
existed at the end of the period.
In 3 systems (JU NIT,LOG4J, and X ERCES IMPL), some APIs
were Ô¨Årst removed, then brought back and immediately marked as
deprecated. We call this phenomenon remove‚Äìresurrect‚Äìdeprecate
in comparison to the classic deprecate‚Äìreplace‚Äìremove cycle. We
hypothesize that this indicates that library developers have falsely
assumed that these APIs were not used by API consumers and went
forward to remove them. Un-deprecation and the phenomenon of
remove‚Äìresurrect‚Äìdeprecate indicate that API producers lack suf-
Ô¨Åcient knowledge of how their systems are being used.
RQ4. How often are deprecated APIs removed later?
We tracked deprecated APIs in the systems over consecutive ver-
sions; if they stop appearing in a version, they are deemed as re-
moved. We found that 42.3% of the deprecated APIs were later re-
moved, in sharp contrast to the 0% reported elsewhere [31], due to
Raemaekers et al. having overlooked the J AVADOC @deprecation
tag and artiÔ¨Åcial boundaries subdividing single projects within the
MAVEN CENTRAL REPOSITORY . Further investigation found that
systems differ greatly in this aspect: some removed all their depre-
cated APIs while the majority of them removed none. We catego-
rize the systems into the following three cases.
All the deprecated APIs were removed . Only 15.4% (4 out of 26)
of the systems removed all their deprecated APIs ( COMMONS -
COLLECTIONS ,COMMONS -CONFIGURATION ,MAVEN -MODEL ,
NEKO HTML). Two systems only had one or two API deprecations
in total ( MAVEN -MODEL ,NEKO HTML).
None of the deprecated APIs have ever been removed . A total of
53.8% (14 out of 26) of the systems never deleted any of their dep-
recated APIs during the time periods in our study.
Some of the deprecated APIs were removed . The remaining 30.8%
(8 out of 26) of the systems removed some of their deprecations.
Deprecated APIs that are not removed yet in this group may or
may not be removed in later versions.The fact that more than half of the systems never removed any
of their deprecated APIs suggests that the developers of these sys-
tems are highly concerned with backward compatibility and fear to
introduce breaking API changes by removing deprecated APIs. In
the extreme, there is even evidence that some API producers intend
tonever remove deprecated APIs if possible [12].
RQ5. When are deprecated APIs removed?
We chose to examine when deprecated APIs were removed in sys-
tems that have removed more than two deprecated APIs, because
it is hard to generalize from systems that removed less than two
deprecated APIs. Seven out of the twelve systems fulÔ¨Åll this con-
dition. We categorized these systems based on when they removed
their deprecated APIs: before version 1.0 ,during transitions to ma-
jor releases , and other versions . Different frameworks and libraries
have different conventions about what is a major release. For ex-
ample, LOG4Jconsiders 1.2 to be a major release.
All the systems removed deprecated APIs during transitions to
a major release. JDOM removed its deprecated APIs before ver-
sion 1.0 and during its transition to 1.0. Five systems removed
their deprecations exclusively during their transition to major re-
leases. Since no versions before 1.0 of these systems were used
in the study, it is unclear if they removed deprecated APIs in these
versions. LOG4Jis the only system that removed deprecated APIs
in non-major releases. It removed 3 out of its 85 deprecated APIs
in two non-major releases: 1.1.3 and 1.2.1. Overall, 74.4% of the
removed deprecated APIs were removed during the transition to
major releases and 99.0% of the removed deprecated APIs were
removed either before version 1.0 or during transitions to major
releases. We hypothesize that API developers are concerned with
the backward compatibility of their systems. We note an inconsis-
tency, however, since we also found that many APIs were removed
without being deprecated Ô¨Årst.
Overall, our study shows that deprecation is treated sporadically
and inconsistently both within single systems and across systems.
The lack of migration paths, explicit removal plans, and rationales
all limit the API consumer‚Äôs ability to act both proactively and re-
actively. Given these problems, we could at least do a better job of
informing them that an API is deprecated.
4. TOOL AND FRAMEWORK
Our second goal is to provide a tool for developers to warn about
when an example uses deprecated API. Figure 2 shows a code ex-
ample involving deprecated APIs under which a warning message
has been inserted by our tool, called D EPRECATION WATCHER .
The version-sensitive framework underlying this tool (see Fig-
ure 3) consists of three components: (1) an extractor/proÔ¨Åler for
code elements, (2) a version-sensitive API matcher, and (3) a visual
feedback component. In D EPRECATION WATCHER , the code ele-
ment extractor and visual feedback component work on the client
as an extension to the G OOGLE CHROME web browser, while the
version-sensitive API matcher works on a server.
4.1 Extractor/ProÔ¨Åler
The framework needs access to the source code example. Most
modern web browsers allow external programs to extend their func-
tionalities. With the permission of the web browser user, they make
the HTML and D OCUMENT OBJECT MODEL (DOM) of the cur-
rent webpage available to extensions.
To extract code elements from the source code examples, we Ô¨Årst
extract the code snippets on a webpage that are contained in <pre>
or<code> HTML tags, which is the norm on the web today. WeFigure 2: D EPRECATION WATCHER identiÔ¨Åed the usage of a
deprecated API in the code example and appended a warning
message below it with the details.
 
Code examples  
Visual  
feedback  
Extractor/profiler  
EXTENSION  
WEBPAGE  
BROWSER  
API matcher  
 Database  
SERVER  
Figure 3: The structure of the framework.
1protected Dialog onCreateDialog( intid) {
2 Dialog dialog;
3 switch (id) {
4 case 0:
5 dialog = new Dialog( this);
6 dialog.setContentView(R.layout.paused);
7 dialog.setTitle("Game Paused");
8 dialog.show();
9 break ;
10 default :
11 dialog = null;
12 }
13 return null ;
14}
Figure 4: Example code containing a call to setContentView() .
also process code snippets and reconstruct the lines in the code
snippets before extracting code elements from them. The extraction
is processed locally in the browser.
The next step is to construct a proÔ¨Åle for every code element in
the source code example (see Figure 4). To match code elements in
the code snippets, we created JavaScript-based regular expressions
(see Figure 5), matching them to every line in the code snippetvartypeVaribleRegex = /(\w+(?:\.\w+)?)\s(\b[a  z]\w{0,})/g;
varmethodRegex = /(\b[a  z]\w+)\(/g;
varcallerMethodRegex = /(\w+)\.(\w+)\(/g;
varargsRegex = /\((.?)\)/;
Figure 5: Regular expressions used to extract code elements.
(For argsRegex , the number of arguments in any matched,
non-empty string equals the number of commas plus one. Not
used for nested calls.)
{ "kind": "method",
"name": "setContentView",
"cName": "Dialog",
"args": 1,
"type": "void",
"tags": [ "android", "contacts" ] }
Figure 6: The proÔ¨Åle for the example code element.
in order to construct a proÔ¨Åle for them. The proÔ¨Åle that is built
for a code element depends on: (1) how much information can be
extracted, given that many code examples on the web lack detailed
information such as the fully qualiÔ¨Åed name of classes; and (2) the
strategy that the API matcher uses to match a deprecated API since
the API matcher uses the code element proÔ¨Åle for matching. Many
pieces of information about a code element could be used in the
proÔ¨Åle. For example, for setContentView() in the code example in
Figure 4, our tool extracts the following types of information:
Kind of code element (kind). The kind of an API can be
class ,interface ,method ,constructor , or Ô¨Åeld. The kind of
setContentView() ismethod because it matches the regular expres-
sion for a method call.
Name of code element (name). The name here is setContentView() .
Name of enclosing class (cName). The name of the enclosing class
for the code element is Dialog . This information is inferred through
the context in the code. In line 2, a variable named dialog of type
Dialog is declared, which is stored into the context for the code
example. In line 6, setContentView(R.layout.paused) is invoked on
dialog .
Argument count (args). The code element takes one argument.
Return type (type). The (inferred) return type of the code element
isvoid.
Semantic tags (tags). The tags attached to the post are ‚Äúandroid‚Äù
and ‚Äúcontacts‚Äù.
The proÔ¨Åle for the code element setContentView() constructed with
the information above is shown in Figure 6. The algorithm we use
in the extractor/proÔ¨Åler is shown in Figure 7. (We have found that
the tool works better when we also include code elements from
the question posts as part of the context CQbecause answer posts
sometimes refer to the types and variables used in the question.)
The D EPRECATION WATCHER client-side asynchronously sends
each proÔ¨Åle constructed for an example to the server for matching.
4.2 Version-Sensitive API Matcher
The version-sensitive API matcher must attempt to map each pro-
Ô¨Åle to a concrete deprecated API in the target framework or library.
The matcher in our tool matches against a repository of all APIs in
the target system. The set of APIs in a framework or library can
be obtained in several ways as mentioned in Section 3.2. Our API
matcher is version-sensitive in that it returns its result based on the
developer-conÔ¨Ågured version that the API matcher uses.1CQ fg context of question
2CA fg context of answer
3P fg set of proÔ¨Åles
4foreach s2Q each snippet in question
5 doL RECONSTRUCT -LINES (s)
6 foreach l2L
7 doCQ CQ[EXTRACT -CONTEXT (l)
8foreach A2A each answer in answers
9 do foreach s2A each snippet in answer
10 doL RECONSTRUCT -LINES (s)
11 foreach l2L
12 doCA CA[EXTRACT -CONTEXT (l)
13 (kind;name ;cName ;args;type;tags ) 
MATCH REGULAR EXPRESSIONS (l)
14 iftype =NULL
15 thentype FINDTYPE(CQ)
16 p (kind;name ;cName ;args;type;tags )
17 P P[p
Figure 7: Algorithm to extract code elements and construct
proÔ¨Åles for them.
On the server, we built a database of all deprecated API methods
by parsing the DIFF Ô¨Åles downloaded from the ofÔ¨Åcial A NDROID
website. The DIFF Ô¨Åles were produced by the A NDROID team us-
ing the JD IFFtool.8Each DIFF Ô¨Åle contains the changes to the
ANDROID API between two consecutive API levels. We stored in-
formation such as the name of the API, the enclosing type of the
API, the deprecated version of the API, and the tag ‚Äúandroid‚Äù, into
the database so an API could be matched with a code element pro-
Ô¨Åle easily. We also stored a database of all APIs in the newest
version of the A NDROID API in the same way. Due to the fact that
the code element proÔ¨Åle only contains incomplete information of
an API, we cannot be sure whether there is really a match when
a code element proÔ¨Åle matches a deprecated API in the database.
Therefore we adopt a conservative strategy: we only consider there
to be a match when allAPIs matching the proÔ¨Åle are deprecated.
The matcher can make use of a set of heuristics to match code
element proÔ¨Åles to deprecated APIs in the database. Heuristics are
necessary because it is difÔ¨Åcult to obtain the fully qualiÔ¨Åed name of
an API from a code example on the web directly, and sound anal-
yses are likely to be expensive even when possible. We currently
use the name of the code element, the simple name of the enclosing
type, the number of arguments, and the return type as the elements
in the proÔ¨Åle that have to match exactly with a deprecated API to
announce the usage of a deprecated API. The sets of tags have to
have at least one element in common. After the matching process,
the server returns all matches of deprecated APIs.
4.3 Providing Visual Feedback
The visual feedback component must parse the result and visually
display the result to the user. The visual feedback could be designed
and implemented in several ways [25]. First, deprecated APIs can
be highlighted inline in the code snippet, mimicking IDEs where
strikethroughs signify that that API has been deprecated. However,
code snippets might already contain strikethroughs. Second, the
feedback could be presented outside the code example. This option
could offer more information about the deprecated APIs via text.
Users then would have to look through the code to locate where the
deprecated APIs are used. Finally, a hybrid of the two options is
possible. For our tool, we chose the second option as least invasive.
When the extension receives the result for a code example from
the server, it loops through all the APIs in the result and constructs
8http://javadiff.sourceforge.net/an HTML segment containing the information about the depre-
cated APIs. The information includes the name of the API, the
enclosing type of the API, the version in which the API is depre-
cated, and any deprecation message for the API. inserted.
In terms of running time performance, the non-optimized form of
DEPRECATION WATCHER described here (as opposed to the batch
processing form described below) completes its task within a max-
imum of Ô¨Åve seconds on commodity hardware.
5. EV ALUATION
For the evaluation of D EPRECATION WATCHER , we have two re-
search questions:
RQ6. How well does D EPRECATION WATCHER de-
tect deprecated API usages in source code examples?
RQ7. What factors affect how well D EPRECATION
WATCHER performs?
5.1 Selection of Code Snippets
We chose to evaluate D EPRECATION WATCHER with posts con-
taining code snippets on S TACK OVERFLOW that are tagged ‚Äúan-
droid". An accepted answer is deemed as the most helpful one by
the asker on S TACK OVERFLOW and is also the Ô¨Årst answer a de-
veloper tends to look at when browsing the site. Many of these an-
swers include source code examples to demonstrate how to accom-
plish certain tasks. In our evaluation, D EPRECATION WATCHER is
conÔ¨Ågured to use A NDROID API level 21. If an API that was dep-
recated in or before level 21 is detected in a code example, D EPRE -
CATION WATCHER will append a warning after the code example.
For batch processing: (1) we set up a database containing the
documents (questions and answers) to be processed; (2) we fed the
documents directly to the extractor/proÔ¨Åler; and (3) we replaced
the visual feedback component with a simple collector that records
whether deprecated API was detected or not for a given document.
We chose our evaluation posts from S TACK OVERFLOW ‚Äôs March
2015 data dump9with the following process. We Ô¨Årst extracted all
questions having an ‚Äúandroid‚Äù tag and their answers from the data
dump. Our database stores 638,756 documents in total. We Ô¨Åltered
the documents using the set of all deprecated A NDROID APIs by
the following two conditions. (1) The name of a deprecated API
must appear in the code examples of the accepted answer. (2) The
enclosing type name of that API must be mentioned in the docu-
ment. These conditions leverage the lexical information in a doc-
ument to Ô¨Ålter out documents that cannot possibly be detected as
having deprecated API usages by the tool, allowing us to focus our
manual analyses on relevant cases.
We ended up with 7,464 documents that satisÔ¨Åed the Ô¨Åltering
conditions. Some of the code snippets in the accepted answers of
the documents may not contain deprecated API usages because our
conditions for Ô¨Åltering are not strict enough. We then randomly
selected 200 documents out of the 7,464 for our evaluation, as de-
tailed, manual interpretation of each was needed at this stage.
5.2 Procedure
To evaluate D EPRECATION WATCHER , we reconstructed the URL
for each question in the 200 documents from its question ID and we
went to S TACK OVERFLOW to examine the code snippets. We la-
belled them based on whether they contained deprecated A NDROID
API methods, by manually checking the A NDROID ofÔ¨Åcial docu-
mentation. If the API was not present in the documentation, we
went on to check the API DIFF Ô¨Åles. (The absence of an API in the
documentation was usually due to the API‚Äôs deletion.)
9https://archive.org/details/stackexchangeThis manual process was quite time consuming. First, there can
be two or more code examples in one answer. Second, in order to
construct the signature of an API, a basic understanding of the code
example is required. In many cases, it involves reading the question
post and understanding the code snippets inside as well. Third,
there is a signiÔ¨Åcant amount of context switching involved between
checking the A NDROID ofÔ¨Åcial documentation and examining the
code snippets. As a result, the process of manually examining the
code examples in a single answer can easily take 30 minutes.
5.3 Results
We used precision and recall to measure the performance of D EP-
RECATION WATCHER . If an API was identiÔ¨Åed by D EPRECATION
WATCHER as deprecated and was manually classiÔ¨Åed as depre-
cated, it is classiÔ¨Åed as a true positive (TP). If an API was incor-
rectly identiÔ¨Åed as deprecated by D EPRECATION WATCHER , it is
classiÔ¨Åed as a false positive (FP). If a deprecated API was not cor-
rectly identiÔ¨Åed as such, it is classiÔ¨Åed as a false negative (FN).
DEPRECATION WATCHER identiÔ¨Åed 74 deprecated A NDROID
API usages in the source code examples, all of which were correctly
identiÔ¨Åed. There were 86 deprecated A NDROID API usages in total
in the code examples of the accepted answers in the 200 documents.
It thus has a precision of 100% and a recall of 86% for those 200
documents. Considering the sample size, the population recall falls
in the 95% conÔ¨Ådence interval [81.19%, 90.81%].
We also found that, out of the 74 deprecated API usages that
DEPRECATION WATCHER correctly detected, only 2 were ac-
knowledged in the answers. Both of these were used deliberately
after they were deprecated in order to target devices running older
versions of A NDROID . Furthermore, only 3 out of all the 86 dep-
recated API usages were acknowledged by the answers or their
comments. The third one, method removeGlobalOnLayoutListener
(OnGlobalLayoutListener) in class android.view.ViewTreeObserver
was used in a code example before it was deprecated and a com-
ment pointed this out at a later date.
From documents that were Ô¨Åltered away, only negative results
are possible; thus, the precision is representative of the entire docu-
ment set assuming that the random sample was representative. Re-
call could be impacted by the documents that were Ô¨Åltered away if
they contain false negatives. The Ô¨Årst Ô¨Åltering condition retains all
documents mentioning a name that matches deprecated API; there-
fore, only the second Ô¨Åltering condition could be an issue. If the
enclosing type name is not mentioned in the document, there are
two possibilities: (1) an unrelated type is being used and the match-
ing name is a coincidence, but then the occurrence is a true nega-
tive; or (2) the enclosing type name is not mentioned. The second
case could arise in an example whose enclosing type transitively
or implicitly extends a type containing the deprecated API (direct
and explicit inheritance would cause the document to be retained).
Implicit inheritance would involve a sloppy example (contravening
the S TACK OVERFLOW policy on examples [36]) that is unlikely
to result in useful comments and views, and so its practical impact
would be low. The transitive inheritance could only involve custom
classes, because the Android documentation lists all inherited enti-
ties within a class. But again, this seems unlikely since the example
would be complex, contravening the S TACK OVERFLOW policy.
5.3.1 What Factors Affect Performance?
We have found that almost all FNs in the evaluation arise from the
fact that D EPRECATION WATCHER is limited in extracting infor-
mation about the code elements in a code example. More speciÔ¨Å-
cally, some of the factors that affect how well the tool performs in
recall are as follows.intscreenHeight = ( short ) Activity.getWindow().
getWindowManager().getDefaultDisplay().getHeight();
intscreenWidth = ( short ) Activity.getWindow().getWindowManager
().getDefaultDisplay().getWidth();
Figure 8: A code snippet with two chained method API calls.
intindex = 0;
if(getLastNonConÔ¨ÅgurationInstance() != null) {
index = (Integer) getLastNonConÔ¨ÅgurationInstance();
}
Figure 9: A code snippet with typecasting.
Chained method calls . This factor mostly affects the code ele-
ment extractor. Since D EPRECATION WATCHER relies on sim-
ple regular expressions to extract API information, it is not able
to extract the return types and the enclosing class of APIs inside
a chained method call; an example of this is shown in Figure 8.
DEPRECATION WATCHER failed to identify the deprecated meth-
odsgetHeight() andgetWidth() in this code snippet because it failed
to identify the class they belong to. In the matching process, the
API matcher tries to match the proÔ¨Åles of code elements getHeight()
andgetWidth() , only to Ô¨Ånd that several APIs with the same names
exist in different classes and some of them are not deprecated. As
a result, D EPRECATION WATCHER was not able to correctly map
the code elements into deprecated APIs.
Class hierarchy . Our approach also ignores important type rela-
tionships like class inheritance in J AVA. This factor affects both
the code element extractor and the API matcher. The code ele-
ment extractor cannot identify the types some APIs belong to in
some cases. For example, if a class Aextends class Band calls a
method m, DEPRECATION WATCHER would not know that method
mcomes from class B. The API matcher also matches types di-
rectly without taking the class hierarchy in the system into account.
In J AVA an object can be type cast (explicitly or implicitly) to its
subclass or superclass type. In Figure 9, the return type of API
getLastNonConÔ¨ÅgurationInstance() in class android.app.Activity has
been typecast to Integer . As a result, D EPRECATION WATCHER
misconstructs the code element proÔ¨Åle for the code element here
and consequently the API matcher was not able to return a match.
5.4 Evaluating Alternative Heuristics
The heuristics we used in the evaluation are the name, the num-
ber of arguments, the enclosing type, and the return type. Alter-
native heuristics could lead to a better result. But the example in
Figure 9 shows how an extra heuristic may actually hurt the per-
formance. In that speciÔ¨Åc example, the return type of the API
getLastNonConÔ¨ÅgurationInstance() was typecast to Integer . As a re-
sult, the tool misconstructs the proÔ¨Åle for this code element and no
match was found by the API matcher that tried to use all heuristics.
This prompted us to evaluate, after the fact, the performance on
the same examples of three other combinations: (1) the name and
the number of arguments; (2) the name, the number of arguments,
and the return type; and (3) the name, the number of arguments,
and the enclosing type. The results are shown in Table 1.
We found that the combination using only the name and the
number of arguments performs as well as the combination that
also includes the return type of a code element. Both of them
were able to correctly identify a case that the other missed, but
at the cost of missing a case that the other detected: the Ô¨Årst set
of heuristics was able to correctly detect code element getLastNon -
ConÔ¨ÅgurationInstance() in Figure 9 while the second set of heuris-Table 1: Three more heuristic combinations were tried. N =
name; A = # of arguments; R = return type; E = enclosing type.
Heuristics TP FP FN Precision Recall
N, A 52 1 36 98.1% 59.1%
N, A, R 52 1 36 98.1% 59.1%
N, A, E 77 0 11 100.0% 87.5%
1ProgramFragmentFixedFunction.Builder builder = new
ProgramFragmentFixedFunction.Builder(mRS);
2builder.setTexture(ProgramFragmentFixedFunction.Builder.
EnvMode.REPLACE, ProgramFragmentFixedFunction.
Builder.Format.RGBA, 0);
3ProgramFragment pf = builder.create();
4pf.bindSampler(Sampler.WRAP_NEAREST(mRS), 0);
Figure 10: A code snippet where return type aided detection.
public void updatePage(CurlPage page, intwidth, intheight, int
index) {
switch (index) {
case 0: {
Bitmap front = loadBitmap(width, height, 0);
page.setTexture(front, CurlPage.SIDE_FRONT);
page.setColor(Color.rgb(180, 180, 180), CurlPage.
SIDE_BACK);
break ;
// ...
}
Figure 11: A case of incorrect detection.
tics was not. However, with the help of the return type information,
the second set of heuristics was able to correctly detect a depre-
cated API in a code example [17] that the Ô¨Årst set was not able to
(see Figure 10): the return type ProgramFragment of the code ele-
ment create() in line 3 helped to detect a usage of deprecated API.
The Ô¨Årst two sets of heuristics also incorrectly detected a code
element as deprecated API due to the fact that they do not make
use of the enclosing type of the code element. (The relevant part of
the code example [3] is shown in Figure 11.) The code element
setTexture() was incorrectly detected as a deprecated A NDROID
API even though it was from an external library because the type
of code element page was not utilized.
We also found that the third combination of heuristics was able
to outperform the heuristics we used to evaluate D EPRECATION
WATCHER , despite it not making use of the return type.
We learned two lessons from evaluating these sets of heuristics.
First, more heuristics do not necessarily lead to a better result. The
addition of the return type of a code element as a heuristic does not
help improve the performance of the tool when other heuristics are
also applied. In the evaluation it proved to be useless when the en-
closing type of a code element is included as one of the heuristics.
This is somewhat expected since the return type is not considered
as part of the method signature in J AVAand two APIs differing only
in return type cannot co-exist in the same class.
Second, the detailed design of the heuristics matters. Had the
code element extractor allowed for the return type to be typecast
to another type, it would not have misconstructed a code proÔ¨Åle in
such cases. The return type would remain as a useless heuristic
but would not have hurt the tool‚Äôs performance. This has a greater
implication: It can be hard to add complex heuristics even though
in theory they may improve the performance, as complex heuristics
tend to call for complex, error-prone implementations.6. DISCUSSION
6.1 Why Lightweight Tooling SufÔ¨Åces Here
DEPRECATION WATCHER works well despite extracting only sim-
ple (essentially lexical) information from examples and performing
only simple analyses thereon. We were initially surprised at how
well this simple approach worked, expecting to encounter frequent
situations where ambiguity arising from lack of semantic informa-
tion would lead to poor recommendations. The fact that such prob-
lems occurred rarely can be attributed to the fact that code exam-
ples on S TACK OVERFLOW are intentionally kept simple and self-
contained so as to be easily understood. D EPRECATION WATCHER
in its current form could not fare as well if general source code
were analyzed. However, alternative analyses of greater complex-
ity would slow down the tool, reducing its usability.
6.2 Deprecation Messages
We found that nearly half of the deprecation messages do not pro-
vide information on how to replace the deprecated APIs. A possi-
ble cause for this is that there is no standard format for deprecation
messages, urging conformance from API producers. As a result,
developers only include what they think is necessary. Therefore, it
could be beneÔ¨Åcial to establish a standard format and tool support
for deprecation messages. Such standardization would also enable
the creation of tools to analyze deprecation messages. For instance,
to Ô¨Ånd all the deprecated APIs with a replacement and replace them
automatically, or to generate a report for all the deprecations in a
system and prioritize them based on information in the deprecation
messages. We believe such standardization would not create much
more overhead for developers of frameworks and libraries. API
deprecation does not happen in every release of a system and when
it does happen in a release, in most cases, not many APIs are dep-
recated simultaneously. Furthermore, we observed in the systems
we studied, many APIs get deprecated due to the same, underlying
change and can be removed in the future in the same version. A
tool could use this information and reduce developers‚Äô workload.
6.3 Removing APIs
Removing APIs without prior deprecation seems dangerous be-
cause it can break client code without warning. Two factors may
contribute to this phenomenon. First, it is likely unrealistic to dep-
recate APIs and retain them when a framework or library undergoes
radical structural changes. Second, developers of frameworks and
libraries remove APIs that they assume are not being used. When
examining release notes, we noted that developers often make as-
sumptions about how APIs in their systems are being used. (For ex-
ample, in the release notes of C OMMONS COLLECTIONS 4.0 [4], in
the removed classes section, the developers state ‚Äúremoved unused
class AbstractUntypedCollectionDecorator .‚Äù)
Our results imply that developers are reluctant to remove depre-
cated APIs. However, when they do, the removal usually happens
either before version 1.0 or during transition to major releases‚Äî
and different systems have different conventions about what con-
stitutes a major release. Many treat any release with an increase in
the major release number as a major release while others treat re-
leases with an increase in minor release number as major releases as
well. Adopting semantic versioning [30] would be good for both
API producers and consumers, providing greater clarity over the
signiÔ¨Åcance of new versions for planning by both parties.
6.4 Web Search in Software Development
Web search has proven valuable to developers during software de-
velopment tasks. However, web search also has its problems: codeexamples on the web can be written with different versions of an
API, and developers can use different versions of the API as well.
When APIs are deprecated or removed, some source code exam-
ples become outdated and are no longer helpful for developers who
use the latest version of the API. At the same time, the same source
code example can be of different value for developers who use dif-
ferent versions of an API. Web search engines take neither of these
factors into consideration in their ranking of online resources.
We expect the usefulness of web search to deteriorate in the fu-
ture if nothing is done to change this situation. Our work can be
seen as an initial attempt to solve this problem. The framework
we propose keeps track of what version of an API a developer uses
in the API matcher and assesses whether a source code example
on the web using the same API can be useful for the developer by
detecting deprecated API usages.
6.5 Threats to Validity
The choice of libraries. We used a few criteria when selecting li-
braries to study. First, all the J AVA third party libraries we chose
are open source projects. Therefore, our results do not necessarily
reÔ¨Çect how API deprecation is used in closed source libraries. Sec-
ond, all the libraries we chose are widely used by J AVA developers.
As a result, our analysis may not be representative of less popular
libraries. Third, all the libraries in our study have been in existence
for at least 6 years. Therefore it may not reÔ¨Çect how new libraries
are using API deprecation. Finally, we focused only on uses of the
ANDROID API. Therefore this may not reÔ¨Çect uses of other APIs
or web-based discussions thereof.
The versions of the libraries used in our analysis. We collected as
many versions of the source code and binary code of the libraries as
possible in our study so as to pinpoint when APIs were deprecated,
removed, or un-deprecated. Unfortunately, we still were not able
to locate some versions of some libraries. As a result, the exact
version when the deprecation or deletion of certain APIs occurred
might not be accurate. This is particularly relevant to RQ5 where
we answered the question of when deprecated APIs were removed.
However, by collecting as many versions of the libraries as possi-
ble, we were able to ensure any discrepancy between the apparent
version and the actual version would be small at worst.
The use of STACK OVERFLOW .Our evaluation made use of only
STACK OVERFLOW posts. Furthermore D EPRECATION WATCHER
demonstrated strong performance because of the social limitations
on examples discussed there. While the engineering aspects of the
tool could easily be translated to similar Q&A sites, it is possi-
ble that the S TACK OVERFLOW social limitations would not be in
place. We believe that this is a dubious concern: more complex
examples lead to type ambiguity would be just as problematic to
humans on other sites, and thus there would be as much social pres-
sure to ‚Äúkeep it simple, stupid.‚Äù
The choice of posts in the evaluation. We selected posts that possi-
bly contain deprecated APIs through the two criteria mentioned in
Section 4. The Ô¨Årst criterion Ô¨Ålters out all posts that do not contain
deprecated APIs. The second criterion aims to narrow the size of
the posts down by another condition: the enclosing type name of an
API should appear either in the question or in the accepted answer
along with that API. This condition is important to Ô¨Ålter out posts
that contain APIs with a common name such as create because the
majority of them are not deprecated. Another rationale behind this
criterion is that knowing the type name an API belongs to is also
important for a developer to understand the program. In rare cases,
the enclosing type name of an API may be missing in both the ques-
tion and answer text. In these cases, even if a document contains
deprecated APIs, it would not end up in our evaluation set of posts.6.6 Future Work
Investigate why APIs are removed without prior deprecation. We
found evidence that API producers are concerned with backwards
compatibility yet many APIs were removed without prior depreca-
tion, possibly leading to broken client code. We think this paradox
merits further investigation. We examined a few relevant release
notes and found that API producers were aware of the fact that they
were removing APIs without deprecating them Ô¨Årst. However, they
justiÔ¨Åed it with the belief that these APIs were not used and the
removal of these APIs would not affect API consumers. In several
systems we also found that most of the removed APIs in question
were protected rather than public . API producers may believe that
no user would inherit the classes in question and went forward to
remove protected APIs. These hypotheses need further study.
Improve Deprecation Watcher. DEPRECATION WATCHER does
well in precision because of its conservative API matching strategy.
It only returns a match when it is certain. On the other hand, its per-
formance in recall can be improved. We found that the main factor
affecting its recall during our evaluation is that it does not deal with
many parts of a language such as the class hierarchy. First, we can
devise more complicated regular expressions to match structural in-
formation such as class inheritance and method overriding so more
useful heuristics can be used; however, this alternative may compli-
cate the implementation of the tool signiÔ¨Åcantly. Alternatively, we
could fully parse code examples to extract information; however,
this alternative could reduce usability because of slowdown.
Evaluate with developers. We evaluated D EPRECATION WATCHER
in terms of precision and recall, but with the involvement of devel-
opers, we could: collect direct evidence that deprecation problems
waste time; consider the usability of the tool. For example, timely
feedback to developers likely matters since this may affect percep-
tion of its usefulness. Furthermore, we could investigate what in-
formation is most useful to developers when a deprecated API is
detected to improve the feedback component.
7. RELATED WORK
We consider two classes of related work more closely: deprecation
practices and web-based code examples.
7.1 Deprecation Practices
Previous work from our lab has hinted at issues with API depre-
cation. Kapur et al. [18] found that deprecated entities do not al-
ways get deleted and deleted entities are not always deprecated;
they manually studied only three systems and deprecation was not
the focus. Cossette and Walker [8] found that replacement rec-
ommendations in deprecation messages were frequently missing or
incorrect; again, their focus was not on API deprecation.
Hou and Yao [16] conducted a case study of the evolution of the
AWT/S WING APIs to classify the intent behind API deprecations
and additions, rather than how API deprecation is used.
Robbes et al. [34] studied the ripple effect of API deprecation in
a SMALLTALK ecosystem and how developers react to it, Ô¨Ånding
that deprecation messages cannot be relied upon to be helpful be-
cause they can be missing or not offer concrete advice. Their study
is done on only two S MALLTALK systems and might not be repre-
sentative of how API developers use deprecation in general. They
also focused on how API deprecation in one system affects other
systems while our work focuses on how API deprecation is used
and how deprecated APIs change over time within single systems.
Ko et al. [20] studied the quality of deprecation messages in eight
JAVAlibraries and found that 61% of the deprecation messages pro-
vide replacement APIs, while rationales and concrete examples onhow to use new APIs are rarely given. In contrast, our study also
examines whether deprecation messages provide information on
when deprecated APIs are expected to be removed since this in-
formation helps developers make decisions about when to migrate
deprecated APIs. Furthermore, our study has a much larger scope.
Linares-V√°squez et al. [22] investigated how developers react to
API changes by considering the volume of discussions about A N-
DROID API changes on S TACK OVERFLOW : they found that re-
moving API methods in particular triggers more discussions and
from more experienced developers but API deprecation triggers
discussion or even confusion as well.
Espinha et al. [13] examined how deprecation policy is used by
several web service APIs and found that even when a web service
gives a long deprecation timeframe before removing its old APIs,
many developers still are not able to migrate their code in time. In
the case of the G OOGLE MAPSAPI version 2, Google gave a dep-
recation timeframe of three years initially but had to extend it be-
cause many developers were not able to migrate their code in time.
They reached the interesting conclusion that long deprecation peri-
ods leave developers too relaxed to migrate deprecated API code.
However, their study was done on web service APIs while our work
focuses on local APIs provided by libraries.
Raemaekers et al. [31] studied deprecation patterns in J AVA sys-
tems on M AVEN CENTRAL REPOSITORY . They found that dep-
recated APIs were never removed. However, they considered an
API to be deprecated only if possessing a @Deprecated annotation,
ignoring the presence of the @deprecated JAVADOC tag; further-
more, they failed to consider that projects there are sometimes sub-
divided artiÔ¨Åcially. Many researchers [10, 38, 40] seem to assume
that deprecated APIs follow the deprecate‚Äìreplace‚Äìremove cycle
where the deprecated API is replaced by a new API and eventu-
ally gets removed, even if the cycle can take a long time. However,
many deprecated APIs in various frameworks and libraries have
not been removed despite having remained as deprecated for years;
there is no indication that they will ever be removed. Furthermore,
in JAVA and many third party libraries, some deprecated APIs have
also been un-deprecated, which suggests the deprecate‚Äìreplace‚Äì
remove cycle is not the only possibility.
7.2 Web-Based Code Examples
Code examples are helpful for developers to learn APIs [35]. Com-
mercial code search engines are able to search code from a vast
number of open source projects that are available online. However,
they are mostly keyword-based [32] which limits their utility. Sev-
eral code search techniques [e.g., 5, 15, 32] have been proposed
to improve code search by utilizing structural and semantic infor-
mation of the code to make the results more relevant to developers.
These techniques are only responsible for locating code examples
and developers need to assess the code examples themselves. These
code search techniques also value relevancy over timeliness.
Two approaches aim to link code elements in a code snippet to
concrete APIs. R ECODOC[9] links code-like terms in learning re-
sources to concrete API elements, in order to solve the problem that
the learning resources may not reÔ¨Çect API changes. The B AKER
tool [37] tries to link the ofÔ¨Åcial documentation of a framework or
library with example-based resources of the framework or library
on the web so developers can beneÔ¨Åt from both at the same time.
Both approaches use partial program analysis and an oracle to link
code elements to concrete APIs. Both approaches face the chal-
lenge of ambiguity when linking code elements in code examples
to a concrete API in a framework or library; to uniquely identify an
API, a fully qualiÔ¨Åed name is required while names in free text and
code snippets tend to be ambiguous.Although both approaches work well for their purposes, neither
of them is able to address the problem of detecting deprecated API
usages in source code examples on the web. B AKER assumes that
API usages in code examples on the web are written with a speciÔ¨Åc
version of a framework or library in mind and as a result can be
mapped to that speciÔ¨Åc version of the API. This assumption is prob-
lematic for our context because code examples on the web can be
written with different versions of the API of a framework or library
in mind. This can be particularly true for new or rapidly evolving
frameworks and libraries, e.g., the A NDROID API evolves at the
rate of 115 API updates per month on average, many of which are
deprecations or deletions [24]. Similarly, R ECODOConly works on
learning resources such as documentation and supporting channels
that are known to correspond to a speciÔ¨Åc version of a framework
or library. In contrast, our approach is designed to identify only
deprecated APIs and does not assume that code examples on the
web are written with a speciÔ¨Åc version of a framework or library;
this permits D EPRECATION WATCHER to be lightweight.
8. CONCLUSION
Deprecation is an important tool for API producers and API con-
sumers, but little is known about it beyond anecdotes and assump-
tions. We examined historical data of API deprecation and removal
from 26 open source J AVA third party frameworks and libraries
(690 versions in total). We found that, while deprecation is used
by all the systems, it is underused: many APIs were removed with-
out being deprecated Ô¨Årst. Our analysis of deprecation messages
shows their poor usability: just over half of the messages offered
concrete replacements for their deprecated APIs; only 9.1% of the
deprecation messages provided a rationale for the deprecated API;
and a mere 5.7% of them speciÔ¨Åed a concrete timeframe for the
removal of the deprecated API. We found un-deprecation in almost
half of the systems we studied. We identiÔ¨Åed the phenomenon of
removal‚Äìresurrection‚Äìdeprecation of APIs within three systems as
well. More than 40% of all deprecated APIs were removed but with
uneven distribution: more than half of the systems never removed
any of their deprecated APIs and only 15.4% of the systems re-
moved all their deprecated APIs. Almost all of the deprecated-and-
removed APIs were removed either before version 1.0 or during the
transition to a major release; few APIs were removed elsewhere.
To address some of the difÔ¨Åculties that API consumers encounter
in the face of deprecation, we proposed a version-sensitive frame-
work to detect deprecated API usages in source code examples on
the web. By utilizing the API change history of a target framework
or library, we make our framework version-sensitive. We imple-
mented the framework as a prototype tool called D EPRECATION
WATCHER , which works as an extension to the G OOGLE CHROME
web browser. It gives visual feedback when usages of deprecated
API usages in a code example are detected. In our evaluation, D EP-
RECATION WATCHER achieved a precision of 1.0 and a recall of
0.86 in detecting deprecated A NDROID API usages in source code
examples in the accepted answers on S TACK OVERFLOW .
Our results have several implications. First, API producers need
to provide better deprecation messages. Second, they need tool
support to better understand how their APIs are used so they can
have more conÔ¨Ådence in removing deprecated APIs. Better sup-
port for API producers and API consumers would permit decreased
risks for both groups.
Acknowledgments
This work was supported by a Discovery Grant from the Natural
Sciences and Engineering Research Council of Canada.References
[1] Android. Documentation for class ListActivity .http://
developer.android.com/reference/android/app/ListActivity.html ,
2015. Accessed: 2015-07-20.
[2] Android. Documentation for class WebView .http://developer.
android.com/reference/android/webkit/WebView.html , 2015.
Accessed: 2015-09-21.
[3] AnilPatel. Top answer to ‚ÄúAndroid page curl with images
streaming from web?‚Äù. http://stackoverÔ¨Çow.com/a/16373967/
1062364 , 2013. Accessed: 2015-09-21.
[4] Apache Software Foundation. Apache Commons Collec-
tions: Release notes for v4.0. http://commons.apache.
org/proper/commons-collections/release_4_0.html , 2015. Ac-
cessed: 2015-09-21.
[5] S. Bajracharya, J. Ossher, and C. Lopes. Sourcerer: An infras-
tructure for large-scale collection and analysis of open-source
code. Science of Computer Programming , 79:241‚Äì259, 1 Jan.
2014. .
[6] K. Chow and D. Notkin. Semi-automatic update of applica-
tions in response to library changes. In Proc. IEEE Int. Conf.
Software Maintenance , pages 359‚Äì368, 1996.
[7] ciscogambo. ‚ÄúPictureListener is deprecated and obsolete,
is there a replacement?‚Äù. http://stackoverÔ¨Çow.com/questions/
7166534/picturelistener-is-deprecated-and-obsolete-is-there-a
-replacement , 2011. Accessed: 2015-09-21.
[8] B. E. Cossette and R. J. Walker. Seeking the ground truth: A
retroactive study on the evolution and migration of software
libraries. In Proc. ACM SIGSOFT Int. Symp. Foundations of
Software Engineering , pages 55:1‚Äì55:11, 2012.
[9] B. Dagenais and M. P. Robillard. Recovering traceability
links between an API and its learning resources. In Proc.
ACM/IEEE Int. Conf. Software Engineering , pages 47‚Äì57,
2012.
[10] D. Dig and R. Johnson. The role of refactorings in API evo-
lution. In Proc. IEEE Int. Conf. Software Maintenance , pages
389‚Äì398, 2005.
[11] D. Dig, S. Negara, V . Mohindra, and R. Johnson. ReBA:
Refactoring-aware binary adaptation of evolving libraries.
InProc. ACM/IEEE Int. Conf. Software Engineering , pages
441‚Äì450, 2008.
[12] dsaff. Response to ‚ÄúRequest for clariÔ¨Åcation / roadmap / doc-
umentation #689‚Äù. https://github.com/junit-team/junit/issues/
689, 2013. Accessed: 2015-09-21.
[13] T. Espinha, A. Zaidman, and H.-G. Gross. Web API grow-
ing pains: Stories from client developers and their code. In
Proc. IEEE Conf. Softw. Maint. Reeng. Rev. Eng. , pages 84‚Äì
93, 2014.
[14] J. Henkel and A. Diwan. CatchUp!: Capturing and replaying
refactorings to support API evolution. In Proc. ACM/IEEE
Int. Conf. Software Engineering , pages 274‚Äì283, 2005.
[15] R. Holmes, R. J. Walker, and G. C. Murphy. Approximate
structural context matching: An approach to recommend rel-
evant examples. IEEE Trans. Software Engineering , 32(12):
952‚Äì970, Dec. 2006. .[16] D. Hou and X. Yao. Exploring the intent behind API evolu-
tion: A case study. In Proc. Working Conf. Reverse Engineer-
ing, pages 131‚Äì140, 2011.
[17] A. Huerta. ‚ÄúWhat do the Renderscript FixedFunction shaders
look like?‚Äù. http://stackoverÔ¨Çow.com/a/9353027/1062364 ,
2012. Accessed: 2015-09-21.
[18] P. Kapur, B. Cossette, and R. J. Walker. Refactoring refer-
ences for library migration. In Proc. ACM SIGPLAN Conf.
Object-Oriented Programming, Systems, Languages, and Ap-
plications , pages 726‚Äì738, 2010.
[19] Karthi. ‚ÄúCapture picture from android webview‚Äù. http:
//stackoverÔ¨Çow.com/questions/7702565/capture-picture-from-
android-webview , 2011. Accessed: 2015-09-21.
[20] D. Ko, K. Ma, S. Park, S. Kim, D. Kim, and Y . Le Traon.
API document quality for resolving deprecated APIs. In Proc.
Asia‚ÄìPaciÔ¨Åc Software Engineering Conf. , volume 2, pages
27‚Äì30, 2014.
[21] B. P. Lientz and E. B. Swanson. Software Maintenance Man-
agement . Addison-Wesley, 1980.
[22] M. Linares-V√°squez, G. Bavota, M. Di Penta, R. Oliveto, and
D. Poshyvanyk. How do API changes trigger Stack OverÔ¨Çow
discussions?: A study on the Android SDK. In Proc. IEEE
Int. Conf. Program Comprehenension , pages 83‚Äì94, 2014.
[23] lolyoshi. ‚ÄúHow to capture a webview to bitmap in
Android?‚Äù. http://stackoverÔ¨Çow.com/questions/20900196/
how-to-capture-a-webview-to-bitmap-in-android , 2014. Ac-
cessed: 2015-09-21.
[24] T. McDonnell, B. Ray, and M. Kim. An empirical study of
API stability and adoption in the Android ecosystem. In Proc.
IEEE Int. Conf. Software Maintenance , pages 70‚Äì79, 2013.
[25] E. Murphy-Hill and G. C. Murphy. Recommendation deliv-
ery: Getting the user interface just right. In M. P. Robillard,
W. Maalej, R. J. Walker, and T. Zimmermann, editors, Recom-
mendation Systems in Software Engineering , chapter 9, pages
223‚Äì242. Springer, 2014.
[26] T. D. Nguyen, A. T. Nguyen, and T. N. Nguyen. Mapping
API elements for code migration with vector representations.
InProc. ACM/IEEE Int. Conf. Software Engineering , 2016.
To appear.
[27] M. Nita and D. Notkin. Using twinning to adapt programs
to alternative APIs. In Proc. ACM/IEEE Int. Conf. Software
Engineering , volume 1, pages 205‚Äì214, 2010.
[28] C. Parnin, C. Treude, and L. Grammel. Crowd documenta-
tion: Exploring the coverage and the dynamics of API discus-
sions on Stack OverÔ¨Çow. Technical report, Georgia Institute
of Technology, 2012.
[29] J. H. Perkins. Automatically generating refactorings to sup-
port API evolution. In SIGSOFT Software Engineering Notes ,
volume 31, pages 111‚Äì114, 2005.
[30] T. Preston-Werner. Semantic versioning 2.0.0. http://semver.
org/. Accessed: 2015-08-10.[31] S. Raemaekers, A. Van Deursen, and J. Visser. Semantic ver-
sioning versus breaking changes: A study of the Maven repos-
itory. In Proc. IEEE Int. Wkshp. Source Code Analysis and
Manipulation , pages 215‚Äì224, 2014.
[32] S. P. Reiss. Semantics-based code search. In Proc. ACM/IEEE
Int. Conf. Software Engineering , pages 243‚Äì253, 2009.
[33] Reno. Top answer to ‚ÄúCapture picture from android web-
view‚Äù. http://stackoverÔ¨Çow.com/a/7703007 , 2013. Accessed:
2015-09-21.
[34] R. Robbes, M. Lungu, and D. R√∂thlisberger. How do de-
velopers react to API deprecation?: The case of a Smalltalk
ecosystem. In Proc. ACM SIGSOFT Int. Symp. Foundations
of Software Engineering , pages 56:1‚Äì56:11, 2012.
[35] M. P. Robillard. What makes APIs hard to learn?: Answers
from developers. IEEE Software , 26(6):27‚Äì34, 2009.
[36] Stack Exchange. How to create a minimal, complete,
and veriÔ¨Åable example (revision 2016.3.10.3331). http://stackoverÔ¨Çow.com/help/mcve , 2016. Accessed: 2016-03-10.
[37] S. Subramanian, L. Inozemtseva, and R. Holmes. Live API
documentation. In Proc. ACM/IEEE Int. Conf. Software En-
gineering , pages 643‚Äì652, 2014.
[38] K. Taneja, D. Dig, and T. Xie. Automated detection of API
refactorings in libraries. In Proc. IEEE/ACM Int. Conf. Auto-
mated Software Engineering , pages 377‚Äì380, 2007.
[39] R. ≈†trobl and Z. Tron√≠ Àácek. Migration from deprecated API
in Java. In Companion Conf. Syst. Progr. Lang. Appl. Softw.
Humanity , pages 85‚Äì86, 2013.
[40] T. Xie, M. Acharya, S. Thummalapenta, and K. Taneja. Im-
proving software reliability and productivity via mining pro-
gram source code. In Proc. IEEE Int. Symp. Parallel Distr.
Proc. , pages 1‚Äì5, 2008.
[41] Z. Xing and E. Stroulia. API-evolution support with Diff-
CatchUp. IEEE Trans. Software Engineering , 33(12):818‚Äì
836, 2007.