Model-Driven Allocation Engineering
Uwe Pohlmann∗, Marcus Hüwe∗
∗Software Engineering, Project Group Mechatronic Systems Design, Fraunhofer IPT
Zukunftsmeile 1, 33102 Paderborn, Germany
Email: [uwe.pohlmann | marcus.huewe]@ipt.fraunhofer.de
Abstract —Cyber-physical systems (CPSs) provide sophisti-
cated functionality and are controlled by networked elec-
tronic control units (ECUs). Nowadays, software engineers use
component-based development approaches to develop their soft-
ware. Moreover, software components have to be allocated to
an ECU to be executed. Engineers have to cope with topology-,
software-, and timing-dependencies and memory-, scheduling-,
and routing-constraints. Currently, engineers use linear programs
to specify allocation constraints and to derive a feasible allocation
automatically. However, encoding the allocation problem as a
linear program is a complex and error-prone task. This paper
contributes a model-driven, OCL-based allocation engineering
approach for reducing the engineering effort and to avoid failures.
We validate our approach with an automotive case study modeled
with MechatronicUML. Our validation shows that we can specify
allocation constraints with less engineering effort and are able to
derive feasible allocations automatically.
I. I NTRODUCTION
Cyber-physical systems (CPSs) behave smart by being
controlled by software and collaborate with each other. Modern
cars are examples for CPSs. The amount of safety-critical
software increases, which makes the engineering more com-
plex. The software steers and controls the cars’ behavior.
Therefore, cars use sensor signals from many sensors that
are located in different parts of a car and are connected
to different networked electronic control units (ECUs). In
particular, a hardware platform of a modern car consists of
up to 100 networked ECUs [1]. In addition, software has to
be allocated to an ECU in order to be executed. The task of
specifying an allocation of software components to ECUs is
complicated, because of complex software architectures and
complex hardware platforms.
In the upper part, Figure 1 shows the coarse engineering
process for developing software for CPSs. In Step 1, software
engineers deﬁne a software architecture for the system. A
software architecture consists of connected software compo-
nents that could be speciﬁed using, e.g., AUTOSAR [2]. In
Step 2, hardware engineers deﬁne a hardware platform. A
hardware platform consists of connected resources like ECUs,
sensors, and actuators. In Step 3, allocation engineers deﬁne
the allocation of software components to ECUs. AUTOSAR
enables that each allocated software component is able to run
on each ECU. As a result, specifying an allocating is complex.
There exist 1005(#e#c)possible allocations for 100 het-
erogeneous ECUs ( {e1,. . . ,e 100}) and 5 software components
({c1,. . . ,c 5}). The amount of feasible combinations is reduced
by deﬁning mandatory and useful allocation constraints. In
Step 4, the developers implement the software components asProcess StepLegendSpecify
Allocation
ConstraintsSolve
Linear
ProgramDerive
Linear
EquationsDerive
Allocation
ModelArtifactImplemen-
tationHardware
EngineeringSoftware
EngineeringAllocation
Engineering1 2 3 4
Allocation
Specification
LanguageC1Linear Equations
Model and
TransformationC2Transformation
to Solver
InputC3Back-
Trans-
formationC4Software
Artifacts
Contribution
Fig. 1: Engineering Process and Paper Contribution
software artifacts or code generators derive the implementation
automatically that fulﬁlls the speciﬁcation.
“One major inﬂuence on the architecture of software
systems used in the industry are constraints that need to be
satisﬁed in order for the system to be accepted.” [3] In par-
ticular, engineers have to cope with topology-, software-, and
timing-dependencies and memory-, scheduling-, and routing-
constraints at design time. “[. . . C]onstraint satisfaction is a
crucial aspect [ . . . ] in the design of embedded systems.
However, constraints add more complexity to the [allocation]
problem.” [3] In realistic automotive systems, the constraint
set is very large and could reach about 126 thousand equa-
tions [4]. Currently, engineers use approaches like linear
programming [5] or SAT-based techniques [4] to encode the
allocation problem and to derive a feasible allocation auto-
matically that fulﬁlls all constraints. Encoding the allocation
problem as a linear program is a complex and error-prone task.
An example for a constraint is that each software component
is allocated to exactly one ECU. In terms of the previous
example, 5·100many binary decision variables xci,ejare
required to specify such a constraint. xc1,e2=1 means
that the software component c1is allocated to the ECU e2.
Analogously, xc1,e1=0means that the software component
c1is not allocated to the ECU e1. For all software components
cithe constraint/summationtext100
j=1xci,ej=1must hold to be allocated
exactly once.
This paper contributes a model-driven allocation engineer-
ing approach to provide a means to the user for specifying
allocation constraints in an easy and expressive way (cf. Step 3,
Figure 1). It enables a model-based speciﬁcation of allocation
constraints. We derive an integer linear program (ILP) based on
the allocation constraints that encodes the allocation problem.PreprintWe solve the allocation problem automatically by solving the
ILP and deriving an allocation model from the solution.
Our approach consists of our new Allocation Speciﬁcation
Language (ASL) that uses OCL operations stored in a library
(cf.C1, Figure 1). We provide the library as a standard alloca-
tion constraint library that provides various operations, which
should ease the allocation constraint speciﬁcation. Further-
more, this paper contributes a meta-model for linear programs
(cf.C2, Figure 1). We transform an allocation speciﬁcation to
a model instance of the linear program meta-model by model-
to-model transformations (cf. C2, Figure 1). The linear pro-
gram model decouples the problem description from concrete
solving mechanisms. We provide transformations from ILP
models to LPSolve [6], which is an existing ILPsolver, to solve
the linear program (cf. C3, Figure 1). Finally, we transform
the solution of the linear program via a back-transformation
to an allocation model that maps software components to
ECUs (cf. C4, Figure 1). As a result, the solving of the
whole allocation problem becomes transparent for allocation
engineers. They get a feasible solution without having to know
how to encode and solve the allocation problem as an ILP.
We validate our approach with a Brake-by-wire automotive
case study deﬁned by Aleti [7]. We specify the software
component model, the hardware platform model [8], and
the allocation speciﬁcation with our software engineering
approach M ECHATRONIC UML [9]. Our validation shows that
we can specify allocation constraints with less engineering
effort compared to using ILP directly and are able to derive
feasible allocations automatically.
The remainder of this paper is structured as follows:
First we introduce a Brake-by-wire system in Section II,
which serves as a running example. Afterwards, we present
in Section III our key contribution of this paper the ASL.
In Section IV we explain how we derive an allocation
from a given software architecture-, hardware platform-, and
allocation-speciﬁcation. We evaluate our results by describing
an automotive case study in Section V. Section VI summarizes
related work and compares it with our approach. We conclude
the paper in Section VII and give an outlook to future work.
II. R UNNING EXAMPLE :BRAKE -BY-WIRE
For illustrating our approach, we choose the Brake-by-wire
functionality from the automotive case study by Aleti [7]. We
choose M ECHATRONIC UML for implementing the system.
MECHATRONIC UML [9]–[11] is a development method for
self-coordinating CPSs. It supports a hierarchical software and
a hierarchical hardware architecture. A software architecture is
described by a component instance conﬁguration that consists
of composed software component instances . In the following,
we call component instances just components for simplicity. “A
component is a software entity that encapsulates a part of the
system behavior, which implements a certain function. Each
component deﬁnes a set of external interaction points, called
ports, for accessing its functionality.” [9] Software components
represent an application or a device. Application components
represent speciﬁc functionality and handle messages for com-
munication. Device components represent the software for
accessing sensor or actuator values and handle signals. A
signal has a value that varies depending on the time andWheel BrakePedalCalliper
sc4:
Calliper
Control
sc6/
CentralBrake
Control
sc10:
BrakePedal
Controlsc8:
WheelSpin
Detector
sc7:
WheelSpeed
Sensorsc2:
CalliperPos-
itionSensorsc1:
Temperature
Sensor
sc5:
Calliper
Clamp
Actuator
sc11:
PedalPosi-
tionSensor
sc12:
BrakeForce
Sensorsc13:
BrakeFeed-
backActuatorsc9/
Parking
BrakeSensor
Legend
Message
PortHybrid
PortSignal PortApplication
Com-
ponentDevice
Component name
:t y p ename
: typename:
typeElectronic
Control
Unit
xSensor ActuatorBus-
PortCommuni-
cation Busname:
typeSoftware Component Architecture Hardware Platform Architecture
xsc3:Park-
ingBrake
Actuator
b
u
s
4
:
C
A
N
HumanInterface
hw8:
ECUhw9:
ECU1112913 bus3:CANAssistance
hw1:
ECUhw2:
ECUhw3:
ECUbus1:CANBrake
hw5:
ECUhw6:
ECUhw7:
ECU271 35
bus2:CANhw4:
ECU
Fig. 2: Brake-by-wire System Architecture (cf. [7])
has always a value. Software components have a hierarchical
architecture: A software component is either atomic , i.e., it is
implemented directly, or it is structured , i.e., it is composed
of other components that are called component parts.
In the left part, Figure 2 shows the Brake-by-wire soft-
ware architecture. It consists of the three structured com-
ponents ( Calliper ,BrakePedal ,Wheel ), the atomic applica-
tion component sc6/CentralBrakeControl , and the atomic de-
vice component sc9/ParkingBrakeSensor . The structured com-
ponent Calliper consists of the atomic application compo-
nent part sc4:CalliperControl and the atomic device compo-
nent parts sc1:TemperatureSensor ,sc2:CalliperPositionSensor ,
sc3:ParkingBrakeActuator , and sc5:CalliperClampActuator . The
structured component BrakePedal consists of the atomic ap-
plication component part sc10:BrakePedalControl and the
atomic device component parts sc11:PedalPositionSensor ,
sc12:BrakeForceSensor , and sc13:brakeFeedbackActuator .
“In the automotive industry, an existing hardware topology
is usually used, because car models remain the same through
parts of their lifetimes.” [7] The hardware platform architecture
deﬁnes on which hardware topology the software runs. We
use the M ECHATRONIC UML hardware platform description
language [8] for modeling the hardware architecture described
by Aleti [7]. In M ECHATRONIC UML a hardware architecture
is represented by a hardware platform instance conﬁguration .
It consists of a distributed set of resources and hardware
platforms that are connected via networking connectors. A
resource represents a device, like a sensor or actuator, or
a structured resource, like an ECU, that contains memory
resources and computing resources. Software components can
only be allocated to structured resources. A hardware platformPreprintembeds a hardware platform instance conﬁguration and en-
ables hierarchical modeling. Networking connectors are either
direct links that connect resources or hardware platforms
directly or are communication buses.
In the right part, Figure 2 shows the hardware platform
for the Brake-by-wire system. It consists of the three sub-
platforms Assistance ,Brake , and HumanInterface .Assistance
consists of three structured resources hw1:ECU ,hw2:ECU ,
and hw3:ECU that are connected by bus1:CAN . The hardware
platform Brake consists of four structured resources hw4:ECU ,
hw5:ECU ,hw6:ECU , and hw7:ECU that are connected by
bus2:CAN . These ECUs have access to the temperature sensor
1, the wheel speed sensor 7, the calliper position sensor 2, the
parking brake actuator 3, and the calliper clamp actuator 5. The
hardware platform HumanInterface consists of two structured
resources hw8:ECU and hw9:ECU . These ECUs have access
to the pedal position sensor 11, the brake force sensor 12, the
parking brake sensor 9, and the brake feedback actuator 13.
The structured resources hw2:ECU ,hw3:ECU ,hw4:ECU , and
hw8:ECU are additionally connected by bus4:CAN .
According to Aleti [7], the software components
sc11:PedalPositionSensor and sc12:BrakeForceSensor must
be allocated to the same ECU. The structured component
Wheel consists of the atomic application component part
sc8:WheelSpinDetector , and the atomic device component part
sc7:WheelSpeedSensor . According to Aleti [7], both compo-
nents must be allocated to the same ECU.
III. A LLOCATION SPECIFICATION LANGUAGE
(CONTRIBUTION C1)
During the allocation step, engineers have to specify al-
location constraints. The primary design goal of the ASL
is to provide a means to the user for specifying allocation
constraints in an easy and expressive way. In order to achieve
this, the language embeds OCL [12], which is widely used in
the model-driven world. Thus, we assume that the potential
users of the ASL are already familiar with OCL.
A. Constraint Kinds
We identiﬁed four different allocation constraint kinds from
the literature [4], [5], [13]–[15]. The constraint kinds are
collocation ,separateLocation ,requiredLocation , and require-
dResource , which we introduce in the following paragraphs.
In a later step, each kind has to be transformed in a different
way to a set of constraints of an ILP. Knowing the limited
number of possible constraint kinds enables to specify this
transformation. It handles each user-deﬁned allocation con-
straint that ﬁts into our kind schema. The general idea is that
for each of the constraints an OCL expression is speciﬁed by
the user, which has a speciﬁc OCL type. Using the previously
mentioned transformation, the OCL expression is evaluated
and its result is mapped to corresponding ILP constraints.
The collocation constraint is used to specify that two
components have to be allocated to the same ECU. Thereby,
it is possible to avoid safety-critical communication be-
tween components via an unreliable bus or it is possible
to reduce communication latencies. For example, we have
to implement a constraint that ensures that the componentsconstraint collocation collocateSC11AndSC12 {
descriptors (ﬁrstComponent, secondComponent);
ocl self .allocateToSameECU(’sc11’,’sc12’); }
Listing 1: A Constraint of the Kind collocation
constraint separateLocation separateLocationSC6aAndSC6b {
descriptors (ﬁrstComponent, secondComponent);
ocl self .allocateToDifferentECUs(’sc6a’,’sc6b’); }
Listing 2: A Constraint of the Kind separateLocation
sc11:PedalPositionSensor and sc12:BrakeForceSensor are al-
located to the same ECU as deﬁned by Aleti [7]. Thus,
we have to specify an OCL expression that evaluates to
Set{Tuple{ﬁrstComponent = sc11:PedalPositionSensor, second-
Component = sc12:BrakeForceSensor}} . Listing 1 shows this
constraint with the name collocateSC11AndSC12 of the kind
collocation . The constraint evaluates to a set that consists of
a 2-tuple whose concrete type is deﬁned by the descriptors .
The elements of the tuple can be accessed via the names ﬁrst-
Component andsecondComponent . We use the OCL operation
allocateToSameECU(instance1 : String, instance2 : String) to
deﬁne the allocation constraint that the components with the
name sc11 andsc12 have to be collocated. Later, the evaluation
result of this operation call is transformed to corresponding
ILP constraints. The OCL operation allocateToSameECU( ...)
is stored in the M ECHATRONIC UML speciﬁc allocation oper-
ation OCL library, which we introduce in Section III-C.
The separateLocation constraint is used to specify
that two components have to be allocated to different
ECUs. Thereby, it is possible to avoid that redundant
components are allocated to the same ECU and fail at
the same time in the case of an ECU hardware fault.
For example, a component, which performs safety-critical
functionality, like sc6:CentralBrakeControl , is duplicated
tosc6a:CentralBrakeControl and sc6b:CentralBrakeControl .
Both should be allocated to different ECUs. Thus, we
have to specify an OCL expression that evaluates to
Set{Tuple{ﬁrstComponent = sc6a:CentralBrakeControl, second-
Component = sc6b:CentralBrakeControl}} . Listing 2 shows this
constraint with the name separateLocationSC6aAndSC6b of
the kind separateLocation . The constraint evaluates to a set
that consists of a 2-tuple. The elements of the tuple can be
accessed via the names ﬁrstComponent andsecondComponent .
We use the OCL operation allocateToDifferentECUs(instance1
:S t r i n g ,i n s t a n c e 2:S t r i n g ) to specify that the components
with the names sc6a and sc6b cannot be collocated. The
allocateToDifferentECUs 2-tuple is syntactical the same as the
allocateToSameECU 2-tuple. Due to the distinguished kind its
semantics is the exact opposite.
The requiredLocation constraint is used to specify that a
component has to be allocated to speciﬁc ECUs or ECUs
that are part of speciﬁc platforms. Thereby, it is possible to
avoid that safety-critical components are allocated to non-
secure ECUs that are designed for entertainment purposes and
have, e.g., no trusted platform with appropriate authentication
mechanisms for access control [16]. Additionally, we have to
ensure that components, which communicate with each other,Preprintconstraint requiredLocation requiredLocationSC8 {
descriptors (component, allowedResource);
ocl self .allocateComponentToPlatform(’sc8’, ’Brake’); }
Listing 3: A Constraint of the Kind requiredLocation
are allocated to the same ECU or to ECUs that are connected
via a bus or a direct link. For instance, the component sc8
communicates with the component Wheel and sc7. So, for
example, we obtain a valid allocation, with respect to the
component communication and ECU interconnection, if we
allocate sc8to ECU hw4,Wheel to ECU hw3, and sc7to
ECU hw5.
Furthermore, not all ECUs have access to all sen-
sors. For example, only ECUs, which are connected to the
same bus as a sensor, can read the provided sensor val-
ues. As a result, e.g, the component sc8:WheelSpinDetector
has to be allocated to one of the ECUs of the Brake
platform ( hw4-hw7 ) that can read the value of the wheel
speed sensor 7, via the bus. Thus, we have to specify
an OCL expression that evaluates to Set{Tuple{component
= sc8:WheelSpinDetector, allowedResource = hw4:ECU}, ...,
Tuple{component = sc8:WheelSpinDetector, allowedResource =
hw7:ECU}} . Listing 3 shows this constraint with the name
requiredLocationSC8 of the kind requiredLocation . The con-
straint evaluates to a set that consists of several 2-tuples.
The elements of a 2-tuple can be accessed via the names
component and allowedResource . We use the OCL operation
allocateComponentToPlatform(component : String, platform :
String) to specify that the component with the name sc8has
to be allocated to one of the ECUs of the Brake platform.
Listing 4 shows the communicatingComponents constraint,
which ensures that communicating components are allocated
to ECUs that can communicate with each other. Basically,
the allocateCommunicatingComponentsToConnectedECUs()
operation computes the cartesian product of the set consisting
of pairs of communicating components and the set consisting
of pairs of connected ECUs. More precisely, its return type
isSet(Tuple(component1 : Component, resource1 : ECU,
component2 : Component, resource2 : ECU)) . The semantics
of a tuple from this set is that the component that is referred
by the named part component1 can be allocated to the ECU
referred by resource1 , while the component referred by
component2 is allocated to the ECU referred by resource2 .
Since a tuple in OCL is unordered, the tuple descriptors
descriptors (component1, resource1), (component2, resource2)
are used to group the corresponding component,
ECU pairs. That is, the semantics of the tuple
Tuple{component1 = sc8, resource1 = hw4, component2
= wheel, resource2 = hw3} is that the component sc8
can be allocated to hw4, while the component Wheel
is allocated to hw3. Changing the tuple descriptor to
descriptors (component1, resource2), (component2, resource1)
means that the component sc8can be allocated to hw3, while
the component Wheel is allocated to hw4.
The requiredResource constraint is used to specify that
an allocation has to respect certain resource restrictions.
Thereby, it is possible to avoid that more main memory of
an ECU is used by software components than an ECU pro-constraint requiredLocation communicatingComponents {
descriptors (component1, resource1), (component2, resource2);
ocl self .allocateCommunicatingComponentsToConnectedECUs(); }
Listing 4: Another Constraint of the Kind requiredLocation
vides. For example, the component sc3:ParkingBrakeActuator
needs 64kbytes , the component sc4:CalliperControl needs
512kbytes , and the component sc5:CalliperClampActuator
needs 256kbytes according to Aleti [7]. Moreover, the
ECU hw5:ECU ’s amount of available memory is 512kbytes .
Hence, it is possible that sc3and sc5are both allocated
tohw5:ECU , but, for example, sc3and sc4cannot be both
allocated to hw5:ECU . Thus, we have to specify an OCL
expression that returns for each ECU the available mem-
ory and a set that describes the memory consumption of
each component, if it is allocated to that ECU. An excerpt
of this OCL result for the ECU hw5 and the components
sc3-sc5 is:Set{Tuple{availableMemory = 512, requiredMem-
ory = Set{ Tuple{componentInstance = sc3, resourceInstance
= hw5, requiredMemory = 64}, Tuple{componentInstance =
sc4, resourceInstance = hw5, requiredMemory = 512}, Tu-
ple{componentInstance = sc5, resourceInstance = hw5, re-
quiredMemory = 256} }}} . In general, for each component,
which can be potentially allocated to hw5:ECU , the set that
is referred by the outer tuple’s requiredMemory named part
should include a corresponding tuple.
Listing 5 shows a constraint with the name maxMemo-
ryConsumption of the kind requiredResource that is used to
guarantee that the components, which are allocated to the
same ECU, do not exceed the ECU’s available memory. The
constraint evaluates to a set that consists of nine 2-tuples
(one 2-tuple for each ECU). Such a 2-tuple has the named
parts availableMemory and requiredMemory . The named part
availableMemory represents an ECU’s available memory. The
named part requiredMemory refers to a set that consists of 3-
tuples. Such a 3-tuple has the named parts componentInstance ,
resourceInstance , and requiredMemory . The requiredMemory
named part represents the required memory of the component
that is referred by the componentInstance named part, if it is
allocated to the ECU that is referred by the resourceInstance
named part.
Each 2-tuple represents a constraint whose left-hand side
(lhs) has to be smaller than or equal to the right-hand side
(rhs). The left-hand side is the sum over the referred 3-
tuples. A 3-tuple contributes its requiredMemory value to sum,
if its referred componentInstance is allocated to its referred
resourceInstance , and 0otherwise. The right-hand side is given
by the 2-tuple’s availableMemory named part. Referring to the
excerpt of the previous OCL result, we see that only certain
combinations of the components sc3-sc5can be allocated to
the ECU hw5, because, e.g., 64 + 512 + 256 ≤512(sc3-sc5
are allocated to hw5) does not hold, while 64+0+256 ≤512
(sc3,sc5are allocated to hw5andsc4is allocated to a different
ECU) holds.
B. OCL Context
We assume that all OCL expressions are speciﬁed in the
syntactical context of the class OCLContext . Figure 3 showsPreprintconstraint requiredResource maxMemoryConsumption {
lhs requiredMemory;
rhs availableMemory;
descriptors (componentInstance, resourceInstance);
ocl self .maxMemoryConsumption(); }
Listing 5: A Constraint of the Kind requiredResource
that the class OCLContext has references to the classes Com-
ponentInstanceConﬁguration and HWPlatformInstanceConﬁg-
uration . Hence, it is possible to specify OCL expressions
that refer to M ECHATRONIC UML language elements, like
StructuredComponentInstance and HWPlatformInstance .
C. Allocation Speciﬁcation Library for MECHATRONIC UML
We designed the ASL to be modular, so that it could
be reused for different languages and is not restricted to
MECHATRONIC UML. The binding to M ECHATRONIC UML
is done via a context model (cf. Figure 3) and the OCL-based
Allocation Speciﬁcation Library. The purpose of the library is
to provide frequently used OCL expressions so that the users
do not have to specify them manually.
A library encapsulates operations that are frequently used
when specifying constraints. Instead of writing operations
from scratch repeatedly, it is possible to include a library
and have access to all of its operations. The statement
include ’platform:/plugin/pluginUri/operations/OCLContext.ocl’ in-
cludes the library that is located at the speciﬁed URI. The
library OCLContext.ocl is a standard library for M ECHATRON -
ICUML that provides various operations, which should ease
the constraint speciﬁcation.
For example, Listing 6 shows the OCL operations that the
collocation constraint in Listing 1 uses. The operations are
deﬁned within a speciﬁc context. For M ECHATRONIC UML
the context is deﬁned as the class oclcontext::OCLContext .
The operation allocateToSameECU gets two Strings as in-
put and returns a Set that contains a 2-tuple in which
the two components that should be collocated are refer-
enced. For deriving these components the operation getSWIn-
stance(instanceName:String) is called. This operation searches
in all available components an instance that has the speciﬁed
name. It uses the operation getAllEmbeddedInstances() via
the operation getAllSWInstances() , which returns all available
components in the component instance conﬁguration, which is
accessed via the OCLContext’s componentInstanceConﬁgura-
tionattribute. The whole deriving process of the components
is transparent to the user who uses the allocateToSameECU
operation. In a similar way the library provides the opera-
tions allocateToDifferentECUs( ...),allocateToECU( ...),com-
municatingComponents() ,maxMemoryConsumption() for the
other constraint kinds. Currently, the library provides 31 OCL
operations, which can be used to constrain an allocation.
Allocation engineers can create their own libraries and import
them via the include statement if OCL operations are missing.
D. Formal Preliminaries
We need a formal deﬁnition of the ASL to deﬁne a mapping
to an ILP and to prove that the mapping is correct. Therefore,context oclcontext::OCLContext
def: allocateToSameECU(instance1 : String, instance2 : String)
: Set(Tuple(ﬁrstComponent : instance::ComponentInstance,
secondComponent : instance::ComponentInstance)) =
Set{Tuple{ﬁrstComponent = self.getSWInstance(instance1),
secondComponent = self.getSWInstance(instance2)}}
def: getSWInstance(instanceName : String) :
instance::ComponentInstance =
self.getAllSWInstances() −>any(name = instanceName)
def: getAllSWInstances() : Set(instance::ComponentInstance) =
self.componentInstanceConﬁguration.getAllEmbeddedInstances()
context instance::ComponentInstanceConﬁguration
def: getAllEmbeddedInstances() :
Set(instance::ComponentInstance) =
self.componentInstances −>closure(c |
if c.oclIsKindOf(instance::StructuredComponentInstance) then
c−>asSet() −>union(
c.oclAsType(instance::StructuredComponentInstance).
embeddedCIC.componentInstances)
else c −>asSet() endif )
Listing 6: OCL-Operations from the Allocation Speciﬁcation Library
for the Collocation Constraint
in the following, we provide the formal preliminaries that are
needed to deﬁne the ASL. Let Mbe the object model [12] that
is represented by the class diagram in Figure 3. Moreover,
letσ=(σCLASS ,σATT,σASSOC )be a system state for the
object model M. Basically, such a system state corresponds to
an object diagram ( σCLASS =objects, σATT=attribute values,
σASSOC =links between objects) that is typed over the class
diagram in Figure 3. Let OCL be the set of all syntactically
correct (in the context of the class OCLContext ) OCL expres-
sions. To evaluate an OCL expression Ψ∈OCL , an evaluation
environment is required. We assume that eval σ(Ψ)denotes the
evaluation result of the OCL expression Ψ∈OCL and that the
evaluation environment’s system state is σ. We usually omit
theσand simply write eval(Ψ).
LetCOMP =σCLASS (ComponentInstance )be a set
of M ECHATRONIC UML components, e.g., { sc1-sc13}. Analo-
gously, let ECU =σCLASS (StructuredResourceInstance )
be a set of M ECHATRONIC UML ECUs, e.g., { hw1-hw9}. A
mapping f∈ECUCOMP:={f:COMP →ECU }is
called an allocation. Let c∈COMP ande∈ECU . Then,
f(c)=emeans that the component cis allocated to the ECU
e.
In OCL, a tuple consists of several named parts, which are
used to access its elements [12]. Listing 7 demonstrates how
to create and access a tuple in OCL. The ﬁrst two lines deﬁne
via the keyword letthe temporary variable tas a tuple with
the named parts comp andecu. This allows us to use the tuple
twithin the subsequent expression. The third line constructs
the new tuple object and binds the object eto the named part
ecuand the object cto the named part comp . We assume
that ehas the type StructuredResourceInstance andchas the
type ComponentInstance and both variables are available in
the expression’s scope. The forth line is used to access the
element that was bound to the named part comp . Thus, the
whole OCL expression in Listing 7 evaluates to the object c.PreprintOCLContext
ComponentInstanceConfiguration
n
HWPlatformInstanceConfiguration
on
HWPlatformInstance
Networking
ConnectorInstance
ResourceInstance
PortConnector
Instance
tor
Structured
ComponentInstance
ComponentInstance
/topLevel : 
EBoolean = true[0..1] component [0..1] hardwarePlatform
[0..*] 
Instances[0..*] resources[1..1] embeddedHPIC
[0..1] 
parentHWPlatform
Instance[1..1] parentHPIC
[0..*] 
hwplatform
Instances[0..*] 
portConnector
Instances[1..1] embeddedCIC
[0..1] 
parentStructured
ComponentInstance[1..1] parentCIC
[0..*] 
component
Instances networkingConnector
nce
nce
e
InstanceConfiguration InstanceConfiguration
Structured
Fig. 3: OCLContext Meta-Model
We interpret an OCL tuple as a mathematical tuple using
the order of the speciﬁed tuple descriptors. For convenience,
we omit tuple descriptors in the following and assume the
implicit order of the named parts from the tuple’s type def-
inition. Hence, the OCL tuple tin Listing 7 corresponds to
the mathematical tuple (c, e). More generally, an OCL tuple
of the type Tuple (n1:T1,. . . ,n k:Tk), where Tiis a type, is
interpreted as the mathematical tuple (n1,. . . ,n k). Furthermore,
an OCL set sof the type Set(T), where Tis a type, is
considered as a mathematical set. For instance, to select an
arbitrary element efrom the set sthe notation e∈sis used.
let t : T uple(comp : ComponentInstance,
ecu : StructuredResourceInstance)
= Tuple{ecu = e, comp = c}
in t.comp
Listing 7: Creating and Accessing a Tuple in OCL
Formally, a constraint Φis represented by 3-tuple
(Φkind,ΦOCL T,ΦOCL E). The ﬁrst element Φkind ∈
{collocation ,separateLocation ,requiredLocation,
requiredResource }represents the kind of the constraint. The
second element ΦOCL Trepresents an OCL type. The third
element ΦOCL E∈OCL represents an OCL expression, whose
OCL type conforms to ΦOCL T.
IV . D ERIVE ALLOCATION
In this section, we present an ILP meta-model and formally
deﬁne the ASL. Moreover, we show how the constraints,
which are speciﬁed via the previously introduced ASL, can
be transformed to a corresponding ILP model. For the sake
of readability, we deﬁne the semantics of the different ASL
constraint kinds in combination with the transformation of
ASL constraints to an ILP. Generally, the ASL semantics
deﬁnition is independent of the transformation to an ILP. The
created ILP uses only binary decision. These ILPs are also
called, 0-1-ILP or a Pseudo-Boolean problem [17].
A. Linear Program Meta-Model (Contribution C2)
We provide a meta-model for general linear programs,
so that we can use model-to-model (M2M) transformation
techniques. The linear program model decouples the problem
description from concrete solver inputs, which result in a
Constraint Expression
Linear
LPDataType
BINARY
INTEGER
REAL
ObjectiveFunction
goal : 
Objective
MIN
MAX
Variable
dataType :
Variable Expression
operator : 
ComparingOperator
 = LESS
Comparing Operator
LESS
LESS_OR_EQUAL
EQUAL
GREATER
orrr
[0..*] 
variables [0..*] constraints[0..1] 
objective
Function
[1..1]  variable
[1..1] leftExpression[1..1] rightExpression[1..1] objectiveFunctionObjectiveGoal = MAXExpression
 LPDataType = BINARYGoal Program
ExpressionGREATER_OR_EQUAL
Fig. 4: Linear Program Meta-Model
better understandability and maintainability of the transfor-
mation. The 0-1-ILP model, which results from this M2M
transformation, is transformed via an Xtext speciﬁcation to
LPSolve [6]. A solution of the ILP, if it exists, corresponds
to a feasible allocation. Figure 4 shows the meta-model for
linear programs. Usually, a LinearProgram consists of un-
known variables x1,. . . ,x n∈R,mconstraints , and a linear
objectiveFunction ϕ:Rn→R.A ConstraintExpression
1≤i≤mhas the form/summationtextn
k=1ai,k·xkθbiwhere ai,k,bi∈R
and θ∈{ <,≤,=,≥,>}. The goal is to ﬁnd an assign-
ment for the unknowns x1,. . . ,x nsuch that all constraints
hold and ϕ(x1,. . . ,x n)= goal{ϕ(x/prime
1,. . . ,x/prime
n)|x/prime
1,. . . ,x/prime
n∈
Rand all constraints hold for x/prime
1,. . . ,x/prime
n}, where goal ∈
{min, max }[18]. If the xiare restricted to the LPDataType
BINARY {0,1}they are also called binary decision variables
and the linear program is called a 0-1-ILP .
B. Transformation to a 0-1-ILP and ASL Semantics Deﬁnition
(Contribution C3)
The starting point of the transformation is an allocation
speciﬁcation. The idea is that each constraint can be mapped
to a corresponding equation or inequality, respectively. We use
QVT-o to implement the corresponding M2M transformation
to the linear program model.
For all components c∈COMP and ECUs e∈ECU, we
introduce binary decision variables xc,e∈{0,1}. These binary
decision variables are meant to represent an allocation. ThePreprintbinary decision variable xc,e=1 indicates that component
cis allocated to ECU e. In order to make sure that each
component is allocated to exactly one ECU, we add the
following constraint:
/summationdisplay
e∈ECUxc,e=1 (1)
for all c∈COMP . Let fILP⊆COMP ×ECU be a binary
relation such that (c, e)∈fILPdef.⇐⇒xc,e=1forc∈COMP
and e∈ECU. Since the binary decision variables should
represent an allocation, it can be shown that the relation fILP
corresponds to a mapping. That means fILPis left-total and
right-unique [19].
In order to transform language elements like the required-
Location constraint, we have to express more advanced de-
pendencies such as component c1is allocated to ECU e1and
component c2is allocated to ECU e2. For this, we introduce
new binary decision variables and inequalities, which are based
on concepts that are presented in [15]. More precisely, for
c1,. . . ,c l∈COMP ,e1,. . . ,e l∈ECU ( l≥2), we introduce
a new binary decision variable xc1,e1,...,c l,el∈{ 0,1}. The
idea is that this variable takes the value 1if and only if
c1is allocated to e1,. . . ,andclis allocated to el. Therefore,
we have to couple it with the previously introduced binary
decision variables using appropriate inequalities [19]. Next,
we formally deﬁne the semantics of the ASL’s constraints and
their transformation to linear equalities/inequalities.
1) The collocation constraint Φis deﬁned as:
• Φkind=collocation
• ΦOCL T=Set(Tuple (
c1:ComponentInstance,
c2:ComponentInstance ))
• ΦOCL E∈OCL
The set of feasible allocations FΦ⊆ECUCOMPis deﬁned
as:
f∈FΦdef.⇐⇒ ∀ (c1,c2)∈eval(ΦOCL E):f(c1)=f(c2)
LetΦbe a collocation constraint. Φis transformed as:
/summationdisplay
e∈ECUxc1,e,c2,e=1 (2)
for all (c1,c2)∈eval(ΦOCL E). That means, that for each
tuple (c1,c2)from the evaluation result set there exists exactly
one ECU esuch that the binary decision variable xc1,e,c2,e
takes the value 1, which implies that c1and c2are both
allocated to e.
2) The separateLocation constraint Φis deﬁned as:
• Φkind=separateLocation
• ΦOCL T=Set(Tuple (
c1:ComponentInstance,
c2:ComponentInstance ))
• ΦOCL E∈OCLThe set of feasible allocations FΦ⊆ECUCOMPis deﬁned
as:
f∈FΦdef.⇐⇒ ∀ (c1,c2)∈eval(ΦOCL E):f(c1)/negationslash=f(c2)
LetΦbe a separateLocation constraint. Φis transformed as:
/summationdisplay
e∈ECUxc1,e,c2,e=0 (3)
for all (c1,c2)∈eval(ΦOCL E). That means, that for each
tuple (c1,c2)from the evaluation result set there exists no
ECU esuch that the binary decision variable xc1,e,c2,etakes
the value 1, which implies that c1andc2are both allocated
different ECUs.
3) The requiredLocation constraint Φis deﬁned as:
• Φkind=requiredLocation
• ΦOCL T=Set(Tuple (
c1:ComponentInstance,
e1:StructuredResourceInstance,
..., c n:ComponentInstance,
en:StructuredResourceInstance ))
• ΦOCL E∈OCL
Let∼be a binary relation on the set eval(ΦOCL E)such that
(c1,e1,c2,e2,. . . ,c n,en)∼(c/prime
1,e/prime
1,c/prime
2,e/prime
2,. . . ,c/prime
n,e/prime
n)def.⇐⇒
{c1,c2,. . . ,c n}={c/prime
1,c/prime
2,. . . ,c/prime
n}.∼is an equivalence relation.
The set Q:=eval(ΦOCL E)/∼denotes the quotient set,
which is the set of equivalence classes. The set of feasible
allocations FΦ⊆ECUCOMPis deﬁned as:
f∈FΦdef.⇐⇒ ∀ x∈Q:/logicalordisplay
(c1,e1,...,c n,en)∈xf(c1)=e1∧f(c2)=e2∧...∧f(cn)=en
LetΦbe a requiredLocation constraint that is transformed as:
/summationdisplay
(c1,e1,...,c n,en)∈xxc1,e1,...,c n,en≥1 (4)
for all x∈Q. That means, we require that there exists at least
one tuple (c1,e1,. . . ,c n,en)in the equivalence class xsuch
that the binary decision variable xc1,e1,...,c n,entakes the value
1, which implies that ciis allocated to eifori=1,. . . ,n .
4) The requiredResource constraint Φis deﬁned as:
• Φkind=requiredResource
• ΦOCL T=Set(Tuple (r:Real, w :Set(Tuple (
c1:ComponentInstance,
e1:StructuredResourceInstance,...,
cn:ComponentInstance,
en:StructuredResourceInstance,w :Real))))
• ΦOCL E∈OCL
The set of feasible allocations FΦ⊆ECUCOMPis deﬁned
as:
f∈FΦdef.⇐⇒ ∀ (r, w)∈eval(ΦOCL E): (5)/summationdisplay
(c1,e1,...,c n,en,w′)∈ww/primex(f,c1,e1,. . . ,c n,en)≤rPreprintAllocation
System Allocation
HWPlatformInstance
e
ComponentInstance
Structured ResourceInstance
ce
ComponentInstance
ce[1..*] allocations[1..1] cic[1..1] hpic
[1..1] componentInstance [1..1] resourceInstance[1..1] parentCIC
[0..*] componentInstances[0..*] resourcesConfiguration Configuration
Fig. 5: System Allocation Meta-Model
, where
x(f,c1,e1,. . . ,c n,en): =

1iff(c1)=e1∧...
∧f(cn)=en,
0else(6)
LetΦbe a requiredResource constraint that is transformed as:
/summationdisplay
(c1,e1,...,c n,en,w′)∈ww/prime·xc1,e1,...,c n,en≤r
for all (r, w)∈eval(ΦOCL E). This transformation directly
corresponds to the deﬁnition of the requiredResource con-
straint. Basically, we just replaced the xmapping, which
is deﬁned by Equation (6), with the corresponding binary
decision variable in Inequality (5).
5) Multiple Constraints: So far, we deﬁned for each con-
straint a set of feasible allocations. Since an allocation has to
usually respect multiple constraints, we have to deﬁne the set
of feasible allocations for a set of constraints. Let Cbe a set of
constraints. The set of feasible allocations FC⊆ECUCOMP
is deﬁned as FC:=/intersectiontext
Φ∈CFΦ
C. Back-Transformation to the System Allocation Model
(Contribution C4)
Once we transformed the allocation speciﬁcation to an ILP,
we leverage LPSolve [6] to solve the ILP. It returns the ﬁrst
feasible solution by assigning concrete values to the variables.
In order to obtain a system allocation, we parse this output.
Each variable xc,ewith xc,e=1 is transformed into an
allocation object, which references the the corresponding com-
ponent instance and ECU. For this transformation, we make
use of QVT-o’s invresolve mechanism. The created allocation
object is added as a child to a M ECHATRONIC UML system
allocation model. Figure 5 shows the M ECHATRONIC UML
system allocation meta-model. A SystemAllocation references
aM ECHATRONIC UML ComponentInstanceConﬁguration and
HWPlatformInstanceConﬁguration . An Allocation maps a Com-
ponentInstance to a StructuredResourceInstance .
V. V ALIDATION
We validate our model-driven allocation engineering ap-
proach with a Brake-by-wire case study. The Brake-by-wire
case study from Section II is based on the case study from
Aleti [7]. We conduct the case study, using the guidelines
deﬁned by Kitchenham et al. [20]. All our models (including
the ILP model) are available on our website [19].A. Context
Our objective of the case study is to evaluate whether our
allocation engineering returns correct results for a realistic
example and if it is possible to specify common allocation
constraints with less effort. The example (cf. Figure 2) consists
of 3 structured software components and 13 atomic soft-
ware components. Furthermore, it consists of 9 ECUs and
9 devices (sensors and actuators). We consider two collo-
cation constraints (Rq1:{sw11,sw12} Rq2:{wheel,sw7,sw8}),
three requiredLocation constraints (Rq3: software components,
which access devices have to be connected to the same bus,
Rq4: communicating components have to be allocated to
connected ECUs that share the same bus, Rq5: calliper and
sub-components have to be allocated to the brake platform),
and one requiredResource constraint (Rq6: consumed memory
per ECU has to be smaller or equal than available memory).
B. Hypotheses
We deﬁne two evaluation hypotheses for our case study.
Our ﬁrst evaluation hypothesis is that our allocation engi-
neering returns feasible allocations that fulﬁll all allocation
constraints. Our second evaluation hypothesis is that the ASL
reduces the engineering effort to specify the allocation con-
straints.
For evaluating our hypotheses, we generate an allocation
based on the input models and check manually if the generated
solution fulﬁlls all constraints. Furthermore, we compare the
size of the input model, which is speciﬁed with the ASL
with the number of ILP constraints that have to be speciﬁed
manually without using our method. Additionally, we measure
the time, which we need to generate a 0-1-ILP.
C. Preparation of the InputModel
In preparation of the case study, we specify all software,
hardware and allocation speciﬁcation models presented in this
paper. For the speciﬁcation, we use the M ECHATRONIC UML
Tool Suite [21] that implements the concepts of M ECHA -
TRONIC UML. The ASL is implemented with Xtext and reuses
the existing Xtext OCL tooling. The transformation from
MECHATRONIC UML to the 0-1-ILP model is implemented
with QVT-o, the transformation from the linear program model
to LPSolve [6] is implemented with Xtext.
D. Validating the Hypotheses
We create a system allocation by executing the allocation
transformation, which creates an ILP, solves it, parses the
result, and creates an instance of the system allocation meta-
model (cf. Figure 5). Table I shows this computed allocation.
The ﬁrst column shows the required memory of a software
component and the ﬁrst row shows the available memory of
an ECU. The second column shows all software components
and the second row shows all ECUs. The crossing cell of a
software component and an ECU shows 1, if the software
component is allocated to that ECU and 0 otherwise. Using
Table I, we check if the constraints Rq1-Rq6 are fulﬁlled, e.g.,
that the consumed memory is smaller or equal to the available
memory. Table I shows, by comparing the ﬁrst row with the
last row that this constraint is fulﬁlled. Furthermore, we makePreprintTABLE I: Computed Allocation
available memory →512 512 1024 1024 512 1024 1024 1024 1024
required
memory ↓ECU →
SC↓hw1 hw2 hw3 hw4 hw5 hw6 hw7 hw8 hw9
0 calliper 0 0 0 1 0 0 0 0 0
64 sc1 0 0 0 1 0 0 0 0 0
128 sc2 0 0 0 1 0 0 0 0 0
64 sc3 0 0 0 1 0 0 0 0 0
512 sc4 0 0 0 1 0 0 0 0 0
256 sc5 0 0 0 0 1 0 0 0 0
1024 sc6 0 0 1 0 0 0 0 0 0
0 wheel 0 0 0 1 0 0 0 0 0
64 sc7 0 0 0 1 0 0 0 0 0
128 sc8 0 0 0 1 0 0 0 0 0
128 sc9 0 0 0 0 0 0 0 1 0
0 brakePedal 1 0 0 0 0 0 0 0 0
512 sc10 0 1 0 0 0 0 0 0 0
64 sc11 0 0 0 0 0 0 0 1 0
128 sc12 0 0 0 0 0 0 0 1 0
64 sc13 0 0 0 0 0 0 0 1 0
consumed memory → 0 512 1024 960 256 0 0 384 0
0200040006000800010000
Create
General
ConstraintsCreate
Collocation
ConstraintsCreate
Required
Location
ConstraintsCreate
Required
Resource
ConstraintsSolve 0-1-
ILPTransf. Time 792 514 8796 2127 538# Tuples 144 3 709 9Transformation Time (in ms) / 
Number of Tuples Brake-by-wire Allocation  
(16 Components, 9 ECUs) 
Fig. 6: Performance Test
formal proofs to ensure, that our transformation to an ILP (cf.
Section IV-B) is semantics preserving [19].
Figure 6 shows the result of the performance test while
calculating the allocation for the Brake-by-wire system. The
dark gray columns show the time in ms for performing the
corresponding transformation. The light gray columns show
the number of generated tuples, which represent constraint sets.
The transformation computes 792 ms for creating 16∗9 = 144
general constraints (cf. Equation (1)) and the transformation
computes 514 ms for transforming 3 collocation tuples. The
transformation for creating the requiredLocation constraints
took the longest time with almost 9s. 709 tuples were trans-
formed. The transformation for creating the requiredResource
constraints took with 2s also very long for creating 9 tuples.
These tuples, which describe all possible memory consump-
tions, are quite large. Solving the ﬁnal, in general NP-complete
ILP, consisting of 945 binary variables and 1983 constraints,
takes only 538 ms. Our input allocation speciﬁcation has
96 LOC. It results in an ILP with 6833 LOC.E. Interpreting the Results
The results of our case study show that our model-driven
allocation engineering correctly calculates a feasible alloca-
tion. Therefore, our ﬁrst evaluation hypothesis is fulﬁlled.
Additionally, the results of our case study show that the
ﬁve constraints speciﬁed with the ASL result in 1983 ILP
constraints. Therefore, we claim that our second evaluation
hypothesis, that we need less engineering effort, is fulﬁlled.
In our case study, the threats to validity are as follows:
(1) We might have made mistakes in the manual check that
all constraints are fulﬁlled by the calculated allocation. (2) We
only considered six constraints and 3 kinds of constraints. We
omit separateLocation constraints. Even though we consider
this example as realistic, other realistic constraints could be
different. Especially, if these constraints tackle other solution
categories [3], like changing replications or parameters of
entities. (3) We did not check all possible constraints, e.g.,
we omit scheduling. (4) We are experts for using our ASL
and OCL. Therefore, we could easily specify valid allocation
constraints, which might not be true for novices.
VI. R ELATED WORK
Aleti et al. [3] provide a systematic literature review
about software architecture optimization methods. In this ﬁeld
of research, 26 percent do not consider constraints at all.
Only 7 percent give importance to physical constraints and 5
percent to memory constraints, which are critical for the design
of CPSs. We present in the following different approaches,
which consider safety-critical constraints, e.g., memory and
are related to model-driven and component-based software
engineering methods. The focus of these approaches is solving
and optimizing the allocation problem. The approaches offer
methods to specify constraints. Nevertheless, it is not attracting
the most attention, although it is a crucial task during specify-
ing the allocation problem. Therefore, we see great potential
in combining our approach with these approaches in future.
Aleti et al. [22] present a framework for modeling, evaluat-
ing, and optimizing embedded systems, called ArcheOpterix.
ArcheOperix can extract architecture descriptions by parsing
different speciﬁcation languages, like AADL or EAST-ADL.
Furthermore, ArcheOperix has an architecture analysis module
that provides the Architecture Constraint Validation Interface
to specify and evaluate constraints. As standard features, local-
ization, collocation, and memory constraints can be speciﬁed.
The constraint speciﬁcation is done by matrices. In contrast to
our approach, ArcheOperix provides no support for deriving
the constraint speciﬁcation for complex models. However,
ArcheOperix could be a future back-end for solving and
optimizing models that are speciﬁed by our presented ASL. For
this, the M ECHATRONIC UML software components, hardware
platforms, and computed allocation speciﬁcation tuples have to
be transformed into an ArcheOperix input ﬁle. Additionally,
constraint evaluators have to be developed in ArcheOpterix
forrequiredResource .
Malek et al. [15] present an extensible framework for
improving a distributed software system’s deployment archi-
tecture, called deployment improvement framework (DIF).
They provide also a constraint model for collocation, location,
and resource constraints. Cross tables are used to deﬁnePreprintlocation and collocation constraints. Therefore, constraints can
only be deﬁned by considering ﬂat software architectures
and hardware platforms. Information about the hierarchical
architecture cannot be used for deﬁning constraints. For a
large set of components and ECUs, deﬁning constraints is
tedious and error-prone. In contrast to DIF, we use the power of
OCL and a domain-speciﬁc language to ease the speciﬁcation
of constraints. Additionally, DIF provides transformations to
different solving mechanisms for the allocation problem, like
MINLP, MIP, Greedy, and Genetic algorithms. Our transfor-
mation to ILP is inspired by these transformations.
Zeller et al. [23] present a SAT-based approach for solv-
ing the allocation problem in the automotive domain. They
introduce a formal model of linear allocation constraints. In
our approach, we abstract from formal and difﬁcult aspects by
introducing the ASL and an automatic transformation to an ILP
model. As a result, engineers can specify allocation constraints
efﬁciently for an existing component-based software and hard-
ware model and derive an allocation automatically. Our ILP-
based formalization of allocation constraints is inspired by
Zeller et al. and therefore highly related. Additionally, Zeller
et al. describe constraints for task scheduling strategies. These
constraints serve as a good starting point for specifying schedu-
lability constraints with our ASL in future.
Koziolek and Reussner [24] present a quality optimization
framework, called PerOpteryx, for component-based business
information systems. They deﬁne a degree of freedom model
that restricts the design space. Furthermore, by OCL and
an input model of a component-based system, their software
tool “can automatically detect instances of the degrees, which
deﬁne the design space, and instantiate the optimisation prob-
lem.” [24] Possible allocation candidates are selected using
meta-heuristics. These candidates may also represent an invalid
allocation. Allocations can be constrained by OCL, but the
constraints are checked after selecting candidates. Therefore,
the meta-heuristic approach may select many invalid candi-
dates before ﬁnding a valid candidate. PerOpteryx searches
allocation candidates in a design space, which is restricted by
a degree of freedom model and not by a constraint model.
In contrast to PerOpteryx our approach tackles CPSs, which
have to fulﬁll many constraints. Therefore, we ﬁrst select
feasible candidates, which fulﬁll all constraints. According
to Lukasiewycz this is more efﬁcient, if the search space
(searching without considering constraints) of a problem is
huge compared to the valid design space (searching, while
considering constraints) [5]. Nevertheless, we only consider
ﬁnding feasible solutions and not optimal solutions. Therefore,
we are working on integrating measurement operations in the
ASL to specify optimization goals in the future.
Lukasiewycz [5] presents an open design space explo-
ration framework (OpenDSE) [25] for embedded systems. The
framework provides an own meta-model, implemented in Java.
It enables to model applications that consists of ﬂat data-
dependent tasks. A task can be allocated to a resource that
is structured in a ﬂat hardware architecture. Engineers can
create the application model by instantiating corresponding
objects in Java. Constraints can also be programmed directly
in Java by implementing the SpeciﬁcationConstraint interface.
For optimization OpenDSE uses Opt4J [26], which combines
constraint solving with meta-heuristic optimization. In contrastto OpenDSE, our allocation approach is combined with a
model-driven component-based software engineering approach
for CPSs. Nevertheless, we think the combination of constraint
solving and meta-heuristic based optimization is promising for
CPSs. Therefore, we provide an experimental transformation
to OPT4J for solving and optimizing allocation speciﬁcations.
VII. C ONCLUSION
This paper contributes a model-driven allocation engi-
neering approach. The key contribution is the ASL, which
enables allocation engineers to deﬁne allocation constraints,
using OCL, for existing software architecture and hardware
platform models. For this, it provides the four allocation con-
straint kinds collocation ,separateLocation ,requiredLocation ,
andrequiredResource . Furthermore, this paper contributes a
linear program meta-model and an automatic transformation
of allocation constraints speciﬁed with the ASL to an instance
of this model. An existing solver derive a feasible allocation.
The result of the solver is transformed back to a model that
references model elements of a software architecture and hard-
ware platform. We validate the contributed approach with an
evaluation based on a Brake-by-wire case study. Our approach
eases the work of allocation engineers that have to deﬁne
allocation constraints for complex component-based software,
e.g., in the automotive domain. In particular, it helps allocation
engineers if constraint satisfaction is a crucial aspect that needs
to be satisﬁed in order to the system being accepted. Allocation
engineers can use structural aspects of existing models, like
hierarchy, to specify allocation constraints in a more compact
way. The approach is limited to alter the allocation of software
components to hardware resources to ﬁnd a feasible solution.
It does not support other solution categories, like changing
replications or parameters of entities.
In future, we plan to extend our ASL with a kind of
measurement functions. They should be used to specify op-
timization goals for the quality of software services (QoS).
For instance, the communication between components can be
viewed as a service. QoS dimensions for a communication
service are, e.g., reliability that should be maximized or latency
that should be minimized. Additionally, we plan to extend
the presented case study by considering a more complex
software architecture with more functions and by considering
more advanced allocation constraints, like component-, or
communication-scheduling. Furthermore, we like to combine
our approach with the advantages of other approaches as
described in Section VI. Thereby, it will become possible, e.g.,
to perform reliability-driven allocation optimization that fulﬁlls
schedulability constraints. In future, we see high potential for
allocation engineering of self-adaptive systems. These systems
optimize their software architecture and allocation at run-time
by considering changing communication partners, different
modes of operation, and reacting to hardware failures [27].
VIII. A CKNOWLEDGMENTS
This work was developed in the Leading-Edge Cluster ’In-
telligent Technical Systems OstWestfalenLippe’ (IT’S OWL).
The IT’S OWL project is funded by the German Federal
Ministry of Education and Research. We thank Stefan Dziwok
and Aindrila Basak for reviewing earlier drafts of this paper.PreprintREFERENCES
[1] K. Venkatesh Prasad, M. Broy, and I. Krueger, “Scanning advances
in aerospace & automobile software technology,” Proc. of the IEEE ,
vol. 98, no. 4, pp. 510–514, 2010.
[2] AUTOSAR development cooperation, Release 4.2 Overview and
Revision History , 2014. [Online]. Available: http://www.autosar.org/
speciﬁcations/release-42/
[3] A. Aleti, B. Buhnova, L. Grunske, A. Koziolek, and I. Meedeniya,
“Software architecture optimization methods: A systematic literature
review,” Software Engineering, IEEE Transactions on , vol. 39, no. 5,
pp. 658–683, May 2013.
[4] M. Zeller and C. Prehofer, “Modeling and efﬁcient solving of extra-
functional properties for adaptation in networked embedded real-time
systems,” Journal of Systems Architecture , vol. 59, no. 10, Part C, pp.
1067–1082, 2013, embedded Systems Software Architecture.
[5] M. Lukasiewycz, “Modeling, analysis, and optimization of
automotive networks,” Ph.D. dissertation, Friedrich-Alexander-
Universität Erlangen-Nürnberg, Göttingen, Germany, 2010. [Online].
Available: http://d-nb.info/1005711844
[6] LPSolve . [Online]. Available: http://lpsolve.sourceforge.net/5.5/
[7] A. Aleti, “Designing automotive embedded systems with adaptive
genetic algorithms,” Automated Software Engineering , vol. 22, no. 2,
pp. 199–240, 2015. [Online]. Available: http://dx.doi.org/10.1007/
s10515-014-0148-0
[8] U. Pohlmann, M. Meyer, A. Dann, and C. Brink, “Viewpoints and
views in hardware platform modeling for safe deployment,” in VAO
’14: Proceedings of the 2nd Workshop on View-Based, Aspect-Oriented
and Orthographic Software Modelling . New York, NY , USA: ACM,
2014, pp. 23–30.
[9] S. Becker, S. Dziwok, C. Gerking, W. Schäfer, C. Heinzemann,
S. Thiele, M. Meyer, C. Priesterjahn, U. Pohlmann, and M. Tichy,
“The MechatronicUML design method - process and language for
platform-independent modeling,” Heinz Nixdorf Institute, University of
Paderborn, Tech. Rep. tr-ri-14-337, Mar. 2014, version 0.4.
[10] T. Eckardt, C. Heinzemann, S. Henkler, M. Hirsch, C. Priesterjahn,
and W. Schäfer, “Modeling and verifying dynamic communication
structures based on graph transformations,” Computer Science -
Research and Development , vol. 28, no. 1, pp. 3–22, 2013. [Online].
Available: http://dx.doi.org/10.1007/s00450-011-0184-y
[11] S. Becker, S. Dziwok, C. Gerking, C. Heinzemann, W. Schäfer,
M. Meyer, and U. Pohlmann, “The MechatronicUML method: model-
driven software engineering of self-adaptive mechatronic systems,” in
ICSE Companion 2014: Companion Proceedings of the 36th Interna-
tional Conference on Software Engineering . New York, NY , USA:
ACM, 2014, pp. 614–615.
[12] OMG OCL, Object Constraint Language (OCL), version = 2.4 , 2014.
[Online]. Available: http://www.omg.org/spec/OCL/2.4/PDF/
[13] I. Meedeniya, B. Buhnova, A. Aleti, and L. Grunske, “Reliability-driven
deployment optimization for embedded systems,” Journal of Systems
and Software , vol. 84, no. 5, pp. 835–846, 2011.
[14] I. Švogor, I. Crnkovi ´c, and N. Vr ˇcek, “An extended model for
multi-criteria software component allocation on a heterogeneous
embedded platform,” Journal of Computing & Information Technology ,vol. 21, 2013. [Online]. Available: http://connection.ebscohost.com/c/
articles/94937269/
[15] S. Malek, N. Medvidovic, and M. Mikic-Rakic, “An extensible frame-
work for improving a distributed software system’s deployment archi-
tecture,” Software Engineering, IEEE Transactions on , vol. 38, no. 1,
pp. 73–100, Jan 2012.
[16] L. Apvrille, R. El Khayari, O. Henniger, Y . Roudier, H. Schweppe,
H. Seudié, B. Weyl, and M. Wolf, “Secure automotive on-board
electronics network architecture,” in FISITA 2010 World Automotive
Congress, Budapest, Hungary , vol. 8, 2010.
[17] F. A. Aloul, A. Ramani, I. L. Markov, and K. A. Sakallah, “Generic
ilp versus specialized 0-1 ilp: An update,” in Proceedings of the
2002 IEEE/ACM International Conference on Computer-aided Design ,
ser. ICCAD ’02. New York, NY , USA: ACM, 2002, pp. 450–457.
[Online]. Available: http://doi.acm.org/10.1145/774572.774638
[18] A. Schrijver, Theory of linear and integer programming . New York,
NY, USA: John Wiley & Sons, Inc., 1986.
[19] Supplementary Material for the Paper Model-Driven Allocation
Engineering . [Online]. Available: https://trac.cs.upb.de/mechatronicuml/
wiki/PaperASE2015/
[20] B. Kitchenham, L. Pickard, and S. L. Pﬂeeger, “Case studies for
method and tool evaluation,” IEEE Softw. , vol. 12, no. 4, pp. 52–62,
Jul. 1995. [Online]. Available: http://dx.doi.org/10.1109/52.391832
[21] S. Dziwok, C. Gerking, S. Becker, S. Thiele, C. Heinzemann, and
U. Pohlmann, “A tool suite for the model-driven software engineering
of cyber-physical systems,” in Proceedings of the 22Nd ACM SIGSOFT
International Symposium on Foundations of Software Engineering , ser.
FSE 2014. New York, NY , USA: ACM, 2014, pp. 715–718.
[22] A. Aleti, S. Bjornander, L. Grunske, and I. Meedeniya, “Archeopterix:
An extendable tool for architecture optimization of aadl models,” in
ICSE Workshop on Model-Based Methodologies for Pervasive and
Embedded Software, 2009. MOMPES ’09. , May 2009, pp. 61–71.
[23] M. Zeller, C. Prehofer, G. Weiss, D. Eilers, and R. Knorr, “Towards
self-adaptation in real-time, networked systems: Efﬁcient solving of
system constraints for automotive embedded systems,” in Fifth IEEE
International Conference on Self-Adaptive and Self-Organizing Systems
(SASO) , 2011, pp. 79–88.
[24] A. Koziolek and R. Reussner, “Towards a generic quality optimisation
framework for component-based system models,” in Proceedings of
the 14th International ACM Sigsoft Symposium on Component Based
Software Engineering , ser. CBSE ’11. New York, NY , USA: ACM,
2011, pp. 103–108. [Online]. Available: http://doi.acm.org/10.1145/
2000229.2000244
[25] OpenDSE . [Online]. Available: http://opendse.sourceforge.net/
[26] M. Lukasiewycz, M. Glaß, F. Reimann, and J. Teich, “Opt4J - A
Modular Framework for Meta-heuristic Optimization,” in Proceedings
of the Genetic and Evolutionary Computing Conference (GECCO
2011) , Dublin, Ireland, 2011, pp. 1723–1730.
[27] C. Heinzemann, D. Schubert, S. Dziwok, U. Pohlmann, C. Priesterjahn,
C. Brenner, and W. Schäfer, “Railcab convoys: An exemplar for
using self-adaptation in cyber-physical systems,” Software Engineering
Group, Heinz Nixdorf Institute, University of Paderborn, Tech. Rep.
tr-ri-15-344, Jan. 2015.Preprint
View publication stats