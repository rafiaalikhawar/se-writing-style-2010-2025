Automatically Assessing Crashes from
Heap OverÔ¨Çows
Liang He, Yan Caiy, Hong Huz, Purui Suyx, Zhenkai Liangz, Yi Yang,
Huafeng Huang, Jia Yan, Xiangkun Jia, Dengguo Fengy
Trusted Computing and Information Assurance Laboratory,
Institute of Software, Chinese Academy of Sciences, Beijing, China
yState Key Laboratory of Computer Science,
Institute of Software, Chinese Academy of Sciences, Beijing, China
zDepartment of Computer Science, National University of Singapore
fheliang, purui, yangyi, yanjia, huafengg@iscas.ac.cn, liangzk@comp.nus.edu.sg,
fycai.mail, huhong789, ajiahitg@gmail.com, fengdg@263.net
Abstract ‚ÄîHeap overÔ¨Çow is one of the most widely exploited
vulnerabilities, with a large number of heap overÔ¨Çow instances
reported every year. It is important to decide whether a crash
caused by heap overÔ¨Çow can be turned into an exploit. EfÔ¨Åcient
and effective assessment of exploitability of crashes facilitates to
identify severe vulnerabilities and thus prioritize resources. In
this paper, we propose the Ô¨Årst metrics to assess heap overÔ¨Çow
crashes based on both the attack aspect and the feasibility aspect.
We further present HCS IFTER , a novel solution to automatically
assess the exploitability of heap overÔ¨Çow instances under our
metrics. Given a heap-based crash, HCS IFTER accurately detects
heap overÔ¨Çows through dynamic execution without any source
code or debugging information. Then it uses several novel
methods to extract program execution information needed to
quantify the severity of the heap overÔ¨Çow using our metrics. We
have implemented a prototype HCS IFTER and applied it to assess
nine programs with heap overÔ¨Çow vulnerabilities. HCS IFTER
successfully reports that Ô¨Åve heap overÔ¨Çow vulnerabilities are
highly exploitable and two overÔ¨Çow vulnerabilities are unlikely
exploitable. It also gave quantitatively assessments for other two
programs. On average, it only takes about two minutes to assess
one heap overÔ¨Çow crash. The evaluation result demonstrates both
effectiveness and efÔ¨Åciency of HCS IFTER .
Index Terms‚ÄîMemory error, Heap overÔ¨Çow, Vulnerability
assessment
I. I NTRODUCTION
Heap-based buffer overÔ¨Çow is one of the most widely
exploited vulnerabilities in recent security incidents. High-
risk heap overÔ¨Çow errors can be leveraged by attackers to
execute arbitrary code or leak sensitive information (such as
passwords and encryption keys) while low-risk heap overÔ¨Çow
errors may only lead to Denial of Service attack (DoS). Given
the large number of heap overÔ¨Çow errors reported every year,
it is ideal to assess their severity efÔ¨Åciently and effectively,
so that resources can be allocated towards high-risk ones for
timely analysis and patching. The representative assessment of
the severity is the exploitability ‚Äì the likelihood that a heap
xCorresponding author.overÔ¨Çow error can be utilized to launch the attacks to run
arbitrary code.
An ultimate way to demonstrate the exploitability of a
vulnerability is to generate working exploits. Previous work-
s [1], [2], [3], [4] study the practical viability to automatically
generate exploits. One mechanism is to symbolically execute
the whole program and capture the program constraints as
predicates. Then it generates working exploits by solving the
constraints. AEG [1] and Mayhem [2] are representative ones
in this category. Though using exploit generation as a way
for assessment is accurate, they cannot generate exploits for
all potential vulnerabilities due to the limitation in program
analysis techniques.
Another assessment method is to analyze the code executed
after the crash point ‚Äì the instruction leading to the program
crash. For example, the !exploitable tool [5] developed by
Microsoft checks all instructions in the same basic block as
the crash point to Ô¨Ånd exploit points ‚Äì the exploitable special-
purposed instructions, like control-Ô¨Çow-transfer instructions
(e.g., call andjmp) or condition-affecting instructions (e.g.,
cmp followed by jnz). CRAX [3] takes a mixed method
with these two techniques: starting from the crash point,
it symbolically executes the program to Ô¨Ånd exploit points.
The weakness of this type of solutions is the correctness of
results. The corruption usually affects the original program
behavior (e.g., due to crashes on dereferencing pointers from
the overÔ¨Çowed memory), preventing these techniques from
Ô¨Ånding any exploitable points. Moreover, these tools will stop
work when a crash occurs, leading missed potential exploit
points.
In this paper, we aim to address the challenge in automat-
ically assessing the exploitability of crashes caused by heap
overÔ¨Çow when no working exploits can be easily generated.
We propose a set of metrics to quantify the exploitability of
heap overÔ¨Çows. To the best of our knowledge, this is the Ô¨Årst
approach that aims to automatically assess the exploitability
of heap overÔ¨Çows. Our metrics are based on two aspects:
978-1-5386-2684-9/17/$31.00 c2017 IEEEASE 2017, Urbana-Champaign, IL, USA
Technical Research - New Ideas274
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. theAttack Metrics and the Feasibility Metrics. The former
measures the potential threats of a heap overÔ¨Çow and the
latter measures the speciÔ¨Åc difÔ¨Åculties to build a real working
exploit.
Based on the metrics, we present a framework, HCS IFTER1,
for automatic heap overÔ¨Çow crash assessment. HCS IFTER
accurately detects heap overÔ¨Çow errors through dynamic pro-
gram analysis. It tracks all heap objects and checks related
operations to Ô¨Ånd the out-of-bound heap memory accesses.
The detection happens right before the real execution of the
corruption point ‚Äì the instruction leading to the heap overÔ¨Çow.
To extract features of the overÔ¨Çow‚Äôs impact on the program
execution, HCS IFTER dynamically carries out data recovery in
the corrupted memory region, so that the program can continue
its normal execution for our analysis. Note that, compared
with other dynamic approaches, this is a key step to continue
the execution after a heap overÔ¨Çow occurrence without any
crashes, enabling HCS IFTER to explore additional exploitable
points. During the dynamic subsequent execution, HCS IFTER
tracks all recovery memory regions and detects exploits based
on exploit patterns. We also identify several novel strategies
that enable HCS IFTER to detect exploit points missed by other
techniques.
In this paper, we aim to assess a single path from a given
crash. If multiple paths exist, our technique can be applied
on each path separately. It is possible to Ô¨Ånd other paths
from a crash with fuzzing tools [6], [7] or symbolic execution
tools [8], [9].
In summary, the contributions of this paper include:
We propose a set of novel metrics for quantifying the
severeness of heap overÔ¨Çow crashes. Our metrics mea-
sures the challenges to convert crashes into exploits, in-
cluding both the potential attack aspect and the feasibility
aspect.
We design and implement a prototype tool HCS IFTER ,
which automatically assesses the exploitability of giv-
en heap overÔ¨Çows based on our metrics. HCS IFTER
introduces dynamic memory recovery and second-order
overÔ¨Çow to automatically assess the difÔ¨Åculties for exploit
generation.
We evaluated HCS IFTER using real-world vulnerable
programs. The results demonstrated both the effectiveness
and efÔ¨Åciency of HCS IFTER .
II. P ROBLEM DEFINITION AND CHALLENGES
In this paper, we aim to assess the exploitability of given
heap overÔ¨Çow errors. We deÔ¨Åne the problem as follows:
Assessment of Heap OverÔ¨Çow Crash: Given a binary with a
heap overÔ¨Çow bug, and a proof of concept (PoC) that crashes
the program, we aim to quantify the severeness of the error,
i.e., the likelihood for attackers to further develop this crash
into a working exploit, such as arbitrary memory access or
code execution attacks.
1Standing for Heap Crash Sifter.TABLE I
Exploit Point Types. ‚Äútaint‚Äù means user input data.
Exploit Points Description
call/jmp taint Directly call/jump into the tainted target
call/jmp [taint] Indirectly call/jump into the target with a tainted
address
mov [taint1], taint2 Write a tainted value taint2 into the memory
location with a tainted address taint1
mov [taint1], [taint2] Read the value at a tainted address taint1 and
write it to the tainted address taint2
critical func(taint) Control the arguments of security-critical func-
tions
Different from exploit generation [1], [2], [3], [4], which
generates a concrete working exploit, we aim to estimate the
level of difÔ¨Åculty for attackers to build a working exploit. The
output should be a quantitative assessment that describes the
severity of the error. For example, program developers can use
the assessment result to prioritize the Ô¨Åx of highly exploitable
overÔ¨Çows, considering the limited human resources. Further,
the assessment result can also be used by exploit generation
tools to focus on overÔ¨Çows with high exploitability.
Challenges in Assessment: Our approach is based on dynamic
program analysis to address the problems. Several challenges
must be resolved:
C1: Preserving the program execution. In the dynamic
code analysis, the Ô¨Årst consideration is to continue the
program execution after the corruption point, which is
required by our approach to further analyze the impact
of the overÔ¨Çow. Directly continuing the execution after a
heap overÔ¨Çow is infeasible, as the subsequent execution
usually crashes due to invalid memory access.
C2: Bypassing the integrity checks. It is problematic
if a heap overÔ¨Çow overwrites the meta data of free
heap chunks, such as the backward and forward pointers,
which are protected by heap manager. If the overÔ¨Çow has
to overwrite the meta data to reach one exploit point, the
attack needs to bypass the integrity checks of heap data
structure.
C3: Preserving the memory layout. Heap memory is
dynamically allocated by the heap manager. The order of
heap allocation and free signiÔ¨Åcantly affects the memory
layout. Analysis code in the same memory space with
the vulnerable program may change the memory layout,
and thus affect the assessment of the exploitability. The
analysis should be performed in a different memory space
from the vulnerable program.
III. E XPLOITABILITY METRICS
As one of our main contributions, we Ô¨Årst propose two
kinds of metrics to measure the severity of heap overÔ¨Çow
crashes. The metrics should not only reÔ¨Çect the possible
exploit methods an attacker may choose, but also the difÔ¨Åculty
to build working exploit in real-world programs. SpeciÔ¨Åcally,
we deÔ¨Åne two types of metrics to assess the features of the
crashing program: Attack Metrics andFeasibility Metrics.
275
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. A. Attack Metrics
Attack metrics describe the potential risks that a heap over-
Ô¨Çow may introduce. Intuitively, if a heap overÔ¨Çow introduces
more risks (e.g., corrupt more function pointers), it becomes
easier for attackers to utilize the overÔ¨Çow.
1)Exploit Point (Exp): As different exploit points have
different attack power, we deÔ¨Åne Ô¨Åve types of exploit
points as shown in Table I, where taint1 and taint2
indicates the user input data. This metric is crucial as
more exploit points means higher exploitability of the
error.
2)OverÔ¨Çow Bytes (OB): A larger memory area corrupted
by a heap overÔ¨Çow usually means a higher threat. And
it also means that more exploit points may be found.
We use the number of the overÔ¨Çowed bytes to depict
the basic information of a heap overÔ¨Çow.
3)Taint Bytes (TB): For attackers who exploit a heap
overÔ¨Çow to execute arbitrary code usually need to Ô¨Åll
a proper length of payload within the input data. It is a
common fact that a more complex payload needs more
space to be Ô¨Ålled with. So having more taint bytes means
the ability to Ô¨Åll more complicate payload.
4)Taint Relation (TR): We need to conÔ¨Årm that the
overÔ¨Çow bytes are tainted (i.e., from user input data).
If so, attackers could provide arbitrary payload (i.e.,
malicious code) to Ô¨Åll with them. We use this metric
as the basic information of heap overÔ¨Çow.
B. Feasibility Metrics
Feasibility metrics depict the difÔ¨Åculties to build a real
working exploit. We deÔ¨Åne two kinds of feasibility metrics.
The Ô¨Årst one is the count of various pointers corrupted by
heap overÔ¨Çow, and the second one is the value constraint of
overÔ¨Çowed bytes. Intuitively, if a heap overÔ¨Çow involves more
such elements (e.g., more pointers that will be dereferenced),
it becomes more difÔ¨Åcult to exploit the overÔ¨Çow.
1)Pointer Dereference Count (PDC) As one main chal-
lenge faced by attackers is to ensure that all the memory
accesses along the program path during an attack are not
affected. Otherwise, memory dereference may lead to
the program crash due to corrupted pointers. Based on
the types of pointers possibly corrupted, we deÔ¨Åne the
pointer dereference count as a four-tuple which includes
the counts of four types of pointers:
Index Pointer (IP) where the corrupted data is
an index pointer (offset) of a memory access, for
example, mov eax, [ebx + esi5]. The
register esi is used as the index pointer in the
memory access and a memory access error will
happen if esi is loaded with a large number.
However, it is not difÔ¨Åcult for attackers to preserve
the correctness of such memory accesses (e.g., set
the register esi to be 0).
Base Pointer (BP) where the corrupted data is a
base of a memory access for fetching data, forexample, mov eax, [ebx + esi5]. The
register ebx is used as the base pointer for memory
access. Due to the address randomization [10], it
is challenging to guess all the randomized pointer
values correctly to avoid the crash.
Multilevel Pointer (MP) where the corrupted data
is an pointer to another pointer. Compared to BP,
where attackers can search and use any existed
memory, it is more challenging for attackers to Ô¨Ånd
a proper pointer‚Äôs pointer.
Protected Pointer (PP): OS or special program log-
ic checks or protects whether a pointer is corrupted,
such as the Safe Unlinking of Windows [11]. This
usually means that the exploiting process is very
difÔ¨Åcult and attackers have to bypass the protection
checking.
SpeciÔ¨Åcally, based on the real-world situation, we deÔ¨Åne
the order of difÔ¨Åculty levels for these metrics as follows,
with increasing difÔ¨Åculty to exploit:
IP<BP<MP<PP
2)Value Constraint (VC): Different applications usually
have their own strategies to check the validation of var-
ious input data. In this work, we only extract the value
constraints for the data used to overwrite heap memory.
Note that, VC does not directly affect our assessment;
however, it plays an important role in building working
exploits as it strictly indicates that some characters (e.g.,
0x0, 0xA) cannot appear in the designed payload by
attackers.
IV. HCS IFTER FRAMEWORK
We present the design details of our framework, HCS IFTER .
As shown in Figure 1, HCS IFTER works in three steps:
heap overÔ¨Çow identiÔ¨Åcation, exploit point shortlisting, and
exploitability assessment. It tracks all heap-related operations
with a multi-semantic taint analysis engine, which treats the
input PoC, heap object, and recovery memory as different
kinds of taint data. Then HCS IFTER detects cross-boundary
heap accesses at both the instruction level and the function
level (Section IV-A). It then identiÔ¨Åes memory objects that can
be exploited by attackers (Section IV-B). We further analyze
exploitable code patterns and identify second-order overÔ¨Çow
attack techniques. In the last step, for each exploitable code
pattern, HCS IFTER analyzes related memory operations to
evaluate the difÔ¨Åculty level of exploitability (Section IV-C).
A. Heap OverÔ¨Çow IdentiÔ¨Åcation
The goal of this step is to identify the location of the heap
overÔ¨Çow vulnerability, so that we can record and recover the
corrupted data by heap overÔ¨Çow. HCS IFTER utilizes dynamic
taint analysis [12] to identify heap overÔ¨Çows. We Ô¨Årstly taint
the base address and the size of the allocated heap blocks.
When accessing tainted memory addresses, we check whether
the access is out of the bound of the allocated heap blocks.
276
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. Exploitability 
AssessmentExploit Point 
ShortlistingHeap Overflow 
IdentificationProgram
Input
Multi -Semantic 
Taint AnalysisRecoveryHeap 
allocation
Exploitability Exploit
Points? YesAssess‚Ä¶
SnapshotFig. 1. The HCS IFTER framework. HCS IFTER takes as inputs the binary of the vulnerable program and the error-exhibiting input. It executes the program in
a virtual environment to detect the heap overÔ¨Çow at run-time. Then HCS IFTER restores the memory to continue the execution. At last, it detects the exploit
points and evaluates the exploitability.
Taint Source. To label information of the allocated heap
blocks as tainted, HCS IFTER hooks the heap allocation func-
tions (e.g.,RtlAllocateHeap on Windows system).
Taint Propagation. HCS IFTER propagates the taint value
at the instruction level using the standard taint propagation
mechanism. Due to taint explosion [13], HCS IFTER does not
take control-Ô¨Çow dependencies into account. More details on
taint analysis can be found in [14], [15].
Taint Checking. With the base address and the size infor-
mation propagated by taint analysis, HCS IFTER checks every
memory access to identify heap overÔ¨Çows. SpeciÔ¨Åcally, for an
instruction involving a pointer, it retrieves the taint value of the
pointer operand used for the memory access. From the taint
value, it restores the base address of the heap object and the
allocated size. It then checks whether the pointer value falls
into the base address and the end address of the heap object.
B. Exploit Point Shortlisting
Once the heap overÔ¨Çow vulnerability is detected, HC-
SIFTER analyzes the heap memory that can be corrupted by
the overÔ¨Çow to identify data types (discussed in the second
point below) that can be exploited by attackers.
We Ô¨Årst present the techniques for recovering the program‚Äôs
execution after the heap overÔ¨Çow.
1) Dynamic Heap Data Recovery: As discussed in Sec-
tion II, the Ô¨Årst challenge to detect exploit points is to preserve
the program execution after the memory corruption. To address
this challenge (C1), HCS IFTER recovers the corrupted data
back to the uncorrupted version, so that the program can
continue its execution without any crash. By watching the
following executed instructions, we can Ô¨Ånd the usage of the
corruptible data. The usage of the data is important to assess
the exploitability. We use dynamic taint analysis to track the
corruptible data. During the dynamic data recovery, we label
each recovered data with the offset from the Ô¨Årst overÔ¨Çowed
bytes. In the following execution, we propagate the taint value
as for the heap pointers.
2) Exploit Point Detection: We aim to detect the exploit
points ‚Äì the instructions that can be used by attackers to launch
attacks ‚Äì based on the data type affected by the heap overÔ¨Çow.
We classify data into types like code pointers, data pointers,loop bounds. The data type can be inferred by the program‚Äôs
behavior. A heap data can directly affect program‚Äôs code
execution or the memory access if some program variables
derived from it (tainted by its offset) are used as pointers to
code and data. In addition, a heap object can indirectly affect
memory accesses if memory addresses are control-dependent
on it. Control-dependent means the heap object affects the
control Ô¨Çow, and at the same time, the memory access happens
inside the code under the control. For example, if a heap data
is used as a counter of one loop, the memory access in the
loop body is control-dependent on this heap data.
3) Exploitability by Second-Order OverÔ¨Çow: To address the
challenge (C2), we identify an interesting heap meta data that
can cause second-order heap overÔ¨Çows. It is the size Ô¨Åeld in
the header of a free chunk. The method to trigger the second-
order overÔ¨Çow is to change the value of size Ô¨Åeld into a
larger value. We call this method SizeOverÔ¨Çow.
The basic idea is, during heap allocation, if the heap
manager checks the value of size Ô¨Åeld in the header of
the overÔ¨Çowed free chunk, whose value has been tampered
be to a larger one (e.g., 0xFFFF), then this free chunk will
be allocated. The following memory access into this chunk
may lead to new buffer overÔ¨Çows, as its size is believed to
be larger than the actual one. This opens a new chance to
explore additional exploit points. Compared with the exploit
type deÔ¨Åned in Section III-A which are Direct Exploit Point
(DExp), we call this data as Indirect Exploit Point (IExp).
C. Exploitability Assessment
Besides the exploit points, HCS IFTER collects the feasibil-
ity metrics, especially the count of pointer dereferences, from
the corruption points to exploit points. This kind of metrics
will depict the real difÔ¨Åculty to reach the exploit points. We
assess the exploitability with two basic rules as follows:
Rule-1: If there is no pointer dereference from the cor-
ruption point to any direct exploit point, we treat it as an
EXPLOITABLE error. If there is any pointer dereference
from the corruption point to any exploit point, we treat it
as a DIFFICULT error and we use nearest exploit point‚Äôs
highest difÔ¨Åculty level, deÔ¨Åned in Section III-B as the
assessment result.
277
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. TABLE II
Exploitability Assessment Overview. The 2nd main columns give the details of heap overÔ¨Çow. (1-1)* means indirect table look-up operation, B!0x0 means
each byte cannot be 0x0, B!0xA means each byte cannot be 0xA. []+ means further exploitability is possible with a higher-order (> 2nd-order) overÔ¨Çow.
ProgramsHeap Ov
erÔ¨Çow Information Basic Metrics Exploitability Assessment
Instruction Function OB TB TR VC !exploitable HC
SIFTER
1ClickUnzip mov
[edx],al lstrcp yA 2433 6573 (1-1) B!0x0 3 [IP]+
Acousitca Con
verter mov
[eax+edx], cl lstrcp yA 1092 10613 (1-1) B!0x0 UNKNO WN [BP+PP]
CoreFTP Client repmo
vsd recv 8910 17653 (1-1) B!0xA UNKNO WN [IP]
FoxitReader mov
[edx],al lstrcp yA 4241 443 (1-1)* B!0x0 3 3
HTTPDX repmo
vsd memcp y 1049 1059 (1-1) B!0xA UNKNO WN [BP+PP]
Python repmo
vsd memcp y 64745 723419 (1-1)* B!0x0 3 3
Vallen
Zipper mov
[edx],al lstrcp yA 4021 8443 (1-1) B!0x0 UNKNO WN 3
WMPlayer repmo
vsd - 2524 2547 (1-1) - 3 3
ZipItF ast - ReadFile 4021 20899 (1-1) - 3 3
Rule-2: If the error is reported as DIFFICULT according
to Rule-1 and there exists any indirect exploit point from
corruption point to the nearest exploit point, we enable
the second-order overÔ¨Çow and repeat the assessment with
the rule above.
We measure the pointer dereference as follows:
We collect all instructions between the corruption point
and the exploit point that access tainted address to def-
erence memories, and put them into a set S.
We retrieve the offsets of the bytes that affect the exploit
point, and Ô¨Ånd the maximum offset Max.
For any instruction inside S, if its memory operand is
tainted with offset off andoffMax, we count the
dereferences by its types.
The Ô¨Ånal value of the derefCount is the number of
necessary tainted dereferences.
V. I MPLEMENTATION AND EVALUATION SUMMARY
A. Implementation
We extend QEMU [16] to support the instruction instrumen-
tation and the dynamic taint analysis outside the guest system.
Unlike the TEMU [17] that needs to install extra drivers into
guest system, we only use the emulated hardware information
provided by QEMU to implement our system. By doing so,
we can preserve the memory layout of guest system(C3).
HCS IFTER uses the udis86 library [18] to help disassemble
x86 instructions. Our implementation supports about 200 x86
instructions for dynamic taint analysis, including the special
support for Ô¨Çoat point registers (FPU) and SSE registers
(XMM, MMX). Our implementation totally contains more
than 36,000 lines of code, including 12,000 lines of C code
for dynamic instruction instrumentation and data recovery in
QEMU and 24,000 lines of C/C++ code for multi-semantic
taint analysis and exploitability assessment.
B. Summary of Evaluation
1) Benchmarks and Experiment Setup: We conÔ¨Ågure HC-
SIFTER to run on a platform with 8 core-CPU, 8GB RAM,
installed with Ubuntu 16.04 (x86-64) system. We run Windows
XP-SP2 as a guest virtual machine to execute the vulnerableprograms. To evaluate HCS IFTER , we collect 9 Windows
programs with heap overÔ¨Çows from exploit-db [19]. All these
programs are available either on the exploit-db site or at their
ofÔ¨Åcial websites.
2) EfÔ¨Åcacy in Exploitability Assessment: we apply HC-
SIFTER on the nine real-world heap overÔ¨Çow programs with
crash PoCs and compare the result with the widely used tool
!exploitable. HCS IFTER demonstrates its ability to accurately
locate heap overÔ¨Çow instructions, which is the base of our
assessment. As shown in the column of Heap Overflow
Information, HCS IFTER conÔ¨Årms all nine known heap
overÔ¨Çows. The major column Basic Metrics in Table II
shows the assessment reported by HCS IFTER . In the column
Exploitability Assement of Table II, we show the
exploitability assessment for all nine programs. It reports that
Ô¨Åve programs can be ‚Äúdirectly exploited‚Äù and two programs
almost cannot be exploited, unless the attackers have the
ability to bypass the integrity checker ([BP+PP]). Besides
there are two ‚Äúeasily exploited‚Äù (1ClickUnzip and CoreFtp
Client) as the attack is constrained only by index pointers
([IP]).
3) Importance of Indirect Exploit Points and SizeOverÔ¨Çow:
Indirect exploit points play an important role in the exploitabil-
ity assessment. Among Ô¨Åve exploitable programs, one of them
(i.e., FoxitReader) can only be easily attacked with the indirect
exploit points, as it has one BPbefore the direct exploit point
in the Ô¨Årst round. Two programs, the 1ClickUnzip and the
CoreFTP Client, only leave the exploit chance in the indirect
exploit points. For 1ClickUnzip, the indirect exploit points in
the second round provides further exploitability.
4) Assessment Performance: Our performance evaluation
shows that HCS IFTER can Ô¨Ånish one assessment efÔ¨Åciently,
with less than 2 minutes on average and at most 5 minutes. For
the memory overhead, HCS IFTER uses 52 MB more memory
on average than the original QEMU execution. Such a memory
consumption is acceptable on modern systems.
VI. R ELATED WORK
There are two main aspects related to our work in this paper.
The Ô¨Årst one is the automatic exploitation generation. The
278
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. second is the detection of software overÔ¨Çows, especially the
heap overÔ¨Çow as focused in this paper.
Automatic Exploitation Generation. Brumley et al. [20] pro-
posed the Ô¨Årst patch-based automated exploitation of software
vulnerabilities. Later, by integrating preconditioned symbolic
execution and dynamic instruction instrumentation, Avgerinos
et al. [1] implemented the Ô¨Årst end-to-end system for fully
automatic exploit generation. In practice, it is common that
program source code is unavailable. Therefore, binary code
based exploit generation is required. Mayhem [2] is the Ô¨Årst
one practically targeting on binary programs to automatically
generate exploitation. PolyAEG [21] further targets to generate
multiple exploits for a given vulnerable program based on
control Ô¨Çow hijacking and redirection. FlowStitch [4] targets
to automatically generate data-oriented exploits by searching
ways to join program data Ô¨Çows.
Detection of Heap OverÔ¨Çows. Robertson et al. proposed to
append additional protection data at the head or the tail of a
heap to detect buffer overÔ¨Çows [22]. During a buffer overÔ¨Çow,
the protection data is broken and can then be detected. Besides
the protect data, inaccessible memory pages could also be
allocated to detect buffer overÔ¨Çows [23]. Low-fat pointer [24]
takes a method to detect heap overÔ¨Çow at run-time. It encodes
the heap object information in addresses, to propagate the
information, and to detect the buffer overÔ¨Çow.
The most related work to our approach is proposed by
Slowinska et al. [25], which is based on binary data structure
reversal. The approach assigns different colors to different
heaps and monitors each heap access. However, this approach
heavily relies on binary data reversal, which will result in
imprecision (i.e., false negatives).
VII. C ONCLUSION
Heap overÔ¨Çow is a severe threat to computer programs.
However, it is a tedious work to determine whether a heap
overÔ¨Çow is exploitable or not. In this paper, we propose
HCS IFTER , a platform that automatically evaluates the ex-
ploitability of given heap overÔ¨Çows. HCS IFTER incorporates
two kinds of metrics proposed in this paper to assess a heap
overÔ¨Çow crash. We implement HCS IFTER as a prototype and
evaluate it with nine real-world vulnerable programs. The
experimental results show that HCS IFTER is effective and
efÔ¨Åcient on evaluating heap overÔ¨Çows.
ACKNOWLEDGMENT
This work was supported by the National Natural Science
Foundation of China (No. 61602457, 61572483, 61502469,
61502465), National 973 Program of China (2014CB340702)
and the Youth Innovation Promotion Association of the Chi-
nese Academy of Sciences (YICAS) (2017151).
REFERENCES
[1] T. Avgerinos, S. K. Cha, B. L. T. Hao, and D. Brumley, ‚ÄúAEG:
Automatic Exploit Generation,‚Äù in Proceedings of the 18th Annual
Network and Distributed System Security Symposium, 2011.[2] S. K. Cha, T. Avgerinos, A. Rebert, and D. Brumley, ‚ÄúUnleashing
Mayhem on Binary Code,‚Äù in Proceedings of the 33rd IEEE Symposium
on Security and Privacy, 2012.
[3] S. K. Huang, M. H. Huang, P. Y . Huang, and C. W. Lai, ‚ÄúCRAX:
Software Crash Analysis for Automatic Exploit Generation by Mod-
eling Attacks as Symbolic Continuations,‚Äù in Proceedings of the 6th
International Conference on Software Security and Reliability, 2012.
[4] H. Hu, Z. L. Chua, S. Adrian, P. Saxena, and Z. Liang, ‚ÄúAutomatic
Generation of Data-Oriented Exploits,‚Äù in Proceedings of the 24th
USENIX Security Symposium, 2015.
[5] ‚Äú!exploitable Crash Analyzer,‚Äù http://msecdbg.codeplex.com/.
[6] M. Zalewski, ‚ÄúAmerican Fuzzy Lop,‚Äù http://lcamtuf.coredump.cx/aÔ¨Ç/.
[7] P. Godefroid, M. Y . Levin, and D. Molnar, ‚ÄúSAGE: Whitebox Fuzzing
for Security Testing,‚Äù Queue, vol. 10, no. 1, January 2012.
[8] C. Cadar, D. Dunbar, and D. Engler, ‚ÄúKLEE: Unassisted and Automatic
Generation of High-coverage Tests for Complex Systems Programs,‚Äù
inProceedings of the 8th USENIX Conference on Operating Systems
Design and Implementation, 2008.
[9] V . Chipounov, V . Kuznetsov, and G. Candea, ‚ÄúS2E: A Platform for In-
vivo Multi-path Analysis of Software Systems,‚Äù in Proceedings of the
16th International Conference on Architectural Support for Program-
ming Languages and Operating Systems, 2011.
[10] PaX Team, ‚ÄúPaX Address Space Layout Randomization (ASLR),‚Äù http:
//pax.grsecurity.net/docs/aslr.txt, 2003.
[11] A. Anisimov, ‚ÄúDefeating Microsoft Windows XP SP2 Heap Protec-
tion and DEP bypass,‚Äù https://www.ptsecurity.com/download/defeating-
xpsp2-heap-protection.pdf, 2005.
[12] J. Chow, B. Pfaff, T. GarÔ¨Ånkel, K. Christopher, and M. Rosenblum,
‚ÄúUnderstanding Data Lifetime via Whole System Simulation,‚Äù in Pro-
ceedings of the 13th Conference on USENIX Security Symposium, 2004.
[13] E. Andrey, K. Sachin, S. Shenker, L. Fowler, and M. McCauley,
‚ÄúTowards Practical Taint Tracking,‚Äù in Technical Report No. UCB/EECS-
2010-92, 2010.
[14] E. J. Schwartz, T. Avgerinos, and D. Brumley, ‚ÄúAll You Ever Wanted to
Know About Dynamic Taint Analysis and Forward Symbolic Execution
(but Might Have Been Afraid to Ask),‚Äù in Proceedings of the 31st IEEE
Symposium on Security and Privacy, 2010.
[15] X. Jia, C. Zhang, P. Su, Y . Yang, H. Huang, and D. Feng, ‚ÄúTowards
efÔ¨Åcient heap overÔ¨Çow discovery,‚Äù in 26th USENIX Security Symposium,
2017.
[16] F. Bellard, ‚ÄúQEMU, a Fast and Portable Dynamic Translator,‚Äù in
Proceedings of the USENIX Annual Technical Conference, 2005.
[17] D. Song, D. Brumley, H. Yin, J. Caballero, I. Jager, M. G. Kang,
Z. Liang, J. Newsome, P. Poosankam, and P. Saxena, ‚ÄúBitBlaze: A New
Approach to Computer Security via Binary Analysis,‚Äù in Proceedings
of the 4th International Conference on Information Systems Security,
2008.
[18] ‚ÄúUdis86 Disassembler Library for x86 and x86-64,‚Äù https://github.com/
vmt/udis86.
[19] ‚ÄúOffensive Security Exploit Database Archive ,‚Äù https://www.exploit-
db.com/.
[20] D. Brumley, P. Poosankam, D. Song, and J. Zheng, ‚ÄúAutomatic Patch-
Based Exploit Generation is Possible: Techniques and Implications,‚Äù in
Proceedings of the 29st IEEE Symposium on Security and Privacy, 2008.
[21] M. Wang, P. Su, Q. Li, L. Ying, Y . Yang, and D. Feng, ‚ÄúAutomatic
Polymorphic Exploit Generation for Software Vulnerabilities,‚Äù in Pro-
ceedings of the 9th International Conference on Security and Privacy
in Communication Networks, 2013.
[22] W. Robertson, C. Kruegel, D. Mutz, and F. Valeur, ‚ÄúRun-time Detection
of Heap-based OverÔ¨Çows,‚Äù in Proceedings of the 17th USENIX Confer-
ence on System Administration, 2003.
[23] S. Sidiroglou, G. Giovanidis, and A. D. Keromytis, ‚ÄúA Dynamic Mech-
anism for Recovering from Buffer OverÔ¨Çow Attacks,‚Äù in Proceedings of
the 8th International Conference on Information Security, 2005.
[24] G. J. Duck and R. H. C. Yap, ‚ÄúHeap Bounds Protection with Low
Fat Pointers,‚Äù in Proceedings of the 25th International Conference on
Compiler Construction, 2016.
[25] A. Slowinska, T. Stancescu, and H. Bos, ‚ÄúBody Armor for Binaries:
preventing buffer overÔ¨Çows without recompilation,‚Äù in Proceedings of
the Usenix Technical Conference, 2012.
279
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. 