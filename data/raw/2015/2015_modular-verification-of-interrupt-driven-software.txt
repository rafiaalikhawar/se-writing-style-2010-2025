Modular Veriﬁcation of Interrupt-Driven Software
Chungha Sung
University of Southern California
Los Angeles, CA, USAMarkus Kusano
Virginia Tech
Blacksburg, V A, USAChao Wang
University of Southern California
Los Angeles, CA, USA
Abstract —Interrupts have been widely used in safety-critical
computer systems to handle outside stimuli and interact with
the hardware, but reasoning about interrupt-driven softwareremains a difﬁcult task. Although a number of static veriﬁcation
techniques have been proposed for interrupt-driven software,
they often rely on constructing a monolithic veriﬁcation model.Furthermore, they do not precisely capture the complete ex-ecution semantics of interrupts such as nested invocations ofinterrupt handlers. To overcome these limitations, we proposean abstract interpretation framework for static veriﬁcation of
interrupt-driven software that ﬁrst analyzes each interrupt han-dler in isolation as if it were a sequential program, and thenpropagates the result to other interrupt handlers. This iterative
process continues until results from all interrupt handlers reach aﬁxed point. Since our method never constructs the global model,it avoids the up-front blowup in model construction that hampers
existing, non-modular, veriﬁcation techniques. We have evaluated
our method on 35 interrupt-driven applications with a total of22,541 lines of code. Our results show the method is able toquickly and more accurately analyze the behavior of interrupts.
I. I NTRODUCTION
Interrupts have been widely used in safety-critical embedded
computing systems, information processing systems, and mo-
bile systems to interact with hardware and respond to outside
stimuli in a timely manner. However, since interrupts may arrive
non-deterministically at any moment to preempt the normal
computation, they are difﬁcult for developers to reason about.
The situation is further exacerbated by the fact that interrupts
often have different priority levels: high-priority interrupts
may preempt low-priority interrupts but not vice versa, and
interrupt handlers may be executed in a nested fashion. Overall,
methods and tools for accurately modeling the semantics of
interrupt-driven software are still lacking.
Broadly speaking, existing techniques for analyzing inter-
rupts fall into two categories. The ﬁrst category consists of
techniques based on testing [12], [30], which rely on executingthe program under various interrupt invocation sequences. Since
it is often practically infeasible to cover all combinationsof interrupt invocations, testing will miss important bugs.
The second category consists of static veriﬁcation techniques
such as model checking [3], [18], [33], [36], [43], whichrely on constructing and analyzing a formal model. During
the modeling process, interrupt-related behaviors such as
preemption are considered. Unfortunately, existing tools such
as iCBMC [18] need to bound the execution depth to remain
efﬁcient, which means shallow bugs can be detected quickly,
but these tools cannot prove the absence of bugs.
In this paper, we propose a static veriﬁcation tool geared
toward proving the absence of bugs based on abstract inter-
pretation [5]. The main advantage of abstract interpretation isthe sound approximation of complex constructs such as loops,
recursions and numerical computations. However, although ab-
stract interpretation techniques have been successfully applied
to sequential [6] and multithreaded software [27], they have not
been able to precisely model the semantics of interrupt-driven
software.
At the high level, interrupts share many similarities with
threads, e.g., both interrupt handlers and thread routines may
be regarded as sequential programs communicating with others
via the shared memory. However, there are major differences
in the way they interleave. For example, in most of the existing
veriﬁcation tools, threads are allowed to freely preempt each
other’s execution. In contrast, interrupts often have variouslevels of priority: high-priority interrupts can preempt low-
priority interrupts but not vice versa. Furthermore, interrupts
with the same level of priority cannot preempt each other. Thus,
the behavior manifested by interrupts has to be viewed as a
subset of the behavior manifested by threads.
To accurately analyze the behavior of interrupts, we develop
IntAbs,a n iterative abstract interpretation framework for
interrupt-driven software. That is, the framework always
analyzes each interrupt handler in isolation before propagating
the result to other interrupt handlers and the per interrupt
analysis is iterated until results on all interrupt handlersstabilize, i.e., they reach a ﬁxed point. Thus, in contrast
to traditional techniques, it never constructs the monolithic
veriﬁcation model that often causes exponential blowup up front.
Due to this reason, our method is practically more efﬁcient
than these traditional veriﬁcation techniques.
The IntAbs framework also differs from prior techniques
for statically analyzing interrupt-driven software, such as
the source-to-source transformation-based testing approach
proposed by Regehr [31], the sequentialization approach used
by Wu et al. [42], and the model checking technique imple-
mented in iCBMC [18]. For example, none of these existing
techniques can soundly handle inﬁnite loops, nested invocations
of interrupts, or prove the absence of bugs. Although some
prior abstract interpretation techniques [28] over-approximate
of the interrupt behavior, they are either non-modular or too
inaccurate, e.g., by allowing too many infeasible store-to-
load data ﬂows between interrupts. In contrast, our approach
precisely models the preemptive scheduling of interrupts to
identify apparently-infeasible data ﬂows. As shown in Fig. 1,
by pruning away these infeasible data ﬂows, we can drastically
improve the accuracy of the overall analysis.
IntAbs provides not only a more accurate modeling of the
interrupt semantics but also a more efﬁcient abstract interpre-
tation framework. We have implemented IntAbs in a static
978-1-5386-2684-9/17/$31.00 c/circlecopyrt2017 IEEEASE 2017, Urbana-Champaign, IL, USA
T echnical Research206
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. Interrupt Driven 
Program
QueryAbstract Interpretation
of Each InterruptInvariants
Feasibility
Checking
(μZ)Datalog RulesDatalog FactsPropagating Results
to Other Interrupts 
Fig. 1. IntAbs – iterative veriﬁcation framework for interrupt-driven programs.
analysis tool for C/C++ programs, which uses Clang/LLVM [1]
as the front-end, Apron [16] for implementing the numerical
abstract domains, and μZ[13] for checking the feasibility
of data ﬂows between interrupts. We evaluated IntAbs on 35
interrupt-driven applications with a total of 22,541 lines of C
code. Our experimental results show that IntAbs can efﬁciently
as well as more accurately analyze the behavior of interrupts
by removing a large number of infeasible data ﬂows between
interrupts.
In summary, the main contributions of our work are:
•A new abstract interpretation framework for conducting
static veriﬁcation of interrupt-driven programs.
•A method for soundly and efﬁciently identifying and
pruning infeasible data ﬂows between interrupts.
•The implementation and experimental evaluation on a
large number of benchmark programs to demonstrate the
effectiveness of the proposed techniques.
The remainder of this paper is organized as follows. We ﬁrst
motivate our approach in Section II by comparing it with testing,
model checking, and abstract interpretation tools designed
for threads. Then, we provide the technical background oninterrupt modeling and abstract interpretation in Section III.
Next, we present our new method for checking the feasibility
of data ﬂows between interrupts in Section IV, followed by our
method for integrating the feasibility checking with abstractinterpretation in Section V. We present our experimental
evaluation in Section VI. Finally, we review the related work
in Section VII and conclude in Section VIII.
II. M OTIV ATION
We ﬁrst use examples to illustrate the problems of prior
techniques such as testing, model checking, and thread-modular
abstract interpretation. Then, we explain how our method
overcomes these problems.
Consider the example program in Fig. 2, which has three
interrupts irq_H ,irq_L andirq_M . The sufﬁx His used
to denote high priority, Lfor low priority, and Mfor medium
priority. Interrupts with higher priority levels may preempt
interrupts with lower priority levels, but not vice versa. Inside
the handlers, there are two variables xandy, which are set to
0initially. Among the three assertions, the ﬁrst two may fail,
while the last one always holds.
A. Testing
Testing an interrupt-driven program requires the existence
of interrupt sequences, which must be generated a priori. Inirq_H() {
...
assert(y==0);
}irq_L() {
x=0 ;assert(x==0);
}irq_M() {
y=1 ;
x=1 ;
assert(x==1);
}
Fig. 2. An example program with three interrupt handlers and assertions.
irq_H irq_M irq_L
irq_Mirq_H
irq_Lcase0
case1
irq_Lirq_Mirq_H
case3irq_Lirq_H
irq_M
case2
Fig. 3. Some possible interrupt sequences for the program in Fig. 2.
Fig. 2, for example, since the interrupt handlers have different
priority levels, we need to consider preemption while creating
the test sequences. Since a high-priority interrupt handler may
preempt, at any time, the execution of a medium- or low-
priority interrupt handler, when irq_L is executing, irq_H
may be interleaved in between its instructions.
Fig. 3 shows four of the possible interrupt sequences for
the program. Speciﬁcally, case0 is the sequential execution
of the three handler functions; case1 shows that irq_H
preempts irq_M , followed by irq_L ;case2 is similar, except
thatirq_L executes ﬁrst and then is preempted by irq_H ,
followed by irq_M ; and case3 is the nested case where irq_L
is preempted by irq_M and then by irq_H.
The main problem of testing is that there can be too many
such interrupt sequences to explore. Even if we can somehow
guarantee that each interrupt handler is executed only once,
the total number of test sequences can be enormously large,
even for small or medium-sized programs.
B. Model Checking
Model checking tools such as CBMC [4] may be used to
search for erroneous interrupt sequences, e.g., those leading
to assertion violations. For instance, in the running example,
all assertions hold under the sequences case0 and case2 in
Fig. 3. This is because, although irq_H preempts irq_L , they
access different variables and thus do not affect the assertion
conditions, while irq_M checks the value of xafter assigning
1t ox.
Incase1, however, the execution order of the three interrupt
handlers is different, thus leading to an assertion violation inside
irq_H . More speciﬁcally, irq_M is preempted by irq_H at
ﬁrst. Then, after both completes, irq_L is executed. So, the
207
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. assert(y==0)y = 0; initialized value
y = 1; from irq_M
assert(x==0)x = 0; from irq_L
x = 1; from irq_M
assert(x==1)x = 0; from irq_L
x = 1; from irq_MFeasible
Infeasible
Fig. 4. Some possible store-to-load data ﬂows during abstract interpretation.
change of ymay affect the read of yinirq_H , leading to
the violation.
Finally, in case3, both of the ﬁrst two assertions may be
violated, because the check of xinirq_L and the check of
yinirq_H can be affected by irq_M ’s own assignments of
xandy.
Although bounded model checking can quickly ﬁnd bugs,
e.g., the assertion violations in Fig. 2, the depth of the execution
is often bounded, which means in practice, tools such as
iCBMC [18] cannot prove the absence of bugs.
C. Abstract Interpretation
Abstract interpretation is a technique designed for proving
properties, e.g., assertions always hold. Unfortunately, existing
methods based on abstract interpretation are mostly designed
for threads as opposed to interrupts. Since threads interact
with each other more freely than interrupts, these methods are
essentially over-approximated analysis. As such, they may still
be leveraged to prove properties in interrupt-driven programs,
albeit in a less accurate fashion. That is, when they prove
an assertion holds, the assertion indeed holds; but when they
cannot prove an assertion, the result is inconclusive.
For the running example in Fig. 2, for instance, existing
abstract interpretation techniques such as Min ´e [24], [27],
designed for analyzing threads, cannot prove any of the three
assertions. To see why, let us ﬁrst assume that interrupt
handlers are thread routines. During thread-modular abstract
interpretation, the veriﬁcation procedure would ﬁrst gather all
possible pairs of load and store instructions with respect to
the global variables, as shown in Fig. 4, where each assertion
has two possible loads. Speciﬁcally, the load of yinirq_H
corresponds to the initial value 0and the store in irq_M . The
load of xinirq_L corresponds to the stores in irq_L and
irq_M . The load of xinirq_M corresponds to the stores in
irq_L andirq_M.
Since these existing methods [24], [27] assume that all
stores may affect all loads, they would incorrectly report that
all three assertions may fail. For example, it reports that the
load of xinirq_M may (incorrectly) read from the store
x=0 inirq_L despite that irq_L has a lower priority and
thus cannot preempt irq_M . In contrast, our new method can
successfully prove the third assertion. Speciﬁcally, we model
the behavior of interrupts with different levels of priorities.irq_M() {
if (...)
y=0 ;
y=1 ;
assert(x==1);
}irq_L() {
...y=1 ;
...
assert(y==1);
}irq_H() {
if (...)
x=0 ;
x=1 ;assert(y==1);
}
Fig. 5. An example program with three interrupt handlers, where the ﬁrst two
assertions alway hold but the last assertion may fail.
Due to the different priority levels, certain store-to-load data
ﬂows are no longer feasible, as shown by the stores marked
by red boxes in Fig. 4: these two stores have lower priority
than the corresponding load in the assertions.
D. Abstract Interpretation for Interrupts
Modeling the priority levels alone, however, is not enough
for proving all assertions because even without preemption,
a low-priority interrupt may affect a high-priority interrupt.
Consider the ﬁrst red box in Fig. 4. Although y=1 fromirq_M
cannot affect the load of yinirq_H through preemption, if
irq_H is invoked after irq_M ends, ycan still get the value
1, thus leading to the assertion violation. Therefore, our new
veriﬁcation procedure has to consider all possible sequential
interleavings of the interrupt handlers as well.
Now, consider the program in Fig. 5, which has three
interrupt handlers irq_M ,irq_L andirq_H . In these handler
functions, there are two global variables xandy, which
are set to 0initially. Among the three assertions, the ﬁrst
two always hold, whereas the last one may fail. For ease ofcomprehension, we assume the computer hardware running
this program provides the sequentially consistent memory [20],
[22], [45]. Note that irq_M has two stores of y, one inside
the conditional branch and the other outside, and irq_H has
two stores of x, one inside the conditional branch and the other
outside.
With prior thread-modular analysis [19], [24], [27], all three
assertions may fail because the store y=0 inirq_M may be
interleaved right before the assertions in irq_L andirq_H .
Furthermore, the store x=0 inirq_H executed before irq_M
may lead to the violation of the assertion in irq_M . In contrast,
with our precise modeling of the interrupt behavior, the new
method can prove that the ﬁrst two assertions always hold.
Speciﬁcally, the assertion in irq_L holds because, even if it is
preempted by irq_M , the value of yremains 1. Similarly, the
assertion in irq_M holds because, even if it is preempted by
irq_H , the store x=1 post-dominates the store x=0, meaning
the value of xremains 1afterirq_H returns.
In contrast, the assertion in irq_H may fail if irq_H
preempts irq_M right after the conditional branch that sets
yto0. This particular preemption is feasible because irq_H
has a higher priority than irq_M.
Therefore, our new method has to consider not only the
different levels of priority of all interrupts, but also the
domination and post-domination relations within each handler.
It decides the feasibility of store-to-load data ﬂows based on
whether a load has a dominated store, whether a store has a
208
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. TABLE I
COMPARING INTABSWITH TESTING AND PRIOR VERIFICATION METHODS ON THE PROGRAMS IN FIG.2AND FIG.5 .
Property Testing [12], [30] Model Checking (bounded) [18], [42] Abs. Int. for Threads [19], [27] IntAbs for Interrupts (new)
assertion in Fig. 2: irq_H violation violation warning warning
assertion in Fig. 2: irq_L violation violation warning warning
assertion in Fig. 2: irq_M (bogus) warning proof
assertion in Fig. 5: irq_M (bogus) warning proof
assertion in Fig. 5: irq_L (bogus) warning proof
assertion in Fig. 5: irq_H violation violation warning warning
run0() {
stmt1;
stmt2;
}run1() {
stmt3;stmt4;
}
•Possible traces for interrupts:
–stmt1→stmt2→stmt3→stmt4
–stmt1→stmt3→stmt4→stmt2
•Possible traces for threads:
–stmt1→stmt2→stmt3→stmt4
–stmt1→stmt3→stmt4→stmt2
–stmt1→stmt3→stmt2→stmt4
Fig. 6. The interleavings (after stmt1) allowed by interrupts and threads.
post-dominated store, and whether a load-store pair is allowed
by the priority levels of the interrupts. We present the details
of this feasibility-checking algorithm in Section IV.
To sum up, the main advantages of IntAbs over state-of-the-
art techniques are shown in Table I. Speciﬁcally, testing and
(bounded) model checking tools are good at detecting bugs
(e.g., assertion violations) but cannot prove the absence of bugs,
whereas thread-modular abstract interpretation tools are good
at obtaining proofs, but may report many false positives (i.e.,
bogus warnings). In contrast, our new abstract interpretation
method is signiﬁcantly more accurate. It can obtain more proofs
than prior techniques and, at the same time, can signiﬁcantly
reduce the number of bogus warnings.
III. P RELIMINARIES
In this section, we describe how interrupt-driven programs
are modeled in our framework by comparing their behavior to
the behavior of threads. Then, we review the basics of prior
abstract interpretation techniques.
A. Modeling of Interrupts
We consider an interrupt-driven program as a ﬁnite set T=
{T1,...,T n}of sequential programs. Each sequential program
Ti, where 1≤i≤n, denotes an interrupt handler. For ease of
presentation, we do not distinguish between the main program
and the interrupt handlers. Globally, sequential programs in T
are executed in a strictly interleaved fashion. Each sequential
program may access its own local variables; in addition, it may
access a set of global variables, through which it communicates
with the other sequential programs in T.
The interleaving behavior of interrupts is a strict subset of
the interleaving behavior of threads (c.f. [18]). This is becauseconcurrently running threads are allowed to freely preempt each
other’s executions. However, this is not the case for interrupts.Consider the example program in Fig. 6, which has two
functions named run0 andrun1 . If they were interrupts,
where run1 has a higher priority level than run0 , then after
executing stmt1 , there can only be two possible traces. The
ﬁrst one is for run1 to wait until run0 ends, and the second
one is for run1 to preempt run0 . If they were threads,
however, there can be three possible traces after executing
stmt1 . In addition to the traces allowed by interrupts, we
can also execute stmt3 inrun1 , then execute stmt2 in
run0 , and ﬁnally execute stmt4 inrun1 . The third trace is
infeasible for interrupts because the high-priority run1 cannot
be preempted by stmt2 of the low-priority run0.
Since the interleaving behavior of interrupts is a strict subset
of the interleaving behavior of threads, it is always safe to
apply a sound static veriﬁcation procedure designed for threads
to interrupts. If the veriﬁer can prove the absence of bugs by
treating interrupts as threads, then the proof is guaranteed to
be valid for interrupts. The result of this discussion can be
summarized as follows:
Theorem 1: Since the interleaving behavior of interrupts is a
subset of the interleaving behavior of threads, proofs obtained
by any sound abstract interpretation over threads remain valid
for interrupts.
However, the reverse is not true: a bug reported by the
veriﬁer that treats interrupts as threads may not be a real bug
since the erroneous interleaving may be infeasible. In practice,
there are also tricky corner cases during the interaction of
interrupts, such as nested invocations of handlers, which call
for a more accurate modeling framework for interrupts.
Interrupts may also be invoked in a nested fashion as shown
bycase3 in Fig. 3, which complicates the static analysis. Here,
we say interrupts are nested when one’s handler function is
invoked before another’s handler function returns, and the third
handler function is invoked before the second handler functionreturns. Such nested invocations are possible, for example, if the
corresponding interrupts have different priority levels, where
the inner most interrupt has the highest priority level. This
behavior is different from thread interleaving; with numerous
corner cases, it requires the development of dedicated modeling
and analysis techniques.
B. Abstract Interpretation for Threads
Existing methods for modular abstract interpretation are
designed almost exclusively for multithreaded programs [19],
[24], [25], [27]. Typically, the analyzer works on each thread
in isolation, without creating a monolithic veriﬁcation model
as in the non-modular techniques [7], [42], to avoid the up-
front complexity blowup. At a high level, the analyzer iterates
209
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. Algorithm 1 Local analysis of Twith prior interferences I.
1:function ANALYZE LOCAL (T=/angbracketleftN,n 0,δ/angbracketright,I)
2:S←∅ ⊿Map from nodes to states
3:W←{n0} ⊿Set of nodes to process
4: while∃n∈W do
5:W←W\{n}
6: ifnis a shared-memory read of variable vthen
7: s←TFUNC (n,S (n)/unionsqI(v))
8: else
9: s←TFUNC (n,S (n))
10: for all/angbracketleftn,n/prime/angbracketright∈δ such that s/negationslash/subsetsqequalS(n/prime)do
11: S(n/prime)←S(n/prime)/unionsqs
12: W←W∪{n/prime}
13: returnS
through threads in two steps: (1) analyzing each thread in
isolation, and (2) propagating results from the shared-memory
writes of one thread to the corresponding reads of other threads.
Let the entire program Pbe a ﬁnite set of threads, where
each thread Tis represented by a control-ﬂow graph /angbracketleftN,n 0,δ/angbracketright
with a set of nodes N, an entry node n0, and the transition
relationδ. Each pair (n,n/prime)∈δmeans control may ﬂow from
nton/prime. Each node nis associated with an abstract memory-
state over-approximating the possible concrete states at n.W e
assume the abstract domain (e.g., intervals) is deﬁned as a
lattice with appropriate top ( /latticetop) and bottom ( ⊥) elements, a
partial-order relation ( /subsetsqequal), and widening/narrowing operators
to ensure that the analysis eventually terminates [5]. We also
deﬁne an interference Ithat maps a variable vto the values
stored into vby some thread T.
Algorithm 1 shows how a thread-local analyzer works on T
assuming some interferences Iprovided by the environment
(e.g., writes in other threads). It treats Tas a sequential program.
LetS(n)be the abstract memory-state at node n,n0be the
entry node of T, andWbe the set of nodes in Tleft to be
processed. The procedure keeps removing node nfrom the
work-list Wand processing it until Wis empty (i.e., a ﬁxed
point is reached).
If nodencorresponds to a shared-memory read of variable
v, then the transfer function TFUNC (Line 7) assumes that n
can read either the local value (from S) or the value written
by another thread (the interference I(v)). The transfer function
TFUNC of an instruction ntakes some memory-state as input
and returns a new memory-state as output; the new memory-
state is the result of executing the instruction in the given
memory-state. Otherwise, if nis a local read, in which case the
transfer function TFUNC uses the local memory-state (Line 9)
as in the abstract interpretation of any sequential program. The
analysis result (denoted S) is an over-approximation of the
memory states within Tassuming interferences I.
The procedure that analyzes the entire program is shown
in Algorithm 2. It ﬁrst analyzes each thread, computes theinterferences, and then analyzes each thread again in the
presence of these interferences. The iterative process continuesuntil a ﬁxed point on the memory-states of all threads is reached.
Initially,
Smaps each node in the program to an empty memory-
state⊥.S/primecontains the analysis results after one iteration of
the ﬁxed-point computation. The function I NTERF returns the
interferences of thread T, i.e., a map from some variable vtoAlgorithm 2 Analysis of the entire program, i.e., a set of T’s.
1:function ANALYZE PROG(P)
2:S←map all nodes to ⊥
3:S/prime←S
4: repeat
5:S=S/prime
6: for allT∈Pdo
7: I←/unionmultitextINTERF (T/prime,S)for eachT/prime∈P,T/prime/negationslash=T
8: S/prime←S/prime/unionmultiANALYZE LOCAL (T,I )
9: untilS/prime=S
10: function INTERF (T=/angbracketleftN,n 0,δ/angbracketright,S )
11:I←∅
12: for alln∈Ndo
13: ifnis a shared memory write to variable vthen
14: I(v)←I(v)/unionsqTFUNC (n,S(n))
15: returnI
all the (abstract) values stored into vbyT. Each thread Tis
analyzed in isolation by the loop at Lines 4–9. Here, we use
/unionmultito denote the join ( /unionsq) of all memory-states on the matching
nodes.
This thread-modular abstract interpretation framework, while
more efﬁcient than monolithic veriﬁcation, is potentially less
accurate. For example, a load lmay see anyvalue written into
the shared memory by a store seven if there does not exist
a path in the program where lobserves s. This is why, as
shown in Table I, techniques such as [19], [27] cannot obtainproofs for the programs in Fig. 2 and Fig. 5. In the context of
interrupt handlers with priorities, it means that even infeasible
store-to-load ﬂows due to priorities may be included in the
analysis, thus causing false alarms.
In the remainder of this paper, we show how to introduce
priorities into the propagation of data ﬂows between interrupts
during the analysis, thereby increasing the accuracy while
retaining its efﬁciency.
IV . F EASIBILITY OF DATA FLOWS BETWEEN INTERRUPTS
In this section, we present our method for precisely modeling
the priority-based interleaving semantics of interrupts, anddeciding the feasibility of store-to-load data ﬂows between
interrupts. If, for example, a certain store-to-load data ﬂow is
indeed not feasible, it will not be propagated across interrupts
in Algorithm 2.
More formally, given a set of store-to-load pairs, we want
to compute a new M USTNOTREADFROM relation, such that
MUSTNOTREADFROM (l,s), for any load land store s, means
if we respect all the other existing store-to-load pairs, then it
would be infeasible for lto get the value written by s.
We have developed a Datalog-based declarative program
analysis procedure for computing M USTNOTREADFROM .
Toward this end, we ﬁrst generate a set of Datalog facts
from the program and the given store-to-load pairs. Then,
we generate a set of Datalog rules, which infer the new
MUSTNOTREADFROM relation from the Datalog facts. Finally,
we feed the facts together with the rules to an off-the-shelf
Datalog engine, which computes the M USTNOTREADFROM
relation. In our implementation, we used the μ-Z Datalog
engine [13] to solve the Datalog constraints.
210
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. A. Inference Rules
Before presenting the rules, we deﬁne some relations:
•DOM(a,b): statement adominates bin the CFG of an
interrupt handler function.
•POSTDOM(a,b): statement apost-dominates bin the CFG
of an interrupt handler function.
•PRI(s,p): statement shas the priority level p.
•LOAD(l,v):lis a load of global variable v.
•STORE (s,v):sis a store to global variable v.
Dominance and post-dominance are efﬁciently computable [8]
within each interrupt handler (not across interrupt handlers).
Priority information for each interrupt handler, and thus all
its statements, may be obtained directly from the program.
Similarly, L OAD and S TORE relations may be directly obtained
from the program.
Next, we present the rules for inferring three new relations:
NOPREEMPT ,COVERED LOAD and I NTERCEPTED STORE .
a)NOPREEMPT :The relation means s1cannot preempt
s2, where s1ands2are instructions in separate interrupt
handlers. From the interleaving semantics of interrupts, weknow a handler may only be preempted by another handler
with a higher priority. Thus,
NOPREEMPT (s1,s2)←PRI(s1,p1)∧PRI(s2,p2)∧(p2≥p1)
Here, PRI(s1,p1)meanss1belongs to a handler with priority
p1, and PRI(s2,p2)meanss2belongs to a handler with priority
p2.I fp 1is not higher than p2, thens1cannot preempt s2.
b)COVERED LOAD :The relation means a load lof a
variablevis covered by a store stovinside the same interrupt
handler; this is the case when soccurs before lalong all
program paths. This is captured by the dominance relation in
the corresponding control ﬂow graph:
COVERED LOAD(l)←LOAD(l,v)∧STORE(s,v)∧DOM(s,l)
c)INTERCEPTED STORE :The relation is similar to C OV-
ERED LOAD. We say a store s1is intercepted by another store s2
ifs2occurs after s1along all program paths in the same handler.
Intuitively, the value written by s1is always overwritten by s2
before the handler terminates. Formally,
INTERCEPTED STORE (s1)←STORE (s1,v)∧STORE (s2,v)
∧POSTDOM(s2,s1)
Finally, the M USTNOTREADFROM relation is deduced
using all aforementioned relations including N OPREEMPT ,
COVERED LOAD and I NTERCEPTED STORE . It indicates that,
under the current situation (deﬁned by the set of existing store-to-load data ﬂows), a load
lcannot read from a store sin any
feasible interleaving. There are several cases:
First, we say a load lcovered by a store in a handler I
cannot read from a store sintercepted by another store in a
handlerI/prime, because lcannot read from susing any preemption
or by running IandI/primesequentially.MUSTNOTREADFROM (l,s)←COVERED LOAD(l)∧LOAD(l,v)
∧STORE (s,v )∧INTERCEPTED STORE (s)
Second, we say a load lcovered by a store sin a handler I
cannot read from any store s/primethat cannot preempt I, because
the value of s/primewill always be overwritten by s. That is, since
s/primecannot preempt I, it cannot execute in between sandl.
MUSTNOTREADFROM (l,s)←COVERED LOAD(l)∧LOAD(l,v)
∧STORE (s,v )∧NOPREEMPT (s,l)
Third, we say that, if a store sis intercepted in a handler
I, then a load lof the same variable that cannot preempt s,
cannot read from the value stored by s. This is because the
store intercepting swill always overwrite the value.
MUSTNOTREADFROM (l,s)←INTERCEPTED STORE (s)∧STORE (s,v )
∧LOAD(l,v)∧NOPREEMPT (l,s)
B. The Running Examples
To help understand how M USTNOTREADFROM is deduced
from the Datalog rules and facts, we provide a few exam-ples. For ease of comprehension, we show in Table II how
MUSTNOTREADFROM may be deduced from I NTERCEPTED -
STORE ,COVERED LOAD and N OPREEMPT . Since all stores
are either in or outside I NTERCEPTED STORE , and all loads
are either in or outside C OVERED LOAD, our rules capture the
MUSTNOTREADFROM relation between all stores and loads.
TABLE II
MUSTNOTREADFROM RULES BASED ON INTERCEPTED STORE ,
COVERED LOAD AND PRIORITY
INTERCEPTED STORE (s) NOTINTERCEPTED STORE (s)
COVERED LOAD(l) MUSTNOTREADFROM (l,s) 1)Not N OPREEMPT (s,l)→
Possibly READFROM (l,s)
2)NOPREEMPT (s,l)→
MUSTNOTREADFROM (l,s)
NOTCOVERED LOAD(l) 1)NOPREEMPT (l,s)→ Possibly READFROM (l,s)
MUSTNOTREADFROM (l,s)
2)Not N OPREEMPT (l,s)→
Possibly READFROM (l,s)
Speciﬁcally, if a store sis INTERCEPTED STORE and a load
lis C OVERED LOAD, there is no way for the load to read from
the store (Row 2 and Column 2).
If a load lis not C OVERED LOAD and a store sis not
INTERCEPTED STORE , the load may read from the store by
running sequentially or via preemption (Row 3 and Column
3).
If a load lis C OVERED LOAD, a store sis not I NTER -
CEPTED STORE and the handler of the store can preempt the
handler of the load, the load may read from the store through
preemption (the ﬁrst case at Row 2 and Column 3). However,
if the handler of the store cannot preempt the handler of the
load, it is impossible for the load to read from the store; inthis case, the load always reads from the store in the same
interrupt handler (the second case at Row 2 and Column 3).
Lastly, if a load lis not C OVERED LOAD, a store sis
INTERCEPTED STORE , and the handler of the load cannot
preempt the handler of the store, the load cannot read from
211
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. the store since the value of the store is always overwritten by
another store in the same handler (the ﬁrst case at Row 3 and
Column 2). However, if the handler of the load can preempt
the handler of the store, then the load can read from the store
through preemption in between two stores (the second case at
Row 3 and Column 2).
irq0() {
store(x)
load(x)
}irq1() {
store(x)store(x)
}
(a) C OVERED LOAD &I NTER -
CEPTED STOREirq0() {
store(x)load(x)
}irq1() {
...store(x)
}
(b) C OVERED LOAD & Not I N-
TERCEPTED STORE
irq0() {
...
load(x)
}irq1() {
store(x)
store(x)
}
(c) Not C OVERED LOAD &I N-
TERCEPTED STOREirq0() {
...load(x)
}irq1() {
...store(x)
}
(d) Not C OVERED LOAD & Not
INTERCEPTED STORE
Fig. 7. Examples for each case in Table II.
Fig. 7 shows concrete examples of the four cases presented
in Table II, where the ﬁgures correspond to the cases.
Fig. 7(a) represents the case at Row 2 and Column 2 in
Table II and Fig. 7(b) represents the case at Row 2 and Column
3. In both programs, only the interference between bold-style
statements are considered.
Fig. 7(a) shows an interference between C OVERED LOAD
and I NTERCEPTED STORE . Since the load in irq0 is always
overwritten by another store in it and a value of the ﬁrst store
inirq1 is always updated by a store in it, the load cannot read
a value from the store by preemption or running sequentially.
Fig. 7(b) shows an interference between C OVERED LOAD and
not I NTERCEPTED STORE . In this case, if irq1 can preempt
irq0 , then the store from irq1 can occur between the store
and the load in irq0 . Otherwise, the load from irq0 cannot
read a value from the store from irq1.
Fig. 7(c) shows an interference between not C OVERED LOAD
and I NTERCEPTED STORE . Similarly, if irq0 can preempt
irq1 , the load from irq0 can occur between the two stores
from irq1 . Thus, it is possible for the load to read a value
from the ﬁrst store in irq1 . Otherwise, the load cannot read
a value from the store by preemption of irq1 or running
sequentially.
Fig. 7(d) shows an interference between not C OVERED LOAD
and not I NTERCEPTED STORE . Here, the load in irq0 can
read a value from the store in irq1 by running sequentially
or through preemption. Therefore, it is possible for the load toread a value from the store as described at Row 3 and Column
3 in Table II.
To sum up, we can use the three inference rules to determine
infeasible store-to-load pairs for all these cases.
C. Soundness of the Analysis
By soundness, we mean the M USTNOTREADFROM rela-
tion deduced from the Datalog facts and rules is an under-
approximation. That is, any pair (l,s)of load and store in this
relation is guaranteed to be infeasible. However, we do notAlgorithm 3 Analysis of the entire program (cf. Alg. 2).
10: function INTERF (T=/angbracketleftN,n 0,δ/angbracketright,T/prime=/angbracketleftN/prime,n/prime
0,δ/prime/angbracketright,S )
11:I←∅
12: for alln∈Ndo
13: ifnis a shared memory write to variable vthen
14: I(v)←I(v)/unionmulti{(n, TFUNC (n,S(n))}
15: returnI
Algorithm 4 Analysis of a single interrupt (cf. Alg. 1).
1:function ANALYZE LOCAL (T=/angbracketleftN,n 0,δ/angbracketright,I)
...
6: ifnis a shared-memory read of variable vthen
7:i←/unionsqtext{n|(st,s)∈I(v)∧¬MUSTNOTREADFROM (l,st)}
8:s←TFUNC (n,S (n)/unionsqi)
9: else
10: s←TFUNC (n,S (n))
...
attempt to identify allthe infeasible pairs because the goal
here is to quickly identify some infeasible pairs and skip them
during the more expensive abstract interpretation computation.
Theorem 2: Whenever MUSTNOTREADFROM (l,s)holds,
the load lcannot read from the store son any concrete
execution of the program.
The soundness of our analysis as stated above can be
established in two steps. First, assume that each individual
rule is correct, the composition is also correct. Second, while
presenting these rules, we have sketched the intuition behind
the correctness of each rule. A more rigorous proof can be
formulated via proof-by-contradiction in a straightforward
fashion, which we omit for brevity.
V. T HEOVERALL ANALYSIS PROCEDURE
We now explain how to integrate the feasibility checking
technique into the overall procedure for iterative analysis, whichleverages the M
USTNOTREADFROM relation to improve perfor-
mance. Speciﬁcally, when analyzing each interrupt handler T,
we ﬁlter out any interfering stores from other interrupt handlers
that are deemed infeasible, thereby preventing their visibility
toT. This can be implemented in Algorithm 2 by modifying
the function I NTERF , as well as the function A NALYZE LOCAL
deﬁned in Algorithm 1.
Our modiﬁcations to I NTERF are shown in Algorithm 3.
That is, when computing the interferences of T, we choose to
create a set of store–state pairs, instead of eagerly joining all
these states. By delaying the join of these states, we obtain
the opportunity to ﬁlter out the infeasible store-to-load pair
individually. For this reason, we overload the deﬁnition of /unionmulti
to be the join (/unionsq ) of sets on matching variables.
Next, we modify the abstract interpretation procedure for a
single interrupt handler as shown in Algorithm 4. The process
remains the same as A NALYZE LOCAL of Algorithm 1 except
that, when a load lis encountered (Line 6), we join the state
from all interfering stores while removing any that must not
interfere with l, as determined by the M USTNOTREADFROM
relation (Line 7).
The remainder of the modular analysis remains the same as
in Algorithm 2.
212
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. irq0() {
b=x ;
assert(b == 0);
}irq1() {
while(...) {
x=1 ;
x=0 ;
}
}
Fig. 8. A small example with a loop.
For example, in Fig. 7(a), existing thread-modular abstract
interpretation methods would consider the two stores from
irq1 for the load of xinirq0 . In contrast, we use
Algorithm 4 to remove the pairing of the load in irq0 and
the ﬁrst store in irq1 , since the load and the store satisfy the
MUSTNOTREADFROM relation. Similarly, the pairing of the
load of xinirq0 and the store of xinirq1 is ﬁltered out
when irq1 ’s priority is not higher than irq0 ’s priority as
shown in Fig. 7(b).
Our method can handle programs with loops. Fig. 8 shows
an example, which has two interrupt handlers where irq1 has
higher priority than irq0 . Note that irq0 loads xand stores
the value into b. Since xis initialized to 0, the handler checks
whether the value of bis0.irq1 has a loop containing two
stores of x. First, it stores the value 1and then the value 0.
Using traditional thread-modular abstract interpretation, we
would assume that x=1 andx=0 are all possible stores to the
load of xinirq0 . This would lead to a bogus violation of
the assertion in irq0.
However, in our analysis, this bogus violation is avoided by
using the post-dominate relation between statements. Inside the
while-loop of irq1 ,x=0 post-dominates x=1, meaning that
x=0 always occurs after x=1. Therefore, using our Datalog
inference rules presented in the previous section, we conclude
that the store x=1 cannot reach the load of xinirq0 . Thus,
it is impossible for the value 1to be stored in band then
cause the assertion violation.
VI. E XPERIMENTS
We have implemented IntAbs, our new abstract interpretation
framework in a static veriﬁcation tool for interrupt-driven
C programs. It builds on a number of open-source tools
including Clang/LLVM [1] for implementing the C front-end,
Apron library [16] for implementing the abstract domains, and
μZ[13] for solving the Datalog constraints. We experimentally
compared IntAbs with both iCBMC [18], a model checker
for interrupt-driven programs and the state-of-the-art thread-
modular abstract interpretation method by Min ´e [24], [27]. We
conducted our experiments on a computer with an Intel Core
i5-3337U CPU, 8 GB of RAM, and the Ubuntu 14.04 Linux
operating system.
Our experiments were designed to answer the following
research questions:
•Can IntAbs prove more properties (e.g., assertions) than
state-of-the-art techniques such as iCBMC [18] and
Min´e [24], [27]?
•Can IntAbs achieve the aforementioned higher accuracy
while maintaining a low computational overhead?
•Can IntAbs identify and prune away a large number of
infeasible store-load pairs?TABLE III
BENCHMARK PROGRAMS USED IN OUR EXPERIMENTAL EV ALUATION .
Name Description
test Small programs created to conduct the sanity check of IntAbs’s
handling of various interrupt semantics.
logger Programs that model parts of the ﬁrmware of a temperature logging
device from a major industrial enterprise. There are two major interrupt
handlers: one for measurement and the other for communication.
blink Programs that control LED lights connected to the MSP430 hardware,
to check the timer values and change LED blinking based on the timer
values.
brake Programs generated from the Matlab/Simulink model of a brake-by-
wire system from V olvo Technology AB, consisting of a main interrupt
handler and four other handlers for computing the braking torque based
on the speed of each wheel.
usbmouse USB mouse driver from the Linux kernel, consisting of the device
open, probe, and disconnect tasks with interrupt handlers.
usbkbd USB keyboard driver from the Linux kernel, consisting of the device
open, probe, and disconnect tasks with interrupt handlers.
rgbled USB RGB LED driver from the Linux kernel. We use initializationofledand rgbfunctions and the ledprobe function, and check the
consistency of the ledand rgbdevice values using interrupts.
rcmain Linux device driver for a remote controller core, including operations
such as device register, free, check the device information, and update
protocol values. We check the consistency of the device information
and protocol values using several interrupt handlers.
others Programs collected from Linux kernel drivers for supporting hardware
such as ISA boards, TCO timer for i8xx chipsets, and watch dog.
Toward this end, we evaluated IntAbs on 35 interrupt-driven C
programs, many of which are from real applications such
as control software, ﬁrmware, and device drivers. Thesebenchmark programs, together with our software tool, have
been made available online [14]. The detailed description of
each benchmark group is shown in Table III. In total, there
are 22,541 lines of C code.
A. Results
Table IV shows the experimental results. Columns 1-4 show
the name, the number of lines of code (LoC), the number
of interrupt handlers, and the number of assertions used for
each benchmark program. Columns 5-7 show the results of
iCBMC [18], including the number of violations detected,
the number of proofs obtained, and the total execution time.
Columns 8-10 show the results of Min ´e’s abstract interpretation
method [24], [27]. Columns 11-13 show the results of IntAbs,
our new abstract interpretation tool for interrupts.
Since iCBMC conducts bounded analysis, when it detects
a violation, it is guaranteed to be a real violation; however,
when it does not detect any violation, the property remains
undetermined. Furthermore, since iCBMC by default stops as
soon as it detects a violation, we evaluated it by repeatedly
removing the violated property from the program until it couldno longer detect any new violation. Also note that since
iCBMC
requires the user to manually set up the interrupt-enabled points
as described in [18], during the experiments, we ﬁrst ordered
the interrupts by priority and then set interrupt-enabled points
at the beginning of the next interrupt handler. For example,
given three interrupts irq_L ,irq_M andirq_H , we would
set the enabled point of irq_L in a main function, the enabled
point of irq_M at the beginning of irq_L , and the enabled
point of irq_H at the beginning of irq_M.
Overall, iCBMC found 88 violations while obtaining 0 proofs.
Min´e’s method, which was geared toward proving properties
in threads, obtained 8 proofs while reporting 254 warnings,
213
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. TABLE IV
RESULTS OF COMPARING INTABSWITH STATE -OF-THE-ART TECHNIQUES ON 35INTERRUPT -DRIVEN PROGRAMS .
iCBMC [18] Min´e [24], [27] intAbs (new)
Name LOC Interrupts Assertions Violations Proofs Time (s) Warnings Proofs Time (s) Warnings Proofs Time (s)
test1 46 2 2 0 0 0.23 1 1 0.18 0 2 0.07
test2 65 3 3 1 0 0.55 3 0 0.05 1 2 0.06
test3 86 4 4 1 0 0.52 4 0 0.06 2 2 0.10
test4 56 2 2 1 0 0.52 2 0 0.04 1 1 0.05
test5 54 2 2 1 0 1.56 2 0 0.04 1 1 0.04
logger1 161 2 1 0 0 0.45 1 0 0.22 0 1 0.27
logger2 183 3 3 0 0 0.50 2 1 0.29 0 3 0.39
logger3 195 4 4 0 0 0.46 1 3 0.31 0 4 0.43
blink1 164 3 3 1 0 0.65 3 0 0.12 2 1 0.18
blink2 174 4 3 1 0 0.67 3 0 0.16 2 1 0.30
blink3 194 5 4 2 0 1.14 4 0 0.25 3 1 0.46
brake1 819 2 5 1 0 0.87 3 2 0.66 1 4 0.98
brake2 818 3 4 3 0 2.24 4 0 1.67 3 1 1.91
brake3 833 4 5 2 0 2.38 5 0 2.58 4 1 3.48
usbmouse1 426 2 8 2 0 0.79 7 1 0.11 2 6 0.13
usbmouse2 442 4 16 2 0 0.69 16 0 0.31 5 11 0.69
usbmouse3 449 5 20 11 0 4.00 20 0 0.52 11 9 1.28
usbkbd1 504 2 8 3 0 0.91 8 0 0.23 4 4 0.39
usbkbd2 512 3 12 2 0 1.20 12 0 0.51 4 8 1.09usbkbd3 531 5 20 3 0 1.19 20 0 1.86 12 8 4.44
rgbled1 656 2 10 5 0 0.71 10 0 0.41 5 5 0.77
rgbled2 679 3 15 5 0 1.11 15 0 0.99 5 10 2.39
rgbled3 701 4 20 5 0 1.07 20 0 2.18 10 10 5.68
rcmain1 2060 3 9 0 0 5.36 9 0 1.58 0 9 1.80
rcmain2 2088 5 15 6 0 12.39 15 0 6.93 6 9 9.46rcmain3 2102 6 18 9 0 3.95 18 0 12.20 9 9 16.35
i2cpca isa1 321 4 6 0 0 0.41 6 0 0.14 0 6 0.29
i2cpca isa2 341 6 10 8 0 2.24 10 0 0.36 8 2 1.05
i2cpca isa3 363 8 14 12 0 4.98 14 0 0.85 12 2 2.48
i8xx tco1 757 3 2 0 0 0.30 2 0 0.28 0 2 0.35
i8xx tco2 949 4 2 1 0 0.96 2 0 0.43 1 1 0.54
i8xx tco3 944 6 3 0 0 0.52 3 0 0.81 0 3 1.04
wdt pci1 1239 4 2 0 0 0.41 2 0 0.40 0 2 0.61
wdt pci2 1290 6 3 0 0 0.43 3 0 0.78 1 2 1.45
wdt pci3 1339 8 4 0 0 0.39 4 0 1.41 3 1 3.21
Total 22,541 136 262 88 0 56.75 (254)∗8 39.92 (118) 144 64.21
∗indicates the results contain bogus warnings, because the technique was designed for threads, not for interrupts.
many of which turned out to be bogus warnings. In contrast,
our new method, IntAbs, obtained 144 proofs while reporting
118 warnings. This is signiﬁcantly more accurate than the prior
techniques.
In terms of the execution time, IntAbs took 64 seconds,
which is slightly long than the 39 seconds taken by Min´e’s
method and the 56 seconds taken by iCBMC.
B. Infeasible Pairs
Since IntAbs removes infeasible store-load pairs during
the iterative analysis of individual interrupt handlers, it tends
to spend extra time checking the feasibility of these data
ﬂow pairs. Nevertheless, this is the main source of accuracyimprovement of IntAbs. Thus, to understand the trade-off,
we have investigated, for each benchmark program, the total
number of store-load pairs and the number of infeasible store-
load pairs identiﬁed by our technique. Table V summarizes the
results, where Column 3 shows the total number of store-load
pairs, Column 4 shows the number of infeasible pairs, and
Column 5 shows the percentage.
Overall, our Datalog-based method for computing the
MUSTNOTREADFROM relation helped remove 69% of the load-
store pairs, which means the subsequent abstract interpretationprocedure only has to consider the remaining 31% of the load-store pairs. This allows IntAbs to reach a ﬁxed point not only
quicker but also with signiﬁcantly more accurate results.
VII. R ELATED WORK
We have reviewed some of the most closely-related work. In
addition, Min ´e [28] proposed an abstract interpretation based
technique for proving the absence of data-races, deadlocks,
and other runtime errors in real-time software with dynamic
priorities, which is an extension of his prior work [24], [26],
[27] by adding priorities while targeting the OSEK/AUTOSAR
operating systems. Speciﬁcally, it tracks the effectiveness ofmutex, yield and scheduler state based on execution traces
to ﬁgure out reachability, while using priorities to make the
analysis more accurate. However, the technique may not be
efﬁcient in terms of memory and speed since it needs to check
all mutex, yield, and scheduler state to determine spurious
interference through trace history. Furthermore, it has not been
thoroughly evaluated on practical benchmarks.
Schwarz and M ¨uller-Olm [34] proposed a static analysis
technique for programs synchronized via the priority ceiling
protocol. The goal is to detect synchronization ﬂaws dueto concurrency induced by interrupts, especially for data
214
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. TABLE V
RESULTS OF TOTAL AND FILTERED STORE -LOAD PAIRS USING INTABS.
Name LOC # of Pairs # of Filtered Pairs Filtered Ratio
test1 46 1 1 100%
test2 65 4 2 50%
test3 86 16 8 50%
test4 56 4 3 75%
test5 54 4 3 75%
logger1 161 18 2 11%
logger2 183 32 6 18%
logger3 195 34 6 17%
blink1 164 19 15 78%
blink2 174 56 32 57%
blink3 194 120 63 52%
brake1 819 34 24 70%
brake2 818 82 58 70%
brake3 833 164 128 78%
usbmouse1 426 12 8 66%
usbmouse2 442 168 136 80%
usbmouse3 449 288 208 72%
usbkbd1 504 40 20 50%
usbkbd2 512 120 80 66%
usbkbd3 531 400 280 70%
rgbled1 656 76 38 50%
rgbled2 679 228 152 66%
rgbled3 701 456 304 66%
rcmain1 2060 84 84 100%
rcmain2 2088 560 476 85%
rcmain3 2102 840 714 85%
i2cpca isa1 321 33 33 100%
i2cpca isa2 341 210 110 52%
i2cpca isa3 363 434 240 55%
i8xx tco1 757 14 12 85%
i8xx tco2 949 28 20 74%
i8xx tco3 944 39 33 84%
wdt pci1 1239 60 40 66%
wdt pci2 1290 150 82 54%
wdt pci3 1339 288 139 48%
Total 22,541 5,116 3,560 69%
races and transactional behavior of procedures. However, it
is not a general-purpose veriﬁcation procedure and cannotprove the validity of assertions. Regehr et al. [32] proposedto use context-sensitive abstract interpretation of machinecode to guarantee stack-safety for interrupt-driven programs.
Kotker and Seshia [17] extended a timing analysis procedure
from sequential programs to interrupt-driven programs witha bounded number of context switches. As such, it does not
analyze all behaviors of the interrupts. Furthermore, the user
needs to come up with a proper bound of the context switches
and specify the arrival time for interrupts.
Wu et al. [43] leveraged (bound) model checking tools to
detect data-races in interrupt-driven programs. Kroening et
al. [18] also improved the CBMC bounded model checker to
support the veriﬁcation of interrupt-driven programs. However,
they only search for a bounded number of execution steps, andthus cannot prove the validity of assertions. Wu et al. [42] also
proposed a source-to-source transformation technique similar
to Regehr [31]: it sequentializes interrupt-driven programs
before feeding them to a veriﬁcation tool. However, due to thebounded nature of the sequentialization process, the method is
only suitable for detecting violations but not for proving the
absence of such violations.
This limitation is shared by testing methods. For example,
Regehr [30] proposed a testing framework that schedules theinvocation of interrupts randomly. Higashi and Inoue [12]
leveraged a CPU emulator to systematically trigger interrupts
to detect data races in interrupt-driven programs. However,
it may be practically infeasible to cover all interleavings of
interrupts using this type of techniques.
Wang et al. [39], [40] proposed a hybrid approach that
combines static program analysis with dynamic simulation to
detect data races in interrupt-driven programs. Although theapproach is useful for detecting bugs, it cannot be used to
obtain proofs, i.e., proofs that assertions always hold.
There are also formal veriﬁcation techniques for embedded
software based on model checking [11], [15], [33], [36]–[38],
[44]. For example, Schlich and Brutschy [33] proposed thereduction of interrupt handler points based on partial order
reduction when model checking embedded software. V ´ortler
et al. [36] proposed, within the Contiki system, a method for
modeling interrupts at the level of hardware-independent C
source code and a new modeling approach for periodically
occurring interrupts. Then, they verify programs with interrupts
using CBMC, which is again a bounded model checker. This
means the technique is also geared toward detecting bugs and
thus cannot prove properties. Furthermore, since it models the
periodical interrupt invocation only, the approach cannot deal
with non-periodic invocations.
Datalog-based analysis techniques have been widely used in
testing and veriﬁcation [2], [7], [9], [10], [21], [23], [29], [41],
but none of the prior techniques was designed for analyzing
the interleaving behavior of interrupts. For example, Kusano
and Wang [19], [20] used Datalog to obtain ﬂow-sensitivity
in threads to improve the accuracy of thread-modular abstract
analysis for concurrent programs. Sung et al. [35] used Datalog-
based static analysis of HTML DOM events to speed up atesting tool for JavaScript based web applications. However,the Datalog rules used by these prior techniques cannot be
used to reason about the behavior of interrupts with priorities.
VIII. C ONCLUSIONS
We have presented an abstract interpretation framework
for static veriﬁcation of interrupt-driven software. It ﬁrst
analyzes each individual handler function in isolation and then
propagates the results to other handler functions. To ﬁlter out
the infeasible data ﬂows, we have also developed a constraint-
based analysis of the scheduling semantics of interrupts with
priorities. It relies on constructing and solving a system of
Datalog constraints to decide whether a set of data ﬂow pairs
may co-exist. We have implemented our method in a softwaretool and evaluated it on a large set of interrupt-driven programs.Our experiments show the new method not only is efﬁcient butalso signiﬁcantly improves the accuracy of the results compared
to existing techniques. More speciﬁcally, it outperformed both
iCBMC, a bounded model checker, and the state-of-the-art
abstract interpretation techniques.
IX. A CKNOWLEDGMENTS
This material is based upon research supported in part by the
U.S. National Science Foundation under grants CCF-1149454
and CCF-1722710 and the U.S. Ofﬁce of Naval Research under
award number N00014-17-1-2896.
215
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. REFERENCES
[1]Vikram Adve, Chris Lattner, Michael Brukman, Anand Shukla, and
Brian Gaeke. LLV A: A Low-level Virtual Instruction Set Architecture.
InACM/IEEE international symposium on Microarchitecture, 2003.
[2]Martin Bravenboer and Yannis Smaragdakis. Strictly declarative
speciﬁcation of sophisticated points-to analyses. In ACM SIGPLAN
Conference on Object Oriented Programming, Systems, Languages, and
Applications, pages 243–262, 2009.
[3]Doina Bucur and Marta Kwiatkowska. On software veriﬁcation for sensor
nodes. Journal of Systems and Software, 84(10):1693–1707, 2011.
[4]E. Clarke, D. Kroening, and F. Lerda. A tool for checking ANSI-C
programs. In International Conference on Tools and Algorithms for
Construction and Analysis of Systems, pages 168–176, 2004.
[5]Patrick Cousot and Radhia Cousot. Abstract interpretation: A uniﬁed
lattice model for static analysis of programs by construction or approxi-
mation of ﬁxpoints. In ACM SIGACT-SIGPLAN Symposium on Principles
of Programming Languages, pages 238–252, 1977.
[6]Patrick Cousot, Radhia Cousot, J ´erˆome Feret, Laurent Mauborgne,
Antoine Min ´e, David Monniaux, and Xavier Rival. The ASTRE ´E
analyzer. In European Symposium on Programming Languages and
Systems, pages 21–30, 2005.
[7]Azadeh Farzan and Zachary Kincaid. Veriﬁcation of parameterized
concurrent programs by modular reasoning about data and control.
InACM SIGACT-SIGPLAN Symposium on Principles of Programming
Languages, pages 297–308, 2012.
[8]Jeanne Ferrante, Karl J. Ottenstein, and Joe D. Warren. The programdependence graph and its use in optimization. ACM Transactions on
Programming Languages and Systems, 9(3):319–349, July 1987.
[9]Shengjian Guo, Markus Kusano, and Chao Wang. Conc-iSE: Incremental
symbolic execution of concurrent software. In IEEE/ACM International
Conference On Automated Software Engineering, 2016.
[10] Shengjian Guo, Markus Kusano, Chao Wang, Zijiang Yang, and Aarti
Gupta. Assertion guided symbolic execution of multithreaded programs.
InACM SIGSOFT Symposium on F oundations of Software Engineering,
pages 854–865, 2015.
[11] Shengjian Guo, Meng Wu, and Chao Wang. Symbolic execution of
programmable logic controller code. In ACM SIGSOFT Symposium on
F oundations of Software Engineering, pages 326–336, 2017.
[12] Makoto Higashi, Tetsuo Yamamoto, Yasuhiro Hayase, Takashi Ishio, andKatsuro Inoue. An effective method to control interrupt handler for data
race detection. In Proceedings of the 5th Workshop on Automation of
Software Test, pages 79–86, 2010.
[13] Krystof Hoder, Nikolaj Bjørner, and Leonardo de Moura. muZ - anefﬁcient engine for ﬁxed points with constraints. In International
Conference on Computer Aided V eriﬁcation, pages 457–462, 2011.
[14] The intAbs tool and benchmark programs for evaluating intAbs. URL:
https://github.com/sch8906/intAbs.
[15] Franjo Ivan ˇci´c, I. Shlyakhter, Aarti Gupta, M.K. Ganai, V . Kahlon, Chao
Wang, and Z. Yang. Model checking C program using F-Soft. In
International Conference on Computer Design, pages 297–308, 2005.
[16] Bertrand Jeannet and Antoine Min ´e. Apron: A library of numerical
abstract domains for static analysis. In International Conference on
Computer Aided V eriﬁcation, pages 661–667, 2009.
[17] Jonathan Kotker, Dorsa Sadigh, and Sanjit A. Seshia. Timing analysis
of interrupt-driven programs under context bounds. In International
Conference on F ormal Methods in Computer-Aided Design, pages 81–90,
2011.
[18] Daniel Kroening, Lihao Liang, Tom Melham, Peter Schrammel, and
Michael Tautschnig. Effective veriﬁcation of low-level software with
nested interrupts. In Proceedings of the Design, Automation & Test in
Europe Conference, pages 229–234, 2015.
[19] Markus Kusano and Chao Wang. Flow-sensitive composition of thread-
modular abstract interpretation. In ACM SIGSOFT Symposium on
F oundations of Software Engineering, pages 799–809, 2016.
[20] Markus J. Kusano and Chao Wang. Thread-modular static analysis for
relaxed memory models. In ACM SIGSOFT Symposium on F oundations
of Software Engineering, pages 337–348, 2017.
[21] Monica S. Lam, John Whaley, V . Benjamin Livshits, Michael C. Martin,
Dzintars Avots, Michael Carbin, and Christopher Unkel. Context-sensitive
program analysis as database queries. In ACM SIGACT-SIGMOD-SIGART
Symposium on Principles of Database Systems, pages 1–12, 2005.
[22] Leslie Lamport. Time, clocks, and the ordering of events in a distributed
system. Commun. ACM, 21(7):558–565, 1978.
[23] V . Benjamin Livshits and Monica S. Lam. Finding security vulnerabilities
in Java applications with static analysis. In USENIX Security Symposium,
2005.[24] Antoine Min ´e. Static analysis of run-time errors in embedded critical
parallel C programs. In Programming Languages and Systems, pages
398–418. 2011.
[25] Antoine Min ´e. Static analysis by abstract interpretation of sequential
and multi-thread programs. In Proc. of the 10th School of Modelling
and V erifying Parallel Processes, pages 35–48, 2012.
[26] Antoine Min ´e. Static analysis of run-time errors in embedded real-time
parallel C programs. Logical Methods in Computer Science, 8(1), 2012.
[27] Antoine Min ´e. Relational thread-modular static value analysis by
abstract interpretation. In International Conference on V eriﬁcation, Model
Checking, and Abstract Interpretation, pages 39–58, 2014.
[28] Antoine Min ´e. Static analysis of embedded real-time concurrent software
with dynamic priorities. Electr . Notes Theor . Comput. Sci., 331:3–39,
2017.
[29] Mayur Naik, Alex Aiken, and John Whaley. Effective static race detection
for Java. In ACM SIGPLAN Conference on Programming Language
Design and Implementation, pages 308–319, 2006.
[30] John Regehr. Random testing of interrupt-driven software. In Interna-
tional Conference on Embedded Software, pages 290–298, 2005.
[31] John Regehr and Nathan Cooprider. Interrupt veriﬁcation via thread
veriﬁcation. Electron. Notes Theor . Comput. Sci., 174(9):139–150, 2007.
[32] John Regehr, Alastair Reid, and Kirk Webb. Eliminating stack overﬂow
by abstract interpretation. ACM Trans. Embedded Comput. Syst. , 4(4):751–
778, 2005.
[33] Bastian Schlich, Thomas Noll, J ¨org Brauer, and Lucas Brutschy. Re-
duction of interrupt handler executions for model checking embedded
software. In Haifa V eriﬁcation Conference, pages 5–20, 2009.
[34] Martin D. Schwarz, Helmut Seidl, Vesal V ojdani, Peter Lammich,and Markus M
¨uller-Olm. Static analysis of interrupt-driven programs
synchronized via the priority ceiling protocol. In ACM SIGACT-SIGPLAN
Symposium on Principles of Programming Languages, pages 93–104,
2011.
[35] Chungha Sung, Markus Kusano, Nishant Sinha, and Chao Wang. Static
DOM event dependency analysis for testing web applications. In ACM
SIGSOFT Symposium on F oundations of Software Engineering, pages
447–459, 2016.
[36] Thilo V ´ortler, Benny H’”ockner, Petra Hofstedt, and Thomas Klotz.
Formal veriﬁcation of software for the Contiki operating system
considering interrupts. In IEEE International Symposium on Design
and Diagnostics of Electronic Circuits & Systems, pages 295–298, 2015.
[37] Chao Wang and Kevin Hoang. Precisely deciding control state reacha-
bility in concurrent traces with limited observability. In International
Conference on V eriﬁcation, Model Checking, and Abstract Interpretation,
pages 376–394, 2014.
[38] Chao Wang, Z. Yang, Franjo Ivancic, and Aarti Gupta. Disjunctive image
computation for emebedded software veriﬁcation. In Proceedings of the
Design, Automation & Test in Europe Conference, 2006.
[39] Yu Wang, Junjing Shi, Linzhang Wang, Jianhua Zhao, and XuandongLi. Detecting data races in interrupt-driven programs based on static
analysis and dynamic simulation. In Proceedings of the 7th Asia-Paciﬁc
Symposium on Internetware, pages 199–202, 2015.
[40] Yu Wang, Linzhang Wang, Tingting Yu, Jianhua Zhao, and Xuandong Li.
Automatic detection and validation of race conditions in interrupt-driven
embedded software. In International Symposium on Software Testing
and Analysis, pages 113–124, 2017.
[41] John Whaley and Monica S. Lam. Cloning-based context-sensitive
pointer alias analysis using binary decision diagrams. In ACM SIGPLAN
Conference on Programming Language Design and Implementation,
pages 131–144, 2004.
[42] Xueguang Wu, Liqian Chen, Antoine Min ´e, Wei Dong, and Ji Wang.
Static analysis of runtime errors in interrupt-driven programs viasequentialization. ACM Trans. Embedded Comput. Syst., 15(4):70:1–
70:26, 2016.
[43] Xueguang Wu, Yanjun Wen, Liqian Chen, Wei Dong, and Ji Wang. Data
race detection for interrupt-driven programs via bounded model checking.
InInternational Conference on Software Security and Reliability, pages
204–210, 2013.
[44] Z. Yang, Chao Wang, Franjo Ivan ˇci´c, and Aarti Gupta. Mixed symbolic
representations for model checking software programs. In International
Conference on F ormal Methods and Models for Codesign, pages 17–24,
2006.
[45] Naling Zhang, Markus Kusano, and Chao Wang. Dynamic partial order
reduction for relaxed memory models. In ACM SIGPLAN Conference
on Programming Language Design and Implementation, pages 250–259,
2015.
216
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. 