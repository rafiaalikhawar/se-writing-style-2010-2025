FiB: Squeezing Loop Invariants by Interpolation
between Forward/Backward Predicate Transformers
Shang-Wei Lin∗, Jun Sun†, Hao Xiao∗, Yang Liu∗, David San ´an∗, and Henri Hansen‡
∗School of Computer Science and Engineering, Nanyang Technological University, Singapore
†Singapore University of Technology and Design, Singapore
‡Tampere University of Technology, Finland
Abstract —Loop invariant generation is a fundamental problem
in program analysis and veriﬁcation. In this work, we propose
a new approach to automatically constructing inductive loopinvariants. The key idea is to aggressively squeeze an inductive
invariant based on Craig interpolants between forward and
backward reachability analysis. We have evaluated our approach
by a set of loop benchmarks, and experimental results show that
our approach is promising.
I. I NTRODUCTION
In program veriﬁcation, loops are challenging to handle.
One way to prove that a loop satisﬁes its postcondition
under a precondition is based on inductive loop invariants .
Intuitively, an inductive loop invariant is a property which
holds in each iteration of the loop. Given an inductive loop
invariant, as long as it is weaker than the precondition, andits conjunction with the negation of the loop condition isstronger than the postcondition, we can conclude that the loopestablishes its postcondition if it terminates. However, program
veriﬁcation based on loop invariants does not come for free.
The key challenge is how to construct inductive loop invariantsautomatically, which is a fundamental problem in programanalysis and veriﬁcation.
Given a loop with precondition Pand postcondition Q,
traditional forward analysis [23], [19] tries to obtain thereachability of the loop after each iteration, as shown inFig. 1 (a). Let F
t(P)be the set of forward reachable states
starting from the precondition Pafter thet-th iteration of the
loop, where F0(P)=P. Notice that Fi(P)=⇒Fi+1(P)for
alli≥0, does not necessarily hold if we consider the strongest
condition after the loop is executed (c.f. Section III for moredetails). Assume that the loop terminates after titerations for
somet≥0, i.e.,F
t(P)does not satisfy the loop condition. If
Ft(P)=⇒Q, then we can conclude that the loop satisﬁes
its postcondition after it terminates. However, this approachmay not terminate in general, or it may take a large numberof forward iterations to ﬁnd such a F
t(P)for some t≥0.
Similarly, traditional backward reachability analysis [23],
[19] tries to obtain the set of backward reachable states,denoted by B
t(Q), from the postcondition Qaftertiterations
(assume the loop condition is still satisﬁed). Notice that
Bi(Q)=⇒Bi+1(Q)for alli≥0does hold if we consider
the weakest condition after the loop is executed backward
(c.f. Section III for more details). If we can ﬁnd a backwardܳܲ…
ܨଵ(ܨ)ܲ௧(ܨ)ܲଶ()ܲ
ܤଵ(ܤ)ܳ௧()ܳ
ܳ
…
ܲ
(a) (b)
Fig. 1. Traditional (a) Forward and (b) Backward Reachability
ܤଵ(¬ܤ)ܳ௧(¬)ܳ
¬ܳܲ…
ܨଵ(ܨ)ܲ௧()ܲ
I…ܨଶ()ܲ
Fig. 2. Our Approach
reachability Bt(Q)for some t≥0such that P=⇒Bt(Q),
then we conclude that the loop satisﬁes its postcondition, asshown in Fig. 1 (b). However, this backward approach maynot terminate in general as well, or it may take a large numberof backward iterations to ﬁnd such a B
t(Q)for some t≥0.
In this paper1, we propose an approach to automatically
constructing inductive loop invariants in the form of Bool-ean combinations of linear integer constraints over programvariables. Our approach is to squeeze an invariant betweenforward and backward reachability of the loop. Althoughthe forward and backward approaches may not terminate ingeneral, they do provide some hints to construct inductiveinvariants. The intuitive idea behind our approach is as follows.Instead of starting from the postcondition Q, we perform the
backward reachability analysis from ¬Q, the negation of the
postcondition. If the loop does have an inductive invariant I
to establish the postcondition Q, as shown in Fig. 2, then
∪
∞
t=0Ft(P)will not intersect with Bt→∞(¬Q); otherwise
Iwould not be inductive. In addition, ∪∞
t=0Ft(P)will be
included in the inductive invariant, i.e., ∪∞t=0Ft(P)=⇒I .
Furthermore, Iwill not intersect with Bt→∞(¬Q)as well;
otherwise, Iwould not be an invariant to establish Q. Based
on the above observation, an inductive invariant Iis actually
1The corresponding author, Shang-Wei Lin, can be contacted via the
following e-mail address: shang-wei.lin@ntu.edu.sg.
978-1-5386-2684-9/17/$31.00 c/circlecopyrt2017 IEEEASE 2017, Urbana-Champaign, IL, USA
T echnical Research793
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:03 UTC from IEEE Xplore.  Restrictions apply. a Craig interpolant [18] (c.f. Deﬁnition 2) for ∪t
i=0Fi(P)with
respect to Bt(¬Q). That is, we can squeeze an inductive
invariant between the forward reachability from Pand the
backward reachability from ¬Qby obtaining an interpolant in
between. If the number of forward/backward steps is sufﬁcient,
an inductive invariant in between should be squeezed out.This observation gives a systematic way to construct an
inductive invariant. The details of our approach is described
in Section IV. To summarize, this work makes the followingcontributions:
•We propose a novel approach to automatically con-structing inductive loop invariants for loop structuresconsisting of multiple paths inside. The generated inva-riant is in the form of Boolean combinations of linearinteger constraints over program variables. The proposedapproach squeezes loop invariants between forward and
backward analysis by obtaining interpolants in between.
To the best of our knowledge, this is the ﬁrst workto combine interpolation techniques with forward andbackward predicate transformers in Hoare Logic [34].
•We have implemented our approach in a tool, called
FiB. We compared FiB with other state-of-the-art inva-
riant generation tools: BLAST [33], InvGen [31], Inter-proc [35], CPAchecker [9], ITP[41], and HOLA[20]. Ourexperimental results show that our approach is promisingfor advancing the state-of-the-art invariant generation fornumeric loops.
The rest of this paper is organized as follows. Section II
illustrates our approach with motivating examples. Section IIIreviews preliminary backgrounds. The details of the proposedapproach is introduced in Section IV. Evaluations of ourapproach are presented in Section V. Section VI summarizesrelated works, and Section VII concludes this work.
II. M
OTIV ATING EXAMPLES
In this section, we illustrate the intuitive idea behind our
approach using two example programs. The ﬁrst exampleis shown in Fig. 3 (a). The precondition of the loop isP:(x=0∧y=0 ) , and the postcondition (assertion)
isQ:y= 100. Traditional forward analysis based on
strongest postcondition requires to execute 100 iterations of
the loop to reach F
100(P):(x= 100∧y= 100) . Since
F100(P)∧(x= 100) = ⇒Q, we can conclude that the
assertion Qis satisﬁed if the loop terminates.
Similarly, traditional backward analysis based on weakest
precondition also requires 100 iteration to ﬁnd B100(Q):/logicalortext100
i=0(x=i∧y=i). SinceP=⇒B100(Q),w ec a n
conclude that the assertion is satisﬁed if the loop terminates.
If we change the constant from 100 to100000, traditional
approaches require a huge number of iterations to prove theassertion. Fig. 3 (b) shows the second example, which isalmost the same as the ﬁrst one except that the constant 100
is replaced by a variable n≥0. In this example, traditional
(either forward or backward) approaches do not terminatebecause the bound is now a variable instead of a constant.assume(x == 0);
assume(y == 0);
while(x != 100){
x++; y++;
}assert(y == 100);
(a)assume(x == 0);
assume(y == 0);
assume(n >= 0);
while(x != n){
x++; y++;
}
assert(y == n);
(b)
Fig. 3. Simple Examples
Stmt/triangle= skip|Stmt; Stmt|x:=Exp|x:=nondet
|ifBExp then Stmt else Stmt
Exp/triangle= n|x|Exp+Exp|Exp−Exp
|Exp∗n|Exp%n
BExp/triangle= False|b|nondet|¬BExp|BExp∧BExp
|Exp <Exp|Exp=Exp
Fig. 4. Syntax of IMP
Our approach works as follows for the second program.
Let us ﬁrst consider the case where the loop executes without
any iteration. In this case, the forward reachability F0(P)is
P:(x=0∧y=0∧n≥0). Then, we perform the
backward analysis. Notice that unlike traditional backward
approach starting from the postcondition Q, we obtain bac-
kward reachability from the negation of the postcondition,i.e.,¬Q. If the loop executes backward without any iteration
from¬Q, the backward reachability B
0(¬Q)would be the
conjunction of ¬Qand the negation of the loop condition,
i.e.,(y/negationslash=n∧x=n). Then, we use an SMT solver to
check the satisﬁability of F0(P)∧B0(¬Q). That is, we check
whether the loop violates its postcondition in zero iteration.Obviously, the formula is not satisﬁable, and we can obtainan interpolant I:(x=y), c.f. Deﬁnition 2, for F
0(P)
with respect to B0(¬Q)from the SMT solver. Intuitively, the
interpolant Iis an abstraction of F0(P), i.e.,F0(P)=⇒I ,
andIis still inconsistent with B0(¬Q). Then, we check
whether the interpolant Iis inductive, i.e., if Iholds initially
in the loop, no matter how many iterations the loop executes,Istill holds. The formula for the inductiveness checking is
(x=y)∧(x
/prime=x+1)∧(y/prime=y+1)∧(x/negationslash=n)=⇒(x/prime=y/prime).
We can check the validity of this formula by an SMT solveras well (c.f. Sections III and IV), and (x=y)is inductive and
strong enough to prove the postcondition Q. Thus,(x=y)
is the loop invariant obtained by our approach. However, if I
is not inductive, we consider the second case where the loopexecutes for one iteration. The same procedure is performed:(1) check the satisﬁability of (F
0(P)∨F1(P))∧B1(¬Q),
(2) obtain an interpolant Iif the formula is not satisﬁable,
and (3) check the inductiveness of I. We keep increasing the
number of iterations and performing the same procedure untilwe ﬁnd an inductive invariant. The details of our approach isintroduced in Section IV.
794
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:03 UTC from IEEE Xplore.  Restrictions apply. wp(skip,Q)⇔Q
wp(x:=e,Q)⇔Q[x/mapsto→e]
wp(x:=nondet,Q )⇔∀x:Q
wp(s1;s2,Q)⇔ wp(s1,wp(s2,Q))
wp(ifbthen s1else s2,Q)⇔(b∧wp(s1,Q))∨
(¬b∧wp(s2,Q))
wp(if nondet then s1else s2,Q)⇔ wp(s1,Q)∨
wp(s2,Q)
Fig. 5. Rules for Weakest Precondition
III. B ACKGROUND
In this work, we consider the imperative (IMP) language,
whose syntax is shown in Fig. 4. In the IMP language, pro-
grams consist of one or more statements. Statements, denoted
by the symbol Stmt, include skip, sequencing, assignment,
and conditional statements. The keyword nondet denotes an
arbitrary value in the type of the assigned variable. The IMP
language supports two basic types: Booleans and integers.There are two kinds of expressions in IMP language, namelyinteger expressions (denoted by the Exp symbol) and Boolean
expressions (denoted by the BExp symbol). A term in Exp is
of the type of integers where xis an integer variable and nis
an integer constant, while a term in BExp is of Boolean type
wherebis a Boolean variable.
To reason about the correctness of an IMP program, we
use the interpretation of Hoare Logic [34]. A Hoare triple isa formula of the form {P}s{Q}, where sis aStmt formula
representing a statement in an IMP program, and PandQ
are the precondition and postcondition of the statement s,
respectively. The Hoare triple {P}s{Q} ispartially correct
2
if the statement sis executed in a state in which Pholds, and
then it terminates in a state in which Qholds unless it aborts
or runs forever.
In this work, we consider two predicate transformers [23],
[19]: wpand sp. The function wptakes as inputs an IMP
statement sand a postcondition Qand returns the weakest
precondition ofswith respect to Q, denoted by wp(s,Q).
The function sptakes as inputs an IMP statement and a
precondition Pand returns the strongest postcondition ofs
with respect to P, denoted by sp(P,s). The rules to calculate
the weakest precondition and strongest postcondition for eachprimitive statement are given in Fig. 5 and Fig. 6, respecti-vely [53]. A Hoare triple {P}s{Q} can be proved if either
P=⇒wp(s,Q)holds, or sp(P,s)=⇒Qholds.
The target loop structure in this work is a single loop with
multiple paths, which can be represented as an annotated loop
of the form: {P}whileκdo S done {Q}. The BExp
formulaκis the loop guard. The loop body Sis a Stmt
2Total correctness requires that the statement shas to terminate. We only
consider partial correctness because the target statement in this work is a loop
which may not terminate in general.sp(P,skip)⇔P
sp(P,x:=e)⇔∃x0:P[x/mapsto→x0]∧
x=e[x/mapsto→x0]
sp(P,x:=nondet) ⇔∃x0:P[x/mapsto→x0]
sp(P,s1;s2)⇔ sp(sp(P,s 1),s2)
sp(P,ifbthen s1else s2)⇔ sp(P∧b,s1)∨
sp(P∧¬b,s2)
sp(P,if nondet then s1else s2)⇔ sp(P,s1)∨sp(P,s2)
Fig. 6. Rules for Strongest Postcondition
formula representing a sequence of statements. The BExp
formulas PandQare the precondition and postcondition of
the annotated loop, respectively.
One way to validate the Hoare triple for an annotated
loop is based on the sppredicate transformer, in which we
need to prove that sp(P,whileκdoSdone)= ⇒Q.
Traditionally [23], [19], it is done by approximating the
strongest postcondition of the loop. We can deﬁne the strongestpostcondition of a loop in a recursive way as follows:
sp(P,whileκdoSdone)
/arrowdblbothv
(P∧¬κ)∨sp(sp(P∧κ,S),whileκdoSdone)
However, the above recursive construction of the strongest
postcondition may not terminate in general, which is notpractical to validate an annotated loop. Furthermore, even if itterminates, it may take a large number of iterations to convergeto a ﬁx-point.
Another way to validate an annotated loop is based on the
wppredicate transformer [23], [19], in which we need to
prove that P=⇒wp(whileκdoSdone,Q). Similarly,
We can approximate the weakest precondition of the loop byconsidering the number of iterations required to establish thepostcondition Q. LetB
tbe a predicate describing the set of
states from which the loop terminates within titerations and
establish Q. We can deﬁne Btin a recursive way as follows,
whereB0=(¬κ∧Q):
Bt=B0∨(κ∧wp(S,Bt−1))
It means that to establish Qwithintiterations, the loop
can either terminate immediately without any iteration and
then establish Q, or perform one iteration and reach a state
where it terminates within t−1iterations and then establish
Q. Theoretically, wp(whileκdoSdone,Q)is equiva-
lent tolimk→∞Bt. SinceBtis an under-approximation of
wp(whileκdoSdone,Q)for allt≥0, in practice,
as long as we can ﬁnd Btfor some t≥0such that
P=⇒Btholds, then we can conclude that P=⇒
wp(whileκdoSdone,Q)holds. However, this approach
may not terminate in general, or it may take a large number
of iterations to ﬁnd such a Btfor some t≥0.
795
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:03 UTC from IEEE Xplore.  Restrictions apply. A promising way to validate an annotated loop is based
on loop invariants, as formulated in Deﬁnition 1. However,
the main problem of validating an annotated loop based onloop invariants is how to generate inductive loop invariantsautomatically. In the next section, we are going to introduceour approach to generating loop invariants automatically basedon Craig interpolation, as formulated in Deﬁnition 2.
Deﬁnition 1: Aloop invariant Iof an annotated loop is a
formula satisfying the following conditions: (1) P=⇒I ,
(2)I∧¬κ=⇒Q, and (3) {I ∧κ}S{I}.
Deﬁnition 2: Given two Boolean formulas AandBsuch
thatA∧Bis unsatisﬁable, a Craig interpolant forAwith
respect to Bis a formula ˆAsatisfying the following properties:
(1)ˆAis an abstraction of A, i.e.,A=⇒ˆA, (2)ˆA∧Bis
unsatisﬁable, and (3) ˆArefers only to the common variables
ofAandB.
The Craig interpolation lemma [18] states that an interpolant
always exists for inconsistent (unsatisﬁable) formulas in ﬁrst-
oder logic. Modern SAT or SMT solvers, e.g., Z3 [3] andMathSAT [1], support Craig interpolation from unsatisﬁableformulas.
IV . S
QUEEZING LOOP INV ARIANTS
In this section, we introduce how an invariant of a loop can
be squeezed based on interpolation between forward/backwardreachability analyses. We propose two approaches. The ﬁrstone, introduced in Section IV-A is based on interpolationwith respect to forward reachability. The second, introduced
in Section IV-B, is based on interpolation with respect to bac-
kward reachability. Section IV-C discusses some extensions.
A. F orward Interpolation
Given an annotated loop, {P}whileκdoS done{Q},
we can consider its forward reachability with the precondition
Pby calculating its strongest postcondition. Let us use A
i=
sp(Ai−1∧κ,S)fori≥1to denote the strongest postcondition
after thei-th iteration, where A0=P. If the loop does have an
inductive invariant I, then the reachability after each iteration
must be contained in I(otherwise, Iwould not be inductive),
i.e., the condition/logicalortext∞
i=0Ai=⇒I must hold.
On the other hand, we can also consider the backward rea-
chability of the loop by calculating the weakest precondition.
However, for the backward reachability, we start from ¬Q, the
negation of the postcondition. Let Bi=B0∨(κ∧wp(S,Bi−1))
fori≥1be the predicate representing the set of states from
which the loop terminates within iiterations and violates the
postcondition Q, where B0=(¬Q∧¬κ)represents that
the loop violates its postcondition Qwithout performing any
iterations. If the loop does have an inductive invariant Ito
establish its postcondition Q, then the formula I∧Bimust be
unsatisﬁable for all i≥0, otherwise Iwould not be inductive
and establish Q.
Based on the above observations, we can ﬁnd that an
inductive invariant I(if it exists) of a loop is actually
an interpolant for (/logicalortext∞
i=0Ai)with respect to B∞because/logicalortext∞i=0Ai=⇒I andI∧B∞is unsatisﬁable. Notice thatAlgorithm 1: Squeeze Invariant – Forward
input : An annotated loop: {P}whileκdoS done{Q}
output: (yes/no,I), whereIis a loop invariant
1A0←−P;
2B0←−(¬κ∧¬Q);
3t←−r←−0;
4while True do
5 if/parenleftBig/logicalortextti=0Ai/parenrightBig
∧Bris not satisﬁable then
6 LetItbe the interpolant for (/logicalortextti=0At)w.r.t.Br;
7 if{It∧κ}S{It}then return (yes,It);
8 At+1←−sp(It∧κ,S);
9 t←−t+1;
10 Br+1←−B0∨(κ∧wp(S,Br));
11 r←−r+1;
12 else
13 ifAtis concrete then return (no,⊥);
14 else
15 whileAtis not concrete dot←−t−1;
16 At+1←−sp(At∧κ,S);
17 t←−t+1;
the inverse is not true, i.e., the interpolant Iis not necessary
to be inductive. However, it does provide a way to ﬁnd an
inductive invariant of a loop. The basic idea is as follows.Firstly, we calculate, for titerations, the forward reachability
(/logicalortext
t
i=0Ai)as well as the backward reachability Bt. Secondly,
we obtain an interpolant Ifor(/logicalortextt
i=0Ai)with respect to Bt
and check whether Iis inductive or not. Thirdly, if Iis an
inductive invariant, then we are done. Otherwise, we increase
the value of tand repeat the ﬁrst and second steps until we
ﬁnd an inductive invariant. Algorithm 1 shows the pseudo-codeof squeezing an inductive invariant of a loop by interpolationbetween the forward and backward reachabilities. The detailsof Algorithm 1 are described as follows:
•Initially, we set A0to beP, andB0to be(¬Q∧¬κ),
respectively (lines 1–2). And, we use tto denote the
number of forward iterations, and rfor the number of
backward iterations. Their initial values are set to be zero,
respectively (line 3). Notice that the values of tandr
might become different during the following process.
•A decision procedure is performed to check whether the
formula(/logicalortextt
i=0Ai)∧Bris satisﬁable or not (line 5).
If the formula is not satisﬁable, we can further obtain
an interpolant Itfor(/logicalortextt
i=0Ai)with respect to Br.
According to the characteristic of interpolants (c.f. Deﬁ-
nition 2), we are guaranteed to have the following twoproperties: (1)/logicalortext
t
i=0Ai=⇒I tand (2)It∧Bris
not satisﬁable. That is, the forward reachability for t
iterations from the precondition Pis included in It,
andItis not going to violate the postcondition Qin
riterations, as illustrated in Fig. 7 (a). Then, we check
whetherItis inductive. If yes, we are done, and the
796
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:03 UTC from IEEE Xplore.  Restrictions apply. B0B1Br…A0
A1
At
…
IݐIt
B0B1Br…Br+1ܣ௧ାଵsp(It∧)ܵ,ߢ
(a) (b)
It-1
B0B1Br-1…Brܣ௧sp(I௧ିଵ∧)ܵ,ߢ
B0B1Br-1…A0
A1
At-1…
At
Br
(c) (d)
Fig. 7. Squeezing Invariants
inductive invariant Itis returned (line 7). IfItis not
inductive, we advance forward for one more iteration
based on It(lines8–9). The reason for advancing forward
fromItis that we may converge toward an inductive
invariant more quickly than from the concrete reachability
(/logicalortextt
i=0Ai)becauseItis an over-approximation of the
concrete reachability, as illustrated in Fig. 7 (b). Similarly,
for backward reachability, we advance backward for onemore iteration from B
r(lines10–11).
•Notice that for the sequence of forward reachabilityA
0,A1,...,A t, if there exists 0<j≤tsuch that
Ajis an over-approximation (i.e., Ajis obtained by
the strongest postcondition operator from the interpolantI
j−1instead of from the concrete reachability Aj−1,a s
shown in Fig. 7 (b), then every Amforj≤m≤t
would be an over-approximation as well. Thus, if the
formula(/logicalortextt
i=0Ai)∧Bris satisﬁable (line 12), there
could be two cases. The ﬁrst case is that Atis concrete,
which means that A0,A1,...,A tare all concrete. In this
case, we conclude that the loop violates its postcondition
Qbecause the solution to the satisﬁability problem of
(/logicalortextt
i=0Ai)∧Bris such a counterexample starting from
Pand violating Qwithint+riterations (line 13). The
second case is shown in Fig. 7 (c), where Atis an over-approximation. We cannot conclude anything for this case
becauseAtmay contain spurious counterexamples. To be
sound and simplify the process, we backtrack to the latestconcrete forward reachability (line 15), from which we
advance forward for one more iteration (lines 16–17),
as illustrated in Fig. 7 (d). After that, the new forward
and backward reachability layout will be analyzed in the
next iteration of Algorithm 1. We repeat the process until
either a counterexample or an inductive invariant is found.
The soundness of Algorithm 1 is proved by Lemma 1 and
Theorem 1. Notice that Algorithm 1 does not guarantee itstermination. In practice, we can set an upper bound on thenumber of forward or backward iterations.
Lemma 1: IfA∧(B∨C)is unsatisﬁable, then A∧Bis
also unsatisﬁable.
Theorem 1: Algorithm 1 is correct.
Proof 1: Given a loop: {P}whileκdoS done{Q},w e
want to prove that the invariant I
treturned by Algorithm 1
satisﬁes the following three conditions: (1) P=⇒I t, (2)
It∧¬κ=⇒Q, and (3){It∧κ}S{It}. SinceItis returned
by Algorithm 1 only if condition (3)holds, we only have to
prove conditions (1)and(2).
Condition (1): we know that P=A0=⇒(/logicalortextt
i=0Ai), and
(/logicalortextt
i=0Ai)=⇒I tbecauseItis an interpolant for (/logicalortextt
i=0Ai)
with respect to Br. Thus, condition (1)holds.
Condition (2): Since Itis an interpolant for (/logicalortextt
i=0Ai)with
respect to Br, we know that It∧Bris unsatisﬁable. According
to Algorithm 1, B0=(¬κ∧¬Q)is one of the disjuncts
ofBr. By Lemma 1, we know that It∧(¬κ∧¬Q)is also
unsatisﬁable. So, its negation, ¬It∨κ∨Q, is a tautology. In
addition, (¬It∨κ)∨Qis equivalent to It∧¬κ=⇒Q.
Thus, condition (2)holds.
We also want to prove that if Algorithm 1 returns “no”, the
loop violates its postcondition Q. According to Algorithm 1,
it returns “no” only when (/logicalortextt
i=0Ai)∧Bris satisﬁable and
Atis concrete. Since Atis concrete, we can conclude that
A0,A1,...,A tare all concrete, and (/logicalortextti=0Ai)represents the
set of concrete states which the loop can reach from Pwithint
iterations. In addition, Bris the predicate representing the set
of states from which the loop terminates within riterations
and violates the postcondition Q. Thus, a solution to the
satisﬁability problem of (/logicalortextti=0Ai)∧Bris a counterexample
starting from Pand violating Qwithint+riterations. /squaresolid
Discussion. In our implementation of Algorithm 1, we use
an SMT solver to solve the formula (/logicalortextti=0Ai)∧Brin each
iteration and directly obtain an interpolant from the solver
if the formula is not satisﬁable. However, the interpolant foran unsatisﬁable formula is not unique, i.e., we may havemany candidates fulﬁlling the three conditions in Deﬁnition 2.Which one is better is worthy of further investigation, and ofcourse we need to deﬁne what “better” means ﬁrst. Currently,our implementation relies on the quality of the interpolantsreturned by the SMT solver, which dominates the performanceof our approach. In fact, initially, we have tried the Z3 [3]SMT solver. However, Z3 always returns the trivial interpolant(/logicalortext
t
i=0Ai), which makes our approach degenerate into traditi-
797
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:03 UTC from IEEE Xplore.  Restrictions apply. onal forward/backward analysis. Thus, we have tried another
SMT solver, MathSAT [1], and it returns better interpolantsthan trivial ones, which makes our implementation effective toﬁnd inductive invariants (c.f. Section V). Techniques providingquality interpolants, like beautiful interpolants [6], could helpto further improve the performance of our approach.
B. Backward Interpolation
In the previous approach, we obtain interpolants from
forward reachability. In this section, we introduce another
approach in the reverse direction. The basic idea is ba-sed on the following observation. Given an annotated loop,{P}whileκdoS done{Q}, if it does have an inductive
invariant I, then the negation of the invariant, ¬I, must be
inductive as well. That is, starting from ¬I, no matter how
many iterations we take backward for the loop, we will stillbe in the set of states satisfying ¬I, i.e., wp(S,¬I)=⇒¬ I .
If it were not the case, ¬Icould cross over to Iafter some
backward iterations so that Iwould not be inductive. This
observation provides us another way to squeeze an inductiveinvariant. The intuition is that when we do the interpolationbetween the forward/backward reachabilities, i.e., the unsa-tisﬁable formula (/logicalortext
t
i=0Ai)∧Br, we obtain an interpolant
IforBrinstead of for (/logicalortextti=0Ai). Then, we check whether
the negation of the interpolant, ¬I, is inductive or not. If yes,
then¬Iis an inductive invariant, and we are done. Otherwise,
we increase the values of tandrby one, respectively, and
repeat the same process until we ﬁnd an inductive invariant.
Algorithm 2 shows the pseudo-code of the backward approach.Since Algorithm 2 is very similar to Algorithm 1 by symmetry,we omit its detailed descriptions here.
The soundness of Algorithm 2 is proved by Lemma 1 and
Theorem 2. Notice that Algorithm 2 does not guarantee itstermination. In practice, we can set an upper bound on thenumber of forward or backward iterations.
Theorem 2: Algorithm 2 is correct.
Proof 2: We want to prove that ¬I
rreturned by Algorithm 2
satisﬁes the following three conditions: (1) P=⇒¬ I r, (2)
¬Ir∧¬κ=⇒Q, and (3) {¬I r∧κ}S{¬I r}. Since¬Iris
returned by Algorithm 2 only if condition (3)holds, we only
have to prove conditions (1)and(2).
Condition (1): Since Iris an interpolant for Brwith respect
to(/logicalortextt
i=0Ai), we know that Ir∧(/logicalortextti=0Ai)is unsatisﬁable. By
Lemma 1, Ir∧Pis also unsatisﬁable because A0=Pis one
of the disjuncts of (/logicalortextti=0Ai). Thus,¬P∨¬I ris a tautology.
In addition, ¬P∨¬I ris equivalent to P=⇒¬ I r. Therefore,
condition (1)holds.
Condition (2): Since Iris an interpolant for Brwith respect
to(/logicalortextti=0Ai), we know Br=⇒I r. Let us consider the se-
quence of B0,B1,...,B r. SinceBj+1=Bj∨(κ∧wp(S,B j))
for0≤j<r , we know B0=⇒B1=⇒...=⇒Br.
Thus,B0=¬κ∧¬Q=⇒I r, which is logically equivalent
to(κ∨Q)∨Ir. According to the associativity law, (κ∨Q)∨Ir
is equivalent to (κ∨Ir)∨Q, which is also logically equivalent
to¬κ∧¬I=⇒Q. Therefore, condition (2)holds. /squaresolidAlgorithm 2: Squeeze Invariant – Backward
input : An annotated loop: {P}whileκdoS done{Q}
output: (yes/no,I), whereIis a loop invariant
1A0←−P;
2B0←−(¬κ∧¬Q);
3t←−r←−0;
4while True do
5 ifBr∧/parenleftBig/logicalortextti=0Ai/parenrightBig
is not satisﬁable then
6 LetIrbe the interpolant for Brw.r.t.(/logicalortextti=0Ai);
7 if{¬I r∧κ}S{¬I r}then return (yes,¬Ir);
8 Br+1←− I r∨(κ∧wp(S,Ir));
9 r←−r+1;
10 At+1←−sp(At∧κ,S);
11 t←−t+1;
12 else
13 ifBris concrete then return (no,⊥);
14 else
15 whileBris not concrete dor←−r−1;
16 Br+1←−B0∨(κ∧wp(S,Br));
17 r←−r+1;
C. Extensions
Our approaches have been proposed to handle one single-
level loop. In this section, we discuss how to extend our
approaches to handle general loop structures, e.g., nested loopsor a sequence of loops. Fig. 8 (a) shows the general structure ofa two-level nested loop, where we only have the preconditionand postcondition of the outer loop. In this case, we are notable to perform our approaches on the inner loop because wedo not know its precondition and postcondition. To handlethis case, one straightforward solution is to ﬂatten the nestedloops into one single-level loop. Fig. 8 (b) illustrates how theﬂattening can be done. Brieﬂy, we just introduce an auxiliaryvariable, block, indicating which loop is active now. One
can easily verify that the ﬂattened loop is equivalent to the
original one. If the outer loop has more than one loop inside,we can inductively perform the ﬂattening. Once the loop isﬂattened, our approaches apply.
The second case that our approaches are not directly ap-
plicable is a sequence of loops. Fig. 9 (a) shows the general
structure of two loops in a sequence. We can see that thepostcondition of the ﬁrst loop as well as the precondition ofthe second are missing. To bridge the gap, we can combinethem into one single-level loop. Fig. 9 (b) illustrates howthe translation is done. Similarly, we use auxiliary variable,block, to indicate the active loop. One can easily verify thatthe translation is correct. If we have more than two loops ina sequence, we can inductively perform the translation suchthat our approaches apply. In a general program, we may havenested loops and sequence loops mixed together. In such asituation, we can inductively perform the translation based on
798
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:03 UTC from IEEE Xplore.  Restrictions apply. while(κ 1){
S1;
while(κ 2){
S2;
}
S/prime
1;
}int block = 0;
while (block != -1){
if (block == 0){
if (κ 1){
S1; block = 1;
} else {
block = -1;
}
} else if(block == 1){
if (κ 2){S2;}
else { S/prime
1; block = 0; }
}
}
(a) Nested Loops (b) Flattened Loop
Fig. 8. Flattening Nested Loops into a Flattened Loop
while(κ 1){
S1;
}
S;
while(κ 2){
S2;
}int block = 0;
while (block != -1){
if (block == 0){
if (κ 1){S1;}
else { S; block = 1; }
} else if (block == 1) {
if (κ 2){S 2;}
else { block = -1; }
}
}
(a) Sequential Loops (b) Combined Loop
Fig. 9. Translation of a Sequence of Loops into One Loop
the two primitive cases in Fig. 8 and Fig. 9.
One more interesting extension is to combine the forward
and backward approaches into a bidirectional one. That is,
in each forward/backward advancing iteration, we obtain theforward interpolant as well as the backward interpolant si-multaneously. If either of them is inductive, we are done;otherwise, we start from them to advance in the next iteration.If they intersect with each other, we backtrack to the concretecases and then continue from there. The process is repeateduntil an invariant is found.
V. E
V ALUATION
The proposed approach to automatically generating in-
ductive loop invariants has been implemented in a tool, calledFiB. In the implementation, we use the SMT solver, Mat-hSAT [1], to solve the satisﬁability problems as well as toobtain interpolants if the formula is not satisﬁable.
To evaluate our approach, we compared FiB with six ex-
isting state-of-the-art invariant generation tools: BLAST [33],InvGen [31], Interproc [35], CPAchecker [9], ITP [41], and
HOLA[20]. Each of the compared tools represents a diffe-
rent family of invariant generation techniques. BLAST is aCEGAR-based model checker that generates loop invariantsfrom counterexamples based on interpolations. InvGen as-sumes that the invariant is of a given template form andgenerates loop invariants by solving constraints with unknown
parameters. Interproc generates loop invariants based on ab-stract interpretation. CPAchecker is a conﬁgurable software1i n tx=0 ;
2i n ty=0 ;
3
4while(x != 100){
5 x=x+1 ;
6 y=y+1 ;
7}
8
9assert(y == 100);
I:x=0∧y=0∧pc=4
t1:(pc=4 )∧(x/negationslash= 100)∧(pc/prime=5 )∧(x/prime=x)∧(y/prime=y)
t2:(pc=4 )∧(x= 100)∧(pc/prime=9 )∧(x/prime=x)∧(y/prime=y)
t3:(pc=5 )∧(pc/prime=6 )∧(x/prime=x+1 )∧ (y/prime=y)
t4:(pc=6 )∧(pc/prime=4 )∧(y/prime=y+1 )∧ (x/prime=x)
t5:(pc=9 )∧(pc/prime=9 )∧(x/prime=x)∧(y/prime=y)
T:t1∨t2∨t3∨t4∨t5
¬ϕ:pc=9∧y/negationslash= 100
Fig. 10. Transition Relation Construction
model checker which supports CEGAR based veriﬁcation
approaches. HOLA generates loop invariants based on logicalabduction and quantiﬁer elimination. ITP is a transition-relation-based model checking technique, which calculatesﬁxpoints by interpolation. For our experiments on ITP, weadopt the standard approach (Chapter 2of [14]) to encode the
transition relation of a program. Fig. 10 shows an exampleillustrating the encoding. An auxiliary variable pcis required
to indicate the program counter (line number). For example,if the next statement to be executed is x=x+1 , that is,
pc=5, then the statement is encoded as t
3in Fig. 10. The
overall transition relatioin would be T:t1∨t2∨t3∨t4∨t5. The
initial condition would be I:x=0∧y=0∧pc=4, and the
assertion checking problem becomes the reachability problemof the formula: pc=9∧y/negationslash= 100. We have implemented the
ITP approach in our FiB tool for exeperiments. Both ITP andour approach use MathSAT as their satisﬁable checking andinterpolation engine with the same conﬁguration.
HOLA was already compared with BLAST, InvGen, and
Interproc in [20] through a set of benchmarks collectedfrom other loop invariant generation papers [10], [29], [8],[36], [27], InvGen test suite [5], NECLA veriﬁcation bench-marks [4], and the HOLA test suite [20]. Considering thatthe set of benchmarks is rather comprehensive, we adoptedthe same set for evaluation. All the details of benchmarksand tools are collected and can be found in [2]. Out of theoriginal46benchmarks, we ﬁltered out those with assertions
(postconditions) inside the loops and selected the 41bench-
marks for evaluation. Each benchmark has at least one loopand at least one assertion, and some benchmarks have nestedloops or sequence of loops. If the benchmark has nested orsequence loops, it is manually translated into a single loopusing the translation mentioned in Section IV-C. Table I showsthe experimental results that are obtained on a machine, with
an Intel Xeon 3.5GHz CPU and 16GB memory, running the
64-bit Ubuntu version 16.04.
799
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:03 UTC from IEEE Xplore.  Restrictions apply. TABLE I
EXPERIMENTAL RESULTS
No. LoC BLAST InvGen Interproc CPAchecker ITP HOLA FiB-F FiB-B FiB-Bi
Time Time Time Time Time Time Time Time Time(sec) (sec) (sec) (sec) (sec) (sec) (sec) (sec) (sec)
1 21 0.28  0.27  0.04  0.79  1.84  0.04  0.48  0.05  0.11
2 260.13 0.17 0.10  1.21  14.05  0.31  0.32  0.19  0.26
4 21 3.72 0.23 0.03  0.74  0.21  0.02  0.01  0.01  0.01
5 27 /clock 0.31  0.13 /clock 16.54  0.04  0.17  0.04  0.95
6 280.14 0.15  0.09 /clock /clock 0.20  0.18  0.26  0.31
7 27 11.5  0.56  0.08  1.07  16.22  0.62  0.01  0.02  0.03
8 30 2.61  0.44 0.07  1.16 /clock 0.38  0.01  0.01  0.01
9 49 /clock0.17  0.08 /clock 0.20  0.08  0.03  0.02  0.02
10 30 1.27 0.20 0.07  0.86  4.53  0.13  0.03  0.01  0.02
11 24 /clock 0.36  0.02 /clock 0.35  0.13  0.01  0.01  0.01
12 34 /clock0.25 0.12 /clock /clock 3.13  1.93  1.69  2.01
13 25 0.76 0.44  0.04  0.87  0.94  0.38  0.01  0.01  0.03
14 26 5.30  0.58  0.03  1.10  5.67  1.07  0.01  0.01  0.03
15 28 0.78  0.28  0.02  0.91  0.63 11.7  0.01  0.01  0.01
16 231.69  0.38  0.02  0.89  0.03  0.12  0.01  0.01  0.01
17 22 1.14 0.20  0.08  0.89 /clock 0.09  0.15  0.33  0.19
18 24 /clock 7.26 0.03 /clock 0.60  2.75  0.02  0.01  0.02
19 24 3.74 0.39 0.03  1.31  30.09 14.7  0.04  0.02  0.04
20 33 5.02  0.74 0.07  1.05  5.73  2.56  0.02  0.02  0.05
21 391.84 0.14  0.09  0.96 /clock 0.59 /clock 0.13 /clock
22 260.15 0.16 0.03  1.20  21.88  0.26  0.14  0.14  0.18
23 20 /clock 0.38 0.05 /clock 1.60  0.05  1.74  0.02  0.01
25 33 1.33 0.20 0.05  0.86 /clock 0.04  0.09  0.05  0.06
26 240.12 0.18 0.09 /clock /clock 0.31  0.80  0.49  0.81
28 250.94  0.43  0.02 /clock 0.26  0.06  0.01  0.01  0.01
29 320.09 0.17 0.14  0.86  7.41  0.31  0.05  0.02  0.02
30 22 0.70  0.40 0.01 /clock 2.92  0.03  0.32  0.01  0.16
32 24 /clock0.18 0.05 /clock169.97  0.65  0.13  0.08  0.18
33 361.72 0.17 0.12  1.12  48.32  0.09  0.09  0.05  0.10
34 234.12 0.19 0.03  1.75 /clock /clock 0.73  0.33  0.91
35 17 0.39 0.43 0.02  0.90  0.06  0.12  0.01  0.01  0.01
36 713.21 0.24 0.60  54.31 /clock 0.89 /clock 0.23  0.46
37 21 2.01  0.42 0.03  0.80  1.47  0.41  0.01  0.01  0.01
38 200.29 0.21 0.05  0.99  11.78  0.27  0.02  0.04  0.05
40 303.97 0.17 0.11  5.76 /clock 0.80  0.04  0.06  0.06
41 250.01  0.38 0.04  1.03  3.84  0.43  0.21  0.03  0.15
42 370.06 0.15  0.06  65.52  16.37  0.51  0.06  0.10  0.08
43 27 0.17 0.14  0.05  0.72  0.07  0.07  0.01  0.01  0.01
44 35 1.33 0.44 0.05  0.88  0.48  1.27  0.04  0.01  0.01
45 440.55 0.20 0.58 /clock /clock 0.60  0.06  0.11  0.08
46 240.23 0.21 0.04  0.88  10.62  0.19  0.02  0.02  0.04
Each benchmark number in the ﬁrst column of Table I cor-
responds to that in [20], and all the assertions in benchmarks
are satisﬁed. For each tool, the symbol indicates that the
tool is able to verify all assertions in the benchmark, while thesymbol indicates that the tool is not able to infer the loop
invariants to verify the assertions, or the veriﬁcation result iswrong. The columns labeled “Time” indicate the executiontime (in seconds) to generate loop invariants for verifyingthe assertions. The symbol /clockindicates that the tool did not
terminate in 200 seconds. We mark the least execution time
of correct veriﬁcation in gray color for each benchmark.
As Table I shows, the proposed approaches are very ef-
fective to construct loop invariants to prove the assertionswithin2seconds for each benchmark, especially the backward
interpolation approach (FiB-B). The forward interpolation ap-proach (FiB-F) and the bidirectional approach (FiB-Bi) failed
to prove the assertion in benchmark 21within200 seconds.
Among the other six tools, HOLA performs the best, whichonly failed to verify three benchmarks (wrong veriﬁcation
results in no. 15and no.19, and timeout in no. 34). Generally,
we found that the backward interpolation approach (F iB-B)
outperforms the forward approach (FiB-F) and bidirectional
approach (FiB-Bi), especially for benchmarks 5,21,23,
and41.
Table II shows the statistics of our three approaches in-
cluding the number of forward iterations (f), the number offorward backtracks (fb), the number of backward iterations(b), the number of backward backtracks (bb), whether theinvariant is obtained based on abstract interpolants or concretestates (a/c), and whether the obtained invariant is disjunctive(∨?). The size of the obtained invariant refers to the number of
nodes in its syntax tree, e.g. the size of (x=y)is three. If the
benchmark has more than one assertion to be checked, we listthe average size of the invariant for all the assertions. We also
show the size of the ﬁxpoints found by the ITP approach. SinceITP aims to ﬁnd a ﬁxpoint instead of an inductive invariant, we
800
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:03 UTC from IEEE Xplore.  Restrictions apply. TABLE II
EXPERIMENT STATISTICS
No. ITP FiB-F FiB-B FiB-Bi
abortk size f fb b a/c size ∨? f b bb a/c size ∨? f fb b bb a/c size ∨?
1 29 3 ,842 211 c 2no 110 a 13 yes 2121 c 18 no
2 31 8 2 ,914 422 c135 no 220 a193 yes 4242 c150 no
4 1 8 279 101 a 20 yes 000 c 7yes 0000 c 7yes
5 43 9 1 8 ,914 1 266 c 82 yes 220 a 43 yes 22 11 22 11 c450 no
6 –– – 211 c 85 yes 110 a 62 yes 2121 c 62 yes
7 42 8 2 5 ,522 211 c 30 yes 110 a 25 no 2121 c 63 no
8 –– – 000 c 13 yes 000 c 8yes 0000 c 8yes
9 0 4 140 000 c 3no 000 c 4no 0000 c 4no
10 31 8 1 3 ,454 211 c 16 yes 110 a 22 no 2121 c 22 no
11 2 9 426 211 c 30 yes 110 a 20 no 2121 c 23 no
12 –– – 844 c529 yes 440 a408 yes 8484 c221 no
13 31 3 1 ,982 211 c 27 yes 110 a 25 yes 2121 c 33 no
14 32 4 5 ,703 422 c 35 yes 110 a 18 no 4242 c 20 no
15 2 12 747 633 c 16 yes 220 a 16 no 4242 c 18 no
16 0 4 105 000 c 18 yes 000 c 20 yes 0000 c 20 yes
17 –– – 633 c115 yes 91 0 1 a475 yes 6363 c115 no
18 2 12 770 211 c 28 yes 110 a 30 no 2121 c 28 no
19 44 8 3 7 ,318 422 c 29 yes 220 a 56 yes 4242 c 64 yes
20 21 4 4 ,225 000 c 10 yes 000 c 10 yes 0000 c 10 yes
21 –– – ––– – – – 220 a 53 yes ––––– – –
22 21 7 1 ,445 422 c 58 yes 220 a 38 yes 4242 c 43 yes
23 31 9 2 ,911 77 37 40 c345 no 110 a 11 no 6363 c 36 yes
25 –– – 211 c 29 yes 110 a 14 no 2121 c 29 yes
26 –– – 211 c157 no 110 a209 yes 2121 c143 no
28 2 9 266 000 c 3no 000 c 3no 0000 c 3no
29 21 0 1 8 ,095 000 c 14 no 000 c 15 no 0000 c 15 no
30 43 5 1 ,775 32 16 16 c208 no 110 a 11 no 22 11 22 11 c 28 no
32 44 2 2 7 ,060 633 c104 yes 330 a126 no 6363 c 81 no
33 21 81 3 8 ,121 211 c 69 yes 110 a 39 no 2121 c 79 no
34 –– – 20 7 13 a406 no 16 20 4 a242 yes 28 11 28 11 c182 no
35 0 4 104 000 c 8yes 000 c 8no 0000 c 8no
36 –– – ––– – – – 110 a 85 no 2121 c 85 no
37 21 5 3 ,673 000 c 14 yes 000 c 20 yes 0000 c 20 yes
38 32 7 1 3 ,414 211 c 40 yes 110 a 45 no 2121 c 42 no
40 –– – 000 c 17 yes 000 c 16 yes 0000 c 16 yes
41 53 4 3 ,257 26 12 14 c508 yes 110 a 12 no 16 8 16 8 c236 yes
42 31 8 2 9 ,392 211 c 74 yes 110 a 55 no 2121 c 72 yes
43 0 4 184 000 c 8yes 000 c 8no 0000 c 8no
44 2 11 747 808 a 34 yes 000 c 9yes 0000 c 9yes
45 –– – 000 c 17 yes 000 c 13 yes 0000 c 13 yes
46 22 1 2 0 ,207 211 c 20 yes 110 a 18 no 2121 c 18 no
can observe that the size of a ﬁxpoint is usually much larger
than that of an inductive invariant. More discussions about whyour approach outperforms ITP can be found in Section VI.
We can also observe that the backward (FiB-B) approach
has zero backtracks except benchmarks no. 17and34, which
explains why it performs the best among the proposed three
approaches. After our investigation based on the statisticsgiven in Table II, we summarize the reasons why FiB-B is the
best: (1) The assertion (postcondition) to be proved is usuallymore symbolic (abstract), e.g., x>0, than the precondition
of the loop (e.g., x=0∧y=0). Thus, the interpolant
for the backward reachability would converge to be inductive
more easily. (2) For the assignment statement, the weakestprecondition (wp) calculation is faster than the strongest
postcondition (sp) calculation because wpdoes not require
quantiﬁer elimination (except the nondeterminism assignmentstatement), but spdoes. (3) Considering the assertion of a
loop is usually more symbolic than its precondition, after thesame number of iterations, the backward analysis based onwpprovides more general information than forward analysis
based on sp. Thus, the interpolant for the backward direction
would be more close to an inductive invariant, which canbe conﬁrmed in the a/c column in Table II by the fact thatFiB-B often obtains an inductive invariant based on abstractinterpolants from previous iterations. That is why F iB-B has
much less backward backtracks than FiB-F.
VI. R
ELATED WORKS AND DISCUSSIONS
Automatic loop invariant generation is a fundamental pro-
blem in program analysis and veriﬁcation. Theoretically, it is
an undecidable problem. To tackle this problem in practice,
both static and dynamic analysis based techniques have beenproposed. Static analysis based techniques can be furtherclassiﬁed to the following categories based on the underlyingtechniques that are used: abstract interpretation [17], [44], [16],[37], [38], SMT solving based techniques such as counte-
rexample guided abstraction reﬁnement (CEGAR) [33], [7],[13], constraint-based methods [31], [15], [30], Craig interpo-
801
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:03 UTC from IEEE Xplore.  Restrictions apply. lation [43], [32], [41], [42], [40], abduction [45], [11], [26],
[28], [12], [20], learning-based approach [39], and algebraicapproaches [47], [46], [48]. Dynamic analysis based techni-ques include guess-and-check techniques [22], [21], [49], [50],[51] and learning-based techniques [24], [25]. Our approachbelongs to the static analysis category.
The very related work to ours is ITP [41], in which a
transition system (I,T), whereIis the initial condition and
Tis the transition relation, as well as a safety property ϕ
are considered. Given a value k, their approach constructs a
BMC formula in k+1steps:I∧T∧T
k∧¬ϕ, and obtains an
interpolant IforI∧Twith respect to Tk∧¬ϕ. That is, Iis
an over-approximation of states that can be reachable within
one step and not going to violate ϕwithinksteps. Then, I
is considered in the formula: I∧T∧Tk∧¬ϕ.I fi ti sn o t
satisﬁable, an interpolant I/primeforI∧Twith respect to Tk∧¬ϕ
is an over-approximation of state that can be reachable in two
steps and not going to violate ϕwithinksteps. However, if
the formula is satisﬁable, then nothing can be concluded, and
the algorithm aborts. The value of kneeds to be increased by
a certain value, and the same process is repeated until a realcounterexample is found or the obtained interpolant reaches aﬁx-point. If ITP advances tsteps and then aborts, we increase
kbytin the next iteration. Table II shows the number of aborts
and the sufﬁcient value of kto have a conclusive result. In our
experiments, we start with k=4, which is small but sufﬁcient
to ﬁnd ﬁx-points, e.g., benchmark no. 9,16,35, and43.
Our approach is different from ITP in several aspects. We
list the differences and try to analyze why our approachoutperforms ITP in the followings:
•Our approach obtains the concrete forward/backward
reachability and tries to squeeze out an inductive inva-riant based on the interpolation in between; ITP over-approximates the set of reachable states for each step
with ak-lookhead to see if a ﬁxpoint can be quickly
reached based on the abstraction. If our approach fails toﬁnd an inductive invariant in one iteration, we only haveto advance one further step from the current reachabilityfor the next iteration because the reachability is concreteand can be accumulated. However, if ITP fails to ﬁnd aﬁxpoint in one iteration, it has to be restarted from scratchwith a new klarger than the previous one, whose value
is tricky to decide because if the increment of kis too
small, many restarts may be required; if the increment istoo big, the satisﬁability checking problem may becomedifﬁcult to solve.
•Our approach handles program statements compositio-nally. As we know, quantiﬁer elimination is computa-
tionally expensive [41]. However, in our approach, we
process one program statement at a time; thus, only onequantiﬁed variable has to be eliminated at a time. In addi-tion, only assignment statements require quantiﬁer elimi-nation. Thus, quantiﬁer elimination is not a performancebottleneck in our approach, which is also conﬁrmed in our
experiments. On the contrary, the ITP approach considersthe global transition relation of all program statements.If there are nvariables in the program, the k-step BMC
problem consists of k×nvariables. If the value of k
is large, solving the BMC formula takes longer time, asevidenced by benchmark no. 19and32. Furthermore, if
the transition relation of a program is lengthy, the BMC
problem also becomes difﬁcult to solve.
Another closely related work is DAR [52], which also
considers a transition system (I,T)and a safety property ϕ.
Their approach obtains two interpolation sequences: (1) Theforward interpolation sequence /angbracketleft(F
0=I),F1,F2,...,F k/angbracketright
satisfying Fi∧T=⇒Fi+1for0≤i<k andFi=⇒ϕ
for0≤i≤k. (2) The backward interpolation sequence
/angbracketleft(B0=¬ϕ),B1,B2,...,B k/angbracketrightsatisfying Bi∧T=⇒Bi+1
for0<i≤kandBi=⇒¬Ifor0≤i≤k. The two inter-
polation sequences are strengthened or extended by the localand global strengthening procedures until a counterexample is
found or either interpolation sequence reaches a ﬁx-point.
Our approach is different from DAR in several aspects. We
list the differences as follows:
•Our approach handles program statements compositio-
nally, while the DAR approach, similar to ITP, considersthe global transition relation.
•What DAR maintains are sequences of abstractions (inter-polants). Once each interpolation sequence is changed orextended, some subsequent process has to be performedso that the properties mentioned above are still valid.What our approach maintains are concrete forward andbackward reachable states step by step, whose validity isnot changed. They can be accumulated for the followingiterations without any recalculations.
We have tried to obtain the DAR tool on internet for evalua-
tion, but failed. According to the experimental results reportedin [52], the performance of DAR and ITP are evenly balanced.We are interested in implementing the DAR approach byourselves in the future for evaluation.
VII. C
ONCLUSION AND FUTURE WORK
In this work, we propose an novel approach to automa-
tically constructing inductive loop invariants, which solvesthe fundamental problem in program analysis and veriﬁcation.
Our approach squeezes an inductive invariant based on Craig
interpolants between forward and backward predicate trans-formers. In the future, we would like to investigate the qualityof interpolants.
A
CKNOWLEDGMENT
This research is mainly supported by the startup grant
M4081588.020.500000 of School of Computer Science andEngineering in Nanyang Technological University and parti-ally supported by the National Research Foundation, PrimeMinisters Ofﬁce, Singapore under its National CybersecurityR&D Program (Award No. NRF2014NCR-NCR001-30) andadministered by the National Cybersecurity R&D Directorate.
802
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:03 UTC from IEEE Xplore.  Restrictions apply. REFERENCES
[1] http://mathsat.fbk.eu/.
[2] https://github.com/spencerxiao/ase2017-results-and-tools.
[3] https://z3.codeplex.com/.
[4] http://www.nec-labs.com/research/system/systems SA V-
website/benchmarks.php.
[5] http://www.tcs.tifr.res.in/ ˜agupta/invgen/.
[6] A. Albarghouthi and K. L. McMillan. Beautiful interpolants. In CA V,
volume 8044 of LNCS, pages 313–329, 2013.
[7] T. Ball and S. Rajamani. The SLAM toolkit. In CA V, volume 2102 of
LNCS, pages 260–264, 2001.
[8] D. Beyer, T. A. Henzinger, R. Majumdar, and A. Rybalchenko. Path
invariants. In PLDI, volume 42, pages 300–309, 2007.
[9] D. Beyer and M. E. Keremoglu. CPAchecker: A tool for conﬁgurable
software veriﬁcation. In CA V, pages 184–190, 2011.
[10] A. Bradley. Understanding IC3. In Theory and Applications of
Satisﬁability T esting, volume 7317 of LNCS, pages 1–14, 2012.
[11] C. Calcagno, D. Distefano, P. O’Hearn, and H. Yang. Compositional
shape analysis by means of bi-abduction. In POPL, pages 289–300,
2009.
[12] C. Calcagno, D. Distefano, and V . Vafeiadis. Bi-abductive resource
invariant synthesis. In Programming Languages and Systems (APLAS),
volume 5904 of LNCS, pages 259–274, 2009.
[13] E. Clarke, O. Grumberg, S. Jha, Y . Lu, and H. Veith. Counterexample-
guided abstraction reﬁnement for symbolic model checking. Journal of
the ACM, 50(5):752–794, 2003.
[14] E. M. Clarke, O. Grumberg, and D. A. Peled. Model Checking. MIT
Press, 1999.
[15] M. Col ´on, S. Sankaranarayanan, and H. Sipma. Linear invariant
generation using non-linear constraint solving. In CA V, volume 2725
ofLNCS, pages 420–432, 2003.
[16] P. Cousot and R. Cousot. Systematic design of program analysis
frameworks. In POPL, pages 269–282, 1979.
[17] P. Cousot and N. Halbwachs. Automatic discovery of linear restraints
among variables of a program. In POPL, pages 84–96, 1978.
[18] W. Craig. Three uses of the herbrand-gentzen theorem in relating model
theory and proof theory. The Journal of Symbolic Logic, 22(3):269–285,
1957.
[19] E. W. Dijkstra and C. S. Scholten. Predicate calculus and program
semantics. T exts and Monographs in Computer Science, 1990.
[20] I. Dillig, T. Dillig, B. Li, and K. McMillan. Inductive invariant
generation via abductive inference. In OOPSLA, volume 48, pages 443–
456, 2013.
[21] M. Ernst, J. Perkins, P. Guo, S. McCamant, C. Pacheco, M. Tschantz,
and C. Xiao. The Daikon system for dynamic detection of likelyinvariants. Science of Computer Programming, 69(1–3):35–45, 2007.
[22] C. Flanagan and K. Leino. Houdini, an annotation assistant for
ESC/Java. In International Symposium of F ormal Methods Europe
on F ormal Methods for Increasing Software Productivity (FME), pages
500–517, 2001.
[23] R. W. Floyd. Assigning meanings to programs. In Applied Math, volume
XIX, pages 19–32, 1967.
[24] P. Garg, C. L ¨oding, P. Madhusudan, and D. Neider. Ice: A robust
framework for learning invariants. In CA V,
pages 69–87, 2014.
[25] P. Garg, D. Neider, P. Madhusudan, and D. Roth. Learning invariants
using decision trees and implication counterexamples. In POPL,
volume 51, pages 499–512, 2016.
[26] R. Giacobazzi. Abductive analysis of modular logic programs. In
International Symposium on Logic Programming, pages 377–391, 1994.
[27] B. Gulavani and S. Rajamani. Counterexample driven reﬁnement for
abstract interpretation. In TACAS, pages 474–488, 2006.[28] S. Gulwani, B. McCloskey, and A. Tiwari. Lifting abstract interpreters
to quantiﬁed logical domains. In POPL, pages 235–246, 2008.
[29] S. Gulwani, S. Srivastava, and R. Venkatesan. Program analysis as
constraint solving. In PLDI, volume 43, pages 281–292, 2008.
[30] S. Gulwani, S. Srivastava, and R. Venkatesan. Constraint-based invariant
inference over predicate abstraction. In V eriﬁcation, Model Checking,
and Abstract Interpretation, volume 5403 of LNCS, pages 120–135,
2009.
[31] A. Gupta and A. Rybalchenko. InvGen: An efﬁcient invariant generator.
InCA V, volume 5643 of LNCS, pages 634–640, 2009.
[32] T. Henzinger, R. Jhala, R. Majumdar, and K. McMillan. Abstractions
from proofs. In POPL, pages 232–244, 2004.
[33] T. A. Henzinger, R. Jhala, R. Majumdar, and G. Sutre. Software veri-
ﬁcation with BLAST. In International Conference on Model Checking
Software (SPIN), volume 5403 of LNCS, pages 235–239, 2003.
[34] C. A. R. Hoare. An axiomatic basis for computer programming.
Communications of the ACM, 12(10):576–580, 1969.
[35] B. Jeannet. Interproc analyzer for recursive programs with numerical
variables.
[36] R. Jhala and K. McMillan. A practical and complete approach to
predicate reﬁnement. In TACAS, pages 459–473, 2006.
[37] M. Karr. Afﬁne relationships among variables of a program. Acta
Informatica, 6(2):133–151, 1976.
[38] V . Laviron and F. Logozzo. Subpolyhedra: A (more) scalable approach
to infer linear inequalities. In V eriﬁcation, Model Checking, and Abstract
Interpretation, volume 5403 of LNCS, pages 229–244, 2009.
[39] W. Lee, Y . Jung, B.-Y . Wang, and K. Yi. Predicate generation for
learning-based quantiﬁer-free loop invariant inference. Logical Methods
in Computer Science, 8(3):1–21, 2012.
[40] S.-W. Lin, J. Sun, T. K. Nguyen, Y . Liu, and J. S. Dong. Interpolation
guided compositional veriﬁcation. In ASE, pages 65–74, 2015.
[41] K. McMillan. Interpolation and SAT-based model checking. In CA V,
volume 2725 of LNCS, pages 1–13, 2003.
[42] K. McMillan. Lazy abstraction with interpolants. In CA V, volume 4144
ofLNCS, pages 123–136, 2006.
[43] K. McMillan. Lazy annotation for program testing and veriﬁcation. In
CA V, volume 6174 of LNCS, pages 104–118, 2010.
[44] A. Min ´e. The octagon abstract domain. Higher-Order and Symbolic
Computation, 19(1):31–100, 2006.
[45] C. Peirce. Collected Papers of Charles Sanders Peirce . Belknap Press,
1932.
[46]
R. Rebiha, A. V . Moura, and N. Matringe. Generating invariants for non-
linear loops by linear algebraic methods. F ormal Aspects of Computing,
27(5):805–829, 2015.
[47] E. Rodr ´ıguez-Carbonell and D. Kapur. Automatic generation of polyno-
mial invariants of bounded degree using abstract interpretation. Science
of Computer Programming, 64(1):54–75, 2007.
[48] S. Sankaranarayanan, H. B. Sipma, and Z. Manna. Non-linear loop
invariant generation using gr ¨obner bases. In POPL, pages 318–329,
2004.
[49] R. Sharma and A. Aiken. From invariant checking to invariant inference
using randomized search. In CA V, volume 8559 of LNCS, pages 88–105,
2014.
[50] R. Sharma, S. Gupta, B. Hariharan, A. Aiken, P. Liang, and A. V . Nori.
A data driven approach for algebraic loop invariants. In Programming
Languages and Systems, volume 7792 of LNCS, pages 574–592, 2013.
[51] R. Sharma, S. Gupta, B. Hariharan, A. Aiken, and A. V . Nori. Veriﬁ-
cation as learning geometric concepts. In Static Analysis, volume 7935
ofLNCS, pages 388–411, 2013.
[52] Y . Vizel, O. Grumberg, and S. Shoham. Intertwined forward-backward
reachability analysis using interpolants. In TACAS, pages 308–323, 2013.
[53] G. Winskel. The F ormal Semantics of Programming Languages: An
Introduction. MIT Press, 1993.
803
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:03 UTC from IEEE Xplore.  Restrictions apply. 