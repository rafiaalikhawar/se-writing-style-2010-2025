EfÔ¨Åcient and Reasonable Object-Oriented Concurrency
Scott West
Google Inc., Switzerland
scottgw@google.comSebastian Nanz Bertrand Meyer
Department of Computer Science
ETH Z√ºrich, Switzerland
Ô¨Årstname.lastname@inf.ethz.ch
ABSTRACT
Making threaded programs safe and easy to reason about
is one of the chief diculties in modern programming. This
work provides an ecient execution model for SCOOP, a con-
currency approach that provides not only data-race freedom
but also pre/postcondition reasoning guarantees between
threads. The extensions we propose inuence both the under-
lying semantics to increase the amount of concurrent execu-
tion that is possible, exclude certain classes of deadlocks, and
enable greater performance. These extensions are used as
the basis of an ecient runtime and optimization pass that
improve performance 15 over a baseline implementation.
This new implementation of SCOOP is, on average, also 2 
faster than other well-known safe concurrent languages. The
measurements are based on both coordination-intensive and
data-manipulation-intensive benchmarks designed to oer a
mixture of workloads.
Categories and Subject Descriptors
D.3.3 [ Programming Languages ]: Language Constructs
and Features| Concurrent programming structures ; D.3.4
[Programming Languages ]: Processors| Code generation,
Optimization, Run-time environments
Keywords
Concurrency, object-oriented, performance, optimization
1. INTRODUCTION
Programming languages and libraries that help program-
mers write concurrent programs are the subject of intensive
research. Increasingly, special attention is paid to develop-
ing approaches that provide certain execution guarantees;
they support the programmer in avoiding delicate concur-
rency errors such as data races or deadlocks. For example,
All research was done while employed at ETH Z urich; opin-
ions in this paper do not necessarily reect those of Google
Inc.languages such as Erlang [1] and others based on the Ac-
tor model [12] avoid data races by a pure message-passing
approach; languages such as Haskell [21] are based on Soft-
ware Transactional Memory [24], avoiding some of the pitfalls
associated with traditional locks.
Providing these guarantees can, however, be at odds with at-
taining good performance. Pure message-passing approaches
face the diculty of how to transfer data eciently between
actors; and optimistic approaches to shared memory access,
such as transactional memory, have to deal with recording,
committing, and rolling back changes to memory. For this
reason, execution strategies have to be developed that pre-
serve the performance of the language while maintaining the
strong execution guarantees of the model.
This work focuses on SCOOP [20], an object-oriented ap-
proach to concurrency that aims to make concurrent pro-
gramming simpler by providing higher-level primitives that
are more amenable to standard programming techniques,
such as pre/postcondition reasoning. To achieve this goal,
SCOOP places restrictions on the way concurrent programs
execute, thereby gaining more reasoning capabilities but also
introducing performance bottlenecks. To improve the perfor-
mance of SCOOP programs while maintaining the core of the
execution guarantees, this paper introduces a new execution
model called SCOOP/Qs1. We rst give a formulation of the
SCOOP semantics which admits more concurrent behaviour
than the existing formalizations [18], while still providing the
reasoning guarantees. On this basis, lower-level implementa-
tion techniques are developed to make the scheduling and
interactions between threads ecient. These techniques are
applied in an advanced prototype implementation [22].
The design and implementation choices are evaluated on
a benchmark suite that includes computation-intensive and
coordination-intensive workloads, showing the advantages of
the SCOOP/Qs execution strategies. The overall performance
is compared to a broad variety of other paradigms for parallel
and concurrent programming { C++/TBB, Go, Haskell, and
Erlang { demonstrating SCOOP's competitiveness.
The remainder of this paper is structured as follows. Sec-
tion 2 introduces SCOOP and formally species executions.
Section 3 describes the implementation techniques for this
model. Section 4 evaluates the eectiveness of the dierent op-
timizations. Section 5 compares SCOOP/Qs against a variety
of other paradigms. An analysis of related work is performed
in Section 6, and conclusions are drawn in Section 7.
1Qs is pronounced \queues", as queues feature prominently
in our new approach; the runtime and compiler associated
with Qs is called Quicksilver, available from [22].arXiv:1405.7153v2  [cs.DC]  27 Jul 20152. EXECUTION MODEL
The key motivation behind SCOOP [20] is providing a
concurrent programming model that allows the same kinds of
reasoning techniques that sequential models enjoy. In partic-
ular, SCOOP aims to provide areas of code where pre/post-
condition reasoning exists between independent threads. To
do this, SCOOP allows one to mark sections of code where,
although threads are operating concurrently, data races are
excluded entirely.
2.1 A Brief Overview
In Fig. 1 one can see two programs that are running in
parallel. Supposing that xis the same object in each thread,
separate x
do
x.foo()
a := long _comp()
x.bar()
end
Thread 1separate x
do
x.bar()
b := short _comp()
c := x.baz()
end
Thread 2
Figure 1: A simple SCOOP program
there are only two possible interleavings:
x.foo(), x.bar(), x.bar(), x.baz() or
x.bar(), x.baz(), x.foo(), x.bar()
However, in contrast to synchronized blocks in Java, these
separate blocks not only protect access to shared memory,
but also initiate concurrent actions: for both threads, the
calls on xare performed asynchronously, thus for Thread 1,
x.foo() can execute in parallel with long _comp() . However,
itcannot be executed in parallel with x.bar() as they have
the same target, x. SCOOP has another basic operation, the
query, that provides synchronous calls. It is so called because
the sender expects an answer from the other thread; this is
the case with the c := x.baz() operation, where Thread 2
waits for x.baz() to complete before storing the result in c.
The SCOOP model associates every object with a thread
of execution, its handler . There can be many objects asso-
ciated to a single handler, but every object has exactly one
handler. In Fig. 1, xhas a handler that takes requests from
Threads 1 and 2. The threads that wish to send requests to
xmust register this desire, which is expressed in the code by
separate x.The threads are deregistered at the end of the
separate block.
This model is similar to other message passing models, such
as the Actor model [12]. What distinguishes SCOOP from
languages like Erlang [1] is that the threads have more control
over the order in which the receiver will process the messages.
When multiple processes each send multiple messages to a
single receiver in Erlang, the sending processes do not know
the order of processing of their messages (as they may be
interleaved with messages from other processes). In SCOOP,
since each thread registers with the receiver, the messages
from a single separate block to its handler will be processed
in order, without any interleaving.
This ordering gives the programmer the ability to reason
about concurrent programs in a sequential way within the
separate blocks. To be precise, pre/postcondition reasoning
can be applied to a separate object protected by a separate
block, even though the actions are being executed in parallel.
Aseparate object is marked as such by the type system,
h
c0
c1
 c2
 c3
Figure 2: Normal handler implementation
and methods may only be called on a separate object if it is
protected by a separate block. Maintaining reasoning among
multiple independent separate objects is also possible, but
requires all separate objects concerned be protected by the
same separate block.
The original SCOOP operational semantics [20] mandated
the use of a lock to ensure that pre/postcondition reasoning
could be applied by a client on its calls to a handler. One
can visualize this as the client c0placing the calls in a queue
for the handler hto dequeue and process, as in Fig. 2. The
other clients ( c1; c2; c3) that may want to access the handler's
queue must wait until the current client is nished.
2.2 Reasoning Guarantees
There are a few key reasoning guarantees that an imple-
mentation of SCOOP must provide:
1.Regular (non- separate ) calls and primitive instructions
(assignment, etc.) execute immediately and are syn-
chronous.
2.Calls to another handler, h, on which object xresides,
within the body of a separate xblock will be executed
in the order they are logged, and there will be no inter-
vening calls logged from other clients.
The eect of rule 1 is that normal sequential reasoning is
applied to calls that are issued by the client, to the client.
Rule 2 implies that calls that are made from the client to
the handler are applied in order, thus the client can apply
pre-/postcondition reasoning from one call it has made to
the next.
2.3 The SCOOP/Qs Execution Model
The rst SCOOP guarantee is easy to achieve, it is simply
how sequential programs operate. To understand how to
implement SCOOP eciently, it is important to concentrate
on the the second guarantee. This guarantee states that the
requests from a particular client are processed by the handler
in the order they are sent, disallowing interleaving requests
from other clients. To prevent clients from interfering with
one another on a particular handler can be achieved by giving
each client their own private area (a queue) in which to place
their requests. Each client then just shares this private queue
with the handler to which it wants to send requests.
Syntax.
The following syntax of statements sis used to describe
the execution model.
s::= separate x sjcall(x; f)jquery (x; f)j
waithjrelease hjendjskip
Note that separate blocks and call and query requests
model instructions of SCOOP programs, whereas the state-
ments wait,release ,end, and skipare only used to model theseparate
(h; qh;separate x s)jj(x; qx; t))
(h; qh; s;call(x;end))jj(x; qx+ [h7![]]; t)call
(h; qh;call(x; f))jj(x; qx; t))
(h; qh;skip) jj(x; qx[h7!qx[h] + [f]]; t)
query
(h; qh;query (x; f))jj(x; qx; t))
(h; qh;waitx) jj(x; qx[h7!qx[h] + [f;release h]]; t)sync
(h; qh;waitx)jj(x; qx;release h))
(h; qh;skip)jj(x; qx;skip)
run
(h;[x7![s] +ss] +ys;skip))
(h;[x7!ss] +ys; s)end
(h;[x7![]] + ys;end))
(h;ys;skip)seq(h;xs;s1)) 
h;xs;s0
1
(h;xs;s1;s2)) 
h;xs;s0
1;s2
seqSkip(h; xs; skip;s2))(h; xs; s2)parStepQ)Q0
PjjQ)PjjQ0
oneStepP)Q
P)QmanyStepP)P0P0)Q
P)Q
Figure 3: Inference rules of SCOOP/Qs
runtime behaviour. In particular, statements waitandrelease
describe the synchronization to wait for the result after a
query , statement endmodels the end of a group of requests,
and skipmodels no behaviour.
Operational Semantics.
In Fig. 3, an operational semantics that conforms to the
SCOOP guarantees is given. It is described using inference
rules for transitions of the form P)Q, where PandQare
parallel compositions of handlers. The jjoperator is commu-
tative and associative to facilitate appropriate reordering of
handlers.
The basic representation of a handler is a triple (h; qh; s)
of its identity h, request queue qh, and the current program
it is executing, s. A request queue is a list of handler-tagged
private queues, and is thus really a queue-of-queues. Private
queues of a client handler ccan be looked-up qh[c], and can
be updated qh[c7!l], where lis the new list to associate
with the handler h. Both lookup and updating work on the
lastoccurrence of c, which is important as this is the one
that the client modies. The queue can also be decomposed
structurally, with [x7!s] +ysmeaning that the head of
the queue is from client xwith private queue s, and ysis
the rest of the structure (possibly empty). So although the
private queues in the queue-of-queues can be accessed and
modied in any order, they are inserted and removed in
rst-in-rst-out order.
We describe the unique operations of Fig. 3: separate
blocks (the rule separate ), the two dierent kinds of re-
quests ( call ,query ,sync rules), and how these requests
are processed by the handlers ( run andend rules). The
sequential and parallel composition rules are dened in the
standard way.
In the rule separate , clients insert their private queue at
the end of the handler's request queue. This operation occurs
at the beginning of a separate block. This registers them
with the handler, who will eventually process the requests.
The fact that a handler only processes one private queue at a
time ensures that the reasoning guarantees are maintained. It
is also a completely asynchronous operation, as the supplier's
handler-triple only consists of variables, i.e., there are no
restrictions on what state the supplier has to be in for this
rule to apply. Additionally, the client appends a call(x;end)
action before the end of the separate block to signal thatthe supplier xcan take requests from other clients.
The SCOOP/Qs semantics, in contrast to the original
lock-based SCOOP semantics, uses multiple queues that can
all be accessed and enqueued into simultaneously by clients.
This behaviour is visualized in Fig. 4, where the outer (gray)
c0
h
c1
 c2
Figure 4: Handler implementation based on queue of queues
boxes are nodes in the queue of queues, and the inner (green)
boxes are nodes in the private queues. This nested queueing
maintains the reasoning guarantees while still allowing all
clients to enqueue asynchronous calls without waiting.
In rule call , the call action is non-blocking: it asyn-
chronously appends the requested method fto the end of
the appropriate client's private queue.
Rule query , requesting a query execution, however, does
require blocking as it must wait for the result of the function
application. This is modeled by sending the query request
and introducing a pair of actions which can only step forward
together: the wait/release pair. There is only one rule ( sync )
that can rewrite these into skip, and it can only do so when
both processes are executing each of the pair.
Each handler processes its request queue in the following
way: in rule run, if the handler is idle (executing skip) then
it will examine the request queue. If the request queue's rst
entry (a private queue) is non-empty, then the rst action is
taken out of that private queue and placed in the program
part of the handler to execute. If the request queue is empty,
or it contains an empty private queue as its rst entry, then
the thread does nothing. In rule end, the thread nishes one
private queue and switches to the next when it encounters the
endstatement, which was placed by the owner of the outgoing
private queue when it nished executing its separate block
(rule separate ).
2.4 Multiple Handler Reservations
The separate block as shown so far only reserves a single
handler, and this block provides race-freedom guaranteesbetween a single client and a single handler. However, a client
may want to ensure consistency among multiple handlers or
objects. To provide guarantees about multiple handlers, a
multiple handler separate block must be used, as in Fig. 5.
In this example, this has the eect that, whenever a client
separate x y
do
x.set (Red)
y.set (Red)
end
(a) Thread 1separate x y
do
x.set (Blue)
y.set (Blue)
end
(b) Thread 2
Figure 5: Multiple reservations
reserves both xand y, the colours of each object will be
the same, either both red or both blue. When written in
this way and executed under either SCOOP or SCOOP/Qs,
any client that comes after the execution of Thread 1 or
Thread 2 (or both), and reserves xand ytogether will always
seex.colour = y.colour . If using nested reservation, this
may not be the case due to a possible race enqueueing the
private queue into the queue-of-queues.
The modication to the separate rule to support this is
straight-forward. First one denes an update function that
updates a handler if it is in the set X.
resOne( X; h; (x; qx; t)) =
(x; qx+ [h7![]]; t) if x2X
(x; qx; t) if x =2X
Then this is applied over the parallel composition of all
handlers.
resMany( X; h; PjjQ) = resMany( X; h; P )jj
resMany( X; h; Q )
resMany( X; h; (x; qx; t)) = resOne( X; h; (x; qx; t))
Lastly, a function describes that each handler in the set
(represented here by a list so it can be traversed) is sent an
endmessage.
endMany( x::xs) = call(x;end); endMany( xs)
endMany([]) = skip
These functions combine to dene a generalized separate
rule that can reserve multiple handlers atomically.
separateP0= resMany( X; h; P )
ends = endMany( X)
(h; qh;separate X s)jjP)
(h; qh; s; ends)jjP0
2.5 Deadlock
Under the original handler implementation of SCOOP, the
program in Fig. 6 will deadlock under some schedules. This
is due to the inconsistent locking order of xand y. However,
in the SCOOP/Qs execution model this example cannot
deadlock because there are no longer any blocking operations:
both clients can simultaneously reserve the handlers xand y,
and log asynchronous calls on them. Deadlock is still possible
in SCOOP/Qs, however one must also use queries (which
block) to achieve the same eect. If x.query and y.query
are added to the innermost separate blocks of Client 1 and
Client 2, respectively, the program may deadlock.separate x
do
separate y
do
x.foo()
y.bar()
end
end
Client 1separate y
do
separate x
do
x.foo()
y.bar()
end
end
Client 2
Figure 6: Possible deadlock situation
3. IMPLEMENTATION
The semantics described in Section 2 are used to implement
a compiler and runtime for SCOOP programs. The opera-
tional semantics gives rise to notable runtime performance
and implementation properties. We pay particular attention
to how to move the implementation from a synchronization-
heavy model to one which reduces the amount of blocking.
The runtime for SCOOP/Qs is written in C, the compiler
is written in Haskell and targets the LLVM framework [16] to
take advantage of the lower level optimizations that are avail-
able. Using LLVM is a necessary choice for this work because
it is important to compare with other more mature languages
and the comparison should not focus on obvious shortcomings,
such as a lack of standard optimizations. LLVM is also built
to be extended; this work extends LLVM by adding a custom
optimization pass. The SCOOP/Qs compiler, runtime, and
benchmarks are available from GitHub [22].
The runtime is broken into 3 layers: task switching, light-
weight threads, and handlers. Some of the optimizations
described in this section take place at the handler layer, but
there are also some that use the other two layers as well to
optimize scheduling.
3.1 Request Processing
Therun andendrules describe all of the queue manage-
ment facilities that a handler has to perform. This correspon-
dence is shown in the high-level implementation of the main
handler-loop given in Fig. 7.
// RUN rule, when there is a private queue
// available
while (qoq.dequeue (&private _queue))
{
// if dequeue returns true:
// RUN rule; process calls from
// this queue.
// otherwise:
// END rule; switch to the next
// private queue
while (private _queue.dequeue (&call))
{
execute _call (call);
}
}
Figure 7: Main handler-loop
The structure of the handler's loop directly corresponds to
the data structure implementation (a queue of queues). One
can see that private queues are continually taken from the
outer queue, where the dequeue operation returns a Boolean
result. False corresponds to no more work (indicating theprocessor can shut down), not that the queue is empty as
may be in a non-blocking queue implementation. For each
private queue that is received, calls are repeatedly dequeued
out of it and executed until false is returned from the dequeue
operation, indicating that the endrule has been triggered,
and the client presently does not wish to log more requests.
Note that the arrangement of clients and handlers follows a
particular pattern when the queue-of-queues pattern is used.
Namely, that each handler rst reserves a position in the
queue-of-queues: each queue-of-queues has many clients try-
ing to gain access, but only one handler removing the private
queues. This is a typical multiple-producer single-consumer
arrangement, so an ecient lock-free queue specialized for this
case can be used to implement the queue-of-queues. Similarly,
once the private queue has been dequeued by the handler
the communication is then single-producer single-consumer;
the client enqueues calls, the handler dequeues and executes
them. Again an ecient queue can be constructed to espe-
cially handle this case. These optimizations are important as
they are involved in all communication between clients and
handlers.
3.2 Client Requests
The handler-loop implementation, above, resides in the
runtime library. The client-side is where the compilation and
runtime system meet. In particular, the compiler emits the
code allowing the client to package and enqueue requests for
the handler, and handle waiting for the results of separate
queries.
private _queue *h_p = client.queue _for (h);
// SEPARATE rule, adding an empty queue
// to the queue of queues
h.qoq.enqueue (h _p);
<compiled body>
// SEPARATE rule, compiler adds the
// code to enqueue the END marker
h_p.enqueue (END);
Figure 8: A compiled separate block
When a client reserves a handler with separate hdo<
body> end, this corresponds to the code shown in Fig. 8. The
client receives a private queue h_pfor the desired handler
h, represented in the separate rule by the private queue
appearing on the handler's queue-of-queues. This private
queue can either be freshly created or taken from a cache of
queues, to improve execution speed. The client then enqueues
this new private queue on the queue-of-queues for the handler,
which means the private queue is now ready to log calls in
the body. Finally, corresponding to the end of the separate
block, the constant denoting the end of requests is placed in
the private queue, allowing the handler to move on to the
next client.
There will typically be calls to the handler in the body
of a separate block. The asynchronous calls are packaged
using the lib library [15], which abstracts away the details
of various calling conventions. This packaged call is then
put into the proper private queue for the desired handler.
This can be seen in Fig. 9, the enqueue operation relating
directly to the call rule. Packaging the call entails setting
up the call interface (cif) with the appropriate argument andarg_types[0] = &ffi _type _pointer;
arg_values[0] = &arg;
ffi_prep _cif(ffi _call, FFI _DEFAULT _ABI, 1,
&ffi _type _void, arg _types);
// CALL rule, showing the setup via libffi.
h_p.enqueue(call _new(ffi _call, 1, arg _values));
Figure 9: Enqueueing an asynchronous call
return types with ffi_prep _cif, and then storing the actual
arguments for later application by the handler. Note that
the allocation of arguments and argument types for the call
cannot be done on the client's stack because the call may be
processed by the handler after the client's stack frame has
been popped.
For eciency reasons, a dierent strategy is used for syn-
chronous calls (queries). This is because packaging a call
involves allocating memory, populating structures, and the
handler must later unpack it. In short: this takes longer than
a regular function call. In the asynchronous case these steps
are unavoidable because the execution of the call must be
done in parallel with the client's operations. However, for
synchronous calls this is not the case: the client will be wait-
ing for a reply from the supplier when the supplier nishes
executing the query. To make use of this optimization op-
portunity, for shared-memory systems, we can change the
query rule to the following:
(h; qh;query (x; f))jj(x; qx; t))
(h; qh;waitx;f)jj(x; qx[h7!qx[h] + [release h]]; t)
Note that the execution of the call fis shifted to the client,
after the synchronization with the handler has occurred. This
does not change the execution behaviour because, as in the
original rule, all calls on the handler are processed before the
query and the client does not proceed to log more calls until
the query has nished executing. As can be seen from Fig. 10,
the old rule rst generates the call, sends it to the handler,
<packing same as async>
ffi_call(&ffi _call, f,
&result, 0);
// QUERY rule
h_p.enqueue(ffi _call);
// SYNC rule
h_p.sync();
(a) Generated code for initial
sync rule.// New QUERY rule
h_p.enqueue(SYNC);
// SYNC rule
h_p.sync();
// New QUERY rule
result = f();
(b) Generated code for modied
sync rule.
Figure 10: Executing a query f
and then synchronizes (Fig. 10a), these actions come from
the combination of the query andsync rule. The new rule
just performs the call after synchronization occurs (Fig. 10b).
This approach oers three main benets:
there is no memory allocation required,
no encoding/decoding of the call is required, and
which call is being made is known statically.
The last item is important, as now the underlying optimizer
knows which call is being made, statically. This allows opti-
mizations such as inlining.One last optimization uses the knowledge that when the
handler nishes synchronizing with a client, it will have no
more work to do. Therefore, it control passes directly from
the handler to the client, using the scheduling layer of the
lightweight threads to avoid global scheduler. This optimiza-
tion is safe, because the handler will otherwise just be idle,
and avoids unnecessary context switching.
3.3 Multi-reservation Separate Blocks
The code generation for the multi-reservation separate
block diers slightly from the single-reservation case which is
optimized due to it being a simpler operation. One can see in
Fig. 11 that some of the complexity is pushed into the client
client.new _reservations ();
client.add _handler (h1);
client.add _handler (h2);
client.reserve _handlers();
private _queue *h1_p = client.queue _for (h1);
private _queue *h2_p = client.queue _for (h2);
<compiled body>
h1_p.enqueue (END);
h2_p.enqueue (END);
Figure 11: A compiled 2-reservation separate block
run-time library. The run-time maintains structures that al-
low the multiple handlers to be stored. The interface between
the compiled code and run-time consists of marking the start
of a new set of reservations with new_reservations , adding
a handler with add_handler , and nally safely reserving all
handlers with reserve _handlers . The client can now retrieve
the private queues that were just reserved; they do not need
to be inserted into the handler's queue-of-queues because
the reservation mechanism has already done that. Signalling
the end of the private queue is done as before. Currently,
the multiple reservation implementation uses one spinlock
for every handler to maintain the ordering guarantees. How-
ever, since the number of memory accesses to enqueue in the
queue-of-queues is quite small, a more sophisticated imple-
mentation could use transactional memory to implement the
same behaviour. These spinlocks were not found to decrease
performance.
3.4 Removing Redundant Synchronization
The SCOOP model essentially prevents data races by man-
dating that one must access (read and write) separate areas
of memory through their respective handlers. Due to this, a
common SCOOP idiom is that memory is often copied back
and forth between processors when a local copy is desired
for speed reasons. One example of this is sending data to a
worker for further asynchronous processing. When copying
data in SCOOP there are essentially two options: push or pull.
Either the data is copied via routines that asynchronously
push data to a separate target, or the data is synchronously
pulled by the client that wants it using queries. Even though
the rst option appears to enable more concurrency because
it is asynchronous, it often isn't the case. Consider sending an
array one integer at a time: this involves reading the integer
from the client, packaging the call that will set the integer
on the handler, sending the call, then applying the call. The
speed advantage of utilizing more than one core is dwarfedby the huge cost of issuing the call. Also, the second option
(synchronous pull) tends to be more natural, as the client
knows how and where to reconstruct the data.
Therefore it is natural to make queries as ecient as pos-
sible. This was partially addressed using the approach in the
previous section, using sync operations and executing the
query on the client. There is a further enhancement that can
be made to this approach, which is eliding unnecessary sync
calls. A sync call is not necessary if the previous call to the
desired handler was also a sync call; basically if the handler
is already \synced" it doesn't need to be re\synced".
We perform this elision in two ways: either by dynamically
recording the synced status in the runtime and ignoring sync
operations on handlers that have already been synced, or
statically by performing a static analysis.
3.4.1 Dynamic Avoidance
The dynamic method keeps the synced status in the private
queue structure. When a sync call is made on a private queue,
nothing happens if the queue is already synchronized; the
call merely returns and the synced status is unaected. If
the queue is not currently synced, the sync message is sent
to the handler as usual and when it returns the synced ag
is set in the handler reecting that the handler is processing
this private queue, but the queue is empty.
3.4.2 Static Removal
The static analysis starts by traversing the control ow
graph (CFG). It annotates every basic block, basic blocks
being sequences of basic instructions, with a set of handlers
that are synchronized by the end of the block. This set of
handlers is called the sync-set . The traversal of a function's
basic blocks can be seen in Fig. 12. Each block acts as a
while changed6=;
b2changed, changed := changed  fbg
common :=Tb.predecessors.sync set
ifb.sync set6=UpdateSync (b, common)
b.sync set := UpdateSync (b, common)
changed := changed [b.successors
Figure 12: Sync-set calculation for a function
sync-set transformer, adding and removing handlers from the
set. As an initial input, the intersection of the sync-sets of
all the block's predecessors is used. The traversal continues
until every basic block's sync-set has stopped changing.
Of course this only says how the blocks are traversed,
not how a given block's sync set is calculated given the in-
struction in that block. This is described in the UpdateSync
function, shown in Fig. 13. Each type of instruction is han-
UpdateSync (b, synced):
forinst2b
h := HandlerOf(inst)
synced := synced[fhgifinstis sync.
synced fhgifinstis async.
; ifinsthas side eects
synced otherwise
return synced
Figure 13: Sync-set calculation for a block
dled dierently: synchronization calls add the target handlerto the sync-set, asynchronous calls remove those handlers
(and anything they may be aliased to), and arbitrary calls
clear the sync-set entirely. Obviously this nal case is quite
severe, as it has to be, because a call could subsequently issue
asynchronous calls on all the handlers currently in the sync-
set. This can be mitigated by not clearing the sync-set for
functions which are marked with the readonly and readnone
ags. LLVM will automatically add these ags when it can
determine that they hold.
The static analysis operates on LLVM bitcode, and is im-
plemented as a standard LLVM pass (outside of the base
compiler). Keeping the pass outside of the base SCOOP/Qs-
compiler has the advantage that it separates the generation
of code from the analysis and transformation of the generated
control ow graph.
3.4.3 Example
The eect of the sync coalescing pass can be seen in Fig. 14.
This program has three blocks, with sync operations in each
h_p.sync()
x[i] := a[i]
h_p.sync()
fg
True
 Falsefg
h_p.sync()fgB1
B2
B3
(a) A simple loop before the sync-
coalescing pass.
x[i] := a[i]
h_p.sync()
fh_pg
True
 Falsefh_pg
fh_pgB1
B2
B3
(b) After sync-coalescing sync-
sets label edges.
Figure 14: Sync-coalescing pass
one. Before the sync-coalescing pass, in Fig. 14a, the client
is reading values out of a handler's array, for which a na ve
code generator will produce a sync before every array read.
Fig. 14b shows the results of the sync-coalescing pass in such
a situation. The sync-sets are shown explicitly on the edges
out of each block. In this case there are no calls that may
invalidate a sync-set, so the handler h_pappears on all edges.
The result of this is that the sync calls in blocks B2 and B3
can be removed. Removing sync calls in the body of a loop
can greatly increase performance. Note that even though the
sync call in the body of B2 was removed, h_pstill appears
on B2's outgoing edges because B2 doesn't invalidate the
synchronization on h_pby issuing an asynchronous call.
It is not always possible, however, to remove the sync
operations, even when the processor is apparently unaected.
Consider Fig. 15, where there is an additional call to i_p.
enqueue(r) , in Fig. 15a. Enqueueing a call is an asynchronous
activity, but it occurs on a dierent handler variable. This is
not enough, though, to conclude the handler h_pis unaected,
as these are only variables and could be aliased to one another.
Meaning they eectively be the same handler. This means
h_p.sync()
x[i] := a[i]
i_p.enqueue(r)
h_p.sync()
fg
True
 Falsefg
h_p.sync()fgB1
B2
B3
(a) A simple loop with an extra
asynchronous call on i.
h_p.sync()
x[i] := a[i ]
i_p.enqueue(r)
h_p.sync()
fhpg
True
 Falsefg
h_p.sync()fgB1
B2
B3
(b) Handlers h_pand i_pmay be
aliased: no coalescing.
Figure 15: Ineective sync-coalescing pass
that at the end of the B2 block the outgoing edges are labeled,
visible in in Fig. 15b, with neither h_pori_p. If more aliasing
information is given to the compiler then it is possible that
this ambiguity can be resolved and h_pcan be added to the
sync-set for the block.
The static analysis is important as it goes further towards
getting SCOOP out of the way of the optimization passes. In
the end our implementation uses both the static and dynamic
approaches. The static analysis is used when it can be, but
it is necessarily conservative. For the cases where the static
analysis keeps an unnecessary sync operation around, the
dynamic check will eliminate the round-trip to the handler.
4. OPTIMIZATION EVALUATION
Here we examine the impact of the following optimizations
(also outlined in Section 3):
Applying no optimizations ( None ).
Dynamically coalescing sync operations by recording
and checking the synchronization status in the runtime
(Dynamic ), as in Section 3.4.1.
Statically determining unnecessary sync operations and
removing them in a compiler pass ( Static ), as in Sec-
tion 3.4.2.
Usage of the queue-of-queues and private queues as a
handler/client communication abstraction ( QoQ ), as
seen in the semantic model given in Section 2.
Applying all optimizations ( All).
For the comparison, a variety of workloads are used.
4.1 Computation and Coordination-based Work-
loads
Properly evaluating a core runtime mechanism, such as
SCOOP/Qs, requires that it be used in a diverse assortment of
situations. With this in mind, we categorize the benchmarks
that will be used into two main groups:parallel : problems where concurrency is not part of the
functional specication, but can be used to speed up
the execution.
concurrent : problems which are dened by their con-
current behaviour.
The rst work type, parallel, is often a data processing task,
where multiple threads each process part of a large data
set to decrease the total running time. The second type of
work, concurrent, is more about the coordination between
the threads of control. Here, the concurrency is part of the
system's specication, such as a server handling multiple
clients simultaneously.
4.1.1 Parallel Workloads
The benchmark programs we selected for the parallel prob-
lems are a selection from the Cowichan problem set [27].
They focus on numerical processing and working over large
arrays and matrices. The programs include:
randmat : randomly generate a matrix of size nr.
thresh : pick the top p% of a matrix of size nrand
construct a mask.
winnow : apply a mask to a matrix of size nr, sorting
the elements that passed the mask based on their value
and position, and taking only nwfrom that sorted list.
outer : constructing a matrix and vector based o a list
of points.
product : matrix-vector product.
These benchmarks can be sequentially composed together,
the output of one becoming the input to the next, to form
achain . This chain is more complex and sizable than the
individual and gives a more diverse picture of a language's
parallel performance.
4.1.2 Concurrent Workloads
The concurrent problems focus on the interaction of dier-
ent independent threads with each other. We have created
three benchmarks that represent dierent interaction pat-
terns:
mutex :nthreads all compete for access to a single
resource, the threads do not depend on each other.
prodcons :nproducers and nconsumers each operate on
a shared queue; the queue has no upper limit so produc-
ers do not depend on consumers, but consumers must
wait until the queue is non-empty to make progress.
condition :n\odd" and n\even" workers increment a
variable from an odd (even) to an even (odd) number.
Each group depends on the other to make progress.
All of the above are repeated for miterations. Finally to
this we add two concurrency benchmarks from the Computer
Language Benchmarks Game [7]:
threadring : threads pass a token around a ring in se-
quence until the token has been passed nttimes.
chameneos : colour changing \chameneos" mate and
change their colours depending on who they mate with.
This is done nctimes.
The combination of these parallel and concurrent benchmarks
gives us a balanced view of the performance characteristics
of the approach.Table 1: Normalized (to fastest) comparison of optimizations
on parallel tasks
Task none Dyn. Static QoQ All
chain 27.70 1.13 1.00 28.81 1.28
outer 78.95 1.45 1.00 80.44 1.00
product 49.99 1.33 1.00 51.18 1.02
randmat 345.61 3.05 1.00 353.43 1.03
thresh 64.54 1.33 1.00 66.08 1.05
winnow 53.14 1.35 1.21 54.33 1.00
Setup.
All benchmarks were performed 20 times on a Intel Xeon
Processor E7-4830 server (4 2.13 GHz, each with 8 cores;
32 physical cores total) with 256 GB of RAM, running Red
Hat Enterprise Linux Server release 6.3. Language and com-
piler versions used were: gcc-4.8.1, go-1.1.2, ghc-7.6.3, erlang-
R16B01. For the parallel benchmarks, the problem sizes used
arenr=10,000 ,p=1andnw=10,000 ; for the concur-
rent benchmarks n=32,m=20,000 ,nt=600,000 , and
nc= 5,000,000.
4.2 Parallel Benchmarks
As mentioned in the previous section, the idiomatic way
to transfer data in SCOOP/Qs is to have the client pull data
from the handler. This happens in the Cowichan problems
often, as the underlying data structures are almost exclu-
sively large arrays and they must be distributed to and from
workers. This is important for interpreting the results of the
comparison of optimizations when they are applied to the
Cowichan problems. Fig. 16 displays the communication time
(as this is by far the factor dominating the execution time)
normalized to the fastest version and in log scale. From this,
it is clear that there is a marked improvement in communi-
cation time for the parallel benchmarks over the programs
that had no optimizations that reduce the number of sync
operations that are performed.
The dierence between having no reduction in the number
of sync calls ( None ,QoQ ) and employing some reduction
technique ( Dynamic ,Static ,All) is that the latter is at
least 10 times faster ( chain ), near 100 times faster ( thresh ,
winnow ,outer ,product ), or over 100 times faster ( randmat ).
Reducing the number of sync calls is a great benet for
programs that require large numbers of synchronous calls.
There is an additional property of these benchmarks that
they access the arrays in a very regular way, namely they copy
from one array to another, generally calling sync many times
in a tight loop. In these cases, it is benecial to fully lift this
call right out of the loop body, as the Static optimization
does. The dierence between the Static andDynamic sync-
coalescing optimizations can be seen in more detail in Table 1.
We can see for example that randmat is 3x faster when
using the Static sync coalescing optimization compared to
theDynamic , and others using Static sync coalescing are
between 1.1x and 1.4x faster than Dynamic .
4.3 Concurrent Benchmarks
While the QoQ optimization has little eect on the Cowichan
problems, it has a stronger inuence on the concurrency prob-
lems which can be seen in Fig. 17. The full results are visible
in Table 2.
Using QoQ is faster ( chamenos, condition, prodcons ) or
about the same ( mutex, threadring ). The increase in perfor-
mance can be attributed to the better utilization of availablechain outer product randmat thresh winnow
110
110100
110
110100
110
110
NoneDyn.StaticQoQAll NoneDyn.StaticQoQAll NoneDyn.StaticQoQAll NoneDyn.StaticQoQAll NoneDyn.StaticQoQAll NoneDyn.StaticQoQAll
OptimizationTime (normalized)Figure 16: Communication times for dierent optimization techniques evaluated on parallel tasks
chameneos condition mutex prodcons threadring
05101520
0510
0.00.10.20.30.4
0123
051015
NoneDyn.StaticQoQAll NoneDyn.StaticQoQAll NoneDyn.StaticQoQAll NoneDyn.StaticQoQAll NoneDyn.StaticQoQAll
OptimizationTime (s)
Figure 17: Comparison of SCOOP/Qs optimizations on concurrent benchmarks
Table 2: Times (in seconds) for optimizations applied on
concurrent benchmarks
Task none Dyn. Static QoQ All
chameneos 21.41 6.58 21.58 16.54 4.80
condition 12.41 8.93 12.44 1.78 1.50
mutex 0.44 0.45 0.44 0.46 0.47
prodcons 3.72 1.88 3.71 1.98 1.42
threadring 17.01 5.27 17.08 16.41 5.80
processing capabilities resulting from less blocking in the
underlying semantics. When using QoQ there are also fewer
context switches, since the private queues require only one
context switch to wait for a query to return. When not us-
ing the queue-of-queues a client must wait three times: rst
for the lock on the handler, then the handler must wait for
the client to log its query, then the client must wait again
for the handler to return the query. However, the queue-of-
queues approach does introduce some overhead in cases where
there are few calls issued in the separate block, because it
must enqueue twice, once putting the private queue into the
queue-of-queues, then putting the call into the private queue.
However, mostly the QoQ optimization is benecial.
One can also see here the importance of the Dynamic
sync-coalescing optimization. In particular it benets the
chameneos, condition, prodcons and threadring benchmarks.
This underscores the benet of limiting the roundtrips to the
handler when they are not necessary. When it applies, this
increases the performance between 1.5 and 3 . It is important
to note here that because the workloads are irregular, the
Static sync-coalescing is not as eective. Its main benet
comes in cases of regular access patterns where it can be
applied more readily.
4.4 Summary
Each optimization has particular situations in which itbrings the most benet:
QoQ is best on coordination tasks but is not as useful
for query-heavy workloads.
Dynamic sync-coalescing is useful on both coordina-
tion tasks and tasks with many queries.
Static sync-coalescing is primarily eective on very
structured query usages, beating even Dynamic in
such situations.
The geometric mean of all benchmarks is 20.70s for no op-
timizations, 1.99s for Dynamic sync-coalescing, 2.24s for
Static sync-coalescing, 16.21s for QoQ , and 1.36s with all
optimizations. The net eect is that the nal SCOOP/Qs
runtime is15faster than the basic runtime.
4.5 Application outside the Prototype
To provide further evidence of the eectiveness of the
execution techniques presented here, a new runtime was con-
structed for the research branch, EVE[5], of the EielStudio
IDE. The new runtime, which we've named EVE/Qs, incor-
porates the QoQ andDynamic optimizations. The Static
optimization was not implemented due to the lack of robust
static code analysis and transformation facilities in EielStu-
dio. The results are promising: the speedup compared to the
existing production SCOOP runtime has a geometric mean of
11.7on the concurrency benchmarks, 7.7 on the parallel
benchmarks, and a 9.7 across all benchmarks. The absolute
performance of EVE/Qs is lower compared to SCOOP/Qs
because EVE/Qs inherits several implementation decisions
from EielStudio. For example, the use of a shadow-stack for
garbage collection, inhibiting ecient tight-loop optimiza-
tions important for the parallel benchmarks. Also, storing
handler IDs in the object header requiring maintenance of a
secondary thread-safe data structure to lookup the handler
data. Since the handlers are accessed incredibly often, thisalso is a detriment to performance. Lastly, since SCOOP/Qs
uses lightweight threads, situations with high contention, such
as in the concurrency benchmarks, benet.
5. LANGUAGE COMPARISON
It is dicult to gauge the appropriateness of a concur-
rency model without comparing it against its contemporaries.
With that in mind, this section presents a comparison of
SCOOP/Qs with four well-established languages.
5.1 A Variety of Languages
The comparison languages should: be modern, well-known,
and represent a variety of dierent underlying design choices.
For the purposes of the evaluation, this means that we should
select from dierent programming paradigms, dierent ap-
proaches to shared memory, dierent concurrency safety guar-
antees, and dierent threading implementations. We have
chosen a selection of languages: C++/TBB (Threading Build-
ing Blocks) [14], Erlang [1], Go [9], and Haskell [21]. This
selection attempts to combine a reasonable number of the
facets outlined above to give a complete picture. To make
the diversity clear, we present this in Table 3.
The Memory column refers to how memory is shared be-
tween threads. Erlang has no sharing between dierent pro-
cesses: when data is sent between processes it is copied in
its entirety. In SCOOP/Qs the programmer is only able ti
access shared memory through a handler. In Haskell it is
perfectly possible to construct data races if one uses mutable
references. However, to include one more race-free model
to this comparison, we restrict ourselves to using Haskell's
STM implementation, the parconstruct which executes pure
computations in parallel, as well as the Repa library which
is specialized to work on parallel arrays.
5.2 Parallel Benchmarks
The parallel benchmarks are meant to measure how well a
language can handle taking a particular program and scaling
it given more computational resources (cores). Note that it
is common in the Erlang and SCOOP/Qs implementations
of the Cowichan problems that a signicant amount of time
is spent sharing results among the threads. Therefore, to
more clearly see the eect of dierent optimizations, and to
separate computational eects from communication eects,
we distinguish the time spent computing versus the time
spent communicating the results.
5.2.1 Execution Time
We can see the graph of performance given 32 cores in
Fig. 18. As with SCOOP/Qs, to give a clearer picture of the
performance characteristics of Erlang, we also distinguish
the computation time from the communication time. We
can see that SCOOP/Qs and Erlang both spend a majority
of their time in communication, with the exception of the
chain problem, which has much less communication between
the workers. It is useful to consider both the total and the
computation time: in non-benchmark style problems it is
more likely that the workloads fall somewhere in the middle.
For example, the chain problem, which is the composition of
the other smaller benchmarks, does not suer from nearly
the same communication burden as they do.
Erlang has unfavorable performance results compared to
the other languages. Due to Erlang's data representation(forces to use linked lists to represent matrices) and its ex-
ecution model (cannot use the HiPE-optimized builds [13]
with the multithreaded runtime), it generally falls far behind
the other approaches, even Haskell and SCOOP/Qs.
Besides Erlang, the other languages are more closely
grouped. The geometric means for total time are, in increas-
ing order: C++/TBB (0.32s), Go (0.57s), Haskell (0.89s),
SCOOP/Qs (1.35s), and Erlang (18.07s). For computation-
only time, the order is: SCOOP/Qs (0.29s), C++/TBB
(0.32s), Go (0.57s), Haskell (0.89s) and Erlang (4.32s).
Note that this puts SCOOP/Qs rst because many of the
cache eects are removed due to the predistribution of the
data before the timing starts. This is only included as a
sanity test, to show that the lower-bound for the SCOOP/Qs
implementation is competitive with the other approaches.
5.2.2 Scalability
The other aspect that we investigated was the speedup
of the benchmarks across 32 cores. In Fig. 19 we can see
the performance of the various languages on the dierent
problems. We can see that on chain , most languages manage
to achieve a speedup of at least 5x. Go is the exception to
this, and performance decreases past 8 cores. Erlang also sees
a performance degradation, though only past 16 cores. This
was also an eect that was seen in our language comparison
study [19] from which the implementation was taken; the
implementation was also reviewed by a key Go developer in
the study.
Also of note is the performance of Haskell on the randmat
benchmark. This is one of the few benchmarks where Repa
could not be eectively used due to the nature of the problem,
so the basic par-based concurrency primitives are used. The
basic strategy has chunks of the output array constructed in
parallel, then concatenated together. The concatenation is se-
quential, however, putting a limit on the maximum speedup;
using the ThreadScope [26] performance reporting tool, we
could see that the stop-the-world garbage collector was inter-
vening too often. The last unexpected result was the inability
for the Erlang version of the winnow program to speedup
past about 2-3x. This was examined in detail but no cause
could be found. Precise timing data can be found in Table 4.
5.3 Concurrent Benchmarks
The concurrent programming tasks are compared in Fig. 20
and exact times in Table 5.
Table 5: Concurrent benchmark times (in seconds)
Task c++ erlang go haskell SCOOP/Qs
chameneos 0.32 8.67 2.40 61.97 4.71
condition 15.92 2.15 5.95 26.05 1.48
mutex 0.14 6.13 0.17 0.86 0.47
prodcons 0.40 8.78 0.66 2.99 1.33
threadring 34.13 3.30 13.98 57.44 5.82
Haskell tends to perform the worst, which is likely due to
the use of STM, which incurs an extra level of bookkeeping
on every operation. Erlang performs better, but in general
lags behind the other approaches. C++/TBB tends to be the
fastest, except in the condition and threadring benchmarks,
which are both essentially single-threaded; they are designed
to test context switching overhead in various forms. Go does
quite well uniformly, never the fastest, but never the slowest.
Lastly, SCOOP/Qs performs mostly in line with C++/TBBTable 3: Language characteristics
Language Races Threads Paradigm Memory Approach
C++/TBB possible OS Imperative Shared Skeletons/traditional
Go possible light Imperative Shared Goroutines/channels
Haskell none light Functional STM STM/Repa
Erlang none light Functional Non-shared Actors
SCOOP/Qs none light O-O Non-shared Active Objects
chainouterproductrandmatthreshwinnow
0510150.02.55.07.5036912
012345
0.02.55.07.510.012.5
0510152025
cxxerlanggohaskellQscxxerlanggohaskellQscxxerlanggohaskellQscxxerlanggohaskellQscxxerlanggohaskellQscxxerlanggohaskellQsLanguageTime (s)Computation timeCommunication time
Figure 18: Execution times of parallel tasks on dierent languages, executed on 32 cores
and Go, however it is the fastest in the condition benchmark.
In increasing order of geometric means: C++/TBB (1.57s),
Go (1.82s), SCOOP/Qs (1.91s), Erlang (5.01s), and Haskell
(12.20s).
5.4 Summary
This evaluation presents a wide variety of approaches to
concurrency and situates SCOOP/Qs among them. In par-
ticular, we can see that SCOOP/Qs is generally quite com-
parable on coordination or concurrency tasks, falling in the
middle of the pack after Go and C++/TBB, but faring better
than Erlang and Haskell. Note, however, that neither Go nor
C++/TBB oers any of the guarantees of SCOOP/Qs, and
SCOOP/Qs oers more guarantees than Erlang.
For parallel problems, SCOOP/Qs ranks 4th with all com-
munication burdens accounted for, but 1st when only compu-
tation is considered. Again, we present both of these results
only to say that we expect real world usage to be between
these extremes; see the chain benchmark for an indication of
performance on tasks which are not dominated by communi-
cation. In any case, it still remains that SCOOP/Qs outpaces
Erlang in all cases, and can provide reasonable performance
comparable with the other approaches, while still providing
more guarantees in the execution model.
For all problems, concurrent and parallel, the geomet-
ric means are: C++/TBB (0.71s), Go (1.02s), SCOOP/Qs
(1.61s), Haskell (3.30s), and Erlang (9.51s). This places
SCOOP/Qs as the best performing of the safe languages.
6. RELATED WORK
Finding runtime and compiler optimizations is a vital re-
search goal when developing programming approaches for
concurrency and parallelism. While approaches in this area
are based on a broad variety of concepts, and in this re-
spect each require dierent solutions, this work proted from
insights and discussions of a number of related works.
Cilk [2] is an approach to multi-threaded parallel program-
ming based on a runtime system that provides load balancing
using dynamic scheduling through work stealing. Work steal-ing [3] assumes the scheduling forms a directed acyclic graph.
In contrast, we tolerate some cyclic schedules through the use
of queues. Since we use queues, handler A can log work on
handler B while handler B logs work on A, as long as they do
not issue queries on one another (forcing a join edge). We are
not strict: edges go into handlers from the outside, other than
at spawn; this is actually the normal case when logging calls.
Although Cilk has been extended into Cilk++ [8], this does
not indicate a signicant uptake of object-oriented concepts
to ensure correctness properties such as race freedom.
X10 [6] is an object-oriented language for high perfor-
mance computing based on the partitioned global address
space model, which aims to combine distributed memory pro-
gramming techniques with the data referencing advantages
in shared-memory systems. Although there is a mechanism
to ensure local atomicity through the keyword atomic , it
is opt-in, and as such admits programs with data races by
default. The async blocks allow computations to run on dif-
ferent address spaces, but there is no way for the caller to
ensure consistency between async blocks directed to the same
address space. The help-rst stealing discipline [11] in X10
oers that the spawned task is left to be stolen, while the
worker rst executes the continuation; this is in contrast to
Cilk's work-rst strategy where the spawned task is executed
rst. The help-rst strategy has benets as it avoids the ne-
cessity of the thieves synchronizing. This only applies because
the thefts in a nish block in X10 are serialized in work-rst,
whereas they are not for help-rst. This technique would not
be directly applicable to our work because SCOOP/Qs waits
only on the result of a single handler.
Aida [17] is an execution model that, like SCOOP, as-
sociates threads of control with portions of the heap. The
technique is implemented on top of Habanero-Java [4], an
extension of the X10 implementation for Java. When there
is contention for a particular heap location, the \loser" rolls
back its heap modications, suspends, and appends itself
(delegates) to the run queue of the winner, eectively turning
two concurrent tasks into a single one. This is fundamentally
dierent from the SCOOP model, which also has isolated
heaps, but allows interaction between threads of control, andchainouterproductrandmatthreshwinnow
‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè01020
248163224816322481632248163224816322481632BenchmarkSpeedupLanguage‚óècxxerlanggohaskellQserlang (comp.)Qs (comp.)Figure 19: Speedup over single-core performance, up to 32 cores
Table 4: Parallel benchmark times (in seconds)
Threads
Task Lang V 1 2 4 8 16 32
randmat c++ T 0.44 0.23 0.13 0.08 0.06 0.08
randmat erlang T 30.93 18.01 10.20 5.77 4.05 4.14
randmat erlang C 20.69 11.26 5.63 2.99 1.73 1.50
randmat go T 0.78 0.43 0.24 0.14 0.09 0.08
randmat haskell T 0.68 0.43 0.36 0.44 0.62 1.03
randmat SCOOP/Qs T 0.72 0.43 0.29 0.22 0.21 0.23
randmat SCOOP/Qs C 0.59 0.30 0.15 0.08 0.05 0.05
thresh c++ T 1.00 0.66 0.34 0.18 0.12 0.11
thresh erlang T 31.82 22.35 17.77 14.48 12.88 11.96
thresh erlang C 19.30 10.74 5.97 2.77 1.47 0.89
thresh go T 0.95 0.60 0.37 0.22 0.17 0.17
thresh haskell T 1.56 0.96 0.69 0.55 0.51 0.50
thresh SCOOP/Qs T 3.71 2.72 2.28 2.10 2.11 2.15
thresh SCOOP/Qs C 1.87 1.08 0.54 0.31 0.16 0.09
winnow c++ T 2.04 1.03 0.53 0.29 0.18 0.15
winnow erlang T 31.03 26.02 25.04 24.75 24.38 23.95
winnow erlang C 4.06 2.58 1.84 1.46 1.29 1.24
winnow go T 2.47 1.29 0.71 0.46 0.32 0.28
winnow haskell T 5.43 2.77 1.42 0.80 0.48 0.52
winnow SCOOP/Qs T 5.16 3.74 3.04 2.69 2.58 2.57
winnow SCOOP/Qs C 2.83 1.40 0.72 0.36 0.19 0.10Threads
Task Lang V 1 2 4 8 16 32
outer c++ T 1.59 0.83 0.42 0.23 0.15 0.14
outer erlang T 61.57 38.21 21.19 17.57 11.67 8.05
outer erlang C 40.66 22.54 10.45 6.05 3.12 2.52
outer go T 2.47 1.44 0.84 0.57 0.60 0.67
outer haskell T 5.49 2.76 1.40 0.74 0.41 0.36
outer SCOOP/Qs T 2.58 1.62 1.15 0.93 0.90 0.89
outer SCOOP/Qs C 1.87 0.93 0.46 0.24 0.12 0.06
product c++ T 0.44 0.23 0.13 0.09 0.08 0.12
product erlang T 15.89 13.94 12.66 12.08 11.82 11.33
product erlang C 3.35 1.95 0.90 0.45 0.24 0.15
product go T 0.76 0.46 0.29 0.19 0.15 0.13
product haskell T 0.45 0.25 0.16 0.11 0.11 0.15
product SCOOP/Qs T 1.49 1.33 1.27 1.24 1.28 1.34
product SCOOP/Qs C 0.32 0.16 0.08 0.04 0.02 0.01
chain c++ T 5.57 2.76 1.42 0.76 0.43 0.32
chain erlang T 120.59 69.00 32.06 18.48 13.23 16.01
chain erlang C 119.68 68.13 30.93 17.75 12.63 15.15
chain go T 7.39 4.09 2.39 1.79 1.93 2.60
chain haskell T 13.78 7.71 4.62 3.30 2.74 2.94
chain SCOOP/Qs T 5.60 2.88 1.56 0.97 0.68 0.67
chain SCOOP/Qs C 5.54 2.75 1.40 0.74 0.40 0.25
V - Timing Variant, T - Total time, C - Compute time.
even provides reasoning guarantees on this interaction. There-
fore the underlying mechanisms are fundamentally dierent,
where Aida requires ecient heap ownership and conict
resolution via a parallel union-nd algorithm, SCOOP/Qs
requires ecient communication which is attained via novel
and nested uses of specialized queue structures. Otello [28]
extends the isolation found in Aida to include support for
nested tasks.
Another object-oriented approach which, like SCOOP,
associates threads of execution with areas of the heap
is JCoBox [23]. It also makes the distinction (similar to
separate ) between references that are local and those that
are remote, although this can only be applied per-class, not
per-object as in SCOOP. Each CoBox contains a queue for
incoming asynchronous calls, though the reasoning guaran-
tees are weaker for JCoBox, so this structure can be simple.
The synchronous calls in JCoBox are also executed locally,
but no dynamic or static method to reduce communication,
ensuring data race freedom, is performed.
Kilim [25] is a framework that supports the implementa-
tion of Actor-based approaches in Java. It improves message-
passing performance by treating messages dierently fromother Java objects, in that they are free of internal aliases
and owned by at most one Actor at a time. The messages
arrive via explicitly declared mailboxes in the objects, which
also do not provide the reasoning guarantees between mes-
sages that the SCOOP model provides. The Kilim mailboxes
have, therefore, a more simplistic behaviour compared to the
queue-of-queues approach in SCOOP/Qs. Kilim also sets
new standards in creating lightweight threads, which are not
tied to kernel resources, thereby providing scalability and
low context switching costs. SCOOP implementations have
previously been based on operating system threads, and us-
ing lightweight threads in SCOOP/Qs we can report similar
improvements in scalability as observed by Kilim. Kilim is
extended with ownership-based memory isolation [10] for
messages to reduce the amount of unnecessary copying. Al-
though not strictly a message-based model, SCOOP/Qs may
be able to apply this technique to so-called expanded classes,
which are more like standard C structures, and are presently
copied when used as arguments to separate calls.
We summarize the above approaches by stating whether
they oer guards (protection against races) and delegation
(ability for one entity to give work to another).chameneos condition mutex prodcons threadring
0204060
01020
0246
0.02.55.07.5
0204060
cxxerlanggohaskellQs cxxerlanggohaskellQs cxxerlanggohaskellQs cxxerlanggohaskellQs cxxerlanggohaskellQs
LanguageTime (s)Figure 20: Execution times of concurrent tasks on dierent languages
No guarding, no delegation { Cilk/Cilk++.
Partial guarding, delegation { X10 allows delegation as
the only way for one place to modify another. However,
a place can asynchronously modify itself using the same
mechanism, thus there may be races within a place.
Guarding, protective delegation { Aida and Otello ex-
tend X10 with the ability to resolve races by rolling
back changes and reducing the amount of concurrent
execution.
Guarding, delegation { JCoBox and Kilim both have
dierent approaches to the actor/active object model.
This implies strict guarding and delegation of actions.
Guarding, enhanced delegation { SCOOP follows the
actor approach, but also oers enhanced delegation by
allowing clients to maintain pre/postcondition reason-
ing with the handlers that they are delegating to.
7. CONCLUSION
We have presented SCOOP/Qs, an ecient execution
model and implementation for the SCOOP concurrency model.
As many other programming models that ensure strong safety
guarantees, SCOOP introduces restrictions on program ex-
ecutions, which can become performance bottlenecks when
implemented naively, standing in the way of practicality
and more widespread adoption. The key to our approach
was a reformulation of the SCOOP guarantees in abstract
form, allowing one to explore a larger design space for run-
time and compiler optimizations than previous operational
descriptions. In particular, it enabled us to remove much
of the need for synchronization between threads, thereby
providing more opportunities for parallelism. In the eval-
uation of our approach, we traced the impact of the key
optimizations, and compared SCOOP/Qs with a number of
well-known and varied approaches to concurrency and paral-
lelism: C++/TBB, Go, Haskell, and Erlang. This conrmed
that, on a broad benchmark including both coordination-
intensive and computation-intensive tasks, SCOOP/Qs can
compete with and often outperform its competitors.
SCOOP oers a method of controlling access to other actors
which is more exclusive than typical Actor-like languages. In
SCOOP, messages can be bundled together to provide better
pre/postcondition reasoning between messages (calls). The
underlying techniques used in SCOOP/Qs are an ecient
way to oer temporary control of one active object, or actor,
over another. As such the technique could also be used in
approaches like JCoBox [23] or Kilim [25] to provide more
structured interactions between entities.In the future, we plan to further explore the utility of
the private queue design, in particular the usage of sockets
as the underlying implementation. To further investigate
and advance the eciency of the runtime, a SCOOP-specic
instrumentation for the runtime, providing detailed measure-
ments for the internal components, will be essential.
8. ACKNOWLEDGMENTS
This work was supported by ERC grant CME #291389.
9. REFERENCES
[1] J. Armstrong, R. Virding, C. Wikstr om, and
M. Williams. Concurrent programming in Erlang .
Prentice Hall, 2nd edition, 1996.
[2] R. D. Blumofe, C. F. Joerg, B. C. Kuszmaul, C. E.
Leiserson, K. H. Randall, and Y. Zhou. Cilk: An
ecient multithreaded runtime system. In Proceedings
of the Fifth ACM SIGPLAN Symposium on Principles
and Practice of Parallel Programming , PPOPP '95,
pages 207{216, New York, NY, USA, 1995. ACM.
[3] R. D. Blumofe and C. E. Leiserson. Scheduling
multithreaded computations by work stealing. Journal
of the ACM , 46(5):720{748, Sept. 1999.
[4] V. Cav e, J. Zhao, J. Shirako, and V. Sarkar.
Habanero-java: The new adventures of old x10. In
Proceedings of the 9th International Conference on
Principles and Practice of Programming in Java , PPPJ
'11, pages 51{61, New York, NY, USA, 2011. ACM.
[5] Chair of Software Engineering, ETH. EVE (Eiel
Verication Environment).
http://se.inf.ethz.ch/research/eve/ , Mar. 2014.
[6] P. Charles, C. Grotho, V. Saraswat, C. Donawa,
A. Kielstra, K. Ebcioglu, C. von Praun, and V. Sarkar.
X10: An object-oriented approach to non-uniform
cluster computing. In Proceedings of the 20th Annual
ACM SIGPLAN Conference on Object-oriented
Programming, Systems, Languages, and Applications ,
OOPSLA '05, pages 519{538, New York, NY, USA,
2005. ACM.
[7] Computer Language Benchmarks Game.
http://shootout.alioth.debian.org/ , 2013.
[8] M. Frigo, P. Halpern, C. E. Leiserson, and
S. Lewin-Berlin. Reducers and other Cilk++
hyperobjects. In Proceedings of the Twenty-rst Annual
Symposium on Parallelism in Algorithms and
Architectures , SPAA '09, pages 79{90, New York, NY,
USA, 2009. ACM.
[9] Go programming language. http://golang.org/ , 2013.[10]O. Gruber and F. Boyer. Ownership-based isolation for
concurrent actors on multi-core machines. In
Proceedings of the 27th European Conference on
Object-Oriented Programming , ECOOP'13, pages
281{301, Berlin, Heidelberg, 2013. Springer-Verlag.
[11]Y. Guo, R. Barik, R. Raman, and V. Sarkar. Work-rst
and help-rst scheduling policies for async-nish task
parallelism. In Proceedings of the 2009 IEEE
International Symposium on Parallel & Distributed
Processing , IPDPS '09, pages 1{12, Washington, DC,
USA, 2009. IEEE Computer Society.
[12] C. Hewitt, P. Bishop, and R. Steiger. A universal
modular Actor formalism for articial intelligence. In
Proceedings of the 3rd International Joint Conference
on Articial Intelligence , IJCAI'73, pages 235{245, San
Francisco, CA, USA, 1973. Morgan Kaufmann
Publishers Inc.
[13] HiPE reference manual.
http://erlang.org/doc/apps/hipe/ , 2013.
[14]W. Kim and M. Voss. Multicore desktop programming
with Intel Threading Building Blocks. IEEE Software ,
28(1):23{31, 2011.
[15] lib. http:://sourcware.org/libffi/ , Mar. 2014.
[16] LLVM. http:://www.llvm.org , Mar. 2014.
[17] R. Lublinerman, J. Zhao, Z. Budimli c, S. Chaudhuri,
and V. Sarkar. Delegated isolation. In Proceedings of
the 2011 ACM International Conference on Object
Oriented Programming Systems Languages and
Applications , OOPSLA '11, pages 885{902, New York,
NY, USA, 2011. ACM.
[18] B. Morandi, M. Schill, S. Nanz, and B. Meyer.
Prototyping a concurrency model. In Proc. ACSD'13 ,
pages 170{179. IEEE, 2013.
[19] S. Nanz, S. West, K. Soares da Silveira, and B. Meyer.
Benchmarking usability and performance of multicore
languages. In Proc. ESEM'13 , pages 183{192. IEEE,
2013.
[20]P. Nienaltowski. Practical framework for contract-basedconcurrent object-oriented programming . PhD thesis,
ETH Zurich, 2007.
[21]S. Peyton Jones, A. Gordon, and S. Finne. Concurrent
haskell. In Proceedings of the 23rd ACM
SIGPLAN-SIGACT Symposium on Principles of
Programming Languages , POPL '96, pages 295{308,
New York, NY, USA, 1996. ACM.
[22] Quicksilver, an implementation of the SCOOP/Qs
model. https://github.com/scottgw/quicksilver , Sept.
2014.
[23] J. Sch afer and A. Poetzsch-Heter. JCoBox:
Generalizing active objects to concurrent components.
InProceedings of the 24th European Conference on
Object-oriented Programming , ECOOP'10, pages
275{299, Berlin, Heidelberg, 2010. Springer-Verlag.
[24] N. Shavit and D. Touitou. Software transactional
memory. In Proceedings of the Fourteenth Annual ACM
Symposium on Principles of Distributed Computing ,
PODC '95, pages 204{213, New York, NY, USA, 1995.
ACM.
[25] S. Srinivasan and A. Mycroft. Kilim: Isolation-typed
actors for java. In Proceedings of the 22nd European
Conference on Object-Oriented Programming , ECOOP
'08, pages 104{128, Berlin, Heidelberg, 2008.
Springer-Verlag.
[26] K. B. Wheeler and D. Thain. Visualizing massively
multithreaded applications with threadscope. CCPE ,
22(1):45{67, Jan. 2010.
[27]G. V. Wilson and R. B. Irvin. Assessing and comparing
the usability of parallel programming systems.
Technical Report CSRI-321, University of Toronto,
1995.
[28] J. Zhao, R. Lublinerman, Z. Budimli c, S. Chaudhuri,
and V. Sarkar. Isolation for nested task parallelism. In
Proceedings of the 2013 ACM SIGPLAN International
Conference on Object Oriented Programming Systems
Languages & Applications , OOPSLA '13, pages
571{588, New York, NY, USA, 2013. ACM.