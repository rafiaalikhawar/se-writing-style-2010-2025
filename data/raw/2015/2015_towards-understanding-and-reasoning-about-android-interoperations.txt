Towards Understanding and Reasoning
about Android Interoperations
Sora Bae
KAIST
Daejeon, South Korea
bsora92@kaist.ac.krSungho Lee
KAIST
Daejeon, South Korea
eshajlee@gmail.comSukyoung Ryu
KAIST
Daejeon, South Korea
sukyoung.ryu@gmail.com
Abstract —Hybrid applications (apps) have become one of the
most attractive options for mobile app developers thanks to its
support for portability and device-speciﬁc features. Android hy-
brid apps, for example, support portability via JavaScript, device-
speciﬁc features via Android Java, and seamless interactions
between them. However, their interoperation semantics is often
under-documented and unintuitive, which makes hybrid apps
vulnerable to errors. While recent research has addressed such
vulnerabilities, none of them are based on any formal grounds.
In this paper, we present the ﬁrst formal speciﬁcation of An-
droid interoperability to establish a ﬁrm ground for understand-
ing and reasoning about the interoperations. We identify its se-
mantics via extensive testing and thorough inspection of Android
source code. We extend an existing multi-language semantics to
formally express the key features of hybrid mechanisms, dynamic
and indistinguishable interoperability. Based on the extensions,
we incrementally deﬁne a formal interoperation semantics and
disclose its numerous unintuitive and inconsistent behaviors.
Moreover, on top of the formal semantics, we devise a light-
weight type system that can detect bugs due to the unintuitive
inter-language communication. We show that it detects more bugs
more efﬁciently than HybriDroid, the state-of-the-art analyzer of
Android hybrid apps, in real-world Android hybrid apps.
Index T erms —Android hybrid applications, interoperability,
multi-language systems, operational semantics, type system
I. I NTRODUCTION
Taking the best out of both web and native apps—portability
and device-speciﬁc features— hybrid apps have become preva-
lent [1], [2]. In hybrid apps, JavaScript code handles user
interactions to be run on multiple browsers, native code
accesses device-speciﬁc features, such as accelerometer, and
they can communicate via interoperations.
However, understanding the interoperation behaviors of hy-
brid apps is not trivial because the implementation languages
have different semantics. Because the semantics of JavaScript
is different from that of native languages like Android Java,
it is quite easy for developers to make errors like pass-
ing wrong number or wrong types of arguments to foreign
function calls. Consider Fig. 1 an excerpt from the Adobe
Acrobat Reader source code, which is downloaded using
the PlayDrone project [3]. It shows an interaction between
Java1and JavaScript. Fig. 1(a) shows Java code where class
ARJSApp declares method alert that can be used in JavaScript
1While Android Java is different from Java, we use Android Java and Java
interchangeably when their differences do not matter.class ARJSApp {
@JavascriptInterface
public final int alert(String paramString,
int paramInt) { ... }
...
}
(a) Java class ARJSApp declares method alert that can be injected to
JavaScript contexts.
this.mWebView.addJavascriptInterface(
new ARJSApp(this), "_app");
(b) Java code injects a Java object new ARJSApp(this) into the
JavaScript context with name _app .
App.prototype.alert = function(cMsg, nIcon) {
return window._app.alert(cMsg + "", nIcon);
};
var app = new App();
app.alert(cAlert);
(c) JavaScript invokes the injected Java method window._app.alert .
Fig. 1: Interaction between Android Java and JavaScript
as denoted by annotation @JavascriptInterface . Fig. 1(b)
shows another Java code where an instance of ARJSApp is
injected to the JavaScript context as top-level variable _app
via method addJavascriptInterface of class WebView . Then,
Fig. 1(c) illustrates an actual interaction in JavaScript code.
JavaScript object app calls its function property alert with a
single argument cAlert while the function declaration expects
two parameters cMsg andnIcon . Calling a function expecting
two arguments with only one argument is a valid semantics in
JavaScript: the second parameter nIcon gets value undefined .
Then, the function body calls the injected Java method
window._app.alert expecting a string and an integer with
cMsg + "" and nIcon . The second argument from JavaScript
does not satisfy the type requirement of the Java method.
Moreover, inter-language communication introduces various
design choices to make. Consider Fig. 1 once again. When
value undefined is passed to function window._app.alert ,
would it throw an exception? If method alert is overloaded
in the Java side, would it be still overloaded after the injection
to the JavaScript side, which does not support overloading?
When the same Java object is injected to JavaScript twice as
_app and app_ , would the injected objects be still the same
object in the JavaScript side? And so on.
However, existing research for Android hybrid apps [4]–
2232019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)
1558-1225/19/$31.00 ©2019 IEEE
DOI 10.1109/ICSE.2019.00038
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:59:16 UTC from IEEE Xplore.  Restrictions apply. [7] and even the ofﬁcial Android documentation [8] do not
clearly specify the interoperation behaviors and its design
choices. The existing works focus on handling real-world
Android apps and various engineering decisions for scalability;
they do not aim to cover the inter-communication semantics.
The state-of-the-art static analyzer for Android hybrid apps,
HybriDroid [7], analyzes inter-communication between Android
Java and JavaScript, and detects misuses of foreign function
calls, but it addresses interoperations partially; it does not
consider, for example, multiple injections of single Java object.
The Android documentation is neither exhaustive nor consis-
tent; it does not address any design choices discussed above.
In this paper, we present the ﬁrst formal speciﬁcation of
Android interoperability to provide a ﬁrm ground for under-
standing and reasoning about inter-language communication in
Android hybrid apps. We identify the interoperation semantics
via extensive testing and inspection of the publicly available
Android source code [9]. To formally specify its key features,
dynamic and indistinguishable interoperability, we extend the
existing multi-language calculus [10]. For dynamic interoper-
ations, the extension dynamically builds bridge s across Java
and JavaScript, which allow accesses to Java objects from
JavaScript. For indistinguishable interoperations, it creates a
JavaScript object for a bridge to support an interchangeable
switch of languages from JavaScript to Java. Based on the
extension, we present an operational semantics of Android
interoperability. Moreover, we discuss its numerous unintuitive
and inconsistent behaviors that have not been disclosed by the
existing research.
Taking advantage of the semantics, we also present a light-
weight type system that detects interoperation bugs including
MethodNotFound bugs deﬁned by HybriDroid . While HybriDroid uses
an expensive points-to analysis, our type system is light-weight
with linear time traversal over target apps. We evaluate our
type system on real-world Android hybrid apps, and show that
it detects about twice as many true bugs than HybriDroid with
the average speed-up of 20.7x compared to HybriDroid .
The contributions of this paper include the following:
•We identify complex but under-documented behaviors
in Android hybrid apps. It requires extensive testing
and thorough investigation of Android source code due
to incomplete Android documentation.
•We extend the existing multi-language semantics for
dynamic and indistinguishable interoperability. It may
give an example to specify various inter-language commu-
nications beyond the Android hybrid mechanism.
•We present the ﬁrst formal semantics for Android
interoperability. It provides a formal ground to reason
about Android hybrid apps, and it allows us to uncover
their unintuitive, surprising, and inconsistent behaviors.
•We develop a precise and efﬁcient type system that
detects interoperation bugs. The type system detects
more true bugs more efﬁciently than HybriDroid .
In the rest of the paper, we present key interoperation
features of hybrid apps (Section II) and a formal operational
semantics of Android interoperability from core to wild be-haviors (Section III). Using the formal semantics, we present
a type system for safe interoperability in Android hybrid apps
(Section IV). We evaluate the type system (Section V), discuss
related work (Section VI), and conclude (Section VII).
II. A NDROID INTEROPERABILITY
We describe the Android hybrid mechanism [8] and intro-
duce its key features that are not expressible in the existing
multi-language semantics [10].
A. From Android Java to JavaScript
Android Java code can execute JavaScript code using two
methods. First, evaluateJavascript takes two arguments:
public void evaluateJavascript(
String script, ValueCallback<String> resultCallback)
It executes the ﬁrst string argument denoting JavaScript code,
and invokes the second callback, if any, when the execution
completes. Second, loadUrl loads a given URL:
public void loadUrl(String url)
possibly with given HTTP request headers for the URL:
public void loadUrl(
String url, Map<String,String> additionalHttpHeaders)
It executes JavaScript code embedded in the web page at
the URL. To focus on the core interaction functionality, we
ignore the callback argument for evaluateJavascript and
the HTTP request headers argument for loadUrl . Also, while
loadUrl can take a string argument representing JavaScript
code rather than a URL, we ignore such case because it is the
same as using evaluateJavascript . We assume that Java and
JavaScript code run synchronously for simplicity.
B. From JavaScript to Android Java
JavaScript code executed by evaluateJavascript or
loadUrl can invoke Java methods via objects “injected” by
method addJavascriptInterface :
public void addJavascriptInterface(Object object, String name)
It injects the ﬁrst object argument into the JavaScript context
using the second string argument as a name, which then be-
h a v e sa sa bridge for inter-language communication. Injected
Java objects can be removed from the JavaScript context by
the following method:
public void removeJavascriptInterface(String name)
For example, an instance of class Bridge can be injected
to the JavaScript context by addJavascriptInterface(new
Bridge(), "brg") , and it is mapped as a JavaScript object
named brg. We call such mapped JavaScript objects bridge
objects .
JavaScript code invokes Java methods via bridge objects
in the same way as it calls function properties of JavaScript
objects. For example, for Java method foo in class Bridge ,
JavaScript can invoke the method by brg.foo() . While An-
droid versions 4.2 and above allow only public methods
annotated with @JavascriptInterface to be accessible from
224
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:59:16 UTC from IEEE Xplore.  Restrictions apply. JavaScript, we assume that every method is accessible from
JavaScript for simplicity. Note that Java ﬁelds are not acces-
sible from JavaScript.
C. Dynamic and Indistinguishable Interoperability
We identify two distinct key features in the Android hybrid
mechanism: dynamic and indistinguishable interoperability,
which are not expressible in existing multi-language seman-
tics [10]. We call the existing semantics MFin this paper.
First, Java code accessible from JavaScript changes dy-
namically, for example, by addJavascriptInterface and
removeJavascriptInterface . For example, access to class
Bridge from JavaScript code varies over runtime. On the other
hand, MFcan statically determine the accessibility via ﬁxed
and static bridges. Note that Android supports ﬂexible and
dynamic bridges for inter-language communication.
Second, JavaScript code invokes Java methods in the same
way as it calls function properties of JavaScript objects. Such
syntatically indistinguishable interoperations switch languages
interchangeably while MFintroduces a new kind of expressions
called “syntatic boundaries” to support a switch of languages.
III. A NDROID INTEROPERABILITY SEMANTICS
We present Android interoperation semantics by extending
MFwith bridges. For simplicity, we omit Android-speciﬁc
features like activity life cycles.
A. Models for Java and JavaScript
We ﬁrst present base models for Java and JavaScript in
Fig. 2. Following the convention of MF, we have typeset
non-terminals of Java model using a bold font with serifs ,
and those of JavaScript model with a light sans-serif font.
Occasionally, we use subscripts and superscripts when the font
difference is too subtle to differentiate Java and JavaScript: V
for Java and Sfor JavaScript. Java and JavaScript models are
based on Featherweight Java [11] and λJS[12], respectively.
Java code pconsists of a sequence of object declarations
odfollowed by a sequence of expressions e. For presentation
brevity, we use singleton objects instead of classes because the
interoperations do not utilize features like class inheritance,
constructors, and ﬁelds. An object declaration contains a
sequence of method declarations md. We use Afor an object
name and mfor a method name. A method body is an
expression e, which is either a constant c, a variable x,o r
method invocation. A constant is a number n, an object [A],
ornull . A Java type τvmay be a primitive type ι, an object
A,o r void for internal value (). We describe the operational
semantics in the Felleisen-Hieb small-step operational seman-
tics with evaluation contexts [13]. The operational semantics
is conventional using the following:
MatchType (v,τv)=⎧
⎪⎪⎪⎪⎨
⎪⎪⎪⎪⎩true if(v=n∧τv=ι)
∨(v=[A]∧τv=A)
∨(v=null∧τv=Afor any A)
∨(v=()∧τv=void)
false otherwise
that checks whether a given value has a given type.p::= ode
od::= object A{md}
md::=τvm(τvx){e}
e::= c|x|e.m(e)
c::= n|[A]|null
v::= c|()
τv::=ι|A|void
E::= [] V|E.m(e)|v.m(vE e)
[Jv-Call]object A{md}τvm(τvx){e}∈{ md}
|x|=|v| MatchType (v,τv)
E[[A].m(v)]V→E[e[v/x]]
(a) Java model
e::= c|x|let x=ein e|e.m|e.m=e|e.m(e)
c::= n|[A]|function (x){e}|null
v::= c|undefined
E::= [] S|let x=Ein e|E.m|E.m=e|v.m=E
| E.m(e)|v.m(vE e)
[Js-Let] OE[let x=vin e]S→OE[e[v/x]]
[Js-Load1]O(A.m)= v
OE[[A].m]S→OE[v]
[Js-Load2]A.m/negationslash∈dom(O)
OE[[A].m]S→OE[undefined ]
[Js-Store] OE[[A].m=v]S→O[A.m:=v]E[v]
[Js-Call]O(A.m)=function (x){e}
OE[[A].m(v)]S→OE[e[v/x]]
(b) JavaScript model
Fig. 2: Models for Java and JavaScript
p::= odt
t::= e|add([A])|remove([A])|evaluate (e)
i::=··· |τvVS(e)
E::=··· |τvVS(E)
(a) Extensions to Fig. 2(a)
i::=··· | SVτv(e) v::=··· | bridge m
E::=··· | SVτv(E)
(b) Extensions to Fig. 2(b)
Fig. 3: Extended models for interoperability
A JavaScript expression eis a constant c, a variable x,
variable binding, property load, property store, or property call.
A constant is a number n, an object [A], a ﬁrst-class function
function (x){e},o r null . We omit features like property
deletion and prototypes that do not affect the interoperations.
The operational semantics is conventional as well using object
tableOthat maps object properties to their values.
225
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:59:16 UTC from IEEE Xplore.  Restrictions apply. B. Extended Models for Interoperability
To support interoperations, we extend each base model.
Fig. 3(a) and Fig. 3(b) show extensions to the base Java
and JavaScript models, respectively. They introduce additional
expressionsτvVS(e)and SVτv(e)to indicate switches of lan-
guages.τvVS(e)denotes a Java boundary expression of type
τvthat contains JavaScript expression e. Similarly, SVτv(e)
denotes a JavaScript boundary expression that contains Java
expression eof type τv. For indistinguishable interoperability,
external syntax edoes not include its cross-language boundary;
SVτv(e)is an internal expression icreated at run time.
For dynamic interoperability, Fig. 3(a) speciﬁes dynamic
creation and destruction of a bridge using add([A])and
remove([A]), respectively: add([A])enables access to a Java
object [A]from JavaScript; and remove([A])withdraws the
accessibility of [A]. Without loss of generality, we assume
that JavaScript code uses a JavaScript object [A]to exploit a
bridge for [A]. We call such JavaScript objects bridge objects .
Another additional expression evaluate (e)in Fig. 3(a)
indicates two methods loadUrl andevaluateJavascript that
Android provides to execute JavaScript code from Java code.
Because both loadUrl andevaluateJavascript always return
values of type void , the extended model initiates interoper-
ations via evaluate (e)instead of boundaryτvVS(e). Thus,
Fig. 3(a) includes evaluate (e)in external syntax eand hides
τvVS(e)under internal syntax i.
Using this model, we can simplify Android interoperations.
Consider the following Android Java code:
class A {
@JavascriptInterface
public int m(int x) { return x; }
}
WebView webView = ...;
webView.addJavascriptInterface(new A(), "a");
webView.evaluateJavascript("a.m(undefined);");
which injects an instance of class Ainto the JavaScript context
with name a, and evaluates JavaScript code a.m(undefined)
invoking Java method m. We encode it as follows in our model:
object A{ιm(ιx){x}}
add([A])
evaluate ([A].m(undefined ))
We will describe reduction steps of such code in following
subsections using context-sensitive reduction rules as with MF;
we use an evaluation context Efor Java and Efor JavaScript.
Also, we establish Eas a top-level evaluation context Eto
indicate that the top-level program is written in Java.
Note that our model prohibits nested interoperability by
separating bridging operations, add([A]),remove([A]), and
evaluate (e), from normal operations even though Android
allows nested interoperations. However, our model still can
represent the exact Android interoperation behaviors because
of the asynchronous feature that we discuss in Section III-D.
C. Core Interoperation Semantics
We present the “core” interoperability semantics ﬁrst, and
then extend it to describe quirky behaviors that we discovered.[Jv-Add]B/prime=B∪{([A],[A])}
BOE[add([A])]V→B/primeOE[()]
[Jv-Remove]B/prime=B\{([A],[A])}
BOE[remove([A])]V→B/primeOE[()]
[Jv-Evaluate] B=([A],[A])
object A{τvm(τvx){e}} O/prime=(A.m,bridge m)
BOE[evaluate (e)]V→BO/primeE[voidVS(e)]
[Jv-VS-V oid] BOE[voidVS(v)]V→BOE [()]
[Jv-VS-Num1] BOE[ιVS(n)]V→BOE [n]
[Jv-VS-Num2]v/negationslash=n
BOE[ιVS(v)]V→BOE [0]
[Jv-VS-Obj1]B([A])=[A]
BOE[AVS([A])]V→BOE [[A]]
[Jv-VS-Obj2]v/negationslash∈dom(B)
BOE[AVS(v)]V→BOE [null]
[Jv-VS-Obj3] B([A])/negationslash=[A]
BOE[AVS([A])]V/squigglerighterror"incompatible object"
(a) Extended Java semantics
[Js-JsCall]O(A.m)=function (x){e}
BOE[[A].m(v)]S→BOE [e[v/x]]
[Js-JvCall1] O(A.m)=bridge m/primeB([A])=[A]
object A{md}τvm/prime(τvx){e}∈{ md}| x|=|v|
BOE[[A].m(v)]S→BOE [SVτv([A].m/prime(τvVS(v)))]
[Js-JvCall2] O(A.m)=bridge m/primeB([A])=[A]
object A{md}τvm/prime(τvx){e} /negationslash∈{ md}| x|=|v|
BOE[[A].m(v)]S/squigglerighterror "no bridge method"
[Js-JvCall3]O(A.m)=bridge m/prime[A]/negationslash=dom(B)
BOE[[A].m(v)]S/squigglerighterror "non-bridge object"
[Js-SV-V oid] BOE[SVvoid(())]S→BOE [undefined ]
[Js-SV-Num] BOE[SVι(n)]S→BOE [n]
[Js-SV-Obj1]([A],[A])∈B
BOE[SVA([A])]S→BOE [[A]]
[Js-SV-Obj2] ([A],[A])/negationslash∈B object A{τvm(τvx){e}}
B/prime=B∪{([A],[A])}O/prime=O∪{(A.m,bridge m)}
BOE[SVA([A])]S→B/primeO/primeE[[A]]
(b) Extended JavaScript semantics
Fig. 4: Core interoperation semantics
Fig. 4(a) shows the semantics of bridge creation, destruc-
tion, and provision. Rules [Jv-Add] and [Jv-Remove] create
and destruct bridges, respectively, by updating bridge table
B. Rule [Jv-Evaluate] provides available bridges in Bto the
JavaScript context by updating object table Owith properties
of bridge objects. A bridge object [A]contains methods
of[A]as its properties: (A.m,bridge m)where bridge m
denotes a Java method named min the JavaScript context,
called a bridge method . Fig. 4(b) shows the semantics of
bridge objects and bridge methods, which intermingle with
those of JavaScript expressions for indistinguishable interop-
226
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:59:16 UTC from IEEE Xplore.  Restrictions apply. erability. While we present the intermingled semantics in the
Android hybrid mechanism in this paper, we can describe
various interoperability semantics based on our formalization.
For example, consider Java™ Plug-In [14] and Rhino [15]
supporting communication between JavaScript code and Java
applets running on a web page. While they have different
semantics from that of Android, they also provide dynamic and
indistinguishable communication between Java and JavaScript.
Thanks to such common ground, we can use the Android
interoperation semantics as a reference when specifying their
semantics. As an example, we present an operational semantics
of Java™ Plug-In in a companion report [16].
1) Method Overloading Resolution in JavaScript: While
Java supports overloaded methods having the same name
but with different signatures, JavaScript does not provide
overloaded functions. Moreover, JavaScript allows any number
of arguments for a function call regardless of the number of
function parameters at its declaration site.
The Android hybrid mechanism partially supports over-
loaded Java methods; it selects a Java method to invoke
from a list of available method declarations in a given Java
object using the name and the arity of a method call. When
there are multiple method declarations with the same name
and the same arity but with different parameter types, it
does not guarantee which method is called. When no method
declarations have the same name and the arity of a given
method call, it throws a “Method not found” exception. Rule
[Js-JvCall1] in Fig. 4(b) speciﬁes a successful Java method call
from JavaScript code; calling a bridge method bridge m/primeon
a bridge object [A]with JavaScript values v. First, it searches
for a Java method τvm/prime(τvx){e}to invoke using the bridge
method name m/primeand the number of arguments |v|. Then, it
converts the arguments to Java values byτvVS(v), invokes
the Java method with the converted values, and converts
the method call result via SVτv. Rule [Js-JvCall2] speciﬁes
exception "no bridge method" when it cannot ﬁnd the Java
method. We use /squigglerightfor exception-throwing rules to distinguish
them from normal reduction rules.
2) First-Class Java Methods: While JavaScript functions
are ﬁrst-class values, Java methods are not. Java methods in-
jected to the JavaScript context, which we call bridge methods,
are considered as ﬁrst-class values; we can assign them to
variables or set them as object properties. However, they do
not behave like normal JavaScript functions. For example, we
can set a JavaScript object property with a bridge method foo
of a bridge object brg as follows:
jsObj = {}
jsObj.bar = brg.foo;
but calling the property jsObj.bar() throws a “Java bridge
method can’t be invoked on a non-injected object” exception.
Rule [Js-JvCall3] throws exception "non-bridge object" for
bridge method calls on non-bridge (normal) objects.
3) V alue Conversion between Java and JavaScript: Java
and JavaScript have different values with different type sys-
tems. While Java provides user-deﬁned types by staticallydeclared classes, JavaScript does not support them but it allows
users to construct and update objects at run time.
Android provides implicit value conversion between Java
and JavaScript. When JavaScript code invokes a Java method
with JavaScript values, Android converts the arguments to
Java values of the method’s parameter types. When values
to be converted are inconsistent with given types, Android
uses default values like 0for a number and null for an
object as shown in rules [Jv-VS-Num2] and [Jv-VS-Obj2] in
Fig. 4(a). Rule [Jv-VS-Obj3] shows an unacceptable value
conversion; converting a bridge object to a Java object of an
incompatible type throws exception "incompatible object" .
After invoking a Java method from JavaScript code, its result is
converted to a JavaScript value. This conversion may implicitly
inject Java objects to the JavaScript context. Consider rules
[Js-SV-Obj1] and [Js-SV-Obj2] in Fig. 4(b) representing conver-
sions from a Java object to a JavaScript object. If the Java
object is already injected to the JavaScript context, Android
uses the corresponding bridge object ( [Js-SV-Obj1] ). Otherwise,
it dynamically injects the Java object to the JavaScript context
on demand ( [Js-SV-Obj2] ).
D. Extensions for Wild Interoperation
Now, let us extend the core semantics to express wild
Android interoperation behaviors.
1) Multiple Bridge Objects for Single Java Object: A
single Java object can be bound to multiple bridge objects.
For example, the following code:
1Bridge obj = new Bridge();
2addJavascriptInterface(obj, "b1");
3addJavascriptInterface(obj, "b2");
4loadUrl("file:///android_asset/www/index.html");
injects the same Java object obj into the JavaScript context
with two different names b1and b2on lines 2 and 3.
Because Android creates a new bridge object for a given name
rather than for a given Java object, it maintains many-to-one
mappings from bridge objects to Java objects. Thus, JavaScript
code can make independent updates on b1and b2, which do
not reﬂect to each other nor to the original Java object obj.
This functionality may be useful but it incurs unintuitive
semantics. For instance, suppose that the above obj contains
method identity that returns itself as it is, and that loading
the above index.html executes the following JavaScript code:
b1.print = function() { console.log("b1"); };
b2.print = function() { console.log("b2"); };
b2.identity().print();
The code adds a property named print with a JavaScript
function value to both bridge objects b1and b2. One may
expect that b2.identity() would return b2as it is, thus
b2.identity().print() would log "b2" to the console. How-
ever, unfortunately, it may log "b1" rather than "b2" because,
when b2.identity() returns a Java object, Android does not
guarantee to ﬁnd the correct bridge object ( b2) from multiple
bridge objects ( b1and b2). In short, Android uses many-to-
227
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:59:16 UTC from IEEE Xplore.  Restrictions apply. one mappings from bridge objects to Java objects, which bring
buggy results from Java method calls.
We can extend the core semantics to specify many-to-
one mappings from bridge objects to Java objects. While
the core semantics represents one-to-one mappings by the
implicit correspondence between a Java object [A]and its
bridge object [A], we can extend it to the correspondence
between a Java object [A]and its multiple bridge objects
{[A]}. Then, rule [Js-SV-Obj1] does not guarantee which bridge
object among multiple ones would be returned.
2) Bridge Objects without Matching Java Objects: Android
provides two methods loadUrl and evaluateJavascript to
execute JavaScript code from Java code, but they provide
bridges to the JavaScript context differently. loadUrl al-
ways provides new bridges while evaluateJavascript pro-
vides new bridges only when Android executes JavaScript
code for the ﬁrst time. With these new bridges, JavaScript
code cannot access previous implicitly-injected Java ob-
jects. Also, loadUrl clears the JavaScript context except for
its ﬁrst call, but evaluateJavascript does not clear the
JavaScript context. Therefore, sequentially invoking methods
evaluateJavascript and loadUrl may lead to unintuitive
behaviors. For example:
addJavascriptInterface(new Bridge(), "brg");
evaluateJavascript("var b = brg.create(); ... ");
loadUrl("file:///android_asset/www/index.html");
JavaScript code executed by evaluateJavascript implicitly
injects a Java object as a result of brg.create() ,b u t loadUrl
disallows access to the injected object while preserving its
bridge object b. In short, even though the Java object is no
longer accessible from JavaScript, its corresponding bridge
object is retained in the JavaScript context. Thus, if the
JavaScript code in index.html invokes Java methods via b,
it results in application crash.
We can describe such wild behaviors by classifying
evaluate (e)according to its behaviors and deﬁning its seman-
tics differently. We distinguish three kinds of evaluate (e):1 )
it provides new bridges to a new JavaScript context, which rep-
resents evaluateJavascript that executes JavaScript code for
the ﬁrst time and loadUrl after the ﬁrst call, 2) it provides new
bridges to the existing JavaScript context, which represents the
ﬁrst call of loadUrl , and 3) it provides the existing bridges to
the existing JavaScript context. Rule [Jv-Evaluate] in Fig. 4(a)
speciﬁes the ﬁrst case where a JavaScript expression is exe-
cuted under newly constructed object table {(A.m,bridge m)}.
The second case is as follows:
BE={([A],[A])} object A{τvm(τvx){e}}
{([A/prime],[A/prime])}⊆B { [A/prime]}∩{[A]}=∅
B/prime=BE∪{([A/prime],[])]}
O/prime=(O\{(A.m/prime,)})∪{(A.m,bridge m)}
BEBOE[evaluate (e)]V→BEB/primeO/primeE[voidVS(e)]
By separately maintaining explicitly-injected Java objects in
BE, it identiﬁes previous implicitly-injected Java objects [A/prime][Js-Cache1][A]/negationslash∈dom(B)
CBOE [[A].m]S→CBOE [access([A],m)]
[Js-Cache2][A]∈dom(B)( A.m,JS)∈C
CBOE [[A].m]S→CBOE [access([A],m)]
[Js-Cache3][A]∈dom(B)( A.m,JV)∈C
CBOE [[A].m]S→CBOE [bridge m]
[Js-Cache4]([A],[A])∈B A.m/negationslash∈dom(C) object A{md}
τvm(τvx){e}∈{ md}C/prime=C∪{(A.m,JV)}
CBOE [[A].m]S→C/primeBOE[bridge m]
[Js-Cache5]([A],[A])∈B A.m/negationslash∈dom(C) object A{md}
τvm(τvx){e} /negationslash∈{ md}C/prime=C∪{(A.m,JS)}
CBOE [[A].m]S→C/primeBOE[access([A],m)]
Fig. 5: Cached property accesses of bridge objects
and disables accesses to them while retaining their bridge
objects by mapping the bridge objects to dummy objects [].
Note that the JavaScript code is executed with new bridges on
top of the existing object table O. Finally, for the third case,
we use the existing object table as it is for the JavaScript
code execution. Because the JavaScript context may contain
bridge objects without corresponding Java objects, various
unexpected behaviors may happen.
3) Cached Accesses of Bridge Object Properties: Bridge
objects behave differently for different properties. Consider a
bridge object brg for a Java object obj:
Bridge obj = new Bridge();
addJavascriptInterface(obj, "brg");
where obj contains a method named foo, but no methods
named bar. It is okay to add a property named bar tobrg,t o
modify it, and even to delete it from brg though such actions
do not get reﬂected to obj. However, modifying or deleting
properties whose names already exist in the corresponding
Java object is silently ignored. Thus, JavaScript code brg.foo
=4evaluates to 4, but it does not change the value of brg.foo
to 4. Moreover, reconsidering the example in Section III-D2:
addJavascriptInterface(new Bridge(), "brg");
evaluateJavascript("var b = brg.create(); ... ");
loadUrl("file:///android_asset/www/index.html");
One more quirky semantics exists here. If bridge object
property b.print has a non-Java value such as a JavaScript
function, evaluation of b.print() inindex.html produces
different results depending on whether b.print was accessed
or not in the ... part. This surprising behavior is due to
the cached lookup process; because Android caches access
of bridge object properties, b.print is still accessible in
index.html if it was accessed before loadUrl .
Fig. 5 formally speciﬁes cached access of bridge object
properties in Android. Cache Crecords accessed properties of
a bridge object; C(A.m)= JSdenotes that property A.mwas
accessed and has a usual JavaScript value, and C(A.m)= JV
denotes that property A.mwas accessed and its value comes
from the Java context. Rule [Js-Cache1] speciﬁes that the prop-
228
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:59:16 UTC from IEEE Xplore.  Restrictions apply. erty accesses of normal JavaScript objects behave the same,
where access([A],m)follows rules [Js-Load1] and [Js-Load2]
in Fig. 2(b). Rules [Js-Cache2] and [Js-Cache3] represent when a
property of a bridge object has a cached JavaScript value and a
cached bridge method, respectively. The last two rules are for
cache misses, where the cache is extended with a new property
information: (A.m,JV)or(A.m,JS). Using caches for bridge-
object lookup may be efﬁcient, but, given the unintuitive
semantics, actual beneﬁts may be questionable.
4) Asynchronous Boundaries: Android’s loadUrl and
evaluateJavascript execute JavaScript code asynchronously,
making nested interoperations behave in an unintuitive manner.
Consider Java class NestedBr having the following method:
@JavascriptInterface
public void inter() {
evaluateJavascript(
"brg.name = function() { console.log(’brg’) };");
}
and consider the following Java code:
addJavascriptInterface(new NestedBr(), "brg")
evaluateJavascript("brg.inter(); brg.name();")
One may expect that brg.name() would log "brg" to the
console because call to evaluateJavascript inbrg.inter()
stores a log function to property brg.name . However, it
throws a type error rather than printing "brg" . Because
the evaluateJavascript method executes JavaScript code
asynchronously, brg.inter() terminates without the prop-
erty assignment; it updates the property after the previous
evaluateJavascript call ﬁnishes. Thus, brg.name() raises
an exception for calling the undefined value.
Since asynchronous boundaries do not affect the interoper-
ation semantics besides the nested interoperation, we exclude
them in this paper.
IV . T YPE SYSTEM FOR SAFE HYBRID APPS
In this section, as an application of the formal semantics,
we deﬁne safety of Android interoperability and devise a type
system that detects unsafe interoperations.
A. Preventing the Bugs Detected by HybriDroid
We deﬁne the safety as absence of error MethodNotFound
that HybriDroid [7] detects from Android hybrid apps, and we
design a type system detecting the MethodNotFound errors.
1) Safety: Safe interoperations involve no MethodNotFound
errors deﬁned by HybriDroid :
When a bridge method call cannot ﬁnd any target
Java method to call, the bug detector reports error
MethodNotFound , which may be due to three reasons.
The ﬁrst case is when a developer makes a typo in the
bridge method name or indeed calls an undeﬁned method
of an injected object. The second case is when a target
Java method is inaccessible either because it is private or
it does not have the @JavascriptInterface annotation
when the target Android version is 4.2 or later. Finally,[T-Jv-Add] ΓB˜O/turnstileleft add([A]):void/B∪{([A],[A])}˜O
[T-Jv-Remove] ΓB˜O/turnstileleft remove([A]):void/B\{([A],[A])}˜O
[T-Jv-Evaluate]B=([A],[A]) object A{τvm(τvx){e}}
ΓB(A.m,FunV(m))/turnstilelefte:τs/B/prime˜O/prime
ΓB˜O/turnstileleft evaluate (e):void/B/prime˜O/prime
[T-Jv-VS]ΓB˜O/turnstileleft e:τs/B/prime˜O/prime
ΓB˜O/turnstileleftτvVS(e):τv/B/prime˜O/prime
Fig. 6: Type system for Java
the third case is when a bridge method call has a wrong
number of arguments.
The three cases represent possible failure scenarios in ﬁnding
a corresponding Java method from a given property call on a
bridge object. The ﬁrst two cases stand for undeﬁned property
calls, and the third case indicates bridge method calls with a
wrong number of arguments. Formally speaking:
Deﬁnition 1 (Safety): Top-level expression eis safe (in terms
of interoperability) if for any OandB
•e/negationslash=E[[A].m(v)]Swhere ([A],[A])∈B,A.m/negationslash∈dom(O),
and
•e/negationslash=E[[A].m(v)]Swhere ([A],[A])∈B ,O(A.m)=
bridge m/prime,object A{md},τvm/prime(τvx){e} /negationslash∈{ md},
|x|=|v|.
2) Type System: For simplicity, the type system detects only
unsafe interoperations; it does not detect traditional type errors
but extending it to detect them as well is straightforward. Java
and JavaScript expressions share type environments; type table
Γmaps variables to their types, bridge table Bkeeps bridges,
and object table ˜Omaps object properties to their types.
Fig. 6 presents a type system snippet for Java; the rest rules
are conventional. The full type system is available in a com-
panion report [16]. Rules [T-Jv-Add] and [T-Jv-Remove] main-
tain bridges in B. Rule [T-Jv-Evaluate] builds an object table
based on Bto type-check JavaScript code; it checks the type
ofeunder a newly constructed object table (A.m,FunV(m))
where FunV(m)denotes a JavaScript type for Java methods
named min the JavaScript context. The typing rule for Java
boundaryτvVS(e)checks the type of the wrapped JavaScript
expression e. To focus on interoperability, we assume that Java
objects and their method declarations are well-typed.
Fig. 7 presents a type system snippet for JavaScript. We
introduce a simple type hierarchy with six kinds of JavaScript
typeτs:FunS(x,e)for JavaScript function, FunV(m)for bridge
method bridge m,ObjS(A)for pure JavaScript object [A],
ObjV(A,A)for bridge object [A],Obj(A)for encompassing
ObjS(A)and ObjV(A,A), and/latticetopfor encompassing all JavaScript
types. We use helper function CheckTypes to type-check a
series of expressions.
Three typing rules for e.m(e)in Fig. 7 check the type of
the callee function e.m. If the type is FunS(x,e), it checks
the argument expressions and the function body ( [T-Js-JsCall] ).
229
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:59:16 UTC from IEEE Xplore.  Restrictions apply. τs::= FunS(x,e)|FunV(m)|ObjS(A)|ObjV(A,A)|Obj(A)|/latticetop
τs<:/latticetop ObjS(A)<:Obj(A) ObjV(A,A)<:Obj(A)
[T-Js-Fun] ΓB˜O/turnstileleft function (x){e}:FunS(x,e)/B˜O
[T-Js-Bridge] ΓB˜O/turnstileleft bridge m:FunV(m)/B˜O
[T-Js-JsObj][A]/negationslash∈dom(B)
ΓB˜O/turnstileleft [A]:ObjS(A)/B˜O
[T-Js-BrgObj]([A],[A])∈B
ΓB˜O/turnstileleft [A]:ObjV(A,A)/B˜O
[T-Js-JsCall]
ΓB˜O/turnstileleft e:Obj(A)/B/prime˜O/prime(A.m,FunS(x,e/prime))∈˜O/prime
τsB/prime/prime˜O/prime/prime=CheckTypes (ΓB/prime˜O/primee)
Γ∪{(x,τs)}B/prime/prime˜O/prime/prime/turnstilelefte/prime:τs/B/prime/prime/prime˜O/prime/prime/prime
ΓB˜O/turnstileleft e.m(e):τs/B/prime/prime/prime˜O/prime/prime/prime
[T-Js-JvCall1]
ΓB˜O/turnstileleft e:ObjV(A,A)/B/prime˜O/prime(A.m,FunV(m/prime))∈˜O/prime
object A{md}τvm/prime(τvx){e}∈{ md}| x|=|e|
τvB/prime/prime˜O/prime/prime=CheckTypes (ΓB/prime˜O/primeτvVS(e))
Γ∪{(x,τv)}B/prime/prime˜O/prime/prime/turnstileleftSVτv(e):τs/B/prime/prime/prime˜O/prime/prime/prime
ΓB˜O/turnstileleft e.m(e):τs/B/prime/prime/prime˜O/prime/prime/prime
[T-Js-JvCall2]
ΓB˜O/turnstileleft e:ObjS(A)/B/prime˜O/prime(A.m,FunV(m/prime))∈˜O/prime
τsB/prime/prime˜O/prime/prime=CheckTypes (ΓB/prime˜O/primee)
ΓB˜O/turnstileleft e.m(e):/latticetop/B/prime/prime˜O/prime/prime
[T-Js-SV1]τv/negationslash=A
ΓB˜O/turnstileleft SVτv(e):/latticetop/B˜O
[T-Js-SV2]([A],[A])∈B
ΓB˜O/turnstileleft SVA(e):ObjV(A,A)/B˜O
[T-Js-SV3]
([A],[A])/negationslash∈B object A{τvm(τvx){e}}
B/prime=B∪{([A],[A])}˜O/prime=˜O∪{(A.m,FunV(m))}
ΓB˜O/turnstileleft SVA(e):ObjV(A,A)/B/prime˜O/prime
Fig. 7: Type system for JavaScript
If the type of the callee is FunV(m), the callee is a bridge
method named m. When a receiver object is a bridge object, the
corresponding Java object [A]should contain a declaration of
method m([T-Js-JvCall1] ). Rule [T-Js-JvCall1] checks the types
of the converted argumentsτvVS(e)and of the converted result
SVτv(e). Note that typing rules [T-Js-JvCall1] and [T-Js-JvCall2]
correspond to [Js-JvCall1] and [Js-JvCall3] , respectively; there
is no typing rule for [Js-JvCall2] denoting the MethodNotFound
error. The typing rule for SVA(e)with a not-yet-injected Java
object [A]injects the Java object to the JavaScript context by
introducing it to the object table ( [T-Jv-SV3] ).
Based on the formal semantics and the type system, we can
show that a well-typed Android hybrid app does not contain
any evaluation contexts that lead to error MethodNotFound . The
full type system and proof using well-typed object tables [17]
are available in a companion report [16].[T-Js-Store1]
ΓB˜O/turnstileleft e:ObjS(A)/B/prime˜O/primeΓB/prime˜O/prime/turnstilelefte/prime:τs/B/prime/prime˜O/prime/prime
ΓB˜O/turnstileleft e.m=e/prime:τs/B/prime/prime˜O/prime/prime[A.m:=τs]
[T-Js-Store2]ΓB˜O/turnstileleft e:ObjV(A,A)/B/prime˜O/primeobject A{md}
τvm(τvx){e} /negationslash∈{ md}ΓB/prime˜O/prime/turnstilelefte/prime:τs/B/prime/prime˜O/prime/prime
ΓB˜O/turnstileleft e.m=e/prime:τs/B/prime/prime˜O/prime/prime[A.m:=τs]
Fig. 8: Extensions to Fig. 7
B. Extensions for Preventing Quirky Behaviors of Cached
Property Access
We show how to extend the type system to prevent un-
intuitive behaviors discussed in Section III-D. We focus on
quirks caused by cached access of bridge object properties
(in Section III-D3) because the other quirks can be simply
avoided; 1) multiple bridge objects for a Java object (in
Section III-D1) can be syntactically checked and 2) bridge
objects without corresponding Java objects (in Section III-D2)
never happen in Android versions 7.0 and above. Note that we
do not consider asynchronous boundaries (in Section III-D4)
either because the asynchrony is orthogonal to the Android
interoperation semantics.
1) Safety: Reconsider the quirky behaviors due to cached
property access:
Bridge objects behave differently for different properties.
...However, modifying or deleting properties whose
names already exist in the corresponding Java object is
silently ignored.
Such ignored property assignments make property accesses to
bridge objects difﬁcult to understand, leading to programming
errors. Thus, we extend the safety with coherence between
assignments and accesses to bridge object properties; in safe
Android hybrid apps, JavaScript changes bridge objects only
with properties whose names do not overlap with those of the
corresponding Java objects. We extend Deﬁnition 1 as follows:
Deﬁnition 2 (Safety): Top-level expressions eis safe if
•e/negationslash=E[[A].m = v]Swhere ([A],[A])∈B ,
object A{md},τvm(τvx){e}∈{ md}.
2) Type System: We now extend the type system in Sec-
tion IV-A for the new safe interoperability. We change only
the typing rules for property assignment as shown in Fig. 8.
Property assignment to JavaScript objects can be conducted
without any constraints ( [T-Js-Store1] ). On the other hand,
assignment to bridge objects are constrained to use properties
whose names do not exist in the corresponding Java objects
([T-Js-Store2] ). We show that the extensions provide the new
safe interoperability with the proof in a companion report [16].
V. E V ALUATION
In this section, we evaluate our implementation of the type
system in terms of soundness, precision, and efﬁciency.
230
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:59:16 UTC from IEEE Xplore.  Restrictions apply. TABLE I: Interoperation bug detection results
HybriDroid Ours
Target #BugsTime#BugsTime SpeedHybrid AppFP TP (sec.)FP due to FP due toTP Cause(#) (sec.) upHybriDroid Rules
com.app.sophosi - - - 0 0 0 16.1 -
com.appliclub1410 - - - 0 1 0 181.4 -
com.dhobilite - - - 0 1 0 13.6 -
com.eclectictt - - - 0 0 0 18.0 -
com.gameloft.android.ANMP.GloftA3HM 0 0 54.3 1 0 1 Obfuscation(1) 2.1 25.9×
com.gameloft.android.ANMP.GloftPEHM 0 0 276.4 6 0 13 No Annotation(1) 26.8 10.3×
Obfuscation(12)
com.ibs.sketch 0 0 5.5 1 0 0 1.6 3.4×
com.lenovo.anyshare.cloneit 0 1 42.8 0 0 1 No Method(1) 0.8 10.2×
com.officeon_b - - - 0 0 0 24.5 -
com.PrankFingerPregnancyTest2 0 0 118.0 1 0 0 8.0 6.2×
com.wirelesstag.android3 - - - 0 3 0 35.8 -
europe.de.ftdevelop.aviation.toolknife 0 1 305.0 0 0 1 No Annotation(1) 7.9 38.6×
mediavision.handwallet 3 5 111.4 2 0 4 Obfuscation(4) 7.2 15.5×
pozdravuha.ru.pozdravleniya 0 1 36.4 0 0 1 Obfuscation(1) 2.2 16.5×
Total 3 8 11 5 21
Fig. 9: Overview of the type system implementation
A. Implementation
We implemented our type system using two open-source
tools, HybriDroid [7] and SAFE [18]. As rule [T-Jv-Evaluate]
in Fig. 6 speciﬁes, we need to collect bridges in bridge
tableBand to construct object table ˜Oin order to type-
check JavaScript code. We use the front-end of HybriDroid to
extract JavaScript code and its available bridges from Android
hybrid apps. We modiﬁed HybriDroid to extract only necessary
information without running its full analysis and to record
this information in JSON format. We also use the front-end
of SAFE to generate JavaScript intermediate representation
that is suitable for type checking. Then, we implemented a
type checker that constructs a bridge table and an object table
from the recorded information and checks the type of the
JavaScript code received from SAFE. Fig. 9 illustrates the
overall architecture of the implementation. The source code
of our tool is open to the public [19].
To address complex and extremely dynamic features of
JavaScript, we extend the JavaScript typing rules in Fig. 7 and
Fig. 8. First, we revise the simple type hierarchy of JavaScript
to address functions as objects by making function types and
bridge method types subtypes of object types. Second, we
extend typing rules for function calls so that constructor calls,
recursive calls, and unknown function calls have type /latticetop, which
may be imprecise but sound. Third, we extend typing rules for
property read and write so that any accesses with non-literal
property names have type /latticetop. Finally, any language-constructs
joining multiple values, such as conditional expressions and
loops, have type /latticetop. Even though our revised type system is
aggressively losing precision, the experimental results in thenext section show that it works well in practice.
B. Interoperation Bug Detection
To evaluate the soundness, precision, and efﬁciency of our
type system, we compare its bug detection results with those of
HybriDroid . The state-of-the-art static analyzer for Android hy-
brid apps, HybriDroid , conducts a costly ﬂow-insensitive points-
to analysis but with no formal ground, while our type system
performs a light-weight linear traversal based on the formal
interoperation semantics. For fair comparison, our experiments
use the latest version of HybriDroid , which is much faster than
its predecessor. We performed all the experiments on a Linux
machine with 3.4GHz Intel Core i7 and 32GB Memory.
For analysis targets, we collected 231 real-world Android
hybrid apps: 135 apps from PlayDrone [3] and 96 apps
from AndroZoo [20]. Because HybriDroid collected hybrid apps
from PlayDrone, we used PlayDrone for the fair comparison.
In addition, because PlayDrone crawls apps from the 2014
Google Play store, we used AndroZoo as well to collect more
up-to-date hybrid apps. From AndroZoo, we selected apps that
are deployed more than 10 times in 2018 because they are
likely to be well-maintained.
Table I summarizes the experimental results for AndroZoo
dataset, especially for 14 hybrid apps that either HybriDroid or
the type system fails to terminate or reports interoperation bugs
for. The ﬁrst column shows target apps, and the rest presents
the numbers of false and true bugs, and the execution time in
seconds for both HybriDroid and the type system. The execution
time does not include the preparation time of HybriDroid , such
as crawling JavaScript code to analyze, that is common for
both HybriDroid and the type system. All ﬁgures in the table
are averaged over 5 runs, and a dash (-) indicates a failure of
analysis to terminate within 24 hours. We do not present the
evaluation results for PlayDrone dataset in this paper because
they show similar results to those for AndroZoo.
a) Soundness: The type checker detects 21 true inter-
operation bugs for the target subjects while HybriDroid reports
only 8 true bugs. All the true bugs are MethodNotFound bugs
caused by calling obfuscated methods with non-obfuscated
231
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:59:16 UTC from IEEE Xplore.  Restrictions apply. names, methods not annotated with @JavascriptInterface ,
or undeclared methods. We reported these bugs to the cor-
responding developers. Note that the type checker did not
ﬁnd any bugs caused by cached property accesses. We man-
ually investigated inter-language communication patterns in
the target subjects and observed that developers use simple
patterns defensively, which may explain why the type checker
detected only MethodNotFound bugs. Also, the type checker
ﬁnds all the true bugs detected by HybriDroid except one in
mediavision.handwallet . We manually examined the missed
true bug and found out that it is wrapped in an event call-
back registered by HTML DOM method addEventListener .
Because the type system does not handle addEventListener
unlike HybriDroid , it considers the buggy code unreachable. We
believe that we can detect the bug when we introduce a model
for event callbacks to the type system. The type checker also
ﬁnds 14 more true bugs that HybriDroid fails to detect. We found
a soundness bug in HybriDroid , conﬁrmed by the authors.
b) Precision: The type checker reports 13 more false
positives than HybriDroid , but only ﬁve of them are due to
the type checking rules themselves as shown in Table I. We
manually investigated them and found out that they are due
to the imprecise type checking rule for dynamic property call
obj[prop](...) where prop is not a literal. The type system
simply gives type /latticetopfor such dynamic property accesses and
forbids property calls of type /latticetop, which is sound but imprecise.
The other 11 false positives are due to the incorrect bridge
information extracted by the imprecise front-end of HybriDroid .
While HybriDroid and our type system share the imprecise
front-end, HybriDroid reports only two of 11 false positives
in common. It does not report the rest nine false positives
because of its soundness bug ironically; HybriDroid does not
analyze some inter-language communications. We believe that
we can remove the false positives by replacing the front-end
ofHybriDroid with a precise analyzer.
c) Efﬁciency: While HybriDroid takes 5.5 seconds to more
than 24 hours in analyzing hybrid apps, the type checker takes
0.8 seconds to 181.4 seconds. As expected, the type checker
detects interoperation bugs much faster than HybriDroid for all
the subjects. The type checker shows the average speed-up
of 15.8x compared to HybriDroid ; we omitted the apps that
HybriDroid fails to analyze within the time limit from the
calculation of the average speed-up.
VI. R ELATED WORK
A. Analysis of Android hybrid apps
Researchers have revealed security vulnerabilities in An-
droid hybrid apps, and developed analyzers that defend the
apps against the vulnerabilities. [5] and [21] reported the
security issue that no access control policy governs the An-
droid interoperability, and proposed alternative policies. [4]
reported new code injection attacks exploiting the Android
interoperability, and they developed an analysis that detects
potential injection ﬂaws. While they propose defence mecha-
nisms for security vulnerabilities utilizing the interoperability,
we formalize the interoperation semantics.Recent research has developed static analyzers that address
control ﬂows between Java and JavaScript. While [6] built
control ﬂow graphs of JavaScript and Java separately and
added edges between them in a heuristic matter, HybriDroid [7]
tracked ﬂows seamlessly and detected interoperation bugs in
real-world Android hybrid apps. Unlike HybriDroid , our type
system is based on a formal semantics, which enables to
uncover unintuitive, surprising interoperation behaviors, and
to detect the bugs efﬁciently.
B. Semantics for multi-language programs
Researchers have studied multi-language semantics using
Java™ Native Interface (JNI) [22]. Jeannie [23] is a language
that integrates Java and C by compiling Jeannie to JNI,
but its inter-language communication semantics are described
informally using examples. JNI Light (JNIL) [24] formally
describes interoperations between Java bytecode and assembly
code. Similarly for JNIL, we formally describe interoperability
in Java and JavaScript code, but our semantics is for high-level
languages, in particular for typed and untyped languages.
Researchers also studied the interaction between typed
and untyped languages. [10] used a syntactic boundary as a
key construct for interoperations, and used a guard for the
boundary to preserve type soundness. While [10] separated
interoperations from normal operations via explicit syntactic
boundaries, we do not distinguish them syntactically because
the Android hybrid mechanism identiﬁes such interoperations
at run time. We also provide a way to control the interoper-
ability granularity via bridges . [25] proposed a safe inheritance
model between typed and untyped languages. We may apply
the model to Android by creating JavaScript objects that inherit
properties of Java classes, and by calling bridge methods
using super calls. However, because the model prohibits bridge
objects from using JavaScript’s Object prototype, they may
behave differently from original bridge objects.
VII. C ONCLUSION
We presented a formal speciﬁcation for inter-language com-
munication in Android to provide a ﬁrm ground for under-
standing and reasoning about Android hybrid apps. We iden-
tiﬁed complex but under-documented interoperation behaviors
via extensive testing and inspection of the Android source
code. We extended the existing multi-language semantics to
formally specify key interoperation features, dynamic and
indistinguishable interoperations. Based on the extensions, we
presented an operational semantics of the Android interoper-
ability, and it enabled us to uncover quirky and error-prone
behaviors in the Android hybrid mechanism. On top of the
formalization, we designed and implemented a type system
that detects interoperation bugs. We showed that it detects
about twice more true bugs than HybriDroid with the 15.8x
average speed-up. Moreover, our type system is just one
application of the presented formal semantics. We believe one
can design static analyzers or more expensive type systems
based on the formalization in this paper.
232
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:59:16 UTC from IEEE Xplore.  Restrictions apply. ACKNOWLEDGMENT
This work has received funding from National Research Foun-
dation of Korea (NRF) (Grants NRF-2017R1A2B3012020 and
2017M3C4A7068177).
REFERENCES
[1] I. Framework, “2017 developer survey,” https://
www.ionicframework .com/survey/2017, 2017.
[2] OutSystems, “Mobility, custom apps a priority for 2015,” https://
www.outsystems .com/1/mobility-custom-apps-report, 2015.
[3] N. Viennot, E. Garcia, and J. Nieh, “A measurement study of Google
Play,” in Proceedings of the ACM International Conference on Mea-
surement and Modeling of Computer Systems (SIGMETRICS) , 2014.
[4] X. Jin, X. Hu, K. Ying, W. Du, H. Yin, and G. N. Peri, “Code injection
attacks on HTML5-based mobile apps: Characterization, detection and
mitigation,” in Proceedings of the 2014 ACM SIGSAC Conference on
Computer and Communications Security . ACM, 2014, pp. 66–77.
[5] M. Shehab and A. AlJarrah, “Reducing attack surface on Cordova-based
hybrid mobile apps,” in Proceedings of the 2nd International Workshop
on Mobile Development Lifecycle . ACM, 2014, pp. 1–8.
[6] A. D. Brucker and M. Herzberg, “On the static analysis of hybrid mobile
apps,” in International Symposium on Engineering Secure Software and
Systems , 2016.
[7] S. Lee, J. Dolby, and S. Ryu, “Hybridroid: Static analysis framework
for android hybrid applications,” in Proceedings of the 31th IEEE/ACM
International Conference on Automated Software Engineering , 2016.
[8] Android, “Webview,” http://developer .android.com/reference/android/
webkit/WebView .html, 2008.
[9] Google, “Chromium,” https://code .google.com/p/chromium/codesearch,
2016.
[10] J. Matthews and R. B. Findler, “Operational semantics for multi-
language programs,” in Proceedings of the 34th Annual ACM SIGPLAN-
SIGACT Symposium on Principles of Programming Languages , 2007.
[11] A. Igarashi, B. C. Pierce, and P. Wadler, “Featherweight Java: A minimal
core calculus for Java and GJ,” in Proceedings of ACM SIGPLAN
Conference on Object-Oriented Programming, Systems, Languages, and
Applications , 1999.
[12] A. Guha, C. Saftoiu, and S. Krishnamurthi, “The essence of JavaScript,”
inEuropean Conference on Object-Oriented Programming , 2010.
[13] M. Felleisen and R. Hieb, “The revised report on the syntactic theories
of sequential control and state,” Theoretical Computer Science , vol. 103,
no. 2, pp. 235–271, 1992.
[14] O. T. Network, “LiveConnect support in the next generation
Java™Plug-In technology introduced in Java SE 6 update 10,”
http://www .oracle.com/technetwork/java/javase/overview/liveconnect-
docs-349790 .html, 2006.
[15] M. D. Network, “Rhino,” https://developer .mozilla.org/en-US/docs/
Mozilla/Projects/Rhino, 2005.
[16] S. Bae, S. Lee, and S. Ryu, “Towards understanding and
reasoning about Android interoperations (supplementary material),”
https://plrg .kaist.ac.kr/lib/exe/fetch .php?media=research:material:
supplement .pdf, 2018.
[17] B. C. Pierce, Types and Programming Languages . The MIT Press,
2002.
[18] H. Lee, S. Won, J. Jin, J. Cho, and S. Ryu, “SAFE: Formal speciﬁcation
and implementation of a scalable analysis framework for ECMAScript,”
inProceedings of the International Workshop on F oundations of Object-
Oriented Languages , 2012.
[19] S. Bae, S. Lee, and S. Ryu, “Type system for safe interoperability in
Android,” https://github .com/sorabae/android-typecheck, 2018.
[20] K. Allix, T. F. Bissyande, J. Klein, and Y . L. Traon, “Androzoo:
Collecting millions of android apps for the research community,” in
IEEE/ACM 13th Working Conference on Mining Software Repositories
(MSR) , 2016.
[21] G. Martin, S. Jana, and V . Shmatikov, “Breaking and ﬁxing origin-based
access control in hybrid web/mobile application frameworks,” in NDSS
symposium. V ol. 2014. NIH Public Access , 2014.
[22] Oracle, “Java™ Native Interface,” http://docs .oracle.com/javase/7/docs/
technotes/guides/jni/, 1999.
[23] M. Hirzel and R. Grimm, “Jeannie: Granting Java Native Interface
developers their wishes,” in Proceedings of the Conference on Object-
Oriented Programming, Systems, Languages and Applications , 2007.[24] G. Tan, “JNI Light: An operational model for the core JNI,” Journal
of Mathematical Structures in Computer Science , vol. 25, pp. 805–840,
2015.
[25] K. E. Gray, “Safe cross-language inheritance,” in European Conference
on Object-Oriented Programming , 2008.
233
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:59:16 UTC from IEEE Xplore.  Restrictions apply. 