Dataflow Tunneling
Mining Inter-request Data Dependencies for Request-based Applications
Xiao Yu
Department of Computer Science
North Carolina State University
xyu10@ncsu.eduGuoliang Jin
Department of Computer Science
North Carolina State University
guoliang_jin@ncsu.edu
ABSTRACT
Request-based applications, e.g., most server-side applications, ex-
pose services to users in a request-based paradigm, in which re-
questsare servedbyrequest-handlermethods. Animportanttask
for request-based applications is inter-request analysis, which ana-
lyzesrequest-handlermethodsthatarerelatedby inter-requestdata
dependencies together. However, in the request-based paradigm,
data dependencies between related request-handler methods are
implicitlyestablishedbytheunderlyingframeworksthatexecute
thesemethods.Asaresult,existinganalysistoolsareusuallylim-
itedtothescopeofeachsinglemethodwithouttheknowledgeof
dependencies between different methods.
Inthispaper,wedesignanapproachcalled dataflowtunneling
to capture inter-request data dependencies from concrete applica-
tion executions and produce data-dependency specifications. Our
approach answers two key questions: (1) what request-handler
methods have data dependencies and (2) what these data depen-
dencies are. Our evaluation using applications developed with two
representativeandpopularframeworksshowsthatourapproach
is general and accurate. We also present a characteristic study and
ausecaseofcachetuningbasedontheminedspecifications.We
envision thatour approach canprovide keyinformation to enable
future inter-request analysis techniques.
KEYWORDS
web applications, request-based applications, web frameworks,
inter-request analysis, tracing
1 INTRODUCTION
Server-side applications commonly expose services to users ina request-based paradigm, in which user requests are served by
application-defined request-handler methods. We refer to such ap-
plicationsasrequest-basedapplications.Request-basedapplications
are playing an increasingly important role in the current software
ecosystem, providing classic web pages and emerging cloud-based
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5638-1/18/05...$15.00
https://doi.org/10.1145/3180155.3180171application services. The increasing prevalence of these applica-
tions brings new demands and challenges regarding software qual-
ity,therebycallingforadvancedtechniquestoensureapplication
correctness, performance, and security.
Modern request-based applications are usually built on top of
somesupportingframeworks,e.g.,Spring[ 37]andStruts[ 5]forweb
applications. In the request-based execution model, upon receiving
a request, the framework invokes one or more request-handler
methods,andtheinvokedmethod(s)returndataobjectscontaining
the necessary information to serve the request. These data objects
are further processed by the framework to generate a concrete
response to be sent to the user side (e.g., in the form of HTML).
While each request is served modularly, users can issue a series of
relatedrequests,whichmaybebasedonthereceivedresponses(e.g.,throughahyperlinkgenerateddynamicallyfromsomedataobjects).
Therefore,theoutputofoneservingrequest-handlermethodcould
becometheinputofanothermethod,creatingdatadependencies
betweenthesemethods.Wesaytworequest-handlermethodsare
relatedif there are data dependencies between them.
With theexecution model,it is importantfor programanalysis
techniquestargetingrequest-basedapplicationstotrackdatadepen-
denciesacrossrelatedmethodsandperform inter-requestanalysis.
While there is a natural analogy between inter-request analysis
and interprocedural analysis [ 40,43], one cannot directly apply
techniquesdevelopedforinterproceduralanalysisforinter-request
analysis. The challenges are mainly rooted in the way how data
dependenciesbetweenrequest-handlermethodsareestablished:(1)
because of the separation of server and user sides, data dependen-
cies are not directly established by propagating data objects across
methodsthroughreturnvaluesorparameters,and(2)becauseofthe
framework,thereisnoexplicitcaller-calleerelationshipbetween
methodsservingdifferentrequests.Thesecomplicationsmakeinter-
requestdatadependenciesnotperceivablebyconventionalinter-
procedural or summary-based analysis techniques [41, 42, 57, 58].
Existing techniques in different fields are affected by the limited
capability of conducting inter-request analysis. In the performance
field, a previous study [ 21] shows that many performance bugs
arecausedbyskippablefunctioncallsorinefficientfunction-call
combinations. Request-based applications are more prone to such
inefficiencies, as the request abstraction is highly modular, and
developerscaneasilywriteinefficientcodespreadacrossindividual
request-handler methods. Although various techniques [ 13,14,30,
38]havebeenproposedtoalleviatesuchinefficiencies,theymay
notreachtheirfullpotentialwithoutinter-requestcapability.Inthe
securityfield,investigatingmalicious-datapropagationiscrucial.
Request-to-response propagation within each request is a common
targetforexistingwork[ 47,53],butpropagationthatspansmultiple
5862018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Xiao Yu and Guoliang Jin
requests can also create vulnerabilities. Some work [ 1,31] has
discussed and tried identifying such vulnerabilities by exploring
navigation sequences of web pages.
Toovercomechallengesandbuildasolidfoundationforinter-
requestanalysisonmodernrequest-basedapplications,wepropose
anapproachcalled dataflowtunneling.Ourapproachisbasedon
the key observation that framework and user behaviors are of
less interest in application-code analysis. For example, knowinghow a framework accesses some data objects is less importantthan knowing what data these objects carry. Therefore, our ap-
proacheffectivelyabstractsawaytheinvolvementofframeworks
and users in propagating data across requests, and directly exposesdatadependenciesacrossrequest-handlermethods.Wedefinesuch
dependencies in the form of data-dependency specifications, which
describe how the output of a method tunnels(i.e., being propa-
gated and transformed) through frameworks and users to become
theinputofanothermethod.Theresultingspecificationsprovide
necessaryinformationtoallowconventionalanalysistechniques
to go across the boundaries of request-handler methods without
analyzing supporting frameworks or user behaviors.
Ourapproachanalyzesconcreteapplicationexecutionstocap-
ture data dependencies. We design our approach with three keytechniques: (1) a static analysis on request-handler methods to
identify input and output sites where these methods and their sup-
porting framework pass data objects to each other; (2) on data
objectspassingthroughtheidentifiedsites,anobject-centrictrac-
ingtechnique tocaptureobject accessesandtheir accessedvalues
throughout the whole processing of every single request; and (3) a
mining technique to identify potential data dependencies between
request-handler methods in traces from different requests. Withthis design, our approach adheres to the general request-basedexecution model instead of specific framework implementations,
thereby avoiding ad hoc analyses on framework code.
WehaveimplementedaprototypeforJava-basedwebapplica-
tions,andevaluatedthespecificationaccuracyandtracingoverhead
on two real-world open-source applications developed with differ-
entsupportingframeworks.Wehavealsomanuallyinspectedthe
generated specifications to investigate how useful they are for pro-
gram understanding andfuture inter-request analysis techniques.
The results show good accuracies (above 80%) in typical configura-
tions, and suitable overheads for an in-house testing environment.
Our manual inspection helps us gain a better understanding of the
two applications. Based on the understanding, we present a usecase of the specifications in tuning object caching, which shows
promising results in database-query reduction and execution-time
reduction.Webelievethesespecificationscanhelpenablefuture
sophisticated inter-request analysis.
Overall,wemakefourmaincontributions.First,weelaboratethe
importance and challenges of inter-request analysis, especially on
challengesposedbymodernframeworks.Second,weproposeanap-proachtoinferinter-requestdatadependencies.Onenoveltyofour
approach is to abstract away the involvement of frameworks with-
outhuman-assistedmodeling.Third,weprototypeandevaluateour
approach on two open-source applications regarding accuracy and
overhead.Fourth,westudythedata-dependencyspecificationsgen-
erated by our prototype and present a usage scenario on how they
can help program understanding and future analysis techniques.
Client
Parsed InputRequest Response
View
TemplatesView Output
Create ConcretizeRequest-
handler 
Methods
Data Objects
Request-based Application Framework
Figure 1: The abstract request-based execution model
2 BACKGROUND AND MOTIVATION
We presentanextendeddiscussiononthe backgroundofrequest-
basedapplicationsandthechallengesofinter-requestdata-dependency
analysis.Thediscussionisbasedonareal-worldexample,which
involves a popular Java request-based framework.
2.1 Background
Figure 1 illustrates the general request-based application executionmodel,whichcapturesthecommonalitiesamongapplicationsdevel-opedwithdifferentframeworks.Thisabstractmodelshowsasingle
request-to-response flow. Along the flow, three major components
of a request-based application are involved: (1) request-handler
methods, (2) data objects, and (3) view templates.
Request-handler methods are the entry points of a request-based
application to process incoming requests. For each request, the
frameworkdeterminesandinvokestheappropriatehandlermethod(s)throughapredefined request-handlermapping.Therequest-handler
mapping defines requests that each handler method can process.It is specified by developers in different forms depending on the
underlyingframeworks,e.g.,Spring[ 37]usesJavaannotationsand
Struts[5]usesconfigurationfiles.Dependingonspecificframework
implementations,oneormorerequest-handlermethodsmayget
invoked to process one request.
During the execution of a request-handler method, it creates
data objects and passes them to the framework. These data objects
encapsulatedatathatareusuallyretrievedfromabackenddatabase.
The framework then references and uses these objects to generate
concreteresponses.Basedonourinvestigationofpopularframe-
works for Java listed in an online source [ 49], the majority of them
allow request-handler methods to pass data objects through either
methodreturnsorcollection-basedparameters,whilesomerequire
request-handlermethodstouseframework-specificAPIs.Inthis
paper, we follow the object-passing model of the majority, but our
approach can be extended to include framework-specific APIs.
View templates define how data objects should be further pro-
cessed to display to the client, and such templates are usually
written in different markup languages, such as FreeMarker [ 4],
JSTL [35], and Velocity [ 3]. With the data objects from request-
handlermethods,theframeworkchoosesaviewtemplate,either
programmatically or based on a predefined view-template mapping,
587
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. Dataflow Tunneling ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
to populate a concrete view. Finally, the concretized view will be
sent to the user as the response, which can be as complex as a web
page or as simple as plain text that is serialized from data objects.
2.2 Motivating Example
Figure 2 shows an example from OpenMRS [ 33], which is an open-
source web-based medical-record system. It uses the Spring Frame-
work[37]astheapplicationframework.Thelistedcodeincludes
three request-handler methods implemented in Java, with excerpts
ofJSP[34]filesthataretheircorrespondingviewtemplates.The
request-handlermethodandviewtemplateforhandlingrequests
to the path /patientDashboard.form are listed from lines 1 to
19. They produce an overview page for the patient specified in
the request. The method renderDashboard() takes two param-
eters: (1) an integer patientId passed in by the Spring Frame-
work as a request parameter, and (2) a ModelMap objectmapcarry-
ingdataobjectstothecorrespondingviewtemplate.Themethod
usespatientId tocreatea Patientdataobject(line7),andthen
puts it into map(line 8). With the method returning the string
“patientDashboardForm ” (line 10), the framework chooses the
view template patientDashboardForm.jsp (lines 14 to 19) to pro-
duce a concrete patient-overview page. The page contains a button
(line15)thatcanfireanotherrequesttoshowsomevisitinforma-
tion of the specified patient. This new request requires the patient
identifiertobeembeddedasarequestparameter.Atruntime,the
Spring Framework evaluates model.patient.patientId (line 18)
to fill in the request path (lines 17 - 18) with a concrete value. The
value evaluation relies on the Java reflection mechanism to find
the data object bound to model.patient , and invoke the accessor
method bound to the field name patientId . In this example, the
objectisthe Patientobjectcreatedby renderDashboard() ,and
the accessor method is Patient.getPatientId().
Whenauserclicksthebuttonontheoverviewpage,arequestfor
thepatient’svisitisfiredtotherequestpath /admin/visits/visit .
Thisrequestishandledbythecodefromlines21to45.Lines21to27
comprisetherequest-handlermethod showForm() ,andthismethod
requires a Visitobject populated by another method getVisit()
listed from lines 28 to 38. At runtime, the Spring Framework in-
vokesgetVisit() beforeshowForm() to create the Visitobject
with its corresponding Patient object from request parameters
visitId andpatientId . The view template visitForm.jsp ac-
cesses the VisitandPatient objects bound to visit.patient
multiple times (lines 43 and 45) for different pieces of information.
Aninter-requestcachingopportunity. Weshowthatinter-request
analysisisusefultoidentifyanoptimizationopportunity.Forthe
two requests in the example, their corresponding methods invoke
PatientService.getPatient() (lines 7 and 35), which queries a
database for patient data to create a Patient object. With inter-
requestdatadependencies,onecandeterminethattheflow(lines
connected by dashed arrows) 4 →7→8→18→29→35 propagates
the value of patientId from the first method invocation to the
second.Thispropagationhintsthatonemayaddacachemechanismtocachethe
Patient objectfromthefirstinvocation,sothecached
object is available on the second invocation without additionalqueries to the database. In Section 4.6, we show a use case using
Hibernate [39], a data-access framework, to achieve such caching.1@Controller
2public class PatientDashboardController {
3@RequestMapping("/patientDashboard. form")
4protected String renderDashboard( @RequestParam("patientId")
Integer patientId , ModelMap map , ...) {
5 // Get the patient
6 PatientService ps = Context.getPatientService();
7 Patient patient = ps.getPatient(patientId);
8 map.put( "patient" , patient);
9 ...
10 return "patientDashboardForm" ;
11}
12}
14// patientDashboardForm.jsp
15<input type= "button"
16onclick= "window.location=
17 '/admin/visits/ visit.form ?patientId=
18 <c:out value=${model.patient.patientId} />'"
19.../>
21@Controller
22public class VisitFormController {
23@RequestMapping("/admin/visits/visit")
24public String showForm( @ModelAttribute("visit") Visit visit,
ModelMap model , ...) {
25 ...
26 return "/admin/visits/visitForm" ;
27}
28@ModelAttribute("visit")
29public Visit getVisit( @RequestParam("visitId") Integer visitId,
@RequestParam("patientId") Integer patientId) {
30 Visit visit = null;
31 PatientService ps = Context.getPatientService();
32 if(visitId == null&& patientId != null){
33 visit = newVisit();
34 // Get the patient and set it to the visit
35 visit.setPatient(ps.getPatient(patientId));
36 }else{ ... }
37 return visit;
38}
39}
41// visitForm.jsp
42<input type= "hidden" value=
43<c:out value=${visit.patient.patientId} />
44... />
45<td><c:out value=${visit.p atient.personName} /></td>
Figure 2: An excerpt of three related request-handler meth-ods and their view templates from OpenMRS. Only methodparameters related to our discussion are shown.
The challenges of inter-request data-dependency analysis. Follow-
ing the discussion in Section 1 that framework behaviors and user
interactions complicate the analysis of inter-request data depen-
dencies,weconcretelydiscussthechallengesbasedonourexample
with the assumption that we were to extend conventional interpro-
cedural analyses to compute inter-request data dependencies.
First, handling application components in different languages
would be necessary but ad hoc. Request-handler methods and view
templates are commonly developed in different languages, andconcrete responses can also contain scripts that perform client-
side operations to propagate data across requests. In our example,
three languages are involved to propagate the patientId value:
Java for handler methods, Expression Language [ 36] for evaluating
concrete values on data objects in view templates, and a pieceof JavaScript code (lines 16 to 18) to propagate the
patientId
value by firing the second request from the user’s browser. As
588
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Xiao Yu and Guoliang Jin
data propagation goes through all the three components, ad hoc
supportsfordifferentlanguageswouldbenecessarytocapturedata
dependencies between the involved request-handler methods.
Second, analyzing framework code would be necessary but chal-
lenging to capture data propagation outside request-handler meth-
ods.Theframeworkisthecallerofrequest-handlermethodsand
view templates, and it provides the supports of parsing requests,
binding and accessing data objects, and populating concrete views.
As our example shows, the framework heavily relies on the re-
flection mechanism, which performs dynamic object instantiation
andmethodinvocationsatruntime.Forinstance,theframework
usestheannotation @ModelAttribute (line28)tobindthe Visit
objectinJavacodetotheviewtemplatewithatextualname visit
(line 43). It is not until the time of execution that the framework
parsestheseannotationsandtextualnames,andusesthereflection
mechanism to invoke the parsed methods on the bound objects. It
isknown thatthisruntimemechanism bringsdifficultiestostatic
analysis.Researchershaveproposeddifferentapproachestoaddress
this problem with their own pros and cons [12, 25, 28, 45, 47, 50].
3 DATAFLOW TUNNELING
Ourapproachrequirestwoartifacts:theapplicationcodeofrequest-
handlermethodsspecifiedbydevelopersforanalysisandtestinputsforgeneratingtraces.Withthetwoartifacts,ourapproachperforms
threekeysteps:(1)staticanalysisonrequest-handlermethodsto
identify input and output sites, (2) instrumenting the methods and
tracingapplicationexecutionsundertestinputs,and(3)miningthe
generated traces for data-dependency specifications. The results of
our approach are data-dependency specifications across request-
handlermethods.Suchspecificationsdescribehowtheoutputof
a request-handlermethod is propagated andtransformed into the
input of another request-handler method. We use the following
notations to represent data-dependency specifications:
(1)amethod
typedenotes that an entity with a name ais oftypeand
usedinmethod.Weuseaspecialnotation objtodenoteanentity
withoutaname,andweuse VIEWasaspecial methodtodenote
that the entity is used outside a request-handler method.
(2)a=⇒bdenotes that ais propagated to bwithout transforma-
tion(weomitthe methodandtypeonaandbforsimplicity).There
are two propagation channels: PARAMfor propagation through a
collection-basedparameter,or RETURN for propagationthrough
amethodreturn.Weputthepropagationchanneloverthearrow.
For channel PARAM, we put the parameter name under the arrow.
(3)a− →bdenotes that ais transformed and then propagated to
b. We put the method name related to the transformation over the
arrow.Sometimes amayrepresentacollectionofobjects(e.g.,aset
ofPatient objects),while bmayrepresentonlyasinglevalue(e.g.,
thepatientId ofoneoftheobjects).Suchcasesindicateamany-to-
one relation between aandb. We put the notation CHOICE under
the arrow to denote these cases.
Withthesenotations,thedata-dependencyspecificationsforthe
example in Figure 2 are:
objrenderDashboard ()
PatientPARAM=======⇒mapobjVIEW
Patient
Patient .дetPatientId ()−−−−−−−−−−−−−−−−−−−−−− →patientIdдetVisit ()
Inteдer(1)objдetVisit ()
VisitRETURN========⇒visitshowForm ()
Visit(2)
Specification(1)describesthata Patientobjectfromthemethod
renderDashboard() is passed through a parameter channel map
(denoted by ⇒) to the view. Then the object is transformed by
Patient.getPatientId() into an integer, which is propagated to
the input parameter patientId of the method getVisit() (de-
notedby →).Specification(2)describesthata Visitobjectisre-
turned from the method getVisit() , and then the object is propa-
gated to the parameter visitof the method showForm().
3.1 Identifying Input and Output Sites
To capture data dependencies across request-handler methods, we
first need to know what input each method receives and what
outputeachmethodproduces.Thegoalofthisstepisidentifying
theinputandoutputsitesineachrequest-handlermethod.Aninput
site indicates where a handler method receives input data from the
framework, and an output site indicates where the method passes
outputdatatotheframework.Theidentifiedsitesallowthelater
instrumentationand tracingstepto collectnecessaryinformation.
Weapplyastatictaintanalysistoidentifyinputandoutputsites,
as essentially they are sources and sinks between which data is
propagatedwithinthescopeofarequest-handlermethod.Foreachrequest-handlermethod,westartwithaconservativesetofsourcesand then identify sinks based on a propagation graph computed by
thestatictaintanalysis.Wefurtherfiltersourcesandsinksusing
asetofrulesthatincorporatetherequest-basedexecutionmodel.
We consider variables in the resulting sources as input sites and
variables in the resulting sinks as output sites.
We define the propagation graph as follows, followed by the
rules to determine sources and sinks.
Definition 1. A Propagation Graph is a directed graph PG=
(V,E)whereVis a set of nodes for variables labeled by program
locations,and Econtainsedgesover V.Eachedge vl1
1→vl2
2indicates
a flow of data from variable v1at program location l1tov2atl2.
Inproducingsuchpropagationgraphs,weconsidertwotypes
of variables as sources: (1) parameters of a request-handler method
and (2) variables that receive data fromstatic method invocations.
These two sets of sources reflect two common ways that a request-
handlermethodreceivesrequestinputsfromtheframework:either
fromparametersorthroughcertainAPIs.Startingfromthesesource
variables,weapplyconventionalpropagationrulestocomputea
propagation graph for each method. In particular, we propagate
taintedvaluesstartingfromsourcesthroughnormalassignments,
and arguments and return values in method invocations. To prop-
agatethroughvirtualmethodinvocations,whosemethodbodies
cannot be determined statically for direct analysis, we introducetwoheuristics.First,if
bistaintedinthecaseof a.m(b),ashould
alsobe tainted(i.e., introducinganedge b→a).This rulereflects
acommonpatternthattheobject areceivesdatafromtheobject
b. For example, line 35 in Figure 2 is a typical case in which the
Visitobject stores the Patientobject in a field. Second, for the
casea=b.m(c),ashould be tainted if borcis tainted. This is an
over-approximationthataggressivelycreatespossibleflowedges
whenmis not available for direct analysis.
589
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. Dataflow Tunneling ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Onapropagationgraphconstructedbasedonthepropagation
rules,thenodeswithoutanyincomingedgesarelikelysources,and
the nodes without any outgoing edges are likely sinks. We then
apply the following three rules to filter sources and sinks for input
and output sites. First, the variable in a sink is an output site if it is
aparameter(e.g.,acollectionobject),inareturnstatement(e.g.,an
object returned by the method), or an argument of a static method
invocation. This rule indicates that a sink variable is an output
site only if the data carried by the sink variable is visible outside a
request-handlermethod.Second,anobjectvariablemarkedasboth
asourcevariableandasinkvariableislikelytobeanoutputsite,
astheobjectreferencedbythevariableislikelytoholdnewdata
derivedfromotherinputs.Latersuchdatamaybeaccessedoutside
therequest-handlermethod.Third,sourceandsinkvariablesnot
affected by the first two rules are input sites and output sites, re-
spectively. For example, we initially consider the parameter mapof
renderDashboard in Figure 2 as a source, and then we find that it
actslikeasink atalaterprogramlocation.Withthesecondrule,
we classify the parameter mapas an output site.
3.2 Instrumentation and Tracing
Inthisstep,weinstrumenttheidentifiedinputandoutputsites,and
then execute the application with test inputs to trace and collect
necessaryinformationforthelaterminingstep.Foreachmethod
execution,twosetsofeventsaregenerated:inputeventsandout-
putevents.Inputeventsrecordconcreteinputvaluespassedinto
request-handler methods by the framework, and output eventsrecord (1) the concrete values in request responses and (2) themethod-invocation sequences representing how the framework
retrieves these values from output data objects.
We specifically design this step not to ad hoc analyze or trace
complex framework executions. Instead, this step focuses on data-
objectaccesses(e.g.,gettinganobjectfield).Thisideaisbasedon
theobservationthatallframework-dependentcode,regardlessof
languagesandtheuseofreflection,finallyhastoinvokemethods
on data objects to retrieve concrete data. Therefore, tracing object
accessesisareasonablewaytoobservedatapropagationbeyond
request-handler methodsand into framework andview templates.
Inparticular,weuseadynamicproxy-basedtechniqueondata
objects. A proxy object is a type-safe delegate of its original object.
Wecanreplaceadataobjectwithitsproxyobject,andtheproxy
objectcaninterceptmethodinvocationsmadeontheoriginalobject
without affecting application behaviors. This technique involves
two keyideas: (1) dynamically creatingproxy objects tointercept
and then dispatch method invocations to the original objects, and
(2)propagatingproxyobjectsbasedonthecontextofmethodex-
ecutions to capture framework behaviors in different execution
points. By dynamically creating and propagating proxy objects, we
canrecordasequenceofmethodsthattheframeworkinvokeson
each data object, together with concrete values returned by thissequence.Thistechniqueallowsustocaptureframeworkbehav-
iors but effectively avoid the scalability issue of ad hoc analysis on
different languages and analysis limitations caused by reflection.
Table1summarizestheinstrumentationandtracingrules.These
rulesfiretracingeventsandcreateproxyobjectsondemand.We
describe these rules in detail as follows.At the entry and exit points of each request-handler method,
weinstrument enterMethod(mName) andexitMethod(mName) to
record the start and end of each method execution. These points
generateevents EnterMethodEvent andExitMethodEvent (RE1and
RE2).Weintroducetheseeventstodistinguishdifferentmethodex-
ecutions.Theyonlyrecordthenameofthemethodbeingexecuted.
Foreachvariable varInidentifiedasaninputsite,weinstrument
varIn = recordInput(varIn) at the beginning of the method.
For each variable varOutidentified as an output site, we instru-
mentvarOut = recordOutput(varOut) to a point that depends
on the output type. If varOutappears in a return statement, the
instrumentation is placed before the statement. In other cases, the
instrumentationisplacedwherethemethodfirstinitializes varOut:
eitheratthebeginningofthemethodif varOutisanout-parameter,
or right after an API invocation if varOutreceives a return object.
Such instrumentation serves two purposes: recording necessary
informationoninputandoutputsites,andcreatingproxyobjects
to further trace objects passed through these sites.
Theinstrumentedinputandoutputsitesgenerateeventsof In-
putEvent (RI1,RI2)andOutputEvent (RO1,RO2).Theinformation
recordedintheseeventsdependsonthetypeof varInorvarOut:a
simple value for a simpletype, or an object identifier for a complexclass.Theinstrumentedsitesalsocreateproxyobjectstoreplacethe
original objects in order to trace method invocations. In particular,
the rules RI2andRO2describe two situations where proxy objects
arecreated.First,ifanoutput-sitevariable varOutreferencesacom-
plexobject,theinstrumentationcreatesaproxyobjecttoreplace
the referencedobject (RO2 ). Asa result,the tracingstep cantrace
how the request-handler method and the framework use the refer-
enced object. Second, the instrumentation creates a proxy object
on the input site that references an HttpRequest object (RI2). This
isforbackwardcompatibilitywithrequest-handlermethodsthat
directly access the HttpRequest object to retrieve request inputs.
Withtheinitialproxyobjectscreatedatinstrumentationsites,we
discuss rules PM1,PM2,PF1, andPF2, which specify the behaviors
of proxy objects when they intercept method invocations.
RulePM1orPM2applieswhenaproxyobjectinterceptsamethod
invocation within a request-handler method. If the proxy objectis an
HttpRequest object, we consider that it presents an input
site, therefore an event of InputAccessEvent is fired (PM2 ). The
InputAccessEvent representsthebehaviorofretrievingrequestinput
from the HttpRequest object, and records the return value and
argument values of the method invocation.
The cases other than invocations on an HttpRequest object
imply that the target proxy object serves as an output site of the
method,andtheinvocationargumentsare likelytobevisibleand
usedbytheframework.Therefore,weapply PM1tofireanevent
ofOutputEvent on each argument involved in the invocation, and
replaceeachargumentthatisofacomplextypewithaproxyobject.
This rule captures output data that is passed out by the handler
method,aswellaspropagatesproxyobjectstotheframeworkto
further trace runtime behaviors outside the method.
Forinvocationsinterceptedoutsidethescopeofarequest-handler
method, we introduce rules PF1to trace an intermediate invoca-
tion that returns another complex object, and PF2to trace the
final invocation that returns a simple value. These two rules are
basedontheobservationthattheframeworkmayinvokeaseries
590
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Xiao Yu and Guoliang Jin
Table1:Instrumentationandtracingrules.TracPoint:whetheratraceeventisfiredonaninstrumentationpoint(Inst)oron
a proxy object (Proxy); Exec Point: the current scope of execution, in a request-handler method or the framework; Involved
Statement: the instrumented code for an instrumentation point, the intercepted method invocation for a proxy point( objal-
waysreferencesaproxyobject);TracingActionandConditions:thetracingstepperformstheactionundercertainconditions.
RuleTrac Point Exec Point Involved Statement Conditions Tracing Action
RE1Inst Method enterMethod(mName) Fireaneventof EnterMethodEvent,recordingthemethodname mName .
RE2Inst Method exitMethod(mName) Fire an event of ExitMethodEvent, recording the method name mName .
RI1Inst Method recordInput(var) varis not of the type
HttpRequest.Fire an event of InputEvent, recording the value or object identifier of
var.
RI2Inst Method recordInput(var) varis of the type HttpRequest. Fire an event of InputEvent that records the object identifier of var, and
create a proxy object for the object referenced by var.
RO1Inst Method recordOutput(var) varis a simple value. Fire an event of OutputEvent, recording the value of var.
RO2Inst Method recordOutput(var) varreferences a complex object. Fire an event of OutputEvent that records the object identifier of var,
and create a proxy object for the object referenced by var.
PM1Proxy Method obj.m(arg1, ...) Foreacharдi,fireaneventof OutputEvent,andcreateaproxyobjectfor
arдiif it is of a complex type.
PM2Proxy Method obj.m(arg) objis of the type HttpRequest ,
andmhas a return value.Fire an event of InputAccessEvent to recordarдand the returned value.
PF1Proxy Framework obj.m(...) mreturns a complex object. Createaproxyobjecttoreplacethereturnedobject,andappend mtothe
invocation sequence that leads to the current invocation.
PF2Proxy Framework obj.m(...) mreturns a simple value. Fire an event of OutputAccessEvent to record the returned value and the
previously recorded invocation sequence plus m.
of methods on a complex object to retrieve a simple value (e.g.,
visit.patient.patientId ). If an intercepted method invocation
returns a complex object, we consider it as an intermediate steptowardsthefinaloutputvalue,andweapply PF1tocreateanew
proxyobjecttoreplacethereturnobjecttofurthertracesubsequent
invocations and record the current invocation in the invocation
sequence.Otherwise,iftheinvocationreturnsasimplevalue,we
applyPF2to fire an event of OutputAccessEvent, which records the
returned value, as well as the sequence of invocations recorded
along with all the intermediate invocations plus the final one.
Overall,thistracingstepproducesatraceforeachrequest.Each
trace is in the form of (EnterMethodEvent (InputEvent |InputAc-
cessEvent |OutputEvent)*ExitMethodEventOutputAccessEvent*)*,
indicating that zero or more request-handler methods are executedforone request. Duringtheexecution ofeachmethod,there canbe
zero or more InputEvent, InputAccessEvent, and OutputEvent. After
each method execution, there can be zero or more OutputAccessEv-
ent.Foreveryaccessevent(InputAccessEvent orOutputAccessEvent )
inatrace,thesametracemusthaveonecorrespondingsourceevent
(InputEvent orOutputEvent )beforetheaccessevent,andthesource
event records information about the accessed root object.
An example with Figure 2. We userenderDashboard() in Fig-
ure2asanexampletoshowhowtheanalysisandtracingstepswork.
Thestatic-analysisstepfirstidentifiestheparameter patientId asa
sourcevariableandtheparameter mapasasinkvariable.Thenwein-
strumenttwolinesofcode patientId = recordInput(patientId)
andmap = recordOutput(map) at the beginning of the method.
We also instrument events enterMethod andexitMethod at the
beginning and end of the method, respectively.
In the tracing step, the execution of renderDashboard() yields
atraceconsistingof EnterMethodEvent, InputEvent onpatientId ,
OutputEvent onmap,OutputEvent on thePatient object,Exit-
MethodEvent, OutputAccessEvent representing a method invoca-
tionofPatient.getPatientId .TheInputEvent istriggeredby RI1,
and the first OutputEvent byRO2. A proxy object for mapis cre-
ated to replace the original object during this process. Then thisproxy object fires the second OutputEvent byPM1when it inter-
ceptsmap.put() .Italsocreatesandpassesaproxyobjectforthe
originalPatientobject into map. When the framework executes
patientDashboardForm.jsp ,theproxyobjectforthe Patientob-
ject intercepts an invocation Patient.getPatientId() , and fires
OutputAccessEvent byPF2as the method returns a simple value.
3.3 Specification Mining
Based on the trace structure defined in Section 3.2, each trace rep-
resents the processing of a single request. We first leverage the
user-session information collected along tracing to distinguish and
grouptracesofrequestsfromdifferentusersessions.Wethenusea
k-length sliding window algorithm to infer data-dependency spec-
ifications from traces from the same user session. Our algorithmmaintains a k-length sliding window because data dependenciesmay exist across non-adjacent requests. For example, the two re-
quests mentioned in Section 2.2 are actually not adjacent, which is
separated by a background request triggered by the first patient-
overview page. In practice, data dependencies are unlikely to exist
betweenmethodsofalongrequestdistance,andweexpecttheslid-
ingwindowsizetobesmall.Onecandetermineaproperwindow
size in different ways, depending on the environment where the
applicationunderanalysisisrunning.Inanin-housetestingsetting,
onemayrepeattestrunsandgraduallyincreasethewindowsize
untilnotruespecificationisfound.Inaproductionenvironment
where requests and workloads are not repeatable, one may use the
windowssizedeterminedduringin-housetestingorheuristically
adjust the size online, and we leave the latter for future work.
Algorithm 1 presents an outline of the k-length sliding window
algorithm. For each incoming trace t, the algorithm pairs twith
k−1 previous traces from the same user session as well as tit-
self, and applies the subroutine MineSpec on these pairs. Mining
each of these trace pairs yields specifications that describe data de-
pendencies between request-handler methods in the paired traces.
Notethatminingthereflectivepair (t,t)yieldsspecificationswhen
multiplerequest-handlermethodsareinvolvedinprocessingthe
591
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. Dataflow Tunneling ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Algorithm1: MiningTraceswithaK-LengthSlidingWin-
dow
Input:A tracetfrom a trace stream of the application
Global:A configurable integer k, a mapMassociating every session
identifier with a list storing up to k−1previous traces, and a
databaseDBstoring existing data-dependency specifications
1list←M[GetSessionId( t)];
2AppendLast( list,t);
3foreacht/primeinlistdo
4methodPairs ,specs←MineSpec( t/prime,t);
5foreachpinmethodPairs do
6 UpdateMethodPairStats( p,DB);
7foreachsinspecsdo
8 UpdateSpecDB( s,DB);
9ifSize(list)=kthen
10RemoveFirst( list);
same request. From the subroutine MineSpec , the algorithm gets a
set of method pairs and a set of specifications. These pairs cover
request-handler methods between which the algorithm tries toidentifydatadependencies.Thealgorithmstoresthesepairs(via
UpdateMethodPairStats() ) for the statistical purpose of calcu-
latingandupdatingthe confidence ofeachminespecificationvia
UpdateSpecDB() .Foraspecification s,wedefineits confidence as
the frequency of having the specification sidentified between two
request-handlermethodswhenthesetwomethodsappeartogether
in different trace pairs. We use confidence as an indicator of the
likelihood that a specification is true and worth further analysis.
Algorithm 2 shows the subroutine MineSpec , which does the
actual work to infer data dependencies across two methods. The
basicideaofthisalgorithmistocheckwhethersomeoutputvaluesfromthetraceofonerequestandsomeinputvaluesfromthetraceofanotherrequestareequal.Apairofequalvaluesindicatesapossible
inter-request data dependency. The adoption of this equivalence
relation is backed by the observations that (1) unique values likely
exist to approximate the actual dependencies, and (2) these values
areusuallycarriedfromtheoutputofonerequesttotheinputof
anotherwithoutcomplexcomputationsinbetween.Forexample,
thevalueof patient.patientId wouldbeuniqueforeverypatient,
and the value is not involved in any complex computation.
Inparticular,Algorithm2 takestwotraces t1andt2toperform
thefollowing threemajorsteps. First,it extractsoutputand input
related events from t1andt2. The extracted events include Out-
putEvent andOutputAccessEvent, indicatingthe outputof request-
handlermethod(s)in t1,andInputEvent andInputAccessEvent,in-
dicating the input of method(s) in t2. SinceOutputAccessEvent
andInputAccessEvent record method-invocation sequences, the
same invocation sequence in different events essentially reflectseither repetitive or iterative data-access actions, which may in-dicate a many-to-one relation between the output and input ofthe request-handler methods (i.e., the
CHOICE case in specifi-
cations). Therefore, the algorithm clusters events that record anidentical invocation sequence (via
ClusterOutputEvents() and
ClusterInputEvents() ) to form an event set, which is used in
later steps as a whole to represent identical object-access actions.
Given the clustered input and output events, the second step
constructsamatchingtabletocomputepotentialdatadependencies
using concrete values recorded in these events. As shown below,
therowsofthetablerepresentclusteredoutputeventsintrace t1,Algorithm 2: MineSpec on a Trace Pair
Input:Two traces t1andt2
Output: A setmethodPairs storing pairs of request-handler methods, and
a setspecsstoring derived data-dependency specifications
1methodPairs ←[ ];
2specs←[ ];
3oEventList ←ClusterOutputEvents( t1);
4iEventList ←ClusterInputEvents( t2);
5matchTable ←ConstructMatchTable( oEventList ,iEventList );
6fori←0;i<Size(oEventList );i++do
7forj←0;j<Size(iEventList );j++do
8 matchType ←matchTable [i][j];
9 ifmatchType is not no-match then
10 s←CreateSpec( matchType ,oEventList [i],
iEventList [j]);
11 Add(specs,s);
12 method1←GetMethodName( oEventList [i]);
13 method2←GetMethodName( iEventList [j]);
14 Add(methodPairs ,(method1,method2));
15returnmethodPairs ,specs;
and the columns represent clustered input events in trace t2.
t2Event Input1t2Event Input2
t1Event Output 1no-match one-to-one
t1Event Output 2no-match no-match
t1Event Output 3many-to-one no-match
... ... ...
For each cell of the table, the algorithm extracts concrete values
from theevents, and checksfor matched values, resultingin one ofthreetypesofoutcomes:(1)novalueismatched,thenthealgorithm
marksthecellas no-match ;(2)asinglevalueismatched,andthe
output and input events each contains only one concrete value,
thenthealgorithmmarksthecellas one-to-one ;(3)asinglevalueis
matched,andtheoutputeventcontainsmultipleconcretevalues,
then the algorithm marks the cell as many-to-one. We currently
donotconsiderthecaseof many-to-many,asitisnotcommonly
observed, but our approach can be extended to support such cases.
Withaconstructedmatchingtable,thealgorithmgoesovereach
cellinthetableandcreatesaspecificationforthecellthatindicates
a potential dependency (lines6-1 4i nAlgorithm 2). In particu-
lar,CreateSpec() (line 10)identifies(1) outputand inputentities
by tracking back from OutputAccessEvent orInputAccessEvent to
itscorresponding OutputEvent orInputEvent,(2)thechannel( =⇒)
that propagates an output object to the framework by determin-ing whether OutputEvent is from a return statement or an out-
parameter,and(3)thetransformationactions( − →)byextractingthe
invocationsequencefrom OutputAccessEvent orInputAccessEvent.
Withthematchingtypefromeachcell,thealgorithmcreatesaspec-
ificationdescribinghowanoutputobjectofamethodispropagated
and transformed into the input of another method.
4 EVALUATION
We have built a prototype of our approach for Java-based web
applications. We use Soot [ 11] for static analysis and instrumen-
tation, and Byte Buddy [56] for dynamic proxy creation. With theprototype, we evaluated the following aspects of our approach.
Specification Accuracy. We measure how accurate the gener-
ated specifications are in describing data dependencies between
request-handler methods. We consider a specification to be true if
it reveals a real data dependency between the involved methods
592
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Xiao Yu and Guoliang Jin
but not due to coincidentally equal values, and we manually exam-
ine and label each specification based on our understanding of the
subjects’ code and runtime behaviors.
TracingOverhead. Wemeasuretheruntimeoverheadimposed
by the tracing step. Measuring the tracing overhead helps us de-
terminetheapplicabilityofourapproachinvariousscenarios.A
manageable overhead would allow us to run more tests to achieve
a better coverage. If the measured overhead is low enough and
suitable ina production environment, wecan apply our approach
in the field to extract specifications based on real-world workload.
CharacterizationandApplication. Wemanuallystudyallthe
generatedspecificationstounderstandtheircharacteristicsandhow
they can facilitate program understanding and future inter-request
analyses.Wediscussthelessonslearnedandtheexperienceofusing
the specifications for tuning object cache policies.
4.1 Subjects
We evaluated our approach on two open-source Java-based web
applications:ITracker[ 20](version3.3.2),anissue-trackingsystem,
and OpenMRS [33] (version 1.11.5), a medical-record system.
ITrackerhasabout37,000linesofJavacodeandabout8,000lines
ofview-templatecode.ItusesStruts[ 5]asthesupportingframe-
work. The request-handler methods defined under Struts follow
the convention that method inputs and outputs are passed through
special objects, such as HttpRequest objects. For the evaluation,
we randomly generated a data set containing 10 developers, 20
projects, and 200 bugs randomly distributed among the 20 projects.
OpenMRS has about 204,000 lines of Java code and about 25,000
linesofview-templatecode.ItusesSpring[ 37]asthesupporting
framework, and it contains request-handler methods defined inthree different forms: (1) methods using special objects to pass
inputs and outputs, (2) a workflow-based model requiring multiple
methods to process a single request (e.g., a method to create a
view and another method to create data objects), and (3) a modern
modelpassingmethodinputsandoutputsdirectlythroughmethodparametersbysimplevaluesandcollection-basedobjects.Weusean
anonymized data set with 5,000 patients and 500,000 observations.
Thesetwoapplicationsusetwowidelyadoptedrequest-based
frameworks in a non-trivial way. The two frameworks have differ-
ent programming interfaces and paradigms, which lead to differ-
encesintheimplementationofrequest-handlermethods.Weuse
thetwoapplicationstoshowthegeneralityandusefulnessofour
approach on applications using different frameworks.
4.2 Experiment Design
Togenerateconcreteapplicationexecutions,wehaveimplemented
a random workload generator using Selenium [ 46], a web-browser
basedtestingframework.Thegeneratordrivesawebbrowserto
simulate user actions on web pages, such as clicking hyperlinks.
These actions can trigger requests to the applications. In particular,
thegeneratoridentifiesactionableelementsoneachpage,andthen
performs an action on a randomly selected element. The identified
elements include hyperlinks, web forms, input elements, and so
on. For each element, the generator applies a corresponding action:
clicking for a hyperlink or a button, and generating random butdomain-specificdataforawebform.Withthesecapabilities,theTable 2: Specification accuracy of ITracker and OpenMRS
Subject (Window Size) #o fS pec s # of True Specs Accuracy
ITracker (reflective) 0 0 N/A
ITracker (2) 64 54 84.38%
ITracker (3) 16 14 87.50%
ITracker (4) 2 0 0.00%
ITracker (5) 0 0 N/A
ITracker (Total) 82 68 82.92%
OpenMRS (reflective) 15 15 100.00%
OpenMRS (2) 20 17 85.00%
OpenMRS (3) 32 20 62.50%
OpenMRS (4) 11 1 9.09%
OpenMRS (5) 12 0 0.00%
OpenMRS (Total) 90 53 58.89%
generator can keep running to cover a wide range of request se-quencesonthesubjectapplications.Giventherandomnatureof
the generator, the workload it generates may not cover all possible
real-world request sequences. Therefore, our results need to be
interpreted with the random workload in mind.
We configure the generator with 10 distinct random seeds to
exercisedifferentrequestsequencesinthesubjects.Foreachseed
configuration, we run the generator 10 times. Each run starts with
the same database state and consists of 500 simulated user actions.
Ourresultsshowthatthissetupallowsourapproachtodiscover
mostofthepossibleandvalidspecifications.Althoughweaimat
producing repeatable results, the generator may encounter non-deterministic and unexpected behaviors from Selenium and thenetwork. So we choose a relatively small number of actions foreach run to reduce the potential divergences on the request se-
quences, which are supposedly fixed by each random seed, and re-
peatedly run each configuration to get stable results. Nevertheless,
ourreportedresultsmaystillbeaffectedthelikelynondeterminism.
Toevaluatespecificationaccuracy,weuseaslidingwindowwith
an increasing size to process the generated traces. Starting fromsize two, we keep increasing the window size until our manual
inspection determines that the increased window does not yield
new true specifications not seen in smaller windows. In the results,
weonlyconsiderspecificationsobservedatleast100timeswitha
confidence (defined in Section 3.3) of at least 0.2. These thresholds
arechosentoensurethatmosttruespecificationswouldlikelybe
reported, while most false specifications would likely be filtered
out. We consider the reported results worth further inspection.
For tracing overhead, we record the processing time for each
request on the server side during experiment runs. Then we calcu-
latetheoverheadbycomparingtherecordedtimeofcorresponding
requests on the instrumented and uninstrumented subjects. We
includerequests fromrepeatedruns toamortize thelikelynonde-
terminism and performance anomaly.
4.3 Specification Accuracy
Table 2 presents the accuracy results for ITracker and OpenMRS
in different sliding-window sizes. Each row shows the statistics of
uniquespecificationsthatarenotfoundinsmallerwindows.The
column“#ofSpecs”showsthetotalspecificationsinthewindowof
sizeshownbythefirstcolumn,and“#ofTrueSpecs”showsthetotaltruepositivesthatwemanuallyidentified.Notethataspecification
593
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. Dataflow TunnelingICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
0500010000150002000025000
25% 50% 75% 100% 125% 150% 175% 200% 200%+# of Requests
Overhead Range
 ITracker
 OpenMRS
Figure 3: Tracing overhead by requests
maybefoundinwindowsofdifferentsizes,soweattributeittothe
smallestwindow.Forexample,“ITracker(3)”showsstatisticsofthespecificationsthatcanonlybefoundinwindowsizethreeorabove,
and “OpenMRS (reflective)” indicates specifications found between
request-handlermethodsthatprocessthesamerequest.Asaresult,
we observe decreased numbers of specifications in larger windows.
The results show that our approach is effective and can reach a
balancebetweentestingeffortsandresultaccuracywiththereport-ingthreshold.Wefindthatincreasingthewindowsizedoesproduce
morespecifications.Theadditionalspecificationsareeitherinfre-
quentornotdiscoveredundersmallerwindows.Ontheotherhand,
alargerwindowintroducesmorefalsepositives,whichlowerthe
overall accuracy. As we can observe from the results, a break point
existsfromwhichwemaynothavemoretrueuniquespecifications.
For instance, the accuracy of ITracker is steady under windows of
sizes two and three, but no new true specifications are found in
larger windows. This observation suggests that most specifications
can be found in small windows, and we candetermine the proper
window size by gradually increasing the mining window.
We also look into the false positives to investigate the causes. In
our mining step, any coincidentally equal output and input values
would lead to false positives. Confidence values can mitigate such
false positives to some extent. However, a specification with a
confidence of 100% does not necessarily mean a true positive, e.g.,
some of the false positives in OpenMRS have very high confidence
values. This is usually due to a combination of overlapped value
rangesandinsufficientdatapointsofdifferentkindsofdataobjects.
For instance, multiple distinct data objects in OpenMRS, such ashospital locations and question forms, have the same range of
identifier values, and sometimes appear in the same output. When
only a small number of such data objects exist in the database, the
chanceofoverlappedidentifiersincreases.Usingmorediversedata
sets (e.g., real-world data sets) can mitigate such problems.
4.4 Tracing Overhead
Thetracingoverheadonthetotalexecutiontimefromallexperi-
mentrunsis74.96%orITracker,and33.43%forOpenMRS.Figure3
presents the overhead results by requests. Each bar represents the
number of requests whose overhead falls into the range indicated
by thex-axis, e.g.,100% meansthe rangefrom75% (exclusive) to
100% (inclusive). Due to the space limit, we aggregate all the re-
questswhoseoverheadisabove200%intothelastbar.Alsonotethat the total number of requests for each subject is not exactly50,000, because some user actions may not trigger requests, and
some web pages may trigger background requests automatically.
Overall,theresultsshowthattheoverheadofnearly83%ofallre-
questsfallswithin100%.Giventhecurrentoverheadmeasurements,
we conclude that our approach is suitable for in-house testing and
feasible to be selectively applied in a production environment with
less strict performance requirements.
Wealsoobservesomerequestswithhighoverheadthatisrelated
tothelargenumberofobjectaccessesduringrequestprocessing.InITracker,afrequentrequestpathofhighoverheadis
/list_issues
withamedianoverheadof166.67%.Toshowalistofbugs,theview
templateaccesseseverybugobjectmultipletimestoretrievethe
bugidentifier,name,andotherinformation,withanaverageof695
methodinvocations per requestonthose objects.Thesituationis
similarin OpenMRS,e.g., /concept.htm witha medianoverhead
of 75.57% and 488 invocations per request on average.
4.5 Characterization
The mined specifications allow us to investigate common char-
acteristics of data dependencies across requests in the level of
request-handlermethods.Wenextdiscussourfindingsregarding
the propagation and use of inter-request data.
Among121truespecifications,86ofthemshowthepropagation
ofentityidentifiers,suchastheidentifierofapatientinOpenMRSoraprojectinITracker.OpenMRSandITrackerstoredomain-specific
entities with identifiers in databases, and create data objects repre-
sentingtheseentitieswhenaccessesareneeded.Toachievecertainfeatures,theseapplicationsmayneedthesameentityinprocessing
multiple related requests. For instance, ITracker needs the same
piece of project information in processing requests /list_issues ,
whichlistsallissuesintheproject,and /view_issue ,whichshows
aparticularissue.Toshareinformationacrossrequests,theseap-
plications choose to propagate entity identifiers instead of dataobjects. On incoming requests, request-handler methods receive
theseidentifiersandthenusethemtorecreatethecorresponding
data objects from the database.
Fortherestofthespecifications,15ofthemrepresentdatadepen-
dencies between request-handler methods that process the samerequest (e.g.,
getVisit() andshowForm() in Figure 2). As such
methodsareexecutedinthesamecontextwithoutgoingacrossthe
clientside,theydirectlypropagatedataobjectstothesupporting
framework, which further passes the objects to other methods.
The remaining 20 specifications involve values for pagination
andflags,andthepropagatedobjectsarenotinstancesofapplication-
definedclasses.Examplesincludeanintegervalueindicatingthe
number of total data entries, which allows a method to calculatehow many remaining entries need to be displayed, and a string
instructing the next action of a receiving method.
4.6 Application: Tuning Cache Policies
Asrevealedbyourcharacterizationstudy,entityidentifiersderived
from data objects are common in inter-request data propagation.
Therequest-handlermethodstendtousethepropagatedidentifiers
to recreate the corresponding data objects. Such behaviors leadto repetitive object creation, which can be expensive, because it
usually involves database queries.
594
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Xiao Yu and Guoliang Jin
The mined specifications can help pinpoint repetitive object cre-
ationbetweenrelatedrequest-handlermethods.Fortheexamplein
Figure 2, a hypothetical analyzer could work in the following way:
(1)applyingdataflowanalysisstartingfrom renderDashboard()
to identify the creation of the Patientobject (line 7) and its out-
put site (line 8), (2) using the specification on renderDashboard()
andgetVisit() as a summary to confirm that the parameter
patientId is an alias of patientId retrieved from the Patient
object, (3) continuing the analysis into getVisit() to identify the
creationofanother Patientobjectusingthesame patientId (line
35). The analyzer could then infer that the two Patient objects
represent the same entity, and suggest an optimization strategy,
e.g., caching the first Patientobject.
Wefollowthemethodologyofthishypotheticalanalyzertoman-
ually optimize repetitive object creation in our evaluation subjects
byleveragingtheobjectcachebuiltinHibernate[ 39].Hibernate
is used by both subjects as their data-access layer, and its cache is
controlled by configuration files specifying classes of objects to be
cached and their caching lifetimes.
Wefirstranktheminedspecificationsbytheirobservedtimes
to identify data objects whose identifiers are frequently propa-
gated across requests. The top identified objects are: Issueand
Project for ITracker, and Concept,Obs(Observation), Patient,
andVisitforOpenMRS.InITracker, IssueandProjectobjects
arenotcached,andwedirectlycreateanewlong-termcachepol-
icy for them. In OpenMRS, there is a default cache policy apply-ing a long-term cache policy with a 12,000-second lifetime for
Concept objects and a short-term policy with a 30-second life-
timeforPatientobjects.However,thecacheof Conceptobjects
is insufficient, as the objects referenced by Conceptobjects (e.g.,
ConceptName andConceptDescription ) are not included in the
defaultpolicy.Inaddition,thelifetimefor Patientobjectsistoo
shortformultiplerequestsofrelatedpatientfeatures.Therefore,we
amendthedefaultcachepolicytoinclude ObsandVisitobjects,
objectsreferencedby Conceptobjects,andchangethepolicyfor
Patientobjects to be long-term.
WerunthesameexperimentdescribedinSection4.2withand
without the updated cache policies, and we measure both database
queriesandexecutiontime.Areductionindatabasequeriesindi-
catesthatfewerdataobjectsarecreatedbyqueryingdatafroma
database, as the required objects are cached in the application. The
results show an average query reduction of 8.50% for ITracker and
5.05% for OpenMRS under our random workload, and the reduc-
tion in the total execution time is 3.32% for ITracker and 2.80% for
OpenMRS. The presented execution time is measured in an experi-
mental setup where the database server and application server are
deployedonthesamemachine.Weexpectagreatertimereduction
in a realistic setting where the network latency in accessing the
databaseintroducesmoreoverheadintheoverallexecutiontime.
On the other hand, the query count will remain stable, as it is less
sensitive to possible instabilities in the execution environment.
5 RELATED WORK
Analysisofwebapplications. Thereisawiderangeofworkon
webapplications,suchastesting[ 2,7,24,26,27,44,54,59],program
slicing [32,51,53], and security analysis [ 1,19,31,47,52,55]. Theproposed approaches perform their analysis based on some formsof data- or control-flows.
Someoftheapproaches[ 1,6,7,26,32,51]extractpagenaviga-
tion and/or data-flows across web pages. These approaches com-
monly rely on a language-specific model to analyze program code
(e.g., PHP) that directly generates dynamic page content. With a
modernizedpointofviewonframework-basedwebapplications,ourapproachfocusesonrequest-handlermethodsandtheirdata
dependencies, eliminating the involvement of web pages. We make
this choice because framework-based web applications are popular
nowadays and they expose request-handler methods as application
entry points instead of web pages.
Some other approaches, such as TAJ [ 53], F4F [47], and AN-
DROMEDA [ 52], perform analysis on framework-based web ap-
plications. These approaches require framework-specific model-
ing, and treat each request-handler method as a single entry point
of analysis. On the contrary, our approach is not tied to specific
frameworkimplementations,andcanenhancetheseapproachesby
providing inter-request data dependencies for end-to-end analysis.
Program specification mining and its applications. Existing work
has shown program specifications inferred from traces to be useful
in program analysis, such as data-flow specifications [ 15,17] for
complex libraries and dynamic language features, and specifica-
tionsinfinitestatemachines[ 9,10,18,22,23,29]forcomponent
interactions, API usages, and temporal invariants.
Withthepurposeofinter-requestanalysis,ourinferredspecifica-
tionsdescribedatadependenciesbetweenrequest-handlermethods
that are modularized by underlying frameworks. Our evaluation
hasshownausecaseoftuningcachepoliciestoreducedatabase
operations.Futureworkcanuseourspecificationstoautomatesuch
optimization and performmore fine-grained analysis in combina-
tionofmanyexistingapproaches[ 30,38,48].Forinstance,Tamayo
etal.[48]proposeanapproachtoconstructdependencygraphsfor
database operations. Ramachandra et al.[38] propose an approach
to identify database operations in the interprocedural scope to en-
ableprefetching.Ourspecificationscanenabletheseapproachestoperforminter-requestanalysisformoreoptimizationopportunities.
Asanotherexample,wealsoenvisionthatourspecificationscan
allowinformation-flowanalysistodetectsecurityvulnerabilities
and malicious flows across multiple requests.
Dynamictainttracking. Ourtracingapproachissimilartody-
namic tainttracking, which incurs anon-negligible runtime over-
head. Dytan, a generic taint tracking system[16], reports an over-
headfrom3000%to5000%.Phosphor,arecentsystemforJava[ 8],in-
cursanaverageoverheadof53.31%and220%atworst.Weconsider
the overhead of our approach to be on a par with these systems.
6 CONCLUSION
We present dataflow tunneling, which derives data-dependency
specifications between request-handler methods for request-based
applications.Theoutcomespecificationscanenable inter-request
analysis,whichallowsprogramanalysistoworkinthescopeacrossrequest-handlermethods.Asfuturework,weplantodevelopinter-
requestanalysis techniquesthatcanleverage theoutcomespecifi-cations to improve the quality of request-based applications.
595
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. Dataflow Tunneling ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
REFERENCES
[1]Abeer Alhuzali, Birhanu Eshete, Rigel Gjomemo, and V.N. Venkatakrishnan.
2016. Chainsaw: Chained Automated Workflow-based Exploit Generation. In
Proceedingsofthe2016ACMSIGSACConferenceonComputerandCommunications
Security (CCS ’16). ACM, New York, NY, USA, 641–652. https://doi.org/10.1145/
2976749.2978380
[2]Anneliese A. Andrews, Jeff Offutt, Curtis Dyreson, Christopher J. Mallery,
KshamtaJerath,andRogerAlexander.2010.ScalabilityIssueswithUsingFSMWeb
to Test Web Applications. Information and Software Technology 52, 1 (Jan. 2010),
52–66. https://doi.org/10.1016/j.infsof.2009.06.002
[3]Apache. 2010. The Apache Velocity Project. (2010). Retrieved March 8, 2017
from http://velocity.apache.org/
[4]Apache. 2016. Apache FreeMarker. (2016). Retrieved March 8, 2017 from
http://freemarker.org/
[5]Apache. 2017. Apache Struts. (2017). Retrieved March 8, 2017 from https:
//struts.apache.org
[6]Snigdha Athaiya. 2017. Inferring Page Models for Web Application Analysis.
InProceedings of the 26th ACM SIGSOFT International Symposium on Software
Testing and Analysis (ISSTA 2017). ACM, New York, NY, USA, 412–415. https:
//doi.org/10.1145/3092703.3098240
[7]Snigdha Athaiya and Raghavan Komondoor. 2017. Testing and Analysis of
WebApplicationsUsingPageModels.In Proceedingsofthe26thACMSIGSOFT
International Symposium on Software Testing and Analysis (ISSTA 2017). ACM,
New York, NY, USA, 181–191. https://doi.org/10.1145/3092703.3092734
[8]Jonathan Bell and Gail Kaiser. 2014. Phosphor: Illuminating Dynamic Data Flow
in Commodity JVMs. In Proceedings of the 2014 ACM International Conference on
ObjectOrientedProgrammingSystemsLanguages&Applications (OOPSLA’14).
ACM, New York, NY, USA, 83–101. https://doi.org/10.1145/2660193.2660212
[9]IvanBeschastnikh,YuriyBrun,JennyAbrahamson,MichaelD.Ernst,andArvind
Krishnamurthy. 2013. Unifying FSM-inference Algorithms Through Declarative
Specification. In Proceedings of the 2013 International Conference on Software
Engineering (ICSE ’13). IEEE Press, Piscataway, NJ, USA, 252–261. http://dl.acm.
org/citation.cfm?id=2486788.2486822
[10]Ivan Beschastnikh, Yuriy Brun, Sigurd Schneider, Michael Sloan, and Michael D.
Ernst.2011.LeveragingExistingInstrumentationtoAutomaticallyInferInvariant-
constrained Models. In Proceedings of the 19th ACM SIGSOFT Symposium and the
13th European Conference on Foundations of Software Engineering (ESEC/FSE ’11).
ACM, New York, NY, USA, 267–277. https://doi.org/10.1145/2025113.2025151
[11]Eric Bodden. 2017. Soot - A framework for analyzing and transforming Java and
Android Applications. (2017). Retrieved April 15, 2017 from https://sable.github.
io/soot/
[12]Martin Bravenboer and Yannis Smaragdakis. 2009. Strictly Declarative Spec-ification of Sophisticated Points-to Analyses. In Proceedings of the 24th ACM
SIGPLAN Conference on Object Oriented Programming Systems Languages and
Applications (OOPSLA ’09). ACM, New York, NY, USA, 243–262. https://doi.org/
10.1145/1640089.1640108
[13]AlvinCheung,SamuelMadden,OwenArden,andAndrewC.Myers.2012. Auto-maticPartitioningofDatabaseApplications. ProceedingsoftheVLDBEndowment
5, 11 (July 2012), 1471–1482. https://doi.org/10.14778/2350229.2350262
[14]Alvin Cheung, Samuel Madden, and Armando Solar-Lezama. 2014. Sloth: Being
LazyisaVirtue(whenIssuingDatabaseQueries).In Proceedingsofthe2014ACM
SIGMODInternational ConferenceonManagementofData (SIGMOD’14).ACM,
New York, NY, USA, 931–942. https://doi.org/10.1145/2588555.2593672
[15]Lazaro Clapp, SaswatAnand, andAlex Aiken.2015. Modelgen: MiningExplicit
Information Flow Specifications from Concrete Executions. In Proceedings of
the2015 InternationalSymposium onSoftware Testingand Analysis (ISSTA2015).
ACM, New York, NY, USA, 129–140. https://doi.org/10.1145/2771783.2771810
[16]James Clause, Wanchun Li, and Alessandro Orso. 2007. Dytan: A Generic Dy-
namicTaintAnalysisFramework.In Proceedingsofthe2007InternationalSym-
posiumonSoftwareTestingandAnalysis (ISSTA’07).ACM,NewYork,NY,USA,
196–206. https://doi.org/10.1145/1273463.1273490
[17]TomDeering,GaneshRamSanthanam,andSureshKothari.2015. FlowMiner:
AutomaticSummarizationofLibraryData-FlowforMalwareAnalysis.In Pro-
ceedings of the 11th International Conference on Information Systems Security -
Volume9478 (ICISS2015).Springer-VerlagNewYork,Inc.,NewYork,NY,USA,
171–191. https://doi.org/10.1007/978-3-319-26961-0_11
[18]Mark Gabel and Zhendong Su. 2008. Javert: Fully Automatic Mining of General
Temporal PropertiesfromDynamic Traces.In Proceedingsof the16th ACMSIG-
SOFT International Symposium on Foundations of Software Engineering (SIGSOFT
’08/FSE-16).ACM,NewYork,NY,USA,339–349. https://doi.org/10.1145/1453101.
1453150
[19]Wei Huang, Yao Dong, and Ana Milanova. 2014. Type-Based Taint Analysis
for Java Web Applications. In Proceedings of the 17th International Conference
on Fundamental Approaches to Software Engineering - Volume 8411. Springer-
Verlag New York, Inc., New York, NY, USA, 140–154. https://doi.org/10.1007/
978-3-642-54804-8_10[20]itracker. 2016. itracker. (2016). Retrieved March 8, 2017 from http://itracker.
sourceforge.net/
[21]Guoliang Jin, Linhai Song, Xiaoming Shi, Joel Scherpelz, and Shan Lu. 2012.
UnderstandingandDetectingReal-worldPerformanceBugs.In Proceedingsof
the 33rd ACM SIGPLAN Conference on Programming Language Design and Imple-
mentation (PLDI ’12). ACM, New York, NY, USA, 77–88. https://doi.org/10.1145/
2254064.2254075
[22]Ivo Krka, Yuriy Brun, and Nenad Medvidovic. 2014. Automatic Mining of
Specifications from Invocation Traces and Method Invariants. In Proceedings
of the 22nd ACM SIGSOFT International Symposium on Foundations of Soft-
ware Engineering (FSE 2014). ACM, New York, NY, USA, 178–189. https:
//doi.org/10.1145/2635868.2635890
[23]Ivo Krka, Yuriy Brun, Daniel Popescu, Joshua Garcia, and Nenad Medvidovic.
2010. Using Dynamic Execution Traces and Program Invariants to Enhance
BehavioralModelInference.In Proceedingsofthe32ndACM/IEEEInternational
ConferenceonSoftwareEngineering-Volume2 (ICSE’10).ACM,NewYork,NY,
USA, 179–182. https://doi.org/10.1145/1810295.1810324
[24]GuodongLi,EsbenAndreasen,andIndradeepGhosh.2014. SymJS:Automatic
Symbolic Testing of JavaScript Web Applications. In Proceedings of the 22Nd
ACMSIGSOFTInternationalSymposiumonFoundationsofSoftwareEngineering
(FSE 2014). ACM, New York, NY, USA, 449–459. https://doi.org/10.1145/2635868.
2635913
[25]YueLi,TianTan,YuleiSui,andJinglingXue.2014. Self-inferencingReflection
Resolution for Java. In Proceedings of the 28th European Conference on ECOOP
2014—Object-OrientedProgramming-Volume8586.Springer-VerlagNewYork,
Inc., New York, NY, USA, 27–53. https://doi.org/10.1007/978-3-662-44202-9_2
[26]Chien-Hung Liu. 2006. Data Flow Analysis and Testing of JSP-based Web Ap-plications. InformationandSoftwareTechnology 48,12(Dec.2006),1137–1147.
https://doi.org/10.1016/j.infsof.2006.06.003
[27]Chien-HungLiu,DavidC.Kung,PeiHsia,andChih-TungHsu.2000.Object-Based
DataFlowTestingofWebApplications.In Proceedingsofthe FirstAsia-Pacific
Conference on Quality Software (APAQS’00) (APAQS ’00). IEEE Computer Society,
Washington, DC, USA, 7–16. http://dl.acm.org/citation.cfm?id=786446.786478
[28]Benjamin Livshits,John Whaley, andMonica S.Lam. 2005. Reflection Analysis
for Java. In Proceedings of the Third Asian Conference on Programming Languages
and Systems (APLAS’05). Springer-Verlag, Berlin, Heidelberg, 139–160. https:
//doi.org/10.1007/11575467_11
[29]Davide Lorenzoli, Leonardo Mariani, and Mauro Pezzè. 2008. Automatic Gen-
erationofSoftwareBehavioralModels.In Proceedingsofthe30thInternational
ConferenceonSoftwareEngineering(ICSE’08).ACM,NewYork,NY,USA,501–510.
https://doi.org/10.1145/1368088.1368157
[30]AmitManjhi,CharlesGarrod,BruceM.Maggs,ToddC.Mowry,andAnthony
Tomasic. 2009. Holistic Query Transformations for Dynamic Web Applications.
InProceedings of the 2009 IEEE International Conference on Data Engineering
(ICDE ’09). IEEE Computer Society, Washington, DC, USA, 1175–1178. https:
//doi.org/10.1109/ICDE.2009.194
[31]MichaelMartinandMonicaS.Lam.2008. AutomaticGenerationofXSSandSQL
Injection Attacks with Goal-directed Model Checking. In Proceedings of the 17th
Conference on Security Symposium (SS’08). USENIX Association, Berkeley, CA,
USA, 31–43. http://dl.acm.org/citation.cfm?id=1496711.1496714
[32]HungVietNguyen,ChristianKästner,andTienN.Nguyen.2015. Cross-language
ProgramSlicing forDynamicWebApplications.In Proceedingsof the201510th
JointMeetingonFoundationsofSoftwareEngineering (ESEC/FSE2015).ACM,New
York, NY, USA, 369–380. https://doi.org/10.1145/2786805.2786872
[33]OpenMRS.2016. OpenMRS. (2016). RetrievedMarch8,2017fromhttp://openmrs.
org
[34]Oracle. 2013. JavaServer Pages Technology. (2013). Retrieved March 8, 2017
from http://www.oracle.com/technetwork/java/javaee/jsp/index.html
[35]Oracle.2013. JSPStandardTagLibrary. (2013). RetrievedMarch8,2017from
https://jstl.java.net/
[36]Oracle. 2013. Unified Expression Language. (2013). Retrieved March 8, 2017
from https://uel.java.net/
[37]Pivotal.2017. SpringFramework. (2017). RetrievedMarch8,2017fromhttps:
//projects.spring.io/spring-framework/
[38]KarthikRamachandraandS.Sudarshan.2012. HolisticOptimizationbyPrefetch-
ing Query Results. In Proceedings of the 2012 ACM SIGMOD International Confer-
ence on Management of Data (SIGMOD ’12). ACM, New York, NY, USA, 133–144.
https://doi.org/10.1145/2213836.2213852
[39]RedHat. 2017. Hibernate ORM. (2017). Retrieved March 8, 2017 from http:
//hibernate.org/orm/
[40]Thomas Reps, Susan Horwitz, and Mooly Sagiv. 1995. Precise Interprocedu-ralDataflowAnalysisviaGraphReachability.In Proceedingsofthe22NdACM
SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL
’95). ACM, New York, NY, USA, 49–61. https://doi.org/10.1145/199448.199462
[41]Atanas Rountev, Scott Kagan, and Thomas Marlowe. 2006. Interprocedural
DataflowAnalysisinthePresenceofLargeLibraries.In Proceedingsofthe15th
InternationalConferenceonCompilerConstruction(CC’06).Springer-Verlag,Berlin,
Heidelberg, 2–16. https://doi.org/10.1007/11688839_2
596
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Xiao Yu and Guoliang Jin
[42]AtanasRountev,MarianaSharp,andGuoqingXu.2008. IDEDataflowAnalysisin
the Presence of Large Object-oriented Libraries. In Proceedings of the Joint Euro-
peanConferencesonTheoryandPracticeofSoftware17thInternationalConference
onCompiler Construction (CC’08/ETAPS’08).Springer-Verlag,Berlin,Heidelberg,
53–68. http://dl.acm.org/citation.cfm?id=1788374.1788380
[43]Mooly Sagiv, Thomas Reps, and Susan Horwitz. 1996. Precise Interprocedu-
ral Dataflow Analysis with Applications to Constant Propagation. In Selected
Papers from the6th International Joint Conference onTheoryand Practice of Soft-
ware Development (TAPSOFT ’95). Elsevier Science Publishers B. V., Amsterdam,
The Netherlands, The Netherlands, 131–170. http://dl.acm.org/citation.cfm?id=
243753.243762
[44]Sreedevi Sampath, Valentin Mihaylov, Amie Souter, and Lori Pollock. 2004. A
Scalable Approach to User-Session Based Testing of Web Applications Through
Concept Analysis. In Proceedings of the 19th IEEE International Conference on
Automated Software Engineering (ASE ’04). IEEE Computer Society, Washington,
DC, USA, 132–141. https://doi.org/10.1109/ASE.2004.6
[45]Jason Sawin and Atanas Rountev. 2009. Improving Static Resolution of Dynamic
ClassLoadinginJavaUsingDynamicallyGatheredEnvironmentInformation.
AutomatedSoftwareEngineering 16,2(June2009),357–381. https://doi.org/10.
1007/s10515-009-0049-9
[46]Selenium. 2016. Selenium WebDriver. (2016). Retrieved March 8, 2017 from
http://www.seleniumhq.org/projects/webdriver/
[47]Manu Sridharan, Shay Artzi, Marco Pistoia, Salvatore Guarnieri, Omer Tripp,
andRyanBerg.2011. F4F:TaintAnalysisofFramework-basedWebApplications.
InProceedingsofthe2011ACMInternationalConferenceonObjectOrientedPro-
grammingSystemsLanguagesandApplications (OOPSLA’11).ACM,NewYork,
NY, USA, 1053–1068. https://doi.org/10.1145/2048066.2048145
[48]Juan M. Tamayo, Alex Aiken, Nathan Bronson, and Mooly Sagiv. 2012. Un-
derstanding the Behavior of Database Operations Under Program Control. In
Proceedings of the ACM International Conference on Object Oriented Programming
Systems Languages and Applications (OOPSLA ’12). ACM, New York, NY, USA,
983–996. https://doi.org/10.1145/2384616.2384688
[49]TechEmpower. 2016. Framework Benchmarks for Java Web Applications.
(2016). Retrieved March 8, 2017 from https://github.com/TechEmpower/
FrameworkBenchmarks/tree/master/frameworks/Java
[50]Andreas Thies and Eric Bodden. 2012. RefaFlex: Safer Refactorings for Reflective
JavaPrograms.In Proceedingsofthe2012InternationalSymposiumonSoftware
Testing and Analysis (ISSTA 2012). ACM, New York, NY, USA, 1–11. https://doi.org/10.1145/2338965.2336754
[51]Paolo Tonella and Filippo Ricca. 2005. Web Application Slicing in Presence of
DynamicCodeGeneration. AutomatedSoftwareEngineering 12,2(April2005),
259–288. https://doi.org/10.1007/s10515-005-6208-8
[52]Omer Tripp, Marco Pistoia, Patrick Cousot, Radhia Cousot, and SalvatoreGuarnieri. 2013. ANDROMEDA: Accurate and Scalable Security Analysis of
WebApplications.In Proceedingsofthe16thInternationalConferenceonFunda-
mental Approaches to Software Engineering (FASE’13). Springer-Verlag, Berlin,
Heidelberg, 210–225. https://doi.org/10.1007/978-3-642-37057-1_15
[53]OmerTripp,MarcoPistoia,StephenJ.Fink,ManuSridharan,andOmriWeisman.
2009. TAJ:EffectiveTaintAnalysisofWebApplications.In Proceedingsofthe30th
ACMSIGPLANConferenceonProgrammingLanguageDesignandImplementation
(PLDI’09).ACM,NewYork,NY,USA,87–97. https://doi.org/10.1145/1542476.
1542486
[54]D. A. Turner, M. Park, J. Kim, and J. Chae. 2008. An Automated Test Code
Generation Method for Web Applications Using Activity Oriented Approach. In
Proceedings of the 2008 23rd IEEE/ACM International Conference on Automated
Software Engineering (ASE’08). IEEEComputerSociety,Washington,DC, USA,
411–414. https://doi.org/10.1109/ASE.2008.61
[55]Gary Wassermann and Zhendong Su. 2007. Sound and Precise Analysis of
WebApplicationsforInjectionVulnerabilities.In Proceedingsofthe28thACM
SIGPLANConferenceonProgrammingLanguageDesignandImplementation(PLDI
’07). ACM, New York, NY, USA, 32–41. https://doi.org/10.1145/1250734.1250739
[56]Rafael Winterhalter. 2017. Byte Buddy. (2017). Retrieved April 15, 2017 from
http://bytebuddy.net/
[57]Dacong Yan, Guoqing Xu, and Atanas Rountev. 2012. Rethinking Soot for
Summary-based Whole-program Analysis. In Proceedings of the ACM SIGPLAN
InternationalWorkshoponStateoftheArtinJavaProgramAnalysis (SOAP’12).
ACM, New York, NY, USA, 9–14. https://doi.org/10.1145/2259051.2259053
[58]Greta Yorsh, Eran Yahav, and Satish Chandra. 2008. Generating Precise and
Concise Procedure Summaries. In Proceedings of the 35th Annual ACM SIGPLAN-
SIGACTSymposiumonPrinciplesofProgrammingLanguages (POPL’08).ACM,
New York, NY, USA, 221–234. https://doi.org/10.1145/1328438.1328467
[59]YunxiaoZou,ZhenyuChen,YunhuiZheng,XiangyuZhang,andZebaoGao.2014.
VirtualDOMCoverageforEffectiveTestingofDynamicWebApplications.In
Proceedings of the 2014 International Symposium on Software Testing and Analysis
(ISSTA 2014). ACM, New York, NY, USA, 60–70. https://doi.org/10.1145/2610384.
2610399
597
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. 