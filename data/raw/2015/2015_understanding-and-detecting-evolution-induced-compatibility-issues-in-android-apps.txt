Understanding and Detecting Evolution-Induced Compatibility
Issues in Android Apps
Dongjie He
State Key Laboratory of Computer
Architecture, Institute of Computing
Technology, CAS
University of Chinese Academy of
Sciences
Beijing, China
hedongjie@ict.ac.cnLian Li∗
State Key Laboratory of Computer
Architecture, Institute of Computing
Technology, CAS
University of Chinese Academy of
Sciences
Beijing, China
lianli@ict.ac.cnLei Wang
State Key Laboratory of Computer
Architecture, Institute of Computing
Technology, CAS
University of Chinese Academy of
Sciences
Beijing, China
wanglei2011@ict.ac.cn
Hengjie Zheng
State Key Laboratory of Computer
Architecture, Institute of Computing
Technology, CAS
University of Chinese Academy of
Sciences
Beijing, China
zhenghengjie@ict.ac.cnGuangwei Li
State Key Laboratory of Computer
Architecture, Institute of Computing
Technology, CAS
University of Chinese Academy of
Sciences
Beijing, China
liguangwei@ict.ac.cnJingling Xue
University of New South Wales
School of Computer Science and
Engineering
Sydney, Australia
jingling@cse.unsw.edu.au
ABSTRACT
The frequent release of Android OS and its various versions bring
many compatibility issues to Android Apps. This paper studies
and addresses such evolution-induced compatibility problems. We
conduct an extensive empirical study over 11 different Android
versionsand4,936AndroidApps.Ourstudyshowsthatthereare
drastic API changes between adjacent Android versions, with aver-
agely140.8newtypes,1,505.6newmethods,and979.2newfields
being introduced in each release. However, the Android Support
Library (provided by the Android OS) only supports less than 23%
ofthenewlyaddedmethods,withmuchlesssupportfornewtypes
and fields. As a result, 91.84% of Android Apps write additional
codetosupport differentOSversions.Furthermore,88.65% ofthe
supporting codes share a common pattern, which directly com-
paresvariable android.os.Build.VERSION.SDK_INT withaconstant
version number, to use an API of particular versions.
Basedonourfindings,wedevelopanewtoolcalledIctApiFinder,
to detect incompatible API usages in Android applications. Ic-
tApiFindereffectivelycomputestheOSversionsonwhichanAPI
maybeinvoked,usinganinter-proceduraldata-flowanalysisframe-
work.ItdetectsnumerousincompatibleAPIusagesin361outof
1,425 Apps. Compared to Android Lint, IctApiFinder is sound and
∗Corresponding author
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,
topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ’18, September 3–7, 2018, Montpellier, France
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.3238185able to reduce the false positives by 82.1%. We have reported the is-
suesto13Appsdevelopers.Atpresent,5ofthemhavealreadybeen
confirmedbytheoriginaldevelopersand3ofthemhavealready
been fixed.
CCS CONCEPTS
•Software and its engineering →Automated static analysis ;
Software reliability; Software safety ;
KEYWORDS
Android compatibility, incompatible API usage, Android evolution
ACM Reference Format:
Dongjie He, Lian Li,Lei Wang, Hengjie Zheng, Guangwei Li, andJingling
Xue. 2018. Understanding and DetectingEvolution-Induced Compatibility
Issues in Android Apps. In Proceedings of the 2018 33rd ACM/IEEE Inter-
nationalConferenceonAutomatedSoftwareEngineering(ASE’18),Septem-
ber 3–7, 2018, Montpellier, France. ACM, New York, NY, USA, 12pages.
https://doi.org/10.1145/3238147.3238185
1 INTRODUCTION
Android is the most popular mobile operating system with over
80% market share [ 10]. The number of Android applications is
increasing at an alarming speed, with about 35,000 new Apps re-leased on Google Play every month [
1]. However, Android OS is
released frequently and it is a well-known challenge for the ap-
plicationdeveloperstodealwithcompatibilityissuesondifferent
OS versions [ 27,39]. This challenge is now a hot topic on internet
forums such as Stack Overflow (414 different topics), and the de-
velopershavetodealwithcomplaintsfromusersaboutthepoor
compatibility of their Apps frequently.
There are no mature tools to detect evolution-induced compat-
ibility issues for Android Apps, i.e., compatibility issues caused
by Android system evolution. Existing studies have investigated
167
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:09 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Dongjie He, Lian Li, Lei Wang, Hengjie Zheng, Guangwei Li, and Jingling Xue
severalaspectsoftherelatedissues.Forexample,previousworks
[37,41,44] try to understand software reuses in Android Apps and
find them heavily depend on Android API. McDonnell et al.[ 36]
studiedhowfastAndroidAPIevolvesandtheimpactofAPIevo-
lution on the compatibility issues of Android Apps. Li et al.[ 30]
studied inaccessible Android APIs and concluded that inaccessible
APIs used in Apps are neither forward nor backward compati-
ble. FicFinder[ 47] uses API-context pairs (manually extracted from
known compatibility issues) to detect unknown fragmentation-
induced compatibility issues. Although these works are helpful in
understanding evolution-induced compatibility issues for Android
Apps,littleisknownonhowdevelopersfixsuchissues,whether
theseissuesarecommoninAppsandwhataretheirrootcauses.In
addition, existing studies have not investigated these issues down
to the source code level. Hence, they cannot provide deeper in-
sights (e.g., common fixing patterns) to understand and mitigate
evolution-induced compatibility issues.
To better understand evolution-induced compatibility issues in
AndroidApps,weconductanextensiveempiricalstudyoverthe
11 most popular Android OS versions and 4,936 Android Apps. We
findthat91.84%ofAndroidAppswritespecificcodetodealwith
evolution-inducedcompatibilityissues.Thisisduetothedrastic
API changes induced by Android evolution and the insufficient
support from the Android Support Library: there are 140.8 new
types, 1,505.6 new methods, and 979.2 new fields being introduced
ineachnewSDKreleaseandonly21.60%newtypes,22.74%new
methods, and 5.36% fields are supported by the Support Library.
Furthermore,wefindthatfixingevolution-inducedcompatibility
issues in Android Apps is usually very simple: 88.65% of themcompare the variable
android.os.Build.VERSION.SDK_INT , abbreviated
asSDK_INT, with a constant integer value directly to check the
versionsoftheunderlyingAndroidOS.Webelievethesefindings
can provide guidance to detect, diagnose and fix evolution-induced
compatibility issues.
Based on our findings, we develop IctApiFinder, a new tool to
automatically detect incompatible API usages in Android Apps.IncompatibleAPIusagesareonetypeofevolution-inducedcom-
patibilityissueswhichinvokeAPImethodsnotsupportedbythe
underlyingAndroidversions.Theyareseriousbugswhichoften
crash the Apps and throw “ java.lang.NoSuchMethodError ” excep-
tions. IctApiFinder computes on which Android versions each API
canbeinvoked,usinganinter-proceduraldata-flowanalysisframe-
work. It then checks whether an API invocation is incompatible
ornotbyexaminingeachspecificAndroidSDKversion.Wehave
implemented IctApiFinder in Soot[ 46] and have applied it to 1,425
Android Apps downloaded from F-Droid[ 8], where 361 Apps have
been found to be problematic. We have manually analyzed the bug
reports from 20 randomly selected Apps, and have found that our
tool could effectively reduce 82.1% false positives compared to An-
droid Lint, a tool available in Android SDK. We have reported our
findings to their original developers for 13 of the 20 Apps: 5 re-
portedissueshavebeenacknowledgedbytheiroriginaldevelopers,
and3ofthemareconsideredascriticalbugswhichhavealreadybeenfixed.Notethatonealready-fixedbugisactuallycausedbyan external library, which cannot be found by Android Lint, and
isalsodifficulttodiagnoseforthedevelopers.Tosummarize,this
paper makes the following contributions:•We conduct the first empirical study of evolution-induced
compatibilityissuesonlarge-scale,real-worldAndroidApps
(4,936 Apps and 11 Android OS versions). Our findings can
help to better understand and characterize such issues, and
shed lights on future studies on this topic.
•Weproposeanewmethodtoautomaticallydetectincompat-ibleAPIusagesinAndroidApps,bypreciselycomputingthe
reachable Android OS versions for each API (the OS versions
onwhichtheAPImaybeinvoked)usinganinter-proceduralcontext-sensitivedata-flowanalysisframework.Ourmethoddrasticallyimprovestheprecisionofexistingtools,reducing
the false positives of Android Lint by 82.1%.
•We design and implement a new tool, IctApiFinder, to auto-
maticallydetectincompatibleAPIusagesinAndroidApps.
IctApiFinder have detected incompatible API usage bugs in
361 out of 1,425 Apps. We have reported our findings to
theiroriginaldevelopersfor13randomly-selectedApps,5
reportedissueshavebeenacknowledgedand3criticalissues
have already been fixed.
The rest of this paper is organized as follows: Section 2presents
the necessary background information. Section 3describes our
empirical study. We propose our detection method in Section 4
and evaluate it in Section 5. We discuss the threats to validity
in Section 6and summarize related works in Section 7. Finally,
Section8concludes the paper.
2 BACKGROUND
Android is a fast evolving system. The platform provides APIs (i.e.,
Android SDK) to its applications as the programming interfaces.
TheseinterfaceskeepchangingasAndroidevolves.Byconvention,
versions of Android SDKs are differentiated using a unique integer
identifier,named APIlevel [4].TheAPIlevelstartsfrom1,andat
present, the API level of the latest SDK version is 27.
2.1 Declare SDK Versions in Android Apps
Listing 1: Example code snippet to declare SDK versions.
1<uses-sdk
2android:minSdkVersion ="10"
3android:targetSdkVersion ="27"
4android:maxSdkVersion ="27"/>
Android Apps need to declare their supported SDK versions via
the<uses-sdk> element in their manifest files (i.e., AndroidMani-
fest.xml) [ 48]. As shown in Listing 1, there are 3 attributes given
integer values:
•minSdkVersion. TheminSdkVersion value declares the
minimum API level supported by an App. The App will
not be installed on an Android system if its minSdkVersion
value is larger than the API level of the underlying system.
•targetSdkVersion. ThetargetSdkVersion value defines
the API level that an App targets at. Android adopts the
backward-compatibleAPIbehaviorsofthedeclaredtarget
SDKversion,evenwhentheAppisrunningonahigherSDK
version.Thisdesignaimstoensureconsistentbehaviorof
the Apps on different SDK versions.
•maxSdkVersion. ThemaxSdkVersion value gives the max-
imum platform API level on which an App can run. This
168
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:09 UTC from IEEE Xplore.  Restrictions apply. Understanding and Detecting Evolution-Induced Compatibility Issues in Android AppsASE ’18, September 3–7, 2018, Montpellier, France
attributeisalreadydeprecatedsinceAndroid2.1(APIlevel
7).
ThedeclaredSDKversionsonlysuggestonwhichversionsan
App can be installed. In practice, App developers commonly use
the runtime value of variable SDK_INT to check the SDK version of
the underlying system [47].
2.2 Android Support Library
Android OS provides the Android Support Library as a basic so-
lution to tackle the increasingly severe evolution-induced com-
patibility issues. This library was firstly released in 2011. It hassince become the most widely used Android library [
3]. The An-
droidSupportLibraryconsistsofacollectionoflibrarieswhichcan
roughly be divided into two groups: compatibility and component
libraries [15].
Compatibilitylibrariesfocusonbackportingfeaturesfornew
SDK releases. It provides wrappers for a subset of interfaces (or
types)ondifferentSDKversions.InsteadofinvokingAPIsprovided
by the SDK directly, Apps can call the wrappers in the Supportlibrary. As such, Apps developed for a new SDK version may be
abletorunonpreviousSDKversions,withoutmodification.The
major compatibility libraries are v4- and v7-appcompat.
Component libraries implement features that are not part of the
standard framework. These self-contained libraries can be easily
addedorremovedfromaprojectwithoutconcerningfordependen-
cies.Themajorcomponentlibrariesincludev7-recyclerviewand
v7-cardview. In this paper, we focus on the compatibility libraries
since the component libraries do not handle compatibility issues.
2.3 Android Lint
AndroidLintisacodescanningtoolintroducedinADT(Android
Development Tools) 16. It checks for various potential bugs and
optimizationimprovements.Thetoolintegratedinthelatestversion
of Android Studio features more than 200 default checks. One of
them called ApiDetector aims to detect incompatible API usages.
This check scans through all invocations to Android APIs. It warns
about an invocation to a particular API if it is not available on
SDK versions supported by the App, as declared in its manifest file.
Lint ignores code snippets annotated with certain annotations, e.g.,
@TargetApi and@SuppressLint [11]. Although not mentioned
in any documents, we notice that Lint avoids false positives by
ignoring code patterns when an API is invoked in an ifstatement
whose condition compares variable SDK_INT to an integer value to
check the underlying Android SDK version.
3 EMPIRICAL STUDY
The study tries to address the following three research questions.
•RQ1:(Root cause): Whataretherootcausesofevolution-
induced compatibility issues?
•RQ2:(Issueseverity): Howcommonaretheseissuesinreal
Android Apps?
•RQ3:(Issuefixing): HowdoAndroiddevelopersfixevolution-
induced compatibility issues in practice?3.1 Methodology
To answer the above research questions, we collect a large set of
data consisting of 11 Android SDK versions (together with the
AndroidSupportLibraryintheseversions),and4,936Apps.This
subsection presents our datasets and analytical methods.
Table 1: List of selected Android SDK versions.
Level Revision Shares # Types # Methods # Fields
16 android-4.1.2_r2.1 1.7% 3,217 30,057 11,679
17 android-4.2.2_r1.2b 2.6% 3,259 30,569 12,00418 android-4.3_r3.1 0.7% 3,290 31,104 12,51219 android-4.4_r1.2.0.1 12.0% 3,412 32,139 13,32521 android-5.0.2_r3 5.4% 3,673 35,426 16,333
22 android-5.1.1_r9 19.2% 3,683 35,568 16,380
23 android-6.0.1_r9 28.1% 3,471 35,239 16,75724 android-7.0.0_r7 22.3% 3,823 39,773 20,01625 android-7.1.2_r9 6.2% 3,828 39,896 20,07626 android-8.0.0_r9 0.8% 4,181 44,307 21,41927 android-8.1.0_r9 0.3% 4,201 44,455 21,471
3.1.1 DatasetsCollection. Weconsider APIlevels 16-27inour
research. TABLE 1presents the selected Android SDK versions
(Column2)andtheirmarketshares(Column3).Theotherversions
arenotselectedsincetheirmarketsharesarenegligible.APIlevel
20 is specific to wearable devices thus it is not included in our
study either [ 30]. We compile the sources of these SDK versions
downloadedfromAOSP[ 5].Foreachversion,weextractitsSDK
(android.jar) and the corresponding Support Library for further
study.ThelastthreecolumnsinTABLE 1givethenumberoftypes,
methods, and fields in each SDK version, respectively.
Weconductourstudyusingalargesetofthird-partyApps(in
APK format, without source code) downloaded from the Andro-
Zoorepository[ 18].AndroZooisaspecializedrepositoryforthe
researchcommunity,andwetotallydownload8,047Appsfromit.
In this study, we only consider Apps targeting our selected APIlevels (i.e.,
targetSdkVersion value ranges from 16 to 27), and
4,936 Apps are selected.
Table 2: List of manually inspected Apps. The 10 Apps in
F-Droid with the most usage counts of variable SDK_INT are
selected.
APP Release KLOC # SDK_INTs
org.telegram.messenger 4.6.0a 324.2 531
com.poupa.vinylmusicplayer 0.16.4.4 35.8 209
org.glucosio.android 1.3.0-FOSS 8.2 195
com.amaze.filemanager 3.2.1 30.3 185
im.vector.alpha 0.8.1 52.5 185com.github.axet.maps 8.1.0-4-Google 120.9 179com.biglybt.android.client 1.1.4 483.8 173eu.kanade.tachiyomi 0.6.8 2.7 165org.bottiger.podcast 0.160.2 41.9 165es.usc.citius.servando.calendula 2.5.3 26.3 154
TABLE2lists the 10 open-source Apps downloaded from F-
Droid[8] (a popular open-source App store) for manual inspection.
The 10Apps are selected becausethey frequently usethe variable
SDK_INT, which is commonly used by developers to check specific
SDKversionsandaddresscompatibilityissuesonthoseversions.
We write a crawler to download all latest version of the total 1,425
Apps in F-Droid. The 10 Apps which use variable SDK_INT for
169
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:09 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Dongjie He, Lian Li, Lei Wang, Hengjie Zheng, Guangwei Li, and Jingling Xue
the most number of times are chosen. Column 4 gives the usage
counts of variable SDK_INT for each App. We manually inspect the
sourcecodesofthe10Apps,tounderstandhowdevelopersaddress
evolution-induced compatibility issues in practice.
3.1.2 Analytical Methods. To answer RQ1, we compare the
differencesbetweenany twoadjacentSDKversions.Specifically,
we check whether any newly introduced APIs are supported by its
corresponding Android Support library or not. To answer RQ2, we
useSoot[ 46]toscanthe4,936AppsdownloadedfromAndroZoo,
and count how many times the variable SDK_INT is used. In our
experiments, we assume that variable SDK_INTis mostly used to
test the underlying SDK version and address evolution-induced
compatibility issues. We manually inspect the code snippets where
SDK_INTis used for the 10 Apps in TABLE 2, to answer RQ3 and
validate the above assumption.
3.2 Findings
(a) Type
(b) Method
(c) Field
Figure 1: Differences between adjacent SDK versions.
3.2.1 RQ1: Root cause.
•Finding 1: AndroidSDKversionevolutionleadstosignifi-
cant API changes.
Figure1comparesthedifferencesbetweentwoadjacentSDKver-
sions.WeobservedramaticchangesasAndroidSDKevolves.On
average,140.8newtypes,1,505.6newmethodsand979.2newfields
are introduced, as the Android SDK evolves into a new version.
•Finding 2: Android Support Library provides support for
less than 23% of the new introduced APIs.
TheAndroidSupportLibraryisintroducedtoeasecompatibility
issuesintheAndroidecosystem.Wearecuriousabouthowwell
theyaddresscompatibilityissuesbetweendifferentSDKversions.
In our research, we compare any two adjacent SDK versions by
checkinghowmanynewlyintroducedAPIs(types,methods,and
fields)aresupportedbytheAndroidSupportLibrary.Weconser-
vativelyassumethatanAPIissupportedbytheAndroidSupportLibraryifitisusedinthelibrary.Thisgivesusanoptimisticestima-
tion,sincetherearealsonormalusagesbesidesthoseaswrapper
methods. Disappointingly, the support ratio is only 21.60% for new
types,22.74%fornewmethods,and5.36%fornewfields,suggesting
insufficientsupporttoaddresstheprevalentcompatibilityissues.
Table 3: API changes supported by the Android Support Li-
brary.
#Supported / #New introduced
Adjacent Levels Type Method Field
17vs18 0/67 0/744 0/571
18vs19 6/122 75/1,044 91/813
19vs21 11/265 136/3,383 3/3,02221vs22 0/10 4/154 0/6422vs23 2/152 2/1,970 0/82323vs24 102/355 1,100/4,605 179/3,267
24vs25 1/5 7/132 0/60
25vs26 164/357 2,424/4,450 261/1,350
•Finding 3: Without considering API behavioral changes,
86% of Apps can directly run on the next Android version
withoutany modification.Thus,evolution-inducedcompat-
ibility issues are mainly introduced from API behavioral
changes and new features in later SDK versions.
4041
426
71 13411 14
050010001500200025003000350040004500
0 1~49 50~99 100~499 500~999 >=1000APK
Figure 2: Distribution of Apps using abandoned APIs.
Figure2counts how those APIs abandoned in the next SDK
version are used in Android Apps. The interesting fact is that 4,041
Appsoutofthetotal4,697AppsdonotuseanyabandonedAPIs.
Hence,ifnotconsideringAPIbehavioralchanges,wecanconclude
that 86% Apps can run on a later SDK version without any mod-
ification.Thisimpliesthatdevelopersaddressevolution-induced
compatibility issues mainly because they need to adapt API behav-
ioral changes or use new features in later SDK versions.
Answer to RQ1: To summarize, the main causes of
evolution-induced compatibility issues in Android Apps
are the drastic API changes induced by Android evolution,
and the insufficient support from the Android Support
Library. As a result, App developers often have to deal
withevolution-inducedcompatibilityissuesinordertouse
latest features and support multiple SDK versions.
170
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:09 UTC from IEEE Xplore.  Restrictions apply. Understanding and Detecting Evolution-Induced Compatibility Issues in Android AppsASE ’18, September 3–7, 2018, Montpellier, France
3.2.2 RQ2: Issue severity.
•Finding 4: 91.84% of Apps write specific code to address
evolution-induced compatibility issues.
We use Soot [ 46] to analyze the 4,936 Apps downloaded from
AndroZoo,where32Appscannotbeprocessed.Amongtheremain-
ing 4,904 Apps, 4,504 Apps use variable SDK_INT (usages in the
Android support libraries, e.g., classes whose name started with
android.support.* , are excluded), suggesting that 91.84% of Apps
checktheunderlyingAndroidSDKversionstoaddressevolution-
inducedcompatibilityissuesintheirimplementation.Wealsocount
howmanytimes SDK_INT isusedineachApp.Onaverage,anApp
uses variable SDK_INTfor 55.45 times (Figure 3).
Figure 3: SDK_INTusage counts in Apps
•Finding 5: Less than 6.74% APIs are frequently used, and
SDK_INTis the most frequently used field.
Figure4studies the usages for each Android API: 54,593 APIs
have never been used by the 4,904 Apps we processed, and only
6.74% APIs are used by more than 100 Apps. We have manually
inspected the 66 APIs with more than one million usage numbers.
They can be classified into three categories: 33 APIs belong to
the JDK library, with 18 in java.lang.* ,1 2i njava.util.* and 3 in
java.io.* ;30APIsstartwith android.* ,with8in android.os.Parcel ,
5inandroid.util.Log ,4inandroid.os.Bundle ,3inandroid.content.-
Intent,2inandroid.app.Activity andandroid.os.Binder ,andother
6in6diffrentpackages,respectively;theremaining3APIsallbe-
long toorg.json.JSONObject . Moreover, we find that SDK_INT is
the only field with more than one million usage counts, which also
confirmsourfindingthattheAppsdevelopersfrequentlyhandle
evolution-induced compatibility issues by themselves.
54593
9811
30991533
0100002000030000400005000060000
0 1~100 101~1000 1001~4679API
Figure 4: Distribution of APIs by usage counts.
Answer toRQ2: Evolution-inducedcompatibilityissues
are very common and about 91.84% of Apps write specific
code to deal with such issues.3.2.3 RQ3: Issue fixing.
•Finding6: mostfixingpatternsareverysimple,complicated
patterns are rare.
We have manually inspected the 10 Apps in TABLE 2, and
found several common patterns to address evolution-induced com-
patibility issues. The most common practice is to invoke differ-
ent APIs directly on different versions, according to the runtime
value ofSDK_INT. Forexample, Listing 2shows acode snippetex-
tractedfrom com.amaze.filemanager [2],wheretheSDKAPImethod
quitSafely, instead of quit, is used after API level 18.
Listing2:Commonpracticetoaddressevolution-inducedin-compatibility issues.
1if(SDK_INT >= 18) {
2// let it finish up first with what it's doing
3handlerThread.quitSafely();
4}else
5handlerThread.quit();
Frequently,thedevelopersintroducewrappermethodstodeal
withevolution-inducedcompatibilityissues.Thecodesnippet(also
extracted from com.amaze.filemanager [2]) in Listing 3invokes dif-
ferent password encrypt wrappers ( CryptUtil.aesEncryptPassword
andCryptUtil.rsaEncryptPassword )fordifferentSDKversions,where
different SDK APIs are invoked by the wrappers accordingly.
Listing 3: Address evolution-induced compatibility issues
using wrapper methods.
1if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
2returnCryptUtil.aesEncryptPassword(plainText);
3}else if(Build.VERSION.SDK_INT >= 18) {
4returnCryptUtil.rsaEncryptPassword(context, plainText);
5}else
6returnplainText;
Inadditiontodirectlycheckthevalueof SDK_INT inanifstate-
ment, developers sometimes check the value of SDK_INT using dif-
ferentformsofexpressions,e.g.,ternaryexpressions.Listing 4uses
ternaryexpressionstodecidetheframesizefordifferentAndroid
versions.
Listing 4: Address evolution-induced compatibility issues
using ternary expression.
1LayoutHelper.createFrame(Build.VERSION.SDK_INT >= 21 ? 56 : 60,
2Build.VERSION.SDK_INT >= 21 ? 56 : 60, (LocaleController.isRTL
3? Gravity.LEFT : Gravity.RIGHT) | Gravity.BOTTOM,
4LocaleController.isRTL ? 14 : 0, 0, LocaleController.isRTL?0:1 4 ,14);
Complicatedpatternsareusuallyappliedtoadaptacompletenew
Type.Thesepatternsarerareinreal-worldApps(non-existinthe10
Appsweanalyze),butverycommonintheAndroidSupportLibrary.
Forexample, android.support.v4.view.ViewCompat isatypeusedto
adaptdifferentversionsoftype android.view.View .Listing5shows
the simplified code snippet. It uses different inner types to wrap
theAPIs fordistinctSDK versions(lines2-20),then initializesthe
static instance according to a particular SDK version (lines 21-33).
•Finding 7: The most common practice (88.65% of usages)
checkstheunderlyingSDKversionbycomparingthevari-
ableSDK_INT directly with a constant API level value.
Wehavemanuallyinspectedallusagesofvariable SDK_INTin
the 10 Apps in TABLE 2. There are 1,249 usages in total in the
source codes of the 10 Apps, usages in external libraries excluded.
Theusagepatternscanbeclassifiedinto3categories: SDK_INTis
171
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:09 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Dongjie He, Lian Li, Lei Wang, Hengjie Zheng, Guangwei Li, and Jingling Xue
directlycomparedwithaconstantvalue,andthecomparisonresult
isusedinconditionsof ifstatements( C1);thevalueof SDK_INT is
propagated toother variablesappearing in ifconditions (e.g.,via
field stores and loads), this is also a complicated pattern involving
complex dependencies ( C2); control-flow irrelevant usages like log-
printing ( C3).
Listing 5: Complicated fixing strategy in ViewCompat.
1public class ViewCompat {
2interface ViewCompatImpl {
3 voidsetElevation(View view, floatelevation);
4}
5static class BaseViewCompatImpl implements ViewCompatImpl {
6 @Override
7 public void setElevation(View view, floatelevation) {
8 }
9}
10static class EclairMr1ViewCompatImpl extendsBaseViewCompatImpl {...}
11static class GBViewCompatImpl extendsEclairMr1ViewCompatImpl {...}
12......
13static class KitKatViewCompatImpl extendsJbMr2ViewCompatImpl {...}
14static class LollipopViewCompatImpl extendsKitKatViewCompatImpl {
15 public void setElevation(View view, floatelevation) {
16 view.setElevation(elevation);
17 }
18}
19...
20static class Api24ViewCompatImpl extendsMarshmallowViewCompatImpl {...}
21static final ViewCompatImpl IMPL;
22static{
23 final int version = android.os.Build.VERSION.SDK_INT;
24 if(BuildCompat.isAtLeastN()) {
25 IMPL =newApi24ViewCompatImpl();
26 } ......
27 else if(version >= 21) {
28 IMPL =newLollipopViewCompatImpl();
29 } ......
30 else{
31 IMPL =newBaseViewCompatImpl();
32 }
33}
34public static void setElevation(View view, floatelevation) {
35 IMPL.setElevation(view, elevation);
36}
37}
TABLE4gives the usage counts of variable SDK_INT by cate-
gories.Mostoftheusages(88.44%)arecontrolflow-related(Columns
2 and 3), i.e., the value of SDK_INTis used directly or indirectly in
ifconditions. In addition, most usages (78.4%) adopt the simple
commonpractice C1(i.e.,directlycomparevariable SDK_INT witha
constant value) to check the SDK version of the underlying system.
TheApp org.telegram.messenger isanexception,itstoresthevalue
ofSDK_INT tostaticfield Util.SDK_INT ,whichisthencheckedfor
84 times. There are also many statements in that App printing the
valueofSDK_INT.Fortheother9Apps,thepercentageofcontrol
flow-relatedusages(Columns2and3),andthepercentageofthe
simplecommonpractice C1(Column2only)are97.14%and95.81%,
respectively.
Answer to RQ3: Most evolution-induced compatibility
issue fixing patterns are very simple. In particular, the
mostcommonpractice(78.4%)checks theSDKversionof
the underlying system by directly comparing the variable
SDK_INT with a constant value.Table 4: Categorized Usage counts of variable SDK_INT.
App Name #C1#C2#C3
org.telegram.messenger 409 84 109
com.poupa.vinylmusicplayer 48 0 4
org.glucosio.android 5 0 0com.amaze.filemanager 127 0 1im.vector.alpha 40 0 3com.github.axet.maps 39 2 4com.biglybt.android.client 38 1 1
eu.kanade.tachiyomi 31 0 0
org.bottiger.podcast 80 2 0es.usc.citius.servando.calendula 27 1 0
4 INCOMPATIBLE API USAGE DETECTION
According to our findings, 91.84% of Apps try to address evolution-
induced compatibility issues by checking the underlying SDK ver-
sion in their implementation. The developers need to use the right
version of API on each supported SDK version. However, this pro-
cessiserror-proneandoftenleadstoincompatibleAPIusages.A
query onGoogle and Stack Overflowusing the keyword “ Android
NoSuchMethodError ” gives us 162,000 results, and 414 topics, respec-
tively(April17,2018).Itisbecomingaprevalentproblem.However,
there are no tools to detect these issues precisely and effectively.
As a result, many Android Apps are poorly tested[28].
Android Lint can be used to detect incompatible API usages.
However,itisnotcommonlyusedbythedevelopersduetoitshigh
false positive rates. Listing 6gives an example. The API used on
line9isintroducedintoSDKafterlevel11,butthe minSdkVersion
issetto10.Hence,a“ java.lang.NoSuchMethodError ”exceptionwill
be thrown, crashing the App on SDK version 10. For this example,
AndroidLintwillreporttwoissues,online9andonline12,respec-
tively. The report on line 12 is a false positive because Lint does
not apply inter-procedural analysis and does not consider context-
sensitivity. In addition, Lint cannot detect incompatible API usages
in external libraries, leading to false negatives. Currently, Android
development uses Gradle[ 9] as the automated building tool and
Apps rely heavily on external libraries.
Listing 6: Example code snippet with incompatible
API usage.
1// minSdkVersion: 10; targetSdkVersion 27.
2public class MainActivity extendsActivity {
3privateTextView mView;
4protected void onCreate(Bundle bundle) {
5 ...
6 if(Build.VERSION.SDK_INT >= 24)
7 wrapper(mView, c, s, null, i);
8 else
9 mView.startDrag(c, s, null, i);// API1 [11, 23]
10}
11privatewrapper(View v, ClipData c, ...) {
12 v.startDragAndDrop(c, s, o, i); // API2 [24, 27]
13}
14}
4.1 Detection Method
We develop a new inter-procedural dataflow analysis to detect
incompatible API usages. Definition 4.1gives the necessary and
sufficient conditions for incompatible API usages.
Definition 4.1. For any App, the use of an API is incompatible if
and only if it satisfies the following three conditions:
172
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:09 UTC from IEEE Xplore.  Restrictions apply. Understanding and Detecting Evolution-Induced Compatibility Issues in Android AppsASE ’18, September 3–7, 2018, Montpellier, France
•ThereexistsaSDKversionwhoseAPILevelislargerthan
or equal to the declared minSdkVersion value of the App.
•The API is used by the App on that SDK version.
•TheAPIisnotincludedintheSDKofthatparticularversion.
It istrivial to check thefirst and last conditions,as implemented
inAndroidLint.Thechallengeliesinhowtodeterminewhether
an API is used or not on a given SDK version. We formulate this
challengeintoaclassicalinter-proceduraldata-flowanalysis,which
computes the set of reachable Android versions for each API usage
in a context-sensitive manner.
We compute the set of reachable SDK versions at each program
point for the App under evaluation. At the entry point, the set
includesallSDKversionsdeclaredinthemanifestfileoftheAPP,
e.g., from minSdkVersion to the largest level 27. This set is up-
datedatprogrampointscheckingSDKversions.Weconsiderthe
common practice where the variable SDK_INT is directly compared
toaconstantintegervalue(Finding7),andthecomparisonresult
is used as conditions of ifstatements. These ifstatements are
referred to as checkpoint statements. The set of reachable SDK ver-
sions in the true or false branch of the checkpoint statement areupdated accordingly. Equations 1-2give the data flow functions,
where
CHKED iis defined according to the condition of check-
pointstatements.Forexample,iftheconditionis SDK_INT≤24,
thenCHKED i={1,2,··· ,23}(assuming minSdkVersion is1)and
CHKED i={24,25,26,27}.
INi=/uniondisplay.1
p∈pred i(OUT p) (1)
OUT i=⎧⎪⎪ ⎨
⎪⎪⎩INi∩CHKED itrue branch of checkpoint statement
INi∩CHKED ifalse branch of checkpoint statement
INi otherwise.
(2)
For each usage of APIi, we check whether APIiis included in
anyreachableSDKversionattheusagepointornot.Ifnot,abug
is reported.
4.2 Implementation
APK
Issue 
ReportChecker
Path TracerReporterBuild ICFG
IFDS SolverSDK-4
paths
android-4.jar
SDK-5
android-5.jar
 android-27.jar
SDK-27……
……
<API, available versions>
ICFGICFG
<API use, reachable versions>
Figure 5: The Architecture of IctApiFinder.
WeimplementIctApiFinder( InCompaTibleAPIusageFinder)
in Soot. The tool detects incompatible API usages in Android Apps
by analyzing the .apk file of an App directly.
 5   …  …  
 6   if (Build.VERSION.SDK_INT >= 24)
 7        wrapper(mView, c, s, null, i);
 8    else
 9        mView.startDrag(c, s, null, i);
  11  private wrapper(View v, ClipData c, ...) {
  12      v.startDragAndDrop(c, s, o, i);
  13 }10...2324 ...27
24...27
CallFlow
ReturnFlowNormalFlow
CalltoReturnFlow
Figure6:IllustrationexampletodetectincompatibleAPIus-
ages in Listing 6.
Figure5depictsthearchitectureofourimplementation.Webuild
theinter-proceduralcontrolflowgraph(ICFG)forAndroidApps
using Soot’s SPARK[ 29] call graph construction algorithm [ 19].
The inter-procedural data flow solver is implemented on top of
Heros[22],acommonlyusedIFDSframework[ 40].Tocheckwhether
agivenAPIisincludedinaparticularSDKversionornot,weuse
Doop[42], a framework for points-to analysis of Java programs, to
extractAPIsfromSDK(android.jar)fileanduseadatalogengine,
LogicBlox[ 17,23] to load API information for each SDK version.
Previousworks[ 36][48]extractsuchinformationfromaSDKdocu-
ment called api-versions.xml, which is not as accurate [48].
Next, we give a brief description on how the IFDS framework
computes reachable SDK versions at each program point, and how
we detect incompatible API usages using an example.
4.2.1 IFDSFramework. IFDSisaclassicalcontext-sensitiveinter-
proceduraldataflowanalysisframework.Thisframeworkcanbe
used to find precise solutions to a general class of inter-procedural
data-flow-analysis problems, where the set of data flow facts Dis a
finite set and the data flow functions are distributive.
TheIFDSframeworkformulatesthedataflowanalysisproblem
intoageneralgraphreachabilityproblemonasupergraphextended
from ICFG. Nodes are elements in the finite domain of data-flowfacts, and edges encode the semantics of transferring functions.
Therearefourtypesofedges:normal-flowedgestopropagatedata-
flow facts within a procedural; and call-flow edges, return-flow
edges,andcall-to-return-flowedgestopropagatedata-flowfacts
inter-procedurally.AsshowninFigure 6,foreachprogrampoint
in the ICFG, there is a set of nodes in the extended supergraph,
where each node represents an SDK version number at a program
point. Edges connect nodes representing the same SDK version
numberatsuccessiveprogrampoints,topropagatethereachable
SDK version to the next program point. At a checkpoint statement
C(line6),anedgefromanodebefore Candafter Cexistsonlyifits
correspondingSDKversionnumbersatisfiesthecheckedcondition.
An SDK version is reachable at a program point if there exists a
pathfromtheentrytoitscorrespondingnodeoftheSDKversion
at that program point.
173
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:09 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Dongjie He, Lian Li, Lei Wang, Hengjie Zheng, Guangwei Li, and Jingling Xue
4.2.2 Detection Example. Figure6shows how we detect incom-
patible API usages in the example in Listing 6. At the program
point before line 6, the reachable SDK versions are {10 ,··· ,27},
as declared in the manifest file. Line 6 is a checkpoint statement.
According to Equation 2, the reachable SDK versions at line 7 and
line 9 are {24 ,··· ,27}and{10 ,··· ,23}, respectively. Line 7 in-
vokesthe wrappermethod.SothereachableSDKversionsatline
7,{24,··· ,27}, are propagated to line 12, along the call-flow edges.
At the checking stage, IctApiFinder does not report the false
positive in line 12 since the API used on line 12 exists in SDK
versions 24-27 according to the extracted information. However,
theAPIusedonline9doesnotexistinSDK10.Hence,IctApiFinder
reports an incompatible API usage bug on line 9.
5 EVALUATION
In this section, we evaluate IctApiFinder using the total 1,426 real-
world open source Android Apps from F-Droid (a popular open-
source App store). We do not test with the 4,936 Apps from An-
droZoo since it will be difficult to verify the results without source
code information. All experiments are conducted on an Intel(R)
Core(TM)i5-4590boxwith4CPUcoresand16GBmemory.Theun-
derlying OS is Ubuntu 16.04.4 LTS. Our evaluation aims to answer
the following two research questions:
•RQ4: precision of IctApiFinder : Can IctApiFinder pro-
vide more precise detection results for Apps developers?
•RQ5: usefulnessof IctApiFinder: CanIctApiFinderhelp
to detect unknown incompatible API usages in real-world
AndroidApps?CanitprovideusefulinformationforApps
developers to diagnose and fix incompatible API usage is-
sues?
5.1 RQ4: precision of IctApiFinder
1064
227
4828 21 192 16
020040060080010001200
0 1~5 6~10 11~20 21~30 31~40 41~50 51~389APKNUM
Figure 7: Distribution of Apps in F-Droid by incompatible
API usage counts
We apply IctApiFinder to all Apps (using the latest version)
available in F-Droid[ 8], i.e., the total 1,426 Apps in F-Droid. The
Apppl.hypeapp.endoscope_5 cannotbeprocessedbySoot[ 46].On
average, our tool processes an App in 6.08 seconds. The most time-
consumingAppis com.nextcloud.client_30000399 ,whichtakes3
mintues and 45 seconds to analyze. Figure 7shows the numberof incompatibleAPI usages reported byour tool inthe total 1,425
Appsweanalyzed.IctApiFinderfindsincompatibleAPIusagesin
361 (25.33%) of the total 1,425 Apps. Although the Apps developers
have made extensive efforts to address compatibility issues, many
Apps still suffer from incompatible API usages.
Werandomlyselect20outofthe361AppswithincompatibleAPI
usage issues for manual inspection. TABLE 5lists the 20 Apps we
choose.The‘ APP’and‘Version’columnsgivetheirnamesandver-
sions,respectively.Column4and5presentthenumberofincompat-
ible API usages reported by Android Lint and IctApiFinder, respec-
tively. IctApiFinder is sound in reporting incompatible API usages
becauseofanover-approximatestrategyusedbytheIFDSsolver.
Hence,itwillnevermissanyincompatibleAPIusagebugs.However,
Android Lint often suffers from false negatives because it will skip
processing sources with certain annotations (e.g. @SuppressLint ,
@TargetApi ). In this experiment, we remove these annotation tags
for a fair comparison. In addition, Lint does not process libraries
thusoftenmissesincompatibleAPIusagebugsinexternallibraries.
Tominimizetheeffectofsuchkindoffalsenegatives,weconserva-
tivelyaddallissuesreportedbyIctApiFinderinexternallibraries
into that of Lint.
BycomparingColumn #Lintand#IctApiFinder ,wefindthat
the issues reported by IctApiFinder are significantly less than that
of Lint. On average, IctApiFinder can effectively reduce the false
positive rate of Android Lint by 82.1%.
Answer to RQ4: In conclusion, IctApiFinder largely re-
duces the false positive rate of Android Lint by 82.1%. It
processes an App within 7 seconds on average.
5.2 RQ5: Usefulness of IctApiFinder
WehavemanuallycheckedallreportsgeneratedbyIctApiFinder
forthe20AppsinTABLE 5.Columns #T Pand#F Ppresentthe
results.IctApiFinderreports217issuesinthe20Apps,including71
falsepositives,withafalsepositiverateof32.72%.Mostofthefalsepositivesareduetoimprecisionintheinter-proceduralcontrol-flow
graph:ouralgorithmsoundlyassumesthatallcomponentsinan
APK are directly reachable from the entry without considering the
complicated conditions to trigger a component.
Aftermanualinspection,webelievethat13Appssufferfromreal
incompatible API usages and have reported them to their original
developers. At present, we have received confirmation from the
developers of the 4 Apps: com.vonglasow.michael.qz (the 6th App),
com.xargsgrep.portknocker (the 7th App), com.zegoggles.smssync
(the9thApp),and org.severalproject (the16thApp).Theseissues
are color-flagged in red in Table 5. The 3 issues we reported in the
Appcom.zegoggles.smssync (the 9th App) are actually false posi-
tivessinceitappliesacomplicatedstrategytoaddressincompatible
API usages, which is not considered in our current implementa-
tion. For the App it.feio.android.omninotes.foss (the 12th App),
although we did not receive any confirmation from its develop-
ers directly, the developers have added a ‘ Development ’ tag to our
reports in their issue tracking system, suggesting further action
needed. These issues are color-flagged in orange in TABLE 5. The
issueinjonas.tool.saveForOffline (the14thApp)iscolor-flagged
174
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:09 UTC from IEEE Xplore.  Restrictions apply. Understanding and Detecting Evolution-Induced Compatibility Issues in Android AppsASE ’18, September 3–7, 2018, Montpellier, France
Table 5: Effectiveness of IctApiFinder over 20 randomly-selected Apps
ID APP Version #Lint#IctApiFinder #TP#FP
1 com.github.premnirmal.tickerwidget 2.4.04 17 3 3 0
2 de.christinecoenen.code.zapp 1.10.0 21 1 0 1
3 ca.rmen.android.networkmonitor 1.30.0 46 13 12 1
4 com.easytarget.micopi 3.6.11 2 1 0 1
5 com.prhlt.aemus.Read4SpeechExperiments 1.1 1 1 0 16 com.vonglasow.michael.qz 1.1 32 7 7
0
7 com.xargsgrep.portknocker 1.0.11 44 17 13 4
8 com.ymber.eleven 1.0 15 9 9 09 com.zegoggles.smssync 1.5.11-beta7 5 3 0 3
10 de.devmil.muzei.bingimageofthedayartsource 1.4 37 37 37 0
11 de.kromke.andreas.unpopmusicplayerfree 1.41 29 14 0 1412 it.feio.android.omninotes.foss 5.4.3 37 28 24
4
13 jackpal.androidterm 1.0.70-rebuild 52 14 0 1414 jonas.tool.saveForOffline 3.1.6 3 1 1
0
15 net.opendasharchive.openarchive.release 0.0.17-alpha-1 12 8 0 816 org.servalproject 0.93 5 1 1
0
17 org.openintents.notepad 1.5.4 4 3 2 118 org.sensors2.osc 0.2.0 25 14 0 1419 org.smssecure.smssecure 0.16.8-unstable 93 5 2 320 org.softeg.slartus.forpdaplus 3.4.8.2 732 37 35 2
ingreenbecausewecansuccessfullytriggerthisbugandcrashthe
App.
In the following, we discuss some real incompatible API usages
detected by our tool.
5.2.1 jonas.tool.saveForOffline. This App[ 13] (the 14th App)
downloadswebpagesforoff-linereading.Its minSdkVersion value
is16.TheAppinvokestheAPI android.webkit.WebSettings.setMed-
iaPlaybackRequiresUserGesture ,whichisintroducedintoSDKaf-
ter version 17. We run this App on a GALAXY S3 (API level 16)
device rented from WeTest[ 16]. The App directly crashed while
browsingoff-linepagesandthrewa“ java.lang.NoSuchMethodError ”
exception.
5.2.2 com.xargsgrep.portknocker. This App[ 12] (the 7th App) is
abasicportknockerclientandits minSdkVersion valueis10.Ituses
theexternalcomponent com.ianhanniballake.localstorage.Local-
StorageProvider ,whichisinheritedfromtheAPI android.provider.
DocumentsProvider . However, this API is introduced since SDK ver-
sion 19. We reported the issues to the original developers and
they confirmed them in a 2 days. The issues are fixed in revision
7f37522[7]byincreasingtheApp’s minSdkVersion to19.Thiskind
of incompatible API usages are very common since third party-libraries are frequently used in Apps. It is also very difficult to
avoidbythedevelopers.NotethatAndroidLintdoesnotprocess
externallibraries. IctApiFindersuccessfullyfinds theseincompati-
ble API usage issues, demonstrating its effectiveness.
5.2.3 org.servalproject. ThisApp(the16thApp,alsocalled Batp-
hone)[14]providesfreeandsecurephone-to-phonevoicecalling,
SMSandfilesharingoverWi-Fi,withouttheneedforaSIMcardoracommercialmobiletelephonecarrier.ThisApp’s
minSdkVersion
valueis8whileitusestheAPI java.lang.String: void String(byte[],
int,int,java.nio.charset.Charset) whichisaddedintoSDKsince
level9.Thedevelopersthankedusandfixedthisissueinrevision
05e784a[6] byusing java.lang.String: void String(byte[],int,
int,java.lang.String) on SDK version 8.
TheaboveexamplesshowthatIctApiFindercandetectcritical
unknown incompatible API usage issues in real-world Android
Apps, including these issues deeply hidden in external libraries.Such issues are very common, but hard to be detected by the devel-
opers and Android Lint.
To help with bug diagnosis and verification, we also implement
apathtracerwhichprovidesupto10possiblereachablepathsto
thedevelopersforeachincompatibleAPIusage.Ourbugreports
present the API usage, the incompatible versions, as well as the
reachablepathswhichcouldhelpthedeveloperstoquicklydiagnose
and fix incompatible API usages.
Answer to RQ5: IctApiFinder is useful in detecting un-
knownincompatibleAPIusages.Wehavefoundnumerous
realincompatibleAPIusagesin13ofthe20Appsmanually
inspected,whereissuesreportedin5Appshavealready
been confirmed or directly triggered. It also demonstrates
itseffectivenessbyreportingincompatibleAPIusagesin
externallibraries,whicharecommonbutdifficulttofind
bydevelopersandAndroidLint.ThereportofIctApiFinder
includes detailed information such as reachable paths and
incompatibleversions,whichishelpfulfordevelopersto
quickly diagnose and fix the reported issues.
6 DISCUSSIONS
6.1 Threats To Validity
Subjectselection. Thevalidityofourempiricalstudyresultsmay
be subject to the threat that we only manually inspect 10 Android
Appsassubjectsinanalyzingevolution-inducedcompatibilityis-
suesfixingpatterns.However,these10Appsareselectedfrom1,425
candidateAppsfromF-Droidastheycontainthemostnumberof
fixingpracticestoaddressevolution-inducedcompatibilityissues,
with a total number of 1,249 usages of the variable SDK_INT. More
importantly, the findings obtained from studying these 10 Apps
have been proven to be useful in detecting unknown incompatible
API usages in real-world Apps.
Errors in manual inspection. Our study may suffer from er-
rorsinmanuallyanalyzingcodesnippetswhichusesvariable SDK_INT
toaddressevolution-inducedcompatibilityissues.Toreducethis
175
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:09 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Dongjie He, Lian Li, Lei Wang, Hengjie Zheng, Guangwei Li, and Jingling Xue
threat, we follow the widely-adopted cross-validating method to
ensure the correctness of our results.
Assumptions. In our empirical study, we make two assump-
tions. The first assumption is that usages of variable SDK_INTall
addressevolution-inducedcompatibilityissues.Inpractice,there
also exist other usages such as log-printing. Ho wever,these usages
onlyaccountforlessthan11.56%ofthetotalusagesinourstudy.
Another assumption is that a new API is supported by the Android
SupportLibraryifitisusedintheSupportLibrary.Thisisacon-
servative assumption since there are also normal usages of the API.
The API support ratio provided by the Android Support Library
will be even lower. Hence it does not affect our conclusion that the
support from the Android Support Library is insufficient.
Android OS Evolution. The last threat may come from the
strategy of Android evolution. All our empirical findings are based
oncurrentmajorandroidversions.However,Androidisafastevolv-
ing system and many OS versions will be gradually phased out.
There may be significant changes in the Android ecosystem to ad-
dress evolution-induced compatibility issues. We cannot guarantee
that our findings still hold in the remote future.
6.2 Further Reduce False Positives
In our empirical study, we have classified the usages of SDK_INT
intothreecategories.IctApiFinderonlyconsidersthemostcommon
practice( C1).Therearealsocomplicatedcaseswhichrequireprecise
pointer analysis [ 32,33,43,45] to track dependencies of variable
SDK_INT, or complicated fixing strategies as in List 5. We plan to
address these issues in our future work.
Most of the false positives are due to the imprecision of our
inter-proceduralcontrolflowgraph(ICFG).Currently,theICFGwe
use is actually same as the one in Flowdroid [ 20], which conserva-
tively assumes that all components in Android Apps are directly
reachablefromtheentrypoint,withoutconsideringthecomplex
control flows to trigger a component. However, this is not true.For example, some “
Activity” can only be reached after the call
to “startActivityForResult ”. Hence, a more precise ICFG which
is required to further reduce false positives. In general, it requires
controlflowspecialization[ 26,51]andreflectionanalysis[ 50]to
build the precise ICFG.
7 RELATED WORK
To the best of our knowledge, we are the first to quantify Android
evolution-inducedcompatibilityissueswithdatafromalargebodyofrealAndroidAppsandprovidetooltodetecttheseissues.Existing
work have studied the general Android API evolution problem and
fragment-induced compatibility issues.
Android API evolution. The maintenance of mobile applica-
tions remains to be largely undiscovered in the software mainte-
nance field[ 38]. API evolution is a frequently research topic in this
area.McDonnelletal.[ 36]haveperformedanempiricalstudyon
APIstabilityandadoptioninAndroid,inwhichtheyshowedthat
Android is rapidly evolving, at a rate of 115 averagely API updates
permonth.However,comparedtothefastevolvingAPIs,ittakes
much longer time on average to adopt new versions in Android
Apps. Linares et al. [ 35] have shown that Android API changes
willtriggermoreStackOverflowdiscussions.Work[ 34]and[21]investigated the relationship between the popularity of Android
Apps and the SDK API changes. Their empirical study pointed out
that morepopular AndroidApps generally tendto useAPIs thatare less change-prone. The above works are helpful in learning
evolution-inducedcompatibilityissues.Thispaperextendsexisting
worksbyshowingtherootcausesandquantifyingtheseverityof
evolution-induced compatibility issues in real Android Apps. Our
findings facilitate effective detection and diagnose of evolution-
induced compatibility issues in practice.
Android compatibility issues. Android fragmentation also
causes portability and compatibility issues within the entire An-droid ecosystem [
25,49,52]. A few recent works have been try-
ing to address these fragmentation-induced compatibility issues.
Ham et al.[ 24] proposed aDevice API Level Check Method.Their
methodrecordsthetestresultsofAndroidAPIforeachdevicein
a pre-stored database, which is then used to check API usage in-
formation and detect compatibility issues.Wei et al.[ 47] manually
extract API usage information (referred to as API-Context pair)from existing compatibility issues, and use such information to
detectfragmentation-inducedcompatibilityissues.Thelatestwork,CiD[
31],detectsevolution-inducedcompatibilityissuesbybuilding
a so-called conditional call graph, which is not context-sensitive.
This paper targets evolution-induced compatibility issues, and we
applyacontext-sensitivedata-flowanalysistoautomaticallydetect
incompatibility issues, without manual annotation.
8 CONCLUSION AND FUTURE WORK
This paper conducts an extensive empirical study on evolution-
inducedcompatibilityissuesinAndroidApps.Ourstudiesdiscoverthefollowinginterestingfindings:theAndroidSupportlibrarypro-
vides support for less than 23% of the new APIs in each release,
andmostApps(91.84%)needtoaddressevolution-inducedcompat-
ibilityissuesintheirimplementation.Themostcommonpractice
(88.65%)adoptsasimplecodepattern.Thesefindingsarehelpfor
future research on this topic.
Basedonourfindings,wedevelopIctApiFinder,whichdetects
incompatible API usage issues in Android Apps based on inter-
proceduraldata-flowanalysis.IctApiFinderdetectsincompatible
API usage issues on 361 Apps out of the 1,425 Apps we tested. It
issoundandcaneffectivelyreducethefalsepositivesofAndroid
Lint by 82.1%.
Inthefuture,weplantoautomaticallyverifythebugsIctApiFinder
detected. We also plan to give useful fixing suggestions to develop-
ers by mining equivalent APIs on different Android SDKs.
ACKNOWLEDGEMENT
ThisworkissupportedbytheInnovationResearchGroupofNa-
tionalNaturalScienceFoundationofChina(61521092and61672492),
the National Key research and development program of China
(2016YFB1000402and2017YFB0202002),theNationalNaturalSci-
enceFoundationofChina(U1736208),andAustraliaResearchCoun-
cil grants (DP170103956).
REFERENCES
[1]2018. Retrieved April 26, 2018 from https://www.statista.com/statistics/266210/
number-of-available-applications-in-the-google-play-store
176
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:09 UTC from IEEE Xplore.  Restrictions apply. Understanding and Detecting Evolution-Induced Compatibility Issues in Android AppsASE ’18, September 3–7, 2018, Montpellier, France
[2]2018. AmazeFileManager. RetrievedApril26,2018from https://f-droid.org/en/
packages/com.amaze.filemanager/
[3]2018. AndroidDevelopmenttools. RetrievedApril26,2018from http://www.
appbrain.com/stats/libraries/dev
[4]2018. Android:Platformcodenames,versions, andAPIlevels. RetrievedApril
26, 2018 from https://source.android.com/setup/start/build-numbers
[5]2018. AOSP: Android Open Source Project. Retrieved April 26, 2018 from
https://source.android.com/
[6]2018. Fix EIC issues for batphone. Retrieved April 26, 2018 from https://github.
com/servalproject/batphone/commits/development
[7]2018. Fix minSDKVersion for PortKnocker. Retrieved April 26, 2018 from
https://github.com/xargsgrep/PortKnocker/commit/master
[8]2018. Free and Open Source Android App Repository. Retrieved April 26, 2018
fromhttps://f-droid.org
[9] 2018. Gradle build tool. Retrieved April 26, 2018 from https://gradle.org
[10]2018. IDC: Smartphone OS Market Share. Retrieved April 26, 2018 from
https://www.idc.com/promo/smartphone-market-share/os
[11]2018. LintAPICheck. RetrievedApril26,2018from http://tools.android.com/
recent/lintapicheck
[12]2018. Port Knocker. Retrieved April 26, 2018 from https://f-droid.org/en/
packages/com.xargsgrep.portknocker/
[13]2018. Save For Offline. Retrieved April 26, 2018 from https://f-droid.org/en/
packages/jonas.tool.saveForOffline/
[14]2018.ServalMesh. RetrievedApril26,2018from https://f-droid.org/en/packages/
org.servalproject/
[15]2018. Understanding the Android Support Library. Retrieved April 26, 2018
fromhttp://martiancraft.com/blog/2015/06/android-support-library/#fn:3
[16]2018. WeTest: Professional and Reliable One-stop Testing Service. Retrieved
April 26, 2018 from http://wetest.qq.com/
[17]Serge Abiteboul, Richard Hull, and Victor Vianu. 1995. Foundations of databases:
the logical level. Addison-Wesley Longman Publishing Co., Inc.
[18]Kevin Allix, Tegawendé F Bissyandé, Jacques Klein, and Yves Le Traon. 2016.
Androzoo:Collectingmillionsofandroidappsfortheresearchcommunity.In
Proceedings of the 13th International Conference on MiningSoftwareRepositories .
ACM, 468–471.
[19]Steven Arzt. 2017. Static data flow analysis for android applications. Ph.D. Disser-
tation. Technische Universität.
[20]Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bodden, Alexandre Bar-
tel,JacquesKlein,YvesLeTraon,DamienOcteau,andPatrickMcDaniel.2014.
Flowdroid: Precise context, flow, field, object-sensitive and lifecycle-aware taint
analysis for android apps. Acm Sigplan Notices 49, 6 (2014), 259–269.
[21]Gabriele Bavota, Mario Linares-Vasquez, Carlos Eduardo Bernal-Cardenas, Mas-
similiano Di Penta, Rocco Oliveto, and Denys Poshyvanyk. 2015. The impact
of api change-and fault-proneness on the user ratings of android apps. IEEE
Transactions on Software Engineering 41, 4 (2015), 384–407.
[22]Eric Bodden. 2012. Inter-procedural data-flow analysis with ifds/ide and soot. In
Proceedings of the ACM SIGPLAN International Workshop on State of the Art in
Java Program analysis. ACM, 3–8.
[23]Todd JGreen,Molham Aref,and GrigorisKarvounarakis. 2012. Logicblox,plat-
form and language: A tutorial. In Datalog in Academia and industry. Springer,
1–8.
[24]Hyung Kil Ham and Young Bom Park. 2011. Mobile application compatibilitytest system design for android fragmentation. In International Conference on
Advanced Software Engineering and Its Applications. Springer, 314–320.
[25]Dan Han, Chenlei Zhang, Xiaochao Fan, Abram Hindle, Kenny Wong, and Eleni
Stroulia. 2012. Understanding android fragmentation with topic analysis of
vendor-specific bugs. In Reverse Engineering (WCRE), 2012 19th Working Confer-
ence on. IEEE, 83–92.
[26]Liu Jie, Wu Diyu, and Jingling Xue. 2018. TDroid: Exposing App Switching
Attacks in Androidwith Control Flow Specialization. In Proceedings of the33rd
International Conference on Automated Software Engineering.
[27]MonaErfaniJoorabchi,AliMesbah,andPhilippeKruchten.2013. Realchallenges
in mobile app development. In Empirical Software Engineering and Measurement,
2013 ACM/IEEE International Symposium on. IEEE, 15–24.
[28]Pavneet Singh Kochhar, Ferdian Thung, Nachiappan Nagappan, Thomas Zim-
mermann,andDavidLo.2015. Understandingthetestautomationcultureofapp
developers.In SoftwareTesting,VerificationandValidation(ICST),2015IEEE8th
International Conference on. IEEE, 1–10.
[29]Ondřej Lhoták and Laurie Hendren. 2003. Scaling Java Points-to Analysis Using
Spark.In InternationalConferenceonCompilerConstruction.Springer,153–169.
[30]LiLi,TegawendéFBissyandé,YvesLeTraon,andJacquesKlein.2016. Access-
inginaccessibleandroidapis:An empiricalstudy.In SoftwareMaintenanceand
Evolution (ICSME), 2016 IEEE International Conference on. IEEE, 411–422.
[31]Li Li, Tegawendé F Bissyandé, Haoyu Wang, and Jacques Klein. 2018. CiD:
automating the detection of API-related compatibility issues in Android apps.InProceedings of the 27th ACM SIGSOFT International Symposium on Software
Testing and Analysis. ACM, 153–163.
[32]Lian Li, Cristina Cifuentes, and Nathan Keynes. 2011. Boosting the Performance
of Flow-sensitive Points-to Analysis Using Value Flow. In Proceedings of the
19th ACM SIGSOFT Symposium and the 13th European Conference on Foundations
of Software Engineering (ESEC/FSE ’11). ACM, New York, NY, USA, 343–353.
https://doi.org/10.1145/2025113.2025160
[33]Lian Li, Cristina Cifuentes, and Nathan Keynes. 2013. Precise and Scalable
Context-sensitivePointerAnalysisviaValueFlowGraph.In Proceedingsofthe
2013InternationalSymposiumonMemoryManagement (ISMM’13).ACM,New
York, NY, USA, 85–96. https://doi.org/10.1145/2464157.2466483
[34]Mario Linares-Vásquez, Gabriele Bavota, Carlos Bernal-Cárdenas, Massimiliano
Di Penta, Rocco Oliveto, and Denys Poshyvanyk. 2013. API change and fault
proneness: a threat to the success of Android apps. In Proceedings of the 2013 9th
joint meeting on foundations of software engineering. ACM, 477–487.
[35]Mario Linares-Vásquez, Gabriele Bavota, Massimiliano Di Penta, Rocco Oliveto,
andDenysPoshyvanyk.2014. Howdoapichangestriggerstackoverflowdis-cussions? a study on the android sdk. In proceedings of the 22nd International
Conference on Program Comprehension. ACM, 83–94.
[36]TylerMcDonnell,BaishakhiRay,andMiryungKim.2013. Anempiricalstudy
of api stability andadoption in the android ecosystem. In Software Maintenance
(ICSM), 2013 29th IEEE International Conference on. IEEE, 70–79.
[37]I. J. Mojica, B. Adams, M. Nagappan, S. Dienst, T. Berger, and A. E. Hassan. 2014.
A Large-Scale Empirical Study on Software Reuse in Mobile Apps. IEEE Software
31, 2 (Mar 2014), 78–86. https://doi.org/10.1109/MS.2013.142
[38]MeiyappanNagappanandEmadShihab.2016. Futuretrendsinsoftwareengineer-
ingresearchformobileapps.In Softwareanalysis,evolution,andreengineering
(SANER), 2016 IEEE 23rd International Conference on, Vol. 5. IEEE, 21–32.
[39]Je-HoPark,YoungBomPark,andHyungKilHam.2013. Fragmentationproblem
in Android. In Information Science and Applications (ICISA), 2013 International
Conference on. IEEE, 1–2.
[40]ThomasReps,SusanHorwitz,andMoolySagiv.1995. Preciseinterprocedural
dataflowanalysisviagraphreachability.In Proceedingsofthe22ndACMSIGPLAN-
SIGACT symposium on Principles of programming languages. ACM, 49–61.
[41]I.J.M.Ruiz,M.Nagappan,B.Adams,andA.E.Hassan.2012. Understandingreuse
in the Android Market. In 2012 20th IEEE International Conference on Program
Comprehension (ICPC). 113–122. https://doi.org/10.1109/ICPC.2012.6240477
[42]Yannis Smaragdakis and Martin Bravenboer. 2011. Using Datalog for fast and
easy program analysis. In Datalog Reloaded. Springer, 245–251.
[43]Yulei Sui and Jingling Xue. 2016. On-demand Strong Update Analysis via Value-
flow Refinement. In Proceedings of the 2016 24th ACM SIGSOFT International
Symposium on Foundations of Software Engineering (FSE 2016). ACM, New York,
NY, USA, 460–473. https://doi.org/10.1145/2950290.2950296
[44]M. D. Syer, B. Adams, Y. Zou, and A. E. Hassan. 2011. Exploring the Develop-ment of Micro-apps: A Case Study on the BlackBerry and Android Platforms.
In2011 IEEE11th InternationalWorking Conferenceon Source CodeAnalysis and
Manipulation. 55–64. https://doi.org/10.1109/SCAM.2011.25
[45]TianTan,YueLi,andJinglingXue.2017. EfficientandPrecisePoints-toAnalysis:
Modeling the Heap by Merging Equivalent Automata. In Proceedings of the 38th
ACMSIGPLANConferenceonProgrammingLanguageDesignandImplementation
(PLDI2017).ACM,NewYork,NY,USA,278–291. https://doi.org/10.1145/3062341.
3062360
[46]RajaVallée-Rai,PhongCo, EtienneGagnon,Laurie Hendren,PatrickLam, and
Vijay Sundaresan. 2010. Soot: A Java bytecode optimization framework. In
CASCON First Decade High Impact Papers. IBM Corp., 214–224.
[47]L.Wei,Y.Liu,andS.C.Cheung.2016. TamingAndroidfragmentation:Character-izinganddetectingcompatibilityissuesforAndroidapps.In 201631stIEEE/ACM
International Conference on Automated Software Engineering (ASE). 226–237.
[48]DaoyuanWu,XimingLiu,JiayunXu,DavidLo,andDebinGao.2017. Measuring
the declared SDK versions and their consistency with API calls in Android apps.
InInternational Conference on Wireless Algorithms, Systems, and Applications.
Springer, 678–690.
[49]LeiWu,MichaelGrace,YajinZhou,ChiachihWu,andXuxianJiang.2013. The
impact of vendor customizations on android security. In Proceedings of the 2013
ACMSIGSACconferenceonComputer&communicationssecurity.ACM,623–634.
[50]Zhang Yifei, Li Yue, Tian Tan, and Jingling Xue. 2018. Ripple: Refection analysis
forAndroidAppsinincompleteinformationenvironments. Software:Practice
and Experience 8, 1419–1437.
[51]Zhang Yifei, Sui Yulei, and Jingling Xue. 2018. Launch-Mode-Aware Context-
Sensitive Activity Transition Analysis. In Proceedings of the International Confer-
ence on Software Engineering. 598–608.
[52]Xiaoyong Zhou, Yeonjoon Lee,Nan Zhang, Muhammad Naveed,and XiaoFeng
Wang. 2014. The peril of fragmentation: Security hazards in android device
driver customizations. In Security and Privacy (SP), 2014 IEEE Symposium on.
IEEE, 409–423.
177
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:09 UTC from IEEE Xplore.  Restrictions apply. 