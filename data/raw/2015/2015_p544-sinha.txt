Responsive Designs in a Snap
Nishant Sinha
IBM Research, India
nishant.sinha@in.ibm.comRezwana Karim
Rutgers University, USA
rkarim@cs.rutgers.edu
ABSTRACT
With the massive adoption of mobile devices with different form-
factors, UI designers face the challenge of designing responsive UIs
which are visually appealing across a wide range of devices. De-
signing responsive UIs requires a deep knowledge of HTML/CSS
as well as responsive patterns - juggling through various design
conﬁgurations and re-designing for multiple devices is laborious
and time-consuming. We present DECOR, a recommendation tool
for creating multi-device responsive UIs. Given an initial UI de-
sign, user-speciﬁed design constraints and a list of devices, DECOR
provides ranked, device-speciﬁc recommendations to the designer
for approval. Design space exploration involves a combinatorial
explosion: we formulate it as a design repair problem and devise sev-
eral design space pruning techniques to enable efﬁcient repair. An
evaluation over real-life designs shows that DECORis able to com-
pute the desired recommendations, involving a variety of responsive
design patterns, in less than a minute.
Categories and Subject Descriptors
D.2.2 [ Design Tools and Techniques ]: User Interfaces, CASE
General Terms
Algorithms, Design
Keywords
Responsive Layout inference, Constraint-based Design, HTML,
CSS
1. INTRODUCTION
The massive growth of mobile and tablet devices has compelled
both enterprises and individual developers to create UIs viewable on
multiple devices. The solution is to create responsive designs [ 31,
34], which adapt to device environments, e.g., different form-factors.
They provide optimal viewing experience across devices by allowing
users to read and navigate a page easily and minimizing the effort
spent on window resizing, panning, and scrolling. Indeed, 2013 was
named the year of responsive design1[16].
1The term responsive may have multiple informal meanings; here,
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are not
made or distributed for proﬁt or commercial advantage and that copies bear
this notice and the full citation on the ﬁrst page. Copyrights for components
of this work owned by others than ACM must be honored. Abstracting with
credit is permitted. To copy otherwise, or republish, to post on servers
or to redistribute to lists, requires prior speciﬁc permission and/or a fee.
Request permissions from Permissions@acm.org. ESEC/FSE’15, August
31-September 04, 2015, Bergamo, Italy c/circlecopyrt2015 ACM. ISBN 978-1-4503-
3675-8/15/08 $15.00 DOI: http://dx.doi.org/10.1145/2786805.2786808HTML and CSS are the de-facto web design languages; off-
the-shelf browsers can render such designs for mobile platforms.
HTML/CSS designing requires deep expertise, both for (i) encod-
ing layouts in CSS and (ii) various layout transformation patterns
that lead to responsive designs. Non-experts, instead, may prefer
either programming-by-demonstration ,constraint-based design or a
combination of these approaches. A design demonstration consists
of a set of UI elements or widgets laid out on a canvas, e.g., of
a WYSIWYG editor [ 1,11,2];nested layouts are speciﬁed using
container boxes . Design synthesis engines [ 27,33] are used to create
renderable HTML/CSS ﬁles from the speciﬁcation.
Alternatively, the designer may specify a partial UI layout on a
canvas and then add constraints on the alignment, positioning and
relative sizes of UI elements [ 18,35,26], e.g., min-width of a text
box, max-margin between two adjacent elements. Constraint-based
UI design has a rich history [ 21,19,18,27,24,35,26]: by enabling
the designer to focus on the desired design properties instead of
how to encode them, constraints reduce the layout speciﬁcation
burden. These constraints are ﬁnally used by a layout engine to
render a device-speciﬁc design. Desktop UIs have a dedicated
layout engine [ 10] which solves the constraints and renders design
on-the-ﬂy. In contrast, for web UIs, a browser’s layout engine
understands only HTML/CSS natively; hence, the page synthesis
engine should transform the design constraints into CSS rules.
Creating responsive layouts which adapt smoothly to different
devices is non-trivial. A naive approach to adapt UI designs to
devices is by creating so-called ﬂuid designs, where UI elements
shrink or expand in a ﬁxed ratio to their parent. However, such
re-sizing leads to cluttered appearance and overlapping elements
as devices become smaller. Instead, responsive layouts employ
multiple transformations on UI elements: rearrange, resize, replace,
change visibility, move elements across pages, etc. Further, to
enable efﬁcient encoding in HTML/CSS, the layouts cannot be
rearranged arbitrarily: horizontal/vertical alignment of elements
may change freely, e.g. rows transformed to columns, but the parent-
child relationships are generally preserved across layouts.
Visual tools like Adobe Reﬂow [ 2] assist users in adapting a
particular design to different form-factors using direct manipula-
tion. However, the designer must juggle through a large number
of possible designs manually, ﬁxing designs through a laborious
trial-and-error process. Further, the tool does not provide any layout
recommendations. Grid-based CSS libraries, e.g., Bootstrap [ 7],
allow designers to annotate UI elements with CSS classes having
pre-deﬁned responsive behaviors, e.g., a 2x2 grid will transform to
4x1 grid at the mobile form-factor. Manual annotation is laborious
and error-prone: it is easy to specify wrong annotations which are
hard to debug without a deep knowledge of the library and CSS
we refer to designs whose layouts adapt to different form-factors.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciﬁc permission and/or a
fee. Request permissions from Permissions@acm.org.
ESEC/FSE’15 , August 30 – September 4, 2015, Bergamo, Italy
c2015 ACM. 978-1-4503-3675-8/15/08...$15.00
http://dx.doi.org/10.1145/2786805.2786808
544Figure 1: (top) Real-world example of a responsive site. (below)
DECOR: A responsive design recommendation tool.
layouts.
Constraint-based design holds the promise of reducing the man-
ual design effort. However, existing constraint-based approaches
are ineffective for responsive design because they search over a re-
stricted design space. For example, most techniques try to preserve
the UI element alignments (from the original design) during adap-
tation and do not explore designs having grid-based rearrangments
during solution discovery. Consider the original design layout in
Fig. 2(top) which is adapted to the small tablet ( STP) form-factor
in Fig. 2(bottom-left). Current approaches can shrink the original
layout to the one shown in the STP (left) area, but cannot produce
the desired layout (STP (right)) which requires changing the align-
ment of multiple elements from horizontal to vertical. Because
of their reduced search space, these techniques are forced to de-
clare the constraint set inconsistent or drop inconsistent constraints
arbitrarily [10] to keep the layout aesthetic.
We present a constraint-based design recommender tool, DECOR,
to assist the designer in creating multi-device responsive UIs (Fig. 1(b)).
Given an initial UI design, user-speciﬁed constraints on elements,
e.g., width or margin, and a list of device form-factors, DECOR
provides ranked, device-speciﬁc recommendations to the designer
for approval. Intuitively, DECORis to responsive design, as content-
assist tools are to programming: the latter improve developer pro-
ductivity by providing features like auto-completion and ranked
suggestions, while DECORprovides design recommendations to
enable rapid multi-device design. The designer may specify con-
straints for each form-factor and let the tool provide suggestions for
each form-factor. If the designer does not approve of any suggestion,
she may reﬁne the constraints and query the tool again. To our
knowledge, DECORis the ﬁrst tool to provide multiple responsive
design recommendations.
The design of DECORrelies on two main observations. First, we
observe that UI designs are essentially labeled trees, and responsive
designs may be obtained by one or more tree transformations . Con-
sider a designDwith the design tree T, containing an UI element
nodenwith children c1andc2laid out horizontally on being ren-
dered (nis aHBox ). Supposec1andc2appear too narrow on the
tablet device. We can ﬁx Dby transforming the orientation of nto
VBox wherec1andc2align vertically and hence appear sufﬁcientlywide. We formalize responsive design as a design repair problem:
given a UI design, and a set of design constraintsC, compute the set
ofﬁxes, so that the ﬁxed design satisﬁes Cfor each desired device.
The notion of a ﬁxis at the core of our approach: a ﬁx effectively
characterizes the designer’s actions as she goes about adapting the
design for different devices.
Our second observation is that although the total number of po-
tential tree transformations (space of designs) is huge, only a few
transformation patterns are used in practice. However, trying out all
permutations of even this smaller set of transformations on real UI
design trees leads to a combinatorial explosion. To build a practical
tool, we devise several pruning heuristics which exploit the indepen-
dence of ﬁxes, similar to partial order reduction methods [ 25,23],
and bias the search towards more general and ordered ﬁx sequences
to prune the search space (cf. Sec. 5).
We evaluate DECORover a representative set of synthetic and
real-life UI designs. Our results show that DECORis able to com-
pute several design recommendations, involving a variety of respon-
sive design patterns, in less than a minute. The recommendations
obtained are realistic, i.e., they precisely mimic the responsive behav-
iors created manually by experienced designers of real-life respon-
sive sites. In some cases, DECORis also able to suggest alternative
design repairs which require fewer ﬁxes as compared to the original
responsive site. The paper makes the following contributions.
•We formalize the responsive design problem as a constraint-
based repair problem over labeled design trees. We present
a new speciﬁcation language to specify constraints over UI
elements for multi-device designs.
•We model the space of design transformations using a design
tree graph (DTG), whose nodes are design trees and transi-
tions are repairs. An algorithm is presented to search over a
DTG systematically to ﬁnd designs satisfying constraints.
•We present efﬁcient pruning heuristics to avoid combinatorial
explosion during DTG exploration by avoiding redundant
ﬁxes, exploiting mutual independence of ﬁxes and enforcing
a tree-based ordering on ﬁx sequences.
•We describe an implementation and an evaluation of DECOR,
a tool for creating multi-device responsive designs. We demon-
strate that DECORis able to provide realistic recommenda-
tions for real-life designs within a minute. We conduct a
study to compare the user experience with DECORagainst a
commercial responsive design tool.
2. OVERVIEW OF THE APPROACH
Consider the UI design Dshown in Fig. 2(top-left), based on a
real-life responsive website [ 6]. Suppose designer uses a WYSI-
WYG design tool [ 2] or a mockup builder [ 3,9] to create this
design for the desktop form-factor (width >1200px). Now, she
wishes to adaptDto be visually appealing for the following devices
(form-factors): (i) tablet landscape ( width < 1024px) (ii) small
tablet portrait ( width< 600px) and (iii) mobile-portrait ( width<
320px). Instead of manually tweaking Dfor each form factor, the
designer uses DECORto obtain desired designs. First, she provides
a set of design constraints on attributes of UI elements, e.g., min-
width, min-margin, font-size or their combinations (cf. Sec. 4.1).
DECORthen generates ranked design recommendations for each
desired form-factor, that satisfy the above constraints. Now, the
designer picks one of the designs if she approves of it; otherwise,
she adds more constraints and asks DECORto come up with bet-
ter recommendations. Once the designer approves all the designs,
545Figure 2: An illustrative responsive design example, for tablet, small tablet portrait (STP) and mobile portrait (MOP) form factors.
Dotted borders mark visually unappealing UI elements, solid borders show the ﬁxed versions.
DECORgenerates faithful HTML/CSS ﬁles encoding the designs,
which may be viewed in any off-the-shelf mobile/desktop browser
and responds to form factor changes.
To adapt the original design D, the tool ﬁrst extracts a hierarchical,
annotated, design tree (DT) TfromD(cf. Sec. 3 for details), shown
in Fig. 2(top-right), and then repairsTto satisfy all constraints for
each form-factor (FF) f. RepairingTfor eachfinvolves computing
one or more sequence of ﬁxes, called ﬁx-chains . Each ﬁx-chain
transformsTto a visually appealing tree T/primeforf. These ﬁx-chains
are then ranked and the designs encoding the repaired trees are
shown as recommendations.
We describe how DECORworks for the tablet-landscape ( tl) FF.
DECORstarts with most obvious repair: it shrinks the original
design (preserving relative sizes of elements) to the width of tlFF.
This design is not visually pleasant, e.g., the following elements
appear too narrow : email input and subscribe button under the
newsbar, the navbar 1, sidebar and the four ip i(1≤i≤4) elements
(Fig. 2, Tablet). To eliminate these issues, the designer speciﬁes
constraints: (a) min-width(navbar 1) = 200px , which applies tonavbar 1in all FFs. Further, she determines that the sidebar should
now be invisible and speciﬁes constraint (b) hidden(sidebar) for
all FFs less than tl. Similarly, (c) min-width constraints for input ,
button andipielements are speciﬁed.
Now, DECORuses these constraints to ﬁx the design: it applies
ﬁxes from its ﬁx library (cf. Sec. 4.2) to repair the design. Here,
the computed ﬁx-chain has 3 ﬁxes. First, the ﬁx hide-element is
applied on the sidebar. Then, the ﬁx reduce column (red-col) is
applied on the body element: body has two columns ( div1anddiv2
boxes) in the original design, this ﬁx converts body into a single
column, i.e., it stacksdiv1overdiv2. The resulting design is shown
in Fig. 2, Tablet (middle): elements fs-image andnavbar 1appear too
wide again, making the design unpleasant. The designer speciﬁes
amax-width fornavbar 1; the tool then applies the ﬁx red-row to
obtain the desired design (Fig. 2, Tablet (right)). Note how the min-
width constraints for input andbutton elements (inside newsbar ) are
satisﬁed, without applying ﬁx directly on them; ﬁxing the higher
(closer to root) tree nodes often obviates the need for ﬁxing speciﬁc
lower nodes and leads to short ﬁxes.
546For small tablet portrait (stp) FF, DECORagain shrinks the pre-
vious design to stp’s width (Fig. 2(STP)). Now, the unpleasant
elements are: navbar 2, email, subscribe and ip i. Suppose the de-
signer decides to hide navbar 2for stp and adds constraints for above
elements. Now, DECORtries to satisfy all given constraints for
stp: it applies red-col on newsbar (move input and button to a new
row) and red-col on content, i.e., convert from 4-column, 1-row
box to 2-column, 2-row box, to obtain the desired design for stp
(STP(right)). On shrinking this design to mobile portrait (mop) FF
(Fig. 2(MOP)), navbar 1and ip iappear squished. DECORapplies
red-col on both topbar (navbar 1gets a new row) and content (switch
to 1-column, 4-rows) to repair this design.
Discussion. Note that a designer may not conceive of all constraints
upfront; she may need to add constraints interactively and re-run the
tool multiple times. Constraints and ﬁxes are notrelated one-to-one:
a single constraint may determine ﬁxes for multiple FFs , which
saves the designer from re-applying the multiple ﬁxes manually.
To ﬁx designs manually without constraints, the designer must be
able to visualize the design hierarchy and various ﬁx interactions
mentally and adapt the design by trial-and-error, which becomes
unduly hard with complex designs and longer ﬁx-chains.
3. PRELIMINARIES
Designing UIs. Static UI design involves deﬁning the UI elements ,
thelayout , e.g., left-to-right alignment of elements, and the styling ,
e.g., color, font-size of elements. Either direct manipulation tools,
e.g., Adobe Photoshop, or UI programming frameworks [ 8,5] or
a combination of them [ 1,10] may be used. For creating web UIs,
HTML [ 8] and CSS [ 4,5] are the de-facto languages (JavaScript
is used for the dynamic behavior). Web UI programming involves
a signiﬁcant learning curve: most direct manipulation tools do not
generate good-quality code and end-users or unskilled designers
struggle to encode their designs in HTML/CSS [28, 33].
Devices and Form-Factors. Recently, a variety of mobile devices
have become available. These devices are distinguished by their
display form-factors , i.e., width-height ratio (in pixels), denoted
aswidth xheight ) Devices may be categorized into following major
categories: desktop, tablet, phone having widths 1200px or more,
500px - 800px and 320px - 480px, respectively. Further, phones and
tablets typically support both portrait andlandscape modes.
Breakpoints, Viewports. Abreakpoint is, intuitively, a transition
point for the design and is speciﬁed by its width, e.g., 700px; transi-
tion points affect noticeable discrete visual changes in the design (cf.
Fig. 1(a)). A designer picks breakpoints in order to ensure visual
appeal on a small subset of devices: each breakpoint bpcorresponds
to one or more devices having width close to bp. In this paper, we
use the term device orform-factor to specify device properties, view-
port to denote the design container or renderer, e.g., the browser,
andbreakpoint to specify the viewport width at which the design
changes. Viewport may correspond either to the entire device screen
or the reduced width of a resized browser.
Responsive designs. A declarative speciﬁcation in HTML/CSS,
may be rendered on different devices or viewports in completely
different ways. Although the underlying structure (HTML) remains
same, the layout, positioning, styling and visibility of elements may
be changed via CSS3 rules speciﬁc to devices or viewports. These
rules can be speciﬁed using media-query directives [ 12]: based on a
combination of device and viewport properties, different CSS rules
may be triggered. For the example in Fig. 2, we write
media (min-width: 1200px) { #sidebar {display: block;} }
media (min-width: 1024px) and (max-width: 1200px) {
#sidebar {display: none;}
}to make sidebar element visible for viewports of width >1200 px
and hide it for lower width viewports. Media queries can be complex
Boolean combinations of various device properties [ 12] and allow
designs to adapt to devices in non-trivial ways.
UI Designs Formally. A designDconsists of a collection of UI
elementsB(basic widgets, containers), represented as rectangular
objects (also called boxes ). Non-rectangular UI objects, e.g., images,
are represented by their bounding boxes.
Design tree (DT). We represent a design formally using a design
treeT= (N,ch,orn,σ )which consists of a set of nodes N, and
mapsch,ornandσ. We useroot(T)andleaves (T)to represent
the root node and the set of leaves of T, respectively. Given a node
n∈N,ch(n)denotes the ordered list of children of ninT. The
leaves ofTcorrespond to basic UI widgets, e.g., button, selection,
image, section, and intermediate nodes are containers. Functions
orn andσcapture the design features of T:orn(n)denotes the
layout of children of nandσ(n)denotes the styling, positioning
and other attributes of n, as explained below.
Styling. Each noden∈Nis labeled with a set of attributes which
determine the size, position and visual appearance of non being
rendered. Given a set of attributes Adrawing values from set VA,
the attribute map σ:N→ A → VA, which maps a node n
and an attribute a∈A to a valuev∈VA. Attribute values may
be speciﬁed either using absolute measures, e.g., in pixels (px) or
relative to parent of n, using percentages. Percentage values allow
the design to be ﬂuid. For example, suppose a child node nhas
width 40% of its parent, the root element r. Now, if we reduce
the (rendered) width of r,n’s width will also shrink in the same
ratio. Although responsive designs are ﬂuid in general, ﬂuidity is
not enough: elements typically are rearranged to adapt to devices.
Hierarchical Layouts: Grids, HVBoxes. A DT is rendered as a
nested collection of boxes; different layouts are obtained by aligning
children boxes vertically orhorizontally inside the parent (container)
box. We specify the orientation of each non-leaf node pusing a
generic grid box primitive;orn(p) = (k,l)means that the children
ofpare aligned into a grid with krows andlcolumns, and pis
said to be a (k,l)-box. When k= 1 (l= 1) we say that pis a
HBox (VBox ), i.e., contains a single row (column) of elements. As
we will see later, the grid box notation allows us to capture layout
transformations conveniently.
Rendering Design Trees. A DTTmay be visualized using a suit-
able renderer, e.g., an off-the-shelf browser. The renderer interprets
Tand projects it on to a 2-D plane, as a ﬂatdesignD= (B,σr),
whereBis a set of visible UI boxes corresponding to nodes in Tand
the attribute map σris deﬁned for each b∈B. For a boxbn∈B
corresponding to n∈N,σr(bn) =σ(n)andσr(bn)(p)is deﬁned
in absolute pixel values for all position and size attributes p, e.g.,
left, top, height, width. Given a device of form-factor f= WxH, we
say that a tree Tﬁtsthe device if the rendered box brootforroot(T)
is narrower than W, i.e.,σr(broot,width )<W .
4. CONSTRAINT-BASED DESIGN REPAIR
Given an initial DT Tdrawn for a breakpoint bp(e.g., 1200x768),
we want to transform Tinto a new tree T/primewhich is visually ap-
pealing for a lower-width breakpoint, e.g., 800x600. Once T/primeis
obtained, we can encode TandT/primetogether into HTML/CSS auto-
matically using media queries and rules presented in [ 33]. We can
obtainT/primebyshrinking the width of all elements by a ﬁxed ratio;
however, this may lead to visually unpleasant designs, e.g., text may
be unreadable, page elements may overlap or appear cluttered.
To create a repair strategy, we ﬁrst must deﬁne what a good-
looking design is. While it is hard, if not impossible, to quantify
visual appeal precisely, we can often characterize design deﬁciencies
547Constants k∈{N,true, false, strings, numbers, .. }
Tree nodes n
Node attributes a∈A: {width, height, margin, min-width, font-size, .. }
Operators⊕: {=,<,>,≤,≥, ..}
Breakpoints bp∈B: {1024x768, 320x480, tab, stp, mop, all,...}
ConstraintsC ::= [ bpl]φ
bpl ::=bp(,bp)∗
φ ::= (L|N)|φ∨φ|φ∧φ
L ::= Cx⊕k
Cx ::=n.a|/summationtext(k∗Cx)k∈N
N ::= hidden (n)|halign (n1,n2)|valign (n1,n2)
Table 1: Constraint language for multi-device designs. L= lin-
ear predicate, Cx= constraint expression. Expressions should
be type-correct. bp=alldenotes the set of all breakpoints.
in terms of constraints on size, spacing and other attributes, e.g.,
a design is not looking good because an image is too wide, or
a paragraph text is too narrow. Therefore, we ask the designer to
supply a set of design constraints on UI elements: a design satisfying
these constraints is assumed to be visually appealing.
Given a set of constraints C, we can repair Tin large number
of ways to satisfyC, e.g., we may ﬁx the size attributes of nodes
or change their orientation or move around subtrees in T. Our key
observation is that designers rely only on a small subset (about
10) of these ﬁxes for creating responsive designs, e.g., converting
rows to columns or vice versa, changing margin sizes, fonts and
hiding optional controls. These patterns are applied carefully only
to a selected set of tree nodes, and are in many cases independent
of each other. These observations allow to devise a systematic
approach to search over the set of possible ﬁxes efﬁciently. Our
constraint-based repair framework is extensible : both constraints
and ﬁxes can be added, enabled and removed on demand.
4.1 Design Constraints
Formally, design constraints are logical predicates on proper-
ties of tree nodes, e.g., attributes (width, margin), orientation and
the parent-child relationships, e.g. for a paragraph UI element
p,p.width≤600pxis an instance of a max-width constraint.
Constraints may refer to multiple elements simultaneously, e.g.,
n1.width +n2.width≤200px, for nodesn1andn2.
Table 1 shows our constraint language formally. The language
is inspired by, and generalizes, the constrained CSS language [ 19],
which allows specifying linear constraint rules in addition to CSS
rules. To design for multiple-devices, each constraint may be speci-
ﬁed for one or more breakpoints bpl. For example, ( [all]n1.width>
300px) constrains the min-width of n1to be 300px for all break-
points. Named predicates (N) allow specifying additional con-
straints: hidden (n)constraintsnto be invisible, halign (n1,n2)
(valign) constrains sibling nodes n1andn2to be horizontally (verti-
cally) aligned.
Trees satisfying constraints. A DTTis said to satisfy a constraint
φ(denotedT|=φ) iffφevaluates totrue given the node attribute
values inT. Given constraints C, we say that TsatisﬁesCfor a
breakpointbp(T|=bpC), iffT|=φfor each constraint of form
([..,bp,.. ]φ)∈C. Our goal is to ﬁnd alltreesT|=bpCfor each
breakpointbpand allow the designer to select the desired one.
4.2 Design Fixes
Aﬁxis the basic unit of design tree transformation. Given a DT
T= (N,ch,orn,σ ), a ﬁx may modify either (i) the set of nodes
N(insert or delete nodes), or (ii) the ordering of children ch, or (iii)
the orientation orn, or (iv) one or more attributes (height, width,Fix Name Description Fix Description
red-margin Reduce Margin res-child Modify Children Width Ratio
red-row Reduce Rows red-col Reduce Columns
reorder-child Reorder Children nav-to-select Replace list byselect
add/del-node Delete/Add Node mod-line Change line-height
mod-img Change Image Size mod-txt Change Text Properties
Table 2: List of common ﬁxes.
margin, font-size, ...) of a node n∈N. Multiple ﬁxes may be
required to repair a T, i.e., satisfy constraints C.
Table 2 shows common ﬁxes used in responsive designs [ 15,31].
For example, applying red-row ﬁx at noden,orn(n) = (2,2)
(2x2 grid box, cf. Sec. ??) reduces the number of rows of n,
e.g.,orn/prime(n) = (1,4)(1x4 grid box) whereas red-col reduces
the columns (increases rows) of ne.g.,orn/prime(n) = (4,1)(4x1 grid
box). Each ﬁx targets one or more types of constraint violation
distinctly, e.g., red-margin (reduce margin values) targets the con-
straints over min-width or max-margin of elements. DT nodes are
not explicitly added/removed: their visible attribute is toggled.
DECORtakes a ﬁx libraryFas input and uses ﬁxes from Fto
repairT. Acombination of these ﬁxes gives rise to popular respon-
sive patterns [ 15,31]. For example, the columnﬂip andmondrian
patterns [ 31,15] can be captured by red-col andred-row ﬁxes. Sim-
ilarly, basic gallery ,column drop orcolumn ﬂip patterns [ 15,31],
are different instances of the red-col ﬁx depending on the number
of elements in the grid.
Formally, a ﬁx is a rewrite rule at a node nofT:
(n,[c1,···,cm],ch,orn,σ )⇒(n,[c1,···,cm],ch/prime,orn/prime,σ/prime)
where [c1,···,cm])are the child nodes of ninTand functions
ch,ornandσ(ch/prime,orn/prime,σ/prime) denote the children, orientation and
attributes, resp., for Tbefore (after) transformation.
We describe the ﬁxes red-margin andred-col informally here.
Detailed rules for ﬁxes in Table 2 are omitted to the full version of
the paper [ 14]. Recall that nis rendered into 3 nested boxes: margin,
border and content boxes. The red-margin ﬁx onnincreasesn’s
content box width and decreases left/right margins of n, without
changing the margin box width of n. It ﬁrst computes the margin
valueγthat can be deducted from n’s current margin value without
violating the min-margin constraints on ninC(if they exist). Both
left and right margins are then reduced by γ; in turn, the width of
content-box of nis increased by the total reduced margins. This
expands the contents of n(and its children) which now may satisfy
a min-width constraint. Note how a single ﬁx may satisfy/falsify
multiple constraints (min-margin, min-width).
Thered-col ﬁx applies to most designs. Suppose nis a(k,l)-box
withmchildrenc1,...,c m;red-col reduces the number of columns
lofn(increasesk, in turn). Fig. 3 shows two red-col ﬁxes applied in
sequence ( (k,l) = (1,4)→(2,2)→(4,1)) on a design extracted
from Fig. 2. The ﬁx transforms ninto a (k/prime,l/prime)-box, where the
columnsl/primeis the largest factor ofmless thanl. The new width
and margin values for children ciare as follows: ( margins: ) the
top (bottom) margin for each ciis set to the maximum of a pre-
deﬁned global-min-margin value and their left (right) margin values
in previous (k,l)-box. For the new rows added to box of n, we
compute an average horizontal (left/right) margin value from the
previous left and right margin values of each child. In case the new
margin value is lower than min-margin constraintγiforcithen we
set it toγi. (widths: ) For updating width of each ci,red-col uses
a simple heuristic: the margin-box width for each ciis obtained
by dividing the width of namong each child ciin a row of (k/prime,l/prime)
using their relative width ratio. This relative width ratio is computed
fromci’s width in (k,l). Finally, the width of content box ofciis
obtained by deducting already computed left/right margin values for
548img 1 img 2 img 3 img 4
p1 p2 p3 p4V1 V2 V3 V4H1
img 1 img 2
p1 p2V1 V2H1
img 3 img 4
p3 p4V3 V4img 1
p1V1H1
img 2
p2V2Figure 3: Illustration of the 4-2-1 responsive pattern.
eachcifrom corresponding margin-box width. Other heuristics for
margin and width computation are also possible; after ﬁx is applied,
the designer can further ﬁne-tune these values.
We have designed most ﬁxes to be local , i.e., a ﬁx on nkeeps its
margin box ﬁxed and hence does not affect its non-subtree nodes
in the tree. In general, ﬁxes and constraints interact in complex
ways; applying a ﬁx may lead to satisfaction of some constraints
and violation of others. In other words, ﬁxes may enable ordisable
other ﬁxes. Therefore, different permutations of ﬁxes may lead to
different designs. To ensure we obtain multiple satisfying DTs, we
need to explore several permutations of multiple ﬁxes. Because
the number of such ﬁx sequences is huge, we introduce design tree
graphs to explore representative ﬁx sequences systematically.
5. DESIGN TREE GRAPHS
ADesign Tree Graph (DTG)G=(Q,ι,Σ,R,Ψ,T)over a
ﬁx libraryFand constraintsC, consists of a set of states Q, set
of initial states ι, a set of transition labels Σ, transition relation
R⊆Q×Σ×Qand a mapping function T(·), whereT(q)is
the DTTcorresponding to state q. The set Ψ⊆Qconsists of
good statesqwith satisfying trees, i.e., T(q)|=C. Each transition
labelg∈Σis a pairg=(n,f)wherenis a node in a DT and
f∈F. Given a state q, DTT=T(q)and labelg= (n,f)where
n∈T(q)andf∈F, transition (q,g,q/prime)∈Riff applying fto
nodeninTresults inT/primeandT(q/prime) =T/prime. The outgoing edges of a
stateqinGrepresent the set of valid ﬁxes (described below) which
may be applied toT(q). We construct a DTG separately for each
breakpoint; each initial state corresponds to a Tto be repaired.
Finding responsive designs boils down to exploring paths of G
to ﬁnd a good state. Alg. 1 shows the algorithm for constructing a
DTG and ﬁnding all good ﬁx-chains, which lead to good states. For
a breakpoint bp, the algorithm starts with a satisfying tree T0from
the previous breakpoint, shrunk tobp’s width. GETVALID FIXES
computes the set of valid node-ﬁx pairs Σ/prime⊂Σat a stateqover
libraryF(cf. Sec. 6). Each node-ﬁx pair in Σ/primeis applied iteratively
(using procedure APPLY FIX) to obtain new tree T/primeand stateq/prime. A
DTGGmay contain cycles: the algorithm uses a state matching
criterion to detect cycles and avoid loopy ﬁx-chains.
Example. Recall the designDfor the 4-2-1 pattern shown in Fig. 3.
We now describe how EXPLORE DTG algorithm constructs the DTG
forDforstpbreakpoint, shown in Fig. 4. The algorithm starts with
the initial state containing the DT T0forD(H1is a(1,4)-box).
Suppose after shrinking to stp, the width of imgiinT0violatesC.
Fixingimgidirectly may not be useful; instead we may need to ﬁx
one of its ancestors. Let us deﬁne the bad nodes in a DT to be all
nodes whose some descendant violates C. Here, bad nodes in T0are
{imgi,Vi,H1}.Input: Breakpointbp, Initial Design Tree T0, ConstraintsC, Fix LibraryF
Output: SetΛof satisfying ﬁx-chains λ
T:={(q0,T0)};R:= Ψ :=∅;Q:={q0};G:=(Q,q 0,Σ,R,Ψ,T);
Λ :=∅;
EXPLORE DTG (q0,/epsilon1)
EXPLORE DTG (q,λ)//λis current ﬁx chain
T:=T(q)
ifT|=bpC)thenΛ∪={λ};Ψ∪={q}return
Σ/prime:= G ETVALID FIXES(T,F)//Σ/primeis an ordered list of pairs (n,f)
ifΣ/primeis empty then return //Backtrack
foreachg∈Σ/primedo
T/prime:= A PPLY FIX(g,T)
Create freshq/primewhereT(q/prime) =T/prime
λ/prime= (λ→g);Q∪={q/prime};R∪={(q,g,q/prime)}
EXPLORE DTG (q/prime,λ/prime)
Algorithm 1: Computing all satisfying ﬁx-chains.
(H1,red-margin)(V1,red-margin)
(V1,
red-row) red-col)(V1,(V2,
red-row)red-col)(V2,(H1,
red-col)
(H1,
red-col)(V2,red-margin) q1
q2
q3q4
q5q6
q7
q/prime
3
Figure 4: A snippet of the DTG for ﬁxing the original design
(4-columns) for 4-2-1 pattern, shown in Fig. 3.
Suppose EXPLORE DTG picks a bad node V1to ﬁx and applies
red-margin toV1(stateq4); stillimgiis too narrow. The algorithm
continues to apply ﬁxes red-row (which makes V1single row and
shrinksimgifurther), followed by red-col toV1. At this point,
it detects a cycle and backtracks without success. Suppose after
trying to ﬁxV2,V3andV4similarly, the algorithm backtracks to q1
without success. Now EXPLORE DTG picks nodeH1and applies
ﬁxred-margin toH1to reach another bad state q2. The red-col ﬁx
is applied to H1, converting it to a (2,2)-box at state q/prime
3(treeT/prime
3).
Because the image widths now satisfy C, we obtain a good ﬁx-chain
(H1,red-margin )→(H1,red-col ) for stp. The algorithm will also
ﬁnd a shorter chain ( H1,red-col ) for stpleading to tree T3atq3.
After ﬁnishing with stp,EXPLORE DTG computes ﬁx-chains for the
next breakpoint mop, starting from either T3orT/prime
3. A satisfying
DT for mop breakpoint is obtained by applying red-col toH1again,
resulting in all Vi’s being aligned vertically.
EXPLORE DTG is inefﬁcient in multiple ways. (1) The algorithm
tries to ﬁxVi’s unnecessarily. Although we cannot rule out ﬁxing
Vi’s statically ( red-margin may be a valid ﬁx), we can avoid red-row
forVibecause applying red-row will not satisfy the min-width con-
straint. Similarly, we can avoid the large number of ﬁx permutations
onVi’s because they are tree siblings and can be ﬁxed independent
of each other. (2) The algorithm may try to both ﬁx Vifollowed by
H1and vice versa. In most cases, ﬁxing nodes in the tree order ( H1
followed byVi) is sufﬁcient. We now present a set of optimizations
to explore DTGs more efﬁciently.
6. EFFICIENT EXPLORATION OF DTGS
Given a tree TwithNnodes and ﬁx library F, the number of
ﬁx-chains in the corresponding DTG is O(N!·pN)wherep=
(|F|+1). We present path-pruning heuristics to explore a small
549Input: Design TreeT, Fix Library F,
ConstraintsC
Output: Fix List Σ/prime
GETVALID FIXES (T,F)
B:= nodes from TviolatingC;G=[]
SortBin decreasing tree height order
foreachn∈Bdo
F/prime:= G ETVALID NODEFIXES(n,F)
Σ/prime= Σ/prime·[(n,f),f∈F/prime]
return Σ/primeFix Node Properties
red-col VBox
red-row HBox or Root
red-margin No/Min. margin
nav-to-select Non-navbar
red-font No descendant
with text
(a) (b)
Figure 5: (a) The algorithm GETVALID FIXES (b) A list of in-
valid ﬁxes and their target node properties.
q1
q2q3B1
B2 B3
B1
B2
B3B1
B2 B3Fixf1 Fixf2
Fixf2(red-margin )(red-col )
Fixf1
Figure 6: A DTS fragment illustrating dependent ﬁxes.
representative set of ﬁx-chains in DTG based on (i) pruning the
ﬁxes applied to each node, and (ii) selecting the order of nodes to ﬁx.
The latter may omit some satisfying DTs from exploration; however,
in our evaluation, no desired DTs were eliminated.
Valid and Enabled Fixes. Given a DTG state qwith treeT, the set
ofvalid ﬁxes atqconsists of ﬁxes which may be applied to some
node inTbecause their pre-condition is satisﬁed. In general, many
ﬁxes are invalid , e.g., we cannot apply red-col on a VBox element,
orred-margin on a node with no margin, or reduce font on non-text
nodes. For each node n, the procedure GETVALID NODEFIXES
computes only the valid ﬁxes (Tab. 5) and prunes away the rest (e.g.,
red-row in Fig. 4). The procedure GETVALID FIXES combines these
ﬁxes for the bad nodes in Tand ranks them to obtain enabled ﬁxes
Σ/primeforq.
Redundant ﬁx pruning. We can prune the valid ﬁx set further by
removing ﬁxes which may not help satisfy any violated constraint
inC. We detect them by relating the constraints violated and the bad
nodes inn’s subtree as follows.
•Ifnis a bad node but none of descendants are bad, then
ﬁxes red-col andred-row are redundant. This is because both
these ﬁxes modify only n’s descendants, not n, e.g., in Fig. 3,
suppose the min-width for Vis is violated, but its children
imgiandpiare not. Applying ( Vi,red-col ) does not change
Vi’s width, only its children’s width.
•Applying red-col (red-row ) onnis redundant if none of its
descendants is violating min-width (max-width) constraints.
•Applying red-margin if (i) max-width is violated for n, i.e.,
width (n)>max-width (n)(red-margin increases the width of
n), or, (ii)nviolates its min-width constraint and maximum
margin reduction is not enough, i.e., width (n)+ max-margin-
reduction (n)<min-width (n). (cf. red-margin ﬁx).
The second optimization tries to detect equivalent ﬁx-chains in a
DTG which correspond to re-orderings of independent ﬁxes.
Independent Fixes. Two ﬁxesf1andf2on nodesn1andn2,
respectively, are said to be independent if (i) applying one ﬁx does
not disable the other, and (ii) the T/primeobtained after applying both f1
andf2does not depend on the order in which the ﬁxes are applied,i.e., the ﬁxes commute . The notion of independence allows us to
explore only the representative ﬁx-chains of enabled ﬁxes. Most
ﬁxes in Table 2 commute with each other, leading to the same DT
irrespective of the application order. However, depending on the
given constraints, ﬁxes may disable each other. Fig. 6 illustrates a
portion of the DTS for a design with three boxes B1,B2andB3.
In the initial state q1, the min-width criteria for both B2andB3
is violated, i.e., bad nodes are {B1,B2,B3}. There are two ways
to ﬁx it: by applying ﬁx f1(red-col) on B1or by applying ﬁx f2
(red-margin) on B2andB3. The two ﬁxes are dependent on each
other: applying f1leads toq2, with no bad nodes and hence f2is
disabled. Similarly, applying f2atq1disablesf1inq3.
Fixes which only affect the subtree of the target node cannot
disable each other because they apply to non-overlapping subtrees,
e.g., in Fig. 4, ﬁxes red-margin ,red-row andred-col can be applied
to each of the nodes V1,V2,V3andV4and are independent of each
other. For example, the ﬁx-pair ( V2,red-margin ) enabled at state q1,
remains enabled at q4andq5, after applying ﬁxes to V1. Efﬁcient
exploration of graphs with dependent transitions is a hard problem:
several generic partial-order reduction methods [ 25,22,23] for
program state space exploration have been developed. We extend
these methods to our problem by exploiting the fact that states in a
DTG correspond to trees.
Pre-order Fix Chains. A pre-order linearization ,pre(T)of a DT
Tis a node sequence obtained by traversing Tin pre-order. Because
DTs are ordered, a unique linearization, /hatwidestpre(T), exists for each DT
T. Given a ﬁx chain s=(n1,f1),···,(nk,fk), we deﬁne the
node-projection ofs,s↓, as the sequence n/prime
1,n/prime
2,···n/prime
lsuch that
(i)n1=n/prime
1andnk=n/prime
l, (ii)s↓preserves the node order of sand
does not stutter, i.e., for all 1≤i < k ,n/prime
i/negationslash=n/prime
i+1. A ﬁx chain s
overTis said to be pre-order iffs↓is a sub-sequence of /hatwidestpre(T).
For example, in Fig. 3, the ﬁx-chains [( H1, red-margin), ( H1, red-
col), (V1, red-margin)] and [( V1,red-margin), ( V2,red-margin)] are
pre-order but [( V1, red-margin), ( H1, red-col)] is not.
We observed that ﬁxes on higher tree nodes affect a large number
of nodes and few such ﬁxes (in contrast to lower node ﬁxes) are
sufﬁcient to yield most desired DTGs. Pre-order ﬁx chains are
biased towards such ﬁxes; ﬁxes are applied on the parent node ﬁrst,
followed by children. Also, pre-order ﬁx chains process siblings in
a ﬁxed order, allowing us to avoid permutations of independent ﬁxes
and narrow the search space. We therefore constrain EXPLORE DTG
to search only for pre-order ﬁxes by checking on-the-ﬂy if the current
ﬁx-chain is a sub-sequence of the DT linearization. Given a tree T
withNbad nodes, number of sub-sequences of pre(T)isO(N·p!)
wherep=|F|+1. Although still large, this bound is signiﬁcantly
lower than the earlier bound O(N!·pN).
Ranking Fix Sequences. DECORranks the obtained ﬁx chains Λ
(Alg. 1) as follows. Shorter ﬁx-chains are ranked higher than longer
ones. For ﬁx-chain sands/primeof equal length, sis ranked higher if
between nodes niandn/prime
iatithindex, resp., nihas a higher tree
height thann/prime
i. We can also shorten ﬁx-chains to remove irrelevant
ﬁxes before ranking them (cf. Sec. 7).
7. IMPLEMENTATION AND EV ALUATION
We implemented DECORas a plugin to Maqetta [ 11], an open-
source WYSIWYG editor, which allows creating designs by drag-
drop and then specifying CSS properties. The plugin extracts the
design as a JSON ﬁle and sends it to a backend server (node.js [ 13]
application), which provides responsive design suggestions. The
backend takes in user-speciﬁed constraints and breakpoints also in
JSON format. We run a simple checker to identify any inconsistency
in the input constraints before running DECOR, e.g., min-width is
higher than the max-width constraint for an element.
DECORcan operate in two modes - default andinteractive . In
550thedefault mode, DECORis fully automated: it ﬁnds all possible ﬁx
chains for each breakpoint, ranks them, applies the highest ranked
ﬁx-chain to get the repaired design for that breakpoint and proceeds
to the next smaller breakpoint. In the interactive mode, user shrinks
the design up to a certain breakpoint, identiﬁes constraint violations,
adds new constraints and invokes DECORto get recommendations.
She can add/remove/update constraints and run DECORagain to
get a different set of recommendations. Finally, the set of obtained
design trees, one for each breakpoint, are encoded into a pair of
HTML and CSS ﬁles using the technique in [ 33]: each tree is
encoded into CSS rules separately and then combined using media-
queries [ 12]. If multiple recommendations exist, each of them gets
its own CSS ﬁle. DECORis 15K lines of JavaScript code (around
6K lines for repair computation).
We evaluate DECORfrom two different perspectives. (Q1) What
are the characteristics of recommended ﬁx-chains and how effective
are the pruning strategies (cf. Sec. 6) ? (Q2) To test the overall
usability of the tool, understand the beneﬁts and drawbacks of the
proposed approach. For the ﬁrst part, we ran DECORin default
mode and thoroughly study the recommended ﬁx chains and com-
putation times. For the second part of evaluation we conduct a
preliminary user study of the tool in the interactive mode.
Benchmarks. No standardized set of benchmarks for responsive
designs exist. However, several online resources point to the popular
responsive patterns and web-sites implementing them, e.g., Neil’s
slides [ 15] and the Marcotte’s book [ 31] provide a comprehensive
overview of responsive design patterns. From these references, we
selected web-sites which implement the popular responsive patterns,
e.g., column-drop, column-ﬂip, feature-items, feature-shufﬂe, mostly-
ﬂuid, mondrian, tiny-tweak, layout-shifter, gallery, top-nav etc. [ 15]
All these transformations can be obtained using the set of ﬁxes
implemented in DECOR. We created two sets of benchmarks: (a)
synthetic designs with few boxes, each of which demonstrates one or
two responsive behaviors, and (b) real-world designs. For the latter,
we selected 7 web-sites (Table 3) having multiple responsive patterns
and created mockups in Maqetta faithful to the original web-sites:
we ignored some style annotations and few elements irrelevant to
the responsive behavior. Table 4 shows the benchmarks (synthetic
followed by real). In total we used 20 mockups for evaluating
DECORin the default mode. Drawing each initial design took about
1-2 hours. All mockups are drawn originally for desktop width
(1400px).
Deﬁning Constraints. For the ﬁrst part of evaluation, we deﬁned
constraints on properties, e.g., width and margin, for each bad UI
element. Most constraints relate to min/max width or margins of el-
ements and apply to all breakpoints. Breakpoint-speciﬁc constraints
are only a few ( 5%): those for hiding an element and ﬁxing its font-
size. To specify constraints for a breakpoint, we shrink the browser
size to the breakpoint and obtain, say, the current width for a bad
element or its parent. Next, we add constraints to allow DECORto
provide recommendations which mimic original design transitions.
Constraint speciﬁcation for synthetic designs to obtain desired be-
haviors was easy. However, constraints for the real designs to mimic
Mockup Name URL
overview http://foodsense.is
portfolio http://www.bradsawicki.com
ﬁve-steps http://www.ﬁvesimplesteps.com/
orestis http://www.orestis.nl
modernizr http://modernizr.com/
palantir http://palantir.net
trent-walton http://trentwalton.com/
Table 3: Sources of real responsive pages in benchmarks.original behaviors required a few iterations to get right. Specifying
constraints for real benchmarks took 3mins (ﬁve-steps, portfolio,
palantir) to 10mins (modernizr, overview).
7.1 Tool Performance
We implemented the following ﬁxes in DECOR:red-col, red-
margin, red-row, hide-node, mod-nav, mod-text , and mod-line-height
(cf. Table 2). We conducted all experiments in default mode on
a Mac Snow Leopard with 2.3 GHz Intel Core i5 processor and
4GB memory. To gain insight into the running times, ﬁx-chain
characteristics and effect of optimizations, we implemented three
exploration modes in D ECOR.
•Dynamic Depth limit (DDL): Once DECORﬁnds a ﬁx-chain
of lengthl, it restricts its search to all ﬁx chains of depth l.
This mode ﬁnds at least one ﬁx-chain, if it exists, and then
does not waste time searching for longer chains.
•Bounded exploration: Given a particular bound l,DECOR
restricts its search to all ﬁx-chains of length less than lin
DTG. Multiple bounds are evaluated. In contrast to DDL
mode, a ﬁx-chain may not be found if lis too small.
•Lazy mode: Here, DECORstops after ﬁnding single ﬁx-chain
(as opposed to earlier modes), which is minimized by greedily
removing ﬁxes (in no particular order) and checking if the
remaining chain repairs the tree. This mode aims at ﬁnding a
single, short ﬁx-chain quickly.
The number of UI elements (boxes) vary between 7 to 109, and
the tree height between 2 and 6, the number of constraints between 2
to 21 in the benchmarks. Table 4 shows the results on 20 benchmarks
with the DDL mode for each of the 3 breakpoints. For each break-
point, the number of bad nodes and ﬁx-chains (recommendations)
found, the lengths of ﬁx-chains and the time is shown. Although the
number of bad nodes (cf. Sec. 5) is large in many designs, a short
ﬁx-chain is sufﬁcient, e.g., for portfolio , the number of bad nodes
is19in stp breakpoint but requires a ﬁx-chain only of length 2to
repair it. Note that it may be hard for the designer to ﬁgure this out
manually: she may perform too many unnecessary ﬁxes for the bad
nodes before realizing that a shorter ﬁx exists. For real benchmarks,
most ﬁx-chains have length 2−6except for stp, e.g., 11−13for
modernizr . This is because the same ﬁx red-margin is applied on 6
similar images in modernizr .
The ranking heuristics in DECORperform well on most real
designs in mimicking the original design transitions accurately.
DECORﬁnds ﬁx-chains that mimic the behavior of all real bench-
marks among ﬁve top-ranked recommendations: for all benchmarks
except ﬁve-steps (rank 2) and portfolio (rank 4), the top recom-
mendation matched the real behavior. In ﬁve-steps andportfolio ,
DECORﬁnds a shorter ﬁx-chain satisfying constraints than the one
that captures the real behavior and ranks it higher.
Overall, DECORsuccessfully computes multiple possible ﬁx-
chains for multiple breakpoints on realistic mockups with 100
elements, within 30 seconds. Thus, it can be used interactively to
perform multiple design updates. DECORowes its performance
to a series of optimizations discussed earlier (Sec. 6). Across all
benchmarks, the maximum memory used by DECORis<100MB.
Table 4 shows that with a small set of constraints we are able
to infer realistic ﬁx-chains. For benchmarks portfolio ,modern-
izr,palantir , the number of constraints required is larger ( >10);
however, this is because of multiple similar elements: the unique
constraints here are 5, 10, and 7 respectively.
Effect of Optimizations. We show the effect of optimizations (cf.
Sec. 6) on a selected set of 4real benchmarks (other benchmarks
551Tablet (width 1024px) Small tablet portrait (stp, width 600px) Mobile portrait (mop, width 300px)
# Nodes / # Constraints/ # Bad # Fix Chain Len. # Bad # Fix Chain len. # Bad # Fix Chain len. Total
Mockup Height # C-nodes node Chain Min/ Max/ Avg Time node chain Min/Max/Avg Time node chain Min/Max/Avg Time Time
mostly-ﬂuid 12/3 3/3 1 1 1/1/1 0.105 0  N/A 0.033 8 2 1/2/1.5 0.206 0.353
column-drop 11/3 2/2 1 1 1/1/1 0.092 4 2 1/2/1.5 0.201 4 2 1/2/1.5 0.187 0.488
tiny-tweak 11/3 3/3 1 1 1/1/1 0.09 4 1 1/1/1 0.093 6 2 1/2/1.5 0.216 0.406
mondrian 7/2 7/4 4 1 1/1/1 0.146 6 2 2/3/2.5 0.188 7 4 2/4/3 0.197 0.562
gallery 11/3 6/6 1 1 1/1/1 0.098 8 2 1/2/1.5 0.146 8 2 1/2/1.5 0.165 0.416
featured-items 15/3 4/4 0  N/A 0.078 10 4 1/3/2 0.323 10 4 1/3/2 0.475 0.888
top-nav 19/3 5/5 2 4 1/2/1.5 0.279 10 4 1/3/2 0.482 10 4 1/3/2 0.713 1.483
nav-bar 19/3 5/5 2 4 1/2/1.5 0.277 10 4 1/3/2 0.464 11 7 2/4/3.29 1.177 1.926
hide-3 8/2 6/4 4 1 1/1/1 0.112 5 2 3/4/3.5 0.14 7 4 2/4/3 0.215 0.475
hide-p 11/3 2/2 1 1 1/1/1 0.103 7 1 1/1/1 0.059 6 2 1/2/1.5 0.173 0.345
hide-h 11/3 3/3 2 1 1/1/1 0.113 7 2 2/3/2.5 0.216 2 1 1/1/1 0.073 0.412
hide-n-font 11/3 3/3 1 1 1/1/1 0.09 4 1 1/1/1 0.091 0  N/A 0.035 0.223
rpe-mockup 35/5 4/4 5 1 1/1/1 0.166 5 4 2/4/3 0.558 0  N/A 0.06 0.794
overview 69/5 9/8 6 2 4/5/4.5 3.462 10 5 3/5/4.2 5.928 11 4 3/5/4 12.402 21.888
portfolio 31/3 16/15 4 1 1/1/1 0.351 19 2 2/3/2.5 0.847 17 2 2/3/2.5 0.64 1.845
ﬁve-steps 95/6 8/8 12 6 2/3/2.5 5.926 12 24 3/7/4.83 17.737 5 4 2/4/3 4.067 27.738
orestis 109/6 10/10 1 1 1/1/1 1.021 9 16 5/9/7 22.389 10 1 4/4/4 1.841 25.258
modernizr 62/5 21/16 8 8 3/5/4 5.037 16 4 11/13/12 7.748 19 2 6/7/6.5 3.193 15.986
palantir 62/4 11/8 3 2 2/3/2.5 0.964 11 12 4/8/6 12.975 10 4 5/7/6 2.478 16.428
trent-walton 27/4 5/4 0  N/A 0.09 16 1 12/12/12 0.979 12 1 8/8/8 1.254 2.33
Table 4: Fix data for all benchmarks in DDL mode with all optimizations applied. All times in seconds. Column #C-nodes denotes
the number of constrained nodes. denotes that the design satisﬁes constraints and no ﬁx is needed.
show similar results) in Fig. 7(a). Basic column corresponds to
applying hide-node, mod-text ﬁxes initially followed by full DTG
exploration. Basic + preorder corresponds to searching only for
pre-order ﬁx chains (Sec. 6). Basic+rfp stands for combining basic
mode with redundant ﬁx pruning (rfp). Basic+ preorder + rfp stands
for combining all above optimizations, but allowing permutations
of ﬁxes on same node. Allcolumn combines all optimization heuris-
tics, i.e., basic, preorder ﬁx-chains, pruning redundant ﬁxes and
eliminating ﬁx permutations on a node. The results show that pre-
order ﬁx-chains and rfpprovide the most signiﬁcant improvement
in run-times. For small benchmarks, the effect of optimizations is
not signiﬁcant but they are essential for real benchmarks: running
overview example with only basic optimization applied took more
than 3 hours for one breakpoint (stp), whereas it came down to
almost 30s after applying all optimizations.
Figure 7(b) shows the correlation of enabled ﬁxes and run-time
foroverview benchmark. We observe that the runtime of DECOR
increases linearly with the number of ﬁxes enabled; optimizations
are able to reduce this value, thus leading to improved performance.
Also observe that preorder ﬁx-chains have a drastic effect in reducing
the number of enabled ﬁxes, from tens of thousands to less than
500; rfp brings it down further. Finally, combining all optimizations
reduces enabled actions to only 128.
Lazy mode. Fig. 7(c) compares the runtime of DDL (ﬁnd all ﬁx-
chains) and Lazy (ﬁnd one ﬁx-chain) modes, with all other pruning
optimizations. In most cases, the top-ranked ﬁx-chain in DDL and
the one found by the Lazy mode are of equal lengths. In general,
the Lazy mode returns the ﬁrst ﬁx much sooner than the DDL mode.
However, for some examples the Lazy mode takes longer: if a ﬁx-
chain is long and has no redundant ﬁx, the minimization time in
Lazy mode outweighs the beneﬁt of searching for only one ﬁx chain.
Although DDL does not minimize ﬁx-chains explicitly, it explores
multiple ﬁx-chains and hence can ﬁnd short chains also.
Limitations. The current version of DECORrequires users to spec-
ify constraints on individual nodes, not groups. DECORcannot
extract design trees from existing designs currently. We therefore
specify original designs in Maqetta [ 11] WYSIWYG editor, which
is time-consuming and laborious. We plan to handle legacy designs
in future. Better support for visualizing the interaction of constraints
with ﬁxes is needed for a better debugging experience. Finally,DECORis restricted to its ﬁx library and chosen responsive patterns
during recommendation. While we support the common ﬁx actions,
others are not implemented yet, in particular, those for changing
order of elements and navigation patterns which require complex
JavaScript interaction.
7.2 Preliminary User Study
We conducted a preliminary study to gauge the manual effort
inDECORand compare with Adobe Edge Reﬂow (AER) [ 2], a
commercial tool, which enables creating designs for multiple break-
points by direct manipulation. We created a web UI to specify
constraints (in JSON format), run DECORon various benchmarks
and view recommendations. We chose 3 participants (1 female,
mean age=26.33, sd=2.52) with minimal expertise in UI program-
ming, i.e., who are familiar with HTML/CSS based design using
WYSIWYG editors but are unfamiliar with responsive design.
The study was conducted in two phases. First, the participants
were given a tutorial on both AER (using web site [ 2] tutorials) and
DECOR(drawing mockups in Maqetta with direct manipulation,
writing constraints in JSON format, and using browser tools to in-
spect output design features). This was followed by a walk-through
ofDECORon the overview benchmark: drawing mockup, setting
constraints and viewing recommendations. The effect of various
ﬁxes and interaction between constraints and ﬁxes was explained.
The participants could modify the constraints iteratively via the UI,
run D ECOR and inspect changes in recommended designs.
In the second phase, we asked the participants to create respon-
sive UIs from an initial design for 3 breakpoints using both AER
andDECOR, in their preferred order. We chose 3 UIs: nav-bar
(simple), portfolio (slightly complex) and modernizr (complex).
Here, complexity is measured using the number of UI elements,
responsive transitions and the number of constraints. At the end
of the task, the participants were asked to answer an evaluation
questionnaire set. The questions included rating the difﬁculty in
adding constraints and comparison of design effort with DECORas
opposed to AER. To complete the tasks, the participants take about
10 minutes with DECORand about 20 minutes with AER. The user
feedback suggested the following beneﬁts of D ECOR over AER.
Repeated manual effort. In AER, the participants had to manually
rearrange UI elements for each breakpoint. In contrast, constraints
on elements in DECORtrigger responsive behavior directly. For
552(a) (b) (c)
Figure 7: (a) Effect of optimizations on runtime. (b) Effect of number of enabled actions on runtime for overview benchmark (c)
Runtime for benchmarks in DDL and lazy modes (all optimizations enabled). Column ’X’ denotes a timeout (5min).
example, in the modernizr benchmark, the team images are arranged
in 2x3 grid initially. Each time a user tries to modify the grid layout
in AER for lower breakpoints, say to 3x2 or 6x1, she has to resize
and rearrange each of the images. On the other hand in DECOR,
the same constraint, e.g., min-width of an image, triggers layout
grid changes for all the breakpoints. Similarly, in portfolio , the grid
contains 12 elements and for each breakpoint, all of them either have
to be relocated, resized or the corresponding CSS property updated
carefully in AER. In DECOR, the constraints for one element in the
grid can be quickly copied to other siblings. Moreover, specifying
constraints on only a subset of elements is often sufﬁcient to obtain
the desired responsive behavior.
Useful Recommendations. In contrast to DECOR, AER provides
no recommendations. The designer bears the onus of choosing
the right responsive patterns in AER, requiring deep knowledge
of responsive designs, e.g., in the nav-bar benchmark (arranged
as a single row grid in the tablet breakpoint), DECORgave two
recommendations for mop: replace it by select , or reduce the number
of columns and place the navigation anchors in different rows. One
of the participants did not think of the select option with AER and
found the suggestion by D ECOR very helpful.
Avoid Trial and Error. Lack of recommendations in AER forced
the participants to try out and undo different design changes one-by-
one, which was time-consuming. For nav-bar , a participant tried to
rearrange the elements in top navbar in different ways, in a single
column or multiple rows and ﬁnally replaced them with a select
menu. In contrast, in DECOR, she speciﬁed only the min-width con-
straint and obtained all the three recommendations within a minute.
Participant answered that even if each constraint corresponds to
a single ﬁx, it is easier in many cases to specify constraints than
guessing the correct element to ﬁx manually.
Participants remarked that AER’s superior direct manipulation
features (compared to Maqetta) allowed them to create initial de-
signs faster. We also received multiple feature requests for DECOR:
ability to specify non-numerical constraints (too narrow or wide),
constraints on multiple elements simultaneously, tool recommenda-
tions to hide elements. We plan to incorporate these requests in the
tool and conduct a user study over a bigger participant set in future.
Although thinking in terms of constraints required more work for
simple designs, participants were quite enthusiastic about using
DECORas the design complexity increased. In summary, the partic-
ipants found DECOR’s approach of using constraints and providing
design recommendations more appealing than direct manipulation
based design in AER.
8. RELATED WORK
Constraints are widely used for macro -typography (see [ 27,35]
for a detailed survey) to specify UI object sizes and relative align-
ment [ 21,18,24]. Constraints are central to iOS ( Auto Layouts ) [10],
which also allows visual constraints. However, these systems as-sume a dedicated layout engine: the solver computes the exact pixel
locations of elements for a particular viewport, which is used on-
the-ﬂy by the renderer. Further (cf. Sec. 1) these systems search
over a narrow design space: ﬁxes proposed by the solver can re-size
(shrink, expand) boxes but not re-arrange them. Annotation-based
libraries, e.g., Bootstrap [ 7], Zurb foundation [ 17], have a steep
learning curve and require deep HTML/CSS expertise [ 30,33] to
map arbitrary designs to the framework-speciﬁc annotations.
Recent work investigates specifying constraints by direct ma-
nipulation [ 35,26]. None of these tools provide multiple design
recommendations: [ 35] provides conﬂict explanations, but each
explanation may correspond to multiple ﬁxes leading to several
possible designs. Remorph [ 20] retargets existing web pages by
shrinking element widths based on viewport without user-speciﬁed
constraints: this may result in too-wide elements and unaesthetic
designs. Bricolage [ 29] is a machine learning based approach to
retargeting based on a web-based corpus of designs.
In contrast, we perform constraint-based design tree repair and
provide a small set of recommendations via a set of novel design-
space pruning and ranking techniques. We avoid a fully symbolic
encoding, as the latter requires logical axiomatization of trees (with
quantiﬁers), making implementing optimizations and browser-based
deployment much more complex. Encoding the solution DTs as a
HTML/CSS ﬁle [ 33] along with media-queries allows us to employ
the off-the-shelf, heavily optimized rendering engines of browsers
to parse and render HTML/CSS for responsive behavior. Adaptive
document layout techniques were presented in [ 32] based on solving
constraints over user-speciﬁed layout templates and a dedicated ren-
dering engine. In contrast, we target HTML/CSS designs based on
nested box layouts (designer only speciﬁes constraints on elements
not templates) and exploit off-the-shelf renderers. Another option
is to use JavaScript for on-the-ﬂy layout computation in browser;
however, this overloads the mobile devices unnecessarily and also
fails to exploit the native optimized renderer.
9. CONCLUSIONS
We presented a systematic approach for inferring multi-device
responsive designs from a given UI design and user-speciﬁed con-
straints. Our tool DECORassists the designer by providing design
recommendations interactively. DECORaims at improving the pro-
ductivity of experienced designers for creating responsive designs as
well as reducing the learning curve for HTML/CSS and responsive
designs for unskilled designers. DECORis able to provide realistic
list of recommendations in a short time for real-life designs. We
plan to add constraints for multiple elements, e.g., by direct manipu-
lation, and improve debugging experience. Other planned features
include adding inverse ﬁxes from lower to higher breakpoints, and
ﬁxes which adapt image resolution to devices.
553References
[1]Adobe Dreamweaver CS6. http://www.adobe.com/
products/dreamweaver.html .
[2]Adobe edge reﬂow cc. http://html.adobe.com/edge/
reflow/ .
[3] Balsamiq. http://www.balsamiq.com/ .
[4]Cascading Style Sheets Level 2 Revision 1 (css 2.1) Speciﬁcation.
http://www.w3.org/TR/CSS21/ .
[5]CSS ﬂexible box layout module. http://www.w3.org/TR/
css3-flexbox/ .
[6] Food sense website. http://foodsense.is/ .
[7] Get bootstrap. http://getbootstrap.com/css/ .
[8] Html5. http://www.w3.org/TR/html5/ .
[9]Interactive wireframe software and mockup tool. http://www.
axure.com/ .
[10] iOS Auto Layouts. https://developer.apple.com/
library/ios/documentation/UserExperience/
Conceptual/AutolayoutPG/Introduction/
Introduction.html .
[11] Maqetta. http://maqetta.org/ .
[12] Media queries, Mozilla MDN. https://developer.mozilla.
org/en-US/docs/Web/Guide/CSS/Media_queries .
[13] node.js. http://nodejs.org/ .
[14] Responsive designs in a snap (full version). http:
//researcher.watson.ibm.com/researcher/files/
in-nishant.sinha/responsive.pdf .
[15] Theresa Neil: Mobile design strategic solution.
http://www.slideshare.net/theresaneil/
mobile-design-strategic-solutions/ .
[16] Why 2013 is the year of responsive web design. http://mashable.
com/2012/12/11/responsive-web-design/ .
[17] Zurb foundation. http://foundation.zurb.com/ .
[18] G. J. Badros, A. Borning, and P. J. Stuckey. The cassowary linear
arithmetic constraint solving algorithm. ACM Trans. Comput.-Hum.
Interact. , 8(4):267–306, December 2001.
[19] Greg J. Badros, Alan Borning, Kim Marriott, and Peter Stuckey. Con-
straint cascading style sheets for the web. UIST ’99, pages 73–82,
1999.[20] G. L. Bernstein and S. Klemmer. Towards responsive retargeting of
existing websites. UIST’14 Adjunct.
[21] A. Borning, B. N. Freeman-Benson, and M. Wilson. Constraint hierar-
chies. In Over-Constrained Systems , pages 23–62, 1995.
[22] E. Clarke, O. Grumberg, and D. Peled. Model Checking . MIT Press.
[23] C. Flanagan and P. Godefroid. Dynamic partial-order reduction for
model checking software. In POPL , pages 110–121, 2005.
[24] K. Z. Gajos, D. S. Weld, and J. O. Wobbrock. Automatically generating
personalized user interfaces with supple. Artif. Intell. , 174(12-13):910–
950, 2010.
[25] P. Godefroid. Partial-Order Methods for the Veriﬁcation of Concurrent
Systems: An Approach to the State-Explosion Problem . Springer-
Verlag, Secaucus, NJ, USA, 1996.
[26] T. Hottelier, R. Bodik, and K. Ryokai. Programming by manipulation
for layout. In UIST , 2014.
[27] N. Hurst, W. Li, and K. Marriott. Review of automatic document
formatting. In Proceedings of the 9th ACM symposium on Document
engineering , DocEng ’09, pages 99–108, 2009.
[28] P. M. Marden Jr. and E. V . Munson. Today’s style sheet standards: The
great vision blinded. IEEE Computer , 32(11):123–125, 1999.
[29] R. Kumar, J. O. Talton, S. Ahmad, and S. R. Klemmer. Bricolage:
example-based retargeting for web design. In Proceedings of the
SIGCHI Conference on Human Factors in Computing Systems , CHI
’11, pages 2197–2206, 2011.
[30] H. W. Lie. Cascading style sheets. PhD thesis, University of Oslo,
February 2006.
[31] E. Marcotte. Responsive Web Design . A Book Apart, 2011.
[32] E. Schrier, M. Dontcheva, C. Jacobs, G. Wade, and D. Salesin. Adap-
tive layout for dynamically aggregated documents. In IUI, pages
99–108, 2008.
[33] N. Sinha and R. Karim. Compiling mockups to ﬂexible uis. In ESEC-
FSE, 2013.
[34] L. Wroblewski. Mobile First . A Book Apart, 2011.
[35] Clemens Zeidler, Christof Lutteroth, Wolfgang Sturzlinger, and Gerald
Weber. The auckland layout editor: An improved gui layout speciﬁca-
tion process. UIST ’13, 2013.
554