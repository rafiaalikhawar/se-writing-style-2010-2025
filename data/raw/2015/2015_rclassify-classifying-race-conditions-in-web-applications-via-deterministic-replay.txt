RClassify: Classifying Race Conditions in Web
Applications via Deterministic Replay
Lu Zhang
Virginia Tech
Blacksburg, V A, USAChao Wang
University of Southern California
Los Angeles, CA, USA
Abstract —Race conditions are common in web applications
but are difﬁcult to diagnose and repair. Although there exist
tools for detecting races in web applications, they all report a
large number of false positives. That is, the races they report are
either bogus , meaning they can never occur in practice, or benign ,
meaning they do not lead to erroneous behaviors. Since manually
diagnosing them is tedious and error prone, reporting these
race warnings to developers would be counter-productive. We
propose a platform-agnostic, deterministic replay-based method
for identifying not only the real but also the truly harmful race
conditions. It relies on executing each pair of racing events in two
different orders and assessing their impact on the program state:
we say a race is harmful only if (1) both of the two executions are
feasible and (2) they lead to different program states. We have
evaluated our evidence-based classiﬁcation method on a large set
of real websites from Fortune-500 companies and demonstrated
that it signiﬁcantly outperforms all state-of-the-art techniques.
I. I NTRODUCTION
Modern web applications are complex due to their need
to implement many features on the client side through asyn-
chronous programming and the use of JavaScript code while
maintaining quick response to users. Although web browsers
typically guarantee that each Java Script code block is executed
atomically, meaning there is no data-race in the traditional
sense, high-level race conditions can still occur due to de-
ferred HTML parsing, interleaved execution of event handlers,
timers, Ajax requests, and their callbacks.
Existing race detection tools for web applications [33],
[21], [22], [7], [18], [9] often report many false positives.
That is, warnings reported by these tools may be bogus ,o r
real but harmless . For example, E VENT RACER [22] reported
hundreds of warnings from the ofﬁcial websites of Fortune-
500 companies; although some of these race conditions are
indeed harmful, the vast maj ority are not, which means di-
rectly reporting them to developers would have been counter-
productive. None of the existing tools, including R4 [9], can
accurately assess the impact of racing events and robustly
identify the real and truly harmful race conditions.
We propose RC LASSIFY ,t h eﬁ r s t evidence-based method
for classifying race-condition w arnings in web applications.
Toward this end, we develop a platform-agnostic deterministic
replay framework for client-side JavaScript programs, and
leverage it to assess the actual impact of race conditions.
Given a race-condition warning denoted (eva,ev b),w h e r eeva
andevbare the racing events, we ﬁrst execute the application
while forcing evato occur before evb, and then execute the
application while forcing evbto occur before eva.W es a y
that (eva,ev b)is a harmful race only if (1) both executions
are feasible and (2) the resulting program states, ps1and
Instrumented 
Web Application
Compare the 
Program States
Execution 1
URL of Web 
Application Race-condition
Warnings
Static Analysis 
 of HTML files
Replay the Racing
Event Pair
Execution 2Harmful or
Harmless
Fig. 1. RC LASSIFY :O u r evidence-based race-condition classiﬁcation method.
ps2, differ in some important ﬁelds of the HTML DOM,
JavaScript variables, and environment variables of the browser.
The intuition is that, when the order of evaandevbis not fully
controlled by the program logic, and yet affects the program
behavior, it deserves a closer look by developers.
The overall ﬂow of RC LASSIFY i ss h o w ni nF i g .1 ,w h o s e
input is the URL of the web application and a set of race-
condition warnings, and whose output is the set of harmful
races. First, it statically an alyzes the HTML ﬁles and then
uses source-code transformation to add self-monitoring and
control capabilities. Then, it analyzes the race-condition warn-
ings (reported by the race detection tool) and generates the
conﬁguration ﬁles needed for deterministic replay. Next, for
each pair (eva,ev b)of racing events, it executes the application
twice—once with evapreceding evband the other time with
evbpreceding eva. Finally, it compares the two resulting
program states ps1andps2.
There are two technical challenges. The ﬁrst challenge
is developing a robust method to deterministically replay a
JavaScript-based client-side web application. This is difﬁcult
due to the myriad possible sources of nondeterminism. For
example, the race condition may occur during the deferred
parsing of HTML elements, the interleaved execution of
JavaScript, the dispatch of multiple event handlers, the ﬁring of
timer events, the execution of asynchronous HTTP requests,
as well as their callback routines. In this context, our main
contribution is developing a uniﬁed framework for controlling
the execution order of the various types of racing events.
Our replay framework differs from the mechanisms used
by existing race detection tools such as E VENT RACER ,WAV E,
and R4, because it is implemente d within the target web appli-
cation itself and therefore is platform-agnostic. That is, we do
not modify the web browsers or their underlying JavaScript ex-
ecution engines (e.g., W EBKIT). Instead, we leverage source-
code transformation to add self-monitoring and control capa-
2017 IEEE/ACM 39th International Conference on Software Engineering
 
DOI 10.1109/ICSE.2017.33277
2017 IEEE/ACM 39th International Conference on Software Engineering
1558-1225/17 $31.00 © 2017 IEEE
DOI 10.1109/ICSE.2017.33278
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:08 UTC from IEEE Xplore.  Restrictions apply. bilities to the application itself (see Section V). This is better
than existing approaches because technologies are changing
rapidly and tools implemented using a particular version of
the browser will quickly become obsolete. In contrast, our
platform-agnostic approach will be more robust against these
changes and updates.
Since we concretely execute the application using deter-
ministic replay, as opposed to heuristically ﬁltering the warn-
ings [21], [22] or applying conservative static analysis [18],
[32], we can robustly decide if a race condition is real (i.e., if
both execution orders are feasib le). The reason why existing
tools report many bogus race conditions in the ﬁrst place is
because some hidden happens-bef ore relations between events
are not accounted for, and precisely capturing all happens-
before relations would have been prohibitively expensive.
The second challenge is to decide, during state recording
and comparison, which ﬁelds of the program state are impor-
tant and thus should be compared. For a typical client-side web
application, the number of ﬁelds can be extremely large, which
means including all of them would result in large overhead at
run time. Furthermore, many ﬁelds are actually designed to be
sensitive to other sources of nondeterminism that are irrelevant
to the race condition. For example, there are ﬁelds that need
to have different values depending on the date or time of the
day. In such cases, we should exclude them in order to avoid
the false positives.
Therefore, our main contribution in this context is develop-
ing a ﬂexible conﬁguration interface to allow users to specify
which ﬁelds should be excluded. We also propose a testing-
based method (see Section VI) to automatically identify and
exclude these irrelevant ﬁelds.
We implemented and evaluated RC LASSIFY on standard
benchmarks and real websites from Fortune-500 companies.
Our experiments show that RC LASSIFY outperforms all other
existing tools capable of handling the same benchmarks,
including E VENT RACER [22], Mutlu et al. [18], and R4 [9].
For example, RC LASSIFY identiﬁed all 33 known-to-be-
harmful races out of the 50 warnings in standard benchmarks,
whereas R4 identiﬁed only 8 of them and Mutlu et al. [18]
did not identify any. Furthermore, on the seventy randomly
chosen websites from the portals of Fortunate-500 companies,
EVENT RACER [22] returned 1,903 warnings, among which
RCLASSIFY identiﬁed 73 as bogus, 132 as harmful, 1644
as harmless, and 54 as undecided. We manually reviewed
the 132 harmful races and conﬁrmed the correctness of our
classiﬁcation; in contrast, R4 [9] identiﬁed only 33 of the
harmful races, indicating that it is signiﬁcantly less effective.
To sum up, this paper makes the following contributions:
•We propose an evidence-based method for classifying
race-condition warnings in web applications, by con-
cretely executing the appli cation to assess the actual
impact of racing events.
•We develop a platform-agnostic deterministic replay
framework for JavaScript-based web applications, which
does not rely on modifying browsers or JavaScript en-
gines, and thus is more widely applicable.
•We evaluate the new method on standard benchmarks as
well as a large number of real websites to demonstrate its
effectiveness in identifying the harmful race conditions.
1<html >
2<head > ... </ head >
3<body >
4<img src ="image1.jpg" onload ="image1Loaded()"
id="image1" >
5<!-- omitted elements... -- >
6<script id ="script1" >
7 function image1Loaded() {
8 document.getElementById( "button1" )
.addEventListener( "click" , func);
9 }
10 function func() {
11 document.getElementById( "outputField" ).innerHTML
="Well done!" ;
12 }
13 </script >
14 <!-- omitted elements... -- >
15 <button id ="button1" > button1 </ button >
16 <!-- omitted elements... -- >
17 <div id ="outputField" >< / div>
18</body >
19</html >
Fig. 2. Example: A client-side web application with race conditions.
II. M OTIV ATION
In this section, we use examples to illustrate the ideas behind
our new method while highlighting the technical challenges.
A. Race Conditions
Consider the web page in Fig. 2, which contains an image,
a button, and a JavaScript code block. The image.onload
event, ﬁred after the browser downloads image1 ,i n v o k e st h e
image1Loaded() function, which in turn attaches a listener
function to the onclick event of button1 . The button may
be clicked by the user immediately after it is parsed, and
its listener function func() changes text in outputField to
’Well done!’ Thus, the expected event sequence is ev0:
parsing( image1 )→ev1: parsing( script1 )→ev2: pars-
ing(button1 )→ev3: ﬁring( image1 .onload) →ev4: parsing
(outputField )→ev5: ﬁring( button1 .onclick) .
However, depending on the network speed, load of the
computer, and timing of the user click, there may be other
execution sequences, some of which do not lead to the
expected display of ’Well done!’ . As shown in the partial
order of events in Fig. 3, there are four race conditions:
1)RC1 is(ev1,ev 3)over image1Loaded
a) event ev1:parsing( script1 )
b) event ev3:ﬁring( image1 .onload)
2)RC2 is(ev2,ev 3)over button1
a) event ev2:parsing( button1 )
b) event ev3:ﬁring( image1 .onload)
3)RC3 is(ev3,ev 5)over button1
a) event ev3:ﬁring( image1 .onload)
b) event ev5:ﬁring( button1 .onclick)
4)RC4 is(ev4,ev 5)over outputField
a) event ev4:parsing( outputField )
b) event ev5:ﬁring( button1 .onclick)
The ﬁrst race condition (RC1) is between the parsing of
HTML element script1 a n dt h eﬁ r i n go f image1 .onload . Typ-
ically, the parsing ﬁnishes ﬁrst, but if image1 is downloaded
before the parsing ﬁnishes, e.g., due to caching of the image
or slow parsing of other HTML elements preceding script1 ,
278
279
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:08 UTC from IEEE Xplore.  Restrictions apply. /g104/g400/g286/g396 /g17/g396/g381/g449/g400/g286/g396
/g87/g258/g396/g400/g286/g282/g855/g3/g349/g373/g258/g336/g286/g1005/g3
/g87/g258/g396/g400/g286/g282/g855/g3/g400/g272/g396/g349/g393/g410/g1005/g3
/g87/g258/g396/g400/g286/g282/g855/g3/g271/g437/g410/g410/g381/g374/g1005/g3
/g87/g258/g396/g400/g286/g282/g855/g3/g381/g437/g410/g393/g437/g410/g38/g349/g286/g367/g282/g69/g286/g410/g449/g381/g396/g364
/g24/g381/g449/g374/g367/g381/g258/g282/g855/g3/g349/g373/g258/g336/g286/g1005/g856/g361/g393/g336/g3
/g38/g349/g374/g349/g400/g346/g286/g282/g855/g3/g349/g373/g258/g336/g286/g1005/g856/g361/g393/g336/g3/g349/g373/g258/g336/g286/g1005/g856/g381/g374/g367/g381/g258/g282
/g17/g437/g410/g410/g381/g374/g1005/g3/g396/g286/g258/g282/g455/g3/g410/g381/g3/g272/g367/g349/g272/g364/g3
/g104/g400/g286/g396/g3/g272/g367/g349/g272/g364/g286/g282/g3/g271/g437/g410/g410/g381/g374/g1005 /g271/g437/g410/g410/g381/g374/g1005/g856/g381/g374/g272/g367/g349/g272/g364/g286/g1004
/g286/g1005
/g286/g1006/g286/g1007
/g286/g1008/g286/g1009
Fig. 3. Partial order graph of the racing events of the example in Fig. 2.
image1Loaded will be undeﬁned when the browser invokes it
through image1 .onload .
The second race condition (RC2) is between the parsing of
button1 and the ﬁring of image1 .onload . Here, we assume
the unwanted situation regarding RC1 did not occur ( ev1
precedes ev3and image1Loaded is properly deﬁned). In this
case, it is still possible for image1 .onload to happen before the
parsing of button1 , thereby causing document.getElementById
(“button1”) at Line 8 to fail.
The third race condition (RC3) is between image1 .onload
and button1 .onclick . Here, we again assume the unwanted
situations regarding RC1 and RC2 did not occur ( ev1andev2
precedeev3). However, it is possible for button1 to be clicked
before the ﬁring of image1 .onload .S i n c e func() has not yet
been attached to button1 .onclick , clicking the button will not
lead to the desired behavior.
The fourth race condition (RC4) is between the pars-
ing of HTML element outputField a n dt h eﬁ r i n go f
button1 .onclick . Here, we again assume that none of the
unwanted situations regarding RC1, RC2, and RC3 occurred.
However, it is possible for button1 to be clicked and yet the
’Well done!’ message is not displayed. This occurs when the
button is clicked before the parsing of outputField , causing
document.getElementById (“outputField”) at Line 11 to fail.
The example in Fig. 2 and Fig. 3 shows that race conditions
in web applications are tricky: Developers may have to spend
long hours weeding out the bogus warnings, if the race
detection tools report too many false positives to them. Our
work aims to lift this burden from developers, thus allowing
them to focus on diagnosing the truly harmful race conditions.
B. Harmful Race Conditions
We leverage deterministic replay and state comparison to
identify harmful races. Let (eva,ev b)be a potential race condi-
tion (e.g., reported by E VENT RACER ). We perform controlled
executions of the application twice, ﬁrst with evabeforeevb,
and then with evaafterevb. If any of these executions is
infeasible, the replay fails, indicating that it is a bogus warning.
Otherwise, we record the program states at the end of the two
executions and compare them.
Consider RC1 in Fig. 2. First, we execute the application
while forcing ev1beforeev3, which leads to the expected event
sequence. Then, we execute the application while forcing ev3
1<input id ="input_1" type ="text" value ="Name"
onfocus ="clearText(this)" >
2<input id ="input_2" type ="text" value ="Email"
onfocus ="clearText(this)" >
3<script id ="script2" src="nyl-min.js" > ... </ script >
4<script id ="script1" >
5<!-- adding async script "utag.js" to DOM -- >
6</script >
7...
8<!-- nyl-min.js -- >
9function clearText(a){
10 if(a.defaultValue==a.value) {a.value= ""}}
11...
12<!-- utag.js -- >
13function c() {
14 if(!done) { done = true; ... } }
15document.addEventListener( "DOMContentLoaded" ,c,false);
16window.addEventListener( "load" , c, false);
Fig. 4. Race conditions that we detected from www.newyorklife.com .
beforeev1. Both executions are feasible, and the second exe-
cution invokes image1Loaded before it is deﬁned, causing the
browser to print an error message in the console window. The
event handler for button1 .onclick also remains uninitialized,
subsequently causing a difference in outputField . Therefore,
we say that RC1 is a harmful race, meaning that it deserves
the attention of the developers.
However, not all real race conditions are harmful.
Among the three race conditions in Fig. 4, which were
detected by RC LASSIFY from www.newyorklife.com ,t h e
one between parsing of utag.js and ﬁring of docu-
ment.onDOMContentLoaded is harmless, while the two races
over input_1 and input_2 are harmful. The ﬁrst race
is harmless because although the event handler of docu-
ment.onDOMContentLoaded may be registered (by utag.js )
after the browser ﬁres the document.onDOMContentLoaded
event, the same callback function c() is also registered to
window.onload as a precaution. Since window.onload always
execute after the load of utag.js , it ensures that c()is executed,
thereby resulting in the same program state.
However, the two races over input_1 and input_2 are
harmful because they initially show the hint values ’Name’ and
’Email’ to the user, but their onfocus event handlers, which
call clearText() , will empty these hint values as soon as
the user tries to type into the text areas. Unfortunately, the
script that deﬁnes clearText() m a yb ep a r s e da f t e rt h eu s e r
typed something into the two ﬁelds – assume ’USERTYPED’ is
what the user typed. This can lead to unwanted text contents
such as ’NamUSERTYPEDe’ or’NameUSERTYPED’ instead of just
’USERTYPED’ .O u r evidence-based method can correctly iden-
tify these two races as harmful, since they led to signiﬁcant dif-
ferences in the program states. In contrast, E VENT RACER [22]
reported all three races to the user, whereas Mutlu et al. [18]
could not detect any of them.
III. P RELIMINARIES
A. Web Applications
A modern HTML page consists of a set of elements, each
with opening/closing tags and the content in between, e.g.,
<p>...</p> for a paragraph. In addition, elements may be
added dynamically by executing JavaScript code. The docu-
ment object model (DOM) is a tree representation of the web
page to be rendered by the browser. Each DOM node has
279
280
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:08 UTC from IEEE Xplore.  Restrictions apply. attributes for holding meta-data, e.g., the <img> element has
thesrcattribute indicating the URL of the image. JavaScript
may be embedded in the HTML ﬁle or declared externally,
e.g., <script src="code.js"> </script> ; by default, they
are synchronous and therefore must be parsed before the
browser can move to the next HTML element. However,
external scripts with the ”defer” attribute will run after all
static HTML elements are parse d, whereas ”async” scripts may
run at any time after they are downloaded.
Web applications follow an event-driven execution model,
where various handlers are registered to events of DOM nodes
to react to the user and the environment. An event may be
propagated through the DOM tree through ”capturing” and
”bubbling”. For example, if a button is clicked, the onclick
event will be ﬁred not only for this button but also for DOM
nodes that recursively contain this button. The propagation is
performed level by level, all the way up to the window object.
Any onclick event handler registered to DOM nodes along this
chain of propagation will also be ﬁred.
The execution trace of a web application is a sequence of
events, denoted ρ=ev1,...,ev n. Each event is of the form
ev=/angbracketleftid,type,info,mem/angbracketright,w h e r eidis the element ID, type
is the event type, info stores additional information of the
DOM node, and mem stores information of shared memory
access. We consider ﬁve event types:
•parse (element ), which represents the parsing of an el-
ement. Static elem ents are parsed sequentially following
the order in which they are declared in the HTML.
•execute (js), which represents the e xecution of an embed-
ded, deferred, or asynchronous JavaScript code block.
•ﬁre(ev
cb), which represents the execution of a callback
function ev
cbin response of an event, such as the
onclick event of a button.
•ﬁre(tm
cb), which represents the execution of a callback
function tm
cbin response of a timer, registered using
either setInterval() orsetTimeOut() .
•ﬁre(ajax
 cb), which represents the execution of a call-
back function ajax
 cbin response to an Ajax request.
LetPS be the set of program states. Each state ps=
/angbracketleftDOM,JS,Env,Console/angbracketrightis a memory snapshot, where
DOM is the DOM content, JSis a valuation of JavaScript
variables, Env is a valuation of the browser’s environment
variables, and Console denotes console messages. An execu-
tion is a sequence λ=ps0ev1− − →ps1ev2− − →ps2...evn− − →psn,
whereps1,...,ps n∈PS are program states, ev1,...,ev n
are events, and for each 1≤i<n ,w eh a v e psi−1evi− − →psi.
B. Race Conditions
Since the web browser ensures that each JavaScript-based
event handler function is execute d atomically, it is impossible
for individual JavaScript statements to interleave. Thus, web
applications do not have data-races in the traditional sense
(unlike multithreaded Java or C++ programs). However, there
are still race conditions at higher levels. For example, a web
application may consider fast rendering of visual elements as a
priority, while asynchronously loading images and JavaScript
libraries. In such cases, event handlers of the visual elements
may be made available to users long before the corresponding
JavaScript functions are deﬁned.Before formally deﬁning race conditions, we deﬁne the
must-happens-before relation →mhb, which is a binary relation
over events. We say (eva,ev b)∈→ mhb if and only if eva
precedes evbin all possible executions of the web application.
Ifevaprecedes evbonly in a particular execution, we say
eva≺evbin this execution. Let WR(ev)be the set of memory
locations written by ev,a n d RD(ev)be the set of memory
locations read by ev. A race condition is deﬁned as a pair
(eva,ev b)of events such that
1)(eva,ev b)/negationslash∈→ mhb,(evb,ev a)/negationslash∈→ mhb,a n d
2)∃var such that var∈WR(eva)∩WR(evb)orvar∈
WR(eva)∩RD(evb)orvar∈RD(eva)∩WR(evb).
However, (eva,ev b)may not be considered harmful if it does
not affect the program behavior [1]. Thus, we say a race
condition is harmful only if there exist two executions λ1and
λ2such that (1) eva≺evbinλ1,( 2 )evb≺evainλ2,a n d
(3) the two resulting program states ps1andps2are different.
IV . T HEALGORITHM OF RCLASSIFY
RCLASSIFY takes the URL of the web application and
a set of race-condition warnings as input, and returns the
classiﬁcation results as output (Fig. 1). It ﬁrst removes the
bogus races, where at least one of the two executions is shown
to be infeasible. Next, it removes the real but harmless races,
where the two executions do not result in differences in the
program states. In both steps, we need to deterministically
replay the web application.
Toward this end, we ﬁrst download the application following
the URL and then instrument the HTML ﬁles to add self-
logging capabilitie s. We want to record information of the
racing events during race detection, so we can identify and
control these events during deterministic replay. In this work,
we used E VENT RACER [22] to generate race-condition warn-
ings (input of RC LASSIFY ), although other race detection tools
m a yb eu s e da sw e l l .
Next, we classify these warnings using replay and state
comparison. For each pair (eva,ev b)of racing events, we ﬁrst
executeevabeforeevb(denoteλ1) and then execute evbbefore
eva(denoted λ2). In both executions, we ﬁx the order of other
events as much as possible.
If both executions are feasible, we call (eva,ev b)a real race
condition, and record the global states at the end. Let ps1and
ps2be the two states resulting from λ1andλ2, respectively.
We say (eva,ev b)is a harmful race if there are signiﬁcant
differences in ps1andps2.
In the remainder of this section, we explain how to in-
strument the web application a nd analyze the race-condition
warnings to prepare for the subsequent deterministic replay. In
Sections V and VI, we will explain how to control the event
order and record/compare program states.
A. Instrumenting the HTML Files
One input of RC LASSIFY is the URL of the target web
application, consisting of the HTML ﬁles and other resource
ﬁles, such as Cascading Style Sh eets (CSS), JavaScript code,
images, audio, and video. After fe tching these ﬁles, we instru-
ment them before using them as input of the race detection
tool (E VENT RACER ); it allows us to generate information of
the racing events for deterministic replay.
280
281
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:08 UTC from IEEE Xplore.  Restrictions apply. 1<html >
2<head >
3 <script src ="Pre_RClassify.js" ></script >
4 <!-- start of head elements -- >
5 ...
6</head >
7<body >
8 ...
9 <!-- end of body elements -- >
10 <script > window.addEventListener( "load" ,
RC_fire_handlers, false); </ script >
11 </body >
12</html >
Fig. 5. Example: Instrumented web page prior to race detection.
We use an open-source HTML parser called J SOUP
(http://jsoup.org/). We generate a unique idattribute for each
HTML element, to help pinpoint the HTML element involved
in the racing event at run time and therefore control its
execution order during replay. We also insert our own library
code Pre_RClassify.js ,t ot h eH T M L head element. This
library code block will be executed before the browser loads
the body of the web page, thereby allowing us to track the
execution of all racing events.
Our instrumentation is designed to collect information about
the race-condition warnings. Fig. 5 shows an example, where
Lines 3 and 10 are added during our instrumentation. They
execute Pre_RClassify.js at the start of the head element,
to redeﬁne API functions such as addEventListener() and
setTimeOut() so we can intercept these function calls at run
time. Speciﬁcally, we replace them with wrapper functions,
which invoke the original APIs but also gather information of
the racing events for later phases of our algorithm.
We also insert a window.onload event handler at the end
of the HTML body element, to be ﬁred after the page is
fully loaded. Our function RC
 ﬁre
 handlers() goes through
all registered event handlers that require user actions, and
ﬁres them one by one, to simulate user interactions. By
automatically dispatching these event handlers, as opposed to
relying on clicks from the user [21], we have improved the
coverage compared to existing race detectors.
B. Analyzing Race-condition Warnings
Another input of RC LASSIFY is the set of race-condition
warnings. In our work, the race detector is E VENT RACER ,
which uses a modiﬁed version of W EBKITto generate a trace
log while loading the web page. Then, it analyzes the trace log
to build a happens-before model to capture global resources
that have conﬂicting accesses. Two accesses are conﬂicting
if they refer to the same memory location and at least one of
them is a write operation. However, the happens-before model
in E VENT RACER is not precise enough to separate harmful
races from bogus/harmless ones [22]. Our work focuses on
precisely classifying these race-condition warnings.
Toward this end, we statically analyze the warnings to
compute the information required by deterministic replay. We
use JS OUP to create two instrumented versions of the web
application. In one version, the self-control capability ensures
eva≺evb; in the other version, it ensures evb≺eva.T o
prevent interference from other pairs of racing events, we force
all other racing events to maintain their original execution
order instead of allowing them to interleave freely.
1<html >
2<head >
3 <!-- load replay info of all races here ... -- >
4 <script src ="RClassify.js" ></script >
5 ...
6</head >
7<body >
8 ...
9 <!-- end of the element m -- >
10 <script > RC_detect_handler_changes(); </ script >
11 ...
12 <!-- end of all body elements -- >
13 <script > window.addEventListener( "load" ,
RC_dump_state, false); </ script >
14</body >
15</html >
Fig. 6. Example: Instrumented web page prior to deterministic replay.
For example, given two warnings RC 1(eva,ev b)
andRC 2(evc,ev a), the ﬁrst execution may be
λ1=ps0...ps ievc− − →...ps jeva− − →...ps kevb− − →...ps nwhere
eva≺evb. To classify RC 1, we obtain the second execution
λ2=ps0...ps ievc− − →...ps jevb− − →...ps/prime
keva− − →...ps/prime
n,w h e r e
evb≺eva. In both executions, we try to maintain the order
evc≺evaforRC 2.
Fig. 6 shows an example of the instrumented HTML
ﬁle. Similar to Fig. 5, it loads another of our libraries,
RClassify.js ,a tt h es t a r to ft h e head element, as well
as information of the racing events. This library contains
functions to control the execution order of racing events and
record the program state. We also insert a JavaScript code
snippet to invoke the function RC
 detect
 handler
 changes()
after the parsing of every HTML element (Line 10). It checks
if the list of event handlers attached to any element of the
DOM has changed. If new handlers have been added, we
retrieve and instrument them so as to track their executions
at run time.
When loading the racing events (Line 3), if evaneeds to
be executed before evb, we putevainto the toWaitList [evb].
During replay, we monitor all racing events dynamically and
forceevbto wait for all events in toWaitList [evb]before
executing evb. For multiple warnings, however, it is not always
possible to maintain the execu tion order of all other racing
events while ﬂipping the race c ondition under investigation.
This is because reversing the order of a race condition may
invalidate the order of other race conditions. For example,
considerRC 1(eva,ev c),RC 2(eva,ev b)andRC 3(evb,ev c)in
an execution where eva≺evb≺evc. When reversing RC 1,
maintaining the original order of RC 2andRC 3becomes
impossible.
In such cases, we try to maintain the order of as many of
the other races as possible. That is, after loading the ordering
information of the reversed RC 1and the original RC 2,w e
discover that they conﬂict with the original order of RC 3.
Therefore, we ignore RC 3and obtain an execution where
evc≺eva≺evb.
When the must-happens-before relation among race condi-
tions are available, we use it to further reﬁne the execution
order information needed for replay. For example, if there is
a must-happens-before relation eva→mhbevb, we know the
order of evaandevbcannot be ﬂipped. Although analyzing
RC 1orRC 2alone would not detect any conﬂict, when
281
282
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:08 UTC from IEEE Xplore.  Restrictions apply. reversing RC 1, we know that it is no longer possible to
maintain both RC 2andRC 3. Therefore, we ignore RC 2and
obtain an execution where evc≺eva≺evb.
We also insert a window.onload handler at the end (Line 13).
The function RC_dump_state saves all relevant ﬁelds of the
global state into a disk ﬁle. After recording the two program
states, we compare them to decide if the race is harmful. We
say(eva,ev b)is harmful if the two states are signiﬁcantly
different. Toward this end, an important problem is to identify
ﬁelds that may be affected by sources of nondeterminism other
than race conditions; failure to do so will lead to harmless
races to be incorrectly classiﬁed as harmful races.
In the next sections, we explain in detail how to accurately
control the order of racing events during replay and how to
compare relevant ﬁelds of the program states.
V. C ONTROLLED EXECUTIONS
To replay the racing events, we need to intercept them and
control their execution order at run time.
A. Intercepting the Callback Functions
We want to intercept the registration, invocation, and re-
moval of callback functions for all global events, timers, and
AJAX requests. We replace each callback function with a
wrapper that, prior to invoking the original function, checks if
the invocation should be postponed.
Broadly speaking, there are two types of callback functions
for handling events. Type 1 handlers are installed by setting
a DOM element’s attribute such as el.onload and el.onclick .
Type 2 handlers, in contrast, are added and removed by calling
addEventListener() and removeEventListener() , respectively.
Each element may have multiple Type 2 handlers, stored in the
browser as opposed to the DOM itself; as such, these handlers
cannot be accessed by traversing the DOM tree. Third-party
libraries such as JQUERY may deﬁne their own APIs, such as
jQuery.bind() and jQuery.detach() , for managing event han-
dlers. But internally they still rely on the two aforementioned
mechanisms.
The addition and removal of Type 1 event handlers (via
attributes such as el.onclick ) are difﬁcult to intercept at run
time, since it is possible for the parsing of any HTML element
(e.g., script elements) to add or remove event handlers. In
RCLASSIFY , we do not modify the underlying web browser
or intercept the execution of each individual JavaScript in-
struction. Instead, our instru mentation is performed at the
HTML ﬁle level. To solve this problem, we developed a uniﬁed
framework for detecting changes to event handlers, which
periodically scans the DOM and compares it with a copy of
the DOM recorded during the previous scan. If there is any
change in the DOM element’s Type 1 event handler, e.g., the
addition or modiﬁcation of el.onclick , we will detect it.
In Fig. 6, for example, the scan is implemented using
JavaScript in RC_detect_handler_changes() . By statically
instrumenting the HTML ﬁle, at run time we can invoke this
function right after the parsing of each HTML element or
the execution of each callback f unction that may modify the
DOM. To reduce the runtime overhead, we statically analyze
the HTML elements to invoke this function only if needed,
e.g., after the parsing of JavaScript code, embedded HTML,
and other elements whose event handlers contain racing events.
Algorithm 1 Scanning and instrumenting event handlers.
1:RC_detect_handler_changes (){
2: for each (el∈document.all
 elements ) {
3: for each (eh
type∈all
event
 handler
 types ){
4: if(el[eh
type ]has changed ) {
5: event
 str=compose_es (el.id, eh
 type );
6: orig
 func =el[eh
type ];
7: if(is_racing_event (event
 str))
8: el[eh
type ]=Replace_callback (event
 str,orig
 func );
9: }
10: }
11:}
12:}
Algorithm 2 Controlling execution of callback functions.
1:Replace_callback (event
 str,orig
 func ){
2: function RC
 func (){
3: if(orig
 func is deﬁned )
4: if(¬racing_event_finished_waiting (event
 str ))
5: postponedEvent .push ( RC
 func );
6: else
7: orig
 func .call ( arguments );
8:}
9: return RC
 func ;
10:}
The pseudocode is shown in Algorithm 1, which ﬁrst scans
the DOM to identify any change of el[eh
 type] , corresponding
to the event el.eh
 type, and then instruments the handler:
var orig
 func = el.onclick; el.onclick = Replace_callback
(event
 str , orig
 func){generate and return RC
 func; ...},
where RC
 func is a dynamically generated instance of
orig
 func. In addition to controlling the execution order,
RC
 func also invokes the original function orig
 func.I n t e r -
nally, Replace_callback() creates the wrapper RC
 func using
event
 strand orig
 func, and uses it to replace the original
function.
Type 2 event handlers are intercept by replacing addE-
ventListener() and removeEventListener() with wrapper func-
tions while loading RClassify.js in the HTML head ele-
ment. Internally, the procedure executes var orig_addEL =
addEventListener; addEventListener = function new_addEL ()
{orig_addEL ();...}Therefore, at runtime, instead of invoking
the original function, it would invoke new_addEL() . Instead of
adding orig
 func as an event handler, new_addEl() dynami-
cally creates a wrapper function RC
 func as the event handler.
B. Controlling the Execution Order
After a callback function is replaced with its wrapper
function, the execution order can be controlled with respect to
other racing events. Speciﬁcally, the callback is instrumented
according to Algorithm 2, where orig
 func() is replaced by
a dynamically generated instance of RC
 func() . We control
the event execution order by conditionally postponing the
corresponding callback functions. When a racing event is
about to be dispatched, instead of executing the original
function directly, we call the function RC
 func, which in turn
checks if the corresponding orig
 func is ready to execute. Each
eventevhas a precomputed set of events ( toWaitList [ev])
that need to be executed before ev. If an event needs to be
postponed, the function RC
 func will be put into the waiting
list. The list is checked periodically to ensure that callbacks
are executed immediately after they are ready.
To ensure that replay does not deadlock, we use a counter
inside each RC
 func to record the number of times it has been
282
283
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:08 UTC from IEEE Xplore.  Restrictions apply. postponed (not shown in Algorithm 2 for brevity). When the
counter reaches a certain threshold, say 200, we assume that it
has waited too long and thus declare that replay failed. After
that, it will stop waiting and enter a free run.
The reason why replay may fail is because some racing
events simply cannot be ﬂipped (e.g., bogus race). In this
sense, our method can robustly handle bogus races. However,
it is not the most efﬁcient way to detect bogus races, since
waiting for replay to fail consumes a signiﬁcant amount of
time. Therefore, we also deve loped a cheaper mechanism for
identifying certain bogus races common in web applications.
Recall that bogus races are largely due to limitations of
race detectors in modeling happen-before relationships. Cer-
tain event handlers, such as document.onDOMContentLoaded
and window.onload , have somewhat ﬁxed execution time:
they are ﬁred either after the entire HTML is parsed, or
after all resources are loaded. Therefore, if a reported race
is between the parsing of an HTML element and docu-
ment.onDOMContentLoaded orwindow.onload , we know for
sure that it is a bogus race. In such case, we can skip replay
because replay is guaranteed to fail.
VI. P ROGRAM STATE COMPARISON
We record the program states after both controlled execu-
tions and then compare their ﬁelds.
A. State Recording
After the web page is fully loaded, we serialize the program
state and store the result in a disk ﬁle. We initiate state
recording when the following two conditions are met: (1) the
web page is fully loaded, and (2) a ll racing events have ﬁnished
executing. We consider the following ﬁelds as parts of the
program state:
1)The DOM : We record the value of all HTML elements,
their attributes, and Type 1 event handlers. We also
intercept all Type 2 event handlers and store them in
a special DOM attribute.
2)JavaScript variables : We record the value of all
JavaScript global variables since they affect the behavior
of the application.
3)Environment variables : We record the value of environ-
ment variables associated with the browser, such as the
height and width of the window.
4)Console messages : We record runtime information dis-
played in console.log ,console.warn and console.error .
They are invisible to end-users but useful to developers.
All JavaScript functions and v ariables used to implement
RCLASSIFY are deﬁned in a speciﬁc name space and thus
can be excluded from the program state easily.
To serialize the data ﬁelds into a string, thus allowing
them to be compared easily, we use the JSON.stringify()
API. However, JSON does not directly handle data with
cyclic dependency, which are common in web applications.
To solve this problem, we imp lemented a JavaScript method
that traverses the DOM object in the BFS order and marks
each visited node with a unique identiﬁer. If it encounters a
visited object again, it replaces the reference to that object
with its unique identiﬁer. Since the resulting representation is
guaranteed to be acyclic, it can be serialized to a string using
JSON.stringify() .B. State Comparison
To compare two program states, we ﬁrst use JSON.parse
to restore the data ﬁelds from disk ﬁles and construct two
key-value tables. For the DOM, we use the element’s id
attribute as the key (the unique idgenerated by our HTML
instrumentation) and the HTML content as the value. For
JavaScript variables and environment variables, we use the
variable name as the key. For console messages, we use their
order in the console as the key. We say the race condition
isharmless if the two states are identical. We say the race
condition is harmful if they differ in the DOM or JavaScript
global variables. If they differ only in console logs or the value
of some environment variables, we assume the race condition
is likely harmless but we still report it as a warning.
Sometimes, certain ﬁelds of the DOM or JavaScript vari-
ables may have nondeterministic values due to reasons other
than race conditions. For example, an application may record
the last time it is executed or create a session ID that is
different every time it is executed. To exclude such ﬁelds in
state comparison – since they may lead to false positives –
we developed a mechanism for users to specify which ﬁelds
should be excluded. We also developed a heuristic method for
ﬁltering out such irrelevant ﬁelds automatically.
Our solution is to execute the web application three times,
with the following event orders: eva≺evb,eva≺evb,a n d
evb≺eva. After that, we use a three-way comparison to check
the state differences. If there exists a ﬁeld that has different
values in all three states, then we consider it as an irrelevant
ﬁeld. If a ﬁeld has the same value in the ﬁrst two states, but
a different value in the third state, then we consider it as a
relevant ﬁeld.
VII. E XPERIMENTS
We have implemented our evidence-based classiﬁcation
method in a software tool (RC LASSIFY ), which builds upon a
number of open-source software. Our libraries for monitoring
and controlling racing events is written in 2.1K lines of
JavaScript code. Our front-end for HTML instrumentation is
implemented using Jsoup 1.8.1 in 2.4K lines of Java code.
We leverage E VENT RACER to generate the race-condition
warnings (our input). During the experiments, we store bench-
marks under test in a local web server. We use Teleport Ultra
1.69 to download the source ﬁles of real websites before
instrumenting them. We use Mozila Firefox as the web browser
– we experimented with versions ranging from 35.0 to 47.0
and did not encounter any incompatibility issue.
Our benchmarks fall into two groups. The ﬁrst group
consists of standard web appli cation benchmarks from recent
publications such as E VENT RACER [21], [22] and W AV E [7].
Since they are written speciﬁcally for illustrating various
types of race conditions, most of them have known-to-be-
harmful races, and our goal is to conﬁrm that RC LASSIFY
can correctly identify them. The second group consists of
seventy real websites randomly chosen from the portals of
the Fortune-500 companies. Previously, E VENT RACER was
applied to the same type of websites and reported many bogus
warnings. Therefore, our goal is to see if RC LASSIFY can do
better than state-of-the-art techniques, which include not only
EVENT RACER [22], but also Mutlu et al. [18] and R4 [9].
283
284
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:08 UTC from IEEE Xplore.  Restrictions apply. That is, can RC LASSIFY accurately classify these warnings
while maintaining a low runtime cost? Our experiments were
conducted on a machine with Intel Core i7-4700 2.4 GHz CPU
and 4 GB RAM running 64-bit Ubuntu.
A. Results on Standard Benchmarks
Table I shows our results on the standard benchmarks.
Columns 1-2 show the benchmark name and number of
race-condition warnings (input of RC LASSIFY ). Column 3
shows the number of bogus races that RC LASSIFY identiﬁed.
Columns 4-8 show the number of harmful races, harmless
races, and undetermined cases (Undet), respectively. Column 9
shows the total time taken by RC LASSIFY . Note that some
warnings cannot be generated by the race detector E VEN-
TRACER due to its own limitations; for these warnings, we
manually created them and gave them to RC LASSIFY .W e
checked all 50 input warnings manually and conﬁrmed that
RCLASSIFY produced the correct classiﬁcation.
Speciﬁcally, the 13 harmless races fall into three groups:
none means there are no differences in the program states;
con. means there are differences in console logs only; and
b/c/t means the differences are due to event “bubbling” and
“capturing” or a “timer-try” pattern. Event bubbling and
capturing (b/c) lead to duplicated events on the upper-level
elements. For example, if a windows has 100 buttons, each
of the 100 button.onclick events can be bubbled up to trigger
document.onclick . In such case, there will be 100 races re-
ported on document.onclick . Timer-try (t) is when a function
repeatedly postpones its execution via setTimeout() until some
condition is satisﬁed. The nature of these races means they
are likely harmless.
We also downloaded and applied the tools from Mutlu et
al. [18] and Jessen et al. [9] (R4). Mutlu et al. [18] was
designed to report only harmful races, but it reported 0 races
despite that 33 of the 50 races were known-to-be-harmful.
R4 [9] focuses on applying stateless model checking to web
applications to systematically explore the event interleavings,
but also can ﬁlter race-condition warnings. Our experiments
showed that
•R4 detected only 21 race conditions, among which it
classiﬁed 8 as harmful (H), 1 as normal-risk (N), and
12 as low-risk (L).
•Our manual inspection showed that, whereas the 8 races
marked as harmful (H) by R4 are indeed harmful, 3 of
the other 13 races (which were not marked as harmful by
R4) are also harmful.
Altogether, R4 reported only 8 (out of the 33) harmful races
while missing the other 25.
B. Results on Real Websites
Table II shows the results of our experiments on real
websites. Since going through all web portals of the Fortune-
500 companies takes too much time, we randomly selected
seventy companies and applied E VENT RACER to generate the
initial set of race-condition warnings. Among them, twenty
websites do not have any E VENT RACER -reported warnings;
for the remaining ﬁfty websites, the results are shown in the
table. Columns 1-2 show the website name and the number
of E VENT RACER -reported warnings (input of RC LASSIFY ).TABLE I
EXPERIMENTAL RESULTS ON THE STANDARD BENCHMARKS .
Name
 Warning
 Bogus
 Harmful
 Harmless
 Undet.
 Time
 From[18]
 From[9]
(input)
 con. b/c/t none
 Harmful
 H/N/L
WebR
 ex1
 1
 0
 0
 10 0
 0
 23.8s
 0
 0/1/0
WebR
 ex2
 1
 0
 1
 00 0
 0
 23.8s
 0
 0/0/0
WebR
 ex3
 1
 0
 1
 00 0
 0
 23.8s
 0
 0/0/1
WebR
 ex4
 1
 0
 1
 00 0
 0
 23.8s
 0
 0/0/0
WebR
 ex5
 1
 0
 0
 10 0
 0
 24.1s
 0
 0/0/0
EventR
 ex1
 1
 0
 0
 10 0
 0
 23.8s
 0
 1/0/0
EventR
 ex2
 1
 0
 1
 00 0
 0
 23.8s
 0
 0/0/1
EventR
 tut
 3
 0
 3
 00 0
 0
 1m10s
 0
 0/0/0
kaist
 ex1
 1
 0
 0
 10 0
 0
 23.8s
 0
 0/0/1
kaist
 ex2
 1
 0
 0
 10 0
 0
 25.0s
 0
 1/0/0
kaist
 ex3
 3
 0
 1
 20 0
 0
 1m10s
 0
 1/0/0
kaist
 case1
 6
 0
 4
 11 0
 0
 2m20s
 0
 1/0/2
kaist
 case2
 3
 0
 3
 00 0
 0
 47.2s
 0
 1/0/1
kaist
 case3
 4
 1
 2
 10 0
 0
 1m35s
 0
 1/0/0
kaist
 case4
 7
 4
 3
 00 0
 0
 1m51s
 0
 0/0/3
kaist
 case5
 3
 0
 3
 00 0
 0
 1m11s
 0
 0/0/1
kaist
 case6
 3
 0
 2
 10 0
 0
 24.3s
 0
 1/0/0
kaist
 case7
 7
 0
 6
 10 0
 0
 2m50s
 0
 0/0/1
kaist
 case8
 2
 0
 2
 00 0
 0
 47.6s
 0
 1/0/1
Total
 50
 5
 33
 11 1 0
 0
 0
 8/1/12
1<script id ="script_1" >
2 function show() {
3 document.getElementById( "dw" ).style.display= "block" ;
4 }
5</script >
6<ai d ="href1" href ="javascript:show()" > link </ a>
7<div id ="dw" style ="display:none" >d w< / div>
Fig. 7. A harmful race condition RC LASSIFY identiﬁed but R4 [9] missed.
Columns 3-8 show the number of bogus races, harmful
races, harmless races, and undecided cases, respectively. Col-
umn 9 shows the total time taken by RC LASSIFY ). Finally,
Columns 10-12 show the results reported by R4.
While using E VENT RACER to generate the input warnings,
we found that some of the reported races do not make sense
since the racing events have empty read/write accesses (likely
due to defects in E VENT RACER ); therefore, we ﬁltered them
out before applying RC LASSIFY –they are labeled Undet. in
the table.
The results in Table II show that RC LASSIFY identiﬁed 132
harmful races out of 1,903 E VENT RACER reported warnings.
We manually inspected the state comparison results of these
races and conﬁrmed the correctne ss of all classiﬁcations. An
example of the harmful races identiﬁed by RC LASSIFY is
already shown in Fig. 4, which turns out to be a real bug
from www.newyorklife.com. In contrast, R4 identiﬁed only
33 harmful races. There are also six websites on which R4
crashed – they are marked as “(CRASH)” in the table.
A closer investigation shows that R4 relies on the severity
of error logs and exception logs to determine the risk level
of each race. Although R4 saves a picture screenshot after
each execution for the user’s reference, it does not record
the program state. Even if the developers manually compare
screenshots, it is not as accurate or informative as comparing
the program states. For example, in Fig. 7, R4 failed to identify
the harmful race (occurred when href1 is clicked before the
dwelement is parsed, thus causing show() to access a non-
existing element) but there is no visual difference. In contrast,
RCLASSIFY can detect the difference in program states and
thus identify it as a harmful race.
While reviewing the classiﬁcation results, we also noticed
that harmful race conditions from the same website were often
284
285
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:08 UTC from IEEE Xplore.  Restrictions apply. TABLE II
EXPERIMENTAL RESULTS ON REAL WEBSITES RANDOMLY CHOSEN FROM WEBPORTALS OF FORTUNE -500 C OMPANIES .
Name
 Warning
 Bogus
 Harmful
 Harmless
 Undet.
 Time
 Result of R4 [9]
(input of RC LASSIFY )
 console b/c/t none
 Harmful Normal Low
www.aa.com
 7
 0
 3
 30 1
 0
 5m30s
 27 2 4
www.adp.com
 2
 0
 1
 01 0
 0
 43.8s
 81 4 1 5
www.ally.com
 91
 0
 8
 71 0 8
 4
 67m48s
 01 1
www.altria.com
 13
 2
 3
 24 1
 1
 4m5s
 (CRASH)
www.amazon.com
 10
 6
 0
 03 0
 1
 0
 (CRASH)
www.arrow.com
 1
 1
 0
 00 0
 0
 0
 12 3
www.ashland.com
 6
 0
 0
 01 5
 0
 3m17s
 (CRASH)
www.autozone.com
 9
 4
 1
 02 0
 2
 41.6s
 34 2 0
www.ball.com
 2
 0
 0
 20 0
 0
 1m14s
 00 1
www.bd.com
 22
 2
 5
 15 0 0
 0
 11m16s
 11 1
www.biogen.com
 26
 1
 0
 60 4
 15
 7m40s
 (CRASH)
www.boeing.com
 4
 1
 0
 10 2
 0
 1m39s
 01 4
www.buckeye.com
 23
 1
 1
 40 1 6
 1
 12m53s
 03 3 5
www.campbellsoupcompany.com
 5
 3
 1
 10 0
 0
 1m16s
 00 3
www.coach.com
 95
 1
 13
 61 0 18
 2
 75m18s
 00 1
www.cognizant.com
 56
 2
 25
 26 2 0
 1
 73m37s
 01 2
www.disney.com
 1
 0
 0
 10 0
 0
 1m8s
 04 4
www.dollartree.com
 501
 0
 6
 14 238 243
 0
 235m31s
 08 5
www.freddiemac.com
 1
 1
 0
 00 0
 0
 0
 00 0
www.generalcable.com
 7
 1
 1
 40 1
 0
 3m32s
 00 1
www.heinz.com
 3
 1
 0
 20 0
 0
 1m22s
 00 1
www.honeywell.com
 1
 0
 1
 00 0
 0
 0m36s
 26 8
www.huntsman.com
 70
 2
 18
 00 4 5
 5
 21m18s
 00 0
www.l-3com.com
 404
 0
 0
 0 109 294
 1
 161m18s
 03 7
www.loews.com
 4
 3
 1
 00 0
 0
 37.6s
 14 0
www.marathonoil.com
 1
 0
 0
 00 1
 0
 30.3s
 02 2
www.mcdonalds.com
 4
 1
 2
 10 0
 0
 5m58s
 20 5
www.newyorklife.com
 18
 13
 2
 11 0
 1
 1m49s
 22 1 6
www.nov.com
 5
 1
 0
 13 0
 0
 1m1s
 00 3 2
www.pge.com
 281
 0
 0
 13 99 169
 0
 126m30s
 00 2
www.regions.com
 14
 8
 0
 40 1
 1
 3m33s
 09 2
www.sandisk.com
 5
 2
 1
 10 1
 0
 1m42s
 21 6
www.simon.com
 1
 1
 0
 00 0
 0
 0
 01 0
www.sjm.com
 12
 0
 1
 53 3
 0
 4m59s
 10 2
www.starbucks.com
 8
 2
 1
 04 1
 0
 1m38s
 01 4
www.target.com
 9
 2
 0
 03 0
 4
 0
 12 6
www.tractorsupply.com
 7
 1
 0
 10 0
 5
 43.2s
 11 3
www.trw.com
 8
 0
 0
 03 5
 0
 2m48s
 04 3
www.tysonfoods.com
 1
 0
 0
 10 0
 0
 53.7s
 00 6
www.unﬁ.com
 13
 0
 3
 10 1
 8
 3m22s
 (CRASH)
www.unitedhealthgroup.com
 11
 1
 0
 73 0
 0
 4m10s
 30 2
www.unitedrentals.com
 7
 1
 1
 40 0
 1
 3m46s
 10 7
www.unum.com
 1
 0
 0
 10 0
 0
 31.5s
 (CRASH)
www.valero.com
 36
 2
 8
 12 3 2
 0
 6m41s
 15 1
www.wd.com
 2
 1
 0
 01 0
 0
 0
 10 1
www.wdc.com
 2
 1
 0
 01 0
 0
 0
 01 1
www.wesco.com
 5
 1
 3
 10 0
 0
 2m3s
 00 1
www.weyerhaeuser.com
 29
 0
 21
 80 0
 0
 14m45s
 00 0
www.wfscorp.com
 16
 1
 0
 80 6
 1
 7m33s
 02 1
www.yum.com
 43
 2
 1
 11 1 2 8
 0
 15m36s
 00 1
Total
 1,903
 73
 132
 273 515 856
 54
 33 90 240
correlated: ﬁxing one race (e.g., by adding a must-happen-
before constraint) also ﬁxes many of the other races.
The execution time of RC LASSIFY is largely determined
by how fast the browser loads the target web page, since we
need to wait for the page to be completely loaded before
recording the program state. In practice, it is common for
a website to have large resource ﬁles that take a signiﬁcant
amount of time to download. An example is www.coach.com,
which may take tens of seconds to load completely and thus
increase the total execution time of RC LASSIFY . In addition,
we inserted several sleep commands in our framework to
ensure a smooth connection between operations, e.g., between
the script for saving the state recording ﬁle and the script
for loading the next web page. During state comparison, we
also run the same web application three times, among which
two are in the original execution order while the third one
is with the racing events ﬂipped. For each individual replay,
we observed only a slowdown of 1.5-2X when compared to
a free run. Also note that we have not optimized the runtime
performance of our tool. Nevertheless, RC LASSIFY is fully
automated, and therefore is signiﬁcantly more efﬁcient than
manually classifying race-condition warnings.C. Compared to Heuristic Filtering
We also compared RC LASSIFY with E VENT RACER ’s
heuristic ﬁltering, which does not check the effect of racing
events, but instead relies on event types and a limited number
of bug patterns. As such, they may report false positives as
well as miss harmful races. More speciﬁcally, E VENT RACER
has two levels of ﬁltering. The ﬁrst-level ﬁltering aims at
removing benign races. The second-level ﬁltering aims at
identifying high-risk (harmful) races. We use the-rest to denote
left-over races after these two levels of ﬁltering.
Table III shows our experimental results. Of the 1,903
race-condition warnings, E VENT RACER ’s heuristic ﬁltering
identiﬁed 558 as high-risk (harmful), 372 as benign, and 973
as the-rest. In contrast, our method showed that only 38 of
the 558 high-risk (harmful) r aces are truly harmful, whereas
40 of the 372 benign races are harmful. In addition, 54 of
the 973 left-over races are also harmful. The results show that
heuristic ﬁltering techniques are not effective in practice.
Fig. 8 shows a harmful race condition detected by RC LAS-
SIFY from the ofﬁcial website of Honeywell International, but
considered by EventRacer ’s heuristic ﬁltering as benign (they
call it ﬁltered ). The race condition is between the parsing of
285
286
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:08 UTC from IEEE Xplore.  Restrictions apply. TABLE III
RCLASSIFY VERSUS EVENT RACER ’SHEURISTIC FILTERING [22].
Total
 EVENT RACER ’shigh-risk
 EVENT RACER ’sbenign
 EVENT RACER ’sthe-rest
1,903
 558
 372
 973
Harmful
 38(6.8%)
 40(10%)
 54(5.5%)
asynchronous script jsapi (eva) and the parsing of synchronous
script gssAutoComplete.js (evb). By executing these racing
events in different orders, RC LASSIFY detected differences in
many ﬁelds of the program states. Among them, one difference
is in the title ﬁeld of the web page: When evb≺eva,t h e
title is ”Honeywell - Global Technology Leader in Energy
Efﬁciency, Clean Energy Generation, Safety & Security, and
Globalization” ,b u tw h e n eva≺evb, the title is ”Home” .
1<!-- other elements -- >
2<script id ="script_4" >
3...
4var gjsapi = document.createElement(’script’);
5gjsapi.type = ’text/javascript’;
6gjsapi.src = (’https:’ == document.location.protocol
? ’https://’ : ’http://’) +
’www.google.com/jsapi’;
7var s = document.getElementsByTagName(’script’)[0];
8s.parentNode.insertBefore(gjsapi, s);
9...
10</script >
11<!-- other elements -- >
12<script type ="text/javascript" id="script_26"
src="http://honeywell.com/_layouts/
13InternetFramework/Scripts/gssAutoComplete.js" ></script >
14<!-- other elements -- >
Fig. 8. A harmful race condition ﬁltered out by E VENT RACER [22].
VIII. R ELATED WORK
There are several existing tools for detecting race conditions
in web applications, some of which are based on conservative
static analysis (e.g., Zheng et al. [33] and A RROW [32]) while
others are based on dynamic analysis [22], [21], [7]. Static
analysis has the advantage of covering all possible execution
paths of the JavaScript code, but due to the rich set of
dynamic features in JavaScript and client-side web applica-
tions in general [6], [10], [23], [28], [16], [29], they cannot
robustly handle real websites. Dynamic analysis tools such as
EVENT RACER [22], [21] and W AV E [7] do not have such
limitations. However, they have limited code coverage and
often report many bogus warnings as well as miss real bugs.
Furthermore, none of these existing methods uses evidence-
based techniques to classify race conditions.
Mutlu et al. [18] proposed a method for detecting race
conditions using a combination of dynamic and static analysis
techniques. They obtain an execution trace and then use
predictive static analysis to detect races that may occur in all
possible interleavings of events of the given trace. However,
their method does not use deterministic replay to check the
actual impact of racing events and therefore may still report
bogus and harmless races. Furthermore, their tool is limited
to detecting certain types of races over persistent storage and
may miss many other races, as shown in our experiments.
Jensen et al. [9] proposed a stateless model checking tool
(R4) for systematically exploring event interleavings in a web
application. Unlike tools such as E VENT RACER [22], [21],which detect races only in one trace, R4 can generate many
new traces from the given trace and detect races in these
traces. However, as shown in our experimental evaluation, R4
does not perform well in classifying the races: it missed many
harmful races and reported many false positives.
There are also software tool s for recording the state of a
running web application [17], [2], [5], but the goal is to allow
developers to revisit the recorded program state to diagnose
bugs, or dynamically migrate the web application to other
platforms [4], [15], [14]. Therefore, although they also address
the state recording problem, the applications are signiﬁcantly
different from ours: none of these prior works focuses on
diagnosing concurrency bugs.
For diagnosing data-races in multithreaded programs, there
is a large body of work [19], [25], [31], [26], [11], [24], [3],
[13], [12]. Speciﬁcally, Narayanasamy et al. [19] proposed
perhaps the ﬁrst deterministic replay-based method for clas-
sifying data-races in multithreaded applications. They used
a checkpointing tool to take snapshots of the main memory
while executing the program, and compared the snapshots to
decide if a data-race is harmful. Similar works also include
Sen’s race-directed testing tool [25] and the Portend tool by
Kasikci et al. [11]. There are also many testing tools such
as CTrigger [20], PENELOPE [27], Fusion [30], and RV-
Predict [8] for multithreaded programs.
However, data-races in multithreaded C/C++ or Java pro-
grams are signiﬁcantly different from race conditions in client-
side web applications. Speciﬁcally, the computing platforms
are signiﬁcantly different in that one relies on multi-threading
whereas the other relies on event-driven execution. The sup-
porting tools are also different. For multithreaded programs,
there already exist a large number of checkpointing tools,
but for web applications, we are not aware of any such
checkpointing tool. Due to these reasons, both deterministic
replay and program-state comparison require drastically dif-
ferent solutions. Therefore, except for the high-level similar-
ity, RC LASSIFY is completely different from these existing
methods and tools.
IX. C ONCLUSIONS
We have presented RC LASSIFY ,t h eﬁ r s t evidence-based
method for automatically cla ssifying race-condition warnings
in web applications. It identiﬁes the real and harmful races
based on executing the racing events in different orders and
then comparing the program states. We also developed a purely
JavaScript-based, platform-agnostic framework for monitoring
and controlling the execution order of racing events. We have
implemented RC LASSIFY and evaluated it on both standard
benchmarks and a large set of real websites. Our experimental
results show that the new method is both effective in identi-
fying harmful races and scalable for practical use. For future
work, we plan to leverage RC LASSIFY not only to diagnose
race conditions but to automatically repair them.
X. A CKNOWLEDGMENTS
This work was primarily supported by the National Sci-
ence Foundation (NSF) under the grants CCF-1149454, CCF-
1405697, and CCF-1615834. Partial support was provided by
the Ofﬁce of Naval Research (ONR) under the grant N00014-
13-1-0527.
286
287
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:08 UTC from IEEE Xplore.  Restrictions apply. REFERENCES
[1] Saba Alimadadi, Sheldon Sequeira, Ali Mesbah, and Karthik Pattabira-
man. Understanding JavaScript event-based interactions. In International
Conference on Software Engineering , pages 367–377, 2014.
[2] Silviu Andrica and George Candea. WaRR: A tool for high-ﬁdelity web
application record and replay. In IEEE/IFIP In ternational Conference
on Dependable Systems and Networks , pages 403–410, 2011.
[3] Mitra Tabaei Befrouei, Chao Wang, and Georg Weissenbacher. Abstrac-
tion and mining of traces to explain concurrency bugs. In International
Conference on Runtime Veriﬁcation , pages 162–177, 2014.
[4] Federico Bellucci, Giuseppe Ghiani, Fabio Patern` o, and Carmen Santoro.
Engineering JavaScript state pers istence of web applications migrating
across multiple devices. In ACM SIGCHI Symposium on Engineering
Interactive Computing System , pages 105–110, 2011.
[5] Brian Burg, Richard Bailey, Andrew J. Ko, and Michael D. Ernst.
Interactive record/replay for web application debugging. In ACM
Symposium on User Interface Software and Technology , pages 473–484,
2013.
[6] Salvatore Guarnieri and V . Benjamin Livshits. GATEKEEPER: mostly
static enforcement of security and r eliability policies for JavaScript code.
InUSENIX Security Symposium , pages 151–168, 2009.
[7] Shin Hong, Yongbae Park, and Moonzoo Kim. Detecting concurrency
errors in client-side java script web applications. In IEEE International
Conference on Software Testing, Veriﬁcation and Validation , pages 61–
70, 2014.
[8] Jeff Huang, Patrick O’Neil Mere dith, and Grigore Rosu. Maximal
sound predictive race detection with control ﬂow abstraction. In
ACM SIGPLAN Conference on Programming Language Design and
Implementation , pages 337–348, 2014.
[9] Casper Svenning Jensen, Anders Møller, Veselin Raychev, Dimitar
Dimitrov, and Martin T. Vechev. Stateless model checking of event-
driven applications. In ACM SIGPLAN Conference on Object Oriented
Programming, Systems, Languages, and Applications , pages 57–73,
2015.
[10] Simon Holm Jensen, Peter A. Jonsson, and Anders Møller. Remedying
t h eE v a lt h a tm e nd o .I n International Symposiu m on Software Testing
and Analysis , pages 34–44, 2012.
[11] Baris Kasikci, Cristian Zamﬁr, and George Candea. Data races vs.
data race bugs: Telling the difference with portend. In International
Conference on Architectural Support for Programming Languages and
Operating Systems , pages 185–198, 2012.
[12] Sepideh Khoshnood, Markus Kusano, and Chao Wang. C oncBugAssist:
Constraint solving for diagnosis an d repair of concurrency bugs. In
International Symposium on So ftware Testing and Analysis , 2015.
[13] Markus Kusano, Arijit Chattopadhyay, and Chao Wang. Dynamic in-
variant generation for concurrent programs. In International Conference
on Software Engineering , 2015.
[14] James Teng Kin Lo, Eric Wohlstadter, and Ali Mesbah. Imagen:
Runtime migration of browser sessions for javascript web applications.
InInternational World Wide Web Conference , pages 815–826, 2013.
[15] James Teng Kin Lo, Eric Wohlstadter, and Ali Mesbah. Live migration
of JavaScript web apps. In International World Wide Web Conference ,
pages 241–244, 2013.
[16] Magnus Madsen, Benjamin Livshits, and Michael Fanning. Practical
static analysis of JavaScript applications in the presence of frameworks
and libraries. In ACM SIGSOFT Symposium on Foundations of Software
Engineering , pages 499–509, 2013.
[17] James W. Mickens, Jeremy Elson, and Jon Howell. Mugshot: Deter-
ministic capture and replay for JavaScript applications. In USENIX
Symposium on Networked Systems Design and Implementation , pages
159–174, 2010.[18] Erdal Mutlu, Serdar Tasiran , and Benjamin Livshits. Detecting
JavaScript races that matter. In ACM SIGSOFT Symposium on Founda-
tions of Software Engineering , pages 381–392, 2015.
[19] Satish Narayanasamy, Zhenghao Wang, Jordan Tigani, Andrew Edwards,
and Brad Calder. Automatically classifying benign and harmful data
races using replay analysis. In ACM SIGPLAN Conference on Pro-
gramming Language Design and Implementation , pages 22–31, 2007.
[20] Soyeon Park, Shan Lu, and Y uanyuan Zhou. CTrigger: Exposing
atomicity violation bugs from their hiding places. In International
Conference on Architectural Support for Programming Languages and
Operating Systems , pages 25–36, 2009.
[21] Boris Petrov, Martin T. Vechev, Manu Sridharan, and Julian Dolby.
Race detection for web applications. In ACM SIGPLAN Conference on
Programming Language Design and Implementation , pages 251–262,
2012.
[22] Veselin Raychev, Martin T. Vechev, and Manu Sridharan. Effective race
detection for event-driven programs. In ACM SIGPLAN Conference on
Object Oriented Programming, Systems, Languages, and Applications ,
pages 151–166, 2013.
[23] Gregor Richards, Christian Hammer, Brian Burg, and Jan Vitek. The
eval that men do - A large-scale study of the use of eval in JavaScript
applications. In European Conference on Object-Oriented Programming ,
pages 52–78, 2011.
[24] Mahmoud Said, Chao Wang, Zijiang Yang, and Karem Sakallah. Gen-
erating data race witnesses by an SMT-based analysis. In NASA Formal
Methods , pages 313–327, 2011.
[25] Koushik Sen. Race directed random testing of concurrent programs. In
Proceedings of the ACM SIGPLAN 2008 Conference on Programming
Language Design and Implementation, Tucson, AZ, USA, June 7-13,
2008 , pages 11–21, 2008.
[26] Arnab Sinha, Sharad Malik, Chao Wang, and Aarti Gupta. Predictive
analysis for detecting serializability vi olations through trace segmenta-
tion. In International Conference on Formal Methods and Models for
Co-Design , pages 99–108, 2011.
[27] Francesco Sorrentino, Azadeh Fa rzan, and P. Madhusudan. PENELOPE:
Weaving threads to expose atomicity violations. In ACM SIGSOFT
Symposium on Foundations of Software Engineering , pages 37–46, 2010.
[28] Manu Sridharan, Julian Dolby, Satish Chandra, Max Sch¨ afer, and Frank
Tip. Correlation tracking for point s-to analysis of JavaScript. In
European Conference on Object-Oriented Programming , pages 435–
458, 2012.
[29] Chungha Sung, Markus Kusano, Nishant Sinha, and Chao Wang. Static
DOM event dependency analysis for testing web applications. In ACM
SIGSOFT Symposium on Foundations of Software Engineering , 2016.
[30] Chao Wang, Mahmoud Said, and Aarti Gupta. Coverage guided
systematic concurrency testing. In International Conference on Software
Engineering , pages 221–230, 2011.
[31] Chao Wang, Yu Yang, Aarti Gupta, and Ganesh Gopalakrishnan. Dy-
namic model checking with property driven pruning to detect race
conditions. In International Symposium on A utomated Technology for
Veriﬁcation and Analysis , pages 126–140, 2008.
[32] Weihang Wang, Yunhui Zheng, Peng Liu, Lei Xu, Xiangyu Zhang, and
Patrick Eugster. ARROW: Automated repair of races on client-side web
pages. In International Symposium on So ftware Testing and Analysis ,
2016.
[33] Yunhui Zheng, Tao Bao, and Xiangyu Zhang. Statically locating
web application bugs caused by asynchronous calls. In International
Conference on World Wide Web , pages 805–814, 2011.
287
288
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:08 UTC from IEEE Xplore.  Restrictions apply. 