Understanding Developers’ Needs on
Deprecation as a Language Feature
Anand Ashok Sawant
Delft University of Technology
Delft, The Netherlands
A.A.Sawant@tudelft .nlMaurício Aniche
Delft University of Technology
Delft, The Netherlands
m.f.aniche@tudelft .nl
Arie van Deursen
Delft University of Technology
Delft, The Netherlands
Arie .vanDeursen@tudelft .nlAlberto Bacchelli
University of Zurich
Zurich, Switzerland
bacchelli@ifi .uzh .ch
ABSTRACT
DeprecationisalanguagefeaturethatallowsAPIproducerstomark
afeatureasobsolete.Weaimtogainadeepunderstandingofthe
needsofAPIproducersandconsumersalikeregardingdeprecation.
To that end, we investigate why API producers deprecate features,
whether they remove deprecated features, how they expect con-
sumers to react, and what prompts an API consumer to react to
deprecation.Toachievethisgoalweconductsemi-structuredinter-
viewswith 17third-party JavaAPI producersand survey170 Java
developers. We observe that the current deprecation mechanism in
Java and the proposal to enhance it does not address all the needs
of a developer. This leads us to propose and evaluate three further
enhancements to the deprecation mechanism.
KEYWORDS
API, deprecation, Java
ACM Reference Format:
Anand Ashok Sawant, Maurício Aniche, Arie van Deursen, and Alberto
Bacchelli. 2018. Understanding Developers’ Needs on Deprecation as a
Language Feature. In Proceedings of ICSE ’18:40th International Conference
on Software Engineering (ICSE ’18). ACM, New York, NY, USA, 11 pages.
https://doi .org/10 .1145/3180155 .3180170
1 INTRODUCTION
Concerning deprecation, the official Java documentation states: “A
programelementannotated@Deprecatedisonethatprogrammers
arediscouragedfromusing,typicallybecauseitisdangerous,orbe-
cause a better alternative exists” [ 26]. The deprecation mechanism
is a commonly used practice [2].
Deprecation as a language feature has been adopted in many
languages, such as PHP and Java. However, there is no uniform
implementation or support of deprecation across languages. For
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
©2018 Copyright held by the owner/author(s). Publication rights licensed to the
Association for Computing Machinery.
ACM ISBN 978-1-4503-5638-1/18/05...$15.00
https://doi .org/10 .1145/3180155 .3180170example, Java exposes its deprecation mechanism as an annotation
captured by the compiler to throw a warning when a program
element marked as deprecated is invoked; in PHP deprecation is
added as a property to a function and throws a runtime warning.
Furthermore, languages have been changing the deprecation
mechanism in the search for improvements, as evidenced by the
Javalanguagedesigners’proposaltorevamptheJavadeprecation
mechanism for the third time [ 16]. According to the Java language
designers, the deprecation mechanism has been open to misuse
and the inconsistent removal of deprecated features creates con-
fusion surroundingthe fateof deprecatedfeatures. In theirwords,
this led to a situation where “everybody was confused about what
deprecation actually meant, and nobody took it seriously.”
Thisvariabilityindeprecationmechanismsacrosslanguagesand
volatility of implementations shows that deprecation as a whole is
anunsolvedproblem.Thereisnocurrentunderstandingastowhat
constitutes an effective deprecation mechanism. Currently, API
consumers do not appear to react to deprecation [ 24,29] despite
API producers taking great care in documenting the deprecation
and the changes involved [2].
Inthispaper,ourgoalistodeterminethecharacteristicsthata
deprecationmechanismshouldpossessandwhetherthesearede-
sirable amongst developers and feasible to implement, particularly
in a mainstream language such as Java. We do this conducting a
study set up in two phases: An exploratory investigation, followed
bytheevaluationofthedesirabilityandfeasibilityofenhancements
we propose to the deprecation mechanism.
In the first part of our study, we investigate why API producers
deprecate features, how they expect the API consumers to react,
whethertheyremovedeprecatedfeaturesfromtheirAPIs,andwhat
theassociatedchallengesarewithusingthedeprecationmechanism.
To that aim, we use an interpretive descriptive technique to conduct
and analyze interviews with 17 developers who work on APIsboth in industry and open source. We challenge our findings by
conducting a survey with 170 Java professionals.
With the insights gained from API producers and consumers
coupled with interface usability guidelines [ 19], in the second part
of this study, we propose enhancements to the deprecation mecha-
nism.Weevaluatethefeasibilityofthisproposalbydiscussingthem
with two Java language designers (one of whom is the promoter of
thecurrentrevampoftheexistingJavadeprecationmechanism)and
its desirability among the aforementioned 170 Java professionals.
5612018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:53:54 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden A. A. Sawant, M. F. Aniche, A. van Deursen, A. Bacchelli
2 THE DEPRECATION MECHANISM IN JAVA
Deprecationisprovidedbymostprogramminglanguages,asaway
for developers of APIs and libraries to avoid introducing breaking
changes when classes, fields, or methods are to be removed.
In the original documentation of deprecation, we read: “Dep-
recation is a reasonable choice in all these cases [where the API
is buggy, insecure, disappearing in a future release, or encourag-
ing bad coding] because it preserves backward compatibility while
encouraging developers to change to the new API” [26].
Javafirstintroducedthedeprecationmechanismintheformofa
Javadoc @deprecated annotation, which provides information on
whyafeaturewasdeprecatedandwhatreplacementfeatureshould
be used. Once source code annotations were introduced in Java
1.5,Javaintroduceda @Deprecated annotation.Accordingtothe
Javalanguagespecification,thisannotationgeneratesacompiler
warning when a deprecated feature is used in source code. Modern
IDEs pick up this warning and display the warning along with the
accompanying Javadoc (Figure 1).
Recently,therehasbeenaproposaltochangethedeprecation
mechanisminJava(JEP277[ 16]).StuartMarks(leadJavaandOpen-
JDKlanguagedesignerandpromoterofthechangesinthedepre-
cation mechanism) stated that deprecation warnings are largely
ignored by API consumers [ 17]. Marks attributed this behavior to
two main reasons (which he captured by observing the behavior of
consumers who use the Java SE API):
(1)Potential misuse: The current implementation of the dep-
recationmechanismisopentopotentialmisuse:“the@Dep-recatedannotationendedupbeingusedforseveraldifferent
purposes” [ 16]. This led to API consumers not taking depre-
cation warnings seriously.
(2)Inconsistentremoval: Thereisnoconsistentremovalpro-
tocolofdeprecatedfeatures,leadingto:“anunclearmessage
[regarding the future of a deprecated feature] being deliv-
eredtodevelopersaboutthemeaningof@Deprecated”[ 16].
This led clients to leave references to a deprecated features
in the source code, given that there is no danger of the code
breaking when updating to a newer version of the API.
Given the aforementioned issues, the Java language developers
put forward a set of enhancements in the JEP [16]:
(1)forRemoval(): A method named ‘forRemoval()’ in the dep-
recationclass,whichsetsabooleanflagtoeithertrueorfalse,
where true signifies that the feature is going to be removed
in the future and false signifies that there are no plans to
remove the deprecated feature.
(2)since():Amethodnamed‘since()’inthedeprecationclass,to
setastringduringthedeprecationofafeaturetoindicatethe
versionoftheAPIinwhichthisfeaturehasbeendeprecated.
The involved Java language developers expect that these en-
hancements would remove some of the confusion surrounding
deprecation. In addition to enhancing the deprecation mechanism,
the Java language designers are going to remove deprecated fea-turesthatarecurrentlypresentintheJavaSEAPI.Theirhopeis
thattheseinitiativeswillserveasaninspirationtootherAPIpro-
ducers to remove their deprecated features and to API consumers
totakedeprecationseriouslyandconsiderreactingtoit.Overall,
they aim to change the culture surrounding deprecation.
Figure 1: Example of deprecation warning in the IDE
3 METHODOLOGY
Theoverallgoalofthispaperistodeterminethecharacteristicsthat
a deprecation mechanism should possess and whether these are
desirableamongdevelopersandfeasibletoimplementinamain-
stream language such as Java. This study has two parts: In the first
part, we start by deeply understanding how the deprecation mech-
anismisusedandperceivedbybothAPIproducersandconsumers;
in the second part, we propose extensions to Java’s deprecation
mechanism and determine the feasibility of the same. This section
describesthemethodologyforthefirstpart,themethodologyfor
the second part can be found in Section 6.
Inthefirstpartofourstudy,weproposefourresearchquestions:
RQ1: WhydoAPIproducersusethedeprecationmechanism?
InthisRQ,weidentifywhyAPIproducersusethedeprecation
mechanism. Such an understanding will help us obtain a catalog
of reasons adopted by API producers to deprecate features.
RQ2: When and why do API producers remove deprecated
features? TheJavalanguagedesignersclaimthatinconsistent
removalpoliciesrelatedtodeprecatedfeatureshaveledtoconfu-sionsurroundingtheimplicationsofdeprecation.HavingnoclearpolicyofremovalsendsanunclearmessagetoAPIconsumers.InthisRQ,weinvestigateastowhatthedifferentremovalprotocols
are and why API producers adopt them.
RQ3: HowdoAPIproducersexpecttheirconsumerstoreact
to deprecation? It is an unverified claim that API producers
alwaysrequiretheirconsumerstoreacttodeprecation.Inthis
RQ, we seek to understand and analyze when API producers feel
that a reaction should take place.
RQ4: Why do API consumers react to deprecated features?
Fromourfirstresearchquestionweobtainacatalogofreasons
whyAPIproducersmaydeprecateafeature.InthisRQ,wein-
vestigate the consumers’ perspective on deprecation.
3.1 Research Method
InterviewswithAPIproducers. Togainanin-depthunderstand-
ing ofhow API producers perceivethe current implementationof
the deprecation mechanism in Java, we conduct a series of semi-
structuredinterviews[ 15]withindustrialandopensourcesoftware
(OSS) API producers.
Before the interviews, (1) we analyze the official Java documen-
tation and study the deprecation mechanism that elucidates when
the mechanism should be used, (2) we look at the improvements
madetothedeprecationmechanisminJava5andfinally(3)welook
562
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:53:54 UTC from IEEE Xplore.  Restrictions apply. Understanding Developers’ Needs on Deprecation as a Language Feature ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
at the proposed enhancement for Java 9. This helps us understand
the scenarios in which deprecation is used; this understanding was
key in developing and conducting the interviews.
The questions asked during the interviews are based on a guide-
line derived from our research questions. We ask interviewees
questions such as “When do you decide to change an API?” and
“Arethereanystepsthatwouldlessentheburdentoupgrade?”.We
iteratively refine this guideline before every interview, based on
theresponses.InterviewsareconductedinEnglishandtranscribed.
We follow an interpretive descriptive approach [ 31], after an
explorativeresearchmethod,originatingfromthesocialsciences,
that is an inductive approach to analyzing interviews and deriving
theories. As part of the interpretive descriptive technique, each
interview transcript was analyzed and broken into smaller parts,
where each part was assigned a code based on its content. We
clustered these codes based on similarity, to let common themes
emerge from the interviews. When we encounter the same code
repeatedlyacrossmultipleinterviews, i.e.,saturation,weadjustour
interview guideline to explore other topics. Each research question
has its own set of codes, which we then present as our results.
Survey with API producers and consumers. To challenge the
findingsfromtheinterviews,wesendoutananonymizedsurvey
made up of 29 questions to developers. Our survey consists of
questions for both API producers and API consumers, based on the
rolethatthedeveloperplays.Thisissothatwegetbothperspectives
on the Java deprecation mechanism. It followed the structure of
the theory developed as a result of the interviews. The survey
respondents were asked to rank the degree (on a five-point Likert
scale) to which they agreed with a theme that emerged from the
interviewprocess.Whenarespondentcompletelydisagreeswith
one of the statements, we ask the respondent to provide us with
their perspective. The survey is in our replication package [27].
3.2 Participant Selection
Interviews. We contacted API producers who work for large com-
panies in two different countries (The Netherlands and Brazil) and
those that actively work on well-known open source projects. We
contacted the industrial developers by mailing the CTOs of certain
companiesaskingtobeputincontactwithproducersofAPIs.Inthe
caseofopensourcedevelopers,wemailedtheinternaldevelopersof
JUnit, Spring and Mockito asking for an interview. We chose these
three projects due to (1) the popularity of their API (According to
Sawantetal.[28],JUnitisthefirst,Springthethird,andMockito
the 10th most used APIs on GitHub), and (2) convenience to access
developers working on these projects. Overall this resulted in 17interview participants (identified as
P1-P17 in this paper). The
background of the participants is summarized in Table 1.
Survey.Weaimed toreach asmany Java developersfrom diverse
backgrounds. To that end, the survey was spread via Twitter, Java
mailinglists,country-specificdevelopermailinglists,andcompa-
nies.Thesurveyranforaperiodof3months.Overall,weobtained
170responsesfromwhichwecouldderivevalidresults.Thesurvey
respondents were primarily developers (142 out of 170), the rest
was composed of architects (10 out of 170), researchers (9 out of
170), analysts (1 out of 170), manager (3 out of 170), consultants (1
out of 170) andtesters (4 out of 170). 138of our respondents workTable 1: Profiles of the interviewed API producers
Company/ Experience
IDDomain Project (in years)
P1 Industry Large consultancy 6
P2Industry Large consultancy 7
P3 Industry Large consultancy 6
P4Industry Large bank 6
P5 Industry Large bank 5
P6Industry Large consultancy 4
P7 Industry Large SW company 18
P8Industry Large SW company 16
P9 Industry Large SW company 21
P10Industry Startup 6
P11 Industry Startup 9
P12Industry Public sector 15
P13 Industry Small SW company 9
P14Industry XWiki 16
P15 OSS Spring Framework 8
P16OSS JUnit 17
P17 OSS Mockito 4
in industry and the rest on open source projects. Our respondents
originate primarily from countries such as USA, Italy, Brazil, India
andTheNetherlands.Onaverageourrespondentshave11yearsof
experience of working with Java.
3.3 Limitations
Oneoftherisksofaqualitativestudyisthatdeterminingtheva-lidity of our findings is a difficult undertaking [
9]. We followed
interpretivedescriptiveinterviewguidelinesclosely.Despiteour
best efforts, some limitations exist, in the following, we explain
how we try to minimize them.
Generalizability. Ourselectionofdevelopers tointerviewmight
not be representative of the Java API producer community. To
mitigate this limitation, we questioned three different sets of devel-
opers for their opinions from both industry and open source based
projects. Furthermore, we surveyed 170 developers who act as API
producers and consumers, to challenge our findings. If the study
isrepeatedusingadifferentsetofdevelopers,theresultsmaybe
different. However, we found a large agreement concerning the
view on deprecation of interviewees and survey respondents.
Interviewer bias. Our own biases may have played a role when
interviewing developers, e.g., by leading interviewees to provide
more desirable answers [ 11]. To mitigate this issue, we challenged
and triangulated our findings by conducting a survey with API
producers and consumers. We sent our survey out via differentmedia such as Twitter and developer forums. Given this, we donot know the exact context of the population that has accessed
our survey. Dueto this, we cannotknowthe exact response rate.
Howeverwecanreportthatatotalof535developersstartedour
survey and 170 (32%) of them filled the entire survey.
Credibility. Question-order effect [ 30] (a phenomenon where one
questioncouldprovidecontextforthenextone)mayleadourinter-
vieweesandsurveyrespondentstospecificanswers.Oneapproach
563
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:53:54 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden A. A. Sawant, M. F. Aniche, A. van Deursen, A. Bacchelli
It is no longer 
supportedIt contained non-functional issuesIt encouraged bad coding practices
Better features have 
been developed
It is no longer required
It contained 
functional issues
It marks a
feature as beta
Never Almost never Neutral Almost every time0 0 40% 80%
Every time40% 80%
Figure2:MotivationstodeprecateafeatureaccordingtoAPI
producers, by decreasing frequency
to address this bias could have been to randomize the order of
questions. In this study, we decided to order the questions based
on the order in which decisions are taken when deprecating a fea-
ture.Socialdesirabilitybias[ 8](i.e.,aninterviewee’stendencyto
give a socially acceptable answer to appear in a positive light) may
have influenced answers in our interview and survey. To mitigate
this issue, we informed participants that the responses would be
anonymous and evaluated in a statistical form.
4 RESULTS
4.1 RQ1: Why do API producers use the
deprecation mechanism?
We ask API producers whether and why they find the deprecation
mechanismrelevantandwhatmotivatesthemtouseit.Fromthe
interviewsandtheJavadocumentationondeprecation,sevenmain
reasons as to why developers deprecate part of their API emerge:
(1) Old interface encourages bad practices
(2) New/updated feature supersedes existing one
(3) Usage of the feature is unnecessary(4) Functional issue in current implementation
(5) Non-functional issue in current implementation(6) No longer provide a feature(7) Mark as beta
The first three reasons emerge from documentation. Reasons
2-6a r ementioned by our interviewees, with reason 1 the only
unmentioned one.We included these seven main reasons behind
deprecationinoursurveythatwassenttodevelopers.Inoursurvey,
API producers were asked how frequently they had used one or
more of the reasons; Figure 2 reports the results. We also asked
both API producers and consumers if they had encountered any
otherreasonsbehinddeprecatingafeature.Within170responses
we obtained no more reasons behind deprecation.
Reason 1 is the most popular reason behind deprecation as re-
ported by our survey’s respondents. Reasons 2-6 are the ones that
all our interviewees agreed upon as being those that they have
used in their own APIs. API producers in our survey also agreed
that these are common/frequent reasons that they have used to
deprecate a feature.Reason 7 was mentioned by interviewee P16, whose team unex-
pectedly uses the deprecation mechanism in Java to mark a featureasbetaorexperimental.IntervieweeP16didacknowledgethisasis
a misuse of the deprecation mechanism, but they found it effective.
P14mentionedthatintheirAPItheyfacedasimilardilemma,wheretheywantedtoexplicitlyindicatetoanAPIconsumerthatafeature
being used was new/experimental. However, instead of perverting
the meaning of deprecation, they introduced their own annotation
@Unstable that marked in the documentation that caution should
be exercised when using a new feature.
Orthogonaltoallthemotivationsbehinddeprecation,itemerged
thatdeprecationisaneffective,yetimperfectcommunicationchan-
nel between API producers and the API consumers. Interviewee
P17putitas:“[deprecationis]stillthebestcommunicationmethod
as of today”. He went on to further state that the language feature
of deprecation makes it easier to tell a developer that uses a dep-
recated feature: “Hey! Be aware! We will remove this feature later,
justsoyouknow”.Thisadvantageofdeprecationisnotrestrictedto
the open source software world but is found to be quite importantin industry as well. Interviewee P2 said that they find it important
“when stopping an existing service, this communication should
happenatthetimewhenwearethinkingofbreakinganexisting
service”. The industrial API producers find it useful to let theircustomers know that a certain service that they might be using
isgoingtodisappear.Nevertheless,thelowreactionratesofAPI
consumers reported in literature [ 24,29] underlines that messages
sentthroughthischannel(regardlessofhowaccuratelytheyare
written[2])areoftennotactedupon,thusraisingconcernsonits
actual effectiveness, also on our interviewees.
One stated advantage of deprecation is that a developer is given
instantfeedbackintheIDEwhenusingadeprecatedfeature.De-
spite this, some of our interviewees (P5, P6, P7, P10) expressed the
view that there might be a better way to communicate this change
to the consumer. In the opinion of these participants, this warning
might be a bit of a later point, as it would require developers to
gothrougheachfileintheIDEtoseeifthereareanydeprecated
featuresthatarebeingused.Thishappensonlyafteranupgradeis made to a newer version, but the notification only reaches thedevelopers at the last moment, thus necessitating an alternative
channel of communication.
Thedeprecationmechanismisviewedasaninterfacefor
communicationwiththeAPIconsumer.Ho wever,itisopen
to misuse and has shortcomings.
4.2 RQ2: When and why do API producers
remove deprecated features?
MostAPIproducers(48%)amongoursurveyrespondentsindicated
that they usually remove a feature two or more releases after its
deprecation. Despite most of the positive votes for this policy, only
12% of developers indicate that they always remove a feature after
tworeleases, whereas22% indicatethatthey dothisalmost every
time and 29% say they occasionally do this.
The second most popular removal pattern among our survey
respondents was to never remove a deprecated feature. This may be
564
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:53:54 UTC from IEEE Xplore.  Restrictions apply. Understanding Developers’ Needs on Deprecation as a Language Feature ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
at the basis of the lack of reaction by clients to deprecation. 16% of
developerssaythattheyalwayschoosetonotremoveadeprecated
feature, 15% say that they do this almost every time and 27% say
thattheydothisoccasionally.Only25%oftherespondentssaythat
they have never adhered to this behavior.
Our survey respondents also indicated that they remove dep-
recated features in an upcoming release or in one release after
the next immediate one. However, none of these responses had
too much support. Developers do not appear to be very keen on
cleaning up their code base after deprecating a feature.
Regarding whydevelopersdecide(not)toremoveadeprecated
feature,fromthesurveyresultswegetthesensethatthereisalarge
varianceinremovalpoliciesofdeprecatedfeatures,afactechoed
by Stuart Marks (proponent of JEP 277) [17].
Interviewee P8 mentioned that they never remove a deprecated
featurebecauseconsumersdonotappreciateitwhenfunctionalities
are removed. The other developers of this company (P7 and P9)agree with this perspective. In their opinion, the introduction ofbreakingchangeswouldbedetrimentaltocustomersatisfaction;
this is despite this company providing detailed documentation on
how totransition tothe replacementfeature alongwith customer
support to aid the transition.
Interviewee P12 echoed the previous sentiment. Their company
too prefers to never remove a deprecated feature. In fact, they are
willingtomaintain twoversionsof thesamefeaturein theircode
base. This company has only ever introduced a breaking change
when there was a severe flaw in the feature that was being used
and in such a case the feature was not deprecated first.
P14mentionedthattheyalsodonotremoveafeaturefromtheir
API.Afterafeatureisdeprecated,theyfirstremoveallreferences
toitfromtheirowncodebase.Afterthis,theymovethisfeatureto
alegacypackage.Thisdoesnotinvolvechangingthenamespaceofthefeature,theysimplybuildtheirAPIsJARinsuchawaythatthey
obtain one version with no legacy features ( i.e., no deprecated fea-
tures) and another which includes them. This gives the consumers
of this API the choice of continuing the use of a legacy feature.
Interviewee P17 mentioned that in their API they often remove
a deprecated feature, however, they do not have a regular schedule
orpolicy.Whatcantriggertheremovalmaybemajorchangessuch
as a modification in the underlying architecture of the API.
Only interviewee P15 mentioned that they have a protocol to
removedeprecatedfeatures.Whendeprecatingafeaturetheyin-
dicate the release in which this feature is going to be removed.
They generally remove deprecated features in the following ma-
jor release. On being asked about this policy resulting in breaking
changes, the interviewee responded: “We deprecate a feature when
wehaveapointwhereweseeit’snotuseful ... andthenweremove
it in the next major release ... because we have a new [,better]
implementation.”
API producers are wary about removing deprecated fea-
tures from their API and mostly have no preset protocol
for removal.4.3 RQ3: How do API producers expect their
consumers to react to deprecation?
We asked our interviewees whether they perceived that (1) dep-
recation on its own was enough to send a message across that a
featureshouldnolongerbeusedand(2)whetheritwouldactasanincentivefortheirclientstoreacttoAPIevolution. Predominantly,
mostofourintervieweessaidthatitwasthechoiceoftheconsumertoreact,butthatthedeprecationmechanismwouldhavenoimpact
on reaction behavior. In the words of P17: “I think it’s an easy way
out for developers of an API because it is really easy to edit and
notifyyourusers,butyoudonotactuallyremovethewholefeature.
Soyouarestuckwiththesensethatausercanbewillingtokeep
using it and not be incentivized to actually stop using it”.
The only outlier we had was interviewee P5 who disagreed
with the popular sentiment and went on to say that deprecation
isabeautifulconceptasitgivesaconsumerthetimetoconsider
reacting: “just marking something deprecated will give you an
opportunity to think of alternative ways of doing things but at the
same time keeping control over when you want to move on ... to
new features”.
As a follow-up, we asked our interviewees if deprecation of a
feature could act as an incentive for their clients to change the
version of the API that they are using. Interviewee P10 mentioned
that the reason behind the deprecation would be key: “Yes, ... the
reason for deprecation has to be concrete enough for me to switch
to the new versions”.
In the view of interviewee P2, the decision to switch versions is
oftenbasedonthecostofanupgrade:giventhatdeprecationisnot
abreakingchange,itdoesnotactasastumblingblock;however,
if the reason behind deprecation is serious enough, then there is
anincentivetochange.Overall,APIproducersassumethattheir
clients will react to deprecation only if the reason is serious.
Wealsowantedtoestablishifdeprecationofafeaturedissuades
the usage of that feature to such an extent that it can be safely
removed. Some of our industrial interviewees said that when they
deprecateafeature,theycanoftenremoveitsafelylateronastheyknowthattheirclientshavereceivedthemessage.ConcerningOSS,P16 said: “For JUnit, it hasn’t really worked out to deprecate things
and then get rid of them ... [but it] might work for some other
libraries”. He recounted a case where JUnit had deprecated a singlefieldinthecodebase,whichhadcausedIDE’ssuchasEclipsetopostissuesonJUnitastheywereopposedtothatfieldbeingdeprecated.
OnepointofagreementacrossalltheAPIproducerswasthatan
automatedtoolthathelpsAPIconsumerstoreacttodeprecation
with minimal effort would probably be most beneficial. Such a tool
wouldensurethatclientsreact,andkeepconcernsregardingcost
to change at a minimum.
API producers acknowledge the costs for consumers as-
sociated to reacting to deprecation. For this reason, they
assume a prompt reaction by consumers only if the reason
behind deprecation is serious.
565
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:53:54 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden A. A. Sawant, M. F. Aniche, A. van Deursen, A. Bacchelli
4.4 RQ4: Why do API consumers react to
deprecated features?
WestartbyascertainingwhetherAPIconsumersreacttodeprecated
features. In the event that they do react, we investigate why.
Do API consumers react to deprecated features? In addition
toinvestigatingwhetherconsumersreacttodeprecatedfeatures,
we also explore whether deprecation acts as a barrier to upgrading
the version of the API being used.
Deprecation is regarded by consumers as the least important
reasonthatpreventsthemfromchangingversionsoftheAPI.Over
40%oftheconsumersareneutralaboutitsimpact,whileonly1%
indicate that deprecation has prevented them from upgrading API
versions. We see that the largest barrier to API consumers when
upgrading a version of an API is the new version breaking some
existing functionality. This is in line with previous findings [4].
Most consumers claim that they react to deprecation, we asked
these API consumers as to how they react. 67% of consumers in-
dicate that they react by replacing a deprecated feature with its
recommendedreplacement.66%ofourrespondentsclaimtoread
thedocumentationandthenbasethereactiononthemotivation
behind deprecation. “doing nothing” is the second least popular
waytoreacttodeprecation,26%ofthesurveyrespondentsindicate
that they have never reacted in this manner. The least popular way
to react to deprecation is to replace the deprecated feature with an
in-housefeature.Thesefindingscontradictearlierresults etal.[29]
showing that majority of projects on GitHub do not react to API
deprecations.Ho wever,onee xplanationforthismightbethatthese
responses might be an indicator of the social desirability bias, thus
prompting the consumers to claim that they always react.
We ask the respondents who have never reacted to deprecation
toexplainthereasonbehindtheirbehavior.Mostresponsesindi-
catedthatsincedeprecationisnotabreakingchange,reactingto
deprecationisnotpivotal.Thisissummarizedbyonerespondent
saying:“Itisthesafestbettokeepthingsastheyare.Deprecationas
suchdoesnotchangethebehaviorofthesolution,soitdoesn’tneed
to be actedupon”. Other responses include APIconsumers saying
that the cost of a reaction was not justified hence they preferred
to wait till the deprecated feature is removed. Poor documentation
was also cited as a reason not to react.
WhydoAPIconsumersreacttodeprecatedfeatures? Weask
oursurveyrespondentstoindicatewhatmotivatedthemtoreact
to deprecation. These results can be found in Figure 3.
WeaskedtheAPIconsumersifknowingtheremovalpolicyofan
APIregardingdeprecatedfeatureshadanyimpactontheirdecision
toreact.Thiswasapointofcontention,with29%ofrespondents
saying that this had indeed motivated them to react. However, a
majority of 36% claimed that this had never motivated them and
that the reason behind deprecation had far greater significance.
We see in Figure 3 that the motivation behind deprecation plays
a large role in eliciting a reaction from the API consumer. When a
featureisdeprecatedduetofunctionalissues,non-functionalissues,
orbecauseanewfeatureisanimprovementovertheoldone,there
is a large number of API consumers (over 40%) in each case thatsays they have been motivated to react in that case. 27% or less
oftheAPIconsumersindicatethatotherreasonshavemotivated
them to react to deprecation.Its use is no longer 
necessaryA non-functional issue 
has emergedNew/better features 
have been developed
A functional issue 
has emerged
It encouraged bad 
coding practices
It is no longer going 
to be supported
It marks a
feature as beta
Never Almost never Neutral Almost every time0
Every time0 40% 80% 40% 80%
Figure 3: Motivations to react to deprecation according to
API consumers’ experience, by decreasing frequency
APIconsumerspredominantlyclaimthattheyreacttodep-
recation, the driving factor behind this behavior is the rea-
son behind deprecation.
5 ANALYSIS AND REFLECTION
We now discuss the main findings of our study. The knowledge
gainedfromthisstudyhelpsusunderstandthegaps(andhowto
address them) in the current implementation of the deprecation
mechanism and deprecation in Java on the whole.
5.1 A communication mechanism
PreviousworkbySawant etal.[29]hasshownthatAPIconsumers
in the Java ecosystem do not necessarily replace references to dep-
recatedfeaturesintheirsourcecode.Thisissimilartothebehavior
observed in the SmallTalk sphere by Robbes et al.[24] as well.
Oneofthecontributingfactorstothisphenomenonisthefact
thatthird-partyAPIproducersandJavaSEAPIproducersdonot
haveconsistencywhenitcomestotheremovalofafeaturefrom
the API as seen in Section 4.2. This points to the fact that the
deprecation mechanismin its currentform might notbe fulfilling
its goal in effectively communicating when it is imperative that an
API consumer cease to use a deprecated feature.
Fromtheinterviews,weobservedthatAPIproducersagreewith
thisviewastheytoofeelthatcertainimprovementscanbemadeto
streamlinethecommunicationbetweenproducersandclients.To
addressthis,weleveragetheinterfaceusabilityguidelinesoutlined
byJakobNielsen[ 19].Byconsideringdeprecationasacommunica-
tioninterfacebetweenAPIproducersandAPIconsumersandbyus-inginterfaceusabilityguidelines,wehopetobeabletounderstand
theshortfallintheeffectivenessofthedeprecationmechanismasa
communication mechanism.
In the following, we discuss two enhancements to the current
deprecationmechanismthatwouldbetterfacilitatethecommunica-
tionbetweenAPIproducersandconsumers,namelyunderstanding
whenafeaturewillberemovedfromtheAPIandtheseveritylevel
of the deprecation.
566
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:53:54 UTC from IEEE Xplore.  Restrictions apply. Understanding Developers’ Needs on Deprecation as a Language Feature ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
The future of deprecated features. The current implementa-
tion of the deprecation mechanism is in direct contravention of
Nielsen’s[ 19]guidelineon“Visibilityofsystemstatus,”whichstates:
“Thesystemshouldalwayskeepusersinformedaboutwhatisgoing
on.” Indeed, with the current deprecation mechanism provided by
the Java language, API consumers have no indication on the future
of a deprecated feature.
TheenhancementsinJava9’sdeprecationmechanismattempt
to address this shortcoming by allowing API producers to indicate
whether a deprecated feature is going to be removed or not. By
doing so, API consumers will be given a clear indication about the
futureofadeprecatedfeature.Thiswillhelptheconsumertakea
decision on the reaction to deprecation.
However, the enhancements do not go far enough in addressing
the issuespresent inthe usabilityof thedeprecation interface.Al-
thoughthefutureofadeprecatedfeaturehasbeenmadeexplicit,
there is still no definitetimeline that an API producer can provide
totheconsumer.Byjustmarkingafeatureasonethatwillbere-
moved,noindicationisgivenastohowlongtheremovalcouldtake,
whichstillleavesthefutureofadeprecatedfeatureinanambiguous
stateasthedeprecatedfeaturecouldberemovedimmediatelyor
after many years. Currently, the onus is on APIs to provide thistimelineintheJavadoc(e.g.,Springframework),however,thisis
not standard practice [2].
The severity of a deprecation. Nielsen’s usability guideline on
“Consistencyandstandards”dictatesthat“Usersshouldnothave
to wonder whether different words, situations, or actions mean the
same thing” [ 19]. In the current implementation of the deprecation
mechanism, there is no way to discern the difference betweenfeatures deprecated due to serious issues, those that have been
deprecatedduetosmall improvements,oreventhosethathavebeen
deprecatedbecausetherewasnobetteralternativetocommunicate
with the customers(as in the case of betafeatures).The proposed
enhancementstothedeprecationmechanismtobeimplementedin
Java 9 do not address this issue.
We see from API producers (Section 4.3), that there are differ-
ent suggested reaction patterns for different deprecations. Only in
certain cases where there is a serious issue with a feature, do they
feelit isimperative forthe consumertoreact.From theAPIcon-
sumersthatansweredoursurvey,weunderstandthatthereason
behind deprecation is important when it comes to reacting to adeprecated feature. Functional issues, non-functional issues, andbad coding practices are all major motivations when it comes to
reactingtodeprecatedfeatures,whereastheyarelesslikelytoreact
to a deprecation of a feature due to the fact that usage of it is no
longerrequired.Inthecurrentstate,thedeprecationmechanism
does not allow for API producers to inform the API consumers on
the severity of a deprecation.
Anindicationoftheseverityofdeprecationwouldnotbeanovel
extension toJava’s deprecationmechanism. Currently, C#[ 18] al-
lowsAPIproducerstoindicateifadeprecationissevereornotwith
the help of a boolean. In the event that a deprecation is serious,
the compiler throws an error when the functionality is invoked.
AlthoughC#’sapproachcanbeconsideredextreme,itshowsthat
indicationofseverityofadeprecationisaviablefeatureinadepre-
cationmechanism.Wehighlightthatthisextensiontothemech-anism is of utmost importance to API producers and consumersalikeandwillaidthedeprecationmechanisminfunctioningasa
more effective communication interface.
5.2 Misuse of deprecation
Currently, in Java, if an API producer wants to issue a compiler
warningtocommunicatewiththeconsumer,thedeprecationmech-
anismis theonlystraightforwardoption.API producershaveat-
tempted to overcome this limitation in the Java language specifi-cation by implementing workarounds (e.g., in the case of XWiki,
betafeaturesaremarkedusingaspecialannotationwhichrequires
special IDE support so that it is highlighted). However, none of
these workarounds arenatively supportedby IDEsor Continuous
Integration (CI) environments and, thus, not portable.
This has led to the misuse of the deprecation mechanism, where
certain features that are not intended for removal in the future are
marked as deprecated (e.g., in the case of JUnit where beta features
are marked as deprecated).
This leads us to conclude that there is a need for an alternative
way for API producers to communicate with the API consumers,
especiallyinthecasewheretheywouldliketoindicatethatafeature
isbetaorexperimental.Agenericwarningmechanismthatgives
API producers the ability to generate compiler warnings on usages
of certain features of the API for reasons other than deprecation
could solve this issue.
Such mechanisms already exist in other languages (e.g., Python
has a warning system that allows for the specifications of different
levels of compiler warnings) and would not be a revolutionary
introduction.However,byintroducingsuchasystemandmaking
deprecationasub-caseofthewarningmechanismtheJavalanguage
designers would allow API producers increased flexibility. There is
currentlynoproposaltointroducesuchamechanism;wepostulate
that it would be fruitful for the Java community to discuss this.
5.3 API consumer aid with deprecation
Most of our interviewees suggested that refactoring tools to au-
tomatically replace references to deprecated features with theirrecommended replacements could incentivize API consumers to
react to deprecation, as it would reduce the overall cost to react to
deprecation and reduce the chances of errors.
Thereissomeexistingworkonprovidingrefactoringsupport
to API consumers to reduce the burden of reacting to deprecation.
Henkel and Diwan [ 10] propose to capture refactorings made by
APIproducerstotheircodebasewhenadaptingtotheirowndep-
recated featuresand then replaying theserefactorings on theAPI
consumers’ code. Xing and Stroulia [ 33] developed an approach
that recommends alternative features from an API to replace anobsolete feature by looking at how the API’s own codebase has
adapted to change. The tool created by Perkins [ 20] replaces depre-
catedmethodinvocationswiththesourcecodeofthedeprecated
method from the API itself. This has been shown to be effective in
75% of cases.
Althoughexploringpromisingavenues,alloftheaforementioned
toolsrequireanon-trivialamountofeffortfromtheAPIproducers,
thus do not scale. Additionally, these tools do not handle more
complexcaseswherethereplacementforadeprecatedmethodis
567
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:53:54 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden A. A. Sawant, M. F. Aniche, A. van Deursen, A. Bacchelli
Specify version when deprecated 
and whether it will be removed
Create a generic warning, 
superclass of deprecation
Very undesirable Undesirable Neutral Desirable0
Very desirable0 40% 80% 40% 80%Automated refactoring to replace deprecated callsHave diﬀerent strengths for warningsR
S
W
Figure 4: Respondent’s perspective on theenhancements to
the Java deprecation mechanism
notaone-to-onereplacement.Thisshowsthatthisproblemofauto-
matically replacing deprecated features is non-trivial and remains
unsolved. The persistent need for such a tool calls for increased
research in programming languages and practices supporting auto-
mated API restructuring.
6 PROPOSED ENHANCEMENTS TO THE
DEPRECATION MECHANISM
Basedonourresultsandanalysis,wehaveuncoveredcertainas-
pectssurroundingthedeprecationmechanismthatareespecially
important for the Java language designers. In the second part of
thisstudy,weproposeandinvestigatedesirabilityandfeasibility
of three enhancements. The first two are related to the deprecation
mechanism: they go beyond JEP 277, aiming at defining a more
completedeprecationmechanism.Thethirdproposaladdressan
issue at a higher level - the language level.
(1)R:Removaldatesshouldbemarked :Deprecationshould
allow developers to indicate the version or date when a
deprecated feature will be removed.
(2)S: Severity should be marked :Deprecationshouldallow
developerstoindicatetheseverityofadeprecationandraise
warnings of according strength.
(3)W:Warningmechanismsshouldbegeneric :Javashould
introduce a warning mechanism to allow for other types of
warnings to be raised, as well as managed by IDEs, thus
minimizing the misuse of deprecation.
Werefertoourproposalas RSWfromthispointon.Wevalidate
thedesirabilityandfeasibilityof RSWbyperformingatwo-step
validation. First, we obtain feedback from the larger community
of Java developers (survey with the same 170 professionals) to
understandtowhatextenttherewouldbesupportfor RSW.Second,
we interview two Java language design experts (one of them being
the promoter of JEP 277) to determine whether RSWcould be
implemented in Java and if-so then how this could be done and
what the associated difficulties would be.
6.1 Desirability among the Java community
We present the results of our survey in Figure 4. 78% of develop-
ers findRto be (very) desirable and only 7% do not want such a
change.Infact,inouroptionalwrite-insurveyoption,2developers
expressed even more support for this feature.
We see that Sis the third most desired change, thus implying
that Java developers would like API producers to be allowed to
signify to their clients that in certain cases it is pivotal that theclientreacts.ThissupportsthatAPIconsumersdonotgetaclear
indication as to how severe the deprecation of a feature is.
Waims to give API producers more flexibility when it comes to
communicating with their clients. We see that there is no strong
trendamongJavadevelopersconcerningthedesirabilityofthispro-
posal: The 22% of the developers who find it desirable are balancedby27%whofinditundesirable.Moreover,51%ofthedeveloperssit
on the fence in this case and have neutral opinion on the warning
mechanism.ThisresultmayindicatethattheJavacommunitydoes
notcurrentlyperceiveitasnecessarytohavedifferentwarnings
other than deprecation; this would be in line with the low number
of respondents who reported to use the deprecation mechanism
for purposes different than the intended ones (Section 4.4). Never-
theless,thisproposalistheonethatdivergesthemostfromwhat
developers are already used to, thus, it would be reasonable to
considertheresultsinthelightofthetheoryonthe“diffusionof
innovations”[ 25];inthiscase,thepercentageoftherespondents
that found this enhancement desirable would be slightly higher
than the expected percentage of early adopters of innovations [ 25].
We also asked our survey respondents whether they would wel-
come an automated refactoring tool to deal with deprecation. The
surveyrespondentswereprimarilypositive,confirmingtheopinion
of the interviewed API producers.
6.2 From theory to practice: RSW’s Feasibility
Weassessedthefeasibilityofimplementing RSWintheJavalan-
guagebymeansofaninterviewwiththepromoterofJEP277(Stuart
MarksreferredtoasJ1)andaJavalanguagedesignexpert(referred
toasJ2)whohasbeenpartoftheexpertgroupforJSR-305[ 21]and
the specification lead group of JSR-308 [6].
R:Indicationonaremovaltimelinefordeprecatedfeatures.
Regarding R, J1 mentions that the implementation would be possi-
ble but not trivial. The principal challenge is how such a feature
could be implemented. The first issue with indicating in which
version a deprecated feature is going to be removed is that version
numbering schemes constantly change. The second issue is that
havingaconcretedatewouldposeachallengeaswellsincerelease
schedulesconstantlychange(e.g.,Java9releasehasbeenpushed
back twice in the last year). However, J1 did concede that giving
suchanindicationisdefinitelyusefultoAPIconsumers,butonlyifa uniform version numbering convention is adopted by third-party
APIs and the Java SE.
J2confirmedaswellthat Rwouldsendamoreconcretemessage
aboutremovaltotheAPIconsumers.However,hefeltthatthere
wouldbenoneedtoovercomplicatetheannotationtoachievethis
aim: “[there is no] need to make the annotation that much morecomplicated”. He felt that if an API established and adhered to a
uniformpolicytodealwithdeprecatedfeatures,thatmightachieve
the same goal.
S: Indication on the severity of deprecation. WithS,wehope
to provide API consumers a clear indication as to how severe a cer-
tain deprecationis. J1 saidthat for JEP277 something similarwas
considered: “[the idea was] to include an enumerator that specifies
the reason behind deprecation such that tools could do filtering
based on the reason, and different reasons would have different
severities for different users”. According to him, the issue was that
568
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:53:54 UTC from IEEE Xplore.  Restrictions apply. Understanding Developers’ Needs on Deprecation as a Language Feature ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
compiling a comprehensive list of distinct reasons behind depre-
cation of a feature is a non-trivial endeavor. In fact, we observed
inourinterviewsthat,inmanycases,deprecationscouldfallinto
morethanonecategory.However,ourproposaldiffersfromthis
asitallowsAPIproducerstoindicatethelevelofseverity i.e.,the
seriousnesswithwhichAPIconsumersshouldtakethisdeprecation
into account. This is similar to the severity field in the deprecation
mechanisminC#.J1feltthatitcouldbeimplementedinJavabut
only after further deliberation on this takes place.
In J2’s opinion having two different levels of deprecation: “error
versus warning” would be a good idea, as it would give API pro-
ducersenhancedcontrolovertheusageofthefeaturestheirAPI
provides.However,therearetwoprincipalchallengesassociated
with this: First, the deprecation mechanism would have to provide
a boolean flag that would allow an API producer to indicate if itis severe or not, which would also indicate to the compiler if a
warningorerrorshouldbethrown;Second,abetterunderstanding
would be needed to demarcate deprecated features that are severe
and those that are not.
W: A high-level warning mechanism. W does not impact the
deprecationmechanismdirectly,butseekstoaddressthemisuse
of the deprecation as elucidated in JEP 277. In this work, we found
just one case of misuse of the deprecation mechanism where a
beta feature was marked as deprecated. J1 agreed that marking
betafeaturesasdeprecatedis“offlabel”usageofthedeprecation
mechanism.DuringthediscussionsonJEP277,itwasconsideredto
have“experimental”asareasontodeprecateafeature.Despitethisextensionneverbeingimplemented,nofurtherstepsweretakento
minimizethismisuseofthedeprecationmechanism.J1feltthata
warningmechanismwouldbeextreme.Infact,hesuggestedthat
one viable alternative that will be present in Java 9 is “incubator
modules, which are sort-of related to beta or experimental”. How-
ever, these are coarse-grained as they apply to entire modules and
not individual classes or methods.
J2 was was not entirely supportive of adding a generic warning
mechanismtoJava.Hefeltthat“[byattempting]toeliminateevery
type of misuse, we’re only going to open the opportunity for more
types of misuse, and we’re going to make it harder for people who
are going to use it in a sensible way or in an imaginative way”.
Healsofeltthatintroducinganexplicitwarningmechanismand
makingdeprecationasubclassofthatsystemwouldbetoomassive
a change to introduce into the Java language. However, he was
supportive of first trying out more specific warnings as in the case
of JSR-305 [ 21]. This would then entail creating a generic warning
mechanism that could be reused for each specific warning.
7 COMPARISON OF DEPRECATION
MECHANISMS IN OTHER LANGUAGES
BesidesJava,therearemanyotherlanguagesthatprovideamecha-
nism that allows API producers to deprecate features in their APIs.
We investigate to what degree these languages implement RSW.
Wefocusonlanguagesthathavethedeprecationmechanismasa
built-infeatureinthelanguage,unlikelanguagessuchasPython
or Go that rely on documentation and coding conventions to mark
functionalityasdeprecated.Additionally,weevaluatewhetherthey
implement any feature in line with RSW.We selectthefirst 15languagesfrom theTiobelanguage popu-
larity index [ 13] that have a built-in mechanism, and toanalyze if
newerlanguagesdoabetterjobwithdeprecationwelookatlan-
guagesthathavebeenreleasedsince2010.WealsoaddSmallTalk
to this comparison as it has been studied in previous work. This
results in a comparison between 21 languages seen in Table 2.
We first of all note that no language implements all of RSW.
Ruby and Dart are the only languages that allow API producers
toindicatewhenadeprecatedfeatureisgoingtoberemoved( R).
Scala, on the other hand, allows API producers to indicate if a
deprecatedfeatureisgoingtoberemoved.VisualBasic,Kotlin,andC#aretheonlylanguagesthatimplement
S.Only6languagesallow
developers to issue a custom compiler warning ( W). The warnings
thrown in PHP and hack are runtime warnings, whereas for the
other languages they are all compiler warnings.
Julia, Swift, Scala, and Rust allow developers to indicate the
versioninwhichafeaturewasdeprecated.Fortheotherlanguages,
this fact is typically communicated with the aid of documentation.
However,unlikeJava’sJavadocsystemthatsupportsdeprecation,
mostlanguagesdonotprovideadedicatedmechanismtodocument
deprecation.
Intermsofvariancebetweennewerandolderlanguages,wesee
thatKotlin,RustandSwiftarethemostadvancedastheyimplement
one of the facets of RSW. Among the more established languages,
C# and Ruby standout as well.
We see that there is no uniform manner in which languages
implement their deprecation mechanism. In fact, newer languages
who have a clean slate to start with also do not implement all
the features that would constitute a more complete deprecation
mechanism.
Languagesarenotconsistentinimplementingadepreca-
tion mechanism and none implement RSWfully.
8 RELATED WORK
Previousstudieshavefocusedondeprecationfromtheclientper-
spective. Particularly Robbes et al.[24] analyzed the reaction to
deprecatedfeaturesintheSmallTalkecosystem.Theyfoundthat
in most cases clients prefer not to react to an obsolete API feature.
This study was extended by Sawant et al.[29] who analyzed the
reaction todeprecated featuresof 5 popularJava APIs.This study
confirmed the results of Robbes et al.with one exception where
clientsofJavaAPIswerelessinclinedtoreplaceanobsoletefeature
with a replacement feature from the same API.
TherehavebeenafewstudiesfocusedonanAPIsdeprecation
policyitself.Raemaekers etal.[22,23]investigatedwhenAPIdevel-
opersdeprecatefeatures.TheyfoundthatAPIsintroduceddepre-
catedfeaturesinmajorandminorreleasesinequalmeasure.Brito et
al.[2] investigate whether API developers document deprecated
features with a link to the replacement feature. They found that
intwo-thirdsofthecasesdeprecatedfeatureswereappropriately
documentedbytheAPIdevelopers,however,theyfoundthatthe
quality of these deprecation messages did not improve over time.
The introduction of breaking changes in APIs and their impact
hasbeenamajortopicofstudy.DigandJohnson[ 5]studiedand
569
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:53:54 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden A. A. Sawant, M. F. Aniche, A. van Deursen, A. Bacchelli
Table 2: Deprecation mechanisms across languages
LanguageVersion of
feature
deprecationWarning:
feature to be
removedRSW
Most popular languages with a deprecation mechanism
Java 8 /check
C# /check
VBasic /check
PHP /check /check
Ruby /check/check /check
Delphi /check
R /check /check
Obj.-C /check
Dart /check/check
D
Scala /check/check
Clojure
Haskell
Groovy /check
Languages developed since 2010
Swift /check
Rust /check
Kotlin /check /check
Ceylon
Julia
Hack /check /check
Language with deprecation investigated in previous work
Smalltalk /check
classified the API breaking changes in 4 APIs. They found that
80% of the breaking changes introduced in an API were due to
refactorings. Cossette and Walker [ 3] studied 5 Java based APIs to
investigatehowAPIevolutionrecommenderswouldhandlecertain
cases. Their study showed that none of the recommenders could
handle all of the breaking cases.
TheimpactofbreakingchangesinAPIscanbewideranging.For
example, Linares-Vasquez et al.[14] show that breaking changes in
AndroidAPIshaveanimpactontheratingofanapp.Espinha et
al.[7] looked at the impact of breaking changes introduced in
popularwebAPIssuchasTwitter,Facebooketc.Xavier etal.[32]
looked at 317 real-world Java libraries and showed that 14% of API
changesarebreakinginnatureand2.5%oftheclientsoftheseAPIs
are affected by these changes.
StudiesonwhyAPIsevolveovertimeandwhatdecisionsgointo
evolvinganAPIprovideauniqueinsightintotheinnerworkingsof
APIs. Bogart et al.[1] studied how developers decide tointroduce
breaking changes in APIs in the Eclipse, R, and NodeJS ecosystems,
howthesechangesarecommunicatedtotheclientsoftheAPIsand
whattoolingandpracticesareadoptedtoensurethattheimpactof
thechangeisminimal.Theyshowthateachecosystemhasitsown
policytoevolveandthispolicyistightlycoupledwiththenature
of the developers that work in that ecosystem. Hou and Yao [ 12]
explore the breaking changes in Java’s AWT/Swing frameworkand find that these changes are limited due to the quality of the
pre-existing architecture of the framework.9 CONCLUSION
Java’s deprecation mechanism is planned for change due to issues
perceivedbytheJavalanguagedesigners[ 16]:Forthethirdtime,
the deprecation mechanism in Java is being revamped. Most main-
streamlanguagesofferadeprecationmechanism,butthereisno
uniform,universalsupportacrosslanguages.Thesefactswitness
that deprecation as a whole is an unsolved problem and that there
is no clear understanding as to what constitutes an effective depre-
cation mechanism.
With this work, we aimed at empirically determining the devel-
opers’ needs concerning deprecation. We did this by conducting a
two-stepstudy,involvinganexploratoryinvestigationandavali-
dation with a large number of Java developers.
Our results show that API producers do not have any kind of
preset protocol to remove deprecated features from their codebase,
thus making the future of a deprecated feature ambiguous. APIconsumers, are more concerned with the reason behind depreca-
tion as that proves to be the ultimate motivation to react. Based on
thesefindings,weproposedtwoenhancementsforthedeprecationmechanism,namely,theindicationoftheversioninwhichthedep-
recated feature will be removed, and different severity levels for
different types of deprecation. Furthermore, to counteract the mis-
useofthedeprecationmechanism,wealsoproposedtoextendJava
withawarningmechanism.Thesechangesgobeyondtheproposed
revampoftheJavadeprecationmechanism,andweshowedthatthe larger Java community would find these extensions valuable
and at the same time, Java language designers found these changes
tobechallenging,yetfeasibletoimplement.Theknowledgethat
weaccumulatedinthisstudyisnotapplicabletoonlyJava,butalso
to other languages which may choose to alter the way in which
they implement their deprecation mechanism.
With this paper we make the following main contributions :
•An understanding of why and how API producers use the
deprecationmechanismandacatalogofreasonsthatmoti-
vate API consumers to react to deprecation, thus providing
researchers and language designers with an in-depth under-
standing of required features of a deprecation mechanism.
•A proposal that enhances Java’s deprecation mechanism
whosefeasibilityanddesirabilityisevaluatedwiththeaidof
twoJava languagedesigners anda surveywith 170respon-
dents,showingthatcertainaspectsofourproposalwould
be well received by the Java community.
•An analytical comparison between the deprecation mech-anisms of 23 popular and new languages, that shows both
practitionersandresearchersthestateofdeprecationmecha-nismsandhowtheydeviatefromamechanismthataddresses
additional developers’ needs.
ACKNOWLEDGMENTS
Theauthorswouldliketothankallparticipantsoftheinterviews
and the survey, as well as the anonymous reviewers for their thor-
oughfeedback.A.Bacchelligratefullyacknowledgesthesupport
of the Swiss National Science Foundation through the SNF Project
No. PP00P2_170529.
570
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:53:54 UTC from IEEE Xplore.  Restrictions apply. Understanding Developers’ Needs on Deprecation as a Language Feature ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
REFERENCES
[1]ChristopherBogart,ChristianKästner,JamesHerbsleb,andFerdianThung.2016.
How to break an API: Cost negotiation and community values in three software
ecosystems.In 24thJointmeetingoftheEuropeanSoftwareEngineeringConference
and the ACM SIGSOFT Symposium on the Foundations of Software Engineering.
ACM, 109–120.
[2]Gleison Brito, AndreHora, Marco Tulio Valente, and RomainRobbes. 2016. Do
developersdeprecateAPIswithreplacementmessages?Alarge-scaleanalysison
Javasystems.In SoftwareAnalysis,Evolution,andReengineering(SANER),2016
IEEE 23rd International Conference on, Vol. 1. IEEE, 360–369.
[3]BradleyECossetteandRobertJWalker.2012. Seekingthegroundtruth:aretroac-
tive study on the evolution and migration of software libraries. In Proceedings of
the ACMSIGSOFT20th InternationalSymposium on theFoundations ofSoftware
Engineering. ACM, 55.
[4]Jens Dietrich, Kamil Jezek, and Premek Brada. 2014. Broken promises: An empir-
ical study into evolution problems in java programs caused by library upgrades.
InSoftwareMaintenance, ReengineeringandReverse Engineering(CSMR-WCRE),
2014 Software Evolution Week-IEEE Conference on. IEEE, 64–73.
[5]DannyDigandRalphJohnson.2006. HowdoAPIsevolve?Astoryofrefactoring.
Journal of software maintenance and evolution: Research and Practice 18, 2 (2006),
83–107.
[6]Michael D Ernst. 2008. JSR 308: Type annotations specification. https://jcp .org/
en/jsr/detail?id =308. (2008). last accessed May 2017.
[7]TiagoEspinha,AndyZaidman,andHans-GerhardGross.2014. WebAPIgrowing
pains: Stories from client developers and their code. In Software Maintenance,
ReengineeringandReverseEngineering(CSMR-WCRE),2014SoftwareEvolution
Week-IEEE Conference on. IEEE, 84–93.
[8]Adrian Furnham. 1986. Response bias, social desirability and dissimulation.
Personality and individual differences 7, 3 (1986), 385–400.
[9]Nahid Golafshani. 2003. Understanding reliability and validity in qualitative
research. The qualitative report 8, 4 (2003), 597–606.
[10]Johannes Henkel and Amer Diwan. 2005. CatchUp!: capturing and replaying
refactorings to support API evolution. In Proceedings of the 27th international
conference on Software engineering. ACM, 274–283.
[11]Donald C Hildum and Roger W Brown. 1956. Verbal reinforcement and inter-
viewer bias. The Journal of Abnormal and Social Psychology 53, 1 (1956), 108.
[12]Daqing Hou and Xiaojia Yao. 2011. Exploring the intent behind api evolution:
Acasestudy.In ReverseEngineering(WCRE),201118thWorkingConferenceon .
IEEE, 131–140.
[13]TIOBE Index. [n. d.]. TIOBE.–2017.[Electronic resource]. Mode of access
http://www.tiobe.com/tiobe_index ([n. d.]).
[14]Mario Linares-Vásquez, Gabriele Bavota, Carlos Bernal-Cárdenas, Massimiliano
DiPenta,RoccoOliveto,andDenysPoshyvanyk.2013. APIChangeandFault
Proneness: A Threat to the Success of Android Apps. In 9th Joint meeting of the
European Software Engineering Conference and the ACM SIGSOFT Symposium on
the Foundations of Software Engineering. ACM, 477–487.
[15]Thomas R Lindlof and Bryan C Taylor. 2011. Qualitative communication research
methods. Sage.
[16]Stuart Marks. 2014–2017. JEP 277: Enhanced Deprecation. http://
openjdk .java .net/jeps/277. (2014–2017). last accessed Aug 2017.[17]Stuart Marks. 2016. Java One presentation on JEP 277. https:
//oracle .rainfocus .com/scripts/catalog/oow16 .jsp?event =javaone&search =
CON3297&search .event=javaone. (2016). last accessed May 2017.
[18]Microsoft. 2012. C# ObsoleteAttribute Class. https://msdn .microsoft .com/en-
us/library/system .obsoleteattribute(v =vs.110 ).aspx.(2012). lastaccessedMay
2017.
[19]Jakob Nielsen. 1995. 10 usability heuristics for user interface design. Nielsen
Norman Group 1, 1 (1995).
[20]Jeff H Perkins. 2005. Automatically generating refactorings to support API
evolution. In ACM SIGSOFT Software Engineering Notes, Vol. 31. ACM, 111–114.
[21]WilliamPugh.2006. JSR305:Annotationsforsoftwaredefectdetection. https:
//jcp .org/en/jsr/detail?id =305. (2006). last accessed May 2017.
[22]Steven Raemaekers, Arie van Deursen, and Joost Visser. 2014. Semantic Version-
ingversusBreakingChanges:AStudyoftheMavenRepository.In Proceedings
of hte IEEE 14th International Working Conference on Source Code Analysis and
Manipulation.
[23]StevenRaemaekers,ArievanDeursen,andJoostVisser.2017.Semanticversioning
and impact of breaking changes in the Maven repository. Journal of Systems and
Software129 (2017), 140–158.
[24]RomainRobbes,MirceaLungu,andDavidRöthlisberger.2012.Howdodevelopers
react to API deprecation?: the case of a smalltalk ecosystem. In Proceedings of
the ACMSIGSOFT 20th InternationalSymposium onthe Foundations ofSoftware
Engineering. ACM, 56.
[25] Everett M Rogers. 2010. Diffusion of innovations. Simon and Schuster.
[26]John R. Rose. 1996. How and When To Deprecate APIs. http:
//www .oracle .com/technetwork/java/javasebusiness/downloads/java-archive-
downloads-javase11-419415 .html#7122-jdk-1 .1-doc-oth-JPR. (1996). last
accessed May 2017.
[27]A.A Sawant, Mauricio Aniche, Arie van Deursen, and Alberto Bacchelli.2017. Replication Package. https://www
.dropbox .com/s/cwchbspdeek6iuh/
replication_package .zip?dl=0. (2017). last accessed May 2017.
[28]AnandAshokSawantandAlbertoBacchelli.2016. fine-GRAPE:fine-grainedAPi
usageextractor–anapproachanddatasettoinvestigateAPIusage. Empirical
Software Engineering (2016), 1–24. https://doi .org/10 .1007/s10664-016-9444-6
[29]A. A. Sawant and A. Bacchelli. 2016. On the reaction to deprecation of 25,357clients of 4+1 popular Java APIs.. In Proceedings of the 32nd IEEE International
Conference on Software Maintenance and Evolution (ICSME) . IEEE press, in press.
[30]LEESIGELAMAN.1981. Question-ordereffectsonpresidentialpopularity. Public
Opinion Quarterly 45, 2 (1981), 199–207.
[31]Sally Thorne, S Reimer Kirkham, Janet MacDonald-Emes, et al .1997. Focus
on qualitative methods. Interpretive description: a noncategorical qualitative
alternative for developing nursing knowledge. Research in nursing & health 20, 2
(1997), 169–177.
[32]LaerteXavier,AlineBrito,AndreHora,andMarcoTulioValente.2017. Historical
and impact analysis of API breaking changes: A large-scale study. In Software
Analysis, Evolution and Reengineering (SANER), 2017 IEEE 24th International
Conference on. IEEE, 138–147.
[33]Zhenchang Xing and Eleni Stroulia. 2007. API-evolution support with Diff-
CatchUp. IEEE Transactions on Software Engineering 33, 12 (2007), 818–836.
571
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:53:54 UTC from IEEE Xplore.  Restrictions apply. 