Putback-Based Bidirectional Model Transformations∗
Xiao He
School of Computer and Communication Engineering,
University of Science and Technology Beijing
Beijing, China
hexiao@ustb.edu.cnZhenjiang Hu
National Informatics Institute/
The University of Tokyo
Tokyo, Japan
hu@nii.ac.jp
ABSTRACT
Bidirectional model transformation (BX) plays a vital role in Model-
Driven Engineering. A major challenge in conventional relational
andbidirectionalization -based BX approaches is the ambiguity is-
sue, i.e., the backward transformation may not be uniquely deter-
mined by the consistency relation or the forward transformation.
A promising solution to the ambiguity issue is to adopt putback -
based bidirectional programming, which realizes a BX by specifying
the backward transformation. However, existing putback -based ap-
proaches do not support multiple conversions of the same node
(namely a shared node). Since a model is a graph, shared nodes are
very common and inevitable. Consequently, existing putback -based
approaches cannot be directly applied to bidirectional model trans-
formation. This paper proposes a novel approach to BX. We define a
new model-merging-based BX combinator, which can combine two
BXs owning shared nodes into a well behaved composite BX. After-
wards, we propose a putback -based BX language XMU to address
the ambiguity issue, which is built on the model-merging-based BX
combinator. We present the formal semantics of XMU which can
be proven well behaved. Finally, a tool support is also introduced
to illustrate the usefulness of our approach.
CCS CONCEPTS
•Software and its engineering →Domain specific languages ;
Specification languages ;
KEYWORDS
bidirectional transformation, model, ambiguity, shared node
ACM Reference Format:
Xiao He and Zhenjiang Hu. 2018. Putback-Based Bidirectional Model Trans-
formations. In Proceedings of the 26th ACM Joint European Software Engineer-
ing Conference and Symposium on the Foundations of Software Engineering
(ESEC/FSE ’18), November 4–9, 2018, Lake Buena Vista, FL, USA. ACM, New
York, NY, USA, 11 pages. https://doi.org/10.1145/3236024.3236070
∗This work was partially supported by the National Key Research and Development
Program of China (Nos. 2017YFB0202303, 2017YFB0202300), by the Japan Society for the
Promotion of Science (JSPS) Grant-in-Aid for Scientific Research (S) No. 17H06099, and
by the National Natural Science Foundation of China (Nos. 2015CB352200, 61620106007,
61472180, 61300009).
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
ESEC/FSE ’18, November 4–9, 2018, Lake Buena Vista, FL, USA
©2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5573-5/18/11. . . $15.00
https://doi.org/10.1145/3236024.32360701 INTRODUCTION
In Model-Driven Engineering (MDE), developers employ various
models to capture different views of the system under development.
Those models are probably interrelated, and may evolve indepen-
dently. When one is updated, the changes should be propagated
to the related models. How to keep these models synchronized is
known to be a crucial issue in a round-trip development.
It has been argued for a long time that bidirectional transforma-
tion (BX) [ 4,31] could provide a software foundation for model syn-
chronization. A BX program is a single program but can be viewed
as a pair of forward and backward transformations, namely getand
put, respectively, where getcreates a view model from a source
model, and putconverts a source model into an updated source
model according to a view model. We have seen good progress in
BX and its application to model synchronization, particularly in the
theoretical foundation [ 5,7], the languages and/or the algorithms
[3,8,12,15,21–23,33], and the applications [ 13,30,34]. There
are basically two approaches to writing BX. One is to ask users
to write a declarative consistency relation (e.g., QVT relations [ 1])
between models, from which a suitable BX (forward and backward
transformations) is derived; And the other is to ask users to write
a forward transformation in a traditional unidirectional language
(e.g., ATL [ 17]) or a domain specific language (e.g., lens [ 11]), from
which a backward transformation is derived.
Despite the promising features of BX for model synchronization,
there is a big issue that prevents it from being used in practice. As
argued in [ 31], the existing bidirectional model transformation lan-
guages have inherited ambiguity in their semantics, and they never
provide any effective way to remove the ambiguity to gain full
control of the synchronization behavior. To be concrete, consider
the classic bidirectional model transformation between UML class
diagrams to Relational Database, namely UML2RDBMS1. We may ask
the user to write a forward transformation in ATL from which a
backward transformation is derived, or a more general flexible con-
sistency relation in QVT from which both forward and backward
transformations are derived. The ATL rule and the QVT relation
are presented in Figure 1. In forward transformation, a table is
created for each non-abstract class. But what about the backward
transformation? There are many possibilities that cause ambiguity.
For instance, if we delete a table and attempt to propagate the table
deletion back to the class model, we may either delete the class that
corresponds to the deleted table, or keep it by changing the class
into an abstract one. The existing approaches automatically return
one as the result. However, if it is not the one we wish to have for
the backward transformation behavior, we have no way to specify
our intention (in ATL or in QVT).
1TheUML2RDBMS transformation has been implemented using QVT [ 1] and ATL (http:
//www.eclipse.org/atl/atlTransformations/#Class2Relational).
434
ESEC/FSE ’18, November 4–9, 2018, Lake Buena Vista, FL, USA Xiao He and Zhenjiang Hu
// ATL rule rule ClassToTable {   from c:uml!Class(     c.isAbstract=false)   to t:rdbms!Table{     t.name <- c.name   }   do {/* inner updates */} }// QVT-R rule relation ClassToTable {   cn:String;   when { PackageToSchema(p,s) }   domain uml p:Package{     classes=c:Class{name=cn,isAbstract=false}}   domain rdbms s:Schema{tables=t:Table{name=cn}}   where {/* inner updates */} }// the first extended XMU rule rule ClassToTable(source p:uml!Package, view s:rdbms!Schema) {   cn:String;   update p:uml!Package{classes=c:uml!Class{name=cn,isAbstract=false}}     with s:rdbms!Schema{tables=t:rdbms!Table{name=cn}} by        match -> {/* inner updates */}      /* Extension 1: delete the unpaired class */       unmatchs -> delete c       unmatchv -> enforce c:uml!Class{} }// the second extended XMU rule rule ClassToTable(source p:uml!Package, view s:rdbms!Schema) {   cn:String;   update p:uml!Package{classes=c:uml!Class{name=cn,isAbstract=false}}     with s:rdbms!Schema{tables=t:rdbms!Table{name=cn}} by        match -> {/* inner updates */}       unmatchs -> enforce c:uml!Class{isAbstract=true}       /* Extension 2: check whether we can turn an abstract class          into a non-abstract one before creating a new class */       unmatchv -> switch(p) {                   case p:uml!Package{classes=c:uml!Class{name=cn,isAbstract=true}} ->                       enforce c:uml!Class{isAbstract=false}                   otherwise -> enforce c:uml!Class{}} }// XMU rule rule ClassToTable(source p:uml!Package, view s:rdbms!Schema) {   cn:String;   update p:uml!Package{classes=c:uml!Class{name=cn,isAbstract=false}}     with s:rdbms!Schema{tables=t:rdbms!Table{name=cn}} by       match -> {/* inner updates */}       unmatchs -> enforce c:uml!Class{isAbstract=true}       unmatchv -> enforce c:uml!Class{} }// patS and patV are defined as follows// patS = p:uml!Package{//    classes=c:uml!Class{name=cn,isAbstract=false}}// patV = s:rdbms!Schema{tables=t:rdbms!Table{name=cn}}updateWithBy patS patV  index sc st (index tc tt (replace patS patV))         delete assoc                                          condition p.classes->exists(sc|sc.name=sn)            (do nothing) enforce sc:uml!Class{name=sn} ;      condition p.classes->exists(tc|tc.name=tn)         (do nothing) enforce tc:uml!Class{name=tn} ;      enforce assoc:uml!Association{name=an,        source=sc:uml!Class{},target=tc:uml!Class{}}}ur→ ua→ b
Figure 1: ATL and QVT realization of ClassToTable
Fortunately, we have an important fact about BX that is little
known: while there are generally many possible backward transfor-
mations for a forward transformation, there is at most one forward
transformation for a backward transformation without ambigu-
ity. In other words, the essence of bidirectional transformation is
nothing but ( putback ) backward transformation [ 10,19,20]. This
putback -based BX approach has been applied to build useful bidi-
rectional transformations between tree-like data [25, 36].
Inspired by the success of the putback -based BX on tree-like
data, we want to go further to see whether we can extend it to
bidirectional model transformation, where models are basically
graphs that may contain shared nodes (and cycles). As a matter
of fact, the shared nodes introduce a new challenge. Consider the
following two putback -based backward transformation rules:
•R1converts
BACABDCDBACBDC into
BACABDCDBACBDC given view node X, and
•R2converts
BACABDCDBACBDC into
BACABDCDBACBDC given view node Y.
When the original source model is
BACABDCDBACBDC and the view model
consists of XandY, we expect to convert the original source and
the view model into
BACABDCDBACBDC , where the shared node Ain the
source model is converted twice by R1andR2. It could not work if
we would apply the two rules in a trivial sequential manner, say
one after another. If R1is applied first, then the intermediate output
is
BACABDCDBACBDCBDC , which cannot trigger R2. Similarly, if R2is applied
first, then the intermediate output is
BACABDCDBACBDCBDCBDC , which rejects
R1. To resolve this problem, we carefully investigated the behavior
of multiple rule applications on graphs, and found that if we could
merge
BACABDCDBACBDCBDC and
BACABDCDBACBDCBDCBDC well then we could get the
expected result. Based on this observation, we propose to treat
multiple conversions of a shared node as independent BXs (in each
BX, this node is converted with an index/label), and then merge
their outputs.
In this paper, we propose a novel bidirectional model transforma-
tion language XMU that can effectively handle both the ambiguity
issue and the shared node issue. XMU is a putback -based BX lan-
guage, enabling developers to define a BX over models in the form of
a backward transformation, and automatically deriving the unique
forward transformation from the backward transformation (and
thus avoiding the ambiguity issue). In addition, XMU is established
on a new model-merging-based BX combinator (rather than the
existing parallel and sequential combinators [ 25]), supporting mul-
tiple conversions of the same node. The main contributions of this
paper are twofolds: 1) a model-merging-based BX combinator to
address the shared node issue; and 2) XMU, a putback -based BX lan-
guage for ambiguity-free model synchronization. The preliminary
results showed the practical feasibility of our approach.The reminder of this paper is organized as follows: Section 2
introduces the background and the related work of this paper; Sec-
tion 3 proposes the model-merging-based BX combinator; Section
4 proposes XMU, a bidirectional model transformation language;
Section 5 presents the formal semantics of XMU; Section 6 intro-
duces the tool support; The last section concludes the paper and
briefly discusses the future work.
2 BACKGROUND AND RELATED WORK
2.1 Background
A bidirectional transformation (BX) can be viewed as a pair of a
forward transformation getand a backward transformation put
between two models.
The forward and backward transformations ( getandput) can
be defined symmetrically [ 7,31] or asymmetrically [ 25].This paper
mainly focuses on asymmetric BXs because in theory, a symmet-
ric BX can be composed of two asymmetric BXs. Without loss of
generality, getandputcan be defined as follows:
дet :S→V (1)
put :S→V→S (2)
where getreads a source model of type (metamodel) S, and creates
a view model of type (metamodel) V; and putyields an updated-
source model by taking the original source and an updated view
model as inputs.
A BX is well behaved if it satisfies the following round-trip
properties:
дets,⊥=⇒puts(дets)=s (GetPut )
puts v,⊥=⇒дet(puts v)=v (PutGet )
puts v,⊥=⇒put(puts v)v=puts v (PutTwice )
where⊥denotes a runtime error or an undefined value in this paper.
TheGetPut property says that if getsucceeds, then no update on
the view leads to no update on the source, the PutGet property
says that if putsucceeds, then update on the view should be fully
put back to the source such that the updated view can be recovered
from the updated source, and the last PutTwice property, which
is derivable from the GetPut andPutGet properties, says that
putting back twice has the same effect of putting back once.
One important fact that is used in this paper, as formally proven
in [10], is that if putis well defined, then there is exactly one get
that can be paired with the putto form a well-behaved BX. We say
putis well defined, iff. (1) ∀s,v(put(puts v)v)=puts v, (2)puts
is injective on view type, and (3) uncurry putis surjective on source
type. This is the foundation of the putback-based bidirectional
programming and the key to ambiguity issues.
2.2 Related Work
Diskin et al. [ 5,7] proposed an algebraic framework of model syn-
chronization. Their work focused on the theoretical aspect of model
synchronization (e.g., the correctness properties).
Giese et al. [ 12] proposed an incremental model synchronization
approach based on Triple Graph Grammar (TGG). Lauder et al.
[22] also proposed TGG-based incremental BX approach based on
the node precedence analysis. Ehrig and Hermann et al. [ 8,15]
discussed the correctness of TGG-based BX approaches. Lamo et al.
435
Putback-Based Bidirectional Model Transformations ESEC/FSE ’18, November 4–9, 2018, Lake Buena Vista, FL, USA
[21] proposed a graph-grammar-based BX approach, which shares
many ideas with TGG-based approaches. These approaches are
typical relational BX approaches that cannot deal with ambiguity
issues properly.
Xiong el al. [ 33] proposed an ATL-based model synchronization
framework. They derive a backward transformation automatically
from a forward ATL transformation. Their approach imposed some
restrictions on the transformation specification and view updating,
e.g., element deletion is not allowed in the view model, to avoid the
ambiguity issue.
Solvers are intensively used to realize BXs. Macedo et al. [ 23]
proposed an Alloy-based approach that turns QVT relations and
ATL rules into BXs over models. The basic idea is to encode QVT
relations and ATL rules into Alloy [ 16] constraints that can be
solved by the Alloy solver. Their approach uses a customizable
graph edit distance (GED) or an operation-based distance (OBD) to
guide the solver to find possible solutions. Semeráth et al. [ 29] also
proposed an Alloy-based backward change propagation approach.
They derive a backward change propagation operation from a model
query. Cicchetti et al. [ 3] proposed a relational BX language named
JTL, and mapped JTL onto Answer Set Programming. In solver-
based approaches, developers may have to iterate the result sets
returned by the solver to obtain the required result. Besides, solver-
based approaches usually do not scale.
Some technologies, such as those in [ 6,9,14], support uncertainty
andvariability in BXs. Those approaches can be adapted for dealing
with the ambiguity issue by asking the user to pick a required result
from a number of candidates.
There are also some research efforts in bidirectional transfor-
mation on tree-like data formats, such as XML. BiXid is a relation-
based bidirectional XML transformation language [ 18]. However,
BiXid cannot handle ambiguity and shared node issues. BiFluX is a
putback-based bidirectional XML transformation language [ 24,25].
BiGUL [ 20] is a general purpose putback -based BX language, which
is a revision of the core of BiFluX .BiFluX and BiGUL enable us
to specify put, i.e., how to update a source according to a view.
Afterwards, a unique getcan be computed automatically from put.
BiFluX and BiGUL are free from the ambiguity issue, but they do
not support multiple conversion of the same node in a graph. So
they cannot handle shared nodes well.
In summary, the state-of-the-art approaches to BX over models
cannot avoid the ambiguity issue. Existing ambiguity-free BX ap-
proaches are mainly designed for tree structures and do not handle
shared graph nodes properly.
3 MODEL-MERGING-BASED BX
COMBINATION
This section address the shared node issue in bidirectional model
(graph) transformation as discussed in the introduction. The basic
idea of our solution is to treat the multiple conversions (transfor-
mations) of the same node as independent component BXs, each of
which converts this node only once. These component BXs are then
combined by merging their outputs. In this way, a BX over models
suffering from the shared node issue can be viewed as a combination
of component BXs, which do not suffer from the shared node issue.
This section proposes a model-merging-based BX combinator.3.1 Metamodel, Model and Merging
We start by explaining metamodels, models and model merging
used in this paper. Generally, a metamodel (written as A,B,etc .)
describes a type of graphs, and a model (written as A,B,etc .) is
viewed as a typed graph that confirms to a metamodel. Concretely,
a model consists of objects (e.g., o1,o2) and links (e.g., l1,l2). We
assume that typeOf is a function that can return the type of an
object or a link (i.e., a class or a relationship defined in a metamodel).
In this paper, a model mis regarded as a typed graph with indices,
in which each object is associated with a set of indices. index m(o)
returns the indices of o.object m(i)returns the object in Mthat
owns the index i. We assume that each index appears once, i.e.,
∀o1,o2(o1,o2⇒index m(o1)∩index m(o2)=∅). We do not as-
sume that indices are persistent attributes. They can be transient
information that is maintained at runtime by BXs.
Given two models aandb, we say a⊑bifbcontains all objects
(including attribute values) and links in a, and we say a=biff
a⊑b∧b⊑a.
We identify two types of model merging, denoted by ⊎and▷.
One is the three-way model merging [ 32],m1⊎m0m2, denoting
merging m1andm2based on a common model m0. The basic idea
is to compute the delta (i.e., changes) δ1andδ2from m0tom1and
m2, respectively. Then, we compute the result by applying both δ1
andδ2tom0. Intuitively, three-way model merging will preserve
all the changes from m0tom1andm2(i.e.,m1⊑m1⊎m0m2∧m2⊑
m1⊎m0m2) when there is no conflict. It is not difficult to verify that
m⊎mm=mandm⊎∅m=m. To determine which objects in m1
andm2should be merged and to calculate the delta, we use object
indices to align models and objects. If index a(o)∩index b(o′),∅,
then oando′are aligned. We may define other alignment strategies
(e.g., using key properties as indices) to extend ⊎. It is our future
work to investigate other possibilities.
The three-way merging may fail when there is a conflict. For
example, assuming that a link l(l≡⟨o,o′⟩) and an object osatisfy
l∈m1∧l<m0ando∈m0∧o<m2,m1⊎m0m2fails (namely
m1⊎m0m2=⊥) because ois required to be preserved by m1but is
deleted in m2.
The other type of model merging is the additive merging, m1▷m0,
denoting merging m1intom0. For every object o∈m1, if there exists
o0∈m0andindex m1(o)∩index m0(o0),∅, then replace o0with o
(and preserve all compatible attributes and links); otherwise, add
oto the result. For each link l∈m1, merge/copy lto the result.
Obviously, m1⊑m1▷m0.
3.2 A Model-Merging-based Combinator
Now we show how to lift the model-merging operation from models
to BXs, which is the key step towards our put-based bidirectional
model transformation.
As required in [ 10] for a well-defined put,puts vmust be injec-
tive for all v, i.e., all information in the view should appear in the
new updated source. In this paper, we relax this condition because
we intend to allow a putto use part of the view to convert the
source model and leave the unused information to other BXs. For
anyput :S→V→S, we assume that there exists a function
core :S→V→Vto capture the partial view from the current
436
ESEC/FSE ’18, November 4–9, 2018, Lake Buena Vista, FL, USA Xiao He and Zhenjiang Hu
source and view:
core s v⊑v (3)
which should satisfy the following properties:
puts v=puts(core s v) (4)
core s v=core(puts v)v (5)
Intuitively, core extracts the necessary view information needed
byput. Note that such function core always exists because we can
know from putwhat view information is needed.
We refine the original PutGet intoPutGet* as follows:
puts v,⊥=⇒дet(puts v)≃core s v (PutGet* )
where≃denotes graph isomorphism. If a BX satisfies PutGet* law,
it is not difficult to verify that the following condition also holds:
∀v1,v2(core s v1,core s v2=⇒puts v1,puts v2). This
condition is the refined condition for injective put. We can also
prove that under the new definitions and conditions, the uniqueness
ofget2for a well-behaved putstill holds. In brief, due to the uncurry
putis surjective on source and PutTwice , for any s, there must
exist a certain vthat makes puts v=s. Afterwards, we can define
дets≡core s v, where vsatisfies puts v=s(i.e., the existence).
Furthermore, for any s, we choose vsuch that puts v=s. If there
is another get’ that can be paired with this put, due to PutGet* ,
дet′s=дet′(puts v)≃core s v≡дets(i.e., the uniqueness).
We are now ready to define our model-merging-based BX com-
binator⊎to combine two BXs bx1≡ (дet1,put 1)andbx2≡
(дet2,put 2)into a composite BX bx=bx1⊎bx2≡(дet,put)as
follows:
дets=дet1s⊎∅дet2s (6)
puts v=put 1s v⊎sput 2s v (7)
The core function of bxis defined as core 1s v⊎∅core 2s v, where
core 1andcore 2are core functions of bx1andbx2. Note that bx1
andbx2can be successfully combined, only when the following
equations hold for any sandv(i=1,2):
putis(дetis)=putis(дet1s⊎∅дet2s) (8)
core i(putis v)v=core i(put 1s v⊎sput 2s v)v (9)
puti(put 1s v⊎sput 2s v)v=put 1s v⊎sput 2s v (10)
core is v=core is(core 1s v⊎∅core 2s v) (11)
дet1(put 1s v)⊎∅дet2(put 2s v)≃core 1s v⊎∅core 2s v (12)
Now, we can prove that a composite BX that is constructed by
using⊎is also well behaved, i.e., Theorem 3.1.
Theorem 3.1 (Correctness of ⊎).Given two well behaved BXs,
namely bx1andbx2, and their core functions, namely core 1and
core 2, when equations (8)-(12) hold, bx=bx1⊎bx2is a well behaved
BX, and the core function of bx, i.e., core 1s v⊎∅core 2s v, satisfies
equations (3)-(5).
In brief, equations (9) and (11) ensure that the composite core
function works properly, and equations (8)-(10), and (12) ensure
that the composite BX is well behaved. Due to space limitation, the
details of the proof are omitted in this paper and are presented at
our project website3.
2getis unique in terms of graph isomorphism.
3https://bitbucket.org/ustbmde/morel/wiki/Home
ABCXYview vsource sput1DBCupdated sources  s1 and s2 (intermediate)updated source (final)put2D1BCD2BCs1]ss2
<latexit sha1_base64="c92+H/bm09WqrxT38D7BX8OfojI=">AAAE73iclVRfaxQxEE/bU+v5p1d99CW4CBWk3F4F9a0oiI8VPFu4PZZsdvYuXDa7JrN3PUO+hw8ivij4TfwKfhuze1fwtkVoYGEy8/v9ZjKzSVJKYbDf/7O1vdO5cfPW7u3unbv37u/19h98NEWlOQx5IQt9ljADUigYokAJZ6UGlicSTpPZmzp+OgdtRKE+4LKEcc4mSmSCM/SuuNczcUijqpSViQ018SDuBf3DfrPoZSNcGwFZr5N4f+d3lBa8ykEhl8yYUdgvcWyZRsEluG5UGSgZn7EJjLypWA5mbJvSHX3iPSnNCu0/hbTx/suwLDdmmScemTOcmnasdl4ZM5gzvdTpVcFRhdnLsRWqrBAUX1WRVZJiQesm0VRo4CiX3mBcC38QyqdMM46+lRtpRIZTUK7bjRQseJHnTKU2UkI6GyGcI6KtN24z7qc1c6PB2FtMTSTYIHTPbDBwkW72LThqkYOegBsdjW2NXQ/MRqv0IA3YCD5VTNrgyFnnk0Ne4tIAutrjau2WaKOIRVNGo6mn6Qq2iZt7y41CD4qa6VgNqdc3vi8lGvEZ7EFzUsNrlafOtRMJlWaV73KtcdET74NzF9eMFrpSwsAqYVQPLkns0AMjKRPf/xkgDfwPq/V616Yn52322TXY2SJt099eJ/ls0aa/vgZ9tlhR6UWX6qnQdokXqP9g5FVKLYy5rOP83Q/bN/2yMRwcvjoM3z8Pjg/Wj8AueUQekwMSkhfkmLwjJ2RIOJmTr+QH+dnRnS+db53vK+j21przkGyszq+/tPK7WA==</latexit><latexit sha1_base64="c92+H/bm09WqrxT38D7BX8OfojI=">AAAE73iclVRfaxQxEE/bU+v5p1d99CW4CBWk3F4F9a0oiI8VPFu4PZZsdvYuXDa7JrN3PUO+hw8ivij4TfwKfhuze1fwtkVoYGEy8/v9ZjKzSVJKYbDf/7O1vdO5cfPW7u3unbv37u/19h98NEWlOQx5IQt9ljADUigYokAJZ6UGlicSTpPZmzp+OgdtRKE+4LKEcc4mSmSCM/SuuNczcUijqpSViQ018SDuBf3DfrPoZSNcGwFZr5N4f+d3lBa8ykEhl8yYUdgvcWyZRsEluG5UGSgZn7EJjLypWA5mbJvSHX3iPSnNCu0/hbTx/suwLDdmmScemTOcmnasdl4ZM5gzvdTpVcFRhdnLsRWqrBAUX1WRVZJiQesm0VRo4CiX3mBcC38QyqdMM46+lRtpRIZTUK7bjRQseJHnTKU2UkI6GyGcI6KtN24z7qc1c6PB2FtMTSTYIHTPbDBwkW72LThqkYOegBsdjW2NXQ/MRqv0IA3YCD5VTNrgyFnnk0Ne4tIAutrjau2WaKOIRVNGo6mn6Qq2iZt7y41CD4qa6VgNqdc3vi8lGvEZ7EFzUsNrlafOtRMJlWaV73KtcdET74NzF9eMFrpSwsAqYVQPLkns0AMjKRPf/xkgDfwPq/V616Yn52322TXY2SJt099eJ/ls0aa/vgZ9tlhR6UWX6qnQdokXqP9g5FVKLYy5rOP83Q/bN/2yMRwcvjoM3z8Pjg/Wj8AueUQekwMSkhfkmLwjJ2RIOJmTr+QH+dnRnS+db53vK+j21przkGyszq+/tPK7WA==</latexit><latexit sha1_base64="c92+H/bm09WqrxT38D7BX8OfojI=">AAAE73iclVRfaxQxEE/bU+v5p1d99CW4CBWk3F4F9a0oiI8VPFu4PZZsdvYuXDa7JrN3PUO+hw8ivij4TfwKfhuze1fwtkVoYGEy8/v9ZjKzSVJKYbDf/7O1vdO5cfPW7u3unbv37u/19h98NEWlOQx5IQt9ljADUigYokAJZ6UGlicSTpPZmzp+OgdtRKE+4LKEcc4mSmSCM/SuuNczcUijqpSViQ018SDuBf3DfrPoZSNcGwFZr5N4f+d3lBa8ykEhl8yYUdgvcWyZRsEluG5UGSgZn7EJjLypWA5mbJvSHX3iPSnNCu0/hbTx/suwLDdmmScemTOcmnasdl4ZM5gzvdTpVcFRhdnLsRWqrBAUX1WRVZJiQesm0VRo4CiX3mBcC38QyqdMM46+lRtpRIZTUK7bjRQseJHnTKU2UkI6GyGcI6KtN24z7qc1c6PB2FtMTSTYIHTPbDBwkW72LThqkYOegBsdjW2NXQ/MRqv0IA3YCD5VTNrgyFnnk0Ne4tIAutrjau2WaKOIRVNGo6mn6Qq2iZt7y41CD4qa6VgNqdc3vi8lGvEZ7EFzUsNrlafOtRMJlWaV73KtcdET74NzF9eMFrpSwsAqYVQPLkns0AMjKRPf/xkgDfwPq/V616Yn52322TXY2SJt099eJ/ls0aa/vgZ9tlhR6UWX6qnQdokXqP9g5FVKLYy5rOP83Q/bN/2yMRwcvjoM3z8Pjg/Wj8AueUQekwMSkhfkmLwjJ2RIOJmTr+QH+dnRnS+db53vK+j21przkGyszq+/tPK7WA==</latexit><latexit sha1_base64="c92+H/bm09WqrxT38D7BX8OfojI=">AAAE73iclVRfaxQxEE/bU+v5p1d99CW4CBWk3F4F9a0oiI8VPFu4PZZsdvYuXDa7JrN3PUO+hw8ivij4TfwKfhuze1fwtkVoYGEy8/v9ZjKzSVJKYbDf/7O1vdO5cfPW7u3unbv37u/19h98NEWlOQx5IQt9ljADUigYokAJZ6UGlicSTpPZmzp+OgdtRKE+4LKEcc4mSmSCM/SuuNczcUijqpSViQ018SDuBf3DfrPoZSNcGwFZr5N4f+d3lBa8ykEhl8yYUdgvcWyZRsEluG5UGSgZn7EJjLypWA5mbJvSHX3iPSnNCu0/hbTx/suwLDdmmScemTOcmnasdl4ZM5gzvdTpVcFRhdnLsRWqrBAUX1WRVZJiQesm0VRo4CiX3mBcC38QyqdMM46+lRtpRIZTUK7bjRQseJHnTKU2UkI6GyGcI6KtN24z7qc1c6PB2FtMTSTYIHTPbDBwkW72LThqkYOegBsdjW2NXQ/MRqv0IA3YCD5VTNrgyFnnk0Ne4tIAutrjau2WaKOIRVNGo6mn6Qq2iZt7y41CD4qa6VgNqdc3vi8lGvEZ7EFzUsNrlafOtRMJlWaV73KtcdET74NzF9eMFrpSwsAqYVQPLkns0AMjKRPf/xkgDfwPq/V616Yn52322TXY2SJt099eJ/ls0aa/vgZ9tlhR6UWX6qnQdokXqP9g5FVKLYy5rOP83Q/bN/2yMRwcvjoM3z8Pjg/Wj8AueUQekwMSkhfkmLwjJ2RIOJmTr+QH+dnRnS+db53vK+j21przkGyszq+/tPK7WA==</latexit>Figure 2: Example of merging-based combinator
Consider the shared node example in the Introduction, as shown
in Figure 2. The original source must be converted by the two
rules R1andR2(i.e., put 1andput 2) simultaneously, as explained
previously. After applying put 1andput 2, we get two intermediate
results, namely s1ands2.s1ands2contain two D-elements (namely
D1andD2, respectively), which were created during put 1andput 2.
If we assign the same index to D1andD2, then by using our model-
merging-based BX combinator ⊎, we finally obtain the expected
output, and the PutGet law holds.
4 XMU: A BIDIRECTIONAL MODEL
TRANSFORMATION LANGUAGE
This section proposes a novel bidirectional model transformation
language, namely XMU, which extends the putback BX approach
with the unique model-merging-based BX combination.
XMU is a rule-based language. The main concrete syntax of
XMU is listed in Figure 3. An XMU rule is defined as a sequence
of formal parameters and a body statement. Each formal parame-
ter is declared as a source/view/normal variable associated with a
type (for a normal variable, its type can only be a primitive type).
XMU statements, which are bidirectional, include update-with-by ,
switch-case and rule call statements. An update-with-by state-
ment, which aligns the matches of source and view patterns first,
has at most three clauses to indicate how to construct the updated
source model according to the result of alignment. A switch-case
statement consists of some branches. A branch condition can be a
pattern or a boolean expression. Unidirectional statements ( uStmt )
of XMU include enforce ,delete node/link and unidirectional
switch-case statements. An enforce statement is responsible to
construct the updated source model, while a delete statement is
used to delete an object or a link from the updated source model. A
unidirectional switch-case statement is similar to its bidirectional
version, however its branch actions must be unidirectional state-
ments. The definition of a model pattern (its syntax and meaning)
in XMU is similar to that in QVT [ 1]. A pattern consists of a set of
nodes and expressions. In the implementation, we extend the syntax
presented in Figure 3 with some syntax sugar and variants to ease
the BX specification. Figure 3 also omits some common language
constructs that are shared by existing programming languages, such
as basic arithmetic, relational and boolean expressions.
437
Putback-Based Bidirectional Model Transformations ESEC/FSE ’18, November 4–9, 2018, Lake Buena Vista, FL, USA
Take the classic conversion between classes and tables as an
example. Figure 4 shows the XMU rule for this conversion, which
corresponds to the ATL rule and QVT relation presented in Figure
1. This XMU rule can be read as follows: update each non-abstract
class cwithin package pwith a table twhose table name is identical
to the class name within schema s; ifcis paired with t, then perform
the inner updates (i.e., the match clause); if ccannot be paired with
any table, then turn cinto an abstract class (i.e., the unmatchs
clause); if tcannot be paired with any class, then create a new class
cthat is intended to be paired with tto continue the conversion
(i.e., the unmatchv clause).
By comparing Figure 1 with Figure 4, we can easily discover the
syntactic correspondence between XMU, ATL and QVT. Neverthe-
less, XMU is semantically different from ATL and QVT because
an XMU rule specifies the backward transformation , rather than a
forward transformation or a consistency relation between source
and view. From the backward transformation, our approach is able
to derive the unique forward transformation from source to view.
For instance, in the forward direction, the behavior of the XMU
rule ClassToTable is identical to that of the ATL and QVT rules in
Figure 1: this XMU rule creates a table for each non-abstract class.
In the forward semantics, the update-with-by statement can be
roughly viewed as the from-to structure in ATL.
Elimination of ambiguity. A benefit of XMU is that it allows
developers to explicitly specify the behavior of putto avoid the
ambiguity issue. Compared with other BX technologies, XMU pro-
vides developers with better control over their BXs. For example,
the XMU rule in Figure 4 can be substituted with either of the two
rules in Figure 5. The first alternative rule will delete the unpaired
class, rather than turning it into an abstract one. The second al-
ternative rule will try to find and change an abstract class into a
non-abstract one before creating a new class for an unpaired table.
Note that forward transformations, which are derived from the
initial XMU rule in Figure 4 and the two alternative rules in Figure
5, are identical to each other.
If we specify this rule as a mapping or a relation, we are unable
to tell the transformation engine which backward semantics is
required, and the ambiguity issue arises.
Addressing shared nodes. Consider a more complicated conver-
sion between associations and foreign keys. We define an XMU
ruleDef::=ruleruleName(fpars){varDec stmt}fpars::=fpars,fpars|sourcev:type|viewv:type|[normal]v:typevarDec::=varDec varDec|v:type;stmt::=updatepatSwithpatVbyclause|switch(v){case}|stmtwhere{index}|ruleName(apars)|stmt1;stmt2|{stmt}clause::=clause clause|match ->stmt|unmatchs ->uStmt|unmatchv ->uStmtcase::=case case|casepat->stmt|caseboolexp->stmtindex::=index,index|index(vs,vv)apars::=apars,apars|expruStmt::=enforcepatS|deletev|deletev.feature=expr|switch(v){uCase}|uStmt1;uStmt2|{uStmt}uCase::=uCase uCase|casepat->uStmt|caseboolexp->uStmtpat::=patNodepatNode::=v:type{patExp}patExp::=feature=patNode|feature=expr|patExp,patExpexpr::= constant|v
<latexit sha1_base64="qLA20QaiEX3soUODare2ttv783I=">AAAImniclVVbaxNBFN5WbWKs2ir6og+DXUsKMSR9USqV0lZQhFLpTciGMDs72yzdGzOzaUNc/J3+AX+HZ2b2kmwS0IU2M9+5f+fMjB37Hhedzu+V1Xv3H6zV6g8bj9YfP3m6sfnskkcJI/SCRH7EftiYU98L6YXwhE9/xIziwPbplX1zJOVXI8q4F4XnYhzTfoCvQ8/1CBYADTbXflk9y6bXXjgR2E58zNIJI37asIbSZcNkiU+PqWui7b29/W1kWoLeCSEmEk8tJH9OcEAtlAuagLoxZryEdtJ8ZU3SEWbHlFiIi0AUcJqaltUwlV0RquKllTs2kfnTLDPRXIBwlCN7qSy1ojby6O1SpV6OhhELsJ/25xVlfjr3IsG8lBxWrip2+e6jrlBWre3RFJlJ7GAhS4ixGJyVJd96YpihlyVqjwEjPk54tUYOBmTYTIscdoBwAuNRIRrJb1vZwn/ViTLmkDKKwM4LHXo3bahj5R1vYtmLnQyVPgbdsli1362kB05V21G173kxGa96u6TGAEOJ6N0npH1VpEmo5FwrJGdSY67givKoomxKxspksEoFzyUiId2ckrxlaWW6dhT59C5epC/jKsaLwDP8t9JMOONWYdDuAW+NBmXTNal45jCpXekNTx0kyIgpC81AdThp6Eb6gKnprKTgUJ+q0R0tFeRIO3UpFgkrpnE/zUPP92bhKCdHlVnWIVXe09OngUXjpyRz86f8FlTpKCgD/63nmrr/aHo5beCsCA3rk8ihOa7WcnCzliy5W6AwUP4MMaapyXwAbJYe5jpQRJGpL5CrDum6ZmO0spgqV62VRyFRyAUOReZzJFWy98SioVO8NA2r3xhsbHXaHfWh+UU3W2wZ2Xc62FxZtZyIJAENBVwQnPe6nVj0J5gJj8Cb1LDgzogxucHXtAfLEO4q3p+opzJFbwFxEAw0/EGCCp22mOCA83FggybcDUNelUlwoQwOMWZj5iwS9hLhfujDaY0TQUOis3ATH4kIyT4ix2OUCH8MC0yYB4UgMsQMEwFP90wYzxVDGqbAWrfK0fzicrfd7bS733e3Dg4z/urGK+ON0TS6xnvjwPhinBoXBln7U1uvvai9rL+uH9a/1r9p1dWVzOa5MfPVz/8CjNniFA==</latexit><latexit sha1_base64="qLA20QaiEX3soUODare2ttv783I=">AAAImniclVVbaxNBFN5WbWKs2ir6og+DXUsKMSR9USqV0lZQhFLpTciGMDs72yzdGzOzaUNc/J3+AX+HZ2b2kmwS0IU2M9+5f+fMjB37Hhedzu+V1Xv3H6zV6g8bj9YfP3m6sfnskkcJI/SCRH7EftiYU98L6YXwhE9/xIziwPbplX1zJOVXI8q4F4XnYhzTfoCvQ8/1CBYADTbXflk9y6bXXjgR2E58zNIJI37asIbSZcNkiU+PqWui7b29/W1kWoLeCSEmEk8tJH9OcEAtlAuagLoxZryEdtJ8ZU3SEWbHlFiIi0AUcJqaltUwlV0RquKllTs2kfnTLDPRXIBwlCN7qSy1ojby6O1SpV6OhhELsJ/25xVlfjr3IsG8lBxWrip2+e6jrlBWre3RFJlJ7GAhS4ixGJyVJd96YpihlyVqjwEjPk54tUYOBmTYTIscdoBwAuNRIRrJb1vZwn/ViTLmkDKKwM4LHXo3bahj5R1vYtmLnQyVPgbdsli1362kB05V21G173kxGa96u6TGAEOJ6N0npH1VpEmo5FwrJGdSY67givKoomxKxspksEoFzyUiId2ckrxlaWW6dhT59C5epC/jKsaLwDP8t9JMOONWYdDuAW+NBmXTNal45jCpXekNTx0kyIgpC81AdThp6Eb6gKnprKTgUJ+q0R0tFeRIO3UpFgkrpnE/zUPP92bhKCdHlVnWIVXe09OngUXjpyRz86f8FlTpKCgD/63nmrr/aHo5beCsCA3rk8ihOa7WcnCzliy5W6AwUP4MMaapyXwAbJYe5jpQRJGpL5CrDum6ZmO0spgqV62VRyFRyAUOReZzJFWy98SioVO8NA2r3xhsbHXaHfWh+UU3W2wZ2Xc62FxZtZyIJAENBVwQnPe6nVj0J5gJj8Cb1LDgzogxucHXtAfLEO4q3p+opzJFbwFxEAw0/EGCCp22mOCA83FggybcDUNelUlwoQwOMWZj5iwS9hLhfujDaY0TQUOis3ATH4kIyT4ix2OUCH8MC0yYB4UgMsQMEwFP90wYzxVDGqbAWrfK0fzicrfd7bS733e3Dg4z/urGK+ON0TS6xnvjwPhinBoXBln7U1uvvai9rL+uH9a/1r9p1dWVzOa5MfPVz/8CjNniFA==</latexit><latexit sha1_base64="qLA20QaiEX3soUODare2ttv783I=">AAAImniclVVbaxNBFN5WbWKs2ir6og+DXUsKMSR9USqV0lZQhFLpTciGMDs72yzdGzOzaUNc/J3+AX+HZ2b2kmwS0IU2M9+5f+fMjB37Hhedzu+V1Xv3H6zV6g8bj9YfP3m6sfnskkcJI/SCRH7EftiYU98L6YXwhE9/xIziwPbplX1zJOVXI8q4F4XnYhzTfoCvQ8/1CBYADTbXflk9y6bXXjgR2E58zNIJI37asIbSZcNkiU+PqWui7b29/W1kWoLeCSEmEk8tJH9OcEAtlAuagLoxZryEdtJ8ZU3SEWbHlFiIi0AUcJqaltUwlV0RquKllTs2kfnTLDPRXIBwlCN7qSy1ojby6O1SpV6OhhELsJ/25xVlfjr3IsG8lBxWrip2+e6jrlBWre3RFJlJ7GAhS4ixGJyVJd96YpihlyVqjwEjPk54tUYOBmTYTIscdoBwAuNRIRrJb1vZwn/ViTLmkDKKwM4LHXo3bahj5R1vYtmLnQyVPgbdsli1362kB05V21G173kxGa96u6TGAEOJ6N0npH1VpEmo5FwrJGdSY67givKoomxKxspksEoFzyUiId2ckrxlaWW6dhT59C5epC/jKsaLwDP8t9JMOONWYdDuAW+NBmXTNal45jCpXekNTx0kyIgpC81AdThp6Eb6gKnprKTgUJ+q0R0tFeRIO3UpFgkrpnE/zUPP92bhKCdHlVnWIVXe09OngUXjpyRz86f8FlTpKCgD/63nmrr/aHo5beCsCA3rk8ihOa7WcnCzliy5W6AwUP4MMaapyXwAbJYe5jpQRJGpL5CrDum6ZmO0spgqV62VRyFRyAUOReZzJFWy98SioVO8NA2r3xhsbHXaHfWh+UU3W2wZ2Xc62FxZtZyIJAENBVwQnPe6nVj0J5gJj8Cb1LDgzogxucHXtAfLEO4q3p+opzJFbwFxEAw0/EGCCp22mOCA83FggybcDUNelUlwoQwOMWZj5iwS9hLhfujDaY0TQUOis3ATH4kIyT4ix2OUCH8MC0yYB4UgMsQMEwFP90wYzxVDGqbAWrfK0fzicrfd7bS733e3Dg4z/urGK+ON0TS6xnvjwPhinBoXBln7U1uvvai9rL+uH9a/1r9p1dWVzOa5MfPVz/8CjNniFA==</latexit>
Figure 3: Concrete Syntax of XMU
// ATL rule rule ClassToTable {   from c:uml!Class(     c.isAbstract=false)   to t:rdbms!Table{     t.name <- c.name   }   do {/* inner updates */} }// QVT-R rule relation ClassToTable {   cn:String;   when { PackageToSchema(p,s) }   domain uml p:Package{     classes=c:Class{name=cn,isAbstract=false}}   domain rdbms s:Schema{tables=t:Table{name=cn}}   where {/* inner updates */} }// the first extended XMU rule rule ClassToTable(source p:uml!Package, view s:rdbms!Schema) {   cn:String;   update p:uml!Package{classes=c:uml!Class{name=cn,isAbstract=false}}     with s:rdbms!Schema{tables=t:rdbms!Table{name=cn}} by        match -> {/* inner updates */}      /* Extension 1: delete the unpaired class */       unmatchs -> delete c       unmatchv -> enforce c:uml!Class{} }// the second extended XMU rule rule ClassToTable(source p:uml!Package, view s:rdbms!Schema) {   cn:String;   update p:uml!Package{classes=c:uml!Class{name=cn,isAbstract=false}}     with s:rdbms!Schema{tables=t:rdbms!Table{name=cn}} by        match -> {/* inner updates */}       unmatchs -> enforce c:uml!Class{isAbstract=true}       /* Extension 2: check whether we can turn an abstract class          into a non-abstract one before creating a new class */       unmatchv -> switch(p) {                   case p:uml!Package{classes=c:uml!Class{name=cn,isAbstract=true}} ->                       enforce c:uml!Class{isAbstract=false}                   otherwise -> enforce c:uml!Class{}} }// XMU rule rule ClassToTable(source p:uml!Package, view s:rdbms!Schema) {   cn:String;   update p:uml!Package{classes=c:uml!Class{name=cn,isAbstract=false}}     with s:rdbms!Schema{tables=t:rdbms!Table{name=cn}} by       match -> {/* inner updates */}       unmatchs -> enforce c:uml!Class{isAbstract=true}       unmatchv -> enforce c:uml!Class{} }// patS and patV are defined as follows// patS = p:uml!Package{//    classes=c:uml!Class{name=cn,isAbstract=false}}// patV = s:rdbms!Schema{tables=t:rdbms!Table{name=cn}}updateWithBy patS patV  index sc st (index tc tt (replace patS patV))         delete assoc                                          condition p.classes->exists(sc|sc.name=sn)            (do nothing) enforce sc:uml!Class{name=sn} ;      condition p.classes->exists(tc|tc.name=tn)         (do nothing) enforce tc:uml!Class{name=tn} ;      enforce assoc:uml!Association{name=an,        source=sc:uml!Class{},target=tc:uml!Class{}}}ur→ ua→ bFigure 4: XMU Rule ClassToTable
rule AssocToFKey (as shown in Figure 6) to update each associa-
tion between two classes with a foreign key between two tables.
If an association cannot be paired with any foreign key, we must
delete this association. If a foreign key cannot be paired with any
association, we must create an association. Before creating a new
association, we must check whether the related classes exist in the
source model and create the absent class(es) if necessary to ensure
the successful creation of this association.
The execution of an XMU program is based upon the model-
merging-based BX combination. Informally, each XMU state-
ment/rules (e.g., an update-with statement) is viewed as a primi-
tive BX. A sequence of XMU statements/rules are combined by ⊎
defined in Section 3. However, when an object is converted multiple
times, the shared issue may arise and the BX combination may fail.
Assume that we merge the XMU rules ClassToTable in Figure 4
and AssocToFKey in Figure 6 (i.e., ClassToTable⊎AssocToFKe y).
Given the source model m0and the view model as shown in Figure
7, we obtain two updated source models m1andm2by applying
ClassToTable andAssocToFKey , respectively. Although a human can
easily know that class s3inm1and class s4inm2are conceptually
identical (they are both derived from table t3), the model merging
operator⊎will treat them as two distinct objects because they
have different indices. Consequently, m1⊎m0m2will contain three
classes, and the combination of ClassToTable andAssocToFKey is
invalid ( PutGet* law will be violated).
// ATL rule rule ClassToTable {   from c:uml!Class(c.isAbstract=false)   to t:rdbms!Table{     t.name <- c.name   }   do {/* inner updates */} }
// the first alternative rule rule ClassToTable(source p:uml!Package, view s:rdbms!Schema) {   cn:String;   update p:uml!Package{classes=c:uml!Class{name=cn,isAbstract=false}}     with s:rdbms!Schema{tables=t:rdbms!Table{name=cn}} by        match -> {/* inner updates */}      /* delete the unpaired class */       unmatchs -> delete c       unmatchv -> enforce c:uml!Class{} }// QVT-R rule relation ClassToTable {   cn:String;   when { PackageToSchema(p,s) }   domain uml p:Package{classes=c:Class{         name=cn,isAbstract=false}}   domain rdbms s:Schema{tables=t:Table{name=cn}}   where {/* inner updates */} }
// the second alternative rule rule ClassToTable(source p:uml!Package, view s:rdbms!Schema) {   cn:String;   update p:uml!Package{classes=c:uml!Class{name=cn,isAbstract=false}}     with s:rdbms!Schema{tables=t:rdbms!Table{name=cn}} by        match -> {/* inner updates */}       unmatchs -> enforce c:uml!Class{isAbstract=true}       /* check whether there is an abstract class that can be turned          into a non-abstract one before creating a new class */       unmatchv -> switch(p) {                   case p:uml!Package{classes=c:uml!Class{name=cn, isAbstract=true}} ->                       enforce c:uml!Class{isAbstract=false}                   otherwise -> enforce c:uml!Class{}} }// XMU rule rule ClassToTable(source p:uml!Package, view s:rdbms!Schema) {   cn:String;   update p:uml!Package{classes=c:uml!Class{name=cn,isAbstract=false}}     with s:rdbms!Schema{tables=t:rdbms!Table{name=cn}} by       match -> {/* inner updates */}       unmatchs -> enforce c:uml!Class{isAbstract=true}       unmatchv -> enforce c:uml!Class{} }
Figure 5: Alternative XMU rules to ClassToTable
438
ESEC/FSE ’18, November 4–9, 2018, Lake Buena Vista, FL, USA Xiao He and Zhenjiang Hu
s1:Packages2:Classname=‘A’ isAbstract=falseclasses
t1:Schemat3:Tablename=‘B’tablest2:Tablename=‘A’tablest4:ForeignKeyname=‘R’foreignKeysreferTos1:Packages2:Classname=‘A’ isAbstract=falseclassess3:Classname=‘B’ isAbstract=falseclasses
s1:Packages2:Classname=‘A’ isAbstract=falseclassess4:Classname=‘B’s5:Associationname=‘R’associationssourcetargetClassToTable
AssocToFKeyduplicateviewm0sourcem1updated source
m2updated sourceclassesrule AssocToFKey(source p:uml!Package, view s:rdbms!Schema) {   sn, tn, an:String;   update p:uml!Package{associations=assoc:uml!Association{name=an,       source=sc:uml!Class{name=sn}, target=tc:uml!Class{name=tn}}}     with s:rdbms!Schema{tables=st:rdbms!Table{name=sn,       foreignKeys=f:ForeignKey{name=an,referTo=tt:rdbms!Table{name=tn}}}} by       match -> {}       unmatchs -> delete assoc       unmatchv -> switch(p) {                              case p:uml!Package{classes=sc:uml!Class{name=sn} -> {}                              otherwise -> enforce sc:uml!Class{name=sn}                            };                            switch(p) {                              case p:uml!Package{classes=tc:uml!Class{name=tn} -> {}                              otherwise -> enforce tc:uml!Class{name=tn}                            };                            enforce assoc:uml!Association{name=an,                              source=sc:uml!Class{}, target=tc:uml!Class{}} }
Figure 6: Rule AssocToFKey
To ensure that⊎works properly, XMU provides an index func-
tion to compute object indices. For instance, during the backward
transformation, index(c,t) computes an extra index iaccording
to the indices of candtand maps ionto cin the result. If the in-
dex of cis unused in the source model, its index is treated as nil
during the computation. In forward transformation, index(c,t)
computes and maps an index onto taccording to the index of c.
Figure 8 shows the use of the index function. We add some index
functions within where clauses appended to the match branches.
When constructing the updated source models (from the same
source and view in Figure 7), we compute an extra index for each
class (the extra index computed by the index function is denoted
as the concatenation of the function parameters). Class s3inm1
and class s4inm2are mapped onto the same index, namely nil-t3
(since neither s3nors4exists in m0). In this way, m1⊎m0m2will
contain only two classes, and ClassToTable⊎AssocToFKe yis valid.
It is worthwhile to notice that rule ClassToTable and rule As-
socToFKey cannot be applied sequentially. Otherwise, we will not
get the expected result. As shown in Figure 9, assume that the orig-
inal source model m0contains two classes (namely AandB) that
are connected by an association R; The view model contains table
duplicatet1:Schemat3:Tablename=‘B’tablest2:Tablename=‘A’tablest4:ForeignKeyname=‘R’foreignKeysreferToviews1:Packages2:Classname=‘A’ isAbstract=falseclassesm0sources1:Packages2:Classname=‘A’ isAbstract=falseclassess3:Classname=‘B’ isAbstract=falseclassesm1updated source
s1:Packages2:Classname=‘A’ isAbstract=falseclassess4:Classname=‘B’s5:Associationname=‘R’associationssourcetargetm2updated sourceclassesClassToTable
AssocToFKeyrule AssocToFKey(source p:uml!Package, view s:rdbms!Schema) {   sn, tn, an:String;   update p:uml!Package{associations=assoc:uml!Association{name=an,       source=sc:uml!Class{name=sn}, target=tc:uml!Class{name=tn}}}     with s:rdbms!Schema{tables=st:rdbms!Table{name=sn,       foreignKeys=f:ForeignKey{name=an,referTo=tt:rdbms!Table{name=tn}}}} by       match -> {}       unmatchs -> delete assoc       unmatchv -> switch(p) {                              case p:uml!Package{classes=sc:uml!Class{name=sn} -> {}                              otherwise -> enforce sc:uml!Class{name=sn}                            };                            switch(p) {                              case p:uml!Package{classes=tc:uml!Class{name=tn} -> {}                              otherwise -> enforce tc:uml!Class{name=tn}                            };                            enforce assoc:uml!Association{name=an,                              source=sc:uml!Class{}, target=tc:uml!Class{}} }
Figure 7: A shared node issue in UML2RDBMS
rule AssocToFKey(source p:uml!Package,     view s:rdbms!Schema){   sn, tn, an:String;   update p:uml!Package{     associations=assoc:uml!Association{       name=an,source=sc:uml!Class{name=sn},          target=tc:uml!Class{name=tn}}}     with s:rdbms!Schema{       tables=st:rdbms!Table{name=sn,         foreignKeys=f:ForeignKey{name=an,         referTo=tt:rdbms!Table{name=tn}}}} by       match -> {}          where {index(sc,st);index(tc,tt)}       ... }rule ClassToTable(source p:uml!Package,      view s:rdbms!Schema) {   cn:String;   update p:uml!Package{      classes=c:uml!Class{        name=cn,isAbstract=false}}     with s:rdbms!Schema{      tables=t:rdbms!Table{name=cn}} by       match -> {/* inner updates */}         where {index(c,t)}       ... }
mergeables1:Packages2,s2-t2:Classname=‘A’ isAbstract=falseclassess3,nil-t3:Classname=‘B’ isAbstract=falseclassesm1updated sourcem2updated sources1:Packages2,s2-t2:Classname=‘A’ isAbstract=falseclassess4,nil-t3:Classname=‘B’s5:Associationname=‘R’associationssourcetargetclassesFigure 8: Index computation
s1:Packages2:Classname=‘A’ isAbstract=falseclassess1:Packages2:Classname=‘A’ isAbstract=falseclassess3:Classname=‘B’ isAbstract=falseclasses
AssocToFKeyduplicatet1:Schemat2:Tablename=‘A’tablesview
m0sourcem1updated sources1:Packages2:Classname=‘A’ isAbstract=falseclassess3:Classname=‘B’s4:Associationname=‘R’associationssourcetargetm0sourceclassesClassToTables1:Packages2:Classname=‘A’ isAbstract=falseclasses
s4:Associationname=‘R’associationssourcem1updated source
Figure 9: AssocToFKey will fail after ClassToTable
Aonly, and table Band the foreign key from table Ato table Bwere
removed (please refer to the view model as shown in Figure 7). If
we apply ClassToTable against m0in the backward direction first,
then we get an (intermediate) updated source m1in which class B
was removed. However, in this case, we cannot continue to perform
AssocToFKey backward against m1because the source pattern of the
update statement in AssocToFKey (as shown in Figure 6) cannot be
matched. This source pattern matches an association that connects
two classes, while in m1in Figure 9, the association Rconnects
class Aonly. The final result, which is equal to m1and contains
class Aand an unwanted association R, is incorrect. The only way
of obtaining the expected result is to combine ClassToTable and
AssocToFKey by using our model-merging-based BX combinator,
i.e., applying ClassToTable andAssocToFKey against m0in parallel
and then merging the two results.
439
Putback-Based Bidirectional Model Transformations ESEC/FSE ’18, November 4–9, 2018, Lake Buena Vista, FL, USA
b::=updateWithBypatSpatVbucur|ifThenElsefb1b2u::=enforcepatS|replacepatSpatV|matchSpatSb|matchVpatVb|deletev|deletevf e a t u r ee|indexvSvVb|P(e1,. . . ,en)|b1;b2|conditioneu1u2|u1;u2
<latexit sha1_base64="ql0bA3P+YcIDlHIXqLBV2qG40Nc=">AAAG5niclVTNjts2EFacxkndn2TbYy9E7QYbYGFYziFFigLBFg1y6GGLZH8A0xAoamQTpiiVpHbX1fIVeihQ5JAc8hJ9gx76Cr31UTqUvLu2vCiwBEQNh9/3zWiGVFxIYexo9M+dzt2P7nXvP/i498mnn33+8NHOF0cmLzWHQ57LXJ/EzIAUCg6tsBJOCg0siyUcx4sf/P7xKWgjcvXGLguYZmymRCo4s+iKdjr3aAwzoSrL4lIy7SrN5QU+rkfnXrQ3iAfkMXn+/HucB9TCubW2KouEWTgWdr6/dJQUzEavm9cRJTElZcT9pCm5oOSSJNI3c1A/SgNISREXhX4ae/1BeUMUUGmOn3kZYEBpj+BAxMWArAM1FJJdA68yWQueMcvnr68R8fbukbv+BJ9NE2ctTAISrI9yukFed6fAbKmBEmiyfUy2khUqgXOP9mmcrgqGcge7EIV7w+FwDyL1pHb5Cq1Y37lVpbay4rlKhO8maoKveuincS1Qrgug0ye16isFlVx1PXrUHw1H9SDbRrgy+i9++vOvf4MgOIh27v5Nk5yXGSjLJTNmEo4KO62YtoJLwNNTGigYX7AZTNBULAMzreoD68g36EkINhcfZUntXWdULDNmmcWIxM7MTXvPO2/cMzZjeqmTmzYnpU2/nWL5i9KC4k0WaSmJzYm/GiQRGriVSzQY11hSTvicacYtXqCNMCK1eJJdr0cVnPE8yxjWkiohXXVZbr9wm/tY9oWbjKdoMTWTUPVDt1f1x47qet2CWy0y0DNwk6fTymNpWcjSRBVtwgNepIrCLyWTVf+pqxwGh6ywSwPWeY/z2i3RWtHmdRq1pp4nDWwTd4qWm4QIonV38IolqG+wLoU14leodusvNdyrPHGuHQhPeVpilb3G5smPPKOFLpUw0ASkvnFxXB0ikEoZY/0XYEk/JFTr1apNj8/b7JNbsNOzpE1/eZvgi7M2ff8W9MVZQ736nfiukHaKl6j/wciblFoYs63j737YvunbxtF4GI6G4c/4E9gPmvEg+Cr4OtgNwuBZ8CJ4FRwEhwHvyM7vnXed991597fuH923DbRzZ8X5MtgY3Q//AYUAZyQ=</latexit><latexit sha1_base64="qssTOA3IQBHYOS/DjmeaZJ/ArbY=">AAAG5niclVRPj+M0FM922bKUBXbgyMWiZTUrjaqme9jVrpBWg0AcOAzanT9SXUWO89JadZys7cxMyVh8Aw5IiAMc+BKcuXDgK3DlK/AFeE46M206WmksxXl+/v1+7+U9O3EhhbGj0T93Onffudd99/57vfcffPDhRw93Pj4yeak5HPJc5vokZgakUHBohZVwUmhgWSzhOF586fePT0EbkavXdlnANGMzJVLBmUVXtNO5R2OYCVVZFpeSaVdpLi/wcT0696K9QTwgj8jz51/gPKAWzq21VVkkzMKxsPP9paOkYDZ61byOKIkpKSPuJ03JBSWXJJG+noP6ShpASoq4KPTT2OsPyhuigEpz/MzLAANKewQHIi4GZB2ooZDsGniVyVrwjFk+f3WNiLd3j9z1J/hsmjhrYRKQYH2U0w3yujsFZksNlECT7SOylaxQCZx7tE/jdFUwlDvYhSjcGw6HexCpx7XLV2jFeuFWldrKiucqEb6bqAm+6qGfxrVAuS6ATp/Uqq8UVHLV9ehhfzQc1YNsG+HK6L/89o+//v3vhz8Pop27f9Mk52UGynLJjJmEo8JOK6at4BLw9JQGCsYXbAYTNBXLwEyr+sA68jl6EoLNxUdZUnvXGRXLjFlmMSKxM3PT3vPOG/eMzZhe6uSmzUlp02dTLH9RWlC8ySItJbE58VeDJEIDt3KJBuMaS8oJnzPNuMULtBFGpBZPsuv1qIIznmcZw1pSJaSrLsvtF25zH8u+cJPxFC2mZhKqfuj2qv7YUV2vW3CrRQZ6Bm7yZFp5LC0LWZqook14wItUUXhTMln1n7jKYXDICrs0YJ33OK/dEq0VbV6nUWvqedLANnGnaLlJiCBadwevWIL6ButSWCO+h2q3/lLDvcpj59qB8JSnJVbZa2ye/MgzWuhSCQNNQOobF8fVIQKplDHWfwGW9ENCtV6t2vT4vM0+uQU7PUva9K9vE3xx1qbv34K+OGuoV78T3xXSTvES9RaMvEmphTHbOv7uh+2bvm0cjYfhaBh+hz+B/aAZ94NPg8+C3SAMngYvg2+Cg+Aw4B3Z+anza+e37rz7Y/fn7i8NtHNnxfkk2Bjd3/8H+xZpVw==</latexit><latexit sha1_base64="KCrgSRr5iaZrLOBUmfDy0XwYjAo=">AAAG5niclVTNjts2EFacxk3cn2TbYy5E7QYbYGFYzqFFigLBBi163CLZH8A0BIoa2YQpSiWp3XW1fIUeAhQ9tIc+Tl+hb9OhpN215UWBJSBqOPy+b0YzpOJCCmMnk38f9B5+9Kj/8eMng08+/ezzp8/2vjgxeak5HPNc5vosZgakUHBshZVwVmhgWSzhNF699fun56CNyNV7uy5gnrGFEqngzKIr2us9ojEshKosi0vJtKs0l1f4uAFdetHBKB6RF+T16+9xHlELl9baqiwSZuFU2OXh2lFSMBu9a14nlMSUlBH3k6bkipJrkkjfL0H9IA0gJUVcFPpp6vVH5R1RQKU5fuZ1gBGlA4IDEVcjsgnUUEh2C7zJZCN4xixfvrtFxLu7J+72E3w2TZyNMAlIsD7K+RZ5050Cs6UGSqDJ9gXZSVaoBC492qdx3hYM5Y72IQoPxuPxAUTqZe3yFWpZ37m2UjtZ8VwlwncTNcFXPfTTtBYoNwXQ6ZNq+0pBJTddj54NJ+NJPciuEbbGMGjHUbT38B+a5LzMQFkumTGzcFLYecW0FVwCnp7SQMH4ii1ghqZiGZh5VR9YR75GT0KwufgoS2rvJqNimTHrLEYkdmZpunveeeeesRnTa53ctTkrbfrtHMtflBYUb7JIS0lsTvzVIInQwK1co8G4xpJywpdMM27xAm2FEanFk+wGA6rggudZxrCWVAnpquty+4Xb3seyr9xsOkeLqYWEahi6g2o4dVTX6w7capGBXoCbvZpXHkvLQpYmqmgTHvAiVRR+KZmshq9c5TA4ZIVdG7DOe5zX7ojWijav06g19TJpYNu4c7TcLEQQrbuDVyxBfYN1KawRv0K1X3+p4V7lpXPdQHjK0xKr7DW2T37kGR10qYSBJiD1jYvj6hiBVMoY678CS4YhoVq3qy49vuyyz+7BTi+SLv3H+wRfXXTph/egry4a6s3vxHeFdFO8Rv0PRt6l1MGYXR1/98PuTd81TqbjcDIOf54M3xy2f4HHwfPgq2A/CINvgjfBT8FRcBzwnux96P3Z+6u/7P/W/73/RwPtPWg5XwZbo//3fwePZD8=</latexit>
Figure 10: Core Language of XMU
5 SEMANTICS OF XMU
The concrete syntax of XMU in Figure 3 is designed for users, but it
would be too complex to define the semantics directly on it. Rather,
we propose a core language for XMU (namely XMU core), whose
semantics is easier to define. XMU core is defined in Figure 10, where
bdenotes a bidirectional statement and udenotes a unidirectional
statement.
The conversion between the concrete syntax of XMU and XMU
core is straightforward, as follows: update-with-by is converted
intoupdateWithBy ;switch-case is converted into ifThenElse (a
pattern used as a branch condition can also be viewed as a boolean
condition [ 1]);where-index is converted into index ;replace ,
matchS andmatchV are used to realize bidirectional conversions
implied by update-with-by andswitch-case .
Take rule AssocToFKey as a concrete example. The concrete syn-
tax of AssocToFKey has been presented in Figure 6 and Figure 8. This
rule can be equivalently translated into an updateWithBy statement
in XMU core, as shown in Figure 11. The bidirectional statement b
of the updateWithBy statement is a replace statement wrapped
by two index statements. The two unidirectional statements ua
andurof the updateWithBy statement are a delete statement and
a chain of two condition s and an enforce statement.
// ATL rulerule ClassToTable {  from c:uml!Class(    c.isAbstract=false)  to t:rdbms!Table{    t.name <- c.name  }  do {/* inner updates */}}// QVT-R rulerelation ClassToTable {  cn:String;  when { PackageToSchema(p,s) }  domain uml p:Package{    classes=c:Class{name=cn,      isAbstract=false}}  domain rdbms s:Schema{    tables=t:Table{name=cn}}  where {/* inner updates */}}// the first extended XMU rulerule ClassToTable(source p:uml!Package, view s:rdbms!Schema) {  cn:String;  update p:uml!Package{classes=c:uml!Class{name=cn,isAbstract=false}}    with s:rdbms!Schema{tables=t:rdbms!Table{name=cn}} by       match -> {/* inner updates */}     /* Extension 1: delete the unpaired class */      unmatchs -> delete c      unmatchv -> enforce c:uml!Class{}}// the second extended XMU rulerule ClassToTable(source p:uml!Package, view s:rdbms!Schema) {  cn:String;  update p:uml!Package{classes=c:uml!Class{name=cn,isAbstract=false}}    with s:rdbms!Schema{tables=t:rdbms!Table{name=cn}} by       match -> {/* inner updates */}      unmatchs -> enforce c:uml!Class{isAbstract=true}      /* Extension 2: check whether we can turn an abstract class         into a non-abstract one before creating a new class */      unmatchv -> switch(p) {                  case p:uml!Package{classes=c:uml!Class{name=cn,                    isAbstract=true}} ->                      enforce c:uml!Class{isAbstract=false}                  otherwise -> enforce c:uml!Class{}}}// XMU rulerule ClassToTable(source p:uml!Package, view s:rdbms!Schema) {  cn:String;  update p:uml!Package{classes=c:uml!Class{name=cn,isAbstract=false}}    with s:rdbms!Schema{tables=t:rdbms!Table{name=cn}} by      match -> {/* inner updates */}      unmatchs -> enforce c:uml!Class{isAbstract=true}      unmatchv -> enforce c:uml!Class{}}// patS and patV are defined as follows// patS = p:uml!Package{//    classes=c:uml!Class{name=cn,isAbstract=false}}// patV = s:rdbms!Schema{tables=t:rdbms!Table{name=cn}}updateWithBy patS patV  index sc st (index tc tt (replace patS patV))         delete assoc                                          condition p.classes->exists(sc|sc.name=sn)            (do nothing) enforce sc:uml!Class{name=sn} ;      condition p.classes->exists(tc|tc.name=tn)         (do nothing) enforce tc:uml!Class{name=tn} ;      enforce assoc:uml!Association{name=an,        source=sc:uml!Class{},target=tc:uml!Class{}}}ur→ ua→ b
Figure 11: Translation of rule AssocToFKey
An XMU transformation can be compiled into an XMU core
program, which can further be executed according to the semantics
defined in Figure 12. It is worthwhile emphasizing that we do not
claim that the core language we proposed is complete. In fact, XMU
core should be further refined and extended to cover more appli-
cation scenarios (such as delta-based BXs). The reminder of this
section will discuss the semantics of the core language in detail.
5.1 Variable, Environment and Pattern
A variablevin XMU core is viewed as an identifier associated with
a type. A variable type can be a primitive type (e.g., integer) or
an index type (if this variable will be pointed to an object). An
environment γis a set of mappings from variables to values. Γ
denotes the set of all environments. We assume that γ(v)returnsthe value assigned to v, andγ[v:=c]adds a mapping from vtoc.
Besides,γ(v)=⊥means that vis unassigned in γ.
In XMU core, model patterns are used to find matches and to
create model fragments. XMU core adopts the conventional seman-
tics of pattern matching and instantiation that is widely used in
existing model transformation languages (such as QVT). We mainly
explain some properties in this subsection.
We term an environment γa match of a pattern patif all the
variables occurring in pat(namely pattern variables, denoted by
vars(pat)) are assigned in γ, and if the values assigned to pattern
variables satisfy all the constraints implied by pat(as explained in
[1], a pattern can be viewed as some constraints). Given an initial
environment γ,pat(γ,M)returns all matches of a pattern patin
a model Mbased onγ. Each returned environment γ′satisfies
the condition∀v(v<vars(pat)∨γ(v),⊥=⇒γ′(v)=γ(v)).
Instantiating a pattern patbased on an environment γ(denoted as
M=pat .new(γ)) is to create a model fragment Mthat matches pat
using the information provided by γ. Obviously, pattern matching
and instantiation satisfy the following properties:
γ′∈pat(γ,M)=⇒M=(pat .new(γ′)▷M)
M′=pat .new(γ)▷M=⇒γ∈pat(γ,M′)
For simplicity, given variable v, if the type of vis the index type
andγ(v)=⊥, then we assume that γis automatically replaced
byγ[v:=idx]during pattern instantiation, where idxa fresh and
unused object index.
5.2 Unidirectional Statements
A unidirectional statement can convert a source model into an
updated source model without considering the view model. Unidi-
rectional statements will never be executed in the forward trans-
formation. Given a unidirectional statement u,Uγ
JuK:S→S×Γ
denotes the semantics of uunder the environment γ. For an ex-
pression e, the notation λγe·val,γ′means given environment γ,e
evaluates to value valand a new environment γ′. If we do not care
about the new environment, we may say λγe·val. The semantics
of unidirectional statements is discussed as follows.
enforce patSensures that a match of patSexists in the result.
If the given environment is not a match of patS, this statement
creates a new instance of patSand merge it into the source model
(i.e.,UJenforce patSK).
deletevremoves the object referenced by variable vfrom
the model (i.e., UJdeletevK). After the object removal, the indices
mapped onto the removed object cannot be mapped onto other
objects again. deletevf eature e removes an attribute value or
a link from the model (i.e., UJdeletevf eature e K). We also view
attribute values as links for simplicity. For the node/link deletion,
if the node/link does not exist in the input, the output is identical
to the input.
440
ESEC/FSE ’18, November 4–9, 2018, Lake Buena Vista, FL, USA Xiao He and Zhenjiang Hu
U JenforcepatSK(S)⌘(pat.new( )BS, )U Ju1;u2K(S)⌘let(S0, 0)=U Ju1K(S)inU 0Ju2K(S0)F JreplacepatSpatVK(S)⌘if{ 0}=patS( ,S)thenpatV.new( 0)else?endifB JreplacepatSpatVK(S, V)⌘ifpatS( ,S)={ 0}^|patV( 0,V)|=|patV( ,V)|=1thenSelse if{ 0}=patV( ,V)^patS( ,S)=;thenpatS.new( 0)BSelse?endif endifF JindexvSvVbK(S)⌘letiv=indexV( (vS)),V=F JbK(S)inVwhereivis mapped ontoobjectV( (vV)) inVB JindexvSvVbK(S)⌘letis=indexS( (vS), (vV)),S0=B JbK(S, V)inS0whereisis mapped ontoobjectS0( (vS)) inS0
X JP(e1,...,en)K⌘let 0={vi:=vali|  ei·vali}inX 0JbKwherebis the body statement ofPF JmatchSpatSbK(S)⌘if{ 0}=patS( ,S)thenF 0JbK(S)else?endifB JmatchSpatSbK(S, V)⌘if{ 0}=patS( ,S)then letS0=B 0JbK(S, V)inif{ 0}=patS( ,S0)thenS0else?endifelse?endif
U Jconditioneu1u2K(S)⌘if  e·true, 0thenU 0Ju1K(S)else if  e·false, 0thenU 0Ju2K(S)else?endifendifU JdeletevK(S)⌘(S objectS( (v)), )U Jdeletefeature eK(S)⌘(S l, 0)where  e·val, 0^l⌘(objectS( (v)),v a l)^typeOf(l)=featureF JifThenAdaptionfbuK(S)⌘getBranch( ,f,b ,S)B JifThenAdaptionfbuK(S, V)⌘if  f(S, V)·truethen letS0=B JbK(S, V)inif  f(S0,V)·truethenS0else?endifelse let(Sa, a)=U JuK(S)inif  f(Sa,V)·truethen letS0a=B JbK(Sa,V)inif  f(S0a,V)·truethenS0aelse?endifelse?endifendif
<latexit sha1_base64="BcZJP0JBZpNcQ/pdlrLpRaVQ2Mo=">AAAHlHiclVRRbxM5EF4auEDgjvZO4gFeLMJdUxRV2fJw9wBSAd0JeECg0lIpDpHXO5tY8XoX29s0WP5V/An+Av8GezdB7Da015WijGe++Wb2mx1HOWdKDwZfr2y0rl77pX39RufmrV9/u7259fuRygpJ4ZBmPJPHEVHAmYBDzTSH41wCSSMO76PZcx9/fwJSsUy804scRimZCJYwSrRzjbc2PuMIJkwYwtlEPLSdv3AyjxWkBiezuWHJuymIpzHJPdwmGEUYFfYDnpA0Jb2DHQwfC3aCJqCfSSLotFdF+kk/6rsodnzRbP6/+fpHS8Yy82NB4mWaxdy9VEwqIEZJhaVxppGWBWCH0o7alngO2h5sP1mVjuoFuGd0yO8lzq+zvb7QwbY3gSuwOMp0yQoi9hS13ivEqqvewZj0K/Ix2XmCC8F8hzVJL9mfI7xAiTFZq0WVuL7aRSV/IgryoYt1aYhzrnylr4Pd//dvdLzZHewOygedNcKl0Q2Wz5vxVusLjjNapCA05USpYTjI9cgQqRnl4OgLBTmhMzKBoTMFSUGNTLleFv3pPDFKMul+QqPS+2OGIalSizRyyJToqWrGvHNtTOmUyIWM1wWHhU7+GbnJ5IUGQasukoIjnSG/yChmEqjmC2cQKpl7EUSnRBKq3brXyrCknE2ngwXMaeaG6LTEgnFrsIZTrbXxB1uPuxtlZod7I2cRMeFguqHtm+6exbI8N+BashTkBOzw0ch4LC5yXqixwVV5P2njd5tw031kjXXFIc31Qrkv1Hus526Qlow6K9soOeU0rmB13Imz7DB0IFxOx0iIHb9yuuRasU9geuWbKupZdqxtFmIiTgqnsudYaeJ8cGrHPqOBrpa2AvvBRZE5dEDMeeT0n4FG3RBhKZenZnp02sw+vkR2dT3X0v+7TPHyGqilP7tE+mxepaKVSn4qqNniCnUOhq9jamDUWR7rdj9sbvpZ42hvNxzshm/3uvsPlrfA9eBecD/oBWHwd7AfvAjeBIcBbd1t7bdetl6177Qft5+3/62gG1eWOX8Etaf9+htIQLkC</latexit><latexit sha1_base64="BcZJP0JBZpNcQ/pdlrLpRaVQ2Mo=">AAAHlHiclVRRbxM5EF4auEDgjvZO4gFeLMJdUxRV2fJw9wBSAd0JeECg0lIpDpHXO5tY8XoX29s0WP5V/An+Av8GezdB7Da015WijGe++Wb2mx1HOWdKDwZfr2y0rl77pX39RufmrV9/u7259fuRygpJ4ZBmPJPHEVHAmYBDzTSH41wCSSMO76PZcx9/fwJSsUy804scRimZCJYwSrRzjbc2PuMIJkwYwtlEPLSdv3AyjxWkBiezuWHJuymIpzHJPdwmGEUYFfYDnpA0Jb2DHQwfC3aCJqCfSSLotFdF+kk/6rsodnzRbP6/+fpHS8Yy82NB4mWaxdy9VEwqIEZJhaVxppGWBWCH0o7alngO2h5sP1mVjuoFuGd0yO8lzq+zvb7QwbY3gSuwOMp0yQoi9hS13ivEqqvewZj0K/Ix2XmCC8F8hzVJL9mfI7xAiTFZq0WVuL7aRSV/IgryoYt1aYhzrnylr4Pd//dvdLzZHewOygedNcKl0Q2Wz5vxVusLjjNapCA05USpYTjI9cgQqRnl4OgLBTmhMzKBoTMFSUGNTLleFv3pPDFKMul+QqPS+2OGIalSizRyyJToqWrGvHNtTOmUyIWM1wWHhU7+GbnJ5IUGQasukoIjnSG/yChmEqjmC2cQKpl7EUSnRBKq3brXyrCknE2ngwXMaeaG6LTEgnFrsIZTrbXxB1uPuxtlZod7I2cRMeFguqHtm+6exbI8N+BashTkBOzw0ch4LC5yXqixwVV5P2njd5tw031kjXXFIc31Qrkv1Hus526Qlow6K9soOeU0rmB13Imz7DB0IFxOx0iIHb9yuuRasU9geuWbKupZdqxtFmIiTgqnsudYaeJ8cGrHPqOBrpa2AvvBRZE5dEDMeeT0n4FG3RBhKZenZnp02sw+vkR2dT3X0v+7TPHyGqilP7tE+mxepaKVSn4qqNniCnUOhq9jamDUWR7rdj9sbvpZ42hvNxzshm/3uvsPlrfA9eBecD/oBWHwd7AfvAjeBIcBbd1t7bdetl6177Qft5+3/62gG1eWOX8Etaf9+htIQLkC</latexit><latexit sha1_base64="BcZJP0JBZpNcQ/pdlrLpRaVQ2Mo=">AAAHlHiclVRRbxM5EF4auEDgjvZO4gFeLMJdUxRV2fJw9wBSAd0JeECg0lIpDpHXO5tY8XoX29s0WP5V/An+Av8GezdB7Da015WijGe++Wb2mx1HOWdKDwZfr2y0rl77pX39RufmrV9/u7259fuRygpJ4ZBmPJPHEVHAmYBDzTSH41wCSSMO76PZcx9/fwJSsUy804scRimZCJYwSrRzjbc2PuMIJkwYwtlEPLSdv3AyjxWkBiezuWHJuymIpzHJPdwmGEUYFfYDnpA0Jb2DHQwfC3aCJqCfSSLotFdF+kk/6rsodnzRbP6/+fpHS8Yy82NB4mWaxdy9VEwqIEZJhaVxppGWBWCH0o7alngO2h5sP1mVjuoFuGd0yO8lzq+zvb7QwbY3gSuwOMp0yQoi9hS13ivEqqvewZj0K/Ix2XmCC8F8hzVJL9mfI7xAiTFZq0WVuL7aRSV/IgryoYt1aYhzrnylr4Pd//dvdLzZHewOygedNcKl0Q2Wz5vxVusLjjNapCA05USpYTjI9cgQqRnl4OgLBTmhMzKBoTMFSUGNTLleFv3pPDFKMul+QqPS+2OGIalSizRyyJToqWrGvHNtTOmUyIWM1wWHhU7+GbnJ5IUGQasukoIjnSG/yChmEqjmC2cQKpl7EUSnRBKq3brXyrCknE2ngwXMaeaG6LTEgnFrsIZTrbXxB1uPuxtlZod7I2cRMeFguqHtm+6exbI8N+BashTkBOzw0ch4LC5yXqixwVV5P2njd5tw031kjXXFIc31Qrkv1Hus526Qlow6K9soOeU0rmB13Imz7DB0IFxOx0iIHb9yuuRasU9geuWbKupZdqxtFmIiTgqnsudYaeJ8cGrHPqOBrpa2AvvBRZE5dEDMeeT0n4FG3RBhKZenZnp02sw+vkR2dT3X0v+7TPHyGqilP7tE+mxepaKVSn4qqNniCnUOhq9jamDUWR7rdj9sbvpZ42hvNxzshm/3uvsPlrfA9eBecD/oBWHwd7AfvAjeBIcBbd1t7bdetl6177Qft5+3/62gG1eWOX8Etaf9+htIQLkC</latexit><latexit sha1_base64="BcZJP0JBZpNcQ/pdlrLpRaVQ2Mo=">AAAHlHiclVRRbxM5EF4auEDgjvZO4gFeLMJdUxRV2fJw9wBSAd0JeECg0lIpDpHXO5tY8XoX29s0WP5V/An+Av8GezdB7Da015WijGe++Wb2mx1HOWdKDwZfr2y0rl77pX39RufmrV9/u7259fuRygpJ4ZBmPJPHEVHAmYBDzTSH41wCSSMO76PZcx9/fwJSsUy804scRimZCJYwSrRzjbc2PuMIJkwYwtlEPLSdv3AyjxWkBiezuWHJuymIpzHJPdwmGEUYFfYDnpA0Jb2DHQwfC3aCJqCfSSLotFdF+kk/6rsodnzRbP6/+fpHS8Yy82NB4mWaxdy9VEwqIEZJhaVxppGWBWCH0o7alngO2h5sP1mVjuoFuGd0yO8lzq+zvb7QwbY3gSuwOMp0yQoi9hS13ivEqqvewZj0K/Ix2XmCC8F8hzVJL9mfI7xAiTFZq0WVuL7aRSV/IgryoYt1aYhzrnylr4Pd//dvdLzZHewOygedNcKl0Q2Wz5vxVusLjjNapCA05USpYTjI9cgQqRnl4OgLBTmhMzKBoTMFSUGNTLleFv3pPDFKMul+QqPS+2OGIalSizRyyJToqWrGvHNtTOmUyIWM1wWHhU7+GbnJ5IUGQasukoIjnSG/yChmEqjmC2cQKpl7EUSnRBKq3brXyrCknE2ngwXMaeaG6LTEgnFrsIZTrbXxB1uPuxtlZod7I2cRMeFguqHtm+6exbI8N+BashTkBOzw0ch4LC5yXqixwVV5P2njd5tw031kjXXFIc31Qrkv1Hus526Qlow6K9soOeU0rmB13Imz7DB0IFxOx0iIHb9yuuRasU9geuWbKupZdqxtFmIiTgqnsudYaeJ8cGrHPqOBrpa2AvvBRZE5dEDMeeT0n4FG3RBhKZenZnp02sw+vkR2dT3X0v+7TPHyGqilP7tE+mxepaKVSn4qqNniCnUOhq9jamDUWR7rdj9sbvpZ42hvNxzshm/3uvsPlrfA9eBecD/oBWHwd7AfvAjeBIcBbd1t7bdetl6177Qft5+3/62gG1eWOX8Etaf9+htIQLkC</latexit>getBranch( ,f,b ,S)⌘letV=F JbK(S)inif  f(S, V)·truethenVelse?endifF JifThenElsefb1b2K(S)⌘letV2=getBranch( ,¬f,b2,S)inletV02=if  f(S, V2)·truethen?elseV2endif inifV02=?thengetBranch( ,f,b1,S)elseV02endifB JifThenElsefb1b2K(S, V)⌘if  f(S, V)·truethenletS01=B Jb1K(S, V)inif  f(S01,V)·truethenS01else?endifelse letS02=B Jb2K(S, V)in if  f(S02,V)·falsethenifgetBranch( ,f,b1,S02)=?thenS02else?endifelse?endifendif
<latexit sha1_base64="/+dlNF5n/eQ75XdWZFNYIyRrLMY=">AAAI53iclVXNjts2EFYSN3Xdv2x77IWo28RbGAtLObSXBYIULXpMsVlnAdMVKImSCVOUQlLrdQU+Qw8Fih7aQ9+mr9C36VDSei1Zm2QF2B4Nv/lmvhmSDnLOlJ7N/rt3/8HgvYfvDz8YffjRx598+ujos7nKChnS8zDjmbwIiKKcCXqumeb0IpeUpAGnr4L193b91SWVimXipd7mdJmSRLCYhUSDyz8aPMQBTZgoCWeJ+MaMHidUP5dEhKsJTkiakmk8DaZnx5i+LtgljtebklNt5qc43kSKpmVgfqmBEwBxWGbCYDx6jF8XJKrwLDaYQ0kRqYEYxZOz6fwYh1GmkZYFxYDSKyrM3FqUK2pwkOnqRUQ23hI2CRvOl4D/wSJjjALftV/efimden3v9EAZFjRBIM/3pn217wQ0BE9O3yTH9/oE7WTYSgGzJ0n15tvvWp2zYajo+obju7b6vRxPKil7jQvWm3dunJ3LTeveYXR8JxWjvsad+a4VUZcA+dqp3tqDw/TA17957Ep7/3T6sOOtETcVevsVdppxvS1uLce7KScmQHwz+9tV3TZHIDtuTxxZH3q7rI6222Bq5xth+N0de//ReHYyqx50aLiNMXaa54V/9OBfHGVhkVKhQ06UWrizXC9LIjULOQX6QtGchGuS0AWYgqRULcvqxjLoa/BEKM4kfIRGlXc/oiSpUts0AGRK9Ep116yzd03plMitjPoWF4WOv1vCMPNCUxHWVcQFRzpD9m5EEZM01HwLBgklAyEoXBFJQg03aCsNi6vhjEZwhWzCDCYIvcSCcVNiTa+01qV9Me11uKTXZuEtwSIi4bQcu2Zajj2DZfXegWvJUioTahZPl6XF4iLnhfJLXKe3ky7tYSW8HD81pYHkNM31VsGmth5juTukFaPOqjIqTrmKalgbdwmWWbgAwtV0Skkj4FfQl1wr9istJ5VSFVqWY2O6iZiI4gK6bDmuewI+emV8G9FBF4LB6avBdnBBUJ4DEHMeQP/XVKOxi7CUzVs3PLjqRl/cIbr+Y2mF/3iX5NXN0Qp/fofw9aYORdddslNB3RKvUW/A8D6mDkYd8hg4+273pB8ac+/EnZ24P3vjZ181t8DQ+cL50pk4rvOt88z5yXnhnDvhIB38Pvhr8PeQDX8b/jH8s4bev9fEfO60nuE//wPoATlk</latexit><latexit sha1_base64="/+dlNF5n/eQ75XdWZFNYIyRrLMY=">AAAI53iclVXNjts2EFYSN3Xdv2x77IWo28RbGAtLObSXBYIULXpMsVlnAdMVKImSCVOUQlLrdQU+Qw8Fih7aQ9+mr9C36VDSei1Zm2QF2B4Nv/lmvhmSDnLOlJ7N/rt3/8HgvYfvDz8YffjRx598+ujos7nKChnS8zDjmbwIiKKcCXqumeb0IpeUpAGnr4L193b91SWVimXipd7mdJmSRLCYhUSDyz8aPMQBTZgoCWeJ+MaMHidUP5dEhKsJTkiakmk8DaZnx5i+LtgljtebklNt5qc43kSKpmVgfqmBEwBxWGbCYDx6jF8XJKrwLDaYQ0kRqYEYxZOz6fwYh1GmkZYFxYDSKyrM3FqUK2pwkOnqRUQ23hI2CRvOl4D/wSJjjALftV/efimden3v9EAZFjRBIM/3pn217wQ0BE9O3yTH9/oE7WTYSgGzJ0n15tvvWp2zYajo+obju7b6vRxPKil7jQvWm3dunJ3LTeveYXR8JxWjvsad+a4VUZcA+dqp3tqDw/TA17957Ep7/3T6sOOtETcVevsVdppxvS1uLce7KScmQHwz+9tV3TZHIDtuTxxZH3q7rI6222Bq5xth+N0de//ReHYyqx50aLiNMXaa54V/9OBfHGVhkVKhQ06UWrizXC9LIjULOQX6QtGchGuS0AWYgqRULcvqxjLoa/BEKM4kfIRGlXc/oiSpUts0AGRK9Ep116yzd03plMitjPoWF4WOv1vCMPNCUxHWVcQFRzpD9m5EEZM01HwLBgklAyEoXBFJQg03aCsNi6vhjEZwhWzCDCYIvcSCcVNiTa+01qV9Me11uKTXZuEtwSIi4bQcu2Zajj2DZfXegWvJUioTahZPl6XF4iLnhfJLXKe3ky7tYSW8HD81pYHkNM31VsGmth5juTukFaPOqjIqTrmKalgbdwmWWbgAwtV0Skkj4FfQl1wr9istJ5VSFVqWY2O6iZiI4gK6bDmuewI+emV8G9FBF4LB6avBdnBBUJ4DEHMeQP/XVKOxi7CUzVs3PLjqRl/cIbr+Y2mF/3iX5NXN0Qp/fofw9aYORdddslNB3RKvUW/A8D6mDkYd8hg4+273pB8ac+/EnZ24P3vjZ181t8DQ+cL50pk4rvOt88z5yXnhnDvhIB38Pvhr8PeQDX8b/jH8s4bev9fEfO60nuE//wPoATlk</latexit><latexit sha1_base64="/+dlNF5n/eQ75XdWZFNYIyRrLMY=">AAAI53iclVXNjts2EFYSN3Xdv2x77IWo28RbGAtLObSXBYIULXpMsVlnAdMVKImSCVOUQlLrdQU+Qw8Fih7aQ9+mr9C36VDSei1Zm2QF2B4Nv/lmvhmSDnLOlJ7N/rt3/8HgvYfvDz8YffjRx598+ujos7nKChnS8zDjmbwIiKKcCXqumeb0IpeUpAGnr4L193b91SWVimXipd7mdJmSRLCYhUSDyz8aPMQBTZgoCWeJ+MaMHidUP5dEhKsJTkiakmk8DaZnx5i+LtgljtebklNt5qc43kSKpmVgfqmBEwBxWGbCYDx6jF8XJKrwLDaYQ0kRqYEYxZOz6fwYh1GmkZYFxYDSKyrM3FqUK2pwkOnqRUQ23hI2CRvOl4D/wSJjjALftV/efimden3v9EAZFjRBIM/3pn217wQ0BE9O3yTH9/oE7WTYSgGzJ0n15tvvWp2zYajo+obju7b6vRxPKil7jQvWm3dunJ3LTeveYXR8JxWjvsad+a4VUZcA+dqp3tqDw/TA17957Ep7/3T6sOOtETcVevsVdppxvS1uLce7KScmQHwz+9tV3TZHIDtuTxxZH3q7rI6222Bq5xth+N0de//ReHYyqx50aLiNMXaa54V/9OBfHGVhkVKhQ06UWrizXC9LIjULOQX6QtGchGuS0AWYgqRULcvqxjLoa/BEKM4kfIRGlXc/oiSpUts0AGRK9Ep116yzd03plMitjPoWF4WOv1vCMPNCUxHWVcQFRzpD9m5EEZM01HwLBgklAyEoXBFJQg03aCsNi6vhjEZwhWzCDCYIvcSCcVNiTa+01qV9Me11uKTXZuEtwSIi4bQcu2Zajj2DZfXegWvJUioTahZPl6XF4iLnhfJLXKe3ky7tYSW8HD81pYHkNM31VsGmth5juTukFaPOqjIqTrmKalgbdwmWWbgAwtV0Skkj4FfQl1wr9istJ5VSFVqWY2O6iZiI4gK6bDmuewI+emV8G9FBF4LB6avBdnBBUJ4DEHMeQP/XVKOxi7CUzVs3PLjqRl/cIbr+Y2mF/3iX5NXN0Qp/fofw9aYORdddslNB3RKvUW/A8D6mDkYd8hg4+273pB8ac+/EnZ24P3vjZ181t8DQ+cL50pk4rvOt88z5yXnhnDvhIB38Pvhr8PeQDX8b/jH8s4bev9fEfO60nuE//wPoATlk</latexit><latexit sha1_base64="/+dlNF5n/eQ75XdWZFNYIyRrLMY=">AAAI53iclVXNjts2EFYSN3Xdv2x77IWo28RbGAtLObSXBYIULXpMsVlnAdMVKImSCVOUQlLrdQU+Qw8Fih7aQ9+mr9C36VDSei1Zm2QF2B4Nv/lmvhmSDnLOlJ7N/rt3/8HgvYfvDz8YffjRx598+ujos7nKChnS8zDjmbwIiKKcCXqumeb0IpeUpAGnr4L193b91SWVimXipd7mdJmSRLCYhUSDyz8aPMQBTZgoCWeJ+MaMHidUP5dEhKsJTkiakmk8DaZnx5i+LtgljtebklNt5qc43kSKpmVgfqmBEwBxWGbCYDx6jF8XJKrwLDaYQ0kRqYEYxZOz6fwYh1GmkZYFxYDSKyrM3FqUK2pwkOnqRUQ23hI2CRvOl4D/wSJjjALftV/efimden3v9EAZFjRBIM/3pn217wQ0BE9O3yTH9/oE7WTYSgGzJ0n15tvvWp2zYajo+obju7b6vRxPKil7jQvWm3dunJ3LTeveYXR8JxWjvsad+a4VUZcA+dqp3tqDw/TA17957Ep7/3T6sOOtETcVevsVdppxvS1uLce7KScmQHwz+9tV3TZHIDtuTxxZH3q7rI6222Bq5xth+N0de//ReHYyqx50aLiNMXaa54V/9OBfHGVhkVKhQ06UWrizXC9LIjULOQX6QtGchGuS0AWYgqRULcvqxjLoa/BEKM4kfIRGlXc/oiSpUts0AGRK9Ep116yzd03plMitjPoWF4WOv1vCMPNCUxHWVcQFRzpD9m5EEZM01HwLBgklAyEoXBFJQg03aCsNi6vhjEZwhWzCDCYIvcSCcVNiTa+01qV9Me11uKTXZuEtwSIi4bQcu2Zajj2DZfXegWvJUioTahZPl6XF4iLnhfJLXKe3ky7tYSW8HD81pYHkNM31VsGmth5juTukFaPOqjIqTrmKalgbdwmWWbgAwtV0Skkj4FfQl1wr9istJ5VSFVqWY2O6iZiI4gK6bDmuewI+emV8G9FBF4LB6avBdnBBUJ4DEHMeQP/XVKOxi7CUzVs3PLjqRl/cIbr+Y2mF/3iX5NXN0Qp/fofw9aYORdddslNB3RKvUW/A8D6mDkYd8hg4+273pB8ac+/EnZ24P3vjZ181t8DQ+cL50pk4rvOt88z5yXnhnDvhIB38Pvhr8PeQDX8b/jH8s4bev9fEfO60nuE//wPoATlk</latexit>
XJupdateWithBypatSpatVbucurK⌘XJifThenAdaptionfb⇤uaKFJb⇤K (S)⌘let{ 1,. . . , n}=patS( ,S),Vi=F iJbK(S),V0=V1];...];VninifS=B iJbK(S, V0)thenV0else?endifB Jb⇤K(S, V)⌘let{ 1,. . . , n}=patS( ,S),Si=B iJbK(S, V),S0=S1]S...]SSn,Vi=F iJbK(S),V0=V1];...];VninifVi=F iJbK(S0)^S0=B iJbK(S0,V)^Si=B iJbK(S, V0)^{ 1,. . . , n}=patS( ,S0)thenS0else?endifisAligned( l, r)⌘ 8v( l(v)6=?^ r(v)6=?=) l(v)= r(v)) wherethe value ofvis considered as?whenvis an unused index
<latexit sha1_base64="4idAdwdB2Q3z50wdpAX+d6KM+I8=">AAAJP3icrVXPj+M0FM7uFijlx+7AkYtFgbarqmpmD3CptLtIiOOi7mRGqjuRkzitVcfJxE47JfIfxwGJf4G/gAMS4gAHbjw76dC0syNGEGlSx+/7vvf82X4TZJxJNR7//ODho9Zbb7/Tfrfz3vsffPj4yclHnkyLPKRnYcrT/CIgknIm6JliitOLLKckCTg9D1Zfm/j5muaSpeK12mZ0npCFYDELiYIp/6R1iQO6YKIknC3EU935AgfXkiYljlebssgioug5U8uXW40yovwptj8eRgFGhR+aV64xvSrYep/J4tdLKl5EJDN5NIqBcPnUoInGGLLEm8iAYVLjBUkS0p8OahnD51RpXFYR3x2ORqNh/SGwnthK+tXEcDoYYuT5bHKjqS93TKb7JmwSXhUksi/k9Sae7+Ii44X0S0yTTG0l5IMkx5MeJORmQUI3ZaqXXaqeTnCw2tySe+j1BgajwAzt9cyQckk1DlJlZamIgG+VdwrgyOXOkqH3X0yZGlPeVNiRLdPeZPqPLdN9O6Z66ovh3R7/D7ZWB0ffkQfc3NBoQU2xb1hZz3hWg+5aP0g199Ny/q29e9sKtdy1r0y+MFeLRjXX5zvVfLe3AVv0cZzmhHO0voH11wMs6JWVrGqrafsBlkCXoBLtkSZ7uIHRHjQd3ixpDpUqeq3MAtCa8IKiNEZ6XU0iJlGYCskiAEaISFStqwoCXTSgRKBCFBKQTET0GpqBiG7aif+kOx6N7YOOB2496Dr188o/efQTjtKwSKhQISdSztxxpuYlyRULOdUdDKkyEq7Igs5gKEhC5by0nVCjz20dYCX8CYXs7D6jJImU2yQAZELUUh7GzOStMakSkm/z6LbgrFDxV3M4ylmhqAirKuKCI5Ui03NRxHIaKr6FAQlzBgtB4ZLkJFTQmRtpWGyPVKcDG7wJU9hG8BILxnVpDVeqNB+6GYfmv9Kz0zmMiFhwWnZdPSy7pxrn9vsArnKW0HxB9ezZvDTYm+tZpTcnuTRHk/Cy+0yXWu9dXDOjjfaBqFVUqS3DaubLqII1cWsY6ZkLIGx3p4QjBvoSfMmUZN/Tsm9XKkOjMtD6MBEcsrgAl43GzpPq4PmGcYAuBIPbX4HNxgVBeQZAzHkA/q+oQl0X4Tyvvw7p9j9ag31xD3bVwxr0b+6T3HauBv3lPeirTUVFO5fMrqDDEneoOzD8NqUDjDzW0XD33cObfjzwTkfueOR+d9p9/lndBdrOJ86nTt9xnS+d5863zivnzAlbP7Z+bf3R+rP9Q/uX9m/t3yvowwc152On8bT/+huJGlmR</latexit><latexit sha1_base64="4idAdwdB2Q3z50wdpAX+d6KM+I8=">AAAJP3icrVXPj+M0FM7uFijlx+7AkYtFgbarqmpmD3CptLtIiOOi7mRGqjuRkzitVcfJxE47JfIfxwGJf4G/gAMS4gAHbjw76dC0syNGEGlSx+/7vvf82X4TZJxJNR7//ODho9Zbb7/Tfrfz3vsffPj4yclHnkyLPKRnYcrT/CIgknIm6JliitOLLKckCTg9D1Zfm/j5muaSpeK12mZ0npCFYDELiYIp/6R1iQO6YKIknC3EU935AgfXkiYljlebssgioug5U8uXW40yovwptj8eRgFGhR+aV64xvSrYep/J4tdLKl5EJDN5NIqBcPnUoInGGLLEm8iAYVLjBUkS0p8OahnD51RpXFYR3x2ORqNh/SGwnthK+tXEcDoYYuT5bHKjqS93TKb7JmwSXhUksi/k9Sae7+Ii44X0S0yTTG0l5IMkx5MeJORmQUI3ZaqXXaqeTnCw2tySe+j1BgajwAzt9cyQckk1DlJlZamIgG+VdwrgyOXOkqH3X0yZGlPeVNiRLdPeZPqPLdN9O6Z66ovh3R7/D7ZWB0ffkQfc3NBoQU2xb1hZz3hWg+5aP0g199Ny/q29e9sKtdy1r0y+MFeLRjXX5zvVfLe3AVv0cZzmhHO0voH11wMs6JWVrGqrafsBlkCXoBLtkSZ7uIHRHjQd3ixpDpUqeq3MAtCa8IKiNEZ6XU0iJlGYCskiAEaISFStqwoCXTSgRKBCFBKQTET0GpqBiG7aif+kOx6N7YOOB2496Dr188o/efQTjtKwSKhQISdSztxxpuYlyRULOdUdDKkyEq7Igs5gKEhC5by0nVCjz20dYCX8CYXs7D6jJImU2yQAZELUUh7GzOStMakSkm/z6LbgrFDxV3M4ylmhqAirKuKCI5Ui03NRxHIaKr6FAQlzBgtB4ZLkJFTQmRtpWGyPVKcDG7wJU9hG8BILxnVpDVeqNB+6GYfmv9Kz0zmMiFhwWnZdPSy7pxrn9vsArnKW0HxB9ezZvDTYm+tZpTcnuTRHk/Cy+0yXWu9dXDOjjfaBqFVUqS3DaubLqII1cWsY6ZkLIGx3p4QjBvoSfMmUZN/Tsm9XKkOjMtD6MBEcsrgAl43GzpPq4PmGcYAuBIPbX4HNxgVBeQZAzHkA/q+oQl0X4Tyvvw7p9j9ag31xD3bVwxr0b+6T3HauBv3lPeirTUVFO5fMrqDDEneoOzD8NqUDjDzW0XD33cObfjzwTkfueOR+d9p9/lndBdrOJ86nTt9xnS+d5863zivnzAlbP7Z+bf3R+rP9Q/uX9m/t3yvowwc152On8bT/+huJGlmR</latexit><latexit sha1_base64="4idAdwdB2Q3z50wdpAX+d6KM+I8=">AAAJP3icrVXPj+M0FM7uFijlx+7AkYtFgbarqmpmD3CptLtIiOOi7mRGqjuRkzitVcfJxE47JfIfxwGJf4G/gAMS4gAHbjw76dC0syNGEGlSx+/7vvf82X4TZJxJNR7//ODho9Zbb7/Tfrfz3vsffPj4yclHnkyLPKRnYcrT/CIgknIm6JliitOLLKckCTg9D1Zfm/j5muaSpeK12mZ0npCFYDELiYIp/6R1iQO6YKIknC3EU935AgfXkiYljlebssgioug5U8uXW40yovwptj8eRgFGhR+aV64xvSrYep/J4tdLKl5EJDN5NIqBcPnUoInGGLLEm8iAYVLjBUkS0p8OahnD51RpXFYR3x2ORqNh/SGwnthK+tXEcDoYYuT5bHKjqS93TKb7JmwSXhUksi/k9Sae7+Ii44X0S0yTTG0l5IMkx5MeJORmQUI3ZaqXXaqeTnCw2tySe+j1BgajwAzt9cyQckk1DlJlZamIgG+VdwrgyOXOkqH3X0yZGlPeVNiRLdPeZPqPLdN9O6Z66ovh3R7/D7ZWB0ffkQfc3NBoQU2xb1hZz3hWg+5aP0g199Ny/q29e9sKtdy1r0y+MFeLRjXX5zvVfLe3AVv0cZzmhHO0voH11wMs6JWVrGqrafsBlkCXoBLtkSZ7uIHRHjQd3ixpDpUqeq3MAtCa8IKiNEZ6XU0iJlGYCskiAEaISFStqwoCXTSgRKBCFBKQTET0GpqBiG7aif+kOx6N7YOOB2496Dr188o/efQTjtKwSKhQISdSztxxpuYlyRULOdUdDKkyEq7Igs5gKEhC5by0nVCjz20dYCX8CYXs7D6jJImU2yQAZELUUh7GzOStMakSkm/z6LbgrFDxV3M4ylmhqAirKuKCI5Ui03NRxHIaKr6FAQlzBgtB4ZLkJFTQmRtpWGyPVKcDG7wJU9hG8BILxnVpDVeqNB+6GYfmv9Kz0zmMiFhwWnZdPSy7pxrn9vsArnKW0HxB9ezZvDTYm+tZpTcnuTRHk/Cy+0yXWu9dXDOjjfaBqFVUqS3DaubLqII1cWsY6ZkLIGx3p4QjBvoSfMmUZN/Tsm9XKkOjMtD6MBEcsrgAl43GzpPq4PmGcYAuBIPbX4HNxgVBeQZAzHkA/q+oQl0X4Tyvvw7p9j9ag31xD3bVwxr0b+6T3HauBv3lPeirTUVFO5fMrqDDEneoOzD8NqUDjDzW0XD33cObfjzwTkfueOR+d9p9/lndBdrOJ86nTt9xnS+d5863zivnzAlbP7Z+bf3R+rP9Q/uX9m/t3yvowwc152On8bT/+huJGlmR</latexit><latexit sha1_base64="4idAdwdB2Q3z50wdpAX+d6KM+I8=">AAAJP3icrVXPj+M0FM7uFijlx+7AkYtFgbarqmpmD3CptLtIiOOi7mRGqjuRkzitVcfJxE47JfIfxwGJf4G/gAMS4gAHbjw76dC0syNGEGlSx+/7vvf82X4TZJxJNR7//ODho9Zbb7/Tfrfz3vsffPj4yclHnkyLPKRnYcrT/CIgknIm6JliitOLLKckCTg9D1Zfm/j5muaSpeK12mZ0npCFYDELiYIp/6R1iQO6YKIknC3EU935AgfXkiYljlebssgioug5U8uXW40yovwptj8eRgFGhR+aV64xvSrYep/J4tdLKl5EJDN5NIqBcPnUoInGGLLEm8iAYVLjBUkS0p8OahnD51RpXFYR3x2ORqNh/SGwnthK+tXEcDoYYuT5bHKjqS93TKb7JmwSXhUksi/k9Sae7+Ii44X0S0yTTG0l5IMkx5MeJORmQUI3ZaqXXaqeTnCw2tySe+j1BgajwAzt9cyQckk1DlJlZamIgG+VdwrgyOXOkqH3X0yZGlPeVNiRLdPeZPqPLdN9O6Z66ovh3R7/D7ZWB0ffkQfc3NBoQU2xb1hZz3hWg+5aP0g199Ny/q29e9sKtdy1r0y+MFeLRjXX5zvVfLe3AVv0cZzmhHO0voH11wMs6JWVrGqrafsBlkCXoBLtkSZ7uIHRHjQd3ixpDpUqeq3MAtCa8IKiNEZ6XU0iJlGYCskiAEaISFStqwoCXTSgRKBCFBKQTET0GpqBiG7aif+kOx6N7YOOB2496Dr188o/efQTjtKwSKhQISdSztxxpuYlyRULOdUdDKkyEq7Igs5gKEhC5by0nVCjz20dYCX8CYXs7D6jJImU2yQAZELUUh7GzOStMakSkm/z6LbgrFDxV3M4ylmhqAirKuKCI5Ui03NRxHIaKr6FAQlzBgtB4ZLkJFTQmRtpWGyPVKcDG7wJU9hG8BILxnVpDVeqNB+6GYfmv9Kz0zmMiFhwWnZdPSy7pxrn9vsArnKW0HxB9ezZvDTYm+tZpTcnuTRHk/Cy+0yXWu9dXDOjjfaBqFVUqS3DaubLqII1cWsY6ZkLIGx3p4QjBvoSfMmUZN/Tsm9XKkOjMtD6MBEcsrgAl43GzpPq4PmGcYAuBIPbX4HNxgVBeQZAzHkA/q+oQl0X4Tyvvw7p9j9ag31xD3bVwxr0b+6T3HauBv3lPeirTUVFO5fMrqDDEneoOzD8NqUDjDzW0XD33cObfjzwTkfueOR+d9p9/lndBdrOJ86nTt9xnS+d5863zivnzAlbP7Z+bf3R+rP9Q/uX9m/t3yvowwc152On8bT/+huJGlmR</latexit>F JmatchVpatSbK(S)⌘letV=F JbK(S)inif{ 0}=patV( ,V)^V=F 0JbK(S)thenVelse?endifB JmatchVpatSbK(S, V)⌘let{ 1, 2,. . .}=patV( ,V)inif9!i(B iJbK(S, V)=S06=?)thenif9!i(B iJbK(S0,V)6=?)thenS0else?endifelse?endif
<latexit sha1_base64="9hN+kdSRlNDIPhKlsnHFx4lRTUM=">AAAHHXiclVTNjuNEEPZmISzhbweOXBoCTGY1iuLsgT3sSCuQEMdFw2RHSoeobZeTVtptT3d7MqHVz8KBZ0ECCXGAA+JtqLbj3bVnNDCWbFVXffXVX5ejQnBtJpN/7vXuv/Fm/60Hbw/eefe99z94ePDhTOeliuEszkWuziOmQXAJZ4YbAeeFApZFAl5Em6+9/cUlKM1z+b3ZFbDI2ErylMfMoGp50HtKI1hxaZngK/nIDb6g6TbRkFmabrY2YyZezxwpmFmeUhK5H+iKZRkbnR5RuCj5ZYUSYNzspHFsgQSauXSUIvFFyZL645146qitgYfUnfgIs1F9Pp4d0S0kKyAt1gbtPDEymDVIN/MSCA2ORrmp4oFMPLkPGW22/6MWH69dTZPZMjzeC9Pj8Xh8Q563FwhXOEL9CR81mbwqY8ldFfnk9JBKuPDZ12xVWR0+/yENK/lP2kOf2UvShhMD3darV9FeR5E2jKL08q4Mlg+Hk/Gkesh1IdwLw2D/PF8e3P+VJnlcZiBNLJjW83BSmIVlyvBYgBvQUkPB4g1bwRxFyTLQC1vdc0c+R01C0lzhKw2ptK97WJZpvcsiROKw17pr88obbdpkTO1UcpNxXpr0yQJnXJQGZFxnkZaCmJz4jSIJVxAbsUOBxYpjISReM8Vig3vXCsPTag6DAc5mG+c4LWwmlVw4Sw1cGWOsP7i2HVd74+bTBUpMrgTYYeiO7XDqqKrOHbhRPAO1Ajd/vLAeS8tClHppaR3eT9b6686EHT521mFwyAqz03jvvcZ57g5pxWjyKo2KU62TGtbGXaLk5iGCaDUdqyBBfo19KYzmP4IdVZXq2LMcOdcNxGWSlthlz9H0BHVw5Zbeo4MuJcfbX4P94KLIniGQChFh/zdgyDAkVKn9qeseXXW9z+/gXf+YWu7f3CV4tbkt96/u4L7Z1q6k6ZKfCumm2KBuwYibmDoYfZ3H4e6H3U2/Lsym43AyDr+bDp99tv8LPAg+Dj4NRkEYfBk8C74NngdnQdz7ufdb78/eX/2f+r/0f+//UUN79/Y+HwWtp//3v0ckkMk=</latexit><latexit sha1_base64="9hN+kdSRlNDIPhKlsnHFx4lRTUM=">AAAHHXiclVTNjuNEEPZmISzhbweOXBoCTGY1iuLsgT3sSCuQEMdFw2RHSoeobZeTVtptT3d7MqHVz8KBZ0ECCXGAA+JtqLbj3bVnNDCWbFVXffXVX5ejQnBtJpN/7vXuv/Fm/60Hbw/eefe99z94ePDhTOeliuEszkWuziOmQXAJZ4YbAeeFApZFAl5Em6+9/cUlKM1z+b3ZFbDI2ErylMfMoGp50HtKI1hxaZngK/nIDb6g6TbRkFmabrY2YyZezxwpmFmeUhK5H+iKZRkbnR5RuCj5ZYUSYNzspHFsgQSauXSUIvFFyZL645146qitgYfUnfgIs1F9Pp4d0S0kKyAt1gbtPDEymDVIN/MSCA2ORrmp4oFMPLkPGW22/6MWH69dTZPZMjzeC9Pj8Xh8Q563FwhXOEL9CR81mbwqY8ldFfnk9JBKuPDZ12xVWR0+/yENK/lP2kOf2UvShhMD3darV9FeR5E2jKL08q4Mlg+Hk/Gkesh1IdwLw2D/PF8e3P+VJnlcZiBNLJjW83BSmIVlyvBYgBvQUkPB4g1bwRxFyTLQC1vdc0c+R01C0lzhKw2ptK97WJZpvcsiROKw17pr88obbdpkTO1UcpNxXpr0yQJnXJQGZFxnkZaCmJz4jSIJVxAbsUOBxYpjISReM8Vig3vXCsPTag6DAc5mG+c4LWwmlVw4Sw1cGWOsP7i2HVd74+bTBUpMrgTYYeiO7XDqqKrOHbhRPAO1Ajd/vLAeS8tClHppaR3eT9b6686EHT521mFwyAqz03jvvcZ57g5pxWjyKo2KU62TGtbGXaLk5iGCaDUdqyBBfo19KYzmP4IdVZXq2LMcOdcNxGWSlthlz9H0BHVw5Zbeo4MuJcfbX4P94KLIniGQChFh/zdgyDAkVKn9qeseXXW9z+/gXf+YWu7f3CV4tbkt96/u4L7Z1q6k6ZKfCumm2KBuwYibmDoYfZ3H4e6H3U2/Lsym43AyDr+bDp99tv8LPAg+Dj4NRkEYfBk8C74NngdnQdz7ufdb78/eX/2f+r/0f+//UUN79/Y+HwWtp//3v0ckkMk=</latexit><latexit sha1_base64="9hN+kdSRlNDIPhKlsnHFx4lRTUM=">AAAHHXiclVTNjuNEEPZmISzhbweOXBoCTGY1iuLsgT3sSCuQEMdFw2RHSoeobZeTVtptT3d7MqHVz8KBZ0ECCXGAA+JtqLbj3bVnNDCWbFVXffXVX5ejQnBtJpN/7vXuv/Fm/60Hbw/eefe99z94ePDhTOeliuEszkWuziOmQXAJZ4YbAeeFApZFAl5Em6+9/cUlKM1z+b3ZFbDI2ErylMfMoGp50HtKI1hxaZngK/nIDb6g6TbRkFmabrY2YyZezxwpmFmeUhK5H+iKZRkbnR5RuCj5ZYUSYNzspHFsgQSauXSUIvFFyZL645146qitgYfUnfgIs1F9Pp4d0S0kKyAt1gbtPDEymDVIN/MSCA2ORrmp4oFMPLkPGW22/6MWH69dTZPZMjzeC9Pj8Xh8Q563FwhXOEL9CR81mbwqY8ldFfnk9JBKuPDZ12xVWR0+/yENK/lP2kOf2UvShhMD3darV9FeR5E2jKL08q4Mlg+Hk/Gkesh1IdwLw2D/PF8e3P+VJnlcZiBNLJjW83BSmIVlyvBYgBvQUkPB4g1bwRxFyTLQC1vdc0c+R01C0lzhKw2ptK97WJZpvcsiROKw17pr88obbdpkTO1UcpNxXpr0yQJnXJQGZFxnkZaCmJz4jSIJVxAbsUOBxYpjISReM8Vig3vXCsPTag6DAc5mG+c4LWwmlVw4Sw1cGWOsP7i2HVd74+bTBUpMrgTYYeiO7XDqqKrOHbhRPAO1Ajd/vLAeS8tClHppaR3eT9b6686EHT521mFwyAqz03jvvcZ57g5pxWjyKo2KU62TGtbGXaLk5iGCaDUdqyBBfo19KYzmP4IdVZXq2LMcOdcNxGWSlthlz9H0BHVw5Zbeo4MuJcfbX4P94KLIniGQChFh/zdgyDAkVKn9qeseXXW9z+/gXf+YWu7f3CV4tbkt96/u4L7Z1q6k6ZKfCumm2KBuwYibmDoYfZ3H4e6H3U2/Lsym43AyDr+bDp99tv8LPAg+Dj4NRkEYfBk8C74NngdnQdz7ufdb78/eX/2f+r/0f+//UUN79/Y+HwWtp//3v0ckkMk=</latexit><latexit sha1_base64="9hN+kdSRlNDIPhKlsnHFx4lRTUM=">AAAHHXiclVTNjuNEEPZmISzhbweOXBoCTGY1iuLsgT3sSCuQEMdFw2RHSoeobZeTVtptT3d7MqHVz8KBZ0ECCXGAA+JtqLbj3bVnNDCWbFVXffXVX5ejQnBtJpN/7vXuv/Fm/60Hbw/eefe99z94ePDhTOeliuEszkWuziOmQXAJZ4YbAeeFApZFAl5Em6+9/cUlKM1z+b3ZFbDI2ErylMfMoGp50HtKI1hxaZngK/nIDb6g6TbRkFmabrY2YyZezxwpmFmeUhK5H+iKZRkbnR5RuCj5ZYUSYNzspHFsgQSauXSUIvFFyZL645146qitgYfUnfgIs1F9Pp4d0S0kKyAt1gbtPDEymDVIN/MSCA2ORrmp4oFMPLkPGW22/6MWH69dTZPZMjzeC9Pj8Xh8Q563FwhXOEL9CR81mbwqY8ldFfnk9JBKuPDZ12xVWR0+/yENK/lP2kOf2UvShhMD3darV9FeR5E2jKL08q4Mlg+Hk/Gkesh1IdwLw2D/PF8e3P+VJnlcZiBNLJjW83BSmIVlyvBYgBvQUkPB4g1bwRxFyTLQC1vdc0c+R01C0lzhKw2ptK97WJZpvcsiROKw17pr88obbdpkTO1UcpNxXpr0yQJnXJQGZFxnkZaCmJz4jSIJVxAbsUOBxYpjISReM8Vig3vXCsPTag6DAc5mG+c4LWwmlVw4Sw1cGWOsP7i2HVd74+bTBUpMrgTYYeiO7XDqqKrOHbhRPAO1Ajd/vLAeS8tClHppaR3eT9b6686EHT521mFwyAqz03jvvcZ57g5pxWjyKo2KU62TGtbGXaLk5iGCaDUdqyBBfo19KYzmP4IdVZXq2LMcOdcNxGWSlthlz9H0BHVw5Zbeo4MuJcfbX4P94KLIniGQChFh/zdgyDAkVKn9qeseXXW9z+/gXf+YWu7f3CV4tbkt96/u4L7Z1q6k6ZKfCumm2KBuwYibmDoYfZ3H4e6H3U2/Lsym43AyDr+bDp99tv8LPAg+Dj4NRkEYfBk8C74NngdnQdz7ufdb78/eX/2f+r/0f+//UUN79/Y+HwWtp//3v0ckkMk=</latexit>F Jb1;b2K(S)⌘letV1=F Jb1K(S),V2=F Jb2K(S),V0=V1];V2inifS=B Jb1K(S, V0)=B Jb2K(S, V0)thenV0else?endifB Jb1;b2K(S, V)⌘letS1=B Jb1K(S, V),S2=B Jb2K(S, V),S0=S1]SS2,V1=F Jb1K(S1),V2=F Jb2K(S2),V0=V1];V2,Vc1=core1SV , Vc2=core2SV ,Vc=Vc1];Vc2inifcore1S1V=core1S0V^core2S2V=core2S0V^S0=B Jb1K(S0,V)^S0=B Jb2K(S0,V)^Vc1=core1SVc^Vc2=core2SVc^V1];V2'VcthenS0else?endif
<latexit sha1_base64="YNHB3qAD8a780gtHO1UpOOEfrAc=">AAAIgXiclVRtb9s2EFYbb/W8t3b7uC/CvM3J4AaWCqwDigBFBwz72MGLGsD0BIqiHMLUS0gqjkfwv/Tn9C/03+woyYklqwEiwPTx7rnneHfkRQVnUs1mHx89Php89vmT4RejL7/6+ptvnz77LpB5KQg9JznPxUWEJeUso+eKKU4vCkFxGnH6Llr/Ye3vrqmQLM/+UduCLlO8yljCCFagCp8dvUcRXbFMY85W2a9m9AtKNrGkqY5CD8n1Rr8yUeibf9EKpyk+np8gelWya5SAiVNlgtA723PZA06RG4T+ntHvGCdnSAmWUrGiGmgMLL7RBnGgZplBCA5zVeK4XmxAlpj5GYrWm4No02Bysmfx2xYEvuqSZiaYWJFySQ2KclWFolkMvFW0O+a+1KdBN/m5Tb7/ODbDuU2//0yVeb8Ac1uAuS3A3EzbqbufrHHo3Vvl0L+vzodRNPHMGckFhfzdOXhOK6XfKP1GaSOSFqd1NLrG9nawaZ57S26X4C7WBHZoQ+MVdW9D2SW4i1xB2iduPGwd+5owsQ3rgfi9kJ70Q9IfsKcoAK1s/Tdagu6qAu0uos3nEzdxhOD/9j2Owqfj2ems+txDwWuEsdN8b+FNf0BxTsqUZopwLOXCmxVqqbFQjHAK/KWkBSZrvKILEDOcUrnU1Swx7s+gid0kF/DLlFtp9z00TqXcphEgU6wuZddmlb02qVIstiLuMy5Klfy+hCtTlIpmpD5FUnJX5a6dWm7MBCWKb0HARDBIxCWXWGCiYLa1wrCkqu9ohDK6ITl0GYqJMsaNRoreKKW03Zi2Hcbn2iz8JUg4W3Gqx56Z6rFvkKj2HfiuyWbxYqktFpUFL2WoUR3etlXbWYG5Hr+AGwDBaVqorYShYTXGcndIK0aVV8eoOMVlXMPauGuQzMIDEKq6owWNgV9CXQol2X9UH1eZSmJZTozpBmJZnJRQZcuxqwno6I0JrUcHXWYMnk0Nto2LIn0OQMR5BPVfU+WOPRcJ0ey67tFN1/viAd71VGu5//mQ4NWTb7m/eYD7elO7ursq2a643SPuUPdgeB9TByMPeQy8fa/70g+FwD/1Zqfe3/749U/NFBg6Pzg/OseO57x0Xjt/OW+dc4cMngyeD34bvBweDU+Gs6FfQx8/any+d1rf8NX/rUr/fg==</latexit><latexit sha1_base64="YNHB3qAD8a780gtHO1UpOOEfrAc=">AAAIgXiclVRtb9s2EFYbb/W8t3b7uC/CvM3J4AaWCqwDigBFBwz72MGLGsD0BIqiHMLUS0gqjkfwv/Tn9C/03+woyYklqwEiwPTx7rnneHfkRQVnUs1mHx89Php89vmT4RejL7/6+ptvnz77LpB5KQg9JznPxUWEJeUso+eKKU4vCkFxGnH6Llr/Ye3vrqmQLM/+UduCLlO8yljCCFagCp8dvUcRXbFMY85W2a9m9AtKNrGkqY5CD8n1Rr8yUeibf9EKpyk+np8gelWya5SAiVNlgtA723PZA06RG4T+ntHvGCdnSAmWUrGiGmgMLL7RBnGgZplBCA5zVeK4XmxAlpj5GYrWm4No02Bysmfx2xYEvuqSZiaYWJFySQ2KclWFolkMvFW0O+a+1KdBN/m5Tb7/ODbDuU2//0yVeb8Ac1uAuS3A3EzbqbufrHHo3Vvl0L+vzodRNPHMGckFhfzdOXhOK6XfKP1GaSOSFqd1NLrG9nawaZ57S26X4C7WBHZoQ+MVdW9D2SW4i1xB2iduPGwd+5owsQ3rgfi9kJ70Q9IfsKcoAK1s/Tdagu6qAu0uos3nEzdxhOD/9j2Owqfj2ems+txDwWuEsdN8b+FNf0BxTsqUZopwLOXCmxVqqbFQjHAK/KWkBSZrvKILEDOcUrnU1Swx7s+gid0kF/DLlFtp9z00TqXcphEgU6wuZddmlb02qVIstiLuMy5Klfy+hCtTlIpmpD5FUnJX5a6dWm7MBCWKb0HARDBIxCWXWGCiYLa1wrCkqu9ohDK6ITl0GYqJMsaNRoreKKW03Zi2Hcbn2iz8JUg4W3Gqx56Z6rFvkKj2HfiuyWbxYqktFpUFL2WoUR3etlXbWYG5Hr+AGwDBaVqorYShYTXGcndIK0aVV8eoOMVlXMPauGuQzMIDEKq6owWNgV9CXQol2X9UH1eZSmJZTozpBmJZnJRQZcuxqwno6I0JrUcHXWYMnk0Nto2LIn0OQMR5BPVfU+WOPRcJ0ey67tFN1/viAd71VGu5//mQ4NWTb7m/eYD7elO7ursq2a643SPuUPdgeB9TByMPeQy8fa/70g+FwD/1Zqfe3/749U/NFBg6Pzg/OseO57x0Xjt/OW+dc4cMngyeD34bvBweDU+Gs6FfQx8/any+d1rf8NX/rUr/fg==</latexit><latexit sha1_base64="YNHB3qAD8a780gtHO1UpOOEfrAc=">AAAIgXiclVRtb9s2EFYbb/W8t3b7uC/CvM3J4AaWCqwDigBFBwz72MGLGsD0BIqiHMLUS0gqjkfwv/Tn9C/03+woyYklqwEiwPTx7rnneHfkRQVnUs1mHx89Php89vmT4RejL7/6+ptvnz77LpB5KQg9JznPxUWEJeUso+eKKU4vCkFxGnH6Llr/Ye3vrqmQLM/+UduCLlO8yljCCFagCp8dvUcRXbFMY85W2a9m9AtKNrGkqY5CD8n1Rr8yUeibf9EKpyk+np8gelWya5SAiVNlgtA723PZA06RG4T+ntHvGCdnSAmWUrGiGmgMLL7RBnGgZplBCA5zVeK4XmxAlpj5GYrWm4No02Bysmfx2xYEvuqSZiaYWJFySQ2KclWFolkMvFW0O+a+1KdBN/m5Tb7/ODbDuU2//0yVeb8Ac1uAuS3A3EzbqbufrHHo3Vvl0L+vzodRNPHMGckFhfzdOXhOK6XfKP1GaSOSFqd1NLrG9nawaZ57S26X4C7WBHZoQ+MVdW9D2SW4i1xB2iduPGwd+5owsQ3rgfi9kJ70Q9IfsKcoAK1s/Tdagu6qAu0uos3nEzdxhOD/9j2Owqfj2ems+txDwWuEsdN8b+FNf0BxTsqUZopwLOXCmxVqqbFQjHAK/KWkBSZrvKILEDOcUrnU1Swx7s+gid0kF/DLlFtp9z00TqXcphEgU6wuZddmlb02qVIstiLuMy5Klfy+hCtTlIpmpD5FUnJX5a6dWm7MBCWKb0HARDBIxCWXWGCiYLa1wrCkqu9ohDK6ITl0GYqJMsaNRoreKKW03Zi2Hcbn2iz8JUg4W3Gqx56Z6rFvkKj2HfiuyWbxYqktFpUFL2WoUR3etlXbWYG5Hr+AGwDBaVqorYShYTXGcndIK0aVV8eoOMVlXMPauGuQzMIDEKq6owWNgV9CXQol2X9UH1eZSmJZTozpBmJZnJRQZcuxqwno6I0JrUcHXWYMnk0Nto2LIn0OQMR5BPVfU+WOPRcJ0ey67tFN1/viAd71VGu5//mQ4NWTb7m/eYD7elO7ursq2a643SPuUPdgeB9TByMPeQy8fa/70g+FwD/1Zqfe3/749U/NFBg6Pzg/OseO57x0Xjt/OW+dc4cMngyeD34bvBweDU+Gs6FfQx8/any+d1rf8NX/rUr/fg==</latexit><latexit sha1_base64="YNHB3qAD8a780gtHO1UpOOEfrAc=">AAAIgXiclVRtb9s2EFYbb/W8t3b7uC/CvM3J4AaWCqwDigBFBwz72MGLGsD0BIqiHMLUS0gqjkfwv/Tn9C/03+woyYklqwEiwPTx7rnneHfkRQVnUs1mHx89Php89vmT4RejL7/6+ptvnz77LpB5KQg9JznPxUWEJeUso+eKKU4vCkFxGnH6Llr/Ye3vrqmQLM/+UduCLlO8yljCCFagCp8dvUcRXbFMY85W2a9m9AtKNrGkqY5CD8n1Rr8yUeibf9EKpyk+np8gelWya5SAiVNlgtA723PZA06RG4T+ntHvGCdnSAmWUrGiGmgMLL7RBnGgZplBCA5zVeK4XmxAlpj5GYrWm4No02Bysmfx2xYEvuqSZiaYWJFySQ2KclWFolkMvFW0O+a+1KdBN/m5Tb7/ODbDuU2//0yVeb8Ac1uAuS3A3EzbqbufrHHo3Vvl0L+vzodRNPHMGckFhfzdOXhOK6XfKP1GaSOSFqd1NLrG9nawaZ57S26X4C7WBHZoQ+MVdW9D2SW4i1xB2iduPGwd+5owsQ3rgfi9kJ70Q9IfsKcoAK1s/Tdagu6qAu0uos3nEzdxhOD/9j2Owqfj2ems+txDwWuEsdN8b+FNf0BxTsqUZopwLOXCmxVqqbFQjHAK/KWkBSZrvKILEDOcUrnU1Swx7s+gid0kF/DLlFtp9z00TqXcphEgU6wuZddmlb02qVIstiLuMy5Klfy+hCtTlIpmpD5FUnJX5a6dWm7MBCWKb0HARDBIxCWXWGCiYLa1wrCkqu9ohDK6ITl0GYqJMsaNRoreKKW03Zi2Hcbn2iz8JUg4W3Gqx56Z6rFvkKj2HfiuyWbxYqktFpUFL2WoUR3etlXbWYG5Hr+AGwDBaVqorYShYTXGcndIK0aVV8eoOMVlXMPauGuQzMIDEKq6owWNgV9CXQol2X9UH1eZSmJZTozpBmJZnJRQZcuxqwno6I0JrUcHXWYMnk0Nto2LIn0OQMR5BPVfU+WOPRcJ0ey67tFN1/viAd71VGu5//mQ4NWTb7m/eYD7elO7ursq2a643SPuUPdgeB9TByMPeQy8fa/70g+FwD/1Zqfe3/749U/NFBg6Pzg/OseO57x0Xjt/OW+dc4cMngyeD34bvBweDU+Gs6FfQx8/any+d1rf8NX/rUr/fg==</latexit>
Figure 12: Formal Semantics of XMU Core
condition e u 1u2is a conditional statement, which exe-
cutes u1oru2according to the result of expression e(i.e.,
UJcondition e u 1u2K).
u1;u2executes u1andu2sequentially (i.e., UJu1;u2K).
5.3 Bidirectional Statements
A bidirectional statement bis interpreted as a BX Xγ
JbK, which rep-
resents the bidirectional semantics of bunder environment γ.Xγ
JbK
consists of a forward semantics Fγ
JbKand a backward semantics
Bγ
JbK(under the same environment γ).b1;b2merges b1andb2using⊎. We embed explicit checks of
equations (8)-(12) in the definitions of Bγ
Jb1;b2KandFγ
Jb1;b2Kto
ensure their well-behavedness. The core function of Xγ
Jb1;b2Kis the
merging of the core functions of Xγ
Jb1KandXγ
Jb2K.
replace patSpatVensures that a match of patSis paired with a
match of patV. ForBγ
Jreplace patSpatVK, this statement instantiates
a match of patSbased on a match of patVif the source match is
absent. In the forward semantics Fγ
Jreplace patSpatVK, this state-
ment instantiates a match of patVbased on a match of patS. The
441
Putback-Based Bidirectional Model Transformations ESEC/FSE ’18, November 4–9, 2018, Lake Buena Vista, FL, USA
core function of Xγ
Jreplace patSpatVKextracts the unique match of
patVout from the view model based on γ.
indexvSvVbmay append new indices to the result of b. The
core function of Xγ
JindexvSvVbKis the core function of Xγ
JbK. As
mentioned in Section 4, we employ an index function index(s,v)to
compute object indices. In Bγ
JindexvSvVbK, the index function is
written as index S(s,v), which computes an updated-source index
based on sandv. In the same backward transformation, any two
invocations of index S(s1,v1)andindex S(s2,v2)must satisfy the
following runtime constraints: 1) v1=v2⇒s1=s2; 2)s1,
s2=⇒ index S(s1,v1),index S(s2,v2); 3)index Sshould not
generate an index that is already used in the original source model.
InFγ
JindexvSvVbK, the index function is denoted as index V(s),
which computes a view index based on s. In the same forward
transformation any two invocations of index V(s1)andindex V(s2)
must satisfy the following constraint s1,s2=⇒index V(s1),
index V(s2). These constraints ensure that 1) the same view objects
are always created based on the same source objects and that 2)
index functions do not cause index collision. Index functions may
be implemented in many ways. They can (but not necessarily)
be bidirectional transformations. As shown in Section 4, we can
concatenate the actual parameters of an index function to compute
the result index. In our future work, we plan to investigate other
possible implementation of index functions.
ifThenElse f b1b2is a bidirectional statement that selects b1or
b2according to condition f, where fis a boolean function about the
source and view model. We adapt the semantics of the case state-
ment in BiGUL [ 20] (i.e., a two-branch case statement) for the se-
mantics of this statement. The core function of Xγ
JifThenElse f b 1b2K
returns either the result of Xγ
Jb1K’s core function or the result of
Xγ
Jb2K’s core function, depending on condition f.
matchS patSbfinds a match of patSand then evaluates bbased
on this match (i.e., Fγ
JmatchS patSbKandBγ
JmatchS patSbK). Espe-
cially, in the backward semantics, the match of patSmust also
exist in the updated source model. Similarly, matchV patVbfinds
a match of patVand then evaluates bbased on this match (i.e.,
Fγ
JmatchV patSbKandBγ
JmatchV patSbK). In the backward semantics,
there may be multiple matches of patVfound, but only one match
is expected to be successfully used in the evaluation of b. If no or
many matches of patVcan be used, then the statement returns ⊥.
The core functions of Xγ
JmatchS patSbKandXγ
JmatchV patVbKare the
core function of Xγ′
JbK, whereγ′is the match of patSorpatVthat
is found based on γ.
P(e1, ...,en)denotes the rule call statement. It prepares a new
environment for the callee rule and executes the body statement
(supposing that bis the body of rule P). The core function of this
statement is the core function of b.
Finally, consider the semantics of updateWithBy . Before go-
ing on, we define a conditional statement with adaption (i.e.,
ifThenAdaption f b u ), which will be used to construct the seman-
ticsupdateWithBy .ifThenAdaption is also adapted from BiGUL
[20], so it is a well behaved BX. Informally, in the backward di-
rection, ifThenAdaption executes bidirectional statement bif con-
dition fholds; otherwise, this statement executes unidirectionalstatement uto change the given source model into a new source
that can make fhold, and then executes bwith the new source. In
the forward direction, ifThenAdaption ignores uand behaves like
ifThenElse statement whose else-branch is⊥.
As for updateWithBy patSpatVb ucur, informally, in the back-
ward direction, it aligns the matches of patSwith the matches of
patV, and executes the bidirectional statement b(to synchronize the
aligned source and view matches) and unidirectional statements ur
(to destroy misaligned source matches) and uc(to create matches
ofpatSfor misaligned view matches) according to the alignment
result. In the forward direction, this statement finds all matches of
patSand executes bto construct the view model for each match.
We start from a simple case in which source and view models
(i.e.,SandV) satisfy the following alignment condition : each match
ofpatScan be uniquely aligned with a match of patV, and each
match of patVcan be uniquely aligned with a match of patS(we
useisAliдned(γl,γr), defined in Figure 12, to determine whether a
source match and a view match can be aligned). In fact, in this case,
a view match is uniquely determined by a source match (and vice
versa). Furthermore, only bidirectional statement bwill be executed
for each pair of source and view matches that are aligned. We
view each execution of bas a derived component BX. Because the
view match is fully determined by the corresponding source match,
every component BX is actually derived from a single source match.
Hence, in the simple case, the semantics of updateWithBy can be
viewed as a composition of a set {Xγi
JbK}of derived component
BXs, where γiis a match of patS. We formulate this semantics as
(FJb∗K,BJb∗K)in Figure 12. In FJb∗KandBJb∗K, we explicitly check
equations (8)-(12) and the alignment condition.
Now we consider the complex case where some source/view
matches may be misaligned. Based on the informal semantics
above, ucand urwill be executed to destroy the unaligned
source matches and to construct new source matches that can
be paired with unaligned view matches, respectively. In short,
we execute ucand urto convert the original source model
into a new one that will satisfy the alignment condition . Hence,
given a certain source model S, we can specify the semantics
ofupdateWithBy as follows: Xγ
JupdateWithBy patSpatVb ucurK≡
Xγ
JifThenAdaption f b∗uaK, where fis the alignment condition ,ua
is derived from ucandur. In backward transformation, uacan be
derived as follows: 1) for each misaligned match γsiofpatS, execute
urto obtain Ssi≡Uγsi
JurK(S); 2) for each misaligned match γviof
patV, execute ucto obtain Svi≡Uγvi
JucK(S); 3) merge all SsiandSvi.
In forward direction, we simply ignore uasince it is useless.
5.4 Round-trip Properties of XMU Core
The key to defining a BX language is to assure the well-behavedness
of this language. All bidirectional statements defined in XMU core
can be proven to be well behaved. In this section, we presents the
proof sketch of the well-behavedness of XMU core as the evidence
of the correctness of our approach.
•Xγ
Jreplace patSpatVK: After executing Bγ
Jreplace patSpatVK, we
can ensure that there exists a unique match of patSin the updated
source model which can be found in the forward execution to
442
ESEC/FSE ’18, November 4–9, 2018, Lake Buena Vista, FL, USA Xiao He and Zhenjiang Hu
construct the view model (i.e., PutGet* ).Bγ
Jreplace patSpatVKalso
states that if there is already a match of patSin the original source
model, this statement does nothing (i.e., PutTwice ). After running
Fγ
Jreplace patSpatVK, for the unique match of patS, a view instance
is created which can be paired with the match of patSduring the
backward execution (i.e., GetPut ).
•Xγ
JindexvSvVbK: IfXγ
JbKis well behaved, then this statement is
also well behaved because it does not change the output of Xγ
JbK
(though it appends new object indices).
•Xγ
JifThenElse f b 1b2K: This statement is well behaved because it
is adapted from the case statement in BiGUL (i.e., a case state-
ment with two branches and without adaption). In BiGUL, the case
statement has been verified [20].
•Xγ
JmatchS patSbK: InBγ
JmatchS patSbK, a match of patS, namely
γ′, is found first and then Bγ′
JbKis executed. After executing Bγ′
JbK,
Bγ
JmatchS patSbKalso checks that the match γ′ofpatSstill exists
in the updated source. Hence, PutGet* andPutTwice hold when
Xγ′
JbKis well behaved. In Fγ
JmatchS patSbK, a match of patS, namely
γ′, is found first and then Fγ′
JbKis executed. Hence, GetPut holds
when Xγ′
JbKis well behaved.
•Xγ
JmatchV patVbK: The backward semantics (i.e., Bγ
JmatchV patVbK)
ensures PutTwice . As discussed previously, Bγ
JmatchV patVbKfinds
a match (namely γ′) ofpatVto evaluate b. In this process, it does
not change the information related to source in the original environ-
mentγ. Hence, executing Fγ
JbKresults in a view that is isomorphic
to the result of Fγ′
JbK. Hence, PutGet* must hold when bis well
behaved. Regarding GetPut , inFγ
JmatchV patVbK, the statement ex-
ecutes bto create a view Vthat contains exactly one match of patV
(namelyγ′). If we execute the backward transformation immedi-
ately, we will find a unique match in Vthat must be γ′. Hence,
GetPut holds.
•Xγ
JP(e1, . . .,en)K: If the body statement of P, namely b, is well
behaved, then the rule call statement is well behaved. It is because
that a rule call statement simply constructs a new environment
based onγand then executes bwith the new environment.
•Xγ
Jb1;b2K: This statement is well behaved because this statement is
actually realized by using the model-merging-based BX combinator
⊎(see Theorem 3.1).
•Xγ
JupdateWithBy patSpatVb ucurK: This statement is interpreted
asXγ
JifThenAdaption f b∗uaK, where ifThenAdaption statement is
also adapted from the case statement in BiGUL. Hence, we only
have to prove Xγ
Jb∗Kis well behaved. According to the definition
ofXγ
Jb∗K, we learn that Xγ
Jb∗Kis a composition of Xγ1
JbK,Xγ2
JbK, ...,
Xγn
JbK(they are combined by ⊎), where{γ1, ...,γn}=patS(γ,S). The
definition itself is well behaved. However, this definition of Xγ
Jb∗K
is actually related to the source matches γ1, ...,γn. To ensure Xγ
Jb∗Kis well behaved, we must ensure that γ1, ...,γnare not destroyed
during the backward transformation (since in the forward transfor-
mation, the source model is not changed). In Bγ
Jb∗K, we append an
explicit check at the end of the execution. Overall, the round-trip
properties of Xγ
JupdateWithBy patSpatVb ucurKare satisfied.
6 TOOL SUPPORT AND EXAMPLES
We implemented a prototype tool of XMU on Eclipse platform. The
tool employed Eclipse Modeling Framework [ 27] as the internal
data representation. The language facilities, such as code editor,
interpreter and launcher, were realized based on EMFText [ 26] and
Xtext [ 28]. In our tool implementation, we also extend the syntax
of XMU by providing some syntax sugars, such as the otherwise
branch for switch-case . At present, we applied the dynamic check
of equations (8)-(12) to ensure the well-behavedness of a BX.
To evaluate and demonstrate XMU, we implemented several
benchmark BX programs2using our tool support. Those BX pro-
grams include (but not limited to) the follow programs: 1) the clas-
sic transformation UML2RDBMS between UML class diagrams and
RDBMS models, which has been intensively studied in the model
transformation community (e.g., Zan et al., [ 35] presented a partial
implementation based on BiFluX ); 2) the conversion between a
hierarchical state machine and a flatten state machine ( HSM2FSM ),
which was studied in [ 9]; 3) the book mark example, which was
studied in [ 25] and [ 18]; 4) the nested section example, which was
studied in [ 2]; 5) the address book examples, which were studied in
[25]. Due to space limitation, we cannot present all details of these
examples. A full list of example BX programs (including the source
code and transformation results) is available on our website. To the
best of our knowledge, our implementation of UML2RDBMS is the
first fully implemented putback -based version, which is partially
presented in Section 4.
7 CONCLUSION AND FUTURE WORK
In this paper, we proposed a putback -based language XMU for
bidirectional model transformation and a model-merging-based
BX combinator⊎to address the ambiguity and the shared node
issue. XMU enables us to define a BX in the form of a backward
transformation. According to the semantics presented in Figure 12,
we can derive a unique forward transformation from this backward
transformation to eliminate ambiguities. The model-merging-based
BX combinator allows multiple conversions of the same node and
preserves the result of each conversion if there is no conflict.
There are some open issues that must be investigated in the
future to turn XMU into a more efficient, user-friendly and practical
BX language. First, we believe that XMU core may be refined and
enhanced to improve its semantics and expressiveness. Second,
XMU directly checks equations (8)-(12) at runtime to ensure the
successful application of ⊎. However, doing so may be very time
consuming. We plan to investigate how to efficiently check the
validity of the BX combination. Third, we will explore some useful
implementation mechanisms of index functions and integrate them
into our tool support. Fourth, we will investigate how to support
delta-based, incremental, and symmetric BX, and how to integrate
XMU core with the existing transformation languages. Finally, we
will conduct more case studies to evaluate and apply our approach.
443
Putback-Based Bidirectional Model Transformations ESEC/FSE ’18, November 4–9, 2018, Lake Buena Vista, FL, USA
REFERENCES
[1]2015. Meta Object Facility (MOF) 2.0 Query/View/Transformation specification
V1.2. Technical Report formal/15-02-01. Object Management Group.
[2]Davi M J Barbosa, Julien Cretin, Nate Foster, Michael J Greenberg, and Benjamin C
Pierce. 2010. Matching lenses: alignment and view update. In Proc. of ICFP’10 .
193–204.
[3]Antonio Cicchetti, Davide Di Ruscio, Romina Eramo, and Alfonso Pierantonio.
2011. JTL: a bidirectional and change propagating transformation language. In
Proc. of SLE’11 . Springer, 183–202.
[4]Krzysztof Czarnecki, J. Nathan Foster, Zhenjiang Hu, Ralf Lämmel, Andy Schürr,
and James F. Terwilliger. 2009. Bidirectional Transformations: A Cross-Discipline
Perspective. In Proc. of ICMT’09 (LNCS) , Richard F. Paige (Ed.), Vol. 5563. Springer,
260–283.
[5]Zinovy Diskin. 2008. Algebraic models for bidirectional model synchronization.
InProc. of MODELS’08 . Springer, 21–36.
[6]Zinovy Diskin, Romina Eramo, Alfonso Pierantonio, and Krzysztof Czarnecki.
2016. Incorporating Uncertainty into Bidirectional Model Transformations and
their Delta-Lens Formalization. In Proc. of BX’16 , J. Gibbons A. Anjorin (Ed.).
[7]Zinovy Diskin, Yingfei Xiong, Krzysztof Czarnecki, Hartmut Ehrig, Frank Her-
mann, and Fernando Orejas. 2011. From state-to delta-based bidirectional model
transformations: the symmetric case. In Proc. of MODELS’11 . Springer, 304–318.
[8]Hartmut Ehrig, Karsten Ehrig, Claudia Ermel, Frank Hermann, and Gabriele
Taentzer. 2007. Information preserving bidirectional model transformations. In
Proc. of FASE’07 . Springer, 72–86.
[9]Romina Eramo, Alfonso Pierantonio, and Gianni Rosa. 2015. Managing Uncer-
tainty in Bidirectional Model Transformations. In Proc. of SLE’15 . ACM, 49–58.
[10] Sebastian Fischer, ZhenJiang Hu, and Hugo Pacheco. 2015. The essence of
bidirectional programming. Science China Information Sciences 58, 5 (2015), 1–21.
[11] J. Nathan Foster, Michael B. Greenwald, Jonathan T. Moore, Benjamin C. Pierce,
and Alan Schmitt. 2007. Combinators for Bidirectional Tree Transformations: A
Linguistic Approach to the View-update Problem. ACM Trans. Program. Lang.
Syst. 29, 3, Article 17 (May 2007).
[12] Holger Giese and Robert Wagner. 2009. From model transformation to incre-
mental bidirectional model synchronization. Softw. & Syst. Modeling 8, 1 (2009),
21–43.
[13] Xiao He, ChangJun Hu, ZhiYi Ma, and WeiZhong Shao. 2014. A bidirectional-
transformation-based framework for software visualization and visual editing.
Science China Information Sciences 57, 5 (2014), 1–23.
[14] Xiao He, Zhenjiang Hu, and Yi Liu. 2017. Towards Variability Management in
Bidirectional Model Transformation. In Proc. of COMPSAC’17 . 224–233.
[15] Frank Hermann, Hartmut Ehrig, Fernando Orejas, Krzysztof Czarnecki, Zinovy
Diskin, Yingfei Xiong, Susann Gottmann, and Thomas Engel. 2013. Model syn-
chronization based on triple graph grammars: correctness, completeness and
invertibility. Softw. & Syst. Modeling 14, 1 (2013), 241–269.
[16] Daniel Jackson. 2012. Software Abstractions: logic, language, and analysis . MIT
press.
[17] Frédéric Jouault, Freddy Allilaire, Jean Bézivin, Ivan Kurtev, and Patrick Valduriez.
2006. ATL: a QVT-like transformation language. In Proc. of OOPLSA’06 . ACM,719–720.
[18] Shinya Kawanaka and Haruo Hosoya. 2006. biXid: a bidirectional transformation
language for XML. In ACM SIGPLAN Notices , Vol. 41. ACM, 201–214.
[19] Hsiang-Shang Ko and Zhenjiang Hu. 2018. An Axiomatic Basis for Bidirectional
Programming. In Proc. of POPL’18 . ACM.
[20] Hsiang-Shang Ko, Tao Zan, and Zhenjiang Hu. 2016. BiGUL: a formally verified
core language for putback-based bidirectional programming. In Proc. of PEPM’16 .
61–72.
[21] Yngve Lamo, Florian Mantz, Adrian Rutle, and Juan de Lara. 2013. A declarative
and bidirectional model transformation approach based on graph co-spans. In
Proc. of PPDP’13 . ACM, 1–12.
[22] Marius Lauder, Anthony Anjorin, Gergely Varró, and Andy Schürr. 2012. Bidi-
rectional model transformation with precedence triple graph grammars. In Proc.
of ECMFA’12 . Springer, 287–302.
[23] Nuno Macedo and Alcino Cunha. 2016. Least-change bidirectional model trans-
formation with QVT-R and ATL. Softw. & Syst. Modeling 15, 3 (2016), 783–810.
[24] Hugo Pacheco, Zhenjiang Hu, and Sebastian Fischer. 2014. Monadic combinators
for Putback style bidirectional programming. In Proc. of PEPM’14 . ACM, 39–50.
[25] Hugo Pacheco, Tao Zan, and Zhenjiang Hu. 2014. Biflux: A bidirectional func-
tional update language for XML. In Proc. of PPDP’14 .
[26] EMFText project. 2018. EMFText. http://www.emftext.org/index.php/EMFText
[27] Eclipse Modeling Framework project. 2018. Eclipse Modeling Framework. http:
//www.eclipse.org/modeling/emf/
[28] Xtext project. 2018. Xtext. http://www.eclipse.org/Xtext/
[29] Oszkár Semeráth, Csaba Debreceni, Ákos Horváth, and Dániel Varró. 2016. In-
cremental Backward Change Propagation of View Models by Logic Solvers. In
Proc. of MODELS’16 . ACM, 306–316.
[30] Hui Song, Gang Huang, Franck Chauvel, Yingfei Xiong, Zhenjiang Hu, Yanchun
Sun, and Hong Mei. 2011. Supporting runtime software architecture: A
bidirectional-transformation-based approach. Journal of Systems & Software
84, 5 (2011), 711–723.
[31] Perdita Stevens. 2010. Bidirectional model transformations in QVT: semantic
issues and open questions. Softw. & Syst. Modeling 9, 1 (2010), 7–20.
[32] Gabriele Taentzer, Claudia Ermel, Philip Langer, and Manuel Wimmer. 2012. A
fundamental approach to model versioning based on graph modifications: from
theory to implementation. Softw. & Syst. Modeling 13, 1 (2012), 239–272.
[33] Yingfei Xiong, Hui Song, Zhenjiang Hu, and Masato Takeichi. 2013. Synchroniz-
ing concurrent model updates based on bidirectional transformation. Softw. &
Syst. Modeling 12, 1 (2013), 89–104.
[34] Yijun Yu, Yu Lin, Zhenjiang Hu, Soichiro Hidaka, Hiroyuki Kato, and Lionel
Montrieux. 2012. Maintaining invariant traceability through bidirectional trans-
formations. In Proc. of ICSE’12 . IEEE, 540–550.
[35] Tao Zan, Hugo Pacheco, and Zhenjiang Hu. 2014. Writing Bidirectional Model
Transformations As Intentional Updates. In Proc. of ICSE’14 . ACM, 488–491.
[36] Zirun Zhu, Yongzhe Zhang, Hsiang-Shang Ko, Pedro Martins, João Saraiva, and
Zhenjiang Hu. 2016. Parsing and Reflective Printing, Bidirectionally. In Proc. of
SLE’16 . ACM, 2–14.
444
