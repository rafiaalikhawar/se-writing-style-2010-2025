String Analysis for Side Channels with Segmented Oracles
Lucas Bang1, Abdulbaki Aydin1, Quoc-Sang Phan2, Corina S. P ÀòasÀòareanu2;3, TevÔ¨Åk Bultan1
1University of California, Santa Barbara
Santa Barbara, CA, USA
{bang,baki,bultan}@cs.ucsb.edu2Carnegie Mellon University
Moffet Field, CA, USA
sang.phan@sv.cmu.edu3NASA Ames Research Center
Moffet Field, CA, USA
corina.s.pasareanu@nasa.gov
ABSTRACT
We present an automated approach for detecting and quan-
tifying side channels in Java programs, which uses symbolic
execution, string analysis and model counting to compute
information leakage for a single run of a program. We fur-
ther extend this approach to compute information leakage
for multiple runs for a type of side channels called segmented
oracles, where the attacker is able to explore each segment
of a secret (for example each character of a password) inde-
pendently. We present an ecient technique for segmented
oracles that computes information leakage for multiple runs
using only the path constraints generated from a single run
symbolic execution. Our implementation uses the symbolic
execution tool Symbolic PathFinder (SPF), SMT solver Z3,
and two model counting constraint solvers LattE and ABC.
Although LattE has been used before for analyzing numeric
constraints, in this paper, we present an approach for using
LattE for analyzing string constraints. We also extend the
string constraint solver ABC for analysis of both numeric
and string constraints, and we integrate ABC in SPF, en-
abling quantitative symbolic string analysis.
CCS Concepts
Software and its engineering !Formal software ver-
ication;Security and privacy !Logic and veri-
cation;
Keywords
Side-channel analysis; Symbolic execution; String constraints
1. INTRODUCTION
Since computers are used in every aspect of modern life,
many software systems have access to secret information
such as nancial and medical records of individuals, trade
secrets of companies and military secrets of states. Con-
dentiality, a core computer security attribute, dictates that,
a program that manipulates secret information should notreveal that information. This can be hard to achieve if an
attacker is able to observe dierent aspects of program be-
havior such as execution time and memory usage.
Side-channel attacks recover secret information from pro-
grams by observing non-functional characteristics of pro-
gram executions such as time consumed, number of mem-
ory accessed or packets transmitted over a network. In this
paper, we propose an automatic technique for side-channel
analysis. Our technique uses symbolic execution for the sys-
tematic analysis of program behaviors under dierent input
values. Furthermore, we use model counting [35, 6] over the
constraints collected with symbolic execution to quantify the
leakage of the detected side channels.
We present specialized techniques for segmented oracle
side channels in which an attacker is able to explore each
segment of a secret, for example each character of a pass-
word, independently. Our technique can answer questions
such as \what is the probability of discovering a password in
k runs" or \what is the leakage (in the number of bits) after
k runs" through side channels.
The widespread use of web-based applications have re-
sulted in a greater need for analysis techniques targeted
at string manipulating programs to ensure better security.
However, classic testing approaches, such as guided black-
box and random testing are not capable of reliably detecting
malicious behaviors, simply because the domain of string in-
puts is too large. In contrast, symbolic execution can explore
multiple inputs all at once, through the systematic collec-
tion and solving of symbolic constraints. A key challenge
that we address in this work is to perform constraint solving
and model counting eciently over a combination of string
and numeric constraints. Towards this end we investigate a
set of complementary techniques for symbolic quantitative
string analysis. We implemented these techniques in the
Symbolic PathFinder (SPF) tool [45].
Our contributions can be summarized as follows: 1) Single-
run side-channel analysis using SPF that computes the in-
formation leakage in terms of Shannon entropy using prob-
abilistic symbolic execution and listeners that track the ob-
servable values such as execution time, le size, or memory
usage. 2) Two types of multi-run side-channel analysis for
segmented oracles based on a best-adversary model. The
rst approach composes the adversary model and the func-
tion under analysis within a loop and conducts the multi-run
analysis on the composed system. However, this approach
leads to path explosion. We also present a second, more ef-
cient, approach for multi-run side-channel analysis for seg-
mented oracles that uses path constraints generated for only
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission and/or a
fee. Request permissions from Permissions@acm.org.
FSE‚Äô16 , November 13‚Äì18, 2016, Seattle, WA, USA
c2016 ACM. 978-1-4503-4218-6/16/11...$15.00
http://dx.doi.org/10.1145/2950290.2950362
193
a single-run symbolic execution of the function. 3) We ex-
tend SPF to enable analysis of Java programs that manip-
ulate strings using two approaches. One of them traces the
implementations of string manipulation functions and treats
strings as bounded arrays of characters that are represented
as bit-vectors, and checks satisability of path constraints
using the SMT solver Z3. The second approach generates
constraints in the theory of strings and uses the string con-
straint solver ABC. 4) We use two model counting constraint
solvers for computing information leakage. One of them is a
model counter for numeric constraints called LattE, which
has been used for analyzing numeric constraints in SPF be-
fore. In this paper we extend the SPF+LattE framework to
the analysis of string constraints by viewing strings as arrays
of characters. We also integrate the model-counting string
constraint solver ABC with SPF. We further implement an
extension to ABC that enables model counting for numeric
constraints. With this extension to ABC can perform model
counting for combinations of numeric and string constraints.
5) We conduct experiments on two side-channel examples,
demonstrating the performance of dierent approaches.
Our approach applies to functions which behave as seg-
mented oracles. For example, time-based segmented oracles
can result from library functions that use early termina-
tion optimizations for string, array, and memory equality
comparisons, which are present in many programming lan-
guages including C, C++, Java, Python, Ruby, PHP, and
Node.js [13, 32, 49, 18]. As described in [30], these types of
library functions have enabled real-world segmented oracle
attacks against the Xbox 360 operating system [2], and the
hash-message authentication code (HMAC) comparisons in
the Google Keyczar cryptographic library [31] and the open
authorization standards OAuth [3, 4] and OpenID [40]. We
demonstrate the applicability of our approach given in Sec-
tion 4.2 on a password verication function as an example
of an early termination segmented oracle and this analysis
applies equally well to the other examples just described.
On the other hand, size-based segmented oracles can arise
from text compression functions [24] resulting in leakage of
condential web-session information by measuring the sizes
of les and network communications [46]. We demonstrate
our approach for this type of segmented oracles using LZ77
compression [54]. Although the approach we present in Sec-
tion 4.2 requires an ordered traversal of the secret's segments
(which is the case for all the examples listed above), we be-
lieve that, in the future, it can be generalized to handle
oracles which do not require a specic ordering of segments.
2. SIDE-CHANNEL ANALYSIS
Consider a password-based authentication function. The
password checking function has two inputs: 1) a password,
which is secret, and 2) a user input, which is public. The
function should compare the password and the user input
and return true if the input matches the password and return
false otherwise; it should not leak any information about the
password if the input does not match.
Let us consider two password checking functions F1and
F2whose implementations are shown in Figures 1 and 2,
respectively. We assume that functions F1andF2are exe-
cuted on inputs handl, where we follow the typical notation
used in the security literature: hdenotes the high value, i.e.
the secret password, and ldenotes the lowvalue, i.e. the
public input that the function compares with the password.public F1 ( char [] h, char [] l){
for (int i = 0; i < h.length; i++)
if(h[i] != l[i]) return false ;
return true ;
}
Figure 1: Password checking function F1.
public F2 ( char [] h, char [] l){
matched = true ;
for (int i = 0; i < h.length; i++) {
if(h[i] != l[i]) matched = false ;
else matched = matched;
}
return matched;
}
Figure 2: Password checking function F2.
Both functions return true or false indicating if the input
(l) matches the secret ( h). Note however that the functions
may leak some information about the secret through side
channels , in this case an adversary may infer some informa-
tion about the secret hby measuring the execution time (as
explained below). In general, let us assume that function
F(h;l) returns an observable valueowhich represents the
side-channel measurements of the adversary after executing
F(h;l). The observable value ocan be one of a set of ob-
servable values O. We assume that the observable values are
noiseless, i.e., multiple executions of the program with the
same input value will result in the same observable value.
For the functions F1andF2above, let us use the execution
time as an observable. For function F1this will result in
n+ 1 observable values where nis equal to the length of
h, i.e.,o2 fo0;o1;:::o ng, since function F1will have a
dierent execution time based on the length of the common
prex ofhandl. Ifhandlhave no common prex, then
F1will have the shortest execution time (let us call this
observable value o0) since the loop body will be executed
only once (assuming the password length is not zero). If h
andlhave a common prex of one character (and assuming
that password length is greater than or equal to two), then
F1will have a longer execution time since the loop body
will be executed twice (let us call this observable value o1).
In fact, for each dierent length of the common prex of
handl, the execution time of F1will be dierent. Let
observable value oidenote the execution time of F1for the
common prex of size i. Note that oncorresponds to the
case where handlcompletely match where nis the length
of the password. On the other hand, execution time of F2is
always the same, so F2does not have a side channel.
Side-channel analysis can be used to answer following type
of questions: Are F1andF2leaking information about the
secret through side channels, and, if so, how much? Based
on the above discussion, we can see that F1is leaking in-
formation about heven when handldo not completely
match. By observing the execution time of F1, an adversary
can deduce the length of the common prex of handl.
F2on the other hand leaks no information through the
side channel. Note that an attacker learns that his not
equal to the value of l. However, the information leakage
forF2is pretty small compared to the information leakage
byF1(which has the timing side channel). For example,
assuming the secret is a four digit PIN, an attacker needs at
most 104tries to guess the password using F2but at most 40
tries usingF1(as the adversary can try to rst guess the rst
194digit in the PIN, then secod digit etc. using the side-channel
information). The question is: can we formalize the amount
of information leaked and can we automatically compute it?
2.1 Entropy Computation
Shannon entropy is a well-known information theoretic
concept for measuring the expected amount of information
contained in a message. The observables produced by a
functionFcan be considered the messages that an adver-
sary receives by executing F; they correspond to messages
about the secret. Hence, we can use the Shannon entropy to
measure the amount of information conveyed by each execu-
tion ofF, i.e., the amount of information leaked by function
F. We dene the Shannon entropy of a function Fas:
H(F) = X
oi2Op(oi)log2(p(oi))
wherep(oi) is the probability of observing the value oiafter
executingF. In order to compute the Shannon entropy,
we need to compute the probability of observing each value
oi. We can compute these probabilities using probabilistic
symbolic execution with model counting [16].
Symbolic Execution (SE) [26] is a well known program
analysis technique that executes the program on symbolic,
rather than concrete, inputs and computes the program ef-
fects as functions in terms of these symbolic inputs. Sym-
bolic execution also computes and maintains a path con-
dition ,PC, which is a conjunction of constraints over the
symbolic inputs that characterizes those inputs that follow
each path through the program.
In our analysis we perform symbolic execution (where
bothhandlare symbolic) to systematically analyze all
paths through the code. In this way, we collect each path
condition and corresponding observable as an ordered pair
(oi;PC i). For example, symbolic execution of function F1
results in a set of n+ 1 path conditions, each with a dier-
ent time observation: f(o0;PC 0);(o1;PC 1);:::(on;PC n)g,
witho0<o 1<:::<o n+1, and path conditions of the form:
PC 0h[0]6=l[0]
PC 1h[0] =l[0]^h[1]6=l[1]
PC 2h[0] =l[0]^h[1] =l[1]^h[2]6=l[2]
...
PCn 1h[0] =l[0]^h[1] =l[1]^:::^h[n]6=l[n]
PCnh[0] =l[0]^h[1] =l[1]^:::^h[n] =l[n]
Each path condition PCiencodes the fact that a prex
of the public input lmatches a prex of the secret h. For
example (o1;PC 1) indicates that the rst character in the
public input matches the rst charter in the secret and the
second character does not match. For the largest observable,
we see that ( on;PC n) indicates that the public and private
inputs match on all segments.
We can compute the probability p(oi) for each observable
valueoi, using model counting over the path conditions, in
the following way. Let Ddenote the input domain (i.e.,
the set of possible values for handl, assumed to be nite)
and letjDjdenote the size of the input domain. We write
jPCjto denote the number of solutions over Dthat sat-
isfy the path constraint PC. We can compute jPCjusinga model counting constraint solver [35, 6]. Assuming a uni-
form distribution for handlthe probability of observing
oiisp(oi) =jPCoij=jDjwhere the probability of the input
value completely matching the password hisp(on).
For function F2there are only two observable values through
themain channel , i.e. the boolean values returned by the
function, and the corresponding path constraints are:
:(h[0] =l[0]^h[1] =l[1]^::^h[n 1] =l[n 1])
h[0] =l[0]^h[1] =l[1]^::^h[n 1] =l[n 1]
Figure 3 shows the Shannon entropy computed for F1and
F2as described above using probabilistic symbolic execution
and model counting. Note that as the size of the password
increases, the entropy gets very close to 0 for function F2.
So, for a reasonable sized password, F2does not leak in-
formation. However, for F1we observe that the informa-
tion leaked remains around 1 bit even if we keep increasing
the length of the password. Independent of the size of the
password,F1leaks information about the rst digit of the
password due to the timing side channel.
1234567891000:250:50:7511:25
Password LengthEntropy (bits)F1
F2
Figure 3: Entropy after a single guess for functions
F1andF2, for password length ranging from 1 to 10.
The analysis we presented above computes the amount of
information leaked by a single execution of a function. We
can also easily determine the amount of initial information
in the system by assuming that his picked using a uniform
distribution from the domain Dh. Then the amount of in-
formation in the system initially is:
H(h) = X
v2Dh1=jDhjlog2(1=jDhj) = log2(jDhj)
An execution of the function leaks the amount of information
given by the Shannon entropy of the function H(F) and the
remaining entropy in the system is H(h) H(F).
An interesting question to answer is the following: How
many tries would it take an adversary to gure out the pass-
word? We can try to estimate the attack sequence length
using the information leakage. When the amount of infor-
mation in the system reaches zero, then, we can conclude
that the adversary has gured out the password.
Based on the amount of initial information and the Shan-
non entropy for the function, we can try to estimate the
amount of runs it would take an adversary to determine the
secret. However, this analysis would not be accurate since
an adversary could learn from previous tries and choose the l
values accordingly based on earlier observations. So, except
for the rst run, the adversary would not pick the lvalues
with a uniform distribution from the domain of l. In order
to do a more precise analysis we need to model the adversary
behavior. We discuss how to do this for a particular class of
problems called segmented oracles in the following section.
1953. SEGMENTED ORACLES
Segmented oracle side channels provide observations about
\segments" of the secret. For example, a segmented oracle
side channel can provide an observable value (such as exe-
cution time) that enables an adversary to determine if the
rst character of the secret value (for example a password)
matches to the public value (the input provided by the ad-
versary). In general, a segmented oracle provides a distinct
value for each matched segment (such as the matching the
rst character in the password, matching the rst 2 charac-
ters, the rst 3 characters, etc.)
Note that for the function F1shown in Figure 1, execution
time serves as a segmented oracle side channel. The function
terminates the execution immediately if it determines that
the rst character of the secret does not match the input
and the execution time increases linearly with the number
of segments that match. I.e., by observing the execution
time, an adversary can gure out how many characters of
the secret match the public input. Hence, for the function
F1, execution time acts as a segmented oracle side channel.
The function F1is a particular instance of an early ter-
mination optimized equality comparison. It returns false as
soon as it discovers a mismatch in order to avoid unneces-
sary comparisons. This is a common programming pattern
found in many library functions which results in segmented
oracle timing attacks [13, 32, 49, 18, 30]. These vulnerabil-
ities are remedied by implementing constant time function-
ally equivalent versions of those comparison functions that
operate over sensitive data, for example F2, in order to re-
move the timing side channel [49, 31, 32, 18]. Our approach
provides a method for automatically quantifying the amount
of information an advesary can gain by a function under a
segmented oracle side channel attack, indicating whether a
constant time implementation is necessary.
Now, let us discuss the adversary model. We are assuming
that the adversary is runs a function Fmultiple times with
dierentlvalues (but the secret hstays the same) and is
records the corresponding observables, while trying to gure
outh. Further we assume that the analyzed programs are
deterministic, i.e. given handlvalues,F(h;l) returns one
observable value owhich represents the observations of the
adversary after executing F(h;l). For segmented oracles the
observable values consist of a set of values o2fo0;o1;:::o ng
whereo0denotes no segments of the input ( l) and secret ( h)
match,oidenotesisegments of the secret match the input,
andondenotes the secret completely matches the input.
We call each execution of Fa run. So, the adversary is
generating a sequence of lvalues to run the program multi-
ple times, the intuition being that each run reveals some new
information about the secret. We can formalize the adver-
sary as a function Athat takes all the prior history as input
(which is a sequence of tuples where each tuple is a lvalue
and the corresponding observable for the execution of func-
tionFwith thatlvalue). Note that the hvalue is constant
and does not change from one execution to the other.
We can model the whole system S= (A;F), where the
adversaryAgenerateslvalues for multiple executions of the
functionFin order to determine the secret h, as follows.
Given the system S= (A;F) we may want to compute
the probability of determining the secret after kruns, i.e.,
havingjseqj=kwhenSterminates. Or, we may want to
compute the information leakage (i.e., entropy) for kruns.
One approach would be to analyze the system Swithoutrestricting the adversary. However, this would take into ac-
count behaviors such as the adversary trying the same lvalue
over and over again even though it does not match the se-
cret. When analyzing vulnerabilities of a software system,
we have to focus on the behavior of the best adversary.
procedure S= (A;F), initiallyseq nil
repeat
l A(seq)
o F(h;l)
seq append (seq;hl;oi)
until (o=on)
For the segmented oracles, it is easy to specify the best
adversaryAB[22]. This adversary works as follows: Let
hl1;o1i;hl2;o2i;:::;hlk;okibe the run history. The adver-
sary generates lk+1for thek+ 1st run as follows:
Ifok6=ok 1andok=oi, then the adversary con-
structslk+1as follows:8j;1j <i :lk+1[j] =lk[j]
(part oflthat already matched remains the same),
lk+1[i]6=lk[i], (use a dierent value for the rst part
that did not match in the last try) and rest of the lk+1
is randomly generated.
Ifok=ok 1, then letmbe the smallest number where
om=okand letok=om=oi, then the adversary con-
structs the lk+1as follows:8j;1j < i :lk+1[j] =
lk[j] (part oflthat already matched remains the same)
and8j;mj < k :lk+1[i]6=lj[i] (use a dierent
value then the values that have already been tried for
the rst part that does not match) and rest of the lk+1
is randomly generated.
LetSkdenote the execution of the system S= (AB;F)
where the function Fis executed ktimes, i.e.,jseqj=k. We
can ask the following question: What is the probability of
the adversary ABguessing the password in exactly ktries?
Note that, execution of Skwill generate observable se-
quenceso1;o2;:::;okwhere for all 1tk;ot=oi^ot+1=
oj)ji. I.e., since we are using the best adversary
modelAB, the observable values in the sequence will be
non-decreasing. The adversary will never produce a worse
match than the one in the previous try. Another constraint
for the observable sequences is that if onappears in a se-
quence, then onis the last observable of the sequence since
Sterminates when onis observed.
We can calculate the probability of determining the pass-
word in exactly ktries as the probability of generating the
observable sequences o1;o2;:::;olwherelk, observable
values in the sequence are non-decreasing, and ol=on.
Letp(o1;o2;:::;ok) denote the probability of Skgenerat-
ing that particular observable sequence. Then we can com-
pute the entropy for Sk(i.e., the information leakage within
the rstkruns) as follows:
H(Sk) = X
o1;o2;:::;ol2SEQkp(o1;o2;:::;ol)log2(p(o1;o2;:::;ol))
whereSEQkis the set of all non-decreasing observable se-
quences that can be generated by the rst kiterations of
S= (AB;F). For every sequence o1;o2;:::;ol2SEQk:
1)lk, 2) the observable values in the sequence are non-
decreasing, 3) if onappears in the sequence, then it is the
last observable in the sequence, and 4) if ondoes not appear
in the sequence, then l=k.
1964. MULTI-RUN SIDE-CHANNEL ANALYSIS
In this section we present two approaches to multi-run
analysis of segmented oracles. The rst approach is intuitive
and more general; it is applicable to any adversary model.
However, this approach requires the probabilistic symbolic
execution of an adversary model which executes the program
multiple times, and thus it suers from the path explosion
problem. To address this problem, for the best adversary
model, we propose a more scalable approach with a novel
computation of the leakage which requires the probabilistic
symbolic execution on only one run of the program.
4.1 Multi-Run Symbolic Execution
Our rst approach for multi-run side-channel analysis is
described with the following two steps. First, we create a
model of the attack scenario, explained in Section 3, where
an adversary can provide the low inputs, and execute the
program a number of times. Then, we use probabilistic
symbolic execution to explore all possible observations of
the model and compute the probability for each observa-
tion. Shannon entropy and channel capacity of the leaks are
easily derived from the probabilities.
In this work, a model in our analysis is a Java bytecode
program, written as a driver for the program under test.
Since the secret hand the inputs of the adversary l1;:::lk
are not known in advance, they are modeled by symbolic
variables in symbolic execution. Without any constraints
onl1;:::lk, this is a model for a very naive adversary, who
repeatedly tries to guess the secret with random values, and
learns nothing from the previous attempts.
To model an adversary who gains information through
observing program executions and revises the input domain
accordingly, we use the assume-guarantee reasoning in SE
to impose the constraints on the inputs. We illustrate the
approach by implementing a particular adversary model.
4.1.1 The Best Adversary Model
ProcedureSin Figure 4 depicts a driver modeling the best
adversary described in section 3. Here an observation oiof
the adversary indicates how many segments in the low input
matched with the secret. The adversary is allowed to make
kexecutions of F(h;l) but stops early if all the segments
are matched, i.e. oi=jhj. The instruction assume , imple-
mented by the built-in API Debug.assume in SPF, is used
to impose constraints on the inputs.
The best adversary is characterized by two sets of assump-
tions. The rst set of assumptions reect the fact that,
for the segment being search s, the best adversary selects
an input dierent from the ones in the previous executions.
When the adversary discovers more segments of the secret,
i.e. whenoi>oi 1, she keeps these segments for the inputs
of the following executions, and moves on to search for the
next segment. This is modeled by the second set of assump-
tions in the procedure.
4.1.2 Computation of Information Leakage
In this approach, the computation of leakage does not
depend on any particular adversary model S= (A;F), i.e.
it can be applied to any model with any assumptions made
by the adversary, or even no assumptions at all.
For our analysis, we extend classical symbolic execution
to keep track of the assumptions ASM in a symbolic path.
At a low level, ASM is implemented with exactly the sameprocedure S= (AB;F)
vars
s: the current segment of hbeing searched
b: the rst time sis searched
o0;o1;:::ok: observations of the adversary
begin
s 1,b 1,o0 0
for alli2[1::k]f
for allj2[b::i)fassume (li[s]6=lj[s])g
oi F(h;li)
if(oi=jhj)freturng
if(oi>oi 1)f
for allj2[i+ 1::k]f
for alln2[s::oi]fassume (lj[n] =li[n])g
g
s oi+ 1,b i+ 1
g
g
end
Figure 4: Adversary Model
data structure as the path condition. When executing the in-
struction assume (c), symbolic execution updates the path
conditionPC PC^c, and checks satisability with a con-
straint solver. symbolic execution advances to the next in-
struction if the updated PCis satisable, and it backtracks
otherwise. Our extension for symbolic execution updates
ASM ASM^conly when the updated PCis satisable.
Thus, there is no constraint solving overhead for ASM .
We performs symbolic execution, with our extension, on
the modelS= (A;F) to explore all possible observations.
Each observation of Sis a sequence of observations of F:  !oi=ho1;o2:::oniwhere 1nk. For each  !oi, we
also obtain from symbolic execution the path condition PCi
that leads to that observation, and the assumptions ASM i
on that path.
We denote by Dh;D1;D2:::D kthe domains of h;l1;l2:::lk
respectively. The input space is then D=DhD1Dk.
If there is no assumptions on the low inputs, lican take any
valueDi. Hence, the search space of the adversary is D, and
the probability of observing  !oiis computed by
p(  !oi) =jPCij
jDj
In the case the adversary has some knowledge about the
input, modeled by the assumptions, the revised domain of  !oiisjASM ij, and hence its probability is
p(  !oi) =jPCij
jASM ij
BothjPCijandjASM ijare computed by model counting
tools integrated in probabilistic symbolic execution. We will
discuss in more details about these tools in later section.
4.2 Multi-Run Analysis Using Single-Run
Symbolic Execution
As shown in the previous section, we are able to compute
the probabilities of observation sequences by performing a
complete symbolic execution of a program which simulates
the adversary strategy of repeated guessing. However, per-
forming a complete symbolic execution over all iterations
of adversary behavior can become prohibitively expensive.
Therefore, we seek to avoid this expensive computation. In
197this section, we describe how to compute the sequence prob-
abilities using symbolic execution and model counting from
only a single iteration of the adversary strategy, by taking
advantage of the segmented nature of observations which
reveal the secret.
Notation. For a segmented oracle the low ( l) and high
(h) inputs are compared incrementally. The nsegments of l
andhare denoted by l[0];:::;l [n 1] andh[0];:::;h [n 1],
respectively. We write h[i:j] for the\slice"of hfrom index i
to indexj, and similarly for l. We letDibe the domain size
ofl[i], or equivalently, the domain size of h[i], and we write
D=hD0;D1;:::;D n 1ifor the vector of these domain sizes.
We will write Di:jto denote the subvector of Dof indicesi
throughj, andQDfor the product of all elements of D.
Probability Computation. By performing a symbolic ex-
ecution of a single run of F(h;l) we can automatically gener-
ate the set of observables and corresponding path conditions,
f(oi;PC i) : 0ing. Without loss of generality we as-
sume an order of observables, o0<o 1<:::<o n+1, and we
assume that the path conditions are in the form given be-
low, a generalization of the path conditions given in Section
2. Path constraints of this form result from symbolic execu-
tion of comparison functions which utilize the early termi-
nation optimization programming pattern, as described in
Section 2.
PCi8
>>>><
>>>>:(l[i]6=h[i])^ i 1^
j=0h[j] =l[j]!
ifi<n
n 1^
j=0h[j] =l[j] if i=n
Due to the segmented nature of the comparison between
landh, we can consider the size of the domain Difor each
segment, that is, the number of possible values to which
each segment can be assigned, independently. Then each
PCidetermines a combinatorial restriction on the set of D.
In the case of PCnwhere each h[i] =l[i], we have that
for any of the Divalues forl[i], the value of h[i] is
constrained to a single value. Therefore, the product
of the domain sizes must be equal to jPCnj.
ForPCi(i<n ), we have that h[j] =l[j] forj <i , and
so for any of the Divalues forl[j],h[j] is constrained
to be a single value. Since, h[i]6=l[i], for any of the
Divalues forl[i], there are Di 1 possible values for
h[i]. Finally for j > i there is no constraint on the
relationship between l[i] andh[i] and so there are Di
possible values for each of them.
The combinatorial argument above can be summarized by
the following system of equations:
(QD=jPCnjQD(wi 1)QDi+1:n 1=jPCij
This system of equations can be solved for each wivia re-
verse substitution using the following recurrence:
Di=jPCij
jPCnjQDi+1:n 1+ 1
Once we have determined the domain sizes of the indi-
vidual segments, we are in a position to compute the prob-
ability any particular observation sequence. Let p(  !ojD)
be the probability of observation sequence  !ogiven a vec-
tor of segment domains D. In addition, we dene D0
itobe the vector of domains constrained by PCi. That is D0
i=
h1;1;:::;D i 1;Di+1;:::;D ni. Thenp(  !ojD) can be com-
puted recursively using the following logic:
Base Case: if  !o=oiis a sequence of length 1, the
probability of oiis (QD0
i)=(QD), that is, the num-
ber of remaining possible inputs that are consistent
with (oi;PC i), out of the total number of inputs in
the domain.
Recursive Case: if  !o=ho1;o2;:::okiis a sequence
of lengthkwe can think of it as o1followed by a se-
quence of length k 1. Then computing p(  !ojD) re-
duces to computing the probabilities of p(o1jD0
i) and
p(ho2;:::;okijD0
i) and multiplying.
The above presented computation results in the same prob-
abilities that are computed by a full probabilistic symbolic
execution analysis of the adversary's complete attack be-
havior. Given the probabilities, we can simply apply the
entropy formula. We have implemented both methods and
experimentally veried that they produce the same results.
However, the second method is signicantly faster. We dis-
cuss this in Section 6 containing our experimental results.
5. STRING CONSTRAINTS
In this section we discuss our extensions to SPF for string
analysis and model counting. Our work is motivated by the
extensive use of string manipulation in modern software ap-
plications. Some common reasons for using string manipula-
tion are: 1) creation of documents in HTML or XML format,
2) runtime code generation, 3) creation of queries for back-
end databases, 4) validation and sanitization of user input.
In order to analyze modern software systems it is necessary
to handle string constraints.
F!Cj:FjF^FjF_F (1)
C!S=S (2)
jmatch (S; S ) (3)
jcontains (S; S ) (4)
jbegins (S; S ) (5)
jends (S; S ) (6)
jI=IjI < I (7)
S!vjs (8)
jS:SjS|SjS(9)
jreplace (S; S; S ) (10)
jsubstring (S; I; I ) (11)
jcharAt (I) (12)
jtoString (I) (13)
I!vjn (14)
jI+IjI IjIn (15)
jlength (S) (16)
jindexOp (S; S ) (17)
Figure 5: String Constraints
We dene the set of string constraints using the gram-
mar shown in Figure 5 where Cdenotes the basic con-
straints,ndenotes integer values, s2denotes string
values, and vdenotes string and integer variables. This con-
straint language can model complex string operations avail-
able in Java and in many modern programming languages
such as boolean matches(String) ,int indexOf(String, int) ,
String substring(int, int) ,String replace(String, String) .
1985.1 Symbolic Execution with Strings
We experimented with two approaches for handling of
string operations in SPF: 1) Numeric encoding reduces string
operations to numeric constraints, 2) String encoding maps
string operations to string constraints.
All existing string solvers are limited in their capabilities
of handling mixed integer and numeric constraints. Many of
the current solutions to symbolic execution for strings sup-
port only a subset of such operations. The approaches to
model counting are even more limited. We therefore imple-
mented a numeric encoding approach in SPF that uses the
low-level Java implementations of the String classes and uses
models only for the native calls in these methods. This eec-
tively reduces all string operations to low-level numeric op-
erations over arrays of characters (representing the strings).
The low-level Java implementations of string operations can
thus be analyzed with SPF and the generated numeric con-
straints can be handled with available solvers such as Z3 [39].
Furthermore, o-the-shelf numeric model-counting proce-
dures for numeric constraints such as LattE [35] can be used.
This numeric encoding approach has the advantage that it
is robust and general (it can handle arbitrary combinations
of numeric and string constraints) but it can only analyze
symbolic strings of xed length.
The second approach we implemented maps string oper-
ations directly to string constraints. For this approach we
built on SPF's existing capabilities for symbolic execution
over strings [45]. SPF maintains an additional path con-
dition that encodes directly operations from Java String,
StringBuilder and StringBuer APIs. The constraints main-
tained by SPF are built from string expressions described by
the grammar in Figure 5.
In this string encoding approach, SPF does not analyze
the implementations of the string operations. Instead it
builds string expressions based on the string operations (and
assumes the implementations are correct). For example,
when if(cmd.indexOf(‚Äô ‚Äô)==-1) is executed with sym-
bolic value s1forcmd, the method indexOf is not actu-
ally executed inside SPF but rather a symbolic string ex-
pression is created which can later appear in the symbolic
string expressions and path conditions built by the analysis,
e.g. symbolic constraint s1.indexOf(‚Äô ‚Äô)=-1 is added to
the string PC. We integrated the model-counting string con-
straint solver ABC to SPF to support this string encoding
approach.
5.1.1 Automata Based Constraint Solving
Automata Based model Counter (ABC) is an automata
based constraint solver that also supports model counting [6].
ABC was originally developed for string constraint solving.
In this paper, in order to support model counting both for
numeric and string constraints and their combinations, we
extended ABC to support numeric constraints. Below we
explain how ABC converts numeric and string constraints
to automata.
String Constraints.
Given an automaton A, letL(A) denote the set of strings
accepted by A. Given a constraint Fand a string variable
v, our goal is to construct a deterministic nite automaton
(DFA)A, such thatL(A) = JF;v Kwhere JF;v Kdenotes the
set of strings for which Fevaluates to true when substituted
for the variable vinF.ab ab
a;b
(a)
 1 0 10
0;0
1;1
10
0;1
11
0
1
0
0
11
0
0
0;0
1;1
1
(b)
Figure 6: Automata (a) for the string constraint
:(x2(ab))^length (x)1and (b) for the numeric
constraint x y<1.
Let us dene an automata constructor function Asuch
that, given a string constraint Fand a variable v,A(F;v) is
an automaton where L(A(F;v)) = JF;v K. Below we discuss
how to implement the automata constructor function A.
Let us rst discuss Boolean operators. Given a constraint
:F, in order to construct A(:F;v) we can rst construct
A(F;v) and use automata complement to construct A(:F;v)
whereL(A(:F;v)) =  L(A(F;v)). For constraints
in the form F1^F2andF1_F2, we can rst construct
A(F1;v) andA(F2;v). Then we can construct A(F1^F2;v)
andA(F1_F2;v) using automata product, where L(A(F1^
F2;v)) =L(A(F1;v))\L(A(F2;v)) andL(A(F1_F2;v)) =
L(A(F1;v))[L(A(F2;v)).
Automata constructor A(C;v) for basic constraints Ccan
be implemented for each basic constraint type shown in Fig-
ure 5 as discussed in [6]. As an example, consider the string
constraintF:(x2(ab))^length (x)1 over the
alphabet  =fa;bg. In order to construct A(F;x), we rst
constructA(x2(ab);x), andA(length (x)1;x), and
use automata complement and automata product operations
to obtain the resulting automaton shown in Figure 6(a).
A constraint Fmay have more than one variable. In that
case, we use the same algorithm describe above to construct
an automaton for each variable in F. If two variables ap-
pear in the same basic constraint, we do a projection for
each of them. In a multi-variable constraint, for each vari-
ablev, we would get an over-approximation of the truth-set
A(F;v)JF;v K. We can eliminate over-approximation by
solving the constraint iteratively. At each iteration, we ini-
tialize eachA(F;v) to automaton that is obtained in the
previous iteration for the same v. We stop the iteration
when there is no more change in any A(F;v). Note that,
using multiple variables, one can specify constraints with
non-regular truth sets. For example, given the constraint
Fx=y : y ,JF;x Kis not a regular set, so we cannot
construct an automaton precisely recognizing its truth set.
In that case, we put a bound on the number of iterations for
constraint solver and return an over-approximation of the
truth set when the bound is reached.
Numeric Constraints.
In order to handle numeric constraints in ABC, we im-
plemented the automata construction techniques for linear
199arithmetic constraints on integers [8]. The approach we
use can handle arithmetic constraints that consist of lin-
ear equalities and inequalities (= ;6=;>;;;<) and logical
operations (^;_;:).
Similar to string constraints, the goal is to create an au-
tomaton that accepts solutions to the given formula. How-
ever, for numeric constraints, it is necessary to keep relation-
ships between integer variables in order to preserve precision.
For example, given a numeric constraint such as 2 x y= 0,
we would like the automaton to recognize the tuples ( x;y)
such that (x;y)2f(0;0);(1;2);(2;4);(3;6);:::g. If we sep-
arate the set of values for xandyand recognize the set
0;1;2;3;::: forxand the set 0 ;2;4;6;::: fory, then we
would get tuples such as (2 ;2), which are not allowed by the
constraint 2 x y= 0. To address this, we use multi-track
automata which is a generalization of nite state automata.
A multi-track automaton accepts tuples of values by reading
one symbol from each track in each transition. I.e., given an
alphabet , a k-track automaton has an alphabet k.
For numeric constraints, we use the alphabet  = f0;1g.
The numeric automata accept tuples of integer values in
binary form, starting from the least signicant digit.
We implement an automata constructor function Afor nu-
meric constraints, such that, given a numeric constraint F,
A(F) is an automaton where L(A(F)) = JFK. Note that, for
numeric constraints, A(F) accepts tuples of integer values,
one for each variable in the constraint F. Each variable in
Fis mapped to a unique track of the multi-track automaton
that we construct.
The automata constructor Afor numeric constraints han-
dles the boolean operators :;^;_the same way as the au-
tomata constructor for string constraints. Each basic nu-
meric constraint is in the formPn
i=1aixi+a0op0, where
op2f=;6=;>;;;<g,aidenote integer coecients and
xidenote integer variables. The automata construction for
basic numeric constraints relies on a basic binary adder state
machine construction [8]. The state machine starts from a
state labeled with the constant term a0. It reads the rst bi-
nary digit of all the variables, computes the result of the sum
for the rst digit and the carry. The next state is the state
that corresponds to the new carry. Using each digit and the
current carry, it is possible to compute the next carry which
dene the transitions of the state machine. Accepting states
are determined based on the operation op. For example, if
the operation is =, then all the resulting digits should be
equal to 0 and the carry should also be 0. So the state 0 is
accepting and all transitions that result in a non-zero digit
go to the sink state. In order to handle negative values,
2's-complement representation is used.
As an example, in Figure 6(b) we show the multi-track
automaton that accepts tuples of integer values that satisfy
the constraint x y < 1 (the transitions are labeled with
the digit for variable xon top of the digit for variable y).
5.2 Model Counting
Model counting for numeric path conditions using Latte
has been implemented in our previous work [16]. As model
counting is expensive we perform several optimizations. First
the path condition PCis partitioned into independent com-
ponents which can be solved separately: PC=c1^c2^^
cn, where a variable xin a component cidoes not appear in
any other component. Therefore jPCj= ijcij.If a component ciis a set of linear integer constraints,
it is simplied and normalized further by using the Omega
library [1]. Latte [35] is then used on this normalized con-
straint to count the models of ci.
As we described above, ABC is an automata-based con-
straint solver that, give a constraint Fconstructs an au-
tomatonA(F) whereL(A(F)) = JFK. Note that,jFj=
jL(A(F))j. So, in order to count the number of solutions
for a constraint F, we need to count the number of strings
accepted byA(F). Counting the number of accepted strings
by an automaton corresponds to counting the number of ac-
cepting paths [6]. For example, consider the automaton for
constraintF:(x2(ab))^length (x)1 shown in
Figure 6(a). In the language L(A(F)), we have zero strings
of length 0 ( "62L(A(F))), two strings of length 1 ( fa;bg),
three strings of length 2 ( faa;ba;bbg), and so on.
Given an automaton A, consider its corresponding lan-
guageL(A). LetLi(A) =fw2 L(A) :jwj=ig, the
language of strings in L(A) with length i. ThenL(A) =S
i0Li(A). The cardinality of L(A) can be computed as
jL(A)j=P
i0jLi(A)j.
Note that the number of strings accepted by an automaton
could be innite in the presence of loops. In applications of
model counting (such as probabilistic symbolic execution)
a model counting query is accompanied with a bound that
limits the domain of the variable. For string variables this
is the length of the strings, whereas for numeric variables it
is the number of bits. These correspond to the length of the
accepted strings for our automata representation of string
and numeric constraints.
Computation ofjL(A)jwithin a bound can be done by
constructing the adjacency matrix of the automaton based
on its transition relation, and then using matrix exponenti-
ation to compute the number of accepting paths. We rst
add a new extra state to the automaton and connect each
accepting state to this new state with -transitions where 
is a new padding symbol that is not in the alphabet of A.
The augmented DFA preserves both the language and count
information of A. From this augmented DFA we construct
the adjacency matrix Twhere matrix entry Ti;jcorresponds
to the number of transitions from state sito statesj. Let
n+1 denote the new state that was added. We can compute
jLm(A)jby computing the matrix Tmby matrix exponentia-
tion wherejLm(A)j=Tm
n+1;n+1. Moreover, we can computeP
0imjLi(A)jmy modifying the matrix Tto matrix by
adding a self-loop to the new state that was added. After
that modicationP
0imjLi(A)j=Tm
n+1;n+1.
Note that this approach works both for numeric and string
constraint automata. Hence, using an automata-based con-
straint solver provides a general approach to model counting.
6. EXPERIMENTS
To validate the eectiveness of our methods, we rst eval-
uated ABC by comparing it with LattE. Next we compare
the eciency of using multi-run vs. single-run symbolic ex-
ecution for computing the entropy after a sequence of ob-
servations. Lastly, we have tested our side-channel analysis
on: 1) the password checking function described in Section 3
which is susceptible to a timing attack, and 2) a compression
function which contains a side channel based on the size of
the compressed output le.
2000 5 10 15 200246
Password LengthTime (s)LattE
ABC Numeric
ABC String
Figure 7: Time comparison for computing single
guess entropy using ABC and LattE.
6.1 Timing Performance of Model Counting
Symbolic PathFinder already contained an implementa-
tion of path constraint model counting using LattE [15]. In
addition, we integrated ABC in SPF for counting solutions
to path constraints. Our experiments show that ABC and
LattE produce identical model counting results. To compare
running time, we analyzed the password checking function.
We compare the end-to-end running time of performing sym-
bolic execution, collecting path constraints, and performing
model counting on all generated constraints in order to com-
pute the information leakage of a single run by the adversary.
We nd that the implementation using ABC is signicantly
faster than the previous implementation that uses Latte. As
shown in Figure 7, for a xed alphabet size of 4, we see that
the running time increases with the password length for both
ABC and LattE, and that the ABC Numeric implementa-
tion is signicantly faster, with ABC String second fastest,
and the Latte implementation slowest.
However, we do not claim that ABC is faster than Latte.
ABC is implemented as a shared library in SPF allowing
for direct function calls to the model counter. On the other
hand, in order for SPF to pass constraints to Latte, they
are rst preprocessed and simplied using the Omega library
and then saved to a set of les. Latte is then invoked on these
les and the model counts are parsed back into JPF. In order
to make any claims about the relative eciency of ABC and
LattE we will need to do a comparison of the constraint
model counting capabilities directly. This is future work.
1234567891002040
Observation Sequence LengthRunning Time (s)Single-run SE
Multi-run SE
Figure 8: Time for multi-run and single-run SE.
The remaining experiments were conducted using ABC
Numeric as the model counter, due to the relative execution
speed of the implementation within SPF.
6.2 Single- and Multi-run Symbolic Execution
As described in Section 4, we have given two methods for
computing the entropy after the adversary makes kobserva-
tions: performing symbolic execution over the k-composition
of the program under an adversary model (Section 4.1.1)
and performing symbolic execution over a single copy of theprogram and then using mathematical formula to infer the
multi-run entropies (Section 4.2).
We ran both analyses on the password checking example
and, as expected, we see in Figure 8 that the multi-run anal-
ysis takes much longer, due to the exploration of many more
paths generated by symbolic execution.
6.3 Password Checker
We also present results on the timing analysis of the pass-
word checking function. We present results only for multi-
run analysis using single-run execution here, as we have just
described that it is much faster and produces the same re-
sults. We rst describe results for a small conguration
where we x the alphabet size to 4 and the password length
to 3. We assume that the adversary can make kguesses,
and we compute the remaining entropy and the information
leakage as shown in Figure 9. There are 43= 64 possible in-
puts forhgiving log264 = 6 bits for the initial entropy. As
the adversary makes more guesses, the remaining entropy
decreases from 6 to 0. Indeed, our analysis shows that the
entropy is 0 for k10. Symmetrically, we can see that the
information leakage increases with more guesses, from 0 to
6, indicating that all information about the secret is leaked
after 10 guesses. Thus, we conclude that the adversary needs
at most 10 guesses to fully determine the secret.
We also analyzed a larger conguration. For a password of
length 10 and an alphabet of size 128, we incrementally in-
creased the guessing budget of the adversary and determined
that 15 guesses are required to reveal 1 bit of information.
This analysis took 135.34 seconds.
0 2 4 6 8 100123456
Observation Sequence LengthEntropy (bits)Initial Entropy
Leakage
Remaining Entropy
Figure 9: Information leakage and remaining en-
tropy for password checking function.
6.4 Text Concatenation and Compression
We further analyzed side channels that depend on the
size of the output. One example of such an attack is known
as \Compression Ratio Info-leak Made Easy" (CRIME)[46].
The function concatSAndCompress() shown in Figure 10
accepts an input low which is controlled by the adversary,
concatenates it with a secret high value high , and then uses
the Lempel-Ziv (LZ77) [54] compression algorithm on the re-
sulting string. We do not show the code for LZ77compress
here, as it requires approximately 60 lines of Java code.
public concatAndCompress (String low){
return LZ77compress(high.concat(low));
}
Figure 10: A function with a size-based side channel.
201The basic idea behind the attack is that if the adversary
provides a value for lowthat does not have a common pre-
x with high , then there will be little compression. How-
ever, if low andhigh do share a prex, this will result in
a higher compression ratio. This is real-world vulnerabil-
ity that can be used to reveal secret web session tokens to
a malicious user by observing compressed network packet
size [24]. Such a user is able to control input through, say,
a web form, which is later concatenated with session infor-
mation and sent to the server. For instance, suppose the
secret value high is the text sessionkey:xb5du . If the
malicious user sets the value of low to be the text string
sessionkey:abcde he will observe less compression than
if he sets low to be sessionkey:xb5da . In this way, the
attacker is able to make repeated guesses and incrementally
learn more information about prexes of the secret. Thus,
theconcatAndCompress() function acts as a segmented
oracle with a side channel on the size of the output.
We apply our analysis to concatAndCompress() and we
are able to compute the information leakage for a given bud-
get on the number of guesses used by the adversary. Due to
the complexity of the LZ77 algorithm, symbolic execution
becomes more expensive than in the case of the password
checking function. For a secret of length 3 and alphabet size
4 single-run symbolic execution generates 187 path condi-
tions leading to 4 dierent observables. For each observable
oi, we built the disjunction of all the PCs that result in
oiand we used Z3 to prove logical equivalence to the PC
formulation in Section 4.2. Using the single-run method we
then determined that the concatAndCompress() function
leaks all information about the secret after 10 executions by
the adversary. Using ABC Numeric for model counting, the
total running time of this analysis is 8 :695 seconds. We
repeated this experiment using ABC String as the model
counter. The same results took 152 :332 seconds to com-
pute, due to the complex nature of the string operations
contained in the LZ77 compression algorithm.
7. RELATED WORK
Side-channels attacks received signicant attention in pre-
vious work [9, 28, 10, 14]. Kocher [28] addresses timing at-
tacks against cryptographic systems using statistical tech-
niques treating the attack as a signal detection problem
where the signal consists of the timing variation due to the
target secret bit and \noise" results from measurement inac-
curacies and timing variations in the unknown secret bits.
Brumley and Boneh [9] further study timing attacks against
OpenSSL implementations and show how to extract private
keys using similar testing techniques over multiple rounds
of attacks on OpenSSL-based web servers running on a ma-
chine on a local network. CacheAudit [14] uses static anal-
ysis for cache side channels to derive formal, quantitative
security guarantees for a comprehensive set of side-channel
adversaries, based on observing cache states, traces of hits
and misses, and execution times.
Quantitative measurement of information leakage has been
an active are of research. Early work [38] measured the
number of tainted bits, not an information-theoretic bound.
Most previous work [12, 7, 43, 27, 41, 42], quantify the leak-
age in one run of the program given a concrete value of
low input. Single-run analysis is addressed in [19] where
bounded model checking is used over the k-composition of
a program to determine if it can yield kdierent outputs.Further LeakWatch [11] estimates leakage in Java program
based on sampling program executions on concrete inputs.
Kopf and Basin [29] present a multi-run analysis based on
an enumeration algorithm. Mardziel et al. [37] generalizes
the work by considering probabilistic systems to account for
secrets that change over time.
In previous work [44] we give a formulation of multi-run
side channel analysis using symbolic execution and Max-
SMT solving. The focus of that work is to synthesize the
worst case attack for arbitrary side channels, in the context
of non-adaptive attacks. In contrast here we assume the
worst case attack is known and it is adaptive, i.e. the at-
tacker changes the public input based on the observations
made so far. Further we give an ecient computation of
leakage tailored to side channels with segment oracles for
string manipulating programs.
There has been signicant amount of work on string con-
straint solving [20, 25, 21, 47, 17, 53, 33, 5, 34, 48]; how-
ever none of these solvers provide model-counting functional-
ity. SMC is the only other model-counting string constraint
solver that we are aware of [36]. ABC is strictly more pre-
cise than SMC. Namely SMC cannot propagate string values
across logical connectives which reduces its precision dur-
ing model counting, whereas we can handle logical connec-
tives without losing precision. We can also handle complex
string operations such as replace that SMC cannot han-
dle. ABC builds on the automata-based string analysis tool
Stranger [52, 50, 51] determined to be the best string solver
in terms of precision and eciency in a recent empirical
study [23]. An earlier version of ABC was presented in [6].
In this paper we extended the functionality of ABC to handle
all string operations in Java, numeric constraints, and the
ability to perform model counting for numeric constraints.
Further, we integrated ABC in SPF.
8. CONCLUSIONS
We presented a symbolic execution approach for side chan-
nel analysis. We illustrated our approach on side channels
with segmented oracles and we gave an ecient computation
of leakage over multiple attack steps. Our technique lever-
ages satisability checking and model counting over complex
constraints involving both string and numeric operations. In
the future we plan to extend our side-channel analysis with
segmented oracles in the presence of noisy observations.
9. ACKNOWLEDGMENTS
We thank the anonymous reviewers for their construc-
tive comments. This material is based on research spon-
sored by NSF under grants CCF-1548848 and CCF-1549161
and by DARPA under agreement number FA8750-15-2-0087.
The U.S. Government is authorized to reproduce and dis-
tribute reprints for Governmental purposes notwithstanding
any copyright notation thereon. The views and conclusions
contained herein are those of the authors and should not be
interpreted as necessarily representing the ocial policies
or endorsements, either expressed or implied, of DARPA or
the U.S. Government. The term \Segmented Oracle" was
dened by DARPA in a white paper distributed to us.
20210. REFERENCES
[1] Omega. http://www.cs.umd.edu/projects/omega/.
[2] Xbox 360 timing attack. http://beta.ivc.no/wiki/
index.php/Xbox 360Timing Attack, 2007.
[3] A few important facts regarding oauth security.
http://oauthlib.readthedocs.io/en/latest/oauth1/
security.html, 2012.
[4] Oauth protocol hmac byte value calculation timing
disclosure weakness.
https://osvdb.info/OSVDB-97562, 2013.
[5] P. A. Abdulla, M. F. Atig, Y. Chen, L. Hol k,
A. Rezine, P. R ummer, and J. Stenman. String
constraints for verication. In Proceedings of the 26th
International Conference on Computer Aided
Verication (CAV) , pages 150{166, 2014.
[6] A. Aydin, L. Bang, and T. Bultan. Automata-based
model counting for string constraints. In Proceedings
of the 27th International Conference on Computer
Aided Verication (CAV) , pages 255{272, 2015.
[7] M. Backes, B. Kopf, and A. Rybalchenko. Automatic
Discovery and Quantication of Information Leaks. In
Proceedings of the 2009 30th IEEE Symposium on
Security and Privacy , SP '09, pages 141{153,
Washington, DC, USA, 2009. IEEE Computer Society.
[8] C. Bartzis and T. Bultan. Ecient symbolic
representations for arithmetic constraints in
verication. Int. J. Found. Comput. Sci. ,
14(4):605{624, 2003.
[9] D. Brumley and D. Boneh. Remote Timing Attacks
Are Practical. In Proceedings of the 12th Conference
on USENIX Security Symposium - Volume 12 ,
SSYM'03, pages 1{1, Berkeley, CA, USA, 2003.
USENIX Association.
[10] S. Chen, R. Wang, X. Wang, and K. Zhang.
Side-channel leaks in web applications: A reality
today, a challenge tomorrow. In Proceedings of the
2010 IEEE Symposium on Security and Privacy , SP
'10, pages 191{206, Washington, DC, USA, 2010.
IEEE Computer Society.
[11] T. Chothia, Y. Kawamoto, and C. Novakovic.
Leakwatch: Estimating information leakage from java
programs. In M. Kutylowski and J. Vaidya, editors,
Computer Security - ESORICS 2014 - 19th European
Symposium on Research in Computer Security,
Wroclaw, Poland, September 7-11, 2014. Proceedings,
Part II , volume 8713 of Lecture Notes in Computer
Science , pages 219{236. Springer, 2014.
[12] D. Clark, S. Hunt, and P. Malacaria. A static analysis
for quantifying information ow in a simple imperative
language. J. Comput. Secur. , 15(3):321{371, Aug.
2007.
[13] J. S. Daniel Mayer. Time trial: Racing towards
practical remote timing attacks.
https://www.nccgroup.trust/globalassets/
our-research/us/whitepapers/TimeTrial.pdf, 2014.
[14] G. Doychev, B. K opf, L. Mauborgne, and J. Reineke.
Cacheaudit: A tool for the static analysis of cache side
channels. ACM Trans. Inf. Syst. Secur. , 18(1):4, 2015.
[15] A. Filieri, C. S. Pasareanu, and W. Visser. Reliability
analysis in symbolic pathnder. In Proceedings of the
35th International Conference on Software
Engineering (ICSE) , pages 622{631, 2013.[16] A. Filieri, C. S. P as areanu, and W. Visser. Reliability
analysis in symbolic pathnder. In Proceedings of the
2013 International Conference on Software
Engineering , ICSE '13, pages 622{631, Piscataway,
NJ, USA, 2013. IEEE Press.
[17] V. Ganesh, M. Minnes, A. Solar-Lezama, and M. C.
Rinard. Word equations with length constraints:
What's decidable? In Proceedings of the 8th
International Haifa Verication Conference (HVC) ,
pages 209{226, 2012.
[18] C. Hale. A lesson in timing attacks (or, don^ a AZt use
messagedigest.isequals).
https://codahale.com/a-lesson-in-timing-attacks/,
2009.
[19] J. Heusser and P. Malacaria. Quantifying information
leaks in software. In Proceedings of the 26th Annual
Computer Security Applications Conference , ACSAC
'10, pages 261{269, New York, NY, USA, 2010. ACM.
[20] P. Hooimeijer and W. Weimer. A decision procedure
for subset constraints over regular languages. In
Proceedings of the ACM SIGPLAN Conference on
Programming Language Design and Implementation
(PLDI) , pages 188{198, 2009.
[21] P. Hooimeijer and W. Weimer. Solving string
constraints lazily. In Proceedings of the 25th
IEEE/ACM International Conference on Automated
Software Engineering (ASE) , pages 377{386, 2010.
[22] M. Joye. Basics of side-channel analysis. In
Cryptographic Engineering , chapter 13, pages 367{382.
2009.
[23] S. Kausler and E. Sherman. Evaluation of string
constraint solvers in the context of symbolic
execution. In Proceedings of the 29th ACM/IEEE
International Conference on Automated software
engineering (ASE) , pages 259{270, 2014.
[24] J. Kelsey. Compression and information leakage of
plaintext. In Fast Software Encryption, 9th
International Workshop, FSE 2002, Leuven, Belgium,
February 4-6, 2002, Revised Papers , pages 263{276,
2002.
[25] A. Kiezun, V. Ganesh, P. J. Guo, P. Hooimeijer, and
M. D. Ernst. Hampi: a solver for string constraints. In
Proceedings of the 18th International Symposium on
Software Testing and Analysis (ISSTA) , pages
105{116, 2009.
[26] J. C. King. Symbolic execution and program testing.
Commun. ACM , 19(7):385{394, July 1976.
[27] V. Klebanov, N. Manthey, and C. Muise. SAT-Based
Analysis and Quantication of Information Flow in
Programs. In Quantitative Evaluation of Systems ,
volume 8054 of Lecture Notes in Computer Science ,
pages 177{192. Springer Berlin Heidelberg, 2013.
[28] P. C. Kocher. Timing Attacks on Implementations of
Die-Hellman, RSA, DSS, and Other Systems. In
Proceedings of the 16th Annual International
Cryptology Conference on Advances in Cryptology ,
CRYPTO '96, pages 104{113, London, UK, UK, 1996.
Springer-Verlag.
[29] B. K opf and D. A. Basin. An information-theoretic
model for adaptive side-channel attacks. In P. Ning,
S. D. C. di Vimercati, and P. F. Syverson, editors,
Proceedings of the 2007 ACM Conference on
203Computer and Communications Security, CCS 2007,
Alexandria, Virginia, USA, October 28-31, 2007 ,
pages 286{296. ACM, 2007.
[30] N. Lawson. Side-channel attacks on cryptographic
software. IEEE Security and Privacy , 7(6):65{68, Nov.
2009.
[31] N. Lawson. Timing attack in google keyczar library.
https://rdist.root.org/2009/05/28/
timing-attack-in-google-keyczar-library/, 2009.
[32] N. Lawson. Optimized memcmp leaks useful timing
dierences. https://rdist.root.org/2010/08/05/
optimized-memcmp-leaks-useful-timing-dierences/,
2010.
[33] G. Li and I. Ghosh. PASS: string solving with
parameterized array and interval automaton. In
Proceedings of the 9th International Haifa Verication
Conference (HVC) , pages 15{31, 2013.
[34] T. Liang, A. Reynolds, C. Tinelli, C. Barrett, and
M. Deters. A DPLL(T) theory solver for a theory of
strings and regular expressions. In Proceedings of the
26th International Conference on Computer Aided
Verication (CAV) , pages 646{662, 2014.
[35] J. A. D. Loera, R. Hemmecke, J. Tauzer, and
R. Yoshida. Eective lattice point counting in rational
convex polytopes. Journal of Symbolic Computation ,
38(4):1273 { 1302, 2004. Symbolic Computation in
Algebra and Geometry.
[36] L. Luu, S. Shinde, P. Saxena, and B. Demsky. A
model counter for constraints over unbounded strings.
InProceedings of the ACM SIGPLAN Conference on
Programming Language Design and Implementation
(PLDI) , page 57, 2014.
[37] P. Mardziel, M. S. Alvim, M. W. Hicks, and M. R.
Clarkson. Quantifying information ow for dynamic
secrets. In 2014 IEEE Symposium on Security and
Privacy, SP 2014, Berkeley, CA, USA, May 18-21,
2014, pages 540{555, 2014.
[38] S. McCamant and M. D. Ernst. Quantitative
information ow as network ow capacity. In
Proceedings of the 2008 ACM SIGPLAN conference
on Programming language design and implementation ,
PLDI '08, pages 193{205, New York, NY, USA, 2008.
ACM.
[39] Microsoft Inc. Z3 SMT Solver.
http://z3.codeplex.com.
[40] T. Nelson. Widespread timing vulnerabilities in openid
implementations. http://lists.openid.net/pipermail/
openid-security/2010-July/001156.html, 2010.
[41] Q.-S. Phan and P. Malacaria. Abstract Model
Counting: A Novel Approach for Quantication of
Information Leaks. In Proceedings of the 9th ACM
Symposium on Information, Computer and
Communications Security , ASIA CCS '14, pages
283{292, New York, NY, USA, 2014. ACM.
[42] Q.-S. Phan, P. Malacaria, C. S. P as areanu, and
M. d'Amorim. Quantifying Information Leaks UsingReliability Analysis. In Proceedings of the 2014
International SPIN Symposium on Model Checking of
Software , SPIN 2014, pages 105{108, New York, NY,
USA, 2014. ACM.
[43] Q.-S. Phan, P. Malacaria, O. Tkachuk, and C. S.
P as areanu. Symbolic Quantitative Information Flow.
SIGSOFT Softw. Eng. Notes , 37(6):1{5, Nov. 2012.
[44] C. S. P as areanu, Q.-S. Phan, and P. Malacaria.
Multi-run side-channel analysis using Symbolic
Execution and Max-SMT. In Proceedings of the 2016
IEEE 29th Computer Security Foundations
Symposium , CSF '16, Washington, DC, USA, 2016.
IEEE Computer Society.
[45] C. S. P as areanu, W. Visser, D. Bushnell,
J. Geldenhuys, P. Mehlitz, and N. Rungta. Symbolic
PathFinder: integrating symbolic execution with
model checking for Java bytecode analysis. Automated
Software Engineering , pages 1{35, 2013.
[46] J. Rizzo and T. Duong. The crime attack. Ekoparty
Security Conference, 2012.
[47] P. Saxena, D. Akhawe, S. Hanna, F. Mao,
S. McCamant, and D. Song. A symbolic execution
framework for javascript. In Proceedings of the 31st
IEEE Symposium on Security and Privacy , 2010.
[48] M. Trinh, D. Chu, and J. Jaar. S3: A symbolic string
solver for vulnerability detection in web applications.
InProceedings of the ACM SIGSAC Conference on
Computer and Communications Security (CCS) , pages
1232{1243, 2014.
[49] F. Weimer. Defeating memory comparison timing
oracles. https:
//access.redhat.com/blogs/766093/posts/878863/,
2014.
[50] F. Yu, M. Alkhalaf, and T. Bultan. Stranger: An
automata-based string analysis tool for php. In
Proceedings of the 16th International Conference on
Tools and Algorithms for the Construction and
Analysis of Systems (TACAS) , pages 154{157, 2010.
[51] F. Yu, M. Alkhalaf, T. Bultan, and O. H. Ibarra.
Automata-based symbolic string analysis for
vulnerability detection. Formal Methods in System
Design , 44(1):44{70, 2014.
[52] F. Yu, T. Bultan, M. Cova, and O. H. Ibarra.
Symbolic string verication: An automata-based
approach. In Proceedings of the 15th International
SPIN Workshop on Model Checking Software (SPIN) ,
pages 306{324, 2008.
[53] Y. Zheng, X. Zhang, and V. Ganesh. Z3-str: A
z3-based string solver for web application analysis. In
Proceedings of the 9th Joint Meeting on Foundations
of Software Engineering (ESEC/FSE) , pages 114{124,
2013.
[54] J. Ziv and A. Lempel. A universal algorithm for
sequential data compression. IEEE Transactions on
Information Theory , 23(3):337{343, May 1977.
204