Move-Optimized Source Code Tree Differencing
Georg Dotzler, Michael Philippsen
Friedrich-Alexander University Erlangen-NÃ¼rnberg (FAU), Germany
Programming Systems Group
{georg.dotzler, michael.philippsen}@fau.de
ABSTRACT
When it is necessary to express changes between two source
code les as a list of edit actions (an edit script), modern
tree dierencing algorithms are superior to most text-based
approaches because they take code movements into account
and express source code changes more accurately.
We present 5 general optimizations that can be added to
state-of-the-art tree dierencing algorithms to shorten the
resulting edit scripts. Applied to Gumtree, RTED, JSync,
and ChangeDistiller, they lead to shorter scripts for 18{
98% of the changes in the histories of 9 open-source soft-
ware repositories. These optimizations also are parts of our
novel Move-optimized Tree DIFFerencing algorithm (MTD-
IFF) that has a higher accuracy in detecting moved code
parts. MTDIFF (which is based on the ideas of ChangeDis-
tiller) further shortens the edit script for another 20% of the
changes in the repositories.
MTDIFF and all the benchmarks are available under an
open-source license.
CCS Concepts
Software and its engineering !Software mainte-
nance tools;Mathematics of computing !Trees;
Keywords
Tree Dierencing; Optimizations; Source Code
1. INTRODUCTION
In many disciplines, it is common to express the changes
between two character sequences as a list of edit actions, a
so-called edit script. It often matters to nd the shortest
possible edit script, for instance between RNA structures in
biology [4, 27]. When software developers examine changes
in source code, it is also likely that the shortest edit script
is the most benecial to grasp the nature of a change. Ac-
cording to Falleri et al. [18], the length of the edit script is
a proxy to the cognitive load for a developer to understandthe essence of a commit (and thus le changes). It is also
likely that code change recommendation tools [28, 29] can
produce better results if they have access to the shortest edit
scripts. Unfortunately, nding them is NP-hard [38] if the
movement of subsequences (e.g. substrings or subtrees) is a
permitted edit action.
To determine source code dierences quickly, diand its
variants solve a simplied problem. First, they do not con-
sider moved code. The only permitted edit actions are in-
sertions and deletions of code lines. Second, they use Myers
algorithm [31] to detect changes on the granularity of full
text lines. Thus, even if a change only aects a part of a
line (e.g., renames a variable), the full line is deleted and a
new line is inserted. Both simplications make the output of
diunnecessarily verbose due to a sub-optimal edit script.
Tree dierencing approaches avoid the above granularity
problem as a code line usually consists of a number of nodes
in the abstract syntax tree (AST). The resulting edit scripts
no longer mention unmodied parts of code lines. But since
the general problem of nding the shortest edit script on
ASTs with moves remains NP-hard [9, 10], state-of-the-
art tree dierencing algorithms also need to simplify the
problem. RTED [33], for example, does not consider moved
subtrees. Other state-of-the-art tree dierencing algorithms
that consider move-actions cannot be fast andnd an opti-
mal ne-grained edit script. They use dierent heuristics to
match the requirements of their specic use cases.
ChangeDistiller (CD) [19] uses coarse-grained AST nodes
that represent larger structures of the code, e.g., full loop
conditions or full statements. The dierences on the result-
ing (much smaller) trees are sucient for CD's purpose to
categorize and identify types of changes. CD's edit scripts
are short, but the arguments of the individual edit actions
are long, sometimes as long as in di. JSync [32] is used in
a clone detector framework. Thus, the algorithm is aimed
at changes in methods and not at changes in complete les.
Hence JSync leaves out irrelevant aspects from the ASTs,
such as imports, elds, etc., and does not work on full les.
Gumtree (GT) [18] works on ne-grained ASTs and full code
les. For an upper bound on the runtime complexity (O( n2)
fornAST nodes) GT nds a short edit script.
The goal of this paper is to achieve shorter ne-grained
edit scripts that use move actions more frequently, even if
the computation takes slightly longer than for GT or di.
We analyzed the four tree-dierencing algorithms from
above to better understand why their edit scripts are longer
than necessary. From this analysis, we developed 5 gen-
eral optimizations. When they are added as pre- or post-
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proï¬t or commercial advantage and that copies bear this notice and the full citation
on the ï¬rst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciï¬c permission and/or a
fee. Request permissions from Permissions@acm.org.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ASEâ€™16 , September 3â€“7, 2016, Singapore, Singapore
ACM. 978-1-4503-3845-5/16/09...$15.00
http://dx.doi.org/10.1145/2970276.2970315
660
Original code: Modied code:
01: foo( xy + 2);
02: int a = 0;
03: int b = 1;
04: log();
05: if(cond )
06: m1(d, c);
07: log();
08: print( "42!" + "hello");
09: m2( 1 + 2, 3 *4);foo( xyz + 2, t);
int b = 1;
int a = 0;
log();
if(cond !=null )
m1( 5,c, d);
log();
print( "hello" +"42!" );
m2( 3.1 *4,1.1 +2);
(a) GT takes 18 edit actions ^ =18 boxes.
01: foo( xy + 2);
02: int a = 0;
03: int b = 1;
04: log();
05: if( cond)
06: m1( d, c);
07: log();
08: print( "42!" + "hello");
09: m2( 1 + 2, 3 *4);foo( xyz + 2, t);
int b = 1;
int a = 0;
log();
if(cond !=null )
m1( 5, c, d);
log();
print("hello" + "42!" );
m2( 3.1 *4,1.1 +2);
(b) GT with our optimizations takes 15 edit actions.
01: foo( xy + 2);
02: int a = 0;
03: int b = 1;
04: log();
05: if( cond)
06: m1( d, c);
07: log();
08: print( "42!" + "hello");
09: m2( 1 + 2, 3 *4);foo( xyz + 2, t);
int b = 1;
int a = 0;
log();
if(cond !=null )
m1( 5, c, d);
log();
print("hello" + "42!" );
m2( 3.1 *4,1.1 + 2);
(c) MTDIFF only needs 12 edit actions.
Figure 1: Code change (left !right). The boxes
show the edit actions that the tree dierencing al-
gorithms detect: Yellow for updates, green for inser-
tions, redfor deletions, blue for node movements.
processing phases to GT, RTED, CD, and JSync, the op-
timizations shorten their edit scripts. Note that this may
not be necessary for the applications for which these tree
dierencing algorithms were initially developed.
Fig. 1 holds an articial code change to illustrate the op-
timizations (original code on the left, modied code on the
right). The code is identical in all three sub-gures. The
boxes indicate the edit actions. Fig. 1(a) shows that GT
produces an edit script of size 18. When the 5 general opti-
mizations are added to GT, they shorten the edit script to
the 15 actions shown in Fig. 1(b). The optimizations have
similar eects on the other tree dierencing algorithms, but
due to their dierent ASTs, the boxes would be dierent.
Additionally, this work presents a novel Move-optimized
Tree DIFFerencing algorithm (MTDIFF) that achieves even
shorter edit scripts due to its higher accuracy in detecting
moved code parts. It is based on CD and uses the 5 gen-
eral optimizations. Applied to the same example, MTDIFF
requires only 12 edit actions, see Fig. 1(c).
Sec. 2 briey introduces tree dierencing. Sec. 3 describes
the 5 general optimizations and Sec. 4 presents MTDIFF.
These two sections also address the details of the optimiza-
tions that lead to the results in Fig. 1 while Sec. 5 discusses
time complexities. Sec. 6 holds both a quantitative evalu-
ation on 126,162 changed les and a study to demonstrate
that shorter edit scripts are more helpful to developers than
longer ones. Sec. 7 discusses related work.
2. TREE DIFFERENCING
Compilers use ASTs to internally represent source les as
rooted, labeled, ordered trees. Fig. 2 shows two examples.Each node has a label lbl, such as Calloand SimpleName
(for xyo). Some nodes also have a value attribute v. Fig. 2
uses their values ( 2oorxyo) instead of their labels.
Anedit script is a list of edit actions that transforms the
original ASTointo the modied ASTm. Each edit action
has a cost siand the cost of an edit script is the sum of all
si. An edit script is optimal if its cost is minimal. For the
remainder of this work, all edit actions have the same cost
(e.g. 1). Thus, there is no preference of an edit action. The
optimal edit script then is the shortest one.
Most tree dierencing algorithms approach the search for
the shortest edit script in two phases. Phase 1 uses heuristics
to generate a mapping between the nodes of the ASTs. The
algorithms vary with respect to both the granularity of the
AST they use and the heuristics they employ to derive the
mapping. A mapping is a list of matching pairs of nodes
(no,nm), where node nofrom ASTois mapped to node nm
inASTm. Each mapped node is part of only one pair. It is a
common restriction that only nodes with the same label can
match, although this misses a few corner cases (e.g., while
$forwith similar conditions). Our optimizations and also
MTDIFF share this restriction. Based on the mapping from
phase 1, phase 2 computes the edit script in O(n2) [12, 20].
As the algorithms for phase 2 are optimal [12], a shorter edit
script can only result from a dierent mapping from phase
1. Thus, our work focuses on the heuristics in phase 1.
For our evaluation, we use the implementation of GT for
phase 2 as it uses an optimal algorithm. This implemen-
tation uses 4 edit actions, namely updateValue ,add,delete ,
andmove . For a pair (no,nm)with dierent values, GT adds
anupdateValue( no, vm)action to the script. If a node no
is not in the mapping, GT adds delete( no). If a node nmis
not in the mapping, GT adds add(nm, parent( nm), i)where
ispecies the ithchild of the parent of nm. If there is a pair
(no,nm)in the mapping where ( parent( no),parent( nm))
is not mapped, GT adds a move( no, parent( nm), i) where
nmis the node mapped to noandispecies the ithchild
of the parent of nm. If both (no,nm)and (parent( no),
parent( nm))are mapped, GT also adds a move action if no
andnmhave dierent child-indices in their parents. Note
that rather than moving a single node n,move aects the
complete subtree rooted in n.
3. GENERAL OPTIMIZATIONS
The following optimizations  A Eare applicable to all
examined tree dierencing algorithms. For the discussion
of A Ewe use the code and ASTs from Figs. 1 and 2.
For brevity, Fig. 1 only shows the situation for GT and we
only demonstrate  B Eon GT. Our evaluation shows that
A Eshorten the edit scripts for the other tree dierencing
algorithms as well.
3.1 Identical Subtree Optimization A
Identifying unchanged code is crucial to avoid large edit
scripts because any pairing of nodes from unchanged parts
with nodes from changed parts causes avoidable edit actions.
As example we apply CD to the AST in Fig. 2 (although it is
more detailed than the CD-AST [19]). Since in this change
the two assignments (=) switch places, a single move action
for =ois sucient. CD does not recognize that the subtrees
of =oand =oare left unchanged, albeit in a dierent
order. Thus, CD creates four edit actions that modify each
of the constants (0,1) and identiers (a,b) . The main cause
661Blocko
=o
1o
 Declo
bo
 into
=o
0o
 Declo
ao
 into
Callo
Argso
+o
2o
 xyo
fooo
(a)ASToof the original code.
Blockm
=m
0m
 Declm
am
 intm
=m
1m
 Declm
bm
 intm
Callm
Argsm
tm
 +m
2m
 xyzm
foom
(b)ASTmof the modied code.
Figure 2: ASTs of the rst 3 code lines in Fig. 1. Same legend as in Fig. 1.
is that CD pairs nodes from within the subtree = oto nodes
from the two dierent subtrees of = mand =m.
Hence, the Identical Subtree Optimization Aadds pairs
of matching nodes from identical subtrees to the mapping
before phase 1 of the tree dierencing algorithm even starts.
This reduces the number of pairs in the mapping that hold
nodes from both unchanged and changed code.  Ais a
built-in part of GT. Di/TS [20, 21] uses a variant of it.
For each subtree,  Agenerates a ngerprint. Identical
subtrees (i.e. identical code parts) have the same ngerprint
(i.e. the same string representation). Then  Atraverses
ASTotop down. If a node's ngerprint also appears in the
modied ASTm, Aadds all pairs of nodes from the two
subtrees to the mapping, provided that the ngerprints are
unique in their respective ASTs. Since in most cases leaves
arenotunique (e.g., into), Aignores them for speed. As
in Fig. 2, the ngerprints of the subtrees of = oand =m
match and are unique in ASToand ASTm, Aadds the
pairs (=o,=m),(Declo,Declm),(into,intm), etc.
to the mapping. Note that  Anot only improves the tree
dierencing results, it also reduces the runtime of all sub-
sequent steps, including the tree dierencing algorithm, as
their complexities depend on the number of nodes that are
not in the mapping.
3.2 LCS Optimization B
GT uses RTED to match smaller subtrees and inherits
the inability to detect the move of cond in Fig. 1 (line 5). It
creates two instead of one edit action ( delete and insert ).
The idea of the Longest Common Subsequence (LCS) post-
processing  Bis to atten two subtrees that have their roots
in the mapping. If there are unmapped nodes that have the
01:function LCSOpt (rooto, rootm, M)
02: Uo unmappedNodesTopDown(root o, M);
03: Um unmappedNodesTopDown(root m, M)
04: done ;
05: foruo2Uodo
06: po parent(uo)
07: ifpo2done then
08: continue
09: done done[fpog
10: pm mappedNode(u o, M)
11: ifpm6= null then
12: lo nodesInPostOrder(p o)
13: lm nodesInPostOrder(p m)
14: result LCS(lo, lm, Uo, Um, M)
15: for(mo, mm)2result do
16: ifmo2Uo^mm2Umthen
17: M M[f(mo, mm)g
18: Uo Uonfmog; Uo Umnfmmg
19: return M
Figure 3: LCS Optimization, B.same labels within their two attened sequences,  Badds
them as a pair to the mapping.
Bin Fig. 3 initially traverses both ASTs top-down and
collects nodes that are not yet mapped (lines 2-3). As input
it uses the root nodes of both ASTs and the current map-
pingM. In the example, condo,nullm, ! =m, and condmare
not in the mapping. Afterwards  Bselects the rst such
node ( condo) and tests whether its parent ( ifo) has a part-
ner in the mapping. As ifois mapped to ifm, Battens
both subtrees and computes the LCS [8] in lines 12-14. A
pair (mo, mm)is part of the LCS ( result ) if the two labels
are identical and either the pair was previously mapped or
both were unmapped (line 16).  Badds the pair (condo,
condm)to the mapping. This leads to the move action and
the shorter edit script.  Bdoes not add other pairs since
the remaining nodes only appear in one sequence. To avoid
duplicate work,  Bchecks each parent only once (lines 6-9).
3.3 Unmapped Leaves Optimization C
Caddresses the problem of unmapped leaves that are
missing in the mapping. For instance, GT does not recognize
the movement of cin Fig. 1 (line 6). This again is caused
by the use of RTED to map small subtrees.  Bdoes not
heal this as either cordcan be part of the LCS.
To x this, the pseudo-code of  Cin Fig. 4 works on all
unmapped leaves that have a parent that is mapped to a
partner. In the example, cois not part of the mapping, but
the argument list of method m1ois. Then partnerChild (line
7) nds a node xthat is a suitable partner of co. Our imple-
mentation uses a cascade of 8 conditions to select the most
suitable node. Condition 1: Select a node xthat is among
the children of mappedPm, has both the same label and the
same value asuo, and is not in the mapping. Condition 2:
Select a node xthat is among the children of mappedPm,
has both the same label and the same position asuo, and is
not in the mapping. For brevity, we skip the less common
remaining 6 conditions that can be found in the source code.
01:function UnmappedLeavesOpt (rooto, rootm, M)
02: Uo unmappedLeaves(root o, M);
03: foruo2Uodo
04: po parent(uo)
05: mappedPm mappedNode(p o, M)
06: ifmappedPm6= null then
07: xm partnerChild(u o, mappedP m)
08: ifxm6= null then
09: M M[f(uo, xm)g
10: return M
Figure 4: Unmapped Leaves Optimization, C.
662Ascmis the most suitable node (same label, same value,
not in the mapping) in the example,  Cadds (co,cm)to the
mapping (line 9). This shortens the edit script because it
replaces delete (co) and insert (cm) with one move .
Cis invoked twice, once for the unmapped leaves in
ASToand once for those in ASTm, because an unmapped
leaf in ASTmmay have a parent in the mapping (lines 4-6),
whereas its counterpart in ASTohas not.
3.4 Inner Node Optimization D
The post-processing Inner Node Optimization Dis only
eective when  Bor Chave changed the mapping. Then
it can further improve the results with the new information.
The conditions that trigger  Donly occur in larger code
fragments. Fig. 5 shows an abstract example and its sub-
optimal mapping in which only one child of Ois mapped to
a child of M. For two children ( o2ando3) ofOthere is a
mapping to nodes in ASTmthat are children of a dierent
parent N6=M. Thus, the edit script has two move actions.
The key idea of  Dis to change the partner of the parent
node Ofrom MtoN, so that afterwards fewer children have
tomove . In the example, after  D, the edit script has only
onemove for(o1,m1).
Fig. 6 holds the pseudo-code of  D. For an inner node
ioinASTo(Oin Fig. 5),  Dsearches for an inner node in
ASTmthat shares more mapped children with iothan the
current partner in the mapping ( M). If found,  Dcounts
the number of its shared children (line 7). If at least half of
them have a mapped partner in the subtree of the matching
candidate ( N), Dremoves the old pair (O,M)and adds
the new pair (O,N)instead (line 10). Again, only pairs with
the same label are considered (line 9).
3.5 Leaf Move Optimization E
Whereas  Ctargets unmapped leaves only,  Ealso ex-
amines pairs that are already in the mapping. GT generates
twoupdate actions to modify the string constants of print in
Fig. 1 (line 8).  Edetects that a single move is sucient.
The pseudo-code in Fig. 7 rst identies pairs of leaves in
the mapping where both leaves have dierent values (line 2).
These are candidates for the optimization. Then, for each
such pair, e.g., (42!o,hellom), Elooks for a leaf that is
a better partner because it has the same value (lines 5-24).
To avoid unnecessary moves , only leaves from the partner of
the parent node (e.g., the string concatenation in Fig. 1) are
considered (lines 7-9). Using another parent always requires
amove action and cannot shorten the edit script. If  E
nds such a node ( pm), it modies the current mapping, but
only if there is just a single other possible match ( unique ).
Otherwise,  Edoes not touch the mapping as there is no
O
o3
 o2
 o1
M
m1...
N
n2
 n1...
(a)ASToof original code. (b) Modied ASTm.
Figure 5: ASTs with sub-optimal mapping. O,M,
: : :,niare simplications, e.g., of argument lists.01:function OptimizeInnerNodes (rooto, rootm, M)
02: Io mappedInnerNodesInPostOrder(root o, M);
03: forio2Iodo
04: im mappedNode(i o, M)
05: maxm nodeWithMostMappedChildren(i o, M)
06: ifmaxm6= imthen
07: commonChildren  commonChildren( io, maxm, M)
08: ifjcommonChildrenj>oor(jchildren(io)j=2)then
09: iflbl(io) = lbl(max m)then
10: M M[f(io, maxm)g; M Mnf(io, im)g
11: return M
Figure 6: Inner Node Optimization, D.
fast way to decide which match prevents the edit script from
growing. There is one exception.  Eupdates the mapping if
there are several leaves with identical values and the position
of the possible match inside its parent's subtree is the same
as the position of the leaf in the original subtree (1 for 42! o).
As there is a better matching leaf in the example,  Ere-
moves the old pair (42!o,hellom)in line 13 and adds the new
pair (42!o,42!m)in line 14. Afterwards, hellomlacks a part-
ner in the mapping. As the previous partner of 42 m(helloo)
has the same label,  Eadds ( helloo,hellom) to the mapping
(lines 16-19). For Fig. 1,  Eis done at this point. It has re-
placed the two updates with a single move . If in other cases
a pair with dierent values (instead of ( helloo,hellom)) is
added to the mapping, the pair is added to the work list for
further optimization (lines 20-21, 25).  Eachieves termi-
nation with a second work list (line 21).
There may be no tting node for the leaf of the original
tree. If for the pair (42!o,hellom)there is no identier
42!m, then there still can be a better partner for hellom.
The second loop (lines 23-24) nds the partner in a way
that is similar to the loop in lines 9-22. After a rst run,
Eruns again with parent(lm)instead of mappedNode(p o,
M)in line 7. This optimizes leaves for parents that are not
in the mapping.
3.6 Order of A E
Due to their design, the order ( A; phase 1;  B; C; D;
E) results in the shortest edit scripts in our evaluation.
Ais a pre-processing step that does not require an initial
mapping while the post-processing steps  B Edo. Other
01:function LeafMoveOpt (rooto, rootm, M)
02: work mappedLeavesWithValueDierences(M)
03: work' new List()
04: while work6=;doouter:
05: for(lo, lm)2work do
06: po parent(lo)
07: mpm mappedNode(p o, M) // parent(l m) in run 2
08: pos childPosition( io, po)
09: forc2children(mp m)do
10: ifisIdenticalLeaf(c, l o)then
11: posc childPosition(c, mp m)
12: ifunique(lo,children(mp m))_pos=poscthen
13: M Mnf(lo, lm)g
14: M M[f(lo, c)g;
15: c' mappedNode(c, M)
16: ifc'6= null then
17: M Mnf(c', c)g
18: M M[f(c', lm)g;
19: work remove(work, (c', c))
20: ifvalue(c')6= value(lm)then
21: work' add(work',(c', l m))
22: break
23: forc2children(p o)do
24: ...
25: work work'; work' ;
26: return M
Figure 7: Leaf Move Optimization, E.
663orders or subsets of  B Eare valid but in general result in
longer edit scripts.  Donly makes sense after  Bor C.
Eis useful on its own.
4. MOVE-OPTIMIZED TREE DIFF
In contrast to the other considered tree dierencing algo-
rithms (only  Ais already part of GT), MTDIFF includes
(and also requires) all the general optimizations  A E. The
other major dierence is in phase 1, i.e., in the way MTDIFF
computes the mapping of nodes between ASTs.
Due to their design, GT and JSync struggle with move-
ments of subtrees that are also altered while they are moved,
e.g., the (moved and altered) +-subtree in line 9 of Fig. 1.
As CD can detect such movements in its coarse-grained CD-
AST, we use it as foundation of MTDIFF.
Both CD and MTDIFF take a two-step approach to create
the mapping in phase 1. In their rst step, both algorithms
create pairs of leaf nodes for the mapping. Based on the
leaves in the mapping, their second step creates pairs of
inner nodes. The workings of these steps are dierent in CD
and MTDIFF. The latter has to address two challenges that
are not an issue for CD (due to its original purpose).
Challenge A: Since the values of nodes in the CD-AST
contain larger pieces of the code, there are fewer nodes with
identical labels and values than in a ne-grained AST. For
example, there are two identical intnodes in Fig. 2, whereas
the CD-AST represents the two non-identical statements in
lines 2 and 3 as only two nodes with non-identical values.
Thus, MTDIFF has to nd a mapping that takes care of
identical leaves (not relevant for CD) and that also yields a
short edit script. Sec. 4.1 presents how MTDIFF nds pairs
of (identical) leaves for the mapping.
Challenge B: Similarly, the coarse-grained CD-AST en-
codes loop conditions (and other pieces of the code) as val-
ues. Fine-grained ASTs express them as separate subtrees.
Thus, MTDIFF requires new heuristics to measure the sim-
ilarity of inner nodes when it computes a mapping for them.
Additionally, MTDIFF has to examine more inner nodes to
nd suitable partners. Sec. 4.2 addresses the details.
Although MTDIFF can reuse the similarity function for
leaves from CD, its heuristics require their own set of simi-
larity thresholds. Sec. 4.3 explains our approach to identify
suitable values.
4.1 Leaf Mapping
The rst step of phase 1 creates pairs of leaf nodes and
adds them to the mapping. The pseudo-code for this step
is in Fig. 8. LeafMapping is called on the original ASTo
and the modied ASTm. Initially it extracts lists L o, Lm
of all leaves that are not already part of the M apping M
due to  A(lines 2-3). Then the loops (lines 5-9) compute
the pairwise similarities of the unmapped leaves. MTDIFF
shares with CD the similarity function simLfor the leaves:
simL(lo; lm) =
0 lbl(lo)6=lbl(lm)
sim2g(v(lo); v(lm)) otherwise.
AST-nodes with dierent labels lblnever match. Otherwise,
MTDIFF uses bigrams [24] ( sim2g) to compute the string
similarity of the values ( v) [19] in the interval [0 ;1].
Then LeafMapping sorts the list of node P airs by decreas-
ing similarities. Nodes with the same similarities are sorted
according to the post-order visiting sequence, rst of AST o
and then of AST m(line 10). To keep this example simple,01:function LeafMapping (rooto, rootm, M, resolveAmbiguity)
02: Lo unmappedLeaves(root o, M)
03: Lm unmappedLeaves(root m, M)
04: U Lo[Lm; P ;
05: forlo2Lodo
06: forlm2Lmdo
07: similarity simL(lo, lm)
08: ifsimilaritythresholdLthen
09: P P[f(lo, lm, similarity)g
10: P orderBySimilarityAndVisitOrder(P);
11: C P; A ;
12: ifresolveAmbiguity then
13: C unambiguousPairs(P)
14: A ambiguousPairs(P)
15: for(lo, lm, s)2Cdo
16: iflo2U^lm2Uthen
17: M M[f(lo, lm)g
18: U Unflog; U Unflmg
19: A handleAmbiguities(A, M)
20: for(lo, lm, s)2Ado
21: iflo2U^lm2Uthen
22: M M[f(lo, lm)g
23: U Unflog; U Unflmg
24: return M
Figure 8: Creates a mapping from two trees (root o,
rootm).
we ignore the results of the  Apre-processing. Pthen con-
tains the following ordered list of leaf pairs, with a similarity
above zero: ( fooo,foom, 1), (2o, 2m, 1), ( into,intm, 1),
(into,intm, 1), ( ao,am, 1), (0o, 0m, 1), ( into,intm, 1),
(into,intm, 1), ( bo,bm, 1), (1o, 1m, 1), ( xyo,xyzm, 0.66).
Only for the 7 pairs without intnodes there is no ambiguity.
Whereas CD does not need to handle A mbiguous nodes
(resolveAmbiguity = false), MTDIFF separates them (in list
A) from unambiguous ones with a C lear match (list C) in
lines 12-14. Ambiguous nodes are nodes for which there is
no single best match in P. All intnodes in Fig. 2 fall into
this category. Then, MTDIFF examines all entries in Cand
adds them to the mapping if both nodes are part of U(set
of Unmapped nodes). Thus, the for-loop in lines 15-18 adds
all the 7 unambiguous node pairs in the above order.
Without an ambiguity treatment of the intnodes in Fig. 2
(and without  A), the second step (mapping of inner nodes)
would add the barely similar pairs ( Declo,Declm, 0.5)
and ( Declo,Declm, 0.5) to the mapping. This would
lead to an overly verbose edit script that moves the variable
names ( aoandbo) and declarations ( DecloandDeclo).
To prevent this, handleAmbiguities resolves such ambigu-
ities before MTDIFF adds inner nodes to the mapping. It
reconsiders the pairs based on the similarity values of all
pairs in Aand takes the previously determined pairs in M
into account. Based on A,handleAmbiguities builds a ma-
trix for each group of ambiguous leaves, see Fig. 9(a) for 2 2
ways to pair the intnodes. The key idea is that the parents
of the leaves often can help to resolve the ambiguity because
their similarities are connected to the choices of leaf pairs.
Therefore, handleAmbiguities recursively uses LeafMapping
on the (small) subtrees that have their parents as root. If,
among all combinations, there are parent-rooted ASTs that
have more mapped nodes than the others, MTDIFF has an
indication for a selection of lmamong the ambiguous leaves.
intointo
intm 1 1
intm 1 1
(a) Ambiguous leaf
similarity matrix S.intointo
intm2
31
intm 12
3
(b) Similarity matrix S
after handleAmbiguities .
Figure 9: Ambiguous leaf similarity matrix for Fig 2.
66401:function InnerNodeMapping (rooto, rootm, M)
02: Io unmappedInnerNodes(root o, M)
03: Im unmappedInnerNodes(root m, M)
04: U Io[Im; P ;
05: forio2Iodo
06: forim2Imdo
07: vsim simIV(io, im)
08: csim simIC(io, im)
09: similarity (wI0vsim + wI1csim) =2
10: ifsimilaritythresholdIthen
11: P P[f(io, im, similarity)g
12: P orderBySimilarityAndVisitOrder(P);
13: for(io, im, s)2Pdo
14: ifio2U^im2Uthen
15: M M[f(io, im)g
16: U Unfiog; U Unfimg
17: return M
Figure 10: Creates pairs of inner nodes.
In the example, the parent of the leaf lo=intoisDeclo.
For the ambiguous choices for lm2fintm; intmg, their
parents are DeclmandDeclm, resp. Thus, MTDIFF calls
LeafMapping twice: with (Declo,Declm, M, false) and
also with (Declo,Declm, M, false) . The adjusted simi-
larity simAbetween ambiguous leaves is then based on the
results of LeafMapping , i.e., the number of pairs in the map-
ping. The more pairs, the higher is the similarity between
two leaves. With normalization, simAis:
simA(lo; lm) =jLeafMapping (parent (lo);parent (lm);M;false )j
jmax(nodes (parent (lo));nodes (parent (lm))j.
ForDecloandDeclm, this yields a similarity of2
3as 2
of the 3 nodes in this subtree match, see cell ( into,intm) of
the adjusted matrix in Fig. 9(b). Based on the matrix, the
best mapping of leaves is (into,intm)and(into,intm)
because this maximizes the total combined similarity (= 2).
IfLeafMapping on the parents does not nd a unique best
pair for each row and column, MTDIFF recursively applies
LeafMapping to the grand-parents of the best-rated parents.
It is still possible that even at the root nodes there are
identical similarity values for several leaf pairs. In Fig. 1 this
is the case for the logidentiers. They have the same parent
hierarchy, identical values and labels. The only dierence is
their position within the AST. Therefore, handleAmbiguities
also uses the position of the leaves. It generates a second
matrix D(Distance) that holds the dierences in the post-
order position of the node pairs. For example, the rst logo
and rst logmnodes both have the same post-order position
and thus a dierence d ijof 0. Note that solely using the
position matrix would lead to longer edit scripts.
For the best results, handleAmbiguities combines matrix
D(with cells d ij) with matrix S(cells sij) after the recursive
application of simA. The combination uses weights (w L0
and wL12[0;1]) and inverts and also normalizes the values
to s'ij=wL0(1 sij)1000 + w L1dij. Sec. 4.3 shows
how we determine the weights. The weighted combination
is done in preparation for the next and nal part of the leaf
mapping that ensures a suitable choice of leaf pairs.
It is easy to see the best mapping of leaves in the matrix
in Fig. 9(b). In the general case, nding the pairs with the
best combined similarity is identical to solving the assign-
ment problem [25], for which handleAmbiguities applies the
Hungarian method [25] to the matrix as nal step.
4.2 Inner Node Mapping
Next, MTDIFF uses the InnerNodeMapping algorithm in
Fig. 10. Similar to the leaf mapping step, MTDIFF com-
putes the similarities between all inner nodes and adds allpairs whose similarity is above a threshold Ito the list P(of
similar P airs) in lines 5-11. Whereas CD always selects the
rst pair found above a threshold to prune the search space
and to reduce the runtime, MTDIFF exploits the fact that
Aalready added most inner nodes to the mapping which
reduces the size of the problem. Thus, MTDIFF can aord
to compute all similarities above the threshold Iand to select
the pair with the highest similarity.
Computing the similarity of two inner nodes is more dif-
cult for MTDIFF than for CD. Due to challenge (B), the
similarity functions of CD are not applicable. They expect
that larger parts of the code (e.g., a complete loop condition)
are included in the values of inner nodes. Instead MTDIFF
uses two similarity heuristics ( simIVand simIC) and com-
bines them with two weights (w I0and wI12[0;1]) in line
9. The rst similarity heuristics handles the values of inner
nodes: simIV(io; im) =8
<
:0:0 lbl(io)6=lbl(im);
0:2 v(io)6=v(im)^discrete (io)
sim2g(v(io); v(im))otherwise.
This structure is similar to simL. The dierence lies in the
handling of inner node types for which only discrete values
are allowed. An example for such inner nodes are arithmetic
expressions. For them, only the values of the operation +,
, etc. are valid. In these cases, the similarity of dierent
operations is set to 0.2 (based on preliminary experiments).
Hence, MTDIFF can express an operator change in an arith-
metic expression with a single update action. For all other
types, simIVuses sim2gto measure the textual similarity
of the node values. The use of sim2ghas another positive
side eect: it allows MTDIFF to use the CD-AST in the
evaluation. Without the extra treatment of arithmetic ex-
pressions, sim2gwould return a similarity of 0, leading to
two edit actions ( delete and insert ).
The second similarity heuristics simICof MTDIFF takes
the similarity of the children into account. Without it,
InnerNodeMapping would add (=o,=m1)and (Declo,
Declm)to the mapping for our example in Fig. 2. This
requires 4 additional moves (for the leaves ao, 0o,bo, 1o).
To take the children into account, according to the eval-
uation of Fluri et al [19], it is sucient to only examine
the leaves of the children's subtrees. In contrast to CD,
simIChas to take the importance of smaller subtrees (e.g.,
loop conditions) into account (challenge (B)). CD handles
this together with the values of inner nodes as such code
parts appear as values and not as subtrees in the CD-AST.
Instead, simIChas to normalize the importance of the sub-
trees of the inner nodes ioandimto make them independent
of their sizes. To enforce that small subtrees (expressing a
control ow condition) are as important as the subtrees of
other siblings, regardless of their number of leaves, MTDIFF
uses:
simIC(io; im) =0 lbl(io)6=lbl(im);
sumC (io;im)
jch(io)j+jch(im)jotherwise.
Nodes with dierent AST labels never match. Otherwise,
the similarity of two inner nodes depends on their subtrees
(children ch). For illustration of simIC, consider the two
Args nodes in Fig. 2. Since Argsohas +oas its only child
andArgsmhas the two children + mandtm, there is a di-
vision byjch(io)j+jch(im)=1+2=3 for the normalization of
sumC (io; im) =P
qo2ch(io)jcomp (qo;im)j
jleaves (qo)j+P
qm2ch(im)jcomp (qm;io)j
jleaves (qm)j.
665For each of the children qof both trees, sumC computes
similarity values by counting leaf pairs in the mapping (as
determined by the previous leaf mapping step, i.e., xyoand
xyzmis counted as one pair since the similarity is above
the threshold). With comp( q; i), MTDIFF compares all the
leaves of the subtrees qandi. If one of the leaves has a
mapped leaf somewhere in iit is counted. The resulting
count is normalized by the number of leaves to stress the
importance of small subtrees, e.g., a control ow condition.
Note that a leaf is counted even if it has been moved to a
dierent subtree in i. The rationale is that program struc-
tures remain similar even if somewhere within them code is
moved around. In the example, the child + oofArgsohas
two leaves that both have a mapped node among the leaves
ofArgsm. Weighted by the two leaves in q, this contributes
2
2tosumC . Likewise, + malso contributes2
2. As there is
no mapped leaf for tminio, this child adds0
1= 0 to sumC .
Overall, the two Args nodes have a normalized similarity
of1
3(1+1+0) = 0.67. With this approach, MTDIFF makes
the condition and the body of a loop equally important and
avoids longer edit scripts due to the problem of descendant
subtree matching [19].
4.3 Thresholds and Weights
As mentioned above, MTDIFF uses four weights and two
thresholds. To identify suitable values for those constants,
we performed an extensive Particle Swarm Optimization
(PSO) [22] that minimizes the edit scripts for each of the
changed les in the histories of 4 dierent open source repos-
itories (Checkstyle, Fitlibrary, JGraphT, JUnit). The target
function for the PSO was the number of les for which the
weights and thresholds result in shorter edit scripts com-
pared to an initial set of scripts. This function achieves a
balance between minimizing the edit scripts for les with a
few changes and les with several thousand changes (the al-
ternative to minimize the total number of all edit actions of
all les favored large les). The best values determined by
the PSO are w L0= 0.37, w L1= 0.0024, w I0= 0.40, w I1=
0.25, threshold L= 0.88, and threshold I= 0.10.
5. COMPLEXITY ANALYSIS
The evaluation shows that in practice  A Ebarely in-
crease the runtime of the tree dierencing algorithms.  A
can even make them faster. We now analyze the complexity
fornnodes ( iinner nodes, lleaves). With hash maps  A
has an average complexity of OA(n) [18]. Bhas a worst
case complexity of OB(n3). But real-world codes rarely (or
never) have the worst case in whichn
2nodes from both trees
are part of a mapping and where each LCS execution does
not change this condition.  Chas a complexity of OC(u)
with uunmapped nodes.  Dhas a complexity of OD(i2).
Ehas a complexity of OE(l2logl) as it adds at mostl
2
mappings to the work list.
In our evaluation, MTDIFF is faster than other examined
algorithms, even though its asymptotic complexity is above
OCD(l2logl2+il). For practical use, OAmust reduce
the number of unmapped leaves and unmapped inner nodes
for MTDIFF's phase 1.
In more detail: LeafMapping without ambiguity resolution
is inO(l2log(l2+cL)). This is based on l2leaf comparisons
with cost cLand the sorting of the leaf pairs according to
their similarities in O( l2logl2). The worst case is l(l 
1) pairs of leaves with equal similarities and labels. ThenLeafMapping with ambiguity resolution has to compare all
i2combinations of subtrees of inner nodes to determine the
best leaf matching. Each comparison requires l2executions
ofLeafMapping without ambiguity handling. This causes a
complexity of O(l4i2(logl2+cL)). Dynamic programming
reduces this to OL(l2i2log(l2+cL)) as subtree compar-
isons can be reused. The Hungarian method (see Sec.4.1)
is in OH(l3). The position computation is in OP(l2). The
InnerNodeMapping has a complexity of OI(i2(logi2+cI))
as there are i2comparisons of cost cI. The cost of sort-
ing the inner node pairs according to their similarities is in
O(i2logi2). Thus, if the comparison costs are in O(1), the
complexity of phase 1 of MTDIFF is in OL+OH+OP+OI=
O(l2i2log(l2+cL)+i2(logi2+cI)+l3+l2)O(l2i2logl2+
i2logi2+l3).
6. EVALUATION
The evaluation shows (a) that the general optimizations
shorten the edit script for all tree dierencing algorithms and
(b) that MTDIFF achieves even shorter scripts. Moreover, it
shows (c) that the optimizations and MTDIFF detect more
moves and (d) that for both the optimizations and MTDIFF
the performance is fast enough for practical use. Finally,
we show (e) that shorter edit scripts are more benecial to
developers.
As a common code base, we use the GT framework [1].
This includes the unoptimized baselines of the tree dier-
encing algorithms GT, RTED, and CD. In the framework,
GT and RTED share a ne-grained AST (called GT-AST
below). CD uses a coarse-grained CD-AST. For JSync we
adopted the published source code [3] to the GT framework
(with the JSync-AST) so that the four tree dierencing al-
gorithms use the same edit script generator (phase 2) from
the GT framework. Because of the dierent ASTs, we never
compare the results of GT, RTED, CD and JSync with each
other. Instead, we show the eects of  A Efor each of the
algorithms on their ASTs separately. Since MTDIFF is con-
gurable to use any of the three ASTs, we can compare it
with the other algorithms in Sec. 6.2.
Our dataset uses all commits in the master branches (no
merges) before Aug. 2015 taken from 9 active open-source
Java projects (Ant, Checkstyle, Cobertura, DrJava, Eclipse
JDT Core, Findbugs, Fitlibrary, JGraphT, JUnit). All the
projects are part of the Qualitas Corpus [40]. We excluded
61,435 le revisions because they only contained changed
comments and whitespace. We also excluded 5,496 le re-
visions with more than 20,000 AST nodes because RTED
could not process them with the 128 GB of RAM our work-
station is equipped with (CPU: 3.6 GHz Intel Xeon). We
ignored 9,890 revisions because CD or RTED could not deal
with them in our (articially set) time limit of 3 minutes. For
the remaining 126,162 le revisions in those commits (simply
called lesbelow) we ran the tree dierencing algorithms on
the original le before the commit and the modied le after
the commit. As we ran the tree dierencing algorithms in
5 combinations (without optimizations, with  A, with B,
with C E, with A E) and also MTDIFF with 3 dier-
ent AST types, the time limits were necessary. Except for
the RTED versions (due to the memory limitations) we also
executed 10 changes in parallel. Even with the time limits
and the parallel execution, the measurements took about 6
weeks (24/7) on the workstation.
6666.1 Effects of the General Optimizations
Table 1 shows the eects of  A E(in this order) on the
four state-of-the-art tree dierencing algorithms. We show
the eect of  A Eon the number of pairs in the map-
ping ( map. ) and on the size of the resulting edit scripts.
The third column shows for how many of the 126,162 les
the baseline tree dierencing algorithm (i.e., GT, RTED,
CD, JSync) produces better results (without optimizations
A E). A mapping is better if it has more pairs of nodes;
an edit script is better if it is shorter. Column four shows
for how many les the optimized algorithm with  A Eleads
to better results compared to its original versions. The last
column holds the rest, i.e., the number of les for which the
scripts have the same size or the same number of mappings.
Across all the tree dierencing algorithms, the ve opti-
mizations only have a harmful eect (both on the number
of pairs in the mappings and the script sizes) for a negligi-
ble 1.3% of the les. We discuss some reasons for this in
Sec. 6.2. For 18{98% of the les,  A Eshorten the edit
scripts for all tree dierencing algorithms. The mean edit
script size reduction by  A Eis 279 edit actions (median:
61). For the same les, the mean edit script size produced
by the baseline algorithms is 351 edit actions (median: 142).
RTED is a special case in our evaluation as it already nds
optimal (shortest) edit scripts, although without moves . No
optimization can improve them. But as the RTED in the GT
framework produces a mapping of nodes, this mapping can
be fed into an edit script generator from the GT framework
that considers moves . The generated scripts can be shorter
due to the moves and can also benet from our optimiza-
tions. In fact, for 22% of all les, RTED with optimizations
has shorter edit scripts. This also means that despite its
original use, RTED with the optimizations can act as a tree
dierencing algorithm that takes moves into account.
On its own, each of the ve optimizations also improves
the results. As  Ais already part of the baseline GT, it
has no eect there. But  Ahas a huge impact on the CD
results with an improvement for 97% of all les. The reason
is that for its original purpose CD did not need to handle
unchanged code explicitly. When it is added to JSync,  A
shortens the scripts for 10% of the les, although JSync
already uses a textual line dito detect unchanged code.
From all optimizations,  Bhas the largest impact on GT
and shortens the scripts for 16% of the les without harmful
impact. It also has a strong eect on CD (shorter scripts for
94% of all les) and on JSync (26%). Since individually,  C-
Ehave little eect, we measured them together.  C E
shorten the scripts for GT for 6% of the les (CD: 71%,
JSync: 6%). Overall, all optimizations reduce the script
sizes for several thousand les.
6.2 Performance of MTDIFF
We now compare MTDIFF with the state-of-the-art tree
dierencing algorithms on their respective ASTs. For in-
Table 1: Eects of A Eon changed les.
Baseline With A ESame
better better Size
GT # map." 3 (00.0%) 26,727 (21.2%) 99,432 (78.8%)
(GT-AST) # size# 90 (00.1%) 22,427 (17.8%) 103,645 (82.2%)
RTED # map."1,539 (01.2%) 26,729 (21.2%) 97,894 (77.6%)
(GT-AST) # size#1,325 (01.1%) 28,230 (22.4%) 96,607 (76.6%)
CD # map." 14 (00.0%) 120,149 (95.2%) 5,999 (04.8%)
(CD-AST) # size# 2 (00.0%) 123,724 (98.1%) 2,436 (01.9%)
JSync # map." 86 (00.1%) 38,269 (30.3%) 87,807 (69.6%)
(JSync-AST) # size# 131 (00.1%) 37,963 (30.1%) 88,068 (69.8%)Original code: Modied code:
01: obj1.obj2(obj3);
02: l = m;
03: n = o;obj4 .obj5 (obj1 );
l = t;
n = m;
(a) GT takes 5 edit actions.
01: obj1.obj2(obj3);
02: l = m;
03: n = o;obj4.obj5 (obj1 );
l = t;
n = m;
(b) GTA Etakes 6 edit actions.
01: obj1.obj2(obj3);
02: l = m;
03: n = o;obj4.obj5 (obj1 );
l = t;
n = m;
(c) MTDIFF takes 7 edit actions.
Figure 11: Tough code changes (legend from Fig. 1).
stance, MTDIFF uses the JSync-AST when compared to
JSync. For the comparison we always switch on the opti-
mizations  A Eas they shorten the edit scripts or produce
the same size for almost all les. The third column of Table 2
lists all les for which the state-of-the-art algorithms (with
A Eactivated) produce better results than MTDIFF. The
fourth column shows the larger number of les for which
MTDIFF is better. Across all algorithms, MTDIFF short-
ens the script sizes for 19%{42% of all les. Compared to
the baseline algorithms without  A E, the improvement is
even larger (25%{98%). The mean edit script size reduction
by MTDIFF (compared to the algorithms with  A E) is 21
edit actions (median: 6). For the same les, the mean edit
script size produced by the algorithms with  A Eis 110 edit
actions (median: 42). Note that the comparison also shows
that MTDIFF is capable of producing short edit scripts for
dierent types of ASTs.
There are several cases in which the state-of-the-art algo-
rithms produce shorter edit scripts, i.e., in which the opti-
mizations  A Eare harmful or for which MTDIFF produces
longer edit scripts. A manual inspection of the cases revealed
two main patterns of tough code changes. Fig. 11 illustrates
both. First, if nodes with the same label are moved and
at least one of them is updated , it is sometimes shorter to
use only update actions in the edit script. Fig. 11(a) shows
that GT can express the changes in line 1 with three up-
dates as the underlying RTED nds the optimal move -free
edit script. In some cases, JSync's heuristics also handle
this situation well. In contrast, the optimizations  A E
add as many pairs of identical nodes to the mapping as pos-
sible. Under some circumstances this can lead to longer edit
scripts as shown in line 1 of Fig. 11(b+c). The second tough
pattern are nodes that are moved and replaced in their for-
mer position with a node of the same label. Consider lines
2 and 3 of the example in Fig. 11. The identier mismoved
from line 2 to line 3 and a new identier ttakes its former
place. While it is possible to express the change with the
two updates (m o, tm)and (oo, mm), phase 1 of MTDIFF
Table 2: Performance of MTDIFF on changed les.
Alg. with A EMTDIFF Same
better better Size
GTA E# map." 1,646 (01.3%) 20,155 (16.0%) 104,361 (82.7%)
(GT-AST) # size# 8,966 (07.1%) 23,797 (18.9%) 93,399 (74.0%)
RTEDA E# map." 1,136 (00.9%) 24,425 (19.4%) 100,601 (79.7%)
(GT-AST) # size# 9,124 (07.2%) 24,944 (19.8%) 92,094 (73.0%)
CDA E# map." 1,150 (00.9%) 18,556 (14.7%) 106,456 (84.4%)
(CD-AST) # size# 3,628 (02.9%) 52,369 (41.5%) 70,165 (55.6%)
JSyncA E# map." 1,385 (01.1%) 21,845 (17.3%) 102,932 (81.6%)
(JSync-AST) # size# 8,287 (06.6%) 25,104 (19.9%) 92,771 (73.5%)
6670% 20% 40% 60% 80% 100%JSyncCDRTEDGT
JSync-ASTCD-ASTGT-ASTGT-AST
Figure 12: Fraction of move -only that are found on
the respective ASTs (black for the baseline alg., gray
with A Eadded, and white for MTDIFF).
nevertheless adds the pair (m o, mm) to the mapping which
not only causes the move in phase 2, but also a delete (oo)
and an insert (tm) action. This yields a longer edit script,
see Fig. 11(c). We plan to address these issues with an ad-
ditional post-processing step in the future.
6.3 Move Accuracy
Not all possible moves reduce the size of the edit scripts
(see Fig. 11). In general, it is hard to determine whether the
moves in a script make it shorter. Falleri et al. [18] argue
that a tree dierencing algorithm is more precise in detecting
moves and thus more likely to nd the ideal number of moves
if it identies more scripts that solely consist of moves .
Based on this way to gauge the script quality, we count the
les for which the tree dierencing algorithms have found
move -only scripts. Separately for each type of AST, we
identify all such les that are found by any of the algo-
rithms (with or without  A E) and by MTDIFF. Fig. 12
sets this total count of move -only scripts to 100% for each of
the ASTs. The black areas in the gure show the fractions
that the baseline versions identify, the gray areas show the
fractions found when the optimizations  A Eare activated.
With the optimizations, all algorithms nd more move -only
scripts. Thus, the optimizations improve the accuracy in
detecting moves . No single move -only script was missed be-
cause of the optimizations. There is no black area for the
baseline RTED as it does not generate moves .
The white areas show that MTDIFF is always more ac-
curate in detecting moves . For both the GT-AST and the
JSync-AST, MTDIFF did not miss a single move -only script.
On its AST, CD A Eidenties some move -only scripts that
MTDIFF does not detect (8% of all scripts). The reason is
that the PSO (see Sec. 4.3) optimized MTDIFF's weights
and thresholds for a ne-grained AST.
6.4 Runtime
To evaluate the runtime of the optimizations we compare
the baseline algorithms with their optimized variants. To
ease comparison with related work, we select the Jenkins [2]
repository that is also used by Falleri et al. [18]. As dataset
we use all 1,293 le changes in the commits between the ver-
sions 1.509.2 and 1.532.2. In a total of 27 hours, our work-
station executed each tree dierencing algorithm 5 times on
these changes.
We only measure the time taken by phase 1 and by the
optimizations as all the tree dierencing algorithms use the
same script generator (phase 2). For this dataset there is no
need to exclude any les due to memory or runtime limita-
tions. Also, in contrast to the previous measurements, we
executed no changes in parallel.The box plots in Fig. 13 capture the results (25% =75%
quartiles, whiskers for 1.5 times the interquartile range).
The optimizations only slightly slow down GT, RTED, and
JSync. Across all les, the mean runtime increase for GT,
RTED and JSync is 0.062s (median: 0.0032s). For most
applications this is an acceptable overhead. With the op-
timizations switched on, CD runs even faster because  A
reduces the problem size, see the discussion in Sec. 3.1.
The lower three box plots in Fig. 13 show the runtime of
MTDIFF on the dierent ASTs. Due to its higher complex-
ity, MTDIFF is slower than GT. This is the price to pay
for shorter edit scripts. Even though phase 1 of MTDIFF
has a higher asymptotic complexity than CD, it is faster due
to the eect of  A. Compared to CD A E, MTDIFF is on
par. Overall, MTDIFF requires less than 0.3s for the ma-
jority of les which we consider an acceptable runtime. The
lower three box plots also illustrate the eect of the AST
granularity on the runtime.
6.5 Script Size Questionnaire
The goal of  A Eand MTDIFF is to produce shorter
edit scripts. This section reports on a survey with eight
developers (not the authors) to determine whether this is a
reasonable goal and whether shorter edit scripts are more
helpful to them. We base this study on the dataset that
was used for Tables 1 and 2. From the 126,162 le changes,
we excluded large ones (pairs in the mapping + edit actions
500) as they are hard to analyze for study participants.
From each of the 2 43 = 24 shaded cells in the two
tables, we randomly selected 10 le changes and the corre-
sponding two edit scripts created by the two compared tree
dierencing algorithms (or variations). The alternative, a
completely random selection of the changes would have fa-
vored the tree dierencing algorithms with  A Eover the
baseline versions, MTDIFF over the algorithms with  A E,
or same-size cases over cases with dierent script sizes. If
there are less than 10 le changes in a cell (for instance there
are only 2 changes for which the baseline CD is better than
CDA E), we randomly picked the missing le changes from
the same column. We also picked only changes with dierent
edit scripts from the cells in the same-size columns. In the
other cells, the size dierence in the edit scripts was between
1 and 234 (mean: 1.5, median: 2.5).
We presented a questionnaire with all of the 24 10 = 240
0 0:5 1 1:5 2 2:5 3MTDIFF
(JSync-AST)MTDIFF
(CD-AST)MTDIFF
(GT-AST)JSyncA EJSyncCDA ECDRTEDA ERTEDGTA EGT
Execution time (sec.) per changed le.
Figure 13: Runtimes for Jenkins.
668Table 3: Questionnaire results (1,920 answers).
First Second Unclear Sum
more helpful more helpful
First shorter 270 180 190 640
Second shorter 106 354 180 640
Same Size 197 238 205 640
Sum 573 772 575 1,920
pairs of edit scripts in a graphical representation (similar to
Fig. 1) to the eight study participants that all hold a mas-
ter or PhD degree in Computer Science or Mathematics.
To avoid order eects, we randomized the order of the edit
scripts in each pair and also showed the 240 pairs to each of
the participants in a random order. For each of the pairs,
we asked the participants \Is the rst or the second repre-
sentation more helpful in understanding the intention of the
change? [First, Second, or Unclear]".
Table 3 holds the results of the 240 8 answers. When the
rst edit script was shorter, the majority of the participants
also found the rst script to be more helpful (270). Simi-
larly, when the second script was shorter, more participants
preferred the second script (354). When the scripts had the
same size there was no clear dierence and the results were
more similar to a random distribution.
More formally, Pearson's chi-squared test [34] rejects our
null hypothesis that the two nominal variables (script size
dierence in the pairs versus helpfulness) are independent
(p <0:001). This allows us to examine the strength of the
eect that the size dierence has on the helpfulness. Since
the third row (same size) has no size dierence and thus no
eect to be measured, it is left out of the remaining eval-
uation. For the rst and second row, Cram er's association
measurement is V= 0:32 (where 0 indicates no association
and 1 is a full association) [15]. Cohen's eect size measure
isw=Vprows 1 = 0 :32 [14], this indicates a medium
eect of the script size dierence on the helpfulness. How-
ever, wdoes not address the issue whether a shorter or a
longer script increases the helpfulness. For that, we can use
the observations from Table 3. As there are more \helpful"-
votes for shorter scripts, the shorter scripts have a medium
positive eect on the helpfulness.
6.6 Limitations and Threats to Validity
None of the ve optimizations  A Euses language de-
pendent features. Thus, they should also work for other pro-
gramming languages even though the evaluation only uses
Java code. This is also supported by the fact that there is no
large variation in the results regardless of the type of AST
we have used.
A threat to validity are possible bugs in the implementa-
tions. As far as possible we used publicly available baseline
code. The parsers, the edit script generator, GT, RTED,
and CD are part of the GT tool [1]. We also open-sourced
our code changes (and the adaption of CD to use the results
of A) to make our results reproducible. After adopting a
publicly available JSync implementation to the GT frame-
work, all four tree dierencing algorithms produce compara-
ble mappings and edit scripts whose variations are reason-
able, both with and without the optimizations.
A threat to validity is the manual analysis of the script
quality because the participants are members of the same
university as the authors. Therefore we make the question-
naires and the raw answers available to allow re-evaluation.7. RELATED WORK
We divide the related work into three categories, namely
line dierencing, tree dierencing, and other approaches.
Miller and Myers [30, 31] describe the basic algorithm
that is still used in the ditool. Newer line dierencing
approaches [7, 11, 36] also detect moved lines but are still
too coarse-grained for source code dierencing.
There are several optimal tree dierencing algorithms for
ordered trees that do not consider move operations [16, 23,
39, 42]. Bille [9] provides a survey. CSLICER [26] uses a tree
dierencing algorithm with heuristics that does not support
moves . RTED [33], the currently fastest optimal algorithm,
has a complexity of O( n3). We discuss it throughout this
paper and in our comparison.
This paper also works with and improves three publicly
available tree dierencing algorithms that support moves :
ChangeDistiller that was created by Fluri et al. [19] based
on an algorithm by Chawathe et al. [12], Gumtree [18] that
already includes  Aand relies on RTED, and JSync [32]
that uses a line-based dito identify unchanged parts of
the code but nevertheless still benets from  A.
Di/TS [20, 21] is another tree dierencing tool that sup-
ports moves . Its top-down step is similar to  A. We are con-
vinced that the general optimizations  B-Epresented in
this paper are also useful for Di/TS. But because the source
code is not publicly available and as the papers are not de-
tailed enough for a fair and competitive re-implementation,
we cannot prove this.
There are also tree dierencing algorithms that are tai-
lored to specic languages, but still can benet from our
ndings. For example there are several for XML [5, 13, 37],
some of which also use ngerprints. Vdi [17] is a tree dier-
encing algorithm for Verilog HDL. There are also approaches
that handle graphs instead of ASTs (e.g., UMLDi [41], JD-
IFF [6], Dex [35]). With some adaptations, like breaking cir-
cles at appropriate places, some of our optimizations might
also be useful for them.
8. CONCLUSION
This work introduces ve general optimizations for tree
dierencing algorithms. We evaluate the performance of
the optimizations with four state-of-the-art tree dierenc-
ing algorithms (GT, RTED, CD, and JSync) on code from
open-source archives. The optimizations shorten the sizes
of the edit scripts for 18-98% of the 126,162 analyzed les
(depending on the baseline tree dierencing algorithm used).
We also introduce our novel Move-optimized Tree DIF-
Ferencing algorithm MTDIFF. It uses a new approach to
identify and map corresponding leaves between the original
and modied AST. Additionally, MTDIFF uses a new met-
ric to measure the similarity of inner nodes of the two ASTs.
Our evaluation shows that MTDIFF produces even shorter
scripts for around 20% of all les, independently of the type
of AST used.
For reproducibility, we open-source all the measurements,
including the questionnaire (https://github.com/FAU-Inf2/
tree-measurements), and the source codes (https://github.
com/FAU-Inf2/treedierencing).
9. ACKNOWLEDGMENTS
This project has been supported by the Embedded Sys-
tems Institute (ESI) http://esi-anwendungszentrum.de/.
66910. REFERENCES
[1] GumTreeDi, 2016.
https://github.com/GumTreeDi/.
[2] Jenkins, 2016. https://github.com/jenkinsci/jenkins.
[3] JSync, 2016. https://sites.google.com/site/
nguyenanhhoan/JSync4Public.zip.
[4] T. Akutsu. Tree edit distance problems: Algorithms
and applications to bioinformatics. IEICE Trans. Inf.
Syst. , 93D(2):208{218, Feb. 2010.
[5] R. Al-Ekram, A. Adma, and O. Baysal. diX: An
Algorithm to Detect Changes in Multi-version XML
Documents. In CASCON'05: Conf. Centre for
Advanced Studies on Collaborative Research , pages
1{11, Toranto, Canada, Oct. 2005.
[6] T. Apiwattanapong, A. Orso, and M. J. Harrold. A
Dierencing Algorithm for Object-Oriented Programs.
InASE'04: Intl. Conf. Automated Softw. Eng. , pages
2{13, Linz, Austria, Sep. 2004.
[7] M. Asaduzzaman, C. Roy, K. Schneider, and M. Di
Penta. LHDi: A Language-Independent Hybrid
Approach for Tracking Source Code Lines. In
ICSM'13: Intl. Conf. on Softw. Maintenance , pages
230{239, Eindhoven, The Netherlands, Sep. 2013.
[8] L. Bergroth, H. Hakonen, and T. Raita. A Survey of
Longest Common Subsequence Algorithms. In
SPIRE'00: String Processing and Inf. Retrieval
Symp. , pages 39{48, A Coruna, Spain, Sep. 2000.
[9] P. Bille. A survey on tree edit distance and related
problems. Theoretical Computer Science ,
337(1):217{239, June 2005.
[10] U. Boobna and M. de Rougemont. Correctors for
XML Data. In Database and XML Technologies ,
volume 3186 of Lecture Notes in Computer Science ,
pages 97{111.
[11] G. Canfora, L. Cerulo, and M. Di Penta. Tracking
Your Changes: A Language-Independent Approach.
IEEE Software , 26(1):50{57, Jan. 2009.
[12] S. S. Chawathe, A. Rajaraman, H. Garcia-Molina, and
J. Widom. Change Detection in Hierarchically
Structured Information. In SIGMOD'96: Intl. Conf.
Management of Data , pages 493{504, Montreal,
Canada, June 1996.
[13] G. Cobena, S. Abiteboul, and A. Marian. Detecting
changes in XML documents. In ICDE'02: Intl. Conf.
Data Eng. , pages 41{52, San Jose, CA, Feb. 2002.
[14] J. Cohen. Statistical Power Analysis for the
Behavioral Sciences . Lawrence Erlbaum Associates,
Inc., Hillsdale, NJ, 2nd edition, 1988.
[15] H. Cram er. Mathematical Methods of Statistics .
Princeton University Press, Princeton, NJ, 1946.
[16] E. D. Demaine, S. Mozes, B. Rossman, and
O. Weimann. An Optimal Decomposition Algorithm
for Tree Edit Distance. ACM Trans. Alg. ,
6(1):2:1{2:19, Dec. 2009.
[17] A. Duley, C. Spandikow, and M. Kim. A Program
Dierencing Algorithm for Verilog HDL. In ASE'10:
Intl. Conf. Automated Softw. Eng. , pages 477{486,
Antwerp, Belgium, Sep. 2010.
[18] J. Falleri, F. Morandat, X. Blanc, M. Martinez, and
M. Monperrus. Fine-grained and accurate source code
dierencing. In ASE'14: Intl. Conf. Automated Softw.
Eng., pages 313{324, V aster as, Sweden, Sep. 2014.[19] B. Fluri, M. Wuersch, M. Pinzger, and H. Gall.
Change Distilling: Tree Dierencing for Fine-Grained
Source Code Change Extraction. IEEE Trans. Softw.
Eng., 33(11):725{743, Nov. 2007.
[20] M. Hashimoto and A. Mori. Di/TS: A Tool for
Fine-Grained Structural Change Analysis. In
WCRE'08: Working Conf. Reverse Eng. , pages
279{288, Antwerp, Belgium, Oct. 2008.
[21] M. Hashimoto, A. Mori, and T. Izumida. A
comprehensive and scalable method for analyzing
ne-grained source code change patterns. In
SANER'15: Intl. Conf. Softw. Anal., Evolution and
Reengineering , pages 351{360, Montr eal, Canada,
Mar. 2015.
[22] J. Kennedy and R. Eberhart. Particle swarm
optimization. In ICNN'95: Intl. Conf. Neural
Networks , pages 1942{1948, Perth, Australia, Nov.
1995.
[23] P. N. Klein. Computing the Edit-Distance between
Unrooted Ordered Trees. In ESA'98: Europ. Symp.
Alg., pages 91{102, Venice, Italy, Aug. 1998.
[24] G. Kondrak. N-Gram Similarity and Distance. In
SPIRE'2005: String Processing and Inf. Retrieval
Symp. , pages 115{126, Buenos Aires, Argentina, Nov.
2005.
[25] H. W. Kuhn and B. Yaw. The Hungarian method for
the assignment problem. Naval Res. Logist. ,
2(1-2):83{97, Mar. 1955.
[26] Y. Li, J. Rubin, and M. Chechik. Semantic Slicing of
Software Version Histories. In ASE'15: Intl. Conf.
Automated Softw. Eng. , Lincoln, NE, Nov. 2015.
[27] B. Ma, L. Wang, and K. Zhang. Computing similarity
between RNA structures. Theoretical Computer
Science , 276(1-2):111{132, Apr. 2002.
[28] N. Meng, L. Hua, M. Kim, and K. S. McKinley. Does
Automated Refactoring Obviate Systematic Editing?
InICSE'15: Intl. Conf. Softw. Eng. - Volume 1 , pages
392{402, Florence, Italy, May 2015.
[29] N. Meng, M. Kim, and K. S. McKinley. LASE:
Locating and Applying Systematic Edits by Learning
from Examples. In ICSE'13: Intl. Conf. Softw. Eng. ,
pages 502{511, San Francisco, CA, May 2013.
[30] W. Miller and E. W. Myers. A le comparison
program. Software: Practice and Experience ,
15(11):1025{1040, Nov. 1985.
[31] E. W. Myers. AnO(ND) dierence algorithm and its
variations. Algorithmica , 1(1-4):251{266, Nov. 1986.
[32] H. A. Nguyen, T. T. Nguyen, N. Pham, J. Al-Kofahi,
and T. Nguyen. Clone Management for Evolving
Software. IEEE Trans. Softw. Eng. , 38(5):1008{1026,
Sep. 2012.
[33] M. Pawlik and N. Augsten. RTED: A Robust
Algorithm for the Tree Edit Distance. VLDB Endow. ,
5(4):334{345, Dec. 2011.
[34] K. Pearson. On the criterion that a given system of
deviations from the probable in the case of a
correlated system of variables is such that it can be
reasonably supposed to have arisen from random
sampling. Philosophical Magazine Series 5 ,
50(302):157{175, 1900.
[35] S. Raghavan, R. Rohana, D. Leon, A. Podgurski, and
V. Augustine. Dex: a semantic-graph dierencing tool
670for studying changes in large code bases. In ICSM'04:
Proc. Intl. Conf. on Softw. Maintenance , pages
188{197, Chicago, IL, Sep. 2004.
[36] S. P. Reiss. Tracking Source Locations. In ICSE'15:
Intl. Conf. Softw. Eng. , pages 11{20, Leipzig,
Germany, May 2008.
[37] S. R onnau and U. Borgho. XCC: change control of
XML documents. Computer Science - Research and
Development , 27(2):95{111, 2012.
[38] D. Shapira and J. A. Storer. Edit Distance with Move
Operations. In CPM'02: Symp. on Combinatorial
Pattern Matching , pages 85{98, Fukuoka, Japan, July
2002.
[39] K.-C. Tai. The Tree-to-Tree Correction Problem. J. ofthe ACM (JACM) , 26(3):422{433, July 1979.
[40] E. Tempero, C. Anslow, J. Dietrich, T. Han, J. Li,
M. Lumpe, H. Melton, and J. Noble. Qualitas Corpus:
A Curated Collection of Java Code for Empirical
Studies. In APSEC'10: Proc. Asia Pacic Softw. Eng.
Conf. , pages 336{345, Sydney, Australia, Dec. 2010.
[41] Z. Xing and E. Stroulia. UMLDi: An Algorithm for
Object-oriented Design Dierencing. In ASE'05: Intl.
Conf. Automated Softw. Eng. , pages 54{65, Long
Beach, CA, Oct. 2005.
[42] K. Zhang and D. Shasha. Simple Fast Algorithms for
the Editing Distance between Trees and Related
Problems. J. on Computing (SIAM) , 18(6):1245{1262,
1989.
671