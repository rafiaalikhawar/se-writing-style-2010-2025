Leveraging Program Analysis to Reduce
User-Perceived Latency in Mobile Applications
Yixue Zhao
 , Marcelo Schmitt Laser
 , Yingjun Lyu
 , Nenad Medvidovic
University of Southern California
 Pontifical Catholic University of Rio Grande do Sul
Los Angeles, CA, USA Porto Alegre, RS, Brazil
{yixue.zhao, yingjunl, neno}@usc.edu marcelo.laser@gmail.com
ABSTRACT
Reducing network latency in mobile applications is an effective
way of improving the mobile user experience and has tangible
economic benefits. This paper presents PALOMA, a novel client-
centric technique for reducing the network latency by prefetching
HTTP requests in Android apps. Our work leverages string analy-
sis and callback control-flow analysis to automatically instrument
appsusingPALOMAâ€™srigorousformulationofscenariosthatad-
dress â€œwhatâ€ and â€œwhenâ€ to prefetch. PALOMA has been shown
to incur significant runtime savings (several hundred milliseconds
perprefetchableHTTPrequest),bothwhenappliedonareusable
evaluation benchmark we have developed and on real applications.
1 INTRODUCTION
Inmobilecomputing,user-perceivedlatencyisacriticalconcernas
it directly impacts user experience and often has severe economic
consequences.Arecentreportshowsthatamajorityofmobileusers
would abandon a transaction or even delete an app if the response
timeofatransactionexceedsthreeseconds[ 6].Googleestimates
thatanadditional500msdelaypertransactionwouldresultinupto
20% loss of traffic, while Amazon estimates that every 100ms delay
would cause 1% annual sales loss [ 42]. A previous study showed
that network transfer is often the performance bottleneck, and
mobile apps spend 34-85% of their time fetching data from the
Internet [ 32]. A compounding factor is that mobile devices rely
onwirelessnetworks, which can exhibit high latency, intermittent
connectivity, and low bandwidth [21].
Reducing network latency thus becomes a highly effective way
ofimprovingthemobileuserexperience.Inthecontextofmobile
communication,wedefine latencyastheresponsetimeofanHTTP
request. In this paper, we propose a novel client-centric technique
for minimizing the network latency by prefetching HTTP requests
inmobileapps.Prefetchingbypassestheperformancebottleneck(inthiscase,networkspeed)and maskslatencybyallowingaresponse
to a request to be generated immediately, from a local cache.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,
topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden
Â© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5638-1/18/05...$15.00
https://doi.org/10.1145/3180155.3180249Prefetching has been explored in distributed systems previously.
Existingapproachescanbedividedintofourcategoriesbasedon
whatthey prefetch and whenthey do so. (1) Server-based tech-
niquesanalyzetherequestssenttotheserverandprovideâ€œhintsâ€
totheclientonwhattoprefetch[ 13,28,34,35].However,mostofto-
dayâ€™smobileappsdependextensivelyonheterogeneousthird-party
servers.Thus,providingserver-sideâ€œhintsâ€isdifficult,notscalable,
orevenimpossiblebecauseappdevelopersdonothavecontrolover
thethird-partyservers[ 42].(2)Human-based approachesrelyon
developerswhohavetoexplicitlyannotateapplicationsegments
that are amenable to prefetching [ 25,26]. Such approaches are
error-prone and pose significant manual burden on developers. (3)
History-based approaches build predictive models from prior re-
queststoanticipatewhatrequestwillhappennext[ 14,22,28,36,43].
Suchapproachesrequiresignificanttimetogatherhistoricaldata.
Additionally,buildingaprecisepredictivemodelbasedonhistoryis
moredifficultintodayâ€™ssettingbecausethecontextofmobileusers
changesfrequently. (4)Domain-based approachesnarrowdownthe
problemtoonespecificdomain.Forexample,approachesthatfocus
onthesocialnetworkdomain[ 40,44]onlyprefetchtheconstant
URLs in tweets based on user behavior and resource constraints.
These approaches cannot be applied to mobile apps in general.
To address these limitationsof current prefetching approaches,
we have developed PALOMA (Program Analysis for Latency Opti-
mizationofMobileApps),anoveltechniquethatis client-centric,
automatic,domain-independent,andrequiresnohistoricaldata.In
this paper, we focus on native Android apps because of Androidâ€™s
dominant market share [ 31] and its reliance on event-driven in-
teraction, which is the most popular style used in mobile apps
today. Our guiding insight is that an appâ€™s codecan provide a lot of
useful information regarding whatHTTP requests may occur and
when.Inaddition,amobileuserusuallyspendsmultipleseconds
decidingwhateventtotriggernextâ€”aperiodknownasâ€œuserthink
timeâ€[26]â€”providinganopportunitytoprefetchHTTPrequests
in the background. By analyzing an Android program, we are able
toidentifyHTTPrequestsandcertainuser-eventsequences(e.g.,
onScroll followed by onClick). With that information, we can
prefetch requests that will happen next during user think time.
User-eventtransitionsarecapturedascallbackcontrol-flow[ 46]
relationships in PALOMA, and we only perform very targeted,
short-term prefetchingâ€”a singlecallback ahead. There are several
reasons we opted for this strategy. First, short-term prefetching
minimizes the cache-staleness problem that is commonly experi-
encedbylonger-termprefetchingbecausethenewlyupdatedcache
1762018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:51:40 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™18, May 27-June 3, 2018, Gothenburg, SwedenYixue Zhao
 , Marcelo Schmitt Laser
 , Yingjun Lyu
 , Nenad Medvidovic
will be used immediately when the user transitions to the next
event. Second, the information needed to send the HTTP requests
(e.g.,a parameterin anHTTP requestthat dependson userinput)
is more likely to be known since the prefetching occurs very close
intimetotheactualrequest.Third,short-termprefetchingtakes
advantage of user think time between callbacks, which has been
showntobesufficientforprefetchingHTTPrequests[ 14,26].By
contrast,prefetching withinthesamecallback wouldnotprovide
a performance gain since the relevant statements would execute
within a few milliseconds of one another.
PALOMA comprises four major elements. (1) String Analysis
identifies the â€œprefetchableâ€ requests by interpreting each URL
string.(2) CallbackAnalysis determines theprefetching points for
the â€œprefetchableâ€ requests by analyzing callback control-flow rela-
tionships. (3)AppInstrumentation modifiestheoriginalappbased
on the information extracted in the previous phases and outputs
anoptimizedappthatprefetchestheHTTPrequests. (4)Runtime
prefetching involves the optimized app and a local proxy that is in
charge of prefetching HTTP requests and managing the responses.
PALOMAâ€™sfirsttwoelementsareadaptationsandextensionsofex-
isting techniques, while the latter two have been newly developed.
PALOMAhasbeenevaluatedforaccuracyandeffectivenessin
two different ways. First, we developed a microbenchmark (MBM)
that isolates different prefetching conditions that may occur in
an Android app. The MBM can be reused for evaluating similar
futureapproaches.Second,weappliedPALOMAon32realAndroidapps.OurevaluationshowsthatPALOMAexhibitsperfectaccuracy
(in terms of precision and recall) and virtually eliminates user-
perceived latency, while introducing negligible runtime overhead.
Thispapermakesthefollowingcontributions:(1)PALOMA,a
novel client-side, automated, program analysis-basedprefetching
techniqueformobileapps;(2)arigorousformulationofprogram
analysis-based prefetching scenarios that addresses â€œwhatâ€ and
â€œwhenâ€ to prefetch; (3) a comprehensive, reusable MBM to eval-
uate prefetching techniques for Android apps; and (4) the imple-
mentation of an open-source, extensible framework for program
analysis-basedprefetching.PALOMAâ€™ssourcecodeandsupporting
materials are publicly available [15].
The paper is organized as follows. Section 2 motivates the prob-
lem and defines the terms used by PALOMA. Sections 3 and 4
describe PALOMAâ€™s approach and implementation. Sections 5 and
6 detail PALOMAâ€™s evaluation using a benchmark and real apps.
Section 7 presents related work, and Section 8 concludes the paper.
2 BACKGROUND AND MOTIVATION
Inthissection,weuseaconcreteexampletointroducethefunda-
mental building blocks and execution model of mobile apps, with a
particular focus on Android. We then introduce our insights and
motivation, followed by the definition of several key terms.
2.1 Mobile App Example
Mobile apps that depend on network generally involve two key
concepts: eventsthatinteractwithuserinputsand networkrequests
that interact with remote servers. We explain these concepts via
Listing1â€™ssimplifiedcodefragmentofanAndroidappthatresponds
to user interactions by retrieving weather information.
Events:In mobile apps, user interactions are translated to inter-
nalappevents.Forinstance,ascreentapistranslatedtoan onClickevent. Each event is, in turn, registered to a particular application
UIobjectwithacallbackfunction;thecallbackfunctionisexecuted
when the event is triggered. For instance in Listing 1, the button
objectsubmitBtn isregisteredwithan onClick event(Line9),and
thecorrespondingcallbackfunction onClick() (Line10)willbeex-
ecuted when a user clicks the button. Similarly, the drop-down box
objectcityNameSpinner is registered with an onItemSelected
event that has an onItemSelected() callback function (Lines 5-7).
NetworkRequests: Withinaneventcallbackfunction,theapp
often has to communicate with remote servers to retrieve informa-
tion.Thecommunicationisperformedthroughnetworkrequests
overtheHTTPprotocolinmostnon-realtimeapps[ 12].EachHTTP
request is associated with a URL field that specifies the endpoint of
therequest.ForinstanceinListing1,the onClickeventcallback
sends three HTTP requests, eachwith a unique URL (Lines12-14).
TherearetwotypesofURLvalues,dependingonwhenthevalue
is known: staticanddynamic. For instance, favCityId in Listing 1
isstaticbecauseitsvalueisobtainedstaticallybyreadingtheap-
plication settings (Lines 4, 12). Similarly, getString("domain")
reads the constant string value defined in an Android resource
file[20](Line12,13,14).Incontrast, cityName isdynamicsinceits
valuedependsonwhichitemauserselectsfromthedrop-downbox
cityNameSpinner duringruntime(Lines7,13).Similarly, cityId
is also a dynamic URL value (Lines 11, 14).
1classMainActivity {
2String favCityId, cityName, cityId;
3protected void onCreate(){
4favCityId = readFromSetting("favCityId");//static
5cityNameSpinner.setOnItemSelectedListener(new OnItemSelectedListener(){
6 public void onItemSelected() {
7 cityName = cityNameSpinner.getSelectedItem().toString();//dynamic
8 }});
9submitBtn.setOnClickListener(new OnClickListener(){
10 public void onClick(){
11 cityId = cityIdInput.getText().toString();//dynamic
12 URL url1 = newURL(getString("domain")+"weather?&cityId="+favCityId);
13 URL url2 = newURL(getString("domain")+"weather?cityName="+cityName);
14 URL url3 = newURL(getString("domain")+"weather?cityId="+cityId);
15 URLConnection conn1 = url1.openConnection();
16 Parse(conn1.getInputStream());
17 URLConnection conn2 = url2.openConnection();
18 Parse(conn2.getInputStream());
19 URLConnection conn3 = url3.openConnection();
20 Parse(conn3.getInputStream());
21 startActivity(DisplayActivity.class);
22}});
23}
24}
Listing 1: Code snippet with callbacks and HTTP requests
2.2 Motivation and Challenges
ThemotivationforPALOMAisthatonecansignificantlyreduce
theuser-perceivedlatencybyprefetchingcertainnetworkrequests.
For instance, Listing 1 corresponds to a scenario in which a userselects a city name from the drop-down box
cityNameSpinner
(Line 7), then clicks submitBtn (Line 9) to get the cityâ€™s weather
informationthroughanHTTPrequest.Toreducethetimetheuser
willhavetowaittoreceivetheinformationfromtheremoteserver,
a prefetching scheme would submit that request immediately after
the user selects a city name, i.e., before the user clicks the button.
Prefetching HTTP requests is possible for two reasons. First, an
HTTPrequestâ€™sdestinationURLcansometimesbeknownbefore
theactualrequestissentout,suchasthestaticURL url1(Line12)in
Listing 1. Second, there is often sufficiently long slack between the
177
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:51:40 UTC from IEEE Xplore.  Restrictions apply. Leveraging Program Analysis to Reduce
User-Perceived Latency in Mobile ApplicationsICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden
time a requestâ€™s URL value is known and when the request is sent
out,duetoothercodeâ€™sexecutionandtheâ€œuserthinktimeâ€[ 14,26].
Prefetching in effect â€œhidesâ€ the network latency by overlapping
the network requests with the slack period.
The key challenges to efficiently prefetching HTTP requests
involve determining (1) which HTTP requests to prefetch, (2) what
their destination URL values are, and (3) when to prefetch them.
Priorworkaddressedthesechallengesbyrelyingonvariousserver
hints [13,28,34], developer annotations [ 25,26], and patterns of
historical user behaviors [ 14,22,28,36,43]. Our goal is to avoid
relyingonsuchexternalinformationthatmaybedifficulttoobtain,
and instead to use only program analysis on the app.
2.3 Terminology
We define several terms needed for describing our approach to
program analysis-based prefetching of network requests.
URL Spot is a code statement that creates a URL object for
an HTTP request based on a string denoting the endpoint of the
request. Example URL Spots are Lines 12, 13, and 14 in Listing 1.
Definition Spot m,nis a code statement where the value of a
dynamicURLstringisdefined,suchasLines7and11inListing1. m
denotesthe mthsubstringintheURLstring,and ndenotesthe nth
definition of that substring in the code. For example, Line 7 would
containDefinitionSpot L73,1forurl2becausecityName isthethird
substringin url2andLine7isthefirstdefinitionof cityName .A
singlestatementofcodemayrepresentmultipleDefinitionSpots,
each of which is associated with a dynamic string used in different
URLs.
FetchSpot is a code statement where the HTTP request is sent
to the remote server. Example Fetch Spots are Lines 16, 18, and 20.
Callback is a method that is invoked implicitly by the Android
framework in response to a certain event. Example callbacks from
Listing 1 include the onItemSelected() (Line 6) and onClick()
(Line 10) methods. These are referred to as event handler callbacks
in Android as they respond to user interactions [ 18]. Android also
defines a set of lifecycle callbacks that respond to the change of an
appâ€™s â€œlife statusâ€ [17], such as the onCreate() method at Line 3.
Call Graph is a directed graph representing the explicitinvoca-
tion relationships between procedures in the app code.
Target Method is a method that contains at least one Fetch
Spot. It is named that because identifying methods that contain
onCreate,
MainActivity
wn1
onClick,
Button, 
[submitBtn]onItemSelected,
Spinner,
[cityNameSpinner]
onCreate,
DisplayActivity1
2
345
callback,
Class,
[instance]Legend
Figure 1: CCFG extracted from Listing 1 by GATOR [33, 46]Fetch Spots is the target of PALOMAâ€™s analysis (see Section 3).
For example, the onClick() method is a Target Method because it
contains three Fetch Spots. A Target Method may or may not be a
Callback.
TargetCallback isaCallbackthatcanreachatleastoneTarget
Method in a Call Graph. If a Target Method itself is a Callback,
itisalsoaTargetCallback.Forexample,the onClick() Callback
defined at Lines 10-22 of Listing 1 is a Target Callback.
CallbackControl-FlowGraph (CCFG)representsthe implicit-
invocationflowinvolvingdifferentCallbacks[ 46].InaCCFG,nodes
represent Callbacks, and each directed edge fâ†’sdenotes that sis
the next Callback invoked after f. Figure 1 illustrates the CCFG
extracted from Listing1 using GATOR, a recently-developedanaly-
sis technique [ 33,46]. Await node in a CCFG (e.g., wn1in Figure 1)
indicatesthattheuserâ€™sactionisrequiredandtheeventshetriggers
will determine which one of the subsequent callbacks is invoked.
Trigger Callback is any Callback in the CCFG that is an im-
mediate predecessor of a Target Callback with only a wait node
between them. For instance, in Listing 1 the Trigger Callbacks for
the Target Callback onClick() areonCreate() (path 1â†’2) and
onItemSelected() (path 5â†’2). Note that onClick() cannot be
theTriggerCallback for DisplayActivity â€™sonCreate() method
(path 3) because there is no wait node between them.
TriggerPoint istheprogrampointthattriggerstheprefetching
of one or more HTTP requests.
3 APROACH
ThissectionpresentsPALOMA,aprefetching-basedsolutionforre-
ducing user-perceived latency in mobile apps that does not require
anydevelopereffortorremoteservermodifications.PALOMAis
motivatedbythefollowingthreechallenges:(1)whichHTTPre-
questscanbeprefetched,(2)whattheirURLvaluesare,and(3)when
to issue prefetching requests. Our guiding insight is that static pro-
gram analysis can help us address all three challenges. To that end,
PALOMAemploysanoffline-onlinecollaborativestrategyshownin
Figure 2. The offline component automatically transforms a mobile
app into a prefetching-enabled app, while the online component
issues prefetching requests through a local proxy.
PALOMAhasfourmajorelements.Itfirstperformstwostatic
analyses: it (1) identifies HTTP requests suitable for prefetching
viastringanalysisand(2)detectsthepointsforissuingprefetching
requests (i.e., Trigger Points) for each identified HTTP request via
callback analysis. PALOMA then (3) instruments the app automati-
callybasedontheextractedinformationandproducesanoptimized,prefetching-enabled app. Finally at runtime, the optimized app will
interact with a local proxy deployed on the mobile device. The
Figure 2: High-level overview of the PALOMA approach
178
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:51:40 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden
Yixue Zhao
 , Marcelo Schmitt Laser
 , Yingjun Lyu
 , Nenad Medvidovic
Figure 3: PALOMAâ€™s detailed workflow. Different analysis
toolsemployedbyPALOMAandartifactsproducedbyitare
depicted, with a distinction drawn between those that are
extensions of prior work and newly created ones.
local proxy (4) issues prefetching requests on behalf of the app andcachesprefetchedresourcessothatfutureon-demandrequestscan
be serviced immediately. We detail these four elements next.
3.1 String Analysis
ThegoalofstringanalysisistoidentifytheURLvaluesofHTTP
requests.PrefetchingcanonlyhappenwhenthedestinationURLof
anHTTPrequestisknown.Thekeytostringanalysisistodiffer-
entiatebetweenstaticanddynamicURLvalues.AstaticURLvalue
is the substring in a URL whose concrete value can be determined
usingconventionalstaticanalysis.Incontrast,adynamicURLvalue
is the substring in a URL whose concrete value depends on user
input. For this reason, we identify the Definition Spots of dynamic
URL values and postpone the actual value discovery until runtime.
AsFigure3shows,theoutputofstringanalysisisaURLMapthat
willbeusedbytheproxyatruntime(Section3.4),andtheDefinition
Spot in the URL Map will be used by the App Instrumentation step
(Section 3.3). The URL Map relates each URL substring with its
concrete value (for static values) or Definition Spots (for dynamic
values). In the example of Listing 1, the entry in the URL Map that
is associated with url2would be
{url2: ["http://weatherapi/", "weather?&cityName=", L7 3,1]}
WenowexplainhowtheURLMapiscreatedforstaticanddynamic
URL values.
Staticvalue analysisâ€“ To interpret the concrete value of each
staticsubstring,wemustfinditsuse-definitionchainandpropagate
the value along the chain. To do that, we leveraged a recent string
analysisframework,Violist[ 24],thatperformscontrol-anddata-
flow analyses to identify the value of a string variable at any given
programpoint.Violistisunabletohandleimplicituse-definition
relationships that are introduced by the Android app development
framework. In particular,in Android, string valuescan be defined
in a resource file that is persisted in the appâ€™s internal storage and
retrievedduringruntime.ForinstanceinListing1,allthreeURLs
have a substring getString("domain") (Lines 12-14), which is
defined in the appâ€™s resource file [ 20]. PALOMA extends Violist to
properlyidentifythiscaseandinclude theappâ€™sresourcefilethat
isextractedbydecompilingtheappinthecontrol-anddata-flow
analysis.Intheend,theconcretevalueofeachstaticsubstringin
each URL is added to the URL Map.Dynamic value analysis â€“ Dynamic URL values cannot be
determinedbystaticanalysis.Instead,PALOMAidentifiesthelo-
cations where a dynamic value is defined,i.e., its Definition Spots.
The DefinitionSpots are later instrumented (see Section 3.3)such
that the concrete values can be determined at runtime.
The key challenge in identifying the Definition Spots is that a
URL string may be defined in a callback different from the callback
where the URL is used. Recall that, due to the event-driven execu-
tion model, callbacks are invoked implicitly by Android. Therefore,
the control flow between callbacks on which the string analysis
depends cannot be obtained by analyzing the app code statically.
Solvingtheinter-callbackdata-flowproblemisoutsidethescope
of this paper. This is still an open problem in program analysis,
because of the implicit control-flow among callbacks as well as the
complex and varied types of events that can trigger callbacks at
runtime, such as GUI events (e.g., clicking a button), system events
(e.g., screen rotation), and background events (e.g., sensor data
changes).Researchefforts onunderstandingcallbacksarelimited
to specific objectives that prevent their use for string analysis in
general.SucheffortshaveincludedafocusrestrictedtoGUI-related
callbacks[ 46,47](whichwedouseinourcallbackanalysis,detailed
in Section 3.2), assumption thatcallback control-flow can be inany
arbitraryorder[ 7],andanalysisoftheAndroidframework-level,
but not app-level, code to construct callback summaries [11, 30].
Tomitigatetheseshortcomings,wedevelopedahybridstatic/dy-
namic approach, where the static part conservatively identifies all
potentialDefinitionSpots,leavingtotheruntimethedetermination
of which ones are the actualDefinition Spots. In particular, we
focusontheDefinitionSpotsofclassfieldsbecauseafieldisacom-
mon wayto passdata between callbacks.We identifyall potential
Definition Spots in two ways. First, if a string variable is a private
memberofaclass,weincludealltheDefinitionSpotsinsidethat
class, such as constructor methods, setter methods, and definitions
in the static block. Second, if a variable is a public member of a
class, that variable can be defined outside the class and we conduct
a whole-program analysis to find all assignments to the variable
that propagate to the URL.
At the end of the analysis, all substring Definition Spots for a
URLareaddedtotheURLMap.Itisworthnotingthatalthoughthe
staticanalysisisconservativeandmultipleDefinitionSpotsmay
berecordedin theURLMap,the trueDefinitionSpotwillemerge
at runtime because false definitions will either be overwritten by a
later true definition (i.e., a classic write-after-write dependency) or
will never be encountered if they lie along unreachable paths.
3.2 Callback Analysis
Callback analysis determines where to prefetch different HTTP
requests,i.e.,theTriggerPointsintheappcode.Theremaybemul-
tiplepossibleTriggerPointsforagivenrequest,dependingonhowfarinadvancetheprefetchingrequestissentbeforetheon-demand
requestisactuallyissued.Themostaggressivestrategywouldbe
toissueanHTTPrequestimmediatelyafteritsURLvalueisdiscov-
ered.However,thisapproachmayleadtomanyredundantnetwork
transmissions:theURLvaluemaynotbeusedinanyon-demand
requests (i.e., it may be overwritten) or the callback containing the
HTTPrequest(i.e.,theTargetCallback)maynotbereachedatrun-
timeatall.Incontrast,themostaccuratestrategywouldbetoissue
179
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:51:40 UTC from IEEE Xplore.  Restrictions apply. Leveraging Program Analysis to Reduce
User-Perceived Latency in Mobile ApplicationsICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden
Algorithm 1: IdentifyTriggerCallbacks
Input:CCFG, ECG, App
Output:TriggerMap
1InstrumentTimestamp (App )
2NetworkMethodLoÐ´s â†Profile (App )
3SiÐ´natureâ†GetFetchSignature (NetworkMethodLoÐ´s )
4Requestsâ†GetReqests (SiÐ´nature )
5TriÐ´Ð´erMap =âˆ…
6foreachreqâˆˆRequestsdo
7tarMethodâ†GetTargetMethod (req )
8TarÐ´etCallbacks â†FindEntries (tarMethod ,ECG )
9foreachtarCallbackâˆˆTargetCallbacks do
10 TriÐ´Ð´erCallbacks â†
GetImdiatePredecessors (tarCallback ,CCFG )
11 foreachtriÐ´CallbackâˆˆTriggerCallbacks do
12 TriÐ´Ð´erMap .Add (triÐ´Callback ,req .url )
13returnTriÐ´Ð´erMap
the prefetching request right before the on-demand request is sent.
However, this strategy would yield no improvement in latency.
Ourapproachistostrikeabalancebetweenthetwoextremes.
Specifically, PALOMA issues prefetching requests at the end of the
callbackthatis theimmediatepredecessoroftheTargetCallback.
RecallfromSection2thatwerefertotheTargetCallbackâ€™simmedi-
atepredecessorasTriggerCallback,becauseittriggersprefetching.
Thisstrategyhasthedualbenefitof(1)takingadvantageoftheâ€œuser
thinktimeâ€betweentwoconsecutivecallbackstoallowprefetching
to take place, while (2) providing high prefetching accuracy as the
Trigger Point is reasonably close to the on-demand request.
AsFigure3shows,PALOMAcreatesaTriggerMapattheendof
callback analysis that is used by app instrumentation (Section 3.3).
The Trigger Map maps each Trigger Callback to the URLs that will
beprefetchedattheendofthatcallback.IntheexampleofListing1,
the Trigger Map will contain two entries:
{[onCreate]: [url1, url2,url3]}
{[onItemSelected]: [url1, url2,url3]}
becauseboth onCreate() andonItemSelected() areTriggerCall-
backsthataretheimmediatepredecessorsoftheTargetCallback
onClick(), which in turn contains url1,url2, and url3.
Algorithm1detailshowPALOMAidentifiesTriggerCallbacks
and constructs the Trigger Map. In addition to the app itself, the al-
gorithmreliesontwoadditionalinputs,bothobtainedwiththehelp
ofoff-the-shelf-tools:theCallbackControl-FlowGraph(CCFG)[ 46]
and the Call Graph (CG) [ 37]. Note that the CCFG we use in our
callback analysis is restricted to GUI callbacks that are triggeredby user actions (recall Section 2). However, this fits PALOMAâ€™s
needsgivenitsfocusonuser-initiatednetworkrequests.TheCCFG
captures the implicit-invocation flow of Callbacks in Android, and
thus allows us to find the Trigger Callbacks of a given Target Call-
back.Ontheotherhand,theCG,whichisextractedbySoot[ 37],
captures the control flow between functions, and thus allows usto locate the Callbacks that contain any given method. However,
the CG does not include the direct invocations that are initiated
from the Android framework. We identified such invocations from
Androidâ€™s documentation and extended the CG with the resultingdirect edges. An example is the execute()â†’doInBackground()
edgefromthe AsyncTask class[16]thatiswidelyusedfornetwork
operations in Android. We refer to the thus extended CG as ECG.
Giventheseinputs,PALOMAfirstidentifiesthesignatureofa
Fetch Spot, i.e., the method that issues HTTP requests, by profiling
theapp(Lines1-3ofAlgorithm1).Wefoundthattheprofilingis
needed because the methods that actually issue HTTP requestsunder different circumstances can vary across apps. For exam-
ple, the
getInputStream() method from Javaâ€™s URLConnection
library may consume hundreds of milliseconds in one app, but
zeroinanotherappwhere,e.g.,the getResponseCode() method
consumesseveralhundredmilliseconds.1Thus,weobtainthesigna-
tures by instrumenting timestamps in the app, and select the most
time-consuming network operations according to our profiling re-
sults. Using the signatures, we then identify all HTTP requeststhat the app can possibly issue (Line 4). In the example of List-
ing1,thesignaturewouldbe getInputStream() andtheRequests
would be conn1.getInputStream() ,conn2.getInputStream() ,
andconn3.getInputStream() . We iterate through each discov-
ered request and identify the method in which the request is actu-
ally issued, i.e., the Target Method (Line 7). Using the control flow
information that the ECG provides, we locate all possible Target
CallbacksofaTargetMethod(Line8).Wetheniteratethrougheach
Target Callback and identify all of its immediate predecessors, i.e.,
TriggerCallbacks,accordingtotheCCFG(Line10).Finally,weadd
each {Trigger Callback, URL} pair to the Trigger Map (Lines 11-12).
3.3 App Instrumentation
PALOMA instruments an app automatically based on the infor-
mation extracted from the two static analyses, and produces an
optimized, prefetching-enabled app as Figure 3 shows. At runtime,
the optimized app will interact with a local proxy that is in charge
of issuing prefetching requests and managing the prefetched re-sources (Section 3.4). While PALOMAâ€™s app instrumentation isfully automated and it does not require the source code of the
app,PALOMA also supports appdevelopers whohave theknowl-
edge and the source code of the app to further improve runtime
latencyreductionviasimpleprefetchinghints.Wedescribethetwo
instrumentation aspects next.
3.3.1 Automated Instrumentation
PALOMAperformsthreetypesofinstrumentationautomatically.
Each type introduces a new API that we implement in an instru-
mentationlibrary.Listing2showsaninstrumentedversionofthe
app from Listing 1, with the instrumentation code bolded. We will
use this example to explain the three instrumentation tasks.
1. Update URL Map â€“ This instrumentation task updates the
URL Map as new values of dynamic URLs are discovered. Recall
thatthevaluesof staticURLsarefullydeterminedandinsertedinto
theURLMapoffline.Thisinstrumentationisachievedthrougha
newAPI, sendDefinition(var, url, id) ,whichindicatesthat
varcontains the value of the idthsubstring in the URL named
url.TheresultingannotationisinsertedrightaftereachDefinition
Spot. Forinstance atLine 8of Listing 2,PALOMA will updatethe
1In this paper, we focus on URLConnection , a built-in Java standard library widely
used by Android developers. If the developer is using a different library and/or knows
which method(s) to optimize, then PALOMAâ€™s profiling step may not be needed.
180
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:51:40 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden
Yixue Zhao
 , Marcelo Schmitt Laser
 , Yingjun Lyu
 , Nenad Medvidovic
thirdsubstringin url2withtheruntimevalueof cityName .This
ensuresthattheURLMapwillmaintainafreshcopyofeachURLâ€™s
value and will be updated as soon as new values are discovered.
2. Trigger Prefetching â€“ This instrumentation task triggers
prefetching requests at each Trigger Point. A Trigger Point in
PALOMA is at the end of a Trigger Callback. We made this choice
for two reasons: on one hand, it makes no discernible difference in
terms of performance where we prefetch within the same callback;
on the other hand, placing the Trigger Point at the end is more
likelytoyieldknownURLs(e.g.,whentheDefinitionSpotisalso
within the Trigger Callback). PALOMA provides this instrumen-
tation via the triggerPrefetch(url1, ...) API. The URLsthat
aretobeprefetchedareobtainedfromtheTriggerMapconstructed
in the callback analysis (recall Section 3.2). For instance, PALOMA
triggers the proxy to prefetch url1,url2, andurl3at the end of
onItemSelected() (Line9)and onCreate() (Line26)ofListing2,
which is consistent with the Trigger Map built in Section 3.2.
3. Redirect Requests â€“ This instrumentation task redirects all
on-demand HTTP requests to PALOMAâ€™s proxy instead of the
origin server. This allows on-demand requests to be served fromtheproxyâ€™scache,withoutlatency-inducingnetworkoperations.
Thecaseswheretheproxyâ€™scachedoesnotcontaintheresponse
to a request are discussed in Section 3.4. The request redirection
is achieved through the fetchFromProxy(conn) API, where conn
indicates the original URL connection, which is passed in case the
proxystillneedstomaketheon-demandrequesttotheoriginserver.
ThisinstrumentationreplacestheoriginalmethodsateachFetch
Spot:callstothe getInputStream() methodatLines16,18,and20
ofListing 1arereplacedwith callstothe fetchFromProxy(conn)
method at Lines 19, 21, and 23 in Listing 2.
3.3.2 Developer Hints
AlthoughPALOMAcanautomaticallyinstrumentmobileappswith-
out developer involvement, it also provides opportunities for de-
velopers to add hints in order to better guide the prefetching. In
particular,PALOMAenablestwowaysfordeveloperstoprovide
1classMainActivity {
2String favCityId, cityName, cityId;
3protected void onCreate(){
4 favCityId = readFromSetting("favCityId");//static
5 cityNameSpinner.setOnItemSelectedListener(new OnItemSelectedListener(){
6 public void onItemSelected() {
7 cityName = cityNameSpinner.getSelectedItem().toString();//dynamic
8 sendDefinition(cityName, url2, 3);
9 triggerPrefetch(url1, url2, url3);
10 }});
11 submitBtn.setOnClickListener(new OnClickListener(){
12 public void onClick(){
13 cityId = cityIdInput.getText().toString();//dynamic
14 sendDefinition(cityId, url3, 3);
15 URL url1 = newURL(getString("domain")+"weather?&cityId="+favCityId);
16 URL url2 = newURL(getString("domain")+"weather?cityName="+cityName);
17 URL url3 = newURL(getString("domain")+"weather?cityId="+cityId);
18 URLConnection conn1 = url1.openConnection();
19 Parse(fetchFromProxy(conn1));
20 URLConnection conn2 = url2.openConnection();
21 Parse(fetchFromProxy(conn2));
22 URLConnection conn3 = url3.openConnection();
23 Parse(fetchFromProxy(conn3));
24 startActivity(DisplayActivity.class);
25 }});
26 triggerPrefetch(url1, url2, url3);
27 }
28}
Listing 2: Example code of the optimized apphints: by using its instrumentation APIs and by directly modifying
its artifacts. These two approaches are described below.
APIsupportâ€“ PALOMAâ€™sthreeAPIfunctionsdefinedinthein-
strumentationlibraryâ€” sendDefinition() ,triggerPrefetch() ,
andfetchFromProxy() â€”can be invoked by the developers explic-
itlyintheappcode.Forinstance,ifadeveloperknowswherethe
true Definition Spots are, she can invoke sendDefinition() at
those locations. Developers can also invoke triggerPrefetch()
at any program point. For example, prefetching can happen fartheraheadthanisdoneautomaticallybyPALOMAifadeveloperknows
thattheresponsestoaprefetchingrequestanditscorresponding
on-demand request will be identical.
Artifact modification â€“ Using PALOMAâ€™s instrumentation
APIs in themanner described aboverequires modifications to the
appsourcecode.Analternativeistodirectlymodifytheartifacts
generated by PALOMAâ€™s static analysesâ€”Trigger Map, Fetch Spot
Signature,andDefinitionSpot(recallFigure3)â€”withoutaltering
the code. For example, a developer can add an entry in the Trigger
Map; as a result, PALOMAâ€™s instrumenter will automatically insert
a call totriggerPrefetch() at the end of the Trigger Callback
specified by the developer.
We now introduce two frequently occurring instances where
developers are well positioned to provide prefetching hints with
verylittle manualeffort. Thesehints canbe providedusing either
of the above two approaches.
Prefetching at app launch â€“ Launching an app may take sev-
eral seconds or more because many apps request remote resources,
typically toward the end of the launch process. The URLs of the
launch-time requests are usually statically known, but the ways in
whichtheURLvaluescanbeobtainedarehighlyapp-dependent.
For instance, apps may retrieve the request URLs from a configura-
tionfileoralocaldatabase.SupportingthosecasesinPALOMAâ€™s
string analysis would mean that PALOMA must understand the
semanticsofeachindividualapp,whichisnotareasonablerequire-
ment. However, a practical alternative is for developers to provide
prefetching hints because they understand their own appsâ€™ behav-
ior. One way developers could implement this is to insert into the
URLMapadditionalstaticURLsandthencall triggerPrefetch()
at the beginning of onCreate() , which for PALOMAâ€™s purposes
can be treated as the app entry point in most Android applications.
Prefetching for ListView â€“ TheListView class [19] is com-
monly used in Android apps to display the information of a list of
items. The app â€œjumpsâ€ to another page to display further informa-
tionbasedontheitemauserselectsinthelist.TheURLfetchedfor
the page to which the app â€œjumpsâ€ is typically only known after
theuserselectstheiteminthelist.Ordinarily,thiswouldprevent
prefetching. However, Android apps tend to exhibit two helpful
trends. First, the list view usually displays similar types of informa-tion. Second, the further information obtained by selecting an item
is related to the information displayed in the list itself. Based on
these observations, we identified and are exploiting in PALOMAsimilarpatternsintheURLsforthelistandthesubsequentpage.
Considera wallpaperappforillustration: TheURLthatis fetched
to render an item in the list view may be â€œimage1Url_small.jpgâ€,
while the URL that is fetched after the user selects image1may
be â€œimage1Url_large.jpgâ€. Based on this pattern, we have explored
manuallyaddingDefinitionSpotsoftheURLsthatarefetchedin
181
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:51:40 UTC from IEEE Xplore.  Restrictions apply. Leveraging Program Analysis to Reduce
User-Perceived Latency in Mobile ApplicationsICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden
Algorithm 2: TriggerPrefetch
Input:Requests
1foreachreqâˆˆRequestsdo
2ifIsKnown (req .url )andÂ¬IsCached (req )then
3 SetWaitFlag (req )
4 responseâ†req .FetchRemoteResponse ()
5 cache .Put (req ,response )
6 UnWait (req )
the list view and sending modified values to the proxy, such as
replacing â€œsmallâ€ with â€œlargeâ€ in the wallpaper example.
3.4 Runtime Prefetching
PALOMAâ€™s first three phases are performed offline. By contrast,
this phase captures the interplay between the optimized apps and
PALOMAâ€™sproxytoprefetchtheHTTPrequestsatruntime.The
instrumented methods in an optimized app trigger the proxy to
performcorrespondingfunctions.Wenowusetheexamplefrom
Listing 2 to show how the three instrumented functions from Sec-
tion 3.3.1 interact with the proxy.
1.UpdateURLMapâ€“ Whentheconcretevalueofthe dynamic
URLisobtainedatruntime,theinsertedinstrumentationmethod
sendDefinition(var, url, id) isexecutedandtheconcreterun-
time value is sent to the proxy. In response, the proxy updates the
correspondingURLvalueintheURLMap.ForinstanceinListing2,
whenauserselectsacitynamefromthe cityNameSpinner (Line7),
the concrete value of cityName will be known, e.g., â€œGothenburgâ€.
ThencityName issenttotheproxy(Line8)andtheURLMapen-
tryforurl2willbeupdatedto{ url2: ["http://weatherapi/",
"weather?&cityName=","Gothenburg"] }.
2. Trigger Prefetching â€“ Whentheinsertedinstrumentation
methodtriggerPrefetch(url1,...) isexecuted,ittriggersthe
proxy to perform TriggerPrefetch as shown in Algorithm 2.For each request that is sent to the proxy by
triggerPrefetch
(url1,...) , the proxy checks if the whole URL of the request is
knownbuttheresponsetotherequesthasnotyetbeencached(Line
2).Ifbothconditionsaremet,aâ€œwaitâ€flagissetinthecacheforthat
request(Line3).Thisensuresthatduplicatedrequestswillnotbe
issuedinthecasewhentheon-demandrequestismadebytheuser
beforetheresponsetotheprefetchingrequesthasbeenreturned
fromtheoriginserver.IntheexampleofListing2,whentheapp
reaches the end of onCreate (Line 26), it triggers the proxy to per-
formTriggerPrefetch(url1,url2,url3) .Onlyurl1meetsboth
conditionsatLine2ofAlgorithm2:theURLvalueisconcrete(itis,infact,astaticvalue)andtheresponseisnotinthecache.Theproxy
thussetstheâ€œwaitâ€flagfor
url1inthecache,prefetches url1from
theoriginserver,storestheresponseinthecache,andfinallysends
an â€œunwaitâ€ signal to the on-demand request that is waiting for
the prefetched request (Line 3-6). Thereafter, when the user selects
a city name from the dropdown box, onItemSelected (Line 6 of
Listing2)willbetriggered.Attheendof onItemSelected (Line9),
TriggerPrefetch(url1,url2,url3) is invoked again and url2
will be prefetched because its URL is known (its dynamic value
obtained at Line 8) and has not been previously prefetched. In con-
trast,thevalueof url1isknownatthispointbut url1wasalready
prefetched at Line 26, so the proxy will not prefetch url1.Algorithm 3: ReplacedFetch
Input:reqâˆˆRequests
Output:responseâˆˆResponses
1ifIsCached (req )then
2ifGetWaitFlag (req )isTRUEthen
3 Wait (req )
4returncache .GetResponse (req)
5else
6responseâ†req .FetchRemoteResponse ()
7cache .Put (req ,response )
8returnresponse
3. Redirect Requests â€“ Whentheon-demandrequestissent
at the Fetch Spot, the replaced function fetchFromProxy(conn)
will be executed, and it will in turn trigger the proxy to perform
ReplacedFetch as shown in Algorithm 3. If the request has a
corresponding response in the cache, the proxy will first check the
â€œwaitâ€ flag for the request. If the flag is set, the proxy will wait for
the signal of the prefetching request (Line 3) and will return the
response of the prefetching request when it is back from the origin
server(Line4).Iftheâ€œwaitâ€flaghasnotbeenset,theresponseis
alreadyinthecacheandtheproxyreturnstheresponseimmediately
with no network operations involved (Line 4). Otherwise, if the
cachedoesnotcontaintheresponsetotherequest,theproxyissues
anon-demandrequestusingtheoriginalURLconnection connto
fetchtheresponsefromtheoriginserver,storestheresponseinthe
cache,andreturnstheresponsetotheapp(Line6-8).Forinstancein
Listing 2, if a user clicks submitBtn ,fetchFromProxy(conn) will
beexecutedtosendon-demandrequestsfor url1,url2,url3tothe
proxy (Lines 19, 21, and 23 of Listing 2). The proxy in turn returns
theresponsesto url1andurl2fromthelocalcacheimmediately
becauseurl1andurl2areprefetchedatLines26and9respectively,
as discussed above. url3is not known at any of the Trigger Points,
sotheresponseto url3willbefetchedfromtheoriginserveron
demand as in the original app. Note that if a user did not select
a city name from the dropdown box before clicking submitBtn ,
onItemSelected will not be triggered, meaning that Lines 8 and 9
of Listing 2 will not be executed. In this case, only the response for
url1will be returned from the cache (prefetched at Line 26) while
the on-demand requests for url2andurl3will be routed to the
origin server.
4 IMPLEMENTATION
PALOMA has been implemented by reusing and extending several
off-the-shelf tools,and integrating them withnewly implemented
functionality.PALOMAâ€™sstringanalysisextendsthestringanalysis
framework Violist [ 24]. The callback analysis is implemented on
top of the program analysis toolkit GATOR [ 33], and by extending
GATORâ€™s CCFG analysis [ 46]. PALOMAâ€™s instrumentation compo-
nentisastand-aloneJavaprogramthatusesSoot[ 37]toinstrument
an app. The proxy is built on top of the Xposed framework [ 5] that
provides mechanisms to â€œhookâ€ method calls. The proxy interceptsthemethodsthataredefinedinPALOMAâ€™sinstrumentationlibrary
andreplacestheirbodieswithcorrespondingmethodsimplemented
intheproxy.Thetotalamountofnewlyaddedcodetoextendex-
istingtools,implementthenewfunctionality,andintegratethem
together in PALOMA is 3,000 Java SLOC.
182
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:51:40 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden
Yixue Zhao
 , Marcelo Schmitt Laser
 , Yingjun Lyu
 , Nenad Medvidovic
5 MICROBENCHMARK EVALUATION
Inthissection,wedescribethedesignofamicrobenchmark(MBM)
containingasetoftestcases,whichweusedtoevaluatePALOMAâ€™s
accuracy andeffectiveness.
MBMthoroughlycoversthespaceofprefetchingoptions,wherein
eachtestcasecontainsasingleHTTPrequestanddiffersinwhether
and how that request is prefetched. The MBM is restricted to indi-
vidualHTTPrequestsbecausetherequestsareissuedandprocessed
independently of one another. This means that PALOMA will pro-
cess multiple HTTP requests simply as a sequence of individual
requests;anyconcurrencyintheirprocessingthatmaybeimposed
bythenetworklibraryand/ortheOSisoutsidePALOMAâ€™spurview.
Inpractice,thelook-uptimeformultiplerequestsvariesslightly
from one execution of a given app to the next. However, as shown
inSection5.3,thelook-uptimerequiredbyPALOMAwouldnotbe
noticeabletoauserevenwithalargenumberofrequests.Aswe
willshowinSection6,thenumberofHTTPrequestsinrealapps
istypicallybounded.Moreover,PALOMAonlymaintainsasmall
cache that is emptied every time a user quits the app.
Intherestofthissection,wewillfirstlayoutthegoalsunder-
lyingtheMBMâ€™sdesign(Section5.1),andthenpresenttheMBM
(Section5.2).OurevaluationresultsshowthatPALOMAachieves
perfectaccuracywhenappliedontheMBM,andleadstosignificant
latency reduction with negligible runtime overhead (Section 5.3).
5.1 Microbenchmark Design Goals
The MBM is designed to evaluate two fundamental aspects of
PALOMA: accuracy andeffectiveness.
PALOMAâ€™s accuracy pertainstothe relationshipbetween pre-
fetchable and actually prefetched requests. Prefetchable requests
arerequests whoseURLvalues areknownbefore theTriggerPoint
and thus can be prefetched. Quantitatively, we capture accuracy
via the dual measures of precision andrecall. Precision indicates
howmanyoftherequeststhatPALOMAtriestoprefetchatagiven
Trigger Point were actually prefetchable. On the other hand, recall
indicates howmany requestsare actuallyprefetched byPALOMA
out of all the prefetchable requests at a given Trigger Point.
PALOMAâ€™s effectiveness is also captured by two measures:
the runtime overhead introduced by PALOMA and the latency
reduction achieved by it. Our objective is to minimize the runtime
overheadwhilemaximizingthereductioninuser-perceivedlatency.
5.2 Microbenchmark Design
The MBM is built around a key conceptâ€”prefetchable â€”a request
whose whole URL is known before a given Trigger Point. We refer
to the case where the request is prefetchable and the response is
usedbytheappasa hit.Alternatively,arequestmaybeprefetchable
but the response is not used because the definition of the URL is
changedaftertheTriggerPoint.Wecallthisa non-hit.TheMBM
aimstocoverallpossiblecasesof prefetchable andnon-prefetchable
requests, including hitandnon-hit.
TherearethreefactorsthataffectwhetheranHTTPrequestis
prefetchable: (1) the number of dynamic values in a URL; (2) the
number of Definition Spots for each dynamic values; and (3) the
locationofeachDefinitionSpotrelativetotheTriggerPoint.We
nowformallydefinethepropertiesof prefetchable andhitconsider-
ingthethreefactors.Theformaldefinitionswillletussuccinctly
describe test cases later.










  






 

 




 
 


  






 



 
Figure 4: The 24 test cases covering all configurations in-
volvingdynamicvalues.Thehorizontaldividerdenotesthe
Trigger Point, while the vertical divider delimits the two
dynamic values. The circles labeled with â€œDS i,jâ€ are the lo-
cations of the Definition Spots with respect to the Trigger
Point. â€œHâ€ denotes a hit, â€œNHâ€ denotes a non-hit, and â€œNPâ€
denotes a non-prefetchable request.
FormalDefinition. LetMbe the set of Definition Spots before
theTriggerPointand NthesetofDefinitionSpotsaftertheTrigger
Point, which is within the Target Callback (recall Sections 2 and
3.2). Let us assume that a URL has kâ‰¥1 dynamic values. (The case
where k=0, i.e., the whole URL is static, is considered separately.)
Furthermore, let us assume that the dynamic values are the first k
valuesintheURL.2Theithdynamicvalue(1â‰¤iâ‰¤k)has diâ‰¥1
Definition Spots in the whole program. A request is
â€¢prefetchable iffâˆ€iâˆƒ(jâˆˆ[1..di])|DefSpoti,jâˆˆM
(every dynamic value has a DefSpot before Trigger Point)
â€¢hitiffprefetchableâˆ§âˆ€(jâˆˆ[2..di])|DefSpoti,jâˆˆM
(all dynamic value DefSpots are before Trigger Point)
â€¢non-hitiffprefetchableâˆ§âˆƒ(jâˆˆ[2..di])|DefSpoti,jâˆˆN
(some dynamic value DefSpots are after Trigger Point)
â€¢non-prefetchable iffâˆ€(jâˆˆ[1..di])âˆƒi|DefSpoti,jâˆˆN
(all DefSpots for a dynamic value are after Trigger Point)
Without loss of generality, MBM covers all cases where kâ‰¤2
anddiâ‰¤2.Wedonotconsidercaseswhere k>2ordi>2because
we only need two dynamic values to cover the non-prefetchable
caseâ€”where some dynamic values are unknown at the Trigger
Pointâ€”and twoDefinition Spots tocover the non-hitcaseâ€”where
some dynamic values are redefined after the Trigger Point.
2Thisassumptionisusedonlytosimplifyourformalization.Theorderofthevalues
in a URL has no impact on whether the URL is prefetchable and can thus be arbitrary.
183
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:51:40 UTC from IEEE Xplore.  Restrictions apply. Leveraging Program Analysis to Reduce
User-Perceived Latency in Mobile ApplicationsICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden
There are a total of 25 possible cases involving configurations
with kâ‰¤2 and diâ‰¤2. The simplest case is when the entire URL is
knownstatically;werefertoitascase0.Theremaining24cases
are diagrammatically encoded in Figure 4: the two dynamic URL
valuesaredepictedwithcirclesanddelimitedwiththeverticalline;
thelocationoftheTriggerPointisdenotedwiththehorizontalline;
andtheplacementofthecirclesmarksthelocationsofthedynamic
valuesâ€™DefinitionSpots(â€œDS i,jâ€inthefigure)withrespecttothe
Trigger Point. These 24 cases can be grouped as follows:
â€¢single dynamic value â€“ cases 1-5;
â€¢two dynamic values, one Definition Spot each â€“ cases 6-9;
â€¢twodynamicvalues,onewithasingleDefinitionSpot,the
other with two â€“ cases 10-15; and
â€¢two dynamic values, two definition spots each â€“ cases 16-24.
Eachcaseislabeledwithits prefetchable/hit property(â€œHâ€for hit,
â€œNHâ€for non-hit,andâ€œNPâ€for non-prefetchable ).Ofparticularin-
terestarethesixcasesâ€”0,1,3,6,10,and16â€”thatrepresentthe hits
that should allow PALOMA to prefetch the corresponding requests
and hence significantly reduce the user-perceived latency.
5.3 Results
We implemented the MBM as a set of Android apps along with the
remoteservertotesteachofthe25cases.Theserverisbuiltwith
Node.jsanddeployedontheHerokucloudplatform[3].Theapps
interact with the server to request information from a dataset in
MongoDB[ 4].Theevaluationwasperformedonthe4Gnetwork.
ThetestingdevicewasGoogleNexus5XrunningAndroid6.0.Over-
all, our evaluation showed that PALOMA achieves 100% precision
andrecallwithoutexception,introducesnegligibleoverhead,and
can reduce the latency to nearly zero under appropriate conditions
(thehitcases discussed above).
Table 1 shows the results of each test case corresponding to
Figure 4, as well as case 0 in which the entire URL value is known
statically.Eachexecutionvalueistheaverageofmultipleexecutionsof the corresponding MBM apps. The highlighted test cases are the
hitcases that should lead to a significant latency reduction. The
columnsâ€œSDâ€,â€œTPâ€,andâ€œFFPâ€showtheaveragetimesspentinthecorrespondingPALOMAinstrumentationmethodsintheoptimized
appsâ€”sendDefinition() ,triggerPrefetch() , andfetchFrom-
Proxy(),respectively(recallSection3.3).Theâ€œOrigâ€columnshows
the execution time of the method invoked at the Fetch Spot in the
original app, such as getInputStream().
Thefinalcolumninthe table,labeledâ€œRed/OHâ€showstheper-
centagereductionin executiontimewhenPALOMAisappliedon
eachMBMapp.Thereductionismassiveineachofthesix hitcases
(â‰¥99%).ItwasinterestingtoobservethatapplyingPALOMAalso
resulted in reduced average execution times in 11 of the 19 non-hit
andnon-prefetchable cases.Themoreexpectedscenariooccurredin
theremainingeightofthe non-hitandnon-prefetchable cases:apply-
ingPALOMAintroducedanexecutionoverhead(shownasnegative
values in the table). The largest runtime overhead introduced by
PALOMAwas149msincase11,wheretheoriginalresponsetime
was 2,668ms. This value was due to a couple of outliers in comput-
ingtheaverageexecutiontime,anditmaybeattributabletofactors
inourevaluationenvironmentotherthanPALOMA,suchasnet-
work speed; the remaining measurements were significantly lower.
However, even this value is actually not prohibitively expensive:
recallthatPALOMAisintendedtobeappliedincasesinwhichaTable 1: Results of PALOMAâ€™s evaluation using MBM apps
covering the 25 cases discussed in Section 5.2. â€œSDâ€, â€œTPâ€,
andâ€œFFPâ€denotetheruntimesofthethreePALOMAinstru-
mentation methods. â€œOrigâ€ is the time required to run theoriginal app. â€œRed/OHâ€ represents the reduction/overhead
in execution time when applying PALOMA.
CaseSD (ms) TP (ms) FFP (ms) Orig (ms) Red/OH
0N/A 2 1 1318 99.78%
1 0 5 0 15495 99.97%
2 0 1 2212 2659 16.81%
3 1 4 1 781 99.24%
4 2 5 611 562 -9.96%
5 0 2 2588 2697 3.97%
6 1 4 2 661 98.95%
7 1 4 2237 2399 6.54%
8 1 9 585 568 4.75%
9 2 2 611 584 -5.31%
10 1 5 0 592 98.99%
11 2 2 2813 2668 -5.58%
12 2 6 546 610 8.16%
13 2 3 2478 2753 10.87%
14 3 3 549 698 20.49%
15 5 1 631 570 -11.75%
16 1 11 0 8989 99.87%
17 0 3 418 555 31.83%
18 2 6 617 596 -4.87%
19 4 6 657 603 -10.61%
20 1 3 620 731 17.15%
21 2 10 611 585 -6.50%
22 2 7 737 967 29.62%
23 2 9 608 607 -1.98%
24 1 10 611 715 14.95%
useralreadytypicallyspendsmultiplesecondsdecidingwhatevent
to trigger next [26].
6 THIRD-PARTY APP EVALUATION
WealsoevaluatedPALOMAonthird-partyAndroidappstoobserve
its behavior in a real-world setting. We used the same execution
setup as in the case of the MBM. We selected 32 apps from the
GooglePlaystore[1].We madesurethattheselectedappsspana
rangeofapplicationcategoriesâ€”Beauty,Books&Reference,Educa-
tion, Entertainment, Finance, Food & Drink, House & Home, Maps
&Navigation,Tools,Weather,News&Magazines,andLifestyleâ€”
and vary in sizesâ€”between 312KB and 17.8MB. The only other
constraints in selecting the apps were that they were executable,
relied on the Internet, and could be processed by Soot.3
We asked two Android users to actively use the 32 subject apps
for two minutes each, and recorded the resulting usage traces.4
We then re-ran the same traces on the apps multiple times, to
accountforvariationscausedbytheruntimeenvironment.Then
weinstrumentedtheappsusingPALOMAandrepeatedthesame
steps the same number of times. Each session started with app
(re)installation and exposed all app options to users. As in the case
of the MBM, we measured and compared the response times of
3SootisoccasionallyunabletoprocessanAndroidappforreasonsthatwewereunable
to determine. This issue was also noted by others previously.
4While the average app session length varies by user and app type (e.g., [ 2]), two
minutes was sufficiently long to observe representative behavior and, if necessary, to
extrapolate our data to longer sessions.
184
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:51:40 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden
Yixue Zhao
 , Marcelo Schmitt Laser
 , Yingjun Lyu
 , Nenad Medvidovic
Table2:Resultsof PALOMAâ€™sevaluationacrossthe32third-
party apps.
Min. Max. Avg.Std. Dev.
Runtime Requests 16413.28 14.41
Hit Rate 7.7% 100%47.76% 28.81%
Latency Reduction 87.41% 99.97% 98.82% 2.3%
the methods at the Fetch Spots between the original and optimized
apps.
UnlikeinthecaseoftheMBM,wedonothavetheground-truth
data for the third-party apps. Specifically, the knowable URLs at
theTriggerPointswouldhavetobedeterminedmanually,whichis
prohibitivelytime-consuminganderrorprone.Infact,thiswould
boildowntomanuallyperforminginter-callbackdata-flowanalysis
(recall Section 3.1). For this reason, we measured only two aspects
of applying PALOMA on the third-party apps: the hit rate(i.e.,
thepercentage ofrequests thathave been hitoutof alltriggered
requests) and the resulting latency reduction . Table 2 depicts the
averages, outliers (min and max values), as well as the standard
deviations obtained across all of the runs of the 32 apps.
Overall, the results show that PALOMA achieves a significant
latency reduction with a reasonable hit rate. There are several
interestingoutliercases.Theminimumhit-rateisonly7.7%.The
reason is that the app in question fetches a large number of ads
at runtime whose URLs are non-deterministic, and only a single
static URL is prefetched outside those. There are four additional
apps whosehit rateis below20% becausethose appsare list-view
apps, such as a wallpaper app (recall Section 3.3), and they fetch
largenumbersofrequestsatthesametime.InPALOMA,wesetthe
threshold for the maximum number of requests to prefetch at once
tobe5.Thisparametercanbeincreased,butthatmayimpactdeviceenergyconsumption,cellulardatausage,etc.Thisisatrade-offthat
will require further study.
SimilarlytotheMBMevaluation,PALOMAachievesareduction
in latency of nearly 99% on average for â€œhitâ€ cases. Given the av-
erage execution time for processing a single request across the 32
unoptimizedappsofslightlyover800ms,prefetchingtheaverageof
13.28requestsatruntimewouldreducethetotalappexecutiontime
by nearly 11s, or 9% of a two-minute session. Note that the low-
estlatencyreduction was87.41%.Thiswas caused byon-demand
requests that happen before the prefetching request is returned
(recallthediscussioninSection3.4).Inthosecases,theresponse
time depends on the remaining wait time for the prefetching re-
questâ€™s return. However, there were only 5 such â€œwaitâ€ requests
among425totalrequestsinthe32apps.Thisstronglysuggeststhat
PALOMAâ€™schoicefortheplacementofTriggerPointsiseffective
in practice.
7 RELATED WORK
Prefetching of HTTP requests has been applied successfully in
the browser domain [ 26,27,38,39]. Unfortunately, approaches
targeting page load times cannot be applied to mobile apps. The
bottleneckforpageloadtimesisresourceloading[ 41],becauseone
initialHTTPrequestwillrequirealargenumberofsubresources
(e.g.,images),whichcanonlybediscoveredafterthemainsourceis
fetched and parsed. Thus, existing research efforts have focused onissues such as prefetching subresources [
34,42], developer support
for speculative execution [ 26], and restructuring the page loadprocess[39].Inmobileapps,theHTTPrequestsarealwayslight-
weight [23]: one request only fetches a single resource that does
not require any further subresource fetching. Therefore, our work
focusesonprefetching thefuturerequeststhat ausermaytrigger
rather than the subresources within a single request.
Researchers have recently begun exploring prefetching in the
mobile app domain. One research thread has attempted to answer
â€œhow muchâ€ to prefetch under different contexts (e.g., network
conditions)[ 10,21,48],while assumingthat â€œwhatâ€toprefetch is
handledbytheappsalready.Anotherthreadofworkfocusesonfast
prelaunchingbytryingtopredictwhatapptheuserwillusenext[ 8,
29,45].Bycontrast,ourworkaimstoprovideanautomatedsolution
to determine â€œwhatâ€ and â€œwhenâ€ to prefetch for a given app in a
generalcase.Asdiscussedpreviously,othercomparablesolutionsâ€”
server-based [13, 28, 34], human-based [25,26], history-based [14,22
,28,36,43],anddomain-based[ 9,40,44]â€”havelimitationswhich
we directly target in PALOMA.
To the best of our knowledge, PALOMA is the first technique to
apply program analysis to prefetching HTTP requests in mobile
apps in order to reduce user-perceived latency. Bouquet [ 23] has
applied program analysis techniques to bundle HTTP requests
in order to reduce energy consumption in mobile apps. Bouquet
detectsSequential HTTP Requests Sessions (SHRS), in which the
generationofthefirstrequestimpliesthatthefollowingrequests
willalsobemade,andthenbundlestherequeststogethertosave
energy. This can be considered a form of prefetching. However,
this work does not address inter-callback analysis and the SHRS
arealwaysinthesame callback.Therefore,theâ€œprefetchingâ€only
happensafewstatementsahead(withinmillisecondsmostofthe
time) and has no tangible effect on app execution time.
8 CONCLUSION AND FUTURE WORK
WehavepresentedPALOMA,anovelprogramanalysis-basedtech-
nique that reduces the user-perceived latency in mobile apps by
prefetching certain HTTP requests. While PALOMA cannot be ap-
plied to all HTTP requests an app makes at runtime, it provides
significant performance savings in practice. Several of PALOMAâ€™s
current facets make it well suited for future work in this area, both
byusandbyothers.Forinstance,PALOMAdefinesformallythe
conditions under which the requests are prefetchable. This can
leadtoguidelinesthatdeveloperscouldapplytomaketheirapps
more amenable to prefetching, and lay the foundations for fur-
ther program analysis-based prefetching techniques. We have also
identifiedseveralshortcomingstoPALOMAwhoseremedymust
include improv ements to stringanalysis and callback analysistech-
niques.Anotherinterestingdirectionistoimprovetheprecision
and reduce the waste associated with prefetching by incorporating
certain dynamic information (e.g., user behavior patterns, runtime
QoSconditions).Finally,PALOMAâ€™smicrobenchmark(MBM)forms
afoundationforstandardizedempiricalevaluationandcomparison
of future efforts in this area.
9 ACKNOWLEDGMENT
We would like to thank William G.J. Halfond, Atanas Rountev,
YuhaoZhu,andtheirresearchgroups.Thisworkissupportedby
theU.S.NationalScienceFoundationundergrantsno.CCF-1618231
and CCF-1717963, U.S. Office of Naval Research under grant no.
N00014-17-1-2896, and by Huawei Technologies Co., Ltd.
185
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:51:40 UTC from IEEE Xplore.  Restrictions apply. Leveraging Program Analysis to Reduce
User-Perceived Latency in Mobile ApplicationsICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden
REFERENCES
[1] [n. d.]. Google Play App Store. http://play.google.com/store/apps. ([n. d.]).
[2]2015. Average mobile app session length as of 4th quar-
ter 2015. (2015). https://www.statista.com/statistics/202485/
average-ipad-app-session-length-by-app-categories/
[3] 2017. Heroku. (2017). https://www.heroku.com/
[4]2017. MongoDB. (2017). https://docs.mongodb.com/getting-started/shell/
import-data/
[5] 2017. Xposed Framework. (2017). http://repo.xposed.info/[6] AppDynamics. 2014. The app attention span. (2014).
[7]
Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bodden, Alexandre Bar-
tel,JacquesKlein,YvesLeTraon,DamienOcteau,andPatrickMcDaniel.2014.
Flowdroid: Precise context, flow, field, object-sensitive and lifecycle-aware taint
analysis for android apps. ACM SIGPLAN Notices 49, 6 (2014), 259â€“269.
[8]Ricardo Baeza-Yates, Di Jiang, Fabrizio Silvestri, and Beverly Harrison. 2015.
PredictingTheNextAppThatYouAreGoingToUse.In ProceedingsoftheEighth
ACMInternationalConferenceonWebSearchandDataMining(WSDMâ€™15).ACM,
New York, NY, USA, 285â€“294. https://doi.org/10.1145/2684822.2685302
[9]Leilani Battle, Remco Chang, and Michael Stonebraker. 2016. Dynamic Prefetch-
ing of Data Tiles for Interactive Visualization. In Proceedings of the 2016 Interna-
tional Conference on Management of Data (SIGMOD â€™16). ACM, New York, NY,
USA, 1363â€“1375. https://doi.org/10.1145/2882903.2882919
[10]PaulBaumannandSilviaSantini.2017. EveryByteCounts:SelectivePrefetching
forMobileApplications. Proc.ACMInteract.Mob.WearableUbiquitousTechnol.
1, 2, Article 6 (June 2017), 29 pages. https://doi.org/10.1145/3090052
[11]Yinzhi Cao, Yanick Fratantonio, Antonio Bianchi, Manuel Egele, Christopher
Kruegel, Giovanni Vigna, and Yan Chen. 2015. EdgeMiner: Automatically De-
tectingImplicitControlFlowTransitionsthroughtheAndroidFramework..In
NDSS.
[12]ShuaifuDai,AlokTongaonkar,XiaoyinWang,AntonioNucci,andDawnSong.
2013. Networkprofiler: Towards automatic fingerprinting of android apps. In
INFOCOM, 2013 Proceedings IEEE. IEEE, 809â€“817.
[13]B De La Ossa, JA Gil, Julio Sahuquillo, and Ana Pont. 2007. Improving web
prefetchingbymakingpredictionsatprefetch.In NextGenerationInternetNet-
works, 3rd EuroNGI Conference on. IEEE, 21â€“27.
[14]LiFan,PeiCao,WeiLin,andQuinnJacobson.1999.Webprefetchingbetweenlow-
bandwidth clients and proxies: potential and performance. In ACM SIGMETRICS
Performance Evaluation Review, Vol. 27. ACM, 178â€“187.
[15]SoftArch Research Group. 2018. PALOMA Project Website. (2018). https://
softarch.usc.edu/PALOMA
[16]Android Developers Guide. 2017. Android AsyncTask. (2017). https://developer.
android.com/reference/android/os/AsyncTask.html
[17]Android Developers API Guides. 2017. The Activity Lifecycle. (2017). https:
//developer.android.com/guide/components/activities/activity-lifecycle.html
[18]Android Developers API Guides. 2017. Android Input Events. (2017). https:
//developer.android.com/guide/topics/ui/ui-events.html
[19]Android Developers API Guides. 2017. Android ListView. (2017). https://
developer.android.com/guide/topics/ui/layout/listview.html
[20]AndroidDevelopersAPIGuides.2017. StringResources. (2017). https://developer.
android.com/guide/topics/resources/string-resource.html
[21]BrettDHiggins,JasonFlinn,ThomasJGiuli,BrianNoble,ChristopherPeplin,
and David Watson. 2012. Informed mobile prefetching. In Proceedings of the
10thinternationalconferenceonMobilesystems,applications,andservices.ACM,
155â€“168.
[22]Vassilis Kostakos, Denzil Ferreira, Jorge Goncalves, and Simo Hosio. 2016.Modelling Smartphone Usage: A Markov State Transition Model. In Proceed-
ings of the 2016 ACM International Joint Conference on Pervasive and Ubiqui-tous Computing (UbiComp â€™16). ACM, New York, NY, USA, 486â€“497. https:
//doi.org/10.1145/2971648.2971669
[23]Ding Li, Yingjun Lyu, Jiaping Gui, and William GJ Halfond. 2016. Automated
energy optimization of HTTP requests for mobile applications. In Proceedings of
the 38th International Conference on Software Engineering. ACM, 249â€“260.
[24]Ding Li, Yingjun Lyu, Mian Wan, and William GJ Halfond. 2015. String analysis
forJavaandAndroidapplications.In Proceedingsofthe201510thJointMeeting
on Foundations of Software Engineering. ACM, 661â€“672.
[25]Yang Li. 2014. Reflection: enablingevent prediction as anon-deviceservice for
mobile interaction. In Proceedings of the 27th annual ACM symposium on User
interface software and technology. ACM, 689â€“698.
[26]James W Mickens, Jeremy Elson, Jon Howell, and Jay Lorch. 2010. Crom: Faster
Web Browsing Using Speculative Execution.. In NSDI, Vol. 10. 9â€“9.
[27]Ravi Netravali, Ameesh Goyal, James Mickens, and Hari Balakrishnan. 2016.
Polaris:fasterpageloadsusingfine-graineddependencytracking.In 13thUSENIX
Symposium on Networked Systems Design and Implementation (NSDI 16).
[28]VenkataNPadmanabhanandJeffreyCMogul.1996. Usingpredictiveprefetching
to improve world wide web latency. ACM SIGCOMM Computer Communication
Review26, 3 (1996), 22â€“36.
[29]AbhinavParate,MatthiasBÃ¶hmer,DavidChu,DeepakGanesan,andBenjaminM.
Marlin. 2013. Practical Prediction and Prefetch for Faster Access to Applicationson Mobile Phones. In Proceedings of the 2013 ACM International Joint Conference
onPervasiveandUbiquitousComputing(UbiCompâ€™13).ACM,NewYork,NY,USA,
275â€“284. https://doi.org/10.1145/2493432.2493490
[30]Danilo Dominguez Perez and Wei Le. 2017. Generating Predicate Callback
SummariesfortheAndroidFramework.In Proceedingsofthe4thInternational
ConferenceonMobileSoftwareEngineeringandSystems(MOBILESoftâ€™17).IEEE
Press,Piscataway,NJ,USA,68â€“78. https://doi.org/10.1109/MOBILESoft.2017.28
[31]QUARTZ. 2016. Androidjusthita record88%marketshareofallsmartphones.
(2016).
[32]Lenin Ravindranath, Jitendra Padhye, Sharad Agarwal, Ratul Mahajan, Ian Ober-
miller, and Shahin Shayandeh. 2012. AppInsight: mobile app performance moni-
toringinthewild.In Presentedaspartofthe10thUSENIXSymposiumonOperating
Systems Design and Implementation (OSDI 12). 107â€“120.
[33]PRESTOresearchgroup.2017. GATOR:ProgramAnalysisToolkitForAndroid.
(2017). http://web.cse.ohio-state.edu/presto/software/gator/
[34]Sanae Rosen, Bo Han, Shuai Hao, Z. Morley Mao, and Feng Qian. 2017. Push or
Request: An Investigation of HTTP/2 Server Push for Improving Mobile Perfor-
mance. In Proceedings of the 26th International Conference on World Wide Web
(WWWâ€™17) .InternationalWorldWideWebConferencesSteeringCommittee,
Republic and Canton of Geneva, Switzerland, 459â€“468. https://doi.org/10.1145/
3038912.3052574
[35]Vaspol Ruamviboonsuk, Ravi Netravali, Muhammed Uluyol, and Harsha V Mad-
hyastha. 2017. VROOM: Accelerating the Mobile Web with Server-Aided Depen-
dency Resolution. In Proceedings of the Conference of the ACM Special Interest
Group on Data Communication. ACM, 390â€“403.
[36] N. Swaminathan and S. V. Raghavan. 2000. Intelligent prefetch in WWW using
clientbehaviorcharacterization.In Proceedings8thInternationalSymposiumon
Modeling,AnalysisandSimulationofComputerandTelecommunicationSystems
(Cat. No.PR00728). 13â€“19. https://doi.org/10.1109/MASCOT.2000.876424
[37]RajaVallÃ©e-Rai,PhongCo, EtienneGagnon,Laurie Hendren,PatrickLam, and
Vijay Sundaresan. 1999. Soot - a Java Bytecode Optimization Framework. In
Proceedings of the 1999 Conference of the Centre for Advanced Studies on Collabo-
rative Research (CASCON â€™99). IBM Press, 13â€“. http://dl.acm.org/citation.cfm?id=
781995.782008
[38]Haoyu Wang, Junjun Kong, Yao Guo, and Xiangqun Chen. 2013. Mobile web
browser optimizations in the cloud era: A survey. In Service Oriented System
Engineering (SOSE), 2013 IEEE 7th International Symposium on. IEEE, 527â€“536.
[39]XiaoSophiaWang,ArvindKrishnamurthy, andDavidWetherall.2016. Speeding
up web page loads with Shandian. In 13th USENIX Symposium on Networked
Systems Design and Implementation (NSDI 16). 109â€“122.
[40]Yichuan Wang, Xin Liu, David Chu, and Yunxin Liu. 2015. EarlyBird: Mobile
Prefetching ofSocial NetworkFeeds via ContentPreference Miningand Usage
Pattern Analysis. In Proceedings of the 16th ACM International Symposium on
MobileAdHocNetworkingandComputing(MobiHocâ€™15).ACM,NewYork,NY,
USA, 67â€“76. https://doi.org/10.1145/2746285.2746312
[41]Zhen Wang, Felix Xiaozhu Lin, Lin Zhong, and Mansoor Chishtie. 2011. Why
are web browsers slow on smartphones?. In Proceedings of the 12th Workshop on
Mobile Computing Systems and Applications. ACM, 91â€“96.
[42]ZhenWang,FelixXiaozhuLin,LinZhong,andMansoorChishtie.2012. Howfar
can client-only solutions go for mobile browser speed?. In Proceedings of the 21st
international conference on World Wide Web. ACM, 31â€“40.
[43]Ryen W. White, Fernando Diaz, and Qi Guo. 2017. Search Result Prefetching on
Desktop and Mobile. ACM Trans. Inf. Syst. 35, 3, Article 23 (May 2017), 34 pages.
https://doi.org/10.1145/3015466
[44]C. Wu, X. Chen, Y. Zhou, N. Li, X. Fu, and Y. Zhang. 2016. Spice: Socially-
drivenlearning-basedmobilemediaprefetching.In IEEEINFOCOM2016-The
35th Annual IEEE International Conference on Computer Communications. 1â€“9.
https://doi.org/10.1109/INFOCOM.2016.7524568
[45]Tingxin Yan, David Chu, Deepak Ganesan, Aman Kansal, and Jie Liu. 2012.Fast App Launching for Mobile Devices Using Predictive User Context. In
Proceedings of the 10th International Conference on Mobile Systems, Applica-
tions, and Services (MobiSys â€™12). ACM, New York, NY, USA, 113â€“126. https:
//doi.org/10.1145/2307636.2307648
[46]ShengqianYang,DacongYan,HaoweiWu,YanWang,andAtanasRountev.2015.
Static control-flow analysis of user-driven callbacks in Android applications. In
Proceedings of the 37th International Conference on Software Engineering-Volume1. IEEE Press, 89â€“99.
[47]
ShengqianYang,HailongZhang,HaoweiWu,YanWang,DacongYan,andAtanas
Rountev. 2015. Static window transition graphs for android (t). In Automated
SoftwareEngineering(ASE),201530thIEEE/ACMInternationalConferenceon.IEEE,
658â€“668.
[48]Y. Yang and G. Cao. 2018. Prefetch-Based Energy Optimization on Smartphones.
IEEETransactionsonWirelessCommunications 17,1(Jan2018),693â€“706. https:
//doi.org/10.1109/TWC.2017.2769646
186
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:51:40 UTC from IEEE Xplore.  Restrictions apply. 