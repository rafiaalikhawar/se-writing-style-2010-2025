Repairing Event Race Errors
by Controlling Nondeterminism
Christoffer Quist Adamsen∗
Anders Møller
Aarhus University
Aarhus, Denmark
{cqa,amoeller}@cs.au.dkRezwana Karim
Manu Sridharan†
Samsung Research America
Mountain View, CA, USA
rezwana.k@samsung.com
manu@sridharan.netFrank Tip
Northeastern University
Boston, MA, USA
f.tip@northeastern.eduKoushik Sen
EECS Department
UC Berkeley, CA, USA
ksen@cs.berkeley.edu
Abstract —Modern web applications are written in an event-
driven style, in which event handlers execute asynchronously in
response to user or system events. The nondeterminism arising
from this programming style can lead to pernicious errors. Recent
work focuses on detecting event races and classifying them as
harmful or harmless. However, since modifying the source code
to prevent harmful races can be a difﬁcult and error-prone task,
it may be preferable to steer away from the bad executions.
In this paper, we present a technique for automated repair
of event race errors in JavaScript web applications. Our ap-
proach relies on an event controller that restricts event handler
scheduling in the browser according to a speciﬁed repair policy,
by intercepting and carefully postponing or discarding selected
events. We have implemented the technique in a tool called
EventRaceCommander , which relies entirely on source code in-
strumentation, and evaluated it by repairing more than 100 event
race errors that occur in the web applications from the largest 20
of the Fortune 500 companies. Our results show that application-
independent repair policies usually sufﬁce to repair event race
errors without excessive negative impact on performance or user
experience, though application-speciﬁc repair policies that target
speciﬁc event races are sometimes desirable.
Keywords -JavaScript; event-driven programming; automated
repair
I. I NTRODUCTION
Modern application development has largely moved to
platforms requiring event-driven programming, using web
browsers and mobile platforms. The event-driven model is
well-suited to the needs of today’s interactive programs, which
must perform high-latency network requests to send and re-
ceive requested data while remaining responsive to user input.
However, as studied in recent work [8, 11, 21, 22, 25, 34],
this programming style can cause pernicious nondeterminism
errors, which can lead to crashes, lost user data, and malfunc-
tioning user interfaces.
Recent work has attacked this nondeterminism problem
through tools for detecting event races , where application
behavior may differ depending on the order in which event
handlers are executed. For web applications, event race detec-
tors are capable of ﬁnding errors in real-world, deployed web
∗The work of this author was carried out during an internship at Samsung
Research America.†The author’s current afﬁliation is Uber.applications [25]. Further, tools such as R4[11] can ﬁlter away
warnings about races that do not affect the external behavior
of web applications.
Despite these advances, the output of state-of-the-art event
race detectors is often still not practical. Diagnosing the
root cause of an event race in a real-world web application
can require a signiﬁcant effort—it often requires deciphering
complex event sequences, and it can be difﬁcult to classify
how harmful a reported race is, especially for non-expert
users of the tools. In addition, preventing such races may
require introducing complex synchronization into the code, an
arduous task since the web platform provides few mechanisms
for synchronizing across event handlers. Manually devising
such a ﬁx is often not worth the effort, particularly for minor
errors, when considering that ﬁxes sometimes have unforeseen
consequences [31]. Better techniques are needed to reduce the
cost of ﬁxing event race errors.
In this work, we explore automated repair of event race er-
rors in web applications. Automated repair holds great promise
for addressing the aforementioned drawbacks of event race
detectors. If event race errors can be automatically repaired,
without requiring developers to deeply understand root causes,
the errors may be avoided more often. There is a wide body
of work on repairing races in multi-threaded programs [6, 12–
18, 23, 24, 27, 29, 30, 32, 33], but relatively little work
on repair for event races. Wang et al. [28] have proposed a
repair technique for event races in web applications, but it has
signiﬁcant limitations in the types of races it can handle (see
Section VIII).
Our approach builds on an event controller that restricts
event handler scheduling in the browser according to a speci-
ﬁed repair policy , by intercepting and carefully postponing or
discarding selected events. Restricting schedules dynamically
to avoid bad orderings is a well-known approach to automated
repair of races in the context of shared-memory concurrency
races, but to our knowledge it has not previously been applied
to event-driven applications. An important property of our
approach is that the event controller is built entirely by instru-
menting the web application code. Most event race detection
tools for JavaScript work using modiﬁed browsers, which is
reasonable for detecting races, but not for automated repair,
2017 IEEE/ACM 39th International Conference on Software Engineering
 
DOI 10.1109/ICSE.2017.34288
2017 IEEE/ACM 39th International Conference on Software Engineering
1558-1225/17 $31.00 © 2017 IEEE
DOI 10.1109/ICSE.2017.34289
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:08 UTC from IEEE Xplore.  Restrictions apply. as the code must run on end-user browsers. In spite of relying
solely on light-weight instrumentation, our approach is general
enough to repair common types of event races, although some
event race errors cannot be repaired by merely restricting the
nondeterminism (see Section V -D).
Given this event controller, the question remains of what
policies are required to repair races in practice. A policy
speciﬁes which events to postpone or discard, so choosing
an appropriate policy requires knowledge about which event
orders are good and which are bad. We observe that many
races in web applications can be prevented with a small
collection of application-independent policies. For example,
application developers often expect Ajax response handlers to
execute in a ﬁrst-in ﬁrst-out (FIFO) order, and that the page
completes loading before the user interacts with it: many errors
occur when these assumptions are violated. Our application-
independent policies enforce these assumptions, yielding a
simple method for avoiding many races.
Application-independent policies are easy to apply, but may
impact performance or user experience negatively. For exam-
ple, delaying all user events until after the page has loaded
may make the page appear sluggish, and in fact many user
interactions during page load may be perfectly safe (i.e., they
cannot lead to harmful races). We show that these problems
can be alleviated using application-speciﬁc policies, which
can be designed, for example, by specializing an application-
independent policy to a particular web application.
In summary, the contributions of this paper are as follows.
•We demonstrate that most errors involving event races
in JavaScript web applications can be repaired auto-
matically, using light-weight instrumentation to steer the
nondeterminism according to a speciﬁed repair policy.
•We propose the use of application-independent policies,
which can be specialized as needed to avoid excessive
delay in event processing, or to target speciﬁc event races
reported by existing race detection tools.
•We evaluate our approach based on an implementation
called EventRaceCommander , by repairing 117 event
race errors in the websites of the 20 largest companies
from the Fortune 500 list. Our results show that 94 of the
errors can be repaired using application-independent poli-
cies, mostly without excessive negative impact, and that
application-speciﬁc policies can alleviate the undesirable
effects when this is not the case.
II. M OTIV A TING EXAMPLE
Figure 1 shows a small web application for browsing
through galleries of images, consisting of three ﬁles. File
index.html deﬁnes a top-level page with two buttons, labeled
“Gallery 1” and “Gallery 2.” Clicking each button causes
function loadThumbs (lines 15–26) to be invoked with the
gallery name “ g1”o r“ g2,” depending on the gallery being
selected. Executing loadThumbs will send an Ajax request
to the server (lines 17–25). When the server responds, the
readystatechange callback function (lines 18–23) is invoked.
This callback parses the response to retrieve an array ofindex.html
1<html>
2...
3<div id= "container" ...>
4...
5<button id= "g1">Gallery 1</button>
6<button id= "g2">Gallery 2</button>
7<script src= "init.js" ></script>
8<script src= "script.js" ></script>
9</html>
init.js
10document.getElementById( ’g1’).addEventListener(
11 ’click’ ,function () { loadThumbs( ’g1’); }, false );
12document.getElementById( ’g2’).addEventListener(
13 ’click’ ,function () { loadThumbs( ’g2’); }, false );
script.js
14varthumbs;
15function loadThumbs(name) {
16 thumbs = [];
17 varxhr = newXMLHttpRequest();
18 xhr.onreadystatechange = function () {
19 if(xhr.readyState === XMLHttpRequest.DONE) {
20 thumbs = JSON.parse(xhr.responseText);
21 showThumbs(name);
22 }
23 };
24 xhr.open( ’GET’ ,’gallery?name=’ + name, true);
25 xhr.send( null);
26}
27function showThumbs(name) {
28 container.innerHTML = ’’;
29 for(varpos = 0; pos < thumbs.length; ++pos) {
30 ...// display thumbnail image
31 varb = document.createElement( ’button’ );
32 b.textContent = ’Delete’ ;
33 (function (pos) {
34 b.addEventListener( ’click’ ,function (e) {
35 deleteImg(name, pos);
36 },false );
37 })(pos);
38 container.appendChild(b);
39 }
40}
41function deleteImg(name, pos) {
42 ...
43 xhr.open( ’POST’ ,’gallery?action=delete&name=’
44 + name + ’&img=’ +thumbs[pos].id, true);
45 ...
46}
Fig. 1. Motivating example (inspired by Zheng et al. [34]).
thumbnail images and stores them in variable thumbs (line 20),
and then invokes showThumbs with the same gallery name as
before. Function showThumbs (lines 27–40) iterates through
thumbs and creates a ‘ Delete ’ button for each image that, when
clicked, will invoke deleteImg with the gallery name and index
of the image. Function deleteImg (lines 41–46) creates another
Ajax request, requesting the selected image to be deleted from
the server (lines 43–44).
A. Event Races
The example application exhibits three event races that
may cause runtime exceptions or other unexpected behavior,
depending on the order in which event handlers execute. The
corresponding undesirable schedules are illustrated in Figure 2
and discussed in detail below.
A/circlecopyrt If the user clicks the “Gallery” buttons before init.js has
executed, then the user event is lost, since the click event
handlers are not yet registered.
289
290
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:08 UTC from IEEE Xplore.  Restrictions apply. index.html 
init.js 
script.js 
(lines 1-46)
index.html 
init.js
script.js 
(lines 1-46 )user clicks 
“Gallery 1” 
buttononreadystate- 
change 
eventuser clicks 
“Gallery 2” 
buttonuser clicks 
“Delete 
buttonTypeError 
(no property id in  
undefined)
loadThumbs 
(lines 15-26)
loadThumbs 
(lines 15-26 )showThumbs 
(lines 27-40)
showThumbs 
(lines 27-40 )loadThumbs 
(lines 15-26)
loadThumbs 
(lines 15-26 )deleteImg 
(lines 41-46)
deleteIm g
(lines 41-46 )
C
C
B
BA
A
index.html 
(lines 7-9)
index.html
(lines 7-9 )index.html 
(lines 1-6)
index.html
(lines 1-6 )init.js 
(lines 10-13)
init.js
(lines 10-13 )script.js 
(lines 14-46)
script.js
(lines 14-46 )user clicks 
“Gallery 2” 
button(click event is lost)
init.js 
(lines 10-13)
init.
js 
(lines 10-13 )index.html 
(lines 1-7)
index.html
(lines 1-7 )user clicks 
“Gallery 2” 
button
ReferenceError 
(loadThumbs  not declared)
Fig. 2. Illustration of event races in the program of Figure 1.
B/circlecopyrt If the user clicks the “Gallery” buttons after executing
init.js , but before script.js has executed, then an event
handler is associated with the click event, but function
loadThumbs is still undeclared. Hence, executing either of
theclick event handlers on lines 11 and 13 triggers an
uncaught ReferenceError .
C/circlecopyrt Assume the user clicks the “Gallery 1” button after
the entire page has been parsed. This causes loadThumbs
(lines 15–26) to execute with argument “ g1,” generating
an Ajax request. When the server responds, the event
handler on lines 18–23 executes, causing showThumbs to ex-
ecute (lines 27–40). If the user then clicks the “Gallery 2”
button, loadThumbs runs again (now with argument “ g2”)
assigning an empty array to thumbs before making a sec-
ond Ajax request. Now, say the user clicks the “Delete”
button for an image that is still on the screen, before
the response to the second Ajax request is received.
Then, the click handler on lines 34–36 invokes deleteImg
(lines 41–46), causing the expression thumbs[pos].id to
be evaluated (line 44). But thumbs is still empty! So,
thumbs[pos] evaluates to undefined , and accessing the id
property of undefined yields an uncaught TypeError .
We will refer to scenarios where user events interfere with
initializations performed during page loading (e.g., scenarios
A/circlecopyrt and B/circlecopyrt)a s initialization races . Races such as the one in
scenario C/circlecopyrt will be referred to as post-initialization races .
B. Repairing Event Race Errors
The types of problems discussed above commonly occur
when a schedule differs from developers’ expectations. For
example, developers typically test their code in environments
where the parsing and loading of a page is fast and where user
actions do not occur until page loading is complete. Scenarios
like A/circlecopyrtand B/circlecopyrtviolate this assumption, causing various sorts of
errors to arise when user events arrive at inopportune moments.
Similarly, developers commonly assume the network to be fast,
so that responses to Ajax requests are received before the user
performs additional actions. Scenario C/circlecopyrt, where the user clickson “Delete” before the response for the click on “Gallery 2” is
received, violates this assumption, resulting in a runtime error.
Our approach for preventing undesirable schedules relies
on code instrumentation, and takes as input a repair policy
that speciﬁes constraints on the scheduling of event handlers.
In particular, the web application is instrumented so that all
events are intercepted and monitored by a runtime controller.
At runtime, when an event arrives that is not in accordance
with the repair policy, it is either discarded or postponed until
the execution of the associated event handlers agrees with the
policy. For example, scenarios A/circlecopyrt and B/circlecopyrt can be prevented
in our approach by an application-independent policy that
postpones user events until all statically declared scripts are
loaded, by intercepting the events and regenerating them later.
(In cases where this policy blocks harmless user events, one
can easily create a policy that only postpones clicks on the
“Gallery” buttons.) Likewise, scenario C/circlecopyrt can be prevented
by an application-independent policy that discards user events
after an Ajax request until the response arrives. In such cases,
EventRaceCommander shows a “spinner” on the screen to
inform the end-user that user events are temporarily blocked.
While the three scenarios discussed here can be repaired us-
ing application-independent policies, application-speciﬁc poli-
cies may be preferable, as we shall see in Section VII.
III. B ACKGROUND ON EVENT RACES
This section deﬁnes event races and related concepts using
a simpliﬁed version of the formalism of Raychev et al. [25].
We instrument an event-based program to generate a se-
quence of operations , called a trace , for a given execution.
An operation can be of the following kinds (assuming each
event is given a unique identiﬁer u):
•read(u,x)and write (u,x)denote that an event handler
ofureads and writes, respectively, a shared variable x.
•fork(u,v)denotes that an event handler of ucreates a
new event vthat will be dispatched later.
•begin (u)and end(u)denote the beginning and ending,
respectively, of the execution of u’s event handlers.
We denote the set of all operations by Op, and the event
to which an operation σbelongs by evt(σ). The execution
of a program generates a ﬁnite trace τ=σ0···σn∈Op∗.
In event-based programs, all event handlers of an event ex-
ecute atomically without interleaving with the execution of
any handler of another event. Therefore, if an event ugets
dispatched, then all the operations from the event handlers
ofuappear as a contiguous subsequence in the trace, where
the ﬁrst and last operations of the subsequence are begin (u)
and end(u), respectively. If the trace contains an operation
fork(u,v), then begin (u)appears before begin (v), i.e., an event
must be created before it gets dispatched.
A traceτdeﬁnes a linear relation <, whereσ<σ/primeif the
operation σappears before σ/primein the trace τ. As in traditional
concurrent programs, we can deﬁne a happens-before relation
/precedesequalas the minimal partial order (i.e., a reﬂexive, anti-symmetric,
transitive relation) over the events of a trace such that u/precedesequalvif
fork(u,v)∈τor ifuandvare user events where begin (u)<
290
291
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:08 UTC from IEEE Xplore.  Restrictions apply. scheduler (σ,τ,P): =(τ·extend (σ,τ,P),update (σ,τ,P))
update (σ,τ,P): =P\{ (q,s, 1,a,r )∈PA(σ,τ,Sτ)}/uniontext{ri∈r(σ)|(q,s,t,a,r )∈PA(σ,τ,Sτ)}extend (σ,τ,P): =⎧
⎪⎨
⎪⎩discard (u) ifσ≡begin (u)∧action (u,τ,P)≡DISCARD
postpone (u) ifσ≡begin (u)∧action (u,τ,P)≡POSTPONE
σ otherwise
action (u,τ,P): =m a x {a|(q,s,t,a,r )∈PA(begin (u),τ,Sτ)},where
DISP A TCH <POSTPONE <DISCARD
Fig. 3. The effect of a repair policy on the execution.
begin (v). Two events uandvare unordered, denoted by u/bardblv,
if they are not related by the happens-before relation. We are
now in a position to deﬁne the notion of an event race.
An event race (σ,σ/prime)is a pair of operations from a trace τ
whereσ<σ/prime,evt(σ)/bardblevt(σ/prime), bothσandσ/primeaccess (i.e.,
read or write) the same shared variable, and at least one of σ
andσ/primeis a write.
Recent work has focused on classifying event races as either
harmful or harmless [11, 20, 21, 25]. In general, such classi-
ﬁcation is a subjective matter. In many cases, lost user events
or uncaught exceptions do not signiﬁcantly affect the user ex-
perience and do not require remediation, though for some web
sites such errors are intolerable. Our approach side-steps this
ambiguity by relying on the user of EventRaceCommander
to distinguish desirable schedules from undesirable ones, and
applying a repair policy that prevents undesirable schedules
from taking place. In other words, our approach does not rely
on a particular deﬁnition of harmfulness, nor is it limited to
races that are considered harmful.
IV . A F RAMEWORK FOR SPECIFYING REP AIR POLICIES
This section presents a framework for constraining the order
in which event handlers are executed using a speciﬁed repair
policy. A repair policy Pconsists of a set of rules, which upon
their activation (determined by the current trace τand program
stateSτof the web application) may discard or postpone
events occurring in the execution. To this end, we add the
following types of operations.
•discard (u)denotes the discarding of event u(i.e., the
event handlers for event uwill not be invoked, and no
begin (u)operation will ever appear in the trace).
•postpone (u)denotes the postponement of event u(i.e.,u
will be re-emitted later, and at least one of the operations
begin (u),discard (u),postpone (u)will appear in the trace
onceuis re-emitted).
A key contribution of our work is that we—based on a study
of many event races in real-world web applications—observe
that harmful races mostly arise for similar reasons, and can be
repaired using application-independent policies.
Arule is a quintuple of the form (q,s,t,a,r )∈Q where:
•qis an operation predicate over the operations in Op that
speciﬁes a necessary condition for the rule to be activated
upon the current operation of a scheduler.
•sis an expiration status , which is a predicate over the
pairs of traces and program states that determines if the
rule is enabled or expired.
•t∈{1,∞} is a scope .I ft=1 , then the rule expires
the ﬁrst time it is activated, otherwise it remains enabled
until the expiration status sbecomes true.•a∈{ DISP A TCH,DISCARD,POSTPONE }is an action in
response to the event that the rule was activated by.
•r:Op→2Qis an extension function that maps an
operation to a policy, which is used for dynamically
adding new rules to the existing policy.
For the sake of presentation, we will use (q,s,t,a )σ=⇒
r0,...,r nto denote the policy {(q,s,t,a,λσ./uniontext
0≤i≤nri)},
and(q,s,t,a )to denote the policy {(q,s,t,a, ∅)}.
A rule (q,s,t,a,r )∈P isactivated by an operation σ
in state (τ,Sτ)ifq(σ)and¬s(τ,Sτ)hold, i.e., the rule
matches the operation and is not expired. We denote by
PA(σ,τ,Sτ)the set of rules in Pthat are activated by σ
in(τ,Sτ). The deﬁnition of activated rules enables us to
describe the effect of a repair policy on the execution by
means of a function, scheduler (σ,τ,P)(Figure 3), that maps
an operation, a trace, and a repair policy to an extended trace
and updated policy. The auxiliary function extend (σ,τ,P)
(Figure 3) determines whether events should be discarded or
postponed, by computing the action for σas a maximum
over the activated actions (multiple rules may be activated
simultaneously). The ordering among actions is deﬁned in
Figure 3. If σis not a begin operation, then τis simply
extended with σ. Hence, a policy cannot discard or postpone
an event based on speciﬁc operations within an event handler.
Rules can, however, match on speciﬁc operations and use them
to modify the policy via the extension function.
In addition to extending the trace τ, the current repair policy
Pis replaced by P/prime=update (σ,τ,P)(Figure 3), which
differs from Pas follows.
1) All rules with scope 1that were activated by σin(τ,Sτ)
are removed from P.
2)Pis extended with the rules in r(σ)for every activated
rule (q,s,t,a,r ).
We emphasize that postponing one event may require other
events to be postponed as well, due to the happens-before
relation of the original web application. For example, the load
event of a script always follows the execution of the same
script. Our framework automatically enforces such constraints,
and additionally preserves the order of user events.
V. R EP AIR POLICIES
We identify ﬁve classes of event races that cause many prob-
lems in practice. Section V -A deﬁnes application-independent
policies in terms of the framework presented in Section IV.
Then, Section V -B shows how such general policies can
be specialized to particular web applications, for improved
performance and user experience.
291
292
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:08 UTC from IEEE Xplore.  Restrictions apply. quser(σ): =σ=begin (u)∧type(u)∈{keydown,mousedown ,...}
qcallback (σ): =σ=begin (u)∧(type(u)=timer∨
(type(u)=load∧tagName (target (u))∈{iframe,img}))
qfork(σ): =σ=fork(·,v)∧(type(v)∈{script-exec ,timer}∨
(type(v)=readystatechange ∧readyState (target (v)) = 4))
qbegin(u,σ): =σ=begin (u)ARRIVED (u,τ,Sτ): = begin (u)∈τ
PARSED (τ,Sτ): = DOMC ONTENT LOADED∈/uniontext
begin(u)∈τtype(u)
(a) (b)
WAIT FOR(u): = (quser,ARRIVED (u),∞,DISCARD )
WAIT REC(u): = (qfork,ARRIVED (u),∞,DISP A TCH )
fork(v,w)=====⇒ WAIT FOR(w),WAIT REC(w)
ORDER (u,v): = (qbegin(v),ARRIVED (u),∞,POSTPONE )
ORDER NEXT(u): = (qfork,ARRIVED (u),1,DISP A TCH )
fork(v,w)=====⇒ ORDER (u,w)Pinit,user := (quser,PARSED,∞,POSTPONE )
Pinit,system := (qcallback,PARSED,∞,POSTPONE )
Pasync,user := (qfork,/latticetop,∞,DISP A TCH )fork(u,v)=====⇒ WAIT FOR(v)
Pasync,ﬁfo := (qfork,/latticetop,∞,DISP A TCH )fork(u,v)=====⇒ ORDER NEXT(v)
P+
init,user:=Pinit,user/uniontext/parenleftBig
(qfork,PARSED,∞,DISP A TCH )
fork(u,v)=====⇒ WAIT FOR(v),WAIT REC(v)/parenrightBig
(c) (d)
Fig. 4. Repair policies. (a) operation predicates, (b) expiration status utilities, (c) utility functions, (d) application-independent repair policies.
A. Application-Independent Repair Policies
User events before DOMContentLoaded :Scenarios A/circlecopyrt
and B/circlecopyrtfrom Section II-A illustrate initialization races that lead
to undesirable behavior when a user interacts with a web page
before it has been fully parsed. The errors induced by these
races can be repaired by enforcing the policy Pinit,user from
Figure 4(d), where quser is an operation predicate that matches
any user event. Due to the deﬁnition of the policy’s expiration
status, P ARSED (Figure 4(b)), this policy postpones any user
event until the event handlers of DOMContentLoaded have been
executed. It is easy to see how this policy prevents the errors
in scenarios A/circlecopyrt and B/circlecopyrt from Section II-A: By preventing
click events on the “Gallery” buttons until the page has been
parsed, the click event handlers will be registered in time, and
theloadThumbs function will be deﬁned before it is invoked,
thereby preventing the ReferenceError .
In this policy, D ISCARD could be used instead of
POSTPONE . The D ISCARD action is intended for user events
only, since users can always simply repeat their inputs when
the policy allows it, which is not possible for system events.
System events before DOMContentLoaded :Harmful initial-
ization races also arise when system events ﬁre unexpectedly
early. In the following example, which is based on code from
exxon.com , the load event listener attached by the script will
never run if the iframe loads prior to the execution of the script.
47<iframe src= "..." id="iframe" ></iframe>
48...
49<script>
50$(’#iframe’ ).load( function (e) {/* adjust iframe height */ });
51</script>
Such errors can be repaired using the policy Pinit,system from
Figure 4(d), which postpones system events, such as the load
event of the iframe in line 47, until the page has been parsed.
Pinit,system matches any iframe orimg load event, and any timer
event, with the operation predicate qcallback .
User events while async event is pending :Scenario C/circlecopyrt
in Section II-A represents a situation where the application
logic implicitly assumes that asynchronously forked events are
handled atomically, without being interrupted by user events.Such post-initialization race errors can be prevented using
policyPasync,user of Figure 4(d). Informally, this policy adds
the rule W AIT FOR(v)(Figure 4(c)) to the policy whenever an
operation forks an asynchronous event v(e.g., Ajax request,
asynchronous script request, setTimeout ). This rule discards
user events until vis observed in the trace.
Ajax FIFO :Sometimes programmers implicitly assume
that the responses to multiple Ajax requests arrive in the
same order as the requests were made. Consider the fol-
lowing example, which captures the essence of a race from
gazzetta.it [21]:
52ajax( ’POST’ , url1, function (a) { document.cookie = f(a); });
53ajax( ’POST’ , url2, function (b) { document.cookie = g(b); });
The two callback functions are executed in response to the
ﬁrst and second Ajax request, respectively. Both functions
assign some data from the server’s response to the same
document.cookie key. Therefore, the value of this key depends
on the order in which Ajax responses arrive.
To prevent such races, we use policy Pasync,ﬁfo of Figure 4(d)
to postpone Ajax response events that would break FIFO
order: Upon each Ajax request operation fork(·,v), the policy
starts listening for the next Ajax request operation fork(·,w)
by adding the rule O RDER NEXT(v). The use of scope 1
in O RDER NEXT ensures that the rule will not be activated
upon any Ajax request operations following fork(·,w).I f
begin (v)appears in the trace before fork(·,w), then FIFO is
already maintained and O RDER NEXT(v)expires due to its
expiration status, A RRIVED (v). Otherwise, FIFO is enforced
by O RDER (v,w)(added from O RDER NEXT(v)), which post-
pones begin (w)until begin (v)appears in the trace. Further-
more, O RDER NEXT(w)is added (by the rule in Pasync,ﬁfo )t o
order begin (w)with the response of the Ajax request operation
that follows fork(·,w)(if any).
User events before async initialization :Sometimes ini-
tialization actions are being performed by asynchronously
executed code. Consider the following snippet, which was
extracted from flysas.com .
54<input id= "from-airport" /><input id= "to-airport" />
55<script>
292
293
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:08 UTC from IEEE Xplore.  Restrictions apply. 56varlastFrom = ..., lastTo = ...; // inspect cookie
57$.get( ’/service?code=’ + lastFrom, function (from) {
58 $.get( ’/service?code=’ + lastTo, function (to) {
59 $(’#from-airport’ ).val(from.name);
60 $(’#to-airport’ ).val(to.name);
61 });
62});
63</script>
During loading, the user’s input may be overwritten, since the
ﬁelds in lines 59–60 are not initialized until the responses of
the two Ajax requests in lines 57–58 have been processed.
This may happen after the DOMC ONTENT LOADED event,
and therefore the policy Pinit,user does not sufﬁce to repair
the race. To accommodate for this, we deﬁne an extension
of this policy, P+
init,user , that additionally discards user events
until asynchronous initialization has been performed.
Intuitively, P+
init,user continuously adds W AIT FOR(v)(which
discards user events until begin (v)appears in the trace) for
every operation fork(·,v)that matches qfork, as long an event
that has been forked by some other operation matching qfork
is pending. For example, if fork(·,v)and fork(·,w)denote
the Ajax requests in lines 57 and 58, respectively, then
WAIT FOR(v)is added upon fork(·,v), which discards user
events until the callback in lines 57–62 has executed. In addi-
tion, W AIT REC(v)is added, which itself adds W AIT FOR(w)
upon fork(·,w). The W AIT FOR(w)rule discards user events
until after the callback in lines 58–61.
The W AIT REC rule recursively adds new rules to approxi-
mate when asynchronous initialization is over. This may lead
to user events being discarded indeﬁnitely (e.g., in the presence
of image sliders that keep changing automatically). Thus, this
policy should only be used for pages that always “terminate”
(i.e., where the event queue eventually becomes empty if no
more user events are made), or qfork should be deﬁned such
that it excludes operations that are not part of initialization
(e.g., by ignoring timer operations).
B. Application-Speciﬁc Policies
The application-independent policies can be applied without
a deep understanding of the races, and sufﬁce for preventing
the majority of the race errors (see Section VII). However,
sometimes the policies negatively affect web page responsive-
ness (e.g., the user experience of a web page can be degraded
when too many user events are interrupted). This motivates
application-speciﬁc repair policies that reduce disruption. It is
straightforward to reﬁne an application-independent policy to
speciﬁc user events. The manual effort required to design an
“optimal” application-speciﬁc policy naturally requires under-
standing the cause of the race.
Specializing an application-independent policy to a concrete
web application is straightforward. As an example, recall
that the race errors exposed by scenarios A/circlecopyrt and B/circlecopyrt can be
prevented by enforcing the policy Pinit,user . However, this may
unnecessarily affect clicks to buttons other than “Gallery 1”
and “Gallery 2” during page loading. This problem can be
alleviated by reﬁning the operation predicate quser inPinit,user
to only match click events on those two buttons.The interruption of the user is still not minimal, though,
since the function loadThumbs (Figure 1, lines 15–26) is de-
clared strictly before the DOMContentLoaded event gets dis-
patched. This can be remedied by, for example, exchanging
the policy’s expiration status from P ARSED to one that, unlike
all of the application-independent policies, relies on the actual
program state to return true when loadThumbs is declared in the
global scope of Sτ. With this modiﬁcation, it not only becomes
clear that the policy covers the event races in question; it also
minimizes the interruption of the user.
C. Effectiveness of Repair Policies
To understand if a repair policy Pprevents the bad order
of an event race, recall that state-of-the-art dynamic race
detectors, such as EventRacer [25], report event races as two
operations σandσ/primein a trace τwhere evt(σ)/bardblevt(σ/prime).
Simply checking that the race disappears when running a
race detector on the instrumented program that enforces P
is too naive, since state-of-the-art race detectors are currently
unable to reason about ad-hoc synchronization and will report
(σ,σ/prime)as a false positive. On the other hand, checking that
the race becomes covered [25] gives false conﬁdence.1Indeed,
most races become covered in the instrumented program,
since the execution of event handlers is controlled by ad-hoc
synchronization in the instrumented program.
To see how a repair policy Pprevents the bad order of
(σ,σ/prime), consider that the instrumentation restricts the non-
determinism in the original program, by enforcing an order
among certain events in the execution. Assuming that the
traceτobtained by the race detector is valid according to
P, it is possible to model the effect of Pby deﬁning an
augmented happens-before relation /precedesequalPas the minimal partial
order such that u/precedesequalPvif eitheru/precedesequalvorPwould enforce u
to execute before v. Using this relation, it is possible to tell
ifPwould prevent the race (σ,σ/prime)by checking if σ/precedesequalPσ/prime
orσ/prime/precedesequalPσ, giving developers a way to automatically repair
races that has been reported from dynamic race detectors (for
a ﬁxed catalogue of policies). The relation /precedesequalPcan be built
for multiple application-independent policies by extending
EventRacer. It remains open for future work to construct the
relation for arbitrary policies.
D. Discussion of Limitations and Liveness
Although it is not a problem for the repair policies we
have presented so far, there is a risk for postponing events
indeﬁnitely, thereby breaking liveness, when enforcing poli-
cies. Generally, we want to prevent some bad ordering v···u
by discarding or postponing vuntiluhas been dispatched.
To avoid breaking liveness, it must be known by the time vis
about to ﬁre that uwill inevitably occur later in the execution.
Intuitively, repair policies can only make decisions based
on past events and not on future events. Let Fbe a set of
events that are known to happen in the future. Initially, F
contains events that always happen during page loading, e.g.,
1Intuitively, a race (σ,σ/prime)iscovered by another race (δ,δ/prime)if(σ,σ/prime)is
no longer a race when (δ,δ/prime)is being treated as synchronization.
293
294
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:08 UTC from IEEE Xplore.  Restrictions apply. DOMContentLoaded . During execution, as soon as some event is
known to happen in the future (e.g., a timeout is registered or
an Ajax request is sent), it is added to F. Perhaps surprisingly,
Fmay also contain some user events, since a single user event
is typically composed of a sequence of low-level events (e.g.,
akeyup event always follows a keydown event). We now deﬁne a
necessary condition for being able to enforce an order u···v:
Ifvcomes before u, andu/negationslash∈F, then there is no way to
steer away from the bad execution without potentially breaking
liveness, since it is unknown if uwill ever arrive (safety can
be preserved, though, by postponing vuntilu, or indeﬁnitely
ifunever arrives). Otherwise, if we can deﬁne ( i) an operation
predicate that identiﬁes begin (v), and ( ii) a state predicate that
becomes false at some point after uhas been dispatched, then
the desired ordering can be enforced.
We call a repair policy enforceable for a program if it does
not break liveness in any execution . Conversely, we call a race
repairable if there exists an enforceable policy that prevents
the bad order of that race. The application-independent policies
Pinit,user ,Pinit,system ,Pasync,ﬁfo , andPasync,user are enforceable for
all programs, and P+
init,user is enforceable for all programs that
“terminate” (see Section V -A).
There are situations where it is not possible to prevent
an ordering v···uby only discarding or postponing events.
Consider the following example:
64<script>setTimeout( function ( ){d= document; }, 0);</script>
65<script>console.log(d.querySelectorAll( ’*’).length);</script>
Here, the callback in line 64 is supposed to execute prior to
the script in line 65. If the latter executes ﬁrst, then the only
possible repair is to postpone its execution. However, this will
change program behavior, since line 65 counts the number of
elements currently in the DOM. We have not seen any such
examples in practice, and hypothesize that this situation is rare.
In other cases, although it is technically possible to repair an
event race error, the result would have such a negative impact
on user experience that we do not consider it. These races
involve event handlers that are triggered when the user merely
moves the cursor (e.g., mouseenter ). Using a repair policy, the
user can be provided with feedback that the page is not ready.
However, for this kind of “indirect” user event (as opposed to
mouse clicks and key events), the event handler registration
should rather be performed earlier by changing the code.
VI. I MPLEMENT A TION
Our implementation, named EventRaceCommander , instru-
ments HTML and JavaScript source ﬁles of a given web
application on-the-ﬂy using mitmproxy [3]. The instrumenta-
tion intercepts relevant operations and interacts with the event
controller, which is loaded before any application code, such
that instrumentation and application code do not race.
The implementation of EventRaceCommander is available
athttps://github.com/cs-au-dk/EventRaceCommander .
A. Controlling the execution
For non-DOM events (e.g., timers, Ajax responses),
EventRaceCommander replaces each registration of an eventhandlerhwith the registration of a new event handler h/primethat
addshto a queue maintained by the event controller. This
involves intercepting calls to a small set of global functions
(e.g., setTimeout ), and instrumenting all property assignments
to intercept registrations to, e.g., the onreadystatechange prop-
erty of XMLHttpRequest objects.
For DOM events (e.g., click ,load ), the situation is slightly
more complicated due to capturing and bubbling . These event
delegation mechanisms propagate events from the document
root to the target node and back [1]. EventRaceCommander
handles DOM events as follows. When the page starts loading,
event handlers for all DOM event types are registered for
the capturing phase of the root element (this ensures that
these event handlers are triggered ﬁrst, since event handlers
are triggered in registration order). When one of these event
handlers is invoked with an event ethat was not previously
postponed, the event controller is notiﬁed that ehas been
emitted. The controller then queries the repair policy for
the action a/primeassociated with e.I fa/prime≡ DISP A TCH , then
all event handlers associated with eare triggered, and the
controller is notiﬁed that ehas been dispatched. Otherwise,
a/prime∈{ DISCARD,POSTPONE }, and the execution of the appli-
cation’s event handlers and other possible side-effects of the
event (e.g., the insertion of a character into a text ﬁeld) are pre-
vented by calling stopImmediatePropagation andpreventDefault
on the event object of e. Furthermore, if a/prime≡POSTPONE , then
the process is repeated by re-dispatching easynchronously.
B. Intercepting relevant operations
EventRaceCommander intercepts fork ,begin and end in-
structions. Operations of type fork are intercepted by replac-
ing certain browser API functions and intercepting property
assignments. For example, the send function on the prototype
ofXMLHttpRequest is replaced by a function that, in addition to
sending the request, notiﬁes the event controller that an Ajax
response event has been forked.
It is insufﬁcient to monitor events for which the program has
an event handler: in order to enforce, e.g., Pasync,ﬁfo , all Ajax
response events must be intercepted, even those that have no
response event handler. EventRaceCommander therefore adds
a default event handler for such events.
VII. E V ALUA TION
We aim to answer the following research questions.
RQ1: How effective is each of the application-independent
policies of Section V at repairing event race errors?
RQ2: What is the impact of each application-independent re-
pair policy on runtime performance and user experience?
RQ3: Is it possible to reduce runtime overhead and improve
user experience using application-speciﬁc policies?
A. Experimental Methodology
Selecting event race errors :We use existing tools, such
as, EventRacer [25] and R4[11], to identify candidate event
races in the web applications of the 20 largest companies
from the Fortune 500 list. Since front pages of many websites
294
295
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:08 UTC from IEEE Xplore.  Restrictions apply. often contain little dynamic behavior, we manually explore the
selected sites to ﬁnd interesting pages.
Following Mutlu et al. [20], we focus on observable races
that result in errors, such as, uncaught exceptions or visual
differences so that we can conﬁrm the effectiveness of our
repairs. In order to keep the amount of work manageable,
we examine up to 25 candidate races for each website to
identify whether they are observable. Altogether this gives us
117 errors that are caused by observable races.
Selecting application-independent repair policies :We
study each observable race in detail to identify which of
the application-independent repair policies that can repair the
corresponding error.
Measuring instrumentation overhead :For each web-
site, we create an application-independent policy that repairs
all race errors (possibly by combining multiple application-
independent policies), and measure the overhead of that policy.
We use the Chrome Debugging Protocol [2] to measure:
(i)parsing time (i.e., time to DOMContentLoaded ), showing the
cost for loading EventRaceCommander and instrumenting the
source, and (ii) layout time (i.e., time to last layout event
during initialization). In this experiment, we prevent layout
events from triggering indeﬁnitely (e.g., due to a slideshow)
by stopping recursive timer registrations and intervals so that
every web application terminates. We report the mean of 50
repetitions in each case.
User experience :Parsing time and layout time indirectly
reﬂect the user’s experience: most elements are ready for
user interactions after a page has been parsed, and layout
time reﬂects perceived responsiveness. In a few cases where
application-independent policies are inadequate because of
undesirable impact on the user experience, we attempt to
design application-speciﬁc versions of application-independent
policies that do no exhibit similar problems. For each such
case, we attempt to evaluate the impact on user experience
by comparing the delays in event processing for application-
independent and application-speciﬁc policies.
System details :We run the experiments on Ubuntu 15.10
with an Intel Core i7-3770 CPU and 16 GB RAM.
Table I shows the sites and races used to evaluate
EventRaceCommander .2The “Race errors” column presents
the total number of observable races found in each site. The
“Race classiﬁcation” columns classify these races. Most of
the observable races that we found are initialization races,
and nearly all of these involve user events, except a race
onatt.com , where two dependent scripts are loaded without
any ordering, and on exxon.com , where an iframe load event
handler is registered late. Late event handler registrations tend
to be a recurring problem. We also identify multiple post-
initialization races. These typically cause a web application to
end up in an inconsistent state.
2We did not detect any observable races on berkshirehathaway.com ,
valero.com ,unitedhealthgroup.com , andkroger.com . Those sites are
excluded from the table.B. Experimental Results
RQ1 :The “Repair policy” columns of Table I reﬂect the
applicability of the application-independent policies. If, for a
given site, an event race riappears in the column of repair
policyP, thenPrepairs the error caused by ri. Otherwise,
no application-independent policy prevents ri, and the race ap-
pears in the “None” column. In our experiments, allobservable
races that could not be repaired using application-independent
policies involve indirect user inputs (Section V -D). These races
are relatively harmless (e.g., dropdowns that do not unfold
when the user hovers a menu item with the cursor during
loading). Note that races with the same classiﬁcation tend to
be prevented using the same policies. This is to be expected,
sincePinit,user ,P+
init,user andPinit,system target initialization races,
unlikePasync,ﬁfo andPasync,user .
Although we cannot guarantee that our application-
independent policies always sufﬁce, our results suggest that
the policies can prevent most event race errors in practice:
94 of the 117 event race errors are repairable using our
application-independent policies .
This also suggests that, although EventRaceCommander
relies on a light-weight instrumentation, it provides sufﬁcient
control of the nondeterminism to prevent the races that occur in
practice. Furthermore, the results indicate that our assumption
of what “good” schedules are (Section II-B) agrees with de-
velopers’ expectations (otherwise, our policies would enforce
erroneous schedules).
Table I shows that many race errors can be repaired using
more than one application-independent policy. Not surpris-
ingly, many races can be repaired using both Pinit,user and
P+
init,user , but we also ﬁnd that Pasync,ﬁfo andPasync,user often
repair the same race. This happens when a user triggers an
asynchronous event (e.g., an Ajax request) twice. The policy
Pasync,ﬁfo avoids such races by enforcing an order among the
unordered events, whereas Pasync,user postpones user events
while an asynchronous event is pending (thereby ensuring that
event handlers and their forked events execute atomically).
RQ2 :The last two columns of Table I show parsing and
layout time. For most sites, the instrumentation overhead is
less than 200ms, which we deem to be acceptable. Small
websites exhibit larger relative overheads due the cost of
including EventRaceCommander ’s 32 KB of JavaScript. The
absolute overhead is barely noticeable by a user, though.
Regarding user experience, it is important to interrupt only
user events that are involved in races, and only for as long as
is necessary to prevent undesirable schedules. Generally, we
ﬁnd that the policies Pinit,system andPasync,ﬁfo can be enforced
obliviously to the user, since they do not involve user events
and, in our experiments, do not signiﬁcantly postpone UI
updates. There is often room for improvements over Pinit,user ,
Pasync,user , andP+
init,user , since the operation predicates in these
policies are overly general. This is mostly a problem for
P+
init,user in sites that extensively load code asynchronously
(e.g., walmart.com , which uses RequireJS [4]). In such cases,
the page appears to be ready signiﬁcantly before user input
is tolerated, and an application-speciﬁc policy should be used
295
296
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:08 UTC from IEEE Xplore.  Restrictions apply. Race classiﬁcation Repair policy Instrumentation overheadRace errors
Pinit,user
P+
init,user
Pinit,system
Pasync,ﬁfo
Pasync,userInitialization
racesPost-init.
races
Websitedeclare/
eventregister/
eventupdate/
eventsystem/
user None Parsing (ms) Layout (ms)
walmart.com 14 r1...r13 r14 r1...r10 r14r14r11...r13 +609 (1.29x) +247 (1.08x)
exxon.com 7 r1...r6 r7r1...r5r1...r5r6r7r7 +20 (1.02x) +23 (1.01x)
chevron.com 8 r1...r6 r7...r8 r7...r8r7...r8r1...r6 +88 (1.12x) +176 (1.13x)
apple.com 3 r1...r2 r3r1...r2r1...r2 r3r3 +69 (1.11x) +65 (1.10x)
gm.com 8 r1...r6r7r8r1...r6r1...r7 r8r8 +60 (1.08x) +60 (1.08x)
phillips66.com 3r1...r2 r3 r1r1...r2 r3r3 +87 (1.14x) +31 (1.04x)
ge.com 10 r1...r7r8...r10r1r2...r7r8...r10r8...r10 +124 (1.08x) +207 (1.13x)
ford.com 1 r1 r1r1 +154 (1.06x) +155 (1.06x)
cvshealth.com 10 r1...r8 r9...r10r1...r7r1...r7r9...r10r9...r10r8 -24 (0.98x) -14 (0.99x)
mckesson.com 2r1 r2 r1...r2r1...r2 +101 (1.08x) +7 (1.00x)
att.com 12r1...r2r3...r12 r3...r12r3...r12r1...r2 +723 (1.21x) +699 (1.20x)
verizonwireless.com 13r1...r13 r1...r13r1...r13 +360 (1.15x) +266 (1.12)
amerisourcebergen.com 4 r1...r4 r1...r4r1...r4 +13 (1.04x) +12 (1.03x)
fanniemae.com 5 r1...r5 r1...r5r1...r5 +143 (1.26x) +70 (1.10x)
costco.com 16 r1...r16 r1...r3r1...r3 r4...r16 +92 (1.11x) +45 (1.03x)
hp.com 1 r1 r1r1 +35 (1.01x) +37 (1.01x)
total 117 18 78 9 12 61 78 1 14 12 23
T ABLE I
OBSERV ABLE RACES ,APPLICABILITY OF APPLICA TION -INDEPENDENT REP AIR POLICIES ,AND INSTRUMENT A TION OVERHEAD .
Race classiﬁcation :declare/event : an entity may be used before it is declared, triggering an error (e.g., scenario B/circlecopyrt).register/event : an event handler may be
registered late, leading to lost events (e.g., scenario A/circlecopyrt, lines 47–51). update/event : a form ﬁeld may be updated asynchronously, overwriting the user’s input
(e.g., lines 54–63). system/user : a system and user event are unordered, leading to an error or erroneous state (e.g., scenario C/circlecopyrt).
to target the relevant user events, and minimize the time in
which the user is disrupted.
Interestingly, we ﬁnd that some of the websites, e.g. apple.
com , prevent races in ways similar to Pasync,user , by showing a
spinner that takes up most space on the screen, when a user
event leads to asynchronous DOM updates.
RQ3 :We now brieﬂy report on two event races where
application-independent repair policies yield suboptimal re-
sults, and discuss how each situation can be remedied using
an application-speciﬁc policy.
Onatt.com , event race r1can cause a TypeError due
to two scripts being unordered.3PolicyPasync,ﬁfo ensures
that asynchronous scripts are executed in FIFO order and
ﬁxes the error, but unnecessarily imposes an order on 39
scripts. On average, 21 of these scripts are postponed for
292ms. This can be prevented using a specialized policy
P/prime
async,ﬁfo , which only postpones the execution of satellite-
567046aa64746d0712008241.js . On average, this policy post-
pones no scripts at all (i.e., in our experiments, the two scripts
always load in the desired order).
Onwalmart.com ,aclick event handler of a button is
registered by an asynchronous script. Until that happens, click
events on the button are lost and no dropdown is shown
(event race error r13). While this problem can be ﬁxed using
the application-independent policy P+
init,user , this results in
excessive delays for processing a click event. We can avoid
such undesirable impact on the user experience by designing
an application-speciﬁc policy Pspec that postpones click events
only until the handler is present. In an experiment, we issue
3The global variable s_att is declared in s-code-contents-
65778bc202aa3fe01113e6b6ea6d103eda099fe5.js , and used in
satellite-567046aa64746d0712008241.js . The latter may, depending
on the event order, crash during an assignment to s_att.events .a click immediately when the button is declared, and measure
the time until the corresponding event handlers execute. On
average, the click event is dispatched 817ms faster when using
the policy Pspec instead of P+
init,user .
The application-speciﬁc repair policies discussed above are
both “optimal” in the sense that they only postpone events that
are involved in the races under consideration, for the minimal
amount of time required to prevent the undesired orders. We
argue that, for these race errors, enforcing repair policies using
EventRaceCommander compares well to alternative solutions
such as modifying the code to introduce ad-hoc synchroniza-
tion or explicitly load scripts synchronously.
C. Discussion
Some aspects of our evaluation may affect the generality
of the reported results. Most signiﬁcantly, the selection of
websites and event race errors used in our evaluation could
be subject to bias. We have attempted to address this concern
by evaluating EventRaceCommander on the websites of the
20 largest companies from the Fortune 500 list, similar to
previous work on event race detection [11, 25].
The code of the websites used in our evaluation may be sub-
ject to change, which may affect reproducibility of our results.
Therefore, we spent signiﬁcant effort using mitmproxy [3]
to record the server responses for an interaction with every
site under consideration. This enables reproducibility for all
front pages. Regrettably, some highly dynamic pages that we
consider cannot be replayed, since the URLs of Ajax requests
depend on user input, random numbers, timestamps, etc. Still,
this is a signiﬁcant improvement over recent work [8, 10, 11,
21, 22, 25, 28, 34], where the importance of reproducibility
has mostly been ignored. The recordings from our study are
available with the implementation of EventRaceCommander .
296
297
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:08 UTC from IEEE Xplore.  Restrictions apply. A related concern is that real websites may give rise to
unpredictable network delays, which may affect repair poli-
cies, such as, Pasync,ﬁfo . In principle, these delays can become
arbitrarily large, so the data from our experiments may not
truly reﬂect the impact on user experience. In our experiments,
we avoid large ﬂuctuations by relying on recordings of every
website, and by conducting experiments 50 times and reporting
average times. To prevent situations where the user is being
disrupted for too long, it would be possible to monitor if
EventRaceCommander postpones an event for more than a
given threshold. In such cases, the event could simply be
dispatched, and the users of EventRaceCommander could be
notiﬁed of the incident, so that the policy can be adjusted.
VIII. R ELA TED WORK
Race detection: Ide et al. [10] pointed out that JavaScript
programs can have data races despite being single-threaded
and non-preemptive. Such races often arise due to asyn-
chronous Ajax communication and HTML parsing. The au-
thors note regarding Ajax races that “the programmer prefers
to think of the interaction with the server as a synchronous
call”, which is also the foundation for our scheduling policies
for such races. Zheng et al. [34] proposed a static analysis
for automatically detecting JavaScript races. Due to the dy-
namic nature of JavaScript, such static analyses are often pro-
hibitively imprecise or unscalable. Inspired by successful tech-
niques developed for multi-threaded programs [7], WebRacer
and EventRacer instead use dynamic analysis and a happens-
before relation [22, 25]. This signiﬁcantly improves precision,
however, these tools cannot distinguish harmful from benign
races, which has motivated techniques that explore whether
races cause observable differences [8, 11, 21]. Still, these
techniques tend to report many false positives and also miss
harmful races, and it has been observed that the harmful races
that are detected are often difﬁcult to ﬁx.
Event race detection algorithms have also been devel-
oped for Android, using similar techniques as those target-
ing JavaScript, but with more sophisticated happens-before
relations [5, 9, 19]. Adapting our technique to Android is an
interesting opportunity for future work.
Automated ﬁxing of race errors: The idea of automati-
cally ﬁxing race errors has been studied extensively in a multi-
threaded setting, but not much for event-driven applications,
in particular JavaScript.
Some techniques patch the program code by inserting,
e.g., locks and wait-signal operations, based on reports from
race detectors and static analysis [12–16, 29]. The JavaScript
platform provides no explicit synchronization primitives, but
our repair policy mechanism can simulate the effect of having
wait-signal primitives or atomic groups of event handlers.
Other techniques steer away from nondeterministic errors
by postponing selected actions, much like our approach but
for multi-threaded programs. The AI technique [32] attempts
to stall threads where manifestation of a concurrency bug is
about to become deterministic. Kivati [6] uses static analysis
and hardware watchpoints to detect atomicity violations andthen dynamically reorders the relevant instructions. The Aviso
system [17] learns schedule constraints from successful and
failing executions, and then uses these constraints to guide
scheduling, much like our policy mechanism and controller.
The Loom system [30] uses a notion of execution ﬁlters, which
resembles our use of application-speciﬁc repair policies.
These techniques share the limitation of EventRace-
Commander that they cannot ﬁx all race errors while entirely
avoiding situations where actions are postponed excessively.
Other approaches include rollback-recovery [33], replicated
execution with different schedules [27], replication of shared
state in critical sections [23, 24], or require special hard-
ware [18], which would not be realistic for JavaScript.
EventHealer [26], unlike most of the work mentioned above,
considers event-driven programs, but with a different execution
model than the one in JavaScript: execution takes place in a
main thread, which has lower priority than event handlers,
and preemption is possible but can be selectively disabled
to protect critical sections. The system uses static analysis
to locate event handlers, shared variables, and fragments of
code that should be treated as critical sections, which is very
different from our setting.
None of the work on automated ﬁxing discussed above
targets JavaScript. A position paper by Mutlu et al. [20]
proposes a notion of “schedule shepherding” for JavaScript,
but does not present any mechanism for how to actually do
it. The recent ARROW tool by Wang et al. [28] is the ﬁrst
to automatically repair races in JavaScript applications. The
key difference to EventRaceCommander is that ARROW is
based on static analysis, which is notoriously difﬁcult for real-
world JavaScript code. Moreover, the main idea in ARROW
is to identify inconsistencies between the happens-before and
def-use relations, which may miss many race errors, even if
more powerful static analysis were developed. ARROW cannot
repair any of the errors in the example application in Section II.
IX. C ONCLUSION
We have presented a general framework for controlling
nondeterminism in event-driven applications using speciﬁed
repair policies, and proposed application-independent policies
to prevent nondeterminism that commonly triggers event race
errors. The framework is sufﬁciently general to repair a wide
variety of real-world event race errors. Our experimental re-
sults show that 94 of 117 event race errors are repairable by our
application-independent policies, and that application-speciﬁc
policies are useful to target speciﬁc races, when needed.
For future work, it will be interesting to automate the
process of inferring application-speciﬁc policies for a given
event race, to avoid negative impacts from overly general
policies. Such candidate policies should restrict the nonde-
terminism only as needed to repair a given race, but still
be reasonably general, so that they do not only apply to the
concrete execution explored by the dynamic race detector.
Acknowledgments This work was supported by the European
Research Council (ERC) under the European Union’s Horizon 2020
research and innovation program (grant agreement No 647544).
297
298
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:08 UTC from IEEE Xplore.  Restrictions apply. REFERENCES
[1] W3C Document Object Model Level 2 Events Speciﬁcation.
http://www.w3.org/TR/DOM-Level-2-Events/events.
html#Events-flow , last accessed on 2016/08/24.
[2] Chrome Debugging Protocol. https://developer.chrome.
com/devtools/docs/debugger-protocol , last accessed on
2016/08/24.
[3] mitmproxy. https://mitmproxy.org/ , last accessed on
2016/08/24.
[4] RequireJS. http://requirejs.org/ , last accessed on 2016/08/24.
[5] P . Bielik, V . Raychev, and M. T. V echev. Scalable race detection for
Android applications. In Proc. 30th ACM SIGPLAN International
Conference on Object-Oriented Programming, Systems, Languages,
and Applications (OOPSLA) , 2015.
[6] L. Chew and D. Lie. Kivati: fast detection and prevention of
atomicity violations. In Proc. 5th European Conference on Computer
Systems (EuroSys) , 2010.
[7] C. Flanagan and S. N. Freund. FastTrack: efﬁcient and precise
dynamic race detection. Commun. ACM , 53(11), 2010.
[8] S. Hong, Y . Park, and M. Kim. Detecting concurrency errors in
client-side Java Script web applications. In Proc. 7th IEEE Inter-
national Conference on Software Testing, V eriﬁcation and V alidation
(ICST) , 2014.
[9] C. Hsiao, C. Pereira, J. Y u, G. Pokam, S. Narayanasamy, P . M.
Chen, Z. Kong, and J. Flinn. Race detection for event-driven
mobile applications. In Proc. 35th ACM SIGPLAN Conference on
Programming Language Design and Implementation (PLDI) , 2014.
[10] J. Ide, R. Bodik, and D. Kimelman. Concurrency concerns in rich
internet applications. In Proc. Workshop on Exploiting Concurrency
Efﬁciently and Correctly , 2009.
[11] C. S. Jensen, A. Møller, V . Raychev, D. Dimitrov, and M. T. V echev.
Stateless model checking of event-driven applications. In Proc.
30th ACM SIGPLAN International Conference on Object-Oriented
Programming, Systems, Languages, and Applications (OOPSLA) ,
2015.
[12] G. Jin, L. Song, W . Zhang, S. Lu, and B. Liblit. Automated atomicity-
violation ﬁxing. In Proc. 32nd ACM SIGPLAN Conference on
Programming Language Design and Implementation (PLDI) , 2011.
[13] G. Jin, W . Zhang, and D. Deng. Automated concurrency-bug ﬁxing.
InProc. 10th USENIX Symposium on Operating Systems Design and
Implementation (OSDI) , 2012.
[14] S. Khoshnood, M. Kusano, and C. Wang. ConcBugAssist: constraint
solving for diagnosis and repair of concurrency bugs. In Proc.
International Symposium on Software Testing and Analysis (ISSTA) ,
2015.
[15] B. Krena, Z. Letko, R. Tzoref, S. Ur, and T. V ojnar. Healing data
races on-the-ﬂy. In Proc. 5th Workshop on Parallel and Distributed
Systems: Testing, Analysis, and Debugging (PADTAD) , 2007.
[16] P . Liu and C. Zhang. Axis: Automatically ﬁxing atomicity violations
through solving control constraints. In Proc. 34th International
Conference on Software Engineering (ICSE) , 2012.
[17] B. Lucia and L. Ceze. Cooperative empirical failure avoidance for
multithreaded programs. In Architectural Support for Programming
Languages and Operating Systems (ASPLOS) , 2013.
[18] B. Lucia, J. Devietti, L. Ceze, and K. Strauss. Atom-Aid: Detecting
and surviving atomicity violations. IEEE Micro , 29(1), 2009.[19] P . Maiya, A. Kanade, and R. Majumdar. Race detection for Android
applications. In Proc. 35th ACM SIGPLAN Conference on Program-
ming Language Design and Implementation (PLDI) , 2014.
[20] E. Mutlu, S. Tasiran, and B. Livshits. I know it when I see it:
Observable races in JavaScript applications. In Proc. Workshop on
Dynamic Languages and Applications (Dyla) , 2014.
[21] E. Mutlu, S. Tasiran, and B. Livshits. Detecting JavaScript races
that matter. In Proc. 10th Joint Meeting on F oundations of Software
Engineering (ESEC/FSE) ,2015.
[22] B. Petrov, M. T. V echev, M. Sridharan, and J. Dolby. Race detection
for web applications. In Proc. 33rd ACM SIGPLAN Conference on
Programming Language Design and Implementation (PLDI) , 2012.
[23] S. K. Rajamani, G. Ramalingam, V . P . Ranganath, and K. V aswani.
ISOLA TOR: dynamically ensuring isolation in concurrent programs.
InProc. 14th International Conference on Architectural Support for
Programming Languages and Operating Systems (ASPLOS) , 2009.
[24] P . Ratanaworabhan, M. Burtscher, D. Kirovski, B. G. Zorn, R. Nag-
pal, and K. Pattabiraman. Efﬁcient runtime detection and toleration
of asymmetric races. IEEE Trans. Computers , 61(4), 2012.
[25] V . Raychev, M. T. V echev, and M. Sridharan. Effective race de-
tection for event-driven programs. In Proc. 28th ACM SIGPLAN
International Conference on Object Oriented Programming Systems
Languages, and Applications (OOPSLA) , 2013.
[26] G. M. Tchamgoue, K. H. Kim, and Y . Jun. EventHealer: Bypassing
data races in event-driven programs. Journal of Systems and Soft-
ware , 118, 2016.
[27] K. V eeraraghavan, P . M. Chen, J. Flinn, and S. Narayanasamy.
Detecting and surviving data races using complementary schedules.
InProc. 23rd ACM Symposium on Operating Systems Principles
(SOSP) , 2011.
[28] W . Wang, Y . Zheng, P . Liu, L. Xu, X. Zhang, and P . Eugster.
ARROW: Automated repair of races on client-side web pages. In
Proc. International Symposium on Software Testing and Analysis
(ISSTA) , 2016.
[29] D. Weeratunge, X. Zhang, and S. Jagannathan. Accentuating the
positive: atomicity inference and enforcement using correct execu-
tions. In Proc. 26th ACM SIGPLAN Conference on Object-Oriented
Programming, Systems, Languages, and Applications (OOPSLA) ,
2011.
[30] J. Wu, H. Cui, and J. Y ang. Bypassing races in live applications
with execution ﬁlters. In Proc. 9th USENIX Symposium on Operating
Systems Design and Implementation (OSDI) , 2010.
[31] Z. Yin, D. Y uan, Y . Zhou, S. Pasupathy, and L. N. Bairavasundaram.
How do ﬁxes become bugs? In Proc. 13th European Software
Engineering Conference and 19th ACM SIGSOFT Symposium on the
F oundations of Software Engineering (ESEC/FSE) , 2011.
[32] M. Zhang, Y . Wu, S. Lu, S. Qi, J. Ren, and W . Zheng. AI:
a lightweight system for tolerating concurrency bugs. In Proc.
22nd ACM SIGSOFT International Symposium on F oundations of
Software Engineering (FSE) , 2014.
[33] W . Zhang, M. de Kruijf, A. Li, S. Lu, and K. Sankaralingam.
ConAir: featherweight concurrency bug recovery via single-threaded
idempotent execution. In Architectural Support for Programming
Languages and Operating Systems (ASPLOS) , 2013.
[34] Y . Zheng, T. Bao, and X. Zhang. Statically locating web application
bugs caused by asynchronous calls. In Proc. 20th International
Conference on World Wide Web (WWW) , 2011.
298
299
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:08 UTC from IEEE Xplore.  Restrictions apply. 