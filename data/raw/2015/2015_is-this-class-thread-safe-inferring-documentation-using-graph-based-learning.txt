Is This Class Thread-Safe?
Inferring Documentation using Graph-Based Learning
Andrew Habib
andrew.a.habib@gmail.com
Department of Computer Science
TU Darmstadt
GermanyMichael Pradel
michael@binaervarianz.de
Department of Computer Science
TU Darmstadt
Germany
ABSTRACT
Thread-safe classes are pervasive in concurrent, object-oriented
software. However, many classes lack documentation regarding
their safety guarantees under multi-threaded usage. This lack of
documentationforcesdeveloperswhouseaclassinaconcurrent
programtoeithercarefullyinspecttheimplementationoftheclass,
to conservatively synchronize all accesses to it, or to optimistically
assumethattheclassisthread-safe.Toovercomethelackofdoc-
umentation, we present TSFinder, an approach to automatically
classify classes as supposedly thread-safe or thread-unsafe. Thekey idea is to combine a lightweight static analysis that extracts
agraphrepresentationfromclasseswithagraph-basedclassifier.
Aftertrainingtheclassifierwithclassesknowntobethread-safe
andthread-unsafe,itachievesanaccuracyof94.5%onpreviously
unseen classes, enablingthe approach to infer thread safety docu-
mentationwithhighconfidence.Theclassifiertakesabout3secondsperclass,i.e.,itisefficientenoughtoinferdocumentationformany
classes.
CCS CONCEPTS
‚Ä¢Softwareanditsengineering ‚ÜíSynchronization ;Reusabil-
ity;Documentation ;Automated static analysis ;Object oriented
development ; Software maintenance tools;
KEYWORDS
inferring documentation, thread-safe class, graph-based learning
ACM Reference Format:
AndrewHabibandMichaelPradel.2018.IsThisClassThread-Safe?Inferring
DocumentationusingGraph-BasedLearning.In Proceedingsofthe201833rd
ACM/IEEEInternationalConferenceonAutomatedSoftwareEngineering(ASE
‚Äô18), September 3‚Äì7, 2018, Montpellier, France. ACM, New York, NY, USA,
12pages.https://doi.org/10.1145/3238147.3238212
1 INTRODUCTION
Thread-safeclassesarepervasive.Theyarethecornerstoneofcon-
current,object-orientedprograms.Athread-safeclassencapsulates
allnecessarysynchronizationrequiredtobehavecorrectlywhen
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
¬© 2018 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.3238212itsinstancesareaccessedbymultipleclientthreadsconcurrently,
without additional synchronization from the calling side. Devel-
opers of multi-threaded object-oriented programs often rely on
thread-safe classes to cast away the burden of ensuring the thread
safety of their applications.
Unfortunately, it is not always clear to a developer who uses
aclasswhethertheclassisthread-safeornot.Thereasonisthat
many classes do not provide any or only partial information about
their thread safety. Instead, it is common to find questions on
web forums, such as Stack Overflow, about the thread safety of
a specific class. For example, one developer asked about the thread
safety of the widely used javax.xml.parsers.DocumentBuilder
class.1Anotherdeveloperquestionedthethreadsafetyofthecrucial
JDKclass java.util.Random .2Developersoftencomplainabout
the lack of thread-safety documentation. For instance, the devel-
operwhoreportedthatearlierversionsofJDKformatclassesare
notthread-safenotesthat:‚ÄúNotbeingthread-safeisasignificant
limitation on a class, with potentially dire results, and not doc-
umenting the classes as such is dangerous.‚Äù3Eventually, the ac-
cepted fix was to explicitly state in the documentation that JDK
formatclassesarenotthread-safe.Anotherdevelopercomments
onthethread-safetyof java.beans.PropertyChangeSupport and
java.beans.VetoableChangeSupport and writes:‚Äú[...] However,
thedocumentationdoesnotindicateeithertheirthread-safetyor
lack thereof. In keeping with the current documentation standards,
this point should be indicated in the class documentation.‚Äù4
The lack of adequate documentation about the thread safety of
classeshasseveralnegativeconsequences.First,adevelopermay
solve the problem by manually analyzing the classes she wants to
reuse.However,thisapproachspoilssomeofthebenefitsofreusing
an existing class because it forces the developer to inspect and
understandtheclassimplementation,breakingtheencapsulation
provided by the class API. Second, a developer may conservativelyassume that a class is not thread-safe and carefully synchronize all
concurrentaccessestotheclasstoavoidconcurrencybugs,such
asdataraces,atomicityviolations,anddeadlocks.However,ifthe
classisalreadythread-safe,thisadditionalsynchronizationimposes
additional runtime overhead and may unnecessarily limit the level
ofparallelismachievedbytheprogram.Finally,adevelopermay
optimisticallyassumeaclasstobethread-safe .However, iftheclass
turns out to not provide this guarantee, the program may suffer
fromconcurrencybugs,e.g.,[ 1‚Äì3],whichoftenbecomeapparent
1https://www.stackoverflow.com/questions/56737
2https://www.stackoverflow.com/questions/5819638
3https://bugs.java.com/view_bug.do?bug_id=4264153
4https://bugs.java.com/view_bug.do?bug_id=5026703
41
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Andrew Habib and Michael Pradel
only under specific interleavings and therefore may easily remain
unnoticedduringtesting.Inallthreescenarios,thedevelopertakes
apoorlyguideddecisionthatreliesonherlimitedunderstanding
of an implementation or on luck.
This paper addresses the problem of missing thread safety docu-
mentation by automatically classifying a given class as thread-safe
or thread-unsafe. Our approach, called TSFinder, is a statistical,
graph-based learning technique that learns from a relatively small
setofclassesknowntobethread-safeorthread-unsafethedistin-
guishing properties of these two kinds of classes. The approach is
enabled by two contributions. First, TSFinder uses a lightweight
staticanalysisofthesourcecodeoftheclasstoextractinformation
andrepresentthisinformationinagraph.Second,weusegraph-
basedclassificationtechniques‚Äìgraphkernels[ 65]combinedwith
supportvectormachine(SVM)[ 56]tolearna classifierforprevi-
ously unseen classes. TSFinder helps developers assess the thread
safetyofanotherwiseundocumentedclass,enablingadeveloper
to take an informed decision on whether and how to use the class.
Our work is complementary to techniques for finding concur-
rencybugs,whichhasbeenextensivelystudiedinthepast[ 7,13,
18,19,35,36,42,55,68,71,78], in particular in the context of
thread-safe classes [ 14,41,44,51‚Äì53,61]. These approaches con-
sider supposedly thread-safe classes and try to find corner cases in
theirimplementationthatadeveloperhasmissed.Instead,TSFinder
addressesclassesforwhichitisunknownwhethertheclassiseven
supposed to be thread-safe and tries to answer that question in
anautomaticway.Applyingexistingbugdetectiontechniquesto
answerthisquestionwouldlikelyresultinmissingthread-unsafe
classes(bytesting-basedapproaches)ormissingthread-safeclasses
(bysoundstaticanalyses).Ourworkalsorelatestoexistingworkon
inferring [ 5,26] and improving [ 27,37,63,81] documentation. We
extend this stream of work to concurrency-related documentation,
which has not yet been studied.
Ourevaluationconsistsoftwoparts.First,wevalidateourhy-
pothesis that existing classes lack thread safety documentation
bysystematicallysearchingall179,239classesintheQualitascor-
pus[60].Wefindthatthevastmajorityofclassesfailstodocument
whether it is thread-safe or not. Second, we evaluate our classifier
with 230 training classes that were manually labeled as thread-safe
or thread-unsafe. We find that 94.5% of TSFinder‚Äôs classification
decisions are correct. In particular, the precision and recall of iden-
tifying thread-safe classes are 94.9% and 94.0%, respectively. Onaverage, adding documentation to a new class takes about 3 sec-
onds.Theseresultsshowthattheapproachisaccurateenoughto
significantlyimproveoverguessingwhetheraclassisthread-safe
and efficient enough to scale to large sets of classes.
In summary, this paper makes the following contributions:
‚Ä¢Asystematicstudyofthread-safetydocumentationinreal-
world Java classes showing the lack of such documentation.
‚Ä¢The first automated classifier to distinguish supposedly
thread-safeandthread-unsafeclasses,anunderstudiedprob-
lem that addresses the lack of thread safety documentation.
‚Ä¢A novel combination of static analysis and graph-based clas-
sification that accurately and efficiently predicts the threadsafety of a class.
	

				
	

 		 			 !
	 !	


"


Figure 1: Overview of TSFinder: Inferring thread safety us-
ing static analysis and graph kernels.
In Section 2, we give an overview of TSFinder. Sections 3and4
fillinthedetails.Sections 5and6summarizetheimplementation
andevaluation.Sections 7and8discussthelimitationsofTSFinder
andandrelatedwork.Finally,inSection 9weconcludethepaper
and discuss future work.
2 CHALLENGES AND OVERVIEW
Thegoal ofthis workis toautomatically documentclasses assup-
posedlythread-safeorthread-unsafe.Theapproachshouldbeef-
ficientenoughtoscaletohundredsofclasses,e.g.,allclassesina
3rd-partylibrary,andaccurateenoughtoprovidereliabledocumen-
tation. Achieving this goal is challenging for several reasons. First,
there are different approaches for ensuring that a class is thread-safe, e.g., making the class immutable, using language-level syn-
chronizationprimitives,buildingonotherthread-safeclasses,using
lock-free data structures, and combinations of these approaches.
Becauseofthisdiversity,asimplecheck,e.g.,forwhetheraclasshas
synchronized methods, is insufficient to determine thread safety.
Second, the thread safety of a class may depend on other classes.
In particular, inheriting from a thread-unsafe class may compro-
misethethreadsafetyofthechildclass.Third,extensivereasoning
about concurrent behavior, e.g., to reason about different inter-leavings [
66], can easily require large amounts of computational
resources, which conflicts with our scalability goal.
Figure1providesanoverviewofourapproachtoinferthread
safetydocumentation.Theapproachconsistsofatrainingphase,
whereitlearnsfromasetofclassesknowntobethread-safeand
thread-unsafe, and a prediction phase, where it infers thread safetydocumentation for a previously unseen class. Both phases combine
a lightweight static analysis that extracts graph representations of
classeswithagraph-basedclassifier.Thegraph-basedclassification
converts graphs into vectors by computing the similarity between
graphsofato-be-classifiedclassandgraphsinthetrainedmodel.
These vectors are then classified using a model based on a support
vector machine (SVM). The following illustrates the main steps of
TSFinder using the Java class in Figure 2a.
Extractingfield-focusedgraphs. Toapplymachinelearningtothe
threadsafetyclassificationproblem,weneedtorepresentclasses
inasuitableform.Ourapproachexploitsthestructurednatureof
programs by representing a class as a set of graphs. Since multi-
threadingismainlyaboutsharingandallowingmultipleconcurrent
42
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. Is This Class Thread-Safe? ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
public class Sequence {
private volatile int seq;
private int MAX;
public Sequence(int m) {
M A X=m ;
reset();
}
public synchronized
int next() {
if(!isMax())
return seq++;
return -1;
}boolean isMax() {
return seq > MAX;
}
void reset() {
s e q=0 ;
}
}
(a) Java class.
next()
Sequence(int)
isMax()
seq
	
 


		
	




				

next()

Sequence(int)

MAX
	
 


		



isMax()

	

next()Sequence(int)
isMax() 
seq
	
 



reset() 		
	






				
MAX




reset() 
(b) Extracted graphs. The graphs from left to right correspond to fields seq, MAX, and the pair (seq,
MAX), respectively. The identifier names, in italic and blue font, are not used for classification, but
shown only for illustration.
–¥1–¥2...–¥4860 –¥1–¥2...–¥4860 –¥1–¥2...–¥4860 /bracketleftbig
0.350 0.436...0.573/bracketrightbig/bracketleftbig
0.355 0.536...0.584/bracketrightbig/bracketleftbig
0.392 0.588...0.567/bracketrightbig
(c) Vectors of the three graphs in Figure 2b. The trained model has 4,860 graphs in it.
min(–¥1)max(–¥1)av–¥(–¥1)min(–¥2)max(–¥2)av–¥(–¥2)...av–¥(–¥4860)/bracketleftbig
0.350 0 .392 0 .366 0 .436 0 .588 0 .520...0.575/bracketrightbig
(d) Class vector of the entire class.
Figure 2: A Java class and graphs extracted from it by our analysis. TSFinder predicts this class to be thread-safe.
accessestoresources,thegraphsrepresentsharedresourcesand
how these resources are accessed.
For the example class, Figure 2b shows the graphs extracted by
TSFinder. Each graph focuses on a single field or a combination of
fields of the class. The graphs represent read and write accesses
to the fields, call relationships between methods, and the use of
synchronization primitives, such as the synchronized keyword.
For example, the first graph in Figure 2b which focuses on the seq
fieldshowsthatthefieldisreadbythe isMaxmethod,writtenby
theresetmethod, and both read and written by the nextmethod.
Furthermore, the graph represents the call relationship between
nextandisMax.
Computing graph kernels. After extracting a set of graphs for
each class under analysis, TSFinder checks for each graph whether
itissimilartographsthatcomefromthread-safeorfromthread-
unsafeclasses.Tothisend,weusethegraphkernels[ 65],i.e.,math-
ematical functions that compute the pairwise similarity of graphs.
TSFindercomputesthesimilarityof eachgraphofaclassandthe
graphs of classes known to be thread-safe or thread-unsafe. The
similarity values yield a vector of numbers, called the graph vector
orembedding. For the running example, the approach computes
three graph vectors, one for each graph, as illustrated in Figure 2c.
Learning a classification model. To train a classifier that can dis-
tinguishthread-safeclassesfromthread-unsafeclasses,TSFinder
trains a model using a corpus of classes with known thread safety.
The approach combines all graph vectors of a class into a singlevector,called classvector,thatrepresentstheentireclass(Figure2d)
along with a label denoting whether the class is thread-safe or not.
Finally, the labeled class vectors are used to train a classification
model that distinguishes between the two kinds of classes.
Classifyinganewclass. Givenanewclass,ourapproachextracts
graphsandcomputesaclassvectorasinthepreviousstep.Basedon
thetrainedmodel,TSFinderthenclassifiestheclassbyqueryingthemodelwiththisvector.For Figure2,TSFinderinfersthattheclassis
thread-safe and adds this information to the class documentation.
3 EXTRACTING FIELD-FOCUSED GRAPHS
The first step of our approach is to extract graphs from classes via
alightweightstaticanalysis.Thissectionexplainstheproperties
extractedbythestaticanalysis(¬ß3.1)andhowwesummarizethese
properties into graphs (¬ß 3.2).
3.1 Static Analysis
TSFinderperformsalightweightstaticanalysisthatextractsvar-
ious properties of a class under analysis. We focus on two kinds
ofproperties: unaryproperties,whichdescribeprogramelements
of the class, and binary properties , which describe relationships be-
tween program elements and properties of program elements. We
choose properties relevant for concurrency, e.g., memory locations,accesses to memory locations, and memory visibility guarantees of
these accesses.
43
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Andrew Habib and Michael Pradel
3.1.1 UnaryProperties. Thestaticanalysisextractsthefollow-
ing unary properties from each class:
Definition 3.1 (Unary properties). LetCbe the class under analy-
sis.LetCfbethesetoffields, Cmbethesetofmethods,and Cconst
bethesetofclassconstructorsandstaticconstructorsdefinedby
C. The set of unary properties of Cis:
Cunary=Cf‚à™Cm‚à™Cconst
Forexample,ourapproachextractsfromtheclassin Figure2a
the following set of unary properties:
Cf={seq,MAX},Cm={next(),isMax(),reset()}
and
Cconst={Sequence (int)}
3.1.2 Binary Properties. To capture relationships between pro-
gram elements and properties of program elements, the analysis
extracts several binary properties:
Definition3.2(Binaryproperties). LetCbetheclassunderinspec-
tion,andCconst,Cm,Cfasdefinedabove.Wedefinethefollowing
binary relations Rels:
‚Ä¢Calls:{Cconst‚à™Cm}√ó{Cconst‚à™Cm}
‚Ä¢Reads:{Cconst‚à™Cm}√ó{Cf}
‚Ä¢Writes:{Cconst‚à™Cm}√ó{Cf}
‚Ä¢Sync:{Cm}√ó{this,lock}
‚Ä¢Mod:{Cconst‚à™Cm‚à™Cf}√ó{public,protected ,private,
static,volatile,final}
The set of binary properties of Cis:
Cbinary=Calls‚à™Reads‚à™Writes‚à™Sync‚à™Mod
The binary properties capture a rich set of relations relevant to
our thread safety prediction task, e.g., whether a method is public,
what fields a method reads and writes, and whether a method is
synchronized. The set {this,lock}represents objects that the class
uses as locks, where thisrepresents a self-reference to the current
instance and lockrepresents any other object.
For our running example in Figure 2a, the binary properties
include that the public class constructor Sequence(int) writes to
thefield MAX,thatthemethod next()readsandwritesthefield seq,
and that the method next()issynchronized onthis. Note that
theabsenceofpropertiesalsoconveysinformation.Forexample,
the absence of a binary relation (MAX,volatile)‚ààModindicates
that the MAXfield is non-volatile.
3.1.3 FlatteningtheClassHierarchy. Thethreadsafetyofaclass
notonlydependsonitsownimplementation,butalsoontheimple-
mentationofitssuperclasses.E.g.,aclassmayinheritamethodthat
doesnotsynchronizedataaccessesandthereforebecomethread-
unsafe,eventhoughthesubclassalonewouldbethread-safe[ 45].
Our static analysis addresses this challenge by flattening the class
hierarchy.Specifically,theanalysisrecursivelymergestheunary
andbinarypropertiesofeachclasswiththoseofitssuperclassuntil
reachingtherootoftheclasshierarchy.Themergingfollowsthe
inheritance rules of the Java language. For example, the properties
relatedtoasuperclassmethodthatisnotoverriddenbythesubclass
are merged into the properties of the subclass.3.2 Field-focused Graphs
Given the properties extracted by the static analysis, TSFinder
summarizesthisinformationintoasetofgraphsforeachclass.Tra-
ditionally, programs have been represented by a variety of graphs
suited for different purposes. For example, abstract syntax trees,
control-flowgraphs,andprogramdependencygraphshavebeen
usedtoanalyzethesyntax,controlflow,anddataflowofprograms.
Thefollowingpresentstwokindsofgraphsdesignedspecificallyto
reasonaboutconcurrency-relatedpropertiesofclasses.Thebasic
idea is to summarize in each graph how clients of the class may
accessafieldoracombinationoffieldsoftheclass.Wecallthese
graph representations field-focused graphs.
Before presenting field-focused graphs, we define a single graph
per class, which conflates all properties known about this class:
Definition 3.3 (Class graph). Given a class C, letCunaryand
Cbinarybe the unary and binary properties of C, respectively. The
class graph of Cis a directed multi-graph –¥C=(VC,EC), where
VC=VRels‚à™Cunary‚à™{this,lock,public,protected ,private,
static,volatile,final}areverticesthatrepresentprogramelements
and properties of them, and VRels={Calls,Reads,Writes,Sync,
Mod}are special nodes that represent the different relations in
Cbinary.Eachspecialnodeislabeledwiththenameoftherelation,
i.e.,withCalls,Reads,Writes,Sync,orModandisconnectedtoits
binary operands by the set ECof directed unlabeled edges.
Onepossible approachwould betopredict thethread safetyof
a class based on its class graph. However, most class graphs are
dissimilar from most other class graphs, independently of whetherthe classes are thread-safe, because classes and therefore also their
class graphs are very diverse. An important insight of our work is
thatthisproblemcanbeaddressedbyderivingsmallergraphsfromtheclassgraph,sothateachsmallgraphcapturesacoherentsubsetofconcurrency-relatedproperties.Theintuitionisthatthesesmaller
graphscapturerecurringimplementationpatternsofthread-safe
andthread-unsafeclasses,enablingTSFindertolearntodistinguish
them.
TSFinderderivessmallergraphsfromtheclassgraphbyfocusing
on a single field or a combination of fields:
Definition 3.4 (Field-focused graph). Given a non-empty sub-
setF‚äÜCfof the fields of a class Cand a class graph –¥C
where–¥C=(VC,EC), the field-focused graph –¥F=(VF,EF)
contains all vertices reachable from F, i.e.,VF={v|‚àÉvf‚àà
Fs.tt.reachable –¥C(vf,v)andreachable –¥C(v,vf)}, and contains
all edges connecting these vertices.
For a directed graph –¥=(V,E)whereuandv‚ààV,
reachable –¥(u,v)‚áê ‚áíthere exists a directed edge from utov.
Iftheset Fcontainsasinglefield,thenthefield-focusedgraph
captures all program elements related to this field, as well as the
relations between them. Such a single-field graph summarizes how
clients of the class may access the field and to what extent these
accesses are protected by synchronization.
For the example in Figure 2a, TSFinder extracts two graphs that
focusonsinglefields,shownasthefirsttwographsin Figure2b.
They focus on the fields seqandMAX, respectively.
44
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. Is This Class Thread-Safe? ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
Somecharacteristicsofthread-safeclassescannotbecaptured
by single-field graphs. For example, a thread-safe class may update
twosemanticallyrelatedfieldstogetheranduseasinglelockora
synchronizedmethodtoprotecttheaccesstothesefields.TSFinder
capturessuchbehaviorbyalsoconsideringsets Fofmultiplefields,
whichyieldsmulti-fieldgraphs.Specifically,theapproachconsiders
all pairs of fields for which there exists at least one method that
reads or writes from both fields. To bound the overall number of
graphsextractedperclass,wefocusonfield-focusedgraphswith
|F|‚â§2, i.e., single fields or pairs of fields.
Asanexampleofamulti-fieldgraph,considerthethirdgraph
inFigure2b.Becausetheclassmethod isMax()readsbothfields,
the approach extracts a graph that captures both fields together.
Intuitively, the reason why field-focused graphs are effective
at characterizing the thread safety of a class is that they capture
various patterns for making a class thread-safe. Whether a class
is thread-safedepends on howthe class accessesits internalstate,
i.e., its fields, and in what ways these accesses are protected by
synchronization. Field-focused graphs capture the various ways to
implementthreadsafety,e.g.,usingsynchronizedmethods,volatile
fields, or by making a class immutable. By capturing these im-plementation patterns, the graphs enable TSFinder to determine
whether a class is thread-safe.
Graphcanonicalization. Thefinalstepofextractingfield-focused
graphsfromclassesistocanonicalizethegraphs.Themotivation
is that, to learn recurring patterns in implementations of thread-safe and thread-unsafe classes, the extracted graphs need to be
comparableacrossdifferentclasses.Inparticular,theyshouldnot
contain identifier names, such as method and field names, as these
vary across different classes and projects. Therefore, our approach
renameseachnodethatrepresentsamethodto m,whiletwospecial
node names initandclinitare reserved for class constructors
andstaticconstructors,respectively.Similarly,allfieldsarerenamed
tof.
4 CLASSIFYING CLASSES
Classifyinggraphsisaclassicalprobleminseveraldomainssuch
asbio-andchemo-informatics[ 10,47,59],imageanalysis[ 25],and
web and social network analysis [ 67]. Traditional approaches to
this problem [ 65] use a so-called kernel method [ 56], a function
tocomputethesimilaritybetweentwographs.Thepairwisesim-
ilarities between graphs are then used as vector embeddings to
represent the graphs for classification.
Weadoptavariantofthisapproachtoourproblemofclassifying
thread-safe classes. TSFinder first builds several graphs per class
(¬ß 3.2). It then uses the kernel method through a graph kernel func-
tion to generate vectors (embeddings) for graphs (¬ß 4.2.1). Instead
of training a machine learning model on several individual graphs
from each class, we combine embeddings of graphs extracted from
the same class into one single embedding per class for the ma-
chinelearningmodeltolearn(¬ß4.2.2).ThisstepallowsTSFinderto
classify thread-safe classes using all generated graphs from a class.
Basedonthefield-focusedgraphsextractedforeachclass,TS-
Finderlearnshowtoclassifyclassesintosupposedlythread-safeand thread-unsafe classes. To this end, the approach combines a
graphkernel,whichcomputesthesimilarityoftwographs,witha SVM, which classifies each class based on the similarity of its
graphstoothergraphsfromclassesknowntobethread-safeornot.
The basic idea is to perform three steps:
(1)Givenaclass,compareitsgraphstographsofclassesknown
tobethread-safeorthread-unsafe.Foreachpairofgraphs,
computeasimilarityscoreandsummarizeallscoresintoa
vector per graph.
(2)Combine all graph vectors of a class into one single class
vector that summarizes the similarity of graphs extracted
from the class to graphs in the trained model.
(3)Classify a class by querying a vector-based binary classi-
fierusing theresultingclass vector.The classifierhasbeen
trained with the class vectors of the classes with known
thread safety.
The remainder of this section presents these steps in detail.
4.1 Background: Graph Kernels
Checking whether two graphs are isomorphic is a computationally
hardproblemforwhichnopolynomial-timealgorithmisknown.In
contrast, graph kernels offer an efficient alternative that compares
graphsubstructuresinpolynomialtime.Inessence,agraphkernelis
a function that takes two graphs and yields a real-valued similarityscore.Givenalistofgraphs
–¥1,..,–¥nandakernel k,onecancompute
a matrixK=(k(–¥i,–¥j))i,j,1‚â§i,j‚â§n, that contains all pairwise
similarityscoresofthegraphs.Thismatrix,calledthe kernelmatrix,
is symmetric and positive-definite.
Inthiswork,webuilduponafast,scalable,stateoftheartkernel,
theWeisfeiler-Lehman (WL) graph kernel [58]. It is based on the
Weisfeiler-Lehmangraphisomorphismtest[ 74],whichaugments
each labeled node by the sorted set of its direct neighbors andcompresses this augmented label into a new label. This step is
repeateduntilthesetsofnodelabelsofthetwographsaredifferentoruntilreachingamaximumnumberofiterations
h.Givenagraph
–¥,werefertothesequenceofgraphsobtainedbythisaugmentation
and compression step as –¥0,–¥1,..,–¥h, where–¥0=–¥and–¥his the
maximallyaugmentedandcompressedgraph.Wecallthissequence
of graphs the WL sequence of–¥.
Given two graphs and their WL sequences, we compute the
graph kernel as follows:
Definition 4.1 (Weisfeiler-Lehman kernel). The graph kernel of –¥
and–¥/primeis
k(–¥,–¥/prime)=ksub(–¥0,–¥/prime
0)+ksub(–¥1,–¥/prime
1)+¬∑¬∑¬∑+ksub(–¥h,–¥/prime
h)
The function ksubis a subtree kernel function.
Definition 4.2 (Weisfeiler-Lehman subtree kernel). The subtree
graph kernel of –¥and–¥/primeis
ksub(–¥,–¥/prime)=/angbracketleftœï(–¥),œï(–¥/prime)/angbracketright
where the notation /angbracketleft.,./angbracketrightdenotes the inner product of two vectors.
Theœïfunction vectorizes a labeled graph by counting the origi-
nal and compressed node labels of the graphs in the WL sequences
of–¥and–¥/prime.Specifically,let Œ£ibethesetofnodelabelsthatoccurat
leastoncein –¥or–¥/primeattheendofthe i-thiterationofthealgorithm,
andletci(–¥,œÉij)bethenumberofoccurrencesofthelabel œÉij‚ààŒ£i
in the graph –¥. Based on the counter ci, we compute œïas follows:
45
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Andrew Habib and Michael Pradel
œï(–¥)=/parenleftbigc0(–¥,œÉ01),...,c0(–¥,œÉ0|Œ£0|),...,
ch(–¥,œÉh1),...,ch(–¥,œÉh|Œ£h|)/parenrightbig
4.2 Training
The goal of the training step of TSFinder is to create a binary
classificationmodelthatpredictswhetheragivenclassisthread-
safe or thread-unsafe. We use a supervised learning technique and
thereforerequiretrainingdata.Astrainingdata,weusetwosets
of classes CTSandC/tildewiderTS, which consist of known thread-safe and
knownthread-unsafeclasses,respectively.Foreachoftheseclasses,
the static analysis (¬ß3 ) extracts a set of graphs.
4.2.1 GraphsVectors. TSFinderfirstcomputesavectorrepre-
sentationofeachgraphbasedonthegraphkernelfunctionin ¬ß4.1.
Intuitively,thevectorcharacterizesagraphbysummarizinghow
similar it is to other, known graphs in the training data.
More technically, the approach computes the vector representa-
tion of a graph in three steps:
(1)Fix the order of all graphs in GCTS‚à™C/tildewidestTSto obtain a list of
graphs–¥1,..,–¥n. Thespecific order does notmatter, as long
as it remains fixed.
(2)Compute the kernel matrix of all graphs K=(k(–¥i,–¥j))i,j
for 1‚â§i,j‚â§n.
(3)Foreachgraph –¥i,thei-throwof Kisthevectorrepresenta-
tion of–¥, called graph vector.
4.2.2 CombiningClassGraphs. Giventhegraphsvectorsofa
class,wecombinethesevectorsintoasingleclassvector.Intuitively,
the class vector should summarize to what extent the individual
graphsofaclassresemblethegraphsofclassesinthetrainingdata.
Ifaclasshasgraphsthatareverysimilartographsthattypically
occur in thread-safe classes, then the class is more likely to thread-
safe. Likewise, a class with graphs that mostly resemble graphs
fromthread-unsafeclassesismorelikelytoalsobethread-unsafe.
To encode this intuition, we create a class vector by computing the
minimum, maximum, and average similarity of all the graphs of
the class against all graphs extracted from the training classes.
Letn=|GCTS‚à™C/tildewidestTS|be the total number of graphs extracted
from all classes in the training data. For a specific class C, letGC
bethesetofallgraphsTSFinderextractedfrom Candm=|GC|be
the total number of these graphs. For each graph –¥i‚ààGCwhere
1<i<m, letfj
–¥iwhere 1 <j<nbe thejth feature of graph –¥iof
the classC. Our approach computes the class vector by calculating
‚àÄj‚àà1,...,n:
min(fj
–¥i‚àÄi‚àà1,...,m),
max(fj
–¥i‚àÄi‚àà1,...,m),
mean(fj
–¥i‚àÄi‚àà1,...,m)
and concatenating these n‚àó3 values into a single vector.
For example, the class vector in Figure 2d has 3*4860=14580
elements. The first three elements are the minimum, maximum,
and mean similarity of the graphs in Figure 2b compared to the
first graph in the list of graphs extracted from the training classes.
The next three elements are the minimum, maximum, and meansimilarity of the graphs in Figure 2b compared to the second graph
extracted from the training classes, ...etc.
4.2.3 Classifier. Giventheclassvectorsandtheircorresponding
labelsl1,..,lnthatindicatewhetheraclass cisfromCTSorfrom
C/tildewiderTS, we finally feed the labeled vectors into a traditional vector-
based classification algorithm. By default, TSFinder uses a SVM for
learning the classifier. Our evaluation also considers alternative
algorithms.
4.3 Classifying a New Class
Once TSFinder has learned a model, we use it to predict the thread
safety of a new class. Let Cnewbe the new class for which we
wish to infer its supposed behavior regarding thread safety. The
approachcomputesaclassvectorof Cnewinthesamewayasfor
training.Atfirst,TSFinderextractsfield-focusedgraphsfrom Cnew,
which yields a set GCnewof graphs. For each graph –¥‚ààGCnewthe
approachcomputesthegraphvectorof –¥bycomputingitsgraph
kernel against all graphs in our training data:
vec(–¥)=(k(–¥,–¥j))1j,j=1,2,...,n
where–¥j‚ààGCTS‚à™C/tildewidestTSisthesetofgraphsinthelearnedmodeland
n=|GCTS‚à™C/tildewidestTS|is the total number of graphs in the model. Given
thesetofgraphsvectors,TSFindercombinesthesegraphsintoasingle class vector as described in ¬ß 4.2.2and queries the trained
modeltoobtainaclassificationlabelfortheclass Cnew.Thelabel
indicates whether the model predicts the class to be thread-safe or
thread-unsafe.
5 IMPLEMENTATION
WeimplementTSFinderintoafullyautomatedtooltoanalyzeJava
classes. The static analysis builds on the static analysis framework
Soot [64]. Given a class, either as source code or byte code, the
analysis extracts field-focused graphs by traversing all program
elements,byqueryingthecallgraph,andbyanalyzingdefinition-
userelationshipsofstatements.WeusetheGraphMLformat[ 11]
tostoregraphs.TocomputetheWLgraphkernel,webuildonan
existing Python implementation [ 58]. The SVM model is imple-
mentedontopoftheWekaframework[ 21].Ourimplementation
is available as open-source.5
6 EVALUATION
The evaluation is driven by four main research questions:
‚Ä¢RQ1: How many classes come with documentation about
their thread safety? (¬ß 6.1)
‚Ä¢RQ2: How effective is TSFinder in classifying classes as
thread-safe or thread-unsafe? (¬ß 6.2)
‚Ä¢RQ3: How efficient is TSFinder? (¬ß 6.3)
‚Ä¢RQ4: How does TSFinder compare to variants of the ap-
proach and to a simpler approach? (¬ß 6.4)
6.1 RQ1: Existing Thread Safety
Documentation
Tobetterunderstandthecurrentstate-of-theartindocumenting
thread safety, we systematically search all 179,239 classes from
5https://github.com/sola-da/TSFinder
46
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. Is This Class Thread-Safe? ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
the Qualitas corpus for thread safety documentation. We focus on
documentationprovidedaspartoftheJavadoccommentsofaclass
and its members, and ignore any other documentation, e.g., on
projectwebsitesorinbooks.Mostreal-worldclasseshaveJavadoc
documentationanditisacommonsoftwareengineeringpractice
to document class-level properties, such as thread safety, there.
Ourinspectionproceedsintwo steps.Atfirst,wegeneratethe
JavadocHTMLfilesforallclassesandautomaticallysearchthem
for keywords related to concurrency and thread safety. Specifically,
wesearchfor‚Äúconcu‚Äù,‚Äúthread‚Äù,‚Äúsync‚Äù,and‚Äúparallel‚Äù.Wechoose
these terms to overapproximate any relevant documentation. In
total, the search yields hits in 8,655 of the 179,239 classes.
Asthesecondstep,wemanuallyanalyzearandomsampleof120
of the 8,655 classes. For each sampled class, we inspect the Javadoc
andsearchforanydocumentationrelatedtothethreadsafetyof
theclass.Basedonthisinspection,weclassifytheclassinoneof
the following four categories.
Documentedasthread-safe. Thedocumentationexplicitlyspec-
ifies that the class is supposed to be thread-safe or this intention
can be clearly derived from the available information. Examples
include:
‚Ä¢The class-level documentation states ‚ÄúThis class is thread-
safe‚Äù.
‚Ä¢The name of the class is SynchronousXYChart and the
project also contains a class XYChart, indicating that the
former is a thread-safe variant of the latter.
‚Ä¢The class-level documentation states ‚ÄúMutex that allows
only one thread to proceed [while] other threads must wail
until the one finishes‚Äù. The semantics of a mutex implemen-
tation imply that the class is thread-safe because mutexes
are accessed concurrently without acquiring any additional
locks.
Documentedasthread-unsafe. Thedocumentationexplicitlyspec-
ifiesthattheclassisnotsupposedtobethread-safeorthisintention
can be clearly derived from the available information. Examples
include:
‚Ä¢Theclass-leveldocumentationstates‚ÄúThisclassisnotthread-
safe‚Äù or ‚Äúnot to be used without synchronization‚Äù.
‚Ä¢The class-level documentation states ‚ÄúWe are not using any
synchronized so that this does not become a bottleneck‚Äù.
‚Ä¢Theclass-leveldocumentationstates‚ÄúTheclass(..)shallbe
usedaccordingtotheSwingthreadingmodel‚Äù,whichimpliesthat only the Swing thread may access instances of the class
and that the class is not thread-safe [77].
Documented as conditionally thread-safe. The documentation
specifiestheclasstobethread-safeundersomecondition.Examples
include:
‚Ä¢The class depends on another class and has the same thread
safety as this other class.
‚Ä¢All static methods of the class are thread-safe, whereas non-
static methods are not necessarily thread-safe.
No documentation on thread safety. The documentation does not
mentionthreadsafetyandwecannotderivefromotheravailableTable 1: Existing thread safety documentation.
Documented as: Number Percentage
Thread-safe 11 9.2%
Not thread-safe 12 10.0%Conditionally thread-safe 2 1.7%No documentation 95 79.2%
Total inspected 120 100.0%
information whether the class is supposed to be thread-safe. Exam-
ples of documentation that matches our search terms but does not
document thread safety include:
‚Ä¢The class implements a graph data structure and its docu-
mentation says that it ‚Äúpermits paralleledges‚Äù.
‚Ä¢Themethod-leveldocumentationspecifiesthatanargument
orthereturnvalueofthemethodissupposedtobethread-
safe.Whilesuchastatementisaboutthreadsafety,itdoes
not specify this property for the current class.
Table1summarizes the results of this classification. We find
that most (79.2%) of the inspected classes do not document the
threadsafetyoftheclass,buthitoursearchtermsforsomeother
reason.Inthedocumentedsubsetofclasses,whichsumsupto20.8%,
roughlythesamenumberofclassesisdocumentedasthread-safe
and thread-unsafe, respectively.
Under the assumptions that our search terms cover all possible
thread safety documentationand that the 120sampled classes are
representativefortheentirepopulationofclassesinthecorpus,we
can estimate the percentage of documented classes in the corpus:
%documented ‚àóSearchhits
Total classes=0.208‚àó8,655
179,239=1.004%
In summary, the vast majority of real-world Java classes do
not documentwhether theyare thread-safe ornot. Among
thefewdocumentedclasses,47.8%and52.2%aredocumented
as thread-safe and thread-unsafe, respectively. We conclude
thatthecurrentstateofthreadsafetydocumentationispoorandwillbenefitfromautomaticinferenceofdocumentation.
6.2 RQ2: Effectiveness of TSFinder
6.2.1 Data Set and Graph Extraction. For the remaining evalua-
tion,weuseasetof230classesgatheredfromJDKversion1.8.0_152.
These classes are documented to be either thread-safe or thread-
unsafe, providing a ground truth for our evaluation. Table 2shows
the number fo fields, methods, and lines of code of these classes. In
total, the classes sum up to 74,313 lines of Java code. The last three
columnsof Table2providestatisticsaboutthegraphsthatTSFinder
extracts. On average, the static analysis extracts 21.1 graphs per
class, which yields a total of 4,860 graphs that the approach learns
from.
Althoughthenumberofthread-safeandthread-unsafeclasses
is equal, thetotal number of extracted graphs from thread-unsafe
classes is about 1.4 the number of graphs extracted from thread-safe classes. Since TSFinder uses the entire set of 4,860 graphsto construct the class vector for any class, this imbalance does
47
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Andrew Habib and Michael Pradel
Table 2: Classes and extracted field-focused graphs used for training and cross-validation.
Fields Methods LoC Extracted graphs
Classes Count Min Max Avg Min Max Avg Min Max Avg Graphs Vertices Edges
Thread-safe 115 1 64 8.7 2 163 34.7 13 4,264 430.2 1,989 128,493 150,850
Thread-unsafe 115 0 55 4.3 1 103 23.8 7 1,931 219.7 2,871 151,410 170,473
All 2300 64 6.4 1 163 29.2 7 4,264 323.1 4,860 279,903 321,323
Table 3: Effectiveness of classification via 10-fold cross vali-
dation across 230 classes with h=3.
Thread-safe Thread-unsafe
Accuracy Precision Recall Precision Recall
94.5% 94.9% 94.0% 94.2% 95.0%
not prevent the approach from learning an effective classifier. The
numberofgraphspercategoryin Table2isdisproportionatetothe
numberoffieldsandmethodsinthesamecategoryduetoflattening
the class hierarchy (¬ß 3.1.3).
6.2.2 Results. To evaluate the effectiveness of TSFinder, we ap-
plyittothe230classesandmeasureprecision,recall,andaccuracy.
We perform 10-fold cross validation, a standard technique to evalu-
ate supervised machine learning. The technique shuffles and splits
all labeled data, i.e., our 230 thread-safe and thread-unsafe classes
into ten equally sized sets. For each set, it then trains a model with
theclassesintheotherninesetsandpredictsthelabelsofthere-
maining classes using the trained model. We measure accuracy as
thepercentageofcorrectclassificationsamongallclassifications
madebyTSFinder.Wemeasureprecisionandrecallbothforpredict-
ingthreadsafetyandforpredictingthreadunsafety.Withrespecttothread (un)safety, precision meansthe percentage ofcorrect thread
(un)safetypredictionsamongallpredictionssayingthataclassis
thread-(un)safe.Recallmeansthepercentageofclassesclassifiedas
thread-(un)safe among all classes that are actually thread-(un)safe.
Table 3shows the results of the 10-fold cross validation. The
classification accuracy is 94.5%, i.e., TSFinder correctly predicts
the thread safety of the vast majority of classes. The precision and
recall results allow the reader to further understand how incorrect
predictions are distributed. For example, the fact that the precision
for thread safety is 94.9% means the following: When the approach
predicts a class to be thread-safe, then this prediction is correct
in94.9%ofthecases.Similar,therecallforthread-safetyof94.0%
meansthatTSFinderfinds94.0%ofallthread-safeclassesandmisses
the remaining 6%.
6.2.3 ManualInspection. Tobetterunderstandthelimitations
of TSFinder, we inspect some of the mis-classified classes.
Thread-safeclasspredictedasnotthread-safe. TSFindermistak-
enly predicts the thread-safe ConcurrentLinkedQueue class to
bethread-unsafe.Thisqueueimplementationbuildsuponanon-blocking algorithm [
38]. Since our training set includes only six
classes that use a similar lock-free implementation, the trainingdata may not be sufficient for the classifier to generalize to the
ConcurrentLinkedQueue implementation. Nevertheless, TSFinder
correctlypredicts someoftheother classesthatusenon-blocking
implementations.
Thread-unsafeclasspredictedasthread-safe. Theapproachpre-
dicts TreeSetandEnumSetas thread-safe, even though they are
thread-unsafe implementations of the abstract class AbstractSet .
We suspect these misclassification to be due limitations of the the
learned model to generalize to previously unseen cases.
Inaccurate documentation. TSFinder classifies PKIXCertPath-
ValidatorResult asthread-safe,eventhoughitsdocumentation
labelsitasnotthread-safe.Manuallyinspectingtheimplementa-
tionshowsthattheclassisindeedthread-safe.Theprivatefields
of the class are initialized by the constructor and after that can-
notbewrittento.ThiscaseillustratesthatTSFindercannotonly
add otherwise missing documentation, but could also be useful for
validating existing documentation.
In summary, our classifier correctly predicts the thread
safety of a class in 94.5% of the cases. The precision and
recallforidentifyingthread-safeclassesare94.9%and94.0%,
respectively.Weconcludethattheapproachachievesitsgoal
of automatically and precisely identifying whether a class is
supposed to be thread-safe.
6.3 RQ3: Efficiency of TSFinder
Weevaluate theefficiency ofourapproach bymeasuring thetime
required for the different steps. All experiments are performed on
amachinewith4Inteli7-4600UCPUcoresand12GBofmemory.
Training the classifier with a set of training classes is a one-time
effort. For the 230 training classes that we use in this evaluation,
thetrainingtakesapproximately11.7minutes,includingallcom-
putationsteps,suchasextractinggraphs,computinggraphkernels,
and training the SVM model. When querying TSFinder with a new
class,theapproachextractsgraphsfromthisclassandclassifiesthe
classbasedonthegraphs.Theformersteptakesabout3seconds
and it dominates the latter which is negligible, on average over all
230 training classes.
TSFinderstoresgraphsextractedfromtrainingclassesaspartof
itstrainedmodel.Thesegraphsareusedtocomputethepairwise
similarity of graphs extracted from the class under inspection to
buildthevectorembeddingoftheclass.Forourmodeltrainedwith
230graphs,thetotalsizeofthecompressedgraphsis0.6MB,i.e.,
the space consumed by the model graphs is negligible.
48
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. Is This Class Thread-Safe? ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
Table 4: Effect of the WL kernel iterations parameter hon
classification.
h 1234567
Accuracy (%) 89.7 94.1 94.5 94.4 93.9 94.1 94.1
Table 5: Effectiveness of the graph-based TSFinder against
the SimpleClassifier classifier.
Accuracy
Classifier TSFinder SimpleClassifier
SVM (SGD6with hinge loss) 94.5% 75.0%
Random forest 94.1% 79.3%
SVM (SMO7) 92.5% 70.6%
SVM (SGD with log loss) 92.0% 74.3%
Additive logistic regression 92.8% 74.5%
WeconcludethatTSFinderistimeandspaceefficientenough
todocumenthundredsofclasses,e.g.,ofathird-partylibrary,
in reasonable time and with minimal space overhead.
6.4 RQ4: Comparison with Alternative
Approaches
Asthedefaultclassificationalgorithm,weuseaSVMwithstochastic
gradient decent (SGD) and the hinge loss function. We empirically
set the learning rate to 0.0001 and the number of WL-iteration h
to 3. The following compares this configuration with alternative
approaches.
6.4.1 Configuration of the WL Graph Kernel. To compare field-
focusedgraphswitheachother,TSFinderusestheWLgraphkernel,
which hasa parameter hthat determinesto what extentshould it
compressnodelabels. Table4showstheeffectof hontheclassifica-
tionaccuracy.Theresultssuggestthat h=3isanappropriatevalue
forhandthatsmallvariationsoftheparameterdonotsignificantly
change the accuracy.
6.4.2 Classification Algorithm. TSFinder uses a classification
algorithm that determines whether a given class vector is likely
thread-safe or not (¬ß 4.2.3). We evaluate several other popular algo-
rithmsinadditiontoourdefaultofSVMwithstochasticgradient
descent and hinge loss. Table 5shows the accuracy of TSFinder
with four other classification algorithms, each with the default
configurationofhyperparametersprovidedbyWeka.Theresults
show that the accuracy is only slightly influenced by the choice of
classification algorithm, as it ranges between 92.0% and 94.5%.
6.4.3 Simple Class-level Features. We evaluate whether our
graph-based view on classes could be replaced by a simpler ap-
proachthatsummarizesclass-levelfeaturesintoavector.Thein-
tuition behind this set of features is that as a human, we tend to
6Stochastic Gradient Descent
7Sequential Minimal Optimizationbelievethat, forexample, aclass withhighpercentage ofsynchro-
nizedmethodsisprobablymorelikelyintendedtobethread-safe
than a class with fewer synchronized methods. Specifically, we
consider the following class-level features:
‚Ä¢Percentage of fields that are volatile.
‚Ä¢Percentage of fields that are public and volatile.
‚Ä¢Percentage of methods that are either synchronized or con-
tain a synchronized block.
‚Ä¢Percentage of methods that are either public and synchro-
nized or public and contain a synchronized block.
Basedonafeaturevectorforeachofour230classes,wetrainand
evaluateaclassifierusingthesame10-foldcrossvalidationstrategy
asabove.Wecallthisapproach SimpleClassifier.Thelastcolumn
inTable5showstheaccuracyobtainedbySimpleClassifierusing
different learning algorithms. All algorithms are used with their
default configurations, as provided by Weka. The highest accuracy
that SimpleClassifier achieves is 79.3%, using the random forest
learning algorithm, which is significantly lower than the accuracy
of TSFinder.
In summary, we find that the choice of classification al-
gorithm has little influence on the accuracy of TSFinder.
Comparingtheapproachwithaclassifierbasedonsimple,
class-level features shows that our graph-based representa-
tion of classes yields a significantly more accurate classifier
(94.5% versus 79.3%).
7 LIMITATIONS
Onelimitationisthatthetrainingclassesmaynotcomprehensively
coverallpossiblepatternsofthread-safeandthread-unsafecode.
As a result, the analysis may not be able to correctly classify a
previously unseen class that relies on a completely new way to im-
plement thread safety. We try to address this problem by selecting
a diverse set of training classes that are used in various application
domains and that cover different concurrency-related implementa-
tionpatterns,e.g.,immutableclasses,classesthatusesynchronized
methods, and classes that use synchronization blocks.
Another limitation is that some of the supposedly thread-safe
training classes may have subtle concurrency bugs. If such bugs
were prevalent, the approach might learn patterns of buggy con-
current code. To mitigate this potential problem, the training set
contains well-tested and widely used classes, for which we assume
that most of their implementation is correct.
8 RELATED WORK
8.1 Analysis of Concurrent Code
The analysis of concurrent software has been an active topic for
several years. Analyses that target thread-safe classes are partic-
ularlyrelatedtoourwork.ConTeGe[ 44]andBallerina[ 41]have
pioneeredtestgenerationforsuchclasses.Othertestgeneratorsim-
prove upon them by considering coverage information [ 14,61], by
steeringtestgenerationbasedonsequentialtestexecutions[ 51‚Äì53],
bycomparingthread-safeclassesagainsttheirsuperclasses[ 45],or
bytargetingteststhatraiseexceptions[ 54].SpeedGun[ 46]aimsat
detecting performance regression bugs in thread-safe classes. Con-
Crash [8] creates tests that reproduce previously observed crashes.
49
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Andrew Habib and Michael Pradel
LockPeeker [ 34] tests API methods to find latent locking bugs. All
theseapproachesfindcorrectnessorperformancebugsinthread-
safeclasses.Instead,ourworkaddressestheorthogonalproblem
of inferring whether a class is even supposed to be thread-safe.
Beyondthread-safeclasses,variousdynamicanalysestofindcon-
currency bugs have been proposed, such as data race detectors [ 13,
19,42,55],analysestodetectatomicityviolations[ 7,18,35,71,78],
and analyses to find other kinds of concurrency anomalies [ 36,68].
Whilethesetechniquesanalyzeagivenexecution,anotherdirection
is to influence the schedule of an execution to increase the chance
totriggerconcurrency-relatedmisbehavior.Workoninfluencing
schedulesincludesrandom-basedscheduling[ 12,15],systematic
explorationofschedules[ 39,66],andforcingschedulestotrigger
previously identified, potential bugs [ 28,57]. All these approaches
aim at bug detection, whereas TSFinder infers documentation.
Finally, there are various static analyses of concurrent code,
e.g., to find deadlocks [ 4,40,76], atomicity violations [ 20], locking
policies[17],andconflictingobjects[ 69].Onestrengthofourwork
compared to existing static analyses of concurrent code is the use
of a relatively simple static analysis and complementing it with
graph-based machine learning.
8.2 API Documentation
Lethbridge et al .[32]study how documentation is used in practice.
Theyfindthatdocumentationisoftenoutdatedandinconsistent.
Inferringdocumentationfromsourcecodealleviatestheseproblems.
Another study focuses on problems that developers face when
learning a new API [ 50]. Their results include that many APIs
need more and better documentation. Our work addresses this
problembyprovidingan automated waytogenerateconcurrency
specifications.
Improvingdocumentationandhowdevelopersuseitisanactive
area of research. McBurney et al .[37]investigate how to prioritize
documentationeffortbasedonsourcecodeattributesandtextual
analysis. Treude and Robillard [63]augment API documentation
with relevant and otherwise missing information from Stack Over-
flow. APIBot is a bot created to answer natural language questions
by developers based on the available documentation [ 62]. Other
workfindsrelevanttutorialfragmentsforanAPItohelpdevelopers
better understand that API [ 27]. Another line of work searches for
mistakes in existing documentation by comparing it to the doc-
umented implementation [ 82] or by pinpointing comments that
risk becoming inconsistent when changing identifier names in the
code[49].Ourworkalsocontributestoimprovingandaddingother-
wise missing documentation, yet we tackle the so far understudied
problem of inferring concurrency-related documentation.
8.3 Specifications Mining
Specification mining automatically extracts a formal specification
fromsourcecodeorfromprogramsexecutions.Minedspecification
include finite-state specifications of method calls [ 5,31,43,75],
algebraic specifications [ 26], temporal specifications of API us-
ages [22,73,79], implicit programming rules [ 33], and locking
disciplines [ 16]. One benefit of mined specifications is to use them
as documentation. TSFinder can be seen as a form of specificationmining.Incontrasttoexistingtechniques,ourworkfocusesoncon-
currency documentation and uses machine learning to learn fromknown examples how to infer this specification (documentation).
8.4 Graph Kernels
Kondor and Lafferty [30]and G√§rtner et al .[23]introduced graph
kernels and others have been proposed since then, e.g., random-
walk kernels [ 29], shortest-path kernels [ 9], and subtree ker-
nels[48].Thesegraphkernelshavebeenmainlyusedinbioinfor-
matics [10], in chemoinformatics [ 47,59], and in web mining [ 72],
e.g., to find similar web pages and to analyze social networks.
Some existing work applies graph kernels to software. Wagner
et al.[70]analyze process trees with graph kernels to identify mal-
ware.Another approach[ 6]uses Markovchains constructedfrom
instructiontracesofexecutables[ 6].Furthermore,graphkernels
have been applied to statically identify malware by applying aneighborhood hash graph kernel on call graphs [
24] and by us-
ing graph edit distance on API dependency graphs [ 80]. Our work
tackles a different problem: the lack of documentation regardingmulti-threaded behavior. Another difference is the kind of infor-
mation that TSFinder extracts from classes and then feeds into
graphkernels.Finally,tothebestofourknowledge,ourexperimen-
tal setup is orders of magnitude larger than any other study that
utilizes graph kernels in the context of program analysis.
9 CONCLUSION
This paper addresses the understudied problem of inferring
concurrency-related documentation. TSFinder is an automatic ap-
proachtoinferwhetheraclassissupposedtobethread-safeornot.
Our approach is a novel combination of lightweight static analysis
and graph-based classification. We show that our classifier has an
accuracy of 94.5% and therefore provides high-confidence docu-
mentation, while being efficient enough to scale to hundreds of
classes, e.g., in a third-party library.
We envision the long-term impact of this work to be twofold.
First,developersofconcurrentsoftwarecanuseourapproachto
decideifandhowtousethird-partyclasses.Second,webelievethat
thetechnicalcontributionofthispaper‚Äìcombininglightweight
staticanalysisandgraph-basedclassification‚Äìgeneralizestoother
problems.Forexample,futureworkcouldadapttheideatoother
class-levelproperties,suchasimmutability,andtoothercodeprop-
erties, such as whether a piece of code suffers from a particular
kind of bug.
ACKNOWLEDGMENTS
ThisworkwassupportedinpartbytheGermanResearchFoundationwithin
theEmmyNoetherprojectConcSysandthePerf4JSproject,bytheGerman
Federal Ministry of Education and Research and by the Hessian Ministry of
ScienceandtheArtswithinCRISP,andbytheHessianLOEWEinitiative
within the Software-Factory 4.0 project.
50
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. Is This Class Thread-Safe? ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
REFERENCES
[1][n. d.]. JBoss Platform issue 1416472.
https://bugzilla.redhat.com/show_bug.cgi?id=1416472.
[2] [n. d.]. NX issue 239. https://track.radensolutions.com/issue/NX-239.
[3] [n. d.]. RESTEasy issue 1669. https://issues.jboss.org/browse/RESTEASY-1669.[4]
Rahul Agarwal, Liqiang Wang, and Scott D. Stoller. 2005. Detecting Potential
Deadlocks with Static Analysis and Run-Time Monitoring. In Haifa Verification
Conference, Vol. 3875. Springer, 191‚Äì207.
[5]GlennAmmons,RastislavBod√≠k,andJamesR.Larus.2002. Miningspecifications.
InSymposium on Principles of Programming Languages (POPL). ACM, 4‚Äì16.
[6]BlakeAnderson,DanielQuist,JoshuaNeil,CurtisStorlie,andTerranLane.[n.d.].
Graph-basedmalwaredetectionusingdynamicanalysis. 7,4([n.d.]),247‚Äì258.
https://doi.org/10.1007/s11416-011-0152-x
[7]Cyrille Artho, Klaus Havelund, and Armin Biere. 2003. High-level data races.
Software Testing, Verification and Reliability 13, 4 (2003), 207‚Äì227.
[8]Francesco A. Bianchi, Mauro Pezze, and Valerio Terragni. 2017. Reproducing
Concurrency Failures from Crash Stacks. In FSE.
[9]Karsten M. Borgwardt and Hans-Peter Kriegel. 2005. Shortest-Path Kernels
on Graphs. In Proceedings of the Fifth IEEE International Conference on Data
Mining (ICDM‚Äô05).IEEEComputerSociety,Washington,DC,USA,74‚Äì81. https:
//doi.org/10.1109/ICDM.2005.132
[10]KarstenM.Borgwardt,ChengSoonOng,StefanSch√∂nauer,S.V.N.Vishwanathan,
Alex J. Smola, and Hans-Peter Kriegel. 2005. Protein Function Prediction via
GraphKernels. Bioinformatics 21,1 (Jan.2005),47‚Äì56. https://doi.org/10.1093/
bioinformatics/bti1007
[11]Ulrik Brandes, Markus Eiglsperger, Ivan Herman, Michael Himsolt, and
M. Scott Marshall. 2002. GraphML Progress Report Structural Layer Proposal.
SpringerBerlinHeidelberg,Berlin,Heidelberg,501‚Äì512. https://doi.org/10.1007/
3-540-45848-4_59
[12]SebastianBurckhardt,PraveshKothari,MadanlalMusuvathi,andSantoshNa-
garakatte.2010. Arandomizedschedulerwithprobabilisticguaranteesoffinding
bugs. InConference on Architectural Support for Programming Languages and
Operating Systems (ASPLOS). 167‚Äì178.
[13]Jong-DeokChoi,KeunwooLee,AlexeyLoginov,RobertO‚ÄôCallahan,VivekSarkar,
andManuSridharan.2002. EfficientandPreciseDataraceDetectionforMulti-
threaded Object-Oriented Programs. In Conference on Programming Language
Design and Implementation (PLDI). 258‚Äì269.
[14]Ankit Choudhary, Shan Lu, and Michael Pradel. 2017. Efficient Detection of
ThreadSafetyViolationsviaCoverage-GuidedGenerationofConcurrentTests.
InInternational Conference on Software Engineering (ICSE).
[15]Orit Edelstein, Eitan Farchi, Yarden Nir, Gil Ratsaby, and Shmuel Ur. 2002. Multi-
threadedJavaprogramtestgeneration. IBMSystemsJournal 41,1(2002),111‚Äì125.
[16]Michael D. Ernst, Alberto Lovato, Damiano Macedonio, Fausto Spoto, and Javier
Thaine. 2016. Locking discipline inference and checking. In Proceedings of the
38thInternationalConferenceonSoftwareEngineering,ICSE2016,Austin,TX,USA,
May 14-22, 2016. 1133‚Äì1144.
[17]CormacFlanaganandStephenN.Freund.2000. Type-basedracedetectionfor
Java. 219‚Äì232.
[18]CormacFlanaganandStephenN.Freund.2004. Atomizer:adynamicatomicity
checkerformultithreadedprograms.In SymposiumonPrinciplesofProgramming
Languages (POPL). ACM, 256‚Äì267.
[19]Cormac Flanagan andStephen N. Freund. 2009. FastTrack: efficientand precise
dynamic race detection. In Conference on Programming Language Design and
Implementation (PLDI). ACM, 121‚Äì133.
[20]Cormac Flanagan and Shaz Qadeer. 2003. A type and effect system for atomicity.
ACM, 338‚Äì349.
[21]Eibe Frank, Mark A. Hall, Geoffrey Holmes, Richard Kirkby, and Bernhard
Pfahringer. 2005. WEKA - A Machine Learning Workbench for Data Mining. In
The Data Mining and Knowledge Discovery Handbook. 1305‚Äì1314.
[22]Mark Gabel and Zhendong Su. 2008. Javert: Fully Automatic Mining of General
Temporal Properties from Dynamic Traces. In Symposium on Foundations of
Software Engineering (FSE). ACM, 339‚Äì349.
[23]Thomas G√§rtner, Peter Flach, and Stefan Wrobel. 2003. On graph kernels: Hard-
nessresultsandefficientalternatives. In LearningTheoryandKernelMachines.
Springer, 129‚Äì143.
[24]HugoGascon,FabianYamaguchi,DanielArp,andKonradRieck.[n.d.].Structural
DetectionofAndroidMalwareUsingEmbeddedCallGraphs.In Proceedingsof
the2013ACMWorkshoponArtificialIntelligenceandSecurity (2013)(AISec‚Äô13).
ACM, New York, NY, USA, 45‚Äì54. https://doi.org/10.1145/2517312.2517315
[25]Za√Ød Harchaoui and Francis Bach. 2007. Image classification with segmentation
graphkernels.In ComputerVisionandPatternRecognition,2007.CVPR‚Äô07.IEEE
Conference on. IEEE, 1‚Äì8.
[26]Johannes Henkel, Christoph Reichenbach, and Amer Diwan. 2007. Discover-ing Documentation for Java Container Classes. IEEE Transactions on Software
Engineering 33, 8 (2007), 526‚Äì543.
[27]HeJiang,JingxuanZhang,ZhileiRen,andTaoZhang.2017. AnUnsupervised
Approachfor DiscoveringRelevantTutorialFragments forAPIs.In Proceedingsofthe39thInternationalConferenceonSoftwareEngineering (ICSE‚Äô17).IEEEPress,
Piscataway, NJ, USA, 38‚Äì48. https://doi.org/10.1109/ICSE.2017.12
[28]PallaviJoshi,MayurNaik,Chang-SeoPark,andKoushikSen.2009. CalFuzzer:
AnExtensibleActiveTestingFrameworkforConcurrentPrograms.In Conference
on Computer Aided Verification. Springer, 675‚Äì681.
[29]Hisashi Kashima, Koji Tsuda, and Akihiro Inokuchi. 2003. Marginalized Kernels
BetweenLabeledGraphs.In ProceedingsoftheTwentiethInternationalConference
onInternationalConferenceonMachineLearning (ICML‚Äô03).AAAIPress,321‚Äì328.
http://dl.acm.org/citation.cfm?id=3041838.3041879
[30]RisiImreKondorandJohnD.Lafferty.2002. DiffusionKernelsonGraphsand
Other Discrete Input Spaces. In Proceedings of the Nineteenth International Con-
ference on Machine Learning (ICML ‚Äô02) . Morgan Kaufmann Publishers Inc., San
Francisco,CA, USA,315‚Äì322. http://dl.acm.org/citation.cfm?id=645531.655996
[31]Choonghwan Lee, Feng Chen, and Grigore Rosu. 2011. Mining Parametric
Specifications.In InternationalConferenceon SoftwareEngineering(ICSE).591‚Äì
600.
[32]TimothyC.Lethbridge,JaniceSinger,andAndrewForward.2003. HowSoftware
Engineers Use Documentation: The State of the Practice. IEEE Software 20, 6
(2003), 35‚Äì39.
[33]Zhenmin Li and Yuanyuan Zhou. 2005. PR-Miner: Automatically Extracting
ImplicitProgrammingRulesandDetectingViolationsinLargeSoftwareCode.
InEuropeanSoftwareEngineeringConferenceandSymposiumonFoundationsof
Software Engineering (ESEC/FSE). ACM, 306‚Äì315.
[34]Z.Lin,H.Zhong,Y.Chen,andJ.Zhao.2016. LockPeeker:Detectinglatentlocksin
JavaAPIs.In 201631stIEEE/ACMInternationalConferenceonAutomatedSoftware
Engineering (ASE). 368‚Äì378.
[35]ShanLu,JosephTucek,FengQin,andYuanyuanZhou.2006. AVIO:detecting
atomicityviolationsviaaccessinterleavinginvariants.In ConferenceonArchi-
tectural Support for Programming Languages and Operating Systems (ASPLOS) .
ACM, 37‚Äì48.
[36]Brandon Lucia and Luis Ceze. 2009. Finding concurrency bugs with context-
awarecommunicationgraphs.In SymposiumonMicroarchitecture(MICRO).ACM,
553‚Äì563.
[37]P. W. McBurney, S. Jiang, M. Kessentini, N. A. Kraft, A. Armaly, M. W. Mkaouer,
and C. McMillan. 2017. Towards Prioritizing Documentation Effort. IEEE Trans-
actions on Software Engineering PP, 99 (2017), 1‚Äì1. https://doi.org/10.1109/TSE.
2017.2716950
[38]Maged M Michael and Michael L Scott. 1996. Simple, fast, and practical non-
blockingandblockingconcurrentqueuealgorithms.In Proceedingsofthefifteenth
annual ACM symposium on Principles of distributed computing. ACM, 267‚Äì275.
[39]Madanlal Musuvathi, Shaz Qadeer, Thomas Ball, G√©rard Basler, Pira-
manayagamArumugaNainar,andIulianNeamtiu.2008.FindingandReproducing
Heisenbugs in Concurrent Programs. In Symposium on Operating Systems Design
and Implementation. USENIX, 267‚Äì280.
[40]MayurNaik,Chang-SeoPark,KoushikSen,andDavidGay.2009. Effectivestatic
deadlockdetection.In InternationalConferenceonSoftwareEngineering(ICSE).
IEEE, 386‚Äì396.
[41]Adrian Nistor, Qingzhou Luo, Michael Pradel, Thomas R. Gross, and Darko
Marinov. 2012. BALLERINA:AutomaticGenerationand ClusteringofEfficient
RandomUnitTestsforMultithreadedCode.In InternationalConferenceonSoft-
ware Engineering (ICSE). 727‚Äì737.
[42]RobertO‚ÄôCallahanandJong-DeokChoi.2003.Hybriddynamicdataracedetection.
InSymposiumon Principlesand PracticeofParallel Programming(PPOPP).ACM,
167‚Äì178.
[43]Michael Pradel and Thomas R. Gross. 2009. Automatic Generation of Object
UsageSpecificationsfromLargeMethodTraces.In InternationalConferenceon
Automated Software Engineering (ASE). 371‚Äì382.
[44]MichaelPradelandThomasR.Gross.2012.FullyAutomaticandPreciseDetection
of Thread Safety Violations. In Conference on Programming Language Design and
Implementation (PLDI). 521‚Äì530.
[45]Michael Pradel and Thomas R. Gross. 2013. Automatic Testing of Sequential and
Concurrent Substitutability. In International Conference on Software Engineering
(ICSE). 282‚Äì291.
[46]Michael Pradel, Markus Huggler, and Thomas R. Gross. 2014. Performance
RegressionTestingofConcurrentClasses.In InternationalSymposiumonSoftware
Testing and Analysis (ISSTA). 13‚Äì25.
[47]Liva Ralaivola, Sanjay J Swamidass, Hiroto Saigo, and Pierre Baldi. 2005. Graph
kernels for chemical informatics. Neural networks 18, 8 (2005), 1093‚Äì1110.
[48]JanRamonandThomasG√§rtner.2003. Expressivityversusefficiencyofgraph
kernels. In Proceedings of the first international workshop on mining graphs, trees
and sequences. 65‚Äì74.
[49]InderjotKaurRatolandMartinP.Robillard.2017. Detectingfragilecomments.In
Proceedingsofthe32ndIEEE/ACMInternationalConferenceonAutomatedSoftwareEngineering,ASE2017,Urbana,IL,USA,October30-November03,2017.112‚Äì122.
[50]Martin P. Robillard. 2009. What Makes APIs Hard to Learn? Answers from
Developers. IEEE Software 26, 6 (2009), 27‚Äì34.
[51]Malavika Samak and Murali Krishna Ramanathan. 2014. Multithreaded Test
SynthesisforDeadlockDetection.In ConferenceonObject-OrientedProgramming
51
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Andrew Habib and Michael Pradel
Systems, Languages and Applications (OOPSLA). 473‚Äì489.
[52]MalavikaSamakandMuraliKrishnaRamanathan.2015. Synthesizingtestsfor
detecting atomicity violations. In ESEC/FSE. 131‚Äì142.
[53]Malavika Samak, Murali Krishna Ramanathan, and Suresh Jagannathan. 2015.
Synthesizing racy tests.. In PLDI. 175‚Äì185.
[54]Malavika Samak, Omer Tripp, and Murali Krishna Ramanathan. 2016. Directed
synthesisoffailingconcurrentexecutions.In Proceedingsofthe2016ACMSIG-
PLANInternationalConferenceonObject-OrientedProgramming,Systems,Lan-
guages, and Applications, OOPSLA 2016, part of SPLASH 2016, Amsterdam, The
Netherlands, October 30 - November 4, 2016. 430‚Äì446.
[55]StefanSavage,MichaelBurrows,GregNelson,PatrickSobalvarro,andThomasE.
Anderson. 1997. Eraser: A Dynamic Data Race Detector for Multithreaded
Programs. ACM Transactions on Computer Systems 15, 4 (1997), 391‚Äì411.
[56]Bernhard Sch√∂lkopf and Alexander J Smola. 2002. Learning with kernels: Support
vector machines, regularization, optimization, and beyond. the MIT Press.
[57]Koushik Sen. 2008. Race directed random testing of concurrent programs. In
Conference on Programming Language Design and Implementation (PLDI). ACM,
11‚Äì21.
[58]Nino Shervashidze, Pascal Schweitzer, Erik Jan van Leeuwen, Kurt Mehlhorn,
and Karsten M. Borgwardt. 2011. Weisfeiler-Lehman Graph Kernels. J. Mach.
Learn.Res. 12(Nov.2011),2539‚Äì2561. http://dl.acm.org/citation.cfm?id=1953048.
2078187
[59]S Joshua Swamidass, Jonathan Chen, Jocelyne Bruand, Peter Phung, Liva
Ralaivola, and Pierre Baldi. 2005. Kernels for small molecules and the prediction
of mutagenicity, toxicity and anti-cancer activity. Bioinformatics 21, suppl 1
(2005), i359‚Äìi368.
[60]EwanTempero,CraigAnslow,JensDietrich,TedHan,JingLi,MarkusLumpe,
HaydenMelton,andJamesNoble.2010. QualitasCorpus:ACuratedCollectionof
Java Code for Empirical Studies. In Asia Pacific Software Engineering Conference
(APSEC).
[61]Valerio Terragni and Shing-Chi Cheung. 2016. Coverage-Driven Test Code
Generation for Concurrent Classes. In ICSE.
[62]Yuan Tian, Ferdian Thung, Abhishek Sharma, and David Lo. 2017. APIBot: ques-
tion answering bot for API documentation. In Proceedings of the 32nd IEEE/ACM
InternationalConferenceonAutomatedSoftwareEngineering,ASE2017,Urbana,
IL, USA, October 30 - November 03, 2017. 153‚Äì158.
[63]ChristophTreudeandMartinP.Robillard.2016. AugmentingAPIDocumentation
withInsightsfromStackOverflow.In Proceedingsofthe38thInternationalCon-
ferenceonSoftwareEngineering (ICSE‚Äô16).ACM,NewYork,NY,USA,392‚Äì403.
https://doi.org/10.1145/2884781.2884800
[64]Raja Vall√©e-Rai, Phong Co, Etienne Gagnon, Laurie J. Hendren, Patrick Lam,
and VijaySundaresan. 1999. Soot -a Java bytecodeoptimization framework.In
ConferenceoftheCentreforAdvancedStudiesonCollaborativeResearch(CASCON) .
IBM, 125‚Äì135.
[65]S. V. N. Vishwanathan, Nicol N. Schraudolph, Risi Kondor, and Karsten M. Borg-
wardt. [n. d.]. Graph Kernels. 11 ([n. d.]), 1201‚Äì1242. http://dl.acm.org/citation.
cfm?id=1756006.1859891
[66]WillemVisser,KlausHavelund,GuillaumeP.Brat,SeungjoonPark,andFlavio
Lerda.2003. ModelCheckingPrograms. AutomatedSoftwareEngineering 10,2
(2003), 203‚Äì232.
[67]Bimal Viswanath, M. Ahmad Bashir, Mark Crovella, Saikat Guha, Krishna P.
Gummadi,BalachanderKrishnamurthy,andAlanMislove.2014. TowardsDetect-
ingAnomalousUserBehaviorinOnlineSocialNetworks..In USENIXSecurity.223‚Äì238.
[68]Christoph von Praun and Thomas R. Gross. 2001. Object Race Detection. In
ConferenceonObjectOrientedProgramming,Systems,LanguagesandApplications
(OOPSLA). 70‚Äì82.
[69]ChristophvonPraunandThomasR.Gross.2003. Staticconflictanalysisformulti-
threaded object-oriented programs. In Conference on Programming Languages
Design and Implementation. ACM, 115‚Äì128.
[70]C. Wagner, G. Wagener, R. State, and T. Engel. [n. d.]. Malware analysis with
graph kernels and support vector machines. In 2009 4th International Conference
onMaliciousandUnwantedSoftware(MALWARE) (2009-10).63‚Äì68. https://doi.
org/10.1109/MALWARE.2009.5403018
[71]LiqiangWangandScottD.Stoller.2006. Accurateandefficientruntimedetection
of atomicity errors in concurrent programs. In Symposium on Principles and
Practice of Parallel Programming, (PPOPP). ACM, 137‚Äì146.
[72]Takashi Washio and Hiroshi Motoda. 2003. State of the Art of Graph-based Data
Mining.SIGKDD Explor. Newsl. 5, 1 (July 2003), 59‚Äì68. https://doi.org/10.1145/
959242.959249
[73]Andrzej Wasylkowski and Andreas Zeller. 2009. Mining Temporal Specifications
fromObjectUsage.In InternationalConferenceonAutomatedSoftwareEngineering
(ASE). IEEE, 295‚Äì306.
[74]Boris Weisfeiler and AA Lehman. 1968. A reduction of a graph to a canonical
form and an algebra arising during this reduction. Nauchno-Technicheskaya
Informatsia 2, 9 (1968), 12‚Äì16.
[75]JohnWhaley,MichaelC.Martin,andMonicaS.Lam.2002. AutomaticExtraction
of Object-Oriented Component Interfaces. In Symposium on Software Testing and
Analysis (ISSTA). ACM, 218‚Äì228.
[76]AmyWilliams,WilliamThies,andMichaelD.Ernst.2005. StaticDeadlockDetec-
tionfor JavaLibraries.In EuropeanConferenceon Object-OrientedProgramming
(ECOOP). Springer, 602‚Äì629.
[77]HenryWongandScottOaks.2004. JavaThreads (3rdeditioned.). O‚ÄôReillyMedia,
Inc.
[78]Min Xu, Rastislav Bod√≠k, and Mark D. Hill. 2005. A serializability violation
detector for shared-memory server programs. In Conference on Programming
Language Design and Implementation (PLDI). ACM, 1‚Äì14.
[79]Jinlin Yang, David Evans, Deepali Bhardwaj, Thirumalesh Bhat, and ManuvirDas. 2006. Perracotta: Mining temporal API rules from imperfect traces. In
International Conference on Software Engineering (ICSE). ACM, 282‚Äì291.
[80]Mu Zhang, Yue Duan, Heng Yin, and Zhiruo Zhao. [n. d.]. Semantics-Aware
Android Malware Classification Using Weighted Contextual API Dependency
Graphs. In Proceedings of the 2014 ACM SIGSAC Conference on Computer and
Communications Security (2014)(CCS ‚Äô14). ACM, New York, NY, USA, 1105‚Äì1116.
https://doi.org/10.1145/2660267.2660359
[81]YuZhou,RuihangGu,TaolueChen,ZhiqiuHuang,SebastianoPanichella,and
Harald Gall. 2017. Analyzing APIs Documentation and Code to Detect Directive
Defects.In Proceedingsofthe39thInternationalConferenceonSoftwareEngineering
(ICSE ‚Äô17). IEEE Press, Piscataway, NJ, USA, 27‚Äì37. https://doi.org/10.1109/ICSE.
2017.11
[82]YuZhou,RuihangGu,TaolueChen,ZhiqiuHuang,SebastianoPanichella,and
HaraldC.Gall.2017. AnalyzingAPIsdocumentationandcodetodetectdirective
defects.In Proceedingsofthe39thInternationalConferenceonSoftwareEngineering,
ICSE2017,BuenosAires,Argentina,May20-28,2017.27‚Äì37. https://doi.org/10.
1109/ICSE.2017.11
52
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. 