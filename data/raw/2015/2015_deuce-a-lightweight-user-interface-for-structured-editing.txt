Deuce: A Lightweight User Interface for Structured Editing
Brian Hempel, Justin Lubin, Grace Lu, and Ravi Chugh
University of Chicago
{brianhempel,justinlubin,gracelu,rchugh}@uchicago.edu
ABSTRACT
We present a structure-aware code editor, called Deuce, that is
equippedwithdirectmanipulationcapabilitiesforinvokingauto-
mated program transformations. Compared totraditional refactor-
ing environments, Deuceemploys a direct manipulation interface
thatistightlyintegratedwithinatext-basededitingworkflow.In
particular, Deucedraws (i) clickable widgets atop the source code
thatallowtheuserto structurallyselect theunstructuredtextfor
subexpressionsandotherrelevantfeatures,and(ii)alightweight,
interactive menu of potential transformations based on the cur-
rentselections.Weimplementandevaluateourdesignwithmostly
standardtransformationsinthecontextofasmallfunctionalpro-
gramminglanguage.Acontrolleduserstudywith21participants
demonstrates that structural selection is preferred to a more tradi-
tional text-selection interface and may be faster overall once users
gainexperiencewiththetool.Theseresultsaccordwith Deuce’s
aim to provide human-friendly structural interactions on top of
familiar text-based editing.
CCS CONCEPTS
•Softwareanditsengineering →Integratedandvisualdevelop-
mentenvironments; •Human-centered computing →Human
computer interaction (HCI);
KEYWORDS
Structured Editing, Refactoring, Direct Manipulation
ACM Reference Format:
Brian Hempel, Justin Lubin, Grace Lu, and Ravi Chugh. 2018. Deuce:A
Lightweight User Interface for Structured Editing. In ICSE ’18: 40th Interna-
tionalConferenceonSoftwareEngineering,May27–June3,2018,Gothenburg,
Sweden.ACM,NewYork,NY,USA,11pages.https://doi.org/10.1145/3180155.
3180165
1 INTRODUCTION
Plain text continues to dominate as the universal format for pro-
gramsinmostlanguages.Althoughthesimplicityandgenerality
oftextareextremelyuseful,thebenefitscomeatsomecosts.For
noviceprogrammers,theunrestrictednatureoftextleavesroom
for syntax errors that make learning how to program more diffi-
cult [Altadmriet al. 2016].For expert programmers, manyediting
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden
© 2018 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-5638-1/18/05...$15.00
https://doi.org/10.1145/3180155.3180165tasks—perhapseventhe vastmajority[Koet al.2005]—fallwithin
specific patterns that could be performed more easily and safely
by automated tools. Broadly speaking, two lines of work have,
respectively, sought to address these limitations.
StructuredEditing. Structurededitors—suchastheCornellProgram
Synthesizer [Teitelbaum and Reps 1981], Scratch [Maloney et al .
2010;Resnicketal .2009],andTouchDevelop[Tillmannetal .2012]—
reducetheamountofunstructuredtextusedtorepresentprograms,relyingonblocksandothervisualelementstodemarcatestructuralcomponentsofaprogram(e.g. aconditionalwithtwobranches,and
afunctionwithanargumentandabody).Operationsthatcreateand
manipulate structural components avoid classes of errors that may
otherwiseariseinplaintext,andtext-editingislimitedtowithin
well-formed structures. Structured editing has not yet, however,
becomepopularamongexpertprogrammers,inpartduetotheir
cumbersome interfaces compared to plain text editors [Monig et al .
2015], as well as their restrictions that even transitory, evolving
programs always be well-formed.
TextSelection-BasedRefactoring. Analternativeapproachininte-
grated development environments (IDEs), such as Eclipse, is to
augment unrestricted plain text with support for a variety of refac-
torings[Fowler1999;Griswold1991;Robertsetal .1997].Insuch
systems,theusertext-selectssomethingofinterestintheprogram—anexpression,statement,type,orclass—andthenselectsatransfor-
mation either from a menu at the top of the IDE or in a right-click
pop-up menu. This approach provides experts both the full flex-ibility of text as well as mechanisms to perform common tasks
more efficiently and with fewer errors than with manual, low-level
text-edits. Although useful, this workflow suffers limitations:
(1)The text-selection mechanism is error-prone when the item to
select islong, spanning a non-rectangularregion or requiring
scrolling [Murphy-Hill and Black 2008].
(2)Alltransformationsmustrequireasingle“primary”selection
argument, and any additional arguments are relegated to a
separate Configuration Wizard window.
(3)Thelistoftoolsistypicallyverylong—evenintheright-click
menu where tools that are not applicable to the primary se-
lection are filtered out—making it hard to identify,invoke, and
configure a desired refactoring [Mealy et al .2007; Murphy-Hill
et al. 2009; Vakilian et al. 2012].
(4)Evenwhenatransformationhasnoconfigurationoptionsor
whenthedefaultsareacceptable—asisoftenthecase[Murphy-
Hill et al.2009]—the user must go through a separate Configu-
rationWizardtomakethechange.Theusermust,furthermore,
navigatetoanotherpanewithintheConfigurationWizardto
preview the changes before confirming them.
OurApproach. Ourgoalistoenableaworkflowthatenjoysthe
benefits of both approaches. Specifically, programs ought to be
6542018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden Brian Hempel, Justin Lubin, Grace Lu, and Ravi Chugh
represented in plain text for familiar and flexible editing by ex-
pertprogrammers,andtheeditingenvironmentoughttoprovide
automatedsupportforavarietyofcodetransformationswithout
deviating from the text-editing workflow.
In this paper, we present a structure-aware editor, called Deuce,
that achieves these goals by augmenting a text editor with (i) click-
able widgets directly atop the program text that allow the user
tostructurallyselect theunstructured textfor subexpressionsand
other relevant features of the program structure, and (ii) a context-
sensitive tool menu with previews based on the current selections.
StructuralCodeSelection. Ratherthanrelyingonkeyboard-based
text-editsforselection,oureditordrawsdirectmanipulationwid-
getstostructurallyselect itemsinthecodewithasinglemouse-click.
In particular, holding down the Shift key transitions the editor into
structural selection mode. In this mode, the editor draws a box
(which resembles a text-selection highlight) around the code item
below the current mouse position. Clicking the box selects the en-
tiretextforthatcodeitem,eliminatinganypossibilityforerrorand
reducingthetimeneededtoselectlong,non-rectangularsequences
of lines. Furthermore, this interface naturally allows multiple se-
lection,evenwhenitemsarefarapartinthecode.Structuraltext
selection helps address concerns (1) and (2) above.
Context-Sensitive Menu with Previews. Because structural selection
naturally supports multiple selection, we address concern (3) by
showingonlytoolsforwhich allnecessaryargumentshavebeen
selected,reducingthenumberoftoolsshowntotheusercompared
to a typical right-click menu. Hovering over a result description
previewsthechanges,andclickingaresultchoosesit.Fortoolswithfewconfigurationoptions,webelievethepreviewmenuprovidesa
lightweight way to consider multiple options while staying within
the normal editing workflow, helping to address concern (4).
The resulting workflow in Deuceis largely text-driven, but aug-
mentedwithautomatedsupportforcodetransformations(e.g. to
introducelocalvariables,rearrangedefinitions,andintroducefunc-
tion abstractions) that are tedious and error-prone (e.g. because of
typos,namecollisions,andmismatcheddelimiters),allowingthe
usertospendkeystrokesonmorecreativeanddifficulttasksthat
are harderto automate.The name Deucereflects thisstreamlined
combination of text- and mouse-based editing.
Contributions. This paper makes the following contributions:
•Wepresentthedesignof Deuce,acodeeditorequippedwith
structuralcodeselection,alightweightdirectmanipulationmech-
anismthathelpstoidentifyandinvokeprogramtransforma-
tionswhile retaining thefreedom andfamiliarityof traditional
text-based editing. Our design can be instantiated for different
programming languages and with different sets of program
transformations. (§3.1)
•We implement DeucewithinSketch-n-Sketch , a program-
ming environment for creating Scalable Vector Graphics (SVG)
images.Mostofthefunctionalprogramtransformationsinour
implementation are common to existing refactoring tools, but
two transformations— Move Definitions andMake Equal —are,
to the best of our knowledge, novel. (§3.2)•To evaluate the utility of our user interface, we performed acontrolled user study with 21 participants. The results show
that, compared to a more traditional text selection-based refac-
toring interface, structural code selection is preferred and may
be faster for invoking transformations, particularly as users
gain experience with the tool. (§4)
Our implementation, videos of examples, and user study materials
are available at http://ravichugh.github.io/sketch-n-sketch/. In the
next section, we introduce Deuce with a few short examples.
2 OVERVIEW EXAMPLES
Example 1. De-
spite the inten-tion of the fol-
lowingprogram,
the redSquare
definition usesdifferent valuesfor the widthand height of
therectangle(the
fourth and fifth
arguments,respec-
tively, to the rectfunction). The user chooses Deucecode tools—
rather than text-edits—to correct this mistake.
The user presses the Shift key to enter structured editing mode,
and then hovers over and clicks the two constants 120and 80
to select them; the selected code items are colored orange in the
screenshotabove.Basedontheseselections, Deuceshowsapop-up
CodeToolsmenuwithseveralpotentialtransformations.The Make
Equal by Copying tool would replace one of the constants with the
other,thusgeneratingasquare.However,suchaprogramwould
require two constants to be changed whenever a different size is
desired. Instead, the user wishes to invoke Make Equal withSingle
Variableto introduce a new variable that will be used for both
arguments.Hoveringoverthismenuitemdisplaysasecond-level
menu (shown above) with tool-specific options, in this case, the
names of four suggested new variable names.
The user hovers over the second op-
tion, which shows a preview of the
transformed code (shown on the right).
Theuserclickstochoosethesecondop-
tion. Noticethat thenumber 80(rather than 120) waschosen tobe
thevalueofthenewvariable w.Whereasthetoolprovidedconfigu-
ration options for the variable name, it did not provide options for
which value to use; this choice was made by the implementor of
theMake Equal code tool, not by the Deuce user interface.
Example2. Consider the following program that draws two circles
connectedbyaline.Alldesignparametersandshapeshavebeenor-ganizedwithinasingletop-level
connectedCircles definition.To
makethedesignmorereusable,theuserwants connectedCircles
to be a function that is abstracted over the positions of the two cir-
cles. The user hovers over and clicks the defkeyword, and selects
theCreate Function from Definition tool (shown in the screenshot).
655
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. Deuce: A Lightweight User Interface for Structured Editing ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden
Inresponse, CreateFunc-
tionrewrites the defi-
nition to be a function
(shown on the right),
and previous uses of
connectedCircles are
rewritten to appropriate function calls (not shown).
Theorderofargumentstothefunctionmatchtheorderofdefini-
tions in the previous program, but that order was unintuitive—the
coordinates of the startandendpoints were interleaved. To fix
this,asshownabove,theuserselectsthelasttwoargumentsand
thetarget position (i.e.the space enclosed by a blue rectangular
selection widget) between the first two, and selects the Reorder
Arguments tool so that the order of arguments becomes startX,
startY,endX,and endY(notshown).Callsto connectedCircles
are, again, rewritten to match the new order (not shown).
Example 3. Intheprogrambelow,theuserwouldliketoorganize
all design parameters and shapes within the single logodefinition.
The user hovers over and selects the five definitions on lines 2
through 9, as well as the space on line 13, and selects the Move
Definitions tooltomovethedefinitionsinside logo.Thetransfor-
mationmanipulatesindentationanddelimitersappropriatelyinthe
final code (not shown).
3 Deuce: DESIGN AND IMPLEMENTATION
Inthissection,weexplainthedesignof Deuceinmoredetail.First,
we define a core language of programs where various structural
features can be selected. Then, we describe a user interface that
displays active transformations based on the set of structural se-lections. Finally, we describe a set of general-purpose program
transformations that are provided in our current implementation.
Little. Tomakethediscussionofourdesignconcrete,wechoose
to work with a small functional language called Little, defined in
Figure1.A Littleprogramisasequenceoftop-leveldefinitions,
the last of which is called main. Notice that all (sub)expressions,
(sub)patterns, definitions (both at the top-level and locally via let),program ::=•(defx0e0)•···•(def main e)
e::=c|x|(λpe)|(e1e2)|[e1|e2]
| (letpe1e2)|(casee(p1e1)···)
p::=c|x|[]|[p1|p2]
Expressions e::=•e•Patterns p::=•p•
Figure 1: Syntax of Little. The orange boxes and blue dots
identify features for structural selection.
EditorState = { code: Program, selections: Set Selection }
ActiveState = Active | NotYetActive | InactiveOptions = NoOptions | StringOption StringResult = { description: String, code: Program }
CodeTool =
{ name : String
, requirements : String, active : EditorState -> ActiveState, run : (EditorState, Options) -> List Result }
Figure 2: Code tool interface.
and branches of caseexpressions are surrounded in the abstract
syntaxbyorangeboxes;thesedenote codeitems thatwillbeexposed
forselectionanddeselectionintheuserinterface.Inaddition,there
aretarget positions , denoted by blue dots, before and after every
definition,expression,andpatternintheprogram.Targetpositions
are“abstractwhitespace”betweenitemsintheabstractsyntaxtree,
which will also be exposed for selection.
CodeToolInterface. Eachcodetoolmustimplementtheinterface
inFigure2.Atoolhasaccesstothe EditorState ,whichcontainsa
Program and the Setof structural Selection s within it. Based on
theEditorState ,theactivepredicatespecifieswhetherthetoolis
Active(readytorunandproduce Resultoptions), NotYetActive
(couldbe Activeifgivenmorevalidselections),or Inactive (in-
valid based on the selections). For example, Move Definitions is
NotYetActive if the user has selected one or more definitions but
no target position. When invoked via run, a tool has access to
theEditorState and configuration Options, namely, an optional
String.Thisstrategysupportstheubiquitous Renametool.Amore
full-featured interface may allow a more general set of configu-ration parameters; the challenge would be to expose them usinga lightweight user interface. In our implementation, all transfor-
mations besides Renamerequire NoOptions . Each Resultis a new
Programand a description of the changes.
ThisAPI betweenthe userinterface andcode toolimplementa-
tionsisshallow,inthesensethatacodetoolimplementationcan
do whatever it wants with the selection information. A framework
for defining notions of transformation correctness would be a use-
ful line of work, but is beyond the scope of this paper. Currently,
code tools must be implemented inside the Deuceimplementation.
Designing a domain-specific language for writing transformations
would be useful, but is also beyond the scope of this paper.
656
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden Brian Hempel, Justin Lubin, Grace Lu, and Ravi Chugh
Figure 3: Example target positions.
Implementation in Sketch-n-Sketch. We have chosen to im-
plementourdesignwithin Sketch-n-Sketch [Chughetal .2016;
Hempel and Chugh2016], an interactiveprogramming system for
generatingSVGimages.Whereas Sketch-n-Sketch providesca-
pabilitiesfordirectlymanipulatingthe outputofaprogram, Deuce
provides capabilities for directly manipulating the codeitself.
Direct code manipulation is particularly useful for a system like
Sketch-n-Sketch for a couple reasons. First, while the existing
output-directedsynthesisfeaturesin Sketch-n-Sketch attemptto
generate program updates that are readable and which maintain
stylisticchoicesintheexistingcode,thegeneratedcodeoftenre-
quires subsequent edits, e.g.to choose more meaningful names, to
rearrangedefinitions,andtooverridechoicesmadeautomatically
byheuristics; Deuceaimstoprovideanintuitiveandefficientinter-
face for performing such tasks. Furthermore, by allowing users to
interactivelymanipulatebothcodeandoutput,weprovideanother
step towards the goal of direct manipulation programmingsystems
identified by Chugh et al .[2016]. These two capabilities—direct
manipulation of code and output—are complementary.
Sketch-n-Sketch iswritteninElm(http://elm-lang.org/),alan-
guageinwhichprogramsarecompiledtoJavaScriptandruninthe
browser. The project uses the Ace text editor (https://ace.c9.io/) for
manipulating Littleprograms.(Thesecondreasonforthename
Deuceis that it extends Ace.) We extended Sketch-n-Sketch to
implement Deuce;ourchangesconstituteapproximately9,000lines
of Elm and JavaScript code. The new version ( v0.6.2) is available at
http://ravichugh.github.io/sketch-n-sketch/.
3.1 User Interface
Thegoalsofouruserinterfaceare,first,toexpose structural code
selection widgets —corresponding to the code items and target posi-
tionsina Littleprogram—and,second,todisplayaninteractive
menu of active transformations based on the set of selections.
So that the additional features provided by Deucedo not in-
trude on the text-editing workflow, we display structural selection
widgets when hovering over the code box only when the user is
holding down the Shift key. Hitting the Escape key at any time
deselects all widgets and clears any menus, returning the editor to
text-editingmode.Thisallowstheusertoquicklytogglebetween
editing modes during sustained periods in either mode. When not
using the Shift modifier key, the editor is a standard, monospace
code editor with familiar, unrestricted access to general-purpose
text-editing features.
3.1.1 Structural Code Selection. The primary innovation in our
designistheabilityto structurally select concretesourcetextcor-
responding to code items and target positions from the abstract
syntax tree of a program.
CodeItems. Ourcurrentimplementationdrawsaninvisible“bound-
ing polygon” around the source text of each expression, whichtightlywrapstheexpressionevenwhenstretchedacrossmultiple
lines.Thesepolygonsserveasmousehoverregionsforselection,
with the polygons of larger expressions drawn behind the (smaller)
polygonsforthesubexpressionssuchthatallpolygonsforchildex-
pressions partially occlude those of their parents. Because complex
expressions in Littleare fully parenthesized, it is always unam-
biguousexactlywheretostartandendeachpolygon,andthereare
alwayscharacterpositionsthatcanbeusedtoselectanarbitrary
subexpression inthe tree.Similarly,we createbounding polygons
for all patterns and definitions.
Whenhoveringoveraninvisibleselectionpolygon, Deucecolors
thepolygontoindicatethatithasbecomethefocus.Itstransparency
andstyleisdesignedtoresemblewhatmightotherwisebeexpected
for text selection ( cf.the screenshots in §2). Clicking a polygon
selectsthecodeitem,makingitvisibleevenafterhoveringaway.
Hovering the mouse back to the polygon and clicking it again
deselects the code item.
Target Positions. Theuserinterface alsodrawspolygonsforthe
whitespacebetweencodeitemsforselectingtargetpositions.Fig-
ure 3 (left) shows how our implementation draws whitespace poly-
gonsslightlytotheleftofthebeginningofaline,anduntiltheend
ofalineeveniftherearenocharactersonthatline.Figure3(center)
shows whitespace polygons with non-zero width even when there
are no whitespace characters between adjacent code items.
Another concern is that many target positions in the abstract
syntax from Figure 1 describe the samespace between code items.
For example, the expression [•50••70•]on line 3 of Figure 3
contains both an after- 50and before- 70position. Because such
target positions between adjacent items are redundant, our imple-
mentation draws only one whitespace polygon. (This polygon is
not selected in any of the screenshots.)
A more interesting case is for the code items (def•p••e•)
and(let•p••e•···);thereisbothanafter- ptargetandabefore-
etarget.Toallocatethewhitespacebetween pande,wetakethe
following approach. The space up to the first newline, if any, isdedicated to after-
p; the remaining is for before- e. If there is no
newline,thenwedonotexposeanyselectionwidgetforbefore- e.
For comparison,notice howthe whitespacefrom theend ofline 2
to beginning of line 3 in Figure 3 (right) is split into two polygons,
but the whitespace from the end of line 3 to the beginning of line 4
in the Figure 3 (left) is not. In other settings, it may be worthwhile
to consider alternative approaches to the design decisions above.
3.1.2 Displaying Active Code Tools. Severalprogramtransforma-
tions may be Activebased on the items and targets that are se-
lected.Wedesignandimplementalightweightuserinterfacefor
identifying, invoking, and configuring Activetransformations.
Pop-upPanel. Whentheuserhasenteredstructurededitingmode
(by pressing Shift) and selected at least one item, we automatically
657
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. Deuce: A Lightweight User Interface for Structured Editing ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden
displayamenuneartheselecteditems.Theuserhasalreadypressed
akeytoenterthismode,soourdesigndoesnotrequirearight-click
to display the menu. The user can drag the pop-up panel if it is
obstructingrelevantcode.Weoftenmanuallyre-positionedpop-up
menus to make the screenshots in §2 fit better in the paper.
HoverPreviews. Eachtoolinthemenuhasalistof Results,which
appear in a second-level menu when hovering the tool name. Each
second-levelmenuitemdisplaysthe description ofthechange,
and hovering over it previews the new codein the editor. Clicking
theitemconfirmsthechoiceandclearsall Deuceselections.When
there are few Results(i.e.configuration options), this preview
menu provides a quick way to consider the options, rather than
going through a separate Configuration Wizard. For tools that
requiremultipleandnon-trivialconfigurations, however, theeditor
could fall back on separate, tool-specific Configuration Wizards;
our current implementation of Deuce does not support this.
3.2 Program Transformations
We have implemented a variety of pro-
gramtransformations,shownontheright.
While we believe these transformations
form a useful set of basic tools for com-mon programming tasks, we do not ar-gue that these constitute a necessary orsufficient set. One benefit of our design
is that different sets of transformations—
such as refactorings for class-based lan-guages [Fowler 1999], refactorings for
functionallanguages[ThompsonandLi
2013], transformations that selectively
changeprogrambehavior[Reichenbach
et al.2009], and task-specific transforma-
tionsthatdonothavecommon,recogniz-
able names [Steimann and von Pilgrim
2012]—canbeincorporatedanddisplayed
to the user within our interface.
We limit ourdiscussion below to transformations that are not
implemented in existing refactoring tools. The Supplementary Ap-
pendices[Hempeletal .2018]describeothertransformations,but
these details are not necessary to understand the rest of the paper.
MakeEqualwithSingleVariable. Whenmultipleconstantsand
anoptionaltargetpositionareselected,the MakeEqualwithSingle
Variabletransformationintroducesanewvariable,boundtooneof
the constants, and replaces all the constants with the new variable.
This has the effect of changing the program to make each of these
valuesequal.Thetransformationattemptstosuggestmeaningful
names, based on how the selected expressions appear in the pro-gram. For Example 1 from §2, because the numbers
120and80
are passed as the fourth and fifth arguments, respectively, to thefunction
(def rect (\(fill x y w h) ...)) , the suggested
names include wandh. The user is asked to choose a name. The
valueitself(inthiscase, 120or80)isnotasimportant—theinten-
tion is that the values vary at once by a single change—so, to keep
the number of Results small, the transformation does not ask the
user to choose which value to use for the variable.Move Definitions. Because of nested scopes and simultaneous
bindings( i.e.tuples),therearemanystylisticchoicesaboutvariable
definitions when programming in functional languages. The Move
Definitions transformation takes a set of selected definitions and
a single target position, and attempts to move the definitions tothe target position. If the target position is before an expression,
ane w let-bindingisaddedtosurroundthetarget.Whitespaceis
addedorremovedtomatchtheindentationofthetargetscope.If
thetargetpositionalreadydefinesalistpattern,thentheselected
definitionsareinsertedintothelist.Ifthetargetpositiondefines
asinglevariable,thenalistpatterniscreated.Incaseswherethe
intendedtransformation wouldcapture variableusesor movedef-
initions above their dependencies (errors that are easy to make
when using text-edits alone), the transformation makes secondary
edits(alpha-renamingvariablesandmovingdependencies)tothe
programtoavoidtheseissues.Ourimplementationof MoveDefini-
tionsalso provides options for whether or not to collapse multiple
definitions into a single tuple, and also provides support for rewrit-
ing arithmetic expression definitions as an alternative way to deal
with dependency inversion issues.
4 USER STUDY
We designed and implemented Deucewith the goal to incorporate
structurededitingwithinatext-basedprogrameditor.Inthissec-
tion,wedescribeauserstudydesignedtomeasurethedegreeto
which we were successful.
Besidesthetwonovelmechanismsinouruserinterfacedesign—
structuralcodeselectionandcontext-sensitivepreviewmenus—that
wewishtoevaluate,thereareseveraladditionalfactorsatplay.First,
many users may not have extensive experience with functionalprogramming languages, especially the custom
Littlelanguage
supportedinourimplementation.Second,ourimplementationpro-
videssomefamiliartransformationsbutsome—particularlythose
involving targetpositions—are not.Furthermore, someusers may
prefertousetext-editingratherthanstructurededits,evenwhen
the latter can be used. These factors make it hard to perform a
directcomparisonbetweenourimplementationof Deuceandan
existing system, such as Eclipse.
To mitigate these factors, we designed a study that compared
Deucewith a “baseline” version of the system, with features de-
signed to emulate the traditional text-select-based interface de-scribed in §1. We then designed tasks, to be completed in both
versions and
withouttext-edits, to measure the effect of the new
Deuceuserinterfacefeaturescomparedtothebaselineones.Below,
wedescribethedifferentconfigurationsofoursystem,ourstudy
procedures, and our results.
4.1 System Configurations
Recall that tools may be ActiveorNotYetActive based on one or
more selected items and target positions (Figure 2).
Traditional Mode (“Text-Select Mode”). To form the traditional
mode of the tool, which we called Text-Select Mode in the user
studymaterials,weimplementedfourinteractionsseparatefrom
the workflow described in §2 and §3.1 to invoke code tools.
658
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden Brian Hempel, Justin Lubin, Grace Lu, and Ravi Chugh
(A)CodeToolsMenu. TheeditordisplaysaCodeToolsmenuatthe
top of the window with a list of all transformations available in
the system; this menu is akin to the Source and Refactor menusin Eclipse. The user selects a tool from this menu without first
selecting anything in the program. Then, the editor displays a
Tool Configuration Panel that displays tool-specific instructions.
Tool Configuration Panels, which appear in all four interactions of
Traditional Mode, are discussed below.
(B)Text-SelectSingleArgument+CodeToolsMenu. Thisinteraction
islikeInteraction A,exceptthattheuserfirst text-selectsanitem
ortargetinthecode.LikeEclipse,text-selectingrequirestheentire
item to be selected, possibly with trailing or leading whitespace.
Our implementationprovides moregenerous text-selectionmech-
anisms (e.g.largest containing expression, smallest surrounding
expression),butthestricterversionisusedinthestudybecauseitis
more similar to existing approaches [Murphy-Hill and Black 2008].
Also like Eclipse, all tools are displayed and enabled in the Code
Tools menu, even if the tool is Inactive based on the selection.
(C)Text-SelectSingleArgument+Right-ClickMenu. Afterfirsttext-
selectinganitem,asinInteractionB,theuserright-clickstotrig-
ger a pop-up menu that displays onlyplausible tools ( Activeor
NotYetActive). A similar workflow is provided by Eclipse.
Returning to Example 1 from § 2,
the screenshot on the right shows the
right-clickmenuaftertext-selectingthe
120constant. By comparison, notice
how this right-click menu displays more
tools ( NotYetActive tools in addition to
Activeones).Afterthetextselectionis
made,theeditordrawsanorangebox(as
withDeucewidgets) to identify the se-
lection.
(D) Cursor-Select Single Argument + Right-Click Menu. For atomic
code items ( i.e.constants and variables), the user implicitly selects
theitembyright-clickingonthetoken(ratherthantext-selectingit)
totriggertheright-clickmenu,asinInteractionC.Again,asimilar
workflow is provided by Eclipse.
Tool Configuration Panels. Each of the
four interactions above trigger ToolConfiguration Panels, which display
therequirements string that explains
howtoinvokethetool.Theuserselects
any additional arguments by hovering
over and clicking structural selection
widgets. That is, structural selection
widgets are notaccessible to make the
primary selection, but they areused to
makeallremainingselectionsinaTool
Configuration Panel. The screenshotabove shows the Configuration Panel after text-selecting
120,a s
above, and then selecting 80and a target position using structural
selection.Becausethetoolrequirementsaresatisfied,thepaneldis-
plays the list of Results, each of which can be hovered to preview
the change before selecting it.DeuceMode(“Box-SelectMode”). Thisconfiguration,calledBox-
Select Mode in the user study materials, isolates the new Deuce
features. To review, the user holds down the Shift key, then hovers
overandclicksoneormorestructuralcodeselectionwidgets.When
atleastonewidgetisselected,thepop-uppreviewmenudisplays
the list of Activetools.
ThereisnoCodeToolsmenuatthetopoftheeditorinthismode,
even though the “full” version of our tool (not used by participants
inthestudy)does;thelistoftoolnamesanddescriptionsinTool
ConfigurationPanels(whichare notaccessiblein DeuceMode)can
help understand unfamiliar transformations.
CombinedMode. OurlastconfigurationcombinesTraditionaland
Deuce Modes, with all interactions described above.
4.2 Questions and Procedures
We sought to address several questions:
•Iseithermodemoreeffectivefor(a)completingtasks,(b)rapid
editing, or (c) achieving more with fewer transforms?
•Is either mode preferred by users? In which cases?
Toanswerthesequestions,wedesignedthefollowingIRB-approved,
controlleduserstudywith21undergraduateandgraduatestudents
from the University of Chicago. We recruited users by sending
emails to public mailing lists, offering a monetary incentive of
$50 for participating in the two-hour study. Prior experience with
functional programming or Sketch-n-Sketch was not required.
Each user attended an individual session and was given the option
to use the laptop and mouse provided by us or their own devices.
Theprimarycomponentsofthestudyincludedatutorialportion
followedbyatasksportion.Weconfiguredapared-downversionof
thesystemthatturnedoffall Sketch-n-Sketch featuresunrelated
to the interactions being studied. The tutorial and tasks were setup as a self-guided progression of steps through the tool, to be
completed at the user’s own pace. In the description of the tutorial
andtasksbelow,allrandomchoicesweremadeindependentlyof
other choices, as well as across users.
Our system logged user events to analyze the tutorial and tasks.
Wealsorecordedvideooftheusersperformingthetasks,formanual
inspection in situations where the log information was insufficient
or more difficult to process. Besides helping to get started and
correctminorissuesunrelatedto Deuce,theuserstudyproctordid
not answer any questions about Deuceor the tasks. To wrap up,
users answered questions about their programming background
and experience using Deuce in an exit survey.
Tutorial. The first part of the tutorial introduced ordinary text-
based programming in Little, emphasizing that the syntax would
not be too important for subsequent tasks.
Themajorityofthetutorialintroducedthecodetoolsusingboth
Traditionaland DeuceModes.Thefirsttoolintroduced— Rename
Variable,afamiliartooltomany—wasexplainedusingallfivein-
teractionmodes.ButbecausethefourinteractionsinTraditional
Mode are largely similar, all subsequent tools introduced in the tu-
torial had only one set of instructions for Traditional Mode. For all
tools introduced, a random choice was used to determine whether
to explain Traditional or DeuceMode first. In total, 10 of the 22
codetoolsinourimplementationweredemonstratedinthetutorial.
659
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. Deuce: A Lightweight User Interface for Structured Editing ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden
Table1:Overviewofthefourhead-to-headandtwoopen-endedtasks.#LOCisnon-blanklinesofcodeinthestartingprogram.
Name #LOC #Transforms Example Tool Sequence (with minimum number of transforms required)
One Rectangle 9 3 Swap Expressions; Move Definition; Swap Definitions
Two Circles 11 2 Create Function from Definition; Reorder ArgumentsThree Rectangles 11 2 Creating Function by Merging Definitions; Rename
Four Rings 7 4 Remove Argument; Rename; Move Definition; Add Arguments
Four Squares 9 7 Create Function by Merging Definitions; Create Function from Arguments; Rename (5x)
Lambda Icon 10 8 Make Equal with Single Variable (6x); Introduce Variable; Rename
To give a flavor of the tutorial, Example 1 in §2 is adapted from
the steps that introduced the Make Equal tools. In addition to tool-
specific tutorial steps, we also dedicated a step for more practice
with target positions, independent of a specific tool, because the
notion of target positions was likely to be unfamiliar.
Tasks.Afterthetutorial,usersworkedonsix tasks,eachadifferent
programandalistofoneormoreeditstoperformusingcodetools.
For some tasks, there were multiple different sequences of code
tool invocations that could lead to the desired result. The starting
programsrangedfrom7to11linesofcodeandrequiredbetween
2and8toolinvocations(atminimum)tofinishthetasks.Table1
outlinesthetasks.TheTwoCirclestaskwaspresentedasExample2
in§2.ExtendedtaskdescriptionscanbefoundintheSupplementary
Appendices [Hempel et al. 2018].
Before every task, the participant was given a read-only reading
period to understand the program before seeing the list of edits
toperform.Toemulateareal-worldscenariowheretheprogram-
mer knows what to accomplish but may not quite remember all
thesteps,thetaskdirectionswerewritteninamorenaturalstyle
without direct reference to tool names—for example, “move the
ringdefinitioninside target”insteadof“invoke Move Definition
on the ringdefinition with a target position inside target.”
Eachofthefirstfourtasks(“head-to-headtasks”)wasperformed
twice, once each in Traditional and DeuceModes, resulting in
eighttrials.Thefirstfourtrialscomprisedeachofthefourtasks,in
randomorderandwithoneofthemodesrandomlychosenpertrial.
Forthenextfourtrials, theorderoftaskswas,again,randomized,
each using the mode not chosen for the task in the first round.
After these eight trials, the user performed each of the last two
tasks(“open-endedtasks”)onceusingtheCombinedMode—both
Traditionaland DeuceModeswereavailableforuse,tomix-and-
match the two modes however they saw fit.
For each task, comments showed what the desired final code
should look like, sometimes modulo minor whitespace differences.
The editor provided an indicator about whether the task was com-
pleted,givingtheusertheoptiontoGiveUpatanypointifneeded.
There was also a maximum time limit of six and twelve minutes
foreachhead-to-headandopen-endedtask,respectively,withno
indication about the time limit until and unless the user reached
the two and four minutes remaining mark, respectively.
4.3 Results
Participants reported between 2 and 10 yearsof programming ex-
perience(mean:5.1),ofwhichbetween0and3yearsinvolvedfunc-
tional programming (mean: 0.76). 10 participants (48%) reportedno prior functional programming experience. 8 participants re-
portedusingtoolsthatsupportedautomatedrefactoring(Eclipse,
IntelliJ, and PyCharm all received multiple mentions). 4 partici-pants reported some prior exposure to previous versions of the
Sketch-n-Sketch project, but none reported knowledge of the
code tools presented in the study.
Forthestudyitself,8usersbroughttheirownlaptop,theremain-
ing13usedours.15participantsusedamouse,and6reliedontheir
laptop’strackpad.Eachsessiontookameanof1hr44min(range:
1h 11m– 2h27m). Usersspent between23 and66 minuteson the
tutorial(mean:41)and20and65minutesonthetasks(mean:44).
The remaining time was spent on introductory remarks and the
exitsurvey.Allusersattemptedalltasks.Twotrialswerediscarded
because of tool malfunction, for a final total of 166 head-to-head
trials and 42 open-ended tasks suitable for analysis.
The tasks proved moderatelydifficult. On average, each partici-
pant successfully completed 71% of the trials and open-ended tasks
within the time limits, with 3 users completing them all and 1 user
failing to completeany. Figure4 shows completion rates by task.
The One Rectangle and Lambda tasks had particularly low comple-
tionrates.Basedonvideosoffailedattempts,manyusersstruggled
with choosing appropriate tools— e.g.many chose Introduce Vari-
ablesrather than Make Equal , and some chose Inlinerather than
MoveDefinitions inanattempttocreateatupledefinition.Thetuto-
rialwasnotsufficientforeveryonetorememberandunderstandall
the tools needed for the tasks. The task descriptions may have also
presented obstacles— e.g.for Lambda, the phrase “Define and use...”,
along with (def [x y w h] ...) in the final code, may have led
some to use Introduce Variables , which would then require several
roundabout transformations to complete the task. We believe these
difficulties are largely independent of the user interface features.
We now address each of the research questions in turn.
Is either mode more effective for completing tasks?. Figure 5
breaks down completion rates for head-to-head tasks by mode. Be-cause each was attempted twice, to assess possible learning effects
from already completing a task in the other mode, Figure 5 alsodifferentiates between the user’s first or second encounter with
each task. Visually, the data suggest that on the first encounter
with a task, Traditional Mode may better facilitate completion, and
isalsoabetterteacherforthesubsequentencounterwith Deuce
Mode. In contrast, a first encounter with DeuceMode may be less
helpful for the second encounter with Traditional Mode.
To control for learning effects, a mixed effects logistic regres-
sionmodel[GelmanandHill2007]wasfitwith lme4[Batesetal .
2015]topredicttaskcompletionprobabilitybaseduponfixedeffect
660
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden Brian Hempel, Justin Lubin, Grace Lu, and Ravi Chugh
1Rect 2Circles 3Rects 4Rings 4Squares Lambda0%100%Completion Rate46.3%81.0% 81.0% 80.5%85.7%
47.6%
Figure 4: Task completion rates pooled over both modes.
1Rect 2Circles 3Rects 4Rings Overall0%50%100%Completion Rate           
12 12 12 12 12Traditional
Deuce
Figure 5: Head-to-head task completion rates by mode and
bysubject’sfirst/secondencounterwithtask.Overlaidlinesindicated pooled completion rates.
predictors for the mode (coded as 0 or 1), the trial number (1-8),
whetherthetrialwasthesecondencounterwiththetask(0or1),
whether the participant used a mouse (0 or 1), whether the partici-
pant used their own computer (0 or 1), and the interaction of mode
withthesecondencounter(0,or1when DeuceModeandasecond
encounter). To model differences inuser skill and task difficulty, a
randomeffectwasaddedforeachparticipantaswellaseachtask,
and a random interaction was added to model differences in the
secondencounterdifficultypertask.Reportedp-valuesarebased
on Wald Z-statistics.
In the fit model, the coefficient for mode was on the edge of
significance (p=0.057), indicating that Traditional Mode did better
facilitate task completion on the first encounter with a task. Given
this,DeuceModeperformedbetterthanexpectedonthesecond
encounter(interactiontermp=0.036),butnotenoughtoconfidently
say thatDeuceMode was absolutely better than Traditional Mode
forthesecondencounter(p=0.17).Nootherfixedeffectcoefficients
approached significance.
DeuceMode therefore seems to present a learning curve, but
may be just as effective as Traditional Mode once that learning
curve is overcome. This interpretation accords with the surveys: 5
participants wrote that Traditional Mode might be better for learn-
ing, and 4 participants—including 3 of the previous 5—said Deuce
Modewasbetterwhentheyknewthedesiredtransformation.How-ever,thedatamaybealternativelyexplainedif
DeuceModeonthe
firstencounterisapoorteacher,activelymisleadingusersonthe
second encounter with Traditional Mode.
Is either mode more effective for rapid editing? Among trials
successfully completed, the duration of each trial was measured
from the start of configuration of the first refactoring to the end of
the final refactoring. The distribution of these timings is presented
in Figure 6, scaled relative to the mean duration for each task.1Rect 2Circles 3Rects 4Rings Overall01234Rel Time (vs task mean)
12 12 12 12 12Traditional
Deuce
Figure 6:Head-to-head taskdurations for successfullycom-
pleted trials, scaled relative to the mean time per task.
Again, to tease out if any of these differences are significant,
from the same predictors described above two linear mixed effects
modelswerefittopredict(1)trialdurationand(2)thelogarithm
of trial duration ( i.e.considering effects to be multiplicative rather
than additive). Percentile bootstrap p-values for the fixed effect
coefficientswerecalculatedfrom10,000parametricsimulate-refit
samples.1For the first encounter with a task, Traditional Mode
wasinsignificantlyfaster(by13seconds,p=0.44;or9.2%,p=0.52).
However, DeuceMode was on average 25 seconds (p=0.13) or 36%
(p<0.01) faster for the second encounter with a task, suggesting
thatDeuceModemaybefasteronceusersbecomefamiliarwith
the available tools. Most of the gain comes from less time spent
inconfiguration—after discountingallidle thinkingtimebetween
configurations, the model still reveals an 18 second difference.
Is either mode more effective for achieving more with fewer
transforms? Todetermineifeithermodefacilitatedmoreefficient
use of interactions, the same mixed effects model was fit to predict
the number of refactorings invoked during each successful trial, as
well as the number of Undos. On the first encounter with a task,
TraditionalModeaccountedforanaverageof2.0fewerrefactorings(p
<0.01)and2.1fewerUndos(p <0.01),butonthesecondencounter
nosignificantdifferenceinnumberofrefactoringsorUndoswas
indicated.As asecondencounterwith DeuceModeis fasterthan
TraditionalMode,the speedgainthus appearstobeexplainedby
faster invocations rather than fewer invocations.
Is either mode preferred by users? In which cases? The two fi-
nalopen-endedtasksallowedparticipantstomix-and-matchthe
twomodesastheypleased.AsshowninFigure7,onbothtasksthe
overwhelming number of users performed a greater share of refac-
toringsusing DeuceMode.Webelieveamainadvantageof Deuce
Modeisthatitsimplifiestheconfigurationofrefactoringsthatre-
quire multiple arguments, as the user may select all the arguments
togetherbeforechoosingatransformationfromashortmenu.In
Traditional Mode, the workflow is stuttered: the user must select a
singleargument,right-clicktochooseatransformation,thenselect
theremainingarguments.However,forarefactoringrequiringonly
a single argument, Traditional Mode is more streamlined: a usermay simply select the desired transformation immediately afterright-clicking on the first argument. Thus, for single-argumentrefactorings,
DeuceMode’s advantages may be limited. A break-
downofmodeusagebypopulartools(Figure8)lendssupportto
1See https://www.rdocumentation.org/packages/lme4/versions/1.1-13/topics/bootMer
661
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. Deuce: A Lightweight User Interface for Structured Editing ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden
T D
4Squares051015#Participants
T D
LambdaT D
Overall
Figure7:DistributionofuserpreferencesforTraditionalvs.
Deuce Modes as measured by the ratio of refactorings per-formed by the user in each mode on the open-ended tasks.Far left represents all Traditional Mode refactorings; far-right indicates all Deuce Mode refactorings. The 95% con-fidence interval for the mean preference across all users isindicated (via percentile bootstrapping, 10,000 samples).
0% 5% 10% 15%
Mean Proportion of User's RefactoringsRename
Make Equal with Single Variable
Introduce Variable(s)
Add Argument(s)
Create Function from Arguments
Move Definition(s)
Inline Definition(s)
Create Function by Merging Definitions
Create Function from DefinitionTraditional
Deuce
Figure8:Modeusagefortoolsusedbyatleasthalfofpartici-pantsontheopen-endedtasks.Deucemodeispreferredformost tools. Stars indicate differences significant at the 95%level (via percentile bootstrapping, 10,000 samples).
this hypothesis. For the most commonly used tool, Rename, which
always takes only a single argument, participants used Traditional
andDeuceModeswithroughlyevenfrequency.Mostothertools
showed strong preferences towards DeuceMode, with the notable
exception of Create Function by Merging Definitions . Because the
FourSquarestaskrequiredinvokingthistoolwithfourexpressions,
according to the hypothesis, users should prefer DeuceMode. The
videos revealed that several users were unable to discover how
tostructurallyselectafunctioncall,whichrequiredhoveringon
the open parenthesis (not demonstrated in the tutorial). Several of
these users were, however, able to invoke the tool by text-selecting
a function call or by starting from the full Code Tools menu.
Subjectively,theconcludingsurveyaskedwhether DeuceorTra-
ditional Mode worked better for each head-to-head task, measured
on a 5-point scale from “Text-Select Mode worked much better”
to“Box-SelectModeworkedmuchbetter”.Foreachparticipant,a
randomchoicedeterminedwhichmodeappearedateachendofthescale.AsshowninFigure9,onaverageasimilarmodestpreference
for Deuce Mode was expressed for each task.T D
1Rect051015#Responses
T D
2CirclesT D
3RectsT D
4RingsT D
Overall
Figure 9: Surveyed subjective preference for Traditional vs.Deuce Modes for the head-to-head tasks. The 95% confi-dence interval for the mean preference across all users isindicated (via percentile bootstrapping, 10,000 samples).
On the free-response portion of the survey, several explanations
weregivenforthispreferencefor DeuceMode.3participantsappre-
ciated the ability to select multiple arguments; 2 other participants
appreciated selecting all arguments before selecting a tool; 1 other
participant appreciated the smaller menu of refactorings; and 1
otherparticipantappreciatedtheeaseofstartingarefactoringby
clicking code objects rather than having to create a text selection.
Altogether,usersdemonstratedastrongobjectiveandmodest
subjectivepreferencefor DeuceoverTraditionalMode,suggesting
thatDeuceaccomplishesitsgoaltoprovideamorehuman-friendly
interface to identify, configure, and invoke refactorings.
Limitations. There are several threats to the validity of our ex-
perimental setup. One is that our emulation of traditional features
mayhavebeenlesseffectivethanthosefeaturesinexistingtools.
Another is that the participants may have felt compelled to use
DeuceMode (which could likely have been deduced to be more
novel than Traditional Mode) more during the open-ended tasks—
andpronounceapreferenceforitinthesurvey—becausethepar-
ticipantsweredrawnfromthesameacademiccommunityasthe
authors.Anotheristhatparticipantsusedthetoolinheterogeneous
environments—different computers and browsers, configured with
differentscreensizesandmousesettings.Performanceonthetasks
may have also been affected by the presence of the user study
proctor and video recording device. According to self-reported as-
sessments, participants were relatively unfamiliar with functional
programming andwith refactoring tools, sothe results maydiffer
for users with more extensive experience. Finally, our results were
obtained on small programs and tasks in a prototype language.Future Improvements.
There are opportunities to improve our
implementation of Deuce. First, to reduce the learning curve, it
wouldbeworthaddingmoreexplanatoryfeatures( e.g.inatutorial,
orwithinthetoolwhentheuserselectscertainkindsofitemsfor
thefirsttime),particularlyforunfamiliartransformations( e.g.Move
Definitions ) and for unfamiliar user interface features ( i.e.target
positions).EnablingthefullCodeToolsmenumayalsohelpbecause
ofthedescriptionsofrequirementsintheToolConfigurationPanels
(cf.the “DeuceMode” discussion).Also, to alloweasy corrections
ofmisconfiguredrefactorings,itwouldhelpifUndorestoredthe
previousselectionstateratherthanjustthepreviousversionofthe
code; we have since implemented this feature.
662
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden Brian Hempel, Justin Lubin, Grace Lu, and Ravi Chugh
5 RELATED WORK
Wedescribethemostcloselyrelatedideasinstructurededitingand
refactoring. Ko and Myers [2006], Lee et al .[2013], and Omar et al .
[2017] provide more thorough introductions.
5.1 User Interfaces for Structured Editing
Compared to traditional text-selection and menus, several alterna-
tiveuserinterfacefeatureshavebeenproposedtointegratestruc-
tured editing more seamlessly within the text-editing workflow.
Text Selection. Murphy-Hill and Black [2008] identify that text
selection-based refactoring is prone to error, particularly for state-
mentsthatspanmultiplelinesandthathaveirregularformatting.
They propose two prototype user interface mechanisms, called Se-
lectionAssistandBoxView,tohelp.WithSelectionAssist,theuser
positions the cursor at the start of a statement, and the entire state-
ment is highlighted green to show what must be selected (using
normal text-selection). With Box View, the editor draws a separate
panel (next to the code editor) that shows the tree structure of
theprogramwithnestedboxes.Whenselectingtextintheeditor,
the nested boxes are colored according to which code items are
completelyselected.Similarly,theusercanselectanestedboxin
the Box View to select the corresponding text in the code.
In contrast, our structural selection polygons are drawn directly
atopthecode,atoncehelpingtoidentify(likeBoxView)andselect
(likeSelectionAssist),whichaimstomitigatethecontextswitching
overhead of Box View identified by Murphy-Hill and Black [2008].
Drag-and-DropRefactoring. Leeetal.[2013]proposeatoolcalled
DNDRefactoring that eliminates the use of menus altogether.
They demonstrate how many common Eclipse refactorings can
beunambiguouslyinvokedwithadrag-and-dropgesturewithout
the need for any additional configuration. This is a compelling
workflow for situations in which the user can (a) readily identify
an intended refactoring based on a preconceived notion ( e.g.its
name), (b) unambiguously invokethe intended refactoring by a
single-source,single-target drag-and-dropgesture,and(c) accept
thedefault configuration of the refactoring. It would be useful to
add drag-and-drop gestures to Deucefor transformations that sat-
isfythesethreeconditions.However,ouruserinterfacesupports
situations when one or more of these three conditions fails to hold.
Hybrid Editors. Compared to “fully” structured editors, several
hybrid editor approaches augment text-based programs with addi-
tional information. Barista [Ko and Myers 2006] is a hybrid Java
editorwhere structureviews canbeimplementedtopresentalter-
naterepresentationsofstructuralitemsinsteadoftext.Forexample,
an arithmetic expression may be rendered with mathematical sym-
bols, a method may be accompanied by interactive documentation
with input-output examples, and structures may be selectively col-
lapsed,expanded,orzoomed.Omaretal .[2012]introduceasimilar
notion to structure views, called palettes, where custom displays
can be incorporated based on the type of a subexpression. Forexample, a color palette can provide visual previews of different
candidatecolor values,anda regularexpressionpalette canshow
input-output examples for different candidate regular expressions.
In Greenfoot [Brown et al .2016], program text is separated into
structuralregionscalled frames,whicharecreatedandmanipulatedwith text- andmouse-based operations that are orthogonalto the
text-editswithinaframe.CodeBubbles[Bragdonetal .2010]allows
text fragments to be organized into working sets, which are collec-
tions of code, documentation, and notes from multiple files that
canbeorganizedinaflexibleway.Outsideoftheviews,palettes,
frames, and working sets in the above hybrid editors, the user has
access to normal text-editing tools.
Our approach is complementary to all of the above: in places
where code fragments—regardless of their granularity and their
relationship to alternative or additional pieces of information—are
representedinplaintext,weaimforalightweightuserinterfaceto
structurally manipulate it.
Refactoring with Synthesis. In contrast to direct manipulation
inDNDRefactoring andDeuce, Raychev et al .[2013] propose
a workflow where the user starts a refactoring with text-edits—
providing some of the changes after the refactoring—and then asks
the tool to synthesize a sequence of refactorings that complete the
task.Thistext-basedinterfaceandthemouse-basedinterfacesof
DNDRefactoring and Deuce are complementary.
5.2 Program Transformations
Automated support for refactoring [Fowler 1999; Griswold 1991;
Roberts et al .1997] has been aimed primarily at programs written
in class-based, object-oriented languages.Refactoring for Functional Languages. HaRe
[Brown 2008; Li
2006; Thompson and Li 2013] is a refactoring tool for functional
languages, such as Haskell, where features—including first-class
functions ( i.e.lambdas), local bindings, tuples, algebraic datatypes,
and type polymorphism—lead to editing tasks that are different
fromthosesupportedinmosttypicalrefactoringtoolsforobject-
oriented programs. Our user interface could be incorporated by
HaReto expose the supported transformations with lightweight
direct manipulation. HaReprovides a larger catalog of transfor-
mations than our current implementation of Deuce. However, the
detailsofour MoveDefinitions andMakeEqual transformationsare,
to the best of our knowledge, not found in existing tools.
6 CONCLUSION
Basedonourexperienceandtheresultsofouruserstudy,webe-
lieveDeucerepresents a proof-of-concept for how to achieve a
lightweight, integrated combination of text- and structured editing.Infuturework,ourdesignmaybeadaptedandimplementedforfull-
featured programming languages and development environments,
incorporating additionalwell-known transformations( e.g.Fowler
[1999]; Thompson and Li [2013]). Additional direct code manipula-
tion gestures, aswell as incremental parsing (e.g. the algorithm of
Wagner and Graham [1998] used by Barista [Ko and Myers 2006]),
could further help streamline, and augment, support for structured
editing within an unrestricted text-editing workflow.
ACKNOWLEDGMENTS
Theauthorsthank ShanLu,ElenaGlassman, AaronElmore,Peter
Scherpelz,andBlaseUrforsuggestionsaboutthispaper.Thiswork
was supported by National Science Foundation Grant No. 1651794,
and a University of Chicago Liew Family Research Fellows Grant.
663
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. Deuce: A Lightweight User Interface for Structured Editing ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden
REFERENCES
Amjad Altadmri, Michael Kölling, and Neil Christopher Charles Brown. 2016. The
CostofSyntaxandHowtoAvoidIt:TextversusFrame-BasedEditing.In Computer
Software and Applications Conference (COMPSAC).
Douglas Bates, Martin Mächler, Ben Bolker, and Steve Walker. 2015. Fitting Linear
Mixed-Effects Models Using lme4. Journal of Statistical Software (2015).
AndrewBragdon,StevenP.Reiss,RobertZeleznik,SumanKarumuri,WilliamCheung,
JoshuaKaplan,ChristopherColeman,FerdiAdeputra,andJosephJ.LaViola,Jr.2010.
Code Bubbles: Rethinking the User Interface Paradigm of Integrated Development
Environments. In International Conference on Software Engineering (ICSE).
Christopher Brown. 2008. Tool Support for Refactoring Haskell Programs. Ph.D. Disser-
tation. University of Kent.
Neil Christopher Charles Brown, Amjad Altadmri, and Michael Kölling. 2016. Frame-
BasedEditing:CombiningtheBestofBlocksandTextProgramming.In Conference
on Learning and Teaching in Computing and Engineering (LaTiCE).
Ravi Chugh,Brian Hempel, Mitchell Spradlin,and Jacob Albers. 2016. Programmatic
andDirectManipulation,TogetheratLast.In ConferenceonProgrammingLanguage
Design and Implementation (PLDI).
Martin Fowler. 1999. Refactoring: Improving the Design of Existing Code. Addison-
Wesley Longman Publishing Co., Inc.
AndrewGelmanandJenniferHill.2007. DataAnalysisUsingRegressionandMulti-
level/Hierarchical Models. (2007).
William G. Griswold. 1991. Program Restructuring as an Aid to Software Maintenance.
Ph.D. Dissertation. University of Washington.
BrianHempel andRaviChugh. 2016. Semi-Automated SVGProgramming viaDirect
Manipulation. In Symposium on User Interface Software and Technology (UIST).
BrianHempel,JustinLubin,GraceLu,andRaviChugh.2018. Deuce:ALightweight
User Interface for Structured Editing. (2018). Extended version of ICSE 2018 paper
available as CoRR abs/1707.00015.
Andrew J. Ko, Htet Htet Aung, and Brad A. Myers. 2005. Design Requirements for
MoreFlexibleStructuredEditorsfromaStudyofProgrammers’TextEditing.In
Human Factors in Computing Systems (CHI).
AndrewJ.KoandBradA.Myers.2006. Barista:AnImplementationFrameworkfor
EnablingNewTools,InteractionTechniquesandViewsinCodeEditors.In Human
Factors in Computing Systems (CHI).
YunYoungLee,NicholasChen,andRalphE.Johnson.2013.Drag-and-DropRefactoring:
Intuitive and Efficient Program Transformation. In International Conference on
Software Engineering (ICSE).
HuiqingLi.2006. RefactoringHaskellPrograms. Ph.D.Dissertation.UniversityofKent.
John Maloney, Mitchel Resnick, Natalie Rusk, Brian Silverman, and Evelyn Eastmond.
2010. The Scratch Programming Language and Environment. Transactions on
Computing Education (TOCE) (2010).
EricaMealy,DavidCarrington,PaulStrooper,andPetaWyeth.2007. ImprovingUsabil-
ityofSoftwareRefactoringTools.In AustralianSoftwareEngineeringConference
(ASWEC).
Jens Monig, Yoshiki Ohshima, and John Maloney. 2015. Blocks at Your Fingertips:
Blurring the Line Between Blocks and Text in GP. In IEEE Blocks and Beyond
Workshop (BLOCKS AND BEYOND).
Emerson Murphy-Hill and Andrew P. Black. 2008. Breaking the Barriers to Successful
Refactoring. In International Conference on Software Engineering (ICSE).
EmersonMurphy-Hill,ChrisParnin,andAndrewP.Black.2009. HowWeRefactor,
and How We Know It. In International Conference on Software Engineering (ICSE).
Cyrus Omar, Ian Voysey, Michael Hilton, Joshua Sunshine, Claire Le Goues, Jonathan
Aldrich,andMatthewA.Hammer.2017. TowardSemanticFoundationsforProgram
Editors. In Summit on Advances in Programming Languages (SNAPL).
CyrusOmar,YoungSeokYoon,ThomasD.LaToza,andBradA.Myers.2012. Active
Code Completion. In International Conference on Software Engineering (ICSE).
Veselin Raychev, Max Schäfer, Manu Sridharan, and Martin Vechev. 2013. Refac-
toringwithSynthesis.In Object-OrientedProgramming,Systems,Languages,and
Applications (OOPSLA).
Christoph Reichenbach, Devin Coughlin, and Amer Diwan. 2009. Program Metamor-
phosis. In European Conference on Object-Oriented Programming (ECOOP).
Mitchel Resnick, John Maloney, Andrés Monroy-Hernández, Natalie Rusk, Evelyn
Eastmond, Karen Brennan, Amon Millner, Eric Rosenbaum, Jay Silver, Brian Silver-
man,andYasminKafai.2009. Scratch:ProgrammingforAll. Communicationsof
the ACM (CACM) (2009).
Don Roberts, John Brant, and Ralph Johnson. 1997. A Refactoring Tool for Smalltalk.
Theory and Practice of Object Systems (1997).
Friedrich Steimann and Jens von Pilgrim. 2012. Refactorings Without Names. In
International Conference on Automated Software Engineering (ASE).
Tim Teitelbaum and Thomas Reps. 1981. The Cornell Program Synthesizer: A Syntax-
Directed Programming Environment. Commun. ACM (1981).
Simon Thompson and Huiqing Li. 2013. Refactoring Tools for Functional Languages.
Journal of Functional Programming (2013).
Nikolai Tillmann, Michal Moskal, Jonathan de Halleux, Manuel Fahndrich, and Sebas-
tian Burckhardt. 2012. TouchDevelop: App Development on Mobile Devices. In
International Symposium on the Foundations of Software Engineering (FSE).Mohsen Vakilian, Nicholas Chen, Stas Negara, Balaji Ambresh Rajkumar, Brian P. Bai-
ley,andRalphE.Johnson.2012. Use,Disuse,andMisuseofAutomatedRefactorings.
InInternational Conference on Software Engineering (ICSE).
TimA.WagnerandSusanL.Graham.1998. EfficientandFlexibleIncrementalParsing.
ACM Transactions on Programming Languages and Systems (TOPLAS) (1998).
664
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. 