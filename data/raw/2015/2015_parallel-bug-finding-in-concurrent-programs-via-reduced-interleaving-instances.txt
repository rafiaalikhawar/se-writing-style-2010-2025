Parallel Bug-Finding in Concurrent Programs
via Reduced Interleaving Instances
Truc L. Nguyen, Peter Schrammely, Bernd Fischerz, Salvatore La Torrex, Gennaro Parlato
University of Southampton, UK, trucnguyenlam@gmail.com, gennaro@ecs.soton.ac.uk
yUniversity of Sussex, UK, p.schrammel@sussex.ac.uk
zStellenbosch University, South Africa, bÔ¨Åscher@cs.sun.ac.za
xUniversit `a degli Studi di Salerno, Italy, slatorre@unisa.it
Abstract ‚ÄîConcurrency poses a major challenge for program
veriÔ¨Åcation, but it can also offer an opportunity to scale when
subproblems can be analysed in parallel. We exploit this oppor-
tunity here and use a parametrizable code-to-code translation
to generate a set of simpler program instances, each capturing
a reduced set of the original program‚Äôs interleavings. These
instances can then be checked independently in parallel. Our
approach does not depend on the tool that is chosen for the Ô¨Ånal
analysis, is compatible with weak memory models, and ampliÔ¨Åes
the effectiveness of existing tools, making them Ô¨Ånd bugs faster
and with fewer resources. We use Lazy-CSeq as an off-the-shelf
Ô¨Ånal veriÔ¨Åer to demonstrate that our approach is able, already
with a small number of cores, to Ô¨Ånd bugs in the hardest known
concurrency benchmarks in a matter of minutes, whereas other
dynamic and static tools fail to do so in hours.
Index Terms‚ÄîVeriÔ¨Åcation, concurrency, sequentialization,
swarm veriÔ¨Åcation
I. I NTRODUCTION
Processor development has reached the point where clock
speeds can no longer be increased easily, but processors con-
tain multiple cores that work in parallel. Therefore, to achieve
higher performance software must necessarily be concurrent.
Unfortunately, developing correct, scalable, and efÔ¨Åcient
concurrent programs is a complex and difÔ¨Åcult task, due to the
large number of possible concurrent executions that must be
considered. Modern multi-core processors and weak memory
models (WMMs) make this task even harder, as they introduce
additional executions that confound the developers‚Äô reasoning.
Due to these complex interactions, concurrent programs often
contain bugs that are difÔ¨Åcult to Ô¨Ånd, reproduce, and Ô¨Åx.
Existing automatic bug-Ô¨Ånding techniques and tools are
not effective when facing concurrent programs. They struggle
particularly with programs that contain rare concurrency bugs,
i.e., programs where only a few, speciÔ¨Åc interleavings violate
the speciÔ¨Åcation. For techniques that analyze executions ex-
plicitly, Ô¨Ånding rare bugs is like looking for a needle in a
haystack. For techniques that analyze all executions collec-
tively using symbolic representations, Ô¨Ånding rare bugs is also
challenging due to the large amount of memory required for
the analysis. As a result, we currently do not have techniques
and tools that can reliably Ô¨Ånd such rare bugs.
Partially supported by EPSRC grants no. EP/M008991/1 and no.
EP/P022413/1, and MIUR-FARB 2014-2017 grants.Although concurrency is clearly a problem for reasoning
about programs, it also offers a chance to scale up veriÔ¨Åcation,
as suggested by Holzmann et al. [1]: ‚Äú. . . to scale applications
of logic model checking to larger problem sizes then, we
must be able to leverage the availability of potentially large
numbers of processors that run at [...] relatively low speed. ‚Äù
Different approaches have been tried out to achieve this
leveraging, with varying degrees of success. In (truly) dis-
tributed algorithms, multiple processors are running the same
algorithm jointly on the same problem and periodically ex-
change information. However, veriÔ¨Åcation using distributed
model checking techniques (e.g. [2], [3]) has had limited
success because they need to share too much information,
leading to high communication overheads and contention.
Instrategy competition, multiple processors are running dif-
ferent variants of the same underlying algorithm independently
(i.e., without exchanging information) on the same problem;
the Ô¨Årst variant that produces a deÔ¨Ånitive answer (i.e., counter-
example or proof) ‚Äúwins‚Äù and aborts the others. This exploits
the fact that complex search procedures such as model check-
ers [4], [1], SAT solvers [5], or Ô¨Årst-order theorem provers [6],
[7], [8] have many control parameters and strategies that can be
used to explore different parts of the search space. Holzmann
et al. have applied this idea in swarm veriÔ¨Åcation [4], [1]
to scale up model checking based on explicit state space
exploration. More speciÔ¨Åcally, their approach is to spawn a
large number of instances (the ‚Äúswarm‚Äù) of the SPIN model
checker, each with different parameters and search strategies;
each instance runs an incomplete search, but in aggregate the
swarm substantially outperforms an exhaustive search.
In this paper, we propose a different approach called task
competition: we run the same algorithm on multiple proces-
sors, again in competition without information exchange, but
now on different andeasier veriÔ¨Åcation tasks derived from the
original problem. SpeciÔ¨Åcally, each task captures a subset of
the program‚Äôs interleavings under analysis, in a way that each
of such interleavings is captured by at least one of these tasks.
Thus, for programs with rare concurrency bugs, most tasks do
not contain a bug. However, in tasks that do, the bugs are
generally more frequent (i.e., manifest in a higher fraction of
the interleavings) than in the original program. Consequently,
bugs can be found faster and with fewer resources, because the
individual tasks are simpler and can be analyzed in parallel,
978-1-5386-2684-9/17/$31.00 c2017 IEEEASE 2017, Urbana-Champaign, IL, USA
Technical Research753
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:02 UTC from IEEE Xplore.  Restrictions apply. each with a shorter time-out and a smaller memory.
We develop and evaluate this approach under a bounded
context-switch analysis where only interleavings with up to k
context-switches (for a given k) are explored. This choice is
justiÔ¨Åed by an empirical study which shows that most of the
concurrency bugs manifest themselves within a small number
of context-switches [9]. We use a code-to-code translation
to derive the tasks as variants of the original program by
splitting the code of each thread into fragments (tiles) and
allowing context-switches only in some of them. By selecting
dk
2etiles in all possible ways, we thus ensure the coverage of
all interleavings up to kcontext-switches.
Our approach offers a number of advantages. First, since
it is using code-to-code translations, it is ‚Äúagnostic‚Äù of the
underlying veriÔ¨Åcation techniques and tools: existing bug-
Ô¨Ånding tools can be reused as is, and while we have achieved
very good results using bounded model checking (BMC)
techniques (in particular Lazy-CSeq [10], [11]), it can also
be used with other symbolic analysis techniques, explicit state
space exploration techniques, or even testing.
Second, our approach ampliÔ¨Åes the effectiveness of existing
bug-Ô¨Ånding tools. We empirically demonstrate that it is partic-
ularly effective for symbolic methods: it reduces the memory
consumption and run time of each individual veriÔ¨Åcation task
containing a bug, and also leads to a considerable reduction
in time for the global veriÔ¨Åcation. We show a substantial
reduction in the wall-clock times required to Ô¨Ånd a bug in
some very difÔ¨Åcult problems: from 8-12 hours using a single
instance of Lazy-CSeq, the only tool capable of Ô¨Ånding the
underlying bugs, down to 15-30 minutes using Lazy-CSeq on
a modest number (5-50) of processors. Looking at this from
an opposite perspective, our approach enables existing tools
to Ô¨Ånd rare bugs that were previously out of their reach.
Third, our approach also is oblivious of the assumed mem-
ory model and therefore also works for WMMs, as long as the
underlying analysis tool supports their semantics. Moreover,
our experiments demonstrate that the approach is also effective
for reducing the additional veriÔ¨Åcation complexity introduced
by relaxed consistency semantics.
Finally, our approach is tuneable. The veriÔ¨Åcation com-
plexity of each of the instances generally depends on the
underlying analysis tool and number of interleavings captured
by each instance. From our experience, instances with roughly
the same number of interleavings have similar veriÔ¨Åcation
times. Thus, we empirically learn the number of interleavings
per instance that the underlying tool can effortlessly handle
and then generate all the instances to capture all interleavings
according to a Ô¨Åxed schema. However, the number of instances
to generate can be extremely high. We empirically show that
using only a few instances selected at random still enables
us to Ô¨Ånd rare bugs. In our experiments, we demonstrate that
we only have to consider a few instances (out of millions or
billions) to Ô¨Ånd bugs with high probability.
Contributions. In summary, in this paper we make three
main contributions. First, we propose a new swarm veriÔ¨Åcation
approach for the analysis of concurrent programs that isbased on a code-to-code translation and leverages the power
of sequential analysis engines. Second, we implement the
approach as an extension to Lazy-CSeq. Third, we report
the results of an evaluation of our approach on the two
hardest known concurrency benchmarks, safestack [12]
andeliminationstack [13] for three different memory
models (SC, TSO, PSO).
Organization of the paper. In the next section, we give a high-
level overview of our approach. Sections III and IV describe
our code-to-code translation. Section V gives details on our
implementation and Section VI presents the results of our
experimental evaluation. Section VII compares with related
work, and Section VIII concludes.
II. A PPROACH
We consider multi-threaded programs where threads com-
municate through shared memory (for example, a C program
that uses the POSIX threads library for concurrency). As
in bounded model checking, we Ô¨Årst Ô¨Çatten the program by
inlining functions and unrolling loops up to a given bound.
The resulting bounded program, say P, consists of a Ô¨Ånite
number of threads; the control in each thread can only move
down in the code. The goal of the analysis is to Ô¨Ånd an
assertion violation of Pthat may occur through an execution
that involves at most kcontext-switches (for a given k). Let
kbe a small natural number denoting the maximum number
of context-switches to consider along an execution, and Tbe
the set ofP‚Äôs threads. We denote with Ik(P)the set of all
executions that Pcan exhibit with at most kcontext-switches.
A. Splitting Computations with Tilings
Our goal is to deÔ¨Åne a code-to-code translation for P,
parameterized over k, that generates a set of simpler program
variants, each capturing a subset of P‚Äôs executions, such that
each ofP‚Äôs executions involving at most kcontext-switches
is captured by at least one of them. The resulting variants can
then be checked independently in parallel.
We construct these variants by building on the notion of
tiling. A tiling of a thread t2Tis a partition of t‚Äôs statements.
Each element of a tiling is called tile. For example, consider
Fig. 1. The program has two threads with respectively seven
(A, . . . , G) and Ô¨Åve (H, . . . , L ) statements, and the tiling of
each thread is marked with the braces. A tiling of a program
Pis a set of thread tilings, one for each thread of P. Let
P=ftgt2Tbe a tiling of P. Az-selection ofPis a set
ftgt2Twherettcontains exactly ztiles.
We build the variants as follows. For a given tiling Pof
Pand any of its z-selections#=ftgt2T, we construct a
program variant P#ofPobtained by instrumenting Pin a
way that each thread tcan only be preempted at statements
belonging to the tiles of tand at any other blocking statement
oft(in order to allow an execution to continue when a
statement is blocked and there are other threads that are ready
to execute). Consider again Fig. 1. If we take the 1-selection
#corresponding to selecting tiles #1 and #4, the executions
ofP#are of the form uvw where: (1)uis any interleaving of
754
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:02 UTC from IEEE Xplore.  Restrictions apply. thread 0f
#1A;
B;
#28
<
:C;
D;
E;
#3F;
G;
gthread 1f
H;
I;
#4
J;	
#5
K;
L;
#6
g
Fig. 1. Tiling example
A-BandH-I; (2) ifuends with B, thenv=C-. . . -G andw=J-
K-L; (3) ifuends with I, thenv=J-K-L andw=C-. . . -G.
For example, A-B-H-. . . -L-C-. . . -G andA-H-I-B-C-. . . -G-J-K-
Ldenote possible executions of P#.
We observe that the set of executions over all the variants
P#, with#being adk
2e-selection of P, that contain at most
kcontext-switches is exactly the set Ik(P). In fact, every
execution of a variant P#ofPis also an execution of P
sinceP#, by construction, is the same as P, except that we
forbid context-switches to occur at some points. Vice-versa,
any execution 2 Ik(P)can context-switch out of each
thread at mostdk
2etimes, thus it sufÔ¨Åces to select dk
2etiles
per thread to capture . Therefore, is an execution of some
variantP#, for adk
2e-selection#.
B. Overall Approach
The veriÔ¨Åcation approach works in two phases. We Ô¨Årst
generateP‚Äôs variants according to any selection of an input
tiling. We then search for bugs in each of the resulting program
variants (typically in parallel) using an off-the-shelf analyzer
such as a testing tool or a model checker. The analysis phase
can be stopped as soon as a bug is found in one of the
program variants. The overall scheme is shown in Fig. 2; in
the following, we sketch the two phases in turn.
1) Instance Generation: The Ô¨Årst phase is composed of
a chain of code-to-code transformations of the input multi-
threaded program.
The Ô¨Årst module transforms this program into a bounded
multi-threaded program Pthat is syntactically guaranteed to
terminate after a bounded number of transitions, by applying
standard BMC program transformations [14] such as inlining
the functions and unwinding the loops (up to a given bound).
Pthus has a different function associated with each thread;
we refer to these as thread functions.
The second module injects numerical labels at each visible
statement of the thread functions (i.e., at the beginning and end
of the function, before each access to the shared memory, and
before each call to a thread synchronization primitive) of P.
In each thread function, the labels start at zero and increase
consecutively in statement order; we assume that any other
label of the program is non-numerical. This labeling simpliÔ¨Åes
the code injected by the third module for the tile selection.The third module instruments the code with guarded com-
mands that at each numerical label enable/disable context-
switchs and statement reordering. This control-Ô¨Çow code is
used by the next module to imprint the tile selection in the
code. A detailed description of the translation by this module
is given in Section IV.
The fourth and last module generates the variants of P
according to any z-selection of the input tiling P(where
zis the value of the input parameter #tiles). This is done
by triggering the guards injected by the previous module.
Note that the number of different program variants generated
this way is Ô¨Ånite, but can be large. Therefore, we consider
a randomized version of this module along with a new input
parameter, the number nof instances to be generated. The n
instances are generated by randomly choosing the z-selections.
This, also introduces a loop in our veriÔ¨Åcation approach: we
repeat the random generation of nnew variants until either a
bug is found or all the variants are generated.
2) VeriÔ¨Åcation Cluster: Since the generated instances can
be analyzed independently, we can achieve in our scheme
a high diversiÔ¨Åcation and parallelism of the analysis: each
instance can be analyzed on a separate core and possibly using
a different tool for concurrent program analysis.
III. S HARED -MEMORY MULTI -THREADED PROGRAMS
Our implementation can handle the full C language (see
Section V), but we describe our approach for multi-threaded
programs in a simple imperative language. This features
dynamic thread creation, thread join, and mutex locking and
unlocking operations for thread synchronization. Thread com-
munication is implemented via shared memory and modelled
by global variables. All threads share the same address space:
they can write to or read from global variables of the pro-
gram to communicate with each other. We assume that each
statement is atomic as it is always possible to decompose a
statement into a sequence of statements each involving at most
one access to the shared memory [15].
A. Syntax
The syntax of multi-threaded programs is deÔ¨Åned by the
grammar shown in Fig. 3. Terminal symbols are set in
typewriter font. Notation hntirepresents a possibly empty
list of non-terminals nthat are separated by terminals t;
xdenotes a local variable, ya shared variable, ta thread
variable and pa procedure name. All variables involved in a
sequential statement are local. We assume expressions eto be
local variables, integer constants, that can be combined using
mathematical operators. Boolean expressions bcan be true
orfalse, or Boolean variables, which can be combined using
standard Boolean operations.
Amulti-threaded program consists of a list of global
variable declarations (i.e., shared variables), followed by a
list of procedures. Each procedure has a list of zero or more
typed parameters, and its body has a declaration of local
variables followed by a statement. A statement is either a
simple statement or a compound statement, i.e., a sequence
755
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:02 UTC from IEEE Xplore.  Restrictions apply. SplitunwindInline/
BugNo bugInstance generator VeriÔ¨Åcation cluster
ProgramInst 1
Inst nAnalyzer 1
Analyzer nNumerical
labelsInstrument
tiling #tilesFig. 2. VeriÔ¨Åcation approach.
P ::=(dec;)(typep(hdec ,i) {(dec ;)stm})
dec ::=typez
type ::=booljintjvoid
stm ::=sstmj{hstm ;i}
sstm ::=seqjconcjl:sstm
seq ::=assume(b)jassert(b)jx:=ejp(he,i)
jreturnejif(b) then stm else stm
jwhile(b) dostmjgotol
conc ::=x:=yjy:=xjt:=createp(he,i)
jjointjinitmjlockm
junlockmjdestroym
Fig. 3. Syntax of multi-threaded programs.
of statements enclosed in braces. A simple statement is either
a labeled simple statement, or a sequential statement, or a
concurrent statement.
Asequential statement can be an assume- or assert-
statement, an assignment, a call to a procedure that takes
multiple parameters (with an implicit call-by-reference pa-
rameter passing semantics), a return-statement, a conditional
statement, a while-loop, or a jump to a label. Local vari-
ables are considered uninitialized right after their declaration,
which means that they can nondeterministically take any value
from their type domains until they are explicitly set by an
assignment statement. We also use the symbol *to denote the
expression that nondeterministically evaluates to any possible
value; with x:=*we then mean that xis assigned with any
possible value of its type domain.
Aconcurrent statement can be a concurrent assignment,
a call to a thread routine, such as a thread creation, a join,
or a mutex operation (i.e., init, lock, unlock, and destroy). A
concurrent assignment assigns a shared (resp. local) variable to
a local (resp. shared) one. Unlike local variables, global vari-
ables are always assumed to be initialized to a default value.
For the sake of simplicity, we assume that the default valuealways 0regardless of the variable type. A thread creation
statementt:=createp(e1;:::;e n)spawns a new thread
from procedure pwith expressions e1;:::;e nas arguments.
A thread join statement, joint, pauses the current thread until
the thread identiÔ¨Åed by tterminates its execution, i.e., after
the thread has executed its last statement. Lock and unlock
statements respectively acquire and release a mutex. If the
mutex is already acquired, the lock operation is blocking for
the thread, i.e., the thread is suspended until the mutex is
released and can then be acquired.
We assume that a valid program PsatisÔ¨Åes the usual well-
formedness and type-correctness conditions. We also assume
thatPcontains a procedure main, which is the starting
procedure of the only thread that exists in the beginning. We
call this the main thread. We further assume that there are no
calls to main inPand that no other thread can be created that
uses main as starting procedure.
B. Semantics
As common, a program conÔ¨Åguration is a tuple of conÔ¨Åg-
urations of each thread that has been created and has not yet
terminated, along with a valuation of the global variables. A
thread conÔ¨Åguration consists of a stack which stores the history
of positions at which calls were made, along with valuations
for local variables, and the top of the stack contains the local
and global valuations, and a pointer to the current statement
being executed.
The behavioral semantics of a program Pis obtained by
interleaving the behaviors of its threads. At the beginning of
any computation only the main thread is ready andrunning.
At any point of a computation, only one of the ready threads
isrunning. A step is either the execution of a step of the
running thread or a context-switch that nondeterministically
replaces the running thread with one of the ready ones that
thus becomes the running thread at the next step. A thread
will no longer be available when its execution is terminated,
i.e., there are no more steps that it can take.
IV. C ODE-TO-CODE TRANSLATION
In this section, we give a formal description of the code
instrumentation done by module Instrument in Fig. 2.
For the sake of better presentation, in the following, in order
to enable/disable context-switches in the code, we consider a
semantics in the style of preemptive asynchronous programs
756
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:02 UTC from IEEE Xplore.  Restrictions apply. s(dec;)(typepi(hdec ,i)
{(dec ;)stm})i=0;:::;n 1{
def=bool yields[n][h] =ffa0
0;a0
1;:::;a0
h 1g;:::;fan 1
0;an 1
1;:::;an 1
h 1gg;
(dec;)(typepi(hdec ,i){(dec ;)JstmKi})i=0;:::;n 1
JstmKidef=JsstmKij{hJstm Ki;i}
JsstmKidef=seqjconcjJl:sstmKi
Jl:sstmKidef=8
>>><
>>>:l: if (yields[i ][l]&&)yield;
JsstmKi; iflis numerical
l:JsstmKi otherwise
Fig. 4. Formal description of the code-to-code translation by module Instrument.
with nondeterministic scheduler. In particular, we augment the
concurrent statements of the syntax from Fig. 3 with a yield-
statement, i.e., we add the rule conc ::=yield, and restrict
the context-switches to occur only if explicitly invoked via a
yield-statement (which thus causes the control to return to
the nondeterministic scheduler). In the following, we will refer
to this class of programs as extended preemptive asyncronous
programs (EPA programs, for short).
It is straightforward to show that given a multi-threaded
programPunder the syntax and semantics of Section III
we can easily obtain an equivalent program P0under syntax
and semantics sketched above by simply inserting a yield-
statement guarded by a nondeterministic guess in front of
each statement of P. Moreover, as we are interested only in
reachability of program locations or assertion failure checking,
such as in standard bug-Ô¨Ånding analysis, it is sufÔ¨Åcient to ac-
count only for context-switches that occur at visible statements
(i.e., the concurrent statements and each thread‚Äôs Ô¨Årst and last
statements).
We recall that we assume that all the labels of the original
multi-threaded program must be non-numerical and that after
the code-to-code translation by modules Inline/unwind and
Numerical labels, we get that: (1) the code of each thread
is all contained within the same procedure, i.e., there are no
procedure calls, and there are no loops; and (2) the visible
statements are all labeled with a numerical label such that
in each thread code labels start from 0and increase by 1
according to the statement order.
In module Instrument, we thus rewrite the code by inserting
a guarded yield-statement after each numerical label. Guards
are triggered by input Boolean parameters: we use ai
lto
activate the yield-statement at the numerical label lof thread
i. These parameters are assigned to a Boolean array yields.
After the instrumentation, the portion of code l:sstm of
threadi, where lis a numerical label, is thus:
if(yields[i ][l] && *)yield; sstm;
The rest of the code stays unchanged.
We formally give our code-to-code translation in Fig. 4 asrewrite rules over the syntax of programs. In the Ô¨Ågure, we
have denoted with nthe number of threads and with hthe
maximum number of numerical labels over all threads.
We observe that whenever yields[i ][l]holds, by the
choice operator *, the yield-statement is nondeterministically
executed or not. This can be used to select in the code the
points where context-switches can happen. Thus, the following
module Split (see Fig. 2) will assign the array yields ac-
cordingly to a valid selection for the input tiling and blocking
statements.
V. I MPLEMENTATION
We have implemented the veriÔ¨Åcation approach illustrated
in Fig. 2 to analyze concurrent C programs that use the
concurrency library POSIX Threads. We optimize the tilings
by taking into account only statements at which context-
switches can occur which correspond to numerical labels. For
the instance generation we use uniform window tilings, i.e.,
tilings where all tiles have the same number of numerical
labels except for the last one that can have fewer, and all
tiles correspond to contiguous sections of a thread‚Äôs code. For
example, the tiling from Fig. 1 is not uniform though tiles
cover contiguous portions of code.
TheInstance generator is written as an independent compo-
nent that takes as input: (1) a multi-threaded program Pwith
assertions, (2) the unwinding bound, (3) the size tof each
tile (i.e., the number of numerical labels), (4) the number s
of tiles to select from each thread, and (5) the number nof
randomly chosen instances to generate. The pool of (bounded)
EPA programs generated by the Instance generator is then
veriÔ¨Åed on a cluster of computers with a modiÔ¨Åed version of
the symbolic veriÔ¨Åcation tool Lazy-CSeq [10].
Below we provide more details on our implementation of
theInstance generator, the veriÔ¨Åcation tool, and the cluster.
A. Instance Generator
Our tool V ERISMART1(‚ÄúVeriÔ¨Åcation-Smart‚Äù), builds upon
the CSeq framework [10], [16], and is composed of a chain
1VERISMART is publicly available at http://users.ecs.soton.ac.uk/gp4/cseq/.
757
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:02 UTC from IEEE Xplore.  Restrictions apply. of software modules that matches the chain of modules of the
Instance generator from Fig. 2. We recall that CSeq is a frame-
work that comprises several software modules implementing
standard source-to-source transformations of C programs. We
re-use CSeq modules to implement the modules Inline/unwind
andNumerical labels. For Instrument, we have realized a new
software module that implements the code-to-code translation
detailed in Section IV. It is written in Python and uses the
AST built by pycparser2on the fetched program to implement
the rewriting rules of Fig. 4. The last module Split is also
written in Python. It generates each instance by randomly
selectingstiles per thread by setting to true the corresponding
entries of the array yields (entries corresponding to blocking
statements are always set to false). This module also takes
an additional parameter that allows to bound the number
of generated instances. In our setting we manually allocate
the resulting instances to several veriÔ¨Åcation units that are
analyzed independently.
The code of V ERISMART is publicly available at http:
//users.ecs.soton.ac.uk/gp4/cseq/ and can be used, in combina-
tion with different bug-Ô¨Ånding analysis tools, for experiment-
ing with the veriÔ¨Åcation approach proposed in this paper.
B. Backend VeriÔ¨Åcation Tool
Lazy-CSeq [10] is a symbolic bug-Ô¨Ånding tool for multi-
threaded programs based on sequentialization and bounded
model checking. The multi-threaded input program is trans-
lated into a corresponding sequential program up to a given
number of rounds of execution, where in each round each
thread is executed exactly once according to a Ô¨Åxed ordering.
The resulting sequential program is then veriÔ¨Åed using existing
veriÔ¨Åcation tools for sequential programs.
We modify Lazy-CSeq to account for the syntax and the
semantics of EPA programs. Essentially, we extend the parsing
for handling also the yield-statement and then adjust the
code-to-code translation such that in the resulting sequential
C program the context-switches are now simulated only at
theyield-statements according to the semantics of the EPA
programs. In the following, we refer to this modiÔ¨Åed version
of Lazy-CSeq as EPA-Lazy-CSeq.
In our experiments we use the C bounded model checker
CBMC3v5.3 [17], [18] as sequential backend for Lazy-
CSeq and EPA-Lazy-CSeq. CBMC encodes symbolically the
multiple execution paths of the input program, which is then
checked by a SAT/SMT solver. If the formula is satisÔ¨Åable
there is a deÔ¨Ånite execution path that leads to an assertion
violation. In this case the SAT/SMT solver returns the values
of the variables along this execution path. From these values,
which in particular include the input values and the encoded
context switch points, a test can be constructed and executed
in order to debug the reason for the assertion violation.
If the formula is unsatisÔ¨Åable then there is no execution
that violates any of the assertions (up to the considered
2pycparser: https://github.com/eliben/pycparser
3CBMC: http://www.cprover.org/cbmc/depth). The formula is generated by symbolically executing
the program while encoding the control Ô¨Çow structure into
additional Boolean variables. The formula is linear in the
size of the program, but implicitly encodes a potentially
exponential number of execution paths. Hence, unlike path-
wise enumeration approaches [19], [20] this approach avoids
explicitly enumerating a potentially exponential number of
execution paths and maximizes the exploitation of today‚Äôs
optimized SAT solvers.
Lazy-CSeq was initially developed for C program running
under the SC semantics. It has been recently extended to
handle WMM semantics such as TSO and PSO [21]. Our
modiÔ¨Åcation are also compatible with these extensions. In
our experiments we only use EPA-Lazy-CSeq for the analysis
carried out on the cluster. Our choice has been motivated
by the effectiveness of Lazy-CSeq for complex benchmarks
containing rare bugs.
VI. E XPERIMENTS
Here we report on a large number of experiments that
we have conducted to demonstrate the effectiveness of the
proposed approach. It turns out that V ERISMART improves
the performance of Lazy-CSeq by achieving more than 1000x
speed-up already with few cores ( 20) on some benchmarks
that are hard to analyze.
A. Benchmarks
Our Ô¨Årst effort was to identify suitable benchmarks that
present a non-trivial challenge for concurrency bug-Ô¨Ånding
tools. The widely used concurrency benchmarks from the
Software VeriÔ¨Åcation Competition (SV-COMP) are too easy:
several tools can quickly Ô¨Ånd the bugs in all buggy bench-
marks; Lazy-CSeq requires 2.5 seconds on average.4
We have instead considered several concurrency bench-
marks from the literature, including the SCT Benchmarks5
[22]. From these, we discarded all parametric benchmarks
whose complexity comes simply from artiÔ¨Åcially increas-
ing the number of threads (e.g., CS.reorder_n bad and
CS.twostage_n bad [22], where nis the number of
threads), or the size of the data structures (e.g., the work steal-
ing queue [22]), since their bugs can already be exposed with
smaller instances. We further discarded all benchmarks that
Lazy-CSeq can solve in less than 600 seconds; this includes
several benchmarks that are traditionally considered to be hard,
e.g., DCAS [23]. Similarly to the SV-COMP benchmarks, our
experiments showed that there is no signiÔ¨Åcant performance
difference between Lazy-CSeq and V ERISMART ‚Äîin some
sense these benchmarks are ‚Äútoo simple‚Äù to beneÔ¨Åt substan-
tially from the V ERISMART approach. We therefore do not
4For the hardest benchmark (Ô¨Åbonacci), Lazy-CSeq required less than 300
seconds, but this is an atypical, artiÔ¨Åcial example speciÔ¨Åcally crafted to require
a high number of context switches (21) in a small program (11 visible
statements in two threads each), which is smaller than our usual tile size,
so that there is no difference to V ERISMART . For four other benchmarks,
Lazy-CSeq requries between 20 and 90 seconds; here, V ERISMART performs
similarly. For the majority of the simple benchmarks, V ERISMART pays a
small wall-clock time penalty due to the transformation overhead.
5SCT Benchmarks: https://sites.google.com/site/sctbenchmarks/
758
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:02 UTC from IEEE Xplore.  Restrictions apply. report further details for these benchmarks. This leaves us with
two benchmarks that both come from the domain of concurrent
data structures.6
eliminationstack is a C implementation of Hendler
et al.‚Äôs Elimination Stack [13] that follows the original pseu-
docode presentation. It augments Treiber‚Äôs stack with a ‚Äúcolli-
sion array‚Äù, used when an optimistic push or pop detects a con-
Ô¨Çicting operation; the collision array pairs together concurrent
push and pop operations to ‚Äúeliminate‚Äù them without affecting
the underlying data structure. This implementation is incorrect
if memory is freed in pop operations. In particular, if memory
is freed only during the ‚Äúelimination‚Äù phase, then exhibiting a
violation (an instance of the infamous ABA problem) requires
a seven thread client with three push operations concurrent
with four pops. To witness the violation, the implementation
is annotated with several assertions that manipulate counters as
described in [24]. Lazy-CSeq is the only tool we are aware of
that can automatically Ô¨Ånd bugs in this benchmark and requires
almost 13 hours and 4 GB of memory to Ô¨Ånd a bug.
safestack is a real world benchmark implementing a
lock-free stack designed for weak-memory models. It was
posted to the CHESS forum7by Dmitry Vyukov. This bench-
mark is unique as it contains a very rare bug that requires at
least three threads and Ô¨Åve context-switches to get exposed
when running under the SC semantics, whereas it requires
only four context-switches when running under TSO or PSO.
In the veriÔ¨Åcation literature, it was shown that real-world bugs
require at most three context-switches to manifest themselves
[9].safestack, for this reason, presents a nontrivial chal-
lenge for concurrency testing and symbolic tools. Lazy-CSeq
is the only tool we are aware of that can automatically Ô¨Ånd
these bugs: it takes almost 7 hours to Ô¨Ånd these bugs and
consumes more than 6 GB of memory.8
B. Experimental Set-Up
In our experimental evaluation we compare V ERISMART
against Lazy-CSeq v1.0.9The results are summarized in Fig. 5.
For both tools, we use the minimum number of unwindings
and rounds of computation that are required to expose the
bug in the original program by Lazy-CSeq; the exact values
for these parameters are reported in Fig. 5 for each considered
benchmark. We also report the number of the threads involved
in the computation and the number of visible points in each
of those threads.
For Lazy-CSeq, the results for the comprehensive veriÔ¨Å-
cation are given in the leftmost columns of Fig. 5. Under
6It is hardly surprising that lock-free programming is an important source
of truly concurrently complex benchmarks since the focus there is to minimize
the amount of synchronization for performance optimization thus generating
a large amount of nondeterminism due to interleaving.
7https://social.msdn.microsoft.com/Forums/
en-US/91c1971c-519f-4ad2-816d-149e6b2fd916/
bug-with-a-context-switch-bound-5?forum=chess
8The tool Relacy [22] can Ô¨Ånd a bug in a modiÔ¨Åed version of safestack
where an explicit pthread_yield call has been added to help the search.
In our experiments, on the plain safestack benchmark used here, Relacy
was not able to detect a bug within one million iterations.
9CSeq framework: http://users.ecs.soton.ac.uk/gp4/cseq‚ÄúAll schedules‚Äù, we report the veriÔ¨Åcation time and mem-
ory consumption when all interleavings are analyzed in one
attempt. We also estimate the ‚Äúsequential complexity‚Äù of
the benchmarks as the average performance to analyze them
given one Ô¨Åxed schedule. This gives us an estimated lower
bound for the analysis of each of the tasks generated by
VERISMART . For this, we have considered 3000 randomly
selected interleavings. We report the computed average time
and memory consumption in Fig. 5 under ‚ÄúOne schedule‚Äù.
For V ERISMART , see Fig. 5 again, we select as many
tiles per thread as the number of rounds required to expose
the bug in each of the considered benchmark; this ensures
that the bug can (in principle) be found. We use a uniform
window tiling with three different tile sizes to evaluate the
effect of tiling. For each benchmark and tile size, we then
analyze 8,000 program variants with the timeout given in
Fig. 5; these variants are generated by randomly selecting the
tiles. We report the minimum, the maximum, the average and
the standard deviation over the veriÔ¨Åcation time and memory
consumption of all the buggy variants. We also report the
percentage of the buggy variants.
We also estimate, for each considered benchmark and set-
ting (using the data collected in the V ERISMART experiments
described above), how the expected bug-Ô¨Ånding time varies as
the number nof cores increases. We thus randomly draw sets
ofnvariants containing at least one with a bug, and compute
the the minimum time to Ô¨Ånd a bug over this set. We then plot
the expected bug-Ô¨Ånding time for values of nup to 2000 (see
Fig. 6). Here, a round (resp. square) point marks the expected
number of cores required Ô¨Ånd a bug with probability 0.95
(resp. 0.99) and the corresponding expected time.
We carried out our experiments on a cluster with 750
compute nodes equipped with dual 2.6 GHz Intel Sandybridge
processors. Each compute node has 16 CPUs with 64 GB
of physical shared memory running 64-bit linux 3.0.6. On
each CPU of a node we run EPA-Lazy-CSeq over a single
veriÔ¨Åcation task produced by the instance generator, with the
timeout given in Fig. 5.
C. Experimental Results
Fig. 5 and 6 give detailed results of our experiments; the
safestack-TSO results are summarized in the text.
As expected, the results for the comprehensive veriÔ¨Åcation
using Lazy-CSeq show that both benchmarks are very hard
under SC. The relation between the numbers for one schedule
and all schedules, respectively, shows that the complexity
comes from the interleavings. Less expectedly, with Lazy-
CSeq requiring 11005 seconds and 4.3 GB of memory to
Ô¨Ånd a bug in safestack-TSO, they also show that WMMs
can actually make it easier to Ô¨Ånd bugs, as both runtime and
memory requirements go down. This is a consequence of both
the lower number of rounds required to expose the bug, and
the higher number of buggy executions that the WMMs allow.
The main part of Fig. 5 shows the V ERISMART results for
the different tile sizes. We focus on the SC benchmarks Ô¨Årst,
and defer the discussion of WMM benchmarks to below.
759
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:02 UTC from IEEE Xplore.  Restrictions apply. eliminationstack-SC (unwind=1, rounds=2, thread=8, visible point=52)
COMPREHENSIVE VERIFICATION VERISMART: 2 tiles per thread
Time Memory#1: tile size 12, timeout 1.5hrs #2: tile size 14, timeout 2hrs #3: tile size 18, timeout 3hrs
VeriÔ¨Åcation Time Memory VeriÔ¨Åcation Time Memory VeriÔ¨Åcation Time Memory
One schedule 80.8 661.1Min 34.9 945.2 Min 39.7 979.84 Min 37.1 999.8
Max 4753.6 1199.1 Max 7195.2 1281.3 Max 10762.0 1785.5
All schedules 46764 4203.9Average 1116.3 1017.8 Average 2169.5 1096.3 Average 3162.4 1156.9
Deviation 1051.4 32.4 Deviation 1935.3 68.9 Deviation 2699.6 133.0
instances with bug: 38.33% instances with bug: 61.38% instances with bug: 69.01%
safestack-SC (unwind=3, rounds=4, thread=4, visible point=152)
COMPREHENSIVE VERIFICATION VERISMART: 4 tiles per thread
Time Memory#1: tile size 11, timeout 1hr #2: tile size 14, timeout 1hr #3: tile size 20, timeout 4hrs
VeriÔ¨Åcation Time Memory VeriÔ¨Åcation Time Memory VeriÔ¨Åcation Time Memory
One schedule 55.4 700.1Min 195.6 774.5 Min 574.8 846.6 Min 313.0 850.3
Max 2662.6 1265.7 Max 3521.8 1450.4 Max 10315.8 3830.8
All schedules 24139 6632.4Average 1172.2 928.8 Average 1851.1 1147.3 Average 2167.5 1230.1
Deviation 552.4 122.5 Deviation 827.3 165.5 Deviation 1558.1 317.1
instances with bug: 1.26% instances with bug: 2.14% instances with bug: 10.20%
safestack-PSO (unwind=3, rounds=3, thread=4, visible point=152)
COMPREHENSIVE VERIFICATION VERISMART: 3 tiles per thread
Time Memory#1: tile size 12, timeout 1.5hrs #2: tile size 16, timeout 2.25hrs #3: tile size 20, timeout 3hrs
VeriÔ¨Åcation Time Memory VeriÔ¨Åcation Time Memory VeriÔ¨Åcation Time Memory
One schedule 272.5 2651.8Min 898.1 2795.9 Min 593.5 2862.6 Min 1083.8 2910.1
Max 5348.0 3280.7 Max 8083.1 3942.2 Max 10771.7 3784.1
All schedules 4777 3708.4Average 2929.8 2872.9 Average 4607.1 3015.4 Average 5176.9 3073.8
Deviation 941.4 52.4 Deviation 1751.7 154.2 Deviation 2265.9 145.9
instances with bug: 7.63% instances with bug: 16.73% instances with bug: 26.85%
Fig. 5. V ERISMART experiments: each experiment is carried out using 8,000 instances chosen randomly. The veriÔ¨Åcation is done using Lazy-CSeq 1.0
for all schedules, and EPA-Lazy-CSeq for the program variants. For each experiment, we report the minimum, the maximum, the average and the standard
deviation over the veriÔ¨Åcation time and memory consumption of all the buggy variants. Time is given in seconds and memory in MB.
For SC, we see the best-case resource consumption required
to expose a bug in any of the generated instances drops
dramatically: the best instances expose the bugs 100x to 1000x
faster, with only 10% to 25% of the memory. The relative
numbers of buggy instances are very favorable and can be
improved even further, by increasing the tile sizes. These
increased odds come at modest costs: average times to expose
the bugs increase 2x‚Äì3x, while average memory consumption
remains roughly stable. Taken together, this means that we
only need to analyze a small number (less than 100, and in
many cases less than 10) of relatively simple (average times
to Ô¨Ånd the bugs between 20 minutes and one hour) problems
to Ô¨Ånd a bug with probability approximating 1 (see Fig. 6).
Forsafestack-PSO the results appear at Ô¨Årst less im-
pressive. While the best-case bug-Ô¨Ånding times still represent
a roughly 5x speed-up, the average times are closer to (and
in some times even exceed) the comprehensive analysis times.
However, the high fraction of buggy instances (roughly 5%‚Äì
25%) allows us to play the numbers game to achieve a good
overall performance. If we run a moderate number (say 50)
of tasks in parallel, we will with high probability (since the
distribution of the bug-Ô¨Ånding times exhibits a log-normal
shape) also come across one of the ‚Äúfaster‚Äù tasks, which will
abort the remaining ‚Äúslower‚Äù tasks, giving us wall-clock speed-
ups roughly similar to the best cases.
Finally, for safestack-TSO none of the 24,000 tasks
generated with three selected tiles exposes a bug within thegiven timeouts (despite the fact that this already represents
52,000 hours CPU-time). Since the experimental set-up means
we are only looking for bugs that occur only under TSO
but not under SC, we can clearly see that the TSO-only bug
is extremely rare. In such cases, V ERISMART is unable to
leverage the effectiveness of the underlying analysis tool, and
suffers from the same explosion of the search spaces as other
sampling-based methods such as testing or explicit state model
checking. Here, symbolic methods that analyze all behaviors
simultaneously have the upper hand, as demonstrated by Lazy-
CSeq‚Äôs ability to expose the TSO-only bug.
Since the generated problem instances are completely in-
dependent and can be analyzed in parallel, V ERISMART is
indeed a very effective veriÔ¨Åcation approach. Fig. 6 shows that
with moderate resources (5‚Äì50 cores) we can get a noticeable
speed-up on the expected bug-Ô¨Ånding time. In particular, for
eliminationstack-SC the expected time is roughly the
same as the minimum time already for few cores and reaches
a more than 1000x speed-up compared to the all-schedule
comprehensive veriÔ¨Åcation time.
In general, Fig. 6 shows that the expected bug-Ô¨Ånding time
converges faster to the minimum time when the probability of
Ô¨Ånding a buggy program variant is higher. Since larger tiles
would ensure higher probability of Ô¨Ånding a buggy variant but
at the same time could affect the veriÔ¨Åcation time, determining
the right tile size seems to be a crucial aspect for maximizing
the beneÔ¨Åts of our approach.
760
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:02 UTC from IEEE Xplore.  Restrictions apply. All schedules:
T
ime: 46764s
Memory: 4203.9MB
1 400 800 1;200 1;600 2;00034:95001;0001;5002;0002;5003;000
Number of
coresExpected b
ug-Ô¨Ånding time (second)eliminationstack-SC (unwind=1,
rounds=2, thread=8, visible point=52)
Tile
size 12
Tile
size 18
Minimum time
Allschedules:
T
ime: 24139s
Memory: 6632.4MB
1 400 800 1;200 1;600 2;000195:65001;0001;5002;000
(1135, 409)
Number of
coresExpected b
ug-Ô¨Ånding time (second)safestack-SC (unwind=3,
rounds=4, thread=4, visible point=152)
Tile
size 11
Tile
size 20
Minimum time
Allschedules:
T
ime: 4777s
Memory: 3708.4MB
1 400 800 1;200 1;600 2;000593:51;0002;0003;0004;0005;000
Number of
coresExpected b
ug-Ô¨Ånding time (second)safestack-PSO (unwind=3,
rounds=3, thread=4, visible point=152)
Tile
size 12
Tile
size 20
Minimum time
Fig. 6.
Expected bug-Ô¨Ånding time varying over the number of cores. A round
(resp. square) point marks the expected time corresponding to the number of
cores that are needed to Ô¨Ånd a bug with probability 0.95 (resp. 0.99).VII. R ELATED WORK
There is a wide range of approaches proposed in the
literature on automatic analysis of concurrent programs. Here
we brieÔ¨Çy describe the related work and compare it to the
work presented in this paper.
Parallel VeriÔ¨Åcation: Attempts to parallelize veriÔ¨Åcation by
partitioning the problem and distributing the workload have
been implemented in explicit-state model checking [2], [25]
and SAT solving [3]. With the rise of multi-core processors,
techniques that exploit shared memory for communication
have been proposed [26], [27]. However, these approaches
suffer from the overhead introduced by exchanging infor-
mation between the instances. Approaches that run several
tools with different strategies and heuristics in parallel on
the unpartitioned problem have been more successful. Such
portfolio approaches have been implemented in automated
theorem provers [6], [7], [8] and SAT/SMT solvers [5], [28].
Our approach leverages so-called swarm veriÔ¨Åcation (SV),
as promoted by Holzmann et al for explicit-state model
checking [4], [1], [29]. In SV computing instances do not
collaborate directly in Ô¨Ånding a solution, but solve independent
subproblems that cover the original problem. We lift this idea
to symbolic model checking through sequentialization.
Sequentialization: Reducing the analysis of a concurrent
program to the analysis of sequential programs was Ô¨Årst
proposed by Qadeer and Wu [30]. They transform a concurrent
program into a sequential one that simulates all executions
of the original program with at most two context-switches.
Lal and Reps [31], [32] generalized the concept to arbitrary
context bounds. In our experiments, we used Lazy-CSeq [10],
[33], [11], [34], [35], which implements a sequentialization
as a code-to-code translation that is efÔ¨Åciently analyzable by
sequential bounded model checking tools such as CBMC [18].
Musuvathi and Qadeer [9] propose an algorithm for iteratively
relaxing the context bound. This is orthogonal to our approach:
in our experiments we Ô¨Åxed the maximum number of context-
switches and analysed tilings of three different sizes. We could
consider their algorithm as a starting point to automatically
Ô¨Ånd good parameter values for our tilings.
Concolic Testing: Concolic testing [19] combines symbolic
aspects with concrete inputs. Namely, it runs the program
over an input vector with both concrete and symbolic values,
and uses SMT solvers to compute new input vectors that
systematically explore the branches of the program. Farzan
et al [36] extend this idea to concurrent programs and call it
(con)2colic testing. They use the notion of thread interference
scenario, which is a representation of a set of bounded inter-
ferences [37] among the threads, which deÔ¨Åne the scheduling
constraints for a concurrent program run. These interference
scenarios are then explored in a systematic way by generating
a schedule and input vectors that conform with the scenario.
(con)2colic testing analyzes the program sequentially and
accumulates information about explored scenarios in a data
structure, whereas our approach is capable of analyzing tilings
independently and can thus be parallelized at large scale.
761
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:02 UTC from IEEE Xplore.  Restrictions apply. Moreover, (con)2colic testing requires to modify the core of
a concolic testing tool in order to handle concurrent programs
and thus it cannot Ô¨Çexibly leverage the increasing power of
existing sequential checkers.
Testing: Automated testing tools such as CHESS [38]
have been highly successful for Ô¨Ånding concurrency bugs
in large code bases because of their ability to handle code
independently of its sequential complexity. CHESS controls
the scheduler and explores all possible interleavings giving
priority to schedules with few context-switches. Nonetheless,
the success of testing depends on the proportion of schedules
that lead to a bug w.r.t. the total number of schedules, as shown
by a recent empirical study [39], [22] on testing of concurrent
programs. Preemption sealing [40] consists of inhibiting pre-
emptions in some program modules which corresponds in our
approach to choose a tiling where tiles exactly correspond to
program modules. This strategy was aimed to tolerating errors
for Ô¨Ånding more ones and compositional testing of layered
concurrent systems. The uniform tiling we implement in this
paper is irrespective of the structure of the program and looks
more appropriate for an exhaustive bug-Ô¨Ånding search up to a
given number of context-switches. There are also differences
in the implementation of the two techniques, we do not seal
portions of code with scope functions but rather we implement
tiles statically, that in general makes the underlying BMC
analysis simpler. Other testing tools try to mutate observed
interleavings to Ô¨Ånd bugs (e.g. [41], [42]). Our approach can
be seen as a way to tune concurrency veriÔ¨Åcation between
concrete testing and fully symbolic veriÔ¨Åcation.
VIII. C ONCLUSIONS AND FUTURE DIRECTIONS
We have presented a swarm approach for Ô¨Ånding bugs
in concurrent programs. We perform a code-to-code trans-
lation that constructs program variants by placing tiles over
the threads, and thus reducing nondeterminism by allowing
context-switches to occur only in a selected subset of tiles
and inhibiting statement reordering in other selected ones.
The set of possible program variants deÔ¨Åned by a tiling
covers all possible interleavings of the concurrent programs.
We can analyze these program variants in parallel on a
cluster using any off-the-shelf backend tool. We implement
the approach building on the CSeq framework and use Lazy-
CSeq with CBMC backend for the Ô¨Ånal analysis. We experi-
mentally show that we can Ô¨Ånd bugs in very hard concurrency
benchmarks, eliminationstack andsafestack, under
different memory models (SC and PSO) by analysing only
a modest number of randomly picked program variants. In
comparison to analyzing the original program, our approach
reduces time and memory footprint of the backend analysis
tool when launched on a program variant. In summary, we
are able to reduce the wall clock time to Ô¨Ånd Heisenbugs
by at least two orders of magnitude on the hardest known
concurrency benchmarks.
Future Directions: The ideas and approaches proposed in
this paper may underpin the development of more effectivebug-Ô¨Ånding approaches for concurrent programs. We brieÔ¨Çy
discuss this below.
We have conducted preliminary experiments using a BDD-
based model checker designed for concurrent Boolean pro-
grams [43], [44] on a version of safestack that we have
translated by hand. By performing a state space exploration
up to four rounds of computation, the BDD size exploded
and the analysis was unsuccessful. Repeating the experiment
by applying our veriÔ¨Åcation approach with this same tool as
backend analyzer, the BDD sizes reduced considerably on all
produced program variants, and we have been able to Ô¨Ånd a
bug in less than one minute using only a handful of instances.
This suggests that analysis based on BDD can be very valuable
when combined with our veriÔ¨Åcation approach, particularly
for lock-free implementations of data-structures, and should
be further developed to handle multi-threaded C programs.
In our experiments, we use a bounded model checking
backend. This proved to be very efÔ¨Åcient on instances that
actually contain an interleaving that exposes the bug but very
slow on the other (bug-free) instances. We think that abstract
interpretation has the potential for quickly discharging bug-
free instances. This is indeed corroborated by our preliminary
experiments where we have used standard abstractions avail-
able in abstract interpreters such as C ONCUR INTER PROC [45].
We have in fact discovered that with abstract interpretation we
can deem bug-free a signiÔ¨Åcant number of instances orders-
of-magnitude faster than BMC.
Effective analysis tools based on sound approximation, such
as abstract interpretation, can also play a signiÔ¨Åcant role in
building veriÔ¨Åcation approaches for Ô¨Ånding extremely rare
bugs. For example, in our experiments we are not able to
Ô¨Ånd the bug for safestack-TSO although we know that
there must be an offending execution. We intend to tackle
the problem of Ô¨Ånding such extremely rare bugs by combin-
ing tools based on sound approximations with a recursive
veriÔ¨Åcation approach in the style of a divide-and-conquer
algorithm. At each level of the recursion, we split the problem
using the tiling as shown in this paper. Then, we run in
parallel on each instance two tools: a bug Ô¨Ånder and bug-free
prover. We also give a timeout to halt them. Now, as soon
as one of the two tools succeeds we either report the bug or
discard the instance (bottom of the recursion). The method
recurs on all the instances where the timeout is reached.
This method has the potential to take advantage of both the
best available technologies for Ô¨Ånding bugs, such as those
based on BMC [17], [46], [47], [48], [49] and testing [38],
[36], [22], and for proving absence of bugs, such as abstract
interpretation [50], enhanced with the V ERISMART approach.
ACKNOWLEDGMENT
The authors acknowledge the use of the IRIDIS High Per-
formance Computing Facility, and associated support services
at the University of Southampton, in the completion of this
work.
762
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:02 UTC from IEEE Xplore.  Restrictions apply. REFERENCES
[1] G. J. Holzmann, R. Joshi, and A. Groce, ‚ÄúSwarm veriÔ¨Åcation tech-
niques,‚Äù IEEE Trans. Software Eng., vol. 37, no. 6, pp. 845‚Äì857, 2011.
[2] U. Stern and D. L. Dill, ‚ÄúParallelizing the murphi veriÔ¨Åer,‚Äù in Computer
Aided VeriÔ¨Åcation, 9th International Conference, CAV ‚Äô97, Haifa, Israel,
June 22-25, 1997, Proceedings, ser. Lecture Notes in Computer Science,
O. Grumberg, Ed., vol. 1254. Springer, 1997, pp. 256‚Äì278.
[3] K. Ohmura and K. Ueda, ‚Äúc-sat: A parallel SAT solver for clusters,‚Äù in
Theory and Applications of SatisÔ¨Åability Testing - SAT 2009, 12th Inter-
national Conference, SAT 2009, Swansea, UK, June 30 - July 3, 2009.
Proceedings, ser. Lecture Notes in Computer Science, O. Kullmann, Ed.,
vol. 5584. Springer, 2009, pp. 524‚Äì537.
[4] G. J. Holzmann, R. Joshi, and A. Groce, ‚ÄúSwarm veriÔ¨Åcation,‚Äù in 23rd
IEEE/ACM International Conference on Automated Software Engineer-
ing (ASE 2008), 15-19 September 2008, L‚ÄôAquila, Italy. IEEE Computer
Society, 2008, pp. 1‚Äì6.
[5] L. Xu, F. Hutter, H. H. Hoos, and K. Leyton-Brown, ‚ÄúSatzilla: Portfolio-
based algorithm selection for SAT,‚Äù J. Artif. Intell. Res., vol. 32, pp.
565‚Äì606, 2008.
[6] J. Schumann, ‚ÄúSicotheo: Simple competitive parallel theorem provers,‚Äù
inAutomated Deduction - CADE-13, 13th International Conference on
Automated Deduction, New Brunswick, NJ, USA, July 30 - August 3,
1996, Proceedings, ser. Lecture Notes in Computer Science, M. A.
McRobbie and J. K. Slaney, Eds., vol. 1104. Springer, 1996, pp. 240‚Äì
244.
[7] A. Wolf and R. Letz, ‚ÄúStrategy parallelism in automated theorem
proving,‚Äù IJPRAI, vol. 13, no. 2, pp. 219‚Äì245, 1999.
[8] G. Sutcliffe and D. Seyfang, ‚ÄúSmart selective competition parallelism
ATP,‚Äù in Proceedings of the Twelfth International Florida ArtiÔ¨Åcial
Intelligence Research Society Conference, May 1-5, 1999, Orlando,
Florida, USA, A. N. Kumar and I. Russell, Eds. AAAI Press, 1999,
pp. 341‚Äì345.
[9] M. Musuvathi and S. Qadeer, ‚ÄúIterative context bounding for systematic
testing of multithreaded programs,‚Äù in Proceedings of the ACM SIG-
PLAN 2007 Conference on Programming Language Design and Imple-
mentation, San Diego, California, USA, June 10-13, 2007, J. Ferrante
and K. S. McKinley, Eds. ACM, 2007, pp. 446‚Äì455.
[10] O. Inverso, T. L. Nguyen, B. Fischer, S. La Torre, and G. Parlato,
‚ÄúLazy-cseq: A context-bounded model checking tool for multi-threaded
c-programs,‚Äù in 30th IEEE/ACM International Conference on Automated
Software Engineering, ASE 2015, Lincoln, NE, USA, November 9-13,
2015, M. B. Cohen, L. Grunske, and M. Whalen, Eds. IEEE Computer
Society, 2015, pp. 807‚Äì812.
[11] O. Inverso, E. Tomasco, B. Fischer, S. La Torre, and G. Parlato,
‚ÄúBounded model checking of multi-threaded C programs via lazy
sequentialization,‚Äù in Computer Aided VeriÔ¨Åcation - 26th International
Conference, CAV 2014, Held as Part of the Vienna Summer of Logic,
VSL 2014, Vienna, Austria, July 18-22, 2014. Proceedings, ser. Lecture
Notes in Computer Science, A. Biere and R. Bloem, Eds., vol. 8559.
Springer, 2014, pp. 585‚Äì602.
[12] D. Vyukov, ‚ÄúBug with a context switch bound
5,‚Äù 2010, https://social.msdn.microsoft.com/Forums/
en-US/91c1971c-519f-4ad2-816d-149e6b2fd916/
bug-with-a-context-switch-bound-5?forum=chess.
[13] D. Hendler, N. Shavit, and L. Yerushalmi, ‚ÄúA scalable lock-free stack
algorithm,‚Äù in SPAA 2004: Proceedings of the Sixteenth Annual ACM
Symposium on Parallelism in Algorithms and Architectures, June 27-30,
2004, Barcelona, Spain, P. B. Gibbons and M. Adler, Eds. ACM, 2004,
pp. 206‚Äì215.
[14] E. M. Clarke, D. Kroening, and K. Yorav, ‚ÄúBehavioral consistency of C
and verilog programs using bounded model checking,‚Äù in Proceedings
of the 40th Design Automation Conference, DAC 2003, Anaheim, CA,
USA, June 2-6, 2003. ACM, 2003, pp. 368‚Äì371.
[15] M. M ¬®uller-Olm, Variations on Constants - Flow Analysis of Sequen-
tial and Parallel Programs, ser. Lecture Notes in Computer Science.
Springer, 2006, vol. 3800.
[16] B. Fischer, O. Inverso, and G. Parlato, ‚ÄúCseq: A concurrency pre-
processor for sequential C veriÔ¨Åcation tools,‚Äù in 2013 28th IEEE/ACM
International Conference on Automated Software Engineering, ASE
2013, Silicon Valley, CA, USA, November 11-15, 2013, E. Denney,
T. Bultan, and A. Zeller, Eds. IEEE, 2013, pp. 710‚Äì713.
[17] D. Kroening and M. Tautschnig, ‚ÄúCBMC - C bounded model checker -
(competition contribution),‚Äù in Tools and Algorithms for the Construc-tion and Analysis of Systems - 20th International Conference, TACAS
2014, Held as Part of the European Joint Conferences on Theory and
Practice of Software, ETAPS 2014, Grenoble, France, April 5-13, 2014.
Proceedings, ser. Lecture Notes in Computer Science, E. ¬¥Abrah ¬¥am and
K. Havelund, Eds., vol. 8413. Springer, 2014, pp. 389‚Äì391.
[18] E. M. Clarke, D. Kroening, and F. Lerda, ‚ÄúA tool for checking ANSI-C
programs,‚Äù in Tools and Algorithms for the Construction and Analysis
of Systems, 10th International Conference, TACAS 2004, Held as Part
of the Joint European Conferences on Theory and Practice of Software,
ETAPS 2004, Barcelona, Spain, March 29 - April 2, 2004, Proceedings,
ser. Lecture Notes in Computer Science, K. Jensen and A. Podelski,
Eds., vol. 2988. Springer, 2004, pp. 168‚Äì176.
[19] P. Godefroid, N. Klarlund, and K. Sen, ‚ÄúDART: directed automated
random testing,‚Äù in Proceedings of the ACM SIGPLAN 2005 Conference
on Programming Language Design and Implementation, Chicago, IL,
USA, June 12-15, 2005, V . Sarkar and M. W. Hall, Eds. ACM, 2005,
pp. 213‚Äì223.
[20] C. Cadar, D. Dunbar, and D. R. Engler, ‚ÄúKLEE: unassisted and auto-
matic generation of high-coverage tests for complex systems programs,‚Äù
in8th USENIX Symposium on Operating Systems Design and Implemen-
tation, OSDI 2008, December 8-10, 2008, San Diego, California, USA,
Proceedings, R. Draves and R. van Renesse, Eds. USENIX Association,
2008, pp. 209‚Äì224.
[21] E. Tomasco, T. L. Nguyen, O. Inverso, B. Fischer, S. La Torre, and
G. Parlato, ‚ÄúLazy sequentialization for TSO and PSO via shared memory
abstractions,‚Äù in 2016 Formal Methods in Computer-Aided Design,
FMCAD 2016, Mountain View, CA, USA, October 3-6, 2016, R. Piskac
and M. Talupur, Eds. IEEE, 2016, pp. 193‚Äì200.
[22] P. Thomson, A. F. Donaldson, and A. Betts, ‚ÄúConcurrency testing using
controlled schedulers: An empirical study,‚Äù TOPC, vol. 2, no. 4, pp.
23:1‚Äì23:37, 2016.
[23] D. Detlefs, C. H. Flood, A. Garthwaite, P. A. Martin, N. Shavit, and
G. L. S. Jr., ‚ÄúEven better dcas-based concurrent deques,‚Äù in Distributed
Computing, 14th International Conference, DISC 2000, Toledo, Spain,
October 4-6, 2000, Proceedings, ser. Lecture Notes in Computer Sci-
ence, M. Herlihy, Ed., vol. 1914. Springer, 2000, pp. 59‚Äì73.
[24] A. Bouajjani, M. Emmi, C. Enea, and J. Hamza, ‚ÄúTractable reÔ¨Ånement
checking for concurrent objects,‚Äù in Proceedings of the 42nd Annual
ACM SIGPLAN-SIGACT Symposium on Principles of Programming
Languages, POPL 2015, Mumbai, India, January 15-17, 2015, S. K.
Rajamani and D. Walker, Eds. ACM, 2015, pp. 651‚Äì662.
[25] J. Barnat, L. Brim, and I. Cern ¬¥a, ‚ÄúCluster-based LTL model checking
of large systems,‚Äù in Formal Methods for Components and Objects, 4th
International Symposium, FMCO 2005, Amsterdam, The Netherlands,
November 1-4, 2005, Revised Lectures, ser. Lecture Notes in Computer
Science, F. S. de Boer, M. M. Bonsangue, S. Graf, and W. P. de Roever,
Eds., vol. 4111. Springer, 2005, pp. 259‚Äì279.
[26] J. Barnat, L. Brim, and P. Rockai, ‚ÄúScalable multi-core LTL model-
checking,‚Äù in Model Checking Software, 14th International SPIN Work-
shop, Berlin, Germany, July 1-3, 2007, Proceedings, ser. Lecture Notes
in Computer Science, D. Bosnacki and S. Edelkamp, Eds., vol. 4595.
Springer, 2007, pp. 187‚Äì203.
[27] G. J. Holzmann and D. Bosnacki, ‚ÄúThe design of a multicore extension
of the SPIN model checker,‚Äù IEEE Trans. Software Eng., vol. 33, no. 10,
pp. 659‚Äì674, 2007.
[28] C. M. Wintersteiger, Y . Hamadi, and L. M. de Moura, ‚ÄúA concurrent
portfolio approach to SMT solving,‚Äù in Computer Aided VeriÔ¨Åcation,
21st International Conference, CAV 2009, Grenoble, France, June 26
- July 2, 2009. Proceedings, ser. Lecture Notes in Computer Science,
A. Bouajjani and O. Maler, Eds., vol. 5643. Springer, 2009, pp. 715‚Äì
720.
[29] G. J. Holzmann, ‚ÄúCloud-based veriÔ¨Åcation of concurrent software,‚Äù in
VeriÔ¨Åcation, Model Checking, and Abstract Interpretation - 17th Inter-
national Conference, VMCAI 2016, St. Petersburg, FL, USA, January
17-19, 2016. Proceedings, ser. Lecture Notes in Computer Science,
B. Jobstmann and K. R. M. Leino, Eds., vol. 9583. Springer, 2016,
pp. 311‚Äì327.
[30] S. Qadeer and D. Wu, ‚ÄúKISS: keep it simple and sequential,‚Äù in
Proceedings of the ACM SIGPLAN 2004 Conference on Programming
Language Design and Implementation 2004, Washington, DC, USA, June
9-11, 2004, W. Pugh and C. Chambers, Eds. ACM, 2004, pp. 14‚Äì24.
[31] A. Lal and T. W. Reps, ‚ÄúReducing concurrent analysis under a context
bound to sequential analysis,‚Äù Formal Methods in System Design,
vol. 35, no. 1, pp. 73‚Äì97, 2009.
763
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:02 UTC from IEEE Xplore.  Restrictions apply. [32] S. La Torre, P. Madhusudan, and G. Parlato, ‚ÄúReducing context-
bounded concurrent reachability to sequential reachability,‚Äù in Computer
Aided VeriÔ¨Åcation, 21st International Conference, CAV 2009, Grenoble,
France, June 26 - July 2, 2009. Proceedings, ser. Lecture Notes in Com-
puter Science, A. Bouajjani and O. Maler, Eds., vol. 5643. Springer,
2009, pp. 477‚Äì492.
[33] O. Inverso, E. Tomasco, B. Fischer, S. La Torre, and G. Parlato, ‚ÄúLazy-
cseq: A lazy sequentialization tool for C - (competition contribution),‚Äù in
Tools and Algorithms for the Construction and Analysis of Systems - 20th
International Conference, TACAS 2014, Held as Part of the European
Joint Conferences on Theory and Practice of Software, ETAPS 2014,
Grenoble, France, April 5-13, 2014. Proceedings, ser. Lecture Notes
in Computer Science, E. ¬¥Abrah ¬¥am and K. Havelund, Eds., vol. 8413.
Springer, 2014, pp. 398‚Äì401.
[34] T. L. Nguyen, B. Fischer, S. La Torre, and G. Parlato, ‚ÄúConcurrent
program veriÔ¨Åcation with lazy sequentialization and interval analysis,‚Äù
inNetworked Systems - 5th International Conference, NETYS 2017,
Marrakech, Morocco, May 17-19, 2017, Proceedings, ser. Lecture Notes
in Computer Science, A. E. Abbadi and B. Garbinato, Eds., vol. 10299,
2017, pp. 255‚Äì271.
[35] ‚Äî‚Äî, ‚ÄúLazy sequentialization for the safety veriÔ¨Åcation of unbounded
concurrent programs,‚Äù in Automated Technology for VeriÔ¨Åcation and
Analysis - 14th International Symposium, ATVA 2016, Chiba, Japan,
October 17-20, 2016, Proceedings, ser. Lecture Notes in Computer
Science, C. Artho, A. Legay, and D. Peled, Eds., vol. 9938, 2016, pp.
174‚Äì191.
[36] A. Farzan, A. Holzer, N. Razavi, and H. Veith, ‚ÄúCon2colic testing,‚Äù in
Joint Meeting of the European Software Engineering Conference and the
ACM SIGSOFT Symposium on the Foundations of Software Engineering,
ESEC/FSE‚Äô13, Saint Petersburg, Russian Federation, August 18-26,
2013, B. Meyer, L. Baresi, and M. Mezini, Eds. ACM, 2013, pp.
37‚Äì47.
[37] N. Razavi, A. Farzan, and A. Holzer, ‚ÄúBounded-interference sequential-
ization for testing concurrent programs,‚Äù in Leveraging Applications of
Formal Methods, VeriÔ¨Åcation and Validation. Technologies for Mastering
Change - 5th International Symposium, ISoLA 2012, Heraklion, Crete,
Greece, October 15-18, 2012, Proceedings, Part I, ser. Lecture Notes
in Computer Science, T. Margaria and B. Steffen, Eds., vol. 7609.
Springer, 2012, pp. 372‚Äì387.
[38] M. Musuvathi, S. Qadeer, T. Ball, G. Basler, P. A. Nainar, and
I. Neamtiu, ‚ÄúFinding and reproducing heisenbugs in concurrent pro-
grams,‚Äù in 8th USENIX Symposium on Operating Systems Design
and Implementation, OSDI 2008, December 8-10, 2008, San Diego,
California, USA, Proceedings, R. Draves and R. van Renesse, Eds.
USENIX Association, 2008, pp. 267‚Äì280.
[39] P. Thomson, A. F. Donaldson, and A. Betts, ‚ÄúConcurrency testing using
schedule bounding: an empirical study,‚Äù in ACM SIGPLAN Symposium
on Principles and Practice of Parallel Programming, PPoPP ‚Äô14,
Orlando, FL, USA, February 15-19, 2014, J. E. Moreira and J. R. Larus,
Eds. ACM, 2014, pp. 15‚Äì28.
[40] T. Ball, S. Burckhardt, K. E. Coons, M. Musuvathi, and S. Qadeer,
‚ÄúPreemption sealing for efÔ¨Åcient concurrency testing,‚Äù in Tools and
Algorithms for the Construction and Analysis of Systems, 16th Inter-
national Conference, TACAS 2010, Held as Part of the Joint European
Conferences on Theory and Practice of Software, ETAPS 2010, Paphos,
Cyprus, March 20-28, 2010. Proceedings, ser. Lecture Notes in Com-
puter Science, J. Esparza and R. Majumdar, Eds., vol. 6015. Springer,
2010, pp. 420‚Äì434.
[41] W. Zhang, J. Lim, R. Olichandran, J. Scherpelz, G. Jin, S. Lu, and T. W.
Reps, ‚ÄúConseq: detecting concurrency bugs through sequential errors,‚Äù
inProceedings of the 16th International Conference on ArchitecturalSupport for Programming Languages and Operating Systems, ASPLOS
2011, Newport Beach, CA, USA, March 5-11, 2011, R. Gupta and T. C.
Mowry, Eds. ACM, 2011, pp. 251‚Äì264.
[42] N. Razavi, F. Ivancic, V . Kahlon, and A. Gupta, ‚ÄúConcurrent test gener-
ation using concolic multi-trace analysis,‚Äù in Programming Languages
and Systems - 10th Asian Symposium, APLAS 2012, Kyoto, Japan,
December 11-13, 2012. Proceedings, ser. Lecture Notes in Computer
Science, R. Jhala and A. Igarashi, Eds., vol. 7705. Springer, 2012, pp.
239‚Äì255.
[43] S. La Torre, P. Madhusudan, and G. Parlato, ‚ÄúAnalyzing recursive
programs using a Ô¨Åxed-point calculus,‚Äù in Proceedings of the 2009
ACM SIGPLAN Conference on Programming Language Design and
Implementation, PLDI 2009, Dublin, Ireland, June 15-21, 2009, M. Hind
and A. Diwan, Eds. ACM, 2009, pp. 211‚Äì222.
[44] ‚Äî‚Äî, ‚ÄúModel-checking parameterized concurrent programs using linear
interfaces,‚Äù in Computer Aided VeriÔ¨Åcation, 22nd International Confer-
ence, CAV 2010, Edinburgh, UK, July 15-19, 2010. Proceedings, ser.
Lecture Notes in Computer Science, T. Touili, B. Cook, and P. B.
Jackson, Eds., vol. 6174. Springer, 2010, pp. 629‚Äì644.
[45] B. Jeannet, ‚ÄúRelational interprocedural veriÔ¨Åcation of concurrent pro-
grams,‚Äù in Seventh IEEE International Conference on Software En-
gineering and Formal Methods, SEFM 2009, Hanoi, Vietnam, 23-27
November 2009, D. V . Hung and P. Krishnan, Eds. IEEE Computer
Society, 2009, pp. 83‚Äì92.
[46] T. L. Nguyen, O. Inverso, B. Fischer, S. La Torre, and G. Parlato, ‚ÄúLazy-
cseq 2.0: Combining lazy sequentialization with abstract interpretation
- (competition contribution),‚Äù in Tools and Algorithms for the Construc-
tion and Analysis of Systems - 23rd International Conference, TACAS
2017, Held as Part of the European Joint Conferences on Theory and
Practice of Software, ETAPS 2017, Uppsala, Sweden, April 22-29, 2017,
Proceedings, Part II, ser. Lecture Notes in Computer Science, A. Legay
and T. Margaria, Eds., vol. 10206, 2017, pp. 375‚Äì379.
[47] E. Tomasco, T. L. Nguyen, O. Inverso, B. Fischer, S. La Torre, and
G. Parlato, ‚ÄúMu-cseq 0.4: Individual memory location unwindings -
(competition contribution),‚Äù in Tools and Algorithms for the Construc-
tion and Analysis of Systems - 22nd International Conference, TACAS
2016, Held as Part of the European Joint Conferences on Theory
and Practice of Software, ETAPS 2016, Eindhoven, The Netherlands,
April 2-8, 2016, Proceedings, ser. Lecture Notes in Computer Science,
M. Chechik and J. Raskin, Eds., vol. 9636. Springer, 2016, pp. 938‚Äì
941.
[48] E. Tomasco, O. Inverso, B. Fischer, S. La Torre, and G. Parlato,
‚ÄúVerifying concurrent programs by memory unwinding,‚Äù in Tools and
Algorithms for the Construction and Analysis of Systems - 21st Inter-
national Conference, TACAS 2015, Held as Part of the European Joint
Conferences on Theory and Practice of Software, ETAPS 2015, London,
UK, April 11-18, 2015. Proceedings, ser. Lecture Notes in Computer
Science, C. Baier and C. Tinelli, Eds., vol. 9035. Springer, 2015, pp.
551‚Äì565.
[49] E. Tomasco, T. L. Nguyen, B. Fischer, S. La Torre, and G. Parlato, ‚ÄúUs-
ing shared memory abstractions to design eager sequentializations for
weak memory models,‚Äù in Software Engineering and Formal Methods -
15th International Conference, SEFM 2017, Trento, Italy, September 4-8,
2017, Proceedings, ser. Lecture Notes in Computer Science, A. Cimatti
and M. Sirjani, Eds., vol. 10469. Springer, 2017, pp. 185‚Äì202.
[50] P. Cousot and R. Cousot, ‚ÄúAbstract interpretation: A uniÔ¨Åed lattice model
for static analysis of programs by construction or approximation of
Ô¨Åxpoints,‚Äù in Conference Record of the Fourth ACM Symposium on
Principles of Programming Languages, Los Angeles, California, USA,
January 1977, R. M. Graham, M. A. Harrison, and R. Sethi, Eds. ACM,
1977, pp. 238‚Äì252.
764
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:02 UTC from IEEE Xplore.  Restrictions apply. 