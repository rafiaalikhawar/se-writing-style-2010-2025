ClDiff: Generating Concise Linked Code Differences
Kaifeng Huang‚àó
Fudan University
ChinaBihuan Chen‚àó‚Ä†
Fudan University
ChinaXin Peng‚àó
Fudan University
China
Daihong Zhou‚àó
Fudan University
ChinaYing Wang‚àó
Fudan University
ChinaYang Liu
Nanyang Technological University
Singapore
Wenyun Zhao‚àó
Fudan University
China
ABSTRACT
Analyzingandunderstandingsourcecodechangesisimportantina
varietyofsoftwaremaintenancetasks.Tothisend,many codediffer-
encingandcodechangesummarization methodshavebeenproposed.
Forsometasks(e.g.codereviewandsoftwaremerging),however,
those differencing methods generate too fine-grained a representa-
tionofcodechanges,andthosesummarizationmethodsgenerate
toocoarse-grainedarepresentationofcodechanges.Moreover,they
donotconsidertherelationshipsamongcodechanges.Therefore,
thegenerateddifferencesorsummariesmakeitnoteasytoanalyze
and understand code changes in some software maintenance tasks.
Inthispaper,weproposeacodedifferencingapproach,named
ClDiff,togenerateconciselinkedcodedifferenceswhosegranu-
larity is in between the existing code differencing and code change
summarizationmethods.Thegoalof ClDiffistogeneratemoreeas-
ily understandable code differences. ClDiff takes source code files
beforeandafterchangesasinputs,andconsistsofthreesteps.First,
itpre-processesthesourcecodefilesbypruningunchangeddeclara-
tionsfromtheparsedabstractsyntaxtrees.Second,itgeneratescon-
cisecodedifferencesbygroupingfine-grainedcodedifferencesatorabovethestatementlevelanddescribinghigh-levelchangesineachgroup.Third,itlinkstherelatedconcisecodedifferencesaccording
to five pre-defined links. Experiments with 12 Java projects (74,387
commits)andahumanstudywith10participantshaveindicatedthe
accuracy, conciseness, performance and usefulness of ClDiff.
CCS CONCEPTS
‚Ä¢Softwareanditsengineering ‚ÜíSoftwaremaintenancetools ;
‚àóK.Huang,B.Chen,X.Peng,D.Zhou,Y.WangandW.ZhaoarewiththeSchoolof
ComputerScienceandShanghaiKeyLaboratoryofDataScience,FudanUniversity,
China and the Shanghai Institute of Intelligent Electronics & Systems, China.
‚Ä†B. Chen is the corresponding author.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
¬© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.3238219KEYWORDS
Code Differencing, Program Comprehension, AST
ACM Reference Format:
KaifengHuang,BihuanChen,XinPeng,DaihongZhou,YingWang,Yang
Liu, and Wenyun Zhao. 2018. ClDiff: Generating Concise Linked Code
Differences. In Proceedings of the 2018 33rd ACM/IEEE International Con-
ferenceonAutomatedSoftwareEngineering(ASE‚Äô18),September3‚Äì7,2018,
Montpellier, France. ACM, New York, NY, USA, 12pages.https://doi.org/10.
1145/3238147.3238219
1 INTRODUCTION
Analyzingandunderstandingsourcecodechangesisimportantina
varietyofsoftwaremaintenancetasks.Forexample,toimprovesoft-
warequality,developersoftenspendasignificantamountoftimeto
comprehendcodechangesduringcodereview[ 6,52];toresolvemerg-
ingconflicts,codechangeknowledgeisrequiredduringsoftware
merging[ 43];andtoefficientlyfindregressionbugs,codechangein-
formationisusefulforselectingthetestcasesthatneedtobererun
duringregressiontesting[ 51].Therefore,anumberof codediffer-
encingandcodechangesummarization methodshavebeenproposed
to represent code changes at different granularity.
In particular, for code differencing, text-based methods [ 4,9,44,
46,50]areunawareofthesyntacticstructureofsourcecodeand
computetextualdifferencesthatarenoteasyforfurtheranalysis
and understanding. Instead, tree-based methods [ 16,17,19,21,24]
directly work at the abstract syntax tree (AST) granularity for gen-
erating fine-grained syntactic code differences. The differences be-
tweentwoASTsareintheformofaneditscript,asequenceof edit
actionstotransformtheASTbeforechangestotheASTafterchanges.
Sucheditscriptscanbetoofine-grained,tooscattered,andtoolongto
understandcodechangesinsomeapplications(e.g.codereviewandsoftwaremerging),especiallyforlargecodechanges[
24].Moreover,
therelationshipsamongcodechanges(e.g.achangetothesigna-
ture of a method can result in changes to all the invocations of the
method)are missing,which arein factimportant forcode change
analysisandunderstanding(e.g.therelatedcodechangesneedto
be considered together during code review or software merging).
Ontheotherhand,codechangesummarizationmethods[ 27,37,
38,45,49]generatenaturallanguagesummariestodescribecode
changes, e.g. the motivation behind code changes [ 49], the commit
message for code changes in a commit [ 27,37,38], and the release
679
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:52 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France K. Huang, B. Chen, X. Peng, D. Zhou, Y. Wang, Y. Liu and W. Zhao
public abstract class ExecutorConfigurationSupport ‚Ä¶ {
‚Ä¶
public void shutdown() {
‚Ä¶
- this.executor.shutdownNow();+      for(Runnable remainingTask : this.executor.shutdownNow()) {+         cancelRemainingTask(remainingTask);+      }
‚Ä¶
}
+   protected void cancelRemainingTask(Runnable task) {‚Ä¶}
}org.springframework.scheduling.concurrent.ExecutorConfigurationSupport.java
org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor.javaorg.springframework.scheduling.concurrent.ThreadPoolTaskScheduler.java
public class ThreadPoolTaskExecutor extends ExecutorConfigurationSupport ‚Ä¶ {
‚Ä¶
+   private final Map<Runnable, Object> decoratedTaskMap = ‚Ä¶;
‚Ä¶protected ExecutorService initializeExecutor(ThreadFactory threadFactory, 
RejectedExecutionHandler rejectedExecutionHandler) {
‚Ä¶
- super.execute(taskDecorator.decorate(command));+      Runnable decorated = taskDecorator.decorate(command);+      if (decorated != command) {+         decoratedTaskMap.put(decorated, command);+      }+      super.execute(decorated);
‚Ä¶
}‚Ä¶
+   @Override+   protected void cancelRemainingTask(Runnable task) {‚Ä¶}
}public class ThreadPoolTaskScheduler extends ExecutorConfigurationSupport ‚Ä¶ {
‚Ä¶
+   private final Map<Object, ListenableFuture<?>> listenableFutureMap = ‚Ä¶;
‚Ä¶ public ListenableFuture<?> submitListenable(Runnable task) {
ExecutorService executor = getScheduledExecutor();try {
- ListenableFutureTask<Object> future = new ListenableFutureTask<>(task, null);
- executor.execute(errorHandlingTask(future, false));
- return future;
+         ListenableFutureTask<Object> listenableFuture = new ListenableFutureTask<>(task, null);+         executeAndTrack(executor, listenableFuture);+         return listenableFuture;
}catch (RejectedExecutionException ex) {‚Ä¶}
}
public <T> ListenableFuture<T>  submitListenable(Callable<T> task) {
ExecutorService executor = getScheduledExecutor();
try {
- ListenableFutureTask<T> future = new ListenableFutureTask<>(task);
- executor.execute(errorHandlingTask(future, false));
- return future;
+         ListenableFutureTask<T> listenableFuture = new ListenableFutureTask<>(task);+         executeAndTrack(executor, listenableFuture);+         return listenableFuture;
}catch (RejectedExecutionException ex) {‚Ä¶}
}
+   private void executeAndTrack(ExecutorService executor, ListenableFutureTask<?> listenableFuture) {‚Ä¶}
+   @Override
+   protected void cancelRemainingTask(Runnable task) {‚Ä¶}
‚Ä¶
}






	






	



	
Figure 1: An Example of Code Changes from Commit 3c1adf7 in spring-framework
note forcode changesin arelease [ 45]. Thesemethods aremostly
developedfortheeaseofdocumentationofcodechanges.Thus,the
generatedsummariesareusuallytoocoarse-grainedtobeuseful
for in-depth analysis and understanding of code changes (e.g. code
review and software merging).
Toaddresstheproblemswithexistingmethodsandtoprovide
more easily understandable code differencing information required
fortaskssuchascodereviewandsoftwaremerging,weproposeandimplementanovelcodedifferencingapproach,namedClDiff.Itis
designedtogenerateaconcise,linkedrepresentationofcodedif-
ferences,whosegranularityisinbetweentheexistingcodediffer-
encingandcodechangesummarizationmethods.Inotherwords,
ClDiff not only generates short and informative codedifferences,
but also establishes their relationships.
Technically, ClDiff takes as inputs source code files before and
afterchanges(e.g.inapatch,commitorrelease),andworksinthree
steps. First, ClDiff pre-processes the source code files by pruning
unchanged declarations from parsed ASTs. The purpose is to avoid
unnecessary differencinganalysis on unchanged ASTelements in
thesecondstep.Second,ClDiffgeneratesconcisecodedifferences
via grouping the fine-grained code differences, generated by Gum-
Tree[17],atorabovethestatementlevelanddescribinghigh-level
changesineachgroup.Theunderlyingideaistoputtogetherthe
fine-grainedcodedifferencesthatarescatteredbutrelatedtoahigh-levelASTelement.Third,ClDifflinkstherelatedconcisecodedif-
ferencesaccordingtofivepre-definedlinks.Themotivationisto
consider such related code changes as a whole in some tasks.
We have implemented ClDiff for Java, and conducted experi-
ments with 12 open-source Java projects (i.e. 74,387 commits in to-
tal) to evaluate the accuracy, conciseness and performance of ClD-
iffaswellasahumanstudywith10participantstoevaluatetheuse-fulnessof ClDiff.TheresultshavedemonstratedthatClDiffgen-eratedconcisecodedifferencesandestablishedtheirlinkswithanac-curacyof99%and98%,respectively;andcomparedtoGumTree,ClD-iffgeneratedmorethan80%shortereditscriptfor48%commitswith
72% shorter time, and was more useful in change understanding.
In summary, this work makes the following contributions.‚Ä¢WeproposedacodedifferencingapproachnamedClDifftogen-
erate concise linked code differences.
‚Ä¢We implemented ClDiff for Java, and provided visualization for
the generated concise linked code differences.
‚Ä¢We conducted experiments with 12 open-source Java projects as
well as a human study with 10 participants to demonstrate ClD-
iff‚Äôs accuracy, conciseness, performance and usefulness.
2 PRELIMINARIES
AST.A source code file can be parsed into an abstract syntax tree
(AST),whichisarooted,labeled,orderedtree.Eachnodehasa label
to indicateits typerepresentinga structuralelement (e.g. declara-
tion)ofthesourcecode.Somenodeshaveastring valuetoindicate
the actual token (e.g. variable name) in code.
Example2.1. Fig.2(a)and2(b)givethetwoASTsbeforeandafter
the code changes at Line 7‚Äì12 in Fig. 1. We only show partial ASTs
forclarity.TheASTinFig. 2(a)containseightnodes.Specifically,
noden5hasthreechildnodes n6,n7andn8,anditslabelis Method-
Invocation.Thelabelof n6,n7andn8isSimpleName. n6,n7andn8re-
spectivelydenotethereceiver,nameandargumentofthemethodin-
vocation; and their value is taskDecorator, decorate andcommand.
ASTNodeTypeHierarchy. ThetypeoftherootnodeofanAST
isCompilationUnit,whosechildnodescanbeofthetype BodyDec-
laration.Thecommonsubtypesof BodyDeclaration areTypeDecla-
ration(class or interface declaration), MethodDeclaration (method
orconstructordeclaration), Initializer (staticorinstanceinitializing
block),FieldDeclaration (fielddeclaration),and EnumDeclaration
(enumeration declaration). Declarations can contain a list of state-
mentswhichhave22differentstatementtypes(e.g. IfStatement and
VariableDeclarationStatement). Statements can contain a list of ex-
pressions (e.g. MethodInvocation). Therefore, declaration, state-
ment and expression have a decreasing granularity. However, they
can be nested with each other.
ASTDifferencing. GiventwoASTsbeforeandaftercodechanges
(i.e.AST bandAST a), AST differencing tools can generate an edit
script(i.e. a sequence of edit actions). By sequentially applying the
680
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:52 UTC from IEEE Xplore.  Restrictions apply. ClDiff: Generating Concise Linked Code Differences ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
|-Block (n1)
|-ExpressionStatement (n2)
|-SuperMethodInvocation (n3)
|-SimpleName:execute (n4)
|-MethodInvocation (n5)
|-SimpleName:taskDecorator (n6)
|-SimpleName:decorate (n7)
|-SimpleName:command (n8)
|-Block (n9)
|-VariableDeclarationStatement (n10)
| |-SimpleType:Runnable (n11)
| | |-SimpleName:Runnable (n12)
| |-VariableDeclarationFragment (n13)
|   |-SimpleName:decorated (n14)
|   |-MethodInvocation (n15)
|     |-SimpleName:taskDecorator (n16)
|     |-SimpleName:decorate (n17)
|     |-SimpleName:command (n18)
|-IfStatement (n19)
| |-InfixExpression:!= (n20)
| | |-SimpleName:decorated (n21)
| | |-SimpleName:command (n22)
| |-Block (n23)
|   |-ExpressionStatement (n24)
|     |-MethodInvocation (n25)
|       |-SimpleName:decoratedTaskMap (n26)
|       |-SimpleName:put (n27)
|       |-SimpleName:decorated (n28)
|       |-SimpleName:command (n29)
|-ExpressionStatement (n30)
|-SuperMethodInvocation (n31)
|-SimpleName:execute (n32)
|-SimpleName:decorated (n33)addVariableDeclarationStatementP(n10, n1, 1)
addIfStatement(n19, n1, 2)
updateExpressionStatement(n2) by 
addSimpleName(n33, n3, 2)
moveMethodInvocation(n5, n13, 2)add(n10, n1, 1) 
add(n19, n1, 2) 
add(n11, n10, 1)
add(n13, n10, 2)
add(n20, n19, 1)
add(n23, n19, 2)
add(n12, n11, 1)
add(n14, n13, 1)
move(n5, n13, 2)
add(n21, n20, 1)
add(n22, n20, 2)
add(n24, n23, 1)
add(n33, n3, 2)
add(n25, n24, 1)
add(n26, n25, 1)
add(n27, n25, 2)
add(n28, n25, 3)
add(n29, n25, 4)<n1, n9>
<n2, n30>
<n3, n31>
<n4, n32>
<n5, n15>
<n6, n16>
<n7, n17>
<n8, n18>
(a) Partial AST Before Changes 
(b) Partial AST After Changes (c) Mapping by G UMTREE
(d) Edit Script by G UMTREE
(e) Edit Script by C LDIFF
Figure 2: An Example of Differencing on Line 7‚Äì12 in Fig. 1
editactions,wecanconvert AST btoAST a.Hereweapplythestate-
of-the-art tool, GumTree [ 17], to generate fine-grained code differ-
ences.GumTreeworksintwosteps.First,itusesheuristicstoderive
amapping between nodes in two ASTs. The mapping is a set of
pairs/angbracketleftnb,na/angbracketright,wherenode nbinAST bismappedtonode nainAST a.
Then,basedonthemapping,itgeneratestheeditscriptthatcon-
tains four kinds of edit actions, i.e. update,add,deleteandmove.
‚Ä¢update(n,v)replaces the value of node nwith a value v.
‚Ä¢add(n,p,i)adds a new node nas thei-th child node of node pif
pisnotnull.Otherwise, nbecomesthenewrootnodeandhas
the previous root node as its only child node.
‚Ä¢delete(n)removes a leaf node n.
‚Ä¢move(n,p,i)moves node nto be the i-th child node of node p.
All descendant nodes of nare moved together with n.
Example 2.2. Fig.2(c) give the mapping, generated by GumTree,
between the nodes in the two ASTs in Fig. 2(a) and2(b). Here all
the eight nodes in Fig. 2(a) are mapped. Based on this mapping,
GumTreegeneratesaneditscriptcontaining18editactions,aslisted
inFig.2(d).Specifically,oneoftheeditactionsis move(n5,n13,2),
which moves the method invocation rooted at n5to be the second
child node of a variable declaration fragment rooted at n13.
3 MOTIVATION AND OVERVIEW
Inthissection,wemotivatetheproposedapproachwithanexample
before introducing our approach overview.
3.1 Motivation Example
Fig.1lists three source code files changed in a commit taken from
spring-framework.Inclass x,aforstructure(Line2‚Äì4)isadded,
whereanewly-declaredmethod(Line5)isinvoked.Thisnewmethod
isthenoverriddeninbothclass y(Line13‚Äì14)andclass z(Line
29‚Äì30) because yandzinherit x. In class y, a field is declared
(Line6),avariableisextracted(Line7‚Äì8),andbothofthemareused
inanewly-added ifstructure(Line9‚Äì11).Inclass z,afiledisde-
clared (Line 15) and then used in a newly-declared method (Line28). This new method is then invoked in two similar code changes
(Line16‚Äì21and22‚Äì27).Thisexampleisusedthroughoutthepaper.
GiventhecodechangesatLine7‚Äì12inclass yinFig.1,wepresent
thetwopartialASTsbeforeandafterthechangesinFig. 2(a)and
2(b).Theaddednodesarehighlightedingreenandthemovednodes
arehighlightedinyellow.Herenodeletionorupdateisinvolved.Forthesechanges,GumTreegeneratestheeditscriptshowninFig. 2(d),
which means that 17 new nodes are added and one node is moved.
However,someeditactions(e.g.thoseunderlinedonesinFig. 2(d))
arerelatedtoahigh-levelASTelement(e.g.variabledeclarationstate-ment),butarescatteredacrosstheeditscript.Suchrelatedbutscat-
terededitactions,althoughbeingexhibitedtogetherinvisualiza-
tion,makethefollow-upanalysisandunderstandingofcodechangesdifficult.Forexample,incodereview,developerswillrecognizethe
insertionofavariabledeclarationstatementintuitivelyratherthan
thinking of the fine-grained tree operations. Similarly, in software
merging,anewly-addedvariabledeclarationstatementwillbecon-
sideredasawholetoresolveaconflict.Therefore,togeneratemore
easily-understandable code differences for both developers and au-
tomatic analysis tools, we try to obtain high-level concise code dif-
ferences at or above the statement level. Fig. 2(e) shows the edit
scriptgeneratedbyourapproach.Ithasfourhigh-leveleditactions,i.e.addingavariabledeclarationstatement,addingan ifstatement,
updatinganexpressionstatementbyaddingasimplename,andmov-
ingamethodinvocationtobeapartofthenewly-addedvariable
declaration statement (see approach details in Section 4.2).
On the other hand, the relationships among code changes are
not considered in GumTree but are actually helpful in the analysis
and understanding of code changes. As an example, for the newly-
declaredmethodatLine5inFig. 1,itisinvokedatLine3andoverrid-
denatLine13‚Äì14and29‚Äì30.Asanotherexample,thecodechangesatLine16‚Äì21arealmostthesametothecodechangesatLine22‚Äì27.Suchrelationshipscapturethecausalityofcodechanges,whichcan
speeduptheprocess ofcodereviewandimprovetheaccuracyof
merging conflict resolution. Therefore, we attempt to establish the
linksamonggeneratedhigh-levelcodedifferences(seeapproach
details in Section 4.3).
3.2 Approach Overview
Fig.3presentsanoverviewof ClDiff.Theinputsof ClDiffareaset
of pairs of source code files before and after changes (e.g. in a com-
mit, patch or release). The outputs can be visualized by our web-
basedtool.ClDiffworksinthreesteps,pre-processing(Section 4.1),
generating concise code differences (Section 4.2) and linking code
differences(Section 4.3),togenerateconciselinkedcodedifferences.
First,sincecodechangesoftenaffectasmallpartofasourcecode
fileandalargeamountofcoderemainsunchanged,wepre-process
thepairsofsourcecodefilestoremovesomeunchangedcodeinor-
dertoavoidunnecessarydifferencinganalysis.Tothisend,ClDifffirstparseseverypairofsourcecodefilesintoanASTpair,andthen
prunes unchanged declaration-level elements from the AST pairbased on a hashing technique. Here we select declaration as the
pruning unit to strike a balance between feasibility and scalability.
Second,asfine-grainedcodedifferences(intheformofeditac-
tions)areoftenrelatedtohigh-levelASTelementsbutscatteredacrosstheeditscript,wegeneratehigh-levelconcisecodedifferencesator
681
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:52 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France K. Huang, B. Chen, X. Peng, D. Zhou, Y. Wang, Y. Liu and W. Zhao
   
	
	

	

	

	   



Figure 3: An Overview of ClDiff
abovethestatementlevel.Specifically,ClDifffirstusesGumTree[ 17]
toobtainthemappingandeditactionsforeachprunedASTpair.
Then, it traverses the edit actions and the pruned AST pair to itera-
tivelygroupeditactionsthatarerelatedtoanASTelementator
abovethestatementlevel.Finally,itgeneratesaconcisecodediffer-
enceforeachgrouptocaptureitshigh-levelchanges.Herewechoose
statementasthesuitablegranularityofcodedifferencestobetter
reflect developers‚Äô intuition about code changes.
Third,sincecodechangesareoftencausallyrelatedwitheach
other,weestablishlinksamongthegeneratedconcisecodediffer-
ences.Specifically,basedontheconcisecodedifferencesforeach
pairofsourcecodefiles,ClDiffcheckswhetherthereexistsacodechangelinkbetweentwoconcisecodedifferencesaccordingtofive
pre-defined links (e.g., Def-Uselink).
4 METHODOLOGY
Inthissection,weelaborateeachstepof ClDiff(Fig. 3)indetail.
Ourapproachisgeneral,althoughweexplainourapproachforJava.
4.1 Pre-Processing
Inthefirststep,wepre-processthesourcecodefilestoprunesome
unchanged declarations from parsed ASTs.
Giveneachpairofsourcecodefiles /angbracketleftfb,fa/angbracketright,weparseitintoanAST
pair/angbracketleftAST b,AST a/angbracketright,whereAST bistheASTofthefile fbbeforecode
changesand AST aistheASTofthefile faaftercodechanges.Then,
wetraverse AST btocomputetwohashvaluesforthenodewhosela-
bel is a field, enumeration, method, inner class, or initializor decla-
ration,andstoretheASTnodetoamapwhosekeyisthetwohash
values.Onehashvalueiscalculatedoverthecanonicalnameofthe
residingclassandisusedtodistinguishthesamedeclarationinbothouterandinnerclasses.Anotherhashvalueiscalculatedoverthecor-respondingdeclarationcode(i.e.thesubtreerootedatthenode).Fi-nally,wetraverse
AST atocomputethetwohashvaluesforeachdec-
larationnode,andprunethenode(includingallitsdescendantnodes)fromboth
AST bandAST aifthetwohashvaluesfindamatchinthe
map.TheoutputisaprunedASTpair /angbracketleftAST/prime
b,AST/primea/angbracketright.Noticethatas
comments and Javadocs are not treated as code, they are removed
from ASTs beforehand.
4.2 Generating Concise Code Differences
In the second step, we generate concise code differences from fine-
grainedcodedifferences.Ourunderlyingideaistoputfine-grained
code differences within a statement or declaration AST element to
a group and describe high-level changes in the group.
Specifically,givenaprunedASTpair /angbracketleftAST/prime
b,AST/primea/angbracketright,weuseGum-
Tree[17]togeneratethemapping Mandtheeditscript Abetween
thetwoASTs.Recallthat MmaintainsthemappedASTnodepairs
andAstorestheeditactions(Section 2).Then,wetraversetheeditactions in three phases to group edit actions and generate concise
code differences.
Phase1. Different from update,addanddeleteactions that only
affect one atomic node but not its descendant nodes, moveactions
movethewholesubtreerootedatonenode.Therefore,a moveac-
tioncanalreadyreflecthigh-levelconcisecodechanges.Inthatsense,
foreachmove(n,p,i)‚ààA,wegenerateaconcisecodedifference
moveX(n,p,i),whereXisthelabelofnode nandexplicitlyreflects
the syntactic information, and remove move(n,p,i)fromA.
Example4.1. TheeditscriptinFig. 2(d)containsone moveaction
move(n5,n13,2)thatmovesawholemethodinvocation.Thus,ClD-
iff generates moveMethodInvocation (n5,n13,2).
Phase2. Somestatementsordeclarationshavesimplestructures,
while others contain complex ones with statements or declarations
nested as composing elements. In that sense, an addor adeleteac-
tiononastatementordeclarationASTnodeismostlyaccompaniedbysimultaneous addordeleteactionsonitscomposingelements;i.e.
awholeorapartofastatementordeclarationisaddedordeletedto-gether.Hence,wegroupeditactionswithrespecttothecomposing
elements ofa statementor declaration,and distinguishwhether a
wholeorapartofacomposingelementisaddedordeletedtogether.
Beforeintroducinghowtogroupeditactions,wefirstcategorize
allstatementsanddeclarationsintotwocategoriesanddefinetheir
baseandcomposing elements.
‚Ä¢C1.This category includes statements and declarations whose
childnodes Ncancontainstatementsordeclarations,e.g. IfState-
ment,TryStatement, MethodDeclaration andTypeDeclaration.
Wedefineeachnode n‚ààNthatisanon-blockstatementoradec-
laration as a composing element, each child node of the node
n‚ààNwhichisablockstatementasacomposingelement,and
all the other nodes in Nand their parent node as a base element.
‚Ä¢C2.This category contains statements and declarations whose
childnodesdonotcontainstatementsordeclarations,e.g. Expres-
sionStatement, VariableDeclarationStatement, ReturnStatement
andFieldDeclaration. They are defined as a base element and do
not have composing elements.
Example4.2. InFig.2,n10isavariabledeclarationstatementthat
belongsto C2;andthus n10andallitsdescendantnodesareconsid-
eredasthebaseelementof n10.n19isanifstatementwhichbelongs
toC1;andhence n19,n20,n21,n22andn23areconsideredasthebase
element of n19(representing the wrapper of the ifstatement intu-
itively), while n24and all its descendant nodes are considered as a
composing element of n19(indicating the statement in the ifstate-
ment body). Similarly, the base element of a method declaration
denotes the method with an empty body, whileits composing ele-
ments represent the statements in the method body.
682
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:52 UTC from IEEE Xplore.  Restrictions apply. ClDiff: Generating Concise Linked Code Differences ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
Then we introduce how to group edit actions. Specifically, for
eachadd(n,p,i)‚ààAwherenis a statement or declaration, we put
thisactionto Bwhichmaintainsthe addactionsonthebaseele-
ment, locate nonAST a(because addactions are applied on AST a),
andtraverse n‚Äôsdescendantnodesinadepth-firstwaywhiledistin-
guishingbaseandcomposingelements.Forthebaseelement,for
each traversed node m,i fmis newly-added by an addactiona,w e
groupatoBand continue the traversal on m‚Äôs child nodes; other-
wise(misnotnewly-added,i.e.thereexistsamatchin Mform),we
markBas apartial addition, stop our traversal on m‚Äôs child nodes,
butcontinuethetraversalonothernodesinthebaseelement.After
completing the traversal, if Bis marked as a partial addition, we
generate a concise code difference addXP(n,p,i), whereXis the
label ofn,Pdenotes partial addition, and nis the subtree result-
ingfromtheactionsin B,andremove BfromA;otherwise(the
whole base element is newly-added), we traverse the composing
elements to determine whether they are allnewly-added. If yes,
we store all these addactions to C, generate a concise code differ-
enceaddX(n,p,i), whereXis the label of nandnis the subtree
resultingfromtheactionsin BandC,andremove BandCfrom
A.Ifnot,wegenerate addXP(n,p,i)andremove BfromA.Intu-
itively, if one whole statement or declaration is added, we generate
one code difference; otherwise, we generate code differences on its
base and composing elements separately.
Ontheotherhand,foreach delete(n)‚ààAwherenisastatement
or declaration, we traverse nonAST b(asdeleteactions are applied
onAST b)inthesamewayasfor addactions,andgenerateeither
deleteXP (n)ordeleteX(n).
Example4.3. WhentraversingtheeditscriptinFig. 2(d),wefirst
analyzeadd(n10,n1,1),whichaddsavariabledeclarationstatement
thatbelongsto C2.Wegroupitwith add(n11,n10,1),add(n13,n10,2),
add(n12,n11,1)andadd(n14,n13,1)inB.A sBismarkedasapar-
tialaddition,wegeneratethefirstcodedifferenceinFig. 2(e).Then
we analyze add(n19,n1,2), which adds an ifstatement of C1.W e
groupitwith add(n20,n19,1),add(n21,n20,1),add(n22,n20,2)and
add(n23,n19,2)inB.AsBisnotmarked,wefurthergroup add(n24,
n23,1)withadd(n25,n24,1),add(n26,n25,1),add(n27,n25,2),add(n28,
n25,3)andadd(n29,n25,4)inC,andthengeneratethesecondcode
difference in Fig. 2(e) that adds a complete ifstatement.
Example 4.4. Fig.4shows another case of generating concise
codedifferences.WhentraversingtheeditscriptinFig. 4(e),wefirst
encounter add(n15,n1,1), which adds an ifstatement that belongs
toC1.Wegroupitwithalltheother addactionsinFig. 4(e)inB.As
Bis not marked, we further analyze its composing elements. How-
ever, the composing element is not newly-added but moved. Thus,
wegeneratethefirstcodedifferenceinFig. 4(f),whichactuallyadds
a wrapper of an ifstatement.
Phase3. AfterPhase1andPhase2,theremainingactionsin A
are onlyadd,deleteandupdateactions on non-statement and non-
declaration AST nodes. Given that some actions are applied within
the same statement or declaration, we group such actions together
with respect to their common ancestor statement or declaration. In
particular, for each traversed add(n,p,i)‚ààA, we locate n‚Äôs closest
ancestor node mthat is a statement or declaration in AST a,r e -
placemwithitsmapping m/primeinAST busingMifm/primeexists,andput
add(n,p,i)toalistQmthatmaintainsalltheactionsappliedwithinpublic abstract class PatternsRequestCondition‚Ä¶ {
‚Ä¶
public List<String> getMatchingPatterns(String lookupPath) {
‚Ä¶
-matches.sort(this.pathMatcher.getPatternComparator(lookupPath));
+      if (matches.size() > 1) {
+         matches.sort(this.pathMatcher.getPatternComparator(lookupPath));+      }
return matches;
}
}org.springframework.web.servlet.mvc.condition.PatternsRequestCondition.java




Block (n1)
|-...
|-ExpressionStatement (n2)
| |-MethodInvocation (n3)
|   |-SimpleName:matches (n4)
|   |-SimpleName:sort (n5)
|   |-MethodInvocation (n6)
|     |-FieldAccess (n7)
|     | |-ThisExpression (n8)
|     | |-SimpleName:pathMatcher (n9)
|     |-SimpleName:getPatternComparator (n10)
|    |-SimpleName:lookupPath (n11)
|-ReturnStatement (n12)
|-SimpleName:matches (n13)
Block (n14)
|-...|-IfStatement (n
15)
| |-InfixExpression:> (n16)
| | |-MethodInvocation (n17)
| | | |-SimpleName:matches (n18)
| | | |-SimpleName:size (n19)
| | |-NumberLiteral:1 (n20)
| |-Block (n21)
|   |-ExpressionStatement (n22) 
|     |-MethodInvocation (n23)
|       |-SimpleName:matches (n24)
|       |-SimpleName:sort (n25)
|       |-MethodInvocation (n26)
|         |-FieldAccess (n27)
|         | |-ThisExpression (n28)
|         | |-SimpleName:pathMatcher (n29)
|         |-SimpleName:getPatternComparator (n30)
|         |-SimpleName:lookupPath (n31)
|-ReturnStatement (n32)
|-SimpleName:matches (n33)addIfStatementP(n15, n1, 1)
moveExpressionStatement(n2, n21, 1)add(n15, n1, 1) 
add(n16, n15, 1) 
add(n21, n15, 2)
add(n17, n16, 1)
add(n20, n16, 2)
move(n2, n21, 1)
add(n18, n17, 1)
add(n19, n17, 2)<n1,n14> 
<n2, n22>
<n3, n23>
<n4, n24>
<n5, n25>
<n6, n26>
<n7, n27>
<n8, n28>
<n9, n29>
<n10,n30>
<n11,n31>
<n12,n32> 
<n13,n33>
(b) Partial AST Before Changes 
(c) Partial AST After Changes (d) Mapping by G UMTREE
(e) Edit Script by G UMTREE
(f) Edit Script by C LDIFF(a) An Example of Code Changes  from Commit b104897 in spring-framework
Figure 4: An Example of Concise Code Differences
m. Similarly, foreach traversed delete(n)orupdate(n,v)inA,w e
findn‚Äôsclosestancestornode mthatisastatementordeclarationin
AST b,andstore delete(n)orupdate(n,v)toQm.Afterthetraversal,
foreachQm,wegenerateaconcisecodedifference updateX(m)byY
whereXis the label of mandYrepresents the actions in Qmwith
the syntactic information highlighted in their action names. In this
way,alloriginally-scatterededitactionsononestatementordec-
laration are grouped together for the ease of analysis and under-
standing. Unlike our addanddeleteactions,mis not a subtree but
an atomic node to inform that the actions in Qmare applied on
scattered descendant nodes of m.
Example4.5. FollowingExample 4.1and4.3,thereisonlyonere-
mainingeditaction add(n33,n3,2)intheeditscriptinFig. 2(d)after
Phase1andPhase2. n33‚Äôsclosestancestornodethatisastatement
ordeclarationinFig. 2(b)isn30,mappedto n2inFig.2(a).Hence,
updateExpressionStatement (n2)by addSimpleName (n33,n3,2)is
generated, as shown by the last code difference in Fig. 2(e).
4.3 Linking Code Differences
In the third step, we establish code change links among the gener-
atedconcisecodedifferencesaccordingtofivepre-definedlinks.Such
links reflect the causality of code changes.
Wefirstdefinethefivekindsofcodechangelinks,whicharenot
meant to be exhaustive but to demonstrate that a small set of links
arealreadyusefulinchangeunderstanding.Theycanbeextendedto
incorporate new kinds of links.
‚Ä¢Def-UseLink. Ifthedeclarationofavariable,fieldormethodis
changed(i.e.added,deleted,updatedormoved)bycodedifference
683
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:52 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France K. Huang, B. Chen, X. Peng, D. Zhou, Y. Wang, Y. Liu and W. Zhao
Figure 5: A Snapshot of Our Visualization Tool
d1,theusageofthevariable,fieldormethodcanbechangedby d2.
Wedefinethelinkbetween d1andd2asaDef-Uselinkd1DU‚àí‚àí‚àí‚Üíd2.
‚Ä¢Abstract-Method Link. If the declaration of an abstract method
in a class is changed by d1, the implementation of the abstract
method in eachsub-class must be changed by d2. We definethe
link between d1andd2as anAbstract-Method linkd1AM‚àí‚àí‚àí‚Üíd2.
‚Ä¢Override-Method Link. If the declaration of a method in a class
is changed by d1, the implementation of the method might be
changed through override in each sub-class by d2. We define the
link between d1andd2as anOverride-Method linkd1OM‚àí‚àí‚àí‚Üíd2.
‚Ä¢Implement-MethodLink. Ifthe declaration ofamethodin anin-
terfaceischangedby d1,theimplementationofthemethodmust
bechangedineachclassthatimplementstheinterfaceby d2.W e
definethelinkbetween d1andd2asanImplement-Method link
d1IM‚àí ‚àí ‚Üíd2.
‚Ä¢Systematic-ChangeLink. Iftwocodedifferences d1andd2aresim-
ilar,theymightbecausedbysystematicchanges(e.g.refactor-
ing[35]andrecurringbugfixes[ 47]).Wedefinethelinkbetween
d1andd2as aSystematic-Change linkd1SC‚Üê ‚àí ‚Üíd2.
Then,weintroducehowtoestablishtheselinksbasedonconcise
codedifferences DiforeachprunedASTpair.Assumingthatthere
aretotally kASTpairs,i.e.1 ‚â§i‚â§k.Specifically,toestablish Def-
Uselinks,wefirstfindeach d‚ààD ithatisappliedonavariabledec-
laration statement, a field declaration or a method declaration, and
extractthenameofthevariable,fieldormethod.Then,welocate
everye‚ààD ithatiswithinthesamescope(i.e.foravariabledecla-
rationstatement,thescopeisitsenclosingmethoddeclaration;and
forafieldormethoddeclaration,thescopeisitsenclosingclassdec-
laration) and involves a variable, field access or method invocation
with the same name, and establish the link dDU‚àí‚àí‚àí‚Üíe. Here we only
consider the Def-Uselinks within a limited scope; e.g. we do not
consider that a method declaration might be used in another class.
TobuildAbstract-Method, Override-Method orImplement-Method
links,wefirstfindeach d‚ààD ithatisappliedonanabstractmethod
declaration,amethoddeclarationoraninterfacemethoddeclara-
tion,andextractthemethodsignatureandthenameoftheenclosing
abstract class, class or interface. Then, we find every e‚ààD j(j/nequali)
thatisappliedonsuchamethoddeclarationthatithasthesame
methodsignatureanditsenclosingclassextendsaclassorimple-
ments an interface with the same name, and construct the link
dAM‚àí‚àí‚àí‚Üíe,dOM‚àí‚àí‚àí‚ÜíeordIM‚àí ‚àí ‚Üíe.Toconstruct Systematic-Change links,foreach delete,addormove
actiond‚ààD ithatisappliedonnode nd,wefirstgeteach delete,
addormoveactione‚ààD j(e/nequald)thatisappliedon newhoselabel
is the same to nd. Then, we check whether the size of the grouped
editactions(seeSection 4.2)forndandneisthesame.Ifyes,we
compute the bi-gram similarity [ 2] between the code snippets cor-
responding tothe subtreesrooted at ndandne. Ifthe similarityis
largethanorequalto0.8,webuildthelink dSC‚àí ‚àí ‚Üíe.Foreach update
action, the overall procedure is similar but the similarity computa-
tion is different. Since our updateactions often group a set of fine-
grained edit actions that are scattered, ndandneare atomic nodes.
Hence, we get the subtrees rooted at ndandnefrom the pruned
ASTpair(i.e.eitherfromboth AST bandAST aoronlyfrom AST bde-
pendingonwhether ndandnecanberespectivelymappedintheir
M), and compute the bi-gram similarity. Intuitively, this checks
whether the changed code before and after changes is similar.
Itisworthmentioningthatourstrategyofestablishinglinksis
designedtobeheuristicandlightweightanddirectlyworkatthe
sourcecodelevel,butnotrelyonheavyweightprogramanalysis
techniques. Our assumption is that code changes are often focused,
andsuchasimplestrategyisoftensufficienttoachieveabalance
between accuracy and scalability. We leave it as our future work toinvestigatethecost-benefitofusingheavyweightprogramanalysis
techniques to establish links.
Example4.6. ForthecodechangesinFig. 1,ClDiffcorrectlyes-
tablishesallthelinkswithoutanyfalsepositiveorfalsenegative.
For example, it constructs a Override-Method links between the
addMethodDeclaration for Line 5 and the addMethodDeclaration for
Line 14. It establishes a Def-Uselink between the addVariableDecla-
rationStatementP forLine8andthe addIfStatement forLine9‚Äì11.It
buildsaSystematic-Change linkbetweenthe updateVariableDeclara-
tionforLine16,19andthe updateVariableDeclaration forLine22,25.
5 IMPLEMENTATION AND EVALUATION
We have implemented ClDiff for Java with 30K lines of Java code,
anddevelopedaweb-basedtooltovisualizeourconciselinkedcodedifferenceswith4.6KlinesofJavaScriptcode.Fig. 5givesasnapshot
of our visualization tool. A concise code difference is visualized viahighlightingthecodeandpromptingtheactionname.Aclickononeofthehighlightedcodesnippetswillpopawindowtoshowthelinks
thatarerelatedtothiscodedifference,whileaclickononeofthe
links will navigate to the corresponding code difference. ClDiff is
open-sourced and is available at [1].
684
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:52 UTC from IEEE Xplore.  Restrictions apply. ClDiff: Generating Concise Linked Code Differences ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
Table 1: Projects Used in Our Experiments
Projects Creation Date LOC Stars Commits
RxJava 2012-03 270.0K 32.6K 4226
elasticsearch 2010-02 889.2K 30.5K 29929
okhttp 2011-05 60.0K 26.3K 2784
retrofit 2010-09 22.4K 27.5K 1090
spring-framework 2008-07 673.5K 20.7K 12838
zxing 2007-10 156.0K 18.3K 1793
netty 2008-08 258.6K 13.7K 11047
fastjson 2011-07 170.0K 13.3K 2304
guava 2009-06 342.0K 23.7K 3925
glide 2012-12 73.6K 21.4K 1745
mybatis-3 2010-05 96.0K 7.4K 1189
MPAndroidChart 2014-04 26.7K 21.8K 1517
5.1 Evaluation Setup
Toevaluatetheeffectivenessof ClDiff,weconductedexperiments
using12highly-staredopen-sourceJavaprojectsfromGitHubbycom-
paringClDiffwithoneofthestate-of-the-artASTdifferencingtools,
GumTree [ 17]. Table1reports the statistics about projects, includ-
ingprojectname,creationdate,linesofcode,thenumberofstars,andthenumberofcommits.Thenumberofcommitsiscomputedbyre-
movingthecommitsthatarenotrelatedtocodechanges(e.g.changes
to configuration files) or only related to testing code changes. In
total,74,387commitsareused.Wecanseethattheseprojectsareall
large-scale and popular, and have a long evolution history. This en-suresthattheseprojectscontainrichanddiversecodechanges.Gum-
Tree was configured with the same setting as the one used in [ 17].
Ontheotherhand,toevaluatetheusefulnessof ClDiff,wecon-
ductedahumanstudywith10participantstounderstandthechanges
in 10 commits. In particular, from our school, we hired 10 graduate
students who had at least 2-years experience in Java programming.
Oneofthemhad6-yearsexperience;andtheaverageexperience
was4years.Alltheparticipantsarenottheauthorsofthispaper.
Besides, we randomlyselected 10 commits fromthose 12 projects
with the criterion that at most 6 Java source files were involved in
a commit. This is to control the complexity of understanding code
changes and thus keep the concentration of participants.
Usingtheprevioussetup,weconductedtheexperimentsandthe
human study to answer the following research questions.
‚Ä¢RQ1:Howistheaccuracyofthegeneratedconcisecodediffer-
ences and the established links by ClDiff? (Section 5.2)
‚Ä¢RQ2:Howisthesizeofthegeneratedconcisecodedifferences
of ClDiff compared to GumTree? (Section 5.3)
‚Ä¢RQ3:How is the performance overhead of ClDiff compared to
GumTree? (Section 5.4)
‚Ä¢RQ4:How is the usefulness of ClDiff in understanding code
changes compared to GumTree? (Section 5.5)
5.2 Accuracy Evaluation (RQ1)
Toevaluatetheaccuracyof ClDiff‚Äôsgeneratedconcisecodediffer-
encesandestablishedlinks,werandomlychose10commitsfrom
eachproject,andmanuallyanalyzedtheresultsof ClDiffonthem.
Table2showstheaccuracyresults,wherewealsoreportedthetotal
numberofgeneratedcodedifferencesforthe10commitsandthe
total number of established links under column Size. In total, we
analyzed 1,456 code differences, and achieved an accuracy of 99%;
and we analyzed 512 links and achieved an accuracy of 98%.Table 2: Accuracy of ClDiff
ProjectConcise Code Differences Links
Size Accuracy Size Accuracy
RxJava 99 1.00 26 1.00
elasticsearch 88 1.00 24 1.00
okhttp 88 0.98 52 0.85
retrofit 78 1.00 31 1.00
spring-framework 175 1.00 69 0.99
zxing 83 1.00 36 1.00
netty 122 0.98 42 1.00
fastjson 95 0.98 37 1.00
guava 167 0.99 54 1.00
glide 154 0.99 45 1.00
mybatis-3 129 1.00 38 1.00
MPAndroidChart 178 0.98 58 1.00
Forallthe12inaccuratecodedifferences,wefoundthatallofthem
werecausedbytheinaccuratemappinginGumTree(becauseClD-
iffusesthemappingthatisheuristicallygeneratedbyGumTree).In
detail,10ofthemwerecausedbymissedmappings,i.e.twoASTnodes
thatshouldhavebeenmappedareactuallynotmapped.Asaresult,
GumTreegeneratesa deleteandanaddactioninsteadofa moveac-
tion, making ClDiff fail to generate a moveaction as well. In addi-
tion,twoofthemwerecausedbywrongmappings,i.e.twoASTnodesthatshouldnothavebeenmappedareactuallymapped.Thus,both
GumTree and ClDiff generate a code difference that does not re-
flect the real code change, confusing the change understanding.
Amongthe512links,ourfivepre-definedlinksalloccurredex-
ceptforImplement-Method links;andaround91%ofthemwere Def-
Uselinks. We found totally 9 inaccurate links and all of them were
Def-Uselinks.Theywerecausedbyourheuristicnatureofestablish-
inglinks;e.g.whenalocalvariablesharesthesamenameasafieldinitsenclosingclass,ourapproachmightconstructwronglinks.Thishigh accuracy is surprising but still reasonable as code changes areoftenfocusedandour simplestrategy onlyanalyzesthose changed
code that contain small sources of inaccuracy.
Summary. BasedontheresultsinTable 2,wecanpositivelyan-
swerRQ1that ClDiff had a high accuracy of 99% and 98% for the
generated concise code differences and established links.
5.3 Conciseness Evaluation (RQ2)
ToanalyzewhetherClDiffgeneratesconcise(orshort)codediffer-
encescomparedtoGumTree,wemeasuredthelengthoftheedit
script(i.e.thenumberofactionsinthescript)foreachcommit.SincetheupdateactionsinClDiffsimplyputasetoffine-grainedactions
togetherbutnotrepresentacompleteactionlikeour addanddelete
actionsdo,weusedthenumberofthosefine-grainedactionsforthe
counting for our updateactions to have a fair comparison. Overall,
for90% commits,ClDiffgeneratedshorter editscripts thanGum-
Tree.Fortheremaining10%commits,ClDiffhadthesamelength
as GumTree, meaning that the fine-grained edit actions cannot be
grouped at or above the statement level.
Table3presentsthemaximumandmedianlengthforeachproject
(theminimumlengthsareomittedastheyareallone),whichshows
that ClDiff significantly shortened the edit script. Fig. 6further
shows the lengthratio of ClDiff to GumTree with respect to each
commitineachproject.Foralltheprojects,themedianratiowasaround0.2.Numerically,for48%commits,ClDiffshortenededit
scriptsbymorethan80%.Thisowestoourhigh-level addanddelete
actions,describingagroupoffine-grained addanddeleteactions.
685
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:52 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France K. Huang, B. Chen, X. Peng, D. Zhou, Y. Wang, Y. Liu and W. Zhao
Table 3: Length of Generated Code Differences
ProjectMaximum Median
GumTree ClDiff GumTree ClDiff
RxJava 56905 4727 107.5 10
elasticsearch 317867 9695 62 11
okhttp 17325 1039 79 14
retrofit 4738 360 51 8
spring-framework 102587 5972 46 9
zxing 14580 915 36 8
netty 48401 6411 38 8
fastjson 69996 1889 54 8
guava 23820 4276 46 4
glide 23592 902 59 10
mybatis-3 9592 336 31 7
MPAndroidChart 18123 2920 100 21
Average 58961 3287 59 10
Figure 6: Length Ratio of ClDiff to GumTree
Table4lists the maximum and median group size for our addand
deleteactions. These maximum cases often correspond to the addi-
tionordeletionofanentiremethoddeclaration.Themediansize
was respectively 8 and 6 for our addanddeleteactions.
Summary. BasedontheresultsinTable 3and4andFig.6,wecan
positivelyanswer RQ2thatClDiffgeneratedmorethan80%shorter
edit scripts for 48% commits than GumTree.
5.4 Performance Evaluation (RQ3)
Table5comparestheaverageperformanceoverhead(inmillisec-
onds)of ClDiffandGumTreeingeneratingcodedifferencesforthe
setofchangedsourcecodefilesineachcommit.Italsoreportstheper-formanceoverheadofeachstepinClDiff.WecanseethatClDifftook72%shortertimethanGumTree.Thereasonisthat,inClDiff,
we prune unchanged declarations in the AST pairs before applying
GumTreetogeneratefine-grainedcodedifferences,whileGumTree
directly works on raw ASTs. Besides, the second step of ClDiff is
themostexpensivestep,spending92%ofthetime.Thethirdstepis
the cheapest step, only taking 0.42 milliseconds for a commit. This
actually owes to ourheuristic-based strategy to build links, which
alsoachieveshighaccuracyasdiscussedinSection 5.2.Onaverage,
ClDiff spent 188.51 milliseconds for a commit.
Summary. BasedontheresultsinTable 5,wecanpositivelyan-
swerRQ3that ClDiff spent 72% shorter time than GumTree.
5.5 Usefulness Evaluation (RQ4)
Toevaluatetheusefulnessof ClDiff,weconductedahumanstudy
with10participantstounderstandthechangesin10commits(i.e.to
finish10tasks)withthehelpof ClDiffandGumTree.ThisstudywasTable 4: Group Size of Our addand deleteActions
ProjectMaximum Median
add delete add delete
RxJava 2540 341 8 6
elasticsearch 2832 2029 8 6
okhttp 851 179 7 5
retrofit 2631 130 7 6
spring-framework 969 1425 8 6
zxing 2797 157 7 5
netty 1955 881 7 5
fastjson 1898 511 7 6
guava 6276 6240 10 6
glide 408 213 8 6
mybatis-3 781 188 8 5
MPAndroidChart 1486 872 7 7
Average 2119 1097 8 6
Table 5: Performance Overhead of GumTree and ClDiff
Project GumTree (ms)ClDiff (ms)
Step 1 Step 2 Step 3 Total
RxJava 1987 38 41 0 79
elasticsearch 869 18 87 3 108
okhttp 379 12 18 0 30
retrofit 185 8 14 0 22
spring-framework 452 9 15 1 25
zxing 221 7 14 0 21
netty 378 9 21 0 30
fastjson 329 16 40 1 57
guava 2306 16 1763 0 1779
glide 244 11 17 0 28
mybatis-3 292 7 9 0 16
MPAndroidChart 416 22 45 0 67
Average 671.50 14.42 173.67 0.42 188.51
conductedblindly;i.e.participantsdidnotknowwhichtoolwasde-
veloped by us. We divided the participants into two groups equally.
ThefirstgroupusedClDifftounderstandthechangesforthefirst
five tasks and used GumTree for the remaining five tasks. The sec-
ondgroupusedClDiffandGumTreeinanoppositeway.Everypar-ticipantwasaskedtoanswerseveralquestionsaboutthechangesineachtask,writedownasummaryofhis/herunderstandingaboutthe
changesineachtask,andrecordthetimerequiredtofinisheach
task. Details of the 10 tasks are available at [ 1]. After they finished
all the tasks, we further asked the participants to finish a question-
naire which contained four questions with provided options.
‚Ä¢Q1:Does ClDiff do a good job?
(a) Yes, (b) Neutral, (c) No
‚Ä¢Q2:Does GumTree do a good job?
(a) Yes, (b) Neutral, (c) No
‚Ä¢Q3:Is ClDiff or GumTree more helpful?
(a) ClDiff, (b) GumTree, (c) No Difference
‚Ä¢Q4:Are ClDiff‚Äôs code differences and links helpful?
(a) Both, (b) Code Differences, (c) Links, (d) Neither
Basedonthishumanstudy,weusedthreeindicatorstocompare
ClDiffwithGumTree.Thefirstindicatorisascoretoassessthede-
greeofunderstandingthechangesineachtask.Twooftheauthorsmanuallyassignedascorebetween0and2toboththetask-specific
questionsandthesummaryofeachtaskforeachparticipant.Thusa
fullscoreis4.Astask-specificquestionshaddeterministicanswers,
0.5 was deducted for one wrong answer. The summary was scored
basedonwhethercodechangeswereunderstood.Duetothesubjec-tive nature, the two authors finalized the summary‚Äôs score through
discussion. The second indicator is the time required to finish each
task. The third is the qualitative results about the questionnaire.
686
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:52 UTC from IEEE Xplore.  Restrictions apply. ClDiff: Generating Concise Linked Code Differences ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
(a) Score of Understanding the Changes in 10 Tasks (b) Time of Understanding the Changes in 10 Tasks
Figure 7: Comparison Results of the Score and Time of Understanding the Changes in 10 Tasks
Table 6: Answers to the Questionnaire
QuestionAnswers
(a) (b) (c) (d)
Q1 10 0 0 ‚Äì
Q2 3 4 3 ‚Äì
Q3 10 0 0 ‚Äì
Q4 5 2 3 0
Fig.7showstheresultsofthetwoindicatorsscoreandtime.The
x-axisinFig. 7denoteseachtask,the y-axisinFig. 7aand7brespec-
tivelydenotetheaveragescoreofunderstandingthechangesineach
taskandtheaveragetimetofinisheachtask.Overall,theaverageto-talscoreof ClDiffandGumTreefor10taskswasrespectively34.0
and 29.6; and there was a significant difference in score between
ClDiffandGumTreeaccordingtotheWilcoxonSigned-RankTest.
Theaveragetotaltimeof ClDiffandGumTreefor10taskswas
respectively 1,539 and 1,865 seconds. However, there was no signif-icantdifferenceintimebetweenClDiffandGumTree.Specifically,
in four tasks, ClDiff took more time but had higher score; in two
tasks, ClDiff took less time but had lower score; and in four tasks,
ClDiff took less time and had higher score.
Table6reports the results of the four questions in the question-
naire.Thefirstcolumnliststhequestion,andtheotherfourcolumns
report the number of participants choosing the corresponding op-
tions.Generally,alltheparticipantfeltthatClDiffwashelpful(Q1),
andwasmorehelpfulthanGumTree(Q3 ),whilesomeparticipants
felt that GumTree was not very helpful (Q2 ). Besides, seven partic-
ipants thought that our concise code differences were helpful, and
eight participants thought that our links were helpful (Q4 ).
Summary. Based on the results in Fig. 7and Table 6,w ec a n
positivelyanswer RQ4thatClDiffwasmoreusefulthanGumTree
inunderstandingcodechangesforallparticipants;andourconcise
code differences and their links were helpful for most participants.
5.6 Discussion
Threats.Theprimarythreatstothevalidityofourexperimentsand
humanstudyaretwofold.First,weanalyzedtheaccuracyof ClDiffusingatotalnumberof120commits,whichwasnotverylarge-scale.
This is because such a manual analysis is very time-consuming, in-
volvingtheunderstandingofmapping,editscript,ASTpairsandreal
codechanges.Hence,wefollowedthesimilarworkintheliterature[
24]touse120commits.However,thesecommitsweretakenfrom12
differentprojects,andthuscanbeconsideredasrepresentativecodechanges.Second,wehired10graduatestudentstoparticipatethe
humanstudyratherthandevelopersworkingintheindustry.There-
fore,weonlyrecruitedthestudentsthathadatleast3-yearspro-
gramming experience. A further human study is required to evalu-
ate the usefulness of ClDiff in the industry.
Limitations. Onemainlimitationof ClDiffistheheuristicna-
tureofestablishinglinks,especiallyfor Def-Uselinks,asindicatedin
our accuracy evaluation (Section 5.2). We plan to investigate the
cost and benefit of using data-flow analysis to further improve the
linkaccuracy.Ontheotherhand,weonlysupportfivekindsoflinks.
We plan to further analyze the usefulness of each kind of links, ex-
tendthecapabilityofcurrentlinksandsupportmorelinkssuchthat
we can have a compact but really useful set of links.
Applications. We believe that ClDiff can be useful in various
applications. For example, by applying ClDiff to the evolution his-
toryofaprojectandchainingthesecodedifferencestogether,we
candetectlogicalcoupling[ 57]atafinergranularity.Usingstatistics
about the different kinds of code differences in each commit as fea-
tures, wecan classify commits[ 10]into bugfixing, refactoringor
upgradingbasedonmachinelearningtechniques.Byfurtherattach-
ing a semantic understanding of our generated code differences,
wecancharacterizeorevenquantifysemanticchangesforsecurity
patchorcompatibilityanalysis[ 54,56].BycombiningClDiffwith
performance analysis techniques [ 7,12,13], we can analyze perfor-
mance regressions and potentially locate their root causes.
6 RELATED WORK
We focus our discussion on the most relevant work in four aspects,
i.e. code differencing, code change summarization, code change de-
composition, and systematic code changes.
6.1 Code Differencing
Text-basedapproaches[ 44,46]arefirstproposedtocomputediffer-
ences(intheformofinserted,removedorchangedlinesofcode)
betweentwoversionsofasourcefile,followedbyseveraladvances[
4,9,50]thatfurtheridentifymovedlinesofcode.Theseapproaches
areoftenfastandlanguage-independent;however,theyfailtocom-
putesyntacticcodechanges[ 39],hinderingcodereview,automatic
analysis and tool development based on their code differences.
Tree-basedapproaches[ 17,19,21]arethenproposedtogenerate
syntactic code changes. ChangeDistiller [ 19] uses a general tree
687
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:52 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France K. Huang, B. Chen, X. Peng, D. Zhou, Y. Wang, Y. Liu and W. Zhao
differencingalgorithm[ 11]togenerateaneditscriptfromtwocoarse-
grainedASTswheretheleafnodesarecodestatements(e.g.,method
invocationsorcontrolstatements)ratherthanrawASTs.Although
being sufficient to meet its purpose of classifying certain change
types [18], ChangeDistiller is not able to distinguish updates on
statements.ThisalsoexplainswhyweusedandcomparedGumTree
but not ChangeDistiller. Diff/TS [ 21] can work on raw ASTs. It
extendsatreedifferencingalgorithm[ 58]togenerateafine-grained
editscript.AmorerecentapproachisGumTree[ 17],whichalso
worksonrawASTs.Thegoalistofindaneditscriptthatwellreflects
the developer intent based on several heuristics. Higo et al. [ 24]e x -
tendGumTreebyintroducingcopy-and-pasteasanewkindofeditactionstomakeeditscriptsshorterandmoreeasilyunderstandable.Dotzler and Philippsen [
16] propose some general optimizations to
improve the accuracy of the previous tree-based approaches in de-
tecting moved code. Most of these tree-based approaches generate
low-levelfine-grainedrepresentationsofcodechanges,whereasour
approach first computes high-level abstracted code changes and
then establishes potential links among code changes.
Besides,graph-baseddifferencingapproaches[ 3,25,48,55]arepro-
posed to deal with graph representations of source code, e.g., ex-
tendedcontrolflowgraph[ 3,25]andabstractsyntaxtree[ 48]with
programsemantics,andclassmodel[ 55]withUMLsemantics.With
thesemanticinformation,theycancapturecertainsemanticcode
changes.Further,someadvances[ 26,36]havebeenmadetoachieve
semantic differencing based on input-output behaviors. These ap-
proachesprovideuswithagoodinsightonextendingourapproach
to understand the semantics behind our syntactic code changes.
6.2 Code Change Summarization
To generate natural language descriptions of code changes, a num-
berofadvances[ 8,14,27,37,38,45,49]havebeenmadetosumma-
rizecodechanges.DeltaDoc[ 8]capturesthebehavioralchangesfor
everymethodandtheconditionsunderwhichtheyoccur.Change-Scribe[
14,37]generatesacommitmessagebyprovidingageneral
description of a commitand detailed descriptions of code changes
inthecommitbasedonpredefinedrules.Jiangetal.[ 27]andLoyola
et al. [38] adapt a neural encoder-decoder architecture to automati-
callygeneratecommitmessagesfromcodedifferences.Assoftwaredocumentsareoftenrelated,RastkarandMurphy[
49]proposeama-
chinelearning-basedtechniquetoextractdescriptionsfromasetof
relevant documents (e.g., commit messages or bug reports). Inte-grating the ideas of [
37] and [49], ARENA [ 45] summarizes code
changes at the system level and links to issues to generate release
notes.Thesechangesummarizationtechniquesaremostlydesigned
for the ease of documentation of code changes, while ClDiff gen-
erates more fine-grained code changes at the syntactic level.
6.3 Code Change Decomposition
Developersusuallycommitunrelatedorlooselyrelatedcodechanges
in a single commit, resulting in tangled changes which make code
reviewdifficultandcommit-orientedanalysisbiased.Tothisend,
Kawrykow and Robillard [ 30] detect non-essential changes (e.g.,
local variableextractions) ina commitbased onfine-grained code
change analysis. Herzig and Zeller [ 23] report the first empirical
study on the frequency and impact of tangled changes. They use amultilevel graph-partition algorithm [ 29] to decompose tangled
changesbasedonasetoffeatures.Diasetal.[ 15]improvefeatures
in[23]bynotrelyingonstaticanalysisbutconsideringfine-grained
code change informationgathered during development. Based on
improvedfeatures,theyleveragemachinelearningandclustering
todecompose tangledchanges. Barnettet al.[ 5]usedef-useinfor-
mationfromaddedorchangedcodetodecomposetangledchanges.
Tao and Kim [ 53] develop three heuristics to decompose tangled
changesintochangesforformatting,changeswithstaticdependen-
cies,andchangeswithsimilarpatterns.GuoandSong[ 20]apply
programslicingandASTsearchingtointeractivelydecomposetan-gledcodechangesforcodereviewandregressiontesting.Theseap-proachesinspireustoexplicitlyestablishlinksamongcodechanges.
6.4 Systematic Code Changes
Systematic code changes (i.e., similar, related code changes) can be
caused by crosscutting concerns [ 31], API evolution [ 22,28], recur-
ring bug fixes[ 47] orrefactoring [ 35]. Kim etal. [ 33] firstidentify
such systematic code changes at the method signature level and
representthemaslogicrules.Then,Kimetal.[ 32,34]extend[ 33]to
describechangeswithinamethodbodyandatafieldlevel.Recently,Zhang et al. [
59] propose an interactive approach to allow develop-
erstocustomizeageneratedchangetemplateandtomatchthetem-
plate to summarize systematic changes and locate potential incon-
sistent or missing changes. Given a systematic code change, McIn-
tyre and Walker [ 40] discover locations where this change should
be applied(if anyexist); andMeng etal. [41, 42] furtherautomati-
callyapplythischangetothediscoveredlocationswithdifferent
contexts.Differentfromtheseapproachesthatfocusonaspecific
kind of code changes (i.e. systematic code changes), our approach
focusesonabroaderrangeofcodechanges.Further,weplantouse
them to improve the construction of Systematic-Change links.
7 CONCLUSIONS
In this paper, we have proposed and implemented a code differenc-
ingapproach,namedClDiff,togenerateconciselinkedcodediffer-ences.ClDiff‚Äôsgoalistogeneratemoreeasilyunderstandablecode
differences.Takingasinputsasetofsourcecodefilesbeforeand
afterchanges,ClDiffworksinthreesteps.First,itpre-processes
source code files to prune unchanged declarations from parsed ab-
stractsyntaxtrees.Second,itgroupsfine-grainedcodedifferencesat
orabovethestatementlevelandgeneratesaconcisecodedifference
tocapturehigh-levelchangesineachgroup.Third,itlinksthere-
lated concise code differences based on five pre-defined links. Our
experiments with 12 open-source Java projects and a human study
with 10 participants have demonstrated the accuracy, conciseness,
performance and usefulness of ClDiff.
ACKNOWLEDGMENTS
This work was supported by the National Key Research and Devel-
opmentProgramofChinaunderGrantNo.2016YFB1000801andthe
ShanghaiScienceandTechnologyDevelopmentFunds(16JC1400801),
and was partially supported by the National Research Foundation,
Prime Ministers Office, Singapore under its National Cybersecurity
R&D Program (Award No. NRF2016NCR-NCR002-026) and admin-
istered by the National Cybersecurity R&D Directorate.
688
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:52 UTC from IEEE Xplore.  Restrictions apply. ClDiff: Generating Concise Linked Code Differences ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
REFERENCES
[1] 2018. CLDIFF. https://github.com/FudanSELab/CLDIFF.
[2]GeorgeWAdamsonandJillianBoreham.1974. Theuseofanassociationmeasure
based on character structure to identify semantically related pairs of words and
document titles. Information storage and retrieval 10, 7-8 (1974), 253‚Äì260.
[3]TaweesupApiwattanapong,AlessandroOrso,andMaryJeanHarrold.2004. A
Differencing Algorithm for Object-Oriented Programs. In Proceedings of the 19th
IEEE International Conference on Automated Software Engineering. 2‚Äì13.
[4]MuhammadAsaduzzaman,ChanchalKRoy,KevinASchneider,andMassimiliano
DiPenta.2013. LHDiff:Alanguage-independenthybridapproachfortracking
source code lines. In Proceedings of the 29th IEEE International Conference on
Software Maintenance. 230‚Äì239.
[5]MikeBarnett,ChristianBird,Jo√£oBrunet,andShuvenduK.Lahiri.2015. Helping
DevelopersHelpThemselves:AutomaticDecompositionofCodeReviewChange-
sets. InProceedings of the 37th International Conference on Software Engineering -
Volume 1. 134‚Äì144.
[6]TobiasBaum,KurtSchneider,andAlbertoBacchelli.2017. OntheOptimalOrder
of Reading Source Code Changes for Review. In Proceedings of the 2017 IEEE
International Conference on Software Maintenance and Evolution. 329‚Äì340.
[7]Marc Br√ºnink and David S. Rosenblum. 2016. Mining Performance Specifica-
tions. InProceedings of the 2016 24th ACM SIGSOFT International Symposium on
Foundations of Software Engineering. 39‚Äì49.
[8]Raymond PL Buse and Westley R Weimer. 2010. Automatically documentingprogram changes. In Proceedings of the IEEE/ACM international conference on
Automated software engineering. 33‚Äì42.
[9]Gerardo Canfora, Luigi Cerulo, and Massimiliano Di Penta. 2009. Tracking your
changes: A language-independent approach. IEEE Software 26, 1 (2009), 50‚Äì57.
[10]CaseyCasalnuovo,YagnikSuchak,BaishakhiRay,andCindyRubio-Gonz√°lez.
2017. GitcProc:atoolforprocessingandclassifyingGitHubcommits.In Proceed-
ingsofthe26thACMSIGSOFT InternationalSymposiumonSoftwareTestingand
Analysis. 396‚Äì399.
[11]Sudarshan S. Chawathe, Anand Rajaraman, Hector Garcia-Molina, and Jennifer
Widom. 1996. Change Detection in Hierarchically Structured Information. In
Proceedings ofthe1996ACMSIGMODInternational ConferenceonManagementof
Data. 493‚Äì504.
[12]BihuanChen,YangLiu,andWeiLe.2016. GeneratingPerformanceDistributions
via Probabilistic Symbolic Execution. In Proceedings of the 38th International
Conference on Software Engineering. 49‚Äì60.
[13]ZhifeiChen,BihuanChen,LuXiao,XiaoWang,LinChen,YangLiu,andBaowen
Xu. 2018. Speedoo: Prioritizing Performance Optimization Opportunities. In
Proceedings of the 40th International Conference on Software Engineering. 811‚Äì
821.
[14]Luis Fernando Cort√©s-Coy, Mario Linares-V√°squez, Jairo Aponte, and Denys
Poshyvanyk. 2014. On Automatically Generating Commit Messages via Summa-
rizationofSourceCodeChanges.In Proceedingsofthe2014IEEE14thInternational
Working Conference on Source Code Analysis and Manipulation. 275‚Äì284.
[15]Mart√≠n Dias, Alberto Bacchelli, Georgios Gousios, Damien Cassou, and St√©phane
Ducasse. 2015. Untangling fine-grained code changes. In Proceedings of the IEEE
22ndInternational Conferenceon SoftwareAnalysis,Evolution andReengineering.
341‚Äì350.
[16]Georg Dotzler and Michael Philippsen. 2016. Move-optimized Source Code Tree
Differencing. In Proceedings of the 31st IEEE/ACM International Conference on
Automated Software Engineering. 660‚Äì671.
[17]Jean-R√©my Falleri, Flor√©al Morandat, Xavier Blanc, Matias Martinez, and Martin
Monperrus.2014. Fine-grainedandAccurateSourceCodeDifferencing.In Pro-
ceedingsofthe29thACM/IEEEInternationalConferenceonAutomatedSoftware
Engineering. 313‚Äì324.
[18]Beat Fluri and Harald C. Gall. 2006. Classifying Change Types for Qualifying
Change Couplings. In Proceedings of the 14th IEEE International Conference on
Program Comprehension. 35‚Äì45.
[19]Beat Fluri, Michael Wuersch, Martin PInzger, and Harald Gall. 2007. Change
distilling: Tree differencing for fine-grained source code change extraction. IEEE
Transactions on software engineering 33, 11 (2007), 725‚Äì743.
[20]Bo Guo and Myoungkyu Song. 2017. Interactively Decomposing Composite
Changes toSupport CodeReview andRegression Testing. In Proceedingsof the
IEEE 41st Annual Computer Software and Applications Conference. 118‚Äì127.
[21]MasatomoHashimotoandAkiraMori.2008. Diff/TS:AToolforFine-Grained
Structural Change Analysis. In Proceedings of the 2008 15th Working Conference
on Reverse Engineering. 279‚Äì288.
[22]JohannesHenkelandAmerDiwan.2005. CatchUp!:CapturingandReplaying
RefactoringstoSupportAPIEvolution.In Proceedingsofthe27thInternational
Conference on Software Engineering. 274‚Äì283.
[23]Kim Herzig and Andreas Zeller. 2013. The Impact of Tangled Code Changes.InProceedings of the 10th Working Conference on Mining Software Repositories.
121‚Äì130.
[24]Yoshiki Higo, Akio Ohtani, and Shinji Kusumoto. 2017. Generating Simpler AST
EditScriptsbyConsideringCopy-and-paste.In Proceedingsofthe32NdIEEE/ACMInternational Conference on Automated Software Engineering. 532‚Äì542.
[25]Susan Horwitz. 1990. Identifying the Semantic and Textual Differences Between
Two Versions of a Program. In Proceedings of the ACM SIGPLAN 1990 Conference
on Programming Language Design and Implementation. 234‚Äì245.
[26]Daniel Jackson and David A Ladd. 1994. Semantic Diff: A Tool for Summarizing
the Effects of Modifications. In Proceedings of the International Conference on
Software Maintenance. 243‚Äì252.
[27]Siyuan Jiang, Ameer Armaly, and Collin McMillan. 2017. Automatically generat-
ing commit messages from diffs using neural machine translation. In Proceedings
ofthe32ndIEEE/ACMInternationalConferenceonAutomatedSoftwareEngineering .
135‚Äì146.
[28]Puneet Kapur, Brad Cossette, and Robert J. Walker. 2010. Refactoring References
for Library Migration. In Proceedings of the ACM International Conference on
Object Oriented Programming Systems Languages and Applications. 726‚Äì738.
[29]GeorgeKarypisandVipinKumar.1995. Analysisofmultilevelgraphpartitioning.
InProceedings of the IEEE/ACM Conference on Supercomputing. 29‚Äì29.
[30]David Kawrykow and Martin P. Robillard. 2011. Non-essential Changes in
Version Histories. In Proceedings of the 33rd International Conference on Software
Engineering. 351‚Äì360.
[31]GregorKiczales,JohnLamping,AnuragMendhekar,ChrisMaeda,CristinaLopes,
Jean-Marc Loingtier, and John Irwin. 1997. Aspect-oriented programming. In
Proceedings of the 11th European Conference on Object-Oriented Programming.
220‚Äì242.
[32]MiryungKimandDavidNotkin.2009. DiscoveringandRepresentingSystematic
Code Changes. In Proceedings of the 31st International Conference on Software
Engineering. 309‚Äì319.
[33]MiryungKim,David Notkin,andDanGrossman. 2007. AutomaticInferenceof
Structural Changes for Matching Across Program Versions. In Proceedings of the
29th International Conference on Software Engineering. 333‚Äì343.
[34]MiryungKim,DavidNotkin,DanGrossman,andGaryWilsonJr.2013.IdentifyingandSummarizingSystematicCodeChangesviaRuleInference. IEEETransactions
on Software Engineering 39, 1 (2013), 45‚Äì62.
[35]Miryung Kim, Vibha Sazawal, David Notkin, and Gail Murphy. 2005. An Em-
pirical Study of Code Clone Genealogies. In Proceedings of the 10th European
Software Engineering Conference Held Jointly with 13th ACM SIGSOFT Interna-
tional Symposium on Foundations of Software Engineering. 187‚Äì196.
[36]ShuvenduK.Lahiri,ChrisHawblitzel,MingKawaguchi,andHenriqueReb√™lo.
2012.SYMDIFF:ALanguage-agnosticSemanticDiffToolforImperativePrograms.
InProceedingsofthe24thInternationalConferenceonComputerAidedVerification.
712‚Äì717.
[37]Mario Linares-V√°squez, Luis Fernando Cort√©s-Coy, Jairo Aponte, and Denys
Poshyvanyk.2015. Changescribe:Atoolforautomaticallygeneratingcommit
messages.In Proceedingsofthe2015IEEE/ACM37thIEEEInternationalConference
on Software Engineering. 709‚Äì712.
[38]Pablo Loyola, Edison Marrese-Taylor, and Yutaka Matsuo. 2017. A Neural Archi-
tectureforGeneratingNaturalLanguageDescriptionsfromSourceCodeChanges.
InProceedings of the 55th Annual Meeting of the Association for Computational
Linguistics (Volume 2: Short Papers). 287‚Äì292.
[39]JonathanIMaleticandMichaelLCollard.2004.Supportingsourcecodedifference
analysis. In Proceedings of the 20th IEEE International Conference on Software
Maintenance. 210‚Äì219.
[40]Mark M McIntyre and Robert J Walker. 2007. Assisting potentially-repetitive
small-scalechangesviasemi-automatedheuristicsearch.In Proceedingsofthe
22nd IEEE/ACM International Conference on Automated Software Engineering.
497‚Äì500.
[41]Na Meng, Miryung Kim, and Kathryn S. McKinley. 2011. Systematic Editing:
GeneratingProgramTransformationsfromanExample.In Proceedingsofthe32Nd
ACMSIGPLANConferenceonProgrammingLanguageDesignandImplementation.
329‚Äì342.
[42]Na Meng, Miryung Kim, and Kathryn S. McKinley. 2013. LASE: Locating and
ApplyingSystematicEditsbyLearningfromExamples.In Proceedingsofthe2013
International Conference on Software Engineering. 502‚Äì511.
[43]T.Mens.2002. AState-of-the-ArtSurveyonSoftwareMerging. IEEETransactions
on Software Engineering 28, 5 (2002), 449‚Äì462.
[44]WebbMillerandEugeneWMyers.1985. Afilecomparisonprogram. Software:
Practice and Experience 15, 11 (1985), 1025‚Äì1040.
[45]Laura Moreno, Gabriele Bavota, Massimiliano Di Penta, Rocco Oliveto, Andrian
Marcus, and Gerardo Canfora. 2017. ARENA: an approach for the automated
generation of release notes. IEEE Transactions on Software Engineering 43, 2
(2017), 106‚Äì127.
[46]Eugene W Myers. 1986. An O(ND) difference algorithm and its variations. Algo-
rithmica1, 1-4 (1986), 251‚Äì266.
[47]Tung Thanh Nguyen, Hoan Anh Nguyen, Nam H. Pham, Jafar Al-Kofahi, and
Tien N. Nguyen. 2010. Recurring Bug Fixes in Object-oriented Programs. In Pro-
ceedings of the 32Nd ACM/IEEE International Conference on Software Engineering.
315‚Äì324.
[48]Shruti Raghavan, Rosanne Rohana, David Leon, Andy Podgurski, and Vinay
Augustine.2004. Dex:ASemantic-GraphDifferencingToolforStudyingChanges
689
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:52 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France K. Huang, B. Chen, X. Peng, D. Zhou, Y. Wang, Y. Liu and W. Zhao
in Large Code Bases. In Proceedings of the 20th IEEE International Conference on
Software Maintenance. 188‚Äì197.
[49]SarahRastkarandGailCMurphy.2013.Whydidthiscodechange?.In Proceedings
of the 2013 International Conference on Software Engineering. 1193‚Äì1196.
[50]Steven P. Reiss. 2008. Tracking Source Locations. In Proceedings of the 30th
International Conference on Software Engineering. 11‚Äì20.
[51]Gregg Rothermel and Mary Jean Harrold. 1996. Analyzing regression test selec-
tion techniques. IEEE Transactions on software engineering 22, 8 (1996), 529‚Äì551.
[52]Yida Tao, Yingnong Dang, Tao Xie, Dongmei Zhang, and Sunghun Kim. 2012.
How Do Software Engineers Understand Code Changes?: An Exploratory Study
in Industry. In Proceedings of the ACM SIGSOFT 20th International Symposium on
the Foundations of Software Engineering. 51:1‚Äì51:11.
[53]Yida Tao and Sunghun Kim. 2015. Partitioning Composite Code Changes to
Facilitate Code Review. In Proceedings of the 12th Working Conference on Mining
Software Repositories. 180‚Äì190.
[54]Lili Wei, Yepang Liu, and Shing-Chi Cheung. 2016. Taming Android fragmen-
tation: Characterizing and detecting compatibility issues for Android apps. In
Proceedingsofthe31stIEEE/ACMInternationalConferenceonAutomatedSoftwareEngineering. 226‚Äì237.
[55]Zhenchang Xing and Eleni Stroulia. 2005. UMLDiff: An Algorithm for Object-
oriented Design Differencing. In Proceedings of the 20th IEEE/ACM International
Conference on Automated Software Engineering. 54‚Äì65.
[56]ZhengziXu,BihuanChen,MahinthanChandramohan,YangLiu,andFuSong.
2017. SPAIN: security patch analysis for binaries towards understanding the
pain and pills. In Proceedings of the 39th International Conference on Software
Engineering. 462‚Äì472.
[57]Annie T. T. Ying, Gail C. Murphy, Raymond Ng, and Mark C. Chu-Carroll. 2004.
PredictingSourceCodeChangesbyMiningChangeHistory. IEEETransactions
on Software Engineering 30, 9 (2004), 574‚Äì586.
[58] K. Zhang and D. Shasha. 1989. Simple Fast Algorithms for the Editing Distance
Between Trees and Related Problems. SIAM J. Comput. 18, 6 (1989), 1245‚Äì1262.
[59]TianyiZhang,MyoungkyuSong,JosephPinedo,andMiryungKim.2015. Interac-
tiveCodeReviewforSystematicChanges.In Proceedingsofthe37thInternational
Conference on Software Engineering - Volume 1. 111‚Äì122.
690
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:52 UTC from IEEE Xplore.  Restrictions apply. 