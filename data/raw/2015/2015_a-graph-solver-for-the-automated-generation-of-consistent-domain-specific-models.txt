A Graph Solver for the Automated Generation of
Consistent Domain-Specific Models
Oszkár Semeráth1,2, András Szabolcs Nagy1,2and Dániel Varró3,1,2
1MTA-BME Lendület Cyber-Physical Systems Research Group, Hungary
2Budapest University of Technology and Economics, Department of Measurement and Information Systems, Hungary
3McGill University, Canada
semerath@mit.bme.hu,nagya@mit.bme.hu,varro@mit.bme.hu
ABSTRACT
Manytestingandbenchmarkingscenariosinsoftwareandsystems
engineering depend on the systematic generation of graph models.
For instance, tool qualification necessitated by safety standards
would require a large set of consistent (well-formed or malformed)
instance models specific to a domain. However, automatically gen-
erating consistentgraph modelswhich comply witha metamodel
and satisfy all well-formedness constraints of industrial domains is
asignificantchallenge.Existingsolutionswhichmapgraphmodels
intofirst-orderlogicspecificationtouseback-endlogicsolvers(like
AlloyorZ3)haveseverescalabilityissues.Inthepaper,wepropose
agraphsolverframeworkfortheautomatedgenerationofconsis-
tent domain-specific instance models which operates directly over
graphsbycombiningadvancedtechniquessuchasrefinementof
partialmodels,shapeanalysis,incrementalgraphqueryevaluation,and rule-baseddesign spaceexplorationto providea more efficient
guidance. Our initial performance evaluation carried out in four
domainsdemonstratesthatourapproachisabletogeneratemodels
whichare1-2ordersofmagnitudelarger(with500to6000objects!)
compared to mapping-based approaches natively using Alloy.
ACM Reference Format:
OszkárSemeráth1,2,AndrásSzabolcsNagy1,2andDánielVarró3,1,2.2018.A
Graph Solver for the Automated Generation of Consistent Domain-Specific
Models.In ProceedingsofICSE’18:40thInternationalConferenceonSoftware
Engineering , Gothenburg, Sweden, May 27-June 3, 2018 (ICSE ’18), 12 pages.
https://doi.org/10.1145/3180155.3180186
ACKNOWLEDGMENTS
This paper is partially supported by MTA-BME Lendület Cyber-
Physical Systems Research Group, the NSERC RGPIN-04573-16
projectandtheUNKP-17-3-IIINewNationalExcellenceProgramof
theMinistryofHumanCapacities.WearegratefulforAlexandra
Sólyom and Gábor Szárnyas for preliminary experiments in using
design space exploration for model generation and all contributors
to past model generators of query and transformation benchmarks.
Permission to make digital or hard copies of part or all of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthefirstpage.Copyrightsforthird-partycomponentsofthisworkmustbehonored.
For all other uses, contact the owner/author(s).
ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
© 2018 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-5638-1/18/05.
https://doi.org/10.1145/3180155.31801861 INTRODUCTION
Motivation. The automated generation of graph models has re-
cently become a key approach in variousapplication areas of soft-
wareandsystemsengineering.Representingobjectsandpointersas
graphs in object-oriented programs, automatically generated mod-
elsmayserveascomplexteststubs[ 1,2].Auto-generatedgraphs
help the testing and benchmarking of graph databases [ 3] since
obtainingrealgraphsfrombusinessusecasesisoftendifficultto
duetoprotectionofintellectualpropertyrights.Automatedsynthe-
sis of prototypical test contexts [ 4] aims to systematically derive
previously unanticipated contexts in the form of graph models for
the assurance of smart cyber-physical systems (CPS).
Similarly,inmanydesignandverificationtoolsusedforengineer-
ingcomplexCPSs,systemmodelsarealsorepresentedinternally
asgraphs,andmodelgeneratorsmaybeusedforvalidating,test-
ingorbenchmarkingsuchdesigntools[ 5–8].Asamainpractical
motivation for this scenario, while tool qualification of design and
verification tools are necessitated by safety standards (like DO-
178C[9],orISO26262[ 10]),toolqualificationisextremelycostly
due to the lack of effective best practices for validating the toolsthemselves. Considering tool qualification as a long-term objec-
tive, our approach will be illustrated in the context of an industrial
domain-specificmodelingtool(YakinduStatecharts),butitcould
be adapted to many other practical scenarios above.
In [11], four desirable properties are stated as key challenges
forgraphmodelgeneratorsusedinsuchscenarios.Asetofauto-
generated graphs should ideally be (1) consistent , i.e. each graph
should satisfy all well-formedness (WF) constraints, (2) diverse,
i.e. each pairs of graphs should be structurally distant from each
other, (3) scalable, i.e. the size of models are exponentially growing,
and (4)realistic, i.e. auto-generated graphs cannot be distinguished
from real models created by engineers by using advanced graph
metrics[3,12,13].Forinstance,characteristics(1,2)areessential
inafunctionaltesting scenario,whileproperties(3,4)arecrucial
for benchmarking and stress testing.
However, real models created by engineers are dominantly con-
sistent(see[ 11]forastatisticalanalysis)accordingtothecorrect-
by-constructionprinciple(e.g.commitsaredisallowedwhentest
cases fail or constraints are violated). Similarly, auto-generated
graphsviolatingasingleWFconstraintbutsatisfyingalltheothersarefrequentlynecessitatedfortestingpurposes.Moreover,random
generation of graphs is unable to guarantee consistency, i.e. many
WFconstraintswillbeviolated.Thisway,the synthesisofconsistent
graphs is a prerequisite of both realistic and diverse graph models .
Problem Statement. This paper aims to automatically gener-
ate well-formed graph models of a specification defined by (1) a
9692018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:56:19 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Oszkár Semeráth, András Szabolcs Nagy and Dániel Varró
metamodel (graph schema), (2) a set of well-formedness (WF) con-
straints expressed in first-order graph logic with transitive closure
andoptionally(3)aninitialmodelfragment.Existingapproaches
like [14–20] map the instance generation problem of consistent
graph models into logic solvers such as Alloy [ 21,22], SMT-solvers
[23],SAT-solversorconstraintsolverswhentheefficiencyofgraph
model generation depends on the scalability and performance ofback-end logic solvers, which primarily excel in finding inconsis-
tenciesincomplexspecifications .However,thegenerationmodels
as a side-effect of the proof construction is much less efficient.
Infact,thesesolversguaranteeneitherscalability[ 24]nordiver-
sity[25]whentheyneedtogeneratewell-formedgraphinstancesof
aspecification–regardlessofhowsmartthemappingisfromahigh-
levelgraphmodeltotheunderlyinglogicsolver.Fromapractical
perspective, while the specification of complex industrial modelingtoolsmaycontainhundredsofclasses(intheirmetamodel)andWF
constraints, no existing model generation technique could derive a
consistent graph that contains at least one object from each class.
Contribution. Weproposeanovelautomaticgenerationtech-
nique to derive consistent domain-specific graph models for speci-
fications by exploiting and innovatively combining a multitude ofadvanced graph-based and core SAT-solving techniques.
(1)
We formulate model generation as a refinement of partial
models[26,27] where initial abstract model fragments are
gradually refined and concretized during exploration.
(2)Weprovide partialmodelrefinementrules asdecisionandunit
propagation steps by following core SAT-solving techniques.
(3)We use incremental graph query evaluation of the VIATRA
engine [28] to efficiently evaluate violations of constraints
over partial models during model generation [27].
(4)We integrate shape analysis as state encoding [29–31] for
graphstoefficientlydetectiftwopartialmodelsshouldbe
treated as equivalent during exploration.
(5)We exploit rule-based design space exploration [ 32]t odrive
the generation process directly over graph shapes using an ob-
jective function approximating the distance from a solution.
(6)Weevaluate the scalability of our approach using 6 tests sets
of four domains (including industrial DSLs) and compare its
performance with the well-known Alloy Analyzer [21].
AddedValue. To our best knowledge, our framework is one of
thefirstattemptstoautomaticallygenerateconsistentmodelsby
operating natively over (typed and attributed) graphs. Moreover,
according to our scalability experiments, it is capable of generating
consistent graph models of 1-2 orders of magnitude larger (with 500-
6000nodes)comparedtomodelsderivedbyAlloyandthegenerated
modelsuiteisalsomorediverse[ 24].Assuch,ourgraphsolvercan
serve as a back-end where Alloy was used previously for model
generation purposes in testing and benchmarking scenarios.
2 MODELING PRELIMINARIES
Ourmodelgenerationtechniquewillbeillustratedbyautomatically
generating test inputs for Yakindu Statecharts Tools [ 33], which
is an industrial integrated modeling framework for developing
reactive,event-drivensystems.First,wegiveabriefintroductionto
theformaldefinitionofpartialmodelsusingathree-valuedlogic,
which will drive the automated generation of consistent models.2.1 Metamodels
Adomain-specific(modeling)language(DSL)istypicallydefinedby
ametamodel and a set of well-formedness constraints . A metamodel
defines the main concepts and relations in a domain, and specifies
thebasicgraphstructureofthemodels,andWFconstraintsfurther
restrict valid models of the language by defining additional design
rules. In this paper, the Eclipse Modeling Framework (EMF) [ 34]i s
used for domain modeling, which is a de facto industrial standard.
Pseudostate
Vertex
 Region
 Transition
Statechart
 Entry
 Synchronization
 State
RegularState
 CompositeElement[0..*] vertices
[0..*] re gions[1..1] tar get [0..*] incomin gTransitions[0..1] source [0..*] out goingTransitions
Figure 1: Metamodel of Yakindu statecharts
Example 2.1. A metamodel extracted from Yakindu is illustrated
inFigure1.A Statechart consistsof Regions,whichinturncontain
Vertexesand Transition s.Anabstractstate Vertexisfurtherrefined
into RegularState s (like State) and PseudoState s like Entryand
Synchronization states. The source and target states of a transition
are identified by the sourceandtargetreferences.
ToreasonabouttheconsistencyofDSLs,aformalalgebraicspec-
ification is frequently created [ 19,27,35–38]. We briefly revisit the
notationof[ 27]toprovideaprecisebackgroundforourmodelgen-
erationapproach(butforspaceconsideration,weomitthedetailed
handling of attributes, which could be introduced accordingly).
Formally, a metamodel defines a vocabulary Σ={C1,..., Cn,
exist,R1,..., Rm,∼}withunarypredicatesymbols Ci(1≤i≤n)
definedforeach EClass,andbinarypredicatesymbols Rj(1≤j≤
m) for each EReference . To represent abstract (partial) models, a
unaryexistpredicate is introduced to denote the existence of an
objectinagivenmodel,while ∼denotesanequivalencerelation
over objects.
2.2 Partial Models
Partial models (PM) were introduced in [ 35,38] to represent un-
certain (possible) elements in instance models where one partialmodel represents a range of possible instance models. In this pa-
per,3-valuedlogic[ 39]isusedtoexplicitlyrepresentunspecified
orunknownpropertiesofmodelswithathird1/2truthvalue(be-
sides 1 and 0 which stand for trueandfalse) in accordance with
[11,27,31].Apartialmodel isrepresentedasa3-valuedlogicstruc-
tureP=/angbracketleftObjP,IP/angbracketrightofΣ,whereObjPisthefinitesetofindividuals
in the model (i.e. the objects), and IPprovides a 3-valued interpre-
tation for all constants in Idand predicate symbols in Σ.
TypePredicates. IPisa3-valuedinterpretationofeachclasssym-
bolCiinΣ:IP(Ci):ObjP→{1,0,1/2}:1 ,0a n d1/2means that it is
true, false or unspecified if an object is an instance of a class Ci.
Reference Predicates. IPgives a 3-valued interpretation to each
referencesymbol RjinΣ:IP(Rj):ObjP×ObjP→{1,0,1/2},where
970
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:56:19 UTC from IEEE Xplore.  Restrictions apply. A Graph Solver for the Automated Generation of Consistent Domain-Specific Models ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Figure 2: Sample partial models with uncertain elements and their refinement
1, 0 and1/2means that it is true, false or unspecified if there is a
reference Rjbetween two objects.
Existence Predicate. IPgives a 3-valued interpretation for the
existence predicate IP(exist):ObjP→{1,0,1/2}, where 1 values
representanobjectthatmustbe,1/2valuerepresentsobjectsthat
may be included in a model.
Equivalence Predicate. IPgives a 3-valued interpretation to the
∼relation between the objects IP(∼):ObjP×ObjP→{1,0,1/2}.
An uncertain1/2value relation between two objects means that
thoseobjectmaybeequalandcanpotentiallybemerged.Onthe
other hand, uncertain equivalence of a single object (with itself)
implies that it may represent multiple separate objects.
Example2.2. FourpartialmodelsareillustratedinFigure2.Asa
notation guide, (1) the truth value of a type predicate is denoted by
labels on nodes, where missing labels are treated as 0 values, while
(2)reference predicate values 1 and1/2are represented by edges
with solid and dashed lines (respectively), while missing edges
betweentwoobjectsrepresent0valuesforapredicate,(3) existence
predicate values1and1/2arerepresentedbynodeswithsolidand
dashed borders, respectively, while objects with 0 existence values
aresimplynotdepicted.Finally,(4)uncertain1/2equivalencesare
marked by dashed line with an ∼symbol. Otherwise, each node
representsasingle,uniqueobject(i.e.forallobject o:[[o∼o]]=1
and for all different objects o1ando2:[[o1∼o2]]=0).
InP0(on the left side of Figure 2), object ris of type Regionbut
not of type State:[[Region(r)]]P0=1 and[[State(r)]]P0=0. In case
ofobjectnew,alltypepredicateare1/2,whichmeansthattheobject
may represent any type ofobjects. In P0there is a certain vertices
reference between randsandrande, and a possible reference
betweenrandneworasaself-loopof new.Nodesr,eandsrepresent
objectsthatmustexist,and newrepresentpossibleobjectswhich
may exist or they might be removed later from the model. Node
newmayalsorepresentmultipleobjects(notetheself-loopedge ∼),
which can later be refined into multiple distinct model elements.
2.3 Refinement and Concretization of PMs
Duringmodelgeneration,thelevelofuncertaintywillgraduallybe
reducedby refinements derivingpartialmodelsthatrepresentmore
concrete instance models. In a refinement step, properties with1/2
valuescanberefinedtoeither0or1whichimposesaninformation
orderingrelation X/subsetsqequalYwhereeither X=1/2andYisrefinedto1or0,orvaluesof XandYremainequal: X/subsetsqequalY:=(X=1/2)∨(X=Y).
A refinement is defined as a function ref:ObjP→2ObjQwhich
maps each object of a partial model Pto a set of objects in the
refined partial model Q. A refinement respects the information
orderingoftype,reference,equivalenceandexistencepredicates
for eachp1,p2∈ObjPandq1∈ref(p1),q2∈ref(p2):
•for each class Ci:[[Ci(p1)]]P/subsetsqequal[ [Ci(q1)]]Q.
•for each reference Rj:[[Rj(p1,p2)]]P/subsetsqequal[ [Rj(q1,q2)]]Q
•[ [p1∼p2]]P/subsetsqequal[ [q1∼q2]]Q
•[ [exist(p1)]]P/subsetsqequal[ [exist(q1)]]Q, and if[[exist(p)]]P=1 then
ref(p)is not empty
Refinement from partial model PtoQis denoted by P/subsetsqequalQ.
Ifa3-valuedpartialmodel Ponlycontains1and0values,and
thereareno ∼relationsbetweendifferentobjects(i.e.allequivalent
nodesaremerged),then Prepresentsatraditional instancemodel .
Aconcretization defines a trivial refinement to a 2-valued fully
definedconcretemodelbyrewritingall1/2type,referenceandexist
predicatesvaluesto0,andrewritingall1/2equivalencepredicateto
0 between different objects, and to1 on the same object.
Example2.3. Figure2illustratestworefinementstepsfrom P0
toP2.InP1objectnewissplitintotwodifferentobjects: newand
tofP1,where[[new∼new]]P0=1/2isrefinedto [[new∼t]]P1=0,
[[t∼t]]P1=1and[[new∼new]]P1=1/2.Additionally, [[exist(new)]]P0
=1/2is refined to [[exist(t)]]P1=1, and[[Transition (new)]]P0=1/2
is refined to [[Transition (t)]]P1=1, thus creating a new Transition
objectt, while all other1/2type predicates are refined to 0. Finally,
sourcepredicates are refined to 1 with eas target, and to 0 with all
other objects as target.
InstepP1toP2,possible targetpredicatesare refinedto1with
sastargetobject,andto0with eandnewastargetobjects.Note
that refinement step P1/subsetsqequalP2will illustrate the decision rule while
P2/subsetsqequalP3will illustrate the unit propagation rule later in section 3.1.
P3is a concretization of P2, which is also a refinement P2/subsetsqequalP3.
2.4 Defining constraints over PMs
In many industrial modeling tools, domain-specific WF constraints
arecapturedeitherbystandardOCLconstraints[ 40]orbygraph
patterns(GP)[ 28,41].Agraphpatterncapturescomplexstructural
conditionsoveraninstancemodel.Inordertohaveaunifiedand
971
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:56:19 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Oszkár Semeráth, András Szabolcs Nagy and Dániel Varró
[[C(v)]]P
Z:=IP(C)(Z(v))
[[R(v1,v2)]]P
Z:=IP(R)(Z(v1),Z(v2))
[[exist(v)]]P
Z:=IP(exist)(Z(v))
[[v1∼v2]]P
Z:=IP(∼)(Z(v1),Z(v2))
[[φ1∧φ2]]P
Z:=min([[φ1]]P
Z,[[φ2]]P
Z)
[[φ1∨φ2]]P
Z:=max([[φ1]]P
Z,[[φ2]]P
Z)
[[¬φ]]P
Z:=1−[ [φ]]P
Z
[[∃v:φ]]P
Z:=max{[[exist(x)∧φ]]P
Z,v/mapsto→x:x∈ObjP}
[[∀v:φ]]P
Z:=min{[[¬exist(x)∨φ]]P
Z,v/mapsto→x:x∈ObjP}
[[φ+(v1,v2)]]P
Z:=[[φ(v1,v2)∨(∃m:φ(v1,m)∧φ+(m,v2))]]P
Z
Figure 3: Semantics of graph logic expressions
semantically precise handling of evaluating graph patterns con-
straintsforregularandpartialmodels,weuseafirst-ordergraph
logic formalism with transitive closure that covers the key features
of several concrete graph pattern languages. This semantics was
introduced in [27] being influenced by [31].
Syntax.A graph pattern is a first order logic predicate with
transitive closure φ(v1,...,vn)over (object) variables. A graph
predicate φcan be inductively constructed by using object variable
symbols ( v1,v2,...), atomic predicates ( C(v),R(v1,v2),v1∼v2),
standardlogicconnectives( ¬,∨,∧),logicquantifiers( ∃and∀),and
transitive closure over binary predicates denoted as φ+(v1,v2).
Semantics. Apredicate φ(v1,...,vn)canbeevaluatedonpar-
tial model Palong a variable binding Z, which is a mapping Z:
{v1,...,vn}→ObjPfrom variables to objects in M. The truth
value ofφcan be evaluated over a partial model PandZ(denoted
by[[φ(v1,...,vn)]]P
Z)inaccordancewiththesemanticrulesdefined
in Figure 3. Note that minandmaxtakes the numeric minimum
andmaximumvaluesof0,1/2and1,andtherulesfollow3-valued
interpretationofstandardlogicformulaeasdefinedin[ 27,31].A
variablebinding Zwherethepredicate φisevaluatedto1over Pis
called apattern match , formally [[φ]]P
Z=1.
Graphpredicatesarefrequentlyusedfordefiningcomplexstruc-
tural WF constraints and validation rules [ 28]. In such a case, a
predicate match denotes a constraint violation , thus the correspond-
ing graph formula needs to capture the erroneous cases, and a
match detect a violation of a WF constraint. Therefore, a set of WF
predicates {φWF
1,...,φWFn}defines a theorem of valid models T,
whereT={¬φWF
1,...,¬φWFn}. WF predicates of Tare derived
fromtwosources:themetamodeldefinesthebasicstructure,and
additional validation constraints of a domain can be defined by
using OCL [40] or graph patterns [28].
Therearestructuralconstraintsimposedbytheunderlyinggraph
representation. In case of EMF metamodels, such constraints in-
clude (1)Type Hierarchy (TH) which expresses that a more specific
(child)classhaseverystructuralfeatureofthemoregeneral(parent)
class,(2)TypeCompliance(TC) thatrequiresthatforanyrelation
R(o,t), its source and target objects oandtneed to have compliant
types, (3) Abstract (ABS) : If a class is defined as abstract, it is not
allowedtohavedirectinstances,(4) Multiplicity(MUL) ofstructural
features can be limited with upper and lower bound in the form
of “lower..upper” and (5) Inverse (INV) , which states that two paral-
lel referencesof oppositedirection always occurin pairs.FinallynoOutgoing (e):=
Entry(e)∧¬∃t1,t2,e1,s:
source(t1,e1)∧target(t2,s)
∧e∼e1∧t1∼t2
Figure 4: Sample statechart WF constraint as graph query
instance models in EMF are expected to be arranged into a (6) Con-
tainment (CON) hierarchy, which is a directed tree along relations
marked in the metamodel as containment (e.g. regionsorvertices).
Since a formalization of these structural restrictions as WF con-
straintsisprovidedin[ 19],thegraphpredicatelanguageofFigure3
can uniformly be used for both kinds of structural constraints.
Example 2.4. The Yakindu documentation states several con-
straints forstatecharts thatcan beformalized asgraph predicates
[24].Forinstance,constraint noOutgoing (e)inFigure4(depictedas
agraphpatternandagraphpredicate)detectsanentrystate ewith-
out an outgoing transition. The explicit use of equality constraints
e∼e1andt1∼t2isresponsibleforperforminganaturaljoinop-
eration over the edges as predicates. As a result, the same formula
can be evaluated with both 2-valued and 3-valued interpretation.
2.5 Approximating constraints over PMs
WhileWFconstraintscanbedirectlyevaluatedonconcreteinstance
models,checkingthecorrectnessofapartialmodelisachallenging
task, because one partial model may represent multiple concretiza-
tions.Aconstraint φcanbeevaluatedonapartialmodel Pusingthe
3-valued logic and open-world semantics by a constraint rewriting
technique [27] which over- and under-approximates the results:
•Under-Approximation :I f[[φ]]P=1 in a partial model P,
then[[φ]]Q=1 in any partial model QwhereP/subsetsqequalQ.
•Over-Approximation If[[φ]]Q=1 in a partial model Q,
then[[φ]]P≥1/2in a partial model PwhereP/subsetsqequalQ.
Usingtheseproperties,wedefineamonotonousderivationse-
quence of valid partial models which (1) starts from the most ab-
stractpartialmodelwhereallconstraintsareevaluatedto1/2,which
partial model (2) is gradually refined into more and more concrete
partial models (with less number of predicates evaluating to1/2).
Refinement steps are continued until a concretized graph model
ofadesignatedscopeeventuallysatisfiesallWFconstraintswith
2-valuedinterpretation.Duringtheserefinementsteps,specialcare
needs to be taken to handle two situations:
•False negatives arepartialmodels Pwhichdonotviolate
an under-approximated (must) constraint, i.e. [[φ]]P≤1/2,
buttheycanneverbeconcretizedintoavalidinstancemodel
with[[φ]]Q=0whereP/subsetsqequalQ.Thesesequencesaredeadends,
and ideally, they should be detected as early as possible.
•False positives are partial models Pwhich violate an over-
approximated (may) constraint, i.e. [[φ]]P≥1/2, but they
can be further refined into partial model [[φ]]Q=0 where
P/subsetsqequalQ.Thesesequencesmightbepostponedduringmodel
generation,buttheymayeventuallyleadtoaconcretemodel
that satisfies all WF constraints, thus they should be kept.
972
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:56:19 UTC from IEEE Xplore.  Restrictions apply. A Graph Solver for the Automated Generation of Consistent Domain-Specific Models ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Ourgraphgenerationapproachwillderiveinstancemodelsalong
refinements.Assuch,partialmodelswillgraduallybecomemore
andmoreconcreteaftereachrefinementstepwhichimpliesthat
checking WF constraints on partial models also becomes more
precise.Thepracticalbenefitcomparedtoconsecutivecallstoback-
end solvers [ 24] is that the complex model finding problem can be
divided into a sequence of small decisions while WF constraints
can be checked (approximately) on intermediate solutions.
3 AUTOMATED GRAPH GENERATION
In this paper, we propose a general and automated graph model
generationapproachwhichtakesadomainspecifiedby( I1)av o-
cabulary Σdefinedby a metamodel,and ( I2) atheorem Tdefined
by a set of well-formedness constraints {¬φWF
1,...,¬φWFn}, and
(I3)asearchscope(i.e.minimalandmaximalnumberofnodesin
a solution graph) and ( O) generates a consistent (valid) concrete
graph model G|=Tas output.
The model generation framework gradually refines partial mod-
elsbyrule-baseddesignspaceexploration(DSE)[ 32]intoawell-
formedinstancemodelwhichcompliestothemetamodelandallWF
constraints are satisfied, if such a concrete model exists within the
given search scope. During exploration, our framework simultane-
ouslyoperateson(concrete)instancemodelsandWFconstraintsas
well as (abstract) partial models and approximated WF constraints
introducedinsection2byapplyingrefinementrules. Refinement
rulesare defined as graph transformation rules [ 27,42] manipulat-
ing directly over partial models with 3-valued interpretations by
concertizing a single atomic uncertain1/2value in each step.
Refinementrulesaregroupedintotwocategories:(1) Decision
rulesarederivedfrom Σtoreducethenumberof valid concretiza-
tions of a partial model (i.e. new information is added) while (2)
Unit propagation rules are derived from Tto propagate the con-
sequences of previous decisions in order to simplify a solution
candidate without excluding potential solutions.
Modelgenerationisinitiatedfroman initialpartialmodel pro-
videdasinputbyanengineer,orfromthe mostabstractpartialmodel
whereallpredicatesareunknown,i.e.(1)thereisasingle(abstract)
objectObjP={new};(2)exist(new)=1/2andnew∼new=1/2thus
this object may represent multiple possible objects of the concrete
models;(3)forallclasspredicate Ci:Ci(new)=1/2;and(4)forall
reference predicates Rj:Rj(new,new)=1/2.
3.1 Decision Rules
Decision rules (see Figure 5) define various refinements to con-
cretizeinformationinpartialmodelstoconstructpossiblesolutions.
Theyarederivedfromthevocabulary Σofthemetamodel,where
each predicate symbol CiandRjrepresents a ClassandReference.
Ingeneral,decisionrulesareresponsiblefor(1)introducingnew
objects by splitting the abstract newobject or (2) rewriting an1/2
value to 1 as detailed by (the scheme of) four decision rule classes.
•Rule addRoot( C)selects a non-abstract class C(see the pre-
conditioninthelefthandside)ifnootherrootshavebeen
created (denoted by NEG) to ensure that the model has a
singleroot(asrequiredbyEMF).Itseffect(prescribedbythe
right hand side) is to split the initial newobject by creating
an e wrootas an instance of C, which acts as a root elementfor the containment hierarchy and all self-loop references
onneware extended to both objects.
•Rule addChild( CP,RC,CC)selectsanexisting parentobject
of type CP, thenewobject with a non-abstract type CC,
andacontainmentreference RCfromparenttonew.Upon
execution, it splits newinto a new object childof type CC
connected to parentviaRC, thus unfolding a new object
along the containment hierarchy. During the unfolding step,
all outgoing Ri, incoming Rjand loop Rkreferences of new
are extended (copied) to child.
•Finally,tworules addType( C)andaddReference( R)refineun-
certain1/2classes and references in the partial model. In the
latter case,the rulerequires that thetypes ofthe endpoints
are already fixed appropriately.
Example3.1. Therefinementstep P0/subsetsqequalP1inFigure2introduces
a new object tby applying the decision rule addChild (of Figure 5),
which changes1/2values of transition (t)andsource(t,e)to 1.
3.2 Unit Propagation Rules
Unit propagation rules are responsible for refining unspecified ele-
mentsin apartial model withoutexcluding anyvalidsolution to
simplify the partial model propagating the consequences of pre-
viouslyapplieddecisionrules.Unitpropagationrulesareapplied
repeatedlyrightafteradecisionruleisapplied.Theyarederived
from the structural constraints (1)-(6) introduced in section 2.4. In
general,unitpropagationrulesrewrite1/2elementsto0(or1)ifa
1(or0)valuewouldcontradicttoaconstraint.Figure6illustrates
(the scheme of) unit propagation rules used in this paper.
•Typehierarchy(TH) ismaintainedbytworules: propTH+(C,Cs)
propagates a positive (1) type predicate of Cto a supertype
Cs;propTH−(C/prime,C)rewrites a1/2type predicate value to 0
for type Cif the object already has an incompatible type C/prime
where CandC/primedo not have a common subclass (all classes
are considered to be subclasses of themselves).
•Typecompliance(TC) ischeckedbytworules: propTCFrom(C,R)
andpropTCTo(R,C).Bothrulesremovepossiblereferences
if the types of the reference end-points are incompatible.
•Rule propMULUpper(R)checksthe uppermultiplicity(MUL)
of a reference, and removes all possible additional links if
the upper limit is reached.
•TheInverse (INV) structural constraint is checked two rules:
propINV+(R,RI)andpropINV−(R,RI)whichseta Rpredicate
value to 1 or 0 if an inverse RIvalue is already set.
•To ensure Containment hierarchy (CON) , first decision rules
enforce that each non-root object has a parent. Then, ad-
ditional possible incoming containment references are re-
moved by unit propagation rule propCON2Parent(R,RC).
Finally, propCONLoop(R)removes possible reference predi-
cates that would create a loop in the containment hierarchy.
Decisionandunitpropagationrulesareincloseanalogywiththe
DLL62algorithmoftraditionalSAT-solvers[ 43]:valuesofvariables
are graph elements in our case (instead of Boolean values), com-
plex graph predicates are evaluated (instead of conjunctive normal
formulae),andthestatespaceofgraphsneedstobecontinuously
stored during exploration (instead of a search tree).
973
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:56:19 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Oszkár Semeráth, András Szabolcs Nagy and Dániel Varró
addRoot( C)
C: non-abstract
copy all Rj
new 
C≥½otherNEG
Rj
 ~ root 
C=1
new 
C≥½Rj
Rj
Rj
 ~ RjaddChild( CP,RC,CC)
CC: non-abstract,
RC: containment from CPtoCC
copy all RiandRjaddType( C)
C: non-abstract
o 
C=½o C=1addReference( R)
R: non-containment
Figure 5: Decision rules for graph model generation
propTH+(C,Cs)
CS: supertype of CpropTH−(C/prime,C)
C/primeandChas
has no common
non-abstract subtypepropTCFrom(C,R)
Ris from CpropTCTo(R,C)
Ris to CpropMULUpper(R)
Ris to C
propINV+(R,RI)
Ris inverse of RIpropINV−(R,RI)
Ris inverse of RIpropCON2Parent(R,RC)
RandRC: containmentspropCONLoop(R)
R: containment
Figure 6: Unit propagation rules for graph model generation
Example3.2. Refinementstep P1/subsetsqequalP2isaresultofa decisionrule
addChild tosetthe1/2valueof target(t,s)to1followedbya unit
propagationrule propMULUpper(target )whichaimstopreventthe
partial model from violating an upper multiplicity constraint by
setting1/2values of target(t,e)andtarget(t,new)to 0 as a direct
consequence of the previous decision rule.
Asapreprocessingstep,decisionandpropagationrulesarede-
rived.Moreover, under-approximated(must)predicates aresynthe-
sized from graph predicates in accordance with [ 27] to detect unre-
solvable WF constraints early in a partial solution.
3.3 Exploration
Duringexploration(seeFigure7),refinementrulesarerepeatedly
applieddrivenbyanobjectivefunctionandaruleselectionstrategy.
Assuch,thesizeofpartialmodelsiscontinuouslygrowinguptothe
designatedscope,whilethenumberofuncertaintiesandconstraint
violations in these partial models are decreasing to ensure that the
process convergesto consistent instancemodels. Now wediscuss
the steps of the model generation process.(1)After initializing the search with an initial partial model,
anunexploreddecisionruleisselectedandapplied toderiveanew
(refined)partialmodelalongapartialmodelrefinementstep(sec-
tion 2.3). The role of these refinement rules is in direct analogy
with the decision steps in SAT solvers.
(2)Afterexecutingadecisionrule,ourframework executesall
possibleunitpropagationrulesonthepartialsolution topropagate
theconsequenceofthedecision,thusfurtherrefiningthepartial
model. This step is again in direct analogy with SAT solvers, but it
is carried out by incremental, change-driven model transformation
rules [44] to improve efficiency.
(3)To prevent traversing the same (graph) state twice, a state
codeis calculated and stored for the new partial model by using
graphisomorphismchecksover graphshapes [30].Graphshapes
abstract from node identities, but they efficiently identify if two
graphs can be distinguished by the neighborhood (i.e. incoming
and outgoing edges) of a node.
(4)Hadthenewstatebeenalreadyexplored,thepartialmodel
is dropped and a new refinement rule is applied (1).
974
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:56:19 UTC from IEEE Xplore.  Restrictions apply. A Graph Solver for the Automated Generation of Consistent Domain-Specific Models ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Figure 7: Exploration strategy for automated model generation
(5)Ifanewpartialmodelisreached,thenourframework checks
if it satisfies all under-approximated (must) constraints by partial
evaluation of these constraints [ 27] using an incremental graph
query engine [ 28]. If an under-approximated constraint is violated
by the partial model then an inconsistency is detected, thus thepartial model can never be refined into a well-formed instance
model so it can be dropped (1).
(6)Nextthepartialmodelis concretizedintoaninstancemodel by
removingalluncertaintiesandalltheoriginalWFconstraintsare
checkedonthiscandidatemodelbytheincrementalgraphquery
engine to detect inconsistencies. If no violations are found, then
the instance model is stored as a solution, and the exploration may
terminate(ifdesignatedmodelscopeisreached)orcontinuetofind
other solutions (1). Note that checking the original WF constraints
on a concretized model guarantees the correctness of our solver.
(7)Finally, our framework approximates the distance for a solu-
tionby an objective function, adds the current partial model to the
exploration path and continues refinement from with new unex-
ploreddecisionrefinement.Foreachpartialmodel,thisobjective
functioniscalculatedasthesumofconstraintviolationsandthe
number of missing objects wrt. a designated size.
For selecting the next match where a decision rule is to be ap-
plied, we use a combined exploration strategy with best-first search
heuristic, backtracking ,backjumping andrandomrestarts inanad-
vanceddesignspaceexplorationframework[ 32].Thesearchselects
the best candidate wrt. the objective function, then it randomly
fires (with uniform distribution) an enabled decision rule, subse-quently, it fires all possible unit propagation rules. If no further
decision rules can be applied, then it backtracks to continue along
the previous partial model candidate. At each step, the exploration
may backjump to the best model candidate found so far during
theexploration.Finally,thesearchisoccasionallyrestartedfrom
a randomly chosen intermediate model candidate. Such a random
restartisacommontechniqueinSAT-solverstoavoidlocaloptima.
Our framework operates directly over graph models and the
explorationitselfisdrivenonsuchahigh-level.Thus,it combines
the advantages of multiple advanced graph-based techniques with
core SAT-solving techniques to tackle the scalability problems of
existing mapping-based approaches:
•The approximated and the original of WF constraints are
efficiently evaluated over partial models (in (5)and(6.B))
using incremental graph query evaluation techniques [28].
•Refinementrulesaredividedintodecision (1)andunitpropa-
gationrules (2)asfacilitatedbycoreSAT-solvingalgorithms.
•Isomorphic states are detected during exploration (3)by
combining shape analysis techniques [30, 31].
•Ourframeworkhasfullcontroloverthegraphgeneration
process(1,7)via rule-based DSE techniques [32].3.4 Soundness and Completeness
Starting from the abstract initial model, our decision rules guaran-
tee thecompleteness of graph model generation [11], i.e. any con-
crete graph can possibly be derived within a bounded scope: Rule
addRoot can derive any root objects, addChild is responsible for
deriving new elements along the containment tree, addType can
assign any types to an object while addReference can build any
graphsbyaddingedges.However,efficientstrategiesareneededto
initiate the execution of decision rules in proper order.
Thesoundnessofgraphmodelgeneration isguaranteedbycheck-
ing all WF constraints on each generated candidate graph instance.
AssuchweobtainatleastthesameguaranteeasprovidedbyAlloy,
namely, if a consistent graph model exists within a given scope
then our approach will derive it.
Ifnowell-formedmodelsarefoundwithinagivenscopethen
Alloy provides no further details (stating that the problem maybe
inconsistent).Incontrast,ifthesearchisterminatedinourapproach
with no valid refinements (i.e. all branches of the state space are
closed)thenthespecificationis surelyinconsistent.Thisisprimarily
ensured by the fact thatif an under-approximated predicate φhas
amatchinapartialsolutionitcannotberefinedtoavalidmodel.
Furthermore,weguaranteethatanywell-formedmodel(ofalarger
scope) can only be derived by refining existing partial models at
the edge of the search horizon, i.e. our approach can incrementally
continue exploration for a larger scope.
3.5 Strengths and Limitations
Our approach operates on connected sparse graphs with edges as
relations (i.e. no edge identities and no parallel edges of a type) as
underlying data model, which is less expressive than full relational
algebraincaseofAlloy.Asacurrenttechnicallimitation,ourgraph
generationapproachisshowcasedforEMFmetamodelsandmodels,
which are widely used in industrial modeling tools, but it could be
easily adapted to other graph formalisms. The expressive power of
graphpredicatesusedforcapturingWFconstraintsisequivalent
to first order logic with transitive closure over binary predicates.
Our solver efficiently handles complex structural graph con-
straints defined in first order logic with transitive closure. How-
ever,it includesonly enumerationsas attributevalues butexcludes
strings, integers, etc. Such attribute values could be handled in
the future by calling external solvers (e.g. SMT-solvers) during the
exploration or as a post-processing step.
Whilethedecisionprocedureofourgraphsolverprovidesstronger
completeness guarantees than Alloy within a bounded scope, it
doesnotprovideanunsatisfiablecore(i.e.minimalcontradictory
setofformulae)tohighlightcontradictionbetweenWFconstraints,
which is supported by many SAT and SMT-solvers.
975
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:56:19 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Oszkár Semeráth, András Szabolcs Nagy and Dániel Varró
4 EXPERIMENTAL EVALUATION
Wecarriedoutanexperimentalevaluationofgeneratingconsistent
instance models to address the following research questions:
RQ1How does our graph solver scale (in time and model size)
when generating consistent models of increasing size?
RQ2Howdoesourapproachscale(intimeandmodelsize)com-
pared to the widely used model finder Alloy [21]?
RQ3Howdothedifferentstepsoftheexplorationinfluenceper-
formance of the graph solver?
Selected DSLs for evaluation. AsmodelgenerationforDSLs
still lacks systematically constructed performance benchmarks, we
evaluatedourapproachinthecontextof6testsetsoffourdiffer-
entdomains.First(1)asmallFileSystem( FS)examplewastaken
from the Alloy documentation [ 45].Ecore, the meta-metamodeling
languageofEMF[ 34],hasbeenusedasacasestudybydifferentap-
proaches [ 14,16,19,24,46,47] using Alloy as a background solver
for model generation purposes. Our measurements also cover two
DSLsthatweredevelopedinindustrialprojects,namely,(3) Yakindu
[33] and (4) Functional Architecture Model ( FAM) developed for
avionics [ 48]. Due to their complexity, domains (3) and (4) are
split into two cases: we generate models first with only general
metamodel constraints ( w/o WF), and then in the presence of extra
WF constraints ( with WF). In addition to their direct practical rele-
vance, theseDSLs have alreadybeen used inthe context ofmodel
generation in numerous papers [19, 24, 49] in the past.
Benchmarkingsetup. Tomeasurescalability,wesetupatime-
out of 3 minutes for each model generation run with increasing
model size. For each measurement point, model generation was ex-
ecuted 30 times and the medianof the runs were taken.To account
for warm-up effects and memory handling of the Java 8 virtualmachine, we added an extra 20 runs before the actual measure-
ments and called the garbage collector explicitly between runs. As
a baseline of comparison, Alloy Analyzer V4.2 (the latest stable
version available at the Alloy download site) was used with two
underlyingSATsolverlibraries:Sat4J(defaultinAlloy)andMin-iSAT(recommendedbyAlloy).Allmeasurementswereexecuted
on an average desktop computer1with 12 GB heap size.
Experimentalresults. ForRQ1weevaluatetheexecutiontime
ofourapproachforthefourdomainsbyincreasingthetargetmodel
size from 50 to 500 objects (with a step size of 50 new objects), and
measuring(inFigure8a–Figure8d)thetotalexecutiontime.Asa
keyobservation,ourapproachisabletogenerateconsistentmodels
with 500 elements for all four domains within 10 seconds for FAM
and FS, within 40 seconds for Ecore and 3 minutes for Yakindu. As
astresstest,wealsomanaged togenerate evenlarger consistent
models(1000objectsforYakindu,7000objectsforFAM,4750objectsforFSand2000objectsforEcore,seeFigure8k)in20minutes(asa
median of 10 measurements).
ForRQ2,wecomparemodelgenerationtimeofourGraphSolver
withAlloyforsmallmodelsizes(from5to50objects,stepsizeof5
newobjects)forthe6testcases.Asabaseline,weuseastate-of-the-
artEMF-to-Alloymappingtechnique[ 16,19,24,46,47]andtoolto
obtainAlloyspecificationsfortheYakindu,FAMandEcoredomains,andtheoriginalAlloyspecificationisusedforFS.Accordingtothe
1CPU: Intel Core-i5-m310M, MEM: 16GB, OS: Windows 10 Pro.results (see Figure 8e–8j and Figure 8k), our approach scales much
betterasitgeneratesmodels1-2ordersofmagnitudelargerthan
Alloy could handle regardless of the back-end SAT solver which
only had little impact on scalability. This is in line with previous
measurementsforAlloyin[ 19,24]).Alloydominantlyranoutof
memory when mapping input specification into a SAT problem
whichresultsinover6millionvariablesandseveralmillionclauses
when aiming to generate a model with 40-90 objects.
NotethattheAlloyAnalyzerisnotprimarilytargetedtogenerate
models but to check the consistency of a relational specification
within a given scope and synthesize small counterexamples. In
fact,Alloyhadasmallerruntimeforverysmallmodels,thusthe
warm-up cost of our graph solver is higher. However, our graph
solver is able to generate much larger graph models even for all
four domains with similar consistency guarantees as Alloy.
ForRQ3, we also measured (in Figure 8a–Figure 8d) how much
time is spent in the different phases of model generation by our
graphsolver(seeFigure7)suchasinitialization,partialmodelre-
finement, state encoding and exploration. The preprocessing phase
(1.5secondsforFS,4secondsforEcore,2secondsforFAMand4
secondsforYakindu)isaone-timepenaltywhichisisproportional
tothecomplexityofthemetamodelandtheWFconstraints,thus
we expect it to be negligible for model generation incase of other
domains. Refinement is the dominant phase in the Yakindu and FS
cases, while state encoding is dominant for Ecore. These results
show that future research should primarily improve on refinement
by providing a better transformation engine or refinement rules.
Quality of generated models. The quality of the generated
modelscanbeinvestigatedfromdifferentaspects.Toensure cor-
rectness, all WF constraints were checked on each generated graph
instancebyusinganexternaltool,theVIATRAgraphqueryengine
[50]. To assess diversitywhen a sequence of models are generated
by the proposed graph solver (within similar scope), each model
is guaranteed tobe non-isomorphic by the statecodes (Step (4)in
Figure 7) or by a distance metric [ 51] in case of repeated calls to
the solver, which offers increased diversity compared to Alloy [ 51].
Systematically assessing the realisticnature of models is a more
complex task [ 13] which necessitates to obtain a large set of real
models authored by engineers. Our graph solver ensures that only
enumeration values can be isolated nodes in a graph otherwise all
graphs are connected by default, i.e. all regular nodes are arranged
into a containment hierarchy. In order to assure connectedness,
Alloy requires an extra constraint to capture this concept, thus
by default, our solution appears to be more realistic. In addition,[
11,13] contain an in-depth investigation of realistic models for
the Yakindu domain. All generated models are available at [52].
Threatstovalidity. Inordertostrengthen internalvalidity ,our
experimentsincludeanextensivewarm-upphasepriortotheactualmeasurementstodecreasethefluctuationofruntimeresultscaused
bytheJVM(instead ofthenaturalfluctuationofsolverruntimes).
We used default setups for running Alloy and our graph solver, i.e.
no extra hints and performance optimizations were provided inthe two approaches. Domain-specific fine tunings may improve
scalability in some cases but it would simultaneously decrease the
general-purpose nature of these solvers.
Toaddress externalvalidity ,ourmeasurementscover6testcases
including3industrialdomains(Ecore,Yakindu,FAM)with complex
976
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:56:19 UTC from IEEE Xplore.  Restrictions apply. A Graph Solver for the Automated Generation of Consistent Domain-Specific Models ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
0510
50
100
150
200
250
300
350
400
450500Runtime (s)
Model Size (#Objects)
Initia lisation Refinement
State Coding Exploration
(a) Graph Solver: FAM050100150200
50
100
150
200
250
300
350
400
450
500Runtime (s)
Model Size (#Objects)
Initialisation Refinement
State Coding Exploration
(b) Graph Solver: Yakindu0510
50
100
150
200
250300
350
400
450
500Runtime (s)
Model Size (#Objects)
Initialisation Refinement
State Coding Exploration
(c) Graph Solver: FS010203040
50
100
150
200
250
300
350
400
450
500Runtime (s)
Model Size (#Objects)
Initia lisation Refinement
State Coding Exploration
(d) Graph Solver: Ecore
01020
51 0 1520 25 30 35 40 4550Runtime (s)
Model Size (#Objects)
Graph Solver Alloy+Sat4j
Alloy+MiniSat
(e) Comparison: FAM w/o WF02040
51 0 152 02 53 03 54 0 4550Runtime (s)
Model Size (#Objects)
Graph Solver Alloy+Sat4j
Alloy+MiniSat
(f) Comparison: FAM with WF01020
510 15 2 025 30 35 40 4550Runtime (s)
Model Size (#Objects)
Graph Solver Alloy+Sat4j
Alloy+MiniSat
(g) Comparison: Yakindu w/o WF01020
51 0 152 02 53 03 54 0 4550Runtime (s)
Model Size (#Objects)
Graph Solver Alloy+Sat4j
Alloy+MiniSat
(h)Comparison:YakinduwithWF
0510
510 15 20 25 30 35 40 45 50Runtime (s)
Model Size (#Objects)
Graph Solver Alloy+Sat4j
Alloy+MiniSat
(i) Comparison: FS with WF02040
5 1 01 52 02 53 03 54 04 55 0Runtime (s)
Model Size (#Objects)
Graph Solver Alloy+Sat4 j
Alloy+Minisat
(j) Comparison: Ecore with WFProblem size Largest model (#Objects)
#Class #Ref#WF. Graph Solver Sat4JMiniSat
FAM+WF 91523 6250 5861
FAM-WF 91515 7000 8792
Yak+WF 10625 1000 ––
Yak-WF 1065 7250 8690
FS 447 4750 8789
Ecore 193324 2000 3841
(k) Comp.: Maximal model
Figure 8: Runtime comparison with increasing model size and distribution of generation time
structural WF constraints , thus our experimental scalability results
for our graph solver are likely generalizable to other domains of
similar size and complexity within the limitations of section 3.5. In
caseofsimpleWFconstraints,thedifferencebetweentheperfor-
mancecharacteristicsofAlloyandourgraphsolvermaybesmaller.
SincetheperformanceofAlloydependsonthebackendSAT-solver,
our measurements already included two state-of-the-art solvers
(SAT4JandMiniSAT).Thusthelargescalabilitydifferenceinthe
sizeofgeneratedmodelscanlikelybeattributedtoourgraphsolver.
Summary. Ourgraphsolverprovidesastrongplatformforgen-
eratingconsistentgraphmodelswhichare1-2ordersofmagnitude
larger (with similar or higher quality) than derived by mapping
basedapproachesusingAlloywithanunderlyingSAT-solver.Such
adifferenceinscalabilitycanonlypartlybededicatedtoourcon-
ceptually different approach which combines several advanced
graph techniques to improve performance instead of fine-tuning a
mapping.However,itlikelyindicatesfundamentalshortcomings
of existing mapping based approaches. Based on in-depth profil-ing we suspect that representing each potential edge between apair of nodes as a separate Boolean variable blows up the state
spaceforsparsegraphwithonlylinearnumberofedges.Moreover,SAT-solvershavemajorproblemsinevaluatingcomplexpredicates
overlargergraphmodels[ 11]wheregraphqueryevaluationwas
particularly efficient [28].LogicUncertain Rule-Iterative Symbolic
Solvers Models BasedInputsPartial Snapshot + ++ -+ -
Local Constraints + -++ +
Global Constraints + - -+ +OutputsMetamodel + + ++ +
Well-formed + - -+ +
Scalable - -+++/- -
Decidability - + +- +/-
Table 1: Comparison of related approaches
5 RELATED WORK
Wecompareoursolutionwithexistingmodelgenerationtechniques
with respect to the characteristics of inputsandoutput results in
Table 1. As for inputs, the model generation can be (1) initiated
from apartial snapshot . Additionally, an approach may support (2)
localand (3)global constraints as WF constraints: a local constraint
accessesonlytheattributesandtheoutgoingreferencesofanobject,
while a global constraint specifies a complex structural pattern.
Local constraints are frequently attached to objects (e.g. in UML
classdiagrams),whileglobalconstraintsarewidelyusedinDSLs.As
outputs, the generated models may (i) be metamodel-compliant (ii)
satisfy all well-formedness constraints of the language. We consider
atechnique(iv) scalableifthereisnohardlimitonthemodelsize(as
demonstratedintherespectivepapers).Finally,amodelgeneration
977
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:56:19 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Oszkár Semeráth, András Szabolcs Nagy and Dániel Varró
approach may be (v) decidable which always terminates with a
result. Our comparison excludes approaches like which do not
guarantee metamodel- compliance of generated instance models.
Logic Solver Approaches. Several approaches map a model
generation problem into a logic problem, which is solved by un-
derlying SAT/SMT-solvers. Complete frameworks with standalone
specification languages include Formula [ 35] (which uses Z3 SMT-
solver [23]), Alloy [ 36] (which relies on SAT solvers like Sat4j[ 53])
and Clafer [20] (using backend reasoners like Alloy).
There are several approaches aiming to validate standardized
engineering models enriched with OCL constraints [ 54] by relying
upon different back-end logic-based approaches such as constraint
logicprogramming[ 17,37,55],SAT-basedmodelfinders(likeAlloy)
[14,16,19,24,46,47,56], CSP solvers [ 49] first-order logic [ 57],
constructive query containment [ 58], higher-order logic [ 59,60],
or rewriting logics [61]. Partial snapshots and WF constraints can
be uniformly represented as constraints [ 19]. Growing models are
supported in [15, 24] for a limited set of constraints.
Scalabilityofalltheseapproachesarelimitedtosmallmodels/
counter-examples.Furthermore,theseapproachesareeitherapriori
bounded (where the search space needs to be restricted explicitly)
ortheyhavedecidabilityissues.Asourapproachisindependent
fromtheactualmappingofconstraintstologicformulae,itcould
potentially be integrated with most of the above techniques by
complementing or replacing the back-end solvers.
UncertainModels. Partialmodelsaresimilartouncertainmod-
els,whichofferarichspecificationlanguage[ 38,62]amenableto
analysis.Theyamoreuser-friendlylanguagecomparedto3-valued
interpretations, but without handling additional WF constraints.
Potentialconcretemodelscompliantwith anuncertainmodelcan
be synthesized by the Alloy Analyzer [ 63], or refined by graph
transformation rules [ 26]. Each concrete model is derived in a sin-
gle step, thus their approach is not iterative like ours. Scalability
analysis is omitted from these papers, but refinement of uncertain
models is always decidable, thus termination is guaranteed.
Approacheslike[ 64]analyzepossiblematchesandexecutionsof
modeltransformationrulesonpartialmodelsbyusingaSATsolver
(MathSAT4)orbyautomatedgraphapproximation(referredtoas
“lifting”), or by graph query engines with [ 27]. As a key difference,
ourapproachcarriesoutmodelrefinementwhilesimultaneously
evaluating graph query evaluation in an automated process.
Rule-based Instance Generators. A different class of model
generators relies on rule-based synthesis driven by randomized,
statistical or metamodel coverage information for testing purposes
[65–67].Someapproachessupportthecalculationofeffectivemeta-
models [68], but partial snapshots are excluded from input specifi-
cations.Moreover,WFconstraintsarerestrictedtolocalconstraints
evaluatedonindividualobjectswhileglobalconstraintsofaDSL
arenotsupported.Onthepositiveside,theseapproachesguarantee
the diversity of models and scale well in practice [67, 69].
Iterative Approaches. Iterative approaches generate models
by multiple solver calls. In [ 24] models are generated in by calling
Alloyinmultiplesteps,whereeachstepextendstheinstancemodel
bya fewelements.This approachscaledupto 50objectin 45sfor
generating valid Yakindu Statecharts. An iterative approach is pro-
posedspecifically for allocation problems in [70] based on Formula.
Modelsaregeneratedintwostepstoincreasediversityofresultsbyfirstcreatingnon-isomorphicsubmodelsfromaneffectivemeta-
modelfragmentfollowedbyaproblem-specificsymmetry-breaking
predicate [ 71] to ensures that no isomorphic models are generated
twice whileconstraint checksare postponed tothe very finalstage.
An iterative, counter-example guided synthesis is proposed for
higher-order logic formulae in [ 22], but the size of derived models
is fixed and smaller than 50 objects.
Symbolic Model Generation Technique Certaintechniques
use abstract (or symbolic) graphs for analysis purposes. A tableau-
based reasoning method is proposed for graph properties [ 72–74],
which automatically refine solutions based on well-formedness
constraints, and handle state space in the form of a resolution tree.
As a key difference, our approach refines possible solutions in the
formofpartialmodels,while[ 72,73]resolvesthegraphconstraints
to a concrete solution. Therefore our approach is able to exploitefficient graphquery enginesto evaluate partialsolutions, while
those techniques are demonstrated on small ( <10 objects) graphs
or with no scalability evaluation at all.
Additionally, different approaches use abstract interpretation
[29,30], or predicate abstraction [ 31] for partial modeling. In those
approaches,concretizationisusedtomaterialize(typicallysmall)
counter-examples for designated safety properties in a graph trans-
formation system. However, their focus is to support model check-
ingofabstractgraphtransformationsystems,whichcanevaluate
complex trajectories, but do not scale in the size of the models.
6 CONCLUSION AND FUTURE WORK
Wepresentedanovelgraphsolvertogenerateconsistentmodels
of adesignated size from aspecification definedby a metamodeland a set of WF constraints. Unlike existing approaches which
map the model generation problem to logic solvers (dominantly
SAT or SMT-solvers), we address the model generation problem of
consistentinstancesdirectlyovergraphsbycombiningadvanced
graph-basedtechniqueswithcoreSAT-solvingrules.Ourapproach
is fully automated and available as an open source tool [52].
Our experimental evaluation carried out over three industrial
domains confirmed that our solver is able to synthesize consistent
graph models with over 500-6000 objects with similar quality guar-
anteesasprovidedbythepopularrelationalmodelfinderAlloy.The
scalabilityofoursolveris1-2ordersofmagnitudebetterthanex-
isting mapping based approaches using Alloy with a SAT-solver in
the background. Such a difference in scalability likely indicates not
onlythebenefitsofourapproachbutalsotheinherentproblemsof
mapping based model generation approaches deriving and solving
a SAT problem. Thus our solver can serve as the output of map-pings that previously used Alloy for model generation purposes.
Altogether, our technique has the potential to be used in many
testing scenarios including validation of large industrial DSLs, but
its scalability is not yet sufficient for benchmarking purposes.
We havenoprecise claims onthediversity andrealisticnature
of our model generator. In the future, we aim to extend the frame-
work to synthesize a set of graph models which are consistent,
diverseandrealisticatthesametime.Numerousstudies[ 24,25,51]
havedemonstratedthatneithertraditionalSAT-solversnorSMT-
solversprovidesufficientdiversityfortheiroutcomewhencalled
repeatedly.
978
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:56:19 UTC from IEEE Xplore.  Restrictions apply. A Graph Solver for the Automated Generation of Consistent Domain-Specific Models ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
REFERENCES
[1]A. Milicevic, S. Misailovic, D. Marinov, and S. Khurshid, “Korat: A tool for
generating structurally complex test inputs,” in 29th International Conference on
SoftwareEngineering(ICSE2007),Minneapolis,MN,USA,May20-26,2007 ,2007,
pp. 771–774. [Online]. Available: https://doi.org/10.1109/ICSE.2007.48
[2]D. Marinov and S. Khurshid, “Testera: A novel framework for automated testing
ofjavaprograms,”in 16thIEEEInternationalConferenceonAutomatedSoftware
Engineering (ASE 2001), 26-29 November 2001, Coronado Island, San Diego, CA,
USA, 2001, p. 22. [Online]. Available: https://doi.org/10.1109/ASE.2001.989787
[3]G. Bagan, A. Bonifati, R. Ciucanu, G. H. L. Fletcher, A. Lemay, and N. Advokaat,
“gMark: Schema-driven generation of graphs and queries,” IEEE Transactions on
Knowledge and Data Engineering , vol. 29, no. 4, pp. 856–869, 2017.
[4]Z. Micskei, Z. Szatmári, J. Oláh, and I. Majzik, “A concept for testing robustness
and safety of the context-aware behaviour of autonomous systems,” in KES-
AMSTA, ser. LNCS, vol. 7327. Springer, 2012, pp. 504–513.
[5]J. Härtel, L. Härtel, and R. Lämmel, “Test-data generation for Xtext,” in SLE, 2014,
pp. 342–351.
[6]V.Aranega,J.-M.Mottu,A.Etien,T.Degueule,B.Baudry,andJ.-L.Dekeyser,“To-
wardsanautomationofthemutationanalysisdedicatedtomodeltransformation,”
Softw. Test., Verif. Reliab. , vol. 25, no. 5-7, pp. 653–683, 2015.
[7]S.Ali,M.Z.Z.Iqbal,A.Arcuri,andL.C.Briand,“GeneratingtestdatafromOCL
constraints with search techniques,” IEEE Trans. Software Eng. , vol. 39, no. 10, pp.
1376–1402, 2013.
[8]G. Szárnyas, B. Izsó, I. Ráth, and D. Varró, “The Train Benchmark: cross-technology performance evaluation of continuous model queries,” Softw. Syst.
Model., 2017.
[9]SpecialCommittee205ofRTCA,“DO-178C,SoftwareConsiderationsinAirborne
Systems and Equipment Certification,” 2011.
[10] ISO, “Road vehicles – Functional safety,” 2011.
[11]D. Varró, O. Semeráth, G. Szárnyas, and Ákos Horváth, “Towards the automated
generationofconsistent,diverse,scalableandrealisticgraphmodels,”in Graph
Transformation,Specifications,andNets(InMemoryofHartmutEhrig) . Springer
LNCS 10800, 2018.
[12]W. van Leeuwen, A. Bonifati, G. H. L. Fletcher, and N. Yakovets, “Stabilitynotions in synthetic graph generation: a preliminary study,” in Proceedings
of the 20th International Conference on Extending Database Technology, EDBT
2017, Venice, Italy, March 21-24, 2017. , 2017, pp. 486–489. [Online]. Available:
https://doi.org/10.5441/002/edbt.2017.51
[13]G. Szárnyas, Z. Kővári, Á. Salánki, and D. Varró, “Towards the characterization
ofrealisticmodels:Evaluationofmultidisciplinarygraphmetrics,”in MODELS,
2016.
[14]K. Anastasakis, B. Bordbar, G. Georg, and I. Ray, “On challenges of model trans-
formationfromUMLtoAlloy,” SoftwareandSystemsModeling ,vol.9,no.1,pp.
69–86, 2010.
[15]E. K. Jackson and J. Sztipanovits, “Constructive techniques for meta-and model-
level reasoning,” in Model Driven Engineering Languages and Systems . Springer,
2007, pp. 405–419.
[16]M. Kuhlmann, L. Hamann, and M. Gogolla, “Extensive validation of OCL models
by integrating SAT solving into use,” in TOOLS’11 - Objects, Models, Components
and Patterns , ser. LNCS, vol. 6705, 2011, pp. 290–306.
[17]J.Cabot,R.Clariso,andD.Riera,“VerificationofUML/OCLclassdiagramsusingconstraintprogramming,”in SoftwareTestingVerificationandValidationWorkshop,
2008. ICSTW ’08. IEEE International Conf. on , April 2008, pp. 73–80.
[18] F. Büttner,M.Egea,andJ. Cabot,“OnverifyingATLtransformations using’off-
the-shelf’ SMT solvers,” in Proc. of the 15th Int. Conf. on MODELS , ser. LNCS, vol.
7590, 2012.
[19]O. Semeráth, A. Barta, A. Horváth, Z. Szatmári, and D. Varró, “Formal valida-
tion of domain-specific languages with derived features and well-formedness
constraints,” Software and Systems Modeling , vol. 16, no. 2, pp. 357–392, 2017.
[20]K. Bak, Z. Diskin, M. Antkiewicz, K. Czarnecki, and A. Wasowski, “Clafer: unify-
ingclassandfeaturemodeling,” Software&SystemsModeling ,vol.15,pp.811–845,
2016.
[21]E. Torlak and D. Jackson, “Kodkod: A relational model finder,” in Tools and
Algorithms for the Construction and Analysis of Systems . Springer, 2007, pp.
632–647.
[22]A. Milicevic, J. P. Near, E. Kang, and D. Jackson, “Alloy*: A general-purpose
higher-orderrelationalconstraintsolver,”in 37thIEEE/ACMInt.Conf.onSoftware
Engineering, ICSE , 2015, pp. 609–619.
[23]L.deMouraandN.Bjørner,“Z3:AnefficientSMTsolver,”in ToolsandAlgorithms
fortheConstructionandAnalysisofSystems,14thInternationalConference(TACAS
2008), ser. LNCS, vol. 4963. Springer, 2008, pp. 337–340.
[24]O.Semeráth,A.Vörös,andD.Varró,“Iterativeandincrementalmodelgeneration
by logic solvers,” in 19th International Conference on Fundamental Approaches to
Software Engineering , ser. LNCS, no. 9633. Springer-Verlag, 2016, pp. 87–103.
[25]E.K.Jackson,G.Simko,andJ.Sztipanovits,“Diverselyenumeratingsystem-level
architectures,”in Proceedingsofthe11thACMInt.Conf.onEmbeddedSoftware .
IEEE Press, 2013, p. 11.[26]R.Salay,M.Chechik,M.Famelis,andJ.Gorzny,“Amethodologyforverifying
refinements of partial models,” Journal of Object Technology , vol. 14, no. 3, pp.
3:1–31, 2015.
[27]O. Semeráth and D. Varró, “Graph constraint evaluation over partial models
byconstraintrewriting,”in TheoryandPracticeofModelTransformation-10th
InternationalConference,ICMT2017,HeldasPartofSTAF2017,Marburg,Germany,
July 17-18, 2017, Proceedings , 2017, pp. 138–154.
[28]Z.Ujhelyi,G.Bergmann,Á.Hegedüs,Á.Horváth,B.Izsó,I.Ráth,Z.Szatmári,
and D. Varró, “EMF-IncQuery: An integrated development environment for live
model queries,” Sci. Comput. Program. , vol. 98, pp. 80–99, 2015.
[29]A. Rensink and D. Distefano, “Abstract graph transformation,” Electronic Notes in
Theoretical Computer Science , vol. 157, no. 1, pp. 39–59, 2006.
[30]A.Rensink,“Canonicalgraphshapes,”in ProgrammingLanguagesandSystems,
13th European Symposium on Programming, ESOP 2004 , 2004, pp. 401–415.
[31]T.W.Reps,M.Sagiv,andR.Wilhelm,“Staticprogramanalysisvia3-valuedlogic,”
inInternationalConferenceonComputerAidedVerification . Springer,2004,pp.
15–30.
[32]Á.Hegedüs,Á.Horváth,andD.Varró,“Amodel-drivenframeworkforguided
design space exploration,” Automated Software Engineering , vol. 22, no. 3, pp.
399–436, 2015.
[33] Yakindu Statechart Tools, Yakindu, 2017, http://statecharts.org/.
[34] The Eclipse Project, Eclipse Modeling Framework , 2017, //www.eclipse.org/emf.
[35]E. K. Jackson, T. Levendovszky, and D. Balasubramanian, “Reasoning about
metamodeling with formal specifications and automatic proofs,” in Model Driven
Engineering Languages and Systems . Springer, 2011, pp. 653–667.
[36]D.Jackson,“Alloy:alightweightobjectmodellingnotation,” ACMTrans.Softw.
Eng. Methodol. , vol. 11, no. 2, pp. 256–290, 2002.
[37]J.Cabot,R.Clarisó,andD.Riera,“UMLtoCSP:atoolfortheformalverificationofUML/OCL models using constraint programming,” in Proc. of the 22nd IEEE/ACM
InternationalConferenceonAutomatedSoftwareEngineering(ASE’07) . NewYork,
NY, USA: ACM, 2007, pp. 547–548.
[38]M. Famelis, R. Salay, and M. Chechik, “Partial models: Towards modeling and
reasoningwithuncertainty,”in Proceedingsofthe34thInternationalConference
on Software Engineering . Piscataway, NJ, USA: IEEE Press, 2012, pp. 573–583.
[39]S.C.Kleene,N.DeBruijn,J.deGroot,andA.C.Zaanen, Introductiontometa-
mathematics . van Nostrand New York, 1952, vol. 483.
[40]Object Constraint Language, v2.4 , The Object Management Group, February 2014.
[41]U.Nickel,J.Niere,andA.Zündorf,“TheFUJABAenvironment,”in Proceedings
ofthe22ndInt.Conf.onSoftwareEngineering,ICSE2000,LimerickIreland,June
4-11, 2000. , 2000, pp. 742–745.
[42]H. Ehrig, G. Rozenberg, and H.-J. rg Kreowski, Handbook of graph grammars and
computing by graph transformation . world Scientific, 1999, vol. 3.
[43]M. Davis, G. Logemann, and D. Loveland, “A machine program for theorem-
proving,” Communications of the ACM , vol. 5, no. 7, pp. 394–397, 1962.
[44]G. Bergmann, I. Ráth, G. Varró, and D. Varró, “Change-driven model transforma-
tions,”Software & Systems Modeling , vol. 11, no. 3, pp. 431–461, 2012.
[45]“Alloy online tutorial,” 2017. [Online]. Available: http://alloy.mit.edu/alloy/
tutorials/online/
[46]F.Büttner,M.Egea,J.Cabot,andM.Gogolla,“VerificationofATLtransformations
usingtransformationmodelsandmodelfinders,”in 14thInternationalConf.on
Formal Engineering Methods,ICFEM’12 . LNCS 7635, Springer, 2012, pp. 198–213.
[47]M. Soeken, R. Wille, M. Kuhlmann, M. Gogolla, and R. Drechsler, “Verifying
UML/OCL models using boolean satisfiability,” in Design, Automation and Test in
Europe, (DATE’10) . IEEE, 2010, pp. 1341–1344.
[48]Á. Hegedüs, Á. Horváth, I. Ráth, R. R. Starr, and D. Varró, “Query-driven soft
traceability links for models,” Software & Systems Modeling , vol. 15, no. 3, pp.
733–756, 2016.
[49]C. A. González, F. Büttner, R. Clarisó, and J. Cabot, “Emftocsp: a tool for the
lightweight verification ofEMF models,” in Proceedings of theFirst International
Workshop on Formal Methods in Software Engineering - Rigorous and Agile
Approaches, FormSERA 2012, Zurich, Switzerland, June 2, 2012 , 2012, pp. 44–50.
[Online]. Available: https://doi.org/10.1109/FormSERA.2012.6229788
[50]D.Varró,G.Bergmann,Á.Hegedüs,Á.Horváth,I.Ráth,andZ.Ujhelyi,“Roadto
a reactive and incremental model transformation platform: three generations
of the VIATRA framework,” Software and System Modeling , vol. 15, no. 3, pp.
609–629, 2016. [Online]. Available: https://doi.org/10.1007/s10270-016-0530-4
[51]O.SemeráthandD.Varró,“Iterativegenerationofdiversemodelsfortestingspec-ificationsofdsltools,”in 21stInternationalConferenceonFundamentalApproaches
to Software Engineering , ser. LNCS. Springer-Verlag, 2018.
[52]Viatra Solver Project, 2018. [Online]. Available: https://github.com/viatra/
VIATRA-Generator
[53]D.LeBerreandA.Parrain,“Thesat4jlibrary,release2.2,” JournalonSatisfiability,
Boolean Modeling and Computation , vol. 7, pp. 59–64, 2010.
[54]M. Gogolla, J. Bohling, and M. Richters, “Validating UML and OCL models in
USEbyautomaticsnapshotgeneration,” SoftwareandSystemsModeling ,vol.4,
pp. 386–398, 2005.
979
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:56:19 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Oszkár Semeráth, András Szabolcs Nagy and Dániel Varró
[55]F. Büttner and J. Cabot, “Lightweight string reasoning for OCL,” in Modelling
Foundations and Applications - 8th European Conference, ECMFA 2012, Lyngby,Denmark, July 2-5, 2012. Proceedings , ser. LNCS, A. Vallecillo, J.-P. Tolvanen,
E. Kindler, H. Störrle, and D. S. Kolovos, Eds., vol. 7349. Springer, 2012, pp.
244–258.
[56]S.M.A.Shah,K.Anastasakis,andB.Bordbar,“FromUMLtoAlloyandbackagain,”
inMoDeVVa’09:Proceedingsofthe6thInternationalWorkshoponModel-Driven
Engineering, Verification and Validation . ACM, 2009, pp. 1–10.
[57]B.Beckert, U.Keller, andP. H.Schmitt,“Translating theObject ConstraintLan-
guage into First-order Predicate Logic,” in Proc. of the VERIFY, Workshop at Feder-
ated Logic Conferences (FLoC), Copenhagen, Denmark , 2002.
[58]A. Queralt, A. Artale, D. Calvanese, and E. Teniente, “OCL-Lite: Finite reasoning
on UML/OCL conceptual schemas,” Data Knowl. Eng. , vol. 73, pp. 1–22, 2012.
[59]A. D. Brucker and B. Wolff, “The HOL-OCL tool,” 2007, http://www.brucker.ch/.
[60]H. Grönniger, J. O. Ringert, and B. Rumpe, “System model-based definition of
modeling language semantics,” in Formal Techniques for Distributed Systems , ser.
LNCS, vol. 5522. Springer, 2009, pp. 152–166.
[61]M.ClavelandM.Egea,“TheITP/OCLtool,”2008,http://maude.sip.ucm.es/itp/ocl/.
[62]R. Salay and M. Chechik, “A generalized formal framework for partial modeling,”
inFundamental Approaches to Software Engineering , ser. LNCS, A. Egyed and
I. Schaefer, Eds. Springer Berlin Heidelberg, 2015, vol. 9033, pp. 133–148.
[63]R. Salay, M. Famelis, and M. Chechik, “Language independent refinement using
partial modeling,” in Fundamental Approaches to Software Engineering , ser. LNCS,
J.deLaraandA.Zisman,Eds. SpringerBerlinHeidelberg,2012,vol.7212,pp.
224–239.
[64]M.Famelis,R.Salay,A.DiSandro,andM.Chechik,“Transformationofmodels
containing uncertainty,” in International Conference on Model Driven Engineering
Languages and Systems . Springer, 2013, pp. 673–689.
[65]E. Brottier, F. Fleurey, J. Steel, B. Baudry, and Y. Le Traon, “Metamodel-based
TestGenerationforModelTransformations:anAlgorithmandaTool,”in 17th
InternationalSymposiumonSoftwareReliabilityEngineering,2006.ISSRE’06. ,Nov
2006, pp. 85–94.
[66]F. Fleurey, J. Steel, and B. Baudry, “Validation in model-driven engineering:
Testing model transformations,” in International Workshop on Model, Design and
Validation , Nov 2004, pp. 29–40.
[67]S. Ali, M. Z. Iqbal, M. Khalid, and A. Arcuri, “Improving the performance of OCL
constraint solving with novel heuristics for logical operations: a search-basedapproach,” Empirical Software Engineering , vol. 21, no. 6, pp. 2459–2502, 2016.
[Online]. Available: https://doi.org/10.1007/s10664-015-9392-6
[68]S.Sen,N.Moha,B.Baudry,andJ.-M.Jézéquel,“Meta-modelPruning,”in Proceed-
ingsof theInternational Conferenceon Model DrivenEngineering Languagesand
Systems (MODELS) , Denver, Colorado, USA, Oct 2009.
[69]G. Soltana, M. Sabetzadeh, and L. C. Briand, “Synthetic data generation
for statistical testing,” in Proceedings of the 32nd IEEE/ACM International
Conference on Automated Software Engineering, ASE 2017, Urbana, IL, USA,October 30 - November 03, 2017 , 2017, pp. 872–882. [Online]. Available:
https://doi.org/10.1109/ASE.2017.8115698
[70]E. Kang, E. Jackson, and W. Schulte, “An approach for effective design space
exploration,”in FoundationsofComputerSoftware.Modeling,Development,and
Verification of Adaptive Systems , ser. LNCS, R. Calinescu and E. Jackson, Eds.
Springer Berlin Heidelberg, 2011, vol. 6662, pp. 33–54.
[71]J.Crawford,M.Ginsberg,E.Luks,andA.Roy,“Symmetry-breakingpredicates
for search problems,” KR, vol. 96, pp. 148–159, 1996.
[72]S.Schneider,L.Lambers,andF.Orejas,“Symbolicmodelgenerationforgraph
properties,”in InternationalConferenceonFundamentalApproachestoSoftware
Engineering . Springer, 2017, pp. 226–243.
[73]K.-H.Pennemann,“Resolution-liketheoremprovingforhigh-levelconditions,”in
International Conference on Graph Transformation . Springer, 2008, pp. 289–304.
[74]A. S. Al-Sibahi, A. S. Dimovski, and A. Wasowski, “Symbolic execution
of high-level transformations,” in Proceedings of the 2016 ACM SIGPLAN
International Conference on Software Language Engineering, Amsterdam, The
Netherlands,October31-November1,2016 ,2016,pp.207–220.[Online].Available:
http://dl.acm.org/citation.cfm?id=2997382
980
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:56:19 UTC from IEEE Xplore.  Restrictions apply. 