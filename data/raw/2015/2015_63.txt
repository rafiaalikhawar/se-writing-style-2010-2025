Jens Knoop, Uwe Zdun (Hrsg.): Software Engineering 2016,
Lecture Notes in Informatics (LNI), Gesellschaft f ¨ur Informatik, Bonn 2016 63
Hidden Truths in Dead Softwar ePaths
Michael Eichberg1Ben Hermann2Mira Mezini3and Leonid Glanz4
Abstract: Approaches and techniques for statically ﬁnding amultitude of issues in source code
havebeen de veloped in the past. Acore property of these approaches is that the yare usually targeted
towards ﬁnding only avery speciﬁc kind of issue and that the effort to de velop such an analysis is
signiﬁcant. This strictly limits the number of kinds of issues that can be detected.
In this paper ,w ed iscuss ageneric approach –based on the detection of infeasible paths in code –
that can disco veraw ide range of code smells ranging from useless code that hinders comprehension
to real bugs. The issues are identiﬁed by computing the difference between the control-ﬂo wgraph
that contains all technically possible edges and the corresponding graph recorded while performing
amore precise analysis using abstract interpretation.
The approach wasevaluated using the Ja vaDevelopment Kit as well as the Qualitas Corpus (a
collection of over100 Ja vaApplications) and enabled us to ﬁnd thousands of issues.
1O verview
Since the 1970s man yapproaches ha vebeen de veloped that use static analyses to iden-
tifyamultitude of different types of issues in source code [Co06, CA01, GYF06]. The
techniques used by these approaches range from pattern matching [Co06] to using for-
mal methods [Co09] and vary widely w.r.t. their precision and scalability .But, the yhave
in common that each one only targets avery speciﬁc kind of issues. Those tools (e.g.,
FindBugs [Co06]) that can identify issues across awide(r) range of issues are typically
just suits of relati vely independent analyses. In all cases, the issues that can be found are
limited to those that are identiﬁed by some tool de veloper.
Wepresent ageneric approach that detects control- and data-ﬂo wdependent issues in
JavaBytecode without targeting an yspeciﬁc kind of issues per se. The approach applies
abstract interpretation based techniques to analyze the code and while doing so records
the paths that are taken. Afterwards, the analysis compares the recorded paths with the set
of all paths that could be taken according to an a¨ıvecontrol-ﬂo wanalysis that does not
consider an ydata-ﬂows. The paths computed by the latter analysis, butnot found in the
former graph, are then reported along with ajustiﬁcation wh ytheywere not taken.
The rationale underlying this approach is that man yissues such as null dereferences or
array inde xout of bounds accesses lead to executions that lea veinfeasible paths behind.
1Technische Uni versit¨at Darmstadt, Fachbereich Informatik Fachgebiet Softwaretechnik, Hochschulstraße 10,
64289 Darmstadt, eichberg@cs.tu-darmstadt.de
2hermann@cs.tu-darmstadt.de
3mezini@cs.tu-darmstadt.de
4glanz@cs.tu-darmstadt.de64 Michael Eichber ge ta l.
Hence, the hypothesis underlying the approach is threefold. First, in well-written code
every path between an instruction and all it’ sdirect successors is eventually taken, and,
second, apath that will ne verb et aken indicates an issue. Third, alarge class of rele vant
issues manifests itself sooner or later in infeasible paths.
Though we opted for analyzing the code as precisely as possible, we deliberately limited
the scope of the analysis to mak ei ts calable. Westart with each method of aproject and
then perform acontext-sensiti veanalysis with avery small maximum call chain size. This
makes the analysis unsound –i.e. we may miss certain issues –but it enables us to use it
for large industrial sized libraries and applications.
Tovalidate our approach we analyzed the Ja vaDevelopment Kit (JDK 1.8.0 25) and also
the applications of the Qualitas Corpus [Te10]. The issues that we found range from seem-
ingly benign issues to serious bugs that will lead to exceptions at runtime or to dead fea-
tures. Howe ver,even at ﬁrst sight benign issues, such as unnecessary checks that test what
is already guaranteed, can ha ve,e.g., an impact in code reviews such code generally hin-
ders comprehension.5
2C onclusion
The proposed approach is based on the idea that infeasible paths in software are agood
indication of code issues and that alarge class of rele vant issues manifest themself sooner
or later in infeasible paths. The implementation relies on anewstatic analysis technique
thatexploits abstract interpretation and is parametrized overabstract domains as well as the
depth of call chains to follo winter-procedurally .This enables us to mak einformed reason-
able trade-offs between scalability and soundness. The validity of the claims is evaluated
by doing acase study of industrial size software; the issues re vealed during the case study
constitute themselves avaluable contribution of the paper and are publicly available.
References
[CA01] Cyrille, A.; Armin, B.: Applying Static Analysis to Large-Scale, Multi-Threaded Ja va
Programs. In: Proceedings of ASWEC ’01. IEEE Computer Society ,2001.
[Co06] Cole, B.; Hakim, D.; Ho vemeyer ,D.; Lazarus, R.; Pugh, W.;Stephens, K.: Improving
Your Software Using Static Analysis to Find Bugs. In: Companion to OOPSLA ’06.
ACM, 2006.
[Co09] Cousot, P.;Cousot, R.; Feret, J.; Mauborgne, L.; Min ´e, A.; Ri val, X.: Wh yDoes Astr ´ee
Scale Up? Form. Methods Syst. Des., 35(3):229–264, December 2009.
[GYF06] Geay ,E.;Yahav,E.; Fink, S.: Continuous Code-quality Assurance with SAFE. In: Pro-
ceedings of PEPM ’06. ACM, 2006.
[Te10] Tempero, E.; Anslo w,E.; Dietrich, J.; Han, T.;Li, J.; Lumpe, M.; Melton, H.; No-
ble, J.: Qualitas Corpus: ACurated Collection of Ja vaCode for Empirical Studies. In:
APSEC2010. 2010.
5The tool and the data set are available for download at www.opalwproject.de/tools/bugpicker .