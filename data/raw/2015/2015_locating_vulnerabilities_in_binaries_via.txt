1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
5859
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116Locating Vulnerabilities in Binaries via
MemoryLayout Recovering
Haijun Wang
ShenzhenUniversity
ChinaXiaofei Xie
Nanyang TechnologicalUniversity
SingaporeShang-Wei Lin
Nanyang TechnologicalUniversity
Singapore
Yun Lin
National Universityof Singapore
SingaporeYuekang Li
Nanyang TechnologicalUniversity
SingaporeShengchaoQin
Teesside University
UnitedKingdom
Yang Liu
Nanyang TechnologicalUniversity
SingaporeTingLiu
Xi’anJiaotong University
China
ABSTRACT
Locatingvulnerabilitiesisanimportanttaskforsecurityauditing,
exploit writing, and code hardening. However, it is challenging
to locate vulnerabilities in binary code, because most program
semantics(e.g.,boundariesofanarray)ismissingaftercompilation.
Withoutprogramsemantics,itisdifficulttodeterminewhethera
memory access exceeds its valid boundaries in binary code. In this
work, we propose an approach to locate vulnerabilities based on
memorylayoutrecovery.First,wecollectasetofpassedexecutions
andonefailedexecution.Then,forpassedandfailedexecutions,we
restoretheirprogramsemanticsbyrecoveringfine-grainedmemory
layouts based on the memory addressing model. With the memory
layouts recovered in passed executions as reference, we can locate
vulnerabilities in failed execution by memory layout identification
andcomparison.Ourexperimentsshowthattheproposedapproach
iseffectivetolocatevulnerabilitieson24outof25DARPA’sCGC
programs (96%), and can effectively classifies 453 program crashes
(in5Linux programs)into19 groupsbasedontheirroot causes.
1 INTRODUCTION
For memory unsafe languages like C/C++, memory corruption
vulnerability is one of the most severe defects, as it can lead to
software crash or even allows adversaries to take full control of
the software. Buffer overflow is one of the most common memory
corruption vulnerabilities, which is also the focus of this paper.
In the remaining of this paper, by vulnerability, we mean buffer
overflowvulnerability.
Therehavebeenanumberoftechniques[ 1ś4]thatcanlocate
bufferoverflows,andmostofthemareinthesourcecodelevel,such
as AddressSanitizer [ 1]. However, the source code is not always
available(e.g.,closed-sourcesoftwareandoff-the-shelfcomponents
in IoT devices). Further, it is shown that the semantics of binary
code may be different from its source code [ 5]. For the purpose of
binary securityauditing, exploit writing and code hardening,it is
highly significant to locate buffer overflows in binary code directly.
However, it is much more challenging to locate buffer overflows
in binaries than in source code. When the source code is compiled
into binaries, its program semantics is missing, i.e., we are not
able to identify variables of program and their memory boundariesanymore. Without the memory boundaries, locating buffer over-
flowsinbinarycodebecomesverydifficult.Althoughtherehave
beensometechniquesworkingonthebinarycode(e.g.,Valgrind
Memchecks[ 3]),noneofthemcanlocatebufferoverflowswithin
thestack/globalmemoryregions(e.g.,overflowbeyondanarray
but still within its resident stack frame) [ 1]. To address these is-
sues,recoveringtheprogramsemantics,i.e.,memoryboundaries
of variables, is necessary to locate buffer overflows inbinary code.
In addition, locating vulnerabilities highly benefits triaging pro-
gramcrashesinbinaries[ 6].Itiswell-knownthatthesamevulnera-
bilitycanproducevarioussymptoms,leadingtocrashesatdifferent
locations.Forexample,thefuzzingsystem(e.g.,fairfuzz,aflfastand
aflgo[7ś11])usuallygeneratesalargenumberofcrashes.However,
not all of these crashes are unique. Many of them are due to the
samevulnerability.Ifthecrashescanbegroupedaccordingtotheir
root causes, itwouldgreatly improve the efficiency of analysis.
Aimingataddressingtheabovechallenges,weproposeanap-
proach,basedondynamicexecutioninformation,tolocatebuffer
overflowsinbinaries.Ourapproachmainlyconsistsoftwoparts:
recoveringmemorylayout andlocating vulnerabilities .
RecoveringMemoryLayout .Amemorylayoutrepresentsthe
staticdatastructureofavariableinsourcecode,e.g.,adatastructure
with its members. In our approach, we actually use the dynamic
executioninformationinbinarycodetorestorestaticdatastructure
information of variables in source code. To recover the memory
layout, first, we identify the relevant addressing instructions for
each memory access in dynamic execution information. Second,
we recover a memory layout for each memory access based on the
memory addressing model. Third, if multiple memory layouts (e.g.,
recoveredfrommultipleexecutions)accessthesamevariable,we
merge them into a memory layout, generating a more complete
staticdatastructureforthatvariable.Comparedtoexistingtech-
niques [12ś16], our approach can precisely recover fine-grained
memory layoutsofvariables (c.f.Section 6.1).
LocatingVulnerabilities .Basedonrecoveredmemorylayouts,
we locate buffer overflows in a failed execution. To achieve this
goal, we need to determine whether the recovered memory layout
infailedexecutionexceedsitsvalidboundaries.Toinferthebound-
aries,wecollectafailedexecutionandasetofpassedexecutions.In
this paper, the failed execution means to cause the program crash,
1117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174ESEC/FSE2019, 26–30August,2019, Tallinn,Estonia Haijun Wang,XiaofeiXie, Shang-Wei Lin, Yun Lin, Yuekang Li, ShengchaoQin, Yang Liu, andTing Liu
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
1    Identify relevant 
instructions2     Recover memory layout 
on single access3  Merge memory layouts 
on multiple accesses4  Locate vulnerabilitiesReportsStatic memory layout recoveryPassed and failed
test cases
Binary programPassed and failed 
execution informationDynamic execution informationFigure 1:Overview ofour approach
12:      ptr->stu[a].name[i] = 41;typedef struct {
  int name[3];
  void (*func)( void);
}Stu;
typedef struct {
  Stu stu[2];  
  int a;
}Info;
static int num = 1;
1:  void f(void){
2:       ...
3:  }
4: void  test( int a, int b) {
5:    Info *ptr = (Info*)malloc(sizeof(Info));
6:    char  *str = ( char *)malloc (b);
7:    for(int i=0; i<b; i++){
8:       *str = 'a';
9:        str = str +1;
       }
10:  ptr->stu[a].func = &f; 
11:  for (int i=0; i<b; i++)
12:      ptr->stu[a].name[i] = 41;
13:  ptr->stu[a].name[5*num -3] = 42;
14:  ptr->stu[a].func();  
15:}  …...
l1:  mov    -0x3c(%ebp),%eax
l2:  movb  $0x61,(%eax)
l3:  addl    $0x1,-0x3c(%ebp)
…...
m1: mov   -0xc(%ebp),%eax
m2: mov   0x8(%ebp),%edx
m3: shl     $0x4,%edx
m4: add    %edx,%eax
m5: add    $0xc,%eax
m6: movl  $0x804843b,(%eax)
…...
p1:  mov  -0xc(%ebp),%eax
p2:  mov  0x8(%ebp),%edx
p3:  lea     0x0(,%edx,4),%ecx
p4:  mov   -0x10(%ebp),%edx
p5:  add    %ecx,%edx
p6:  movl  $0x29,(%eax,%edx,4)
…...
q1:  mov   0x804a020,%edx
q2:  mov   %edx,%eax
q3:  shl     $0x2,%eax
q4:  add    %edx,%eax
q5:  lea     -0x3(%eax),%ecx
q6:  mov   -0xc(%ebp),%eax
q7:  mov   0x8(%ebp),%edx
q8:  shl     $0x2,%edx
q9:  add    %ecx,%edx
q10: movl  $0x2a,(%eax,%edx,4)
…...0 12 36 32 280 1 4 3 2
16 32 24 28Real memory layout
Recovered memory layout
ptr->stu[a].func = &f; 
    ptr->stu[a].name[i] = 41;
ptr->stu[a].name[5*num -3] = 42;
(a) Source code (d) Merged memory layout (c) Memory layout on single access (b) Identified relevant instructionsstr[0] str[1] str[3] str[2]
L1
L216
ptr->stu[0] ptr->stu[1]
aname name func func
0 12 36 32 28 16
ptr->stu[0] ptr->stu[1]aname func func24
[2] name[0,1]
0 12 32 28
L416
ptr->stu[0] ptr->stu[1]aname func func24
[2] name[0,1]0Memory block
36x1 x1+16 28
L3Lp
0 16 3228overflow
(e) Reported root cause Lf3228
Failed memory layoutPassed memory layout32Step 1Step 2
Step 3
Step 4
Figure 2:Illustrationexample forour approach
whilethepassedexecutionwouldnot.Thefailedexecutionisthe
inputtoourapproach,andpassedexecutionscanbeobtainedeasily
fromexistingtoolsortestsuites(c.f.Section5.2).Forpassedexe-
cutions,werecover theirmemorylayouts(calledpassedmemory
layouts), which are considered as the memory layouts within valid
boundaries.Forthefailedexecution,wealsorecoveritsmemory
layouts(calledfailedmemorylayouts),whichmayincludemem-
ory layouts exceeding valid boundaries (called vulnerable memory
layouts). With the memory layouts recovered in passed executions
as reference, we can locate vulnerable memory layout, i.e., can-
didatebufferoverflow,inthefailedexecutionbymemorylayout
identification andcomparison (see Section 4).
We have implemented the proposed approach in a prototype
tool,and evaluateditseffectivenessintwo differentaspects:1)lo-
cating vulnerabilities, and 2) triaging program crashes. In locating
vulnerabilities,ourapproachiseffectivetolocatebufferoverflow
vulnerabilities on 24 out of 25 DARPA’s CGC programs (96%). In
triagingexperiments,ourapproachisabletoclassifythe453pro-
gram crashes (in 5 widely used Linux programs) into 19 groups,
whileAFL reports 320unique crashes(groups).
The contributionsofthis work are summarizedas follows:
•We formalize a memory addressing model, based on which,
togetherwiththedynamicexecutioninformation,wepro-
pose a general approach to precisely recover the static fine-
grainedhierarchical memory layoutsofprogram variables.
•With the memory layouts recovered in passed executions as
reference,weproposeanapproachtolocatebufferoverflows
infailedexecutionbymemorylayoutidentificationandcom-
parison.Tothebestofourknowledge,byusingfine-grained
memory layouts, our approach is the first work to locatebufferoverflowswithinstack,globalmemoryregions,and
data structures inbinary code.
•We implemented a prototype of the proposed approach and
evaluated its effectiveness on binary programs with diverse
kindsofvulnerabilities.
2 APPROACHOVERVIEW
2.1 Motivating Example
Fig.2(a)showsaprogramwithabufferoverflowvulnerability.If
theinputoffunction testis(1,4),theprogramcrashesatLine14.
The buffer overflow is triggered in the loop (Line 11). The variable
ptr→stu[1].namecontains three elements, but is assigned with
four elements. As a result, the variable ptr→stu[1].funcis over-
written, and the program crashes when Line 14 is executed (where
ptr→stu[1].funcisaccessed).
After being compiled into binaries, the program semantics is
missing,makingitdifficulttoidentifythevariablesandtheirbound-
aries. For example, the variable ptr→stu[1].nameand its memory
boundaries (its size is 12 bytes) are missing in binaries. Without
thisinformation,thebufferoverflowcannotbeidentifiedwhenit
iswritten with16 bytes.
2.2 OverviewofourApproach
To address this issue, we propose an approach to locate buffer
overflowsinbinaries.Theoverallflowoftheproposedapproach
isshowninFig.1.Theinputtoourapproachisasetofconcrete1
executioninformation (eitherpassedorfailed).
1Noticethatwecalltheobtainedexecutionsłconcretežbecausetheyarerealtraces
from dynamic executions. Thus, there are no loop or recursive function issues any
morein ourapproach as theyhavebeen unrolled during dynamicexecutions.
2233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290LocatingVulnerabilities in Binaries via
MemoryLayoutRecovering ESEC/FSE2019, 26–30August,2019, Tallinn,Estonia
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348Theproposedapproachconsistsoffoursteps.Inthefirststep,
givenpassedandfailedexecutions,weidentifyrelevantaddressing
instructionsforeachmemoryaccess.Inthesecondstep,werecover
thememorylayoutforeachmemoryaccess.Sinceoneexecution
may have multiple memory accesses, we may have more than
one memory layout recovered. If some of the recovered memory
layouts access the same variable, we merge them into one in the
thirdstep.Afterthisstep,wehaverecoveredmemorylayoutsfor
each execution(either passed orfailed). In the fourth step, we use
the memory layouts of passed executions as reference to locate
buffer overflows in the failedexecution.In the following,we walk
throughthesesteps using the motivatingexample inFig. 2.
Step1. We identify relevant addressing instructions for each
memory access. To access a variable, the program first determines
its memory address. For a memory access instruction, we perform
a backward taint analysis to identify the relevant instructions used
to compute its memory address. Fig. 2 (b) shows several sets of
identifiedinstructions.Forexample, m6isamemoryaccessinstruc-
tion, we perform backward taint analysis and identify the relevant
instructions m1...m6,whichcorrespondto Line10 inFig. 2(a).
Step2.Werecovermemorylayoutbasedonidentifiedinstruc-
tions for each memory access. In general, the memory address of a
variable is computed by iterativelyadding an offset tothe address
ofitsenclosingvariable.Basedonthisiterativeprocess,weidentify
thememory blocks (c.f. Definition 1), which represent the enclosed
variables.Inaddition,weconstructtheirhierarchicalstructure,and
finally form amemory layout.
Forexample,considerinstructions p1...p6,whichcorrespondto
Line 12 (e.g., ptr→stu[1].name[2]=41). The recovered memory
layout is L3, as shown in Fig. 2 (c), where the red part is the real
memorylayoutofthevariable,andthebluepartistherecovered
memory layout (double-headed arrows below indicate memory
blocks). Based on identified instructions, we can infer that: the
memoryaddressiscomputedbyaddingtwooffsets(16and8)tothe
baseaddress,andtheniswrittenwithfourbytes .Basedonthisinfor-
mation, we identify two memory blocks [0, 28] and [16, 28], where
0 represents a relative base address. In addition, we construct their
hierarchicalstructures.Thememoryblock[16,28]isenclosedin
[0, 28]. The identified memory blocks actually correspond to the
variablesinsourcecode.Forexample,[0,28]and[16,28]represents
arraysptr→stuandptr→stu[1].name,respectively.Thehierar-
chical structures reflect the enclosing/enclosed relationships of
variables. The variable ptr→stu[1].nameis enclosed in ptr→stu.
Step3. When multiple memory accesses operate on the same
variableintheexecutions(e.g.,intheunrolledloop),corresponding
recovered memory layouts should be merged. For example, the
memory layouts L2andL3in Fig. 2 (c) represent the same variable,
we merge them into a more complete memory layout Lp, as shown
in Fig. 2 (d), which reflects not only the variable ptr→stu[1].func
but alsoptr→stu[1].name.
Step4.Withabovethreesteps,werecovermemorylayoutsof
variables. To locate vulnerabilities, we need to determine whether
therecoveredmemorylayoutinfailedexecutionexceedsitsvalid
boundaries.Withthememorylayoutsrecoveredinpassedexecu-
tions as reference, we locate buffer overflows in failed execution
by memory layout identification and comparison. For example, we
recoverapassedmemorylayout,i.e., test(1,3),andafailedmemorylayout,i.e., test(1,4),asshownin LpandLfofFig.2(d).Bymemory
layout identification, memory blocks [16, 28] in Lpand [16, 32]
inLfare compared, and [28, 32] (i.e., ptr→stu[1].func) inLfis
consideredto be overflowed,as showninFig. 2(e).
The proposed approach can help users in two scenarios: (1)
Onewantstodisassembleordebugthebinaryprogram.Withthe
recoveredfine-grainedmemorylayoutsasdebugsymbols,he/she
caninterpretsomekeydatastructures.(2)Onehasabinaryprogram
crashed,andhe/shewantstofigureoutwhetherthecrashisdue
to buffer overflow and its root causes. Given the failed (crashed)
execution,togetherwithasetofpassedexecutions,ourapproach
can diagnose whether there is a buffer overflow and its root causes.
3 MEMORYLAYOUTRECOVERY
We first formalize a memory addressing model, and then introduce
the memory layoutrecovery basedonmemory addressing model.
3.1 MemoryAddressingModel
Beforea variableis accessed, itsmemory addressneedsto bedeter-
minedfirst.Inbinarycode,thereareusuallytwoaddressingmodes
for memory access: direct and indirect addressing [ 12]. In direct
addressing, the address is encoded in the instruction itself, usually
usedto access ascalar variable.
Theindirectaddressingmodeistypicallyusedtoaccessanar-
rayoradatastructure.Generally,theaddressiscomputedbyan
equation: address=base+(index∗scale)+offset,whereindexrep-
resentstheindexofanarray, scaleisthesizeofunitelementinthe
array,and offsetimpliestheoffsetcalculationforthememberofa
data structure.
Theequationforindirectaddressingdependsonthehierarchical
structureofavariable.Forexample,adatastructuremaycontain
an array as its member or the element of an array can be a data
structure. Hence, there could be more than one index∗scaleand
offset.A more generalequation is:
address=base+n/summationdisplay
i=1(indexi∗scalei)+offset (1)
Ingeneral, offsetmaybeanoptimizedvalueduetothecompilation,
i.e.,offset=/summationtextn
i=1offseti, where each offseticorresponds to one
indexi∗scaleiandoffseti≥0.Theaddressingequation isthe key
insightfor recoveringmemory layoutsof variables inthis paper.
Example1. Considerptr→stu[index1].name[index2]inFig.2(a),
thememoryaddressiscalculatedby: base+offset1+index1∗scale1+
offset2+index2∗scale2, wherebase=ptris the base address;
offset1=0istheoffsetof stuindatastructure ptr;index1∗scale1
calculates the address of the index1thelement of stu;offset2=0
istheoffsetof nameindatastructure stu[index1];index2∗scale2
calculatesthe addressofthe index2thelement of name.
3.2 Definition ofMemoryLayout
Definition1. Amemoryblock misatuple (m⌞,m⌟,/tildewidem),where
m⌞isthestartaddressand m⌟istheendaddress.Ifitrepresentsan
array,/tildewidemisthesizeofitsunitelement;Otherwise, /tildewidemiszero.Weuse
← →mto denote thesizeof m.
Definition 2. A memory layout L=(m,M,E)is a directed
acyclic graph (DAG), where mis the root memory block, Mis a set of
3349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406ESEC/FSE2019, 26–30August,2019, Tallinn,Estonia Haijun Wang,XiaofeiXie, Shang-Wei Lin, Yun Lin, Yuekang Li, ShengchaoQin, Yang Liu, andTing Liu
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464memory blocks, and E⊂M×Mis a set of directed edges connecting
memoryblocks suchthat (m1,m2)∈Eifm⌞
1≤m⌞
2∧m⌟
2≤m⌟
1.
Definition3. Giventwomemoryblocks m1andm2,ifm1and
m2represent the same variable, they are the aliasmemory blocks; if
thevariable representedby m1is enclosed inthatrepresentedby m2,
thenm1is aninnermemoryblockof m2.
Specifically,adirectededge (m1,m2)inmemorylayout Lrepresents
thatm2istheinnermemoryblockof m1.Amemorylayoutactually
reflectsthestatichierarchicaldatastructureofavariable(i.e.,the
enclosing/enclosedrelationship).
Theorem 1. Given two memory blocks m1andm2, if they are
intersected (i.e., m⌞
1<m⌟
2∧m⌟
1>m⌞
2),and0</tildewiderm2≤/tildewiderm1istrue,m2
is thealias orinnermemoryblockof m1.
Theorem 2. Given two memory blocks m1andm2, if they are
intersected(i.e., m⌞
1<m⌟
2∧m⌟
1>m⌞
2),and0</tildewiderm2≤/tildewiderm1∧← →m2>/tildewiderm1
is true,m2is thealias memoryblockof m1.
Theorems 1 and 2 present two basic approaches to determine
therelationshipbetweentwomemoryblocks.Theirdetailedproofs
can be foundinthe website [17].
3.3 MemoryLayoutRecoveryon Single
MemoryAccess
Memorylayoutsarerecoveredbasedonmemoryaddressingmodel.
Forthedirectaddressing,therecoveredmemorylayoutcontains
only one memory block m, i.e., the accessed memory block, and its
unit element size is zero (i.e., /tildewidem=0). For the indirect addressing,
the memory layout is recovered based on the following four steps:
3.3.1 Identifying Relevant Instructions. We first identify the rel-
evant instructions, which compute the address for the memory
access. To achieve this goal, we perform a backward taint analysis,
inwhichthememoryaccessinstructionisregardedasthe sink.Dif-
ferent from traditional taint analysis, we only propagate the taints
among the registers (not including registers espandebp), since
the memory address is computed by registers [ 18]. For example,
inFig.2(b)Line m6isamemoryaccessinstruction.Basedonthe
taintpropagationamongregisters,wecontinuetoidentifyLines
m1−m5. At Lines m1andm2, we stop the taint propagation as
their source operands are memory, not registers. As a result, the
identifiedaddressing instructionsare Lines m1-m6.
3.3.2 RecoveringAddressingEquation. Afteridentifyingrelevant
instructions,werecovertheaddressingequation,basedonthead-
dresscalculationinidentifiedinstructions,intheformofEquation1.
For example, we identify instructions (Lines m1-m6) in Fig. 2(b),
whereLine m6isamemoryaccessinstruction.AtLine m1,itstores
theaddresspointedby ptrtoregister eax,whichisthebaseaddress.
AtLinem2,itstoresthevalueofvariable atoregister edx,whichis
index1.Then,index1ismultipliedby16atLine m3,andthus scale1
is16.AtLine m4,itaddsindex1∗scale1tothebaseaddress.AtLine
m5,itaddsoffset(i.e.,0xc)tocomputethememoryaddress.Thus,
the recoveredaddressing equation is: eax+(edx∗16)+12.
3.3.3 Optimizing Addressing Equation. The addressing equation
is optimized as follows: 1) Sorting ntermsindexi∗scaleibasedAlgorithm1: GenerateLayout
input:address=base+/summationtextn
i=1(indexi∗scalei)+offset
output:amemory layout L=(m,M,E)
1Letoffset=/summationtextn
ixi, wherexirepresents offsetiandxi≥0;
2start←−base;
3end←−address +sizeof(accessed memory );
4if∀1≤i≤n:indexi∗scalei≥0then
5M←−∅,E←−∅;
6fori=1 :ndo
7 start←−start+xi;
8 mi←−(start,end,scalei);
9 M←−M∪{mi};
10 ifi≥2then
11 E←−E∪(mi−1,mi);
12 start←−start+indexi∗scalei;
13m←−m1;
14else
15m←−(start,end, 0) ;
16M←−{m},E←−∅;
17returnL;
on the descending order of scaleifori∈ {1,...,n}. 2) Merging
some terms of indexi∗scaleiif possible. For two adjacent terms
indexi∗scaleiandindexi+1∗scalei+1(1≤i<n), ifscalei<
indexi+1∗scalei+1, they are merged into one term index∗scale,
wherescale=gcd(scalei,scalei+1)(i.e.,greatestcommondivisor)
andindex=(indexi∗scalei+indexi+1∗scalei+1)/scale. In fact,
these two terms are used together to access the same array. The
detailed explanation can be found in the website [ 17]. For example,
the equation for array access inta[2p+q]is recovered as: base
+p∗(2∗sizeof(int))+q∗sizeof(int), wherep∗(2∗sizeof(int))
andq∗sizeof(int)are used together to access an array. Hence,
they should be merged.
3.3.4 RecoveringMemoryLayout. Basedontheoptimizedaddress-
ingequation,werecoverthememorylayoutinAlgorithm1.Ittakes
the addressing equation as input, and outputs a recovered memory
layout. As described in Section 3.1, offsetin the equation may be
an optimized value. Thus, at Line 1 we introduce the parameter xi
torepresenteachpossible offseti.Werecoverthememorylayout
based on two cases: (1) if every indexi∗scaleiin the equation is
greater than or equal to zero, the memory layout can be recovered
normally (Lines4ś13).Weiterativelyidentifythememoryblocks
and construct their hierarchical structure (Lines 6ś12). In this loop,
we first compute the start address of a memory block by adding
the offset xi(Line 7). Then, we recover this memory block miat
Line8,anditsunitsizeis scalei.AtLine11,weaddadirectededge
(mi−1,mi).Last,wecalculatetheaddressofthe indexithelement
andcontinuetorecoverthenextmemoryblock(Line12).(2)Ifthere
is anindexi∗scaleithat is negative (i.e., indexiis negative), it may
be used to access an array with other indexj∗scalejtogether. For
example,in ptr→stu[a].name[5∗num−3],-3(i.e., indexi)isused
to access array namewith 5∗num(i.e.,indexj) together. However,
we cannot determine whether aor 5∗numis used to access an
array together. In this case, we adopt a conservative strategy to
only recover the largestmemory block(Line 15).
4465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522LocatingVulnerabilities in Binaries via
MemoryLayoutRecovering ESEC/FSE2019, 26–30August,2019, Tallinn,Estonia
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
538
539
540
541
542
543
544
545
546
547
548
549
550
551
552
553
554
555
556
557
558
559
560
561
562
563
564
565
566
567
568
569
570
571
572
573
574
575
576
577
578
579
580Example 2. In Fig. 2(a), we assume that the address pointed
bypointer ptris0andthevalueofvariable ais1.BasedonLines
m1−m6inFig.2(b),wecanrecoveranequation:0 +1∗16+12.Weuse
x1andx2torepresenttheoptimizedoffsets,i.e., x1+x2=12.Based
onLine8ofAlgorithm1,amemoryblock (x1,32,16)isidentified.
Hence, we recover a memory layout, as L2in Fig. 2(c). For Lines
q1−q10,werecoveranequation:0 +1∗20+1∗16+(−3∗4).Since
index3∗scale3(i.e.,−3∗4) is negative, we only recover the largest
memory block (0,28,0),asL4inFig. 2(c).
3.4 MemoryLayoutRecoveryon Multiple
MemoryAccesses
Whenmultiplememoryaccessesoperateonthesamevariable(e.g.,
in the unrolled loop), corresponding recovered memory layouts
should be merged to generate a more complete one. Notice that
multiple memory accessescould happeninthe same ordifferent
executions.Itisnon-trivialto inferwhichmemory layoutscan be
mergedbecausetheirconcretememoryaddressescannotbeusedas
a uniqueidentification. Hence, we first index the memorylayouts
to make their memory addresses in a relative coordinate system so
that we can determinewhether they can be merged.
3.4.1 IndexingMemoryLayout. Assumethattheaddressspaceofa
program consistsofseveralnon-overlappingmemory-regions [ 12,
19]:stack,heap,andglobal,whichcorrespondtofunctions,heap-
allocationstatementsandglobal/staticvariables,respectively.Specif-
ically, each function has a memory-region, i.e., its stack frame; one
heap-allocationstatementhasamemory-region;thedatasectionis
a memory-region including global/static variables. Hence, the con-
cretememoryaddresscanbeindexedbyapair:(memory-region,
offset). The indexing processisdescribedas follows:
•For variable awhich is a local variable in a function f(stack
memory), we index its memory address by the pair (f,&a−fp),
wherefrepresents the memory region associated with f, &ais
the concrete memory address of a, andfpis the frame pointer of
f(e.g.,register ebp).
•For variable awhich is an enclosed variable (e.g., the member of
a data structure) in heap memory allocated at statement s, we
indexitsmemoryaddressbythepair( s,&a−ptr(s)),wheresrep-
resents the memory regionassociated withthe heap-allocation
statement s, &ais the concrete memory address of a, andptr(s)
isthe baseaddressofmemory allocatedat statement s.
•For variable awhich is a global/static variable in global memory,
we index its memory address by the pair (д,&a−ds), whereдis
thememoryregion associatedwithdatasection (oftendenoted
.datain binary code), & ais the concrete memory address of a,
anddsisthe baseaddressofdata section.
Afterindexing,theaddressesofmemorylayoutsareinthesame
coordinate, i.e., they are relative to the beginning of a memory-
region.Hence,we can merge the memory layouts.
3.4.2 MergingMemoryLayouts. Giventwomemorylayouts L1and
L2,wemergethembasedontwocases,asshowninAlgorithm2.
The first case is that their root memory blocks m1andm2are
intersected (Line 1). We first merge the root memory blocks of
L1andL2byMergeBlock (i.e.,Algorithm3),andconstructanew
memorylayout L′.Then,wecontinuetomergethechildrenof L′Algorithm2: MergeLayout
input:memory layouts L1=(m1,M1,E1)andL2=(m2,M2,E2)
output:merged memory layout L′=(m′,M′,E′)
1ifm⌞
1<m⌟
2∧m⌟
1>m⌞
2then
2L′←−MergeBlock (L1,L2);
3L′←−UpdateLayout (L′);
4returnL′;
5else return NIL;
Algorithm3: MergeBlock
input:memory layouts L1=(m1,M1,E1)andL2=(m2,M2,E2)
output:merged memory layout L′=(m′,M′,E′)
1if0</tildewiderm1</tildewiderm2thenswap(L1,L2);
2(m′,M′,E′)←−(m1,M1∪M2,E1∪E2);
3(m′⌞,m′⌟,/tildewidem′)←−(min(m⌞
1,m⌞
2),max(m⌟
1,m⌟
2),/tildewiderm1);
4status←−DetermineLevel (m′,m2);
5ifm2is the inner memory block of m′instatusthen
6E′←−E′∪{(m′,m2)};
7else
8foreachmc∈Child(m2)do
9 E←−E\{(m2,mc)};
10 E←−E∪{(m′,mc)};
11M←−M\{m2};
12if/tildewiderm2==0then/tildewidem′←−0;
13returnL′;
byUpdateLayout (i.e., Algorithm 5). The second case is that m1
andm2are not intersected. They represent different variables, and
cannot be merged. Next, we introduce the merging in the first case.
Algorithm3introduceshowtomergerootmemoryblocks m1
andm2ofL1andL2. At Line 1, it makes sure that /tildewiderm2≤/tildewiderm1is true.
Thus,m2is the alias or inner memory block of m1(c.f. Theorem 1).
At Lines 2-3, it merges m1andm2as a new memory block m′, and
constructsanewmemorylayout L′.Then,itdetermineswhether
m2is the inner memory block of m′byDetermineLevel (i.e., Al-
gorithm 4). If so, m2is added as the inner memory block of m′
(Line 6). Otherwise, m2andm′are alias memory blocks, or their
relationshipcannotbedetermined.Itaddstheinnermemoryblocks
(i.e., children) of m2as the inner memory blocks of m′(Lines 8-10),
and deletes m2(Line 11). Note that, when the relationship between
m2andm′cannot be determined, the algorithm ignores the case
thatm2is the inner memory block of m′. As a result, it may lose
some precision but is still correct. If the unit size of m2is zero, the
unitsize of m′isupdatedas zero(Line 12).
Given two memory blocks m1andm2such that/tildewiderm2≤/tildewiderm1(c.f.
Algorithm 3), Algorithm 4 determines whether m2is the alias or
innermemoryblockof m1.AtLines1-3,itdecidesthat m2isthe
aliasmemoryblockof m1(c.f.Theorem2).Ifitcannotdetermine
m2isthealiasmemoryblockof m1,weconsidertheinnermemory
blockmcofm1at Lines 5-11. It first checks whether m2andmc
areintersected(Line6).Then,itcheckswhether /tildewiderm2≤/tildewidermcistrue
(Line 7). If so, m2is the alias or inner memory layout of mc(c.f.
Theorem1).Basedontransitivity, m2istheinnerblockof m1.At
Line10,itcheckswhether m2isthealiasblockof mc(c.f.Theorem2).
If so,m2isalsothe innerblockof m1basedontransitivity.
5581
582
583
584
585
586
587
588
589
590
591
592
593
594
595
596
597
598
599
600
601
602
603
604
605
606
607
608
609
610
611
612
613
614
615
616
617
618
619
620
621
622
623
624
625
626
627
628
629
630
631
632
633
634
635
636
637
638ESEC/FSE2019, 26–30August,2019, Tallinn,Estonia Haijun Wang,XiaofeiXie, Shang-Wei Lin, Yun Lin, Yuekang Li, ShengchaoQin, Yang Liu, andTing Liu
639
640
641
642
643
644
645
646
647
648
649
650
651
652
653
654
655
656
657
658
659
660
661
662
663
664
665
666
667
668
669
670
671
672
673
674
675
676
677
678
679
680
681
682
683
684
685
686
687
688
689
690
691
692
693
694
695
696Algorithm4: DetermineLevel
input:memory blocks m1andm2
output:determining relationshipbetween m1andm2
1if/tildewiderm1/nequal0and/tildewiderm2/nequal0then
2if← →m2>/tildewiderm1then
3 returnm2is aliasmemory block of m1;
4else
5 foreachmc∈Child(m1)do
6 ifm⌞c<m⌟
2andm⌟c>m⌞
2then
7 if/tildewiderm2≤/tildewidestmcthen
8 returnm2is inner memory block of m1;
9 else
10 if← →mc>/tildewiderm2then
11 returnm2is inner block of m1;
12returnitis unknown
Algorithm5: UpdateLayout
input:memory layout L=(m,M,E)
output:updated memory layout L′=(m,M′,E′)
1L′←−L;
2LetQbean empty queue ;
3Q.ENQUEUE(m);
4whileQis notempty do
5mq←−Q.DEQUEUE();
6foreach(m1,m2)s.t.m1,m2∈Child(mq)do
7 LetL1=(m1,M1,E1)andL2=(m2,M2,E2)betwosub
layoutsof L′, whoserootsare m1andm2;
8 ifm⌞
1<m⌟
2andm⌟
1>m⌞
2then
9 L3:(m3,M3,E3)←−MergeBlock (L1,L2);
10 M′←−M′\(M1∪M2)∪M3;
11 E′←−E′\(E1∪E2)∪E3;
12 E′←−E′\{(mq,m1),(mq,m2)}∪{(mq,m3)};
13 L′←−UpdateLayout (L′);
14 returnL′;
15foreachmc∈Child(mq)do
16 Q.ENQUEUE(mc);
17returnL′;
3.4.3 Update Memory Layout. Algorithm 5 iteratively merges sub-
memorylayoutsbyaqueue Q.Theinputisamemorylayout Land
the outputis anupdated one L′. For the memory block mq, itfirst
identifiestwosub-memorylayouts L1andL2(Line6-7).Iftheirroot
memoryblocks m1andm2areintersected(Line8),wemergethem
toconstructanewmemorylayout L3byMergeBlock (Line9).At
Lines10-12,itreplaces L1andL2withL3.Sincethememorylayout
is updated, we continue to update L′byUpdateLayout (Line 13).
If sub-memory layouts of mqcannot be merged, it adds children
ofmqintoQ(Lines 15-16) and continues to merge the children
iteratively. If there is no merging between any two sub memory
layouts,the algorithm terminates.
Example 3. Fig. 3 shows the process of merging two memory
layouts,whichcorrespondto L2andL3inFig.2(c).Wecaninferthat
m1(x1,32,16)andm2(0,28,16)are intersected,where 0 ≤x1≤12,
/tildewiderm1=/tildewiderm2=16 and← →m2=28. Based on Lines 1-3 in Algorithm 4,
m1(x,32,16) m2(0,28,16)
m3(16,28,4)m'(0,32,16)
m3(16,28,4)L2 L3 LpFigure 3:Example to illustratemerging memory layouts.
we know m1andm2are the aliasmemoryblocks.Hence,theyare
merged as m′=(0,32,16), andm3is added as the inner memory
blockofm′.
3.4.4 Merging for Pointer Arithmetics. The pointer arithmetic gen-
erallyyieldsanewpointerthatstillpointsthesamememoryalloca-
tion[4].Multiplememoryaccessesbydereferencingthesepointers
canleadtomanymemorylayouts,whichcannotbemergedwith
Algorithm 2 (because they are not intersected). However, these
memory layouts belong to the same memory allocation and should
be merged together. To improve the precision, we merge them
togetheras follows:
Given such two memory layouts L1=(m1,M1,E1)andL2=
(m2,M2,E2), they are merged into a new memory layout L3=
(m3,M3,E3), wherem3=(min(m⌞
1,m⌞
2),max(m⌟
1,m⌟
2),0),M3=
M1∪M2∪{m3}andE3=E1∪E2∪{(m3,m1),(m3,m2)}.
Example 4. In Fig. 2(b), Lines l1−l3are executed four times (in
the unrolled loop), and we recover four memory layouts, which
cannotbemergedwithAlgorithm2.Duetothepointerarithmetics,
thesefourmemory layoutsare then mergedas L1inFig. 2(c).
3.5 Discussion ofSpecial Cases
Based on the memory addressing model, our approach can recover
memorylayoutsofvariablesgenerally.Inthissection,wediscuss
specialcasesduringmemory layoutrecovery.
Address space layout randomization. Addressspacelayout
randomization (ASLR) is a memory-protection technique by ran-
domizingthelocationsofmodulesandcertaindata[ 20].Current
ASLR techniques usually randomize the base address of a memory
region(e.g.,stackframe).Inthiscase,itdoesnotaffectourmemory
layout indexing (c.f. Section 3.4.1) and our approach can still work.
Memory allocation alloca.The function allocaallocates the
memory in the stack. In our approach, the stack memory allocated
byallocaistreatedas the heapmemory allocation.
Differentmemorylayoutsinoneallocationstatement. The
layouts of memory allocated in one allocation statement may be
differentindifferentcontexts.Forexample, if(*)size=sizeof(structA);
elsesize=sizeof(structB);ptr=malloc(size); ,thevariable ptrcanrep-
resenttwodatastructures(i.e., structAandstructB).Forthiscase,
we associate its context with the allocation statement to index the
memory layout. Specifically, we adopt the technique in memory
indexing[ 19],whichusescontrolflowstructuretoindexallocation
point,as the contextofallocation statement.
Data structure union.Aunioncan hold only one of its data
members at a time. In multiple accesses of a union, it may hold dif-
ferentmembers.Thus,ourapproachmaymergedifferentmembers.
If different members have different unit sizes, we only recover the
maximum memory range and discard the internal memory layout.
Hence, the recovered memory layout is still consistent with the
semantics of union.
6697
698
699
700
701
702
703
704
705
706
707
708
709
710
711
712
713
714
715
716
717
718
719
720
721
722
723
724
725
726
727
728
729
730
731
732
733
734
735
736
737
738
739
740
741
742
743
744
745
746
747
748
749
750
751
752
753
754LocatingVulnerabilities in Binaries via
MemoryLayoutRecovering ESEC/FSE2019, 26–30August,2019, Tallinn,Estonia
755
756
757
758
759
760
761
762
763
764
765
766
767
768
769
770
771
772
773
774
775
776
777
778
779
780
781
782
783
784
785
786
787
788
789
790
791
792
793
794
795
796
797
798
799
800
801
802
803
804
805
806
807
808
809
810
811
8124 LOCATING VULNERABILITIES
Inthissection,weintroducehowtolocatebufferoverflowvulnera-
bilitiesbyleveragingrecoveredmemory layouts.
4.1 Locating Vulnerabilities by Leveraging
RecoveredMemoryLayouts
Abufferoverflowoccurswhendereferencingapointerthatgoes
outoftheboundsofitspointedobject.Tolocatethebufferoverflow,
wecollectasetofpassedexecutionsandafailedexecution.With
thefine-grainedmemorylayoutsrecoveredinpassedexecutions
as reference, the vulnerable memory layout in failed execution can
be identifiedbymemory layoutidentification andcomparison.
It is worth noting that, the size of a memory block may not
be fixed as we introduce the parameters in Algorithm 1 (i.e., xi
atLine1).Tolocatethebufferoverflow,weadoptaconservative
strategytodeterminetheirvalues:letthesizeofthepassedmem-
ory layout be the maximum and the size of the failed memory lay-
outbetheminimum.Specifically,inamemorylayout L=(m,M,E),
the size of each memory block mi∈Mis:end−(base+···+
(xi−1+indexi−1∗scalei−1)+xi)(c.f. Algorithm 1). Forthe passed
memorylayout,wemakethesizeofeach mi∈Mmaximum,i.e.,
(∀1≤i<n:xi=0)∧xn=offset. For the failed memory layout,
wemakethesizeofeach mi∈Mminimum,i.e., x1=offset∧(∀1<i
≤n:xi=0).
Algorithm 6 shows how to locate the buffer overflow. It takes a
failed memory layout L1and a passed memory layout L2as inputs.
Its intuition is as follows: for each memory block m′
1ofL1, ifm′
1is
thealiasorinnermemoryblockofsomememoryblock m′
2ofL2,
andm′
1isbeyond m′
2,then itisacandidate buffer overflow.
AtLine5,itcheckswhether /tildewidem′
1iszero.Ifso,itcannotdetermine
the relationship between m′
1andm′
2. Thus, it only compares m′
1
withtherootmemoryblock m2ofL2.Ifm′
1is beyond m2(Line6),
thereisacandidatebufferoverflowin m′
1.AtLine9-17,itchecks
m′
1witheachmemoryblock m′
2ofL2.Ifm′
1isbeyond m′
2(Line13),
the algorithm checks the relationship between m′
1andm′
2. Ifm′
1is
thealiasorinnermemoryblockof m′
2(Line14),thereisacandidate
buffer overflowin m′
1.
Notice that, for the heap memory whose size is controlled by
inputs, its memory layout is not fixed with different inputs. Al-
though we recoverthemaximum memoryrangeaftermerging, it
still cannot be used to locate vulnerabilities. For example, in the
statement p=malloc(input), if the maximum value of inputin
passedtestcasesis5,werecoveramemoryblockwhosesizeis5
bytes (the maximum). If the value of inputin the failed test case is
10, we recover a memory block whose size is 10 bytes. Comparing
thesetwomemoryblocksintroducesafalsepositive.Inthiscase,
wedynamicallyrecordthememoryrangeofallocatedmemory,not
to index and merge their memory layouts. To locate vulnerabili-
ties,wecheckwhethertheusedmemoryisbeyondtheallocated
memory,whichisthe same as ValgrindMemcheck[3].
4.2 FalsePositiveReduction
Passedexecutionsmayonlycoverpartialprogrambehaviors.Thus,
thepassedmemorylayoutmayalsobeunder-approximated.Locat-
ing vulnerabilities by comparing failed memory layout with under-
approximated memory layout may introduce false positives. ForAlgorithm6: CompareLayout
input:memory layouts L1=(m1,M1,E1)andL2=(m2,M2,E2)
output:determining the bufferoverflow
1LetQ1bean empty queue ;
2Q1.ENQUEUE(m1);
3whileQ1is notempty do
4m′
1←−Q1.DEQUEUE();
5if/tildewidem′
1==0then
6 ifm′⌞
1<m⌞
2<m′⌟
1orm′⌞
1<m⌟
2<m′⌟
1then
7 returnfind buffer overflow
8else
9 LetQ2bean empty queue ;
10 Q2.ENQUEUE(m2);
11 whileQ2is notempty do
12 m′
2←−Q2.DEQUEUE();
13 ifm′⌞
1<m′⌞
2<m′⌟
1orm′⌞
1<m′⌟
2<m′⌟
1then
14 ifm′
1is aliasorinner block of m′
2then
15 returnfind buffer overflow
16 foreachmc∈Child(m′
2)do
17 Q2.ENQUEUE(mc);
18foreachmc∈Child(m′
1)do
19 Q1.ENQUEUE(mc);
20returnnotfind buffer overflow
thisproblem,wereducefalsepositivesbasedontwoaccompanying
phenomena: data corruption or abnormal memory address [ 21],
whichincreasethe confidence of our results.
4.2.1 DataDependenceMismatch. Bufferoverflowtypicallyincurs
data corruption (overflowed by another data) [ 21]. Data corruption
can lead to data dependence mismatch, describing a data depen-
dence that is not supposed to exist in the code. For example, in
Fig. 2(a), assume that the value of variable bis 4. The program
executes four times at Line 12. As a result, the value of variable
ptr→stu[a].funciscorruptedby ptr→stu[a].name.AtLine14,it
usesptr→stu[a].func.Thus,thereisadatadependencebetween
Lines 12 and 14, which does not exist in the code. Hence, a data de-
pendencemismatchoccurs.Toincreasetheconfidence,wereporta
buffer overflow vulnerability only if it conducts a data dependence
mismatchas well.
Toobtaindatadependencerelationsthatdoexistinthecode,we
usedynamicanalysisasinwork[ 21].Weexecuteasetofpassed
test cases, and compute data dependence relations. Similarly, we
also compute the data dependence relations in the failed execution.
If a data dependence relation only occurs in failed execution but
not in any passedexecution, there is a datadependence mismatch.
4.2.2 AbnormalMemory Address. When thebuffer isoverflowed
toomuch,itmayreachanmemoryaddressthatcannotbeaccessed
(e.g.,unallocatedmemory).Thissituationisconsideredasanabnor-
mal memory address access. Usually, an abnormal memory access
directlyleadstoaprogramcrash.Thus,ifabufferoverflowleads
to an abnormal memory address access, it is a true buffer overflow.
7813
814
815
816
817
818
819
820
821
822
823
824
825
826
827
828
829
830
831
832
833
834
835
836
837
838
839
840
841
842
843
844
845
846
847
848
849
850
851
852
853
854
855
856
857
858
859
860
861
862
863
864
865
866
867
868
869
870ESEC/FSE2019, 26–30August,2019, Tallinn,Estonia Haijun Wang,XiaofeiXie, Shang-Wei Lin, Yun Lin, Yuekang Li, ShengchaoQin, Yang Liu, andTing Liu
871
872
873
874
875
876
877
878
879
880
881
882
883
884
885
886
887
888
889
890
891
892
893
894
895
896
897
898
899
900
901
902
903
904
905
906
907
908
909
910
911
912
913
914
915
916
917
918
919
920
921
922
923
924
925
926
927
9285 EVALUATION
We have implemented a prototype tool for our approach, and eval-
uateditseffectiveness.Alltheexperimentsareperformedonthe
32-bit Linux system with 3 .5 GHz Intel Xeon E5 CPU and 8 GB
RAM.Sinceourmemoryaddressingmodelisgeneral,ourapproach
can be easily extendedto 64-bitsystem.
5.1 Experiment Setup
We selected 25 binary programs from the benchmarks of DARPA’s
CGC[22],whichisacompetitiontoautomaticallydetectvulnera-
bilities. Instead of contrived simple situations, they approximate
real vulnerabilities with enough complexities and diversities, ideal
for evaluating our approach [ 21]. However, not all programs are
selectedbecause:1)theyrununderDARPADECREE,whileourtool
runs on the Linux system. Although the team TrailofBits has mi-
gratedthemintoLinuxsystem,notallofthemarereproducible[ 23];
2)weonlyconsiderthebufferoverflow,theprogramswithother
types(e.g.,nullpointerdereferenceanduseafterfree)areoutofour
consideration.Inaddition,weselectedfourbinaryprograms obj-
dump,readelf,ldandc++filtfrombinutils(about 690k LoC), which
arewidelyusedinfuzzingsystem[ 10,11],andonebinaryprogram
tiff2bwfromlibtiff(about 100k LoC). In these five programs, we
generated453programcrashes,whichconstitutereal-worldbench-
marks.The25CGCprogramsshowthediversitiesofvulnerabilities,
andthe5real-worldprogramsshowthescalabilityofourapproach.
5.2 Experiment Design
Intheexperiments,weusethefuzzingsystem[ 7ś11]togeneratethe
passed test cases2and use the dynamic binary analysis framework
Pin[24]tocollectthedynamicexecutioninformation.Ingeneral,
AFL generates a large number of passed test cases with different
code coverage. For efficiency, we select the passed test cases by
adopting additionalcoveragestrategy [25].Itselectsthenextpassed
testcase,whichcoversmorecodesthatarecoveredbythefailed
test case but not covered by already-selected passed test cases,
until vulnerabilities are located. Due to the lack of ground truth
inourexperiments,wemanuallyvalidatetheresults.Intotal,we
manually check 478 program crashes in 30 programs and their
recoveredmemory layouts.
5.3 ExperimentalResults
We evaluated the effectiveness of our approach in three aspects:
1) recovering memory layouts, 2) locating vulnerabilities, and 3)
triaging program crashes.
5.3.1 Recovering Memory Layout. Table 1 shows the experimental
results on recovering memory layouts. Column Namelists the pro-
gramnames.Incolumn PassedInputs ,theheading #Totalliststhe
total number of generatedpassed test cases, and #Selectshows the
numberofselectedpassedtestcases.Thedetails ofgeneration/se-
lectionofpassedtestcasescanrefertoSection5.2.Column Trace
Lengthlists the number of instructions in the execution, where
#Passedand#Failedrepresent the average numbers of instructions
inselectedpassedexecutionsandfailedexecution,respectively.
2There could be a situation where a passed execution accesses a memory location
beyond the boundary, but does not lead to any crash. This would not produce false
positives, not misleading analyst to wrong investigation. See[17] for moredetails.Sinceaprogrammaycontainmorethanonevulnerablememory
layout, in column Vulnerable Memory Layout , the heading No.lists
each of them. For example, there are three vulnerable memory
layoutsinthe program stack_vm .
Theheading Statusshowsthestatusof recoveredpassedmem-
ory layout,which isusedfor comparisonto identifythe vulnerable
memorylayout.Itindicateswhetherthepassedmemorylayoutrep-
resents the hierarchical structure of variables, where Undermeans
thatweunder-approximatelyrecoverthememorylayout,and Com-
pletemeansthatwerecoveritscompletememorylayouts.Notice
that we got a large number of passed memory layouts recovered in
passed executions. We manually check and report only 36 of them
(columnStatus) because:1) the numberofrecovered memory lay-
outs is too large to manually check all; 2) these 36 memory layouts
are compared to identify vulnerable memory layouts andwe need
to checkits status(under-approximatedorcomplete).
Summary. Among thereported36 passedmemorylayouts,15
memory layouts are completely recovered (i.e., the recovered static
hierarchical data structures for variables are the same with their
static hierarchical data structures in source code) and 21 are under-
approximatelyrecovered(e.g.,someinternaldatastructuresofvari-
ables are not recovered). Memory layouts are under-approximately
recoveredbecausesomeelementsofarrayormembersofdatastruc-
turearenotaccessedindynamicexecutioninformation.Thatis,our
approachachieves100%successratetorecovermemorylayouts
that are covered in dynamic execution information. Despite the
under-approximatememorylayoutrecovery,theyarestilluseful
to locate buffer overflow vulnerabilities, which is shown in the
following experiments.
5.3.2 Locating Vulnerabilities. Table 1 also shows the results of
locatingbufferoverflowvulnerabilities.Therearemultipletypesof
bufferoverflowvulnerabilitiesintheprograms,asshownincolumn
Type.Thesymbols Stack,Heap,Globalrepresentstack,heap,and
globalbufferoverflow,respectively.Inaddition,weconsideranother
specialtypeofbufferoverflow:overflowwithinadatastructure,as
indicatedby Internal.Inbinarycode,ValgrindMemcheck[ 3]cannot
locatebufferoverflowswithinstack,globalmemoryregions,and
data structures [ 1]. Valgrind’s extension SGCheck tries to locate
stackbufferoverflows,however,itstill needsdebuginformation.
Even in sourcecode,AddressSanitizer[ 1]cannot detect thebuffer
overflowwithin the data structures as well.
ColumnBuffer Overflow shows whether the vulnerable memory
layouts are the root causes of crash. Since one vulnerable memory
layoutmaybeoverflowedatdifferentinstructions,theheading #Ins
representsthenumberofinstructionsproducingbufferoverflowsin
vulnerable memory layouts. The heading Rootshows whether it is
a real buffer overflow. Our approach may report false positives. To
reduce them, we adopt two strategies: data dependence mismatch
(denotedbyM)andabnormalmemoryaddress(denotedbyA)in
the column PlusAccompanying .
After our investigation, we found that the false positives are
generated in two cases: (1) Some instructions do lead to the buffer
overflow, but do not lead to the crash. For example, in the pro-
gramSample_Shipgame , there are 2 instructions leading to a buffer
overflow. However, one is assigned with ‘ \0’, and it is not the root
causeofcrash.Thiscanbeeliminatedbyourstrategies,andthus
8929
930
931
932
933
934
935
936
937
938
939
940
941
942
943
944
945
946
947
948
949
950
951
952
953
954
955
956
957
958
959
960
961
962
963
964
965
966
967
968
969
970
971
972
973
974
975
976
977
978
979
980
981
982
983
984
985
986LocatingVulnerabilities in Binaries via
MemoryLayoutRecovering ESEC/FSE2019, 26–30August,2019, Tallinn,Estonia
987
988
989
990
991
992
993
994
995
996
997
998
999
1000
1001
1002
1003
1004
1005
1006
1007
1008
1009
1010
1011
1012
1013
1014
1015
1016
1017
1018
1019
1020
1021
1022
1023
1024
1025
1026
1027
1028
1029
1030
1031
1032
1033
1034
1035
1036
1037
1038
1039
1040
1041
1042
1043
1044Table 1:Experimentalresults on programs fromDARPA’sCyberGrand Challenge
Name TypePassed Inputs Trace LengthVulnerableBufferOverflow PlusAccompanying Time(s)Memory Layout
#Total #Select #Passed #Failed No. Status #Ins Root Mismatch/Abnormal #Ins Root Select Locate
Sample_Shipgame Stack 620 1 20,843 32,502 1 Under 2 ✓ M 1✓349 50
ValveChecks Stack 10 2 5,242 104,7261 Under 1 × ś 0 ś6 512 Complete 1 ✓ M+A 1✓
Bloomy_Sunday Stack 192 1 786,145 642,941 1 Complete 2 ✓ M+A 1✓119 147
The_Longest_Road Stack 298 1 343,992 344,668 1 Under 3 ✓ M+A 1✓168 110
Thermal_Controller_v2 Stack 83 1 64,752 66,291 1 Under 5 ✓ M 3✓52 104
XStore Stack 290 1 995,805 997,2221 Under 1 × ś 0 ś163 3872 Under 3 ✓ M+A 1✓
Casino_Games Stack 603 2 192,211 182,209 1 Under 1 ✓ M+A 1✓390 143
Palindrom Stack 61 1 106,087 5,262 1 Complete 6 ✓ M 4✓31 48
CableGrind Stack 818 1 17,240 18,336 1 Under 1 ✓ M+A 1✓432 46
stack_vm Heap 168 1 177,047 1,104,4141 Under 1 × ś 0 ś
95 378 2 Under 1 ✓ A 1✓
3 Complete 1 ✓ M 1✓
Street_map_service Heap 630 1 1,121,017 714,785 1 Complete 3 ✓ M 1✓468 240
humaninterface Heap 533 1 509,169 509,618 1 Complete 1 ✓ M 1✓279 244
AIS-Lite Heap 368 1 41,069 33,9041 Under 3 × ś 0 ś203 472 Complete 2 ✓ M 1✓
matrices_for_sale Heap 34 1 170,680 6,564 1 Complete 1 ✓ A 1✓18 54
cotton_swab_arithmetic Heap 1065 1 2,192 2,052 1 Complete 1 ✓ A 1✓544 37
LMS Heap 147 1 26,710 22,425 1 Complete 2 ✓ M 1✓81 58
BudgIT Heap 222 1 169,483 9,5021 Under 2 × ś 0 ś123 722 Complete 2 ✓ A 1✓
PKK_Steganography Heap 184 1 182,333 114,543 1 Complete 1 ✓ A 1✓102 178
ASCII_Content_Serve Heap 277 1 1,377,145 489,714 1 Complete 1 ✓ A 1✓174 551
electronictrading Internal 90 2 595,381 10,800 1 Under 2 ✓ M 1✓49 186
Internal 699 2 706,641 83,4241 Under 3 × ś 0 ś
477 303 SCUBA_Dive_Logging 2 Under 2 × ś 0 ś
3 Under 1 ✓ M 1✓
Internal 583 6 999,709 131,2561 Under 3 × ś 0 ś
612 1,432CGC_Planet_Mark_ 2 Under 5 × ś 0 ś
Language_Parser 3 Under 3 × ś 0 ś
4 Under 6 × ś 0 ś
Square_Rabbit Global 593 1 2,917,848 837,835 1 Complete 1 ✓ A 1✓484 605
TAINTEDLOVE Global 52 1 201,339 100,849 1 Under 1 ✓ A 1✓29 73
stream_vm Global 136 1 101,184 100,145 1 Complete 1 ✓ A 1✓67 76
Total 4 8,756 34 11,831,264 6,665,987 36 15+21 76 25+11 25+11 30 25+0 5,515 5,620
Avg. ś 350 1.4 473,251 266,639 ś ś 3.04 ś ś 1.2 ś 221 225
thenumberofinstructionsisreducedfrom2( #InsinBufferOver-
flow)to1(#InsinPlusAccompanying ).(2)Someinstructionsindeed
do not produce the buffer overflow. For example, in the program
CGC_Planet_Mark_Language_Parser ,allthefalsepositivesarere-
duced(#InsinPlusAccompanying ).
Since our approach requires passed and failed executions, its
effectiveness depends on the testcases. For example, in program
CGC_Planet_Markup_Language_Parser , our approach fails to lo-
cate buffer overflow vulnerabilities. This is because the program
contains many specialchecks in the markup language parser,and
AFL does not generate passed test cases to cover the data structure
overflowed (i.e., struct City).Sinceour approach does notrecover
the memory layoutofstruct Cityinpassed executions,we fails to
locate its buffer overflowinfailedexecution.
ColumnTimeshowsthetimeoverhead.Theheading Selectshows
the time for selecting passed test cases, while Locatefor locating
bufferoverflowvulnerabilities(includingrecoveringmemorylay-
outs,computing data dependencies,andlocating vulnerabilities).
Summary. Ourexperimentalprogramsinclude4typesofvul-
nerabilities (Column Type): 9 stack buffer overflows, 10 heap buffer
overflows, 3 internal data structure overflows, 3 global memory
bufferoverflows,whichshowthediversityofvulnerabilities.ForTable 2:TriageProgram Crash on five real-world programs
NameTestCases TraceLengthAFL Our Approach#passed #failed #Passed #Failed
objdump-2.26 1,475 73 166,802 235,657 59 4(61, 8,3,1)
readelf-2.28 1,780 119 162,662 68,088 69 3(102,15, 2)
ld-2.24 1,274 117 1,504,274 1,334,977 90 6(45, 28, 12, 12, 3,1)
c++filt-2.26 1,861 23 17,708 4567 18 3(21, 1,1)
tiff2bw-3.9.7 1,846 121 1,131,200 1,102,423 84 3(111,6,4)
each vulnerable memory layout, we locate 3 .04 instructions on
average. In the beginning, we reports 25 true positives and 11 false
positives ( RootinBuffer Overflow ). After applying the proposed
eliminationstrategies,25errorsareconfirmed,andallof11false
positives are eliminated ( RootinPlus Accompanying ). The average
time for selecting passed test cases and locating vulnerabilities are
221and225seconds.Theresultsshowthatourapproachiseffective
to locate buffer overflowvulnerabilities.
5.3.3 TriageProgramCrashes. AsdescribedinSection1,triaging
program crashes is very important in the program analysis and de-
bugging.Intheexperiments,weusethefuzzingsystemtogenerate
a number of program crashes, many of which are caused by the
same vulnerability but AFL is not able to distinguish them. Our
91045
1046
1047
1048
1049
1050
1051
1052
1053
1054
1055
1056
1057
1058
1059
1060
1061
1062
1063
1064
1065
1066
1067
1068
1069
1070
1071
1072
1073
1074
1075
1076
1077
1078
1079
1080
1081
1082
1083
1084
1085
1086
1087
1088
1089
1090
1091
1092
1093
1094
1095
1096
1097
1098
1099
1100
1101
1102ESEC/FSE2019, 26–30August,2019, Tallinn,Estonia Haijun Wang,XiaofeiXie, Shang-Wei Lin, Yun Lin, Yuekang Li, ShengchaoQin, Yang Liu, andTing Liu
1103
1104
1105
1106
1107
1108
1109
1110
1111
1112
1113
1114
1115
1116
1117
1118
1119
1120
1121
1122
1123
1124
1125
1126
1127
1128
1129
1130
1131
1132
1133
1134
1135
1136
1137
1138
1139
1140
1141
1142
1143
1144
1145
1146
1147
1148
1149
1150
1151
1152
1153
1154
1155
1156
1157
1158
1159
1160approach can help to triage program crashes based on the root
causes ofvulnerabilities.
Since multiple instructions may lead to the same vulnerable
memory layout (e.g., #InsinBuffer Overflow ), we decided to use
a more coarse-grained granularity, i.e., we use functions where
blamed instructions reside as blamed functions. Thus, in our ex-
periment, we identify the root causes based on vulnerable memory
layoutsandblamedfunctions[6].
Table 2 shows the results of five real-world programs with total
453 program crashes. Column Nameshows the program name.
ColumnTest Cases lists the number of test cases, where #Passed
and#Failedrepresent the number of passed and failed test cases,
respectively. Column Trace Length lists the average number of
instructionsintheexecution.Thelasttwocolumnsshowtheresults
oftriaging program crashes.
Summary. ColumnAFLlists the number of unique program
crashestriagedbyAFL.Column OurApproach showstriagingre-
sults of our approach, where the first number is the number of
groups, and the numbers in the brackets represent the number
of crashes in each group. For example, 4 (61,8,3,1)represents 73
crashes are classified into 4 groups, which include 61, 8, 3 and 1
crashes,respectively.Wemanuallycheckthecrashesforallgroups
andconfirmthatourtriagingresultsarecorrect.ComparedtoAFL,
ourapproachhelpstoreducethenumberofuniqueprogramcrashes
significantly.Thus,itcansavemanualresourcesforanalyzingthem.
There are 16 crashes that are not grouped in program ld-2.24, as
ourapproachfailsto locatetheirvulnerabilities. We lookclosely
into this program, and these 16 crashes are due to the null pointer
dereference,whichisoutofthe scope ofthis work.
6 RELATED WORK
6.1 Reverse Engineering
Reverseengineeringofdatastructuresisanactiveareainbinary
code analysis [ 39ś43]. Thomas and Gogul [ 12] also proposed an
approachtorecovermemory ranges of variablesinbinary code. Its
maindifferencefromoursisthattheyrecovermemoryinformation
using static analysis (value-set analysis), while we use dynamic
execution information. Our results are under-approximated and
theirs are over-approximated. Our under-approximated memory
layoutintroduceslessfalsenegativesandfalsepositivesinlocating
buffer overflow vulnerabilities. Built on the work [ 12], Brumley et
al.developed TIE [ 13], which recovers the memory information
ofdatastructuresandtheirtypes.TIEhasthesamelimitationsas
work [12] when usedfor locating buffer overflowvulnerabilities.
Linetal.proposedRewards[ 14],thereverseengineeringofdata
structures using dynamic analysis. It infers the types of data struc-
tures basedon arguments ofwell-knownfunctions (e.g.,asystem
call).However,ourapproachrecoversmemorylayoutsbasedonthe
memoryaddressingmodel.Hence,Rewardsonlyrecoversasmall
portionofdatastructures[ 15],andourapproachismoregeneral
for data structures.
Slowinska et al.developed Howard [ 15,16], which is the closest
worktoours.However,therearestilltwomaindifferences.Thefirst
isthatHowardmaymissinternallayoutsofdatastructuresinsome
cases even they are accessed in the execution. Howard [ 15] onlyrecords a base pointer for each memory access. It may miss the in-
ternallayoutsinthecasewherememoryaddressiscomputedbased
onmultiplebaseaddresses.TakethememoryaccessatLine12in
Fig2forexample,Howardconsidersitsbasepointeris ptr.How-
ever,itsmemoryaddressiscomputedbasedon ptr,stuandname.
Hence, Howard misses the internal layouts. Thesecond difference
is that Howard detects arrays which are accessed in loops while
ourapproachcanrecoverarraysgenerallybasedonthememory
addressingmodel.Thus,ourapproachismoregeneraltorecover
the fine-grainedlayoutsof data structures.
6.2 Locating Vulnerabilities
Sourcecodeanalysis. Therehasbeenlotsofworkaimingatlocat-
ingvulnerabilitiesinsourcecode(e.g.,[ 53ś56]).AddressSanitizer[ 1]
is a widely used tool inpractice. It instruments aprogram, inserts
undefined memory (i.e., redzones) between the objects and detects
an access to the undefined memory. DieHard [ 53] and its successor
DieHarder [ 54] populate newly allocated memory and freed mem-
orywithmagicvalues.Theyalsoaddredzonesaroundtheallocated
memoryregiontodetectthespatialerrors.ThetoolsSoftBound[ 2],
CETS [4] and LowFat [ 55,56] keep track of per-pointer capability
andcheckscapability when accessingan object.
Althoughthesetechniquescanalsolocatebufferoverflows,they
are applicable to different scenarios (i.e., source code vs.binary
code).Sincethesourcecode isnotalwaysavailable,ourapproach
isapplicabletomorescenarios.Inaddition,somesourcecodebased
techniquesdonotrecognizetheinternalstructuresofdatastruc-
tures, such as AddressSanitizer. Hence, they cannot locate internal
overflow within a data structure. Since our approach recovers fine-
grainedmemory layouts of variables, this is not anissue anymore.
Binarycodeanalysis. Locatingvulnerabilitiesinbinarycode
has also been widely studied [ 57ś62]. Valgrind Memchecks [ 3]
usesthe validvaluebitand addressbitin shadowmemorytocap-
ture reading undefined memory and out-of-bounds access. Besides,
Valgrind’s extension SGCheck also wants to locate stack buffer
overflows,however,itstillneedsthehelpofdebuginformation.Dr.
Memory [ 59] is similar to Valgrind Memchecks in many ways. It is
further equipped with a multi-threaded binary translation system.
Purify[60]shadowseverybyteofmemorywithatwo-bitvaluethat
encodesone ofthree states:unaddressable,writable, andreadable.
These techniques locate heap buffer overflow without false posi-
tives,whichisachievedbyourapproachaswell.Duetothelackof
programsemanticsinbinarycode,itisverydifficulttoidentifythe
boundaries of variables in stack and global memory regions. Thus,
noneofthesetechniquescanlocatebufferoverflowwithinthestack
and globalmemory regions[ 1]. To the best of our knowledge,our
approach isthe firstwork to achieve this goalinbinary code.
7 CONCLUSION
In this work, we propose an approach to locate buffer overflows in
binarycode.Wefirstrecoversthememorylayoutsbasedonmemory
addressing model together with dynamic execution information.
Then, based on the recovered memory layouts we locate buffer
overflowvulnerabilities.
101161
1162
1163
1164
1165
1166
1167
1168
1169
1170
1171
1172
1173
1174
1175
1176
1177
1178
1179
1180
1181
1182
1183
1184
1185
1186
1187
1188
1189
1190
1191
1192
1193
1194
1195
1196
1197
1198
1199
1200
1201
1202
1203
1204
1205
1206
1207
1208
1209
1210
1211
1212
1213
1214
1215
1216
1217
1218LocatingVulnerabilities in Binaries via
MemoryLayoutRecovering ESEC/FSE2019, 26–30August,2019, Tallinn,Estonia
1219
1220
1221
1222
1223
1224
1225
1226
1227
1228
1229
1230
1231
1232
1233
1234
1235
1236
1237
1238
1239
1240
1241
1242
1243
1244
1245
1246
1247
1248
1249
1250
1251
1252
1253
1254
1255
1256
1257
1258
1259
1260
1261
1262
1263
1264
1265
1266
1267
1268
1269
1270
1271
1272
1273
1274
1275
1276REFERENCES
[1]K. Serebryany, D. Bruening, A. Potapenko, and D. Vyukov, łAddresssanitizer: A
fast address sanity checker.ž in USENIX Annual Technical Conference , 2012, pp.
309ś318.
[2]S. Nagarakatte, J. Zhao, M. M. Martin, and S. Zdancewic, łSoftbound: Highly
compatible and complete spatial memory safety for c,ž ACM Sigplan Notices ,
vol. 44,no. 6,pp. 245ś258, 2009.
[3] N.NethercoteandJ.Seward,łValgrind:aframeworkforheavyweightdynamic
binary instrumentation,ž in ACM Sigplan notices , vol. 42, no. 6. ACM, 2007, pp.
89ś100.
[4]S.Nagarakatte,J.Zhao,M.M.Martin,andS.Zdancewic,łCets:compilerenforced
temporal safety for c,ž in ACM Sigplan Notices , vol. 45, no. 8. ACM, 2010, pp.
31ś40.
[5]X. Meng and B. P. Miller, łBinary code is not easy,ž in Proceedings of the 25th
International Symposium on Software Testing and Analysis . ACM, 2016, pp.
24ś35.
[6]W. Cui, M. Peinado, S. K. Cha, Y. Fratantonio, and V. P. Kemerlis, łRetracer:
Triagingcrashesbyreverseexecutionfrompartialmemorydumps,žin Proceedings
of the 38th International Conference on Software Engineering . ACM, 2016, pp.
820ś831.
[7] AFL, łAmerican fuzzylop. http://lcamtuf.coredump.cx/afl/.ž
[8]C. Lemieux, R. Padhye, K. Sen, and D. Song, łPerffuzz: automatically generat-
ingpathologicalinputs,žin Proceedingsofthe27thACMSIGSOFTInternational
SymposiumonSoftwareTestingand Analysis . ACM,2018,pp. 254ś265.
[9]C. Lemieux and K. Sen, łFairfuzz: A targeted mutation strategy for increasing
greybox fuzztestingcoverage,ž in Proceedings ofthe33rdACM/IEEE International
Conference onAutomatedSoftwareEngineering . ACM,2018,pp. 475ś485.
[10]M. Böhme, V.-T. Pham, M.-D. Nguyen, and A. Roychoudhury, łDirected greybox
fuzzing,ž in Proceedings of the 2017 ACM SIGSAC Conference on Computer and
Communications Security . ACM,2017,pp. 2329ś2344.
[11]M. Böhme, V.-T. Pham, and A. Roychoudhury, łCoverage-based greybox fuzzing
asmarkovchain,žin Proceedingsofthe2016ACMSIGSACConferenceonComputer
and Communications Security . ACM,2016,pp. 1032ś1043.
[12]G.BalakrishnanandT.Reps,łAnalyzingmemoryaccessesinx86executables,ž
inInternationalconference oncompiler construction . Springer, 2004,pp. 5ś23.
[13]J.Lee,T.Avgerinos,andD.Brumley,łTie:Principledreverseengineeringoftypes
in binaryprograms,ž2011.
[14]Z.Lin,X.Zhang,andD.Xu,łAutomaticreverseengineeringofdatastructures
from binary execution,ž in Proceedings of the 11th Annual Information Security
Symposium . CERIAS-Purdue University, 2010,p. 5.
[15]A.Slowinska,T.Stancescu,andH.Bos,łHoward:Adynamicexcavatorforreverse
engineeringdatastructures.žin ProceedingsoftheNetworkandDistributedSystem
SecuritySymposium, year=2011,organization=Citeseer .
[16]ÐÐ,łBodyarmorforbinaries:Preventingbufferoverflowswithoutrecompila-
tion.žinUSENIXAnnual TechnicalConference , 2012,pp. 125ś137.
[17] łProof,žhttps://sites.google.com/site/memorylayout/proof.
[18]J.Devietti,C.Blundell,M.M.Martin,andS.Zdancewic,łHardbound:architec-
tural support for spatial safety of the c programming language,ž ACM SIGARCH
Computer ArchitectureNews , vol. 36,no. 1,pp. 103ś114, 2008.
[19]W.N.SumnerandX.Zhang,łMemoryindexing:canonicalizingaddressesacross
executions,ž in Proceedings of the eighteenth ACM SIGSOFT international sympo-
sium onFoundationsofsoftwareengineering . ACM,2010,pp. 217ś226.
[20]J. Seo, B. Lee, S. M. Kim, M.-W. Shih, I. Shin, D. Han, and T. Kim, łSgx-shield:
Enablingaddressspacelayoutrandomizationforsgxprograms.žin Proceedings
ofthe Network and DistributedSystemSecuritySymposium , 2017.
[21]Y.Chen,M.Khandaker,andZ.Wang,łPinpointingvulnerabilities,žin Proceedings
ofthe2017ACMonAsiaConferenceonComputerandCommunicationsSecurity .
ACM,2017,pp. 334ś345.
[22]DARPA, łCyber grand challenge repository.
https://github.com/cybergrandchallenge/.ž
[23]Y.Li,B.Chen,M.Chandramohan,S.-W.Lin,Y.Liu,andA.Tiu,łSteelix:program-
state based binary fuzzing,ž in Proceedings of the 2017 11th Joint Meeting on
FoundationsofSoftwareEngineering . ACM,2017,pp. 627ś637.
[24]C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser, G. Lowney, S. Wallace, V. J.
Reddi, and K. Hazelwood, łPin: building customized program analysis tools with
dynamic instrumentation,ž in Acm sigplan notices , vol. 40, no. 6. ACM, 2005, pp.
190ś200.
[25]Y. Lu, Y. Lou, S. Cheng, L. Zhang, D. Hao, Y. Zhou, and L. Zhang, łHow does
regression test prioritization perform in real-world software evolution?ž in 2016
IEEE/ACM38thInternationalConferenceonSoftwareEngineering . IEEE,2016,
pp. 535ś546.
[26]D.Hao,L.Zhang, L.Zang,Y.Wang,X.Wu, and T.Xie,łTo beoptimalornotin
test-case prioritization,ž IEEE Transactions on Software Engineering , vol. 42, no. 5,
pp. 490ś505, 2016.
[27]L.Zhang,D.Hao,L.Zhang,G.Rothermel,andH.Mei,łBridgingthegapbetween
thetotalandadditionaltest-caseprioritizationstrategies,žin Proceedingsofthe
2013 International Conference on Software Engineering . IEEE Press, 2013, pp.192ś201.
[28]S. A. Khalek andS. Khurshid, łEfficientlyrunning testsuites using abstractundo
operations,žin 2011IEEE22ndInternationalSymposiumonSoftwareReliability
Engineering . IEEE,2011,pp. 110ś119.
[29]W. Masri and F. A. Zaraket, łCoverage-based software testing: Beyond basic test
requirements,žin AdvancesinComputers . Elsevier, 2016,vol. 103, pp. 79ś142.
[30]A. Filieri, C. S. Păsăreanu, and W. Visser, łReliability analysis in symbolic
pathfinder,žin 201335thInternationalConferenceonSoftwareEngineering . IEEE,
2013,pp. 622ś631.
[31]S.Person, G. Yang,N. Rungta,and S.Khurshid, łDirected incremental symbolic
execution,žin Acm SigplanNotices , vol. 46,no. 6. ACM,2011,pp. 504ś515.
[32]J. H. Siddiqui and S. Khurshid, łStaged symbolic execution,ž in Proceedings of the
27thAnnualACMSymposiumonAppliedComputing . ACM,2012,pp.1339ś1346.
[33]Y. Li, Z. Su, L. Wang, and X. Li, łSteering symbolic execution to less traveled
paths,žin ACMSigPlanNotices , vol. 48,no. 10. ACM,2013,pp. 19ś32.
[34]T. Xie, N. Tillmann, J. de Halleux, and W. Schulte, łFitness-guided path explo-
ration indynamic symbolicexecution,ž in IEEE/IFIPInternationalConferenceon
DependableSystems& Networks . Citeseer, 2009,pp. 359ś368.
[35]B.C.Parrino,J.P.Galeotti,D.Garbervetsky,andM.F.Frias,łTacoflow:optimizing
satprogramverificationusingdataflowanalysis,ž Software&SystemsModeling ,
vol. 14,no. 1,pp. 45ś63, 2015.
[36]C.Cadar,D.Dunbar,D.R.Engler etal.,łKlee:Unassistedandautomaticgeneration
of high-coverage tests for complex systems programs.ž in USENIX Symposium on
OperatingSystemsDesignand Implementation , vol. 8,2008,pp. 209ś224.
[37]W. Visser, C. S. Pasareanu, and S. Khurshid, łTest input generation with java
pathfinder,ž ACM SIGSOFT Software Engineering Notes , vol. 29, no. 4, pp. 97ś107,
2004.
[38]S.Anand,C.S.Păsăreanu,andW.Visser,łJpfśse:Asymbolicexecutionextension
to java pathfinder,ž in International Conference on Tools and Algorithms for the
Construction and AnalysisofSystems . Springer, 2007,pp. 134ś138.
[39]G.BalakrishnanandT.Reps,łDivine:Discoveringvariablesinexecutables,žin
InternationalWorkshoponVerification,ModelChecking,andAbstractInterpretation .
Springer, 2007,pp. 1ś28.
[40]A. Cozzie, F. Stratton, H. Xue, and S. T. King, łDigging for data structures.ž in
USENIXSymposiumonOperatingSystemsDesignandImplementation ,vol.8,2008,
pp. 255ś266.
[41]E. Dolgova and A. Chernov, łAutomatic reconstruction of data types in the
decompilation problem,ž Programming and Computer Software , vol. 35, no. 2, pp.
105ś119, 2009.
[42]X. Chen, A. Slowinska, D. Andriesse, H. Bos, and C. Giuffrida, łStackarmor:
Comprehensive protection from stack-based memory error vulnerabilities for
binaries.žin ProceedingsoftheNetworkandDistributedSystemSecuritySymposium .
Citeseer, 2015.
[43]V.Braberman,D.Garbervetsky,S.Hym,andS.Yovine,łSummary-basedinference
ofquantitativeboundsofliveheapobjects,ž ScienceofComputerProgramming ,
vol. 92,pp. 56ś84, 2014.
[44]J.A.JonesandM.J.Harrold,łEmpiricalevaluationofthetarantulaautomatic
fault-localizationtechnique,žin Proceedingsofthe20thIEEE/ACMinternational
Conference onAutomatedsoftwareengineering . ACM,2005,pp. 273ś282.
[45]D.Hao,T.Xie,L.Zhang,X.Wang,J.Sun,andH.Mei,łTestinputreductionfor
result inspection to facilitate fault localization,ž Automated software engineering ,
vol. 17,no. 1,p. 5,2010.
[46]J.ClauseandA.Orso,łLeakpoint:pinpointingthecausesofmemoryleaks,žin Pro-
ceedings of the 32nd ACM/IEEE International Conference on Software Engineering .
ACM,2010,pp. 515ś524.
[47]R. Santelices, J. A. Jones, Y. Yu, and M. J. Harrold, łLightweight fault-localization
usingmultiplecoveragetypes,žin Proceedingsofthe31stInternationalConference
onSoftwareEngineering . IEEE Computer Society, 2009,pp. 56ś66.
[48]G. K. Baah, A. Podgurski, and M. J. Harrold, łCausal inference for statistical
fault localization,ž in Proceedings of the 19th international symposium on Software
testingand analysis . ACM,2010,pp. 73ś84.
[49]B.Liblit,M.Naik,A.X.Zheng,A.Aiken,andM.I.Jordan,łScalablestatisticalbug
isolation,žin Proceedingsof ProgrammingLanguageDesign andImplementation ,
2005,pp. 15ś26.
[50]F.Keller,L.Grunske,S.Heiden,A.Filieri,A.vanHoorn,andD.Lo,łAcriticaleval-
uation of spectrum-based fault localization techniques on a large-scale software
system,žin 2017IEEEInternationalConferenceonSoftwareQuality,Reliabilityand
Security. IEEE,2017,pp. 114ś125.
[51]X.Li,M.dAmorim,andA.Orso,łIterativeuser-drivenfaultlocalization,žin Haifa
Verification Conference . Springer, 2016,pp. 82ś98.
[52]A. Perez, R. Abreu, and M. d’Amorim, łPrevalence of single-fault fixes and its
impactonfaultlocalization,žin 2017IEEEInternationalConferenceonSoftware
Testing,Verification and Validation . IEEE,2017,pp. 12ś22.
[53]E. D. Berger and B. G. Zorn, łDiehard: probabilistic memory safety for unsafe
languages,žin Acm sigplan notices , vol. 41,no. 6. ACM,2006,pp. 158ś168.
[54]G. Novark and E. D. Berger, łDieharder: securing the heap,ž in Proceedings of the
17th ACM conference on Computer and communications security . ACM, 2010, pp.
573ś584.
111277
1278
1279
1280
1281
1282
1283
1284
1285
1286
1287
1288
1289
1290
1291
1292
1293
1294
1295
1296
1297
1298
1299
1300
1301
1302
1303
1304
1305
1306
1307
1308
1309
1310
1311
1312
1313
1314
1315
1316
1317
1318
1319
1320
1321
1322
1323
1324
1325
1326
1327
1328
1329
1330
1331
1332
1333
1334ESEC/FSE2019, 26–30August,2019, Tallinn,Estonia Haijun Wang,XiaofeiXie, Shang-Wei Lin, Yun Lin, Yuekang Li, ShengchaoQin, Yang Liu, andTing Liu
1335
1336
1337
1338
1339
1340
1341
1342
1343
1344
1345
1346
1347
1348
1349
1350
1351
1352
1353
1354
1355
1356
1357
1358
1359
1360
1361
1362
1363
1364
1365
1366
1367
1368
1369
1370
1371
1372
1373
1374
1375
1376
1377
1378
1379
1380
1381
1382
1383
1384
1385
1386
1387
1388
1389
1390
1391
1392[55]G. J. Duck and R. H. Yap, łHeap bounds protection with low fat pointers,ž in
Proceedingsofthe25thInternationalConferenceonCompilerConstruction . ACM,
2016,pp. 132ś142.
[56]G. J. Duck, R. H. Yap, and L. Cavallaro, łStack bounds protection with low fat
pointers,žin SymposiumonNetwork and DistributedSystemSecurity , 2017.
[57]D.Andriesse,X.Chen,V.vanderVeen,A. Slowinska,andH.Bos,łAn in-depth
analysis of disassembly on full-scale x86/x64 binaries.ž in USENIX Security Sym-
posium, 2016,pp. 583ś600.
[58]F.Peng,Z.Deng,X.Zhang,D.Xu,Z.Lin,andZ.Su,łX-force:Force-executing
binary programs for security applications.ž in USENIX Security Symposium , 2014,pp. 829ś844.
[59]D. Bruening and Q. Zhao, łPractical memory checking with dr. memory,ž in Pro-
ceedingsofthe9thAnnualIEEE/ACMInternationalSymposiumonCodeGeneration
and Optimization . IEEE Computer Society, 2011,pp. 213ś223.
[60]R. Hastings and B. Joyce, łPurify: Fast detection of memory leaks and access
errors,žin Proceedingsofthe 1992 USENIXConference . Citeseer, 1991.
[61] Intel,łIntel inspector. https://software.intel.com/en-us/intel-inspector-xe/.ž
[62]Oracle, łSun memory error discovery tool.
https://docs.oracle.com/cd/e18659_01/html/821-1784/gentextid-302.html.ž
12