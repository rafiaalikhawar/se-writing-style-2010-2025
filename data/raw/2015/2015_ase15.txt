EfÔ¨Åcient Data Model VeriÔ¨Åcation with Many-Sorted
Logic
Ivan Boci ¬¥c and TevÔ¨Åk Bultan
Department of Computer Science
University of California, Santa Barbara, USA
fbo,bultang@cs.ucsb.edu
Abstract ‚ÄîMisuse or loss of web application data can have
catastrophic consequences in today‚Äôs Internet oriented world.
Hence, veriÔ¨Åcation of web application data models is of
paramount importance. We have developed a framework for
veriÔ¨Åcation of web application data models via translation to First
Order Logic (FOL), followed by automated theorem proving. Due
to the undecidability of FOL, this automated approach does not
always produce a conclusive answer. In this paper, we investigate
the use of many-sorted logic in data model veriÔ¨Åcation in order
to improve the effectiveness of this approach. Many-sorted logic
allows us to specify type information explicitly, thus lightening
the burden of reasoning about type information during theorem
proving. Our experiments demonstrate that using many-sorted
logic improves the veriÔ¨Åcation performance signiÔ¨Åcantly, and
completely eliminates inconclusive results in all cases over 7 real
world web applications, down from an 17% inconclusive rate.
I. I NTRODUCTION
Modern software applications have migrated from the desk-
top onto to the cloud. BeneÔ¨Åts of web applications over desktop
applications include accessibility on multiple devices anywhere
and anytime, higher availability due to redundant systems,
easier upgrades and patching etc. However, these beneÔ¨Åts
come at the cost of increased complexity, as web applications
are complex, distributed systems. Web applications typically
serve to store and manage user data. For applications such
as Healthcare.gov, Gmail, and Facebook, loss or corruption of
data would have dire consequences. Hence, veriÔ¨Åcation of how
applications manage data is of paramount importance.
We focus on a speciÔ¨Åc but widespread type of web ap-
plication that is enforced by many popular web application
frameworks (Ruby on Rails [30] for Ruby, Spring [33] for Java,
Play [28] for Scala and Java, Django [9] for Python, Sails [32]
for NodeJS etc.). These web applications employ the Model-
View-Controller [21] (MVC) pattern to make web application
development easier and modular. The data model deÔ¨Ånes the
data the application manages, as well as the methods that
are used to modify the data. The controller accepts requests,
queries and/or updates the data, and invokes the view to syn-
thesize the response. These operations are deÔ¨Åned as actions .
These web applications have the following characteristics: 1)
They are RESTful [13], meaning that actions can be invoked
any number of times and in any order; 2) Actions are (or
should be) atomic, meaning that they update the data in one
This material is based on research sponsored by NSF under grant CCF-
1423623. Part of this research was conducted while TevÔ¨Åk Bultan was visiting
Koc ¬∏ University in ÀôIstanbul, Turkey, supported by a research fellowship from
T¬®UBÀôITAK under the B ÀôIDEB 2221 program.step and revert any changes if an error is encountered; 3)
The data is manipulated only by actions, meaning that there
is no way to modify the data outside of actions; 4) The
data model is implemented using Object-Relational Mapping
(ORM) libraries that help bridge the semantic gap between
object oriented languages and relational databases. Based on
these characteristics we can verify invariants about the data
model by analyzing the object oriented code that deÔ¨Ånes the
actions, and verifying that each action preserves the invariants.
Previously, we developed a framework for veriÔ¨Åcation
of web application data models by automatically translating
veriÔ¨Åcation queries to logic formulas and then using an auto-
mated theorem prover to check these automatically generated
formulas [3], [4]. In this framework, we Ô¨Årst statically extract
a semantic data model from the web application by analyzing
the data model schema and the methods that implement the
actions. We ask the user to write data model invariants to be
veriÔ¨Åed using our invariant speciÔ¨Åcation library that provides
constructs for quantiÔ¨Åcation. For each action-invariant pair we
synthesize a Ô¨Årst order logic (FOL) theorem that is valid if
and only if the action preserves the invariant. Assuming that
the invariant is true before the action starts executing, and
specifying the way the action modiÔ¨Åes the data, the theorem
posits that the invariant must hold after the action ends its exe-
cution. We send this theorem to an off-the-shelf FOL theorem
prover to verify. Using this method on several real world web
applications, we discovered several previously unknown bugs
that the developers acknowledged and repaired [3].
Since FOL is undecidable, an automated theorem prover
may never terminate deducing, continuously producing new
deductions without reaching a proof of the theorem. This is
especially the case in the presence of complex constructs in
actions such as loops [4]. Our approach results in one of three
outcomes for each action-invariant pair: 1) a proof that the
action preserves the invariant, 2) a proof that the action can
violate the invariant, or 3) an inconclusive result, caused by the
theorem prover not reaching a conclusive answer in a speciÔ¨Åed
time period.
Minimizing the ratio of inconclusive results is a necessary
step for making our approach usable in practice. In order to
understand the causes of inconclusive results, we investigated
the logs of the theorem prover we used in our experiments
(Spass [41]). We noticed that the theorem prover did an
excessive number of deductions solely to reason about the
types of quantiÔ¨Åed variables and objects. Since FOL does not
have a notion of type, our FOL translation generates predicatesthat encode all the type information, and the theorem prover
was spending a lot of time deducing about these predicates.
In order to address this problem, we looked into using
many-sorted logic for data model veriÔ¨Åcation. In many-sorted
logic, sorts (i.e., types) are explicitly associated with all
variables, functions and predicates. Our intuition was that using
sorts will beneÔ¨Åt veriÔ¨Åcation because it mitigates the necessity
of deducing type information. On the other hand, the semantics
of sorts and the semantics of data model classes do not match,
and this semantic mismatch makes the translation of data
models challenging especially if inheritance is present in the
data model.
In addition to dealing with inheritance, there is one more
complication in translation to many-sorted logic. Classical
FOL (i.e., FOL without sorts) deÔ¨Ånes structures (instances that
may or may not satisfy a given set of formulas) as strictly
non-empty. In our data model encoding, empty structures
represent the possibility of a particular class having no objects,
and, we want to allow empty structures since this might be
a possible behavior of the data model. Unfortunately, most
theorem provers do not allow empty structures. This problem
was not a signiÔ¨Åcant issue with our translation to unsorted
FOL since we were encoding types with predicates, and it
is possible to deÔ¨Åne a predicate that never evaluates to true
(which would encode an empty class). However, when we map
classes to sorts, the issue of empty structures must be handled
during translation which introduces extra complexity, further
distancing sorts from the data model type system.
In order to compare the performance of the unsorted FOL
(i.e., FOL without sorts) translation with the many-sorted logic
translation we used Spass and Z3. We compared the perfor-
mance between Spass (using the unsorted FOL translation)
and Z3 (using the many-sorted logic translation) by extracting
a total of 3184 veriÔ¨Åable action-invariant pairs and translating
them to formulas for Spass and Z3. We observed that veriÔ¨Å-
cation results for Z3 were signiÔ¨Åcantly better. We found that
Z3 outperformed Spass in all cases, successfully verifying all
the action-invariant pairs whereas Spass had an inconclusive
result rate of 17%. In addition, we observed a speedup of two
orders of magnitude over Spass. This performance difference
was beyond our expectations.
However, looking just at these results, it is not possible
to attribute the performance improvement to the beneÔ¨Åts of
many-sorted logic translation over the unsorted FOL transla-
tion. Spass and Z3 use different deduction methods, which
could be the cause of the performance difference. Or, the
performance difference could even be due to differences in the
implementations and optimizations of the different provers.
In order to determine the cause of the performance differ-
ence we developed a translation of the data model to many-
sorted logic that effectively bypasses the sort system. We re-
ran our experiment suite on Z3 with this unsorted translation.
We found that the unsorted translation induced a 3.67%
inconclusive result rate, and slowed down veriÔ¨Åcation by two
orders of magnitude. While Z3 and Spass use fundamentally
different approaches to theorem proving, we posit that sorts
are inherently useful in data model veriÔ¨Åcation.
The rest of the paper is organized as follows. Section II
presents an overview of our approach through examples.
Account Contact
Taggable Commentable
Tag Comment0..*
taggings
0..*
tags1
commentable
0..*
comments0..1
account0..*
contacts(a) Data model schema.
1class CommentsController
2 ...
3 def destroy
4 @comment = Comment.find(params[:id])
5 @comment.destroy
6 respond_with(@comment)
7 end
8 ...
9end
(b) Destroy Comment action.
Fig. 1. A data model example based on FatFreeCRM [12].
Section III deÔ¨Ånes FOL, focusing on the differences between
unsorted, many-sorted and empty logics. Section IV deÔ¨Ånes the
type system of data models. Section V explains the translation
of data models into different variants of Ô¨Årst order logic. In
Section VI we evaluate how use of these different logics affect
veriÔ¨Åcation feasibility and performance. Section VII discusses
related work, and Section VIII concludes the paper.
II. O VERVIEW
FatFreeCRM [12] is an open source web application for
customer relationship management written in Ruby on Rails.
Figure 1 contains an excerpt from the data model of this
application. Figure 1(a) deÔ¨Ånes a portion of the data model
schema. In FatFreeCRM Account objects can have any number
of Contacts. Both Accounts and Contacts are Taggable and
Commentable. Even though Taggable and Commentable are
implemented using mixins, we treat them as normal classes
in our abstraction. Commentable objects have any number of
Comments, and every Comment is attached to a Commentable.
Taggable objects can have any number of Tags, and Tags can
be attached to any number of Taggables.
Data models also specify behaviors via actions, i.e., they
specify how the data are modiÔ¨Åed. Figure 1(b) shows an
example action from the FatFreeCRM. This action is taken
from the CommentsController and it deletes the comment
whose idis provided by the user. Line 4 reads this identiÔ¨Åer
from the request ( params[:id] ), looks up the comment for this
id(using Comment.find(...) ), and assigns the return value to
a variable called @comment . Line 5 deletes this comment and
line 6 synthesizes the response.
In our framework, data models are veriÔ¨Åed by synthesizing
formulas in Ô¨Årst order logic (FOL) in order to answer the
following question: After deÔ¨Åning the model schema, and
assuming that all invariants about the data model hold before
the action, and taking into account all possible behaviors of the
action, do the invariants still hold after the action‚Äôs execution?
The generated FOL formula is valid if and only if the answer
to this question is afÔ¨Årmative.For example, Figure 2 presents a translation of the data
model schema from Figure 1(a) to FOL. We deÔ¨Åne 6 predicates
for this purpose: Account, Contact, Taggable, Commentable,
Tag, and Comment. We deÔ¨Åne that all Accounts are Taggable
and Commentable (Formula (1)) and that all Contacts are
Taggable and Commentable (Formula (2)).
It is useful to deÔ¨Åne a predicate that denotes that an object
is precisely of a class and not of a subclass. This is not trivial
to express since, for example, Accounts are simultaneously
Taggable but the reverse might not be the case. To that end,
we introduce 2 predicates: Taggable xandCommentable x.
We deÔ¨Åne these predicates in Formulas (3) and (4). With these
predicates we can deÔ¨Åne that every object is an instance of at
most one class (Formulas (5)-(10)). These formulas imply that,
for example, an object could be simultaneously Taggable and
Commentable, but not Commentable and a Comment.
Predicates: Account ,Contact ,Taggable ,Commentable ,Tag ,Comment ,
Taggable x,Commentable x.
8o: Account( o)!Taggable( o)^Commentable( o) (1)
8o: Contact( o)!Taggable( o)^Commentable( o) (2)
8o: Taggable x(o)$
Taggable( o)^:Account( o)^:Contact( o) (3)
8o: Commentable x(o)$
Commentable( o)^:Account( o)^:Contact( o) (4)
8o: Account( o)!: Contact( o)^:Taggable x(o)^
:Commentable x(o)^:Tag(o)^:Comment( o) (5)
8o: Contact( o)!: Account( o)^:Taggable x(o)^
:Commentable x(o)^:Tag(o)^:Comment( o) (6)
8o: Taggable x(o)!: Account( o)^:Contact( o)^
:Commentable x(o)^:Tag(o)^:Comment( o)) (7)
8o: Commentable x(o)!: Account( o)_:Contact( o)^
:Taggable x(o)^:Tag(o)^:Comment( o) (8)
8o: Tag( o)!: Account( o)^:Contact( o)^
:Taggable x(o)^:Commentable x(o)^:Comment( o) (9)
8o: Comment( o)!: Account( o)^:Contact( o)^
:Taggable x(o)^:Commentable x(o)^:Tag(o) (10)
Fig. 2. Axioms deÔ¨Åning the class diagram in Figure 1(a) in classical
(unsorted) Ô¨Årst order logic.
The fact that these 10 formulas need to be explicitly
stated just to implement these types in FOL demonstrates
the semantic gap between the object oriented paradigm and
FOL. Generating these formulas from a data model is doable,
however, they indicate a potential performance problem during
theorem proving. Since the theorem prover does not treat types
of variables as integral parts of them, every formula that the
theorem prover deduces will need to be additionally processed
to deduce the possible types of involved entities. And indeed,
upon inspecting the deduction logs of the theorem prover we
use (Spass), we found that the theorem prover frequently takes
steps to deduce types of entities.
Deduction about types is largely unnecessary in our case.
When constructing formulas that deÔ¨Åne actions and invariants
we have speciÔ¨Åc types in mind. We would be able to provide
this type information explicitly if the underlying logic sup-
ported type declarations. This would lessen the burden of the
theorem prover and possibly drastically reduce the number of
deductions necessary.
Many-sorted logic is a variant of FOL that supports explicit
type information. In addition, there exist automated theorem
provers that accept many-sorted logic and, as our experiments
demonstrate, can use the sort information to increase veriÔ¨Åca-
tion performance and viability.
Many-sorted logic supports sorts , or types, that are associ-
ated with all predicates, functions and variables. Sorts implymutually disjoint sets of elements (e.g., an element of sort A
and an element of sort B can never be equal). Many-sorted
logic does not support subsorts, and every domain element
is always of a single sort. A formal deÔ¨Ånition is given in
Section III.
We developed a translation of data models to many-
sorted logic. Figure 3 shows the speciÔ¨Åcation of the data
model in Figure 1(a) within the many-sorted logic. Since sorts
imply mutually exclusive types, and classes Account, Contact,
Commentable and Taggable are related through inheritance,
we cannot use sorts alone to deÔ¨Åne this data model. Instead,
we introduce a single sort (called Cluster) and four unary
predicates Account, Contact, Commentable and Taggable that
accept an argument of this sort. We use these predicates to refer
to these classes directly. On the other hand, Tag and Comment
are classes that are unrelated to others through inheritance, and
as such we can use sorts alone to denote their types.
Formulas (1) and (2) specify that all Cluster objects are
Commentable and Taggable. Note that this could have been
speciÔ¨Åed in a simpler way, but the example corresponds to the
result of our method presented in Section V. Formulas (3)
and (4) deÔ¨Åne predicates Taggable xand Commentable x.
Formulas (5)-(8) deÔ¨Åne that, within the Cluster, no object can
be an instance of more than one type.
Sorts: Cluster ,Tag ,Comment .
Predicates: Account(Cluster) ,Contact(Cluster) ,
Taggable(Cluster) ,Taggable x(Cluster) ,
Commentable(Cluster) ,Commentable x(Cluster) .
8Cluster o: Account( o)!Taggable( o)^Commentable( o) (1)
8Cluster o: Contact( o)!Taggable( o)^Commentable( o) (2)
8Cluster o: Taggable x(o)$
Taggable( o)^:Account( o)^:Contact( o) (3)
8Cluster o: Commentable x(o)$
Commentable( o)^:Account( o)^:Contact( o) (4)
8Cluster o: Account( o)!
:Contact( o)^:Taggable x(o)^:Commentable x(o)(5)
8Cluster o: Contact( o)!
:Account( o)^:Taggable x(o)^:Commentable x(o)(6)
8Cluster o: Taggable x(o)!
:Account( o)^:Contact( o)^:Commentable x(o) (7)
8Cluster o: Commentable x(o)!
:Account( o)^:Contact( o)^:Taggable x(o) (8)
Fig. 3. Axioms deÔ¨Åning the class diagram in Figure 1(a) in many-sorted
logic.
The translation in Figure 3 may not seem like an im-
provement over the translation in Figure 2. However, not only
is the part deÔ¨Åning exact type exclusivity shorter in case of
many-sorted logic (4 instead of 6 axioms), but these axioms
are also shorter (4 instead of 6 conjuncts implied). Also, the
difference between the two translations increases if inheritance
is rarely used. In case of no inheritance in the data model, no
axioms are necessary to model the data model schema. Out
of 25 most starred Ruby on Rails applications on Github only
7 employ inheritance, and on average, only 23% of classes
inherit or are inherited from other classes. We further discuss
these differences in Section V.
There exists another problem with data model veriÔ¨Åcation
using FOL. In FOL, a structure can loosely be deÔ¨Åned as an
instance that may satisfy a given FOL formula. Classical FOL
is deÔ¨Åned in such a way that the structure cannot be empty
(more precisely deÔ¨Åned in Section III-C). This is not suitable
for our purposes. An empty structure corresponds to no objects
existing in the data store, which is a possible state that we
want to be considered by the theorem prover. We remedy thisby introducing new predicates that enable us to deÔ¨Åne a type
system that allows empty domains (discussed in Section V-B).
III. F IRST ORDER LOGIC
In this section we give an overview of Ô¨Årst order logic
(FOL). DeÔ¨Ånitions in this section are based on [11], but
simpliÔ¨Åed where possible for brevity. After discussing classical
FOL, we describe two variants of FOL called many-sorted
logic (Section III-B) and empty logic (Section III-C).
A. First Order Logic
A FOL language Lis a tuplehF; P; Viwhere Fis a set
offunction symbols, Pis a set of predicate symbols, Vis a
set of variable symbols. All function and predicate symbols
are associated with their arities , which are positive integers
denoting the number of arguments they accept1.
Given a FOL language L=hF; P; Vi, aterm is a variable
v2Vor a function invocation f(t1; t2: : : tk)where f2F
andt1: : : tkare terms and kis the arity of function f.
A (well formed) FOL formula is deÔ¨Åned as either:
p(t1; : : : t k), where p2Pis a predicate of arity kand
t1: : : tkare terms
 8 v:f, where v2Vandfis a formula
 : f1,f1^f2,f1_f2where f1andf2are formulas
t1=t2, where t1andt2are terms.2
Given a FOL language L, astructure Sis an instance that
may or may not satisfy a formula expressed in this language.
More formally, it is a tuple hU; FS; PS; VSiwhere Uis a non-
empty set of elements called the universe .FSis a mapping
ofFonto a set of functions such that for every f2Fof
cardinality kthere exists an fS2FSsuch that fSis a function
that maps Uk!U. Similarly, for every predicate p2Pof
arityk, there exists a pU2PUsuch that pUUk.
We can test whether a structure SsatisÔ¨Åes a formula
(whether the formula is true within this structure). To do
this we assign elements of Uto all terms in the formula.
Each variable v2Vis assigned an element vS2U.
Term f(t1: : : tk)is mapped to the return value of fUwhen
using elements of Uassigned to terms t1: : : tkas arguments.
Similarly, p(t1; : : : t k)is considered to be true if and only if
elements corresponding to t1: : : tkform a tuple that is in PU.
Boolean connectives and equality are interpreted in a standard
way. Universal quantiÔ¨Åcation is a bit more involved: 8v:fis
satisÔ¨Åed by Sif and only if, for every structure S(vje)that
is identical to Sexcept that vwas assigned a (potentially
different) element eofU,fis satisÔ¨Åed by S(vje).
A formula that is satisÔ¨Åed by one structure may not be
satisÔ¨Åed by another. For example, x=yis true for all
structures that happen to map variables xandyto the same
element. A formula 8x: (8y:x=y)is true if and only if U
is a singleton set. If a formula is satisÔ¨Åed by all structures, we
call this formula valid . E.g. x=xis a valid formula.
1We may extend this to introduce constants as functions of arity 0 and
propositional variables as predicates of arity 0.
2Although classical FOL does not include equality, since the theorem
provers we use operate on FOL with equality, we include equality in our
deÔ¨Ånition of FOL.We take note of free variables : variables that are not
quantiÔ¨Åed outside the term in which they appear. For example,
8x:x=yhas one free variable y. Since the theorem provers
we use do not allow free variables, from this point on, we will
only consider formulas without free variables.
B. Many-Sorted Logic
Sometimes it is useful to divide the universe of a structure
using types with mutually exclusive domains. This is especially
true if the functions and predicates make sense only within a
speciÔ¨Åc domain.
Types in many-sorted logic are called sorts . Many-sorted
logic allows us to explicitly declare the types of all function
and predicate arguments, function return values and variables.
It also gives us the ability to quantify over elements of a given
type instead of over the whole universe.
Formally, many-sorted logic is very similar to classical
FOL. In addition to everything discussed previously, Lin-
cludes a set of sorts S. Functions and predicates in Fand
Prespectively deÔ¨Åne the sorts of their arguments, functions
deÔ¨Åne the sort of their return value, and all variables are
associated with a sort from S. We also require all formulas
to be well typed (e.g. a predicate can only accept a term as an
argument if the term‚Äôs sort matches the predicate‚Äôs declaration).
A structure Sin many-sorted logic does not contain a single
universe U. Instead, it contains a non-empty universe Usfor
each sort s2S. For each predicate pof sorts s1: : : s kand
arityk, we deÔ¨Åne PSas a subset of Us1 USk. The
setFUis deÔ¨Åned analogously, and VUassigns an element
of a variable‚Äôs sort to each variable. QuantiÔ¨Åcation is always
done over a speciÔ¨Åc sort‚Äôs universe. For clarity, we explicitly
declare the sort sof a variable vwhen quantifying by using
the notation8s v:f.
Note that many-sorted logic and unsorted logic have
equivalent expressive power [5]. Given a set of many-sorted
formulas, a similar set of unsorted formulas is equisatisÔ¨Åable if
we introduce predicates used to denote sorts and conjoin the
formulas that partition the universe to these sorts. Unsorted
logic can be translated to many-sorted logic by introducing a
single sort that applies to all language elements.
C. Empty Logic
FOL universes are usually deÔ¨Åned to be non-empty. Allow-
ing the special case of an empty universe makes deÔ¨Ånitions
more complicated. Treatment of variables and function return
values becomes problematic because terms are expected to take
a value of one element of the universe. This is not possible in
empty universes.
Furthermore, the possibility of an empty universes breaks
certain fundamental rules about FOL. E.g. 8x:x6=xis
normally an unsatisÔ¨Åable formula. If we deÔ¨Åne quantiÔ¨Åcation
over an empty universe to be vacuously true (as there does not
exist an assignment of the variable that does not satisfy the
subformula), this example formula is satisÔ¨Åed by a structure
with an empty universe.
Empty universes are a useful concept for data model
veriÔ¨Åcation. In general, a data model state may contain noobjects. This is an important consideration for data model
veriÔ¨Åcation (e.g. does the application behave properly even
if there exist no Users or Accounts?). For this reason it is
necessary to consider empty universes as a possibility during
veriÔ¨Åcation. As one would expect, other data model veriÔ¨Åcation
tools, such as Alloy [17], support empty domains.
Empty logic is a variant of FOL that allows empty uni-
verses. The treatment of empty universe in empty logic is
deÔ¨Åned by Quine [29]: universal quantiÔ¨Åcation over an empty
set is considered vacuously true (since there exists no coun-
terexample variable assignment), and existential quantiÔ¨Åcation
over an empty set is considered vacuously false (since there
exists no satisfactory variable assignment).
This interpretation of quantiÔ¨Åcation over empty sorts is
in concordance with an alternative deÔ¨Ånition of universal
quantiÔ¨Åcation: Given a universe U, quantiÔ¨Åcation8v:fcan
be unrolled into a conjunction of all formulas that result from
replacing vinfwith an element of U. In case of an empty
universe, this list of quantiÔ¨Åed formulas is empty, and the
neutral element of conjunction is the boolean true .
In combination with many-sorted logic, empty logic allows
a sort‚Äôs universe to be empty. Although theorem provers we
use during veriÔ¨Åcation do not support empty logic, in our
translation of data models to FOL, we simulate the empty
logic semantics so that the resulting translation covers the data
model behaviors where data classes can be empty (i.e., without
any instances). We discuss our formalization of the data models
and how we deal with many-sorted logic and empty universes
in our translation to FOL in the following sections.
IV. D ATA MODELS
In this section we formally deÔ¨Åne our data models. This
deÔ¨Ånition is an extension of the model deÔ¨Åned in our previous
work [3]. This extended formulation supports multiple inheri-
tance among data model classes.
a) Data Stores: A data store is a structure DS =
hC; R; A; Iiwhere Cis a set of classes, Ris a set of relations,
Ais a set of actions, and Iis a set of invariants.
The set of classes CidentiÔ¨Åes the types of objects that can
be stored in the data store. Each class can have any number of
superclasses from C(superclass( c)C) and, transitively, no
class can be a superclass of itself. We use c1< c2(c1c2)
to denote that c1is a subclass of (or equal to) c2. A relation
r=hn; co; ct; cardi2Ris deÔ¨Åned by a name n, origin class
co2C, a target class ct2Cand a cardinality constraint card
(such as one-to-one, one-to-many etc.).
b) Data Store States: Given a data store DS =
hC; R; A; Ii, the set of all possible data store states is denoted
asDS. A data store state is a structure hO; Ti2DS where
Ois a set of objects andTis a set of tuples . Objects are
instances of classes, whereas tuples are instances of relations.
Each object o2Ois an instance of a class c2Cdenoted by
c= classof( o). Each tuple t2Tis in the form t=hr; oo; oti
where r=hn; co; ct; cardi2Randclassof( oo)coand
classof( ot)ct. For a tuple t=hr; oo; otiwe refer to oo
as the origin object and otas the target object. Cardinality
constraints of each relation r2Rmust be satisÔ¨Åed by every
data store state in DS.c) Actions: Given a data store DS=hC; R; A; Ii,A
denotes the set of actions. Each action a2Acorresponds to a
set of possible state transitions (hO; Ti;hO0; T0i)DSDS.
Actions characterize updates to the data store states such as
creation or deletion of a set of objects or creation or deletion
of a set of tuples.
For example, the action in Figure 1(b) could be deÔ¨Åned
as follows. We would deÔ¨Åne that there exists a Comment that
is going to be deleted: this Comment will not exist in the
post-state, regardless of whether it existed in the pre-state. All
associations of this deleted Comment are deleted as well. This
alone is insufÔ¨Åcient, as this deÔ¨Ånition allows a behavior where
any other object is created or deleted as well. In order to deÔ¨Åne
that this one Comment is the only object affected by the action,
we explicitly deÔ¨Åne that all other Comments exist in the post
state if and only if they existed in the pre state. Similarly,
for all objects of other types, we deÔ¨Åne that they exist in the
post-state if and only if they existed in the pre-state.
d) Invariants: Given a data store DS=hC; R; A; Ii,
Iis the set of invariants. An invariant i2Icorresponds to
a Boolean function i:DS!f false;truegthat identiÔ¨Åes the
set of data store states which satisfy the invariant. We allow
the user to specify invariants in Ruby on Rails directly using a
library that we provide that supports quantiÔ¨Åcation. Invariants
are translated to FOL almost verbatim.
V. L OGICS AND THE TRANSLATION
In this section we present the translation of data models (as
deÔ¨Åned in Section IV) into different variants of Ô¨Årst order logic
(FOL). The speciÔ¨Åcs of the underlying logic (many-sorted or
not, empty or non-empty) are closely related to the way we
encode type system in FOL, as well as the way we quantify
over objects in the translation. Discussing how we handle the
data model schema and quantiÔ¨Åcation is sufÔ¨Åcient to explain
and differentiate our translation to different FOL variants. The
rest of the FOL translation is described in detail in our earlier
work [3] and will not be repeated here due to space constraints.
For brevity, we restrict the following discussion to classes
only. Although the deÔ¨Ånition of relations does differ based on
the underlying logic, they are handled in a way analogous to
how we handle classes.
Furthermore, in this section, we frequently conjoin or
disjoin a set of formulas. When a set of conjoined or disjointed
formulas is empty, we substitute the conjunction or disjunction
with their neutral elements (true and false respectively).
A. Unsorted vs. Many-sorted
In order to deÔ¨Åne the class system, for both unsorted and
many-sorted logics we deÔ¨Åne three groups of axioms: inher-
itance axioms that deÔ¨Åne superclass relationships, instance
axioms that deÔ¨Åne predicates that we can use to denote that
an object is an instance of a given class (speciÔ¨Åcally not of a
subclass), and membership axioms that deÔ¨Åne that every object
is an instance of at most one class. In this section we assume
to be given a data store DS=hC; R; A; Ii.a) Unsorted Logic: Inheritance axioms for unsorted
logic are deÔ¨Åned as follows. For each class c2Cthat has a
non-empty superclass set superclass( c) =fp1; p2: : : p kgwe
generate an axiom:
8o:c(o)!p1(o)^p2(o)^^ pk(o)
For example, given the model in Figure 1(a) this method
produces Formulas (1) and (2) in Figure 2.
Instance axioms constitute one axiom per class c2Cand
serve to deÔ¨Åne instance predicates cx. These predicates are
used to express that an object is an instance of class c, or more
explicitly, of class cbut not of any of c‚Äôs subclasses. Given
fs1: : : s kg, the set of all direct subclasses of c(all classes s
for which c2superclass( s)), we generate an axiom:
8o:cx(o)$c(o)^:s1(o)^^: sk(o)
Note that, if chas no subclasses, this axiom deÔ¨Ånes equivalence
between candcx. If this is the case, as an optimization,
we omit deÔ¨Åning cxand use cinstead. Given the model in
Figure 1(a) this creates Formulas (3) and (4) in Figure 2.
Membership axioms deÔ¨Åne that each object represents an
instance of exactly one class. Assuming that C=fc1: : : c kg,
for every class ci2C, we create an axiom in order to constrain
that, if an object is an instance of class ci, it cannot be an
instance of any other class:
8o:cix(o)!: c1x(o)^^: ci 1x(o)^:ci+1x(o)^^: ckx(o)
These formulas correspond to Formulas (5)-(10) in Figure 2.
The resulting number of generated formulas is linear in the
number of classes, and so is the size of these formulas.
b) Many-sorted Logic: Within our translation where
universe elements correspond to objects, sorts naturally serve
the purpose similar to classes. However, sorts imply disjoint
object sets, which is only suitable for classes that do not
employ inheritance. Classes that employ inheritance cannot be
directly mapped to sorts because a subclass‚Äôs object set is a
subset of a parent‚Äôs.
To work around this problem, we partition the set of all
classes into inheritance clusters . An inheritance cluster is a
maximal set of classes such that, for any two classes c1and
ckin the cluster, there exists a list of classes c1; c2; : : : c k
where each consecutive pair of classes constitutes a child-
parent or parent-child relationship. In other words, in the
class graph where vertices are classes and edges correspond
to inheritance, an inheritance cluster is a maximally connected
component. Note that all classes that do not employ inheritance
are members of singleton clusters.
For each inheritance cluster we introduce a sort that is
common to all classes in the cluster. In case of an inheritance
cluster with multiple classes we introduce predicates and
axioms in order to differentiate classes within the cluster. These
predicates and axioms are similar in purpose to the predicates
used in the unsorted logic translation. For each class cin a non-
singleton inheritance cluster we introduce unary predicates c
andcxof the cluster‚Äôs sort and introduce axioms that resemble
the ones deÔ¨Åned for unsorted logic, the key distinction being
these axioms refer to classes of that cluster only.
SpeciÔ¨Åcally, inheritance axioms are deÔ¨Åned as follows: for
each class cthat belongs to an inheritance cluster of sort sand
whose superclass set is superclass( c) =fp1; p2: : : p kg:
8s o:c(o)!p1(o)^p2(o)^^ pk(o)
For the model presented in Figure 1(a), inheritance axioms are
Formulas (1) and (2) in Figure 3.An instance axiom is generated for each class c. Let
fs1: : : s kgbe the set of c‚Äôs subclasses and let sbe the sort of
c‚Äôs inheritance cluster:
8s o:cx(o)$c(o)^:s1(o)^^: sk(o)
Given the model presented in Figure 1(a), instance axioms are
Formulas (3) and (4) in Figure 3.
Finally, membership axioms are generated for each non-
singleton inheritance cluster individually instead of for the
entire set C. Given an inheritance cluster that consists of
classesfc1; : : : c kgwhere k > 1we generate an axiom for
each class ciinside this cluster:
8s o:ci(o)!:c1(o)^^: ci 1(o)^:ci+1(o)^^: ck(o)
Formulas (5)-(8) in Figure 3 correspond to membership axioms
for the model in Figure 1(a).
The number of introduced predicates and axioms is highly
dependent on the data model in question. With no inheritance,
no additional predicates and axioms are introduced. The num-
ber and size of formulas introduced by each inheritance cluster
are linear in the number of classes in the cluster. However,
most classes do not employ inheritance in data models of real
world applications (18 out of 25 most starred Ruby on Rails
applications do not employ inheritance at all, with an average
of 23% classes involving inheritance), making most classes
part of singleton inheritance clusters. Furthermore, if multiple
non-singleton inheritance clusters exist in the data model, the
size of generated axioms is relatively small when compared to
those generated by the unsorted logic translation.
B. Empty structures
Our treatment of empty structures is dependent on whether
the underlying theory is unsorted or many-sorted. In fact, our
translation to unsorted logic as presented above allows empty
structures by default. This becomes clear when we change the
interpretation of all type predicates cto imply that the universe
element in question is of the given type, but in addition, it
exists semantically. Notice that our encoding does not require
that all universe elements are of a class type. For example, we
use universe elements to represent tuples.
Whenever we deÔ¨Åne functions and predicates in unsorted
logic we constrain argument values and the return value, if
applicable, to be of expected types. As a corollary of our
expanded interpretation, function return values objects exist
semantically if and only if arguments exist semantically and
are of corresponding types. Similarly, predicates may accept
a set of domain elements under the condition that they exist
semantically and are of corresponding types.
As for quantiÔ¨Åcation, whenever quantifying over a class
type, we introduce a condition that the subformula is relevant
only for domain elements that represent objects of the given
type. For example, in order to universally quantify over el-
ements of class cusing the variable vand a subformula f
we generate a formula 8v:c(v)!f. In case of existential
quantiÔ¨Åcation we would instead generate 9v:c(v)^f.
Predicates: PreState ,PostState ,AtComment .
8x: AtComment( x))Comment( x) (1)
8x: (8y: AtComment( x)^AtComment( y))x=y) (2)
8x: AtComment( x)): PostState( x) (3)
8x::AtComment( x))(PreState( x),PostState( x)) (4)
Fig. 4. Unsorted action translation example.For example, the action presented in Figure 1(b) can be
translated to FOL as deÔ¨Åned in Figure 4. For brevity, we
omit listing all predicates and axioms that deÔ¨Åne the type
system. In this translation, the AtComment predicate denotes
values that are saved in the @Comment variable. First we
constrain type-speciÔ¨Åc predicates to refer to their actual types
(Formula (1)). Note that as part of our interpretation of class
type predicates, any entity accepted by the AtComment is
also accepted by Comment and therefore exists semantically.
Next, in Formula (2) we constrain that there exists at most one
element in variable AtComment , as the find method in Ruby
on Rails (line 4 in Figure 1(b)) returns at most one object.
Formulas (3) and (4) deÔ¨Åne the delete statement. For-
mula (3) deÔ¨Ånes that the objects in the @Comment variable no
longer exist after the statement (regardless of their existence
before). Formula (4) deÔ¨Ånes that all objects outside this vari-
able existed before if and only if they exist after the statement
has Ô¨Ånished executing. This particular translation allows for
an empty universe. Such a structure would have no elements
accepted by predicates Comment andAtComment .
This problem becomes more complicated with the many-
sorted logic translation. If we were to deÔ¨Åne a Comment sort
alone, then the universe of this sort would be non-empty,
meaning that at least one Comment would exist for every
sort. To go around this problem, for each such class c, we
introduce a predicate cthat accepts a single argument of c‚Äôs
sort. We do not introduce any axioms. We use these predicates
to deÔ¨Åne object sets of these classes, implying that object sets
are subsets of their corresponding universes.
Predicates: PreState Cluster (Cluster) ,PreState Comment (Comment) ,
PreState Tag(Tag) ,PostState Cluster (Cluster) ,
PostState Comment (Comment) ,PostState Tag(Tag) ,
AtComment(Comment) ,Comment P(Comment) ,TagP(Tag) .
8Comment x: AtComment( x))Comment P(x) (1)
8Comment x: (8Comment y: AtComment( x)^AtComment( y)
)x=y) (2)
8Comment x: AtComment( x))
PreState Comment (x)^:PostState Comment (x) (3)
8Comment x::AtComment( x))
(PreState Cluster (x),PostState Cluster (x)) (4)
Fig. 5. Many-sorted action translation example.
Given the example action in Figure 1(b), a many-sorted
translation can be deÔ¨Åned as in Figure 5. Note that, once
again, we omit declaring all sorts, predicates and axioms from
Figure 3 for brevity.
Notice that we introduce predicates Comment PandTagP
in addition to previously deÔ¨Åned sorts Comment andTag.
In Formula (1) we deÔ¨Åne that all elements accepted by
AtComment are also accepted by Comment P. This is nec-
essary to express since, without this axiom, there could be
an element accepted by AtComment that is not accepted by
Comment P. Formula (2) deÔ¨Ånes that there exists at most one
element accepted by AtComment . Formulas (3) and (4) deÔ¨Åne
how the delete statement transitions between the pre-state and
the post-state. These formulas are analogous to Formulas (3)
and (4) in the unsorted translation. Note that, however, these
formulas are constrained to the Comment sort. All other
sorts are handled implicitly (we do not differentiate between
their pre- and post-states). This demonstrates the beneÔ¨Åt of
introducing sorts, as the theorem prover does not need to
reason at all about other types by default.TABLE I. W EB APPLICATIONS USED IN OUR EXPERIMENTS
Application KLOC# of Model # of Action/
Classes Invariant Pairs
Copycopter 2.33 6 21
FatFreeCRM 38.79 34 480
Fulcrum 3.04 5 105
Kandan 6.10 11 20
Lobsters 4.93 13 270
Redmine 87.72 55 2024
Tracks 28.72 39 210
Empty structures are handled by this translation. For exam-
ple, a structure that represents this case would have no entities
of sort Comment be accepted by predicates Comment Pand
AtComment . Without introducing a predicate Comment P
this would not be the case.
VI. E XPERIMENTS
We conducted two sets of experiments. Both these exper-
iments involved data store veriÔ¨Åcation of 7 real world web
applications: Copycopter [6], FatFreeCRM [12], Fulcrum [15],
Kandan [19], Lobsters [23], Redmine [31] and Tracks [39].
We extracted the data models from these applications fully
automatically [3] and we wrote the invariants to be veriÔ¨Åed
manually. Statistics about these applications are summarized in
Table I. Note that KLOC refers to the number of lines of code
in Ruby, excluding JavaScript and domain-speciÔ¨Åc languages.
In addition to these 7 applications, we separately tested
our tool on applications and actions that employ loops. In
our experience, loops are the most difÔ¨Åcult construct to verify,
where even the presence of loops with empty iteration bodies
may cause timeouts [4]. This data set is useful to test how
sorts help with highly complex problems. We included all 54
action/invariant pairs from this data set that used application-
speciÔ¨Åc invariants (and not the trivially preserved false invari-
ant).
In total we had 3184 action-invariant pairs. We refer to
these pairs as veriÔ¨Åcation cases or veriÔ¨Åcation instances. We
translated these 3184 cases into different FOL variants in order
to evaluate the performance using different provers, heuristics
and translations: a total of 12736 FOL theorems. For each
of these cases, we ran veriÔ¨Åcation with a time limit of 5
minutes. If the theorem prover did not deduce a result within 5
minutes we treated the result as inconclusive. Given that most
veriÔ¨Åcation cases terminate in a few seconds, we believe that
this is a reasonable time limit.
A. FOL Theorem Provers
As an unsorted logic theorem prover we used Spass [41].
Spass is a FOL theorem prover based on superposition calcu-
lus. While Spass supports multiple input formats, we translated
the veriÔ¨Åcation cases to Spass‚Äôs own input format [40]. Spass
tries to prove that a conjecture follows from a set of axioms
by negating the conjecture and attempting to deduce a contra-
diction. If this contradiction is found, then the conjecture is
proven to follow from the axioms.
Note that Spass supports soft sorts [41] which are different
than the sorts in many-sorted logic we discussed earlier, and
any other sort system we encountered. Soft sorts do not imply
mutually exclusive universes. In a soft sort system any universeTABLE II. V ERIFICATION PERFORMANCE SUMMARY
Method# of VeriÔ¨Åcation Time (sec) SMT Unit Propagations (#) Memory (Mb)
Timeouts Average Median Average Median Average Median Maximum
Spass (Soft sorts on) 558 (17.53%) 5.42 7.89 n/a n/a 69.00 74.45 129.30
Spass (Soft sorts off) 541 (16.99%) 5.37 7.95 n/a n/a 72.64 74.45 1686.19
Z3 (Many-sorted) 0 (0.00%) 0.05 0.03 518.77 22.00 3.12 3.47 127.16
Z3 (Unsorted) 117 (3.67%) 1.47 0.24 7704.67 42.00 741.02 33.04 30046.01
Fig. 6. VeriÔ¨Åcation time distribution.
element may be of a sort, of no sort, or of multiple sorts.
Semantically, these sorts are indistinguishable from unary
predicates. Furthermore, Spass by default infers soft sorts even
if none are explicitly speciÔ¨Åed. Spass provides a command
option that allows us to disable the soft sort system, in which
case the theorem prover treats soft sorts as unary predicates.
The differences between these soft sorts and sorts as deÔ¨Åned
in many-sorted logic have been observed before [2]. In the
following discussion, whenever we refer to sorts we refer to
sorts deÔ¨Åned by many-sorted logic. We will use ‚Äúsoft sorts‚Äù to
refer to Spass‚Äôs version of sorts speciÔ¨Åcally.
We used Z3 [8] to evaluate effectiveness of data model
veriÔ¨Åcation using many-sorted logic. Z3 is a DPLL(T) [10]
based SMT solver that deals with free quantiÔ¨Åcation and
uninterpreted functions using E-matching [7].
SMT solvers tend to support many different theories, such
as arithmetic, arrays or bitarrays. These theories are combined
in propositional logic, which serves to tie the underlying
theories without interpreting them. Instead, predicates in un-
derlying theories are treated as propositional variables, and
left to the underlying provers to be solved. Partial conclu-
sions from these underlying theories may be propagated to
other underlying provers in DPLL(T) in order to reach other
conclusions. When used only with free quantiÔ¨Åcation, free
sorts and uninterpreted functions (which is denoted as the
problem group UF), SMT solvers behave like many-sorted
logic theorem provers.
SMT solvers try to Ô¨Ånd instances that satisfy the speciÔ¨Å-
cation, so in order to prove that the conjecture follows from
axioms, we negate our conjecture and state it as an additional
axiom. The conjecture follows from the axioms if and only if
this resulting set of axioms is unsatisÔ¨Åable.
B. Spass vs. Z3 Performance
Our Ô¨Årst set of experiments compare the performance of
Spass and Z3 for the purpose of data model veriÔ¨Åcation.
These experiments were done solely to detect whether Z3 can
sometimes outperform Spass, either by reaching results thatSpass could not, or occasionally reaching them faster. If so,
our efforts in translating data models to SMT would increase
the performance and/or reduce the ratio of inconclusive results
in our data model veriÔ¨Åcation efforts, and therefore increase
the viability of data model veriÔ¨Åcation in the real world.
Our results are summarized in Table II and Figure 6 and the
performance difference was beyond our initial expectations.
Note that the Z3 (Unsorted) entries are only relevant for
the experiment discussed in the next subsection and can be
disregarded for now, as is the case for SMT Unit Propaga-
tions columns. With soft sorts enabled, Spass produced 558
inconclusive results (17.53%). With soft sorts disabled, Spass
produced 541 inconclusive results (16.99%). Interestingly, the
set of inconclusive results caused by disabling soft sorts is
a strict subset of the inconclusive results caused by enabling
soft sorts. Spass performed similarly regardless of the soft sorts
setting. For both settings, excluding timeouts, veriÔ¨Åcation took
an average of over 5 seconds per case. The median case is
just under 8 seconds. The memory consumption averaged at
around 70Mb, with the median case of 74.45Mb. Disabling
soft-sorts caused a peak of 1.6Gb memory used, whereas with
soft-sorts enabled, the peak was at 129.30Mb. In only 7 cases
did veriÔ¨Åcation with disabled soft-sorts exceed 129.30Mb.
Z3 performed far better than Spass with either heuristic.
Z3 produced no inconclusive results . On average, Z3 took
0.05 seconds to verify an action-invariant pair. In no case did
Spass outperform Z3 in terms of veriÔ¨Åcation time performance.
Furthermore, Z3‚Äôs average and median memory consumption
was under 4Mb, peaking at 127.16. Only for 4 cases did Z3
consume more memory than Spass (with or without soft sorts)
and the difference is negligible.
Figure 6 shows the distribution of the veriÔ¨Åcation cases
over the veriÔ¨Åcation time ranges for each theorem prover. For
example, the leftmost column (labeled .01) shows that Z3
produced a veriÔ¨Åcation result in less or equal than 0.01 seconds
469 times. Spass never achieved a result within this time. The
next time range is labeled .02 and shows that Z3 produced a
veriÔ¨Åcation result in more than 0.01 seconds but less or equal
to 0.02 seconds 641 times.Fig. 7. Distribution of the slowdown factor compared to (many-sorted) Z3.
TABLE III. O BSERVED SLOWDOWN COMPARED TO (MANY -SORTED ) Z3
Method Average Median Interdecile Range
Spass (Soft sorts on) 201.40 263.00 11.0 ‚Äì 274.0
Spass (Soft sorts off) 186.87 265.00 10.5 ‚Äì 276.7
Unsorted Z3 72.81 8.00 3.7 ‚Äì 51.3
We wanted to compare the performances of different
provers on case-by-case basis. For each action-invariant pair,
we calculated the relative slowdown factor induced by a prover
compared with Z3. So, for example, if an action-invariant pair
was veriÔ¨Åed 85 times slower using Spass with sorts enabled
when compared with Z3, this counts as a slowdown factor of
85. Figure 7 and Table III summarize this data.
Figure 7 contains the distribution of slowdown factors per
prover. For example, Spass (with and without soft sorts) is
most frequently 29times slower than Z3. Table III contains
additional information about this slowdown. On average, Z3
was 201.40 times faster than Spass with soft sorts on, and
186.87 times faster with soft sorts off. In the median case, Z3
was 263 and 265 times faster, respectively.
In order to estimate a range of performance increase factor
for the majority of cases, we calculated interdecile ranges of
these distributions. The interdecile range is the range of values
ignoring the lowest and highest 10% of values in the sample.
The interdecile ranges of performance increases of Z3 over
Spass with soft sorts on and off are 11.0-274.0 and 10.5-276.7
respectively. This means that, 80% of the time, Spass was one
to two orders of magnitude slower than Z3.
In summary, our translation to SMT and use of Z3 for
veriÔ¨Åcation increased the performance of veriÔ¨Åcation of our
method by two orders of magnitude, and removed all incon-
clusive results down from an inconclusive rate of around 17%.
C. Many-sorted vs Unsorted Performance
We observed a drastic improvement in our method‚Äôs per-
formance by utilizing Z3 instead of Spass. However, this
difference was beyond our expectations, and we wanted to
investigate the reason behind the performance difference. This
is hard to pinpoint since Spass and Z3 are fundamentally
different. They utilize a different approach to theorem proving
and have different optimizations and heuristics.
During manual investigation of Spass‚Äôs deduction logs we
noticed that Spass was taking a signiÔ¨Åcant amount of time
reasoning about types of quantiÔ¨Åed variables. This is true
regardless of whether soft sorts are enabled or not. This
reasoning about types would not be necessary or would bedrastically reduced if the theorem prover supported (non-soft)
sorts. Even if the model contains a larger number of classes that
inherit from one another, causing us to introduce predicates and
axioms that resemble the ones generated for unsorted logic,
this type reasoning is constrained to a smaller scope of an
inheritance cluster instead of the set of all classes.
We implemented an unsorted translation to SMT in order to
observe the beneÔ¨Åt of using sorts. Because SMT-LIB requires
all predicates and functions to be sorted, we deÔ¨Åned a single
sort (called Sort ) that we used for all language elements. Since
this single sort represents everything, we effectively provide no
explicit type information. On top of this sort(less) system we
enforce the type system using predicates and axioms using the
unsorted translation presented in Section V-Aa. Thereby we
specify the type system in a way that requires type reasoning
in a way that corresponds to the amount of information we
provide to Spass.
We ran the same suite of application models and action-
invariant pairs using the many-sorted and unsorted translations
to SMT. Table II summarizes the performance of many-sorted
and unsorted Z3 veriÔ¨Åcation. Unsorted Z3 did not produce
a conclusive result in 117 cases (3.67%). On average, many-
sorted Z3 took 0.05 seconds per case whereas unsorted Z3 took
1.47 seconds. Median values are 0.03 for the many-sorted logic
and 0.24 for the unsorted translation.
The SMT Propagations columns in Table II refer to the
number of DPLL(T) unit propagations done by the prover.
On average, the many-sorted translation required 518.77 unit
propagations before terminating, with a median number of 22.
The unsorted translation required 7704.67 propagations on the
average, with a median number of 42. If we were to, for each
case, calculate the ratio between unit propagations taken by
the unsorted translation over the number of unit propagations
taken by the many-sorted translation, we get an average of
41.90 and a median of 1.76. This means that, on average,
the unsorted translation took 41.90 more unit propagations to
terminate when compared to many-sorted translation.
Finally, the memory footprint of veriÔ¨Åcation suffered as
well. The many-sorted translation used an average of 3.12Mb
of memory per veriÔ¨Åcation case, with a median of 3.47Mb and
peaking at 127.16Mb. The unsorted translation was drastically
more demanding, with an average of 741.02Mb, median of
33.04Mb, and peaking at 30046.01 megabytes.
Figure 6 contains data for the unsorted Z3 translation in
addition to (many-sorted) Z3 and Spass results. Similarly,Figure 7 and Table III show the distribution of case-by-case
slowdown factors when comparing unsorted Z3 to many-sorted
Z3. On average, the many-sorted translation resulted in 72.81
times faster veriÔ¨Åcation compared to the unsorted translation.
The median case is 8.00, and the interdecile range is 3.7-51.3.
These results imply a large performance difference between
many-sorted and unsorted logic veriÔ¨Åcation in Z3. While this
does not imply that implementing proper many-sorted logic in
Spass would increase Spass‚Äôs performance by a similar factor,
it does indicate that the reduction of reasoning induced by
many-sorted over unsorted logic plays a signiÔ¨Åcant role in the
performance gain we observed.
Finally, in our experiments, a large majority of actions
preserve invariants. This is expected as most actions do not
affect data in a way that would invalidate invariants. This is
relevant because Z3 is optimized to Ô¨Ånd satisfying instances
(corresponding to falsiÔ¨Åcation in our encoding), and Spass is
optimized to prove valid theorems (corresponding to veriÔ¨Åca-
tion in our encoding). There were 59 veriÔ¨Åcation cases that
were proven to be invalid (i.e. falsiÔ¨Åed) by at least one prover.
In all 59, Z3 (Many-sorted) proven the case to be invalid
successfully, and in all 59, Z3 (unsorted) failed to deduce a
result. Spass (Soft sorts on) failed to prove 48 of these, and
Spass (soft sorts on) failed to prove 33 of these.
VII. R ELATED WORK
This paper‚Äôs goal is improving the performance and via-
bility of our previous work on data model veriÔ¨Åcation using
theorem provers [3], [4]. Our more recent paper [4] looks into
veriÔ¨Åcation of loops using a FOL theorem prover (Spass) and
how loop veriÔ¨Åcation can be made more viable and better
performing. That branch of research is orthogonal to this work.
Coexecutability is applicable to both many-sorted and unsorted
logic representations regardless of the solution to the empty
universe problem.
VeriÔ¨Åcation of software using theorem provers has been
explored before in projects such as Boogie [1], Dafny [22]
and ESC Java [14]. These projects focus on veriÔ¨Åcation of
languages such as C, C# and Java, whereas we focus on data
model veriÔ¨Åcation. The underlying type systems are largely
different, as their work focuses on manipulating basic types
and pointers, whereas our model is based on manipulating sets
and relations.
Alloy [17], [18] is a formal language for specifying object
oriented data models and their properties. Alloy Analyzer is
used to verify properties of Alloy speciÔ¨Åcations using bounded
veriÔ¨Åcation. Since Alloy was designed speciÔ¨Åcally for data
model veriÔ¨Åcation, it supports sorts and single inheritance.
However, it does not support multiple inheritance, which would
have to be implemented. Furthermore, the Alloy Analyzer uses
SAT-based bounded veriÔ¨Åcation techniques as opposed to our
FOL based unbounded veriÔ¨Åcation technique.
iDaVer [25], [26], [24] represents a set of techniques for
veriÔ¨Åcation of data model schemas. Among other features, it is
able to translate data model schemas into SMT for unbounded
veriÔ¨Åcation. Our models focus on behaviors in data models,
even they encompass the static data model schema. In addition,
our solution supports multiple inheritance. Their solution does
not address the problem of sorts and empty universes, makingtheir veriÔ¨Åcation unsound. Finally, their work does not delve
into the difference between logics and their implied encodings.
As part of a research effort to use Spass as the theorem
prover engine for interactive theorem proving [2], Spass was
modiÔ¨Åed to support many-sorted logic. This was done in order
to make deduction logs sort aware, which in turn makes it
possible to reconstruct readable proofs from these logs and
show them to the user for the purpose of interactive theorem
proving. They observed an increase in the number of theories
Spass could solve. However, this modiÔ¨Åcation was done for
performance reasons, making it reasonable to expect an even
larger performance gain from sorts in Spass. The source of
this Spass modiÔ¨Åcation is not available, and so we could not
include it as part of our experiments.
There are other theorem provers that can be used for data
model veriÔ¨Åcation. Vampire [20] is a high performance FOL
theorem prover that supports sorts. Snark [34] is another FOL
theorem prover, also supporting sorts. We plan to, as part of our
future work, implement automatic translation of data models
into TPTP syntax [37], [38]), the syntax of the test suite that
is used by the annual World Championship for Automated
Theorem Proving [36], [27]. This language is readable by
many theorem provers, including Spass and Z3. However,
given that many-sorted logic has only recently been added to
TPTP [35], we expect that the highest performing theorem
provers are optimized for unsorted logic. Unless the theorem
prover integrates sorts within its resolution engine, we can
expect many-sorted logic to perform no better than unsorted
logic. Support for many-sorted logic is possible to implement
syntactically (e.g., by treating sorts as predicates and implicitly
introducing axioms that deÔ¨Åne disjoint universes), however,
this would not result in the performance gains we observed.
In addition to unsorted and many-sorted logic, there exists
order-sorted logic [16]. Order-sorted logic deÔ¨Ånes a partially
ordered set of sorts, and the universes that correspond to
these sorts are such that universe of class c1is a subset
of the universe of class c2ifc1c2. While order-sorted
logic is highly similar to our data-models involving multiple
inheritance, we are not aware of theorem provers that support
it in Ô¨Årst order logic with free quantiÔ¨Åcation.
VIII. C ONCLUSION
We investigated the differences between Ô¨Årst order logic
(FOL) variants used by theorem provers and the implications
of these differences on data model veriÔ¨Åcation. We identiÔ¨Åed
two major differences: 1) the treatment of the type system, and
2) the possibility of empty structures satisfying a given FOL
theorem. We formally deÔ¨Åned these differences and devised
encodings that reconcile them for the purposes of data model
veriÔ¨Åcation.
After implementing translations based on these encodings
we observed that Z3, an SMT solver, outperformed Spass, a
FOL theorem prover, on almost all fronts. Using a many-sorted
logic translation that targets Z3, we were able to increase the
veriÔ¨Åcation performance by two orders of magnitude, while
decreasing the number of inconclusive results by one order of
magnitude. With further experiments we showed that encoding
our type system using sorts is the cause of this improvement.REFERENCES
[1] M. Barnett, B.-Y . E. Chang, R. DeLine, B. Jacobs, and K. R. M. Leino.
Boogie: A modular reusable veriÔ¨Åer for object-oriented programs. In
F. S. de Boer, M. M. Bonsangue, S. Graf, and W. P. de Roever, editors,
Proceedings of the 4th International Symposium on Formal Methods
for Components and Objects (FMCO 2005) , volume 4111 of Lecture
Notes in Computer Science , pages 364‚Äì387. Springer, 2005.
[2] J. C. Blanchette, A. Popescu, D. Wand, and C. Weidenbach. More
SPASS with isabelle - superposition with hard sorts and conÔ¨Ågurable
simpliÔ¨Åcation. In Interactive Theorem Proving - Third International
Conference, (ITP 2012), Princeton, NJ, USA, August 13-15, 2012.
Proceedings , pages 345‚Äì360, 2012.
[3] I. Bocic and T. Bultan. Inductive veriÔ¨Åcation of data model invariants
for web applications. In 36th International Conference on Software
Engineering (ICSE 2014), Hyderabad, India - May 31 - June 07, 2014 ,
pages 620‚Äì631, 2014.
[4] I. Bocic and T. Bultan. Coexecutability for efÔ¨Åcient veriÔ¨Åcation of
data model updates. In 37th International Conference on Software
Engineering (ICSE 2015) , 2015.
[5] K. Claessen, A. Lilliestr ¬®om, and N. Smallbone. Sort it out with
monotonicity - translating between many-sorted and unsorted Ô¨Årst-
order logic. In Automated Deduction - CADE-23 - 23rd International
Conference on Automated Deduction, Wroclaw, Poland, July 31 - August
5, 2011. Proceedings , pages 207‚Äì221, 2011.
[6] Copycopter, Jan. 2015. http://copycopter.com.
[7] L. de Moura and N. Bjrner. EfÔ¨Åcient e-matching for smt solvers. In
Automated Deduction - CADE-21, 21st International Conference on Au-
tomated Deduction, Bremen, Germany, July 17-20, 2007, Proceedings ,
volume 4603 of Lecture Notes in Computer Science , pages 183‚Äì198.
Springer, 2007.
[8] L. M. de Moura and N. Bj√∏rner. Z3: an efÔ¨Åcient SMT solver. In
Tools and Algorithms for the Construction and Analysis of Systems,
14th International Conference, TACAS 2008, Held as Part of the Joint
European Conferences on Theory and Practice of Software, ETAPS
2008, Budapest, Hungary, March 29-April 6, 2008. Proceedings , pages
337‚Äì340, 2008.
[9] The Web framework for perfectionists with deadlines ‚Äî Django, Feb.
2013. http://www.djangoproject.com.
[10] B. Dutertre and L. M. de Moura. A fast linear-arithmetic solver for
DPLL(T). In Computer Aided VeriÔ¨Åcation, 18th International Confer-
ence, CAV 2006, Seattle, WA, USA, August 17-20, 2006, Proceedings ,
pages 81‚Äì94, 2006.
[11] H. B. Enderton. A mathematical introduction to logic . Academic Press,
1972.
[12] Fat Free CRM - Ruby on Rails-based open source CRM platform, Sept.
2013. http://www.fatfreecrm.com.
[13] R. T. Fielding. Architectural Styles and the Design of Network-based
Software Architectures . PhD thesis, University of California, Irvine,
2000.
[14] C. Flanagan, K. R. M. Leino, M. Lillibridge, G. Nelson, J. B. Saxe,
and R. Stata. Extended static checking for java. In Proceedings of the
2002 ACM SIGPLAN Conference on Programming Language Design
and Implementation (PLDI) , pages 234‚Äì245, 2002.
[15] wholemeal: Fulcrum, Jan. 2015. http://wholemeal.co.nz/projects/
fulcrum.html.
[16] J. A. Goguen and J. Meseguer. Order-sorted algebra I: equational
deduction for multiple inheritance, overloading, exceptions and partial
operations. Theor. Comput. Sci. , 105(2):217‚Äì273, 1992.
[17] D. Jackson. Alloy: A lightweight object modelling notation. ACM
Transactions on Software Enginnering and Methodology (TOSEM
2002) , 11(2):256‚Äì290, 2002.[18] D. Jackson. Software Abstractions: Logic, Language, and Analysis . The
MIT Press, Cambridge, Massachusetts, 2006.
[19] kandanapp/kandan, Sept. 2013. http://github.com/kandanapp/kandan.
[20] L. Kov ¬¥acs and A. V oronkov. First-order theorem proving and vampire.
InProceedings of the 25th International Conference on Computer Aided
VeriÔ¨Åcation (CAV 2013), Saint Petersburg, Russia, July 13-19, 2013. ,
pages 1‚Äì35, 2013.
[21] G. E. Krasner and S. T. Pope. A cookbook for using the model-view
controller user interface paradigm in Smalltalk-80. Journal of Object
Oriented Programming (JOOP 1988) , 1(3):26‚Äì49, Aug. 1988.
[22] K. R. M. Leino. Dafny: An automatic program veriÔ¨Åer for functional
correctness. In Proceedings of the 16th International Conference on
Logic Programming, ArtiÔ¨Åcial Intelligence, and Reasoning (LPAR) ,
pages 348‚Äì370, 2010.
[23] Lobsters, Mar. 2014. https://lobste.rs.
[24] J. Nijjar, I. Boci ¬¥c, and T. Bultan. An integrated data model veriÔ¨Åer with
property templates. In Proceedings of the ICSE Workshop on Formal
Methods in Software Engineering (FormaliSE 2013) , 2013.
[25] J. Nijjar and T. Bultan. Bounded veriÔ¨Åcation of Ruby on Rails data
models. In Proceedings of the 20th Int. Symp. on Software Testing and
Analysis (ISSTA 2011) , pages 67‚Äì77, 2011.
[26] J. Nijjar and T. Bultan. Unbounded data model veriÔ¨Åcation using SMT
solvers. In Proceedings of the 27th IEEE/ACM Int. Conf. Automated
Software Engineering (ASE 2012) , pages 210‚Äì219, 2012.
[27] F. Pelletier, G. Sutcliffe, and C. Suttner. The Development of CASC.
AI Communications , 15(2-3):79‚Äì90, 2002.
[28] Play Framework - Build Modern & Scalable Web Apps with Java and
Scala, May 2015. http://www.playframework.com/.
[29] W. V . Quine. QuantiÔ¨Åcation and the empty domain. J. Symb. Log. ,
19(3):177‚Äì179, 1954.
[30] Ruby on Rails, Feb. 2013. http://rubyonrails.org.
[31] Overview - Redmine, Sept. 2014. www.redmine.org.
[32] Sails.js ‚Äî Realtime MVC Framework for Node.js, May 2015. http:
//sailsjs.org/.
[33] Spring Framework ‚Äî SpringSource.org, Feb. 2013. http://www.
springsource.org.
[34] M. E. Stickel, R. J. Waldinger, M. R. Lowry, T. Pressburger, and
I. Underwood. Deductive composition of astronomical software from
subroutine libraries. In Automated Deduction - CADE-12, 12th Inter-
national Conference on Automated Deduction, Nancy, France, June 26
- July 1, 1994, Proceedings , pages 341‚Äì355, 1994.
[35] G. Sutcliffe, S. Schulz, K. Claessen, and P. Baumgartner. The TPTP
typed Ô¨Årst-order form with arithmetic. In Logic for Programming,
ArtiÔ¨Åcial Intelligence, and Reasoning - 18th International Conference,
LPAR-18, M ¬¥erida, Venezuela, March 11-15, 2012. Proceedings , pages
406‚Äì419, 2012.
[36] G. Sutcliffe and C. Suttner. The State of CASC. AI Communications ,
19(1):35‚Äì48, 2006.
[37] G. Sutcliffe, C. B. Suttner, and T. Yemenis. The TPTP problem library.
InAutomated Deduction - CADE-12, 12th International Conference
on Automated Deduction, Nancy, France, June 26 - July 1, 1994,
Proceedings , pages 252‚Äì266, 1994.
[38] TPTP Syntax, Jan. 2015. http://www.cs.miami.edu/ tptp/TPTP/
SyntaxBNF.html.
[39] Tracks, Sept. 2013. http://getontracks.org.
[40] C. Weidenbach. Spass input syntax version 1.5. http://www.spass-
prover.org/download/binaries/spass-input-syntax15.pdf.
[41] C. Weidenbach, D. Dimova, A. Fietzke, R. Kumar, M. Suda, and
P. Wischnewski. SPASS version 3.5. In Proceedings of the 22nd Int.
Conf. Automated Deduction (CADE 2009), LNCS 5663 , pages 140‚Äì145,
2009.