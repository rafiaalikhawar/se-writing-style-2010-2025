Composite Constant Propagation: Application to
Android Inter-Component Communication Analysis
Damien Octeau1,2, Daniel Luchaup1,3, Matthew Dering2, Somesh Jha1, and Patrick McDaniel2
1Department of Computer Sciences, University of Wisconsin
2Department of Computer Science and Engineering, Pennsylvania State University
3CyLab, Carnegie Mellon University
octeau@cs.wisc.edu, luchaup@andrew.cmu.edu, dering@cse.psu.edu, jha@cs.wisc.edu, mcdaniel@cse.psu.edu
Abstract ‚ÄîMany program analyses require statically inferring
the possible values of composite types. However, current ap-
proaches either do not account for correlations between object
Ô¨Åelds or do so in an ad hoc manner. In this paper, we introduce
the problem of composite constant propagation. We develop the
Ô¨Årst generic solver that infers all possible values of complex
objects in an interprocedural, Ô¨Çow and context-sensitive man-
ner, taking Ô¨Åeld correlations into account. Composite constant
propagation problems are speciÔ¨Åed using COAL, a declarative
language. We apply our COAL solver to the problem of inferring
Android Inter-Component Communication (ICC) values, which
is required to understand how the components of Android
applications interact. Using COAL, we model ICC objects in
Android more thoroughly than the state-of-the-art. We compute
ICC values for 460 applications from the Play store. The ICC
values we infer are substantially more precise than previous work.
The analysis is efÔ¨Åcient, taking slightly over two minutes per
application on average. While this work can be used as the basis
for many whole-program analyses of Android applications, the
COAL solver can also be used to infer the values of composite
objects in many other contexts.
I. I NTRODUCTION
Program analyses sometimes need to statically infer the
possible values of object Ô¨Åelds. Such a program analysis that
has recently received interest [11], [15], [34] is the inference
of messages communicated between Android applications. The
components of Android applications can interact with one an-
other using platform-speciÔ¨Åc constructs. This Inter-Component
Communication (ICC) facilitates the reuse of functionality,
both within and between applications. For example, an applica-
tion may need to render a map centered on speciÔ¨Åc geographic
coordinates. In Android, this application simply needs to send
an ICC message, which will be relayed to an appropriate target
by the operating system. The target will then render the map
based on passed values.
This development model potentially presents concerns.
First, exposed application components may be activated in
unexpected ways, leading, for example, to privilege escalation
attacks [14], [25]. Second, ICC messages can be intercepted
by malicious recipients, with consequences ranging from data
leaks [8] to piracy [29]. Finally, since information may Ô¨Çow
between components, secure information Ô¨Çow analysis must
account for inter-component Ô¨Çows. Without ICC analysis, in
order to remain conservative, static taint analyses in Android
have to assume that any data coming from another component
is tainted [1]. With ICC analysis, such a taint analysis can
precisely determine if inter-component links carry tainted data.
Thus, ICC analysis has proven very valuable in many contextssuch as information Ô¨Çow analysis [22], [24], [38], [41], patch
generation for privilege escalation vulnerabilities [42] and
detection of stealthy behavior [18].
In order to infer facts about interactions between compo-
nents, we need to Ô¨Ånd all possible values of the Ô¨Åelds of
ICC objects at program points where message passing occurs.
Unfortunately, existing studies of application interfaces are
limited. The Epicc tool [34] tries to determine the speciÔ¨Å-
cations of ICC interfaces. Unfortunately, it only addresses
Intent messages and a small subset of URI messages for which
all Ô¨Åelds are constant values. Adding complete support for
URIs using the same approach as for Intents would result
in a signiÔ¨Åcant increase in the complexity of the formulation
and implementation of the data Ô¨Çow functions. While this is
possible in theory, it is not feasible in practice. Apposcopy [15]
also infers Intent values but does not compute all Ô¨Åelds of an
Intent. In particular, similarly to Epicc URI data is not inferred.
In this paper, we deÔ¨Åne the problem of Multi-Valued
Composite (MVC) constant propagation. Unlike most constant
propagation analyses, we attempt to Ô¨Ånd all possible values
of objects of interest at important program points, making
our analysis multi-valued . Our analysis targets composite
constants, i.e., we determine the values of complex objects
that may have multiple Ô¨Åelds, taking the correlations between
Ô¨Åelds into account. Problems are speciÔ¨Åed using the COAL
declarative language. We design a COAL solver, which takes
COAL speciÔ¨Åcations and programs as input and outputs com-
posite constant values at program points of interest. In order
to automatically generate data Ô¨Çow functions, it utilizes the
concept of Ô¨Åeld transformers , which express how Ô¨Åelds are
changed by program statements.
While MVC constant propagation was motivated by An-
droid ICC analysis, this work applies to a wide variety of
static program analyses where the range of values of objects
needs to be determined. It is valuable in various areas such as
software security, maintenance and modeling. It can apply to
many object oriented programming languages.
As an application of our composite constant propagation
solver, we implemented and evaluated IC3, a new tool for
Android ICC analysis. In the COAL language, we modeled
all ICC messages with about 750 lines of COAL speciÔ¨Åcation.
Since Android ICC messages heavily rely on strings of charac-
ters, we devised and implemented a string analysis that is both
efÔ¨Åcient and more precise than the one in Epicc. We computed
ICC values in 460 applications from the ofÔ¨Åcial Play store. We1void map( float latitude , float longitude) {
2 Intent intent = new Intent();
3 intent.setAction("VIEW");
4 Uri geoUri = Uri.parse("geo:" + latitude + ","
+ longitude);
5 intent.setData(geoUri);
6 startActivity(intent); }
(a) Intent targeted at components that can render a map.
1<activity android:name="MapRenderingActivity">
2 <intent -filter >
3 <action android:name="VIEW"/>
4 <data android:scheme="geo"/>
5 <category android:name="DEFAULT"/>
6 </intent -filter >
7</activity >
(b) Example Intent Filter declaration to receive the Intent in (a).
1<activity android:name="DialerActivity">
2 <intent -filter >
3 <action android:name="VIEW"/>
4 <action android:name="DIAL"/>
5 <data android:scheme="tel"/>
6 <category android:name="DEFAULT"/>
7 </intent -filter >
8</activity >
(c) Example Intent Filter declaration to dial phone numbers.
Fig. 1. Example Intent and Intent Filter used for rendering a map and for
displaying a dialer. The real string values have been abbreviated for clarity.
inferred precise ICC values in 85% of cases. Epicc, on the
other hand, could only infer 66% precisely. The remaining
15% of values could not be determined because of constructs
not yet handled by our string analysis and other pathological
cases. Computing ICC values is efÔ¨Åcient, taking on average
slightly over two minutes per application. The extra precision
in inferring ICC values directly translated to a signiÔ¨Åcant
increase in precision when matching messages with potential
receivers. Since the matching process is an overapproxima-
tion of actual runtime communication, having fewer links is
desirable. In our experiments with 460 applications, such a
matching yielded 120,817 links with ICC values computed
by Epicc, whereas values computed with IC3 produced only
26,872 potential links. We make the following contributions:
We introduce the MVC constant propagation problem.
We deÔ¨Åne COAL, a declarative language to specify MVC
constant propagation problems and query their solution.
We formally deÔ¨Åne an approach to solve MVC con-
stant propagation problems in an interprocedural, Ô¨Çow and
context-sensitive manner. We implement a COAL solver
based on this formalism and open source it at [32].
We build IC3, an ICC analysis tool that relies on the COAL
solver. As a part of IC3, we develop a string analysis that
is Ô¨Ånely tuned for the most typical cases found in Android
applications. We make its source code available at [33].
II. A M OTIVATING EXAMPLE : ANDROID ICC
Android applications are composed of four different types
of components. Activities represent the user interface. Services
are used for background processing. Content Providers allow
for sharing of structured data between components. Broadcast
Receivers receive messages sent to the entire system.
Components can communicate with one another using two
kinds of objects. Uniform Resource IdentiÔ¨Åers (URIs) are used
to address data in Content Providers. Intent object are used
in all other cases. The target component of an Intent can
be speciÔ¨Åed by explicitly naming it, or it can be determined
automatically by the operating system based on the Ô¨Åelds
of the Intent. An Intent resolution procedure maps a givenIntent to possible targets. Several Ô¨Åelds of an implicit Intent
are used to match it with potential targets. The action Ô¨Åeld
represents the operation that the receiving component should
perform. The categories Ô¨Åeld adds information about the
component that the system can use. For instance, the system
places components with the LAUNCHER category in the main
application launcher. The data Ô¨Åeld includes data that the
receiving component should act on. It has the form of a URI.
Components can subscribe to receive implicit Intents by
specifying Intent Filters, which describe the actions, categories
and data of the Intents that should be addressed to them. Most
Intent Filters are speciÔ¨Åed in the manifest Ô¨Åle that is included
with every application.
Figure 1 shows a representative example of Android ICC.
In this Ô¨Ågure and in the remainder of this paper, we abbreviate
string values for ease of exposition. Figure 1(a) shows a
method that sends an Intent in order to render a map centered
at given coordinates. An Intent intent is created. Its action
is set to VIEW , which is a generic action used to display
many kinds of data. The data of the Intent is deÔ¨Åned to be
a URI with the geo scheme followed by coordinates. When
thestartActivity ()framework method is called, the operating
system (OS) resolves potential target components, prompting
the user to choose a recipient if several components match.
Figure 1(b) is a component declaration as it can be found in
an application manifest. The activity element (Line 1) de-
clares that the application contains an Activity component with
name MapRenderingActivity that includes a single Intent
Filter. The action line speciÔ¨Åes that the action Ô¨Åeld of Intents
received by the component should have value VIEW . The data
declaration at Line 4 speciÔ¨Åes that any received Intent should
carry data in the form of a URI with a geo scheme. Finally,
thecategory line declares that received Intents can carry
theDEFAULT category. This category is added by the OS to
implicit Intents targeting Activities, such as the one on Line
6 of Figure 1(a). Therefore, MapRenderingActivity could
receive the Intent created in Figure 1(a).
In order to statically know how application components
communicate with one another, we need to determine the
values of ICC objects at message-passing program points. For
example, in Figure 1(a), we want to know all the possible
values ofintent at statement startActivity(intent) . Ob-
jects of interest are Intents, Intent Filters and URIs. It is very
challenging to write data Ô¨Çow models separately for all of
these. That is why previous work [34] has not properly handled
URIs, which has two negative consequences. First, interactions
with Content Providers cannot be determined. Second, the data
Ô¨Åeld of Intents cannot be known, which signiÔ¨Åcantly limits
the Intent resolution process. Any Ô¨Åeld that cannot be known
results in a loss of precision. For example, mapping the Intent
from Figure 1(a) with the component from Figure 1(b) requires
knowing the action and the URI data of the Intent. When the
data Ô¨Åeld is not known, any attempt to resolve the possible
targets ofintent from Figure 1(a) has to conservatively
assume that the data Ô¨Åeld can take any value. Figure 1(c)
declares a dialer Activity DialerActivity . It is similar to
MapRenderingActivity , except that it adds support for a
DIAL action and it handles tel URI schemes. Because of1public class Intent {
2 private String action;
3 private Set<String > categories = new
HashSet <>();
4 private String data;
5 private String mimeType;
6
7 public void setAction(String act) {
8 this .action = act; }
9 public void addCategory(String cat) {
10 this .category = cat; }
11 public void setDataAndType(String d,
String t) {
12 this .data = d;
13 this .mimeType = t; }
14 public void setData(Uri u) {
15 this .data = u.getData();
16 this .mimeType = null ; } }
17
18public class Uri {
19 private String data;
20
21 public void setData(String d) {
22 this .data = d; }
23 public void getData() {
24 return this .data; } }
(a) SimpliÔ¨Åed Intent and Uri classes. The real ones comprise 2,000
and 1,200 SLOC, respectively.1class Intent {
2String action; String categories; String data;
String mimeType;
3
4mod <Intent: void setAction(String)> {
5 0:replace action; }
6mod <Intent: void addCategory(String)> {
7 0:add categories; }
8mod <Intent: void setDataAndType(String ,String)> {
9 0:replace data;
10 1:replace mimeType; }
11 mod <Intent: void setData(Uri)> {
12 0:replace data , type Uri:data;
13 clear mimeType; }
14 query <Context: void startActivity(Intent)> {
15 0:type Intent; } }
16
17class Uri {
18 String data;
19
20 mod <Uri: void setData(String)> {
21 0:replace data; }
22 source <Uri: String getData(String)> {
23 data; } }
(c) COAL speciÔ¨Åcation for the constant propagation problem. Each modiÔ¨Åer
speciÔ¨Åcation ( mod) describes the inÔ¨Çuence of a method call on the Ô¨Åelds of an
Intent. A query indicates that all Intent values at calls to startActivity ()should
be computed. A source indicates how the value of a Ô¨Åeld Ô¨Çows out of an object.
1void sendMessage(Context c, boolean b,
String mimeType) {
2 Intent intent = new Intent();
3 intent.setAction("VIEW");
4 Uri uri = new Uri();
5 if(b) {
6 intent.addCategory("BROWSABLE");
7 uri.setData("http://icse -conferences.org");
8 intent.setData(uri);
9 }else {
10 uri.setData("file:///florence.jpg");
11 intent.setDataAndType(uri.getData(),
mimeType); }
12 c.startActivity(intent); }
(b) Message-passing code. We assume that the mimeType argument
may have value either image/jpg orimage/* .Value 1 Value 2 Value 3
action VIEW VIEW VIEW
categoriesfBROWSABLEg ? ?
data http://... file:///... file:///...
mimeType ? image/jpg image/*
(d) Possible values of the Ô¨Åelds of intent at the startActivity ()call. We have
abbreviated the URI strings for space reasons, however our system would infer
complete strings. Value 1 is for the Ô¨Årst branch after the ifstatement (Lines 6-8
in (b)). Values 2 and 3 account for the fall-through branch of the ifstatement,
where argument mimeType may have two different values.
Fig. 2. Running example.
its inability to infer Intent URI data, the current state-of-the-
art [34] would infer that both MapRenderingActivity and
DialerActivity can receive the Intent. In reality, only the
former is able to do so. Thus, more precision is needed to
avoid such false positives.
We address this issue in this paper. In Sections III
through VI, we introduce a novel approach to statically infer
the set of values that objects can take. In Section VII, we apply
this approach to the problem of inferring Android ICC values.
III. O VERVIEW
A. The MVC Constant Propagation Problem
Consider OBJ an object of type class Pairfint X; int
Y;g. Assume that at some program location OBJ can be either
(X, Y) = (1, 10) or(2, 20) . We would like an analysis
that can determine this fact. Classical constant analysis applied
for each Ô¨Åeld fails at determining a useful value because none
of the Ô¨Åelds is the same constant across all paths. Multi-valued
constant analysis could determine that OBJ:X2 f1;2gand
OBJ:Y2f10;20g. These constraints accurately describe the
individual Ô¨Åelds, but they allow for imprecision in the object,
because they allow the possibility that OBJ=(1, 20) . We de-
Ô¨Åne the Multi-Valued Composite (MVC) constant propagation
problem to be the problem of determining the set of values
that an object viewed as a tuple (such as (X, Y) ) can have.
Note that the above multi-valued constant analysis applied to
individual Ô¨Åelds is a possible solution, it may just not beprecise enough for certain analyses. We will show how to
efÔ¨Åciently Ô¨Ånd more precise solutions.
We now introduce a running example that will be used
throughout. Figure 2(a) shows code for a hypothetical Intent
class that contains data used for passing messages between
application components. It uses a data Ô¨Åeld which is copied
from a Uri object, for which code is also shown in Figure 2(a).
Figure 2(b) deÔ¨Ånes method sendMessage (), which we as-
sume to be called as part of an Android application. This
method creates an Intent object and sets its action Ô¨Åeld. Then,
depending on the value of a Boolean, one of two things can
happen. In the Ô¨Årst branch after the ifstatement, a value is
added to the categories Ô¨Åeld ofintent . Then the data Ô¨Åeld of
a Uri object is copied to the data Ô¨Åeld ofintent at Line 8. In
the fall-through branch, the data andtype Ô¨Åelds of the intent
variable are set using a call to setDataAndType ()(Line 11).
Finally, the Intent object is sent to another component using
thestartActivity ()method.
The data Ô¨Çow problem we are solving is to determine
all the possible values of the Ô¨Åelds of intent at the call
tostartActivity (). In our propagation framework deÔ¨Åned
below, the problem can be speciÔ¨Åed using COAL, a declarative
language we designed for this purpose. The function of COAL
(COnstant propAgation Language) is to specify Multi-Valued
Composite (MVC) constant propagation problems . It speciÔ¨Åes
the types of variables for which values should be inferred(1) Intermediate representation generationApplication(2) ICFG construction(3) MVC data Ô¨Çow analysisComposite constantsFig. 3. General overview of the MVC constant analysis process.
COAL speciÔ¨Åcation
IDE solverLatticesData Ô¨Çow functionsComposite constantsArgument analysesICFGCOAL solver
Fig. 4. The MVC data Ô¨Çow analysis process (Step 3 from Figure 3).
and how these values are modiÔ¨Åed by program statements. It
enables abstract reasoning on the semantics of API methods.
The COAL language is recognized by our COAL solver, which
outputs solutions for many propagation problems solely from
their COAL speciÔ¨Åcation and an input program.
Figure 2(c) shows how to specify the problem with our
framework using COAL. The COAL speciÔ¨Åcation is manually
written once and it can subsequently be used to solve the
same problem for an arbitrary number of applications. It is
composed of Ô¨Åeld declarations, modiÔ¨Åers and a query. The
Ô¨Åeld declarations specify the Ô¨Åelds that are being tracked and
their type. Note that, for each Ô¨Åeld, we keep track of sets of
values, even though the Ô¨Åeld declaration only speciÔ¨Åes the type
of each individual Ô¨Åeld value. The Ô¨Årst modiÔ¨Åer indicates how
thesetAction ()method inÔ¨Çuences the modeled value of an
Intent object. A modiÔ¨Åer speciÔ¨Åcation starts with the signature
of the modeled method. Each line in a modiÔ¨Åer declaration is
an argument whose value is used to modify the Intent value.
Each argument declaration is composed of several attributes.
An integer declares the position of the argument in the array of
arguments to the method, with indices starting at 0. After the
argument index, an operation and a Ô¨Åeld are declared. They
describe both the Ô¨Åeld that is modiÔ¨Åed by the method and how
it is modiÔ¨Åed. For example, in the setAction ()modiÔ¨Åer, 0:
replace action means that the action Ô¨Åeld is replaced with
the value of the Ô¨Årst argument to setAction (). Other modiÔ¨Åers
are declared in a similar manner, except when the type of an
argument is a class that is modeled with COAL. In that case,
atype attribute is used in order to specify which Ô¨Åeld of
the argument object is used. For example, in the setData ()
modiÔ¨Åer, the 0: replace data, type Uri:data argument
means that the data Ô¨Åeld of the Uri argument is used to replace
thedata Ô¨Åeld of the Intent being modiÔ¨Åed.
The query statement indicates that we are querying the so-
lution at all calls to startActivity (). Similarly to the modiÔ¨Åer
declaration, we specify a list of arguments. They describe the
arguments whose value we would like to query. In this case, it
is the Ô¨Årst argument (as described by the 0attribute), which is
an Intent object. The source at Line 22 indicates how a Ô¨Åeld
value Ô¨Çows out of an object. This is useful when the value
subsequently Ô¨Çows into a COAL modiÔ¨Åer, since the COAL
solver can then infer the correct value.
Figure 2(d) shows the expected result of our analysis.
We want our analysis to recover the three possible valuesof Intentintent . These values correspond to all possible
execution paths of the program from Figure 2(b). We wish
to recover exactly these possible values, and we do not want
all the possible combinations of Ô¨Åelds. For example, it is not
possible in our problem to have an Intent value with category
BROWSABLE and MIME type image/jpg . As a result, our
analysis does not simply track Ô¨Åelds individually as separate
variables, but rather propagates composite constants.
B. MVC Constant Propagation Analysis
Figure 3 shows a general overview of the analysis process
that takes an application as input and outputs the values of
composite objects. It starts by converting the program to an
intermediate representation that is suitable for further analysis
(Step 1). It then generates an Interprocedural Control Flow
Graph (ICFG) (Step 2). An ICFG is a collection of CFGs of
all the procedures in the program connected with each other
at procedure call sites. This includes building a call graph for
the entire program. Finally, the actual MVC data Ô¨Çow analysis
takes place in Step 3 and outputs the MVC constant values.
Existing work [1], [30] can perform Steps 1 and 2. There-
fore, the scope of this paper is limited to the MVC data Ô¨Çow
analysis (Step 3), which is performed using our COAL solver.
Figure 4 depicts a more detailed overview of the COAL solver,
which takes two inputs. First, it uses the ICFG of the program
being analyzed. Second, it takes a COAL speciÔ¨Åcation for
the problem being solved. This COAL speciÔ¨Åcation describes
the structure of the composite objects for which constant
propagation should be performed. It also describes the methods
that can modify these objects and the program locations
where the constants should be computed. The speciÔ¨Åcation
is written using the COAL language, which allows MVC
constant propagation problems to be speciÔ¨Åed easily. It should
be noted that, for a given problem, the COAL speciÔ¨Åcation
need only be written once, after which an arbitrary number of
programs can be analyzed.
For each program, the COAL speciÔ¨Åcation is parsed to
build a model of the problem by creating problem-speciÔ¨Åc
lattices of values and data Ô¨Çow functions. These are input
with the ICFG into a solver for Interprocedural Distributive
Environment (IDE) problems [36]. We present the generic IDE
model for constant propagation in Section V. Finally, since the
values of arguments to functions have to be known, we use
argument value analyses (e.g., integer and string analyses) to
generate the data Ô¨Çow functions.
The IDE solver outputs the analysis results. The COAL
language allows speciÔ¨Åcation of program points of interest
(queries) where the MVC constant values should be computed.
This is useful in cases where the program points of interest are
known in advance. In other cases, we also allow lower-level
queries to the IDE solver as part of the COAL solver API. The
results can then be output in a simple text format or accessed
using a programmatic interface (API).
Note that it is possible to write MVC data Ô¨Çow models
for individual classes in an ad hoc manner without using an
MVC constant solver. However, given the complexity of a
typical MVC model, doing so is time consuming and prone
to errors. In contrast, the approach we present relies on ahmodeli::= ‚Äò class ‚Äôhtypei‚Äò{‚ÄôfhÔ¨ÅeldijhmodiÔ¨Åerijhqueryijhconstanti
jhsourceig‚Äò}‚Äô
hÔ¨Åeldi ::=htypeihÔ¨Åeld namei‚Äò;‚Äô
hmodiÔ¨Åeri::= ‚Äò mod‚Äôhmethod sigi‚Äò{‚ÄôfhmodiÔ¨Åer argig‚Äò}‚Äô
hqueryi::= ‚Äò query ‚Äôhmethod sigi‚Äò{‚Äôfhquery argig‚Äò}‚Äô
hconstanti::= ‚Äò constant ‚ÄôhÔ¨Åeld sigi‚Äò{‚ÄôfhÔ¨Åeld namei‚Äò=‚Äôhinline valuei
‚Äò;‚Äôg‚Äò}‚Äô
hsourcei::= ‚Äò source ‚Äôhmethod sigi‚Äò{‚ÄôhÔ¨Åeld namei‚Äò;‚Äô ‚Äò}‚Äô
hmodiÔ¨Åer argi::= [harg numberi‚Äò:‚Äô]hoperationihÔ¨Åeldi[‚Äò,‚Äôharg typei‚Äò:‚Äô
hÔ¨Åeld namei]
hquery argi::=harg numberi‚Äò:‚Äôharg typei
harg numberi::=hintegerij‚Äò(‚Äôhintegerif‚Äò,‚Äôhintegerig‚Äò)‚Äô
harg typei::= ‚Äò type ‚Äôhtypei
hÔ¨Åeld sigi::= ‚Äò <‚Äôhtypei‚Äò:‚ÄôhtypeihÔ¨Åeldi‚Äò>‚Äô
Fig. 5. COAL language for specifying MVC constant propagation problems.
single, generic and formally deÔ¨Åned MVC data Ô¨Çow model.
Instead of specifying data Ô¨Çow models for each class being
analyzed, MVC constant propagation problems are speciÔ¨Åed
by writing COAL speciÔ¨Åcations. This approach has several
advantages over the ad hoc one. First, it is easier to im-
plement and maintain, since COAL speciÔ¨Åcations are written
using a simple declarative language. Second, it is easier to
ensure that the models and their implementation are correct.
Correctness of the generic model is discussed in Section VI-A
and in an accompanying technical report [31]. Since COAL
speciÔ¨Åcations only describe the relationships between Ô¨Åelds
and methods without specifying semilattices or Ô¨Çow functions,
their correctness is relatively simpler to verify. Third, the
generic data Ô¨Çow model used by the COAL solver can be
changed without having to rewrite all the COAL speciÔ¨Åcations
that have been written so far. In particular, we are currently
using an IDE model [36], but it is possible to use reductions
to other types of problems [35]. Finally, when modeled types
interact with one another the data Ô¨Çow functions in the ad hoc
approach become much more complex. On the other hand, the
Ô¨Åxed point iteration described in Section VI-C supported by
the COAL constructs demonstrated at Line 12 of Figure 2(c)
enables seamless support for inter-object data Ô¨Çows.
IV. T HECOAL L ANGUAGE
The goal of the COAL language is to specify and query a
wide variety of MVC constant propagation problems. COAL
speciÔ¨Åcations are used by our solver to automatically generate
semilattices of values and data Ô¨Çow functions.
A simpliÔ¨Åed grammar for this language is presented on
Figure 5. Thefgcharacters symbolize repetition, while []
characters surround optional parts of a production.
The model for a given object is composed of Ô¨Åeld decla-
rations, modiÔ¨Åers, constants and sources. Queries can also be
speciÔ¨Åed using the COAL language to specify program points
where MVC constants should be inferred.
Field declarations - A Ô¨Åeld declaration speciÔ¨Åes a Ô¨Åeld that
is part of the modeled class. It describes a data type and a
name for the Ô¨Åeld. In Figure 5, we use non-terminals htypei
andhÔ¨Åeld nameito represent valid types and Ô¨Åeld names.
ModiÔ¨Åers - ModiÔ¨Åers represent method calls where constant
values Ô¨Çow to the modeled object. The speciÔ¨Åcation of the
modiÔ¨Åers comprises a method signature hmethod sigithat
identiÔ¨Åes the method of interest. It also includes a set of
arguments that describe how the method arguments are usedto modify the Ô¨Åelds of the modeled object. A modiÔ¨Åer argu-
ment has several attributes. An argument index identiÔ¨Åes the
method argument of interest. In some cases, several arguments
contribute to the value of a single Ô¨Åeld. That is why the
language supports sets of argument indices. A Ô¨Åeld operation
to be performed is also speciÔ¨Åed. This allows the solver to
create appropriate data Ô¨Çow functions. Natively supported Ô¨Åeld
operations are add (add argument value to the Ô¨Åeld), remove
(remove argument value from Ô¨Åeld), replace (replace Ô¨Åeld
with argument value) and clear (clear Ô¨Åeld value). A modiÔ¨Åer
speciÔ¨Åcation also includes a Ô¨Åeld name that identiÔ¨Åes the Ô¨Åeld
being modiÔ¨Åed. In the case where an argument is a class
modeled with COAL, an argument type and additional Ô¨Åeld
name are speciÔ¨Åed. This indicates to the solver that the value of
a Ô¨Åeld of a modeled class Ô¨Çows to the object being modiÔ¨Åed.
Constants - Many languages allow the speciÔ¨Åcation of
constants (e.g., static Ô¨Ånal Ô¨Åelds in Java). The constants of
a class are initialized in the class initializer the Ô¨Årst time the
class is referenced. A na ¬®ƒ±ve way to deal with constants would
consist in tracking the constant creation and initialization as it
is done for all modeled objects. We would then propagate them
throughout the entire program at the cost of performance. As a
performance optimization, we allow constant modeled objects
to be speciÔ¨Åed in COAL. Where these values are used, the
COAL solver uses the speciÔ¨Åed value.
Sources - Sources model the case where a modeled Ô¨Åeld
value Ô¨Çows to an argument value. For example the source at
Line 22 of Figure 2(c) allows the COAL solver to infer that
thedata Ô¨Åeld of the Uri object Ô¨Çows to the intent variable.
Using this information allows the solver to infer the correct
value for the data Ô¨Åeld ofintent .
Queries - Queries specify statements of interest where
modeled values should be determined.
The MVC constant propagation problem from Figure 2(b)
can be solved by inputting the program and the speciÔ¨Åcation
from Figure 2(c) into our COAL solver. Alternative methods
such as code annotations could be used to specify these prob-
lems. However, our approach speciÔ¨Åes all analysis parameters
in a single location and does not require the source code of
the modeled objects. Annotations, on the other hand, would
require source code and they would have to be spread over
the modeled code. In our motivating example of Android, this
implies spreading speciÔ¨Åcations over thousands of lines code.
V. A G ENERIC MODEL FOR MVC C ONSTANT
PROPAGATION
The purpose of the COAL language and the associated con-
stant propagation solver is to determine the possible values of
composite objects by only deÔ¨Åning a COAL speciÔ¨Åcation. The
COAL solver automatically converts the COAL speciÔ¨Åcation
to an instance of an Interprocedural Distributive Environment
(IDE) problem, using the model deÔ¨Åned in Section V. Given an
IDE problem, existing algorithms can compute a solution [36].
This section presents the analysis domain and a space Fof
functions that model the inÔ¨Çuence of COAL modiÔ¨Åers. They
will subsequently be used in Section VI to automatically build
reductions to IDE problems. Interested readers are referred to
the technical report [31] for a more detailed presentation.A. TheLSemilattice of Values
For any set X, we denote the power set of Xby2Xand
the set of functions from XtoXbyXX. We are trying to
determine the value of an object with nÔ¨Åelds, taking values
in Ô¨Ånite sets V1;:::;V n. If Ô¨Åeldihas a container type (e.g.,
set of integers), Viis the contained type (e.g., integer). For
i2f1;:::;ng, letPi= 2Vi[f!g, where!represents an
undeÔ¨Åned value. Let B=P1Pn. We deÔ¨Åne L=
(2B;)a join-semilattice with a bottom element ?=?. The
join operation on Lis the set union[. The top element of L
is the set of all elements in B.
SetsV1;:::;V nare the domains of the Ô¨Åeld values we
are trying to determine. For example, V1could be the set of
constant strings of characters in the program. A value in B
represents a value as it is seen on a single path. Finally, values
inLrepresent values of objects, taking into account several
paths of a program. Note from the deÔ¨Ånition of P1;:::;P n
that we keep track of sets of values, even for scalar Ô¨Åelds. A
scalar is simply represented by a set with a single value.
Let us consider the example from Figure 2(a). We are in-
terested in four Ô¨Åelds: action ,categories ,data andmimeType .
LetSbe the set of string constants in the program. In this
case, we consider P1=P2=P3=P4= 2S[f!g. In other
words, we consider all four Ô¨Åelds to take values in the power
set ofS. We haveB=P1P2P3P4andL= (2B;).
In methodsendMessage (), the value associated with the
intent variable is initially ?before Line 2. Line 2 transforms
this value tof(?;?;?;?)g. Right after Line 3, the value is
f(fVIEWg;?;?;?)g: (1)
After the ifstatement, at Line 12, the value is
f(fVIEWg;fBROWSABLEg;fhttp://icse-conferences.org g;?);
(fVIEWg;?;ffile:///florence.jpg g;fimage/jpgg);
(fVIEWg;?;ffile:///florence.jpg g;fimage/*g)g:
(2)
B. Transformers on L
The intuition behind the COAL language is that each
argument in a COAL modiÔ¨Åer represents the inÔ¨Çuence of the
method call on a Ô¨Åeld. Accordingly, we introduce transformers
that are deÔ¨Åned at the granularity of Ô¨Åelds. In this section, we
assume that the value of uriis available where necessary. We
revisit this assumption in Section VI-C.
DeÔ¨Ånition 1 - Fori2f1;:::;ng, we deÔ¨ÅneFia non-empty
subset ofPPi
iclosed under composition. Each 2Fiis called
aÔ¨Åeld transformer .
In this paper, we consider Ô¨Åeld transformers such that:
Type (1):(!) =!and for all X2Pisuch that
X6=!,(X) = (X KILL )[GEN , for some constant
setsGEN andKILL inPi. Such a function will also
be denoted as =KILL
GEN . This is used for the add and
remove Ô¨Åeld operations in COAL.
Type (2): For all X2Pi,(X) =GEN , for someGEN
inPi. This case is also denoted by =GEN . This is used
for the replace andclear Ô¨Åeld operations in COAL.
It is easy to verify that the set of such Ô¨Åeld transformers is
closed under composition.
Let us denote the identity Ô¨Åeld transformer by id. We have
id=?
?. The important idea is that each modiÔ¨Åer argument in
COAL is mapped to a single Ô¨Åeld transformer. For example,let us consider the statement at Line 3 of Figure 2(b). Using
the deÔ¨Ånition above and the fact that this method replaces the
existing action value, we can model it using type (2) Ô¨Åeld
transformer fV IEWg.
Field transformers are used as basic building blocks for data
Ô¨Çow functions. We deÔ¨Åne the set Lof functions from Bto
Bsuch that for any l2L, there exists (1;:::; n)2F1
Fnsuch that, for any b= (1;:::; n)2B,l(b) =
(1(1);:::; n(n)). We notel=1n. Recall that
the inÔ¨Çuence of the statement at Line 3 of Figure 2(b) on Ô¨Åeld
action is modeled by Ô¨Åeld transformer fV IEWg. The function
inLthat models the inÔ¨Çuence of the setAction ()call on the
action Ô¨Åeld is quite naturally fVIEWgididid2L. This
function solely modiÔ¨Åes the action Ô¨Åeld.
Functions inLmodel the inÔ¨Çuence of a single execution
path. We can deÔ¨Åne their composition as follows. For any
l1=1
11
nandl2=2
12
ninL, we have:
l1l2=1
12
11
n2
n:
Using DeÔ¨Ånition 1, Lis closed under composition.
We now deÔ¨Åne a set Fof functions from LtoLusing
functions inL. Functions in Fcan model the inÔ¨Çuence
of several execution paths on all Ô¨Åelds of an object. More
speciÔ¨Åcally, any f2Fis writtenf=fl1;:::;l mg, with
l1;:::;l m2L, such that:
for anyb2B,f(fbg) =Sm
i=1li(b),
for anyv=fb1;:::;b kg2L,f(v) =Sk
i=1f(fbig).
The identity over Lis denoted by idL. Additionally, F
contains 
, which is such that for all v2L,
(v) =?.
Informally, the 
function is used to ‚Äúkill‚Äù data Ô¨Çow facts. This
only happens when a variable is assigned a new value. Finally,
Fcontainsinitvfunctions, which are such that initv(?) =v,
withv2L. Informally, init functions generate data Ô¨Çow facts
and associate them with an initial value.
Let us now consider the ifstatement in Figure 2(b). The
inÔ¨Çuence of the two branches is summarized by
fid?
fBROWSABLE gfhttp://icse-conferences.org g?;
ididffile:///florence.jpg gfimage/jpg g;
ididffile:///florence.jpg gfimage/* gg;(3)
where?clears the value of the mimeType Ô¨Åeld. We can verify
that applying this function to the value given by Equation (1)
yields the value given by Equation (2).
By deÔ¨Åning the composition of elements of Fin a standard
way, it is possible to prove the following proposition [31],
which will be used in the next section.
Proposition 1 - Fis closed under composition.
Finally, we deÔ¨Åne the [operator such that, for
f1=fl1
1;:::;l1
mgandf2=fl2
1;:::;l2
kg,f1[f2=
fl1
1;:::;l1
m;l2
1;:::;l2
kg.
VI. F ROM COAL S PECIFICATIONS TO IDE P ROBLEMS
This section presents how COAL speciÔ¨Åcations are used to
automatically generate instances of IDE problems by generat-
ing data Ô¨Çow functions in F. Recall that IDE problems can
then be solved using existing algorithms [36]. We Ô¨Årst outline
the requirements of IDE problems.
A. Environment Transformers
LetDbe the set that comprises all variables in the program
and a special symbol, which represents the absence of a dataAlgorithm 1 Generate functions in Ffrom COAL modiÔ¨Åers.
1:procedure GENERATE FUNCTION (modifier ,statement )
2:result :=idL3: for all arguments arg inmodifier:args do
4: values :=null
5: ifarg:number != null then
6: values :=GETARGUMENT VALUES (statement ,arg:number ,
arg:type )
7: argfunction :=null
8: ifvalues6=null then
9: for all argument values value invalues do
10: current :=BUILD FUNCINF(arg:op ,value ,arg:field )
11: ifargfunction =null then
12: argfunction =current
13: else
14: argfunction =argfunction[current
15: else
16: argfunction :=BUILD FUNCINF(arg:op , null, arg:field )
17: result :=resultargfunction
18: return result
Ô¨Çow fact. An environment is a function from DtoL, where
Lwas introduced in Section V-A. The set of environments
isE. A join operation tis deÔ¨Åned on Esuch that, for
anye1;e22Eandd2D,(e1te2)(d) =e1(d)[e2(d).
Environment transformers are used to model the inÔ¨Çuence
of program statements on the values of variables. They are
functions from EtoE. For example, before a program
statements, the values associated with each variable of interest
are given by environment e12E. Statement stransforms
e1to a new environment e22E, which is modeled by
an environment transformer tsuch thate2=t(e1). The
IDE framework requires that environment transformers be
distributive . An environment transformer tis said to be dis-
tributive if, for every e1;e2; 2Eand for any d2D,
(t(tiei))(d) =[i(t(ei))(d).
The main function of the COAL solver is to turn COAL
speciÔ¨Åcations into distributive environment transformers. We
can show that the functions in Fare distributive and that they
can be used to easily build distributive environment transform-
ers [31], which ensures the correctness of our approach.
B. Generating Functions in F
Since producing environment transformers from functions
inFis trivial, this section addresses how the COAL solver
builds elements of Ffrom COAL speciÔ¨Åcations. Algorithm 1
is used by the COAL solver to generate a function in Ffrom
a statement and a modiÔ¨Åer speciÔ¨Åcation for the statement. It
computes functions in Ffor each argument and composes
them (recall from Proposition 1 that Fis closed under com-
position). A modiÔ¨Åer argument arg has several attributes: (i)
an operation op, which is performed by the modiÔ¨Åer method,
(ii) an argument number number , which indicates the position
of the arguments of interest in the modiÔ¨Åer method, (iii) an
argument type type, which can be declared as part of the Ô¨Åeld
declaration (see Line 2 of Figure 2(c)) and (iv) field , the
index (or the name) of the modiÔ¨Åed Ô¨Åeld.
We assume the existence of a procedure G ETARGUMENT -
VALUES , which computes the possible values of a method
argument, given an invoke statement, an argument number
and an argument type. For most value types, this procedure
simply traverses the interprocedural control Ô¨Çow graph starting
at the method call looking for assignments to the variable
that is used as an invocation argument. For string arguments,
we use the analysis described in Section VII-A. Note thatthe argument type is needed by the COAL solver to select
the argument analysis that should be used. We also assume
that there is a procedure B UILD FUNCINF that generates a
function in Fgiven an operation, an argument value and a
Ô¨Åeld. In the interest of space, we only summarize its main
steps. It starts by generating a Ô¨Åeld transformer using
the operation and the argument value. The Ô¨Åeld index (or
name) allows the creation of a function l2L of the form:
l=idididid. The corresponding function
inFis simplyflg. When a modiÔ¨Åer method argument may
have several values resulting in possible functions f1;:::;f n,
we compute f1[[fn(Line 14).
To illustrate this procedure, let us consider Line 11 of
Figure 2(b). The COAL solver determines that this is a
modiÔ¨Åer with two arguments (see Figure 2(c) Lines 8-10).
Considering the Ô¨Årst argument 0: replace data and given
the fact that data is a string Ô¨Åeld, the G ETARGUMENT VAL-
UES procedure Ô¨Ånds that the method argument has value
file:///florence.jpg . Since a replace operation is re-
quested, the B UILD FUNCINF procedure generates Ô¨Åeld trans-
formerffile:///florence.jpg g. Using the fact that data is the
third Ô¨Åeld (Line 2 of Figure 2(c)), it generates function
fididffile:///florence.jpg gidg: (4)
Considering argument 1: replace mimeType , the solver
Ô¨Ånds that there are two possible values for the mimeType
variable. Thus, Lines 9-14 of the algorithm yield function
fidididfimage/jpg g;idididfimage/* gg;(5)
where Line 14 utilizes the deÔ¨Ånition of the [operator on F
from Section V. Finally, Line 17 of Algorithm 1 composes the
two functions given by Equations (4) and (5), which yields:
fididffile:///florence.jpg gfimage/jpg g;
ididffile:///florence.jpg gfimage/* gg:
C. Fixed Point Iteration
Let us consider method sendMessage ()from Figure 2(b).
So far, we have assumed that the value of the Uri uriat Line 8
of Figure 2(c) is available when we generate Ô¨Åeld transformers
forintent . In reality, it is not initially available, because when
we solve the problem for the Ô¨Årst time, values for intent
anduriare computed in the same iteration. Thus, in order to
fully resolve all values, we run several iterations of the COAL
solver. For example, in the Ô¨Årst iteration, the transformer that
is generated for statement intent.setData(uri) is
fintent; 1intent; 2intent; 3intent; 4g=
fidididuri;1g;
whereuri;1is a transformer that indicates that the value of
thedata Ô¨Åeld ofintent refers to the Ô¨Årst Ô¨Åeld of Uri uri.
We initially start with intent;i anduri;1mapping to !, for
1i4. We then iterate until a Ô¨Åxed point is reached for
intent;i anduri;1. The same process allows the solver to
resolve the value of intent at Line 11 of Figure 2(b).
VII. A PPLICATION TO ANDROID ICC
As an application of the COAL language and solver, we
built IC3 (Inter-Component Communication analysis with
COAL), an ICC inference tool that is based on COAL speci-
Ô¨Åcations. The main ICC classes are Intents, Intent Filters and
URIs. For completeness we also model the Component Name,
Bundle, Pending Intent and Uri Builder classes since they are
referenced by the main class types.
Recall from Figure 3 that as a prerequisite to the MVC
constant propagation, it is necessary to generate an inter-mediate representation (IR) that is suitable to generate an
ICFG. The COAL solver is currently implemented using the
Soot framework [39] and the Heros IDE solver [3]. Soot
converts Java bytecode to an internal IR that is recognized
by its Spark [23] call graph construction module, which is
used to build an ICFG. However, Android applications present
additional challenges. First, they are distributed in a platform-
speciÔ¨Åc bytecode format. We therefore preprocess them with
Dare [30], which converts Android to Java bytecode. Second,
Android applications are composed of components that may
be started in an arbitrary order. Additionally, they are event-
based programs that declare callbacks that may be called in
an arbitrary order. In order to address this challenge in a
conservative manner, we adopt the call graph construction
procedure from FlowDroid [1], which generates a wrapper
entry point method that simulates the application lifecycle and
the arbitrary event and component call order.
The COAL solver takes aliasing into account. When a
method modiÔ¨Åes a variable o1that is a possible alias for
another object o2, our analysis generates two values for o2.
One of them takes the call into account and the other one
does not. The one that does not models the case where the
alias analysis results in a false positive (i.e., detecting that a
value may point to a certain heap location even though it does
not). This is similar to the standard idea of weak updates [7].
A. String Analysis
Strings are ubiquitous in Android applications. Many argu-
ments to ICC methods are strings. Because of the limited set
of predeÔ¨Åned Intent Ô¨Åelds (e.g., default action and category
strings), in many cases, the value of string Ô¨Åelds is deter-
mined by a Ô¨Ånite set of constants. However, the way these
constants are transferred or combined is not trivial and a string
analysis is required to determine the set of possible values
that a given variable can have. Our string analysis determines
a safe overapproximation of such sets. It was inspired by
JSA [9], although our analysis is highly customized for the
purposes of Android. Conversely, JSA is more generic but
signiÔ¨Åcantly slower for our purposes. Our analysis works
in two stages: constraint generation and constraint solving.
Constraint generation simply gathers the dataÔ¨Çow facts for
string variables. Constraint solving determines regular sets
(described as regular expressions) that satisfy the constraints.
In the Ô¨Årst stage we generate constraints for all string
operations, modeling the String and StringBuilder classes. Our
goal is to have a representation that can be used either by
a constraint solver or by abstract interpretation. This is why
the constraints are a symbolic representation of the original
program operations. The analysis is Ô¨Çow-sensitive. Constraints
model idioms that are common in Android operations: con-
catenation, string Ô¨Åelds, function calls, etc.
In the second stage, a solver uses the constraints to answer
queries about variable values. As a proof of concept, we
implemented a simple solver that given a variable xproduces
a regular expression that overapproximates the set of values
thatxcan take. It works by Ô¨Ånding the constraints associated
withxand by traversing the Ô¨Çow graph and interpreting the
nodes. We avoid non-termination by detecting self dependencecycles and widening to .*(that is?). Similarly, we widen
to.*when we detect calls to functions outside the analysis
(for which we have not generated constraints). Although our
widening method may be less accurate than that in [9],
our simple solver is faster and can still be more accurate
because of context sensitivity. Our analysis is interprocedural,
context-sensitive, Ô¨Çow-sensitive, Ô¨Åeld-sensitive but not object-
sensitive. Additional details about the string analysis can be
found in the technical report [31].
B. Evaluation
The evaluation of our approach was aimed at answering
three central questions:
Q1: Can IC3 precisely infer Ô¨Åeld values of ICC objects?
Q2: As an application of our analysis, how precisely can ICC
messages be matched with their targets?
Q3: Are the computational costs of IC3 feasible in practice?
The answer to these questions determines how effectively our
analysis can be used as the basis of inter-component analyses.
Highlights of our evaluation are:
IC3 infers precise Ô¨Åeld values for 85% of ICC values.
Epicc can only infer 66%. This is a signiÔ¨Åcant increase
in precision.
When matching components that may communicate with
one another, speciÔ¨Åcations from IC3 lead to 78% fewer
component links than the current state-of-the-art.
On average, our analysis takes 140 seconds per application.
This makes it feasible in practice to use our analysis as the
Ô¨Årst step of inter-component analyses.
For performance reasons, we generally do not allow the
constant propagation to analyze the Android framework code.
The only exception is when a framework class may create
or modify ICC objects, which only occurs in a few classes of
the framework. In the few cases where ICC method arguments
are not strings of characters (e.g., integer arguments), we use a
simple analysis that looks for deÔ¨Ånitions of constant values for
that argument. It simply traverses the interprocedural control
Ô¨Çow graph starting at the method call, keeping track of all
possible values. When a constant value cannot be found, a
special!value is conservatively returned.
We performed our experiments on a corpus of 500 appli-
cations. They were randomly selected from a set of 453,525
applications downloaded from the Google Play store between
January and September 2013. Some application could not be
processed because of insufÔ¨Åcient memory errors or timeout,
so we report numbers for 460 applications.
Precision of Ô¨Åeld values - We Ô¨Årst measured the precision
of the Ô¨Åelds of the ICC values inferred by IC3 at program
points of interest (i.e., sending a message, or programmatically
registering a component with an Intent Filter). The list of these
program points is given in [31]. We counted the number of
ICC values inferred by IC3 and Epicc [34] for which no Ô¨Åeld
value used for Intent or URI resolution is completely unknown
(e.g., a .*string value). We modiÔ¨Åed Epicc such that it used
the same entry point construction procedure from [1]. The
precision results are presented in Table I. The third line shows
the results for Intents and Intent Filters, whereas the fourth line
shows statistics for URIs. The value count column shows theTABLE I
ICC VALUE FIELD PRECISION RESULTS .
Value ICC values with precise Ô¨Åelds ICC values with imprecise Ô¨Åelds Missing ICC values
count Epicc IC3 Epicc IC3 Epicc IC3
Intents & Filters 5,306 3,660 (69%) 4,575 (86%) 1,474 (28%) 662 (12%) 172 (3%) 69 (1%)
URIs 522 176 (34%) 374 (72%) 158 (30%) 85 (16%) 188 (36%) 63 (12%)
Total 5,828 3,836 (66%) 4,949 (85%) 1,632 (28%) 747 (13%) 360 (6%) 132 (2%)
total number of ICC objects that were detected. The third and
fourth columns present the number of ICC values discovered
by Epicc and by IC3 that only have precise (e.g., not equal to
.*) Ô¨Åeld values. The Ô¨Åfth and sixth columns show the number
of imprecise values detected by each tool. Finally, the missing
columns show the number of locations where an ICC value
was missed by either tool.
We observe that the precision of the values inferred by IC3
for Intents, Intent Filters and URIs was high, with 85% of
values being detected accurately by our tool. Epicc, on the
other hand, could only precisely detect 66%. Of the 915 Intent
and Filter values that IC3 detected precisely but Epicc did
not, 591 were due to the presence of URI data in Intent
values, which is not handled by Epicc. In 4 cases, Epicc
missed a value that IC3 did not. The remaining 324 cases that
were precisely detected by IC3 and not by Epicc were due
to the more powerful string analysis. There was also a clear
difference in the case of URIs, with IC3 precisely determining
374 values, compared to 176 for Epicc. That is because Epicc
does not include a thorough model for URIs. In particular, a
number of methods refer to other modeled objects. Since this
is handled in an ad hoc manner in Epicc, good coverage of
these methods cannot be achieved, resulting in a lot of missed
values. On the other hand, using COAL speciÔ¨Åcations, IC3
achieves much better coverage of URI methods. In particular,
references to modeled values are handled in a principled and
generic manner. Finally, IC3 detected 73 fewer URI values
imprecisely than Epicc, thanks to our new string analysis.
There are several reasons why IC3 missed 132 ICC values.
First, some API callback methods have Intent or URI argu-
ments that cannot be known statically. For example, method
onReceive ()is a Broadcast Receiver callback that is called
upon reception of an Intent. The received Intent is passed as an
argument to that method by the framework upon activation of
the Receiver. The value of that Intent is in general impossible
to determine statically. We found 48 such cases. Another
related case was when URIs were extracted from Intents that
were callback arguments with the getData ()method, before
being used to address Content Providers. Another cause for
missed ICC values was when Intents were extracted from
containers such as sets or lists. We will investigate handling
these by tracking the values of these containers in future work.
We note that handling containers is challenging, especially
if tracking array indices is desired. Finally, we found a few
pathological cases where a call to an interface or abstract
method returning an Intent was not resolved to the proper
possible subtypes by the call graph construction procedure.
In the 747 cases where imprecise values were inferred,
the arguments to ICC API methods could not be determined.
Some cases are not yet handled by our argument analyses
(e.g., integer Ô¨Åelds and string array Ô¨Åelds), while other cases
cannot be determined statically (e.g., sequences of complexstring operations). We will continue investigating the cases
that can be resolved while keeping good performance.
Component matching - As an application of inferring ICC
values, we matched the computed Intents with potential target
components for the 460 applications. This is a fundamental ap-
plication of the ICC analysis, since the matching is necessary
for any inter-component analysis. Matching precision deter-
mines the precision of the overall analysis. Its inÔ¨Çuence on
analysis precision is similar to the inÔ¨Çuence of the call graph
construction process in interprocedural program analyses: an
imprecise call graph results in an overall imprecise analysis.
We implemented a matching process that was modeled
after the Android Intent resolution process. We performed
the matching using both the values computed by IC3 and
those calculated by Epicc. Matching Intent-sending program
locations with potential target components using values output
by IC3 produced 26,872 links. In contrast, the matching that
used Epicc values yielded 120,817 links. When performing
inter-component analysis, fewer potential links imply fewer
false positives (since the ICC value computation and matching
are conservative). The 78% reduction in potential targets is a
very signiÔ¨Åcant gain in precision. The reason why a 19% gain
in ICC value precision resulted in a 78% gain in matching
precision is that imprecise ICC values often cause an explosion
of the number of potential links. For example, when the action
of an Intent is not known, the matching process conservatively
matches it with all Intent Filter action values.
Performance - Processing all the applications took 64,571
seconds using our tool, or slightly less than 18 hours of
compute time. That is about 140 seconds per application
on average. The processing time was dominated by the IDE
problem solver and the string solver, taking 73% of the time
overall. The second most time-consuming function was the
entry point building procedure of [1], taking 20% of the total
time. Soot analyses (class loading, type inference, Ô¨Ånal call
graph construction, etc.) took 4% of the time. Other parts
of the analysis (e.g., COAL model parsing, result generation)
took 3% of the total time. We did not Ô¨Ånd any clear trend
describing how running time grows with size parameters of
the input program. We leave this matter for future work.
VIII. D ISCUSSION
Writing COAL speciÔ¨Åcations requires some effort, which
could be seen as a limitation. However, the effort to write a
speciÔ¨Åcation is much less than the effort required to produce
separate data Ô¨Çow models for each object. We have also found
that it is less prone to errors. Finally, handling cases where
modeled objects reference other modeled objects in a princi-
pled way (for example see Lines 12 and 22 of Figure 2(c))
has allowed us to model complex inter-object relationships
such as the one between Android Uri, UriBuilder and Intent.
We estimate that writing speciÔ¨Åcations for all modiÔ¨Åers andqueries for Android took us approximately Ô¨Åve hours using
the developer documentation for the classes involved. On the
other hand, writing ad hoc composite constant propagation
models for Epicc took longer than eight hours for each
modeled object, with an incomplete coverage. In order to make
writing speciÔ¨Åcations more effortless, we are looking into a
semi-automated inference approach. We believe that COAL
elements such as the list of Ô¨Åelds, many modiÔ¨Åers and sources
as well as queries can be inferred automatically.
We have successfully applied composite constant propa-
gation to Android ICC, but it can also be applied to other
problems where object values have to be inferred. In order to
ensure that this is the case, the COAL solver can be extended
by registering new COAL keywords for Ô¨Åeld operations and
Ô¨Åeld types. This enables support for additional operations
beyond add, remove, replace and clear, as well as for additional
method argument analyses.
Our evaluation does not compute the number of spurious
values that would be computed if we were not keeping track of
the correlations between Ô¨Åelds. We expect that, similarly to any
analysis reÔ¨Ånement, this will be useful in some contexts more
than others. In future work, we will quantify the precision
beneÔ¨Åt and potential performance penalty of keeping track of
Ô¨Åeld correlations over traditional constant propagation. We will
also compare our results with values from dynamic traces.
IC3 has the traditional limitations of static analysis on
Java. It does not handle native code or reÔ¨Çection. Some ap-
proaches [4] exist that can handle reÔ¨Çection for Java programs
and could be adapted for Android. Loops and recursion are
naturally handled for the operations that we deÔ¨Åned (i.e., add,
remove ,clear andreplace ) because the corresponding Ô¨Åeld
transformers are idempotent for composition. Other operations
(e.g., appending to a list) would require carefully deÔ¨Åning the
composition of the corresponding Ô¨Åeld transformers.
IX. R ELATED WORK
Single-valued interprocedural constant propagation has been
studied in the past [6], [16], [27], [36]. Unlike our work,
for each constant these works seek to Ô¨Ånd a single value
that is common to all interprocedural paths. Multi-valued
constant propagation [2], [26] has also been studied. While
our constant propagation is also multi-valued, it propagates
composite types. As we explain in Section III, it is possible
to simply consider Ô¨Åelds to be separate, single variables.
However, this approach limits the precision of the results.
We are not the Ô¨Årst to consider tuples of values in the
context of static analysis. Several works have used tuples or
vectors to represents properties of sets of sets of variables [10],
[19], [20], keeping track of correlations between properties
of different variables. Our analysis is more restricted in that
it only handles correlations between object Ô¨Åelds. However,
our goal is different: we aim to provide analysis designers
with a relatively easy-to-use layer of abstraction to statically
compute possible object values without having to write data
Ô¨Çow functions. This has enabled us to write a thorough model
of Android ICC with limited effort. We hope that it will
allow other analysis designers to quickly prototype and run
composite constant propagation analyses in various contexts.Analysis of Inter-Component Communication in Android
has been performed in past work. Dynamic analysis has
attempted to enforce security policies related to ICC [5],
[12]. Other work has performed inter-component dynamic
taint analysis [13]. Static analysis has also been investigated.
ComDroid [8] attempts to determine a limited number of
properties of Intents. Epicc [34] is the Ô¨Årst work that tried
to determine most Intent attributes that are useful for compo-
nent matching. It performs some ad hoc composite constant
propagation, which is considerably more complex than writing
COAL speciÔ¨Åcations. Another important difference is how
we deal with cases where modeled classes reference other
modeled types. Epicc deals with them in an ad hoc , class-
speciÔ¨Åc manner. On the other hand, our iterative algorithm
described in Section VI-C is completely generic and can
apply to all occurrences of modeled value references. As a
result, we can model all of ICC in Android. However, like
Epicc, our analysis is context-sensitive and Ô¨Çow-sensitive.
Apposcopy [15] uses static analysis as the basis of a signature-
based malware detection system. The static analysis includes
some ICC analysis limited to a subset of the Intent Ô¨Åelds. In
particular, URI data is not considered.
String analysis reasons about the set of values for string vari-
ables. While much work has been performed in this area [9],
[17], [21], [28], [37], [40], JSA [9] is the closest to our
analysis. However, JSA seeks to model all string operations,
whereas we limit our analysis to the most common cases.
Additionally, while JSA performs its own pointer analysis, we
rely on the more efÔ¨Åcient Spark [23] analysis, which is already
performed as part of the ICFG building process. As a result,
our analysis is much more efÔ¨Åcient in the context of Android
ICC analysis. Initial tests with JSA showed processing times
well over an hour for medium sized applications, which made
the entire ICC analysis impractical.
X. C ONCLUSION
In this paper, we introduced the MVC constant propagation
problem, and we presented the COAL language and the
associated solver for MVC problems. We also developed IC3,
an Android ICC analysis tool that is based on a reduction to
an MVC problem. As a part of IC3, we developed a sound
string analysis that offers an effective tradeoff of scalability
and precision. We achieved a much greater accuracy in ICC in-
ference than previous work. In the future we plan to investigate
more ways to improve accuracy, and to what extent generating
COAL speciÔ¨Åcations can be automated. Finally, we will apply
our IC3 work to design novel inter-component analyses in
Android.
ACKNOWLEDGEMENTS
We thank William Harris for editorial comments during
the writing of this paper. This material is based upon work
supported by National Science Foundation Grants No. CNS-
1064900, CNS-1228700, CNS-1228620 and CNS-1219495.
Any opinions, Ô¨Åndings, and conclusions or recommendations
expressed in this material are those of the authors and do
not necessarily reÔ¨Çect the views of the National Science
Foundation. This research was also supported by a Google
Faculty Research Award.REFERENCES
[1] Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bodden, Alexan-
dre Bartel, Jacques Klein, Yves Le Traon, Damien Octeau, and Patrick
McDaniel. Flowdroid: Precise context, Ô¨Çow, Ô¨Åeld, object-sensitive and
lifecycle-aware taint analysis for android apps. In Proceedings of the
35th ACM SIGPLAN Conference on Programming Language Design and
Implementation , PLDI ‚Äô14, pages 259‚Äì269, New York, NY , USA, 2014.
ACM.
[2] Gogul Balakrishnan and Thomas Reps. Analyzing memory accesses in
x86 executables. In Evelyn Duesterwald, editor, Compiler Construction ,
volume 2985 of Lecture Notes in Computer Science , pages 5‚Äì23.
Springer Berlin Heidelberg, 2004.
[3] Eric Bodden. Inter-procedural data-Ô¨Çow analysis with ifds/ide and soot.
In1st ACM SIGPLAN International Workshop on the State Of the Art
in Java Program Analysis (SOAP 2012) , pages 3‚Äì8, July 2012.
[4] Eric Bodden, Andreas Sewe, Jan Sinschek, Hela Oueslati, and Mira
Mezini. Taming reÔ¨Çection: Aiding static analysis in the presence
of reÔ¨Çection and custom class loaders. In Proceedings of the 33rd
International Conference on Software Engineering , ICSE ‚Äô11, pages
241‚Äì250, New York, NY , USA, 2011. ACM.
[5] Sven Bugiel, Lucas Davi, Alexandra Dmitrienko, Thomas Fischer,
Ahmad-Reza Sadeghi, and Bhargava Shastry. Towards taming privilege-
escalation attacks on Android. In Proceedings of the 19th Annual NDSS
Symposium , February 2012.
[6] David Callahan, Keith D. Cooper, Ken Kennedy, and Linda Torczon.
Interprocedural constant propagation. In Proceedings of the 1986
SIGPLAN Symposium on Compiler Construction , SIGPLAN ‚Äô86, pages
152‚Äì161, New York, NY , USA, 1986. ACM.
[7] David R. Chase, Mark Wegman, and F. Kenneth Zadeck. Analysis of
pointers and structures. In Proceedings of the ACM SIGPLAN 1990
Conference on Programming Language Design and Implementation ,
PLDI ‚Äô90, pages 296‚Äì310, New York, NY , USA, 1990. ACM.
[8] Erika Chin, Adrienne Porter Felt, Kate Greenwood, and David Wagner.
Analyzing inter-application communication in android. In Proceedings
of the 9th International Conference on Mobile Systems, Applications,
and Services , MobiSys ‚Äô11, pages 239‚Äì252, New York, NY , USA, 2011.
ACM.
[9] Aske Simon Christensen, Anders M√∏ller, and Michael I. Schwartzbach.
Precise analysis of string expressions. In Proceedings of the 10th In-
ternational Conference on Static Analysis , SAS‚Äô03, pages 1‚Äì18, Berlin,
Heidelberg, 2003. Springer-Verlag.
[10] Patrick Cousot and Radhia Cousot. Automatic synthesis of optimal
invariant assertions: Mathematical foundations. In Proceedings of the
1977 Symposium on ArtiÔ¨Åcial Intelligence and Programming Languages ,
pages 1‚Äì12, New York, NY , USA, 1977. ACM.
[11] Xingmin Cui, Da Yu, Patrick Chan, LucasC.K. Hui, S.M. Yiu, and
Sihan Qing. Cochecker: Detecting capability and sensitive data leaks
from component chains in android. In Willy Susilo and Yi Mu, editors,
Information Security and Privacy , volume 8544 of Lecture Notes in
Computer Science , pages 446‚Äì453. Springer International Publishing,
2014.
[12] Michael Dietz, Shashi Shekhar, Yuliy Pisetsky, Anhei Shu, and Dan S.
Wallach. Quire: Lightweight provenance for smart phone operating
systems. In Proceedings of the 20th USENIX Conference on Security ,
SEC‚Äô11, pages 23‚Äì23, Berkeley, CA, USA, 2011. USENIX Association.
[13] William Enck, Peter Gilbert, Byung-Gon Chun, Landon P. Cox,
Jaeyeon Jung, Patrick McDaniel, and Anmol N. Sheth. Taintdroid:
An information-Ô¨Çow tracking system for realtime privacy monitoring
on smartphones. In Proceedings of the 9th USENIX Conference on
Operating Systems Design and Implementation , OSDI‚Äô10, pages 1‚Äì6,
Berkeley, CA, USA, 2010. USENIX Association.
[14] Adrienne Porter Felt, Helen J. Wang, Alexander Moshchuk, Steven
Hanna, and Erika Chin. Permission re-delegation: Attacks and defenses.
InProceedings of the 20th USENIX Conference on Security , SEC‚Äô11,
pages 22‚Äì22, Berkeley, CA, USA, 2011. USENIX Association.
[15] Yu Feng, Saswat Anand, Isil Dillig, and Alex Aiken. Apposcopy:
Semantics-based detection of android malware through static analysis.
InProceedings of the 22Nd ACM SIGSOFT International Symposium on
Foundations of Software Engineering , FSE 2014, pages 576‚Äì587, New
York, NY , USA, 2014. ACM.
[16] Dan Grove and Linda Torczon. Interprocedural constant propagation: A
study of jump function implementation. In Proceedings of the ACM
SIGPLAN 1993 Conference on Programming Language Design and
Implementation , PLDI ‚Äô93, pages 90‚Äì99, New York, NY , USA, 1993.
ACM.[17] Pieter Hooimeijer and Westley Weimer. A decision procedure for
subset constraints over regular languages. In Proceedings of the 2009
ACM SIGPLAN Conference on Programming Language Design and
Implementation , PLDI ‚Äô09, pages 188‚Äì198, New York, NY , USA, 2009.
ACM.
[18] Jianjun Huang, Xiangyu Zhang, Lin Tan, Peng Wang, and Bin Liang.
Asdroid: Detecting stealthy behaviors in android applications by user
interface and program behavior contradiction. In Proceedings of the
36th International Conference on Software Engineering , ICSE 2014,
pages 1036‚Äì1046, New York, NY , USA, 2014. ACM.
[19] Neil D. Jones and Steven S. Muchnick. Complexity of Ô¨Çow analysis,
inductive assertion synthesis and a language due to dijkstra. In 21st
Annual Symposium on Foundations of Computer Science, Syracuse, New
York, USA, 13-15 October 1980 , pages 185‚Äì190, 1980.
[20] Neil D. Jones and Steven S. Muchnick. A Ô¨Çexible approach to interpro-
cedural data Ô¨Çow analysis and programs with recursive data structures.
InProceedings of the 9th ACM SIGPLAN-SIGACT Symposium on
Principles of Programming Languages , POPL ‚Äô82, pages 66‚Äì74, New
York, NY , USA, 1982. ACM.
[21] Adam Kiezun, Vijay Ganesh, Philip J. Guo, Pieter Hooimeijer, and
Michael D. Ernst. Hampi: A solver for string constraints. In Proceedings
of the Eighteenth International Symposium on Software Testing and
Analysis , ISSTA ‚Äô09, pages 105‚Äì116, New York, NY , USA, 2009. ACM.
[22] William Klieber, Lori Flynn, Amar Bhosale, Limin Jia, and Lujo Bauer.
Android taint Ô¨Çow analysis for app sets. In Proceedings of the 3rd
ACM SIGPLAN International Workshop on the State of the Art in Java
Program Analysis , SOAP ‚Äô14, pages 1‚Äì6, New York, NY , USA, 2014.
ACM.
[23] Ond Àárej Lhot ¬¥ak and Laurie Hendren. Scaling java points-to analysis using
spark. In Grel Hedin, editor, Compiler Construction , volume 2622 of
Lecture Notes in Computer Science , pages 153‚Äì169. Springer Berlin
Heidelberg, 2003.
[24] Li Li, Alexandre Bartel, Tegawend ¬¥e Bissyande, Jacques Klein, Yves Le
Traon, Steven Arzt, Siegfried Rasthofer, Eric Bodden, Damien Octeau,
and Patrick McDaniel. IccTA: Detecting Inter-Component Privacy Leaks
in Android Apps. In Proceedings of the 37th International Conference
on Software Engineering (ICSE) , May 2015.
[25] Long Lu, Zhichun Li, Zhenyu Wu, Wenke Lee, and Guofei Jiang. Chex:
Statically vetting android apps for component hijacking vulnerabilities.
InProceedings of the 2012 ACM Conference on Computer and Com-
munications Security , CCS ‚Äô12, pages 229‚Äì240, New York, NY , USA,
2012. ACM.
[26] E. Merlo, J.F. Girard, L. Hendren, and R. De Mori. Multi-valued
constant propagation for the reengineering of user interfaces. In
Proceedings of the 1993 Conference on Software Maintenance , pages
120‚Äì129, Sep 1993.
[27] Robert Metzger and Sean Stroud. Interprocedural constant propagation:
An empirical study. ACM Letters on Programming Languages Systems ,
2(1-4):213‚Äì232, March 1993.
[28] Yasuhiko Minamide. Static approximation of dynamically generated
web pages. In Proceedings of the 14th International Conference on
World Wide Web , WWW ‚Äô05, pages 432‚Äì441, New York, NY , USA,
2005. ACM.
[29] Trustlook News. Emergency: Android in-app billing veriÔ¨Åcation
bypass vulnerability, November 2013. Available from
http://blog.trustlook.com/index.php/emergency-android-app-billing-
veriÔ¨Åcation-bypass-vulnerability/.
[30] Damien Octeau, Somesh Jha, and Patrick McDaniel. Retargeting android
applications to java bytecode. In Proceedings of the ACM SIGSOFT 20th
International Symposium on the Foundations of Software Engineering ,
FSE ‚Äô12, pages 6:1‚Äì6:11, New York, NY , USA, 2012. ACM.
[31] Damien Octeau, Daniel Luchaup, Matthew Dering, Somesh Jha, and
Patrick McDaniel. Android inter-component communication analysis
with the coal constant propagation language. Technical Report NAS-
TR-0170-2014, Network and Security Research Center, Department
of Computer Science and Engineering, Pennsylvania State University,
University Park, PA, USA, 2014.
[32] Damien Octeau, Daniel Luchaup, Somesh Jha, and Patrick McDaniel.
Coal constant propagation language. http://siis.cse.psu.edu/coal/, 2014.
[33] Damien Octeau, Daniel Luchaup, Somesh Jha, and Patrick Mc-
Daniel. IC3: Android inter-component communication analysis.
http://siis.cse.psu.edu/ic3/, 2014.
[34] Damien Octeau, Patrick McDaniel, Somesh Jha, Alexandre Bartel,
Eric Bodden, Jacques Klein, and Yves Le Traon. Effective inter-
component communication mapping in android with epicc: An essential
step towards holistic security analysis. In Proceedings of the 22NdUSENIX Conference on Security , SEC‚Äô13, pages 543‚Äì558, Berkeley,
CA, USA, 2013. USENIX Association.
[35] Thomas Reps, Stefan Schwoon, Somesh Jha, and David Melski.
Weighted pushdown systems and their application to interprocedural
dataÔ¨Çow analysis. Science of Computer Programming , 58(12):206 ‚Äì
263, 2005. Special Issue on the Static Analysis Symposium 2003 SAS
‚Äô03 10th International Static Analysis Symposium.
[36] Mooly Sagiv, Thomas Reps, and Susan Horwitz. Precise interprocedural
dataÔ¨Çow analysis with applications to constant propagation. Theoretical
Computer Science , 167(1-2):131‚Äì170, October 1996.
[37] Prateek Saxena, Devdatta Akhawe, Steve Hanna, Feng Mao, Stephen
McCamant, and Dawn Song. A symbolic execution framework for
javascript. In Proceedings of the 2010 IEEE Symposium on Security and
Privacy , SP ‚Äô10, pages 513‚Äì528, Washington, DC, USA, 2010. IEEE
Computer Society.
[38] Feng Shen, Namita Vishnubhotla, Chirag Todarka, Mohit Arora, Babu
Dhandapani, Eric John Lehner, Steven Y . Ko, and Lukasz Ziarek.
Information Ô¨Çows as a permission mechanism. In Proceedings of
the 29th ACM/IEEE International Conference on Automated Software
Engineering , ASE ‚Äô14, pages 515‚Äì526, New York, NY , USA, 2014.
ACM.[39] Raja Vallee-Rai, Etienne Gagnon, Laurie Hendren, Patrick Lam, Patrice
Pominville, and Vijay Sundaresan. Optimizing java bytecode using the
soot framework: Is it feasible? In David A. Watt, editor, Compiler
Construction , Lecture Notes in Computer Science. Springer Berlin
Heidelberg, 2000.
[40] Gary Wassermann and Zhendong Su. Sound and precise analysis of
web applications for injection vulnerabilities. In Proceedings of the
2007 ACM SIGPLAN Conference on Programming Language Design
and Implementation , PLDI ‚Äô07, pages 32‚Äì41, New York, NY , USA,
2007. ACM.
[41] Fengguo Wei, Sankardas Roy, Xinming Ou, and Robby. Amandroid:
A precise and general inter-component data Ô¨Çow analysis framework
for security vetting of android apps. In Proceedings of the 2014 ACM
SIGSAC Conference on Computer and Communications Security , CCS
‚Äô14, pages 1329‚Äì1341, New York, NY , USA, 2014. ACM.
[42] Mu Zhang and Heng Yin. Appsealer: Automatic generation of
vulnerability-speciÔ¨Åc patches for preventing component hijacking at-
tacks in android applications. In Proceedings of the 21th Annual Network
and Distributed System Security Symposium (NDSS ‚Äô14) , 2014.