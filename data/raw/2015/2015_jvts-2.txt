A Symbolic Justice Violations Transition System
for Unrealizable GR(1) Specifications
Aviv Kuvent, Shahar Maoz, Jan Oliver Ringert
School of Computer Science, Tel Aviv University, Israel
ABSTRACT
One of the main challenges of reactive synthesis, an automated
procedure to obtain a correct-by-construction reactive system, is to
deal with unrealizable speci/f_ications. Existing approaches to deal
with unrealizability, in the context of GR(1), an expressive assume-
guarantee fragment of LTL that enables eï¬ƒcient synthesis, include
the generation of concrete counter-strategies and the computation
of an unrealizable core. Although correct, such approaches pro-
duce large and complicated counter-strategies, o/f_ten containing
thousands of states. /T_his hinders their use by engineers.
In this work we present the Justice Violations Transition System
(JVTS), a novel symbolic representation of counter-strategies for
GR(1). /T_he JVTS is much smaller and simpler than its corresponding
concrete counter-strategy. Moreover, it is annotated with invariants
that explain how the counter-strategy forces the system to violate
the speci/f_ication. We compute the JVTS symbolically, and thus
more eï¬ƒciently, without the expensive enumeration of concrete
states. Finally, we provide the JVTS with an on-demand interactive
concrete and symbolic play.
We implemented our work, validated its correctness, and evalu-
ated it on 14 unrealizable speci/f_ications of autonomous Lego robots
as well as on benchmarks from the literature. /T_he evaluation shows
not only that the JVTS is in most cases much smaller than the cor-
responding concrete counter-strategy, but also that its computation
is faster.
CCS CONCEPTS
â€¢So/f_tware and its engineering â†’Formal methods; So/f_tware veri-
/f_ication;
KEYWORDS
reactive synthesis, GR(1), unrealizability
1 INTRODUCTION
Reactive synthesis is an automated procedure to obtain a correct-
by-construction reactive system from its temporal logic speci/f_ica-
tion [ 20]. Rather than manually constructing an implementation
and using model checking to verify it against a speci/f_ication, syn-
thesis oï¬€ers an approach where a correct implementation of the
system is automatically obtained for a given speci/f_ication, if such
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for pro/f_it or commercial advantage and that copies bear this notice and the full citation
on the /f_irst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permi/t_ted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speci/f_ic permission and/or a
fee. Request permissions from permissions@acm.org.
ESEC/FSEâ€™17, Paderborn, Germany
Â©2017 ACM. 978-1-4503-5105-8/17/09... $15.00
DOI: 10.1145/3106237.3106240an implementation exists. In the case of reactive synthesis, an
implementation is typically given as a controller, i.e., an automa-
ton that accepts input from the environment (e.g., from sensors)
and produces the systemâ€™s output (e.g., commands for actuators)
to always satisfy the speci/f_ication. If such a controller exists, the
speci/f_ication is considered realizable. Otherwise, the speci/f_ication
is unrealizable â€“ there exists an environment that can force the
system to violate some of its guarantees.
GR(1) is a fragment of LTL, which has an eï¬ƒcient symbolic
synthesis algorithm [ 3,19] and whose expressive power covers
most of the well-known LTL speci/f_ication pa/t_terns of Dwyer et
al. [7,13]. GR(1) speci/f_ications include assumptions and guarantees
about what needs to hold on initial states, on all states (safety), and
in/f_initely o/f_ten on every run (justice). GR(1) synthesis has been
used and extended in diï¬€erent contexts and for diï¬€erent applica-
tion domains, including robotics [ 11,12], scenario-based speci/f_ica-
tions [ 16], aspect languages [ 15], event-based behavior models [ 6],
hybrid systems [9], and device drivers [23], to name a few.
Previous work has shown how the debugging of an unrealizable
speci/f_ication, in the context of GR(1), can be done via the extraction
of a counter-strategy (CS), which the engineer may explore in order
to analyze the source of unrealizability [ 10,18]. First a Rabin game
is played over the speci/f_ication, and then intermediate values saved
during the game are used to extract the concrete CS. /T_he extracted
concrete CS can be viewed as a labeled transition system (LTS) that
represents a deterministic choice for the environment for every
choice by the system. /T_he LTS can contain cycles in which all
environment assumptions are satis/f_ied while at least one system
justice guarantee is violated, states which can force the system to
these cycles, and states from which every system choice violates a
safety guarantee. Although correct, such concrete CS LTS is o/f_ten
large and complex, making it expensive to compute and diï¬ƒcult to
explore eï¬€ectively.
In this work we introduce the Justice Violations Transition Sys-
tem (JVTS), a new, abstract, symbolic representation of a CS, with
three key properties. First, unlike a concrete CS, the JVTS is acyclic
and is typically small. /T_hus, in comparison to the concrete CS, it is
much simpler and easier to explore. Second, although it is abstract,
it is complete: every in/f_inite and /f_inite play on the concrete CS
has a corresponding play on the JVTS. /T_hird, the JVTS states are
annotated with invariants that relate them to the speci/f_ication and
explain exactly how the CS can force the system to violate the spec-
i/f_ication. /T_he JVTS is comprised of cycle-states, which represent
sets of concrete states that the system can visit in/f_initely o/f_ten, and
a/t_tractor-states, which represent sets of concrete states that the
system can visit at most once. We formally de/f_ine the JVTS, discuss
its properties, and present a symbolic algorithm to compute it in
Sect. 4.ESEC/FSEâ€™17, September 4â€“8, 2017, Paderborn, Germany Aviv Kuvent, Shahar Maoz, Jan Oliver Ringert
1env boolean dockRequest ;
2sys boolean ready ;
3sys boolean docking ;
4
5// don /quotesingle.Vart dock before ready
6asm G dockRequest -> ONCE ( ready );
7
8gar Ready :
9 GFready ;
10
11// respond to dock requests
12gar DockingResponse :
13 pRespondsToS ( dockRequest , docking );
14
15gar G docking -> dockRequest ;
16
17gar G docking -> ! next ( docking );
Listing 1: Excerpt of the docking mechanism speci/f_ication
In addition to statically computing and presenting the JVTS, we
introduce an interactive approach to dynamically concretize parts of
it and execute it step-by-step while alternating between the concrete
and the symbolic representations. We describe the interactive,
simultaneous play of concrete and symbolic CS representations
in Sect. 5. We further minimize the JVTS by merging of a/t_tractor
nodes described in Sect. 6.
We have implemented all the above ideas in a GR(1) synthesis
framework, and integrated them into an Eclipse-based environ-
ment. We present a preliminary evaluation of our work using 14
speci/f_ications of autonomous Lego robots (created by students in
a project class that we have taught) as well as using benchmarks
from the literature. /T_he evaluation provides evidence that in many
speci/f_ications, the size of the JVTS is much smaller than that of
the concrete CS, and that its computation is faster. We present the
evaluation in Sect. 7.
Previous works on debugging unrealizable speci/f_ications for
reactive synthesis (e.g., [ 1,4,10,18]) have considered the notion
of unrealizable core, and the idea of semi-automatic discovery of
possible assumptions to repair an unrealizable speci/f_ication. To the
best of our knowledge, all have used concrete CSs and none has
considered a symbolic representation such as the JVTS. We discuss
related work in Sect. 8.
2 RUNNING EXAMPLE
We start oï¬€ with a running example of an unrealizable speci/f_ication
of the docking mechanism of a space station. /T_he speci/f_ication
shown in Lst. 1 is deliberately small, to /f_it and be simple enough
to explain in the paper format. /T_he speci/f_ications used in our
evaluation (see Sect. 7) are larger and more complex.
2.1 Example Speci/f_ication
/T_he docking mechanism described by the speci/f_ication in Lst. 1
receives as input a docking request (represented by the Boolean
environment variable dockRequest ) and outputs whether the space
station is ready to receive docking requests (the Boolean system
variable ready ) and whether the requesting spacecra/f_t should pro-
ceed with docking (the Boolean system variable docking ). /T_he
speci/f_ication contains an assumption that a docking request is only
sent if the mechanism was in a ready state at some point previously,
as expressed in the environment assumption GdockRequest ->
ONCE(ready) . All systems satisfying the speci/f_ication will even-
tually be ready to accept docking requests, expressed by justice
s0 s1 s3
s2
s7
s8s6
s9
s10 s11 ready = true 
docking = true 
dockRequest = true 
AUX_Once = true 
AUX_Must_Respond = false s4ready = false 
docking = false 
dockRequest = true 
AUX_Once = true 
AUX_Must_Respond = false 
s5Figure 1: Concrete CS LTS for the docking mechanism speci/f_ica-
tion, as computed by existing tools such as [4, 10, 18].
guarantee Ready :GFready . /T_he guarantee DockingResponse :
pRespondsToS(dockRequest, docking) ensures that every dock-
ing request will eventually receive a response, allowing the space-
cra/f_t to dock. /T_his is de/f_ined using the pRespondsToS pa/t_tern,
which is translated to G(dockRequest -> Fdocking)1. /T_he last
two guarantees require that there is a docking request when the
mechanism allows docking Gdocking -> dockRequest , and that
there should not be two consecutive docking responses Gdocking
-> !next(docking) .
/T_his speci/f_ication is unrealizable. To try to understand the prob-
lem using existing tools [ 4,10,18], the engineer can generate a
concrete CS, as shown in Fig. 1 (the complete result will list in each
state the assignments to all of the variables; to avoid clu/t_ter, we
show assignments only for states s4ands7).
While the concrete CS in Fig. 1 does not contain many states,
one can see that even for such a simple and small speci/f_ication, the
concrete CS as computed by existing tools is already relatively com-
plicated. Moreover, computing an unrealizable core (as suggested
by some tools [ 4,10]) will not help here, because the core for this
example speci/f_ication contains all guarantees and system variables.
2.2 /T_he Justice Violations Transition System
We present an alternative, the Justice Violations Transition System
(JVTS), a symbolic representation of a CS, which is much smaller,
simpler (acyclic), and informative. Fig. 2 shows the JVTS we com-
pute for the same example speci/f_ication.
1/T_his LTL formula is not in GR(1). We use here its equivalent GR(1) translation,
see [13].
attractor 
cycle 
!DockingResponse cycle 
!Ready ready = false 
docking = false 
dockRequest = false 
AUX_Once = false 
AUX_Must_Respond = false AUX_Once = true 
AUX_Must_Respond = false 
docking = false 
dockRequest = false 
AUX_Once = true 
AUX_Must_Respond = true attractor 
docking = true 
dockRequest = false q1 q2
q3 q4
Figure 2: JVTS for the docking mechanism speci/f_ication. States are
labeled with invariants.JVTS ESEC/FSEâ€™17, September 4â€“8, 2017, Paderborn, Germany
s2s6
s7s4s5
Figure 3: /T_he concretization of attractor q1in the JVTS of
the space station docking mechanism shown in Fig. 2. /T_he
names of concrete states are the ones appearing in Fig. 1.
From the JVTS, the engineer sees that the system can initially
choose whether to set ready for docking requests or not. If it never
sets the variable ready , it remains in a cycle-state ( q2) where it will
violate the system justice of Ready . If it sets ready at any point, it
moves to an a/t_tractor state ( q1) from which the environment can
force the system to a second cycle-state ( q3), where the system
justice of DockingResponse is violated. In addition, in every state
the system can choose to set docking when the environment sets
!dockRequest , which will get it to a/t_tractor state q4, representing
the violation of the safety Gdocking -> dockRequest .
To be/t_ter understand the /f_low when the system chooses to set
ready , the engineer can begin by selecting the cycle-state q3and
viewing the invariants over the concrete states it contains, as
shown in Fig. 2. AUXMust Respond is an auxiliary variable in-
dicating that there was previously a docking request to which
the system must respond. From these invariants it is clear to
the engineer that indeed the system violates the justice guaran-
tee of DockingResponse , since previously there was a state where
dockRequest is set, but the environment does not provide this value
again (invariant !dockRequest ), and the system cannot therefore
setdocking without violating the safety guarantee Gdocking ->
dockRequest .
2.3 Concretizing a JVTS State
To be/t_ter observe how the environment can force the system to q3
(once the system sets ready ), the engineer can concretize only the
a/t_tractor state q1, resulting in the concrete LTS shown in Fig. 3.
/T_he engineer can choose each of the states in the concretized
a/t_tractor to view the variable assignments, as she would do in the
concrete CS. In Fig. 3, the states are named using the equivalent
states in the concrete LTS of Fig 1. /T_he initial state s2is the state
where ready & !dockRequest & !docking . /T_his state has 4 suc-
cessor states, which depend on the system choice. In all of them,
dockRequest holds. However, the system can choose whether to
respond immediately to this request, resulting in states s6ors7,
where docking is set, or not to respond immediately, resulting in
states s4ors5, where !docking . Even if the system responds, the en-
vironment sends dockRequest immediately and the system cannot
respond to it immediately without violating the safety guarantee G
docking -> !next(docking) . /T_herefore, in states s4ands5it also
holds that dockRequest . Finally, in the next step the environment
will not send a docking request, and hence trap the system in the
previously described cycle-state q3.
/T_he above example demonstrates how the JVTS provides the
engineer with a high-level view of the CS, and then focus on speci/f_ic
areas of interest for more in-depth examination. Concretization
of a JVTS state is done only on demand. /T_he engineer can also
choose to start an interactive play from a JVTS state (where theengineer plays the role of the system), moving between concrete
states contained in it based on the engineer choices of output. We
describe state concretization and interactive play in Sect. 5.
3 PRELIMINARIES
3.1 LTL and GR(1)
We repeat some of the standard de/f_initions of linear temporal logic
(LTL), e.g., as found in [ 3], a modal temporal logic with modalities
referring to time. /T_he syntax of LTL formulas is typically de/f_ined
over a set of atomic propositions APwith the future temporal
operators X(next) and U(until).
De/f_inition 3.1. /T_he syntax of LTL formulas over APis
Ï†::=pj:Ï†jÏ†_Ï†jXÏ†jÏ†UÏ†forp2AP.
ForÎ£=2AP, a computation u=u0u1::2Î£Ï‰is a sequence where
uiis the set of atomic propositions that hold at the i-th position.
For position iwe use u;ij=Ï†to denote that Ï†holds at position i,
inductively de/f_ined as:
u;ij=piï¬€p2ui;
u;ij=:Ï•iï¬€u;i6j=Ï•;
u;ij=Ï†1_Ï†2iï¬€u;ij=Ï†1oru;ij=Ï†2;
u;ij=XÏ†iï¬€u;i+1j=Ï†;
u;ij=Ï†1UÏ†2iï¬€9ki:u;kj=Ï†2and 8j;ij<k:u;jj=Ï†1:
We denote u;0j=Ï†byuj=Ï†. We use additional LTL operators
F(/f_inally), G(globally), ONCE andH(historically):
FÏ†:=true UÏ†;
GÏ†:=:F:Ï†;
u;ij=ONCEÏ†iï¬€90ki:u;kj=Ï†;
u;ij=HÏ†iï¬€80ki:u;kj=Ï†.
LTL formulas can be used as speci/f_ications of reactive systems
where atomic propositions are interpreted as environment (input)
and system (output) variables. An assignment to all variables is
called a state.
A strategy for an LTL speci/f_ication Ï†prescribes the outputs of a
system that from its winning states for all environment choices lead
to computations that satisfy Ï†. A speci/f_ication Ï†is called realizable
if a strategy exists such that for all initial environment choices the
initial states are winning states. /T_he goal of LTL synthesis is, given
an LTL speci/f_ication, to /f_ind a strategy that realizes it, if one exists.
GR(1) synthesis [ 3] handles a fragment of LTL where speci/f_ica-
tions contain initial assumptions and guarantees over initial states,
safety assumptions and guarantees relating the current and next
state, and justice assumptions and guarantees requiring that an as-
sertion holds in/f_initely many times during a computation. A GR(1)
synthesis problem consists of the following elements [3]:
 X input variables controlled by the environment;
 Y output variables controlled by the system;
Î¸eassertion overXcharacterizing initial environment states;
Î¸sassertion overX[Y characterizing initial system states;
ÏeÂ¹X[Y ;XÂºtransition relation of the environment;
ÏsÂ¹X[Y ;X[YÂº transition relation of the system;
/J.alte
i21: :njustice goals of the environment;
/J.alts
j21: :mjustice goals of the system.ESEC/FSEâ€™17, September 4â€“8, 2017, Paderborn, Germany Aviv Kuvent, Shahar Maoz, Jan Oliver Ringert
GR(1) synthesis has the following notion of (strict) realizability:
Ï†sr=Â¹Î¸e!Î¸sÂº^Â¹Î¸e!GÂ¹Â¹HÏeÂº!ÏsÂºÂº^
Â¹Î¸e^GÏe!Â¹Ã›
i21: :nGF/J.alte
i!Ã›
j21: :mGF/J.alts
jÂºÂº:
Speci/f_ications for GR(1) synthesis have to be expressible in the
above structure and thus do not cover the complete LTL. Eï¬ƒcient
symbolic algorithms for GR(1) realizability checking and controller
synthesis for Ï†srhave been presented in [ 3,19]. /T_he algorithm of
Piterman et al. [ 19] computes winning states for the system, i.e.,
states from which the system can ensure satisfaction of Ï†sr.
3.2 Unrealizability and Rabin Game
A speci/f_ication Ï†sris unrealizable if there is a CS in which the
environment can force the system to violate one of its guarantees
while satisfying all the environment assumptions. In such a CS,
there is an initial environment choice for which the initial states are
not winning for the system. A CS can be represented as a labeled
transition system (LTS).
De/f_inition 3.2 (CS LTS). Given an unrealizable speci/f_ication Ï†sr,
a CS is an LTShQ;T;I;Liwhere:
Qis a set of states;
Lis a labeling function L:Q!2X[Y;
TQQis a transition relation where 8q2Q:
â€“qis a deadlock for the system Âšq0:TÂ¹q;q0Âºiï¬€
9x2X:ÏeÂ¹q;xÂº^8/y.alt2Y ::ÏsÂ¹q;hx;/y.altiÂº
â€“or the transitions from qare environment deterministic and
system complete:
91x2X:ÏeÂ¹q;xÂº^8/y.alt2Y :
ÏsÂ¹q;hx;/y.altiÂº! 9q02Q:LÂ¹q0Âº=hx;/y.alti^TÂ¹q;q0Âº
Iis a set of initial states such that:
â€“the environment initially deadlocks the system I=;iï¬€
9x2X:Î¸eÂ¹xÂº^8/y.alt2Y ::Î¸sÂ¹x;/y.altÂº
â€“or the initial states are environment deterministic and system
complete:
91x2X:Î¸eÂ¹xÂº^8/y.alt2Y :
Î¸sÂ¹x;/y.altÂº!9q2I:LÂ¹qÂº=hx;/y.alti
and every in/f_inite path Ï€=q1q2: : :of the LTS violates Ï†sr, i.e.,
LÂ¹q1ÂºLÂ¹q2Âº: : :6j=Ï†sr(unrealizability).
For a CS we say that a state qison a cycle iï¬€ the system has a
strategy to visit the state in/f_initely many times.
De/f_inition 3.3 (state on a cycle). Given a CS TS=hQ;T;I;Li,
a state q2Qis on a cycle in TSif there exists an in/f_inite path
Ï€=q1q2: : :ofTSs.t.qrepeats in/f_inite times in Ï€.
It is obvious that for every such cycle there exists at least one
justice guarantee /J.alts
ithat is not satis/f_ied by any state on the cycle.
Konighofer et al. [ 10] and Maoz and Saâ€™ar [ 18] show how to
derive a CS for an unrealizable speci/f_ication from the intermediate
results of a Rabin game. /T_he game computes the environmentâ€™swinning states, displayed here using Âµ-calculus notation:
Wen/v.alt=ÂµZ:mÃ˜
j=1Î½Y:nÃ™
i=1ÂµX:
Â¹:/J.alts
j[
Â¹ZÂºÂº\
Â¹YÂº\Â¹/J.alte
i[
Â¹XÂºÂº
where/J.alte
iis environment justice i,/J.alts
jis system justice j, and
Â¹RÂº=fq22X[Yj9x2X:ÏeÂ¹q;xÂº^8/y.alt2Y :
Â¹:ÏsÂ¹q;hx;/y.altiÂº_h x;/y.alti2RÂºg:
/T_he Rabin game algorithm computes CSs based on cycles vio-
lating at least one justice guarantee /J.alts
iwhile satisfying all justice
assumptions /J.alte
j. Cycles can be le/f_t by the system iï¬€ the environ-
ment can force it to a future cycle (ensures termination) or to a
safety guarantee violation.
Note that the above still allows CSs that are â€œlargerâ€ than the
ones we compute. Importantly, all the ones we compute satisfy
Def. 3.2. Note that a CS can have memory and jQj2OÂ¹nj2X[YjÂº.
During the computation of the Rabin game, the following inter-
mediate results are collected:
Z- array of sets of concrete states. Cell ZÂ»iÂ¼contains concrete
states which either violate system justice guarantee iÂ¹mod mÂº
or from which the environment can force the system to a cell
ZÂ»jÂ¼with j<i.
X- A three-dimensional array of sets of concrete states. For
indices ifrom 0 tojZj 1 (cell ZÂ»iÂ¼),jfrom 0 to n 1 (for justice
assumption /J.alte
j), and k(maximal number of steps required to
satisfy current /J.alte
j, each step consisting of a concrete state), the
cellXÂ»iÂ¼Â»jÂ¼Â»kÂ¼contains a set of concrete states which (1) for k=0
satisfy environment justice assumption /J.alte
jand have a successor
inXÂ»iÂ¼Â»j0Â¼Â»k0Â¼forj0=Â¹j+1mod nÂºand some k0or (2) are a step
towards satisfying /J.alte
jand have a successor in XÂ»iÂ¼Â»jÂ¼Â»k0Â¼with
k0<k.
Based on the Rabin game we de/f_ine the Z-Rank of a state:
De/f_inition 3.4 (Z-Rank). /T_he Z rank of a state scontained in the
intermediate results of the Rabin game is:
ZRankÂ¹sÂº=minfijs2ZÂ»iÂ¼g.
By construction of the Rabin game, all states on a cycle have the
same Z-Rank iand avoid satisfaction of at least the justice guarantee
/J.alts
imodm. We denote all states of Z-Rank ibyZRankSÂ¹iÂºZÂ»iÂ¼. For
a set of states S, all of Z-Rank i, we de/f_ine ZRankÂ¹SÂº=i.
4 THE JUSTICE VIOLATIONS TRANSITION
SYSTEM (JVTS)
We are now ready to present the main contribution of our work,
namely the Justice Violations Transition System (JVTS). We de/f_ine
the JVTS in Sect. 4.1 and describe the symbolic algorithm to compute
it in Sect. 4.2.
4.1 De/f_ining the JVTS
A Justice Violations Transition System (JVTS) is an acyclic LTS
consisting of two types of states, cycle-states and a/t_tractor-states.
Each state in the JVTS represents a set of states in some CS, andJVTS ESEC/FSEâ€™17, September 4â€“8, 2017, Paderborn, Germany
each transition in the JVTS represents a set of transitions in the CS.
We call this CS a CS of the JVTS.
De/f_inition 4.1 (Justice Violations TS (JVTS)). Given an unrealiz-
able GR(1) speci/f_ication, a JVTS is an acyclic LTS TSj=hQj;Tj;Ij;
Lji, s.t. there exists a concrete CS TSc=hQc;Tc;Ic;Lci, extracted
from the intermediate values of a Rabin game (note that every
qc2Qchas a ZRank per Def. 3.4), where:
Qjis a partition of Qcwhere for each qj2Qjeither
â€“qjis a cycle-state, i.e., 8qc2qj:qcis on a cycle in TSc
(see Def. 3.3) or 9C1;C2Qcrepresenting cycles in TSc, s.t.
ZRankÂ¹C1Âº=ZRankÂ¹C2Âºandqcis on a path from C1toC2in
TSc(i.e. in-between cycles with same Z-Rank), or
â€“qjis an a/t_tractor-state, i.e., 8qc2qj:qcis on a path leading to
a deadlock or cycle only through a/t_tractor states or 9C1;C2
Qcrepresenting cycles in TSc, s.t. ZRankÂ¹C1Âº>ZRankÂ¹C2Âº
andqcis on a path from C1toC2inTSconly through a/t_tractor
states (i.e. in-between cycles with decreasing Z-Ranks);
Ljis a labeling function: 8qj2Qj:LjÂ¹qjÂº=fLcÂ¹qcÂºjqc2qjg;
TjQjQjis a transition relation where TjÂ¹qj
1;qj
2Âºiï¬€
qj
1,qj
2^9qc
12qj
1;qc
22qj
2:TcÂ¹qc
1;qc
2Âº; and
Ijis a set of initial states: qj2Ijiï¬€Â¹qj\IcÂº,;.
Example 4.2. In our running example (Sect. 2) Fig. 2 shows a
JVTS. A CS of the JVTS is shown in Fig. 1. /T_he label of a/t_tractor
state q1is:LjÂ¹q1Âº=fLcÂ¹s2Âº;LcÂ¹s4Âº;LcÂ¹s5Âº;LcÂ¹s6Âº;LcÂ¹s7Âºg, where
s2;s4;s5;s6;ands7are the concrete states contained in q1, as can
be seen in Fig. 3. From the de/f_inition of Lcin Def. 3.2, the label
LjÂ¹q1Âºis the set of assignments to input and output variables in the
concrete states contained in q1.
Note that Def. 4.1 allows for multiple JVTSs for the same CS (we
look at a minimal JVTS in Sect. 6).
/T_he following states the completeness of the JVTS in terms of
paths in its concrete CS computed by the Rabin game algorithm.
T/h.sc/e.sc/o.sc/r.sc/e.sc/m.sc 4.3 (JVTS C/o.sc/m.sc/p.sc/l.sc/e.sc/t.sc/e.sc/n.sc/e.sc/s.sc/s.sc). Given a concrete CS LTS
TScof a JVTS TSj, the following holds:
For every in/f_inite path Ï€c=qc
1qc
2::inTSc, exists a single corre-
sponding /f_inite path Ï€j=qj
1::qj
kinTSjs.t.qj
kis a cycle-state
for justice /J.alts
iandÏ€c6j=GF/J.alts
i;
For every /f_inite path Ï€c=qc
1::qcrinTSc, exists a single corre-
sponding /f_inite path Ï€j=qj
1::qj
k(kr) inTSjs.t.LcÂ¹qcrÂº2
LjÂ¹qj
kÂº; and
For every pre/f_ix Ï€ca=qc
1::qcrof a /f_inite or in/f_inite path Ï€c
b=
qc
1::qcr::inTSc, exist unique corresponding /f_inite paths Ï€j
aand
Ï€j
binTSjs.t.Ï€j
ais a pre/f_ix of Ï€j
b.
P/r.sc/o.sc/o.sc/f.sc. (sketch) By de/f_inition of the JVTS (as a partition of the
CS) and by the correctness of the existing algorithm of the Rabin
game (for cycles avoiding justice guarantees). 
Example 4.4. In our example (Sect. 2), the in/f_inite path Ï€c=
s2;s4;s8;s9;s8;s9; : : :in the concrete CS has a single /f_inite corre-
sponding path ending in a cycle-state in the JVTS Ï€j=q1;q3.
/T_he /f_inite path Ï€c=s2;s4;s8;s9;s8;s10in the concrete CS has a
corresponding /f_inite path in the JVTS Ï€j=q1;q3;q4.Algorithm 1 Computing the JVTS
1:if deadendIni(ini) then
2: attr FromState /afii10069.italetDeadendIniÂ¹iniÂº
3: j/v.altts:addÂ¹attr FromStateÂº
4: returnhj/v.altts;en/v.altChoicesi
5:end if
6:RT S compRankingTS
7:forstate in RTS (reverse z-rank order) do
8:hattr FromCands ;en/v.altChoicesi compAttrFromCands
9: X /f_ilterXÂ¹XÂ»Z RankÂ¹stateÂºÂ¼Âº
10:hpaths ;en/v.altChoicesi compPaths
11: c/y.altcleState compCycleState
12: attrT oState compAttrToState
13: attr FromState compAttrFromState
14: j/v.altts:addÂ¹c/y.altcleState ;attrT oState ;attr FromStateÂº
15:end for
16:returnhj/v.altts;en/v.altChoicesi
/T_he following theorem states lack of redundant states and tran-
sitions in the JVTS.
T/h.sc/e.sc/o.sc/r.sc/e.sc/m.sc 4.5 (JVTS S/t.sc/a.sc/t.sc/e.sc /a.sc/n.sc/d.sc T/r.sc/a.sc/n.sc/s.sc/i.sc/t.sc/i.sc/o.sc/n.sc S/o.sc/u.sc/n.sc/d.sc/n.sc/e.sc/s.sc/s.sc). Given
a concrete CS LTS TScof a JVTS TSj, every state qj2Qjand every
transition tj2Tjappears on at least one path in TSjcorresponding
to a concrete path in TSc.
Example 4.6. In our example, the states q3andq4and the transi-
tion between them in the JVTS appear in the path Ï€j=q1;q3;q4;
which corresponds to the concrete CS path Ï€c=s2;s4;s8;s9;s8;s10.
4.2 Computing the JVTS
A naive method to compute the JVTS could have been to /f_irst
extract a CS using the methods described in [ 10] and then compute
the JVTS from the CS. However, this method would require the
enumeration of all states in the CS and is therefore ineï¬ƒcient. Our
algorithm, presented below, is purely symbolic, and thus avoids
the costly enumeration. /T_he algorithm uses an eï¬ƒcient symbolic
representation and manipulation of sets of concrete states. We
consider this to be an important part of our contribution.
Alg. 1 presents our symbolic algorithm for computing the JVTS.
Its input is the set of initial states iniand the intermediate values
collected during the Rabin game (Sect. 3.2) - the Z array ( Z) and
the three-dimensional X array ( X). /T_he output of the algorithm is a
JVTS and a set envChoices , which contains all possible transitions
between states, deterministic for the environment inputs.
We start by checking if the set of initial states inicontains
a dead-end state for the system (i.e., the environment can force
the system to violate a safety guarantee). If such a state exists, it
constitutes the CS. It is added to the JVTS (Alg. 1, line 3) and the
algorithm ends. Else, we compute the Ranking TS (Alg. 1 line 6), a
TS representation of Zcells reachable from the initial set of states
(Sect. 4.2.1). /T_he algorithm then traverses the Ranking TS states in
reverse Z-Rank order. Each Ranking TS state is split into at most 3
JVTS states, a cycle-state and 2 a/t_tractor-states.
In line 8 of Alg. 1, a set of concrete state-candidates to be in
one of the a/t_tractor-states - the a/t_tractor-from-cycle state - are
computed, with the relevant environment choices (Sect. 4.2.2);
In line 9 of Alg. 1, the a/t_tractor-from-cycle state candidates are
removed from the array X;
In line 10 of Alg. 1, a set of paths along the cells (with the rele-
vant environment choices) in Xare computed. Each such pathESEC/FSEâ€™17, September 4â€“8, 2017, Paderborn, Germany Aviv Kuvent, Shahar Maoz, Jan Oliver Ringert
represents a series of steps ending in a cycle which satis/f_ies all
environment assumptions while violating a system guarantee
(Sect. 4.2.3);
In lines 11 and 12 of Alg. 1, the set of concrete states to be
contained in the cycle-state and in the a/t_tractor-to-cycle state
are extracted from the computed paths (Sect. 4.2.4 and Sect. 4.2.5);
In line 13 of Alg. 1, the set of concrete states to be contained in
the a/t_tractor-from-cycle state are computed using the previously
computed a/t_tractor-from-cycle state candidates, the a/t_tractor-to-
cycle state and cycle state (Sect. 4.2.6).
Finally, the algorithm adds the computed states to the JVTS.
As it follows the general steps of the concrete CS extraction
described in [ 10], and relies on the intermediate values of the Rabin
game, the result of the algorithm is a valid JVTS, symbolically
representing a concrete CS.
T/h.sc/e.sc/o.sc/r.sc/e.sc/m.sc 4.7. Algorithm 1 outputs a valid JVTS as de/f_ined in
Def. 4.1, which is minimal in the number of cycle-states.
4.2.1 Ranking TS. /T_he Ranking TS is an acyclic TS which groups
concrete states according to their Z-Rank. Concrete states of Z-
Rank iare part of the Ranking TS only if they are reachable from
initial states inithrough other concrete states of Z-Ranks ji.
/T_he intermediate Ranking TS is non-deterministic, as opposed to
the more re/f_ined JVTS we later compute from it.
De/f_inition 4.8 (Ranking TS). Given a set of concrete initial states
iniand an array Zof disjoint sets of concrete states, the Ranking
TShQ;T;Iiis an acyclic TS where:
Q22X[Yis the set of states: 8q2Q;910i<jZj:q
ZRankSÂ¹iÂºs.t. all concrete states in qare reachable from inivia
states of higher Z-Rank:
8s2q;9Ï€=s1::sk:s12ini^sk=s^
81<jk:ÏÂ¹sj 1;sjÂº^ZRankÂ¹sj 1ÂºZRankÂ¹sjÂº;
Transition TÂ¹q1;q2Âºexists for q1,q2iï¬€9s12q1;s22q2:
ÏÂ¹s1;s2Âº; and
IQinitial states: q2Iiï¬€q\ini,;.
/T_he symbolic removal of duplicate concrete states from Z(keep-
ing their Z-Rank copy only), ensures that we advance to the lowest
Z-Rank for the correctness of the algorithm, as explained in [10].
4.2.2 computeA/t_trFromCands. A/f_ter computation of the Rank-
ing TS, we compute the sets of concrete states which are the candi-
dates to be contained in the a/t_tractor-from-cycle state. /T_his com-
putation is done for every state rankState of the previously com-
puted Ranking TS hQ;T;Ii. We return the set of candidate states
(attrFromCands ) and environment choices collected between the
candidate states ( envChoices ). /T_he computation of attrFromCands
is the standard a/t_tractor computation, done to the set of concrete
states contained in all Ranking TS states of lower Z-Rank value:
lower =fsj9q2Q:ZRankÂ¹rankStateÂº>ZRankÂ¹qÂº^s2qg.
In addition, we store the environment choices taken at each step
of the /f_ixed-point computation of the a/t_tractor in envChoices . /T_he
envChoices stored here are used in Sect. 4.2.6 to compute the valid
reachable (per environment choices taken) set of concrete states
contained in the a/t_tractor-from-cycle JVTS state.4.2.3 compPaths. We now describe the symbolic computation
of paths along the cells in XÂ»ZrÂ¼array of arrays, where Zr=
ZRankÂ¹rankStateÂº. Each such path will represent a series of steps
ending in a cycle which satis/f_ies all of the environment assumptions
while violating a system guarantee. /T_he /f_irst step of the computa-
tion is done in the /f_iltering of XÂ»ZrÂ¼, performed in Alg. 1, line 9. /T_he
/f_iltered X(filterX ) is constructed thus: 8i;j:s2filterXÂ»ZrÂ¼Â»iÂ¼Â»jÂ¼
iï¬€: (1) s2XÂ»ZrÂ¼Â»iÂ¼Â»jÂ¼, i.e., scomputed by Rabin game, and (2)
80k<j:s<XÂ»ZrÂ¼Â»iÂ¼Â»kÂ¼, i.e., sclosest to satisfying /J.alte
i, and
(3)s<attrFromCands , i.e., paths through send in a cycle.
A/f_ter removal of duplicate states in step 2, we can perform an
algorithm similar to the one described for concrete CS extraction
in [10] in order to compute the paths. /T_he algorithm in [ 10] enumer-
ates the concrete states beginning with the initial state. For each
concrete state reached, the original algorithm locates to which Zcell
it belongs (its Z-Rank Zr) and to which XÂ»ZrÂ¼Â»jÂ¼cell it belongs. It
then de/f_ines an environment choice for this concrete state based on
the following order of priorities: (1) If there exists an environment
choice for which all successors of this concrete state are in a Zcell
of lower Z-Rank than the cell of the current concrete state, this
environment choice is taken; (2) Else, the environment choice taken
has successors in a cell closest to index 0 in the current XÂ»ZrÂ¼Â»jÂ¼
array (or in the next array XÂ»ZrÂ¼Â»Â¹j+1Âºmod nÂ¼if the current con-
crete state is already in index 0). /T_he concrete successor states are
then added to the concrete CS, and are iterated over in turn (if they
were not already visited previously as a result of a concrete cycle).
Our symbolic algorithm follows a similar /f_low, except that in-
stead of checking for successors of concrete states at each step (and
iterating over them), it performs a symbolic step between sets of
states, composed of two parts:
In the /f_irst part, a valid environment choice which leads to the
target set of states dstis selected for the source set of states src
for which an environment choice was not yet taken:
newSuccsTransÂ¹src;dst;others ;envChoicesÂº=
fhs;xijs2src;x2X^ÏeÂ¹s;xÂº^hs;xi<envChoices^
Â¹8/y.alt2Y :ÏsÂ¹s;hx;/y.altiÂº!h x;/y.alti2Â¹dst[othersÂº^
Â¹9/y.alt2Y :ÏsÂ¹s;hx;/y.altiÂº^h x;/y.alti2dstÂºg
others are additional destination states which can be reached via
a diï¬€erent system choice for the taken environment choice. /T_he
srcanddstsets of states are subsets of states in some XÂ»ZrÂ¼Â»kÂ¼
cells determined according to the /f_low in [10].
In the second part we take all relevant successors in dstaccord-
ing to the environment choices taken for states in src:
succsÂ¹src;dst;envChoicesÂº=
fs2dstj9s02src;x2X:hs0;xi2envChoices^
9/y.alt2Y :hx;/y.alti=sg:
/T_he successors which are the result of succs are then used as the
srcstates in the next step.
Despite the similar /f_low, there are two key diï¬€erences between
our computation and the one described in [ 10]. First, due to the
removal of states that are in attrFromCands , done in step 3, the
resulting CS represented by the JVTS will a/t_tempt to force to states
with the lowest Z-Rank possible in one or more steps. In [ 10],
the choice of moving to a state in a lower Z-Rank is only doneJVTS ESEC/FSEâ€™17, September 4â€“8, 2017, Paderborn, Germany
by looking one step ahead. Second, during computation of a path,
when performing steps over the filterX , we consider sets of states
and not a single concrete state.
4.2.4 compCycleState. /T_he concrete states contained in a JVTS
cycle-state are computed using the previously calculated paths.
/T_here are two types of concrete states inside a cycle-state: (1) states
which are part of a concrete cycle in a single path, and (2) states
which are between concrete cycles in diï¬€erent paths computed
from the same Ranking TS state (see Def. 4.1).
We identify states on cycles by iterating over the computed paths,
and for each path computing the set of all concrete states which are
a part of the cycle. We denote these states on cycles by S. We identify
states in-between cycles Busing a least /f_ixed-point computation of
successors of Swithin paths: B=ÂµC:S[succsÂ¹C;A;envChoicesÂº,
where Aare all the states in the paths for this Ranking TS state.
4.2.5 compA/t_tractorToState. /T_he concrete states contained in
the a/t_tractor-to-cycle state are computed using the previously com-
puted cycle-state and the paths. /T_he a/t_tractor-to-cycle state contains
all concrete states in paths that are not in the calculated cycle-state.
4.2.6 compA/t_tractorFromState. /T_he set of concrete states con-
tained in the a/t_tractor-from-cycle state are computed from the
attrFromCands using the Ranking TS, the previously computed
attrTo andcycle states, the concrete states contained in the pre-
viously computed JVTS states Pand the envChoices . /T_he compu-
tation begins by /f_inding states StartattrFromCands reachable
in a single step from P:
Start =fs02attrFromCandsj
9s2Â¹attrTo[cycle[PÂº;x2X;/y.alt2Y :
hs;xi2envChoices^ÏeÂ¹s;xÂº^ÏsÂ¹s;hx;/y.altiÂº^s0=hx;/y.altig:
We then compute attrFrom as the least /f_ixed-point of states reach-
able from start :
attrFrom =ÂµA:Start[fs02attrFromCandsj
9s2A;x2X;/y.alt2Y :hs;xi2envChoices^
ÏeÂ¹s;xÂº^ÏsÂ¹s;hx;/y.altiÂº^s0=hx;/y.altig:
4.3 Computing JVTS annotations
On top of the JVTS computation, for its presentation to the engineer,
we annotate its states with the following information:
State type (a/t_tractor-state or cycle-state);
For each cycle-state â€“ the speci/f_ic violated justice. From the con-
struction of the Zarray in the Rabin game, the Z-Rank identi/f_ies
a system justice guarantee being violated by the states in the rel-
evant Z-array cell, and therefore by the states in the cycle-state
constructed from this Z-array cell; and
Invariants - we annotate each JVTS state with invariants of the
form <var> = <value> . Computation of the invariants is per-
formed by iterating over the values of each variable and checking
if a restriction to the value constitutes an invariant. In the worst-
case, the computation of all invariants requires OÂ¹jX[YjÂº many
eï¬ƒcient symbolic operations. As a performance improvement,
we only check for variables that appear in the symbolic repre-
sentation as only their values might constitute an invariant.Note that the annotations present aggregated information. /T_hey
are not the labels from Def. 4.1.
5 CONCRETIZATION AND INTERACTIVE
SYMBOLIC AND CONCRETE PLAY
To further assist the engineer in the exploration of the CS, we
implemented an interactive play over the JVTS. /T_he engineer can
select a JVTS state (cycle or a/t_tractor) and can either (1) concretize
the state, or (2) perform interactive play starting from concrete
states in the JVTS state.
Concretizing a JVTS State. Concretizing a JVTS state results in
generating all concrete states contained in it, allowing the engineer
to view the concrete cycle violating at least one justice guarantee,
or an a/t_tractor path towards the next cycle. Generation of concrete
states entails enumerating all concrete states contained in the JVTS
state. /T_herefore, this can be (in the worst-case) as expensive as
computation of the concrete CS.
Example 5.1. In our running example, Fig. 3 shows the result
of concretizing the a/t_tractor state q1. In the /f_igure we see the 5
concrete states it contains, and the transitions between them.
/T_he computation of concrete states contained in a JVTS state
is immediate from the JVTS structure returned by Alg. 1 and the
envChoices accumulated in memory. Each JVTS state consists of
a symbolic representation of the set of concrete states it contains,
and we simply extract these concrete states by enumerating all
assignments to environment and system variables representing a
state in this set. We build the transitions between the states using
theenvChoices .
Interactive Symbolic and Concrete Play. /T_he engineer can
perform an interactive play starting from a JVTS state. /T_he play
consists of 4 steps: (1) /T_he engineer chooses as a starting point a
concrete state contained in a JVTS state; (2) /T_he concrete state and
all its possible concrete successors, in the same JVTS state and in
other JVTS states, are displayed to the engineer; (3) /T_he engineer
chooses a concrete successor; (4) We return to step (2).
Example 5.2. In our running example, the engineer chooses to
perform interactive play starting from the a/t_tractor (symbolic state
q1) in Fig. 2. She selects assignments to environment and system
variables in order to pick a concrete state of her interest within JVTS
state q1. She chooses to give the value of true to all variables and
is shown only the concrete state s7and its immediate successors s4
ands5(all of which are in the a/t_tractor q1, as seen in Fig. 3). She then
continues the play from state s4, which will display its immediate
successors s8;s9;s10, and s11(as they appear in the concrete graph
in Fig. 1). Note that these successors are in a diï¬€erent JVTS state
q3; this is indicated to the engineer during the interactive play.
Using the interactive play, the engineer can traverse the concrete
states of the CS, on demand, while seeing the context provided by
the JVTS states in which they are contained, e.g., the system justice
guarantee which the CS a/t_tempts to violate or invariants shared by
this concrete state and other concrete states in the JVTS state.
Computation of an interactive play is done in the same way a
concretization of a JVTS state is performed, except that in each
step, the only concrete states extracted are the ones chosen by theESEC/FSEâ€™17, September 4â€“8, 2017, Paderborn, Germany Aviv Kuvent, Shahar Maoz, Jan Oliver Ringert
attractor 
cycle 
!DockingResponse cycle 
!Ready 
attractor attractor ready = false 
docking = false 
dockRequest = false 
AUX_Once = true 
AUX_Must_Respond = false 
dockRequest = true 
AUX_Once = true 
AUX_Must_Respond = false 
attractor ready = true 
docking = true 
dockRequest = true 
AUX_Once = true 
AUX_Must_Respond = false q1a
q1cq1bq2
q3 q4
Figure 4: JVTS for docking mechanism speci/f_ication with
unmerged attractors. Attractors q1a;q1b;and q1ccan be
merged to attractor q1, as is shown in Fig. 2. /T_he invariants
ofq2,q3, and q4are the same as shown in Fig. 2.
engineer and its immediate successors. /T_his allows instantaneous,
on-demand computation of concrete states and is thus very eï¬ƒcient.
A set of screenshots demonstrating interactive symbolic and con-
crete play in our Eclipse-based environment is available from [ 25].
6 MERGING OF JVTS ATTRACTOR STATES
Since the JVTS computation is based on the intermediate values of
the Rabin game, as shown in Sect. 4.2, it may contain sequences
of a/t_tractor states that were computed from Zcells of diï¬€erent
Z-Ranks (Def. 3.4). In our experience, these sequences may be
relatively long and do not always provide valuable information
to the engineer. /T_hus, our default implementation merges such
sequences of a/t_tractor states into one.
Still, in some cases the engineer may be interested in a more
re/f_ined version of the JVTS, where such a/t_tractors are not merged.
We therefore provide the engineer with a means to unmerge and
merge such sequences of a/t_tractor states on demand.
Example 6.1. Using our running example in Sect. 2, running the
JVTS algorithm without merging of a/t_tractor states results in the
JVTS shown in Fig. 4, where state q1a;q1b;andq1care unmerged.
/T_he version of this JVTS shown earlier in Fig. 2 has these a/t_tractors
merged to a single a/t_tractor, q1.
As can be seen in our example, without merging, the resulting
JVTS is not the minimal JVTS which is also acyclic. /T_he algorithm
which merges a/t_tractors traverses the JVTS and merges neighboring
a/t_tractors that can be merged without creating a cycle. /T_his merging
minimizes the number of a/t_tractor states of the JVTS. /T_hus, the
resulting JVTS, a/f_ter merging, is minimal not only in the number of
cycle states (see Sect. 4.2) but also in the number of a/t_tractor states.
7 EVALUATION
We have implemented Alg. 1, the interactive play discussed in
Sect. 5, and the merging discussed in Sect. 6, in our synthesis en-
vironment, based on CUDD [ 22] as a BDD library, and integrated
into Eclipse. Our implementation includes also the computation
of concrete CS extraction based on [ 10,18]. It is important to noteTable 1: /T_he 14 unrealizable speci/f_ications of Lego robots created
by our students in the workshop class and used for the evaluation in
this paper. For each speci/f_ication we report the number of justice
assumptions and guarantees ( nandmresp.), number of safety as-
sumptions and guarantees ( /afii10069.italeand/afii10069.itals), number of input and output
variables (jXjandjYj), and number of auxiliary variables ( jAU Xj)
added due to the use of patterns and past LTL formulas.
Name n mj/afii10069.italej j/afii10069.italsj jXj jYj j AU Xj
Gyro rev710 4 2 1 4 3 6 3
Gyro var2 rev710 3 2 1 4 3 5 2
Humanoid rev458 0 0 0 11 3 10 0
Humanoid rev503 0 1 1 16 6 13 2
Humanoid rev531 2 1 0 15 1 14 2
Humanoid rev741 2 1 3 19 4 19 5
Humanoid rev742 0 1 2 24 1 16 2
PCar rev769 2 1 2 25 5 13 2
PCar rev870 2 1 4 29 5 16 5
PCar rev888 1 1 2 19 3 11 2
PCar un2 1 1 2 19 3 11 2
ColorSort rev790 4 2 2 25 11 17 4
ColorSort rev791 5 2 2 31 13 22 6
SelfParkingCar rev974 3 3 0 42 4 28 5
that the concrete CS computed might not be the one represented by
the JVTS, i.e., the concrete CS computed by the original algorithm
might have a slightly diï¬€erent size than the one represented by
the JVTS. Both algorithms work on the same results of the Rabin
game but JVTS computation might prefer leaving cycles early as
mentioned in Sect. 4.2.3.
We consider the following research questions:
R1Is the JVTS computation eï¬ƒcient and how does it compare to
concrete CS construction?
R2Is the JVTS smaller than the concrete CS?
7.1 Speci/f_ications Used
Only few GR(1) speci/f_ications are available and these were usually
created by authors of synthesis algorithms or extensions thereof.
For the purpose of evaluation, we have used unrealizable speci/f_i-
cations created by 3rd year CS students in a workshop project class
that we have taught. Over the course of a semester, the students
have created speci/f_ications for the following systems, which they
actually built and run: ColorSort â€“ a robot sorting Lego pieces by
color; Humanoid â€“ a mobile robot of humanoid shape; PCar â€“ a self
parking car; Gyro â€“ a robot with self-balancing capabilities; and
SelfParkingCar - a second version of a self parking car.
/T_he speci/f_ications were notcreated speci/f_ically for the evaluation
in our paper but as part of the ordinary work of the students in the
workshop class. During their work, the students have commi/t_ted
many versions of their speci/f_ications to the repository. Most of
these were realizable, but some unrealizable. We use here all of the
unrealizable speci/f_ications from the repository. In total, we have
collected 14 speci/f_ications. We consider these GR(1) speci/f_ications
to be the most realistic and relevant examples one could /f_ind for
the purpose of evaluating our work.
Tbl. 1 provides basic information regarding the size of the 14 spec-
i/f_ications: number of justice and safety assumptions and guarantees,JVTS ESEC/FSEâ€™17, September 4â€“8, 2017, Paderborn, Germany
number of input and output variables, and number of auxiliary vari-
ables. As can be seen, the number of justice guarantees is small,
ranging from 0 to 3. /T_he total number of safety guarantees ranges
from 5 to 42. /T_he state space (input, output, and auxiliary variables)
ranges from 210to 241.
In addition to the speci/f_ications created by the students, we
considered the ARM AMBA AHB Arbiter, which is the most popular
GR(1) example in literature, used, e.g., in [ 1,3,4,10]. We looked at
4 diï¬€erent sizes of AMBA (1 to 4 masters), each in the 3 variants of
unrealizability described in [ 4] (with a justice assumption removed,
with a justice guarantee added, and with a safety guarantee added).
We have thus run our experiments on 12 AMBA speci/f_ications.
All speci/f_ications used in our evaluation, the raw results, and
the code to reproduce our experiments are available from [25].
7.2 Validation
We have systematically validated the correctness of our implemen-
tation by model-checking the symbolic JVTS constructed for the
speci/f_ications mentioned in this paper and for many more. We
/f_irst transformed the JVTS into a symbolic controller. /T_he initial
states of this symbolic controller are the union of the initial states
in the JVTS states. /T_he transitions of this symbolic controller are
the transitions accumulated in envChoices (see Sect. 4.2). We then
used a model-checker to check whether this symbolic controller
satis/f_ies the speci/f_ication Ï†sr(as described in Sect. 3.1).
In addition, we validated the completeness of JVTS with regard
to system choices by ensuring that, given a concrete state and an
environment choice represented in the JVTS, every system choice
either violates a safety guarantee or leads to a successor which is
also represented in the JVTS.
Our validation helped us /f_ind a number of bugs in our earlier
implementation and to increase our con/f_idence in the correctness
of its latest version.
7.3 Results
R1: Computation Time. We run all experiments on an ordinary
PC, Intel i7 CPU 3.4GHz, 16GB RAM with Windows 7 64-bit OS,
Java 8 64Bit, and CUDD 3 compiled for 64Bit, using only a single
core of the CPU. We measured the running time of concrete CS
extraction, and of symbolic JVTS computation with and without
merging of a/t_tractors, for the 14 speci/f_ications shown in Tbl. 1, as
well as for 12 AMBA AHB speci/f_ications from [ 4]. Times we report
are median values of 12 runs per speci/f_ication measured by Java
in milliseconds. Even though the JVTS computation algorithm is
deterministic, we performed 12 runs since JVM garbage collection
and BDD dynamic-reordering add variance to running times.
As it is well known that BDD-based implementationsâ€™ perfor-
mance is sensitive to variable order, it is important to note that in
all our experiments we used CUDDâ€™s automatic variable reordering
for the Rabin game, and no variable reordering for strategy extrac-
tion. Our experience shows that this con/f_iguration provides the
fastest results for both the concrete CS extraction and the JVTS
computation, across all the speci/f_ications we examined.
Tbl. 2 (le/f_t) displays the running time quartiles for concrete
CS extraction for the 14 speci/f_ications from Tbl. 1 and ratios of
JVTS computation times. We see that the JVTS computation isTable 2: Running time (in ms) quartiles of the concrete CS extrac-
tion and ratios of JVTS computation (including annotations) for the
14 speci/f_ications from Tbl. 1 and the 12 AMBA speci/f_ications. T/O
represents running time of over 10 minutes.
14 Lego Robots 12 AMBA AHB
/Q_uartile ConcreteConcrete
JVTSratio ConcreteConcrete
JVTSratio
MIN 17 1 7 1
Q1 93 3 11 2
Q2 8426 190 129 4
Q3 38794 1658 1292 6
MAX T/O1 26787 23
Table 3: Size quartiles and ratios for the 14 speci/f_ications of Tbl. 1
(upper part), and the 12 AMBA speci/f_ications (lower part), compar-
ing the concrete CS numbers of states Qcand transitions Tcand
the ratios of JVTS states and transitions with merged attractors (un-
merged attractors in parentheses). We use 1as the size of empty sets
of states and transitions to avoid division by 0.
/Q_uartilesjQcj j TcjjQcj
jQjjratiojTcj
jTjjratio
MIN 8 20 3 (3) 7 (7)
Q1 167 204 92 (65) 83 (73)
Q2 1308 1884 878 (468) 1884 (740)
Q3 3309 608861 1377 (1104) 124270 (101658)
MAX 2124000 66816000 708000 (708000) 22272000 (22272000)
MIN 1 0 1 (1) 1 (1)
Q1 1 0 1 (1) 1 (1)
Q2 25 46 10 (8) 20 (15)
Q3 85 196 21 (14) 34 (24)
MAX 1921 7292 274 (160) 521 (270)
signi/f_icantly faster for these 14 speci/f_ications. In fact, for half of the
speci/f_ications, the JVTS running time is more than 190 times faster
than the concrete CS extraction, and for 25% the running time is
more than 1658 times faster.
Tbl. 2 (right) displays the running time quartiles and ratios for
the 12 AMBA speci/f_ications. Here as well we see the that JVTS
computation is faster than the concrete CS extraction. For half of
the speci/f_ications, the running time of the JVTS is faster than the
concrete CS by a factor of 4, and for 25% of the speci/f_ications, the
JVTS computation is faster by a factor of 6.
In all the speci/f_ications evaluated, a/t_tractors merging added only
very small overhead (at most 16 ms) to the JVTS computation time.
To answer R1: Computation time of the JVTS is faster than ex-
traction of a concrete CS, for both the Lego robot (more than 190
times faster for half of the speci/f_ications) and the AMBA speci/f_i-
cations (more than 4 times faster for half of the speci/f_ications).
R2: Size. We have measured the number of states and transitions
for the CSs of the 14 speci/f_ications listed in Tbl. 1, as well as for
the 12 AMBA AHB speci/f_ications, for concrete CSs and for JVTSs
with/without merging of a/t_tractors.
Tbl. 3 (upper part) shows the quartiles of the number of states
Qcand transitions Tcof the concrete CS and the ratios of the JVTS
sizes with merged a/t_tractors and unmerged a/t_tractors, for the 14
speci/f_ications listed in Tbl. 1. For all of these speci/f_ications, theESEC/FSEâ€™17, September 4â€“8, 2017, Paderborn, Germany Aviv Kuvent, Shahar Maoz, Jan Oliver Ringert
number of states and transitions in the JVTS is signi/f_icantly smaller
than the number of states and transitions in the concrete CS. In
more than half of the speci/f_ications, the number of states in the
JVTS is smaller by a factor of at least 878 than in the concrete
CS, and in about 25% the factor is more than 1377. For half of the
speci/f_ications, the number of transitions in the JVTS is smaller by
a factor of 1884 than the number of transitions in the concrete, and
for 25% of the speci/f_ications, the number of transitions is smaller
by a factor of 124270. Merging of a/t_tractors further reduces the
number of states and transitions.
Tbl. 3 (lower part) shows the quartiles of the number of states
and transitions of the concrete CS and the ratios of the JVTS sizes
(with/without merging of a/t_tractors), for the 12 AMBA AHB speci-
/f_ications listed in Sect. 7.1. /T_he results show that in all the AMBA
speci/f_ications, the size of the JVTS is smaller than or equal to the
size of the concrete CS. Half of the JVTSs of these speci/f_ications are
smaller than the concrete CSs by a factor of 10 or more. Merging
of a/t_tractors further decreases the size of the JVTS in some cases.
To answer R2: /T_he size of the JVTS, states and transitions, is much
smaller than the size of the concrete CS in most the examined
speci/f_ications.
7.4 /T_hreats to Validity
We brie/f_ly discuss threats to the validity of our results.
Internal. /T_he JVTS computation is not trivial and our implemen-
tation may have bugs. To mitigate this, we performed a thorough
validation (Sect. 7.2) using all speci/f_ications available to us.
External. First, we did not perform a user-study, with engineers,
to examine how the JVTS achieves its ultimate goal of aiding them
in debugging unrealizable speci/f_ications. However, the orders of
magnitude smaller size of the JVTS and its simplicity (in comparison
with the concrete CS, as seen in Sect. 7), as well as the annotations
added to the JVTS states (directly referencing elements in the spec-
i/f_ication), all hint that the JVTS will indeed be easier for engineers
to explore and use. Second, we have based most of our evaluation
on speci/f_ications created by 3rd year CS students with no prior
experience in writing LTL speci/f_ications. Due to the lack of other
real-world unrealizable speci/f_ication examples, the speci/f_ications
chosen were all unrealizable speci/f_ications available to us.
8 RELATED WORK
GR(1) synthesis was introduced in [ 19], and has since been used
and investigated in many works. To list a few, Dâ€™Ippolito et al. [ 5,6]
used GR(1) to deal with fallible domains and non-anomalous event-
based behavior models; Kress-Gazit et al. [ 11] used GR(1) in ro-
botics; Maoz and Ringert showed GR(1) synthesis for speci/f_ication
pa/t_terns [ 13]. Several tools support GR(1) synthesis, including
RATSY [ 2], TuLiP [ 24], and Slugs [ 8]. We give an overview of exist-
ing approaches to dealing with unrealizable GR(1) speci/f_ications.
Counter-Strategies and Core. Cima/t_ti et al. [ 4] suggest to use
a CS to provide an explanation for unrealizability, and use a core
to explain a single speci/f_ic unrealizability cause. Konighofer et
al. [10] compute a core not only for system guarantees but alsofor output variables. Maoz and Saâ€™ar [ 17] present CSs for scenario-
based speci/f_ication. All works use concrete CSs. Our work is the
/f_irst to suggest a symbolic CS. It can be composed on top of a core
calculation.
Interactive Play. Some previous works suggest the use of an
interactive play [ 10,17,21], where the engineer explores the CS by
playing the role of the system against the winning environment.
Again, all these approaches to interactive play rely on a concrete
CS. No previous work provides an interactive play which is based
on a symbolic representation of the CS, as we have introduced and
implemented here.
Repair using Strengthened Assumptions. Finally, Alur et al. [ 1]
proposed a method for semi-automatic strengthening of assump-
tions. It analyses the concrete CS and suggests candidate assump-
tions that may solve the cause of unrealizability. /T_he use of our
symbolic CS representation in the context of repair is a very inter-
esting future work direction.
9 CONCLUSION
We presented the Justice Violations Transition System (JVTS), a
novel symbolic representation of CSs for GR(1). /T_he JVTS is much
smaller and simpler than its corresponding concrete CS and is
annotated with invariants that explain how the CS forces the system
to violate the speci/f_ication. We compute the JVTS symbolically,
and thus eï¬ƒciently, without expensive enumeration of concrete
states. Finally, we provide the JVTS with an on-demand interactive
concrete and symbolic play.
We implemented our work, validated its correctness, and evalu-
ated it on 14 unrealizable speci/f_ications of autonomous Lego robots
and on benchmarks from the literature. /T_he evaluation shows not
only that the JVTS is in most cases much smaller than a concrete
CS, but also that its computation is signi/f_icantly faster.
We consider the following future work directions. First, one
may propose an analogous symbolic representation of strategies
for the realizable case, to allow engineers to eï¬ƒciently explore a
synthesized controller. Second, as we mentioned in Sect. 8, some
works investigate the use of concrete CSs to generate candidate
assumptions that will repair the unrealizable speci/f_ication. Based
on the JVTS, it may be possible to develop a symbolic and hence
much more eï¬ƒcient repair mechanism.
/T_he work is part of a larger project2on bridging the gap between
the theory and algorithms of reactive synthesis on the one hand
and so/f_tware engineering practice on the other. As part of this
project we are building engineer-friendly tools for writing and
understanding temporal speci/f_ications for reactive synthesis (see,
e.g., [13, 14]).
ACKNOWLEDGEMENTS
We thank O/f_ir Fisher and Yoni Wolbe for their help in the imple-
mentation. /T_his project has received funding from the European
Research Council (ERC) under the European Unionâ€™s Horizon 2020
research and innovation programme (grant agreement No 638049,
SYNTECH).
2SYNTECH: h/t_tp://smlab.cs.tau.ac.il/syntech/JVTS ESEC/FSEâ€™17, September 4â€“8, 2017, Paderborn, Germany
REFERENCES
[1]R. Alur, S. Moarref, and U. Topcu. Counter-strategy guided re/f_inement of GR(1)
temporal logic speci/f_ications. In FMCAD , pages 26â€“33. IEEE, 2013.
[2]R. Bloem, A. Cima/t_ti, K. Greimel, G. Hoï¬€erek, R. K Â¨onighofer, M. Roveri, V. Schup-
pan, and R. Seeber. RATSY - A new requirements analysis tool with synthesis.
InCAV, volume 6174 of LNCS , pages 425â€“429. Springer, 2010.
[3]R. Bloem, B. Jobstmann, N. Piterman, A. Pnueli, and Y. Saâ€™ar. Synthesis of
Reactive(1) Designs. J. Comput. Syst. Sci. , 78(3):911â€“938, 2012.
[4]A. Cima/t_ti, M. Roveri, V. Schuppan, and A. Tchaltsev. Diagnostic information
for realizability. In VMCAI , volume 4905 of LNCS , pages 52â€“67. Springer, 2008.
[5]N. Dâ€™Ippolito, V. A. Braberman, N. Piterman, and S. Uchitel. Synthesis of live
behaviour models for fallible domains. In ICSE, pages 211â€“220, 2011.
[6]N. Dâ€™Ippolito, V. A. Braberman, N. Piterman, and S. Uchitel. Synthesizing
nonanomalous event-based controllers for liveness goals. ACM Trans. So/f_tw. Eng.
Methodol. , 22(1):9, 2013.
[7]M. B. Dwyer, G. S. Avrunin, and J. C. Corbe/t_t. Pa/t_terns in property speci/f_ications
for /f_inite-state veri/f_ication. In ICSE, pages 411â€“420. ACM, 1999.
[8]R. Ehlers and V. Raman. Slugs: Extensible GR(1) synthesis. In CAV, volume 9780
ofLNCS , pages 333â€“339. Springer, 2016.
[9]I. Filippidis, S. Dathathri, S. C. Livingston, N. Ozay, and R. M. Murray. Control
design for hybrid systems with tulip: /T_he temporal logic planning toolbox. In
2016 IEEE Conference on Control Applications, CCA 2016, Buenos Aires, Argentina,
September 19-22, 2016 , pages 1030â€“1041. IEEE, 2016.
[10] R. KÂ¨onighofer, G. Hoï¬€erek, and R. Bloem. Debugging formal speci/f_ications: a
practical approach using model-based diagnosis and counterstrategies. STTT ,
15(5-6):563â€“583, 2013.
[11] H. Kress-Gazit, G. E. Fainekos, and G. J. Pappas. Temporal-logic-based reactive
mission and motion planning. IEEE Trans. Robotics , 25(6):1370â€“1381, 2009.
[12] S. Maniatopoulos, P. Schillinger, V. Pong, D. C. Conner, and H. Kress-Gazit.
Reactive high-level behavior synthesis for an atlas humanoid robot. In D. Kragic,
A. Bicchi, and A. D. Luca, editors, 2016 IEEE International Conference on Roboticsand Automation, ICRA 2016, Stockholm, Sweden, May 16-21, 2016 , pages 4192â€“4199.
IEEE, 2016.
[13] S. Maoz and J. O. Ringert. GR(1) synthesis for LTL speci/f_ication pa/t_terns. In
ESEC/FSE , pages 96â€“106. ACM, 2015.
[14] S. Maoz and J. O. Ringert. On well-separation of GR(1) speci/f_ications. In FSE,
pages 362â€“372. ACM, 2016.
[15] S. Maoz and Y. Saâ€™ar. AspectLTL: an aspect language for LTL speci/f_ications. In
AOSD , pages 19â€“30. ACM, 2011.
[16] S. Maoz and Y. Saâ€™ar. Assume-guarantee scenarios: Semantics and synthesis. In
MODELS , volume 7590 of LNCS , pages 335â€“351. Springer, 2012.
[17] S. Maoz and Y. Saâ€™ar. Counter play-out: executing unrealizable scenario-based
speci/f_ications. In ICSE, pages 242â€“251. IEEE / ACM, 2013.
[18] S. Maoz and Y. Saâ€™ar. Two-way traceability and con/f_lict debugging for aspectltl
programs. T. Aspect-Oriented So/f_tware Development , 10:39â€“72, 2013.
[19] N. Piterman, A. Pnueli, and Y. Saâ€™ar. Synthesis of reactive(1) designs. In VMCAI ,
volume 3855 of LNCS , pages 364â€“380. Springer, 2006.
[20] A. Pnueli and R. Rosner. On the Synthesis of a Reactive Module. In POPL , pages
179â€“190. ACM Press, 1989.
[21] V. Raman and H. Kress-Gazit. Explaining impossible high-level robot behaviors.
IEEE Transactions on Robotics , 29(1):94â€“104, 2013.
[22] F. Somenzi. CUDD: BDD package, University of Colorado, Boulder. h/t_tp://vlsi.
colorado.edu/fabio/CUDD/cudd.pdf.
[23] A. Walker and L. Ryzhyk. Predicate abstraction for reactive synthesis. In Formal
Methods in Computer-Aided Design, FMCAD 2014, Lausanne, Switzerland, October
21-24, 2014 , pages 219â€“226. IEEE, 2014.
[24] T. Wongpiromsarn, U. Topcu, N. Ozay, H. Xu, and R. M. Murray. TuLiP: A
So/f_tware Toolbox for Receding Horizon Temporal Logic Planning. In Proceedings
of the 14th International Conference on Hybrid Systems: Computation and Control ,
HSCC â€™11, pages 313â€“314, New York, NY, USA, 2011. ACM.
[25] SYNTECH JVTS website. h/t_tp://smlab.cs.tau.ac.il/syntech/jvts/.