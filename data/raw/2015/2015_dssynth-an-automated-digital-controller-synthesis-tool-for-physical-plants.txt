DSSynth: An Automated Digital Controller
Synthesis Tool for Physical Plants
Alessandro Abate1, Iury Bessa2, Dario Cattaruzza1, Lennon Chaves2, Lucas Cordeiro1,2,
Cristina David1, Pascal Kesseli1, Daniel Kroening1, and Elizabeth Polgreen1
1University of Oxford, Oxford, United Kingdom
2Federal University of Amazonas, Manaus, Brazil
Abstract —We present an automated MATLAB Toolbox, named
DSSynth (Digital-System Synthesizer), to synthesize sound digital
controllers for physical plants that are represented as linear time-
invariant systems with single input and output. In particular,DSSynth synthesizes digital controllers that are sound w.r .t. sta-
bility and safety speciﬁcations. DSSynth considers the complete
range of approximations, including time discretization, quanti-zation effects and ﬁnite-precision arithmetic (and its roundingerrors). We demonstrate the practical value of this toolbox byautomatically synthesizing stable and safe controllers for intricatephysical plant models from the digital control literature. Theresulting toolbox enables the application of program synthesis toreal-world control engineering problems. A demonstration canbe found at https://youtu.be/
hLQslRcee8.
Index T erms—Formal Synthesis; Digital Control Systems;
MATLAB Toolbox; Finite-Word Length; V eriﬁcation
I. I NTRODUCTION
Control theory targets the construction of reliable systems
by providing mathematical guarantees about the stability and
the performance of closed-loop dynamics, where outputs of a
discrete plant G(z)are fed back and compared to a reference
signal towards which a controller C(z)should steer [1]. Fig. 1
depicts a typical closed-loop digital control system.
Reference OutputController
C(z)Plant
G(z)+-
Fig. 1: Typical closed-loop control system
There are various ways to model control systems. Two
common ways to represent the dynamics of such systems
are transfer functions and state-space equations (difference or
differential equations). In this paper, we consider systems with a
single input and a single output (SISO), given either as transferfunctions or state-space linear time-invariant (LTI) models. LTI
models are a common sub-class, and are frequently used incyber-physical systems (e.g., in robotics, smart grids, power
plants and avionics). A discretized plant or a digital controller
is, in general, given as follows when using the transfer function
representation:
H(z)=B(z)
A(z)=b0+b1z−1+...+bMz−M
a0+a1z−1+...+aNz−N, (1)In this representation, z−1is called the backward-shift operator;
A(z)andB(z)are the denominator and numerator polyno-
mials; and NandMare the order of the denominator and
numerator polynomials, respectively.
In state-space form, the behavior of a system is represented
via a state evolution equation x(n+1 ) and an instantaneous
output equation y(n), as follows:
x(n+1 )= Ax(n)+Bu (n)
y(n)= Cx(n)+Du (n),(2)
where A,B,CandDare matrices that fully specify the model.
There is a rich body of literature on automating the synthesis
of controllers for LTI systems [2]–[4]. However, there aremany challenges when digital control is used to implementthe controller, mainly due to effects of ﬁnite-word length
(FWL), which leads to truncation or round-off errors [5],
[6], and time discretization and quantization noise, which are
typically introduced by Analogue-to-Digital (ADC) and Digital-
to-Analogue (DAC) conversion [1].
We have recently proposed a new method to synthesize
digital control systems for LTI systems, which we havenamed DSSynth (Digital-System Synthesizer) [7], [8]. The
algorithm implements Counter-Example Guided InductiveSynthesis (CEGIS) [9]. CEGIS is used to realize a program
synthesis engine that is able to generate sound digital controllers
for highly non-trivial system speciﬁcations with a very high
degree of automation. The program synthesis engine is given
a speciﬁcation and subsequently produces a sequence of can-
didate programs from a template. The candidate programs are
iteratively reﬁned to eventually satisfy the speciﬁcation. Modernsynthesis engines such as the one used here combine automatedtesting, genetic algorithms and SMT-based reasoning [10], [11].
Using the CEGIS-based approach, DSSynth synthesizes stable
digital controllers for a given physical plant represented by
either transfer functions or state-space equations.
There are existing toolboxes for MATLAB that provide
functions and scripts to support the design and implementation
of digital controllers [12]. In particular, there is a MATLAB
Toolbox named DSV eriﬁer [13]–[15], which automatically
detects speciﬁc errors in a given digital system design (e.g.,errors related to stability, limit cycle and overﬂow) usingsymbolic model checking based on Boolean Satisﬁability
(SAT) and Satisﬁability Modulo Theories (SMT) solvers. The
Pessoa [2] toolbox performs synthesis of correct-by-design
978-1-5386-2684-9/17/$31.00 c/circlecopyrt2017 IEEEASE 2017, Urbana-Champaign, IL, USA
T ool Demonstrations919
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:30:50 UTC from IEEE Xplore.  Restrictions apply. digital controllers. Pessoa is based on approximate bisimulation,
which allows control engineers to replace the differential equa-
tions (describing the physical plant) by a ﬁnite-state machine.
However, Pessoa does not take advantage of recent advances in
bit-accurate veriﬁcation of programs to synthesize controllers
w.r.t. FWL effects. MATLAB offers a tool named Control
System Tuner [16] for automatically designing controllers
based on optimization or graphical analysis. However, the
Control System Tuner is unable to consider FWL effects during
controller synthesis. To the best of our knowledge, there is no
MATLAB toolbox able to perform digital controller synthesis
that considers the complete range of approximations, including
time discretization, quantization effects, and ﬁnite-precision
arithmetic and its rounding errors.
The present tool paper addresses this limitation and describes
a MATLAB toolbox for DSSynth. MATLAB is very commonly
used for modeling physical plants. Thus, the integration into
MATLAB enables rapid synthesis of a stable and safe digital
controller for such plants without switching the environment.
Experimental results show that the DSSynth Toolbox is able
to efﬁciently synthesize stable and safe controllers for a
set of intricate benchmarks taken from the literature: themedian runtime for our benchmarks set is
124s, and the
average synthesis time amounts to 35.5s for closed-loop control
systems represented by state-space equations, while for transfer
functions, the average synthesis time amounts to 123.6s.
II. C OUNTEREXAMPLE -GUIDED INDUCTIVE SYNTHESIS
FOR CONTROL SYSTEMS
Our synthesizer iterates between two main phases, an
inductive synthesis phase, SYNTHESISE , and a validation phase,
VERIFY . The two phases interact via a ﬁnite set of test vectors,
which is updated incrementally. Given a stability and safety
speciﬁcation, the inductive synthesis procedure tries to ﬁnd
a candidate solution satisfying the speciﬁcation for the given
set of test inputs. If the synthesis phase succeeds in ﬁnding a
witness, this witness is a candidate solution to the full synthesis
formula. We pass this candidate solution to the validation phase,
which checks whether it is a proper solution (i.e., satisﬁes the
speciﬁcation for all possible inputs). If this is the case, then
the algorithm terminates. Otherwise, additional information is
provided to the inductive synthesis phase in the form of a new
counterexample, C-ex, which is added to the set of test inputs,
and the loop iterates again.
We use two different instantiations of the synthesiser. The
two approaches differ in the manner in which they check the
safety speciﬁcation. The ﬁrst approach, presented in Fig. 2,
starts by devising a digital controller that stabilizes the model
while remaining safe for a pre-selected time horizon ( k) and a
single initial state; then, it employs a multi-staged veriﬁcation
process as follows: (i) The ﬁrst veriﬁcation stage ( SAFETY )
checks that the candidate solution, which we synthesized tobe safe for at least one initial state, is safe for allpossible
initial states, i.e., does not reach an unsafe state within
k
steps. (ii) The second veriﬁcation stage ( PRECISION ) restores
soundness with respect to the plant precision by using interval
arithmetic [17] to validate the operations performed by theSYNTHESIZEVERIFY
1.SAFETY 2.PRECISION 3.COMPLETE DONE
Prog ram SearchBMC-based
VeriﬁerFixed-point
Arithmetic
VeriﬁerCompleteness
VeriﬁerK
C-exPASSIncrease PrecisionIncrease Unfolding Bound
Fig. 2: CEGIS with multi-staged veriﬁcation
1.PRE-
PROCESSING4.ABSTRACT
2.SYNTHESIZE 3.VERIFY (φ)
PASSDONE
Prog ram
SearchAbstr act
AccelerationAbstr action
VeriﬁerKC-ex
Fig. 3: Abstraction-based CEGIS
previous stage. (iii) The third veriﬁcation stage ( COMPLETE )
checks that the current kis large enough to ensure safety for
anyk/prime>k. Here, we compute the completeness threshold k
for the current candidate controller K[8], i.e., the number
of iterations required to sufﬁciently unwind the closed-loop
state-space model such that the boundaries are not violated for
any larger number of iterations, and check that k≥k.
The second approach (illustrated in Fig. 3) employs abstract
acceleration [18] to simultaneously evaluate all possible
progressions of the model. This eliminates the need for a
completeness threshold, since the time horizon considered in
abstract acceleration is inﬁnite. An additional preprocessing
phase is used to compute a set of initial bounds on Kbased
on input constraints. Note that these bounds will be used
by the SYNTHESIZE phase to reduce the size of the solution
space. Since this model is based on abstraction, we initially
perform the synthesis over a basic model that abstracts away
the complexity of the speciﬁcation and is only reﬁned to a
more complex model when a counterexample is found. The useof this Counterexample-Guided Abstraction-Reﬁnement results
in much faster synthesis and veriﬁcation since it is applied
to both phases, allowing for faster results whilst maintaining
soundness for an inﬁnite time horizon.
III. S YNTHESIZING DIGITAL CONTROLLERS WITH THE
DSS YNTH TOOLBOX
A. DSSynth Toolbox Architecture
The proposed synthesis methodology for closed-loop digital
control systems is based on the DSSynth tool [7], [8], which
can be split into two main stages as follows: manual and
automated steps, as illustrated in Fig. 4.
920
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:30:50 UTC from IEEE Xplore.  Restrictions apply. Fig. 4: Phases of the controller synthesis
In Step 1, the user selects the digital controller representation,
which can be a transfer function or a state-space model. In
Step 2, the physical plant (in the form of Equation (1) or (2),
depending on representation) must be given [1]. Finally, in
Step 3, the numerical representation for the digital controller
implementation must be set by the user, i.e., the FWL format
that deﬁnes the number of bits of the integer and fractional
parts as well as the dynamic range inputs. The input provided
by the user is a speciﬁcation of the physical plant.
After that, the automated synthesis process starts with Step A,
where the DSSynth Toolbox translates the digital system spec-
iﬁcation from the MATLAB format into an ANSI-C program.
In Step B, our CEGIS engine is invoked to synthesize the
digital controller w.r.t. the digital system speciﬁcation. Finally,
in Step C, the synthesized digital controller is produced. The
output generated by the DSSynth Toolbox is the synthesized
digital controller represented either in transfer function or state-
space equation. The synthesis is considered to be successful if
a digital controller is correctly synthesized w.r.t. FWL effects;
otherwise, if any parameter is incorrectly deﬁned in previous
steps, or if there is no solution (no controller) for the respective
physical plant (given the implementation requirements), then
the synthesis is considered to have failed.
Our CEGIS engine is implemented as an integrated module
within the C bounded model checker (CBMC) [19]. CBMC
transforms the ANSI-C representation of our closed-loop
control system model into its internal format. We instrument
this IR for each synthesis or veriﬁcation scenario accordingly,
and use CBMC as an oracle to answer our queries. CBMC itselfrelies on an underlying SAT or SMT solver to solve veriﬁcation
conditions. We model FWL effects, time discretization and
the presence of quantization noise explicitly using CBMC’s
nondeterminism API (e.g., nondet ,CPROVER assume intrinsic
functions). Our module is included in CBMC 5.8 and is
available for download.1We further created a VirtualBox OV A
image with our tool pre-installed, including our MATLAB-
generated benchmarks and benchmark shell script with instruc-
tions to run all benchmarks and reproduce our experiments.2
Our toolbox is available online.3
The entire implementation consists of 400lines of MATLAB
scripts for the UI module, 585 and 800 lines of C code
1https://github.com/diffblue/cbmc/archive/cbmc-5.8.zip
2www.cprover.org/DSSynth/controller-synthesis-cav-2017.tar.gz
3https://github.com/ssvlab/dsveriﬁer/tree/master/toolbox-dssynthin the naive and abstract accelerator back-ends, respectively
(cf. Section II), 4000 lines of C code for utility functions such
as interval and ﬁxed-point arithmetic, as well as 1000 lines of
C++ code in the control synthesis module in CEGIS CBMC.
We evaluate DSSynth Toolbox using 18SISO control system
benchmarks. Additionally, documentation and videos about the
DSSynth Toolbox are available at www.cprover.org/DSSynth/
dssynth-toolbox-1.0.0.zip.
B. DSSynth Toolbox Procedures
The DSSynth Toolbox performs the following automated
steps to synthesize a digital controller for the given physical
plant:
1)Setup : obtains the physical plant, ﬁxed-point format and
dynamic input ranges, and translates them to a speciﬁc
structure in MATLAB.
2)Parse : obtains the digital system speciﬁcation and
translates it into an ANSI-C program.
3)Execution : obtains the ANSI-C program from the previ-
ous (parse) step and calls our CEGIS engine as a back-
end program synthesis tool to perform the automated
synthesis.
4)Extraction : obtains the “.log” ﬁle that is generated after
the synthesis phase and then checks the synthesized
digital controller.
5)Report : obtains the digital controller from the previous
(extraction) step and translates it into MATLAB, for
presentation to the user.
C. DSSynth Toolbox Usage
1) Command Line: Users must provide a digital system
described as a MATLAB model using a tf(for transfer
function) or an ss(for state-space model) command (Step
1of Fig. 4). The DSSynth Toolbox is called via the command
line in MATLAB as
synthesize(plant, intBits, fracBits, maxR, minR)
whereplant is the physical plant in state-space or transfer
function representation, intBits is the integer part, fracBits
is the fractional part, maxR andminR are the maximum
and minimum dynamic range, respectively (Steps 2and 3
of Fig. 4). After executing the synthesize command, the
DSSynth Toolbox provides the synthesized digital controller.
921
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:30:50 UTC from IEEE Xplore.  Restrictions apply. 2) MATLAB Application: A graphical user interface appli-
cation was developed (illustrated in Fig. 5) to support digital
controller synthesis in MATLAB. Its aim is to improve usability
and, consequently, to attract more engineers. Users provide the
following inputs for digital controller synthesis within the UI:
physical plant speciﬁcation, ﬁxed-point representation and the
range of the inputs.
(a) Deﬁnition of the system repre-
sentation and the physical plant
(b) Deﬁnition of implementation
aspects and input ranges
(c) Digital controller synthesized
by DSSynth
(d) Step response for the synthesized
digital controller
Fig. 5: DSSynth GUI for controller synthesis using transfer function
representation
D. Illustrative Example
Fig. 6 illustrates each step of the synthesis process for
a physical plant described in Eq. (3), which represents an
unmanned aerial vehicle (UA V) quadcopter system [20]. This
physical plant is expressed by a transfer function G(z), where
B(z)and A(z)represent the numerator and denominator,
respectively, as
G(z)=B(z)
A(z)=−0.06875z2
z2−1.696z +0.7089. (3)
>> num = [-0.06875 0 0];
>> den = [1.0000 -1.696 0.7089];
>> system = tf(num,den,0.002);
>> y = synthesize( system,8,8 ,1,-1);
>> SYNTHESIS SUCCESSFUL
>> y =
>> -0.9983zˆ2 + 0.09587z + 0.1926
>> --------------------------------
>> zˆ2 + 0.5665z + 0.75
Fig. 6: Synthesis of a digital controller for the physical plant deﬁned
in Eq. (3) with ﬁxed-point format /angbracketleft8,8/angbracketrightIn Fig. 6, “num” represents B(z)and “den” represents A(z),
while yrepresents the synthesized stable digital controller,
which is deﬁned by Eq. (4).
C(z)=−0.99832+0.09587z +0.1926
z2+0.5665z +0.75. (4)
A digital system is stable iff all of its poles are inside the z-
plane unity circle, i.e., the poles must have a modulus less than
one [1]. In order to compute the poles for the digital system
represented by Equations (3)and(4), the user can invoke the
feedback andseries commands in MATLAB [12] to obtain a
general equation regarding the transfer function representation,
as illustrated in Fig. 7.
>> num = [-0.99832 0 .09587 0.1926];
>> den = [1 0.5665 0.75];
>> controller = tf(num,den,0.002);
>> num = [-0.06875 0 0];
>> den = [1.0000 -1.696 0.7089];
>> plant = tf(num,den,0.002);
>> sys = feedback(series(controller, plant),1)
>> sys =
>> 0.06863zˆ4 - 0.006591zˆ3 - 0.01324zˆ2
>> ---------------------------------------------------
>> 1.069zˆ4 - 1.136zˆ3 + 0.4849zˆ2 - 0.8704z + 0.5317
Fig. 7: General equation for the closed-loop control system using the
series conﬁguration as illustrated in Fig. 1
The general equation that represents the closed-loop control
system, using the series conﬁguration as illustrated in Fig. 1,
is described by Eq. 5 as follows:
N(z)
D(z)=0.06863z4−0.006591z3−0.01324z2
1.069z4−1.136z3+0.4849z2−0.8704z +0.5317.
(5)
For the stability check, if any root of the denominator
polynomial D(z)in Eq. 5 has modulus equal or greater than
one, then the system is unstable; otherwise, it is stable. Indeed,
the roots computed by the function roots in MATLAB [12]
result in the following poles as illustrated in Fig. 8, which
means that DSSynth has synthesized a stable digital controller.
>> den = [1.069 -1.136 0. 4849 -0.8704 0.5317]
>> r = roots(den)
>> r =
>> -0.2912 + 0.8061i
>> -0.2912 - 0.8061i
>> 0.8225 + 0.0219i
>> 0.8225 - 0.0219i
Fig. 8: Roots of the polynomial D(z)given by Eq. 5
Simulating the digital system represented by Equations (3)
and(4)to validate and reproduce the system stability, the user
can obtain the step response using the command dstep in
MATLAB, and then observe that the plotted graph indicates a
stable digital system (Fig. 9).
IV . DSS YNTH TOOLBOX EXPERIMENTAL EV ALUATION
A. Benchmark Description
Our evaluation consists of 18SISO control system bench-
marks extracted from the literature [7], [8], [14], [15], [20]–
[28], which include physical plants for an unmanned aerial
922
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:30:50 UTC from IEEE Xplore.  Restrictions apply. 0 5 10 15 20 25 30 35 40 45 5000.10.20.30.40.50.60.7Step Response
Time (seconds)Amplitude
Fig. 9: Step response for Eq. (3)describing a stable system for the
UA V quadcopter system
vehicle (UA V), a cruise control system, a spring-mass damper,
a satellite, a direct current (DC) servo motor, a helicopter,
the inverted pendulum, a pendulum, magnetic suspension, a
magnetized pointer, 1/4 car suspension, a computer tape driver,
a ﬂexible beam, a guidance system, a US Coast Guard cutter,
a continuous stirred tank reactor, a voltage regulator, and an
acrobot control system.
B. Experimental Setup
For all evaluated benchmarks, the signal input range is
between −1and 1. The implementation features used for
digital controller are: 8bits for the integer part (including
the sign bit) and 8bits for the fractional part. We have run the
DSSynth Toolbox using CEGIS with multi-staged veriﬁcation
(cf. Section II). All experiments with DSSynth Toolbox v 1.0.0
were conducted on an otherwise idle Intel Core i 7−2600 3. 40
GHz processor, with 24GB of RAM, running Ubuntu 64-bit.
C. Objectives
The main objectives of our experimental evaluation is to
(1) evaluate the DSSynth Toolbox performance to produce
stable and safe controllers, and also (2) conﬁrm the stability
and safety of the synthesized digital controllers outside of our
model using MATLAB.
D. Results
For our experiments, we observed that the DSSynth Toolbox
correctly synthesizes stable and safe digital controllers for
our set of benchmarks represented by transfer functions or
state-space equations. We employed a diverse set of real-worldbenchmarks extracted from the control literature. However, note
that this set of benchmarks is still limited within the scope of
this paper, and the performance may not generalize to other
benchmarks. The median runtime for our benchmarks is 124s,
and the average synthesis time amounts to 35.5s for closed-loop
control systems represented by state-space equations, whilefor transfer functions, the average synthesis time amounts to
123.6s.
Additionally, we are able to reproduce the stability and
safety for all evaluated control system benchmarks. As anexample, we have reproduced the stability property in the
synthesized controller for a DC motor plant described in
Eq.
(6), simulating the step response in MATLAB. Fig. 10
shows that the digital controller synthesized by the DSSynth
Toolbox stabilizes the closed-loop control system using the
series connection (illustrated in Fig. 1) for the DC motor plant.
We have applied this procedure to all synthesized controllers
to validate our experimental results.
C(z)=−0.3466796875z +0.015625
−0.5z2+0.19921875z. (6)
0 100 200 300 400 500 600 700-12-10-8-6-4-20Step Response
Time (seconds)Amplitude
Fig. 10: Step response for the Eq. (6)describing a stable system for
the DC motor plant
Regarding the state-space representation, we have reproduced
the stability property for the closed-loop control system of a
pendulum represented by Eq. (7).
A=/bracketleftbigg
−1.999909737361046 −1.000000000000000
10/bracketrightbigg
,
B=/bracketleftbigg
4
0/bracketrightbigg
,
C=/bracketleftbig−1.756887232846049 −1.7494556607764090/bracketrightbig
,
D=/bracketleftbig9.8/bracketrightbig
.
(7)
For this particular closed-loop control system, the feedback
matrix (see Eq. (8)) generated by the DSSynth Toolbox also
leads to a stable system, as illustrated in Fig. 11.
K=/bracketleftbig−0.5898−0.1914/bracketrightbig
. (8)
The synthesized controllers are also conﬁrmed to be safe
outside of our model representation using MATLAB, which
means that our results are usable for control engineers. Given
that the closed loop dynamics are convergent, the controller’s
safety can be checked by computing the initial state’s inﬁnity
norm, i.e., the product between the l∞norm of the initial states
923
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:30:50 UTC from IEEE Xplore.  Restrictions apply. 02468 1 0 1 2 1 4 1 6 1 8 2 05101520253035Step Response
Time (seconds)Amplitude
Fig. 11: Step response for the Eq. (7)describing a stable system for
the pendulum plant
(||x0||∞=m a x x0) and the l1norm of (||¯A||1=m a x
jm/summationtext
i=1|¯aij|,
where ¯A=A−BK). This is a conservative safety check, which
is based on a sufﬁcient condition [29]. An alternative (but not
conservative) approach is to unfold the system dynamics up
to a given depth, with the initial state equal to its maximum
value, compute the system input and output via the feedback
matrix, and then check the state bounds.
V. C ONCLUSIONS
The DSSynth Toolbox can automatically synthesize stable
and safe digital controllers for dynamic physical plants, repre-
sented in MATLAB either as a transfer function or a state-space
equation. The DSSynth Toolbox is the ﬁrst fully automated
synthesis tool that is algorithmically and numerically sound,
considering various error sources in the implementation of the
digital control algorithm and in the computational modelingof plant dynamics [7], [8]. The DSSynth Toolbox presents
a practical application of CEGIS-based program synthesis.
Our results in control engineering encourage the applicationof this technique in other ﬁelds such as program repair or
superoptimization. Additionally, given the current literature in
controller synthesis, there is no other MATLAB toolbox forsynthesizing stable and safe digital controllers for physical
plants that considers all aspects of their digital implementation.
As future work, the DSSynth Toolbox will perform synthesis
considering performance requirements and will be combined
with the DSVeriﬁer/DSValidator Toolboxes [13], [30] to veri-
fy/validate other controller properties. We will also pursue the
application of CEGIS to further software engineering problems.
REFERENCES
[1]K.˚Astr¨om and B. Wittenmark, Computer-controlled Systems (3rd Ed.),
ser. Prentice Hall information and system sciences series. Upper Saddle
River, NJ, USA: Prentice-Hall, Inc., 1997.
[2]M. Mazo, Jr., A. Davitian, and P. Tabuada, “PESSOA: A tool for
embedded controller synthesis,” in CA V, ser. LNCS, vol. 6174. Springer,
2010, pp. 566–569.[3]H. Ravanbakhsh and S. Sankaranarayanan, “Robust controller synthesis of
switched systems using counterexample guided framework,” in EMSOFT.
ACM, 2016, pp. 8:1–8:10.
[4]C. Economakos, G. Economakos, M. Skarpetis, and M. Tzamtzi,
“Automated synthesis of an FPGA-based controller for vehicle lateral
control,” in MATEC Web of Conferences, vol. 41. EDP Sciences, 2016,
p. 02004.
[5]Y . Guang-Hong, G. Xiang-Gui, C. Wei-Wei, and G. Wei, Linear Systems:
Non-Fragile Control and Filtering. CRC Press, 2013.
[6]R. Istepanian and J. F. Whidborne, Digital Controller Implementation
and Fragility: A Modern Perspective. Springer, 2001.
[7]A. Abate, I. Bessa, D. Cattaruzza, L. C. Cordeiro, C. David, P. Kesseli,
and D. Kroening, “Sound and automated synthesis of digital stabilizing
controllers for continuous plants,” in HSCC. ACM, 2017, pp. 197–206.
[8]A. Abate, I. Bessa, D. Cattaruzza, L. Cordeiro, C. David, P. Kesseli,
D. Kroening, and E. Polgreen, “Automated formal synthesis of digital
controllers for state-space physical plants,” in CA V, ser. LNCS, vol.
10426. Springer, 2017, pp. 462–482.
[9]A. Solar-Lezama, L. Tancau, R. Bod ´ık, S. A. Seshia, and V . A. Saraswat,
“Combinatorial sketching for ﬁnite programs,” in ASPLOS, 2006, pp.
404–415.
[10] R. Alur, D. Fisman, R. Singh, and A. Solar-Lezama, “SyGuS-Comp
2016: Results and analysis,” in SYNT@CA V, ser. EPTCS, vol. 229, 2016,
pp. 178–202.
[11] C. David, D. Kroening, and M. Lewis, “Using program synthesis for
program analysis,” in LPAR-20, ser. LNCS, vol. 9450, 2015, pp. 483–498.
[12] MathWorks, “Matlab toolbox,” https://www.mathworks.com/products/,
2017, accessed: 30-06-2017.
[13] L. Chaves, I. Bessa, L. Cordeiro, E. Lima, and D. Kroening, “Verifying
Digital Systems with MATLAB,” in ISSTA, 2017, pp. 126–131.
[14] I. Bessa, H. Ismail, R. Palhares, L. C. Cordeiro, and J. E. C. Filho,
“Formal non-fragile stability veriﬁcation of digital control systems with
uncertainty,” IEEE Trans. Computers, vol. 66, no. 3, pp. 545–552, 2017.
[15] I. V . de Bessa, H. Ismail, L. C. Cordeiro, and J. E. C. Filho, “Veriﬁcationof ﬁxed-point digital controllers using direct and delta forms realizations,”
Design Autom. for Emb. Sys., vol. 20, no. 2, pp. 95–126, 2016.
[16] MathWorks, “Control system tuner,” https://www.mathworks.com/help/
control/ref/controlsystemtuner-app.html, 2017, accessed: 30-06-2017.
[17] R. E. Moore, Interval analysis. Prentice-Hall, 1966, vol. 4.
[18] D. Cattaruzza, A. Abate, P. Schrammel, and D. Kroening, “Unbounded-
time analysis of guarded LTI systems with inputs by abstract acceleration,”
inSAS, ser. LNCS, vol. 9291. Springer, 2015, pp. 312–331.
[19] E. M. Clarke, D. Kroening, and F. Lerda, “A tool for checking ANSI-
C programs,” in TACAS, ser. LNCS, vol. 2988. Springer, 2004, pp.
168–176.
[20] S. Bouabdallah, P. Murrieri, and R. Siegwart, “Design and control of an
indoor micro quadrotor,” in ICRA, vol. 5, April 2004, pp. 4393–4398.
[21] M. W. Spong, “The swing up control problem for the Acrobot,” IEEE
Control Systems, vol. 15, no. 1, pp. 49–55, Feb 1995.
[22] F. Tadeo, O. P. Lopez, and T. Alvarez, “Control of neutralization
processes by robust loop shaping,” IEEE Transactions on Control Systems
Technology, vol. 8, no. 2, pp. 236–246, Mar 2000.
[23] P. V . Kokotovic, J. J. Allemong, J. R. Winkelman, and J. H. Chow,
“Singular perturbation and iterative separation of time scales,” Automatica,
vol. 16, no. 1, pp. 23–33, 1980.
[24] Z. Gajic, M.-T. Lim, D. Skataric, W.-C. Su, and V . Kecman, Optimal
control: weakly coupled systems and applications. CRC Press, 2008.
[25] G. Franklin, D. Powell, and A. Emami-Naeini, Feedback Control of
Dynamic Systems, 7th ed. Pearson, 2015.
[26] V . A. Oliveira, E. F. Costa, and J. B. Vargas, “Digital implementation ofa magnetic suspension control system for laboratory experiments,” IEEE
Transactions on Education, vol. 42, no. 4, pp. 315–322, Nov 1999.
[27] R. H. G. Tan and L. Y . H. Hoo, “DC-DC converter modeling and
simulation using state space approach,” in CENCON, 2015, pp. 42–47.
[28] “Control tutorials for MATLAB and SIMULINK,” http://ctms.engin.
umich.edu/.
[29] R. Toscano, Structured Controllers for Uncertain Systems: A Stochastic
Optimization Approach , ser. Advances in Industrial Control. Springer,
2013.
[30] L. Chaves, I. Bessa, L. C. Cordeiro, and D. Kroening, “DSValidator: An
automated counterexample reproducibility tool for digital systems (tool
demonstration),” CoRR, vol. abs/1610.07066, 2016. [Online]. Available:
http://arxiv.org/abs/1610.07066
924
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:30:50 UTC from IEEE Xplore.  Restrictions apply. 