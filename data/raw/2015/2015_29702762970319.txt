Towards Bounded Model Checking using
Nonlinear Programming Solver
Masataka Nishi
Center for Technology Innovation, R&D Group, Hitachi Ltd, Japan.
masataka.nishi.en@hitachi.com
ABSTRACT
Due to their complexity, currently available bounded model
checking techniques based on Boolean Satisability and Sat-
isability Modulo Theories inadequately handle non-linear
oating-point and integer arithmetic. Using a numerical
approach, we reduce a bounded model checking problem
to a constraint satisfaction problem. Currently available
techniques attempt to solve the constraint problem but can
guarantee neither global convergence nor correctness. Us-
ing the IPOPT and ANTIGONE non-linear programming
(NLP) solvers, we transform the original constraint satisfac-
tion problem from one having disjunctions of constraints into
one having conjunctions of constraints with a few introduced
auxiliary variables. The transformation lowers the comput-
ing cost and preserves the Boolean structure of the original
problem while complying with limits of NLP solvers.
CCS Concepts
Software and its engineering !Software verica-
tion and validation; Formal software verication;
Keywords
Bounded Model Checking, Nonlinear Programming, SAT
1. INTRODUCTION
We need to develop a toolchain for formally verifying con-
trol software that operates a complex autonomous system
[1]. A particular issue is that supporting a safety claim and
functional integrity of the systems requires correctness of
many assumptions about their operating environment, but
often these assumptions are violated. The violation can put
the systems in a situation where conditions for supporting
the safety and integrity claim get unsatisable. As we can
hardly predict preemptively which subset of an initial as-
sumption may be violated, we can hardly x the impaired
claims at pre-market stage [2]. Unpredictable nature of the
ACM ISBN 978-1-4503-2138-9.
DOI: 10.1145/1235violation poses a certication challenge for the control soft-
ware involved [3]. Regulatory authorities and casualty insur-
ance rms are concerned about when the situation could oc-
cur; under what condition the autonomous systems could go
wrong, and how to discover the violation from a recorded log
and to replay the situation. The authorities and insurance
rms need to develop an eective procedure for exhaustively
exploring the situation. Software developers need to propose
a scheme of repairing the once impaired claim in a justiable
way. The procedure would assist in obtaining a certication
before deployment, and for accident investigation after de-
ployment in the eld. Yet, it is a complex inverse problem.
Bounded model checker (BMC) for software serves as an
automated tool for modeling, formulating, formalizing, and
solving the inverse problem. But, real-world autonomous
systems run with complex control algorithms on a large ar-
chitecture beyond that currently available BMC can handle.
One of existing toolchains is CBMC [4]. CBMC oers a
generic way of describing a model that consists of assump-
tions on an input and an initial state, a procedure of pro-
ducing an output, and a verication condition (VC) on a
relation between the input and the output. CBMC consists
of a front-end procedure for translating an original problem
expression into the Static Single Assignment (SSA) form for
building a formula of predicates produced using a dedicated
encoding technique. CBMC also consists of a back-end pro-
cedure of solving a satisability (SAT) problem of the for-
mula. We can verify dynamic behavior of a reactive system
by putting a state transition logic in a loop construct. Linear
Temporal Logic (LTL) is a primitive language for expressing
the VC. It can be built in a model program with two-threads
using a dedicated formulation of an assertion construct. By
the design of BMC, we can explore a nite number of tran-
sition steps. We selectively build the formula by bit-vector
encoding or Satisability Modulo Theories (SMT) encoding
of the SSA form. CBMC implements the rst one [5, 6]
to build the formula and solve it using Boolean SAT solver
MiniSAT2. If the formula is reducible or if the original pro-
gram is inadequately expressed using a bit-vector encoding,
then SMT encoding [9] using SMT solvers Z3 [7] and Math-
SAT [8] is more suitable. If the formula consists of a mix of
disjunctions and conjunctions of predicates, the both solvers
exploit an ecient decision procedure CDCL [10].
Yet, the existing SAT/SMT solvers can hardly handle
equations commonly used in numerical control software; equa-
tions of non-linear, of oating-point arithmetic, and of stan-
dard mathematical functions. It is due to hurdles regard-
ing complexity of modeling bit-vector arithmetic and un-
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission and/or a
fee. Request permissions from Permissions@acm.org.
ASE‚Äô16 , September 3‚Äì7, 2016, Singapore, Singapore
c2016 ACM. 978-1-4503-3845-5/16/09...$15.00
http://dx.doi.org/10.1145/2970276.2970319
560
decidability of a general SAT problem over reals and inte-
gers. Practitioners sidestep the known hurdles by bounding
search domain, developing numerically approximate tech-
niques, and limiting on using specic constructs only. dReal
[11, 12] is based on Interval Constraint Propagation (ICP)
[13, 14]. We found that it shares a well-known weakness
of Simplex method revealed by Rosenbrock. It exhibits
poor convergence if the equation is non-convex and of multi-
variables. The weakness originates from that a contracting
feasible domain specied by intervals is an axis-aligned con-
vex polytope and it can hardly asymptotically t non-convex
feasible region. CalCS [20] employs convex programming
and the same issue arises. Other attempts are reducing the
SAT problem to a numerical optimization problem. Reports
[15, 16] attempted to minimize a sum of constraint violations
and explored a global minimum where a satisable solution
resides. Yet, a search strategy based on a derivative-free
method or gradient-descent lacks a mechanism of guaran-
teed global convergence and thus fails. The search for the
global minimum stalls at a local minimum of the objective
function and results in a false report that the SAT problem
is unsatisable, or may not terminate. As we usually take
refutation of the VC and if the formula is unsatisable, it
can cause an unfavorable false negative decision.
We exploit a high-level mathematical property of the orig-
inal SAT problem and solving it using selected constrained
nonlinear programming (NLP) solvers ANTIGONE [18] and
IPOPT [17]. We use them in a way that global conver-
gence is guaranteed and we correctly decide satisability.
We quickly compute a numerically approximate satisable
solution with specied small error bounds. Existing numer-
ical techniques and other NLP solvers lack the guarantee of
global convergence, and thus possibly incorrectly decide sat-
isability when the equations are non-linear or non-convex.
As the NLP solvers can receive a formula of conjunction
of predicates only, we propose techniques of transforming
the formula having disjunction of predicates into one hav-
ing conjunction of predicates while preserving the original
Boolean structure. Few attempted that way, since the ma-
jority persistently regards the original one as a logic formula.
Coincidentally, we only have to solve fewer independent NLP
instances and we can handle larger complex formula.
2. BACKGROUND
2.1 Generation of SatisÔ¨Åability Problem
We inherit an existing front-end procedure of bounded
model checking technique based on symbolic execution [4].
It includes preprocessing, loop unwinding, appending asser-
tions, and a procedure of translating the original program
expression of an input-to-output relation into a partial-order
graph of components comprised of branching, assignments,
assertions, labels, and goto instructions. Each component
is translated into an intermediate representation SSA form,
and then into a predicate. By rule, a new variable is assigned
to a return value at each step of computation. Thus, an ar-
ray of predicates (1) is produced from an N-step sequential
program that consists of assignment functions Feq
k(Xk).
N 1^
k=0 xk+1+Feq
k(Xk) = 0 (1)
Xk+1 fxk+1;Xkgis a program state produced up un-til step k+1, xk+1is a newly assigned return value of an
assignment at step k,X0fxinit
kj08k<N initgis an ini-
tial program state that contains inputs to the program. We
introduce a decision function 
DL
kFbr
k(Xk)DU
k
2B,
0k < N that splits execution path at a branching step
in the program. It is divided into a pair of an assignment
 xk+1+Fbr
k(Xk) = 0 and a comparison DL
kxk+1
DU
k. We combine with some constructs necessary to or-
ganize a bounded model checking problem. An assump-
tion function 
ALFas
k(X0)AU
2B, 0 8k < W
limits a search space and species a constraint on X0. It
is divided into an assignment  xas
k+Fas
k(X0) = 0 and
a comparison AL
kxas
kAU
k. An assertion function
: 
CLFas
N(XN)CU
2Bencodes a verication condi-
tion and divided into an assignment  xN+1+Far
N(XN) = 0
and a comparison CLxN+1CU. HereFas=eq=br=ar
k
can contain non-linear arithmetic. We trail a sequence of
executions for each branching path and build a formula (2).
W 1V
k=0 
 xas
k+Fas
k(X0) = 0^AL
kxas
kAU
k
^
N 1V
k=0 xk+1+Feq=br
k (Xk) = 0^DL
kxk+1DU
k^
 xN+1+Far
N(XN) = 0^CLxN+1CU(2)
We attempt to nd a satisable XNby numerically solving
this system of equations (2). To avoid producing a vacuous
model checking problem, we assume that the assertion and
a conjunction of the assumption functions are satisable.
2.2 Constrained NLP Solver
General Algebraic Modeling System (GAMS) is a high-
level modeling system for describing a constrained NLP prob-
lem with a common interface to a collection of solvers. Mixed
Integer NLP solver (MINLP) is an extension of the NLP
solver for handling non-linear integer arithmetic. A stan-
dard MI/NLP solver attempts to compute a local/global
optimal solution of an objective function f(x;y) subject to
constraints gj(x;y) and bounds on variables given as (3).
m^
j=1gL
jgj(x;y)gU
j^nr^
i=1xL
ixixU
i^ni^
i=1yL
iyiyU
i
(3)
It consists of problem variables x2Rnrandy2Zni, a
twice-dierentiable objective function f(x;y) :RnrZni!
R, twice-dierentiable constraint functions gj(x;y) :Rnr
Zni!Rwith a pair of bounds gL
j;gU
j2Rfor each 1
jm, bounds on the variables f(xL
i;xU
i)j1inrg
andf(yL
i;yU
i)j1inigwherexL;U
i2R,yL;U
i2Z. The
bound constraints species the entire search space. We use
a particular NLP solver IPOPT [17], and a MINLP solver
ANTIGONE [18]. IPOPT is an implementation of primal-
dual interior point method using logarithmic barrier func-
tion. Each MI/NLP solver adopts a dierent mechanism
of solving a MI/NLP instance. For clarity of explaining a
mechanism of the NLP solver, we remove integer part in this
section. For our purpose of solving satisability problem,
we setf(x;y) = 0 and assign one predicate in (2) to each
gj(x;y). We need to transform a non-linear inequality con-
straintgL
jgj(x)gU
jinto a pair of an equality constraint
0gj(x) sj0 and a bound constraint gL
jsjgU
j
on an auxiliary variable sj. A search [15] for a global op-
561timum of constraint violationPjgj(x)jtoward a direction
 Prxjgj(x)jdoes not guarantee global convergence and
thus fails. Instead, IPOPT builds a barrier problem (4).
L(x;) :=mX
j=1jgj(x) nX
i=1 
log(v+
i) +log(v 
i)
(4)
j2Ris a Lagrangian multiplier for each gj(x) that
penalizes large constraint violation. is called a barrier
parameter that enforces the bound constraints v
i0 where
v+
ixi xL
i,v 
ixU
i xi. The constraint functions
and bound constraints are embodied dierently. We dene
a barrier KKT point fx;;zgusing a bound multiplier
z
i>0 where the following KKT condition is satised.
n^
i=12
4z
iv
i = 0^
mP
j=1jrxigj(x) (z+
i z 
i) = 03
5^m^
j=1gj(x) = 0
IPOPT computes a search iterate witrfxitr;itr;z
itrg
and a search direction 4witrtoward the KKT point by solv-
ing a matrix equation rr(witr)T4witr= r(witr) where
r(witr)fr xL(x;);fgj(x)g;fz
iv
i gg. The last bar-
rier term in (4) and a primal-dual mechanism modify the
search direction. A capability of driving witrfrom an arbi-
trary initial point xinitto the barrier KKT point is called
global convergence [17]. IPOPT drives !0 and computes
a converging series of the KKT points until (5) is met.
maxkrxL(x;)k1
sd;kgj(x)k1;kz
iv
i k1
sc
tol
(5)
sc;sdare scaling parameters assigned inside IPOPT and
become 1 at a convergent point. When (3) is feasible, the
Newton-like iteration continues until the second term in (5)
and the third term in (5) get below a suciently small tol.
IPOPT drives the search iterates to a satisable solution of
(3). We get a numerically approximate solution to the orig-
inal SAT problem (3). The property of global convergence
is preserved even when (3) is infeasible, and we get correct
decision of satisability of (3). If unsatisable, then IPOPT
terminates at a point where either at least one of terms in (4)
is violated. We analyze the amount of constraint violations
gj(xUNSAT ) using a nal assignment of xUNSAT .
2.3 Limitations and Scalability
Each MI/NLP solver has a dierent capability and lim-
its often implicitly stated. A common limit is that we need
to organize a conjunction of twice-dierentiable constraint
functionsgj(x). A dedicated parser can decompose a com-
plex formula Feq
kinto a composite of elementary arithmetic
functions. Compilers such as LLVM can decompose it into
machine instructions which an appropriate NLP encoding is
applicable. In Section 3, we propose techniques of convert-
ing a formula of a disjunction of predicates into a formula
of conjunctions that preserves the Boolean structure. Other
limits originate from the mechanism of MI/NLP solver.
2.3.1 Continuity of Constraint Functions
A search strategy of major MI/NLP solvers exploits that
constraint functions are twice dierentiable within the do-main of the bound constraints. We should identify discon-
tinuity in the formula symbolically, as existing NLP solvers
can hardly nd it numerically and correctly. We refer to
some techniques for reformulating an apparently discontin-
uous function into a continuous one. Ones for a discrete
functionmin(fvjg) is shown in Section 3.3. A non-smooth
functionabs(g(x)) onx2Ris reformulated as abs(g(x)) =
g+(x) g (x)0^g+(x)0^g (x)0. Integers arith-
metic produce a discontinuous function. Yet a suitable re-
formulation often exists. Modulo operator b=x%aon
x;a;b2Nis rewritten as a formula x=ac+b^0b<a
using an auxiliary variable c2Nwith checking overow
caused byac. k-bit-shift operator on an unsigned r-bit
integerxkisx=2k, whilexkis 2kx%2r.
2.3.2 Global Convergence from Infeasible Point
Guarantee of global convergence is required to decide sat-
isability correctly. As we do not know preemptively that
the posed NLP instance is satisable or not, the NLP solver
may have to start from a potentially infeasible initial point
and explore a potentially unsatisable nal point as iter-
ation proceeds. With the reformulation of non-linear con-
straints mentioned in Section 2.2, IPOPT and ANTIGONE
are qualied in this sense. Some NLP solvers implicitly
require that the non-linear constraint functions fgj(x)gis
convex [19]. This signicantly limits applicability. Thus,
we need to adopt a NLP solver that can handle non-convex
constraint functions. The hurdle of non-convexity is relaxed
by assigning an auxiliary variable on a return value of each
convex component in the original constraint functions, and
reformulating the original one as sum of linear, bilinear, or
convex ones. Some advanced solvers overcome the hurdle by
exploiting such a special structure of the original one [18].
2.3.3 Path-Connectedness
The mechanism of producing a converging series of search
iterates from an initial search point to the nal satisable
KKT point is homotopy continuation regarding . We need
to assume path-connectedness of the domain of constraint
functions in topological sense and warrant that there exists
a continuous path between the points. It requires the conti-
nuity of the constraint functions. Transforming a discontinu-
ous constraint function into a composite of continuous ones
recovers path-connectedness and avoids fragmenting feasi-
ble regions. NLP solver can drive them toward the nal one
as the Newton-like iteration proceeds. Otherwise, the NLP
solver may not be able to reach the nal KKT point and
incorrectly reports unsatisable. A branch condition breaks
this limit. We need to organize one NLP instance for each
branching path and the path explosion problem revives.
2.3.4 Bounded Execution Time
If the Lagrangian Lin (4) is a function of oating-points
and self-concordant, the number of Newton-like iterations is
bounded [19]. It is O(pmlog(m)) wheremis the number
of constraint functions. It can be multiplied by log(kgj(x0)k1
=tol). At every iteration, Jacobian and Hessian matrix of
the constraint functions is organized, and inverse of the ma-
trix are computed using a subroutine in BLAS library. As
each constraint function gj(x) usually contains few of the
problem variables in x, the Jacobian and the Hessian ma-
trix are sparse. Cost of inverting a sparse matrix scales
linearly to the number of non-zero elements that is roughly
562O(m+n). The total amount of computational cost is in
the order of O(pmlog(m))O(m+n). We can add vari-
ables of integer type and call MINLP solver ANTIGONE.
But, there is no technique that rmly bounds the number
of iterations for solving the MINLP instance. At least, we
need to use the MINLP solver within a limited set of specic
non-linear functions for the global convergence.
3. ENCODING SAT INTO NLP
3.1 Solving BMC Problem by NLP Solver
We propose reducing a BMC instance to a SAT prob-
lem of the formula (2). If (2) is satisable, we want an
accurate satisable solution XNwhere Xk+1fxk+1;Xkg,
X0:=fxinit
jj0j < N initg, xas
j+Fas
j Xj
= 0 for
0j < W , and xj+1+Feq=br=ar
j Xj
= 0 for 0j
N. However, IPOPT produces a numerically approximate
satisable solution XNthat contains accumulation of nu-
merical error. They are apart from XNby the amount
of xjxj xj, xinit
jxinit
j xinit
jand xas
j
xas
j xas
j. IPOPT reports xsuch thatkgj(x)k1tol.
It implies that tol xj+1+Feq=br=ar
j (Xj)tolfor
0 8jN, and tol  xas
j+Fas
j(X0)tolfor
08jNinit. The third term in (5) warrants that all
components in XNare within their bounds. If Fas=eq=br=ar
j
are not twice-dierentiable, then we need to transform them
into a composite of twice dierentiable functions. We sup-
pose that all offgjgare twice-dierentiable. Then, there
exists ~Leq=br=ar
j;k>0 such that@Fas=eq=br=ar
j=@xinit
k<
~Las=eq=br=ar
j;k for 0k < N init. There exists Leq=br=ar
j;k>0
such that@Feq=br=ar
j=@xk<Leq=br=ar
j;k for 0k<j , and
0 forjkN. Thus, errors are constrained as follows.
W 1V
j=0xas
j Ninit 1P
k=0~Las
j;kxinit
ktol
NV
j=02
6640
BB@kxj+1k Ninit 1P
k=0~Leq=br=ar
j;kxinit
k 
 jP
k=1Leq=br=ar
j;kkxkk1
CCAtol3
775
As the inequality matrix with respect to a composite of error
vectorsfxinit
jj0j < N initg,fxas
jj0j < Wg,
andfkxjkj1jN+1gforms a lower triangular matrix
having diagonal values 1 , eigenvalues of the matrix is 1.
Thus, the error bounds are at mostxinit
jr0for 0
8j < N init,xas
jrWfor 08j < W , andkxjk
rW+jfor 18jN+ 1, where rjpNinit+jtol. An
impact of the accumulation of numerical errors on evaluation
ofFas=br=ar
j are bounded as follows.
AL
k r0xas
j=Fas
j(X0)AU
k+r0
DL
k rW+jxj+1=Fbr
j(Xj)DU
k+rW+j
CL rW+N+1xN+1=Far
N(XN)CU+rW+N+1
The errors extend only linearly with respect to square root of
the number of program steps. Actual amount of the errors is
revealed once we recompute Fas=eq=br=ar
j using X0. To avoid
falsely reporting that X0is a satisable solution regardless
of the errors, we need to validate that the decision on satis-
ability of (3) is irrelevant to the errors. Alternatively, we cancheck if at least -weakening of the original predicates are
satised [11]. A practical treatment for warranting sound-
ness is keeping equality constraints in (2) untouched, while
tightening inequality constraints of the comparisons in (2)
by accommodating the amount of the errors =rW+N+1.
3.2 Error Tolerance
3.2.1 Data Type, Range and Precision
MI/NLP solver internally builds an instance using a stan-
dard set of data types that may dier from those of pro-
gram states in (2). Data range used in the instance needs
to be wider than that of the variables in the model. We
need to recompute the program using X0to validate that
the correctness of decision is irrelevant to the potential in-
compatibility. Concerns of numerical inaccuracy in contrast
to bit-precise reasoning techniques that guarantee zero er-
ror tolerance is misleading in practice. Indeed, if program
states are integers and if return values from arithmetic op-
erations on them are also integers, then we can get an exact
satisable solution vector by setting "tol<1 and enforcing
zero error tolerance. It is infrequent but we may be able to
get analytically derived satisable solution vector. Yet, data
representation of the analytically precise solution vector can
get large in practice or given with implicit functions. After
all, we need a numerical solver and the same error tolerance
tolto decipher the solution vector into decimal numbers.
3.2.2 Machine Arithmetic
Machine arithmetic is a potential source of incompatibil-
ity; machine-dependent data types, rounding rules of inte-
gers, and compliance with IEEE standard of oating-point
operations. An actual program may produce a program
stateXNthat greatly deviates from one based on real arith-
metic that our NLP encoding presumes. The limits of MI/
NLP solvers can be broken by constructs which are com-
pliant with ANSI-C standard; decient type conversion that
discontinuously changes the value or results in precision loss,
from unsigned to signed integer, and from double-precision
to single-precision oating point number. We can remove
them by using a static analyzer and enforce a conserva-
tive coding standard in return for ease of verication. In
practice for safeguarding against unnoticed error originat-
ing from them, we need to compute each return value of
Fas=eq=br=ar
k in the same way that we execute the original
program. If we nd that the error is beyond rW+kat stepk,
it implies either a bug of NLP encoding or a awed MI/NLP
solver that lacks the guarantee of global convergence.
3.3 Conversion of CNF and DNF
The NLP solvers can receive a formula comprised of a
conjunction of predicates. We need to develop reformulation
techniques to remove disjunctions of predicates.
3.3.1 Conversion of CNF into Conjunctions
Conjunctive Normal Form (CNF) (6) is a standard form
of a formula which consists of conjunction of clauses and
each clause is disjunction of predicates gi;j(x)0.
m^
i=1 Mi_
j=1gi;j(x)0!
(6)
As long as one persistently regards (6) as a logic formula,
563we need to solveQm
i=1Miindependent NLP instances for
each combination of the predicates. This adversely impacts
on cost of computation and scalability of numerical tech-
niques in general. We propose some techniques of transform-
ing a disjunction of predicates into a conjunction of predi-
cates by appending some auxiliary variables while preserving
the Boolean structure of the original formula.
Lemma 1.Givenftj2Rj1jmg.mW
j=1tj0is
satisable, if and only if parameters fpj2Rj1jmg
in the following formula is satisable.
m^
j=10pj1^mX
j=1pj= 1^mX
j=1pjtj=w^w0
Proof. Asmin
1jmtjwmax
1jmtjand 0w, thus
0max
1jmtj.
By Lemma 1, each disjunction of predicates in (6) is rewrit-
ten as a formula (7) with auxiliary variables pi;jandti;j.
MiV
j=1(0pi;j1^gi;j(x) =ti;j)^MiP
j=1pi;j= 1^
MiP
j=1pi;jti;j=wi^wi0(7)
3.3.2 Conversion of DNF into Conjunctions
Disjunctive Normal Form (DNF) (8) is a standard form
of a formula which consists of a disjunction of clauses and
each clause is conjunction of predicates gi;j(x)0.
M_
i=1 Mi^
j=1gi;j(x)0!
(8)
This DNF formula is transformed into conjunction of pred-
icates (9) with auxiliary variables fsig.
M_
i=1si0^M^
i=1
si=min
1jMigi;j(x)
(9)
By Lemma 1, the rst term of (9) is reformulated as (10).
M^
i=10pi1^MX
i=1pi= 1^MX
i=1pisi=w^w0(10)
Lemma 2.Givenftj2Rj1jMig.s=min
1jMitjis
a satisable solution of the following formula.
Mi^
j=1tjs^Mi^
j=10qj1^MiX
j=1qj= 1^MiX
j=1qjtj=s
Proof. Asmin
1jMitjsmax
1jMitjandMiV
j=1tjs,
thuss=min
1jMitj.
Each predicate in the second term of (9) is rewritten as (11).
Mi^
j=1
gi;j(x) =ti;j^
ti;jsi^0qi;j1
^MiX
j=1qi;j
1
ti;j
=
1
si
(11)The proposed way of converting the DNF (8) is not ben-
ecial ifMis small and Miare large. Because 1 + M+ 2PM
i=1Miauxiliary variables andPM
i=1(2 + (Mi+ 2)) con-
straint functions are added. Instead, we should build M
independent NLP instances and solve them in parallel.
3.4 Limitation on Scalability
Common determinants of the cost for solving a SAT prob-
lem using our NLP encoding are the number of program
steps giving m, the number of problem variables giving n+
m, number of branching paths, and non-linearity of arith-
metic operation. We need to add some auxiliary variables
and increase n, if a VC has disjunction of predicates. Also,
the number of independent NLP instances that we need to
solve increases as the number of branches increases. We need
a better NLP encoding of a branch or reinvent a CDCL pro-
cedure suitable for our NLP encoding.
3.5 Non-trivial Way of Encoding Assertions
A generic assertion construct can be built in a function
Far
Nin (2). We focus on particular assertions that break
the limits of NLP/MINLP solvers; arithmetic overow and
invalid arithmetic operation known as runtime errors.
3.5.1 Arithmetic OverÔ¨Çow
A constraint function that reproduces the eect of arith-
metic overow is discontinuous and breaks the limits dis-
cussed in Section 2.3. We need to detect the overow and
remove such cases before organizing a NLP instance with
a VC. It is a problem of checking if any of return values
xkfrom the arithmetic operation Feq=br=ar
k in (1) exceed a
bound
xL
k;xU
k
of the data type of xk. We employ a formula
(12) to detect the overow when Fas
k(X0) is satisable.
XL
0X0XU
0^Eq:(2)^:N+1^
k=1xL
kxkxU
k (12)
The last term in (12) is disjunction of predicates as we take
negation of a formula composed of conjunction of predicates.
By applying Lemma 2, we get (13), and then translated into
(14) that is conjunction of predicates. As this adds fewer
variables, this reformulation is better than ones using (8).
s=max[max
1kN+1xk xU
k; max
1kN+1xL
k xk]^[0<s] (13)
N+1P
k=1
xk xU
kxL
k xk
1 1
pU
k
pL
k
=
s
1
^
N+1V
k=10pL;U
k1^0<s(14)
3.5.2 Invalid Arithmetic Operation
Floating point division is inevitable in computing an in-
verse matrix. Verication of oating-point division has been
regarded as a challenge, as it needs to handle precision loss
correctly. As existing NLP solvers store numbers in 64-bit
IEEE double-precision values and compute using them, the
same eect of precision loss is reproduced. Our NLP en-
coding has a dierent challenge when the constraint func-
tion contains the division y=d(x),x;y2Rwhered(x) =
d0(x)=d1(x). We suppose that the divisor d1(x) and the
dividendd0(x) are twice dierentiable in the domain spec-
ied by bound constraints. Setting a constraint function
564y d0(x)=d1(x) = 0 is not twice dierentiable at which
d1(x) = 0, it violates the limit of smoothness and thus
path-connectedness. We may start from an initial search
pointfx= 0;y= 0gsuch that there exists no smooth
path between the initial point and a satisable point fx;y=
d(x)g, if there exists a separating hyper-surface d1(x) = 0.
We avoid it in two steps. Firstly, we decide if an asser-
tionabs(d1(x))< is unsatisable with respect to a small
bound >0 for each divisor, and check if the division re-
tains arithmetic validity without returning a Not-a-Number
value. If the assertion is unsatisable, we proceed to check if
ys1 s0= 0^s0 d0(x) = 0^s1 d1(x) = 0 is satisable.
It preserves the same satisable assignment fx;y=d(x)g
and recover smoothness of constraints. If y<0,sqrt(y) and
log(y) can get invalid. Instead, we check if z2 y= 0^z0
andez y= 0 are satisable. Encoding unsigned integer
divisionr=p=q,p;q;r2Ndiers from oating-point divi-
sion. We use a predicate p=qr+s^0s < q^0
p;q;r;s;qr<232and check if q= 0 is unsatisable.
4. DISCUSSION ON COMPLEXITY
We argue that it is a misleading thought that deciding
satisability of a formula having predicates of non-linear in-
teger arithmetic and of non-convex functions is greatly di-
cult due to combinatorial complexity. Indeed, some MINLP
solvers suer from increasing number of branch-and-bound
steps that reect the inherent combinatorial complexity. Yet,
the program (1) is forward computation. There exists a sat-
isable assignment once given X0, irrelevant to the length of
program steps and arithmetic complexity of Feq=br
k . We are
eectively exploring the search space fxN;X0grather than
the entire space of XN. The search space of X0is rstly
constrained by Fas
kand that of xNis done by Feq=br=ar
k .
The predicate of the assertion function Far
Nis the single one
that may conict with other predicates. Thus, the complex-
ity is manageable, as far as we use the MI/NLP solver to
solve a SAT problem generated accordingly. Meanwhile,
the decision functions at branching steps contribute to the
combinatorial complexity, since they discontinuously split
the search space. Yet, modern control software is automat-
ically generated from an IDE that encourages developers to
describe a dataow diagram composed of function blocks
rstly, and implement a complex algorithm in a block after-
ward. Using unbounded loops in real-time control software
is prohibited. Thus, the complexity in control ow and re-
sulting path explosion problem is unlikely a practical issue.
5. CONCLUSIONS
We presented a new way of translating a BMC problem
into a satisability (SAT) problem using a constrained non-
linear programming (NLP) solver. We presented techniques
for reformulating the original SAT problem into a NLP prob-
lem in a way that the global convergence of the NLP solvers
is preserved. As we need to organize one MI/NLP instance
for each branching execution path, the path explosion prob-
lem persists. We explore a way of merging branch-and-
bound steps in the MI/NLP solver with the CDCL scheme.
6. ACKNOWLEDGEMENTS
We appreciate Ed Gamble for proofreading, Prof. Kroen-
ing for much eorts on releasing CBMC under open source li-cense, and anonymous reviewers of CAV2015, FMCAD2015,
ICSE2015 and CAV2016 for valuable and critical comments.
7. REFERENCES
[1] K. Nidhi, Driving to Safety: How Many Miles of
Driving Would It Take to Demonstrate Autonomous
Vehicle Reliability?, In RR1478, RAND Corp., 2016.
[2] M. Nishi. Runtime conict resolution mechanism for
functional integrity of autonomous system. In Proc. of
53rd IEEE Conf. on Decision and Control, IEEE, 2014.
[3] John Rushby. Runtime certication. In Runtime
Verication. 21-35. Springer, 2008.
[4] E. Clarke, et.al. A tool for checking ANSI-C programs.
In TACAS, 168{176, Springer, 2004.
[5] A. Biere, et.al. Symbolic model checking without
BDDs. In:TACAS 1999, 193{207, Springer, 1999.
[6] Niklas Een et.al. MiniSat: A SAT solver with
conict-clause minimization. In SAT 2005, 2005.
[7] L D. Moura et.al. Z3: An ecient SMT solver. In
Tools and Algorithms for the Construction and
Analysis of Systems. 337-340, Springer, 2008.
[8] M. Bozzano. MathSAT: Tight integration of SAT and
mathematical decision procedures. In J. of Automated
Reasoning, vol. 35.1-3, pp.265-293, 2005.
[9] L. Cordeiro. SMT-based bounded model checking for
embedded ANSI-C software. In IEEE Trans. on
Software Engineering, vol. 38.4, 957-974. IEEE, 2012.
[10] L. Bordeaux. Propositional satisability and constraint
programming: A comparative survey. In ACM
Computing Surveys, vol. 38.4, pp. 12, ACM, 2006.
[11] Sicun Gao,et.al. -complete decision procedures for
satisability over the reals. In Int. Joint Conference on
Automated Reasoning: 286-300, Springer, 2012.
[12] Sicun Gao, et.al. dReal: An SMT solver for nonlinear
theories over the reals. In Automated Deduction
CADE (24): 208-214, Springer, 2013.
[13] M. Franzle. Ecient solving of large non-linear
arithmetic constraint systems with complex boolean
structure. In Journal on Satisability, Boolean
Modeling and Computation (1): 209-236, SAT, 2007.
[14] M. Borges et al. Symbolic execution with interval
solving and meta-heuristic search. In Fifth
International Conference on Software Testing,
Verication and Validation, 111-120, IEEE, 2012.
[15] Tim King et.al. Simplex with Sum of Infeasibilities for
SMT. In FMCAD2013, 189-196, ACM, 2013.
[16] M. Souza, et al. CORAL: solving complex constraints
for symbolic pathnder. In NASA Formal Methods
2011, 359-374, Springer, 2011.
[17] A. W achter and L. T. Biegler. On the implementation
of an interior-point lter line-search algorithm for
large-scale nonlinear programming. In Mathematical
programming, 106(1):25-57, 2006.
[18] Ruth Misener, et.al. ANTIGONE: algorithms for
continuous/integer global optimization of nonlinear
equations. In Journal of Global Optimization 59 (2-3):
503-526, Springer, 2014.
[19] Stephen Boyd, and Lieven Vandenberghe. Convex
optimization. In Cambridge university press, 2009.
[20] P. Nuzzo, et al. CalCS: SMT solving for non-linear
convex constraints. Proc. of FMCAD 2010, 2010.
565