Synthesizing Framework Models for Symbolic Execution
Jinseong JeonXiaokang QiuyJonathan Fetter-Degges
Jeffrey S. FosterArmando Solar-Lezamay
University of Maryland, College Park, USAyMassachusetts Institute of Technology, USA
{jsjeon,jonfd,jfoster}@cs.umd.edu {xkqiu,asolar}@csail.mit.edu
ABSTRACT
Symbolic execution is a powerful program analysis tech-
nique, but it is dicult to apply to programs built using
frameworks such as Swing and Android, because the frame-
work code itself is hard to symbolically execute. The stan-
dard solution is to manually create a framework model that
can be symbolically executed, but developing and maintain-
ing a model is dicult and error-prone. In this paper, we
present Pasket, a new system that takes a rst step toward
automatically generating Java framework models to support
symbolic execution. Pasket's focus is on creating models by
instantiating design patterns .Pasket takes as input class,
method, and type information from the framework API, to-
gether with tutorial programs that exercise the framework.
From these artifacts and Pasket's internal knowledge of de-
sign patterns, Pasket synthesizes a framework model whose
behavior on the tutorial programs matches that of the origi-
nal framework. We evaluated Pasket by synthesizing mod-
els for subsets of Swing and Android. Our results show that
the models derived by Pasket are sucient to allow us to
use o-the-shelf symbolic execution tools to analyze Java
programs that rely on frameworks.
Categories and Subject Descriptors
I.2.2 [ Automatic Programming ]: Program Synthesis
Keywords
Program Synthesis, Framework Model, Symbolic Execution,
Sketch.
1. INTRODUCTION
Many modern applications are built on frameworks such
as Java Swing (a GUI framework) or the Android platform,
among many others. Applying symbolic execution [5] to
such applications is challenging because important control
and data ows occur via the framework [11]. For example,
consider a Swing application that creates a button, registers
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full cita-
tion on the Ô¨Årst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission
and/or a fee. Request permissions from permissions@acm.org.
ICSE ‚Äô16, May 14-22, 2016, Austin, TX, USA
c2016 ACM. ISBN 978-1-4503-3900-1/16/05. . . $15.00
DOI:http://dx.doi.org/10.1145/2884781.2884856a callback for it, and later receives the callback when the
button is clicked. A symbolic executor that simulates only
application code would miss the last step, since the control
transfer to the callback happens in the framework.
One possible solution is to symbolically execute the frame-
work code along with the application, but in our experience
this is unlikely to succeed. Frameworks are large, compli-
cated, and designed for extensibility and maintainability. As
a result, behavior that appears simple externally is often im-
plemented in complex ways. Frameworks also contain details
that may be unimportant for a given analysis. For instance,
for Swing, the details of how a button is displayed may not
be relevant to an analysis that is only concerned with con-
trol ow. Finally, frameworks may contain native code that
is not understood by the symbolic executor.
The standard solution to this issue is to manually create
a framework model that mimics the framework but is much
simpler, more abstract, and can be symbolically executed.
For example, Java PathFinder (JPF) includes a model of
Java Swing [24] that is written in Java and can be symbol-
ically executed along with an application. However, while
such models work, they suer from several potential prob-
lems. Since the models are created by hand, they likely con-
tain bugs, which can be hard to diagnose. Moreover, models
need to be updated as frameworks change over time. Finally,
applying symbolic execution to programs written with new
frameworks carries a signicant upfront cost, putting appli-
cations that use new or unpopular frameworks out of reach.
In this paper, we take a rst step toward automatically
synthesizing framework models by introducing Pasket (\Pat-
tern sketcher"), a tool that synthesizes Java framework mod-
els by instantiating design patterns . The key idea behind
Pasket is that many frameworks use design patterns heav-
ily, and that use accounts for signicant control and data
ow through the framework. For example, the Swing but-
ton click callback mentioned above is an instance of the
Observer pattern [12]. Thus, by creating a model that in-
cludes an equivalent instantiation of the observer pattern,
Pasket helps symbolic execution tools discover control ow
that would otherwise be missed.
Overview. Figure 1 gives an overview of Pasket. Its two
main inputs are a set of tutorial programs that exercise rel-
evant parts of the framework, and a summary of the frame-
work API to be modeled. For scalability of the synthesis
problem, Pasket is designed to be used with tutorial pro-
grams that each exercises a small part of the framework,
andPasket then combines the information from each tu-
2016 IEEE/ACM 38th IEEE International Conference on Software Engineering
   156
PASKET
FrameworkTutorialAPI
LoggerEncoder
SynthesizerFramework
ModelDesign
Patterns
LogsSynthesis
ProblemFigure 1: Pasket architecture.
torial into a full model. In the case of Swing, for example,
Oracle provides tutorials for buttons, checkboxes, and simi-
lar components, which are ideal for this purpose [27].
The framework API information can be extracted from
the JAR or AAR les of the framework, although some user
input is needed to select the parts of the framework API that
should be modeled. This API provides the skeleton of the
expected model. Pasket's goal is to generate code for that
skeleton|insert the bodies of constructors and methods|
to yield a model that can be used to analyze the tutorial
programs and that, ideally, will also generalize to larger pro-
grams that use the same parts of the framework.
As a rst step in the model creation process, the logger
component inside Pasket executes the tutorial programs
(perhaps requiring user interaction with the tutorial) and
logs the method names, arguments, and return values that
cross the boundary between the tutorial code and the frame-
work. (Calls internal to the framework are omitted from
the log.) For instance, in the Swing button callback exam-
ple, the user would run the application and press the button
while the logger records the execution. The log would there-
fore capture the button creation, registration, and callback,
including the precise identities of the objects, so it captures
the fact that the registered object is the one being called
back when the button is clicked.
These captured logs serve as a partial specication for the
synthesis process. Specically, the synthesizer aims to pro-
duce a model that achieves log conformity with the original
program, meaning if the application were to run using the
model code in place of the framework code under the same
user inputs, we would observe the exact same sequence of
calls as in the original log. Section 3 explains this in detail.
To produce a model, the log conformity requirement must
be combined with a structural hypothesis to limit the space
of possible models. In Pasket, this structural hypothesis
comes from Pasket's internal knowledge of design patterns.
The idea is that by limiting the search to models that im-
plement design patterns we know to be used by the actual
framework, we increase the likelihood the synthesized model
will generalize and behave correctly with other applications.
Pasket currently supports four main design patterns: Ob-
server, Accessor, Adapter, and Singleton. Section 4 explains
how these patterns are instantiated to match the given API
and produce models satisfying log conformity.
Pasket uses the open-source Sketch synthesis system to
search for log-conforming instantiations of the design pat-
terns (hence the \sketcher" part of the name Pasket) [34].
Sketch's input is a sketch that describes a space of pro-
grams and a set of semantic constraints, usually given as
assertions the synthesized program must satisfy. Sketch
uses a symbolic search procedure to nd a program in that
space that satises the constraints. Section 5 discusses Pas-ket's Encoder component, which translates the client app,
logs, framework API, and design pattern information into a
sketch whose solution solves the Pasket synthesis problem.
The encoded synthesis problems are quite challenging due
the large number of possible design pattern instantiations as
well as the diculty of reasoning about dynamic dispatch.
Despite this, the problems are made tractable using recent
research on combining constraint-based synthesis with ex-
plicit search [19], together with a careful encoding that al-
lows the synthesizer to eciently rule out large numbers of
incorrect solutions.
Results. We used Pasket to produce a model of the Java
Swing GUI framework and the Android framework. For
Swing, we used 10 tutorial programs distributed by Oracle.
Synthesis took just a few minutes, and in the end produced
a model consisting of 95 dierent classes and 2,676 lines of
code, making it one of the largest pieces of code ever syn-
thesized using constraint-based synthesis. For Android, we
used 3 tutorial programs gathered from the web. Synthesis
took a few seconds and produced a model consisting of 50
dierent classes and 1,419 lines of code.
We validated the models in three ways. First, we ran the
Swing tutorials against the synthesized Swing model and
checked that they match the original logs. Second, we ran
the Swing tutorials under Java PathFinder [30] (JPF). We
found we could successfully execute eight of the ten tutorials
(two tutorials are not supported by JPF's event generating
system), while JPF's own model failed due to some miss-
ing methods. Finally, we selected eight code examples from
O'Reilly's Java Swing, 2nd Edition [23] that use the same
part of the framework and veried that they run under JPF
using our merged model. We also selected two Android code
examples and veried they run under SymDroid, a Davlik
bytecode symbolic executor [17], using our merged model.
(Section 7 describes our experiments.)
Contributions. In summary, this paper makes the following
contributions:
We introduce Pasket, a new tool that takes a rst step
toward automatically synthesizing framework models
sucient for symbolic execution.
We formulate the synthesis problem as design pattern
instantiation and show how to use the framework API
and log of framework/client calls to constrain the de-
sign pattern instantiation process. (Sections 3 and 4)
We show how to encode the synthesis problem as a
Sketch synthesis problem. (Sections 5 and 6)
We present experimental results showing Pasket can
synthesize a model of a subset of Swing and a subset of
Android, and that model is sucient to symbolically
execute a range of programs. (Section 7)
2. RUNNING EXAMPLE
As a running example, we show how Pasket synthesizes
a Java Swing framework model from the tutorial program
in Figure 2, which is a simplied extract from one of the
tutorials for Java Swing.
Here the main method (not shown) calls createAndShowGUI
(line 15), which instantiates a new window and adds a new
instance of ButtonDemo to it. The ButtonDemo constructor
1571class ButtonDemo implements ActionListener {
2 public ButtonDemo() {
3 b1 = new JButton("Disable middle button", ...);
4 b1.setActionCommand("disable");
5 b2 = new JButton("Middle button", ...); ...
6 b3 = new JButton("Enable middle button", ...); ...
7
8 b1.addActionListener(this ); b3.addActionListener(this );
9 add(b1); add(b2); add(b3);
10 }
11 public void actionPerformed(ActionEvent e) {
12 if("disable".equals(e.getActionCommand())) {
13 ...
14 } }
15 private static void createAndShowGUI() {
16 JFrame frame = new JFrame("ButtonDemo");
17 ButtonDemo newContentPane = new ButtonDemo(); ...
18 frame.setContentPane(newContentPane); ...
19} }
Figure 2: ButtonDemo source code (simplied).
(line 2) creates and initializes button objects b1through b3,
each of which are labeled (line 4). The code then registers
thisas an observer for clicks to b1and b3(line 8) and then
adds the buttons to the window. When either button is
clicked, Swing calls the actionPerformed method of the reg-
istered observer (line 11), whose behavior depends on the
label of the button that was clicked (line 12).
In addition to the tutorial, the second input to Pasket
is the framework API, consisting of classes, methods, and
types. The API is then completed by Pasket to produce a
complete model like the Swing model that is partially shown
in Figure 3. The black text in the gure corresponds to the
original API given as input; package names are omitted for
space reasons. The rest of the code (highlighted in blue) is
generated by Pasket given a log from a sample run of But-
tonDemo. For example, Pasket discovers that AbstractButton
is a subject in the observer pattern|thus it has a list olist
of observers, initialized in the constructor|and its attach
method is addActionListener. The handle and handle_1 methods
are introduced entirely by the synthesizer to model the way
in which the AbstractButton invokes the actionPerformed methods
in its registered listeners. In this model, the runtime posts
events into the EventQueue and dispatches them by calling
run. The model then propagates those events to any listeners
that have been registered with a button. Pasket also dis-
covers that EventObject, AWTEvent, and ActionEvent participate
in the accessor pattern, with a eld set via their constructor
and retrieved via getSource in the case of EventObject.
Notice that Pasket abstracts several constructors and
methods to have empty bodies, because this particular tu-
torial program does not rely on their functionality. For
example, the argument to the JButton constructor is never
retrieved. Thus, the tutorials control Pasket's level of ab-
straction. Unneeded framework features can be omitted so
they will not be synthesized, and framework features can be
added by introducing tutorials that exercise them.
3. LOGGING AND LOG CONFORMITY
As explained earlier, Pasket executes the tutorial pro-
gram to produce a log of the calls between an application
and the framework. Figure 4 shows a partial log from But-
tonDemo. Each log entry records a call or return. In the20class EventDispatchThread {
21 private EventQueue q;
22 void run() {
23 EventObject e;
24 while ((e = q.getNextEvent()) != null) q.dispatchEvent(e);
25 }... }
26class EventQueue {
27 private Queue<EventObject> q;
28 void postEvent(EventObject e) { q.add(e); }
29 void dispatchEvent(EventObject event) {
30 if (event instanceof ActionEvent) {
31 AbstractButton btn = (AbstractButton)event.getSource();
32 btn.handle((ActionEvent)event);
33 } ...
34 } ... }
35class AbstractButton extends JComponent {
36 private List<ActionListener> olist;
37 AbstractButton() { olist = new LinkedList<ActionListener>(); }
38 void addActionListener(ActionListener l) { olist.add(l);}
39 void setActionCommand(String actionCommand) { // empty}
40 void handle(ActionEvent event) { handle_1(event); }
41 void handle_1(ActionEvent event) {
42 int i=0; while(0<=i && i<olist.size && (o=olist.get(i) != null))
43 { l.actionPerformed(event); i=i+1;}
44 } ... }
45class JButton extends AbstractButton {
46 JButton(String text , Icon icon) { // empty } }
47class JFrame extends Frame { ... }
48class EventObject {
49 private Object source;
50 EventObject(Object source) { this.source = source;}
51 Object getSource() { return source;}
52}
53class AWTEvent extends EventObject { ... }
54class ActionEvent extends AWTEvent {
55 priavte String command;
56 ActionEvent(Object source, intid , String command) {
57 super(source, id); this.command = command;
58 }
59 String getActionCommand() { return command;}
60}
Figure 3: Framework API to be modeled (partial). High-
lighted code produced by synthesis.
gure, thisis the rst parameter to each call, and we use
indentation to indicate nested calls. Constructor calls and
object parameters are annotated with a Java object id. For
example, JButton@8 is a JButton with object id 8. Using ob-
ject ids provides us with a simple way to match the same
object across dierent calls. Thus, the log contains detailed
information about both the values that ow across the API
and the sequencing of calls and returns.
That detailed information is exactly what is needed to
suciently constrain the synthesis problem. For example,
line 66 has a call to addActionListener with arguments JBut-
ton@8 and ButtonDemo@9. Subsequently, on line 70 an Action-
Event associated with this button is created and immediately
posted into the EventQueue; after this, the runmethod in the
EventDispatchThread is called. The details of what happens
inside the framework after the call to runare ignored by the
logger because it does not involve methods in the given API.
The next log entry in line 73 corresponds to the framework's
call to the actionPerformed method in the application. It will
be up to Pasket to infer that this sequence of log entries is
15861ButtonDemo.main()
62 ButtonDemo.createAndShowGUI()
63 ButtonDemo.ButtonDemo@9()
64 JButton.setActionCommand(JButton@8, ‚Äò‚Äòdisable‚Äô‚Äô)
65 JButton.setEnabled(JButton@4, false)
66 JButton.addActionListener(JButton@8, ButtonDemo@9)
67 JButton.addActionListener(JButton@4, ButtonDemo@9)
68 JFrame.setContentPane(JFrame@8, ButtonDemo@9)
69...
70ActionEvent.ActionEvent@7(JButton@8, 0, "disable")
71EventQueue.postEvent(EventQueue@1, ActionEvent@7)
72EventDispatchThread.run(EventDispatchThread@0)
73 ButtonDemo.actionPerformed(ButtonDemo@9, ActionEvent@7)
74 ActionEvent.getActionCommand(ActionEvent@7)
75 return "disable"
76...
77ActionEvent.ActionEvent@5(JButton@4, 0, "enable")
78EventQueue.postEvent(EventQueue@1, ActionEvent@5)
79EventDispatchThread.run(EventDispatchThread@0)
80 ButtonDemo.actionPerformed(ButtonDemo@9, ActionEvent@5)
81 ActionEvent.getActionCommand(ActionEvent@5)
82 return "enable"
83...
Figure 4: Sample output log from ButtonDemo.
part of the observer design pattern. Pasket will then use its
knowledge of the pattern to infer the contents of postEvent,
run, and all the other functions that were invoked inside the
framework to eventually call actionPerformed.
As another example, line 74 shows getActionCommand re-
turning the string ‚Äúdisable‚Äù, which was set in the setter on
line 64. Thus, again given Pasket's library of design pat-
terns, these log elements must be part of an accessor pattern.
The log conformity constraint is that a correct framework
model, run against the same tutorial program under the
same inputs, should produce the same log as the actual
framework. In reactive frameworks such as Swing or An-
droid, however, events such as button clicks are relayed by
the runtime system to the framework, and the framework in-
teracts with the application in response to these events. For
such a reactive framework, these events are what constitute
the \inputs" to the framework/application pair, so to check
log conformity, the system needs to check that the combined
framework model and application react to these events in the
same way as the original framework and application did.
One subtle aspect of the log conformity constraint is that
the objects created when running against the real frame-
work will have dierent ids from those created when run-
ning against the model, so the log conformity check must
allow for the renaming of objects of the same type when
comparing the logs for the two executions.
In the next section, we discuss Pasket's design patterns,
and then in Section 5 we show how to combine the API,
logs, and design pattern knowledge to synthesize a frame-
work model using Sketch .
4. DESIGN PATTERN INSTANTIATION
Pasket synthesizes the code in Figure 3 by instantiat-
ingdesign patterns. To understand the synthesis process,
consider Figures 5 and 6, which show two of the four design
patterns supported by Pasket. The UML diagrams in these
gures have boxes for classes and interfaces, with elds at
the top and methods at the bottom, arrows for subclass orimplements relationships, and diamond edges for contain-
ment. Unless marked private, elds and methods are public.
The key novelty in these diagrams are design pattern vari-
ables , indicated in colored italics. These are unknowns that
Pasket solves to determine which classes and methods play
which roles in the patterns. For example, the observer pat-
tern in Figure 5 includes several dierent design pattern vari-
ables, including the names of the Subject and Observer classes,
the name of the IObserver interface, and the names of the at-
tachand detach methods. The main technical challenge for
Pasket is to match these pattern variables with class, inter-
face, and method names from the API description. In our
running example, Pasket determines there must be an ob-
server pattern instance with AbstractButton as the Subject and
addActionListener as the attach method. Thus to create the
framework model, Pasket instantiates the eld olistfrom
the pattern as a new eld of AbstractButton, and it instanti-
ates the body of the attach method into addActionListener. The
other roles are instantiated to other classes in the API.
In addition to design pattern variables, the design pattern
descriptions also leave certain implementation details to be
discovered by the synthesizer. For example, inside the handle
method, the synthesizer can decide what event types should
invoke which individual handlers, and in the handler handle_i,
the synthesizer is left to choose in what direction to iterate
over the observer list.
Pasket uses the same basic idea of design pattern in-
stantiation to create the entire framework model. We next
discuss the patterns currently supported by Pasket, and
then discuss the problem of synthesizing multiple patterns
simultaneously. We selected this set of patterns to support
the experiments in Section 7, but we have designed Pasket
to support extensibility with more patterns; if necessary, it
is even possible to create specialized patterns when we need
very platform-specic behavior.
Observers and Events. We have already discussed several
aspects of the observer pattern in Figure 5. The Subject
maintains a list of IObserver's, initialized in the constructor.
Observers can be attached or detatched to the list, and both
methods are optional, i.e., they may or may not be present.
Notice update_i has no code in the pattern, since the Observer
is part of the client rather than the framework. For example,
in Figure 2, the update_i method is actionPerformed.
We mark the methods handle and handle_i asauxiliary to in-
dicate they are not part of the original framework. The real
framework has some (possibly complicated) logic to deter-
mine how to call the update_i methods when the runmethod
of the EventDispatchThread is called, and the methods handle
and handle_i are our way of modeling this logic. Because we
do not need to match them with methods in the API, their
names are not pattern variables. This is why they were
added with these same names to AbstractButton in Figure 3,
where the synthesizer instantiated handle to just call handle_1
and handle_1 to iterate forward through olistwhile calling the
update method actionPerformed.
Accessors. Figure 6 shows the accessor pattern, used for
classes with getters and setters. The class has kelds f1
through fk. As in Java, each eld has a default value before
any initialization or update ( 0for int, falsefor boolean, and
nullfor all object elds). There are also rgetter methods
get_f1 through get_fr andsgetter methods set_f1 through
159void update_ i(Evt e);
/* i ‚àà 1.. k */Class ObserverSubject() {
  olist = new LinkedList<>();
}
optional void attach(IObserver obs) {
    olist.add(obs);}
optional void detach(IObserver obs) {
   olist.remove(obs);}
auxiliary
 void handle(Evt e) {
    if (e.getType() = ??) handle_1(e);
    ‚Ä¶
    if (e.getType() = ??) handle_k(e);
    else handle_k(e);
}
auxiliary void handle_i(Evt e) { /* i ‚àà 1.. k */
    int i = [[ 0‚îÇolist.size() - 1 ]] ;
    IObserver o;
    while (0 <= i && i < olist.size() 
            && (o = olist.get(i)) != null ) {
        o. update_ i(e);
        i = [[ i + 1‚îÇi - 1 ]];
}    }private List<IObserver> olist;Class Subject
void update_ i(Evt e  );
/* i ‚àà 1.. k */Interface IObserver
auxiliary  void dispatchEvent(IEvt e) {
    if (e instanceof Evt)
       ((Subject) e.getSource())
         .handle(e);}
void postEvent(IEvt e) {
    return q.add(e);}
auxiliary
 IEvt nextEvent() {
    return q.remove();
}private Queue<IEvt> q;Class EventQueue
Object getSource();
int getType();Interface IEvt
Subject getSource();
int getType();Class Evtvoid run() {
    IEvt e;
    while ((e = q.nextEvent()) != null) {
        q.dispatchEvent(e);
}  }private EventQueue q;Class EventDispatchThreadFigure 5: Observer pattern in Pasket.
Accessor(T1 o1, ‚Ä¶, Tj o j) {   /* j <= k */
  if ([[ true | false ]]) super( [[ o1 | ‚Ä¶ | oj ]]* );
  f1 = o1; ‚Ä¶ ; fj = oj;
  if ([[ true | false ]]) fj+1 = [[ new cls()‚îÇ?? ]];
  ‚Ä¶
  if ([[ true | false ]]) fk = [[ new cls()‚îÇ?? ]];
}
Ti get_f i(void) { return [[ f1 | ‚Ä¶ | fk ]]; } /* i ‚àà 1.. r, r <= k */
void set_fi(Ti v) { [[ f1 | ‚Ä¶ | fk ]] = v; }  /* i ‚àà 1.. s, s <= k */private Ti fi;   /* i ‚àà 1.. k */Class Accessor
Figure 6: Accessor pattern in Pasket.
set_fs. Each getter method get_fi retrieves the value of a
eld chosen from f1 through fk; similarly, each setter method
updates a eld chosen from f1 through fkwith the input v.
The Accessor class also has a single constructor that ac-
cepts jarguments, for some jk. The i-th argument is
used to initialize the i-th eld fi, respectively. This incurs no
loss of generality since Pasket can choose to enumerate the
elds in any order. For those elds beyond fj, i.e., elds fj+1
through fk,Pasket may opt to initialize some of them im-
plicitly with either a new instance of some class clsor some
constant value (indicated by a hole ??), depending on eld's
type. For the former case, we assume that the new instance
is constructed by a public, no-argument constructor cls().
Before these elds are initialized, the constructor may or
may not call the superclass constructor with a subset of
thejarguments, written [[ o1j: : :joj]]. For example, in
Figure 3 we see that ActionEvent's constructor passes only two
parameters to its superclass AWTEvent, which in turn passes
only one parameter to its superclass EventObject. Finally, the
constructor initializes the elds appropriately.
Other Patterns. Pasket also supports the singleton pat-
tern and the adapter pattern, which are not shown due to
lack of space. The singleton pattern supports classes that
have a single instance, such as system-level services. The
adapter pattern is used to delegate calls to another object,
e.g., in Swing, InvocationEvent is an adapter that dispatches
runcalls to a Runnable object stored in a eld. More details
about other patterns, along with UML diagrams, can be
found in [16].Multi-pattern Synthesis. In practice, frameworks may have
zero, one, or multiple instances of each pattern, and they
may use multiple patterns. Currently, the number of in-
stances of each pattern is a parameter to Pasket. In our
experiments, for each framework we x these numbers across
all tutorial programs, and then discard any unused pattern
instances, as discussed further in Section 6.
Since the same class might be involved in multiple pat-
terns, the design patterns in Figures 5 and 6 should be taken
as minimal specications of classes| Pasket always allows
classes to contain additional elds and methods than are
listed in a diagram. Those additional class members either
get their code from a dierent pattern (or dierent instance
of the same pattern), or are left with empty method bod-
ies (or return the default value of the return type). In our
running example, the AbstractButton class is involved in both
the observer pattern and the accessor pattern: its methods
addActionListener, removeActionListener and Ô¨ÅreActionPerformed in-
stantiate an observer pattern, and its methods getActionCom-
mand and setActionCommand instantiate an accessor pattern.
Currently Pasket requires that each method body be in-
stantiated from at most one pattern.
5. FRAMEWORK SKETCHING
Pasket usesSketch to discover how to instantiate the
design patterns from Section 4 into the method bodies in
Figure 3 to satisfy log conformity.
Background. The input to Sketch is a space of programs
in a C-like language. The space is represented as a pro-
gram with choices and assertions. The choices can include
unknown constants, written ??, as well as explicit choices
between alternative expressions, written [[e1j: : :jen]]. The
goal of Sketch is to nd a program in the space that satis-
es the assertions [35]. For example, given a program
void double(int x) {intt = [[ x | 0 ]]??;assert t = x + x; }
Sketch will choose 2for the constant ??and xfor the choice.
Full details about Sketch can be found elsewhere [34, 35].
The Encoder component in Pasket consumes the frame-
work API, the tutorial and the log, and produces a frame-
16087assert Subject6=Observer;
88
89assert subcls[Subject][belongsTo[attach]];
90assert subcls[Subject][belongsTo[detach]];
91assert argNum[attach] == 1;
92assert argNum[detach] == 1;
93assert argType[attach][0] == IObserver;
94assert argType[detach][0] == IObserver;
95assert retType[attach ][0] == VOID;
96assert retType[detach][0] == VOID;
97assert subcls[Observer][IObserver];
98
99assert attach6=detach;
Figure 7: Constraints on design pattern variables (partial).
work sketch , which is a Sketch input le. The framework
sketch is comprised of four main pieces: (1) the tutorial code,
(2) driver code to invoke the framework/tutorial with the se-
quence of events captured in the log, (3) the framework API
lled in with all possible design pattern implementations
guarded by unknowns that allow the synthesizer to choose
which roles of which patterns to use in each method, and
(4) additional code to assert log conformity and other con-
straints, e.g., from subtyping relationships. When Sketch
nds a solution, it will thereby discover the implementations
of framework methods such that when the framework is run
in combination with the app, log conformity will be satised.
From Java to Sketch. The rst issue we face in building
the framework sketch is that it must include Java code, e.g.,
for the client app and framework method implementations.
However, Sketch 's language is not object-oriented. To solve
this problem, Pasket follows the approach of JSketch [20],
a tool that adds a Java front-end to Sketch . We currently
do not use JSketch directly, for two reasons. First, for
log conformity, we need to retrieve runtime instances, which
requires modifying an object allocation function. Second,
to check log conformity only for calls that cross the bound-
ary between the framework and the client app, we need to
slightly modify method signatures and call sites to include
a framework/client ag.
LikeJSketch , we introduce a new type V_Object, dened
as a struct containing all possible elds plus an integer identi-
er for the class. More precisely, if C1; : : : ; C mare all classes
in the program, then we dene:
84struct V_Object {
85 intclass_id; elds-from- C1...elds-from- Cm
86}
where each Cigets its own unique id.
Pasket also assigns every method a unique id, and it cre-
ates various constant arrays that record type information.
For a method id m, we set belongsTo[m] to be its class id;
argNum[m] to be its number of arguments; and argType[m][i]
to be the type of its i-th argument. We model the inher-
itance hierarchy using a two-dimensional array subcls such
that subcls[i][j] is true if class iis a subclass of class j.
Using this encoding, we can translate the client app di-
rectly into the framework sketch.
Driving Execution. The next piece of the framework sketch
is a driver that launches the client app and injects events
according to the log. More specically, looking at Figure 4,102void addActionListener(V_Object self, V_Object l) {
103 /addActionListener has id 19 /
104 int[] params = { 19, self .obj_id, l .obj_id };
105 check_log(params);
106 /Check that "params" is the next log entry /
107 /and advance the log counter by one /
108 if(attach == 19) { /code for attach/}
109 else if (detach == 19) { /code for detach/}
110 else if ...
111 int[] ret = { 19 }
112 check_log(ret);
113}
Figure 8: Framework sketch (partial).
we see three items that come from \outside" both the client
app and the framework: the initial call to main(line 61) and
the user inputs on lines 70 and 77. The driver is responsi-
ble for triggering these events, which it does by calling the
appropriate (hard-coded) method names in Figure 5 for the
event queue (or the appropriate names for Android if apply-
ingPasket to that domain).
Design Pattern Implementations. The next component
of the framework sketch is the framework API itself, with
code for the design patterns, checks of log conformity, and
constraints on design pattern instantiation.
For each possible pattern instantiation, and each possi-
ble design pattern variable, we introduce a corresponding
variable in the framework sketch, initialized with a gener-
ator. For example, to encode the observer pattern, every
role name (in italics in Figure 5) will be a variable in the
framework sketch:
100intSubject = [[ 1 | 2 | ... ]]; intObserver = [[ 1 | 2 | ... ]];
101intattach = [[ 18 | 19 | ... ]]; intdetach = [[ 18 | 19 | ... ]; ...
Here each design pattern variable's generator lists the pos-
sible class or method ids that could instantiate those roles.
(If there were multiple occurrences of the observer pattern,
there would be multiple variables attach1, attach2, etc.)
Next, Pasket generates a series of assertions that con-
strain the design pattern variables according to the structure
of the pattern. Figure 7 shows some of the constraints for
the observer pattern. The rst line requires that two dier-
ent classes are chosen as Subject and Observer. The next lines
check that the attach and detach methods are members of or
inherited by the Subject, and that those methods have the
same signature|taking a single argument of an appropriate
type (a superclass of Observer) and returning void. Finally,
it checks that distinct roles (e.g., attach and detach) in the
design pattern are instantiated with dierent methods.
Finally, for each API method, we add a corresponding
function to the framework sketch that checks log confor-
mity at entrance and exit of the method, and in between
conditionally dispatches to every possible method of every
possible design pattern.
For example, Figure 8 depicts the framework sketch code
corresponding to addActionListener (Figure 3). The rst state-
ment (line 104) creates a call descriptor that includes the
method's id and the object ids of the parameters. This call
descriptor is passed to check_log (on line 105), which asserts
it matches the next entry in the global log array (created in
the driver) and advances the global log counter. Next the
code dispatches to various design pattern method implemen-
161tations based on the role chosen for this method. Finally,
the code checks that the return (indicated by negating the
method id) matches the log; here the method returns void.
(Note that void returns are included in the actual log though
we omitted them from Figure 4.)
Putting this all together, the check_log assertions will only
allow this method to be called at appropriate points in the
trace, specically lines 66 and 67 of Figure 4. Sketch will
determine that attach is19, hence the attach method code
will be called in the function body.
Model Generation. After Sketch has found a solution,
the last step is to generate the framework model. Pasket
usesSketch 's solution for each variable ( attach, detach, etc.)
to emit the appropriate implementation of each method in
the model. For example, since we discover that addAction-
Listener is the attach method of the observer pattern, we will
emit its body as shown in Figure 3, along with the other
methods and elds involved in the same pattern.
In some cases, methods in the framework API will be left
unconstrained by the tutorial program. In these cases, Pas-
keteither leaves the method body empty if it returns void,
or adds a return statement with default values, such as 0,
false, or null, according to the method's return type.
6. IMPLEMENTATION
We implemented Pasket1as a series of Python scripts
that invoke Sketch as a subroutine. Pasket comprises
roughly 14K lines of code, excluding the Java parser.
We specify name and type information for the framework
via a set of Java les containing declarations of the pub-
lic classes and methods of the framework, with no method
bodies. Pasket parses these les using the Python front-
end of ANTLR v3.1.3 [28] and its standard Java grammar.
After solving the synthesis problem, Pasket then unparses
these same Java les, but with method bodies and private
elds instantiated according to the synthesis results. We use
partial parsing [10] to make this output process simpler.
There are several additional implementation details.
Logging. For Swing tutorials, Pasket gathers logs via a
logger agent , which is implemented with the Java Instru-
mentation API [2] using javassist [8]. This allows Pasket
to add logging statements to the entry and exit of every
method at class loading time. Pasket also inserts logging
statements before and after framework method invocations.
In this way, it captures call{return sequences from the frame-
work to clients, and vice versa. Altogether, the logger agent
is approximately 368 lines of Java code.
For Android tutorials, Pasket uses Redexer [18], a gen-
eral purpose binary rewriting tool for Android, to instru-
ment the tutorial bytecode. Similarly to our approach for
Swing, we use Redexer to add logging at the entry and exit
of every method in the app, and also insert logging state-
ments before and after framework method invocations. The
logging statements emit specially tagged messages, and we
read the log over the Android Debugging Bridge ( adb).
Java Libraries. Recall that several of our design patterns
use classes and interfaces from the Java standard library,
typically for collections such as List. Client applications also
1https://github.com/plum-umd/pasketuse the standard library. Thus, as part of our translation
from Java to Sketch , we provide Sketch implementations
of standard library methods used in our experiments.
Android Layouts. Android apps typically include XML lay-
out les that specify what controls (called views in Android)
are on the screen. In addition to the class of each control
and its ID, the layout may specify the initial state of a con-
trol, such as whether a checkbox is checked, or in some cases
an event handler for the control. Since layout information
is needed to analyze an app's behavior, we manually trans-
late the layout les for each tutorial and subject app into
equivalent Java code. The translated layout les instantiate
each view in the layout le, set properties as specied in the
XML, and add it to the Activity's view hierarchy.
Multi-pattern Synthesis. Recall from Section 4 that we
need to synthesize models with multiple design patterns at
once; thus Pasket needs to know how many possible in-
stances of each pattern are needed. For Swing, we choose
5 observer patterns, 9 accessor patterns, 1 adapter pattern,
and 1 singleton pattern per tutorial program, and for An-
droid, we choose 1 observer pattern, 10 accessor patterns,
and 5 singleton patterns per tutorial program. These counts
are sucient for the tutorial programs in our experiments.
Most of the time, not all pattern instances will actually be
needed. If this is the case, the input we pass to Sketch will
underconstrain the synthesis problem, allowing Sketch to
choose arbitrary values for holes in unused pattern instances.
In turn this would produce a framework model that is correct
for that particular tutorial program, but may not work for
other programs. Thus, Pasket includes an extra pass to
identify and discard unused pattern instances.
Merging Multiple Models. As described so far, Pasket
processes a single tutorial program to produce a model of
the framework. In practice, however, we expect to have
many dierent tutorials that illustrate dierent parts of the
framework. Thus, to make our approach scalable, we need
tomerge the models produced from dierent tutorials.
Our merging procedure iterates through the solutions for
each tutorial program, accumulating a model as it goes along
by merging the current accumulated model with the next
tutorial's results. At each step, for each design pattern, we
need to consider only three cases: either the pattern covers
classes and methods only in the accumulated model; only
in the new results for the tutorial program; or in both. In
the rst case, there is nothing to do. In the second case, we
add the new pattern information to the accumulated model,
since it covers a new part of the framework. In the last
case, we check that both models assign the same classes or
methods to design pattern variables, i.e., that the results
for those classes and methods are consistent across tutorial
programs. (Note for this check to work, we must ensure class
and method ids are consistent across runs of Pasket.)
7. EXPERIMENTS
We evaluated Pasket by using it to separately synthesize
a Swing framework model and an Android framework model
from tutorial programs. Table 1 summarizes the results,
which we discuss in detail next.
162Tutorial Sketch w/AC Patterns Java
Name LoC Log LoC Std(s) jjTm(s) Tot(s) O Ac Ad S LoC C M ;S
wingButtonDemo 150 90 8,785 64 358 8 60 1 4 1 1 2,636 95 296 30
CheckBoxDemo 235 90 8,758 139 375 9 65 1 3 1 1 2,636 95 296 30
ColorChooserDemo 116 40 8,466 15 336 5 56 1 3 1 1 2,626 95 296 30
ComboBoxDemo 147 38 8,540 16 256 4 42 1 3 1 1 2,629 95 296 30
CustomIconDemo 233 82 8,837 69 449 9 80 1 4 1 1 2,636 95 296 30
FileChooserDemo 183 58 8,706 33 380 11 69 1 4 1 1 2,633 95 296 30
MenuDemo 276 150 9,481 764 488 67 190 2 5 1 1 2,643 95 296 30
SplitPaneDividerDemo 134 46 8,699 236 428 8 67 1 3 1 1 2,627 95 296 30
TextFieldDemo 244 40 8,728 OOM 400 39 104 3 5 1 1 2,656 95 297 30
ToolBarDemo 199 78 8,751 135 428 13 72 1 4 1 1 2,645 95 296 30
Model (merging) 14 5 9 1 1 2,676 95 297 30An
droidUIButton 50 46 5,258 8 113 1 16 1 10 0 5 1,412 50 169 10
UICheckBox 96 82 5,455 25 209 7 33 1 10 0 5 1,419 50 169 10
Telephony 86 54 5,131 6 30 1 11 0 9 0 5 1,412 50 169 10
Model (merging) 1 1 10 0 5 1,419 50 169 10
Table 1: Pasket results. LoC stands for lines of code; Log indicates number of log entries; Std(s) is the median running time
under the standard version of Sketch ;jjshows the median number of parallel processes forked to nd a solution; Tm(s)
is the median running time of a single process that found a solution; Tot(s) is the median total running time; O(bserver),
Ac(cessor), Ad(apter), and S(ingleton) are the number of instantiations of each design pattern; C and M are the number of
synthesized classes and methods; and ;is the number of empty methods.
Synthesis Inputs. To synthesize the Swing model, we used
ten tutorial programs distributed by Oracle. The names of
the tutorials are listed on the left of Swing group in Ta-
ble 1, along with their sizes. In total, the tutorials comprise
just over 1,900 lines of code. The tutorial names are self
explanatory, e.g., CheckBoxDemo illustrates JCheckBox's be-
havior. The last row of the Swing section reports statistics
for the merged model.
We ran each tutorial manually to generate the logs. For
instance, for the ButtonDemo code from Figure 2, we clicked
the left-most button and then the right-most button; only
one is enabled at a time. It was very easy to exercise all fea-
tures of these small, simple programs. The third column in
the table lists the sizes of the resulting logs. We also created
Java les containing the subset of the API syntactically used
by these programs. It contains 95 classes, 263 methods, and
92 ( Ô¨Ånalconstant) elds.
To synthesize an Android model, we used three tutorial
apps, listed in the Android group of Table 1. Two of them,
UIButton and UICheckBox, were examples in a 2014 Cours-
era class on Android programming. The third tutorial app,
Telephony, is from an online tutorial site.2Table 1 gives
the size of each tutorial after translating the layout les
into Java, as described above. We treated the tutorial apps
similarly to the Swing programs: we ran the Android apps
manually to generate logs, and we created a subset API con-
taining the 50 classes, 153 methods, and 36 ( Ô¨Ånalconstant)
elds referred to by these programs.
Synthesis Time. Given the logs and API information, we
then ran Pasket to synthesize a model from each tutorial
program individually. The middle set of columns in the table
summarizes the results. Performance reports are based on
seven runs of the synthesis process on a server equipped
with forty 2.4 GHz Intel Xeon processors and 99 GB RAM,
running Ubuntu 14.04.3 LTS.
The column Sketch LoC lists the lines of code of the
framework sketch les. We should emphasize that this is a
very challenging synthesis problem, and these sketches are
much larger than Sketch has typically been used for, both
2http://www.javatpoint.com/android-telephony-manager-tutorialin terms of lines of code and search space. For example,
based on the combinatorics of the classes and methods avail-
able to ll the roles, the search space for the Swing frame-
work is at least size 952126347. In fact, one of the sketches
is so hard to solve that Sketch runs out of memory.
To address this problem, we adopted Adaptive Concretiza-
tion (AC) [19], an extension to Sketch that adaptively com-
bines brute force and symbolic search to yield a paralleliz-
able, and much more scalable, synthesis algorithm. The
remaining columns under Sketch in the table report the
results of running both with and without AC. The Std col-
umn lists the median running time under Sketch without
AC. Thejjcolumn lists the median number of parallel pro-
cesses forked and executed before a solution is found under
AC. The next column reports the median running time of
a single trial that found a solution. The last column lists
the median total running time under AC. We can see that
overall, synthesis just takes a few minutes, and AC tends to
reduce the running time, sometimes quite signicantly for
larger programs.
The bottom row of each section of the table lists the time
to merge the individual models together, which is trivial
compared to the synthesis time.
Synthesis Results. The next group of columns summarizes
how many instantiations of each design pattern (O for ob-
server, Ac for accessor, Ad for adapter, and S for singleton)
were found during synthesis. The last four columns report
the lines of code and the number of classes, methods, and
empty methods (i.e., those that are essentially abstracted
away) in the synthesized model.
In Swing, most tutorials handle only one kind of event
and one event type, and hence have a single instance of the
observer pattern. Looking at the bottom row of the table,
we can see there is a lot of overlap between the dierent
tutorial programs|in the end, the merged model has ve
observer pattern instances.
In terms of the accessor pattern, again there is a lot of
overlap between dierent tutorials, resulting in nine total
pattern instances in the merged model. Finally, all tutorials
have exactly one instance of the adapter pattern for Invoca-
tionEvent and one instance of the singleton pattern for Toolkit,
163Name LoC Tutorials
ToolbarFrame2 76 ToolBarDemo
ToolbarFrame3 156 ToolBarDemo
+CustomIconDemo
JButtonEvents 40 ButtonDemo
+CheckBoxDemo
JToggleButtonEvents 43 ButtonDemo
+CheckBoxDemo
SimpleSplitPane 45 SplitPaneDividerDemo
+FileChooserDemo
ColorPicker 35 ColorChooserDemo
+ButtonDemo
ColorPicker3 72 ColorChooserDemo
+ButtonDemo
SimpleFileChooser 94 FileChooserDemo
Table 2: Examples from O'Reilly's Java Swing, 2nd Edition.
which are part of the Swing event-handling framework.
We manually inspected the set of empty methods in the
merged model, and found that most of these methods inu-
ence how things are displayed on screen. E.g., Window.pack()
resizes a window to t its contents, and Component.setVisible()
shows or hides a window. Thus, while these methods are
important in an actual running Swing program, they can be
left abstract in terms of control ow.
We also found some (5 of the 30 empty methods) cases
of setter-like methods that were called in a tutorial, but the
set value was never retrieved, hence it did not aect log
conformity. Thus, for this set of tutorial programs these are
safe to abstract, while another set of tutorial programs might
cause these to be matched against the accessor pattern.
In general, synthesis results in Android are similar to those
in Swing. Most tutorials in Android also handle only one
kind of event and one event type, resulting in a single in-
stance of the observer pattern. Similarly, for the observer
pattern and the accessor pattern, there is a lot of overlap
between dierent tutorials.
One noticeable dierence between Swing and Android is
the number of instances of the singleton pattern. In An-
droid, many system-level services are running in background
and providing useful features to applications. For easier
maintainance, those system-level services are usually imple-
mented as singletons.
Correctness. To check the correctness of the merged Swing
model, we developed a sanity checker that veries that a
tutorial program produces the same logs when run against
the merged model as when run against Swing. Recall that
the logs include the events, i.e., the user interactions, that
produced the original logs used for synthesis. Thus, we de-
veloped a script to translate the logged events into a main()
method containing a sequence of Java method calls simulat-
ing reception of those events. Then we replay the tutorial
under the model by running this main() method with the tu-
torial and model code, recording the calls and returns in the
execution. We then compare against the original log. Using
this approach, we successfully veried log conformity for all
ten tutorial programs.
To check the correctness of the merged Android model,
we ran the tutorial apps under the SymDroid [17] symbolic
executor. Since the Android model is much smaller than
that of Swing, we manually examined SymDroid's outputs
to verify the correctness of the model: we ran SymDroid
and recorded its detailed execution steps; checked branching
points of interest, while walking through those symbolic ex-Name LoC Tutorials
Visibility 114 UIButton +UICheckBox
‚ÄúBump‚Äù 50 UIButton +UICheckBox +Telephony
Table 3: Example apps for Android.
ecution traces; and double-checked that expected branches
were taken and that expected assertions passed accordingly.
Java PathFinder‚Äôs Model. Next, we compared our syn-
thesized Swing model to an existing, manually created model:
the Swing model [24] that ships as part of Java PathFinder [30]
(JPF). We ran JPF, under both models, on eight of the ten
tutorials. We omitted two tutorials, ColorChooserDemo and
FileChooserDemo, since those cannot easily be run under JPF
due to limitations in JPF's Swing event generator. Note
that there are no symbolic variables in this use of JPF, i.e.,
we explore only the path taken to create the original log.
Surprisingly, we found that, run with JPF's own model,
JPF failed on all tutorial programs, for a fairly trivial reason:
Some method with uninteresting behavior (i.e., that our syn-
thesis process left empty) was missing. In contrast, all eight
tutorials run successfully under JPF using Pasket's merged
model. This shows one benet of Pasket's approach: By us-
ing automation, Pasket avoids simple but nonetheless frus-
trating problems like forgetting to implement a method.
Applicability to Other Programs. Finally, we ran sym-
bolic execution on several other programs under each model,
to demonstrate that a model derived from one set of pro-
grams can apply to other programs.
We chose eight Java Swing code examples from O'Reilly's
Java Swing, 2nd Edition [23] that use the same part of the
framework as the Oracle tutorials we used. Table 2 lists the
eight examples, along with their sizes. All ran successfully
using JPF under our merged model. The rightmost column
lists which Oracle tutorials are needed to cover the frame-
work functionality used by the O'Reilly example programs.
Interestingly, we found that in addition to the \obvious" Or-
acle tutorial (based on just the name), often the O'Reilly
example programs also needed another tutorial. For exam-
ple, ToolbarFrame3 needed functionality from both ToolBarDemo
(the obvious correspondence) and CustomIconDemo.
We also ran two apps under the synthesized model of An-
droid; they are listed in Table 3. Visibility is an activity ex-
tracted from the API Demos app in the Android SDK exam-
ples.3\Bump" is an app (created for an earlier project [25])
that looks up a phone number and/or device ID from the
TelephonyManager, depending on the state of two check boxes.
We manually translated the layout les to Java for these two
apps, as we did for the tutorial apps. As with the O'Reilly
examples, these apps needed framework functionality from
multiple tutorials.
In our earlier project [25], we introduced interaction-based
declassication policies along with a policy checker based on
symbolic executions. Using the model generated by Pas-
ket, we conducted similar experiments. We ran the policy
checker against the original, secure version of the Bump app,
and found the checker yielded the correct results with the
synthesized framework model. For the Visibility app, we
conducted the same correctness check as the other tutorial
apps: we ran the app under SymDroid, and double-checked
3http://developer.android.com/sdk/installing/adding-packages.html
164that the simulated events of user clicks were properly propa-
gated to the app's event handlers via our synthesized frame-
work model.
8. RELATED WORK
Modeling. As mentioned earlier, symbolic execution tools
for framework-based applications usually rely on manually
crafted framework models. For example, as discussed ear-
lier JPF-AWT [24] models the Java AWT/Swing framework.
The model is tightly tied to the JPF-AWT tool and cannot
easily be used by other analysis tools. Moreover, as we saw
in Section 7, the model is missing several methods.
There are some studies that attempted to automatically
create models of Swing [7] and Android [40] for JPF. The
techniques from these papers are quite dierent as they rely
primarily on slicing. One advantage of Pasket is that it
could generate more concise models for complex frameworks
because it is unconstrained by the original implementation's
structure. Nonetheless, the techniques used in those papers
could help identify which parts of the framework to model.
Several researchers have developed tools that generate
Android models. EdgeMiner [6] ran backward data-ow
analysis over the Android source code to nd implicit ows.
Modelgen [9] infers a model in terms of information ows,
to support taint analysis. To learn behaviors of the tar-
get framework, it inputs concrete executions generated by
Droidrecord, similarly to our logging using Redexer [18].
Both of these systems target information ow, which is in-
sucient to support symbolic execution.
Given an app, Droidel [4] generates a per-app driver that
simulates the Android lifecycle. This enables some program
analysis of the app without requiring analysis of the Android
framework, which uses reection to implement the lifecycle.
A key limitation of Droidel is that it is customized to the
lifecycle and to a particular Android version.
Mimic [15] aims to synthesize models that perform the
same computations as opaque or obfuscated Javascript code.
Mimic uses random search inspired by machine learning tech-
niques. Mimic focuses on relatively small but potentially
complex code snippets, whereas Pasket synthesizes large
amounts of code based on design patterns.
Samimi et al. [31] propose automatically generating mock
objects for unit tests, using manually written pre- and post-
conditions. This is also quite dierent from Pasket, which
synthesizes a model using knowledge of design patterns.
Synthesis. There is a rich literature on algorithmic program
synthesis since the pioneering work by Pnueli and Rosner
[29], which synthesizes reactive nite-state programs. Most
of these synthesizers aim to produce low-level programs,
e.g., synthesis techniques that are also sketch-based [36, 37,
38]. The idea of encoding a richer type system as a single
struct type with a type id was also used in the Autograder
work [33]. Component-based synthesis techniques [14, 22]
aim at higher-level synthesis and generate desired programs
from composing library components. Our approach is novel
in both its target (abstract models for programming frame-
works) and its specication (logs of the interaction between
the client and the framework, and an annotated API).
The idea of synthesizing programs based on I/O sam-
ples has been studied for dierent applications. Godefroidand Taly [13] propose a synthesis algorithm that can e-
ciently produce bit-vector circuits for processor instructions,
based on smart sampling. Storyboard [32] is a program-
ming platform that can synthesize low-level data-structure-
manipulating programs from user-provided abstract I/O ex-
amples. Transit [39], a tool to specify distributed proto-
cols, inputs user-given scenarios as concolic snippets, which
correspond to call-return sequences Pasket logs. In our
approach, the synthesis goal is also specied in terms of in-
put (event sequences) and output (log traces), and our case
studies show that the I/O samples can also help synthesize
complex frameworks that use design patterns.
Design Patterns. In their original form, design patterns [12]
are general \solutions" to common problems in software de-
sign, rather than complete code. That is, there is exibility
in how developers go from the design pattern to the details.
Several studies formalize design patterns, detect uses of de-
sign patterns, and generate code using design patterns.
Mikkonen [26] formalizes the temporal behavior of design
patterns. The formalism models how participants in each
pattern (e.g., observer and subject) are associated (e.g., attach),
how they communicate to preserve data consistency (e.g.,
update), etc. Mikkonen's formalism omits structural concerns
such as what classes or methods appear in.
Albin-amiot et al. [1] propose a declarative meta-model of
design patterns and use it to detect design patterns in user
code. They also use their meta-model to mechanically pro-
duce code. Jeon et al. [21] propose design pattern inference
rules to identify proper spots to conduct refactoring. These
approaches capture structural properties, but omit tempo-
ral behaviors, such as which observers should be invoked for
a given an event. In contrast, Pasket accounts for both
structural properties and temporal behaviors. We leverage
design patterns as structural constraints and logs from tu-
torial programs as behavioral constraints for synthesis.
Antkiewicz et al. [3] aim to check whether client code
conforms to high-level framework concepts. They extract
framework-specic models, which indicate which expected
code patterns are actually implemented in client code. This
is quite dierent from the symbolically executable frame-
work model synthesized by Pasket.
9. CONCLUSION
We presented Pasket, the rst tool to automatically de-
rive symbolically executable Java framework models. Pas-
ket consumes the framework API and logs from tutorial
program executions. Using these, it instantiates the ob-
server, accessor, singleton, and adapter patterns to construct
a framework model that satises log conformity. Internally,
Pasket usesSketch to perform synthesis, and it merges
together models from multiple tutorial programs to produce
a unied model. We used Pasket to synthesize a model of a
subset of Swing used by ten tutorial programs, and a subset
of Android used by three tutorial programs. We found that
synthesis completed in a reasonable amount of time; the re-
sulting models passed log conformity checks for all tutorials;
and the models were sucient to execute the tutorial pro-
grams and other code examples that use the same portion
of the frameworks. We believe Pasket makes an important
step forward in automatically constructing symbolically ex-
ecutable Java framework models.
165Acknowledgments
Supported in part by NSF CCF-1139021, CCF-1139056, CCF-
1161775, and the partnership between UMIACS and the
Laboratory for Telecommunication Sciences.
References
[1] H. Albin-amiot, Y. ga el Gu eh eneuc, and R. A. Kastler.
Meta-Modeling Design Patterns: Application to Pat-
tern Detection and Code Synthesis. In Workshop Au-
tomating OOSD Methods, pages 01{35, 2001.
[2] T. R. Andersen. Add Logging at Class Load Time,
Apr. 22 2008. https://today.java.net/article/2008/04/
22/add-logging-class-load-time-java-instrumentation.
[3] M. Antkiewicz, T. T. Bartolomei, and K. Czarnecki.
Automatic extraction of framework-specic models
from framework-based application code. In Proceedings
of the Twenty-second IEEE/ACM International Con-
ference on Automated Software Engineering, ASE '07,
pages 214{223, 2007.
[4] S. Blackshear, A. Gendreau, and B.-Y. E. Chang.
Droidel: A general approach to android framework
modeling. In SOAP, pages 19{25. ACM, 2015.
[5] C. Cadar, D. Dunbar, and D. R. Engler. KLEE: unas-
sisted and automatic generation of high-coverage tests
for complex systems programs. In OSDI , pages 209{
224, 2008.
[6] Y. Cao, Y. Fratantonio, A. Bianchi, M. Egele,
C. Kruegel, G. Vigna, and Y. Chen. Edgeminer: Au-
tomatically detecting implicit control ow transitions
through the android framework. In NDSS '15 , 2015.
[7] M. Ceccarello and O. Tkachuk. Automated generation
of model classes for java pathnder. SIGSOFT Softw.
Eng. Notes , 39(1):1{5, Feb. 2014.
[8] S. Chiba. Load-Time Structural Reection in Java. In
ECOOP, pages 313{336, 2000.
[9] L. Clapp, S. Anand, and A. Aiken. Modelgen: Mining
explicit information ow specications from concrete
executions. In ISSTA , pages 129{140. ACM, 2015.
[10] A. Demaille, R. Levillain, and B. Sigoure. TWEAST: A
Simple and Eective Technique to Implement Concrete-
syntax AST Rewriting Using Partial Parsing. In SAC,
pages 1924{1929, 2009.
[11] M. Fowler. InversionOfControl, June 2005. http:
//martinfowler.com/bliki/InversionOfControl.html.
[12] E. Gamma, R. Helm, R. Johnson, and J. Vlissides. De-
sign Patterns: Elements of Reusable Object-Oriented
Software. Addison-Wesley Professional, 1994.
[13] P. Godefroid and A. Taly. Automated Synthesis of
Symbolic Instruction Encodings from I/O Samples. In
PLDI , pages 441{452, 2012.
[14] S. Gulwani, S. Jha, A. Tiwari, and R. Venkatesan. Syn-
thesis of Loop-free Programs. In PLDI , pages 62{73,
2011.[15] S. Heule, M. Sridharan, and S. Chandra. Mimic: Com-
puting models for opaque code. In European Software
Engineering Conference and Foundations of Software
Engineering (ESEC/FSE) , pages 710{720. ACM, Sep
2015.
[16] J. Jeon. Framework Synthesis for Symbolic Execution
of Event-Driven Frameworks . PhD thesis, University of
Maryland, College Park, Feb 2016.
[17] J. Jeon, K. K. Micinski, and J. S. Foster. SymDroid:
Symbolic Execution for Dalvik Bytecode. Technical Re-
port CS-TR-5022, Department of Computer Science,
University of Maryland, College Park, Jul 2012.
[18] J. Jeon, K. K. Micinski, J. A. Vaughan, A. Fogel,
N. Reddy, J. S. Foster, and T. Millstein. Dr. Android
and Mr. Hide: Fine-grained Permissions in Android Ap-
plications. In ACM CCS Workshop on Security and
Privacy in Smartphones and Mobile Devices (SPSM) ,
pages 3{14, Oct 2012.
[19] J. Jeon, X. Qiu, A. Solar-Lezama, and J. S. Foster.
Adaptive Concretization for Parallel Program Synthe-
sis. In Computer Aided Verication (CAV) , volume
9207 of Lecture Notes in Computer Science, pages 377{
394, Jul 2015.
[20] J. Jeon, X. Qiu, A. Solar-Lezama, and J. S. Foster.
JSketch : Sketching for Java. In European Software
Engineering Conference and Foundations of Software
Engineering (ESEC/FSE) , Sep 2015.
[21] S.-U. Jeon, J.-S. Lee, and D.-H. Bae. An automated
refactoring approach to design pattern-based program
transformations in Java programs. In Asia-Pacic Soft-
ware Engineering Conference , pages 337{345, 2002.
[22] S. Jha, S. Gulwani, S. A. Seshia, and A. Tiwari. Oracle-
guided component-based program synthesis. In ICSE,
pages 215{224, 2010.
[23] M. Loy, R. Eckstein, D. Wood, J. Elliott, and B. Cole.
Java swing, 2nd edition: Code examples, 2003. http:
//examples.oreilly.com/jswing2/code/.
[24] P. C. Mehlitz, O. Tkachuk, and M. Ujma. JPF-AWT:
Model checking GUI applications. In ASE, pages 584{
587, 2011.
[25] K. Micinski, J. Fetter-Degges, J. Jeon, J. S. Foster, and
M. R. Clarkson. Checking Interaction-Based Declassi-
cation Policies for Android Using Symbolic Execution.
InEuropean Symposium on Research in Computer Se-
curity (ESORICS) , Vienna, Austria, Sep 2015.
[26] T. Mikkonen. Formalizing Design Patterns. In ICSE,
pages 115{124, 1998.
[27] Oracle Corporation. Using swing components: Ex-
amples, 2015. https://docs.oracle.com/javase/tutorial/
uiswing/examples/components/.
[28] T. Parr and K. Fisher. LL(*): The Foundation of the
ANTLR Parser Generator. In PLDI , pages 425{436,
2011.
166[29] A. Pnueli and R. Rosner. On the Synthesis of an Asyn-
chronous Reactive Module. In ICALP , pages 652{671,
1989.
[30] N. Rungta, P. C. Mehlitz, and W. Visser.
JPF Tutorial, ASE 2013, 2013. URL http:
//babelsh.arc.nasa.gov/trac/jpf/raw-attachment/
wiki/presentations/start/ASE13-tutorial.pdf.
[31] H. Samimi, R. Hicks, A. Fogel, and T. Millstein. Declar-
ative mocking. In Proceedings of the 2013 International
Symposium on Software Testing and Analysis , ISSTA
2013, pages 246{256, 2013.
[32] R. Singh and A. Solar-Lezama. Synthesizing data struc-
ture manipulations from storyboards. In FSE, pages
289{299, 2011.
[33] R. Singh, S. Gulwani, and A. Solar-Lezama. Auto-
mated Feedback Generation for Introductory Program-
ming Assignments. In PLDI , pages 15{26, 2013.
[34] A. Solar-Lezama. Program sketching. International
Journal on Software Tools for Technology Transfer , 15
(5-6):475{495, 2013.[35] A. Solar-Lezama. The Sketch Programmers Manual ,
2015. Version 1.6.7.
[36] A. Solar-Lezama, R. Rabbah, R. Bod k, and
K. Ebcio glu. Programming by sketching for bit-
streaming programs. In PLDI , pages 281{294, 2005.
[37] A. Solar-Lezama, G. Arnold, L. Tancau, R. Bodik,
V. Saraswat, and S. Seshia. Sketching stencils. In PLDI ,
pages 167{178, 2007.
[38] A. Solar-Lezama, C. G. Jones, and R. Bodik. Sketching
concurrent data structures. In PLDI , pages 136{148,
2008.
[39] A. Udupa, A. Raghavan, J. V. Deshmukh, S. Mador-
Haim, M. M. Martin, and R. Alur. TRANSIT: Specify-
ing Protocols with Concolic Snippets. In PLDI , pages
287{296, 2013.
[40] H. van der Merwe, O. Tkachuk, B. van der Merwe, and
W. Visser. Generation of library models for verication
of android applications. SIGSOFT Softw. Eng. Notes ,
40(1):1{5, Feb. 2015.
167