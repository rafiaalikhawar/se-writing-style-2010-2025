Collective Program Analysis
Ganesha Upadhyaya
Dept. of Computer Science
Iowa State University
Ames, Iowa, USA
ganeshau@iastate.eduHridesh Rajan
Dept. of Computer Science
Iowa State University
Ames, Iowa, USA
hridesh@iastate.edu
ABSTRACT
Popularityofdata-drivensoftwareengineeringhasledtoanincreas-
ing demand on the infrastructures to support efficient execution of
tasksthatrequiredeepersourcecodeanalysis.Whiletaskoptimiza-
tionandparallelizationaretheadoptedsolutions,otherresearch
directions are less explored. We present collective program analysis
(CPA),atechniqueforscalinglargescalesourcecodeanalyses,es-
peciallythosethatmakeuseofcontrolanddataflowanalysis,by
leveraginganalysisspecificsimilarity.Analysisspecificsimilarity
is about, whether two or more programs can be considered similar
for a given analysis. The key idea of collective program analysis
is to cluster programs based on analysis specific similarity, suchthat running the analysis on one candidate in each cluster is suf-ficient to produce the result for others. For determining analysis
specific similarity and clustering analysis-equivalent programs, we
useasparserepresentationandacanonicallabelingscheme.Our
evaluation shows that for a variety of source code analyses on a
largedatasetofprograms,substantialreductionintheanalysistime
canbeachieved;onaveragea69%reductionwhencomparedtoa
baseline and on average a 36% reduction when compared to a priortechnique.Wealsofoundthatalargeamountofanalysis-equivalent
programs exists in large datasets.
CCS CONCEPTS
•Software and its engineering →Formal software verification ;
Software maintenance tools ;
KEYWORDS
Source code analysis, Clustering, Boa
ACM Reference Format:
Ganesha Upadhyaya and Hridesh Rajan. 2018. Collective Program Analysis.
InICSE’18: ICSE ’18:40th InternationalConference onSoftware Engineering
, May 27-June 3, 2018, Gothenburg, Sweden. ACM, New York, NY, USA,
12 pages. https://doi.org/10.1145/3180155.3180252
1 INTRODUCTION
Data-driven software engineering technique has gained popularity
insolvingvarietyofsoftwareengineering(SE)problems,suchas
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
©2018 Copyright held by the owner/author(s). Publication rights licensed to the
Association for Computing Machinery.
ACM ISBN 978-1-4503-5638-1/18/05...$15.00
https://doi.org/10.1145/3180155.3180252defect prediction [ 9], bug fix suggestions [ 20,21], programming
patterndiscovery[ 34,40],andspecificationinference[ 1,23,26,44].
The solutions to these SE problems generally require expensive
source code analyses, such as data-flow analysis. Parallelization
andtaskoptimizationsarethetwowidelyadoptedtechniquesto
scale source code analyses to large code bases [5, 11, 18].
We propose collective program analysis (CPA), a complementary
technique that leverages analysis specific similarity to scale source
code analysis to large code bases. The key idea of CPAis to cluster
programsbasedonanalysisspecificsimilarity,suchthatrunning
theanalysisononecandidateineachclusterissufficienttoproduce
theresultforothers.Forinstance,ifauserwantstorunananalysis
to check for null dereference bugs in millions of programs, CPA
would run the analysis on only the unique programs and reuse the
results on others.
Thethreecoreconceptsin CPAaretheconceptof analysisspe-
cificsimilarity,thetechniqueofabstractlyrepresentingprograms
torevealanalysisspecificsimilarity,andthetechniqueofstoring
andreusingtheanalysisresultsbetweensimilarprograms.Analysis
specific similarity (or analysis equivalence) is about, whether two
or more programs can be considered similar for a given analysis.Programs can be considered similar if they execute the same set
of instructions in the analysis. For instance, if an analysis is about
counting the number of assert statements, irrespective of how dif-
ferentthetwoprogramsare,iftheyhavethesamenumberofassert
statements,theycanbeconsideredsimilarforthepurposeofthe
assert counting analysis.
Codeclonesarethepopularwayofrepresentingsimilarcode[ 28].
Syntactic clones represent code fragments that are look alike (at
token-levelorAST-level),semanticclonesrepresentcodefragments
that have similar control and data flow, functional clones repre-
sent codefragments that havesimilar input andoutput behaviors,
and behavioral clones are the code fragments that perform similar
computation. We did not use syntactic clones, because the bene-
fitswillbelimitedtocopy-and-pastecode.Semanticclonescould
not be used, because of lack of guarantee that analysis output will
be similar. Moreover, semantically different code fragments mayproduce similar output for a given analysis and we would miss
out on those. For the same reason, we also could not use the func-tional andbehavioral clones. For thesereasons, we go beyondthe
existing notion ofsimilarity and define analysis specific similarity.
We show that for analysis expressed in the lattice-based data-flow
framework,wecanusethetransferfunctionstoidentifyanalysis
specific similarity.
Programs may have statements that are irrelevant for the given
analysis. These are the statements that do not contributes to theanalysis output. For identifying the analysis specific similarity itis necessary to remove the irrelevant statements and abstractly
6202018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Ganesha Upadhyaya and Hridesh Rajan
1public void writeObj(String filename) {
2try{
3 FileWriter file = newFileWriter(filename);
4 for(..)
5 file .write (...) ;
6 ...
7 file .close () ;
8} catch(IOException e) {
9 e.printStackTrace () ;
10 }
11}1public static void main(String[] args) {
2try{
3 ...
4 OutputStream out = newFileOutputStream("...
");
5 ...
6 out.close () ;
7} catch(Exception e) {
8 e.printStackTrace () ;
9}
10}1public void loadPropertyFile (String file ,...) {
2try{
3 try{
4 ...
5} catch(Exception e) {}
6
7 BufferedInputStream bis = newBuffered...
8 ...
9 bis.close () ;
10 } catch(Exception ex) {
11 throw new WrappedRuntimeException(ex);
12 }
13}
Figure1:Thethreemethodsextractedfromour SourceForge datasetthathavedifferentresourceusagepatterns,howeverthere
exists a similarity that all of them may lead to a resource leak.
represent the reduced program. We use a sparse representation to
remove the irrelevant statements without sacrificing the precision
of the result [ 38]. Comparing sparse representations to determine
analysis equivalence becomes a graph isomorphism problem for
data-flowanalysisthathavesparsecontrolflowgraphs.Weusea
canonicallabelingschemetomakethiscomparisonefficient[ 43].
Using the labeling scheme we can produce unique patterns to facil-
itatethe comparison.For reusingthe resultsbetween theanalysis
equivalent programs, we store the results in an efficient key-value
store based pattern database [25].
We evaluate our approach by measuring the reduction in the
analysistimefor10sourcecodeanalysistasksthatinvolvedata-flow
analysis. We use two large datasets of programs: a DaCapodataset
containingDaCapo9.12benchmarks[ 6]and287thousandmethods,
aSourceForge dataset containing 4,938 open-source SourceForge
projects and 6.8 million methods. When compared to a baseline
thatrunstheanalysisoneveryprograminthedataset, CPAreduces
theanalysistimeby69%onaverageandwhencomparedtoanother
technique that removes irrelevant program statements prior to
running the analysis, CPAreduces the analysis time by 36% on
average. Wealso seea largeamount ofreuseopportunities inour
datasets for almost all analyses.
2 MOTIVATING EXAMPLE
Consider a Resource Leak analysis that identifies possible resource
leaksintheprogramsbytrackingtheresourcesthatareacquired
and released throughout the program by performing a flow analy-
sis[37].Theanalysisreportsaproblemwhenanyacquiredresource
isnotreleasedoneverypathintheprogram.1Ifauserwantstorun
thisanalysisonalargecodebasethatcontainsmillionsofmethods,hewouldenduprunningtheanalysisoneverymethodinthecode
base. An optimization can be performed to skip analyzing meth-
odsthatdonotcontainresourcerelatedstatements,howeverthe
methods that have resource related statements must be analyzed.
To illustrate, consider the three methods writeObj ,main, and
loadPropertyFile extractedfromour SourceForge datasetshown
in Figure 1. These three methods differ by syntax, semantics, func-
tionality, and behaviorally, howeverfor the resource leak analysis
1Thereexistsafinitenumbersystemresources,suchasfiles,streams,sockets,database
connections,anduserprogramsthatacquireaninstanceofaresourcemustrelease
thatinstancebyexplicitlycallingthereleaseorclosemethod.Failuretoreleasethe
resource could lead to resource leak or unavailability.they all behave similar, because all of them acquire a resource and
release along one of the execution paths, leading to a resource leak
(In eventof exception,the resource is not released).Although the
three methods were similar for the resource leak analysis, all of
themwereanalyzedtoreportleak.Ifthereexistedatechniquethat
couldcapturethissimilarity,itcouldperformtheanalysisonany
one of these three methods and simply return truefor the other
two methods, indicating a resource leak.
When analyzing a small number of methods or a handful of
projects, there may not exist a lot of analysis specific similarity
between the source code elements, such as methods, however in
caseoflargecodebases,alargeamountofanalysisequivalentmeth-
ods exists. For instance, the resource usage pattern leading to a
leak shown in Figure 1 exists in 5151 methods in our SourceForge
dataset. This means that, we only need to run the resource leak
analysis on one method out of 5151 and reuse the result (in this
case whether a leak exists or not) for the remaining 5150 methods.
TheSourceForge datasetcontainsatotalof82,900methodsthat
have resource related code out of 6,741,465 methods in the dataset.
We were able to see 5689 unique patterns and the leak pattern dis-
cussedhereappearsinthetop3patterns.Likewise,whenanalyzing
large code bases, there exists a large amount of analysis equivalent
codes and a large percentage of reuse opportunity to utilize for
accelerating the overall analysis of large code bases.
3CPA: COLLECTIVE PROGRAM ANALYSIS
Figure 2 provides a high-level overview of collective program anal-
ysis( CPA).Givenasourcecodeanalysisthatneedstoberunona
largedataset ofprograms,we firstruna light-weightpre-analysis
oneachprogramthatidentifiesandremovesirrelevantpartsoftheprogram,andlabelstheremainingstatements(theanalysisrelevant
statements). This labeled compact program is called a sparse repre-
sentation.Wethengenerateapatternforthesparserepresentation
and check the pattern against a pattern database. If the patternis not found, the analysis is run on the sparse representation to
producetheresult,whereasifthepatternalreadyexists,thenthe
stored result is extracted and returned as the analysis output.
Whileoursolutionlooksintuitive,thereexistsseveralchallenges
in realizing CPA. For example, how to generate a sparse representa-
tiongivenananalysisandaprogram,howtogenerateapatternfor
621
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. Collective Program Analysis ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Figure 2: An overview of Collective Program Analysis (CPA)
sparserepresentationsuchthatanalysisequivalentsparserepresen-
tations can be identified, and how to utilize the sparse representa-
tion to reuse the analysis results. We will describe these challenges
andoursolutionsindetail.But,firstwedescribetheanalysismodel
under assumption.
3.1 The Analysis Model
A source code analysis can be performed either on the source code
text or on the intermediate representations like abstract syntaxtrees (ASTs), control flow graphs (CFGs), etc. A control and data
flowanalysisisperformedonaCFGandisoftenexpressedusing
the lattice-based data-flow framework [ 24]. In this framework, a
data-flowanalysisisdescribedbydefiningalattice,whichdescribesthesetofvaluestobeassociatedwithprogramstatements,andaset
oftransferfunctionsthatdescribeshoweachprogramstatement
transforms the input values to output values.2Two sets of data-
flow values are maintained at each node: INandOUTthat describes
theinputandoutputvaluesateachnode.Thedata-flowanalysis
solves a set of flow equations involving the two sets INandOUT,
and transfer functions. Based on the data-flow values computed at
the nodes, assertions can be made about the program behavior. For
example, the Resource Leak analysis described in the motivation
sectionmaintainsasetofvariablesrepresentingtheresourcesas
data-flowvaluesandithasmainlythreekindsoftransferfunctions
for handling resource acquire, resource release, and resource
copy/aliasing .3From hereon, whenever we refer to analysis, we
mean the data-flow analysis expressed in this framework.
Definition3.1. AControlFlowGraph ofaprogramisadirected
graphCFG=(N,E,n0,ne), with a set of nodes Nrepresenting
programstatementsandasetofedges Erepresentingthecontrol
2Amergeoperatorthatdescribeshowtwodata-flowvaluescanbecombined,apartial
orderthatdescribestherelationbetweenvalues,andtopandbottomvaluesarealso
provided. However, for describing CPA, transfer functions are sufficient.
3We ignore the method calls for simplifying the description, however in our imple-
mentation the method calls are over-approximated.flowbetweenstatements. n0andnedenotetheentryandexitnodes
of the CFG.4
3.2 Sparse Representation
Given an analysis anda large set of programs, we performa pre-analysis on each program to produce a sparse representation. A
sparse representation is a reduced program that contains only the
statements that are relevant for the analysis. Intuitively, a program
statementisrelevantforananalysis,ifitcontributestotheanalysisoutput(orgeneratessomeinformation).Withrespecttotheanalysis
model under consideration, the relevancy is defined as follows:
Definition 3.2. A program statement is relevant for an analysis,
ifthereexistsanon-identitytransferfunctionforthatstatementin
the analysis. That is, if the analysis has defined a transfer function
fk
iforstatement i,wherekrepresentsthetransferfunctionkind
andfk/nequalι, theniis relevant for the analysis. In the data-flow
analysismodeltherealwaysexistsanidentitytransferfunction ι
alongwiththeuserdefinedtransferfunctionstorepresentthose
statement that have no effect on the analysis output.
Definition3.3. Givenaprogram Pwithasetofstatements S,a
sparse representation is a tuple, <P/prime,M>, whereP/primecontains a
subset of the statements S/prime⊆S, such that∀i∈S/prime,iis a relevant
statement. M:S→fkis a map that provides the information
about the kind of the transfer function that is applicable to each
relevant statement iin setS/prime.
AsCPAtakes data-flow analysis and the control flow graphs
(CFGs)ofprograms,wehavetogeneratethesparserepresentations
of CFGs. For this purpose, we utilize a prior work that proposes
reducedcontrolflowgraphs(RCFGs)[ 38].Inanutshell,aRCFGisa
reducedCFGthatcontainsonlythosenodesforwhichthereexitsa
non-identity transfer function in the analysis. RCFG is constructed
using a pre-analysis that takes an analysis specification and a CFG
4A CFG may contain multiple exit points, however we connect them to a auxiliary
exit node.
622
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Ganesha Upadhyaya and Hridesh Rajan
asinput,extractsalltheconditionsfortheanalysistransferfunc-
tions andchecks the conditionsagainst theCFG nodes toidentify
analysis relevant nodes. We extended RCFG to also store the kind
of the transfer function that are applicable to CFG nodes as special
properties of nodes. This information is required in a later stage of
theCPAto generate patterns for CFGs.
0:START
1:C
2:acquire
4:END3:release
Figure 3: Sparse representation of writeObj method shown
in Figure 1.
To provide a concrete example of a sparse representation, let us
revisit the Resource Leak analysis described in our motivation and
thewriteObj methodshowninFigure1.The ResourceLeak anal-
ysis contains threekinds of transfer functions: acquire,release,
andcopy. Using the transfer functions, we can identify the rele-
vant statements in the writeObj method. The relevant statements
for this method are at line 3 and line 7, because line 3 creates a
FileWriter resourcevariableandithasanassociatedtransferfunc-
tion acquire,andline7releasestheresourcebyinvoking close
methodandithasanassociatetransferfunction release.Allother
statementsdonothaveanassociatedtransferfunctionandhence
are considered irrelevantand removed except some specialnodes,
such as STARTandEND. RCFG also retains the branch nodes that
haveatleastonesuccessorwitharelevantstatement.Theresulting
sparserepresentationisasshowninFigure3.ThisgraphisaRCFG
ofthe writeObj method.Itcontainstwonodes3and7thathave
non-identity transfer functions acquire andrelease respectively
and a special branch node marked C.
3.3 Analysis Equivalence
Given the sparse representations of programs, our next problemis tofind similaritiesbetweenthem. In caseof sparserepresenta-
tions of CFGs, finding similarities is a graph isomorphism problem
withrespecttocertainlabelingscheme.Apriorworkgspan[ 43]
hasproposedusingaDepth-firstsearch(DFS)codeastheunique
canonical label for graphs to find isomorphism. We utilize the DFS
code technique for obtaining the canonical form of the sparse rep-
resentation.
Given a graph (directed or undirected) with nodes and edges, a
DFSCode isanedgesequenceconstructedbasedonalinearorder,
≺Tby following rules (assume e1= (i1,j1),e2= (i2,j2), where
e1,e2are edges and i,jare node ids):•ifi1=i2andj1<j2,e1≺Te2,
•ifi1<j1andj1=i2,e1≺Te2, and
•ife1≺Te2ande2≺Te3,e1≺Te3.
EachedgeintheDFScodeisrepresentedasa5-tuple:<i,j, li,l(i,j),lj>
wherei,jare node ids, li,ljare node labels, and l(i,j)represents
the edge label of an edge (i,j).
IntheDFScodethatwegenerate,weuseonly4-tupleandignore
theedgelabel l(i,j),becauseitisonlyrequiredformulti-edgegraphs
and CFGs are notmulti-edge graphs. For nodelabels, we use the
transferfunctionkinds.Forinstance,forthe ResourceLeak analysis,
weuse acquire,releaseandcopyfornodelabels.Notethat,every
nodeinthesparserepresentationoftheCFGhasanassociatednon-identitytransferfunction.Figure4showstheDFScodeconstructed
for the sparse graph of writeObj method shown in Figure 1. As
shown in the figure, each edge is represented as a 4-tuple. For
instance,edgefromnode2tonode3isrepresentedas(2,3, acquire,
release).Byfollowingthethe ≺Torder,weobtainedtheDFScode
shown in the figure.
Figure 4: DFS code for the sparse control flow graph of the
writeObj method shown in Figure 1.
AnundirectedgraphcouldhaveseveralDFScodes(basedonthe
startingnode)andtheminimumDFScodeprovidesthecanonical
label,suchthatiftwographs GandG/primethathavethesameminimum
DFS codes are isomorphic to each other [43].
Theorem3.4(IsomorphicgraphsproduceeqalDFScode).
Giventwographs GandG/prime,Gisisomorphicto G/primeiff,theirminimum
DFS codes are equal.
Proof.The proof is based on [43].
Theorem3.5(ACFGhasauniqe,minimalDFScode). ACFG
always has a single DFS code that is minimum, because there exists a
single start node and the edges are directed.
ProofSketch. Theproofisbycontradiction.ConsiderthataCFG
has two DFS codes C1andC2. BothC1andC2must have the same
first edge because there exists only one start node for a CFG. Fromthe destination node of the first edge,
C1andC2might have two
623
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. Collective Program Analysis ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
different edges.However, thisis not possiblebecause thenext edgeis
picked by following the linear order ≺T, which is deterministic and it
always picks the same edge. If this process of picking the next edge is
continuedtoformtheedgesequencesin C1andC2,wecanseethat
bothC1andC2must have the same edges in the same order in the
sequences.
Giventhatwehaveamechanismtoencodethesparsegraphsas
DFScodes,wedefineanalysisequivalenceofsparserepresentations
of CFGs as graphs with same DFS code.
Definition 3.6. (Analysis Equivalence) Two CFGs G1andG2
are equivalent for a given analysis or analysis equivalent if the DFS
codes of the corresponding sparse graphs are same.
Toprovideaconcreteexample,considerthe ResourceLeak analy-
sisandthethreemethods writeObj ,main,and loadPropertyFile
shown in Figure 1. Although the CFGs of these three methods are
different, after removing all the irrelevant nodes, the sparse graphs
obtained are same, as shown in Figure 3. For this sparse graph, the
DFScodeconstructedisshowninFigure4.Asthesethreemethods
havethesameDFScode,theirsparserepresentationsareanalysis
equivalent.
Animportantpropertyoftheanalysisequivalentsparserepre-
sentationsisthattheanalysisoutputforthesegraphsaresimilar.
Whenwesaysimilar,wemeanthattheanalysisexecutesexactly
same set of instructions to compute results for nodes in the two
sparse representations. We formulate this property as a theorem
and provide proof sketch.
Theorem3.7(Analysiseqivalenceimpliesresultsimilar-
ity).Twoanalysisequivalentsparserepresentationsproducessimilar
results.
ProofSketch. Twoanalysisequivalentsparserepresentationswill
havesamenumberofnodesandeachnodeisassociatedwiththesame
kind of transfer function, which means that the result produced at
nodesaresimilar(bytheapplicationofthetransferfunctions).The
flow of results between the nodes in two sparse representations isalso similar because the edges between the nodes in the two sparserepresentations are also similar. This means that, if the two sparserepresentations starts off with an initial state (often
topelement of
the data-flow analysis), they must produce similar results.
3.4 Leveraging Analysis Specific Similarity
In the previous section, we described a technique for identifyingthe analysis specific similarity between programs, the final stepof
CPAis to cluster programs and reuse the analysis results. We
use a pattern database [ 25] to store the DFS codes of the sparse
representationsaskeysandanalysisresultsasvalues.Asdescribed
in our overview diagram shown in Figure 2, after producing theDFS codes for sparse representations, our approach first checks
whetheraresultisalreadypresentinthedatabase.Wedefinethe
presenceoftheDFScodeasa hitandtheabsenceas miss.Incase
of a hit, we simply return the stored result. In case of a miss, we
runtheanalysisonthesparserepresentationstoproducetheresult
and store the result along with the DFS code into the database for
future use.
Werequirethatanalysisresultsofsparserepresentationscannot
contain any concrete program data, for instance, variable names.Whiletheanalysiscancomputeanyconcreteresultforeachpro-
gram statement,the analysis resultsfor the sparserepresentation
must be free from the concrete program data. For example, Re-
source Leak analysis collects and propagates the variable names of
resource variables, however at the end it produces a boolean asser-
tion indicating “whether a resource leak exists in the program?”.
Thisisnotasevererestrictionfor CPAtobeapplicable,becausethe
analysescanstillcomputeprogramspecificoutputs,howeverthe
final output has to be an assertion or any result that is free from
program specific data.
4 EVALUATION
Themaingoalofourapproachistoacceleratelargescalesource
codeanalysisthatinvolvescontrolanddata-flowanalysis,hence
we mainly evaluate the performance. However, we also present
ourcorrectnessevaluationalongwithsomeinterestingresultsof
applying CPA. Below are the research questions answered in this
section.
•RQ1.Howmuchcanourapproach( CPA)speedupthesource
codeanalysesthatinvolvesanalyzingthousandsandmillions
of control flow graphs?
•RQ2.Howmuchreuseopportunityexistswhenperforming
collective program analysis?
•RQ3.What is the impact of the abstraction (in the form of
sparse representation) on the correctness and precision of
the analysis results?
4.1 Performance
4.1.1 Methodology. Wecompareourapproachagainstabase-
line that runs the analysis on all programs in the dataset with-
out any optimization or reuse. We also compare against a prior
work [38,39] that identifies and removes irrelevant statements
prior toanalyzing programs.We measurethe analysistime forall
threeapproaches( CFG,RCFG,and CPA)andcomputethepercentage
reductionintheanalysistimeof CPAover CFG(denotedasR)and
RCFG(denoted as R’) respectively. The analysis times were aver-
aged over the last three runs, when the variability across these
measurementsisminimal(under2%)byfollowingthemethodology
proposed by Georges et al.[16]. Note that, the cache (or pattern
database) is cleared after every run to ensure same setting for each
run.Ourexperimentswererunonamachinewith24GBofmemory
and 24-cores, running on Linux 3.5.6-1.fc17 kernel.
4.1.2 Analyses. Wehaveused10sourcecodeanalysestoeval-
uateourapproachaslistedinTable1.Weusedseveralcriteriato
select the candidate analyses. We have included analyses to ob-
tain maximum coverage over the flow analysis properties, such
as analysis direction (forward, backward ), merge operation (union,
intersection ),complexityoftheanalysis,andcomplexityofthedata-
structures used to store the analysis results at nodes. The analyses
are written using Boa [ 11–13], a domain specific language (DSL)
for ultra-large-scale mining and we have used Boa compiler and
runtime for executing the analyses. Next, we briefly describe each
analysis used in our evaluation.
624
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Ganesha Upadhyaya and Hridesh Rajan
Table 1: Analyses used in our evaluation.
#Analysis Description
1 Avail Expression optimization opportunities
2 Dom Control flow dominators
3 Escape Escape analysis
4 Leak Resource leaks
5 Live Liveness of statements
6MayAlias Local alias relations
7 Null Null check after dereference
8 Pointer Points-to relations
9 Safe Unsafe synchronizations
10 Taint Vulnerability detections
Avail.[24] Available expression analysis tries to find optimiza-
tionopportunitiesinthesourcecode,suchasvalueofabinopex-
pression computed once can be reused in the later program points,
ifthe variablesintheexpression arenotre-defined.This isastan-
dard compiler optimization drawn from the textbook. We included
this analysis to represent how an optimization problem can ben-
efitfrom CPA.Theanalysiswillreportifthereexistsoneormore
optimization opportunities.
Dom.[2] Control flow dominators are useful in many analyses
that requires control dependence, for instance in computing the
program dependence graph (PDG), however computing the domi-
natorsisexpensive,henceweincludedthisinourlistofanalyses
to demonstrate how our technique can accelerate computing domi-
nators.Thisisalsoaspecialkindofanalysis,whereallnodesare
relevant for the analysis and the sparse representation constitutes
the whole CFG. The analysis will report a map containing a list of
dominators for each CFG node.
Escape.[42] Escape analysis computes whether the objects allo-
cated inside methods stay within the method (captured) or escapes
toanothermethods.Thisinformationisusefultodecidewhetherto
allocate memory for such objects in the stack instead of heap. The
analysisoutputs true,ifthereexistsanycapturedobjects,otherwise
false.
Leak.[37]This is aresource leakcheckerthatcaptures there-
sourceusageinprogramstoidentifypossibleleaks.Theanalysis
tracks all 106 JDK resource related API usages in programs. If any
resource acquired is not released at the exit node, it outputs that
leak may exist.
Live.[24] This analysis tracks the liveness of local variables
usedintheprogram.Thereexistsmanyclient applicationsofthis
analysissuchasidentifyingandremovingthedeadcode,registeral-
location,etc.Thisanalysissimplyreportsallthevariabledefinition
and use sites along with their control flow dependencies.
MayAlias. [30] Precisely computing the alias information is ex-
pensive and sometimes may not be possible. In such situations,computing the may alias information by following the direct as-
signmentscanbehandy.Thismayaliasanalysiscomputesthealias
information and reports the alias sets.
Null.[7]This analysischecksifthere existsadereferencethat
is post-dominated by a null check. Such a pattern indicates thatthedereferencemaycausenullpointerexception,becauseitcanbenull.Theanalysisreportsifthereexistssuchproblemsinthe
program.
Pointer. [31] Pointer or points-to analysis implemented here
is a flow-sensitive and context-insensitive points-to analysis. It
computesthepoints-tograph.Apoints-tographprovidestheinfor-mationwhetherthevariablesintheprogrammaypointtothesame
memorylocation.Thisanalysisoutputsthepoints-tographwith
abstract variables and nodes (meaning concrete variable names are
mapped to symbols).
Safe.[37]Thesafesynchronizationcheckerlooksforthelock
acquire/releasepatternstoidentifybugs.Acquiringlocksandnot
releasing them may cause deadlock and starvation in the program.
Theanalysistracksallthevariablesonwhichthelockisacquired
and checks if the locks on these variables are released on every
program path. If not, it reports that the problem exists.
Taint.[15]Taintanalysisdetectsandreportspossiblevulnera-
bilitiesbyperformingataintanalysis.Theanalysisidentifiesthe
variables that read data from external inputs like console, tracks
their dataflow, and checks if the data from these variables are writ-
ten to output.
4.1.3 Datasets. Wehaveusedtwodatasetsforevaluating CPA.
The first dataset consists of all projects included in the DaCapo
benchmark [ 6], a well-established benchmark of Java programs.
Thisdatasetcontains45,054classesand286,888non-emptymeth-
ods.TheDaCapodatasetispreparedusingtheGitHubprojectlinks
of the 10 DaCapo projects. The second dataset consists of 4,938
open source SourceForge projects. This dataset consists of 191,945
classes,and6,741,465non-emptymethod.Notethat,theorderof
methods in our datasets is random and it is determined by thedataset creators [
11]. As such, the order does not influence CPA,
while prior caching does.
4.1.4 Results and Analysis. Table2comparesourapproach( CPA)
against the baseline(CFG) and theprior work (RCFG). The analysis
timein caseof CFGisthe actualanalysistime, whereas,in caseof
RCFG, it includes the two overheads (to identify and remove the
irrelevant nodes) and in case of CPA, it includes several overheads
(to produce the sparse graph, to generate pattern, to check the
patterndatabase,andretrievetheresultincaseofhit,andtopersist
the results in case of miss). The analysis times are reported inmilliseconds. For some analysis, the analysis times are low, forinstance
Safe. This is mainly because we have optimized all our
analyses toskip through theirrelevant methods (methodsthat do
not contain the information the analysis is looking for). Finding
and skipping through the irrelevant methods is done at a low cost.
Table 2 shows our results. The two columns R and R’ shows the
percentagereductionintheanalysistimeof CPAover CFGandRCFG
respectively.Onaverage CPAwasabletoreducetheanalysistimeby
69%over CFGand36%over RCFG(averagedoverboth DaCapoand
SourceForge datasets, which are individually 34% and 39%). Note
that, for Dom, the CFGandRCFGtimes are exactly same, because for
thisanalysisallnodesarerelevant,hence RCFGissimply CFG.For
Leakanalysis on DaCapodataset, CPAshows negative gain when
comparedto RCFG.Thishappensmainlybecauseofthelownumber
of instances on which the analysis is run. As shown in Table 4,
under DaCapo,the Leakanalysisisrunononly220uniquemethods
625
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. Collective Program Analysis ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Table 2: Reduction in the analysis time of CPA.
Time (in ms)
DaCapo SourceForge
Analysis CFG RCFG CPA CPA-UB CPA-CR RR’ CFG RCFG CPA CPA-UB RR’
Avail 3274 18221368 872103958%25%63971 35087 24688 1659361%30%
Dom 247855 247855 75559 1898 377870%70%6439232 6439232 3614844 3266444%44%
Escape 12624 87073588 902215372%59%250697 160654 71086 2145472%56%
Leak 227 3539 32 3783%-9% 5947 830 458 34892%45%
Live 5470 43292628 820186652%39%138929 111027 65369 1795353%41%
MayAlias 7823 41372238 870154471%46%168542 85204 43657 1629274%49%
Null 3841 22541365 257 68364%39%104838 65551 36885 510865%44%
Pointer 6246 33672019 888171668%40%109031 62279 40446 1722363%35%
Safe 9 22 2 275%0% 70 17 16 1477%4%
Taint 499 172123 55 6275%28%15981 3886 2266 80086%42%
Average 69%34% 69%39%
Figure5:%benefitoftheupperboundachievedby CFG, RCFG,
CPA. Higher bars are better.
and the cost of CPAoverheads may exceed the benefit, hence we
do not expect CPAto improve the performance. Similar situation
can be also be seen for Safeanalysis.
CPAusesanonlinestrategyofcachingtheanalysisresultsatthe
sametimeasrunningtheanalysisonmillionsofprograms. CPAcan
alsobeusedwithpriorcaching,hencewecomputetheidealgain
(or an upper-bound) by re-running the experiments on the same
dataset after caching the results in the first run. The analysis times
are reported in Table 2 under CPA-UBcolumn. Figure 5 helps to
understand how far CFG,RCFG, and CPAare from the ideal speedup
(CPA-UB).AsitcanbeseeninFigure5,formostanalysis, CPAisthe
closestto100%,whencomparedtoothers( CFGandRCFG),except
forLeakandSafe.Thereasonisasexplainedearlier,thenumberof
methodsonwhichtheanalysisisrunissmall,hencetheoverheads
ofCPAexceeds its benefits. Another interesting observation that
canbemadeisthatexceptfor LeakandSafe,forallotheranalysis,
there exists substantial opportunities to improve the performance
ofCPAtogetitcloserto CPA-UB.Thiscanbeperformedbytraining
CPAonsomerepresentativeprojects,cachingtheresults,andusing
them on the test projects.
4.1.5 Cross Project. We also performed a cross-validation ex-
periment,whereweexcludedoneprojectatatimefromthe DaCapo
dataset that contains a total of 10 projects, ran the analysis, cachedtheresults,andmeasuredtheanalysistimefortheexcludedproject.
We repeated this experiment and aggregated the analysis times
for all 10 projects. We reported the analysis times under CPA-CR
column in Table 2. As seen in the CPA-CRcolumn, CPA-CRanalysis
time lies between CPAandCPA-UB. For some analyses CPA-CRis
abletonearlymeettheupper-bound.Forexample, Dom.For Leak
andTaint,priorcachinghadlesseffectontheanalysistime,mainly
because the number of instances on which the analysis is run was
small. For other analyses, a consistent speedup is seen over CPA.
Thissuggeststhat, CPAwithsomepriorcachingcanimprovethe
performance over the online-strategy.
4.1.6 CPAComponents. For every CFG of the method to be an-
alyzed, CPAproduces asparse representation ofthe CFG, generates
a pattern that represents the sparse graph, and checks the pattern
database for a result. The overhead for this stage is represented as
patterninTable3.Whenthereisamiss,i.e.,theresultdoesnot
exists for a pattern, then CPAruns the analysis to produce a result
(analysis stage)andcachetheresult( persist stage).Whenthere
is a hit, i.e., a result is found, nothing else needs to be done. It is in-
terestingtoseehowtheoverall CPAtimeisdistributedacrossthese
components.ThecomponentresultsareshowninTable3,where
pattern,analysis , and persistare the three components. The
absolutetimesareinmillisecondsandwealsoshowthecontribu-
tions of each of the three components towards CPAtime (numbers
inside parentheses).
It can be seen that, persist time is almost always negligible.
Thepattern time, which is the time to construct the sparse graph,
generate pattern, and check the database sometimes exceeds the
actual analysis time. For example, Avail,Leak, and Safe. This is
mainly because in these analyses, the amount of relevant nodes
are very small. Thus, the time for removing the irrelevant nodes to
construct the sparse graph becomes substantial.
4.1.7 Reuse Opportunity. Table 2 shows that our approach was
abletosubstantiallyreducetheanalysistimeacross10analysesandtwodatasets.Thereductionmainlystemsfromtheamountofreuseopportunitythatexistsinlargedatasetsofprograms.Wemeasuredthetotalnumberofuniquegraphstocomputethereusepercentage.
The results are shown in Table 4. For all the analyses, CPAwas
626
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Ganesha Upadhyaya and Hridesh Rajan
Table 3: CPAtime distribution across four components. The absolute times are in milliseconds and the values inside “()” are
the contribution of the component towards CPAtime.
DaCapo SourceForge
Analysis CPA pattern analysis persist CPA pattern analysis persist
Avail 1368863 (63%) 496 (36%) 8 (1%) 2468816454 (67%) 8095 (33%) 138 (%1)
Dom 755591875 (02%) 73661 (97%) 23 (0%) 3614844 32437 (01%) 3582180 (99%) 225 (0%)
Escape 3588892 (25%) 2686 (75%) 10 (0%) 7108621206 (30%) 49632 (70%) 247 (0%)
Leak 3930 (77%) 7 (18%) 1 (3%) 458342 (75%) 110 (24%) 5 (1%)
Live 2628811 (31%) 1807 (69%) 8 (0%) 6536917776 (27%) 47416 (73%) 176 (0%)
MayAlias 2238862 (39%) 1368 (61%) 7 (0%) 4365716167 (37%) 27364 (63%) 125 (0%)
Null 1365252 (18%) 1108 (81%) 4 (0%) 36885 5027 (14%) 31777 (86%) 80 (0%)
Pointer 2019879 (44%) 1130 (56%) 8 (0%) 4044617056 (42%) 23223 (57%) 166 (0%)
Safe 22 (71%) 0 (00%) 0 (0%) 1613 (81%) 2 (13%) 0 (0%)
Taint 12352 (43%) 68 (55%) 2 (1%) 2266 784 (35%) 1466 (65%) 15 (1%)
Table 4: Amount of reuse opportunity available in various
analysis.
DaCapo SourceForge
Analysis TotalUnique Reuse TotalUnique Reuse
Avail 286888 15402 95%6741465 266081 96%
Dom286888 20737 93%6741465 345715 95%
Escape 286888 23347 92%6741465 430978 94%
Leak 3087 22093% 71231 274196%
Live286888 19417 93%6741465 366315 95%
MayAlias 286888 12652 96%6741465 211010 97%
Null 49036 785784%746539 148671 80%
Pointer 286888 16150 94%6741465 313337 95%
Safe 77 1482% 1310 8993%
Taint 6169 120880%147446 22664 85%
able to reuse the analysis results over 80% of the time. A very high
percentage of reuse clearly suggests why our approach was able to
achievesubstantialreductionintheanalysistime.Further,italso
supports the fact that source code is repetitive.
Table 5 lists the transfer functions for all our 10 analyses. The
namesofthesetransferfunctionsprovidesinformationaboutthe
kindof statementsthatare relevantforthe analyses.Forinstance,
def(v)transferfunctionappliestoallstatementsthathavevariable
definitions.Asweusetransferfunctionnamestolabelthenodes
andproducethe pattern,thesenamesare usedinthetoppatterns
discussed next.
In case of Taintanalysis, we had a total of 6169 methods in
theDaCapodatasetthatwereanalyzed(othermethodsdidn’thad
relevant code) and they formed 1208 unique sparse graphs. The
analysisreportedpossibilityofvulnerabilitiesfor101sparsegraphs.
Figure 6 shows the top 3 patterns along with their frequencies ((a),
(b), and (c)). Our analysis did not report any vulnerabilities for any
methodsthathavethesparsegraphsshownin(a),(b),(c),becauseall
these three sparse graphs only have either inputoroutputnodes.
For vulnerability to occur, both must exists. Consider (d) which
hasboth inputandoutputwasoneofthefrequentvulnerabilityFigure 6: Top patterns seen in case of taint analysis that de-tects vulnerabilities
patterninthe DaCapodataset.Wemanuallyverified20outof101
reported instances for the existence of possible vulnerabilities.
Figure 7: The most frequent lock/unlock pattern and thecode example of the pattern.
Incaseof Safeanalysisthatchecksforthecorrectuseoflock/un-
lockprimitivesusingJDKconcurrentlibraries,wehad76instances
reported correct and 1 reported as having a problem. Out of the
76,50ofthemfollowedasinglepatternthatisshowninFigure7.
This is a correct usage pattern for lock/unlock. The one instance
627
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. Collective Program Analysis ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Table 5: Transfer functions to identify relevant nodes.
Analysis Relevant Nodes
Avail def(v), binop(v1,v2)
Dom all
Escapecopy(v1,v2),load(v1,v2.f), store(v1.f,v2),gload(v1,cl.f)
gstore(cl.f,v2),call(v, m, v0,...,vk),new(v, cl), return(v)
Leak open(v), close(v), copy(v1,v2)
Live def(v), use(v)
MayAlias def(v1,c ),def(v1,v2)
Null deref(v), copy(v1,v2),nullcheck(v)
Pointercopy(v1,v2),new(v, cl), load(v1,v2.f)
store(v1.f,v2),return(v), call(v, m, v0,...,vk)
Safe lock(v), unlock(v)
Taint input(v), output(v), copy(v1,v2)
thatwasreportedproblematicwasafalsepositiveanditrequires
inter-procedural analysis to eliminate it.
Figure 8: Most frequent buggy resource leak pattern.
Leakanalysis results were most surprising for us. There existed
3087 usages of JDK resource related APIs (JDK has 106 resource
related APIs) and our analysis reported 2277 possible leaks. Outof these 336 were definitely leaks and others were possible leaks
and confirming them would require inter-procedural analysis. Out
ofthe336definiteleaks,thetoppatternappearedin32methods.
Figure 8 shows this pattern.
4.2 Correctness and Precision
In§3.3weprovidedaproofsketchastowhytheanalysisresults
ofCPAmust match with that of CFG. To empirically evaluate the
correctness of the results, we conducted two experiments using all
10 analysis and DaCapodataset. In the first experiment, we com-
paredtheanalysisresultof CFGandCPAforeverymethodthatis
analyzed. Table 6 provides information about the results computed
for each analysis. We were able to match the two results perfectly.
AsformostoftheanalysisinTable6thecomputedresultsare
justbooleanvalues,wedouble-checktheresultsbyprofilingthe
transferfunctionsexecutedfor CFGandthesparsegraphof CPA,and
comparethesequenceoftransferfunctions.Weskipthroughthe
identitytransferfunctionsincaseof CFG,asthe CFGmaycontain
many irrelevant nodes. As the order of nodes visited in both CFG
andsparsegraphof CPAaresame,wewereabletoseea100%match.Table 6: Analysis results computed for various analysis.
Analysis Computed Result
Availtrueorfalse
Domlist of dominators for each node
Escape points-to escape graph with abstract variables
Leaktrueorfalse
Livedefinitions and uses of abstract variables
MayAlias alias sets of abstract variables
Nulltrueorfalse
Pointer points-to graph with abstract variables
Safetrueorfalse
Tainttrueorfalse
4.3 Limitations
In this work we have applied CPAto accelerate analyses at method-
level, where results for each method is computed independently
withoutusingtheresultsatthemethodcallsites.Insteadofapplying
theresultsofmethodsattheircallsiteswehaveadoptedanover-
approximationstrategy.Assuch,therearenotheoreticallimitations
preventing the use of our technique in a compositional whole-
programanalysissetting,wheretheresultsofthecalledmethods
canbeusedattheircallsites,ifavailable.Thisdesignchoicewas
mainlyduetotheanalysisframeworkusedinourevaluation,which
does not support whole-program analysis as of this writing.
Anotherlimitationthatcurrentlyexistsin CPAisthatitcanonly
storeabstractanalysisresults.Forinstance,booleanvaluetoindi-
cate the existence of certain kinds of bug. CPAalso allows using
abstract variables and location names in the analysis as results. For
instance, variable v0points to the first variable encountered while
analyzingthemethodstatements.Similarly,thelocation loc0points
to the first relevant statement that exists in the sparse represen-
tation of the method. The abstract variables and location names
helpedustomodelmanyimportantanalyses,suchas Live,Escape,
Pointer, etc. In future, we plan to support better output types.
628
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Ganesha Upadhyaya and Hridesh Rajan
5 RELATED WORKS
Our work on CPAis related to the prior work on both improving
the efficiency of software analysis and finding software clones.
5.1 Improving the efficiency of source code
analysis
There exists a trade off between improving the efficiency of the
analysis and improving the accuracy of the analysis results. Re-
movingtheunimportantpartsofthecodebeforeanalyzingithas
been a popular choice [ 3,8,29,36,38]. For instance, Upadhyaya
andRajan[ 38]proposedRCFGareducedcontrolflowgraphthat
contains only statements that are related to analysis. Our work on
CPAhas adopted the RCFG work to produce the sparse graph. CPA
uses RCFG as its sparse representation to cluster similar graphs
and reuse the analysis results to further accelerate analyses. As we
have shown in our evaluation, CPAwas able to achieve on average
a 36% speedup over RCFG. There also exists other sparse represen-
tations such as sparse evaluation graph (SEG) [ 8] that are more
suitable for def-use style data-flow analysis. There exists works
that eliminates unnecessary computations in the traversal of the
program statements to improve the efficiency of analysis [ 4,36].
Thesetechniquesremovetheunne cessaryiterationsto improvethe
efficiency, whereas our work removes the unnecessary statements
to produce sparse graphs and also reuses the results by clustering
sparse graphs.
Allenet al.[3] and Smaragdakis et al.[29] have proposed a pre-
analysis stage prior to actual analysis to scale points-to analysis
to large code bases. They perform static analysis and programcompaction to remove statements that do not contribute to thepoints-to results. Their work is specialized for scaling points-to
analysis, whereas
CPAis more general, in that it can accelerate
analysis that use data-flow analysis and expressed using the lattice
framework.
Programslicingisafundamentaltechniquetoproduceacom-
pilable and runnableprogram that contains statements ofinterest
specified by a slicing criteria [ 41]. Many slicing techniques have
been proposed [ 35]. Our pruning technique is similar to slicing, in
thatwealsoremovetheirrelevantstatements,howeverourpruning
techniqueisapre-processingstepratherthanatransformationand
it does not produce a compilable and runnable code like slicing.
Slicing cannot be used for our purpose, because the program state-
ments of interest are not known. Even if the statements of interest
are known, slicing may includes statements (affecting the values of
variables at program points of interest) that may not contribute to
theanalysisoutput.Ourtechniqueonlyincludesstatementsthat
contributes to the analysis output.
Reusing the analysisresults is another way to improve theeffi-
ciencyofprogramanalysis[ 17,19,27].Kulkarni etal.[19]proposed
a technique to accelerate program analysis in Datalog. The idea of
their technique is to run an offline analysis on a corpus of training
programstolearntheanalysisfactsandthenreusesthelearntfacts
toacceleratetheanalysisofotherprogramsthatsharesomecode
with the training corpus. Inter-procedural analysis are often accel-
eratedbyreusingtheanalysisresultsintheformofpartial[ 17]and
complete [27] procedure summaries, where the analysis results of
procedurescan bereusedat theircallsites. Ourtechnique doesnotrequire that programs share code, it only requires that programs
executed same set of analysis instructions to produce results.
5.2 Finding software clones
Ourtechniqueisalsorelatedtocodeclones[ 28],asCPAalsoclusters
sparse representations of programs to reuse the analysis results.
Thereexistsdifferenttypesofclones.Syntacticclonesarelookalike
code fragments, semantic clones share common expressions and
theyhavesimilarcontrolflows,andfunctionalclonesaresimilar
intermsoftheinputsandoutputs.Therearealsootherapproachesthatgoesbeyondstructuralsimilarity,likecodefingerprints[
22],be-
havioralclones[ 14,32,33],andrun-timebehavioralsimilarity[ 10].
We did not use syntactic clones (token-based or AST-based), be-
cause the benefits will be limited to copy-and-paste code. Semantic
clones(codefragmentswithsimilarcontrolanddataflow)couldnot
beused,becauseoflackofguaranteethatanalysisoutputwillbe
similar.Moreover,semanticallydifferentcodefragmentsmaypro-
duce similar output for a given analysis and we would miss out on
those.Wecannotusefunctionalclones(codefragmentswithsimilar
input/output), because they may not produce similar analysis out-
put. We also could not use behavioral clones (code fragments that
perform similar computation captured using dynamic dependence
graphs), because they cannot guarantee similar analysis output.
An analysis may produce similar output for code fragments that
arenotbehavioral clones.Further,inour setting,whileanalyzing
thousands of projects, it is not feasible to instrument the code, run
them,collecttraces,andbuilddynamicdependencegraphstodetect
behavioral clones.
6 CONCLUSION AND FUTURE WORK
We proposed collective program analysis (CPA), a technique for
acceleratinglargescalesourcecodeanalysisbyleveraginganalysis
specific similarity. The key idea of CPAis clustering programs that
aresimilarforthepurposeoftheanalysis,suchthatitissufficientto
runtheanalysisononeprogramfromeachclustertoproduceresult
for others. To find analysis specific similarity between programs, a
sparse representation and a canonical labeling scheme was used.
The technique is applied to source code analysis problems that
requiresdata-flowanalysis.Whencomparedtothestate-of-the-art,
where the analysis is directly performed on the CFGs, CPAwas
able to reduce the analysis time by 69%. When compared to anoptimization technique that removes the irrelevant parts of theprogram before running the analysis,
CPAwas able to reduce the
analysistimeby36%.Bothoftheseresultswereconsistentacross
two datasets that contained several hundred thousand methods to
over 7 million methods. The sparse representation used in the CPA
was able to create a high percentage of reuse opportunity (more
than 80%). In future, we plan to extend CPAto whole-program
analysis and extend CPAto support more output types.
ACKNOWLEDGMENTS
ThisworkwassupportedinpartbyNSFgrantsCCF-15-18897,CNS-
15-13263, and CCF-14-23370. We thank Dr. Wei Le and anonymous
ICSE 2018 reviewers for their comments and suggestions.
629
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. Collective Program Analysis ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
REFERENCES
[1]Mithun Acharya, Tao Xie, Jian Pei, and Jun Xu. 2007. Mining API Patterns As
Partial Orders from Source Code: From Usage Scenarios to Specifications. InProceedings of the the 6th Joint Meeting of the European Software EngineeringConference and the ACM SIGSOFT Symposium on The Foundations of Software
Engineering (ESEC-FSE’07).ACM, NewYork, NY,USA,25–34. https://doi.org/
10.1145/1287624.1287630
[2]Frances E. Allen. 1970. Control Flow Analysis. In Proceedings of a Symposium on
CompilerOptimization.ACM,NewYork,NY,USA,1–19. https://doi.org/10.1145/
800028.808479
[3]Nicholas Allen, Bernhard Scholz, and Padmanabhan Krishnan. 2015. Staged
Points-to Analysis for Large Code Bases. In Compiler Construction. Springer
Berlin Heidelberg, Berlin, Heidelberg, 131–150.
[4]Darren C. Atkinson and William G. Griswold. 2001. Implementation Techniques
forEfficientData-FlowAnalysisofLargePrograms.In ProceedingsoftheIEEE
International Conference on Software Maintenance (ICSM’01) (ICSM ’01). IEEEComputer Society, Washington, DC, USA, 52–. https://doi.org/10.1109/ICSM.
2001.972711
[5]Sushil Bajracharya, Joel Ossher, and Cristina Lopes. 2014. Sourcerer: An Infras-
tructure for Large-scale Collection and Analysis of Open-source Code. Sci. Com-
put. Program. 79 (Jan. 2014), 241–259. https://doi.org/10.1016/j.scico.2012.04.008
[6]StephenM.Blackburn,RobinGarner,ChrisHoffmann,AsjadM.Khang,KathrynS.
McKinley, Rotem Bentzur, Amer Diwan, Daniel Feinberg, Daniel Frampton,
Samuel Z. Guyer, Martin Hirzel, Antony Hosking, Maria Jump, Han Lee,
J. Eliot B. Moss, Aashish Phansalkar, Darko Stefanović, Thomas VanDrunen,
DanielvonDincklage,andBenWiedermann.2006. TheDaCapoBenchmarks:
Java Benchmarking Development and Analysis. In Proceedings of the 21st An-
nual ACM SIGPLAN Conference on Object-oriented Programming Systems, Lan-guages, and Applications (OOPSLA ’06). ACM, New York, NY, USA, 169–190.
https://doi.org/10.1145/1167473.1167488
[7]Fraser Brown, Andres Nötzli, and Dawson Engler. 2016. How to Build Static
CheckingSystemsUsingOrdersofMagnitudeLessCode.In Proceedingsofthe
Twenty-FirstInternationalConferenceonArchitecturalSupportforProgramming
Languages and Operating Systems (ASPLOS ’16). ACM, New York, NY, USA, 143–
157. https://doi.org/10.1145/2872362.2872364
[8]Jong-DeokChoi,RonCytron,andJeanneFerrante.1991. AutomaticConstruction
ofSparseDataFlowEvaluationGraphs.In Proceedingsofthe18thACMSIGPLAN-
SIGACTSymposiumonPrinciplesofProgrammingLanguages (POPL’91) .ACM,
New York, NY, USA, 55–66. https://doi.org/10.1145/99583.99594
[9]Marco D’Ambros, Michele Lanza, and Romain Robbes. 2012. Evaluating De-
fectPredictionApproaches:ABenchmarkandanExtensiveComparison. Em-
pirical Softw. Engg. 17, 4-5 (Aug. 2012), 531–577. https://doi.org/10.1007/
s10664-011-9173-9
[10]John Demme and Simha Sethumadhavan. 2012. Approximate Graph Clustering
for Program Characterization. ACM Trans. Archit. Code Optim. 8, 4, Article 21
(Jan. 2012), 21 pages. https://doi.org/10.1145/2086696.2086700
[11]Robert Dyer, Hoan Anh Nguyen, Hridesh Rajan, and Tien N. Nguyen. 2013.
Boa: A Language and Infrastructure for Analyzing Ultra-large-scale SoftwareRepositories. In Proceedings of the 2013 International Conference on Software
Engineering (ICSE ’13). IEEE Press, Piscataway, NJ, USA, 422–431. http://dl.acm.
org/citation.cfm?id=2486788.2486844
[12]Robert Dyer, Hoan Anh Nguyen, Hridesh Rajan, and Tien N. Nguyen. 2015. Boa:
Ultra-Large-Scale Software Repository and Source-Code Mining. ACM Trans.
Softw. Eng. Methodol. 25, 1, Article 7 (Dec. 2015), 34 pages. https://doi.org/10.
1145/2803171
[13]Robert Dyer, Hridesh Rajan, and Tien N. Nguyen. 2013. Declarative Visitors
toEaseFine-grainedSourceCodeMiningwithFullHistoryonBillionsofAST
Nodes.In GPCE:the12thInternationalConferenceonGenerativeProgramming:
Concepts & Experiences (GPCE). 23–32.
[14]RochelleElvaandGaryT.Leavens.2012.SemanticCloneDetectionUsingMethod
IOE-behavior.In Proceedingsofthe6thInternationalWorkshoponSoftwareClones
(IWSC’12).IEEEPress,Piscataway,NJ,USA,80–81. http://dl.acm.org/citation.
cfm?id=2664398.2664414
[15]Ansgar Fehnker, Ralf Huuck, and Wolf Rödiger. 2011. Model Checking Dataflow
forMaliciousInput.In ProceedingsoftheWorkshoponEmbeddedSystemsSecurity
(WESS ’11). ACM, New York, NY, USA, Article 4, 10 pages. https://doi.org/10.
1145/2072274.2072278
[16]Andy Georges, Dries Buytaert, and Lieven Eeckhout. 2007. Statistically Rigorous
Java Performance Evaluation. In Proceedings of the 22Nd Annual ACM SIGPLAN
ConferenceonObject-orientedProgrammingSystemsandApplications (OOPSLA
’07). ACM, New York, NY, USA, 57–76. https://doi.org/10.1145/1297027.1297033
[17]Patrice Godefroid, Aditya V. Nori, Sriram K. Rajamani, and Sai Deep Tetali.2010. Compositional May-must Program Analysis: Unleashing the Power of
Alternation.In Proceedingsofthe37thAnnualACMSIGPLAN-SIGACTSymposium
onPrinciplesofProgrammingLanguages (POPL’10).ACM,NewYork,NY,USA,
43–56. https://doi.org/10.1145/1706299.1706307[18]GeorgiosGousios.2013. TheGHTorentDatasetandToolSuite.In Proceedings
ofthe10thWorkingConferenceonMiningSoftwareRepositories (MSR’13).IEEE
Press, Piscataway, NJ, USA, 233–236. http://dl.acm.org/citation.cfm?id=2487085.
2487132
[19]Sulekha Kulkarni, Ravi Mangal, Xin Zhang, and Mayur Naik. 2016. Accelerating
ProgramAnalysesbyCross-programTraining.In Proceedingsofthe2016ACM
SIGPLAN International Conference on Object-Oriented Programming, Systems,
Languages, and Applications (OOPSLA 2016). ACM, New York, NY, USA, 359–377.
https://doi.org/10.1145/2983990.2984023
[20]Zhenmin Li, Shan Lu, Suvda Myagmar, and Yuanyuan Zhou. 2006. CP-Miner:
Finding Copy-Paste and Related Bugs in Large-Scale Software Code. IEEE Trans.
Softw. Eng. 32, 3 (March 2006), 176–192. https://doi.org/10.1109/TSE.2006.28
[21]BenjaminLivshitsandThomasZimmermann.2005. DynaMine:FindingCommon
Error Patterns by Mining Software Revision Histories. In Proceedings of the 10th
EuropeanSoftwareEngineeringConferenceHeldJointlywith13thACMSIGSOFT
International Symposium on Foundations of Software Engineering (ESEC/FSE-13).
ACM, New York, NY, USA, 296–305. https://doi.org/10.1145/1081706.1081754
[22]Collin McMillan, Mark Grechanik, and Denys Poshyvanyk. 2012. Detecting
Similar Software Applications. In Proceedings of the 34th International Conference
on Software Engineering (ICSE ’12). IEEE Press, Piscataway, NJ, USA, 364–374.
http://dl.acm.org/citation.cfm?id=2337223.2337267
[23]Hoan Anh Nguyen, Robert Dyer, Tien N. Nguyen, and Hridesh Rajan. 2014.Mining Preconditions of APIs in Large-scale Code Corpus. In Proceedings of
the 22Nd ACM SIGSOFT International Symposium on Foundations of Software
Engineering (FSE 2014). ACM,New York, NY,USA, 166–177. https://doi.org/10.
1145/2635868.2635924
[24]Flemming Nielson, Hanne R. Nielson, and Chris Hankin. 1999. Principles of
Program Analysis. Springer-Verlag New York, Inc., Secaucus, NJ, USA.
[25]MichaelAOlson,KeithBostic,andMargoISeltzer.1999. BerkeleyDB..In USENIX
Annual Technical Conference, FREENIX Track. 183–191.
[26]HrideshRajan,TienN.Nguyen,GaryT.Leavens,andRobertDyer.2015. Inferring
BehavioralSpecificationsfromLarge-scaleRepositoriesbyLeveragingCollectiveIntelligence.In ICSE’15:The37thInternationalConferenceonSoftwareEngineering:
NIER Track.
[27]Thomas Reps, Susan Horwitz, and Mooly Sagiv. 1995. Precise Interprocedu-
ralDataflowAnalysisviaGraphReachability.In Proceedingsofthe22NdACM
SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL
’95). ACM, New York, NY, USA, 49–61. https://doi.org/10.1145/199448.199462
[28]Chanchal K. Roy, James R. Cordy, and Rainer Koschke. 2009. Comparison
and Evaluation of Code Clone Detection Techniques and Tools: A Qualita-tive Approach. Sci. Comput. Program. 74, 7 (May 2009), 470–495. https:
//doi.org/10.1016/j.scico.2009.02.007
[29]Yannis Smaragdakis, George Balatsouras, and George Kastrinis. 2013. Set-based
Pre-processing for Points-to Analysis. In Proceedings of the 2013 ACM SIGPLAN
International Conference on Object Oriented Programming Systems Languages
&#38; Applications (OOPSLA ’13). ACM, New York, NY, USA, 253–270. https:
//doi.org/10.1145/2509136.2509524
[30] Soot. 2015. Local May Alias Analysis. https://github.com/Sable/soot/.
[31]Manu Sridharan, Satish Chandra, Julian Dolby, Stephen J. Fink, and Eran Ya-
hav.2013. AliasinginObject-OrientedProgramming. Springer-Verlag,Berlin,Heidelberg, Chapter Alias Analysis for Object-oriented Programs, 196–232.
http://dl.acm.org/citation.cfm?id=2554511.2554523
[32]Fang-Hsiang Su, Jonathan Bell, Kenneth Harvey, Simha Sethumadhavan, Gail
Kaiser, and Tony Jebara. 2016. Code Relatives: Detecting Similarly Behaving
Software. In Proceedings of the 2016 24th ACM SIGSOFT International Symposium
on Foundations of Software Engineering (FSE 2016). ACM, New York, NY, USA,
702–714. https://doi.org/10.1145/2950290.2950321
[33]F. H. Su, J. Bell, and G. Kaiser. 2016. Challenges in Behavioral Code Clone Detec-
tion.In2016IEEE23rdInternationalConferenceonSoftwareAnalysis,Evolution,
andReengineering(SANER),Vol.3.21–22. https://doi.org/10.1109/SANER.2016.75
[34]Suresh Thummalapenta and Tao Xie. 2009. Alattin: Mining Alternative Patterns
forDetectingNeglectedConditions.In Proceedingsofthe2009IEEE/ACMInterna-
tional Conference on Automated Software Engineering (ASE ’09). IEEE Computer
Society, Washington, DC, USA, 283–294. https://doi.org/10.1109/ASE.2009.72
[35]FrankTip.1995.ASurveyofProgramSlicingTechniques. JournalofProgramming
Languages 3 (1995), 121–189.
[36]Teck Bok Tok. 2007. Removing Unimportant Computations in Interprocedural
ProgramAnalysis . Ph.D.Dissertation.Austin,TX,USA. Advisor(s)Lin,Calvin.
AAI3290942.
[37]Emina Torlak and Satish Chandra. 2010. Effective Interprocedural Resource
Leak Detection. In Proceedings of the 32Nd ACM/IEEE International Conference on
SoftwareEngineering-Volume1(ICSE’10).ACM,NewYork,NY,USA,535–544.
https://doi.org/10.1145/1806799.1806876
[38]Ganesha Upadhyaya and Hridesh Rajan. 2017. On Accelerating Source Code
Analysis At Massive Scale. Technical Report TR17-02. Iowa State University.
https://lib.dr.iastate.edu/cs_techreports/383/
[39]Ganesha Upadhyaya and Hridesh Rajan. 2017. On Accelerating Ultra-large-scale Mining. In Proceedings of the 39th International Conference on Software
630
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Ganesha Upadhyaya and Hridesh Rajan
Engineering:NewIdeasandEmergingResultsTrack (ICSE-NIER’17).IEEEPress,
Piscataway, NJ, USA, 39–42. https://doi.org/10.1109/ICSE-NIER.2017.11
[40]Andrzej Wasylkowski, Andreas Zeller, and Christian Lindig. 2007. Detecting
Object Usage Anomalies.In Proceedings ofthe the 6th JointMeeting of the Euro-
pean Software Engineering Conference and the ACM SIGSOFT Symposium on The
FoundationsofSoftwareEngineering (ESEC-FSE’07).ACM,NewYork,NY,USA,
35–44. https://doi.org/10.1145/1287624.1287632
[41]Mark Weiser. 1981. Program Slicing. In Proceedings of the 5th International
Conferenceon SoftwareEngineering (ICSE ’81).IEEE Press,Piscataway,NJ,USA,
439–449. http://dl.acm.org/citation.cfm?id=800078.802557
[42]John Whaley and Martin Rinard. 1999. Compositional Pointer and Escape Anal-
ysisforJavaPrograms.In Proceedingsofthe14thACMSIGPLANConferenceonObject-orientedProgramming,Systems,Languages,andApplications (OOPSLA’99).
ACM, New York, NY, USA, 187–206. https://doi.org/10.1145/320384.320400
[43]Xifeng Yan and Jiawei Han. 2002. gSpan: Graph-Based Substructure Pattern
Mining. In Proceedings of the 2002 IEEE International Conference on Data Mining
(ICDM ’02). IEEE Computer Society, Washington, DC, USA, 721–. http://dl.acm.
org/citation.cfm?id=844380.844811
[44]Tianyi Zhang, Ganesha Upadhyaya, Anastasia Reinhardt, Hridesh Rajan, and
Miryung Kim.2018. Are CodeExamples onan OnlineQ&A ForumReliable? A
StudyofAPIMisuseonStackOverflow.In Proceedingsofthe40thInternational
Conference on Software Engineering (ICSE ’18). ACM, New York, NY, USA.
631
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. 