Reducer-Based Construction of Conditional Verifiers
Dirk Beyer
LMU Munich, GermanyMarie-Christine Jakobs∗
LMU Munich, Germany
Thomas Lemberger
LMU Munich, GermanyHeike Wehrheim∗
Paderborn University, Germany
ABSTRACT
Despiterecentadvances,softwareverificationremainschallenging.
Tosolvehardverificationtasks,weneedtoleveragenotjustone
but several different verifiers employing different technologies.
To this end, we need to exchange information between verifiers.
Conditional model checking was proposed as a solution to exactly
thisproblem: Theidea isto letthe firstverifieroutput a condition
whichdescribesthestatespacethatitsuccessfullyverifiedandto
instruct the second verifier to verify the yet unverified state space
using this condition. However, most verifiers do not understand
conditions as input.
In this paper, we propose the usage of an off-the-shelf construc-
tion of aconditional verifier from a given traditional verifier and a
reducer. The reducer takes as input the program to be verified and
thecondition,andoutputsaresidualprogramwhosepathscover
the unverified state space described by the condition. As a proof
ofconcept,wedesignedandimplementedoneparticularreducer
and composed three conditional model checkers from the three
best verifiers at SV-COMP 2017. We defined a set of claims and
experimentally evaluated their validity. All experimental data and
results are available for replication.
CCS CONCEPTS
•Software and its engineering →Formal methods ;Formal
software verification;
KEYWORDS
ConditionalModelChecking,FormalVerification,Testing,Program
Analysis, Software Verification, Sequential Combination
ACM Reference Format:
Dirk Beyer, Marie-Christine Jakobs, Thomas Lemberger, and Heike
Wehrheim.2018.Reducer-BasedConstructionofConditionalVerifiers.In
Proceedings of the 40th International Conference on Software Engineering
(ICSE 2018). ACM, New York, NY, USA, 12pages.https://doi.org/10.1145/
3180155.3180259
∗ThisauthorwaspartiallysupportedbytheGermanResearchFoundation(DFG)within
the Collaborative Research Centre “On-The-Fly Computing" (SFB 901).
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE 2018, May 27 – June 3, 2018, Gothenburg, Sweden
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5638-1/18/05...$15.00
https://doi.org/10.1145/3180155.31802591 INTRODUCTION
Software model checking [ 47] has received lots of attention in
academia and industry [ 2,48] in the past two decades — yet, there
are many programs that are in principle verifiable, but no existing
verifier can solve them automatically. There are many different
approaches, but none is superior. The competition on software
verification(SV-COMP)[ 5]givesayearlyoverviewoverthestateof
theart,intermsofbothstrengthsofverifiersonvariouscategories
and weaknesses as shown by a large amount of unsolved problems.
One promising idea is to combine the strengths of different
verifiers by condition passing, which was formalized as conditional
model checking (CMC) [10] six years ago. The idea is simple and
effective: The first verifier reports what it had successfully verified
andsummarizesitsworkdoneasa condition.Thenextverifierreads
theconditionandverifiesonlythepartofthestatespacenotyet
coveredbythecondition.Thistechniquewasshowntobeeffective,
and sometimes even more efficient. Unfortunately, it is difficultto write a verifier that can parse the complicated conditions and
effectively reduce the state space of the verifier. This complication
isresponsibleforthesituationthatthetechniqueisnotaswidely
applied as it could be: only a few conditional model checkers exist.
To solve this problem, we developed an automatic construction
templatethatcanbeusedtoconstructaconditionalverifierfrom
a given arbitrary classical verifier. The original work proposedto run a product analysis that guides the state-space explorationsuch that it concentrates on the state space not covered by the
condition.Weproposeanalternativesolution,inspiredbyearlier
work on conditional modelchecking and testing [ 35]: Wedefine a
programreducer,whichtakesasinputaprogramandacondition,
andcomputesaprogramwhoseexecutionsarerestrictedtothose
not yet covered by the given condition. Having developed this
component once,it is easyto construct anew conditional verifier
using the equation CMC=V◦R, whereRis the reducer, Vis an
arbitraryverifier,and ◦isthesequentialapplicationoffirst Rtoa
given program and then Vto the output program of R. The new
verifierCMCis a conditional verifier that takes as input a program
andacondition.Figure 1illustratesthiscompositionvisually.There
can be different implementations of reducers, and the reducers
mightleverageanotionofabstraction,causingtheresidualprogram
to be more compact but less precise. We implemented a reducer
thatisbasedonaproductconstruction,i.e.,programandcondition
Reducer VerifierProgram
Conditional VerifierProgram
ConditionResult
Figure 1: Construction of a conditional verifier
11822018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. ICSE 2018, May 27 – June 3, 2018, Gothenburg, Sweden D. Beyer, M.-C. Jakobs, T. Lemberger, and H. Wehrheim
1 int val = nondet_int();
2 if (val >= 0) {3 int out = val%2 * val%3;
}else {
4 int out = -val;
}
5 assert (out >= 0);6
(a) Source codeq0
q1
qf q2
q3
q4(1,int val = nondet_int(), 2)
(2, val < 0, 4) (2, val >= 0, 3)
(3, int out = val%2 * val%3, 5)
(5, assert(out >= 0), 6)*
(b) Condition1 int val = nondet_int();2 if (val >= 0) {3 int out = val%2 * val%3;
4 assert (out >=0);
5}6 else
7;
(c) Residual program
Figure2:Example:(a)fragmentofaCpr ogram,(b)conditiongeneratedby CPAchecker withacceptingstatesasdoublecircles,
assumptions elided (all true), label * subsuming all control-flow edges, and (c) residual program constructed by Reducer
are converted into automata and the reduced product automaton is
converted back to a program.
Inourstudy,weshowthattheconstructionworksandiseffective.
We do not claim that our implementation of the reducer is the best
possible,butweshowforanumberofverifiershowtoincreasethe
number of obtained results with the reducer-based construction of
conditional verifiers. The approach can in some cases even reduce
the resource consumption.Contributions. We make the following contributions:
•
Weprovideareducerthatunderstandsmoreextensivecondi-
tions than a reducer that was previously used in the context
of conditional model checking and testing [35].
•Weconstructanumberofconditionalverifiersfromexisting
verifiers in order to experimentally show that new combina-
tionswithconditionpassingcansignificantlyincreasethe
number of verified programs.
•We apply the concept also to test-case generation and show
that the construction effectively works.
•Ourreducerandallexperimentaldataareavailableforotherresearchersandpractitionersforreplicationortostrengthen
their own verification infrastructure by using newly con-
structed conditional verifiers that were not available before.
2 CONDITION-BASED REDUCERS
Theobjectiveofourworkistheconstructionofconditionalveri-
fiers.Conditionalverifiersareverificationtoolsacceptingprograms
together with conditions as input. A conditional verifier shouldcheck the parts of the program not covered by the condition. To
this end, we employ reducersconstructing residual programs from
conditions.Westartwithgivingaformalaccountofconditionsand
reducers. In our notation, we follow previous work [11].
2.1 Foundations
Programs are represented by control-flow automata1(CFAs)C=
(L,/lscript0,G)that consist of a set of locations L, an initial location /lscript0,
andasetofcontrol-flowedges G⊆L×Ops×L,whereOpsistheset
1CFAs are a variant of control-flow graphs [ 1], with operations attached to the edges.ofoperations.Intuitively,aprogramanditsCFAaresemantically
equivalent because the CFA contains exactly the operations ofthe program on its control-flow edges and in exactly the sameorder.Ourconstructionofreducersreliesonsoundlyconverting
programs to CFAs andback within tools. We let Cbe the set ofall
CFAs.Inourpresentation,weconsideroperationsfromasimple
programming language, with assume operations and assignments
on integer variables. Our implementation covers C programs.
We letXbe the set of variables occurring in the operations
Ops. A concrete data state cis thus a mapping of XtoZ.A
concrete program path of a CFA C=(L,/lscript0,G)is a sequence
(c0,/lscript0)−д1− →...−дn−−→(cn,/lscriptn)such that c0assigns 0 to all variables,
дi=(/lscripti−1,opi,/lscripti)∈G, andci−1−opi−−→ci, i.e., (a) in case of as-
sumeoperations, ci−1|=opi(opiistheassumption) and ci−1=ci,
and (b) in case of assignments, ci=SPopi(ci−1), where SPis the
strongest-post operatorof theoperational semantics.Froma con-
creteprogrampath π=(c0,/lscript0)−д1− →...−дn−−→(cn,/lscriptn),wecanderive
anexecution ex(π)=c0c1...cn.W eletpath(C)bethesetofallcon-
crete program paths and ex(C)be the set of executions of a CFA C.
ACF ACisdeterministic (andhencerepresentableasaCpr ogram)if
the following holds for all /lscript∈L,(/lscript,op1,/lscript1),(/lscript,op2,/lscript2)∈G: either
op1=op2and/lscript1=/lscript2,o rop1is an assume operation and op1∧op2
is unsatisfiable.
Conditionssubsumetheresultsofverificationrunsonprograms.
A condition basically states which paths have been explored. In
addition,aconditionmightinvolve assumptions underwhichthe
verifier has explored a certain path. Assumptions are given as state
conditions (from a set Φ). We write c|=φto say that a concrete
statecsatisfies a state condition φ.
Definition 2.1. Acondition automaton (CA) (short: condition)
A=(Q,Σ,δ,q0,F)consists of
•a finite set Qofstatesand an initial state q0∈Q,
•analphabetΣ⊆2G×Φ,
•atransition relation δ⊆Q×Σ×Q, and
•a setF⊆Qofaccepting states,
and satisfies the following well-formedness condition:
¬∃(qf,∗,q)∈δwithqf∈F∧q/nelementF.
1183
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. Reducer-Based Construction of Conditional Verifiers ICSE 2018, May 27 – June 3, 2018, Gothenburg, Sweden
We let Abe the set of condition automata. Accepting states
in conditions are used to describe paths of the CFA which have
already been successfully verified. Figure 2shows an example C
programandaconditionautomatonasgeneratedby CPAchecker .
Theconditionshowsthattheverifierexploredtheelse-branchof
theif-statement(pathleadingtoacceptingstate qf)andsuccessfully
verified the assertion to hold on that path. Due to the non-linear
arithmetic, the verifier could not handle the then-branch, which
hence appears in the automaton on a path not entering qf.
Definition 2.2. A condition automaton A=(Q,Σ,δ,q0,F)covers
apathπ=(c0,/lscript0)−д1− →(c1,/lscript1)−д2− →...−дn−−→(cn,/lscriptn)ifthereisarun
ρ=q0−(G1,φ1)−−−−−−→q1−(G2,φ2)−−−−−−→...−(Gk,φk)−−−−−−→qk,0≤k≤n,i nA, s.t.
(1)qk∈F,
(2)∀i,1≤i≤k:дi∈Gi, and
(3)∀i,1≤i≤k:ci|=φi.
Thetaskofareducerisnowthegenerationofanewprogram
that contains the paths of the original program except for (at most)
those already covered by the condition.
Definition2.3. Areducerisamapping red:C×A→Csatisfying
the following residual condition:
Res.∀C∈C,∀A∈A:
ex(C)\{ex(π)|Acoversπ}⊆ex(red(C,A))⊆ex(C).
Inthefollowing,werefertotheoutputofareducerasthe residual
program. Note that the Identity relation on CFAs, i.e., red(C,A)=
C, is a reducer, though not a very effective one. Note also that –
contrary to Czech et al. [ 35] – the residual condition Resis not
specifictosafetyproperties,i.e.,unreachabilityoferrorlocations.
It simply states a coverage property for the residual program. Our
definitions allow us to use conditions and reducers as a meansfor various combinations of verifiers. As one example, both thecondition generating verifier
Aas well the condition processing
verifierBcould be tools generating test vectors, and together they
managetoachievecompletecodecoverage.Tools AandBcould,
ontheotherhand,alsobothbeformalsoftwareverifiersproving
validityofassertions,andtogethertheyprovesafetyoftheprogram.
2.2 Implementation
A reducer takes as input a program (in the form of a CFA) together
with a conditionautomaton and returns a residualprogram. Note
that the definition of reducers gives us some freedom in construct-
ingresidualprograms,inparticular,thereismorethanoneresidual
program possible. Here, we will present one such reducer.
OurreducerbuildsupontheideaofCzechetal.[ 35].Itconstructs
theresidualprogrambymeansofaparallelcompositionoforiginal
programandcondition,cuttingoffpathswheneverthecondition
hasreachedanacceptingstate.TheconstructioncalledReducer
is given in Alg. 1. In contrast to Czech et al. [ 35], Alg.1employs
an additional residual state qrto subsume states that the condi-
tion automaton either has not investigated, or has investigated but
under a non-true assumption. Note that Czech et al. do not need
qrbecause they consider a restricted class of conditions, which,
e.g., only considers trueassumptions. Depending on the condition,
the reduction might restructure the program as to isolate paths
which need to be cut off. In our example (Fig. 2), the generatedAlgorithm 1 Reducer
Input:CFAC=(L,/lscript0,G) ⊿original program
CAA=(Q,Σ,δ,q0,F)s.t.qr/nelementQ⊿condition automaton
Output: CFACr=(Lr,/lscript0,r,Gr)⊿residual program
1:Lr:={(/lscript0,q0)};/lscript0,r:=(/lscript0,q0);Gr:=∅;
2:waitlist := Lr;
3:whilewaitlist /nequal∅do
4:choose(/lscript1,q1)∈waitlist; remove (/lscript1,q1)from waitlist;
5:for each д=(/lscript1,op,/lscript2)∈Gdo
6: ifq1∈Q∧∃(q1,(G1,true),q2)∈δs.t.д∈G1then
7: for each (q1,(G1,true),q2)∈δs.t.д∈G1do
8: ifq2/nelementF∧(/lscript2,q2)/nelementLrthen
9: waitlist := waitlist ∪{(/lscript2,q2)};
10: Lr:=Lr∪{(/lscript2,q2)};
11: Gr:=Gr∪/braceleftBig/parenleftBig
(/lscript1,q1),op,(/lscript2,q2)/parenrightBig/bracerightBig
;
12: else
13: if(/lscript2,qr)/nelementLrthen
14: waitlist := waitlist ∪{(/lscript2,qr)};
15: Lr:=Lr∪{(/lscript2,qr)};
16: Gr:=Gr∪/braceleftBig/parenleftBig
(/lscript1,q1),op,(/lscript2,qr)/parenrightBig/bracerightBig
;
17:returnCr
condition describes that paths taking the else-branch have been
successfully verified while paths taking the then-branch still need
to be explored. Hence, the reducer generates a residual program
wheretheassertionismovedinsidethethen-branchsoastoensure
that the assertion need not be checked again for the else-branch.
Theorem 2.4. Algorithm Reducer is a reducer.
Proof.AssumeC,A,Cras used in Alg. 1. We have to show
ex(C)\{ex(π)|Acoversπ}⊆ex(Cr)⊆ex(C).
We separately look at the two set inclusions:
ex(Cr)⊆ex(C):Letc0...cn∈ex(Cr). Then, there exists a
pathπ=(c0,(/lscript0,q0))−д1− →...−дn−−→(cn,(/lscriptn,qn))∈path(Cr)
such that дi=((/lscripti−1,qi−1),opi,(/lscripti,qi))andci−1−opi−−→ci.
From this, we inductively construct a path π/primeofC(and
hence the execution of C):
•Induction start: take π/prime=(c0,/lscript0).
•Induction step: assume path π/primeto be constructed up to
some(cj,/lscriptj),j<n.
We know that дj+1=((/lscriptj,qj),opj+1,(/lscriptj+1,qj+1))∈Gr
(asπisapathof Cr).Newelementsareinsertedinto Grin
lines 11 and 16 of the algorithm only, while iterating over
elementsof G(line5).Hence (/lscriptj,opj+1,/lscriptj+1)∈G,andwe
can extend π/primeby(cj,/lscriptj)−(/lscriptj,opj+1,/lscriptj+1)−−−−−−−−−−−−→(cj+1,/lscriptj+1).
ex(C)\{ex(π)|Acoversπ}⊆ex(Cr):Letc0...cn∈ex(C)\
{ex(π)|Acoversπ}. Then, there is a path π=(c0,/lscript0)−д1− →
...−дn−−→(cn,/lscriptn)ofCthatisnotcoveredby A.Notethatthus
q0/nelementF, as otherwise all paths are covered. We inductively
constructapath π/prime=(c0,(/lscript0,q0))−д/prime
1− →...−д/prime
n−−→(cn,(/lscriptn,qn))
ofCrwithд/prime
i=((/lscripti−1,qi−1),opi,(/lscripti,qi))together with a
runρ=q0−(G1,φ1)−−−−−−→...−(Gm,φm)−−−−−−−→qmofAs.t. 0≤m≤n.
1184
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. ICSE 2018, May 27 – June 3, 2018, Gothenburg, Sweden D. Beyer, M.-C. Jakobs, T. Lemberger, and H. Wehrheim
They satisfy the following properties: (a) ∀i,0≤i≤n:qi/nelement
F,( b )∀i,0≤i<n:(/lscripti,qi)is an element of waitlist at
some point in time during the algorithm, and (c) at position
mthepath is splitintotwoparts, thesecondofwhich may
beempty,suchthat:(i) ∀i≤m:qi/nequalqr,i=0∨φi=true∧
дi∈Gi, and (ii)∀j>m:qj=qr.
•Inductionstart:take π/prime=(c0,(/lscript0,q0))andρ=q0.Then,
q0/nelementF,q0/nequalqr, and(/lscript0,q0)is initially in waitlist.
•Induction step: assume path π/primeto be constructed up to
some(cj,(/lscriptj,qj)),j<n, andρup to some ql,l<m.
We know that дj+1=(/lscriptj,opj+1,/lscriptj+1)∈Gandcj−opj+1−−−−→
cj+1(asπis path of C). We have two cases to consider:
(1)qj/nequalqr: Hence,qj∈Qand by induction hypothesis,
qj/nelementF,qj=ql,j=l. Again two cases:
(a)∃(qj,(Gj+1,true),qj+1)∈δ,дj+1∈Gj+1(line6):We
extendπ/primeby(cj,(/lscriptj,qj))−дj+1−−−→(cj+1,(/lscriptj+1,qj+1))
andρby(qj,(Gj+1,true),qj+1). We have qj+1/nelementF
asthepath πisnotcoveredby Aandρwouldwitness
coverage otherwise. Hence, (/lscriptj+1,qj+1)is added to
waitlist (unlessithasbeenintherebefore).Westay
in the first part of the path.
(b)Else (line 12): We switch to the second part of the
path. We extend the path π/primeby(cj,(/lscriptj,qj))−дj+1−−−→
(cj+1,(/lscriptj+1,qr))and letρremain unchanged. We
haveqr/nelementF(as it is an extra state) and (/lscriptj+1,qr)
is added to waitlist (unless it has been in there be-
fore).
(2)qj=qr:Then,weareinthesecondpartofthepathand
proceed as in (1), case (b). /square
To be usable by the condition processing verifier, the residual
CFAhastobetransformedbackintoaCprogram.TheresidualCFA
obtained by Reducer from a deterministic CFA (i.e., a C program)
isagaindeterministicsincetheconditiongeneratedby CPAchecker
is always deterministic. Moreover, note that we currently inline
procedure calls. Thus, Reducer may fail on recursive programs.
3 REDUCER-BASED VERIFIERS
In the previous section, we introduced two reducers, Identity
and Reducer. Next, we introduce the second component of our
conditional verifiers, the off-the-shelf tools that we transform into
conditional verifiers. In this paper, we transform four verifiers and
three test-generation tools. As verifiers, we use the best three tools
CPAseq,Smack, andUltimate Automizer from SV-COMP 2017 [ 5]
(Table1givesanoverview).Additionally,weusethevalueanalysis
from the CPAchecker framework [ 15], which supports condition
automataasinputconditions(anin-toolCMCsolution[ 10])and
allows us to compare the concept of reducer-based conditional
verifiers against an in-tool solution. As test-generation tools, we
choseAFL-fuzz,Crest-ppc , andKlee. All three are open source and
havelatelyattractedhighinterestbyresearch[ 17,23,27,49,55,56,
59].Inthenextparagraphs,weexplainthetechnologiesunderlying
the selected verifiers and test-generation tools.
ValueAnalysis. CPAchecker ’svalueanalysisisaconfigurablepro-
gram analysis [ 11]. Its reachability analysis tracks the values of
certainvariablesofinterestexplicitlywhileassumingthatthere-
maining variables may have any possible value. The precision [ 11]isincreasediteratively,basedoncounterexample-guidedabstrac-
tion refinement (CEGAR) [ 31] and lazy refinement [ 43]. To get
the best refinement, the analysis applies refinement selection [ 20].
Given an infeasible error path, path-prefix slicing [ 21] is used to
compute different overapproximations of the error path s.t. each
overapproximation replaces some assume operations with no-ops.
For each overapproximation, interpolation [ 18] is used to compute
arefinementcandidate.Intheend,thebestrefinementisselected.
CPAseq.CPAsequsesthe CPAchecker framework[ 15]torunfour
differentanalysesinsequence.Wheneverananalysisgivesup(due
to timeout or unknown result), the next analysis starts. A definite
answer (feasible error path or proof) of an analysis is returnedimmediately.
CPAseqstarts with a simple value analysis without
refinement,whichtracksallvariablevaluesimmediately.Next,a
value analysis similar to the one described above is used. The third
analysis is a bit-precise predicate analysis [ 16] that uses adjustable-
block encoding [ 16] to compute predicate abstractions only at loop
heads.Thesetofpredicatesisdeterminedbyacombinationofinter-
polation [ 42] and CEGAR[ 31] with lazyrefinement [ 43]. The last
analysis runs k-induction in parallel with invariant generation [ 9].
The invariants found so far are used to improve the k-induction
step and are provided by numerical and predicate analyses.
Smack.TheSmack[54]verifierconsistsofatranslationfrontend
andaverificationbackend.First,ittranslatestheinputprogram
to Boogie code (via intermediate LLVM code). Based on heuristics,
the Boogie code is either verified with Boogie or Corral. Boogie [ 3]
proves a verification condition generated with the weakest precon-
dition calculus. Corral [ 50] tries to find a property violation with a
two-stagedCEGAR approach.First, itusesvariable abstractionto
compute an overapproximation of the program, which only consid-
ers a subset of the program variables. The variable abstraction is
adapted whenever the second CEGAR approach fails to rule out an
infeasible error path. On the second stage, Corral inlines functions
(summaries)uptoagivenrecursiondepth(loopsareassumedto
be written as recursive functions). Functions are only inlined if the
function summary appears in an infeasible error path.
Ultimate Automizer .Ultimate Automizer (UAutomizer )[40,41]
usesanautomata-basedverificationapproach.Inprinciple,itmain-tainsanoverapproximationoferrorpathsinformofanautomaton.
A CEGAR approach successively refines the overapproximation,
i.e.,itremovesinfeasibleerrorpaths,untilafeasibleerrorpathis
foundortheautomatonlanguageisempty.Ineachrefinementstep,
a generalization of an infeasible error path is excluded from thecurrent overapproximation. The generalization of the error pathis described by a Floyd-Hoare automaton [
41], which associates
booleanformulasoverpredicateswithitsstates.Theinitialstate
is associated with true, accepting states are associated with false,
and transitions describe valid Hoare triples. The predicates used in
theHoaretriplesareobtainedviainterpolationalongtheinfeasible
error path.
AFL-fuzz .AFL-fuzz is arandom fuzzingtester. Givena setof start
inputs,itperformsdifferentmutationsontheexistinginputs,exe-
cutesthesenewlycreatedinputs,andcheckswhethernewprogram
parts areexplored. Ifthis isthe case,the inputsare keptand used
for further mutation. Otherwise, the inputs are discarded.2
2AFL (American Fuzzy Lop) is available at http://lcamtuf.coredump.cx/afl/.
1185
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. Reducer-Based Construction of Conditional Verifiers ICSE 2018, May 27 – June 3, 2018, Gothenburg, Sweden
Table 1: Overview of applied verification technologies in the verifiers
Refinement
Verifier Technique CEGAR Lazy abstraction Interpolation Bitprecise
CPAseq ARG, explicit and numerical values, predicates, k-induction /check/check /check /check
Smack property-driven reachability [24], bounded model checking [22] /check/check × /check
UAutomizer automata, predicates /check/check /check /check
Klee.Klee[26]usessymbolicexecutionfortest-casegeneration.
Symbolic execution is an extension to concrete execution of a pro-
gram.Foreveryunknowninputvaluetoaprogram,anewsymbolic
valueisintroducedthatinitiallyrepresentsanypossiblevalue.Dur-
ing execution, the symbolic values are constrained by branching
conditions along the program (e.g., if-branches in a C program).
Theseconstraintsareusedtocomputewhetheragivenprogram
path is feasible, and which class of input values will lead to execu-
tionsthattakethispath.Wheneverbothbranchesarefeasiblein
asymbolicexecution, Kleecopiesitscurrentsymbolicexecution
stateandcontinuestoexploreonebranchwiththecurrentstateand
the other with the copied state. After each step in a program, Klee
heuristicallychooseswithwhichoftheexistingexecutionstatesto
continue. Given several heuristics, Klee alternates between them.
Crest-ppc .Crest-ppc [49] is an improved version of Crest[25].
Crestuses concolic execution for testing and provides different
heuristicstoachievehighercodecoverage.Concolicexecutionis
a combination of symbolic execution and concrete execution. A
programundertestisexecutedwithconcreteinputsthatdetermine
one concrete execution path. In parallel, a symbolic execution is
performed on that path to obtain constraints over program inputs
on this path. Based on these path constraints, a constraint solver
computes new inputs that lead to the execution of another, yetunvisited program part. New executions are performed and newinputs are generated until all program parts are explored.
Crest
uses heuristics to choose which unvisited program part to explore
next. To increase the performance, Crest-ppc adds a heuristic to
Crestthatsubmitsmorecallstotheconstraintsolverbutusesfewer
constraints per call.
4 EVALUATION
4.1 Claims to be Evaluated
In the following, we list our claims and how we plan to evaluate
them.Theclaimsarenotonefficiency,butoneffectiveness.That
is, we provide means for solving additional verification tasks by
investing more computing resources, but without implementing or
changing verification tools.
FeasibilityHypothesis. A reducer can be used to effectively con-
struct conditional verifiers from existing verification tools. Evalua-
tionPlan: Weshowthisbyimplementingoneparticularinstanceof
a reducer, and apply our reducer-based construction of conditional
verifierstothreemodelcheckersandthreetesters.Theresultisa
setofsixconditionalverifiers,andwetakestandardconfigurations
“out of the box”, without changing a single line of the verifiers.
Null Hypothesis. Applying a reducer has no effect. Evaluation
Plan:We compare the results using our reducer against the results
using the identity function as replacement for the reducer.Claim1.
Reducer-basedconditionalverificationisnotmuchworse
then“native”conditionalverification. EvaluationPlan: Theoriginalproposal of CMC [ 10] implements the restriction of the state space
that the condition describes internally in the exploration engine
oftheverifier.Weclaimthatitalsoworksreasonablywelltouse
an external reducer instead, which opens the door for constructing
new conditional verifiers without actual implementation work.Claim2.
Thetechniqueof conditionalverificationcaneffectively
increasethenumberofoverallsolvedverificationtasksifadditionalresourcesareprovided. EvaluationPlan: Weselectanumberofhard-
to-solve verification tasks and perform experiments on them using
the original verifiers and the constructed verifiers.
Claim3. Conditionalverificationwithconditionpassingcansolve
verification tasks that neither CPAseq,Smack, norUltimate Au-
tomizercan solve. Evaluation Plan: We select from a given set of
verification tasks those verification tasksthat none of the original
verifiers, but at least one of the conditional verifiers can solve.
Claim 4. The use of different conditional verifiers improves the
overalleffectiveness. EvaluationPlan: Wereportresultsfordifferent
conditionalverifiersandconsiderverificationtasksthatonlyone
conditional combination can solve.
Claim 5. Reducer-based conditional verification is also applicable
to test-case generation. Evaluation Plan: We construct conditional
verifiers from three test-generation tools and compare the number
of generated crashing tests against the result of the test-generation
tools alone.
4.2 Setup
Computing Resources. We performed our experiments on ma-
chines with an Intel Xeon E3-1230 v5 CPU with 8 processing units
each,afrequencyof3.4GHz,33GBofmemory,andanUbuntu16.04
operatingsystemwithLinuxkernel4.4.Welimitedeachanalysis
runto15GBofmemoryandavaryingtimelimit,dependingonthe
experiment, and allowed it to use all 8 processing units. We report
CPU time and memory use with two significant digits.
VerificationTasks. Togetarepresentativesetofverificationtasks,
we used all 5687programs from ReachSafety categories of the SV-
COMPbenchmarkset3inrevisioncc496684.Forallinputprograms,
we verify the property that function __VERIFIER_error is never
called.Atotalof 1501ofthe5687programsareunsafe,i.e.,thecall
to __VERIFIER_error is reachable, and 4186 programs are safe.
Tools.Weusedapredicateanalysisforconditiongenerationand
a value analysis for comparison with native conditional model
checking,both fromthe CPAchecker project. Our implementation
of a reducer is also available in the CPAchecker project. For all
experiments, we used CPAchecker from branch reducer-patch in
revision r25656. For the verifiers in the composition of our reducer
with a verifier, we use the three best tools from SV-COMP 2017,
assubmittedtothecompetition5(withoutanymodifications)and
3https://sv-comp.sosy-lab.org/2017/benchmarks.php
4https://github.com/sosy-lab/sv-benchmarks
5https://sv-comp.sosy-lab.org/2017/systems.php
1186
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. ICSE 2018, May 27 – June 3, 2018, Gothenburg, Sweden D. Beyer, M.-C. Jakobs, T. Lemberger, and H. Wehrheim
 1 10 100 1000
 1  10  100  1000CPU Time for Identity (s)
CPU Time for Reducer (s)
(a)Reducer vs.Identity (pure sequential combination) 1 10 100 1000
 1  10  100  1000CPU Time for Native CMC (s)
CPU Time for Reducer (s)
(b)Reducer vs. native CMC implementation in CPAchecker
Figure 3: Comparison of CPU time of different CMC solutions for predicate (100s) + value analysis
the three test-generation tools described previously. To streamline
the testing process for the test-generation tools, we use the testing
framework tbf[17]6in revision b60a924. We run our experiments
withBenchExec [19] (version 1.14).7
Availability. All our experimental data are available online [ 14].8
4.3 Experiments
FeasibilityHypothesis. Wedesignedandimplementedaproof-of
concept reducer, and licensed the reducer using the open-source
license Apache 2.0 such that other researchers can later use it.
Whileourimplementationcertainlyhaspotentialforimprovement,
we show that the approach of composing a conditional verifier
from an arbitrary verifier and our reducer works in practice. Wedemonstrated this by using the three best verifiers directly fromthe SV-COMP web site and composed the conditional verifiers
without any change to the verifiers. In addition, we also composed
conditional verifiers from test-generation tools, in order to help
test-generatorstoproducecrashingtestsformoreverificationtasks.
Null Hypothesis. We have experimented with verification runs
inwhichwereplacedourreducerbyanidentityfunctionIdentity,i.e.,thereduceriseffectivelyremovedfromthetoolchain.Thefirst
verifier, which generates the condition, is a predicate analysis that
werestricttoatmost 100sofCPUtime.Forthesecondverifier,we
useCPAchecker ’s value analysis with a time limit of 900s.
Figure3auses a scatter plot to illustrate the CPU times of the
reducer-basedapproachusingReducer(x-axis)againstusingIden-
tity (i.e., pure sequential combination). The scatter plot shows
results only for those verification tasks that at least one of the two
combinationscansolveandthatnoneofthemsolvedincorrectly
or crashed on. Thus, the plot only displays results that have a use-
ful result. Often, the results are similar (data points close to the
6https://github.com/sosy-lab/tbf
7https://github.com/sosy-lab/benchexec
8https://www.sosy-lab.org/research/reducer/diagonal). In this case, the predicate analysis alone already solved
the verification task. For some tasks, Reducer is slower or eventimes out, due to the large size of residual programs. The reason
isthatReducerrestructurestheprogram,e.g.,unfoldsloopsand
the program structure. The residual program becomes much larger
andmorecomplexinitsstructure,whichcomplicatesthetaskof
the second verifier in these cases. However, there are also a set
oftasksforwhichReducerissignificantlyfaster:thedatapoints
close to the upper border represent tasks for which the conditional
combination with Reducer solved the task while the combination
with Identity timed out. Thus, the null hypothesis is rejected.
Claim 1 (Comparison against native implementation). We
compare our proposed reducer-based approach to construct con-
ditional verifiers against the approach of the original implementa-
tion[10],whichwerefertoas‘native’approachbecauseitimple-
ments the restriction of the state space according to the condition
internally inthe verifier. We usethe same setupas above, butre-
placethesecondverifierby CPAchecker ’svalueanalysiswiththe
internalconditiontreatmentenabled.Figure 3bshowstheuseful
results as scatter plot, again. Most of the data points are close to
the diagonal, i.e., the two solutions perform similarly. However, as
above,whentheresidualprogramgetstoolarge,thereducer-basedsolutionsometimesusestoomuchtime(rightside).Forsometasks,
the reducer-based solution is even faster than the native approach
(top). Thus, Claim 1 is valid.
Claim2(Effectiveincreaseofnumberofverifiedprograms).
We now evaluate the claim that the use of two complementing
verifiers joined by reducer-based conditional verification can effec-
tively solve additional verification problems if additional resources
arespentonrunningacombinationaftertherunsoftheoriginal
verifier.Inourexperiments,wealwaysfirstrunaconditionalver-
ifier based on predicate analysis to output the conditions, with atime limit of
100sof CPU time. The predicate analysis combines
lazy abstraction refinement [ 43] with predicate abstraction with
adjustable-blockencoding(ABE)[ 16].ABEisconfiguredtoabstract
1187
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. Reducer-Based Construction of Conditional Verifiers ICSE 2018, May 27 – June 3, 2018, Gothenburg, Sweden
Table 2: Results of using a verifier on its own vs. a combina-
tion with predicate analysis and condition passing
CPAseq Smack UAuto Predicate +
CPAseq Smack UAuto
Correct 513 415 238 789 695 789
Correct proof 265 76 170 387 296 386
Correct alarm 248 339 68 402 399 403
Incorrect 0 0 7 0 0 4
Incorrect proof 004 00 0
Incorrect alarm 003 00 4
Unknown 307 405 575 31 125 27
Total 820 820 820 820 820 820
 1 10 100 1000
 0  100  200  300  400  500  600  700  800CPU time (s)
n-th fastest correct resultCPA-seq
SMACK
Ultimate Automizer
Predicate + CPA-seq
Predicate + SMACK
Predicate + Ultimate Automizer
Figure 4: Quantile plots for the six verification approaches
atloopheadsonly.Letusrefertothisverifieras A.Theconditional
verifierinthesecondverificationstepisalwaysconstructedfrom
our reducer and an off-the-shelf verifier; we limit the CPU time
to900s. Let us refer to this kind of verifier as B. Verifier Btries
to solve all tasks that Awas not yet able to solve, with the help
of the conditions generated by Afor these tasks. The time limit
of900sof CPU time is considered a community standard (cf. SV-
COMP),becausemostverificationtaskscaneitherbesolvedway
below this time limit or cannot be solved at all. As verifier B,w e
composeourreducerwiththethreebesttoolsfromSV-COMP2017
on reachability properties: CPAseq,Smack, andUltimate Automizer .
Manyoftheverificationtasksintheconsideredtasksetfromthe
SV-COMP benchmarks are easy to solve for the standard verifiers.
For those tasks, we do not need to further experiment because
our aim is to show that the new approach can increase the overall
numberofverifiedprograms.Therefore,werestrictourexperiment
to verificationtasks that arehard-to-solve; in particular,we select
those verification tasks for which at least one verifier Bfails but
the corresponding combination with condition passing of AandB
solvesthetask.Thisresultsinabenchmarksetcontaining 820hard-
to-solve verification tasks.
Table2breaks down the effectiveness of each verification ap-
proach.Itliststhenumberofverificationtasksthateachverification
approachsolvedcorrectly,solvedincorrectly, andwhichitcannot
solve (‘Unknown’). The correct and incorrect results are further
classifiedintoanswersthatreportedaproofandabug,respectively.
Inspecting the numbers, we observe the following: In all three
cases, the reducer-based CMC combination with condition passingofverifiers AandBsolvessignificantlymoretaskscorrectlythan
verifierBalone.Atthesametime,thenumberofwronganswers
is not increased by the conditional verifier. There are two possible
reasonsforthisimprovement:First,verifier Aalreadyaccomplished
theverification task,inwhich verifier Bhasno work(suggestedby
thedatapointsonthediagonalwithlessthan 100sinFig3a).Or
second,verifier Averifiedasignificantportionoftheverification
tasksuchthattheresidualprogramgeneratedbyReducerbecomes
easier to analyze for verifier B(suggested by the middle and lower
part of Table 3).
Figure4shows quantile plots for all six verification approaches.
Adatapoint (x,y)onsuchagraphmeansthatthe xfastestcorrect
results can be solved all in max. ysof CPU time each. We observe
that all reducer-based approaches significantly outperform their
standalonecounterpartbyinvestingmax. 100sofCPUtime.These
observations together with Table 2validate our Claim 2.
Claim3(Solvingproblemsthatnoneofthethreecansolve).
We consider a particular subset of the verification tasks, namely
those that none of the verifiers CPAseq,Smack, andUltimate Au-
tomizercan solve as standard verifier but at least one combination
can.Thesetasksseemtobeparticularlyhardforverifierswhilenotbeing too hard for our approach. Table 3shows an excerpt of those
143programsofthetaskset.Foreachverificationtask(identified
bynameandexpectedverificationresult),thetablecontainsgroups
of result, CPU time, and max. memory usage, for each of the three
standardverifiersandtheirreducer-basedcombinationwithcon-
dition passing. From the table, it can be observed that Claim 3 is
valid:thereexistprogramsthatconditionalcombinationscansolve
but none of the given standard verifiers can.Claim4(Differentbackendshavedifferentstrengths).
None
oftheconditionalverifiersissuperior.Eachverifierhasitsstrengths:
fortwoverifiers Bthereexistverificationtasksthatonlyacombi-
nation with that verifier can solve and no other combination (cf.
Table2). And each verifier has its weaknesses: for each verifier,
there are some verification tasks that the verifier, even in combina-
tion,cannotsolve.Tosolvealldifficulttasks,weneedtoleverage
different technologies. The experimental results validate Claim 4.
This last observation makes the contribution of our reducer-
basedapproachimportant:Itdoesnotmakesensetoextendexisting
verifiers to become conditional verifiers (in terms of accepting con-
ditionsasinputs),becauseweneed manyconditionalverifiers.Our
approachtotakean arbitrary verifieroff-the-shelfandconstruct
aconditionalverifierwithoutimplementationworksignificantly
improves the overall achieved verification power.Claim5(Reducer-basedconstructionworksalsofortesting).
To demonstrate that our approach can be applied to tools other
than model checkers, we combine our Reducer with three test-
generationtools,namely AFL-fuzz(v2.46b), Crest(revision31c32f4),
andKlee(v1.4.0). As in the other experiments, the first analysis
(which generates the condition) is the predicate analysis, again
limited to 100s. The test-generation is limited to 900s.
Analogous to Claim 2, we restrict the experiment to those verifi-
cationtasksthatarehard-to-solvewithtestgeneration:weselect
those tasks for which at least one test generator fails to uncoverabugin,butthatthecorrespondingcombinationwithcondition
passing can correctly solve. In addition, since testing cannot prove
correctness, we only consider verification tasks that are unsafe.
1188
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. ICSE 2018, May 27 – June 3, 2018, Gothenburg, Sweden D. Beyer, M.-C. Jakobs, T. Lemberger, and H. Wehrheim
Table3:ResultsofverificationtasksforwhichallconsideredverifiersAalonecouldnotcomputearesult,butforwhichatleast
one verifier B succeeded in a reducer-based combination with condition passing. Column Rshows the expected result of the
correspondingtask:eithernopropertyviolationexists(T)intheprogramorapropertyviolationexists(F).Column Sreports
whether the task was solved by the corresponding verifier, tis the CPU time in seconds spent to achieve the corresponding
result, and Mthe used memory in GB.
Task RCPAseq Smack UAutomizer +CPAseq +Smack +UAutomizer
S t(s) M(GB) S t(s) M(GB) S t(s) M(GB) S t(s) M(GB) S t(s) M(GB) S t(s) M(GB)
loop-acc overflow T 910 7.8880 0.93900 1.32.60.272.60.272.60.27
mutex_unbounded F 910 4.90.13 0.021900 0.945.60.325.60.325.60.32
mutex_unlock F 320 4.90.11 0.020900 1.211 0.4711 0.4711 0.47
lin-4.0 legousbtower F 180 15 880 0.56900 4.012 0.4812 0.4812 0.48
lin-4.0 net2272 F 56 15 890 1.0900 7.315 0.5315 0.5315 0.53
fib_longer F 900 3.7880 0.158.60.3015 0.6115 0.6115 0.61
lin-3.4 vivi F 230 15 880 0.2548 1.315 0.5915 0.5915 0.59
lin-3.0 block-loop F 900 8.5880 0.48900 3.816 0.5116 0.5116 0.51
lin-4.2 lm78 T 950 6.8890 1.2910 13 18 0.6318 0.6318 0.63
lin-3.4 synaptics F 210 15 880 0.43900 1.618 0.6218 0.6218 0.62
lin-3.16 mISDN T 910 8.8950 3.0900 5.726 0.9626 0.9626 0.96
lin-4.2 vfio F 910 8.1890 0.47900 5.326 0.7026 0.7026 0.70
val-0.8 g_printer F 910 8.4880 0.73900 5.528 0.8728 0.8728 0.87
val-0.6 g_printer F 910 8.4880 0.71900 5.628 0.8528 0.8528 0.85...
Problem19_label20 T 520 15 880 2.8900 13 110 0.37110 0.37110 0.37
Problem19_label57 T 440 15 880 2.9900 13 110 0.36110 0.37110 0.38
Problem19_label37 T 440 15 880 3.2900 13 110 0.38110 0.37110 0.37
Problem19_label15 T 440 15 880 3.0900 11 110 0.37110 0.37110 0.38
Problem19_label44 T 440 15 880 2.9900 12 110 0.39110 0.37110 0.37
Problem19_label36 T 500 15 880 2.9900 13 110 0.38110 0.38120 0.38
Problem19_label06 T 460 15 880 2.9910 14 110 0.37110 0.38110 0.36
Problem19_label56 T 440 15 880 2.9910 13 110 0.39110 0.37110 0.37
Problem19_label30 T 450 15 880 3.2910 13 110 0.36110 0.37110 0.37
Problem19_label01 T 440 15 880 2.9900 11 110 0.37110 0.37110 0.37
Problem19_label09 T 550 15 880 3.0900 11 110 0.37110 0.37110 0.37
Problem19_label40 T 450 15 880 2.9900 13 110 0.38110 0.37110 0.36
Problem13_label33 T 550 15 880 3.1900 7.2110 0.29110 0.30110 0.32
Problem19_label05 T 450 15 880 2.9900 12 110 0.38110 0.37110 0.36...
lin-4.2 vlsi_ir T 910 7.9890 0.97900 13 490 10 130 0.67150 0.77
lin-3.14 vsp1 T 920 6.9890 0.70910 14 550 1.5610 1.5640 1.5
lin-3.14 vxge T 930 11 190 14 19 0.51760 1.4630 1.5650 1.5
lin-4.2 w83781d T 910 6.7900 3.7910 14 690 1.5660 1.4660 1.5
lin-4.2 zd1211rw T 930 6.3890 0.96140 11 720 1.5670 1.5660 1.5
lin-3.14 vmxnet3 T 930 6.9890 1.2900 10 540 1.5640 1.4670 1.4
lin-3.14 skge T 950 7.3940 3.6410 15 650 1.5600 1.5670 1.5
lin-3.16 ath5k T 950 5.9950 4.7900 13 710 1.5730 1.5710 1.5
lin-3.14 ipw2200 T 950 7.6950 6.615 0.39700 1.5730 1.5720 1.5
lin-3.14 bttv T 950 5.8910 5.020 0.51720 1.5770 1.4750 1.5
lin-4.2 cciss T 920 7.1330 12 900 4.7790 10 120 0.77180 5.3
floodmax.4 T 910 3.0880 0.53910 13 900 4.3110 0.421100 7.9
sep20 T900 3.2880 0.10910 13 1000 2.6110 0.27150 0.99
Sum 0 100k 1600 0 110k 500 0 110k 1200 120 28k 180 42 24k 130 121 25k 160
Average 720 11 800 3.5760 8.1 200 1.2170 0.89170 1.1
The full version of this table can be found at https://www.sosy-lab.org/research/reducer/ .
1189
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. Reducer-Based Construction of Conditional Verifiers ICSE 2018, May 27 – June 3, 2018, Gothenburg, Sweden
Table 4: Test generation vs. CMC combination
AFL-fuzz Crest Klee Predicate +
AFL-fuzz Crest Klee
Correct alarm 96 44 277 479 476 477
Incorrect proof 0 0 0 0 0 0Unknown 384 436 203 1 4 3
Total 480 480 480 480 480 480
 1 10 100 1000
 1  10  100  1000CPU Time for Identity Reducer with AFL-fuzz (s)
CPU Time for Reducer with AFL-fuzz (s)
Figure5:CPUtimeforpredicateanalysisand AFL-fuzz com-
bined with Reducer (CMC) and with Identity (sequential)
As a result, we get 480tasks. Table 4compares the performance
oftheCMCscenarioswiththetesterperformance.SimilartoTa-ble2, it shows the numbers of correct alarms, incorrect proofs,
and unsolved tasks. However, it leaves out the rows related to safe
verification tasks. We see that for all three test-generation tools
the number of correct alarms of our reducer-based combination
withconditionpassingishigherthanfortherespectivetester.In
general, such an improvement is not only caused by the use of the
verifierA, but often a result of the combination of tools. To further
support this statement, we present Fig. 5. It shows the CPU time of
tworeducer-basedCMCsolutions,bothusingthepredicateanal-
ysismentionedabovetogenerateconditions,usingthefullsetof
1501verificationtaskswithexpectedresult false.Thefirstsolution
(x-axis) uses the reducer Reducer with AFL-fuzz and the second
solution (y-axis) uses the Identity reducer with AFL-fuzz (pure
sequentialcombination). Forbettervisualization, weremovedthe
results that the predicate analysis can solve on its own. Due to the
mentioned blowup of the residual program, the Reducer based
solution(Reducerplus AFL-fuzz)performsworseforsometasks,
but it can also solve a significant amount of tasks faster than the
pure sequential combination (Identity plus AFL-fuzz).
Size of residual programs. As already mentioned, the residual
programcreatedbyReducermaybecomesignificantlylargerthanthe original program. The reason is a large amount of branching in
thecondition,i.e.,unfoldingofloopsandprogramstructure,which
is needed to record the verification work already performed. To
study this in more detail, we compared the sizes of the originaland the residual program in terms of locations in the CFA. At
worst,theresidualprogramwasmorethan 10timeslargerthanthe
originalprogram( 1934vs.22325locations).Atbest,thenumberof
locations in the residual program is less than 1%of the number of
original program locations ( 200253vs.127locations). On average,
theresidualprogramcontainsfewerlocations(withameanof 27%
and a median of 14%of the number of locations in the original
program). While the residual program can be much larger, it is
often much smaller.
4.4 Threats to Validity
We did not cross-check the reported verification results with an
independent verifier because we currently do not know how toconstruct correctness or violation witnesses [
7,8] in the setting
of reducer-based conditional model checking. While we are sure
that the standalone verifiers did a proper inspection (they success-
fully participated in SV-COMP or provide a test), tools might have
guessed the correct answer when run as part of the conditional
verifier.Yet,wethinkthatguessingisunlikely.Thetoolsarelaidout
to provide witnesses and thus properly perform their verification.
Thecorrectnessoftheresidualprogramisanotherthreat.Like
otheranalysistools,werelyonthesoundnessofthetransformationfromprogramtoCFAandback.Additionally,werelyonthesound-
ness of the existing condition generating tool in that the condition
onlycoverspathstheverifierhasalreadyinspected.Furthermore,
ourimplementationofReducerisaprototypewhichrevealedbugs
during evaluation. In principle, the bugs might be the reason for
theeffectivenessofthereducer-base dapproach.Ho wever,thebugs
we observed led the conditional verifier to report a wrong result.
Additionally,wecheckedthenullhypothesisandclaim1only
withasingleconditiongeneratinganalysisandasingleconditional
verifier.Thus,thecorrespondingresultsmightnotbeuniversally
valid in any reducer-based conditional-model-checking setup.
WhenusingacombinationoftwoverificationtoolswithCMC,it
isalsopossiblethattheincreaseinsolvabletasksissimplybecause
the different tools can solve a distinct set of tasks each in a very
shorttime.E.g.,inourconfiguration,itcouldhavebeenpossible
that the full increase in additionally solvable tasks is only due toa competence of the predicate analysis in quickly solving a setof tasks that none of the other verifiers can solve. To make surethat our considered tool combinations actually benefit from theuse of condition passing, we provided a comparison with a pure
sequentialcombination(Identity)thatshowedthegeneralbenefit.
In addition, CPAseqincludes a 200s run of predicate analysis in its
configuration—this ensures that all benefits for our combination
ofCPAseqandpredicateanalysisareactuallyduetoourReducer
approach. Of the 820 tasks considered in the experiments backing
claim2,143cannotbesolvedbyanyofthesequentialcombinations,
but only when using CMC with condition passing.
We onlyconsider asubset of theSV-COMP tasks andthe three
best verifiers from SV-COMP. These three verifiers might be tuned
to SV-COMP tasks and may perform worse on our generated resid-
ualprograms.Despitethispossiblebias,ourapproachstillimproves
the existing verifiers. In addition, the three test-generation tools
usedneverparticipatedinanyeditionofSV-COMPandareunlikely
biased. Our approach still shows improvements for them.
1190
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. ICSE 2018, May 27 – June 3, 2018, Gothenburg, Sweden D. Beyer, M.-C. Jakobs, T. Lemberger, and H. Wehrheim
5 RELATED WORK
Our concept of reducers allows us to combine a condition generat-
ing software verifier with an arbitrary second verifier. Techniques
for combining different verification approaches have intensively
been studied in the past. The approaches are executed in paral-
lel,interleaved,orsequentially.Orthogonally,theapproachesare
integratedinawhite-boxorblack-boxstyle.White-boxcombina-
tions tightly integrate typically orthogonal approaches, whereas
black-box combinations aim at a loose coupling of different tools.ParallelCombinations.
Parallelcombinationsareoftenusedina
white-boxstyleiftheanalysisalgorithmsaresimilar.Typically,com-
binations[ 12,32,33]letdifferentdomainsinteroperatetoobtain
analyses that are more precise than a product combination.InterleavedCombinations.
Interleavedcombinationsareoften
white-boxcombinationsthatunitedifferenttechniquesinoneal-
gorithm. For example, SYNERGY [ 39] and DASH [ 4] perform an
alternation of test generation and proof construction. Test genera-
tionisguidedbytheabstracterrorpathsandtheabstractionforthe
proofconstructionisadaptedaccordingtothetests.SMASH[ 38]
combinesunderapproximationwithoverapproximation.Incontrast,
abstraction-driven concolic testing [ 36] is a black-boxintegration
thatalternatesconcolictestingwithmodelchecking.Themaingoal
of the model checker is to identify and exclude infeasible paths.
Giventheopentestgoals(encodedaserrorlocations),themodel
checkerbuildsanabstractreachabilitygraph(ARG).ThebuiltARGssuccessivelyrestrictthe(original)programconsideredbythetester,
i.e., after each model-checking run the new program for the tester
becomes the intersection of its previous program with the ARG.Sequential Combinations Testifying Verification Result.
Manysequentialcombinationsaimatexcludingfalsealarmsafter
animprecisestaticanalysis,typicallyusingablack-boxcombina-
tion. For example, Blast[6], Check’n’Crash [ 34], DyTa [37], and
SANTE [ 28] try to build a test case for each alarm and only re-
port those alarms that are backed by a test. Post et al. [ 53] and
CPAchecker [57] use bounded model checking to check whether
an alarm is realizable. Residual investigation [ 51] tries to reduce
the number of false or irrelevant alarms. It only reports alarms for
whichdynamicanalysisobservedprogrambehaviorindicatingthat
a warning is appropriate. In contrast, proof-carrying code (PCC)
approaches[ 44,52]checka completeproof.Standardizedverifier
exchange formatslike correctnessor errorwitnesses [ 7,8] enable
cross-checks between different tools.Sequential Combinations Splitting Verification Effort.
Pro-
gram partitioning [ 46] suggests to use the test data to partition the
control-flowgraph(CFG)intotestedandnot-tested.Thenon-tested
partition, a subgraph of the CFG, is analyzed by a static analyzer.
Conditional model checking [ 10] uses a sequential combination:
A first verifier constructs a condition summarizing the performed
verification,thenextverifierusesthatconditiontosteeritsverifi-
cation. We use the same idea for the first verifier, but we transform
the condition into a residual program checked by the next verifier.
Multi-goalreachabilityanalysisfortesting[ 13]reusesthever-
ification effort of one (test) goal for another one. The idea is to
transform the ARG that was built to achieve the test goal, s.t. it fitsforanewtestgoal.Thetest-goalautomatacanbeseenasconditions
encoding sets of program paths.Christakisetal.[ 29,30]proposethataverifiershouldaddpro-
gram annotations stating which assertions under which conditions
wereverified.Intheexperiments, thestaticanalyzerClousotpro-
duces annotations that guide the exploration of the tester PEX.
Czechetal.[ 35]useconditionsandaresidual-programconstruc-
tiontocombinemodelcheckingandtestinginthecontextofsafety
checking. They propose two basic program constructions. Theirsynchronouscompositionofconditionandprogramissimilartoour Reducer. However, they consider a restricted class of condi-
tionsandthusdonotneedtoconsiderassumptionsnorprogram
paths that are not covered by the condition. The second approach
slices the program for assertions that are not fully verified.GeneratingProgramsfromVerificationResults.
Programpar-
titioning [ 46] extracts a subgraph of the program which has not
been tested. Abstraction-driven concolic testing [ 36] computes a
program from the intersection of an ARG and a program. A similar
idea,namelyusingARGstogenerateprograms,hasalreadybeen
proposed in a PCC context [ 45,58]. Czech et al. [ 35] compute a
synchronous combination of condition and program. As alreadymentioned, our residual-program construction is similar to theapproach of Czech et al. [
35]. Our implementation constructs an
ARG,representingthecombinationofconditionandcontrol-flow
graph,whichis translatedintoaprogram.Incontrast toprogram
partitioning [46], the generated programs need not be subgraphs.
6 CONCLUSION
Softwareverificationisanundecidableproblem,butstill,almostalllive-criticalsystemsarecontrolledbysoftware,andthus,weneedto
verifytheselargesoftwaresystems.Oneresearchdirectionistode-
velop faster verification algorithms and theories; another direction
is to leverage existing results by combinations. Our contribution
fallsintothesecondresearcharea.Conditionalmodelcheckingisa
promising approach to combine the strengths of different verifiers.
However, it is a large effort to make a verifier understand and use
theconditionthatdescribeswhatthefirstverifieralreadyachieved.
To solve this problem, we propose an easy, automatic template
construction that turns an off-the-shelf verifier into one that un-
derstandsconditions.Ourideaistouseapreprocessor,thereducer,
which takes the condition and the original program to compute
aresidualprogram.Theresidualprogramencodestheremaining
verificationtaskinaformatthatisunderstandablebyeveryverifier:
programcode.Inthispaper,wesuggestedonepossiblereducer.Our
experiments on hard tasks of the SV-COMP benchmark collection
showthatourreducer-basedCMCsolutioniseffective.Usingthe
new combination technique, we can solve many verification tasks
thatwerenotsolvablebefore,andthusadvancethefrontierofwhat
is possible with existing software verifiers.
Themainconclusionfromourexperimentsisthatweneedmany
conditional verifiers, but that it is not worth the effort to changeexisting verifiers. Rather we can simply apply our constructionto get
kconditional verifiers from karbitrary existing verifiers,
without changing one line of code. Even if the task is to find crash-
ing test cases with state-of-the-art test-generation tools, we cansignificantly increase the number of found bugs by using a plug-
and-playconstructionthatdoesnotcostanydevelopmenteffort,
but increases the number of valuable test cases significantly.
1191
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. Reducer-Based Construction of Conditional Verifiers ICSE 2018, May 27 – June 3, 2018, Gothenburg, Sweden
REFERENCES
[1]A. V. Aho, R. Sethi, and J. D. Ullman. 1986. Compilers: Principles, Techniques, and
Tools. Addison-Wesley. http://www.worldcat.org/oclc/12285707
[2]T. Ball and S. K. Rajamani. 2002. The Slam Project: Debugging System Software
via Static Analysis. In Proc. POPL. ACM, 1–3. https://doi.org/10.1145/503272.
503274
[3]M.Barnett,B.-Y.E.Chang,R.DeLine,B.Jacobs,andK.R.M.Leino.2005. Boo-
gie: AModularReusable Verifier forObject-Oriented Programs.In Proc.FMCO
(LNCS 4111). Springer, 364–387. https://doi.org/10.1007/11804192_17
[4]N. E. Beckman, A. V. Nori, S. K. Rajamani, and R. J. Simmons. 2008. Proofs from
Tests. InProc. ISSTA. ACM, 3–14. https://doi.org/10.1145/1390630.1390634
[5]D.Beyer.2017. SoftwareVerificationwithValidationofResults(ReportonSV-
COMP2017).In Proc.TACAS(LNCS10206).Springer,331–349. https://doi.org/10.
1007/978-3-662-54580-5_20
[6]D. Beyer, A. J. Chlipala, T. A. Henzinger, R. Jhala, and R. Majumdar. 2004.
Generating Tests from Counterexamples. In Proc. ICSE. IEEE, 326–335. https:
//doi.org/10.1109/ICSE.2004.1317455
[7]D. Beyer, M. Dangl, D. Dietsch, and M. Heizmann. 2016. Correctness Witnesses:
ExchangingVerificationResultsBetweenVerifiers.In Proc.FSE.ACM,326–337.
https://doi.org/10.1145/2950290.2950351
[8]D. Beyer,M. Dangl, D.Dietsch, M. Heizmann,and A. Stahlbauer.2015. Witness
ValidationandStepwiseTestificationAcrossSoftwareVerifiers.In Proc.ESEC/FSE.
ACM, 721–733. https://doi.org/10.1145/2786805.2786867
[9]D. Beyer, M. Dangl, and P. Wendler. 2015. Boosting k-Induction with
Continuously-RefinedInvariants.In Proc.CAV(LNCS9206).Springer,622–640.
https://doi.org/10.1007/978-3-319-21690-4_42
[10]D.Beyer,T.A.Henzinger,M.E.Keremoglu,andP.Wendler.2012. Conditional
Model Checking: A Technique to Pass Information Between Verifiers. In Proc.
FSE. ACM, 57. https://doi.org/10.1145/2393596.2393664
[11]D. Beyer, T. A. Henzinger, and G. Théoduloz. 2007. Configurable Software
Verification: Concretizing the Convergence of Model Checking and Program
Analysis.In Proc.CAV(LNCS4590).Springer,504–518. https://doi.org/10.1007/
978-3-540-73368-3_51
[12]D. Beyer, T. A. Henzinger, and G. Théoduloz. 2008. Program Analysis with
Dynamic Precision Adjustment. In Proc. ASE. IEEE, 29–38. https://doi.org/10.
1109/ASE.2008.13
[13]D. Beyer, A. Holzer, M. Tautschnig, and H. Veith. 2013. Information Reuse for
Multi-goal ReachabilityAnalyses. In Proc. ESOP(LNCS 7792). Springer, 472–491.
https://doi.org/10.1007/978-3-642-37036-6_26
[14]D.Beyer,M.-C.Jakobs,T.Lemberger,andH.Wehrheim.2018.ReplicationPackage
for Article “Reducer-Based Construction of Conditional Verifiers”, Proc. ICSE’18.
https://doi.org/10.5281/zenodo.1172228
[15]D. Beyer and M. E. Keremoglu. 2011. CPAchecker: A Tool for Configurable
SoftwareVerification.In Proc.CAV(LNCS6806) .Springer,184–190. https://doi.
org/10.1007/978-3-642-22110-1_16
[16]D. Beyer, M. E. Keremoglu, and P. Wendler. 2010. Predicate Abstraction with
Adjustable-BlockEncoding.In Proc.FMCAD.IEEE,189–197. http://ieeexplore.
ieee.org/document/5770949/
[17]D. Beyer and T. Lemberger. 2017. Software Verification: Testing vs. Model
Checking. In Proc. HVC (LNCS 10629). Springer, 99–114. https://doi.org/10.1007/
978-3-319-70389-3_7
[18]D. Beyer and S. Löwe. 2013. Explicit-State Software Model Checking Basedon CEGAR and Interpolation. In Proc. FASE (LNCS 7793). Springer, 146–162.
https://doi.org/10.1007/978-3-642-37057-1_11
[19]D. Beyer, S. Löwe, and P. Wendler. 2015. Benchmarking and Resource Mea-
surement. In Proc. SPIN (LNCS 9232). Springer, 160–178. https://doi.org/10.1007/
978-3-319-23404-5_12
[20]D. Beyer, S. Löwe, and P. Wendler. 2015. Refinement Selection. In Proc. SPIN
(LNCS 9232). Springer, 20–38. https://doi.org/10.1007/978-3-319-23404-5_3
[21]D.Beyer,S.Löwe,andP.Wendler.2015. SlicedPathPrefixes:AnEffectiveMethod
toEnableRefinementSelection.In Proc.FORTE(LNCS9039).Springer,228–243.
https://doi.org/10.1007/978-3-319-19195-9_15
[22]ArminBiere, AlessandroCimatti, EdmundM.Clarke, OferStrichman, andYun-
shan Zhu. 2003. Bounded Model Checking. Advances in Computers 58 (2003),
117–148. https://doi.org/10.1016/S0065-2458(03)58003-2
[23]M.Böhme,V.-T.Pham,andA.Roychoudhury.2016. Coverage-basedGreybox
FuzzingasMarkovChain.In Proc.SIGSAC .ACM,NewYork,NY,USA,1032–1043.
https://doi.org/10.1145/2976749.2978428
[24]A. R. Bradley. 2011. SAT-Based Model Checking without Unrolling. In Proc.
VMCAI(LNCS6538).Springer,70–87. https://doi.org/10.1007/978-3-642-18275-4_
7
[25]J. Burnim and K. Sen. 2008. Heuristics for Scalable Dynamic Test Generation. In
Proc. ASE. IEEE, 443–446. https://doi.org/10.1109/ASE.2008.69
[26]C. Cadar, D. Dunbar, and D. R. Engler. 2008. KLEE: Unassisted and Automatic
GenerationofHigh-CoverageTestsforComplexSystemsPrograms.In Proc.OSDI.
USENIX Association, 209–224. http://www.usenix.org/events/osdi08/tech/full_
papers/cadar/cadar.pdf[27]M.Chalupa,M.Vitovská,M.Jonás,J.Slaby,andJ.Strejcek.2017. Symbiotic4:
BeyondReachability(CompetitionContribution).In Proc.TACAS(LNCS10206).
Springer, 385–389. https://doi.org/10.1007/978-3-662-54580-5_28
[28]O. Chebaro, N. Kosmatov, A. Giorgetti, and J. Julliand. 2012. Program Slicing
Enhances a Verification Technique Combining Static and Dynamic Analysis. InProc. SAC. ACM, 1284–1291. https://doi.org/10.1145/2245276.2231980
[29]
M.Christakis,P.Müller,andV.Wüstholz.2012. CollaborativeVerificationand
TestingwithExplicitAssumptions.In Proc.FM(LNCS7436).Springer,132–146.
https://doi.org/10.1007/978-3-642-32759-9_13
[30]M. Christakis, P. Müller, and V. Wüstholz. 2016. Guiding Dynamic Symbolic
Execution Toward Unverified Program Executions. In Proc. ICSE. ACM, 144–155.
https://doi.org/10.1145/2884781.2884843
[31]E. M. Clarke, O. Grumberg, S. Jha, Y. Lu, and H. Veith. 2003. Counterexample-
guided Abstraction Refinement for Symbolic Model Checking. J. ACM50, 5
(2003), 752–794. https://doi.org/10.1145/876638.876643
[32]P.CousotandR.Cousot.1979. SystematicDesignofProgramAnalysisFrame-
works. In POPL. ACM Press, 269–282. https://doi.org/10.1145/567752.567778
[33]P. Cousot, R. Cousot, J. Feret, L. Mauborgne, A. Miné, D. Monniaux, and X. Rival.
2006. CombinationofAbstractionsintheASTRÉEStaticAnalyzer.In Proc.ASIAN
(LNCS 4435). Springer, 272–300. https://doi.org/10.1007/978-3-540-77505-8_23
[34]C. Csallner and Y. Smaragdakis. 2005. Check ’N’ Crash: Combining Static Check-
ingandTesting.In Proc.ICSE.ACM,422–431. https://doi.org/10.1145/1062455.
1062533
[35]M. Czech, M.-C. Jakobs, and H. Wehrheim. 2015. Just Test What You Cannot
Verify!. In Proc. FASE (LNCS 9033). Springer, 100–114. https://doi.org/10.1007/
978-3-662-46675-9_7
[36]P. Daca, A. Gupta, and T. A. Henzinger. 2016. Abstraction-Driven Concolic
Testing. In Proc. VMCAI (LNCS 9583). Springer, 328–347. https://doi.org/10.1007/
978-3-662-49122-5_16
[37]X. Ge, K. Taneja, T. Xie, and N. Tillmann. 2011. DyTa: Dynamic Symbolic Ex-ecution Guided with Static Verification Results. In Proc. ICSE. ACM, 992–994.
https://doi.org/10.1145/1985793.1985971
[38]P. Godefroid, A. V. Nori, S. K. Rajamani, and S. Tetali. 2010. Compositional
May-mustProgramAnalysis:UnleashingthePowerofAlternation.In Proc.POPL.
ACM, 43–56. https://doi.org/10.1145/1706299.1706307
[39] B. S. Gulavani, T. A. Henzinger, Y. Kannan, A. V. Nori, and S. K. Rajamani. 2006.
SYNERGY:ANewAlgorithmforPropertyChecking.In Proc.FSE.ACM,117–127.
https://doi.org/10.1145/1181775.1181790
[40]M. Heizmann, Y.-W. Chen, D. Dietsch, M. Greitschus, A. Nutz, B. Musa, C. Schät-
zle, C. Schilling, F. Schüssele, and A. Podelski. 2017. Ultimate Automizer with
an On-Demand Construction of Floyd-Hoare Automata (Competition Contribu-
tion).InProc.TACAS(LNCS 10206).Springer,394–398. https://doi.org/10.1007/
978-3-662-54580-5_30
[41]M. Heizmann, J. Hoenicke, and A. Podelski. 2013. Software Model Checking
for People Who Love Automata. In Proc. CAV (LNCS 8044). Springer, 36–52.
https://doi.org/10.1007/978-3-642-39799-8_2
[42]T.A.Henzinger,R.Jhala,R.Majumdar,andK.L.McMillan.2004. Abstractions
fromProofs.In Proc.POPL.ACM,232–244. https://doi.org/10.1145/964001.964021
[43]T. A. Henzinger, R. Jhala, R. Majumdar, and G. Sutre. 2002. Lazy Abstraction. In
Proc. POPL. ACM, 58–70. https://doi.org/10.1145/503272.503279
[44]M.-C. Jakobs and H. Wehrheim. 2014. Certification for Configurable Program
Analysis. In Proc. SPIN. ACM, 30–39. https://doi.org/10.1145/2632362.2632372
[45]M.-C. Jakobs and H. Wehrheim. 2015. Programs from Proofs of PredicatedDataflow Analyses. In Proc. SAC. ACM, 1729–1736. https://doi.org/10.1145/
2695664.2695690
[46]P. Jalote, V. Vangala, T. Singh, and P. Jain. 2006. Program Partitioning: A Frame-
work for Combining Static and Dynamic Analysis. In Proc. WODA. ACM, 11–16.
https://doi.org/10.1145/1138912.1138916
[47]R. Jhala and R. Majumdar. 2009. Software Model Checking. Comput. Surveys 41,
4, Article 21 (2009), 54 pages. https://doi.org/10.1145/1592434.1592438
[48]A. V. Khoroshilov, V. S. Mutilin, A. K. Petrenko, and V. Zakharov. 2009. Es-
tablishing Linux Driver Verification Process. In Proc. Ershov Memorial Confer-
ence (LNCS 5947). Springer, Berlin, Heidelberg, 165–176. https://doi.org/10.1007/
978-3-642-11486-1_14
[49]Y.KörogluandA.Sen.2016. DesignofaModifiedConcolicTestingAlgorithm
with Smaller Constraints. In Proc. CSTVA@ISSTA (CEUR 1639). CEUR-WS.org,
3–14.http://ceur-ws.org/Vol-1639/paper-03.pdf
[50]A. Lal, S. Qadeer, and S. K. Lahiri. 2012. A Solver for Reachability Modulo
Theories.In Proc.CAV(LNCS7358).Springer,427–443. https://doi.org/10.1007/
978-3-642-31424-7_32
[51]K. Li, C. Reichenbach, C. Csallner, and Y. Smaragdakis. 2014. Residual Investiga-
tion: Predictive and Precise Bug Detection. ACM Transactions on Software Engi-
neering and Methodology 24, 2 (2014), 7:1–7:32. https://doi.org/10.1145/2656201
[52]G. C. Necula. 1997. Proof-Carrying Code. In Proc. POPL. ACM Press, 106–119.
https://doi.org/10.1145/263699.263712
[53]H. Post, C. Sinz, A. Kaiser, and T. Gorges. 2008. Reducing False Positives by
Combining Abstract Interpretation and Bounded Model Checking. In Proc. ASE.
IEEE, 188–197. https://doi.org/10.1109/ASE.2008.29
1192
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. ICSE 2018, May 27 – June 3, 2018, Gothenburg, Sweden D. Beyer, M.-C. Jakobs, T. Lemberger, and H. Wehrheim
[54]Z. Rakamaric and M. Emmi. 2014. SMACK: Decoupling Source Language Details
from Verifier Implementations. In Proc. CAV (LNCS 8559). Springer, 106–113.
https://doi.org/10.1007/978-3-319-08867-9_7
[55]H. Seo and S. Kim. 2014. How We Get There: A Context-guided Search Strategy
in Concolic Testing. In Proc. FSE. ACM, 413–424. https://doi.org/10.1145/2635868.
2635872
[56]N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang, J. Corbetta, Y. Shoshi-
taishvili, C. Kruegel, and G. Vigna. 2016. Driller: Augmenting Fuzzing
Through Selective Symbolic Execution. In Proc. NDSS. The Internet Soci-
ety.http://wp.internetsociety.org/ndss/wp-content/uploads/sites/25/2017/09/driller-augmenting-fuzzing-through-selective-symbolic-execution.pdf
[57]P.Wendler.2013. CPAcheckerwithSequentialCombinationofExplicit-State
Analysis and Predicate Analysis (Competition Contribution). In Proc. TACAS
(LNCS 7795). Springer, 613–615. https://doi.org/10.1007/978-3-642-36742-7_45
[58]D.Wonisch,A.Schremmer,andH.Wehrheim.2013. ProgramsfromProofs-A
PCCAlternative.In Proc.CAV(LNCS8044).Springer,912–927. https://doi.org/10.
1007/978-3-642-39799-8_65
[59]Q. Yi, Z. Yang, S. Guo, C. Wang, J. Liu, and C. Zhao. 2015. Postconditioned
Symbolic Execution. In Proc. ICST. IEEE, 1–10. https://doi.org/10.1109/ICST.2015.
7102601
1193
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. 