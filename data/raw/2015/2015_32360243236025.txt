DataRace DetectiononCompressedTraces
DileepKini
AkunaCapital LLC
USA
dileeprkini@gmail.comUmang Mathur
Universityof Illinois,Urbana
Champaign
USA
umathur3@illinois.eduMahesh Viswanathan
Universityof Illinois,Urbana
Champaign
USA
vmahesh@illinois.edu
ABSTRACT
We consider the problem of detecting data races in program traces
that have been compressed using straight line programs (SLP),
which are special context-free grammars that generate exactly one
string, namely the trace that they represent. We consider two clas-
sical approaches to race detection Ð using the happens-before
relation and the lockset discipline. We present algorithms for both
these methods that run in time that is linear in the size of the
compressed, SLP representation. Typical program executions al-
mostalwaysexhibitpatternsthatleadtosignificantcompression.
Thus,ouralgorithmsareexpectedtoresultinlargespeedupswhen
compared with analyzing the uncompressed trace. Our experimen-
tal evaluation of these new algorithms on standard benchmarks
confirmsthis observation.
CCS CONCEPTS
·Software and its engineering →Software testing and de-
bugging;Formal softwareverification ;
KEYWORDS
DynamicProgram Analysis,RaceDetection, Compression
ACMReference Format:
Dileep Kini, Umang Mathur, and Mahesh Viswanathan. 2018. Data Race
Detection on Compressed Traces. In Proceedings of the 26th ACM Joint Eu-
ropean Software Engineering Conference and Symposium on the Foundations
of Software Engineering (ESEC/FSE ’18), November 4ś9, 2018, Lake Buena
Vista, FL, USA. ACM, New York, NY, USA, 12pages.https://doi.org/10.1145/
3236024.3236025
1 INTRODUCTION
Dynamic analysis of multi-threaded programs is the problem of
discovering anomaliesin a programby examining asingle or mul-
tiple traces of a program. While dynamic analysis is sometimes
performed online as the program is running, it is often performed
offline,onastoredtraceoftheprogram.Thereasonsforperforming
offlinedynamicanalysisaremany.Theoverheadofanalyzingthe
trace astheprogram is running maybe large, causingundesirable
slowdowns.Thisis especiallytrue forexpensive dynamicanalysis
techniques which employ heavy-weight machinery such as the
Permissionto make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthefirstpage.Copyrights forcomponentsofthisworkownedbyothersthanthe
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ESEC/FSE ’18, November 4ś9, 2018, Lake BuenaVista,FL,USA
©2018 Copyright heldby the owner/author(s). Publicationrightslicensed to ACM.
ACM ISBN 978-1-4503-5573-5/18/11...$15.00
https://doi.org/10.1145/3236024.3236025use of SMT solvers [ 24,48], graph based analysis [ 7,22] or even
vector clocks [ 20,43]. Often, it is desirable to perform multiple,
different analyses on a single trace, and the kinds of analyses to
be performed may even be unknown at the time the program is
beingobserved.Finally,storingthetraceandlaterreplayingitin
acontrolledenvironment,canhelpindebuggingprograms,inun-
derstanding performance overheads and in performance tuning.
Trace-driven simulations are used widely in computer architecture
for quantitative evaluations of newideasanddesigns[ 26,37].
However program traces are often huge, recording millions and
billions of events. When debugging a large software application,
long tracesare oftennecessary toensure adequatecode coverage.
This is especially acute for multi-threaded programs where subtle
concurrency bugs are often revealed only under specific thread
schedules. Therefore, useful traces are those that exercise the same
programfragmentmultipletimes,underdifferentscenarios;thisis
substantiated by the observation that some concurrency bugs only
manifest themselves in traces with millions of events [ 14]. In such
circumstances, the only way to alleviate the warehousing needs of
storingsuch traces isto compress them[ 26,37].
In this paper, we study the problem of detecting data races in
programsbyexaminingcompressedtraces.Dataracesarethemost
common symptom of a programming error in concurrent program-
ming. The naïve approach to solving this problem would be to
uncompress the trace and then process it using any one of the
manyalgorithmsthathavebeendevelopedfordynamicdatarace
detection [ 18,20,24,29,36,43,49]. But is this necessary? Is this
naïve algorithm, asymptotically, the best one can hope for? Study-
ing the complexity of problems where the input is represented
succinctlyhasalonghistory.Startingfromtheseminalpaperby
GalperinandWigderson[ 23],wheretheystudiedthecomplexity
ofgraphproblemswhentheinputgraphisrepresentedbyacircuit,
it has been observed that typically there is an exponential blowup
inthecomplexityofproblemswhentheyaresolvedoncompressed
inputs[6,11,16,23,35,42,54].Thus,oftenthenaïvealgorithmis
the bestalgorithm asymptotically.
Our results in this paper, fortunately, are the exception to the
aboverule.WeconsidertwoclassicalracedetectionapproachesÐa
sound1methodbasedoncomputingLamport’shappens-beforerela-
tion[32],andthelightweightlockset-basedalgorithmofEraser[ 49]
Ð and extend them to work directly on the compressed trace with-
outfirstuncompressingit.Ouralgorithmsrunintimethatislinear
inthesizeofthecompressedtrace.Thus,weshowthatcompres-
sion can in fact be used as an algorithmic principle to speedup the
analysisinthis context.
1We say a race detector is sound if it never issues any warning on race-free programs
orexecutions.Thisisoften referred to as precise[20] in the race detectionliterature.
26
ESEC/FSE’18,November4ś9, 2018, Lake Buena Vista,FL,USA Dileep Kini, Umang Mathur, andMahesh Viswanathan
public class Testextends Thread{
static final longITERS= 1000000000L;
staticinty;
publicvoidinc() {
y++;
}
@Override
publicvoidrun() {
for(longi= 0;i<ITERS;i++) {
inc();
}
}
public static voidmain(String args [])throwsException {
finalTest t1 =newTest();
finalTest t2 =newTest();
t1.start();
t2.start();
t1.join();
t2.join();
System.out.println("y (actual) = " +y);
System.out.println("y (expected) = " +ITERS*2);
}
}Figure 1:Asimpleconcurrentprogram inJava
Tounderstandwhycompressionactuallyspeedsuptheanalysis,
considerthe simple program shown inFigure 1. A singleexecution
ofthisprogramgeneratesabout680millionevents,takingabout1.3
GBdiskspace.However,whenthistraceiscompressedusingthe
Sequitur algorithm [ 2,40,41], the compressed representation only
occupiesabout34MBofdiskspace.Thereasonforthiseffective
compressionisthattheprogramhasasimpleloopstructurethat
is executed multiple times. Thus the program trace has a łregularž
structure that the compression algorithm exploits. An algorithm
processing the uncompressed trace is agnostic to this regularity,
andisforcedtorepeatthesameanalysiseachtimethesub-trace
correspondingtotheloopbodyisencountered.Compressionmakes
this regular structure łvisiblež, and an algorithm working on the
compressed representation can exploit it by only performing an
analysisonly oncefor eachdistinct sub-trace.
Weconsidercompressionschemesthatcompresstracesasstraight
line programs (SLPs). SLPs are a special class of context-free gram-
marswherethelanguageofthegrammarconsistsofasinglestring,
namely,thetracebeingcompressed.Severallosslesscompression
schemes, like run-length encoding and the family of Lempel-Ziv
encodings [ 62], can be converted efficiently to SLPs of similar
size. Ouralgorithmson SLPsproceed inductivelyon thestructure
of the grammar, and compute, in a compositional fashion, book-
keeping informationfor eachnon-terminalinthe grammar.Thus,
a sub-tracegeneratedbyanon-terminal thatmayappear in many
positions in the uncompressed trace, is analyzed only once. For
happens-before-based race detection, our algorithm is inspired by
theGoldilocksmethod [ 12], where thebook-keepinginformation
iscapturedbyasetofthreads andlocks.
We have implemented our algorithms in a tool called ZipTrack .
ThetracesarecompressedusingapopularSLP-basedcompresssion
algorithm called Sequitur [ 2]. Our experiments on standard bench-
mark examples reveal that the algorithms on compressed traces
performwell,andonlargetraces,oftenhaveanorderofmagnitude
improvementoveralgorithmsrunningintheuncompressedsetting.
The rest of the paper is organized as follows. After discussing
closely related work, we introduce basic notation and classical
race detection algorithms in Section 2. In Section 3, we briefly
present our happens-before based data race detection algorithm
on compressed traces. Our algorithm for checking violations ofthelocksetdisciplineoncompressedtracesispresentedbrieflyin
Section4.Detailsofthesealgorithmsandtheirproofofcorrectness
arepresentedinourcompaniontechnicalreport[ 30].Wepresent
our experimental results inSection 5.
Related Work. Type systems topreventdataraces have beende-
veloped [ 5,9,19]. Since the race detection problem is undecidable,
theseveralstaticanalysistechniques[ 13,38,39,44,46,55,58,61]
sufferfromtwoproblemsÐtheydon’tscaleandtheyraisemany
false alarms since they are typically conservative. Dynamic race
detection techniquescan beclassifiedintothree categories.There
aretheunsoundlockset-basedtechniques,whichmayraisefalse
alarms [49]. Techniques like random testing [ 50] and static escape
analysis [ 45] can reduce the false alarms in such algorithms, but
not eliminate them. The second category of dynamic analysis tech-
niquesarepredictiveruntimeanalysistechniques[ 24,25,34,48,56],
where the race detector explores all possible reorderings of the
given trace to search for a possible witness of a data race. Since
the number of interleavings of a given trace is very large, these
donotscaletolongtraces.Thelastcategoryofdynamicracede-
tection algorithms are those based on identifying a partial order
ontheeventsofatrace,andthensearchingforapairofconflict-
ing data accesses that are unordered by the partial order. These
techniquesaresoundandscaletolongtracessincetheytypically
run inlineartime. The simplest,andmostcommonly usedpartial
orderishappens-before[ 32].Earlyvector-clockbasedalgorithms
to compute happens-before on traces [ 18,36] have been subse-
quently optimized [ 20,43]. A lockset-based method for computing
the happens-before partial orderwasproposed in [ 12]. Structured
parallelismhasbeenexploitedtooptimizethememoryoverheadin
detecting happens before [ 10,17,47,53,60]. More recently, partial
order that are weaker than happens before have been proposed for
detecting data races, including causal precedence [ 51] and weak
causal precedence [ 29].Sofya[31] andRoadRunner [21] are tools
thatprovideaframeworkforimplementingdynamicanalysistools.
2 PRELIMINARIES
In the sectionwe introduce basic notation,our assumptions about
concurrent programs, the happens before ordering on events, and
someclassicalalgorithms for racedetection.
Traces.Wewillanalyzetracesofconcurrentprogramssynchroniz-
ingthroughlockswhileaccessingsharedmemorylocations(also
referredtoasglobalvariables,orsimply,variables).Tracesare(fi-
nite)sequencesofeventsoftheform ⟨t:o⟩,wheretisthethread
performing the operation o2. Operations can be one of the follow-
ing:forkingofanewchildthread( fork(t));joiningofachildthread
(join(t));acquiringandreleasingalock( acq(ℓ)andrel(ℓ));and,
readingandwritingtoavariable( r(x)andw(x)).Wewillassume
that achildthread isforked andjoined bythe sameparent thread.
Locksareassumedtobe reentrant.Thatis,athread tmayacquirea
lockℓmultiple times, as long as tholdsℓ. However, tmust release
ℓ, as many times as it was acquired, before ℓbecomes available for
2Formally, each event in a trace is assumed to have a unique event id. Thus, two
occurences of a thread performing the same operation will be considered different
events. Eventhoughwe will implicitlyassumetheuniqueness of eacheventina trace,
to reducenotationaloverhead, wedo not formally introduce eventids.
27Data RaceDetectionon CompressedTraces ESEC/FSE’18,November4ś9, 2018, Lake Buena Vista,FL,USA
Thread 1 Thread 2
1w(x)
2fork(2)
3 r(x)
4 acq(ℓ)
5 w(y)
6 rel(ℓ)
7r(x)
8acq(ℓ)
9rel(ℓ)
10w(y)
11 r(x)
12 acq(ℓ)
13 w(y)
14 rel(ℓ)
15join(2)
16w(y)S→AB
A→CD
C→EF
E→⟨1 :w(x)⟩⟨1 :fork(2)⟩
F→⟨2 :r(x)⟩⟨2 :acq(ℓ)⟩⟨2 :w(y)⟩⟨2 :rel(ℓ)⟩
D→⟨1 :r(x)⟩⟨1 :acq(ℓ)⟩⟨1 :rel(ℓ)⟩⟨1 :w(y)⟩
B→FG
G→⟨1 :join(2)⟩⟨1 :w(y)⟩
Figure 2: Example trace σ1and itsSLP representation
beingacquiredbysomeotherthread.Therefore,witheveryrelease
evente=⟨t:rel(ℓ)⟩, we can associate a unique acquire event
e′=⟨t:acq(ℓ)⟩,whichisthelast acq(ℓ)-eventinthread tbefore
ethat is not matched with any rel(ℓ)event in thread tbeforee.
Thisacq(ℓ)evente′issaidto bethe matchingacquire of e,andis
denoted by match(e). Similarly, for an acquire event e′such that
e′=match(e), we will say that eis the matching release of e′, and
wewillalsodenotethisby match(e′).Foratrace σ,σ↾twilldenote
the subsequenceofeventsperformedbythread t.
Notation. Let us fix a trace σ. For an event e, we will say e∈σto
denotethefactthat eappearsinthesequence σ.Thesetoflocks
acquired or released in σwill be denoted by Locks(σ).Threads(σ)
willdenotethesetofthreadsperformingsomeeventin σ;inthe
presenceofforksandjoins,this isabit subtleandwe defineitas
Threads(σ)={t|∃e∈σ.e=⟨t:o⟩for some o,ore=⟨t′:fork(t)⟩
ore=⟨t′:join(t)⟩for somethread t′}.
Foravariable x,thesetof w(x)-eventswillbedenotedby WEvents σ(x)
andthesetof r(x)-eventsperformedbythread t∈Threads(σ)will
be denoted by REvents σ(t,x). We will use Rd(σ)to denote the set
ofpairs(t,x)forwhich REvents σ(t,x)/nequal∅.Similarly,wewilluse
Wr(σ)to denote the set of variables xfor which WEvents σ(x)is
non-empty.When σisclear from the context,we maydropit.
For a non-empty subset of events S, we will denote by Lastσ(S)
the (unique) event e∈S, that is latest in σamong the events
inS. Similarly, Firstσ(S)is the event e∈Sthat is earliest in σ
amongsttheeventsin S.WhenSisempty,wesayboth Firstσ(S)
andLastσ(S)are undefined.
Example 2.1. We illustrate the above definitions on the exam-
ple trace σ1shown in Figure 2. We will follow the convention
ofrepresentingeventsofatracefromtop-to-bottom,wheretem-
porally earlier events appear above the later ones. We use eito
denote the ith event in σ1. LetS1=REvents σ1(2,x)={e3,e11}
andS2=WEvents σ1(y)={e5,e10,e13,e16}. The set Rd(σ1)=
{(1,x),(2,x)}whileWr(σ1)={x,y}. Finally,Lastσ1(S1)=e11, and
Firstσ1(S2)=e5.
OrdersonTraces. Letusfixatrace σ.Ifanevent e1appearsearlier
in the sequence σthane2, then we say e1istrace ordered before
e2anddenoteitas e1<σ
tre2.Wesaye1isthreadorderedbefore e2,denoted by e1<σ
TOe2, ife1ande2are events performed by the
samethreadand e1<σ
tre2.Ourracedetectionalgorithmwillrely
oncomputingthe happensbefore strictorder,whichwedefinenext.
Definition2.2(HappensBefore). Eventeintraceσsaidtohappen
beforeevente′∈σ, denoted e<σ
HBe′, if and only if there is a
sequenceofevents e=e1,e2,e3,...en=e′suchthatforeverypair
(ei,ei+1)(i<n),ei<σ
trei+1andoneof the following holds.
(1)ei<σ
TOei+1,
(2)ei=⟨t:rel(ℓ)⟩andei+1=⟨t′:acq(ℓ)⟩for some t,t′,ℓ,
(3)ei=⟨t:fork(t′)⟩andei+1=⟨t′:o⟩for some t,t′,o,or
(4)ei=⟨t′:o⟩andei+1=⟨t:join(t′)⟩for some t,t′,o.
For anyP∈{tr,TO,HB},≤σ
Prefers to the partial relation <σ
P
∪=σ, where=σdenotes the identity relation on the events of σ.
Whenσisclearfromthecontextwewilldropthesuperscriptfrom
theserelations; for example,we willuse ≤HBinstead of≤σ
HB.
Finally,wesayapairofevents e1,e2areconcurrent (w.r.t.hap-
pensbefore)ifneither e1≤HBe2, nore2≤HBe1; we denote this by
e1||HBe2.
Wenowdefineracesidentifiedbythehappens-beforerelation.
A pair of events e1=⟨t1:a1(x)⟩ande2=⟨t2:a2(x)⟩(for some
variablex)issaidtobe conflicting ,denoted e1≍e2,ift1/nequalt2andat
leastoneoutof a1anda2isw.Atraceσissaidtohavea happens
before race (HB-race, for short) if there is a pair of events e1,e2∈σ
such that e1≍e2ande1||HBe2.
Example 2.3. We illustrate the happens before relation through
thetraceσ1inFigure 2.e1≤HBe3becausee2happensbeforeevery
event in thread 2since it forks thread 2. Similarly, we can conclude
thate13≤HBe16becausethejoinevent e15isaftereveryeventin
thread2. Another interesting pair is e5≤HBe10. This is because
e4,e5,e6ande8,e9are critical sections over the same lock ℓ, and
thus,e6happens before e8. Therefore, e5≤TOe6≤HBe8≤TOe10.
Itisusefultopayattentiontoacoupleofconcurrentpairsofevents.
Eventse3ande7areconcurrent,butdonotconstitutean HB-race
becausee3ande7beingreadeventsarenotconflicting.However,
thereisan HB-racebetweenevents e10ande13;theyareconcurrent
andaconflicting pair ofevents.
The standard FastTrack style vector clock algorithm [ 18,20,
32,36,43] detects if a given trace has a race and runs in time
O(nTlogn)andusesspace O((V+L+T)Tlogn)foratracewith
nevents,Tthreads,Llocksand Vvariables.
Goldilocks Algorithm. Goldilocks algorithm [ 12] is another al-
gorithm that detects the presence of HB-races. In order to formally
describe the algorithm, let us first fix some notations. Consider the
functionAfterσdefinedas follows:
Afterσ(e)={t∈Threads(σ)|∃e′=⟨t:o⟩.e≤σ
HBe′}
∪ {t∈Threads(σ)|∃e′=⟨t′:fork(t)⟩.e≤σ
HBe′}
∪ {ℓ∈Locks(σ)|∃e′=⟨t:rel(ℓ)⟩.e≤σ
HBe′}
Thus,informally, Afterσ(e)isthesetofallthreadsandlocksthat
have an event HB-aftere.
Then, for every prefix σ′of the trace, and for every thread t
and variable xinσ′, the Goldilocks algorithm maintains the set
GLSR
σ′(t,x)definedby
GLSR
σ′(t,x)=Afterσ′(Lastσ′(REvents σ′(t,x)))
28ESEC/FSE’18,November4ś9, 2018, Lake Buena Vista,FL,USA Dileep Kini, Umang Mathur, andMahesh Viswanathan
andfor every variable xinσ′,the set
GLSW
σ′(x)=Afterσ′(Lastσ′(WEvents σ′(x)))
where,Afterσ′(undefined )isassumedto be the emptyset.
Finally, a race is declared after observing an event esuch that
one ofthe following hold:
(1)e=⟨t:w(x)⟩and either t/nelementGLSW
σ′(x)ort/nelementGLSR
σ′(t′,x)
for somethread t′∈Threads(σ′)
(2)e=⟨t:r(x)⟩andt/nelementGLSW
σ′(x).
whereσ′istheprefixuntiltheevent e.Thisalgorithmrunsintime
O(n(L+TV))andusesspace O(TV(T+L))foratracewith nevents,
Tthreads,Llocksand Vvariables.
Eraser’s Lockset Algorithm. The lockset algorithm [ 49] is a low
overheadtechniquetodetectpotentialraces.Thebasicideahere,is
to maintain, for every variable x, the set of locks that protect each
accesstox,andcheckifthissetbecomesemptyastheexecutionpro-
ceeds. We recall the details of this technique here. We will assume
thatnoneoftheelementsintheset D={Λ}∪{Λt|tisathread}are
locksusedbytheprogram.Theelementsoftheset Darełdummyž
orfakelocksintroducedbythealgorithmtoensurethatalarmsare
not raised when a (global) variable is only read (and never writ-
ten to), and when a variable is accessed by only one thread [ 43].
For a read/write event event e=⟨t:a(x)⟩(whereais eitherr
orw) in trace σ,LocksHeld σ(e)is the set of locks held by twhen
eis performed. Using this, for an event e=⟨t:a(x)⟩we define
LockSetσ(e)to be
LockSetσ(e)=/braceleftBigg{Λ,Λt}∪LocksHeld σ(e)ifa=r
{Λt}∪LocksHeld σ(e)ifa=w
For a variables xand thread t, letAccessσ(t,x)be the set of all
eventsin σ↾twhosecorrespondingoperationsareeither r(x)or
w(x).Then,
LockSetσ(t,x)=/intersectiondisplay
e∈Accessσ(t,x)LockSetσ(e).
As per convention, when Accessσ(t,x)=∅(i.e., thread tnever
accessesthevariable x),therighthandsideoftheaboveequation
is assumed to be Locks(σ)∪D. A few observations about these
definitionsareinorder.First LockSetσ(t,x)isalwaysnon-empty
becauseΛt∈LockSetσ(t,x). Second, if all events in Accessσ(t,x)
arereadevents,then Λ∈LockSetσ(t,x).Thelocksetdisciplineis
said to be violatedintraceσ,if for somevariable x,/intersectiondisplay
t∈Threads(σ)LockSetσ(t,x)=∅.
NotethattheEraseralgorithmcruciallydependsupontheaccurate
computation of LocksHeld σ(e). To compute this for traces having
reentrant locks, we need to record, for each thread tand lockℓ,
thenumberoftimes ℓhasbeenacquired,withoutbeingreleased,
whichcan be maintainedusing an integervariable.
We briefly highlight the importance of the locks in Dthat were
introduced. Let LS(x)=∩t∈Threads(σ)LockSetσ(t,x). If the vari-
ablexis only accessed by a single thread t1, thenLS(x)is non-
empty because it contains Λt1. And if a variable xis only read and
neverwrittento,then LS(x)isagainnon-emptybecauseitcontains
Λ. The Eraser algorithm [ 49] checks for violation of the lockset
principlebymaintainingthelocksetforeachthread-variablepair.Thread 1 Thread 2
1r(x)
2acq(ℓ)
3w(y)
4rel(ℓ)
5 acq(ℓ)
6 r(x)
7 w(y)
8 rel(ℓ)
9 r(x)
10w(z)S→UV
U→WX
W→⟨1 :r(x)⟩⟨1 :acq(ℓ)⟩
X→⟨1 :w(y)⟩⟨1 :rel(ℓ)⟩⟨2 :acq(ℓ)⟩
V→YZ
Y→⟨2 :r(x)⟩⟨2 :w(y)⟩
Z→⟨2 :rel(ℓ)⟩⟨2 :r(x)⟩⟨1 :w(z)⟩
Figure 3: Example trace σ2and itsSLP representation
Itrunsintime O(n(L+logr))andusesspace O(TLlogr+V(T+L))
wheren,T,LandVarethenumberofevents,threads,locks,and
variables respectively, and ris the maximum number of times a
thread acquires alockwithoutreleasing it.
Example2.4. Weillustrate thelocksetalgorithm onacoupleof
examples.Considerthetrace σ2inFigure 3.Therelevantlocksets
are as follows.
LockSetσ2(1,x)={Λ,Λ1}LockSetσ2(2,x)={Λ,Λ2}
LockSetσ2(1,y)={Λ1,ℓ}LockSetσ2(2,y)={Λ2,ℓ}
LockSetσ2(1,z)={Λ1}LockSetσ2(2,z)={Λ,Λ1,Λ2,ℓ}
Observethat LockSetσ2(2,z)isthesetofalllocksbecausethread2
doesnotaccess z.Thetrace σ2doesnotviolatethelocksetdiscipline.
Informally, the reason for this is because variable xis only read
by both threads, accesses to variable yis always protected by lock
ℓ, and variable zis local to thread 1. Trace σ2also contains no
HB-race.
For trace σ1from Figure 2,
LockSetσ1(1,x)={Λ1}LockSetσ1(2,x)={Λ,Λ2}
LockSetσ1(1,y)={Λ1}LockSetσ1(2,y)={Λ2,ℓ}.
The lockset discipline is violated on both variables xandy. On
theotherhand,thereisan HB-raceonlyonvariable y(events10
and13;seeExample 2.3).Thus,thelocksetdisciplinemayfalsely
concludethepresenceofraces;itisonlyalightweightapproximate
approach.
StraightLinePrograms (SLP). Weconsidertracesthat arecom-
pressed using special context-free grammars called straight line
programs(SLP).Recallthatacontext-freegrammar(inChomsky
Normal Form) is G=(T,N,S,R), whereTis the set of terminals,
Nthe set of non-terminals, T∪Nis the set of symbols, S∈N
is the start symbol, and Ris the set of rules in which each rule
inRis eitherA→aorA→BC, forA,B,C∈Nanda∈T. A
straight line program is a context free grammar such that (a) for
every non-terminal A, there is exactly one rule where Aappears
on theleft,and(b) thenon-terminals are rankedinsuch that way
that in every rule, the non-terminals on the right are of larger rank
than the non-terminal on the left of the rule, i.e., for rules A→BC,
A≺BandA≺C. It is easy to observe that the language of the
grammar contains a single string, namely, the one that is being
succinctlyrepresentedbytheSLP.Withoutlossofgenerality,we
will assume that every non-terminal in the SLP is useful, i.e., every
non-terminalinthegrammarappearsinsomesententialformin
theuniquederivationinthegrammar.Thus,thelanguageassoci-
ated with any non-terminal Ahas a singlestring. We will callthis
29Data RaceDetectionon CompressedTraces ESEC/FSE’18,November4ś9, 2018, Lake Buena Vista,FL,USA
(unique) string generated by non-terminal Aachunk, and denote it
by/llbracketA/rrbracket.Wewilloftenabusenotationandrefertoboth /llbracketA/rrbracketandA
as łAž.For example, Locks(A)willmean Locks(/llbracketA/rrbracket).
Thesizeof an SLP G=(T,N,S,R)will be taken to be |T|+|N|;
notethatthismeasureofsizeislinearlyrelatedtoothermeasuresof
sizeonemightconsiderlike |R|orsumofthesizesofalltherulesin
R.WemakeacoupleofobservationsaboutthesizeofanSLPversus
thesizeofthetraceitrepresents.First,everytrace σ=e1,e2,...en
can berepresentedby ałtrivialžSLPofsize O(n)asfollows. The
non-terminals are {A[i,i]|1≤i≤n}∪{A[1,i]|1≤i≤n}with
startsymbol A[1,n].Intuitively, A[i,i]representsthestring ei,while
A[1,i]represents the prefix of length i. This is accomplished by the
rules ÐA[i,i]→eiandA[1,i]→A[1,i−1]A[i,i]for each1≤i≤n.
Second,theSLPrepresentationofastring σmaybeexponentially
smaller than σitself. For example, take σ=a2n. AnO(n)SLP
representation for σis as follows: N={Ai|0≤i≤n}with
rulesA0→a, andAi+1→AiAi. One can inductively observe that
/llbracketAi/rrbracket=a2i,andso /llbracketAn/rrbracket=σ.
Example2.5. Figure2describesanSLPrepresentationoftrace
σ1.Therulesfor E,F,D,andGarenotstrictlyintheformatofan
SLP,butitcaneasilybeconvertedintoone;therepresentationin
Figure2is sufficient for our illustrative purposes. We will again
useeito denote the ith event of σ1. ChunkErepresents e1,e2,F
represents e3,e4,e5,e6ande11,...e14,Drepresents e7,e8,e9,e10,
andGrepresents e15,e16.Thesub-tracesrepresentedbytheother
non-terminals can be similarly discovered. As mentioned before,
wewillconfusethenotationdistinguishingbetweenanon-terminal
andthestringitrepresents.Thus,forexample, Threads(E)={1,2}.
Similarly,theSLPfor σ2isshowninFigure 3.Thesub-tracesrep-
resented by non-terminals need not conform to thread and critical
section boundaries. For example, the chunk /llbracketX/rrbrackethas partial critical
sections ofdifferentthreads.
SeveralwellknownalgorithmsforSLPbasedcompressionare
known in the literature. The most basic and popular one is Se-
quitur[40,41].Sequiturtakesastringasaninput,andgenerates
an SLP representing the trace. It runs in time and space linear in
the size of the input string. The Sequitur algorithm works in an
online incrementalfashion;itreads the input stringone character
atatime,andupdatestheSLPgeneratedso-far. It maintainsalist
ofdigrams(symbolpairs)that occur somewhere intheSLPso-far.
Onseeinganewcharacter,thealgorithmappendsitattheendof
therulecorrespondingtothestartsymbol.Thenewdigramformed
(byappendingthenewcharactertothelastsymboloftherule)is
addedtothelistofdigrams,ifitisnotalreadypresent.Otherwise,a
newrule,withafreshnonterminalgeneratingthedigram,isadded
to the SLP, and every occurence of the digram is replaced by the
freshlyintroducednon-terminal.Ateverystep,non-terminals,that
are not useful, are also removed. Other popular grammar based
compressionschemesincludeSequential[ 59],LZ77[62],LZW[57],
Bisection [ 28], longestmatch[ 27]andRe-Pair [ 33].
3HB-RACES INCOMPRESSEDTRACES
Inthissection,wewillpresentouralgorithmfordetecting HB-races
incompressedtracesrepresentedbySLPs.Thealgorithm’srunning
time will be linear in the size of the SLP (as opposed to algorithms
analyzinguncompressedtraces withrunningtimesatleastlinear•e
•ejt
•ej+1
•e′
(1)•e
⌣ℓejtt′
⌢ej+1ℓ
•e′
(2)•e
•ejfork(t′)
tt′•ej+1
•e′
(3)•e
•ejt′t
•ej+1join(t′)
•e′
(4)-
B
-
-
C
--
A
-
Figure 4: Illustrating the various scenarios that establish ej<BC
HB
ej+1.In(2), ‘⌢ℓ’ represents acq(ℓ),‘⌣ℓ’ isrel(ℓ).
in the size of the uncompressed trace). While it is very different
fromtheclassicalvectorclockalgorithm,itissimilarinflavorto
the GoldilocksAlgorithm.
3.1 Detecting Cross-Races
Our algorithm will proceed inductively. Starting from the non-
terminals of largest rank, we will proceed to determine for each
non-terminal A,whetherthereisan HB-raceamongsttheeventsin
thechunkthat Agenerates.Inotherwords,foreachnon-terminal A,
we will determine the predicate Race?(A)which is true if and only
if there is an HB-race between events in /llbracketA/rrbracket. For a non-terminal
A, whose (only) rule is of the form A→a, whereais an event,
Race?(A)is clearly false, because /llbracketA/rrbracket, in this case, has only one
event.
Let usnowconsider the casewhenthe rule correspondingto A
hastheform A→BC,whereBandCarenon-terminalsofhigher
rank. If there isaracein chunk /llbracketA/rrbracketbetween events(say) eande′,
then it is one of two kinds. The first case is when eande′both
belong to chunk /llbracketB/rrbracketor both belong to chunk /llbracketC/rrbracket. The existence
of such races can be determined by computing (inductively) the
predicates Race?(B)andRace?(C). The other possibility is that
e∈/llbracketB/rrbracketwhilee′∈/llbracketC/rrbracket. How we discover the presence of such
cross-races ,isthe main challenge we needto overcome.
Considertwoevents e,e′suchthate∈/llbracketB/rrbracketande′∈/llbracketC/rrbracket.Suppose
e≤BC
HBe′. Then, there is a sequence e=e1,e2,...en=e′that
satisfiestheconditionsinDefinition 2.2.Thus,for 1≤i≤n−1,we
havethetraceorder ei<BC
trei+1.Also,e=e1∈/llbracketB/rrbracket,anden=e′∈
/llbracketC/rrbracket.Thismeansthatthereexists jsuchthatforall i≤j,ei∈/llbracketB/rrbracket,
and for all i≥j+1,ei∈/llbracketC/rrbracket. In other words, (ej,ej+1)is how
the sequence e1,...enłcrossesž the B-Cboundary (see Figure 4).
Observe that we have e=e1≤B
HBejandej+1≤C
HBen=e′. It is
important to note that the relationship between eandej(andej+1
ande′) only depends on the events in chunk /llbracketB/rrbracket(/llbracketC/rrbracket). Depending
on which of the conditions ( 1), (2), (3), and (4) of Definition 2.2
holdfor thepair (ej,ej+1),we haveone ofthefollowing: either ej
andej+1are events of the same thread, or ejis a release event and
ej+1is an acquire event on the same lock, or ejis a fork event and
ej+1is an event of the child thread, or ejis a join event and ej+1
isaneventof theparentthread.Thesescenarios areillustratedin
Figure4. Thus, if an event e∈Bhappens-before an event e′∈C
thenthereisacommonthreadoracommonlockthroughwhichthe
30ESEC/FSE’18,November4ś9, 2018, Lake Buena Vista,FL,USA Dileep Kini, Umang Mathur, andMahesh Viswanathan
orderingisłcommunicatedžacrossthe B-Cboundary.Theconverse
ofthisobservationisalsotrue.Wenowmakethisintuitionprecise.
For atrace σ,andevent e∈σ,recallthe function Afterσ:
Afterσ(e)={t∈Threads(σ)|∃e′=⟨t:o⟩.e≤σ
HBe′}
∪{t∈Threads(σ)|∃e′=⟨t′:fork(t)⟩.e≤σ
HBe′}
∪{ℓ∈Locks(σ)|∃e′=⟨t:rel(ℓ)⟩.e≤σ
HBe′}
Wecan,dually,definethesetoflocks/threadsthathaveanevent
HB-beforeeinσ.
Beforeσ(e)={t∈Threads(σ)|∃e′=⟨t:o⟩.e′≤σ
HBe}
∪{t∈Threads(σ)|∃e′=⟨t′:join(t)⟩.e′≤σ
HBe}
∪{ℓ∈Locks(σ)|∃e′=⟨t:acq(ℓ)⟩.e′≤σ
HBe}
Themainobservationthatunderliesthealgorithmisthat Afterand
Beforesets can be used to discover HBordering between events
acrosschunks.
Lemma 3.1. Consider events e∈/llbracketB/rrbracketande′∈/llbracketC/rrbracket.e≤BC
HBe′iff
AfterB(e)∩BeforeC(e′)/nequal∅.
Lemma3.1suggests that cross races in chunk BCcan be discov-
ered by maintaining the after and before sets of data access events.
However,wedon’tneedtomaintainthesesetsforallaccessevents;
instead,wecandoitonlyforthefirstandlastevents.Thisisthe
contentofthe nextlemma.
Lemma 3.2. If there is no HB-race in /llbracketB/rrbracketor in/llbracketC/rrbracket, and if there
isanHB-racebetweenevents e∈/llbracketB/rrbracketande′∈/llbracketC/rrbracketthen,thereisan
HB-racebetween laste
Bandfirste′
C,where
laste
B=/braceleftBiggLastB(REvents B(t,x))ife=⟨t:r(x)⟩
LastB(WEvents B(x))ife=⟨t:w(x)⟩
and
firste′
C=/braceleftBiggFirstC(REventsC(t,x))ife′=⟨t′:r(x)⟩
FirstC(WEvents C(x))ife′=⟨t′:w(x)⟩
Lemma3.2suggests that in order to check for crossraces, it is
enough to inductively maintain the after sets of the last read/write
events and the before sets of the first read/write events of each
variable and thread. We will denote these sets by ALRd,ALWr,
BFRdandBFWr.Formally,
ALRdD(t,x)=AfterD(LastD(REvents D(t,x)))
ALWrD(x)=AfterD(LastD(WEvents D(x)))
BFRdD(t,x)=BeforeD(FirstD(REvents D(t,x)))
BFWrD(x)=BeforeD(FirstD(WEvents D(x)))(1)
wherewesetboth AfterD(undefined )andBeforeD(undefined )to
be∅.
Based on all of these observations we can conclude that for a
non-terminal Awithrule A→BC,we have,
Race?(A)= Race?(B)∨Race?(C)∨/logicalortext
x∈Wr(B)∩Wr(C)ALWrB(x)∩BFWrC(x)=∅/logicalortext
x∈Wr(B),(t,x)∈Rd(C)ALWrB(x)∩BFRdC(t,x)=∅/logicalortext
(t,x)∈Rd(B),x∈Wr(C)ALRdB(t,x)∩BFWrC(x)=∅(2)
Thus, our race detection algorithm will be complete if we can
effectively compute thesets ALRdB(t,x),ALWrB(x),BFRdC(t,x),
andBFWrC(x).We embarkonthis challenge inthe nextsection.
Nextwe state the correctness ofthe Race?predicate.Theorem 3.3. For any non-terminal A,Race?(A)=trueif and
only ifthereareevents e1,e2∈/llbracketA/rrbracketsuchthat e1≍e2ande1||HBe2.
Example 3.4. Let us illustrate the ideas presented in this section
throughsomeexamples.We willconsider traces σ1anditsSLPin
Figure2,andσ2withits SLP inFigure 3.
We begin bygiving examples of BeforeandAftersets.
AfterE(e1)={1,2}AfterC(e1)={1,2,ℓ}
BeforeG(e16)={1,2}BeforeB(e16)={1,2,ℓ}
AfterW(e1)={1}AfterU(e1)={1,2,ℓ}
BeforeX(e3)={1}BeforeU(e3)={1,ℓ}
Let us highlight the significant aspects of these examples. 2∈
AfterE(e1)because of e2=⟨1 :fork(2)⟩andℓ∈AfterC(e1)be-
causeofevent e6=⟨2 :rel(ℓ)⟩.Ontheotherhand, ℓ/nelementAfterW(e1)
because there is no rel(ℓ)event in chunk /llbracketW/rrbracket(ofσ2). But when
consideringthechunk /llbracketU/rrbracket(ofσ2),wehaveℓ∈AfterW(e1)because
of the event e4=⟨1 :rel(ℓ)⟩. Next,2∈BeforeG(e16)because of
the join event e15, andℓ∈BeforeB(e16)because ofacquire event
e12.In trace σ2,ℓ∈BeforeU(e3)because of acquire event e2.
Now let us consider the computation of cross-races for the
chunks in Figure 2. ForM∈ {D,E,F,G}, it is easy to see that
Race?(M)=false,becauseeachofthesechunksonlycontainevents
of one thread. Let us look at the interesting pairs of events we con-
sidered in Example 2.3. The absence of race between e1ande3can
be seen because ALWrE(x)={1,2}andBFRdF(2,x)={2}, both
ofwhichhavethethread 2incommon,andthustheintersection
ALWrE(x)∩BFRdF(x)is non-empty. In fact, what this reason-
ingdemonstratesisthatthereisnoracebetweenany w(x)-event
inEand anyr(x)-event in F. Similarly, the absence of a race be-
tweene13ande16can be seen because ALWrF(y)∩BFRdG(1,y)
={2,ℓ}∩{1,2}={2}/nequal∅. To reason about the events e5ande10,
observe that ALWrF(y)={2,ℓ}andBFWrD(y)={1,ℓ}, both of
which have theℓin common. Thus, we can conclude there is no
racebetween any pair of w(y)-eventscrossing the chunk FD.
Ourreasoningalsorevealstheexistenceof HB-concurrentevents.
For example, ALRdF(2,x)={2,ℓ}, andBFRdD(1,x)={1}. Since
these setsare disjoint,itreveals thatthere area pair of r(x)-events
(namely, e3ande7) that are HB-concurrent; it is not a HB-race
because these events are not conflicting (none of e3ande7is a
writeevent).Theracebetween e10ande13canbeseenasfollows.
ALWrA(y)={1},andBFWrB(y)={2,ℓ}.Wecanseethatthereis
acrossraceinchunk AB,because thesetwosetsare disjoint.
3.2 Computing BeforeandAfterSets
Our discussion in Section 3.1suggests that if we manage to in-
ductivelycomputethesets ALRd,ALWr,BFRd,andBFWr(Equa-
tion(1))foreachchunkinthegrammar,thenwecanuseEquation( 2)
to determine if a chunk has a race. In this section we present such
an inductive computation for these sets. We will only describe the
computation of sets ALRdandBFRd. The computation of the sets
ALWrandBFWrissimilar andispresentedin[ 30].
The base case for non-terminals with rule A→a, whereais
anevent,isstraightforward.Toconservespace,thisdefinitionis
skippedhere,butpresentedin[ 30].Sowefocusontheinductive
step when we have anon-terminal withrule A→BC.
31Data RaceDetectionon CompressedTraces ESEC/FSE’18,November4ś9, 2018, Lake Buena Vista,FL,USA
First consider the case of ALRdA(t,x), which is equal to the
setAfterA(e), whereeis the last event amongst the read events
REvents A(t,x). If variable xis never read by thread tin the chunk
A(i.e.,REvents A(t,x)=∅), we will have ALRdA(t,x)=∅. Oth-
erwise, depending upon where the last read event eoccurs in
the chunk /llbracketA/rrbracket, we have two cases to consider. In the first case,
this last read event ebelongs to the chunk /llbracketC/rrbracket. In this, clearly,
e=LastA(REvents A(t,x)). Observe that since {e′|e≤C
HBe′}=
{e′|e≤A
HBe′}, we have AfterA(e)=AfterC(e). Thus, in this
case,ALRdA(t,x)=ALRdC(t,x). The interesting case is when
REventsC(t,x)isemptyand REvents B(t,x)/nequal∅,i.e.,thelastread
eventebelongs to the chunk B. Since{e′∈/llbracketB/rrbracket|e≤B
HBe′} ⊆
{e′∈/llbracketA/rrbracket|e≤A
HBe′}, we have AfterB(e)⊆AfterA(e). Consider
e′∈/llbracketC/rrbracketsuch that e≤A
HBe′. As in the discussion on cross-races
in Section 3.1, this means there is a pair of events e1∈/llbracketB/rrbracketand
e2∈/llbracketC/rrbracketsuch that e≤B
HBe1,e2≤C
HBe′, and either (1) e1,e2are
eventsofthesamethread,or(2) e1isaforkeventand e2isanevent
of the child thread, or (3) e1is an event of a child thread and e2is a
join event, or (4) e1is a release event and e2is an acquire event on
the same lock. In each of these cases, e1witnesses the membership
of some thread/lock uinAfterB(e), ande′isHB-after the łfirstž
event (namely e2) ofuin chunk C. The definition of what it means
foraneventtobełafteržthełfirstževentofathread/lock uissubtle,
andiskey inaccurately capturingthe intuitions justoutlined.
For anon-terminal Dandthread t,define
AFD(t)=AfterD(FirstD(ThEventsjoin
D(t))) (3)
whereThEventsjoin
D(t)={e∈D|e=⟨t:o⟩ore=⟨t′:join(t)⟩}.
Similarly,for alock ℓ,define
AFD(ℓ)=AfterD(FirstD(AcqEventsD(ℓ))) (4)
whereAcqEventsD(ℓ)istheset{e∈D|e=⟨t:acq(ℓ)⟩}.Asbefore,
we setAfterD(undefined )=∅.
We nowformalize our intuitions inthe following lemma.
Lemma 3.5. LetAbe a non-terminal with rule A→BCand let
e∈/llbracketB/rrbracket.Then
AfterA(e)=AfterB(e)∪/uniondisplay
u∈AfterB(e)AFC(u)
The proof of Lemma 3.5is in our technical report [ 30]. Its state-
mentgives usthe following inductive definitionfor ALRdA(t,x).
ALRdA(t,x)=ALRdC(t,x) ifALRdC(t,x)/nequal∅
ALRdB(t,x)∪ otherwise/uniontext
u∈ALRdB(t,x)AFC(u)
(5)
Notice that the secondexpressionis ∅ifALRdB(t,x)=∅.
To complete the formal definition of ALRdA(x), we need to give
an inductive definition for the sets AF. Again defining AFAfor
A→ais straightforward and is deferred to [ 30]. Consider the
inductive step, of a non-terminal Awith rule A→BCand lett
be some thread. If FirstA(ThEventsjoin
A(t))∈/llbracketB/rrbracketthen Lemma 3.5
formsthebasisofourdefinition.However,itispossiblethattheset
ThEventsjoin
B(t)is empty, while FirstA(ThEventsjoin
A(t))∈/llbracketC/rrbracket. Inthiscase, AFA(t)=AFC(t).Asimilarreasoningappliesforalock
ℓas well. Putting alltheseobservations together,we get
AFA(u)=AFB(u)∪/uniondisplay
u′∈{u}∪AFB(u)AFC(u′) (6)
Letusnowdiscusstheinductivedefinitionoftheset BFRdA(t,x)
for thread tand variable x. As before, the first event e∈/llbracketA/rrbracketof the
kind⟨t:r(x)⟩caneitherbelongto /llbracketB/rrbracketorto/llbracketC/rrbracket.Intheformercase,
we haveBeforeA(e)=BeforeB(e). On the other hand, if e∈/llbracketC/rrbracket,
inamannersimilartothecasefor AfterB(e),weneedtołcomposež
BeforeC(e)withthełbeforežsetsassociatedwiththe lasteventsof
threads/locksinchunk B.
For anon-terminal D,threadtandlockℓ,
BLD(t)=BeforeD(LastD(ThEventsfork
D(t))) (7)
BLD(ℓ)=BeforeD(LastD(RelEvents D(ℓ))) (8)
whereThEventsfork
D(t)={e∈D|e=⟨t:o⟩ore=⟨t′:fork(t)⟩}
andRelEvents D(ℓ)={e∈D|e=⟨t:rel(ℓ)⟩}.
The dual ofLemma 3.5isthe following lemma.
Lemma 3.6. LetAbe a non-terminal with rule A→BCand let
e∈/llbracketC/rrbracket.Then
BeforeA(e)=BeforeC(e)∪/uniondisplay
u∈BeforeC(e)BLB(u)
Using Lemma 3.6,the inductive definitionof BFRdA(t,x)is
BFRdA(t,x)=BFRdB(t,x) ifBFRdB(t,x)/nequal∅
BFRdC(t,x)∪ otherwise/uniontext
u∈BFRdC(t,x)BLB(u)
(9)
To complete the algorithm, we need to give the inductive def-
inition of BLA(u)for thread/lock u. Again the interesting case is
theinductivecaseofanon-terminal Awithrule A→BC.Asimilar
reasoningas inthe caseof AFsetsgives the following definition.
BLA(u)=BLC(u)∪/uniondisplay
u′∈{u}∪BLC(u)BLB(u′)
Thiscompletesthedescriptionofthe HB-algorithmoncompressed
traces.Itscorrectnessisprovedin[ 30].Foratrace σcompressedas
an SLP of size д, this algorithm runs in time O(д(T+L)2(L+TV))
and uses space O(д(T+L)(L+TV)), whereT,LandVdenote the
number ofthreads, locksandvariables in σ.
Example3.7. Weconcludethissectionbyshowingthatthebefore
andaftersetsgiveninExample 3.4arecomputedcorrectlyusing
ourinductivecharacterization.Wewillfocusontrace σ1anditsSLP
grammarinFigure 2.Letusconsiderthecomputationof ALWrC(x).
Observe that the last w(x)-eventin Cise1.Further,
ALWrE(x)={1,2}AFF(1)=∅AFF(2)={2,ℓ}
HereAFF(1)=∅because thereis no event ofthread 1 in F. Using
theinductivedefinitionsimilartoEquation( 5),wegetALWrC(x)=
{1,2,ℓ}whichiscorrect.
Next, consider the computation BFWrB(y). Notice that the first
w(y)-event in Bise13, which is in the chunk F. This immediately
givesBFWrB(y)=BFWrF(y)={2,ℓ}using a characterization
similar to Equation( 9).
32ESEC/FSE’18,November4ś9, 2018, Lake Buena Vista,FL,USA Dileep Kini, Umang Mathur, andMahesh Viswanathan
t
•e1⌢ℓ1•e2
⌣ℓ1
⌣ℓ2
(1)t
⌢ℓ1⌢ℓ2
•e1
⌣ℓ1
•e2
(2)ℓ1∈LocksHeldA(e1),ℓ2∈LocksHeldA(e1)
ℓ1/nelementLocksHeldA(e2),ℓ2∈LocksHeldA(e2)t
•e3
⌢ℓ3
⌣ℓ3
⌣ℓ3
(3)t
⌢ℓ3
⌢ℓ3
⌣ℓ3
•e3
(4)ℓ3∈LocksHeldA(e3)-
B
-
-
C
--
A
-
Figure 5: Unmatched acquire/release events protect all the events
of the same thread in the neighboring chunk when not matched
intheentirechunk((1)and(2)).Re-entrantlocksprotecttheneigh-
boringchunkwhentheoutermostunmatchedacquire/releaseisun-
matched((3) and (4)). ‘ ⌢ℓi’ represents acq(ℓi),‘⌣ℓi’ isrel(ℓi).
4 LOCKSET ALGORITHM FORCOMPRESSED
TRACES
Similar to our algorithm for detecting HB-races on compressed
traces,wewillformulateanalgorithmfordetectingviolationsof
thelocksetdisciplineonSLPsinaninductivefashion.Thechallenge
here again is similar Ð violations occurring inside a chunk /llbracketB/rrbracketare
also violations of any other chunk that contains /llbracketB/rrbracket, and detecting
łcrossžviolationsis,therefore,thekeychallenge.Inthissection,we
willoutlinetheseideasindetail.
4.1 Cross Violations
Recallthat,forathread tandvariable x,LockSetσ(t,x)istheset
ofallthelocks(includingthedummylocksin D)thatprotectevery
access eventof xperformedby t,inσ.
Inthissection,weshowhowtocompute LockSetA(t,x)forevery
non-terminal Aand for every pair (t,x)of thread and variable,by
inductingonthenon-terminalsindecreasingorderoftheirrank.
Checking if∩t∈ThreadsALockSetA(t,x)=∅then followseasily.
Thebasecasefor non-terminalswithrule A→aisstraightfor-
ward, and is presented in [ 30]. Now consider the inductive step
for non-terminals having rules of the form A→BC. To under-
stand what LockSetA(t,x)will be, it is useful to examine what
LocksHeld A(e)for an event elooks like. Consider a data access
evente∈/llbracketB/rrbracketperformed by thread t. Clearly, LocksHeld B(e)⊆
LocksHeld A(e). But are they equal? The answer turns out to be no.
Suppose a lockℓwhich isreleased in /llbracketC/rrbracketby thread tbut doesnot
have amatching acquire in /llbracketA/rrbracket(and hence, neither in /llbracketB/rrbracket). Such a
lockℓwillprotectalltheeventsperformedbeforeitin /llbracketA/rrbracket.Thus
trivially, it will enclose all the events performed by tin chunk /llbracketB/rrbracket.
As a consequence, ℓmust be included in the set LocksHeld A(e)for
everyevent e∈B↾t.Lockℓ2inFigure 5(1)illustratesthis.Similarly,
for an event e∈/llbracketC/rrbracketperformed by thread t, the setLocksHeld A(e)
mustadditionallyincludelockswhichhavebeenacquiredbythread
tin/llbracketB/rrbracketbuthavenotbeenmatchedin /llbracketA/rrbracket(seelockℓ2inFigure 5(2)).
However,onemustbecareful.Alock ℓwhichwasreleasedby tinC
(ateventerel(ℓ))andwhosematchingacquireisin B(eventeacq(ℓ)),does not affect the locks held by any event in BÐ for those events
e∈B↾twhichwere after eacq(ℓ),ℓwasalready in LocksHeld B(e),
whilefortheevents ebeforeeacq(ℓ),ℓdoesnotanywayprotect e,
andthusℓ/nelementLocksHeld B(e).Thisisillustratedthroughlock ℓ1in
Figure5[(1)and(2)].
Inthepresenceofre-entrantlocks,weneedtoaccountforan-
other fact. Since locks can be acquired and released multiple times,
a lock that is released more times in C(by thread t) than it is ac-
quired in B(by thread t) will protect all events of tinB, because
theoutermostreleaseisstillunmatchedin A.Thesameholdsfor
locks that have been acquired more times than they are released in
C.Both thesescenarios are showninFigure 5[(3)and(4)].
To formalize the above notions, we will now introduce some
notation. For a non-terminal D, let us first define the number of
unmatched acquire eventsof lock ℓinthread tas
OpenAcqD(t,ℓ)=|{e=⟨t:acq(ℓ)⟩∈D|match(e)/nelement/llbracketD/rrbracket}|(10)
andthe number ofrelease eventsas
OpenRelD(t,ℓ)=|{e=⟨t:rel(ℓ)⟩∈D|match(e)/nelement/llbracketD/rrbracket}|(11)
Our intuitions, as discussed above, can then be captured for the
more complex caseofre-entrant locksas follows.
Lemma 4.1. LetAbe a non-terminal with rule A→BC. Lete∈
B↾tande′∈C↾t′be read/write events performed by threads t,t′.
Then,
LocksHeld A(e)=LocksHeld B(e)
∪{ℓ|OpenRelC(t,ℓ)>OpenAcqB(t,ℓ)}
LocksHeld A(e′)=LocksHeld C(e′)
∪{ℓ|OpenAcqB(t′,ℓ)>OpenRelC(t′,ℓ)}
BuildingonLemma 4.1,wecannowstatetheinductivedefinition
ofLockSetinterms of OpenAcq andOpenRel.
LockSetA(t,x)
=/parenleftBig
LockSetB(t,x)∪{ℓ|OpenRelC(t,ℓ)>OpenAcqB(t,ℓ)}/parenrightBig
∩/parenleftBig
LockSetC(t,x)∪{ℓ|OpenAcqB(t′,ℓ)>OpenRelC(t′,ℓ)}/parenrightBig
(12)
The basecasefor computing LockSetA(t,x)(see [30]).
Example4.2. ConsidertheSLPfor σ2fromFigure 3.OpenAcq
andOpenRel for variousnon-terminals isgiven below.
OpenAcqW(1,ℓ)=1OpenRelX(1,ℓ)=1
OpenAcqX(2,ℓ)=1OpenRelZ(2,ℓ)=1
OpenAcqU(2,ℓ)=1OpenRelV(2,ℓ)=1.
The values for all other combinations are 0. Note how the un-
matched acquire in Wand the unmatched release in Xon thread 1
getmatchedintheconcatenatedchunk U,givingOpenAcqU(1,ℓ)=
OpenRelU(1,ℓ)=0. This is essentially the insight we will explore
inSection 4.2to inductivelydefine OpenAcq andOpenRel.
Let us now see how LockSetcomputation takes place. First,
LockSetW(1,x)={Λ,Λ1}sincetheonlyeventof xinWisaread
bythread1.Also, LockSetX(1,y)={ℓ,Λ1}ase3isprotectedbythe
(unmatched) release e4inX. In chunk Y,LockSetY(2,x)={Λ,Λ2}
andLockSetY(2,y)={Λ2}; interestingly, the locksets for Ydoes
notrevealthatboth e6ande7areenclosedwithinthecriticalsection
oflockℓ.Ontheotherhand,usingtheinductiveformulationdis-
cussedabove,wecaninferthat LockSetV(2,y)=(LockSetY(2,y)∪
33Data RaceDetectionon CompressedTraces ESEC/FSE’18,November4ś9, 2018, Lake Buena Vista,FL,USA
{ℓ})∩⊤which evaluates to {Λ2,ℓ}as expected. The universal
set⊤is described in [ 30]. Again, the lock ℓdoes not appear in
LockSetU(1,x)eventhough it is unmatched in X, because it gets
matched with e2inW. This also follows from the inductive defini-
tionofLockSetU(1,x).
Given Equation ( 12), our inductive formulation will be com-
pleteoncewecaninductivelycomputethefunctions OpenAcq and
OpenRel.We describe this next.
4.2 Computing OpenAcq andOpenRel
The base case for non-terminals having rules of the form A→
ais straightforward and can be found in [ 30]. In the inductive
case we have a non-terminal Awith production rule of the form
A→BC. For this case, let us first attempt to characterize the
acquire eventsin /llbracketA/rrbracketthat have not been matched. Notice that if a
lockisacquired(withoutamatchingrelease)inthechunk /llbracketC/rrbracket,it
would remain unmatched in the bigger chunk /llbracketA/rrbracket. In addition, the
unmatched acquire events acquired in /llbracketB/rrbracketwhose matching release
is not present in /llbracketC/rrbracketwill also contribute to the unmatched acquire
eventsin /llbracketA/rrbracket.This reasoningisformalizedbelow.
OpenAcqA(t,ℓ)=OpenAcqC(t,ℓ)
+max{0,OpenAcqB(t,ℓ)−OpenRelC(t,ℓ)}
(13)
Noticetheuseofthe maxoperatorinEquation( 13).Ifthequantity
OpenAcqB(t,ℓ)−OpenRelC(t,ℓ)is negative, then there are more
unmatched rel(ℓ)-eventsin C↾t,whichshouldbeaccountedforin
OpenRelA(t,ℓ),insteadofaffectingthecontributionof /llbracketC/rrbrackettowards
the unmatchedacquire eventsof A↾t.
Similar reasoninggives the inductive formulation for OpenRel
OpenRelA(t,ℓ)=OpenRelB(t,ℓ)
+max{0,OpenRelC(t,ℓ)−OpenAcqB(t,ℓ)}
(14)
Thiscompletesthedescriptionofouralgorithmforcomputinglock-
setsandcheckingviolationsoflocksetdisciplineforcompressed
traces. For a trace σcompressed as an SLP of size д, this algorithm
runsintime O(дTL(logr+V))andusesspace O(дTL(logr+V)),
whereT,LandVare the number of threads, locks and variables
respectivelyin σ,andrdenotesthemaximumnumberoftimesa
thread acquires alockwithoutreleasing itin σ.
5 EVALUATION
Inordertogaugetheeffectofcompressiononthesizeoftraces,and
thesubsequenteffectontimetakentoanalyzethesecompressed
traces for races, we conducted experiments on a large variety of
benchmarks and evaluatedour algorithms empirically.Inthissec-
tion, we describe the details of our implementation and experimen-
tal setup,andanalyze the results oftheseexperiments.
5.1 Implementation andSetup
Implementation. Our algorithms for detecting races on com-
pressed traces, discussed in Section 3and Section 4have been
implemented in our tool ZipTrack , which is publicly available
at [4].ZipTrack is written primarily in Java and analyzes traces
generated byJavaprograms. ZipTrack firsts collects tracelogsassequence of events, which include read/write to memory locations,
acquire/releaseoflocks,andjoin/forkofthreads.Forthis,weuse
the logging library provided by the commercial tool RVPredict [1].
After having generated the trace logs, ZipTrack calls the Sequitur
algorithm(availableat[ 2])tocompressthesetracesasstraightline
programs (see Section 2).ZipTrack then analyzes these SLPs to
detectthe presenceofHB racesandlocksetdiscipline violations.
Optimizations. The SLPs generated using the Sequitur algorithm
arenotstrictlyCNFgrammars;productionrulesinthegrammarcan
havelength>2aswell.ThisissimilartothegrammarshowninFig-
ure2,whereboththenon-terminals FandDhaveproductionrules
of length 4. For detecting an HB-race on SLPs, ZipTrack employs
thefollowingoptimizationsthatrelyonexistenceofsuchlongpro-
ductionrules.Foraruleoftheform A→a1a2···ak,whereeachof
a1,...akareterminals,ourtool ZipTrack usesaslightmodifica-
tionofthebasicHBvectorclockalgorithmandusesthevectorclock
values to (i) determine if Race?(A)holds, and (ii) compute the vari-
ous sets associated with A(such asALRdA,BFRdA, etc.). Next, for
production rules where the right hand side has both terminals and
non-terminalsandhaslongcontiguoussequences(orsubstrings)
ofterminals,weintroducenewproductionrulesinthegrammar,
withfreshnon-terminals correspondingtotheselongsequences.
For example, for a rule of the form A→b1···bkCd1···dm, where
bisanddisareterminals,wewillintroducetwonewnon-terminals
BandD, with production rules B→b1···bkandD→d1···dk,
andreplacetheproductionruleof AbyA→BCD.Thisallowsus
to betterexploit the vector-clockoptimization.
SetupandBenchmarks. Our experiments were conducted on an
8-core2.6GHz64-bitIntelXeon(R)Linuxmachine,with30GBheap
space.TocompareagainstHappens-BeforeandLockSetbasedanal-
ysisonuncompressedtraces,weuse RAPID[3],whichimplements
the standard Djit+ [43] vector clock algorithm, epoch optimiza-
tions like in FastTrack [20], the Goldilocks algorithm [ 12], and
Eraser’s lockset algorithm [ 49], as described in [ 43]. Our evalua-
tionbenchmarks(Column1inTable 1)arecarefullychosenwith
the goal of being comprehensive, and have been primarily derived
from [24]. The first set of small-sized (LOC ∼50-300) benchmarks
(accounttopingpong ) is derived from the IBM Contest benchmark
suite[15].Thesecondsetofmediumsized(LOC ∼3K)benchmarks
(moldyntoraytracer)isderivedfromtheJavaGrandeForumbench-
marksuite[ 52].Thethirdset( derbytoxalan)ofbenchmarks(LOC
∼30K-500K) comes from the DaCaPo benchmark suite (version
9.12)[8]andlargerealworldsoftwareincludingApacheFTPServer,
W3C Jigsaw webserver and Apache Derby.Columns 3, 4and 5in
Table1report the number of threads, locks and variables in the
traces generatedfrom the corresponding programs inColumn 1.
5.2 Results
Compression Ratio. To analyze the effect of compression on the
size of traces, consider the compression ratios (ratio of the size
of the original trace and the size of the grammar representation)
shown in Column 7 in Table 1. The compression ratios are not
significant for the small and medium sized benchmarks, barring
boundedbuffer (compression ratio = 1.74), moldyn(compression
ratio = 1.86) and the most notable bufwriter (compression ratio
34ESEC/FSE’18,November4ś9, 2018, Lake Buena Vista,FL,USA Dileep Kini, Umang Mathur, andMahesh Viswanathan
Table 1: Columns 1-5 describe the benchmarks and traces. Columns 6 and 7 describe the size of the compressed traces and
thecompressionratiosachieved.Columns8-10describetheperformanceofvariousHB-racedetectionalgorithmsonuncom-
pressedtraces.Column11-12reportstheperformanceof ZipTrack ’sHBracedetectiononcompressedtracesandtheresulting
speedup achieved. Column 13, 14 and 15 report the performance of respectively Eraser’s lockset algorithm on uncompressed
traces,ZipTrack ’sperformanceon compressed traces, andtheresultingspeedupachieved.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
Memory Grammar Compr. HB(ms) LockSet(ms)
Program Events Threads Locks Loc. Size Ratio Djit+F.Track Goldi. Compr. Speedup Eraser Compr. Speedup
account 130 4 3 41 107 1.21 6 5 4 4 1 3 3 1
airline 137 4 0 44 132 1.04 8 4 5 6 0.67 2 1 2
array 47 3 2 30 47 1 5 4 4 3 1.33 3 1 3
boundedbuffer 337 2 2 63 194 1.74 8 8 2 18 0.11 3 2 1.5
bubblesort 4.2K 10 2 167 3.3K 1.29 14 13 12 92 0.13 2 4 0.5
bufwriter 11.8M 6 1 56 293 40238 20s 15.5s 36.3s 6 2600 1 4 0.25
critical 55 4 0 30 55 1 3 4 3 5 0.6 2 1 2
mergesort 3028 5 3 621 2795 1.08 5 7 5 13 0.38 3 6 0.5
pingpong 146 4 0 51 135 1.08 10 9 9 3 3 2 1 2
moldyn 164K 3 21197 88K 1.86 53 60 57 6 8.83 2 2 1
montecarlo 7.2M 3 3876K 6.1M 1.18 317 271 302 87 3.11 300 1 300
raytracer 16.2K 3 83879 14.6K 1.11 58 32 32 315 0.1 25 133 0.19
derby 1.3M 41112 186K 735K 1.83 1006 1011 26s 592 1.7 848 <1 >1000
eclipse 90.6M 19 8300 11.2M 42.5M 2.13 34.6s 31.5s 3776s 17.4s 1.8 21737 121737
ftpserver 49K 11 301 5461 30K 2.13 49 44 91 23 1.9 34 1 34
jigsaw 3M 13 280 103K 908K 3.37 2432 2309 1888 195 9.7 12 4 3
lusearch 216M 7 118 5.2M 66.6K 3.25 1392 968 700 7 100 814 2 407
xalan 122M 62491 4.4M 71M 1.7 5183 3008 3709 109 27.6 2779 1 2779
> 40,000). The compression ratios for the large benchmarks are
impressive;aslargeas3.25.Thiscanbeattributedtothefactthat
inlargeexecutions,thelargeamountofredundanciesmakethem
amenable to larger compression. Despite smaller lines of code in
thesourcecodeof bufwriter , thesizeof the execution observed is
quitelarge,andthus the excellentcompressionratio.
HB race detection. Columns8,9and10inTable 1representthe
time taken to detect the presence of an HB race by respectively,
Djit+,FastTrack and Goldilocks. Column 11 denotes the time
takenbyour HB racedetection algorithmforanalyzing the traces
compressedasSLPsandColumn12reportsthespeedupachieved
over the bestofthe three valuesinColumns 8, 9and10.
First,inthesmallerexamples( account-pingpong ),thespeed-
upisnotsignificantformostexamples.Thiscanbeattributedto
thelowcompressionratios,andsignificantinitialset-uptimes.In
particular,the bubblesort examplehasasignificantslow-down.One
noteworthy small example that shows the power of compression is
bufwriter wherethecompressionratioandtheresultingspeedup
for racedetection isvery high ( >2500x).
Forthe mediumsizedexamples, the compression ratios range in
1.1−1.86.Thespeedupfor moldynandmontecarlo isabout3−8x,
while for raytracer , we encounter a large slowdown. A possible
explanationforthedegradedperformanceinboth bubblesort and
raytracer is that, while thefirst race pair (e1,e2)occurs very early
in the uncompressed trace, the SLP generated is such that, in order
to discover any race,the entire grammarneedsto be processed.
The performance improvements for the large benchmarks are
noteworthy and the speed ups shoot to the order of 100x. TheFast-
Trackvectorclockalgorithm[ 20]isthegoldstandardfordetecting
HBraces,andourevaluationindicatesthatanalysisoncompressed
traces beats the advantages offered by vector-clocks and further
epoch-likeoptimizations.Infactouralgorithmis,inspirit,closerto
theGoldilocksalgorithm,forwhichtheperformancedegradationdeeply intensifies on larger benchmarks (also noted before in [ 20]).
The speedups (over FastTrack ) achieved by our approach, despite
this similarity, must be attributed to the non-trivial compression
ratios achieved. Overall, the average speed-up is about 2.9x over
FastTrack ,andaround 200x over the Goldilocksalgorithm.
Locksetviolationdetection. Columns13and14denotethetime
for detecting lockset violations on uncompressed and compressed
traces respectively. Since, the compression on smaller examples
isnotlarge,wecanobservethatthespeedupinsuchexamplesis
not extraordinary. However, there is little or almost no slowdown.
Forthemediumandlargeexamples, ZipTrack detectsviolations
of lockset discipline on compressed traces much faster than on
uncompressed traces. In fact, the speed-ups shoot upto more than
20,000x, and the time taken is almost always of the order of a
fewmilliseconds.Theaveragespeed-upachievedovertheEraser
algorithm isaround 173x.
Clearly, these large real-world examples illustrate the benefit of
compression; compression can be leveraged not only for smaller
storagespaces,butalsoforamoreefficientracedetectionanalysis.
6 CONCLUSIONS
We considered the problem of detecting races in traces compressed
bySLPs.Wepresentedalgorithmsthatdetect HB-racesandviola-
tions of the lockset discipline in time that is linear in the size of
thecompressed traces.Experimentalevaluationofour implemen-
tation of these algorithms in the tool ZipTrack , demonstrated that
analyzing compressedtraces can leadto significant speedups.
ACKNOWLEDGMENTS
WegratefullyacknowledgeNationalScienceFoundationforsup-
porting Umang Mathur (grant NSF CSR 1422798) and Mahesh
Viswanathan(NSF CPS 1329991).
35Data RaceDetectionon CompressedTraces ESEC/FSE’18,November4ś9, 2018, Lake Buena Vista,FL,USA
REFERENCES
[1]2017. RV-Predict, Runtime Verification. https://runtimeverification.com/predict/ .
Accessed:2017-11-01.
[2]2017. Sequitur:InferringHierarchiesFromSequences. http://www.sequitur.info/ .
Accessed:2017-08-01.
[3]2018. RAPID:DynamicAnalysisforConcurrentPrograms. https://github.com/
umangm/rapid . Accessed:July30,2018.
[4]2018. ZipTrack: Race Detection on Compressed Traces. https://github.com/
umangm/ziptrack . Accessed:July30,2018.
[5]M. Abadi, C. Flanagan, and S.N. Freund. 2006. Types for safe locking: Static race
detectionforJava. ACMTransactionsonProgrammingLanguagesandSystems 28,
2 (2006), 207ś255.
[6]J.L. Balcázar. 1996. The complexity of searching implicit graphs. Artificial
Intelligence 86,1 (1996), 171ś188.
[7]Swarnendu Biswas,JipengHuang, Aritra Sengupta,andMichael D.Bond. 2014.
DoubleChecker: Efficient Sound and Precise Atomicity Checking. In Proceedings
of the 35th ACM SIGPLAN Conference on Programming Language Design and
Implementation . 28ś39.
[8]S.M. Blackburn, R. Garner, C. Hoffmann, A.M. Khang, K.S. McKinley, R. Bentzur,
A. Diwan, D. Feinberg, D. Frmpton, S.Z. Guyer, M. Hirzel, A. Hosking, M. Jump,
H. Lee, J.E.B.Moss,A. Phansalkar,D. Stefanović, T. VanDrunen, D vonDinck-
lage, and B.Wiedermann.2006. TheDaCapoBenchmarks:JavaBenchmarking
Development and Analysis. In Proceedings of the ACM SIGPLA Conference on
Object-OrientedProgrammingSystems,Languages, and Applications . 169ś190.
[9]C.Boyapati,R.Lee,andM.Rinard.2002. Ownershiptypesforsafeprogramming:
Preventingdataracesanddeadlocks.In ProceedingsoftheACMSIGPLANCon-
ferenceonObject-OrientedProgrammingSystems,Lanaguages,andApplications .
211ś230.
[10]G.-I. Cheng, M. Feng, C.E. Leiserson, K.H. Randall, and A.F. Stark. 1998. De-
tecting DataRaces in CilkProgramsThat Use Locks.In Proceedingsofthe ACM
SymposiumonParallelAlgorithmsand Architectures . 298ś309.
[11]B. Das, P. Scharpfenecker, and J. Torán. 2014. Succinct encodings of graph
isomorphism. In Proceedings of the Internation Conference on Languages and
AutomataTheoryand Applications . 285ś296.
[12]T.Elmas,S.Qadeer,andS.Tasiran.2007. Goldilocks:ARaceandTransaction-
aware Java Runtime. In Proceedings of the ACM SIGPLAN Conference on Program-
mingLanguage Designand Implementation . 245ś255.
[13]D. Engler and K. Ashcraft. 2003. RacerX: Effective, static detection of race
conditions and deadlocks. In Proceedings of the ACM Symposium on Operating
SystemsPrinciples . 237ś252.
[14]M.EslamimehrandJ.Palsberg.2014. Sherlock:Scalabledeadlockdetectionfor
concurrentprograms.In ProceedingsoftheACMSIGSOFTInternationalSympo-
sium onFoundationsofSoftwareEngineering . 353ś365.
[15]E. Farchi, Y. Nir, and S. Ur. 2003. Concurrent Bug Patterns and How to Test
Them.In ProceedingsoftheInternationalSymposiumonParallelandDistributed
Processing .
[16]J. Feigenbaum, S. Kannan, M.Y. Vardi, and M. Viswanathan. 1998. Complexity
of Problems on Graphs Represented as OBDDs. In Proceedings of the Annual
SymposiumonTheoretical Aspects ofComputer Science . 216ś226.
[17]M.FengandC.E.Leiserson.1997. EfficientDetectionofDeterminacyRacesin
Cilk Programs. In Proceedings of the ACM Symposium on Parallel Algorithms and
Architectures . 1ś11.
[18]C.J.Fidge.1988. Timestampsinmessage-passingsystemsthatpreservethepartial
ordering. In Proceedingsofthe AustralianComputer ScienceConference . 56ś66.
[19]C.FlanaganandS.N.Freund.2000. Type-basedracedetectionforJava.In Pro-
ceedings of the ACM SIGPLAN Conference on Programming Language Design and
Implementation . 219ś232.
[20]C. Flanagan and S.N. Freund. 2009. FastTrack: Efficient and Precise Dynamic
Race Detection. In Proceedings of the ACM SIGPLAN Conference on Programming
Language Designand Implementation . 121ś133.
[21]C. FlanaganandS.N.Freund.2010. TheRoadRunnerDynamic AnalysisFrame-
workforConcurrentPrograms.In ProceedingsoftheSIGPLAN-SIGSOFTWorkshop
onProgramAnalysisfor SoftwareToolsand Engineering . 1ś8.
[22]Cormac Flanagan, Stephen N. Freund, and Jaeheon Yi. 2008. Velodrome: A
Sound and CompleteDynamic AtomicityChecker forMultithreadedPrograms.
InProceedingsofthe29thACMSIGPLANConferenceonProgrammingLanguage
Designand Implementation . 293ś303.
[23]H. Galperin and A. Wigderson. 1983. Succinct Representations of Graphs. Infor-
mation and Control 56,3 (1983), 183ś198.
[24]J. Huang, P.O. Meredith, and G. Rosu. 2014. Maximal sound predictive race
detection with control flow abstraction. In Proceedings of the ACM SIGPLAN
Conference onProgrammingLanguage Designand Implementation . 337ś348.
[25]J.HuangandA.K.Rajagopalan.2016. Preciseandmaximalracedetectionfrom
incompletetraces.In ProceedingsoftheACMSIGPLAN InternationalConference
on Object-oriented Programming, Systems, Languages, and Applications . 462ś476.
[26]S.F. Kaplan, Y. Smaragdakis, and P.R. Wilson. 2003. Flexible reference trace
reduction for VM simulations. ACM Transactions on Modeling and ComputerSimulation 13,1 (2003), 1ś38.
[27]J.C.KiefferandE.-H.Yang.2000. Grammar-basedcodes:anewclassofuniversal
lossless source codes. IEEE Transactions on Information Theory 46, 3 (2000),
737ś754.
[28]J.C. Kieffer, E.-H. Yang, G.J. Nelson, and P. Cosman. 2000. Universal lossless
compressionviamultilevelpatternmatching. IEEETransactionsonInformation
Theory46,4 (2000), 1227ś1245.
[29]D.Kini,U.Mathur,andM.Viswanathan.2017. DynamicRacePredictioninLinear
Time. InProceedings of the ACM SIGPLAN Conference on Programming Language
Designand Implementation . 157ś170.
[30]DileepKini,UmangMathur,andMaheshViswanathan.2018.DataRaceDetection
onCompressedTraces. CoRRabs/1807.08427(2018). http://arxiv.org/abs/1807.
08427
[31]A.Kinneer,M.B.Dwyer,andG.Rothermel.2007. Sofya:SupportingRapidDevel-
opment of Dynamic Program Analyses for Java. In Companion to the Proceedings
ofthe 29thInternationalConference onSoftwareEngineering . 51ś52.
[32]L.Lamport.1978. Time,Clocks,andtheorderingofeventsinadistributedsystem.
Commun. ACM 21,7 (1978), 558ś565.
[33]N.J.LarssonandA.Moffat.2000. Off-linedictionary-basedcompression. Proc.
IEEE88,11(2000), 1722ś1732.
[34]P. Liu, O. Tripp, and X. Zhang. 2016. IPA: Improving Predictive Analysis with
Pointer Analysis. In Proceedings of the International Symposium on Software
Testingand Analysis . 59ś69.
[35]A. Lozano and J.L. Balcázar. 1986. The complexity of graph problems for suc-
cinctlyrepresentedgraphs.In ProceedingsoftheInternationalWorkshoponGraph-
TheoreticConcepts inComputer Science . 277ś286.
[36]F.Mattern.1988. VirtualtimeandGlobalstatesofdistributedsystems.In Pro-
ceedings of the International Workshop on Parallel and Distributed Algorithms .
215ś226.
[37]A. Milenković and M. Milenković. 2007. An Efficient Single-Pass Trace Compres-
sionTechniqueUtilizingInstructionStreams. ACMTransactionsonModelingand
Computer Simulation 17,1 (2007).
[38]M. Musuvathi, S. Qadeer, T. Ball, G. Basler, P.A. Nainar, and I. Neamtiu. 2008.
Finding and Reproducing Heisenbugs in Concurrent Programs. In Proceedings of
theUSENIXConferenceonOperatingSystemsDesignandImplementation .267ś280.
[39]M.Naik,A.Aiken,andJ.Whaley.2006. EffectivestaticracedetectionforJava.In
ProceedingsoftheACMSIGPLANConferenceonProgrammingLanguageDesign
and Implementation . 308ś319.
[40]C.G. Nevill-Manning. 1996. Inferring Sequential Structure . Ph.D. Dissertation.
Universityof Waikato.
[41]C.G. Nevill-Manning and I.H. Witten. 1997. Identifying hierarchical structure
insequences:Alineartimealgorithm. JournalofArtificialIntelligence 7(1997),
67ś82.
[42]C.H.PapadimitriouandM.Yannakakis.1986. Anoteonsuccinctrepresentations
of graphs. Informationand Control 71,3 (1986), 181ś185.
[43]E. Pozniansky and A. Schuster. 2003. Efficient On-the-fly Data Race Detection in
MultithreadedC++Programs.In ProceedingsoftheACMSIGPLANSymposium
onPrinciples and Practice ofParallel Programming . 179ś190.
[44]P.Pratikakis,J.S.Foster,andM.Hicks.2011. LOCKSMITH:Practicalstaticrace
detection for C. ACM Transactions on Programming Languages and Systems 33, 1
(2011), 3:1ś3:55.
[45]C.v.PraunandT.R.Gross. 2001. Object race detection.In Proceedings oftheACM
SIGPLANConferenceonObject-orientedProgramming,Systems,Languages,and
Applications . 70ś82.
[46]C. Radoiand D.Dig.2013. Practicalstatic racedetection for Java parallel loops.
InProceedingsoftheInternationalSymposiumonSoftwareTestingandAnalysis .
178ś190.
[47]R. Raman, J. Zhao, V. Sarkar, M. Vechev, and E. Yahav. 2012. Scalable and Precise
Dynamic Datarace Detection for Structured Parallelism. In Proceedings of the
ACMSIGPLANConferenceonProgrammingLanguageDesignandImplementation .
531ś542.
[48]M.Said,C.Wang,Z.Yang,andK.Sakallah.2011. GeneratingDataRaceWitnesses
byanSMT-basedAnalysis.In ProceedingsoftheInternationalConferenceonNASA
FormalMethods . 313ś327.
[49]S.Savage,M.Burrows,G.Nelson,P.Sobalvarro,andT.Anderson.1997. Eraser:
A dynamic data race detector for multi-threaded programs. In Proceedings of the
ACMSymposiumonOperatingSystemsPrinciples . 27ś37.
[50]K. Sen. 2008. Race directed random testing of concurrent programs. In Pro-
ceedings of the ACM SIGPLAN Conference on Programming Language Design and
Implementation . 11ś21.
[51]Y.Smaragdakis,J.Evans,C.Sadowski,J.Yi,andC.Flanagan.2012. SoundPredic-
tive Race Detection in Polynomial Time. In Proceedings of the ACM SIGPLAN-
SIGACT SymposiumonPrinciples ofProgrammingLanguages . 387ś400.
[52]L.A. Smith, J.M. Bull, and J. Obdrzálek. 2001. A Parallel Java Grande benchmark
suite.InProceedingsofthe ACM/IEEEConference onSupercomputing . 8ś8.
[53] R. Surendran and V. Sarkar. 2016. Dynamic determinacy race detection for task
parallelismwithfutures.In ProceedingsoftheInternationalConferenceonRuntime
Verification . 368ś385.
36ESEC/FSE’18,November4ś9, 2018, Lake Buena Vista,FL,USA Dileep Kini, Umang Mathur, andMahesh Viswanathan
[54]H. Veith. 1996. Succinct Representation, Leaf Languages, and Projection Re-
ductions. In Proceedings of the IEEE Conference on Computational Complexity .
118ś126.
[55]J.W.Voung,R.Jhala,andS.Lerner.2007. RELAY:Staticracedetectiononmillions
of lines of code. In Proceedings of the ACM SIGSOFT International Symposium on
FoundationsofSoftwareEngineering . 205ś214.
[56]C. Wang, S. Kundu, M. Ganai, and A. Gupta. 2009. Symbolic Predictive Analysis
forConcurrentPrograms.In ProceedingsoftheWorldCongressonFormalMethods .
256ś272.
[57]T.A. Welch. 1984. ATechnique for High-Performance DataCompression. Com-
puter17,6 (1984), 8ś19.
[58]E.Yahav.2001. VerifyingSafetyPropertiesofConcurrentJavaProgramsUsing
3-valued Logic. In Proceedings of the ACM SIGPLAN-SIGACT Symposium on
Principles ofProgrammingLanguages . 27ś40.[59]En-Hui Yang and J. C. Kieffer. 2000. Efficient universal lossless data compression
algorithms based on a greedy sequential grammar transform. I. Without context
models.IEEE Transactions onInformationTheory 46,3 (2000), 755ś777.
[60]A.Yoga,S.Nagarakatte,andA.Gupta.2016. ParallelDataRaceDetectionforTask
Parallel Programs with Locks. In Proceedings ofthe ACM SIGSOFT International
SymposiumonFoundationsofSoftwareEngineering . 833ś845.
[61]S.ZhanandJ.Huang.2016. ECHO:Instantaneousinsituracedetectioninthe
IDE. InProceedings of the ACM SIGSOFT International Symposium on Foundations
ofSoftwareEngineering . 775ś786.
[62]J.ZivandA.Lempel.1977. Auniversalalgorithmforsequentialdatacompression.
IEEE Transactions onInformationTheory 23,3 (1977), 337ś343.
37