Parameterized Model Countingfor
Stringand Numeric Constraints∗
Abdulbaki Aydin
Microsoft
USA
abakiaydinn@gmail.comWilliamEiers
UniversityofCaliforniaSantaBarbara
USA
weiers@ucsb.eduLucasBang
UniversityofCaliforniaSantaBarbara
USA
bang@ucsb.edu
TeganBrennan
UniversityofCaliforniaSantaBarbara
USA
tegan@ucsb.eduMiroslav Gavrilov
UniversityofCaliforniaSantaBarbara
USA
mvg@ucsb.eduTevfikBultan
UniversityofCaliforniaSantaBarbara
USA
bultan@ucsb.edu
FangYu
National Chengchi University
Taiwan
yuf@nccu.edu.tw
ABSTRACT
Recently, symbolic program analysis techniques have been ex-
tended to quantitative analyses using model counting constraint
solvers. Given a constraint and a bound, a model counting con-
straint solver computes the number of solutions for the constraint
withinthebound.Wepresentaparameterizedmodelcountingcon-
straintsolverforstringandnumericconstraints.Wefirstconstruct
amulti-trackdeterministicfinitestateautomatonthatacceptsallso-
lutions to the given constraint. We limit the numeric constraints to
linear integer arithmetic, and for non-regular string constraints we
over-approximate the solution set. Counting the number of accept-
ingpathsinthegeneratedautomatonsolvesthemodelcounting
problem.Ourapproachisparameterizedinthesensethat,wedonot
assumeafinitedomainsizeduringautomataconstruction,resulting
in a potentially infinite set of solutions, and our model counting
approach works for arbitrarily large bounds. We experimentally
demonstrate the effectiveness of our approach on a large set of
string and numeric constraints extracted from software applica-
tions.Weexperimentallycompareourtooltofiveexistingmodel
counting constraint solvers for string and numeric constraints and
demonstratethatourtoolisasefficientandasormoreprecisethan
∗This material is based on research supported by an Amazon Research Award and
byDARPAundertheagreementnumberFA8750-15-2-0087.TheU.S.Governmentis
authorized toreproduceanddistributereprints forGovernmentalpurposesnotwith-
standinganycopyrightnotationthereon.Theviewsandconclusionscontainedherein
are those of the authors and should not be interpreted as necessarily representing the
official policies or endorsements, either expressed or implied, of DARPA or the U.S.
Government.
Permissionto make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,
topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ESEC/FSE ’18, November 4ś9, 2018, Lake BuenaVista,FL,USA
©2018 Associationfor Computing Machinery.
ACM ISBN 978-1-4503-5573-5/18/11...$15.00
https://doi.org/10.1145/3236024.3236064othersolvers.Moreover,ourtoolcanhandlemixedconstraintswith
stringandintegervariables that noothertoolcan.
CCS CONCEPTS
·Theory of computation →Logic and verification ;·Soft-
ware andits engineering →Software verification ;
KEYWORDS
Modelcounting, constraint solving,quantitative programanalysis
ACMReference Format:
Abdulbaki Aydin, William Eiers, Lucas Bang, Tegan Brennan, Miroslav
Gavrilov, Tevfik Bultan, and Fang Yu. 2018. Parameterized Model Count-
ing for String and Numeric Constraints. In Proceedings of the 26th ACM
Joint European Software Engineering Conference and Symposium on the
Foundations of Software Engineering (ESEC/FSE ’18), November 4ś9, 2018,
Lake Buena Vista, FL, USA. ACM, New York, NY, USA, 11pages.https:
//doi.org/10.1145/3236024.3236064
1 INTRODUCTION
Quantitativeprogramanalysisarisesinmanycontextssuchasprob-
abilistic analysis [ 11,17], reliability analysis [ 15] and quantitative
informationflow[ 5,8,29,30,34].Quantitativeprogramanalyses
require efficientmodel countingconstraintsolverstohandlecom-
plex and diverse constraints generated during program analyses. A
modelcountingconstraintsolvercomputesthenumberofsolutions
for agiven constraintwithin agiven bound [ 4,7,12ś14,27].
Inthispaper,wepresentamodelcountingconstraintsolverthat
can handle both numeric and string constraints and their combina-
tions. Given a constraint,we construct amulti-track deterministic
finiteautomaton(DFA)thatacceptstuplesofvaluesthatcorrespond
tothesolutionsofthegivenconstraint.Fornumericconstraints,we
focus on linear integer arithmetic constraints, and the constructed
automatonacceptsabinaryencodingofthenumbersthatsatisfy
the given numeric constraint. Since some string constraints can
havenon-regularsolutionsets,ourautomataconstructionapproach
over-approximatesthesolutionsetinsuchcases.Hence,ourmodel
400
ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA A.Aydinet al.
countingconstraintsolverprovidesasoundupper-boundforthe
number ofsolutions for agiven constraint.
Sinceweusemulti-trackDFA,wecanrepresentrelationalcon-
straintsthatspecifyrelationshipsamongvariables.Moreover,our
approach handles interactions between numeric and string con-
straintsinthepresenceofoperationssuchasstring lengthwhich
can be usedtogetherwithnumeric variables inaconstraint.
Automata-based constraint solving reduces the model counting
problemtopathcounting.Tocountthenumberofvaluesthatsatisfy
the given constraint withina given domainbound, we count the
numberofacceptingpathsintheautomatonwithinthepathlength
bound that corresponds to said domain bound. We use techniques
from algebraic graph theory to solve the pathcountingproblem.
We implemented the techniques we present in this paper in
a tool called Multi-Track Automata Based model Counter (MT-
ABC). We experimented on a large set of constraints generated
during symbolic execution of Java and JavaScript programs and
compared MT-ABC with five existing model counting constraint
solvers [4,7,14,27,38]. Our experiments demonstrate that MT-
ABC is as efficient and as or more precise than existing tools. More
importantly,MT-ABCistheonlytoolcanhandletheunionofall
constraints that existing tools can handle, and MT-ABC is the only
tool that can handle mixed numeric and string constraints that
contain both stringandintegervariables.
Our novel contributions in this paper are: 1) an extended con-
straint language that is more expressive than constraint languages
supportedbyothermodelcountingconstraintsolvers(Section2),2)
handlingofrelationalstringconstraintsusingmulti-trackautomata
(Section 3), 3) handling of mixedstring and integer constraintsus-
ing multiple automata (Section 3), 4) model counting for tuples
ofvariables(Section4),5)heuristicsforconstraintsimplification
(Section5),and6)anextensiveexperimentalevaluation(Section6).
AMotivatingExample. Letusgiveanexampledemonstrating
the use of model counting constraint solvers for quantitative infor-
mation flow analysis, and how this type of analysis can be used to
quantify information leakage through side-channels. This example
isbasedonasecurity vulnerabilityknownas łCompressionRatio
Info-leak Made Easyž (CRIME) [ 21,32]. Many web server requests
are compressed and encrypted for efficiency and security before
transmission asanetworkpacket.Despitethe encryption,amali-
ciousattackerwhocanobservenetworkpacketsizescanusethe
compression size to learn secret web-session information. Assume
an attacker can inject and concatenate his own text with the secret
text prior to compression. The smaller the resulting packet, the
more compressionmust have occurredprior to encryption, and so
theattacker-controlledinputmustcontainsubstringswhichmatch
substrings of the secret text. In the CRIME attack, encryption does
not significantly change the size of the packet, as many encryption
protocolsaresize-preserving.Thus,bycarefullycraftinginjected
inputs,an attackercan incrementally reveal the secrettext.
Forinstance,supposethesecretisthetext:ł sessionkey:21620 ž
Iftheattackerisabletoinjectthetextstring:ł sessionkey:12345 ž
he will observe less compression than if he injects:
łsessionkey:21600 ž because there is a longer prefix match be-
tween the attacker string and the secret string. In this way, the
attackerisabletomakerepeatedguesses andincrementallylearn
more information aboutprefixesofthe secret.Consider a simple method for compressing the concatenation of
twostrings.Forstrings sandt,wecompresstheirconcatenation,
s·t, by checking if tis a prefix of s, and if so, encoding their
concatenation as s;[k] wherekis the length of t. Iftis not a prefix
ofstheyaresimplyconcatenated.Thenotation s;[k]isinterpreted
as a pointer which indexes into s, indicating how many characters
ofstoexpandinordertorecover t.Forexample,if sisthestring
łHello, World!ž and tis the string łHellož, s·tis encoded as łHello,
World!;[5]ž. The following is a simple Java function for performing
this combinedconcatenation andcompression:
public String compress(String s, String t) {
if(s.startsWith(t)) return s + ";[" + t.\length() + "]";
else return s + t; }
This function results in an exploitable vulnerability similar to
the CRIME attack. Suppose that sis a secret string of 5 numeric
characters, and a malicious adversary has control over t. If the
adversaryisabletoobservethesizeoftheresultingcompression,
hecan learn information about sbyvarying t.
We will assume that the alphabet for sandtis the set of nu-
mericcharacters: ‘1’,..., ‘9’.By performingsymbolic executionof
compress(s,t) ,wecandeterminepathconstraintswhichleadto
differentpossibleobservationsonthesizeoftheresult.Forexample,
(usingtheconstraintlanguagewedefineinSection2)wecansee
that if(length(s)=5)∧(begins(s,t)∨length(t)=4)then the
length of the resulting string is 9. One may verify that there are
10,005possible pairsof strings (s,t)that satisfythis constraint.If
¬begins(s,t)∧length(s)=5∧length(t)=5 then the resulting
stringwillhavelength10,andthereare99 ,999possible (s,t)which
satisfythisconstraint.Assumingthat sisuniformlydistributed,we
can compute the probability of each observation by dividing the
number ofsolutions bythe total domainsize.
Prior work in quantitative information flow has proposed using
entropyasameasureofinformationleakage[ 5,8,29,30,34].Given
aprobabilitydistributionoverprogramobservables,the Shannon
entropyof the distribution is defined as H(p)=−/summationtextn
i=1pilogpi.
Applyingthistotheprobabilitiescomputedusingamodelcounting
constraintsolver,wecanquantifytheamountofinformationleaked
for our example as 0 .52 bits. Note that, in addition to a standard
symbolic execution tool, all we need in order to be able to perform
thiskindofquantitativeinformationflowanalysisisamodelcount-
ing constraint solver, and for this particular example, we need a
modelcountingconstraintsolverthatcanhandlestringconstraints
andnumeric constraintstogether.
2 CONSTRAINTLANGUAGE
We define our constraint language using the grammar shown in
Fig.1, whereφdenotes a formula, βdenotes a numeric term, γ
denotes a string term, φZdenotes a numeric constraint (an atomic
formula) constructed from terms and expressions, φSdenotes a
stringconstraint(anatomicformula)constructedfromtermsand
expressions, ρdenotes a constant regular expression, ndenotes an
integerconstant,⊤and⊥denoteconstants trueandfalse,andvi
andvsdenoteintegerandstringvariables,respectively.Weuse α
to denote φ,φZ,φS,β,orγ.
Given alphabet Σ,s∈Σ∗denotes a string value and εdenotes
theemptystring.Acharacterisastringthathaslengthone.The
stringoperationsł ·",ł/barshort",andł∗"correspondtoregularexpression
401ParameterizedModel Counting ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA
φ−→φ∧φ|φ∨φ|¬φ|φZ|φS|⊤|⊥
φZ−→β=β|β<β|β>β
φS−→γ=γ|γ<γ|γ>γ|match(γ,ρ)|contains(γ,γ)
|begins(γ,γ)|ends(γ,γ)
β−→vi|n|β+β|β−β|β×n
|length(γ)|toint(γ)|indexof(γ,γ)|lastindexof (γ,γ)
γ−→vs|ρ|γ·γ|reverse(γ)|tostring(β)|charat(γ,β)|
|substring (γ,β,β)|replacefirst (γ,γ,γ)|replacelast (γ,γ,γ)
|replaceall (γ,γ,γ)
ρ−→ε|s|ρ·ρ|ρ/barshortρ|ρ∗
Figure 1:Constraint language grammar
operationsconcatenation,alternation,andKleeneclosure,respec-
tively. Comparators ł <ž and ł>ž on string terms correspond to
lexicographicalcomparisons.An atomicconstraint referstoafor-
mulawithoutanybooleanconnectives.Noticethatanintegerterm
producedfromtheproductionrule βmaycontainstringterms γ
and vice versa; aconstraint producedin thisway is calleda mixed
constraint . The constraint language from Fig. 1is rich enough to
capturecommonconstraintsthatappearin JavaandPHPprograms.
Formalsemantics ofthis constraintlanguageisdescribedin[ 3].
Thesetofvariablespresentin φisgivenbyV(φ).Amodelforφ
is an assignment of all variables in V(φ)whereφevaluates to true.
Thetruthsetofaformula φ,denoted /llbracketφ/rrbracket,isthesetofallmodelsof
φ.The goalofmodelcountingisto determinethe size of /llbracketφ/rrbracket.
3 CONSTRAINTSOLVING VIAAUTOMATA
A multi-track DFA Ais a 5-tuple (Q,⃗Σ,δ,q0,F), whereQis the set
of states, ⃗Σ=(Σ∪{λ})kis thek-track input alphabet where Σis
thesetofalphabetsymbolsforonetrack, λ/nelementΣisapaddingsymbol
thatappearsonlyattheendofastringineachtrack, δ:Q×⃗Σ→Q
is the transition relation, q0∈Qis the initial state, and F⊆Q
is the set of accepting states. Multi-track DFA are closed under
intersection, union and complement [ 42]. With each track of A, we
associateauniqueidentifier vi,whichwerefertoasthevariable
for track i. The set of track variables for Ais denotedV(A). The
language of all strings recognized by Ais denotedL(A)where
L(A)⊆⃗Σ∗. Givena word w∈L(A), we usew[vi]∈Σ∗to denote
the value of track i. Hence,w∈L(A)denotes a tuple of values
(w[v1],w[v2],...,w[vk]),one valuefor eachvariable in V(A).
Givenaformula φ,ourgoalistoconstructanautomaton A,such
thatL(A)=/llbracketφ/rrbracket, where the tracks of Acorrespond to the variables
ofφ. We call this DFA the solution automaton forφ. Some mixed
constraintsandsomepurestringconstraintshavenon-regulartruth
sets [42]. For such constraints we provide a sound over approxima-
tionbyconstructing an automaton Asuch that /llbracketφ/rrbracket⊆L(A).
Duringourconstruction,inadditiontohavingonetrackforeach
variableoftheformulainthemulti-trackautomaton,wealsocreate
onetrackforeachstringterm(shownas γinFigure 1)andonetrack
foreach numeric term (shown as βinFigure 1). Actually,forthe
termsthatcorrespondtoaddition,subtractionandmultiplication
withaconstantwedonotcreateseparatetracksaswediscussin
Section3.3. Given a term γorβ, we uset(γ)andt(β)to denote
the tracks that thoseterms are associatedwith.
Wedefineaprojectionoperation πsuchthat,givenanautomaton
Aanda variableset V,π(A,V)isanautomaton A′whereV(A′)=Algorithm1 Solve(A,α)
Procedureoperatesonanautomaton Awhichispassedbyreferenceand
has atrackforeachvariableandterm in α.
αis one of thefollowing: a conjunction of numeric andstring constraints,
a string constraint, a numeric constraint, a string term, or a numeric term.
⋆∈{=,/nequal, <,≤, >,≥,match,¬match,contains,¬contains,
begins,¬begins,ends,¬ends}
⊙∈{−,+,×,length,toint,indexof,lastindexof ,reverse,tostring,
charat,substring ,replacefirst ,replacelast ,replaceall}
1:ifα≡α1∧α2then
2:Solve(A,α1);Solve(A,α2);
3:Propagate (A,α1);Propagate (A,α2);
4:else ifα≡α1⋆α2then
5:Solve(A,α1);Solve(A,α2);
6:Refine(A,⋆,t(α1),t(α2)) ▷modifiestracks t(α1)andt(α2)
7:Propagate (A,α1);Propagate (A,α2);
8:else ifα≡⊙(α1, .. .,αn)then
9:for allαi∈{α1, .. .,αn}do
10: Solve(A,αi);
11:endfor
12:Restrict(A,t(α),⊙,t(α1), .. .,t(αn)); ▷modifiestrack t(α)
13:endif
Algorithm2 Propagate (A,φ)
Procedureoperatesonanautomaton Awhichispassedbyreferenceand
has atrackforeachvariableandterm in φ.
⊙∈{−,+,×,length,toint,indexof,lastindexof ,reverse,tostring,
charat,substring ,replacefirst ,replacelast ,replaceall}
1:ifφ≡⊙(α1, .. .,αn)then
2:Refine(A,t(α),⊙,t(α1), .. .,t(αn));▷modifiestracks t(α1)tot(αn)
3:for allαi∈{α1, .. .,αn}do
4: Propagate (A,αi);
5:endfor
6:else ifφ≡φ1∧φ2then
7:Propagate (A,φ1);Propagate (A,φ2);
8:else ifφ≡φ1∨φ2then
9:Aφ1=A∩Aφ1;Aφ2=A∩Aφ2;
10:Propagate (Aφ1,φ1);Propagate (Aφ2,φ2);
11:endif
V.Letx1,...,xn∈V\V(A)bethevariablesin VbutnotinV(A)
andy1,...,ym∈V(A)\Vbe the variables in V(A)but not in
V. That is, we wish to add new unconstrained xitracks to Aand
removeyjtracksfrom A.Then,wedefine π(A,V)tobeamulti-track
DFAA′withV(A′)=Vsuch that:
w′∈L(A′)⇔∃w∈L(A),∀v∈V(A′)∩V(A),w[v]=w′[v].
3.1 Automata Construction
Since the negation operator is non-monotonic and since we some-
timesover-approximatethesolutionsetsofsubformulas,beforethe
automataconstruction,weconverttheinputformulatonegation
normal form bypushingnegations to atomicformulas.
Wefirstdescribeourautomataconstructionalgorithmforcon-
straints which are conjunctions of numeric and string constraints
(i.e.,φZandφSin Fig.1, respectively). We describe how we handle
combinationsofconjunctions anddisjunctionslater.
Letφbe a formula which is a conjunction of numeric and string
constraints. The automata construction procedure Solve(Algo-
rithm1) recursively constructs a multi-track automaton Asuch
that,when Aisprojectedtothevariablesof φ(i.e.,V(φ)),itaccepts
anoverapproximationof φsolutionsset,i.e., /llbracketφ/rrbracket⊆L(π(A,V(φ))).
402ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA A.Aydinet al.
Procedure Solvepasses the automaton Aby reference, so there
is a single automaton Athat is being modified. Before the first call
totheSolveprocedure, Aisinitialized sothat alltracksaccept all
strings,i.e.,initially, L(A)=⃗Σ∗.
The procedure Solveuses three other procedures during the
construction of automaton A:Restrict ,RefineandPropagate .
Again,theautomaton Aispassedbyreference,soalltheseproce-
dures modify the same automaton Aduringconstruction.
Theprocedure Restrict isusedtocomputetheresultofastring
ornumericoperator.Notethat,thereisatrackin Aforeachterm
inφ, so the result of each string or numeric operator has a track
reserved for the corresponding term. Let us denote the string or
numeric operator with the symbol ⊙, whereα≡⊙(α1,...,αn).
Then,Restrict (A,t(α),⊙,t(α1),...,t(αn))restricts the track in
Athatcorrespondstotheterm ⊙(α1,...,αn)basedonthetracksof
thearguments α1,...,αninA.Forthistowork,weneedtomake
sure that the arguments’ tracks are processed first, and this is done
inthe for loopbefore Restrict iscalled.
For example, consider the term charat(v,i).Restrict (A,
t(charat(v,i)),charat,t(v),t(i))restricts track t(charat(v,i))in
Ato string values that correspond to characters that can appear at
locationiofstringv,wherepossiblevaluesfor vandiarespecified
bythe valuesrecognizedbytracks t(v)andt(i),respectively.
The procedure Refineis used toreflect theconstraint imposed
by astring ornumeric predicate orits negation to its arguments.
Let us denotethe string ornumeric predicate with the symbol ⋆,
whereα1⋆α2andα1andα2are string or numeric terms. Then,
Refine(A,⋆,t(α1),t(α2))reflects the constraint imposed by the
predicate α1⋆α2to the tracks t(α1)andt(α2). BeforeRefineis
calledarguments ofthe predicate ⋆are processed.
For example, for the equality predicate charat(v,i)="a",
Refine(A,=,t(charat(v,i)),t("a"))restricts the set of values for
trackt(charat(v,i)), to the string "a". Note that, since "a"is a
constant,wedonotactuallyneedatrackforit,butforsimplicity
of presentation, let us assume that constants are also assigned a
track which accept just the value that corresponds to the constant.
AfterRefineis called, the set of strings recognized by the argu-
ments’ tracks may have changed and must be propagated to the
other tracks (as arguments can be terms constructed from other
arguments).Thisisdoneusingthe Propagate procedure.Forexam-
ple, once we refine the set of values for track charat(v,i)based on
the predicate charat(v,i)="a"we have to propagate this change
totheargumentsoftheoperator charatandrefinethevaluesfor
t(v)andt(i).We callPropagate (A,charat(v,i))to do this.
In general, we use the Propagate procedure when the result
of a string or numeric operator is refined due to a string or nu-
meric predicate, and this refinement has to be propagated to the
argumentsoftheoperator.AsshowninAlgorithm 2,Propagate (A,
⊙(α1,...,αn))firstcallsRefine(A,t(α),⊙,t(α1),...t(αn))which
refines the tracks for the arguments of the operator ⊙based on the
trackforthe⊙term.Afterthisrefinement,itrecursivelycallsthe
procedure Propagate ontheargumentsofthe ⊙termtofurther
propagatethe refinement.
As shown in Algorithm 3, we extend the Solveprocedure to
combinationsofconjunctionsanddisjunctions.Forconjunctions
we use a single automaton. After a conjunction is solved, it isAlgorithm3 Solve(A,φ)
Procedureoperates on an automaton Awhichis passed by reference.
Disjunctions createaseparate automaton foreachdisjunct.
Conjunctionsuse asingle automaton forallconjuncts.
1:ifφ≡φ1∨φ2then
2:Solve(Aφ1,φ1);Solve(Aφ2,φ2);
3:A=Aφ1∪Aφ2▷Union computed using automataproduct
4:else ifφ≡φ1∧φ2then
5:Solve(A,φ1);Solve(A,φ2);
6:Propagate (A,φ1);Propagate (A,φ2);
7:Solve(A,φ1);Solve(A,φ2);
8:endif
0 1 2(0,1)(1,0)(1,1)
(0,1)
(0,0)(0,0) (i,j)
0 1 2b
a,baa,bv
Figure 2:Automataconstructed forExample 1
necessarytopropagatetheresulttothechildrenoftheconjunction.
After propagation, the conjunction is solved again so that the final
automatoncaptures allthe refinements.
Fordisjunctions,eachdisjuncthasitsownautomaton.Then,the
automatonforthedisjunctioncorrespondstotheautomatonthat
accepts the union of sets accepted by each disjunct automaton. We
compute the union automatonusing automataproduct.
Letusconsiderthe following example constraint:
charat(v,i)="a"∧i=2×j (1)
We show the resulting automata in Figure 2. Note that, to make
the example more readable, we split the automaton to two, one
for string variables and one for integer variables. In fact, in our
implementation we also split the automata to multiple automata
basedonthedependenciesamongvariables,whichwediscusslater
withotherheuristics.
3.2 String ConstraintSolving
WenowdiscusshowAlgorithm 1handlesatomicconstraints α≡
α1⋆α2, whenαis aφSterm,⋆is a string predicate, and α1andα2
are string terms ( γ). In particular, we will focus on the Restrict
andRefineproceduresonstring termsandstringpredicates,and
discussarepresentativesubsetofstringtermsandstringpredicates.
Let us use the notation introduced in Figure 1whereβdenotes
integerterms, γdenotesstringterms,and ρdenotesregularexpres-
sion terms. Given an automaton A, function t(α)represents the
possiblevaluesoftheterm αthatisencodedasatrackinthegiven
automaton. Let t′(α)represent the result of a Restrict orRefine
procedure call on the corresponding track. The prefixes:Σ∗→Σ∗
function computes the set of prefixes for a given set of strings and
thesuffixes:Σ∗→Σ∗function computes the set of suffixes for
a given set of strings. Both functions can be implemented using
projection, determinization, and minimization operations on DFAs.
Letusconsidertheoperations length,indexof,substring ,charat,
andł·ž(stringconcatenation) operations.
Restrict (A,t(length(γ)),length,t(γ)):
t′(length(γ))={i|∃s∈t(γ):i=|s|∧i∈t(length(γ))}
403ParameterizedModel Counting ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA
Restrict (A,t(indexof(γ1,γ2)),indexof,t(γ1),t(γ2)):
t′(indexof(γ1,γ2))={i|∃s∈prefixes(t(γ1)),u∈t(γ2),
v∈Σ∗:suv∈t(γ1)∧∄s1∈suffixes(prefixes(s)):
s1=u∧i=|s|∧i∈t(indexof(γ1,γ2))}
Restrict (A,t(substring (γ,β1,β2)),substring ,t(γ),t(β1),t(β1)):
t′(substring (γ,β1,β2))={s|∃t∈t(γ):∃t1∈prefixes(t),
t2∈Σ∗:t=t1t2∧|t1|∈t(β1)∧∃v∈prefixes(t2):
|v|∈t(β2)∧s=v∧s∈t(substring (γ,β1,β2))}
Restrict (A,t(γ1·γ2),·,γ1,γ2):
t′(γ1·γ2)={s|∃s1∈t(γ1),s2∈t(γ2):s=s1s2∧s∈t(γ1·γ2)}
Notethat charatoperationcanberewrittenas substring (γ,β,1)
wherethelastparameteristhelengthofthesubstring,hencethe
Restrict andRefineforcharatcanbecomputedusingcorrespond-
ingoperations for substring .
Let us now discuss the Refineprocedure. Consider the string
predicates=,match, andcontains. Predicate operations create a
booleanrelationbetweentheinputtracks.Wedefinetherelation
withtuples ofstrings that correspondto valuesfrom inputtracks.
Refine(A,=,t(γ1),t(γ2)):{(s,t)|s∈t(γ1)∧t∈t(γ2)∧s=t}
Wecanimplementthesemanticsoftheequalitypredicateusingthe
multi-trackDFAsprecisely.Procedure Propagate mustbecalled
when tracks represent terms that include stringterm operations.
Refine(A,match,t(γ),t(ρ)):{s|s∈t(γ)∧s∈t(ρ)}
Notethat matchoperationtakesaconstantregularexpressionas
an argument. We do not need to create a relation between a string
termandaconstantregularexpressionconstant.Hence,weonly
refine the stringterm inthe matchpredicate.
Refine(A,contains,t(γ1),t(γ2)):{(s,t)|s∈t(γ1)∧t∈t(γ2)∧s∈
Σ∗t(φ2)Σ∗∧t∈suffixes(prefixes(t(γ1))}
Here,semanticsofthe contains operationdoesnotenforcetherela-
tion between the input tracks’ values. In other words, if one of the
tracks is updated by another operation,we need to propagate that
update back to the contains operation. The Propagate procedure
callsafterconjunctionsmakesurethatrefinementforthe contains
operation isexecutedagainoncethere isan update.
Next,wedefinethe Refinesemanticsforthestringtermoper-
ations.Letusconsidertheoperations length,indexof,substring ,
charat,andł·žagain.
Refine(A,t(length(γ)),length,t(γ)):
t′(γ)={s|∃t∈t(length(γ)):|s|=t∧s∈t(γ)}
Refine(A,t(indexof(γ1,γ2)),indexof,t(γ1),t(γ2)):
t′(γ1)={s|∃t,u,v∈Σ∗:|t|∈t(indexof(γ1,γ2))∧
u∈t(γ2)∧s=tuv∧s∈t(γ1)}∧
t′(γ2)={s|∃t,v∈Σ∗:t∈t(indexof(γ1,γ2))∧
tsv∈t(γ1)∧s∈t(γ2)}
Refine(A,t(substring (γ,β1,β2)),substring ,t(γ),t(β1),t(β1)):
t′(γ)={s|∃t,u∈Σ∗,v∈t(substring (γ,β1,β2)):
|t|∈t(β1)∧|v|∈t(β2)∧s=tvu∧s∈t(γ)}∧
t′(β1)={i|∃t,u∈Σ∗,s∈t(γ),v∈t(substring (γ,β1,β2)):
|v|∈t(β2)∧s=tvu∧i=|t|∧i∈t(β1)}∧
t′(β2)={i|∃t,u∈Σ∗,s∈t(γ),v∈t(substring (γ,β1,β2)):
|t|∈t(β1)∧s=tvu∧i=|v|∧i∈t(β2)}01
2 3(0,0)
(0,1)(0,0)
(0,1)
(1,0)(1,1)
(1,0)(1,1)(i,j)
Figure 3:Automatonbuilt forthe constraint φ1≡i=2×j
Refine(A,t(γ1·γ2),·,t(γ1),t(γ2)):
t′(γ1)={s|∃t∈t(γ1·γ2),v∈t(γ2):t=sv∧s∈t(γ1)}∧
t′(γ2)={s|∃t∈t(γ1·γ2),v∈t(γ1):t=vs∧s∈t(γ2)}
The algorithms for the Restrict andRefineprocedures are
basedonpre-andpost-imagecomputationinstringanalysissimilar
to the ones usedin[ 2,39,40].
Let us consider the string constraint example charat(v,i)=
"a"again. Initially t(v)andt(i)are unconstrained. Based on the
semantics, Restrict (A,t(charat(v,i)),Σ∗,Σ∗)computes the set
fort′(charat(v,i))asΣ∗. Next, the Refine(A,=,Σ∗,"a")refines
t(charat(v,i))as{"a"}.Notethat,wearenotablekeeptherelation
betweencharat(v,i),v, andionce they are computed. As equality
predicate updates the t(charat(v,i)), we need to propagate the re-
sultbackto vandi.Inthefinalstep, Refine(A,{"a"},charat,Σ∗,Σ∗)
is called to refine vandi. The final refinement sets the t(v)as
Σ∗"a"Σ∗andt(i)as{i|i>=0}.
3.3 IntegerConstraintSolving
WenowfocusoutattentiontothebranchofAlgorithm 1forα≡
α1⋆α2, whenαis aφZterm,⋆is an integer term comparison
operator,and α1andα2arelinearcombinationsof atomicinteger
terms.Anysuchintegertermconstraintcanberewrittenbymoving
alltermstoonesideof ⋆anddecomposingitintoasemantically
equivalentconjunctionofconstraintsinwhich ⋆is≤.Thus,without
loss of generality, we focus on integer term constraints of the form
φZ≡0≤n/summationdisplay
i=1ciβi (2)
wherecidenotesanintegerconstantcoefficientand βiisanatomic
integerterm.
Algorithm 1iswritteninawaythatitwouldprocesseachbinary
+term separately. However, in the case of integer constraints of
the form in expression 2, we construct a DFA for all terms of φZ
at once. That is, when we call Refine(A,≤,t(β1),...,t(βn))we
useanautomatonconstructionthatupdatesall βitrackssimultane-
ously.Thisautomataconstructionmethodisbasedonalgorithms
that construct a binary adder state machine [ 9]. GivenφZas in
expression 2, we use those algorithms to directly construct a multi-
trackautomaton Aoverthebinaryalphabet {0,1}suchthateach
track corresponds a βi, andL(A)is the set of tuples of satisfy-
ing assignments for (β1,...,βn), encoded as binary integers in 2’s
complementform,reads from leastto mostsignificant bit.
Forinstance,considertheconstraint i=2×jforintegervariables
iandj.ThebinaryDFAforthisconstraintisdepictedinFigure 3.
Onepossibleacceptingsequenceofstatesis0 ,2,3,0,1.Bytaking
theright-handconcatenation(astheDFAreadsleastsignificantbits
first)ofthepairsofbitsalongthecorrespondingtransitions,weget
404ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA A.Aydinet al.
(0110,0011)in binary which is (6,3)in decimal. The DFA captures
allpossibleintegersolutionsinthisway,withleading1’sindicating
negative numbers inthe standard2’s complementencoding.
3.4 BinaryandUnaryEncodings
Astringtermcanhaveintegersub-termsandaintegertermscan
containstringsub-terms.As describedintheearlier discussionof
Algorithm 1,wecallPropagate ,Refine,andRestrict toupdate
therelationshipbetweenthestringandintegervariables.However,
ourbinaryintegerarithmeticrepresentationisnotdirectlycompat-
ible withautomatonoperations over standardstringautomata.
As just described, we can precisely solve multi-variable linear
integer arithmetic constraints by constructing a multi-track binary
integer automaton that recognizes tuples of solutions. However,
integervariablesolutionscanberelatedtostringvariablesthrough
operations that have both string and integer parameters such as
lengthorindexof. Given the DFA representing the solutions for
integervariables,wemustpropagatetheconstraintsimposedby
the integer solutions to each related string variable. We do so by
first converting the binary DFA solution representation Afor an
integervariable ito asetcomprehensionrepresentation S.
Our conversion from binary integer DFA Ato a set compre-
hensionSuses algorithms from [ 23,24,41], which show how
to construct a description of a semilinear set from a binary DFA,
whichwenowdescribeatahighlevel.Alinearset Liisgivenby
{a0+a1k1+...ankn:kj∈Z}wherethe ajconstantintegers are
calledthe periodsofthelinearset.Asemilinearset Sisafiniteunion
of linear sets, S=∪iLi. For any binary integer DFA Aconstructed
fromlinearintegerarithmeticconstraints,theacceptedintegersfor
eachtrackofAformasemilinearset.Furthermore,foranytrack
(which corresponds toan integerterm), we canrecover asetcom-
prehension for the semilinear set Sthat it represents [ 23,24,41].
Intuitively, this works by examining the periods of the loops in
the strongly connected components of the binary DFA inorder to
find the periods for a linear set Li⊆L(A). A DFA representing
the setLiis then subtracted from Ausing DFA complement and
intersection, andwe iterate this procedure until L(A)=∅.
Oncewehave S,forasingletrackofthebinaryDFA A,which
correspondstoasingleintegerterms,wethenconvert Sintoaunary
DFAA′,whichforanyinteger m∈Sacceptsallstringsoflength m.
TheunaryDFA A′isthencompatiblewithstringautomataandcan
beusedtorestrictorrefinethesetofstringmodels.Forexample,if
S={2+5k1+4k2}the corresponding unary DFA is shown below,
which has an initial segment of length 2 and two interleaved loops
ofperiods4and5.
0123456ΣΣΣΣΣΣΣ
Σ
We described how to propagate solutions from binary integer
DFA to string DFA. In order to propagate solutions from string
DFA to binary integer DFA, we reverse this process by converting
astringDFAintoaunarylengthDFA,extractingthesemilinearset,
andconstructing the corresponding binary integerDFA.
Considerthe following example constraint:
i=2×j∧length(v)=i (3)0
 1 2
(0,0,1)
(1,1,0)
(1,1,1)
(0,0,1)
(0,0,0)
(0,0,0) (vl,i,j)
0
 1
a,b
a,bv
Figure 4:Final automataconstructed forExample 3
Example 3isaconjunctionofanatomicintegerconstraints φ1≡
i=2×jandφ2≡length(v)=i. The constraint φ2is also a mixed
constraintas itcontains both astringandan integervariable.
Figure4shows the final automata constructed for the input
formulaφ≡i=2×j∧length(v)=i. The auxiliary variable vl
representsbitwiseencodingsofthelengthsofthestringsthatare
representedwiththe variable v.
4 MODEL COUNTING
Inthissection,wedescribehowtoperformparameterizedmodel
countingbymakinguseoftheautomataconstructedbyourcon-
straintsolvingprocedure.The modelcountingproblem istodeter-
minethesizeof /llbracketφ/rrbracket,whichwedenote# /llbracketφ/rrbracket.Whileaformulacan
haveinfinitelymanymodels,wecancountthenumberofmodels
inaninfinitespaceofsolutionsrestrictedtoafiniterangeforthe
freevariables.Hence,weperform parameterizedmodelcounting for
stringandintegerconstraints,where# /llbracketφ/rrbracket(bS,bZ)isafunctionover
parameters bS,whichboundsthelengthofstringsolutions,and bZ,
whichbounds the bit-lengthrepresentation of integersolutions.
TheconstraintsolvingprocedureproducesafinalDFA, A,that
contains multi-track solution sub-automata ASandAZ. The sep-
aration of string and integer automata may lose some relational
information between string and integer variables; we can multiply
themodelcountsforeachautomatoninordertogiveasoundupper
bound on the number of models for tuples of integer and string
variables. We use functions # FAS(k)and #fAZ(k)to count string
andintegermodels respectively.
We rely on the observation that counting the number of strings
oflength kinaregularlanguage, L,isequivalentto countingthe
numberofacceptingpathsoflength kintheDFAthataccepts L.
Thatis,byusingaDFArepresentation,wereducetheparameterized
modelcountingproblemtocountingthenumberofpathsofagiven
length in a graph. In a DFA, there is exactly one accepting path for
every recognized string. Thus, if we are interested in computing
only string models or only integer models, there is no loss of preci-
sionduetothethemodelcountingprocedure;anylossofprecision
for strings comes from the over-approximations of non-regular
constraintsinthesolvingphase,andforpureintegerconstraints,
themodelcountingprocedureisprecisebecauseintegersolution
automataconstruction isprecise.
Given a string automaton AS, computation of # fAS(k), the num-
ber of accepted strings of length k, can be done by constructing
the transfer matrix of the automaton based on its transition rela-
tion[31,35].LetASbeaDFAwith nstates.Thetransfermatrix Tof
Ais a matrix where Ti,jis the number of transitions from state ito
statej.Thenumberofpathsoflength kthatstartinstate iandend
in statejis given by (Tk)i,j. Then the number of strings of length
kaccepted by Acan be computed using matrixmultiplication. We
compute uTkv, whereuis the row vector such that ui=1 if and
405ParameterizedModel Counting ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA
φ∧φ→φ φ∨φ→φ φ∨⊤→⊤
φ∧⊤→φ φ∨⊥→φ φ∧⊥→⊥
0×β→0 1×β→β β+0→β
β−0→β β=β→⊤ i/nequalj→⊤
−(−β)→β¬(¬β)→β β/nequalβ→⊥
i=j→⊥ | ϵ|→0|vs1.vs2|→|vs1|+|vs2|
γ.ϵ→γ ϵ .γ→γmatch(γ,t)→γ=t
γ=γ→⊤ γ1.t=γ2.v→⊥ contains(γ2.γ1.γ3,γ1)→⊤
γ/nequalγ→⊥ γ1.t/nequalγ2.v→⊤ begins(γ1.γ2,γ1)→⊤
t=v→⊥ t.γ1=v.γ2→⊥ ends(γ2.γ1,γ1)→⊤
t/nequalv→⊤ t.γ1/nequalv.γ2→⊤t.γ1=t.γ2→γ1=γ2
t1.t2→t1t2 γ1.t=γ2.t→γ1=γ2
Figure 5:Term reductionrules
onlyifiisthestartstateand0otherwise,and visthecolumnvector
wherevi=1ifandonlyif iisanacceptingstateand0otherwise.
Notethatforrelationalstringconstraints,thetransitionalphabetis
over tuples of characters and the method described here will count
thenumberoftuplesofsolutionsofagivenlength.Ourcounting
method is parameterized in thefollowing sense: after a constraint
is solved, we can count the number of solutions of any desired size
kbycomputing uTkv,withoutre-solving the constraint.
Themethoddescribedabovecomputes# fAS(k),thenumberof
string solutions of length exactlyk. It is of interest to compute
#FAS(k), the number of solutions withina given bound. This is
accomplishedeasilyusingaknownłtrickžoftenusedtosimplify
graphalgorithms.Weaddanartificialacceptingstate sn+1toAS,
resulting in a new DFA A′
S, withλ-transitions from each accepting
statetosn+1,andaλ-cycleonsn+1.Thenonecanseethat# FAS(k)=
#fA′
S(k+1),andsowe apply the transfer matrixmethodon A′
S.
Themethodforcountingstringsofagivenlengthallowsusto
performmodelcountingforlinearconstraintsaswell.However,we
mustinterpretthebound kinaslightlydifferentmanner.Asolution
DFAAZfor a set of integer tuples encodes the solutions as bit-
strings.Thus,pathsoflength kinanintegerautomatoncorrespond
to bit string of length k. Since we are using a 2’s complement
representationwithleadingsignbits,bitstringsofexactlylength k
correspondtointegersintherange[ −2k−1,2k−1).Thus,thetransfer
matrixmethodallowsustoperformmodelcountingoverinteger
domains parameterized by intervals of this form by computing
#fAZ(k).Tocountmodelsforarbitraryintervals (a,b),weintersect
AZwiththeDFArepresenting a≤xi≤bforanyvariable xi,and
then count pathsinthe resultingDFA.
The methods described above allow us to compute # FAS(k)
and #fAZ(k)independently. Now, we can compute # φ(bS,bZ)=
#FAS(bS)·#fAZ(bZ).
5 CONSTRAINTSIMPLIFICATION
Weuseseveralheuristicstosimplifytheconstraintsbeforeautomata-
construction andmodelcountingsteps.
TermRe-WriteRules: Alltermsarefirstreducedwithrespect
to a re-write system based on a set of rules (Fig. 5). These rules
includebothtermnormalizationrulesandtautologicalsimplifica-
tions of atomic constraints. Here, i,jare distinct integer constants,
t,varedistinctstringconstantsand γ1,γ2,γ3are(notnecessarily
distinct) stringterms.
DependencyAnalysis: Toreducetheamountofworkrequired
tosolveaconstraint,wenotethatnotallvariablesofaconstraintγ1.begins(γ2)→|γ1|≥|γ2|γ1.contains(γ2)→|γ1|≥|γ2|
γ1.ends(γ2)→|γ1|≥|γ2| ¬ γ.ends(t)→γ/nequalt
¬γ.contains(t)→¬γ.begins(t)
γ1.γ2=γ3.γ4→ |γ1|+|γ2|=|γ3|+|γ4|
γ1.γ2=γ3→ |γ1|+|γ2|=|γ3|∧γ3.begins(γ1)
Figure 6:Implicationrules
needbecountedtogether.Wedefinethe constraintgraph ofafor-
mulaφtobethegraphdefinedonthesetofvariablesof φwhere
an edge exists between any two variables if they appear in the
same clauseof φ.Thisconstraintgraph canbe decomposedintoa
finitesetofconnectedcomponents.Aconnectedcomponent Cis
amaximalsubgraphsuchthatif u,v∈Cthenthereexistsapath
betweenuandvinC. Constraints on any given variable depend
only on variableswithin its connected component. This allows us
todecomposeaformulabasedonconnectedcomponents,solveand
counteachcomponentindividually,andthentaketheproductof
the results to obtain accurate counts for tuples of variables. This
results insmallerautomataandfaster computation.
Equivalence Classes: When no disjunctions are present, the
variablesof a formula φcan be partitionedinto equivalence classes
so that any pair of given variables x,yare in the same equivalence
classonlyiftheyhavethesamesolutionset.Inourimplementation,
weconstructtheseequivalenceclassesbasedonequalityclauses.
Every term, variable or otherwise, begins in its own equivalence
classandforeveryequalityclause,theequivalenceclassesofthe
left and right sides are merged. From each equivalence class a rep-
resentative is chosen. Each variableinthe equivalence classis then
replaced by this representative in the formula φ. This optimization
canresultin the eliminationof variablesfrom φ,andhencetracks
from its DFA,withoutany lossof precision incounting.
Term Elimination via Substitution: Constraints generated
fromsymbolicexecutioninthepresenceofloopsresultinthead-
dition of many intermediate variables and terms, usually due by
loopunrolling.Theseintermediatetermsformacontinuouslink
betweenthestate ofvariablesbeforeand after theloop body,rep-
resented as conjunctions between word equations. If the variables
donotappearelsewhereintheconstraintformula,wecollapsethis
chain intoasinglewordequality.
Implication Rules: As noted previously, our automata con-
structionforsomeconstraintscanbeimprecise.Precisioncanbe
improved for some of these constraints by augmenting the original
formulaφwithclausesimpliedby φ.Wepresentasetofimplication
ruleswhichdefine theaugmentingclausesaddedto φinthepres-
enceofcertainimpreciseconstraintsinFig. 6.Weonlyaddaclause
toφifwecansolveitpreciselyandifitcanpotentiallyimprovethe
precisionforanotherconstraint.Implicationsonstringvariables
appearing in multiple word equations under the same conjunction
are combinedintoasingleimplicationwhenever possible.
6 IMPLEMENTATION AND EXPERIMENTS
We implemented the techniques we presented in this paper in
a tool called Multi-Track Automata Based model Counter (MT-
ABC)1by extending an existing tool called Automata Based Model
Counter(ABC).WeevaluatedtheprecisionandperformanceofMT-
ABCusingthreetypesofconstraints:constraintssolelyonstring
1available at https://github.com/vlab-cs-ucsb/ABC
406ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA A.Aydinet al.
variables,constraintssolelyonintegervariables,andconstraints
that contain both stringandintegervariables.
We experimentally compared MT-ABC with five existing model
countingconstraintsolvers:(1)ABC[ 4],asingle-trackautomata-
basedmodelcounterforstrings,(2)S3#[ 38],amodelcounterfor
strings with some capability of handling relations between strings
and integers, (3) SMC [ 27], a string model counter, (4) LattE [ 7,26],
amodelcounterforlineararithmeticconstraints,and(5)SMTAp-
proxMC [ 14], an approximate model counter for the theory of
fixed-widthwords.
Our experiments show: 1) MT-ABC is as or more precise with
comparableefficiencythanexistingstringmodelcounters.2)Multi-
track automata enables MT-ABC to capture relations between vari-
ables more precisely than single-track automata used in ABC. 3)
ParameterizedmodelcountingenablesMT-ABCtocomputemul-
tiple length bounds for the same formula efficiently without re-
solving. 4) MT-ABC and S3# are the only tools that support mixed
constraintswithstringandintegervariables.MT-ABCisasormore
precisethanS3#formodelcountingconstraintsinvolvingrelations
between string and integer variables, MT-ABC can handle a richer
setofconstraintsthanS3#,andS3#produces unsoundresults.
Allexperiments,otherthanthoseinvolvingS3#,weredoneon
anUbuntu16.04machinewithInteli53.5GHzX4processorsand
32GB ofmemory. We were unableto run S3# onUbuntu 16.04; all
experiments involving S3# were done on the same machine but
within an Ubuntu14.04 virtual machine with8GB ofmemory.
6.1 String Constraints
Security Benchmark: Constraints in this benchmark are taken
fromvarioussecuritycontexts[ 27,38].Forexample,twoconstraints
extracted from string manipulation utilities within the BUSYBOXY
v.1.21.1package(wcandgrep),andoneconstraintextractedfroma
utilityintheCOREUTILSv.8.21package(csplit)areusedtoquantify
information leakage for homomorphically encryptedinputs.
Table1shows the results of MT-ABC, ABC, S3#, SMC for the
security benchmark. Second column shows the string length value
usedformodelcounting(i.e.,thetoolscountthenumberofsolution
strings with the specified length), last column indicates scale for
largerlengths.BothMT-ABCandABCreportanupperboundon
the numberof solutions, while both SMC and S3# give both lower
andupperbounds(S3#reportsanexactcountwhentheboundsare
the same). Both MT-ABC and S3# generate bounds which are as or
moreprecisethanthosereportedbySMC.Inallcases,MT-ABCisas
ormoreprecisethanABC.TheboundsgeneratedbybothMT-ABC
andS3#agreeforallconstraintsexceptghttpdandghttpd_wo_len,
whereghttpd_wo_lenisderivedfromghttpdbyremovingthepart
of the constraint that uses the string length function. For solution
stringsoflength620,thetwosolversgivedifferentcounts.Wecould
notconfirmthemodelcountfortheseconstraintsastheyaretoo
complextomanuallycount.However,whileexperimentingwith
variations of these constraints, we found out that S3# computes an
erroneous count for a simplified version of these constraints. So,
we believe that the count that S3#reports iserroneous.
Therunningtimesforallfourmodelcountersarecomparable
forsmallconstraints(obscure,strstr,regex,contains).Forlargecon-
straints(ghttpd,wc,csplit,nullhttpd),ABCeithertimesoutafter20 minutes or runs out of memory, while both MT-ABC and S3#
produceresultsfasterthanSMC.Whentheinputconstraintcon-
tains a high concrete value for the string length (ghttpd, wc, grep),
MT-ABC generates a large automaton, which leads to a higher run-
ning time, whereas without the length constraint (ghttpd_wo_len),
both MT-ABC andABC produce results quickly.
SimplifiedKaluzaBenchmark: SimplifiedKaluzabenchmark
isasetofsatisfiableconstraintsgeneratedviasymbolicexecutionof
JavaScript and originally solvedwith the Kaluza string solver[ 33].
The authors of SMC simplified the Kaluza benchmark by replacing
integer variables with constants and by removing disjunctions,
since SMC cannothandle integervariables andloses precision for
disjunctiveconstraints.Then,theytranslatedtheseconstraintsinto
theirinputformatandseparatedthemintotwosets:SMCSmalland
SMCBig.WetranslatedthemfromSMCformattoMT-ABCinput
format. The SMCSmall set contains 17544 constraints and SMCBig
contains1342constraints.Eachconstraintcontainsaqueryvariable
tomodelcounton.Wecomparedtheperformanceandupperbounds
producedbyMT-ABC, ABC, andSMC using this benchmark.
Table2compares MT-ABC to ABC and MT-ABC to SMC for
solution strings less than or equal to 50. We did not include S3# in
this comparison since S3# can only model count solution strings
havinglength exactly equal to the given given length.
For SMCSmall constraints ABC takes 0.0036s per constraint,
SMC takes 0.42s per constraint, and MT-ABC takes 0.011s per con-
straint, on average. For SMCBig constraints ABC takes 6.09s per
constraint,SMCtakes4.08sperconstraint,andMT-ABCtakes1.35s
per constraint, on average. For SMCSmall constraints, MT-ABC
generates a more precise count than ABC for 6% of the constraints,
and MT-ABC generates a more precise count than SMC for 0.9%
oftheconstraints.ForSMCBigconstraints,MT-ABCgeneratesa
moreprecisecountthanABCfor78%oftheconstraints,andMT-
ABC generates a more precise count than SMC for 75.9% of the
constraints. MT-ABC reported a higher count than SMC for one
constraint; we manually determined MT-ABC reports the exact
countinthiscaseandconcludedthatthecountreportedbySMCis
erroneous.Insummary,forsmallconstraintstheperformanceof
allthreesolversarecomparable,butforbigconstraints,MT-ABC
is more efficient than ABC and SMC and produces more precise
countsthanABCandSMCformorethan75%ofthebigconstraints.
6.2 IntegerConstraints
Comparison with LattE: We compare the performance of MT-
ABCwithLattEformodelcountinglineararithmeticconstraintson
benchmarkscontainingconstraintsgeneratedduringreliability[ 15]
and side-channel analyses of Java programs using the symbolic ex-
ecutiontoolSPF[ 6,8].Weextendedthereliabilitybenchmarkby
addingMergesort,Quicksort,andBinarysearchfunctions.Pass-
word, LawDB, and CRIME come from side-channelanalysis [ 6,8].
Password, LawDB andBinaryhave 7,8,and13constraints respec-
tively;the othersrange from 600-2000constraintseach.
Some of the constraints (e.g., the constraints coming from the
sorting functions) require a data structure with a certain size in
orderto enablesymbolic execution. We fixedthe size of such struc-
turesto6.Wecountedsolutionstothepathconstraintsgivenbit-
lengths 4, 8, 16, and 32. MT-ABC and LattE return identical counts
407ParameterizedModel Counting ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA
Table 1:Experiments with MT-ABC, ABC, S3#, andSMCon securitybenchmark.Unsound results are highlighted.
Program LenSMC ABC MT-ABC S3#
Lower/UpperBound Time Upper-Bound Time Upper-Bound Time Exact Count Time CountScale
ghttpd620 [10626.2;1031904473.2] 26.07 ś ś1031904473 21.69 1031904472.8 0.54×101465
11 [256;767] 0.49 7670.56 7670.029 7670.49
ghttpd wo_len620 [10626.2;1031904473.2] 25.99 1031904473 0.55 1031904473 0.14 1031904472.8 0.52×101465
11 [256;767] 0.49 7670.57 7670.069 7670.49
nullhttpd 500 [2.9;1369.8] 9.78 ś ś 00.032 00.47×101129
csplit 629[5.9∗101460;3.1∗101481]98.01 ś ś 00.024 00.54
grep 629[0.7∗101408;0.1∗101435]150.97 2.0∗1014735.1 03.94 00.56
wc 629 [0.979;8.0] 153.93 ś ś 0.979 9.05 0.979 3.35×101289
obscure1 10 [11.2;11.6] 0.45 11.20.013 11.20.023 11.2 0.46×1023
obscure2 6 [2.8;2.8] 0.47 2.80.075 2.80.077 2.80.46×1014
strstr1 5 [196608;196608] 0.451099511431168 0.0171099511431168 0.0021099511431168 0.45
strstr2 5 [16776960;16776960] 0.45 16776960 0.026 16776960 0.004 16776960 0.46
regex 4 [0;0]0.52 160.004 160.002 160.45
contains 5 [67108096;67108096] 0.45 67108096 0.007 67108096 0.002 67108096 0.46
Table2:ABC( uABC),MT-ABC( uMT−ABC)andSMC( uSMC)up-
perbounds comparison.
Benchmark #Constraints uMT−ABC<uSMCuMT−ABC=uSMCuMT−ABC>uSMC
SMCSmall 17544 166 (0.9%) 17388 (99.1%) 1(0.0%)
SMCBig 13421019 (75.9%) 323 (24.1%) 0(0.0%)
uMT−ABC<uABCuMT−ABC=uABCuMT−ABC>uABC
SMCSmall 17544 1025 (6%) 16529 (94%) 0(0.0%)
SMCBig 1342 1046 (78%) 296 (22%) 0(0.0%)
Table 3: MT-ABC and LattE average time (seconds) per
numeric constraint for different bit-lengths. The last two
columnsdenotethecombinationofalllengths(columnsfor
lengths4,16omittedforspace).Foreachbit-length,theexe-
cution timeofthefaster toolisinbold.
Bit-length = 8 Bit-length = 32 Bit-length = 4,8,16,32BenchmarkMT-ABC LattE MT-ABC LattE MT-ABC LattE
LawDB 0.0218 0.0118 0.0223 0.0144 0.0227 0.0408
Heap 0.0165 0.0214 0.0209 0.0217 0.0212 0.0868
Booking 0.0104 0.0133 0.0106 0.0133 0.0107 0.0534
Bubble 0.0184 0.0218 0.0264 0.0221 0.0268 0.0879
Binary 0.0246 0.0250 0.0409 0.0256 0.0410 0.1036
DaisyChain 0.0128 0.0359 0.0138 0.0361 0.0140 0.3571
Selection 0.0171 0.0217 0.0224 0.0219 0.0228 0.0878
Crime 0.0143 0.2628 0.0151 0.2604 0.0153 0.9873
Merge 0.0183 0.0215 0.0262 0.0216 0.0266 0.0868
Flap 0.0094 0.0308 0.0094 0.0308 0.0096 0.1234
Quick 0.0173 0.0219 0.0236 0.0224 0.0239 0.0891
Insertion 0.0190 0.0218 0.0270 0.0220 0.0273 0.0880
RobotGame 0.0113 0.1408 0.0113 0.1397 0.0114 0.5717
AlarmClock 0.0095 0.0121 0.0096 0.0121 0.0097 0.0487
Password 0.0102 0.0542 0.0102 0.0542 0.0102 0.2185
forallconstraintsasbothmodelcountersarepreciseincounting
lineararithmeticconstraints.Wefocusonthetimingcomparison
between MT-ABC and LattE. As a side note, the LattE input format
does not support disequalities and thus needs a preprocessing step
whensuchconstraintsarise.TheLattEintegrationwithSPFuses
Omega [20]; we refer the reader to [ 6,8,15] for integration details.
Figure3shows that in general MT-ABC performs better than
LattE, though there are exceptions (such as LawDB, Binary). Note
that MT-ABC always outperforms LattEwhen counting multiple
bit-lengths. Since MT-ABC is a parameterized model counter, it
first solves a constraint without constraints on bit length, and thenTable4:MT-ABCandSMTApproxMCaveragetime(seconds)
per numeric constraint for different bit-lengths. For each
bit-length, theexecution timeofthe faster toolis inbold.
Bit-length= 2 Bit-length= 3BenchmarkMT-ABC SMTApproxMC MT-ABC SMTApproxMC
Bubble 0.011 0.502 0.011 1.046
Booking 0.019 0.530 0.018 24.09
Selection 0.017 0.518 0.017 14.29
Password 0.011 47.28 0.011 1680.67
Merge 0.018 0.528 0.018 24.08
FlapController 0.793 1.487 0.791 158.81
Binary 0.009 0.656 0.009 4.525
Insertion 0.019 0.531 0.019 24.05
Heap 0.017 0.513 0.017 10.33
Quick 0.017 0.521 0.017 16.97
Alarm 0.009 0.472 0.010 0.99
reusesthegeneratedautomatontocountformultiplebit-lengths.
In contrast,LattE needstobecalledseparately foreachbit-length.
Comparison with SMTApproxMC: We compare the perfor-
manceofMT-ABCwithSMTApproxMCusingthesameprogram
analysisbenchmarksweusedincomparisonofMT-ABCwithLattE.
Since SMTApproxMCtargetsthe theoryof fixed-widthwords,we
translated each benchmark into the SMT2-BitVector format that
SMTApproxMC is able to handle. We ran both MT-ABC and SM-
TApproxMCusingbit-lengthsof2and3sinceSMTApproxMCdoes
notscaletolargerbit-lengths.Assomeofthebenchmarkscontains
constants which require more than 2 or 3 bits to be represented
in bitvector format, we omit them from our comparison. Table 4
showstheexecutiontimeofbothtools.Forbothbit-lengthsandall
benchmarks,MT-ABCissignificantlyfasterthanSMTApproxMC.
MT-ABC produces an exact count in every case, while SMTAp-
proxMCreportsanapproximatecountwhichvariesinprecision.
Theaveragedifferenceinmodelcountaspercentageofthedomain
size between the two tools is 3.7% and 4.2%, for bit-lengths of 2
and 3, respectively, with a maximum difference of 23.4% and 25.7%
for bit-lengths of 2 and 3 for the FlapController. For every con-
straint in these benchmarks, MT-ABC significantly outperforms
SMTApproxMC whileproducing as ormore precise counts.
6.3 Mixed String andIntegerConstraints
For our final tool comparison we use the unmodified SMT2 Kaluza
benchmark,usedin[ 36],whichrequiresconstraintsolverstoreason
408ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA A.Aydinet al.
aboutconstraintsovermixedstringandintegervariables.In[ 38]
thisbenchmarkwasusedbytheauthorstodemonstratethatS3#
canhandlemixedstringandintegerconstraints.However,forthese
constraints, no model counting was performed, only a satisfiability
check was done in [ 38]. When we used S3# to model count (by
givingastringlength)wefoundoutthatS3#reportederroneous
results for manyconstraints.
We focused on a subset of the SMT2 Kaluza benchmark. We
compared MT-ABC and S3# on 28059 of the smaller constraints
withinthebenchmark,givenaqueryvariableandastringlength
boundof50(solutionsforthequeryvariablemusthaveanexact
length of 50characters). MT-ABC and S3# agree on 24317 (87%) of
theconstraints.Ineachofthesecases,S3#wasabletogiveanexact
count,matchingtheupperboundgivenbyMT-ABC.Intheother
3742(13%)constraints,S3#reportedbothalowerandupperbound,
neither ofwhichmatchedthe upper bound reportedbyMT-ABC.
For the constraints where MT-ABC and S3# produce different
counts, the lowerbound reportedbyS3# wasbetween 1-3 models,
while the upper bound seemed entirely random, fluctuating either
beloworabovethecountreportedbyMT-ABC.IntheSMT2Kaluza
benchmark,therearemanysetsofconstraintswhichareessentially
equivalent to each other, some differing only in variable naming.
We manually confirmed the upper bound returned by MT-ABC for
manyoftheconstraintswastheexactcount,whiletheupperbound
reportedbyS3#betweenidenticalconstraintsvariedwildly,with
manyofthembeingunsound.Additionally,wefoundthatS3#gives
different results for identical files with different names. Consider a
constraint from the SMT2 Kaluza benchmark, length(s)=i, where
sisanstringvariable, ianintegervariable.Wecreatedthreefiles
eachcontainingthissingleconstraint,differingonlyinname.For
queryvariable sandquerylength5,thenumberofmodelsis2565=
1099511627776, or 240. While MT-ABC gives the exact count for all
three files, S3# reports three differentupper bounds, all unsound
(1.840133,1.856730,1.855426).Weobservedsimilarbehaviorfrom
S3#given differentconstraintsfrom the Kaluzadataset.
We reached out to the developer of S3# ([ 38]) for a possible
explanation.Oneissueisthattheyassumedthatconstraintsfrom
theKaluzadatasetcouldbetransformedintotheirsolvedform,but
theydidnot verifythis,northesoundness oftheirresultsfor this
datasetin[ 38].Thus,itispossiblethateithertheKaluzaconstraints
cannot all be transformed into solved form, or S3# has a faulty
implementation. Additionally, the authors of S3# were unable to
explainwhytheirtoolwasproducingnon-deterministicunsound
upper bounds when the input constraint cannot be transformed
intotheirsolvedform.Ourexperimentssuggestthatthetechniques
presentedin[ 38]andtheirimplementationinS3#arenotableto
handle mixed numeric and string constraints withboth string and
integer variables. Hence, to the best of our knowledge, MT-ABC
istheonlymodelcountingconstraintsolverthatcanhandlethis
class ofconstraints.
7 RELATED WORK
There has been significant amount of work on string constraint
solvinginrecentyears[ 1,16,18,19,22,25,33,36,37,43];however
none of these solvers provide model-counting functionality. Mean-
while, due to the importance of model counting for quantitativeprogramanalyses,modelcountingconstraintsolversaregaining
increasing attention. SMC and S3# are model-counting constraints
solversforstringconstraints[ 27,38].Ourmodelcountingapproach
ismorepreciseandmoreexpressivethanSMCsinceSMCcannot
propagate string values across logical connectives and cannot han-
dlecomplexstringoperationssuchas replace.S3#handlesstring
constraintsinvolvinglengthconstraints,butsuffersasevereloss
in precision when length constraints include symbolic integers.
Although the expressiveness of S3# is comparable to that of MT-
ABCforstringconstraints,unlikeMT-ABC S3#cannothandlepure
numeric constraints, and it produces unsound results for mixed
constraints.
LattE [7] is a model counting constraint solver for linear integer
arithmetic.LattEusesthepolynomial-timeBarvinokalgorithm[ 10]
forintegerlatticepointenumeration.LattEcannothandlestring
constraints, soour approach ismore expressive thanLattE.
Automata-based constraint solving and model counting tech-
niques we use in this paper are not domain-specific like the ap-
proaches used in LattE, SMC, and S3# but general in the sense
that, they can handle any setof constraints that can be mapped to
automata. As we present in this paper, it is possible to map both
numericandstringconstraintsandtheircombinationstoautomata.
Whilelinearalgebraicmethodsforcountingpathsinagraphare
well established, this paper is the first to implement those methods
for the purpose of parameterized model counting for relational
string and integer constraints. There has been earlier work on
integer constraint model counting by counting paths in numeric
DFA [28], but this earlier approach can only count models when
there are finitely many models. We built MT-ABC by extending an
existingtoolcalledAutomataBasedmodelCounter(ABC)[ 4].ABC
uses a single-track automata representation. ABC cannot model
countrelationalconstraintsandnumericconstraintsasprecisely
as MT-ABC, and it cannot handle constraints with integer vari-
ables. ABC has been integrated with Symbolic PathFinder (SPF)
andappliedto side-channel analysisin[ 8].
SMTApproxMC [ 14] is a model counting constraint solver for
thetheoryoffixed-widthwords,anditusesadifferentapproach
formodel-countingbasedonsolutionsampling[ 13].SinceSMTAp-
proxMC cannot handle string constraints, we compared SMTAp-
proxMCwithMT-ABConasetofnumericconstraints.MT-ABC
producesprecisecounts forlineararithmeticconstraintswhereas
SMTApproxMCcanonlyproduce approximations, andour experi-
mentsdemonstratethat MT-ABC issignificantly faster.
8 CONCLUSION
Model countingis a crucial problem in quantitative program analy-
sis.Using automata asa representation for allsolutions ofa given
constraintreducesthemodelcountingproblemtopathcounting.In
this paper, we show that, using automata-based constraint solving,
onecanconstructamodelcountingconstraintsolverthatisable
tohandlebothstringandnumericconstraintsandtheircombina-
tions.Ourexperimentsonalargesetofconstraintsgeneratedfrom
Java and JavaScript programs indicate that, automata-based model
counting approach is as efficient and as precise as domain specific
modelcountingmethods,whileitisabletohandlearichersetof
constraintsthanany othermodelcountingconstraintsolver.
409ParameterizedModel Counting ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA
REFERENCES
[1]ParoshAzizAbdulla,MohamedFaouziAtig,Yu-FangChen,LukásHolík,Ahmed
Rezine, Philipp Rümmer, and Jari Stenman. 2014. String Constraints for Veri-
fication.In Proceedingsofthe26thInternationalConferenceonComputerAided
Verification (CAV) . 150ś166.
[2]Muath Alkhalaf,Abdulbaki Aydin, and Tevfik Bultan. [n. d.]. Semantic Differ-
ential Repair for Input Validation and Sanitization. In Proceedings of the 2014
InternationalSymposiumonSoftwareTestingandAnalysis(ISSTA2014) .NewYork,
NY, USA,225ś236. https://doi.org/10.1145/2610384.2610401
[3]Abdulbaki Aydin. 2017. Automata-based Model Counting String Constraint Solver
forVulnerabilityAnalysis . dissertation.UniversityofCaliforniaSantaBarbara.
https://www.alexandria.ucsb.edu/lib/ark:/48907/f3xp754k
[4]Abdulbaki Aydin, Lucas Bang, and Tevfik Bultan. 2015. Automata-Based Model
CountingforStringConstraints.In ComputerAidedVerification-27thInterna-
tional Conference, CAV 2015, San Francisco, CA, USA, Proceedings, Part I . 255ś272.
https://doi.org/10.1007/978-3-319-21690-4_15
[5]MichaelBackes,BorisKöpf,andAndreyRybalchenko.2009.AutomaticDiscovery
and Quantification of Information Leaks. In 30th IEEE Symposium on Security
and Privacy (S&P2009), 17-20May 2009, Oakland,California, USA . 141ś153.
[6]DanielBalasubramanian,KasperLuckow,CorinaPasareanu,AbdulbakiAydin,
Lucas Bang, Tevfik Bultan, Miroslav Gavrilov, Temesghen Kahsai, Rody Kersten,
Dmitriy Kostyuchenko, Quoc-Sang Phan, Zhenkai Zhang, and Gabor Karsai.
2017. ISSTAC: Integrated Symbolic Execution for Space-Time Analysis of Code.
Insubmission .
[7]V. Baldoni, N. Berline, J.A. De Loera, B. Dutra, M. Köppe, S. Morei-
nis, G. Pinto, M. Vergne, and J. Wu. [n. d.]. LattE integrale v1.7.2.
http://www.math.ucdavis.edu/latte/. ([n. d.]).
[8]Lucas Bang, Abdulbaki Aydin, Quoc-Sang Phan, Corina S. Păsăreanu, and Tevfik
Bultan. 2016. String Analysis for Side Channels with Segmented Oracles. In
Proceedings of the 24th ACM SIGSOFT International Symposium on Foundations of
SoftwareEngineering (FSE 2016) . ACM,NewYork, NY, USA.
[9]ConstantinosBartzisandTevfikBultan.2003. EfficientSymbolicRepresentations
for Arithmetic Constraints in Verification. Int. J. Found. Comput. Sci. 14, 4 (2003),
605ś624.
[10]AlexanderI.Barvinok.1994. APolynomialTimeAlgorithmforCountingIntegral
Points in Polyhedra When the Dimension is Fixed. Math. Oper. Res. 19, 4 (1994),
769ś779. https://doi.org/10.1287/moor.19.4.769
[11]MateusBorges,AntonioFilieri,Marcelod’Amorim,andCorinaS.Pasareanu.2015.
Iterative distribution-aware sampling for probabilistic symbolic execution. In
Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering,
ESEC/FSE 2015, Bergamo, Italy, August 30 -September 4, 2015 . 866ś877.
[12]Mateus Borges, Quoc-Sang Phan, Antonio Filieri, and Corina S. Pasareanu. 2017.
Model-CountingApproachesforNonlinearNumericalConstraints.In Proceedings
ofthe 9thInternationalNASAFormal MethodsSymposium . 131ś138.
[13]Supratik Chakraborty, Daniel J. Fremont, Kuldeep S. Meel, Sanjit A. Seshia, and
Moshe Y. Vardi. 2014. Distribution-Aware Sampling and Weighted Model Count-
ingforSAT.In ProceedingsoftheTwenty-EighthAAAIConferenceonArtificial
Intelligence . 1722ś1730.
[14]SupratikChakraborty,KuldeepS.Meel,RakeshMistry,andMosheY.Vardi.2016.
Approximate Probabilistic Inference via Word-Level Counting. In Proceedings of
the Thirtieth AAAI Conference onArtificial Intelligence . 3218ś3224.
[15]AntonioFilieri,CorinaS.Pasareanu,andWillemVisser.2013. Reliabilityanalysis
in symbolicpathfinder. In 35th International Conference on Software Engineering,
ICSE’13, San Francisco, CA,USA, May 18-26, 2013 . 622ś631.
[16]Vijay Ganesh, Mia Minnes, Armando Solar-Lezama, and Martin C. Rinard. 2012.
WordEquations withLengthConstraints:What’s Decidable?. In Proceedings of
the 8thInternationalHaifa Verification Conference (HVC) . 209ś226.
[17]Jaco Geldenhuys, Matthew B. Dwyer, and Willem Visser. 2012. Probabilistic
symbolicexecution.In InternationalSymposiumonSoftwareTestingandAnalysis,
ISSTA2012, Minneapolis, MN, USA, July 15-20, 2012 . 166ś176.
[18]PieterHooimeijerandWestleyWeimer.2009. Adecisionprocedureforsubset
constraintsoverregularlanguages.In ProceedingsoftheACMSIGPLANConference
onProgrammingLanguage Designand Implementation(PLDI) . 188ś198.
[19]PieterHooimeijerandWestleyWeimer.2010.SolvingStringConstraintsLazily.In
Proceedingsofthe25thIEEE/ACMInternationalConferenceonAutomatedSoftware
Engineering (ASE) . 377ś386.
[20]WayneKelly,VadimMaslov,WilliamPugh,EvanRosser,TatianaShpeisman,and
Dave Wonnacott. 1996. The Omega calculator and library, version 1.1. 0. College
Park,MD 20742(1996), 18.
[21]JohnKelsey.2002.CompressionandInformationLeakageofPlaintext.In FastSoft-
ware Encryption, 9th International Workshop, FSE 2002, Leuven, Belgium, February
4-6,2002, RevisedPapers . 263ś276. https://doi.org/10.1007/3-540-45661-9_21[22]Adam Kiezun, Vijay Ganesh, Philip J. Guo, Pieter Hooimeijer, and Michael D.
Ernst. 2009. HAMPI: a solver for string constraints. In Proceedings of the 18th
InternationalSymposiumonSoftwareTestingand Analysis(ISSTA) . 105ś116.
[23]LouisLatour.2004. FromAutomatatoFormulas:ConvexIntegerPolyhedra.In
19thIEEESymposiumonLogicinComputerScience(LICS2004),14-17July2004,
Turku, Finland, Proceedings . 120ś129. https://doi.org/10.1109/LICS.2004.1319606
[24]Jérôme Leroux. 2005. A Polynomial Time Presburger Criterion and Synthesis for
Number DecisionDiagrams. In LICS. 147ś156.
[25]GuodongLiandIndradeepGhosh.2013. PASS:StringSolvingwithParameterized
Array and Interval Automaton. In Proceedings of the 9th International Haifa
Verification Conference (HVC) . 15ś31.
[26]JesúsA.DeLoera,RaymondHemmecke,JeremiahTauzer,andRurikoYoshida.
2004. Effective lattice point counting in rational convex polytopes. Journal of
SymbolicComputation 38,4(2004),1273ś1302. https://doi.org/10.1016/j.jsc.2003.
04.003
[27]Loi Luu, Shweta Shinde, Prateek Saxena, and Brian Demsky. 2014. A model
counterforconstraintsoverunboundedstrings.In ProceedingsoftheACMSIG-
PLANConference onProgramming LanguageDesign andImplementation(PLDI) .
57.
[28]Erin Parker and Siddhartha Chatterjee. 2004. An Automata-Theoretic Algorithm
forCountingSolutionstoPresburgerFormulas.In CompilerConstruction,13th
InternationalConference,CC2004,Barcelona,Spain .104ś119. https://doi.org/10.
1007/978-3-540-24723-4_8
[29]Quoc-Sang Phan, Pasquale Malacaria, Corina S. Pasareanu, and Marcelo
d’Amorim. 2014. Quantifying information leaks using reliability analysis. In
ProceedingsoftheInternational Symposiumon ModelChecking ofSoftware, SPIN
2014, San Jose,CA,USA . 105ś108.
[30]Quoc-SangPhan,PasqualeMalacaria,OksanaTkachuk,andCorinaS.Pasareanu.
2012.Symbolicquantitativeinformationflow. ACMSIGSOFTSoftwareEngineering
Notes37,6 (2012), 1ś5.
[31]Bala Ravikumar and Gerry Eisman. 2004. Weak minimization of DFA - an
algorithmandapplications. Theor.Comput.Sci. 328,1-2(2004),113ś133. https:
//doi.org/10.1016/j.tcs.2004.07.009
[32]Juliano Rizzo and Thai Duong. 2012. The CRIME attack (Ekoparty Security
Conference) .
[33]Prateek Saxena, Devdatta Akhawe, Steve Hanna, Feng Mao, Stephen McCamant,
and Dawn Song. 2010. A Symbolic Execution Framework for JavaScript. In
Proceedingsofthe 31st IEEE SymposiumonSecurityand Privacy .
[34]Geoffrey Smith. 2009. On the Foundations of Quantitative Information Flow. In
Foundations of Software Science and Computational Structures, 12th International
Conference,FOSSACS 2009, York,UK,March 22-29, 2009. Proceedings . 288ś302.
[35]RichardP.Stanley.2011. EnumerativeCombinatorics:Volume1 (2nded.). Cam-
bridgeUniversityPress,NewYork, NY, USA.
[36]CesareTinelliClarkBarrettMorganDetersTianyiLiang,AndrewReynolds.2014.
ADPLL(T)TheorySolverforaTheoryofStringsandRegularExpressions.In
Computer Aided Verification - 26th International Conference, CAV 2014, Vienna,
Austria, Proceedings . 646ś662.
[37]Minh-ThaiTrinh,Duc-HiepChu,andJoxanJaffar.2014. S3:ASymbolicString
SolverforVulnerabilityDetectioninWebApplications.In ProceedingsoftheACM
SIGSACConferenceonComputerandCommunicationsSecurity(CCS) .1232ś1243.
[38]Minh-Thai Trinh, Duc-Hiep Chu, and Joxan Jaffar. 2017. Model Counting for
Recursively-DefinedStrings.In ComputerAidedVerification -29thInternational
Conference,CAV2017, Heidelberg,Germany, Proceedings,Part II . 399ś418.
[39]Fang Yu, Muath Alkhalaf, and Tevfik Bultan. 2009. Generating Vulnerability
SignaturesforStringManipulatingProgramsUsingAutomata-BasedForwardand
Backward Symbolic Analyses. In Proceedings of the 2009 IEEE/ACM International
ConferenceonAutomatedSoftwareEngineering(ASE’09) .IEEEComputerSociety,
Washington, DC, USA,605ś609. https://doi.org/10.1109/ASE.2009.20
[40]FangYu,MuathAlkhalaf,TevfikBultan,andOscarH.Ibarra.2014. Automata-
based symbolic string analysis for vulnerability detection. Formal Methods in
SystemDesign 44,1 (2014), 44ś70. https://doi.org/10.1007/s10703-013-0189-1
[41] FangYu,TevfikBultan,andOscarH.Ibarra.2009. SymbolicStringVerification:
Combining String Analysis and Size Analysis. In Proceedings of the 15th Inter-
national Conference on Tools and Algorithms for the Construction and Analysis of
Systems: Held As Part of the Joint European Conferences on Theory and Practice of
Software, ETAPS 2009, (TACAS ’09) . Springer-Verlag, Berlin, Heidelberg, 322ś336.
https://doi.org/10.1007/978-3-642-00768-2_28
[42]Fang Yu, Tevfik Bultan, and Oscar H. Ibarra. 2011. Relational String Verification
Using Multi-Track Automata. Int. J. Found. Comput. Sci. 22, 8 (2011), 1909ś1924.
[43]Yunhui Zheng, Xiangyu Zhang, and Vijay Ganesh. 2013. Z3-str: A Z3-based
StringSolverforWebApplicationAnalysis.In Proceedingsofthe9thJointMeeting
onFoundationsofSoftwareEngineering (ESEC/FSE) . 114ś124.
410