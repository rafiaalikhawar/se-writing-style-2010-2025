Singapor e Management Univ ersity Singapor e Management Univ ersity 
Institutional K nowledge at Singapor e Management Univ ersity Institutional K nowledge at Singapor e Management Univ ersity 
Resear ch Collection School Of Computing and 
Information Systems School of Computing and Information Systems 
11-2015 
Interpolation guided compositional v erification Interpolation guided compositional v erification 
Shang-W ei LIN 
Jun SUN 
Singapor e Management Univ ersity , junsun@smu.edu.sg 
Truong Khanh NGUYEN 
Yang LIU 
Jin Song DONG 
Follow this and additional works at: https:/ /ink.libr ary.smu.edu.sg/sis_r esear ch 
 Part of the Softwar e Engineering Commons 
Citation Citation 
LIN, Shang-W ei; SUN, Jun; NGUYEN, T ruong Khanh; LIU, Y ang; and DONG, Jin Song. Interpolation guided 
compositional v erification. (2015). Proceedings of the 30th IEEE/A CM International Conf erence on 
Automated Softwar e Engineering, Lincoln Nebr aska, 2015 No vember 9-13 . 65-74. 
Available at:Available at:  https:/ /ink.libr ary.smu.edu.sg/sis_r esear ch/4974 
This Conf erence Pr oceeding Ar ticle is br ought t o you for fr ee and open access b y the School of Computing and 
Information Systems at Institutional K nowledge at Singapor e Management Univ ersity . It has been accepted for 
inclusion in Resear ch Collection School Of Computing and Information Systems b y an authoriz ed administr ator of 
Institutional K nowledge at Singapor e Management Univ ersity . For mor e information, please email 
cher ylds@smu.edu.sg . Interpolation Guided Compositional Veriﬁcation
Shang-Wei Lin∗, Jun Sun†, Truong Khanh Nguyen†, Yang Liu∗, and Jin Song Dong‡
∗School of Computer Engineering, Nanyang Technological University
†Singapore University of Technology and Design
‡School of Computing, National University of Singapore
Abstract —Model checking suffers from the state space ex-
plosion problem. Compositional veriﬁcation techniques such as
assume-guarantee reasoning (AGR) have been proposed to alle-viate the problem. However, there are at least three challengesin applying AGR. Firstly, given a system M
1/bardblM2,h o w
do we automatically construct and reﬁne (in the presence ofspurious counterexamples) an assumption A
2, which must be an
abstraction of M2? Previous approaches suggest to incrementally
learn and modify the assumption through multiple invocationsof a model checker, which could be often time consuming.Secondly, how do we keep the state space small when checkingM
1/bardblA 2|=ϕif multiple reﬁnements of A2are necessary?
Lastly, in the presence of multiple parallel components, how do wepartition the components? In this work, we propose interpolation-guided compositional veriﬁcation. The idea is to tackle threechallenges by using interpolations to generate and reﬁne theabstraction of M
2, to abstract M1at the same time (so that the
state space is reduced even if A2is reﬁned all the way to M2),
and to ﬁnd good partitions. Experimental results show that theproposed approach outperforms existing approaches consistently.
Keywords—model checking; automatic compositional veriﬁca-
tion; satisﬁability; interpolation;
I. I NTRODUCTION
Model checking [14], [35] is a successful formal veriﬁ-
cation technique, which can automatically check whether a
system model Msatisﬁes a property ϕ, denoted by M|=ϕ.
However, it suffers from the infamous state space explosion
problem [14], [35]. To alleviate the problem, assume-guarantee
reasoning (AGR) [20], [15], [34], a well-known compositional
technique, has been proposed and applied on model checking.The most common rule used in AGR is the following assume-guarantee non-circular (AG-NC) rule:
M
1/bardblA2|=ϕandM2/precedesequalA2
M1/bardblM2|=ϕ(1)
Given a system with two components modeled by M1and
M2and a property ϕ, the AG-NC proof rule says that if M1
can satisfy a property ϕunder an assumption A2andA2
is an abstraction of M2(i.e.,M2can be simulated by A2,
denoted by M2/precedesequalA2as formulated in Section III-A), then
we can conclude that M1/bardblM2satisﬁesϕ. However, the
The corresponding author, Shang-Wei Lin, can be contacted via the follow-
ing e-mail address: shang-wei.lin@ntu.edu.sg.
This research is supported (in part) by the National Research Foundation,
Prime Ministers Ofﬁce, Singapore under its National Cybersecurity R&D
Program (Award No. NRF2014NCR-NCR001-30) and administered by theNational Cybersecurity R&D Directorate.challenge of applying AGR is at least threefold. The ﬁrst is
how to automatically construct and reﬁne (in the presence ofspurious counterexamples) the assumption A
2. In general, the
assumption should be kept as small as possible, i.e., containingonly sufﬁcient details to prove or disprove M
1/bardblA2|=ϕ.
Besides relying on human creativity to create A2manually,
there is a line of works on applying learning techniques(e.g., [19], [4], [12], [26], [32]) to learn the assumption. Theidea is to construct a candidate assumption through learningand then verify that the candidate is indeed an abstraction ofM
2. Otherwise, the assumption must be modiﬁed (sometimes
multiple times) until it becomes an abstraction of M2.S u c h
a process requires multiple invocations of a model checkerand therefore could be time consuming. Secondly, the worstcase scenario for AGR is that every detail of M
2is needed
in order to prove or disprove M1/bardblM2|=ϕand thus
A2is reﬁned all the way to M2. As a result, all the effort
on ﬁnding the assumptions and checking M1/bardblA2|=ϕ,
often multiple times, is wasted. The question is then: is itpossible to make use of the intermediate checking results soas to keep the state space reduced even in the worst casescenario? The last challenge is: in the presence of multipleparallel components, how do we partition components to applyAGR? It has been reported in [17] that without a good partitionstrategy, model checking based on AGR might be even worsethan the traditional monolithic model checking.
In this work, we propose an approach to complement
existing AGR-based compositional veriﬁcation techniques bytackling the three challenges above. Central to our approachis the idea of learning from bounded model checking (BMC)results. In the following, we brieﬂy present our approach, andFig. 1 shows its workﬂow. A model in our work is a paral-lel composition of multiple components, which communicatethrough shared variables
1. At the beginning, the components
are partitioned into two groups, either randomly or based onsimple heuristics. Let us assume that the model is G
1/bardblG2
whereGiwherei∈{1,2}itself is a parallel composition of
multiple components. In our method, we change the partitionbased on intermediate veriﬁcation results. In addition, wewould construct not only an abstraction A
2forG2but also an
abstraction A1forG1. Initially, we set the transition relation
ofA2to be TRUE, which is the weakest over-approximation,
andA1to beG1. We then model check A1/bardblA2.I fA1/bardblA2
satisﬁes the property ϕ, we prove the system satisﬁes ϕ.
Otherwise, we check whether the counterexample is spuriousor not. This is done by bounded model checking G
1/bardblG2up
to the length of the counterexample. If the counterexample isnot spurious, we ﬁnd a counterexample. Otherwise, we obtain
1Our work can be extended to support messaging or barrier synchronization.
2015 30th IEEE/ACM International Conference on Automated Software Engineering
978-1-5090-0025-8/15 $31.00 © 2015 IEEE
DOI 10.1109/ASE.2015.3365
A1/bardblA 2|=ϕ?(G1,G2)
G1/bardblG2|=ϕ
k-step BMC formula G1/bardblG2/negationslash|=ϕInterpolationsUn-SAT
Core
a counterexample in kstepsinitial partition
A1=G1A2=TRUE
yes
satisﬁable unsatisﬁablereﬁneA2abstractA1repartition
Fig. 1. Overall Flow
the unsatisﬁability (unsat) core from the BMC formula. We
re-partition the components such that those relevant to theunsat core are grouped into G
1(since intuitively details of
those components matter, at least in avoiding the spuriouscounterexample). If the partition (G
1,G2)cannot be improved
by unsat cores anymore, we reﬁne A2(the abstraction of
the new G2) based on the interpolants [22], [23] from the
unsatisﬁable BMC formula. Lastly, we use the interpolants toconstruct the abstraction A
1ofG1(so as to avoid details
of the processes which are irreverent at least to the proofof unsatisﬁable BMC formula). The above process continuesuntil a veriﬁcation result can be concluded, i.e., the propertyis proved or a real counterexample is found.
Our interpolation-guided approach tackles the above-
mentioned three problems as follows. Firstly, the assumptionsare generated and reﬁned automatically based on interpola-tions. Different from existing approaches on learning assump-tions [19], [4], [12], [26], [32], the assumptions in our approachare abstractions of G
2by construction. Secondly, unlike in
existing AGR-based approaches where the component G1is
never changed, we actively abstract the transition relation ofG
1based on interpolations. As a result, we would not explore
G1/bardblG2even ifA2has to be reﬁned all the way to G2. Lastly,
we use unsat cores to guide the partition of components. Wehave implemented the approach in the PAT model checker [38],and experiments show the beneﬁts of our approach.
The rest of this paper is organized as follows. Section II
illustrates our approach with a simple example. Section IIIreviews some preliminary backgrounds and recalls the transi-tion over-approximation based on interpolants. In Section IV,we show how we construct and reﬁne A
1andA2by using
interpolations. Experiment results are presented in Section V toshow the effectiveness of our approach. Section VI summarizesrelated works. Section VII concludes this work.
II. A S
IMPLE EXAMPLE
We illustrate how our approach works using a simple
example. We ﬁrst show abstracting M1whilst reﬁning M2
could be beneﬁcial to a system with two components. Next,we generalize the system to ncomponents and then show how
a good partition is found. A two-bit counter is modeled by twocomponents, cell
1andcell2in Fig. 2. Each component
cellifori∈{1,2}has three Boolean variables as follows.
Theinivariable indicates whether the carry-in value of celli
is asserted. The bitivariable stores the current bit value ofcelli. It is initialized as FALSE, and its next value depends
on the exclusive-or of its current value and its carry-in value.Theout
iindicates whether the current bit value of celli
should be carried out. If the bit value of cell1is carried out,
then the carry-in value of cell2should be asserted. The initial
condition Iiand transition relation Tiof the two components
are encoded as follows, respectively.
•I1:¬bit1∧in1
•I2:¬bit2
•T1:(bit/prime
1⇔bit1⊕in1)∧(out/prime
1⇔bit1∧in1)
•T2:(in/prime
2⇔out1)∧(bit/prime2⇔bit2⊕in2)∧
(out/prime
2⇔bit2∧in2)
Suppose we want to verify the property ϕrequiring
thatout2,bit2, and in2do not hold simultaneously, i.e.,
G¬(out2∧bit2∧in2). Let cell1beM1andcell2be
M2, respectively. We use ˆTl
ito denote the over-approximation
ofTiafterl-th iteration. Initially in our approach, ˆT0
2is set to
the weakest transition relation /latticetop, andˆT0
1is kept as T1. Let
Al
ibe the component encoded by the initial condition Iiand
the abstract transition relation ˆTl
i.
In the ﬁrst iteration, a counterexample is found in one
step when model checking A0
1/bardblA02|=ϕ. To check whether
there is any one-step counterexample in the concrete system,
a bounded model checking (BMC) of length one based onT
1andT2is performed. However, the BMC formula is not
satisﬁable meaning that the counterexample is spurious, and
ˆT0
2should be strengthened. From the proof of unsatisﬁability,
we obtain the symmetric interpolant Ω1=/latticetopforT1and
Ω2=bit2∨¬out/prime
2forT2, respectively (c.f. Section III-B
for details). We use the obtained interpolant to weaken ˆT0
1and
strengthen ˆT0
2as follows: ˆT1
1=Ω1=/latticetopandˆT1
2=ˆT0
2∧Ω2=
(bit2∨¬out/prime2). By the characteristics of interpolants, ˆT1
1
andˆT1
2are over-approximations of T1andT2, respectively.
In addition, I1∧ˆT1
1∧I2∧ˆT1
2does not admit any one-step
counterexamples.
In the second iteration, A11/bardblA12|=ϕare veriﬁed again,
and a counterexample in three steps is found. To check the
feasibility of any three-step counterexamples, a BMC of lengththree based on the concrete transition relations, T
1andT2,i s
performed. However, the BMC formula is not satisﬁable, and
ˆT1
2still needs to be strengthened. We obtain the interpolants
Ω/prime
1andΩ/prime2from the unsatisﬁability proof to reﬁne ˆT1
1andˆT1
2,
66
MODULE cell1
var bit1: bool;
var in1: bool;var out1: bool;
init(bit1) := FALSE;
init(in1) := TRUE;
next(bit1) := bit1 xor in1;
next(out1) := bit1 & in1;
END MODULEMODULE cell2
var bit2: bool;var in2: bool;var out2: bool;
init(bit2) := FALSE;next(in2) := out1;
next(bit2) := bit2 xor in2;next(out2) := bit2 & in2;
END MODULE
Fig. 2. The Counter Example
respectively, as follows: ˆT2
1=Ω/prime
1=bit1∨¬out/prime1andˆT2
2=
ˆT1
2∧Ω/prime2=(¬out/prime2∧out1)∨(¬out/prime2∧¬in/prime
2)∨(in2∧bit2).
In the third iteration, a spurious counterexample in seven
steps is found, and ˆT2
1andˆT2
2are strengthen by interpolants as
follows: ˆT3
1=bit1∨¬out/prime
1andˆT3
2=ˆT2
2∧(bit/prime
2∨out/prime
2).
In the fourth iteration, A31/bardblA32|=ϕis veriﬁed by model
checking again, but no counterexamples are found this time
meaning that cell 1/bardblcell2|=ϕ. We remark here that
abstracting T1is optional, but doing so reduces the state
explosion problem when checking M1/bardblA2|=ϕ.
Let us do the veriﬁcation again, but this time let cell2
beM1instead of cell1. The veriﬁcation can be done
in one iteration, where A1=cell2andA2with the
weakest transition relation TRUE. This is because cell2is
sufﬁcient to prove the property. From this example, we canobserve the importance of partitioning components for AGR.In our approach, we utilize the unsatisﬁability core to predictthe components which are necessary to prove the property.Within each iteration, if the BMC formula for checking thespuriousness of counterexamples is unsatisﬁable, we obtainits unsatisﬁability core. Any component whose variables areappearing in the unsatisﬁability core might be necessary forproving the property and is included into the M
1group. Once
theM1group is changed, the veriﬁcation is restart for the new
partition in the next iteration.
For the same counter example, if we have ncells (n-
bit counter) and suppose we want to verify the property ϕj:
G¬(outj∧bitj∧inj)forj∈{1,2,...,n}, our approach
is able to detect that celljis the only necessary component
to proveϕj, i.e., celljis in theM1group and the rest are in
theM2group, which is the best partition (only one iteration
is required for verifying ϕj).
III. B ACKGROUND
In Section III-A, we review some deﬁnitions, borrowed
from [12], [23], of symbolic model checking and boundedmodel checking. Then, we brieﬂy recall the transition approx-imation based on interpolations [22], [23], in Section III-B.
A. Preliminaries
Deﬁne B={/latticetop,⊥}to be the Boolean domain where /latticetopand
⊥denote the truth values TRUE andFALSE, respectively. Let
xbe a set of Boolean variables and |x|the size of x. A Boolean
formulaφ(x)overxis a function from B
|x|toB. A valuation
ν:x→Boverxis a function from Boolean variables to
truth values. We use φ[ν]to denote the result of evaluatingφby replacing each x∈xwithν(x). To represent transition
systems symbolically, we also deﬁne a set of Boolean variables
x/prime={x/prime|x∈x}, which corresponds to xsuch that x∈x
represents the current value of x, while x/prime∈x/primerepresents
the value of xin the next state. Moreover, let φ(x,x/prime)be a
Boolean formula over xandx/prime.I fν andν/primeare valuations over
xandx/prime, respectively, we use φ[ν,ν/prime]to denote the result of
evaluating φby replacing each x∈xwithν(x)and replacing
eachx/prime∈x/primewithν/prime(x/prime). LetCbe a set of formulas. We use/logicalandtextCto denote the conjunction of all formulas.
A transition system M=(x,I(x),T(x,x/prime))consists of its
state variables x, its initial predicate I(x), and its transition
relationT(x,x/prime). We sometimes write (x,I,T)to denote a
transition system if there is no risk of confusion. A trace of M
is a ﬁnite sequence of valuations σ=ν0ν1···νk, whereνiis
a valuation over x, such that I(ν0)=/latticetopandT(νi,νi+1)=/latticetop
for alli∈{0,1,···,k}. The language of M, denoted by
L(M), contains all the traces of M. A state predicate ϕ(x)
is a Boolean function over x. We say Msatisﬁesϕ, denoted
byM|=ϕ, if for each σ=ν0ν1···νk∈L(M),w eh a v e
ϕ[νi]=/latticetop for alli∈{0,1,...,k}. A counterexample of
M|=ϕis a trace ν0ν1···νtofMsuch that ϕ[νi]=/latticetop for
alli∈{0,1,...,t−1}butϕ[νt]=⊥.
LetM=( x,I(x),T(x,x/prime)) andA=
(x,IA(x),TA(x,x/prime))be two transitions systems over
x.W es a yM is simulated by AorAsimulates M,
denoted by M/precedesequalA ,i f∀x/squaresmallsolidI(x)=⇒IA(x)and
∀xx/prime/squaresmallsolidT(x,x/prime)=⇒TA(x,x/prime). That is, the initial condition
ofMis stronger than that of Aand every transition in M
is also allowed in A. Obviously, if M/precedesequalA holds, then
L(M)⊆L(A)holds. Let Mi=(xi,Ii(xi),Ti(xi,x/prime
i))
be two transition systems for i∈{1,2}. The parallel
composition ofM1andM2is the transition system M1/bardbl
M2=(x1∪x2,I1(x1)∧I2(x2),T1(x1,x/prime
1)∧T2(x2,x/prime2)).
Given a transition system M=(x,I(x),T(x,x/prime))and
a state predicate ϕ(x), whether ϕisk-reachable in Mcan
be expressed symbolically as a Boolean formula. For each
variablex∈xand a natural number i, we use x/angbracketlefti/angbracketrightto denote
the variable xwithiprimes added, which represents the value
ofxat timei. For example, x/angbracketleft3/angbracketright=x/prime/prime/primerepresents the value
ofxat time3. We also extend this notation to the set of
variables and formulas. Thus, x/angbracketlefti/angbracketrightcontains variables with i
primes added, φ(x)/angbracketlefti/angbracketrightis the formula over x/angbracketlefti/angbracketright, andφ(x,x/prime)/angbracketlefti/angbracketright
is the formula over x/angbracketlefti/angbracketrightandx/angbracketlefti+1/angbracketright. A state predicate ϕ(x)
isk-reachable in (x,I(x),T(x,x/prime))if the following bounded
model checking (BMC) formula is satisﬁable.
I(x)/angbracketleft0/angbracketright∧T(x,x/prime)/angbracketleft0/angbracketright∧T(x,x/prime)/angbracketleft1/angbracketright∧···∧T(x,x/prime)/angbracketleftk−1/angbracketright∧ϕ(x)/angbracketleftk/angbracketright
67
Algorithm 1: Veriﬁcation by Transition Approximation
input :(x,I,T): the concrete transition system;
ϕ: the property to be checked
output: yes/no, with a counterexample
1ˆT←− /latticetop ;
2while True do
3 if(x,I,ˆT)|=ϕthen
4 return yes
5 else
6 Suppose¬ϕisk-reachable in (x,I,ˆT);
7 Θ←− {I/angbracketleft0/angbracketright,T/angbracketleft0/angbracketright,...,T/angbracketleftk−1/angbracketright,¬ϕ/angbracketleftk/angbracketright};
8 if/logicalandtextΘis satisﬁed by a valuation νthen
9 return(no,ν);
10 else
11 LetˆΘ={ˆI/angbracketleft0/angbracketright,ˆT/angbracketleft0/angbracketright,...,ˆT/angbracketleftk−1/angbracketright,ˆ¬ϕ/angbracketleftk/angbracketright}be
the symmetric interpolant for Θ;
12 ˆT←−ˆT∧/logicalandtextk−1
i=0(ˆT/angbracketlefti/angbracketright)/angbracketleft−i/angbracketright;
B. Interpolation-based Approximation of Transition Relations
In [22], [23], transition relations are approximated by
interpolations [18], as formulated in Deﬁnition 1, obtained
from unsatisﬁability proofs of bounded model checking.
Deﬁnition 1: Given a pair of Boolean formulas (A,B)
such that A∧Bis unsatisﬁable, an interpolant for(A,B)
is a formula ˆAsatisfying the following properties:
1)AimpliesˆA, i.e.,A=⇒ˆA
2)ˆA∧Bis unsatisﬁable
3)ˆArefers only to the common variables of AandB.
IfA∧Bis unsatisﬁable with an unsatisﬁability proof, an
interpolant for (A,B)can be obtained from the proof [31].
In a formula of a k-step bounded model checking problem,
if the formula is unsatisﬁable, the over-approximation of
the transition relation can be obtained from the symmetric
interpolants [22], [23], as formulated in Deﬁnition 2, among
the transition relations from steps 0tok−1.
Deﬁnition 2: Given an indexed set of Boolean formulas
A={a1,a2,...,a n}such that/logicalandtextAis inconsistent, a sym-
metric interpolant forAis an indexed set of Boolean formulas
ˆA={ˆa1,ˆa2,...,ˆan}satisfying the following conditions:
1)ai=⇒ˆaifor alli∈{1,2,...,n}
2)/logicalandtextˆAis inconsistent
3)ˆairefers to the variables common to aiandA\{ai}.
Algorithm 1 shows a veriﬁcation approach by over-
approximating the transition relation based on symmetric in-terpolants [22], [23]. The details are as follows:
• Initially, the approximation ˆTis initialized as /latticetop
(line1).
• If(x,I,ˆT)|=ϕholds, we can conclude (x,I,T)|=ϕ
also holds because T=⇒ˆT(lines3–4).• If¬ϕisk-reachable in (x,I,ˆT), there could be
two cases where either ¬ϕis also k-reachable
in(x,I,T),o rˆTis too weak an approxima-
tion. Bounded model checking can help to ﬁnd outwhich case it is. We construct a set of formu-lasΘ={I
/angbracketleft0/angbracketright,T/angbracketleft0/angbracketright,T/angbracketleft1/angbracketright,...,T/angbracketleftk−1/angbracketright,¬ϕ/angbracketleftk/angbracketright}where/logicalandtextΘis exactly the BMC formula. We use a de-
cision procedure to determine the satisﬁability. If/logicalandtextΘis satisﬁable, then (x,I,T)|=ϕdoes not
hold (lines 8–9). If/logicalandtextΘis not satisﬁable, then ˆT
is too weak and needs to be reﬁned. Let ˆΘ=
{ˆI/angbracketleft0/angbracketright,ˆT/angbracketleft0/angbracketright,ˆT/angbracketleft1/angbracketright,...,ˆT/angbracketleftk−1/angbracketright,ˆ¬ϕ/angbracketleftk/angbracketright}be the symmet-
ric interpolant for Θ. Let us deﬁne ˆT/llbracketi/rrbracket=(ˆT/angbracketlefti/angbracketright)/angbracketleft−i/angbracketright
where(ˆT/angbracketlefti/angbracketright)/angbracketleft−i/angbracketrightdenotes the formula obtained by
removing iprimes from ˆT/angbracketlefti/angbracketrightif possible. Because of
the properties of symmetric interpolants, the formula
I/angbracketleft0/angbracketright∧ˆT/angbracketleft0/angbracketright
/llbracket0/rrbracket∧ˆT/angbracketleft1/angbracketright
/llbracket1/rrbracket∧···∧ˆT/angbracketleftk−1/angbracketright
/llbracketk−1/rrbracket∧¬ϕ/angbracketleftk/angbracketright
is unsatisﬁable, i.e.,/logicalandtextk−1
i=0ˆT/llbracketi/rrbracketadmits no path in k
steps from Ito¬ϕ. Thus, ˆTis reﬁned as ˆT∧/logicalandtextk−1
i=0ˆT/llbracketi/rrbracket, which becomes the new approximation in
the next iteration for veriﬁcation (lines 11–12).
The process continues until a veriﬁcation result can be
concluded. The correctness and termination of Algorithm 1
are proved in [22], [23].
IV . I MPROVING COMPOSITIONAL VERIFICATION BY
INTERPOLATIONS
In this section, we introduce how the compositional veri-
ﬁcation based on assume-guarantee reasoning (AGR), can beimproved using interpolations. We ﬁrst show how our approachworks for systems with two processes in Section IV-A. Next,we show how to extend our approach to systems with manyprocesses in Section IV-B.
A. Generating Assumptions by Interpolations
Let us recall the AG-NC proof rule in Equation 1. To
automatically generate the assumption A
2, we can construct
A2as the symmetric interpolants of M2from the bounded
model checking problem of M1/bardblM2|=ϕ. Since the
transition relation of A2is an over-approximation of that of
M2, the second condition of Equation 1, M2/precedesequalA2, holds
naturally. We only have to check whether the ﬁrst condition,
M1/bardblA2|=ϕ, holds or not. If it does, then we have a
conclusive result showing that M1/bardblM2|=ϕ. If it does not
hold with a counterexample in ksteps, the transition relation of
the assumption A2is reﬁned (strengthened) by the interpolants
obtained from the k-step bounded model checking problem of
M1/bardblM2|=ϕprovided that the problem is unsatisﬁable.
Furthermore, applying the AGR rule twice, it is easy to seethat the following rule holds.
A
1/bardblA2|=ϕandM2/precedesequalA2andM1/precedesequalA1
M1/bardblM2|=ϕ(2)
Thus, using the same formula for bounded model checkingofM
1/bardblM2, we can obtain the symmetric interpolant of the
68
Algorithm 2: Compositional Veriﬁcation based on Interpolation
input :M1=(x1,I1,T1)andM2=(x2,I2,T2): concrete transition systems; ϕ: the property to be checked
output: yes/no, with a counterexample
1ˆT1←−T1;
2ˆT2←− /latticetop ;
3while True do
4 if(x1,I1,ˆT1)/bardbl(x2,I2,ˆT2)|=ϕthen
5 return yes
6 else
7 Suppose¬ϕisk-reachable in (x1,I1,ˆT1)/bardbl(x2,I2,ˆT2);
8 Θ←− {I/angbracketleft0/angbracketright
1,I/angbracketleft0/angbracketright
2,T/angbracketleft0/angbracketright
1,T/angbracketleft0/angbracketright
2,T/angbracketleft1/angbracketright
1,T/angbracketleft1/angbracketright
2,...,T/angbracketleftk−1/angbracketright
1,T/angbracketleftk−1/angbracketright
2,¬ϕ/angbracketleftk/angbracketright};
9 if/logicalandtextΘis satisﬁed by a valuation νthen
10 return(no,ν)
11 else
12 LetˆΘ={ˆI/angbracketleft0/angbracketright
1,ˆI/angbracketleft0/angbracketright
2,ˆT/angbracketleft0/angbracketright
1,ˆT/angbracketleft0/angbracketright
2,ˆT/angbracketleft1/angbracketright
1,ˆT/angbracketleft1/angbracketright
2,...,ˆT/angbracketleftk−1/angbracketright
1,ˆT/angbracketleftk−1/angbracketright
2,ˆ¬ϕ/angbracketleftk/angbracketright}be the symmetric interpolant for Θ;
13 ˆT2←−ˆT2∧/logicalandtextk−1
i=0(ˆT/angbracketlefti/angbracketright
2)/angbracketleft−i/angbracketright;
14 ˆT1←−/logicalandtextk−1
i=0(ˆT/angbracketlefti/angbracketright
1)/angbracketleft−i/angbracketright;//Abstracting M1(optional)
transition relation for M1as well, which gives A1, i.e., the
abstraction of M1.
Algorithm 2 shows the pseudo-code of the proposed au-
tomatic compositional veriﬁcation approach based on interpo-
lations (with A2strengthened and A1abstracted simultane-
ously). The details are described as follows.
Initially, the approximation ˆT1is initialized as T1, and the
approximation ˆT2is initialized as /latticetop, respectively (lines 1–2).
If(x1,I1,ˆT1)/bardbl(x2,I2,ˆT2)|=ϕholds, then we can conclude
that(x1,I1,T1)/bardbl(x2,I2,T2)|=ϕalso holds (lines 4–5)
because ˆT1andˆT2are over-approximations of T1andT2,
respectively. Note that both T1=⇒ˆT1andT2=⇒ˆT2hold
according to the properties of interpolations (cf. Deﬁnition 2).
If¬ϕisk-reachable in (x1,I1,ˆT1)/bardbl(x2,I2,ˆT2), there could
be two cases: (1) ¬ϕis alsok-reachable in (x1,I1,T1)/bardbl
(x2,I2,T2), or (2) ˆT2is too weak an approximation. We
construct a set of formulas
Θ={I/angbracketleft0/angbracketright
1,I/angbracketleft0/angbracketright
2,T/angbracketleft0/angbracketright
1,T/angbracketleft0/angbracketright
2,...,T/angbracketleftk−1/angbracketright
1,T/angbracketleftk−1/angbracketright
2,¬ϕ/angbracketleftk/angbracketright}
where/logicalandtextΘis exactly the bounded model checking formula.
We use a decision procedure to determine its satisﬁability.
• If/logicalandtextΘis satisﬁable, we can conclude that
(x1,I1,T1)/bardbl(x2,I2,T2)violates the property ϕ
because there exists a real counterexample in ksteps
(lines9–10).
• If/logicalandtextΘis unsatisﬁable, then ˆT2is too weak and needs
to be strengthened, which can be done as follows. Let
ˆΘ={ˆI/angbracketleft0/angbracketright
1,ˆI/angbracketleft0/angbracketright
2,ˆT/angbracketleft0/angbracketright
1,ˆT/angbracketleft0/angbracketright
2,...,ˆT/angbracketleftk−1/angbracketright
1,ˆT/angbracketleftk−1/angbracketright
2,ˆ¬ϕ/angbracketleftk/angbracketright}
be the symmetric interpolant for Θ. Let us deﬁne
ˆT/llbracketi,j/rrbracket=(ˆT/angbracketlefti/angbracketright
j)/angbracketleft−i/angbracketrightfori∈{0,1,...,k−1}and
j∈{1,2}where(ˆT/angbracketlefti/angbracketright
j)/angbracketleft−i/angbracketrightdenotes the formula
obtained by removing iprimes from ˆT/angbracketlefti/angbracketright
jif possible.Because of the properties of symmetric interpolants,
the following bounded model checking formula
I/angbracketleft0/angbracketright
1∧I/angbracketleft0/angbracketright
2∧k−1/logicalanddisplay
i=0ˆT/angbracketlefti/angbracketright
/llbracketi,1/rrbracket∧k−1/logicalanddisplay
i=0ˆT/angbracketlefti/angbracketright
/llbracketi,2/rrbracket∧¬ϕ/angbracketleftk/angbracketright
is unsatisﬁable. That is to say,/logicalandtextk−1
i=0ˆT/llbracketi,1/rrbracket and/logicalandtextk−1
i=0ˆT/llbracketi,2/rrbracket admit no path in ksteps from I1∧
I2to violate ϕ. Note that/logicalandtextk−1
i=0ˆT/llbracketi,2/rrbracket is an over-
approximation of T2as well as a reﬁnement of ˆT2.
Thus, we strengthen ˆT2asˆT2∧/logicalandtextk−1
i=0ˆT/llbracketi,2/rrbracket for the next
iteration (line 13). In addition, since/logicalandtextk−1
i=0ˆT/llbracketi,1/rrbracket is an
over-approximation of T1, we can optionally abstract
ˆT1as/logicalandtextk−1
i=0ˆT/llbracketi,1/rrbracket in line14, which alleviates the
state space explosion problem when checking whether
(x1,I1,ˆT1)/bardbl(x2,I2,ˆT2)|=ϕholds.
Theorems 1 and 2 prove the correctness and termination
of the proposed interpolation-based approach.
Theorem 1: Algorithm 2 is correct.
Proof: To establish the correctness of Algorithm 2, we
want to prove that it returns “yes” only if M1/bardblM2|=ϕ, and
returns “no” with a counterexample only if M1/bardblM2/negationslash|=ϕ.
LetˆM1=(x1,I1,ˆT1)andˆM2=(x2,I2,ˆT2)be the transition
systems with respect to ˆT1andˆT2, respectively. Since ˆT1and
ˆT2are obtained by interpolations, both T1=⇒ˆT1and
T2=⇒ˆT2hold, i.e., ˆM1andˆM2are the abstractions of M1
andM2, respectively. Algorithm 2 returns “yes” only when
ˆM1/bardblˆM2|=ϕ, which implies M1/bardblM2|=ϕ. On the other
hand, Algorithm 2 returns “no” only when/logicalandtextΘis satisﬁable
by a valuation ν. Since/logicalandtextΘis a bounded model checking
formula to check whether ¬ϕis reachable within k-steps in
M1/bardblM2, the valuation νis a witness of M1/bardblM2/negationslash|=ϕ.
From the above arguments, we can conclude that Algorithm 2
is correct.
69
Algorithm 3: PARTITION
input :{C1,C2,...,C n}: a set of components;
k: the number of steps
output:(M1,M2): the partition of all components
1M1←−M2←− ∅ ;
2LetUΨbe the unsatisﬁability core of Ψ;
3forj=1 tondo
4 ifCjhas any variable appearing in UΨthen
5 M1←−M1∪{Cj};
6M2←− {C1,C2,...,C n}\M1;
7return(M1,M2);
Theorem 2: Algorithm 2 terminates.
Proof: To establish the termination of Algorithm 2, we
want to prove that the number of reﬁnement iterations for ˆT1
andˆT2is ﬁnite. In Algorithm 2, ˆT2is initialized as /latticetop, and
ˆT1is set to the most abstract over-approximation after the ﬁrst
iteration. In the following iterations of Algorithm 2, ˆT1and
ˆT2are reﬁned and approaching to T1andT2, respectively.
For ﬁnite state systems, the reﬁnement loop for ˆT1andˆT2in
Algorithm 2 must terminate. This is simply because we cannot
strengthen a formula with a ﬁnite number of models inﬁnitely.That is,M
1/bardblM2|=ϕwill be either proved or disproved in
Algorithm 2 within a ﬁnite number of iterations.
B. Generalization to Multiple Components
The proposed compositional veriﬁcation approach based
on interpolation is presented in the context of two compo-nents. If a system consists of ncomponents modeled by
M={C
1,C2,...,C n}wheren≥3, an intuitive approach
to generalize our approach is to partition the components intotwo groups to ﬁt the AG-NC proof rule. For example, if n=4,
we can obtain M
1=C1/bardblC2andM2=C3/bardblC4, and apply
our approach on M1andM2.
However, the number of possible partitions is 2n−2,
which is exponential to the number of components. In addition,Cobleigh et al. [17] showed that a good partition is veryimportant to AGR with the AG-NC proof rule. With a badpartition, assume-guarantee reasoning may not be beneﬁcial,which is corroborated in our experiments in Section V.
In the following, we would like to show that bounded
model checking can help to ﬁnd good partitions efﬁciently.Let us recall the AG-NC proof rule for AGR. An ideal case isthat we can have a conclusive veriﬁcation result when the as-sumption A
2is the most abstract one, whose transition relation
is/latticetop. That is to say, considering only the M1group is sufﬁcient
to have a conclusive result, or the property to be veriﬁedis only related to the M
1group. Based on this observation,
we propose a partition heuristic based on the unsatisﬁabilitycore of BMC formula. Consider the following bounded modelchecking formula in ksteps for the ncomponents where
C
j=(xj,Ij,Tj)andj∈{1,2,...,n}.
Ψ=n/logicalanddisplay
j=1I/angbracketleft0/angbracketright
j∧k−1/logicalanddisplay
i=0n/logicalanddisplay
j=1T/angbracketlefti/angbracketright
j∧¬ϕ/angbracketleftk/angbracketrightIfΨis not satisﬁable, the property is not going to be
violated in ksteps. We can obtain its unsatisﬁability core,
denoted by UΨ, which includes the formula showing why the
property cannot be violated in ksteps. In the other hand, the
unsatisﬁability core also gives us a hint of which componentsare necessary to prove that the property is satisﬁed.
The heuristic, P
ARTITION , for partitioning components is
shown in Algorithm 3. Initially, groups M1andM2are
initialized as empty, respectively (line 1). The satisﬁability of
the bounded model checking formula Ψinksteps is checked
by a decision procedure. If it is unsatisﬁable, we obtain itsunsatisﬁability core, denoted by U
Ψ(line2). If a component
Cjfor some j∈{1,2,...,n}has a variable appearing in
the unsatisﬁability core UΨ, we include Cjinto the group M1
because it is strongly necessary to prove that the property issatisﬁed (lines 3–5). The remaining components that do not
have any variables appearing in U
Ψare included into the group
M2(line6), and the ﬁnal partitioned groups M1andM2are
returned (line 7).
Algorithm 4 gives the pseudo-code of the generalized
interpolation-guided compositional veriﬁcation for multiplecomponents. Initially, we assume that there is an initial par-tition of groups M
1andM2(line2). Then Algorithm 4
works similarly to Algorithm 2 as if there are only twohypothetical components M
1andM2. When a counterexample
is found in abstract components in ksteps (line 9), a BMC
of length kis performed to check whether there exists any
k-step counterexample in the concrete components (line 10).
If the BMC formula is satisﬁed by an valuation ν(line11),
then a real counterexample is found and returned (line 12).
If the BMC formula is not satisﬁable (line 13), the partition
heuristic is performed (line 14) with the value kto obtain a
new partition (M/prime
1,M/prime
2). If there is any component in M/prime
1but
not inM1, it is then included into M1(lines15–17), and the
veriﬁcation restarts from scratch for the new partition (line 18).
If there is no re-partition that can be made (line 19), the
process continues similarly to Algorithm 2 until a veriﬁcationresult can be concluded. We remark that the k-step BMC
formulaΨin the partition heuristic is equivalent to the formula/logicalandtextΘfor checking whether ¬ϕisk-reachable in the concrete
components. Thus, the formula could be solved only once suchthat the unsatisﬁability core as well as the interpolants areobtained from the same unsatisﬁability proof.
The correctness of Algorithm 4 can be proved by Theo-
rem 1 as well, while the termination has to be established basedon Theorem 2 plus the ﬁnite number of re-partition iterations.Notice that the number of components in the M
1group is
strictly increasing, and therefore the number of re-partitions inAlgorithm 4 is at most niterations. Since the re-partitions are
ﬁnite and the veriﬁcation terminates for each new partition (byTheorem 2), we can conclude that Algorithm 4 terminates ina ﬁnite number of iterations.
V. E
V ALUATION
The proposed interpolation-based compositional veriﬁca-
tion framework has been implemented in the PAT modelchecker [38]. We use MathSAT [13] (an SMT solver) to obtaininterpolations. MathSAT supports three different ways to ob-tain interpolations from unsatisﬁability formulas. We use the
70
Algorithm 4: Generalized Interpolation-based Compositional Veriﬁcation
input :{C1,C2,...,C n}: a set of components; ϕ: the property to be checked
output: yes/no, with a counterexample
1while True do
2 Let(M1,M2)be a partition where Mi=(xi,Ii,Ti)fori∈{1,2};
3ˆT1←−T1;
4ˆT2←− /latticetop ;
5 while True do
6 if(x1,I1,ˆT1)/bardbl(x2,I2,ˆT2)|=ϕthen
7 return yes
8 else
9 Suppose¬ϕisk-reachable in (x1,I1,ˆT1)/bardbl(x2,I2,ˆT2);
10 Θ←− {I/angbracketleft0/angbracketright
1,I/angbracketleft0/angbracketright
2,T/angbracketleft0/angbracketright
1,T/angbracketleft0/angbracketright
2,T/angbracketleft1/angbracketright
1,T/angbracketleft1/angbracketright
2,...,T/angbracketleftk−1/angbracketright
1,T/angbracketleftk−1/angbracketright
2,¬ϕ/angbracketleftk/angbracketright};
11 if/logicalandtextΘis satisﬁed by a valuation νthen
12 return(no,ν)
13 else
14 (M/prime
1,M/prime
2)←− PARTITION ({C1,...,C n},k);
15 ifM/prime
1\M1/negationslash=∅then
16 M1←−M1∪(M/prime
1\M1);
17 M2←− {C1,C2,...,C n}\M1;
18 goto Line2;
19 LetˆΘ={...,ˆT/angbracketleft0/angbracketright
1,ˆT/angbracketleft0/angbracketright
2,ˆT/angbracketleft1/angbracketright
1,ˆT/angbracketleft1/angbracketright
2,...,ˆT/angbracketleftk−1/angbracketright
1,ˆT/angbracketleftk−1/angbracketright
2,ˆ¬ϕ/angbracketleftk/angbracketright}be the symmetric interpolant for Θ;
20 ˆT2←−ˆT2∧/logicalandtextk−1
i=0(ˆT/angbracketlefti/angbracketright
2)/angbracketleft−i/angbracketright;
21 ˆT1←−/logicalandtextk−1
i=0(ˆT/angbracketlefti/angbracketright
1)/angbracketleft−i/angbracketright;//Abstracting M1(optional)
approach proposed by McMillan [31] in our implementation.
To demonstrate the feasibility and beneﬁts of our approach,the following systems are used as benchmarks.
• FMS. A ﬂexible manufacturing system (FMS) [36],[26] produces blocks with a cylindrical painted pinfrom raw blocks and raw pegs. The manufacturingdevices are connected through buffers, and the ca-pacity of each buffer is one. We verify the propertiesrequiring that each buffer should not overﬂow.
• DP. The dining philosophers (DP) problem illustratesa resource sharing problem in concurrent systems.Philosophers sit at a round table, and there is onlyone fork between any two philosophers. A philosopherrequires two forks (shared with his/her neighbors) toeat. We verify the properties requiring that any pair ofneighboring philosophers cannot eat simultaneously.
• AIP. The AIP manufacturing system [24], [27], [28]produces two products from two types of materials indifferent production routes. We verify the propertiesrequiring that the routes of the two types of materialsshould be opposite.
• SBA. The synchronous bus arbiter (SBA) is a busarbitration protocol for synchronous circuits [30]. Abus is connected by nodes (the components to accessit) in a ring, and a token is passed around the nodes.We veriﬁed the properties requiring that a bus cannotbe accessed simultaneously by more than two nodes.• MSI. In the MSI cache coherence protocol [30], amemory is shared by nnodes, each of which has a
cache. A bus connects the caches of the nodes andthe memory. We veriﬁed the properties requiring thatthe bus cannot be owned simultaneously by more thantwo nodes.
The system models
2and veriﬁed properties of all the ex-
periments, and the implementation of our framework can befound in [2] on-line. In our experiments, all the propertiesare satisﬁed. We compare three veriﬁcation techniques: tra-ditional BDD-based model checking [30], [33], McMillan’sinterpolation-based transition over-approximation [22], [23],and our interpolation-guided compositional veriﬁcation. Sinceboth of McMillan’s and our approaches require an underlyingveriﬁcation engine, we adopt the traditional BDD-based modelchecking
3. The following experimental results were obtained
by running the PAT model checker on a 64-bit Windows 7
laptop with a 2.8GHz Intel(R) Core(TM) i7-2640M processor
and4GB RAM.
Table I shows the veriﬁcation results of different tech-
niques, where BDD denotes the traditional BDD-based modelchecking, Mc-ITP denotes McMillan’s interpolation-basedtransition over-approximation, C-ITP denotes the proposed
2The input language of our models, which is a simpliﬁed version of
NuSMV’s input language, does not support parameterized module deﬁnitions.
3We integrate the CUDD library [3] in our implementation, and the default
settings are used for all experiments.
71
TABLE I. V ERIFICATION RESULTS
BDD Mc-ITP C-ITP C-ITP A C-ITP P+A
System n|ϕ| Time Time |R| Time |R| Time |R| Time |P|
FSM-02 8610.9 2.02 4 1.11 2 1.81 6 0.30
FSM-04 1612 ⋆9.54 8 12.33 2 7.13 6 0.60
FSM-06 2418 ⋆20.57 2 37.85 6 19.36 0 1.10
FSM-08 3224 ⋆ ⋆ 77.18 0 47.78 4 1.80
FSM-10 4030 ⋆83.1 120 255.0 104 251.6 108 2.70
FSM-12 4836 ⋆ ⋆ ⋆ ⋆ 3.80
FSM-14 5642 ⋆192.8 168 258.0 152 190.1 156 5.20
FSM-16 6448 ⋆298.1 192 360.5 176 282.8 180 7.30
FSM-18 7254 ⋆368.3 216 512.0 200 432.7 204 9.10
FSM-20 8060 ⋆506.9 240 718.4 224 576.8 228 11.80
FSM-24 9672 ⋆ /clock 1020.8 272 885.5 276 17.90
FSM-30 120 90 ⋆ /clock /clock /clock 28.60
DP-04 84 4.8198.91 4 5.31 3 1.41 3 0.55
DP-06 12 6 ⋆7.52 2 ⋆ 2.11 9 1.17
DP-08 16 8 ⋆18.72 8 ⋆ 3.72 5 1.91 1
DP-10 2010 ⋆19.03 4 ⋆ 8.73 2 2.91 4
DP-20 4020 ⋆35.76 3 ⋆ 26.06 1 13.32 9
DP-30 6030 ⋆115.6 106 ⋆ 118.9 101 32.64 4
DP-40 8040 ⋆200.0 124 ⋆ 138.6 122 68.55 8
DP-50 100 50 ⋆281.1 154 ⋆ 276.2 154 122.27 4
DP-60 120 60 ⋆493.2 187 ⋆ 469.7 185 199.78 9
DP-70 140 70 ⋆645.2 214 ⋆ 695.9 215 313.6 104
AIP-01 82106.5 1.71 0 10.89 3.71 0 10.50
AIP-02 16 4 ⋆6.62 0 168.32 0 12.42 0 39.91 2
AIP-04 32 8 ⋆30.04 0 ⋆ 86.84 4 81.52 4
AIP-06 4812 ⋆87.06 0 ⋆ 267.56 8 128.33 6
AIP-08 6416 ⋆189.88 0 ⋆ 611.99 2 180.74 8
AIP-10 8020 ⋆352.5 100 ⋆ 1170.6 116 242.76 0
AIP-11 8822 ⋆459.8 110 ⋆ 1539.4 128 274.66 6
AIP-12 9624 ⋆614.2 120 ⋆ /clock 317.87 2
SBA-02 812 ⋆ ⋆ 140.34 4 13.14 8 3.73 6
SBA-03 1218 ⋆ ⋆ 631.17 4 214.77 8 6.75 4
SBA-04 1624 ⋆ ⋆ 1086.2 104 420.5 108 11.57 2
SBA-05 2030 ⋆ ⋆ 1602.1 134 651.0 138 17.19 0
SBA-06 2436 ⋆ ⋆ /clock 897.1 168 22.9 108
SBA-07 2842 ⋆ ⋆ /clock 1038.4 198 31.9 126
SBA-08 3248 ⋆ ⋆ /clock 1291.7 228 41.7 144
SBA-09 3654 ⋆ ⋆ /clock 1536.3 258 53.2 162
SBA-10 4060 ⋆ ⋆ /clock /clock 71.4 180
MSI-02 81 ⋆0.33 2.73 0.73 1.41
MSI-03 11 3 ⋆3.21 1 /clock /clock 4.43
MSI-04 14 6 ⋆ /clock /clock /clock 12.76
MSI-05 1710 ⋆ ⋆ ⋆ ⋆ ⋆
n: number of components; |ϕ|: number of veriﬁed properties;
Time: veriﬁcation time (in secs); |R|: number of reﬁnements; |P|: number of re-partitions
⋆: out of memory; /clock: time out (30 minutes)
interpolation-guided compositional veriﬁcation, and C-ITP A
denotes the C-ITP approach with abstraction of M1.W e
remark in the above experiments the number of components
involved in the systems (denoted by n) is more than 2 and
therefore we need to partition the components into two groupsfor the C-ITP and C-ITP
Aapproaches. Speciﬁcally, we put
the ﬁrst four components in the M1group and the remains
in theM2group. Note that the order of components can be
speciﬁed by users in the input model. In this set of experiments,we randomly picked one possible order and ﬁxed it for allexperiments unless the partition heuristic is performed.
As we expected, BDD-based model checking performed
worst because it ran out of all available memory for most ofthe cases. In average, McMillan’s approach performed betterthan the C-ITP approach because the partition of the M
1and
M2groups is not good, which leaded to many cases of running
out of memory or time out. However, with the abstractionofM
1, most of these cases can be veriﬁed by the C-ITP A
approach in 30minutes, which shows the signiﬁcant beneﬁt
of abstracting M1in assume-guarantee reasoning. We remark
here that the integration of the SMT solver, MathSAT, isdone by interprocess communications, i.e., a dedicated processis created for MathSAT, and the problems (in SMT-LIB [1]format) to be solved as well as the output interpolations or theunsatisﬁability cores are stored in shared string buffers. Thisimplementation is not optimized because it invokes systemcalls many times, which is time-consuming. The performancecould be improved if MathSAT is integrated natively as alibrary.
We also applied our generalized approach (with the par-
tition heuristic as well as abstracting M
1), denoted by C-
ITPP+A, on the application examples, and the veriﬁcation
results are shown in the right-most column. The initial partitionis obtained by performing the partition heuristic with lengthtwo, which is short but gives a rough understanding of thecomponents. We did not list the number of reﬁnements for theC-ITP
P+Aapproach in the table because the partition heuristic
is able to ﬁnd good partitions where all the componentsrelated to the property are put into the M
1group so that
the property can be proved to hold with the most abstractassumption whose transition relation is /latticetop, i.e., no reﬁnements
are required. Instead, we list the number of re-partitions for theC-ITP
P+Aapproach. In the FSM example, good partitions can
be found initially, while other examples require re-partitions.In the MSI example, no approach can handle the case of ﬁvenodes, which consists of seventeen components, because of
72
running out of memory. After our investigation, we found
that the bottleneck is the underlying BDD-based veriﬁcationengine. Since the transition relations of the MSI componentsare rather complicated, the underlying BDD-based veriﬁcationeasily runs out of memory. In average, the C-ITP
P+Aapproach
is the best one, especially when the system size is large.
VI. R ELATED WORK
Model checking [14], [35] suffers from the state explosion
problem. To alleviate the problem, Pnueli ﬁrstly proposed theassume-guarantee paradigm [34] to verify system componentsindividually and use the individual veriﬁcation results to de-duce additional properties of the system. Clarke et al. [15]used interface processes to model the abstract environmentfor a component, which is much smaller than the real one,such that the state space is reduced. For formal veriﬁcationthat is not based on model checking, Xu et al. [39] proposeda proof system based on the assume-guarantee paradigm forverifying shared variable concurrent programs. Henzinger etal. [21] reported several case studies about applying assume-guarantee reasoning on real world systems.
Cobleigh et al. [16] proposed a framework that generates
the abstract environment of components automatically usingthe L
∗algorithm [5] based on the AG-NC proof rule. This work
is a pioneer of automating the compositional veriﬁcation basedon learning techniques. Consequently, several improvements[11], [37], [19] have been proposed to further reduce the com-plexity. These improvements focus on reducing the size of thealphabet during learning, which dominates the time complexityof the membership query required the L
∗algorithm. Instead of
adopting the non-circular AG-NC proof rule, Barringer et al.used the L
∗algorithm to learn assumptions automatically for
AGR based on the circular and symmetric proof rule [6]. Linet al. extended the learning-based compositional veriﬁcationon timed systems [25], [29], [26].
In traditional assume-guarantee reasoning (AGR), the M
1
component in the AG-NC proof rule is never changed duringthe whole veriﬁcation process, which is very different fromcompositional abstraction [7], [10], [9] where each component
is abstracted and reﬁned iteratively. The approach proposed inthis work breaks with tradition of AGR such that both of theM
1andM2components are abstracted and reﬁned by the
interpolants obtained from unsatisﬁability proofs of boundedmodel checking formulas.
The closest work to the proposed approach in this paper
is [12], which focuses on automatic assumption generationfor compositional symbolic veriﬁcation as well. We havetried to obtain an implementation of [12] for experimentalcomparisons, but failed. The differences between this workand [12] are listed as follows, and we compare them intheoretical point of views.
• Our approach uses interpolation techniques to generatethe assumption, while [12] uses the CDNF algo-rithm [8], which is an active algorithm for learningBoolean formulas from membership and candidatequeries.
• Regarding the AG-NC proof rule in Equation 1,our approach need not check the second condition,M
2/precedesequalA2, because A2is an abstraction of M2
by construction according to the characteristic ofinterpolations. However, in [12], M
2/precedesequalA2has to
be veriﬁed by model checking each time when acandidate assumption A
2is constructed, which is an
additional overhead compared to our approach.
• The partition problem in AGR is not solved in [12],i.e., the partition has to be given manually, while ourapproach solves it by unsatisﬁability cores of BMCformulas.
VII. C
ONCLUSION AND FUTURE WORK
In this work, we propose an automatic compositional
symbolic veriﬁcation based on interpolations. The assump-tionA
2required by assume-guarantee reasoning is obtained
by symmetric interpolants from the unsatisﬁability proofs ofbounded model checking. In addition, the proposed approachalso weakens the component M
1based on interpolations
during the veriﬁcation, which further alleviates the state spaceexplosion problem when checking M
1/bardblA2|=ϕ. Currently,
we use McMillan’s interpolation technique. In the future, weplan to use different interpolation techniques to generate theassumptions and to compare the veriﬁcation results based ondifferent interpolation techniques.
R
EFERENCES
[1] http://smt-lib.org/.
[2] https://sites.google.com/site/shangweilin/itpagr.[3] http://vlsi.colorado.edu/ fabio/cudd/.[4] R. Alur, P. Madhusudan, and W. Nam. Symbolic compositional
veriﬁcation by learning assumptions. In CA V, volume 3576 of LNCS,
pages 548–562, 2005.
[5] D. Angluin. Learning regular sets from queries and counterexamples.
Information and Computation, 75(2):87–106, 1987.
[6] H. Barringer, D. Giannakopoulou, and C. S. P ˘as˘areanu. Proof rules
for automated compositional veriﬁcation through learning. In SA VCBS,
pages 14–21, 2003.
[7] S. Bensalem, Y . Lakhnech, and S. Owre. Computing abstractions
of inﬁnite state systems compositionally and automatically. In CA V,
volume 1427 of LNCS, pages 319–331, 1998.
[8] N. H. Bshouty. Exact learning boolean function via the monotone
theory. Information and Computation, 123(1):146–153, 1995.
[9] S. Chaki, E. Clarke, O. Grumberg, J. Ouaknine, N. Sharygina, T. Touili,
and H. Veith. State/event software veriﬁcation for branching-time
speciﬁcations. In IFM, volume 3771 of LNCS, pages 53–69, 2005.
[10] S. Chaki, J. Ouaknine, K. Yorav, and E. Clarke. Automated compo-
sitional abstraction reﬁnement for concurrent c programs: A two-levelapproach. Electronic Notes in Theoretical Computer Science, 89(3),
2003.
[11] S. Chaki and O. Strichman. Optimized L
∗-based assume-guarantee
reasoning. In TACAS, volume 4424 of LNCS, pages 276–291, 2007.
[12] Y .-F. Chen, E. M. Clarke, A. Farzan, M.-H. Tsai, Y .-K. Tsay, and
B.-Y . Wang. Automated assume-guarantee reasoning through implicitlearning. In CA V, volume 6174 of LNCS, pages 511–526, 2010.
[13] A. Cimatti, A. Griggio, B. Schaafsma, and R. Sebastiani. The Math-
SAT5 SMT Solver. In TACAS, volume 7795 of LNCS, 2013.
[14] E. M. Clarke and E. A. Emerson. Design and sythesis of synchro-
nization skeletons using branching time temporal logic. In Logics of
Programs Workshop, volume 131, pages 52–71, 1981.
[15] E. M. Clarke, D. E. Long, and McMillan K. L. Compositional model
checking. In LICS 1989, pages 353–362, 1989.
[16] J. M. Cobleigh, D. Giannakopoulou, and C. S. P ˘as˘areanu. Learning
assumptions for compositional veriﬁcation. In TACAS, volume 2619 of
LNCS, pages 331–346, 2003.
73
[17] J.M. Cobleigh, G. S. Avrunin, and L. A. Clarke. Breaking up is hard to
do: An investigation of decomposition for assume-guarantee reasoning.
InISSTA, pages 97–108, 2006.
[18] M. Craig. A new form of the herbrand-gentzen theorem. Journal of
Symbolic Logic, 22(3):250–268, 1957.
[19] M. Gheorghiu, D Giannakopoulou, and C. S. P ˘as˘areanu. Reﬁning
interface alphabets for compositional veriﬁcation. In TACAS, volume
4424 of LNCS, pages 292–307, 2007.
[20] O. Grumberg and D. E. Long. Model checking and modular veriﬁcation.
InCONCUR, volume 527 of LNCS, pages 250–265, 1991.
[21] T. A. Henzinger, S. Qadeer, and S. K. Rajamani. You assume, we
guarantee: Methodology and case studies. In CA V, volume 1427 of
LNCS, pages 440–451, 1998.
[22] R. Jhala and K. L. McMillan. Interpolant-based transition relation
approximation. In CA V, volume 3576 of LNCS, pages 39–51, 2005.
[23] R. Jhala and K. L. McMillan. Interpolant-based transition relation
approximation. Logical Methods in Computer Science, 3(4), 2007.
[24] R. J. Leduc, M. Lawford, and P. C. Dai. Hierarchical interface-
based supervisory control of a ﬂexible manufacturing system. IEEE
Transactions on Control Systems Technology, 14(4):654–668, 2006.
[25] S.-W. Lin, ´E. Andr ´e, J. S. Dong, J. Sun, and Y . Liu. An efﬁcient
algorithm for learning event-recording automata. In ATVA , volume 6996
ofLNCS, pages 463–472, 2011.
[26] S.-W. Lin, ´E. Andr ´e, Y . Liu, J. Sun, and J. S. Dong. Learning
assumptions for compositional veriﬁcation of timed systems. IEEE
Transactions on Software Engineering (TSE), 40(2):137–153, 2014.
[27] S.-W. Lin and P. A Hsiung. Counterexample-guided assume-
guarantee synthesis through learning. IEEE Transactions on Computers,
60(5):734–750, 2011.
[28] S.-W. Lin and P.-A. Hsiung. Compositional synthesis of concurrent
systems through causal model checking and learning. In FM, volume
8442 of LNCS, pages 416–431, 2014.
[29] S.-W. Lin, Y . Liu, J. Sun, J. S. Dong, and ´E. Andr ´e. Automatic
compositional veriﬁcation of timed systems. In FM, volume 7436 of
LNCS, pages 272–276, 2012.
[30] K. L. McMillan. Symbolic Model Checking: An approach to the state
explosion problem. Ph. D. Thesis, Carnegie Mellon University, 1992.
[31] K. L. McMillan. Interpolation and sat-based model checking. In CA V,
volume 2725 of LNCS, pages 1–13, 2003.
[32] W. Nam and R. Alur. Learning-based symbolic assume-guarantee
reasoning with automatic decomposition. In ATVA ,volume 4218 of
LNCS, pages 170–185, 2006.
[33] T. K. Nguyen, J. Sun, Y . Liu, and J. S. Dong. A model checking
framework for hierarchical systems. In ASE, pages 633–636, 2011.
[34] A. Pnueli. In transition from global to modular temporal reasoning
about programs. In Logics and Models of Concurrent Systems, pages
123–144, 1985.
[35] J. P. Queille and J. Sifakis. Speciﬁcation and veriﬁcation of concurrent
systems in CESAR. In International Symposium on Programming,
volume 137, pages 337–351, 1982.
[36] M. H. Queiroz, J. E. R. Cury, and W. M. Wonham. Multitasking
supervisory control of discrete-event systems. Discrete Event Dynamic
Systems, 15(4), 2005.
[37] N. Sinha and E. M. Clarke. SAT-based compositional veriﬁcation using
lazy learning. In CA V, volume 4590 of LNCS, pages 39–54, 2007.
[38] J. Sun, Y Liu, J. S. Dong, and J. Pang. PAT: Towards ﬂexible veriﬁcation
under fairness. In CA V, volume 5643 of LNCS, pages 709–714, 2009.
[39] Q. Xu, W. P de Roever, and J. He. The rely-guarantee method for
verifying shared variable concurrent programs. F ormal Aspects of
Computing, 9(2):149–174, 1997.
74
