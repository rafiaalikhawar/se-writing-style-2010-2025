GPredict: Generic Predictive Concurrency Analysis
Jeff Huang
Parasol Laboratory
Texas A&M University
Email: jeff@cse.tamu.eduQingzhou Luo and Grigore Rosu
Deparment of Computer Science
University of Illinois at Urbana-Champaign
Email:fqluo2, grosug@illinois.edu
Abstract ‚ÄîPredictive trace analysis (PTA) is an effective ap-
proach for detecting subtle bugs in concurrent programs. Existing
PTA techniques, however, are typically based on adhoc algorithms
tailored to low-level errors such as data races or atomicity
violations, and are not applicable to high-level properties such as
‚Äúa resource must be authenticated before use‚Äù and ‚Äúa collection
cannot be modiÔ¨Åed when being iterated over‚Äù. In addition,
most techniques assume as input a globally ordered trace of
events, which is expensive to collect in practice as it requires
synchronizing all threads. In this paper, we present GPredict :
a new technique that realizes PTA for generic concurrency
properties. Moreover, GPredict does not require a global trace
but only the local traces of each thread, which incurs much less
runtime overhead than existing techniques. Our key idea is to
uniformly model violations of concurrency properties and the
thread causality as constraints over events. With an existing
SMT solver, GPredict is able to precisely predict property
violations allowed by the causal model. Through our evaluation
using both benchmarks and real world applications, we show
thatGPredict is effective in expressing and predicting generic
property violations. Moreover, it reduces the runtime overhead of
existing techniques by 54% on DaCapo benchmarks on average.
I. I NTRODUCTION
The difÔ¨Åculty of concurrent programming has inspired a
wide range of fault detection and diagnosis tools. Among
them, predictive trace analysis (PTA) has drawn a signiÔ¨Åcant
attention [18], [15], [16], [32], [13], [27], [29], [30], [10], [35],
[36], [34], [20], [19]. Generally speaking, a PTA technique
has two steps: it Ô¨Årst records a trace of execution events at
runtime, then, ofÔ¨Çine, it generates other (often exhaustive)
permutations of these events under certain causal model of
scheduling constraints, and predicts concurrency faults unseen
in the recorded execution. PTA is powerful as, compared to
dynamic analysis, it is capable of exposing bugs in unexercised
executions and, compared to static analysis, it incurs much
fewer false positives. Moreover, recent PTA techniques such
as Penelope [32], PECAN [15], and [27] can not only predict
faults, but also produce witnesses ( i.e., buggy schedules or
even concrete executions) that manifest the faults, which can
signiÔ¨Åcantly speed up the debugging process.
We observe that existing PTA techniques are generally
limited to detecting low-level memory access errors, such as
data races [27], [18], atomicity violations [32], [36], atomic-
set serialization violations [21], [33], or deadlocks [20], [19].
While these errors are common, they only capture a small
portion of concurrency faults in real world programs. For ex-
ample, consider a resource authenticate-before-useproperty, which requires a method authenticate to be
always called before a method use that uses the resource. Any
violation of this property is an indication of a serious security
bug. However, it cannot be characterized by conventional data
races, because in a violation of this property there may not
even exist conÔ¨Çicting reads and writes to shared data. As
another example, in Java, a collection is not allowed to be
modiÔ¨Åed when an iterator is accessing its elements. This prop-
erty, again, is neither a data race nor an atomicity violation, but
a more generic contract on the use of Java Iterators. Existing
techniques do not directly target these properties.
Moreover, while existing techniques are effective in detect-
ing the targeted race or atomicity errors, their algorithms are
usually adhoc and are not applicable to such more general
properties. For instance, the cut-point based algorithm of Pene-
lope [32] is specialized for predicting atomicity violations, and
the pattern-directed graph search algorithm in PECAN [15]
detects concurrency access anomalies only. Furthermore, for
building the causal model, existing algorithms generally as-
sume as input a linearized trace of events, which contains
all the necessary causal ordering information ( e.g., happens-
before) between critical events ( i.e., shared data accesses
and synchronizations). However, this relies on the ability to
track a globally ordered sequence of events by all threads
at runtime, which often incurs hundreds or even thousands
of times of program slowdown [15], [16], [32], [10], making
these techniques less useful in practice.
In this paper, we present a new PTA technique, GPredict ,
that is able to predict violations of high-level more generic
properties . Our central observation is that a vast category of
concurrency faults, together with the causal model, can be
modeled uniformly as Ô¨Årst-order logical constraints between
events. For example, for the authenticate-before-use
property, suppose we model the calls of these two methods
as two events, auth anduse, and give each of them a
corresponding order variable, Oauth andOuse, respectively.
A violation of this property can be simply modeled by the
constraintOuse<O auth, stating that the property is violated
if there exists any feasible schedule in which the order of
theuse event is smaller than the order of the auth event.
Similarly, violations of the collection iterator property can be
modeled as Ocreate< O update< O next, specifying that
the property is violated if a collection update event comes
between the iterator create event and an iterator next
event. Meanwhile, inspired by our prior work [18], we canalso soundly encode the causal model as constraints over the
order of critical events. By solving a conjunction of these
constraints, we can determine if a property can be violated
in other feasible executions, hence to predict faults deÔ¨Åned by
the properties.
Based on the observation above, we Ô¨Årst design a speciÔ¨Åca-
tion language for users to specify generic concurrency property
violations. Our language is adapted from MOP [8], a runtime
veriÔ¨Åcation system for parametric properties. Similar to MOP,
users of GPredict can declare the property events (which are
parametric) with AspectJ pointcuts, and specify the property
with a formalism over the declared events. Differently, in our
formalism, we explicitly support concurrency properties by
associating events with thread attributes and atomic regions,
and allowing parallelism between events. To instantiate our
design, we implemented an initial speciÔ¨Åcation formalism for
properties written in the form of regular expressions. We
present our speciÔ¨Åcation language and the constraint encoding
algorithm for the property violations in Section II.
Another main contribution of this work is a new and sound
causal model that is based on only the local traces of each
individual thread, rather than a global trace. This new model
not only ensures that GPredict never reports any false positive
(i.e., every property violation reported by GPredict is real),
but also enables GPredict to be synchronization-free for
collecting the execution traces at runtime, incurring much less
runtime overhead than existing techniques. The main challenge
we address is how to extract from the thread local traces the
synchronization constraints ( e.g., causal orderings caused by
the signal wait/notify events). We present a formal constraint
modeling in Section III and prove its soundness.
We have implemented GPredict for Java programs and
evaluated it on a set of real world applications with high
level generic properties, as well as conventional data races,
atomicity violations, and deadlocks written in our speciÔ¨Åcation
language. We show GPredict is both expressive and effective
in predicting generic property violations. Moreover, comparing
to the state of art techniques that log a global trace, GPre-
dict has signiÔ¨Åcantly better runtime performance due to the
use of thread-local traces, incurring 10%-82% less overhead
on DaCapo benchmarks [6]. We present the implementation
and evaluation of GPredict in Sections IV and V, respectively.
In summary, we make the following contributions:
We present a new predictive trace analysis (PTA) tech-
nique, GPredict , that is able to predict generic concur-
rency property violations based on constraint solving.
We present a speciÔ¨Åcation language for generic concur-
rency properties and the corresponding constraint encod-
ing algorithm for the property violations.
We present a sound constraint modeling of the predictive
causal model with only the thread-local traces as input,
which frees predictive analysis from expensive runtime
synchronizations in order to obtain a global trace.
We evaluate GPredict with real world applications and
demonstrate its effectiveness and runtime performance for
predicting generic property violations.
T1T2Collection<Item> c;Item A, B;   Iterator i1, i2;c.add(A);start T2;i1=c.iterator();i1.next()c.add(B);i2=c.iterator();i2.next()1:2:3:4:5:6:7:Fig. 2. A collection iterating example
II. G ENERIC PREDICTIVE ANALYSIS
The idea behind PTA is that computations of a concurrent
program may be scheduled in different orders, due to schedul-
ing non-determinism, and that from one observed execution,
a causal model can be constructed to infer a set of similar
feasible executions of the same program, which can be used
to predict behaviours not seen in the observed execution.
GPredict provides a general technique for the PTA of
generic property violations based on constraint solving. The
main idea is that both the causal model and the property
violations can be modeled uniformly by Ô¨Årst-order logical
constraints. By solving the constraints, we can predict property
violations in all the feasible executions captured by the causal
model. There are two categories of events in our model:
property events : declared in the property speciÔ¨Åcation.
model events : critical events that determine the causal
model, i.e., all the reads and writes to shared data and
thread synchronizations.
We next present the speciÔ¨Åcation and constraint modeling
of property events. Model events are addressed in Section III.
A. Overview
We Ô¨Årst give an overview of GPredict using a simple
example. We then discuss the challenges and explain how we
address them. In Fig. 2, there are two threads ( T1andT2)
accessing a shared collection. T1Ô¨Årst initializes the collection
with an item A, then it forks T2and iterates over the collection.
InT2, it Ô¨Årst adds item Bto the collection, then iterates over
the collection. This program, although intuitive, may throw
aConcurrentModificationException because when
T1is iterating over the collection, T2might simultaneously
update the collection, which breaks the contract of Java Itera-
tors. Suppose our problem here is to detect this error. A classic
solution is through runtime veriÔ¨Åcation, such as MOP [8], that
allows the users to specify the safe iterator property using
speciÔ¨Åcation formalisms, and automatically generates monitors
to detect violations of the property at runtime. However,
since the error depends on the thread schedule to manifest,
which is non-deterministic, conventional runtime monitoring
approaches may not detect it.
From a high level view, GPredict addresses this problem
by analyzing the causal ordering relation between events
observed at runtime with a constraint model. We give each
event (including both property events and model events) an
order variable representing its order in the schedule of a
possible feasible execution and use these order variables to<GPredict SpeciÔ¨Åcation >::=<Property Name >\("<Parameters>\)" \f"<Event>*<Pattern>\g"
<Event> ::= \ event "<Id><AspectJ AdviceSpec >\:"<AspectJ Pointcut >
<Pattern> ::= \ pattern : " (<RegExp>‚Äú||‚Äù)<RegExp>
<Property Name > ::=<IdentiÔ¨Åer>
<Parameters> ::= (<Type><IdentiÔ¨Åer>)+
<Id> ::=<IdentiÔ¨Åer>
<AspectJ AdviceSpec > ::= AspectJ AdviceSpec syntax
<AspectJ Pointcut > ::= AspectJ Pointcut syntax
<Thread> ::=<IdentiÔ¨Åer>
<AtomRegion > ::=<IdentiÔ¨Åer>
<IdentiÔ¨Åer> ::= Java IdentiÔ¨Åer syntax
<Begin> ::= ‚Äú<‚Äù<AtomRegion >
<End> ::= ‚Äú>‚Äù<AtomRegion >
<RegExp> ::= Regular expression over f<Id>,<Id>‚Äú(‚Äù<Thread>,<Begin>j<End>‚Äú)‚Äùg
Fig. 1. GPredict property speciÔ¨Åcation language. The new syntax introduced for concurrency properties is highlighted in gray color.
formulate the property violation. For example, let Oidenote
the order of the event at line i. A violation of the safe iterator
property can be formulated as O3<O 5<O 4. Similarly, the
causal ordering constraints between events can be modeled
asO1< O 2< O 3< O 4^O5< O 6< O 7(to respect the
program order, e.g.,O1<O 2means line 1 must happen before
line 2) andO2<O 5(to respect the synchronization semantics,
e.g., line 5 can only happen after line 2, because T2is forked at
line 2). Conjuncting all these constraints, GPredict invokes an
SMT solver ( e.g., Z3 [11]) to solve them. If the solver returns
a solution, it means that there exists a schedule that violates
the property. Moreover, such a schedule represents a witness to
the property violation, and can be deterministically replayed
to manifest the error. Back to our example, the solver may
returnO1=1,O2=2,O3=3,O4=5,O5=4,O6=6,O7=7, which
corresponds to the property violating schedule 1-2-3-5-4-6-7.
Although our technique can be easily illustrated, there are
several challenges we must tackle:
1)Property speciÔ¨Åcation. How to specify the properties?
What type of formalisms can we support? How to specify
conventional concurrency errors as well, such as races,
atomicity violations, deadlocks, etc?
2)Property encoding. How to encode the constraints for
parametric properties? For example, in Figure 2 both line
4 and line 7 access an iterator of the collection, but on
different instances; if we ignore this difference, we might
formulate the property as O3< O 5< O 7instead of
O3< O 5< O 4, which would result in missing the real
property violation.
3)Soundness1(i.e. No-false-positive). How to guarantee that
every property violation we detect is real? For example,
if there exists certain causal order not modeled by our
constraints, the detected property violation might be false.
In the rest of this section, we focus on discussing the Ô¨Årst
two issues. We present a formal constraint modeling of our
sound causal model to address the third issue in Section III.
1Bysoundness we mean no-false-positive in this paper.
UnsafeIterator (Collection c, Iterator i) {    event create after(Collection c) returning(Iterator i) :               call(Iterator Collection+.iterator()) && target(c);    event update after(Collection c) :               (call(* Collection+.remove*(..))               || call(* Collection+.add*(..)) ) && target(c);    event next before(Iterator i) :               call(* Iterator.next()) && target(i);    pattern: create next* update+ next}Fig. 3. UnsafeIterator property speciÔ¨Åcation
B. Generic property speciÔ¨Åcation
GPredict allows specifying properties using regular expres-
sions (RegExp). We choose RegExps as they are natural and
convenient to reÔ¨Çect the ordering relation between property
events. Nevertheless, our technique should work with any
formalism whose properties/formulae can be monitored using
Ô¨Ånite-state machine monitors ( e.g., linear temporal logic).
Fig. 1 shows the syntax of our property speciÔ¨Åcation
language. It is an extension of the MOP speciÔ¨Åcation [8],
consisting of the property declaration (name and parameters),
a list of event deÔ¨Ånitions, and a formula specifying the
property. The event syntax makes use of AspectJ, containing
an identiÔ¨Åer, an advice (with no body), and a pointcut. The
property is then deÔ¨Åned in terms of the event identiÔ¨Åers using
RegExp. Fig. 3 shows an example of the UnsafeIterator
property in our speciÔ¨Åcation. The property is parameterized
by a collection and an iterator. There are three types of events
deÔ¨Åned in the speciÔ¨Åcation: create (creating an iterator i
of the collection c),update (adding or removing an item
to/from the collection), next (iterating over the collection via
calling next() on the iterator). The formula of the property
violation pattern is written as create next *update+
next , meaning that the property is violated if an update
event can happen after create and before a next . Events
in this pattern are parameterized by candias deÔ¨Åned in the
speciÔ¨Åcation.AtomicityViolation (Object o){    event begin before(Object o): execution(m());    event read before(Object o): get(* s) && target(o);    event write before(Object o): set(* s) && target(o);    event end after(Object o): execution(m());    pattern: begin(t1,<r1) read(t1) write(t2) write(t1) end(t1,>r1)}Fig. 4. Atomicity violation property speciÔ¨Åcation
T1T2   m()   r1 = s;  r2=r1+1;  s= r2;1:2:3:m();m();m();4:5:6:
Fig. 5. An example of atomicity violations
To explicitly support concurrency related properties, a major
difference of our speciÔ¨Åcation from MOP is that in the
property formula, the event identiÔ¨Åers are also allowed to bind
with thread attributes and begin/end of atomic regions, in the
form of<Id>(<Thread>,<Begin>j<End>). The<Thread>
attribute denotes a meta ID of the thread performing the
corresponding event, such that events bound with different
<Thread>attributes are by different threads. The <Begin>
and<End>attributes are written as ‚Äú <‚Äù<AtomRegion >and
‚Äú>‚Äù<AtomRegion >, denoting the begin and end of an atomic
region identiÔ¨Åed by <AtomRegion >.
Fig. 4 shows an example of the read-write-write
atomicity violation written in our speciÔ¨Åcation language that
uses these attributes. The atomicity violation is concerned
with three accesses to a shared variable sby two threads,
which can be declared as read andwrite events using the
get andset pointcuts. The begin andend events mark
the beginning and ending of the execution of a method m,
which is considered to be atomic. In the formula, to distin-
guish events by different threads, we bind each event with a
thread attribute, e.g.,read(t1) andwrite(t2) . To match
begin withend, they are written as begin(t1,<r1) and
end(t1,>r1) , ensuring that these two events are marking
the same atomic region (denoted by a meta ID r1). The whole
formula is then written as begin(t1,<r1) read(t1)
write(t2) write(t1) end(t1,>r1) , denoting that
the violation occurs if the two read andwrite events inside
an atomic region marked by the begin andend events
of any thread t1, can be interleaved by a write event
from a different thread t2. Fig. 5 shows a simple program
with such atomicity violations. Note that the speciÔ¨Åcation of
atomic regions in our language is general and can be speciÔ¨Åed
by arbitrary events and their orders, which is much more
expressive than conventional atomic regions that are limited
to synchronization methods or blocks.
In addition, we introduce a new notation ‚Äú ||‚Äù in our
speciÔ¨Åcation language, which is used to denote the parallelism
between events. For example, <Id1>||<Id2>means that
the two events <Id1>and<Id2>can be executed in parallel,
with no causal ordering between each other. This notation is
useful for specifying a range of interesting properties, e.g., data
DataRace (Object o) {    event read before(Object o): get(* s) && target(o);    event write before(Object o): set(* s) && target(o);    pattern: read(t1) || write(t2)}Fig. 6. Data race property speciÔ¨Åcation
races. Fig. 6 shows the speciÔ¨Åcation of a read-write data race
property on a shared variable s. The property is parametrized
by the object instance of sto distinguish different memory
locations. The read event is declared as a get pointcut,
and the write event as set. The formula is then written as
read(t1) || write(t2) , meaning that the two events
by two different threads can happen in parallel.
C. Property encoding
Recall Fig. 1 that properties are written as RegExp patterns
over the alphabet of the declared event identiÔ¨Åers. Since the
events are deÔ¨Åned with pointcuts, which can be triggered
multiple times in the execution, each declared event may
correspond to multiple event instances in the execution. We
shall refer to such event instances as property events.
Consider the order of each event identiÔ¨Åer in the RegExp
patterns. For the pattern to be satisÔ¨Åed, there must exist a
corresponding ordered sequence of property events such that
each event matches with the corresponding event identiÔ¨Åer.
In other words, the pattern actually speciÔ¨Åes the ordering
constraints between property events, which can be directly
modeled by their corresponding order variables. To model the
constraints speciÔ¨Åed in the pattern, however, we must address
the following important problems:
1) Property events must be parametric; how to handle the
parametricity?
2) An event identiÔ¨Åer may have multiple matching property
events; how to encode the constraints for all?
3) Our pattern allows the RegExp quantiÔ¨Åers (‚Äú ?‚Äù, ‚Äú*‚Äù,
‚Äú+‚Äù), as well as negation ‚Äú !‚Äù, boolean logics ‚Äú _‚Äù and
‚Äú^‚Äù, and grouping parentheses ‚Äú ()‚Äù, and supports the
bindings of thread attributes, atomic regions, and the
parallel notation ‚Äú ||‚Äù; how to handle all these features?
1) Parametricity: For parametric property events, the key
is to bind the property parameters to concrete object instances.
Each binding corresponds to a different property instance, and
we construct a separate constraint. Constraints of all property
instances can then be combined together by disjunction ( _).
To create the bindings for each instance, we enumerate the set
of object instances corresponding to each parameter associated
with the property events. For each object instance, we create
a separate binding to the corresponding parameter. By joining
the bindings for all parameters in the property, we can create
the bindings for all property instances. The total number of
bindings is a multiplication of the number of object instances
for each parameter. Back to our example in Fig. 2, there is
only one binding to the Collection parameter, c, and two to theIterator parameter, i1andi2; hence, there are two parametric
bindings in total: ( c,i1) and (c,i2).
2) Multiple event instances: For each event identiÔ¨Åer in
the pattern, since the existence of one such property event is
sufÔ¨Åcient to witness the property violation, if there are multiple
events corresponding to an identiÔ¨Åer, it seems intuitive to
pick any one to build the constraint. However, this naive
approach may miss predictable property violations, because
the constraint with respect to the chosen event might not be
satisÔ¨Åed, while there might exist other events that are not
chosen that can manifest the property violation. To address
this issue, similar to parametric bindings, we enumerate the
corresponding events per property instance that match with
the event identiÔ¨Åer in the pattern. For each property event,
we create a separate ordering constraint and disjoin them.
In this way, no property violation will be missed. Back to
our example, for the property instance ( c,i1), there exist two
update events (at lines 5 and 1, respectively), so we construct
the disjunction O3< O 1< O 4_O3< O 5< O 4. Although
O3< O 1< O 4cannot be satisÔ¨Åed (because line 1 must
happen before line 3), O3< O 5< O 4can, so the property
violation can still be detected.
3) RegExp pattern constructs: Taking the RegExp pattern
as input, we Ô¨Årst preprocess it to handle quantiÔ¨Åers (‚Äú *‚Äù,
‚Äú+‚Äù, ‚Äú?‚Äù). For ‚Äú ?‚Äù, we replace it by ‚Äú |‚Äù, meaning that one
or zero of its preceding event identiÔ¨Åer may appear in the
pattern. For ‚Äú *‚Äù and ‚Äú +‚Äù, because both of them can denote an
inÔ¨Ånite number of events, to avoid exploding the constraints,
we remove ‚Äú *‚Äù and its associated event identiÔ¨Åer or identiÔ¨Åers
from the pattern (because ‚Äú *‚Äù can denote zero event), and
remove ‚Äú +‚Äù from the pattern (because ‚Äú +‚Äù can denote one
event). For example, the UnsafeIterator pattern in Fig. 3
‚Äúcreate next *update+ next ‚Äù is processed to ‚Äú create
update next ‚Äù. This treatment, however, may result in
missing certain violations. We expect this is acceptable since
GPredict is used for predicting if a property can be violated
or not. The number of violations is less important. In fact,
we may simply exclude ‚Äú *‚Äù and ‚Äú +‚Äù from the speciÔ¨Åcation.
We choose not to, so that existing MOP properties can be
supported without any change.
In constructing the constraints, we handle ‚Äú !‚Äù, ‚Äú_‚Äù, ‚Äú^‚Äù,
‚Äú||‚Äù, and ‚Äú ()‚Äù as follows. For ‚Äú !‚Äù, we add a negation
(i.e., a logicalnot) to the corresponding constraint. Note that
‚Äú!‚Äù may conÔ¨Çict with our treatment to ‚Äú *‚Äù and ‚Äú +‚Äù, which
results in over-approximation when ‚Äú !‚Äù and ‚Äú *‚Äù (or ‚Äú +‚Äù) are
used together in the pattern. To avoid this issue, we disallow
such patterns in our speciÔ¨Åcation. For ‚Äú _‚Äù and ‚Äú^‚Äù, we take
them as disjunction and conjunction, respectively, between the
corresponding constraints. For ‚Äú ||‚Äù, we create an equality
constraint between the order variables of the two events2. For
example, for the data race speciÔ¨Åcation in Fig. 6, for any pair
of such property events eijjej, we add the equality constraint
Oi=Oj. For parentheses ‚Äú ()‚Äù that embrace thread attributes
and atomic regions, we handle them as follows.
2Currently, we only support ‚Äú ||‚Äù for two parallel events.For thread attributes, similar to the treatment of parametric
bindings, we Ô¨Årst group the corresponding events by their
thread ID, and then enumerate each group. During enumer-
ation, the only condition is that events with different thread
attributes must be bound to different groups of events. For
example, consider the example in Fig. 5 with the data race
pattern ‚Äú read(t1)||write(t2) ‚Äù, we can bind both t1
andt2to either T1orT2, but they cannot be simultaneously
bound to the same thread. The constraints of different groups
are then combined together by disjunction.
For atomic region attributes, note that we must match
each<Begin>event with its corresponding <End>event;
otherwise, it might lead to false alarms. Taking Fig. 5 as an
example. Suppose we change the method mto be synchro-
nized, then there is no atomicity violation. However, since m
is called twice by thread T1, there are two begin and two
end events by T1; if the Ô¨Årst begin is matched with the
second end, then the ordering of events can still be satisÔ¨Åed
when T2calls mbetween the two calls of mbyT1, which
is not a real atomicity violation. Hence, to maintain a correct
match, we preprocess all events with atomic region attributes.
Because all such events are always nested, we can simply use
a stack to keep track of the current active atomic region, and
match each <Begin>with the correct <End>. We assume
the speciÔ¨Åed RegExp pattern is consistent, and currently we
do not perform any static checking for it. Otherwise, if the
pattern is inconsistent, no violation will be predicted.
III. C ONSTRAINT MODELING
Several previous work [36], [13], [27], [18] have used Ô¨Årst-
order logical SMT formulae to model the ordering constraints
between events. Our constraint modeling of the causal model
extends our prior work [18], with the main improvement that
it is built upon the thread-local traces instead of a global trace.
We consider the following types of model events:
begin (t)/end(t): the Ô¨Årst/last event of thread t;
read(t;x;v )/write(t;x;v ): read/write a value von a
shared variable x;
lock(t;l)/unlock (t;l): acquire/release a lock l;
fork(t;t0)/join(t;t0): fork a new thread t0/block until
threadt0terminates;
wait(t;l;g): a composition of three consecutive events3
unlock w(t;l)-wait(t;g)-lock w(t;l): Ô¨Årst release lock l,
then block until receiving signal g, Ô¨Ånally acquire l;
notify (t;g)/notifyAll (t;g): send a signal gto wake up a
waiting thread/all waiting threads.
From a high level view, taking the model events by each
thread as input, we encode all the necessary ordering con-
straints between model events as a set of Ô¨Årst-order logic
formulae. The whole formula, , is a conjunction of three
sub-formulae over the order variables of the model events:
 =  mhb^sync^rw
3In this work, we do not model spurious wakeups, which happen rarely in
practice and are typically handled by enclosing wait in loops.A. Must happens-before constraints ( mhb)
The must happens-before (MHB) constraints capture the
causal order between events that any execution of the pro-
gram must obey. Let denote the smallest transitively-closed
relation over the events in the observed execution such that
for any two events eiandej,eiejholds if one of the
following holds:
Program Order: eiandejare by the same thread, and ei
occurs before ej.
Fork Order: ei=fork(t;t0)andej=begin (t0).
Join Order: ei=end(t)andej=join(t0;t).
For each MHB relation eiej, we add a conjunction of
the constraint Oi<Ojtomhb. The size of mhbis linear in
the total number of model events.
B. Synchronization Constraints ( sync)
The synchronization constraints capture the locking and
wait-notify semantics introduced by synchronization events:
lock,unlock ,wait,notify , and notifyAll . Recall the seman-
tics that a wait(t;l;g)event can be split into three events:
unlock w(t;l)-wait(t;g)-lock w(t;l). Hence, we divide each
lock region enclosing wait into two smaller lock regions. sync
is constructed as a conjunction of two constraints:
Locking constraints (lock) For each lock l, we Ô¨Årst extract
a setSof all the ( lock,unlock ) pairs onl(including unlock w
andlock wfrom the wait events), following the program order
locking semantics, i.e., anunlock event is paired with the most
recent lock event on the same lock by the same thread. We
then add the following constraint to lock:
^
(a;b)6=(a0;b0)2S(Ob<Oa0_Ob0<Oa)
The size of lockis quadratic in the number of lock regions.
Wait-notify/notifyAll constraints (signal ) The core prob-
lem of constructing signal is to Ô¨Ånd, for each wait event, a
matching notify ornotifyAll event that can send the correct
signal to wake it up. In previous predictive trace analysis
work [15], [16], [18], [36], [27], this task is easy, because
a global trace is available and each wait can be simply
matched with the most recent notify ornotifyAll event with
the same signal. However, this problem becomes challenging
when we have only the thread-local traces, where there is
no causal ordering information between wait/notify /notifyAll
events across different threads. For example, we cannot match
await with an arbitrary notify , because the notify might happen
after the wait, or it might have been matched with another wait.
We develop a sound constraint model that addresses this
issue. Our key observation is that wait and notify /notifyAll
events are always executed inside a lock region. For a wait(t1;
l;g)to match with a notify (t2;g), suppose the enclosing
lock regions of wait(t;l;g)and notify (t2;g)are marked by
lock(t1;l)/unlock (t1;l)and lock(t2;l)/unlock (t2;l), respec-
tively, it must hold that the unlock w(t1;l)event must happen
before lock(t2;l). Otherwise, notify (t2;g)would happen be-
fore unlockw(t;l)and the signal would be lost. Meanwhile,for all the other wait events, they must be either before
lock(t2;l)or after unlock w(t1;l). Otherwise, notify (t2;g)
might be matched with more than one wait event.
SpeciÔ¨Åcally, let XandYdenote the set of wait andnotify
events on the same signal. For each wait(t;l;g)eventw, let
Oul
w,Ow, andOl
wdenote the corresponding order variables
ofunlock w(t;l),wait(t;g)andlock w(t;l), respectively, and
letOle/Ouledenote the order variables of the lock/unlock
events of the enclosing lock region of a wait ornotify event
e.signal forwis written as follows:
_
w2X;n2Y(Oul
w<Oln^On<Ow^
w6=w02X(Oulw<Ol
w0_Oulw0<Oln))
The constraint model for wait-notifyAll is similar, except
that the conjunction over the other wait events inXis not
needed, because a notifyAll event can be matched with multiple
wait events. The total size of signal is2jXj2jYj, which is cubic
in the number of wait/notify /notifyAll events.
C. Read-write constraints ( rw)
The read-write constraints ensure the data-validity of events:
a read must read the same value as that in the observed
execution, though it may be written by a different write.
SpeciÔ¨Åcally, for each property event p, we add a constraint
rw(p)torw.rw(p)is constructed over a set, R, containing
all the read events that must happen-before ( ) it. For each
read(t;x;v )inR, letWdenote the set of write(;x;)events
in the trace (here ‚Äò ‚Äô means any value), and Wvthe set of
write(;x;v)events. rw(p)is written as:
^
8w2Wvrw(w)^Ow<Or^^
8w02WOw0<Ow_Ow0>Or
The constraints above state that the read event, r, may read
the valuevonxwritten by any write event, w=write(;x;v),
inWv(which is a disjunction), with the constraint that the
order ofwmust be smaller than the order of r, and there is
no other write(;x;)event that is between them. Moreover,
thiswrite(;x;v)event itself must be feasible, so we add a
conjunction of the constraint rw(w).
The size of rwis cubic in the number of read andwrite
events. Nevertheless, in practice, rwcan be signiÔ¨Åcantly
reduced by considering the MHB relation . For example,
consider two write eventsw1andw2inWv. Ifw1w2r,
we can exclude w1fromWvbecause it is impossible for r
to read the value written by w1due to mhb. Similarly, for
anyw02W, ifrw0, thenw0can be excluded from W.
Also, when constructing the constraints for matching an event
w2Wvtor, ifw0w, thenw0can be skipped.
D. Soundness
The next theorem states that our constraint modeling based
on the thread-local traces is sound:
Theorem 1. captures a sound causal model, i.e., any
solution to represents a feasible schedule.
Proof. (Sketch) It‚Äôs clear that mhbandrwcapture the data
and control dependencies for every event in the trace. TheT1T2lock(l)...unlock_w(l)wait(g);lock_w(l);...unlock(l);x1:x2:x3:x4:x5:T3lock(l)...unlock_w(l)wait(g);lock_w(l);...unlock(l);y1:y2:y3:y4:y5:lock(l)...notify(g);...unlock(l);z1:z2:z3:
x2<z1 & z2<x3 & (x5<y4 | y5<z1)&& y2<z1 & z2<y3 & (y5<x4 | x5<z1)x1<x2<x3<x4<x5 & y1<y2<y3<y4<y5 & z1<z2<z3(x1>y2 | x2<y1) & (x1>y5 | x2<y4) & (x1>z3 |x2<z1) & (x3>y2 | x4<y1) & (x3>y5 | x4<y4) & (x3>z3 |x4<z1) & (y1>x5 | y2<x4) & (y1>z3 |y2<z1) & (y4>x5 | y5<x4) & (y4>z3 |y5<z1)MHBconstraintLockingconstraintsWait-notifyconstraintsFig. 7. Example of synchronization constraints
only less obvious part is the thread synchronization constraints
captured by sync. Let‚Äôs use an example in Fig. 7 to show the
soundness of sync. For simplicity, we use the label to the left
of each event to refer to both the event and its order variable. In
the example program, both threads T1andT2perform a wait
within a lock region ( x1/x5andy1/y5respectively) on lock l,
andT3performs a notify (z2) within a lock region ( z1/z3) on
the same lock. Following the semantics of wait, the wait events
ofT1andT2are split into six events (denoted by x2-x3-x4
andy2-y3-y4, respectively). Hence, there are Ô¨Åve lock/unlock
pairs in the trace. Our locking constraints (shown in the Ô¨Ågure)
enforces that every two lock/unlock pairs by different threads
cannot overlap. Clearly, mutual exclusion is ensured. For wait-
notify, note that there is only one notify event but two wait
events, either the wait event of T1or of T2can be matched
with the notify event, but not both. Following our construction
ofsignal, our constraints for the two wait events are written
asx2< z1^z2< x3^(x5< y4_y5< z1)and
y2< z1^z2< y3^(y5< x4_x5< z1). By analyzing
the conjunction of these two constraints, we can see that it
contradicts with the locking constraints. Hence, signal cannot
be satisÔ¨Åed, which ensures the semantics that a notify cannot
be matched with more than one wait event.
IV. I MPLEMENTATION
We have implemented GPredict for Java programs based on
JavaMOP [8] and Soot [22]. Fig. 8 shows an overview of the
GPredict infrastructure. Taking the target program (Java byte-
code) and the property speciÔ¨Åcation as input, GPredict Ô¨Årst
adds necessary instrumentation into the program for logging
the model events during execution, and uses JavaMOP‚Äôs front-
end parser to produce a corresponding AspectJ Ô¨Åle for the
property. During program execution, the AspectJ Ô¨Åle is weaved
into the instrumented program to emit the property events. All
events are logged and grouped by their thread ID, and saved
into database together with the property pattern. Then taking
the logged information as input, the ofÔ¨Çine analyzer constructs
the necessary constraints and invokes an SMT solver to solve
them. A property violation is reported if the solver returns a
solution. We next present each of the components in detail.
propertiesJavaMOPprogramInstrumentorT raceCollector.ajConstraintBuilderSMTSolverviolationsFig. 8. Overview of GPredict architecture
Instrumentation This phase consists of two parts. The Ô¨Årst
part takes in the target program, and performs the instru-
mentation on Jimple, an intermediate representation of Java
bytecode in the three-address form [22]. The instrumented
events include read and write accesses to shared data such as
instance Ô¨Åelds and class variables, entry and exit to monitors
and synchronized methods, wait and notify/notifyAll method
calls, and thread fork and join. The second part is parsing
the property speciÔ¨Åcation. Since our speciÔ¨Åcation language
is adapted from MOP, we make use of JavaMOP parser to
produce an AspectJ Ô¨Åle with each declared event converted
into a corresponding pointcut. The aspects are then weaved
into the instrumented program dynamically to emit both the
model events and property events at runtime.
Trace Collection For each model event, we log the runtime
data as described in Section III, such as the thread ID, the
memory address, the read or write value, etc. The logging
of property events is slightly different. Recall Section II-C1
that for parametric properties, we need to group events into
different property instances according to the runtime object of
the event. Instead of performing this grouping task ofÔ¨Çine,
we do it online by reusing the monitoring mechanism of
JavaMOP. SpeciÔ¨Åcally, JavaMOP internally creates a separate
monitor for each property instance, and matches each event
to all the related monitors. Hence, we simply insert a logging
method call in each monitor function and save the property
event associated with the monitor ID (which is equivalent
to the property instance) into database. During constraint
construction, we can directly use the monitor ID to identify
each property instance without grouping the events again.
In order to reduce the runtime overhead, remember that our
technique does not collect a global trace but the events for
each thread separately. We maintain for each thread a thread-
local buffer for storing the events performed by itself. Once
a new event is created by a thread, we add it to the thread‚Äôs
local buffer. At the end of the logging phase, all events are
saved into database indexed by the thread ID.
Constraint Construction and Solving The constraint con-
struction follows the algorithms in Section II-C (for property
constraints) and Section III (for model constraints). It is worth
noting that our constraint model is very extensible. It is not
limited to a single property, but multiple properties can be en-
coded simultaneously. For instance, the UnsafeIterator
property can be encoded together with the data race patterns
by a disjunction. For solving the constraint, we use Z3 [11] in
our implementation and set the timeout to Ô¨Åve minutes. Note
that almost all of our constraints are ordering constraints ( i.e.,
comparing two integer variables by ‚Äú <‚Äù), which can be efÔ¨Å-public void addChangeListener(SeriesChangeListener listener) {        this.listeners.add(listener);}public void Ô¨ÅreSeriesChanged() {        notifyListeners(new SeriesChangeEvent(this));} protected void notifyListeners(SeriesChangeEvent event) {        Iterator iterator = listeners.iterator();        while (iterator.hasNext()) {            SeriesChangeListener listener = (SeriesChangeListener) iterator.next();           listener.seriesChanged(event);}}Fig. 9. JFreeChart bug#1051
ciently solved by the Integer Difference Logic (IDL). The only
exception is the equality constraints ( i.e.,Oi=Oj) encoded
for ‚Äú||‚Äù in the property speciÔ¨Åcation. For such constraints,
we simply Ô¨Ålter them out by replacing all occurences of Oi
in the constraints by Oj.
V. E VALUATION
We have evaluated GPredict on a set of real concurrent pro-
grams with both generic properties and conventional concur-
rency errors written in our speciÔ¨Åcation language. Moreover,
to assess the improved runtime performance of GPredict over
previous techniques by using thread-local traces, we have
runGPredict with a set of DaCapo [6] benchmarks and
compared its performance with the approach of logging global
traces. This section presents our results. All experiments were
conducted on a 8-core 3.50GHz Intel i7 Linux machine.
A. Effectiveness
We have applied GPredict to six programs:
Derby ,H2,JFreeChart ,Jigsaw , and two
JDK libraries and examined properties including
UnsafeIterator , NullPointer Dereference ,
UnsafeDatabaseAccess ,Check-Then-Act , as well
as data races, atomicity violations, and deadlocks. The results
(shown Table 1) demonstrate that GPredict is effective in
expressing properties and predicting violations.
1) UnsafeIterator: Fig. 9 shows a real bug violating
the UnsafeIterator property (as explained in
Section II-B) in JFreeChart [1]. When the two methods
addChangeListener and fireSeriesChanged
are called concurrently by different threads, a
ConcurrentModificationException may be thrown.
The reason is that in fireSeriesChanged an arraylist of
listeners are iterated to notify the SeriesChangedEvent ,
while new listeners can be added to the arraylist from
addChangeListener concurrently. This error is common
in concurrent programs, however, as it is neither a data
race nor an atomicity violation, it cannot be detected by
conventional race or atomicity violation detectors.
With GPredict , it is fairly easy to specify the
UnsafeIterator property (as shown in Fig. 3) and
to predict violations. Based on a normal run of the test driver
class TableDescriptorpublic String getObjectName() {       if(referencedColumnMap ==null) {...}       else {             if(referencedColumnMap.isSet(...)){...}       }}public void setReferenceColumnMap(..) {       referencedColumnMap=null;}NullPointerDereference (Object o) {    event deRef before(Object o):              get(TableDescriptor.referenceColumnMap)&&target(o);    event setNull before(Object o, Object value):              set(* TableDescriptor.referenceColumnMap)                 && target(o)&&args(value)&&if(value==null);    pattern: deRef(t1) || setNull(t2)}Derby bug #2861Fig. 10. Null-pointer dereference speciÔ¨Åcation
provided in the bug repository (which does not manifest
the bug), GPredict captured 90 property events and 140
model events and predicted 20 violations within a second.
We manually inspected all these violations and empirically
conÔ¨Årmed that these 20 violations were all real. Note that
each violation is unique with respect to the event sequences
deÔ¨Åned in the property. We did not further prune redundant
violations with the same event signature.
2) Null-Pointer Dereferences: Null-pointer dereference er-
rors are common in multithreaded programs. Though they are
not unique to concurrency, they are much harder to detect in
multithreaded programs. Fig. 10 shows the concurrency bug
#2861 in Apache Derby [2]. This bug is concerned with a
thread safety issue in the TableDescriptor class. The
shared data referencedColumnMap is checked for null
at the beginning of the getObjectName method and later
dereferenced if it is not null . Due to an erroneous inter-
leaving, another thread can set referencedColumnMap
tonull in the setObjectName method and causes the
program to crash by throwing a NullPointerException .
This bug is in fact an atomicity violation, but it can be
speciÔ¨Åed more intuitively as a null-pointer dereference. Users
need only to declare two events, deRef andsetNull ,
on the variable referencedColumnMap , and specify the
pattern as deRef(t1)||setNull(t2) , meaning that the
two events are from different threads and can be run in
parallel. Because deRef is declared as an event on derefer-
encing referencedColumnMap , and setNull an event
setting referencedColumnMap tonull on the same
TableDescriptor object (represented by the property pa-
rametero), a null-pointer dereference can happen if the pattern
is satisÔ¨Åed. We ran GPredict on Derby with this property.
GPredict collected a trace with around 12K model events and
27 property events, and found 5 violations in 5s.
Note that although our speciÔ¨Åcation in this exam-
ple (Fig. 10 bottom) only concerns about the Ô¨Åeld
referencedColumnMap , it could be written for arbitraryTABLE I
EXPERIMENTAL RESULTS
Program LOC Property #Threads #Model events #Property events #Violations Time
jfreechart 51k UnsafeIterator 21 140 90 20 0.85s
h2 136k UnsafeDatabaseAccess 5 112 14 16 0.67s
derby1 302k NullPointerDereference 3 12527 27 5 4.7s
derby2 368k Check-Then-Act 3 19889 1325 4 8.5s
jigsaw 101k Data race 12 17089 38 29 17.6s
stringbuffer 358 Atomicity violation 3 58 6 2 0.4s
jdk-logger 2587 Deadlock 2 509 61 1 2.6s
UnsafeDatabaseAccess(Connection conn, String table) {    event open after() returning(Connection conn):        call(Connection DriverManager.getConnection(String));    event close before(Connection conn):        call(void Connection.close())&&target(conn);    event create before(Connection conn, String table):        call(* createTable(Connection conn, String table))&&args(conn,table);    event delete before(Connection conn, String table):        call(* deleteTable(Connection conn, String table))&&args(conn,table);    event update before(String table, String sql):        call(boolean Statement.execute(String))        &&args(sql)&&if(sql.contains(table));    pattern : !(open create update delete close)}
Fig. 11. Unsafe database access speciÔ¨Åcation
orallreference Ô¨Åelds. If the user wants to detect allnull-
pointer dereferences, she can simply replace the parameter of
the get/set pointcuts with a wild card ‚Äú *‚Äù. In that case, our
algorithm will enumerate all Ô¨Åelds.
3) UnsafeDatabaseAccess: Database applications typically
follow some safe patterns to access data. For example, an
authenticated connection must be established Ô¨Årst before any
other operation, a table must be created before any update
or query accesses on the table, all operations must Ô¨Ånish
before closing the database connection, etc. There is likely
a bug if the application violates such patterns. Fig. 11 shows
the speciÔ¨Åcation of an UnsafeDatabaseAccess property,
which deÔ¨Ånes Ô¨Åve property events (open connection, cre-
ate table, update table, delete table, and close connection)
over two parameters (the connection and the table name).
The pattern !(open create update delete close)
speciÔ¨Åes that the property is violated when these events happen
in an order different from the written one. The negation symbol
‚Äú!‚Äù is interpreted as a logical not in the property constraints.
TheUnsafeDatabaseAccess property cannot be han-
dled by existing techniques such as serializability violation
detectors [21], [40] (even with event abstraction) or typestate-
based detectors [38], [39], because any violation instance of
this property contains events over multiple objects. In our ex-
periment, we wrote a simple multithreaded client program for
testing the H2 database server with GPredict .GPredict found
16 violations in less than a second based on a trace of the client
program with 112 model events and 14 property events4.
4) Check-Then-Act: Collections are frequently used fol-
lowing the Check-Then-Act idiom: the code Ô¨Årst checks
4As H2 was run in the server model, we did not log its model events.
class GenericLanguageConnectionContextpublic¬†void¬†removeStatement(...) {¬†    Cacheable¬†cachedItem¬†=¬†          statementCache.Ô¨ÅndCached(statement);     if¬†(cachedItem¬†!=¬†null)          statementCache.remove(cachedItem);}CheckThenAct (Map m, Object key) {    event check after(Map m, Object key):              call(* Map+.get(Object))&&target(m)&&args(key);    event act before(Map m, Object key) :               call(* Map+.remove(Object,..))&&target(m)&&args(key,..);    pattern: check(t1) act(t2)+ act(t1)}Derby bug #3786Fig. 12. Check-Then-Act speciÔ¨Åcation
a condition, and then acts based on the result of the con-
dition. However, in concurrent programs, misuse of this
idiom can easily lead to bugs [23]. Fig. 12 shows an-
other bug in Derby [3]. The method removeStatement
Ô¨Årst checks if the statementCache contains a statement,
and if yes it removes the statement by calling the method
remove . To support concurrent accesses, the data structure
for maintaining the statementCache is implemented as
aConcurrentHashMap . However, due to some bad inter-
leaving, more than one thread might still execute the remove
method concurrently, causing an assertion failure eventually.
Fig. 12 (bottom) shows the Check-Then-Act property
in our speciÔ¨Åcation language. In the pattern, the check event
and the second act event are bound to thread t1, and the
Ô¨Årstact event to t2. The pattern means that a violation
happens if two check andact events consecutive in a certain
thread can bracket another act event from a different thread.
GPredict collected a trace of 20K model events and 1.3K
property events, and found 4 violations in around 8s.
5) Races, atomicity violations, and deadlocks: Our tech-
nique also works seamlessly for predicting conventional errors
such as data races, atomicity violations, and deadlocks, without
doing anything speciÔ¨Åc for them. Moreover, these errors can
be speciÔ¨Åed more intuitively with our speciÔ¨Åcation language
by high level events than previous techniques that rely on
checking low level shared data accesses. We have also applied
GPredict to predict data races in Jigsaw and a deadlock
bug [4] in JDK logging package. Due to space limit we omitTABLE II
RUNTIME PERFORMANCE COMPARISON
Program #Threads Base Global GPredict
avrora 4 1.8s 2m20s 2m6s ( -10% )
batik 2 2.1s 2m28s 1m2s ( -58% )
xalan 11 1.7s 6m14s 1m9s ( -82% )
lusearch 10 1.4s 15m17s 3m16s ( -78% )
sunÔ¨Çow 25 1s 19m48s 11m28s ( -42% )
the discussions. All details and more examples can be found
athttp://parasol.tamu.edu/ Àújeff/gpredict/ .
B. Runtime performance
To understand the performance improvement of our tech-
nique, i.e., enabling the use of thread-local traces instead of a
global trace, we quantify GPredict using a set of widely used
third-party concurrency benchmarks from DaCapo (shown in
Table 2). All these benchmarks are real world applications
containing intensive shared data accesses and synchronizations
by concurrent threads. Previous PTA techniques can incur
signiÔ¨Åcant runtime slowdown on these benchmarks because
logging a global trace requires synchronizing every model
event with a global lock protecting the logging data structure.
However, logging thread-local traces allows the recording
computation by different threads to be done in parallel, which
is much cheaper as no extra synchronization is required.
To perform an unbiased comparison, we also implemented
inGPredict the ability of logging global traces, to ensure
the same events are logged at runtime. In our experiment,
we conÔ¨Ågure GPredict to run each benchmark with three
different modes for logging the model events: no loggging,
logging per-thread traces, and logging a global trace. Table
2 shows the results. All data were averaged over Ô¨Åve runs.
Compared with logging a global trace, recording the thread-
local traces incurs signiÔ¨Åcantly less runtime overhead with
respect to the base execution. On average, GPredict reduces
the runtime overhead by 54% for the evaluated benchmarks,
ranging between 10% and 82%. For xalan ,GPredict is
even more than four times faster. Although the overhead of
GPredict is still large (because there is a myriad of model
events to log in these benchmarks), compared to previous
techniques [15], [16], [10], [34], [36], [27] that require logging
a global trace, GPredict signiÔ¨Åcantly improves the runtime
performance of predictive trace analysis. To further reduce the
overhead, we can use static analysis techniques [7], [14] to
eliminate redundant events during instrumentation.
VI. R ELATED WORK
As discussed in Section I, although a large body of pre-
dictive analysis work has been developed [29], [30], [10],
[12], [26], [32], [15], [21], [28], a common difference between
these work and GPredict is that their algorithms are typically
tailored to low-level memory access errors such as data races
and atomicity violations and do not work for the generic
concurrency properties we address in this work. With GPre-
dict, developers are able to specify high-level properties usingaspects and regular expressions and to predict bugs related to
speciÔ¨Åed code regions that are suspected to be buggy.
Besides the speciÔ¨Åcation language, another important con-
tribution of this work is our sound causal model based on
thread-local traces, which is realized with constraints. A few
different causal models have been proposed before [31], [34],
[27], [18], however, all based on global traces rather than local
traces. Our own prior work CLAP [17] also uses thread-local
reasoning to help reproducing bugs. However, the thread-local
concept there is different. In [17], the thread-local control
Ô¨Çow is captured to reconstruct a buggy schedule, whereas our
thread-local tracing in this work is concerned with the model
events ( not control Ô¨Çow ) for building the causal model.
Typestate-based concurrency bug detectors [38], [39] can
also detect high-level program semantics bugs as typestate al-
lows event abstraction. A key limitation is that typestate is non-
parametric and only characterizes single-type or single-object
properties. For example, the UnsafeDatabaseAccess
property in Fig. 11 cannot be expressed with typestate. More-
over, existing detectors [38], [39] can often produce false
alarms because they do not have a sound causal model.
2ndStrike [39] prunes false alarms via re-execution. However,
it may miss real bugs due to the scheduling non-determinism.
Many runtime veriÔ¨Åcation frameworks have been developed
to detect program errors dynamically, such as JavaMOP [8],
PQL [25], Tracematches [5], etc. Users of these frameworks
can specify events and patterns to monitor. When a pattern is
satisÔ¨Åed or violated at runtime, users can provide extra han-
dlers to perform additional function, e.g., to recover from bad
states. Our technique is complimentary to runtime veriÔ¨Åcation,
as it can predict errors by inferring other feasible schedules.
Different from predicting property violations, a few tech-
niques have also been proposed to enforce properties at
runtime. Vaziri et al. [33] develop a language for deÔ¨Åning data-
centric synchronizations over high-level data race patterns, and
generate code to obey the properties at runtime. In our prior
work EnforceMOP [24], we have also developed a language
and runtime system that allows the users to deÔ¨Åne and enforce
general properties for multithreaded programs.
VII. C ONCLUSION
We have presented GPredict , a new predictive trace analysis
technique that works for high-level, more generic concurrency
properties. Our technique advances the state of the art in
three aspects: 1. We develop a general constraint model
that enables uniformly reasoning about the causal ordering
between high-level declarable events in concurrent program
executions. 2. We provide an expressive language to specify
and to predict generic property violations based on existing
constraint solvers. 3. Our technique does not require a global
trace of events as input but only the set of local traces by
each thread. With GPredict , users can specify concurrency
errors more expressively and at the same time predict these
errors with much smaller runtime overhead. Our evaluation
with GPredict on real world applications demonstrates the
effectiveness and the performance of our technique.ACKNOWLEDGMENTS
We would like to thank our anonymous reviewers. This re-
search was supported in part by the NSF grant CCF-1218605,
the NSA grant H98230-10-C-0294, the DARPA HACMS
program as SRI subcontract 19-000222, the Rockwell Collins
contract 4504813093, and the (Romanian) SMIS-CSNR 602-
12516 contract no. 161/15.06.2010.
REFERENCES
[1]http://sourceforge.net/p/jfreechart/bugs/1051/.
[2]https://issues.apache.org/jira/browse/DERBY-2861.
[3]https://issues.apache.org/jira/browse/DERBY-3786.
[4]http://bugs.sun.com/bugdatabase/view bug.do?bug id=
6487638.
[5] Pavel Avgustinov, Julian Tibble, and Oege de Moor. Making trace
monitors feasible. In OOPSLA , 2007.
[6] Stephen M. Blackburn, Robin Garner, Chris Hoffmann, Asjad M. Khang,
Kathryn S. McKinley, Rotem Bentzur, Amer Diwan, Daniel Feinberg,
Daniel Frampton, Samuel Z. Guyer, Martin Hirzel, Antony Hosking,
Maria Jump, Han Lee, J. Eliot B. Moss, Aashish Phansalkar, Darko
Stefanovi ¬¥c, Thomas VanDrunen, Daniel von Dincklage, and Ben Wie-
dermann. The DaCapo benchmarks: Java benchmarking development
and analysis. In OOPSLA , 2006.
[7] Eric Bodden, Laurie Hendren, and Ondrej Lhot ¬¥ak. A staged static
program analysis to improve the performance of runtime monitoring.
InECOOP , 2007.
[8] Feng Chen and Grigore Rosu. Mop: an efÔ¨Åcient and generic runtime
veriÔ¨Åcation framework. In OOPSLA , 2007.
[9] Feng Chen and Grigore Rosu. Parametric and sliced causality. In CAV,
2007.
[10] Feng Chen, Traian Florin Serbanuta, and Grigore Rosu. jPredictor: a
predictive runtime analysis tool for Java. In ICSE , 2008.
[11] Leonardo De Moura and Nikolaj Bj√∏rner. Z3: an efÔ¨Åcient SMT solver.
InTACAS , 2008.
[12] Tayfun Elmas, Shaz Qadeer, and Serdar Tasiran. Goldilocks: a race and
transaction-aware Java runtime. In PLDI , 2007.
[13] Azadeh Farzan, P. Madhusudan, Niloofar Razavi, and Francesco Sor-
rentino. Predicting null-pointer dereferences in concurrent programs. In
FSE, 2012.
[14] Cormac Flanagan and Stephen N. Freund. Redcard: Redundant check
elimination for dynamic race detectors. In ECOOP , 2013.
[15] Jeff Huang and Charles Zhang. PECAN: Persuasive Prediction of
Concurrency Access Anomalies. In ISSTA , 2011.
[16] Jeff Huang, Jinguo Zhou, and Charles Zhang. Scaling predictive analysis
of concurrent programs by removing trace redundancy. TOSEM , 22(1),
2012.
[17] Jeff Huang, Charles Zhang, and Julian Dolby. CLAP: Recording Local
Executions to Reproduce Concurrency Failures. In PLDI , 2013.
[18] Jeff Huang, Patrick Meredith, and Grigore Rosu. Maximal sound
predictive race detection with control Ô¨Çow abstraction. PLDI , 2014.[19] Pallavi Joshi, Mayur Naik, Koushik Sen, and David Gay. An effective
dynamic analysis for detecting generalized deadlocks. In FSE, 2010.
[20] Pallavi Joshi, Chang-Seo Park, Koushik Sen, and Mayur Naik. A
randomized dynamic program analysis technique for detecting real
deadlocks. In PLDI , 2009.
[21] Zhifeng Lai, S. C. Cheung, and W. K. Chan. Detecting atomic-
set serializability violations in multithreaded programs through active
randomized testing. In ICSE , 2010.
[22] Patrick Lam, Eric Bodden, and Laurie Hendren. The soot framework
for Java program analysis: a retrospective, 2011.
[23] Yu Lin and Danny Dig. CHECK-THEN-ACT Misuse of Java Concurrent
Collections. In ICST , 2013.
[24] Qingzhou Luo and Grigore Rosu. EnforceMOP: a runtime property
enforcement system for multithreaded programs. In ISSTA , 2013.
[25] Michael Martin, Benjamin Livshits, and Monica S. Lam. Finding
application errors and security Ô¨Çaws using PQL: a program query
language. In OOPSLA , 2005.
[26] Robert O‚ÄôCallahan and Jong-Deok Choi. Hybrid dynamic data race
detection. In PPoPP , 2003.
[27] Mahmoud Said, Chao Wang, Zijiang Yang, and Karem Sakallah. Gen-
erating data race witnesses by an SMT-based analysis. In NFM , 2011.
[28] Koushik Sen. Race directed random testing of concurrent programs. In
PLDI , 2008.
[29] Koushik Sen, Grigore Rosu, and Gul Agha. Runtime safety analysis of
multithreaded programs. FSE, 2003.
[30] Koushik Sen, Grigore Rosu, and Gul Agha. Detecting errors in
multithreaded programs by generalized predictive analysis of executions.
InFMOODS , 2005.
[31] Traian Florin Serbanuta, Feng Chen, and Grigore Rosu. Maximal causal
models for sequentially consistent systems. In RV, 2012.
[32] Francesco Sorrentino, Azadeh Farzan, and P. Madhusudan. Penelope:
Weaving threads to expose atomicity violations. In FSE, 2010.
[33] Mandana Vaziri, Frank Tip, and Julian Dolby. Associating synchro-
nization constraints with data in an object-oriented language. In POPL ,
2006.
[34] Kahlon Vineet and Chao Wang. Universal causality graphs: A precise
happens-before model for detecting bugs in concurrent programs. In
CAV, 2010.
[35] Chao Wang, Sudipta Kundu, Malay K. Ganai, and Aarti Gupta. Sym-
bolic predictive analysis for concurrent programs. In FM, 2009.
[36] Chao Wang, Rhishikesh Limaye, Malay K. Ganai, and Aarti Gupta.
Trace-based symbolic analysis for atomicity violations. In TACAS , 2010.
[37] Liqiang Wang and Scott D. Stoller. Accurate and efÔ¨Åcient runtime
detection of atomicity errors in concurrent programs. In PPoPP , 2006.
[38] Pallavi Joshi and Koushik Sen. Predictive Typestate Checking of
Multithreaded Java Programs. In ASE, 2008.
[39] Qi Gao, Wenbin Zhang, Zhezhe Chen, Mai Zheng, and Feng Qin.
2ndStrike: Toward Manifesting Hidden Concurrency Typestate Bugs. In
ASPLOS , 2011.
[40] Chang-Seo Park, and Koushik Sen. Randomized active atomicity
violation detection in concurrent programs. In FSE, 2008.