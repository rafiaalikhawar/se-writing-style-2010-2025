Do the Dependency Conflicts in MyProject Matter?
YingWang
NortheasternUniversity
Shenyang,China
wangying8052@163 .comMing Wen
The HongKong University of Science
and Technology
Hong Kong, China
mwenaa@cse.ust.hkZhenwei Liu
NortheasternUniversity
Shenyang,China
lzwneu@163.com
RongxinWu
The HongKong Universityof Science
and Technology
Hong Kong, China
wurongxin@cse.ust.hkRuiWang
NortheasternUniversity
Shenyang,China
jwm080795@163.comBoYang
NortheasternUniversity
Shenyang,China
yb9506@126.com
Hai Yu
NortheasternUniversity
Shenyang,China
yuhai@mail.neu.edu.cnZhiliang Zhu∗
NortheasternUniversity
Shenyang,China
zzl@mail.neu.edu.cnShing-Chi Cheung∗
The HongKong Universityof Science
and Technology
Hong Kong, China
scc@cse.ust.hk
ABSTRACT
Intensive dependencies of a Java project on third-party libraries
can easily lead to the presence of multiple library or class versions
onitsclasspath.Whenthishappens,JVMwillloadoneversionand
shadowstheothers.Dependencyconflict(DC)issuesoccurwhen
theloadedversionfailstocoverarequiredfeature(e.g.,method)ref-
erenced by the project, thus causing runtime exceptions. However,
thewarningsofduplicateclassesorlibrariesdetectedbyexisting
buildtoolssuchas Mavencanbebenignsincenotallinstancesof
duplication will induce runtime exceptions, and hence are often
ignored by developers. In this paper, we conducted an empirical
study on real-world DC issues collected from large open source
projects.WestudiedthemanifestationandfixingpatternsofDC
issues.Basedonourfindings,wedesigned Decca,anautomated
detectiontoolthatassessesDCissues’severityandfiltersoutthe
benignones.Ourevaluationresultson30projectsshowthat Decca
achieves aprecisionof0 .923and recallof0.766indetectinghigh-
severity DC issues. Deccaalso detected new DC issues in these
projects. Subsequently, 20 DC bug reports were filed, and 11 of
them were confirmed by developers. Issues in 6 reports were fixed
withour suggestedpatches.
CCS CONCEPTS
·Softwareanditsengineering →Softwarelibrariesandrepos-
itories;
∗ZhiliangZhuand Shing-Chi Cheung arethe corresponding authorsof thispaper
ACMacknowledgesthatthiscontributionwasauthoredorco-authoredbyanemployee,
contractororaffiliateofanationalgovernment.Assuch,theGovernmentretainsa
nonexclusive, royalty-free right to publish or reproduce this article, or to allow others
to do so, for Government purposes only.
ESEC/FSE ’18, November 4–9, 2018, Lake BuenaVista,FL,USA
©2018 Associationfor Computing Machinery.
ACM ISBN 978-1-4503-5573-5/18/11...$15.00
https://doi .org/10.1145/3236024 .3236056KEYWORDS
Empirical study,thirdpartylibrary,staticanalysis
ACMReference Format:
Ying Wang, Ming Wen, Zhenwei Liu, Rongxin Wu, Rui Wang, Bo Yang, Hai
Yu,ZhiliangZhu,Shing-ChiCheung.2018.DotheDependencyConflictsin
My Project Matter?. In Proceedings of the 26th ACM Joint European Software
Engineering Conference and Symposium on the Foundations of Software Engi-
neering(ESEC/FSE’18),November4–9,2018,LakeBuenaVista,FL,USA. ACM,
NewYork, NY, USA, 12pages.https://doi .org/10.1145/3236024 .3236056
1 INTRODUCTION
ThepopularityoftheJavalanguageleadstothedevelopmentofnu-
merousJavathird-partylibraries[ 69,96]. For example,the Maven
repository [ 43] has indexed over 8 .77 millions Java libraries. These
libraries provide divergent functionalities and are frequently lever-
agedbydeveloperstoimplementnewprojects[ 102].Specifically,
we investigated over 2,000 popular (i.e., over 50 stars or forks) Java
projects that are randomly selected from Github [ 24], and found
that a project directly depends on 14 different libraries on average .
Besides, since adependedlibrary mightdepend onotherlibraries,
a host project would transitively depend on more libraries (e.g., 48
libraries onaveragefor theseinvestigatedprojects).
Suchintensivedependencies onthird-partylibrariescan easily
lead to dependency conflicts in practice. That is, multiple versions
ofthesamelibraryorclassarepresentedontheclasspath.When
multipleclasseswiththesamefully-qualifiednameexistinaproject,
JVM will load one of them and shadow the others [ 95]. If these
classes are not compatible, the program can exhibit unexpected
behaviorswhenitscomponentsrelyontheshadowedones[ 72,82].
Consider the following example. A dependency conflict issue
(i.e.,#DERBY-5429 [21])wasreportedtoproject Apache/Derby .A
Derbydeveloper found that class JVMInfo was included in both
derbyclient.jar andderby.jar .However,ifanolderversionof
derbyclient.jar isspecifiedontheclasspathbefore derby.jar ,
the following error shown in Figure 1 will occur when the method
319
ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA Wang,Wen, Liu, Wu, Wang,Yang,Yu, Zhu, Cheung
javaDump() istriggered.Thisindicatesthatdependencyconflict
issuesmayleadto systemcrashesinpractice.
java.lang.NoSuchMethodError : org/apache/derby/iapi/services/info/JVMInfo.javaDump ()V
at org.apache.derby.iapi.services.context.ContextManage r.cleanupOnError(Unknown Source)
at org.apache.derby.impl.jdbc.TransactionResourceImpl.cl eanupOnError(Unknown Source)
at org.apache.derby.impl.jdbc.EmbedConnection.<init>(Unkn own Source)
at org.apache.derby.jdbc.Driver40.getNewEmbedConnection(U nknown Source)
at org.apache.derby.jdbc.InternalDriver.connect(Unknown S ource)
Figure1: Arealissue #DERBY-5429 causedby dependency conflict
Javaprojectbuildtoolssuchas Maven[43]and Gradle[26],can
warndevelopersofduplicateJARsandclasses,buttheycannotiden-
tifywhethertheduplicationsarebenignorharmful(e.g.,causing
runtimeexceptions).Iftheduplicateclassesareidenticalorcompat-
ible,theprojectrunsnormallyeventhoughithasuncleandesignor
build.Onthecontrary,iftheduplicateclassesareincompatible,the
warningsneedtobecarefullyresolved.Mostbuildingtoolsprovide
theirowndependencymanagementstrategiestohelpdevelopers
select one version of the duplicate classes during the packaging
process [ 75,97]. However, these tools do not guarantee loading
the most appropriate class. Consequently, runtime exceptions will
occurifinappropriateclassesareloaded.Whatisworse,sinceex-
isting tools do not differentiate benign from harmful warnings,
developersmayoverlook theharmfulonesandtake noresolution
actions, whichmightleadto serious consequences.
Adependencyconflictissueariseswhentheloadedclasses are
nottheexpectedonesoftheproject(i.e.,thereferencedfeaturesetof
thetheprojectisnotfullycoveredbytheloadedclasses).Inpractice,
the dependency conflict issues can be manifested in different ways,
dependingonclassloadingmechanisms.However,nosystematic
studies havebeenmade tounderstandthemanifestationpatterns
ofdependencyconflictsandtheseverityoftheseconflicts.Inthis
paper,we firstconductedan empirical study to bridgethisgap.In
particular,wecollected135real-worlddependencyconflictissues
from the Java projects hosted on the Apacheecosystem [ 3] across
16 categories (e.g., big-data, FTP, library and testing), and explored
thefollowingtworesearchquestions.Toeasepresentation,werefer
to the Dependency C onflict issuesas DC issues.
•RQ1 (Issue manifestation patterns): What are the common
manifestationsofDCissues?Aretherepatternsthatcanbeex-
tractedto enable automateddetection oftheseproblems?
•RQ2(Issue fixingpatterns): How do developers fix DC issues
inpractice?Aretherefactorsthataffectdevelopers’choicesof
differentfixing solutions?
Answers to the two research questions enable us to better un-
derstand the characteristics of DC issues between a host project
anditsreferencedthird-party libraries.Specifically,wefoundthat
DCissuessharethreegeneralmanifestationpatterns: conflictsin
libraryversions ,conflictsinclassesamonglibraries ,andconflictsin
classes between the host project and libraries (see Section 3). The
findings provide developers with guidance to help avoid, detect,
anddiagnoseDCissuesautomatically.Besides,byfurtheranalyz-
ing thepatches of thefixed DCissues (128/135), we observed that
there are four common fixing solutions in practice. In addition, by
analyzing the discussions of the corresponding issue reports, we
distilledthekeyinformationtodiagnoseDCissuesaswellasthe
factors affecting the effortsrequiredfor fixing the issues.Basedonthecommonissuemanifestationsandthefixingpat-
ternsrevealedbyourempiricalstudy,wedesignedandimplemented
a DC detection tool using static analysis, Decca(DependEnCy
ConflictsAssessment),tohelpavoiddependencyconflictfailures
at runtime. Specifically, Deccacan assess the severity levels of
DC issues based on their impacts on the project (e.g., whether it
will cause runtime failures) and maintenance costs (e.g., the re-
quired fixing efforts). To evaluate the effectiveness and usefulness
of ourapproach,we first collect a high quality dataset of DCissues
with high and low severity levels. The evaluation results show that
Deccacan achieve a precision of 0.923 and recall of 0.766. More
importantly,weapplied Deccatoanalyzethelatestversionof30
Java projects, which include 9.8 million lines of codes, to see if
itcandetectunknownDCissuesinthefield. Deccasuccessfully
detected 466 DC issues of four different severity levels (defined in
Section4.4)from24projects.Wefurtherfilteredout438benignDC
issuesandreported20bugswhichcontains28harmfulissuestothe
correspondingdevelopers,and11reportedbugs(55%)havebeen
confirmedasrealDCissues,whichaffectstheprojects’reliability
and maintainability. Most of theconfirmed issues are identified in
popular projects such as Apache Spark [54],Hadoop[27],Beam
[13],Google Closure-compiler [25].Moreexcitingly,develop-
ershavequicklyfixed6(55%)ofthembyfollowingoursuggestions.
Theyalsoexpressedgreatinterestsinourtool Decca.Theseresults
showtheusefulnessofourapproach.Insummary,thispapermakes
the following contributions:
•Tothebestofourknowledge,weconductedthefirstempirical
studyonDCissuesinopensourceJavaprojects.Ourfindingshelp
understandthecharacteristicsofDCissuesandprovideguidance
torelatedresearches(e.g.,compatibilityandmaintainability).The
empiricalstudydatasetispubliclyavailableforresearchpurpose.
•We proposed a dependency conflict detection approach based
on the knowledge we learned from our empirical study. It can
automaticallydetectDCissues.Moreimportantly,itcanassess
their severity levels and reduce developers’ efforts by filtering
outthosebenign issues.
•Weimplementedourapproachasanopensourcetool Decca1.
The evaluation results on real world projects confirmed the ef-
fectiveness andpractical usefulnessof our approach.
2 PRELIMINARIES
2.1 Motivation
ToinvestigatethepervasivenessoftheDCproblem,wecollected
2,289JavaprojectsfromGithubandexaminedwhethertheycontain
duplicate JARs or classes using the Maven-Dependency-Plugin
[41]. The above projects were randomly selected based on two
criteria: first, it should have achieved over 50 stars or forks (popu-
larity); second, it is built on Mavenplatform. The results show that
1,457 (63.65%) projects contain the same library of different ver-
sions, 1,003 (43.82%) projects contain duplicate classes in different
libraries. Besides, 954 (41.68%) of projects are affected by both of
theabovetwocases.TheseresultsindicatethatDCproblemisvery
common inpractice.
Dependency conflicts can have serious consequences in prac-
tice. For instance, Apache/Hadoop significantly suffers from the
1link: https://deccadc.github.io/fse18/
320Do the Dependency Conflictsin MyProjectMatter? ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA
DC issues, as mentioned in its issue report #HADOOP-11656 [28].
According to the issue report, Hadoopexposes a variety of third
partylibrariestoitsdownstreamclients(i.e.,thoseprojectsdepend
onHadoop). This caused its downstream users suffering long from
theproblemofdependencyconflicts. Hadoopdevelopershavebeen
always searching for a good solution to resolve these conflicts. For
instance,onedevelopercomplainedaboutthecurrentworkaround:
”Wehavetrieddependencyharmonizationinthepast.Itdoesn’t
work,becausedifferentprojectshavedifferentreleaseschedulesand
differentneeds.Nottomentiondifferentcommunities.Also,projects
likeHBasewant to support multiple versions of Hadoop. This means
thattheyeitherhavetolivewithmixedversionsofthingslike Guava,
Jetty,etc. oragreeto never updatedependencies.”
ThisDCissuehaslastedfor879days(fromMar.2,2015toSep.28,
2017),beforeitwasresolvedbyshading(i.e,renaming)allitsdepen-
denciesintoa UberJar[61]withthehelpof Maven-Shade-Plugin
[44]. However, the workaround affected 176 downstream client
projectsandhas inducedvarioussoftware maintenanceproblems.
Ourabovepreliminarystudyhasshownthepervasivenessand
significanceoftheDCproblem.WhenconflictingJARsaredetected,
existing software build tools, such as Maven, generally adopt an ar-
bitration mechanism to load one of the JARs. However, correctness
is not guaranteed. These tools will also give warnings of duplicate
classes. Due to lack of further analysis, many of these warnings
are false positive results. For example, in our investigated projects,
weobservedthatonly23 .00%oftheDCissuesreportedby Maven
attracted developers’ attention and were fixed within five subse-
quentreleases.Besides,thesetoolsdonotanalyzetheimpactsof
the DC issues on the concerned project and maintenance costs.
Consequently,developersmightmistakenlyoverlookharmful DC
issuesthat leadto systemcrashes.
2.2 Challenges
Motivatedbytheaboveobservations,weaimatdetectingtheDC
warningsandtheirseveritylevelsinthisstudy.Animportantob-
jectiveinourstudyistoassesstheseveritylevelsforthesedetected
DC warnings based on their impacts on the project and their main-
tenancecosts. However, effective detectionand assessmentof DC
issuesneedtoaddressthefollowingtwochallenges.First,themani-
festationsofDCissuesinpracticearediverseandnon-deterministic.
It is because that the manifestation of DC issues depends on the
order in which the JARs are present on the classpath, while the
classpathorderofdependenciesmightdifferacrossdifferentrun-
ningenvironments[ 71].Inaddition,theorderisalsoaffectedbythe
dependency management criteria of software building platforms
(e.g.,Maven, Gradle ).Toaddressthischallenge,weconductedan
empiricalstudytocharacterizethecommonmanifestationpatterns
ofDCissues(seeSection 3).Second,therearenoexistingempirical
evidencesortoolsthatindicatewhichtypesofdependencyconflicts
are more serious than the others. Therefore, even if dependency
conflicts have been manifested, we still do not know how to assess
theseveritylevelsforthem.Toaddressthischallenge,wefurther
analyzed the diverse information of the DC issue reports and their
patches,tounderstandhowtoassesstheirimpactsontheproject
at runtime and what information should be extracted to classify
theirwarning severities (see Section 4).3 EMPIRICAL STUDY
This section aims at answering our proposed research questions
RQ1-2.Inthefollowing,wefirstpresentthedatacollectionprocess
andthen discuss our empirical findings.
3.1 Data CollectionProcess
TounderstandthemanifestationandfixingpatternsofDCissues,
we selected Java open source projects that are built by Mavenfrom
theApacheecosystemasthesubjectsforourempiricalstudydueto
thefollowingreasons.First, Apacheisoneofthemostpopularopen
source software ecosystem and includes different types of software.
The subjects thus selected are representative. Moreover, the use
ofApacheprojectsfor empiricalsoftwareengineeringresearchis
common[ 69,76,79,85,86,89,99,103].Second, Apacheprojectsare
well-maintained.Specifically,theyusethe BugZilla [16]and JIRA
[39]systemstotrackissues.The Apache Software Foundation
provides official support of Git[23] mirrors for all projects. The
issuereportsandcoderepositoriesareopentothepublic,which
greatly facilitates usto study the target problem [ 98].
For the selected Java projects, we identified confirmed DC is-
sues in the issue tracking systems. First, we used the keywords
łlibrary”, łdependency” or łcompatibility”, etc. to narrow the is-
sues down to the compatibility problems between host projects
and third party libraries. Then, we used the keywords łconflict”
or łNoSuchMethodError ”, etc. to further locate the DC issues. As
such searches returned noisy results, we refined these results by
manual checking [ 83]. Eventually, we obtained 135 DC issues, and
128ofthemhave been fixed.
Table1summarizes the demographics of those projects covered
bythecollected135DCissues.Theyarelarge(upto2,218kLOC),
popular(upto16,398stars),anddiverse(14differentcategories,e.g.,
bigdata,buildmanagement, HTTP).Inthe following,weanalyze
the135DCissuesfromtheApacheprojectsandreportourfindings.
3.2 RQ1: Issue ManifestationPatterns
DCissuesinJavaprojectscanbemanifestedindifferentways.This
RQaimsatcategorizingtheirmanifestationpatterns.Thecatego-
rization enables us to understand how DC issues are triggered and
howtheycanbedetected.ToanswerRQ1,wemanuallyinvestigated
thecollected135bugreportsandrelateddiscussions(e.g.,comments
and patches). Specifically, three postgraduates first classified them
independently,andthenreachedaconsensusbydiscussionifthe
classification results are differentamong them.
We observed that DC issues can be manifested in three patterns:
(1)conflictsinlibraryversions ,(2)conflictsinclassesamonglibraries ,
and(3)conflictsinclassesbetweenthehostprojectandlibraries .These
threepatternsdifferinhowaDCissueistriggered.Weusethree
examples in Figure 2to illustrate these three patterns, respectively.
A.Conflictsinlibraryversions (39outof135issues).Suppose
a host project directly uses Lib1andLib2:v1, and Lib1transi-
tivelydependson Lib2:v2,whereL:vdenotesalibrary Lofversion
v.Accordingto Maven’snearestwinsstrategy ,Mavenchoosesthe
version that appears at the nearest to the root (host project) of the
dependencytree ifthereare multipleversionsofthesamelibrary.
AsshowninFigure 2(a),theloginformationinthebottomisthe
dependencyinformation printed by Maven. Only Lib2:v1 willbe
packagedduringthebuildingprocess.Then,asystemfailurewilloc-
curif Lib1invokesthefeatureswhicharenotincludedin Lib2:v1.
321ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA Wang,Wen, Liu, Wu, Wang,Yang,Yu, Zhu, Cheung
Table1: Thestatistics of subjects coveredby collected135 DC issues
Software Star Size (LOC)1Categories2Issue trackingsystems Severity3Selected issues
71Min. Max. Avg. Min. Max. Avg.16/28Jira BugZilla MCBNMi1351016398 796 0.9k2218.4k 375.3k 115 20 747191322
1.LOCdenotes lines of codes; 1 K =1000; 2.Thesoftwarecategoryrefersto Apache officialdefinition [ 5];3.M:Major;C:Critical; B:Block;N:Normal;Mi:Minor
For instance, in issue #YARN-6414 [66], two versions of Guavaare
introducedin YARN. Their introduceddependency pathsare: YARN
→Guava:21.0 andYARN→Hadoop→Guava:11.0.2 . As a re-
sult,Guava:11.0.2 is shadowed by Guava:21.0 , as the latter is
nearer to the host project YARN. From developers’ discussions,we
found that Hadoopreferenced to class LimitInputStream which
is defined in the shadowed version Guava:11.0.2 while not de-
fined in the loaded version Guava:21.0 . Therefore, the project
crashedwith NoClassDefFoundError .
B.Conflictsinclassesamonglibraries (90outof135issues).
Supposethatlibraries Lib1andLib2arepresentinthedependency
treeasshowninFigure 2(b).Lib1andLib2includethreedupli-
cate classes A,BandC. Based on the Maven’sfirst declaration wins
strategy, the duplicate classes within the first declared JAR lib2
willshadowtheonesincludedin lib1.Then,DCissuearises,ifthe
hostprojectreferencedtothefeaturesonlydefinedintheshadowed
classes. The scenario generally occurs in two cases: (1) a fat JAR
repackages alibrary that is already declared on the classpath; and
(2) a library is renamed and unknowingly added to the classpath
twice. Taking issue #SUREFIRE-851 [59] as an example, Maven
Surefire directlydependsonlibraries Jaxws-rt andGf-client .
However,library Gf-client definedclass SEIModel thatwasin-
compatible with class SEIModel included in library Jaxws-rt .
Maven Surefire referencedto method SEIModel.getJAXBCon
text()definedin Gf-client whilenotdefinedin Jaxws-rt .Un-
fortunately, class SEIModel inGf-client was shadowed, as li-
brary Jaxws-rt declaredaheadofitonthe classpath.Asaresult,
NoSuchMethodError occurredat runtime.
C. Conflicts in classes between host project and libraries
(6 out of 135 issues). If the host project and Lib1include duplicate
classesA,BandC, then only those included in Lib1will be in-
cluded during the packaging process. However, if the features only
defined in classes A,BandCof the host project have been refer-
enced,systemmightthrowexceptionsorerrors.Thedependency
analysis scope of Mavenplatform is limited to the libraries listed
in its dependency configuration script ( pom.xml). Since pom.xml
does not declare the host project [ 52],Mavendoes not even notice
theDCissuesofsuchcase.Forexample,in #STORM-2382 [58],host
project Stormanditsdependentlibrary Log4jincludedincompati-
bleclasseswiththesamenames.Inparticular,as Log4jisalogging
framework,several classes definedin Log4jhave beenmovedinto
Stormforspecificpurposesduringtheevolutionprocess.Then,the
classes included in library Log4jshadowed those defined in the
hostproject,whichleadedto aruntimefailure.
These three manifestation patterns A,BandCare all ascribed
to the reason that the host project references to the unexpected
versionofclassesorlibraries.Moreaccurately,iftheloadedclasses
or libraries do not completely cover the actually referenced feature
setofthehostproject,runtimeexceptionsorerrorswilloccur.These
findings help us understand when duplicate classes or libraries are
introduced in one project, which version will shadow the others
basedonbuildingmechanism.Inaddition,thesefindingsarecrucialfor us to automatically detect DC issue and distinguish the benign
andharmfulDC warnings as well.
Host Project
Lib1 Lib2
Lib2v2.0
v1.0ABCAB
C1. [INFO] [dependency:tree]
2. [INFO] groupId:Lib2:jar:v1.0
3. [INFO] groupId:Lib1:jar:v2.8
4. [INFO] +- (groupId:Lib2:jar:v2.0:compile - omitted 
for duplicate)
1. [INFO] [dependency:tree]
2. [INFO] groupId:Lib1:jar:v2.81. [INFO] [dependency:tree]
2. [INFO] groupId:Lib2:jar:v1.0
3. [INFO] groupId:Lib1:jar:v2.8
4. [INFO] -------------------------------------------------------
5. [WARNING] Rule 1: org.apache.maven.plugins.
enforcer.BarDuplicateClasses failed with message:
6. Duplicate classes found in:
7.    groupId:Lib2:jar:v1.0
8.    groupId:Lib1:jar:v2.0:compile
9. Duplicate classes:
10.    Lib1/A.class
11.    Lib1/B.class
12.    Lib1/C.class
a. Nearest wins strategy. Only Lib 2 v1.0 will be included into the
    package, as Maven chooses the version that is nearer to the root 
    (host project) of the dependency tree.
b. First declaration wins strategy. The duplicate classes A, B and
     included in Lib1 and make them unavailable.
    B and C within Lib 1 will be accessed.ABC
ABC
ABC
Host Project
Lib1
Lib2
Host Project
Lib1
   C within the first declare JAR Lib 2 will “shadow” the ones
c. Maven does not notice the conflicting classes and ultimately A, 
Figure2: Issue manifestation patterns
3.3 RQ2: Issue Fixing Patterns
ToanswerRQ2,wefurtherstudiedtheissuereportsandpatches
ofthe128fixedDC issues.We aimto study (1)whether thefixing
solutions of DC issues share common patterns; (2) what factors
affect the choice of different fixing solutions; and (3) how much
effortdevelopersspendinfixingtheseissuesfordifferentsolutions.
Our study identified four common patterns that were applied to
fixthe DC issues:
Pattern1:Shadingtheconflictinglibraries (25outof128so-
lutions). Maven-Shade-Plugin providesthecapabilitytopackage
the project in an Uber Jar[61], including its third party libraries. It
willalsoshade(i.e.,rename)thepackagesof someofthelibraries.
In this way, developers can relocate the classes that were included
intheshadedartifacttocreateaprivatecopyoftheirbytecode(e.g.,
issue #SPARK-2848 [56]). This solution allows multiple versions of
the same class to be referencedbythe hostproject.
Pattern 2: Adjusting the classpath order of dependencies
(42 out of 128 solutions). The dependency order configurations pro-
vided by software build tools, play a vital role in determining a
project’s classpath. Especially, for Maven, library declaration or-
der specified in pom.xml corresponds to their appearance order
onthe classpath[ 40].In practice,forcing aparticulardependency
order on the classpath isa strategy commonlyused by developers
forfixingDCissuesatarelativelylowcost.Forexample,inissue
#HDFS-10570 [32], there were two versions of the Nettylibraries
on the HDFS’s classpath and the older version shadowed the newer
one. A runtime failure occurred, as the loaded older version of
Nettydoes not include the features referenced by HDFS. However,
the shadowed newer version of Nettycould cover all the refer-
enced features. Therefore, developers solved this issue easily by
reversingtheirdeclarationorderin pom.xml.Adoptingthissolu-
tiontoworkaroundDCissuesrequirestheshadowedclassesdefine
allthe features referencedbyhostproject.
322Do the Dependency Conflictsin MyProjectMatter? ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA
Table2: Therelations between manifestation and fixingpatterns
Manifestation Pattern1 Pattern2 Pattern3 Pattern4 Other
PatternA 5 10 18 3 1
PatternB 20 32 30 2 1
PatternC 0 0 3 0 3
Pattern 3: Harmonizing library versions (51 out of 128 so-
lutions). A DC issue always occurs when multiple versions of
the same library coexist in one project but they are incompati-
blewitheachother.Solutionsofthispatternupgradeordowngrade
some of the JARs to resolve the version inconsistencies (e.g., issue
#HADOOP-7606 [31]). However, the solution could only be applied
to the scenario that the harmonized version completely covers the
feature set referenced by the host project. As developers discussed
inissue #HADOOP-8104 [30]:
łThe inconsistent versions of Jackson libraries (1.8 and 1.7.1)
caused the NoSuchMethodError . By manually verifying, Jackson
1.8.8artifactcontainsallthemethodsexplicitlyinvokedby Hadoop.
Sowedon’tneed themixed versionsof Jackson.”
Pattern4:Classloadercustomization (5outof128solutions).
This solution uses dynamic module system frameworks such as
OSGI[48] and Wildfly [64], to allow different versions of the
same libraries or classes coexist in one project by creating multiple
classloaders [ 49,74]. Although this solution works for most of the
DCissues,itcomeswithadditionalcostsandoftenrequiresdevelop-
ers to have a deeper understanding of the class loader mechanism.
Besides, using these frameworks also requires the system under-
going aseries of laboriousrefactoring operations. For instance,in
issue #CURATOR-200 [19],Curator projectinvolveddeepcoupling
with an older version of Guava, and its other libraries introduced a
newer Guavarelease. As the host project referenced to the feature
setsincludedinbothofthesetwoversions,theyadopted OSGItech-
niqueto keep them coexist in Curator. Since the fixing solution is
laboriousandtime-consuming,thedevelopersstruggledtoadopt
this solution after35 rounds ofdiscussions.
Other workarounds (5 out of 128 solutions). The remaining
issuesareresolvedinmiscellaneousways.Forinstance,theyprinted
awarningonconsoleanddisabledtheunexpectedbehaviorscaused
by conflicts (e.g., issue #YARN-5271 [65]), or used a combination
ofmixversionsofalibrarytosatisfyallthefeaturereferences(e.g.,
issue #CXF-5132 [20]),etc.
Diagnosisandfixingefforts. Figure3showsthecomparisons
ofthe diagnosisandfixing efforts.Inordertocompare theefforts
requiredto fix DC issues,we collectedanother 128non-DC issues
withthesameseveritiesasthecollectedDCissuesaforementioned.
Pattern 1 andPattern 4 are applicable to the scenario that the
host project references to the feature set defined in multiple ver-
sions of the same library or class, but neither of a single version
can satisfy the host project’s requirement. From the concerned dis-
cussions,developersfirstneedtospendeffortsinidentifyingthe
duplicateclasses,theloadedclasses,andtheirreferencedclasses.
Theythendecidewhichsolutioncanrelocatetheshadowedones.
Besides, customizing class loaders or shading the JARs are difficult
tohandle.Thus,thefixingeffortsof Pattern1 andPattern4 are
significantlyhigherthanthoseoftheothers.Onthecontrary,ad-
justing dependency order on classpath to eliminate conflicts is a
relativelyeasierwaytoresolvetheproblemasshowninFigure 3.Even so, it takes more time to diagnose for DC issues than non-DC
ones onaverage.
12345NDec0102030405060708090
(a) Comments
12345NDec0102030405060708090
 (b) Rounds
12345NDec020040060080010001200
 (c) Duration
Figure 3: Comparison of the diagnosis and issue-fixing efforts (ł1
∼4” = łPattern 1∼4”, ł5” refers to other workarounds, łNDec =
non-dependency conflict issues”), where (a) concerns the number
of comments for each issue, (b) concerns the number of discussion
rounds during the fixing process, and (c) concerns the number of
days from the time when the issue was reported to the time when
itwas fixed.
Factors affecting the choiceofsolutions. Table2shows the
relationshipsbetweencommonmanifestationpatternsandfixing
patterns.Fromthistable,wecantellthatissuesthataremanifested
bytypeAandBcanbe fixed byall the foursolution patterns,and
issues manifested by Care mainly fixed by harmonizing library
versionsormodifyingthecodetoworkaroundtheproblems.By
furtheranalyzingthediscussionsoftheseissuereports,wefound
that the selection of these solutions are highly correlated with the
followingfourfactors: duplicateclassset ,actualloadedfeatureset ,
shadowedfeatureset andreferencedfeatureset .Therootcausefor
alltheseDCissuesisthattheactualloadedfeaturesisasubsetof
the referenced ones. If reversing the dependency declaration order
ontheclasspathcanavoidruntimeexceptions(i.e.,theshadowed
featuressatisfyhostproject’srequirements),developerspreferto
adoptPattern 2 as a workaround to fix this issue. The reason is
that it comes along with lowest cost without the requirement to
changeanycode.Besides,keepingversionconsistencyvia Pattern
3is commonly adopted if the harmonized version can cover all the
referencedfeatures.Otherwise,developershavenochoicebutto
usePatterns 1, 4 or otherworkarounds to relocate the shadowed
dependenciesrequiredbythehostprojecttoensurethecoexistence
ofthe conflicting JARs.
Diagnosisandfixingcostsgiveushintsforassigningtheseverity
levelsforDCissues. Naturally,morecomplicatedcasesshould be
more carefully handled to ensure the projects’ long-term health
andimprove theirmaintainability.
4 DEPENDENCYCONFLICT DIAGNOSIS
Despiteextensivewarningsgivenbysoftwarebuildtools,depen-
dency conflicts still exist and remain unresolved in 68 .46% the
popular GithubprojectsasrevealedinSection 2.1.Thereasonis
that the existing build tools detect DC issues at library or class
level without analyzing the impacts of these issues on program be-
haviors. As such, these tools do not differentiate the benign issues
from the harmful ones. This motivates us to propose an automated
approachtoanalyzeDCissuesatafinergranularityandprovide
323ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA Wang,Wen, Liu, Wu, Wang,Yang,Yu, Zhu, Cheung
assessmentoftheirseveritylevels.BasedonourfindingsinRQ1,
thebenignandharmfulDCissuesaredeterminedbythedifference
betweentheloadedandactuallyreferencedclasses.Combiningour
observed manifestationpatterns anddependency management cri-
teriaofbuildingplatform,wecanautomaticallydetectthemultiple
versions of classes or libraries, and identify the loaded version and
the shadowed ones on the classpath. Then, we can differentiate the
benignfromharmfulDCissues.AsdiscussedinRQ2,theseissues
can be further subdivided based on their diagnosis and fixing costs.
Inthismanner,wecanhelpdevelopershighlighttheharmfulDC
issuestoavoidruntimeexceptionsorerrors.Inthefollowing,we
firstformulatetheDCproblemandthenelaborateonourdetection
algorithm andseverityassessment strategy.
4.1 ProblemFormulation
To ease presentation, we let pdenote a host project. The set of
classesdefinedbythedevelopersofthehostprojectiscalledthe
hostclassset,whichisdenotedas H.Thesetofthird-partylibraries
referenced by the host project is denoted as B. For each library
li∈B,it defines a set ofclasses Cli,whereiindexes a third-party
library. Multiple versions of a library are uniquely indexed. We
denotealltheclassesdefinedin BasC,specifically,C=∪∀liCli.
Then,thesetofalltheclassesthatmightappearontheclasspath
isdenotedK=H∪C.Foreachclass ci∈K,wedefinefunction
f(ci)to extract the set of all the features in ci. A feature refers
toamethodinthisstudy.Basedontheabovedefinitions,wecan
formallydefinethedependencyconflictproblemamongtheclasses
inKas follows. Note that our formulation focuses on harmful
dependency conflicts.
Definition1.(DependencyConflict). Letc1andc2beanytwo
classes specified on the classpath. If specifying these two classes
withdifferentordersontheclasspathcanleadtodifferentprogram
behaviors,we defineitas adependency conflict.
According to Java’s class loading mechanism, a classpath de-
termines the locations where to find the required classes during
runtime. If multiple classes with the same fully-qualified name are
specifiedontheclasspath,onlyoneofthemwillbeloadedbased
on the loading mechanism of the build tool (i.e., as revealed in our
empirical study) and the others will be shadowed. To detect de-
pendency conflict issues in practice, we first need to identify those
classesCmthathavemultipleversionsspecifiedontheclasspath.
In order to assess the severities of the detected DC issues, we need
to analyze those features defined in these duplicate classes as well
asthefeaturesreferencedbythehostprojectasrevealedbyourem-
piricalstudy inSection 3.Therefore,for eachof theclass ci∈Cm,
we further introduce the following concepts:
Definition2.(DuplicateClassSet). Supposethereare m(m>
1)versionsofclass cideclaredonclasspath.Wedefinetheduplicate
classsetasDi={cij|m>1,1≤j≤m},wherecijrepresentsthe
j-th versionofclass ci.
Definition3.(ReferencedFeatureSet). LetRHbethefeature
set directly or indirectly referenced by the host classes H. We
denotethefeaturesetin DiasRDi=∪∀cij∈Dif(cij).Forci∈Cm,
the referencedfeature setbythe hostclassesis Ri=RH∩RD i.
Definition 4. (Loaded Feature Set). Supposecil∈Diis the
actual loaded version of class ci. We then define the actual loaded
feature setasLi=f(cil).Definition 5. (Shadowed Feature Set). Supposecil∈Diis
the actual loaded version of class ci. We then define the feature set
Si=∪∀cij∈Di\cilf(cij)as the shadowedfeature set.
For each ci∈Cm, we can obtain the above four different sets.
Based on the observations from the empirical study, A DC issue
arises when the actual loaded feature set Lidoes not subsume the
referencedfeatureset Ri.Therefore,wesaythatthereisaDCissue
forpif the following condition satisfies:
Ri/not∼ub∼eteqlLi,∃ci∈Cm (1)
4.2 Overview
Based on our previous observations, we propose a static analy-
sis technique involving four steps as shown in Figure 4. First, it
extractsthelibrarydependencytreebyanalyzingthelibrarydepen-
dencymanagementscript(e.g, pom.xml, build.gradle ).Second,
it identifies duplicate libraries or classes based on the dependency
tree andbytecode(JARorclass files).Third,itdeducesthe loaded,
shadowed feature set based on the class loading rules of build tools.
In our study, we focus on the Mavenclass loading mechanisms
observed in the empirical study. However, our approach can be
easily generalized to other build environment, by adapting the cor-
responding class loading rules. Furthermore, the referenced feature
sets can be obtained via static analysis. Finally, it detects DC issues
based on the deduced feature sets and assesses their severity levels
according to theirimpacts onthe systemandmaintenancecosts.
Library Dependency 
Management ScriptBinary Code File
Extract Library
Dependency
TreeLib1 Lib2
Lib4
Lib5 Lib3 v2.0Lib3 v1.0 Identify
Duplicate Libraries
or ClassesLib1 Lib2
Lib4
Lib5 Lib3 v2.0Lib3 v1.0
Analyze Relations Between Di ﬀerent Feature Set
Loaded Shad owed Referenced
12
3
Assessing Warning L evels ! ! ! ! Level 1 Level 2 Level 3 Level 44
Figure4: Architectureof Decca
4.3 Detecting DCIssues
According to our problem formulation in Section 4.1, the key to
detect DCissues is to identify the duplicate,referenced ,loadedand
shadowed featuresetsfirst,andthentocheckwhetherthecondition
ofthe root cause formulatedinEquation 1issatisfied.
Thefindingsofourempiricalstudytowardsthemanifestation
patternsenableustoidentifytheloadedandshadowedfeaturesets
automatically.First,accordingto PatternA ,ifdifferentversionsof
samelibrariesareinoneproject,theversionthatappearsnearest
tothehostprojectinthedependencytreewillshadowtheothers
andmakethemunavailable.Second,ifdifferentlibrariescontain
the same classes, then the classes included in the first declared JAR
willshadowtheothers,basedon PatternB .Finally,asdependency
analysisscopeof Mavenislimitedtothelibrarieslistedwithinits
pom.xml, if host project and the libraries include the same classes,
then the ones inthe libraries willbe loadedrefers to PatternC .
Identifyingtheduplicateclassesisstraightforwardsinceweonly
need to checkwhetheraclass withthesamefully-qualified name
hasappearedontheclasspathfor multipletimes.However,when
multiple versions of classes coexist in the project, one key problem
isto detectthe referencedfeature set Ri.
324Do the Dependency Conflictsin MyProjectMatter? ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA
To address this problem, we designed an algorithm, which takes
the followingtwopartsas inputs: (1)duplicateclassset Di, and(2)
dependency management script of the project under analysis. The
outputofthealgorithmisthereferencedfeatureset Ri.Specifically,
the algorithm contains the following steps:
•Initializes the referencedfeature set Rias an emptycollection.
•FindsthepathsetPifromthehostprojecttoeachlibrary lithat
contains duplicateclass ci∈Dionthe dependency tree LT.
•Extractsthereferencerelationships basedonclassnames using
staticanalysis.
•Analyzes the libraries on each path pt∈Piseparately, since
static analysis does not know which version is the referenced
versionifdifferentversionsofthesameclasscoexistinbytecode.
•Performs the following tasks for each path pt∈Pi: (1) Identifies
the boundary feature set Bs. Boundary feature set Bsrepresents
thefeaturesetdefinedinthehostprojectthatdirectlydepends
on host project’s succeeding library on path pt[87], where host
project’ssucceedinglibraryisthelibraryafterthehostproject
onpathpt.(2)Identifiestheboundaryfeatureset Bedefinedin
libraryliand directly depended by the preceding library of lion
pathpt, where the preceding library of liis the library before
lion pathpt. (3) For each method mt∈Bs, ifmtdirectly or
transitivelydependson mk∈Be,performsRi←Ri∪Mk∪mk,
whereMkisthe feature setusedby mk.
Deccais implemented as a Mavenplugin based on Sootframe-
work.Itleverages Soot’sprogramdependencygraphandcallgraph
APIs to identify the referenced feature set. It is well-known that
staticallyconstructingsoundandcompletecallgraphsandprogram
dependence graphs for Java language is challenging due to the lan-
guage features such as dynamic binding and reflections [ 73,90].
This factor affects Decca’sdetection precision (See Section 5.1).
4.4 Assessing DCSeverityLevels
Mavendetects duplicate instances as warnings at the library or
class level, which is coarse-grained. Besides, it generates all DC
warningswithoutdistinguishingtheirseveritylevels.Iftherefer-
encedfeaturesetdefinedintheduplicateclassesarecompatibleand
consistent, they have no seriouseffectson thehost project atrun-
time.Therefore,itisdifficultfordeveloperstodistinguishbenign
warningsfromharmfulones(e.g.,causingruntimeexceptions)if
the generated warnings do not provide extra severity information.
Deccaaddressesthisissue intwosteps.First, itanalyzesthehost
project and the third-party libraries at a finer granularity, which
isatthefeaturelevel,toassesswhetherthoseduplicateinstances
are harmful or not driven by our findings on the manifestation
patterns. Second,itestimatesthemaintenanceefforts requiredby
thedetectedissuesdrivenbyourfindingsonthefixingsolutions
to further augment the issues with severity levels. Then, Decca
will assign a DC issue to one of the four severity levels, which are
definedas follows.
Level 1:Ri⊆ LiandRi⊆Si. In this case, the referenced
featureset isa subsetoftheactual loadedfeatureset. Besides,the
shadowed version completely covers the feature set used by the
hostproject.Thisindicatesthatanyordersofthespecificationof
these duplicate classes on the classpath will not induce serious
runtime errors. Therefore, this is a benign conflict and will not
affectthe systemreliabilityat runtime.Level 2:Ri⊆ LiandRi/not∼ub∼eteqlSi. In this case, the referenced
feature set is a subset of the actual loaded feature set. However,
the shadowed feature set does not cover the referenced feature
set.Itisconsideredasapotentialriskforsystemreliabilitysince
differentordersofthespecificationsoftheseduplicateclasseson
the classpath (e.g., in different running environment or building
platform)mightinduceruntimeerrors.
Level 3:Ri/not∼ub∼eteqlLiandRi⊆Si. It is a harmful conflict, as the
actualloadedfeaturesetdoesnotconsumethe referencedfeature
set.Theruntimeerrorswilloccurwhentheexpectedfeaturecannot
beaccessed.However,inthiscase,theshadowedfeaturesetcom-
pletelycoverthefeaturesetreferencedbyhostproject.Therefore,
itcanbesolvedbyadjustingthedependencyorderontheclasspath,
withoutchanging any sourcecode.
Level 4:Ri/not∼ub∼eteqlLiandRi/not∼ub∼eteqlSi. It is a harmful conflict, as the
actual loaded feature setdoes not coverthe referenced feature set.
Besides,theshadowedfeaturesetdoesnotconsumethereferenced
featuresetneither.Therefore,thistypeofconflictscannotbeeasily
resolvedbyadjusting thedependencyordersontheclasspath.To
solve these issues, it requires more efforts to ensure the multiple
versionsofclassescould be referencedbythe hostproject.
DCissuesdetectedas Level1andLevel2arebenignonessince
theywillnotcausesystemfailuresinthecurrentversion.However,
those issues at Level 2might cause runtime errors potentially if
thedependencyordershavebeenchanged.DCissuesdetectedas
Level 3andLevel 4areharmfulonesastheycanleadtosystem
crashes under the current configurations. These severity levels pro-
vide developers with a deeper understanding of the detected DC
issues, and guidance to fix these bugs. For instance, DC issues at
Level2can be potentially avoided by fixing Pattern3 (harmoniz-
inglibraryversions)and Pattern2 (adjustingtheclasspathorder
of dependencies) can be used as the workaround of the Level 3
DC issues.However,DC issues at Level 4require morediagnosis
efforts since they need to be solved by fixing Pattern 1 (shading
the conflicting libraries)or Pattern4 (classloadercustomization).
5 EVALUATION
Weevaluatetheeffectivenessandusefulnessof Deccausingreal-
world open sourceprojectsagainst tworesearch questions:
•RQ3(Effectiveness): Howeffectivecan DeccadetectrealDC
issuesandassesstheirseveritylevels?
•RQ4 (Usefulness): CanDeccadetect unknown DC issues in
real-worldprojectsandfacilitatedevelopersindiagnosingthem?
To study RQ3, we first collected a high quality dataset which
contains high-severity (i.e., Level 3and4) and low-severity (i.e.,
Level1and2)DCissues.Wethenapply Deccatothisdatasetto
see if DC issueswithhigh-severitycan be detected.
To study RQ4, we randomly selected 30 projects from Github
and built their latest releases on Mavenplatform. Then, we applied
DeccatotheseprojectstodetectunknownDCissuesandassess
theirseveritylevels.Especially,wefilteredoutthe Level1issues,
which will not lead to the system failures no matter how the class-
path order of dependencies is changed. For the identified issues
withLevels2,3and4severities,wereportedthemtodevelopers
usingthecorrespondingbugtrackingsystemsandevaluatedthe
usefulnessof Deccabasedondevelopers’ feedbacks.
325ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA Wang,Wen, Liu, Wu, Wang,Yang,Yu, Zhu, Cheung
5.1 RQ3: Effectiveness of Decca
Data collection. Weconstructedthedatasetfromthe2,289Java
projectsasmentionedinSection2.1. DeccacandetectDCissues
in four severity levels. However, it is difficult to collect the ground
truthabouttheexactseveritylevelsofDCissues.Inpractice,devel-
opersoftenconsiderDCissuesinseverityattwolevels:(1)high-
severity issues (include Level3and4DC issues), which will cause
runtimeexceptionsorerrors;and(2)low-severityissues(include
Level1and2DCissues),whichshouldnotcauseunexpectedbe-
haviors, exceptions or errors if the project and dependent libraries
remainunchanged.Thiscategorizationinformationwouldbeeasily
identifiedfrombugreportsorlogmessageofcommits.Therefore,
this evaluation mainly focus on whether Deccacan distinguish
high-severity issues from low-severity ones. To guarantee the qual-
ity of labeling high-severity and low-severity issues, we chose the
fifth latestrelease ofeach project, sincewe assumedthat the time
intervalfromfifthlatestreleasetonowissufficientfordevelopersto
diagnose DC issues and give solutions (fix or not). We constructed
thedatasetofhigh-severityissuesbyselectingfromthefixedDC
issues,sincedeveloperstypicallyassignedsevereissueswithhigher
priority to fix. However, it does not mean that all fixed issues must
be high-severity since developers might also fix low-severity ones
toavoidpotentialissuesariseinfuturemaintenance(e.g.,DCissues
atLevel2).Therefore,weusethefollowingcriteriontoselecthigh-
severity issues: (1) the fixing patch is linked to a bug report which
recordsaruntimeexceptionorcompilationerror;or(2)thecommit
logmessageexplicitlymentionedthatitfixedaharmfulDCissue
(i.e.,causingruntimeexceptionsorcompilationerror).Wecollect
the dataset of low-severityDC issues fromthe unfixed ones. How-
ever, not beingfixedso fardoesnot necessarilymeanthatissueis
lowseveritysinceitmighttakedevelopersalotoftimetodiagnose
the issue. It has been found that bugs are usually repaired within 1
to2yearsacrossdifferentprojectssincetheywereintroducedto
theproject[ 78].Therefore,weonlyselectthoseDCissuesthathave
not been fixed for the next 24 months as low-severity ones. The
other DC issues are ignored in our evaluation to avoid introducing
noises, since we do not have high-confidence to judge whether
their severities are high or low. In this manner, we collected 47
high-severityand172low-severityDCissuesasthegroundtruth
dataset.Thedatacollectionprocessinvolvestwograduatestudents:
one identifying the high-severity and low-severity DC instances
andthe otherverifying the results.
Metrics. We useRecall,Precision, andF-measure to evaluate the
performanceof Decca,whicharedefinedbythefollowingmetrics:
True Positive (TP): the conflict identified as a high-severity issue
(i.e.,Level3orLevel4) isahigh-severityissue.
False Positive (FP): the conflict identified as a high-severity issue
(i.e.,Level3orLevel4) isalow-severityissue.
TrueNegative(TN): theconflictidentifiedasalow-severityissue
(i.e.,Level1orLevel2) isalow-severityissue.
FalseNegative(FN): theconflictidentifiedasalow-severityissue
(i.e.,Level1orLevel2) isahigh-severityissue.
Based on the above four metrics, we can obtain the Recall,Preci-
sion,andF-measure as follows:
Precision=TP/(TP+FP) (2)
Recall=TP/(TP+FN) (3)F-measure=2×Precision×Recall/(Precision+Recall)(4)
Precision evaluateswhether Deccacandetecthigh-severityis-
suesprecisely. Recallevaluatesthecapabilityof Deccaindetecting
all the high-severity issues. F-measure combines the Precision and
Recalltogether[ 100].
Results. Theexperimentalresultsshowthat Deccaidentified
39high-severityDCinstanceswitha Precision of0.923,a Recallof
0.766anda F-measureof0.837.Basedontheresults,wecancon-
clude that Deccacan effectively detect the DC issues with severity
levels. We further investigated the reason why Deccagenerated
falsepositiveandnegativecasesof Decca.Wefoundthat,thisis
mainlybecausestaticanalysis cannotaccuratelydealwiththeJava
language features such as dynamic method dispatching (virtual
function invocations) and reflections [ 73,90]. For instance, project
Apache/Metamodel introducedconflictingJARs Httpclient 4.4.1
and 4.5.2, and version 4.4.1 shadowed 4.5.2. By static analysis, host
projectreferencedto423featuresoflibrary Httpclient ,butthe
loaded version 4.4.1 only defined 378 of them. Deccaassesses this
DCissueas Level4severity.However,thisisafalsepositive.By
further checking, we found that these uncovered 45 (i.e., 423 −378)
features will never be executed at runtime. This discrepancy is
mainly becauseweadopt conservative staticanalysistoconstruct
call graph and include some false call edges in the virtual function
callsites.Inanotherexample,libraries xercesImpl andxml-apis
bothincludedclass SingleSignOnFactory ,whichcausedaDCis-
sueinproject Apache/Oodt .Basedon Decca’detection,theloaded
class defined in xml-apis could fully cover the referenced feature
set. As a result, our tool assigned Level 1severity to this instance.
In fact,Deccaignored a case that a method in the shadowed class
wasusedbyhostprojectviareflectionmechanism,whichleaded
to afalse negative warning.
5.2 RQ4: UsefulnessOf Decca
Deccasuccessfullyidentified466DCissuesfrom24projectsamong
all the 30 projects analyzed. Among these instances, 438 (93.9%)
ofthemareat Level1,20(4.2%)ofthemareat Level 2,4(0.08%)
of them are at Level3, and 4 (0.08%)of them are at Level 4. After
filtering out the benign issues with Level 1, we reported issues
withLevel2,3and4to their corresponding bug tracking systems.
Our bugreport includes the following information:
(1) Severity: concerning the severity options of bug tracking
system, if the detected DC instances are assessed as Level 1or
Level2, welabeled themasł minor” issues,otherwise asł major”
issues.Notethat,wefilteroutmostofthe Level1issues.However,
toconfirmourexpectationinhandling Level1issues,werandomly
sampledfourissuesandreportedthemto developers.
(2)Rootcause:welistedthelibrarypairsincludingduplicated
classes, or different versions of the same libraries in the project.
More importantly, we provided the differences between the feature
setofthe actually loadedclassesandthat of the referencedones.
(3) Fixing suggestions: according to our findings of empirical
study (Section 3.3), developers prefer to adopt fixing Pattern 2
(adjustingtheclasspathorderofdependencies)and Pattern3 (har-
monizing library versions) to solve DC issues as they requires less
efforts. Therefore, for the DC issues with Level 2andLevel 3
severities,wesuggesteddeveloperstofixtheissuesbyharmoniz-
inglibraryversionsoradjustingtheclasspathdependencyorder
326Do the Dependency Conflictsin MyProjectMatter? ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA
Table3: Experimentalsubjects and checking results
ID Project Category RevisionSizeStar Fork AvailabilitySeverity levelBugID(LOC) L1L2L3L4
1 Spark[54] Bigdata 8077bb0 130.0k 16262 15050 Apache/Github 40100SPARK-23509♦
2 Beam [13] Bigdata a750128 337.0k 1722 1038Apache/Github 17200 BEAM-3690♦
3 Bahir [11] Extensiontool 6ea42a8 0.9k 152 102Apache/Github 22011 BAHIR-159♣
4 Wicketstuff/Core[ 63] Container 5cc41f5 228.5k 314 293Apache/Github 16100 Issue #621♦
5 Javasoze clue [ 38] Command 23c9da4 2.8k 103 37 Github 18100 Issue #61
6 ActiveMQ Artemis [ 8] Networkserver f6c5408 557.8k 271 326Apache/Github 24000 -
7 ApexCore[ 6] Platform 4fb580f 87.0k 277 161Apache/Github 34000 -
8 Ignite[33] OSGI 4e86660 2218.4k 1505 848Apache/Github 7000 -
9 Wicket[62] Web framework b728c69 352.5k 412 293Apache/Github 2000 -
10Google/Closure-Compiler [ 25]JS compiler 900251b 427.6k 4005 777 Github 4100 Issue #2815♠
11 Orientdb [ 47] Database 56ab1ac 496.3k 3366 718 Github 8001 Issue #8111♠
12 Cm[18] Web application 9e6f45b 19.k 12 6 Github 5001 Issue #1♦
13 Brooklyn [ 15] Cloud 48dbcc3 276.1k 69 47Apache/Github 20010BROOKLYN-581
14 CarbonData[ 17] Bigdata 9f2884a 127.9k 612 391Apache/Github 25400CARBONDATA-2169
15 Prestodb[ 53] Bigdata 89fed3a 0.8k 15 22 Github 16100 Issue #29
16 Solr[57] NetworkServer d32048c 31.7k 295 207 Github 10100DATASOLR-447
17 tomcat exporter[ 60] Exporter 70ac377 0.9k 19 10Apache/Github 10200 Issue #8
18 Hadoop Common [ 27] Database 1e85a99 2042.8.k 5883 3987Apache/Github 16001HADOOP-15261♦
19 Oozie [45] Bigdata 9e662c7 198.6k 364 327Apache/Github 25010 OOZIE-3185♠
20 Accumulo [ 1] Database d98843b 563.8k 343 197Apache/Github 33100ACCUMULO-4812♣
21 Eclipsejetty[ 22] Debugging b71cd70 375.9k 1868 1134 Github 6200 Issue #2232
22 Parquet [ 50] Bigdata b82d962 0.9k 550 465Apache/Github 2100PARQUET-1236♦
23 ApexMalhar [ 6] Bigdata 0d98d05 243.7k 110 149Apache/Github 34100APEXMALHAR-2556
24 Atlas[10] Framework 6770091 123.4k 33 32Apache/Github 44110 ATLAS-2437
♦:The issueshavealreadybeen fixed. ♠:The issueswereconfirmed and beingfixed in process.
♣:Theyhavebeen confirmed as DCissues,and theyaresuggested to besolved by the upstreamthird party libraries.
based on their specific scenarios. For Level4issues, we suggested
themtousefixing Pattern1 (shadingtheconflictinglibraries)to
work around theseproblems.
Altogether,wereported20DCbugsincluding28issues(issuesin
oneprojectwerecombinedintoonebugreport).AsshowninTable
3,11bugs(55%)wereconfirmedbydevelopersasrealissueswithin
afewdays.6outofthe11confirmedbugs(55%)werequicklyfixed
usingoursuggestions,3confirmedbugs (30%)are inthe process
ofbeingfixed,andtheother2confirmedbugsaretoberesolved
by the developers of upstream third party libraries. By further
analysis, we found that those non-severe issues ( Level 2) have a
lowconfirmationrate(30%).Meanwhile,thesevereissues( Level
3 and 4) have a higher confirmation rate (75%), which is within
ourexpectation.The10unconfirmedissuesaremainlyduetothe
inactive maintenanceofthe corresponding release versions.
5.2.1 Feedback on Reported Issues. For the 6 fixed issues, the
developersagreedthatthedetectedconflictscouldbringrisksto
softwarereliabilityormaintainability,andtheyalsoinvitedusto
uploadpatchestoresolvetheissue.Inparticular,2outofthe6issues
(i.e.,HADOOP-15261 [29]and Issue #1 [34])aredetectedas Level
4byDecca.Thequickfeedbacksfromthecorrespondingdevelopers
are within our expectations since these issues are very serious
and can cause runtime errors. The remaining four are detected
asLevel2(i.e.,BEAM-3690 [14],Issue #621 [36],SPARK-23509
[55] and PARQUET-1236 [51]). Although these issues might not
cause runtime errors at the moment, to avoid potential errors in
the future, developers still fixed them after reviewing the different
feature setsbetween the conflicting JARs.
Three issues (i.e., Issue #2815 [35],Issue #8111 [37] and
OOZIE-3185 [46]) have been confirmed and are being fixed in
process up till now. For example, Google Closure-Compiler
library contains library com.google.code.gson . However, its
downstream project Wicketstuff Core also includes the library
com.google.code.gson ofanewerversion,whichintroducesadependencyconflict.Thisissuewasdetectedas Level 2DCissue.
We reported this issue to Google Closure-Compiler asIssue
#2815,anditwasconfirmedandsupportedbythe developers:
łI’m encountering this problem as well. Is there a way to build the
closurecompiler JARwithoutanydependenciespackaged in it? ”
TwoDCissueswereconfirmed,butdevelopersconsideredthat
they should be solved by its upstream third party libraries (i.e.,
BAHIR-159 [12]and ACCUMULO-4812 [2]).Forexample,developers
explainedin ACCUMULO-4812 :
łThe conflicting JARs are being brought in through Hadoopor
ZooKeeper ’sclasspath,andshouldbeaddressedbytheirpackaging. ”
Inaddition,werandomlyselectedfourDCissuesat Level 1to
report(e.g., ARTEMIS-1674 [9]and APEXCORE-805 [7]),sincewe
wouldliketoseewhetherdeveloperscareabouttheseissues.Aswe
expected, the developers would not like to revise their source code
urgently until they cause failures, although they acknowledged
these issues. These results indicate that Deccacan help developers
filteroutbenign DC issuesandhighlight the harmfulones.
5.2.2 Feedback on DECCA. Besides confirming our reported
issues, several developers expressed interests in our tool Decca,
whichisencouraging.Forexample,wereceivedthefollowingfeed-
back in BEAM-3690 :
łThisseemslikeahandyreport,isthetoolyouusedtoidentifythis
erroropensource? I amcurious to give it atry(alsofor other stuff). ”
łRelated, but not the same: I have tried turning on dependency
convergence in the Maven-enforcer-plugin . We need the same
for gradle to ensure long-term health and protect from regressions.
Maybethetoolthatgeneratedthisfine-grainedconflictsreportcan
alsofail thebuild?That wouldbe nice. ”
The above comments are made from experienced developers
[4] in the Apache Beam community. Currently, existing plugins,
suchas Maven-enforcer-plugin [42]aforementionedcaniden-
tify DC issues. However, Deccastill attracts developers’ attention.
ThefeedbacksindicatethatwhenreportingDCissues,itiscrucialto
327ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA Wang,Wen, Liu, Wu, Wang,Yang,Yu, Zhu, Cheung
providedevelopers with severitylevels and more-detailed conflict-
ing information. Our tool Deccais able to achieve this. The above
resultsandfeedbacksfromdevelopersshowthattheinformation
(e.g., severity levels) provided by Deccais useful for developers to
diagnosethe DC issuesinpractice.
6 THREATS TO VALIDITY
Our study issubjectto the following majorthreatsto validity.
DC issue selection. The DC issue selection may threaten the
validity of our empirical study results since the keyword searching
strategycanintroducenoises.Toreducethisthreat,wemanually
inspected, re-examined and cross-validated all the collected DC
issuesindependently to assure the data quality.
Ground truth dataset collection for evaluation. Collecting
thegroundtruthdatasetischallengingandcanbeathreattothe
evaluationresults.Toavoidintroducingnoisesinourevaluation
dataset, we collected the high-severity set from those DC issues
that been fixed in the subsequent releases. Moreover, we only keep
those instances that the fixing patches are linked with bug reports
orthefixingcommitlogsexplicitlymentionthemasharmfulDC
issues. We collected the low-severity set from those DC issues that
have not been fixed in their subsequent releases and no related DC
issuereportedintheirprojectsduringthe next24 months.
Limitation for detecting diverse types of DC issues. This
paper focuses on crash DC issues due to referencing the shadowed
featuresorclasses.However,insomecases,theconflictcouldbe
causedbythechangesinsemantics,performanceorotherattributes
of the duplicated libraries presented on the classpath. Deccadoes
notanalyzetheabovemanifestationsofDCissue,whichmayaffect
the validity ofdetection.
7 RELATED WORK
Library Evolution: Third-party libraries keep evolving in order
to fix previous bugs, add new features and etc. Bavota et al. ana-
lyzedtheevolutionoftheJavalibrariesofthe Apacheecosystem,
consisting of 147 projects, for a period of 14 years [ 68,69]. Specifi-
cally, they analyzed how upgrades of a project will affect related
projectsandwhatreasonswilldriveahostprojecttoupgradeits
dependencies.Busingeetal.analyzedtheevolutionofthe Eclipse
third-party plugins [ 70]. In particular, they studied the source com-
patibilitiesbetweenthethird-partyplug-insandtheEclipseSDK
releases. The evolving of a library is embodied in the evolution
ofitsdefinedfeatures(i.e.,APIs)atafinergranularity.Therefore,
manyresearchesfocusedonstudyingAPIstabilityduringlibrary
evolution [ 81,84,91,93,94]. Specifically, Robbes et al. investigated
how developers take actions to API evolutions of third-party li-
braries[93].Duetothefastevolutionoflibraries,differentversions
ofalibrarymightbeincompatible.Raemaekeretal.analyzedthe
relationshipbetweenversionnumbersandthebinarycompatibil-
ities of third-party libraries [ 92]. By empirical study, they found
that features defined in an older version are often unavailable in a
newer version. As a result, dependencies conflicts might occur due
to such incompatibilities if multiple versions are included in one
project. However, no existing works focus on the manifestations
anddiagnosisofdependencies conflictissues.
Library Analysis: Itisimportantfor a hostprojectto manage
itsdependedlibrariessincetheyareevolving.Muscoetal.proposedanapproachtomodeltherelationshipsbetweensoftwaresystem
andthird-partylibrariestobetterunderstandsoftwareevolution
[87]. In their study, they introduced the concept of software sys-
temboundary[ 87],whichisalsoadoptedinourpapertoidentify
thefeaturesetreferencedbyhostproject.Annosietal.proposed
a framework to facilitate developers in upgrading third-party li-
braries[67].Sinceupgradinglibrarieswillinevitablyaffectexisting
framework, their approach is designed mainlybased onriskman-
agement.Ounietal.proposedanapproachcalledLibFinder[ 88],
which helps developers find third-party libraries in developing.
Kikas et al. analyzed the dependency network structures for multi-
ple languages [ 77] and found that many third-party libraries are
transitively introduced to a project. Therefore, they suggest that
developers should look more carefully when using a third-party
librarytounderstandwhatdependenciesareexactlyincluded.Kula
et al. proposed an visualization tool to investigate the history of
libraryupdate[ 80]usingthestatisticsofdependenciesextracted
from the Maven repository. By leveraging their tool, developers
caneasilyidentifyoutdatedlibraries.Yanoetal.alsoproposedan
visualization tool to investigate the popular coupling usages of
third-partylibraries[ 101].Theyfoundthatlibrary Http-Client
3.1andCollections 3.2.1 are frequently used together. The
coupling relations revealed by their studies can help developers
reduce the risks of using incompatible libraries. However, none
of the above studies investigated the dependency conflict issues
caused by the incompatibilities of third-party libraries, which is
well investigatedinthis study.
8 CONCLUSION AND FUTUREWORK
In this paper, we first conducted an empirical study to understand
and characterizeDC issuesbetweenhostproject andthird-party
libraries. We investigated 135 real DC issues collected from 71 Java
projectsof Apacheecosystemtounderstandtheircommon man-
ifestationsandfixingstrategies.Basedonourempiricalfindings,
weformulatethedependencyconflictproblemanditsrootcause.
Furthermore, we designed and implemented an automated tech-
niqueDeccato detect DC issues and assess their severity levels.
The evaluation results show that Deccacan achieve a Precision
of 0.923, a Recallof 0.766, and a F-measure of 0.837. We also ap-
pliedDeccato detecting new DC issues on the latest version of
otherlargeJavaprojects.Encouragingly,developersconfirmedand
fixedthereportedbugsdetectedby Decca.Theyalsoshowedgreat
interests in our proposed tool. These feedbacks from developers
demonstratethe practical usefulnessof Decca.
Infuture,weplantodesigneffectivetechniquestohelpdevelop-
ersautomaticallyrepairDCissues.Anotherplanistoextendour
approach to otherbuildframeworks such as Gradle.
ACKNOWLEDGMENTS
TheauthorsexpressthankstotheanonymousreviewersandHKUST
CASTLEmembersfortheirconstructivecomments.Partofthework
was conducted during the first author’s internship at HKUST in
2018. The work is supported by the Hong Kong RGC/GRF grant
16202917,MSRAgrant,theNationalNaturalScienceFoundation
of China (Grant Nos. 61374178, 61603082 and 61402092) and the
Fundamental Research Funds for the Central Universities (Grant
No.N171704004).
328Do the Dependency Conflictsin MyProjectMatter? ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA
REFERENCES
[1] 2018. Accumulo. https://accumulo .apache.org/. Accessed:2018-02-28.
[2]2018. ACCUMULO4812. https://issues .apache.org/jira/browse/ACCUMULO-
4812. Accessed:2018-02-28.
[3] 2018. Apache. http://www .apache.org/. Accessed:2018-02-28.
[4]2018. Apache contributors. https://github .com/apache/beam/graphs/
contributors . Accessed:2018-02-28.
[5]2018. Apache project category. https://projects .apache.org/
projects.html?category . Accessed:2018-02-28.
[6] 2018. Apex. http://apex .apache.org/. Accessed:2018-01-12.
[7]2018. APEXCORE 805. https://issues .apache.org/jira/browse/APEXCORE-805 .
Accessed:2018-02-28.
[8] 2018. Artemis. https://activemq .apache.org/artemis/ . Accessed:2018-01-12.
[9]2018. ARTEMIS1674. https://issues .apache.org/jira/browse/ARTEMIS-1674 .
Accessed:2018-02-28.
[10] 2018. Atlas. https://atlas .apache.org/. Accessed:2018-01-12.
[11] 2018. Bahir. http://bahir .apache.org/. Accessed:2018-02-28.
[12]2018. BAHIR159. https://issues .apache.org/jira/browse/BAHIR-159 . Accessed:
2018-02-28.
[13] 2018. Beam. https://beam .apache.org/. Accessed:2018-02-28.
[14]2018.BEAM3690. https://issues .apache.org/jira/browse/BEAM-3690 . Accessed:
2018-02-28.
[15] 2018. Brooklyn. https://brooklyn .apache.org/. Accessed:2018-01-12.
[16] 2018. Bugzilla. https://www .bugzilla.org/. Accessed:2018-02-28.
[17] 2018. Carbondata. https://carbondata .apache.org/. Accessed:2018-01-12.
[18] 2018. Cm. https://github .com/Jibesh97/cm . Accessed:2018-01-12.
[19]2018. CURATOR-200. https://issues .apache.org/jira/browse/CURATOR-200 .
Accessed:2018-02-28.
[20]2018. CXF5132. https://issues .apache.org/jira/browse/CXF-5132 . Accessed:
2018-02-28.
[21]2018. DERBY-5429. https://issues .apache.org/jira/browse/DERBY-5429 . Ac-
cessed:2018-02-28.
[22] 2018. Eclipsejetty. https://www .eclipse.org/jetty/ . Accessed:2018-01-12.
[23] 2018. Git. http://git-scm .com/. Accessed:2018-02-28.
[24] 2018. Github. https://github .com/. Accessed:2018-02-28.
[25]2018. Google closure compiler. https://developers .google.com/closure/
compiler/ . Accessed:2018-02-28.
[26] 2018. Gradle. https://gradle .org/. Accessed:2018-02-28.
[27] 2018. Hadoop. http://hadoop .apache.org/. Accessed:2018-02-28.
[28]2018. HADOOP-11656. https://issues .apache.org/jira/browse/HADOOP-11656 .
Accessed:2018-02-28.
[29]2018. HADOOP 15261. https://issues .apache.org/jira/browse/HADOOP-15261 .
Accessed:2018-02-28.
[30]2018. HADOOP8104. https://issues .apache.org/jira/browse/HADOOP-8104 .
Accessed:2018-02-28.
[31]2018. HADOOP7606. https://issues .apache.org/jira/browse/HADOOP-7606 .
Accessed:2018-02-28.
[32]2018. HDFS 10570. https://issues .apache.org/jira/browse/HDFS-10570 . Ac-
cessed:2018-02-28.
[33] 2018. Ignite. https://ignite .apache.org/. Accessed:2018-01-12.
[34]2018. Issues#1. https://github .com/Jibesh97/cm/issues/1 . Accessed:2018-02-28.
[35]2018. Issues #2815. https://github .com/google/closure-compiler/issues/2815 .
Accessed:2018-02-28.
[36]2018. Issues 621. https://github .com/wicketstuff/core/issues/621 . Accessed:
2018-02-28.
[37]2018. Issues #8111. https://github .com/orientechnologies/orientdb/issues/8111 .
Accessed:2018-02-28.
[38] 2018. Javasoze clue. https://github .com/javasoze/clue/ . Accessed:2018-01-12.
[39] 2018. Jira. https://www .atlassian.com/software/jira/ . Accessed:2018-02-28.
[40]2018. Maven classpath. https://maven .apache.org/shared/maven-archiver/
examples/classpath .html. Accessed:2018-02-28.
[41]2018. Maven Dependency Plugin. http://maven .apache.org/components/
plugins/maven-dependency-plugin/ . Accessed:2018-02-28.
[42]2018. Maven enforcer plugin. http://maven .apache.org/enforcer/maven-
enforcer-plugin/ . Accessed:2018-02-28.
[43] 2018. Maven repository. https://maven .apache.org/. Accessed:2018-02-28.
[44]2018. Maven shade plugin. http://maven .apache.org/plugins/maven-shade-
plugin/. Accessed:2018-02-28.
[45] 2018. Oozie. http://oozie .apache.org/. Accessed:2018-02-28.
[46]2018. OOZIE 3185. https://issues .apache.org/jira/browse/OOZIE-3185 . Ac-
cessed:2018-02-28.
[47] 2018. Orientdb. https://orientdb .com/why-orientdb/ . Accessed:2018-01-12.
[48] 2018. OSGI. https://www .osgi.org/. Accessed:2018-02-28.
[49]2018. OSGI classloaders. http://moi .vonos.net/java/osgi-classloaders/ . Ac-
cessed:2018-02-28.
[50] 2018. Parquet. https://parquet .apache.org/. Accessed:2018-01-12.
[51]2018. PARQUET1236. https://issues .apache.org/jira/browse/PARQUET-1236 .
Accessed:2018-02-28.[52]2018. POMreference. https://maven .apache.org/pom.html/. Accessed:2018-
02-28.
[53] 2018. Prestodb. https://prestodb .io/. Accessed:2018-01-12.
[54] 2018. Spark. http://spark .apache.org/. Accessed:2018-02-28.
[55]2018. SPARK23509. https://issues .apache.org/jira/browse/SPARK-23509 . Ac-
cessed:2018-02-28.
[56]2018. SPARK 2848. https://issues .apache.org/jira/browse/SPARK-2848 . Ac-
cessed:2018-02-28.
[57]2018. Springdatasolr. http://projects .spring.io/spring-data-solr/ . Accessed:
2018-01-12.
[58]2018. STORM2382. https://issues .apache.org/jira/browse/STORM-2382 . Ac-
cessed:2018-02-28.
[59]2018. SUREFIRE 851. https://issues .apache.org/jira/browse/SUREFIRE-851 .
Accessed:2018-02-28.
[60]2018. Tomcatexporter. https://github .com/nlighten/tomcat exporter. Accessed:
2018-01-12.
[61] 2018. Uber JAR. https://imagej .net/Uber-JAR . Accessed:2018-02-28.
[62] 2018. wicket. https://wicket .apache.org/. Accessed:2018-01-12.
[63] 2018. Wicketstuff. http://wicketstuff .org/. Accessed:2018-02-28.
[64] 2018. Wildfly. http://wildfly .org/. Accessed:2018-02-28.
[65]2018. YARN5271. https://issues .apache.org/jira/browse/YARN-5271 . Accessed:
2018-02-28.
[66]2018.YARN6414. https://issues .apache.org/jira/browse/YARN-6414/ . Accessed:
2018-02-28.
[67]Maria Carmela Annosi, Massimiliano Di Penta, and Genny Tortora. 2012. Man-
agingandassessingtheriskofcomponentupgrades.In ProductLineApproaches
in Software Engineering (PLEASE), 2012 3rd International Workshop on . IEEE,
9–12.
[68]GabrieleBavota,GerardoCanfora,MassimilianoDiPenta,RoccoOliveto,and
SebastianoPanichella.2013. Theevolutionofprojectinter-dependenciesina
softwareecosystem: The caseofapache.In SoftwareMaintenance (ICSM), 2013
29thIEEE InternationalConference on . IEEE,280–289.
[69]GabrieleBavota,GerardoCanfora,MassimilianoDiPenta,RoccoOliveto,and
Sebastiano Panichella. 2015. How the Apache community upgrades depen-
dencies: an evolutionary study. Empirical Software Engineering 20, 5 (2015),
1275–1317.
[70]JohnBusinge,AlexanderSerebrenik,andMarkvandenBrand.2012. Survival
of Eclipse third-party plug-ins. In Software Maintenance (ICSM), 2012 28th IEEE
InternationalConference on . IEEE,368–377.
[71]NicolasGeoffray,Ga ¨elThomas,CharlesCl ´ement,andBertilFolliot.2008. Alazy
developerapproach:BuildingaJVMwiththirdpartysoftware.In Proceedingsof
the 6th international symposium on Principles and practice of programming in
Java. ACM,73–82.
[72]JamesGosling.2000. TheJavalanguagespecification . Addison-WesleyProfes-
sional.
[73]DavidGrove,GregDeFouw,JeffreyDean,andCraigChambers.1997. Callgraph
construction in object-oriented languages. ACM SIGPLAN Notices 32, 10 (1997),
108–124.
[74]RichardSHallandHumbertoCervantes.2004. AnOSGiimplementationand
experience report. In Consumer Communications and Networking Conference,
2004. CCNC2004. First IEEE . IEEE,394–399.
[75]HubertKleinIkkink.2015. GradleDependencyManagement . PacktPublishing
Ltd.
[76]Sascha Just, Rahul Premraj, and Thomas Zimmermann. 2008. Towards the next
generation of bug tracking systems. In Visual languages and Human-Centric
computing,2008. VL/HCC2008. IEEE symposiumon . IEEE,82–85.
[77]Riivo Kikas, Georgios Gousios, Marlon Dumas, and Dietmar Pfahl. 2017. Struc-
tureandevolutionofpackagedependencynetworks.In MiningSoftwareReposi-
tories(MSR),2017IEEE/ACM14thInternationalConference on . IEEE,102–112.
[78]SunghunKimandEJamesWhiteheadJr.2006. Howlongdidittaketofixbugs?.
InProceedings of the 2006 international workshop on Mining software repositories .
ACM,173–174.
[79]AndrewJKo,BradAMyers,andDuenHorngChau.2006.Alinguisticanalysisof
howpeopledescribesoftwareproblems.In VisualLanguagesandHuman-Centric
Computing, 2006. VL/HCC2006. IEEE Symposiumon . IEEE,127–134.
[80]Raula Gaikovina Kula, Coen De Roover, Daniel German, Takashi Ishio, and
Katsuro Inoue. 2014. Visualizing the evolution of systems and their library
dependencies.In SoftwareVisualization(VISSOFT),2014SecondIEEEWorking
Conference on . IEEE,127–136.
[81]RalfL¨ammel,EkaterinaPek,andJ ¨urgenStarek.2011. Large-scale,AST-based
API-usageanalysisofopen-sourceJavaprojects.In Proceedingsofthe2011ACM
SymposiumonAppliedComputing . ACM,1317–1324.
[82]Sheng Liang and Gilad Bracha. 1998. Dynamic class loading in the Java virtual
machine. Acm sigplan notices 33,10(1998), 36–44.
[83]Yepang Liu, Chang Xu, and Shing-Chi Cheung. 2014. Characterizing and de-
tecting performance bugs for smartphone applications. In 36th International
Conference on Software Engineering,ICSE’14, Hyderabad,India - May 31- June
07,2014. 1013–1024.
329ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA Wang,Wen, Liu, Wu, Wang,Yang,Yu, Zhu, Cheung
[84]TylerMcDonnell,BaishakhiRay,andMiryungKim.2013. Anempiricalstudy
of api stability and adoption in the android ecosystem. In Software Maintenance
(ICSM),201329thIEEE InternationalConference on . IEEE,70–79.
[85]WenMing,ChenJunjie,WuRongxin,HaoDan,andCheungShing-Chi.2018.
Context-Aware Patch Generation for Better Automated Program Repair. In
Proceedingsofthe40thInternationalConferenceonSoftwareEngineering (ICSE
2016).
[86]Audris Mockus,Roy TFielding, and JamesDHerbsleb. 2002. Two casestudies
of open source software development:Apache and Mozilla. ACM Transactions
onSoftwareEngineering and Methodology (TOSEM) 11,3 (2002), 309–346.
[87]VincenzoMusco,MartinMonperrus,andPhilippePreux.2014. AGenerative
ModelofSoftwareDependencyGraphstoBetterUnderstandSoftwareEvolution.
arXiv preprint arXiv:1410.7921 (2014).
[88]Ali Ouni, Raula Gaikovina Kula, Marouane Kessentini, Takashi Ishio, Daniel M
German,and Katsuro Inoue.2017. Search-basedsoftwarelibrary recommenda-
tionusingmulti-objectiveoptimization. InformationandSoftwareTechnology
83(2017), 55–75.
[89]James W Paulson, Giancarlo Succi, and Armin Eberlein. 2004. An empirical
studyofopen-sourceandclosed-sourcesoftwareproducts. IEEETransactions
onSoftwareEngineering 30,4 (2004), 246–256.
[90]Renaud Pawlak, Martin Monperrus, Nicolas Petitprez, Carlos Noguera, and
Lionel Seinturier. 2016. Spoon: A library for implementing analyses and trans-
formationsofjavasourcecode. Software:PracticeandExperience 46,9(2016),
1155–1179.
[91]Steven Raemaekers, Arie van Deursen, and Joost Visser. 2012. Measuring
software library stability through historical versionanalysis. In Software Main-
tenance(ICSM),201228thIEEE InternationalConference on . IEEE,378–387.
[92]Steven Raemaekers, Arie Van Deursen, and Joost Visser. 2014. Semantic ver-
sioning versus breaking changes: A study of the maven repository. In Source
Code Analysis and Manipulation (SCAM), 2014 IEEE 14thInternational Working
Conference on . IEEE,215–224.
[93]RomainRobbes,MirceaLungu,andDavidR ¨othlisberger.2012. Howdodevelop-
ersreacttoapideprecation?:thecaseofasmalltalkecosystem.In Proceedingsof
the ACM SIGSOFT 20th International Symposium on the Foundations of SoftwareEngineering . ACM,56.
[94]AnandAshokSawant,RomainRobbes,andAlbertoBacchelli.2017. Onthereac-
tion to deprecation of clients of 4+ 1 popular Java APIs and the JDK. Empirical
SoftwareEngineering (2017), 1–40.
[95]Alexander Stuckenholz. 2005. Component evolution and versioning state of the
art.ACMSIGSOFTSoftwareEngineering Notes 30,1 (2005), 7.
[96]Ferdian Thung, David Lo, and Julia Lawall. 2013. Automated library recommen-
dation.In ReverseEngineering(WCRE),201320thWorkingConferenceon .IEEE,
182–191.
[97]BalajiVaranasiandSudhaBelida.2014. MavenDependencyManagement. In
Introducing Maven . Springer, 15–22.
[98]LiliWei,YepangLiu,andShing-ChiCheung.2016. TamingAndroidfragmen-
tation:CharacterizinganddetectingcompatibilityissuesforAndroidapps.In
Proceedingsofthe31stIEEE/ACMInternationalConferenceonAutomatedSoftware
Engineering . ACM,226–237.
[99]MingWen,RongxinWu,andShing-ChiCheung.2016. Locus:Locatingbugs
from software changes. In Automated Software Engineering (ASE), 2016 31st
IEEE/ACMInternationalConference on . IEEE,262–273.
[100]Rongxin Wu, Hongyu Zhang, Sunghun Kim, and Shing-Chi Cheung. 2011.
Relink:recoveringlinksbetweenbugsandchanges.In Proceedingsofthe19th
ACMSIGSOFTsymposiumandthe13thEuropeanconferenceonFoundationsof
softwareengineering . ACM,15–25.
[101]Yuki Yano, Raula Gaikovina Kula, Takashi Ishio, and Katsuro Inoue. 2015. VerX-
Combo:Aninteractivedatavisualizationofpopularlibraryversioncombina-
tions.InProceedingsofthe2015IEEE 23rdInternationalConference onProgram
Comprehension . IEEE Press,291–294.
[102]Huan Yu, Xin Xia, Xiaoqiong Zhao, andWeiwei Qiu. 2017. Combining Collab-
orativeFilteringandTopicModelingforMoreAccurateAndroidMobileApp
LibraryRecommendation.In Proceedingsofthe9thAsia-PacificSymposiumon
Internetware . ACM,17.
[103]Thomas Zimmermann, Rahul Premraj, Nicolas Bettenburg, Sascha Just, Adrian
Schroter, and Cathrin Weiss. 2010. What makes a good bug report? IEEE
Transactions onSoftwareEngineering 36,5 (2010), 618–643.
330