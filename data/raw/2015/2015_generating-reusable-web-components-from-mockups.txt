Generating Reusable Web Components from Mockups
Mohammad Bajammal
University of British Columbia
Vancouver, BC, Canada
bajammal@ece.ubc.caDavood Mazinanian
University of British Columbia
Vancouver, BC, Canada
dmazinanian@ece.ubc.caAli Mesbah
University of British Columbia
Vancouver, BC, Canada
amesbah@ece.ubc.ca
ABSTRACT
Thetransformationofauserinterfacemockupdesignedbyagraphic
designertowebcomponentsinthefinalappbuiltbyawebdevel-
operisoftenlaborious,involvingmanualandtimeconsumingsteps.
Weproposeanapproachtoautomatethisaspectofwebdevelop-
ment by generating reusable web components from a mockup. Our
approachemploysvisualanalysisofthemockup,andunsupervised
learning of visual cues to create reusable web components (e.g.,
Reactcomponents).Weevaluatedourapproach,implementedin
a tool called VizMod, on five real-world web mockups, and as-
sessed the transformations and generated components through
comparison with web developmentexperts. The results show that
VizMod achieves on average 94% precision and 75% recall in terms
of agreement with the developers’ assessment. Furthermore, the
refactorings yielded 22% code reusability, on average.
CCS CONCEPTS
•Software and its engineering →Software development tech-
niques;Software prototyping ;
KEYWORDS
web UI, web components, web refactoring, machine learning, com-
puter vision
ACM Reference Format:
Mohammad Bajammal, Davood Mazinanian, and Ali Mesbah. 2018. Gener-
ating Reusable Web Components from Mockups. In Proceedings of the 2018
33rd ACM/IEEE International Conference on Automated Software Engineering
(ASE ’18), September 3–7, 2018, Montpellier, France. ACM, New York, NY,
USA,11pages.https://doi.org/10.1145/3238147.3238194
1 INTRODUCTION
The development of user interfaces (UIs) for web apps is often a
manualandtimeconsumingtask.Inasurveyofmorethan5,700
developers, 51% reported working on app UI design tasks on a
daily basis [ 15], more so than other development tasks, which they
tended to perform every few days. Another study also showed that
an average of 48% of the code size of software is related to the user
interface [39].
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,
topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ’18, September 3–7, 2018, Montpellier, France
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.3238194A common workflow for creating web user interfaces is mockup
based design [40,41]. In this approach, a graphic designer creates a
roughillustrationoftheanticipatedUIdesign,calledthe mockup
orwireframe,usuallythroughagraphicdesignsoftwareoraWYSI-
WYGeditor.ThismockupisthenexportedtoHTMLtoberendered
ina browser. Aweb developerthenexamines themockup andbe-
ginsconstructingwebcomponentsfortheapp,whicharenowadays
implementedinoneofthepopularfront-endframeworkssuchas
Angular [13] or React [16].
The main building block of UI design, and a cornerstone of
these front-end frameworks, is the concept of reusable compo-
nents[14,17],whichareasetofAPIsandcodingpracticesallow-
ing reuse and encapsulation of repeated patterns on the front-end.
Reusablecomponentshelpimprovemodularityandmaintainability,
makethecodemoretestable,andeffectivelyremoveduplication,
by offloading the task of creating repetitive patterns to the webbrowser at runtime. Recent surveys show that using front-end
frameworks is extensively popular among web developers. In one
surveymorethan92%ofaround28,000surveyedwebdevelopers
statedthattheyuseaframeworkratherthanconstructingUIsusingpureHTML[
53].Asaresult,creatingreusablecomponentsisoften
an essential element of building an app’s front-end.
Thiscomponentcreationprocesscanoftenbetimeconsuming
andtedious[ 47]inpractice;itrequiresseveralmanualsteps,includ-
ing the examination of the mockup, checking potential elements
thatmayormaynotbesuitableforconversiontocomponents,con-structingatemplateforcomponentsthatunifiesrepeatedsegments,
adding placeholders for variable content, and refactoring the code
to replace instances with instantiated components [47].
To the best of our knowledge, there has been little to no auto-
mated support in creating these reusable web components from
mockups.Existingtechniqueshelptomanagemockupsthemselves,
butdonotgenerateanycomponents.Forinstance,onesetofap-
proaches[ 44,51]takesamockupasinputandconvertsitslayout
into a responsive code (e.g., through CSS) such that it is flexible to
maintain the layout on different display sizes. Others [ 35] propose
atoolthatoverlaysthemockupasatransparencylayerwhileim-
plementing the UI, and performs a snapping-like functionality that
aligns against various parts of the mockup.
In this paper, we propose a technique, implemented in a tool,
VizMod, tofill this gap byautomatically generating reusable web
componentsfrommockups.Givenawebmockup,ourtechniqueau-
tomatically identifies patterns on the UI, refactors the HTML code,
andcreatesreusablecomponentsforpopularfront-endframeworks
that are already familiar to developers such as React or Angular.
Atthecoreofourapproachisanunsupervisedmachinelearning
processforthedetectionofreusableUIpatterns;weusefeatures
composed of a hybrid of information obtained from the Document
Object Model (DOM) as well as the visual analysis of the UI.
601
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Mohammad Bajammal, Davood Mazinanian, and Ali Mesbah
WeevaluateVizModonfivereal-worldwebmockupsbyauto-
maticallyidentifyingandtransforming120componentinstances
into 25 components. We also ask five experts to manually find
patterns on the mockups and compare the output from our ap-
proach with the manually-identified patterns. Our approach is able
to achieve 94% precision and 75% recall, on average, in correctly
detecting reusable patterns in the UIs.
This paper makes the following main contributions:
•A novel approach for automatically generating web compo-
nents (e.g., React, Angular) from mockups, which is the
first to address this issue, to the best of our knowledge.
•Atechniqueforvisuallyanalyzingthestructureofamockup
andtransformingitintocomponentsviaunsupervisedma-
chine learning.
•Animplementationofourapproach,availableinatoolcalled
VizMod.
•Aqualitativeandquantitativeevaluationof VizModinterms
of its accuracy and reusability of the generated components.
2 MOTIVATING EXAMPLE
Figure1illustrates a part of a sample UI mockup for a job hunting
website.Themockup,oftendesignedbyagraphicsdesignerina
team,providesavisualrepresentationofwhattheUIofthewebapp
issupposedtolooklike.Thecodecorrespondingtothismockupincludes the HTML code, which defines the mockup’s structure
andcontent,andCSScode,whichdefinesitsstyleandpresentation.
Thiscodeistypicallygeneratedautomaticallyusingpopularweb
UI editors (e.g., Muse, Dreamweaver, Visual Studio). The HTML
and CSS code is interpreted by web browsers to render the UI.
Subsequently, a web developer oversees the creation of the final
front-endcodefortheapp.Forthevastmajorityofdevelopers,ama-
jor part of this process is the creation of reusable components [ 53].
Usingcomponentsiskeyinimprovingmodularityandmaintain-
abilityandachievingthesoftwareengineeringbestpracticeofDRY
(Don’t Repeat Yourself). It is also an effective way to remove dupli-
cationsintheapp’scode,whichhasbeenshowntobeassociated
withincreasederror-proneness [ 19],maintenanceeffort[ 28],code
instability [ 37], as well as higher hosting costs and rendering de-
laysduetothetransmissionofredundantdata.Theutilizationof
reusable web components can help to address these issues.
For example, observe in Figure 1that there are four groups of
elements repeated in the mockup, denoted by A,B,CandD.
Notice that the repeated elements are not exactly similar; there aredifferences in terms of, for example, the text and images appearing
within the elements. Nevertheless, the structure of the repeated
elements in each group and their overall visual appearances areunquestionably repeating. Reptitions in UI are unavoidable andneccessary. In fact, repetition is an important aspect of effective
visualdesign[ 33],andisknownasa functionaltechnique toachieve
appealing designs [ 11]. Research has shown that, when a visual
stimuliis repeated, it is more likely to be accepted by people, a
phenomenon called repeated exposure [23].
However,theprocessofcreatingcomponentsisrathertimecon-
suming, requiring manualeffort [ 47]. When analyzingrepetitions
in a mockup to construct components in one of the modern UI
frameworks, developers often face the following challenges:
A
B DC
Figure 1: An example of a web UI mockup.
•They need to visually glance at the mockup and manually iden-
tify the patterns in the UI that can be potentially refactored to
create a reusable component. For instance, for group A, they
need to find all patterns in the page that represents components
similar to the elements inside group A. The repetition might
bespreadacrossthewebpage,makingtheidentificationmore
challenging.Thedeveloperhastorepeatthissameprocessfor
othergroupsofcomponentsonthepage,whichquicklybecomes
a time consuming manual effort. Note that, this identification is
notpossiblebyonlyusingexistingcodeclonedetectiontoolsthat
support HTML code as input (e.g., NiCad [ 49]), due to several
reasons:
(1)These toolsleave outthe visualappearance of theelements
and only work at the source code level, which is sub-optimal
since there are several inherent patterns in HTML which
do not necessarily represent a UI component. For example,
HTMLtablesaredeclaredusinga <table> tagfollowedby
a series of other tags, e.g., <thead>,<tbody>,<colgroup> ,
<tr>, and <td>, nested in a predefined hierarchy. The clone
detector might mark all tables on the page for extraction,
even if they do not visually constitute a reusable component
in theUI. Thesame happensfor severalother elements,such
as (un)ordered, description, and drop-down lists.
(2)Clone detectors need to be configured properly in order to
yield desirable clones. There is usually a large list of parame-
tersand thresholdstotune, andfindingan optimalconfigu-
ration is a laborious task [57].
(3)Clone detectors are not aware of the ultimate reason for
detectingclones,e.g.,thereisnoconfigurationthatcanforce
them to only identify refactorable clones.
•The developer also needs to unifythe patterns to construct a
reusable component in a UI framework. This process needs care-
ful investigation of repeated HTML, to identify how elementscan be unified into one representative component, and whichelementscanbe parameterized whentherearedifferences.For
example,ingroup A,adeveloperwouldexamineeachbutton
602
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. Generating Reusable Web Components from Mockups ASE ’18, September 3–7, 2018, Montpellier, France
DOM in
Web BrowserVisual Elements
Refactored
HTMLPotential
Component Instance
Identification
Identified 
ComponentsVisual UI 
Normalization
UI Component
Generationclass C1 extends 
    React.Component {
  render() {
    return(
      <div> ...
    )
  }
}class C1 extends 
    React.Component {
  render() {
    return(
      <div> ...
    )
  }
}class C1 extends 
    React.Component {
  render() {
    return(
      <div> ...
    )
  }
}
UI Components
(React, Angular, ...)Potential 
Component
Instances
Unsupervised
Visual Matching
Figure 2: Overview of the proposed approach.
inthegroup,anddeterminewhichpartsarerepeatedbetween
the buttons, and which part is variable (e.g., the button icon and
its label). The constructed component should resemble the exact
hierarchy of the original repeated elements, or else the output of
the resulting UI might differ from the original one.
•Moreover,tousetheconstructedcomponent,thedeveloperhasto
instantiate itintheplaceswheretherepeatedelementsoriginally
appeared, with the appropriate parameters (e.g., original texts or
images)topreservetheoutputofthemockup.Forexample,in
groupA,thedeveloperneedstorefactortheoriginalcodeand
replace every occurrence of a button with a call to the button
component, passing along arguments for the button label and its
image.
Tothebestofourknowledge,therehasbeennotechniquesavail-
able to address the aforementioned issues and support developers
in the generation of components.
3 PROPOSED APPROACH
Figure2shows an overview of our proposed approach to automat-
icallygeneratemodularizedreusableUIcomponentsfrommock-
ups. The approach begins by retrieving the DOM of the web app’s
mockup. Next, a visual abstraction is performed to generate a nor-
malized and abstract representation of the web app’s UI layout.
This transforms the mockup into a set of visual elements (VEs) on
whichfurtheranalysisisconducted.Theapproachthenperformsa
dynamic grouping of visual elements, to identify subtrees which
correspondtopotentialinstancesofaUIcomponent.Thisgrouping
isusedinthenextstep,whereanunsupervisedmachinelearning
technique applied on the potential UI component instances identi-
fies UI components. Finally, the actual code for the UI components
is generated by refactoring the original HTML code.
Inthefollowingsubsections,wedescribeeachstepofthepro-
posed approach and illustrate some of their major components and
analysis procedures.
3.1 Definitions
Beforeweproceedtodescribethedetailsoftheproposedapproach,
we begin by declaring a few important definitions that are used
throughout the paper.
Definition 1 ( UI Component ).A UI component cE=/angbracketleftn,N/angbracketright
for a repeated group of UI element trees Ein a web application is atreestructurerootedat n∈N,whereN=T∪Pisasetofabstract
user interface elements. The component includes the templateTand
theplaceholders P. The template of the UI component denotes the
nodes which do not change wherever the component is used (i.e.,
instantiated), while the placeholders allow parameterized nodes.
In this paper, we use the terms UI component andcomponent
interchangeably.
Definition2( ComponentInstance ).Acomponentinstance
i=/angbracketleftcE,f/angbracketrightis a concrete and specific instantiation of a UI component
cE.Componentinstancessharethetemplatepartwithotherinstances
ofthesamecomponent,butdifferintheplaceholderparts.Thefunction
f:P→Vassigns values v∈Vto the placeholders p∈PofcE.
Definition 3( Potential Instance ).A potentialinstance is
asubtreeoftheDOMconstructedforawebapplication’suserinter-
face,representingaconcreteUIelementtreethatis likelytoforma
component instance, but may not be so.
Potentialinstancesareprocessedatmultiplestagesofthepro-
posed approach until they are either discarded or associated with a
component.
3.2 Visual UI Normalization
Inthefirststep oftheapproach,wetakeasinputthe DOMofthe
mockup after it is loaded and rendered in a browser, and perform a
visualnormalization thattransformstheDOMintoasetof visual
elements.Thegoalofthisstepistonormalizethevisualpresentation
ofawebuserinterfaceintoasetofabstractelementsthatsignify
the salient features of the page from a visual perspective, which
mayrepresentpotentialcomponentinstances.Theintuitionbehind
this is that normalization and abstraction can be helpful to achieve
our goal of detecting reusable patterns, since the exact and minute
detailsarelessrelevantwhenidentifyingrepeatedregionsofaweb
page. Furthermore, component instances are generally different
fromeachotherinsomeaspects,whiletheystillhavesimilaroverall
visual appearance. This normalization step enables obtaining a big
picture to identify these potential similarities.
Thevisualnormalizationisachievedasfollows.First,weextract
fromtheDOMasetofnodesthatrepresentvisualcontentofthe
UI, and we refer to each of these as visual elements . We define two
maintypesofvisualelements:textualandgraphical(image).The
extractionoftextcontentisachievedbytraversingtextnodesof
the DOM. More specifically:
ΓT/colonequal{E(node):node∈DOMR
∧node .hasTextContent} (1)
whereΓTis the set of all visual elements that represent text in
the UI,DOMRis the rendered DOM in the web browser, and
E(node)mapsthenodetothecorrespondingelement.Thepredicate
hasTextContent examineswhetherthereisatextassociatedwith
the node, and covers two possibilities: non-empty nodes of type
#TEXT,representingstringliteralsin DOMR,andnodesof input
elementsthathaveanassociatedtextvalue(e.g.,buttonsorlists).
Subsequently, we perform another extraction for image content.
We define this as follows:
603
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Mohammad Bajammal, Davood Mazinanian, and Ali Mesbah
Figure 3: The result of the visual UI normalization stage (as
appliedtothemotivatingexampleofFigure 1).Bestviewed
on a color display.
ΓI/colonequal{E(node):node∈DOMR
∧node .hasImaдeContent} (2)
whereΓIis the set of all visual elements that represent images. As
in the previous case, the predicate hasImaдeContent examines if
there is an image associated with the node. This again has two
possibilities:nodesof <img>elementsandnon-imgnodeswitha
non-null background image attribute.
Subsequently,we usethesetof allvisualelementsto construct
the normalized UI:
UIN=V(ΓI∪ΓT) (3)
whereUINis the resultant normalized UI and Vis a visual projec-
tion operation that generates an image from the union of visual
elements. This is achieved as follows. First, we begin by collecting
thefinalcomputed propertiesofeachelement,whenrenderedinthe
web browser. These properties represent the final state of elements
after the propagation of all changes and events. The properties
we collect are the size, location, and z-orders of these elements.
Next, we assign different colors to each class of visual elements.
We assign green for elements in ΓT, and blue for elements in ΓI.
Whileany arbitrarycolorscould have beenchosen, we chosethese
two colors in order to facilitate faster visual analysis in subsequent
steps, since these two are typically represented in separate color
channels.Figure 3illustratesanexampleoftheoutputgenerated
fromthisvisualnormalizationstep.Ascanbeobserved,theminutedetailsofthepageareabstractedawaywhilethemainandessential
structure of the UI is accentuated.
3.3 Potential Instance Identification
The result of the previous step consists of only a set of visual el-
ements. These visual elements on their own do not necessarily
represent reusable repetitive UI patterns. The goal of this step is to
transformthesetofindividualvisualelementsintoasetof poten-
tialreusableUI componentinstances. Thesepotential component
instanceswillbefurthercheckedandanalyzedinthesubsequent
steps in order to generate a final set of components.
Identifying potential component instances can be an intricate
decision since there are multiple levels of hierarchy that can be
considered. For example, consider group Ain Figure 1. Notice
how the icons in that group would constitute repeated elements.The same is true for the text labels under the icons. Yet another
repetition pattern is taking the icon and text as one component
that is repeated multiple times. Accordingly, in order to identify
potential component instances, we propose an approach that aims
tomaximizetwocomplementaryaspects,namely,thenumberof
repetitionsofacomponent,andtheamountofrepetitionsencapsu-latedwithineachcomponentinstance.Werefertothiscombination
of aspects as the modularization potential, where a high value of
modularization potential indicates a highly reusable UI component.
Our goal is therefore to utilize this modularization potential to
optimize a set of potential instances, Ψ:
Ψ/colonequalargmax
C/productdisplay
ci∈C/barex/barex/barex{ci(γT,γI):γT,γI⊂UIN}/barex/barex/barex(4)
whereCisthesetofallcomponentinstances, ciisapotentialin-
stance, and the optimized function is the modularization potential.
Thisoptimizationyieldsaglobaloptimumsetofpotentialinstances
betweentwoextremes.Atoneendofthespectrum,eachvisualele-
ment represents a component of its own. This yields a sub-optimal
component set that has low modularization potential because of
alack ofrepetitions. Forthiscase, themodularization potentialin
eq.(4)yieldsascoreof1sinceeachcomponentencapsulatesonlya
singleelement.Attheotherendofthespectrum,onemighttheoret-
ically consider the entirecollection of visual elements to represent
a single component that is repeated only once. This results in a
score equal to N, the number of total visual elements, in eq. (4). Ψ,
on the other hand, represents a global optimum between the afore-
mentioned two extremes. Ψcaptures a set of potential component
instances that aims for botha large number of components, and
foraninstancethatinitselfhasalargenumberofUIrepetitions.
The subsequent steps of the approach will therefore only use Ψfor
further analyses and final generation of components.
We now describe the implementation for generating Ψ. Figure4
showsanillustrationofthisprocess.First,weobtainDOMlocators
(e.g., XPath expressions) for each of the visual elements. Next,
starting from these locators as leaf nodes, we iteratively build a
treefromthebottomup(asshowninFigure 4),addingtheDOM
parent of every tree node with each iteration. At each iteration, we
calculate the modularizaton potential of eq. (4), with every node’s
subtreerepresentingapotentialinstance ci.Thepotentialinstances
areillustratedusingtheredoutlinesinFigure 4.Notehowatthe
very first iteration, each potential instance is simply the visual
element itself. In the next iteration, the potential instances grow
larger to include more visual elements as shown by the larger red
outlines at iteration 1. Finally, the iteration that yields the maximal
modularizationisreportedasthe Ψsetandpassedtothesubsequent
stage.
3.4 Unsupervised Visual Matching
The output of the previous step is a set of potential component
instances that maximizesthe modularization potential out ofmany
alternative sets of instances. However, these are only potential
instances that may or maynot actually belong to a component. In
other words, there is still no information as to which subgroupof potential instances do indeed belong together and constitute
a reusable component, versus other potential instances that are
simply visual elements that do not represent repetitive reusable
604
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. Generating Reusable Web Components from Mockups ASE ’18, September 3–7, 2018, Montpellier, France
<HTML>
<DIV> <DIV>
<A> <A> <IMG> <IMG>Iteration
01N
<DIV>
<A> <IMG>
Figure4:Illustrationofthepotentialinstanceidentification
stage.Eachiterationconsidersadifferentgroupofpotentialinstances before selecting an optimum set.
components.Inthisstage,weprocessthesetof potentialcomponent
instances and reduce it into a final set of components.
Inordertocreatethefinalcomponents,weproposeanapproach
that visually examines potential instances and combines them into
components via unsupervised machine learning. The intuition be-
hindadoptingthisapproachisthatifpotentialinstancesmatchwith
otherpotentialinstances,the“potential”qualifiercanbedropped
from these instances and they would be recognized as constituting
acomponenttogether.Inthisapproach,weuseaclusteringmecha-
nismtocreatecomponentsinordertofacilitaterobustmatchingof
potential instances.
We now describe the details of the process. First, we obtain the
screenshotimageofthevisualelementsperpotentialinstance.This
results in one image (containing all visual elements) for each po-
tentialinstance.Next,foreachpotentialinstanceimage,weextract
a feature vector. We compute the feature vector using a vectorized
pixel histogram, which is a process that captures a summary of
theoverallcontentintheinstanceimage.However,unliketypical
approaches from the machine vision literature [ 26,27] where a
binningparameter(aparameterforcategorizingpixels)isrequired,
wegeneratethevectorizedhistogramwithoutrequiringthisparam-
eter.Instead,duetothenatureofvisualnormalizationthatwehave
proposed,onlytwocategoriesneedtobeconsidered:onefortext
visual elements, and another for image visual elements. Therefore,
we finally end up with a feature vector for each potential instance.
Subsequently,wecomputethecosinedistancebetweeneachpair
Ii,Ijof potential instances:
Di,j=1−Ii·Ij
/bardblIi/bardbl/bardblIj/bardbl(5)
Next, we perform an unsupervised clustering process. The selec-
tionofanappropriateclusteringisofparamountimportancedue
toacoupleofchallenges.First,theclusteringcanbechallenging
due to the wide range of possibilities of arrangements and struc-
turesofcomponentinstances.Inotherwords,thereispotentiallya
large range of inter-andintra-component variations. This makes it
difficult to use hierarchical clustering, for instance, due to its very
high sensitivity to outliers and therefore would be a poor choice
forhandlinglargecomponentvariations,andalsoduetoitshigh
dependenceonorderofdata,whichcanmakeitlesseffectiveforde-tectinginstancesfarwayfromeachother.Furthermore,performingacutontheclusteredhierarchiesoftenrequiresspecifyingthenum-
ber of clusters or some other parameter, which can be difficult and
brittle to specify. Density-based algorithms (e.g., DBSCAN) would
notbeeffectiveeither,astheywouldhavedifficultyhandlingthe
variabledensitiespresentbetweenpotentialclustersofinstances.
Accordingly,we optedfor atechnique thatcanbe flexibleenough
tocorrectlyidentifysuchvariationsandbeabletobetterrecognize
the final components. To do this, we select a method that performs
variable-density clustering with a hierarchy of densities [ 5]. The
hierarchy of variable-densities allows the method to automatically
detectstableclustersinaparameter-freefashion.Moreimportantly,
the method is built to handle varying-densities, which becomes
very important when handling the potentially large range of inter-
and intra-component variations.
Once the components have been identified through unsuper-
vised visual matching, we extract the corresponding locator in the
DOM(e.g.,XPaths)perinstance.Thefinalresultisasupersetof
component instance locator sets. This superset is passed on to the
nextstepinordertocombinethecomponentinstancesintofinal
components.
3.5 UI Component Generation
We propose an algorithm that unifies the UI component instances
identified in the previous steps into a component implemented
usingawebframework(e.g.,React,Angular,HTMLWebCompo-
nents[38]).However,insteadofdirectlygeneratingtheframework-
specificcodeforcomponents,weoptforconstructingan intermedi-
atemodel thateffectivelyrepresentscomponentsatahigherlevelof
abstraction. This allows building different translation strategies for
generating the actual code for different frameworks from the same
model, with the added benefit of remaining agnostic to the specific
detailsofaparticularframework.Ourimplementationsupportsthe
React [16] translation strategy, which is the preferred framework
for a significant number of developers in practice [ 52,53]. We first
define the terms used in this step.
Definition4( MappingNodesSet ).LetT={t1...tn}bethe
listofDOMsubtreesfor ninstancesofaUIcomponentidentifiedbythe
previous phases of the approach. A set D={d1∈t1,d2∈t2...dn∈
tn}ofDOMnodescorresponding to Tisa MappingNodesSet, when
every pair (di,dj)of DOM nodes belonging to Daremapping.
Definition5( Mapping ).TwoDOMnodes dianddjaremap-
ping (denoted as di/squiggleleftrightdj) when:
•Bothdianddjare root nodes of their trees, or
•dianddjare not root nodes, and
–di.parent .taд=dj.parent .taд, and
–di.parent/squiggleleftrightdj.parent, and
–dianddjhave the same child index (e.g., they are both the first
child of their parents).
Definition6( ComponentIntermediateModel ).TheCom-
ponent Intermediate Model is a rooted, ordered tree in which each
nodecorrespondstoaMappingNodesSet.Thehierarchyofthistree
follows the mapping DOM nodes’ hierarchy.
Example. Figure5(a)depictstheHTMLcodesnippetscorrespond-
ingtotwoidentifiedUIcomponentinstances.Thecorresponding
605
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Mohammad Bajammal, Davood Mazinanian, and Ali Mesbah
(c)Non-parameterized node Soft-parameterized node Hard-parameterized node
t2t1<DIV>
<DIV>
#TEXT <IMG><SPAN>
#TEXT
<DIV>
<DIV> <DIV>
#TEXT <IMG> #TEXT <SPAN>
#TEXT
(b)foosrc="1.png"
barsrc="2.png"baz
text1 text2
(a) (d)1
2
3 45
1
2
34 5
<component>
  <div>
    <div>      {arg0}
      <img src= {arg1}
>
    </div>
    {arg2}
  </div>
</component><div>
 <div>
   foo   <img src="1.png"/> </div> <span>
   baz
 </span>
</div>
<div>
 <div>
   bar   <img src="2.png"/> </div> <div>
   <span>text1</span>
   text2 </span>
</div>
<component args=["foo", "1.png ", "<span>baz</span>"] />
<component args=["bar", "2.png", <di v><span>text1</span>text2</div>"] /> 
(e)1
2
3
4
5
Figure 5: (a) Initial HTML code fragments. (b) Correspond-
ingDOMsubtrees.(c)TheconstructedComponentInterme-diate Model. (d) The final generated UI component. (e) Thecallsto the generated UI component.
DOMsubtrees,andtheconstructedComponentIntermediateModelforthesesubtreesarerespectivelyshowninFigure 5(b)and(c).The
connectedDOMnodeswithdottedarrowsformMappingNodes
Sets.Noticethatnon-mappingDOMnodesdonotformanodein
theintermediatemodel.ThismodelcanbetranslatedtoaReact-
likecomponentsimilar towhatisshowninFigure 5(d).Finally,the
generated component is instantiated two times in the refactoredHTML code to replace the originally-repeated DOM nodes. The
calls to the component can look like what is shown in Figure 5(e).
Whengeneratingtheactualframeworkcode,eachmodelnode
results into a DOM node in the framework component (as depicted
inFigure 5(d)),whichessentially unifythenodesintheMapping
NodesSettoremoveduplication.Therearethreepossibilitiesfor
framework component DOM nodes:
•When all pairs of DOM nodes in a Mapping Nodes Set have the
sametagandidenticalattributevalues,theycanbeunifiedinone
DOMnodeofthesametag.Forexample,thetwo <div>nodes
in Figure 5corresponding to model node 1form a <div>node
in the component.
•A pair of DOM nodes in a Mapping Nodes Set which have dif-
ferent tag names cannot be unified into one DOM node in the
component (e.g., <span>and<div>corresponding to model
node5in Figure 5). Similar is two text nodes with different
content (e.g., the fooandbarcorresponding to the model node
3in Figure 5). In such cases, the DOM nodes (and the whole
subtree rooted at them) should be hard-parameterized in the
resulting component, i.e., a placeholder should be created. The
originalparameterizedDOMnodesarelaterpassedas arguments
when instantiating the component to recreate the original DOM
hierarchy.
•A pair of DOM nodes in a Mapping Nodes Set that have thesame tag name but different values for one of their attributes
might be unifiable into a DOM node via soft parameterization ,wherethedifferingattributevaluesareparameterized(e.g.,the
<img>tags corresponding to model node 4in Figure 5, with
parameterized srcattribute values). This can be done only if
the used framework supports parameterizing attribute values.
Otherwise, the parameterization should be done as if it was a
hard parameterization.
The intermediate model construction and refactoring algo-
rithm.The inputs of Algorithm 1are the original mockup HTML,
thelistofcomponentinstanceDOMsubtrees,andthetranslation
strategy.TheoutputistherefactoredHTMLwhereinduplication
is removed using the UI components.
Algorithm 1 Component Intermediate Model Generation
Input: The original DOM of the mockup ( DOMoriдinal), UI component
instances DOM subtrees ( subtrees ), UI component translation strategy
(strateдy )
Output: The new DOM after refactoring ( DOMrefactored )
1:model←ConstructEmptyIntermediateModel ()
2:coveredNodes←∅
3:templateTree←getSmallestTree (subtrees )
4:templateNodes ←BFS(templateTree )
5:fortemplateNode∈templateNodes \coveredNodes do
6:coveredNodes←coveredNodes∪{templateNode}
7:mappedNodes←getMappedNodesSet (templateNode ,subtrees )
8:parameterization ←NULL
9:forcurrentNode∈mappedNodes\coveredNodes do
10: parameterization ←compare(templateNode ,currentNode )
11: ifparameterization /nequalNULLthen
12: break
13: end if
14:end for
15:parent←model .getModelNodeFor (templateNode .parent)
16:ifparameterization /nequalNULLthen
17: ifparameterization =SOFT_PARAMETERIZATION
∧strateдy .supportsAttributeParameters ()then
18: model .addSoftParamNode (parent ,mappedNedesSet )
19: coveredNodes←coveredNodes∪mappedNodes
20: else
21: model .addHardParamNode (parent ,mappedNedesSet )
22: coveredNodes←coveredNodes∪
GetAllSubtreeNodes (mappedNodes )
23: end if
24:else
25: model .addNonParamNode (parent ,mappedNedesSet )
26: coveredNodes←coveredNodes∪mappedNodes
27:end if
28:end for
29:DOMrefactored←strateдy .refactor (DOMoriдinal ,model)
Algorithm 1starts by constructing an empty model (line 1), and
anexclusionlist( coveredNodes inline2)thatcontainstheorig-
inal DOM nodes of the component instances which are already
coveredbythealgorithm(e.g.,amodelnodehasbeencreatedfor
them),sothattheyareskippedinfutureiterations.Toconstructthe
intermediatemodel,thealgorithmchoosestheDOMsubtreeofone
of the component instances (i.e., the template subtree ) to follow its
hierarchy.Thetemplatesubtreeistheonewiththesmallestnumber
of DOMnodes,choseninline 3.Thisisbecausetheintermediate
model cannot have more DOM nodes than the smallest subtree,
asitresemblesthe intersection ofthecomponentinstances’DOM
subtrees. The algorithm loops over all the uncovered template sub-
tree’sDOMnodes,followingthesubtree’sbreadth-firsttraversal
606
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. Generating Reusable Web Components from Mockups ASE ’18, September 3–7, 2018, Montpellier, France
order(lines 5to28).EachtemplateDOMnodeiscomparedtoother
DOM nodes of its Mapping Nodes Set (identified according to Defi-
nition4in line7) using the compare() function (line 10), which
returns the type of parameterization needed to unify two given
DOM nodes, and NULLif no parameterization is needed. Note that,
even if one node in a Mapping Nodes Set should be parameterized
when compared to the template DOM node, the resulting model
node will be either hard- or soft-parameterized, thus comparing
other nodes of Mapping Nodes Set is not required (line 12).
The intuition behind comparing nodes in the breadth-first order
is that,across thecomponent instances’DOM subtrees,it is more
likely that the the inner nodes (which define the structure of the
finalUIcomponent)aresimilar,whiletheleafnodes(texts,images)
are more probable to differ. The inner nodes are thus compared
before leaves, also facilitating the identification of Mapping Nodes
SetbasedonDefinition 4,asthenodes’childindicesfollowtheBFS
traversal order.
The algorithm then continues to add a model node for each
Mapping Nodes Set (lines 15to27). First, the model node that has
been created for the template DOM node’s parent (in the previous
runs of the loop) is retrieved from the model (line 15), to which the
new model nodes will be added as children. This effectively allows
themodeltopreservetheoriginalhierarchyoftheinstances’DOM
subtrees. If the model is empty, the new model node will form the
model’sroot. Thesubsequent linesof thealgorithm addthe new
modelnodebasedontheparameterizationtype.Ineachstep,the
DOMnodesintheMappingNodesSetforwhichamodelnodeis
createdareaddedtothe coveredNodes tobeskippedinthenext
iterations. As mentioned, in case of a hard-parameterized model
node, all the DOM nodes belonging to the subtrees rooted underthe corresponding mapping DOM nodes should be marked to be
skipped (e.g., node 5in Figure 5).
Finally,theactualrefactoringisconductedusingtheconstructed
ComponentIntermediateModel(line 29).Thedetailsoftherefactor-
ing are built-in the translation strategy, which can be implemented
virtually for any UI framework of interest.
3.6 Implementation
WeimplementedtheproposedapproachinatoolcalledVizMod[ 36]
(shortfor VisualModularizer).VizModisimplementedinJavaand
Python 3. We use the Selenium web driver to view the mockup
and extract DOM trees and their relevant computed properties. For
clustering, we use the implementation provided by Campello et.
al. [5] and the numpy[56] library for mathematical and numerical
functions.
4 EVALUATION
To evaluate VizMod, we conducted qualitative and quantitative
studies aiming at answering the following research questions:
RQ1Are the refactorings by VizMod’s component generation
correct?
RQ2How effective is VizMod in identifying UI components com-
pared to manual examination by web developers?
RQ3How much code reusability can be achieved through the
proposed refactorings?Inthefollowingsubsections,wediscussthedetailsoftheexperi-
mentsthatwedesignedtoanswereachresearchquestion,together
with the results.
4.1 RQ1: Correctness of Component
Generation Refactorings
4.1.1 Study Design. Fortheproposedcomponentizationapplied
on HTML to be safe, the main criterion is that the original and the
refactored HTMLs must result into the same DOM tree landed into
the users’ web browsers. Consequently, to devise a technique that
can automatically assess the safety of the applied transformations,
we relied on the equivalence of the DOM subtrees rendered in
the web browser, before and after refactoring. If the DOM trees
are the same, given that our refactorings do not change any CSS
style rules, the resulting presentation semantics of the HTML files
remain intact.
To automate this process, we serialized the final DOM trees
rendered in the browser to the pretty-printed HTML code and
comparedthempre-andpost-refactoring.Thisallowsafastcom-
parisonofthestructureoftheDOMtrees.WenormalizedtheDOM
trees by removing text nodes which are empty or contain only
white spaces. This is done because React interprets these nodes
differently [ 18,46] compared to the standard HTML specifications.
4.1.2 Results and Discussion. Usingtheaforementionedtechnique,
we compared the DOM subtrees of the UI component instances
before and after refactoring for the 120 UI component instances
(i.e., 25 UI components) identified by VizMod. The tests has passed
for all subjects, indicating that the refactorings introduced by com-
ponent generation do preserve the DOM trees, and as a result, the
transformations are safe to apply.
4.2 RQ2: UI Component Identification
4.2.1 Study Design. We asked independent expert web developers
to participate in a qualitative study, with the goal of understanding
whattheywouldidentifyasbeingacomponentpatterninawebUI.
Withthisstudy,weaimatevaluatingthe(dis)agreementbetween
theproposedapproachandexpertdevelopersintermsofidentifying
the UI components.
SubjectSystems. Theauthor(s)searchedtheInternettofindmock-
ups suitable for this study (using keywords like “web mockups”,
“webtemplates”,“front-endtemplates”).Ourselectioncriteriafor
choosing mockups were:
•They should be non-trivial, both visually and code-wise (i.e.,
HTML and CSS). Note in Table 1that the mockups are indeed
complex,intermsofthenumberof DOMnodesandCSScode
size.
•The number of subjects should be small and manageable enoughsothatwecanaskparticipantstohighlightpotentialcomponents
inallof them, without causing too much burden, mental fatigue,
or boredom on them which can negatively distort the study.
•TheyshouldonlyrepresenttheUIfront-end,i.e.,withoutback-
end or front-end business logic or functionalities.
Basedonthesecriteriawechosefivemockupsforourevaluation.
Weusethesamemockupsinalltheevaluationexperiments.Table 1
shows descriptive statistics for them.
607
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Mohammad Bajammal, Davood Mazinanian, and Ali Mesbah
Table 1: Subjects’ descriptive statics
Subject# Body size (KB) #DOM nodes CSS size (KB)†
1 18 754 323
2 20 915 279
3 33 1,990 350
4 24 1,226 330
5 49 1,065 254
†Some mockups use CSS frameworks (e.g., Bootstrap). This
corresponds to the total CSS size, including the frameworks.
Participants. We emailed developers who have worked in local
businessesorresearchlabsandaskedthemtovoluntarilypartici-
pateinourstudy.Weattachedazippackagecontainingoursubject
systemstogetherwithalinktoapost-studyquestionnaireaimedat
collectinginformationabouttheparticipants’demographics(e.g.,
numberofyearsofexperienceinsoftwareengineeringingeneral
and in web development in particular, and their self-assessment
onwebapplicationdevelopmentskills).Weaskedthemtomanu-
allyhighlightrepetitionsontheUIofeachsubject(bydrawinga
rectangle on each repetition) and send the results back to us.
Accordingly, we emailed 10 developers and informed them of
thestudy,andaskedthemtoalsopassitontotheircontacts.We
receivedresponsesfromatotaloffivedevelopers.Table 2shows
participants’ demographic information. As it is shown, all the par-
ticipants were quite experienced in web development, as measured
bytheyearsofsoftwareandwebdevelopmentexperienceandtheir
own self assessment.
Comparison with Developers. For each subject, we compared
the components highlighted by the experts with those components
that VizMod automatically identified as UI components. In par-
ticular,whenmorethanhalfoftheexpertshighlightedapattern
on the mockup as repeated, we assume the majority is correct and
consider it as a UI component that our technique should be able
to identify. The performance of VizMod is then determined using
the well-known precision andrecallmeasures. A true positive for
the approach is defined as a UI component that has been manually
identified by more than half of the experts (in our case, three or
more participants). A false positive, on the other hand, is a UI com-
ponent that is reported by the approach, yet less than half of the
expertshaveidentifiedit.Finally,a falsenegative oftheapproach
isaUIcomponentthatisreportedbymorethanhalfoftheexperts,
but the approach could not identify.
Table 2: Demographics of the Participants
Participant#SW dev. Web dev. Web dev. self assessment
(#Years) (#Years) (1–5, 5=Highly Expert)
11 0 5 428 2 4
33 3 4
41 1 3 359 8 54.2.2 Results and Discussion. Table3shows the results of compar-
ing the UI patterns identified by our approach to the UI patterns
identified by participating developers in our experiment. The table
shows the valuesfor true positives, false positives,false negatives,
andfinallyprecisionandrecall.Thevaluesforrecallrangebetween
74% and 100%. We examined the subjects at the lower end of the
range to investigate further. Almost all the components that were
missedbyourapproachhadmanyelementsthathadanimations
or moving sub-elements (e.g., a carousel that changes every few
seconds).Ourtechniquewasnotdesignedwithanimationsinmind.Capturing and analyzing animations can be challenging, due to dif-
ficulties in keeping track of changes over time and deciding which
time instant to take as representative. This might be a possible
venue for future work.
As for the precision, we further examined the nature of false
positives in order to better understand the performance. Following
this examination, we identified another variable while performing
thecomparisonwithparticipants:the potentiallymissedopportu-
nities.Wedefinemissedopportunitiesasthosepatternsthatwere
reported by as few as one developer (but not the majority), as well
asour tool. The reason for introducing this variable is that, by
manually examining the false positives, we noticed that there were
afewpotentialopportunitiesthatweremissedbythemajorityof
developers. We postulate a number of possible causes as to why
such patterns were not reported by the majority of participants:
•Some repeating components were laid out far away from each
other(e.g.,attheverytopandverybottomofthepage).Thisoften
makes it difficult for human developers to remember patterns
thatarenotimmediatelyvisiblewithinthesameview,especially
iftherearelotsofpatternsthattheyhavetokeeptrackof.The
human brain has been shown to have a short-term memory
capacity of only around 3 to 7 objects at a time [ 8]. This fact,
coupled with patterns that are far away from each other andinterlaced with multiple other patterns, can cause humans to
misssomepatterns.Ourapproach,however,isagnostictowherethe pattern is located, and is able to recognize matching patterns
fromfar endsofa webUIjustas easilyaspatterns immediatelynext to each other.
•
Some components included images or icons that were designed
to be faint or barely visible due to artistic reasons. Such icons,
especiallywhenpresentclosetoveryvibrantandlargerepeat-
ing components, are often skipped potentially due to the visual
attention in the brain being directed at the larger clearer pat-
terns.However,duetothevisualnormalizationadoptedinour
approach,suchartisticchoicedonotmakeanydifferenceandthe
pattern is recognizable regardless of how visually pronounced it
is.
For these reasons, we believe that the potentially missed op-
portunities are a better indicator of performance and we include
theirnumbersinthetable.Therefore,wefinallyindicatethatthe
precision andrecall performanceof thetool are93.6% and 75.2%,
respectively, as shown in Table 3.
4.3 RQ3: Code Reusability
4.3.1 Study Design. Wenowproceedtodeterminehowmuchcode
reusabilitycanbeattainedwiththecomponentsgeneratedbythe
608
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. Generating Reusable Web Components from Mockups ASE ’18, September 3–7, 2018, Montpellier, France
Table 3: Comparison of automatically identified components to manually-identified ones by developers
Subject#Identified Refactoring OpportunitiesFN TP FP Precision RecallConsidering PMO†
#Components #Component Instances #PMO Precision Recall
1 5 29 0 19 9 67.9% 100.0% 8 96.4% 77.1%
2 5 27 0 15 2 88.2% 100.0% 2 100.0% 77.3%
3 5 26 6 17 5 77.3% 73.9% 0 77.3% 68.0%
4 6 21 3 9 12 42.9% 75.0% 12 100.0% 84.0%
5 4 17 3 13 4 76.5% 81.3% 3 94.1% 69.6%
Avg. 5 22 70.5% 86.0% 5 93.6% 75.2%
†PMO = Potentially Missed Opportunities.
approach. For each test subject, we compare the size of the HTML
codeofthemockupsbeforeandafterrefactoringasameasureof
how much reusability has been achieved.
LetTrbe the set of DOM subtrees corresponding to the UI com-
ponentinstanceswhicharegoingtoberemovedbyarefactoring
operation, r,fromtheoriginalHTML.Therefactoring raddsthe
necessarycodewhichunifies TrsubtreesintoaUIcomponent ur
totheoriginalHTMLcode.Moreover, rreplacesTrsubtreeswitha
setCrofcallstoinstantiate ur.Accordingly,thesizereduction SRr
for the refactoring ris computed as:
SRr=/summationdisplay
t∈TrsizeOf(t)−sizeOf(ur)+/summationdisplay
c∈CrsizeOf(c)(6)
wheretis a component instance, cis a component instantiation
call, and sizeOf(x)is the number of bytes corresponding to x
when serialized to HTML. In an HTML mockup, there might be
several sets of component instances (i.e., several UI components
might be created). The overall size reduction SR, which is achieved
by applying the set Rof all refactoring opportunities found in a
mockup, is calculated as SR=/summationtext
r∈RSRr.
Wecalculatethesizereductionintwodifferentways:1)basedon
animplementationusingaUIframework(whichwehavechosento
beReact),and2)basedontherepresentationcontainedintheCom-ponentIntermediateModel.ThisisbecauseeachUIframework(e.g.,
React,Angular)hasitsownsyntaxandidiomaticmechanisms
for creating UI components and instantiating them. As a result, the
actualsizereductionwouldbedifferentdependingonwhich,and
how,aUIframeworkisused.AllUIframeworks,however,follow
the same basic principle: the set of DOM nodes that can be uni-
fied into single DOM nodes form a templatefor the UI component,
while other nodes form the parameters (i.e.,placeholders )i nt h e
UI component. These placeholders are filled with the arguments
passed when calling the UI framework. As a result, calculating the
size reduction based on the nodes and arguments identified when
constructing the Component Intermediate Model allows a more
accuratedeterminationofhowthealgorithm intrinsically performs
intermsofcodereusability,regardlessofthedifferencesbetween
the many possible UI frameworks that can be used.
Moreover, when using a third-party UI framework, it is usually
required that the framework’s JavaScript library code is imported
at the client-side so that the web browser is able to render the
UI, potentially increasing the overall size of the client-side code.SubjectsSize Reduction (%)Intrinsic performance Performance with React
0
1234510203035.5%
19.3% 20.3%
9.2%21.3%
16.0% 14.9%
6.0%19.3%
15.0%
Figure6:Codereusabilityperformanceachievedbythepro-
posed component generation, as measured by final size re-
duction.
However,ifthewebapplicationwantstoenjoythemaintainabil-
ity benefits of the UI framework, the JavaScript files should be
imported anyway. As mentioned, this is an extensively-popular
trend among the developers [ 52,53]. Notwithstanding, if develop-
ersoptforusingstandardHTMLWebComponents [ 38]instead
ofthird-partyUIframeworks,therewillbenoburdenintermsof
the additional imported JavaScript files. As a result, when report-
ing the size measurements for React, we only consider the code
generatedbyourapproachforimplementingUIcomponents,not
React’s own core JavaScript code.
4.3.2 Results and Discussion. Figure6illustrates the results of ap-
plying the proposed refactorings on the test subjects. Observe that,
using React implementation, refactoring UI components results
inreducingthesizeoftheHTMLcodeby6%–19.34%,withanav-
erageof11.56%.The intrinsicperformanceofthealgorithmitself,
however, is higher: 14.90%–35.54%, with an average of 18.96%. This
difference highlights that React components require quite consid-
erableamountofaddedcodetotheoriginalDOMinformationof
the UI component instances. For example, a UI component shown
in Figure 5(d) needs to be wrapped into a function named render
implemented in a JavaScript class that extends the internal Re-
actclass, React.Component .Wealsoneedtoaddadditionalcode
to pass arguments to the UI components for each UI component
instance. As mentioned, using another UI framework can yielddifferent saving ratios. It is for these reasons that reporting the
intrinsic performance is important.
Itisworthmentioningthatthissavingisnotmeanttoreplace
existingtechniquesthat,forinstance,minifyHTMLbyremoving
609
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Mohammad Bajammal, Davood Mazinanian, and Ali Mesbah
whitespace,orviaanyotherreductionapproach.Rather,whatever
savingsobtainedfromthecomponentscancomplementthemby
adding even more saved bytes on top of what they would normally
save.
5 DISCUSSION
Context within web development. The approach we present in
this paperrefactors repetitions in theUI and mergesthem into a
template, which is finally converted into a component in one ofthecommonfront-endframeworks(e.g.,React,Angular).This
automates one of the initial steps in making a full-fledged web app
UI,whichisoftentimeconsumingandisdonemanually.Theuseof
thisapproach,ofcourse,wouldnotmeanthatthewebappisready
tolaunchtoclientsandthedevelopmentprocessisfinished.The
developer would use these components and continue the develop-
ment,by,e.g.,addingbusinesslogic,handlingevents,connectingto
databases or other sources. Furthermore, the approach we present
in this paper is for modularizing the UI view itself, and is there-
foreorthogonaltotheremainingcomponentsofthearchitecture
patternoftheapp(e.g.,Model-view-controller(MVC),Model-view-
presenter (MVP)) and to any backend server functionality.
Threats to validity. We chose test subjects (i.e., mockups) ran-
domlyfromtheInternetwiththementionedcriteriainSection 4.2.1,
to avoid any selection bias. Plus, the evaluation participants are
expert web developers with different years of web development ex-
perience,mitigatingthethreatstotheinternalvalidityofthestudy.
The mockups are diverse and complex enough to be representative
ofreal-worldappfront-ends,mitigatingtheexternalvalidityofthe
study by making the results generalizable. To make the study repli-
cable, we have made VizMod’s source code, evaluation subjects,
and the anonymized participants’ responses available online [ 36].
6 RELATED WORK
Visual analysis. There exist a few techniques that analyze web
applicationsfromavisualperspective.Choudharyetal.[ 6]propose
anapproachthatdetectscross-browsercompatibilitybyexamin-
ing visual differences between the same app running in multiple
browsers. Burg et al. [ 3] present a tool that helps developers un-
derstand the behavior of front-end apps. It allows developers to
specifywhichelementtheyareinterestedin,thentracksthatele-
mentfor anyvisual changesandthe correspondingcode changes.
Bajammaletal.[ 1]proposeanapproachtoanalyzeandtestweb
canvas element through visual inference of the state of the can-
vas and its objects, and allowing canvas elements to be testable
usingcommonDOMtestingapproaches.Incontrasttoourwork,
none of these studies aims to automatically identify and extract
web components. Stocco et al. [ 22,54] explore visual techniques
for web testing applications, including visual-based test repair and
techniques for migrating DOM-based tests to visual tests.
Clone detection. There is a large body of work on clone detec-
tion in conventional source code [ 45,48,50]. Some techniques also
exist targeting web artifacts, such as for identifying duplicated
content [ 2] or script function clones [ 4,21], and quantifying the
structural similarity across pages [ 10]. A number of existing publi-
cations[12,24,25,29]proposetemplateidentificationforJavacodeby defininga number of heuristicsto compute codesimilarity. Ra-
japakseandJarzabek[ 42]useCCFinder[ 20]toidentifyduplication
inwebapplications.Synytskyyetal.[ 55]useanislandgrammer to
identify cloned HTML forms and tables. Cordy et al. [ 7] propose a
language-independenttechniquetoidentifyexact/near-missclones
(initially in HTML) using island grammars, pretty-printing and
textualdifferencing.Inspiredbythatwork,NiCadclonedetector
is proposed [49].
Transformation and refactoring. Various techniques are pro-
posed to convert static pages to dynamic ones [ 2,55], to gener-
alizedynamicwebpages[ 9,43],ortofindsimilarfunctionalities
acrosswebpages[ 10].Othertechniques[ 34]useclusteringtogroup
similarstaticwebpagestogethertoextractsingle-pagetemplates.
Pattern mining techniques are used [ 30–32] for identifying and
refactoring duplicated CSS code in web apps. In contrast to our
work,noneofthesestudiesaimsatautomaticallyidentifyingand
extracting web components from mockups.
7 CONCLUSIONS
Thedevelopmentofawebappfront-endinvolvesmultiplestake-
holders, chief among them the graphics designer and web devel-oper. A UI mockup designed by the graphics designer has to beanalyzed and processed by a web developer in order create the
app’sfront-endcode,ataskthatislaboriousandinvolvesmanual
timeconsumingsteps.Inthispaper,weproposedanapproachto
automatethisaspectofwebdevelopmentbygeneratingreusable
webcomponentsfromamockup.Weimplementedourapproach
in a tool called VizMod, and evaluated on real-world web mock-ups and assessed its generated components through comparison
withexpertdevelopers.Itachievesanaverageof94%precisionand
75%recallintermsofagreementwiththedevelopers’assessment,
performstherefactoringsinacorrectmanner,andthecomponents
achieve a 22% reusability, on average.
REFERENCES
[1]Mohammad Bajammal and Ali Mesbah. 2018. Web Canvas Testing through
VisualInference.In ProceedingsoftheInternationalConferenceonSoftwareTesting,
Verification and Validation (ICST). IEEE Computer Society, 12 pages.
[2]Cornelia Boldyreff and Richard Kewish. 2001. Reverse engineering to achieve
maintainableWWWsites.In Proceedingsofthe8thWorkingConferenceonReverse
Engineering (WCRE). 249–257.
[3]Brian Burg, Andrew J Ko, and Michael D Ernst. 2015. Explaining visual changes
in web interfaces. In Proceedings of the 28th Annual ACM Symposium on User
Interface Software & Technology. ACM, 259–268.
[4]FabioCalefato,FilippoLanubile,andTeresaMallardo.2004. Functionclonedetec-
tion in web applications: a semiautomated approach. Journal of Web Engineering
3, 1 (2004), 3–21.
[5]RicardoJGBCampello,DavoudMoulavi,andJörgSander.2013. Density-based
clusteringbasedonhierarchicaldensityestimates.In Pacific-Asiaconferenceon
knowledge discovery and data mining. Springer, 160–172.
[6]ShauvikRoyChoudhary,MukulRPrasad,andAlessandroOrso.2012.Crosscheck:
Combining crawling and differencing to better detect cross-browser incompati-
bilitiesinwebapplications.In SoftwareTesting,VerificationandValidation(ICST),
2012 IEEE Fifth International Conference on. IEEE, 171–180.
[7]James R Cordy and Thomas R. Dean. 2004. Practical language-independent
detection of near-miss clones. In Proceedings of the 14th Conference of the Centre
for Advanced Studies on Collaborative Research (CASCON). 1–12.
[8]Nelson Cowan. 2001. The magical number 4 in short-term memory: A reconsid-
eration of mental storage capacity. Behavioral and Brain Sciences 24, 1 (2001),
87–114.
[9]A. De Lucia, R. Francese, G. Scanniello, and G. Tortora. 2004. Reengineering
webapplicationsbasedonclonedpatternanalysis.In Proceedingsof12thIEEE
International Workshop on Program Comprehension. IEEE, 132–141.
610
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. Generating Reusable Web Components from Mockups ASE ’18, September 3–7, 2018, Montpellier, France
[10]A.DeLucia,RitaFrancese,G.Scanniello,andG.Tortora.2005. Understanding
cloned patterns in web applications. In Proceedings of the 13th International
Workshop on Program Comprehension (ICPC). IEEE, 333–336.
[11] Donis A Dondis. 1974. A primer of visual literacy. MIT Press.
[12]StefanFischer,LukasLinsbauer,RobertoErickLopez-Herrejon,andAlexander
Egyed. 2014. Enhancing clone-and-own with systematic reuse for developing
software variants. In Software Maintenance and Evolution (ICSME), 2014 IEEE
International Conference on. IEEE, 391–400.
[13] Google Inc. 2016. Angular. https://angular.io/ Accessed: 15 February 2018.
[14] Google Inc. 2017. Angular CoreDocumentation: Components. https://angular.
io/api/core/Component Accessed: 4 April 2018.
[15]IDC. 2015. Mobile Trends Report. https://www.appcelerator.com/
resource-center/research/2015-mobile-trends-report/ Accessed: 15 February
2018.
[16]JordanWalke,Facebook,Instagramandcommunity.2013. React-AJavaScript
libraryforbuildinguserinterfaces. https://reactjs.org/ Accessed:15February
2018.
[17]JordanWalke,Facebook,Instagram,andcommunity.2013. Reactdocumentation:
React.Component. https://reactjs.org/docs/react-component.html Accessed:4
April 2018.
[18]Jordan Walke, Facebook, Instagram and community. 2014. JSX Whitespace.
https://reactjs.org/blog/2014/02/20/react-v0.9.html#jsx-whitespace Accessed: 16
April 2018.
[19]ElmarJuergens,FlorianDeissenboeck,BenjaminHummel,andStefanWagner.
2009. Do code clones matter?. In Proceedings of the 31st International Conference
on Software Engineering (ICSE). 485–495.
[20]Toshihiro Kamiya, Shinji Kusumoto, and Katsuro Inoue. 2002. CCFinder: A
multilinguistictoken-basedcodeclonedetectionsystemforlargescalesource
code.IEEE Trans. on Software Engineering 28, 7 (2002), 654–670.
[21]FilippoLanubileandTeresaMallardo.2003. Findingfunctionclonesinwebap-
plications.In Proceedingsofthe7thEuropeanConferenceonSoftwareMaintenance
and Reengineering (CSMR). 379–386.
[22]MaurizioLeotta,AndreaStocco,FilippoRicca,andPaoloTonella.2018. PESTO:
Automated migration of DOM-based Web tests towards the visual approach.
Software Testing, Verification And Reliability 28, 4 (2018), e:1665.
[23]William Lidwell, Kritina Holden, and Jill Butler. 2010. Universal principles of
design, revised and updated. Rockport Pub.
[24]Yun Lin, Guozhu Meng, Yinxing Xue, Zhenchang Xing, Jun Sun, Xin Peng, Yang
Liu,WenyunZhao,andJinsongDong.2017. Miningimplicitdesigntemplates
foractionablecodereuse.In AutomatedSoftwareEngineering(ASE),201732nd
IEEE/ACM International Conference on. IEEE, 394–404.
[25]Yun Lin, Xin Peng, Zhenchang Xing, Diwen Zheng, and Wenyun Zhao. 2015.Clone-based and interactive recommendation for modifying pasted code. In
Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering.
ACM, 520–531.
[26]Guang-Hai Liu, Lei Zhang, Ying-Kun Hou, Zuo-Yong Li, and Jing-Yu Yang. 2010.
Imageretrievalbasedonmulti-textonhistogram. PatternRecognition 43,7(2010),
2380–2389.
[27]NunoVieiraLopes,PedroAMogadourodoCouto,HumbertoBustince,andPedro
Melo-Pinto.2010. Automatichistogramthresholdusingfuzzymeasures. IEEE
Transactions on Image Processing 19, 1 (2010), 199–204.
[28]Angela Lozano and Michel Wermelinger. 2008. Assessing the effect of clones on
changeability.In Proceedingsofthe24thIEEEInternationalConferenceonSoftware
Maintenance (ICSM). 227–236.
[29]JabierMartinez, Tewfik Ziadi,Tegawende FBissyande, JacquesKlein,and Yves
Le Traon. 2015. Automating the extraction of model-based software product
lines from model variants (T). In Automated Software Engineering (ASE), 2015
30th IEEE/ACM International Conference on. IEEE, 396–406.
[30]Davood Mazinanian and Nikolaos Tsantalis. 2016. Migrating Cascading StyleSheets to Preprocessors by Introducing Mixins. In Proceedings of the 31st
IEEE/ACM International Conference on Automated Software Engineering (ASE)
(ASE 2016). 672–683.
[31]Davood Mazinanian and Nikolaos Tsantalis. 2017. CSSDev: Refactoring duplica-
tioninCascadingStyleSheets.In Proceedingsofthe39thInternationalConference
on Software Engineering (ICSE) Companion (ICSE 2017).4 .
[32]Davood Mazinanian, Nikolaos Tsantalis, and Ali Mesbah. 2014. Discovering
Refactoring Opportunities in Cascading Style Sheets. In Proceedings of the 22nd
ACMSIGSOFTInternationalSymposiumonFoundationsofSoftwareEngineering
(FSE). 496–506.[33]Philip B. Meggs. 1992. Type and Image: The Language of Graphic Design.V a n
Nostrand Reinhold. 206 pages.
[34]AliMesbahandArievanDeursen.2007. MigratingMulti-pageWebApplications
to Single-page Ajax Interfaces. In Proceedings of the Conference on Software
Maintenance and Reengineering (CSMR). IEEE Computer Society, 181–190.
[35]BogdanMihalcea.2014. Userinterfaceconstructionwithmockupimages. US
Patent 8,650,503.
[36]Mohammad Bajammal, Davood Mazinanian, and Ali Mesbah. 2018. VizMod tool
repository. https://github.com/msbajammal/vizmod
[37]Manishankar Mondal, Chanchal K. Roy, and Kevin A. Schneider. 2012. An
empiricalstudyonclonestability. AppliedComputing Review 12,3(Sept.2012),
20–36.
[38]Mozilla Developer Network. 2017. Web Components. https://developer.mozilla.
org/en-US/docs/Web/Web_Components Accessed: 4 April 2018.
[39]BradAMyersandMaryBethRosson.1992. Surveyonuserinterfaceprogram-
ming. In Proceedings of the SIGCHI conference on Human factors in computing
systems. ACM, 195–202.
[40]Mark W. Newman and James A. Landay. 2000. Sitemaps, Storyboards, andSpecifications: A Sketch of Web Site Design Practice. In Proceedings of the 3rd
Conference on Designing Interactive Systems: Processes, Practices, Methods, and
Techniques (DIS). 263–274.
[41]FatihKursatOzenc,MisoKim,JohnZimmerman,StephenOney,andBradMyers.
2010. HowtoSupportDesignersinGettingHoldoftheImmaterialMaterialof
Software.In ProceedingsoftheSIGCHIConferenceonHumanFactorsinComputing
Systems (CHI). 2513–2522.
[42]DamithC.RajapakseandStanJarzabek.2005. AnInvestigationofCloninginWeb
Applications.In Proceedingsofthe5thInternationalConferenceofWebEngineering
(ICWE). 252–262.
[43]Damith C. Rajapakse and Stan Jarzabek. 2007. Using Server Pages to UnifyClones in Web Applications: A Trade-Off Analysis. In Proceedings of the 29th
International Conference on Software Engineering (ICSE). 116–126.
[44]ÓscarSánchezRamón,JesúsSánchezCuadrado,JesúsGarcíaMolina,andJean
Vanderdonckt. 2016. A layout inference algorithm for Graphical User Interfaces.
Information and Software Technology 70 (2016), 155–175.
[45]Dhavleesh Rattan, Rajesh Bhatia, and Maninder Singh. 2013. Software clone
detection:Asystematicreview. InformationandSoftwareTechnology 55,7(2013),
1165 – 1199.
[46]React Issues on GitHub. 2017. White-space between inline elements #1643.
https://github.com/facebook/react/issues/1643 Accessed: 16 April 2018.
[47]ReactJS.2018. ThinkinginReact. https://reactjs.org/docs/thinking-in-react.html
Accessed: 15 February 2018.
[48]Chanchal Kumar Roy and James R Cordy. 2007. A survey on software clone
detection research. Technical Report. Queen’s School of Computing.
[49]ChanchalK.RoyandJamesR.Cordy.2008. NiCad:Accuratedetectionofnear-
miss intentional clones using flexible pretty-printing and code normalization. In
Proceedings of the 16th IEEE International Conference on Program Comprehension
(ICPC). 172–181.
[50]ChanchalK.Roy,JamesR.Cordy,andRainerKoschke.2009. Comparisonand
evaluation of code clone detection techniques and tools: A qualitative approach.
Science of Computer Programming 74, 7 (2009), 470 – 495.
[51]Nishant Sinha and Rezwana Karim. 2013. Compiling Mockups to Flexible UIs. In
Proceedings of the 2013 9th Joint Meeting on Foundations of Software Engineering
(ESEC/FSE). 312–322.
[52]StackOverflow. 2017. Developer Survey Results. https://insights.stackoverflow.
com/survey/2017 Accessed: 4 April 2018.
[53]stateofjs.com. 2017. Worldwide usage of JavaScript front-end libraries. https:
//stateofjs.com/2017/front-end/results/ Accessed: 10 April 2018.
[54]Andrea Stocco, Rahulkrishna Yandrapally, and Ali Mesbah. 2018. Visual Web
TestRepair. In Proceedings ofthe 26thACM JointEuropean SoftwareEngineering
Conference and Symposium on the Foundations of Software Engineering (ESEC/FSE
2018). ACM.
[55]Nikita Synytskyy, James R. Cordy, and Thomas R. Dean. 2003. Resolution of
staticclonesindynamicWebpages.In Proceedingsofthe5thIEEEInternational
Workshop on Web Site Evolution (WSE). 49–56.
[56]Stéfan van der Walt, S Chris Colbert, and Gael Varoquaux. 2011. The NumPy
array:astructureforefficientnumericalcomputation. ComputinginScience&
Engineering 13, 2 (2011), 22–30.
[57]TiantianWang,MarkHarman,YueJia,andJensKrinke.2013.SearchingforBetter
Configurations: A Rigorous Approach to Clone Evaluation. In Proceedings of the
9th Joint Meeting on Foundations of Software Engineering (ESEC/FSE). 455–465.
611
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. 