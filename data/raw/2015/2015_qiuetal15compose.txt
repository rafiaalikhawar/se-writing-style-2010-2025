Compositional Symbolic Execution with
Memoized Replay
Rui Qiu∗, Guowei Yang†, Corina S. P ˘as˘areanu‡and Sarfraz Khurshid∗
∗University of Texas, USA, {ruiqiu, khurshid }@utexas.edu
†Texas State University, USA, gyang@txstate.edu
‡CMU/NASA Ames, USA, corina.s.pasareanu@nasa.gov
Abstract —Symbolic execution is a powerful, systematic analy-
sis that has received much visibility in the last decade. Scalability
however remains a major challenge for symbolic execution. Com-
positional analysis is a well-known general purpose methodology
for increasing scalability. This paper introduces a new approach
for compositional symbolic execution . Our key insight is that
we can summarize each analyzed method as a memoization
tree that captures the crucial elements of symbolic execution,
and leverage these memoization trees to efﬁciently replay the
symbolic execution of the corresponding methods with respect
to their calling contexts. Memoization trees offer a natural way
to compose in the presence of heap operations, which cannot
be dealt with by previous work that uses logical formulas as
summaries for compositional symbolic execution. Our approach
also enables efﬁcient target oriented symbolic execution for error
detection or program coverage. Initial experimental evaluation
based on a prototype implementation in Symbolic PathFinder
shows that our approach can be up to an order of magnitude
faster than traditional non-compositional symbolic execution.
I. I NTRODUCTION
Symbolic execution is a powerful, systematic program anal-
ysis technique that has found many applications in recent
years, ranging from automated test case generation and error
detection, to regression analysis, security analysis, continuous
testing and program repair [4], [18], [22]. The technique
enumerates the program paths (up to a given bound) and
records the conditions on the inputs to follow the different
paths, as dictated by the branches in the code. Off-the-shelf
constraint solvers [1] are used to check the satisﬁability of
path conditions to discard those paths that are found to be
infeasible. In practice, scalability is a major challenge in
symbolic execution due to high computational demand.
Compositional analysis is a well-known general purpose
methodology that has been used with success to scale up
static analysis and software veriﬁcation [6], [7], [9], [13],
including symbolic execution [3], [10], [12]. The main idea is
to analyze each elementary unit (i.e., a method or a procedure)
in the program separately, and to store the analysis results in a
summary (for that method or procedure), encoding the input-
output behavior of the unit. Whole-program analysis results
are then obtained by incrementally composing and utilizing
the previously built summaries.
This paper introduces a new approach for compositional
symbolic execution . Our key insight is that we can summarize
each analyzed method as a memoization tree that captures
the crucial elements of symbolic execution, i.e. the choicesmade along each path and the input path conditions (including
constraints on the program’s heap) for complete paths. The
memoization tree succinctly summarizes the feasible paths
through the method and it does not explicitly encode the
method’s outputs as is typically done in previous approaches.
Instead, we deﬁne a composition operation that uses the
memoization trees, in a bottom-up fashion, for efﬁcient replay
of symbolic execution of the methods in different calling
contexts. During composition, constraint solving is only used
at a method call site to determine which paths in the method
summary are still feasible; these paths are then explored
without any further constraint solver calls and the search is
guided by the choices recorded in the memoization tree. This
results in signiﬁcant savings in analysis time due to reduced
number of solver calls, as compared to non-compositional
symbolic execution.
A key advantage of using the memoization trees is that they
offer a natural way of handling the heap, which cannot be dealt
with by previous work that uses logical formulas as summaries
for compositional symbolic execution [3], [10], [12]. When
composing a method summary with the actual calling context,
we ﬁrst perform a partial check of the heap constraints on
the (possibly symbolic) heap of the calling context and then
re-execute the method guided by the memoization tree, which
naturally reconstructs the heap, and re-computes the outputs
of the method.
We enhance our approach for two common application sce-
narios of symbolic execution: error-detection and test genera-
tion to achieve a certain coverage. We introduce two heuristics
that speciﬁcally target reachability of program statements and
states of interest, and thus facilitate error detection. Speciﬁ-
cally, we explicitly mark memoization tree nodes along paths
that lead to a target, e.g., an assert statement that may lead
to an assertion violation. The heuristics use this information
to prioritize and prune the exploration of symbolic paths
in a bottom-up incremental way, with the goal of quickly
propagating up the information about the speciﬁc target.
While our focus in this paper is on improving scalability
of symbolic execution using our compositional approach, it
offers a number of other potential beneﬁts. For example, our
approach enables more efﬁcient selective regression testing,
where the memoization trees are stored off-line and re-used,
e.g., when the code in the caller method is modiﬁed but
the callee is unmodiﬁed. Moreover, our approach lends itself
2015 IEEE/ACM 37th IEEE International Conference on Software Engineering
978-1-4799-1934-5/15 $31.00 © 2015 IEEE
DOI 10.1109/ICSE.2015.79632
2015 IEEE/ACM 37th IEEE International Conference on Software Engineering
978-1-4799-1934-5/15 $31.00 © 2015 IEEE
DOI 10.1109/ICSE.2015.79632
2015 IEEE/ACM 37th IEEE International Conference on Software Engineering
978-1-4799-1934-5/15 $31.00 © 2015 IEEE
DOI 10.1109/ICSE.2015.79632
1int p(int x, int y){
2 if(x>y){
3x −−;
4}else {
5y + + ;
6}
7 if(x = = y) {
8 return x;
9}else {
10 return y;
11 }
12}1int q(int a, int b){
2 if(a>b){
3 return p(a + 1, b −10);
4}else {
5 return p(b + 1, a −10);
6}
7}
Fig. 1. Caller method q and callee method p
naturally to parallel analysis for both building and re-use of
summaries; method summaries for different methods can be
constructed in parallel and memoized path conditions can be
checked for the current calling context in parallel.
We implemented our approach into a prototype tool that
builds on Symbolic PathFinder (SPF) [19]. The experimental
results on 10 subjects show that compared to traditional non-
compositional symbolic execution, our approach is up to an
order of magnitude faster and has up to 88% reduction in
constraint solver calls.
II. B ACKGROUND
Symbolic execution [8], [16] is a technique that analyzes a
program using symbolic values for inputs rather than actual
concrete inputs as normal execution of the program would.
In symbolic execution, program variables and outputs are
computed as expressions in terms of those symbols from
inputs. To determine what inputs lead to which paths of the
program to be executed, symbolic execution introduces path
constraints ( PC) that are boolean expressions in terms of input
symbols for possible choice of branch conditions in program.
Asymbolic execution tree represents the paths taken in a
program during symbolic execution. Each node in the tree
represents a state of the symbolic execution, which reﬂects a
set of states in actual concrete execution. Edges between nodes
stand for transitions among states.
We illustrate symbolic execution on a program in Figure 1
that has two methods pandq. Method ptakes two integers
xand yas input and returns an integer according to the
relationship between xandy. Method qalso takes two integers
aandbas input and invokes method pto return an integer. We
treat method qas the start point of symbolic execution. Figure
2 shows the complete symbolic execution tree of method q.
Initially, PCis true, and symbolic variables aand bhave
symbolic values AandBrespectively. Program variables are
then set symbolic values in terms of AandB. For example,
when method pis invoked in line 3 in method q, the values
for input of method p(xand y) are A+1 and B−10
respectively. For each conditional statement in the program,
PCwill be updated with all possible choices from the branch
condition so that all possible paths are explored. Whenever PC
is updated, it is checked for satisﬁability by calling the off-the-
shelf constraint solver. If PCbecomes false (not satisﬁable),
which means the corresponding path is infeasible, symbolic
execution does not continue for that path. For example, in
method qthere are four paths that are infeasible due to the
a: A, b: B
PC: true
a: A, b: B
PC: A > Ba: A, b: B
PC: A <= B
p(A+1, B-10) p(B+1, A-10)
x: A+1, y: B-10
PC: A+1>B-10
&& A>Bx: A+1, y: B-10
PC: A+1<=B-10
&& A>Bx: B+1, y: A-10
PC: B+1>A-10
&& A<=Bx: B+1, y: A-10
PC: B+1<=A-10
&& A<=B
x: A, y: B-10
PC: A == B-10
&& A+1>B-10
&& A>Bx: A, y: B-10
PC: A != B-10 
&& A+1>B-10
&& A>B  x: B, y: A-10
PC: B==A-10
&& B+1>A-10
&& A<=Bx: B, y: A-10
PC: B!=A-10
&& B+1>A-10
&& A<=B
return B-10PC: false
Infeasible path
return A-10PC: false
Infeasible path
PC: false
Infeasible pathPC: false
Infeasible path
Fig. 2. Symbolic execution tree for method q
unsatisﬁable path conditions. Programs with loops may have
inﬁnite numbers of paths so symbolic execution needs to be
bounded for these programs. The exploration of paths can stop
when a certain search depth is reached or a coverage criteria
has been achieved.
Symbolic PathFinder (SPF) uses lazy initialization [15] to
handle dynamic input data structures (e.g., lists and trees). The
components of the program inputs are initialized on an “as-
needed” basis. The intuition is as follows. To symbolically
execute method mof class C, SPF creates a new object oof
class C, leaving all its ﬁelds uninitialized. When a reference
ﬁeldfof type Tis accessed in mfor the ﬁrst time, SPF non-
deterministically sets ftonull, a new object of type Twith
uninitialized ﬁelds, or an alias to a previously initialized object
of type T. This enables the systematic exploration of different
heap conﬁgurations during symbolic execution.
III. E XAMPLE COMPOSITIONAL ANALYSIS
This section illustrates our approach to compositional sym-
bolic execution on the simple example from Figure 1.
When traditional (non-compositional) symbolic execution
is applied on the method qshown in Figure 1, method p
is executed twice, since both branches of the conditional
statement at line 2of method qare feasible. The cost of
method p’s “re-execution” can be reduced by compositional
symbolic execution, where we ﬁrst build a memoization tree
of method p, and then efﬁciently perform symbolic execution
of method qby replaying the symbolic execution of pin the
two calling contexts using p’s memoization tree.
Figure 3 (a) shows the memoization tree for method p.A
memoization tree succinctly summarizes all the choices taken
during symbolic execution [25]. Other than the root node
n0, each node is created whenever a conditional statement is
executed, recording the branch that is taken during symbolic
execution, e.g., node n1in Figure 3 (a) indicates that the
true (1) branch of the conditional statement at line 2in pro-
gram pis executed. Additionally, the tree leaves are annotated
with the path conditions for each complete path through the
method. Out of the four paths in the program, three paths are
captured in this memoization tree, because the missing path is
infeasible with an unsatisﬁable path condition: x<=y&&
x==y+1.
To replay the symbolic execution of the callee method that
has a memoization tree, the (feasible) paths in the memoization
633
633
633n0
p : Root
n5
p : 7 : 0n3
p : 7 : 1n4
p : 7 : 0n1
p : 2 : 1n2
p : 2 : 0
PC: x != y+1
&& x <= yPC:  x-1==y 
&& x > yPC:  x-1 != y 
&& x > y
n1
q : Root
n2
q : 2 : 1n3
q : 2 : 0
n4
p: n4n5
p : n4
PC: a != b-10 
&& a+1>b-10
&& a > b   PC: b != a-10
&& b+1>a-10
&& a<=b
(a) (b)
Fig. 3. (a) Tree built for method p. (b) Tree built for method q
tree are checked against the calling context to determine
whether they are feasible or not. We map the actual inputs
of the callee method to the parameters stored in memoization
tree. For example, when invoked at line 3of method q, method
p’s actual inputs are a+1andb−10, and its formal arguments
arexand y.S ow em a p a+1→xand b−10→y.
Each annotated path condition in the memoization tree is
transformed by replacing the parameters with the actual inputs
using the map, and then combined with the path condition
from the calling context. The combined constraints are then
checked to decide if the corresponding path in pis feasible
or not. For the path in method pthat ends at node n5in
Figure 3 (a), for instance, the transformed path condition
(a+1 ) ! = ( b−1 0 )+1&& ( a+1 ) <=(b−10) after
replacing the formal arguments, combined with the calling
context constraint a>b , is not satisﬁable and thus this path
is not feasible in the calling context. In this case, the nodes
along this path, n2and n5, are marked so that the path will
not be explored by symbolic execution in composition.
Figure 3 (b) shows the memoization tree built for method
qby reusing method p’s memoization tree. For paths in p
that are feasible in the calling context, we do not put their
corresponding nodes in q’s memoization tree. Instead, we
use summary nodes to point to those paths in method p’s
memoization tree to reduce the memory cost. For example,
nodes n4and n5in Figure 3 (b) are summary nodes. In node
n4,“[p : n4] ” points to the path ended at node n4(n0→n1
→n4) in method p’s memoization tree.
In traditional symbolic execution, whenever the path condi-
tion is updated it is checked for satisﬁability using the underly-
ing constraint solver. Therefore, traditional symbolic execution
makes 10constraint solver calls in total for symbolically
executing method q(according to the conditions encoded in
Figure 2). In contrast, our approach makes 8constraint solver
calls, i.e., two calls for branch conditions in method qand3
calls each in method pin its two calling contexts (line 3and
line5in method q), reducing the overall analysis time.
Although in this particular example the saving for number
of constraint solver calls is rather modest, the beneﬁts of the
compositional analysis become more pronounced when there
are many invocations of the same method, e.g., qis invoked
in a loop, and each invocation only costs 2 and 3 constraint
solver calls for methods qandprespectively (see Section V
for beneﬁts).IV . C OMPOSITIONAL SYMBOLIC EXECUTION
Overview. In our compositional approach the methods of a
program are processed in an order corresponding to a bottom-
uptraversal of the program’s call graph, starting with the ones
that invoke no other methods and incrementally processing
methods whose sub-methods have already been processed until
the whole program is analyzed. For each processed method,
we use bounded symbolic execution to compute a method
summary, which consists of a tree that succinctly represents all
the symbolic paths through the method, together with the input
path constraints for the complete paths; the bound is speciﬁed
by the user and it is stored in the tree. The summary is
stored (“memoized”) for future re-use, whenever that method
is invoked from another method – we say that the two methods
are composed .
Note that, when deciding on the order to analyze the meth-
ods in a given system, two main strategies can be followed. A
top-down approach may be adequate if one wants to compute
only the strictly necessary information. However, this approach
does not guarantee that reuse of summaries is always possible,
and summaries may need to be recomputed for different
calling contexts. In contrast, a bottom-up approach ensures
that the computed summaries can always be reused, albeit at
the price of computing summaries larger than necessary in
some cases. We follow the latter strategy in our framework.
At a high level, our approach works as follows. Let us
assume that program Pconsists of an entry method M0and
a set of methods M1,M2, ..., M kthat belong to M0’s method
invocation hierarchy. In the hierarchy, each leaf method, i.e.,
a method that invokes no other methods, is analyzed ﬁrst,
and its feasible paths and corresponding path constraints are
summarized in a memoization tree. Then the methods that
directly invoke these leaf methods are analyzed by leveraging
the already built memoization trees. The process continues in
a bottom-up fashion until the entry method M0is analyzed.
Handling recursion. If a method invokes itself, we build the
summary tree directly up to a pre-speciﬁed bound. For indirect
recursion, i.e., a loop consisting of several methods in the call
graph, we randomly choose one method in the loop and build
the summary tree for it, without reusing other callee methods.
The summary built will consist of all methods in the loop up
to a certain bound.
Algorithm. Algorithm 1 describes our overall approach. Pro-
cedure getStaticCallGraph (P, M 0)(Line 2) creates the call
graph for Prooted in M0. Procedure getLeafNodes (Line 3)
identiﬁes the leaf methods in the invocation hierarchy. Further-
more, the algorithm checks whether each analyzed method has
conditional statements using helper method containsCondStmt
(Line 6), and skips the analysis of the method that does
not contain any conditional statements, since methods with
no conditional statements would not give beneﬁts during
compositional symbolic execution.
Procedure analyzeMethod (Line 7) performs a bounded
symbolic execution for method mand builds its memoization
tree using the previously computed memoization trees stored
634
634
634Algorithm 1 Compositional symbolic execution
Input: Program P, Entry method M0
Output: A set of summary trees STfor methods in P
1:ST←∅
2: CallGraph cg←getStaticCallGraph(P , M0)
3: Set s←cg.getLeafNodes()
4:while s/negationslash=∅do
5: for each Method m∈sdo
6: ifm.containsCondStmt() then
7: SummaryTree t←analyzeMethod(m, ST)
8: ST.add(t)
9: s←cg.getNodesToProcess(s)
10: return ST
in the set ST. Procedure getNodesToProcess (Line 9) returns
the nodes in the call graph whose corresponding methods have
not been processed so far but the methods that they invoke
have already been processed.
Algorithm 2 shows procedure analyzeMethod for building
(Section IV-A) and composing (Section IV-B) method sum-
mary trees. We describe some of its key elements in more
details below.
A. Construction of Memoization Trees
A memoization (or summary) tree is a recursive tree data
structure that succinctly captures the crucial elements of
symbolic execution for each analyzed method.
Each tree contains two types of nodes: normal nodes and
summary nodes . At a high level, for each method Mcaller
invoking method Mcallee , normal nodes encode the choices
taken for each condition in the code, while summary nodes
encode pointers to the paths in Mcallee ’s summary that are
found to be feasible at the invocation point from Mcaller .
Normal Nodes. A “normal” node, N[m : offset : choice] ,
represents a choice taken at a conditional statement and it
encodes: m– the name of the enclosing method, offset – the
instruction offset of the conditional statement, and choice –
choice taken by the execution ( “1” for true branch and “0”
for false branch). For example, in Figure 3 (a), node n2has a
tuple [p:2:0 ] , indicating that in method pinstruction with
offset 2 (“ if(x>y )”) takes the choice of false branch.
A symbolic execution path can be succinctly represented
by the sequence of choices taken during its execution, and
can be recovered from the memoization tree by traversing the
tree from the root to a leaf. We thus can use the leaf nodes to
represent their corresponding paths. For example, in Figure 3
(a), node n4implies an execution path that takes the true
branch at the ﬁrst conditional statement and the false branch
in the second conditional statement in method p.
We note that we need to keep track of all the conditions
in the method, not just the ones being executed symbolically.
The reason is that during replay, some of the conditions that
were symbolic during tree generation may become concrete
due to concrete inputs from the calling context; we can not
distinguish that from a condition that was concrete to begin
with in the tree. We therefore chose to record allthe conditions
in the summary tree and used the tree to guide the execution
of all the conditions (see lines 8-10 in analyzeMethod ).Algorithm 2 Procedure analyzeMethod for building and com-
posing memoization trees
Input: Method Mcaller , Set<MemoizationTree >S T
Output: MemoizationTree Tcaller for method Mcallee
1: boolean toCompose ←false
2: MemoizationTree Tcaller←new MemoizationTree()
3: MemoizationTree t←null
4: Instruction insnToExe ←getNextInstruction()
5:while insnToExe != null do
6: if!toCompose then
7: turnOnConstraintSolver()
8: iftype(insnToExe) == ConditionalInstruction then
9: Node n←createNode(insnToExe)
10: Tcaller .add(n)
11: iftype(insnToExe) == InvokeInstruction then
12: ifinvokedMethod(insnToExe) ∈STthen
13: toCompose ←true
14: t←ST.getSummary(insnToExe)
15: Mapping mapping ←createMapping()
16: Context context←getSymEexContext()
17: for each Path path∈t.getPaths() do
18: SummaryPC spc←path.getSummaryPC()
19: boolean isConsistent ←false
20: for each PCPair pcp∈spc do
21: ifcheck(pcp, context, mapping) then
22: isConsistent ←true
23: break
24: if!isConsistent then
25: markNodes(path)
26: else
27: turnOffConstraintSolver()
28: iftype(insnToExe) == ReturnInstruction then
29: ifbackToCaller(insnToExe) then
30: toCompose ←false
31: Tcaller .compressNode()
32: iftype(insnToExe) == ConditionalInstruction then
33: Node n←t.getNextNode()
34: ifn∈SummaryNode then
35: t.decompressNode(n)
36: n←t.getNextNode()
37: ifn∈markedNodes then
38: prunePath()
39: else
40: Tcaller .add(n)
41: insnToExe ←getNextInstruction()
42: return Tcaller
Summary Nodes. Only a subset of the paths in method
Mcallee ’s memoization tree, i.e., the feasible paths in the
particular calling context from method Mcaller , can be ex-
ecuted and should be contained in the memoization tree for
method Mcaller . To compactly represent these paths in method
Mcaller ’s memoization tree, we introduce summary nodes ,
S[m, p] . These are nodes that point to a path in method
Mcallee , where prepresents a pointer to one of the leaf
nodes in method Mcallee ’s memoization tree. Summary nodes
serve as pointers to the paths in method Mcallee that are
feasible in the method Mcaller ’s context; thus the method
Mcaller ’s memoization tree does not need to duplicate the
paths of repeated normal nodes from existing trees. Procedure
compressNode (Line 31) compacts a sequence of normal nodes
into a summary node, which can be reverted to the original
sequences of normal nodes when the memoization tree is
reused for analyzing other methods.
For instance, in Figure 3 (b) nodes n4and n5are summary
nodes, indicating p’s feasible paths in its calling context.
635
635
635They point to the path represented by node n4in method p’s
memoization tree.
Path Conditions. Each leaf node in the tree has an associated
set of path conditions characterizing the inputs that follow the
path from the root to the leaf. Note that we do not have a
one-to-one correspondence between paths in the memoization
tree and the symbolic execution tree, the reason being that the
memoization tree is more compact and can represent multiple
symbolic executions.
Each tree leaf has one or more pairs of numeric path
condition (PC) and heap path condition (HeapPC). Numeric
path conditions depict the constraints over numeric inputs for
choosing one path (see Figure 3) while heap path conditions
encode heap constraints introduced when analyzing methods
with parameters of reference types. We discuss the heap
constraints in more detail below.
Heap Path Conditions. A Heap Path Condition is a conjunc-
tion of constraints over the heap allocated objects in the input
data structures. They are generated by lazy initialization [15]
during the symbolic execution of a heap manipulating method.
More precisely, these constraints are generated during the
symbolic execution of instructions that perform a ﬁrst access to
an un-initialized ﬁeld (i.e. bytecodes aload ,getfield and
getstatic ). The constraints can have the following form:
•Ref=null. Reference Refpoints to null.
•Ref1=Ref2. Reference Ref1points to the same object
in heap as reference Ref2, i.e., Ref1and Ref2are aliased.
•Ref/negationslash=null. Object reference Ref points to a symbolic
object that is neither null nor any existing objects in heap,
with all its ﬁelds initialized as symbolic values.
These constraints are sufﬁcient to express all the possible
aliasing scenarios in the input data structure [15]. Note that
since our memoization tree only encodes the conditional
branches in a method, different heap constraints can drive the
program along the same path. For example, if the condition in
the code checks for the input to be not null, paths characterized
by non-null constraints (whether they are aliased or not) will
pass that check. Thus each path in a summary tree can have
one or more pairs of PC and HeapPC. We show later in
this section an example of compositional analysis for heap
manipulating programs.
B. Composition of Memoization Trees
Our approach uses existing memoization trees to efﬁciently
replay the symbolic execution of the corresponding methods
with respect to their calling contexts. In particular, the mem-
oization tree of the callee method is utilized to guide part of
the symbolic execution of the caller method.
Our approach ﬁrst performs regular symbolic execution of
method Mcaller and creates normal nodes for conditional
instructions executed in method Mcaller (Lines 8−10). When
the execution encounters an invocation of method Mcallee ,w e
suspend regular symbolic execution (controlled by variable
toCompose ), and check which paths of Mcallee are feasible
in the calling context (Line 21). If a path’s PC-HeapPC pair
is consistent with the current path conditions in the callingsite, this path is considered feasible; otherwise, the path is
infeasible and it is marked in Mcallee ’s memoization tree as
not to be executed (Lines 24−25). Only feasible paths are
considered during symbolic execution. Furthermore, constraint
solving (which is typically the most expensive part of symbolic
execution) is turned off during the guided execution of method
Mcallee (Line 27), and is resumed when the execution returns
from method Mcallee back to method Mcaller (Line 7).
Search Bound. The symbolic execution bound is ﬁxed for a
summary tree once it is built. Summary trees can be iteratively
deepened (as described in our previous work [25]). To reuse
a tree with a search bound, if the caller method’s bound is
set to be greater than the callee method’s summary bound,
our approach will turn on the constraint solver and continue
as traditional symbolic execution to extend the tree for the
caller method. Therefore, the set of paths explored in our
compositional analysis is the same as in traditional (non-
compositional) symbolic execution.
Checking Path Condition Consistency. The composition of
method summaries involves checking the consistency of path
conditions, to determine whether paths in the memoization tree
of a called method are feasible in the current calling context.
In particular, we check the consistency of the path condition
in the tree with the path condition at the calling site.
Algorithm 3 checks path condition consistency. The input
Mapping records the mapping between parameters of the
summarized callee methods and actual inputs of the method in
call site. With this mapping we convert the path conditions in
the memoization trees to path conditions that refer to variables
in the calling context by replacing the formal parameters of
Mcallee with the actual arguments from Mcaller .
Lines 1−7check the consistency of numeric PCs. Each
constraint in a path condition in the memoization tree is
checked against the path condition from the calling context
(we also perform some simpliﬁcations that we omit here for
clarity). The conjunction of the summary PC and the context
PC is checked for satisﬁability using constraint solving.
Checking Heap Path Conditions. Lines 8−18check the
consistency of heap path conditions (HeapPC). Note that the
heap in the calling context may be either concrete or symbolic.
If it is concrete then the HeapPCs can be checked directly.
However, if the current heap is symbolic, we perform an
approximate consistency check for HeapPCs. The objects in
method Mcallee ’s heap path conditions can be mapped to a
concrete object in method Mcaller ’s calling context, or null,
or a symbolic object whose ﬁelds are all symbolic values.
For each constraint in the summary heap path condition, both
sides of the constraint map to lhr(left side heap reference) and
rhr (right side heap reference), respectively. If both of them
arenull, this constraint conforms with the context heap path
condition; or if both of lhrandrhr are concrete objects and
they reference the same object in the calling context heap, the
constraint apparently also conforms to the context heap path
condition. If they are both symbolic objects, we consider it
consistent as well since they are both uninitialized and would
be explored by lazy initialization (Line 15). Thus, we take a
636
636
636Algorithm 3 Procedure check for checking PCand HeapPC
consistency
Input: PCPair pcp, Context context , Mapping m
Output: true for satisﬁable case, or false for unsatisﬁable case
1: PC npc←mapNPC(pcp, m)
2: PC contextNPC ←context.getNPC()
3:for each Constraint c∈npc do
4: contextNPC ←contextNPC.addConstraint(c)
5: boolean pcSatisﬁed ←contextNPC.solve()
6:if!pcSatisﬁed then
7: return false
8: HeapPC hpc←mapHPC(pcp, m, context)
9:for each Constraint hc∈hpc do
10: Comparator comp←hc.getComparator()
11: ifcomp == “!=” then
12: continue
13: Reference lhr←hc.getLeftSideRef()
14: Reference rhr←hc.getRightSideRef()
15: if(lhr== SymRef∧rhr== SymRef)
∨(lhr== object∧rhr== object)
∨(lhr== null∧rhr== null) then
16: continue
17: else
18: return false
19: return true
conservative approach to checking heap consistency, meaning
that for the constraints that we can not decide in the current
context we assume they are feasible, and we leave the lazy
initialization of Mcallee to resolve it during replay. If the
conservative approach is needed we turn on the constraint
solver for checking the numeric path constraints.
C. Example involving heap constraints
Consider the Swap Node example in Figure 4, where class
Node implements a singly-linked list. A node has two ﬁelds
elem and next, representing an integer element and a reference
to the next node in the list. Method swapNode destructively
updates a node’s next ﬁeld. Method callSwapNode creates a
new concrete node n1, sets n1’s next as the input parameter,
and invokes method swapNode onn1.
We use lazy initialization [15] to analyze method swapNode
and generate a memoization tree shown in Figure 5. Lazy
initialization checks seven method executions that represent
an isomorphism partition of the input space. However, based
on conditional statements in the code, the method contains
only three paths as shown in Figure 5, i.e., n1→n2,
n1→n3→n4, and n1→n3→n5. Therefore we
encode these seven different input data structures as seven
pairs of numerical path condition and heap path condition,
which spread across the three paths. For example, node n2
has a numeric path condition (PC) True and a heap path
condition (HeapPC) this.next == null.P C True indicates that
no constraint on the input data structure’s integer variables is
associated with this path. HeapPC implies that if input this’s
ﬁeld next points to null, this path will be executed.
When method swapNode ’s memoization tree is reused dur-
ing compositional symbolic execution the paths in method
swapNode ’s memoization tree are checked for feasibility in
this particular calling context. Figure 6 illustrates the process
of checking consistency of path conditions. First, in statement
16, lazy initialization non-deterministically initializes n1.next1class Node {
2 int elem ;
3 Node next ;
4 Node swapNode () {
5 if(n e x t ! = null ){
6 if( elem >next . elem ) {
7 Node t = next ;
8 next = t . next ;
9t . n e x t = this ;
10 return t;
11 }}
12 return null ;
13 }
14 static Node callSwapNode ( Node n ) {
15 Node n1 = new Node ( ) ;
1 6 n1. next = n;
17 return n1 . swapNode ( ) ;
18}}
Fig. 4. Swap Node example
tonull,o r n1, or a new node with all its ﬁelds uninitialized.
Then the actual parameters from the calling site are mapped
to the formal parameters in the memoization tree. In this
example, concrete object n1is mapped to thisin summary. For
each pair of PC and HeapPC in summary tree, we check if it is
satisﬁable with its current input data structure from the calling
site. For example, in Figure 6 one of the calling context is that
thisreferences a concrete Node object with its elem=0 and its
next ﬁeld pointing to another Node object with all uninitialized
ﬁelds. We select two pairs of PC and HeapPC from two paths
inswapNode to show how to check consistency in presence of
heap operations. One is {PC: True, HeapPC: this.next==null }
and the other one is {PC: this.elem <=this.next.elem, HeapPC:
this.next!=this }. The ﬁrst one is not consistent with the calling
context since this.next is not null; while the second one is
consistent because this.next!=this conforms to the input data
structure and this.next.elem is symbolic (uninitialized) so it
can be greater than or equal to this.elem whose concrete value
is 0.
If all pairs of PC and HeapPC associated with a path in a
memoization tree are checked to be inconsistent with respect
to its calling context, we consider that path infeasible in
the calling context. Again, the infeasible paths are marked
to be pruned in symbolic execution during composition. In
this example, all three paths of swapNode are feasible when
invoked by method callSwapNode , since every path has one
or more pairs of PC and HeapPC that are consistent with the
calling context.
D. Discussion
Correctness. Consider a method Mcallee that does not invoke
any other methods. Then normal symbolic execution explores
the same behaviors as the replay of symbolic execution of
the summary tree for Mcallee . This follows from the way we
construct the memoization tree, as a succinct representation
of the symbolic execution tree for that method. Note also
that the path conditions from the tree leaves characterize (by
construction) the inputs that follow those paths.
Consider now method Mcaller that invokes method Mcallee ,
for which we computed the summary tree. Whenever Mcallee
is invoked inside Mcaller we check to see which path in
Mcallee ’s summary tree can be used in the current context,
637
637
637n1
swapNode: 
Root
n2
swapNode: 5: 0n3
swapNode: 5: 1
n5
swapNode: 6: 1n4
swapNode: 6: 0PC: True
HeapPC : 
this.next==null
PC: this.elem <= 
this.next.elem
HeapPC : this.next!=nullPC:True
HeapPC : 
this.next==thisPC: this.elem > 
this.next.elem
HeapPC : this.next.next
== this.next && 
this.next!=null PC: this.elem > 
this.next.elem
HeapPC : this.next.next 
== this && this.next != 
nullPC: this.elem > 
this.next.elem
HeapPC : this.next.next 
== null && this.next != 
nullPC:this.elem > 
this.next.elem
HeapPC :  
this.next.next!=null && 
this.next!=null
Fig. 5. Tree built for method swapNode
0 nullnext
0 nullnext0 next 0 enextinitialize n1.next in stmt 16n1
n1 n1 n1
?next
0 enext
?next
0 next 0 nullnext
this this thisreplace parameters before 
method invocation
PC: this.elem <= 
this.next.elem 
HeapPC : this.next!=thisPC: True
HeapPC : 
this.next==null.........check PC and HeapPC
for each path
Not 
FeasibleFeasible
Fig. 6. The process for checking path conditions when reusing summary tree
by checking the satisﬁability of the path conditions stored in
the tree’s leaves. It may be the case that multiple paths from
Mcallee can be used in the current calling context. They are
all used systematically. Since all the cases that apply are used
forMcallee we conclude that there is no loss of information
from the composition procedure (up to the given bound).
Note that due to the conservative treatment of consistency
heap checking, some of the infeasible paths need to be re-
executed during composition. Constraint solving is turned “on”
for those paths, so that only feasible paths are added to
Mcaller ’s summary, but it may result in un-necessary work
for the analysis. This is the price we pay in exchange for a
simple consistency checking procedure.
Identifying the inputs to a method. So far in our pre-
sentation, we assumed, for simplicity, that the inputs to a
method are the method’s parameters. However, the inputs to
the method should also include all the global variables (ﬁelds)
that are accessed without ﬁrst being initialized inside the
method. Identifying all these ﬁelds can be a daunting task,
due to the complex features of Java (inheritance, interfaces
etc). We have developed a simple solution to the problem.
Our approach assigns fresh symbolic values to all the global
variables in the containing class of method Mcallee before
it is invoked. The ﬁelds initialization happens right after the
callee object is created. The algorithm also assigns fresh
symbolic values to all ﬁelds of the classes that are created
at the time of the callee’s object creation. For static ﬁelds
we also consider them as symbolic at the beginning of the
analysis for Mcallee . In this way, all the global variables that
Mcallee can access are initialized with fresh symbolic values.
The composition procedure becomes more involved, because
we need to perform a traversal of the heap at the calling siteto identify the values of Mcallee ’s inputs, to be mapped to the
corresponding symbolic values.
In practice some of the global variables should be kept
concrete, as they may represent constants, instances of library
classes etc. that do not need to be analyzed symbolically. This
would also make the symbolic state space more manageable.
Automatically identifying which ﬁelds to keep concrete is left
for future work. In our current work, we assume that the
developer goes into the code and annotates which ﬁelds to
be kept concrete.
E. Target Oriented Compositional Symbolic Execution
We have developed two heuristics that are speciﬁcally
targeted towards covering a designated state in the program
(this may be an error or a statement deep inside the program
that we aim to discover quickly).
Heuristic 1. To quickly steer symbolic execution towards a
speciﬁc target, our approach explicitly marks memoization tree
nodes along paths that lead to the target, e.g., an assertion
violation. In the ﬁrst heuristic, our approach uses short-
circuiting: if a path condition of a path that leads to an error
in a summary is satisﬁable in its calling context, the path does
not need to be re-executed, and the error can immediately be
reported and also recorded in the calling method’s summary.
Moreover, the error markings enable a directed search for
errors where the replay of a memoized tree is prioritized to
paths that may lead to errors: if a memoization tree checked
from a top-level method has a path that terminates in an
error state, the corresponding path condition can be checked
for feasibility in the calling context before the other path
conditions; thus, if the feasibility check succeeds, the search
can report an error, thereby pruning the other memoized paths.
Heuristic 2. The second heuristic performs aggressive pruning
of the memoized trees, by keeping only the paths that lead
to the error (and discarding the rest). While incomplete,
this approach turns out to be quite effective in practice, as
demonstrated by the experiments in the next section.
V. I MPLEMENTATION AND EV ALUATION
Implementation. We implemented our compositional sym-
bolic execution in Symbolic PathFinder (SPF), as two listeners.
One builds the summary tree and the other one uses the
summaries to guide symbolic execution. Whenever a condi-
tional statement is executed (whose condition is either concrete
or symbolic) we introduce a special type of choice called
BranchChoice (of size 1) in the SPF execution. This is a
mechanism that allows us to precisely encode the conditional
638
638
638TABLE I
EV ALUATION FOR COMPOSITIONAL SYMBOLIC EXECUTION
Subject Method(Depth)# Solver calls Time(m:s) Mem (MB) # #
CompoSESPFCompoSESPF CompoSE SPFSub-method CTree/Tree
Init Comp Total Init Comp Total Invocations Nodes
Bank-
Accountdeposit 22 2 <00:01 <00:01 <00:01 17 17 3/3
withdraw 44 4 <00:01 <00:01 <00:01 17 17 6/6
main 6 462 468 706 00:01 00:15 00:16 00:31 17 17 135 369/547
Rationalabs 22 2 <00:01 <00:01 <00:01 17 17 3/3
gcd 24 04 2 40 <00:01 <00:01 <00:01 17 17 9 46/46
simplify 42 52 94 92 <00:01 <00:01 <00:01 17 17 10 28/60
simp 94 2940 3034 19412 00:01 01:40 01:41 07:13 48 48 2321 2955/12450
gcdRec(8) 2 103 105 103 00:10 00:10 00:10 14 14 86/86
Rational- simplify(15) 105 293 398 504 00:10 01:13 01:23 01:44 17 17 11 790/2533
Recursion gcdRec(10) 2 146 148 146 00:15 00:15 00:15 14 14 113/113
simplify(15) 148 237 385 504 00:15 00:58 01:13 01:44 17 17 11 790/2533
WBSupdate 478 478 478 00:22 00:22 00:13 17 17 2609/2609
main1 478 144 622 2206 00:22 00:03 00:25 00:27 20 22 145 1553/6391
main2 478 864 1342 3742 00:22 00:09 00:31 00:39 28 38 289 1905/10461
launch 478 14400 14878 27646 00:22 00:16 00:38 14:00 148 200 601 14426/277663
ASWmain1 42 42 42 <00:01 <00:01 <00:01 17 17 81/81
main2 402 402 402 00:04 00:04 00:05 17 17 640/640
main0 444 576 1020 858 00:05 00:07 00:12 00:11 17 17 9 457/1809
main 1020 1216 2236 5850 00:12 00:16 00:28 00:52 24 35 586 3104/7313
TCASmIBC 22 2 <00:01 <00:01 <00:01 15 15 3/3
mOBT 22 2 <00:01 <00:01 <00:01 15 15 3/3
mOAT 22 2 <00:01 <00:01 <00:01 15 15 3/3
mNCBD 62 63 2 30 <00:01 <00:01 <00:01 <00:01 23 23 7 43/43
mNCBC 62 63 2 30 <00:01 <00:01 <00:01 <00:01 23 23 7 43/43
altseptest 58 230 288 678 00:05 00:07 00:12 00:20 23 25 240 264/901
startTcas 288 68 356 2348 00:12 00:02 00:14 00:59 29 39 677 361/2682
ApolloMain4 12 12 12 00:02 00:02 00:01 17 17 55/55
Main5 12 12 12 00:01 00:01 00:01 17 17 43/43
Main6 12 12 12 00:01 00:01 00:01 17 17 59/59
Main1 36 87 123 348 00:04 00:40 00:44 02:38 16 16 33 179/1106
MainSymbolic 123 1296 1419 12381 00:44 29:08 29:52 247:05 27 81 1440 668/2270
SwapNodeswapNode 16 16 16 <00:01 <00:01 <00:01 17 16 13/13
callTwice 16 100 116 742 <00:01 00:06 00:07 00:09 17 17 13 43/85
call3Times 16 14268 14284 48056 <00:01 02:10 02:11 12:29 24 58 506 259/517
HeapOpq 236 236 236 00:01 00:01 00:01 15 15 21/21
r 236 31903 32139 255976 00:01 10:37 10:38 22:09 15 15 2477 158/338
LinkedListadd(10) 206 206 206 00:45 00:45 00:39 17 17 35/35
repOk(10) 50 50 50 00:01 00:01 00:01 17 17 136/136
Call3Times(20) 256 600 856 1660 00:46 00:10 00:56 00:48 19 17 92 395/648
Call5Times(25) 256 3020 3276 15580 00:46 00:59 01:45 04:00 37 17 233 745/1630
add(15) 348 348 348 01:01 01:01 00:53 17 17 59/59
repOk(15) 93 93 93 00:08 00:08 00:08 17 17 157/157
Call3Times(20) 441 383 824 1660 01:09 00:06 01:15 00:48 19 17 92 395/648
Call5Times(25) 441 2598 3039 15580 01:09 00:31 01:40 04:00 37 17 233 745/1630
instruction’s location and the choice it takes, and to “break”
the transitions that SPF lumps together to introduce new points
to which the tool can backtrack. When building the summary
tree, the listener monitors whenever a new BranchChoice
is created and adds a normal node to the tree as a child
to the current node. When SPF backtracks from the current
BranchChoice to the previous one in the search, the current
node in the tree is “backtracked” to its parent node too to keep
the program states and tree nodes in sync.
Evaluation for compositional symbolic execution. We eval-
uated our approach on the following Java artifacts: BankAc-
count ,Rational ,RationalRecursion ,WBS ,ASW ,TCAS ,Apollo ,
SwapNode ,HeapOp , and LinkedList . All of these artifacts
were used before for evaluating symbolic execution [2], [14],
[18], [20], [21], [24], [25]. These subjects contain rich pro-
gramming constructs, such as complex non-linear constraints,
recursion, heap-manipulating methods, etc. that are difﬁcult to
handle with symbolic execution. The largest of these artifacts
is Apollo with 2.6KLOC in 54classes [21]. The program
contains complex non-linear ﬂoating-point constraints and it
is quite challenging to analyze. To symbolically execute aconﬁguration with two iterations, traditional SPF takes more
than 4 hours to ﬁnish. We are interested in evaluating our
compositional approach on such complex examples to see
whether it could improve the analysis time signiﬁcantly.
We have conducted experiments on the subject programs
using traditional non-compositional symbolic execution (SPF)
and our compositional approach (denoted here as CompoSE).
For all subjects except RationalRecursion and LinkedList ,
no pre-speciﬁed search depth was needed. The search depth
for RationalRecursion and LinkedList is listed in Table I.
Table I shows the results of our experiments using SPF and
CompoSE. We report the number of constraint solver calls,
the execution time, the maximum memory (Mem) used, the
number of invocations of sub-methods that have already been
analyzed, and the number of nodes in compressed memoized
tree using summary nodes (“CTree”) versus the number of
nodes in non-compressed tree (“Tree”).
For CompoSE we show results for two steps: “Init” builds
memoized summary trees for callee methods and “Comp”
reuses the summaries that are already built to composition-
639
639
639ally execute the target method. “Total” is the entire cost of
CompoSE to analyze a method.
The methods without “Init” in Table I are the methods that
we analyzed ﬁrst. For these methods the number of constraint
solver calls is the same for both SPF and CompoSE. This is
because building a tree without any existing tree to re-use has
similar cost to traditional symbolic execution, besides the cost
for building and maintaining the extra tree data structure. We
can see that for methods update inWBS ,Main4 inApollo , and
add inLinkedList , building the summary took slightly longer
than traditional SPF due to this extra work.
We can see however that for the methods that re-use the
trees (marked as “Comp”) the analysis incurs fewer constraint
solver calls and signiﬁcantly less time than traditional SPF on
most of the methods. In some cases the saving can be very
signiﬁcant (highlighted in bold in Table I), from 21% ( simplify
inRationalRecursion ) to 88% ( MainSymbolic inApollo ) fewer
solver calls and 1.1x ( main1 inWBS ) to 22.1x ( launch inWBS )
faster. For Apollo , SPF took about 4 hours and 8 minutes
to ﬁnish while CompoSE took less than 30 minutes. This
result indicates that the beneﬁts of CompoSE become more
pronounced for larger programs.
CompoSE took slightly more number of solver calls than
SPF in a few methods when the number of solver calls saved
in composition was less than the number of solver calls in
building summaries, such as method gcdinRational ,gcdRec
inRationalRecursion , and a few methods in TCAS .
From the results on RationalRecursion and LinkedList it
follows that as the state space to be analyzed becomes larger
(i.e., by increasing the analysis depth) the savings achieved
by CompoSE become more pronounced. Also naturally, the
more times sub-methods are invoked the more repeated work
is required so compositional approach gain more beneﬁts. This
can be veriﬁed by comparison with the numbers of sub-method
invocations and the savings in Table I.
Furthermore, Table I shows that for most methods execu-
tion, CompoSE uses either the same or less memory than
traditional SPF. We note however that the maximum memory
reported by SPF may vary a lot due to the underlying garbage
collection, and thus this comparison is less illustrative.
Evaluation for target oriented heuristics. We use six sub-
jects in Table II to evaluate the effectiveness of our proposed
approach with respect to the two heuristics that are target-
oriented. For each subject, we selected a subset of methods to
seed an assertion error in different locations. These locations
are at the end of the ﬁrst path, last path, and a random path
(that is neither ﬁrst nor last) in the method. For each run there
is only one assertion error in one method. This experiment
mimics scenarios where we are interested in a target located
at different places in the program state space, with various
degrees of difﬁculty in locating it.
Table II shows the comparison for SPF and the two heuris-
tics (H1, H2). The reported numbers include the cost for
building summaries of callee methods. The cases in which
H1 and H2 outperform SPF are highlighted. In most cases,
if the error is not in the ﬁrst path of a method, our proposedTABLE II
EV ALUATION FOR TARGET ORIENTED HEURISTICS
Subject MethodTarget Time(s) # Solver Calls
Location SPF H1 H2 SPF H1 H2
Bank-
Accountwithdraw1st 0.5 1.3 1.1 61 5 1 5
Rand 100.8 87.6 1.0 54 43 13
Last 93.7 1.3 1.3 48 16 14
Rationalgcd1st 0.7 2.3 2.0 28 4 4 0
Rand 1.0 2.0 1.8 28 60 24
Last 2.4 2.5 2.2 106 105 61
simplify1st 0.7 2.0 2.0 04 2 4 2
Rand 0.8 2.3 2.3 66 8 6 8
Last 3.1 2.7 2.7 166 154 154
WBS update1st 0.7 5.2 5.2 4 402 402
Rand 10.5 6.5 6.5 1214 526 526
Last 10.9 10.0 10.0 1366 1070 1070
ASWMain11st 0.78 5.6 5.6 12 444 444
Rand 0.8 5.6 5.6 12 444 444
Last 51.4 11.9 5.6 5680 752 472
Main21st 0.8 1.9 1.9 12 42 42
Rand 0.9 7.5 5.8 22 524 364
Last 63.6 58.6 7.9 7386 1512 776
TCASmNCBC1st 1.1 10.0 7.5 26 242 204
Rand 1.5 11.4 9.3 32 294 256
Last 4.7 10.8 7.6 166 270 216
mNCBD1st 0.8 7.0 3.3 16 182 102
Rand 1.0 7.1 5.3 22 190 160
Last 4.6 9.1 4.5 154 238 136
altsep
test1st 0.8 3.0 3.0 66 8 5 8
Rand 18.2 15.0 14.9 94 75 34
Last 155.3 24.6 20.9 6308 824 750
ApolloMain41st 3.0 33.4 14.3 9 132 78
Rand 16.1 47.0 14.1 33 135 78
Last 134 56.1 10 288 168 118
Main51st 5.5 31.9 14.2 15 121 82
Rand 16.7 53.3 14.3 33 159 80
Last 16.8 36.8 14.8 33 137 82
approaches are better than SPF, from 1.1x to 13.4x faster. Note
that for BankAccount , H2 is much faster than SPF (100x).
This is due to the special structure of the program. For few
other cases where methods are small (e.g., ﬁrst two methods
inTCAS ), the overhead of building method summaries slows
down our heuristics.
Conversely, if an assertion error is in the ﬁrst path of a
method, SPF took less time than H1 and H2. This is expected,
since SPF stops immediately after it explores the ﬁrst path of
a method while our proposed heuristics have the overhead of
building method summary trees for various methods in the
call graph. Furthermore we observe that H2 always took less
or same time to ﬁnd the error than H1. This is because H2
is more aggressive in that it ignores more feasible error-free
paths than H1.
Threats to Validity. The primary threats to external validity in
this study involve the use of SPF for our prototype implemen-
tation, the selection of artifacts, and the use of seeded assertion
errors as targets. We attempted to mitigate these threats by
analyzing multiple artifacts, most of which have been used
in previous studies of symbolic execution based techniques,
and by seeding assertion errors at various locations in the
program. These threats can be further addressed by additional
evaluation using a broader range of programs and targets. The
primary threat to internal validity is possible faults in the
implementations of our algorithms and in SPF. We controlled
for this threat by testing the implementations of the algorithms
and SPF on examples that could be manually veriﬁed. Where
threats to construct validity are concerned, the metrics we
640
640
640selected to evaluate our approach are commonly used to
measure the cost of symbolic execution based techniques.
Discussion. Our preliminary experiments indicate that Com-
poSE has little or no beneﬁt for small programs, but the
savings of CompoSE become more pronounced when the
analyzed state space is larger, and for large programs (such as
Apollo) the savings achieved can be very signiﬁcant. Further-
more, the two target-oriented heuristics are mostly effective
when the target is not easy to ﬁnd (i.e., it is not on the
ﬁrst path). More experimentation is planned to further validate
these conclusions in practice.
VI. R ELATED WORK
Compositional symbolic execution has been addressed
in [2], [3], [10], [12]. The work in [10] is the ﬁrst to
propose compositional techniques to improve a particular form
of “dynamic” symbolic execution, i.e., symbolic execution
performed along concrete paths [11]. This was extended in [3]
with a (demand-driven) top-down approach that uses execution
trees similar to ours but it is not based on replay. Instead each
method summary is represented as a ﬁrst-order logic formula
with uninterpreted functions and the composition is performed
entirely using SMT solving. A further extension [12] employs
both “may” and “must” summaries, expressed with logical
formulae. None of these works address composition in the
presence of heap operations, for object-oriented programming.
While in principle logical summaries could be computed for
heap manipulating methods, the difﬁculty comes when re-
using the summaries: one would need to reconstruct the heap
according to the post condition, to continue execution.
Composition in the presence of heap operations is addressed
in [2], where summaries include both logical formulae and an
explicit representation of input and output heaps. The effects
of the computation are stored so there is no need to “replay”
symbolic execution. However, such advantage comes at a high
price: the summaries are large and the composition operation
is complicated, as it not only checks compatibility at the
invocation point, but also it synthesizes the new state, with
the new heap, to continue with after the composition of each
summary. This work is based on constraint logic programming
(CLP); similar synthesis of the new heap would be very
expensive in a general purpose tool such as SPF. We instead
construct the new heap by re-executing the code.
In a previous workshop paper [20] we described a prelim-
inary investigation of compositional symbolic execution for
Java bytecodes. We used partial evaluation, a well-established
technique that aims at automatically specializing a program
with respect to some of its input, to build method summaries
consisting of several “path-specialized” versions of the method
code. The obtained savings were not very impressive due
to the expensive storing of multiple versions of the code.
We use a lighter-weight approach here, since the method
summaries only encode the choices taken along each path.
This is sufﬁcient for method replay.
Compositional interprocedural analysis has been extensively
studied [13] with recent techniques focusing on handling heapoperations [6], [9]. The compositional shape analysis from [6]
uses separation logic and assigns a collection of Hoare triples
to each procedure that is analyzed separately, in bottom-up
fashion. The triples provide an over-approximation of data
structure usage. We provide an under-approximation, as is
typical in symbolic execution, and we do not use a logical
encoding for our summaries. The work in [9] presents a
bottom-up, summary-based heap analysis that uses abstract
points-to graphs extended with constraints to encode heap
summaries. The work does not address computing summaries
about shapes of data structures as in [6] but guarantees a higher
level of precision.
A recent related target-oriented technique is presented in [7],
although it is done in the context of bounded model checking
not symbolic execution, and it performs weakest preconditions
calculations instead of forward computations. Furthermore it
does not handle heap operations but it is targeted towards the
properties to check. Other target-oriented symbolic execution
techniques are presented in, e.g., [5], [17], [23]. A thorough
empirical comparison with these techniques is future work.
In previous work we developed memoized symbolic execu-
tion (Memoise) [25] for the efﬁcient re-application of symbolic
execution in different scenarios such as iterative deepening and
regression analysis. Similar to the approach here, Memoise
stores (on disk) the key elements of symbolic execution in
a tree data structure, and uses that tree during re-execution.
However the approach is not compositional. The technique
that we present in this paper naturally extends this previous
work, enabling memoization and retrieval of trees at a ﬁner
granularity, resulting in more efﬁcient analysis.
VII. C ONCLUSION
We presented a new approach for compositional symbolic
execution. The approach summarizes each analyzed method
as a memoization tree that captures the crucial elements of
symbolic execution, and leverages these trees to efﬁciently
replay the symbolic execution of the corresponding methods
in different calling contexts. Our approach offers a natural way
to compose in the presence of heap operations, which cannot
be dealt with by previous work that uses logical formulas
as summaries for compositional symbolic execution. We also
presented two heuristics for the efﬁcient treatment of error
traces. Preliminary experimental evaluation based on imple-
mentation in Symbolic PathFinder shows promising results.
We believe compositional analysis holds a key to scalable
symbolic execution. In future work, we plan to evaluate our
approach on larger programs as well as to further optimize our
algorithms. We also plan to incorporate loop invariants for the
succinct summarization of looping methods.
ACKNOWLEDGMENTS
This work was funded in part by the National Science
Foundation (NSF Grant Nos. CCF-1319858, CCF-1319688,
CCF-0845628, and CCF-1329278).
641
641
641REFERENCES
[1] SMT-COMP 2011. http://www.smtcomp.org/2011/.
[2] E. Albert, M. Gmez-Zamalloa, J. M. Rojas, and G. Puebla. Compo-
sitional clp-based test data generation for imperative languages. In
LOPSTR’11 , 2011.
[3] S. Anand, P. Godefroid, and N. Tillmann. Demand-driven compositional
symbolic execution. In TACAS , pages 367–381, 2008.
[4] D. Brumley, J. Caballero, Z. Liang, J. Newsome, and D. Song. Towards
automatic discovery of deviations in binary implementations with ap-
plications to error detection and ﬁngerprint generation. In SS, pages
15:1–15:16, Berkeley, CA, USA, 2007. USENIX Association.
[5] J. Burnim and K. Sen. Heuristics for scalable dynamic test generation.
In23rd IEEE/ACM International Conference on Automated Software
Engineering (ASE 2008), 15-19 September 2008, L’Aquila, Italy , pages
443–446, 2008.
[6] C. Calcagno, D. Distefano, P. O’Hearn, and H. Yang. Compositional
shape analysis by means of bi-abduction. In POPL’09 , 2009.
[7] C. Y . Cho, V . D’Silva, and D. Song. Blitz: Compositional bounded model
checking for real-world programs. In ASE, pages 136–146, 2013.
[8] L. A. Clarke. A program testing system. In Proc. of the 1976 annual
conference , ACM ’76, pages 488–491, 1976.
[9] I. Dillig, T. Dillig, A. Aiken, and M. Sagiv. Precise and compact modular
procedure summaries for heap manipulating programs. In PLDI’11 ,
2011.
[10] P. Godefroid. Compositional dynamic test generation. In POPL , pages
47–54, 2007.
[11] P. Godefroid, N. Klarlund, and K. Sen. Dart: directed automated random
testing. In PLDI , pages 213–223, 2005.
[12] P. Godefroid, A. V . Nori, S. K. Rajamani, and S. D. Tetali. Composi-
tional may-must program analysis: unleashing the power of alternation.
InPOPL , pages 43–56, 2010.
[13] S. Horwitz, T. W. Reps, and S. Sagiv. Demand interprocedural dataﬂow
analysis. In SIGSOFT FSE , pages 104–115, 1995.[14] K. Inkumsah and T. Xie. Improving structural testing of object-oriented
programs via integrating evolutionary testing and symbolic execution.
InASE, pages 297–306, 2008.
[15] S. Khurshid, C. S. P ˘as˘areanu, and W. Visser. Generalized symbolic
execution for model checking and testing. In TACAS , pages 553–568,
2003.
[16] J. C. King. Symbolic execution and program testing. Communications
of the ACM , 19(7):385–394, 1976.
[17] K. Ma, Y . P. Khoo, J. S. Foster, and M. Hicks. Directed symbolic
execution. In Static Analysis - 18th International Symposium, SAS 2011,
V enice, Italy, September 14-16, 2011. Proceedings , pages 95–111, 2011.
[18] S. Person, G. Yang, N. Rungta, and S. Khurshid. Directed incremental
symbolic execution. In PLDI , pages 504–515, 2011.
[19] C. S. P ˘as˘areanu and N. Rungta. Symbolic PathFinder: symbolic
execution of Java bytecode. In ASE, pages 179–180, 2010.
[20] J. M. Rojas and C. S. Pasareanu. Compositional symbolic execution
through program specialization. In BYTECODE’13 (ETAPS) , 2013.
[21] M. Souza, M. Borges, M. d’Amorim, and C. S. P ˘as˘areanu. CORAL:
solving complex constraints for Symbolic PathFinder. In NFM , pages
359–374, 2011.
[22] M. W. Whalen, P. Godefroid, L. Mariani, A. Polini, N. Tillmann, and
W. Visser. Fite: future integrated testing environment. In F oSER , pages
401–406, 2010.
[23] T. Xie, N. Tillmann, J. de Halleux, and W. Schulte. Fitness-guided
path exploration in dynamic symbolic execution. In Proceedings of the
2009 IEEE/IFIP International Conference on Dependable Systems and
Networks, DSN 2009, Estoril, Lisbon, Portugal, June 29 - July 2, 2009 ,
pages 359–368, 2009.
[24] G. Yang, S. Khurshid, S. Person, and N. Rungta. Property differencing
for incremental checking. In ICSE , pages 1059–1070, 2014.
[25] G. Yang, C. S. Pasareanu, and S. Khurshid. Memoized symbolic
execution. In ISSTA , pages 144–154, 2012.
642
642
642