All about Activity Injection: Threats, Semantics,
and Detection
Sungho Lee
KAIST, Korea
eshaj@kaist.ac.krSungjae Hwang
LG Electronics, Korea
sungje.hwang@lge.comSukyoung Ryu
KAIST, Korea
sryu.cs@kaist.ac.kr
Abstract —Android supports seamless user experience by main-
taining activities from different apps in the same activity stack.
While such close inter-app communication is essential in the
Android framework, the powerful inter-app communication con-
tains vulnerabilities that can inject malicious activities into avictim app’s activity stack to hijack user interaction ﬂows. In
this paper , we demonstrate activity injection attacks with a simple
malware, and formally specify the activity activation mechanismusing operational semantics. Based on the operational semantics,
we develop a static analysis tool, which analyzes Android apps
to detect activity injection attacks. Our tool is fast enough to
analyze real-world Android apps in 6 seconds on average, and
our experiments found that 1,761 apps out of 129,756 real-worldAndroid apps inject their activities into other apps’ tasks.
I. I NTRODUCTION
Smartphones have changed many facets of everyday life im-
mensely. People read books, listen to music, browse websites,
purchase goods, and send emails via smartphones withoutrestrictions of locations or time. Researchers report that morethan a half of smartphone users have used phones for online
banking apps and for monitoring their health conditions [1].
Thus, smartphones maintain various kinds of sensitive data,which makes the security of smartphones very important.
Compared to desktop apps, smartphone apps provide diverse
functionalities with seamless user experience by heavily inter-acting with other apps. For example, the Gallery app uses theEmail app to email pictures rather than having its own emailfunctionality. While users may think that a single app managespictures and sends emails, the actual implementation consistsof two independent apps using inter-app communication. Tosupport frequent transitions between apps, Android providespowerful multitasking by managing app activities [2] in a stackcalled a task [3], and it refers the task to ﬁnd an activity to
display. The task is an essential component to support userinteraction transitions smoothly by maintaining activities fromdifferent apps in the same activity stack.
However, the powerful inter-app communication contains
vulnerabilities that may break the sandbox environment ofAndroid. Even though each Android app resides in its ownsecurity sandbox, the ability of starting another app introducesa vulnerability that can inject malicious activities into thevictim app’s activity stack to hijack user interaction ﬂows.
The injected malicious activities can run in the context of avulnerable victim app, and thus can launch various attacksincluding phishing [4].Recently, researchers reported security issues in task behav-
iors with a proof-of-concept implementation of task hijacking
attacks [4]. They deﬁne these attacks as “malware [that] reside
side by side with the victim apps in the same task and hijack
the user sessions of the victim apps” task hijacking. While thetask hijacking attacks include true malicious actions, they iden-tify too many “normal” actions as vulnerable; among the mostpopular 10,985 apps from Google Play, they identiﬁed 93.9%of them as vulnerable, because they consider as vulnerable aswell even such cases where users intentionally select particularactivities. More importantly, because they used a simpliﬁedtask state transition model considering only two activities perapp and one instantiation per activity, the model does notcapture the actual task and activity behaviors correctly, whichleads to missing true malicious attacks.
In this paper, we present a class of critical task hijacking
attacks, activity injection attacks. To reduce the amount of
false alarms from identiﬁed task hijacking attacks, we deﬁneattacks that inject malicious activities into normal tasks asactivity injection attacks. To understand the root cause of theattacks, we formally specify the operational semantics of ac-tivity activation. The formalized semantics captures every taskbehavior described in the Android developers reference [5]without any constraints to limit the scope of task behaviors.As a showcase of activity injection attacks, we developed amalware targeting the Facebook app. Our malware injects amalicious activity into the task of Facebook so that Androiddisplays the malicious activity when users execute Facebookby clicking the Facebook icon. This kind of attacks is ex-tremely powerful because it does not require any permission,and it is difﬁcult for users to detect them because the attacksare launched when the users click legitimate apps’ icons.
Based on our thorough understanding of the activity acti-
vation semantics, we developed a static analyzer that detectactivity injection attacks in Android apps. Our experimentsshow that the tool is fast enough to analyze real-world Androidapps in 6 seconds on average. We found that 1,761 apps outof 129,756 Android apps have possible injection attacks.
The contributions of this paper include the following:
●We present the ﬁrst formal semantics of the Android ac-
tivity activation mechanism. Considering all the status ofactivity attributes and ﬂags for inter-app communication,we specify all possible task behaviors rigorously andexhaustively.
978-1-5386-2684-9/17/$31.00 c/circlecopyrt2017 IEEEASE 2017, Urbana-Champaign, IL, USA
T echnical Research252
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. ●We identify the root causes of activity injection attacks.
The formal semantics speciﬁes all possible ways of activ-
ity injection attacks, and we show an example malwarethat injects a malicious activity into a benign app’s task.
●We developed a static analysis tool that detects possible
activity injection attacks based on the formal semantics.
The tool is efﬁcient enough to detect possible activity
injection attacks in a large number of Android apps.
●We found and analyzed a number of possible activity
injection cases in real-world Android apps.
In the rest of this paper, we ﬁrst provide a brief background
about how Android apps communicate with other apps by
sharing activities (Section II). After formally specifying theactivity activation mechanism in Android and showing itssecurity vulnerability with a sample malware (Section III),we present a tool that detects activity injection attacks au-tomatically (Section IV). We show that our tool can detectactivity injection attacks from real-world Android apps efﬁ-ciently (Section V). We discuss related work (Section VI) andconclude (Section VII).
II. B
ACKGROUND
A. Android App Overview
Android apps reside in their own security sandboxes within
an Android system [6]. Android treats each app as a differentuser so that each app executes in isolation from others. Itprovides a secure environment because each app has ac-cess only to its components with permission. An app hasits own manifest ﬁle (
AndroidManifest.xml ) that declares
components and required device features for permission. AnAndroid app consists of app components that can be invoked
individually. An app component is one of four types: activities,
services, content providers, and broadcast receivers. Each
type serves a different role and has a different lifecycle.For example, an activity denotes a single screen with a userinterface like one for reading and one for writing emails.Android apps communicate with others via intents. An intent is
an asynchronous message that activates activities, services, and
broadcast receivers. Intents can start one component from an-
other even in a different app. For example, Gallery can start anactivity in Email to send emails by calling
startActivity() .
To share data with others and to access system services,Android apps can request permission to access them.
B. Activities and Tasks
Among four types of components, we focus on activities.
An activity is an instance of
android.content.Activity [2].
An app consists of multiple activities; when a user launches
an app, one designated “main” activity starts and it can
start another activities. The Android system manages runningactivities in a stack called a back stack, and it calls a pair of
a name and a back stack a task. When obvious, we use back
stacks and tasks interchangeably. The main activity is pushed
at the bottom of the task as the “root activity.” Whenever anew activity starts, the previous activity is stopped, the newactivity is pushed onto the task, and the user focus is with
Fig. 1. When Gallery com.android.gallery starts an activ-
ity to email a picture, the AutoSendActivity activity of Email
com.google.android.gm is pushed onto the task of Gallery.
the new activity. When the user presses the Back button, the
current activity is popped from the task and the previousactivity resumes. The topmost activity in the task is calleda “top activity” and it is the screen that a device displays.
Figure 1 illustrates that Gallery
com.android.gallery ,
Email com.google.android.gm , and a chat app
com.google.android.talk are executing on an Android
device. Each app has its own task; Gallery receives userinteraction in the foreground, while the other Email andchat apps are suspended in the background, waiting tobe resumed. Each task has its own root activity and topactivity. When Gallery is launched, the main activity
GalleryPicker is pushed onto the task of Gallery as its root
activity. When a user navigates images, Gallery starts the
ImageGallery activity and pushes it onto its task suspending
theGalleryPicker activity, which makes ImageGallery a
new top activity. Then, a user emails a picture by starting
AutoSendActivity , which becomes a new top activity. Note
that AutoSendActivity is an activity of Email; Gallery uses
an activity of Email to email pictures rather than having itsown email functionality.
The Android system provides various ways to manage activ-
ities using attributes in the
<activity> manifest element and
ﬂags in the intent that are passed to the startActivity()
function. For example, the launchMode attribute in the
<activity> manifest element speciﬁes one of four modes
to launch an activity: standard ,singleTop ,singleTask ,
andsingleInstance . The default mode is standard , and
the manifest ﬁle may deﬁne launch modes of activities. A
standard orsingleTop activity can be instantiated multiple
times leading to duplicated activities in a task. In contrast, anactivity with the
singleTask orsingleInstance launch
mode should be instantiated only once. Furthermore, an ac-tivity with the
singleInstance launch mode is always
the root activity of a task. While a singleTask activity
can contain other standard orsingleTop activities in its
task, a singleInstance activity does not contain any other
activities in its task. It is the only activity in its task; if itstarts another activity, that activity is assigned to a differenttask. Because the
singleTask andsingleInstance launch
modes provide a different interaction model from most other
apps, they are not appropriate for most apps.
253
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. Fig. 2. The malicious app Cinjects its malicious activities into the
tasks of victim apps AandBby specifying taskAffinity of the
malicious activities with the victim apps’ package names and setting the
FLAG_ACTIVITY_NEW_TASK intent ﬂag.
C. Activity Injection Attacks
Ren et al. [4] reported that the Android multitasking features
allow task hijacking attacks: letting “malware reside side by
side with the victim apps in the same task and hijack the
user sessions of the victim apps.” Because their deﬁnition of
task hijacking attacks is too broad, they conservatively identifynormal actions as vulnerable, which leads to impracticallymany false positives. For example, 93.9% of the most popular
10,985 apps from Google Play are identiﬁed as vulnerable,because they take activities of other apps to their tasks, which
is a normal inter-app communication in Android.
In this paper, we focus on activity injection attacks, which
inject activities of one app into another app’s task. Unlike
task hijacking attacks that consider activities in different apps’tasks, activity injection attacks focus on injection cases forphishing. For example, Figure 2 shows two tasks for the apps
AandB. Every app has its own task and, by default, the
name of the task is the app’s package name; A’s activities are
stored in the task com.example.A ,A’s package name, and B’s
activities are stored in the task com.example.B . While each app
maintains its own task, it is possible for adversaries to injecttheir malicious activities into other legitimate app’s task.
As we discuss in the next section, there are 220 ways to
make activity injection attacks. One such a way is to ﬁrst spec-ify the special attributes
taskAffinity andlaunchMode
of a malicious activity in the <activity> manifest element
with a victim app’s package name and standard , respec-
tively. Then, to call the startActivity() function for the
malicious activity with the FLAG_ACTIVITY_NEW_TASK intent
ﬂag set. Because the Android system refers taskAffinity
to decide where to put activities, adversaries can use the legiti-
mate app’s package name for taskAffinity of the malicious
activity. Figure 2 depicts that a malicious app Cinjects its
malicious activities into the tasks of AandBby specifying
taskAffinity with the victim apps’ package names and
setting the FLAG_ACTIVITY_NEW_TASK intent ﬂag. Note that
activity injection attacks do not require any permission.TABLE I
FOUR KINDS OF THE launchMode A TTRIBUTE
launchMode Description
standardMake a new instance whenever this activity is
activated.
singleTopMake a new instance only when the top
activity of the target task is not an instance ofthis activity.
singleTaskMake a new instance when there does not existany instance of this activity in any task.
singleInstanceMake a new instance when there does not existany instance of this activity in any task. It is
always the single activity in the task.
III. A CTIVITY ACTIV A TION MECHANISM
In this section, we describe the overview of the activity
activation mechanism, and specify the mechanism as an oper-
ational semantics, which spells out all possible task behaviorsrigorously and exhaustively. Using the semantics, we presentthe threats of activity injection attacks with an example mal-ware that injects a malicious activity into Facebook app’s task.
A. Activity Activation Overview
1) Tasks and Task Stack: The Android system may have
multiple tasks and one task stack. A task is a logical com-
ponent for showing a job to users, and a task stack is astack for managing the current foreground task and previousbackground tasks. A task has its own back stack to manageactivities. When the task comes to the foreground, the topactivity in its back stack is displayed on the device screen.When an activity ﬁnishes, the Android system pops it fromthe back stack of the task. If the back stack is not empty, thenew top activity is displayed on the screen. Otherwise, thetask itself ﬁnishes. The task stack behaves similarly with backstacks but it manages tasks. The top task in the task stack isthe foreground task, which interacts with users. When a taskﬁnishes, the Android system pops it from the task stack, andthe new top task, if any, is displayed on the screen. If the taskstack is empty, the Home screen comes to the foreground.Also, when the Home screen comes to the foreground, thetask stack is always empty.
Tasks may be alive after being popped from the task stack.
The task stack manages which task to display after ﬁnishingthe foreground task. When a user presses the Home button,the task stack becomes empty and the Home screen comes tothe foreground. Then, all live tasks popped from the task stackare still pending, and they may come back to the task stackwhen a user selects them from the overview screen [7].
2) Activity Activation Properties: Developers can spec-
ify how to activate target activities using various Androidproperties. Two kinds of properties mainly govern the activ-ity activation mechanism: the
launchMode attribute in the
<activity> manifest element and intent ﬂags used to start
activities. While launchMode is speciﬁed in the manifest
ﬁle for an activity class, intent ﬂags are set by caller ac-tivities to declare how to activate target activities by calling
startActivity() with the intent ﬂags as its arguments.
Table I describes four kinds of launchMode . Develop-
ers may set only one of them for each activity, and the
254
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. 1Intent i = new Intent(CallerActivity.this,
2 TargetActivity.class);
3i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
4startActivity(i);
(a) Java code for activation of TargetActivity .1<activity android:name=".TargetActivity"
2 android:taskAffinity="com.facebook.katana"
3 android:launchMode="standard">
4</activity>
(b)TargetActivity ’staskAffinity andlaunchMode .
Fig. 3. Code snippet for activity activation
s∈String task name, taskAffinity attribute
a∈ActivityInstance activity instance
A∈ActivityClass activity class
t∈Task=String×BackStack
l∈LaunchMode={ standard,singleTop ,
singleTask ,singleInstance}
F⊆IntentFlag={ FLAG_ACTIVITY_CLEAR_TASK ,
FLAG_ACTIVITY_CLEAR_TOP ,FLAG_ACTIVITY_MULTIPLE_TASK ,
FLAG_ACTIVITY_NEW_TASK ,FLAG_ACTIVITY_REORDER_TO_FRONT ,
FLAG_ACTIVITY_SINGLE_TOP ,FLAG_ACTIVITY_TASK_ON_HOME }
α∶∶=/epsilon1∣(a,l)::α∈BackStack
β∶∶=/epsilon1∣t::β∈TaskStack
γ∶∶=/epsilon1∣t::γ∈TaskPool
C∶∶=HomeButton
∣BackButton
∣(a,l).startActivity( A,l,s,F)
Fig. 4. Domains, stacks, and commands
default launchMode isstandard . While the started tar-
get activity is put on the task of the caller activity in
most cases, developers can designate a different task forthe target task. For example, Figure 3(a) shows Java codethat activates
TargetActivity from CallerActivity and
Figure 3(b) shows taskAffinity and launchMode of
TargetActivity deﬁned in AndroidManifest.xml .I nt h e
Java code, an Intent object is created with a caller activity
and a callee activity, and FLAG_ACTIVITY_NEW_TASK is
set to the intent object. Because taskAffinity of
TargetActivity iscom.facebook.katana andlaunchMode
isstandard ,TargetActivity is injected to the task of
com.facebook.katana when startActivity is invoked with
the intent object. Since the default value of taskAffinity is
the package name of the app, an activity is not injected to othertask when
taskAffinity of the activity is not speciﬁed.
Among 31 intent ﬂags, 19 ﬂags contain ACTIVITY in their
names [8] but only 7 ﬂags listed in IntentFlag in Figure 4 ac-
tually manage the activity activation mechanism. For example,
if the FLAG_ACTIVITY_NO_HISTORY ﬂag is set, the Android
system does not show the activity on the overview screen,
and as soon as the user navigates away from it, the activityﬁnishes. Thus, the ﬂag does not affect the activity activationmechanism in any ways.
Because a caller activity’s
launchMode also affects activity
activation, the number of ways to activate activities is:
# of caller activity’s launchMode×
# of target activity’s launchMode×
# of all combinations of intent ﬂags =
2×4×(0C7+1C7+2C7+3C7+4C7+5C7+6C7+7C7)=1024While the activity activation mechanism behaves differentlyfor all 4 kinds of
launchMode for target activities, it behaves
differently for only 2 cases for caller activities: whether acaller activity’s
launchMode issingleInstance or not. If a
caller activity’s launchMode issingleInstance , the activ-
ity activation mechanism behaves as if the intent ﬂags of thetarget activity contain
FLAG_ACTIVITY_NEW_TASK . For example, if
a caller activity’s launchMode is not singleInstance , the
FLAG_ACTIVITY_MULTIPLE_TASK intent ﬂag is ignored if one of
FLAG_ACTIVITY_NEW_TASK orFLAG_ACTIVITY_NEW_DOCUMENT
is not also set [8]. However, if a caller activity’s launchMode
issingleInstance ,FLAG_ACTIVITY_MULTIPLE_TASK is not ig-
nored even when FLAG_ACTIVITY_NEW_TASK is not also set. The
Android document just describes that singleInstance does
not allow other activities to be in the same task.
Among 1024 ways to activate activities, we can remove
infeasible or redundant ones by considering dependenciesbetween
launchMode and intent ﬂags. Some ﬂags should
be used together, some ﬂags implicitly imply other ﬂags,and some ﬂags should not be used with other ﬂags or some
launchMode . When conﬂicting ﬂags are used together, An-
droid selects one of them and ignores the others. When ﬂagsare used without other required ﬂags, Android ignores them.Figure 5 shows all dependencies between 4
launchMode
attributes of target activities and 7 intent ﬂags. Circle nodesdenote
launchMode and box nodes denote intent ﬂags. Three
types of edges denote dependencies between nodes: 1) solidmust edges denote that the property of the from node should
be used with the property of the tonode, 2) dashed imply
edges denote that the from node implies the to node, and
3) dotted ignore edges denote that the to node is ignored
when it is used with the from node. Because each activity can
have only one
launchMode , no dependency exists between
launchMode attributes. We built the dependency graph via
thorough analysis of the Android documentation [6] and ourown tests with Android devices. Using the dependency graph,we removed 791 out of 1024, leaving only 233 combinationsto consider. Our manual inspection showed that among 233,220 ways can inject activities to other tasks if a target activity’s
taskAffinity does not refer to the caller activity’s task.
B. Semantics
To provide a formal ground to understand the semantics of
various activity activation possibilities, we specify its opera-tional semantics. Figure 4 deﬁnes domains, stacks, and repre-sentative commands to describe the operational semantics. WewriteAfor an activity class and afor an activity instance. A
tasktis a pair of its name and its back stack (s,α). A back
255
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. standardsingleTop
FLAG_ACTIVITY_SINGLE_TOPsingleTask
FLAG_ACTIVITY_CLEAR_TOP FLAG_ACTIVITY_MULTIPLE_TASK
FLAG_ACTIVITY_NEW_TASK FLAG_ACTIVITY_REOREDER_TO_FRONTsingleInstanceFLAG_ACTIVITY_CLEAR_TASK
FLAG_ACTIVITY_TASK_ON_HOME
Fig. 5. Dependencies between launchMode attributes of target activities and intent ﬂags
⋆=getTaskWAct(γ,A)a′=new(A)(s,α)=getTask(γ,s)
γ′=removeTaskTP( γ,(s,α)) β′=removeTaskTS(β,(s,α)) t=(s,(a′,singleTask)::α)
⟨γ,β⟩⊢(a,l).startActivity (A,singleTask ,s,∅)→⟨t ::γ′,t::β′⟩
Fig. 6. Activity injection semantics used in the sample malware
Fig. 7. Task stack showing that a malicious activity is injected in the task of the legitimate Facebook app.
stack is a sequence of activities; an activity is a pair of its
activity instance and its launch mode (a,l). The task stack
and task pool are sequences of tasks. To represent the activity
activation concisely, we focus on three commands: pressing
the Home button, pressing the Back button, and startingan activity. The(a,l).
startActivity(A,l′,s,F)command
denotes that the caller activity is (a,l), the target activity is A
with the launchMode attributel′and the task name sfrom
itstaskAffinity , and the intent ﬂags are F.
The judgments are of the form ⟨γ,β⟩⊢C→⟨γ′,β′⟩, which
denotes that when the current task pool is γand the current
task stack is β, evaluation of the command Cresults in
the new task pool γ′and the new task stack β′. Thus,
⟨γ,β⟩⊢HomeButton→⟨γ,/epsilon1⟩speciﬁes that whenever a user
presses the Home button, the task pool remains the same butthe task stack becomes empty. All the behaviors of pressingthe Back button are:
⟨γ,/epsilon1⟩⊢BackButton→⟨γ,/epsilon1⟩
α=(a,l)::/epsilon1γ′=removeTaskTP( γ,(s,α))
⟨γ,(s,α)::β⟩⊢BackButton→⟨γ′,β⟩
α=(a,l)::α′α′/ =/epsilon1γ′=removeTaskTP( γ,(s,α))
⟨γ,(s,α)::β⟩⊢BackButton→⟨(s,α′)::γ′,(s,α′)::β⟩
The ﬁrst speciﬁes that if a user presses the Back button whenthe task stack is empty, the display remains the same withoutany changes in the task pool or in the task stack. The seconddescribes that when the top task on the task stack has only
one activity, the Back button removes the task from both thetask pool and the task stack. The third describes that when
the top task on the task stack has more than one activities, theBack button removes the top activity from the task both in the
task pool and the task stack. Figure 12 in Appendix describes
all the helper functions. For the last command, the semanticshas 239 rules. We can split them into 4 cases depending onthe target activity’s
launchMode . Figure 12 shows one case
when the target activity’s launchMode issingleTask . Due
to the space limitation, we describe the remaining rules and
helper functions in a companion report [9].
C. Implementation of Malware
Activity injection attacks can steal users’ private data like
phishing attacks. Since launching benign apps can run ma-
licious activities, it is difﬁcult for users to notice maliciousactivities. For example, if a malware disguises an activity asa login page of a benign app and injects it to the app, it cansteal users’ id and password information. To demonstrate suchattacks, we developed a malware targeting the Facebook app.Among 239 rules for the
startActivity function call in
our operational semantics, 180 rules specify possible activityinjection attacks. While we can make malicious apps utilizing
any of such rules, we developed a malware using the semanticsdescribed by the rule in Figure 6 to show its practicality.
Figure 7 shows a snapshot of the task stack when we ﬁrst
run the legitimate Facebook app, execute our malware, and
let the malware inject a malicious activity in the task ofFacebook. The task stack #70 contains two tasks: #329 for
256
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. Intent Data
Activity Injection 
Detector
Intent Analyzer CallGraph
Activity Info. 
Extractor
CHA CallGraph 
Builder
Activity 
Info.APK
Injection 
Report
Fig. 8. Overall structure of the static analysis tool
F={FLAG ACTIVITY SINGLE TOP, FLAG ACTIVITY NEWTASK}
⋆=getTask (γ,s)a/prime=new(A)t=newTask (s,(a/prime,standard))
/angbracketleftγ,β/angbracketright/turnstileleft(a,l).startActivity( A,standard,s,F )→/angbracketleftt::γ,t ::β/angbracketright
F={FLAG ACTIVITY SINGLE TOP, FLAG ACTIVITY NEWTASK}
(s,α)=getTask (γ,s)α=(a/prime,l/prime)::α/prime¬instanceOf (a/prime,A)a/prime/prime=new(A)
α/prime/prime=(a/prime/prime,standard) ::αγ/prime=removeTaskTS (γ,(s,α))β/prime=removeTaskBS (β,(s,α))
/angbracketleftγ,β/angbracketright/turnstileleft(a,l).startActivity( A,standard,s,F )→/angbracketleft(s,α/prime/prime)::γ/prime,(s,α/prime/prime)::β/prime/angbracketright
F={FLAG ACTIVITY SINGLE TOP, FLAG ACTIVITY NEWTASK}
(s,α)=getTask (γ,s)α=(a/prime,l/prime)::α/primeinstanceOf (a/prime,A)
γ/prime=removeTaskTS (γ,(s,α))β/prime=removeTaskBS (β,(s,α))
/angbracketleftγ,β/angbracketright/turnstileleft(a,l).startActivity( A,standard,s,F )→/angbracketleft(s,α)::γ/prime,(s,α)::β/prime/angbracketright
Activity Info. Intent Data
com.example.AActivity
taskAﬃnity: com.fac..
launchMode: standard
com.example.BActivity
…com.example.AActivity
FLAG_ACTIVITY_NEW_TASKFLAG_ACTIVITY_SINGLE_TOP
com.example.AActivity
…
Activity Activation Data
com.example.AActivity
taskAﬃnity: com.facebook.katanalaunchMode: standardIntentFlags: {FLAG_ACTIVITY_NEW_TASK 
IntentFlags: {FLAG_ACTIVITY_SINGLE_TOP}
com.example.AActivity
…1
2
1
2
Fig. 9. Example for Activity Injection Detector mechanism
Facebook ( com.facebook.katana ) and #330 for the malware
(com.example.malicious ). The task of Facebook contains
two activities: #0 for launching a login activity of the Face-
book app ( com.facebook.katana/.FacebookLoginActivity )
and #1 for the malicious activity injected by the malware
(com.example.malicious/.MaliciousActivity ).
Our malware injects the malicious activity when the screen
is off, because it will be displayed on the screen when the
injection occurs. Once the malicious activity is injected intothe Facebook task, it immediately calls the Home activity sothat the screen shows the Home screen when the screen isturned on again. Because the malicious activity is the topactivity of the Facebook task, it will be displayed when a usertouches the Facebook icon
1. In order to launch the activity
injection attack, we assume that our malware is installed ona victim’s mobile device (similarly for [10], [11], [12], [13],[4]). Note that injecting a malicious activity does not requireany permission; our malware requires only the INTERNETpermission to send users’ private data to the attacker’s server.
The root cause of this threat is that the Android system
supports the activity injection feature without any protection
policy against malicious apps. One of the possible mitigations
is a system-level access control that prohibits apps from inject-ing activities into other target apps’ task without authorizationsof the targets. We are discussing this issue with the Androidsecurity team.
1http://plrg.kaist.ac.kr/doku.php?id=research:materialIV . A CTIVITY INJECTION DETECTOR
Based on the formal semantics of activity activation, we
developed a static analyzer that detects possible activity in-jection attacks in Android apps. We implemented it on top ofW ALA [14], an open-source static analysis framework. Theprototype implementation of the tool is publicly available
2.
The overall structure of the tool is illustrated in Figure 8.
From a given Android apk archive, Activity Info. Extractor
builds information about the activities in the app; it disas-sembles the resource ﬁles of the app using apktool [15] andextracts
launchMode andtaskAffinity of the activities
from the AndroidManifest.xml ﬁle. Also, CHA CallGraph
Builder takes the apk and constructs its call graph via Class
Hierarchy Analysis (CHA) [16], which is often less precisethan pointer analysis but much faster, since it analyzes onlytypes rather than values. Then,
Intent Analyzer extracts intent
data that activate activities from the call graph. The intent
data contain the target activity names of the intent and the
set of intent ﬂags added to the intent. Finally, Activity Injection
Detector takes the activity information with intent data, and
produces a report of possible activity injections. Using theactivity information, intent data, and the activity activationsemantics, it analyzes possible activity injection cases.
Similar to
FlowDroid [17], Intent Analyzer tracks intent data
ﬂows via a forward analysis from intent object creation sitesto the
startActivity method, and detects object aliases via
a backward analysis from the locations where intent data are
2https://github.com/SunghoLee/AIDetector
257
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. Total Apps
129,756
Possible  
to Inject 
4,763
Impossible  
to Inject 
124,993
Analysis  
in Time 
4,633
Analysis 
Timeout 
130
Injection  
Detected 
1,761
Injection 
Not Detected 
2,872
(a)Analysis results in terms of apps
Total Injections 
4,133
No Duplicates 
531
Duplicates 
3,602
Inter-ﬂow Intent 
53
Intra-ﬂow Intent 
478
True Positives 
51
False Positives 
2
(b)Analysis results in terms of injections
Fig. 10. Analysis results of 129,756 Android apps
set to object ﬁelds. While Android supports both explicit and
implicit intents, where the former uses concrete target activities
to activate and the latter uses string values to denote target
activities, our tool analyzes only explicit intents. Becauseanalyzing the targets of implicit intents requires a precisestring analysis, the tool does not consider implicit intents.Similarly, the tool does not analyze ﬂows involving built-in method calls and static ﬁelds. Even though the prototypeimplementation of the tool does not address such features thatare not the main interests of this paper, we believe that we
can easily integrate other analyzers that can analyze them.
In addition, the tool covers about a half of the activity injec-
tion rules in the operational semantics. While one can inject a
target activity without the
FLAG_ACTIVITY_NEW_TASK ﬂag if
a caller activity’s launchMode issingleInstance , because
singleInstance is not applicable to most applications [18],
the tool does not consider launchMode of caller activities.
Figure 9 illustrates how Activity Injection Detector works.
It takes two inputs: Activity Info. with taskAffinity and
launchMode for each activity, and Intent Data with intent ﬂags
for each activity activation. Because an activity may be acti-vated multiple times,
Intent Data in the ﬁgure contains multiple
entries for com.example.AActivity . It merges two inputs
into Activity Activation Data and matches each entry with the
operational semantics rules. For example, because the ﬁrst en-
try speciﬁes that launchMode of a target activity is standard
and the intent ﬂags are FLAG_ACTIVITY_NEW_TASK and
FLAG_ACTIVITY_SINGLE_TOP , one of three rules on the right
side may be applicable. Note that no matter which rule is ap-plied, the target activity a
′always exists in the task pointed by
taskAffinity at the activity activation time. Thus, the tool
detects com.example.AActivity as an injected activity.
V. E V ALUA TION
In this section, we evaluate our tool using 129,756 Android
apps collected from AndroZoo [19] with timeout of 5 minutes.
We performed all the experiments on a Linux x64 machinewith 4.0GHz Intel Core i7 CPU and 8GB memory.
A. Experiment Results
The overall results of our experiments are shown in Fig-
ure 10. As Figure 10(a) presents, we ﬁrst identiﬁed apps
that may be open to activity injection. When an app has anactivity, which contains
taskAffinity that is different from
the package name of the app, it is open to activity injection.
Otherwise, it is not possible to inject activities to such apps.Out of 129,756 Android apps, 4,763 apps, only about 3.7% of
Number of Apps
01000200030004000
Analysis Time (sec.)0~10 11~20 21~30 31~300 timeout13047 706413,875
Fig. 11. Analysis time of 4,763 Android apps
the total apps, are open to activity injection. Among 4,763
apps, our tool could ﬁnish analysis of 97.3%; it did notﬁnish analysis of only 130 apps in 5 minutes. Finally, thetool detected activity injection cases from 1,761 apps, whichamounts to about 1.4% of the total apps.
From 1,761 apps, the tool detected 4,133 possible activity
injection cases. As Figure 10(b) presents, among 4,133 injec-tion cases, only 531 cases are unique and the remaining 3,602cases are duplicated ones. We identiﬁed injection cases usingtheir activity names. For example, when the tool reports that
com.example.AActivity is injected multiple times to a single
app or multiple apps, we count it as one injection case. Toevaluate the precision of the tool, we partitioned 531 uniqueinjection cases into the ones with relatively complex data ﬂowsand the others. More speciﬁcally, we identiﬁed such cases thatrequire inter-procedural data ﬂows to detect the injection cases
as complex data ﬂows, which amounts to 53 injection cases.
We manually investigated them, and found that only two casesare false positives and the remaining 51 cases are all truepositives. Thus, the false positive rate of the tool is only 3.8%.
The tool reported a very low false positive rate even though
its CHA-based call graph construction produces imprecise callgraphs in general, thanks to simple usage patterns of intents.Usually, intent objects use only simple data ﬂows as shown bythe number of intra-procedural data ﬂows in Figure 10(b). Ourmanual inspection revealed that most inter-procedural intentdata ﬂows are through static methods that do not affect theimprecision of graph construction. While CHA-based analysesare generally imprecise for code patterns with complex classinheritance relations, most apps do not use complex classhierarchy for activity activation. Thus, the simple call graphconstruction did not harm the precision of our tool much.
Figure 11 summarizes the analysis time of 4,763 apps. The
tool can identify the apps not open to activity injection in 1 or2 seconds. The X-axis denotes analysis time, and the Y -axisdenotes the number of apps. The tool analyzed 4,586 apps,
258
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. TABLE II
ACTIVITIES INJECTED FROM MULTIPLE APPS
Activity Name # of Apps
com/startapp/android/publish/AppWallActivity 1,279
com/startapp/android/publish/list3d/List3DActivity 1,254
com/cmcm/picks/PicksLoadingActivity 40
com/widdit/lockScreen/activities/ 30
TermsAndConditionsActivity
com/applift/playads/PlayAdsActivity 12
com/zdworks/android/zdclock/ui/alarm/AlarmActivity 6
org/chromium/BackgroundActivity 6
com/igexin/getuiext/activity/GetuiExtActivity 6
ccc71/at/activities/at_ui_progress 6
com/csipsimple/ui/incall/InCallMediaControl 6
org/saturn/stark/interstitial/comb/activity/ 5
NativeAdActivity
com/tencent/mm/ui/transmit/TaskRedirectUI 5
about 96.3% of 4,763 apps, in 30 seconds, and the average
analysis time is 6 seconds except for timeout apps. The overallanalysis time shows that our tool detects possible activityinjection attacks in a large number of real-world Android apps.
We measured the unsoundness effects of our restrictions in
analysis of the target apps. As we discussed in Section IV, weintentionally ignored analysis of data ﬂows via static ﬁelds
and built-in methods, and
launchMode of caller activities
for the analysis performance. We investigated how many apps
have such features, and found that the tool may miss activityinjection cases in 287 apps, about 6.0% of 4,763 apps.
B. Case Studies
We discuss three representative cases of activity injection.
1) Activities injected from multiple apps: We ob-
served that some activities are included in multiple apps,
and injected to another task. We summarize the ac-
tivities injected from ﬁve or more apps in Table II.Among them, ﬁve activities are for mobile advertisingplatforms:
AppWallActivity and List3DActivity are
for StartApp [20], PicksLoadingActivity is for Ap-
podeal [21], PlayAdsActivity is for AppLift [22], and
GetuiExtActivity is for igexin [23]. Mobile advertising
platforms use different tasks from their integrated apps so that
they can logically separate their advertisement activities fromthe apps’ activities. Two activities are from app developmentframeworks:
BackgroundActivity is from Cordova [24]
andTaskRedirectUI is from Tencent [24]. Both frameworks
are widely used for Android app development. Three activities
are included in libraries: TermsAndConditionsActivity is
in Homebase [25], which supports personalized lock screen
of mobile phone, at_ui_progress is in 3C Toolbox [26],
which supports other apps’ paid functionalities for free, and
InCallMediaControl is in CSipSimple [27], which is an
open-source session initiation protocol software. We foundthat
AlarmActivity is injected from 6 apps, but all the
apps have the same package name. Because Google Play doesnot allow duplicated package names, we believe that they arethe same app possibly crawled from different app stores byAndroZoo. Finally, we failed to ﬁnd any information about
NativeAdActivity , although the activity name implies a
mobile advertising platform.2) Suspicious activity injection cases: To understand the
reported activity injection cases in more detail, we collected
“suspicious” cases where taskAffinity of the activities are
the names of existing applications’ packages, libraries, or their
subdomains. Out of 531 unique injection cases, we collected12 such cases. The collected cases are highly suspicious, butthe other cases may be malicious as well.
We summarize the cases in Table III. Among 12 tar-
gets, Umeng is a mobile advertising platform library andthe others are applications. For example, we found thatthe app
com/netngroup/point has an activity injection
to the task com/umeng/community of the library Umeng.
Interestingly, two cases inject activities into Android built-inapps’ tasks:
com/tencent/android/qqdownloader injects
an activity into the task of the Android package installer,and
com/lookout injects an activity into the task of Google
Chrome, the default browser of Android. Thus, when userslaunch such built-in apps, they may use injected activitiesinstead of the built-in apps’ activities. Because the built-inapps are installed on every Android device and they are highlysensitive to the device security, such injected activities mayopen the gate to security threats.
a) Redundant usage of
launchMode and intent ﬂags:
In some injection cases, an intent object has a redundantintent ﬂag for activity activation:
FLAG_ACTIVITY_NEW_TASK
is unnecessary when launchMode of a target activity is
singleTask , because the target activity is always injected
into a task pointed by the taskAffinity . However, we
observed that 73 out of 531 activity injection cases haveboth
launchMode and the ﬂag. Since the activity activation
mechanism is complex and difﬁcult to understand from theAndroid document, redundant or misused intent ﬂags may be
discovered in various real-world Android apps. We believe
that our formal semantics would be helpful for developers tounderstand the activity activation mechanism clearly.
VI. R
ELA TED WORK
Recently, various attacks for Android apps have been
reported. They leverage vulnerabilities in inter- and intra-app communication [28], content providers [29], permissionsystems [30], push message services [31], OAuth [32], hybridweb app frameworks [33], dynamic code loading [34], Android
public resources [13], vendor customization [35], [36], [37],
the WebView API [38], and advertisement libraries [39].
Among various Android security issues, we focus on the
Android UI security, which has been extensively studied.Leveraging the ADB daemon, third-party apps can steal users’private data by stealthily taking screen shots [40], [41]. Chenet al. [10] reported the UI state inference attack, which
exploits the public side channel to demonstrate activity hijack-ing attacks. Roesner and Kohno [42] demonstrated securityproblems of embedded user interfaces in Android. Niemietz
and Schwenk [43] reported the UI Redressing attack, which
leverages special characteristics of the toast view. Kraunelis et
al.[44] reported the Masquerade attack using the accessibility
framework in Android. Luo et al. [45] showed launching
259
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. TABLE III
SUSPICIOUS INJECTION CASES ,NAMES OF THEIR TARGET APPS OR LIBRARIES ,AND THEIR TARGET TASKS
App with Activity Injection Target App or Library Target Task
com/dianxinos/dxhome 91PandaHome2 com/nd/android/pandahome2/manage/shop/ThemeShopMainActivity
com/tencent/android/qqdownloader Android package installer com/android/packageinstaller
com/duapps/antivirus Caller ID Recorder com/whosthat/aftercall/tips
com/jushine/chouse Days Money Book com/bora/chouse/ImageViewActivity
cn/opda/a/phonoalbumshoushou DU Speed Booster & Cleaner com/dianxinos/optimizer/task/sevenkey
com/jiubang/goscreenlock GO Launcher com/gau/go/launcherex
com/lookout Google Chrome com/android/chrome
com/j3gha/mailclient K-9 Mail com/fsck/k9/activity/setup/Prefs
com/emoji/input/gif/theme/keyboard PIP Launcher cm/theme/wallpaper/launcher/locksceen
com/csms/activities Power Assistant 4.1.2 com/zhimahu/null
com/netngroup/point Umeng com/umeng/community
com/goldbean/yoyo WeChat com/tencent/mm
Touchjacking attacks using the WebView API. Felt and Wag-
ner [46] analyzed phishing attacks on mobile devices.
The most closely related work to ours is Taskhijacking
attacks [4], which lead users into malicious activities sharing
benign apps’ tasks. Taskhijacking attacks include all the cases
where multiple apps share a task, many of which are normalinter-app communication, but we focus on activity injectionattacks where apps inject an activity into another app’s task.Also, our work signiﬁcantly improved the previous work inthat we speciﬁed all the semantic behaviors formally and
exhaustively without any restrictions that the previous workmade to build transition diagrams via testing and, we detected
possible activity injection attacks in real-world Android apps.
Researchers have tried to analyze Android apps that utilize
Inter-Component Communication (ICC). SCanDroid [47] isone of the ﬁrst static analyzers for Android apps. Basedon a formal constraints system for a core ICC language,SCanDroid collects constraints for each component, and solvesthe collected constraints altogether considering all the callerand callee relations to analyze data ﬂows between compo-nents. ComDroid [48] can detect seven kinds of potentialvulnerabilities in Android ICC, and it speciﬁcally focuses onimplicit intents. SmartDroid [49] uses both a static analysis
and a dynamic analysis. During static analysis, it analyzes
intent data ﬂows to construct Activity Call Graphs (ACGs)that present caller and callee activities. Using the graph, itautomatically triggers UI events of each activity to detectsensitive behaviors executed by UI interactions. Epicc [50]
reduces ICC to an instance of the Inter-procedural Distributive
Environment (IDE) problem, and it detects ICC vulnerabilitiesvia solving the IDE problem with lower false positive ratesthan SmartDroid. Apposcopy [51] performs taint analysis onInter-Component Call Graph (ICCG) using intent informationto detect privacy leakage in Android app. AmanDroid [52]
constructs Inter-component Data Flow Graph (IDFG) via a
pointer analysis, and models various Android APIs to extractintent information and to link data ﬂows between compo-nents. DroidSafe [53] reports sensitive information leakagesin Android apps. It computes the values of intent objects via astring analysis, ﬁnds the target components of the intent object
values, and replaces the inter-component calls with explicitcall instructions to the target components. IC3 [54] constructsinter-procedural Data Dependence Graph (DDG) and tracksdata ﬂows on DDGs to collect intent information. Based onIC3, IccTA [55] instruments Android apps’ bytecode to replace
inter component calls with explicit call instructions, and trackstaint data to detect sensitive data leakages.
The main difference between the above approaches and ours
is the analysis purpose. While the existing approaches focus onanalysis of control and data ﬂows between components, we fo-cus on efﬁcient analysis of the activity activation mechanism.Unlike other approaches, we speciﬁed a formal semanticsfor the activity activation mechanism, and our tool considers
launchMode , intent ﬂags, and the semantics to detect activity
injection attacks that no other tools could detect.
VII. C ONCLUSION
The Android multitasking features are extremely powerful
and useful, but, at the same time, they are vulnerable toactivity injection attacks. Because there are hundreds waysto launch activities, it is very difﬁcult for developers tounderstand the activity activation behaviors clearly. Moreimportantly, the complex behaviors contain various ways toinject malicious activities to legitimate apps. To alleviate theproblem, we formally specify the activity activation semanticsexhaustively, identify possible places for activity injectionattacks, and implement a sample malware to show that theactivity injection attacks are realistic and dangerous. Basedon the formal semantics of activity activation, we developed astatic analyzer to detect activity injection attacks in Androidapps. The tool is fast enough to analyze real-world Androidapps in 6 seconds on average, and it is precise enough tohave only 3.8% false positive rate. Our experiments showedthat 1,761 out of 129,756 Android apps inject their activitiesinto other apps’ tasks, and our manual investigation revealedthat 12 apps inject their activities into the tasks of Androidapps including built-in apps’ tasks. We believe that the formalsemantics of the activity activation mechanism would helpdevelopers to understand the complex mechanism clearly, andthe tool would be useful in detecting activity injection attacksin a large number of Android apps efﬁciently.
A
CKNOWLEDGMENT
This work received funding from National Research Foun-
dation of Korea(NRF) (Grant NRF-2017R1A2B3012020).
260
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. Helper function Type Description
new ActivityClass→ActivityInstance returns an instance of a given activity class
newTask String ×(ActivityInstance×LaunchMode)→ Task creates a new task with a given task name, activity
instance, and its launch mode
removeTaskTP TaskPool ×Task→TaskPool removes a given task from a given task pool
removeTaskTS TaskStack ×Task→TaskStack removes a given task from a given task stack
removeActsUntil BackStack ×(ActivityInstance×LaunchMode) removes activity instances on top of and including
→BackStack a given activity instance from a given back stack
getTask TaskPool ×String→Task∪{⋆} returns⋆for absence or a task with a given name
from a given task pool
getActivity BackStack ×ActivityClass→ActivityInstance∪{⋆} returns⋆for absence or an instance of a given activity
class from a given back stack
getTaskWAct TaskPool ×ActivityClass→Task∪{⋆} returns⋆for absence or a task that contains an
instance of a given activity class from a given task pool
Target activity’s launchMode issingleTask:
⋆=getTaskWAct(γ,A)a′=new(A)⋆ = getTask(γ,s)t=newTask(s,(a′,singleTask))
⟨γ,β⟩⊢(a,l).startActivity (A,singleTask ,s,∅)→⟨t ::γ,t::β⟩
⋆=getTaskWAct(γ,A)a′=new(A)(s,α)=getTask(γ,s)
γ′=removeTaskTP( γ,(s,α)) β′=removeTaskTS(β,(s,α)) t=(s,(a′,singleTask)::α)
⟨γ,β⟩⊢(a,l).startActivity (A,singleTask ,s,∅)→⟨t ::γ′,t::β′⟩
(s,α)=getTaskWAct (γ,A)γ′=removeTaskTP( γ,(s,α)) β′=removeTaskTS(β,(s,α))
a′=getActivity( α,A) α′=removeActsUntil(α,(a′,singleTask))t=(s,(a′,singleTask)::α′)
⟨γ,β⟩⊢(a,l).startActivity (A,singleTask ,s,∅)→⟨t ::γ′,t::β′⟩
F={FLAG_ACTIVITY_CLEAR_TASK }⋆ = getTaskWAct(γ,A)a′=new(A)⋆ = getTask(γ,s)t=newTask(s,(a′,singleTask))
⟨γ,β⟩⊢(a,l).startActivity (A,singleTask ,s,F)→⟨t::γ,t::β⟩
F={FLAG_ACTIVITY_CLEAR_TASK }⋆ = getTaskWAct(γ,A)a′=new(A)
t=getTask(γ,s)γ′=removeTaskTP( γ,t)β′=removeTaskTS(β,t)t′=newTask(s,(a′,singleTask))
⟨γ,β⟩⊢(a,l).startActivity (A,singleTask ,s,F)→⟨t′::γ′,t′::β′⟩
F={FLAG_ACTIVITY_CLEAR_TASK }t=getTaskWAct(γ,A)γ′=removeTaskTP( γ,t)
β′=removeTaskTS(β,t)a′=new(A)t′=newTask(s,(a′,singleTask))
⟨γ,β⟩⊢(a,l).startActivity (A,singleTask ,s,F)→⟨t′::γ′,t′::β′⟩
F={FLAG_ACTIVITY_TASK_ON_HOME }⟨γ,β⟩⊢(a,l).startActivity (A,singleTask ,s,∅)→⟨γ′,t::β′⟩
⟨γ,β⟩⊢(a,l).startActivity (A,singleTask ,s,F)→⟨γ′,t::/epsilon1⟩
F={FLAG_ACTIVITY_CLEAR_TASK ,FLAG_ACTIVITY_TASK_ON_HOME }F′={FLAG_ACTIVITY_CLEAR_TASK }
⟨γ,β⟩⊢(a,l).startActivity (A,singleTask ,s,F′)→⟨γ′,t::β′⟩
⟨γ,β⟩⊢(a,l).startActivity (A,singleTask ,s,F)→⟨γ′,t::/epsilon1⟩
Fig. 12. Operational semantics for starting an activity when the target activity’s launchMode issingleTask .
261
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. REFERENCES
[1] A. Smith and D. Page, “U.S. smartphone use in 2015,” http://www.
pewinternet.org/ﬁles/2015/03/PI Smartphones 0401151.pdf, 2015.
[2] “Android Activity,” http://developer.android.com/reference/android/app/
Activity.html.
[3] “Task and Back Stack,” http://developer.android.com/guide/components/
tasks-and-back-stack.html.
[4] C. Ren, Y . Zhang, H. Xue, T. Wei, and P . Liu, “Towards discovering
and understanding task hijacking in Android,” in SEC, 2015.
[5] “Android Developers Reference,” http://developer.android.com/
reference/packages.html.
[6] “Introduction to Android,” http://developer.android.com/guide/index.
html.
[7] “Overview screen,” http://developer.android.com/guide/components/
recents.html.
[8] “Android Intent,” http://developer.android.com/intl/ko/reference/android/
content/Intent.html.
[9] S. Lee, S. Hwang, and S. Ryu, “Operational semantics for the an-
droid activity activation mechanism,” http://plrg.kaist.ac.kr/doku.php?
id=research:material#technical reports, 2017.
[10] Q. A. Chen, Z. Qian, and Z. M. Mao, “Peeking into your app without
actually seeing it: UI state inference and novel android attacks,” in SEC,
2014.
[11] E. Miluzzo, A. V arshavsky, S. Balakrishnan, and R. R. Choudhury,
“Tapprints: Y our ﬁnger taps have ﬁngerprints,” in Proceedings of the
10th International Conference on Mobile Systems, Applications, andServices, 2012.
[12] Z. Xu, K. Bai, and S. Zhu, “Taplogger: Inferring user inputs on smart-
phone touchscreens using on-board motion sensors,” in Proceedings of
the 5th ACM Conference on Security and Privacy in Wireless and Mobile
Networks, 2012.
[13] X. Zhou, S. Demetriou, D. He, M. Naveed, X. Pan, X. Wang, C. A.
Gunter, and K. Nahrstedt, “Identity, location, disease and more: Inferringyour secrets from Android public resources,” in CCS, 2013.
[14] IBM, “T.J. Watson libraries for analysis,” http://wala.sourceforge.net/
wiki/index.php/Main
Page, 2006.
[15] “Apktool,” https://ibotpeaches.github.io/Apktool/, 2010.
[16] J. Dean, D. Grove, and C. Chambers, “Optimization of object-oriented
programs using static class hierarchy analysis,” in European Conference
on Object-Oriented Programming. Springer, 1995, pp. 77–101.
[17] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel, J. Klein,
Y . Le Traon, D. Octeau, and P . McDaniel, “Flowdroid: Precise context,ﬂow, ﬁeld, object-sensitive and lifecycle-aware taint analysis for android
apps,” Acm Sigplan Notices, vol. 49, no. 6, pp. 259–269, 2014.
[18] A. developer, “activity element,” https://developer.android.com/guide/
topics/manifest/activity-element.html#aff, 2017.
[19] K. Allix, T. F. Bissyand ´e, J. Klein, and Y . Le Traon, “Androzoo:
Collecting millions of android apps for the research community,” in
Proceedings of the 13th International Conference on Mining Software
Repositories. ACM, 2016, pp. 468–471.
[20] “Startapp,” http://www.startapp.com, 2017.[21] “Appodeal,” https://www.appodeal.com, 2017.[22] “Applift,” http://www.applift.com, 2017.
[23] “igexin,” http://www.igexin.com, 2017.
[24] “Apache cordova,” https://cordova.apache.org, 2017.[25] “Homebase sdk,” http://www.widdit.com/home/, 2017.
[26] “3c toolbox,” http://www.3c71.com/android/?q=node/2442, 2017.
[27] “Csipsimple,” https://github.com/r3gis3r/CSipSimple, 2017.[28] E. Chin, A. P . Felt, K. Greenwood, and D. Wagner, “Analyzing inter-
application communication in Android,” in Proceedings of the Interna-
tional Conference on Mobile Systems, Applications, and Services , 2011.
[29] Y . Zhou and X. Jiang, “Detecting passive content leaks and pollution in
Android applications,” in NDSS, 2013.
[30] A. P . Felt, H. J. Wang, A. Moshchuk, S. Hanna, and E. Chin, “Permission
re-delegation: Attacks and defenses,” in SEC, 2011.
[31] T. Li, X. Zhou, L. Xing, Y . Lee, M. Naveed, X. Wang, and X. Han,
“Mayhem in the push clouds: Understanding and mitigating security
hazards in mobile push-messaging services,” in CCS, 2014.
[32] E. Y . Chen, Y . Pei, S. Chen, Y . Tian, R. Kotcher, and P . Tague, “Oauth
demystiﬁed for mobile application developers,” in CCS, 2014.
[33] M. Georgiev, S. Jana, and V . Shmatikov, “Breaking and ﬁxing origin-
based access control in hybrid web/mobile application frameworks,” inNDSS, 2014.[34] S. Poeplau, Y . Fratantonio, A. Bianchi, C. Kruegel, and G. Vigna,
“Execute this! Analyzing unsafe and malicious dynamic code loading
in Android applications,” in NDSS, 2014.
[35] L. Wu, M. Grace, Y . Zhou, C. Wu, and X. Jiang, “The impact of vendor
customizations on Android security,” in CCS, 2013.
[36] X. Zhou, Y . Lee, N. Zhang, M. Naveed, and X. Wang, “The peril of frag-
mentation: Security hazards in Android device driver customizations,”
inS&P, 2014.
[37] M. Grace, Y . Zhou, Z. Wang, and X. Jiang, “Systematic detection of
capability leaks in stock Android smartphones,” in NDSS, 2012.
[38] T. Luo, H. Hao, W. Du, Y . Wang, and H. Yin, “Attacks on WebView in
the Android system,” in ACSAC, 2011.
[39] P . Pearce, A. P . Felt, G. Nunez, and D. Wagner, “Addroid: Privilege
separation for applications and advertisers in Android,” in Proceedings
of the 7th ACM Symposium on Information, Computer and Communi-cations Security, 2012.
[40] C.-C. Lin, H. Li, X. Zhou, and X. Wang, “Screenmilker: How to milk
your Android screen for secrets,” in NDSS, 2014.
[41] S. Hwang, S. Lee, Y . Kim, and S. Ryu, “Bittersweet adb: Attacks and
defenses,” in Proceedings of the 10th ACM Symposium on Information,
Computer and Communications Security, 2015.
[42] F. Roesner and T. Kohno, “Securing embedded user interfaces: Android
and beyond,” in SEC, 2013.
[43] M. Niemietz and J. Schwenk, “UI redressing attacks on Android
devices,” in Black Hat Abu Dhabi, 2012.
[44] J. Kraunelis, Y . Chen, Z. Ling, X. Fu, and W. Zhao, “On malware
leveraging the Android accessibility framework,” in Proceedings of the
EAI Endorsed Transactions on Ubiquitous Environments,
 2015.
[45] T. Luo, X. Jin, A. Ananthanarayanan, and W. Du, “Touchjacking attacks
on web in Android, iOS, and windows phone,” in Proceedings of the
5th International Symposium on F oundations and Practice of Security(FPS), 2012.
[46] A. P . Felt and D. Wagner, “Phishing on mobile devices,” in Proceedings
of Workshop on Web Security and Privacy (W2SP), 2011.
[47] A. P . Fuchs, A. Chaudhuri, and J. S. Foster, “SCanDroid: Automated
security certiﬁcation of Android applications,” Department of Computer
Science, University of Maryland, College Park, Tech. Rep. CS-TR-4991,
2009.
[48] E. Chin, A. P . Felt, K. Greenwood, and D. Wagner, “Analyzing inter-
application communication in android,” in Proceedings of the 9th
international conference on Mobile systems, applications, and services.
ACM, 2011, pp. 239–252.
[49] C. Zheng, S. Zhu, S. Dai, G. Gu, X. Gong, X. Han, and W. Zou, “Smart-
droid: an automatic system for revealing ui-based trigger conditions inandroid applications,” in Proceedings of the second ACM workshop on
Security and privacy in smartphones and mobile devices. ACM, 2012,pp. 93–104.
[50] D. Octeau, P . McDaniel, S. Jha, A. Bartel, E. Bodden, J. Klein, and
Y . Le Traon, “Effective inter-component communication mapping inandroid with epicc: An essential step towards holistic security analysis,”
inProceedings of the 22nd USENIX security symposium, 2013, pp. 543–
558.
[51] Y . Feng, S. Anand, I. Dillig, and A. Aiken, “Apposcopy: Semantics-
based detection of android malware through static analysis,” in Pro-
ceedings of the 22nd ACM SIGSOFT International Symposium onF oundations of Software Engineering. ACM, 2014, pp. 576–587.
[52] F. Wei, S. Roy, X. Ou et al., “Amandroid: A precise and general
inter-component data ﬂow analysis framework for security vetting ofandroid apps,” in Proceedings of the 2014 ACM SIGSAC Conference on
Computer and Communications Security. ACM, 2014, pp. 1329–1341.
[53] M. I. Gordon, D. Kim, J. H. Perkins, L. Gilham, N. Nguyen, and M. C.
Rinard, “Information ﬂow analysis of android applications in droidsafe.”
inNDSS. Citeseer, 2015.
[54] K. O. Elish, D. Yao, and B. G. Ryder, “On the need of precise inter-app
icc classiﬁcation for detecting android malware collusions,” in Proceed-
ings of IEEE Mobile Security Technologies (MoST), in conjunction with
the IEEE Symposium on Security and Privacy, 2015.
[55] L. Li, A. Bartel, T. F. Bissyand ´e, J. Klein, Y . Le Traon, S. Arzt,
S. Rasthofer, E. Bodden, D. Octeau, and P . McDaniel, “Iccta: Detectinginter-component privacy leaks in android apps,” in Proceedings of
the 37th International Conference on Software Engineering-V olume 1.
IEEE Press, 2015, pp. 280–291.
262
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:14 UTC from IEEE Xplore.  Restrictions apply. 