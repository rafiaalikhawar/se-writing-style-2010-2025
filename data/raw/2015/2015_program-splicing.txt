Program Splicing
Yanxin Lu
Rice Universty
Houston, Texas
yanxin.lu@rice.eduSwarat Chaudhuri
Rice University
Houston, Texas
swarat@rice.edu
Chris Jermaine
Rice University
Houston, Texas
cmj4@rice.eduDavid Melski
Grammatech, Inc.
Ithaca, NY
melski@grammatech.com
ABSTRACT
Weintroduce programsplicing,aprogrammingmethodologythat
aims to automate the workflow of copying, pasting, and modifying
code available online. Here, the programmer starts by writing a
“draft”thatmixesunfinishedcode,naturallanguagecomments,and
correctness requirements. A program synthesizer that interacts
with a large, searchable database of program snippets is used to
automatically complete the draft into a program that meets the re-
quirements.Thesynthesisprocesshappensintwostages.First,the
synthesizeridentifiesasmallnumberofprogramsinthedatabase
that are relevant to the synthesis task. Next it uses an enumer-
ative search to systematically fill the draft with expressions and
statements from these relevant programs. The resulting program isreturnedtotheprogrammer,whocanmodifyitandpossiblyinvoke
additional rounds of synthesis.
Wepresentanimplementationofprogramsplicing,calledSplicer,
for the Java programming language. Splicer uses a corpus of over
3.5 million procedures from an open-source software repository.
Ourevaluationusesthesysteminasuiteofeverydayprogramming
tasks, and includes a comparison with a state-of-the-art competing
approachaswellasauserstudy.Theresultspointtothebroadscope
and scalability of program splicing and indicate that the approach
can significantly boost programmer productivity.
ACM Reference Format:
Yanxin Lu, Swarat Chaudhuri, Chris Jermaine, and David Melski. 2018.
ProgramSplicing.In ProceedingsofICSE’18:40thInternationalConference
on Software Engineering , Gothenburg, Sweden, May 27-June 3, 2018 (ICSE
’18),12 pages.
https://doi.org/10.1145/3180155.3180190
1 INTRODUCTION
Copyingandpastingfromexistingcodeisacodingpracticethat
refuses to die out in spite of much expert disapproval [ 24,28]. The
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5638-1/18/05...$15.00
https://doi.org/10.1145/3180155.3180190approachisvilifiedforgoodreason:itiseasytowritebuggypro-
gramsusingblindcopy-and-paste.Atthesametime,thewidespread
nature of the practice indicates that programmers often have to
write codethat substantiallyoverlaps withexisting code,and that
they find it tedious to write this code from scratch.
Inspiteofitspopularity,copyingandpastingcodeisnotalways
easy. To copy and paste effectively, the programmer has to identify
a piece of code that is relevant to their work. After pasting this
code, they have to modify it to fit the requirements of their taskand the code that they have already written. Many of the bugsintroduced during copying and pasting come from the low-level,
manual nature of the task.
In this paper, we present a programming methodology, called
programsplicing,thataimstoofferthebenefitsofcopy-and-paste
without some of its pitfalls. Here, the programmer writes code
with theassistance ofa programsynthesizer [ 5,48]that is ableto
queryalarge,searchabledatabaseofprogramsnippetsextracted
from online open-source repositories. Operationally, the inputs to
synthesisincludea“draft”programthatisamixofunfinishedcodeandnaturallanguagecomments,aswellacorrectnessrequirement,
for example a set of test cases or a constraint on the API callstheprogrammerwantstoinvoke.Thesynthesizercompletesthe
“holes” in the draft by instantiating them with code extracted from
the database, such that the resulting program meets its correctness
requirement.Thesynthesizer isinvokedinteractivelyaspartofa
largerprogramdevelopmentprocess;initially,thedraftfedtothesynthesizer maybe closeto empty, andthe programmeris freeto
generate new drafts by adding code and holes to the result of a
round of synthesis.
Inmoredetail,oursynthesisalgorithmoperatesasfollows.First,
it identifies and retrieves from the database a small number of
programsnippetsthatarerelevanttothecodeinthedraft.These
search results are viewed as pieces of knowledge relevant to the
synthesistaskathand,andareusedtoguidethesynthesisalgorithm.Specifically,fromeachresult,thealgorithmextractsasetof codelets:
expressions and statements that are conceivably related to thesynthesis task. Next, it systematically enumerates over possible
instantiationsofholesinthedraftwithcodelets,usingheuristics
to prune the space of instantiations.
The primary distinction between our synthesis algorithm and
existingapproachestosynthesisliesintheuseofpre-existingcode.
A key benefit of our data-driven approach is that it helps with the
3382018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Y. Lu et al.
1int[][] csvmat(St ring filename) {
2int[][] mat = new int [N][N];
3/* COMMENT:
4* Read a matrix from a csv file
5* REQ: String filename = ``matrix.
csv'';
6* int[][] m = new int[N][N];
7* __solution__
8* return test_matrix (m); */
9??
10}
11
(a) Draft program1int[][] csvmat(St ring filename) {
2int[][] mat = new int [N][N];
3File f = newFile(filename);
4Scanner scanner = newScanner(f);
5for(inti = 0; i < r; ++i) {
6String line = scann er.nextLine();
7String[] fields = line.split(",");
8for(intj = 0; j < c; ++j)
9mat[i][j]= parseInt(fields[j]);
10}
11}
12
(b) Completed draft1int[][] read_ csv(int[][] m, intr,intc,
String filename) {
2File f = newFile(filename);
3Scanner scanner = newScanner(f);
4for(inti = 0; i < r; ++i) {
5String line = scann er.nextLine();
6String[] fields = line.split(",");
7for(intj = 0; j < c; ++j)
8m[i][j] = parseInt(fields[j]);
9}
10return m;
11}
12
(c) A database program
Figure 1: Reading from CSV files
problemof underspecification.Becausesynthesisinvolvesthe dis-
coveryof programs, the requirements for a synthesis problem may
beincomplete.Thismeansthatevenifasynthesizerfindsasolution
thatmeetstherequirements,thissolutionmayinfactbenonsen-
sical.Thisproblemisespeciallycommonintraditionalsynthesis
tools, which explore a space of candidate programs without signifi-
cant human guidance. In contrast, the codelets in our approach are
sourcedfrompre-existingcodethathumanswrotewhensolvingre-
lated programming tasks. This means that our search for programs
isbiasedtowardsprogramsthatarehuman-readableandlikelyto
follow common-sense constraints that humans assume.
Theuseofpre-existingcodealsohasapositiveeffectonscala-
bility. Without codelets, the synthesizer would have to instantiate
holesinthedraftwithexpressionsbuiltentirelyfromscratch.In
contrast, in program splicing, the synthesizer searches the more
limited space of ways in which codelets can be “merged” with a
programmer-written draft.
Wepresentanimplementationofprogramsplicing,calledSplicer,
that uses a corpus of approximately 3.5 million methods, extracted
from the Sourcerer [ 7,35,45] source code repository, to perform
synthesisofJavaprograms.Splicerusesaknownmethodforcodesearchtofindprogramsrelevanttoadraft.Themethodformergingcodelets with a draft is also based on existing (non-data-driven) ap-
proaches to enumerative synthesis. The key novelty of the system
lies in combining these two components into an effective software
engineering tool.
We evaluate our approach on a suite of Java programming tasks,
includingtheimplementationofscriptsusefulineverydaycomput-ing,modificationsofwell-knownalgorithms,andinitialprototypes
ofsoftwarecomponentssuchasGUIs,HTMLparsers,andHTTP
servers. Our evaluation includes a comparison with μScalpel [9],
a state-of-the-art programming system that can “transplant” code
acrossprograms,aswellas auserstudywith18participants.The
evaluation shows our system to outperform μScalpel and indicates
that it can significantly boost overall programmer productivity.
Now we summarize the contributions of the paper:
•We propose program splicing, a methodology where pro-
grammers use a program synthesizer that can query a large
databaseofexistingcode,asamorerobustproxyforcopying
and pasting code.
•We present an implementation, called Splicer, that repur-
poses existing approaches to code search and synthesis and
is driven by a corpus of 3.5 million Java methods.•We present an extensive empirical evaluation of our system
on a range of everyday programming tasks. The evaluation,
which includes a user study, shows that our method outper-
formsastate-of-the-artcompetingapproachandincreases
overall programmer productivity.
Therestofthepaperisorganizedasfollows.InSection2,wegive
anoverviewofourmethod.Section3statesoursynthesisproblem;
Section 4 describes the approach of program splicing; Section 5
presents our evaluation. Related work is described in Section 6. We
conclude with some discussion in Section 7.
2 OVERVIEW
In this section, we describe program splicing, as embodied by
Splicer, using a few motivating examples.
2.1 Reading a Matrix from a CSV File
Consider a programmer who would like to read a matrix from a
comma-separated values (CSV) file into a 2-dimensional array and
thentosquarethematrix.However,theuserdoesnotrecallindetail
what API to use and how matrix multiplication is implemented
exactly.
Incurrentpractice,theprogrammerwouldsearchthewebfor
a program that reads from a CSV file and another one that does
matrix multiplication, copy code from the search results, and mod-
ify the programs manually. In contrast, while using Splicer, he or
shewritesa draftprograminanotationinspiredbytheSketchsys-
tem for program synthesis [ 47,48] (Figure 1a). This draft program
declaresthe2d-array matrix;however,inplaceofthecodetofill
thisarray,ithasa holerepresentedbyaspecialsymbol“ ??”.Ahole
in a program serves as a placeholder that Splicer automaticallysubstitutes with code,using an external snippet. Inthis example,the external snippet is a piece of code that reads a matrix from a
CSV file.
Theuserisrequiredtoprovideinformationaboutrelevantexter-
nalsnippetsusingJavadocstylecommentscontaining“ COMMENT”
sectionand“ REQ”sectionabovetheholeorabovethefunction.If
this information is provided above the hole as showed in Figure 1a,
then the hole itself will be replaced with the external code snippet.
Theuserdescribestheformsofexternalcodethatarerelevant
to the task using natural language comments. In this example, the
commentscontainwordssuchas“read”,“matrix”and“csv”inthe
“COMMENT” section above the hole suggesting a program that reads
339
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. Program Splicing ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
1int[][] csvmat(St ring filename) {
2int[][] mat = new int [N][N];
3...
4int[][] mat2 = new int [N][N];
5/* COMMENT: square a matrix using matrix multiplication
6* REQ: int[][] m={{1, 2, 3}, ...};
7* int[][] result ={{14, 20, 26}, ...};
8* __solution__
9* return tes t_equality(m, result); */
10??
11return mat2;}
12
Figure 2: Reading CSV: draft for matrix multiplication
1int[][] csvmat(St ring filename) {
2int[][] mat = new int [N][N];
3File f = newFile(filename);
4Scanner scanner = newScanner(f);
5for(inti = 0; i < N; ++i) {
6String line = scan ner.nextLine();
7String[] fields = line.split(",");
8for(intj = 0; j < N; ++j)
9mat[i][j]=Integer.parseInt(fields[j]);}
10int[][] mat2 = new int [N][N];
11for(inti = 0; i < N; ++i)
12 for(intj=0 ,s=0 ;j<N ;+ + j ){
13 for(intk = 0; k < N; ++k) s+= mat[i][k]*mat[k][j];
14 mat2[i][j] = s;}
15return mat2;}
16
Figure 3: Reading CSV: Complete Program
from CSV files. The system will use these words as a hint to search
the code database. This is similar to a web search using text, but in
this case it is done in a programming scenario. Finally, to ensure
thatthesynthesizedcodeiscompatiblewiththecodethathehas
alreadywritten,theprogrammerneedstoprovidesomecorrectness
requirements.
Therequirementsforourexampleareshowninthe“ REQ”sec-
tionabovethehole.Arequirementissimplyapieceofcodethat
executesandreturnstrueorfalseindicatingifthesolutioniscor-
rect. To test the correctness of a synthesized code snippet solution,
“__solution__ ” will be replaced with a candidate solution and ev-
erything under “ REQ” is run in an independent environment which
has no access to the variables and names in the draft program. For
example, in Figure 1a, “ m” is defined for storing the matrix and
“filename ” is defined for storing the filename so that the solution
willhaveaccesstothefilenameandbeabletocheckwhetherthe
matrixisreadinto“ m”. “test_matrix ”(weomitadetaileddefini-
tion of this function) is used to test the content of the matrix. The
advantage of separating the testing environment from the draft
programisthatuserscanwritetestsinallpossiblewayswithout
polluting the draft program and thatis also how typical unit tests
are written.
Given the draft, Splicer issues a query to a searchable database
of code snippets. The code database then returns a set of functions
relevant to the current programming task, including at least one
program that reads from CSV files (such an implementation isshown in Figure 1c). The system now extracts a set of codelets—
expressions and statements — from these functions, and uses a
Figure 4: API call sequence constraint for face detection
composition of these codelets to fill in the hole in the draft. The
completed draft is showed in Figure 1b.
Aftergettingthecodethatreadsamatrixfromacsvfile,theuser
nowfocusesonthesecondpartofthetask,whichismatrixsquaring
using matrix multiplication. The previous code is now extendedinto a new draft, which has a hole for the matrix multiplicationcode, some comments and requirements. This draft is shown in
Figure 2. Splicer now searches the code database for snippets that
performmatrixsquaringusingnormalmatrixmultiplicationand
mergesthesesnippetsintotheexistingcode,whileensuringthat
allrequirementsaremet.Thecompleteprogramresultingfromthis
process is shown in Figure 3.
Asshownintheexample,Splicercanbeusedinaniterativeand
interactive manner. A programmer can start writing code as usual,
and then bring in external resources from the web into the exist-
ingcodebaseasneeded.Inthisrespectourapproachissimilarto
copyingandpastingcode.ThedifferenceisthatSplicerautomatestheprocessoffindingandmodifyingrelevantcode,andguarantees
a certain level of reliability by ensuring that the output program
meets all its requirements.
2.2 Face Detection using OpenCV
In previous examples, we relied on input-output tests to verify the
correctness of a solution. Now we consider the use of program
splicing in the implementation of face detection, a computer vision
taskin whichinput-output testsarehard tospecify, requiringthe
use of an alternative form for correctness requirement. Specifically,
therequirementsthat weuseareconstraintson sequencesofAPI
callsthataprogrammakes,givenintheformofafiniteautomaton.
Figure 5 shows a draft program for this task. In this example,
a user wants to use a CascadeClassifier object from OpenCV
to detect faces from an input image called lena.jpg . The output
image named faceDetection.png should have the same picture
with a rectangle drawn above the faces.
The API call constraint for the task is shown in Figure 4. This
requirementdescribesa sequenceofobjectcreation andAPIinvo-
cationactionsperformedduringfacedetection.TochecktheAPI
call requirement, Splicer runs the candidate solutions under an
environment where necessary functions and variables are defined
to keep track of the program state which is checked against therequirement. For example in Figure 5, Splicer loads the require-
ment (line 3), runs a candidate solution and checks internally (line
5)ifthesolutionhascreatedafacedetector( _has_detector_ ),has
loaded an image ( _has_image_ ) and etc., and it ensures things are
completed in order. Predicates like “ _has_detector_ ” are defined
along with the API constraints. In Figure 5 for example, they are
defined inside FaceDetectionTest.java.
While the requirement is more low-level than unit tests, we
notethatitfreesusersfromspecifyingsmalldetailssuchaswhat
configurationfiletobeused,thecolorfordrawingrectangleson
340
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Y. Lu et al.
1/* COMMENT: Doing facedetection using OpenCV
2* REQ: API_cons("FaceDet ectionTest.java");
3* __solution__
4* run_and_test(_has_detector_ && _has_image_ &&
5* _has_detection_ && _image_written_); */
6public void run() {
7String input_img = " lena.jpg";
8String output_img = "faceDetection.png";
9CascadeClassi fier detector = newCascadeClassifier(??);
10??}
11
Figure 5: Face Detection: Draft Program
1public void run() {
2String input_image = "lena.png";
3String filename = "faceDetection.png";
4CascadeClassi fier detector =
5newCascadeClassifier(getClass().getResource("
lbpcascade_frontalface.xml").getPath());
6Mat image = Highgui.imread(getClass().getResource(
input_image).getPath());
7MatOfRect faceDetections = newMatOfRect();
8detector.detectMultiScale(image, faceDetections);
9for(Rect rect : faceDetections.toArray()) {
10 Core.rectangle(image, newPoint(rect.x, rect.y), new
Point(rect.x + rect.width, rect.y + rect.height),
newScalar(0, 255, 0));
11}
12Highgui.imwrite(filename, image);}}
13
Figure 6: Face Detection: Complete Program
faces and the order of specifying the four corners of rectangles.
Splicerusesthisrequirementtofilteroutmanyofthecandidate
programsthat itconsiders during synthesis.Only afewsolutions
satisfy therequirement, andthe usercould easilypick thecorrect
one shown in Figure 6.
Notethattheexternalcodeinformationinthisexampleispro-
videdabovethefunction,asshowninFigure5.Inthiscase,Splicer
willreplacealltheholesinsidethisfunctionwithpossiblydifferent
external code snippets in a single run using a single set of relevant
programs.
3 PROBLEM FORMULATION
In this section, we define the problem of program splicing.
LanguageDefinition. As mentioned earlier,a draftprogram in
oursettingconsistsofincompletecodeandasetofnaturallanguage
comments. We start by specifying the language of code permitted
in our drafts.
Our approach accepts code in a subset Lof Java, abstractly
represented by the following grammar. In summary, the grammar
permits standard imperative expressions and statements over base
and array types, as well as a symbol ??representing holes.
/angbracketleftexpr/angbracketright::=id|c|/angbracketleftexpr/angbracketrightbinop/angbracketleftexpr/angbracketright|unaryop/angbracketleftexpr/angbracketright
|f (/angbracketleftexpr/angbracketright,...,/angbracketleftexpr/angbracketright)|id:=/angbracketleftexpr/angbracketright|? ?
/angbracketleftstmt/angbracketright::=letid=/angbracketleftexpr/angbracketright|if/angbracketleftexpr/angbracketright/angbracketleftstmt/angbracketright/angbracketleftstmt/angbracketright
|while/angbracketleftexpr/angbracketright/angbracketleftstmt/angbracketright|/angbracketleftstmt/angbracketright;/angbracketleftstmt/angbracketright|? ?/angbracketleftprogram/angbracketright::=id(/angbracketleftexpr/angbracketright,...,/angbracketleftexpr/angbracketright)/angbracketleftstmt/angbracketright
Inthis grammar, crepresentsa constant, idrepresentsan iden-
tifier, frepresents external functions (API calls), and binopand
unaryoprespectively represent binary and unary operators. We
assumethatastandardtypesystemisusedtoassigntypestoex-
pressions and statements in this grammar. The actual language
handled by our implementation goes somewhat beyond this gram-
mar, permitting arrays, objects, data structure definitions, a limited
form of recursion, and syntactic sugar such as for-loops.
Thespecialsymbol ??inthegrammarrepresentstwokindsof
holes.Expression holes is a placeholder for a missing expression. A
statement hole is a placeholder for a missing statement.
Thesemanticsofaprogramwithholescanbedefinedasasetof
complete (hole-free) programs obtained by instantiating the holes
with expressions and statements. The semantics of a complete pro-
gramisdefinedinthestandardway.Weskiptheformaldefinitions
of these semantics for brevity.
Requirement. Aside from a draft, an input to a program splicing
problemincludesa requirement.Thisrequirementisnotexpectedto
be a full correctness specification. Specifically, our implementation
permits two classes of requirements: input-output tests, and finite
automata that constrain the sequences of API calls that a program
canmake.Weassumeaproceduretoconservativelycheckwhethera given complete program satisfies a given set of requirements. For
requirements that are input-output tests, this procedure simply
evaluatestheprogramonthetests.Theprocedureforautomaton
constraints is based on a standard, sound program analysis.
Program Splicing. LetPs∈Lbe a draft program with one or
moreholes.Let DB⊆Lbeadatabasecontainingprogramswith
noholes. Our objective is to use the programs from DBto com-
plete holes in Ps. Specifically, we use the expressions (similarly,
statements) from DBto complete the expression holes (similarly,
statementholes) in Ps.Naturally, suchaninstantiation oftheholes
canbeperformedinmanyways.Ourgoalistodothisinstantiation
such that the resulting program passes the requirement.
Moreprecisely,considertheset Cofallcodelets—subexpressions
andstatements—thatappearinprogramsfrom DB.LetPbethe
set of complete programs obtained by instantiating the holes of Ps
by appropriately typed codelets in C. Let U:L→{True ,False}
be a function that maps a complete program in Lto a boolean
valueindicatingwhethertheinputprogrampassestherequirement
accompanying Ps.Thesplicingproblemistofindaprogram P∗c∈P
such that U(P∗c)=True.
4 METHOD
Inthissection,wepresentaspecificsolutiontothesplicingproblem,
implemented in the Splicer system. Our synthesis problem has
two key subproblems: code search andhole substitution.
Code Search Given a program Ps∈L, search a large corpus
containingthousandsofprogramsforasetofrelevantprograms
such that the retrieved programs contain the codelets that are
neededtofillholes.Thedesiredpropertyofthecodesearchtech-
nique should be that the retrieved programs should contain the
exact codelet we need within a short period of time.
341
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. Program Splicing ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Hole Substitution Given multiple database programs Sd,w e
wouldliketosearchforthecorrectcodeletstofillthehole.Multiple
programs combined consist of a large number of codelets. The
keychallengehereistoprunethesearchspacesuchthatwecan
efficiently getthe exactcodelet we needand ensurethe necessary
codelets will not be dropped.
4.1 Searching for programs
Inthissection,wedescribethecodesearchtechniquesfromKashyap
et al. [25] with a modification employed to query a large database
of programs effectively. This is the first step in our workflow: to
findcandidatefunctionalityfromtheprogramdatabasetocomplete
the draft program. Given the word hints below “ COMMENT”i nt h e
Javadoc and also the variable names in the draft program, Splicer
does a code search and returns a set of relevant programs.
An important goal of the code search component is to have a
quickresponsewhensearchinglargeamountsofcode.Toaccom-
plishthis,variouscodefeaturesareextractedfromalargecorpusofopen source code. These code features—along with the correspond-
ing source code—are stored in a program database. The programdatabase is a scalable object-store database that allows for fast
similarity-based queries.
Aqueryissuedtotheprogramdatabaseincludescodefeatures
extracted from the draft program, along with associated weights
indicatingtherelativeimportanceofthecodefeatures.Theprogram
databasecomputestheknearestneighboringcorpuselementsto
thequery,usingthecodefeaturesstored,associatedweights,and
similaritymetricsdefinedoneachcodefeature.Theresultofthe
query is presented as a ranked list of source code corresponding to
the k-nearest neighbors.
Below we describe the features extracted and the associated
similarity metrics.
Natural languageterms. For this feature, we extract the func-
tion name, comments, local variable names, and parameter names
of a function. Such extracted natural language (NL) terms are then
subjected to a series of standard NL pre-processing steps, such
assplittingwordswithunderscoresorcamel-case,removingstop
words (including typical English stop words, and those special-
ized for Java code), stemming, lemmatization, and removing single
character strings. Additionally, we use a greedy algorithm [ 12] for
splitting terms into multiple words, based on dictionary lookup.
This is to handle the case where programmers combine multiple
words, without separating the words with underscores or camel-
case, when naming functions and variables.
AfterNLpre-processing,wecomputeatf-idf(termfrequency-
inversedocumentfrequency)scoreforeachNLterm.Eachfunction
is considered as a document, and the tf-idf is computed per project.
We give the function name term an inflated score (5 ×more than
otherterms)becauseitoftenprovidessignificantinformationabout
a function’s purpose. The similarity between two functions is mea-
sured by taking the cosine-similarity of their NL terms, together
withtheirtf-idfvalues.BelowisanexampleofNLtermsfeatures
for the draft showed in figure 1a.
"read":0.10976425998969035, "matrix":0.658585559938142,"csv":0.10976425998969035, ...Names.Here, we extract all the variable names, the name of
thefunction,andperformsome basicnormalizationsuchassplit-
ting camel case and underscores.The similarity metric used is the
Jaccard index on sets of names.
The code search method is described extensively in [ 25] and the
main difference is that our similarity search is primarily drivenby the natural language term features, with variable names andfunction names providing additional context around the hole inthe query code. We give more weights to natural language termfeatures and less weights to variable names and function names.
The reason is that the most important hint in the draft code is the
comment,becauseusersarerequiredtodescribethecodetheywant
tosynthesize.However,variablenamesandfunctionnamesmust
not be treated as equally important, because sometimes variable
namesandfunctionnamesmightbetotallyirrelevanttothecode
they want to synthesize. For example, users might leave comments
sayingthatthey wantthecodethatreadsa matrixfromacsvfile,
but it is totally possible that the surrounding context is all about
matrix calculation.
4.2 Program completion
Afterwehaveretrievedasetofprogramsfromtheprogramdata-
base,ournextstepistocompletethedraftbysynthesizingcodelets.
A codelet here is a sequence of program statements or a set of
expressions from the programs retrieved from the database dur-
ingcodesearch.Notethatunlikeothertraditionalsynthesistech-
niques [5,13–15,37,38,51,53], our synthesis method does not
generatecodefromscratch,butinsteaditusescodeletsfromalarge
code corpus. For each database program paired with the given par-
tial program, we spawn a thread to do the code completion task,parallelizing the process. A code completion task consists of the
following steps:
4.2.1 Hole substitution. The first step is to use the codelets
from the retrieved program to substitute the holes in the draft.Procedure 1 shows the algorithm. We start by checking whetherthere is any hole in the draft at line 1. If not, we move on to the
merging step. Otherwise, we start injecting codelets into the draft.
For each hole, we iterate all the codelets starting from the smallest
oneandcheckwhethertheinjectionisvalidusingourheuristicsat
line3.Ifso,wethensubstitutetheholewiththecodeletatline4and then continue injecting more codelets by recursively calling
itself at line 5 until we finish filling all the holes. When no more
holesexistinthedraftprogram,wethenmergethecodeletsinto
theexistingcodebase,whichisexplainedindetailinlatersection.
If at some point injecting a codelet is not successful, we backtrack
andtryanothercodelet.Next,wediscussourheuristicsusedinthe
step of hole substitution.
Synthesizingexpressions Ifwearesearchingforasubstitution
nfor an expression hole h, we ensure nandhare of the same type.
In addition, we can also consider the rolesofhandn. The intuition
is that we only consider the codelet that serves as the same role by
lookingattheparentof nandtheparentof hintheparsetree.If
the parents of nandhare not of the same kind, then we discard
nandlookforanothercodelet.Figure7illustratestheidea.Ifwe
are looking for a codelet to replace a hole representing the rval
inside an assignment statement, our target codelets are more likely
342
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Y. Lu et al.
Procedure 1 fill
Input:A draft program, Ps∈Land a database program Pd∈L
Output: A complete program Pc
1:ifnot has_hole (Ps)then return merge (Ps)end if
2:forh←next_hole (Ps),n←next_codelet (Pd)do
3:ifvalid( Ps,h,n)then
4: P/primes←substitute (Ps,h,n)
5: Pc←fill (P/primes,Pd)
6: ifPc/nequalnullthen return Pcend if
7:end if
8:end for
9:return null
Figure 7: Matching for expression codelet
Procedure 2 merge
Input:Acompleteddraftprogram, Ps∈Landadatabaseprogram
Pd∈L
Output: A correct completion Pc
1:ifno_undefined_refs (Ps)then
2:ifis_correct( Ps)then return Psend if
3:return null
4:end if
5:foru←next_undefined_ref (U),r←next_ref (Pd)do
6:ifsame_type( Ps,u,r)then
7: P/primes←substitute (Ps,u,r)
8: Pc←merge (P/primes,Pd)
9: ifPc/nequalnullthen return Pcend if
10:end if
11:end for
12:return null
to be the rvalof other assignment statements. We can then just
considerthosecodeletsassubstitutionsandignoreothercodelets.
The same can be applied if we want to synthesize the code for the
guard of a condition, for example.
Synthesizing statements When we are searching for substi-
tutionsforastatementhole h,weneedtoconsiderasequenceof
statementsfromthedatabaseprogram.Wedefineaslidingwindow
of various lengths and use that to scan the database program to
identify the statement sequence we would like to use to substitute
forh.Wealso scanthesequencesunderloopsandconditions.We
then use each codelet to fill the hole.
4.2.2 Code merging. One problem with using the codelets from
thedatabaseprogramsisthatthenamingschemesaredifferentfrom
the ones in the original draft program. Therefore, after we have
completed thedraftprogram, wesearch forreference substitution
suchthattheresultingprogramrefersbacktothedatadefinedin
thedraftprogram,whichisquitesimilartocodetransplantation[ 9].ThealgorithmisshowninProcedure2.Thetaskhereisessen-
tiallysearchingforamappingbetweenthereferencesacrosstwo
programs. We first check whether we have undefined references
intheprogramatline1.Ifnot,wechecktheprogramcorrectness
against the requirement at line 2. If it is correct, then we have a
solution. If there is still undefined reference in the program, we
then try to rename each undefined reference uto another defined
reference rat line 7. We repeat by recursively calling itself until no
moreundefinednamesexistintheprogram.Weguidethesearchby
using types. When we are considering renaming utor, we rename
uonlyiftheirtypesarethesame.Ifatanypointthealgorithmcan-
notrenameareferenceduetothelackofavailabletargetreferences
inanotherprogram,thealgorithmwillbacktrackandtryanother
renaming for a previous reference. This reference substitution step
is performed every time we complete a draft and thus the whole al-
gorithm suffers from exponential blowup. To ensure the algorithm
terminates, we set a time limit on the entire search process.
4.2.3 Testing. Afterwehavefinishedrenamingallreferences
in a completed program, we validate the solution against the re-
quirementeitherinformofapredefinedinput-outputtestsuiteorapredefinedAPIcallsequenceconstraintgivenasafiniteautomaton.
IfusersprovideIOtests,werunthesolutionontheprovidedtest
suitetovalidateitscorrectness.IfanAPIcallsequenceconstraint
is given instead, we encode the constraint into Java source code in
which API calls are captured and new variables are defined to keep
trackofthecurrentstateinthefiniteautomaton.Whenthecom-
plete program is run, the constraint will be automatically checked
and thus the correctness is determined. We also set a time limit
for program execution to ensure termination. Notice that we could
let the synthesis algorithm produce multiple solutions by letting
itcontinuethesearchafteracorrectcompletionisfound.Ifthere
are multiple correct completions, we will rank them in the order
theyappearandreturnasmanysolutionsasrequired.Ontheotherhand,wecanalsoeasilyaddaselectionfunctiontochoosethebest
solution.
5 EVALUATION
OurgoalistoevaluatetheperformanceofSpliceranditsabilitytocompleteadraftprogram.Theexperimentconsistsofcompletinga
set of draft programs given a code database where a set of relevant
statistics for each run is recorded. In addition, we show the results
of a user study where we test whether our synthesis tool could
increase programming productivity.
5.1 Benchmarks
In this section, we briefly describe our benchmark problems fol-
lowedbytheexperimentsandtheresults.Weevaluatetheperfor-
mance of Splicer and select a set of benchmark problems with
correspondingdraftprogramstoautomatetheprocesswhereusers
try to bring external resources from the web and merge them into
the existing codebase.
It is desirable to compare Splicer with existing synthesis meth-
ods including Sketch [ 48], syntax-guided synthesis [ 6], code reuse
tools [21,29,43,52] or other statistical methods [ 17,39]. How-
ever,noneofthesemethodsarecomparable,because(1)traditional
synthesis methods do not search for or use existing source code,
343
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. Program Splicing ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
(2)codereusemethodsdonotconsiderprogramsatthegranular-
ity of statements and expressions and (3) some methods such as
SWIM[39]andanyCode[ 17]onlyaimtosynthesizeAPI-specific
codesnippets.Specifically,wefedastandardbinarysearchdraft
program with a few expression holes to Sketch and it was not able
tocompletethedraftwithin30minutes.Incontrast,oursplicing
system could generate the correct expressions within 5 seconds
after the code search is complete. Moreover, our splicing system
couldgeneratecodesnippetswhileSketchcannothandlestatement
synthesis problems.
Code transplantation or μScalpel [9] is the most similar sys-
tem to our work and we will use μScalpel for comparison with
the correct donor programs provided to μScalpel. Notice that we
cannot apply μScalpel to some of our system-related benchmark
problems,because μScalpeltargetsatCprogramsinsteadofJava.
SincesystemsprogramsinCandinJavatendtobeverydifferentin
terms of number of variables, types and system calls which makes
thecomparisonunfair.Therefore,weonlycompareourtoolwith
μScalpel on some benchmark problems where the differences in
the solutions are not significant.
Ourbenchmarkproblemsconsistofsynthesizingcomponents
fromonlinerepositoriesandweinclude15benchmarkproblems.
Thesebenchmarkproblemswerechosenwerechosentoreflecta
diversesetofeverydayprogrammingtasks.Accordingly,theycom-
prisetextbookprogrammingtasks,Stackoverflowquestions,and
tutorialsoftoolslikeOpenCV.Thetasksalsomeetthreecriteria:
(a)theproblemsshouldcomefromadiversityofdomains,(b)the
tasks should represent common programming problems, and (c)
thereshouldbeadequatenumberofprogramsrelevanttotheprob-
lems in the code corpus. The draft program for most benchmark
problem contains one or two statement and expression holes. Each
draftprogramhasitsowncommentsandcorrectnessrequirements.Mostbenchmarkproblemsusetypicalinput-outputtestsexceptfor
“Echo Server”, “Face Detection” and “Hello World GUI” where API
callsequenceconstraintsareusedtocheckthecorrectness.Here,
we highlight two draft programs from the benchmark problems.
LCS Table Building A user calculates the longest common
subsequence of two integer arrays, and she has written a draftprogramwiththecodesnippetstoextractthesubsequencefrom
thetableanddisplaytheresult.Aholeisleftforthecodethatbuilds
the table for running dynamic programming algorithm.
HTTPServer A user would like to set up an HTTP server that
servesthecontentofatextfile.Shewroteadraftprogramwhich
has a HTTP request handler, but she does not remember how to
read from a text file and how to set up an HTTP server. Two holes
are left for the code that reads from a text file and the code that
setsupanHTTPserver.Inaddition,shealsoleavesaholeforthe
response status code in the request handler. Figure 8 shows the
draft program.
5.2 Experiments
WeimplementedprogramsplicinginScala2.12.1basedon64-bit
OpenJDK8andweusedBeanShell[ 1]andNailgun[ 3]totestall
the completed draft programs. For each benchmark problem, we
ranSpliceronthedraftprogramwederived.Theseexperiments
were conducted on a 2.2GHz Intel Xeon CPU with 12 cores and1/* COMMENT: Setting up an HTTP server that serves the
2* content of a local file
3* REQ:
4* import com.sun.net.httpserver.*, java.io.OutputStream;
5* __solution__
6* HttpServer server = http("http_test.txt", 23456);
7* test_server(new URL ("http:// localhost:23456/"));
8* server.stop(0); */
9public HttpServer http(String filename, intport) {
10String content;
11// read the content of the file
12??
13HttpServer server;
14HttpHandler handler = newHttpHandler() {
15 public void handle(HttpExchange he) {
16 he.sendResponseHeaders(??, content.length());
17 OutputStream os = he.getResponseBody();
18 os.write(content.getBytes()); os.close();
19 }};
20// set up an http server
21??
22return server;}
23
Figure8:SettingupanHTTPserverthatservesthecontento fat e x tfi l e
64GBRAM.Foreachprogram,werecordtheruntimeforsynthesis
andwestopthesynthesisoncethetimeexceedsfiveminutes.To
roughlyhaveasenseofthesearchspacesize,welistthenumberof
variables and holes in each draft program, the line number and the
number of database programs we use for synthesis. Finally, we list
theLOCofthedraftprogramanditscompletedversion.Ourcorpus
comesfromthe Maven 2012 datasetfromSorcerer[ 7,35,45].We
extracted over 3.5 million methods with features from this corpus.
5.2.1 Synthesis Algorithm Evaluation. Table 1 shows the results
for each benchmark problem with k=5 where kis the number of
databaseprogramsweretrieve.Weset k=5becauseempirically
five programs are usually sufficient to ensure that the retrievedprograms contain the target codelet we want to synthesize. In
addition, we put more weight on features that consider comments
andvariablenamesinthe k-nearest-neighborsearch.Thechoice
on weight selection is explained in section 4.1.
Accordingthe resultsshowed inTable1,data-drivensynthesis
worksforallbenchmarkproblems.Thetimerequiredformostcode
searcheswhichisbasedonk-nearest-neighborsearchisapproxi-
mately15seconds,meaningthatthecodesearchisveryefficient,
given that we have millions of functions in the database. For most
ofthe benchmarkproblems,our methodwasable tocompletethe
draft program in under two minutes and the number of tests re-
quired is no more than five, indicating that users of Splicer do not
have the burden of writing too many tests. In general, a set of tests
isconsidered sufficientif acomplete codecoverage isachieved in
the desired target program. Notice that for “Echo Server”, “FaceDetection” and “Hello World GUI”, a letter “C” is used to signal
an API call sequence constraint being used to test the correctness.
We can also see that synthesis takes more time as the number of
holes and the number of variables increase. Having more holes,
more variables and sometimes more linesleads to larger combina-
torialsearchspaceforholesubstitutionswithcodelets,andmore
variablesincreasethesearchspaceforcodemergingandrenaming.
344
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Y. Lu et al.
Benchmarks Synthesis
TimeNo Roles No Types LOC VarHoles
(expr-
stmt)Test μScalpel
Echo Server 3.0 4.0 17.1 9-17 11-1CN/A
Sieve Prime 4.6 33.0 8.8 12-17 22-13162.1
Collision Detection 4.2 6.3 5.3 10-15 22-14N/A
Collecting Files 3.0 6.0 27.0 13-25 21-12timeout
Face Detection 8.1 12.2 43.1 21-28 21-1CN/A
Binary Search 15.4 16.0 47.9 12-20 51-13timeout
Hello World GUI 16.0 timeout timeout 24-33 41-2CN/A
HTTP Server 41.1 87.4 timeout 24-45 61-22N/A
Prim’s Distance Update 61.1 66.4 timeout 53-58 111-14timeout
Quick Sort 77.2 191.5 217.6 11-18 61-11timeout
CSV 88.4 timeout timeout 13-23 41-22timeout
Matrix Multiplication 108.9 151.9 timeout 13-15 81-11timeout
Floyd Warshall 110.4 timeout timeout 9-12 71-17timeout
HTML Parsing 140.4 timeout timeout 20-34 51-22N/A
LCS 161.5 168.8 timeout 29-36 100-11timeout
Table 1: Benchmarks. “C” in the “Test” column indicates an API call sequence constraint is used to check the correctness
Impact of type matching and role matching Types ensure
the solutionwill type check.In addition, rolematching eliminates
theexpression substitutionswhere theroleof acandidate expres-
sionisdifferentfromtheroleofahole.Tounderstandtheirimpact,
werecordthesynthesistimewithoutusingtypes,whichisshowed
inthe“NoTypes”columnofTable1.The“NoRoles”columnshows
the runtime without role matching. We can see that using types
androlescanreducealargeamountofsearchspace,althoughtypes
seem to be more effective. These heuristics become more and more
important forlarger draftprograms asthe numberof variablesin-
creases. Without types and role matching, our synthesis algorithm
timedoutforsomeharderbenchmarkproblems.Noticethatrole
matching is applied when we synthesize expressions, as we cannot
apply rolematching when synthesizingstatement sequences, and
thuswedonotseeanydifferenceinthe“LCS”benchmarkproblem.
μScalpel Comparison Code transplantation [ 9] is very similar
to our work, except that it does not consider using a large code
corpus.However,itisstillworthwhiletoconductaseriesofperfor-mancecomparisons,since
μScalpelalsoextractscodesnippetsfrom
external programs,or donorprograms. We ran μScalpelon some
of ourbenchmark problems withcorrect donorsspecified. Notice
that μScalpel has an advantage over Splicer under this setting,
because μScalpel does not need to search for relevant programs
from a code corpus. Nevertheless, even with such an advantage,
most of the runs could not finish within five minutes except for
“Sieve Prime” which is relatively easy. Even though we did not run
μScalpelonallbenchmarkproblems,itisreasonabletobelievethat
theperformanceof μScalpel(basedongeneticprogramming)isnot
as efficient as Splicer, which is based on enumerative search.
5.2.2 User Study. Weperformedauserstudytoevaluatetheex-
tenttowhichSplicercanhelphumandevelopers.Nowwedescribe
this study.
Study setup. We recruited 12 graduate students and six profes-
sional programmers and developed four programming problems1/** TODO 1: Use Sieve of Er atosthenes to testprimality
2* of the given integer. */
3static boolean sieve(intn) {
4boolean [] primes = new boolean [100];
5return primes[n];}
6
7/** TODO 2: Test the sieve of Erato sthenes you've just
8* written. Make sure to test the program with the
9* following inputs: n = {1, 2, 3, ..., 73}
10* Return true if the program is correct. */
11static public boolean test() { return false ;}
12
Figure 9: Sieve of Eratosthenes Skeleton with Tests
(described later in this section). Each participant was asked to com-
plete all four programming problems using a web-based program-
mingenvironment.Perperson,twoproblemswerecompletedusing
program splicing (we subsequently call this a “with” task), and two
without (a “without” task). “With” and “without” tasks were as-
signed to participants randomly.
Tosimulateanindustrialprogrammingsettingwhereanengi-
neerisaskedtodevelopacodemeetingaprovidedspecification,
for each task, participants were given a description of the program
they need to implement, and a description of the test cases theyneed to write to verify the correctness of the program. Figure 9
shows anexample skeleton programfor the “without”task on the
Sieve of Eratosthenes programmingproblem.Forthe“with”task,
thedraftprogramisalmostidenticalto the sievefunctionin Fig-
ure 9 except that there is a hole after the array declaration and
participants need to put in comments and requirements.
When completing both “with” and “without” tasks, participants
wereencouragedtouserelevantcodesnippetsfromtheInternet.
For the “with” tasks, participants were asked to use Splicer to pro-
videatleastonecandidatesolutiontotheprogrammingproblem,
but then they could choose to use that candidate, or not use it. Be-foreusingthe web-based programmingenvironmentandSplicer,
they were asked to finish a warm-up problem to be familiar to
345
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. Program Splicing ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
theprogrammingenvironmentandSplicertoeliminatelearning
effects.
To evaluate whether Splicer could boost programming produc-
tivity, we recorded the durations the participants used to correctly
completeeachproblem.Todetermineifthereisastatisticallysig-
nificant difference in completion time for “with” versus “without”
tasks for the same programming problem, we define the following
null hypothesis:
HP
0= “For programming problem P, the expected ‘without’ task
completion time is no greater than the expected ‘with’ task
completion time.”
If this hypothesis is rejected at a sufficiently small p-value for
a specific programming problem, it means that it is likely that the
average completion time is smaller for the “with” task than the
“without” task, and hence program splicing likely has some benefit
ontheproblem.Giventhetimesrecordedovereachproblemand
each task, we use bootstrap[ 11] to calculate the p-value for each
problem. The bootstrap works by simulating a large number of
datasetsfromtheoriginaldatabyre-samplingwithreplacement,
andthe p-valueisapproximatedbythefractionofthetimewhen
the null hypothesis holds in the simulated data sets. In additionto measuring time, we also recorded the number of times that
“with”taskparticipantsforeachproblemaskedtheprogramsplicing
system for help. Typically the participants would stop using oursystem after they have received a useful codelet, and so many
requestsmayindicateaninabilityofthesystemtoproduceauseful
result.
Programming Problems. Now we describe the four program-
ming problems used in the study.
Sieve of Eratosthenes : Implement the Sieve of Eratosthenes
to test the primality of an integer. This is an interesting problem
because it is purely algorithmic, and further, codes to solve thisproblem are ubiquitous on the Internet. We expected Splicer tobe of little use, because an Internet search should result in manydifferent Sieve programs which should be trivial to tailor to theproblem. Given this and the fact that test codes are so easy to
write,weexpectedparticipantswillusetheleastamountoftimeto
finishthisproblem,regardlessofwhethertheyaregivena“with”
or “without” task.
File Name Collection :Collectallfilenamesunderadirectory
tree recursively and return the list of file names. We chose this
problem because it represents an easy systems programming prob-
lem.Further,thereisnostandardsolutiontothisproblem,while
itisstillquiteeasytowritetests.ThereforeweexpectedInternet
searchtobelessuseful,whereasprogramsplicingmightbequite
helpful.
CSV Matrix Multiplication : Read a matrix from a CSV file,
squarethematrixandreturnitasa2d-array.Thisproblemincludes
acombinationofsystemprogrammingandalgorithmicprogram-
ming. We chose this problem expecting that “with” task program-
mers would need to use Splicer multiple times in an interactive
manner to generate two independent code snippets. Given this, we
expectedthatthetimegapbetweenthe“with”taskand“without”
task participants to be smaller.
Figure 10: Time spent on each programming problem, with
and without splicing.
HTML Parsing : Read and parse an HTML document from a text
file,storealllinksthatcontainagivenwordintoaresultlistandre-
turntheresultlist.Thisisthemostdifficultproblemamongthefour.
Not only would those “with” task participants need to use Splicer
multipletimes, buttheyarerequired towritetestsfor HTML ma-
nipulation since program splicing necessitates that participants
manuallyprovideHTMLtobuildtestcasesthatareusedtovalidate
the correctness of the code for extracting links from the parsed
HTMLdocument.Atthesametime,theJSoup[ 2]HTMLparsing
library that we asked participants to use has rather comprehensive
andstraight-forwarddocumentation.Hence,weexpectedthattime
gapbetween“with”and“without”taskparticipantswouldbethe
smallest among the four problems.
Results. Figure11showsthe p-valuesforeachprogrammingprob-
lem, as well as the number of times code splicing was invoked for
each problem’s “with” task. Figure 10 shows time spent on each
submissionwith andwithout splicing,includingthe averagetime,
asboxplots.Wecanseethatformostprogrammingproblemsex-
ceptforHTML,theaveragetimeusedtofinishthe“with”taskisis
significantlylowerthanthetimerequiredtofinishthe“without”
task. The p-values in Figure 11 are also small enough for us to
reject the null hypotheses (stating that there is no utility to pro-
gram splicing) with over 99% confidence. Note that the average
number of program splicing invocations for most problems (except
HTML Parsing )isveryclosetoone,meaningthatprogramsplicing
couldreturncodeletsthattheparticipantscouldusetocompletethe problem with only one try. We argue that this also indicates
thatSplicerisrathereasytouse,andisindeedabletoboostpro-
grammingproductivityinmanycases.Asthelevelofdifficultyof
the problem increases, so does the benefit of using Splicer.
It is, however, useful to consider the HTML Parsing program-
mingproblem,whichistheonecasewhereprogramsplicingwas
not useful. Why is this? After careful investigation, we believe
that there are two reasons program splicing did not help. First, the
documentation of the HTML parsing library used, JSoup[2], is
verycomprehensiveandwell-done.Hencetheproblemwaseasy.
Second, it is very easy to make mistakes when writing tests, whichrequiredevelopingcorrectHTMLcodeandinsertingitinatest.We
found that participants typically forgot to escape quote characters
withinastringwhenloadingavariablecontainingevenverysimple
346
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Y. Lu et al.
Problem p-valueAvg. Number of Invocations
Sieve 0.00008 1.2
CSV 0.0002 1.2
Files 0 1
HTML 0.5 2.45
Figure 11: p-value at which the null hypothesis is rejected,
andtheaveragenumberofprogramsplicinginvocationsfor
each programming problem.
HTML. The difficulty in writing tests meant that program splicing
waslesshelpful.Thatsaid,writingtestshasindependentvalue,and
ifthedifficultyinwritingtestswasthekeyimpedimenttousing
splicing, it may not be a strong argument against the tool.
Weclose this subsection by asking:When is programsplicing
likely most useful for programmers? One surprising case seems to
be programming problems that are deceptively simple, containing
intricatealgorithmics(loopsandrecursion)thatprogrammerstend
to have a difficult time with. Sieve of Eratosthenes falls in this
category.TheSieveappearstobeverysimple,andsoweinitially
expected splicing to be of little use. However, due to the perceived
simplicity, we found that “without” participants tended to write
their own solutions without consulting the Internet (even though
we encouraged Internet use)—and this over-confidence resulted in
buggy programs and longer development times. Use of program
splicing protected “with” participants from such difficulties.
We also found splicing to be useful when documentation is lack-
ingandthereisnotastandardwayofdoingthings.Consider CSV
andCollecting File Names wheretheofficialJavadocumenta-
tion does not provide any code snippets showing how to parse a
CSV files or how to collect file names under a directory subtree.
“Without”participantshadtorelyoncombingthroughsolutions
fromStackOverflow [ 4],where multiplesolutions exist,usingdif-
ferent libraries, each with various pros and cons. Program splicing
cutsouttheneedformanualsearchingandunderstandingmany
different possible solutions—if the splicing succeeds and passes the
provided test cases, the user can be relatively confident that the
provided solution is correct.
5.2.3 Limitations. Finally, we summarize the limitations of our
evaluation:
(1)Our corpus contains over 3.5 million methods with features
which ensured that we always found relevant programs dur-
ingourexperiments.However,formoreobscureprogram-
mingproblems,itmaynotalwaysbepossibletofindhelpful
code in such a database.
(2)Like most synthesis algorithms, the time complexity of our
algorithm is exponential, and so it is limited in its ability to
handle very large draft programs.
(3)It is unclear how to ensure that a user-provided test suiteis comprehensive enough to ensure the correctness of the
synthesized program.
6 RELATED WORK
Thenotionofdraftsusedinprogramsplicingisinspiredby[ 48,49]
fromtheprogramsynthesisfield[ 5,13–15,37,38,51,53].However,
thekeydifferenceisthatourmethodreusesexistingsourcecodefromthe webinsteadofgenerating programsfromscratch.Gilli-
gan[20]andothergeneticprogrammingmethods[ 9,18,22,30,36]
are very similar to our work. However, they do not considering
searching a large code corpus and sufferfromefficiency concerns.
CodePhage[ 46]transplantsarbitrarycodesnippetsacrossdiffer-
entapplications,butthetransplantaionsaredoneexclusivelyfor
binary programs. Code reuse tools [ 21,29,43,52] usually consider
programsatthegranularityoffunctions.Ontheotherhand,our
methodprovidesaSketch-likeinterfacewhereprogrammerscan
leaveholes.Ourmethodallowsreuseatthelevelofstatementsand
expressions, making it more likely that reuse is applicable.
Statistical methods [ 8,19,32,34,40–42] have been shown to be
quiteeffectiveininferringprogrampropertiesandcodecompletion.Ourwork,however,doesnotdependheavilyonstatisticalmethods.
Websearchcombinedwithnaturallanguagequeriesareusedfor
code search [ 17,39], but they do not consider draft programs that
offer a context with which new programs must be merged. Theproblem of copy-and-paste is considered in [
33], but only in the
context of merging similar programs.
Ourcodesearchtechniqueisexplainedextensivelyin[ 25].Much
oftherelatedworkonfindingsimilarcodehasfocusedon clonede-
tection: finding syntactically exact or nearly-exact copies of source
codefragments.See[ 44]forarelativelyrecentsurveyofthesetech-
niques.Syntaxelementshavebeenshowntobeeffectiveincode
search [23,27], but our code search mainly relies on natural lan-
guagewithminorsyntaxelements.Codesearchhasbeenperformed
in variousother settings,using differentcodefeatures [ 10,16,31].
Refer to Table 3 in [ 31] for a comprehensive comparison of vari-
ous code search engines: most of these are targeted towards cre-
atinguser-facingcodesearchenginesthatcanfindrelevantcode
based on a user-specified query. SMT solvers and semantic code
search[26,50]havealsobeenusedforsemanticcodesearchand
program repair.
7 CONCLUSION
In this paper, we introduce program splicing, a synthesis-based
approach to programming that can serve as a principled and auto-
mated substitute for copying and pasting code from the Internet.
The main technology is a program synthesizer that can query a
databasecontainingalargenumberofcodesnippetsminedfrom
open-source repositories. Our experiments show that it is possible
to synthesize missing code by combining such database queries
with a combinatorial exploration of a space of expressions and
statements.Wealsoconductedauserstudyandtheresultsshow
that our method could indeed boost programming productivity.
Oneimportantpieceoffutureworkistoensurethehighquality
of the database programs, because the effect of code quality on the
quality of the synthesized code could be very significant. We could
develop better features and similarity metricsto increase the code
search precision.
REFERENCES
[1]2017. BeanShell. (2017). https://github.com/beanshell/beanshell Accessed:
2017-04-04.
[2] 2017. JSoup. (2017). https://jsoup.org Accessed: 2017-04-02.
[3]2017. Nailgun. (2017). http://martiansoftware.com/nailgun/ Accessed:2017-04-04.
[4] 2017. Stackoverflow. (2017). https://stackoverflow.com Accessed: 2017-04-02.
347
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. Program Splicing ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
[5]Rajeev Alur, Rastislav Bodik, Garvit Juniwal, Milo MK Martin, Mukund
Raghothaman,SanjitASeshia,RishabhSingh,ArmandoSolar-Lezama,Emina
Torlak,andAbhishekUdupa.2015. Syntax-guidedsynthesis. DependableSoftware
Systems Engineering 40 (2015), 1–25.
[6]Rajeev Alur, Rastislav Bodik, Garvit Juniwal, Milo MK Martin, Mukund
Raghothaman,SanjitASeshia,RishabhSingh,ArmandoSolar-Lezama,Emina
Torlak,andAbhishekUdupa.2015. Syntax-guidedsynthesis. DependableSoftware
Systems Engineering 40 (2015), 1–25.
[7]Sushil Bajracharya, Joel Ossher, and CristinaLopes. 2014. Sourcerer: An infras-
tructureforlarge-scalecollectionandanalysisofopen-sourcecode. Scienceof
Computer Programming 79 (2014), 241 – 259. DOI:http://dx.doi.org/10.1016/j.
scico.2012.04.008
[8]MatejBalog,AlexanderLGaunt,MarcBrockschmidt,SebastianNowozin,and
Daniel Tarlow. 2016. DeepCoder: Learning to Write Programs. arXiv preprint
arXiv:1611.01989 (2016).
[9]EarlT.Barr,MarkHarman,YueJia,AlexandruMarginean,andJustynaPetke.2015.
Automated Software Transplantation. In Proceedings of the 2015 International
SymposiumonSoftware TestingandAnalysis(ISSTA2015).ACM,New York,NY,
USA, 257–269. DOI:http://dx.doi.org/10.1145/2771783.2771796
[10]Yaniv David and Eran Yahav. 2014. Tracelet-based code search in executables. In
ACM SIGPLAN Notices, Vol. 49. ACM, 349–360.
[11]Bradley Efron. 1982. The jackknife, the bootstrap and other resampling plans.
SIAM.
[12]HenryFeild,DavidBinkley,andDawnLawrie.2006. Anempiricalcomparisonof
techniquesforextractingconceptabbreviationsfromidentifiers.In Proceedings
of IASTED International Conference on Software Engineering and Applications
(SEAâĂŹ06). Citeseer.
[13]YuFeng,RubenMartins,JacobVanGeffen,IsilDillig,andSwaratChaudhuri.2016.
Component-based Synthesis ofTableConsolidation and Transformation Tasks
from Examples. CoRRabs/1611.07502 (2016). http://arxiv.org/abs/1611.07502
[14]Yu Feng,RubenMartins,Yuepeng Wang,Isil Dillig,andThomasW.Reps.2017.
Component-based Synthesis for Complex APIs. In Proceedings of the 44thACM
SIGPLANSymposiumonPrinciplesofProgrammingLanguages(POPL2017).ACM,
New York, NY, USA, 599–612. DOI:http://dx.doi.org/10.1145/3009837.3009851
[15]JohnK.Feser,SwaratChaudhuri,andIsilDillig.2015.SynthesizingDataStructure
Transformations from Input-output Examples. In Proceedings of the 36th ACM
SIGPLANConferenceonProgrammingLanguageDesignandImplementation(PLDI
2015).ACM,NewYork,NY,USA,229–239. DOI:http://dx.doi.org/10.1145/2737924.
2737977
[16]MarkGrechanik,ChenFu,QingXie,CollinMcMillan,DenysPoshyvanyk,and
Chad Cumby. 2010. A search engine for finding highly relevant applications. In
ACM/IEEE International Conference on Software Engineering. ACM Press, New
York, New York, USA.
[17]TihomirGveroandViktorKuncak.2015. Interactivesynthesisusingfree-formqueries.In 2015IEEE/ACM37thIEEEInternationalConferenceonSoftwareEngi-
neering, Vol. 2. IEEE, 689–692.
[18]MarkHarman,YueJia,andWilliamBLangdon.2014.Babelpidgin:SBSEcangrow
and graft entirely new functionality into a real world system. In International
Symposium on Search Based Software Engineering. Springer, 247–252.
[19]AbramHindle,EarlTBarr,ZhendongSu,MarkGabel,andPremkumarDevanbu.
2012. On the naturalness of software. In 2012 34th International Conference on
Software Engineering (ICSE). IEEE, 837–847.
[20]Reid Holmes and Robert J. Walker. 2013. Systematizing Pragmatic Software
Reuse.ACMTrans.Softw.Eng.Methodol. 21,4,Article20(Feb.2013),44pages.
DOI:http://dx.doi.org/10.1145/2377656.2377657
[21]OliverHummel,WernerJanjic,andColinAtkinson.2008. Codeconjurer:Pulling
reusable software out of thin air. IEEE software 25, 5 (2008).
[22]Yue Jia, Mark Harman, William B Langdon, and Alexandru Marginean. 2015.
Growandserve:Growing DjangocitationservicesusingSBSE.In International
Symposium on Search Based Software Engineering. Springer, 269–275.
[23]LingxiaoJiang,GhassanMisherghi,ZhendongSu,andStephaneGlondu.2007.
Deckard:Scalableandaccuratetree-baseddetectionofcodeclones.In Proceedings
of the 29th international conference on Software Engineering. IEEE Computer
Society, 96–105.
[24]ElmarJuergens,FlorianDeissenboeck,BenjaminHummel,andStefanWagner.
2009. Do code clones matter?. In Proceedings of the 31st International Conference
on Software Engineering. IEEE Computer Society, 485–495.
[25]Vineeth Kashyap, David Bingham Brown, Ben Liblit, David Melski, and
Thomas W. Reps. 2017. Source Forager: A Search Engine for Similar Source
Code.CoRRabs/1706.02769 (2017). http://arxiv.org/abs/1706.02769
[26]Yalin Ke, Kathryn T Stolee, Claire Le Goues, and Yuriy Brun. 2015. Repairing
programswithsemanticcodesearch(t).In AutomatedSoftwareEngineering(ASE),
2015 30th IEEE/ACM International Conference on. IEEE, 295–306.
[27]Iman Keivanloo, Juergen Rilling, and Ying Zou. 2014. Spotting working code ex-
amples.In Proceedingsofthe36thInternationalConferenceonSoftwareEngineering.
ACM, 664–675.[28]MiryungKim,LawrenceBergman,TessaLau,andDavidNotkin.2004. Anethno-
graphicstudyofcopyandpasteprogrammingpracticesinOOPL.In Empirical
Software Engineering,2004. ISESE’04.Proceedings. 2004 InternationalSymposium
on. IEEE, 83–92.
[29]OtávioAugustoLazzariniLemos,SushilBajracharya,JoelOssher,PauloCesar
Masiero, and Cristina Lopes. 2009. Applying test-driven code search to the reuse
of auxiliary functionality. In Proceedings of the 2009 ACM symposium on Applied
Computing. ACM, 476–482.
[30]Alexandru Marginean, Earl T Barr, Mark Harman, and Yue Jia. 2015. Auto-
matedtransplantationofcallgraphandlayoutfeaturesintoKate.In International
Symposium on Search Based Software Engineering. Springer, 262–268.
[31]Collin McMillan, Mark Grechanik, Denys Poshyvanyk, Qing Xie, and Chen
Fu.2011. Portfolio:findingrelevantfunctionsandtheirusage.In International
conference on Software engineering. ACM Press, New York, New York, USA.
[32]Alon Mishne, Sharon Shoham, and Eran Yahav. 2012. Typestate-based Semantic
Code Search over Partial Programs. In Proceedings of the ACM International
Conference on Object Oriented Programming Systems Languages and Applications
(OOPSLA ’12). ACM, New York, NY, USA, 997–1016. DOI:http://dx.doi.org/10.
1145/2384616.2384689
[33]Krishna Narasimhan and Christoph Reichenbach. 2015. Copy and Paste Re-
deemed. In Automated Software Engineering (ASE), 2015 30th IEEE/ACM Interna-
tional Conference on. IEEE, 630–640.
[34]AnhTuanNguyenandTienNNguyen.2015. Graph-basedstatisticallanguage
modelforcode.In Proceedingsofthe37thInternationalConferenceonSoftware
Engineering-Volume 1. IEEE Press, 858–868.
[35]J.Ossher,H.Sajnani,andC.Lopes.2012. Astra:Bottom-upConstructionofStruc-
turedArtifactRepositories.In ReverseEngineering(WCRE),201219thWorking
Conference on. 41–50. DOI:http://dx.doi.org/10.1109/WCRE.2012.14
[36]Justyna Petke, Mark Harman, William B Langdon, and Westley Weimer. 2014.
UsinggeneticimprovementandcodetransplantstospecialiseaC++program
to a problem class. In European Conference on Genetic Programming. Springer,
137–149.
[37]Amir Pnueli and Roni Rosner. 1989. On the Synthesis of an Asynchronous
ReactiveModule.In Proceedingsofthe16thInternationalColloquiumonAutomata,
Languages and Programming (ICALP ’89). Springer-Verlag, London, UK, UK, 652–
671. http://dl.acm.org/citation.cfm?id=646243.681607
[38]Oleksandr Polozov and Sumit Gulwani. 2015. Flashmeta: A framework for
inductive program synthesis. ACM SIGPLAN Notices 50, 10 (2015), 107–126.
[39]Mukund Raghothaman, Yi Wei, and Youssef Hamadi. 2015. SWIM: Synthesizing
What I Mean. arXiv preprint arXiv:1511.08497 (2015).
[40]VeselinRaychev,PavolBielik,MartinVechev,andAndreasKrause.2016.Learning
programs from noisy data. In ACM SIGPLAN Notices, Vol. 51. ACM, 761–774.
[41]Veselin Raychev, Martin Vechev, and Andreas Krause. 2015. Predicting Program
Propertiesfrom"BigCode".In Proceedingsofthe42NdAnnualACMSIGPLAN-
SIGACTSymposiumonPrinciplesofProgrammingLanguages(POPL’15).ACM,
New York, NY, USA, 111–124. DOI:http://dx.doi.org/10.1145/2676726.2677009
[42]VeselinRaychev,MartinVechev,andEranYahav.2014. CodeCompletionwith
StatisticalLanguageModels.In Proceedingsofthe35thACMSIGPLANConference
on Programming Language Design and Implementation (PLDI ’14). ACM, New
York, NY, USA, 419–428. DOI:http://dx.doi.org/10.1145/2594291.2594321
[43]Steven P. Reiss. 2009. Semantics-based Code Search. In Proceedings of the 31st
International Conference on Software Engineering (ICSE ’09). IEEE Computer Soci-
ety,Washington,DC,USA,243–253. DOI:http://dx.doi.org/10.1109/ICSE.2009.
5070525
[44]Chanchal K Roy, James R Cordy, and Rainer Koschke. 2009. Comparison and
evaluation of code clone detection techniques and tools: A qualitative approach.
Science of Computer Programming 74, 7 (2009), 470–495.
[45]H. Sajnani, V. Saini, J. Ossher, and C.V. Lopes. 2014. Is Popularity a Measure
of Quality? An Analysis of Maven Components. In Software Maintenance and
Evolution (ICSME), 2014 IEEE International Conference on. 231–240. DOI:http:
//dx.doi.org/10.1109/ICSME.2014.45
[46]SteliosSidiroglou-Douskos,EricLahtinen,FanLong,andMartinRinard.2015. Au-tomaticerroreliminationbyhorizontalcodetransferacrossmultipleapplications.
InACM SIGPLAN Notices, Vol. 50. ACM, 43–54.
[47]Armando Solar-Lezama. 2009. The sketching approach to program synthesis. In
Asian Symposium on Programming Languages and Systems. Springer, 4–13.
[48]Armando Solar-Lezama, LiviuTancau, Rastislav Bodik, Sanjit Seshia,and Vijay
Saraswat.2006.CombinatorialSketchingforFinitePrograms.In Proceedingsofthe
12thInternationalConferenceonArchitecturalSupportforProgrammingLanguages
andOperatingSystems(ASPLOSXII).ACM,NewYork,NY,USA,404–415. DOI:
http://dx.doi.org/10.1145/1168857.1168907
[49]Saurabh Srivastava, Sumit Gulwani, and Jeffrey S. Foster. 2012. Template-based
programverificationandprogramsynthesis. InternationalJournalonSoftware
Tools for Technology Transfer 15, 5 (2012), 497–518. DOI:http://dx.doi.org/10.
1007/s10009-012-0223-4
[50]Kathryn T Stolee and Sebastian Elbaum. 2012. Toward semantic search via SMT
solver.In ProceedingsoftheACMSIGSOFT20thInternationalSymposiumonthe
Foundations of Software Engineering. ACM, 25.
348
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Y. Lu et al.
[51]AbhishekUdupa,ArunRaghavan,JyotirmoyVDeshmukh,SelaMador-Haim,
Milo MK Martin, and Rajeev Alur. 2013. TRANSIT: specifying protocols with
concolic snippets. ACM SIGPLAN Notices 48, 6 (2013), 287–296.
[52]Yuepeng Wang, Yu Feng, Ruben Martins, Arati Kaushik, Isil Dillig, and Steven P.
Reiss. 2016. Hunter: Next-generation Code Reuse for Java. In Proceedings of the
2016 24th ACM SIGSOFT International Symposium on Foundations of Software
Engineering (FSE 2016). ACM, New York, NY, USA, 1028–1032. DOI:http://dx.doi.
org/10.1145/2950290.2983934
[53]NavidYaghmazadeh,ChristianKlinger,Isil Dillig,andSwaratChaudhuri.2016.
Synthesizing Transformations on Hierarchically Structured Data. In Proceedings
of the 37th ACM SIGPLAN Conference on Programming Language Design and
Implementation(PLDI’16).ACM,NewYork,NY,USA,508–521. DOI:http://dx.
doi.org/10.1145/2908080.2908088
349
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. 