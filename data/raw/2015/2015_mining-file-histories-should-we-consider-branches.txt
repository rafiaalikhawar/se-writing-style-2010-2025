Mining File Histories: Should We Consider Branches?
Vladimir Kovalenko
Delft University of Technology
Delft, The Netherlands
v.v.kovalenko@tudelft.nlFabio Palomba
University of Zurich
Zurich, Switzerland
palomba@ifi.uzh.chAlberto Bacchelli
University of Zurich
Zurich, Switzerland
bacchelli@ifi.uzh.ch
ABSTRACT
Modern distributed version control systems, such as Git, offer sup-
port for branching — the possibility to develop parts of software
outside the master trunk. Consideration of the repository struc-
turein MiningSoftwareRepository(MSR)studies requiresathor-
oughapproachto mining,butthereis nowell-documented,wide-
spread methodology regarding the handling of merge commits and
branches. Moreover, there is still a lack of knowledge of the extent
to which considering branches during MSR studies impacts the
results of the studies.
In this study, we set out to evaluate the importance of proper
handlingofbrancheswhencalculatingfilemodificationhistories.
We analyze over 1,400 Git repositories of four open source ecosys-
tems and compute modification histories for over two million files,
usingtwodifferentalgorithms.Onealgorithmonlyfollowsthefirst
parent of each commit when traversing the repository, the other
returnsthefullmodificationhistoryofafileacrossallbranches.We
show that the two algorithms consistently deliver different results,
butthescaleofthedifferencevariesacrossprojectsandecosystems.
Further,weevaluatetheimportanceofaccurateminingoffilehisto-
riesbycomparingtheperformanceofcommontechniquesthatrely
onfilemodificationhistory—reviewerrecommendation,change
recommendation,anddefectprediction—fortwoalgorithmsoffilehistoryretrieval.Wefindthatconsideringfullfilehistoriesleadsto
an increase in the techniques’ performance that is rather modest.
CCS CONCEPTS
•Softwareanditsengineering →Softwareconfigurationman-
agement and version control systems;
KEYWORDS
Version Control Systems; Branches; Mining Software Repositories
ACM Reference Format:
VladimirKovalenko,FabioPalomba,andAlbertoBacchelli.2018.Mining
File Histories: Should We Consider Branches?. In Proceedings of the 2018
33rd ACM/IEEE International Conference on Automated Software Engineering
(ASE ’18), September 3–7, 2018, Montpellier, France. ACM, New York, NY,
USA,12pages.https://doi.org/10.1145/3238147.3238169
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ASE ’18, September 3–7, 2018, Montpellier, France
© 2018 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.32381691 INTRODUCTION
The workflow of modern version control systems (VCS), such as
Git, extensively relies on branching. Branching support allows
developerstomanagemultipleisolatedversionsoftheworkingtree,
whichcanbemodifiedindependentlyofeachother.Branch-related
operations in Git are by design extremely lightweight compared
to older VCSs [ 27]. Low cost of branching allows branches to be
used for development of individual features, for experimenting
withdesignsolutions,andforpreparingreleases[ 23].Inallthese
examples useof branchesallows teams tokeep themain working
treefreeofquestionablecodeandreducesdevelopmentoverhead
related to version conflicts [46].
Whilebeingthemostpopularversioncontrolsystemtoday[ 14],
Gitisquiteunfriendlyfordatamining[ 27].Inparticular,branching
features introduce issues for miners: branches can be removed and
overwritten,andsynchronizationwiththeremoterepositorycan
introduce implicit branches with no logical meaning [27].
Despite the difficulties with analysis of Git history, mining of
historical data from VCS is still the basis for a variety of studies,
which quantitatively explore the development process and suggest
approaches to facilitate it [20, 26,36,40,43,52,62–64].
History of individual files is a particularly important source
of information for prominent practical applications, like (i) de-
fect prediction algorithms, where metrics based on file history are
important features [ 25,36,41,53], (ii) code ownership heuristics
[38,42,60], which are based on aggregation of individual contribu-
tions of all authors of the file, and (iii) code reviewer recommenda-
tion[22,54,59,61],wherehistoryofpriorchangestofilesserves
as a basis for automatic selection of the expert reviewers.
Pitfalls of Git from the data mining perspective pose common
threatstovalidityofeveryofsuchstudies.Someofthesethreats,
suchasmutabilityofhistory,arecommonlyacknowledgedbyre-
searchers(e.g.,[ 18,34,45,63,65]).Nevertheless,thereisnowide-
spreadapproachtohandlingofmergecommitsandbranchesduring
mining. Moreover, MSR studies often do not provide a detailed de-
scription of mining algorithms, and handling of the branches inparticular,orexplicitlyfocustheanalysesonthemainbranchof
the repository [18].
Inthisstudy,weaimatmakingafirststeptowardtheassessment
ofthethreatsarisingfromnotconsideringfullinformationabout
brenchinginminingsoftwarerepositorystudies.Specifically,we
focusontheimpactofthebranchhandlingstrategyonextractionof
a file modification history. This task requires a traversal of a repos-
itory graph to collect individual commits affecting the file. We first
perform a preliminary analysis on how the mining of file histories
is impacted by branches, by measuring how much first-parent (i.e.,
history extractable when only considering the first parent of each
commitwhentraversingtherepository)and full(i.e.,thehistory
202
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Vladimir Kovalenko, Fabio Palomba, and Alberto Bacchelli
extractable when considering changes in all branches) file histo-
ries differ from each other. Then, we study how performance ofthree MSR applications (code reviewer recommendation, change
recommendation, and defect prediction), that use file modification
histories as input data, varies when considering branches.
Our results show that the first-parent and full mining strategies
consistently result in different file histories, even though the scale
ofthedifferencevariesacrosssoftwareecosystemsandrepositories
within each ecosystem. We find that considering the full file histo-
riesleadstoan increaseintheconsideredMSR-basedtechniques’
performancethatisrathermodest.Thismarginalincreaseindicates
that our findings do not raise any serious questions on the validity
ofstudiesthatsimplifytheminingapproach.Nevertheless,inour
workwedevisedamethodandatoolforefficientminingoffullfile
histories at scale, which we make publicly available [11].
2 BACKGROUND
Severalpriorstudiesfocusontheuseofbranchinganditsadded
valuefordevelopers.Combined,thesestudiesprovidestrongevi-
denceofimportanceofbranchinginmodernsoftwaredevelopment.
Appleton et al. [ 19] explore an extensive set of branching patterns
andproposeanumberofbestpracticesandantipatterns.Buffen-
bargerandGruell[ 32]devisepracticesandpatternstofacilitateeffi-
cient parallel development, mitigating the complexity of branching
operations in early VCSs. Bird et al. [29] conclude that developers
working in a branch represent a virtual team. Barr et al. [ 23] claim
thatlightweightbranchingsupportistheprimaryfactorinrapid
adoptionofmoderndistributedVCSsinOSSprojects.BirdandZim-
mermann[ 28]identifycommonproblemsfromimproperbranch
usageand proposean analysisto assessmoreefficient alternative
branchstructures.Shihabetal.[ 56]findthattheexcessiveuseof
branches is associated with a decrease in software quality.
Today’smostpopularversioncontrolsystem—Git—wasnot
designed to preserve a precise history of modifications [ 10], which
impliesdifficultieswiththeanalysisofthesehistories[ 27,48].Anal-
ysis of software version histories is not only used to study the
developmentpractices,butalsotofacilitatedevelopmentwithdata-
driven tools. Prominent examples of applications for tools heavily
relying on histories of changes of individual files are defect pre-diction [
35,39,47], code reviewer recommendation [ 22,61], and
change prediction [ 67,68]. Notably, the complexity of Git, the mu-
tabilityofitsdatastructure,andthedifficultyoffiguringoutthe
parentrelationshipsbetweenrevisionscomplicatetheworkofre-
searchers and prevent some practitioners from using it as their
versioncontrolsystem[ 16].Beingabletoaccuratelyretrievehis-
toriesofpriorchangesisvitalforefficientuseoftechniquesthat
arebasedonhistories.Moreover,insomecaseshistoriesneedtobe processed to achieve optimal performance of the techniques:For instance, Kawrykow and Robillard [
44] show that removing
non-essential changes from modification histories improves the
performance of co-change recommendation [68].
2.1 Motivation
Version control repositories are the key data source for a wide
variety of software engineering studies [ 34,36,41,58,63]. With
no widespread high-level mining tool in use, the common wayfor the researchers to mine the histories of repositories is to usehomegrown tools based on low-level libraries, such as JGit [
9].
While low-level operations provide greater flexibility of mining,
they also undermine the reproducibility of studies, as details of
miningareusuallynotelaboratedoninthepapers.Reproduction
packages,whereavailable,commonlycontaininformationobtained
after mining, but not the repository mining scripts.
Restoring the actual change history from a Git repository is
challenging anderror-prone [ 27]. Tocome around thedifficulties,
some studies (e.g. [ 18]) focus on the development activity in the
mainbranch,thusomittingpartofthechangesintherepository.
This approach may be sufficiently precise for some applications,
because (i) insome repositories mostof developmentactivity takes
placeinthemasterbranch,and(ii)the rebaseoperationisoften
used to integrate changes from branches into the main branch.
However, consideration of branches and careful handling of merge
commitsmightbeimportantforprecisecalculationofindividual
filehistories,whicharetheprimarysourceofinputdatainsome
contexts, such as code reviewer recommendation [ 22] and change
recommendation [68].
The difference in quality of data between different mining ap-
proaches,andtheimpactofthechosenminingapproachonperfor-
mance of analysismethods driven by historicaldata, are not clear
and have not yet been explored. We conduct this study to quan-
tifytheeffect ofconsideringthegraphstructure oftherepository
(importanceofsuchconsiderationisreportedasoneoftheperils
of mining Git [ 27]) and to investigate how the difference in the
resultsfromdifferentmining approachesimpactsperformanceof
MSR applications.
Whilethefilehistoriesarethemaininputdataforavarietyof
MSR-based techniques, there is no guarantee that more complex
and precise mining methods ensure an increase in performance of
the techniques notable enough to justify the extra mining effort.
With no prior research existing on this topic, with this study we
seeknotonlytoidentifytheimpactofbranchhandlingstrategyon
performanceoffile-history-basedmethods,butalsotocomparethe
scale of this impact between different techniques. This knowledge
couldhelpmakeasteptowardsensuringthatMSRstudiesandtheir
practical applications employ optimal mining strategies to get the
most value out of the repository data.
2.2 Challenges of Mining the File Histories
Mining of histories of individual files at large scale is a non-trivial
task.Gitprovidesatoolkitforrepositoryoperations,including git
log, which facilitates retrieval of logs of commits. However, Git
wasnotdesignedtosupportcarefulstorageandretrievalofhistory
of changes [ 10,31,49,57], which implies several complications
with using git log for mining file histories. Specifically:
Performance With no specialized index for file histories in place,
retrieval of histories of changes for an individual file requires
traversalofthecommitgraph.Retrievalofhistoriesforeveryfile
in the repository tree is very expensive.
Handling of renames AGitrepositorydoesnotcontainanyrecords
of renames and moves of files. Such events are detected based
onsimilarityofcontentsofconsecutiveversionsofafile,with
thresholds defined by the settings of the Git client. As a result,
203
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. Mining File Histories: Should We Consider Branches? ASE ’18, September 3–7, 2018, Montpellier, France
calculatedhistoryofthesamefileinthesamerepositorymight
appear different on different clients.
Handling of merge commits and branches Thegit logtool,
whichisoftenusedforanalysisofsoftwarehistories,supports
an overwhelming variety of settings, with over 100 argument
options[6].Unlessthetoolisthoroughlysetup,somepotentially
interesting changes might be implicitly omitted: for example, by
defaultgit log prunes some side branches. A default approach
might not be suitable for some applications.
Difficulty of use A wide variety of settings makes the user expe-
riencewith git logquitecomplicated.Certainscenariosofre-
trievalofrepositoryhistoryareevenharder:forexample,travers-
ingthecommitsgraphforwardintime,whichmightbeuseful
in some contexts, is more difficult. For example, all descendants
of a commit can be retrieved with the following command:
git rev-list --all --parents | grep ".\{40\}.*SHA.*" |
awk '{print $1}'
This command [ 5], which only lists the commits without provid-
ing any information on the structure, is already not trivial.
2.3 Retrieval of File Histories
History of commits in a Git repository can be represented as a
directed acyclic graph. Each commit logically represents a stateof the repository’s file tree. Each version of the state is based onone or several prior (parent)version, and only the difference in
the state between the parent and the current version is actually
stored.1InFigure 1(left),whichpresentsahypotheticalcommittree,
thecommitparentrelationshipsarerepresentedbyblackarrows:
forexample,commit5istheparentofcommit6.Mergecommits,
whichintegratechangesfrommultiplebranches,havemorethan
one parent. In Figure 1, commit 5 has two parents: 3 and 4. In a
mergecommitwithmultipleparents,thelistofparentsissorted:
ifbranch Aismergedintobranch B,thefirstparentofthemerge
commit would be the one that branch Bwas pointing to before the
merge. In Figure 1, parent commits are sorted left to right: commit
4 is the first parent of commit 5.
Each commit affects a set of files2and defines their new content
relativetotheircontentintheparentcommit.Itispossibletosay
that a commit affectsa file, if its content in the revision which is
represented by the current commit is different from its contentin the parent commit, or if the file was created/removed in the
current commit. It is common to think of a commit as simply a set
ofchangesinoneormultiplefiles.ThissimplemodelisconvenientandisusedbyGititself,e.g.,inthe
git diff command.InFigure 1,
affected files are shown in boxes next to nodes of the commit tree.
Retrieval of a a history of changes for a given file — i.e., list
of the commits that affect this file — one needs to traverse the
commit graph to identify such commits. A traversal and handling
of commits one by one is necessary because Git does not store any
auxiliary data that would allow to perform this operation faster.
Duringthetraversal,itispossibletoeitherfollowallparentsofa
merge commit, which ensures visiting every transitive parent of
the starting point and including all of these commits in the history,
or only follow the first parent.
1Described is a simplified scheme of the storage model of Git, which is in reality more
complex.
2The set can be empty, e.g., in most of merge commits without conflicts.We refer to the traversal strategy that follows all parents and
toresultinghistories as full.Consideringtheexamplerepository
graphinFigure 1,fulltraversalstartingfromthelatestcommitin
the repository (12) would include all 12 commits in the repository.
A full history for the file f2would contain all 9 of these commits
that affect f2. An alternative strategy is to only follow the first
parentofeverymergecommitduringthetraversal.Werefertothis
strategy and resulting file histories as first-parent. For the example
in Figure 1, such traversal starting from commit (12) would only
includecommits(12),(11),(9),(6),(5),(4),(2),and(1).Afirst-parent
history of f2would only include 6 commits from this traversal that
affectf2.Itisimportanttonotethatthefirst-parentstrategydoes
not omit merge commits that contain changes to the file relative to
its first parent: an example of such commit in Figure 1is (5), and it
is included in the first-parent history as well.
The histories for the file f2, as retrieved with both strategies, are
presentedinFigure 1(right).Asthefirst-parenthistorycontainsless
commits,somechangestothefileareomitted.Thus,usingthefirst-
parent strategy to calculate quantitative properties of file histories,
such as number of changes or number of contributors, leads to
incompleteresults.Thetwocasesrepresentedbythetwostrategies
areratherextreme:thesimplifiedstrategyomitsallchangesthat
were made outside the main branch and did not end up in the
mainbranchafterarebase.Therearelessradicalwaysofsimplifiedhandlingofbranchesthantoomittraversingthebranchcompletely.
Forexample,onewaytoseethesummaryofchangesinabranch
is to inspect the output of git diff between two parents of a
mergecommit.ThisapproachisadoptedbysomeGUIapplications
ontopofGit,suchasSourcetree3.Whilethisapproachallowsto
retrieve a summary of changes in a branch, the individual changes,
possibly made by different authors, are presented together and are
not distinguishable, which makes the approach less applicable for
miningtasks:itisimpossibletoidentifyindividualcontributions
by count, sizes, or dates of changes per author.
We find the extreme case of comparing full and first-parent
histories an appropriatesetting to study the impactof the mining
strategy on the results of mining and performance of the methods
based on these results. With the two extreme cases, we have thehighest chance of identifying effects not present in less extreme
settings.Asthisstudyisthefirsttoexploresucheffects,weconsider
this setting fruitful to highlight the directions for future work.
3 METHODOLOGY
3.1 Research Questions
Wecenterourinvestigationaroundtworesearchquestions.First,we
set out to quantify the importance of careful handling of branches
duringmining.Inparticular,we(i)exploretherepositorystructure
tocalculatenumbersofcommitsreachablewithandwithoutcon-
sidering branches and (ii) analyze differences on a lower level of
history of individual files. Thus our first research question is:
RQ1.How does the branch handling strategy impact the results of
mining?
Having identified the magnitude of the difference between min-
ing approaches that consider and do not consider branches, we
3https://www.sourcetreeapp.com/
204
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Vladimir Kovalenko, Fabio Palomba, and Alberto Bacchelli
6
35
4
2
1ADD f1
ADD f2EDIT f1EDIT f1
EDIT f2 EDIT f2¬(merge)
EDIT f2EDIT f1
EDIT f29 12 
10 11 
EDIT f1EDIT f2
EDIT f1EDIT f2¬(merge)
no
changes EDIT f1EDIT f2
8 EDIT f1EDIT f2
6
35
4
2
1ADD f1ADD f2EDIT f1EDIT f1
EDIT f2 EDIT f2¬(merge)
EDIT f2EDIT f1
EDIT f29 12 
10 11 
EDIT f1EDIT f2
EDIT f1EDIT f2¬(merge)
no
changes EDIT f1EDIT f2
8 EDIT f1EDIT f2
6
5
4
1History of f2 
(ﬁrst-parent) History of f2 
(full) 
912
6
5
4
1912
10
8
3
Figure 1: Construction of file parent connections and resulting file histories
investigatetheimpactofbranchhandlingstrategyontheperfor-
mance of algorithms relying on history of files such as reviewer
recommendation,changerecommendation,anddefectprediction.
Thus, our second research question is:
RQ2.How important is the branch handling strategy for applica-
tions?
3.2 Mining Histories at Large Scale
Traversal of the commit tree can take a significant amount of time:
in some repositories the tree contains hundreds of thousands of
commits.Ifthisoperationhastoberepeatedformanyorevenall
files in the repository — which is often the case during mining the
repository for file histories — it can take a lot of time for larger
repositories. Slowness of mining the file histories is a limitation of
thestoragemodelofGit,whichdoesnotlinkindividualversionsof
a file to each other, and does not include indices of changes to indi-
vidual files. To overcome this limitation, we devised an alternative
representationofchangesinGit,aimedatfastretrievaloffilehisto-
ries.Weusea graphdatabase engine4tostore arepresentation of
thecommitgraph.Tokeepthedatabasecompact,weonlystorethe
commit nodes and records of affected files, excluding their content.
In addition to the commit parent relationship, which is the basis
of the commit graph in Git, we introduce the concept of parent file
versions. A parent version of a file can be defined as a change tothe same file in some other commit, which can be reached fromthe current commit with a unique path over the commit parentgraph. In Figure 1(center), the file parent connections are repre-
sentedbygrayarrows.Byprocessingtherepository,webuildthe
graph of parent relationships between file versions, and store it in
the graph database aside the commit graph. Once the file parent
graphisbuilt,retrievalofpriorchangestothefileisassimpleas
retrieving all transitive parents of the current version, which only
4Neo4J: https://neo4j.com/requirestraversingthefileparentgraph,whichismuchfasterthan
traversing the whole repository thanks to direct links to parent
file versions. For large-scale mining tasks this approach saves time:
after processing the repository and building the file parent connec-
tions, it is possible to retrieve full modification histories for several
thousand files per second. Figure 1(right) presents the resulting
histories from traversal of the file parent graph.
3.3 Target Systems
We take a number of steps to ensure diversity in our target sys-
tems [51]. Our dataset consists of 260 repositories from Github,
selected in a stratified manner to include projects of different scale.
UsingGHTorrent[ 37],werandomlysample100repositorieswith
over 10,000 commits recorded in GHTorrent database for each, and
200 repositories with 1,000 to 10,000 commits. 40 of the 300 repos-
itories turned out not to be publicly available anymore; the rest
comprise our Github sample. Counts of commits as retrieved from
GHTorrent are not completely accurate, so actual distribution of
sizesofrepositoriesinthesampleisslighlymoredisperse.Wehave
attempted to download and mine all repositories from the Apache
open source ecosystem, of which we succeeded with 441 reposito-
riesof532.Therestoftherepositorieswerenotavailable,empty,
or failed to process with our toolkit.
Finally, we include 395 and 309 repositories from Eclipse and
OpenStack respectively, which use Gerrit for code review. The
repositories in these two samples belong to the projects concerned
bythelatest100,000reviewsineachGerritinstance,whichwehave
mined to evaluate the performance of a reviewer recommendation
algorithm (Section 5.1). We usesmaller subsetsof repositoriesfor
partsofRQ2.Forchangerecommendationanddefectprediction,
we use samples of 10 repositories from each of Eclipse and Apache
ecosystems.Theseecosystems wereselectedbasedon availability
of defect data (explained in Section 5.3.1). We use the same sample
forchangerecommendation(Section 5.2.1).Toevaluatereviewer
205
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. Mining File Histories: Should We Consider Branches? ASE ’18, September 3–7, 2018, Montpellier, France
recommendation performance, we use the repositories of the 20
mostactiveprojectsfromeachofEclipseandOpenStackecosystems
(Section5.1).Forthequantitativeanalysisofrepositorystructure
and file histories (RQ1), we use all 1,405 repositories from the four
samples. We report the entire list of repositories in our online
appendix [11].
4 RQ1: DIFFERENCE IN MINING RESULTS
Our first research question seeks to quantify the differences re-
sulting from the application of two different mining approaches to
retrieval of the history of files in Git.
4.1 Methodology
Wedevisedasetofmetricsthatquantifytheeffectofstrategyof
branchhandlingontheresultsofmining.Afterwards,wecompared
twoapproachesintermsofthesemetrics,i.e.,the first-parent one
(which extracts history only considering the first parent of each
commit when traversing the repository) and the fullone (which
extracts all the commits by exploiting the approach described in
Section2.3).
For each repository, we first compute descriptive measures of
itsstructure,suchasnumberofcommitsthatarereachablefrom
HEAD (the latest commit in the main branch), number of merge
commits (with more than one parent), number of files in the repos-
itory, and number of unique contributors to the repository. We
usethesemetricstocomparetheecosystemsbetweeneachother,
and to explore the variation in branching activity within and be-
tweenthem,whichisimportantformining:forexample,differences
betweenthe numbersofcommitsreachable dependingonthetra-
versalstrategydenotetheimportanceofthestrategyformining:
if only the first parent is considered and traversed, some commits
are left out, while still contributing to the state of the repository at
HEAD. Number of merge commits can be used as a proxy measure
of branching activity in the repository.
Beyond repository-wide metrics, the way in which branches
arehandledalsoimpactsthecalculationofhistoriesofindividual
files: if only the main branch is considered, some changes from file
historyare omitted.This effectmight impactvarious applications
of file histories, ranging from identification of contributors to a file
to more complex scenarios such as reviewer recommendation.
To quantify this effect, we calculate histories of every file in the
repository, using both the first parent and thefullapproaches to
retrieve all commits that contribute to a given version of a file. For
every repository (all of which contain over 2 million files in total),
we calculate repository-wide average length of the history of a
file in its tree, when retrieved via first-parent and full method. We
compute the ratio of these averages, and fraction of files for which
the two methods deliver different histories among all files in the
repository. In addition, we calculate numbers of contributors to
eachfileforbothmethodsoffilehistorymining,andcomparetheir
repository-wide averages.
4.2 Results
4.2.1 Descriptive Metrics. To display the natural differences be-
tween the ecosystems, which are not associated with different min-
ingstrategies,wefirstpresentthecomparisonoftheecosystemsin terms of natural activity metrics, such as sizes of repositories
and number of contributors. The top two rows of Figure 2present
acomparisonofdescriptivemetricsbetweentherepositoriesinthe
four subject ecosystems. The numbers of commits in the reposi-
tories within each ecosystem greatly vary. A median number of
commits in a repository ranges from 172 for Github to 1,039 for
OpenStack.Anaveragerepositorycontainsseveralhundredfiles
inthefiletreeatHEADandthisnumbervariesinallecosystems,
with a lower variation for OpenStack. Projects from GitHub are
typically developed by only a few authors – the median number of
contributors for a Github repository is 4. This value for OpenStack
is 61, with Eclipse and Apache falling in the middle.
For measures of branching activities, repositories from three of
the four ecosystems display moderate values: The majority of com-
mitsinatypicalrepositoryfromeveryecosystemexceptOpenStack
is reachable from HEAD. OpenStack also stands out in numbers
ofmergecommits.Inamedianproject,almost30%ofcommitsin
therepositorythatarereachablefromHEADaremerges(Figure 2).
Alongwithhigherbranchingactivity,OpenStackrepositoriesshow
thehighestdifferencebetweennumbersofcommitsreachablefrom
HEAD via the first parent and via all parents.
Notably, repositories from Github are much more diverse in
termsofbranchingactivitymetrics.Weattributethisdiversitytothefactthatprojectsinotherecosystemsarelogicallyconnected,
with possibly common engineering guidelines and intersecting
development teams. In addition, the branching structure of the
repositories is possibly impacted by the strategy of integrating the
pull requests, which are a common part of the workflow at Github
and can be either merged or rebased.
4.2.2 File History Metrics. Table1presents the statistics on the
fourecosystemswithregardtodifferenceinfirst-parentandfullfilehistories.Overthefourecosystems,19%offilesdisplaydifferenceinhistoriesretrievedviafirstparentandfullmethods.Ecosystem-wide
fractions vary from 14% in Eclipse to 55% in OpenStack. 71% of the
repositoriesinoursamplescontainatleastonefilewithdifferenceinthehistory.Fractionofsuchrepositoriesvariesbetweenecosystems
from56%inEclipseto97%inOpenStack.81%ofallcommitsand
72% of all files belong to such repositories, which indicates that the
difference between first-parent and full histories is significant in
most of the repositories and cannot be ignored as a rare effect.
Distributionsofthemetricsrelatedtodifferenceintheresultsof
miningfilehistoriesarepresentedinthebottomrowofFigure 2.
One metric that indicates the importance of the strategy of file
historyminingforagivenrepositoryisnumberoffilesforwhich
historiesretrievedviathefirstparentandviathefulltraversalhave
different lengths. Such files exist in 305 of 441 repositories (69%)
fromApache,173outof260(67%)fromtheGithub,220of395(56%)
in Eclipse, and in 301 of 309 (97%) OpenStack repositories.
Similarly to the merge activity metrics, fraction of files with
differenceinhistorygreatlyvarieswithineveryecosystem.Median
proportionofsuchfilesis8%inApacheandGithub,under1%in
Eclipse, and 46% in OpenStack repositories. Distribution of ratio of
the length of the two histories across repositories that contain files
withthedifferenceinhistories(naturally,thismetricisonlydefined
forsuchprojects),displaysasimilarbehaviouracrossecosystemstofraction of files with the difference in history. This ratio for Eclipse
206
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Vladimir Kovalenko, Fabio Palomba, and Alberto Bacchelli
Table 1: Overview of the target ecosystems
EcosystemProjects Commits Files
totalwith 
diﬀerencetotalin projects with 
diﬀerencetotal with diﬀerencein projects with 
diﬀerence
Github 260 173 (67%) 872,833 257,156 (29%) 322,783 85,170 (26%)  225,861 (70%)
Apache 441 305 (69%) 998,910 938,032 (93%) 861,196 136,692 (16%) 525,997 (61%)
OpenStack 309 301 (97%) 1,317,165 1,317,004 (100%) 87,382 47,634 (55%) 87,166 (100%)
Eclipse 395 220 (56%) 1,000,997 883,318 (88%) 874,044 127,833 (14%) 712,315 (82%)
Total 1,405 999 (71%) 4,189,905 3,395,510 (81%) 2,145,405 397,329 (19%) 1,551,339 (72%)


1101001,00010,000100,000
apache eclipse github openstacktotalCommitsCount of commits in the repository




1101001,00010,000100,000
apache eclipse github openstackfilesInTreeFiles in tree at HEAD







  
1101001,000
apache eclipse github openstackuniqueAuthorsInRepoUnique authors of commits




























 
0.00.20.40.60.8
apache eclipse github openstackmergeCommitFractionFraction of merge commits
(among commits reachable from HEAD)







































0.000.250.500.751.00
apache eclipse github openstackreachableCommitFractionFraction of commits reachable from HEAD
(among all commits in the repository)






















0.000.250.500.751.00
apache eclipse github openstackmainBranchReachableFractionFraction of commits reachable
from HEAD via the first parent
(among commits reachable from HEAD)


























0.000.250.500.751.00
apache eclipse github openstackfractionOfFilesWithDiffFraction of files with different
sizes of history (first −parent/full)










































0.250.500.751.00
apache eclipse github openstackhistoryLengthRatioTotalAverage ratio of history lengths
(first−parent/full, all files)














































0.250.500.751.00
apache eclipse github openstackavgContributorsRatioTotalAverage ratio of numbers of contributors
in first−parent/full histories (all files)
Figure 2: Comparison of descriptive metrics between repositories in different ecosystems
repositories is the highest of the four (the histories are the most
similar; median ratio is 0.997) and the lowest for OpenStack (0.63).
If we omit the files with identical first-parent and full histories
and only consider the files with the difference, an ecosystem-wide
median value for average ratio of history lengths in a repository
ranges from 0.54 to 0.82 for OpenStack and Eclipse, respectively.
Thevaluesfortheaforementionedmetricsindicatethat—inmost
of the repositories from all four ecosystems—the first-parent strat-
egy leaves out a significant number of changes. The proportion of
filesaffectedbythedifferenceandthescaleofthisdifferenceare
the lowest for Eclipse and highest for OpenStack.
Onestraightforwardpracticalapplicationoffilehistoriesisre-
trieval of contributors to a file. Developer tools with code viewing
features, such as Github, display contributors to the current file in
theuserinterfaceoffilecontentdisplay.Figure 2displaystheratios
of counts of version control user records in first-parent and full
histories.Whiletheratioiscloseto1formostoftherepositoriesin Eclipse, Github and Apache, there are quite a few repositories
withlargedifferenceineachoftheseecosystems.Formostofthe
repositories in OpenStack, retrieval of histories via the first parent
ofthecommit leavesoutover25%of contributorrecords(median
value of the ratio is 0.74). Only considering the files with different
histories naturally leads to an even stronger effect.
4.2.3 Summary. The analysis of the results of mining across
over1,400repositoriesinthefoursubjectecosystemsrevealsthat—inmostoftheconsideredrepositories—thetwostrategiesofmining
file histories deliver different results (Figure 2, Table1). The size
of the difference for a typical repository varies across the four
ecosystems and is the lowest for Eclipse and the highest for Open-
Stack.Thesizeoftheeffectalignswiththeproportionofthemergecommitsinrepositoriesandreachabilityofcommits(Figure 2).The
differencebetweenthehistoriesdoesnotonlyimpacttheirquantita-tivemetrics,butalsodistortstheobservednumbersofcontributors
207
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. Mining File Histories: Should We Consider Branches? ASE ’18, September 3–7, 2018, Montpellier, France
toafile.Weexploretheimpactoftheminingtechniqueonthemore
complex repository analysistechniques relyingof filehistories in
the next research question (RQ2, Section 5).
5 RQ2: IMPORTANCE FOR APPLICATIONS
To evaluate importance of the mining approach for practice, we
comparetheperformanceofthreeprevalenttechniquesbasedon
historiesofchanges:(i)recommendationofcodereviewers[ 22],(ii)
change recommendation [68], and (iii) defect prediction [41].
Itisimportanttonotethat,whilewecomparethenumbersof
performance of the techniques, we do not perform statistical tests
toassessthesignificanceofthedifference,because(i)wearemerely
demonstratingtheexistenceofthedifferenceforindividualprojects
fromoursamples,ratherthantryingtogeneralizetheresultsfor
a broader population of projects, and (ii) statistical tests, such as
Mann-Whitney U, which arecommonly usedfor thispurpose, are
not applicable in our case, because measures of performance ofconceptually similar algorithms on related data from the same
projects cannot be considered independent samples [50].
5.1 Code Reviewer Recommendation
5.1.1 Methodology. Recommendation of reviewers for code re-
viewhas thegoal offinding themostqualified reviewerfor anew
codechangecommittedonarepository[ 22].Suchrecommendation
toolsusuallyminethechangehistoryinformationtoidentifythe
developer that is more expert on the piece of code impacted by
the change under review. Thus, it represents a prominent example
of usage of file histories to assist developers in routine tasks. In
thelastfewyearsthereviewerrecommendationalgorithmshave
beenadoptedbyindustrialcodereviewtools,suchasGithub[ 7],
Gerrit [4] and Upsource [15].
We focus on two open source ecosystems that use Gerrit for
code review — Eclipse [ 2] and OpenStack [ 12]. For each of the
two Gerrit instances [ 3,13], we extract the 100,000 most recent
codereviews.Wechoosethisnumbertohaveasufficientlylarge
dataset,whichwould,however,notincludeallofthereviewsinthe
correspondinginstances,butonlytwosets,similarinsize,ofthe
mostrecentreviewsfromeachinstance.Weassesstheimpactof
the file history retrieval method on accuracy of recommendations
of code reviewers based on the history of changes. We perform the
evaluationtofindoutwhethertheaccuracyofrecommendations
changesdependingonmethodoffilehistoryretrieval,butnotto
achieve maximum possible accuracy. Thus, we resort to a trivial
reviewerrecommendationalgorithm,basedoncountsofdevelop-
ers’priorcontributionstothefilesunderreview.Weevaluatethe
recommendations by comparing a list of recommendations with
actualreviewersofachangeset,asrecordedinGerrit.Toassessthe
accuracyofrecommendations,weusetwocommonwisemetrics:
Mean Reciprocal Rank (MRR) and top-k precision [66].
5.1.2 Results. Table2presents the results of evaluation of re-
viewerrecommendationalgorithmbasedonauthorsofpastchanges
to files under review. We compare the accuracy of the algorithm
betweenthetwo variationsofinputdata:first-parent andfullfile
histories. For each of the two ecosystems — Eclipse and OpenStack
—wecomparetheaccuracynumbersfor20projectsineachecosys-
tem. The selected projects are the most represented among 100,000latest code reviews in the corresponding Gerrit instance. We re-port values of mean reciprocal rank and top-k accuracy for k in
{1,2,3,5,10}(average for all reviews in the project) for the recom-
mendation lists based on both first-parent and full histories of files
under review, and explore the difference between these values. To
keepthetablecompact,weonlyreportthe5mostactiveprojects
fromeachecosystemindividually,andaggregatedvaluesforthetop
5andtop20projects.Toillustratethescaleofdifferencebetween
filehistories,wealsoreportaveragecountsofcommitsintheunion
ofhistoriesoffilesunderreview,forbothmethodsofretrievalof
file histories, and the ratio of these numbers for the two methods.
For the Eclipse ecosystem, the difference in recommendation
accuracy is subtle: MRR and all 5 top- kprecision values only vary
very slightly between first-parent and full histories consistently
acrossallprojects.FortheOpenStackecosystemthedifferenceis
slightlymorepronounced.WhileMRRvaluesonlydifferslightly,
top-kprecision values differ increasingly for higher values of k.
This difference indicates that the full histories of files may include
changes, made by future reviewers of a file, that are not presentin the first-parent histories. The increase in the size of the effect
with the increase of
ksuggests that authors of such changes are
typicallynotthemaincontributorsofthefile,astheyenduparound
k-thpositioninthelistofpastcontributorssortedbynumbersof
contributions,thusstartingtoaffectthetop- kprecisionvaluefor
the corresponding kand higher.
Thedifferenceinthesizeoftheeffectbetwenthetwoecosystems
can be explained by the fact that the difference between the full
andfirst-parenthistoriesismuchhigherforOpenStackreposito-
ries than for Eclipse. In OpenStack, the full histories of commits
forallfilesunderreview,inunion,containonaverage5.26times
asmanychangesasthefirst-parenthistories.InEclipse,theaver-
agedifferencebetweensizesofhistoriesisunder20%.Suchalow
differenceisunlikelytocausealargedeviationofthetwosorted
contributorlists,andisthusnotcriticalfortheaccuracyofreviewerrecommendationbasedonhistoryofchanges.Alargedifferencein
OpenStack, however, noticeably impacts the accuracy of reviewer
recommendation.
5.2 Change Recommendation
5.2.1 Methodology. Anotherexampleofusageofhistoricaldata
toimprovetheuserexperienceofdevelopmentprocessisrecom-
mendation of changes, based on mining of association rules for
changestoindividualfiles.Apracticalapplicationforthistechnique
wasdescribedbyZimmermann etal.[68]:inparticular,givenanew
codechangeasinput,theirtechniquesuggestsrelatedchangesthatthedevelopermightwanttoapplybasedonthefilesthatfrequently
change with the modified file. We perform an experiment to assess
the effect of using full histories of changes to a file, compared to
using the first-parent histories.
The original design by Zimmermann [ 68] uses a set of changes
from version control to infer file association rules. To apply the
approachtoourareaoffocus—differenceinresultsofminingof
individual files — we adapt the design of the original tool. We use
two different approaches to infer the association rules from past
changes, and evaluate their performance in predicting a change of
208
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Vladimir Kovalenko, Fabio Palomba, and Alberto Bacchelli
Table 2: Results of reviewer recommendation evaluation on projects from Eclipse and OpenStack
MRR Top 1 precision Top 2 precision Top 3 precision Top 5 precision Top 10 precision Changes per review
Project (OpenStack) ReviewsReviews 
w/ diﬀﬁrst 
parentfull deltaﬁrst 
parentfull deltaﬁrst 
parentfull deltaﬁrst 
parentfull deltaﬁrst 
parentfull deltaﬁrst 
parentfull deltaﬁrst 
parentfull ratio
openstack/tripleo-heat-templates 2,588 2,477 0.16 0.19 0.03 0.13 0.10 -0.02 0.17 0.18 0.01 0.19 0.23 0.03 0.21 0.30 0.09 0.22 0.38 0.16 7.75 76.46 9.87
openstack/releases 2,107 1,990 0.16 0.21 0.05 0.10 0.10 0.00 0.19 0.28 0.09 0.22 0.32 0.11 0.24 0.35 0.11 0.24 0.36 0.12 9.81 26.56 2.71
openstack/cinder 2,073 2,049 0.02 0.02 0.00 0.01 0.01 0.00 0.02 0.02 0.00 0.02 0.02 0.00 0.02 0.03 0.01 0.03 0.04 0.02 17.41 157.62 9.05
openstack/requirements 1,786 1,771 0.05 0.07 0.03 0.01 0.01 0.01 0.02 0.02 0.00 0.02 0.04 0.02 0.08 0.12 0.04 0.14 0.29 0.15 255.40 1,534.32 6.01
openstack-infra/zuul 1,367 1,329 0.10 0.13 0.03 0.05 0.04 -0.01 0.08 0.10 0.02 0.11 0.14 0.03 0.15 0.23 0.08 0.24 0.35 0.12 65.85 178.63 2.71
Total (OpenStack top 5) 9,921 9,616 0.10 0.13 0.03 0.07 0.06 -0.01 0.10 0.13 0.03 0.12 0.16 0.04 0.15 0.21 0.06 0.17 0.29 0.11 62.79 359.34 5.72
Total (OpenStack top 20) 25,179 24,297 0.13 0.15 0.02 0.09 0.08 -0.01 0.14 0.15 0.01 0.16 0.19 0.03 0.19 0.24 0.05 0.21 0.31 0.10 40.05 210.50 5.26
Project (Eclipse) ReviewsReviews 
w/ diﬀﬁrst 
parentfull deltaﬁrst 
parentfull deltaﬁrst 
parentfull deltaﬁrst 
parentfull deltaﬁrst 
parentfull deltaﬁrst 
parentfull deltaﬁrst 
parentfull ratio
papyrus/org.eclipse.papyrus 4,884 3,775 0.26 0.26 0.00 0.18 0.18 0.00 0.27 0.26 0.00 0.31 0.31 0.00 0.35 0.36 0.00 0.41 0.42 0.02 48.10 68.46 1.42
jgit/jgit 4,842 4,197 0.42 0.42 0.01 0.30 0.31 0.00 0.43 0.43 0.00 0.50 0.51 0.00 0.58 0.59 0.01 0.64 0.67 0.03 44.74 78.38 1.75
linuxtools/org.eclipse.linuxtools 4,616 2,910 0.42 0.41 -0.01 0.29 0.28 -0.02 0.46 0.44 -0.02 0.55 0.53 -0.02 0.59 0.59 0.00 0.62 0.62 0.01 42.46 56.11 1.32
egit/egit 4,587 4,028 0.35 0.36 0.01 0.23 0.23 -0.01 0.33 0.33 0.00 0.40 0.41 0.01 0.51 0.56 0.05 0.64 0.67 0.03 98.74 140.66 1.42
platform/eclipse.platform.ui 4,083 2,486 0.26 0.23 -0.03 0.15 0.12 -0.03 0.25 0.21 -0.04 0.32 0.27 -0.04 0.40 0.36 -0.04 0.50 0.48 -0.02 117.53 145.60 1.24
Total (Eclipse top 5) 23,012 17,396 0.34 0.34 0.00 0.24 0.22 -0.01 0.35 0.43 -0.01 0.42 0.41 -0.01 0.49 0.50 0.01 0.56 0.57 0.01 68.67 96.15 1.40
Total (Eclipse top 20) 55,620 36,795 0.37 0.37 0.00 0.25 0.24 -0.01 0.38 0.37 0.00 0.46 0.46 0.00 0.55 0.55 0.01 0.62 0.63 0.01 103.37 122.57 1.19
Total (Eclipse top 20 + 
OpenStack top 20)80,799 61,092 0.30 0.30 0.01 0.20 0.19 -0.01 0.30 0.30 0.00 0.37 0.37 0.01 0.43 0.45 0.02 0.49 0.53 0.04 83.63 149.97 2.45
a given file in the commit. The common part of the two algorithms
is their context and input data.
Below we use the notation F∈Cto denote that the commit C
affectsthefile F,i.e.,thefileis modified init.Bothalgorithmstry
to predict the change to the file Fcurrentin the current commit
Ccurrent.
Inthefirstalgorithm(“single-file” ),weinfertheassociationrules
fromthecommitsthataffectedthisfileinthepast: {C:Ciaffects
Fcurrent}.
In the second algorithm (“other-files” ) we infer the rules from
thecommits thataffectedevery oftheother filesin thecommit C:
{C:Ciaffects Fk,Fk∈{F:Fi∈Ccurrent}\{Fcurrent}}
We evaluate both algorithms and compare their performance
depending on the type of file histories in use: first-parent or full.
Intuitively, a full history contains more information about past
changes, which allows one to infer more association rules, someof which are more likely to match the current change. However,
sinceweareinterestedindifferencebetweenthetwomethodsof
file history mining in terms of their capability to provide informa-
tion to inferthe association rules from pastchanges (quantitative
difference is explored by RQ1), we make adjustments to account
for the difference in sizes of the two histories: (1) We only include
the predictions where the histories are different (otherwise they
performequally);(2)Wetrimthefullhistorytothesizeofthefirst-
parent history, taking the most recent commits into account (to
inferrulesfromthesamenumberofcommits);(3)Wesorttherules
bysupportand trim the larger ruleset to match size with smaller
(to account for the possible difference in the number of rules).
Inaddition,tobringthealgorithmclosertoapracticalapproach,
weonlygeneratethepredictionswhenthefollowing(empirically
derived)criteriaaremet:(i)Wedonotconsiderlargecommitswithmorethan10changeswheninferingtherules(theyrarelyrepresent
meaningful changes); (ii) We only execute the algorithm when thesmaller of two histories contains at least 5 commits (otherwisethe history is too trivial to learn meaningful rules from); (iii) Weuse at most 100 most recent commits from the history to infer
therules (tocapturethe currentstateoflogical couplingbetween
files); (iv)We useat most 10rules with the highest support values
(recommendationlistsarefiniteandsmallinpracticalcontexts).We
useanopensourceimplementation[ 8]oftheApriorialgorithm[ 17]
to infer the association rules. A formal definition of the concept of
an association rule is available in literature [68].
Imitatingareal-lifecontextofrecommendationofchanges,we
derive a recommendation set from the set of rules as a union ofall one-item sets of headsof the rules, bodiesof which are fully
contained among the other files changed in the commit C.
Weusearandomsampleof10projectsfromeachofApacheand
Eclipse ecosystems for evaluation. We select these projects to alignthesamplewiththesampleusedfordefectprediction(Section 5.3.1),
for which the choice of target systems is restricted by the issue
tracker in use.
5.2.2 Results. Table3presentstheresultsofevaluationofchange
recommendation. An “event” corresponds to a single case when
association rules have been successfully generated using both first-
parentandfullhistories.Insomeevents,noneoftherulesmatchthe
setofchangesinthecommit,sonorecommendationscanbepro-
duced.RateofsucheventsispresentedinthelastcolumnofTable 3.
The setup and the algoritms are described in detail in Section 5.2.1.
In the context of this study, we are interested in comparing the
performanceoffullandfirst-parenthistoriesastheinputdatafor
each of the two algorithms.
The “other files” algorithm, which uses histories of the other
filesinthecommittoproducetheassociationrules,producesmore
eventsandgeneratesmorerecommendationsonsampledreposi-
tories from both Apache and Eclipse. However, only under 20% of
209
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. Mining File Histories: Should We Consider Branches? ASE ’18, September 3–7, 2018, Montpellier, France
Table3:Comparisonofperformancemetricsforchangerec-
ommendation, by mining approach and ecosystem
Apache
AlgorithmHistory 
typeEvents 
countRecommendations 
(average)Rules 
(average)Success 
rateFailure 
rateNo 
prediction 
rate
Single ﬁleFull 8780 0.908 8.848 0.496 0.029 0.474
First parent 8780 0.858 8.848 0.474 0.031 0.496
Other ﬁlesFull 19072 1.565 8.003 0.184 0.528 0.288
First parent 19072 1.485 8.003 0.170 0.527 0.303
Eclipse 
AlgorithmHistory 
typeEvents 
countRecommendations 
(average)Rules 
(average)Success 
rateFailure 
rateNo 
prediction 
rate
Single ﬁleFull 2721 0.772 7.922 0.491 0.016 0.493
First parent 2721 0.729 7.922 0.483 0.016 0.501
Other ﬁlesFull 6661 1.324 7.540 0.163 0.514 0.323
First parent 6661 1.299 7.540 0.152 0.526 0.322
Table 4: Comparison of performance metrics for defect pre-
diction, by mining approach and ecosystem
Precision Recall F-Measure AUC-ROC
Project (Apache)% 
Defectsﬁrst 
parentfull deltaﬁrst 
parentfull deltaﬁrst 
parentfull deltaﬁrst 
parentfull delta
calcite 42 0.57 0.57 0.00 0.65 0.65 0.00 0.61 0.61 0.00 0.66 0.67 0.01
falcon 55 0.61 0.63 0.02 0.63 0.63 0.00 0.62 0.63 0.01 0.63 0.74 0.11
james 41 0.48 0.49 0.01 0.55 0.58 0.03 0.51 0.58 0.07 0.55 0.60 0.00
lens 63 0.64 0.68 0.04 0.69 0.69 0.00 0.66 0.68 0.02 0.72 0.76 0.02
lucy-clownﬁsh 32 0.59 0.59 0.00 0.61 0.65 0.04 0.60 0.62 0.02 0.67 0.67 0.03
madlib 35 0.61 0.62 0.01 0.67 0.67 0.00 0.64 0.64 0.00 0.62 0.71 0.02
predictionio 44 0.37 0.44 0.07 0.48 0.56 0.08 0.42 0.49 0.07 0.51 0.59 0.02
qpid-proton 37 0.55 0.55 0.00 0.61 0.61 0.00 0.58 0.58 0.00 0.59 0.61 0.02
ranger 40 0.66 0.67 0.01 0.69 0.73 0.04 0.67 0.70 0.03 0.66 0.67 0.02
r
eef 33 0.60 0.61 0.01 0.62 0.62 0.00 0.61 0.61 0.00 0.72 0.74 0.01
Overall (Apache) - 0.58 0.60 0.02 0.64 0.67 0.03 0.62 0.65 0.03 0.64 0.66 0.02
Project (Eclipse)% 
Defectsﬁrst 
parentfull deltaﬁrst 
parentfull deltaﬁrst 
parentfull deltaﬁrst 
parentfull delta
acceleo 39 0.64 0.64 0.00 0.59 0.63 0.04 0.61 0.63 0.02 0.67 0.69 0.02
chemclipse 33 0.62 0.64 0.02 0.61 0.61 0.00 0.61 0.62 0.01 0.59 0.59 0.00
efxclipse 46 0.55 0.55 0.00 0.55 0.57 0.02 0.55 0.56 0.01 0.62 0.65 0.03
epp 53 0.72 0.74 0.02 0.57 0.62 0.05 0.64 0.67 0.03 0.67 0.68 0.01
hudson 44 0.61 0.64 0.03 0.73 0.73 0.00 0.66 0.68 0.02 0.63 0.68 0.05
platform.releng 32 0.66 0.66 0.00 0.58 0.58 0.00 0.62 0.62 0.00 0.64 0.64 0.00
recommenders 18 0.65 0.65 0.00 0.55 0.59 0.04 0.60 0.62 0.02 0.55 0.60 0.05
swtbot 24 0.60 0.60 0.00 0.58 0.59 0.01 0.60 0.60 0.00 0.60 0.60 0.00
tcf 31 0.68 0.69 0.01 0.72 0.72 0.00 0.70 0.70 0.00 0.70 0.75 0.05
downloads 35 0.73 0.76 0.03 0.55 0.58 0.03 0.63 0.66 0.03 0.69 0.74 0.05
Overall (Eclipse) - 0.66 0.69 0.03 0.59 0.63 0.04 0.63 0.66 0.03 0.64 0.67 0.03
Overall (Apache + 
Eclipse)- 0.65 0.67 0.02 0.61 0.61 0.00 0.63 0.66 0.03 0.61 0.65 0.04
these recommendationsare successful.The “single file”algorithm,
using rules inferred from the history of a single file, generates
less recommendations, of which around a half are successful. The
fullhistoriesperformslightlybetterastheinputdataforbothal-
gorithms in both ecosystems: depending on the ecosystem and
algorithm, they yield5–8 %m o r er e commendations, which are 2 –
8% more likely to be successful (i.e., to match an actual change).
5.3 Defect Prediction
5.3.1 Methodology. Thelastapplicationaimsatrecommending
developers the files that are more likely to contain defects [39].
Inourstudy,wetakeintoaccounttheBasicCodeChangeModel
(BCCM)predictionmodeldevisedbyHassan[ 41],whichisbasedontheentropy ofchangesappliedbydevelopersin acertaintime
windowandiscomputedexploitingtheconceptofShannonentropy
[55].WeconsiderthemodelbyHassan[ 41]ratherthanmorerecent
ones(e.g.,[ 36])since(i)weareonlyinterestedinmodelsrelyingon
changehistoryinformation,thuswecannotconsidermodelsbased
onproductmetrics[ 24]and(ii)BCCMperformssimilarlytoothers
proposed in literature, thus still being representative of the field
[39].Ourconjectureisthatthequantificationoftheentropymay
be more precise when considering the full history of files rather
than the single-parent case.
We perform a replication of the study by Hassan [ 41], consid-
eringtheBCCM.Itsplitsthechangehistoryofasoftwareproject
intothree-monthtimeperiods,andadoptsathree-monthsliding
windowtotrainandtestaLogisticRegressionclassifier(thatis,the
one adopted in the original study byHassan [ 41]). In other words,
starting from the beginning of the history, it computes the entropy
ofchangesonthefilesavailableinatimewindowandusessuchdata to train a classifier that predicts the defectiveness of files in
thesubsequenttimewindow.Theprocessisthenrepeateduntilthe
endofthehistory.Giventhenatureofthemodel,weevaluateits
performance in the two scenarios, i.e., single-parent vs full, by con-
sideringthemeanF-MeasureandAUC-ROC[ 21]achievedwhen
run on each time window.
Inthiscase,weruntheexperimentover20randomlysampled
systemsbelongingtotheApacheandEclipseecosystemsconsidered
in the study (their names are reported in the online appendix [ 11]).
We do so because, to extract actual defects composing the ground
truthonwhichcomparetheresultsofthemodelagainst,werelyona issue tracker mining tool based on BugZilla [
1], and therefore we
limitthisstudytotheecosystemsthatuseit.Ourgroundtruthis
representedbypost-releasedefectsmarkedassolvedbydevelopers
on the issue tracker. As such, we consider as defective all thosefiles that have encountered a problem in a certain time window,
according to the timestamp of the bug report.
5.3.2 Results. Table4reports the results achieved when con-
sidering the problem of predicting defects using the BCCM model
defined by Hassan [ 41] in case of single-parent or full history con-
figuration. Overall, the delta between the two approaches is not
largeforanyoftheevaluationmetricsconsidered.Forinstance,the
F-Measure is only 3% higher in both Apache and Eclipse, respec-
tively.Thus,inafirstglancewecanclaimthatconsideringbranches
does not improve the defect prediction performance. Nevertheless,
finerobservationsrevealtwoaspectsthatitisworthtohighlight.In
the first place, the model built using the single-parent strategy has
alwaysperformance equal or lower than the one that considers the
full history: thus, taking into account the full set of changes is not
detrimental inthecaseofdefectprediction.Conversely,thefullhis-
tory approach provides benefits in 65% and 80% of the cases when
considering F-Measure and AUC-ROC, respectively, meaning that
defectpredictionperformancecangenerallygainwhenconsidering
allthechangesratherthanasubsetofthem.Itisinterestingtonote
thedifferencesarehigherwhenconsideringtheAUC-ROC,i.e.,the
evaluation metric suggested by previous work [ 30,33] to evaluate
defect prediction models: specifically, it is up to 11% higher (on the
repositoryoftheApacheFalconproject),showingthatconsideringthefullhistoryoffilescanprovidestrongimprovements.Therefore,
210
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Vladimir Kovalenko, Fabio Palomba, and Alberto Bacchelli
basedonourfindings,wecanfinallyclaimthattakingthewhole
historyintoaccountwhenbuildinghistory-baseddefectprediction
models might provide important benefits in terms of performance.
6 LIMITATIONS AND THREATS TO VALIDITY
A number of limitations affect the results of our study, and pose
potential threats to its validity.
(1)Whendesigningtheexperimentstocompareperformance,
we tried to follow the original approaches as closely as pos-
sible, but it was not always possible completely (e.g. with
changeprediction),thusresultsontheoriginalapproaches
may differ.
(2)While we used a diverse population of projects from four
independentecosystems,itisnotclearwhetherandhowour
results can be generalized further.
(3)Ouranalysisincludedanextensivetechnicalwork,although
wetesteditcarefullyandunderseveralscenarios,wecannot
guaranteethatcodeisbug-free.However,wemakethecode
available in the online appendix [11].
7 DISCUSSION AND IMPLICATIONS
7.1 Discussion
Ourresultshighlightseveralimportantaspectsregardingthechoice
of the mining strategy.
Thetechnicaldetailsofminingcansignificantlyimpactthe
quantitative properties of the retrieved data. In case of our
study, such properties are the sizes of file histories and numbers of
contributors:Inover2millionfilesfromourcompositesampleof
four ecosystems, the resulting histories differ for 19% of files.
The size of the difference varies across projects and ecosys-
tems.In OpenStack projects, the first-parent and full histories are
differentfor55%offiles,whileinEclipseprojectsweobservethe
difference for only 14% of files.
Thesizeofthedifferenceisassociatedwithotherproperties
of a repository. In our case, the ecosystem with the highest dif-
ference (i.e., OpenStack) also demonstrates the highest merging
activity, most of which can be attributed to code review: after asuccessful code review in OpenStack, changes are merged back
into the trunk by a bot. Thus, high proportion of merges and their
impactonfilehistoriescanbeconsideredaconsequenceoftheirdevelopment workflow – namely, code review. Notably, while a
similarworkflowwithcodereviewsperformedwithGerritisalso
present in Eclipse, this ecosystem displays the lowest degree of
difference:changesinEclipsearetypicallyrebased,butnotmerged,
aftercodereview.Theimpactofthisparticularfactorontheresults
of repository mining deserves a deeper analysis in future work.
Thedifferenceinresultsofminingcaninfluencetheperfor-
manceoftechniquesbasedonfilehistories:reviewerrecom-
mendation,changerecommendation,anddefectprediction.
Forallofthetestedapproaches,fullhistories,whenusedasinput
data, perform at least not worse than first-parent histories, in most
cases yielding a slight increase in performance.
Someapplicationsaremoresensitivetoqualityofinputdata
thanothers. Inourcase,forreviewerrecommendationinOpen-
Stack full histories provide better accuracy, especially when longerrecommendation lists are evaluated (top-5 and top-10 accuracy).
OpenStack also happens to be the ecosystem where the difference
between the first-parent and full histories is the highest. At the
sametime,Eclipseprojectsshowthesmallestdifferencebetween
the first-parent and full histories among all four target ecosystems,
and this small difference appears insufficient to influence accuracy
of reviewer recommendation.
7.2 Implications
Consideringthepointsabove,weseeseveralimportantimplications
of our results.
(1)Software engineering researchers should be aware ofthepossibleimpactoftheminingtechniqueonthere-sults.
Ourstudydemonstratesthatomittingchangesoutside
the main branch during mining of file histories significantly
impactstheresultsofmining,whichoftenleadstoaslight
decrease in performance of methods that use file histories
as input data.
(2)The choice of the mining technique should accountfor the context of the mining task.
Whileusingfullfile
historiesensuresabetterperformance,inmostcasesthedif-
ference is only marginal. In many contexts, a small increase
inperformancemaynotjustifydedicatingtheextraeffortto
moreprecisemining.Whilewesuggestusingprecisemin-
ing methods where possible—and provide a tool for doing
that—in many contexts it is not essential.
(3)Researchersshouldreportthetechnicaldetailsofmin-ing.
Wesuggestthattechniquesofrepositoryminingshould
be described in more detail by authors of MSR studies, asnot providing details complicates reproducibility of stud-
ies, and oversimplifying the mining potentially undermines
performance of methods and validity of studies.
8 CONCLUSION
Withthestudypresentedinthispaper,wemakethefollowingmain
contributions:
•Thefirstdemonstrationoftheimportanceofcarefulhandlingofmergecommitsandchangesfromoutsidethemainbranch
for calculation of file histories;
•Analysisofimpactofastrategyofminingfilehistorieson
performanceofthreetechniquesrelyingonthemasinput
data;
•AtoolforefficientminingofprecisefilehistoriesinGit[ 11].
Ourresultscovertheunderrepresentedtopicoftechnicaldetails
of mining the repositories for file histories, and open opportunitiesfordeeperanalysisofassociatedfactors,suchastopologyofchange
histories. We hope that this study will inspire other researchersin MSR to apply a more detailed approach to mining, where it isfeasible, and to report the technical details of mining to ensure
clarity and reproducibility of the studies.
ACKNOWLEDGMENTS
A. Bacchelli and F. Palomba gratefully acknowledge the support of
the SNF Project No. PP00P2_170529.
211
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. Mining File Histories: Should We Consider Branches? ASE ’18, September 3–7, 2018, Montpellier, France
REFERENCES
[1] Bugzilla. https://www.bugzilla.org/. Accessed: 2018-04-26.
[2]Eclipse-theeclipsefoundationopensourcecommunitywebsite. https://www.
eclipse.org/. Accessed: 2018-04-16.
[3] Eclipse code review. https://git.eclipse.org/r/. Accessed: 2018-04-16.
[4] Gerrit code review. https://www.gerritcodereview.com/. Accessed: 2018-04-16.
[5]git - find all the direct descendants of a given commit. https://stackoverflow.
com/questions/27960605/find-all-the-direct-descendants-of-a-given-commit#
27962018. Accessed: 2018-04-24.
[6]git-log(1)manualpage. https://mirrors.edge.kernel.org/pub/software/scm/git/
docs/git-log.html. Accessed: 2018-04-24.
[7] Github. https://github.com. Accessed: 2018-04-22.
[8]A java implementation of the apriori algorithm for finding frequent item sets
and (optionally) generating association rules. https://github.com/michael-rapp/
Apriori/. Accessed: 2018-04-22.
[9] Jgit.https://www.eclipse.org/jgit/. Accessed: 2018-04-09.
[10]Lkml: Linus torvalds: Re: git mv (was re: [git pull] acpi & suspend patches for
2.6.29-rc0). https://lkml.org/lkml/2009/1/9/323. Accessed: 2018-04-24.
[11]Mining File Histories: Should We Consider Branches? - Online Appendix. https:
//github.com/vovak/branches. Accessed: 2018-07-24.
[12]Open source software for creating private and public clouds. https://www.
openstack.org/. Accessed: 2018-04-16.
[13] Openstack code review. https://review.openstack.org/. Accessed: 2018-04-16.
[14]Quora Statistics. https://www.quora.com/
What-are-the-most-popular-distributed-version-control-systems. Accessed:
2018-04-22.
[15] Upsource. https://www.jetbrains.com/upsource/. Accessed: 2018-04-22.
[16]Whysqlitedoesnotusegit. https://sqlite.org/whynotgit.html. Accessed:2018-
04-18.
[17] R. Agrawal et al. Fast algorithms for mining association rules.
[18]M.Aniche,G.Bavota,C.Treude,M.A.Gerosa,andA.vanDeursen. Codesmells
formodel-view-controllerarchitectures. EmpiricalSoftwareEngineering,pages
1–37, 2017.
[19]B.Appleton,S.Berczuk,R.Cabrera,andR.Orenstein. Streamedlines:Branching
patterns for parallel software development. 1998.
[20]A. Bacchelli, M. Lanza, and R. Robbes. Linking e-mails and source code arti-
facts. InProceedings of the 32Nd ACM/IEEE International Conference on Software
Engineering-Volume 1, pages 375–384. ACM, 2010.
[21]R. Baeza-Yates, B. Ribeiro-Neto, et al. Modern information retrieval, volume 463.
ACM press New York, 1999.
[22]V. Balachandran. Reducing human effort and improving quality in peer code re-
viewsusingautomaticstaticanalysisandreviewerrecommendation. In Software
Engineering(ICSE),201335thInternationalConferenceon,pages931–940.IEEE,
2013.
[23]E. T. Barr, C. Bird, P. C. Rigby, A. Hindle, D. M. German, and P. Devanbu. Co-
hesiveandisolateddevelopmentwithbranches. In InternationalConferenceon
Fundamental Approaches to Software Engineering, pages 316–331. Springer, 2012.
[24]V. R. Basili, L. C. Briand, and W. L. Melo. A validation of object-oriented de-sign metrics as quality indicators. IEEE Transactions on software engineering,
22(10):751–761, 1996.
[25]R. M. Bell, T. J. Ostrand, and E. J. Weyuker. The limited impact of individual
developer data on software defect prediction. Empirical Software Engineering,
18(3):478–505, 2013.
[26]M. Beller, A. Bacchelli, A. Zaidman, and E. Juergens. Modern code reviews in
open-source projects: Which problems do they fix? In Proceedings of the 11th
working conference on mining software repositories, pages 202–211. ACM, 2014.
[27]C.Bird,P.C.Rigby,E.T.Barr,D.J.Hamilton,D.M.German,andP.Devanbu. The
promises and perils of mining git. In Mining Software Repositories, 2009. MSR’09.
6th IEEE International Working Conference on, pages 1–10. IEEE, 2009.
[28]C. Bird and T. Zimmermann. Assessing the value of branches with what-if
analysis. In Proceedingsof theACM SIGSOFT20th InternationalSymposium on
the Foundations of Software Engineering, page 45. ACM, 2012.
[29]C. Bird, T. Zimmermann, and A. Teterev. A theory of branches as goals and
virtual teams. In Proceedings of the 4th International Workshop on Cooperative
and Human Aspects of Software Engineering, pages 53–56. ACM, 2011.
[30]D.Bowes,T.Hall,andD.Gray. Comparingtheperformanceoffaultprediction
modelswhichreportmultipleperformancemeasures:recomputingtheconfusion
matrix. In Proceedings of the 8th International Conference on Predictive Models in
Software Engineering, pages 109–118. ACM, 2012.
[31]C. Brindescu, M. Codoban, S. Shmarkatiuk, and D. Dig. How do centralized and
distributed version control systems impact software changes? In Proceedings of
the 36th International Conference on Software Engineering, pages 322–333. ACM,2014.
[32]
J. Buffenbarger and K. Gruell. A branching/merging strtegy for parallel softwaredevelopment. In InternationalSymposiumonSoftwareConfigurationManagement,
pages 86–99. Springer, 1999.[33]C.Catal. Performanceevaluationmetricsforsoftwarefaultpredictionstudies.
Acta Polytechnica Hungarica, 9(4):193–206, 2012.
[34]G. Catolino, F. Palomba, A. De Lucia, F. Ferrucci, and A. Zaidman. Developer-related factors in change prediction: an empirical assessment. In Proceedings
ofthe25thInternationalConferenceonProgramComprehension,pages186–195.
IEEE Press, 2017.
[35]M. D’Ambros, M. Lanza, and R. Robbes. An extensive comparison of bug predic-
tionapproaches. In MiningSoftwareRepositories(MSR),20107thIEEEWorking
Conference on, pages 31–41. IEEE, 2010.
[36]D. Di Nucci, F. Palomba, G. De Rosa, G. Bavota, R. Oliveto, and A. De Lucia.
A developer centered bug prediction model. IEEE Transactions on Software
Engineering, 44(1):5–24, 2018.
[37]G. Gousios. The ghtorrent dataset and tool suite. In Proceedings of the 10th
Working Conference on Mining Software Repositories, MSR ’13, pages 233–236,
Piscataway, NJ, USA, 2013. IEEE Press.
[38]M.Greiler,K.Herzig,andJ.Czerwonka. Codeownershipandsoftwarequality:
a replication study. In Proceedings of the 12th Working Conference on Mining
Software Repositories, pages 2–12. IEEE Press, 2015.
[39]T.Hall,S.Beecham,D.Bowes,D.Gray,andS.Counsell. Asystematicliteraturere-
viewonfaultpredictionperformanceinsoftwareengineering. IEEETransactions
on Software Engineering, 38(6):1276–1304, 2012.
[40]A.E.Hassan. Theroadaheadforminingsoftwarerepositories. In Frontiersof
Software Maintenance, 2008. FoSM 2008., pages 48–57. IEEE, 2008.
[41]A.E.Hassan. Predictingfaultsusingthecomplexityofcodechanges. In Software
Engineering, 2009. ICSE 2009. IEEE 31st International Conference on, pages 78–88.IEEE, 2009.
[42]
L.HattoriandM.Lanza.Miningthehistoryofsynchronouschangestorefinecode
ownership. In Mining Software Repositories, 2009. MSR’09. 6th IEEE International
Working Conference on, pages 141–150. IEEE, 2009.
[43]H. Kagdi, M. L. Collard, and J. I. Maletic. A survey and taxonomy of approaches
for mining software repositories in the context of software evolution. Journal of
Software: Evolution and Process, 19(2):77–131, 2007.
[44]D. Kawrykow and M. P. Robillard. Non-essential changes in version histories. In
Proceedingsofthe33rdInternationalConferenceonSoftwareEngineering,pages
351–360. ACM, 2011.
[45]E. Kocaguneli, T. Menzies, and J. W. Keung. On the value of ensemble effort
estimation. IEEE Transactions on Software Engineering, 38(6):1403–1416, 2012.
[46]J. Loeliger and M. McCullough. Version Control with Git: Powerful tools and
techniques for collaborative software development. " O’Reilly Media, Inc.", 2012.
[47]T.Menzies,Z.Milton,B.Turhan,B.Cukic,Y.Jiang,andA.Bener.Defectpredictionfromstaticcodefeatures:currentresults,limitations,newapproaches. Automated
Software Engineering, 17(4):375–407, 2010.
[48]H.M.Michaud,D.T.Guarnera,M.L.Collard,andJ.I.Maletic. Recoveringcommitbranchoforiginfromgithubrepositories. In SoftwareMaintenanceandEvolution
(ICSME), 2016 IEEE International Conference on, pages 290–300. IEEE, 2016.
[49]A.Mockus. Amassingandindexingalargesampleofversioncontrolsystems:
Towardsthecensusofpublicsourcecodehistory. In MiningSoftwareRepositories,
2009.MSR’09.6thIEEEInternationalWorkingConferenceon,pages11–20.IEEE,
2009.
[50]N. Nachar et al. The mann-whitney u: A test for assessing whether two indepen-
dent samples come from the same distribution. Tutorials in Quantitative Methods
for Psychology, 4(1):13–20, 2008.
[51]M.Nagappan,T.Zimmermann,andC.Bird. Diversityinsoftwareengineering
research. In Proceedings of the 2013 9th Joint Meeting on Foundations of Software
Engineering, pages 466–476. ACM, 2013.
[52]F. Palomba, A. Panichella, A. Zaidman, R. Oliveto, and A. De Lucia. The scent of
asmell:Anextensivecomparisonbetweentextualandstructuralsmells. IEEE
Transactions on Software Engineering, 2017.
[53]F. Palomba, M. Zanoni, F. A. Fontana, A. De Lucia, and R. Oliveto. Toward a
smell-awarebugpredictionmodel. IEEETransactionsonSoftwareEngineering,
2017.
[54]M.M.Rahman,C.K.Roy,andJ.A.Collins. Correct:codereviewerrecommen-
dation in github based on cross-project and technology experience. In Software
EngineeringCompanion(ICSE-C),IEEE/ACMInternationalConferenceon,pages
222–231. IEEE, 2016.
[55]C. E. Shannon. A mathematical theory of communication. ACM SIGMOBILE
Mobile Computing and Communications Review, 5(1):3–55, 2001.
[56]E. Shihab, C. Bird, and T. Zimmermann. The effect of branching strategies onsoftware quality. In Proceedings of the ACM-IEEE international symposium on
Empirical software engineering and measurement, pages 301–310. ACM, 2012.
[57] D. Spinellis. Git. IEEE software, 29(3):100–101, 2012.
[58]S. W. Thomas. Mining software repositories using topic models. In Proceedings
of the 33rd International Conference on Software Engineering, pages 1138–1139.
ACM, 2011.
[59] P. Thongtanunam,R.G. Kula,A.E.C. Cruz,N.Yoshida, andH.Iida. Improving
code review effectiveness through reviewer recommendations. In Proceedings
of the 7th International Workshop on Cooperative and Human Aspects of Software
Engineering, pages 119–122. ACM, 2014.
212
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Vladimir Kovalenko, Fabio Palomba, and Alberto Bacchelli
[60]P. Thongtanunam,S. McIntosh,A. E.Hassan, andH. Iida. Revisitingcode own-
ership and its relationship with software quality in the scope of modern code
review. In Proceedingsofthe38thinternationalconferenceonsoftwareengineering,
pages 1039–1050. ACM, 2016.
[61]P. Thongtanunam, C. Tantithamthavorn, R. G. Kula, N. Yoshida, H. Iida, and K.-i.
Matsumoto. Whoshouldreviewmycode?afilelocation-basedcode-reviewer
recommendationapproachformoderncodereview. In SoftwareAnalysis,Evo-
lution and Reengineering (SANER), 2015 IEEE 22nd International Conference on,
pages 141–150. IEEE, 2015.
[62]M. Tufano, F. Palomba, G. Bavota, M. Di Penta, R. Oliveto, A. De Lucia, and
D. Poshyvanyk. An empirical investigation into the nature of test smells. In
Proceedingsofthe31stIEEE/ACMInternationalConferenceonAutomatedSoftware
Engineering, pages 4–15. ACM, 2016.
[63]M. Tufano, F. Palomba, G. Bavota, M. Di Penta, R. Oliveto, A. De Lucia, and
D. Poshyvanyk. There and back again: Can you compile that snapshot? Journal
of Software: Evolution and Process, 29(4), 2017.[64]M. Tufano, F. Palomba, G. Bavota, R. Oliveto, M. Di Penta, A. De Lucia, and
D. Poshyvanyk. When and why your code starts to smell bad (and whether the
smellsgoaway). IEEETransactionsonSoftwareEngineering,43(11):1063–1088,
2017.
[65]B. Turhan, T. Menzies, A. B. Bener, and J. Di Stefano. On the relative value
of cross-company and within-company data for defect prediction. Empirical
Software Engineering, 14(5):540–578, 2009.
[66]E. M. Voorhees et al. The trec-8 question answering track report. In Trec,
volume 99, pages 77–82, 1999.
[67]A.T. Ying,G.C. Murphy,R.Ng, andM.C. Chu-Carroll. Predicting sourcecode
changes by mining change history. IEEE transactions on Software Engineering,
30(9):574–586, 2004.
[68]T.Zimmermann,A.Zeller,P.Weissgerber,andS.Diehl. Miningversionhistories
to guide software changes. IEEE Transactions on Software Engineering, 31(6):429–
445, 2005.
213
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. 