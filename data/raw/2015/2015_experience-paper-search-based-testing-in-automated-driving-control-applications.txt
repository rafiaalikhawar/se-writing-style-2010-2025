Experience Paper: Search-based Testing in
Automated Driving Control Applications
Christoph Gladisch∗, Thomas Heinz∗, Christian Heinzemann∗,
Jens Oehlerking∗, Anne von Vietinghoff∗‡, Tim Pﬁtzer†
∗Robert Bosch GmbH, Corporate Research, 71272 Renningen, Germany
†Robert Bosch Automotive Steering GmbH, 73527 Schw ¨abisch Gm ¨und, Germany
ﬁrstname.lastname@de.bosch.com,‡anne.vonvietinghoff@de.bosch.com
Abstract —Automated test generation and evaluation in sim-
ulation environments is a key technology for veriﬁcation of
automated driving (AD) applications. Search-based testing (SBT)
is an approach for automated test generation that leverages
optimization to efﬁciently generate interesting concrete tests from
abstract test descriptions. In this experience paper, we report on
our observations after successfully applying SBT to AD control
applications in several use cases with different characteristics.
Based on our experiences, we derive a number of lessons learned
that we consider important for the adoption of SBT methods
and tools in industrial settings. The key lesson is that SBT ﬁnds
relevant errors and provides valuable feedback to the developers,
but requires tool support for writing speciﬁcations.
Index T erms —search-based testing, automated driving, auto-
mated test generation, experience paper
I. I NTRODUCTION
Automated driving (AD) applications aim at taking the
driving responsibility from the human driver [1]. As a con-
sequence, these systems have high safety and performance
demands meaning that they must not pose a safety threat
to their environment and that they should not obstruct the
surrounding trafﬁc. Both of these issues demand thorough
testing of the AD software under a variety of trafﬁc scenarios.
To this end, virtualized software testing in simulated worlds is
a key technology to achieve fast feedback during development
and to support safety arguments for the systems [2]. The
complexity of the (simulated) environment and the number
of scenarios to be tested necessitate the use of automated test
generation and evaluation techniques.
Typically, AD applications have functional blocks that con-
ceptually follow a sense-plan-act architecture [3, Chap. 8]
as illustrated in Figure 1a.1In this architecture, the sensors
provide (raw) information from the physical environment, e.g.,
based on cameras, lidars, and inertia sensors. The Sense com-
ponent translates this information into a model of the vehicle’s
environment. The Plan component decides on a maneuver to
be taken given the current environment, e.g., stay in lane or
change lane, which is then realized by the Actcomponent. The
Actcomponent typically contains several (cascaded) feedback-
control algorithms that control the vehicle’s actuators and close
the loop to the physical environment [4].
1Please note that real architectures are much more complex, but always
contain the basic elements of Sense ,Plan , and Act.Testing an AD application monolithically is infeasible be-
cause of the high dimensionality of the test space. There-
fore, testing demands a careful decomposition of the testing
problem into smaller test problems that can be addressed
individually. In this paper, we are concerned with testing the
Actcomponent of the AD application, which results in the
simulation setup shown in Figure 1b. To obtain this setup, we
assume the following decomposition on the AD application.
We separate testing of the Sense component from testing
the Plan and Act[2], [5]. To this end, we use ground truth
from the simulator as a replacement for the Sense component.
We further decompose the behavior of the Plan component
into equivalence classes on the planner’s decisions, where
each equivalence class is represented by a so-called logical
scenario [6] in which the same behavior is expected by the
Actcomponent, i.e., by the software under test. An example
for a logical scenario could be following a preceding vehicle
in its lane on a highway with 3 lanes with a low speed vehicle
cutting into the AD vehicle’s lane.
For testing the correct behavior of the Actcomponent, the
logical scenarios must be instantiated into concrete scenar-
ios [6] in a particular simulation framework. Thus, each con-
crete scenario results in one closed-loop simulation run (test)
in the simulation framework. Executing the simulation for the
given concrete scenario particularly requires to stimulate the
software and its surrounding system under test with concrete
values for the different parameters of the logical scenario.
In our example above, this includes parameters like vehicle
speeds, initial distances between vehicles, the timing of a cut-
in, or the gradient of the road. Due to their physical nature,
these parameters are real-valued, thus rendering the resulting
test space inﬁnitely large. In this paper, we are concerned with
the question of how to efﬁciently generate concrete scenarios
from a given logical scenario. Instead of using random testing
or ﬁxed gridding of the parameters of the logical parameters,
we use search-based testing.
Search-based testing (SBT) [7]–[9] is a method for au-
tomated test generation based on optimization using meta-
heuristics. The basic idea of SBT is using a quantitative metric
(a ﬁtness function) that describes how well a requirement is
satisﬁed and employing an optimizer that utilizes this metric
to automatically generate interesting tests for the software
under test. The optimizer tries to ﬁnd parameter valuations
262019 34th IEEE/ACM International Conference on Automated Software Engineering (ASE)
978-1-7281-2508-4/19/$31.00 ©2019 IEEE
DOI 10.1109/ASE.2019.00013
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:08:56 UTC from IEEE Xplore.  Restrictions apply. Sense
SoftwarePlan Act
Sensors
Physical environmentActuators
(a) High level architecture of a system for automated drivingSoftware under test
Equivalence Class
of Plan
Environment Model (Scenario + Physics)
System under testActGround
truth
(b) Simulation setup for Actcomponent
Fig. 1: System architecture and simulation setup
that minimize the quantitative metric, which in turn is a worst
case for the system under test. We use an instance of SBT that
particularly supports continuous parameter spaces by using
optimization algorithms such as Bayesian optimization [10].
In this experience paper, we report our observations of
applying SBT in the context of AD applications for generating
concrete scenarios from logical scenarios or, in other words,
for testing the control aspects of an AD application (cf. Sec-
tion II). While SBT achieved impressive results in academic
papers that show the usefulness of the technique [11]–[15], it is
not yet widely adopted in the automotive industry. We discuss
the application of SBT to three different logical scenarios
of an AD software on a highway (cf. Section III): adaptive
cruise control, lane keeping under adversarial environment
conditions, and steering control. Based on these successful
applications of SBT, we report our lessons learned and the
impediments we faced with respect to the tool framework
and speciﬁcation (cf. Section IV). These lessons learned are
not speciﬁc for a particular implementation but focus on the
general use and criteria for acceptance of SBT as a method in
the AD domain.
Key results of our study are (i) SBT effectively ﬁnds
relevant errors in AD applications, (ii) user acceptance depends
on seamless integration into existing tool chains and actionable
feedback from test results, and (iii) good support for writing
and debugging speciﬁcations is essential.
II. S EARCH -BASED TESTING
Figure 2 shows the setup of the SBT framework. A test
task is an informal description consisting of a logical scenario
and a speciﬁcation (cf. Sec. I). The speciﬁcation is formalized
into an executable monitor (STL monitor) and the logical
scenario is implemented as an input signal generator. The input
signal generator, system under test (SUT), and monitor are
composed into a simulation on which test are executed. The
test generation is driven by an optimizer which tries to ﬁnd
test inputs to SUT to minimize the SUT’s performance w.r.t.
the speciﬁcation, i.e. as computed by the STL monitors. The
output format of the optimizer is a low-dimensional vector of
real values, in the following referred to as parameters . The
input signal generator maps these parameters onto a concrete
scenario and technically interfaces the SUT.System
under
test
OptimizerInput
signal
generator
select
parameter
valuesSTL
monitors
Simulation
derive scalar
robustness from
monitor signalsTest taskLogical 
ScenarioSpecification
Fig. 2: Search-based testing framework
The techniques for search-based testing that we used in
our case studies are based on falsiﬁcation tools such as
Breach [16] and S-TaLiRo [17]. These tools allow the user to
provide closed-loop speciﬁcations in Signal Temporal Logic
(STL) [18] or Metric Temporal Logic (MTL) [19], respec-
tively. These logics are an extension of Linear Temporal Logic
towards continuous-time and real-valued signals, see [20]
for an extensive survey. Moreover, they come with a robust
semantics2, which is real-valued instead of Boolean and quan-
tiﬁes the degree of speciﬁcation satisfaction or violation for
a given signal. Falsiﬁcation tools use these values to drive
an optimization loop so that new tests are generated which
lead to challenging tests for the system. There is also a large
body of work in SBT with handcrafted performance metrics
that are not based on logics (for instance [21], [22]), focusing
on the search aspect. For our experiments, we concentrate on
temporal logic based techniques.
In this paper, we use the Boolean operators ∧(and),∨
(or),¬(not), and ⇒(implies, if-then), and predicates such
as=(equality), and ≤(less or equal). Temporal logic ex-
tends Boolean logic with the temporal operator ϕUψ and its
instances /squareϕand♦ϕ, which evaluate any formulas ϕ,ψ over
2Also called quantitative semantics .
27
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:08:56 UTC from IEEE Xplore.  Restrictions apply. a time sequence, e.g. a signal from a simulation. ϕUψ is true
iffϕis true at each time step until ψbecomes true, /squareϕis
true iffϕis always true, and ♦ϕis true iff ϕis true at least
once when evaluating ϕ. Operators with subscripts /square[a,b]ϕor
♦[a,b]ϕevaluateϕon a subinterval [a+t,b+t]relative to
the current evaluation time t. Bothaandbmay be negative,
allowing for temporal operators that refer to both future and
past relative to t. Temporal operators can be arbitrarily nested
with Boolean operators.
Under Boolean semantics the predicates and Boolean and
temporal operators evaluate to true or false. Under robust
semantics the predicates and operators evaluate to real values
such that positive values indicate a degree of a formula being
true and negative values indicate the degree of false [19].
Under robust semantics, the operators of STL are semantically
deﬁned as follows (see [20]):
/llbracket/latticetop/rrbracket(μ,t):=∞ (1)
/llbracketx≥c/rrbracket(μ,t):=μx(t)−c (2)
/llbracket¬ϕ/rrbracket(μ,t):=−/llbracketϕ/rrbracket(μ,t) (3)
/llbracketϕ1∨ϕ2/rrbracket(μ,t):=m a x{/llbracketϕ1/rrbracket(μ,t),/llbracketϕ2/rrbracket(μ,t)} (4)
/llbracketϕ1U[a,b]ϕ2/rrbracket(μ,t):=s u p
t/prime∈(t+a,t+b)(min{/llbracketϕ2/rrbracket(μ,t/prime),
inf
t/prime/prime∈(t+a,t/prime)(/llbracketϕ1/rrbracket(μ,t/prime/prime))})(5)
/llbracketϕ1S[a,b]ϕ2/rrbracket(μ,t):=s u p
t/prime∈(t+a,t+b)(min{/llbracketϕ2/rrbracket(μ,t/prime),
inf
t/prime/prime∈(t/prime,t+b)(/llbracketϕ1/rrbracket(μ,t/prime/prime))})(6)
Particularly, comparison of a signal xto a bound is
implemented as the difference of the signal to the bound.
For example, the formula x≥3is evaluated under robust
semantics as the value of x(t)−3for all t.
In addition, we may deﬁne the operators ♦[a,b]ϕ=/latticetopU[a,b]ϕ
and/square[a,b]ϕ=¬♦[a,b]¬ϕas usual. As an intuition, ♦[a,b]
returns the maximum robustness of the subformula over the
speciﬁed time interval, wheras /square[a,b]returns the minimum.
We chose to not use any of the frameworks from academia
directly but developed our own speciﬁc implementation tar-
geted at the speciﬁc needs of AD applications. In particular,
formalized functional speciﬁcations are not currently the state
of the art in the automotive industry, which means that such
a framework must provide means to debug speciﬁcations and
also speciﬁcation patterns for the common cases. Furthermore,
tool chains for software development and simulation are
already highly complex such that it is imperative to create
as little tool overhead as possible.
To best adapt our implementation to the needs of the
automotive industry, we made the following initial design
decisions:
•We implemented temporal logic monitors as online ﬁlters
that run alongside the simulation. This was driven by
the assumption that speciﬁcations are usually of the form
/squareφ, whereφis a potentially complex temporal formula.
In order to make formula and system debugging easier,
we chose to implement φ(and all its subformulas) asonline ﬁlters, so that the resulting robustness signals can
be examined. The top-level /square-operator is then dealt with
by simply taking the minimum robustness over all times.
The result is a framework that is similar in spirit to
streaming languages [23]. Also, this approach enables
early termination of (often costly) simulations, and the
on-the-ﬂy creation of test inputs.
•We kept the implementation independent of the sim-
ulation tool, by building a C++ library with the core
algorithms than can be interfaced from different tools.
•We did not restrict the framework to temporal logic op-
erators to leave the possibility open for custom operators
whenever needed.
•For the tools we used, we created a tight tool integration.
For example, for Matlab, the ﬁlters are included in
Simulink via S-Functions.
•We did not build our own optimizers but used off-the
shelf optimizers provided by Matlab [24], e.g., Bayesian
optimization [10], [25], to allow for customization to the
speciﬁc SBT problem at hand.
III. I NDUSTRIAL CASE STUDIES
In this section, we describe three selected case studies in
an industrial AD setting: adaptive cruise control (ACC, Sec-
tion III-A), lane keeping (Section III-B), and steering control
(Section III-C). These case studies were done in cooperation
with different development teams from different business units
with diverse mindsets and engineering cultures.
A. Adaptive Cruise Control
Scenario Description: The ﬁrst case study is an adaptive
cruise controller (ACC) for highway situations. This controller
is active when the planner decides to stay in the current lane,
potentially following a vehicle ahead. The overall task is to
keep a safe distance to other vehicles whenever possible. This
includes so-called cut-ins, i.e., lane changes of other vehicles
in front of the ego vehicle, which can occur at potentially
unsafe distances. If there are no other vehicles in front, then
a set speed should be respected, which may be a combination
of passenger input via a human-machine-interface, speed limit
information from the perception, etc.
Therefore, the goal of the controller is to either
ACC1: respect a velocity-dependent distance to the preceding
vehicle in the same lane
ACC2: respect a set speed in absence of a preceding vehicle
(or when it is far away)
The speciﬁcation of this system is primarily deﬁned on phys-
ical quantities, such as velocity and position, necessitating a
closed-loop test. Therefore, the test setup includes not only
the controller itself but also a physical simulation of the ego
vehicle and relevant other vehicles (in this case using the
commercial tool IPG CarMaker [26]).
The ACC software that we used was in an early stage
of development and therefore, we expected to ﬁnd some
speciﬁcation violations using this method.
28
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:08:56 UTC from IEEE Xplore.  Restrictions apply. Test Setup: In general, there are speciﬁcations for the
modes of operation ACC1 and ACC2, as well as transitions in
between. Each of these corresponds to a number of different
logical scenarios to be tested with SBT.
In the following, we explain three speciﬁc logical scenarios
for the ACC functionality which represent different trafﬁc
conﬁgurations. Each conﬁguration maps to a speciﬁc SBT
problem. All scenarios have in common that the real-valued
test parameters are situated in the physical environment:
instead of varying input into the system under test directly, we
vary parameters in the simulation of the physical environment
to create a range of situations the system under test should
react to, and then monitor the closed-loop response. The input
signal generator for this case study maps these parameters onto
a signal description ﬁle for IPG CarMaker.
Speciﬁcation 1: The ﬁrst logical scenario involves a
speciﬁcation for a transition from ACC2 to ACC1 where the
ego vehicle either approaches another vehicle or a cut-in by
another vehicle occurs while the ego vehicle is in set speed
control. We assume that there are no other vehicles in this
scenario. Two parameters are varied for this logical scenario:
the initial velocities of the two vehicles. The initial distance is
set to a ﬁxed (large) amount. The preceding vehicle is assumed
to have constant velocity.
In natural language, the speciﬁcation can be expressed as
follows: Whenever we detect another vehicle in front of us,
and this vehicle has been the preceding vehicle for at least T
seconds, we expect the distance dto this vehicle to stay within
a corridor of /epsilon1around the desired distance ddes.
The desired distance ddesis computed relative to the ve-
locity of the ego vehicle as faster speeds require larger safety
corridors.
The formalization of the speciﬁcation in STL is as follows:
/square(vehicleDetected =⇒
((♦[−T,0]newVehicle )∨|d−ddes(v)|≤/epsilon1))(7)
Here, vehicleDetected is a Boolean ﬂag signifying whether
there is a vehicle in front of and in the same lane as the
ego vehicle within sensor range. newVehicle is an event
that indicates whether there is a new vehicle in front of
the ego vehicle, either because there was a cut-in or be-
cause the ego approached a vehicle from behind that was
outside sensor range. The distance to the preceding vehicle
is denoted by d(∞if there is none), and ddes(v)is the
velocity-dependent desired distance. In the simulation the
event newVehicle is triggered if there is a negative jump on
the distance to the preceding vehicle from one sample to the
next: newVehicle (t)⇔d(tprev)−d(t)>δ.
Inside the outer box operator, the speciﬁcation only uses
past-time STL (i.e., all temporal operators only refer to time
intervals that lie in the past). This subformula can be moni-
tored online using robust semantics. The value of the entire
speciﬁcation, i.e., the box operator applied to the past-time
formula, is the minimum of the monitor signal evaluating the
past-time formula. This yields the scalar robustness value forthe entire formula, which is then used by an optimizer to select
a new test aiming at minimizing this value.
However, in contrast to the past-time formula above, the
informal textual requirements that already exist in practice (in
tools such as DOORS [27]) are often in future form:
Whenever we detect another vehicle in front of us, the
distancedto this vehicle shall reach a corridor of /epsilon1around
the desired distance ddes withinTseconds and shall remain
within this corridor .
One way to make these monitorable online is to select
a ﬁxed future lookahead S. This way the formula can be
monitored online with a delay of S. One realization of such
a formula would be:
/square((newVehicle ∧(/square[0,S]vehicleDetected )) =⇒
(/square[T,S]|d−ddes(v)|≤/epsilon1))(8)
This formula is not equivalent to the past-time formula (7)
above because it requires vehicleDetected to stay true for the
entireS-interval. This is to point out that there are generally
different formalizations of existing informal requirements that
reﬂect its intention. One lesson learned while conducting these
experiments was that speciﬁcations using combined past- and
future-time temporal logic are generally easier to understand
and to write correctly for engineers. While the formula above
is not particularly complex in past form, this is not true for
many other formulas. We will give some more examples of
this later in this section, and also discuss future versus past
operators in Section IV-G.
Test Results: Figure 3 shows the test results for the case
when the ego vehicle drives up to the preceding vehicle. A
total 50 tests were generated for this logical scenario using
the robust semantics of the past-time formula (7) given above
and a Bayesian optimizer, with each single test taking roughly
5 minutes. It should be noted that the evaluation times for the
online monitors added less than 30 seconds to the simulation
time. The time used for generating the Gaussian regression
model for the Bayesian optimizer was negligible compared to
the simulation time.
The two-dimensional test space was sampled using opti-
mization with the goal of minimizing the robustness of the
temporal logic formula deﬁned above. The x-axis is the initial
velocity of the ego vehicle, the y-axis is the constant velocity
of the preceding vehicle and the z-axis is the robustness value,
with negative values signifying failed tests. In order to avoid
interpolation artifacts, the plot uses V oronoi interpolation, i.e.,
each ”plateau” represents a single test and consists of all
points for which no other test exists that is closer in Euclidean
distance. For the part of the input space where the ego vehicle
is slower than the preceding vehicle, no tests are generated.
In this case, the distance between the two vehicles increases,
and thus the preceding vehicle would never be detected. The
failed tests were caused by a problem in the trajectory planning
algorithm that resulted in a too slow convergence to the desired
distance.
29
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:08:56 UTC from IEEE Xplore.  Restrictions apply. LQLWLDOYHORFLW\HJRYHKLFOHPD[YHORFLW\SUHFHGLQJYHKLFOH
PLQPD[5REXVWQHVV
PLQ
PLQPD[
Fig. 3: Test results for transition from speed control to distance
control of adaptive cruise control (Speciﬁcation (7))
As can be seen, even in such a simple test setup, the ro-
bustness surface not monotonic or convex, and the worst case
can not be found by simple boundary value testing. Further
experiments in other setups for the speciﬁcations that follow
also conﬁrm this. Some of the issues encountered are ”hidden
switches” for different discrete modes of operation. These
could be ﬁxed by separating them into separate scenarios with
different speciﬁcations. In addition, we also found controller
errors that only occurred in small areas of the parameter space.
As the system under test was in an early stage of de-
velopment, this is not surprising. In fact, the quantitative
robustness was conﬁrmed to be more valuable than simple
pass-fail information by engineers, since the physical model
is not a perfect model of reality and since the choice of control
parameters for the system under test was not ﬁnal.
Speciﬁcation 2: One speciﬁcation that we tested for case
ACC2 (set speed control without a preceding vehicle) is given
in the following. It describes the reaction to a change in
preferred set speed by the passenger (using controls inside
the cabin) or the recognized speed limit signs:
Whenever the set speed vsetis increased, the actual velocity
vshall have passed 90 percent of the jump height Δjump
vsetafter
Tseconds, and analogously for decreases in set speed.
To formalize this, we need to save the jump height Δvsetof
the last jump as Δjump
vsetin order to refer to it at a later time.
The STL formula is:
/square(Δvset>0=⇒♦[0,T](vset−v≤0.1Δjump
vset))
∧/square(Δvset<0=⇒♦[0,T](vset−v≥0.1Δjump
vset)) (9)
Note that this also is a future-time speciﬁcation and it would
be rather cumbersome to formalize it as a past-time formula.
Speciﬁcation 3: Another scenario of importance is the
cut-in while we are already following another vehicle. This
scenario involves three vehicles: the ego vehicle, the vehicle
that the ego originally followed and the vehicle performing
the cut-in (see Figure 4 for an illustration):Whenever we detect another vehicle in front of us, we shall
respect a velocity-dependent safe minimum distance dsafe(v)
as long as the cut-in was far enough away to allow this.
d >= d min, cutIn
Fig. 4: Cut-in while following another vehicle
We chose the following future-time STL formula:
/square((newVehicle ∧/square[0,T]vehicleDetected ∧
d>d min,cutIn (v)) =⇒(/square[0,T]d≥dsafe(v))) (10)
If the cut-in is very close to the ego vehicle (closer than
dmin,cutIn (v)), the precondition of this speciﬁcation is not met
as the ego cannot decelerate fast enough to avoid a distance
violation. This would then be an unavoidable accident, where,
instead of ACC, the system would switch to a function that
minimizes the collision impact, with its own set of speciﬁca-
tions.
While the complexity of this speciﬁcation is still limited,
the difﬁculty in this scenario lies in the fact that we now have
to orchestrate three vehicles to drive in a prescribed manner.
In particular, we need to parameterize the relative position
and velocity of the cut-in vehicle when changing lanes. This
requires complex scenario setups with synchronization of the
behavior of the simulated agents.
In fact, here the speciﬁcation can be seen as including
an idealized dynamical model of the ego vehicle’s braking
capabilities. On an abstract level, the intention behind the
speciﬁcations is something along the lines of ”If it is physically
possible to obey the safe distance, then I should do it”, with
the braking capabilities of the ego vehicle being encoded in
a velocity-dependent threshold dmin,cutIn (v). The underlying
more general pattern is that AD speciﬁcations often contain
predicted states of the world. In other words, we could
also write d>d min,cutIn (v))in a more general form as
∀t>0:dpred(t)>0, wheredpred(t)is the predicted distance
wrt. some predictive model of the vehicles at time tin the
future. This is a common pattern in AD applications, which
is reﬂected in the use of quantities such as time-to-collision,
time-to-brake, etc. [28], in the speciﬁcations.
B. Lane Keeping
Scenario Description: This case study deals with an
automated vehicle’s ability of staying within a lane in chal-
lenging conditions by steering and/or braking. In particular,
we consider longitudinal and lateral road slopes, wind, and
the curvature of the road, which in combination might result
in a vehicle to leaving its designated driving lane.
Test Setup: Simulation setup and interface of the system
under test with its environment are identical to the adaptive
cruise control case. However, for the scenario considered here,
30
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:08:56 UTC from IEEE Xplore.  Restrictions apply. there is no preceding vehicle. Instead, road parameters are
varied, in particular curvature and slope (both in longitudinal
and lateral direction), as well as angle and velocity of a
constant wind affecting the vehicle, the distribution of the
vehicle’s mass and the set velocity of the vehicle, resulting in a
six-dimensional test space. The road is modeled as a straight
segment followed by a curve with constant curvature to the
left [29].
Speciﬁcation: Informally, the requirement is:
The vehicle shall stay within the lane boundaries, if this is
possible with the actuators it is equipped with.
Formally, the speciﬁcation is
/square(τ>=τmax∨vehicle⊆corridor), (11)
whereτis the current lateral wheel torque and τmax is
the maximum lateral wheel torque the vehicle is capable of
delivering. The larger the lateral wheel torque, the tighter is
the resulting curve driven by the vehicle, i.e. the maximum
lateral wheel torque available determines the tightest drivable
curve. Determining whether the vehicle is inside the corridor
is a geometric operation that computes whether the vehicle’s
bounding box is completely enclosed in the lane, which
is described by polynomial constraints. According to this
speciﬁcation, it is only allowed to leave the corridor if the
maximum lateral wheel torque is applied, i.e., if the vehicle
physically has no chance of staying in the lane. For the
robustness computation this necessitates distance computation
between the road boundary and the vehicle bounding box. In
case there is no physical possibility to stay in the lane (e.g.
due to extreme winds), a mitigation function is activated with
a separate set of requirements.
Test Results: Again, the results are obtained by employing
robust semantics of STL and Bayesian optimization on the six-
dimensional test space [29]. We ran 1450 tests, with each test
taking roughly 3 minutes due to the high-ﬁdelity simulation
of the car physics.
Figure 5 shows a scatter plot of the test results projected
to three dimensions: longitudinal gradient, wind velocity, and
ego vehicle set velocity. Red triangles signify failed tests and
green circles successful tests. The distribution of failed tests
shows two clusters: one at a low velocity range and one at a
high velocity range. The ﬁrst cluster of failed tests is caused by
a switching behavior of the system under test. It turned itself
off as the vehicle was too slow, i.e., the design domain of the
lane keeping function is left. This illustrates an important point
for these kinds of test setups: failed tests mean that there is a
mismatch between speciﬁcation and closed-loop model. Failed
tests can either be caused by the actual software under test,
the environment model or the speciﬁcation. In case of lane
keeping, low speeds should be excluded in the speciﬁcation,
as these are covered by a different software function with its
own set of speciﬁcations. The second cluster represents a set
of tests where it is not physically possible to stay in the lane
but nevertheless the ego vehicle did not apply maximum wheel
torque. This can either be framed as a problem of the system
under test or the speciﬁcation (because it may be impossible tomaxmin
min
grade in %
velocity in km/hwindVelocity in km/hmax
min max
Fig. 5: Test results for lane keeping function (Speciﬁca-
tion (11))
achieve this theoretical maximum braking torque under some
conditions).
C. Steering Control
Scenario Description: The third case study is concerned
with a low level controller of the steering system. The goal of
the controller is to track the desired position of the steering
rack which essentially deﬁnes the orientation of the front
wheels with respect to the vehicle chassis. It does so by
computing a motor torque output signal that is applied to an
electric motor in order to move the rack to the desired rack
position. The actual rack position and its time derivative, the
rack speed, are fed back into the controller.
Figure 6 depicts the test setup for the steering controller.
plant model 
(vehicle model + 
steering mechanics)
Admissible 
rack position
corridor Motor 
torque
Desired 
rack 
positionSteering
ControllerRack position
Rack speed
Lower bound for rack position
Upper bound for rack position
++_
_Monitor 1
Monitor 2Rack position
MonitorsSystem under test
Fig. 6: Test setup for steering controller
Speciﬁcation: The speciﬁcation that the implementation
must adhere to is a typical example for a tracking controller:
F or any desired rack position trajectory rdes(t)such that
the desired rack position remains within +/−rmax and the
desired rack speed vdes(t)remains within +/−vmax, the actual
rack position r(t)shall remain within a corridor [rl(t),ru(t)]
around the desired rack position rdes(t).
31
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:08:56 UTC from IEEE Xplore.  Restrictions apply. In temporal logic, this speciﬁcation can be expressed as
follows:
(/square(|rdes(t)|≤rmax∧|vdes(t)|≤vmax))
=⇒(/square(rl(t)≤r(t)∧r(t)≤ru(t))) (12)
Test Setup: To obtain a tractable SBT problem, families
of signal forms are assumed that can be characterized by few
parameters. One particular choice is the following:
rdes(t)=p1sin/parenleftbiggp2
p1·t/parenrightbigg
. (13)
The desired rack speed vdes(t)equals the time derivate of the
desired rack position rdes(t). It follows to:
vdes(t)=drdes(t)
dt=p2cos/parenleftbiggp2
p1·t/parenrightbigg
. (14)
This renders |p1|the amplitude of the desired rack position
and|p2|the amplitude of the desired rack speed. Thus, the
limitations on the desired rack position and its time derivative
can be expressed as a constraint on the parameters p1and
p2. Therefore, the precondition of Speciﬁcation (12) can
be satisﬁed constructively by generating only feasible input
signals. As a consequence, only the postcondition
/square(rl(t)≤r(t)∧r(t)≤ru(t)) (15)
has to be monitored. Figure 6 depicts two postcondition
monitor signals, where Monitor 1 represents the lower bound
constraint rl(t)≤r(t)and Monitor 2 the upper bound
constraint r(t)≤ru(t). Alternatively, the postcondition can
be expressed as a conjunction of Monitor 1 and Monitor 2.
Test Results: The controller was tested in an early devel-
opment phase. It was well known that the speciﬁcation is not
satisﬁed for all feasible parameter values. Thus, rather than a
single failed test, it was of interest to obtain an overview of
the degree of speciﬁcation satisfaction for the entire parameter
space. In particular, regions where speciﬁcation satisfaction
changes abruptly shall be identiﬁed.
Again, the results are obtained by employing robust seman-
tics of STL and Bayesian optimization on the two-dimensional
test space. We ran 500 tests. A single simulation of the
system under test took approximately 3 seconds. The overall
optimization took 2 hours and 27 minutes, i.e. for this case
study, the main execution time was consumed by the Bayesian
optimizer. Due to the short simulation time for the system
under test, a swarm-based optimization algorithm would also
have been a meaningful choice.
Figure 7 shows a V oronoi plot of the test results for Mon-
itor 2. As for the ﬁrst case study III-A, the two-dimensional
test space was sampled by minimizing the robustness of the
speciﬁcation. The x-axis depicts the amplitude of the desired
rack position (parameter p1in Eq. (13)), the y-axis represents
the amplitude of the desired rack speed (parameter p2in
Eq. (14)), and the z-axis shows the robustness value where
negative values are depicted in red and indicate speciﬁcation
violations. As the robustness decreases, the degree of violation
PLQ5REPD[5RE
5REXVWQHVV
PLQ6SHHG
PD[6SHHGUDFN6SHHG$PSOLWXGHPLQ3RV
PD[3RVUDFN3RV$PSOLWXGH
Fig. 7: Test results for steering controller (Speciﬁcation (15),
upper bound constraint): 3D V oronoi plot
PD[6SHHG
UDFN6SHHG$PSOLWXGH
PLQ6SHHG
UDFN3RV$PSOLWXGHPLQ3RV PD[3RV
Fig. 8: Test results for steering controller (Speciﬁcation (15),
upper bound constraint): 2D scatter plot
grows. Figure 8 shows a two-dimensional scatter plot of the
same tests. Each test result is depicted as a point. Again, the
color indicates the degree of satisfaction (green circles) or
violation (red triangles) of the speciﬁcation.
Both plots provide some indication that speciﬁcation satis-
faction mostly depends on the amplitude of the desired rack
speed. Moreover, the degree of violation (absolute value of the
negative robustness) signiﬁcantly increases in a small range of
desired rack position amplitudes.
IV . D ISCUSSION
In the following, we discuss our lessons learned from the
three successful applications of SBT discussed in Section III
and, in particular, the impediments for applying SBT in the
industrial setting. Our lessons learned fall in two categories:
lessons with respect to an SBT framework (Subsection IV-A
to IV-D) and lessons regarding creation of (formal) speciﬁca-
tions (Subsections IV-E to IV-H). When it comes to (formal)
32
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:08:56 UTC from IEEE Xplore.  Restrictions apply. speciﬁcation and their implementation in monitors, issues and
lessons are often subtle and therefore need to be discussed in
more technical detail.
A. SBT works in practice
The most important lesson we learned is that SBT actually
works well in the industrial setting for control systems and
speciﬁcations, i.e., SBT actually ﬁnds relevant errors in these
kinds of systems. In general, we found three kinds of errors
as discussed in Section III-B). First, we found errors in the
software under test, which are the ones we are actually looking
for. Results for the use cases we analyzed are provided in
Section III. Second, we found errors in the models of the
physical environment that are used for simulation. These errors
often relate to physical effects that the software is sensitive
to but that were not correctly implemented in the physics
models. Third, we found errors in the speciﬁcations where the
requirement did not specify what was intended. We discuss this
point in more detail in Section IV-G. In general, the ability of
ﬁnding errors and the possibility of visualizing the test results
in 2D and 3D plots, which provide useful information beyond
pass/fail results that also gives hints on the cause of the error.
This lead to high acceptance of the method for engineers.
In general, the black box optimizers used in SBT do not
scale to arbitrary dimensionality of the input space. Here, the
second most important lesson we learned is that in all the use
cases we saw to date, we were able to scale SBT to the size
of the problem. From the case studies reported in Section III,
the lane keeping had the largest input space with 6 inputs.
Apart from these, we also ran SBT problems not reported in
this paper with up to 9D input spaces that could be handled
without issues. Making it scale for the general AD use case,
however, requires a proper decomposition of the overall testing
problem into appropriately sized logical scenarios.
•Lesson 1 : Consider an iterative approach by analyzing
the tests created so far in order to identify and remove
parameters from the input space that the software under
test is not sensitive to.
B. Bring SBT to the users
All the case studies reported in Section III involved Matlab
either as a development or simulation tool. This is not a
coincidence but a result from integrating our implementation
into Matlab/Simulink [30] (cf. Section II). In other settings,
e.g., pure C++ and Python based test environments based on
ROS [31], the Matlab-based SBT tooling is perceived as yet
another tool with low acceptance. As a consequence, our SBT
tooling was not used in these settings due to a lack of tool
integration. In order to overcome such problems, the SBT
tooling requires multiple front-ends for integrating seamlessly
into the workﬂows and the tooling of the users. In particular,
since it turned out that SBT has a strong beneﬁt when used
in early development phases (this is the case for all three
case studies), integration into the development environment
turned out to be crucial, so that SBT can be used alongside
the development with minimal overhead.This motivated our custom implementation and design.
In particular, our framework has a core C++ library which
can be customized with front ends that are based on data-
ﬂow semantics (e.g. Matlab/Simulink), and front ends for
programming languages in form of language bindings via
APIs, e.g., for C++ or Python.
•Lesson 2 : Seamless integration into existing tools and
workﬂows is essential for acceptance among users.
C. Robustness landscapes look like mountain ranges
The results presented in Section III show that the robustness
landscapes for our applications are non-convex and poten-
tially non-smooth due to switches in the software under test,
which we expected. In particular, they contain a number
of local minima and, in some cases, also plateaus. In such
cases, local optimization approaches like Hill Climbing get
either frequently stuck or degenerate to random walks on
the plateau [32]. Instead, global optimization algorithms like
Bayesian Optimization yielded much better results in our use
cases.
In early phases of the development, the landscape as such
is more interesting for the developer as the actual minimum
as it is the case for the ACC use case. In these phases, the
models are often only rough approximations of reality and
information from the landscapes gives helpful insights to the
users. Plotting such landscapes, however, is a problem on its
own for input spaces with more than three parameters as they
can’t be plotted entirely. Instead, we have to plot projections
to 2D or 3D with the difﬁculty that multiple X-D samples
may get projected to the same 2D or 3D point in the plot.
To this end, explicit support for such projections was highly
appreciated by the users. For the optimization algorithms this
means that there should be a way to controlling the tradeoff
between quickly ﬁnding failing tests and covering the test
space (leading to hybrid objective functions as those described
in [33]), which again makes Bayesian Optimization a good
candidate. Swarm-based optimizers could also be used, but
seemed less promising for many systems due to the high
computational cost of a single simulation.
•Lesson 3 : Global optimization is essential due to non-
convex landscapes. See also [9], [32].
•Lesson 4 : Support 2D and 3D projections of higher
dimensional robustness landscapes for inspection of the
test results.
•Lesson 5 : Visualization of (projected) robustness land-
scapes is an important asset.
D. Simulation is costly
The simulations for the ACC and lane keeping scenarios are
costly as they involve multiple tools (Matlab Simulink [30],
IPG CarMaker) and complex vehicle simulation models in
a co-simulation. As a result, simulation runs with real-time
factors down to 10%, i.e., 1 minute of simulation time takes
10 minutes to simulate. As a consequence, we had better
experience with approaches like Bayesian Optimization that
require only few simulation runs compared to other approaches
33
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:08:56 UTC from IEEE Xplore.  Restrictions apply. like genetic algorithms. Evaluation of more than one speciﬁca-
tion on a single simulation run is also important even though
typically only one at a time can be used for optimization.
The high simulation times also imply that the performance
of monitoring is not the most important concern, but for
acceptance it is mandatory that monitoring must not slow
down the simulation. In our case, we were able to scale the
monitoring for the formulas we presented such that it had no
impact on simulation time (up to 60,000 simulation samples
in formula scope).
Furthermore, it is desirable to support early termination of
the simulation. In particular, we may terminate the simulation
in case the ﬁnal robustness value of the speciﬁcation can no
longer change during the remainder of the simulation. Whether
this is the case, however, depends on the scenario being used
and the speciﬁcations being checked. As an example consider
Property 9 for the ACC use case. If the scenario involves
only one change of the set speed, then the ﬁnal robustness
is determined once the 90% of the jump height have been
reached and the simulation can be terminated. Depending on
the set bound on the simulation time, this might signiﬁcantly
increase performance.
•Lesson 6 : Support sample-efﬁcient optimizers as com-
putation resources are always limited. For high-ﬁdelity
simulations with long simulation times, Bayesian opti-
mization worked fairly well.
•Lesson 7 : Consider parallelization of SBT from the start
(see for example [34], [35]).
•Lesson 8 : Performance is not the most important concern
for the monitoring (compared to e.g. usability) but make
sure that it does not slow down simulation.
•Lesson 9 : Enable the initialization of (Bayesian) opti-
mization problems from a set of existing test runs.
E. Temporal logics are not enough
We started in our applications by favoring STL-based speci-
ﬁcations for deﬁning the metrics for SBT as it is also available
in S-TaLiRo and Breach. While temporal logics such as STL
are highly suitable for many kinds of speciﬁcations, there
exists a non-negligible set of (sub-)speciﬁcations that cannot
be expressed in temporal logic or where using a temporal logic
is overly complicated.
In the steering control use case, the speciﬁcation demands
that the actual rack position remains in a corridor around the
desired rack position. The upper and lower bound that deﬁne
the corridor can be expressed as outputs of a dynamical system
that takes the desired rack position as input. This cannot be
expressed by an STL formula, i.e., it is not possible to express
the postcondition in STL using only the desired and actual rack
position as signals. However, when calculating the upper and
lower bound signals in the model as shown in Figure 6, the
STL speciﬁcation is simple.
In the ACC use case, we face a T90 property (cf. Prop-
erty 9), which is quite common for these kinds of systems.
For such a property, we require a so-called step detector that
detects an instant change in a signal’s value resulting from adiscrete event. In our example, the event is a new set speed
being provided. Apart from detecting the step, we also need to
store the step height, i.e., the difference of the value before and
after the jump. Without storing the step height, we wouldn’t
be able to evaluate whether 90% of the jump height have
been eventually reached until the deadline T. Storing the jump
height requires a memory element, which is usually realized
as a freeze operator in extensions of STL like STL* [36].
However, these extensions are quite complicated to apply in
their full form as most users are no trained experts in formal
logics. In addition, we observed that a full freeze operator
implementation was not necessary in any of the use cases
we have observed in industrial practice to date. Instead, we
realized a simpliﬁed freeze operator that takes a condition and
a value and always returns the value from the last point in time
where the condition was satisﬁed. While this does not give us
the full expressive power of the freeze operator from STL*, we
found this to be sufﬁcient for the use cases we encountered.
A second observation from the aforementioned T90 property
is that a form of time robustness is necessary. The STL
formulas and plots in Section III are all based on so-called
space robustness as deﬁned through the robust semantics in
Equations (1)-(6), i.e., for the atomic propositions of the logic,
we compare signals to bounds at each point in time tand
calculate robustness values as the distance of the signal to
the bound. This means that signal values at different times
tcan not be related to each other when computing the
robustness. Instead, time robustness measures for each tand
each corresponding space robust or signal value how much
later this value is reached. As an example, consider the plot in
Fig. 9. The property checks whether x≥3at some point in
time between the current point in time tandt+2. Under space
robustness given by standard robust semantics, this formula
resolves to max t∈[0,2](3−x(t)), i.e., the distance of xto
the bound. Under time robustness, one would be interested in
min t(0 + 2−t|x(t)≥3), i.e., how much earlier (or later)
compared to the time bound the subformula becomes true.
Such an interpretation, however, introduces a different kind
of semantics of operators and formulas, see for example [37],
[38]. This, in turn, has a negative impact on the understandabil-
ity of the speciﬁcations by non-experts in temporal logics. In
our examples of T90 properties, the engineers are usually only
interested in how much early or late the controller reaches 90%
of the step height. More generally phrased, the engineers are
often only interested in the temporal difference of two discrete
events. This is a special case of a general time robustness that
can be understood and implemented much easier. Based on this
observation, we implemented this special case with a custom
operator in our framework. With this approach, time is treated
as yet another physical quantity and the resulting robustness
values seamlessly integrate with the remaining STL operators.
•Lesson 10 : Allow user-deﬁned, non-STL operators. This
includes custom signal preprocessing operators like a
simple freeze outside the logic to allow for ﬂexibility.
•Lesson 11 : Include time robustness in a simpliﬁed form
34
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:08:56 UTC from IEEE Xplore.  Restrictions apply. -1x
t1234
-21.0 5.0
F[0, 2](x 3)time robustness
space robustness
Fig. 9: Illustration of Space Robustness vs. Time Robustness
supporting exactly the use cases you have. The main use
case for time robustness is the time distance between two
events.
F . Simple speciﬁcations are often possible
The speciﬁcations that we provided in Section III are quite
simple in terms of the number of temporal operators being
used per speciﬁcation and the nesting depth of temporal
operators being less or equal to 2. This is not for sake of
simpliﬁcation, but representative for the complexity of indus-
trial requirements that we have faced so far in the automotive
domain.
Many speciﬁcations only have a very simple temporal
component like Property 11 or can be brought into such a form
as Property 15 by an appropriate input generation (cf. also
Section IV-H). Such invariant properties are quite common in
the AD domain, especially for spatial properties like staying
in a corridor, e.g., the lane in the lane keeping use case, or
keeping a minimum safety distance to all other objects, i.e.,
no other car or pedestrian must be hit by the AD vehicle.
A second kind of requirements that we have frequently seen
has the form
/square(precondition =⇒postcondition ).
Here, the precondition detects a particular event and the
postcondition deﬁnes the desired (temporal) response of the
software under test. A frequently recurring subset of speciﬁ-
cations in this category is given by the classical step response
properties. In such speciﬁcations, the precondition typically
detects a jump of a value, e.g., the provision of a new set
speed or the instantaneous reduction of the distance to the
preceding car resulting from a cut-in (cf. Properties 7, 9,
and 10). As postconditions, engineers frequently check for
T90 requirements (cf. Section IV-E and Property 9), settling
time requirements (i.e., the controlled quantity only deviates
from the desired value by a constant bound after a deadline),
or bounded overshoots (i.e., the controlled value does not
exceed the desired value by more than a deﬁned margin). Since
these kinds of speciﬁcation frequently occur, the framework
should ease the task of writing speciﬁcations by providing
a pattern library with the most frequent preconditions and
postconditions.
We found that more complicated requirements can often
be decomposed and expressed by multiple simpler monitors.In these cases, each of the simpler monitors typically turns
out to be invariants and/or the precondition/postcondition style
speciﬁcations discussed in the previous paragraph. As an
example, consider Property 9. An exception are speciﬁcations
that include a predictive part as mentioned at the end of
Section III-A, e.g., demanding that the vehicle has to master
a situation (e.g., the cut-in in Figure 4) if it is physically
possible to do so. Such properties are important to distinguish
errors in the system from impossible situations automatically3.
However, such parts of a speciﬁcation are also not expressed in
terms of temporal logic (cf. Section IV-E) but require dedicated
physical vehicle models.
•Lesson 12 : Provide support for pattern libraries and treat
patterns as ﬁrst level modeling entities in the framework.
This includes support for recurring domain speciﬁc parts
of speciﬁcations and / or the signal preprocessing (e.g.,
calculation of distances w.r.t. lanes from positions).
G. F ormal speciﬁcations (even simple ones) are difﬁcult to
write
At ﬁrst glance, this seems to be a contradiction to the
previous statement that real speciﬁcations have simple struc-
ture. However, that real speciﬁcations do not have a complex
structure, unfortunately does not imply that they are easy
to write. In general, temporal logic speciﬁcations are hard
to write from scratch, even for experienced developers and
experts in formal logics [39]. As a consequence, it is necessary
to debug speciﬁcations in order to see whether the result
of the evaluation matches the intent of the developer. This
requires access to intermediate results of all subformulas and
the signal preprocessing steps (e.g., the step detection or
corridor computation). Such a debugging facility is also of
great use when inspecting failing test runs for identifying the
root cause of the error.
As already discussed in Section III-A, the textual require-
ments that need to be formalized for SBT often have a future
form. Even though we have no empirical evidence, it is
easier for users to write down requirements in the form ”If
event A happens, the system shall react as follows and reach
condition Y after time T.” To ease formalization of the textual
requirements and to improve understandability, it is necessary
to allow both causal and acausal temporal formulas. Causal
formulas only refer to values in the past, whereas acausal
formulas also refer to values in the future. The downside of
using future formulas, however, is that online monitoring gets
much more complicated as the truth value at time tcan only
be computed at time t+Tand all intermediate values need to
be buffered. In addition, we are required to explicitly deﬁne
the upper bound Tfor each formula, which was, however, not
a problem in practice.
For the understandability, the unisono feedback from the
developers was that the robust semantics for STL must be
consistent with the Boolean interpretation of the formula for
3In fact, mitigation requirements have to be checked for the case that
collision is inevitable
35
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:08:56 UTC from IEEE Xplore.  Restrictions apply. all possible cases, i.e., any robust value must map to true
orfalse . This is done by distinguishing between positive and
negative values, but special handling of 0 is required in order
to not create an inconsistent logic. In particular, there needs to
be a way to distinguish strict and non-strict inequalities such
that any possible robustness value including 0 has a deﬁned
Boolean interpretation [20].
A frequent problem that we observed with the precondition
/ postcondition style speciﬁcations results from interpreting
the precondition under robust semantics. This may lead to
the circumstance that the optimizer ﬁnds that the minimum
robustness for the entire formula can be achieved by satisfying
the precondition as much as possible without considering the
postcondition. This, however, is obviously not useful as we are
particularly interested in the value of the postcondition. This
can be solved by interpreting the precondition under Boolean
semantics.
•Lesson 13 : Provide a modular evaluation approach with
visible intermediate evaluations. This demands a seman-
tically sound compositional construction and execution of
speciﬁcations and corresponding monitors.
•Lesson 14 : Support the possibility to specify acausal
formulas with time windows referring to future values.
•Lesson 15 : Allow Boolean interpretation of subformulas
especially for preconditions.
•Lesson 16 : Ensure consistency with Boolean semantics
for all possible cases.
H. Test setup affects speciﬁcation and search-space
As depicted in Figure 2, the speciﬁcation depends on the
input signal (output of the input signal generator) and the out-
put signal of the system under test. In some cases, e.g., for the
steering control use case, the precondition depends only on the
input signal which makes it possible to constructively satisfy
the precondition by designing a suitable input signal generator.
Thus, the precondition does not need to be monitored. Even if
the precondition depends on the output, designing a suitable
input signal generator may simplify the monitor signiﬁcantly.
Another design goal of the input signal generator is to restrict
the search space to render the optimization problem tractable.
A potential downside is that relevant behavior is not consid-
ered. Sometimes, it is not clear how to select parameterized
families of input signals. In such cases, a viable alternative is
to search over arbitrary input signals [40].
•Lesson 17 : Restricting the input space may lead to
simpler speciﬁcation monitors.
•Lesson 18 : The input signal generator deﬁnes the search
space. There is a tradeoff between tractability of the
optimization problem and restriction of the search space.
V. C ONCLUSION
In this paper, we presented three selected case studies from
the AD domain and evaluated the application of SBT on the
cases studies. The evaluation is based on our own SBT frame-
work inspired by S-TaLiRo and Breach. We discuss several
lessons that we learned during the case studies. Key lessonsare (i) that SBT works well in the industrial setting, (ii) that
provision of actionable feedback and seamless integration into
the developers’ tools are key to acceptance of the method, and
(iii) that good support for writing and debugging speciﬁcations
is essential as writing speciﬁcations is difﬁcult.
The results of this experience report shall help researchers
and practitioners to bring SBT into a widespread use in
industrial practice.
In addition to the reported lessons learned, future work
could focus on (i) online signal generation for identifying
challenging and arbitrarily shaped input signals for the soft-
ware under test [40], (ii) searching in the scenario space
for automatically constructing meaningful scenarios [41], and
(iii) ﬁnding arguments on when to stop testing in case no
falsifying runs are found [42], [43]. Despite promising initial
works, there are still many open questions, particularly in the
industrial setting.
ACKNOWLEDGMENT
We thank Monja Megger for conducting the Lane Keeping
case study [29].
REFERENCES
[1] Taxonomy and Deﬁnitions for Terms Related to Driving Automation
Systems for On-Road Motor V ehicles , SAE, Jun. 2018. [Online].
Available: https://doi.org/10.4271/J3016 201806
[2] Waymo, “On the road to fully self-driving – waymo safety report,” 2017.
[3] B. Siciliano and O. Khatib, Eds., Handbook of Robotics . Springer
Berlin Heidelberg, 2008.
[4] H. Winner, S. Hakuli, F. Lotz, and C. Singer, Eds., Handbook of Driver
Assistance Systems . Springer, 2016.
[5] A. C. Madrigal. (2017, Aug.) Inside waymo’s secret world
for training self-driving cars. The Atlantic. [Online]. Available:
https://www.theatlantic.com/amp/article/537648/
[6] T. Menzel, G. Bagschik, and M. Maurer, “Scenarios for development,
test and validation of automated vehicles,” in 2018 IEEE Intelligent
V ehicles Symposium (IV) , June 2018, pp. 1821–1827.
[7] W. Miller and D. L. Spooner, “Automatic generation of ﬂoating-point
test data,” IEEE Trans. Software Eng. , vol. 2, no. 3, pp. 223–226, 1976.
[8] P. McMinn, “Search-based software testing: Past, present and future,”
inProceedings of the 2011 IEEE F ourth International Conference on
Software Testing, V eriﬁcation and V alidation Workshops , ser. ICSTW
’11. Washington, DC, USA: IEEE Computer Society, 2011, pp. 153–
163.
[9] S. Ali, L. C. Briand, H. Hemmati, and R. K. Panesar-Walawege,
“A systematic review of the application and empirical investigation
of search-based test case generation,” IEEE Transactions on Software
Engineering , vol. 36, no. 6, pp. 742–762, Nov 2010.
[10] J. Mockus, Bayesian Approach to Global Optimization - Theory and
Applications . Kluwer Academic Publishers, 1989.
[11] C. E. Tuncali, T. P. Pavlic, and G. Fainekos, “Utilizing s-taliro as
an automatic test generation framework for autonomous vehicles,” in
2016 IEEE 19th International Conference on Intelligent Transportation
Systems (ITSC) , Nov 2016, pp. 1470–1475.
[12] J. V . Deshmukh, M. Horvat, X. Jin, R. Majumdar, and V . S. Prabhu,
“Testing cyber-physical systems through bayesian optimization,” ACM
Trans. Embedded Comput. Syst. , vol. 16, no. 5, pp. 170:1–170:18, 2017.
[13] F. Hauer, A. Pretschner, M. Schmitt, and M. Groetsch, “Industrial
evaluation of search-based test generation techniques for control sys-
tems,” in 2017 IEEE International Symposium on Software Reliability
Engineering Workshops (ISSREW) , Oct 2017, pp. 5–8.
[14] C. E. Tuncali, B. Hoxha, G. Ding, G. E. Fainekos, and S. Sankara-
narayanan, “Experience report: Application of falsiﬁcation methods on
the UxAS system,” in NASA F ormal Methods - 10th International
Symposium, NFM 2018, Newport News, VA, USA, April 17-19, 2018,
Proceedings , 2018, pp. 452–459.
36
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:08:56 UTC from IEEE Xplore.  Restrictions apply. [15] R. Matinnejad, S. Nejati, L. C. Briand, T. Bruckmann, and
C. Poull, “Search-based automated testing of continuous controllers:
Framework, tool support, and case studies,” Information & Software
Technology , vol. 57, pp. 705–722, 2015. [Online]. Available:
https://doi.org/10.1016/j.infsof.2014.05.007
[16] A. Donz ´e, “Breach, a toolbox for veriﬁcation and parameter synthesis
of hybrid systems,” in Computer Aided V eriﬁcation , ser. Lecture Notes
in Computer Science, T. Touili, B. Cook, and P. Jackson, Eds. Springer
Berlin Heidelberg, 2010, vol. 6174, pp. 167–170.
[17] Y . Annapureddy, C. Liu, G. Fainekos, and S. Sankaranarayanan, “S-
TaLiRo: A tool for temporal logic falsiﬁcation for hybrid systems,” in
Tools and Algorithms for the Construction and Analysis of Systems , ser.
Lecture Notes in Computer Science, P. A. Abdulla and K. R. M. Leino,
Eds. Springer Berlin Heidelberg, 2011, vol. 6605, pp. 254–257.
[18] A. Donz ´e and O. Maler, “Robust satisfaction of temporal logic over real-
valued signals,” in F ormal Modeling and Analysis of Timed Systems -
8th International Conference, FORMATS 2010, Klosterneuburg, Austria,
September 8-10, 2010. Proceedings , 2010, pp. 92–106.
[19] G. E. Fainekos and G. J. Pappas, “Robustness of temporal logic
speciﬁcations for continuous-time signals,” Theor . Comput. Sci. , vol.
410, no. 42, pp. 4262–4291, 2009.
[20] E. Bartocci, J. V . Deshmukh, A. Donz ´e, G. E. Fainekos, O. Maler,
D. Nickovic, and S. Sankaranarayanan, “Speciﬁcation-based monitoring
of cyber-physical systems: A survey on theory, tools and applications,”
inLectures on Runtime V eriﬁcation - Introductory and Advanced Topics .
Springer, 2018, pp. 135–175.
[21] R. Matinnejad, S. Nejati, L. C. Briand, and T. Bruckmann, “Mil
testing of highly conﬁgurable continuous controllers: scalable search
using surrogate models,” in ACM/IEEE International Conference
on Automated Software Engineering, ASE ’14, V asteras, Sweden -
September 15 - 19, 2014 , 2014, pp. 163–174. [Online]. Available:
https://doi.org/10.1145/2642937.2642978
[22] ——, “Cocotest: a tool for model-in-the-loop testing of continuous
controllers,” in ACM/IEEE International Conference on Automated
Software Engineering, ASE ’14, V asteras, Sweden - September
15 - 19, 2014 , 2014, pp. 855–858. [Online]. Available:
https://doi.org/10.1145/2642937.2648625
[23] B. D’Angelo, S. Sankaranarayanan, C. S ´anchez, W. Robinson,
B. Finkbeiner, H. B. Sipma, S. Mehrotra, and Z. Manna, “LOLA:
runtime monitoring of synchronous systems,” in 12th International
Symposium on Temporal Representation and Reasoning (TIME 2005),
23-25 June 2005, Burlington, V ermont, USA , 2005, pp. 166–174.
[24] MathWorks, “Global optimization toolbox,” Website, accessed May 10,
2019. [Online]. Available: https://de.mathworks.com/products/global-
optimization.html
[25] ——, “Bayesian optimization workﬂow,” Website, accessed May 10,
2019. [Online]. Available: https://de.mathworks.com/help/stats/bayesian-
optimization-workﬂow.html
[26] IPG, CarMaker: Virtual testing of automobiles and light-duty
vehicles . [Online]. Available: https://ipg-automotive.com/products-
services/simulation-software/carmaker/
[27] IBM, IBM Engineering Requirements Management
DOORS Family . [Online]. Available: https://www.ibm.com/us-
en/marketplace/requirements-management
[28] J. Hillenbrand, A. M. Spieker, and K. Kroschel, “A multilevel collision
mitigation approach – its situation assessment, decision making, and
performance tradeoffs,” IEEE Transactions on Intelligent Transportation
Systems , vol. 7, no. 4, pp. 528–540, Dec 2006.
[29] M. Megger, “Analyse einer Testmethode zur Qualit ¨atssteigerung im
Bereich des hochautomatisierten Fahrens,” Bachelor’s Thesis, Duale
Hochschule Baden-W ¨urttemberg, Stuttgart, 2018.
[30] MathWorks, Simulink Product Homepage . [Online]. Available:
http://www.mathworks.com/products/simulink
[31] “Robot operating system,” www.ros.org.
[32] M. Harman and P. McMinn, “A theoretical and empirical study of search-
based testing: Local, global, and hybrid search,” IEEE Transactions on
Software Engineering , vol. 36, no. 2, pp. 226–247, March 2010.
[33] R. B. Abdessalem, A. Panichella, S. Nejati, L. C. Briand, and
T. Stifter, “Testing autonomous cars for feature interaction failures
using many-objective search,” in Proceedings of the 33rd ACM/IEEE
International Conference on Automated Software Engineering, ASE
2018, Montpellier , France, September 3-7, 2018 , 2018, pp. 143–154.
[Online]. Available: https://doi.org/10.1145/3238147.3238192[34] K. Kandasamy, A. Krishnamurthy, J. Schneider, and B. Poczos,
“Parallelised bayesian optimisation via thompson sampling,”
in Proceedings of the Twenty-First International Conference
on Artiﬁcial Intelligence and Statistics , ser. Proceedings of
Machine Learning Research, A. Storkey and F. Perez-Cruz,
Eds., vol. 84. Playa Blanca, Lanzarote, Canary Islands:
PMLR, 09–11 Apr 2018, pp. 133–142. [Online]. Available:
http://proceedings.mlr.press/v84/kandasamy18a.html
[35] J. Wang, S. C. Clark, E. Liu, and P. I. Frazier, “Parallel bayesian
global optimization of expensive functions,” in arXiv:1602.05149 ,
2016. [Online]. Available: https://arxiv.org/abs/1602.05149
[36] L. Brim, P. Dluhos, D. Safr ´anek, and T. Vejpustek, “STL*: Extending
signal temporal logic with signal-value freezing operator,” Inf. Comput. ,
vol. 236, pp. 52–67, 2014.
[37] A. Donz ´e and O. Maler, “Robust satisfaction of temporal logic over
real-valued signals,” in F ormal Modeling and Analysis of Timed Systems ,
K. Chatterjee and T. A. Henzinger, Eds. Berlin, Heidelberg: Springer
Berlin Heidelberg, 2010, pp. 92–106.
[38] T. Akazaki and I. Hasuo, “Time robustness in mtl and expressivity in
hybrid system falsiﬁcation,” in Computer Aided V eriﬁcation , D. Kroen-
ing and C. S. P ˘as˘areanu, Eds. Cham: Springer International Publishing,
2015, pp. 356–374.
[39] G. J. Holzmann, “The logic of bugs,” in Proceedings of the 10th ACM
SIGSOFT Symposium on F oundations of Software Engineering , ser.
SIGSOFT ’02/FSE-10. New York, NY , USA: ACM, 2002, pp. 81–
87.
[40] S. Yaghoubi and G. Fainekos, “Falsiﬁcation of temporal
logic requirements using gradient based local search in
space and time,” IF AC-PapersOnLine , vol. 51, no. 16, pp.
103 – 108, 2018, 6th IFAC Conference on Analysis and
Design of Hybrid Systems ADHS 2018. [Online]. Available:
http://www.sciencedirect.com/science/article/pii/S2405896318311315
[41] G. Bagschik, T. Menzel, and M. Maurer, “Ontology based scene creation
for the development of automated vehicles,” in 2018 IEEE Intelligent
V ehicles Symposium (IV) , June 2018, pp. 1813–1820.
[42] A. Lecchini-Visintini, J. Lygeros, and J. M. Maciejowski, “Stochastic
optimization on continuous domains with ﬁnite-time guarantees
by markov chain monte carlo methods,” IEEE Trans. Automat.
Contr . , vol. 55, no. 12, pp. 2858–2863, 2010. [Online]. Available:
https://doi.org/10.1109/TAC.2010.2078170
[43] H. Abbas, B. Hoxha, G. Fainekos, and K. Ueda, “Robustness-guided
temporal logic testing and veriﬁcation for stochastic cyber-physical
systems,” in The 4th Annual IEEE International Conference on Cyber
Technology in Automation, Control and Intelligent , June 2014, pp. 1–6.
37
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:08:56 UTC from IEEE Xplore.  Restrictions apply. 