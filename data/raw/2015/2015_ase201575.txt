Model Checking Task Parallel Programs using
Gradual Permissions
Eric G Mercer and Peter Anderson
Brigham Young University
Provo, Utah, USA
Email: eric.mercer,anderson.peter@byu.eduNick Vrvilo and Vivek Sarkar
Rice University
Houston, TX, USA
Email: nick.vrvilo,vsarkar@rice.edu
Abstract —Habanero is a task parallel programming model
that provides correctness guarantees to the programmer . Even
so, programs may contain data races that lead to non-determinism, which complicates debugging and veriﬁcation. Thispaper presents a sound algorithm based on permission regions toprove data race and deadlock freedom in Habanero programs.Permission regions are user annotations to indicate the use ofshared variables over spans of code. The veriﬁcation algorithmrestricts scheduling to permission region boundaries and isolationto reduce veriﬁcation cost. The effectiveness of the algorithmis shown in benchmarks with an implementation in the JavaPathﬁnder (JPF) model checker . The implementation uses averiﬁcation speciﬁc library for Habanero that is tested using JPFfor correctness. The results show signiﬁcant reductions in cost,where cost is controlled with the size of the permission regions,at the risk of rejecting programs that are actually free of anydata race or deadlock.
I. I NTRODUCTION
Despite the explosion in multi-core hardware for general
purpose computing, writing programs to take advantage of
the available processing power is often a task reserved forexpert developers. The ﬁrst programs from the uninitiatedoften have more in common with sequential execution thanparallel performance due to excessive synchronization, orworse, those programs are fraught with concurrency errors dueto an absence of needed synchronization.
The Habanero extreme scale software research project
intends to bring multi-core programming to the masses throughlanguages and frameworks for non-experts. Habanero Javaitself is a task-parallel programming model built aroundlightweight asynchronous tasks and data transfers [1]. Theprogrammer in the Habanero framework focuses on the high-level task constructs using simple annotations and delegatesto the Habanero run-time the burden of how to correctly andefﬁciently implement and synchronize those constructs.
The Habanero programming model offers correctness guar-
antees by deﬁning safe subsets of the language that preserveproperties over concurrent interactions such as determinism,serialization, and deadlock freedom; however many of theseproperties rely on the absence of data races. Regardless ofusing a safe-subset of the language, there is no easy way todetermine when and if a program is free of data races. Assuch, the problem of veriﬁcation reduces in practice to printf -
debugging, inefﬁcient code inspection, and run-time failures.
Permission regions are program annotations that announce
how a task interacts with speciﬁc shared objects (i.e., readingor writing), and over what region of code that interaction takesplace [2]. During execution, auxiliary data structures trackaccesses at the region on the indicated variables and signalan error on any accesses that conﬂict with the permissionannotations. Permission regions have been shown effective indynamically detecting data races at run-time, while requiringonly a small number of programmer annotations, for a Javaimplementation of Habanero (HJ) [2], [3].
This paper presents a sound model checking algorithm to
prove a program, for a given input, free of data races, dead-locks, failed assertions, and exceptions based on permissionregions. The algorithm treats permission regions as atomicblocks of read/write operations on shared memory to reducethe number of schedules that must be considered in the proof.The algorithm also enumerates all outcomes that arise fromnon-determinism in sequencing isolated atomic blocks (i.e.,non-determinism that is intended by the programmer) to verifyuser deﬁned assertions and exceptions. This paper includes aproof that the algorithm is sound for any Habanero programwith a ﬁxed input. As such, the cost of model checking aHabanero program is controlled with the size and number ofthe permission regions, at the risk of rejecting some programsthat are actually free of data races.
The effectiveness of the algorithm is explored using a new
implementation of HJ in the form of a veriﬁcation library (HJ-V) and the Java Pathﬁnder model checker (JPF). HJ-V is in-tended for debugging, testing, and veriﬁcation so it trades per-formance for simplicity and correctness by using Java threadsfor each task, and using global locks with conditions for fea-tures of Habanero that require mutual exclusion and complexsynchronization. The library supports all of the constructs inthe Habanero model including phasers. The implementation ofpermission regions with the new model checking algorithm isin an extension to JPF named JPF-HJ. An empirical study overseveral benchmarks comparing the cost of veriﬁcation betweenJPF and JPF-HJ both using HJ-V show a signiﬁcant reductionin the cost when using JPF-HJ that is dependent on the sizeand number of the permission regions with their interactions.The implementations of both HJ-V and JPF-HJ are availableathttp://javapathfinder.org/jpf-hj/
II. H
ABANERO JAVA
The Habanero programming model is built around a task-
parallel view of concurrency. Figure 1 is an HJ program usingHabanero’s most basic task constructs: ﬁnish and async. The
finish-construct is a generalized join operation for collective
2015 30th IEEE/ACM International Conference on Automated Software Engineering
978-1-5090-0025-8/15 $31.00 © 2015 IEEE
DOI 10.1109/ASE.2015.75535
1public static void main(final String[] s) {
2 Stack stk = initStack();
3
4 launchHabaneroApp(() -> {
5 finish(() -> {
67
async(() -> {
8 stk.push(5);
9 });
1011
stk.peek();
12 });
13 });
14}
Fig. 1. An HJ program snipet using the async andfinish statements.
synchronization: the parent task executes and then waits until
all tasks created within the finish-construct have completed
(including transitively created tasks).
Theasync-construct is a mechanism for creating a new
asynchronous task: the calling task (parent) creates a new task(child) to execute in parallel with the parent. The child can reador write any data in the heap and can read, but not write, anylocal variable belonging to the parent’s lexical scope. A taskcreated in an async-construct becomes ready for scheduling
at the point it is declared in the program.
The program in Figure 1 enters a finish-construct
(Line 5) where it creates a child task (Line 7) to write to thestack (Line 8). the parent task then inspects the stack (Line 11).The two stack operations are not ordered and execute logicallyin parallel. The parent blocks at the end of the finish-
construct until the child task completes.
Other constructs in the Habanero model include: isolated
and actors for mutual exclusion, future for passing data be-
tween tasks, and phasers for arbitrary point-to-point synchro-
nization [1].
III. P
ERMISSION REGIONS
Permission regions are programmer added annotations on
shared objects [2], [3]. The regions are indicated as accessingshared objects in read or write mode. When the programexecutes with run-time checking of permission regions en-abled, a state machine is associated with each shared object totrack permissions on that object as indicated by the programannotations. If accesses from distinct tasks on the same objectconﬂict (i.e., a read with a write or a write with a write), thena permission violation, indicative of a data race, is detected.An absence of violations implies an absence of any data races.
To annotate the program in Figure 1 with permission
regions, Line 8 and Line 11 are wrapped in separate regions,writing and reading, respectively, as follows:
acquireW(stk);
stk.push(5);releaseW(stk);
Fig. 2. Different schedules for a permission region annotated version of
the program in Figure 1 with the schedule in the right branch reporting apermission violation.
acquireR(stk);
stk.peek();releaseR(stk);
The state machine associated with each region to track
accesses and detect violations is not shown due to space lim-
itations, but it is intuitively understood from the two possibletask schedules in Figure 2 for an annotated version of theprogram in Figure 1. The solid ﬁlled ovals and solid linesrepresent the parent task and the dotted ﬁlled ovals and dashedlines represent the child task created by the async-statement
on Line 7. The squares indicate the current state of the statemachine that is tracking accesses to the shared object stk.
The left branch of the tree is the schedule where the parent
task runs until it is blocked to wait for the child task. Theparent task acquires and releases private read privileges on theregion and then the newly created task runs, acquiring andreleasing private write privileges. If this schedule is followedin the run-time, then the permission violation in the programis undetected. The right branch is another possible schedulein the run-time. Here the child task runs just after the parenttask acquires private read privileges on stk. When the child
task tries to acquire write privileges on stk, its state machine
detects the violation.
Permission regions are distinctly different from mutual ex-
clusion primitives such as locks and the Habanero isolated-
construct. The isolated-construct deﬁnes an atomic region
that runs mutually exclusive to any other isolated-construct
and can be used to express non-determination that is intendedby the programmer. As such, isolated atomic regions areserialized with respect to one another. Permission regions donot include any serialization or synchronization semantics bythemselves; rather, they check if concurrent accesses obey thepermission annotations.
536Algorithm 1 Permission Region Informed Search
1:function SEARCH (t,h,T)
2: loop: (h,T):=run(t,h,T)
3:
4: s:=status(t, T)
5: permission violation =false
6: ifs=PRENTRY then
7: (h,T,permission violation) :=acquire(t, h,T)
8: else if s=PREXIT then
9: (h,T):=release(t, h,T)
10: goto loop
11: end if
12:13:
ifpermission violation then
14: report permission violation and exit
15: end if
16:17:
R=runnable(T )
18: ifR=∅then
19: ifblocked(T )/negationslash=∅then
20: report deadlock and exit
21: else
22: report any uncovered sharing and exit
23: end if
24: end if
25:26:
if(h,T)/negationslash∈Sthen ⊿Sis a global variable
27: S=S∪{(h,T)}
28: ifs=PRENTRY∨s=ISOLATED then
29: for allti∈Rdo
30: search(t i,h,T)
31: end for
32: else
33: ti:=random(R )
34: search(t i,h,T)
35: end if
36: end if
37: end function
IV . JPF-HJ S EARCH ALGORITHM
Permission regions create natural scheduling boundaries
for model checking that can be leveraged to mitigate state
explosion while preserving the essential behaviors of theprogram that lead to data races, deadlocks, assertion violations,or exceptions since they represent points of execution wheresharing is expected. The intuition is that given a ﬁxed programinput, erroneous behavior can only arise from interactionsbetween tasks on shared memory. As such, it is only necessaryto preempt running tasks at the entrance to permission regionsandisolated-constructs. If a program has any deadlocks,
data races, assertion violations, or exceptions for a ﬁxedprogram input, then such a deadlock, data race, assertionviolation, or exception exists in one of the schedules that isexplored from those preemption points.
Algorithm 1 is the pseudo-code for the algorithm to explore
all task schedules created at entry to permission regionsandisolated-constructs. The pseudo-code only covers the
detection of data races (i.e., permission region violations) ordeadlocks; though, assertion violations and exceptions can bedetected similarly. The state of the program in the pseudo-code is simpliﬁed for clarity; it is represented by a heap, h,
and a set of tasks, T. The lowercase tindicates a task. Line 2
updates the heap and pool of tasks by running task tuntil it
blocks, exits, reaches a permission region boundary (i.e., entryor exit), or reaches an isolated-construct.
At the entry point of the permission region (PR
ENTRY),
Line 7 updates the state machine for the acquired permissionson the object in the heap and checks to see if the acquisitionsignals a permission violation. At the exit point of the per-mission region (PR
EXIT), Line 9 updates the state machine
for the released permissions on the object in the heap, and thealgorithm restarts task trunning anew at Line 2.
If there is a permission violation, then it is detected on
Line 13. Similarly, Line 19 detects a deadlock. A deadlockstate is indicated when there are no runnable tasks (i.e., R=∅)
and there exists tasks that are blocked. A report for either apermission violation or a deadlock includes a witness trace forvalidation and debugging. In the absence of a deadlock or apermission violation, and when there are simply no more tasksto run, Line 22 terminates the search and reports any detectedsharing that was not annotated by a permission region orcovered by an isolated-construct. Such sharing is detected
by tracking tasks on every heap access.
The setSon Line 26 is a global set to track the visited
states. Line 29 does the actual scheduling by considering allrunnable tasks, including the currently running task t,a sa
next task to run. Note that in the current state, if the task t
is preempted because it enters a permission region, then thatstate reﬂects the acquired permissions on that region. In thecase that task tblocked, Line 33 chooses a random runnable
task to schedule next.
Figure 2, shown previously, is the state space explored
by the search algorithm for the permission region annotatedversion of the program in Figure 1. Recall that the example hastwo tasks that access the shared object stk: one reading and
the other writing. The ovals in the diagram represent schedul-ing points, and as before, the blocks on the left represent thestate of the state machine tracking permissions. As indicatedby the pseudo-code, the algorithm only preempts runningtasks at the entrance to permission regions. In this example,it schedules the child task after the main task acquires readpermissions to elicit the permission violation. By observation,if the permission regions in the annotated program werereplaced with isolated-constructs, then the explored state
space would no longer include the violation, but it wouldinclude all schedules that interleave the atomic blocks deﬁnedby the isolated-constructs.
Algorithm 2 is a procedural ﬂow describing the process
of program validation using the new search in Algorithm 1.When Algorithm 1 ﬁnishes, the algorithm reports any heaplocations that have been accessed by more than one distincttask outside a permission region or an isolated-construct
with the input program location where that access occurs.Using this information, a user is able to manually annotate theprogram location appropriately, and then repeat the search. Theprocess terminates when a permission violation or a deadlockis discovered, or no more sharing outside of permission regionsorisolated-constructs exists.
537Algorithm 2 Procedure to Validate a Program
procedure V ALIDATE (p)
(h,T):=init(p)
R:=runnable(T )
t:=random(R )
S:=∅
search(t, h,T)
while uncovered sharing is reported do
Add permissions or isolated on sharing
(h,T)=init(p)
S:=∅
search(t, h,T)
end while
end procedure
Theorem 1. Algorithm 1 is sound in that it only accepts
programs that have no permission violations or deadlock on a
given input under the restriction that the programs terminateand have all sharing correctly annotated with permissionregions or wrapped in isolated-constructs.
Proof: The soundness proof reasons over a slightly mod-
iﬁed version of the algorithm that is iterative and takes as anadditional input a search tree, which is similar to Figure 2,that captures all possible sequences of release and acquirestatements explored thus far. The algorithm traverses that inputtree and at each leaf node tries to extend that node by onegeneration if possible. After the traversal, the algorithm returnsthe new tree. The algorithm is called in an iterative manneruntil the tree reaches a ﬁx-point (which is guaranteed sincethe program terminates).
LetP(n)be the statement that this modiﬁed search algo-
rithm returns all interesting sequences of acquire and releasestatements of length nor less for a given input program,
where interesting means containing a permission violation ordeadlock.
Basis Step: the algorithm produces all interesting sequences of
lengthn≤1. This case is trivially established with the initial
state of the program that represents a sequence of length n≤1
and cannot contain a permission violation or deadlock since
the program has not yet done anything. As such, it includesall interesting sequences.
Inductive Step: assume the modiﬁed algorithm has correctly
generated a tree representing all interesting sequences of nor
less; it is necessary to show that from such a tree the algorithm
is able to generate all interesting sequences of length n+1
or less. There are three possible outcomes at any leaf of theinput tree:
1) the leaf cannot be extended as it is already an interesting
sequence having a permission violation or deadlock;
2) the leaf cannot be extended as there are no more tasks to
run, in which case it is not interesting; or
3) the leaf is able to be extended with one or more immediate
descendants.
The ﬁrst two cases are directly covered by Line 13 throughLine 24 of the algorithm; there is no way to have anydescendants in those situations and the sequences are alreadyclassiﬁed as interesting or not.For the third case, ﬁrst consider Line 28 of the algorithm
that creates the next generation in the tree for permissionregions and isolated-constructs. Every runnable task is
scheduled (Line 29) and each of those tasks must reach animmediate successor. Such a successor may be a permissionviolation or a deadlock, making it an interesting sequence, apreemption, a block condition, or exit by the constraint thatthe input program must terminate. As such, any n+1length
sequence that exists, is generated.
Further, any interesting n+1 sequence is generated. To
see this outcome, it is important to understand that the orderof acquisition relative to read or write does not matter indetecting a violation. The state machines on the objects arenot dependent on acquisition order; they only depend on whattasks hold read or write permissions at the time of acquisition.As the algorithm always ﬁrst acquires a permission and thenschedules other tasks, it generates all the interesting n+1
sequences if any exist. In this case, a sequence is interestingdue to a permission violation. If a permission violation doesnot exist in a sequence, then a deadlock is detected as usual.
To complete the inductive step, the code under Line 32
must be considered. That code covers a blocked or exited task.The input program has all sharing annotated or isolated
by the theorem statement, meaning that any non-determinismdue to scheduling is enumerated by Line 29 so all reachableprogram paths on the input are considered. If an interestingsequence exists because of a deadlock, then it is either foundin then+1 step, by having selected the correct task, or in
a later step when the correct task is chosen. If the deadlockdepends on a particular sequence of task executions, then thosesequences are enumerated by Line 29. As such, the deadlock iseither deterministic (i.e., independent of the schedule) or non-deterministic (i.e., a product of a data race on some sharedobject). In the former, the choice of task does not matter,and in the latter, Line 29 enumerates all possible orders overpermission region blocks and isolated blocks.
As a side note, Algorithm 1 is complete when all regions
cover a single operation (i.e., an individual byte-code in thecase of Java). Such completeness is at the cost of the numberof explored schedules.
V. R
ESULTS
A new Java library was implemented to evaluate Algo-
rithm 1 in the JPF model checker (HJ-V). The library usesLambda support in Java 8, and it is purposed for veriﬁcation inJPF. Algorithm 1 itself is an extension to JPF that implementspermission regions and the search (JPF-HJ). Each is brieﬂydiscussed before the results from several benchmark programsare presented.
A. HJ Library for V eriﬁcation
HJ-V is a new Java library implementation of the Habanero
model designed speciﬁcally for debugging and veriﬁcation. It
consists of roughly 1,300 lines of code in 32 classes. Most ofthe classes address the programmer interface rather than thelibrary internals. Figure 1 is the interface using Java 8 Lambdafunctions and is identical to other Java library implementationsof the Habanero model [4].
538HJ-V supports all of the constructs in the Habanero model
including phasers. To increase conﬁdence in the correctness of
HJ-V , test cases were created to utilize speciﬁc features of theruntime. Each of these test cases were run within JPF withfull scheduling enabled (i.e., it schedules on every bytecoderelated to thread synchronization or sharing). Thus, for eachcase, JPF is used to determine that HJ-V is free of data racesand deadlocks. In total, 22 test cases were created consistingof approximately 1,000 lines of source code.
B. JPF Implementation
The implementation of permission regions in JPF spans
1,036 lines of code and covers 11 distinct class objects. It
leverages JPF’s ability to track thread IDs of all accesses toobjects, so it not only reports violations on the permissionregions, but it also identiﬁes shared accesses that are notannotated by permission regions or covered by isolated-
constructs. In this way, JPF updates the user when a sharedaccess has been missed in the annotations.
The implementation uses two key features of JPF: byte-
code listeners and object attributes. It installs a byte-codelistener to watch for instances of the byte-code that callsmethods. The actual methods for the permission regions in-terface are empty stubs, and when the listener activates onthe interface, it gets the method’s parameters from the stackand updates the associated state machines appropriately. Thestate machines themselves reside in an attribute of the object[5]. The important property of attributes is that they followheap objects through the entirety of state space exploration.For arrays, a separate permissions state machine is stored forevery index.
The JPF implementation of Algorithm 1 exploits the exten-
sible nature of the tool by providing a new scheduling-factory.
A scheduling-factory is activated on preemption, when a threadis no longer able to run, or if there is input non-determinism.It decides what threads are scheduled by inserting choice-
generators into the state search to enumerate the available
choices. The search iterates over those choices starting a newsearch for each choice.
The default scheduling-factory of JPF is replaced with a
new factory that does not insert any choices on thread actions,locks, synchronization, or shared accesses to objects. Anythingrelated to concurrency is turned off except for forced contextswitches such as a thread exiting or a thread blocking. In thosecases, the new scheduling-factory inserts a choice generatorwith a single choice that represents a random thread that isrunnable.
To insert the preemption points for permission regions and
isolated-constructs, the byte-code listener from the imple-mentation of permission regions is extended to also listen forthe calls to isolated. At the entrance to permission regions,
the permission regions’ state machine for the object is updatedas before, but after the update, a choice-generator is insertedinto the search that includes choices for all runnable threads.Similarly, a choice-generator is inserted at the isolated call.
The entire factory with the listener extension is only a fewhundred lines of code but signiﬁcantly reduces the veriﬁcationcost.
Benchmark ResultsJPF’s default code to detect data races is named Precis-
eRaceDetector. Table I compares the performance of JPF-HJwith PreciseRaceDetector over several benchmark programs
taken from materials used to teach the Habanero model or testthe Habanero runtimes. These programs are not necessarilyindicative of actual Habanero programs in the real world butdo contain the breadth of HJ constructs: async, isolated,
finish, future, and phasers. Many benchmarks also in-
clude arrays and shared arrays. The sizes of the benchmarksare indicated by the SLOC column (i.e., the number of program
locations) and the Tasks column (i.e., the number of tasks
created).
In Table I, an entry of N/A in the time column indicates a
running time greater than 30 minutes on a Macbook Pro, coreI7, with 8 Gb of ram. The Error column indicates if a data
race or deadlock is discovered. An entry of Detected Race*
is an incorrect result: the program is actually free from dataraces.
The ﬁrst thing to notice in the table is that the PreciseR-
aceDetector is more likely to not complete in the time bound
due to exploring an excessive number of task schedules: itschedules on individual byte-codes where JPF-HJ scheduleson regions. The second thing to notice is that the PreciseR-
aceDetector reports data races in TwoDimArrays, Add, and
ScalarMultiply benchmarks where no data races exists. This
error report is a limitation of PreciseRaceDetector where it is
not able to discern accesses to the arrays on disjoint indexes;rather, it reports an error because the access on the array objectlooks like a data race and exits. If JPF is conﬁgured to not exiton error discovery, then the entries become N/A. That is whythe Time entries on those examples appear to improve over the
entries for JPF-HJ.
The ﬁnal thing to notice in the table is that the cost of
veriﬁcation is difﬁcult to predict based solely on the staticnumber of region annotations, as it depends not just on thatnumber, but the size of the regions, and how many taskscontain the regions. For example, the PrimeNumberCounter
and its variants have very few regions, as deﬁned by theannotations in the code, but those regions are part of everycreated task, so those benchmarks have a much larger numberof schedules to explore.
VI. R
ELATED WORK
The algorithm introduced in this paper is related to existing
algorithms that only schedule on synchronizations [6], [7], [8],[9], [10]. Grouping synchronizations in regions trades com-pleteness for efﬁciency in a manner similar to bounding. Priormethods using permission regions only detect violations atrunning time and do not search the schedule space [2]; thoughit is possible to use a gradual type system to enforce guaranteesat compile time [3]. An early version of a veriﬁcation speciﬁcrun-time for Habanero requires a specialized Habanero Javacompiler and does not implement all the Habanero constructs(most notably future and phasers) [11]. A preliminary
version of JPF-HJ details how to extend JPF but does not deﬁnethe search algorithm, prove its correctness, provide support forarrays, or provide support for isolated-constructs [12].
Other approaches to verify task-parallel languages create
new virtual machines with veriﬁcation support [13], or spe-
539TABLE I. P ERFORMANCE COMPARISON BETWEEN JPF-HJ AND PreciseRaceDetector
Permission Regions PreciseRaceDetector
Test ID SLOC Tasks States Time Regions Error Note States Time Error Note
PrimitiveArrayNoRace 29 3 5 0:00:00 0 No Race 11,852 0:00:00 No Race
PrimitiveArrayRace 39 3 5 0:00:00 2 No Race 220 0:00:00 Detected Race
TwoDimArrays 30 11 15 0:00:00 0 No Race 597 0:00:00 Detected Race*
ForAllWithIterable 38 2 9 0:00:00 0 No Race N/A N/A N/A
IntegerCounterIsolated 54 10 1,013,102 0:05:53 3 No Race N/A N/A N/A
PipelineWithFutures 69 5 34 0:00:00 1 No Race N/A N/A N/A
SubstringSearch 83 59 8 0:00:00 2 Detected Race N/A N/A N/A
BinaryTrees 80 525 632 0:00:03 0 No Race N/A N/A N/A
PrimeNumCounter 51 25 231,136 0:01:08 2 No Race N/A N/A N/A
PrimeNumCounterForAll 52 25 6 0:00:00 2 Detected Race* N/A N/A N/A
PrimeNumCounterForAsync 44 11 449,511 0:02:51 2 No Race N/A N/A N/A
ReciprocalArraySum 58 2 32 0:00:06 2 No Race N/A N/A N/A
Add 67 3 62,374 0:00:33 6 No Race 4,930 0:00:03 Detected Race*
ScalarMultiply 55 3 55,712 0:00:30 2 No Race 826 0:00:01 Detected Race*
VectorAdd 50 3 17 0:00:00 4 No Race 46,394 0:00:19 No Race
AsyncTest1 23 51 54 0:00:00 0 No Race N/A N/A N/A
AsyncTest2 32 3 4 0:00:00 2 Detected Race 11,534 0:00:04 Detected Race
FinishTest1 32 3 6 0:00:00 0 No Race 2,354 0:00:02 No Race
FinishTest2 33 3 5 0:00:00 0 No Race 25,243 0:00:09 No Race
FinishTest3 44 4 7 0:00:00 0 No Race 34,459 0:00:12 No Race
ClumpedAccess 30 3 15 0:00:00 2 No Race N/A N/A N/A
cialize existing veriﬁcation tools to work with existing run-
times [14]. These assume the run-times correctly implementthe language. Dynamic methods that intercept the run-timecalls or instrument the program input can be effective forveriﬁcation using stateless search or bounding techniques [7],[8]. Bounded techniques apply equally well to the algorithmin this paper. Static method to ﬁnd data races often have betterperformance but are more likely to reject correct programs
VII. C
ONCLUSIONS &F UTURE WORK
This paper presents a model checking algorithm to prove
when a Habanero program does not contain any data races,deadlocks, assertion violations, or exceptions for a givenprogram input. The algorithm, based on permission regions,only considers scheduling points in the search tree at theboundaries of permission regions and isolated-constructs.
The paper includes a proof of soundness for the algorithm,meaning that the algorithm may reject a correct program dueto the size of the permission regions.
The effectiveness of the algorithm is shown in several
benchmark programs that cover many of the Habanero concur-rency constructs. The analysis is done using a new Java libraryimplementation of the Habanero runtime that is intended fordebugging and veriﬁcation. The new algorithm, with permis-sion regions, is implemented as an extension to the JPF modelchecker. The results from the benchmark programs indicate asigniﬁcant cost reduction when using the new algorithm.
Future work includes automating the annotation of per-
mission regions based on the sharing detection in JPF; au-tomating the validation of any counter-example; developingtechniques to automatically reﬁne permission regions fromcounter-examples when needed; a partial order reduction overpermission regions; static-analysis to prevent scheduling on re-gions that cannot race; applying symbolic techniques to reasonover input; and studying benchmarks that are representative ofreal world Habanero programs.
R
EFERENCES
[1] V . Cav ´e, J. Zhao, J. Shirako, and V . Sarkar, “Habanero-Java: the
new adventures of old X10,” in Proceedings of the 9th International
Conference on Principles and Practice of Programming in Java, ser.
PPPJ ’11. New York, NY , USA: ACM, 2011, pp. 51–61.[2] E. Westbrook, J. Zhao, Z. Budimli ´c, and V . Sarkar, “Permission regions
for race-free parallelism,” in Proceedings of the Second international
conference on Runtime veriﬁcation, ser. RV’11. Berlin, Heidelberg:Springer-Verlag, 2012, pp. 94–109.
[3] ——, “Practical permissions for race-free parallelism,” in Proceedings
of the 26th European conference on Object-Oriented Programming, ser.ECOOP’12. Berlin, Heidelberg: Springer-Verlag, 2012, pp. 614–639.
[4] S. Imam and V . Sarkar, “Habanero-Java library: A Java 8 framework
for multicore programming,” in Proceedings of the 2014 International
Conference on Principles and Practices of Programming on the JavaPlatform: Virtual Machines, Languages, and Tools, ser. PPPJ ’14. NewYork, NY , USA: ACM, 2014, pp. 75–86.
[5] C. S. P ˘as˘areanu, W. Visser, D. H. Bushnell, J. Geldenhuys, P. C.
Mehlitz, and N. Rungta, “Symbolic Pathﬁnder: integrating symbolicexecution with model checking for Java bytecode analysis,” Autom.
Softw. Eng., vol. 20, no. 3, pp. 391–425, 2013.
[6] S. Vakkalanka, G. Gopalakrishnan, and R. M. Kirby, “Dynamic veriﬁca-
tion of MPI programs with reductions in presence of split operations andrelaxed orderings,” in Proceedings of the 20th international conference
on Computer Aided V eriﬁcation, ser. CA V ’08. Berlin, Heidelberg:Springer-Verlag, 2008, pp. 66–79.
[7] M. Musuvathi and S. Qadeer, “Iterative Context Bounding for System-
atic Testing of Multithreaded Programs.” in PLDI, J. Ferrante and K. S.
McKinley, Eds. ACM, 2007, pp. 446–455.
[8] M. Emmi, S. Qadeer, and Z. Rakamari ´c, “Delay-bounded scheduling,”
inProceedings of the 38th Annual ACM SIGPLAN-SIGACT Symposium
on Principles of Programming Languages, ser. POPL ’11. New York,NY , USA: ACM, 2011, pp. 411–422.
[9] P. Godefroid, “Model Checking for Programming Languages Using
Verisoft.” in POPL, 1997, pp. 174–186.
[10] C. Flanagan and S. N. Freund, “FastTrack: Efﬁcient and precise
dynamic race detection,” SIGPLAN Not., vol. 44, no. 6, pp. 121–133,
Jun. 2009.
[11] P. Anderson, B. Chase, and E. Mercer, “JPF veriﬁcation of Habanero
Java programs,” SIGSOFT Softw. Eng. Notes, vol. 39, no. 1, pp. 1–7,
Feb. 2014.
[12] P. Anderson, N. Vrvilo, E. Mercer, and V . Sarkar, “JPF veriﬁcation
of Habanero Java programs using gradual type permission regions,”SIGSOFT Softw. Eng. Notes, vol. 40, no. 1, pp. 1–5, Feb. 2015.
[13] T. Zirkel, S. Siegel, and T. McClory, “Automated veriﬁcation of Chapel
programs using model checking and symbolic execution,” in NASA
F ormal Methods, ser. Lecture Notes in Computer Science, G. Brat,N. Rungta, and A. Venet, Eds. Springer Berlin Heidelberg, 2013,vol. 7871, pp. 198–212.
[14] M. Gligoric, P. C. Mehlitz, and D. Marinov, “X10X: Model checking
a new programming language with an ”old” model checker.” in ICST,
G. Antoniol, A. Bertolino, and Y . Labiche, Eds. IEEE, 2012, pp.11–20.
540