Probabilistic Disassembly
Kenneth Miller‚àó, Y onghwi Kwon‚Ä†,Y iS u n‚àó, Zhuo Zhang‚àó, Xiangyu Zhang‚àó, Zhiqiang Lin‚Ä°
‚àóDepartment of Computer Science, Purdue University, West Lafayette, USA
‚Ä†Department of Computer Science, University of Virginia, Charlottesville, USA
‚Ä°Department of Computer Science and Engineering, Ohio State University, Columbus, USA
Abstract ‚ÄîDisassembling stripped binaries is a prominent
challenge for binary analysis, due to the interleaving of code
segments and data, and the difÔ¨Åculties of resolving controltransfer targets of indirect calls and jumps. As a result, mostexisting disassemblers have both false positives (FP) and falsenegatives (FN). We observe that uncertainty is inevitable indisassembly due to the information loss during compilation andcode generation. Therefore, we propose to model such uncertaintyusing probabilities and propose a novel disassembly technique,which computes a probability for each address in the code space,indicating its likelihood of being a true positive instruction.The probability is computed from a set of features that arereachable to an address, including control Ô¨Çow and data Ô¨Çowfeatures. Our experiments with more than two thousands binariesshow that our technique does not have any FN and has only3.7% FP . In comparison, a state-of-the-art superset disassemblytechnique has 85% FP . A rewriter built on our disassemblycan generate binaries that are only half of the size of thoseby superset disassembly and run 3% faster. While many widely-used disassemblers such as IDA and BAP suffer from missingfunction entries, our experiment also shows that even without anyfunction entry information, our disassembler can still achieve 0FN and 6.8% FP .
I. I NTRODUCTION
Analyzing and transforming commercial-off-the-shelf and
legacy software have many applications [1], [2], [3], [4], [5],
[6], [7], [8], [9], [10], [11], [12], [13], [14], [15], [16], [17],[18], [19], [20], [21], such as bug Ô¨Ånding, security hardening,reverse engineering, code clone detection and refactoring.However, they are highly challenging due to the lack of sourcecode. The Ô¨Årst fundamental problem is to precisely disassem-ble the software. The seemingly simple task is indeed highlychallenging due to the diversity and complexity of compilationand optimizations. There are two popular kinds of disassemblytechniques. The Ô¨Årst one disassembles instructions followingthe address order, called linear sweep disassemblers, and
the other disassembles instructions by following control Ô¨Çowedges (e.g., jumps and calls), called traversal disassemblers.
Both have well known limitations. In particular, code and datacan interleave, causing a large number of false positives andeven false negatives in linear sweep disassemblers; traversaldisassemblers suffer indirect control Ô¨Çow caused by functionpointers, virtual tables, and switch-case statements, whichmake recognizing control transfer targets highly difÔ¨Åcult. Eventhe state-of-the-art disassemblers such as those in BAP [ 22],
IDA-Pro [23], OllyDbg [24], Jakstab [25], SecondWrite [26],and Dyninst [27] have difÔ¨Åculty fully disassembling complexbinaries [28]. Some may miss up to 30% of the code [28].
There are machine learning based methods [29] that aimto recognize function entries by instruction patterns (e.g.,starting with ‚Äúpush ebp‚Äù). However, such methods haveinevitable false positives and false negatives (e.g., the entriesof many library functions do not follow speciÔ¨Åc patterns).Recently, superset disassembly [30] was proposed to address
these limitations. It disassembles at each address to produce asuperset of instructions. A rewriter is built on the disassemblerto instrument all superset instructions. While it has a criticalguarantee of no false negatives that other binary rewriting toolscannot provide, the rewritten binaries have substantial codesize blow-up and nontrivial runtime overhead (e.g., 763% sizeoverhead and 3% runtime overhead on SPEC programs).
We argue that the capabilities of reasoning about uncertainty
is critical for binary analysis, since it is inherent due to thelack of symbolic information. Our overarching idea is henceto use probabilities to model uncertainty and then performprobabilistic inference to determine the appropriate way ofdisassembling subject binaries. In particular, our disassemblercomputes a posterior probability for each address in the codesection to indicate the likelihood of the address denoting atrue positive instruction (i.e., an instruction generated by the
compiler). SpeciÔ¨Åcally, our technique disassembles the binaryat each address just like superset disassembly. We call theresult the superset instructions orvalid instructions, which
may or may not be true positives. We then identify correlations
between these superset instructions such as one being the
transfer target of another; and one deÔ¨Åning a register that
is later accessed by another. These relations denote semanticfeatures that only the real code body would likely demonstrate.We call them hints. They are uncertain because instructions
decoded from random bytes may by chance possess suchfeatures. For each kind of hint, we perform apriori probabilityanalysis to determine their prior probabilities. We develop
an algorithm to aggregate these hints and compute the poste-rior probabilities. The resulting disassembler has probabilisticguarantees of no false negatives (e.g., the likelihood of missinga true positive instruction is lower than
1
1000). In our empirical
study with 2,064 binaries, it never misses any true positive
instruction with an appropriate setting. It also has a muchsmaller number of false positives and much lower overheadin rewriting, compared with superset disassembly.
Our contributions are summarized as follows.
‚Ä¢We propose an innovative idea of probabilistic disas-sembling. The capabilities of reasoning about uncertaintyprovides unique beneÔ¨Åts compared to existing techniques.
‚Ä¢We identify a set of features for use as disassembly hints
11872019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)
1558-1225/19/$31.00 ¬©2019 IEEE
DOI 10.1109/ICSE.2019.00121
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:41:52 UTC from IEEE Xplore.  Restrictions apply. Disassembler False Negative False Positive
Linear sweep Some Substantial
Traversal [ 23] Substantial None
Superset [ 30] None Bloated
Our method None‚àóSome‚àó
‚àó: with probabilistic guarantees
T ABLE I: Comparison of Different Kinds of Disassemblers
and perform static probability analysis to determine their
likelihood ( ¬ßIII-B ).
‚Ä¢We develop a novel inference algorithm that leverages a
number of key characteristics of x86 instruction design
(¬ßIV) to aggregate uncertain hints.
‚Ä¢Our experiments on 2,064 binaries demonstrate that our
technique does not have any false negatives, and the false
positive rate is 3.7%, meaning that it disassembles 3.7%
additional instructions that are not true positives. It does
not miss any instructions even when function entries
are not available, with 6.8% FP . Our evaluation on
SPEC Windows PE binaries shows that objdump misses
3095 instructions due to code and data interleavings,
whereas our tool misses none with 8.12% FP . We also
use our disassembler in supporting binary writing. When
compared with the state-of-the-art superset rewriting
technique [ 30], our technique reduces the size of
rewritten binary by about 47% and improves the runtime
speed of the rewritten binary by 3%.
II. B ACKGROUND AND MOTIV A TION
In this section, we use a real world example to explain
binary code disassembly, the limitations of existing work
(¬ßII-A ), and how we advance the state of the art ( ¬ßII-B ).
A. Binary Code Disassembly
Figure 1 (a) presents a snippet from libUbuntuCompo-
nents.so in Ubuntu 16.04. In this piece of code, data is
inserted in between the code bodies of two functions. In (a),
the bytes from 0xbbf72 to0xbbf8f (in blue) denote data.
Address 0xbbf90 denotes the entry of a function. Another
function (omitted from the Ô¨Ågure) precedes the data bytes.
While the binary is stripped, we acquire the ground truth
through debug symbols from a separate unstripped instance.
Linear Sweep Disassembly. Linear sweep disassemblers
disassemble the next instruction from the bytes right after
the current instruction. Here, we use objdump . Without
symbolic information, objdump cannot recognize the data
bytes. As a result, after it disassembles the body of the
preceding function, it proceeds to disassemble the data bytes
to instructions 0xbbf72 ,0xbbf8b , and so on as in Fig-
ure 1 (b). SpeciÔ¨Åcally, in the shaded area, it considers the
three bytes starting at 0xbbf8f an instruction. Consequently,
it misses the true function entry 0xbbf90 . Note that the
instruction sequences in Figure 1 are horizontally aligned
by their addresses. In addition, objdump disassembles the
wrong instruction at 0xbbf92 . This illustrates that linear
disassemblers cannot properly handle inter-leavings of data
and instructions . Note that embedding data such as constantvalues and jump tables in between code segments is a common
practice in compilers [ 28], [31]. As presented in Table I ,linear
sweep disassemblers have some false negatives (i.e., missing
instructions) and a lot of false positives (i.e., incorrectly
disassembling data bytes as instructions) . False negatives are
particularly problematic for binary rewriting as missing even
a single instruction could have catastrophic consequences.
False positives can cause unnecessary overhead in rewriting,
ambiguity in type reverse engineering and so on.
Traversal based Disassembly. Some other diassemblers such
as IDA [ 23] and BAP [ 22] disassemble by following control
Ô¨Çow edges, starting from function entries. A prominent chal-
lenge is to recognize function entries. Missing an entry means
the entire function body may not be properly disassembled.
The presence of indirect calls makes function entry identi-
Ô¨Åcation difÔ¨Åcult as the precise call targets are only known
at runtime. In our example, there is no direct invocation to
the function entry 0xbbf90 inlibUbuntuComponent
and the function is not exported either. As a result, IDA
misses the entire function body. Furthermore, the Ô¨Årst instruc-
tion of the function entry is a rarely used instruction ‚Äú MOV
0x19b978(rip), rax ‚Äù. As such, ML based techniques
(e.g., [ 32], [ 29], [ 33]) likely miss it. There are also non-
learning techniques to recognize functions in binaries [ 34],
[35], [36]. They are based on heuristics such as the matching
of push and pop operations at the entry and exit of a function.
However, a systematic way to handle the inherent uncertainty
in such heuristics is still in need.
As illustrated by Table I ,traversal disassemblers have no
false positives but potentially substantial false negatives .I n
fact, Bao et al. [ 29] show that traversal disassemblers such as
IDA may miss 68.19% function entries.
Superset Disassembly. A state-of-the-art technique (partic-
ularly for rewriting/instrumentation) is called superset dis-
assembly [30]. The idea is to consider that every address
starts an instruction, called superset instruction . As such,
consecutive superset instructions may share common bytes.
Rewriting is performed on all superset instructions. It can
be easily inferred that the superset disassembler has no
false negatives but must have a bloated code body due to
the large number of superset instructions that are not true
positives (Table I ).Figure 1 (c) presents the results for superset
disassembly. Observe that a superset instruction is generated
by disassembling the bytes starting at each address. Hence,
we have instructions at 0xbbf72 ,0xbbf73 , ...,0xbbf91 ,
0xbbf92 , and so on. Observe that consecutive instructions
share common byte values (e.g., the body of 0xbbf91 ‚Äú8b
05 71 b9 19 00 ‚Äù is the sufÔ¨Åx of 0xbbf90 ). Also observe
that all the true positive instructions, i.e., those in Figure 1 (a),
are part of the superset. As such, the rewritten binary can
properly execute as all possible jump/call targets must be
instructions in the superset and hence instrumented. Note
that the bloated instructions cause not only substantial size
overhead, but also runtime slowdown because executing each
1188
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:41:52 UTC from IEEE Xplore.  Restrictions apply. EEI  123FVUD[UD[
EEII123FVUD[EEI123FVUD[
¬´
EEIE  $'' DOUD[EEIF  $'' DOUD[EEIG  $'' DOUD[EEIH  $'' DOUD[EEII E $'' FOUD[
EEI¬´ 029[EULSUD[
EEIE¬´029[EULSHD[EEI ¬´ $'' [HD[EEIE-12EEIIEEIE¬´029[HF[
¬´
EEI 386+ U
EEI386+UVL
¬´
EEIE  029 UG[UGL
EEIE029HG[UGL

EEIEDII7(67UGLUGL

EEIGHI -1=EEIFEEI HIIGDWD
EEIIIGDWD
EEI E E 029[EULSUD[
EEI  386+ U
¬´
EEID G /($ UD[UG[
EEID  $'' UD[
EEIDF  029 UD[UGL
EEIE  029 UG[UGL
EEIED II 7(67 UGLUGL
EEIEG  -( EEIF
¬´
EEIGHI -1=EEIFEEI  123FVUD[UD[

EEIE  $'' DOUD[
EEIG  $'' DOUD[EEII E $'' FOUD[
EEI ¬´ $'' HD[
EEI  386+ U
EEID /($ UD[UG[
EEID  $'' UD[
EEIDF  029 UD[UGL
EEIE  029 UG[UGL
¬´
¬´

¬´

¬´

ƒ¨



 
D*URXQGWUXWK E/LQHDUVZHHS F6XSHUVHWGLVDVVHPEO\ F2XU V
Fig. 1: Example from libUbuntuComponent.so. Instructions are horizontally aligned by their addresses. The code is slightlymodiÔ¨Åed for demonstration purposes. In instructions with two operands, the Ô¨Årst one is source and the second one is destination.
superset instruction requires a table lookup to determine the
location of the instrumented version.
B. Our Technique
We aim to inherit the advantages of superset disassembly
(i.e., no false negatives) while substantially reducing the false
positives and achieving much lower overhead. The idea isthat true positives have lots of hints indicating that theyare true instructions. For example, they often have a lot ofdeÔ¨Ånition and use (def-use) relations caused by registers andmemory, that is, a register/memory-location is deÔ¨Åned at anearlier instruction and then used in a later one. In Figure 1(a),
hint 1/circlecopyrt indicates a def-use relation caused by register rax
between instructions 0xbbf90 and0xbbfa2; 2/circlecopyrt byrdx;
3/circlecopyrt indicates a def-use by the Ô¨Çag bit. Note that false positive
instructions are less likely to induce def-use relations due totheir random nature. For example, instructions at 0xbbf8b-
0xbbf8f (Figure 1(c)) deÔ¨Åne some memory indexed by rax,
but there are no corresponding uses. Furthermore, two jumpsto the same target are likely true positives (e.g., hint 4/circlecopyrt)a s
the chance that random jumps have the same target is small.More hints are discussed in ¬ßIII-B.
However, hints are uncertain, meaning that false positives
instructions have a (small) chance of exhibiting such features.For example, according to ¬ßIII-B, false positive instructions
may have
1
16chance to have def-use relation caused by some
register. Hence, the essence of our technique is to associate
these hints with prior probabilities that are derived fromapriori probability analysis, and then perform probabilisticinference to fuse these evidences to form strong conÔ¨Ådenceabout true positives. Intuitively, the inference procedure thataggregates prior probabilities is based on the following reason-ing: if a superset instruction is likely to be a true positive, itscontrol Ô¨Çow descendants are likely to be true positives, and thedifferent superset instructions that share common bytes withit are unlikely true positives. Note that we aim to disassemblebinaries generated by regular compilers so that instructionsdo not have overlapping bodies. For example, the instructionsinvolved in hints 1/circlecopyrt- 4/circlecopyrt have reachability along control Ô¨Çow
(e.g., those in 1/circlecopyrtcan reach 4/circlecopyrt), allowing their probabilities to
be progagated and aggregated. Intuitively, while individually
1/circlecopyrt- 4/circlecopyrt have certain probability (e.g.,
1
16) to be random, the
chance of all of them randomly happening together is verylow. After inference, the posterior probabilities indicate thelikelihood of superset instructions being true positives. Fig-
ure 1(d) shows the probabilities computed by our techniquefor each superset instruction. Observe that the true positives(highlighted ones) have large probabilities (some of them arealmost certain such as 0xbbfb0 and0xbbfba), whereas
false positives have (very) small probabilities.
Fig. 2: Occlusion does not cascade
III. P ROBABILISTIC CHARACTERISTICS OF X 86
A. Observing Instruction Occlusion
In x86, part of a valid instruction may be another valid
instruction and two valid instructions may have overlapping
1189
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:41:52 UTC from IEEE Xplore.  Restrictions apply. bodies. We call them occluded instructions. W es a yaf e w
bytes form a valid instruction if they can be decoded to an
instruction. A valid instruction may not be a true positive
instruction. Therefore, if the starting point (e.g., function entry)
is not properly recognized, we may have an occluded instruc-
tion sequence that differs from the true positive sequence.
Consider an example in Figure 2 . Column one shows the
continuous addresses; column two shows the byte values; and
the remaining columns show different instructions sequences
when disassembling starts at different addresses. Note that
each instruction (box) aligns horizontally with its addresses
and byte values in the Ô¨Årst two columns. Column three
shows the ground truth instruction sequence, in which the
Ô¨Årst four bytes (from 0x400597 to0x40059a ) form a MOV
instruction whereas the following Ô¨Åve bytes form another MOV
instruction, followed by a CALL instruction. However, if we
start disassembling in the middle of the Ô¨Årst instruction, we
could acquire sequences of valid instructions that occlude with
the ground truth, as shown in the remaining columns (i.e.,
occluded instructions are in grey). Observe that in columns
four and Ô¨Åve, part of the MOV instruction is decoded to a
different MOV instruction and a conditional jump instruction,
respectively. In the last column, the last byte 0xe0 of the MOV
instruction even groups with the Ô¨Årst byte 0xbf of the next
(ground truth) instruction to form a valid LOOPNE instruction.
A concern about occlusion is that it may be cascading,
meaning that when we start at a wrong place, a large number
of following instructions are consequently occluded. However,
researchers have the following observation [ 37].
(Occlusion Rule ):Cascading occlusion is highly un-
likely: occluded sequences tend to quickly agree on a
common sufÔ¨Åx of instructions.
If one of the sequences is the true positive sequence,
occluded sequences quickly converge with the true positive.
Consider the example in Figure 2 . The three occluded se-
quences all converge to the ground truth sequence after one
or two instructions. Intuitively, cascading occlusion is unlikely
because: two occluded instructions have a good chance to
agree on their rears . In other words, the sufÔ¨Åx of an instruction
is likely to be another instruction. Consider Figure 2 . The
occluded instructions in columns 3 and 4 are the sufÔ¨Åces of
the ground truth MOV instruction. The only exception is that
when an occluded instruction i0(e.g., the LOOPNE instruction
inFigure 2 last column) starts at the very end of a valid
instruction j0(e.g., the Ô¨Årst MOV in the 3rd column), i0may go
beyondj0and cause occlusion in the instruction following j0,
sayj1(e.g., the second MOV in the 3rd column). In this case,
i0likely ends in the middle of j1. As such, the instruction(s)
following i0(e.g., the SUB andADD instructions in the last
column) agree with j1at the their rear ends. We did a study
on 2064 ELF binaries and found that 99.992% occluded in-
struction sequences converge within four instructions. We have
also conducted a formal probability proof from the encodings
of x86 instructions. Our proof shows that for instructions i0,
...,ikwithn0, ...,nkbytes, respectively. The probability of


Fig. 3: Control Ô¨Çow convergence
an occluded sequence starting inside i0and not agreeing with
the rear of ikis at most1
(n0‚àí2)...(nk‚àí2). With a sequence of
7 instructions, each having 5 bytes, the probability that an
occluded sequence does not converge at all is1
37=1
6561.
Intuitively, it is analogous to that if two parties cannot settle
on a dispute with a small probability pin one round of
negotiation. The probability that they cannot resolve within
nrounds is pn. The details are elided.
B. Observing Probabilistic Hints for Disassembling
Without knowing the appropriate entries of code segments,
we could disassemble at each address and acquire a set of
all valid instructions (or, superset instructions [ 30]) with only
some being true positives. Next we discuss a number of
correlations between valid instructions that indicate that the
corresponding bytes are not data bytes with high probabilities.
We call them probabilistic hints . The occlusion rule and the
probabilistic hints are the two corner stones of our technique.
Hint I: Control Flow Convergence. As shown in the middle
ofFigure 3 (b), if there are three potential instructions instr 1,
instr 2andinstr 3withinstr 3being the transfer target of
bothinstr 1andinstr 2, there is a good chance that they
are not data bytes (but rather instruction bytes). Figure 3 (a)
shows an example. The bytes starting at 0x804a634 and
at0x804a646 are disassembled to two conditional jumps
A/circlecopyrt and B/circlecopyrt, respectively, whose target is a same valid in-
struction C/circlecopyrt. Intuitively, since it is highly unlikely data bytes
can form two control transfer instructions and both by chance
point to the same target, they are likely instruction bytes. This
control Ô¨Çow relation is often induced by high level language
structures such as conditional statements (e.g., Figure 3 (c)).
Probability Analysis. Assume data byte values have uniform
distribution. Given two valid control transfer instructions
instr 1andinstr 2, letinstr 1‚Äôs transfer target be t, which has
the range of [- 27+1 ,27-1], [‚àí215+1 ,215‚àí1], and [‚àí231+1 ,
231‚àí1]for relative, near, and long jumps, respectively. The
likelihood that instr 2has the same transfer target is hence1
255,
1
216‚àí1, and1
232‚àí1. In other words, when we see two control
transfer instructions having the same target, the likelihood that
they are data bytes is (very) low.
Hint II: Control Flow Crossing. As shown in the middle
ofFigure 4 (b), if there are three valid instructions instr 1,
instr 2andinstr 3, withinstr 2andinstr 3next to each other;
instr 3being the transfer target of instr 1, andinstr 2having
1190
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:41:52 UTC from IEEE Xplore.  Restrictions apply. 


Fig. 4: Control Flow Crossing
a control transfer target different from instr 3(and hence
crossing control Ô¨Çow edges), there is a good chance that they
are not data bytes (but rather instruction bytes). Figure 4 (a)
shows an example. Since it is highly unlikely data bytes can
form two control transfer instructions with one jumping to
right after the other, they are likely instructions. This control
Ô¨Çow relation is often induced by loopy language structures
(e.g., Figure 4 (c) with instr 1the loop head, instr 2the
last instruction of the loop body and instr 3the loop exit).
The probability analysis is similar to that of control Ô¨Çow
convergence and hence elided.
There are also other control Ô¨Çow related hints. For example,
if a valid control transfer instruction i(e.g., a jump) has a
target that does not occlude with the sequence starting from
i, the chance of idenoting data bytes is1
n, withnthe
average instruction length. This is because a false positive
jump (disassembled from random data bytes) may likely jump
to the middle of an instruction. Although this hint is not as
strong as the convergence and crossing hints, a large number
of such hints can be aggregated to form strong indication,
through an algorithm described in ¬ßIV.
Hint III: Register DeÔ¨Åne-use Relation. We say a pair of
instructions instr 1andinstr 2have a register deÔ¨Åne-use (def-
use) relation, if instr 1deÔ¨Ånes the value of a register (or some
Ô¨Çag bit) and instr 2uses the register (or the Ô¨Çag bit). In
Figure 5 (c), there are two def-use relations denoted by the
arrows, one induced by register rdx and the other by eax .
Another example is that a Ô¨Çag bit is set by a comparison
instruction, and then used by a following conditional jump
instruction. Given two valid instructions, if they have def-use
relation, they are unlikely data bytes.
Note that false positive instructions often do not have regis-
ter def-use although they may demonstrate (bogus) memory
def-use relations. Figure 5 (a) presents a snippet of jump
table disassembled to a sequence of instructions. Observe
that the Ô¨Årst instruction adds al to the memory location
indicated by rax whereas the second instruction adds cl to
the same location. There is a memory def-use between the
two instructions as the second instruction Ô¨Årst reads the value
stored in the location and then performs the addition. However,
as we will show in later probability analysis, register def-
use is hardly random, but rather caused by register allocation
(by compiler). Figure 5 (b) presents a snippet of string. It is
disassembled to a sequence of valid instructions too. Observe
that there are no register def-use relations.
Probability Analysis. Assume data byte values have uniform
distribution. To simplify our discussion, we further assumean arbitrary valid instruction has1
2chance to write to some
register or some Ô¨Çag bit (and the other1
2chance writing only
to memory). In contrast, an arbitrary valid instruction reading
some register is much more likely. Note that even a read from
memory often entails reading from register. For example, the
instruction at 0x4005ce inFigure 5 (c) performs a memory
read which entails reading rbp . Hence, we make an approx-
imation (just for the sake of demonstrating our probability
analysis), assuming the likelihood that an instruction reads
some register is 0.99. Each instruction has three bits to indicate
which register is being read/written-to according to the x86
instruction reference. As such, given two valid instructions
instr 1andinstr 2, they have register def-use with the chance
of1
2√ó1
23=1
16. In other words, when we observe def-use
between two valid instructions, the chance that they denote
data bytes is1
16.
We need to point out these hints only indicate the corre-
sponding bytes are not data bytes, they do not suggest the
valid instructions are indeed true positives . In other words,
they may be occluded instructions that are part of some ground
truth instructions. This is because occluded instructions often
share similar features such as the same register operand(s).
For instance, bytes ‚Äú 89 c2 ‚Äù, which is the sufÔ¨Åx of the Ô¨Årst
instruction in Figure 5 (c), is disassembled to MOV eax,
edx , which also has a register def-use with the second
instruction. However, observing these hints strongly suggests
that the corresponding bytes are instruction bytes. Fortunately,
the aforementioned occlusion rule dictates that even there
is occlusion, it will soon be automatically corrected. Our
disassembly technique is hence built on this observation.
Besides the register def-use hint, we have other hints that
denote data Ô¨Çow related program semantics. For example, an
instruction saving a register to a memory location followed
by another instruction that deÔ¨Ånes the register corresponds
toregister spilling [38], which can hardly be random. We
also consider memory def-use between instructions of different
opcodes. Details are elided.
IV . P ROBABILISTIC DISASSEMBLING ALGORITHM
As discussed in the previous section, when a probabilistic
hint is observed, we have certain conÔ¨Ådence that the cor-
responding bytes are not data bytes but rather instruction
bytes, although we are still uncertain if they are true positive
instructions as their occluded peers may have similar proper-
ties as well. The occlusion rule dictates that a sequence that
starts with some occluded instruction can quickly correct itself
and converge on true positive instructions. Therefore in our
method, we consider an instruction is likely a true positive if
multiple sequences with a large number of hints converge on
the instruction. Here, a sequence starting from an instruction
iis acquired by following the control Ô¨Çow (e.g., ifiis a
unconditional jump, the next instruction in the sequence would
be the target of the jump). We say multiple sequences converge
on an instruction if it occurs in all of them.
SpeciÔ¨Åcally, let a hint hhave a prior probability pbeing data
byte, with pcomputed by the analysis in the previous section.
1191
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:41:52 UTC from IEEE Xplore.  Restrictions apply. Fig. 5: Register DeÔ¨Ånition-use Relation
Fig. 6: Example for the algorithm; the code snippet in foo() corresponds to a statement ‚Äúfor (i=0;i<11;i++) ...‚Äù
Since the following instructions are acquired strictly following
the control Ô¨Çow semantics, they inherit the probability p.
Intuitively, if jis the next instruction of halong control Ô¨Çow,
j‚Äôs probability of being some data byte is equal to or smaller
thanp. When the sequences starting with multiple hints h1,
h2, ...hnconverge on an instruction i, the probability of
irepresenting data byte is D[i]=p 1√óp2√ó...√ópn.A s
such, when a large number of hints converge on i,iis highly
unlikely a data byte.
However, a small D[i]does not necessarily denote that i
is a true positive instruction. We then leverage the exclusion
property of a true positive instruction, that is, ifiis a true
positive instruction, all the other valid instructions occluding
withimust not be true positive instructions1.Therefore, we
compute the likelihood of ibeing a true positive instruction
by conducting normalization with all the instructions occluded
withi. Intuitively, if iis the only one that has a very small D[i]
compared to all the occluded instructions, iis highly likely true
positive. If there are occluded instructions whose Dvalues
are comparable to D[i], we cannot be certain that iis true
positive. In this case, we keep all these instructions just likesuperset disassembly. However, the key point is that due to the
occlusion rule, sequences quickly converge on true positivessuch that the occluded peers of the converged true positives arenot reachable by any sequences and hence receive no hints. As
such, the true positives stand out in most cases, the exceptionbeing very short and featureless code segments. According toour experiments (see ¬ßV), our technique never misses any true
1This property may not hold in manually crafted binaries in which the
developer purposely introduces occlusion between true positive instructions.
However, we focus on binaries generated by compilers in this paper.positive and has as low as 3.7% false positives. In comparison,
the false positive rate of superset disassembly is 85%.
Algorithm Details. Algorithm 1takes as input a binary B
which is an array of bytes indexed by address; a list of hints H
withH[i]=pmeaning that iis a hint with a prior probability
p(of being data bytes). It produces posterior probabilities P
withP[i]the likelihood that ibeing a true positive instruction.
Within the algorithm, we use D[i]to denote the probability i
being a data byte and RH[i]to denote the set of hints that
reachi, each hint represented by its address.
In lines 1-6, the algorithm initializes all the Dvalues and
all theRH values. If the bytes starting at idenote invalid
instruction, D[i]is set to 1.0, otherwise ‚ä•to denote that we
do not have any knowledge. Note that some byte sequences
cannot be disassembled to any valid instruction.
Due to the loopy structures in binary, the algorithm is overall
iterative, and terminates when a Ô¨Åx point is reached. Theiterative analysis is in lines 8-30 with variable fixed
point
used to determine termination. The analysis consists of threesteps: forward propagation of hints (lines 10-21), local prop-
agation within occlusion space (lines 22-24), and backward
propagation of invalidity (lines 25-30). The Ô¨Årst step traverses
from the beginning of Bto the end, propagating/collecting
hints and computing the aggregated probabilities. It leveragesthe following forward inference: (1) the control Ô¨Çow successor
of a (likely) instruction is also a (likely) instruction. Otherwise,the program is invalid because its execution would lead toexception (caused by the invalid instruction) following thecontrol Ô¨Çow. The second step is to propagate the computedprobability for each instruction itoits occlusion space con-
sisting of all the other addresses that can be decoded into
1192
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:41:52 UTC from IEEE Xplore.  Restrictions apply. Algorithm 1 Probabilistic Disassembling
Input: B- binary indexed by address
H - probabilistic hints, denoted by a mapping from
an address to a prior probability
Output: P[i]- posterior probability of an address idenoting
a true positive instruction
V ariable: D[i]- probability of address ibeing data byte
RH[i]- the set of hints, denoted by a set of addresses,
that reach an address i
1:for each address iinBdo
2: ifinvalidInstr (i)then
3: D[i]‚Üê1.0
4: else
5: D[i]‚Üê‚ä•
6:RH[i]‚Üê{ }
7:fixedpoint‚Üêfalse
8:while !fixedpoint do
9:fixedpoint‚Üêtrue
‚äøF orward propagation of hints ( Step I )
10: for each address ifrom start of Bto end do
11: ifD[i]‚â°1.0then
12: continue
13: ifH[i]/negationslash=‚ä•andi/negationslash‚ààRH[i]then
14: RH[i]‚ÜêRH[i]‚à™{i}
15: D[i]‚ÜêŒ†h‚ààRH [i]H[h]
16: for eachn, the next instruction of ialong control Ô¨Çow do
17: ifRH[i]‚àíRH[n]/negationslash={}then
18: RH[n]‚ÜêRH[n]‚à™RH[i]
19: D[n]‚ÜêŒ†h‚ààRH [n]H[h]
20: ifn<i then
21: fixedpoint‚Üêfalse
‚äøPropagation to occlusion space ( Step II )
22: for each address ifrom start of Bto end do
23: ifD[i]‚â°‚ä• and‚àÉjoccluding with i, s.t. D [j]/negationslash=‚ä•then
24: D[i]‚Üê 1-min joccludes with i(D[j])
‚äøBackward propagation of invalidity ( Step III )
25: for each address ifrom end of Bto start do
26: for eachp, the preceding instruction of ialong control Ô¨Çow do
27: ifD[p]‚â°‚ä• orD[p]<D[i]then
28: D[p]‚ÜêD[i]
29: ifp>i then
30: fixedpoint‚Üêfalse
‚äøCompute posterior probabilities by normalization
31: for each address ifrom start of Bto end do
32: ifD[i]‚â°1.0then
33: P[i]‚Üê 0
34: continue
35:s‚Üê1
D[i]
36: for each address j, representing an instruction occluded with ido
37: s‚Üês+1
D[j]
38:P[i]‚Üê1/D[i]
s
instructions occluding with i. It is to leverage the following
local inference: (2) an instruction being likely renders all the
other instructions in its occlusion space unlikely . The third
step traverses each address from the end to the beginning and
propagates invalidity of instructions. It leverages the following
backward inference: (3) when an instruction iis unlikely, all
the instructions that reach ithrough control Ô¨Çow are unlikely .
Intuitively, it is the logical contrapositive of the forward
inference rule (1). The Ô¨Årst step can be considered to identify
instruction bytes, whereas the second and third steps are to
identify data bytes.
Step I. In lines 13-15, if idenotes a hint and ihas not been
added to RH[i], it is added to RH[i]andD[i]is updated tothe product of the prior probabilities of all the hints in RH[i]
(line 15). In lines 16-21, the algorithm propagates the hints in
RH[i]toi‚Äôs control Ô¨Çow successor(s). Particularly, if RH[i]
has some hint that the successor ndoes not have (line 17), the
hints ofiare propagated to RH[n]by a union operation (line
18), andD[n]is updated. In lines 20-21, if the successor nhas
a smaller address so that it has been traversed in the current
round, the analysis needs another round to further propagate
the newly identiÔ¨Åed hint(s).
Step II. In lines 22-24, the algorithm traverses all the addresses
and performs local propagation of probabilities within occlu-
sion space of individual instructions. Particularly, for each
addressi, it Ô¨Ånds its occluded peer jthat has the minimal
probability (i.e., the most likely instruction). The likelihood
ofibeing data is hence computed as 1‚àíD[j](line 24).
Step III. Lines 25-30 traverse from the end to the beginning.
For each address i,if its control Ô¨Çow predecessor pdoes not
have any computed probability or has a smaller probability
(line 27), which intuitively means that we have more evidence
thatiis data (instead of instruction), then we set pto have
the same level of conÔ¨Ådence of denoting data bytes (line 28).
In the extremal case, if D[i]‚â°1.0,D[p]must be 1.0too.
Ifphas a larger address than iand hence pmust have been
traversed, variable fixedpoint is reset and the analysis will
be conducted for another round (lines 29-30).
Note that the control Ô¨Çow successors and predecessors are
implicitly computed along the analysis. Our analysis does not
require correctly recognizing indirect jump and call targets ,
which is a very difÔ¨Åcult challenge. In other words, even though
such control Ô¨Çow relations are missing, our technique can
still collect enough hints from (disconnected) code blocks to
disassemble correctly. In ¬ßV- D , we show that our technique
can disassemble without any function entry information with
0 false negatives and only 6.8% false positives.
After the iterative process, lines 31-38 compute the posterior
probabilities for true positive instructions by normalization. If
an instruction starting at iis invalid, P[i]is set to 0 (lines
32-33). Otherwise, it sums up the inverse of probability Dfor
all the instructions occluded with i, including iitself, to s;
thenP[i]is computed as the ratio between1
D[i]ands.
Example. Consider an example in Figure 6 . It is much simpler
than the one in ¬ßIIand allows easy explanation. The large box
on the left shows a code snippet denoting the beginning of a
function foo() (from 0x40058c to0x400594 ) and part
of the function body (from 0x4005c0 to0x4005e1 ) corre-
sponding to a simple loop ‚Äú for (i=0;i<11;i++)... ‚Äù.
The code snippet is preceded by data bytes that stand for
constant strings (from 0x40057b to0x40058b ). The strings
are disassembled to valid instructions. Note that symbolic
information is not available, we mark the function entry
and strings just for explanation purpose. Boxes A/circlecopyrt-F/circlecopyrt on
the right stand for sequences starting from some occluded
instructions. The instructions in the grey background denote
occlusions whereas instructions without background denote
the converged ones, which are horizontally aligned with the
1193
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:41:52 UTC from IEEE Xplore.  Restrictions apply. corresponding instructions in the leftmost box. For example,
in box A/circlecopyrt, disassembling at 0x40057c causes occlusion up
to0x400583 . In the following, we show how our algorithm
computes the probabilities for true positives.
During preprocessing, our technique collects the hints and
their prior probabilities. Each circled number denotes such a
hint (only part of the hints are shown). For example, 1/circlecopyrt is a
register-def-use hint (hint III in ¬ßIII-B ) due to rdi . According
to¬ßIII-B , the prior probability is1
16(being a data byte). Note
that this hint actually occurs in the data bytes. In addition,
2/circlecopyrtand 3/circlecopyrtstand for the register-spilling (i.e., backup and then
update) hint due to rbp andrsp , respectively; 4/circlecopyrt stands for
register-def-use; 5/circlecopyrt stands for control-Ô¨Çow-crossing (hint II
in¬ßIII-B ); and 6/circlecopyrt stands for memory-def-use. None of the
occluded sequences provide any additional hints.
Initially, D[0x400583 ]=D[0x40057e ]=1.0and all
otherD values are ‚ä•. In step I, hints are collected and
probabilities are computed in a forward fashion. Hint 1/circlecopyrt
cannot be propagated to address 0x400584 due to the bad
instruction at 0x400583 and the sequences in A/circlecopyrt and D/circlecopyrt do
not provide any hint, hence D[0x400584] = ‚ä•. Its occluded
peers in 0x400585 -0x400588 have the same Dvalue.
In contrast, D[0x40058c]=1
16due to the hint 2/circlecopyrt. Similarly,
D[0x40058d]=(1
16)3due to the three hints it is involved in.
As shown in boxes B/circlecopyrt, its occluded peer 0x40058e cannot
be reached from 0x40058c . As a result, it gets no hint and
D[0x40058e]=‚ä•. Similarly D[0x40058f]=‚ä•. Let us skip
a few instructions and consider 0x4005db . Due to the loop
(with the backedge 0x4005df ‚Üí0x4005c2 ), hints 2/circlecopyrt-6/circlecopyrt
all reach 0x4005db . As such, D[0x4005db]is a tiny value
smaller than1
232. In contrast, as shown in C/circlecopyrtand F/circlecopyrt, no hints
can reach its occluded peers 0x4005dc and0x4005dd and
theirDvalues remain ‚ä•. Through step II of local propagation
in occlusion space, D[0x40058f]=D[0x40058e]=1‚àí1
163
andD[0x4005dc]=D[0x4005dd]/similarequal1.
In step III, the invalidity information is propagated back-
ward. That is, if an address has a larger D value than its
predecessor, the predecessor inherits that D value. SpeciÔ¨Å-
cally, 0x400583 being invalid invalidates all its control Ô¨Çow
predecessors including 0x400582 ,0x400581 ,0x40057f ,
and0x40057b . That is, their Dvalues equal to 1.0.
In contrast, 0x40058d has two possible predecessors,
‚Äú0x40058b: 4c 55 rex.WR PUSH rbp ‚Äù (not shown
in the code snippet) and ‚Äú 0x40058c: 55 PUSH rbp ‚Äù
(shown in the code snippet). The former has the preÔ¨Åx
‚Äúrex ‚Äù that is only used in the long mode [ 39] and hence
does not form any hint with other instructions. Furthermore,
it occludes with 0x40058c . As a result, D[0x40058b]=
1‚àíD[0x40058c]=15
16after steps I and II. However, since
D[0x40058d]=1
163, which is smaller than D[0x40058b],
there is no backward propagation. Although D[0x40058e]=
1‚àí1
163is a large value, it does not have any control Ô¨Çow
predecessor, that is, it cannot be reached by disassembling at
any preceding addresses.
After the iterative process, the D values are
normalized to compute the posterior probabilities.For example, since 0x40058c only occludes with
0x40058b andD[0x40058b]=15
16,D[0x40058c]=1
16.
P[0x40058c]=16
16+16 /15=0.94 andP[0x40058b]=0.058 .
The other true positive instructions have higher than 0.99
probabilities. For instance, P[0x40058d]/similarequal0.9987 and
P[0x40058e]=P[0x40058f]/similarequal0.0006 .P[0x4005db]/similarequal1.0
andP[0x4005dc],P[0x4005dd]are negligible.
V. I MPLEMENT A TION AND EV ALUA TION
We have implemented a prototype on top of BAP [ 22] using
OCaml. Our implementation has 5,546 LOC. To evaluate
our technique, we use two sets of benchmarks. The Ô¨Årst set
contains 2,064 x86 ELF binaries collected from the BAP
corpora [ 22]. The size of these binaries ranges from 100KB to
3MB. They come with symbolic information, from which we
derive the ground truth. We stripped the binaries before ap-
plying our disassembler. The second set is the SPEC2006INT
programs. We used SPEC for the comparison with super set
disassembly [ 30]. All the experiments were run on a machine
with Intel i7 CPU and 16 GB RAM. Our evaluation addresses
the following research questions (RQ).
‚Ä¢RQ1: Can our technique disassemble binaries with accu-
racy, completeness, and efÔ¨Åciency ( ¬ßV- A )?
‚Ä¢RQ2: How does our technique compare with a state of
the art super set disassembly ( ¬ßV- B )?
‚Ä¢RQ3: How does our technique perform when data and
code are interleaved, in comparison with linear sweep
disassembly ( ¬ßV- C )?
‚Ä¢RQ4: How does our technique perform when no function
entry information is available (e.g., for indirect functions
that are one of the most difÔ¨Åcult challenges for traversal
disassemblers in IDA [ 23] and BAP [ 22]) (¬ßV- D )?
A. RQ1: Effectiveness and EfÔ¨Åciency
To answer RQ1, we perform four experiments: (1) measure
false negatives (missing true positive instructions) and false
positives (bogus instructions) on the 2,064 binaries; (2) mea-
sure the disassembling time; (3) analyze the contributions of
each individual kind of hints; (4) study the effect of different
probability threshold settings.
FP and FN. We report the results with the probability threshold
ofP> =0.01, meaning that we are very conservative and
hence keep all the valid instructions with more than 0.01 com-
puted posterior probability. In this setting, our technique does
not have any false negatives. Figure 7 shows the correlations
between binary size and the FP rate. Observe that most cases
cluster at bottom-left. Most medium to large binaries have
lower than 5% false positives. The a few largest (on the right)
are even lower than 2%. The ones with larger FP rates tend
to be small binaries, which have fewer hints. The average FP
rate is only 3.7%. This strongly suggests the effectiveness of
our technique.
Disassembling Time. Figure 8 shows the distribution of time.
Observe that it has a close-to-linear relation with the binary
size. The largest ones take about 10 minutes to disassemble.
1194
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:41:52 UTC from IEEE Xplore.  Restrictions apply. 
      	



Fig. 7: Binary Size and FP rate
	

      

Fig. 8: Size and Processing Time
The medium ones take 4-8 minutes. Our algorithm is not as
fast as other disassemblers because it is an iterative algorithm
based on probabilistic inference. Also, we have not optimized
implementation. We argue that since disassembling is one-time
effort, the cost is justiÔ¨Åable.
Contributions of Different Kinds of Hints. Figure 9 shows the
results for three settings: using only the control Ô¨Çow hints;
only the data Ô¨Çow hints (e.g., def-use and register-spilling);
and using all hints. The xaxis denotes intervals of the FP rate
and theyaxis represents the number of binaries that fall into
an interval. For example, with only control Ô¨Çow hints, about
300 binaries have less than 1% FPs; with only data Ô¨Çow hints,
about 70 binaries have less than 1% FPs; with all hints, the
number is 510. In other words, both types of hints are critical
for getting the best results.
Effects of Different Probability Thresholds. As mentioned

       	 
         	 

 !" 
Fig. 9: Distribution of Different Kinds of Hints
Fig. 10: Tradeoffs of Threshold Setting
earlier, we retain instructions whose computed probability
P>=Œ±.Figure 10 shows how the FP , FN rates (on the right
yaxis) and the percentage of precisely disassembled functions
(on the left yaxis) change with Œ±(thexaxis). For example,
at the starting point on the left is Œ±=0.67% (i.e., we keep
instructions with P> =0.0067 ), FP is about 4% and FN is
0, and 53.23% of the 607,758 functions in the corpora are
precisely disassembled. With the growth of Œ±, FP drops, FN
and the rate of precisely disassembled functions rise. At the
other end on the right is Œ±= 20% , FP is 0.6% whereas FN is
6.7%. Almost 73% of functions are precise.
B. RQ2: Comparison with Superset Disassembly
Linear sweep and traversal disassemblers suffer false nega-
tives, which may cause serious problems in binary rewriting.
Superset disassembler [ 30] is a state-of-the-art that does not
have false negatives. However, it introduces lots of false
positives, leading to size blowup in rewriting and unnecessary
runtime overhead. Table II shows the comparison with superset
disassembly. To compare the effects on binary rewriting, we
integrate our disassembler with their rewriter. We use the same
SPEC programs in [ 30] (column one). Columns 2-4 present
the FP rate, the code size blowup after rewriting, and the
execution time variation after rewriting, respectively. Here, we
do not add any instructions during rewriting. Columns 5-7
present the same information for our technique. Observe that
we reduce the size blowup from 763% to 404% and improve
the execution time by 3%. Note that it is normal that rewritten
binaries may execute faster than the original code [ 30] due to
the cache behavior changes caused by rewriting. Note that
although our technique still has 404% size inÔ¨Çation, it is
because the rewriter uses a huge lookup table to translate each
address in the code space. While all the entries are necessary
in superset rewriting, majority of these entries are not needed
in our rewriter, and therefore empty. We plan to remove the
empty table entries and replace it with a cost-effective hash
table in the future. The FP rate differences (columns 2 and 5)
indicate the large number of these redundant entries.
C. RQ3: Handling Data and Code Interleavings
A prominent challenge in disassembly is to handle data
and code interleavings (i.e., the presence of read-only data
in between code segments), which could cause false negatives
1195
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:41:52 UTC from IEEE Xplore.  Restrictions apply. Superset Disassembly Probabilistic Disassembly
Program FP Size (rewritten/orig) Exec. time (rewritten/orig) FP Size (rewritten/orig) Exec. time (rewritten/orig)
400.perlbench 85.32% 780% 116.71% 11.29% 427% 117.74%
401.bzip2 84.65% 779% 105.49% 6.57% 400% 97.30%
403.gcc 88.03% 751% 104.60% 11.33% 409% 101.71%
429.mcf 84.72% 749% 104.02% 4.60% 399% 104.74%
445.gobmk 90.27% 727% 103.43% 6.20% 372% 97.30%
456.hmmer 82.71% 779% 99.14% 6.64% 411% 94.12%
458.sjeng 87.08% 756% 98.83% 7.61% 407% 92.76%
462.libquantum 80.96% 758% 100.42% 4.04% 400% 96.94%
464.h264ref 82.36% 781% 100.39% 2.41% 395% 94.57%
471.omnetpp 85.02% 768% 105.24% 9.82% 420% 108.4%
473.astar 81.46% 761% 94.28% 3.90% 402% 93.24%
Avg 84.8% 763% 103.0% 6.8% 404% 99.9%
T ABLE II: Superset Disassembly vs Probabilistic Disassembly
	


Fig. 11: FP Rates In the Absence of Function Entries
in linear sweep disassembly. In this experiment,, we compile
SPECint 2000 benchmark by Visual Studio 2017 with different
optimization levels to generate a set of binaries. We extract
ground truth from pdb Ô¨Åles. We use both objdump, a linear
sweep disassembler, and our disassembler to disassemble the
stripped binaries. The comparison between the disassembled
results and the ground truth shows that objdump misses 3095
instructions in total, whereas our tool misses none. The average
FP rate of our tool is 8.12% (5.95%, 8.84%, 5.76%, and 8.98%
for optimization levels O1, O2, Od, and Ox, respectively).
The FP rate is higher than ELF binaries as data and code
interleavings are more common in PE binaries.
D. RQ4: Handling Missing Function Entries
Another prominent challenge, especially for traversal dis-
assembly, is missing function entries due to indirect calls. To
simulate such challenges, we eliminate all the function related
hints, such as call edges that have the same target (part of the
hint I). In other words, we only leverage the intra-procedural
hints to disassemble. Figure 11 presents the results, with x
axis the FP interval and yaxis the number of binaries. The
average FP rate is 6.8%, slightly higher than that of using both
inter- and intra-procedural hints. FN is still 0. This indicates
that in the cases where traversal disassemblers such as IDA
and BAP have troubles due to missing function entries, our
technique has substantial advantages.
VI. R ELA TED WORK
We have discussed existing disassembly techniques in ¬ßII.
In this section, we discuss other related works. Probabilis-
tic inference has been used in program analysis, such as
locating software faults [ 40], inferring explicit information
Ô¨Çow [ 41], and recognizing memory objects [ 42]. But to our
best knowledge, we are the Ô¨Årst one to use it in binarydisassembly. Machine learning has been used for binary
analysis. For instance, Wartell et. al. [ 43] used a statistical
compression technique to differentiate code and data. Shingled
Graph Disassembly [ 44] leverages graph model based learning
on a large corpus of binaries to recognize data bytes. Our
technique does not require training. Its formalization of using
a random variable to represent each address, the introduction
of hints and the fusion of these hints are unique. Dynamic
disassembly (e.g., [ 45], [ 46], [ 27], [ 1], [ 47]) disassembles
during execution. These approaches impose extra runtime
overhead. In addition, they can hardly serve downstream static
analysis such as dependence analysis. Disassembly has many
applications, such as binary hardening [ 6], [ 48], [ 49], [ 50],
[5], deobfuscation [ 51], [52], reassemble disassembling [ 53],
[54], [55], reverse engineering [ 56], and exploitation [ 57]. Our
work is particularly suited in rewriting and hardening.
VII. T HREA TS TO VALIDITY
Although we used the corpus from BAP and SPEC in our
experiments, the benchmarks may not represent all features
of real-world binaries. We will test our technique on more
binaries. We focus on binaries generated by compilers. It is
unclear how our technique will perform on obfuscated code
although we believe semantic hints still exist in such code.
VIII. C ONCLUSION
We propose a novel probabilistic disassembling technique
that can properly model the uncertainty in binary analysis. It
computes a probability for each address in the code space,
indicating the likelihood of the address representing a true
positive instruction. The probability is computed by fusing
a set of uncertain features that can reach the address. The
results show that our technique produce no false negatives
and as low as 3.7% false positives; and it substantially
outperforms a state-of-the-art superset disassembly technique.
ACKNOWLEDGMENT
The authors were supported in part by ONR
N000141410468, N000141712947, and N000141712995,
DARP A FA8650-15-C-7562, NSF 1748764, 1409668,
1834213, and 1834215, AFOSR FA95501410119, and Sandia
National Lab under award 1701331.
1196
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:41:52 UTC from IEEE Xplore.  Restrictions apply. REFERENCES
[1] D. L. Bruening, EfÔ¨Åcient, transparent, and comprehensive runtime code
manipulation . PhD thesis, Massachusetts Institute of Technology, 2004.
[2] M. Smithson, K. Anand, A. Kotha, K. Elwazeer, N. Giles, and R. Barua,
‚ÄúBinary rewriting without relocation information,‚Äù tech. rep., U. Mary-
land, 2010.
[3] M. P . T. cker Chiueh, A Binary Rewriting Defense against Stack based
Buffer OverÔ¨Çow Attacks . SUNY Stony Brook, 2003.
[4] A. M., B. M., E. U., and L. J.;, Control-Ô¨Çow integrity: principles,
implementations, and applications . University of California, Santa Cruz;
Microsoft Research.
[5] L. Davi, A. Dmitrienko, M. Egele, T. Fischer, T. Holz, R. Hund,
S. Nurnberger, and A.-R. Sadeghi, MoCFI: A framework to mitigate
control-Ô¨Çow attacks on smartphones . University of California, Santa
Barbara, 2012.
[6] R. Wartell, V . Mohan, K. Hamlen, and Z. Lin, ‚ÄúSecuring untrusted
code via compiler-agnostic binary rewriting,‚Äù in Proceedings of the
28th Annual Computer Security Applications Conference (ACSAC‚Äô12) ,
(Orlando, FL), December 2012.
[7] X. Chen, A. Slowinska, D. Andriesse, H. Bos, and C. Giuffrida,
‚ÄúStackarmor: Comprehensive protection from stack-based memory error
vulnerabilities for binaries.,‚Äù in NDSS , 2015.
[8] V . V an der V een, D. Andriesse, E. Goktas, B. Gras, L. Sambuc,
A. Slowinska, H. Bos, and C. Giuffrid, ‚ÄúPractical context-sensitive
cÔ¨Å,‚Äù in Proceedings of the 22nd ACM Conference on Computer and
Communications Security (CCS) , (Denver, Colorado), ACM, October
2015.
[9] V . van der V een, E. Goktas, M. Contag, A. Pawlowski, X. Chen,
S. Rawat, H. Bos, T. Holz, E. Athanasopoulos, and C. Giuffrida, ‚ÄúA
tough call: Mitigating advanced code-reuse attacks at the binary level,‚Äù
inProceedings of the 37th IEEE Symposium on Security and Privacy
(Oakland) , (San Jose, CA, USA), IEEE, May 2016.
[10] X. Chen, H. Bos, and C. Giuffrida, ‚ÄúCodeArmor: Virtualizing the Code
Space to Counter Disclosure Attacks,‚Äù in EuroS&P , Apr.
[11] L. Li and C. Wang, ‚ÄúDynamic analysis and debugging of binary code
for security applications,‚Äù in RV‚Äô13 .
[12] A. S√¶bj√∏rnsen, J. Willcock, T. Panas, D. Quinlan, and Z. Su, ‚ÄúDetecting
code clones in binary executables,‚Äù in Proceedings of the Eighteenth
International Symposium on Software Testing and Analysis (ISSTA‚Äô09) .
[13] F. Peng, Z. Deng, X. Zhang, and Z. S. Dongyan Xu, Zhiqiang Lin,
‚ÄúX-force: Force-executing binary programs for security applications,‚Äù
inUSENIX Security Symposium , 2014.
[14] I. G. T. M. A. R. Guanhua Wang, Sudipta Chattopadhyay, ‚Äúoo7: Low-
overhead defense against spectre attacks via binary analysis,‚Äù in CoRR
abs/1807.05843 , 2018.
[15] M. Bhme, V .-T. Pham, and A. Roychoudhury, ‚ÄúCoverage-based greybox
fuzzing as markov chain,‚Äù in ACM Conference on Computer and
Communications Security (CCS‚Äô16) .
[16] V .-T. Pham, M. Bhme, and A. Roychoudhury, ‚ÄúModel-based whitebox
fuzzing for program binaries,‚Äù in ASE‚Äô16 .
[17] V .-T. Pham, W . B. Ng, K. Rubinov, and A. Roychoudhury, ‚ÄúHercules:
Reproducing crashes in real-world application binaries,‚Äù in ICSE‚Äô15 .
[18] D. Gopan, E. Driscoll, D. Nguyen, D. Naydich, A. Loginov, and
D. Melski, ‚ÄúData-delineation in software binaries and its application
to buffer-overrun discovery,‚Äù in Proceedings of the 37th International
Conference on Software Engineering (ICSE‚Äô15) .
[19] Z. Xu, B. Chen, M. Chandramohan, Y . Liu, and F. Song, ‚ÄúSpain: Security
patch analysis for binaries towards understanding the pain and pills,‚Äù in
ICSE‚Äô17 .
[20] E. Tilevich and Y . Smaragdakis, ‚ÄúBinary refactoring: Improving code
behind the scenes,‚Äù in Proceedings of the 27th International Conference
on Software Engineering (ICSE‚Äô05) .
[21] N. Rosenblum, B. P . Miller, and X. Zhu, ‚ÄúRecovering the toolchain
provenance of binary code,‚Äù in Proceedings of the 2011 International
Symposium on Software Testing and Analysis (ISSTA‚Äô11) .
[22] I. Gotovchits, D. Brumley, J. Bosamiya, and R. V . Tonder, ‚ÄúBinary
analysis platform.‚Äù
[23] Hex-Rays, The Interactive Disassembler .
[24] O. Y uschuk, ‚ÄúOllydbg,‚Äù http://www. ollydbg. de/ , 2007.
[25] J. Kinder and H. V eith, ‚ÄúJakstab: A static analysis platform for binaries,‚Äù
inInternational Conference on Computer Aided V eriÔ¨Åcation , pp. 423‚Äì
427, Springer, 2008.[26] M. Smithson, K. Anand, A. Kotha, K. Elwazeer, N. Giles, and R. Barua,
Second Write: Binary Rewriting without Relocation Information . Uni-
versity of Maryland, 2010.
[27] A. R. Bernat and B. P . Miller, ‚ÄúAnywhere, any-time binary instrumen-
tation,‚Äù in Proceedings of the 10th ACM SIGPLAN-SIGSOFT workshop
on Program analysis for software tools , pp. 9‚Äì16, ACM, 2011.
[28] X. Meng and B. P . Miller, ‚ÄúBinary code is not easy,‚Äù in Proceedings
of the 25th International Symposium on Software Testing and Analysis ,
pp. 24‚Äì35, ACM, 2016.
[29] T. Bao, J. Burket, M. Woo, R. Turner, and D. Brumley, BYTEWEIGHT:
Learning to Recognize Functions in Binary Code . Carnegie Mellon
University; University of Chicago, 2014.
[30] E. Bauman, Z. Lin, and K. Hamlen, ‚ÄúSuperset disassembly: Statically
rewriting x86 binaries without heuristics,‚Äù in Proceedings of the 25th
Annual Network and Distributed System Security Symposium (NDSS‚Äô18) ,
(San Diego, CA), February 2018.
[31] D. Andriesse, X. Chen, V . van der V een, A. Slowinska, and H. Bos,
‚ÄúAn in-depth analysis of disassembly on full-scale x86/x64 binaries.,‚Äù
inUSENIX Security Symposium , pp. 583‚Äì600, 2016.
[32] N. E. Rosenblum, X. Zhu, B. P . Miller, and K. Hunt, ‚ÄúLearning to
analyze binary computer code.,‚Äù in AAAI , pp. 798‚Äì804, 2008.
[33] E. C. R. Shin, D. Song, and R. Moazzezi, ‚ÄúRecognizing functions
in binaries with neural networks.,‚Äù in USENIX Security Symposium ,
pp. 611‚Äì626, 2015.
[34] D. Andriesse, A. Slowinska, and H. Bos, ‚ÄúCompiler-agnostic function
detection in binaries,‚Äù in Security and Privacy (EuroS&P), 2017 IEEE
European Symposium on , pp. 177‚Äì189, IEEE, 2017.
[35] R. Qiao and R. Sekar, ‚ÄúFunction interface analysis: A principled
approach for function recognition in cots binaries,‚Äù in Dependable Sys-
tems and Networks (DSN), 2017 47th Annual IEEE/IFIP International
Conference on , pp. 201‚Äì212, IEEE, 2017.
[36] R. Qiao, Accurate Recovery of Functions in COTS Binaries . PhD thesis,
State University of New Y ork at Stony Brook, 2017.
[37] C. Linn and S. Debray, ‚ÄúObfuscation of executable code to improve
resistance to static disassembly,‚Äù in Proceedings of the 10th ACM
Conference on Computer and Communications Security (CCS‚Äô03) , 2003.
[38] A. V . Aho, M. S. Lam, R. Sethi, and J. D. Ullman, Compilers: Principles,
Techniques, and Tools (2Nd Edition) . Boston, MA, USA: Addison-
Wesley Longman Publishing Co., Inc., 2006.
[39] P . Guide, ‚ÄúIntel R/circlecopyrt 64 and ia-32 architectures software developers man-
ual,‚Äù V olume 3B: System programming Guide, Part , vol. 2, 2011.
[40] G. K. Baah, A. Podgurski, and M. J. Harrold, ‚ÄúThe probabilistic program
dependence graph and its application to fault diagnosis,‚Äù in Proceedings
of the 2008 International Symposium on Software Testing and Analysis ,
ISST A ‚Äô08, (Seattle, W A, USA), pp. 189‚Äì200, ACM, 2008.
[41] B. Livshits, A. V . Nori, S. K. Rajamani, and A. Banerjee, ‚ÄúMerlin:
SpeciÔ¨Åcation inference for explicit information Ô¨Çow problems,‚Äù in
Proceedings of the 30th ACM SIGPLAN Conference on Programming
Language Design and Implementation , PLDI ‚Äô09, (Dublin, Ireland),
pp. 75‚Äì86, ACM, 2009.
[42] Z. Lin, J. Rhee, C. Wu, X. Zhang, and D. Xu, ‚ÄúDimsum: Discovering
semantic data of interest from un-mappable with conÔ¨Ådence,‚Äù in Pro-
ceedings of the 19th Annual Network and Distributed System Security
Symposium (NDSS‚Äô12) , (San Diego, CA), February 2012.
[43] R. Wartell, Y . Zhou, K. W . Hamlen, M. Kantarcioglu, and B. Thurais-
ingham, ‚ÄúDifferentiating code from data in x86 binaries,‚Äù in Proceedings
of the European Conference on Machine Learning and Principles
and Practice of Knowledge Discovery in Databases (ECML PKDD)
(D. Gunopulos, T. Hofmann, D. Malerba, and M. V azirgiannis, eds.),
vol. 3, (Athens, Greece), pp. 522‚Äì536, September 2011.
[44] R. Wartell, Y . Zhou, K. W . Hamlen, and M. Kantarcioglu, ‚ÄúShingled
graph disassembly: Finding the undecideable path,‚Äù in PaciÔ¨Åc-Asia
Conference on Knowledge Discovery and Data Mining , pp. 273‚Äì285,
Springer, 2014.
[45] D. Bruening, T. Garnett, and S. Amarasinghe, ‚ÄúAn infrastructure for
adaptive dynamic optimization,‚Äù in Code Generation and Optimization,
2003. CGO 2003. International Symposium on , pp. 265‚Äì275, IEEE,
2003.
[46] H. Patil, R. Cohn, M. Charney, R. Kapoor, A. Sun, and A. Karunanidhi,
‚ÄúPinpointing representative portions of large Intel Itanium programs
with dynamic instrumentation,‚Äù in Proc. 37th IEEE/ACM International
Sym. on Microarchitecture , pp. 81‚Äì92, 2004.
[47] Nanda, W . Li, and L.-C. Lam, BIRD: binary interpretation using runtime
disassembly . SUNY , Stony Brook, 2006.
1197
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:41:52 UTC from IEEE Xplore.  Restrictions apply. [48] M. Smithson, K. ElWazeer, K. Anand, A. Kotha, and R. Barua, ‚ÄúStatic
binary rewriting without supplemental information: Overcoming the
tradeoff between coverage and correctness,‚Äù in 2013 20th Working
Conference on Reverse Engineering (WCRE) , pp. 52‚Äì61, IEEE, 2013.
[49] M. Wang, H. Yin, A. V . Bhaskar, P . Su, and D. Feng, ‚ÄúBinary code
continent: Finer-grained control Ô¨Çow integrity for stripped binaries,‚Äù
inProceedings of the 31st Annual Computer Security Applications
Conference , pp. 331‚Äì340, ACM, 2015.
[50] P . O‚ÄôSullivan, K. Anand, A. Kotha, M. Smithson, and R. B. A. D.
Keromytis, RetroÔ¨Åtting Security in COTS Software with Binary Rewrit-
ing. University of Maryland; Columbia University, 2011.
[51] C. Kruegel, W . Robertson, F. V aleur, and G. Vigna, Static Disassembly
of Obfuscated Binaries . Reliable Software Group; University of Santa
Barbara, 2004.
[52] C. Kruegel, W . Robertson, F. V aleur, and G. Vigna, ‚ÄúStatic disassembly
of obfuscated binaries,‚Äù in USENIX security Symposium , vol. 13, pp. 18‚Äì
18, 2004.
[53] S. Wang, P . Wang, and D. Wu, ‚ÄúReassembleable disassembling.,‚Äù in
USENIX Security Symposium , pp. 627‚Äì642, 2015.
[54] S. Wang, P . Wang, and D. Wu, ‚ÄúUroboros: Instrumenting stripped
binaries with static reassembling,‚Äù in Software Analysis, Evolution, and
Reengineering (SANER), 2016 IEEE 23rd International Conference on ,
vol. 1, pp. 236‚Äì247, IEEE, 2016.
[55] R. Wang, Y . Shoshitaishvili, A. Bianchi, A. Machiry, J. Grosen,
P . Grosen, C. Kruegel, and G. Vigna, ‚ÄúRamblr: Making reassembly great
again,‚Äù 2017.
[56] M. Sharif, V . Y egneswaran, H. Saidi, P . Porras, and W . Lee, ‚ÄúEureka: A
framework for enabling static malware analysis,‚Äù in European Sympo-
sium on Research in Computer Security , pp. 481‚Äì500, Springer, 2008.
[57] G. Hoglund and J. Butler, Rootkits: Subverting the Windows Kernel ,
ch. 4: The Age-Old Art of Hooking, pp. 73‚Äì74. Pearson Education,
Inc., 2006.
1198
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:41:52 UTC from IEEE Xplore.  Restrictions apply. 