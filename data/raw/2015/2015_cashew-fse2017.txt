Constraint Normalization and Parameterized Caching for
Quantitative Program Analysis∗
Tegan Brennan, Nestan Tsiskaridze, Nicolás Rosner, Abdulbaki Aydin, and Tevfik Bultan
Department of Computer Science, University of California Santa Barbara, CA
{tegan,nestan,rosner,baki,bultan}@cs.ucsb.edu
ABSTRACT
We present a constraint caching framework to expedite potentially
expensive satisfiability and model-counting queries. Integral to this
framework is our new constraint normalization procedure under
which the cardinality of the solution set of a constraint, but not
necessarily the solution set itself, is preserved. We extend these
constraint normalization techniques to string constraints in order
to support analysis of string-manipulating code. We use a group-
theoretic framework, which generalizes earlier results, to express
our normalization techniques. We also present a parameterized
caching approach where, in addition to storing the result of a model-
counting query, we store a model-counter object that allows us to
efficiently recount the number of satisfying models for different
bounds. We implement these techniques in our tool Cashew , which
is built as an extension of the Green caching framework [ 55], and
integrate it with the symbolic execution tool Symbolic PathFinder
(SPF) and the model-counting constraint solver ABC. Our experi-
ments show that constraint caching can significantly improve the
performance of symbolic and quantitative program analyses. For
instance, Cashew can normalize the 10,104 unique constraints in
the SMC/Kaluza benchmark down to 394 normal forms, achieve
a 10x speedup on the SMC/Kaluza-Big dataset, and an average 3x
speedup in our SPF-based side-channel analysis experiments.
CCS CONCEPTS
•Software and its engineering →Formal software verification ;
KEYWORDS
Constraint caching, quantitative program analysis, model counting,
string constraints
ACM Reference Format:
Tegan Brennan, Nestan Tsiskaridze, Nicolás Rosner, Abdulbaki Aydin, and
Tevfik Bultan. 2017. Constraint Normalization and Parameterized Caching
∗This material is based on research sponsored by NSF under grant CCF-1548848 and
by DARPA under the agreement number FA8750-15-2-0087. The U.S. Government is
authorized to reproduce and distribute reprints for Governmental purposes notwith-
standing any copyright notation thereon. The views and conclusions contained herein
are those of the authors and should not be interpreted as necessarily representing the
official policies or endorsements, either expressed or implied, of DARPA or the U.S.
Government.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
ESEC/FSE’17, September 4–8, 2017, Paderborn, Germany
©2017 Association for Computing Machinery.
ACM ISBN 978-1-4503-5105-8/17/09. . . $15.00
https://doi.org/10.1145/3106237.3106303for Quantitative Program Analysis. In Proceedings of 2017 11th Joint Meeting
of the European Software Engineering Conference and the ACM SIGSOFT
Symposium on the Foundations of Software Engineering, Paderborn, Germany,
September 4–8, 2017 (ESEC/FSE’17), 12 pages.
https://doi.org/10.1145/3106237.3106303
1 INTRODUCTION
Improvements in the area of satisfiability modulo theories [ 10,12]
and powerful SMT solvers [ 11,20,21] have been key technologi-
cal developments enabling the rise of effective symbolic program
analysis and testing techniques in the last decade [15, 27, 32, 48].
Performing symbolic analysis via satisfiability checking, how-
ever, is not sufficient for quantitative program analysis , which is an
important problem that arises in many contexts such as probabilistic
analysis [ 14,24,38], reliability analysis [ 22] and quantitative infor-
mation flow [ 7,17,28,40,41,43–45,50,53]. The enabling technol-
ogy for quantitative program analysis is model-counting constraint
solvers. A model-counting constraint solver returns the number of
solutions for a given constraint within a given bound [6, 8, 39].
Since constraint solving and model counting are heavily used
in program analysis, improving performance of these tasks is of
critical importance. In this paper, we present a new approach for
constraint normalization and constraint caching with the goal of
improving the performance of quantitative program analyses.
The key step in constraint caching is normalization of constraints,
i.e., reducing constraints to a normal form, where two constraints
are reduced to the same form only if they are equivalent (w.r.t.
satisfiability or model counting). Using the normal form of a con-
straint as a key, we can recover results of previous satisfiability or
model-counting queries without recomputing them.
Earlier techniques for constraint caching [ 4,31,55] 1) focus only
on numeric constraints and do not handle string constraints, 2) use
normalization techniques that preserve the exact solution set of a
constraint, which reduces cache hits for model-counting queries,
and 3) always produce cache misses for model-counting queries if a
different bound is used, even if the queried constraint remains the
same. In this paper, we extend earlier results in multiple directions:
•We present constraint normalization techniques for model
counting under which the solution set of the constraint may
not be preserved but its cardinality is.
•We extend constraint caching to string constraints which is
crucial for analyzing string manipulating code.
•We present a parameterized caching approach where, in
addition to the result of a model-counting query, we also
cache a counter object in the constraint cache that allows us
to efficiently recount the models for different bounds.
•We formalize our normalization scheme using an extensible
group-theoretic framework for constraint normalization that
535ESEC/FSE’17, September 4–8, 2017, Paderborn, Germany T. Brennan, N. Tsiskaridze, N. Rosner, S. Aydin, and T. Bultan
generalizes earlier results on constraint normalization for
caching.
We implemented these techniques in our tool Cashew , which is built
as an extension of the Green caching framework [ 55]. We integrated
Cashew with Symbolic PathFinder (SPF) [ 42] and the ABC [ 6]
model-counting constraint solver. Our experiments demonstrate
that constraint caching can improve the performance of quantitative
program analysis significantly.
The paper is organized as follows: In Section 2 we provide some
motivating examples for constraint caching. In Section 3 we give
an overview of our constraint caching framework. In Section 4 we
discuss our group-theoretic normalization scheme. In Section 5 we
describe the constraint language we support. In Sections 6 and 7
we present the constraint normalization procedure. In Section 8 we
present our experiments. In Section 9 we discuss related work. In
Section 10 we present our conclusions. In Section 11 we describe
how to obtain and use the implementation.
2 MOTIVATION
The amount of string-manipulating code in modern software appli-
cations has been increasing. Common uses of string manipulation
include: 1) Input sanitization and validation in web applications;
2) Query generation for back-end databases; 3) Generation of data
formats such as XML and HTML; 4) Dynamic code generation; 5)
Dynamic class loading and method invocation. In order to analyze
programs that use string manipulation, it is necessary to develop
techniques for efficient manipulation of string constraints. Recently,
there has been significant amount of work in string constraint solv-
ing to address this problem [ 2,23,29,30,33–36,47,52,57]. One of
our contributions in this paper is a constraint normalization and
caching framework that can handle string constraints.
Consider the following string constraint F:
b=“https ”∧prefix _of(b,url )∧c=“?”∧contains (c,url )
∧w∈(0|1)+∧index _of(w,url )=8
The solution set of Fis the set of values that can be assigned to the
string variables b,c,w, and urlfor which Fevaluates to true.
Constraints such as Fcommonly arise in symbolic program anal-
ysis. For example, Fmight correspond to a path constraint generated
during symbolic execution of a string-manipulating program. A fun-
damental question about a constraint Fgenerated during program
analysis is its satisfiability. Symbolic program analysis techniques
generate numerous satisfiability queries while analyzing programs.
Given that satisfiability checking is computationally expensive, it
is crucial to answer satisfiability queries efficiently in order to build
scalable symbolic program analysis tools.
On the other hand, quantitative program analysis techniques
ask another type of question while analyzing programs. Assume
that we bound the length of the string variables b,c,w, and urlin
constraint Fto 5. How many different string values are there for
the variable bsuch that the constraint Fis satisfiable within the
given bound? These types of queries can be answered by model-
counting constraint solvers. Again, due to the high complexity of
model counting, answering model-counting queries efficiently is
crucial for quantitative program analysis.Now, consider the following string constraint G:
k=“#”∧w=“http : ”∧contains (k,var0)∧z∈(1|0)+
∧index _of(z,var0)=8∧prefix _of(w,var0)
Constraint Gis a constraint on string variables k,z,w, andvar0.
Assume that constraints FandGare generated during program
analysis and it is necessary to check the number of satisfying so-
lutions and satisfiability of each. Can we avoid making redundant
calls to the constraint solver? Note that the solution sets of Fand
Gare different since different string constants appear in these two
constraints. However, the satisfiability and the cardinality of the so-
lution sets for these two constraints are identical. Hence, if we were
able to detect the relationship between the number of satisfying
models of FandGand had stored the result of a model-counting
query on F, then when we see Gwe do not have to call the model-
counting constraint solver again. Same for satisfiability queries.
The problem of reusing information about Fto answer our ques-
tions about Ghas now been reduced to finding a fast way to deter-
mine that FandGare equivalent with respect to satisfiability and
model counting. In this paper, we present a constraint normaliza-
tion scheme to determine this type of equivalence. Based on our
scheme, the normalized form of FandGare identical:
v0=“a”∧v1=“bccde ”∧contains (v0,v2)
∧prefix _of(v1,v2)∧v3∈(f|д)+∧index _of(v3,v2)=8
Hence, given a constraint, to determine if an equivalent constraint
has already been encountered, we normalize it and check if its
normal form was seen previously. Using a constraint store to cache
the results of prior queries to the solver, we avoid redundant queries
for constraints that have the same normalized form.
For both satisfiability and model-counting queries, we can cache
the result of the query in a constraint store, use normalization to
determine equivalence of constraints, and then reuse the query
results from the store when we get a cache hit. However, since
model-counting queries come with a bound parameter, in order
for the query to match, the bound also has to match. While this
limits our ability to reuse results in the most general case, there
is a class of model-counting constraint solvers whose results can
be reused even is the case of mismatched bounds. Parameterized
model-counting techniques [ 6,39] not only count the number of
solutions for a constraint within a given bound, but also generate a
model counter that can count the number of solutions for any given
bound. Note that counting the number of solutions with different
bounds may be necessary during program analysis. For example,
consider the following constraint which has no solutions for bounds
less than 5 but has satisfying solutions for higher bounds:
contains (x,“abcde ”)∧|y|>|x|∧y∈(ab)∗
In this paper, we present a parameterized caching approach
that utilizes parameterized model-counting constraint solvers. We
assume that, in response to a model-counting query, parameterized
model-counting constraint solvers return a model-counter object
that can be used to count the number of models for any given bound.
By storing the model-counter object, we are able to reuse model-
counting query results even for queries with different bounds.
536Constraint Normalization and Parameterized Caching for
Quantitative Program Analysis ESEC/FSE’17, September 4–8, 2017, Paderborn, Germany
Conjunct sorterVariable renamerString alphabet renamerConstant shifterStore
SolverTranslatorClient
ReuseMgrModel-counter object evaluator⟦ F , V, b ⟧⟦ F , V, b ⟧#(F , v, b)M-c object, ⟦ b ⟧Normalization procedure⟦ F , V, b ⟧F , v, b⟦ F , V ⟧
Figure 1: Architecture of Cashew
3 CONSTRAINT CACHING
Our tool Cashew , depicted in Figure 1, is designed to work with a
wide range of model-counting solvers to support quantitative pro-
gram analyses. Algorithm 1 outlines how Cashew handles model-
counting queries. Cashew expects a query of the form (F,V,b),
where Fis a well-formed formula, Vis a set of variables in F, and b
is a bound. The answer to the query, denoted as #(F,V,b), is the
number of satisfying solutions for Ffor the variables in Vwithin the
bound b. We normalize the formula, variable(s) and bound using our
normalization procedure, Normalize-Query , which is described in
the following sections. The resulting normalized query is denoted
as⟦F,V,b⟧=Normalize-Query (F,V,b).
Depending on the capabilities of the selected model-counting
constraint solver, ⟦F,V,b⟧is queried differently. Algorithm 1 out-
lines the normalization and query process. Typical model-counting
constraint solvers [ 16,37,51], return a single count value ( #(F,v,b))
after receiving a query of the form (F,V,b). For such solvers, our
caching algorithm first sends the query ⟦F,V,b⟧to the cache store.
If there is a cache hit, the result is returned to the client. If not,
the normalized query is sent to the model-counting solver, and the
result is stored under ⟦F,V,b⟧and returned to the client.
We call a model-counting constraint solver paramaterized if it
returns a model-counter object that can be used to compute the
number of satisfying solutions for an arbitrary bound. ABC [ 6]
is a parameterized model-counting constraint solver where the
model-counter object is the transfer matrix of an automaton that
accepts all satisfying models of the given constraint. SMC [ 39] and
barvinok [ 54] are also parameterized model-counting constraint
solvers where the model-counter object is a generating function.
For parameterized solvers, the store is queried as follows: First,
⟦F,V,b⟧is queried. On a hit, the result ( #(F,V,b)) is returned to
the client. In the case of a miss, an additional query for ⟦F,V⟧is
made. If this results in a hit, the model-counter object for ⟦F,V⟧is
recovered from the store. This model-counter object is sent to the
model-counter evaluator which evaluates #(F,V,b)based on ⟦b⟧.
The result returned by the model-counter evaluator is stored under
⟦F,V,b⟧and is returned to the client. If both queries are misses,
the selected solver is called, the model-counter object is computed
and cached under the key ⟦F,V⟧, and #(F,V,b)is evaluated based
on⟦b⟧, stored under ⟦F,V,b⟧and returned to the client.In order to use Cashew ’s parameterized caching functionality
and reuse cached model-counter objects, a service that is able to take
a model-counter object (such as a transfer matrix or a generating
function) and evaluate it for a particular bound is required. This
service is referred to as the model-counter evaluator.
Algorithm 1 Constraint-Caching (F,V,b):
Input: A query (F,V,b).
Output: The number of satisfying solutions of VinFunder the length bound b.
1:⟦F,V,b⟧=Normalize-Query (F,V,b)
2:ifHit on ⟦F,V,b⟧then
3: return #(F,V,b)
4:end if
5:ifHit on ⟦F,V⟧then
6: Evaluate the model-counter object for bound ⟦b⟧using the model-counter
evaluator;
7: Store the result under ⟦F,V,b⟧
8: return #(F,v,b)
9:end if
10:Translate ⟦F,V,b⟧andsend it to the selected model-counting solver
11:Store the returned model-counter object under ⟦F,V⟧
12:Store #(F,V,b) under ⟦F,V,b⟧
13:return #(F,V,b)
4 GROUP-THEORETIC FRAMEWORK
The goal of normalization is to reduce constraints equivalent un-
der some property to the same form. This objective is shared by
work in constraint programming, where detecting symmetries in
constraints leads to a more efficient search [ 18,19,25]. Symmetry-
breaking for constraint programming is expressed using concepts
from group theory [ 3,26,49], a formalization we find fitting and
intuitive for our purposes and adopt.
Our framework provides a means for constructing normal forms
of constraints based on groups of property-preserving transfor-
mations. For different analysis problems, it might be necessary to
preserve the entire solution set, the cardinality of the solution set,
or only the satisfiability of constraints, each corresponding to a dif-
ferent level of normalization. Our framework is equally applicable,
regardless of the desired level of normalization. Our framework is
also not restricted to a constraint language, but is equally applicable
to any background theory on which a group of property-preserving
transformations can be defined.
Symmetry Groups. A group (G,op)is a set of elements together
with a binary operator that satisfies the four group axioms: closure,
associativity, identity, and invertibility. For example, the set of
all transpositions on the natural numbers, N, under the binary
operator function composition form a group. The transposition
fromNto itself defined by the relation {(1,2),(2,1)}is an example
of an element of this group which maps 1 to 2, 2 to 1 and all other
elements of Nto themselves.
A subset of a group is called a subgroup if it also forms a group un-
der the same binary operator. We construct the group of cardinality-
preserving transformations under composition (Gcard,◦)by intro-
ducing its generating subgroups. As composition is the only bi-
nary operator we consider, we simply refer to this group as Gcard
throughout the remainder of the paper.
Solution-Set-Preserving Subgroups of Gcard.A solution-set-preser-
ving transformation is one under which the solution set is mapped
537ESEC/FSE’17, September 4–8, 2017, Paderborn, Germany T. Brennan, N. Tsiskaridze, N. Rosner, S. Aydin, and T. Bultan
to itself. Any solution-set-preserving transformation is trivially
cardinality-preserving. Each generating subgroup acts on a par-
ticular domain related to some feature of a constraint. The first
generating subgroup we introduce acts on I, the domain of all
possible indices of conjuncts in a constraint. Here, we consider the
index of a conjunct to be its position in that constraint when read
from left-to-right, making Isimply the set of natural numbers. The
subgroup acting on Iis the group mentioned previously — that of
all transpositions on Nor identically, the permutation group whose
elements fix all but a finite number of numbers.
Intuitively, this subgroup captures our understanding that the
solution set of a constraint is independent of the order of the con-
juncts in it. Under the transposition {(1,2),(2,1)}, for example, the
formula x>0∧y<0is mapped to y<0∧x>0, making the two
orderings equivalent modulo the action of this group.
Our second solution-set-preserving subgroup is the transposition
group acting on V, the infinite domain of all allowable variable
names. Since the solution set of a constraint is independent of
the choice of variable names, two constraints that are equivalent
modulo the action of this group have the same solution set. As a
simple example, realize that both wandxare elements of Vand
that the number of solutions for x<7∧x>2is the same as that
of its mapping under the relation {(x,w),(w,x)}:w<7∧w>2.
Cardinality-Preserving Subgroups of Gcard.Preserving only the
cardinality of the solution set of a constraint enables the use of sub-
groups with less constrained group actions. Under these groups, the
solution set of a constraint is bijectively mapped to the solution set
of another constraint, leaving the number of solutions unchanged.
Our first family of cardinality-preserving subgroups are given by
the Euclidean groups E(n)(symmetry groups on Euclidean space)
acting on the solution space of linear integer arithmetic constraints.
The elements of these groups are Euclidean motions such as trans-
lations, rotations and indirect isometries such as reflection. Under
these symmetries of Euclidean space, the volume captured by the
corresponding polytope remains unchanged.
Though this volume is preserved under any action of the Eu-
clidean group, some actions impact the number of lattice points in
the polytope. Because we are often interested in the number of inte-
ger solutions to a constraint, we limit ourselves to considering only
those transformations that preserve the number of lattice points
as well as those that can be easily reflected through changes in the
syntax of the constraint. In particular, our normalization scheme
uses the subgroup of integral translations in Euclidean space as a
generating subgroup for Gcard. Integral translations can be reflected
syntactically in integer constraints through changes in the constant
terms of each conjunct. Each constant term must be identically
shifted by an integral amount. For example, shifting each constant
term of the constraint x+y=2∧x≥0∧y≥0by 2 results in the
constraint x+y=4∧x≥2∧y≥2which has the same number
of integer solutions (6) as the original.
For any arithmetic constraint, F, the shift ofF, denoted Shift (F),
is the vector composed of the constant terms of each of its conjuncts.
SH denotes the domain of all possible shifts. The subgroup of inte-
gral translations thus acts on SH. For string or mixed constraints,
we do not apply transformations from this subgroup and we say
thatShift (F)of such constraints is ∅.Our second cardinality-preserving subgroup is given by the per-
mutation group on the string alphabet, Σ. The solution set of a
string constraint can be canonically represented by an automaton
that accepts exactly the set of solutions to that constraint. Transi-
tions between states are made based on a set of allowed alphabet
symbols. Permuting the alphabet symbols thus changes the strings
accepted by that automaton but not the cardinality of the accepted
set. As a simple example, the number of solutions of the constraints
F:=x.contains (“ac”)andF′:=x.contains (“bd”)is the same.
Orbits under the Symmetry Group Gcard.These subgroups gen-
erateGcardin the following sense: the domain of any element of
Gcardis the union of the domains of the subgroups, making it the
Cartesian product I×V×SH× Σ. Every element of a subgroup
acts as an element of Gcardby acting as the identity on every do-
main element on which it is not defined. Any element of Gcardcan
be written as a composition of elements from these subgroups.
For a constraint F, the orbit ofFunderGcardis the set of con-
straints obtained by applying any element σ∈G cardtoF.
The problem of choosing a normalized form for Fcan now be
formulated as choosing a representative constraint from the orbit of
FunderGcard. We do this by defining a strict ordering on constraints
and choosing the well-defined lowest ordered constraint within the
orbit as the representative for all constraints within the orbit.
While we have spoken generally about cardinality-preserving
group actions, our application of interest is in parameterized model-
counting which involves finding the number of satisfying solutions
to a constraint for any given bound. While most of the group actions
defined above preserve the number of solutions for a given bound,
the elements of the Euclidean group may not. For example, x+
y=2∧x≥0∧y≥0has 6 solutions given a bound of 2 but
x+y=4∧x≥2∧y≥2, which is in the same orbit under Gcard,
has only one solution for the same bound. In order to preserve
the parameterized model count, the bound is translated according
to the same group action as the constraint. In the example above,
bound 2 is translated to bound 4 by the same integer translation (2)
that translated the shift, resulting in 6 satisfying models.
In a similar vein, it’s interesting to note that though not all of
our transformations preserve the solution set of a constraint, all of
them are invertible. This means that the solution set of a constraint
can be obtained from the solution set of its normal form by applying
the inverse transformations of those applied to ΣandSH when
normalizing the constraint to the solution set of its normal form.
This enables our transformations to be used even for analyses that
require the solution sets of constraints.
5 CONSTRAINT LANGUAGE
We focus on constraints over strings and linear integer arithmetic.
We define three types of terms: string terms TS, regular expression
termsTR, and LIA termsTA, as described in Figure 2. We consider
three types of constraints over these terms, which we call conjuncts
throughout this paper: string conjuncts S, regular membership
conjuncts R, and LIA conjuncts A. The conjuncts are built using
comparators as described in Figure 3. L is a language defined over
these conjuncts. Input constraints to our normalization procedure
are assumed to be in conjunctive form, with each conjunct from L.
538Constraint Normalization and Parameterized Caching for
Quantitative Program Analysis ESEC/FSE’17, September 4–8, 2017, Paderborn, Germany
TSBc|vS|TS·TS|char_at(TS,TA)|int_to_str (TA)|
replace (TS,TS,TS)|substr (TS,TA,TA)
TRBϵ|s|(TR)|TR·TR|TR|TR|T∗
R
TABn|vA|−T A|(TA)|TA+TA|TA−TA|TA×n|
n×TA||TS||index _of(TS,TS)|str_to_int (TS)
Figure 2: Here c∈Σ,n∈Z,s∈Σ∗,vSand vAdenote an
unbounded string variable and an integer variable, resp.
LB⊤|⊥| S|R|A
SBTS=TS|TS,TS|contains (TS,TS)|prefix _of(TS,TS)|
suffix _of(TS,TS)|not_contains (TS,TS)|
not_prefix _of(TS,TS)|not_suffix _of(TS,TS)
RBTS∈TR|TS<TR
ABTA=TA|TA<TA|TA≤TA|TA,TA
Figure 3: The language L: conjuncts of string (S), regular ex-
pression (R)and LIA (A)types.
LetSopbe the set of string operators, i.e. the operators used to
build theTSterms. Let Scomp be the set of string comparators, i.e.
the comparator used to build Sconjuncts. Similarly, let Ropbe the
set of regular expression operators used in TR;Rcomp – the set of
regular expression comparators used in R;Aop– the set of the LIA
operators used inTA; and Acomp – the set of LIA comparators used
inA. Let a function Type :S∪R∪A−>Scomp∪Rcomp∪Acomp
be a function that takes in a conjunct and returns the comparator
of this conjunct.
6 CONSTRAINT ORDERING
Assume a strict total ordering on constraints, ≺. A constraint Fis a
normal form if for every other constraint F′in its orbit underGcard,
F≺F′. There are many ways to impose an ordering on constraints.
We present one possible ordering below.
Our ordering is produced compositionally, with strict orders
defined over various components of our language which are com-
posed to yield an ordering on constraints. To start, we define an
ordering on each element of the domain of Gcard.
The ordering on both VandΣis lexicographical. The ordering on
Iis that induced by the natural numbers. We define the ordering on
SH, the domain of constant shifts, after we introduce an ordering
on vectors. We consider vectors over strict totally ordered sets and
denote by≺vecan order on such vectors.
LetXbe a strict totally ordered set, and ≺Xbe a strict total order
onX. Letv=(v0, . . . ,vn)andu=(u0, . . . , um)be two vectors
over X, then≺vecis defined as:
v≺vecu⇐⇒m<n,or
m=n,∃i∀j:j<i<n,vj=uj,vi≺Xui.
This defines ordering on SH since shift vectors are built over
integer constants.
Our normalization procedure relies on the following auxiliary
functions that given a constraint return, as vectors, various struc-
tural and syntactic components characterizing the constraint. These
vectors are built over the domains of V,ΣandZ, i.e. over strict
totally ordered sets.VI (F)— returns a vector of the indices of variables as they occur
inFrelative to other variables, constants and operators. The
indices are compared according to the “ <” operator over Z.
Int (F)— returns a vector of integer constants occurring in Ffrom
left to right, ignoring all elements of Shift (F). The vectors are
compared according to the “ <” operator on Z.
VVV(F)— returns a vector of variable names occurring in Ffrom
left to right. These vectors are compared according to the lexi-
cographical order on V.
ΣΣΣ(F)— returns a vector of string characters occurring in Ffrom
left to right. The vectors are compared according to the lexico-
graphical order on Σ.
Next, we define strict total orderings on operators and (sepa-
rately on) comparators, listing them in the order of the increasing
precedence. Both operators and comparators, are ordered with
precedence to S, then R, and A.
Sop:·, the rest of the string operators in the lexicographic order
according to their names in Figure 2;
Rop:ordered according to the standard precedence order on
regular expression operators;
Aop:+,−,×,||,(), the rest of the LIA operators in the lexico-
graphic order according to their names in Figure 2.
Scomp :=,,, the rest of the string comparators in the lexico-
graphic order according to their names in Figure 3;
Rcomp :∈,<;
Acomp :=,<,≤,,;
The ordering on comparators allows to define an order ≺typeon
the types of the conjuncts Type , based on the type of the comparator
occurring in the conjuncts. The strict total ordering on operators
allows to introduce vectors of operators of constraints and compare
them with≺vec:
Op (F)—a vector of string, regular and LIA operators occurring
inFfrom left to right.
Note all auxiliary vectors and their orderings introduced in this
section are defined for constraints and are naturally applicable to
conjuncts – as to a special type of constraints with a single conjunct.
In the future, when we compare two elements of the same type
we will drop the subscript notation and use ≺to represent compar-
ison between them.
We are now ready to build a strict total order on conjuncts. We
define the ordering hierarchically: the structural or syntactic aspects
of the conjuncts are compared one at a time in a fixed order, until a
tie-breaking aspect is found. This order can be selected in any way.
We present one intuitive order below to distinguish conjuncts with
more significant differences as early as possible. The conjuncts are
first compared based on their type Type , then based on their length
∥∥, then the total number of variables #Var, then their vectors of
operators Op, followed by the vectors of indices of variables VI,
their vectors of integer coefficients Int, their vectors of variable
names VVV, then vectors of string constants ΣΣΣ, and finally based on
their constant shifts Shift . This order is described in Algorithm 2.
This order is strict and total. Two conjuncts are equal if and only
if they are the same conjunct. This allows us to extend the ordering
to constraints as follows:
(i) Order constraints based on their total number of conjuncts.
539ESEC/FSE’17, September 4–8, 2017, Paderborn, Germany T. Brennan, N. Tsiskaridze, N. Rosner, S. Aydin, and T. Bultan
Algorithm 2 C-LessThan (C1,C2): Conjunct Comparison
Input: Two conjuncts C1,C2∈L
Output: True ifC1≺C2, otherwise False
1:for each f∈[Type ,∥∥,#V ar ,Op,VI,Int,VVV,ΣΣΣ,Shift ]do
2: iff(C1)≺f(C2)then
3: return True
4: end if
5:end for
6:return False
(ii)Then order constraints by comparing their conjuncts element-
wise according to the order imposed on I. This is equivalent
to comparing conjuncts pairwise from first to last.
(iii)A constraint Fis lower ordered than a constraint Gif the
first differing conjunct of Fis lower ordered than that of G.
This order is described in Algorithm 3.
Algorithm 3 F-LessThan (F,G): Constraint Comparison
Input: Two constraints F=F1∧. . .∧FmandG=G1∧. . .∧Gn
Output: True ifF≺G, otherwise False
1:ifm=nthen
2: fori←1,ndo
3: ifC-LessThan (Fi,Gi)then
4: return True
5: end if
6: end for
7:end if
8:return m<n
7 NORMALIZATION PROCEDURE
The normal form of a constraint Fis the lowest constraint in the
orbit of FunderGcard. In this section, we present a normalization
procedure to find the normal form of a constraint.
Given a transformation σ∈G card, we defineσ[F], the action ofσ
onF, as a composition of elements of four categories corresponding
to each of the components of the domain of Gcard:
I:σI[F]gives the constraint resulting from re-ordering the
conjuncts of Faccording to σI.
V:σV[F]gives the constraint resulting from renaming the vari-
ables of Faccording to σV;
Σ:σΣ[F] gives the constraint resulting from permuting the al-
phabet constants in Faccording to σΣ;
SH:σSH[F]gives the constraint resulting from shifting each
element of F’s shift according to σSH.
We first present an expensive but complete procedure for nor-
malization in Algorithm 4 and give guarantees for its termination
and correctness. Given a constraint F, this procedure probes each
permutation F′of conjuncts in F, building and applying a compos-
iteσfrom transformations specific to the domains V,Σ, andSH
which reduces F′until the only transformations that can reduce it
further involve an action on I. The results among all permutations
ofFare compared and the lowest-ordered result is chosen as the
normal form of F.
The procedure uses auxiliary functions to build the minimizing
domain-specific transformations:
Min-σ-V(F′)constructsσVcompositionally — it proceeds through
the conjuncts of F′from left to right renaming the variables of F′in order of appearance. Each time a new variable is encountered a
transposition is added to the composition that permutes the name
of the encountered variable and the lowest-ordered variable name
that no other variable of F′has been renamed to yet. At the start
of the procedure, σVis initialized to the identity transposition on V.
Min-σ-Σ(F′)similarly constructs σΣ— it proceeds through the con-
juncts of F′from left to right, this time permuting string characters.
Each time a new string character is encountered, a transposition
is added to the composition that permutes the encountered string
character with the lowest-ordered character that no other charac-
ter in F′has been mapped to yet. σΣis initialized as the identity
transposition on Σ.
Min-σ-SH (F′)returnsσSH— the transformation on Shift (F)
that translates the constant coefficient of the first appearing (from
left to right) linear integer arithmetic conjunct in F′to 0. If Fcon-
tains variables that are shared between string and LIA constraints,
σSHis the identity transformation.
Algorithm 4 Complete-Normalization (F)
Input: A constraint F
Output: The normalized form of F
1:Fmin :=F
2:for each permutation F′of conjuncts in Fdo
3:σV:=Min-σ-V(F′)
4:σΣ:=Min-σ-Σ(F′)
5:σSH:=Min-σ-SH (F′)
6: F′:=σV◦σΣ◦σSH[F′]
7: ifF-LessThan (F′,Fmin)then
8: Fmin :=F′
9: end if
10:end for
11:return Fmin
Theorem 7.1. Algorithm 4 terminates.
Proof. Given a constraint F, there are finitely many permuta-
tions of conjuncts F′. Consequently, there are finitely many exe-
cutions of the “for each" loop. Construction of each permutation
F′is linear in the length of F. Construction of each of the domain-
specific transformations within a single “for each” call is performed
in a single pass through the conjuncts of F′, thus, is linear in the
length of F, too. The final transformation on F′is also linear in the
length of F. Thus, Complete-Normalization terminates. □
Theorem 7.2. Algorithm 4 returns the normal form of F.
Proof. Assume G=Complete-Normalization (F)is not the
normal form of F. Then either Gis not in the orbit of FunderGcard
or there is some constraint Hin the orbit of Fsuch that H,Fand
F⊀H. We show that both result in a contradiction.
Assume Gis not in the orbit of F.Gis the result of permuting
the conjuncts of F, the action of some σI, composed with domain
specific transformations. Each domain-specific transformation has
an inverse inGcardas does any permutation of the conjuncts of F.
Therefore, there exists some σinGcardsuch thatσ[G]=F.
Now assume that there is some Hin the orbit of Fsuch that
H,GandG⊀H. The order of conjuncts in His given by some
transposition of the indices of F. This means that there is some
iteration of the for loop of Algorithm 4 in which the conjuncts of
540Constraint Normalization and Parameterized Caching for
Quantitative Program Analysis ESEC/FSE’17, September 4–8, 2017, Paderborn, Germany
the considered permutation of Fare ordered identically to those
ofH. By construction, our choices of σV,σΣandσSHreduce this
constraint to the lowest-ordered constraint that maintains the same
ordering of conjuncts. Therefore either G=HorG≺H. □
Algorithm 4 gives a normalization procedure which is sound
(each orbit has at least one fixed point) and complete (there is exactly
one fixed point for each orbit). In practice, however, such a brute
force exploration is very expensive. For our implementation, we
use a sound but not complete normalization procedure given in
Algorithm 5. Given F,Normalization (F)returns the semi-normal
form on F— a constraint within the orbit of Fwhich, though not
necessarily the lowest in the orbit, is not higher ordered than F.
Algorithm 5 simplifies Complete-Normalization procedure in
that instead of brute-forcing all permutations of conjuncts in F, it
inexpensively chooses a permutation by ordering the conjuncts of F
according to C-LessThan up to the point when further refinement
involves comparison over the domains V,Σ, orSH. In other words,
the conjuncts are not compared according to their variable names,
string constants or shifts. It is possible that two conjuncts in F
are equal by this comparison, in which case their initial order in
Fis preserved. The resulting permutation of conjuncts defines a
transposition onI. We apply this transposition to F, resulting in a
constraint F′.σV,σΣ, andσSHare generated by the same auxiliary
functions as in Algorithm 4, composed, and applied to F′. The result
is the semi-normal form of F.
Algorithm 5 Normalization (F)
Input: A constraint F
Output: A semi-normal form of F
1:F′:=Permute conjuncts of Faccording to Algorithm 2 up until VVV
2:σV:=Min-σ-V(F′)
3:σΣ:=Min-σ-Σ(F′)
4:σSH:=Min-σ-SH (F′)
5:⟦F⟧:=σV◦σΣ◦σSH[F′]
6:return ⟦F⟧
Theorem 7.3. Algorithm 5 is sound.
Proof. Each action on Fis the action of an element of Gcard. By
definition, the resulting formula is in the orbit of FunderGcard.□
The procedure given in Algorithm 5 is not complete. There are
orbits for which not every constraint is reduced to the same form.
Though this potentially increases the number of misses to the cache,
our experimental results demonstrate the large number of formulas
mapped to the same semi-normal form by Algorithm 5.
Queries to Cashew are of the form (F,V,b)where Vis the set
of variables on which to count, and bis the maximum length of a
satisfying solution. To ensure that the cardinality of the solution
set is preserved after normalizing F, both Vandbmust be normal-
ized according to the same transformations applied to Fduring
Algorithm 5. Algorithm Normalize-Query (F,V,b)implements
this query normalization.
8 EXPERIMENTAL EVALUATION
We implemented our tool, Cashew , as an extension of the Green [ 55]
caching framework. This allows Cashew to use any of the exist-
ing Green services, and it allows Green users to benefit from our
normalization procedure. We experiment with Cashew -enabled
satisfiability and model-counting services, which support stringAlgorithm 6 Normalize-Query (F,V,b)
Input: A query (F,V,b)
Output: A normalized query ⟦F,V,b⟧
1:⟦F⟧:=Normalization (F)
2:σ:=the transformation used to normalize F
3:⟦V⟧:=σ[V]
4:⟦b⟧:=σ[b]
5:return (⟦F⟧,⟦V⟧,⟦b⟧)
constraints and linear integer arithmetic. They also support mixed
constraints, i.e., those involving both string and arithmetic opera-
tions. In this evaluation, we used ABC [ 6] as our constraint solver.
As we explained in Section 3, other model-counting constraint
solvers can be integrated instead of ABC.
All the experiments were run on an Intel Core i7-6850 3.5 GHz
computer running Linux 4.4.0. The machine has 128 GB RAM, of
which 4 GB were allocated for the Java VM.
8.1 Model Counting over the SMC/Kaluza
String Constraint Dataset
The Kaluza dataset is a well-known benchmark of string constraints
that are generated by dynamic symbolic execution of real-world
JavaScript applications [ 47]. The authors of the SMC solver [ 39]
translated the satisfiable constraints to their input format: one
contains 1,342 big, while the other contains 17,554 small where big
and small classification is done based on the constraint sizes in the
Kaluza dataset. We shall refer to the former as the original SMC-Big
and to the latter as the original SMC-Small.
Duplicate Constraints. While inspecting the results of our nor-
malization, we found out that many of the files within each dataset
are identical (indistinguishable by diff ). Due to the presence of
duplicates, even trivial caching (without any normalization) will
yield some benefit on the original datasets. After removing all du-
plicate files, only 359 of the 1,342 constraints in SMC-Big and 9,745
of the 17,554 constraints in SMC-Small were found to be unique.
As we discuss below, our normalization procedure allows further
reductions in this dataset, increasing the benefits of caching well
beyond what can be achieved with trivial caching.
Model Counting. Since these constraints correspond to path con-
ditions from symbolic execution, counting the number of satisfying
models of each one could be necessary for quantitative analysis.
We model-counted all constraints in each set as a simple way to
emulate the behavioral pattern (w.r.t. caching) of one or more users
performing quantitative analyses on the original programs.
When counting the models of a constraint over strings, to avoid
infinite counts one needs to set a bound on the length of strings.
In this experiment, we set the bound to 50 characters for both sets.
We model-counted each constraint in the dataset. We first did this
without normalization or caching, and then again with Cashew
normalization and caching. In non-caching mode, each constraint
was sent unmodified to the model-counting solver. In caching mode,
the cache was cleared before running SMC-Big, and again before
running SMC-Small. Since these path constraints were produced
by an external symbolic executor, in this experiment we did not use
SPF. Note that since all constraints were model-counted, the order
in which we traverse the datasets does not matter: each normalized
541ESEC/FSE’17, September 4–8, 2017, Paderborn, Germany T. Brennan, N. Tsiskaridze, N. Rosner, S. Aydin, and T. Bultan
SMC-Big SMC-Small
13
1522253
27
2728
3323435 36 36
3738 38
38
3839
39
393940 40
4042 42
43
699
99
1020
152
1551681861874 1875
195216
25372543
323 345
371374
374399
4455772729
73736
7494
Figure 4: Orbit sizes for the original SMC datasets.
Table 1: Model counting SMC-Big and SMC-Small.
Without caching With caching Speedup
Big Average 8.94 s 0.82 s 10.90x
(no dups) Maximum 121.92 s 40.13 s 3.03x
Total time 3,208.65 s 293.21 s 10.94x
Small Average 0.12 s 0.05 s 2.40x
(no dups) Maximum 1.09 s 1.12 s 0.97x
Total time 1,211.09 s 552.56 s 2.19x
Big Average 23.32 s 0.26 s 89.70x
(original) Maximum 121.92 s 40.13 s 3.03x
Total time 31,297.90 s 358.17 s 87.38x
Small Average 0.13 s 0.05 s 2.60x
(original) Maximum 1.09 s 1.12 s 0.97x
Total time 2,221.91 s 971.50 s 2.29x
constraint will fall within some orbit, and for each orbit, the full
cost will be paid exactly once (first cache miss).
Results. Table 1 shows the total, maximum and average model-
counting time, as well as the speedups obtained by Cashew on each
of these metrics, for the two datasets with and without duplicates.
On the SMC-Big set, Cashew achieved a speedup over 10x. On the
SMC-Small set, which is a rather bad case for the caching trade-
off because it contains a large number of very small constraints,
Cashew still achieved a 2.19x speedup.
For the original datasets, these numbers (e.g., a 87x speedup) are
largely due to the presence of duplicates, which makes even caching
with no normalization very effective. We report the results because
the original datasets are widely used, and because the duplicates
might indeed have been genuinely generated by symbolic execution
of various different (yet similar) JavaScript programs.
Figure 4 depicts the effect of our normalization procedure on
the original benchmarks. The area of each orbit is proportional to
its size. Labels indicating orbit size are shown only when they fit
in the available space. For the original SMC-Small set, the 17,554
original constraints are reduced to 360 orbits. For the SMC-Big set,
the 1,342 original constraints are reduced to just 34 orbits.
We do not compare Cashew with Green because the original
Green (without Cashew ) cannot handle string constraints.
Note that the largest constraint in SMC-Small takes slightly more
time after normalization. We cannot infer much from this, because
the largest constraint in SMC-Small barely takes one second; the
small difference (about 30 msec) could be due to noise. However,
the maximum time for SMC-Big decreased by 3x with caching
enabled, from 122 to 40 seconds. This is due to normalization. The
constraint that (without normalization) requires maximum time to
be model-counted falls within some orbit. It does not matter which
constraint in that orbit will be the one to cause a cache miss onceTable 2: Effect of transformations on orbit refinement.
Transformations enabled #Orbits (SMC-Big) #Orbits (SMC-Small)
None 359 9754
All transformations 34 360
All exceptσI 72 376
All exceptσV 344 9645
All exceptσΣ 35 841
All except removeVar 34 361
All except removeConj 40 386
caching is enabled — only one of them will, and as they are all
normalized to the same normal form, any of them would take the
same model-counting time. What is interesting is that said time can
be significantly smaller than the maximum pre-normalization time.
Table 2 shows the number of orbits that are achieved by differ-
ent subsets of the transformations in our normalization procedure.
Since some transformations can benefit from others, instead of
considering them in isolation, we measured the effect of disabling
each one. We did not include σSHas it doesn’t apply to the string
domain. The removeVar and removeConj transformations are pre-
processing steps that remove redundant variables and conjuncts,
respectively. These results indicate that all transformations yield
some benefit, and that σVis the most beneficial transformation. For
SMC-Small, removing σΣmore than doubles the number of orbits.
The same is true of σIfor SMC-Small. This shows that different
transformations can be more effective for different datasets.
8.2 SPF Analysis of String-Handling Code
In this second part of the experimental evaluation we use Symbolic
PathFinder [ 42] with Cashew , to symbolically execute Java pro-
grams that operate on strings. In order to support model-counting-
based quantitative analyses, we are interested in obtaining a model
count for each leaf path constraint.
As an example of quantitative information flow analysis, we
study some possible applications of Cashew to side-channel anal-
ysis. We consider four Java programs in which a side channel
can allow an attacker to gain information about a hidden secret.
PasswordCheck1 contains a method that checks whether or not a
user-given string matches a secret password. Due to the way the
program is written, the attacker can deduce that the longer the
program executes, the longer a prefix of the hidden password was
matched. PasswordCheck2 is another variant that attempts to miti-
gate that vulnerability by requiring a certain number of characters
to be compared before returning, even if a mismatch has already
been found. This yields a more interesting side channel, which can
still be exploited but is much noisier and less predictable. Obscure
is a Java translation of the obscure.c program used in [ 39], which
is a password change authorizer. Given an old password and a new
one, Obscure performs a series of tests to determine whether the
new password is different enough from the old one. CRIME is a Java
version of a well-known attack, Compression Ratio Info-leak Made
Easy [9,46]. This is a side channel in space — the secret is con-
catenated with a string that can be controlled by the attacker, and
both are compressed together before encryption. Thus, the attacker
can try various strings and observe the changes in the size of the
compressed payload to infer, from the compression rate, the level
of similarity between the secret and the injected content.
542Constraint Normalization and Parameterized Caching for
Quantitative Program Analysis ESEC/FSE’17, September 4–8, 2017, Paderborn, Germany
Table 3: SPF-based quantitative analyses of string programs.
Program Caching Total time Speedup #Hits #Misses H/M
Password1 None 297 s - - - -
No norm 258 s 1.15x 17,547 56,173 0.31
Cashew 106 s 2.80x 62,797 10,923 5.75
Password2 None 3,364 s - - - -
No norm 3,379 s 0.99x 30,448 824,832 0.04
Cashew 1,243 s 2.71x 659,804 195,476 3.38
Obscure None 2,158 s - - - -
No norm 1,965 s 1.10x 2,000 59,000 0.03
Cashew 609 s 3.54x 44,893 16,107 2.79
CRIME None 3,005 s - - - -
No norm 2,941 s 1.02x 31,884 84,127 0.38
Cashew 1,067 s 2.82x 78,289 37,722 2.08
In symbolic execution, it is not always desirable to make allargu-
ments of a method symbolic. This is often the case due to scalability
issues. It can also be due to the need to explore a nonstandard distri-
bution of some parameter. Consider, for instance, a situation where
a list of passwords from a website is unwillingly disclosed to the
public. As a consequence, users are strongly encouraged to change
their passwords, and an algorithm similar to the Obscure program
is employed to ensure that they are sufficiently different from the
stolen ones. We might be interested in measuring the amount of
leakage of the algorithm over that particular list of passwords. By
running SPF on Obscure with the new password as a symbolic
string, and the old password as a concrete string, we can measure
the leakage for that particular stolen password. By repeating this
for various passwords from the list, we can quantify the algorithm’s
leakage for that list’s particular distribution. Doing so requires run-
ning SPF repeatedly on the same code, but with different secret
strings. This will affect many path conditions in fundamental ways,
but others might be unaffected, or changed in such a way that
Cashew can still normalize them down to a previously seen one.
RockYou. The RockYou1K dataset is a sample of 1,000 real-world
passwords taken from the RockYou leak [ 56] without duplicates.
The sample consists of 1,000 unique passwords that cover all lengths
between 6 and 16 characters, and can include any ASCII symbols.
Results. For each of the four programs under analysis, we ran
1,000 symbolic-execution-based side-channel analyses, using as the
secret each of the 1,000 passwords in the RockYou1K dataset. For
PasswordCheck1 andPasswordCheck2 , the secret is the password,
which is concrete, and the user’s guess is a symbolic string. For
Obscure , the roles are reversed: what we made concrete is the
old password, which is no longer secret, whereas the user-chosen
new password (which is secret) is symbolic. For CRIME , we used a
concrete secret (session ID) and a symbolic user-injected payload.
Table 3 shows execution time, hits and misses for three execution
modes. The first mode uses neither normalization nor caching. In
the second mode, only caching without normalization is performed,
which measures the extent to which syntactically identical path
conditions (akin to the duplicates mentioned in Section 8.1) are
generated. In the third mode, Cashew ’s normalization is enabled.
Note that each symbolic execution generates many path conditions.
The tables show the aggregated results over all path conditions
of each execution and the 1,000 executions of each mode. As in
the previous section, we do not compare Cashew with Green inTable 4: Cashew normalization and caching costs.
Total Total Total Total Average Total
time time norm. norm. norm. cache
(no cache) ( Cashew ) time calls time size
SMC-Big 3,209 s 293 s <3 s 359 8 ms 54 KB
SMC-Small 1,211 s 553 s 31 s 9,745 3 ms 104 KB
Password1 297 s 106 s 20 s 73,720 275 µs 2.9 MB
Password2 3,364 s 1,243 s 94 s 855,280 110 µs 58 MB
Obscure 2,158 s 609 s 19 s 61,000 300 µs 5.1 MB
CRIME 3,005 s 1,067 s 47 s 116,011 400 µs 8.8 MB
these experiments because the original Green (without Cashew )
cannot handle string constraints. The results show that, for these
experimental subjects, Cashew achieved an average speedup of
nearly 3x, while caching without normalization only achieved 1.06x
(and, for PasswordCheck2 , was in fact slower than no caching). The
hit/miss ratios improve dramatically when switching to Cashew .
Costs of Caching and Normalization. A caching scheme involves
overheads and space/time trade-offs. Normalization overhead must
be kept low, since its cost must be paid not only for each hit, but
also for each miss. Cache size must also be kept within reasonable
limits. Cashew is implemented on top of Green and, like Green, uses
the in-memory Redis [ 1] database by default. This allows extremely
fast queries, but competes with the client application for available
RAM. As Table 4 shows, the average time to normalize a constraint
in our SPF symbolic execution experiments was only a few hundred
microseconds. It was about 8 milliseconds for the largest formulas
(the SMC-Big set, with an average size before normalization of about
10 KB of text per constraint). Finally, as shown in Table 4, the total
cache memory usage was very reasonable for these experiments.
8.3 Parameterized Caching
In this last part of the experimental evaluation we present some
experiments for evaluating parameterized caching—that is, caching
that leverages parameterized model-counting solvers.
The motivation behind these experiments is that users of Cashew
who are targeting quantitative information analysis techniques
often perform their analyses with various different bound values.
For example, in side-channel analysis, one may want to compute the
amount of information leakage for different lengths of a symbolic
secret or input. This requires using different bounds when counting
models. In scenarios where we have reason to believe that there is
potential for reusing already-created model-counting objects for
multiple values of b, we can try to amortize the time required to
construct them by caching them.
String Constraints: SMC/Kaluza. Recall the SMC-Big and SMC-
Small datasets from Section 8.1. We ran these two datasets several
more times, starting with the string length bound bat 10 characters
and raising it up to 100 characters. Since our goal was to evaluate the
usefulness of caching model-counting objects, we did not clear the
cache between successive values of b. Again, we did not compare
with Green in these experiments because Green (without Cashew )
does not support constraints over strings.
Figure 5 shows the cumulative time spent running SMC-Big and
SMC-Small, respectively, for b∈{10,20,30, . . . , 100}characters. We
did this twice for each dataset. The upper lines (red) correspond to
543ESEC/FSE’17, September 4–8, 2017, Paderborn, Germany T. Brennan, N. Tsiskaridze, N. Rosner, S. Aydin, and T. Bultan
Figure 5: SMC datasets for increasing bounds. Cashew : non-
parameterized (red) and parameterized (blue) caching.
Figure 6: Symbolic execution of sorting/searching programs
for increasing bounds. Green (green) vs. Cashew (blue).
Cashew with parameterized caching disabled (model-counting ob-
jects are not cached). The lower lines (blue) correspond to Cashew
with parameterized caching enabled. In this mode, an extra cost
is paid to cache the model-counting objects, but doing so enables
the possibility of reusing them later on. The left chart shows that
caching model-counting objects is indeed beneficial for SMC-Big.
This is an idealized amortization scenario, since all stored model-
counting objects are reused on each successive bound value. Never-
theless, it is useful to confirm that for this dataset, running even one
additional bound is profitable, and that this profit becomes larger
each time we run the dataset for an additional value of b. The right
chart shows a similar phenomenon for SMC-Small, but although
the gap does increase, the lines are so close together that caching
model-counting objects would probably not be worth its cost. This
is consistent with a large number of small problems.
Arithmetic Constraints. The goal of these experiments is to eval-
uate the usefulness of Cashew ’s parameterized caching when sym-
bolically executing Java code whose branch conditions involve
linear integer arithmetic operations. Green can handle arithmetic
constraints, so we can use it as the baseline for these experiments.
One well-known class of algorithms that involve integer arith-
metic constraints and give rise to nontrivial path conditions are clas-
sical sorting algorithms. For these experiments we ran an SPF-based
quantitative analysis (symbolic execution and model counting on
complete path conditions) on the following algorithms: BubbleSort,
InsertionSort, SelectionSort, QuickSort, HeapSort, and MergeSort.
Figure 6 shows the cumulative time spent in the analysis of
each of the seven Java programs, for b∈{16,20,24, . . .64}. Sincewe are counting over the integers, the bound bnow denotes the
maximum number of bits that may be used to represent an integer.
We ran each series twice. The upper curve (green) corresponds to
Green, with caching enabled, using its normalization procedure for
integer arithmetic constraints. The lower curve (blue) corresponds
toCashew with parameterized caching enabled.
The magnitude of the gap between both curves varies for dif-
ferent programs. In most cases, the initial run on an empty cache
(forb=16) is slightly more costly for Cashew due to the over-
head of having to store all the model-counting objects in the cache.
This is compensated as soon as they are reused at least once, and
in all cases we see that the gap between the curves grows as the
model-counting objects are reused further. This confirms that pa-
rameterized caching is beneficial for these programs if there is a
reasonable chance that the model-counting objects may be reused.
9 RELATED WORK
Our work builds on top of Green [ 55], an external framework for
caching the results of calls to satisfiability solvers or model counters
developed by Visser et al. Other caching frameworks include Green-
Trie [ 31], an extension of Green and Recal [ 4], both of which are
able to detect some implications between constraints. Recal trans-
forms a LIA constraint to a matrix, canonizes it, and uses the result
as the constraint’s normal form. A different approach is taken by
the tool Utopia [ 5] which identifies past satisfying solutions likely
to be shared with new formulas. This enables results to be reused
across formulas that share at least one solution, regardless of their
structural resemblance.
Cashew differs notably from these previous caching frameworks.
First, we present a parameterized model counting approach for
quantitative program analysis which allows us to cache and reuse
a model-counter object in addition to the results of model count-
ing queries. This allows us to reuse results for model-counting
queries across different bounds. Cashew also exploits more expres-
sive normalization techniques with reductions that preserve only
thenumber of solutions of a constraint instead of their solution set.
This allows us to reuse information that the above caching frame-
works can not. Cashew is also able to handle string constraints, a
unique contribution amongst the above mentioned tools.
10 CONCLUSIONS
We presented a caching framework for quantitative program anal-
ysis built on constraint normalization techniques that preserve
the cardinality of the solution set for a given constraint but not
necessarily the solution set itself. We augmented our framework
with parameterized constraint caching techniques that can reuse
the result of a previous model counting query even if the bounds
of the queries do not match and extended our framework to sup-
port string constraints and combinations of string and arithmetic
constraints. Our experiments exemplify how, when supplemented
with our constraint normalization techniques, constraint caching
can significantly improve the performance of quantitative program
analyses.
544Constraint Normalization and Parameterized Caching for
Quantitative Program Analysis ESEC/FSE’17, September 4–8, 2017, Paderborn, Germany
Table 5: Classes implementing each transformation
Transformation Class name
σI OrderingService
σV VariableRenamer
σΣ AlphabetRenamer
removeVar VariableRemover
removeConj RedundantConstraintRemover
11 IMPLEMENTATION
Cashew is built on top of Green, and like Green, it acts as a wrapper
around constraint solvers and model counters. In other words, it sits
between the client application (typically a verification tool based on
constraint satisfiability and/or model counting) and the actual con-
straint solver and/or model counter. Besides the caching strategy
and mechanism, it provides a standard interface for the client appli-
cation to create constraints and request solving/counting services;
this enables switching solvers without modifying the client.
Constraints for Cashew are constructed using the same class
hierarchy as in Green; the main change is that we extended that
hierarchy with new objects that represent operations on strings.
Cashew also inherits the storage abstraction from Green. The
default store is a Redis database, but other back ends can be used.
11.1 Obtaining Cashew
Cashew can be obtained from the GitHub repository located at
https://github.com/vlab-cs-ucsb/cashew/
11.2 Configuring Cashew
Cashew can be configured via key/value pairs, using the standard
Java Properties mechanism. Each of the transformations shown
in Table 2 is implemented by a class in the service.canonizer
package, as shown in Table 5. Layers can be enabled and disabled,
for both constraint satisfiability and model counting, by means
of the green.service.sat and the green.service.count prop-
erties, respectively. As in the Green framework, these properties
can specify a composition of services using a parenthesized syntax.
Examples of this can be found in the sample configuration files
included in the Cashew repository.
11.3 Cashew Integration Examples
A Model-Counting Tool for SMC/Kaluza Benchmark Problems. We
used Cashew to implement a simple model counter for SMC/Kaluza
constraints, as shown in Section 8.1, expressed using a subset of
the SMT-LIB format [13].
This tool is essentially a translator that parses that input syntax,
maps it to Cashew ’s constraint representation, and then invokes
the model counter service. This implementation is included in the
Cashew repository as RunCashewKaluza.java .
Cashew as a Back End for SPF. We also used Cashew as the
back end for Symbolic PathFinder, as shown in Section 8.2. The
integration of SPF with Cashew was done much in the same way as
it was with Green: the SPF codebase is modified in the few places
where it calls the constraint solver or model counter, so that it calls
Cashew instead. A translator class is added in order to translateSPF’s constraint language (i.e., abstract syntax tree class hierarchy)
toCashew ’s before making the call.
TheCashew repository includes a sample working version of
SPF modified in this way.
Also, Cashew option configuration properties are read through
the JPF configuration property space, which allows the user to
control Cashew -specific behavior from the same .jpf configuration
file used by JPF and SPF. Examples can be found in the sample
configuration files included in the Cashew repository.
Cashew as a Back End for Your Own Tool. Cashew can be inte-
grated with your client application just like Green; see the Green
documentation and examples for more details.
If you would like to use string operations in your constraints,
please see the Operation ,StringConstant , and StringVariable
classes in the green.expr package.
Adding Your Own Solver to Cashew. Cashew has already been
integrated with the ABC constraint solver and model counter. You
can add a new SMT solver to Cashew in the same way as you
would add one to Green. At a minimum, you will need to write a
translator from Cashew ’s constraint representation to your solver’s
input format. The simplest way to do this is to have your translator
class extend the Visitor class in the green.expr package.
Adding a new model counter is done similarly as well, but in this
case we augmented the interface to allow for storing model-counter
objects. Besides the getModelCount method, Cashew also supports
thegetModelCounter method, which does not require a bound,
and returns a model-counter object rather than a number, and
thegetModelCountUsingCounter method, which takes a model-
counter object and a bound, and returns a number. You may want
to implement these methods if your solver supports parameterized
model counting. Model-counter objects are stored by Cashew as
raw binary objects ( byte[] ), so they can contain anything.
REFERENCES
[1] Redis. https://redis.io/.
[2]P. A. Abdulla, M. F. Atig, Y. Chen, L. Holík, A. Rezine, P. Rümmer, and J. Sten-
man. String constraints for verification. In Proceedings of the 26th International
Conference on Computer Aided Verification (CAV) , pages 150–166, 2014.
[3]F. A. Aloul, K. A. Sakallah, and I. L. Markov. Efficient symmetry breaking for
boolean satisfiability. IEEE Transactions on Computers , 55(5):549–558, 2006.
[4]A. Aquino, F. A. Bianchi, M. Chen, G. Denaro, and M. Pezzè. Reusing constraint
proofs in program analysis. In Proceedings of the 2015 International Symposium
on Software Testing and Analysis , pages 305–315. ACM, 2015.
[5]A. Aquino, G. Denaro, and M. Pezzè. Heuristically matching solution spaces
of arithmetic formulas to efficiently reuse solutions. In Proceedings of the 39th
International Conference on Software Engineering , pages 427–437. IEEE Press,
2017.
[6]A. Aydin, L. Bang, and T. Bultan. Automata-based model counting for string
constraints. In Computer Aided Verification - 27th International Conference, CAV
2015, San Francisco, CA, USA, Proceedings, Part I , pages 255–272, 2015. doi:
10.1007/978-3-319-21690-4_15.
[7]M. Backes, B. Köpf, and A. Rybalchenko. Automatic discovery and quantification
of information leaks. In 30th IEEE Symposium on Security and Privacy (S&P 2009),
17-20 May 2009, Oakland, California, USA , pages 141–153, 2009.
[8]V. Baldoni, N. Berline, J. D. Loera, B. Dutra, M. Köppe, S. Moreinis, G. Pinto,
M. Vergne, and J. Wu. Latte integrale v1.7.2. http://www.math.ucdavis.edu/ latte/,
2004.
[9]L. Bang, A. Aydin, Q.-S. Phan, C. S. Păsăreanu, and T. Bultan. String analysis
for side channels with segmented oracles. In Proceedings of the 2016 24th ACM
SIGSOFT International Symposium on Foundations of Software Engineering , pages
193–204. ACM, 2016.
[10] C. Barrett, L. de Moura, S. Ranise, A. Stump, and C. Tinelli. The smt-lib initiative
and the rise of smt. In Haifa Verification Conference , pages 3–3. Springer, 2010.
545ESEC/FSE’17, September 4–8, 2017, Paderborn, Germany T. Brennan, N. Tsiskaridze, N. Rosner, S. Aydin, and T. Bultan
[11] C. Barrett, C. L. Conway, M. Deters, L. Hadarean, D. Jovanović, T. King,
A. Reynolds, and C. Tinelli. Cvc4. In International Conference on Computer
Aided Verification , pages 171–177. Springer, 2011.
[12] C. Barrett, M. Deters, L. De Moura, A. Oliveras, and A. Stump. 6 years of smt-comp.
Journal of Automated Reasoning , 50(3):243–277, 2013.
[13] C. Barrett, P. Fontaine, and C. Tinelli. The SMT-LIB Standard: Version 2.5. Tech-
nical report, Department of Computer Science, The University of Iowa, 2015.
Available at www.smt-lib.org .
[14] M. Borges, A. Filieri, M. d’Amorim, and C. S. Pasareanu. Iterative distribution-
aware sampling for probabilistic symbolic execution. In Proceedings of the 2015
10th Joint Meeting on Foundations of Software Engineering, ESEC/FSE 2015, Berg-
amo, Italy, August 30 - September 4, 2015 , pages 866–877, 2015.
[15] C. Cadar, D. Dunbar, and D. R. Engler. KLEE: unassisted and automatic generation
of high-coverage tests for complex systems programs. In 8th USENIX Symposium
on Operating Systems Design and Implementation, OSDI 2008, December 8-10, 2008,
San Diego, California, USA, Proceedings , pages 209–224, 2008.
[16] S. Chakraborty, K. S. Meel, R. Mistry, and M. Y. Vardi. Approximate probabilistic
inference via word-level counting. arXiv preprint arXiv:1511.07663 , 2015.
[17] D. Clark, S. Hunt, and P. Malacaria. A static analysis for quantifying information
flow in a simple imperative language. Journal of Computer Security , 15(3):321–371,
2007.
[18] J. Crawford. A theoretical analysis of reasoning by symmetry in first-order logic.
InAAAI Workshop on Tractable Reasoning . Citeseer, 1992.
[19] J. Crawford, M. Ginsberg, E. Luks, and A. Roy. Symmetry-breaking predicates
for search problems. KR, 96:148–159, 1996.
[20] L. De Moura and N. Bjørner. Z3: An efficient smt solver. In International conference
on Tools and Algorithms for the Construction and Analysis of Systems , pages 337–
340. Springer, 2008.
[21] B. Dutertre. Yices 2.2. In International Conference on Computer Aided Verification ,
pages 737–744. Springer, 2014.
[22] A. Filieri, C. S. Pasareanu, and W. Visser. Reliability analysis in symbolic
pathfinder. In 35th International Conference on Software Engineering, ICSE ’13,
San Francisco, CA, USA, May 18-26, 2013 , pages 622–631, 2013.
[23] V. Ganesh, M. Minnes, A. Solar-Lezama, and M. C. Rinard. Word equations with
length constraints: What’s decidable? In Proceedings of the 8th International Haifa
Verification Conference (HVC) , pages 209–226, 2012.
[24] J. Geldenhuys, M. B. Dwyer, and W. Visser. Probabilistic symbolic execution. In In-
ternational Symposium on Software Testing and Analysis, ISSTA 2012, Minneapolis,
MN, USA, July 15-20, 2012 , pages 166–176, 2012.
[25] I. P. Gent and B. Smith. Symmetry breaking during search in constraint program-
ming . Citeseer, 1999.
[26] I. P. Gent, K. E. Petrie, and J.-F. Puget. Symmetry in constraint programming.
Foundations of Artificial Intelligence , 2:329–376, 2006.
[27] P. Godefroid, N. Klarlund, and K. Sen. DART: directed automated random testing.
InProceedings of the ACM SIGPLAN 2005 Conference on Programming Language
Design and Implementation, Chicago, IL, USA, June 12-15, 2005 , pages 213–223,
2005.
[28] J. Heusser and P. Malacaria. Quantifying information leaks in software. In
Twenty-Sixth Annual Computer Security Applications Conference, ACSAC 2010,
Austin, Texas, USA, 6-10 December 2010 , pages 261–269, 2010.
[29] P. Hooimeijer and W. Weimer. A decision procedure for subset constraints
over regular languages. In Proceedings of the ACM SIGPLAN Conference on
Programming Language Design and Implementation (PLDI) , pages 188–198, 2009.
[30] P. Hooimeijer and W. Weimer. Solving string constraints lazily. In Proceedings of
the 25th IEEE/ACM International Conference on Automated Software Engineering
(ASE) , pages 377–386, 2010.
[31] X. Jia, C. Ghezzi, and S. Ying. Enhancing reuse of constraint solutions to im-
prove symbolic execution. In Proceedings of the 2015 International Symposium on
Software Testing and Analysis , pages 177–187. ACM, 2015.
[32] S. Khurshid, C. S. Pasareanu, and W. Visser. Generalized symbolic execution for
model checking and testing. In Tools and Algorithms for the Construction and
Analysis of Systems, 9th International Conference, TACAS 2003, Warsaw, Poland,
April 7-11, 2003, Proceedings , pages 553–568, 2003.
[33] A. Kiezun, V. Ganesh, P. J. Guo, P. Hooimeijer, and M. D. Ernst. Hampi: a solver
for string constraints. In Proceedings of the 18th International Symposium on
Software Testing and Analysis (ISSTA) , pages 105–116, 2009.
[34] G. Li and I. Ghosh. PASS: string solving with parameterized array and interval
automaton. In Proceedings of the 9th International Haifa Verification Conference
(HVC) , pages 15–31, 2013.
[35] T. Liang, N. Tsiskaridze, A. Reynolds, C. Tinelli, and C. Barrett. A decision
procedure for regular membership and length constraints over unbounded strings.In C. Lutz and S. Ranise, editors, Proceedings of the 10th International Symposium
on Frontiers of Combining Systems , volume 9322 of Lecture Notes in Computer
Science , pages 135–150. Springer, 2015.
[36] T. Liang, A. Reynolds, N. Tsiskaridze, C. Tinelli, C. Barrett, and M. Deters. An
efficient smt solver for string constraints. Formal Methods in System Design , 48
(3):206–234, 2016.
[37] J. A. D. Loera, R. Hemmecke, J. Tauzer, and R. Yoshida. Effective lattice point
counting in rational convex polytopes. Journal of Symbolic Computation , 38(4):
1273 – 1302, 2004. ISSN 0747-7171. doi: http://dx.doi.org/10.1016/j.jsc.2003.04.003.
[38] K. Luckow, C. S. Păsăreanu, M. B. Dwyer, A. Filieri, and W. Visser. Exact and
approximate probabilistic symbolic execution for nondeterministic programs. In
Proceedings of the 29th ACM/IEEE international conference on Automated software
engineering , pages 575–586. ACM, 2014.
[39] L. Luu, S. Shinde, P. Saxena, and B. Demsky. A model counter for constraints
over unbounded strings. In Proceedings of the ACM SIGPLAN Conference on
Programming Language Design and Implementation (PLDI) , page 57, 2014.
[40] B. Mao, W. Hu, A. Althoff, J. Matai, J. Oberg, D. Mu, T. Sherwood, and R. Kast-
ner. Quantifying timing-based information flow in cryptographic hardware. In
Proceedings of the IEEE/ACM International Conference on Computer-Aided Design ,
pages 552–559. IEEE Press, 2015.
[41] S. McCamant and M. D. Ernst. Quantitative information flow as network flow
capacity. In Proceedings of the ACM SIGPLAN 2008 Conference on Programming
Language Design and Implementation, Tucson, AZ, USA, June 7-13, 2008 , pages
193–205, 2008.
[42] C. S. Pasareanu, W. Visser, D. H. Bushnell, J. Geldenhuys, P. C. Mehlitz, and
N. Rungta. Symbolic pathfinder: integrating symbolic execution with model
checking for java bytecode analysis. Autom. Softw. Eng. , 20(3):391–425, 2013.
[43] Q. Phan, P. Malacaria, O. Tkachuk, and C. S. Pasareanu. Symbolic quantitative
information flow. ACM SIGSOFT Software Engineering Notes , 37(6):1–5, 2012.
[44] Q. Phan, P. Malacaria, C. S. Pasareanu, and M. d’Amorim. Quantifying information
leaks using reliability analysis. In Proceedings of the International Symposium on
Model Checking of Software, SPIN 2014, San Jose, CA, USA , pages 105–108, 2014.
[45] Q.-S. Phan and P. Malacaria. Abstract model counting: a novel approach for
quantification of information leaks. In Proceedings of the 9th ACM symposium on
Information, computer and communications security , pages 283–292. ACM, 2014.
[46] J. Rizzo and T. Duong. The crime attack. Ekoparty Security Conference, 2012.
[47] P. Saxena, D. Akhawe, S. Hanna, F. Mao, S. McCamant, and D. Song. A symbolic
execution framework for javascript. In Proceedings of the 31st IEEE Symposium
on Security and Privacy , 2010.
[48] K. Sen, D. Marinov, and G. Agha. CUTE: a concolic unit testing engine for C.
InProceedings of the 10th European Software Engineering Conference held jointly
with 13th ACM SIGSOFT International Symposium on Foundations of Software
Engineering, 2005, Lisbon, Portugal, September 5-9, 2005 , pages 263–272, 2005.
[49] I. Shlyakhter. Generating effective symmetry-breaking predicates for search
problems. Electronic Notes in Discrete Mathematics , 9:19–35, 2001.
[50] G. Smith. On the foundations of quantitative information flow. In Foundations
of Software Science and Computational Structures, 12th International Conference,
FOSSACS 2009, York, UK, March 22-29, 2009. Proceedings , pages 288–302, 2009.
[51] M. Thurley. sharpsat–counting models with advanced component caching and
implicit bcp. In International Conference on Theory and Applications of Satisfiability
Testing , pages 424–429. Springer, 2006.
[52] M. Trinh, D. Chu, and J. Jaffar. S3: A symbolic string solver for vulnerability
detection in web applications. In Proceedings of the ACM SIGSAC Conference on
Computer and Communications Security (CCS) , pages 1232–1243, 2014.
[53] C. G. Val, M. A. Enescu, S. Bayless, W. Aiello, and A. J. Hu. Precisely measuring
quantitative information flow: 10k lines of code and beyond. In Security and
Privacy (EuroS&P), 2016 IEEE European Symposium on , pages 31–46. IEEE, 2016.
[54] S. Verdoolaege. barvinok: User guide. Version 0.23), Electronically available at
http://www. kotnet. org/˜ skimo/barvinok , 2007.
[55] W. Visser, J. Geldenhuys, and M. B. Dwyer. Green: reducing, reusing and recy-
cling constraints in program analysis. In Proceedings of the ACM SIGSOFT 20th
International Symposium on the Foundations of Software Engineering , page 58.
ACM, 2012.
[56] M. Weir, S. Aggarwal, M. P. Collins, and H. Stern. Testing metrics for password
creation policies by attacking large sets of revealed passwords. In Proceedings
of the 17th ACM Conference on Computer and Communications Security, CCS
2010, Chicago, Illinois, USA, October 4-8, 2010 , pages 162–175, 2010. doi: 10.1145/
1866307.1866327.
[57] Y. Zheng, X. Zhang, and V. Ganesh. Z3-str: A z3-based string solver for web
application analysis. In Proceedings of the 9th Joint Meeting on Foundations of
Software Engineering (ESEC/FSE) , pages 114–124, 2013.
546