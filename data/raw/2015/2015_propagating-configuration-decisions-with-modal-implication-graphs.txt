Propagating Configuration Decisions with
Modal Implication Graphs
Sebastian Krieter
University of Magdeburg, Germany
Harz University of Applied Sciences
Wernigerode, Germany
sebastian.krieter@ovgu.deThomas Thüm
TU Braunschweig, Germany
t.thuem@tu-braunschweig.deSandro Schulze
Reimar Schröter
Gunter Saake
University of Magdeburg, Germany
sandro.schulze@ovgu.de
reimar.schroeter@ovgu.de
saake@iti.cs.uni-magdeburg.de
ABSTRACT
Highly-configurablesystemsencompassthousandsofinterdepen-
dent configuration options, which require a non-trivial configu-
rationprocess.Decisionpropagationenablesabacktracking-free
configuration process by computing values implied by user deci-
sions. However, employing decision propagation for large-scale
systems is a time-consuming task and, thus, can be a bottleneck in
interactive configuration processes and analyses alike. We propose
modal implication graphs to improve the performance of decision
propagation by precomputing intermediate values used in the pro-
cess.Ourevaluationresultsshowasignificantimprovementover
state-of-the-art algorithms for 120 real-world systems.
CCS CONCEPTS
•Software and its engineering →Software product lines;
KEYWORDS
Software product line, Configuration, Decision Propagation
ACM Reference Format:
SebastianKrieter,ThomasThüm,SandroSchulze,ReimarSchröter,andGun-
terSaake.2018.PropagatingConfigurationDecisionswithModalImplica-
tion Graphs. In ICSE ’18: ICSE ’18: 40th International Conference on Software
Engineering , May 27-June 3, 2018, Gothenburg, Sweden. ACM, New York,
NY, USA, 12 pages. https://doi.org/10.1145/3180155.3180159
1 INTRODUCTION
Highly-configurable systems consist of thousands of configuration
optionsalsoknownas features[16,18,81].Thisenormousandeven
growingamountofvariabilityposeschallengesforestablishedalgo-
rithms used to analyze configurable systems [ 12,89]. In particular,
the variability analysis of large-scalesystems, including their con-
figuration, is still challenging as these tasks are computationally
complex problems.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
©2018 Copyright held by the owner/author(s). Publication rights licensed to Associa-
tion for Computing Machinery.
ACM ISBN 978-1-4503-5638-1/18/05...$15.00
https://doi.org/10.1145/3180155.3180159The features of a configurable system are typically connected
by interdependencies that result from interactions within the sys-
tem [64]. Examples of these dependencies are features that require
anotherfeature’sfunctionalityandfeaturesthataremutuallyex-
clusive [49]. In order to configure a working system variant, all
dependenciesofaconfigurablesystemmustbeconsidered.Thus,
every decision a user makes in a configuration (i.e., selecting a
feature) can imply to the inclusion or exclusion of other features.
During the configuration process it is often critical for users to
immediately know the consequences of their decisions to avoid
unwantedeffectslateron.Forexample,someusersaimtoconfigure
aserversystemwithacertainoperatingsystemandtrafficmonitor-
ing. However, their chosen monitoring application is incompatible
with their operating system. If they are unaware of such dependen-
cies,theirconfiguredsystemvariantisinvalid.Asrealsystemsmaycontainthousandsofinterdependentconfigurationoptions,finding
contradictions within a configuration manually is not feasible.
Decisionpropagation guaranteesthatusersareinformedabout
all consequences of their decisions at any point during the con-
figurationprocess.Decisionpropagationdeterminesthefeatures
that are implied or excluded by user decisions [ 42,43,59]. In an
interactive configuration process, decision propagation prevents
usersfrommakingcontradictorydecisionsandreducestheamountofdecisionsauserhastomake.Byemployingdecisionpropagation
inourexample,users,whochoseaparticularmonitoringapplica-
tion or operating system, can immediately notice the respectivedependency and adjust their configuration accordingly (e.g., by
choosing an alternative monitoring application).
Decision propagation is a computationally expensive task. In
general,decisionpropagationisNP-hardasitinvolvesfindingvalid
assignmentsforinterdependentbooleanvariables,alsoknown as
thebooleansatisfiabilityproblem(SAT),whichisNP-complete[ 25].
With FeatureIDE, we have implemented decision propagation ten
years ago and did not face scalability problems while using smaller
feature models. However, when our industry partner used Fea-
tureIDEwithsystemshavingmorethan18,000features,propaga-
tionofasingledecisiontookover20secondsonaverage,summing
up to 13 hours to create one configuration without even consid-ering the time required to reason about decisions and to interact
with the tool. While modern decision-propagation techniques can
reduce this time to a feasible level for human interaction, decision
propagation is still a bottleneck within automated configuration
processes such as t-wise sampling [2].
8982018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:44 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden S. Krieter et al.
We aim to speed up decision propagation by means of modal
implication graphs. We propose a graph-assisted decision propaga-
tionalgorithmtoreducethenumberofsatisfiabilityproblemstobe
solved.Theideaistoprecomputeimplicitdependenciesbetween
featuresandtomakethisinformationavailableduringconfigura-
tion.Inparticular,wedistinguishbetweentwophasesofthecon-
figurationprocess.Inthe offlinephaseamodalimplicationgraphis
constructedaccordingtothefeaturedependenciesofaconfigurable
system, which only needs to be re-executed if these dependencies
change. The actual decision propagation is part of the onlinephase,
in whichour proposed algorithm traversesthe modal implication
graph to determine the implied values. Our goal is to reduce the
computational effort needed during the online phase and, thus,
improve the response time of an interactive configuration process
and analyses that derive configurations (e.g., t-wise sampling). We
empiricallyevaluatetheimpactontheresponsetimebycomparing
decisionpropagationwithandwithoutmodalimplicationgraphs.
In short, our contributions are:
•We introduce modal implication graphs to represent and
access feature dependencies efficiently.
•Weproposeanalgorithmtopropagatedecisionsusingmodal
implication graphs.
•Weprovideanopen-sourceimplementationofouralgorithm
as part of the FeatureIDE framework.1
•We provide a large-scale evaluation of decision propaga-
tion, including existing algorithms, in terms of performance
during the offline and online phase.
2 FEATUREMODELSANDCONFIGURATIONS
A featuremodel expressesthe variabilityof aconfigurable system
bydefiningdistinctconfigurationoptions,calledfeatures,andtheir
interdependencies[ 8,11,26].Aconfigurationdefinesaselection
of features that are used to derive a particular system variant [8].
A common representation for feature models is a feature di-
agram, which represents feature dependencies in form of a tree
structure [ 29]. A more general way to describe feature models are
propositional formulas [ 11,29]. Though propositional formulas
lackstructuralinformation,theycanexpressanyarbitraryboolean
constraint between any group of features [49].
In this paper, we use the representation of feature models as
propositional formulas in conjunctive normal form (CNF). This
representationcanbeappliedtoallfeaturemodelrepresentations
thatusebooleanconstraints(e.g.,featurediagramscanbeconverted
into CNF) [ 1,11,29,49]. An advantage of CNF is that it allows for
automatedreasoningaboutfeaturesandtheirvalidconfiguration
using satisfiability (SAT) solvers [1, 61].
In Fig. 1, we depict the feature diagram of our running example,
theconfigurable Serversystem.Thefeature Serveristherootofthe
featuretreeandrepresentsthecommonpartofallvariantsofthe
configurable system. The features File System (FS) andOperating
System(OS) arebothmandatorychildrenof Server,whichmeans
eachvariantthatcontains Servermustalsocontain FSandOS.By
contrast, the feature Logging (Log) is an optional child of Server
and is not required if Serveris part of a variant. The children of FS
(i.e.,NTFS,HFS, and EXT) are part of an or-group, which means
1https://github.com/FeatureIDE/FeatureIDEFigure 1: Feature model for configurable Serversystem.
that at least one of them must be part of a variant that contains FS.
The children of OS(i.e.,Windows (Win), macOS (Mac), and Debian
(Deb))arepartofanalternative,whichmeansthatif OSispartofa
variant, exactly one of them must be present too. Additionally, the
feature model contains two cross-tree constraints, a bi-implication
betweenNTFSandWinandabi-implicationbetween HFSandMac.
Formally,wedefineafeaturemodel FM=(F,R)asapairofa
setoffeatures(i.e.,variables) Fandasetofconstraints(i.e.,clauses)
R. The set of features Fcontains all features of the configurable
system(i.e., F={f1,...,fn}withnbeingthenumberoffeatures).
FromFwe infer the set of literals L={l1,¬l1,...,ln,¬ln}that
represent the selection states of each feature, where liindicates
a selection and ¬lia deselection of feature fi. In particular, we
assumethat ¬¬liisequalto li.Wedefinethesetofconstraints R
asR⊆2L. Each element in Rrepresents a clause from the CNF.
Following our definition, the feature model depicted in Fig. 1 is
defined as:
FM=({Server,OS,FS,Log,Win,Mac,Deb,NTFS,HFS,EXT},
{{Server},{¬Win,NTFS},{Win,¬NTFS},
{Mac,¬HFS},{¬Mac,HFS},{OS},{FS},
{¬Win,¬Mac},{¬Win,¬Deb},{¬Mac,¬Deb},
{NTFS,HFS,EXT},{Win,Mac,Deb}} )
A configuration consists of a selection of features from a fea-
ture model. Formally, we define a configuration cfor a feature
modelFM=(F,R)as a set of literals in L, such that c∈C,
withC={c⊂L|∀l∈L:{l,¬l}/notsubseteqlc}. If a feature fiis se-
lected (i.e., li∈c) or deselected (i.e., ¬li∈c) in a configuration
we call it definedand otherwise undefined. Thus, a feature can
have one of three selection states, selected, deselected, or unde-
fined. We call a configuration ccomplete if every feature is de-
fined (i.e., complete(c,FM):=|c|=|F|), otherwise the config-
uration is partial. If a configuration csatisfies all constraints in
Rit isvalid(i.e.,valid(c,FM):=∀r∈R:r∩c/nequal∅), other-
wise it is invalid. Additionally, we call a configuration satisfiable,
if it is valid or can be made valid by defining more features (i.e.,
satisfiable (c,FM):=∃c/prime∈C:c⊆c/prime∧valid(c/prime,FM)).
Feature models may contain anomalies [ 13] such that certain
featureshavetoormustnotbeselected.Afeature fiisdeadiffitis
deselectedinanyvalidconfiguration(i.e., ∄c:li∈c∧valid(c,FM)).
Likewise, a feature fiiscoreiff it is not deselected in any valid
configuration (i.e., ∄c:¬li∈c∧valid(c,FM)). Iff a feature is
neither dead nor core we refer to it as variant.
The definitions of dead and core features can be generalized
by taken arbitrary partial configurations into account. Given a
899
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:44 UTC from IEEE Xplore.  Restrictions apply. Propagating Configuration Decisions with Modal Implication Graphs ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
satisfiableconfiguration candafeature fiwith{li,¬li}∩c=∅,fi
isconditionallydead iff¬satisfiable (c∪{li},FM)andconditionally
coreiff¬satisfiable (c∪{¬li},FM).Thesetofconditionallydead
and core features represents all features that are not explicitly
definedinasatisfiableconfiguration,butareimpliedorexcluded
implicitlybytheselectionstatesofotherfeatures.Therefore,we
use the definition of conditionally dead and core features as formal
basis of decision propagation.
3 SAT-BASED DECISION PROPAGATION
Ideally,userscreateacompleteandvalidconfigurationinaninterac-
tiveconfigurationprocessbysuccessivelyaddingnewliteralstoaninitiallyemptyset.Withinteractive,wemeanthatusersaregetting
feedbackduringtheconfigurationprocess.Withoutfurtherguid-
ance, it is possible that users select contradictory features and laterhavetobacktracktheirstepstoundooneormoreoftheirdecisions.
Decision propagation can beused to avoid backtracking, meaning
thatusersneverhavetorevoketheirdecisionsinordertoobtain
a valid configuration.Given a satisfiablepartial configuration and
acorrespondingfeaturemodel,decisionpropagationdetermines
allfeaturesthatareimplicitlydefined(i.e,conditionallydeadand
core features) and adds them to the given configuration. For in-stance,considerthesatisfiablepartialconfiguration
c={Server,
OS,FS,NTFS}for our running example. Only four features are
explicitlydefinedbythegivenconfiguration.However,giventhe
featuremodel’sdependenciessomeundefinedfeaturesarecondi-
tionallydeadorcore.Forexample,ifusersselectthefeature Mac,
theconfigurationwillbeinvalidnomatterwhatotherfeaturesthey
select. Thus, they must backtrack their steps until they resolve this
conflict. In contrast, if they apply decision propagation, the result-
ing configuration c/prime={Server,OS,FS,NTFS,Win,¬Mac,¬Deb,
¬HFS}includes all conditionally dead and core features.
A SAT-based algorithm for decision propagation reduces the
problemtomultipleinstancesoftheSATproblemandsolvingthese
usingoptimizedSATsolvers.Inparticular,thealgorithmtestsfor
eachundefinedfeature fiwhetherthegivenpartialconfiguration c
is still satisfiable if the fiis selected (i.e., satisfiable (c∪{li},FM))
or deselected (i.e., satisfiable (c∪{¬li},FM)).
InAlg.1,wedepictthegeneralprocessofSAT-baseddecision
propagation in pseudo code. The algorithm takes as input a fea-
ture model FMand a satisfiable configuration ccurrent, which in-
cludesthelatestdecisionoftheuser.Itreturnsaconfiguration cnew
thatcontainsallfeaturesthatareconditionallydeadorcore.The
main procedure decisionPropagation initializes cnewwith the
assignmentfrom ccurrent(cf.Line2)andcallsbothsub-procedures
getUnknownandtesttodeterminethestateofeachundefined
feature.getUnknownreturnstheset Lunknown thatcontainsall
literalsthat mustbecheckedusingthe SAT solver(cf. Line3). testdetermines for each literal in
Lunknown whether it is conditionally
deadorcore(cf.Line4–6).Both, cnewandLunknown areupdated
by test. Finally, the updated cnewis returned.
We show a straight-forward approach to implement both sub-
procedures getUnknown and test in Line 9–17 of Alg. 1. getUn-
known initializes Lunknown by adding two literals for each cur-
rently undefined feature (cf. Line 10). test investigates a single
literalltestfromLunknown by adding it to cnewand querying theAlgorithm 1 Naïve SAT-based testing algorithm
Require: FM=(F,R)– feature model
ccurrent – current configuration
Return: cnew – new configuration
Global: FM,Lunknown,cnew
1:procedure decisionPropagation()
2:cnew ←ccurrent
3:Lunknown ←getUnknown()
4:for allltest∈Lunknown do
5:test(ltest)
6:end for
7:returncnew
8:end procedure
9:procedure getUnknown()
10:return{l∈L|ccurrent∩{l,¬l}=∅}
11:end procedure
12:procedure test(ltest)
13:csolution←sat(FM,cnew∪{ltest})
14:ifcsolution =∅then
15:cnew←cnew∪{¬ltest}
16:end if
17:end procedure
SAT solver (cf. Line 13). If there is no satisfiable configuration cor-
responding to cnew∪{ltest}, every configuration that contains
all literals from cnewmust also contain the complement of ltest
(i.e.,¬ltest). Thus, the feature corresponding to ltestis either con-
ditionally core (i.e., ltestis negative) or dead (i.e., ltestis positive).
Consequently, ¬ltestis added to cnew(cf. Line 15).
FromAlg.1,wecanseethatforasingleexecutionofdecision
propagationthenaïvealgorithmhastocalltheSATsolvertwice
foreachundefinedfeature.ModernSATsolversalreadyapplytech-
niques such as incremental solving, which aims to reduce the com-
puting effort for repetitive SAT queries by learning and reusing
clauses that are implicitly implied by the original formula [ 32,52].
However,evenwhenemployingmodernSATsolvingtechniques,
the naïve algorithm does not scale to large configurable systems.
Janotaproposed amoreefficient waytodetermine whethera fea-
tureisconditionallydeadorcoregivenapartialconfiguration[ 43].
His advanced SAT-based algorithm employs the same concept, but
tries to reduce the number of tested literals. We show the relevant
codechangesinpseudocodeinAlg.2.Theconfigurationsfound
by the SAT solver are used to exclude literals from Lunknown (cf.
Line 3, 10). With this algorithm, our evaluation machine only re-
quired several minutes for configuring a system with more than
10,000 features. Janota’s algorithm also uses a special selection
strategyfortheSATsolver,whichdeterminestheorderinwhich
the solver considers literals to find asolution [ 43]. For brevity, we
exclude this selection strategy from the pseudo code.
4 GRAPH-ASSISTED DECISION
PROPAGATION
We aim to enhance SAT-based decision propagation by reducing
the number of necessary queries to the SAT solver. For this, we
900
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:44 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden S. Krieter et al.
Algorithm 2 Advanced SAT-based testing algorithm
1:procedure getUnknown()
2:csolution←sat(FM,cnew)
3:return{l∈L|ccurrent∩{l,¬l}=∅}\csolution
4:end procedure
5:procedure test(ltest)
6:csolution←sat(FM,cnew∪{ltest})
7:ifcsolution =∅then
8:cnew ←cnew∪{¬ltest}
9:else
10:Lunknown ←Lunknown \csolution
11:end if
12:end procedure
proposemodal implication graphs (MIGs), which represent certain
relationships between features in the feature model. In our ap-
proach, we differentiate between an offline phase, in which we
compute a modal implication graph for a particular feature model
andanonlinephase,inwhichweuseitfordecisionpropagation.
Theofflinephaseonlyneedstobeexecutedwhenthefeaturemodel
is modified, whereas the online phase is part of every configura-
tion process. Our approach is based on two observations we made
regarding decision propagation for large-scale feature models:
(1)In most cases the definition of a feature only affects a small
set of other features.
(2)If other features are affected, it often results from binary
requiresandexcludesconstraints.
Thus,weintroducemodalimplicationgraphsinSection4.1to(1)
identify the set of affected features and (2) determine some of their
selection states in the configuration. In Section 4.2, we present an
algorithm to derive a modal implication graph and describe the
graph’susageforgraph-assisteddecisionpropagationinSection4.3.
4.1 Modal Implication Graphs
Animplicationgraphisadirectedgraphthatdescribesaproposi-
tional formula consisting of a conjunction of implications between
single literals (i.e., binary relations). Each node represents a literal
of a variable and a directed edge from one node to another rep-
resentsabinaryrelation.Afeaturemodel’sbinarydependencies
can be transformed into an implication graph by representing each
feature by a positive and a negative node and each requires and
excludes constraint by an edge [29].
Analogoustoanimplicationgraph,themodalimplicationgraph
forafeaturemodelconsistsofnodesthatrepresenttheliteralsof
eachfeatureanddirectededgesthatrepresenttherelationsbetween
these literals. We extend implication graphs by introducing an
additional edge type to express n-ary relations, such as or-groups
with three or more features.
Wedifferentiatebetweentwotypesofedges, weakandstrong.A
strong edge indicates a binary relation (e.g., requires and excludes)
between two features. If the literal of the source node is element of
aconfiguration,thenalsotheliteralofthedestinationnodemust
be element of the configuration. In contrast, a weak edge indicates
thattwoliteralsare partofann-aryconstraint,whichinvolvesat
least one other literal. For a partial configuration these weak edgescould become strong edges due to the selection and deselection of
other features.
Amodalimplicationgraphforourrunningexamplecanbeseen
inFig.2. Duetothealternativegroup, thereisastrongedge from
Macto¬Win, which implies that if feature Macis selected feature
Winmust be deselected (i.e., Mac∈c→¬Win∈c). In addition,
there is a weak edge from ¬WintoMac, also resulting from the
alternativegroup,whichmeansthatundercertainconditions(i.e.,iffeatureDebisdeselected) Macmustbeselectedif Winisdeselected.
In other words, this edge will become strong, if Debis deselected.
Formally, we define a modal implication graph G=(L,S,W)
to be a triple consisting of a set of nodes L, which is equal to the
set of literals, a set of strong edges S, and a set of weak edges W,
such that S,W⊆{ (lstart,lend)|lstart,lend∈L,lstart /nequallend}
andS∩W=∅. As implications are transitive, we are interested
notonlyinedges,whichdirectlyconnecttwoliterals,butalsoin
pathswithinagraph.Analogoustoedgetypes,wealsodifferentiate
betweenstrongandweak paths. We call a path from one node to
anotherstrong,ifitconsistssolelyofstrongedgesand weak,ifit
containsatleastoneweakedge.Ifthereexistsatleastonestrong
pathfromanode lstoanode ltwedenotethiswith ls/trianglerightsldGltand
callltstronglyconnected tols.Complementarytothis,ifthereexist
onlyweakpathsfrom lttols,wedenotethiswith ls⊿Gltandcall
ltweaklyconnected tols.Withinthecontextofamodalimplication
graphG, we define /trianglerightsldGand⊿Gas:
/trianglerightsld={(ls,lt)∈L2|(ls,lt)∈S∨∃lm∈L:ls/trianglerightsldlm/trianglerightsldlt}
⊿={(ls,lt)∈L2|ls/negationslash/trianglerightsldlt,(ls,lt)∈W∨∃lm∈L:
(ls⊿lm⊿lt)∨(ls⊿lm/trianglerightsldlt)∨(ls/trianglerightsldlm⊿lt)}
Stronglyconnectedliteralsaredirectlydependent,whileweakly
connected literals also depend on other literals. Moreover, non-
connected literals are completely independent of each other. Thus,
wecanusethemodalimplicationgraphtounderstandtherelation-
ship between any two features by looking at the paths between
their respective nodes.
For instance, in the modal implication graph from the Server
system,¬NTFSisstronglyconnectedto Mac(via¬Win).Hence,if
Macisselectedinasatisfiableconfiguration, NTFSmustbedese-
lected. In contrast, Debis weakly connected to ¬NTFS(via¬Win).
Thus, ifNTFSis deselected in a satisfiable configuration, Debmust
be selected for certain conditions, which, in this example, is thedeselection of Mac. Finally, no node is connected to
Log, which
means that it is independent of all other literals.
4.2 Deriving Modal Implication Graphs
(Offline Phase)
Before using a modal implication graph in decision propagation
(i.e.,onlinephase),weneedtoderiveitfromafeaturemodel(i.e.,
offline phase). If the corresponding model evolves, the graph must
be recreated, before the next decision propagation. A modal im-
plication graph is constructed by creatingand analyzing a feature
model’s CNF. The CNF clauses can be categorized by their number
of literals. Clauses containing just one literal (i.e., unit-clauses) can
beignored,astheydescribenorelationshipbetweenfeatures,but
simply make the respective features core or dead. Clauses with ex-
actly two literals (i.e., two-literal clauses) are used to derive strong
901
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:44 UTC from IEEE Xplore.  Restrictions apply. Propagating Configuration Decisions with Modal Implication Graphs ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
¬ NTFS
 ¬ HFS 
¬ Mac
 Mac
¬ EXT¬ Deb 
HFSDeb
Win¬ Win
NTFSEXT
¬ Log
 
Log
Figure 2: Modal implication graph for Serversystem.
edges. Weak edges are derived from the remaining clauses, which
containmorethantwoliterals(i.e.,n-literalclauses).Wepropose
the following four steps to derive a graph with minimal number of
nodes and edges.
Step 1– Adding Nodes. In the first step, we initialize the graph
byaddingtwoliteralnodesforeachvariantfeature.Asdeadand
corefeaturesarenotrelevantfordecisionpropagation,weonlyadd
variant features, to reduce the graph’s memory space consumption
andsaveunnecessarytraversalduringtheonlinephase.Wecom-
pute the set of variant features by running Alg. 2 with an empty
configuration. In our running example the features Server,OS, and
FSare core and, thus, excluded from the graph (cf. Fig. 2).
Step 2 – Adding Edges. In the second step, we add edges ac-
cording to the following pattern. For each two-literal clause, we
addtwostrongedgestothegraph,aseachtwo-literalclausecan
be transformed into two equivalent implications. For instance,
the clause ¬Win∨¬Maccan be transformed into Win⇒¬Mac
andMac⇒¬Win. Thus, we add two strong edges from Winto
¬Macand from Macto¬Win. Likewise, an n-literal clause can be
transformed into nequivalent implications. In this case, we add
a weak edge for each pairwise combination of literals (i.e., in to-
taln·(n−1)). For example, the clause NTFS∨HFS∨EXTcan be
transformedinto ¬NTFS⇒(HFS∨EXT),¬HFS⇒(NTFS∨EXT),
and¬EXT⇒(NTFS∨HFS),resultinginsixweakedges(e.g.,from
¬NTFStoHFSand toEXT).
Beforetransformingaclause,wetestitforobviousredundancies.
Inparticular,weremoveliteralsthatareduplicatesorthatcannever
be true (i.e., core and dead features) and remove clauses that are
tautologies.Forinstance,inourexampletheclause (¬Win∨OS)
isatautology,as OSisacorefeature.Likewise,wecouldremove
¬OSfrom(¬OS∨Win∨Mac∨Deb), since it can never be true.
Step3–A ddingImplicitStrongEdges. Theinitiallyconstructed
graph can contain implicit strong relationships between literalsthat are only weakly connected [
7]. For instance, in the graph
of our running example ¬Debis weakly connected to ¬EXT(cf.
Fig.2).However,duetothefeaturemodel’sor-groupandcross-tree
constraints, ¬EXTdirectly implies ¬Deband, thus, there could be
a strong edge from ¬EXTto¬Deb.
To find implicit strong edges, we employ a depth-first search
that investigates all pairs of weakly connected nodes. We start thesearchwithanarbitrarynode Aandconsidereachnode Bthatis
weaklyconnectedtoit.UsingtheSATsolver,wecheck,whether
AimpliesB. In that case, we add a strong edge from AtoBand
recursivelycontinuethesearchwith Basnewstartingnode.Due
to this depth-first search, we are able to deduce strong edges by
transitivity without querying the SAT solver (e.g. from A/trianglerightsldBand
B/trianglerightsldC, we can deduce that A/trianglerightsldC). We repeat the search with
different starting literals until we checked every pair of weakly
connected nodes.
Step4–RemovingRedundantWeakEdges. Redundantweakedges
areweakedgesthatcanberemovedfromagraphwithoutchanging
its reachability. They can occur due to the inclusion of implicitstrong edges in step three and redundant constraint in the CNF.
The removal of redundantedges saves memory and decreases the
number of weak paths that must be traversed in the online phase.
Toremoveredundantweakedges,weconsidertheircorrespond-
ingclausesintheCNF.Webeginwithorderingthelistofallclausesbytheirnumberofliteralsindescendingorder,aslargerclausesaremorelikelytoberedundant.Foreachn-literalclause,wequerythe
SATsolvertotestwhethertheclauseisredundantregardingthe
current list of clauses and remove it from the list if it is redundant.
Forexample,wewouldremovetheclause (NTFS∨HFS∨EXT),if
there would be an additional clause (NTFS∨HFS), as this clause
subsumes the former. If a weak edge is no longer represented by
any clause in the CNF, we remove it from the graph.
Alternative Construction Process. Step3and4areoptionaland
canbeconsideredatrade-offbetweenofflineandonlinetime.As
Step 3 is the most time consuming one, we evaluate its impactin our evaluation, regarding both, offline and online time. When
step three was applied during the construction process, we call theresulting modal implication graph complete(because it contains all
possible strong edges). In contrast, if the step was skipped, we call
the resulting graph incomplete.
4.3 Using Modal Implication Graphs for
Decision Propagation (Online Phase)
Weemploymodalimplicationgraphsinourgraph-assisteddecision
propagationalgorithmtoreducethenumberofSATqueriesduring
theonlinephase.ThealgorithmisbasedonAlg.1(cf.Section3),but makes two major changes. First, it traverses strong paths forknown literals to find implied literals without querying the SATsolver. Second, it only tests literals that can be reached via weak
paths from the starting literal, which excludes features unaffected
by a given decision.
InAlg.3,wepresenttherelevantdifferencesoverAlg.1.Inaddi-
tiontoafeaturemodel FMandthecurrentconfiguration ccurrent,
the graph-assisted algorithm requires the modal implication graph
Gand the most recent decision in form of a literal lnew.
The procedure getUnknown (cf. Line 1–9) traverses the modal
implicationgraphtofindpotentiallyimpliedliterals.First,theal-
gorithm checks whether there are any weak edges in the graph
that can be transformed into strong edges according to the current
configuration(cf.Line2,22–23).Second,theoutgoingstrongpathsfrom
lnewaretraversed(cf.Line3).Eachliteralthatcanbereached
viaastrongpathisaddedto cnew(i.e.,withoutanySATqueries).
902
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:44 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden S. Krieter et al.
Algorithm 3 Graph-assisted testing algorithm
Require: FM=(F,R)– feature model
G=(L,S,W)– modal implication graph
lnew – literal of most recent decision
Return: cnew – new configuration
Global: FM,G,lnew,cnew,Lunknown
1:procedure getUnknown()
2:G/prime←updateGraph( G)
3:cnew ←cnew∪{l∈L|lnew/trianglerightsldG/primel}
4:Lunknown ←{l∈L|{l,¬l}∩cnew=∅∧lnew⊿G/primel}
5:ifLunknown /nequal∅then
6:Lunknown ←Lunknown\sat(FM,cnew)
7:end if
8:returnLunknown
9:end procedure
10:procedure test(ltest)
11:csolution←sat(FM,cnew∪{ltest})
12:ifcsolution =∅then
13:G/prime←updateGraph( G)
14:Lstronд ←{l∈L|¬ltest/trianglerightsldG/primel}
15:cnew ←cnew∪{¬ltest}∪Lstronд
16:Lunknown ←Lunknown \{¬l|l∈Lstronд}
17:else
18:Lunknown ←Lunknown \csolution
19:end if
20:end procedure
21:procedure updateGraph( Gold)
22:R/prime←{r\{¬l|l∈cnew}|r∈R,r∩cnew=∅}
23:returnupdateEdges( Gold,R/prime)
24:end procedure
Third,alloutgoingweakpathsaretraversedfor lnew.Allliterals
that belong to undefined features and can be reached via a weak
path are added to Lunkown(cf. Line 4).
The procedure test is similar to the procedure of the advanced
SAT-based algorithm. In addition, test utilizes the modal implica-
tiongraphwheneveranimpliedliteralisfoundbytheSATsolver
(cf. Line 13–16). For each found literal the graph’s weak edges
areupdatedagainandtheoutgoingstrongpathsaretraversed(cf.
Line 13–14). All reachable literals are added to cnewand removed
fromLunknown (cf. Line 15–16).
5 EVALUATION
With modal implication graphs (MIGs), we aim to speed-up the
onlinephaseofdecisionpropagationbydoingfurthercomputations
in the offline phase. Therefore, we evaluate the performance of
different decision-propagation algorithms. We compare the offline
andonlineexecutiontimeofgraph-assisteddecisionpropagation
usingmodalimplicationgraphs(cf.Section4)againstSAT-based
decisionpropagation(cf.Section3).Indetail,weaimtoanswerthe
following research questions:
RQ1Doesthechoiceofadecisionpropagationalgorithmaffect
the execution time of the offlinephase?
RQ2Doesthechoiceofadecisionpropagationalgorithmaffect
the execution time of the onlinephase?RQ3Givenanumberofconfigurationprocesses(i.e.,onlinephas-
es), which decision propagation algorithm is superior to
othersintermsofoverallexecutiontimeandmemorycon-
sumption?
5.1 Experimental Setup
To answer our research questions, we perform two experiments
with one factor and four treatments. In summary, we compare four
different algorithms for decision propagation using 120 real-world
systems.Inadditiontoexecutiontime,wemeasurethememorycon-
sumptionofthe derivedmodalimplicationgraphforeach feature
model.Inthefollowing,wedescribewhichconfigurablesystems
anddecision-propagationalgorithmsweconsider,howwedesigned
the individual experiments, and what values we measure during
a single experiment. All computations during the evaluation were
run on a notebook with the following specifications: CPU: Intel
XeonE3-1505Mv5(2.80 GHz),RAM:64 GB,OS:Windows7,Java
Version: 1.8.0_121 (64-Bit). Memory consumption was measured
using the Java Instrumentation package.
Configurable Systems (Subjects). In our evaluation, we use the
featuremodelsof120real-worldconfigurablesystemswithvarying
sizesandcomplexity,whichhavebeenusedinpriorstudies[ 17,49].
Themajorityofthesefeaturemodels(117)containbetween1,166
and1,397features.Ofthese117models,107comprisebetween2,968and4,138cross-treeconstraints,whileonehas14,295andtheother
nine have between 49,770 and 50,606 cross-tree constraints. The
remainingthreemodelscontainanevenhighernumberoffeatures.
ThefeaturemodelsfromthesystemsAutomotive01,Automotive02,
and Linux contain 2,513, 18,616, and 6,889 features and 2,833, 1,369,
and 80,715 constraints, respectively.
Decision-Propagation Algorithms (Treatments). In our evaluation,
we compare the following algorithms:
(1) Naïve SAT-based (NSAT)(2) Advanced SAT-based (ASAT)(3) Graph-assisted using an incomplete MIG (IMIG)
(4) Graph-assisted using a complete MIG (CMIG)
Toensureafaircomparisonofallalgorithms,weemployawhite-
boxevaluation,whereeachalgorithmusesthesamebaseimplemen-
tationas describedinSection3. Weprovide allalgorithmsaspart
of the open-source framework FeatureIDE2Our implementation
uses Java and the default SAT solver of Sat4J (Version 2.3.5) [ 52].
With Sat4J, we are able to employ incremental SAT solving. For
each feature model we create a separate solver, which is able todeduce new clauses while solving a query and later reuse these
clauses in subsequent queries.
Eachalgorithmperformscertaintasksduringitsofflinephase.
BothSAT-basedalgorithms(cf.Section3)determinethecoreand
dead features (i.e., initial decision propagation). In addition to com-
putingcoreanddeadfeatures,bothgraph-assistedalgorithms(cf.
Section4)deriveamodalimplicationgraph.WhileCMIGderives
a complete graph (i.e., containing all explicit and implicit strongedges), IMIG derives an incomplete graph (cf. Section 4.2). The
modalimplicationgraphisimplementedasanadjacencylist,due
2https://github.com/skrieter/MIG-Evaluation
903
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:44 UTC from IEEE Xplore.  Restrictions apply. Propagating Configuration Decisions with Modal Implication Graphs ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
to reasons of memory efficiency. It is stored to and loaded from
persistent memory using Java’s serialization mechanism.
Duringtheironlinephase,allalgorithmscalculateimpliedand
excludedfeatures, asdescribed inSection3 and4. Whilethe SAT-
basedalgorithmssolelyquerytheSATsolver,thegraph-assisted
algorithmsadditionallytraversethroughamodalimplicationgraph
to avoid SAT queries.
OfflinePhase(Experiment1). ToanswerRQ1,wemeasuretheex-
ecutiontimeforeachalgorithm’sofflinephase.Asstatedabove,the
offline phase of each algorithm consists of all tasks after receiving
theCNFofafeaturemodelandbeforestartingtheactualconfigura-
tion process. As the process of creating a CNF is independent from
the chosen algorithm, we do not include it as part of the offline
phase, but use the CNF as initial parameter for each algorithm. To
avoid computational bias and calculate a representable mean value
for each feature model and algorithm, we repeat the experiment
200 times.Furthermore, we compensate forthe warm-up effectof
the Java virtual machine (JVM) by performing an initial execution
without any measurement.
Online Phase (Experiment 2). To answer RQ2, we measure the
execution time for each algorithm’s online phase. We simulate a
configuration process by using random decisions, as we cannotknow which decisions users would make in their configurationsand want to avoid relying on false assumptions. The simulated
configuration process consists of the following steps:
(1) Start with an empty configuration(2) Randomly choose an undefined feature(3) Randomly define the feature (i.e., select or deselect)(4) Apply decision propagation(5) Repeat 2–4 until all features are defined
Wemeasuretheexecutiontimeforeachindividualapplicationof
decisionpropagation.Intheexperiment,weneglectthetimethatauserwouldneedtomakeconfigurationdecisions(i.e.,reasoningand
input), as these values highly depend on the user and, thus, would
bias our results. Furthermore, this is not an issue for automated
configuration processes, such as t-wise sampling [2, 45].
Weuseapseudorandomgenerator,whichhastheadvantagethat
we can fix the random seed for each iteration of the experiment.
Therefore, we ensure that all algorithms get the same series of
random decision and, thus, that the resulting configurations areequal. To get meaningful results, we repeat the experiment 200
times with different random seeds. Analogous to Experiment 1, we
compensate for the JVM warm-up effect.
Hypotheses. In order to be able to draw meaningful conclusions,
we formulate the following null hypotheses from our research
question RQ1 and RQ2, respectively:
HRQ1
0The execution time of the offline phase is the same for all
investigated decision-propagation algorithms.
HRQ2
0The execution time of the online phase is the same for all
investigated decision-propagation algorithms.
Weconducttwoexperimentswithonefactor(i.e,executiontime)
and four treatments (i.e, algorithms) using the same subjects (i.e,feature models). Hence, we test our hypotheses using a paired
Wilcoxon-Mann-Whitneytest.Wechoose95%asourconfidenceinterval.OurexpectationisthattheofflinephaseofbothSAT-basedalgorithmsisfasterthantheofflinephaseofthegraph-assistedalgo-
rithms, but that they perform worse during the online phase. This
isduetothedifferenceineffortofthealgorithmsduringtheoffline
phase.NSATandASATdotheleastamountofprecomputations,
whileIMIGadditionallyderivesanincompletemodalimplication
graph and CMIG even derives a complete modal implication graph.
Thismeansthat,duringtheonlinephase,CMIGcanaccessmore
information than IMIG, while IMIG has more information than
ASAT and NSAT. Hence, we expect that for the offline phase NSAT
andASATarefasterthanIMIG,whichisagainfasterthanCMIG.
For the online phase, we expect that the fastest algorithm is CMIG,
followed by IMIG, ASAT, and NSAT, in that order.
5.2 Results and Interpretations
In the following, we present and analyze our evaluation results
and answer our research questions. In Table1, we give an excerpt
oftheaggregatedevaluationresultsforaselectionofoursubject
systems. For brevity, we do not list the results from all featuremodels.
3For each feature model, we list its number of features
and constraints, memory consumption of the modal implication
graph,andaggregatedmeasurementsofourexperiments.Weshow
the execution time that each algorithm needs during its offlinephase. Additionally, we show the execution time of the onlinephase when 3%, 10%, and 100% of variant features were defined.
The number of defined features includes the features defined by
decisionpropagation.All shownresultsrepresentthemean value
over the 200 conducted experiments. We also show the mean of all
values over all feature models and conducted experiments at the
bottomofthetable.However,weomittheresultsofNSAT,asits
offline phase is equal to ASAT and its online phase execution time
isordersofmagnitudelargerthanallotheralgorithms(e.g.,over
100timeslargercomparedtoASAT).Inthefollowing,wediscuss
the results in more detail.
OfflinePhase(Experiment1). Wedisplaytheresultsofourfirst
experimentinFig.3inthefirstdiagramformostfeaturemodels.
We excluded the four largest feature models (i.e., Automotive01,
Automotive02, FreeBSD, and Linux) from the diagram, as they are
visually hard to compare to the other models due to their size.
Nevertheless, we state the results for these models in Table 1. Each
data point represents the offline time of a particular algorithmand feature model. On the y-axis, we show the execution timein milliseconds and on the x-axis, the number of features in the
feature model. Ourdata reveals that the execution times fromthe
different algorithms differ in orders of magnitude. For instance,
forthefeaturemodelAutomotive01,ASATrequired67 ms,IMIG
696 ms, and CMIG 11,596 ms for the offline phase. In terms of
memoryconsumption,theadditionalmemoryrequiredtostorea
modalimplicationforIMIGandCMIGliesbetween0.25 MBforthe
feature model FreeBSD and 5.1 MB for Automotive02 with a mean
value of 0.9 MB over all 120 feature models.
InTable2,weshowthep-valuesoftheWilcoxon-Mann-Whitney
test for all pairwise combinations of algorithms. In all cases, we
receivedap-valueoflessthan10−15and,thus,wecanrejectournull
3A complete table can be found here: https://github.com/skrieter/MIG-Evaluation/
blob/master/ICSE2018_Evaluation/execution_times.pdf
904
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:44 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden S. Krieter et al.
Table1:Offlineandonlinetimeofevaluatedalgorithmsforaselectionoffeaturemodels(meanvalueover200experiments).
Feature Model #Features #Clauses MIG Mem- Offline time in s (∅ )/summationtext.1Online time in s for relative number of defined features (∅ )
ory (Byte) 3% 10% 100%
ASAT IMIG CMIG ASAT IMIG CMIG ASAT IMIG CMIG ASAT IMIG CMIG
FreeBSD 8.0.0 1,397 14,295 243,168 0.04 0.42 6.89 0.21 0.05 0.04 0.44 0.07 0.05 1.82 0.10 0.08
Automotive01 2,513 2,833 1,098,248 0.07 0.70 11.60 1.54 0.36 0.35 3.10 0.56 0.54 6.05 0.76 0.74Linux 2.6.28.6 6,889 80,715 2,157,320 0.27 16.75 399.98 11.78 5.75 4.24 26.98 8.39 5.63 80.67 10.07 6.66Automotive02 18,616 1,369 5,088,720 2.30 42.47 296.73 329.29 38.08 37.84 535.70 58.77 58.45 821.48 68.03 67.68
All models (∅ ) – – – 0.03 0.62 6.99 2.98 0.38 0.36 4.96 0.58 0.55 8.10 0.68 0.64
Figure 3: Execution time of offline (1), online (2), and combined offline and online phase (3) of all algorithms for multiple
featuremodels(sortedbysize).Break-evenpoint(4)oftwoalgorithmsindicatesthenumberofonlinephasesonealgorithm’soverall execution time becomes faster than another (e.g., CMIG is faster than ASAT for two or more online phases).
Table 2: Pairwise comparison of algorithms.
Attribute ASAT / IMIG ASAT / CMIG IMIG / CMIG
p-value HRQ1
0<10−15<10−15<10−15
p-value HRQ2
0<10−15<10−15<10−15
hypothesis HRQ1
0. For all feature models ASAT needs significantly
lesstimeforitsofflinephasethanthetwograph-assistedalgorithms.
Likewise, IMIG needs significantly less time than CMIG.
Therefore, we can answer RQ1: Yes, there is a significant dif-
ference in the time required for the offline phase of the differentalgorithms. These results are expected, as the algorithms’ offline
phases differ in the amount of precomputations. While ASAT only
detectscoreanddeadfeatures,IMIGhastoderiveanincomplete
modalimplicationgraphinaddition.Moreover,CMIGdoesallof
theaboveandalsocomputesimplicitstrongedgeswithinthemodal
implication graph to make it complete.
Online Phase (Experiment 2). We depict the aggregated results
of our second experiment in Fig. 3 in the second diagram for most
feature models. We provide the results for the remaining featuremodels in Table 1. Analogous to the diagram for the offline time,each data point represents the mean execution time over 200 ex-
perimentsforaparticularalgorithmtodefine100%ofthevariant
featuresofonefeaturemodel.Onthey-axis,weshowtheexecution
timeinmillisecondsand,onthex-axis,thenumberoffeaturesin
the feature model. From our data we can see that for every feature
modelASATrequiresmoreonlinetimethanbothgraph-assistedal-gorithms.Incontrast,thereisnobigdifferenceinthetimerequired
by both graph-assisted algorithms. Nevertheless, using CMIG indi-
cates slight improvements over IMIG.
To illustrate the results of the second experiment in more detail,
we depict the execution time for each individual decision propa-
gation for the feature model of Linux in Fig. 4. Each data pointoriginates from oneof the 200 conducted experiments and repre-
sent the execution time of decision propagation by a particular
algorithm.Onthey-axis,wedepictthetimeinmillisecondsand,on
the x-axis,the number of defined variant features beforedecision
propagationwasexecuted.Theregressioncurvesindicatethemean
execution time over 200 experiments. For ASAT the data pointsforaparticularx-valuespreadwidearoundtheregressioncurve.However, most data points lie above the data points from CMIG
andIMIG.WhileCMIGshowsslightlybetterresultsthanIMIG,thedifferencebetweenbothismostlyintherangeofafewmilliseconds.
It is also notable that, for both graph-assisted algorithms, there are
many data points that are close to zero.
905
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:44 UTC from IEEE Xplore.  Restrictions apply. Propagating Configuration Decisions with Modal Implication Graphs ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Figure 4: Execution time during online phase with ASAT,
IMIG, and CMIG for the feature model of Linux.
We list the results from the Wilcoxon-Mann-Whitney test for
Experiment 2in Table 2. Again, wecan reject our nullhypothesis
HRQ2
0aswereceivedap-valueoflessthan10−15foreachalgorithm
combination.ASATneedssignificantlymoretimethanIMIGand
CMIG,whereasCMIGisfasterthanIMIGtoasignificant,butrather
small degree.
Therefore,wecananswerRQ2:Yes,thereisasignificantdiffer-
enceintheexecutiontimeofdecisionpropagationforthedifferent
algorithms. These results correspond to our expectations, as allalgorithms can access a different amount of information during
theironlinephase.CMIGtraversesacompletemodalimplication
graph,whileIMIGusesagraphthatmightlackssomestrongedges.
Bycontrast,ASATdoesnotuseanyadditionaldatastructureand
hastoinferallneededfeaturedependencieson-the-fly.Thelowper-
formanceincrease ofCMIG overIMIG isdueto thesmall number
of implicit strong edges that can be derived in the offline phase.
ComparisonofOfflineandOnlinePhase. Asthenumberofconfig-
urationprocessesandchangestothefeaturemodelmightdifferfor
eachconfigurablesystem,weareinterestedinthecombinedcost
ofofflineandonlinephase.Forabettercomparisonofexecutiontimes for offline and online phase, we present the diagrams for
bothresultssidebysideinFig.3withbothdiagramssharingthe
same y-axis. Moreover, we visualize the combined cost of offlineand online phase in the third diagram of Fig. 3. In this diagram,
weaddthetimeneededfortheofflinephasetothetimerequired
to execute the online phase once. Again, we depict the results of
thealgorithmsforallbutthelargestfeaturemodels.Wevisualize
the number of online phases necessary for each algorithm to break
even with the other algorithms in the fourth diagram of Fig. 3.
ThevisualizationclearlyindicatesthatIMIGneedslesstimethan
ASAT even for just one iteration of the online phase. Regarding
CMIG, we see that its higher offline time compared to ASAT is
amortizedaftertwoiterationsoftheonlinephase.Inourevaluation,
we experienced only two exceptions of this observation for the
feature models FreeBSD (three iterations) and Automotive02 (five
iterations)(cf. Table1).Asthe onlinetimefor bothgraph-assistedapproaches only differs slightly, CMIG needs many more online
phasesinordertoamortizeitsinitialcostswhencomparedtoIMIG.
Indetail,wemeasuredbetween112and801necessaryiterations,
with a mean value of 185 over all feature models.
Considering the observations, we made from the evaluation re-
sults,wecananswerRQ3:InmostcasesIMIGissuperiortoboth
ASAT and CMIG in terms of overall execution time. Only when
consideringanincompleteonlinephase(i.e.,creatingonlyapartial
configuration)ASAToutperformsIMIGduetoitsefficientoffline
Phase. On the other hand CMIG outperforms IMIG for a high num-
ber of online phases (i.e., 112 in our experiments). Thus, in general
IMIG seems to be preferable over the other three algorithms, as it
provides a good trade-off between the time required for offline andonlinephase.ASATandCMIGarepreferableoverotheralgorithms
only in some extreme cases. When the feature model evolves more
frequentlythantheconfigurations,ASATcanbesuperior.Incase
that configurations are updated frequently while the feature model
does not evolve for a longer period of time, CMIG can be superior
as its online phase requires less time than ASAT and IMIG. Regard-
ingmemoryconsumption,inourexperimentswefoundthatthe
memory required tostore a modal implication graph wasat maxi-
mum5.1MB,whichisrelativelysmallcomparedtotheavailable
main memory on modern hardware. Thus, the additional memory
consumption can be neglected for most applications.
5.3 Threats to Validity
Internal.A number of issues might threaten the internal validity
ofourresults.First,bugsintheimplementationmightcausewrong
results.Wemitigatethisissuebydeployingunitteststotesteach
algorithm individually. Furthermore, we compared the resulting
configurations of all algorithms and found no difference during all
conducted experiments. Additionally, we use matured open-source
tools such as Sat4J to further reduce the possibility of bugs.
Second,theresultscouldbebiasedinfavorofourproposedal-
gorithms.Thisisduetothefact,thatweimplementedallevaluatedalgorithmsbyourselves.However,weusethesamebaseimplemen-
tation for all algorithms and, for each algorithm, we only do the
necessary modifications as described in Section 3 and Section 4.
Third, random input data might lead to unrepresentative results.
To simulate a configuration process, we used a series of random
decisions,whichmightnotcorrespondtoareal-worldconfigura-
tion. However, a randomized approach gave us the capability toefficiently do multiple iterations with distinct random seeds and,thus, gather more data. To avoid random bias, we evaluate each
setting in 200 iterations.
External. Therearesomethreatsthatmayaffectthegeneraliz-
ability of our results. First, our results might not transfer to real
configuration applications. Our simulated configuration process is
likelytobedifferentfromamanualconfigurationbyauserwithdo-
main knowledge. In addition, starting with a partial configurations
may mitigate the problem of slow initial decision propagations (cf.
Fig.4). However, a manual configuration process strongly depends
on the particular user, which could bias the results as well.
Second,thetestedfeaturemodelsmightnotberepresentativeof
featuremodelsusedinpractice.Tomitigatethisissue,wetested120
real-worldfeaturemodelswithavaryingnumberoffeaturesand
906
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:44 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden S. Krieter et al.
constraintsthathavebeenusedinpriorstudies[ 17,75].Further-
more,weincludedthelargestreal-worldfeaturemodelsreferenced
in literature at the moment.
Third, in our implementation, we only employ Sat4J as SAT
solver.However,weuseSat4Jasablack-box,suchthatothersolvers
(e.g.,SAT,CSP,BDD,MDD)couldalsobeplugged-in.Asweshift
SAT calls from the online to the offline phase, faster solvers should
improve both, online and offline computation.
6 RELATED WORK
InteractiveConfiguration. Manytoolsalreadyprovidedecision
propagation for an interactive configuration process. Among those
tools are GEARS [ 50,51], GUIDSL [ 11], S2T2 Configurator [ 21],
S.P.L.O.T.[ 60],andVariaMos[ 58].OurworkisbasedonSAT-based
decisionpropagationasproposedbyJanota[ 43].Othersproposedto
propagatedecisionsusingbinarydecisiondiagrams(BDDs)[ 36,62]
and constraint satisfaction problem (CSP) solvers [ 6,15]. BDDs are
somewhatsimilartoourmodalimplicationgraphs,asbothavoid
someeffortduringdecisionpropagation(i.e.,onlinephase)bymore
effortfortheircreation(i.e.,offlinephase).AproblemwithBDDs
is that they typically do not scale for feature models larger than
1,000features.Forinstance,thereisnoBDDforLinuxsofar.While
CSP solvers can handle constraints beyond boolean formulas as
needed for extended feature models [ 15], they often reduce inputs
tosatisfiabilityproblemsinternally.Hence,wehavelittlehopethat
theycouldimproveperformancecomparedtoourgraph-assisted
algorithm. Similar to CSP, satisfiability modulo theories (SMT) ex-
tend the boolean SAT problem to first-order logic [ 20]. As far as
weknow,SMTsolvers,suchasZ3[ 30],havenotbeenappliedto
decisionpropagationyet.However,asourapproachisindependent
from the actual solver, but instead tries to reduce the number of
requiredSATqueries,weassumethatapproachesthatemploySMT
solvers can also benefit from model implication graphs.
In our evaluation, we use configurable systems such as Linux
and eCos that provide their own feature modeling language and
correspondingconfigurationtools(i.e.,KConfig[ 90]andCDL[ 85]).
Although,theselanguagesallowformulti-valuedlogic,theycan
be translated into boolean feature models [ 18,49,78]. The KConfig
languagedifferentiatesbetween selectanddependsconstraints.In
termsofmodalimplicationgraphs,selectcanbeconsideredastrong
edge,asitdirectlyimpliesotherfeatures,whiledependscanbeseenasasetofweakedges.Incontrast,modalimplicationgraphsdonot
rely on manual specification of select and depends constraints, but
cancomputetherespectiverelationships,whichavoidsmistakes
by users and represents feature dependencies more efficiently.
Anothertechniquetoavoidcontradictionswithinaconfiguration
iserror resolution, which automatically detects and tries to resolve
conflicts[ 14,66,87].Configurationtoolsthatsupportthiskindof
techniqueare,forexample,pure::variants[ 19,72]andFaMa[ 14].
Contrarytodecisionpropagation,errorresolutioncanbeapplied
at any point during or after the configuration process. To support
error resolution,modalimplication graphscan becombinedwith
cycle detection algorithms.
Decreasing the configuration time can also be achieved by con-
sidering only a subset of system’s configuration options. Users
mightbeinterestedincertainpartialconfigurationsoronlyneedtoconfigureasub-treeofthefeaturemodel.Anexampleofthisare
staged configurations [ 27] and the configuration of decomposed
or sliced feature models [ 74,75]. While, in our evaluation, we only
focusedoncompleteconfiguration,modalimplicationgraphscould
alsospeed-uppartialconfigurationprocesses(cf.Fig.4).
Aninteractiveconfigurationprocessisnotlimitedtoensurevalid
configurations, but can also provide other useful information. For
instance, users can be supported by recommender systems [ 69], or
visualfeedback[ 57,65].Alltechniquesthatconsiderfeaturedepen-
denciescanpotentially benefitfrommodalimplication graphs,as
they provide a fast and complete access to binary feature relations.
Automated Configuration. Besides manual configuration by a
user, configurations can also be created automatically by certainalgorithms. A use-case for automated configuration is product-based testing, which requires the generation of a representative
sampleofconfigurations[ 2–5,9,22–24,31,33–35,37–41,44–48,53–
56,67,68,70,71,73,76,79,80,82].Anotherusecaseistheproduct
generationviaoptimizationofnon-functionalproperties[ 15,66,77,
86,88]. Similar to manual configuration, decision propagationcan
beusedinanautomatedconfigurationprocesstoquerythefeature
model and derive valid configurations. Thus, modal implication
graphs could also be applied in automated configuration processes.
Product-Line Analyses. There exist many analyses for config-
urable systems that reason about feature-model dependencies [ 10,
13,28,53,63,83,84].Forinstance,inourwork,weusetheanalysis
of finding core and dead features. Similar to decision propagation,
mostanalysescanbeimplementedusingSATsolvers[ 13,84].There-
fore, modal implications graphs could be used to speed up those
analyses as well.
7 CONCLUSION AND FUTURE WORK
Decision propagation is a useful method for an interactive con-
figurationprocess.Itpreventsusersfromdefiningcontradictions
during the configuration process. However, current implementa-
tions do not scale well for large-scale configurable systems. In this
work, we introduced modal implication graphs, an extension of
implication graphs for feature models to support the application of
decision propagation. We presented the concept of modal implica-
tiongraphs,theirderivationfromfeaturemodels,andhowtheyare
employed during decision propagation. Based on our open-source
implementation, we evaluated the benefits of using graph-assisted
decision propagation for a complete configuration process and rea-
soned about its trade-offs. Compared to a SAT-based approach,
usingmodalimplicationgraphscansignificantlyspeedupdecision
propagation and, thus, make its application feasible for large-scale
configurable systems.
In future work, we will apply modal implication graphs to appli-
cations beyond decision propagation. We are convinced that many
existing approaches could profit from modal implication graphs.
This includes analyses such as atomic sets, visualization of feature
model dependencies, and product-based testing.
Acknowledgments: ThorstenBerger, AlexanderKnüppel, Chris-
tian Kästner. This work is partially funded by DFG (LE 3382/3-1).
907
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:44 UTC from IEEE Xplore.  Restrictions apply. Propagating Configuration Decisions with Modal Implication Graphs ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
REFERENCES
[1]K. Z. Ahmed, Bestoun S.and Zamli, W. Afzal, and M. Bures. Constrained In-
teraction Testing: A Systematic Literature Study. IEEE Access, 5:25706–25730,
2017.
[2]M. Al-Hajjaji, S. Krieter, T. Thüm, M. Lochau, and G. Saake. IncLing: Efficient
Product-line Testing Using Incremental Pairwise Sampling. In Proceedings of the
International Conference on Generative Programming and Component Engineering
(GPCE), pages 144–155. ACM, 2016.
[3]M. Al-Hajjaji, S. Lity, R. Lachmann, T. Thüm, I. Schaefer, and G. Saake. Delta-
Oriented Product Prioritization for Similarity-Based Product-Line Testing. pages
34–40. IEEE Computer Science, 2017.
[4]M.Al-Hajjaji,J. Meinicke, S.Krieter,R.Schröter,T.Thüm,T.Leich,andG. Saake.
Tool Demo: Testing Configurable Systems with FeatureIDE. In Proceedings of the
International Conference on Generative Programming and Component Engineering
(GPCE), pages 173–177. ACM, 2016.
[5]M. Al-Hajjaji, T. Thüm, M. Lochau, J. Meinicke, and G. Saake. Effective Product-
Line Testing Using Similarity-Based Product Prioritization. 2018. To appear.
[6]J. Amilhastre, H. Fargier, and P. Marquis. Consistency Restoration and Expla-
nations in Dynamic CSPs-Application to Configuration. Artificial Intelligence,
135(1-2):199–234, 2002.
[7]S. Ananieva, M. Kowal, T. Thüm, and I. Schaefer. Implicit Constraints in Partial
Feature Models. In Proceedings of the International SPLC Workshop Feature-
Oriented Software Development (FOSD), pages 18–27. ACM, 2016.
[8]S.Apel,D.Batory,C.Kästner,andG.Saake. Feature-OrientedSoftwareProduct
Lines: Concepts and Implementation. Springer, 2013.
[9]P.Arcaini,A.Gargantini,andP.Vavassori. GeneratingTestsforDetectingFaults
in Feature Models. In Proceedings of the International Conference on Software
Testing,VerificationandValidation(ICST),pages1–10.IEEEComputerScience,
2015.
[10]L. Aversano, M. D. Penta, and I.D. Baxter. Handling Preprocessor-Conditioned
Declarations. pages 83–92. IEEE Computer Science, 2002.
[11]D.Batory. FeatureModels,Grammars,andPropositionalFormulas. In Proceedings
oftheInternationalSoftwareProductLineConference(SPLC),pages7–20.Springer,
2005.
[12]D. Batory, D. Benavides, and A. Ruiz-Cortés. Automated Analyses of Feature
Models: Challenges Ahead. Communications of the ACM, 2006.
[13]D. Benavides, S. Segura, and A. Ruiz-Cortés. Automated Analysis of Feature
Models 20 Years Later: A Literature Review. Information Systems, 35(6):615–708,
2010.
[14]D. Benavides, S. Segura, P. Trinidad, and A. Ruiz-Cortés. FAMA: Tooling a
Framework for the Automated Analysis of Feature Models. In Proceedings of the
WorkshoponVariabilityModellingofSoftware-intensiveSystems(VaMoS),pages
129–134. Technical Report 2007-01, Lero, 2007.
[15]D.Benavides,P.Trinidad,andA.Ruiz-Cortés. UsingConstraintProgramming
toReasononFeatureModels. In ProceedingsoftheInternationalConferenceon
Software Engineering and Knowledge Engineering (SEKE), pages 677–682, 2005.
[16]T.Berger,R.Rublack,D.Nair,J.M.Atlee,M.Becker,K.Czarnecki,andA.Wą-
sowski. ASurveyofVariabilityModelinginIndustrialPractice. In Proceedings
oftheWorkshoponVariabilityModellingofSoftware-intensiveSystems(VaMoS),
pages 7:1–7:8. ACM, 2013.
[17]T.Berger,S.She,R.Lotufo,A.Wasowski,andK.Czarnecki. AStudyofVariability
ModelsandLanguagesintheSystemsSoftwareDomain. IEEETransactionson
Software Engineering (TSE), 39(12):1611–1640, 2013.
[18]T.Berger,S.She,R.Lotufo,A.Wąsowski,andK.Czarnecki. VariabilityModeling
intheReal: APerspectivefromtheOperatingSystems Domain. In Proceedings
of the InternationalConference on Automated Software Engineering (ASE), pages
73–82. ACM, 2010.
[19]D.Beuche. ModelingandBuildingSoftwareProductLineswithPure::Variants.
InProceedings of the International Software Product Line Conference (SPLC), pages
255–255, 2012.
[20]A.Biere,M.Heule,andH.vanMaaren. HandbookofSatisfiability,volume185.
IOS press, 2009.
[21]G.Botterweck,M.Janota,andD.Schneeweiss.ADesignofaConfigurableFeature
ModelConfigurator. In ProceedingsoftheWorkshoponVariabilityModellingof
Software-intensive Systems (VaMoS), pages 165–168. Universität Duisburg-Essen,
2009.
[22]I. D.Carmo Machado,J. D. McGregor, Y.a. C. Cavalcanti,and E.S. DeAlmeida.
OnStrategiesforTestingSoftwareProductLines:ASystematicLiteratureReview.
56(10):1183–1199, 2014.
[23]M. B. Cohen, M. B. Dwyer, and J. Shi. Coverage and Adequacy in Software
Product Line Testing. pages 53–63. ACM, 2006.
[24]M.B.Cohen,M.B.Dwyer,andJ.Shi. InteractionTestingofHighly-Configurable
Systems in the Presence of Constraints. pages 129–139. ACM, 2007.
[25]S.Cook. TheComplexityofTheorem-ProvingProcedures. In InProceedingsof
the Annual ACM Symposium on Theory of Computing, pages 151–158, 1971.
[26]K. Czarnecki and U. Eisenecker. Generative Programming: Methods, Tools, and
Applications. ACM/Addison-Wesley, 2000.[27]K.Czarnecki,S.Helsen,andU.Eisenecker. StagedConfigurationthroughSpe-
cializationandMulti-LevelConfigurationofFeatureModels. SoftwareProcess:
Improvement and Practice, 10(2):143–169, 2005.
[28]K.CzarneckiandK.Pietroszek.VerifyingFeature-BasedModelTemplatesAgainst
Well-FormednessOCLConstraints. In ProceedingsoftheInternationalConference
on Generative Programming and Component Engineering (GPCE), pages 211–220.
ACM, 2006.
[29]K.CzarneckiandA.Wąsowski. FeatureDiagramsandLogics:ThereandBack
Again. In ProceedingsoftheInternationalSoftwareProductLineConference(SPLC) ,
pages 23–34. IEEE Computer Science, 2007.
[30]L.DeMouraandN.Bjørner. Z3:AnEfficientSMTSolver. In InProceedingsofthe
InternationalConferenceonToolsandAlgorithmsfortheConstructionandAnalysis
of Systems (TACAS), pages 337–340. Springer, 2008.
[31]X.Devroey,G.Perrouin,A.Legay,P.-Y.Schobbens,andP.Heymans.CoveringSPL
BehaviourwithSampledConfigurations:AnInitialAssessment. In Proceedings
oftheWorkshoponVariabilityModellingofSoftware-intensiveSystems(VaMoS),
pages 59:59–59:66. ACM, 2015.
[32]N. Eén and N. Sörensson. An Extensible SAT-Solver. In In Proceedings of the
International Conference on Theory and Applications of Satisfiability Testing (SAT),
pages 502–518. Springer, 2003.
[33]A. Ensan, E.Bagheri, M. Asadi,D. Gasevic, and Y. Biletskiy. Goal-Oriented Test
CaseSelectionandPrioritizationforProductLineFeatureModels. In Proceedings
oftheInternationalConferenceonInformationTechnology:NewGenerations(ITNG),
pages 291–298. IEEE Computer Science, 2011.
[34]F.Ensan,E.Bagheri,andD.Gasevic. EvolutionarySearch-BasedTestGeneration
for Software Product Line Feature Models. In Proceedings of the International
Conference on Advanced Information Systems Engineering (CAiSE), volume 7328,
pages 613–628. Springer, 2012.
[35]S. Fischer, R. E. Lopez-Herrejon, R. Ramler, and A. Egyed. A Preliminary Empiri-
calAssessment ofSimilarityforCombinatorialInteractionTestingofSoftware
Product Lines. pages 15–18. ACM, 2016.
[36]T. Hadzic, S. Subbarayan, R. Jensen, H. Andersen, J. Møller, and H. Hulgaard.
Fast Backtrack-Free Product Configuration Using a Precompiled Solution Space
Representation. In In Proceedings of the International Conference on Economic,
Technical and Organizational Aspects of Product Configuration Systems, pages
131–138, 2004.
[37]A. Halin, A. Nuttinck, M. Acher, X. Devroey, G. Perrouin, and B. Baudry. Test
them all, is it worth it? A ground truth comparison of configuration sampling
strategies. CoRR, (arXiv:1710.07980), 2017.
[38]E. N. Haslinger, R. E. Lopez-Herrejon, and A. Egyed. Using Feature Model
KnowledgetoS peedUpthe GenerationofCoveringArrays. In Proceedingsofthe
WorkshoponVariabilityModellingofSoftware-intensiveSystems(VaMoS),pages
16:1–16:6. ACM, 2013.
[39]C.Henard,M.Papadakis,andY.LeTraon.Mutation-BasedGenerationofSoftwareProductLineTestConfigurations. InC.LeGouesandS.Yoo,editors, Search-Based
SoftwareEngineering,volume8636of LectureNotesinComputerScience,pages
92–106. Springer International Publishing, 2014.
[40]C. Henard, M. Papadakis, G. Perrouin, J. Klein, P. Heymans, and Y. L. Traon. By-
passingtheCombinatorialExplosion:UsingSimilaritytoGenerateandPrioritize
T-Wise Test Configurations for Software Product Lines. IEEE Transactions on
Software Engineering (TSE), 40(7):650–670, 2014.
[41]C. Henard, M. Papadakis, G. Perrouin, J. Klein, and Y. L. Traon. Multi-Objective
TestGenerationforSoftwareProductLines. In ProceedingsoftheInternational
Software Product Line Conference (SPLC), pages 62–71. ACM, 2013.
[42]A.Hubaux,Y.Xiong,andK.Czarnecki. AUserSurveyofConfigurationChal-
lengesinLinuxandeCos. In ProceedingsoftheWorkshoponVariabilityModelling
of Software-intensive Systems (VaMoS), pages 149–155, 2012.
[43]M. Janota. Do SAT Solvers Make Good Configurators? In Proceedings of the
International Software Product Line Conference (SPLC), pages 191–195, 2008.
[44]M.F.Johansen,Ø.Haugen,andF.Fleurey. PropertiesofRealisticFeatureModels
Make Combinatorial Testing of Product Lines Feasible. pages 638–652. Springer,
2011.
[45]M. F. Johansen, Ø. Haugen, and F. Fleurey. An Algorithm for Generating T-Wise
Covering Arrays from Large Feature Models. In Proceedings of the International
Software Product Line Conference (SPLC), pages 46–55. ACM, 2012.
[46]M.F.Johansen,Ø.Haugen,F.Fleurey,A.G.Eldegard,andT.Syversen. GeneratingBetterPartialCoveringArraysbyModelingWeightsonSub-ProductLines. pages
269–284. Springer, 2012.
[47]C. H. P. Kim, D. Batory, and S. Khurshid. Reducing Combinatorics in Testing
Product Lines. In Proceedings of the International Conference on Aspect-Oriented
Software Development (AOSD), pages 57—68. ACM, 2011.
[48]C. H. P. Kim, E. Bodden, D. Batory, and S. Khurshid. Reducing Configurations to
Monitor in a Software Product Line. pages 285–299. Springer, 2010.
[49]A. Knüppel, T. Thüm, S. Mennicke, J. Meinicke, and I. Schaefer. Is There a
MismatchBetweenReal-WorldFeatureModelsandProduct-LineResearch? In
Proceedings of the European Software Engineering Conference/Foundations of Soft-
ware Engineering (ESECFSE), pages 291–302. ACM, 2017.
908
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:44 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden S. Krieter et al.
[50]C. Krueger. BigLever Software Gears and the 3-tiered SPL Methodology. In
ProceedingsoftheConferenceonObject-OrientedProgramming,Systems,Languages
and Applications (OOPSLA), pages 844–845, 2007.
[51]C. Krueger and P. Clements. Systems and Software Product Line Engineering
withBigLeverSoftwareGears. In ProceedingsoftheInternationalSoftwareProduct
Line Conference (SPLC), pages 136–140, 2013.
[52]D.LeBerreandA.Parrain. TheSat4jLibrary,Release2.2,SystemDescription.
Journal on Satisfiability, Boolean Modeling and Computation, 7(2-3):59–64, 2010.
[53]J.Liebig,A.vonRhein,C.Kästner,S.Apel,J.Dörre,andC.Lengauer. Scalable
AnalysisofVariableSoftware. In ProceedingsoftheEuropeanSoftwareEngineering
Conference/FoundationsofSoftwareEngineering(ESECFSE),pages81–91.ACM,
2013.
[54]M. Lochau, I. Schaefer, J. Kamischke, and S. Lity. Incremental Model-Based
Testing of Delta-oriented Software Product Lines. pages 67–82. Springer, 2012.
[55]R. E. Lopez-Herrejon, J. Ferrer, F. Chicano, A. Egyed, and E. Alba. Compara-
tive Analysis of Classical Multi-Objective Evolutionary Algorithms and Seeding
StrategiesforPairwiseTestingofSoftwareProductLines. pages387–396.IEEE
Computer Science, 2014.
[56]D. Marijan, A. Gotlieb, S. Sen, and A. Hervieu. Practical Pairwise Testing for
Software Product Lines. In Proceedings of the International Software Product Line
Conference (SPLC), pages 227–235. ACM, 2013.
[57]J.L.Martinez,T.Ziadi,R.Mazo,T.F.Bissyandé,J.Klein,andY.LeTraon. Feature
Relations Graphs: A Visualisation Paradigm for Feature Constraints in Software
ProductLines. In ConferenceonSoftwareVisualization(VISSOFT),pages50–59.
IEEE, 2014.
[58]R. Mazo, C. Salinesi, and D. Diaz. VariaMos: A Tool for Product Line Driven
Systems Engineering with a Constraint Based Approach. In In Proceedings of the
InternationalConferenceonAdvancedInformationSystemsEngineering(CAiSE),
pages 147–154. CEUR-WS.org, 2012.
[59]M.Mendonça. EfficientReasoningTechniquesforLargeScaleFeatureModels.P h D
thesis, University of Waterloo, Canada, 2009.
[60]M. Mendonça, M. Branco, and D. Cowan. S.P.L.O.T.: Software Product Lines
OnlineTools. In Proceedingsof theConference onObject-OrientedProgramming,
Systems, Languages and Applications (OOPSLA), pages 761–762. ACM, 2009.
[61]M.Mendonça,A.Wąsowski,andK.Czarnecki. SAT-BasedAnalysisofFeature
ModelsisEasy.In ProceedingsoftheInternationalSoftwareProductLineConference
(SPLC), pages 231–240, 2009.
[62]M. Mendonça, A. Wąsowski, K. Czarnecki, and D. Cowan. Efficient Compilation
TechniquesforLargeScaleFeatureModels. In ProceedingsoftheInternational
ConferenceonGenerativeProgrammingandComponentEngineering(GPCE) ,pages
13–22. ACM, 2008.
[63]A. Metzger, K. Pohl, P. Heymans, P.-Y. Schobbens, and G. Saval. Disambiguating
the Documentation of Variability in Software Product Lines: A Separation of
Concerns, Formalization and Automated Analysis. In Requirements Engineering,
pages 243–253. IEEE Computer Science, 2007.
[64]S. Nadi, T. Berger, C. KÃďstner, and K. Czarnecki. Where Do Configuration
Constraints Stem From? An Extraction Approach and an Empirical Study. IEEE
Transactions on Software Engineering (TSE), 41(8):820–841, 2015.
[65]D.Nestor,S.Thiel,G.Botterweck,C.Cawley,andP.Healy.ApplyingVisualisation
Techniques in Software Product Lines. In In Proceedings of the Symposium on
Software Visualization (SoftVis), pages 175–184. ACM, 2008.
[66]L.Ochoa,O.González-Rojas,andT.Thüm. UsingDecisionRulesforSolvingCon-
flicts in Extended Feature Models. In Proceedings of the International Conference
on Software Language Engineering (SLE), pages 149–160. ACM, 2015.
[67]S.Oster,F.Markert,andP.Ritter. AutomatedIncrementalPairwiseTestingof
Software Product Lines. In Proceedings of the International Software Product Line
Conference (SPLC), pages 196–210. Springer, 2010.
[68]S. Oster, M. Zink, M. Lochau, and M. Grechanik. Pairwise Feature-interaction
TestingforSPLs:PotentialsandLimitations. In ProceedingsoftheInternational
Software Product Line Conference (SPLC), pages 6:1–6:8. ACM, 2011.
[69]J.A.Pereira,P.Matuszyk,S.Krieter,M.Spiliopoulou,andG.Saake. AFeature-
Based Personalized Recommender System for Product-Line Configuration. In
Proceedings of the International Conference on Generative Programming and Com-
ponent Engineering (GPCE), pages 120–131, 2016.
[70]G.Perrouin,S.Oster,S.Sen,J.Klein,B.Baudry,andY.LeTraon. PairwiseTesting
forSoftwareProductLines:ComparisonofTwoApproaches. SoftwareQualityJourna l (SQJ), 20(3-4):605–643, 2012.
[71]G. Perrouin, S. Sen, J. Klein, B. Baudry, and Y. Le Traon. Automated and Scalable
T-WiseTestCaseGenerationStrategiesforSoftwareProductLines.In Proceedings
of the International Conference on Software Testing, Verification and Validation
(ICST), pages 459–468. IEEE Computer Science, 2010.
[72]pure::systems. pure::variants. Website, 2017. Available online at http://www.
pure-systems.com/products/pure-variants-9.html; visited on May 10th, 2017.
[73]D.Reuling,J.Bürdek,S.Rotärmel,M.Lochau,andU.Kelter. Fault-BasedProduct-
Line Testing: Effective Sample Generation Based on Feature-Diagram Mutation.
InProceedings of the International Software Product Line Conference (SPLC), pages
131–140. ACM, 2015.
[74]J. Schroeter, M. Lochau, and T. Winkelmann. Multi-Perspectives on Feature
Models. pages 252–268. Springer, 2012.
[75]R. Schröter, S. Krieter, T. Thüm, F. Benduhn, and G. Saake. Feature-Model Inter-
faces: The Highway to Compositional Analyses of Highly-Configurable Systems.
InProceedings of the International Conference on Software Engineering (ICSE),
pages 667–678. ACM, 2016.
[76]J.Shi,M.B.Cohen,andM.B.Dwyer. IntegrationTestingofSoftwareProduct
LinesUsingCompositionalSymbolicExecution.In ProceedingsoftheInternational
Conference on Fundamental Approaches to Software Engineering (FASE), pages
270–284. Springer, 2012.
[77]N. Siegmund, M. Rosenmüller, M. Kuhlemann, C. Kästner, S. Apel, and G. Saake.
SPL Conqueror: Toward Optimization of Non-Functional Properties in Software
Product Lines. Software Quality Journal, 20(3-4):487–517, 2012.
[78]J. Sincero, H. Schirmeier, W. Schröder-Preikschat, and O. Spinczyk. Is the Linux
Kernel a Software Product Line? In Proceedings of the International Workshop
on Open Source Software and Product Lines (OSSPL) , pages 9–12. IEEE Computer
Science, 2007.
[79]R.Tartler,C.Dietrich,J.Sincero,W.Schröder-Preikschat,andD.Lohmann. Static
Analysis of Variability in System Software: The 90,000 #Ifdefs Issue. pages
421–432. USENIX Association, 2014.
[80]R. Tartler, D. Lohmann, C. Dietrich, C. Egger, and J. Sincero. Configuration
CoverageintheAnalysisofLarge-ScaleSystemSoftware. ACMSIGOPSOperating
Systems Review, 45(3):10–14, 2012.
[81]R.Tartler,D. Lohmann,J.Sincero,andW.Schröder-Preikschat. FeatureConsis-
tencyinCompile-Time-ConfigurableSystemSoftware:FacingtheLinux10,000
Feature Problem. In In Proceedings of the European Conference on Computer
Systems, pages 47–60, 2011.
[82]M. H. ter Beek, H. Muccini, and P. Pelliccione. Assume-Guarantee Testing of
Evolving Software Product Line Architectures. pages 91–105. Springer, 2012.
[83]S.Thaker,D.Batory,D.Kitchin,andW.Cook. SafeCompositionofProductLines.
InProceedings of the International Conference on Generative Programming and
Component Engineering (GPCE), pages 95–104. ACM, 2007.
[84]T. Thüm, S. Apel, C. Kästner, I. Schaefer, and G. Saake. A Classification and
Survey of Analysis Strategies for Software Product Lines. 47(1):6:1–6:45, 2014.
[85]B. Veer and J. Dallaway. The eCos Component Writer’s Guide. Manual,
2017. Availableonlineathttp://ecos.sourceware.org/ecos/docs-3.0/pdf/ecos-3.
0-cdl-guide-a4.pdf; visited on May 10th, 2017.
[86]J.White,B.Dougherty,andD.C.Schmidt.SelectingHighlyOptimalArchitectural
Feature Sets with Filtered Cartesian Flattening. Journal of Systems and Software
(JSS), 82(8):1268–1284, 2009.
[87]J.White,D.C.Schmidt,D.Benavides,P.Trinidad,andA.Ruiz-Cortés. Automated
DiagnosisofProduct-LineConfigurationErrorsinFeatureModels. In Proceedings
oftheInternationalSoftwareProductLineConference(SPLC),pages225–234.IEEE
Computer Science, 2008.
[88]J.White,D.C.Schmidt,E.Wuchner,andA.Nechypurenko. AutomatingProduct-
Line Variant Selection for Mobile Devices. In Proceedings of the International
Software Product Line Conference (SPLC), pages 129–140, 2007.
[89]H.YeandH. Liu. ApproachtoModellingFeatureVariability andDependencies
in Software Product Lines. IEE Proceedings - Software, 152(3):101–109, 2005.
[90]R. Zippel. KConfig Documentation. Website, 2017. Available online at http:
//www.kernel.org/doc/Documentation/kbuild/kconfig-language.txt;visitedon
May 10th, 2017.
909
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:44 UTC from IEEE Xplore.  Restrictions apply. 