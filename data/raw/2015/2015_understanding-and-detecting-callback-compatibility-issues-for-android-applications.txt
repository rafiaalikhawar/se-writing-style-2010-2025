Understanding and Detecting Callback Compatibility Issues for
Android Applications
Huaxun Huang
The Hong Kong University of Science and Technology
Hong Kong, China
hhuangas@cse.ust.hkLili Wei‚àó
The Hong Kong University of Science and Technology
Hong Kong, China
lweiae@cse.ust.hk
Yepang Liu‚àó
Southern University of Science and Technology
Shenzhen, China
liuyp1@sustc.edu.cnShing-Chi Cheung‚àó
The Hong Kong University of Science and Technology
Hong Kong, China
scc@cse.ust.hk
ABSTRACT
The control flows of Android apps are largely driven by the pro-
tocols that govern how callback APIs are invoked in response to
various events. When these callback APIs evolve along with the
Android framework, the changes in their invocation protocols can
induce unexpected control flows to existing Android apps, causing
various compatibility issues. We refer to these issues as callback
compatibility issues. While Android framework updates have re-
ceived due attention, little is known about their impacts on appcontrol flows and the callback compatibility issues thus induced.
To bridge the gap, we examined Android documentations and con-
ducted an empirical study on 100 real-world callback compatibility
issuestoinvestigatehowtheseissueswereinducedbycallbackAPI
evolutions.Basedonourempiricalfindings,weproposeagraph-
based model to capture the control flow inconsistencies caused by
API evolutions and devise a static analysis technique, Cider, to
detect callbackcompatibility issues.Our evaluationof Cider on 20popular open-source Android apps shows that Cider is effective. Itdetected 13 new callback compatibility issues in these apps, among
which 12 issues were confirmed and 9 issues were fixed.
CCS CONCEPTS
‚Ä¢Software and its engineering ‚ÜíSoftware verification and
validation ;‚Ä¢Human-centeredcomputing ‚ÜíSmartphones ;‚Ä¢
General and reference ‚ÜíEmpirical studies;
KEYWORDS
AndroidAPI,empiricalstudy,staticanalysis,callbackcompatibility
‚àóShing-ChiCheungandYepangLiuarethecorrespondingauthors.LiliWeiisalsoa
visiting student at the Southern University of Science and Technology.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
¬© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.3238181ACM Reference Format:
Huaxun Huang, Lili Wei, Yepang Liu, and Shing-Chi Cheung. 2018. Under-
standing and Detecting Callback Compatibility Issues for Android Applica-
tions. InProceedings of the 2018 33rd ACM/IEEE International Conference on
Automated Software Engineering (ASE ‚Äô18), September 3‚Äì7, 2018, Montpellier,
France.ACM,NewYork,NY,USA, 11pages.https://doi.org/10.1145/3238147.
3238181
1 INTRODUCTION
Androidappsareevent-driven. CallbackAPIs,overriddenandim-
plemented in Android apps, are invoked by the underlying oper-
ating system in response to various events. The control flows of
AndroidappsarelargelydrivenbythecallbackAPIinvocationpro-
tocols,whichdefinehowcallbackAPIsareinvokedtohandleevents.
However,callbackAPIsarefastevolvingalongwiththeAndroid
system[47].SuchevolutionscanchangecallbackAPIinvocation
protocolsandcauseappstoexhibitinconsistentcontrolflowswhen
runningondifferentversionsofAndroidsystem.Theseinconsis-
tencies make it difficult for app developers to correctly maintain
programdependenciesamongdifferentoverriddencallbackAPIs
across different API levels. As a result, various compatibility issues
arose.Inthispaper,werefertosuchissuesinducedbycallbackAPI
evolutions as callback compatibility issues.
Severaltechniqueshavebeendevisedtohelpanalyzethecontrol
flowsamongcallbackAPIsforAndroidapps.Forexample,Flow-
Droid [34] can construct dummy main methods to emulate the
execution orders of lifecycle callback APIs for activity components
of Android apps. Barros et al. [ 35] also presented a technique to
detectimplicitcontrolflowsinAndroidprograms.Whilethesetech-
niques helprecover controlflows for Androidapps, noneof them
canidentifyinconsistentappcontrolflowscausedbythecallback
APIevolutions.ResearchershavealsostudiedtheevolutionsofAn-
droid APIs. Linares et al. [ 46] analyzed how change-proneness and
error-pronenessofAndroidAPIsaffecttheratingsofAndroidapps.McDonnelletal.[
47]analyzedthehistoricaldataofasetofAndroid
apps to understand the relationship between API evolutions and
API adoption. Wei et al. [ 52] conducted the first longitudinal study
on the evolutions of permissions in the Android ecosystem. Weiet al. [
51] investigated the fragmentation-induced compatibility
issuesinAndroidappsincludingthosethatareinducedbyAndroid
APIevolutions.Whilethesepiecesofworkstudiedtheevolutions
of Android APIs, none of them considered the changes in callback
532
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:09 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Huaxun Huang, Lili Wei, Yepang Liu, and Shing-Chi Cheung
API invocation protocols introduced by these evolutions and the
control flow inconsistencies thus induced to Android apps.
In this paper, we first study the evolutions of callback APIs
to see how they can affect the invocation protocols of callback
APIs. We characterize the callback compatibility issues induced by
such theevolutions. To thisend, we conductedan empirical study
based on the API Reference in Android Developers [ 6], Android
API Differences Reports [ 2], Android Open Source Project [ 5], and
100callbackcompatibilityissuesfrom50open-sourceAndroidapps.
Our study aims to answer the following two research questions:
‚Ä¢RQ1 (Callback API Evolutions and Invocation Protocols)
Howdotheevolutions ofcallbackAPIschangethe APIinvocationprotocols? Are there any frequently-evolved callback APIs?
‚Ä¢RQ2 (Causes of Callback Compatibility Issues)
How do the
evolutions of callback APIs induce callback compatibility issues?
Are there major issue-inducing causes?
In answering RQ1, we identified two common types of callback
API evolutions: API reachability change andAPI behavioral modifi-
cation.TheformertypechangesthereachabilityofcallbackAPIs
while the latter type changes the invocation conditions and be-
haviors of the concerned callback APIs. Both of the two types of
changes in callback API evolutions can alter app control flows and
induce callback compatibility issues. In answering RQ2, we ob-
servedthatcallbackcompatibilityissuescommonlyaroseifapps
fail to properly handle inconsistent control flows induced by the
callbackAPIevolutions.Thismotivatesustoproposeagraph-basedmodeltocapturesuchinconsistentappcontrolflowswhenrunning
on different API levels for the analysis of callback compatibility
issues.
Basedontheseobservations,weproposeCider,a CallbackCom-
patibility IssueDetectorbasedonstaticanalysis.Itleveragesour
proposed graph-based model to generate callback control flow
graphs capturing inconsistent control flows of callback APIs in
Androidapps.Toevaluatetheperformanceof Cider,weapplied
it to 20 real-world open-source Android projects collected from
GitHub [15]. Cider successfully detected 13 previously-unknown
callbackcompatibilityissues,achieving92.9%precision.Itsignif-
icantly outperformed Lint [ 4], a widely-used static analyzer for
Androidapps,bydetectingmorecallbackcompatibilityissueswhile
generatingmuchfewerfalsepositives.Wereportedourdetected
issuestotheoriginaldevelopersofthecorrespondingAndroidapps
for their feedback. Among the 13 issues, 12 were confirmed by the
developers and nine of them were fixed shortly afterwards. This
showsthatCidercanpreciselydetectcallbackcompatibilityissues
ofinterest tothe Androidapp developers.Insummary,thispaper
makes the following contributions:
‚Ä¢We conducted an empirical study to understand the callback
APIevolutionsintheAndroidofficialdocumentsandframework
code,andfurthercharacterizedtheirimpactonappcontrolflows.
We also investigated the changes in callback API invocation
protocolsandidentifiedmajorcausesofcallbackcompatibility
issues. Our dataset is available at [10].
‚Ä¢We formulated a graph-based model to capture app control flow
inconsistenciesinducedbycallbackAPIevolutions.Basedonthis
model,weproposedastaticanalysistechniqueCidertodetect
callback compatibility issues in Android apps.

!"


!"
 
!"
 
!"
"
!"



	
	


Figure 1: A CCFG with five callback APIs.
‚Ä¢WeevaluatedCideron20open-sourceAndroidapps.Ciderout-
performedawidely-usedstaticanalyzer,Lint,andsuccessfully
detected13previously-unknowncallbackcompatibilityissues,
12 of which were confirmed or fixed by the app developers.
2 BACKGROUND
CallbackAPIsandcallbackcontrolflowgraph. Androidapps
are event-driven. Callback APIs (see Figure 1for examples) encap-
sulatecodethatshouldbeexecutedtohandlevarioussystemand
user events. Due to the event-driven paradigm, control flows of an
Android app are mainly determined by flow of triggering events.
In other words, an Android app‚Äôs execution is largely driven by
control flows across callback APIs.
Inthispaper,weleveragetheconceptof CallbackControlFlow
Graph(CCFG) tocapturethecontrolflowsbetweencallbackAPIs
in Android apps and discuss the issues induced by the evolution
of the callback APIs. CCFG was introduced by Yang et al. [ 54]
to aid control flow analysis for Android apps. Figure 1shows an
example of a simplified CCFG. A CCFG is a directed graph that
consists of two types of nodes: callback node andhelper node. Call-
back nodes represent the invocations of callback APIs while helper
nodes represent branch and join points of control flows. As shown
inFigure 1,therearefivecallbacknodesintheCCFG,eachofwhich
islabeledwiththenameofthecorrespondingcallbackAPIandthe
concerned library class. Node b1andj1are two helper nodes indi-
cating that the subsequent callback APIs of the branch node b1can
be executed in any order until the join node j1is reached. Edges
between the nodes in a CCFG represent the transfer of control
flows between the nodes (i.e., the order of execution). For example,
theedgebetweenthecallbacknodes onOptionsMenuSelected and
onCreateOptionsMenu indicates that the onCreateOptionsMenu
callback will be invoked after the onOptionsMenuSelected call-
back completes its execution.
AndroidAPIevolutionsandcallbackcompatibilityissues.
TheAndroidframeworkisfastevolving.By2017,therewerealready
27 differentAndroidAPI levels[ 3]. EachAPIlevelintroducesAPI
533
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:09 UTC from IEEE Xplore.  Restrictions apply. Understanding and Detecting Callback Compatibility Issues for Android Applications ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
,0!('"1+'# +*// "&+*/$3/"+*/$3/5
.0,$-+*// "&"+*/$3/
)"/'1'/4 -+2.$-"/'1'/4 "+*/$3/
77777
 // "&"/'1'/4-+2.$-"/'1'/4 "+*/$3/
6
,0!('"1+'# +*// "&"/'1'/ 4 "/'1'/4 5
.0,$-+*// "& "/'1'/4
'%0'(# 	 0'(# 5
 // "&"/'1'/4-+2.$-"/'1'/4  "/'1'/4
6
6
,-'1 /$1+'#  // "&"/'1'/4-+2.$-"/'1'/4 "/'1'/45
)"/'1'/4   "/'1'/4
77777
6,0!('"1+'# +*"/'1'/4-$ /$#0*#($ . 1$#*./ *"$/ /$ 5
)"/'1'/4.$//&'.
77777
6



	
	








 
	





Figure 2: The patch for WordPress issue 6906 [33].
updates for various purposes such as adding new features, bug
fixing, performance optimization and code restructuring. These
updates can induce compatibility issues in Android apps [51].
Whilenon-callbackAPIsareimplementedintheAndroidframe-
workandcanbedirectlyinvokedbyAndroidapps,callbackAPIs
are invoked by the Android system in response to occurred events.
Callback APIs are often overridden and customized by developers
to implement app-specific functionalities. As the Android frame-
work evolves, the callback APIs and their invocation protocols also
evolve.SincetheinvocationprotocolsofcallbackAPIsaffectapp
control flows, the evolutions of callback APIs and changes in their
invocation protocols can have significant influence on Android
apps‚Äô runtime behavior. Various compatibility issues would arise if
such changes, which might be subtle, are not timely identified and
properlyhandled.Thisisparticularlythecaseifanappcontainscer-
taincodethathascontrol/datadependenciesonmultiplecallback
APIs.ThismotivatesustostudyAndroidcallback APIevolutions
and their induced compatibility issues, which are referred to as
callback compatibility issues hereafter.
3 MOTIVATING EXAMPLE
This section presents an example to illustrate how callback API
evolutionscaninducecallbackcompatibilityissuesanddiscusses
the challenges of the issue detection. The example is extracted
from issue 6906 in WordPress [ 33], a popular website and blog
builderwithmorethan5milliondownloads.Accordingtotheissue
report, WordPress would crash due to a NullPointerException
(NPEforshort)causedbytheevolutionofalifecyclecallbackAPIin
aFragment ,whichisanAndroiduser-interfacecomponentwithits
ownlifecycle[ 14].InAndroidapps,a Fragment ‚Äôslifecyclecallback
APIs need to be carefully implemented to respond to the events
that would cause the Fragment to change its lifecycle stage. The
crashwasinducedbyanewlifecyclecallback onAttach(Context)
ofFragment ,whichwasintroducedatAndroidAPIlevel23.The
callbackcanbeimplementedtohandletheusereventsthatcausea	
 
	 "
 
	!
	(a)
(b)
	


		 
 	
 
	
 
		 
 	
 
	
 
Figure 3: The CCFG for the code snippet in Figure 2.
Fragment tobeattachedtoaparentcomponent.Weexplainhow
WordPressissue6906aroseduetothecallbackAPIevolutionbelow.
Figure2gives the relevant code snippet of the crashing issue
and the patch written by the developers. In line 3, the variable
mActivity isinitializedinthecallback onAttach(Context) .The
variableislaterusedinanothercallback onActivityCreated (line
18). Figure 3shows the CCFG for the code snippet in Figure 2.
The edges in Figure 3(a) indicate the control flows between the
concerned Fragment callback APIs at API level 23 or higher. Ac-
cording to the CCFG, the following three callback APIs will be
invoked sequentially: onAttach(Context) ,onAttach(Activity)
andonActivityCreated . However, the callback API invocation
sequence differswhen theAPI levelis lower than23, where onAt-
tach(Context) will be skipped and only onAttach(Activity)
andonActivityCreated willbeinvokedasshowninFigure 3(b).
This is because the callback API onAttach(Context) was first in-
troducedatAPIlevel23andthusunavailableatAPIlevelslower
than23.WhenWordPressrunsonadevicewithanAPIlevellower
than 23, onAttach(Context) will not be invoked and the variable
mActivity (its default value is null) will not be initialized. As a
result,theinvocationof onActivityCreated willleadtoanNPE.
Tofixthisissue,WordPressdevelopersrevisedthecodeof onAt-
tach(Activity) to properly initialize mActivity if the runtime
API level is lower than 23 (lines 9‚Äì11).
The above issue arose due to a CCFG inconsistency induced
by the evolution of the callback API onAttach(Context) at API
level 23. The inconsistency affects the def-use chain of the variable
mActivity .Sinceinter-callbackdataflowsarecommoninAndroid
apps [38], such callback API evolutions can easily induce compati-
bilityissues.Todetectsuchissues,wenotonlyneedtohaveadeep
understanding of CCFG inconsistencies caused by callback API
evolutions but also need to analyze the dependencies between app
callbackAPIs.Tothebestofourknowledge,noneoftheexisting
studies on Android compatibility issues investigated the impact
of callback API evolutions on app control/data flows and inter-
callbackdependencies[ 41,48,51].Tobridgethegap,weconducted
an empirical study to understand the callback compatibility issues
inducedbycallbackAPIevolutionsinAndroid.Thestudyresults
further guided us to design a technique to automatically detect the
issues.
4 EMPIRICAL STUDY METHODOLOGY
4.1 Study Setup for Answering RQ1
ToanswerRQ1,weconductanempiricalstudytounderstandthe
evolutions of Android callback APIs and the changes in callback
API invocation protocols. The empirical data come from the API
534
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:09 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Huaxun Huang, Lili Wei, Yepang Liu, and Shing-Chi Cheung
Table 1: Keywords used in RQ2.
compatibility compatible compat deprecated
deprecation honeycomb kitkat jellybean
icecreamsandwich lollipop marshmallow nougat
gingerbread oreo api Build.VERSION
Reference in Android Developers [ 6], Android API Differences
Reports[ 2],andtheAndroidOpenSourceProject[ 5].Inorderto
haveacomprehensiveunderstandingofthecallbackAPIevolutions,
wechosetoanalyzetheAndroidframeworkfromAPIlevel1.We
describe the process in the following.
WefirstneedtolocatealistofcallbackAPIsfromtheAPIRefer-
encesinceitdoesnotprovidealistofcallbackAPIs.Toachievethis,
we study the specifications of well-known callback APIs triggered
bythelifecycleeventsof Activity ,Fragment andService,which
arethekeycomponentsofAndroidapps.Weidentifiedthecommon
characteristicsoftheseAPIspecificationsandformulatedoursearchcriteriatolocatecallbackAPIs.Specifically,wecollectedthreekinds
of APIs: (1) the APIs whose name starts with ‚Äúon‚Äù, (2) the APIs
whose description includes keywords ‚Äúcallback‚Äù or ‚Äúlistener‚Äù, (3)
theAPIswhosedescriptioncontainsentenceswithatleastoneword
from each of the following two sets of keywords (case insensitive):
{‚Äúcalled‚Äù,‚Äúinvoked‚Äù,‚Äúnotified‚Äù},and{‚Äúwhen‚Äù,‚Äúbefore‚Äù,‚Äúafter‚Äù}.W e
treatedtheseAPIsascallbackAPIcandidatesandextractedtheir
information from API Reference. As a result, we identified 5,589callback API candidates out of 42,591 Android framework APIs.
Then, two of the authors cross-examined these 5,589 API candi-
datestofurtherfilteroutnoisesinthesetofcandidatesandkept
onlycallbackAPIsfortheempiricalstudy.Eventually,wecollected2,589callbackAPIstoformourcallbackAPIlist(denotedas
LAPI).
We further identify the evolutions of the callback APIs in LAPI.
However,simplyanalyzingtheAPIReferenceisinadequatebecause
such a constantly-evolving document can be incomplete (e.g., they
do not provide information for certain removed APIs). To obtain
morecompleteinformationofAndroidcallbackAPIs,wefurther
analyzed Android API Differences Reports, which provide the full
history of Android framework API updates. For each callback API
update,wethenstudieditsassociatedcodecommitsintheAndroid
Open Source Project (AOSP for short) [ 5]. Specifically, we studied
thecodechanges,relatedcommentsandcommitlogstounderstand
how each update affects the callback API invocation protocol.
4.2 Study Setup for Answering RQ2
In RQ2, we aim to understand how callback API evolutions canaffect the software quality of Android apps and characterize the
inducedcallbackcompatibilityissues.Toachievethis,weneedto
constructa datasetofcallback compatibilityissuesfromreal-world
Android apps.For data collection,we searchedtwo popular open-
source app hosting platforms: F-Droid [ 12] and GitHub [ 15]. We
collectedtheAndroidappsthat(1)haveatleastonecommitafter
October 2017 (actively-maintained), (2) have received at least 50
stars(popular),and(3)haveapublicissuetrackingsystem(trace-
able).Thisresultedinasetof275apps.Forthese275candidateapps,
we further searched for patched callback compatibility issues by
mining their code repository. Specifically, we searched for commitlogs, issue reports, and code diffs that contain the keywords listed
in Table1. These keywords include the names of major API levels,
the name of the commonly-used class to check the runtime API
level( Build.VERSION )andseveralgeneraltermsrelatedtocompat-
ibility(e.g.,weobservedthatdevelopersoftenuse‚Äúapi‚Äùtorepresent
‚ÄúAPIlevel‚Äùwhendiscussingissues).Toensuretheusefulnessofthe
dataset, we only collected callback compatibility issues that can
occur on devices with an API level 10 or above (older API versions
havenomarketshare[ 3]).Asaresult,weobtained100realcallback
compatibilityissuesfrom50outofthe275appsasourempirical
studydataset.Foreachcollectedissue,wecarefullyidentifiedthe
evolved callback APIs and studied how the callback API evolutions
affected the concerned app‚Äôs CCFG and induced callback compati-
bility issues. We also analyzed the corresponding issue reports and
issue-fixingcodecommits,whichcontainpatches,tounderstand
the practices of Android developers to fix callback compatibility
issues.
5 EMPIRICAL STUDY RESULTS
5.1 RQ1: Callback API Evolutions and
Invocation Protocols
Asdiscussedearlier,toanswerRQ1,weidentifiedtheupdatesfor
each callback API in LAPI. In the resulting dataset, we observed
four ways of callback API evolutions: API introduction, API dep-
recation,APIbehavioralmodification andAPIremoval.Wefurther
examinedthecodecommitsinAOSPthatintroducedtheupdatesof
callbackAPIstostudythecommonchangesintheAPIs‚Äôinvocation
protocols. We present our findings in this section.
5.1.1 Callback API Invocation Protocol Change. There are two ma-
jorcategoriesofchangestothecallbackAPIs‚Äôinvocationprotocols
due to callback API evolutions.
Reachability change. In most cases, a callback API‚Äôs reach-
ability is changed when it evolves, making it accessible only at
specific Android API levels. For example, the onAttach(Context)
callbackAPIdefinedinthe Fragment classwasintroducedatAPI
level23.Therefore,thecallbacksthatoverrideitcannotbeinvoked
at runtime when the API level is below 23. There are 1,762 suchevolvedcallbackAPIs.Theevolutionsaltertheinvocationproto-cols of the concerned callback APIs by enabling or disabling the
APIs‚ÄôinvocationsdependingontheruntimeAPIlevels.Thiscan
significantly affect the control flow of Android apps. In Section 5.2,
we will show that the reachability changes of callback APIs can
commonly induce callback compatibility issues in Android apps.
APIbehavioralmodification. Thereare37callbackAPIswhose
behaviorswereupdated.Theupdatesdidnotadd,removeorchange
thereachabilityofcallbackAPIs,butledtoAPIbehavioralmodi-
fication.Inourdataset,weobservedthreecommontypesofsuch
evolutions:(1)APIdeclarationchanges(e.g.,thecallbackAPI onNo-
tificationPosted ‚Äôsmodifier abstract wasremovedinAPIlevel
21),(2)callingconditionororderchanges(e.g.,sinceAPIlevel11,ifthe API
invalidateOptionsMenu , which declares that the options
menu has changed, is called, the callback API onCreateOption-
sMenuwill also be called by the system when the options menu
needs to be displayed), and (3) the values passed to method pa-rameters change (e.g., the second parameter of the callback API
535
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:09 UTC from IEEE Xplore.  Restrictions apply. Understanding and Detecting Callback Compatibility Issues for Android Applications ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
	
 
! 
 (a)
(b)

	
 

 
Figure 4: CCFG node inconsistency example.
onNewPicture(WebView, Picture) will always receive a null
reference since API level 18). Such behavioral modifications will
causespecificchangestotheAPIs‚Äôinvocationprotocolssincethe
concerned API may undergo different behavioral changes. As a re-
sult,thecallbackcompatibilityissuesinducedbysuchcallbackAPI
evolutionsare also specific to theconcernedcallback APIs. We will
further discuss these callback compatibility issues in Section 5.2.
5.1.2 Commonly-Evolved Callback APIs. We analyzed the callback
APIsthathavebeenupdatedsincetheirfirstintroductionandob-
served that most of them are defined in four classes: Activity ,
Fragment ,Service and WebView. These classes are commonly-
used by Android apps for UI displays ( Activity andFragment ),
backgroundtasks( Service),andwebbrowsing( WebView).Their
callbackAPIsaccountfor25%ofthecallbackAPIsin LAPI.Around
55%ofallAPIupdatesinourdatasetarerelatedtothecallbackAPIsinthesefourclasses.Frequentupdatesofsuchcommonly-usedcall-backAPIscaneasilycausecallbackcompatibilityissuesthatwould
affect a large number of Android apps. This motivates the need of
automatedtoolstosupportcallbackcompatibilityissuedetection.
Inthenextsection,wewilldiscusshowcallbackAPIevolutionscaninduce callback compatibility issues by changing app control flows.
With this knowledge, we then propose a technique for callback
compatibility issue detection.
AnswertoRQ1: CallbackAPIevolutionscanmodifyAPIinvo-
cationprotocols,changingthereachabilityorfunctionalityof
theevolvedAPIs.Suchmodificationsaffectappcontrolflows.
Frequent updates of callback APIs in a few widely-used classes
commonly induce callback compatibility issues.
5.2 RQ2: Causes of Callback Compatibility
Issues
InRQ2,westudyhowthecallbackAPIevolutionsobservedinRQ1
can change app CCFGs and induce callback compatibility issues.
Weinvestigatedthe100callbackcompatibilityissuescollectedfrom
open-source projects on GitHub (Section 4.2). We found that all
these 100 issues arose from two types of CCFG inconsistencies
induced by callback API evolutions.
5.2.1 CCFG structural inconsistency. A vast majority of the issues
(89 out of 100) arose from the CCFG structural inconsistencies
across API levels. CCFG structural inconsistencies occur when the
setofnodesoredgesofanapp‚ÄôsCCFGchangesacrossdifferentAPI(a)
(b)
 
	 

  !
 	 


 
	 


 	 

  !
 
Figure 5: CCFG edge inconsistency example.
levels. From the 89 issues, we found that the callback compatibility
issues arising from node inconsistencies and those arising from
edge inconsistencies differ in nature. In addition, the issues arising
from node inconsistencies are most common.
CCFG node inconsistency. There are 82 issues induced by
CCFG nodes that exist in some API levels but disappear in other
APIlevels.ThisiscommonlycausedbyAPIreachabilitychanges
(Section5.1.1).TheintroductionofacallbackAPIatanAPIlevel
adds a new node to concerned CCFGs, while the removal of an
API deletes a node from the CCFGs. In both cases, the node can
only be found in the CCFGs for certain API levels. This would lead
toinconsistentappbehaviorsacrossdifferentAPIlevels,causing
callback compatibility issues.
With further examination, we found that the absence of a CCFG
node can (1) destruct variable def-use chains or (2) eliminate the
invocations of key APIs that can cause user-perceivable app be-
haviors. Our motivating example in Section 3gives an instance
of such inconsistencies. In the example, the onAttach(Context)
nodeisabsentfromtheapp‚ÄôsCCFGforAPIlevelslowerthan23.
The absence of the node destructs the def-use chain of the vari-
able mActivity , causing the app to crash. The commit 2681e87
inBitmask[ 7]filedanotherissueinducedbyinvokingakeyAPI
inacallbacknodethatisabsentinCCFGsforspecificAPIlevels.
Figure4showstheinconsistentCCFGs.Asthefigureshows,the
APIdisplayisinvokedinthecallbackAPI onViewStateRestored
to display information on the screen. Since this callback API is not
availableuntilAPIlevel17,theAPI displaywillnotbecalledwhen
BitmaskrunsondeviceswithanAPIlevellowerthan17.Asaresult,
the information cannot be properly displayed. The root cause ofthis issue is that some APIs that can cause perceivable changes
atruntime(e.g., display)arenotinvokedbecauseofCCFGnode
absence.ThismotivatesustomaintainalistofsuchAPIstosupport
the automateddetection of callbackcompatibility issues viastatic
analysis (Section 6.2).
CCFG edge inconsistency. The remaining 7 of the 89 issues
were induced by CCFG structural inconsistencies that occurred
whenthesetofCCFGedgesvariedacrossdifferentAPIlevelswhile
thesetofCCFGnodesremainedthesame.Suchedgeinconsisten-
cies can also destruct variable def-use chains and cause callback
compatibility issues by scrambling the execution order of callback
APIs. For example, the commit 467d6e8 of KeePassDroid [ 16]d oc -
umented an issue caused by CCFG edge inconsistency. Figure 5
shows the concerned CCFGs. Before API level 11, the Android sys-
temwillonlytriggerthecallbackAPI onCreateOptionsMenu each
536
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:09 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Huaxun Huang, Lili Wei, Yepang Liu, and Shing-Chi Cheung
timewhentheusersopentheoptionsmenuandbeforethatthe on-
Createcallback of the menu‚Äôs enclosing UI component must have
been invoked. However, at API level 11, a new API invalidateOp-
tionsMenu wasintroducedfordeveloperstoforcetheinvocation
ofonCreateOptionsMenu .Thismakesitpossibletoinvoke onCre-
ateOptionsMenu before onCreate .Inthiscase,theusestatement
ofmEntryinonCreateOptionsMenu can be executed before the
def statement of mEntryinonCreate, causing the app to crash.
5.2.2 CCFG non-structural inconsistency. The remaining 11 of the
100issueswerecausedbyCCFGnon-structuralinconsistency.In
these cases, the sets of nodes and edges in CCFGs stayed the same
but the behaviors of the callback APIs were inconsistent across
different API levels. The non-structural inconsistencies were in-
ducedbythebehavioralmodificationsofcallbackAPIssuchasAPI
modifier changes (from abstract to non-abstract), API triggeringcondition changes and so on. For instance, developers of Omni-
Notes encountered an issue of this type (issue 248 [ 21]). The issue
was induced by a change in the modifier of the callback API on-
NotificationPosted . At API level 21, the API is changed from
abstract to non-abstract. When the API is overridden, the subclass
version invokes the superclass version. This works well on devices
withanAPIlevel21orabove(becausethesuperclassversionofthe
API is a concrete method). However, when the app runs on devices
withanAPIlevellowerthan21,itwouldcrashsincethesuperclass
version of the API is an abstract method that cannot be invoked.
Tosummarize,callbackAPIevolutionscaninducevariousCCFG
inconsistencies.Such inconsistenciescanaffect appruntimebehav-
iors and cause callback compatibility issues. Among our studied
issues,amajorityofthemwerecausedbystructuralinconsistencies
of CCFGs. As discussed in Section 5.2.1, CCFG structural incon-
sistencies often destruct variable def-use chains or eliminate theinvocations of key APIs that can cause user-perceivable app be-haviors. It should be noted that the occurrence of these callback
compatibilityissuesheavilydependsonhowdevelopersoverride
and implement the callback APIs (we observed that definitions and
usages of variables and API invocations commonly occur in the
methodbodyoftheoverriddencallbackAPIsinAndroidprograms).
ThismotivatesustocombineCCFGinconsistenciesandtheanalysis
of the callback code to automatically detect callback compatibility
issues for Android apps (Section 6).
Answer to RQ2: Callbackcompatibilityissuesarecommonly
inducedbytwotypesofappCCFGinconsistenciesarisingfrom
callbackAPIevolutions.Amongthem,CCFGstructuralincon-
sistencies, which could affect app control flows, caused the
majority of our studied issues.
6 AUTOMATED DETECTION OF CALLBACK
COMPATIBILITY ISSUES
In Section 5.2, we made a key observation that callback compatibil-
ityissuesarecommonlyinducedbyCCFGstructuralinconsistencies
atdifferentAPIlevels.Thestructuralinconsistenciescandestruct
variable def-use chains or eliminate the invocations of key APIs
thatcancauseuser-perceivablechanges(e.g.,UIdisplayAPIs).Thismotivates us to construct an app‚Äôs CCFG at each API level to de-
tectpotentialcallbackcompatibilityissues.However,analyzingthe
controlflow inconsistenciesinduced bycallback APIevolutions is
challengingbecausepreciselyconstructinganapp‚ÄôsCCFGatanAPI
level is non-trivial as an app component can implement many call-
backs and the timing of their invocations can be non-deterministic.
To address this challenge, we first propose a graph-based model,
Callback Invocation ProtocolInconsistency Graph(PI-Graph), to
capture the structural invocation protocol inconsistencies occur-ringinanappacrossAPIlevels(Section 6.1).Thenweproposea
techniqueCider,whichleveragesthePI-Graphmodel,todetect
callback compatibility issues caused by CCFG structural inconsis-
tencies (Section 6.2). For issues induced by CCFG non-structural
inconsistencies, which are much less common, we leave them to
our future work.
6.1 The PI-Graph Model
A PI-Graph is a directed graph that models the inconsistencies in
the callback API invocation protocols across multiple API levels.
API-GraphiscreatedbasedondifferentversionsoftheAndroid
softwareplatform.TherearetwocategoriesofnodesinaPI-Graph:
(1) callback node Ncdenoting a callback API, and (2) two types of
helpernodes NpreandNsucdenotingtheprecedingandsucceeding
point of PI-Graph, respectively. An edge E=/angbracketleftns,ne,APILevel /angbracketright
indicatestheexecutionorderoftwocallbacknodes neandns:ne
will be executed after nsif the runtime API level is within the
intervalAPILevel ,whereAPILevel isintheform [a,b],inwhich a
andbspecifythelowestandhighestAPIlevel,respectively.API-
Graph only contains the nodes for those callback APIs that reside
in the same class as the evolved callback API.
Figure6(a) shows an PI-Graph example. In this example, the
PI-Graph captures the CCFG structural inconsistencies induced by
the evolution of the callback API onAttach invoked by WordPress
across multiple API levels as discussed earlier in Section 3. Besides
the preceding node Npreand the succeeding node Nsuc, there are
two callback nodesrepresenting two corresponding callbackAPIs.
Fouredgesinthegraphindicatethedifferentexecutionordersof
thecallbackAPIsfordifferentAPIlevelintervals.Forexample,Edge
2/circlecopyrtin the figure indicates that onAttach(Activity) can be exe-
cutedaftertheexecutionof onAttach(Context) whenAPIlevelis
within[23,27].BasedonthePI-Graphmodel,wecangeneratesim-
plified CCFGs for Android apps by traversing the PI-Graph along
edgesthat arelabelled withdifferentAPI levelintervals. Thegen-
erated CCFGs can then facilitate control flow analysis for Android
apps with regard to different API levels. In the next section, we
willdiscusshowPI-GraphcanbeusedtogenerateappCCFGsand
detect callback compatibility issues.
To demonstrate the usefulness of the PI-Graph model, we man-
uallyderivedsevenPI-GraphsbyanalyzingAPIReferenceandthe
framework source code. These seven PI-Graphs concern different
callback APIs in the classes Activity ,Fragment , and WebView-
Client.Accordingtoourempiricalstudy,theevolutionsofthese
callback APIs commonly caused callback compatibility issues on
recent Android versions.
537
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:09 UTC from IEEE Xplore.  Restrictions apply. Understanding and Detecting Callback Compatibility Issues for Android Applications ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
Algorithm 1: Callback Compatibility Issue Detection.
Input :An Android apkfileapk;
a list of PI-Graphs Œ†;
a list of key APIs Œõ.
Output:Detected compatibility issues
1apk.apiLevels ‚ÜêGetAPILevels( apk.confi–¥)
2foreachœÄinŒ†do
3apk.classList ‚ÜêGetClassesFromPIGraph( œÄ.apiList)
4foreachcinapk.classList do
5 Œì‚ÜêGenCCFGFromPIGraph( œÄ,c,apk.apiLevels )
6 foreachccfg in Œìdo
7 ifCheckUseWithoutDef(ccfg) then
8 report a callback compatibility issue.
9 ifCheckMissingKeyAPIs( Œì,Œõ)then
10 report a callback compatibility issue.
6.2 The Cider Approach
CiderleveragesPI-Graphsto detectcallbackcompatibilityissues
in Android apps by constructing simplified app CCFGs for dif-
ferent API levels. The CCFGs integrate app code into predefined
PI-Graphs.CiderthenperformsstaticanalysisontheCCFGsto
detect callback compatibility issues.
Algorithm 1 describes the running process of Cider. It takes an
Android app (in apkformat), a list of predefined PI-Graphs (de-
notedas Œ†),andalistofkeyAPIs(denotedas Œõ)asinput.Ciderfirst
checks the configuration file of the app under analysis to obtain itssupportedAPIlevels(GetAPILevelsinline1).ForeachPI-Graph
œÄ
inŒ†, Cider first identifies all app classes that extend the class that
defines the callback APIs in œÄby invoking GetClassesFromPI-
Graph (line 3). For each class cgoing to be checked, Cider gen-
erates a set of simplified app CCFGs (denoted as Œì) for different
APIlevelintervalsbasedon œÄ(GenCCFGFromPIGraphinline5)
and performs static analysis to detect use-without-def (line 7) and
missing-key-APIs (line9)issuesasdiscussedearlier(Section 5.2.1).
If any callback compatibility issue is detected, Cider reports its
issue location and issue type (lines 8 and 10).
GeneratingCCFGsfromPI-Graph. Toapproximatetheapp
controlflowsindifferentAPIlevelsandsupportcallbackcompat-
ibility issue detection, Cider generates app CCFGs based on PI-
Graphs. Figure 6(a) shows the PI-Graph capturing the evolutions
ofthecallbackAPIsthatinducedtheWordPressissueinFigure 2.
Given an app and a PI-Graph, Cider identifies all different APIlevel intervals associated with the edges (e.g.,
[1,22]and[23,27]
in Figure 6(a)). It also identifies the supported API levels of the
givenappbycheckingtheattributes android:minSdkVersion and
android:maxSdkVersion in the app‚Äôs configuration file (i.e., An-
droidManifest.xml ). Cider then generates a CCFG for each sup-
portedAPIlevelinterval ran–¥ebytraversingthePI-Graphalong
alledgeswhoseassociatedAPIlevelintervaliswithin ran–¥eand
addingthecallbacknodesassociatedwiththeedges.Ifacallback
API is implemented in the app under analysis, the code in the
methodbodywillbeaddedtothecallbackAPI‚ÄôsCCFGnode.Fig-
ure6(b) shows the CCFG for API level interval [23,27], which is(b)
(c)‚Ä¶    
	
  !
"
(a)
‚Ä¶
‚Ä¶ 

 !
 
#
"
 !
 
#
"  !
 
"  !"	 	

Figure6:ThestepsofgeneratingappCCFGsfromPI-Graph.
(a) is an example of PI-Graph related to the WordPress
issue (Section 3). (b) is a simplified CCFG generated by
CiderforWordPress.TheCCFGdescribestheapp‚Äôscontrol
flowsamongthecallbackAPIsmodeledbythePI-Graphin
(a) at an API level in [23,27]. (c) is an CCFG of the app af-
ter inserting the node of a callback API that is not in the
PI-Graphin(a).Theplaceofinsertionisdeterminedbytheinvocation order of the callback APIs specified in the APIReference.
generatedwiththePI-GraphinFigure 6(a)andthecodesnippet
inFigure 2.TwocallbackAPInodesareincludedintheCCFGas
they can be reached along the edges whose associated API level is
within[23,27].SincetheAPI onAttach(Context) isimplemented,
itscorrespondingCCFGnodecontainsthecodeinthemethodbody.
So far, the generated CCFG only includes the callback APIs that
are in PI-Graph models. Note that the control flow inconsistencies
caused by callback API evolutions may propagate to other callback
APIs that are not modeled by PI-Graphs. To analyze the depen-
denciesbetween thecallbackAPIs inPI-Graphmodelsand other
implementedcallbackAPIsinanapp,Ciderfurtherrecoversthe
executionordersbetweenthecallbackAPIsinthegeneratedCCFGs
and other callback APIs. Specifically, we maintain a set of callback
nodesforeachedgeintheCCFG.Anodewillbeaddedtothissetif
its represented callback API can be executed between the callback
APIs represented by the start and end nodes of the CCFG edge. For
simplicity,weassumethatthestartandendnodesarebothcallbacknodes.Thecaseswherethestartorendnodeisahelpernodecanbe
handledin asimilar way. Forthepurpose ofadding suchcallback
nodes, we studied the specifications of all callback APIs defined
in the classes that we extracted PI-Graphs from. For example, we
extracted arule fromthe APIReference that onActivityCreated
should be executed after onAttach(Activity) . Cider will then
create a callback node for onActivityCreated and add it into the
callbacknodesetoftheedgeconnecting onAttach(Activity) and
NsucasshowninFigure 6(c).Oneshouldnotethatthecontrolflows
between the callback APIs that are not in the PI-Graph models
would stay unchanged at different API levels and thus may not
induce callback compatibility issues. For this reason, we do not
maintain orders between the set of callback nodes associated with
CCFG edges. For those callback APIs of which the execution order
cannot be inferred from the API specifications, Cider inserts them
into all possible callback node sets in CCFGs.
538
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:09 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Huaxun Huang, Lili Wei, Yepang Liu, and Shing-Chi Cheung
Identifying callback compatibility issues. After generating
CCFGs for different API level intervals, Cider conducts control
flow analysis to detect callback compatibility issues. It detects two
common types of issues by analyzing each generated CCFG:
(1)Use-without-def. Cider checks each CCFG and detects any
variablesthatareusedbeforebeingdefined.Specifically,Cideriden-
tifiesthesetofdefandusestatementsforallcallbacknodesineach
CCFG including those nodes in the callback node set of each edge.
For each statement that uses a variable, Cider checks whether the
variablehasbeendefinedinanycallbacknodesthatare(1)inthe
corresponding PI-Graph model and (2) executed before the use
statement.Ifavariableisusedwithoutbeingdefined,Ciderreports
a warning of use-without-def.
(2)Missing-key-APIs. CidercomparestheinvocationsofkeyAPIs
inthelistofCCFGsgeneratedfordifferentAPIlevels.Asdiscussed
in Section 5.2(the Bitmask issue), invoking such APIs will cause
perceivableappbehaviorssuchaspoppingupanotification.Asa
result,missinginvocationsofsuchAPIsincertainAPIlevelscan
induceinconsistentappbehaviorsthatcanbeobservedbyusers.
Cider will report a warning of missing-key-APIs if the invocations
ofkeyAPIs,whicharemanuallyidentifiedfromourempiricalstudy
dataset, are inconsistent among CCFGs for different API levels.
Accordingtoourempiricalstudy,theabovetwotypesofcallback
compatibilityissuescommonlyoccurinreal-worldAndroidapps.
Therefore,weimplementedtwocheckersfordetectingtheseissues
inthecurrentversionof Cider.Ourevaluationresultsshowthatthe
twocheckerscanalreadyhelpdetectalargenumberofrealcallback
compatibility issues. In future, Cider can be further extended with
othercheckerstodetectmoretypesofcallbackcompatibilityissues.
7 EVALUATION
We implemented Cider on top of Soot [ 44], a static analysis frame-
work for Android apps and Java programs. Our current implemen-
tation of Cider encodes seven differentPI-Graphs concerning 24
keyAPIs[ 10],whichareextractedfromourempiricalstudydataset.
In this section, we evaluate Cider with open-source Android apps.
We aim to answer the following two research questions:
‚Ä¢RQ3 (Effectiveness): CanCidereffectivelyandpreciselydetect
callback compatibility issues in real-world Android apps?
‚Ä¢RQ4(Usefulness): CanCiderprovideusefulinformationforAn-
droid app developers to facilitate the diagnosis and fixing callback
compatibility issues?
7.1 Experimental Setup
To answer the above research questions, we collected 20 open-
sourceAndroidappsfromGitHubthatsatisfythefollowingthree
constraints: (1) contain at least one commit after October 2017 (i.e.,
actively-maintained), (2) do not overlap with any projects selected
forourempiricalstudy,and(3)useatleastoneofthecallbackAPIsinthesevenPI-GraphsencodedinCider.Weusedthelatestversion
ofthese20Androidappsasourevaluationsubjectstoexamineif
Cidercandetectnewcallbackcompatibilityissuesinthem.Table 2
gives the basic information of the 20 subjects, including: (1) the
projectname,(2)theapp‚ÄôscategoryinformationprovidedbyGoogle
Playstore(ifapplicable),(3)therevisionusedinourexperiment,
(4) the number of stars on GitHub, (5) the number of downloadson Google Playstore (if applicable), and (6)the number of lines of
code.Asshowninthetable,thesubjectsarediversified,covering
10 different app categories. They are also non-trivial, containing
thousands to hundreds of thousands of lines of code.
Intheexperiments,weconfiguredCidertoreportthelocation
and type (use-without-def ormissing-key-APIs ) of each detected
issue.Toevaluatetheeffectivenessof Cider,wecompareditwitha
baseline tool, Lint[ 4]. Lint is a static analyzer that scans the source
files of Android apps to find common bugs, including callbackcompatibility issues. Since Lint is integrated in Android Studio,it has been widely-used by Android app developers to improvethe software quality of their products. For comparison, we ran
Lint on the same experimental subjects to detect potential callback
compatibilityissues.Wemanuallycheckedtheissuesreportedby
Cider and Lint to categorize them into true positives (TP) and
false positives (FP). For fairness, we excluded those issues that are
reported by Lint but are not related to any callback APIs in our
extractedPI-Graphs.Whencategorizingeachissue,wecarefully
examinedtherelevantsourcecode.Wewouldonlycategorizean
issue as a true positive if it can cause the corresponding app tobehave inconsistently at different API levels. To further evaluatethe usefulness of Cider, we reported the true issues detected by
Cidertotheoriginalappdevelopersforconfirmationandfeedback.
AllexperimentswereconductedonaniMacwithanIntelCorei5
CPU @3.4GHz and 16GB RAM.
7.2 Results of RQ3: Effectiveness of Cider
As shown in Table 2, Cider detected 14 issues in nine subjects,
amongwhich13aretruepositives(i.e.,theprecisionis92.9%).ThisshowsthatCidercanpreciselydetectcallbackcompatibilityissues
in Android apps. Cider reported one false positive in Kolab Notes.
Weinvestigatedthisfalsepositivetounderstandthelimitationof
Cider.AsdiscussedinSection 6,theCCFGsgeneratedbyCiderdo
not capture the execution orders between callback APIs that are
notinPI-Graphs(suchorderswouldstayunchangedatdifferent
API levels). This can cause imprecision in control flow analysis.
For instance, when analyzing Kolab Notes [ 17], Cider reported
a use-without-def issue because a variable defined in an evolved
callback API was later used in a callback that handles a click event.
TheevolvedAPIcannotbeexecutedatsomeAPIlevelsandthus
Ciderdeterminesthatthevariablecanbeusedwithoutadefinition
and reported the issue. However, after manually reviewing thisissue, we found that the app developers have already fixed this
problembyincludingadefinitionofthevariableinanothercallback
API(notinthePI-Graphs),whichcanbecalledaftertheexecution
of the evolved API and before the execution of the click eventhandling callback. In our 20 evaluation subjects, Cider reported
only this false positive, suggesting that such imprecision in control
flow analysis may not affect Cider‚Äôs effectiveness in practice.
Table2alsopresentstheresultsofLint.Lintdetectedtworeal
callback compatibility issues but reported 19 false positives. The
twotrueissuesreportedbyLintwerealsoreportedbyCider.Wein-
vestigated the 19 false positives and found that Lint simply reports
theusageofdeprecatedcallbackAPIswithoutanalyzingwhether
suchusagewouldreallyaffectanapp‚Äôsruntimebehavior.Forexam-
ple, in the app Calendula [ 8], Lint generated a warning suggesting
539
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:09 UTC from IEEE Xplore.  Restrictions apply. Understanding and Detecting Callback Compatibility Issues for Android Applications ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
Table 2: Evaluation subjects and results.
No. Project Name Category Last Commit StarsDownloads KLOCCider LintIssue StatusTPFPTPFP
1 AFWall+ [1] Tools 71e6c66 1,100 500K+ 21.81000786 fixed
2 Calendula [8] Health c476575 76 1K+ 26.30002- -
3 cccTV [9] Education 667a83c 20 100+ 7.820208confirmed
4DuckDuckGo-Kotlin [11] Tools 2d7d379 425 1M+ 10.4100079 fixed
5FOSS Browser [13] - e08f5b6 101 - 18.00003- -
6 Kolab Notes [17] Productivity 14ba3c3 42 1K+ 73.40100- -
7MaterialFBook [18] - 2cb3c61 90 - 68.00000- -
8Network-monitor [19] Tools 0e17b95 54 50K+ 20.80000- -
9 NyaaPantsu [20] - 53ad9a8 22 - 14.10000- -
10 OONI Probe [22] Tools 60cbd70 41 100K+ 4.91002146confirmed
11OpenKeyChain [23] Communication 7135525 1,001 100K+ 848.5 0001- -
12 OsmAnd [24] Maps b7a539f 1,410 5M+ 662.5 10054868 fixed
13 Padland [25] Productivity 38f7e66 22 100+ 58.9100247 fixed
14 PassAndroid [26] Travel 2d50ff4 362 1M+ 85.00000- -
15 Ring [27] Communication 20d4221 82 1M+ 243.5 10011831not fixed
16sg for SteamGifts [28] Entertainment 59fe959 40 1K+ 21.50000- -
17Simple-Solitaire [29] Card 1483ee1 49 10K+ 294.4 1000108 fixed
18SuntimesWidget [30] - c9a3c00 24 - 63.10002- -
19SurvivalManual [31] Books 13b1f43 326 1M+ 49.40000- -
20 Uber-ride [32] - 4d77c38 209 - 12.74001105 fixed
Total - - - - -131219- -
thattheuseofcallbackAPI onReceivedError isnotrecommended
astheAPIhasbeendeprecatedsinceAPIlevel23.However,theuse
ofthisAPIdoesnotaffecttheapp‚ÄôscontrolflowatAPIlevelshigherthan 23, while it is still necessary to use the API to support the app
to run on lower API levels. In contrast, Cider analyzes the control
flowinconsistenciesinducedbythecallbackAPIevolutions.Itis
capable of precisely identifying the impact of an evolve callback
API on an app‚Äôs control flow.
Answer toRQ3: Cidercanpreciselydetect callbackcompati-
bility issues in Android apps. With control flow analysis based
onPI-Graph,CidercanoutperformLintandeffectivelyreduce
the number of false positives.
7.3 Results of RQ4: Usefulness of Cider
To evaluate the usefulness of Cider, we reported the 13 true issues
it detected to the app developers for their feedback. For each issue,
we reported: (1) the issue location, (2) the root cause, and (3) po-
tential patches for fixing the issue. To avoid overwhelming the app
developers, for each concerned Android app, we submitted only
one bug report including all true issues Cider detected in theapp.
So far, we have received developers‚Äô replies for nine bug reports.
Eight of the nine (88.9%) bug reports (concerning 12 detected
issues)havebeenconfirmedbytheappdevelopers,amongwhich
nineissuesmentionedinsixbugreportshavealreadybeenfixed.Forexample,fortheappOsmAnd[
24],wereportedanissue(#4868)that
atoastnotificationfordisplayingnetworkerrorswillnotbeshownondeviceswithanAPIlevellowerthan23becausethefunctionality
is implemented in a callback API that was not introduced until the
APIlevel23.Withthedetailedinformationprovidedbyus,OsmAnddevelopersquicklyrealizedtherootcauseoftheissueandfixedthe
issue by following our suggestions. This shows that the callbackcompatibility issues detected by Cider are useful for improvingthe software quality of Android apps. It also indicates that the
knowledge learned from the 50 apps in our empirical study can be
generalized to other Android apps.
The only bug report that was not confirmed by the app devel-
opers is Ring issue 1831 [ 27]. In this bug report, we reported an
issuewhereacallbackAPIcannotbeinvokedatAPIlevelslower
than 23. The callback API invokes another API that would change
the title of an action bar widget. As a result, when the app runs
ondeviceswithanAPIlevellowerthan23,thetitleoftheaction
barwidgetwillnotbesetproperly.Weconsideredthisissueasa
true positive. However , the app developers of Ring said that the
issuewereportedresidesinsomelegacycodeandtheactionbar
widget isno longerdisplayed. Inother words, evenif thekey API
is not invoked in certain cases, it would not cause any perceivable
consequences.Thisindicatesthatthedeterminationofwhetherthe
missinginvocationofakeyAPIwouldreallyinduceinconsistent
app behaviors can depend on app-specific runtime contexts. It is a
challenge for static analysis to derive such runtime contexts and
determine perceivable impacts of invoking certain APIs. In future,
weplantoexplorethepossibilityofapproximatingsuchruntime
contextssothatCidercanbettermodelappbehavioralinconsis-
tencies induced by the callback API evolutions. This will further
improve the performance of Cider.
Answer to RQ4: Callback compatibility issues reported by
CiderareusefultoAndroiddevelopers.Theknowledgelearned
fromthe50appsinourempiricalstudycanbegeneralizedto
help improve the software quality of other Android apps.
540
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:09 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Huaxun Huang, Lili Wei, Yepang Liu, and Shing-Chi Cheung
8 DISCUSSIONS
Incompleteness of the key API list. Cider takes a list of key
APIswhoseexecutioncancauseuser-perceivableoutcomesasin-
put to detect callback compatibility issues induced by the missing
invocations of these APIs. In this paper, we manually built a list
containing24APIsbasedonourempiricalstudydataset.Thelistis
by no means complete. This may cause Cider to miss real callback
compatibilityissues,leadingtofalsenegatives.Infuture,weplan
toexplorewaystoautomaticallylearnmorekeyAPIsfromvarious
sources such as API documentations to address this problem.
Timeliness of the empirical dataset. Since Android is evolv-
ingquickly,itsframeworkcodeandofficialdocumentsareupdated
constantly.Duetosuchevolutions,ourempiricalstudydatasetmay
becomeoutdatedsomeday.However,ourmainfindingssuchasthecontrolflowinconsistenciesinducedbythecallbackAPIevolutions
may not easily get outdated.
Errors in manual inspection. Our study involved much man-
ual work. For example, we manually identified callback APIs by
analyzingAPI Reference.Such manualprocesses aresubject toer-
rors. This poses a threat to the validity of our findings. To mitigate
the threat, two of the authors independently performed all manual
inspectionsandcross-validatedtheirresults.Wealsoreleaseour
dataset for public access [10].
9 RELATED WORK
9.1 Android Compatibility Issues
Therearemanyexistingstudiesontheevolutionandfragmenta-
tionoftheAndroidecosystemaswellastheresultingcompatibility
issues. Mutchler et al. [ 48] analyzed one million free Android apps
and observed that compatibility issues induced by Android frag-
mentation are of serious concern to the entire app development
community.McDonnelletal.[ 47]studiedAndroidAPIevolution
and its impact on API usage. Bavota et al. [ 36] explored how the
fault-pronenessandchange-proneness ofAndroidAPIscanaffect
appratings.Horaetal.[ 42]studiedthedevelopers‚Äôresponsestothe
Android APIevolutions. Fan etal. [ 39] investigated Android frame-
work crashes and disclosed that one major cause for the crashes
is API evolutions. Li et al. [ 45] studied deprecated Android APIs
and the developers‚Äô reactions. Hu et al. [ 43] studied the compati-
bility issues in Android webview. However, none of the existing
studiesanalyzedhowAndroidevolutionscanchangecallbackAPIs‚Äô
invocation protocols and affect app control flows. In this paper,
we systematically analyzed the changes in callback API invocation
protocols and how such changes can cause compatibility issues.
Another work by Wei et al. [ 51] proposed a tool FicFinder to
detect fragmentation-induced compatibility issues, which include
compatibility issues induced by Android API evolutions (the fo-cus of this paper). FicFinder can detect issues that are caused by
invocationsofcertainissue-inducingAPIs.Itleveragesbackward
slicingforissuedetectionbutdoesnotpreciselyanalyzeappcontrol
flows. In comparison, Cider models inconsistent app control flows
atdifferentAPIlevelsanddetectscallbackcompatibilityissuesin-
duced by such control flow inconsistencies. These issues cannot be
detected by FicFinder.9.2 Android Control Flow Analysis
OurtechniqueanalyzesthecontrolflowsofAndroidapps.There
are several relevant techniques. For example, Blackshear et al. [ 37]
proposedatechniquethatabstractsappcontrolflowsbydiscard-
ingirrelevantflowswhileretainingtheexecutionordersofevent
handlersthatareusefulforcontrolflowanalysis.Yangetal.[ 54]
proposedtheconceptcallbackcontrolflowgraph(CCFG),which
is also used in our work. They also proposed a technique to gen-erate CCFGs for Android activity components by analyzing the
invocationcontextsofcallbackmethods.Arztetal.[ 34]designed
FlowDroid, which performs control flow analysis of Android apps
by synthesizing dummy main methods to model the executions of
callback methods. Sun et al. [ 50] proposed a technique to detect
codereusebymeasuringthesimilaritiesofappcontrolflowgraphs.
Wuetal.[ 53]designedatechniquetodetectunauthorizedopera-
tions in Android apps by leveraging control flow analysis. Gordon
etal.[40]proposedastaticanalysistoolDroidSafethatcombines
app runtime execution models and precise control flow analysis to
detect the leakage of sensitive data in Android apps. Safi et al. [ 49]
proposedDeva,astaticanalysistechniquetodetectanomaliesin-
ducedbynondeterministictimingfortriggeringevents.Whileall
thesetechniquesleveragedappcontrolflowanalysis,noneofthem
considered the inconsistencies of app control flows at different API
levels.Tothebestofourknowledge,ourworkisthefirstthatfo-
cusesonstudyinghowtomodelappcontrolflowinconsistenciesat
different API levels and leverage the model to automatically detect
callback compatibility issues.
10 CONCLUSION
Inthispaper,weconductedanempiricalstudytounderstandAn-
droid callback API evolutions. We found that the evolutions of
AndroidcallbackAPIscancausesignificantchangesintheAPIs‚Äô
invocation protocols. Such changes can affect app control flows
and induce various compatibility issues. Based on the findings, we
proposedagraph-basedmodel,PI-Graph,tocapturethechangesof
Android callback API invocation protocols. We further designed a
staticanalysistechniqueCiderthatleveragesthePI-Graphmodels
toautomaticallydetecttwocommontypesofcallbackcompatibilityissues.WeimplementedCiderandevaluateditsperformanceusing20open-sourceAndroidapps.TheresultsshowthatCidercanpre-
cisely detectreal and previously-unknowncallback compatibility
issues. In future, we plan to extend Cider to support the detection
ofmoretypesofcallbackcompatibilityissues.Wealsoplantoen-
hance Cider‚Äôs performance by better approximating the impact of
its detected control flow inconsistencies on app runtime behaviors.
ACKNOWLEDGMENT
TheauthorsthanktheASE2018reviewersandHKUSTCASTLE
membersfortheirconstructivefeedback.Thisworkissupported
by the Hong Kong RGC/GRF grant 16202917, the MSRA collabora-
tiveresearch fund,Nvidia academicprogram,and theHongKong
PhD Fellowship Scheme. The authors also would like to thank the
SouthernUniversityofScienceandTechnologyforthegenerous
support on the research and travel.
541
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:09 UTC from IEEE Xplore.  Restrictions apply. Understanding and Detecting Callback Compatibility Issues for Android Applications ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
REFERENCES
[1] 2018. AFWall. https://github.com/ukanth/afwall.
[2]2018. Android APIDifferences Report. https://developer.android.com/sdk/api_
diff/19/changes.html.
[3]2018. Android Developer Dashboard. https://developer.android.com/about/
dashboards/index.html.
[4] 2018. Android Lint. https://developer.android.com/studio/write/lint.
[5]2018. Android Open Source Project (AOSP). https://github.com/aosp-mirror/
platform_frameworks_base.
[6]2018. API Reference | Android Developers. https://developer.android.com/
reference/.
[7] 2018. BitMask. https://github.com/leapcode/bitmask_android.
[8] 2018. Calendula. https://github.com/citiususc/calendula.
[9] 2018. cccTV. https://github.com/stefanmedack/cccTV.
[10] 2018. Cider homepage. https://cideranalyzer.github.io.
[11] 2018. DuckDuckGo Android App. https://github.com/duckduckgo/Android .
[12] 2018. F-Droid. https://f-droid.org/en/packages.
[13] 2018. FOSS Browser. https://github.com/scoute-dich/browser.
[14]2018. Fragment - Android Developer. https://developer.android.com/guide/
components/fragments.html.
[15] 2018. GitHub. https://www.github.com.
[16]2018. KeePassDroid Revision 467d6e8. https://github.com/bpellin/keepassdroid/
commit/467d6e8.
[17] 2018. Kolab Notes. https://github.com/konradrenner/kolabnotes-android.
[18] 2018. MaterialFBook. https://github.com/ZeeRooo/MaterialFBook.
[19] 2018. Network Monitor. https://github.com/caarmen/network-monitor.
[20] 2018. NyaaPantsu. https://github.com/NyaaPantsu/NyaaPantsu-android-app .
[21]2018. Omni-notes Issue 248. https://github.com/federicoiosue/Omni-Notes/
issues/248.
[22]2018. OONI-Probe for Android. https://github.com/TheTorProject/
ooniprobe-android.
[23] 2018. OpenKeyChain. https://github.com/open-keychain/open-keychain.
[24] 2018. OsmAnd. https://github.com/osmandapp/Osmand .
[25] 2018. Padland. https://github.com/mikifus/padland .
[26] 2018. PassAndroid. https://github.com/ligi/PassAndroid .
[27] 2018. Ring. https://tuleap.ring.cx/projects/ring.
[28] 2018. Sg for SteamGifts. https://github.com/SteamGifts/SteamGifts .
[29]2018. Simple Solitaire game collection. https://github.com/TobiasBielefeld/
Simple-Solitaire.
[30] 2018. SuntimesWidget. https://github.com/forrestguice/SuntimesWidget .
[31] 2018. Survival Manual. https://github.com/ligi/SurvivalManual.
[32] 2018. Uber Rides Android SDK. https://github.com/uber/rides-android-sdk.
[33]2018. WordPress Issue 6906. https://github.com/wordpress-mobile/
WordPress-Android/issues/6906.
[34]Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bodden, Alexandre Bartel,
JacquesKlein,YvesLeTraon,DamienOcteau,andPatrickMcDaniel.2014. Flow-
Droid:PreciseContext,Flow,Field,Object-sensitiveandLifecycle-AwareTaint
Analysis for Android Apps. In PLDI. 259‚Äì269.
[35]PauloBarros,Ren√©Just,SuzanneMillstein,PaulVines,WernerDietl,andMichael
D. Ernst Ernst. 2015. Static Analysis of Implicit Control Flow: Resolving Java
Reflection and Android Intents. In ASE. 669‚Äì679.[36]Gabriele Bavota, Mario Linares-Vasquez, Carlos Eduardo Bernal-Cardenas, Mas-
similiano Di Penta, Rocco Oliveto, and Denys Poshyvanyk. 2015. The Impact of
API Change- and Fault-Proneness on the User Ratings of Android Apps. TSE41,
4 (Apr 2015), 384‚Äì407.
[37]Sam Blackshear, Bor-Yuh Evan Chang, and Manu Sridharan. 2015. Selective
Control-Flow Abstraction via Jumping. In OOPSLA. 163‚Äì182.
[38]Yinzhi Cao, Yanick Fratantonio, Antonio Bianchi, Manuel Egele, Christopher
Kruegel, Giovanni Vigna, and Yan Chen. 2015. EdgeMiner: Automatically De-
tectingImplicitControlFlowTransitionsthroughtheAndroidFramework.In
NDSS.
[39]LinglingFan,TingSu,SenChen,GuozhuMeng,YangLiu,LihuaXu,GeguangPu,
and Zhendong Su. 2018. Large-Scale Analysis of Framework-Specific Exceptions
in Android Apps. In ICSE. 408‚Äì419.
[40]MichaelIGordon,DeokhwanKim,JeffHPerkins,LimeiGilham,NguyenNguyen,
and Martin C Rinard. 2015. Information Flow Analysis of Android Applications
in DroidSafe. In NDSS.
[41]HyungKilHamandYoungBomPark.2011. MobileApplicationCompatibility
Test System Design for Android Fragmentation. In ASEA. 314‚Äì320.
[42]Andr√©Hora, RomainRobbes,MarcoTulioValente, NicolasAnquetil,Anne Etien,
and St√©phane Ducasse. 2018. How do Developers React to API Evolution? A
Large-Scale Empirical Study. SOFTWARE QUAL J. 26, 1 (Mar 2018), 161‚Äì191.
[43]Jiajun Hu, Lili Wei, Yepang Liu, Shing-Chi Cheung, and Huaxun Huang. 2018.
ATaleofTwoCities:HowWebViewInducesBugstoAndroidApplications.In
ASE.
[44]PatrickLam,EricBodden,OndrejLhot√°k,andLaurieHendren.2011. TheSoot
Framework for Java Program Analysis: a Retrospective. In CETUS.
[45]LiLi,JunGao,Tegawend√©Bissyand√©,LeiMa,XinXia,andJacquesKlein.2018.
Characterising Deprecated Android APIs. In MSR. 254‚Äì264.
[46]Mario Linares-V√°squez, Gabriele Bavota, Carlos Bernal-C√°rdenas, Massimiliano
DiPenta,RoccoOliveto,andDenysPoshyvanyk.2013. APIChangeandFault
Proneness: A Threat to the Success of Android Apps. In FSE. 477‚Äì487.
[47]TylerMcDonnell,BaishakhiRay,andMiryungKim.2013. AnEmpiricalStudyof
API Stability and Adoption in the Android Ecosystem. In ICSM. 70‚Äì79.
[48]Patrick Mutchler, Yeganeh Safaei, Adam Doup√©, and John Mitchell. 2016. Target
Fragmentation in Android Apps. In SPW. 204‚Äì213.
[49]GholamrezaSafi,ArmanShahbazian,WilliamGJHalfond,andNenadMedvidovic.
2015. Detecting Event Anomalies in Event-Based Systems. In FSE. 25‚Äì37.
[50]XinSun,YibingZhongyang,ZhiXin,BingMao,andLiXie.2014. DetectingCode
Reuse in Android Applications Using Component-Based Control Flow Graph. In
IFIP. 142‚Äì155.
[51]Lili Wei, Yepang Liu, and Shing-Chi Cheung. 2016. Taming Android Fragmenta-
tion: Characterizing and Detecting Compatibility Issues for Android Apps. In
ASE. 226‚Äì237.
[52]Xuetao Wei, Lorenzo Gomez, Iulian Neamtiu, and Michalis Faloutsos. 2012. Per-
mission Evolution in the Android Ecosystem. In ACSAC. 31‚Äì40.
[53]Jianliang Wu, Tingting Cui, Tao Ban, Shanqing Guo, and Lizhen Cui. 2015. Pad-
dyFrog: Systematically Detecting Confused Deputy Vulnerability in Android
Applications. SECUR COMMUN. NETW. 8, 13 (Jan 2015), 2338‚Äì2349.
[54]ShengqianYang,DacongYan,HaoweiWu,YanWang,andAtanasRountev.2015.
Static Control-Flow Analysis of User-Driven Callbacks in Android Applications.
InICSE. 89‚Äì99.
542
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:09 UTC from IEEE Xplore.  Restrictions apply. 