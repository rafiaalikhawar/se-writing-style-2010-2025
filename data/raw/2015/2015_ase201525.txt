Developing a DSL-Based Approach for
Event-Based Monitoring of Systems of Systems:
Experiences and Lessons Learned
Michael Vierhauser Rick Rabiser
Christian Doppler Laboratory MEVSS
Johannes Kepler University Linz, AustriaPaul Gr ¨unbacher Alexander Egyed
Institute for Software Systems Engineering
Johannes Kepler University Linz, Austria
Abstract —Complex software-intensive systems are often de-
scribed as systems of systems (SoS) comprising heterogeneous
architectural elements. As SoS behavior fully emerges duringoperation only, runtime monitoring is needed to detect deviationsfrom requirements. T oday, diverse approaches exist to deﬁneand check runtime behavior and performance characteristics.However , existing approaches often focus on speciﬁc types ofsystems and address certain kinds of checks, thus impedingtheir use in industrial SoS. Furthermore, as many SoS need torun continuously for long periods, the dynamic deﬁnition anddeployment of constraints needs to be supported. In this paperwe describe experiences of developing and applying a DSL-basedapproach for monitoring an SoS in the domain of industrialautomation software. We evaluate both the expressiveness of ourDSL as well as the scalability of the constraint checker . We alsodescribe lessons learned.
Keywords—Systems of systems, requirements monitoring, con-
straint checking, domain-speciﬁc languages.
I. I NTRODUCTION
Many software-intensive systems today are systems of sys-
tems comprising heterogeneous and interrelated architectural
elements. Common properties of SoS are decentralized control;support for multiple platforms; inherently volatile and con-ﬂicting requirements; continuous evolution and deployment; aswell as heterogeneous, inconsistent, and changing elements [1].As the full behavior of SoS emerges during operation only,system testing is not sufﬁcient to determine compliance withrequirements. Instead, the behavior of the systems and theirinteractions need to be continuously monitored and checkedduring operation to detect and analyze deviations from theexpected behavior. Checks include the occurrence and orderof runtime events (temporal behavior) [2], the interaction ofsystems (structural behavior), or properties of runtime data(data checks).
Different research communities have been developing run-
time monitoring approaches for various kinds of systemsand diverse types of checks. Examples include requirementsmonitoring [3], [4], monitoring of architectural properties [5],complex event processing [6], or runtime veriﬁcation [7], [8]to name but a few. The expected runtime behavior oftenalso can be expressed formally using temporal logic [9]–[12].Furthermore, domain-speciﬁc languages are used to facilitatethe deﬁnition of constraints [13]–[16], which then can bechecked based on events and data collected from systems atruntime, e.g., via probes instrumenting systems [17].Runtime monitoring in SoS, however, is particularly chal-
lenging as, e.g., temporal, structural, and data constraints needto be checked for a high number of events. Furthermore,many SoS are cyber-physical systems [18] that need to runin 24/7 mode for weeks or even months without interruption,which means that constraints need to be deﬁned and deployeddynamically to ensure live and instant feedback on require-ments violations to users. Many existing runtime monitoringapproaches, however, emphasize particular technologies ortypes of constraints, or are limited to ofﬂine analysis of eventtraces [19]–[21].
This paper describes experiences of extending an existing
incremental consistency checker for design models [22], [23]to support event-based runtime monitoring of SoS [24]. Ourwork is motivated by an industrial case of monitoring a metal-lurgical plant automation system, an example of a large-scaleindustrial SoS (Section II). We describe an industrial scenarioand discuss challenges for constraint checking at runtime. Toaddress these challenges, we developed a domain-speciﬁc con-
straint language aiming at industrial end users, who often lackdeep programming skills, to ease the deﬁnition of various typesof constraints (Section III). Our DSL-based approach allows toincrementally check constraints at runtime and was developed
by extending an existing incremental checker (Sections IVand V). This ensures that violations of requirements can bereported instantly to users monitoring an SoS. The approachfurther supports the deﬁnition and deployment of constraints
at runtime, i.e., constraints can be added or modiﬁed withoutstopping the checker or the monitored systems. We evaluatethe expressiveness of the DSL using real constraints from ourindustrial case and show the scalability of our checker in anindustrial monitoring scenario (Section VI). We also discusslessons learned aimed at researchers and practitioners workingon similar challenges (Section VII). We conclude the paperwith a discussion of related research and an outlook on futurework (Sections VIII and IX).
II. I
NDUSTRIAL CASE AND CHALLENGES
Our industry partner Primetals Technologies – a joint
venture of Siemens and Mitsubishi Heavy Industries – isone of the world’s leading engineering and plant-buildingcompanies in the iron, steel, and aluminum industries. Thecompany provides machinery, hardware, software, and automa-tion systems for steel producers around the globe. We usethe example of a plant automation system (PAS) developed
2015 30th IEEE/ACM International Conference on Automated Software Engineering
978-1-5090-0025-8/15 $31.00 © 2015 IEEE
DOI 10.1109/ASE.2015.25715
and maintained by Primetals Technologies to illustrate the
runtime monitoring and constraint checking challenges. ThePAS automates, optimizes, and tracks different stages of themetallurgical production process. It comprises systems forprocess automation of melting iron ore and raw materialsto produce iron, reﬁning liquid iron and other materials toproduce steel, and casting liquid steel into solid steel slabs.These independently developed automation systems for iron,steel, and continuous casting (cf. Fig. 1) size up to severalmillion LoC. The systems have heterogeneous architectures,they have been developed using diverse technologies, and theyfrequently interact, e.g., when exchanging data controlling themetallurgical production process.
Although the different PAS software systems are engi-
neered independently, there are manifold dependencies in themetallurgical process that need to be considered when planningtheir joint operation. For instance, liquid iron is needed forproducing liquid steel, which is then the input to castingsolid steel slabs. The PAS SoS is further connected to legacyor third-party systems leading to additional complexity. Fur-thermore, there are dependencies between components withinone particular system. For instance, a component optimizingthe arrangement of steel slabs on a strand in the caster –to minimize scrap and to ensure steel quality – relies oninformation provided by other components such as materialtracking.
Besides such constraints, which cross-cut different sys-
tems or components, there are also constraints affecting onlyparticular components. For example, the component handlingthe selection of material from a silo and the subsequenttransportation on a conveyor belt, has to ensure that eventshappen in speciﬁc sequence and within a certain time span toguarantee the uninterrupted and continuous ﬂow of material.
Although such PAS requirements and their dependencies
are carefully managed during development, it is crucial tomonitor them after deployment to detect inaccurate and er-roneous behavior at runtime. This is particularly importantafter upgrading components, a frequent case when modernizingexisting plants. Furthermore, the metallurgical production pro-cess is supervised by operators in control rooms and manualintervention by an operator can have unforeseen effects onthe automation software and the production process, againsuggesting a runtime monitoring approach. For instance, thecut length deﬁned by an operator of the caster system mightconﬂict with required plan characteristics from the productionplanning system, or the ladle-ﬁnished event might not happenin steelmaking, thus affecting the continuous casting process.
A. Industrial runtime monitoring scenario
In the following we describe a typical scenario for runtime
monitoring based on an earlier qualitative study with develop-
ers and engineers of our industry partner [25]. The scenarioshows that constraints need to be deﬁned and deployed dynam-ically and checked continuously at runtime. For the scenariowe assume that the PAS is running at the customer’s site andan infrastructure for runtime monitoring is set up to collectevents and data about the running systems. The scenario shownin Fig. 1 starts with a customer report describing a deviationfrom the expected system behavior: after upgrading several
Fig. 1: Industrial scenario for runtime monitoring of SoS.
components the initialization of the casting system does notcomplete within the expected time frame, thus delaying theprocess of casting liquid steel to solid steel slabs. Due to theinterplay of several systems there are many potential reasonsfor this behavior and both hardware and software issues mighthave caused the problem.
(1) The service engineer reviews the incoming customer
report and remotely connects to the customer’s automation sys-tem to investigate the issue by checking the running systems.(2) The service engineer uses the monitoring infrastructureto retrieve more details about the state of the system, e.g.,by analyzing recorded event data to reveal the origin of thereported problem. This task is simpliﬁed if constraints relatedto the issue have already been deﬁned and violations havebeen recorded. (3) If necessary, the service engineer addsnew constraints to the monitoring infrastructure. Dependingon the type of problem different types of constraints maybe necessary, for instance, to check event sequences or dataranges. In the case of the delayed initialization of the caster theservice engineer adds a new constraint checking the executionof the initialization steps within a time frame of 60 seconds.The constraint is immediately activated in the monitoringinfrastructure to detect deviations from the speciﬁed behaviorin the running system. (4) The service engineer is notiﬁed bythe monitoring infrastructure as soon as the initialization phaseis delayed again. Violations of the new constraint are detectedand can be instantly reviewed by the engineer.
B. Challenges
Several challenges for deﬁning and checking constraints
can be derived from our industrial case:
Constraint diversity. Different types of constraints are
needed to monitor the industrial SoS. This covers global invari-
ants and range checks of variables across the SoS, temporalconstraints on the occurrence and expected order of events,or architectural rules constraining the allowed interactions ofcomponents. Constraints are further required to measure prop-erties such as performance or resource consumption. Regardingruntime monitoring, a wide variety of approaches exist thatfocus on particular types of constraints (see Section VIII).While these approaches focus on speciﬁc types of constraints,
716there is a lack of uniﬁed approaches covering multiple types of
constraints, as needed in our SoS runtime monitoring context.
Incremental deﬁnition and runtime management of con-
straints. Constraints are typically not deﬁned once beforethe system is put into operation but rather incrementallywhen needed. For instance, as our industrial scenario showed,engineers may need to deﬁne additional constraints wheninvestigating an issue reported by a customer. Furthermore,SoS evolve continuously and are conﬁgured to address speciﬁcrequirements. The constraints thus do not remain stable butneed to co-evolve with the system to adapt to certain monitor-ing scenarios [26]. Many existing constraint checkers do notsupport the dynamic deﬁnition and management of constraintsat runtime (see Section VIII). Speciﬁcally, although activating,deactivating, and parameterizing constraints at runtime is sup-ported by some approaches, adding new constraints at runtimetypically cannot be done without restarting the monitoringinfrastructure.
End-user deﬁnition of constraints. End-user support for
writing constraints becomes a primary issue, as a runtime mon-itoring environment and its constraint checking mechanismwill be used in practice by both engineers and maintenancepersonnel. While many existing constraint languages addressthe needs of software developers (see Section VIII), writingnew or understanding existing constraints is much harder forusers without a deep programming background.
III. A C
ONSTRAINT DSL FOR SOSM ONITORING
Existing constraint languages, e.g., requirements-level
methods [14], [27]–[29], UML-based approaches [30], [31], orformal runtime veriﬁcation techniques [9]–[12], often supportspeciﬁc types of constraints. For example, some approachesfocus on monitoring performance properties, while othersemphasize temporal properties, or support aggregating andchecking data. Additionally, most existing approaches havebeen developed for a particular application domain (e.g.,service-based systems [30], [32] or business processes [33])and are hard to apply in other areas. Furthermore, manyexisting constraint languages are deemed as inconvenient byindustrial end users as they require deep understanding offormal concepts or lack tool support.
We conducted a series of workshops and interviews with
engineers and project managers of our industry partner toelicit requirements for a constraint language for SoS runtimemonitoring, based on concepts from existing constraint lan-guages. Emphasizing usefulness and practical applicability, wethen developed a DSL allowing engineers to specify temporal,structural, and data constraints on events and data.
We assume a stream of events observed at runtime by
a monitoring infrastructure. The events are collected in anevent model also managing arbitrary data attached to speciﬁcevents. For example, events in a material quality optimizationsystem show when the system starts, initializes, optimizes,and stores the optimization results. Each event has a timestamp and data can be attached, e.g., the inputs used forinitializing the optimization system, the computed optimizationresults, or information on the performance of the optimizationcomponent.Listing 1: Grammar of our constraint DSL for specifying pastoccurrence, future occurrence, and data constraints
Constraint :
trigger = if event ’trigger event ’ [with Data ] occurs
( PastOccurrence |FutureOccurrence |DataCheck ) .
PastOccurrence :
condition =( event ’event name ’ [ source= ’source ’ ]
has occurred [with Data {,Data }])
|(events ’event name ’ {,’event name ’ }
occurred [consecutively ])
previously in the last Time
FutureOccurrence :
condition =( event ’event name ’ [ source= ’source ’ ]
occurs [with Data {,Data }])
|(events ’event name ’ {,’event name ’ }
occur [consecutively ]) within Time
DataCheck :
condition =data Data {,Data }
Data :
DataItem Operator DataItem |Value
DataItem :
key (’itemname ’ ,’itempath ’ , [ Function ])
Function :
contains |size
Time :
int milliseconds |seconds |minutes |hours
Operator :
>|>=|<|<=|== |!=
Value :
double |int |boolean |String
The grammar of our DSL is shown in Listing 1. Each con-
straint starts with a description of the trigger event activating
the evaluation of the constraint (cf. Fig. 2), e.g., “optimizationrequested”. To also allow specifying invariants, the event typeof the trigger event can be deﬁned as “any”. The triggerspeciﬁcation is followed by a condition statement. Conditions
can be deﬁned to check the past occurrence of a (sequence
of) event(s) before the trigger event; the future occurrence of
a (sequence of) event(s) after the trigger event; or data attached
to the trigger event. Arbitrary or speciﬁc orders of sequencescan be deﬁned.
Conditions on the past or future occurrence of events are
temporal constraints for checking restrictions regarding theoccurrence or sequential order of events, i.e., they are pre- orpost-conditions on these events. For simple order restrictions,
an event of a certain type must occur before or after an eventof a speciﬁc type, e.g., one event of type B must occur afterany event of type A (required sequence [A, B]). For hard time
Fig. 2: Event stream and constraint types of our DSL.
717Listing 2: Examples of three constraints from the PAS
// future occurrence constraint checking a sequence of events
with a hard time limit
trigger = if event ’ControlAdapter . requestOptimization ’
occurs
condition =events
’ Optimizer . optimize START ’ ,
’Optimizer . fetchData ’ ,
’ Optimizer . caculateFINISHED ’ ,
’Optimizer . retrieveOptimizationResult ’ ,
’Cutting . forwardOptimizationResult ’
occur consecutively within 10 seconds .
// past occurrence constraint with a hard time limit
trigger = if event ’Tundish . ca rLockedInCastPosition ’ occurs
condition =event ’Tundish . ladleArrived ’
h a s occurred in the last 500 milliseconds .
// data constraint checking the data attached to the event
System . discInfo
trigger = if event ’System. discInfo ’ occurs
condition =data (’discData ’ ,’Drives / FreeDiscPercentage ’ )>20.
limits, the occurrence of an event of a certain type is required
within a certain time, e.g., an event of type B must occur withina maximum time of ﬁve seconds after an event of type A hasoccurred.
Data constraints check certain items contained in runtime
data objects attached to an event. For numeric values boundarychecks are frequently used, e.g., to ensure a data item is withina certain range. For character sequences usually only checksfor equality are used. Data conditions in our DSL can alsocontain functions, e.g., to count the number of elements in alist, to check whether a list of data objects contains a certainitem, or to calculate the maximum, minimum, or averageof a set of values. It is also possible to combine past andfuture occurrence checks with data checks, e.g., to determineif a certain event occurred with the attached data fulﬁlling aparticular condition.
Listing 2 shows three examples from the PAS: a constraint
checking the future occurrence of an event sequence in aparticular order including a hard time limit for the optimizationsystem cycle; a constraint on the past occurrence of a particularevent with a hard time limit checking that the ladle has arrivedbefore starting casting; and a data constraint checking that freedisc space is larger than 20%.
Checks on past and future occurrence as well as data checks
have been sufﬁcient so far to cover the constraints elicitedtogether with our industry partner (cf. Section VI.A). However,it might be necessary to extend the language in the future tocover additional types of constraints. We have thus developed aDSL-based approach that makes it easy to extend the language.
IV . E
XTENDING AN INCREMENTAL CONSISTENCY
CHECKER TO SUPPORT SOSR UNTIME MONITORING
As runtime monitoring presumes the continuous (re-)eva-
luation of constraints an incremental evaluation strategy isadvisable to ensure fast evaluation feedback to users in caseof violations. We therefore decided to use an incrementalconsistency checker (ICC) [22], [23], [34] developed in ourprevious work on consistency checking of design models inan IDE. To address the challenges identiﬁed in Section IIwe extended the original ICC to support runtime checkingof events and data. We also integrated this new RuntimeIncremental Consistency Checker (RICC) in our SoS RuntimeMonitoring Framework [24].
More speciﬁcally, the RICC (cf. Fig. 3) covers the existing
Runtime Monitoring Framework, the extensions necessary touse the ICC for runtime monitoring, and the original ICC. Ontop of the RICC we added the extensible DSL to support endusers deﬁning constraints in a simple and intuitive manner.The constraints are translated to the underlying language ofthe ICC, which is Java in our current implementation. Whendeveloping the RICC we reorganized the original ICC (whichwas integrated in an IDE) into several components. We nowuse a client-server architecture allowing multiple users tocontribute and modify constraints. Constraints can be addedto the checker at any time without restarting, as the DSL codeis compiled dynamically to Java. Furthermore, we provide toolsupport for different monitoring tasks: an editor to write newconstraints, a tool for activating and deactivating constraintson the monitoring server, and a tool for reviewing constraintviolations of different components and systems of the SoS atruntime.
The RICC relies on events provided by the Runtime
Monitoring Framework, which uses an Event Model to abstract
from different systems and technologies. The event modelenables checking across system boundaries by linking eventsprovided by probes instrumenting different systems. It alsoprovides the foundation for tools visualizing behaviour, per-sisting event logs, or checking constraints on events. Eventsare distinguished by their type. Types can be arranged hi-erarchically to reﬂect the location in the system structure.For example, in the PAS Caster system the event type “Op-timizer.optimize
START” is a child of the “Optimizer” type,
which again is a child of the “Caster” type. Furthermore, eventsare distinguished by their source, i.e., the probes instrumentingsystems or components in the SoS. Each event has a time stampand arbitrary data can be attached, e.g., primitive data types,objects, as well as arrays and lists of data types or objects.Event data can also carry performance information about theinstrumented system.
AnEvent Model Facade allows the ICC – typically running
on a separate server – to register to the event model as listenerand to connect with the runtime monitoring infrastructure (i.e.,the event model). The facade is informed about new incomingevents of certain types from speciﬁc, possibly distributed,sources.
The DSL Editor provides support for writing constraints
in our DSL, including meta-data such as a description, acustom error message, or a severity class. We refer to aconstraint deﬁned in the DSL Editor as a Constraint Deﬁnition .
As soon as the constraint deﬁnition is transmitted to thechecking server, it is compiled to Java on the ﬂy by theRICC to a Compiled Constraint Deﬁnition, thereby making it
usable by the ICC. The Constraint Manager allows activating,
deactivating, and modifying (groups of) constraints.
The Constraint Instance Store is a central component
responsible for maintaining and instantiating compiled con-straints. An active constraint is not instantiated permanentlybut only if an event occurs that matches the trigger eventdeﬁned for this constraint. Each created constraint instance is
718Fig. 3: Our runtime incremental consistency checker (RICC) and its integration with our runtime monitoring framework. The
numbers indicate how the different components interact in a typical scenario.
completely self-contained and can be evaluated independently.
This ensures that even for a high number of incoming eventsonly selected constraints are instantiated and checked.
Depending on the type of constraint, a constraint instance
may need to be evaluated immediately after instantiation (e.g.,when checking data attached to the triggering event or the pastoccurrence of events), or it may need to be postponed untilfuture events arrive. This task is handled by the Evaluation
Delay Manager, which extends the original ICC and addscapabilities for intercepting constraint evaluation requests. Itdelays their evaluation and executes them only when requiredevents arrive or as soon as a speciﬁed timeout occurs.
If a constraint can be evaluated it is passed to the ICC’s
Constraint Engine. The constraint is evaluated by executingits code, thereby accessing the event model via the EventModel Facade to retrieve events or data if necessary. If theconstraint instance evaluates without errors (the constraint con-dition evaluates to true), the instance is immediately destroyedand removed from the checker. If the constraint instance isviolated and evaluates to false, further information on theviolation is forwarded to the Error Handler. This includes
the events leading to the violation, missing events, or violateddata ranges. Listeners can register to this component to receivethis information. For instance, the Runtime Error Manager
tool displays this information as soon as it becomes availableto allow users reviewing occurring violations immediately.Violations can also be persisted for later inspection.
V. I
MPLEMENTA TION AND TOOLS
The RICC has been developed using different components
and technologies. The event model has been implemented inJava as part of the runtime monitoring infrastructure [24]. Themodel provides interfaces for retrieving events of a certain typeor from a speciﬁc source. It further allows registering changelisteners informing the RICC about new events. The DSLeditor and the constraint manager tool are both implementedin Java using the Eclipse RCP framework.
We employed the Java-based frameworks XText and Xtend
(http://www.eclipse.org/Xtext) for developing the constraintDSL, end-user guidance in the editor, and support for thedynamic compilation of DSL code to Java code. The frame-works allow adding new language constructs in a rather simplemanner as the DSL and the transformation steps are treatedseparately and automation is provided, e.g., for supportingsyntax highlighting and auto completion in the editor as shownin Fig. 4(a).
The implementation of the RICC is based on an ear-
lier implementation for checking the consistency of softwareproduct lines [34]. We split the original ICC implementationinto a client and a server part and use the Java CompilerAPI to dynamically compile and load constraints on demand.The evaluation delay manager has been implemented as aseparate Java component intercepting evaluation requests fromthe ICC and postponing them in case of future occurrenceconstraints. The error manager provides interfaces retrievinginformation on violated constraints and for registering listenersto be notiﬁed as soon as constraint violations are detected.
At runtime, a graphical overview is provided of all com-
ponents of the SoS and their current state as shown inFig. 4(b). The runtime error manager shown in this view allowsreviewing constraint violations related to a speciﬁc component,(missing) events responsible for constraint violations, andadditional information provided by the constraints.
719(a) DSL Editor and Constraint Manager.
 (b) Runtime System Overview and Runtime Error Manager.
Fig. 4: Tools for deﬁning and managing constraints (a) and for monitoring and reviewing constraint violations (b).
VI. E V ALUA TION
Our cooperation with Primetals Technologies allowed us
to evaluate our approach by applying the runtime monitoring
infrastructure and the constraint checking approach to sev-eral systems in a realistic setting. We explore two researchquestions regarding the general applicability of our approach.Speciﬁcally, we investigate the expressiveness of our DSL andthe scalability of the RICC in a typical monitoring scenariobased on Primetals Technologies’ SoS.
RQ1 – Is the DSL sufﬁciently expressive to allow its use in
a real-world industrial SoS? We discussed monitoring needs
together with architects and engineers in several workshopsand conducted a series of interviews to assess the current prac-tices at Primetals Technologies for developing, commissioning,and operating their directed SoS. Furthermore, we studieddocuments and analyzed different systems part of the PAS. Forthe evaluation we selected requirements covering the differentsystems of the PAS and formalized them as constraints.
RQ2 – Does the constraint checking approach scale to
industrial needs in the context of a real-world SoS? The
company gave us access to their PAS simulation environment,which is used to test the automation software before and duringcommissioning. We experimented with parts of the PAS ina virtual environment simulating machinery and productionplanning components. This allowed us to use our approach inan SoS environment without interfering with real productionsystems in a metallurgical plant. We describe the resultsof simulations to address RQ2. Speciﬁcally, in a ten-hoursimulation run we measured the number of constraints instan-tiated and checks performed, the memory consumption of theconstraint checking engine, and the average time necessaryto evaluate single constraint instances. We also dynamicallyadded and removed constraints during the ten-hour run to testour capabilities for dynamic constraint deﬁnition and checking.
A. RQ1 – DSL Expressiveness
We performed ﬁve two-hour workshops and several follow-
up meetings with seven system experts to capture require-
ments, which have to be monitored at runtime, from differentparts of the PAS. For example, at SoS level, various non-functional requirements concern monitoring the performanceof the systems’ hardware. Log and trace ﬁles, dumps, andstack traces are continuously created, which can lead to lowdisk space, requiring to monitor the remaining hard disccapacity. Other requirements cover the interaction of differentparts of the system (e.g., user interface and database) or thechecking of (the duration of) certain sequences of events. Forexample, one requirement regards the maximum duration ofa metallurgical calculation. We also monitor the optimizationcomponent, which calculates the optimal distribution of steelslabs on a casting strand and relies on input data from variousother components. Overall, we identiﬁed 40 requirements fromseveral different systems of the PAS to be monitored.
For each of these 40 requirements, we discussed with
engineers from Primetals Technologies how constraints couldbe deﬁned for checking the expected behavior at runtime.For example, one requirement on the timely calculation ofoptimizations led to a future occurrence constraint. This con-straint checks that after an optimization run is triggered, eitherby the operator in his user interface or by another system,the optimization result has to be available within 5 secondsand then fed to the subsequent system. Another requirementon avoiding incorrect or missing quality calculations led to apast occurrence constraint checking that when a robotic armholding a ladle full of liquid steel is starting to move, the dataabout the material in the ladle must already have been updated.Yet another requirement on avoiding incorrect optimizationresults led to a data constraint checking that the “cross sectionoptimization” value is positive and in a certain range whenoptimizations are being calculated.
During these workshops we deﬁned at least one constraint
for each requirement leading to over 40 different constraints.So far the types of constraints our DSL allows to express weresufﬁcient. However, future workshops might reveal new typesof constraints requiring the extension of our DSL. For now, wecan claim our DSL is expressive enough to deﬁne constraintsfor monitoring the industrial SoS.
720TABLE I: Overview of the 13 constraints used for the evalua-
tion, describing the number of checks performed (# checks)and the median evaluation time (MET) for each constraintduring the ten-hour evaluation run.
Const. Type Name # checks MET
[ms]
CST-01 FUTURE PlanChangeUserCheck 128 1.38
CST-02 FUTURE CastSequenceV alidityCheck 2 10.55
CST-03 DATA CheckCrossSectionRange 747 54.06
CST-04 DATA CheckOptiRunId 753 22.00
CST-05 PAST CheckCastingArmProcedure 1 9.74
CST-06 DATA CheckAvailableDiskSpace 16 0.66
CST-07 DATA CheckAvailableStorage 16 0.60
CST-08 DATA CheckCastWatchdogStates 9,700 0.37
CST-09 FUTURE CheckOptiCalcRun 687 1.20
CST-10 FUTURE CheckOptiRunConsistency 584 1.37
CST-11 DATA CheckStrandNumbersV alid 548 14.64
CST-12 FUTURE CheckOptiRunCycle 584 9.71
CST-13 PAST CheckStrandSpeedLength 55,029 1.55
B. RQ2 – RICC Scalability
For evaluating the scalability and applicability of the check-
ing approach to a real-world SoS we used our monitoringinfrastructure and the PAS simulation environment to performa ten-hour evaluation run. Not all constraints we deﬁned can bemonitored in the provided simulator, because it cannot run allrequired systems. We thus selected 13 constraints (cf. Table I;details are not shown due to non-disclosure agreements) toevaluate the scalability of the RICC as described below. Whilethis might seem like a small number, the number of checks(almost 70k) performed on instantiated constraints based onalmost 500k events still allows us to demonstrate scalability.
The goal of our evaluation was to investigate whether the
constraint checker can handle a realistic number of eventswithout signiﬁcant increases in execution time and memoryusage. We also assessed the capabilities for dynamically addingand removing constraints by incrementally adding constraintsand later again deactivating them.
We started with ﬁve active constraints (CST-01–CST-05)
and added added four constraints (CST-06–CST-09) after onehour, followed by four more constraints (CST-10–CST-13)after another hour. The evaluation then continued for sixhours with the full set of constraints active. After eightrespectively nine hours we again reduced the number of activeconstraints by removing CST-01–CST-05 and CST-06–CST-09. The simulation environment and the monitoring infras-tructure were set up on a standard Desktop machine with anIntel(R) Core(TM) i5 CPU @2.60GHz 16GB RAM runningWindows 7 64-Bit.
We measured the number of events that occurred, the num-
ber of constraints instantiated from the 13 constraint deﬁnitions(i.e., the checks performed), the (median) evaluation time foreach constraint (in ms), the maximum number of constraintinstances alive at a certain point in time, and the memoryconsumption of the constraint checker (in MB). During theten hours of the simulation run, 482,841 events and theirrelated data were captured and 68,795 constraints checks wereperformed resulting in an average of 115 checks per minute.
For each constraint instance we measured the time requiredfor executing the method, which checks the constraint andgenerates violations in case of errors. The goal was to assesswhether the number of active constraints negatively inﬂuencesthe evaluation time.
The median evaluation time for a constraint instance ranges
from 0.37 ms for CST-08 up to 54 ms for CST-03. Fig. 5 pro-vides an overview of the evaluation times during the simulationgrouped by the different constraint types. The comparably highmedian evaluation times for data constraints CST-03, CST-04,and CST-11 can be explained by the size and complexity ofthe data items that need to be checked for these constraints.Also there are a few outliers for constraints CST-05, CST-09,and CST-13 (details cf. Fig. 5(a)). Nevertheless, the evaluationtime was always less than one second, which still allows toprovide instant feedback to users. Also, the values indicate thatfor future occurrence constraints (Fig. 5(c)), past occurrenceconstraints (Fig. 5(b)), and data constraints (Fig. 5(d)) thenumber of active constraints does not at all inﬂuence theevaluation time.
The maximum number of active constraint instances for
a measure point ranges from 0 (for most constraints) to 137for constraint CST-13. As described, a constraint instance iscreated only when needed and immediately destroyed afterits evaluation. This is also conﬁrmed by the memory usageof the Java Virtual machine running the constraint checker.In case of CST-13, due to its type, i.e., past occurrence, andthe rather high number of instances that have to be evaluated,constraint instances are queued before they are destroyed.Still, despite this queuing the memory usage does not increasenoticeably, remaining between 330 MB (lower quartile) and412 MB (upper quartile) during the simulation run.
C. Discussion of Results and Threats to V alidity
Our evaluation conﬁrms that we could express all con-
straints elicited for the PAS SoS so far (RQ1) and that the
underlying constraint checker was able to handle the highnumber of incoming events and perform all constraint checksfast enough to provide instant feedback (RQ2).
In terms of external validity, the results and ﬁndings are
based on a single directed SoS in the domain of industrialautomation. We thus cannot claim that the DSL is capableof covering all possible types of constraints in other systems.However, our knowledge of other systems suggests similarconstraint patterns. Due to the ﬂexibility and extensibility ofboth, the DSL and the underlying constraint checker it is possi-ble to consider additional constraint types if needed and adaptthe constraint checker accordingly. Also, the requirements andconstraints selected for the evaluation might not cover the fullrange of requirements existing in the industrial SoS. However,given the scale and complexity of the PAS we consider ourevaluation a good starting point representing a realistic case.We plan to conduct further evaluations with different systemsin the future.
The evaluation focuses on the expressiveness of the
DSL (RQ1) and on the scalability of the constraintchecker (RQ2). We deliberately did not discuss end-user toolsin detail as this is part of a separate study assessing theusefulness of the different tools and editors for writing andmanaging constraints. However, the constraints and the DSL
721(a) Boxplots of evaluation times (in ms) for all constraints.
 (b) Distribution of evaluation times for future occurrence constraints (CST-01,
CST-02, CST-09, CST-10, CST-12)
(c) Distribution of evaluation times for past occurrence constraints (CST-05,CST-13)
 (d) Distribution of evaluation times for data constraints (CST-03, CST-04,CST-06, CST-07, CST-08, CST-11)
Fig. 5: Overview of median evaluation times for all constraints (a) and distributions of evaluation times separately for future
occurrence (b), past occurrence (c), and data constraints (d) over the ten-hour simulation run. We activated constraints after oneand after two hours and deactivated them again after eight and nine hours as shown by the vertical lines.
were developed together with engineers of our industry partner
leading to rapid feedback, which resulted in several adaptationsand improvements during the development process.
Regarding the rather small number of constraints used
in our scalability evaluation (13), the number of constraintinstances created at runtime and the number of constraintchecks performed have a much higher impact on the scalabilityof the checker. We demonstrated in our evaluation that even forconstraints leading to many instances and checks (cf. CST-13)our approach ensures immediate feedback.
Our evaluation did not measure the overhead caused by
the probes instrumenting the system. We also did not considerthe performance of the monitoring infrastructure, which isnot directly part of the constraint checking mechanism andrunning on a separate server. However, earlier evaluations [24]conﬁrm that the underlying infrastructure is capable of hand-ling a high amount of events. Events used for checkingconstraints in our evaluation are provided by probes usingAspectJ (http://eclipse.org/aspectj/). A separate evaluation weconducted shows that the overhead for our probes ranges from1% to 13% for typical instrumentations but can go up to 70%when serializing complex data structures that are later checkedin a constraint. However, the probes used in our evaluationare small, atomic code fragments only collecting speciﬁc datain the SoS, and serializing complex objects was rather theexception. Furthermore, all additional processing and analysistasks are performed independently on a separate machine tokeep the impact on the monitored systems low.VII. L
ESSONS LEARNED
We summarize experiences and lessons learned of de-
veloping our DSL-based checker, which may be useful forresearchers and practitioners working on similar challenges.
Systems of systems require an iterative language design.
The heterogeneous systems in an SoS and the diverse teams in-volved in their development and maintenance make it difﬁcultto develop a language addressing the different needs. Whendeveloping our constraint DSL we started with interviewingdifferent teams responsible for different systems to identifycommon requirements for the language. We showed eachversion of the DSL to these teams and reﬁned it accordingto their comments. This iterative language design helped tocome up with a solution that is acceptable for its users.
Keep the YAGNI (“you aren’t gonna need it”) principle in
mind when developing a DSL. When starting our collaborationwith Primetals Technologies we analyzed diverse existingconstraint languages and formal notations used for deﬁning theexpected behavior of a running system. Although we foundseveral of these approaches quite appealing the reaction ofour industry partner was different. This was mainly becausethe languages provided too many features not needed for theircontext and deﬁning constraints was regarded as difﬁcult usingformal notations. They wanted to deﬁne the constraints as closeas possible to natural language and liked the structured prosetechnique we proposed to them. A key lesson thus is to keepa language as simple as possible and to cover only what isnecessary for the concrete context. The constraint language
722should be oriented towards end users and hide the complexities
of the underlying constraint checker.
Simplify and automate extending the DSL. While keeping
the constraint language simple deﬁnitely makes sense forpractical use, new types of constraints and checks might still beneeded. For example, while we started with support for simplerange checks for data constraints with primitive data objects,later the need arose for more complex checks of data objectsand their relations. It is thus essential to allow extending thelanguage at any time. We thus employed technologies suchas XText and XTend, which make it easy to compile to atarget language like Java from a DSL and to generate end-user support for a DSL based on a grammar.
Keep the mapping of the constraint DSL to the constraint
checker ﬂexible. During our project we also learned that itmight be required to exchange the underlying checker, e.g.,when the number of events to be monitored becomes too highimpacting the checker’s performance too much. So far ourJava-based incremental checker worked ﬁne as demonstrated inthe evaluation. However, future needs might require switchingto a checker providing higher performance for certain typesof constraints. It is thus advisable to deﬁne a clear interfacebetween the language and the checker to allow replacing both.For instance, while keeping our simple DSL, one could re-place our checker with another checker that supports checkingtemporal and data constraints. Only the compilation of ourconstraints to the target language of the checker would thenhave to be changed.
Support dynamic constraint management in runtime mon-
itoring. Industrial scenarios demonstrate the need to add newor modify existing constraints even while the system andthe monitoring infrastructure are running, e.g., to investigatean unforeseen issue. Providing a dynamic approach is thusneeded. A positive side-effect is also the performance of theconstraint checker, which dynamically instantiates constraintsand immediately destroys constraints after their evaluationresults have been stored.
VIII. R
ELA TED WORK
Different research communities have been developing ap-
proaches for monitoring systems to detect violations of re-quirements at runtime. Examples include requirements mon-itoring [3], [4], performance monitoring, complex event pro-cessing [6], or runtime veriﬁcation [7], [8].
Requirements monitoring approaches aim at determining
the compliance of a system with its requirements duringruntime [3], [35]. Monitors are used to detect requirementsviolations and serve as a starting point for revealing the rootcause of problems. For example, Robinson [4] has proposedthe ReqMon framework including a language for deﬁningrequirements and tools supporting different user roles duringmonitoring. ReqMon supports formalizing high-level goals,requirements, and their monitors. It automates generating anddeploying monitors and provides traceability between high-level descriptions and lower-level runtime events.
Performance and event monitoring approaches focus on
monitoring speciﬁc aspects of a running system, e.g., relatedwith performance. Bubak et al. [36], for instance, proposethe J-OCM approach supporting programmers in developingmonitoring tools for distributed Java applications at the virtualmachine level by providing uniform and extensible monitoringfacilities for communication between different components.Their work is based on the Online Monitoring InterfaceSpeciﬁcation (OMIS) [37] providing a standardized interfacebetween monitoring tools and the systems to be monitored.V an Hoorn et al. [21] describe Kieker, an extensible frame-work for event and application performance monitoring. Theframework provides capabilities for system instrumentation,event recording, event processing, and basic visualization.
Requirements monitoring and event monitoring approaches
provide a solid basis for monitoring speciﬁc aspects of singlesystems – e.g., performance, data-ﬂow, or system communi-cation – but are limited regarding the diversity of constraintsand support for constraint checking in SoS architectures.
Complex event processing (CEP) [33] is an approach for
monitoring arbitrary business processes. It aims at combiningevent streams gathered from multiple sources to infer eventsor patterns of events. Event patterns are typically described byimplementing rules in some higher programming language orin an Event Description Language. While we are not focusingon monitoring business processes, CEP makes use of somecommon concepts that are related with our work, i.e., eventdescription languages can be seen as DSLs useful to describeconstraints to be monitored.
Furthermore, in the domain of runtime veriﬁcation various
approaches have been proposed to support monitoring andverifying system properties. For instance, Calinescu et al. [7]propose a three-staged process of monitoring, analysis, andplanning. A system model is veriﬁed to detect violations ofrequirements. Ghezzi et al. [8] present the SPY@RUNTIMEapproach that relies on behavior models which are representedby ﬁnite state automata. An initial model is inferred in a setupphase and then used at runtime to detect changes.
In these and other domains, a wide variety of different con-
straint languages exist for deﬁning requirements, system prop-
erties, or desired event sequences. For example, Spanoudakiset al. [38] present SERENITY , a framework for monitoringsecurity and dependability properties. Monitoring rules areexpressed as EC-Assertions, a temporal formal language basedon the Event Calculus. EC-Assertions are used to detect viola-tions within streams of runtime events, which are are providedby different distributed sources. The language is XML-basedand provides language support for event occurrences suchasHappens, HoldsAt,o r Terminates. Viswanathan et al. [9]
developed two constraint languages for their MaC (Moni-toring and Checking) architecture: PEDL (Primitive EventDeﬁnition Language) for writing low-level speciﬁcations andMEDL (Meta Event Deﬁnition Language) for deﬁning safetyrequirements. This separation allows to adapt to differentimplementation languages and speciﬁcation formalisms (e.g.,Java-MaC [39] for Java programs). Baresi et al. [15] presentmlCCL, the Multi-layer Collection and Constraint Languagepart of the ECoWare framework for monitoring service-basedsystems. Besides constraints for analyzing events, the languagealso provides capabilities for deﬁning how to collect messagesor key performance indicators and how to aggregate datafrom multiple objects. Montali et al. [40] present Declare, adeclarative business process constraint language part of the
723Mobucon EC monitoring framework. The language is based
on the Event Calculus and allows deﬁning sets of rules thatmust be satisﬁed in order to correctly execute a given process.They distinguish between four different types of constraints:existence, choice, relation and negation. Bertolino et al. [41]
present a property-driven approach for runtime monitoring. Aproperty meta-model allows the deﬁnition of quantitative andqualitative properties. The approach further distinguishes be-tween abstract properties for generic declarations, descriptiveproperties describing guaranteed properties, and perspectiveproperties describing system requirements. The approach usesthe GLIMPSE framework for monitoring distributed systemsand checking the properties at runtime. Aktug et al. [42]present an approach for monitoring security properties. Theyuse a security speciﬁcation language called ConSpec to de-scribe automata for security requirements.
Existing constraint languages, however, do not support
all three challenges in SoS monitoring, i.e., coping with thediversity of constraints in large-scale systems, supporting theincremental deﬁnition and runtime management of constraints,and providing end-user support for constraint deﬁnition.
Existing work also often uses temporal logic to support
monitoring software systems. Several authors have shown theexpressiveness and usefulness of such formalisms [10]–[12].However, these approaches usually operate on event tracesand do not support the incremental deﬁnition and runtimemanagement of constraints. Also, they are often difﬁcult touse by industrial end users, at least in our experience.
Developing domain-speciﬁc languages to support (indus-
trial) end users in complex tasks has been discussed in detailin related work, e.g., by Hermans et al. [43] in the area ofWeb services and by V oelter and Visser [44] in the area ofproduct line engineering. Hermans et al. have identiﬁed severalsuccess factors for the use of DSLs in an industrial context:reliability, usability, productivity, learnability, expressiveness,and reusability. Our experiences conﬁrm these success factors.Our evaluation focused on the expressiveness of the constraintDSL and the scalability of the checker. We have also discussedthe reusability of our DSL, i.e., that it is ﬂexible and canbe adapted an automated manner. Assessing productivity andreliability requires longitudinal studies, which we plan toconduct as part of our future work. Also, we plan to assessusability and learnability in studies with our industry partner.In this regard, we will consider the experimental evaluationsperformed for P
ROPEL [45], an approach guiding users through
the process of deﬁning formal property speciﬁcations. Similarto [45], we also plan to assess the usefulness of our DSL fordeﬁning requirements to be used for runtime monitoring.
IX. C
ONCLUSIONS AND FUTURE WORK
Based on a scenario of monitoring an industrial system of
systems we derived challenges regarding the deﬁnition andchecking of constraints at runtime. Existing languages andcheckers cannot easily be applied in an SoS context due tothe diversity of constraints required, the need to incrementallydeﬁne and manage constraints, and the required end-usersupport. We have described a constraint DSL for industrial endusers and an incremental checker we have been developing toaddress these challenges.Our approach supports the incremental checking of con-
straints at runtime and provides live and instant feedback tousers. Our checker also supports the incremental deﬁnitionand dynamic deployment of constraints at runtime, withoutstopping the checker and the monitored system. We evaluatedthe expressiveness of our constraint DSL using real constraintsfrom our industrial case and the scalability of our checkerin an industrial monitoring scenario. Our experiences suggestdesigning a constraint DSL in an iterative manner and keepingit as simple as possible. We also learned to keep the mappingof the DSL to the checking engine ﬂexible to allow switchingunderlying checking technologies.
In our future work we aim to perform a usability assess-
ment of our tools – particularly the constraint DSL editor– involving industrial end users. We further want to applyour approach to systems in other domains and in longitudinalstudies. Furthermore, we are currently working on a frameworkto support the systematic comparison of existing constraint lan-guages and formalisms regarding their usefulness for particularmonitoring scenarios.
A
CKNOWLEDGMENTS
This work has been supported by the Christian Doppler
Forschungsgesellschaft, Austria and Primetals Technologies.We particularly want to thank Christian Danner, Klaus Sey-erlehner, Stefan Wallner, and Helmut Zeisel for their feedbackand support. Special thanks go to Benedikt Aumayr for devel-oping the ﬁrst version of the constraint DSL and checker.
R
EFERENCES
[1] M. W. Maier, “Architecting principles for systems-of-systems,” Systems
Engineering, vol. 1, no. 4, pp. 267–284, 1998.
[2] M. Dwyer, G. Avrunin, and J. Corbett, “Patterns in property speciﬁ-
cations for ﬁnite-state veriﬁcation,” in Proceedings of the 1999 Int’l
Conference on Software Engineering. IEEE, May 1999, pp. 411–420.
[3] N. Maiden, “Monitoring our requirements,” IEEE Software, vol. 30,
no. 1, pp. 16–17, 2013.
[4] W. N. Robinson, “A requirements monitoring framework for enterprise
systems,” Requirements Engineering, vol. 11, no. 1, pp. 17–41, 2006.
[5] H. Muccini, A. Polini, F. Ricci, and A. Bertolino, “Monitoring architec-
tural properties in dynamic component-based systems,” in Component-
Based Software Engineering, LNCS 4608. Springer, 2007, pp. 124–139.
[6] M. V ¨olz, B. Koldehofe, and K. Rothermel, “Supporting strong relia-
bility for distributed complex event processing systems,” in 13th Int’l
Conference on High Performance Computing & Communication, Banff,
Canada. IEEE, 2011, pp. 477–486.
[7] R. Calinescu, C. Ghezzi, M. Z. Kwiatkowska, and R. Mirandola, “Self-
adaptive software needs quantitative veriﬁcation at runtime,” Commu-
nications of the ACM, vol. 55, no. 9, pp. 69–77, 2012.
[8] C. Ghezzi, A. Mocci, and M. Sangiorgio, “Runtime monitoring of
component changes with Spy@Runtime,” in 34th Int’l Conference on
Software Engineering, Zurich, Switzerland, 2012, pp. 1403–1406.
[9] M. Viswanathan and M. Kim, “Foundations for the run-time monitoring
of reactive systems – fundamentals of the MaC language,” in Theoretical
Aspects of Computing, 1st Int’l ICTAC Colloquium, (Revised SelectedPapers), ser. Lecture Notes in Computer Science 3407, Z. Liu andK. Araki, Eds. Springer, 2005, pp. 543–556.
[10] F. Chen, M. d’Amorim, and G. Ros ¸u, “A formal monitoring-based
framework for software development and analysis,” in Formal Methods
and Software Engineering. Springer, 2004, pp. 357–372.
[11] H. Gunadi and A. Tiu, “Efﬁcient runtime monitoring with metric
temporal logic: A case study in the Android operating system,” inProceedings Formal Methods 2014 (FM’14). Springer, 2014, pp. 296–311.
724[12] A. Bauer, M. Leucker, and C. Schallhart, “Monitoring of real-time
properties,” in Foundations of Software Technology and Theoretical
Computer Science (FSTTCS’06). Springer, 2006, pp. 260–272.
[13] A. Paschke, “RBSLA – a declarative rule-based service level agreement
language based on RuleML,” in Int’l Conference on Computational In-
telligence for Modelling, Control and Automation and Int’l Conference
on Intelligent Agents, Web Technologies and Internet Commerce, vol. 2.IEEE, 2005, pp. 308–314.
[14] W. Robinson, “Extended OCL for goal monitoring,” Electronic Com-
munication of the European Association of Software Science andTechnology, vol. 9, no. 1, pp. 1–12, 2008.
[15] L. Baresi and S. Guinea, “Event-based multi-level service monitoring,”
inProceedings 20th Int’l Conference on Web Services (ICWS). IEEE,
2013, pp. 83–90.
[16] H. Phan, G. S. Avrunin, and L. A. Clarke, “Considering the exceptional:
Incorporating exceptions into property speciﬁcations,” Department of
Computer Science, University of Massachusetts, Amherst, MA, vol.1003, 2008.
[17] M. Mansouri-Samani and M. Sloman, “Monitoring distributed systems,”
IEEE Network, vol. 7, no. 6, pp. 20–30, 1993.
[18] T. Bures, P . Hnetynka, and F. Plasil, “Strengthening architectures of
smart CPS by modeling them as runtime product-lines,” in Proceedings
of the 17th Int’l ACM Sigsoft Symposium on Component-based SoftwareEngineering (CBSE’14). ACM, 2014, pp. 91–96.
[19] C. Jeffery, M. Auguston, and S. Underwood, “Towards fully automatic
execution monitoring,” in Radical Innovations of Software and Systems
Engineering in the Future. Springer, 2004, pp. 204–218.
[20] K. Havelund and G. Ros ¸u, “Efﬁcient monitoring of safety properties,”
Int’l Journal on Software Tools for Technology Transfer, vol. 6, no. 2,pp. 158–173, 2004.
[21] A. van Hoorn, J. Waller, and W. Hasselbring, “Kieker: A framework for
application performance monitoring and dynamic software analysis,” inProceedings 3rd Joint Int’l Conference on Performance Engineering,2012, pp. 247–248.
[22] A. Egyed, “Instant consistency checking for the UML,” in Proceedings
of the 28th Int’l Conference on Software Engineering. ACM, 2006,pp. 381–390.
[23] M. Vierhauser, P . Gr ¨unbacher, A. Egyed, R. Rabiser, and W. Heider,
“Flexible and scalable consistency checking on product line variabil-ity models,” in Proceedings Int’l Conference on Automated Software
Engineering, 2010, pp. 63–72.
[24] M. Vierhauser, R. Rabiser, P . Gr ¨unbacher, K. Seyerlehner, S. Wallner,
and H. Zeisel, “ReMinds: A ﬂexible runtime monitoring framework forsystems of systems,” Journal of Systems and Software, 2015.
[25] M. Vierhauser, R. Rabiser, and P . Gr ¨unbacher, “A case study on testing,
commissioning, and operation of very-large-scale software systems,” in36th Int’l Conference on Software Engineering. Hyderabad, India:ACM, 2014, pp. 125–134.
[26] R. Rabiser, M. Vierhauser, and P . Gr ¨unbacher, “V ariability management
for a runtime monitoring infrastructure,” in Proceedings of the Ninth
Int’l Workshop on V ariability Modelling of Software-intensive Systems,V aMoS ’15, Hildesheim, Germany, January 21-23, 2015, 2015, p. 35.
[27] A. van Lamsweerde, Requirements Engineering: From System Goals to
UML Models to Software Speciﬁcations. Wiley, 2009.
[28] J. Skene and W. Emmerich, “Engineering runtime requirements-
monitoring systems using MDA technologies,” in Trustworthy Global
Computing. Springer, 2005, pp. 319–333.[29] J. Whittle, P . Sawyer, N. Bencomo, B. Cheng, and J.-M. Bruel,
“RELAX: a language to address uncertainty in self-adaptive systemsrequirement,” Requirements Engineering, vol. 15, no. 2, pp. 177–196,
2010.
[30] P . Zhang, B. Li, H. Muccini, and M. Sun, “An approach to monitor
scenario-based temporal properties in web service compositions,” inAdvanced Web and Network Technologies, and Applications. Springer,
2008, pp. 144–154.
[31] K. Kiviluoma, J. Koskinen, and T. Mikkonen, “Run-time monitoring
of architecturally signiﬁcant behaviors using behavioral proﬁles andaspects,” in Proceedings of the 2006 Int’l Symposium on Software
Testing and Analysis. ACM, 2006, pp. 181–190.
[32] L. Baresi, S. Guinea, O. Nano, and G. Spanoudakis, “Comprehensive
monitoring of BPEL processes,” IEEE Internet Computing, vol. 14,
no. 3, pp. 50–57, 2010.
[33] D. C. Luckham, Event processing for business: Organizing the real-time
enterprise. John Wiley & Sons, 2011.
[34] M. Vierhauser, P . Gr ¨unbacher, W. Heider, G. Holl, and D. Lettner,
“Applying a consistency checking framework for heterogeneous modelsand artifacts in industrial product lines,” in Model Driven Engineering
Languages and Systems. Springer, 2012, pp. 531–545.
[35] S. Fickas and M. S. Feather, “Requirements monitoring in dynamic
environments,” in 2nd IEEE Int’l Symposium on Requirements Engi-
neering, York, England, 1995, pp. 140–147.
[36] M. Bubak, W. Funika, M. Smetek, Z. Kilia ´nski, and R. Wism ¨uller,
“Event handling in the J-OCM monitoring system,” in Parallel Pro-
cessing and Applied Mathematics. Springer, 2004, pp. 344–351.
[37] T. Ludwig, R. Wism ¨uller, V . Sunderam, and A. Bode, “OMIS: On-
line Monitoring Interface Speciﬁcation (v. 2.0),” Technische Universit ¨at
M¨unchen, Tech. Rep. TUM-I9733, 1997.
[38] G. Spanoudakis, C. Kloukinas, and K. Mahbub, “The SERENITY
runtime monitoring framework,” in Security and Dependability for
Ambient Intelligence. Springer, 2009, pp. 213–237.
[39] M. Kim, M. Viswanathan, S. Kannan, I. Lee, and O. Sokolsky, “Java-
MaC: A run-time assurance approach for Java programs,” Formal
Methods in System Design, vol. 24, no. 2, pp. 129–155, 2004.
[40] M. Montali, F. M. Maggi, F. Chesani, P . Mello, and W. M. van der
Aalst, “Monitoring business constraints with the event calculus,” ACM
Trans. Intell. Syst. Technol., vol. 5, no. 1, pp. 17:1–17:30, Jan. 2014.
[41] A. Bertolino, A. Calabr `o, F. Lonetti, A. Di Marco, and A. Sabetta,
“Towards a model-driven infrastructure for runtime monitoring,” inSoftware Engineering for Resilient Systems. Springer, 2011, pp. 130–144.
[42] I. Aktug, M. Dam, and D. Gurov, “Provably correct runtime monitor-
ing,” in Formal Methods (FM’08). Springer, 2008, pp. 262–277.
[43] F. Hermans, M. Pinzger, and A. van Deursen, “Domain-speciﬁc lan-
guages in practice: A user study on the success factors,” in Model
Driven Engineering Languages and Systems, ser. Lecture Notes inComputer Science 5795, A. Sch ¨urr and B. Selic, Eds. Springer Berlin
Heidelberg, 2009, pp. 423–437.
[44] M. V oelter and E. Visser, “Product line engineering using domain-
speciﬁc languages,” in 15th Int’l Software Product Line Conference
(SPLC 2011). Munich, Germany: IEEE CS, 2011, pp. 70–79.
[45] R. L. Cobleigh, G. S. Avrunin, and L. A. Clarke, “User guidance for
creating precise and accessible property speciﬁcations,” in Proceedings
of the 14th ACM SIGSOFT Int’l Symposium on Foundations of SoftwareEngineering, ser. SIGSOFT ’06/FSE-14. ACM, 2006, pp. 208–218.
725