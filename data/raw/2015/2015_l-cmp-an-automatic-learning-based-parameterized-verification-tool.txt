L-CMP: An Automatic Learning-Based Parameterized
Verification Tool
Jialun Cao
The State Key Laboratory of
Computer Science, Institute of
Software, Chinese Academy of
Sciences & University of Chinese
Academy of Sciences
Beijing, China
caojl@ios.ac.cnYongjian Li∗
The State Key Laboratory of
Computer Science, Institute of
Software, Chinese Academy of
Sciences
Beijing, China
lyj238@ios.ac.cnJun Pang
Faculty of Science, Technology and
Communication & Interdisciplinary
Centre for Security, Reliability and
Trust, University of Luxembourg
Esch-sur-Alzette, Luxembourg
jun.pang@uni.lu
ABSTRACT
This demo introduces L-CMP, an automatic learning-based pa-
rameterized verification tool. It can verify parameterized proto-
cols by combining machine learning and model checking tech-
niques. Given a parameterized protocol, L-CMP learns a set ofauxiliary invariants and implements verification of the protocol
using the invariants automatically. In particular, the learned auxil-
iaryinvariantsarestraightforwardandreadable.Theexperimen-
tal results show that L-CMP can successfully verify a number ofcache coherence protocols, including the industrial-scale FLASH
protocol. The video presentation of L-CMP is available at https:
//youtu.be/6Dl2HiiiS4E, and the source code can be downloaded at
https://github.com/ArabelaTso/Learning-Based-ParaVerifer.
CCS CONCEPTS
•Theoryofcomputation →Verificationbymodelchecking ;
KEYWORDS
Parameterized verification, model checking, association rule learn-
ing, machine learning
ACM Reference Format:
JialunCao,YongjianLi,andJunPang.2018.L-CMP:AnAutomaticLearning-
Based Parameterized Verification Tool. In Proceedings of the 2018 33rd
ACM/IEEEInternationalConferenceonAutomatedSoftwareEngineering(ASE
’18), September 3–7, 2018, Montpellier, France. ACM, New York, NY, USA,
4pages.https://doi.org/10.1145/3238147.3240487
1 INTRODUCTION
Parameterized concurrentsystems, inparticular, cachecoherence
protocols, exist in many practical applications [ 12]. Verifying such
∗Corresponding author
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ASE ’18, September 3–7, 2018, Montpellier, France
© 2018 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.3240487systems has attracted considerable academic interests due to its
practicalimportance[ 13].Aparameterizedprotocol P(N)contains
Nhomogeneousnodes(seesub-figure(a)inFigure 1), sometimes
also contains a heterogeneous node (e.g., FLASHprotocol contains
a‘Home’node,seesub-figure(c)inFigure 1).Thetargetistoverify
that the properties are satisfied for arbitrary sizes of instances. Al-
though the correctness of fixed number of instances can be proved,
their correctness cannot imply the correctness of protocols of arbi-
trary sizes. This problem has been proved to be undecidable [2].
Toaddressthisproblem,manyapproacheshavebeenproposed[ 3,
5–7,9,14–17,19]. Among them, “parameterized abstraction and
guardstrengthening”method,alsoknownasCMP[ 6,14],hasbeen
widely applied to verify large-scaled and industrial protocols, in-
cluding Intel’s Chipset and FLASHprotocols [ 18]. The main idea
of CMP is to construct an abstract protocol AP(m)(mis usually 2
or 3).APcontainsmnormal nodes plus an abstracted node Other,
whichsimulatesthebehavioroftherestnodes.Aswecanseefrom
Figure1, insub-figure(b), mis2 becauseonly homogeneousnodes
in protocol (a), while in sub-figure sub-figure (d), mis set to be 3
becausethereisaheterogeneousnode Homeinsub-figure(c).In
general,APmay fail to satisfy the desired properties because it
is too‘permissive’ [ 6], soresearchers need tocome up (manually)
withasetofauxiliaryinvarianttorestrictitsbehavior.However,
to construct auxiliary invariants manually is often error-prone,
especially when the protocol description is large and complex [6].
Figure1:Differenttypesofparameterizedprotocolsandcor-
responding abstracted protocols after CMP
Inthis paper,weproposeL-CMP,which canautomaticallylearn
auxiliary invariants, abstract and strengthen the parameterized
protocolsinaunifiedframework.WithL-CMP,asetofauxiliaryin-
variantscanbelearnedfromthereachablestatesetsoftheinstances
892
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Jialun Cao, Yongjian Li, and Jun Pang
of protocols, and be applied to verify the protocol automatically.
The soundness of L-CMP is guaranteed in [8].
Figure 2: The envisioned users
A distinguished novelty of our tool lies in two aspects. Firstly,
the combination of association rule learning and parameterized
verification automates the verification process, and expands the
applicationareaofmachinelearningalgorithms.Itmayalsoshed
somelightonthefurthercombinationofthesetwoareas.Secondly,
the invariants it obtains can not only help to automate the veri-
fication, but also provide deep insights for researchers to better
understand the mechanism of protocols because the form of these
invariants are straightforward and understandable. Therefore, our
envisioned users are protocol designers and researchers who want
togainbetterunderstandingandinsightsofprotocols,andbusiness
analystswhowanttocheckthecorrectnessofpracticalprotocols
(see Figure 2).
2 RELATED WORKS
There have been many studies who tried to address the problem of
parameterizedverificationwiththeaidofcomputer.Arons etal.pro-
posedtheconceptof“invisibleinvariants”,whicharecomputedina
finite system instance to aid inductive invariant checking [ 3]. Con-
chonetal.cameupwiththeBRABalgorithmwhichisimplemented
in an SMT-based model checker. It computes over-approximations
of backward reachable states that are checked to be unreachablein the parameterized system [
7]. Liet al. proposed a method to
automatically generate auxiliary invariants from a small reference
instanceofprotocolsandconstructaparameterizedformalproof
in the theorem prover Isabelle [ 12]. Compared with these works,
L-CMPprovidesasimplerwaytoverifyparameterizedprotocols,
andtheauxiliaryinvariantsitobtainsaremoreunderstandableand
straightforward.
3 AN OVERVIEW OF L-CMP
ThearchitectureofL-CMPisshowninFigure 3.Wecanseethat
there are two main phases in the framework. The first phase is
regardedasthe Learningphase.Itreceivesaparameterizedprotocol
written in the input language of the model checker Murphi and
returns a set of auxiliary invariants. This phase consists of threeparts. Preprocessor utilizes Murphi to enumerate the reachableset of the instance of protocols and transforms it into a dataset
consistingofnumericvectors.Then Learnerlearnsassociationrules
fromtheconstructeddataset.Notethatthelearnedassociationrules
are not necessarily invariants, so Selectoris executed with the help
of Murphi to select invariants. After selection, what remained is
regarded as auxiliary invariants and will be used in the second
phase.Thesecondphaseisan advancedCMP phase.UnlikeCMP,whose
strengtheningprocesscomesafterabstraction,theadvancedCMPcar-
riesoutstrengtheningprocessbeforeabstractionsothatmorepred-
icatescan beadded intoguardof rules.Phasetwo alsoconsists of
threemainsteps. Strengthener strengthenstheguardofeachrule
using auxiliary invariants. It is noteworthy that not all auxiliary
invariantswillbeusedinthisstep,andoncesomeofthemareused,theywillberecordedandverifiedinthefinalstep.Next, Abstractor
abstractslocalvariablesintherules.Afterthisstep,anabstracted
protocolisgeneratedanditwillbesubjectedtoMurphitogether
with the used auxiliary invariants. If it passes the model checking,
then L-CMP comes outputs the result. Otherwise, parameters in
Learnerwill be adapted and the next round of execution will start.
Figure 3: The architecture of L-CMP
4 IMPLEMENTATION DETAILS
4.1 Phase One
GivenaparameterizedprotocolintheMurphilanguage,thefirst
step is to generate the reachable set of its instance. We use Murphi
tocomputethe reachableset,whichcanwrite allreachablestates
atleastonce.Ingeneral,weassumethattheprotocolcontainsonly
homogeneous nodes so the size ofinstance is set tobe 2. If there
is a heterogeneous node in the protocol (e.g., the FLASHprotocol),
thenthesizeofinstancewillbesettobe3,includingtwonormal
nodes and one Homenode. Note that there are two possible forms
to represent parameters: digits (i.e., 1, 2) or labeled type names
(i.e.,NODE_1,NODE_2,where‘NODE’isauser-defineddatatype).
The first form is the ordinary expression, and the second form is
used when the protocol applies symmetry reduction to reduce the
searchingspace.L-CMPwillrecordtheformofparametersanduse
it as identifiers.
Then, the reachable set is transformed into a new dataset. We
extract atomic predicates from the guard of rules and properties.
Thisstepiscrucialbecausewithoutitthefollowinglearningpro-
cessmaynotbeabletoobtainsufficientauxiliaryinvariants.We
also build a map to record all the possible values for each variable.
According to the atomic predicates, the reachable set can be trans-
formedintostatevectorswhichcontainonlypredicates.Tobemore
specific, if the predicate holds at one state, then we can add the
original predicate to the state. Otherwise, the negative form of the
predicate will be added. Note that because of symmetry reduction,
the value of some variables could be ‘Undefined’, meaning that
the value of the variable is unknown. In this case, whether the
predicateholdsinthatstateisunknown,sothepredicatewillbe
deleted from the corresponding state. After this step, we acquire a
893
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. L-CMP: An Automatic Learning-Based Parameterized Verification Tool ASE ’18, September 3–7, 2018, Montpellier, France
newdatasetconsistingofrecords,whereeachrecordrepresentsa
reachablestateinthereachableset,andthelengthofrecordsare
not necessarily the same.
Theassociationrulelearningisappliedtothedatasetinthethird
step.Association rulesare strongrelations betweenitemsin large
databases. Assume that a database contains records, each of which
includesseveralitems,thenthelearningresultwillbetherelations
in the database, in the form of ψ→ϕwhereϕandψare sets of
items.Inourcase,therecordsinthedatasetarealreadyconstructed,
whileitemsofassociationrulelearningarecorrespondenttothe
predicatesintherecords.Toimplementassociationrulelearning,
thereareseveralalgorithmssuchasEclatandFP-growth.Inthis
paper, we apply the Apriori [ 1] algorithm because it is more conve-
nient to constrain the size of frequent set. The frequent set is a set
ofitemsthatfrequentlyappearsinthedataset.Wesetthesizeofthe
frequentsettobeatmost K,whereKisaparameterthatisinitially
set to be 3. It may be fixed according to the subsequent steps. Note
that the minimum support and minimum confidence in Apriori are
also parameters, which are set to be 0 .0 and 1 .0, respectively.
Figure 4: The process of minimizing association rules
The number of learned association rules is generally large, so
weneedasteptominimizeit(seeFigure 4).Therearetwopossible
forms of parameters as mentioned above, so we need to replace
themwithaunifiedform.Wereplaceparameterswith P1,P2inthe
orderofappearance.Thisiswhythe‘NODE_2’ofsecondstatement
in top left of Figure 4will be replaced by P1. Moreover, those
symmetrical association rules will be unified as one. Note thatsome of association rules are axiomatic but useless (see the first
association rule in the top of Figure 4), so they will be removed.
Then the parameterizedassociation rules will be instantiatedby i
andj,respectively.Finally,webuildadictionarytorecordallthe
left sides of association rules which have same right side. For each
right side, we build an index to represent all the left sides. Note
thateachleftsideisaset.Ifoneleftsideisthesubsetofanother,then the index of that larger set will be removed. For example, if
association rules p→randp∨q→rare obtained, then after this
step, only p→rwill remain.
Selector, as its name implies, selects auxiliary invariants from
theassociationrules.ThisstepneedsthehelpofMurphi.Although
it is impossible to verify all the association rules for protocols with
arbitrary sizes, we can check them in several small instances. To
realizeit,weconstructatranslatorwhichtranslatestheassociation
rulesinto theMurphi language,so thatwe checkthem inMurphi.
Then, these translated association rules together with the original
instancefromwhichthereachablesetcalculatedaresubjectedto
Figure 5: The process of selecting auxiliary invariants
Murphi.Wheneveranassociationrulefailstopassthemodelcheck-
ing step, L-CMP removes it and continues to check the rest. When
alltheremainingassociationrulespasstheverification,L-CMPwill
increase the size of instance and repeat the above process. This
selectionstepproceedsuntilnoassociationrulescanberemoved
or the searching space is getting too large. Note that we apply mul-
tiprocessing to accelerate this step (as shown in Figure 5), each
processchecksapartofassociationrules,andreturnswhethertheypasstheverification.Thenthemainprocessorcollectsalltheresult
andremovesthefailedonesfromtheassociationruleset.Finally,
theremainingassociationrulesareregardedasauxiliaryinvariants.
4.2 Phase Two
Before going into details, we need to elaborate the structure of
protocolrules.Aruleconsistsoftwomainparts: guardandaction.
If the predicates in guard are satisfied, the statements in action canbeexecuted.Aswecansee,theguardisaconjunctionofpredicates,
whiletheauxiliaryinvariantsareinformof
ϕ→ψ,whereϕ,ψare
sets of predicates. Thus, it is straightforward to add the conclusion
(i.e.,ψ)ofauxiliaryinvariantstotheguardofrulesifitsantecedent
(i.e.,ϕ) is a subset of the guard. This strengthening step iterates
until no more predicates can be added into the guard.
ruleset {parameters definition} do -- for example, i : NODE
rule "rule_name"
guardpart -- conjunction of predicates
==>
actionpart -- a set of statements
endrule; endruleset;
Phase2startsatpartitioningtherulesintofourparts:definition,
rulename,guardandaction.Thenweparsetheguardintopredi-
catesandexecutetheabove-mentionedstrengtheningprocess.Theauxiliary invariants which are used to strengthen the guard will be
recorded. Besides, a dictionary is exploited to map the antecedents
ofusedauxiliaryinvariantstothecorrespondingconclusions.Next,
the abstraction step is implemented by removing the predicatesand statements relating to parameters in the definition part. Forexample, if a rule has two parameters
iandj, at first, we remove
thoserelatedtoparameter iandgeneratethefirstabstractedrule,
anddothesameforparameter j.Further,thoserelatedtoeither ior
jare all removed and a third new rule is generated. Hence, if a rule
has one parameter, then after strengthening and abstraction steps,
itwillgenerateatmostonenewrule.Whileifithastwoparameters,
the answer will be three. It is noteworthy that if the right side of a
statement is about to be abstracted, then the dictionary we build
previously will be used to check whetherthe right part is a key. If
it is a key, then it will be replaced by its corresponding value. This
process prevents the loss of data during abstraction.
894
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Jialun Cao, Yongjian Li, and Jun Pang
5 TOOL USAGE
HereisanexampleshowinghowL-CMPworks.Afterdownloading
L-CMPandinstallingMurphiandPython,itisimportanttoinlcudethepathtoMurphiintothefile‘murphi_url.txt’.WeprovideseveralprotocolsinL-CMP.ThehelpdocumentisillustratedinFigure 6.T o
verifyFLASH,forexample,wecansimplytype‘python3main.py
-p flash -n 3’ and the verification will be executed automatically.
BecauseFLASHis fairly large, so it takes some time to verify. After
it finishes, the result will be printed out and several important files
such as verified protocols, association rules, auxiliary invariants
and other backup files will be saved in the corresponding folder.
Figure 6: The help document of L-CMP
6 EXPERIMENTAL EVALUATION
WeappliedL-CMPtoseveraltypicalparameterizedprotocols.Among
them,MOESI,MESI,MutualExclusion (abbrv.MutualEx), MutualEx-
clusion with data (abbrv. Mutdata) are small-scale protocols, while
GermanandFLASHprotocolsaremorecomplicated1.Thesizeof
instance for most protocols is set to be 2, while for FLASH,i ti ss e t
to be 3.
Table 1: Experiment results
protName states # assoRules # auxInvs # usedF Time (s) result
MOESI 23 736 20 5 24.744 /check
MESI 8 144 16 5 24.412 /check
MutualEx 12 656 12 3 89.869 /check
Mutdata 88 540 12 6 19.703 /check
German 852 21202 448 8 85.418 /check
Flash 1350226 358710 1636 32741371.023 /check
The experimental results for each of these protocols are sum-
marized and presented in Table 1. Each record includes protocol
name,sizeofreachablesets,numberofassociationrules,numberof
auxiliary invariants, number of used auxiliary invariants, running
time,andresult.Wecanseefromthetablethatreachablesetsofthefirstfourprotocolsarerathersmall,followedby German,whilethe
reachablesetof FLASHisenormouscomparingwith theprevious
1The version of GermanandFLASHprotocols we use are the same as those used
in Chouet al.’s work [6]ones. As for running time, almost the first five protocols can be
verifiedwithinaboutoneminute,whereas FLASHtakesabout11
hours.Mostofthetimeisspentonselectingauxiliaryinvariants
fromassociationrules.Thisprocesscanbeacceleratedbyallocating
more processors to L-CMP. If we allocate 16 processors to L-CMP,
the total running time for verifying FLASHis approximate 6 hours.
7 CONCLUDING REMARKS
In this paper, we present an easy-to-use tool, L-CMP, which can
verifyparameterizedprotocolsautomatically.Itprovidesstraight-
forward and understandable invariants. Besides, it also has solid
theoreticalbackground.Theverificationresultsoftypicalbench-
marks are reported in detail. Experiments demonstrate both feasi-
bility and effectiveness of L-CMP. In the future, we plan to extend
the ability of L-CMP to verify more general safety and liveness
properties.
ACKNOWLEDGEMENTS
The authors are partially supported by grant 61672503 from Na-
tional Natural Science Foundation and grant 2017YFB0801900 from
the National Key Research and Development Program in China.
REFERENCES
[1]R. Agrawal, T. Imieliński, and A. Swami. 1993. Mining association rules between
sets of items in large databases. ACM SIGMOD Record, Vol. 22, 207–216.
[2]K. R. Apt and D. C. Kozen. 1986. Limits for automatic verification of finite-state
concurrent systems. Information Processsing Letters 22, (6), 307–309.
[3]A. Pnueli, S. Ruah, Y. Xu, and L. Zuck. 2001. Parameterized verification with
automatically computed inductive assertions?. In CAV. Springer, LNCS 2102,
221–234.
[4] K. Baukus et al.2002. Parameterized verificationof a cache coherence protocol:
Safety and liveness. In VMCAI. Springer, LNCS 2294, 317–330.
[5]X. Chen and G. Gopalakrishnan. 2006. A General Compositional Approach to
VerifyingHierarchicalCacheCoherenceProtocols. TechnicalReport.UUCS-06-014,
School of Computing, University of Utah.
[6]C.-T.Chou,P.KMannava,andS.Park.2004. Asimplemethodforparameterized
verification of cache coherence protocols. In FMCAD. Springer, LNCS 3312, 382–
398.
[7]S.Conchon,A.Goel,S.Krstic,A.Mebsout,andF.Zaıdi.2012. Cubicle:Aparallel
SMT-basedmodelcheckerforparameterizedsystems.In CAV.Springer,LNCS
7358, 718–724.
[8]S. Krstic. 2005. Parameterized system verification with guard strengthening and
parameter abstraction. In Automated Verification of Infinite State Systems.
[9]S. Conchon, A. Goel, S. Krstić, A. Mebsout, and F. Zaïdi. 2013. Invariants for
finite instances and beyond. In FMCAD, 2013. IEEE, 61–68.
[10]E. A. Emerson and V. Kahlon. 2003. Exact and efficient verification of parameter-
ized cache coherence protocols. In CHDVM. Springer, LNCS 2860, 247–262.
[11]S.K.LahiriandR.E.Bryant.2004.Constructingquantifiedinvariantsviapredicate
abstraction. In VMCAI. Springer, LNCS 2937, 267–281.
[12]Y.Li,K.Duan,Y.Lv,J.Pang,andS.Cai.2016. Anovelapproachtoparameterized
verification of cache coherence protocols. In ICCD. IEEE, 560–567.
[13]Y. Lv, H. Lin, and H. Pan. 2007. Computing invariants for parameter abstraction.
InMEMOCODE. IEEE, 29–38.
[14]K. L. McMillan. 2001. Parameterized verification of the FLASH cache coherence
protocolbycompositionalmodelchecking.In CHARME.Springer,LNCS2144,
179–195.
[15]S. Pandav, K. Slind, and G. Gopalakrishnan. 2005. Counterexample guided in-
variantdiscoveryforparameterizedcachecoherenceverification.In CHARME.
Springer, LNCS 3725, 317–331.
[16]A. Pnueli, S. Ruah, and L. Zuck. 2001. Automatic deductive verification with
invisible invariants. In TACAS. Springer, LNCS 2013, 82–97.
[17]A.PnueliandE.Shahar.1996. Aplatformforcombiningdeductivewithalgorith-
mic verification. In CAV. Springer, LNCS 1102, 184–195.
[18]M.TalupurandM.R.Tuttle.2008.Goingwiththeflow:Parameterizedverification
using message flows. In FMCAD. IEEE, 1-8.
[19]A. Tiwari, H. Rueß, H. Saïdi, and N. Shankar. 2001. A technique for invariant
generation. In TACAS. Springer, LNCS 2013, 113–127.
895
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. 