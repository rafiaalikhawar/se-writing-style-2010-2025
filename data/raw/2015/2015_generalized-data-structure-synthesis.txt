Generalized Data Structure Synthesis
Calvin Loncaric
loncaric@cs.washington.edu
Paul G. Allen School of Computer
Science & Engineering
University of Washington
Seattle, WA, USAMichael D. Ernst
mernst@cs.washington.edu
Paul G. Allen School of Computer
Science & Engineering
University of Washington
Seattle, WA, USAEmina Torlak
emina@cs.washington.edu
Paul G. Allen School of Computer
Science & Engineering
University of Washington
Seattle, WA, USA
ABSTRACT
Data structure synthesis is the task of generating data structure
implementations from high-level specifications. Recent work in
this area has shown potential to save programmer time and reduce
the risk of defects. Existing techniques focus on data structures for
manipulatingsubsetsofasinglecollection,butreal-worldprograms
often track multiple related collections and aggregate properties
such as sums, counts, minimums, and maximums.
Thispapershowshowtosynthesizedatastructuresthattrack
subsetsandaggregationsofmultiplerelatedcollections.Ourtech-
niquedecomposesthesynthesistaskintoalternatingstepsof query
synthesis andincrementalization.Thequerysynthesisstepimple-
mentspureoperationsoverthedatastructurestatebyleveraging
existing enumerative synthesis techniques, specialized to the data
structures domain. The incrementalization step implements imper-
ativestatemodificationsbyre-framingthemasfreshqueriesthat
determine what to change, coupled with a small amount of codeto apply the change. As an added benefit of this approach over
previous work, the synthesized data structure is optimized for not
onlythequeriesinthespecificationbutalsotherequiredupdateop-erations.Wehaveevaluatedourapproachinfourlargecasestudies,
demonstrating that these extensions are broadly applicable.
CCS CONCEPTS
•Theoryofcomputation →Datastructuresdesignandanal-
ysis;•Software and its engineering →Source code genera-
tion;
KEYWORDS
Program synthesis, automatic programming, data structures
ACM Reference Format:
CalvinLoncaric,MichaelD.Ernst,andEminaTorlak.2018.GeneralizedData
StructureSynthesis.In ICSE’18:40thInternationalConferenceonSoftware
Engineering, May 27–June 3, 2018, Gothenburg, Sweden. ACM, New York,
NY, USA, 11 pages. https://doi.org/10.1145/3180155.3180211
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden
©2018 Copyright held by the owner/author(s). Publication rights licensed to the
Association for Computing Machinery.
ACM ISBN 978-1-4503-5638-1/18/05...$15.00
https://doi.org/10.1145/3180155.31802111 INTRODUCTION
Many programming tasks can be framed as data structure prob-
lems, especially in domains like user interfaces or web services
wheresoftwaremustmanagesomeinternalstateandalsohandle
asynchronousevents.Manuallyimplementingcomplexapplication-
specific data structures can be time-consuming and error-prone.Recent research seeks to automatically synthesize data structure
implementations from high-level specifications, thus ensuring cor-
rectness and run-time efficiency with minimum programmer ef-
fort [11,12,16]. Existing techniques can synthesize only a narrow
range of data structures—those that retrieve a subset of a single
collection.SuchasimpleAPIlimitstheirapplicability,asreal-world
software often has more complex requirements.
For example, the chat server Openfire [ 13] uses a custom in-
memory data structure to represent a many-to-many relationship
between users and groups. This data structure needs to answermany different kinds of queries efficiently, such as which users
belong to a given group or whether any two users share a group. It
alsoneedsto keepitselfup-to-dateasusers andgroupsareadded,
removed,andrenamed.Despiteitscompleximplementation,Open-
fire’s user management code has a simple specification. In general,
data structure specifications are much smaller than their imple-mentations because they do not need to manage memory or be
algorithmically efficient.
Thispaperpresentsanewtechniquefordatastructuresynthesis
that overcomes many of the limitations of previous work. Our tool
Cozy can synthesize implementations for complex multi-collection
datastructures—includingthosefoundinOpenfire—fromhigh-levelspecifications.Likepreviouswork,aCozyspecificationdeclaresthe
abstractstate (whatinformation thedatastructure stores), queries
(methodsthatperformpurecomputationsonthestate),and updates
(methodsthatmodifythestate)thatthedatastructuremustsupport.
Cozythenproducessourcecodethatdeveloperscanuserightaway.
In previous work, implementations for update methods were
hard-coded[ 16]orderivedusingasetofhand-writtenrules[ 11].
In Cozy, update methods are synthesized rather than hardcoded.
ThisenablesCozytodiscovermorespecializeddatarepresentations
thanpreviouswork,sinceCozycanchoosedifferentrepresentations
depending on what kinds of updates appear in the specification.
Our technique iteratively improves the data structure specifica-
tionusingtwocooperatingcomponents:a querysynthesizer that
selects a better representation and implementation for each query
method and an incrementalization step that ensures the new rep-
resentation is kept up-to-date when an update method is called.Crucially,theincrementalizationstepcanproducespecifications
for new query operations to help implement the update procedure.
9582018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:56:18 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden Calvin Loncaric, Michael D. Ernst, and Emina Torlak
q1(…) = impl new
q2(…) = impl
u1(…) = 
    update_s 1; 
    update_s 2; 
    update_s 3;Implementation
q1(…) = impl newSpec
Find an improvement
Implementation
s1 : t1 
s2 : t2
q1(…) = impl= C 1(…) 
= C 2(…)Implementation Implementation
Stop on timeoutConstruct initial 
implementation
Incomplete 
Implementation
s1 : t1 
s2 : t2 
s3 : t3= C 1(…) 
= C 2(…) 
= C 3(…)Implementation
Query 
Synthesis
u1(…) = 
    update_s 1; 
    update_s 2;u1(…) = 
    update_s 1; 
    update_s 2;Incremental-
izationDead code 
eliminations1 : t1 
s2 : t2 
s3 : t3= C 1(…) 
= C 2(…) 
= C 3(…)
u1(…) = 
    update_s 1; 
    update_s 3;s1 : t1 
s3 : t3= C 1(…) 
= C 3(…)
q1(…) = impl new
q2(…) = impl
new code 
uses s 1, s3uses s 1, s2update code 
calls q 2
Figure 1: Architecture of Cozy. Each iteration through the loop performs query synthesis, incrementalization, and dead code
elimination. Figure 2a shows example input, and Figures 2b and 3 show the corresponding output.
Cozythususesthequerysynthesizertoimplementbothpurequeryoperationsandimperativeupdates.Ourtechniqueisagnostictothe
exactimplementationsofthequerysynthesizerandincremental-
ization step;Section 3gives adetailed explanation ofthe concrete
choices we made for Cozy.
Thequerysynthesizerandincrementalizationstepinteractusing
concretization functions. A concretization function expresses a data
structure’srepresentation—itsconcretestate—asafunctionofitsab-stractstate. Forexample,the following concretizationfunction rep-
resents the count of elements in an abstract set S:C(S)=/summationtext.1
x∈S1.
Concretization functions allow Cozy to reason about the effectsof updates in pure mathematical terms. The imperative opera-
tionS.remove( e)—whichremovesaninstanceof efromSifanyis
present—causesachangetothedatarepresentation.Thenewvalue
of the count thus becomes C(S/prime)=C(S−{e})=/summationtext.1
x∈(S−{e})1.
Cozy’s query synthesis step outputs both an efficient implemen-
tationforeachqueryandasetofconcretizationfunctionsindicating
howthedatashouldberepresented.Theincrementalizationstep
thenusestheconcretizationfunctionstoproduceaspecification
ofthechangetotheconcretestateasaresultofeachupdate.For
thecase of S.remove( e),the changespecificationisthe amountby
whichthecountchanges: C(S/prime)−C(S).Thesechangespecifications
are queries over the abstract state of the data structure, and toimplementthemCozyrepeatsthequerysynthesisstep.Thetool
proceeds in this loop until exhausting its time budget—three hours
for our evaluation.
Contributions
•Ahigh-leveldatastructuresynthesisalgorithmwithalter-
nating steps of query synthesis and incrementalization (§2).
•Query synthesis and incrementalization algorithms (§3).
•An implementation, called Cozy (https://cozy.uwplse.org).
•Four real-world case studies that evaluated Cozy’s effect on
development time, correctness, and efficiency (§4).2 OVERVIEW
This section illustrates Cozy’s high-level algorithm using a simpli-
fiedexampleofareal-worlddatastructurefromOpenfire.Thedata
structurethatmanagesusers’contactshasbeenafrequentsourceof
bugs (Section 4.4). Cozy can synthesize a complete implementation
for Openfire’s data structure given its specification.
Cozy uses the algorithm shown in Figure 1. It takes as input
an executable specification of the data structure (Section 2.1), con-
structs an initial implementation (Section 2.2), and then iteratively
improves its implementation using alternating steps of query syn-
thesis (Section 2.3) and incrementalization (Section 2.4). A dead
codeeliminationstep(Section2.5)prunesdeadcodeassynthesis
progresses.
2.1 Specification
Figure2ashowsacompleteCozyspecificationforpartoftheOpen-
fire contact management data structure. It would be used as the
inputtoFigure1.Inthespecification, statedeclarationsdescribe
the abstract state of the data structure, querydeclarations spec-
ify methods that compute values using the abstract state, and op
declarations specify methods that alter the abstract state. Methods
mayalsoincludeassumptions(preconditions)abouttheirinputs.In
somecases,Cozycanproducebetterimplementationsbyleveraging
theseassumptions,buttheyareoptionalforspecificationwriters.
Callers must ensure that the assumptions hold at each call site.
In Openfire, users’ contact lists are implicit and are computed
basedonthegroupsthateachuserbelongsto.Thedatastructure
must be able to efficiently answer the question “should user u1
appear in the contacts of user u2?” for any u1andu2. The query
method visiblein Figure 2a defines this relationship: u1is visi-
ble to (i.e. appears in the contacts of) u2if there exists a group
дof which u1is a member and either дhas been made visible to
everyone ( д.visibility == Everyone )o ru2is also a member of д.
959
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:56:18 UTC from IEEE Xplore.  Restrictions apply. Generalized Data Structure Synthesis ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden
// Abstract state
state users : Set<User>
state groups : Set<Group>
state members : Set<(User, Group)>
// Query definition
query visible( u1,u2:U s e r ) :
assumeu1∈users
assumeu2∈users
return (exists [д|д←groups ,
(u1,д)∈members and (
д.visibility == Everyone or
(u2,д)∈members )] )
// Update operation definition
opjoin(u: User, д: Group):
assumeu∈users
assumeд∈groups
assume (u,д)/nelementmembers
members.add(( u,д))
(a)// Users who are ∈some group whose
// visibility is "Everyone"
state s1: Map<User, Bool>
// Map from users to the groups of// which each one is a member
state s2: Map<User, Bag<Group>>
// Map from (user, group) tuples to// boolean indicating whether that// user is a member of that group
state s3: Map<(User, Group), Bool>
// Now-unused state
state v1 : Set<User>
state v2 : Set<Group>
state v3 : Set<(User, Group)>
// New code
query visible(
u1,u2:U s e r ) :
return (s1[u1]or
exists Filterλд .s3[(u2,д)]s2[u1])
(b)Cs1(users ,groups ,members )=
MakeMap fusers
where
f=λu.exists Filterp(u)members
p(u)=λ(v,д).u==vand
д.visibility == Everyone
Cs2(users ,groups ,members )=
MakeMap дusers
where
д=λu. Filter q(u)members
q(u)=λ(v,д).u==vand
д.visibility /nequalEveryone
Cs3(users ,groups ,members )=
MakeMap λm .true members
Cv1(users ,groups ,members )= users
Cv2(users ,groups ,members )= groups
Cv3(users ,groups ,members )= members
(c)
Figure 2: (a) An example input to Figure 1 that specifies the Openfire user and group management data structure. (b) New
implementation of visibleafter several query synthesis steps. Cozy does not produce the comments, which we added for
clarity. Since incrementalization and dead code elimination have not yet run, the implementation does not properly updatethe new state variables s
1,s2, ands3and still contains some unused state variables. (c) Concretization functions for the new
implementation.
This example has been simplified; our experiments (Section 4) use
a fullspecification ofthe datastructure thatalso includesexplicit
contacts and additional visibility modes for groups.
As specified, visibleruns inO(|groups|×|members|)time. Cozy
createsamoreefficientimplementationfor visible(Figure2b)that
runs inO(д)time, where дis the maximum number of groups that
any one user is a member of.
2.2 Initial Implementation
WheneverCozychoosesadatarepresentation,italsocreates,for
each field in the representation, a concretization function that com-
putes the field’s representation from the abstract state. Since Cozy
specificationsareexecutable,theycanbeconvertedtoimplementa-tions whose concrete state is the same as the abstract state. For the
specification in Figure 2a, Cozy’s initial implementation has the
variables v1,v2, andv3and trivial concretization functions:
Cv1(users ,groups ,members )= users
Cv2(users ,groups ,members )= groups
Cv3(users ,groups ,members )= members
Eachqueryandupdateoperationcanberewrittenintermsof v1,
v2, andv3by simple substitution. The visiblemethod becomes
query visible( u1,u2:U s e r ) :
assumeu1∈v1
assumeu2∈v1
return (exists [д|д←v2,
(u1,д)∈v3and (
д.visibility == Everyone or
(u2,д)∈v3) ])Whilerenamingtheabstractmembersto v1,v2,v3doesnotfunc-
tionally change the specification, it creates initial concretization
functions for later steps to consume.
2.3 Query Synthesis
Cozysynthesizesanimplementationbyiterativelyfindingimprove-
mentstothedatastructure.ThequerysynthesisstepinFigure1
makesanimprovementtosomenon-deterministicallychosenquery
operation on the data structure. Section 3.2 discusses how Cozy
makes the choice and the improvement.
Figure2showsoutputfromoneofthequerysynthesissteps, i.e.,
animprovementtothequery visiblethatusesanewrepresenta-
tion and has associated concretization functions.
Thequerysynthesisstepmayintroducenewstatevariables,but
it does not drop unused ones. In Figure 2, the red state variables s1,
s2,ands3arenew;v1,v2,andv3arenowunused.Thedeadcode
elimination pass will eliminate the unused variables later.
Thenewvariables’concretizationfunctionsaremorecomplex
than the trivial ones introduced for the initial implementation. The
statevariable s1,forinstance,hastheconcretizationfunction Cs1,
whichusestheMakeMapprimitivetoconstructanewmapfrom
users to Booleans. The MakeMap primitive takes a collection of
keys ( users) and a value function ( f) and builds a map where each
keyu∈usersisassociatedwithvalue f(u).Fors1,thevalueistrue
if the user is a member of a group with visibility set to “Everyone”.
InCozy,mapsaretotal.Lookupsonmissingkeysreturnadefault
value: false for booleans, the empty set for sets, and so on. Thus,
960
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:56:18 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden Calvin Loncaric, Michael D. Ernst, and Emina Torlak
opjoin(u: User, д: Group):
join _s1(u,д)
join _s2(u,д)
join _s3(u,д)
join _v1(u,д)
join _v2(u,д)
join _v3(u,д)
private op join _s1(u: User, д: Group):
fork∈altered _keys _s1(u,д):
s1[k] = new _value _for_key_s1(k,u,д)
// The join _s2 and join _s3 implementations have
// been omitted for brevity.
private op join _v1(u: User, д: Group): // no-op
private op join _v2(u: User, д: Group): // no-op
private op join _v3(u: User, д: Group): v3.add(( u,д))
(a)// Find keys of map s1 whose values
// change when user u joins group g.
private query altered _keys _s1(u: User, д: Group):
assumeu∈users
assumeд∈groups
assume (u,д)/nelementmembers
return [k|k←MapKeys( s1)∪MapKeys(s1/prime),
s1[k]/nequals1/prime[k]]
// Compute a new value at key k ∈s1 when user u joins group g.
private query new_value _for_key_s1(k,u: User, д: Group):
assumeu∈users
assumeд∈groups
assume (u,д)/nelementmembers
assume s1[k]/nequals1/prime[k]
return s1/prime[k]
// Sub-queries for s2 and s3 have been omitted for brevity.
(b)
Figure 3: (a) Implementation of the joinupdate operation and (b) new sub-queries that need to be synthesized. The variable
s1/primeis defined as the new value of s1after joinis called: Cs1(users/prime,groups/prime,members/prime).
the expression s1[u1]efficiently determines whether user u1is a
member of a group with visibility set to “Everyone”.
The concretization functions shown in Figure 2c will become
theimplementationoftheconstructorforthedatastructure.The
constructor takes the abstract state as input and initializes the
concrete state. Furthermore, the concretization functions enable
incrementalization.
2.4 Incrementalization
The query synthesis step creates an incorrect data structure: the
newstatevariables s1,s2,ands3arenotkeptup-to-datewhen join
iscalled.Theincrementalizationsteprestorescorrectfunctioning
by adding code to jointhat updates the new state variables. The
new code must preserve the concretization functions in Figure 2c.
Asimplebutinefficientsolutionwouldbetorecomputethevalue
of each concrete state variable from scratch. Because an update
usually makes asmall changeto theabstract state,Cozy produces
anincremental update that makes small changes to the concrete
state in response to a small change to the abstract state.
To incrementally update the concrete state, Cozy rephrases the
update procedure as a set of queries that compute what changesshould take place, plus a simple hardcoded snippet that applies
thosecomputedchanges.Apreviousapproachappliedthissame
idea to synthesize remove operations [ 11], but with concretization
functionsitcanbegeneralizedtoinsertionsandotherupdatesas
well.Ourapproachalsoallowsformorecomplexupdateprocedures
likethosethatapplymultiplechangesatonceoronlymakeachange
under certain conditions.
Figure 3a shows the code that Cozy produces to update the
concretestateasaresultofauserjoiningagroup.Eachconcrete
state variable gets its own update procedure ( e.g.join _s1fors1).
The code for join _s1is not synthesized; it comes from a lookup
table (Section 3.3). However, the new code uses two fresh query
operations altered _keys _s1and new_value _for_key_s1(Figure 3b)
that determine what changes to apply. The former computes theset ofmap keys whose valueschange, and thelatter computes the
new value for each key. These two queries are added to the data
structurespecification,andthustheywillbeoptimizedbythequery
synthesizer on subsequent iterations.
The definitions of the fresh queries make use of both the old
value of s1and the new value s1/prime. The new value is computed
using the specification of joinand the concretization functions.
Mathematically, joinsets the abstract state to
users/prime=users ;groups/prime=groups ;members/prime=members ∪{ (u,д)}
and thus the new value s1/primemust be
s1/prime=Cs1(users/prime,groups/prime,members/prime)=
MakeMap fusers
where
f=λu.exists Filterp(u)(members ∪{ (u,д)})
p(u)=λ(v,д).u==vandд.visibility == Everyone
Figure3bshowsthespecificationsfor altered _keys _s1andnew_-
value _for_key_s1,whichareinefficient.Onlateriterations,Cozy’s
query synthesizer discovers efficient implementations for both.Specifically, Cozy implements
altered _keys _s1to return the sin-
gletonset {u}ifдhasvisibility Everyone anduisnotalreadyinsuch
ag r o u p ,o r ∅otherwise. Cozy implements new_value _for_key_s1
to simply return true.
The implementations of altered _keys _s1and new_value _for_-
key_s1donotrequireadditionalconcretestate.Ingeneral,however,
newconcretestatemightbegeneratedforthefreshqueriesinlater
iterations, requiring another phase of incrementalization.
2.5 Dead Code Elimination
At each iteration, Cozy cleans up unused state variables and opera-
tions. For instance,the state variable v2can be eliminatedsince it
is never read.All code thatkeeps v2up-to-date canbe eliminated
as well. Cozy also deduplicates state variables and fresh queries.
Duplicates happen in cases where the same concrete state is useful
to multiple different query operations.
961
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:56:18 UTC from IEEE Xplore.  Restrictions apply. Generalized Data Structure Synthesis ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden
spec /Colonequalname: specifications
s1,s2,...
invariant e
m1,m2,...
s/Colonequalx:τ abstract state
τ/ColonequalInt|Bool|String basic types
|Enum{case1,case2,...}enumerations
|/angbracketleftτ1,τ2,.../angbracketright tuples
|{f1:τ1,f1:τ2,...} records
|Bag/angbracketleftτ/angbracketright bags (multisets)
m/Colonequalqueryq(args...): queries
assumee;
returne;
|opu(args...): updates
assumee;
stmt;
stmt /Colonequalx←e assignment
|x.add(e) insertion
|x.rm(e) deletion
|ife:stmt conditional
|stmt;stmt sequencing
e/Colonequalx variables
|e==e|e<e|... comparisons
|e∧e|e∨e|¬e bool operations
|e?e:e conditionals
|e+e|e−e arithmetic
|(e,e,...)|e.n tuples
|{f:e,f:e,...}|e.f records
|∅ | {e}|e∪e|e−ebag operations
|Mapfe|Filterfe map and filter
|FlatMapfe map union
|Σe sum
|Distincte remove duplicates
|ArgMinfe|ArgMaxfemin and max
f/Colonequalλx.e lambda abstraction
Figure 4: Core specification language spec.
3 DETAILS
Cozyiterativelyimprovesaspecification(Section3.1)toproduce
an implementation. At each iteration Cozy attempts to find an
improvementtosomequery(Section3.2). Theimprovementmay
require new concrete state, which must be properly maintained in
each update method (Section 3.3). Finally, unused state and code
are removed (Section 3.4).
3.1 Specification and Output Languages
Figure 4 shows the core specification language. All input specifica-
tions are desugared to this core language (Figure 5). Cozy’s output
languageisasupersetofitsinputlanguagethatincludesadditional
constructs for maps:
τ::=Map/angbracketleftτ,τ/angbracketright
e::=MakeMapfe|MapKeys e|e[e]len(X)→ ΣMapλx.1X
empty(X)→len (X)=0
areUnique (X)→X=DistinctX
∀x∈X,p(x)→empty (Filter¬pX)
∃x∈X,p(x)→¬ empty(FilterpX)
x∈X→∃y∈X,y=x
[f(x)|x∈X,p(x)] → MapfFilterpX
[f(x,y)|x∈X,y∈Y]→FlatMapλx.Mapλy .f(x,y)YX
Figure 5: Expressions that Cozy accepts in input specifica-tions but desugars into simpler forms. Cozy supports ar-bitrary list comprehensions, though only two examples ofdesugaring list comprehensions are shown.
Maps could be included in the input language, but they are not
needed: a comprehension can group and look up values in a declar-
ativeratherthanproceduralmanner.Thisclarifieswhateachex-
pression computesand reducesthe numberof invariants thatpro-
grammers need to maintain. In the output language, the MakeMap
primitivetakesanexpression erepresentingthekeysofthemap
and a projection fthat gives the value at each key. MapKeys re-
turnsthekeysofamap.Themapindexoperator e[e]returnsthe
value of a given key in the given map. If the key is not in the map,
this operator returns a default value; e.g.false for booleans and the
empty set for bags.
We plan to extend Cozy with additional primitives for heaps,
trees, and other efficient data structures in the future. For the case
studiesweexamined,maps alonearesufficienttodiscoverefficient
implementations.
3.2 Synthesis
Cozyattemptstosynthesizeabetterimplementationforeachquery
method in the specification, in parallel, with one thread per query.
Astaticcostmodel(Figure6)defines“better.”Wheneverathread
discoversabetterimplementation:(1)Thatimplementationisim-
mediately passed through the incrementalization step, and newqueries it produces get new threads. (2) The whole specificationundergoes dead code elimination, and any old queries that were
eliminated have their threads terminated.
Each threadsynthesizes improvementsfor its query using enu-
merativesynthesis,anoptimizedformofbrute-forcesearch.The
core algorithm described here was pioneered by previous work [ 3,
28,31],butCozyemploysseveralnovelimprovements.Wedescribe
the core algorithm first, followed by our extensions.
Enumerative synthesis explores every possible expression in
Cozy’s output grammar, in order of size from smallest to largest.For each expression, a verifier (e.g. Z3 [
6]) checks whether the
expression satisfies the specification—that is, they always produce
the same result. If so, the expression is emitted. Then the search
continues to look for an even better solution. Since Cozy employs
boundedverification(describedbelow),theverifieralwaysproduces
a result and never times out or returns unknown.
To make the search feasible, Cozy employs equivalence class
deduplication [ 16,31], an optimization that skips most expressions
in the search space. The skipping is done safely so that Cozy never
962
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:56:18 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden Calvin Loncaric, Michael D. Ernst, and Emina Torlak
State Expressions
costS(e)=number of AST nodes in e
Query Expressionscost
Q(e)|eis a state expression =1
costQ(x)=1
costQ(e1ope2)=1+costQ(e1)+costQ(e2)
costQ(Filterpe)=1+costQ(e)+card(e)×costQ(p(x))
(xis a fresh variable)
costQ(Σe)=1+costQ(e)+card(e)
...
Facts About Cardinalities
∀e,card(e)≥0
∀x,card(x)≥1000 (if xis an abstract state variable)
card(∅)=0
card({e})=1
card(e1+e2)=card(e1)+card(e2)
unsat(|e1|>|e2|)→card(e1)≤card(e2)
Partial Order on Costs
sat(c1<c2)∧¬sat(c2<c1)→c1≺c2
(subject to the provable facts about all
cardinalities in formulas c1andc2)
Figure6:Staticcostmodel.InCozy,costsarerepresentedas
symbolic formulas over the cardinalities of various collec-
tions. Cozy uses a solver (sat andunsatfunctions) to order
costs.
misses a solution, if one exists. Equivalence class deduplication
requiresalistofexampleinputs.InCozy,anexampleinputconsists
of values for both the abstract state of the data structure and the
query arguments. The example inputs are produced by the veri-
fier:everytimeanexpressionfailsverification,theverifieryields
a new example input. Cozy caches built expressions. Whenever
two expressions produce the same output on every example, Cozy
consultsastaticcostmodel(describedbelow)todecidewhichto
keep.Inthisway,anexpression’ssetofoutputsontheexamples
puts it in an equivalence class, and only one representative of each
equivalenceclassiscachedatanygiventime.Largerexpressions
are only built out of those that survive this deduplication. Further-
more, Cozy only tries to verify expressions that produce correct
outputoneveryexample,reducingthenumberofcallstothever-
ifier. Since the skipping is so aggressive, the search must restart
everytimeanewexampleisdiscoveredtoensurethatnosolutions
are missed.
Cozyincludesthreenoveladditionstothecoreenumerativesyn-
thesis algorithm: query-time distinction,asymbolic cost model, and
diversityinjection.Additionally,sinceverificationisundecidablefor
our specification language, Cozy uses bounded verification instead
of full functional verification. This technique was also employed
by previous work [26].
Query-Time Distinction. Cozy’s query synthesis algorithm must
solvetwointertwinedproblems:choosingagoodrepresentationforthedataandchoosingagoodalgorithmthatexploitsthatrepresen-tation.Oursolutionistotageachnodeinasynthesizedexpression
as either a state expression or aquery expression. The data structure
stores each state expression as a member and incrementally main-
tains it ateach update operation.A queryexpression is evaluated
each time the query is called.
For instance, an expression to compute the length of a list could
be implemented in several different ways, depending on which
parts are tagged as state expressions:
ΣMapλx.1S
/bracehtipupleft/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehtipdownright/bracehtipdownleft /bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehtipupright
stateorΣMapλx.1S/bracehtipupleft/bracehtipdownright/bracehtipdownleft/bracehtipupright
state.
The first case indicates that the data structure stores the length
ofSasamemberandreturnsthestoredvaluewhenthequeryis
called. The second case indicates that the data structure stores S
as a member and computes the length on-demand. Since these two
expressionsareequivalent,onlythelower-costone—inthiscase,
the first—is kept during deduplication. Cozy’s cost model does not
account for the cost of maintaining the state; instead, that job is
delegated to the sub-queries generated during incrementalization.
Expressions that contain query arguments may not be tagged as
state expressions, since those values will not be available until the
query is executed.
Symbolic Cost Model. Figure 6 shows Cozy’s novel static cost
model.Thecostmodelcomparesstateexpressionsbasedontheir
complexityintermsofthenumberofASTnodes( costS).Itcompares
query-time expressions based on their expected run time (cost Q).
Cozy represents costs as symbolic formulas involving the cardi-
nalitiesofvariouscollections.Forexample,thecostofperformingafilterincludesthecostofevaluatingthepredicateoneveryelement
of the collection being filtered.
To determine the ordering between two costs c1andc2, Cozy
first makes solver calls to establish as many facts as possible about
all the cardinalities (i.e., calls to card) in each expression. Each call
tocardcan then be replaced by a fresh real-type variable. Using
these assumptions, Cozy then makes more solver calls. If there are
caseswhere c1islessthan c2(sat(c1<c2))andnocaseswhere c1
is more than c2(¬sat(c2<c1)), then the expression having cost c1
should always be preferred over the expression having cost c2.
DiversityInjection. Inpractice,theenumerativesynthesisalgo-
rithmmaytakealongtimetodiscovergoodsolutions,especiallyforlanguageslikeourswhereexpressionsizeisnotstronglycorrelated
withcost(thatis,largerexpressionsmayhavelowercost).When
thesyntaxtreeforthebestsolutionisofsizefifteenortwenty,stan-
dardenumerativesynthesismaytakemanycenturiestodiscover
it! For comparison, the syntax tree for the efficient implementation
ofvisiblein Figure 2 requires 45 nodes.
To bias the search toward useful expressions, Cozy employs a
small number of handwritten diversity rules that inject new expres-
sionsintothesearchprocedure.WheneverCozyconsidersanew
candidateexpression,italsoappliestheserulesandconsidersthe
resulting expressions. The diversity rules do not need to be uni-
versallycorrectorefficient:incorrectexpressionswillberejected
bytheverifier,andinefficientexpressionswillberejectedbythe
cost model. However, incorrect expressions are still cached to help
963
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:56:18 UTC from IEEE Xplore.  Restrictions apply. Generalized Data Structure Synthesis ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden
Map Introduction
Filterλx .f(x)=yX→(MakeMap(λk .Filterλx .f(x)=kX)Mapλx .f(x)X)[y]
Cleaners
Filterλx .P1(x)∧P2(x)X→Filterλx .P1(x)Filterλx .P2(x)X
Filterλx .a(x)?b(x):c(x)X→Filterλx .a(x)∧b(x)X+Filterλx .¬a(x)∧c(x)X
Relevant Subset
X,v|vis a state variable →Filterλx .x∈vX
Instantiation
e1,e2|vis free ine1→e1[v/mapsto→e2]
Figure 7: Cozy’s diversity rules.
buildlargerexpressions,astheymightappearassubexpressionsof
correct solutions later on.
Cozy uses the five diversity rules shown in Figure 7. These di-
versityrulesarespecializedtoCozy’sdomainandareintendedto
capturesomeintuitionshumanprogrammersmightapply.“Map
introduction”convertssomelinear-timefilteroperationsintoeffi-
cientmaplookups.“Cleaners”putexpressionsintonormalform,
whichhelpsCozyidentifypotentialmaplookupsonlateriterations.
The“relevantsubset”ruleconvertsacollectionintothesubsetthat
isalreadystoredonthedatastructure.Finally,the“instantiation”
rule helps transfer insights about a variable to insights about other
expressions.Forexample,ifCozyhasdiscoveredtheexpressions
x∈Sandy, theny∈Smight also be important.
Inpractice,Cozy’senumerativesearchmachinerydoesnotfunc-
tion well without the diversity rules and vice-versa. If the diversity
rulesaredisabled,Cozydoesnotfindagoodsolutiontoanyspecifi-
cationforanyofoursubjectprogramswithinathreehourtimeout.SimilarlyifthediversityrulesareappliedwithouttherestofCozy’s
enumerative search machinery, the search quickly runs out of new
expressions and stalls without ever finding a good solution.
Bounded Verification. It is undecidable to determine whether an
expression in Cozy’s language satisfies a specification. Thus, Cozy
employs bounded verification: collection-type variables are limited
to a fixed number of elements. In our experiments, we found a
limitoffourtobesufficienttoensurecorrectsolutions.Thismay
bethankstothe small-scopehypothesis [14],whichproposesthat
most program bugs can be exhibited with small inputs. There issome evidence that the small scope hypothesis is true for simple
programs [4], and we found it to be true in our domain as well.
3.3 Incrementalization
After query synthesis picks a new representation for the data, the
incrementalizationsteprestoresproperfunctioningbyaddingcodetokeepthatrepresentationup-to-dateasthedatastructurechanges.
Cozy’sincrementalize procedureaccomplishesthatgoalbylever-
aging the existing query synthesis procedure.
Injoinfrom Section 2.4, Cozy updated s1using the code
fork∈altered _keys _s1(u,д):
s1[k] = new _value _for_key_s1(k,u,д)
Figure8showstherulesforCozy’s incrementalize procedure.Since
s1has a map type, Cozy uses the update sketch shown in the figure
formaps.Anupdatesketchisasmallsnippetofimperativecode
thatupdatesthevariable.Anupdatesketchmayrequirenewqueryincrementalize (x,Cx):
Input: old abstract state σand new abstract state σ/prime
Output: code to update concrete state x
Type Update Sketch New Queries
Int x←x+q(...) q(...)=Cx(σ/prime)−Cx(σ)
Bagforelem∈q1(...):
x.del(elem)
forelem∈q2(...):
x.add(elem )q1(...)=Cx(σ)−Cx(σ/prime)
q2(...)=Cx(σ/prime)−Cx(σ)
Mapfork∈q(...):
incrementalize (
x[k],
λσ.Cx(σ)[k])q(...)={k|
k∈MapKeys(C x(σ)) ∪
MapKeys(C x(σ/prime)),
Cx(σ)[k]/nequalCx(σ/prime)[k]}
other x←q(...) q(...)=Cx(σ/prime)
Figure 8: Rules for incrementalize (x,Cx).Cxis the concret-
ization function for x. To update a map-type variable,
incrementalize is called recursively to determine how to up-
date the value at each changed key.
operations in order to function. In the case of maps, the update
sketchfindsthekeyswhosevalueshavechangedandupdateseach
one in the map. Cozy introduces the new query altered _keys _s1
to compute which keys have changed.
Sincethevaluesin s1arebooleans,Cozyusesthefallbacksketch
for “other” types to update each value. This rule uses a new query
new_value _for_key_s1tocompute—from scratch—anew valuefor
s1[k].AsdiscussedinSection2.4,thenewvaluefor s1[k]issimply
true. In practice, new queries generated by incrementalize often
have short and efficient implementations.
3.4 Dead Code Elimination
Whenabetterqueryimplementationisfound,somestatevariables
maygounused.Theimperativeoperationsthatkeepthesevariables
up-to-date are unnecessary, as are any queries required only by
thoseimperative operations, andsoforth. Thedeadcodeelimina-
tion procedure is important; it frequently eliminates variables in
this manner as better query solutions are found.
Tocleanupunusedstateandoperations,Cozyusesmark-and-
sweep. User-specified query operations start as roots. Any state
thattheyuseismarkedasrelevant,andcodetoupdatethatstate
isalsomarked.Queriesusedbytheupdatecodearethenmarked,
and so on until fixed point. Finally any unmarked state, queries, or
update code can be safely removed.
3.5 Termination
The query synthesis procedure (Section 3.2)has no formal termina-
tion guarantees, and as a result, neither does Cozy itself. But since
the input specification is executable, Cozy always has a correct
solution and the synthesis process can be stopped at any time. Our
experiments used a fixed timeout of three hours for synthesis.
964
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:56:18 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden Calvin Loncaric, Michael D. Ernst, and Emina Torlak
4 EVALUATION
Cozyhasthreegoals:toreduceprogrammereffort,toproducebug-
free code, and to match the performance of handwritten code. We
foundthatusingCozyrequiresanorderofmagnitudefewerlinesof
codethanmanualimplementation(Section4.3),makesnomistakesevenwhenhumanprogrammersdo(Section4.4),andoftenmatches
the performance of handwritten code (Section 4.5).
4.1 Methodology
For each of four real-world programs (Section 4.2), we
(1)identifiedanimportant,complex,handwrittendatastructure,
(2) manually wrote a Cozy specification,(3) allowed Cozya three-hourtimeout tosynthesize anewim-
plementation, and
(4) replaced the original data structure by the synthesized one.
Replacing handwritten code with Cozy-synthesized code required
somelightrefactoringineachprogram.Forexample,someprogram-mersintertwinedatastructurecodewithI/Ocode.Wedisentangled
these, because Cozy does not synthesize I/O code. This refactoring
wasonlynecessarybecausetheseprojectsdidnotuseCozyfrom
day one. Furthermore, we believe it results in better code style and
easier-to-understand abstractions.
Weranourexperimentsonamachinewith96coresand512Gbof
memory.Cozyspawnsonethreadforeachqueryinthespecification
andrunsfastestonamachinewithatleastthatmanycores,butdoes
not require it. The Openfire specification, our largest, has 12 query
operations,thusrequiring12coresforfastestoperation.Memory
usage steadily climbs the longer Cozy runs; we have observed it
reach 32 Gb in the worst case.
The three hour synthesis time does not slow down the edit-
compile-testcycle.SinceCozyspecificationsareexecutable,they
canbeimmediatelytranslatedintousablebutinefficientcode.Devel-
operscancodeandtestagainsttheslowversiontogainconfidence
in their specification before running the full synthesizer. We made
use of this feature while writing specifications in our evaluation.
4.2 Subject Programs
ZTopo [32] is a topological map viewer implemented in C++. Its
cacheofmaptilesasynchronouslyloadsmaptilesoverthenetworkandcachesthemondiskorinmemory.Thecacheenablesanyother
part of the program to query for information about a given map
tile. ZTopo was also a target for previous data structure synthesis
work[11,16].Cozyisalsoabletosynthesizetwopartsofthecache
thatpreviousworkcouldnot.First,Cozycansynthesizethecode
thataccountsforthetotaldiskandmemoryusageofcachedmap
tiles. Second, Cozy synthesizes a key operation to look up a single
elementbyitsuniqueidentifier.Previoustoolsimplementedthis
operation inefficiently by checking whether a computed collection
of results contained a single element or not.
Sat4j[17]is aBoolean satisfiabilitysolver implementedinJava.
Itsvariablestoretracks,amongotherthings,whenaguesswaslastmade about a variable’s value and whether any listeners are watch-
ing that variable’s state. Sat4j was also a target for previous data
structure synthesiswork [ 16]. As with ZTopo, Cozy’ssynthesized
implementation of the Sat4j data structure is a closer match to the
original than previous tools, requiring less wrapper code.Table 1: Programmer effort. LoC measurements do not in-
clude comments or whitespace.
Hand-written Cozy
Project Span Commits LoC LoC
ZTopo 1 week 15 1024 41
Sat4j 8 years 22 195 42
Openfire 10 years 47 1992 157
Lucene 13 years 20 68 36
Openfire [ 13] is a large, scalable IRC server implemented in
Java. Its in-memory contact manager is extremely complex. Users’
contacts can be either explicit (added by users manually) or im-
plicit (present due to users’ group memberships). Furthermore, the
contact manager must keep its state in sync with the underlying
database as users and groups are created, modified, and deleted.
Thislogichasbeenafrequentsourceofbugs[ 30].Openfire’sim-
plicitcontactsrequirecomputinginformationabouttwodistinct
collections (users and groups), and thus cannot be handled by any
previous tool.
Lucene [29] is a search engine back end implemented in Java.
Lucene uses a custom data structure that consumes a stream of
words and aggregates key statistics about them. The data structure
has an addmethod that is called once for each token instead of
gettingthetokensasonebiglist.Thelogicforhandlingeachtoken
is tricky since the data structure needs to to be queryable between
callstoits addmethod.Cozyhelpsavoidthelogicinthe addmethod
by having a clean specification that describes the abstract state as
a bag of tokens and descriptions of the queries that matter.
4.3 Programmer Effort
Wedonotknowhowmuchtimeprogrammersspentimplement-
ing and debugging the hand-written data structures, but it was
significant. Table 1 shows the size of each implementation, in non-
commentnon-blanklinesofcode.Italsoreportshowmanycommits
contributed to the currentversion of the data structureimplemen-
tation,andacrosshowmuchtimethosecommitsweremade.The
longtimeperiodsarebecauseSat4j,Openfire,andLucenearees-
tablishedprojectsandstillundergoingactivemaintenance.Inall
three,however,bugfixeshavebeenmadetothedatastructurein
thelastfivecommits,indicatingthatfullfunctionalcorrectnesshas
been difficult to achieve.
The Cozy specifications are an order of magnitude shorter than
themanualimplementations.Mostofourtimewasspentreverse-
engineeringtounderstandtheundocumentedexistingimplementa-tion;onceweunderstoodit,writingthespecificationwasquick.Forexample,writing,integrating,andtestingtheZTopoandSat4jspec-
ificationstooklessthanadayeach.TheOpenfirerostermanager
wasmorechallengingbecausewehadtofirstformalizetheimplicit
contacts function, a task the developers never carried out. We
alreadyunderstoodtheCozyspecificationlanguage(Section3.1),
but we believe that a programmer could learn it more quickly than
it took us to reverse-engineer any one of the programs.
Becausethespecificationsareshorter,simpler,andmoreabstract,
they are much easier to understand. Programmers writing speci-
ficationsarethereforelesslikelytomakemistakes,andmistakes
965
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:56:18 UTC from IEEE Xplore.  Restrictions apply. Generalized Data Structure Synthesis ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden
Table 2: Correctness results. ZTopo has no dedicated issue
tracker.
Project Issues New defects found
ZTopo n/a No
Sat4j 7 No
Openfire 25 Yes
Lucene 1 No
will be easier to discover, diagnose, and correct. The specifications
also serve as concise, unambiguous documentation.
4.4 Correctness
Cozy might produce an incorrect data structure because of its use
ofboundedverification.Wealsomighthavemadeanerrorwhen
writingthespecification.TocheckthecorrectnessoftheCozy-syn-
thesizeddatastructures,weensuredthatalltestsineachprojectstill
pass.ZTopo,Openfire,andLucenehavenoteststhatcoverthedata
structurewe replaced.Fortheseprojects weverifiedthatour syn-
thesizeddatastructurebehavesidenticallytotheoriginalimplemen-
tation during execution of the benchmarks we used in Section 4.5.
Table 2 lists how many data-structure-related issues in each
project’s respective issue tracker might have been prevented by
Cozy.Mostissuesrelatetodefectiveupdatecodeputtingthedata
structureinabadstate.Cozyisperfectlypositionedtopreventthosedefects: changes to a data structure’s abstract state are much easier
to specify than the code that updates an optimized representation.
We now discuss some of these issues.
Sat4j’s variable metadata storage has suffered both performance
andfunctionalcorrectnessissuesinthepastthatCozyavoids.Today
Sat4jhasatest suitethatachieves89%statementcoverageonthe
datastructurewereplaced,andCozy’ssynthesizedimplementation
passes all tests.
OfSat4j’ssevenreportedissues,fiverelatetoupdatecode.Sat4j’s
datastructureincludesseveralarraysofdatathatgrowexponen-
tiallyasentriesareadded,andthelogictogrowthemandkeepthecapacityinformationup-to-dateprovedtrickytogetright.Thedata
structure also supports a reset()method to clear all of its internal
state, but developers did not properly revise its implementation
when they introduced new state variables. Cozy can prevent these
kindsofproblemssincetheprogrammerdoesnotneedtomaintain
the concrete representation.
Openfire,having amore complexdatastructure, hasbeen even
more difficult to get right. Section 2 presented only a simplified
portion of the Openfire roster manager specification. The full spec-
ification has additional rules and visibility modes for groups. In
particular,auser u1isvisibletoauser u2ifanyoneoffourdifferent
conditions aremet: (1)the usershave addedeach otheras explicit
contacts,(2) u1isinagroupwithvisibilitysetto Everyone,(3)both
users share a group with visibility set to OnlyGroup ,o r( 4 )u1is in a
groupдAwith visibility set to OnlyGroup andu2is a member of a
groupдBconfigured to have visibility onto дA.
This definition gives rise to two kinds of roster items: explicit
itemsduetocondition1andimplicititemsduetoconditions2–4.
Themanuallywrittenimplementationmakesatrade-off:allexplicit
items plus implicit items due to conditions 2 and 3 are held asTable 3: Performance results. All times are in seconds.
Project Time (orig.) Time (Cozy)
ZTopo 5 5
Sat4j 53 61
Openfire 16 15
Lucene 9 9
concreteobjectsinmemory,butimplicititemsduetocondition4are
constructedon-demandtosavememory.Developershadtowrite
a large amountof code tokeep the implicit contactscorrect when
groupschange visibility orwhen groupmembershipchanges. Thatcodehasbeenafrequentsourceofdefects,andstillhasopenissues.
For example, one issue still open at time of writing reports that
whenadministratorsdeleteauserwithoutfirstmanuallyremoving
herfromallofhergroups,sheremainsinotherusers’contactlists.1
Otherissueswerecausedbythestoredstateoftherostergetting
out-of-syncwiththeabstractstateoftheroster.Bycontrast,aCozyprogrammerdoesnotneedtowritetheupdatecode;Cozydiscovers
its own data representation and determines how to update it in
response to changes.
Additionally, we discovered multiple new failures while replac-
ing the original implementation.2For example, the original imple-
mentationmakesitpossibletocreateasituationinwhichtwousers
see different views of the roster: according to one user, both are
visible to each other, while according to another, there is only a
one-wayvisibility.Thesynthesizedimplementationdoesnotsuf-
ferfromtheseproblems.Wedonotknowhowmanysourcecode
defects contribute to the observed failures.
Even Lucene’s small data structure has been a source of defects.
Overlapping words caused some of its internal statistics to become
corrupted because the original developers did not foresee this pos-
sibility. Our Cozy implementation handles this case gracefully; the
naturalwaytospecifyLucene’soperationsdoesnothavethedefect.
4.5 Performance
We measured the performance of the handwritten and synthesized
implementationsonrealisticworkloads.Table3reportsthewall-
clock time required to run each benchmark to completion. Thebenchmarks are end-to-end, and include application behavior inaddition to the data structure itself; the resulting time, therefore,
representstheoveralleffectoneachprogramfromusingthesyn-
thesized data structure.
Our benchmarks for ZTopo and Sat4j are the same ones used to
evaluateanearlieriterationofCozy[ 16].TheZTopobenchmark
is a log of recorded application usage that we replay. The Cozy-synthesizedimplementationoftheZTopotilecachematchesthe
performance of the existing implementation almost exactly. The
handwritten and synthesized implementations are conceptually
identical:bothstoremaptilesinlinkedlistsgroupedbytiletype.
The dominant factor affecting performance is the speedof finding
tiles by unique ID, which both implementations do using a hash
table.
1https://issues.igniterealtime.org/browse/OF-1121
2https://community.igniterealtime.org/thread/60317
966
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:56:18 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden Calvin Loncaric, Michael D. Ernst, and Emina Torlak
Sat4j’s benchmark suite consists of eleven randomly-selected in-
putfilesfromthe2002booleansatisfiabilitysolvercompetition[ 18,
22]. The synthesized data structure for Sat4j under-performs the
existingimplementation.Thehandwrittencodeexploitssomefacts
about the data that Cozy does not know: in Sat4j, variable IDs can
beusedasindexesintoanarraysincetheyalwaysfallbetweenzero
andaknownmaximumbound.ThisinteractspoorlywithCozy’s
total semantics for map lookups. At code generation time, Cozy
mustinsertsafetychecksateverymaplookup.InSat4jthosesafety
checks are unnecessary and harm performance substantially.
OurbenchmarkforOpenfireisareplayedsequenceofactions
against its admin panel that offers direct access to the internal
roster data structure, where users, groups, and explicit contacts
can be modified. The synthesized structure improves performance
slightly.Thereareseveralcontributingfactors,butthedominant
one is that the synthesized data structure can avoid a number of
expensive internal representation checks. To improve correctness,
thehandwrittenimplementationwilloftencleanupitsownstate,
whichimposessomeoverhead.Bygeneratingcorrectcode,Cozy
avoids these internal checks.
Our benchmark for Lucene is a series of operations on artificial
data.Cozy’ssynthesizeddatastructureforLuceneisverysimilar
to the manually written one, leading to identical performance.
5 RELATED WORK
Thedatastructuresynthesisproblemdatestothe1970sand iterator
inversion,atechniqueforconstructingdatastructurestoacceler-ate iterative operations [
9,10]. Our syntax for queries is similar
to that found in Earley’s work, although our techniques are sub-
stantially more powerful. Iterator inversion required handwritten
rewrite rules, while Cozy’s exhaustive search discovers complex
transformations unaided.
The developers of the SETL language took a different approach
bysplittingitintoa purelanguageanda representationsub-language.
Thesub-languagespecifieswhatstructurestousewhenrunning
pure code [ 8,19,20]. More recently, researchers have investigated
dynamictechniquestoachievethesameeffect[ 21].Beyondsimply
choosing better existing implementations of an interface, Cozy can
implementmorecomplexinterfacesthatrequirecomposingdata
structure representations.
Modernprogramsynthesistechniqueshavebeenappliedtolow-
leveldatastructurecode[ 23,27].Thesetechniquescanhelptowrite
pointer and array manipulationsbut, unlike our work, require the
programmer to choose a data representation in advance.
More recently, researchers have made headway on synthesizing
completedatastructures.RelC[ 11]constructsdatastructureimple-
mentations that track subsets of a collection. It was later extended
to produce safe concurrent data structures [ 12]. An earlier version
ofCozy[16]usedacustom“outlinelanguage”todescribedatastruc-
ture implementations and was able to synthesize data structures
withricherspecificationsthanRelC.Bygeneralizingtoarbitrary
expressionsandconcretizationfunctions,Cozycannowsynthesizeafarwiderclassofdatastructures,includingthedatastructuresfor
OpenfireandLucenethatrequiremultiplerelatedcollectionsand
aggregationoperators.Togainthisexpressivenesswehavegiven
up decidability, relying instead on bounded verification.RelC and earlier versions of Cozy hada tuning step that used a
user-supplied benchmark to make low-level optimizations. Cozy
no longerhasthis step.Its effectivenesswas neverfully evaluated
andourpowerfulsymboliccostmodelnowfillstherole.Somedata
structures that Cozy originally supported have also been dropped.
These were not necessary for the case studies we explored, but we
plan to reimplement them to extend Cozy’s applicability.
Cozy’shigh-levelalgorithmresembles programmingbyrefine-
ment(PBR),inwhichprogramsareproducedbymanualiterative
modificationstoaninitialspecification.UnlikePBRtoolssuchas
KIDS [24], Designware [ 25], and Fiat [ 7], each refinement iteration
that Cozy makes may bear little resemblance to the implementa-
tionbeforeit.ThisisbecauseCozyenumeratespossiblesolutions
in a fixed order rather than transforming the input specification.
Furthermore,Cozyrequiresnomanualeffortbeyondwritingaspec-
ification. The cost of this simplicity is that Cozy cannot produce
many of the more complicated algorithms derived by PBR systems.
However,Cozycanautomatepartsofthejob,specificallythe“finite
differencing” and “data type refinement” tasks [24].
The transformations that Cozy performs are akin to the index
selectionandviewmaintenance problemsindatabasesystems.Index
selection is the task of choosing useful indexes to speed up desired
queries.AutoAdmin[ 1,5]solvestheproblembyenumeratingmany
possibleindexesandusingaqueryplannertodecidewhichwork
best.Asaresult,AutoAdminislimitedbythesetofoptimization
rules available to the query planner.
Viewmaintenanceistheproblemofkeepinganindexormaterial-
izedviewup-to-dateasthedatachanges.Materializedviewsaresim-
ilar to Cozy’s concretization functions: they can be computed from
the original state of the database. DBToaster [ 2] implements a very
efficientviewmaintenancesystem.Morerecently,thesameteam
has worked on generalizing these ideas to collections, including
nestedcollections[ 15].Whileit ispossibletoaugment Cozywith
thesetechniques,Cozy’senumerativesynthesizergenerallydiscov-ersthosesamesolutionswithouttheneedformanualrewriterules.
6 CONCLUSION
Cozyiseffectivebecauseincrementalizationallowsittoimplement
both pure and imperative operations using only a query synthe-
sizer. A high-quality cost function and diversity injection make the
query synthesizer powerful and practical. As a result, Cozy does
not need clever analyses or transformation rules. Our case studies
demonstrate that data structure synthesis can improve software
development time, correctness, and efficiency.
Acknowledgments
DavidGrantassistedwiththeCozyimplementationandtheLucenecasestudy.
This material is based upon work supported by the United States Air Force un-
derContractNo.FA8750-15-C-0010,andonresearchsponsoredbyAirForceRe-
searchLaboratoryandDARPAunderagreementnumberFA8750-16-2-0032.TheU.S.GovernmentisauthorizedtoreproduceanddistributereprintsforGovern-
mental purposes notwithstanding any copyright notation thereon. This work
is supported in part by NSF grant CCF-1651225, and the Intel and NSF jointresearch centerfor Computer AssistedProgramming forHeterogeneous Archi-
tectures (CAPA).
967
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:56:18 UTC from IEEE Xplore.  Restrictions apply. Generalized Data Structure Synthesis ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden
REFERENCES
[1]SanjayAgrawal,SurajitChaudhuri,andVivekR.Narasayya.2000. Automated
Selection of Materialized Views and Indexes in SQL Databases. In Proceedings of
the26thInternationalConferenceonVeryLargeDataBases(VLDB’00).Morgan
Kaufmann Publishers Inc., San Francisco, CA, USA, 496–505. http://dl.acm.org/
citation.cfm?id=645926.671701
[2]Yanif Ahmad, Oliver Kennedy, Christoph Koch, and Milos Nikolic. 2012.
DBToaster: Higher-order Delta Processing for Dynamic, Frequently Fresh Views.
Proceedings of the VLDB Endowment 5, 10 (June 2012), 968–979. DOI:http:
//dx.doi.org/10.14778/2336664.2336670
[3]Rajeev Alur, Rastislav Bodík, Garvit Juniwal, Milo M. K. Martin, Mukund
Raghothaman, Sanjit A. Seshia, Rishabh Singh, Armando Solar-Lezama, Em-ina Torlak, and Abhishek Udupa. 2013. Syntax-Guided Synthesis. In Formal
Methods in Computer-Aided Design (FMCAD ’13). IEEE, 1–8. http://ieeexplore.
ieee.org/document/6679385/
[4]Alexandr Andoni, Dumitru Daniliuc, and Sarfraz Khurshid. 2003. Evaluating the
“Small Scope Hypothesis”. Technical Report. MIT.
[5]SurajitChaudhuriandVivekR.Narasayya.1997. AnEfficientCost-DrivenIndex
Selection Tool for Microsoft SQL Server. In Proceedings of the 23rd International
ConferenceonVeryLargeDataBases(VLDB’97).MorganKaufmannPublishers
Inc., San Francisco, CA, USA, 146–155. http://dl.acm.org/citation.cfm?id=645923.
673646
[6]Leonardo De Moura and Nikolaj Bjørner. 2008. Z3: An Efficient SMT Solver.InProceedings of the Theory and Practice of Software, 14th International Con-
ference on Tools and Algorithms for the Construction and Analysis of Systems
(TACAS/ETAPS ’08). Springer-Verlag, Berlin, Heidelberg, 337–340.
DOI:http:
//dx.doi.org/10.1007/978-3-540-78800-3_24
[7]Benjamin Delaware, Clément Pit-Claudel, Jason Gross, and Adam Chlipala. 2015.
Fiat: Deductive Synthesis of Abstract Data Types in a Proof Assistant. In Pro-
ceedingsofthe42ndAnnualACMSIGPLAN-SIGACTSymposiumonPrinciplesof
ProgrammingLanguages(POPL’15).ACM,NewYork,NY,USA,689–700. DOI:
http://dx.doi.org/10.1145/2676726.2677006
[8]RobertB.K.Dewar,ArthurGrand,Ssu-ChengLiu,JacobT.Schwartz,andEdmond
Schonberg. 1979. Programming by Refinement, As Exemplified by the SETL
Representation Sublanguage. ACM Transactions on Programming Languages and
Systems1, 1 (Jan. 1979), 27–49. DOI:http://dx.doi.org/10.1145/357062.357064
[9]Jay Earley. 1973. Relational Level Data Structures for Programming Lan-
guages.Acta Informatica 2, 4 (Dec. 1973), 293–309. DOI:http://dx.doi.org/10.
1007/BF00289502
[10]JayEarley.1975. HighLevelIteratorsandaMethodforAutomaticallyDesigning
Data Structure Representation. Computer Languages 1, 4 (Jan. 1975), 321–342.
DOI:http://dx.doi.org/10.1016/0096-0551(75)90019-3
[11]Peter Hawkins, Alex Aiken, Kathleen Fisher, Martin Rinard, and Mooly Sagiv.
2011. DataRepresentationSynthesis.In Proceedingsofthe32ndACMSIGPLAN
ConferenceonProgrammingLanguageDesignandImplementation(PLDI’11).ACM,
New York, NY, USA, 38–49. DOI:http://dx.doi.org/10.1145/1993498.1993504
[12]Peter Hawkins, Alex Aiken, Kathleen Fisher, Martin Rinard, and Mooly Sagiv.
2012. Concurrent Data Representation Synthesis. In Proceedings of the 33rd
ACMSIGPLANConferenceonProgrammingLanguageDesignandImplementation
(PLDI’12).ACM,NewYork,NY,USA,417–428. DOI:http://dx.doi.org/10.1145/
2254064.2254114
[13]Ignite Realtime. 2016. Openfire real time collaboration server. (2016). https:
//www.igniterealtime.org/projects/openfire/ (Retrieved March 28, 2017).
[14]Daniel Jackson and Craig Damon. 1996. Elements of Style: Analyzing a Software
DesignFeaturewithaCounterexampleDetector.In ISSTA.239–249. DOI:http:
//dx.doi.org/10.1145/229000.226322
[15]ChristophKoch,DanielLupei,andValTannen.2016. IncrementalViewMain-
tenanceForCollectionProgramming.In Proceedingsofthe35thACMSIGMOD-
SIGACT-SIGAI Symposium on Principles of Database Systems (PODS ’16). ACM,New York, NY, USA, 75–90. DOI:http://dx.doi.org/10.1145/2902251.2902286
[16]CalvinLoncaric,EminaTorlak,andMichaelD.Ernst.2016. FastSynthesisofFast
Collections.In Proceedingsofthe37thACMSIGPLANConferenceonProgramming
Language Design and Implementation (PLDI ’16). ACM, New York, NY, USA,
355–368. DOI:http://dx.doi.org/10.1145/2908080.2908122
[17]Sat4j 2016. Sat4j Boolean Reasoning Library. (2016). https://www.sat4j.org
(Retrieved February 3, 2016).
[18]SatCompetition2002 2002. SAT Competition 2002. (2002). http://www.
satcompetition.org/2002/ (Retrieved February 3, 2016).
[19]EdmondSchonberg,JacobT.Schwartz,andMichaSharir.1981. AnAutomatic
Technique for Selection of Data Representations in SETL Programs. ACM Trans-
actions on Programming Languages and Systems 3, 2 (April 1981), 126–143. DOI:
http://dx.doi.org/10.1145/357133.357135
[20]Jacob T. Schwartz. 1975. Automatic Data Structure Choice in a Language of
Very High Level. In Proceedings of the 2nd ACM SIGACT-SIGPLAN Symposium
onPrinciplesofProgrammingLanguages(POPL’75).ACM,NewYork,NY,USA,
36–40. DOI:http://dx.doi.org/10.1145/512976.512981
[21]Ohad Shacham, Martin Vechev, and Eran Yahav. 2009. Chameleon: Adaptive
Selection of Collections. In Proceedings of the 2009 ACM SIGPLAN Conference on
ProgrammingLanguageDesignandImplementation(PLDI’09).ACM,NewYork,
NY, USA, 408–418. DOI:http://dx.doi.org/10.1145/1542476.1542522
[22]LaureSimon,DanielLeBerre,andEdwardA.Hirsch.2005. TheSAT2002Compe-
tition.AnnalsofMathematicsandArtificialIntelligence 43,1(1Jan.2005),307–342.
DOI:http://dx.doi.org/10.1007/s10472-005-0424-6
[23]RishabhSinghandArmandoSolar-Lezama.2011. SynthesizingDataStructure
ManipulationsfromStoryboards.In Proceedingsofthe19thJointMeetingofthe
European Software Engineering Conference and the ACM SIGSOFT Symposium on
The Foundations of Software Engineering (ESEC/FSE ’11). ACM, New York, NY,
USA, 289–299. DOI:http://dx.doi.org/10.1145/2025113.2025153
[24]Douglas R. Smith. 1990. KIDS: A Semiautomatic Program Development System.
IEEE Transactions on Software Engineering 16, 9 (Sept. 1990), 1024–1043. DOI:
http://dx.doi.org/10.1109/32.58788
[25]Douglas R. Smith. 1999. Designware: Software Development by Refinement.
Electronic Notesin TheoreticalComputer Science 29 (Dec.1999), 275– 287. DOI:
http://dx.doi.org/10.1016/S1571-0661(05)80320-2
[26]ArmandoSolar-Lezama.2008. ProgramSynthesisbySketching. Ph.D.Dissertation.
University of CA at Berkeley, Berkeley, CA, USA. Advisor(s) Bodík, Rastislav.
AAI3353225.
[27]Armando Solar-Lezama, Christopher Grant Jones, and Rastislav Bodík. 2008.
Sketching Concurrent Data Structures. In Proceedings of the 29th ACM SIGPLAN
ConferenceonProgrammingLanguageDesignandImplementation(PLDI’08).ACM,
New York, NY, USA, 136–148. DOI:http://dx.doi.org/10.1145/1375581.1375599
[28]Armando Solar-Lezama, LiviuTancau, Rastislav Bodík, Sanjit Seshia,and Vijay
Saraswat. 2006. Combinatorial Sketching for Finite Programs. Operating Sys-
temsReview 40,5(Oct.2006),404–415. DOI:http://dx.doi.org/10.1145/1168917.
1168907
[29]The ApacheSoftware Foundation. 2016. Apache Lucene. (2016). https://lucene.
apache.org.
[30]John Toman and Dan Grossman. 2016. Staccato: A Bug Finder for DynamicConfiguration Updates. In 30th European Conference on Object-Oriented Pro-
gramming (ECOOP ’16). Schloss Dagstuhl, Dagstuhl, Germany, 24:1–24:25. DOI:
http://dx.doi.org/10.4230/LIPIcs.ECOOP.2016.24
[31]AbhishekUdupa,ArunRaghavan,JyotirmoyV.Deshmukh,SelaMador-Haim,
MiloM. K.Martin,and RajeevAlur.2013. TRANSIT: SpecifyingProtocolswith
ConcolicSnippets.In Proceedingsofthe34thACMSIGPLANConferenceonPro-
gramming Language Design and Implementation (PLDI ’13). ACM, New York, NY,
USA, 287–296. DOI:http://dx.doi.org/10.1145/2491956.2462174
[32]ZTopo2015. ZTopoTopographicMapViewer. (2015). https://hawkinsp.github.
io/ZTopo/ (Retrieved May 8, 2015).
968
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:56:18 UTC from IEEE Xplore.  Restrictions apply. 