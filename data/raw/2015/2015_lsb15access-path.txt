Access-Path Abstraction: Scaling Field-Sensitive
Data-Flow Analysis With Unbounded Access Paths
Johannes Lerch‚àó, Johannes Sp ¬®ath‚Ä†, Eric Bodden‚àó‚Ä†and Mira Mezini‚àó‚Ä°
‚àóTechnische Universit ¬®at Darmstadt,‚Ä†Fraunhofer SIT,‚Ä°Lancaster University
‚àó‚Ä†Darmstadt, Germany,‚Ä°Lancaster, United Kingdom
‚àóflastname g@cs.tu-darmstadt.de,‚Ä†fÔ¨Årstname.lastname g@sit.fraunhofer.de
Abstract ‚ÄîPrecise data-Ô¨Çow analyses frequently model Ô¨Åeld
accesses through access paths with varying length. While us-
ing longer access paths increases precision, their size must be
bounded to assure termination, and should anyway be small to
enable a scalable analysis.
We present Access-Path Abstraction, which for the Ô¨Årst
time combines efÔ¨Åciency with maximal precision. At control-Ô¨Çow
merge points Access-Path Abstraction represents all those access
paths that are rooted at the same base variable through this base
variable only. The full access paths are reconstructed on demand
where required. This makes it unnecessary to bound access paths
to a Ô¨Åxed maximal length.
Experiments with Stanford SecuriBench and the Java Class
Library compare our open-source implementation against a
Ô¨Åeld-based approach and against a Ô¨Åeld-sensitive approach that
uses bounded access paths. The results show that the proposed
approach scales as well as a Ô¨Åeld-based approach, whereas the
approach using bounded access paths runs out of memory.
I. I NTRODUCTION
Static program analyses and especially data-Ô¨Çow analyses
usually have to consider values being assigned to and read
from local variables and Ô¨Åelds. While local variables are often
simple to track, the systematic handling of Ô¨Åelds can be complex.
Techniques for modeling Ô¨Åelds can be distinguished into Ô¨Åeld-
based and Ô¨Åeld-sensitive approaches. Field-based techniques
model a Ô¨Åeld access a.f simply by the Ô¨Åeld‚Äôs name f, plus
potentially its declaring type‚Äîa coarse grain approach that
ignores the base object a‚Äôs identity. Field-sensitive techniques,
on the other hand, include the base variable ain the static
abstraction, potentially increasing analysis precision as Ô¨Åelds
belonging to different base objects can be distinguished.
While many existing analyses restrict their Ô¨Åeld-sensitivity
to a single level, more precise analyses represent static infor-
mation through entire access paths ‚Äì a base variable followed
by a Ô¨Ånite sequence of Ô¨Åeld accesses [1]‚Äì[3]. For instance,
assume a taint analysis determining whether (and where) the
example shown in Figure 1a might print the password. Here the
analysis must distinguish access paths of length k‚â•2(kis the
maximal length of the Ô¨Ånite sequence) to determine that a leak
can occur only at the Ô¨Årst print statement. While the use of
access paths can increase precision, one must generally bound
kto a Ô¨Ånite maximum, as otherwise loops or recursive data
structures such as linked lists might cause abstractions such as
l.next.prev.next... to grow indeÔ¨Ånitely, which would
cause the analysis not to terminate.
A common approach to deal with inÔ¨Ånite chains of Ô¨Åeld
accesses is k-limiting [4], which includes in the abstractiononly the Ô¨Årst knested Ô¨Åeld accesses, abstracting from all
others. If Ô¨Åelds are read, the analyses frequently assume that
any Ô¨Åeld accessible beyond the Ô¨Årst kÔ¨Åelds may relate to
the tracked information. Hence, k-limiting introduces an over-
approximation that becomes less precise for smaller values of k.
In contrast, a high kvalue means the analysis will distinguish
more states. In this work, we present experiments, which show
that analyses can run out of gigabytes of main memory when
analyzing real-world programs even with small kvalues.
To address the problems raised above, we present Access-
Path Abstraction, a novel and generic approach for handling
Ô¨Åeld-sensitive analysis abstractions without the need for k-
limiting . To keep access paths Ô¨Ånite and small, at control-
Ô¨Çow merge points Access-Path Abstraction represents all those
access paths that are rooted at the same base variable through
this base variable only. In a summary-based inter-procedural
analysis this leads to fewer and yet highly reusable summaries,
which can speed up the analysis signiÔ¨Åcantly: A procedure
summary for a base object acan represent information for all
access paths rooted in a. To maintain the precision of Ô¨Åeld-
sensitive analyses, Access-Path Abstraction reconstructs the
full access paths on demand where required.
We present Access-Path Abstraction as a novel extension to
the IFDS framework for inter-procedural Ô¨Ånite distributive sub-
set problems [5] and hereafter use IFDS-APA as an acronym
for this extension. We provide an open-source implementation
on top of the IFDS/IDE solver Heros [6].1
In experiments using Stanford SecuriBench and the Java
Class Library as benchmarks, we compare IFDS-APA against
a Ô¨Åeld-based approach and against a Ô¨Åeld-sensitive approach
usingk-limiting, both in terms of scalability and analysis time.
The results show that IFDS-APA scales as well as a Ô¨Åeld-based
approach, whereas a Ô¨Åeld-sensitive approach using k-limiting
runs out of memory.
To recap, this work presents the following original contri-
butions:
‚óè a novel extension to the IFDS framework enabling
scalable and precise Ô¨Åeld-sensitive analysis without the
need fork-limiting,
‚óè a full open-source implementation, and
‚óè extensive experiments comparing the performance of
the proposed approach to a Ô¨Åeld-based and a Ô¨Åeld-
sensitive approach with k-limiting.
1Heros is hosted on GitHub: https://github.com/sable/heros Our implemen-
tation is available there.a.g = password();
b.f = a;
print(b.f.g);
print(b.f.h);
(a)x = source();
A a1 = new A();
A a2 = new A();
a1.f = x;
y = a2.f;
sink(y);
(b)
Fig. 1: Precision of Field-Based and Field-Sensitive Models
The remainder of this paper is structured as follows. In
Section II we give a short summary of the IFDS framework,
while Section III explains common ways to model Ô¨Åeld accesses.
In Section IV we describe our changes and extensions to the
IFDS framework. Section V covers the evaluation, while we
discuss related work in Section VI and conclude in Section VII.
II. B ACKGROUND ON IFDS
Due to its efÔ¨Åciency, many data-Ô¨Çow analyses [2], [7], [8]
are implemented as instantiations of the IFDS framework [5].
We next brieÔ¨Çy summarize important background information
on IFDS, necessary to understand our extension IFDS-APA .
The IFDS framework is capable of solving inter-procedural
finite distributive subset problems. At every call, the framework
computes callee summaries on the Ô¨Çy. These summaries are
highly reusable as (1) they are independent of the calling
context and (2) due to the distributivity of the analysis problem
can be reused on an element-by-element basis. Internally, IFDS
transforms the original analysis problem into a reachability
problem over the so-called exploded super graph .
A deÔ¨Ånition of an IFDS problem consists of a data-Ô¨Çow
domainDand a set of Ô¨Çow functions . The data-Ô¨Çow domain is a
set of data-Ô¨Çow facts . A solution to the IFDS problem provides
information whether a given fact holds at a certain statement.
One special fact is the 0-fact, a tautological fact that always
holds. Other facts can be generated unconditionally by deriving
them from this 0-fact. To guarantee termination, IFDS requires
the data-Ô¨Çow domain to be a Ô¨Ånite set. To express an IFDS
problem, one deÔ¨Ånes the Ô¨Çow functions which describe how
data-Ô¨Çow facts are transferred from one statement to its (intra
and inter-procedural) successors. A requirement for IFDS is
that each Ô¨Çow function, say f, needs to be distributive w.r.t. set
union, thusf(A‚à™B)=f(A)‚à™f(B)forA;B‚äÜD. This allows
the framework to deÔ¨Åne Ô¨Çow functions on single elements of
D. The evaluation of the Ô¨Çow function for any such element
yields a subset S‚äÜD.
A. Path Edges
IFDS computes a callee‚Äôs procedure summary incrementally
through so-called path edges . A path edge is written as
/uni27E8s;d1/uni27E9‚Üí/uni27E8t;d2/uni27E9, wheretis an arbitrary target statement and
sis the start statement of the method of t. This makes a path
edge always local to one method. The elements d1andd2are
data-Ô¨Çow facts: d2is the target fact andd1thestart fact of the
edge. Semantically, a path edge expresses: If d1is reachable
(and therefore holds) at statement s, so isd2at statement t. The
purpose of the Ô¨Çow functions is to successively deduce new
path edges to bridge longer and longer paths. The appropriate
Ô¨Çow function for the target statement t, sayft, receives thedata-Ô¨Çow fact d2as arguments. The result of the application
of the Ô¨Çow function is a set of data-Ô¨Çow facts S=ft(d2). For
each element d3of the setSand each statement t‚Ä≤succeeding
ta path edge is derived: /uni27E8s;d1/uni27E9‚Üí/uni27E8t‚Ä≤;d3/uni27E9.
B. Incoming Set And Summaries
An important part of the IFDS framework is its incoming set .
For each method and data-Ô¨Çow fact which enters the method
through a call site, the incoming set stores the information (1)
through which call site(s) the method is entered and (2) which
path edges reach those call site(s). Consider a method mis
called at a call site cand the path edge p=/uni27E8s;d0/uni27E9‚Üí/uni27E8c;d1/uni27E9
reachesc. Further assume, that the call‚Äôs Ô¨Çow function maps
factd1tod2on the side of the callee m. Once entering the
method, the path edge pis added to the incoming set Id2mfor
the callee method mand factd2, sop‚ààId2m.
IFDS seeks to construct procedure summaries that are
independent of any particular calling context. It thus bootstraps
the analysis of any callee mby propagating an initial self
loop edge /uni27E8v;d2/uni27E9‚Üí/uni27E8v;d2/uni27E9from the start statement vofm.
This expresses that d2holds atvifd2holds atv, i.e., without
any further condition. From this edge, new path edges are
successively derived via the application of the Ô¨Çow-functions.
The Ô¨Çow-functions maintain the start statement and start node
of the derived edges. Whenever a derived path edge, say
/uni27E8v;d2/uni27E9‚Üí/uni27E8t;d3/uni27E9, reaches an exit statement tof the method m,
this path edge becomes a (partial) procedure summary. The
framework must now apply this summary‚Äôs effect to all callers
ofm. It traverses the incoming set Id2mto extract all call sites
at which path edges inside callers have to be continued. A
return-Ô¨Çow function maps d3back to a fact d4in the caller
scope. Here, assuming the path edge pis in the incoming set,
IFDS continues with the path edge /uni27E8s;d0/uni27E9‚Üí/uni27E8c‚Ä≤;d4/uni27E9for any
successor statement c‚Ä≤ofc.
The path edge /uni27E8v;d2/uni27E9‚Üí/uni27E8t;d3/uni27E9is stored as a intra-
procedural summary for method m. The summary can be re-
applied for any other call site which is interested in analyzing
the method mwith the same input fact d2.
III. M ODELING FIELDS IN DATA-FLOW ANALYSIS
In this section, we discuss two alternatives for modeling
Ô¨Åeld accesses in data-Ô¨Çow analyses. We use taint analysis as an
example client, however, the described techniques are applicable
to data-Ô¨Çow analyses in general. A taint analysis reasons about
possible data Ô¨Çows from a given source to a given sink and
can decide privacy as well as integrity problems [6].
A. Field-Based Models
Field-based analyses treat Ô¨Åelds independently of the objects
they belong to. They track a Ô¨Åeld as soon as a tracked value
is assigned to it, independent of the object instance the Ô¨Åeld
belongs to. Thus, any subsequent read from the Ô¨Åeld must be
tracked no matter which object the Ô¨Åeld belongs to. A possible
analysis domain Dfor a Ô¨Åeld-based analysis comprises all local
variables Lof all program‚Äôs methods and all Ô¨Åelds Fdeclared
in the program, so D=L‚à™F. While a Ô¨Åeld-based analysis
can be sound, not considering the base object will often lead
to imprecision, as illustrated by the following example.foo(){
A a = new A();
a.f = source();
A b = id(a);
}
bar(){
A a = new A();
a.g = source();
A b = id(a);
}
id(A p){
return p;
}
(a) Multiple Summariesfoo(A a) {
while (unknown()) {
A b = new A();
if(unknown())
b.f = a;
else
b.g = a;
a = b;
b = null ;
}
return a;
}
(b) State Explosion
Fig. 2: Examples of Threats to Scalability
Example 1: In Figure 1b, Ô¨Åeld a1.f is assigned the tainted
value of x. Field a2.f never gets tainted. Nevertheless, the
analysis will report it as tainted, because it models both Ô¨Åeld
accesses as A.f, resulting in a false positive.
B. Field-Sensitive Models
A more precise alternative is to model Ô¨Åeld accesses as
access paths . An access path consists of a base variable ‚Äì a
local variable visible in the current method‚Äôs scope (including
its parameters and the receiver this ) ‚Äì followed by a sequence
of Ô¨Åeld accesses. In a taint analysis, an access path typically
models an access path through which a tainted memory location
can be reached. Field-sensitive models are more precise than
Ô¨Åeld-based ones. In Figure 1b a Ô¨Åeld-sensitive analysis would
taint the access path a1.f but not a2.f . When processing
the read y = a2.f , no taint will be reported for y, avoiding
a false warning.
Unfortunately, the described data-Ô¨Çow domain is unbounded.
Assume a further assignment a3.g = a1 somewhere in the
code in Figure 1b. To maintain precision the analysis must
propagate the taint from a1.f toa3.g.f , resulting in an
access path of length 2. If proper care is not taken, loops can
yield access paths of an unbounded length. Also analyzing
recursive data structures, e.g., doubly-linked lists, may yield
unbounded access paths such as l.next.prev.next... .
Although l.next andl.next.prev.next statically refer
to the same object, most analyses are unable to identify this
equivalence.
Formally, for a Ô¨Åeld-sensitive taint analysis the data-Ô¨Çow
domain is identiÔ¨Åable as the set
D‚à∂={(x1;:::;xk) /divides.alt0k‚ààN;x1‚ààL;xi‚ààF;‚àÄi‚â•2}:
This domain of inÔ¨Ånite size contradicts the requirements of
IFDS and other data-Ô¨Çow analysis frameworks that guarantee
termination only for Ô¨Ånite data-Ô¨Çow domains.
To obtain a Ô¨Ånite domain, it is common practice to
artiÔ¨Åcially bind the sequence of Ô¨Åeld accesses to a Ô¨Åxed length
by limiting kin the domain deÔ¨Ånition to a given natural
number. This is known as k-limiting [4]. Analyses then have
to suitably alter the processing of bounded access paths to
retain soundness. Limiting kobviously introduces an over-
approximation. Decreasing the selected kvalue increases theover-approximation and lowers the precision. Increasing the k
value enables the analysis to distinguish more states, however,
at the cost of defeating its scalability due to state explosion.
Our experiments‚Äîpresented in Section V‚Äîshow that even
for smallkvalues analyses can run out of gigabytes of main
memory when analyzing real-world programs.
There are two main root causes for the scalability problems:
(a) due to the way applicability of method summaries is deÔ¨Åned,
even methods that represent an identity function w.r.t. an input
tainted value must be re-analyzed for each access path rooted
at that tainted value, (b) due to an explosion of different states
to be considered. The following two examples illustrate the
root causes.
Example 2: Methods that represent an identity function
w.r.t. the tainted value must be re-analyzed for each possible call
site. For illustration, consider the code in Figure 2a. Assume a
classAwith two Ô¨Åelds fandg. Method foo taints a.f, which
a Ô¨Åeld-sensitive analysis will model by the access path a.f.
Next, this access path Ô¨Çows as a parameter into method id.
Typical summary-based analyses will translate the abstraction
a.f to the scope of the callee, yielding p.f. Next, the analysis
will create a procedure summary for id, indicating that it taints
retVal .fifp.f was tainted. Now, consider the second
calling context for idwithin bar, which passes a tainted
value a.g. Again, this value is translated into p.g. Since
the computed summary for p.f is not applicable to p.g, the
analysis will process the id-procedure again, although id
returns the parameter unchanged. While the analysis effort is
trivial in this example, the method idcould in reality have
many more statements and may call many other methods, while
remaining an identity function, i.e., opaque, w.r.t. the tainted
value. Such methods can be quite frequent in an application.
Example 3: Each unique access path must be propagated
resulting in an explosion of the propagated facts. For illustration
consider the code in Figure 2b. Assume that the parameter aof
method foo is tainted and that we cannot statically decide the
values to which the while andifconditions will evaluate,
i.e., both branches are possible for each condition. Each loop
iteration thus propagates from atob.f andb.g. Hence, foo
may return tainted access paths a(no loop iteration), a.f
anda.g (one iteration), a.f.f ,a.f.g ,a.g.f , and a.g.g
(two iterations), and so on. Given a maximum access path
length ofkandAthe set of Ô¨Åelds written inside the loop,
this yields ‚àëk
n=0/divides.alt0A/divides.alt0ndifferent access paths. In IFDS the merge
operator at control-Ô¨Çow merge points is restricted to set union.
Thus, the analysis cannot merge facts and must propagate each
unique access path.
In our experiments we observed that constructs similar to
those illustrated by this example defeated the scalability of
our Ô¨Åeld-sensitive client analyses. The most common construct
was actually not a loop, but methods invoked on an interface
type with many concrete implementations. If it is undecidable
to which concrete implementation the method call must be
resolved, analyses typically assume that any of them may be
called. If one of them recursively invokes the same interface
method, we observe the same effect as in the example ‚Äì the loop
manifests itself at an inter-procedural level through recursion.IV. A PPROACH
We propose Access-Path Abstraction, a sound and scalable
framework for Ô¨Åeld-sensitive data-Ô¨Çow analysis. Access-Path
Abstraction obviates the need for over-approximations like k-
limiting for keeping the domain Ô¨Ånite and hence also the need
to tradeoff between precision and scalability.
The key ideas underlying Access-Path Abstraction are:
1) Abstract summaries are constructed that abstract over a
whole set of access paths, e.g., if a method is invoked
with an access path a.f, Access-Path Abstraction
creates a summary for a.*instead.
2) Abstract summaries, such as a.*are reused for all
callers invoking the respective method with any access
path covered by the abstraction, e.g., a.g or any other
access path sharing the common preÔ¨Åx a. Yet, the
application of summaries is designed such that the
result reÔ¨Çects speciÔ¨Åc access paths of speciÔ¨Åc callers.
3) Access-Path Abstraction ensures that only those parts
of the application are analyzed that would be analyzed,
if concrete access paths were used instead of abstract
summaries. For example, a taint analysis processing
an assignment b = a.g should continue for bif
and only if a.g is tainted, but not because any other
tainted Ô¨Åeld of a, e.g., a.f, was abstracted to a.*.
Next, we describe the changes and extensions to the IFDS
framework that are required to achieve 1) and 2), then we
elaborate on changes for 3). Subsequently, we discuss how
the extensions can be adapted to loops and return sites to
solve the state-explosion problem described in Example 3
and why Access-Path Abstraction obviates the need for over-
approximations like k-limiting keeping the domain Ô¨Ånite. IFDS-
APA , the variant of Access-Path Abstraction we describe here,
extends the IFDS framework [5].
A. The Analysis Domain
IFDS-APA uses an efÔ¨Åcient abstraction that encodes sets
ofaccess paths in a concise, symbolic representation.
Access Path: Given the set of all local program variables
Land the set of all Ô¨Åeld declarations F, an access path 
is a sequence of a local variable followed by a sequence of
Ô¨Åeld accesses: =(1;:::;n)with1‚ààLandi‚ààFfor
2‚â§i‚â§nandn=/divides.alt0/divides.alt0.
Access-Path Bundles: To realize the idea of constructing
abstract summaries 1), we formulate an analysis domain that
implicitly encodes sets of access paths.2In this domain, a fact
is called an access-path bundle and consists of an access path
and a set of exclusions E,E‚äÜF. Exclusions are the key to
avoid unnecessary analysis steps due to over-approximation 3),
as we explain later. The tuple /uni27EA;E/uni27EBrepresents a whole set
of access paths, formally deÔ¨Åned as:
/uni27EA;E/uni27EB=/uni27EA(1;:::; /divides.alt0/divides.alt0);E/uni27EB
‚à∂={(x1;:::;xm) /divides.alt0xi=i;1‚â§i‚â§/divides.alt0/divides.alt0;
m‚â•/divides.alt0/divides.alt0;
x/divides.alt0/divides.alt0+1‚àâE}
2A client analysis may include speciÔ¨Åc information into facts. Our imple-
mentation anticipates this. However, to ease the exposition, throughout this
paper, we restrict facts to just a pair of an access path and the set of exclusions.Hence, the bundle /uni27EA;E/uni27EBrepresents all access paths of
length greater or equal to /divides.alt0/divides.alt0, which start with the sequence
, and whose Ô¨Åeld x/divides.alt0/divides.alt0+1is not inE, if the length of the path
is greater than /divides.alt0/divides.alt0. We say that a bundle /uni27EA;E/uni27EBbelongs to
the locall‚ààL, iff1=l. For brevity, we write ÃÉto denote a
bundle /uni27EA;E/uni27EB.
In the following, we deÔ¨Åne some operations on access-path
bundles, which are used in the process of constructing and
applying summaries.
Partial Order on the set of All Bundles: The relation
/uni27EA;E/uni27EB‚äá/uni27EA;E/uni27EBholds, iff the following conditions (given
=(1;:::;k)and=(1;:::;l)) are fulÔ¨Ålled:
1)/divides.alt0/divides.alt0‚â§/divides.alt0/divides.alt0
2)i=i;1‚â§i‚â§/divides.alt0/divides.alt0
3)/braceleft.alt4/divides.alt0/divides.alt0+1‚àâE;if/divides.alt0/divides.alt0</divides.alt0/divides.alt0
E‚äÜE; if/divides.alt0/divides.alt0=/divides.alt0/divides.alt0
Intuitively,is a preÔ¨Åx of andis not excluded through the
exclusion set E, if the length of is greater than ; if they
have the same length, Eexcludes at least the Ô¨Åelds excluded
byE.
If two access-path bundles only differ in their exclusions,
we write /uni27EA;E/uni27EB‚âà/uni27EA;E/uni27EB, formally deÔ¨Åned as:
1)/divides.alt0/divides.alt0=/divides.alt0/divides.alt0
2)i=i;1‚â§i‚â§/divides.alt0/divides.alt0=/divides.alt0/divides.alt0.
For two access-path bundles ÃÉandÃÉsuch that ÃÉ‚âàÃÉor
ÃÉ‚äáÃÉ, we deÔ¨Åne their delta , denoted by (ÃÉ;ÃÉ)‚àà(F)‚àó√ó2F
as
(ÃÉ;ÃÉ)‚à∂=/braceleft.alt4((/divides.alt0/divides.alt0+1;:::; /divides.alt0/divides.alt0);E)if/divides.alt0/divides.alt0</divides.alt0/divides.alt0
(;E‚à™E) if/divides.alt0/divides.alt0=/divides.alt0/divides.alt0
here refers to the empty sequence. Note that a delta is
not an access-path bundle and never contains a local variable.
Concatenation of an Access-Path Bundle and a Delta: Given
a bundle ÃÉand an arbitrary delta =(;E), we deÔ¨Åne the
concatenation, ÃÉ‚à∑, which yields a new bundle, as follows:
ÃÉ‚à∑‚à∂=/braceleft.alt4/uni27EA(1;:::; /divides.alt0/divides.alt0;1;:::; /divides.alt0/divides.alt0);E/uni27EB if‚â†
/uni27EA(1;:::; /divides.alt0/divides.alt0);E‚à™E/uni27EB if=:
Ifis non-empty, then its elements are used to reÔ¨Åne the
access-path (by extension). As exclusions always refer to
the position after the end of the access path, in this case one
retains only the exclusions E. In the other case, both sets of
exclusions are retained.
B. Abstract Summaries
At speciÔ¨Åc statements, called abstraction points ,IFDS-APA
abstracts over a given access-path bundle to compute an abstract
summary. Abstraction points are all merge points of intra or
inter-procedural control Ô¨Çows: (a) start points of methods, (b)
entries to loops, and (c) return sites. In the following, we will
focus Ô¨Årst on (a) as the most intuitive of those cases.
The key to the efÔ¨Åciency of IFDS-APA is that in cases
where an access-path bundle ÃÉ=/uni27EA(1;:::;n);E/uni27EBis passed
to a calleec,IFDS-APA will bootstrap c‚Äôs analysis with aninitial self-loop path edge not of ÃÉbut of an abstracted version
ofÃÉthat represents all access paths rooted in the same local
variable as ÃÉ, i.e.,/uni27EA(1);/uni2205/uni27EB. For instance, in a situation, where
a callee would normally be analyzed for /uni27EAa.f.g;/uni2205/uni27EB,IFDS-
APA initiates an analysis for /uni27EAa;/uni2205/uni27EBinstead. If a summary for
the abstracted bundle already exists, IFDS-APA applies this
summary without further computation.
While the application of summaries to avoid computations
is equal to IFDS, IFDS-APA requires a different deÔ¨Ånition of
both (i) when a summary is applicable, and (ii) how it is applied.
In line with IFDS terminology [5] summaries are of the form
/uni27E8spcallee;d3/uni27E9‚Üí/uni27E8epcallee;d4/uni27E9: ‚Äúd4holds at end point epcallee
in any context in which d3holds at the start point spcallee ‚Äú.
A summary /uni27E8spcallee;d3/uni27E9‚Üí/uni27E8epcallee;d4/uni27E9is applicable to an
incoming fact d2=/uni27EA;Ea/uni27EBiffd3‚äád2. The summary is applied
by computing the delta between d3andd2and concatenating
it tod4. Thus, for a start point spcaller at the caller for which
the factd1resulted ind2being propagated to the callee, we
generate the path edge /uni27E8spcaller;d1/uni27E9‚Üí/uni27E8rs;d 4‚à∂‚à∂(d3;d2)/uni27E9to
the return site rs.3
Example 4: Referring back to Example 2 and Figure 2a,
IFDS-APA analyzes method idonly once for the access-
path bundle /uni27EAp;/uni2205/uni27EB. Method foo callsidwith an incoming
fact/uni27EAp:f;/uni2205/uni27EBand method bar with/uni27EAp:g;/uni2205/uni27EB. The summary
foridmaps/uni27EAp;/uni2205/uni27EBto/uni27EAretVal;/uni2205/uni27EBand is applicable to both
incoming facts. The application computes the deltas (f;/uni2205)and
(g;/uni2205)and their concatenation to the returned value yields the
facts/uni27EAb:f;/uni2205/uni27EBfor method foo and/uni27EAb:g;/uni2205/uni27EBfor method bar.
In other words, concatenating the deltas restores the calling
context that was abstracted away before the callee was analyzed.
C. Field-Read and Field-Write Statements
Next, we explain how IFDS-APA handles cases, where
callee procedures read from or write to access paths that were
abstracted on entry to the callee.
Field-Read Statements: Assume that we are analyzing a
calleecwith a taint represented by an abstracted access-path
bundle /uni27EAx;/uni2205/uni27EB. Ifcreads x.f, the analysis cannot know
which of x,x.f, orx.g etc. are tainted, as /uni27EAx;/uni2205/uni27EBeffectively
represents all access paths x.*.
IFDS-APA addresses this problem by computing the
required information on the Ô¨Çy. It checks c‚Äôs incoming set
for callers that explicitly requested the analysis with respect
tox.f before the abstraction occurred: For a path edge
/uni27E8sp;/uni27EA(1;:::;n);E/uni27EB/uni27E9‚Üí/uni27E8b=x.f;/uni27EAx;E/uni27EB/uni27E9IFDS-APA
checks whether the incoming set contains a fact ÃÉsuch that
/uni27EA(1;:::;n;f);/uni2205/uni27EB‚äáÃÉ. If this is the case, the analysis
continues with a path edge to each successor t‚Ä≤of the statement
b=x.f with a reÔ¨Åned start fact: /uni27E8sp;/uni27EA(1;:::;n;f);/uni2205/uni27EB/uni27E9‚Üí
/uni27E8t‚Ä≤;/uni27EAb;/uni2205/uni27EB/uni27E9. The intuition for this reÔ¨Ånement is: Iff any access
path starting with (1;:::;n;f)Ô¨Çows into statement sp, it
will Ô¨Çow to an access path starting with bat statement t‚Ä≤. Note
thatIFDS-APA proceeds as just described only, iff fwas not
excluded, i.e., f‚àâEandf‚àâE.
3We omitted mapping the actual parameter to the formal parameter and
the return value of the callee to the assigned value at the caller to keep the
explanation brief. Mappings of local variables through call and return edges
are actually performed as in the original IFDS framework.main(){
A a = new A();
a.f = source();
z = wrapper(a);
}
wrapper(A b){
y = bar(b);
return y;
}
bar(A c){
x = c.f
return x;
}
Fig. 3: Callbacks Created for a Field-Read StatementPath Edge:
Call Edge:
Generated by:0
/uni27EAa.f;/uni2205/uni27EB
/uni27EAb;/uni2205/uni27EB
/uni27EAb;/uni2205/uni27EB
/uni27EAc;/uni2205/uni27EB
/uni27EAc;/uni2205/uni27EB/uni27EAb.f;/uni2205/uni27EB
/uni27EAc;/uni2205/uni27EB
IFDS/uni27EAb.f;/uni2205/uni27EB
/uni27EAc.f;/uni2205/uni27EB
/uni27EAx;/uni2205/uni27EB/uni27EAc.f;/uni2205/uni27EB
Callbacks
If no caller requested the analysis with respect to x.f yet,
the analysis must soundly cater for the fact that this could
happen in later rounds of the Ô¨Åxed-point iteration. To handle
this, IFDS-APA creates a callback that creates the path edge(s)
upon future invocation. The callback is registered with the
incoming set and is invoked if a caller provides an incoming
factx.f. Technically, we always create the callback, but this
callback is invoked immediately if the condition is already
fulÔ¨Ålled. Section IV-D discusses callbacks in more detail.
Field-Write Statements: Assume that we are analyzing a
calleecwith access paths represented by the bundle /uni27EAx;/uni2205/uni27EB, and
coverwrites x.f with an un-tainted value, e.g., x.f=null .
This assignment kills Ô¨Çows to x.f. Therefore, the analysis
should only continue if a caller exists that calls cwith an access
path rooted in xbutdifferent from x.f. Field exclusions
are used to express this. For a path edge /uni27E8sp;/uni27EA;E/uni27EB/uni27E9‚Üí
/uni27E8x.f=null;/uni27EAx;E/uni27EB/uni27E9the framework reÔ¨Ånes the start fact by
adding the Ô¨Åeld fto the exclusion set, yielding the reÔ¨Åned
fact/uni27EA;E‚à™{f}/uni27EB. If the incoming set of ccontains a fact ÃÉ,
such that /uni27EA;E‚à™{f}/uni27EB‚äáÃÉ, the analysis will continue with a
path edge /uni27E8sp;/uni27EA;E‚à™{f}/uni27EB/uni27E9‚Üí/uni27E8t‚Ä≤;/uni27EAx;E‚à™{f}/uni27EB/uni27E9to each
successort‚Ä≤of statement x.f=null . If there is no incoming
fact satisfying the constraint, the framework creates a callback
that will create the path edge(s) on invocation. This is analogue
to Ô¨Åeld reads.
D. Callbacks
Callbacks can be registered with abstraction points, e.g.,
the start point of a method together with trigger conditions that
guard their invocation. A trigger condition speciÔ¨Åes a predicate
on an access-path bundle ÃÉ. For example, the trigger condition
for the callback registered with the method‚Äôs starting point
of the example in the sub-section about Ô¨Åeld-read statements,
required an incoming fact ÃÉfor which /uni27EA(1;:::;i;f);/uni2205/uni27EB‚äáÃÉ
holds. In this case, the access-path bundle associated with the
callback condition is ÃÉ=/uni27EA(1;:::;i;f);/uni2205/uni27EB. The callback is
then invoked if a fact ÃÉ, for which ÃÉ‚äáÃÉholds, is passed to
the abstraction point with which the callback is registered.
Example 5: Consider the method bar in the example inFigure 3, while ignoring the methods main andwrapper
for now. The method bar will be analyzed with an access-
path bundle /uni27EAc;/uni2205/uni27EBat the start point. Field fis read at
statement x=c.f . This causes a callback cbto be registered
with the start point spbarofbar that will create the path edge
/uni27E8spbar;/uni27EAc.f;/uni2205/uni27EB/uni27E9‚Üí/uni27E8return x;/uni27EAx;/uni2205/uni27EB/uni27E9upon invocation.
The access-path bundle associated with cbas the trigger
condition is ÃÉ=/uni27EAc.f;/uni2205/uni27EB. The incoming fact ÃÉ=/uni27EAc;/uni2205/uni27EB
is checked against this condition: ÃÉ‚äáÃÉdoes not hold ‚Äì hence,
no path edge is created. If the analysis processes another call
that passes a taint ÃÉ=/uni27EAc.f;/uni2205/uni27EBto the start point spbar, the
callback is triggered, because ÃÉ‚äáÃÉholds. The trigger condition
also holds for ÃÉ=/uni27EAc.f.g;/uni2205/uni27EB, but not for ÃÉ=/uni27EAc.g;/uni2205/uni27EB.
The semantics of callback registration and invocation
deÔ¨Åned so far is simplistic. It ignores the fact that several
abstractions can happen along different invocation chains:
Callback trigger conditions so far only consider the local view
on access paths of methods that contain Ô¨Åeld reads or writes.
This may cause unsoundness of the analysis, as illustrated by
the example below.
Example 6: Consider the methods main andwrapper in
in Figure 3. The method main generates a taint /uni27EAa.f;/uni2205/uni27EB
and passes it to wrapper . Onwrapper ‚Äôs entry, this taint is
abstracted to /uni27EAb;/uni2205/uni27EBand then passed to bar, which reads the
Ô¨Åeldc.f. This Ô¨Åeld read results in the callback installation with
the trigger ÃÉ=/uni27EAc.f;/uni2205/uni27EBas discussed before. The callback‚Äôs
condition cannot be fulÔ¨Ålled, as it is registered for the start
point of bar, which was only passed the abstracted access
pathc, notc.f. As a result, the analysis will miss a tainted
edge, hence be unsound.
The example not only illustrates how unsoundness can occur,
if we leave things as described. It also suggests what needs to
be done to avoid unsoundness: IFDS-APA must reiterate the
registration and evaluation of callbacks in callers.
To ensure that callbacks are also triggered transitively, the
framework replicates callbacks along the incoming sets. When
the framework attaches a callback to a method start point, it
iterates over the incoming edges , the path edges within the
incoming set, and checks whether any of the edge‚Äôs target facts
potentially satisÔ¨Åes the condition of the callback. Assume an
incoming edge /uni27E8spcaller;ÃÉ/uni27E9‚Üí/uni27E8t;ÃÉ/uni27E9for a callee start point
spcallee . The incoming fact ÃÉpotentially satisÔ¨Åes the callback
condition ÃÉin two cases: (a) if ÃÉ‚äáÃÉor (b) if ÃÉ‚âàÃÉ. In any
of the two cases, the framework performs the following steps:
(a) it computes the delta between the incoming fact ÃÉand
the condition ÃÉ,=(ÃÉ;ÃÉ); (b) the delta is concatenated to
the start fact ÃÉof the incoming edge; (c) the result ÃÉ‚Ä≤=ÃÉ‚à∂‚à∂
is installed as the trigger condition for the replicated callback,
and (d) the latter is registered with the start point spcaller of
the incoming edge. On invocation of the replicated callback,
the framework registers a new incoming fact to the start point
spcallee , constructed by concatenating the original incoming ÃÉ
fact and the computed delta . This new incoming fact satisÔ¨Åes
the trigger condition of the original callback at spcallee , which
therefore will be executed.
Note that when the framework registers the replicated
callback with the start point of the incoming edge, this may
result in other replicated callbacks being created as the same
steps are performed recursively for callers of callers. Thisrecursion may happen until the analysis reaches an initial seed
(0-Fact). This process may seem expensive at Ô¨Årst sight, but
it is not. Consider that the framework only needs to traverse
path edges. Each path edge skips over all the internal nodes of
the respective methods, such that in the worst case one needs
to traverse only as many path edges as there are frames on the
current abstract call stack.
The following example illustrates how the transitive regis-
tering of callbacks avoids the unsoundness that would occur
otherwise.
Example 7: Reconsider Example 6 and Figure 3. The
Ô¨Åeld-read statement in method bar will generate a callback.
This callback creates the path edge /uni27E8spbar;/uni27EAc:f;/uni2205/uni27EB/uni27E9‚Üí
/uni27E8return x;/uni27EAx;/uni2205/uni27EB/uni27E9. The trigger condition ÃÉof the call-
back is not satisÔ¨Åed by the incoming fact /uni27EAc;/uni2205/uni27EB, because
ÃÉ=/uni27EAc:f;/uni2205/uni27EB/uni2289/uni27EAc;/uni2205/uni27EB. But, this incoming fact potentially
satisÔ¨Åes the condition transitively, because /uni27EAc;/uni2205/uni27EB‚äá/uni27EAc:f;/uni2205/uni27EB.
Consequently, the framework replicates a transitive callback
for the incoming edge, reÔ¨Çecting the call edge from wrapper
tobar. Using the path edge into the call site, the framework
can retrieve the start-point statement and the start fact at that
statement. The transitive callback is registered with this start-
point statement using as condition the start fact concatenated
with the delta (/uni27EAc;/uni2205/uni27EB;/uni27EAc:f;/uni2205/uni27EB). Therefore, the condition
is/uni27EAb;/uni2205/uni27EB‚à∂‚à∂(/uni27EAc;/uni2205/uni27EB;/uni27EAc:f;/uni2205/uni27EB)=/uni27EAb:f;/uni2205/uni27EB. This condition
is immediately satisÔ¨Åed by the incoming fact /uni27EAb:f;/uni2205/uni27EBthat
is passed from main towrapper . Hence, the transitive
callback is invoked immediately, and creates the call edge,
which registers /uni27EAc:f;/uni2205/uni27EBas incoming fact to bar. This new
incoming fact triggers the Ô¨Årst callback, which in turn creates
the path edge /uni27E8spbar;/uni27EAc:f;/uni2205/uni27EB/uni27E9‚Üí/uni27E8return x;/uni27EAx;/uni2205/uni27EB/uni27E9, with
which the analysis will continue.
E. Loops
To solve the termination problem caused by recursive
constructs such as loops and recursive data structures without
bounding the size of access paths, Access-Path Abstraction
introduces additional abstraction points beyond method calls.
Here we explain the handling of other control-Ô¨Çow merge
points. This includes, in particular, entries to loops. First,
we illustrate by an example, how the termination problem is
solved by introducing loops as abstraction points. Subsequently,
we discuss the algorithmic changes required to accommodate
additional abstraction points.
Example 8: For the loop shown in Figure 2b the framework
will proceed as follows. It Ô¨Årst creates an initial self-loop at the
start point of foo with the access-path bundle /uni27EAa;/uni2205/uni27EB. Then
it passes this bundle to the beginning of the loop, i.e., the
abstraction point. The framework abstracts the bundle, which
in this case has no effect, yielding the same bundle again.
The loop causes the bundle /uni27EAb.f;/uni2205/uni27EBto be created along one
branch and /uni27EAb.g;/uni2205/uni27EBalong the other. Then, bis assigned to
a, such that /uni27EAa.f;/uni2205/uni27EBand/uni27EAa.g;/uni2205/uni27EBare passed back to the
entry of the loop, i.e., back to the abstraction point. At the loop
abstraction point, the framework proceeds just as it does at the
entry to a called procedure. It stores both bundles as incoming
facts and continues the next iteration with abstracted access-
path bundles. In this example, no additional iteration will be
computed, because both access-path bundles are abstracted to
/uni27EAa;/uni2205/uni27EB, i.e., to a fact that the analysis already processed.sp
c=a b.g=a
c.f=b
ap
d=c.f
e=d.f
. . ./uni27EAa;/uni2205/uni27EB‚Üí
/uni27E8/uni27EAa;/uni2205/uni27EB;‚àí;;/uni2205/uni27E9
/uni27EAa;/uni2205/uni27EB‚Üí
/uni27E8/uni27EAa;/uni2205/uni27EB;‚àí;;/uni2205/uni27E9/uni27EAa;/uni2205/uni27EB‚Üí
/uni27E8/uni27EAa;/uni2205/uni27EB;‚àí;;/uni2205/uni27E9
/uni27EAa;/uni2205/uni27EB‚Üí
/uni27E8/uni27EAb.g;/uni2205/uni27EB;‚àí;;/uni2205/uni27E9
/uni27EAa;/uni2205/uni27EB‚Üí
/uni27E8/uni27EAc;/uni2205/uni27EB;‚àí;;/uni2205/uni27E9/uni27EAa;/uni2205/uni27EB‚Üí
/uni27E8/uni27EAc.f.g;/uni2205/uni27EB;‚àí;;/uni2205/uni27E9
/uni27EAa;/uni2205/uni27EB‚Üí
/uni27E8/uni27EAc;/uni2205/uni27EB;ap;;/uni2205/uni27E9
/uni27EAa.f;/uni2205/uni27EB‚Üí
/uni27E8/uni27EAd;/uni2205/uni27EB;ap;f;/uni2205/uni27E9/uni27EAa;/uni2205/uni27EB‚Üí
/uni27E8/uni27EAd;/uni2205/uni27EB;ap;f;/uni2205/uni27E9
/uni27EAa.f.f;/uni2205/uni27EB‚Üí
/uni27E8/uni27EAe;/uni2205/uni27EB;ap;f.f;/uni2205/uni27E9
Fig. 4: Handling of Arbitrary Nodes as Abstraction Points
/uni27EA;/uni2205/uni27EB‚Üí /uni27E8/uni27EA;/uni2205/uni27EB;ap;;/uni2205/uni27E9is used here as abbreviation for a path edge
/uni27E8sp;/uni27EA;/uni2205/uni27EB/uni27E9‚Üí/uni27E8s;/uni27EA;/uni2205/uni27EB;ap;;/uni2205/uni27E9, wherebysis the respective CFG node at which
the path edge is drawn.
To summarize, the additional abstraction points solve the
termination problem without the need to restrict the size of
access paths. However, the additional abstraction points require
an algorithmic change to correctly handle callbacks. When a
Ô¨Åeld-read or Ô¨Åeld-write statement is processed, the framework
must register a callback with the latest abstraction point it
passed. If that abstraction point is a method entry, it is easily
identiÔ¨Åed, because every path edge starts at a method start
point by deÔ¨Ånition.
To identify the latest abstraction point in other situations,
we modify the deÔ¨Ånition of path edges to also use a reference to
the latest non-start-point abstraction point if such an abstraction
point has been passed. In addition, we include a sequence of
Ô¨Åelds, to reÔ¨Çect which Ô¨Åeld accesses have been resolved via
the abstraction point already, and a set of exclusions. We will
explain their need in the next example. From now on, we
will write path edges as /uni27E8sp;ÃÉ/uni27E9‚Üí/uni27E8t;ÃÉ;ap;;E /uni27E9, whereby
sp;ÃÉ;t; andÃÉare‚Äîas before‚Äîthe start point, access-path
bundle at the start point, a target statement, and an access-
path bundle at the target, respectively. New are ap;; andE
representing an abstraction point, a sequence of Ô¨Åeld accesses
=(1;:::;n);i‚ààF, and a set of excluded Ô¨Åelds E‚äÇF.
Example 9: For this example, consider Figure 4. The Ô¨Ågure
shows a control-Ô¨Çow graph supplemented by artiÔ¨Åcial nodes
for the start point spand an abstraction point ap. Each node
is annotated with the path edge targeting that node, whereby
we use an abbreviated form that omits the statements, as they
are easily inferred from the graph. We show only those path
edges that are of interest for the example. Note that path edges
are aligned at the left side of the Ô¨Ågure if a path edge results
from the left branch taken, aligned at the right side if the right
branch is taken, respectively. The path edge is drawn close to
the node, if the path edge results from both branches.
The path edges in the upper part of the Ô¨Ågure, drawn inblue, are straightforward. The analysis propagates through both
branches resulting in facts /uni27EAc;/uni2205/uni27EBand/uni27EAc.f.g;/uni2205/uni27EBpassed to
the abstraction point ap. Both are registered as incoming facts,
together with their respective path edges. After the abstraction
point, the analysis continues with an abstracted access-path
bundle /uni27EAc;/uni2205/uni27EBonly, and stores in the path edge succeeding
apa reference to ap. Now, at statement d=c.f the Ô¨Åeld fis
read, resulting in a callback being generated. The callback is
not registered with the start point sp, but with the abstraction
pointap, because in the path edge an abstraction point was
referenced, i.e., the start point is not the latest passed abstraction
point. The callback‚Äôs condition is checked against the incoming
facts atap. The condition can be immediately fulÔ¨Ålled via the
right branch providing /uni27EAc.f.g;/uni2205/uni27EB. This yields the path edge
/uni27E8sp;/uni27EAa;/uni2205/uni27EB/uni27E9‚Üí/uni27E8e=d.f;/uni27EAd;/uni2205/uni27EB;ap;f;/uni2205/uni27E9.
Note that the framework includes the Ô¨Åeld fin the path
edge, reÔ¨Çecting that a condition was fulÔ¨Ålled consuming a Ô¨Åeld
access fof some incoming edge at ap. This is because the
analysis satisÔ¨Åed the callback‚Äôs condition via the incoming fact
/uni27EAc.f.g;/uni2205/uni27EB‚Äúconsuming f‚Äù such that for succeeding Ô¨Åeld-
read statements the analysis must take into account that fhas
been read already and the incoming fact can now only be used
to read Ô¨Åeld g. Proceeding in the example, IFDS-APA uses
this information to know at statement e=d.f that the callback
generated here cannot be fulÔ¨Ålled by apvia the right branch.
To store information about which Ô¨Åelds have already been
excluded, the set Eof the new path edge is used analogously.
So far, we have ignored that the callback generated at
statement d=c.f could be potentially satisÔ¨Åed transitively
through the start point sp. This is the case, because the incoming
fact via the left branch potentially satisÔ¨Åes the condition. As
discussed in Section IV-D ,IFDS-APA therefore replicates the
callback for transitively preceding abstraction points, i.e., for
the start point sp. When this replicated callback can be fulÔ¨Ålled,
which in this case depends on the incoming facts provided by
callers, IFDS-APA registers an incoming fact /uni27EAc.f;/uni2205/uni27EBat
ap, which triggers the creation of path edge /uni27E8sp;/uni27EAa.f;/uni2205/uni27EB/uni27E9‚Üí
/uni27E8e=d.f;/uni27EAd;/uni2205/uni27EB;ap;f;/uni2205/uni27E9.
F . Return Sites
By introducing loops as additional abstraction points, we
solve the state explosion problem for the intra-procedural case.
But, state explosion may still occur inter-procedurally.
For illustration, consider the example in Figure 5. Assume
Foo to be an interface declaring a method foo with a parameter
xto be tainted. Classes AandBboth implement this interface
and provide similar implementations of foo: Both recursively
callfoo. Assume that the precise type of fis statically
undecidable, therefore, the call is resolved to A.foo and
B.foo . In addition, both wrap the tainted value in another
object‚Äôs Ô¨Åeld and return the object: Awrites to Ô¨Åeld aandB
to Ô¨Åeld b. Assume the analysis is computing a summary for a
tainted parameter x. Without the recursive call, the summary of
foo yields a mapping from xtoy.a, respectively y.b. For
the branch performing the recursive call, the analysis applies
the summaries for both A.foo andB.foo , which will in
turn generate the additional summaries from xtoy.a.a , and
y.a.b forA.foo and from xtoy.b.a , and y.b.b for
B.foo . This results in a similar state explosion as for loops.class A impl. Foo {
Foo f = aOrB();
foo(X x) {
if(unknown())
x = f.foo(x);
y.a = x;
return y;
}
}class B impl. Foo {
Foo f = aOrB();
foo(X x) {
if(unknown())
x = f.foo(x);
y.b = x;
return y;
}
}
Fig. 5: State Explosion through Access Paths
Note that an analog case, in which the taint is wrapped in
a Ô¨Åeld before passing it as parameter to the recursive call, is
already solved. As IFDS-APA abstracts at method start points,
the analysis encounters the previously seen fact /uni27EAx;/uni2205/uni27EBand
stops. By also applying abstraction at return sites, in the same
way as in the treatments for loops, the state explosion problem
can be solved here as well. Hence, at the return sites of call
foo the framework does abstract that the returned facts are
/uni27EAx.a;/uni2205/uni27EBand/uni27EAx.b;/uni2205/uni27EBand continues with the fact /uni27EAx;/uni2205/uni27EB.
/uni27EAx.a;/uni2205/uni27EBand/uni27EAx.b;/uni2205/uni27EBare registered as incoming facts with
the return site. As before, a reference to the return site as last
passed abstraction point is included in subsequent path edges
allowing to reconstruct the abstracted Ô¨Åeld accesses.
G. Termination in Presence of an Unbounded Domain
In theory, the analysis domain consisting of access-path
bundles has an inÔ¨Ånite size. One thus might wonder why
IFDS-APA guarantees termination. Termination would be
threatened in cases where the framework would create access-
path bundles of ever-growing size. But this is impossible, as
such unlimited growth can only occur due to loops or recursion.
Since IFDS-APA abstracts access-path bundles at every entry
into a procedure or loop, the length of the access-path portion of
an access-path bundle is thus bounded by the maximal length
of the access paths used within a single procedure or loop
iteration. This guarantees termination.
V. E VALUATION
We performed experiments to compare the proposed ap-
proach against two baseline approaches: A Ô¨Åeld-based approach,
denoted FB, and a classic Ô¨Åeld-sensitive approach that uses k-
limiting, as described in Section III, denoted FSk. SpeciÔ¨Åcally,
the experiments address the following two research questions:
RQ1: Given a Ô¨Åxed heap size, which analyses can
successfully analyze our benchmark subjects?
RQ2: How fast is IFDS-APA compared to the baseline
approaches?
A. Setup
Our implementation of IFDS-APA is based on Heros [6],
an open-source implementation of an IFDS/IDE solver; we
contributed our adaptations back to the Heros project. The two
baseline approaches also use the IFDS implementation provided
by Heros. The experiments carry out taint analyses, for which
we use the implementation of FlowTwist [8]. FlowTwist uses
Heros and is based on the Soot code-analysis framework [9].
Originally designed to address confused-deputy problems inthe Java Class Library, FlowTwist can be used to conduct
general-purpose data-Ô¨Çow analysis [10].
We use FlowTwist for three different experimental setups.
In the Ô¨Årst two setups we use an adaptation of FlowTwist to
detect SQL injection, command injection, path traversal, and
unchecked redirection vulnerabilities. We apply the analysis
to the Stanford SecuriBench [11] dataset consisting of seven
web applications. In the Ô¨Årst setup we use only the bare web
applications, while we include their dependencies (and the Java
Class Library) in the second setup. For the Ô¨Årst two setups a pure
forward analysis is conducted. In a third setup we use the origi-
nal FlowTwist implementation, which conducts a synchronized
forward and backward taint-analysis to detect confused-deputy
vulnerabilities within the Java Class Library (JCL) 1.7.0, e.g.,
any call to the method Class.forName(String cls) ,
where (1) the String cls is user-controlled, and (2) the return
value Ô¨Çows back to the user. These Ô¨Çows are problematic and
are commonly used in exploits [8]. This setup uses a call graph
starting at all of the JCL‚Äôs public methods, leading to a much
larger coverage of the JCL‚Äôs methods than with SecuriBench.
The applications within the SecuriBench suite vary from 32
to 445 classes and 4,191 to 52,089 lines of code per project. We
found it much more relevant, though, to characterize the projects
by the number of edges of their respective inter-procedural
control Ô¨Çow graphs (ICFGs), which are shown in the second
column of Table I. The ICFGs are relatively small if the web
applications are considered in isolation, but their size grows
signiÔ¨Åcantly if all dependencies are also considered. We counted
only those control-Ô¨Çow edges that are contained in methods
that are transitively reachable from within the web applications.
All experiments were conducted on a machine running
OS X 10.10 with a 4-core Intel Xeon E5 3.0 GHz processor
and 32 GB memory. As Java Runtime Environment, we used
the Oracle Java 1.8.0u40 release, with a heap size set to a
maximum of 25 GB.
B. Results
RQ1 seeks to answer the questions which approaches
can at all analyze which benchmarks within the allotted
25 GB of maximum heap size. To address this question, we
ran all approaches on all benchmarks. Table II shows those
conÔ¨Ågurations that ran out of memory as OoM. Results for all
three setups are shown separated by horizontal lines. As long
as the dependencies were excluded, all approaches were able
to analyze all of SecuriBench. If dependencies are considered,
however, only IFDS-APA and FBwere able to analyze all
SecuriBench applications. FSkwas only able to analyze all
of SecuriBench when kis set to zero. blueblog andwebgoat
could be analyzed for k-limiting with FSk=1orFSk=2, but
no application could be analyzed with any higher value for k.
None of the conÔ¨Ågurations was able to successfully complete
the FlowTwist analysis of Java 1.7.0 with the available memory.
To gain a better understanding of the relative scalability,
we measured two metrics while running all subject analyses
on the web applications of SecuriBench. First, we measured
the fraction of the statements each analysis must traverse, i.e.,
how many ICFG-edges it traverses. We also measured how
many times Ô¨Çow functions are being evaluated. The results
of these measurements are shown in Table I. The fraction ofTABLE I: Measures of Efforts Spent by each Analyses
Vis.: ICFG edges visited during the analysis; Eval.: Number of Ô¨Çow-function evaluations; OoM: Out of memory
ProjectICFG
EdgesIFDS-APA FBFSk
k=0 k=1 k=2 k=3
Vis. Eval. Vis. Eval. Vis. Eval. Vis. Eval. Vis. Eval. Vis. Eval.
blueblog 8 529 11% 2 652 29% 10 438 33% 10 441 32% 20 133 33% 30 981 33% 39 823
jboard 14 154 2% 524 1% 660 2% 614 2% 614 2% 614 2% 614
pebble 67 488 26% 61 676 25% 74 395 27% 66 626 26% 73 126 26% 73 643 26% 74 104
personalblog 11 391 13% 8 956 14% 11 376 14% 7 036 14% 7 024 14% 7 024 14% 7 024
roller 82 264 2% 4 069 3% 9 156 3% 7 942 2% 6 658 2% 6 658 2% 6 658
snipsnap 137 532 6% 22 799 7% 29 234 10% 35 571 7% 23 651 7% 25 500 7% 26 249Excl. Dependencieswebgoat 15 122 26% 13 694 22% 12 927 27% 13 526 27% 13 083 27% 13 083 27% 13 083
blueblog 692 483 3% 101 302 8% 174 713 46% 3 460 269 29% 5 751 330 29% 7 131 355 OoM OoM
jboard 2 353 761 14% 1 610 077 30% 6 287 863 61% 21 644 040 OoM OoM OoM OoM OoM OoM
pebble 1 769 459 13% 1 112 081 27% 3 237 303 62% 17 128 299 OoM OoM OoM OoM OoM OoM
personalblog 2 194 345 15% 1 664 999 28% 4 839 828 62% 27 837 129 OoM OoM OoM OoM OoM OoM
roller 2 891 553 15% 2 286 229 27% 6 999 622 56% 15 536 275 OoM OoM OoM OoM OoM OoM
snipsnap 2 683 739 14% 1 935 187 28% 17 207 797 63% 26 382 020 OoM OoM OoM OoM OoM OoMIncl. Dependencieswebgoat 734 345 16% 692 080 20% 1 349 476 52% 4 612 198 41% 11 615 079 44% 29 299 712 OoM OoM
JCL 1.7.0 12 069 342 OoM OoM OoM OoM OoM OoM OoM OoM OoM OoM OoM OoM
TABLE II: Run Times of the IFDS Framework in Seconds
Project IFDS-APA FBFSk
k=0k=1k=2k=3
blueblog 0.22 0.32 0.44 0.29 0.26 0.34
jboard 0.02 0.02 0.04 0.01 0.01 0.01
pebble 0.99 0.70 0.81 0.53 0.48 0.49
personalblog 0.14 0.07 0.07 0.05 0.05 0.05
roller 0.07 0.06 0.07 0.05 0.05 0.05
snipsnap 0.32 0.24 0.35 0.21 0.26 0.22Excl. Dependencieswebgoat 0.16 0.10 0.15 0.10 0.10 0.10
blueblog 1.21 1.05 27.15 43.54 54.56 OoM
jboard 322.70 40.81 228.84 OoM OoM OoM
pebble 108.38 17.13 138.40 OoM OoM OoM
personalblog 202.08 24.92 236.65 OoM OoM OoM
roller 478.81 35.19 102.83 OoM OoM OoM
snipsnap 307.65 113.01 203.16 OoM OoM OoMIncl. Dependencieswebgoat 57.75 6.70 30.86 98.14 253.56 OoM
JCL 1.7.0 OoM OoM OoM OoM OoM OoM
ICFG-edges each analysis traverses is shown as a percentage
of all the application‚Äôs ICFG edges in columns denoted as
Vis. The frequency of evaluating Ô¨Çow functions is shown as
an absolute number in columns denoted as Eval. While the
percentage of visited ICFG edges is similar for all approaches
when analyzing the web applications in isolation, we can clearly
see a trend when dependencies are considered: IFDS-APA
visits fewer ICFG edges than the other approaches. The same
trend is visible for the number of Ô¨Çow-function evaluations.
ForFSk, with increasing kthe analysis must compute more
Ô¨Çow functions (for more contexts) but can sometimes restrict
itself to a slightly smaller fraction of the ICFG, due to the
added precision.
To address the second research question, we measured the
execution time of the IFDS framework, excluding the time taken
to load and pre-process the bytecode as well as to compute a
call graph. This pre-computation time is shared by all three
approaches. The results are shown in Table II. All approaches
are able to analyze the web applications in isolation in less than
a second. When dependencies are considered, we can observe
differences in execution times ranging from one second up to
8 minutes for a single approach, depending on the benchmark.
We can see that the FBis faster than IFDS-APA .FSk=0is
faster than IFDS-APA on some applications and slower on
others. Fork>0, FSkis slower than IFDS-APA.C. Discussion
Regarding RQ1 we conclude that memory wise IFDS-APA
scales clearly better than FSkand as well as FB.FSkfails for
higherkvalues when analyzing SecuriBench with dependencies.
All approaches are not able to terminate successfully within
the given memory when analyzing the Java Class Library.
The answer to RQ2 is not as clear. Especially when
including dependencies IFDS-APA is faster than FSkfor some
benchmarks but slower for others. It is also worth noting that
IFDS-APA is always slower than FB, although FB typically
computes more Ô¨Çow functions and traverses larger portions
of the ICFG due to its rather imprecise abstraction that leads
to over-tainting. However, while FBcan traverse the entire
application in a single Ô¨Åxed-point iteration, IFDS-APA must
reconstruct abstracted access-paths on demand and must pro-
actively register callbacks to allow for incoming access paths
computed in later phases of the Ô¨Åxed-point iteration. Our
experiments indicate that the cost of these operations seem to
outweigh savings due to the more precise abstraction.
Before concluding this section, we brieÔ¨Çy consider precision.
By nature, a Ô¨Åeld-sensitive approach can yield more precise
results than a Ô¨Åeld-based approach (see Figure 1b). In k-limiting,
over-approximation is controlled by the value for k. In theory,
k-limiting would achieve the same precision as IFDS-APA ,
ifkis chosen to be at least the length of the longest access
path in the application to be analyzed. This is, considering an
application which does not generate access paths of inÔ¨Ånite
length through loops or recursion as shown in Example 3.
Note that, in contrast, IFDS-APA terminates and achieves
optimal precision (with respect to Ô¨Åeld sensitivity) even for
such programs.
As our experiments further show, choosing a high value for
kwill severly degrade scalability of a k-limiting based approach
in practice. On the other hand, selecting small k-values not only
degrades precision, but may as well be a threat to the scalability,
as more data Ô¨Çows have to be considered that are caused by
the over-approximation. This is indicated by the results shown
in Table I. For example, the application snipsnap excluding
dependencies has more Ô¨Çow-function evaluations for FSk=0than
forFSk=1. In addition, the number of Ô¨Çow-function evaluations
increases again for kvalues set to two or three. Further, a toosmallk-value can even give up soundness. Using IFDS-APA
relieves analysis designers of all those considerations.
We conclude that IFDS-APA implements an analysis that
in terms of precision is at least as precise as FSkand scales
better than FS kfor all values of k‚â•0.
VI. R ELATED WORK
Despite the existence of many data-Ô¨Çow frameworks, we
are not aware of any other framework explicitly handling Ô¨Åeld-
sensitivity and bounding the data-Ô¨Çow domain. Both is usually
left to the clients of the framework. Therefore, we here relate to
Ô¨Åeld-sensitive data-Ô¨Çow analyses and how they model data-Ô¨Çow
domains, and to existing work on abstract summaries .
A. Field-Sensitive Data-Flow Models
The access-path model is broadly used within analyses,
such as alias analyses [3] or taint analyses [1], [2].
One attempt by Deutsch [12] to circumvent the limit of the
access-path model was to use a symbolic representation of an
access path in which reoccurring Ô¨Åeld accesses are grouped
into a single symbolic one. The symbolic notation is close
to a regular expression over the Ô¨Åelds. For example, if two
aliased values are both repeatedly written to a Ô¨Åeld fin the
same loop, Deutsch‚Äôs approach is able to learn that a.fnand
b.fnmay be aliased, whereas nis some arbitrary number
of times the aliased values are nested. The advantage of the
approach is that it is known that the nesting has happened the
same times for both values and that only the n-th nesting is
aliased with each other. While this is a solution to overcome
k-limiting in this special case, it does not solve the general
case. If only one value is considered, nhas no more meaning.
This results in a simple over-approximation comparable to a
variant ofk-limiting as it is applied in FlowDroid.
FlowDroid [2] is a taint analysis for Android applications.
In addition to limiting the access path to be at most of size k,
FlowDroid collapses sub-paths between two equal Ô¨Åeld accesses
in an access path. If a sub-path is collapsed, FlowDroid Ô¨Çags
that this sub path may be repeatedly read. This is an over-
approximation and may result in Ô¨Åelds being read for which a
taint has never been written.
Geffken et al. [13] propose an inter-procedural side-effect
analysis. To ensure Ô¨Åeld-sensitivity, they extend Deutsch‚Äôs
symbolic access path to a generalized access graph , which
models Ô¨Åeld accesses as a directed graph; reappearing Ô¨Åeld
accesses by the same statement correspond to cycles in
the graph. This ensures termination without requiring over-
approximations like k-limiting. So far, they only tested their
analysis on a small benchmark. They do not completely solve
the state explosion problem shown in Figure 5, which is why
we expect scalability issues on benchmarks that include similar
program constructs.
In alias analyses it is also common [14]‚Äì[16] to express
the alias relation within a context-free language (CFL) and
therefore solve a reachability problem over that language. Fields
are part of the language and recursive Ô¨Åeld accesses are grouped
into arbitrary accesses using a wildcard leading to an over-
approximation.B. Abstract Summaries
In [17] Chandra et al. introduce a technique of general-
ization to produce summaries which are applicable to many
data-Ô¨Çow facts. As the proposed tool Snugglebug reasons about
weakest preconditions along the control Ô¨Çow to reach a certain
statement, their data-Ô¨Çow domain consists of conditions. Hence,
their generalization technique differs from ours.
The framework proposed by Yorsh et al. [18] is a more
theoretical approach on how to gain more concise summaries
by composing the Ô¨Çow-functions and their preconditions. As
examples they conduct a typestate analysis and constant
propagation. Within their typestate analysis they reason about
Ô¨Åelds by using 1-limiting, within constant propagation they do
not handle Ô¨Åelds.
Landi and Ryder [19] used in their alias analysis an
approach for which they abstracted access paths as non-visible
inside callees. Using this technique the analysis results for the
procedure become reusable across multiple calling contexts.
When evaluating returns they restore access paths according to
the respective calling contexts. Our approach was independently
developed, but the abstraction at method start points is very
similar to their approach. Yet, the previous work lacks general
support for arbitrary abstraction points, which is why it still
requires over-approximations to limit the size of access paths
and does not address the state-explosion problem.
Jensen et al. [20] represent in their abstraction the whole
state of the heap. As they point out, this makes summaries
nearly impossible to be reused. To obtain more reusable
summaries, they therefore represent properties of the heap as
unknown and recover properties as soon as they are accessed.
They call this concept lazy propagation as properties are
propagated into callees on-demand. When applying summaries
they replace unknown properties by the values available in the
calling context. The idea of abstracting at calls and recovering
abstracted state is very similar to ours. Yet, we are the Ô¨Årst to
show that if applying it at loops and return edges as well one
can remove the need of over-approximations through k-limiting,
thus solving the state-explosion problem.
VII. C ONCLUSION
Within this work we have presented Access-Path Abstrac-
tion, our extension to the IFDS framework to support Ô¨Åeld-
sensitivity within an arbitrary data-Ô¨Çow analysis. Without much
effort, any analysis using IFDS-APA can easily yet precisely
reason about Ô¨Åelds. As our experiments have shown the analysis
will largely gain in terms of efÔ¨Åciency through the precise and
abstract summaries IFDS-APA uses internally: For the Ô¨Årst
time, we managed to scale the tough FlowTwist analysis on the
whole Java Class Library with Ô¨Åeld sensitivity ‚Äì so far even
the Ô¨Åeld-based approach did not scale. Finally, introducing the
more abstract summaries, we also managed to abandon any
need fork-limiting within the access-path model, herein we
see a huge proÔ¨Åt for existing and future analyses.
ACKNOWLEDGMENTS
This work was supported by the BMBF within EC SPRIDE,
by the Hessian LOEWE excellence initiative within CASED,
by the DFG Collaborative Research Center CROSSING and
the Emmy Noether Group RUNSECURE.REFERENCES
[1] O. Tripp, M. Pistoia, P. Cousot, R. Cousot, and S. Guarnieri, ‚ÄúAn-
dromeda: Accurate and scalable security analysis of web applications,‚Äù
inFundamental Approaches to Software Engineering , ser. Lecture Notes
in Computer Science, 2013, pp. 210‚Äì225.
[2] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel, J. Klein, Y . Le Traon,
D. Octeau, and P. McDaniel, ‚ÄúFlowDroid: Precise context, Ô¨Çow, Ô¨Åeld,
object-sensitive and lifecycle-aware taint analysis for android apps,‚Äù in
Proceedings of the 35th ACM SIGPLAN Conference on Programming
Language Design and Implementation , ser. PLDI ‚Äô14, 2014, pp. 259‚Äì269.
[3] A. De and D. D‚ÄôSouza, ‚ÄúScalable Ô¨Çow-sensitive pointer analysis for java
with strong updates,‚Äù in Proceedings of the 26th European Conference
on Object-Oriented Programming , ser. ECOOP‚Äô12, 2012, pp. 665‚Äì687.
[4] N. D. Jones and S. Muchnick, ‚ÄúFlow analysis and optimization of lisp-
like structures,‚Äù in In Proceedings of the Symposium on Principles of
Programming Languages (POPL) , ser. POPL ‚Äô79, 1979, pp. 244‚Äì256.
[5] T. Reps, S. Horwitz, and M. Sagiv, ‚ÄúPrecise interprocedural dataÔ¨Çow
analysis via graph reachability,‚Äù in Proceedings of the 22nd ACM
SIGPLAN-SIGACT symposium on Principles of programming languages ,
ser. POPL ‚Äô95, 1995, pp. 49‚Äì61.
[6] E. Bodden, ‚ÄúInter-procedural data-Ô¨Çow analysis with IFDS/IDE and
Soot,‚Äù in 1st ACM SIGPLAN International Workshop on the State Of
the Art in Java Program Analysis , ser. SOAP ‚Äô12, 2012, pp. 3‚Äì8.
[7] N. A. Naeem and O. Lhotak, ‚ÄúTypestate-like analysis of multiple
interacting objects,‚Äù in Proceedings of the 23rd ACM SIGPLAN
Conference on Object-oriented Programming Systems Languages and
Applications , ser. OOPSLA ‚Äô08, 2008, pp. 347‚Äì366.
[8] J. Lerch, B. Hermann, E. Bodden, and M. Mezini, ‚ÄúFlowtwist: EfÔ¨Åcient
context-sensitive inside-out taint analysis for large codebases,‚Äù in
Proceedings of the 22Nd ACM SIGSOFT International Symposium on
Foundations of Software Engineering , ser. FSE ‚Äô14, 2014, pp. 98‚Äì108.
[9] P. Lam, E. Bodden, O. Lhot ¬¥ak, and L. Hendren, ‚ÄúThe Soot framework
for Java program analysis: a retrospective,‚Äù in Cetus Users and Compiler
Infrastructure Workshop , ser. CETUS ‚Äô11, 2011.
[10] J. Lerch and B. Hermann, ‚ÄúDesign your analysis: A case study on
implementation reusability of data-Ô¨Çow functions,‚Äù in 4th ACM SIGPLAN
International Workshop on the State Of the Art in Program Analysis ,
ser. SOAP ‚Äô15, 2015.[11] B. Livshits, ‚ÄúStanford SecuriBench,‚Äù http://suif.stanford.edu/ ‚àºlivshits/
securibench/, 2005, version 91a.
[12] A. Deutsch, ‚ÄúInterprocedural may-alias analysis for pointers: Beyond
k-limiting,‚Äù in Proceedings of the ACM SIGPLAN 1994 Conference
on Programming Language Design and Implementation , ser. PLDI ‚Äô94,
1994, pp. 230‚Äì241.
[13] M. Geffken, H. Saffrich, and P. Thiemann, ‚ÄúPrecise interprocedural
side-effect analysis,‚Äù in Theoretical Aspects of Computing , ser. ICTAC
‚Äô14, 2014, pp. 188‚Äì205.
[14] M. Sridharan, D. Gopan, L. Shan, and R. Bod ¬¥ƒ±k, ‚ÄúDemand-driven points-
to analysis for java,‚Äù in Proceedings of the 20th Annual ACM SIGPLAN
Conference on Object-Oriented Programming, Systems, Languages, and
Applications , ser. OOPSLA ‚Äô15, 2005, pp. 59‚Äì76.
[15] D. Yan, G. H. Xu, and A. Rountev, ‚ÄúDemand-driven context-sensitive
alias analysis for java,‚Äù in Proceedings of the 20th International
Symposium on Software Testing and Analysis , ser. ISSTA ‚Äô11, 2011, pp.
155‚Äì165.
[16] G. H. Xu, A. Rountev, and M. Sridharan, ‚ÄúScaling CFL-reachability-
based points-to analysis using context-sensitive must-not-alias analysis,‚Äù
inProceedings of the 23rd The European Conference on Object-Oriented
Programming , ser. ECOOP ‚Äô09, 2009, pp. 98‚Äì122.
[17] S. Chandra, S. J. Fink, and M. Sridharan, ‚ÄúSnugglebug: a powerful
approach to weakest preconditions,‚Äù in Proceedings of the 2009
ACM SIGPLAN Conference on Programming Language Design and
Implementation , ser. PLDI ‚Äô09, 2009, pp. 363‚Äì374.
[18] G. Yorsh, E. Yahav, and S. Chandra, ‚ÄúGenerating precise and concise
procedure summaries,‚Äù in Proceedings of the 35th ACM SIGPLAN-
SIGACT Symposium on Principles of Programming Languages , ser.
POPL ‚Äô08, 2008, pp. 221‚Äì234.
[19] W. Landi and B. G. Ryder, ‚ÄúA safe approximate algorithm for
interprocedural aliasing,‚Äù in Proceedings of the ACM SIGPLAN 1992
Conference on Programming Language Design and Implementation , ser.
PLDI ‚Äô92, 1992, pp. 235‚Äì248.
[20] S. H. Jensen, A. M√∏ller, and P. Thiemann, ‚ÄúInterprocedural analysis with
lazy propagation,‚Äù in Proceedings of the 17th International Conference
on Static Analysis , ser. SAS‚Äô10, 2010, pp. 320‚Äì339.