Augusto: Exploiting Popular Functionalities for the Generation
of Semantic GUI Tests with Oracles
Leonardo Mariani
University of Milano-Bicocca
mariani@disco.itMauro Pezzè
University of Milano-Bicocca
USI Università della Svizzera italiana
mauro.pezze@usi.chDaniele Zuddas
USI Università della Svizzera italiana
daniele.zuddas@usi.ch
ABSTRACT
Testingsoftwareapplicationsbyinteractingwiththeirgraphical
user interface (GUI) is an expensive and complex process. Current
automatictestcasegeneration techniques implementexplorative
approachesthat,althoughproducingusefultestcases,havealim-
ited capability of covering semantically relevant interactions, thus
frequently missingimportant testing scenarios. Thesetechniques
typicallyinteractwiththeavailablewidgetsfollowingthestructure
oftheGUI,withoutanyguessaboutthefunctionsthatareexecuted.
InthispaperweproposeAugusto,atestcasegenerationtech-
niquethatexploitsabuilt-inknowledgeofthesemanticsassociated
with popular and well-known functionalities, such as CRUD opera-
tions,toautomaticallygenerateeffectivetestcaseswithautomated
functionaloracles.EmpiricalresultsindicatethatAugustocanre-
veal faults that cannot be revealed with state of the art techniques.
CCS CONCEPTS
•Software and its engineering →Software testing and de-
bugging;
KEYWORDS
GUI testing, automatic test case generation, semantics, oracles
ACM Reference Format:
Leonardo Mariani, Mauro Pezzè, and Daniele Zuddas. 2018. Augusto: Ex-
ploitingPopular FunctionalitiesfortheGenerationof SemanticGUITests
withOracles.In ICSE’18:ICSE’18:40thInternationalConferenceonSoftware
Engineering , May 27-June 3, 2018, Gothenburg, Sweden. ACM, New York,
NY, USA, 11 pages. https://doi.org/10.1145/3180155.3180162
1 INTRODUCTION
Testingsoftwareapplicationsatthe systemlevel requiresexecuting
theapplicationsthroughtheirinterfacestoverify thecorrectness
ofthefunctionalitiesandstimulatingallthelayersandcomponents
involved in the execution. Since the number and complexity of
the entities typically involved in a system-level execution could be
significant,definingtestcasesthatthoroughlysampleandverify
thebehaviorofanapplicationisadifficultandexpensiveprocess.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
©2018 Copyright held by the owner/author(s). Publication rights licensed to the
Association for Computing Machinery.
ACM ISBN 978-1-4503-5638-1/18/05 ...$15.00
https://doi.org/10.1145/3180155.3180162Automating just part of this process can dramatically improve the
effectiveness of software verification activities and significantly
reducedevelopmentcosts,partiallyalleviatingsoftwaredevelopers
from their verification effort.
Inthispaperweaddresstheproblemofautomaticallygenerat-
ing system test cases for interactive applications , that is, applica-
tionsthatinteractwiththeusersthroughGraphicalUserInterfaces
(GUIs). Interactiveapplications (from nowon simply applications )
are commonly available in several contexts, including desktop and
mobile environments, and are exploited in many domains, ranging
from leisure and travel to banking and insurance.
Techniques for automatically testing interactive applications
exploit structural information extracted from either the GUI orthe code to generate system test cases. The techniques that ana-lyze the structure of the GUI generate test cases that cover GUIelements based on combinatorial interaction testing and variousheuristics [
28,32,35,43]. Those that analyze the source code in-
stead exploit search-based and symbolic execution to generate test
cases that exercise code items [18, 19, 27].
State-of-the-art techniques suffer from two relevant limitations:
theineffective exploration of the execution space and thelack of
oracles.To illustratetheselimitationslet usconsiderafault inthe
signupfunctionalityofOnShop,ademoe-commerceapplication
available on git-hub [ 24]. Listing 1 shows an excerpt of the code
that handles the user registration in OnShop.
300 private void signup() {
301 if(isValidForm()) {
302 insertIntoDB();
303 JOptionPane.showMessageDialog(SignupPanel, "Please␣Login␣to␣get␣Started!",
"Congratulations", JOptionPane.DEFAULT_OPTION);
...
308 card.show( this.getParent(), "startCard"); //Return to Initial Window
309}else
310 resetForm();
311}
315 private void insertIntoDB() {
...
334 if(resultSet.next()) { //User Already Exists
335 JOptionPane.showMessageDialog(SignupPanel,"Username␣already␣exists");
336 resetForm();
337}
Listing 1: Faulty User Registration in OnShop
When a new user registers, the signupfunction is executed
(line300).Ifthesignupformhasbeencorrectlyfilledin,function
isValidForm returnstrue(line301),andfunction insertIntoDB
is invoked(line 302).If the usernamechosen bythe user hasbeen
already taken by another user, this function correctly shows anerror message to the user (line 335). The execution then returnsto function
signupand a message that informs the user that the
registration has been completed correctly is also shown to the user
(line303).Finally,theapplicationisredirectedtotheinitialwindow
2802018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:12 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Leonardo Mariani, Mauro Pezzè, and Daniele Zuddas
expectingtheusertologin(line308).Thisfaultisquiteconfusingfor
auserbecausetheapplicationshowsboththebehaviorofacorrect
and incorrect registration in response to a single user request.
This fault cannotbe automatically detected with state-of-the-art
techniques. To reveal this fault, a testing technique has to produce
a test case that performs a correct sign up twice while filling the
username field always with the same value. In OnShop, this test
scenariorequiresasequenceofatleast20specificGUIactionsto
be covered. Considering the number of GUI actions that can be
executed at every step of the execution, it is very unlikely that this
scenario is covered with explorative approaches. Indeed, in our
experimentsnoneofthecompetingtechniqueshavebeenableto
cover this scenario ( ineffective exploration of the execution space ).
Moreover,evenifthisscenarioiscoveredbychance,noneofthe
available techniques would interpret the response of the system as
a failure. The application produces an erroneous result, in terms of
awrongoutputmessageandanincorrecttransitiontotheinitial
window,whilestateoftheartsolutionslookforuncaughtexcep-
tions and system crashes [ 6], which is not the case for the OnShop
signupfault.Thus,evenwhenthescenarioiscovered,nofailure
would be reported to the user ( lack of oracles ).
Toaddressboththeineffectiveexplorationoftheexecutionspace
andthelackoforacles,thispaperproposes Augusto(AUtomaticGUi
Semantic Testing and Oracles), an approach that exploits common
sense knowledge to automatically generate semantically-relevant
test cases equipped with functional oracles that can reveal faults
suchastheonediscussedabove.Inparticular,Augustoisableto
(i)cost-effectivelyproducetestcaseswithusefulcombinationsof
actionsonly,incontrastwithtechniquesthatgeneratetestcases
with many unrelated and irrelevant actions, and (ii) detect failures
thatdependonthesemanticsoftheapplication,incontrastwith
techniques revealing crash-like failures only.
Augustoreliesontheintuitionthatthereexistsmanypopular
functionalitiesthatareimplementedinsimilarwaysandrespond
to a same semantics when they occur in interactive applications.
Duetotheirpopularity,thesemanticsofthesefunctionalitiesisnottypicallyprovidedexplicitlysinceusersanddevelopershavealready
clear expectations. We indicate this shared expectation as common
senseknowledge ,andthesefunctionalitiesas applicationindependent
functionalities(AIF) .ExamplesofAIFsareauthenticationoperations,
CRUD (Create, Read, Update, Delete) operations, and search and
bookingoperations.Thesefunctionalitiesarepervasivelypresentin
softwareapplications,and,despiteminordifferences,theirbehavior
remains always the same [8, 40, 42].
Onatestingperspective,AIFsrepresentauniqueopportunity:
theirsemanticscanbespecified onceforall accordingtocommon
senseknowledge,tobethen automaticallyadaptedandreused to
test the specific AIFs present in the applications under test. In this
way a relevant subset of the features present in an application (e.g.,
considerthenumberofCRUDoperationsthataretypicallypresentin an application) can be tested automatically, alleviating the tester
from part of the verification effort. For instance, the authentica-
tionbugpresentintheonShopapplicationcanbe revealedusing
Augusto with virtually no effortfor the tester.
Augusto exploits the characteristics of AIFs to define an auto-
matic testing process by introducing (i) an encoding of the seman-
ticsofAIFswithAlloy[ 22],whichprovidesaflexibleandpowerfulwaytospecifyhowafunctionalityaffectsthestateofanapplication,
(ii) a technique to discover the AIFs by analyzing the GUI of the
application under test, (iii) a strategy to extract the specific seman-
tics of AIFs and to automatically reflect the discovered information
intotheAlloymodel,and(iv)asolutiontogenerateeffectivetest
suites equipped with a functional oracle. Note that Augusto is not
alternative but complementary to otherautomatic techniques:Au-
gustocan efficiently andeffectively testAIFs,whiletherestofthe
functionalities can still be addressed with existing approaches.
In our evaluation, Augusto automatically recognized and ef-
fectivelytestedseveralAIFsacross7interactiveapplicationsand
revealed 7 real faults1. We compared Augusto to Guitar [ 37] and
ABT[28],tworepresentativestate-of-the-arttechniques,anddis-
overedthatonly2ofthesefaultscouldberevealedbythecompeting
approaches,whiletheineffectiveexplorationoftheexecutionspace
andthe lackofaoracle preventedtheidentification oftheother5
faults. This result corroborates our hypothesis that Augusto can be
significantlymoreeffectivethanstate-of-the-artapproacheswith
AIFs,andthatanautomaticsystemtestingprocessshould exploit
bothAugusto, to test AIFs, and other approaches to test non-AIFs.
The paperis organizedas follows.Section 2 discussesthe char-
acteristics of AIFs. Section 3 presents Augusto. Section 4 describes
the empirical results. Section 5 discusses related work. Section 6
provides final remarks.
2 APPLICATION INDEPENDENT
FUNCTIONALITIES
Inthisworkweusetheterm functionality torefertoasemantically
cohese and correlated set of user operations available on the GUI of
an application, for instance, a set of CRUD operations all referring
to the same entity type (e.g., money transactions). Thus a single
AIF may correspond to several user operations.
Manyfunctionalitieshaveaconsistentlysimilarbehaviorthat
cannot be distinguished across applications, once abstracting away
fromconcretedetails.Forinstance,searchandsaveoperationsmay
affectdifferentkindsofentities,butinallcasestheysearchandsaveanentityofsometype.Werefertothemas applicationindependent
functionalities (AIF) . AIFs satisfy the following properties:
•theyarecommonlypresent inseveralapplications,somemight
be more common in certain domains, for instance the cart func-
tionality is very common in the e-commerce domain, whereas
others are generally common, such as CRUD functionalities;
•theirsemanticsislargely applicationindependent thusitcanbe
defined abstractly in a way that is independent on the specific
application.Forexample,thegeneralsemanticsofCRUDfunc-
tionalities does not depend on the type of the handled object;
•theycanbeactivatedfromtheGUIaccordingtostructural GUI
patternsthatuserscanrecognize[ 40,42].Forinstance,thesign
inandsignupfunctionalitiesinmanyapplicationsusesimilar
setsofwidgets,althoughthesewidgetshavedifferentlookand
feel and placements in the windows.
Becauseoftheirpopularity,thesemanticsofAIFsispartofusers’
common sense knowledge , thus they can be intuitively used without
requiring special documentation and manuals.
1Toolandexperimentalmaterialareavailableathttp://github.com/danydunk/Augusto.
281
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:12 UTC from IEEE Xplore.  Restrictions apply. Augusto ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Match 
Finalizing
Te s t i n g
 Ripping
Structural
Matching
GUI Model Raw Match
Interactive 
Application
Test ReportsAIF Recognition
Full
Match
Reiﬁcation
Concrete
MatchAIF Archive
GUI Pattern
 Abs. SemanticsAIF 1
…
AIF 2
AIF 3<READ>
<READ>
Figure 1: Augusto logical architecture
Theauthentication AIF, composed of the sign in, sing up, and
signoutoperations,isagoodexampleofAIFsince:(i)itprovides
an overall functionality, authentication, which can be found in
many applications, (ii) its semantics is well-known and mostlyindependent on the specific application, and (iii) its presentation
on the GUI is predictable and easily recognisable.
Apartfrom authentication,thereare severalotherexamplesof
AIFs:thefunctionalityofcreating,reading,updatinganddeleting
(CRUD) objects of a type, the functionality of saving the work on a
fileandthenreloadingit,thefunctionalityofsearchingandthen
booking a certain service (car, hotel, flight), the functionality of
handling an e-commerce cart, etc. Despite their diffusion, AIFscaneasilyincludefaults, eveninextremely popular applications,
andthusrequirecarefultesting.Forinstance,faultsimpactingan
extensivenumberofusershavebeenreportedforCRUDoperations
in Jenkins [23] and for authentication operations in Dropbox [16].
Thegeneralideathatfunctionalitiesrecurinasimilarwayinthe
GUIofdifferentapplicationshasbeenalreadyinvestigatesinthe
fieldofUIdesign.ThereexistscatalogsofUIdesignpatterns[ 40,42]
anddesigningtools[ 8]thatallowtocreateanewGUIbycomposing
thesepatterns.EveniftheconceptofUIdesignpatternisnotexactly
thesame ofAIF, manyUIdesign patternsturn outtobe alsoAIFs.
Augusto exploits the presence of AIFs to automatically generate
semantically relevant test cases equipped with functional oracles.
3 AUGUSTO: AUTOMATED AIFS TESTING
Augustoisanautomatictestcasegeneratorforapplicationindepen-
dentfunctionalities (AIFs):itexploitsthe application-independent
semanticsofAIFstoautomaticallyidentifyandtesttheAIFspresent
in interactive applications. The intuition is that, ideally, an AIF can
be modelled once for all and then be exploited to effectively testany occurrence of the modeled AIF in any application. Augusto
supports this intuition by offering the capabilities to discover AIFs,
to automatically adapt the models to the application under test
(AUT), and to generate effective test cases equipped with oracles.
To study the effectiveness of the approach, we provide an initial
definition for several AIFs. Of course, the set of the defined AIFs
canbefurtherextended toincreasethescopeandapplicability of
the approach. Note that testers do not have to do any modelingeffort because they can benefit from the AIF definitions already
present in the tool.
Intherestofthissection,wefirstprovideanoverviewofAugusto
and thendiscuss the individualelements andsteps of theapproach.3.1 Overview
Figure1showsthelogicalarchitectureofAugusto.The AIFArchive
istherepositorythatcontainsthesetofAIFssupportedbyAugusto.
EachAIFismodelledasapair <GUIPattern ,AbstractSemantics >,
where the GUI Pattern specifies the set of windows and widgets
that may refer to the AIF (Section 3.2), and the Abstract Semantics
specifies the behavior of the AIF (Section 3.3).
Augustoworksinfivesteps.The Rippingstepexecutestheap-
plicationundertesttodynamicallyextracttheGUImodel,which
is a partial model of the structure of the GUI (Section 3.4). The
Structural Matching step exploits the GUI Model to identify the
AIFs, by searching for instances of the GUI Patterns in the GUI
Model(Section3.5).Thisstepproducesasetofrawmatches,which
canbepartial,thatis,onlyasubsetofaGUIPatternmightmatch
the GUI Model. Augusto supports partial matches because the GUI
Model extracted through ripping might be incomplete. The Match
Finalizing step generates additional executions aiming to complete
the partial matches while verifying the consistency between the
behaviorsspecifiedintheAbstractSemanticsmodelandthebehav-
ioroftheapplication(Section3.6).Thisstepproducesasetoffull
matches,whichincludeseveryAIFsthathavebeenfullymatchedin
terms of its GUI pattern and its abstract semantics. The Reification
step further refines the full matches extracting properties about
the concrete behavior of the application (Section 3.7). For instance,
everyCRUDoperationmayincludeadifferentnumberofunique
andmandatoryfieldsforthecreationofanentity.Augustoextracts
these properties by stimulating the application with different com-
binationsofinputs.Thisstepproducesasetofconcretematches,
each being an AIF that occurs in the application under test. The
concretematchesareassociatedwithsemanticsinformationthat
takes intoconsideration the specificcharacteristics of theapplica-
tionundertest.Finally,the Testingstepgeneratesandexecutestest
cases that both combine multiple operations in a semantically rele-
vant way and include a functional oracle to check the correctness
of the results produced by the application (Section 3.8).
3.2 GUI Pattern Model
TheGUIpatternmodelspecifieshowacertainAIFgenerallyoccurs
on the GUI of interactive applications, and it is used by Augusto
toautomaticallyrecognizewhethertheAUTimplementstheAIF.
Even though there exists powerful UI modelling languages such
asIFML[ 12],theselanguagesaremeanttomodelthe concreteUI
of a specific application, and they are not meant to model abstract
portions of UIs that must be general and flexible and that can fit
282
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:12 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Leonardo Mariani, Mauro Pezzè, and Daniele Zuddas
multipleapplications.Forthisreasonwedefinedanadhoclanguage
for the GUI pattern model.
ThelanguagewedefinedfortheGUIPatternmodelsspecifies
how AIFs occur in GUIs as sets of abstract windows that contain
abstract widgets and are connected through abstract edges .
Anabstractwindow identifieswindowsoftheapplication.Itis
definedas asetof abstractwidgetsthat arerequiredto bepresent
inthewindow.An abstractwidget abstractlyreferstoawidgetin
the GUI, and might be of type (i) action, which represents widgets
thatcanbeclicked,forinstancebuttons,(ii) input,whichrepresents
widgets that can be used to enter data, for instance text fields, and
(iii)selectable , which represents widgets that can be selected, for
instancelistsortables.Abstractwidgetsareannotatedwithboth
regularexpressions,whichspecifythelabelsthatmustbeassociated
withthewidgets,andcardinality,whichexpressesthequantityof
that particular widget that can be in a window and can be either
one (exactly 1), some (1 or more), none (no occurrences), lone (1 or
0) or any (0 or more).
<window id="loginform"  card=one>
<action_widget  id="signup"  card=lone>
<label>^(register|signup|sign up).*$ </label>
</action_widget >
<action_widget  id="login" card=one>
<label>^(login|enter|sign in).*$ </label>
</action_widget >
<input_widget  id="pass" card=one>
<label>^(pass|password).* </label>
</input_widget >
<input_widget  id="user" card=one>
<label>^(user|username|email).* </label>
</input_widget >
</window>
<window id="signupform"  card=one>
<action_widget  id="register"  card=one>
<label>^(ok|save|record|signup|sign up) </label>
</action_widget >
<input_widget  id="signupuser"  card=one>
<label>^(user|username|email).* </label>
</input_widget >
<input_widget  id="signuppass"  card=one>
<label>^(?!re-enter|repeat)(pass|password).* </label>
</input_widget >
<input_widget  id="signuppass2"  card=lone>
<label>^(repeat|re-enter|confirm).* </label>
</input_widget >
<input_widget  id="otherfields"  card=any>
<label>.*</label>
</input_widget >
</window>
<window id="loggedpage"  card=some>
<action_widget  id="logout"  card=one>
<label>^(logout|exit|sign out|signout).*$ </label>
</action_widget >
</window>
<edge type=uncond from=signup to=signupform />
<edge type=uncond from=logout to=loginform />
<edge type=cond from=register  to=loginform;loggedpage />
<edge type=cond from=login to=loggedpage />
Figure 2: AUTH GUI Pattern model
Figure 2 shows a simplified GUI pattern for the authentica-
tion AIF (for the complete model see http://github.com/danydunk/
Augusto).Thepatternisdefinedinxmlformat.The windowxmlele-
mentsdefinetheabstractwindowsthatcorrespondtothewindows
of the application. For instance, the loginabstract window corre-
sponds to the presence of a window that includes an input field for
the username, an input field for the password, an action widget to
login,andanoptionalactionwidgetforregistering.Thedefinitions
are flexible. They are not bound to specific GUI widgets, for in-
stance buttons, but refer to general classes of widgets, for instance1/* GUI elements definition */
2sigloginform, signupform, loggedpage extends Window{}
3siglogin, signup, register, logout extends Action_widget{}
4siguser, pass, pass2, ..., otherfields extends Input_widget{}
5one sig Curr_win { /* Current window */
6is_in:Window one-> Time,
7}
8/* Functionality internal state elements */
9sigUsr {
10username :oneValue,
11password :oneValue
12}
13sigUsers{
14list:Usr set-> Time
15}
16/* Semantic Property */
17one sig Required{
18fields:setotherfields
19}
20predpreconditions [w :Widget, t :Time] {
21winregister =⇒ notuser.content.t =none∧notpass.content.t =none∧
22(∀us:Users.list.t | user.content.t /nequalus.username) ∧
23pass.content.t =pass2∧(∀iw:Required.fields | notiw.content.t =none)
24}
25predpostconditions [w :Widget, t,t' :Time] {
26winregister =⇒ oneus:Users | us.username =user.content.t ∧
27us.password =pass.content.t ∧Users.list.t' =Users.list.t+us ∧
28(Curr_win.is_in.t' =loginform ∨Curr_win.is_in.t' =loggedpage)
29}
Figure 3: AUTH Abstract Semantics model
action widgets, and allow elements to be optional, for instance the
registeractionwidgetinthe loginwindow.Theflexibilityinthe
definition of the cardinality is also useful for abstraction, for ex-
ample the cardinality of the otherfields field in the signupform
abstract window allows the pattern to match an arbitrary number
offields.Thepatterndefinitionallowsforadditionalelements,that
is,awindowmatchinganabstractwindowmayincludeelements
not specified in the pattern.
Abstract edges connect an action widget of an abstract window
to another abstract window to indicate possible execution flows.
Unconditional abstract edges indicate that the target window is
always reached when interacting with the source action widget,
for example clicking on a navigation menu. Conditional abstract
edges indicate that the target window is reached only if certainpreconditions are satisfied, for instance successfully submittinga form. The definition in Figure 2 uses two conditional and two
unconditionaledges.Uncertaintyisrepresentedasalistofpossible
targetwindows.For exampletheedgeassociated withthe register
action widget indicates that once registered the execution may
reach either the welcome page (automatic login) or the login form.
Abstract windows are logical windows, thus a same concrete
windowofanapplicationmayhostmultiplelogicalwindows,forin-
stance the login and registration abstract windows might be found
in a same concrete window. Windows may have a cardinality to
indicate that they are not required to be present in the target appli-
cation. This might be useful for example in cases like confirmation
windows which might or might not be shown in an application.
3.3 Abstract Semantics Model
TheAbstractSemantics modeldescribesthebehaviorofanAIF,and
formallyspecifiestheeffectontheapplicationoftheinteractions
withthewidgetsdefinedinthecorrespondingGUIPatterninterms
of: (i) the condition necessary to successfully execute an operation
283
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:12 UTC from IEEE Xplore.  Restrictions apply. Augusto ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
(precondition); (ii) the window that is shown after the execution
ofanaction(transition);(iii)thestateoftheapplicationafterthe
execution of the action (postcondition). Augusto uses the abstract
semantics model to generate test cases and oracles.
We specifytheAbstract Semanticsmodel usingtheAlloy spec-
ificationlanguage[ 22],chosenbecauseofbothitssimplicityand
expressiveness,andtheefficiencyoftheAlloyAnalyzer,anauto-
matictoolabletoanalyzeanAlloymodelandsimulatetheexecution
of the operations defined in the model.
Figure 3 shows an excerpt of the Abstract Semantics model of
theauthenticationAIFwhosepatternmodelisshowninFigure2
(for the complete model see http://github.com/danydunk/Augusto).
Themodeldeclaresthewindowsandthewidgetsrelevanttothe
specified functionality (lines 2–4). The widgets defined in the GUI
patternareannotatedwithatag(notshownintheexample)whose
value is the identifier of the corresponding widget in the Alloy
model. In this way, after mapping a GUI Pattern to the concrete
GUI of the application, every action on a widget can be associated
with its semantics expressed inAlloy. Then the model defines the
statevariablesthatarenecessarytodefinethebehaviorofthefunc-
tionality(lines5–15).Inthefigure,themodeldefinesthecurrent
window (lines 5–7) and the list of registered users (lines 9–15).
Finallythemodeldefinesthepreconditions(lines20–24)andthe
postconditions (lines 25–29) of the operations. The figure showspre and postconditions only for the registration operation. The
preconditionrequirestheusername( user)andthepassword( pass)
tobenotempty,therepeatedpassword( pass2)tobethesamethan
thepassword,alltherequiredfields( Required.fields )tobenot
empty,andtheusernametobeunique.Thepostconditionaddsa
new user to the set of registered users and changes the current
windowtoeitherthe loginForm ortheloggedPage window.For
simplicity we omitted some of the checks in the precondition, such
as the individual validity checks on the input fields.
The behavior of an AIF can be specified only partially, since
it may depend on some specific semantic properties that change
fromapplication toapplication. Augustocan enrichthemodel by
automatically plugging-in semantic properties inferred during the
Reificationstep.Tosupportsemanticproperties,themodelspecifies
in advance one or more items that might be affected by a property
that will be fully defined at a later stage. In a sense, the model
mustbereadytoincorporatethepropertiesthataredynamically
extracted by running the application under test. In the model in
Figure 3, the item Required , which expresses the concept of some
fieldsrequiredto befilled in tosubmit the registrationform, is an
exampleofapropertythatisindicatedinadvancesimplyasaset
of fields (from line 17 to line 19) and that is refined based on the
interactionwiththeactualapplication.Wediscussthesupported
properties and the strategy to infer them in Section 3.7.
3.4 Ripping
TheRippingstep produces a graph that represents the structure of
theGUIoftheinteractiveapplicationininput,followingtheGUI
ripping technique defined by Memon et al. [ 32]. Augusto creates
the graph by recursively clicking on all the widgets in the GUI
accordingtoadepthfirststrategyandcreatinganodeforeverytra-
versed window and an edge for every observed transition betweenwindows.Augustoannotatesthenodeswithdetailedinformation
about all the widgets displayed in the windows.
Ripping may not be able to discover all the edges and windows.
In particular, it might be unable to traverse some conditional edges
becauseitmightfailinsatisfyingthepreconditionofthefunctional-ityassociatedwiththeedge.Augustoaddressesthisincompleteness
when recognizing AIFs in the next steps of the process.
3.5 Structural Matching
TheStructuralMatching stepsearchesfor rawmatches betweenthe
AIFs defined in the AIF archive and the GUI model produced in the
rippingphase. Inparticular,a rawmatchisa subgraph ofthe GUI
Model (i.e., a subset of its windows and edges) that includes all the
elements of a GUI Pattern that can be discovered through ripping.
Morerigorously,awindow wintheGUImodel(i.e.,anodeofthe
graph)matchesanabstractwindow awifthereexistsamatching
widgetin wforeachabstractwidgetin aw.Awidgetmatchesan
abstractwidgetifthewidgetisofthetypedefinedintheabstract
widget(eitheraction,inputorselectable)anditslabelisaccepted
by the regular expression defined in the abstract widget. When the
label is not on the widget itself, the label is identified by searching
foradescriptorplacednearbythewidgetaccordingtothealgorithm
definedbyBecceetal.[ 7].Thematchingbetweenawindowand
anabstractwindowconsidersthecardinalityofthewidgets.The
left part of Figure 4 shows a match between the definition of the
loginform abstract window and the Sign In window of OnShop.
Since the GUI model extracted through ripping does not include
conditionaledges,thestructuralmatchingconsidersonlytheun-
conditional edges defined in the GUI pattern. In practice, Augusto
finds a raw match if it recognizes all the windows reachable by
navigatingtheunconditionaledgesoftheGUIpatternintheGUI
model.Theconditionaledges,ifpresentinthepattern,aresearched
in the next step.
Forexample,theportionofGUIrelevanttotheauthentication
pattern discovered through ripping in the onShopapplication cor-
responds to the two windows shown in Figure 4 inside the grey
frame. These windows are the windows reachable by navigating
unconditionaledgesonly(unconditionaledgesareshownwitha
greenthicklineinFigure4).Thesetwowindowscorrespondtotwo
oftheabstractwindowsthatcomposetheauthenticationpattern
reportedinFigure2,thusgeneratingarawmatchbetweentheGUI
model and the AUTH pattern.
Ingeneral,theproblemofidentifyingGUIpatternsintheGUI
model is an instance of the subgraph isomorphism problem, which
isproventobeNP-complete[ 15].However,sincethenumberofdis-
tinct windows in an application is commonly low, the problem can
be solved in few seconds, as confirmed in our empirical experience.
3.6 Match Finalizing
TheMatch Finalizing step aims to complete the raw matches, that
is,eachrawmatchiseitherdiscardedorextendedtoafullmatch
by including the conditional edges.
Foreachconditionaledgetobeconfirmed,Augustogenerates
a probing GUI interaction that samples the edge. A probing GUI
interactionisatestcasethatterminateswithanexecutionofthe
conditionaledgeintheAUTwhenitspreconditionissatisfied.If
284
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:12 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Leonardo Mariani, Mauro Pezzè, and Daniele Zuddas
<window id="loginform"  card=one>
<input_widget  id="user" card=one>
<label>^(user|username|email).* </label>
</input_widget >
<input_widget  id="pass" card=one>
<label>^(pass|password).* </label>
</input_widget >
<action_widget  id="login" card=one>
<label>^(login|enter|sign in).*$ </label>
</action_widget >
<action_widget  id="signup"  card=lone>
<label>^(register|signup|sign up).*$ </label>
</action_widget >
</window>
Figure 4: A simplified version of the OnShop GUI. The windows in the grey frame are those that are discovered by the
ripping. Dashed red edges are discovered during the match finalizing step.
itsexecutionreachestheexpectedwindowandsatisfiesthepost-
conditionassociatedwiththeedgeintheAbstractSemanticsmodel,
Augustoconfirmsthepresenceoftheconditionaledge,andaddsthe
edge,aswellasanynewlydiscoveredwindow,totheGUImodel.
If Augusto succeeds in confirming every conditional edge relevant
to the pattern that originated the raw match, it transforms the raw
match into a full match, otherwise it discards the raw match.
In some cases, a conditional edge may have more than one pos-
sible resulting window, such as for the conditional edge associated
withtheregisterwidgetdefinedinFigure2.Accordingtothepat-
ternafteraregistrationhasbeensuccessfullycompleted,aprogram
is expected to reach either the login or the welcome (abstract) win-
dow.InthesecasesAugustoexpectsaconsistentbehaviorfromthe
application,thatis,whensuccessfullyexecutingaconditionaledge
it expects the application to always reach the same window.
AugustogeneratestheprobingGUIinteractionsexploitingthe
Alloy Analyzer, which can be instructed to generate a sequence of
GUIactionsthatcoversacertainoperationorconditionoftheAlloymodel.TheAlloyAnalyzerrequiresininputtheabstractsemantics
model, a condition that must be covered, and the maximum length
of the interaction sequence that must be produced. In this case, the
Alloy Analyzer is asked to generate sequences, of length up to a
given boundary, that execute the patterns conditional edges.
IfthetestedAIFisnotavailableintheinitialwindowoftheAUT,
Augusto analyzes the GUI model to find the shortest sequence
of actions that reaches the window with the AIF from the initial
window, and adds this sequence as a prefix of the probing GUI
interaction generated with the Alloy Analyzer.
When executing a GUI interaction that requires input values,
such asfilling a textfield,Augustouses an archiveof input values
organized according to their type (e.g., emails are distinguished
from dates) and divided between valid and invalid values. The
archive includes predefined values for most common data types,
but it can be extended with values specific for an AUT.
InthecaseofthesamplerawmatchoftheAUTHpatternwith
theonShopapplication, Augusto successfully generates probing
GUI interactions that confirm the two conditional edges present in
thepattern,shownwithdashedredarrowsinFigure4.Thisalso
leadstotheidentificationofanewwindowandfinallyturnedtheraw match into a full match.
3.7 Reification
TheReification step adapts a full match to the specific semantics of
theapplication,byfocusingonthe semanticproperties definedintheAbstract Semantics model. The Abstract Semantics model encodes
thesemanticpropertiesinageneralway,thatis,semanticproperties
mayhaveunspecifiedpartsthatareautomaticallyadaptedtothe
specific characteristics of the AUT. For instance, the property that
requiressomefieldstobenon-emptyisdefinedinFigure3asbeing
associatedwithasetofinputwidgets,buttheexactsetofwidgetsisleftunspecified.TheReificationstepadaptsthesemanticproperties
to the behavior observed for the AUT.
Augusto starts by generating a probing GUI interaction that
coversthebehavioraffectedbyasemanticproperty,andexploits
the result of the execution to guess the semantic property. For
example,aprobingGUIinteractionmaytrytoexecutethe Sign Up
operationpresentinthe Sign UpwindowofFigure4withanon-
emptyFull Name ,beingFull Name theonlyfieldthatneedstobe
determined as required or not. In fact fields username ,password
andrepeated password areknowntoberequired(seeFigure3).
AfterexecutingthisprobingGUIinteraction,Augusto,usingtheAlloy Analyzer constraint solver, makes a guess consistent with
thecollectedevidence.Forinstanceitmayguessthatthefield Full
Nameismandatory.Augustoautomaticallyincludestheguessinthe
Alloymodelbyaddingsomefieldstothesetoffieldsaffectedbythe
property–inthisexampleitadds Full Name toRequired.fields –
andtriestogenerateanewprobingGUIinteractionthatviolates
the newly guessed semantic property. The new interaction can
either confirm or refute the guess. If the interaction refutes theguess, Augusto makes a new guess based on the newly collected
evidence.Thisprocessiteratesuntileitherthereisonlyonepossible
guess consistent with all the collected observations or a timeout is
reached.InbothcasesAugustoincorporatestheguessinthemodel.
Intheexample,thefirstguessiscorrectanditisconfirmedbyan
interaction that fails to sign up with an empty Full Name .
This process is quite general and can discover several classes of
semantic properties. The current version of Augusto supports any
semanticpropertythatcanbeexpressedasapropertyassociated
with a (possibly empty) set of elements of the GUI, for instance the
property that an input field in a form is either requiredorunique.
3.8 Testing
Thetestingphasegeneratestestcasesthatstimulatethediscovered
AIFs within semantically relevant usage scenarios. In particular,
Augusto generates a test suite that satisfies the following criteria.
Conditionaledge coverage .This criterionrequires samplingthe
AIFsineveryexecutioncontext:foreachconditionassociatedwith
a conditional edge of the model, and for each combination of truth
285
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:12 UTC from IEEE Xplore.  Restrictions apply. Augusto ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
values computed according to MC/DC [ 20], there must exist a test
case that exercises that combination. We selected MC/DC because
it offers a good compromise between cost and completeness.
Pairwise edge coverage . This criterion requires combining the
execution of multiple edges to test combinations of actions. For
each ordered pair of edges in the concrete match, there must exist
atestcasethatexercisesthepair.Ifanedgeisaconditionaledge,it
mustbeexecutedtwice,withasatisfiedandaviolatedprecondition.
AugustogeneratesGUItestcasesthatsatisfythesecriteriausing
the Alloy Analyzer in the same way as it generates the probing
GUI interactions of the previous steps. Note that the generated test
cases cover the semantics of the operations by construction.
In addition, Augusto generates a functional oracle for each test
casebymappingthepostconditions,whichdefinethewindowthat
mustbedisplayedaftertheexecutionofaGUIactionanditscontent,into assertions that are checked after the execution of every action.
Letusconsiderourrunningexample.Inordertocoverthecondi-
tional edge about the registration operation with MC/DC (see line
22 of Figure 3), Augusto generates a non-trivial test case that first
registers a new user and then registers again a user with the same
usernameofthealreadyexistinguser.Thetestcaseisalsoequipped
withafunctionaloraclethatchecksthatthecurrentwindowisstill
the window with the registration form, after an error message has
beenpossiblydisplayed.Theexecutionofthetestcausesafailure
detected by the oracle because the onShop application, in addition
toshowing anerrormessage, behaveslikeiftheregistrationhas
been completed successfully, which violates the generated oracle.
4 EMPIRICAL EVALUATION
Our empirical evaluation addresses 3 research questions:
(RQ1)HoweffectiveisAugustoin detecting applicationindependent
functionalities?
This research question investigates the capability of Augusto
to automatically detect the presence of the modelled AIFs in the
tested applications.
(RQ2) How effective is Augusto in testingapplication independent
functionalities?
ThisresearchquestioninvestigatesAugusto’sabilitytoautomat-
ically generate test cases and find faults in the detected AIFs.
(RQ3)HowdoesAugusto comparetostateofthearttestingtech-
niques in testing AIFs?
This research question investigates if testing the AIFs present in
an application with Augusto delivers better results than testing the
same functionalities with other approaches, thus motivating the
adoptionofAugustoinadditiontoexistingtechniques.Weusedthe
GUITAR [ 37] and ABT [ 29] testing techniques for the comparison.
Toanswertheseresearchquestionswedevelopedaprototype
of Augusto for Java desktop applications. For the purpose of theevaluation, we populated the AIF archive with the definition of
three AIFs: CRUD, that is adding, removing, updating and deleting
objects of a type; AUTH, that is signing up, signing in and signing
out from applications; and SAVE, that is saving data in files andloading them. We produced these definitions before identifying
the subject applications. These AIFs are modelled according to the
common sense knowledge by the authors of this paper.Forourempiricalstudy,weselectedassubjectsseveninteractive
applicationsfromdifferentapplicationdomains,fiveofwhichwere
already used in previous studies [ 5,28,29]: Buddi v3.4.0.8 [ 13], a
personal finance and budgeting program; UPM v1.6 [ 39], a pass-
word manager; Rachota 2.3 [ 26], personal tasks and activities man-
agement application; TimeSlotTracker v1.3.1 [ 9], another personal
tasksmanagerapplication;PDF-samv0.7[ 41],atoolformerging
andsplittingPDFs;OnShop[ 24],ademoe-commerceapplication
availableongit-hub;andSparkv2.7.5[ 21],aLANchatclient.Since
a database is required to enable all the functionalities in Buddi and
UPM,weconfiguredaninitialdbwithcustomdataforBuddiand
an empty db for UPM.
ThethreetechniquescomparedinRQ3requiredthesamecon-
figurations,thatis,apoolofinput valuesthatcanbeusedduring
the testing activity and the definitions of some configuration pa-
rameters.Forallthetechniques,wepopulatedthepoolofinputs
value with the same valid and invalid values, defined coherently
with the nature of the data processed by the subject applications.
In our evaluation, we used the best configuration possible for
eachtool,basedonourknowledgeofthetechniques.InAugusto,
weusedatestcaselengthof15GUIactionsforallapplicationswith
theexceptionofOnShopthathasbeentestedwithatestcaselength
of22actions.Wesetto30minutesthemaximumamountoftime
forthereificationstep.InABTweusedepisodesof30actions(note
that since each episode can start from any state of the system, the
resulting test cases can have an arbitrary length) and the ϵ−greedy
policy with ϵ=0.8, as used in ABT original paper [ 28]. In all
the experiments ABT has been executed for the same time than
Augusto. Finally, for GUITAR we generated the test cases using
theEFGmodeland3-wisecoveragefortestcasegeneration,which
guarantees GUITAR to be executed for a longer time (in some case
significantly longer) thanAugusto, thusfavouringGUITAR over
Augusto. Notice that we tried to use GUITAR also with other types
of models [ 5,43], but we failed since the tool always produced
corrupted test suites despite our best effort (including the attempt
to receive support from the developers of the tool).
Since GUITAR and ABT are not limited to AIFs, simply running
the tools on the full applications would produce incomparable data
for RQ3. We know by construction that GUITAR and ABT can test
applicationsmorebroadlythanAugustoandanyresultobtainedbythesetoolswithnon-AIFscouldnotbeachievedwithAugusto.ThepurposeofRQ3istoinvestigateiftheoppositeisalsotrue,thatis,if
Augustocandeliverbetterresultsthancompetingapproacheswhen
testingAIFs.OnlyforthepurposeofRQ3,tomakethiscomparison
as fair as possible and have GUITAR and ABT spending all thetimetestingAIFsonly,asAugustodoes,wemodifiedthesubject
applications disabling every functionality that is not an AIF.
Finally,tomitigatetherandomnessintheresults,werepeated
all the experiments three times and reported average values.
4.1 RQ1 - AIF Detection
To answer RQ1, we studied the completeness and precision of the
algorithmfordetectingAIFs.WefirstidentifiedtheAIFsactually
presentinthesubjectapplicationsbyopeningandinspectingevery
window of every application looking for instances of the three
defined AIFs (CRUD, AUTH, SAVE). We identified a total of 17
286
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:12 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Leonardo Mariani, Mauro Pezzè, and Daniele Zuddas
Table 1: RQ1 - AIF Detection
AUT AIF ID Match StructureSem. Properties
Compl. FP
UPMCRUD 1 yes precise 100% 0
SAVE 2 yes precise n/a n/a
Spark AUTH 3 (yes) precise 100% 0
Rachota CRUD4 yes precise 100% 0
5 yes precise 100% 0.7
6n o - - -
OnShop AUTH 7 yes precise 100% 1.0
BuddiCRUD8 yes lack delete button 100% 0.7
9 yes precise 100% 0
10 yes precise 100% 011 (yes) precise 50% 3.712 yes precise 100% 0
SAVE 13 yes lack replace file window n/a n/a
PDFsam CRUD 14 (yes) precise 100% 0
TTrackerCRUD 15 yes precise 100% 0
CRUD 16 no - - -CRUD 17 no - - -
occurrencesacrosstheapplications.NotethatanAIFoccurrence
istheoccurrenceofthesetofoperationsspecifiedintheAIF.For
example, an instance of a CRUD includes operations to create,
read, update and delete the entities of a kind. The applications and
their AIFs are reported in the AUTandAIFcolumns of Table 1,
respectively. Each AIF is associated with an identifier (column ID).
We then executed Augusto on the applications and checked
the discovered matches. We indicate the result of this check incolumnMatch:yescorresponds to the generation of a concrete
match that can be used for generating test cases, noindicates that
nomatchisfound,and (yes)meansthatthematchrequiredmanual
interventiontobefound.Outof17cases,Augustomissedonly3
AIFs.ForTTrackerthemissedmatchesarecausedbythelimitation
of therippingphase that was not able to discover the GUI portions
that contain the AIFs. The missed AIF in Rachota was caused by
twoCRUDAIFssharingsomewindows,acasenotsupportedby
Augusto. Augusto never identified a non-AIF functionality as an
AIF, that is, it never produced false positives during AIF detection.
Augusto required manual intervention to deal with cases not
supportedbytheprototypein3ofthe14identifiedAIFs.Inthecase
of Buddi (case 11), we manually excluded a Combo Box producing
behaviors that are not supported by our technique. To addresscases 3 and 14 we extended the definition of two GUI Patternsto accept labels that are not typically used for the operations of
CRUDandAUTH.Forinstance,wesetthelabel accounts asavalid
alternative of sign up/register in AUTH. Although these are
small interventions,they prevented the fullyautomatic execution
of the approach in three cases.
We also evaluated the accuracy of the discovered matches in
terms of the widgets included in the AIF match: Column Structure
indicates if the match includes all and only the widgets that we
manually identified as related to the AIF. The value preciseindi-
cates a perfect match, that is, no missing neither unrelated widgets
associatedwiththeAIF.Notethatin12outof14casesAugustopro-
ducedaperfectmatch.Incase8Augustomissedonlyanelement,
reportedinthetable,duetoparticularimplementationchoicesin
theapplication,andincase13Augusto missed awindowbecause
ofabugintheapplication(thebugwasthenreportedinthetestingTable 2: RQ2 - Effectiveness
AUT AIF ID Avg TC Avg Fail Avg FA Avg Fault #Fault (Crash)
UPMCRUD 1 17.7 6.7 0.3 2.0 3 (1)
Save 2 75.7 1.0 0.7 0.3 1 (1)
Spark Auth 3 33.7 6.7 6.7 0 0 (0)
Rachota CRUD 4 8.3 0.7 0.7 0 0 (0)
5 76.0 7.3 7.3 0 0 (0)
OnShop Auth 7 17.0 4.5 4.0 0.3 1 (0)
BuddiCRUD8 17.0 5.5 5.5 0 0 (0)
9 18.0 2.7 2.7 0 0 (0)
10 18.7 0 0 0 0 (0)11 22.7 12.7 6.3 1.0 1 (0)
12 19.3 0 0 0 0 (0)
Save 13 50.7 12.3 0 1.0 1 (0)
PDFsam CRUD 14 9.4 0 0 0 0 (0)
TTracker CRUD 15 11.7 0 0 0 0 (0)
Overall 7 (2)
phase). In no case Augusto associated unrelated widgets to the AIF,
that is, Augusto never confused the additional elements present in
a window with the ones that refer to the identified AIF.
We also evaluated the ability of Augusto to identify semantic
properties,inthiscasetoidentifytherequiredanduniquefieldsfor
CRUD and AUTH AIFs. We evaluated this aspect by considering
completeness, defined as the percentage of required and uniquefields identified correctly by Augusto (column Compl.), and false
positives,definedastheaveragenumberoffieldswronglyassoci-
ated with a required or unique property (column FP). We report
thevalue n/awhentheAIFdoesnotincludeanysemanticproperty
to be discovered.
The results obtained with semantic properties show that Au-
gusto is quite effective both in terms of completeness, only in one
case some fields have not been associated with the corresponding
property, and rate of false positives, only in four cases there are
false positives. Note that completeness and the number of falsepositivesassociatedwithsemanticpropertiescouldbeimproved
by allocating more time to the reification phase.
In a nutshell, Augusto has been able to identify the AIFs present
inthesubjectapplicationsin82%ofthecases(in3casesrequiringamanualintervention)producinghighlyaccuratematches,including
86%perfectmatches.Moreover,ithasbeenabletoidentifythevast
majority of the semantic properties present in the application.
4.2 RQ2 - Effectiveness
The effectiveness of testing techniques is typically assessed consid-
eringcodecoverageandtheirfaultrevealingability.SinceAugusto
does not target the whole application, code coverage metrics are
notinformative.Thus,toanswerRQ2weevaluatedAugustocon-
sidering its fault revealing ability. In particular, we measure the
number of faults revealed in the subject applications.
Table2reportsforeachAIFidentifiedbyAugusto,theaverage
number of generated test cases (column Avg TC), the average num-
ber of test cases that fail because of the violation of a functional
oracle(column AvgFail),theaveragenumberoffalsealarmspro-
duced,thatis,thenumberoffailingtestcasesthatdonotexpose
anyfaultintheprogram(column Avg FA),theaveragenumberof
faultsdetectedperAIFinarun(column AvgFault ),andthetotal
number of faults detected in the three runs (column #Fault). Col-
umn#Faultsalsoindicatesthenumberoffaultsthatcauseprogram
287
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:12 UTC from IEEE Xplore.  Restrictions apply. Augusto ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Table 3: RQ3 - Comparison
AUT Time (h) AugustoABT GUITAR
Reported Covered Reported Covered
UPM 3.0 4 21 11
Spark 2.0 0 00 00
Rachota 2.5 0 00 00
OnShop 8.0 1 00 00
Buddi 11.0 2 00 00
PDFsam 1.5 0 00 00
TTracker 1.5 0 00 00
Overall Reported 7 2 1
crashes. The classification of a failing test case as fault revealing or
as false alarm was performed manually by this paper’s authors.
The average number of test cases generated by Augusto varies a
lot,rangingfrom8 .3to76.0.Thisbigvariability,whichmightbe
observed even for AIFs of the same kind in the same application
(e.g., see number of test cases for the CRUDs in Rachota), depends
on the specific structural match, concrete semantics and semantic
properties that are extracted. This shows how Augusto, although it
usesabuilt-insemanticsfortheAIFs,isabletoflexiblyadaptthese
definitionstothespecificcase,generatinganumberoftestcases
that depends on the actual complexity of the tested functionality.
Augustomayproducefalsealarms,asreportedinthetable.This
is due to two main reasons: acceptable mismatches between the
semantics model and the concrete behavior of the application, and
imprecise semantics properties inference. Both these sources of
imprecision cause the generation of an imprecise functional oracle.
Note that in several cases sets of failures refer to a same cause (e.g.,
asingleimprecisepropertymaycausethefailureofmultipletest
cases) and identifying the cause of the failure for one test can beused to drastically reduce the inspection time of the other tests
failing for the same reason.
In the evaluation, Augusto has been able to reveal a total of 7
faults, with only two faults causing program crashes. This resultshows that the automatic functional oracle included in the test
cases is an essential element for revealing failures beyond crashes.
Augusto revealed some interesting faults, such as the one de-
scribed in the introduction of this paper. Another interesting fault
was detected in UPM: When editing the identifier of an account,
ifthechangeisundoandtheaccountissaved,theoperationfails
withanerrormessagestatingthattheidentifieralreadyexists,even
though the identifier is the current identifier of the edited account.
In a nutshell, Augusto has been able to generate a number of
test cases for the AIFs present in several applications and revealed
multiple faults, including several non crashing faults.
4.3 RQ3 - Comparison
Table 3shows the resultsobtained byAugusto, ABT andGUITAR
whentestingAIFs.Column SUTindicatesthesubjectapplication.
ColumnTimereports the time spent by Augusto to test the ap-
plication. ABT has been executed for the same amount of time,
while GUITAR has been configurated to be executed at leastfor
that time. Column Augustoindicates the number of faults detected
by Augusto. For ABT and GUITAR the table distinguishes between
reported and covered faults. A reported fault is a crashing fault
revealedbyABTorGUITAR(ABTandGUITARdonotincludeafunctional oracle and can onlyreveal crashing faults). Acovered
fault is a fault that has been activated by a generated test case, but
no failure has been reported due to the lack of an oracle.
AllthefaultsreportedandcoveredbyABTandGUITARarea
subset of the faults reported by Augusto, confirming the higher
effectiveness of semantics approaches when testing AIFs. Augusto
hasbeenabletotestinterestingcasesandinterestingcombinations
ofactionsrevealing7faults,whilefor4ofthesefaultsABTandGUI-
TAR have not been even able to produce the sequence that covers
thefaultycase.Moreover,evenwhenABTorGUITARmanageto
cover the fault, there is a good chance that the fault is not reported
due tolack of non-trivial oracles.In our evaluation, togetherABT
and GUITAR reported 2 crashing faults and covered but did not
report another fault.
Finally,noticethatAugustocomputationtimeiscompatiblewith
server-side quality assurance sessions as well as with overnightusageofthetechnique.Augustomainperformancebottleneckis
theconstraintsolvingperformedbytheAlloyAnalyzertogenerate
test cases. This aspect might be potentially improved employing a
formulacachingframeworktoreducetheneedofconstraintsolving
andthusspeedingupthetechnique[3,4].
In a nutshell, compared to other state of the art techniques,
AugustohasbeenabletosampletheexecutionspaceoftheAIFs
moreeffectivelyandtoreportfailuresthatcouldnotbereported
bythecompetingapproaches,atthecostofreportingsomefalse
alarms.Augustoprovedtobeaneffectivecomplementtocurrent
general purpose GUI testing techniques.
Limitations. Augusto most obvious limitation is that it can be
exploited totest onlyAIFs and cannotbe used totest anarbitrary
functionality,whileotherapproachescouldinprinciplebeexploited
to test any kind of operation, although their effectiveness depends
on the complexity of the tested operations.
Inaddition,AugustodependsontheAIFarchive,whichassumes
thattheGUIofthetestedapplicationfollowscommonsense,while
in practice people might do choices against common sense. More-
over, the patterns exploit labels, which makes the archive sensitive
to thelanguage of thetested application andto the choiceof terms.
Thislimitationcanbemitigateddefiningmultiplepatternsfordiffer-
ent languages and/or using automatic strategies to find synonyms
in a specific context, as done in the work by Mariani et al [30].
Threats to validity. Athreattointernalvalidityisthegeneralityof
theAIFsmodelsthatweusedinourevaluation.Tomitigatetherisk
ofdefiningmodelsthatfittheapplicationsusedintheevaluation
but not others, we defined the AIF archive before selecting the
subject applications.
Another threat to internal validity is related to the manual ac-
tivitiesperformedbytheauthorstoclassifythefailingtestcasesreported by Augusto as faultyorfalse alarm , and to modify the
subject applications for RQ3. For the first threat, to reduce any
bias, only the failing test cases for which all the authors agree that
they expose a fault were classified as faulty. For the second threat,
after modifying the applications we verified that the AIFs continue
working the same including the presence of the faulty behaviors.
Theexternalvaliditythreatsofourstudyrelatetothegenerality
of the results with respect to the set of AIFs and set of applications
288
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:12 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Leonardo Mariani, Mauro Pezzè, and Daniele Zuddas
that we used. Although we cannot make claims about the general-
izability of the results to other AIFs, the AIFs that we used were all
successfullymatchedandhavebeenallusefultorevealfaults.We
thus expect Augusto to be able to effectively exploit other AIFs too.
In terms of subject applications, to mitigate any issue with gen-
eralizability, we selected applications that belong to a variety of
domains, most of which were already used in other studies, which
facilitates comparison, and experimented with a relatively high
number of AIFs per application.
5 RELATED WORK
Automation has been investigated extensively in software test-
ing [2,31]. Techniques for the automatic generation of system test
caseshavefocusedontwoclassesofcomplementaryapproaches:
techniquesthatsampletheexecutionspaceaccordingtoamodel
derived from the GUIof the AUT, and techniques that samplethe
executionspaceaccordingtoamodelderivedfromthesourcecode.
Thetechniques thatusea model extractedfrom aGUIsample
the execution space according to a coverage criterion defined onthe model, such as covering every GUI action or every pair ofdependent GUI actions [
1,5,32–35,43]. These approaches can
uniformlysampletheportionoftheexecutionspacerepresentedin
themodelbutprovidenoguaranteeonthesemanticrelevanceof
the generate tests. On the contrary, Augusto includes mechanisms
tocompletetheinitialGUImodelanddirectlygeneratetestcases
that cover semantically meaningful scenarios, thus avoiding to
waste time and resources on testing irrelevant scenarios.
Instead of generating the model and generating the test cases
intwosequentialsteps,ABTusesQ-Learningtobuildthemodel
while generating system test cases, alternating exploration and
exploitationactivity[ 28,29].Althoughthetestgenerationstrategy
is different, ABT still generates test cases that may cover scenarios
thatarerelativelyrelevantonatestingperspective.Asreportedanddiscussedinthispaper,Augustocanbedramaticallymoreeffective
than these approaches in the domain of AIFs.
Other techniques exploit the AUT source code to apply sym-
bolic execution or search-based algorithms to test case genera-
tion [18,19]. Although these techniques may cover meaningful
testing scenarios in the attempt to cover code statements, they are
stilllimitedintheirabilitytocapturethesemanticsofaprogramand
mighthardlyscaletocomplexGUIsandlargeprograms.Augusto
overcomesbothproblemssinceitexploitssemanticsinformation
and does not depend on the source code.
More in general, none of these test case generation techniques can
reveal failures that do not cause crashes , which is a key ability of
Augusto, as reported in this paper.
The need of moving from explorative approaches mainly using
structuralinformationtoadifferentclassofapproachesthatcan
directlyaddressthesemanticsoftheAUTisalsosupportedbystud-
ies such as the one by Choudhary et al. [ 14]. The study shows that,
even though there exist elaborated techniques that use complex
structural information, the most effective testing technique for An-
droid applications is still a technique that simply performs random
clicks on the GUI. We interpret this result as a clear evidence of
theineffectivenessofautomatictestingtechniquesiftheyarenot
guided by semantic information and as a motivation for this work.Other researchers approached the problem of generating seman-
ticallyrelevantexecutionsinacomplementary,althoughrelated,
situation, that is, generating complex and semantically relevantinput data for testing [
10,11,30,38]. In particular, Link [ 30] can
exploit semantic Web technologies to generate sets of coherent
and semantically relevant input values to execute forms. These
solutions could be used to populate Augusto’s input values archive.
Previousworkspartiallyinvestigatedtheuseofpatternstofa-
cilitatetesting[ 17,36,44,44].Ermuthetal.proposedatechnique
to infermacro-events , that is, GUI operations composed of several
low-level GUI events (e.g., open drop down menu and click on a
menuitem)fromusagetraces.DifferentlyfromAIFs,macro-events
are application specific and do not include information on how
theymayaffecttheapplicationstate.Zaeemetal.introducedthe
conceptof user-interactionfeatures ,thatis,sequencesofoperations
without input-data that bothhave little impact on the application
state(e.g.,double-screen-rotationandpause-and-resume)andhave
a known effect. Compared to AIFs, user-interaction features are
rathersimple,donotneedtobediscoveredfromtheGUI,andhave
a semantics that does not require adaptation. Moreira et al. instead
exploited UI design patterns . This approach shares some ideas with
Augusto, although Augusto has several unique capabilities: the au-
tomaticdetectionofknownAIFsinaGUI,theautomaticadaptation
ofAIFsdefinitionstotheactualsemanticsoftheapplication,and
the automatic generation of test cases equipped with oracles.
Finally, Augusto is not the only technique that uses Alloy to
generate test cases. For instance, TestEra [ 25] can generate test
cases for Java methods from pre-post conditions written in Alloy.
6 CONCLUSIONS
This paper presents Augusto, a GUI test case generation technique
that can automatically produce system test cases for application-
independentfunctionalities(AIF)that:(i)systematicallycoverse-
mantically relevant scenarios and (ii) include precise functional
oracles that can reveal non-crashing faults. To obtain this result,
Augustoencodesthehigh-levelcommonlyexpectedsemanticsof
AIFs into models that are automatically adapted to the specific
characteristics of the application under test.
OurempiricalevaluationshowsthatAugustocanpreciselyiden-
tify AIFs and then generate complex test cases able to exercise and
reportrealnon-crashingfailuresthatcannotbedetectedwithother
state of the art techniques. Indeed, of the 7 faults discovered by
Augusto only 2 could be reported by the competing approaches.
Our evaluation also shows that AIF models are quite resilient
to the minor differences that might occur between the different
implementations of a same AIF across different applications. For
instance, in the evaluation our AIF models required minor changes
only in 3 cases.
ACKNOWLEDGMENTS
This work is supported by the Swiss National Science Founda-
tionwiththeproject“ASysT:AutomaticSystemTesting”(grantn.
200021_162409)andbytheH2020"Learn"projectfundedunderthe
ERCConsolidatorGrant2014program(ERCGrantAgreementn.
646867).
289
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:12 UTC from IEEE Xplore.  Restrictions apply. Augusto ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
REFERENCES
[1]Domenico Amalfitano, Anna Rita Fasolino, Porfirio Tramontana, Salvatore
De Carmine, and Atif M. Memon. 2012. Using GUI Ripping for Automated
TestingofAndroidApplications.In ProceedingsoftheInternationalConference
on Automated Software Engineering (ASE ’12) . ACM, 258–261.
[2]Saswat Anand, Edmund K Burke, Tsong Yueh Chen, John Clark, Myra B Cohen,
Wolfgang Grieskamp, Mark Harman, Mary Jean Harrold, and Phil McMinn.
2013. An orchestrated survey of methodologies for automated software test case
generation. Journal of Systems and Software 86, 8 (2013), 1978–2001.
[3]Andrea Aquino, Francesco A. Bianchi, Meixian Chen, Giovanni Denaro, and
MauroPezzè.2015.ReusingConstraintProofsinProgramAnalysis.In Proceedings
oftheInternationalSymposiumonSoftwareTestingandAnalysis(ISSTA’15) .ACM,
305–315.
[4]Andrea Aquino, Giovanni Denaro, and Mauro Pezzè. 2017. Heuristically Match-
ing Solution Spaces of Arithmetic Formulas to Efficiently Reuse Solutions. InProceedings of the International Conference on Software Engineering (ICSE ’17) .
IEEE Computer Society, 427–437.
[5]StephanArlt,AndreasPodelski,ClementBertolini,MartinSchaf,IndradipBaner-
jee, and Atif M Memon. 2012. Lightweight static analysis for GUI testing. InProceedingsoftheInternationalSymposiumonSoftwareReliabilityEngineering
(ISSRE ’12) . IEEE Computer Society, 301–310.
[6]Earl T. Barr, Mark Harman, Phil McMinn, Muzammil Shahbaz, and Shin Yoo.
2015. TheOracleProbleminSoftwareTesting:ASurvey. IEEETransactionson
Software Engineering 41, 5 (2015), 507–525.
[7]Giovanni Becce, Leonardo Mariani, Oliviero Riganelli, and Mauro Santoro. 2012.
ExtractingWidgetDescriptionsfromGUIs.In ProceedingsoftheInternationalCon-
ferenceonFundamentalApproachestoSoftwareEngineering(FASE’12) .Springer,
347–361.
[8]RolandBennett. Patternry. http://patternry.com/patterns/.(Accessed:2017-08-
12).
[9]Roland Bennett. TimeTracker. https://sourceforge.net/projects/ttracker/. (Ac-
cessed: 2017-08-12).
[10]ChristianBizer,TomHeath,andTimBerners-Lee.2009. LinkedData-TheStorySoFar.InternationalJournalonSemanticWebandInformationSystems 5,3(2009),
1–22.
[11]Mustafa Bozkurt and Mark Harman. 2011. Automatically generating realistic
testinputfromwebservices.In ProceedingsoftheInternationalSymposiumon
Service Oriented System Engineering (SOSE ’11) . IEEE Computer Society, 13–24.
[12]Marco Brambilla and Piero Fraternali. 2014. Interaction flow modeling language:
Model-driven UI engineering of web and mobile apps with IFML . Morgan Kauf-
mann.
[13] Buddi. The Digital Cave. http://buddi.digitalcave.ca. (Accessed: 2017-08-12).[14]
Shauvik Roy Choudhary, Alessandra Gorla, and Alessandro Orso. 2015. Auto-
matedTest InputGenerationforAndroid: AreWeThere Yet?(E). In Proceedings
oftheInternationalConferenceonAutomatedSoftwareEngineering(ASE’16) .IEEE
Computer Society, 429–440.
[15]Stephen A. Cook. 1971. The Complexity of Theorem-proving Procedures. In
ProceedingsoftheAnnualACMSymposiumonTheoryofComputing(STOC’71) .
ACM, 151–158.
[16] Dropbox. Yesterday’s Authentication Bug. https://blogs.dropbox.com/dropbox/
2011/06/yesterdays-authentication-bug/. (Accessed: 2017-08-12).
[17]MarkusErmuthandMichaelPradel.2016. Monkeysee,monkeydo:Effectivegen-erationofGUItestswithinferredmacroevents.In ProceedingsoftheInternational
Symposium on Software Testing and Analysis (ISSTA ’16) . ACM, 82–93.
[18]Svetoslav Ganov, Chip Killmar, Sarfraz Khurshid, and Dewayne E Perry. 2009.
Eventlistener analysisandsymbolicexecution fortestingGUI applications. In
Formal Methods and Software Engineering . Springer, 69–87.
[19]FlorianGross,GordonFraser,andAndreasZeller.2012. Search-basedsystemtest-ing:highcoverage,nofalsealarms.In ProceedingsoftheInternationalSymposium
on Software Testing and Analysis (ISSTA ’12) . ACM, 67–77.
[20]Kelly J Hayhurst and Dan S Veerhusen. 2001. A practical approach to modi-fied condition/decision coverage. In 20th DASC. 20th Digital Avionics Systems
Conference . NASA Langley Technical Report Server, 1B2/1–1B2/10 vol.1.
[21]Igniterealtime. Spark. https://igniterealtime.org/projects/spark. (Accessed: 2017-
08-12).
[22]Daniel Jackson. 2002. Alloy: a lightweight object modelling notation. ACM
Transactions on Software Engineering and Methodology 11, 2 (2002), 256–290.[23]Jenkins. ISSUE 25012. https://issues.jenkins-ci.org/browse/JENKINS-25012?jql=
issuetype. (Accessed: 2017-08-12).
[24]Himalay Joriwal. OnlineShopping. https://github.com/himalayjor/
OnlineShoppingGUI/tree/master/OnlineShopping. (Accessed: 2017-08-12).
[25]ShadiAbdulKhalek,GuoweiYang,LingmingZhang,DarkoMarinov,andSarfraz
Khurshid. 2011. TestEra: A Tool for Testing Java Programs Using Alloy Speci-
fications.In ProceedingsoftheInternationalConferenceonAutomatedSoftware
Engineering (ASE ’11) . IEEE Computer Society, 608–611.
[26]JiriKovalsky. http://rachota.sourceforge.net/en/index.html.(Accessed:2017-08-
12).
[27]KeMao,MarkHarman,andYueJia.2016. Sapienz:multi-objectiveautomated
testingforAndroidapplications.In ProceedingsoftheInternationalSymposium
on Software Testing and Analysis (ISSTA ’16) . ACM, 94–105.
[28]Leonardo Mariani, Mauro Pezzè, Oliviero Riganelli, and Mauro Santoro. 2012.
AutoBlackTest: Automatic Black-Box Testing of Interactive Applications. In Pro-
ceedings of the International Conference on Software Testing, Verification and
Validation (ICST ’12) . IEEE Computer Society, 81–90.
[29]Leonardo Mariani, Mauro Pezzè, Oliviero Riganelli, and Mauro Santoro. 2014.
AutomatictestingofGUI-basedapplications. SoftwareTesting,Verificationand
Reliability 24, 5 (2014), 341–366.
[30]Leonardo Mariani, Mauro Pezzè, Oliviero Riganelli, and Mauro Santoro. 2014.Link: Exploiting the Web of Data to Generate Test Inputs. In Proceedings of
the International Symposium on Software Testing and Analysis (ISSTA ’14) . ACM,
373–384.
[31]Leonardo Mariani, Mauro Pezzè, and Daniele Zuddas. 2015. Recent Advances in
Automatic Black-Box Testing. In Advances in Computers . Elsevier.
[32]Atif M. Memon, Ishan Banerjee, and Adithya Nagarajan. 2003. GUI Ripping:Reverse Engineering of Graphical User Interfaces for Testing. In Proceedings
ofTheWorkingConferenceonReverseEngineering(WCRE’03) .IEEEComputer
Society, 260–269.
[33]Atif M. Memon, Ishan Banerjee, Bao Nguyen, and Bryan Robbins. 2013. The
First Decade of GUI Ripping: Extensions, Applications, and Broader Impacts. In
Proceedingsof TheWorkingConferenceon ReverseEngineering(WCRE’13) .IEEE
Computer Society, 11–20.
[34]AtifM.MemonandQingXie.2005. StudyingtheFault-DetectionEffectiveness
of GUI Test Cases for Rapidly Evolving Software. IEEE Transactions on Software
Engineering 31, 10 (2005), 884–896.
[35]AliMesbah,EnginBozdag,andArievanDeursen.2008. CrawlingAJAXbyInfer-
ring User Interface StateChanges. In Proceedings of the InternationalConference
on Web Engineering (ICWE ’08) . ACM, 122–134.
[36]RodrigoMLMMoreira,AnaCRPaiva,andAtifMemon.2013. Apattern-based
approach for GUI modeling and testing. In Proceedings of the International Sym-
posiumonSoftwareReliabilityEngineering(ISSRE’13) .IEEEComputerSociety,
288–297.
[37]Bao N Nguyen, Bryan Robbins, Ishan Banerjee, and Atif Memon. 2014. GUITAR:
an innovative tool for automated testing of GUI-driven software. Automated
Software Engineering 21, 1 (2014), 65–105.
[38]MuzammilShahbaz,PhilMcMinn,andMarkStevenson.2012. AutomatedDis-
coveryofValidTestStringsfromtheWebUsingDynamicRegularExpressions
CollationandNaturalLanguageProcessing.In ProceedingsoftheInternational
Conference on Quality Software (QSIC ’12) . IEEE Computer Society, 79–88.
[39]AdrianSmith. UniversalPasswordManager. http://upm.sourceforge.net/index.
html. (Accessed: 2017-08-12).
[40]Jenifer Tidwell. 2010. Designing interfaces: Patterns for effective interaction design .
"O’Reilly Media, Inc.".
[41]Andrea Vacondio. PDFsam. https://sourceforge.net/projects/pdfsam/. (Accessed:
2017-08-12).
[42]MartijnvanWelie. Patternlibrary. http://www.welie.com/patterns/index.php.
(Accessed: 2017-08-12).
[43]Xun Yuan, Myra B Cohen, and Atif M Memon. 2011. GUI Interaction Testing:Incorporating Event Context. IEEE Transactions on Software Engineering 37, 4
(2011), 559–574.
[44]RaziehNokhbehZaeem,MukulRPrasad,andSarfrazKhurshid.2014. Automated
generation of oracles for testing user-interaction features of mobile apps. In
ProceedingsoftheInternationalConferenceonSoftwareTesting,Verificationand
Validation (ICST ’14) . IEEE Computer Society, 183–192.
290
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:12 UTC from IEEE Xplore.  Restrictions apply. 