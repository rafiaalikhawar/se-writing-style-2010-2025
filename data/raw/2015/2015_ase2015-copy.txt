Extracting Visual Contractsfrom Java ProgramsAbdullah Alshanqiti∗amma2@mcs.le.ac.ukReiko Heckel∗Department of Computer SciencesLeicester University, UKreiko@mcs.le.ac.ukAbstract—Visual contracts model the operations of componentsor services by pre- and post-conditions formalised as graphtransformation rules. They provide a precise intuitive notationto support testing, understanding and analysis of software.However, due to their detailed speciﬁcation of data states andtransformations, modelling real applications is an error-proneprocess. In this paper we propose a dynamic approach to reverseengineering visual contracts from Java based on tracing theexecution of Java operations. The resulting contracts give anaccurate description of the observed object transformations, theireffects and preconditions in terms of object structures, parameterand attribute values, and their generalised speciﬁcation by uni-versally quantiﬁed (multi) objects. While this paper focusses onthe fundamental technique rather than a particular application,we explore potential uses in our evaluation, including in programunderstanding, review of test reports and debugging.I. INTRODUCTIONVisual Contracts(VCs) provide a precise high-level speci-ﬁcation of the object graph transformations caused by invoca-tions of operations on a component or service. They link staticmodels (e.g., class diagrams describing object structures) andbehavioural models (e.g., state machines specifying the orderoperations are invoked in) by capturing the preconditions andeffects of operations on a system’s objects.Visual contracts differ from contracts embedded with code,such as JML in Java or Contracts in Eiffel, as well asfrom model-level contracts in OCL. They arevisual, usingUML notation to model complex patterns and transformationsintuitively and concisely, and theirexecutable semanticsbasedon graph transformation supports model-based oracle and testcase generation [1], [2], run-time monitoring [3], service speci-ﬁcation and matching [4], state space analysis and veriﬁcation.However, creating a detailed model in any language is error-prone. Visual contracts are no exception, and their speciﬁ-cation of object states and transformations requires a deeperunderstanding of a system than models of externally visiblebehaviour. This limits their applicability in testing, veriﬁcationand program understanding in general.In this paper we propose a dynamic approach to reverseengineering visual contracts from sequential Java programsbased on tracing the execution of Java operations. The result-ing contracts give accurate descriptions of the observed objecttransformations, their effects and preconditions in terms ofobject structures, parameter and attribute values, and allowgeneralisation bymulti objects. The restriction to sequentialJava is due to the need to associate each access to a uniqueoperation invocation.Given a Java application, the process starts by selectingthe classes and operations within the scope of extraction andproviding a set of test cases for the relevant operations. Weproceed by (A) observing the behaviour under these tests usingAspectJ instrumentation and synthesising contract instancesas pre/post graphs of individual invocations; (B) combiningthe instances into higher-level rules by abstracting from non-essential context; (C) generalising further by introducing multiobjects; and (D) deriving logical constraints over attribute andparameter values.First solutions to variants of (A) and (B) were reportedin [5], [6], respectively. Apart from general performance im-provements in the individual algorithms and their integrationin a prototype tool, the dynamic analysis (A) was extendedby traceability of contract instances to code, recording accessand changes to attribute and parameter values, and producingcontract instances in a format that could be fed into the initialstep (B) of the learning. The latter originally relied on bothpositive and negative examples, so had to be adapted to makedo with positive examples only as produced by (A). Supportfor operations with parameters was also added. Steps (C) and(D) extending the learning of basic contracts by multi objectsand attribute constraints are discussed here for the ﬁrst time,as is an experiment on the usefulness of visual contracts fortesting and debugging.Following a general presentation of the notions and tech-niques of the approach in Sect.II, Sect.III-Adescribes theprototype tool implementing them. The evaluation in Sect.IIIdiscusses the scalability of the extraction as well as thevalidity of the resulting models and their utility in programunderstanding in the context of testing and debugging. Apartfrom their use in validation, case studies and experiments arechosen to exemplify potential applications in this area withoutclaiming that the present tool could support real-world use.After discussing Related Work, Sect.Vconcludes the paper.II. EXTRACTINGVISUALCONTRACTSThis section gives an overview of the approach using a sim-ple case study of a Car Rental Service designed to represent arange of different preconditions and effects of operations overa complex object-structure, including the creation of objects,the creation and deletion of links as well as attribute updates
2015 30th IEEE/ACM International Conference on Automated Software Engineering
978-1-5090-0025-8/15 $31.00 © 2015 IEEE
DOI 10.1109/ASE.2015.63104
public interfaceIRentalextendsSerializable{publicString registerClient(String city, String clientName);publicString makeReservation(String ClientID, String pick−up, String drop−off);publicvoid cancelReservation(String Reference);publicvoid cancelClientReservation(String clientID);publicvoid pickupCar(String Reference);publicvoid dropoffCar(String Reference);publicReservation[] showClientReservations(String clientID);publicClient[] showClients (String city);publicCar[] showCars (String city);}Listing 1: Interface of a Car Rental Serviceand constraints. Basic concepts of graph transformation areintroduced, following [7].An interface with the relevant operations is given inList-ing 1. The class diagram in the top left ofFigure 1shows theselected classes, whose instances will be observed. Classesand data-valued attributes in the diagram map to classes andattributes in Java. Associations with cardinality1at the targetrepresent object-valued attributes in their source class andassociations with cardinality∗are implemented by containers.Formally, a class diagram is represented as anattributedtype graphTG, i.e., a distinguished graph deﬁning vertex,edge, attribute and data types from which object graphs can beconstructed. Anobject graphoverTGis a graphGequippedwith a structure-preserving mappingG→TGassigning everyelement inGits type inTG.A. Observing Access and Synthesising Contract InstancesWe adopt a dynamic approach to extract, for each oper-ation invocation, acontract instancecapturing the observedbehaviour. Observations are made by weaving instrumentationcode using AspectJ. This results in a trace recording theobject creation, read and write access to objects and attributescaused by the active invocation. Concurrent invocations createthe problem of identifying for each observation the relevantinvocation and are therefore not considered. We aggregateobservations into a contract instance capturing the overallprecondition and effect of the invocation (see [6] for moredetails). Along with the instance we collect traceability datafor its elements, such as the line numbers in the code causingfor their access. This is used later to validate the extraction,e.g., to assess which code fragments are captured by whichcontracts.Consider the contract instances inFigure 1. Instancereg-isterClientcreates a new client object, registers it with thebranch atcity, and updates attributebranch.cMax. InstancemakeReservationbooks a car for a client by creating a newreservation objectrwith linkspickup, dropoff, madeandfor.Linksofandatindicate that a client can reserve cars from thepickupbranch they are registered with. InstancespickupCaranddropoffCardescribe the movement of a car from thepickupto thedropoffbranch.As can be seen in the example, a contract instance consistsof a pair of object graphs representing the situation before andafter the operation. We writeb=op(a1,...,an):G⇒Hto indicate the invocationop(a1,...,an)of an operationwith signatureop(x1:T1...,xn:Tn):Tleading to atransformation ofGintoH. We assume thatG, Hlive in acommon name space given by unique object identities, so theelements deleted, preserved and created by the transformationareG\H,G∩HandH\G, respectively.
Fig. 1: Type graph and rule instances, extracted from car rentalserviceB. Deriving Minimal Contracts and Shared ContextEach contract instance only represents one invocation, butof course our aim is to derive a small set of contracts thatdescribe the overall behaviour as precisely as possible. Sucha general contract is given by a set ofparametrised rulesop(x1,...,xn)=y:L⇒Rover the same operationsignature with graphsLandR,c a l l e dt h eleft-andright-handsideof the rule, expressing the pre- and postconditions of theoperation. As beforeL\R,L∩RandR\Lrepresent theelements deleted, preserved and created by the rule.To derive such a general model we consider all instancesrepresenting executions of the same operation. First, we gen-erate aminimal rulefor each instance, i.e., the smallest rulecontaining all objects referred to by the operation’s parametersand able to perform the observed object transformation. Theconstruction has been formalised in [8] and implemented(without considering parameters) in [5]. Formally, given acontract instanceb=op(a1,...,an):G⇒Hits minimalrule is the smallest ruleL⇒Rsuch thatL⊆G, R⊆Hwitha1,...,an∈Landb∈Ras well asG\H=L\RandH\G=R\L. That means, the rule is obtained fromthe instance by cutting all context not needed to achieve theobserved changes nor required as input or return.The result is a classiﬁcation of instances by effect: Allinstances with the same minimal rule have the same effect, but
105possibly different preconditions. These are in turn generalisedby one so calledmaximal rulewhich extends the minimal ruleby all the context that is present in all instances, essentiallythe intersection of all its instances’ preconditions.Figure 2shows an example of this generalisation where maximal rule(C) results from instances (A) and (B) ofcancelClientReserva-tion(..). The shared effect in both cases is the deletion of theReservation object connected to the Client and the minimalrule is identical to (B). The isolatedr1:Reservationobject in(A) arises from an unsuccessful test onr1when searching forthe reservation object to be cancelled.
Fig. 2: Extracting maximal rules from contract instances
Fig. 3: Inferring MOs from contract instancesBut minimal or maximal rules are not just generalisationsof instances, but provide a constructive speciﬁcation. Givenan object graphG, a rule can be applied if there is a matchm:L→G, such thatLis (isomorphic to) a subgraph ofGand removing (an image of)L\RfromG, the resultingstructure is a graph. The derived object graphHis obtainedby adding a copy ofR\L. Unsurprisingly, applying a ruleextracted from a contract instanceb=op(a1,...,an):G⇒Hto the pre-graphGof that instance, we obtain its post-graphH, but we can also apply the same rule to other given graphsderiving transformations not previously observed.C. Introducing Universally Quantiﬁed Multi ObjectsThe contracts extracted so far may use a number of rulesto describe the same operation. In the case of iteration overcontainers, for example, the set of minimal rules is potentiallyunbounded, but some only differ in the number of objectsmanipulated while performing the same actions on all ofthem. Rules with multi objects (MOs) provide a concise wayto specify constraints and actions across sets of objects ofdifferent cardinalities.Amulti-object (MO) ruledistinguishes a setM⊆Lof MOnodes, with cardinality constraintscard:M→P(I lN)statinghow many concrete objects each MO can be instantiated by.Application of MO rules is deﬁned by expanding MO nodesinto sets of regular nodes. An expansion of an MO rule isa (regular) rule obtained by successively replacing each MOnodem∈M,card(m)=Cbyc(m)copies for somec(m)∈C. This includes copying all incoming and outgoing edges sothat for each nodem∈Mand chosenc(m)we getLmas•LmV=LV\{m}/unionmulti{m}×{1,...,c(m)}and•LmE=LE\LE(m)/unionmultiLE(m)×{1,...,c(m)}whereLE(m)={e|srcL(e)=m∨tarL(e)=m}is theset of edges attached to nodem. Sources, targets and typesof new edges and nodes are inherited fromL. The expansionextends toRon the MO nodes shared withL. (Due to theassociativity of the product×up to isomorphism, the resultingrule is essentially independent of the order of the MO nodesexpanded.) Note that for two MO nodesm1,m2connected byan edge we will createc(m1)∗c(m2)edges between the copiesofm1andm2. Anapplication of an MO ruleto an objectgraphGis an application of a maximal applicable expansion.For example, nodeReservationinFigure 3(C) is anMO node (shown with a 3D shadow) with cardinality1..2,applicable to object graphs with 1 or 2Reservationnodes con-nected to theClient. Contract instances of two correspondingtransformations are shown inFigure 3(A) and (B).To derive MO rules from such instances we have to discoversets of nodes that have the same structure and behaviour, thenrepresent them by a single multi-object node. We only considermulti-object nodes that are part of the minimal rule becausetheir typical use is to describe universally quantiﬁed effects(rather than preconditions). In the rule instanceFigure 3(B),for example, bothReservationnodes have the same context,i.e., they both point to the sameClientnode by amadeedge,and they are both connected toreturn: Collectionon the right-hand side, so share the same behaviour. Therefore they aresubstituted by one multi-object, as shown inFigure 3(C),which also generalisesFigure 3(A) with only one occurrence.After inferring multi objects within individual rules, if two MOrules are isomorphic, the two original rules can be replacedby a single MO rule with appropriate cardinalities reﬂectingthe generalised cases.Two objects areequivalentif they are (1) of the same type;(2) part of the minimal rule; and (3) have the same context(incident edges of the same type connected to the same nodes)in the pre- and postcondition (thus specify the same actions).Assuming for every operationopa set of maximal rulesR(op)as constructed in Sect.II-B, we derive MO rules in two steps.Merge equivalent objects:For each rulem∈R(op)and eachnon-trivial equivalence class of objects inm, one object ischosen as the representative for that class and added to the set
106of MO nodes form, while all other objects of that class aredeleted with their incident edges. The cardinality of the MOnode is deﬁned to be the cardinality of its equivalence class(the number of objects it represents). The resulting set of MOrules isMOR(op).Combine isomorphic rules:A maximal set of structurallyequivalent rules inMOR(op), differing only in their objectidentities and cardinalities of their MO nodes, forms anisomorphism class. For each such class we derive a single ruleby selecting a representative MO rule and assigning to each ofits MO nodes the union of cardinalities of corresponding nodesin all the rules in the class. The resulting set of combined MOrules isCMOR(op). An example is the derivation ofFigure 3(C), a combination of basic ruleFigure 3(A) with the MOrule derived from (B) whose cardinalities of1and2for theReservationnode are merged to1..2.D. Deriving Constraints on Attributes and Parameter ValuesSo far we have focussed on structural preconditions and ef-fects, disregarding the data held in objects’ attributes or passedas parameters. However, at implementation level, manipulationof object structure and data are tightly integrated. While wehave seen that the structural view is naturally expressed bygraphical patters, constraints or assignments over basic datatypes are more adequately expressed in terms of logic.The contract forcancelClientReservation(cid: String)de-scribes the removal of aReservationobject linked to theClientwhoseidmatches the parametercid. In the contractthis is expressed by the equalityid=cidin theClientobject. Formally,c.idandcid, as well as the right-hand sidecounterpartc.id/primeofc.id, are local variables of the contractthat get instantiated by the match as part of an application.In particular, given a graph objectGand matchm:L→G,c.idis instantiated by the value of theidattribute ofm(c),i.e.,m(c.id)=m(c).id. In a similar way we can extendmtoevaluate complex expressions and use these in assignmentsto update attributes. The formalisation in attributed graphtransformation assumes an abstract data typeAas attributedomain linking it to the structural part by attribution maps.Let us consider how attribute constraints for contracts can belearned. Say, an instancei=[b=op(a1,...,an):Gi⇒Hi]has attribute and parameter valuesAi(i.e., these values wereeither read or written during the corresponding invocation). Amaximal ruler=[op(x1,...,xn)=y:L⇒R]generalisinga number of instances with shared effects is given a setXof local variables for all formal parametersx1,...,xnand allattributes read or accessed by all its instances. Since maximalruleris embedded by a matchmiinto every instanceiitsubsumes, this extends to an assignment of the local variablesmi:X→Gi.Fixing an order on the variablesX, eachmibecomesa vector of values to be fed into a machine learning toolcapable of driving logical constraints. We use the Daikontool [9] designed for the derivation of invariants over programvariables. From the assignmentsmifor all instancesithat con-tributed to the construction of rulerDaikon generates a set ofconstraints that are valid for all assignments. These constraintsare fed back into the graphical part of the contract, whereeach becomes part of the pre- or postcondition depending onwether the variables used occur only inLor inL, Rand theparameters. This approach allows the separation of structuraland constraint learning.III. EVA L UAT I O NIn this section, we illustrate the implementation of theapproach by a proof-of-concept prototype and discuss correct-ness and completeness of extracted contracts. We report onexperiments to assess the utility of visual contracts and thescalability of the extraction as implemented by the prototype.A. Prototype ToolThe approach is implemented by a tool whose high-levelarchitecture is shown inFigure 5. It consists of a Tracerobserving the behaviour of selected classes using AspectJand constructing contract instances (cf.subsection II-A), aGeneraliser learning minimal, maximal and MO rules (cf.subsection II-BandII-C) using Daikon [9] to learn constraints(cf.subsection II-D) both supported by a database connectionand a Visualiser for selective display and analysis of contracts.An export to the graph and model transformation tool Hen-shin [10] is used to simulate contracts for validation. First wefocus on the Visualiser to illustrate how results are presentedand how they could be used to aid program understanding.
Fig. 5: Architecture of the ToolThe main task of the Visualiser (seeFigure 4) is to organise,browse and display extracted contracts. To this end we support•the distinction in colour and style between elements ofthe minimal and larger maximal rule, e.g., dotted edgesand nodes with grey background represent elements ofminimal rules, while nodes with white background andsolid edges are context elements;•the alternative display of collections as to-* associationsor using explicit collection objects;•the selective visualisation of rules, for example of theminimal rule or the precondition only.Figure 4shows two screenshots of the main interface. In(a), we present an instance extracted frommakeReservation()inFigure 1. The upper part of (a) gives information onthe operation signature, actual parameters and the extractionprocess. Apart from the rule showing the precondition andeffect at a high level, we provide information on the accessto individual objects with the corresponding locations in the
107(a) Rule instance
(b) Generalised rules interfaceFig. 4: Visualiser interfacecode. They are available through a pop-up window like the oneinFigure 6activated by clicking on the:Reservationnode inthe right-hand side of the contract.Figure 4(b) shows how generalised (maximal and MO)rules are displayed. The top left shows a list of the rulesorganised by their operation signatures. When selecting, e.g.,a maximal rule, all its rule instances will appear in thetable, see the top right of (b). The lower part shows themaximal rule with multi objects and 5 attribute constraintsforRegisterClient()that describe the relation between attributevalues, input and return parameters. For example, the 4thconstraint states that the value of thecIDis returned whilethe 5th requires that thecNameattribute of the new Client
Fig. 6: Object access and code locations
108(a) Left-hand side of maximal rulecancelClientReservations()
(b) Left-hand side with multi object extracted from (a)Fig. 7: Extraction of rule with multi objectobject has the same value as the 2nd parameter. An exampleof a rule with multi object is shown inFigure 7(b) as extractedfrom the maximal rule in (a) forcancelClientReservations().B. Correctness and CompletenessIn order to establish to which extent the contracts extractedprovide an accurate description of the software’s behaviourwe consider two directions, thecorrectnessandcompletenessof the contracts. For every statesin the implementationthere exists a corresponding object graphG(s)at model levelobtained by representing all objects in the scope of observation(i.e., that are instance of the classes selected for tracing,cf. start ofsection II) as nodes, object-valued attributes asedges and data-valued attributes as node attributes. Then, amodel iscorrectif for every valid statesand invocationin, a stepin:G(s)⇒Hin the model implies a stepin the implementation from statesto a new states/primesuchthatH=G(s/prime). That means, the model does not allowbehaviour that is not implemented by the system. Conversely,completenessmeans that for each valid states, a step causedby an invocationinof the implementation leading to a states/primemust be matched by a stepin:G(s)⇒G(s/prime)in the model,i.e., all the system’s behaviour is captured by the model.In general, the models extracted will be neither correct norcomplete. Correctness fails because the model is extractedfor a certain part of the system only as identiﬁed by theimplementation classes selected for tracing. Anything outsidethis scope of observation is not recorded and therefore notrepresented by the model. That means, if the implementationchecks a condition on the state of an object outside scope,this check is not reﬂected in the precondition of the contract.If this check fails, a step in the model may not be reﬂectedby a step in the implementation. A weaker condition takinginto account this limitation is that ofmoderated correctness.It states that, if both preconditions are satisﬁed, the observableeffect of the implementation-level step should match the effectof the model-level step. Here the comparison is moderatedvia the the mappingG()of implementation states to objectgraphs, which also takes account of the scope.Completeness fails for the same reason that test cases cannotprove the correctness of a system. The dynamic approach toextracting contracts is inherently dependent on the range of be-haviours observed, and behaviours that have not been observedwill not be reﬂected in the model. So what can we realisticallyhope to achieve? A minimal notion of completeness shouldrequire that all observed behaviours are represented in themodel, i.e., when executing the tests the model was extractedfrom, all steps steps in the implementation should be matchedby the model.We used manual inspection on the Car Rental Service casestudy to validate if the models extracted by the tool satisfy thebaseline/moderated notions of correctness and completeness.The limited amount of code and our familiarity with theapplication allowed us to perform a detailed review for everymethod in the interface, validating for all execution paths thatthere exists a rule in the corresponding contract capturing thepath’s combined precondition and effect, and vice versa forevery rule that the behaviour described is fully implemented.This process was aided by the export of extracted contracts tothe Henshin model transformation tool [10], which providesa facility to simulate contracts based on their operationalsemantics as graph transformation rules.Consider the source code fragment inListing 2implement-ing thedropoffCar()method. There are three possible pathsleading to at least three different contracts, depending onthe evaluation of the twoifstatements in lines 4 and 10.When executing this method by three test cases that cover allstatements, the extracted rules reﬂect the expected behaviours.This is conﬁrmed by tracing the line numbers in the coderesponsible for the access to objects in the contracts.Figure 8shows the left-hand sides of the three rulesextracted fromdropoffCar(). For example, (a) reﬂects thebehaviours of statements 1-6 as we pass an invalidreser-vation idand, accordingly, the execution breaks at line 5.The rule correctly describes the access tothis:RentalandtheReservationcontainer. In (b) the parameter is valid, i.e.,theReservationobjectLeicester13exists, but the executionbreaks at line 11 since the car has not been picked up yet.This can be seen from thepickuplink which would have been
109deleted otherwise. The rule in (c) reﬂects correctly the thirdpath, i.e., the conditions in 4 and 10 are false so there is noreturn from the method there.1publicvoid dropoffCar(String Reference){23intiIndex = getReservationIndex(Reference);4if(iIndex==−1){5return;6}78Reservation getReservation =this.reservations.get(iIndex);9// check if reserved car has been picked up already10if(getReservation.pickup!=null){11return;12}1314// return reserved car to the drop−off branch15getReservation.dropoff.at.add(getReservation.for);16// remove reservation object17this.reservations.remove(iIndex);18}Listing 2: Implementation of dropoffCar() method
(a) Rule instance extracted from lines (1-6)
(b) Rule instance extracted from lines (1-12) without line(5)
(c) Rule instance extracted from all lines except (5,11)Fig. 8: Rule instances fordropOffCar()More generally, due to the method of model extraction (andassuming it was correctly implemented in our prototype tool)we can assert that model and implementation should show thesame behaviour at least for the test cases used. In particular•contract instances capture precisely the preconditions andeffects relevant to the invocation they are derived from,within the scope of observation;•minimal rules capture exactly the effect of contract in-stances they are extracted from;•maximal rules subsume all contract instances they derivefrom, i.e., every contract instance can be replicated as anapplication of the maximal rule;•rules with multi-objects are (more concise, but) equivalentto the sets of maximal rules they derive from, i.e., byretaining the original rules’ cardinality information, theydescribe exactly the same set of transformations;•the parameter and attribute constraints derived do notinvalidate any of the contract instances their maximal ruleoriginates from.The fact that, in general, models are only representative ofthe behaviour they were extracted from is an obstacle to someapplications, such as their use in veriﬁcation, where automatedextraction has to be followed by a manual review and com-pletion of contracts. In the following section we demonstratean application to program understanding in the context oftesting and debugging that does not rely on completeness orcorrectness beyond the set of tests executed.C. Utility in Assessing Test Reports and Localising FaultsUsing the Car Rental Service case study we conducted anexperiment to evaluate the utility of visual contracts extractedfrom the execution of test cases for analysing test reports andidentifying faults. In this paper-based exercise our hypothesiswas that “visual contracts, rather than textual representationsof the same information, improve recall and accuracy ofdetecting faults in test reports”. Generally, we wanted to ﬁndout how visual contracts help developers, and for which kindsof faults they are most effective.To conduct the experiment, an implementation of the RentalCar Service was documented in natural language, seeded with8 faults and provided with several short test cases able todetect them. Tests were executed and results recorded intwo different formats: (A) as sequences of invocations andreturns of operations from the interface, with queries added todisplay details of the internal state after each step and (B) assequences of visual contracts extracted from the same invoca-tions. Students were asked to (1) identify invocations wherethe observed behaviour deviated from the expected based onthe documentation and (2) locate the faults responsible in thecode provided. Both groups received reports from 4 tests of4-5 invocations each, containing a total of 20 failures to betraced down to the 8 seeded faults.The 66 participating students were volunteers from anMSc module on (UML-based design, implementation andtesting of) Service-oriented Architectures running February-May at the University of Leicester. We could use data frompreviously submitted coursework, one on modelling and oneon implementation and testing, to check that the average levelof qualiﬁcation of participants in both groups was comparable.The groups A and B were selected randomly (handing outworksheets A and B alternatingly), resulting in 32 students
110in group A with an average coursework mark of 67.4% and34 students in group B with an average coursework mark of68.1%. From the module, the students were broadly familiarwith the concept of speciﬁcation-based testing of serviceinterfaces like the one provided. The Car Rental Serviceinterface, its documentation and the two types of assignmentswere introduced to all students in a 50 min session prior tothe experiment. The participants then had 50 mins under examconditions to analyse test reports, detect and document failuresand locate the corresponding faults in the code provided.Group A achieved an avg. recall of 0.215 (identifying 1.7out of the 8 faults) and an avg. precision of 0.232 (with 1.7correct out of 7.4 responses). Group B had an avg. recall of 0.3(correctly identifying 2.41 out of 8) and an avg. precision of0.35 (with 2.41 correct out of 6.88 responses). This representsa factor of improvementrecall B / recall Aof0.3/0.215 = 1.4andprecision B / precision Aof0.35/0.232 = 1.5. In bothcases, the t-test for independent two-sample experiments (forunequal variances and population sizes) showed that the resultsare statistically signiﬁcant with a probability (p-value) of 0.033for recall and 0.013 for precision. The p-value was calculatedusing an online tool1for a degree of freedom of 64 (the sum ofpopulation sizes−2), a signiﬁcance level of 0.05, and a one-tailed hypothesis (there is a reasonable expectation that groupB would perform better than group A). That means, assumingthe null hypothesis that “the different representations of testreports in both groups have no effect on the resulting scores”is true, there is a 0.033 resp. 0.013 probability of observing thesame results due to random sampling error. The key ﬁguresare summarised inTable I.2TABLE I: Statistical data for groups A and BrecallprecisionA mean0.2150.232A std dev.0.1960.212B mean0.30.35B std dev.0.180.209t-test1.8752.284p-value0.0330.013We investigated more closely which faults in which oper-ations were detected more frequently by which group. Thenumbers are too low to have statistical signiﬁcance, but suggestthat the differential beneﬁt of using visual contracts is greaterwith faults that involve structural features rather than thosethat concern attributes and parameter values only, such as•makeReservation()does not check theoflink betweenBranchandClientobject;•dropoffCar()does not remove theReservationobject.The visual representation seems to be less effective for de-tecting faults in postconditions than in preconditions. In fact,there are two examples of structural postcondition faults thatwere detected with higher frequency by group A than B, i.e.,1Social Science Statistics, P Value from T Score Calculator,http://www.socscistatistics.com/pvalues/tdistribution.aspx2All documents and instructions handed out to both groups as well asthe raw data and detailed calculations are available athttp://www.cs.le.ac.uk/people/amma2/experiment•cancelReservation()deletes all reservations for the rel-evant client, rather than only the one speciﬁed by theparameter;•pickupCar()does not delete thepickuplink.Indeed to understand the structural effect of a rule we haveto spot the differences between its left- and right-hand side,which can be difﬁcult if the structure is complex and thereare several changes. This could be addressed, for example, byusing different colours to highlight changes.The highest relative beneﬁt of visual contracts (13 dis-coveries in group B vs. 1 in group A) was observed forregisterClient()(see top right ofFigure 1) where accordingto the documentation, the client id returned should have beenformed ascity + ”” + Branch.cMaxwhile in fact wascomputed ascity + ”” + Branch.of.size()using the size ofthe client list rather than the next free client numbercMax.To detect this problem requires matching information from preand postcondition, including the navigation of the link betweenClientandBranchobject, and the return value. Indeed, oneadvantage of visual representations is that they are not linear,and so able correlate items of information across more thanone dimension.Threats to Validity:While it is unlikely (see above) thatresults are due to random error, the design of the experimentitself could have biased the outcome. The (self) selectionof participants may have resulted in groups that are notrepresentative of the software developers normally concernedwith testing tasks or could have provided an advantage to oneof the groups. However, testing is often performed by juniordevelopers. Many of our MSc students, mostly internationalwith a broad range of backgrounds, would expect to go intoentry level developer roles after graduation. As stated earlierwe checked that both groups were equally capable based ontheir academic performance on a related MSc module thatmatched well with the expertise required in this task.The relatively poor performance overall is a cause for con-cern. We believe this is due to the limited time to understandand perform a quite complex task, and the lack of practicalexperience of the participants, but also caused by the paper-based nature of the exercise, where a debugging tool providingsimilar representations in a more interactive, navigable waycould improve outcomes. It is worth stressing, however, thatthe study does not claim the visual approach to be effective inabsolute terms, only that it works better than the textual onein this artiﬁcial setting. This indicates that it might provideadvantages in related practical tasks as well, but this is yet tobe demonstrated.There could be bias in the representation of information toboth groups. Of course, since the hypothesis claims that thevisual representation is more useful, this “unfair advantage” isintended. Apart from that the information provided is equiva-lent: invocations with actual parameters and returns are showntextually in both cases, only information on the internal state(object structure and attribute values) is represented differently,in group A by query operations listing all accessed objects andtheir state and in group B by visual contracts extracted.
111The choice of case study, with its dominance of structuralfeatures and their manipulation rather than computations ondata, limit the validity of results to just such applications. Thisis justiﬁed by the fact that this is the natural domain for visualcontracts. The NanoXML and JHotDraw case studies providefurther examples of that nature.D. ScalabilityWe use two case studies to evaluate scalability to largenumbers of invocations and large object graphs. The casestudies are based on NanoXML and JHotDraw3, both popularbenchmarks for software testing and analysis, and representa-tive of the kind of system our method would be appropriatefor, i.e., with signiﬁcant and dynamic object structures in theircore model. In NanoXML this is the object representation ofthe XML tree, for JHotDraw that of graphics’ objects.NanoXML is a small non-validating XML parser for Java,which provides a light-weight and standard way to manipu-late XML documents. We use version 2.2.1 which consistsof three packages and 24 Java classes. We focus on twoclasses,XMLElementandXMLAttribute, which provide thefunctionality to manipulate XML documents. We monitor allXMLElementmethods, executing 5605 test cases in order toevaluate the handling of large numbers of invocations. Theoriginal test cases were generated by CodePro4, some modiﬁedand completed manually to improve coverage. These testscover 2099 out of 5836 instructions. InFigure 9we plotthe time taken to execute different batch sizes of tests, from59 to 2183. Each test generates a single rule instance fromwhich minimal and maximal rules, multi-objects and con-straints are extracted. Tracing, contract instance constructionand extraction of minimal rules are essentially linear, as is thederivation of constraints and multi objects. The constructionof maximal rules requires to compare all rule instances withshared minimal rules, which is quadratic in the number of ruleinstances that share the same effect.
Fig. 9: Scalability for extracting contracts from NanoXMLJHotDraw is a Java GUI framework for technical andstructured graphics, developed as an exercise in good softwaredesign using patterns. We used version 5.3 which has 2433Seehttp://nanoxml.sourceforge.net/orig/andwww.jhotdraw.org/4A JUnit test case generatorhttps://developers.google.com/java-dev-tools/codepro/doc/features/junit/testcasegenerationclasses, focussing on the top level methods for the manipu-lation of graphs, such as*.addFigure(..), *.DeleteFigure(..),*.copyFigure(..), *.DecoratorFigure(..)and all undoable ac-tions in*.CommandMenu.actionPerformed(comExe). We useGUI testing using WindowTester5to generate test cases byrecording user interactions. We executed 405 test cases thatcover 9284 of 34710 instructions. Based on the recorded testcases, the total runtime of the extraction is about 3 hours 15mins. Scalability is analogous to NanoXML, seeFigure 10,but the quadratic component of maximal rule extraction is lesssigniﬁcant due to the smaller overall number of rule instances.
Fig. 10: Scalability for extracting contracts from JHotDrawUnlike NanoXML where the number of invocations / con-tract instances is large but the size of each contract instancesmall, JHotDraw produces contract instances up to severalhundreds of objects.Table IIshows the number of objectsaccessed, number of instances, maximal rules, and rules withMO created (with total size in terms of numbers of objects).TABLE II: JHotDraw objects accessed and processed forconstruction of contractsexecutedinstancemaxMOExecuted method signatureobjectsrulesrulesrulesCopyCommand.execute()2015016(400)3(80)0add(Figure)1110624(332)2(26)0DeleteCommand.execute()49497115(6259)2(828)1 (207)DecoratorFigure.decorate(Figure)221520(90)2(10)0UndoableCommand.execute()65167160(19060)10(2088)1 (209)number (and size) of rulesBased on these results we conclude that scalability may beacceptable for batch processing moderately sized test suites,but not necessarily for interactive testing. In applications toprogram understanding and debugging, however, where thehuman effort is signiﬁcant, the time taken to prepare a moreeffective representation for inspection is likely to pay off, andour user study indicates that such beneﬁts may be expected.The number of cases where multi objects could be identiﬁed isrelatively small (2 out of 19 maximal rules) but they covereda large number of objects that may be hard to survey withoutthis added level of abstraction.The overall evaluation provides some conﬁdence in thevalidity of the technology, the usefulness of the results andthe scalability of the tool, but these aspects were evaluated5A tool to record GUI tests for Swing applications,https://developers.google.com/java-dev-tools/wintester/html/gettingstarted/swingsampletest
112through separate experiments on a range of different cases.There is no direct evaluation of the usability of the tool orof the absolute effectiveness of the approach in applicationsto program understanding and testing because such claims arebeyond the scope of the paper.IV. RELATEDWORKReverse engineering visual contracts is a process of learningrules from transformations. This has been suggested in anumber of areas, including the modelling of real-word businessprocesses [11], biochemical reactions [12] and model trans-formations [13]. Although related in the aim of discoveringrules, the challenges vary based on the nature of the graphsconsidered, e.g., directed, attributed or undirected graphs, theavailability of typing or identity information, etc. We organisethe discussion in two levels: tracing to construct rule instancesand learning to infer high-level rules with advance featuresModel Extraction:Automated reverse engineering is basedon static or dynamic analysis. The static approach, exempliﬁedby [14], [15], [16], examines the source code only, withthe intention of extracting all possible behaviours. This isuseful for incomplete systems, e.g., components that cannot beexecuted independently [15], but limited in its ability to detectdynamic object-oriented behaviours such as dynamic binding.The drawback of a dynamic approach, such as ours butalso [17], [18], [19], is that the extracted model represents onlythose behaviours that are actually executed. In particular [19]uses AspectJ for extracting a context-free graph grammarbut their use of graph grammars is for representing nestedhierarchical call graphs, not to model the behaviour of thesystem in terms of transformations on objects.Learning Models from Observations:[11] propose miningalgorithms for graph transformation systems from transitionsystems. Theircontext algorithmprovides similar outputsto our inferred maximal rule, but we differ in the strategyused. Their construction relies on extending the minimal ruleby adding matched context elements. Our approach is theopposite, based on cutting down unmatched contexts from achosen contract instance, which makes it easier to maintainthe graph structure as valid against the type-graph. To the bestof our knowledge, no work has been done on inferring multi-objects for visual contracts.In [12] source and target graphs represent networks ofbiomolecules. The authors aim to discover rules modellingreactions. They extract the minimal rule by best sub-graphmatching and adopt a statistical approach to rate context. Ourapproach is simpler in that the minimal rule is determined bytracing and we do not deal with uncertainty of context.Considering approaches to learning model transforma-tions [20], we distinguishin-placewhere source and targethave the same metamodel andout-placetransformations wherethe metamodels are different [21]. For learningout-placetrans-formations, [13] use input-output pairs representing the resultof a transformation process rather than a single step. [22], [23],[24] also address the learning ofout-placetransformations,while our approach focusses onin-placetransformations.[25] also addressing the learning ofin-placetransformationsis interactive, requiring conﬁrmation of the rules proposed.Our approach does not rely on direct user involvement and,signiﬁcantly, is not based on a small number of carefullyhand-crafted examples, but on large numbers of observationsextracted from a running system. Therefore, scalability andthe ability to deal with example sets providing incompletecoverage are important.Graph pattern mining:An algorithmic problem closelyrelated to the extraction of rules from example transformationsis graph pattern discovery. Current approaches are statisticalor node signature-based. Finding graph patterns by statisticalmeans is popular in machine learning [26], but can producea large variance depending on the frequency of a pattern. Forinstance, an object that is not accessed, but always present inthe context, is considered an important element of the rule.[27], [28] discuss research in exact and best graph patternmatching. A crucial point is how to distinguish nodes ascandidates for possible matches. In [29], a node signature forattributed graphs encodes node/edge types and node attributes.We use a node signature-based approach with added structuralinformation and metadata, extended from subgraph to subrulematching, taking into account shared minimal rules and pa-rameters.V.CONCLUSION ANDFUTUREWORKWe presented an integrated approach and tool for learningvisual contracts, from instrumentation of Java code and obser-vation of tests to the derivation of general rules with multi ob-jects and attribute constraints. It supports the analysis of testsbased on a concise, visual and comprehensive representationof operations’ behaviour. We have evaluated the validity of theresulting models, usability and scalability in experiments onthree case studies.Currently we work on improving the integration of ourtool with Henshin [10] to evaluate extracted contracts morewidely. This involves invoking the model alongside the orig-inal implementation with the same set of tests, comparingoutputs for consistency. Executing the tests the contracts wereextracted from adds to their validation of correctness, butmore interestingly we can try a range of additional casesto evaluate how well contracts capture the wider behaviour,beyond the directly observed. A related idea is the use foradaptive testing [30] where test cases are generated fromcontracts in a cycle of test generation, execution, and contractextraction.We also plan to use contract extraction to support testingand debugging, evaluating their effectiveness for these tasksmore comprehensively. Additionally, we will be investigatingtechniques such as Hyper/J [31] to support tracing and extrac-tion for multithread Java applications.ACKNOWLEDGMENTWe would like to thank Michel Chaudron and Neil Walkin-shaw for the valuable advice and feedback on conducting userexperiments.
113REFERENCES[1] T. A. Khan, O. Runge, and R. Heckel, “Testing against visual contracts:Model-based coverage,” inGraph Transformations - 6th InternationalConference, ICGT 2012, Bremen, Germany, September 24-29, 2012.Proceedings, 2012, pp. 279–293.[2] O. Runge, T. A. Khan, and R. Heckel, “Test case generation using visualcontracts,”ECEASST, vol. 58, 2013.[3] G. Engels, M. Lohmann, S. Sauer, and R. Heckel, “Model-drivenmonitoring: An application of graph transformation for design bycontract,” inGraph Transformations, Third International Conference,ICGT 2006, Natal, Rio Grande do Norte, Brazil, September 17-23, 2006, Proceedings, ser. Lecture Notes in Computer Science,A. Corradini, H. Ehrig, U. Montanari, L. Ribeiro, and G. Rozenberg,Eds., vol. 4178. Springer, 2006, pp. 336–350. [Online]. Available:http://dx.doi.org/10.1007/1184188324[4] J. H. Hausmann, R. Heckel, and M. Lohmann, “Model-baseddevelopment of web services descriptions enabling a precise matchingconcept,”Int. J. Web Service Res., vol. 2, no. 2, pp. 67–84, 2005.[Online]. Available:http://dx.doi.org/10.4018/jwsr.2005040104[5] A. M. Alshanqiti, R. Heckel, and T. A. Khan, “Learning minimal andmaximal rules from observations of graph transformations,”ElectronicCommunications of the EASST, vol. 58, 2013. [Online]. Available:http://journal.ub.tu-berlin.de/eceasst/article/view/848[6] A. M. Alshanqiti and R. Heckel, “Towards dynamic reverse engineeringvisual contracts from Java,”Electronic Communications of the EASST,vol. 67, 2014. [Online]. Available:http://journal.ub.tu-berlin.de/eceasst/article/view/940[7] H. Ehrig, K. Ehrig, U. Prange, and G. Taentzer,Fundamentals ofAlgebraic Graph Transformation (Monographs in Theoretical ComputerScience. An EATCS Series). pp 12, 21,22, Secaucus, NJ, USA: Springer-Verlag New York, Inc., 2006.[8] D. Bisztray, R. Heckel, and H. Ehrig, “Veriﬁcation of architectural refac-torings: Rule extraction and tool support,”Proceedings of the DoctoralSymposium at the International Conference on Graph Transformation -Electronic Communications of the EASST, vol. 16, 2009.[9] M. D. Ernst, J. H. Perkins, P. J. Guo, S. McCamant, C. Pacheco,M. S. Tschantz, and C. Xiao, “The Daikon system for dynamicdetection of likely invariants,”Science of Computer Programming,vol. 69, no. 13, pp. 35 – 45, 2007, special issue on ExperimentalSoftware and Toolkits. [Online]. Available:http://www.sciencedirect.com/science/article/pii/S016764230700161X[10] T. Arendt, E. Biermann, S. Jurack, C. Krause, and G. Taentzer,“Henshin: Advanced concepts and tools for in-place EMF modeltransformations,” inModel Driven Engineering Languages and Systems- 13th International Conference, MODELS 2010, Oslo, Norway,October 3-8, 2010, Proceedings, Part I, ser. Lecture Notes inComputer Science, D. C. Petriu, N. Rouquette, and Ø. Haugen,Eds., vol. 6394. Springer, 2010, pp. 121–135. [Online]. Available:http://dx.doi.org/10.1007/978-3-642-16145-29[11] H. Bruggink, “Towards process mining with graph transformationsystems,” inGraph Transformation, ser. Lecture Notes in ComputerScience, H. Giese and B. Knig, Eds. Springer InternationalPublishing, 2014, vol. 8571, pp. 253–268. [Online]. Available:http://dx.doi.org/10.1007/978-3-319-09108-217[12] C. h. You, L. B. Holder, and D. J. Cook, “Learning patterns in thedynamics of biological networks,” inProceedings of the 15th ACMSIGKDD International conference on Knowledge discovery and datamining, ser. KDD ’09. New York, NY, USA: ACM, 2009, pp. 977–986.[13] X. Dolques, A. Dogui, J.-R. Falleri, M. Huchard, C. Nebut, and F. Pﬁs-ter, “Easing model transformation learning with automatically alignedexamples,” inProceedings of the 7th European conference on Modellingfoundations and applications, ser. ECMFA’11. Berlin, Heidelberg:Springer-Verlag, 2011, pp. 189–204.[14] M. K. Sarkar, T. Chatterjee, and D. Mukherjee, “Reverse engineering:An analysis of static behaviors of object oriented programs by extractingUML class diagram,”International Journal of Advanced ComputerResearch, vol. 3, no. 3, 2013.[15] A. Rountev, O. Volgin, and M. Reddoch, “Static control-ﬂow analysisfor reverse engineering of UML sequence diagrams,”SIGSOFT Softw.Eng. Notes, vol. 31, no. 1, pp. 96–102, Sep. 2005.[16] P. Tonella and A. Potrich, “Reverse engineering of the interactiondiagrams from C++ code,” inSoftware Maintenance, 2003. ICSM 2003.Proceedings. International Conference on. IEEE, Sept 2003, pp. 159–168.[17] H. Brito, H. Marques-Neto, R. Terra, H. Rocha, and M. Valente, “On-the-ﬂy extraction of hierarchical object graphs,”Journal of the BrazilianComputer Society, pp. 1–13, 2012.[18] T. Ziadi, M. A. A. Da Silva, L. M. Hillah, and M. Ziane, “A fully dy-namic approach to the reverse engineering of UML sequence diagrams,”in16th IEEE International Conference on Engineering of ComplexComputer Systems (ICECCS). IEEE, 2011, pp. 107–116.[19] C. Zhao, J. Kong, and K. Zhang, “Program behavior discovery and ver-iﬁcation: A graph grammar approach,”IEEE Transactions on SoftwareEngineering, vol. 36, no. 3, pp. 431–448, 2010.[20] G. Kappel, P. Langer, W. Retschitzegger, W. Schwinger, and M. Wim-mer, “Conceptual modelling and its theoretical foundations,” inCon-ceptual Modelling and Its Theoretical Foundations,A .D¨usterh¨oft,M. Klettke, and K.-D. Schewe, Eds. Berlin, Heidelberg: Springer-Verlag, 2012, ch. Model transformation by-example: a survey of theﬁrst wave, pp. 197–215.[21] T. Mens and P. Van Gorp, “A taxonomy of model transformation,”Electron. Notes Theor. Comput. Sci., vol. 152, pp. 125–142, Mar. 2006.[22] M. Faunes, H. Sahraoui, and M. Boukadoum, “Generating modeltransformation rules from examples using an evolutionary algorithm,”inProceedings of the 27th IEEE/ACM International Conference onAutomated Software Engineering, ser. ASE 2012. New York, NY, USA:ACM, 2012, pp. 250–253.[23] D. Varr, “Model transformation by example,” inIn Proceedings of theACM/IEEE 9th International Conference on Model Driven EngineeringLanguages and Systems (MoDELS/UML). Springer, 2006, pp. 410–424.[24] Z. Balogh and D. Varr, “Model transformation by example usinginductive logic programming,”International Journal - Software andSystems Modeling, vol. 8, no. 3, pp. 347–364, 2009.[25] P. Langer, M. Wimmer, and G. Kappel, “Model-to-model transforma-tions by demonstration,” inProceedings of the Third international con-ference on Theory and practice of model transformations, ser. LectureNotes in Computer Science, L. Tratt and M. Gogolla, Eds. SpringerBerlin Heidelberg, 2010, vol. 6142, pp. 153–167.[26] M. Qiu, H. Hu, Q. Jiang, and H. Hu, “A new approach of graphisomorphism detection based on decision tree,” inEducation Technologyand Computer Science (ETCS), 2010 Second International Workshop on,vol. 2. IEEE, 2010, pp. 32–35.[27] D. Conte, P. Foggia, C. Sansone, and M. Vento, “Thirty years ofgraph matching in pattern recognition,”International journal of patternrecognition and artiﬁcial intelligence, vol. 18, no. 03, pp. 265–298,2004.[28] N. Dahm, H. Bunke, T. Caelli, and Y. Gao, “Efﬁcient subgraph matchingusing topological node feature constraints,”Pattern Recognition, vol. 48,no. 2, pp. 317 – 330, 2015.[29]S. Jouili, I. Mili, and S. Tabbone, “Attributed graph matching usinglocal descriptions,” inAdvanced Concepts for Intelligent Vision Systems- Acivs 2009, ser. Lecture Notes in Computer Science, SEE. Springer,2009, pp. 89–99.[30] K.-Y. Cai, T. Y. Chen, Y.-C. Li, W.-Y. Ning, and Y. T. Yu,“Adaptive testing of software components,” inProceedings of the2005 ACM Symposium on Applied Computing, ser. SAC ’05. NewYork, NY, USA: ACM, 2005, pp. 1463–1469. [Online]. Available:http://doi.acm.org/10.1145/1066677.1067011[31] H. Ossher and P. Tarr, “Hyper/j: Multi-dimensional separation ofconcerns for Java,” inProceedings of the 22Nd InternationalConference on Software Engineering, ser. ICSE ’00. New York,NY, USA: ACM, 2000, pp. 734–737. [Online]. Available:http://doi.acm.org/10.1145/337180.337618
114
View publication stats