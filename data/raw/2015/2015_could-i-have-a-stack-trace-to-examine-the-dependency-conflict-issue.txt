Could I Have a Stack Trace to Examine the
Dependency Conï¬‚ict Issue?
Ying Wangâˆ—, Ming Wenâ€ , Rongxin Wuâ€ Â§, Zhenwei Liuâˆ—, Shin Hwei Tanâ€¡,
Zhiliang Zhuâˆ—, Hai Yuâˆ—and Shing-Chi Cheungâ€ Â§
âˆ—Northeastern University, Shenyang, China
Email: {wangying8052, lzwneu}@163.com, {yuhai, zzl}@mail.neu.edu.cn
â€ The Hong Kong University of Science and Technology, Hong Kong, China
Email: {mwenaa, wurongxin, scc}@cse.ust.hk
â€¡Southern University of Science and Technology, Shenzhen, China
Email: tansh3@sustc.edu.cn
Abstract â€”Intensive use of libraries in Java projects brings
potential risk of dependency conï¬‚icts, which occur when a
project directly or indirectly depends on multiple versions of
the same library or class. When this happens, JVM loads
one version and shadows the others. Runtime exceptions can
occur when methods in the shadowed versions are referenced.
Although project management tools such as Maven are able to
give warnings of potential dependency conï¬‚icts when a project
is built, developers often ask for crashing stack traces before
examining these warnings. It motivates us to develop R IDDLE ,
an automated approach that generates tests and collects crashing
stack traces for projects subject to risk of dependency conï¬‚icts.
RIDDLE , built on top of A SMand E VOSUITE , combines condition
mutation, search strategies and condition restoration. We applied
RIDDLE on 19 real-world Java projects with duplicate libraries or
classes. We reported 20 identiï¬ed dependency conï¬‚icts including
their induced crashing stack traces and the details of generated
tests. Among them, 15 conï¬‚icts were conï¬rmed by developers
as real issues, and 10 were readily ï¬xed. The evaluation results
demonstrate the effectiveness and usefulness of R IDDLE .
Index T erms â€”test generation, third-party library, mutation
I. I NTRODUCTION
Java projects are commonly built on top of third-party
libraries, which may in turn have reference to other libraries
[1]â€“[3]. According to Javaâ€™s class loading mechanism, the
speciï¬ed classpath determines the locations where to ï¬nd
the referenced classes during runtime [4], [5]. If multiple
versions of the same library or class are present on a classpath ,
only one version will be loaded while the others will be
shadowed [6]. A DC (D ependency C onï¬‚ict) issue occurs if
these versions are incompatible. Runtime exceptions (e.g.,
ClassNotFoundException and NoSuchMethodError ) will
be thrown when a project references the methods of incom-
patible shadowed versions at runtime [7].
Most software management tools such as Maven [8]
support the detection of potential DC issues and give
warnings accordingly. However, they only warn developers
of the duplicate classes or libraries rather than all instances
of duplication that will induce runtime exceptions. Therefore,
Â§Rongxin Wu and Shing-Chi Cheung are the corresponding au-
thors.developers often want to have a stack trace to validate the
risk of these warned DC issues. It echoes earlier ï¬ndings that
stack traces provide useful information for debugging [9],
[10]. We observe that developers can more effectively locate
the problem of those DC issues accompanied by stack traces
or test cases than those without. For instance, a DC issue
Issue #57 [11] was reported to project FasterXML with
details of the concerning library dependencies and versions.
Nevertheless, the project developer asked for a stack trace to
conï¬rm if the reported issue is a problem.
â€œI would need full stack trace to make sure exactly where
the problem occurs. If that still happens, I need stack trace
to investigate further . At this point, this issue will be closed,
assuming the problem has been resolved. But please reopen
it if the issue is reproducible, and stack trace is available as
additional information. â€
1. @Api
2. @SwaggerDefinition(tags = @Tag(name = "test",extensions=
3. @Extension(name= "test",properties = @ExtensionProperty(name = "test", value = ""))))
4. public class Test {
5.public static void main(String[] args) {
6. BeanConfig beanConfig  = FF4jSwaggerConfiguration.getBeanConfig(); 
7. beanConfig .setResourcePackage( "org.ff4j.web.api" ); 
8. beanConfig .setScan( true); //Entry method
9.}
10.}
141. if (reflections.getTypesAnnotatedWith(SwaggerDefinition. class) != null) {
142.    Swagger swagger = readSwaggerConfig(classes);
143. ...
144. }
Exception in thread "main" java.lang.NoSuchMethodError: 
org.apache.commons.lang3.StringUtils.prependIfMissing(Ljava/lang/String;Ljava/lang/
CharSequence;[Ljava/lang/CharSequence;)Ljava/lang/String;
1. at io.swagger.util.BaseReaderUtils.parseExtensions(BaseReaderUtils.java:30)
2. 
at io.swagger.jaxrs.Reader.readSwaggerConfig(Reader.java:462)3. 
at io.swagger.jaxrs.Reader.read(Reader.java:142)4. 
at io.swagger.jaxrs.config.BeanConfig.setScan(BeanConfig.java:172)A manual test
Code snippet of method 
read(Reader.java)
Stack trace173. AbstractReader configReader ;
174. ...
175. configReader.read();Code snippet of method 
setScan(BeanConfig.java)(a)
(b)
(c)
(d)...
5.
Fig. 1: An example of a test for Issue #309
Similar observations can be made in many other DC issues
(e.g., Issue #8706 [12], Issue #501 [13], etc.). Developers
showed more interests in a failing test case or stack trace
to know what the conditions of triggering the shadowed
methods are. Consider the following example. In Issue #309
[14], Ff4j directly depends on libraries commons-lang3
3.0 and swagger-core 1.5.4 , and transitively references
5722019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)
1558-1225/19/$31.00 Â©2019 IEEE
DOI 10.1109/ICSE.2019.00068
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:17 UTC from IEEE Xplore.  Restrictions apply. the features included in commons-lang3 3.2.1 via library
swagger-core 1.5.4 . According to Maven â€™s loading mech-
anism for duplicate JARs, library commons-lang3 3.2.1 will
be shadowed. Figure 2 shows the two paths identiï¬ed by static
analysis from the entry method setScan() deï¬ned in Ff4j to
the methods that only deï¬ned in the shadowed library. On the
two paths, classes DefaultReader and Reader implement the
method read deï¬ned in the abstract class AbstractReader ,
as shown in Figure 1 (c).
Path 1 : BeanConÄ®g.setScan Ã†  DefaultReader.read  Ã† DefaultReader. readSwaggerCon Ä®g Ã†â€¦ 
Ã† ReaderU ÆŸls.collectConstructorParameters Ã† commons-lang3.ObjectU ÆŸls.idenÆŸtyToString .
Path 2 : BeanCon Ä®g.setScan Ã†  Reader.read  Ã† Reader. readSwaggerCon Ä®g Ã† â€¦ Ã†
BaseReaderU ÆŸÅ¯s.parseExtensions Ã† commons-lang3.StringU ÆŸls.prependIfMissing .
Fig. 2: Two paths identiï¬ed by static analysis from the entry method
to shadowed methods
However, due to dynamic binding, compiler could
only resolve at run time whether to use method
DefaultReader.read orReader.read . This illustrates
the shortcoming of static analysis. In this case, with the aid
of the test shown in Figure 1 (a), we get a crash with the
stack trace shown in Figure 1 (d). Stack trace consists of a
sequence of methods that were active on the call stack at
the time that an exception occurred due to the DC issue.
Each stack frame contains the full-qualiï¬ed name of method
and the exact location of the execution inside the source
code together with a ï¬le name and line number [15]. It
can capture precise runtime information such as dynamic
bindings for developers to facilitate the debugging tasks. It
also demonstrates the feasibility of reproducing the DC issue.
This motivates us to study how to generate tests (including
test inputs and test scripts) that lead to failures for DC issues.
For ease of presentation, we refer to the project dependent
on libraries as a host project ; the method in a shadowed class
version as a shadowed method ; and a branch containing a
call site of a shadowed method as a target branch hereafter.
A major challenge of test generation for DC issues lies in
the difï¬culties in reaching the target branches along the path
from entry methods deï¬ned in a host project to the shadowed
methods provided by third party libraries. Especially, the
conditions on the path may involve complex object creation,
private method invocation or ï¬eld accesses, etc., making the
conditions hard to construct [16]. For instance, we can tell that
to reach the target branch, the test ( Lines 1-3 ,and 7) shown
in Figure 1 (a), covers a complex condition in Line 141 of
the code snippet shown in Figure 1 (b). However, this branch
condition involves the environment dependency and complex
objects, which are difï¬cult for test generation tools to construct
automatically.
Wang et al. conducted an empirical study on open source
Java projects to characterize DC issues. Leveraging the em-
pirical study results, they developed D ECCA , a static analysis
tool, to detect DC issues with a high precision [7]. However,
there is no prior work on the test generation for DC issues. In
this paper, we present R IDDLE (tRIgger D epenD ency confL ict
crashE s), the ï¬rst automated test generation technique for DCissues. R IDDLE works in two phases: condition mutation and
condition restoration. In the ï¬rst phase of condition mutation,
it identiï¬es program paths from an entry methods to shadowed
methods. It mutates the conditions of each branch in an
identiï¬ed path by making them evaluated to be TRUE or
FALSE so as to force a test execution along the path that
invokes a shadowed method. We call the mutation operation
forcing a condition evaluating to trigger a desirable branch as
short-circuiting , and the program after mutation as a program
variant . Consider the above example shown in Figure 1, after
short-circuiting the unsolvable branch condition ( Line 141 )
in method read , a crash can be triggered by an automatic
generated test, as shown in Figure 3.
1. @Test(timeout = 4000)
2. public void test0()  throws Throwable  {
3.    BeanConfig beanConfig0 = FF4jSwaggerConfiguration.getBeanConfig();
4.    beanConfig0.setScan( true);
5. }  //generate stack trace with NoSuchMethodError
Fig. 3: An automatic generated test for Issue #309 after short-
circuiting an unsolvable branch condition
Short-circuiting offers two advantages. Firstly, it signiï¬-
cantly increases the chances of generating a stack trace (i.e.,
runtime information) leading to a DC issue. It helps to collect
runtime information required to reach the target branches
that often involve environment dependencies and non-linear
constraints, which are known to be difï¬cult to solve [16].
Secondly, when a target branch cannot be reached using short-
circuiting, it identiï¬es the key constraints to be solved in order
to reach a potential DC issue. For example, when a short-
circuited condition involves dereferencing a null-initialized
object variable, those constraints that compute a proper value
for this variable need to be solved. Otherwise, the program
execution catches a NullPointerException at the short-
circuited branch and terminates before reaching the target
branch. We will discuss it in Section IV-B.
The ï¬rst phase generates a set of program variants with
short-circuited branch conditions along the path that invokes
an identiï¬ed shadowed method. In the second phase of condi-
tion restoration, R IDDLE ï¬rst uses a guided search-based strat-
egy to generate tests for each short-circuited program variant.
Then, it iteratively restores solvable conditions to (1) capture
more precise runtime information with more solved constraints
and (2) reduce infeasible behaviors caused by short-circuiting.
Besides the stack trace obtained after condition restoration,
RIDDLE provides the details of remaining branch conditions
that cannot be solved after restoration to developers for further
checking. From the feedback of the reported issues (see
Section IV-C), we observed that developers can easily work
out the above unrestored branch conditions based on their
domain knowledge of their own projects.
We applied R IDDLE to analyze the latest version of 19
real-world Java projects with duplicate libraries or classes,
which include 1.3 million of lines of code, to generate tests to
produce their failure-introducing conditions and inputs. Then,
we reported 20 identiï¬ed DC issues with full stack traces
and test cases. So far, we have received acknowledgment
573
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:17 UTC from IEEE Xplore.  Restrictions apply. from developers on 15 reported issues. Ten of them have
been quickly ï¬xed. Most of the conï¬rmed issues are iden-
tiï¬ed in popular projects such as Apache azure storage
[17], Google truth [18], Webmagic [19], etc. These results
demonstrate that R IDDLE can provide useful test information
to facilitate issue diagnosis and ï¬xing. To summarize, we make
the following contributions in this paper:
â€¢To the best of our knowledge, we proposed the ï¬rst au-
tomated test generation technique to produce the failure-
introducing conditions and inputs of DC issues.
â€¢We provide a publicly available implementation of the
technique, R IDDLEa. It can be considered as an extension
to the search-based test generation tool, E VOSUITE [20].
â€¢The experimental evaluation on real-world projects shows
the effectiveness and usefulness of the proposed technique.
II. P RELIMINARIES
A. Problem F ormulation
DC issues arise when the loaded classes do not cover the
methods referenced by a project [7]. Generally, DC issues are
manifested at two granularities:
â€¢Class level: Conï¬‚icts in classes among libraries, or between
host project and libraries. If duplicate classes exist in one
project, only one version will be loaded based on the class
loading mechanism. In this case, host project will throw
NoSuchMethodError etc. when referencing the methods
that are not deï¬ned in loaded classes.
â€¢Library level: Conï¬‚icts in library versions. If a project
directly or transitively depends on multiple versions of
the same library, one will shadow the others during the
packaging process of build tool. In such scenario, the host
project will crash with ClassNotFoundException etc.
when referencing the methods belonging to the classes only
included in the shadowed library.
In this work, we deï¬ne multiple versions of class Cior
library Lib ias potential DC issue Ii. Consider a host project
Hwith a set of potential DC issues I={I1,I2,Â·Â·Â·,In}.F o r
each IiâˆˆI,Siis the method set deï¬ned in the shadowed
version of class Cior library Lib iandRH iis the method set
belonging to duplicate class Cior library Lib iand referenced
by project H. To formulate our research problem, we introduce
the following concepts.
Deï¬nition 1. (Risky method set): IfRi=RH i/intersectiontextSi/negationslash=âˆ…,
we deï¬ne Ri={rf1,r f 2,Â·Â·Â·,r f|Ri|}as the risky method
set for issue Ii, since the runtime exceptions will be thrown
when project Hhas references to any risky method rfmâˆˆR i.
Deï¬nition 2. (Boundary class): Suppose class BC kbe-
longs to host project Hand directly depends on the meth-
ods of third library Lib i. We then deï¬ne class BC kas
a boundary class between host project and third party li-
braries. For each risky method rfmâˆˆR i, there is a set
of boundary classes in project Hthat directly or transitively
reference it. We denote such a boundary class set as CLi=
{BC 1,BC 2,Â·Â·Â·,BC|CL i|}.
ahttps://skillwind.github.io/RiddleDC/index.htmlProblem deï¬nition: Given a project with DC issue Ii,
our research problem is to generate a test tp(test in-
puts and test script) to trigger the execution of any risky
method rfmâˆˆR i, thereby causing runtime exceptions (i.e.,
NoSuchMethodError ,ClassNotFoundException , etc.).
B. Motivation
Issue reports are vital for any software development. They
allow users to inform developers of the problems encountered
while using a piece of software. Recent research [21], [22],
[23]â€“[25] shows that providing stack traces or test cases can
greatly elevate the quality of issue reports. Stack traces are
useful runtime information, which can support developers in
debugging tasks [15], [26].
To investigate the importance of a stack trace in validating
DC issue reports, we conducted an empirical study to check
whether the conï¬rmation rate is different between DC issues
with stack traces and those without. We collected the subjects
satisfying the following two criteria. First, the Java project
have received more than 50 stars or forks (popularity). Second,
the bug tracking system of each selected Java project contains
two types of DC issues: with and without stack traces. In this
manner, we can minimize the impacts of maintenance activity
of different projects on the statistics. Note that we used the
keywords â€œlibraryâ€, â€œdependencyâ€, â€œconï¬‚ictâ€, etc. to search
the DC issues and reï¬ned the results by manual checking to
remove the noisy ones. For the DC issues without stack traces,
we manually checked the results and only collected the ones
with clear description of problem manifestation. Eventually,
we obtained 22 Java projects with 59 DC issuesb.
Furthermore, we manually investigated the collected 59
issue reports and related discussions to calculate the time
(days) for conï¬rmation, which is the duration from the opening
time of an issue report to the time when this issue is conï¬rmed.
For the unconï¬rmed issues, we consider their unconï¬rmed
duration (days) from the issue open time to data collection
time.
0200400600800100012001400
With stack traces Without stack tracesÂÂšÂÂ’Â›ÂÂÈ±Â’Â–ÂÈ±ÂÂ˜Â›È±Â˜Â—Ä™Â›Â–ÂŠÂÂ’Â˜Â—È±Ç»ÂÂŠÂ¢ÂœÇ¼
Fig. 4: Required time for conï¬rmation of the two types of DC issues
Figure 4 reports the time for conï¬rmation of two types of
DC issues. We observed that, on average, the reported DC
issues with stack traces can be conï¬rmed by developers 521
days faster than those without. The result indicates that the
stack traces indeed help to speed up validation process for
DC issues.
bhttps://github.com/skillwind/Empirical-Study-Subjects
574
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:17 UTC from IEEE Xplore.  Restrictions apply. C. Challenge
Figure 5 shows an example to explain the research chal-
lenges of the problem. The host project directly depends
ona-1.0.Jar and b-2.0.Jar , and library b-1.0.Jar is
transitively introduced by a-1.0.Jar . As we can see, the
project depends on two versions of library b. Suppose the
project is built by Maven , then b-1.0.Jar will be shadowed
based on Maven â€™snearest wins strategy and b-2.0.Jar is
loaded as it appears at the nearest to the root (host project) of
the dependency tree. By static analysis, host project references
method D() which is only included in the shadowed JAR.
1. public class ClassA {
2.boolean flag;
3.BigDecimal var = null;
4.ClassC Clc = new ClassC();
5.ClassE Cle = new ClassE();
6.ClassB Clb;
7.public void main(String args){
8.  A(); //C1 
9.     if(OptionHelper .getSystemProperty 
(CONFIG_FILE_PROPERTY )!= null)
10.    B(); //C2
11.  else
12.    E(); //C3                
}13.
void A(){ 14.
    Clb.F(); //C4 
}15.
void B(){16.
      Clc.G(var) //C5
       }17.
void E(){18.
    if(flag)19.
Cle.C() //C6;20.
    else21.
Clc.G(var); //C7        
}22. 
1.public class ClassE {
2.    void C(){
3. //no call sites       
}  4.
}1.public class ClassE {
2.    void C(){
3. //no call sites 
}  4.
void D(){ 5.
//no call sites 
}6.
}.UYZVXUPKIZ
1. interface  ClassB {
2.    void F();               
3.  }
4. public class ClassC implements  ClassB{
5.    ClassA Cla = new ClassA();
6.    ClassE Cle = new ClassE();
7.    public void F(){
8. G(Cla.var); //C8 
}9.
void G(BigDecimal var){ 10.
    if(var!=null){ 11.
Cla.var.abs(); 12.
Cle.D(); //C9 13.
}else 14.
Cle.C(); //C10   
}15.
}16.
public class ClassD implements  ClassB{17.
public void F(){18.
//no call sites 
}19.
}Gç‡¦ç‡¥0GX
Hç‡¦ç‡¥0GX
Hç‡§ç‡¥0GX;
23.
24.
25.20.
21.
22.
7.
8. 5.
Fig. 5: Source code of motivation example
Using the example, we explain the major research challenge
of test generation for a given Java project with DC issues.
Challenge It is difï¬cult to resolve complex branch condi-
tions to trigger the shadowed methods. Existing search-based
tools like E VOSUITE are less ineffective in handling complex
branch conditions. They provide little guidance to search the
boolean ï¬‚ags and create complex object instances as required
by these conditions [16]. Consider ClassA deï¬ned in the host
project as the boundary class under test. To trigger the runtime
exception caused by this DC issue, the execution of main()
under tests (inputs) should cover risky method D(). However,
the invocation path from main() toD()passes through a third
party library a-1.0.Jar , which introduces more complex
conditions preventing generated tests from reaching the target
branches. For instance, to ensure that a test executes along
the invocation path main()â†’B()â†’G()â†’D(), it should
cover the conditional branches in Line 9 ofmain() and Line
11ofG(). However, the condition statement in main() is
implemented to obtain the local path of a log conï¬guration
ï¬le from system property, which is unlikely to be constructed
by test generation tools.
RIDDLE uses a genetic algorithm to evolve sets of candidate
tests, which aims to maximize the possibility of triggeringthe risky method execution with the deï¬ned guidance criteria.
To address the above challenge, R IDDLE short-circuits all the
branch conditions in the path main()â†’B()â†’G()â†’
D(), to force the execution of generated tests to cover these
desirable branches. In this manner, the complex condition in
Line 9 ofmain() can be overcome.
However, infeasible behaviors can be introduced by short-
circuiting. Consider the conditional branch in Line 10 of
G(). In the case that instance var is a null-initialized object
variable, the tests will trigger a NullPointerException at
the statement Cla.var.abs() , if we force the above condition
to be TRUE .RIDDLE solves this key constraint by restoring the
branch condition of in Line 10 ofG(). After restoring this
condition, R IDDLE overcomes this branch by passing a non-
null object of type BigDecimal to method G(). Based on the
above steps, risky method D()ï¬nally can be covered by gener-
ated tests. Besides, for the unrestored branch condition ( Line
9ofmain() ), R IDDLE provides its details to developers for
further checking.
III. T EST GENERATION
A. Overview
In this work, we propose a test generation approach, R ID-
DLE. It takes the project with DC issues as input, and output
the generated tests that can trigger the risky methods. Figure
6 shows an overview of our approach. It mainly contains the
following four steps.
â€¢Step 1: Static analysis. RIDDLE identiï¬es risky method
set for each DC issue and then extracts the control ï¬‚ow
dependencies to construct IMCFG (I nter-m ethod C ontrol
Flow G raph).
â€¢Step 2: Condition mutation. RIDDLE short-circuits the
branches that can reach to an identiï¬ed risky method, by
forcing their condition statements to be evaluated to be TRUE
orFALSE ,RIDDLE forces the execution of tests to cover
these desirable branches.
â€¢Step 3: Search-based test strategy. RIDDLE uses a genetic
algorithm to evolve sets of candidate tests, which aims
to maximize the possibility of triggering the risky method
execution.
â€¢Step 4: Condition restoration. To reduce the infeasible
behaviors caused by condition mutations, R IDDLE restore
the mutated branches in IMCFG depth by depth, and check
whether the generated tests can cover risky methods in
these cases. If so, it retains the restored branch conditions.
Otherwise, it labels the conditions as unrestored conditions.
Finally, R IDDLE provides program variants with unrestored
branch conditions to developers for further checking their
feasibility.
B. Static Analysis
In the static analysis phase, R IDDLE ï¬rst identiï¬es the risky
method set for each DC issue and then constructs IMCFG by
control ï¬‚ow analysis and call graph analysis.
Identiï¬cation for risky method set. We obtain the multiple
versions of library Lib ior class Ci, as well as referenced
575
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:17 UTC from IEEE Xplore.  Restrictions apply. 1.public class ClassE {
2.    void D(){ }
3.}.UYZVXUPKIZ Gç‹£ç‹¢0GX
Hç‹£ç‹¢0GX Hç‹¤ç‹¢0GX&)*RI& &)*RI'&)*RIPDLQ &)*RI$
&)*RI(
&)*RI&ODVV&) &)*RI* &)*RI&ODVV')æ¿˜ç€ç€‡ç€…ç€Œ
æ¿–æ¿„
æ¿–æ¿…æ¿–æ¿†
æ¿˜ç€‹æ¿¼ç€‡æ¿˜ç€ç€‡ç€…ç€Œ
æ¿˜ç€‹æ¿¼ç€‡æ¿–æ¿‡&)*RI%
æ¿˜ç€ç€‡ç€…ç€Œ
æ¿˜ç€‹æ¿¼ç€‡æ¿˜ç€ç€‡ç€…ç€Œ
æ¿˜ç€‹æ¿¼ç€‡
æ¿˜ç€ç€‡ç€…ç€Œ
æ¿˜ç€‹æ¿¼ç€‡æ¿–æ¿‹æ¿˜ç€ç€‡ç€…ç€Œ
æ¿–æ¿Œæ¿–æ¿„æ¿ƒ
æ¿˜ç€‹æ¿¼ç€‡æ¿˜ç€ç€‡ç€…ç€Œ
æ¿–æ¿‰æ¿–æ¿Š
æ¿˜ç€‹æ¿¼ç€‡æ¿˜ç€ç€‡ç€…ç€Œ
æ¿˜ç€‹æ¿¼ç€‡æ¿–æ¿ˆ
æ¿˜ç€ç€‡ç€…ç€Œ
æ¿˜ç€‹æ¿¼ç€‡Static analysis
Construct MLCFG
Risky method647'
647'Condition mutation
Fitness funcionSearch-based test  strategy
Risk feature647'Condition restoration
/ÄšÄÅ¶ÆŸÄ¨Ç‡ÆŒÅÆÅ¬Ä¨ÄÄ‚ÆšÆµÆŒÄÆÄÆš NBJO	
"	
 #	
 &	
$MBTT%'	
$MBTT$'	
(	
$	
NBJO	
&	
 #	
"	
$MBTT%'	
$MBTT$'	
(	
$	
&YDFQUJPO
Fig. 6: Logical architecture of R IDDLE
method set RH i, by analyzing dependency tree and bytecode
(JAR or class ï¬les). Note that, the dependency tree can
be readily extracted from projectsâ€™ dependency management
script (e.g., pom.xml ,build.gradle etc.). Furthermore, the
method set Sideï¬ned in the shadowed version of Lib iorCi
is deduced based on the class loading rules of build tools.
In this work, R IDDLE identiï¬es the shadowed method set ac-
cording to Mavenâ€™s class loading mechanism, which has been
systematically summarized in Wang et al.â€™s empirical study
[7]. Finally, for any DC issue Ii, we extract its corresponding
risky method set Ri=RH i/intersectiontextSi.
IMCFG construction. Control ï¬‚ow dependencies among
method calls help to guide testing to cover the identiï¬ed risky
methods. Inspired by Wu et al.â€™s approach [9], we construct a
reduced version of control ï¬‚ow graph that only preserves the
intraprocedural control ï¬‚ow dependencies for call sites within
a method. Besides, we apply call graph analysis to build the
interprocedural edges between methods. Based on the above
steps, we can statically build the IMCFG. Formally, IMCFG
is deï¬ned as follows.
Deï¬nition 3. (Inter-method control ï¬‚ow graph): G=
{Vf,Vc,Ef,Ec}, where Vfis a set of nodes, each of which
represents a method that is passed through by the program
paths from any entry method efndeï¬ned in boundary class
BC kto any risky method rfmâˆˆR i;Vcrepresents a set of
call sites pointing to the methods in Vf;Ef={<f i,fj>
|fi,fjâˆˆVf}, which denotes a set of invocation relationships
between methods, including the dynamic bindings; and Ec=
{<c i,cj>|ci,cjâˆˆVc}, which is a set of intraprocedural
control ï¬‚ow dependencies between call sites.
Deï¬nition 4. (Conditional branch): Ifâˆƒ<f i,fj>âˆˆEf
and there are at least one control ï¬‚ow path from entry to
exit that do not pass through the call site pointing to method
fjin the intraprocedural control ï¬‚ow graph of fi, then we
deï¬ne <f i,fj>as a conditional branch. Also, we denote its
conditional statement as Tij, which is equivalent to a boolean
variable TRUE orFALSE .
Deï¬nition 5. (Polymorphic branch): Ifâˆƒ<f i,fj>âˆˆEf
and the invocation relationship between fiandfjis caused
by dynamic binding, then <f i,fj>is considered as a
polymorphic branch.
Deï¬nition 6. (Branch node): Ifâˆƒ<f k,ft>is a
conditional or polymorphic branch in IMCFG, we consider
fkis a branch node .
We implemented the above static analysis based on theSoot [27] framework. R IDDLE leverages Soot â€™s program
dependency graph, control ï¬‚ow graph and call graph APIs
to construct IMCFG and identify the referenced risky method
set based on D ECCA . Figure 7 exempliï¬es the IMCFG con-
struction for the sample code shown in Figure 5. To explain
the correspondences between the call sites and methods in
Figure 7, we labeled the call site symbols as code comments
in Figure 5. With the aid of interprocedural edges, we obtain
the three invocation paths from entry method main() to risky
method D():main()â†’A()â†’ClassC.F() â†’G()â†’D();
main()â†’B()â†’G()â†’D(); and main()â†’E()â†’G()
â†’D(). By analyzing the CFG of each method, we found that
main()â†’B(),main()â†’E(),E()â†’G(),E()â†’C(),G()
â†’D() and G()â†’C() are conditional branches, since their
execution is determined by control conditions. Moreover, A()
â†’ClassC.F() and A()â†’ClassD.F() are polymorphic
branches, whose execution is determined by dynamic bindings.
&)*RI& &)*RI'&)*RIPDLQ &)*RI$
&)*RI(
&)*RI&ODVV&) &)*RI* &)*RI&ODVV')æ¿˜ç€ç€‡ç€…ç€Œ
æ¿–æ¿„
æ¿–æ¿…æ¿–æ¿†
æ¿˜ç€‹æ¿¼ç€‡æ¿˜ç€ç€‡ç€…ç€Œ
æ¿˜ç€‹æ¿¼ç€‡æ¿–æ¿‡&)*RI%
æ¿˜ç€ç€‡ç€…ç€Œ
æ¿˜ç€‹æ¿¼ç€‡æ¿˜ç€ç€‡ç€…ç€Œ
æ¿˜ç€‹æ¿¼ç€‡
æ¿˜ç€ç€‡ç€…ç€Œ
æ¿˜ç€‹æ¿¼ç€‡æ¿–æ¿‹æ¿˜ç€ç€‡ç€…ç€Œ
æ¿–æ¿Œæ¿–æ¿„æ¿ƒ
æ¿˜ç€‹æ¿¼ç€‡æ¿˜ç€ç€‡ç€…ç€Œ
æ¿–æ¿‰æ¿–æ¿Š
æ¿˜ç€‹æ¿¼ç€‡æ¿˜ç€ç€‡ç€…ç€Œ
æ¿˜ç€‹æ¿¼ç€‡æ¿–æ¿ˆ
æ¿˜ç€ç€‡ç€…ç€Œ
æ¿˜ç€‹æ¿¼ç€‡Call site
Control flow
dependency
Invocation
relationship
Dynamic
binding
Fig. 7: IMCFG of the example code
C. Search-based Test Strategy
As symbolic execution techniques suffer from path ex-
plosion problem and require constraint solving [28], [29],
we selected the search-based unit test generation tool, E VO-
SUITE [20], to build R IDDLE . Our approach improves its
coverage criterion to trigger the failures caused by DC issues.
For a given host project Hwith DC issue Ii,EVOSUITE
considers one boundary class BC kâˆˆCL iat a time and uses
a genetic algorithm to generate test suites for it.
576
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:17 UTC from IEEE Xplore.  Restrictions apply. We brieï¬‚y describe how E VOSUITE works. E VOSUITE
leverages genetic algorithm for generating a JUnit test suite
for a given Java class. The steps in E VOSUITE involve:
Initialization. An initial population of individuals is randomly
generated [30]. In E VOSUITE , an individual is a whole test
suite consists of tests that execute methods in the program
and test oracles.
Fitness. The ï¬tness is computed according to the given ï¬tness
function, a quantitative measurement of an individualâ€™s overall
effectiveness [31]. Currently, E VOSUITE supports different
coverage criteria (e.g., statement coverage, branch coverage,
or mutation coverage), where the default criterion is branch
coverage over the Java bytecode.
Crossover. EVOSUITE performs crossover between two test
suites by exchanging test cases based on a randomly chosen
crossover position.
Mutation. Mutation of test suites in E VOSUITE involves
adding new test cases, or mutating individual test. Meanwhile,
tests are mutated by inserting, removing, or modifying indi-
vidual statements and parameters. To enhance the generation
of input data, E VOSUITE also leverages focused local searches
and dynamic symbolic execution after every predeï¬ned num-
ber of generations.
Iteration and Termination. The new population is evaluated
and evolved until a stopping criterion is reached [32].
Our modiï¬cations of E VOSUITE aim to guide the search
towards the identiï¬ed risky method. Speciï¬cally, our goal is
to maximize the possibility of covering the identiï¬ed risky
method. In general, the more branches on the control ï¬‚ow
paths from the entry method to the risky method, the more dif-
ï¬cult to generate appropriate input data to trigger the crashes.
Hence, to ease the generation of input data, our modiï¬ed
ï¬tness function estimates how close a test suite is to covering
the identiï¬ed risky method. For each method fkâˆˆVfin
IMCFG, we calculate the number of branches passed through
by the paths from fkto risky method rfmâˆˆR i, which is
denoted by BN(fi). In this work, the ï¬tness of individual tsi
is the minimum of BN tsi={BN(fi)|fiâˆˆCVtsi}, where
CVtsirepresents the method set covered by test suite tsi. The
individuals with lower ï¬tness value tend to be selected during
the evolution process. Consequently, an individual has ï¬tness
0 if it covers the identiï¬ed risky method.
RIDDLE calculates the ï¬tness of test suite tsiin the follow-
ing four steps:
First, it identiï¬es method set CVtsicovered by tsi.
Second, it initializes BN tsk={BN(fk)|fkâˆˆCVtsi}to
record the number of branches passed through by invocation
paths from each method in CVtsito risky method rfnâˆˆR i.
Third, it let BN(rfn)=0 , where rfnâˆˆR i. Then, it
removes the methods directly or indirectly invoked by risky
method rfnfrom IMCFG.
Fourth, R IDDLE traverses the methods in CVtsiin a bottom-
up manner based on invocation relationships. For each fkâˆˆ
CVtsi, it performs the following tasks:
(1) If fkis a leaf node in the call graph, it let BN(fk)=âˆ
since the leaf node could not reach the target branch.(2) If fkis a non-leaf node in the call graph, it checks
whether fkis a branch node. There are two cases in this
scenario: (a) If fkis a branch node, we assign BN(fk)
to be the sum of MinChd (fk)and NBranch (fk)âˆ’1,
where NBranch (fk)denotes the number of conditional
or polymorphic branches starting from method fkin IM-
CFG, MinChd (fk)represents the minimum of BN chld =
{BN(ft)|ftâˆˆDV fk}, and DV fkis the set of methods directly
invoked by fkin the call graph. (b) If fkis neither a leaf node
in the call graph nor a branch node, we assign MinChd (fk)
toBN(fk).
Finally, the ï¬tness of test suite tsiis equal to the minimum
ofBN tsi={BN(ft)|ftâˆˆCVtsi}.
main()
A() B() E()
ClassD.F() ClassC.F() G() C()
D()CondiÆŸonal branch
Polymorphic branchBN(main)=2
BN(E)=2 BN(A)=2 BN(B)=1
BN(E)=1BN(F)=Äº
BN(C)=Äº
BN(E)=0BN(F)=1Test suite ts1 covers {main(), 
A(), ClassD.F(), B(), G(), C()}.
Fitness = min{2,2, Äº,1,1,Äº} = 1
Test suite ts2 covers {main(), 
A(), ClassD.F(), E(), C()}.
Fitness = min{2,2, Äº,2,Äº} = 2
Test suite ts3 covers {main(), 
A(), ClassD.F(), B(), G(), D()}
Fitness = min{2,2, Äº,1,1,0} = 0
Fig. 8: An illustrative example to explain the ï¬tness of an individual
Figure 8 illustrates how to calculate the ï¬tness of an
individual using the sample code shown in Figure 5. Based
on invocation relationships, we traverse the methods from the
bottom-up and deduce the number of branches from each
method to risky method D(). As the leaf nodes ClassD.F()
and C()are not reachable to D(),w eh a v e BN(ClassD.F )=
BN(C)=âˆ. There are two conditional branches starting
from G(),s oNBranch (G)is equal to 2. Then, BN(G)=
min(BN(D),BN (C)) + (2âˆ’1) = 1 . Similarly, we can
obtain BN(fk)for each method fkas shown in Figure 8.
Consider a test suite ts1that covers CVts1={main() ,A(),
ClassD.F() ,B(),G()and C()}. Its ï¬tness is equal to min{2,
2,âˆ,1 ,1 ,âˆ} = 1. By contrast, test suite ts2covers method
E() which needs to span more conditional branches to trigger
D(). In terms of possibility of triggering the risky method,
test suite ts1is preferable to ts2, resulting in a higher ï¬tness
value. Moreover, test ts3has ï¬tness 0, as it successfully covers
risky method D().
D. Condition Mutation and Restoration
Condition mutation. Lt=<e f m,Â·Â·Â·,r f n>is an invocation
path from an entry method efmdeï¬ned in boundary class
BC kâˆˆCL ito risky method rfnâˆˆR i. Suppose that Ltpasses
through a set of conditional branches whose corresponding
condition statement set is CDt={Tpq|<f p,fq>âˆˆEf}.
To guide test tkto execute along invocation path Lt,RIDDLE
mutates the program Pby forcing all the branch conditions
inCDtto be evaluated to be TRUE orFALSE , thereby we
get a program variant P/prime(Lt). For each risky method rfnâˆˆ
Ri, there is an invocation path set Ln={L1,L2,Â·Â·Â·,L|Ln|}
that is possible to trigger its execution. R IDDLE generates a
program variant set P={P/prime(Lk)|LkâˆˆL n}and then adopts
a genetic algorithm to generate tests for each P/prime(Lk).
577
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:17 UTC from IEEE Xplore.  Restrictions apply. Short-circuiting the branch conditions provides two beneï¬ts:
(1) It maximizes the probability of generating a stack trace
(i.e., runtime information) leading to a DC issue. It signif-
icantly increases the chances of collecting runtime informa-
tion required to reach the target branches that often involve
environment dependencies and non-linear constraints, which
are known to be difï¬cult to solve [16]. (2) It identiï¬es the
key constraints to be solved in order to reach a potential
DC issue, when a target branch cannot be reached based on
short-circuiting. As mentioned earlier in Section II-C, short-
circuiting may introduce some infeasible behaviors. Therefore,
RIDDLE tries to restore the mutated branch conditions to
compensate these side effects.
Condition restoration. If the generated test trigger the risky
method rfnunder program variant P/prime(Lt),RIDDLE generates
a program variant P/prime/prime(Lt)by restoring one mutated condition
statement that is nearest to entry method efmin IMCFG. Fur-
thermore, we check whether the search strategy can generate
tests to cover the risky method rfnin this case. If the tests
work, we retain the restored branch condition, otherwise, this
branch condition still should be short-circuited. By analogy,
RIDDLE restores the branch conditions from the top bottom
in IMCFG, and generate tests for their corresponding program
variants. Then, we prioritize the test cases that cover the risky
method in ascending order based on the number of unrestored
branch conditions in program variants. Intuitively, the test
that covers risky method with the fewest unrestored branch
conditions, is considered as the optimal test.
In summary, R IDDLE handles the condition mutation and
restoration process in the following steps:
First, it initializes the test suite Tnand program variant set
Pto empty.
Second, it identiï¬es invocation path set Lnfrom efmto
rfn. For each path LtâˆˆL n, we perform the following tasks:
(1) It identiï¬es the conditional branch set CDtpassed
through by path Lt.
(2) It generates program variant P/prime(Lt)by short-circuiting
the branch conditions in CDt.
(3) With the aid of search strategy, it generates test suite
Ttfor program variant P/prime(Lt).I fâˆƒtkâˆˆT tcan trigger risky
method rfn, then it let Tnâ†T n/uniontexttk.
(4) Then it ranks the conditional branches in CDtaccording
to their invocation distances to entry method efmin ascending
order and obtains sequence QB.
(5) For each TijâˆˆQB,R IDDLE restores its branch
condition and generate program variant P/prime(CDt\Tij). Then,
it generates test suite T/prime
tforP/prime(CDt\Tij).I fâˆƒtkâˆˆT/prime
t
can trigger risky method rfn,RIDDLE retains the restored
branch condition Tijand letTnâ†T n/uniontexttk,CDtâ†CD t\Tij
andPâ†P/uniontextP/prime(CDt). Otherwise, Tijstill should be short-
circuited.
After trying to restore the branch conditions in CD tdepth
by depth, R IDDLE ï¬nally obtains the test suite Tnand its
corresponding program variant set P.
Since E VOSUITE performs instrumentation on the bytecode
of the System Under Test (SUT), R IDDLE mutates branchTABLE I: Basic information of experimental subjects
ID Project Category Version KLOC # Stars
1 Azure storage [17] SDK 508ec1f 79.6 132
2 Google/truth [18] Testing 83a2d5d 35.3 1482
3 Ff4j [34] Framework 83a2d5d 35.3 1482
4 Incubator dubbo [35] Framework 1c16f78 111.1 20831
5 Jetbrick/template [36] Framework ae3896f 10.4 224
6 Webcam/capture [37] Driver a837030 16.6 1303
7 Blueï¬‚ood [38] Database 4722a34 42.8 564
8 Vertx/swagger [39] Web server 11437ef 9.1 62
9 Webmagic [37] Web application be892b8 12.1 6883
10 Apache Storm [40] Distributed system c2931da 267.4 5226
11 Htm.java [41] Platform 8fc6b59 54.7 255
12 Incubator service [42] SDK e1671b4 100.7 549
13 Selendroid [43] Framework 44118d6 35.5 703
14 HotelsDotCom/styx [44] Platform 6911de9 54.2 131
15 Wisdom [45] Framework a35b643 84.3 76
16 Geowave [46] Plugin 4de7e02 194.6 272
17 Mayocat shop [47] Platform ec84978 27.8 161
18 Vipshop/saturn [48] Platform c5ae22e 55.5 951
19 St-js [49] Plugin a97a611 34.2 149
condition statements with the aid of A SM[33], a Java byte-
code manipulation and analysis framework. It can be used
to modify existing classes directly in binary form. Restoring
some solvable conditions brings two beneï¬ts: (1) capture more
precise runtime information with more solved constraints and
(2) reduce infeasible behaviors caused by short-circuiting. For
the unrestored branch conditions, R IDDLE can provide their
detailed information to developers for further checking.
IV . E V ALUATION
We evaluate the effectiveness and usefulness of R IDDLE
using real-world open source projects with the aim to answer
the following two research questions:
â€¢RQ1 (Effectiveness): What is the overall effectiveness (in
terms of condition mutation and restoration)?
â€¢RQ2 (Usefulness): Can R IDDLE provide useful information
for developers to facilitate diagnosing and ï¬xing DC issues?
A. Experimental Design
To answer the two research questions, we conducted exper-
iments on 19 open source Java projects. These projects were
randomly selected from Github , satisfying two criteria. First,
it has received over 50 stars or forks (popularity). Second, it
contains DC issues with risky methods detected by D ECCA .
We further ensure that the subjects selected for evaluation are
different from those used in our empirical study in section
II-B, to avoid bias towards developers who prefer bug reports
with stack traces. Table I gives the basic information of these
projects, which includes: (1) project name, (2) category, (3)
the version used in our experiments, (4) lines of code, and (5)
number of stars. As we can see from the table, these projects
are diverse (covering 10 different categories), non-trivial (with
code size ranging from 9.1K âˆ¼267.4K lines of code), and
popular (with the number of stars ranging from 62 to 20,831).
The experiments were conducted on a dual-core machine with
Intel Core i7 CPU @2.8 GHz and 8GB RAM.
To study RQ1, after identifying the risky method using
DECCA , we applied the following three techniques to generate
tests for DC issues and then compared their effectiveness on
578
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:17 UTC from IEEE Xplore.  Restrictions apply. covering the risky methods. The detailed experimental settings
are described below:
â€¢EVOSUITE :It uses E VOSUITE â€™s default ï¬tness function
to guide the evolutionary search. Although E VOSUITE has
many coverage criteria that can be tuned for different tasks.
In this paper, we use its default branch coverage criteria,
as it has been shown effective in many prior studies [20],
[50]â€“[52].
â€¢EVOSUITE & Fitness: It uses the ï¬tness function deï¬ned
in Section III-C to guide the evolutionary search.
â€¢RIDDLE :It leverages search-based strategy with our deï¬ned
ï¬tness function, condition mutation and restoration strate-
gies to generate tests.
All of the above three techniques target at generating
test for the boundary class under test with the E VOSUITE â€™s
default options, except for two settings: 1) following earlier
works [16], we set the time budget for the search to three
minutes per boundary class, and 2) we conï¬gured E VOSUITE â€™s
parameter INSTRUMENT_CONTEXT to be TRUE , to allow the
three techniques to dive into the methods that are not deï¬ned in
the boundary class under test based on the invocation context.
In addition, due to the usage of randomized algorithms in
EVOSUITE , for the above three techniques, we repeated the
process of test generation for 10 times for each DC issue with
different random seeds. The ï¬nal results are averaged over the
10 runs in order to avoid the biased results.
To study RQ2, we conï¬gured R IDDLE to report: (1) con-
ï¬‚icting root causes arising from multiple versions of the
same libraries or classes in the project, (2) risky method set,
and (3) optimal test, which is the generated test with the
fewest unrestored branch conditions, and its corresponding
program variant. Then, we reported the above information
to developers using their corresponding bug tracking systems
and evaluated the usefulness of R IDDLE based on developersâ€™
feedback. Based on the reported information, developers can
reproduce the failure-introducing conditions and inputs to
facilitate issue diagnosis. Speciï¬cally, we listed the unrestored
branch conditions in the program variant and asked developers
to further check whether they could be triggered in reality.
For the tests with unrealistic branch condition mutations, we
labeled them as false positives. We only labeled the conï¬rmed
bug reports as true positives in our evaluation.
B. RQ1: Effectiveness of RIDDLE
Table II shows the effectiveness of R IDDLE in covering the
risky methods of 20 DC issues identiï¬ed from the above 19
subjects, where column â€œ Ndisâ€ represents the average invo-
cation path length from entry methods to the risky methods;
column â€œ Nbrâ€ represents the average number of conditional
branches on the invocation paths from entry methods to the
risky methods; columns â€œE VOSUITE â€, â€œE VOSUITE & Fitnessâ€
and â€œR IDDLE â€ represent the number of tests generated by the
above three techniques, which can trigger the risky methods;
Nlgrepresents the number of program variants with infeasible
behaviors introduced by short-circuiting which can be solved
by condition restoration operations.TABLE II: Effectiveness of R IDDLE in covering risky methods of
20 DC issues identiï¬ed from 19 subjects (averaged over 10 runs)
ID Project NdisNbrEvosuiteEvosuite&
FitnessRIDDLE Nlg
1 Azure storage 19.4 16.3 0 0 72.4 5.5
2 Google/truth 15.3 13.9 0 0 15.2 2.2
3Ff4j6.1 7.5 0 2.5 10.3 0.0
4 18.2 14.2 0 0 13.7 1.0
5 Incubator dubbo 23.6 15.7 0 0 12.5 3.5
6 Jetbrick/template 14.1 11.3 0 0 15.4 4.3
7 Webcam/capture 15.5 12.8 0 0 1.0 0
8 Blueï¬‚ood 17.4 14.7 0 0 1.0 0
9 Vertx/swagger 19.2 10.2 0 0 20.0 0
10 Webmagic 26.9 13.5 0 0 8.5 3.0
11 Apache Storm 13.9 9.7 0 6.5 17.0 1.0
12 Htm.java 12.2 8.2 0 0 19.3 0
13Incubator servicecomb 16.5 11.5 0 0 16.5 5.0
14 Selendroid 17.3 13.9 0 0 14.3 1.0
15 HotelsDotCom/styx 14.1 10.2 0 0 2.4 0
16 Wisdom 13.7 7.3 0 0 12.4 0
17 Geowave 17.3 8.4 0 0 13.2 0
18 Mayocat shop 16.2 10.2 0 0 18.4 3.5
19 Vipshop/saturn 15.5 10.5 0 0 4.5 0
20 St-js 12.5 16.4 0 0 5.5 1.0
As shown in Table II, the Ndisof the above subjects varies
from 6.12 to 26.90, and Nbrvaries from 7.34 to 16.34. These
two values indicate the challenges of triggering the risky
methods. Despite these challenges, R IDDLE can successfully
generate tests reaching the target branches for DC issues in all
the subjects. However, E VOSUITE could not cover the risky
methods because its branch coverage criteria fail to guide the
search to explore the methods that lead to the risky ones. In
contrast, E VOSUITE & Fitness outperforms E VOSUITE for the
Ff4j and Apache Storm projects, which have shorter invo-
cation paths (smaller Ndis) with fewer complex conditional
branches (smaller Nbr). Using the ï¬tness function deï¬ned in
our approach, E VOSUITE & Fitness avoids exploring some
complex conditional branches. Compared with R IDDLE , it still
fails to reach the branches guarded by unsolvable conditions
without short-circuiting these conditions.
RIDDLE indeed provides an effective strategy to collect
runtime information for DC issues, by forcing the generated
tests to reach the target branches. However, the challenges
inhibiting test generation tools from achieving high code
coverage, (e.g., creation of complex objects), may appear in
non-branch condition statements. In these cases, the tests are
unlikely generated by R IDDLE , if they cannot be avoided by
condition mutation or the guidance of ï¬tness function during
evolution process. Taking a DC issue in project Htm.java
as an example, there are 63 invocation paths from boundary
classes to risky methods. Among them, 43 have to pass
through the statements shown in Figure 9, which require
a browserâ€™s local installation path. Nevertheless, such envi-
ronment dependencies and complex object are difï¬cult to
construct automatically. Consequently, on average, R IDDLE
only generates 19.3 tests triggering the crashes, over 10 runs.
In some cases, short-circuiting branch conditions can cause
infeasible behaviors. As shown in Table II, after condition mu-
tation, such side effects are introduced in ï¬ve program variants
of project Azure storage . For instance, if R IDDLE short-
579
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:17 UTC from IEEE Xplore.  Restrictions apply. 1. File connectFile  = prepareConnectFile(server.getUrl());
2. BrowserInstallation installation  = browserLocator.findBrowserLocationOrFail();
3. commandLine = new CommandLine(installation.launcherFilePath(), 
                     connectFile.getAbsolutePath());
4. commandLine.executeAsync(); ...
Fig. 9: Code snippet in project Htm.java
1. int bodyPos = 0;
2. Buffer wireBuffer  = null;
...
3. void decodeFromWire( int bodyPos, Buffer wireBuffer){
4. if(wireBuffer !=null && bodyPos!=0){
5. int length = wireBuffer .getInt( bodyPos);
6. }
7.}   ...
Fig. 10: Code snippet in project Azure storage
circuits the branch condition in Line 4 of the code snippet
shown in Figure 10, we trigger a NullPointerException
when executing the statement in Line 5 , in the case that
variable wireBuffer is a null-initialized object variable. To
address this problem, R IDDLE restores the branch condition
inLine 4 , and then reaches the target branch ( Line 5 )
by passing a non-null object of type Buffer to method
decodeFromWire .
C. RQ2: Usefulness of RIDDLE
Table III presents the results of DC issues reported by
RIDDLE , where column â€œ |Ri|â€ represents the number of risky
methods in each reported DC issue; column â€œ |CL i|â€ represents
the number of boundary classes that can reach to risky meth-
ods; column â€œ Nur/Ntotalâ€ represents the ratio of unrestored
branch conditions to the total number of branches on the
invocation path covered by reported tests. By communicating
with developers, we collected developersâ€™ feedback on the
reported DC issues and summarized them into two ï¬ndings
as follows.
First, among the 20 reported issues, 15 (75%) were con-
ï¬rmed by developers as real issues within a few days, thereby
we labeled them as true positives. Ten out of the 15 conï¬rmed
issues (67%) were quickly ï¬xed, and ï¬ve out of the 15
conï¬rmed issues (33%) were in the process of being ï¬xed.
TABLE III: Results of 20 DC issues reported by R IDDLE
ID Project Issue ID |Ri||CL i|Nur/N total
1 Azure storage Issue #345 [53] â™¦ 2 4 1/13
2 Google/truth Issue #473 [54] â™¦ 1 3 2/11
3Ff4jIssue #309 [14] â™¦ 1 3 0/5
4 Issue #315 [55] â™¦ 3 5 2/12
5 Incubator dubbo Issue #2134 [56] â™¦ 3 6 3/13
6 Jetbrick/template Issue #39 [57] â™¦ 2 3 2/9
7 Webcam/capture Issue #653 [58] â™  3 6 4/10
8 Blueï¬‚ood Issue #829 [59] 2 5 4/12
9 Vertx/swagger Issue #102 [60] 1 2 2/9
10 Webmagic Issue #816 [61] 3 4 3/15
11 Apache Storm STORM-3171 [62] â™¦ 2 3 0/8
12 Htm.java Issue #540 [63] â™  1 2 2/10
13 Incubator service Issue #858 [64] â™£ 2 3 2/8
14 Selendroid Issue #1169 [65] 1 2 2/11
15 HotelsDotCom/styx Issue #227 [66] â™¦ 1 3 2/9
16 Wisdom Issue #573 [67] â™  1 2 1/6
17 Geowave Issue #1371 [68] â™  2 3 2/7
18 Mayocat shop Issue #272 [69] â™¦ 2 2 3/9
19 Vipshop/saturn Issue #477 [70] â™¦ 1 2 3/11
20 St-js Issue #146 [71] â™  2 3 2/10
â™¦: The issues have already been ï¬xed.
â™ : The issues were conï¬rmed and in the process of being ï¬xed.
â™£: False positive results.Moreover, among the ï¬ve unconï¬rmed issues, only one was
labeled as false positive and the others are not conï¬rmed
mainly due to the inactive maintenance of the corresponding
release versions. For the ten ï¬xed DC issues, developers
agreed that the shadowed methods indeed can cause runtime
exceptions with the reported stack traces, so we receive quick
feedback from these developers. Encouragingly, in Issue
#227 [66], one developer complimented on the usefulness of
our issue reports:
â€œThanks for the bug report! The provided stack trace was
very helpful for us to further investigate this bug. I have
opened a PR for this. Please feel free to have a look. â€
We also got a positive feedback, in Issue #345 [53]:
â€œThe stack trace is useful information because this is how
we can decide the feasibility of reproducing the DC issue. â€
Meanwhile, for Issue #858 [64], developers acknowl-
edged the risks associated with the dependency conï¬‚icts
reported by R IDDLE . However, they mark the bug report as
a false positive after checking the mutated branch conditions.
The developers noted that the runtime exceptions might never
happen because the statements in this branch are dead code
and the condition is not satisï¬able in reality.
Second, developers agreed with the condition mutation
strategy for triggering the possible crashes caused by DC
issues. In particular, one experienced developer [72] from
Microsoft responded in Issue #345 [53] that:
â€œAlthough the way you arrived at the parse error is
artiï¬cial, I believe that a similar parse error in the code
is achievable in actual us age, pr esumably leading to the
runtime exceptions due to dependency conï¬‚icts (if indeed such
a conï¬‚ict exists in the application code). The tests did bring
to our attention to update the conï¬‚icting library to the latest
version, so I would not call it a false positive. â€
The high conï¬rmation rate of the reported DC issues
indicates that developers accepted the reported runtime infor-
mation with some unrestored conditions and were likely able
to use their domain knowledge to ï¬gure out them.
Moreover, the low values for the column â€œ Nur/Ntotalâ€i n
Table III indicates that in our reported issues, most of the
branch conditions on execution traces can be restored by R ID-
DLE, which are very close to the actual runtime information.
Finally, developers have expressed great interest in includ-
ing R IDDLE as part of their projects. For instance, we received
a feedback in Issue #473 [54]:
â€œIf you have a test generation tool that can run continually
on Truth and other Google projects, or if you have other
information to share, Iâ€™d be happy to hear about it. â€
In addition, after resolving Issue #540 [63], we accepted
an inspiring invitation from the developers of Htm.java to
continuously maintain the dependencies of third party libraries
in their project, with the aid of R IDDLE .
V. T HREATS TOVALIDITY
Validity of bug reports. We rely on developersâ€™ feedback
to validate our submitted bug reports. In general, there may
be disagreement between the developers on the validity of the
580
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:17 UTC from IEEE Xplore.  Restrictions apply. bug reports. However, we did not encounter such disagreement
for all the evaluated subjects. Therefore, we believe that the
positive feedback that we received are strong indications of
the usefulness of our approach.
Condition restoration strategy. After short-circuiting branch
conditions, R IDDLE restores them step by step in MLCFG
following a top-down strategy. In our evaluation, the effective-
ness of the proposed condition restoration strategy has been
conï¬rmed by developers. However, the proposed restoration
strategy may generate invalid tests if path conditions interact
with each other.
Limitation for detecting diverse types of DC issues. The
proposed test generation technique focuses on crash-related
DC issues due to the reference of shadowed features or classes.
However, in some cases, conï¬‚icts could be caused by the
changes in semantics, performance or other attributes of the
duplicated libraries presented on a projectâ€™s classpath. R IDDLE
does not analyze the above manifestations of DC issues, and
may miss some DC issues.
VI. R ELATED WORK
Dependency Conï¬‚ict. Patra et al. [73] studied the library
conï¬‚icts problem speciï¬cally for JavaScript language, and
proposed a tool, C ONFLICT JS, to automatically detect con-
ï¬‚icts. Wang et al. [7] conducted the ï¬rst empirical study to
investigate the manifestation and the ï¬xing patterns of DC
issues in Java projects. Based on their ï¬ndings, they proposed
a tool, D ECCA , to assess severity of potential DC issues using
static analysis. R IDDLE differs from D ECCA in several aspects:
(1) D ECCA detects the existence of DC issues using static
analysis, while R IDDLE leverages D ECCA to identify risky
methods causing DC issues, and combines dynamic analysis
(i.e., automatic test generation), condition mutation, search
strategies and condition restoration to obtain stack traces
reaching these methods; and (2) D ECCA only categorizes the
severity levels of DC issues, while R IDDLE provides stack
trace information and the failure-introducing conditions to help
developers reproduce and debug DC issues. So, R IDDLE and
DECCA complement each other.
Stack trace analysis and fault localization. Prior studies
provided empirical evidence that stack traces are useful for
developers to ï¬x bugs [9], [10], [15], [21], [22], [26], [74], [75]
Meanwhile, Coelho et al. [76] conducted a detailed empirical
study of 6,000 Java exception stack traces and explored the
common causes for system crashes. Inspired by these studies,
RIDDLE generates stack traces to explain DC issues. The
positive feedback from developers, who get the stack trace
information in our evaluation, further conï¬rm the ï¬ndings of
prior studies. The concept of predicate switching (i.e., ï¬‚ipping
branches outcome during execution for locating faults) [77]
is similar to the condition mutations in R IDDLE . Moreover,
predicate switching leverages dynamic instrumentation for
controlling the program execution, while R IDDLE mutates
branch conditions and generate tests based on the mutated
program variants.Automated Test Generation. Many test generation techniques
have been proposed to detect software bugs [78]â€“[104]. Zhang
et al. [29] implemented an isomorphic regression testing ap-
proach named I SON, which forced the existing tests to execute
the originally uncovered code by modifying the isomorphic
code of two program versions. The behaviors (i.e., test outputs)
of the modiï¬ed programs were then compared to check if
abnormal behaviors were induced in the new version. Soltani et
al. [105] presented E VOCRASH , a post-failure approach which
used data from crash stack traces as input and combined with
a guided genetic algorithm to search for a test case that could
trigger the target crash. Different from prior work, R IDDLE
is the ï¬rst approach that generate tests with buggy frame in
the stack traces to examine DC issues without known crash
information. It short-circuits the branch conditions to trigger
the risky methods caused by DC issues and then addresses the
side effects by condition restoration.
VII. C ONCLUSION AND FUTURE WORK
In this paper, we developed R IDDLE , the ï¬rst automatic
approach that generates tests and collects crashing stack traces
for the projects with DC issues. To overcome the complex
branch conditions, R IDDLE combines condition mutation and
search strategies to generate tests reaching the risky methods
that cause DC issues. Furthermore, it restores solvable branch
conditions to capture more precise runtime information. We
applied R IDDLE on real-world projects. Positive feedback
were obtained from project developers on R IDDLE â€™s results.
Most of the submitted bug reports were conï¬rmed by devel-
opers with a majority of them readily ï¬xed. Also, developers
showed great interests in R IDDLE , and acknowledged that
stack traces are very helpful for their debugging tasks. These
feedback from developers demonstrate the practical usefulness
of R IDDLE .
An alternative mutation strategy is to perform selective
mutation of branch conditions that cannot be solved by
EVOSUITE to reduce the cost of condition restoration. As
identifying the unsolvable branch conditions reaching to target
branches may incur more overhead, we choose to mutate all
branch conditions to drive the program executions towards the
target branches in one step. We leave the investigation of the
efï¬ciency of this alternative as future work.
ACKNOWLEDGMENT
The authors express thanks to the anonymous reviewers for
their constructive comments. Part of the work was conducted
during the ï¬rst authorâ€™s internship at HKUST in 2018. The
work is supported by the National Natural Science Foundation
of China (Grant Nos. 61374178, 61603082 and 61402092),
the Fundamental Research Funds for the Central Universities
(Grant No. N171704004), the Hong Kong RGC/GRF grant
16202917, MSRA grant, and the Science and Technology
Innovation Committee Foundation of Shenzhen (Grant No.
JCYJ20170817110848086). Dr. Rongxin Wu is the ï¬rst cor-
responding author of this paper.
581
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:17 UTC from IEEE Xplore.  Restrictions apply. REFERENCES
[1] M. Backes, S. Bugiel, and E. Derr, â€œReliable third-party library
detection in android and its security applications,â€ in Proceedings of
the 2016 ACM SIGSAC Conference on Computer and Communications
Security . ACM, 2016, pp. 356â€“367.
[2] G. Bavota, G. Canfora, M. Di Penta, R. Oliveto, and S. Panichella,
â€œHow the apache community upgrades dependencies: an evolutionary
study,â€ Empirical Software Engineering , vol. 20, no. 5, pp. 1275â€“1317,
2015.
[3] W. Ming, L. Yepang, W. Rongxin, X. Xuan, C. Shing-Chi, and
S. Zhendong, â€œExposing Library API Misuses via Mutation Analysis,â€
inProceedings of the 41th International Conference on Software
Engineering , ser. ICSE 2019, 2019.
[4] J. Gosling, B. Joy, and G. Steele, The Java language speciï¬cation .
Addison-Wesley Professional, 2000.
[5] M. Coblenz, W. Nelson, J. Aldrich, B. Myers, and J. Sunshine,
â€œGlacier: transitive class immutability for java,â€ in Software Engineer-
ing (ICSE), 2017 IEEE/ACM 39th International Conference on . IEEE,
2017, pp. 496â€“506.
[6] S. Liang and G. Bracha, â€œDynamic class loading in the java virtual
machine,â€ Acm sigplan notices , vol. 33, no. 10, pp. 36â€“44, 1998.
[7] Y . Wang, M. Wen, Z. Liu, R. Wu, R. Wang, B. Yang, H. Yu, Z. Zhu,
and S.-C. Cheung, â€œDo the dependency conï¬‚icts in my project matter?â€
inProceedings of the 2018 26th ACM Joint European Software Engi-
neering Conference and Symposium on the F oundations of Software
Engineering (ESEC/FSE 2018) . ACM, 2018, pp. 1â€“12.
[8] â€œMaven,â€ http://maven .apache .org/, 2018, accessed: 2018-08-18.
[9] R. Wu, M. Wen, S.-C. Cheung, and H. Zhang, â€œChangelocator: locate
crash-inducing changes based on crash reports,â€ Empirical Software
Engineering , vol. 23, no. 5, pp. 2866â€“2900, 2018.
[10] R. Wu, H. Zhang, S.-C. Cheung, and S. Kim, â€œCrashlocator: locating
crashing faults based on crash stacks,â€ in Proceedings of the 2014
International Symposium on Software Testing and Analysis . ACM,
2014, pp. 204â€“214.
[11] â€œIssue #57,â€ https://github .com/FasterXML/jackson-module-jaxb-
annotations/issues/57, 2018, accessed: 2018-08-18.
[12] â€œIssue #8706,â€ https://github .com/spring-projects/spring-boot/issues/
8706, 2018, accessed: 2018-08-18.
[13] â€œIssue #501,â€ https://github .com/apollographql/apollo-android/issues/
501, 2018, accessed: 2018-08-18.
[14] â€œIssue #309,â€ https://github .com/ff4j/ff4j/issues/309, 2018, accessed:
2018-08-18.
[15] A. Schroter, A. SchrÃ¶ter, N. Bettenburg, and R. Premraj, â€œDo stack
traces help developers ï¬x bugs?â€ in Mining Software Repositories
(MSR), 2010 7th IEEE Working Conference on . IEEE, 2010, pp.
118â€“121.
[16] S. Shamshiri, R. Just, J. M. Rojas, G. Fraser, P. McMinn, and A. Arcuri,
â€œDo automatically generated unit tests ï¬nd real faults? an empirical
study of effectiveness and challenges (t),â€ in 2015 30th IEEE/ACM
International Conference on Automated Software Engineering (ASE) .
IEEE, 2015, pp. 201â€“211.
[17] â€œAzure storage,â€ https://docs .microsoft .com/en-us/java/api/overview/
azure/storage?view=azure-java-stable, 2018, accessed: 2018-08-18.
[18] â€œGoogle/truth,â€ http://google .github .io/truth/, 2018, accessed: 2018-08-
18.
[19] â€œWebmagic,â€ http://webmagic .io/, 2018, accessed: 2018-08-18.
[20] G. Fraser and A. Arcuri, â€œEvosuite: automatic test suite generation for
object-oriented software,â€ in Proceedings of the 19th ACM SIGSOFT
symposium and the 13th European conference on F oundations of
software engineering . ACM, 2011, pp. 416â€“419.
[21] N. Bettenburg, S. Just, A. SchrÃ¶ter, C. Weiss, R. Premraj, and T. Zim-
mermann, â€œWhat makes a good bug report?â€ in Proceedings of the 16th
ACM SIGSOFT International Symposium on F oundations of software
engineering . ACM, 2008, pp. 308â€“318.
[22] T. Zimmermann, R. Premraj, N. Bettenburg, S. Just, A. Schroter, and
C. Weiss, â€œWhat makes a good bug report?â€ IEEE Transactions on
Software Engineering , vol. 36, no. 5, pp. 618â€“643, 2010.
[23] S. Rastkar, G. C. Murphy, and G. Murray, â€œSummarizing software
artifacts: a case study of bug reports,â€ in Software Engineering, 2010
ACM/IEEE 32nd International Conference on , vol. 1. IEEE, 2010,
pp. 505â€“514.
[24] M. BÃ¶hme, E. O. Soremekun, S. Chattopadhyay, E. Ugherughe, and
A. Zeller, â€œWhere is the bug and how is it ï¬xed? an experimentwith practitioners,â€ in Proceedings of the 2017 11th Joint Meeting on
F oundations of Software Engineering . ACM, 2017, pp. 117â€“128.
[25] L. Layman, M. Diep, M. Nagappan, J. Singer, R. Deline, and G. Veno-
lia, â€œDebugging revisited: Toward understanding the debugging needs
of contemporary software developers,â€ in Empirical Software Engineer-
ing and Measurement, 2013 ACM/IEEE International Symposium on .
IEEE, 2013, pp. 383â€“392.
[26] C.-P. Wong, Y . Xiong, H. Zhang, D. Hao, L. Zhang, and H. Mei,
â€œBoosting bug-report-oriented fault localization with segmentation and
stack-trace analysis,â€ in 2014 IEEE International Conference on Soft-
ware Maintenance and Evolution (ICSME) . IEEE, 2014, pp. 181â€“190.
[27] P. Lam, E. Bodden, O. LhotÃ¡k, and L. Hendren, â€œThe Soot
framework for Java program analysis: a retrospective,â€ in Cetus Users
and Compiler Infrastructure Workshop (CETUS 2011) , Oct. 2011.
[Online]. Available: http://www .bodden .de/pubs/lblh11soot .pdf
[28] T. Xie, D. Marinov, W. Schulte, and D. Notkin, â€œSymstra: A framework
for generating object-oriented unit tests using symbolic execution,â€ in
International Conference on Tools and Algorithms for the Construction
and Analysis of Systems . Springer, 2005, pp. 365â€“381.
[29] J. Zhang, Y . Lou, L. Zhang, D. Hao, L. Zhang, and H. Mei, â€œIsomorphic
regression testing: executing uncovered branches without test augmen-
tation,â€ in Proceedings of the 2016 24th ACM SIGSOFT International
Symposium on F oundations of Software Engineering . ACM, 2016, pp.
883â€“894.
[30] B. Baudry, F. Fleurey, J.-M. JÃ©zÃ©quel, and Y . Le Traon, â€œFrom genetic
to bacteriological algorithms for mutation-based testing,â€ Software
Testing, V eriï¬cation and Reliability , vol. 15, no. 2, pp. 73â€“96, 2005.
[31] A. Aleti, I. Moser, and L. Grunske, â€œAnalysing the ï¬tness landscape
of search-based software testing problems,â€ Automated Software Engi-
neering , vol. 24, no. 3, pp. 603â€“621, 2017.
[32] M. Harman, R. Hierons, and M. Proctor, â€œA new representation and
crossover operator for search-based optimization of software modular-
ization,â€ in Proceedings of the 4th Annual Conference on Genetic and
Evolutionary Computation . Morgan Kaufmann Publishers Inc., 2002,
pp. 1351â€“1358.
[33] â€œAsm,â€ https://asm .ow2 .io/, 2018, accessed: 2018-08-18.
[34] â€œFf4j,â€ http://ff4j .org/, 2018, accessed: 2018-08-18.
[35] â€œIncubator dubbo,â€ http://dubbo .incubator .apache .org/en-us/, 2018, ac-
cessed: 2018-08-18.
[36] â€œJetbrick/template,â€ http://subchen .github .io/jetbrick-template/, 2018,
accessed: 2018-08-18.
[37] â€œWebcam/capture,â€ http://webcam-capture .sarxos .pl/, 2018, accessed:
2018-08-18.
[38] â€œBlueï¬‚ood,â€ http://www .blueï¬‚ood .io, 2018, accessed: 2018-08-18.
[39] â€œVertx/swagger,â€ https://vertx .io/blog/presentation-of-the-vert-x-
swagger-project/, 2018, accessed: 2018-08-18.
[40] â€œApache storm,â€ http://storm .apache .org/, 2018, accessed: 2018-08-18.
[41] â€œHtm.java,â€ https://numenta .org/, 2018, accessed: 2018-08-18.
[42] â€œIncubator service,â€ http://servicecomb .incubator .apache .org/, 2018,
accessed: 2018-08-18.
[43] â€œSelendroid,â€ http://selendroid .io, 2018, accessed: 2018-08-18.
[44] â€œHotelsdotcom/styx,â€ https://github .com/Netï¬‚ix/Hystrix/wiki, 2018,
accessed: 2018-08-18.
[45] â€œWisdom,â€ http://wisdom-framework .org, 2018, accessed: 2018-08-18.
[46] â€œGeowave,â€ http://locationtech .github .io/geowave/, 2018, accessed:
2018-08-18.
[47] â€œMayocat shop,â€ https://github .com/jvelo/mayocat-shop/, 2018, ac-
cessed: 2018-08-18.
[48] â€œVipshop/saturn,â€ https://vipshop .github .io/Saturn/#/, 2018, accessed:
2018-08-18.
[49] â€œSt-js,â€ http://st-js .org/, 2018, accessed: 2018-08-18.
[50] G. Fraser, J. M. Rojas, J. Campos, and A. Arcuri, â€œEvosuite at the
sbst 2017 tool competition,â€ in Ieee/acm International Workshop on
Search-Based Software Testing , 2017, pp. 39â€“42.
[51] G. Fraser and A. Arcuri, â€œWhole test suite generation,â€ IEEE Trans-
actions on Software Engineering , vol. 39, no. 2, pp. 276â€“291, 2013.
[52] A. Arcuri and G. Fraser, â€œOn parameter tuning in search based software
engineering,â€ in International Symposium on Search Based Software
Engineering . Springer, 2011, pp. 33â€“47.
[53] â€œIssue #345,â€ https://github .com/Azure/azure-storage-java/issues/345,
2018, accessed: 2018-08-18.
[54] â€œIssue #473,â€ https://github .com/google/truth/issues/473, 2018, ac-
cessed: 2018-08-18.
[55] â€œIssue #315,â€ https://github .com/ff4j/ff4j/issues/315, 2018, accessed:
2018-08-18.
582
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:17 UTC from IEEE Xplore.  Restrictions apply. [56] â€œIssue #2134,â€ https://github .com/apache/incubator-dubbo/issues/2134,
2018, accessed: 2018-08-18.
[57] â€œIssue #39,â€ https://github .com/subchen/jetbrick-template-2x/issues/
39, 2018, accessed: 2018-08-18.
[58] â€œIssue #653,â€ https://github .com/sarxos/webcam-capture/issues/653,
2018, accessed: 2018-08-18.
[59] â€œIssue #829,â€ https://github .com/rackerlabs/blueï¬‚ood/issues/829, 2018,
accessed: 2018-08-18.
[60] â€œIssue #102,â€ https://github .com/phiz71/vertx-swagger/issues/102,
2018, accessed: 2018-08-18.
[61] â€œIssue #816,â€ https://github .com/code4craft/webmagic/issues/816,
2018, accessed: 2018-08-18.
[62] â€œStorm-3171,â€ https://issues .apache .org/jira/browse/STORM-3171,
2018, accessed: 2018-08-18.
[63] â€œIssue #540,â€ https://github .com/numenta/htm .java/issues/540, 2018,
accessed: 2018-08-18.
[64] â€œIssue #858,â€ https://github .com/apache/incubator-servicecomb-java-
chassis/issues/858, 2018, accessed: 2018-08-18.
[65] â€œIssue #1169,â€ https://github .com/selendroid/selendroid/issues/1169,
2018, accessed: 2018-08-18.
[66] â€œIssue #227,â€ https://github .com/HotelsDotCom/styx/issues/227, 2018,
accessed: 2018-08-18.
[67] â€œIssue #573,â€ https://github .com/wisdom-framework/wisdom/issues/
573, 2018, accessed: 2018-08-18.
[68] â€œIssue #1371,â€ https://github .com/locationtech/geowave/issues/1371,
2018, accessed: 2018-08-18.
[69] â€œIssue #272,â€ https://github .com/jvelo/mayocat-shop/issues/272, 2018,
accessed: 2018-08-18.
[70] â€œIssue #477,â€ https://github .com/vipshop/Saturn/issues/477, 2018, ac-
cessed: 2018-08-18.
[71] â€œIssue #146,â€ https://github .com/st-js/st-js/issues/146, 2018, accessed:
2018-08-18.
[72] â€œMicrosoft developer,â€ https://github .com/mirobers, 2018, accessed:
2018-08-18.
[73] J. Patra, P. N. Dixit, and M. Pradel, â€œConï¬‚ictjs: ï¬nding and under-
standing conï¬‚icts between javascript libraries,â€ in Proceedings of the
40th International Conference on Software Engineering . ACM, 2018,
pp. 741â€“751.
[74] M. Wen, R. Wu, and S. Cheung, â€œLocus: Locating bugs from soft-
ware changes,â€ in Proceedings of the 31st IEEE/ACM International
Conference on Automated Software Engineering, ASE 2016 , 2016.
[75] S. H. Tan, Z. Dong, X. Gao, and A. Roychoudhury, â€œRepairing crashes
in android apps,â€ in Proceedings of the 40th International Conference
on Software Engineering , ser. ICSE 2018. IEEE, 2018, pp. 187â€“198.
[76] R. Coelho, L. Almeida, G. Gousios, A. Van Deursen, and C. Treude,
â€œException handling bug hazards in android,â€ Empirical Software
Engineering , vol. 22, no. 3, pp. 1264â€“1304, 2017.
[77] X. Zhang, N. Gupta, and R. Gupta, â€œLocating faults through automated
predicate switching,â€ in Proceedings of the 28th international confer-
ence on Software engineering . ACM, 2006, pp. 272â€“281.
[78] P. McMinn, â€œSearch-based software test data generation: a survey,â€
Software testing, V eriï¬cation and reliability , vol. 14, no. 2, pp. 105â€“
156, 2004.
[79] W. Visser, C. S. P Ë‡asË‡areanu, and S. Khurshid, â€œTest input generation
with java pathï¬nder,â€ ACM SIGSOFT Software Engineering Notes ,
vol. 29, no. 4, pp. 97â€“107, 2004.
[80] C. Pacheco and M. D. Ernst, â€œRandoop: feedback-directed random
testing for java,â€ in Companion to the 22nd ACM SIGPLAN conference
on Object-oriented programming systems and applications companion .
ACM, 2007, pp. 815â€“816.
[81] Y .-S. Ma, J. Offutt, and Y .-R. Kwon, â€œMujava: a mutation system for
java,â€ in Proceedings of the 28th international conference on Software
engineering . ACM, 2006, pp. 827â€“830.
[82] C. Csallner and Y . Smaragdakis, â€œJcrasher: an automatic robustness
tester for java,â€ Software: Practice and Experience , vol. 34, no. 11,
pp. 1025â€“1050, 2004.
[83] P. Godefroid, N. Klarlund, and K. Sen, â€œDart: directed automated
random testing,â€ in ACM Sigplan Notices , vol. 40, no. 6. ACM,
2005, pp. 213â€“223.
[84] C. Cadar, D. Dunbar, D. R. Engler et al. , â€œKlee: Unassisted and
automatic generation of high-coverage tests for complex systems
programs.â€ in OSDI , vol. 8, 2008, pp. 209â€“224.
[85] G. Perrouin, S. Sen, J. Klein, B. Baudry, and Y . Le Traon, â€œAutomatic
and scalable t-wise test case generation strategies for software productlines,â€ in International Conference on Software Testing . Springer
Lecture Notes in Computer Science (LNCS), 2010.
[86] M. Christakis and P. Godefroid, â€œIc-cut: A compositional search
strategy for dynamic test generation,â€ in Model Checking Software .
Springer, 2015, pp. 300â€“318.
[87] S. Artzi, A. Kiezun, J. Dolby, F. Tip, D. Dig, A. Paradkar, and M. D.
Ernst, â€œFinding bugs in web applications using dynamic test generation
and explicit-state model checking,â€ IEEE Transactions on Software
Engineering , vol. 36, no. 4, p. 474, 2010.
[88] E. P. Enoiu, D. Sundmark, A. Ë‡CauÅ¡evi Â´c, R. Feldt, and P. Pettersson,
â€œMutation-based test generation for plc embedded software using
model checking,â€ in IFIP International Conference on Testing Software
and Systems . Springer, 2016, pp. 155â€“171.
[89] M. Gligoric, T. Gvero, V . Jagannath, S. Khurshid, V . Kuncak, and
D. Marinov, â€œTest generation through programming in UDITA,â€ in
International Conference on Software Engineering , 2010, pp. 225â€“234.
[90] G. Denaro, A. Gorla, and M. Pezze, â€œDatec: Contextual data ï¬‚ow test-
ing of java classes,â€ in Software Engineering-Companion V olume, 2009.
ICSE-Companion 2009. 31st International Conference on . IEEE,
2009, pp. 421â€“422.
[91] S. HallÃ©, E. La Chance, and S. Gaboury, â€œGraph methods for gen-
erating test cases with universal and existential constraints,â€ in IFIP
International Conference on Testing Software and Systems . Springer,
2015, pp. 55â€“70.
[92] C. Boyapati, S. Khurshid, and D. Marinov, â€œKorat: Automated testing
based on java predicates,â€ in ACM SIGSOFT Software Engineering
Notes , vol. 27, no. 4. ACM, 2002, pp. 123â€“133.
[93] Y . Kim, S. Hong, B. Ko, D. L. Phan, and M. Kim, â€œInvasive software
testing: Mutating target programs to diversify test exploration for high
test coverage,â€ in Software Testing, V eriï¬cation and V alidation (ICST),
2018 IEEE 11th International Conference on . IEEE, 2018, pp. 239â€“
249.
[94] F. Zaraket, W. Masri, M. Adam, D. Hammoud, R. Hamzeh, R. Farhat,
E. Khamissi, and J. Noujaim, â€œGuicop: Speciï¬cation-based gui testing,â€
inSoftware Testing, V eriï¬cation and V alidation (ICST), 2012 IEEE
Fifth International Conference on . IEEE, 2012, pp. 747â€“751.
[95] A. Arcuri, â€œTest suite generation with the many independent objective
(mio) algorithm,â€ Information and Software Technology ,2018.
[96] S. Artzi, J. Dolby, F. Tip, and M. Pistoia, â€œDirected test generation for
effective fault localization,â€ in Proceedings of the 19th international
symposium on Software testing and analysis . ACM, 2010, pp. 49â€“60.
[97] M. Fazzini, M. Prammer, M. dâ€™Amorim, and A. Orso, â€œAutomatically
translating bug reports into test cases for mobile apps,â€ in Proceedings
of the 27th ACM SIGSOFT International Symposium on Software
Testing and Analysis . ACM, 2018, pp. 141â€“152.
[98] A. Bertolino, J. Gao, E. Marchetti, and A. Polini, â€œAutomatic test
data generation for xml schema-based partition testing,â€ in Proceedings
of the second international workshop on automation of software test .
IEEE Computer Society, 2007, p. 4.
[99] P. D. Marinescu and C. Cadar, â€œKatch: high-coverage testing of
software patches,â€ in Proceedings of the 2013 9th Joint Meeting on
F oundations of Software Engineering . ACM, 2013, pp. 235â€“245.
[100] D. Giannakopoulou, N. Rungta, and M. Feary, â€œAutomated test case
generation for an autopilot requirement prototype,â€ in Systems, Man,
and Cybernetics (SMC), 2011 IEEE International Conference on .
IEEE, 2011, pp. 1825â€“1830.
[101] M. Gligoric, T. Gvero, V . Jagannath, S. Khurshid, V . Kuncak, and
D. Marinov, â€œTest generation through programming in udita,â€ in Pro-
ceedings of the 32nd ACM/IEEE International Conference on Software
Engineering-V olume 1 . ACM, 2010, pp. 225â€“234.
[102] D. H. Bushnell, C. Pasareanu, and R. M. Mackey, â€œAutomatic testcase
generation for ï¬‚ight software,â€ 2008.
[103] J. Burnim, K. Sen, and C. Stergiou, â€œTesting concurrent programs on
relaxed memory models,â€ in Proceedings of the 2011 International
Symposium on Software Testing and Analysis . ACM, 2011, pp. 122â€“
132.
[104] S. Kundu, M. K. Ganai, and C. Wang, â€œContessa: Concurrency testing
augmented with symbolic analysis,â€ in International Conference on
Computer Aided V eriï¬cation . Springer, 2010, pp. 127â€“131.
[105] M. Soltani, A. Panichella, and A. van Deursen, â€œA guided genetic
algorithm for automated crash reproduction,â€ in Proceedings of the
39th International Conference on Software Engineering . IEEE Press,
2017, pp. 209â€“220.
583
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:17 UTC from IEEE Xplore.  Restrictions apply. 