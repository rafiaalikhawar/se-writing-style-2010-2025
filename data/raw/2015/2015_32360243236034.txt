Syntax-Guided Synthesis ofDatalogPrograms
Xujie Si
Universityof Pennsylvania, USA
xsi@cis.upenn.eduWoosuk Lee∗
Universityof Pennsylvania, USA
HanyangUniversitySouthKorea
woosuk@cis.upenn.eduRichard Zhang
Universityof Pennsylvania, USA
rmzhang@cis.upenn.edu
Aws Albarghouthi
Universityof Wisconsin-Madison
USA
aws@cs.wisc.eduParaschosKoutris
Universityof Wisconsin-Madison
USA
paris@cs.wisc.eduMayurNaik
Universityof Pennsylvania, USA
mhnaik@cis.upenn.edu
ABSTRACT
Datalog has witnessed promising applications in a variety of do-
mains. We propose a programming-by-example system, alps, to
synthesize Datalog programs from input-output examples. Scaling
synthesistorealisticprogramsinthismannerischallengingdue
to the rich expressivity of Datalog. We present a syntax-guided
synthesisapproachthatprunesthesearchspacebyexploitingthe
observation that in practice Datalog programs comprise rules that
have similar latent syntactic structure. We evaluate alpson a suite
of 34benchmarksfrom threedomainsÐknowledgediscovery,pro-
gram analysis, and database queries. The evaluation shows that
alpscan synthesize 33 of these benchmarks, and outperforms the
state-of-the-art tools Metagol and Zaatar, which can synthesize
only upto 10 ofthe benchmarks.
CCS CONCEPTS
·Theoryofcomputation →Programanalysis ;Activelearn-
ing;·Software and its engineering →Programming by ex-
ample;Domainspecificlanguages ;·Informationsystems →
Relational databasequery languages ;
KEYWORDS
Syntax-guidedsynthesis,Datalog,Activelearning,Templateaug-
mentation, Program analysis
ACMReference Format:
XujieSi,WoosukLee,RichardZhang,AwsAlbarghouthi,ParaschosKoutris,
andMayurNaik.2018.Syntax-GuidedSynthesisofDatalogPrograms.In
Proceedingsofthe26thACMJointEuropeanSoftwareEngineeringConference
andSymposiumontheFoundationsofSoftwareEngineering(ESEC/FSE’18),
November 4ś9, 2018,Lake BuenaVista,FL,USA. ACM, New York, NY,USA,
13pages.https://doi.org/10.1145/3236024.3236034
∗The firsttwoauthorscontributed equally to thiswork.
Permissionto make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,
topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ESEC/FSE ’18, November 4ś9, 2018, Lake BuenaVista,FL,USA
©2018 Associationfor Computing Machinery.
ACM ISBN 978-1-4503-5573-5/18/11...$15.00
https://doi.org/10.1145/3236024.32360341 INTRODUCTION
Datalog, a declarative logic programming language, has witnessed
promising applications in a variety of domains, including bioin-
formatics [ 33,58], big-dataanalytics [ 30,60,63], naturallanguage
processing [ 44], networking [ 39], program analysis [ 17,26], and
robotics [ 56]. A key reason is the emergence of scalable Datalog
solvers, including open-source [ 1,3,11,59,60] and commercial
ones[2,4,6,25].Moreover,theconciseanddeclarativenatureof
Dataloghasmadeitthetargetofagrowingbodyofmeta-reasoning
tools.Forinstance,programanalyseswritteninDatalogarereadily
extensible with features such as fixed point frameworks [ 14,40],
abstraction refinement [ 74], and user interaction [ 41,57,73]. Like-
wise,software-definednetworking(SDN)applicationswrittenin
Datalog canavail ofefficient provenancetracking tohelp intasks
such as debuggingandrepairing [ 71].
A key hindrance to bringing these benefits to a broad user base
is the lack of automated tools to help develop Datalog programs.
Tothisend,weproposeaprogramming-by-examplesystem, alps,
to synthesize Datalog programs from input-output examples. This
constitutesanaturalnextstepinmanydomainssuchasprogram
analysis and networking, where reference imperative implementa-
tionscan provideinput-output examples.
Whileostensiblysimple,synthesizingsuchprogramsischalleng-
ing because Datalog is powerful enough to capture all polynomial
time computations. Learning logic programs from examples has
beenextensivelystudiedinasubfieldofmachinelearningcalled
inductive logic programming (ilp) [45,49]. However, even state-
of-the-art ilptechniquesareverylimitedintheirabilitytolearn
realistic Datalogprograms [ 9,50].
We propose a new approach to synthesize Datalog programs.
Our key insight is that such programs in practice comprise rules
that have similar latentsyntactic structure. Our approach exploits
this insight via the syntax-guided program synthesis paradigm [ 10],
whereinthesyntacticstructureofthetargetclassofprogramsis
leveraged toefficiently traverse thehypothesisspace ofprograms.
For this purpose, our approach must address three key challenges:
(i) capture syntactic structure effectively, ( ii) minimize the number
of examples needed, and ( iii) explore the search space efficiently.
We nextelaborateuponeachof theseobjectives.
To capture the syntactic structure of rule-based programs, we
usemeta-rules [50]Ðtemplates that describe a set of possible rules
that can appear in a program. The key challenge is to obtain a
setofmeta-rulesthatis generalenoughtocaptureusefulprograms
515
ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA X. Si,W.Lee,R. Zhang, A.Albarghouthi,P.Koutris,andM. Naik
but specific enough to enable efficient synthesis . We propose a novel
approachtosystematicallygeneratemeta-rules,takingadvantage
ofdomainknowledge.
Tominimizethenumberofexamplesneeded,ourapproachaims
toaskanoracleasmallnumberofqueriesconcerningtheexpected
outputonagiveninput.Theoracleneedonlyanswerwith yesor
no, rather than crafting elaborate examples and supplying them to
thesynthesizer.Weusean activelearning technique,called query
by committee (qbc) [24,62], to pick an example that can prune the
searchspacethemost.Inoursetting, qbctakesasinputacommittee
formed by a set of consistent programs, and returns an example
on which the committee disagrees the most Ðthe most controversial
example. We then prune the programs that disagree with the given
label and repeat the process. However, it is infeasible to apply qbc
onthe entire searchspace,whichisprohibitivelylarge.
To explore the search space efficiently and overcome the chal-
lenge in using qbc, we use a bidirectional synthesis strategy to
maintain the most-general andmost-specific programs that are con-
sistent with the given examples[ 43]. Intuitively, the most-general
and most-specific programs (defined through logical entailment)
form a representative set of the search space, allowing us to pre-
serve exactness of the search. Moreover, this set is much smaller
than the size ofthe search space, making itan ideal committee . To
incrementally update the search space as examples are labeled, we
defineefficient top-downandbottom-uprefinementoperators that
are guidedbythe given setofmeta-rules.
We have implemented our end-to-end approach in the alpssys-
tem and report on our experience evaluating it on a diverse set
of34benchmarksfromthreedomains:knowledgediscovery,pro-
gram analysis, and relational queries. The evaluation shows that
alpscan synthesize 33 of these benchmarks, and outperforms the
state-of-the-arttoolsMetagol[ 19]andZaatar[ 9],whichcansyn-
thesizeonly upto 10 ofthe benchmarks.
We summarize the main contributionsofthis paper:
•Wepresentasyntax-guidedapproachandsystem alpsforsyn-
thesizingDatalogprograms from input-output examples.
•alpsemploys a bidirectional search strategy to efficiently tra-
versethe spaceofpossible programs.
•alpsminimizesthenumberofrequiredexamplesusinganactive
learningtechniquecalledquery-by-committee.
•We demonstrate the effectiveness of alpsat synthesizing real-
istic Datalog programs from diverse domains and its ability to
outperform existing state-of-the-arttechniques.
2 OVERVIEW EXAMPLES
alpslearns Datalog programs that are correct with respect to a
given instance of input and output relations. In this section, we
firstpresenttwoillustrativeexamplesthathighlightapplicationsof
alpsin two domains: program analysis and relational queries. We
then present an example to elucidate key design choices in alps.
We alsouse itas the running example inthe restofthe paper.
Example 2.1 (Program analysis). Datalog has shown great poten-
tialinthedomainofprogramanalysis[ 22,40,51,59,65].Thus,there
is a growing need to help synthesize program analyzers in Datalog
foravarietyofprogramminglanguages,includinggeneral-purpose
anddomain-specific ones.We demonstrate how alpscan be used to learn a static analysis
to detect API misusesÐa common source of bugs in today’s world
ofcomplexandevolvingAPIs.Foragivenexampleprogramwith
known API misuses, we populate input relations representing the
syntax ofthe program andoutput relations representing the bugs.
Then,alpslearns Datalog rules that can be used for detecting
similar API misuses.
ConsiderthefollowingCprogramusingtheOpenSSLAPI.Func-
tionsssl_socket_open1-4 establishaSSLsocketandreturnacon-
stantOKiftheysucceed.Twofunctions ssl_socket_open{2,4} con-
tain API misuses in that they incorrectly return OKwhen a SSL
socketisnot properly established.
1intssl_socket_open1 (SSL∗ssl){
2X509∗cert=SSL_get_peer_certificate (ssl);
3longerr=SSL_get_verify_result (ssl);
4if(!cert){...}
5if(err==X509_V_OK ){ ...}
6returnOK;//correct
7}
8
9intssl_socket_open2 (SSL∗ssl){
10X509∗cert=SSL_get_peer_certificate (ssl);
11if(cert==NULL){...}
12longerr=SSL_get_verify_result (ssl);
13...
14returnOK;//incorrect (missingcheckon err)
15}
16
17intssl_socket_open3 (SSL∗ssl){
18longerr=SSL_get_verify_result (ssl);
19if(err!=X509_V_OK ){...}
20X509∗cert=SSL_get_peer_certificate (ssl);
21if(cert){...}
22returnOK;//correct
23}
24
25intssl_socket_open4 (SSL∗ssl){
26longerr=SSL_get_verify_result (ssl);
27switch(err){
28 caseX509_V_OK :
29 cert=SSL_get_peer_certificate (ssl);
30}
31returnOK;//incorrect (missingcheckon cert)
32}
Ourgoalisto learnaDatalogprogramthatdetects functions that
misuse the OpenSSLAPI, whose behaviorisdefinedas follows:
•SSL_get_peer_certificate returns a pointer to the X509 cer-
tificatethepeerpresented.Ifthepeerdidnotpresentacertificate,
NULLisreturned.
•SSL_get_verify_result returns the result of the verification of
the X509 certificate presented by the peer, if any. It returns a
constant named X509_V_OK if the verification succeeded or if no
peer certificate waspresented.
Functions should return OKonly if (i)SSL_get_peer_certificate
returnsanon-nullpointer,and( ii)SSL_get_verify_result returns
the constant named X509_V_OK .
Theprobleminvolvesfourinputrelationsandoneoutputrela-
tionwiththe following meaning:
516Syntax-GuidedSynthesis ofDatalogPrograms ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA
•OpSucc(l1,l2) : Program controlmayflowfrom line l1tol2.
•Check(x,l) : The value of variable xis compared to a specific
valueat line l.
•Certify(x,l) : Variable xat linelis assigned the return value
ofSSL_get_peer_certificate() .
•Verify(x,l) : Variable xat linelis assigned the return value
ofSSL_get_verify_result() .
•Ok(l):Thefunctionthatreturns OKatlinelcorrectlyusesthe
OpenSSLAPI.
Relations OpSuccandCheckare pre-defined as part of the pro-
gram’s intermediate representation while relations Certifyand
Verifycan be automatically extracted from a given API, in this
case OpenSSL. We provide an instance of these relations encoding
the analyzedC program to alps,namely
Certify(cert,2),Verify(err,3),Check(cert,4),Check(err,5),...
alongwith Ok(6)andOk(22)aspositiveexamplesand Ok(14)and
Ok(31)as negativeexamplesintheoutputrelation. alpsgenerates
the following program in6minutes.
CertFlow (x,l2):−Certify(x,l1),OpSucc(l1,l2).
VeriFlow (x,l2):−Verify(x,l1),OpSucc(l1,l2).
CertCheck (l2):−CertFlow (x,l1),Check(x,l1),OpSucc(l1,l2).
VeriCheck (l2):−VeriFlow (x,l1),Check(x,l1),OpSucc(l1,l2).
Ok(l):−CertCheck (l),VeriCheck (l).
Therulesareintendedtobereadright-to-left,withallvariablesuni-
versally quantified, and the :−operator interpreted as implication.
Notethatpredicates CertFlow(x,l) ,VeriFlow(x,l) ,CertCheck(l) ,
andVeriCheck(l) are not specified among the input or output
relations; they are invented by alps, highlighting the rich space
of programs it explores.1We elaborate on how the search space
is determined in Section 4.1. The relation CertFlow(x,l) (Ver-
iFlow(x,l) resp.) indicates the return value of SSL_get_peer_-
certificate (SSL_get_verify_result resp.) flows to line l. The
relationCertCheck(l) (VeriCheck(l) resp.)meansthereturnvalue
ofSSL_get_peer_certificate (SSL_get_verify_result resp.) is
comparedto aspecific valueandcontrolflowsto line l.
TheDatalogprogramcorrectlycapturesanimportantportion
of the proper use of the OpenSSL API. This example illustrates
thatalpsrepresents a promising step towards synthesizing usable
programanalyzers.Onthecontrary,thestate-of-the-art ilptools
MetagolandZaatar fail to synthesize the program within 3hours.
Example 2.2 (Relational queries). Datalog is widely used as a
relational query language due to its expressiveness and scalable
performance[ 13,27,59].alpscanbeusedtosynthesizesophisti-
catedrelationalqueriesinDatalogfrom input-output behaviors.
We illustrate using alpsto synthesize a relational query for
finding students who take two different classes on the same day.
The problem involves three input relations and one output relation
withthe following meaning:
•Student(s,n) : Student sisassociatedwiththe ID n.
•Class(c,d) : Classcisheld onday d.
•Enrolled(n,c) : The studenthavingID nisenrolledinclass c.
•Busy(s): Student stakes twodifferentclassesonthe same day.
1For readability, we provide intuitive names for invented predicates instead of me-
chanically generated onesby alps.Itisnaturalinaprogramming-by-examplesettingfortheuserto
provide an instance specifying the input-output behavior of the
desiredquery.Usingsuchaninstancecomprisinginputrelations
regarding 14 students and 6 classes, and 5 examples in the out-
put relation Busy,alpssynthesizes the following Datalog program
within 18 seconds:
EnrollClass (n,c,l):−Enrolled (n,c),Class(c,l).
Busy(s):−Student(s,n),EnrollClass (n,c1,l),EnrollClass (n,c2,l),
c1!=c2.
whereEnrollClass is an invented predicate. While ostensibly sim-
ple, the above query is non-trivial to synthesize since it is semanti-
cally equivalentto the following complex SQL query:2
SELECT S.s FROM Student S
WHERE S.n IN(SELECT E1 .n
FROM Enrolled E1 ,Enrolled E2 ,Class C1,Class C2
WHERE E1.n=E2.n AND E1.c<>E2.c
AND E1.c=C1.c AND E2.c=C2.c AND C1.d=C2.d))
In contrast, a state-of-the art tool Scythe [ 69] for synthesizing SQL
queriesfails to generatethe above SQL query within 3hours.
Example2.3(Knowledgediscovery). Wedemonstratehow alps
synthesizes a prototypical program in knowledge discovery that
is commonly used in the ilpliterature: computing the transitive
closureofadirectedgraph.Theprobleminvolvesoneinputrelation
edgeandone outputrelation pathwiththe following meaning:
•edge(x,y) : there isan edge from node xto nodey.
•path(x,y) : there isapathfrom node xto nodey.
Suppose the user populates the input relation, edge, with the
following example graph:
3 4 56
7 21
where an edge from node ito nodejindicates that edge(i,j)ap-
pears inthe inputrelation.
Given4examplesoftheoutput relation path,alpssynthesizes
the following recursive program in less than one second, which
computes the transitive closure of adirectedgraph.
path(x,y) :- edge(x,y).
path(x,z) :- path(x,y), edge(y,z).
Infact,since alpsmaintainsallpossibleprograms,italsodiscovers
the following non-linear recursive program:
path(x,y) :- edge(x,y).
path(x,z) :- path(x,y), path(y,z).
Wenextelaborateonthreetechniquesthat alpscombinessyner-
gisticallyinorder to realizethis result.
Meta-rule-guided synthesis. Learning Datalog programs is a
complextask;evenapproximatelearningishard[ 18].3Toovercome
thisbarrier, alpsexploitsthe observationthatin practiceDatalog
programs comprise rules with similar latent syntactic structure.
2Datalogcan infactbe viewed as augmentingrelationalalgebra, which iswidely used
in the form of sql, with recursion.
3In approximate learning, the learnt program is not guaranteed to be consistent with
the given examples.
517ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA X. Si,W.Lee,R. Zhang, A.Albarghouthi,P.Koutris,andM. Naik
Note that both of the recursive rules above are very similar: the
onlydifferenceisintherelationnames.Wecapturesuchsimilarities
viathenotionof meta-rules [50]whichareessentiallyHornclauses
where the relation names are kept abstract and can be instantiated
later.Thenbothoftherecursiverulesareinstancesofthemeta-rule:
R0(x,z) :- R 1(x,y), R 2(y,z).
ManyDatalogrulesfollowasimilarchainpattern.Thissuggests
astrategyforsynthesizingDatalogprograms:enumerateallpos-
sibleinstantiationsoftheabovemeta-rulewithconcreterelation
namesandexaminetheircombinations.Furthermore,wecanthink
of slight variations of this pattern to capture a broader range of
programs. For example, the first rule in Example 2.2is a slight
variation of this meta-rule, the only difference being the arity of
predicate EnrollClass . We formalize this concept via a process
calledaugmentation (see Section 4.4).
Query-by-Committee ( qbc).alpsusesanactivelearningtech-
nique to iterativelyposemembershipqueriesaboutthe contents
oftheoutput relation, whichcanbe answeredupfront orinanin-
teractive manner. To minimize the number of queries, at each step,
alpspicks a query that can prune the space of candidate programs
the most to converge to the oracle’s desired program. In the above
example, it begins by posing the query: Is there a path from 1to
2?It obtains the answer yes.alpsthen poses the next query: Is
thereapathfrom 3to2?Itobtainstheanswer no,andtheprocess
continues. After 4 queries out of 49 possible queriesÐall pairs (i,j)
wherei,j∈[1,7],alpsarrivesattheaboveprograms.Incontrast,
picking examples to query randomly may result in a large number
ofquestions. Forinstance, in100 trialswith random selection,the
maximum number ofqueriesis27, withan averageof12.
Bidirectionalsearchstrategy. Toexplorethesearchspaceeffi-
ciently,weproposeabidirectionalsynthesisstrategytomaintain
aconcisecommittee,i.e.,themost-generalandmost-specificpro-
gramsthatareconsistentwithcurrentavailableexamples.Inour
running example, using this strategy results in only 384programs
beingevaluatedduringthesearch,outofover 104possibleprograms
inthe searchspace.
Theabovethreetechniquesarecombinedinasynergisticalman-
ner inalps: meta-rules define a reasonably large and rich space of
candidate programs; the syntactic structure of the space enables
bidirectionalsearchtoefficientlyrepresentandeffectivelyrefineall
consistent candidateprograms as aconcise committee;and,using
this committee, qbcguides the refinement by picking the most
controversialexample to query inthe nextiteration.
3 PROBLEM FORMULATION
In this section, we formalize Datalogandthe synthesis problem.
3.1 DatalogPrograms
Rules.Atermtiseitheravariable x,y,z,...,oraconstant a,b,c,....
Arelation symbol p,q,r,...is associated with an arity ar(r). An
atomis an application of a relation symbol to a vector of vari-
ables and constants, e.g., r(x,y,a)for a relation rwith arity 3. A
ground atom is an application of a relation symbol to constants,
e.g.,r(a1,...,an), whereaiare constants. A Datalog rule Cis an
expression ofthe form:A:-B1,B2,...,Bn.
whereA,B1,...,Bnare atoms. The atom Ais called the headof
the rule; the set of atoms {B1,...,Bn}is called the bodyof the
rule.ADatalogrulecanbeinterpretedasalogicalimplication:if
B1,...,Bnare true,then sois A.
Programs. A Datalog program Pis a finite set of rules. We divide
relation symbols into two categories: the input relations whose
contents are given, and the output relations whose contents are
derived from the input relations using the program P. An input
relation can never appear in the head of a rule. We use Ito denote
the set of facts(ground atoms) in the input relations. The Herbrand
baseBdenotesallpossibleapplicationsoftheoutputrelationsto
vectorsofconstantsin I.ADatalogprogramis recursiveifarelation
symbolappears inboth the head andthe body of arule.
Semantically,evaluating PonIyieldsaminimalHerbrandmodel
ofP∪I,whichisthesmallestsetofgroundatomsthatsatisfiesthe
rules inPand input I. Given a ground atom e,P∪I|=edenotes
thatPwithinput Iderives fact e.
3.2 Synthesis Problem
Our task is to synthesize Datalog programs through examples. An
exampleis a ground atom from the Herbrand base B, which can be
labeled as positive ( +) or negative (−). We are now ready to define
our synthesis problem.
Definition3.1(Synthesisproblem). Asynthesisproblem Sisatuple
(H,O,I),where
•HisasetofDatalogprograms, i.e.the hypothesisspace ;
•Oisanoraclethat labels eachexample with {+,−};
•IisasetofinputsÐfacts inthe inputrelations.
LetE+
O={e∈B|O(e)=+}andE−
O={e∈B|O(e)=−}be the
positiveandnegativeexamplesdefinedbytheoraclerespectively.
Thegoalistofind P∈Hsuchthat:forall e∈E+
O,P∪I|=e,and
for alle∈E−
O,P∪I̸|=e.
Givenasynthesisproblem (H,O,I),thesetofallDatalogpro-
gramsP∈Hthat are consistent with E=(E+,E−)is called the
versionspace ,andisdenotedVE.
4 OURAPPROACH
Inthissection,wepresentthesynthesisalgorithmunderlying alps.
Section4.1describes the structure of the search space. Section 4.2
presentsthealgorithmparameterizedbyrefinementoperators.Sec-
tion4.3instantiates the algorithm with meta-rules. Section 4.4
describes our methodology for designing meta-rules. Lastly, Sec-
tion4.5states formalpropertiesof our algorithm.
4.1 StructureoftheSearch Space
Thehypothesisspace HconsistsofafinitesetofDatalogprograms
overthe sameinputand outputrelations. Forourrunning example
(Example 2.3), we consider a simple hypothesis space where all
programs use asubsetofthe following fourrules:
r1: path(x,y) :- edge(x,y).
r2: path(x,z) :- path(y,z).
r3: path(x,x) :- edge(x,x).
r4: path(x,y) :- path(x,z), path(z,y).
518Syntax-GuidedSynthesis ofDatalogPrograms ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA
Algorithm1 Thealpssynthesis algorithm
1:(E+,E−)←(∅,∅)
2:P←MostGeneral()
3:P←MostSpecific()
4:loop
5:P←P∪P//construct committee
6:if∀e∈B.D(e,P)=0then return P
7:e⋆←argmaxe∈BD(e,P)//most controversial example
8:⋄←O(e⋆) //⋄∈{+,−}
9:E⋄←E⋄∪{e⋆}
10:P←F↓(P,E+,E−)//top-down refinement
11:P←F↑(P,E+,E−)//bottom-uprefinement
12:end loop
WedenotetheDatalogprogramconsistingofrules ri,rj,rkasPijk.
Generalityorder. Westructurethesearchbyimposingageneral-
ityorderonthespaceofDatalogprograms.Todefinethisorder,we
useθ-subsumption[ 54],whichisasyntacticapproachfordeciding
whether one rulesubsumes(ismore generalthan) anotherrule.
Formally, a rule Csubsumes another rule Diff there is a variable
substitution θsuchthat Cθhasthesameheadas D,andallatomsin
thebodyof Cθappearinthebodyof D.4Forexample, r2subsumes
r4withθ={z/y,y/z},andr1subsumes r3withθ={y/x}.
Subsumption can be naturally extended from rules to programs.
For any two Datalog programs PandQ,Psubsumes Q, denoted
Q⊑P, iff for every rule in Qthere exists a rule in Pthat subsumes
it.For instance,inour running example, P13subsumes P24.
Given the hypothesis space H, and a generality ordering ⊑,
everysubset PofHformsaquasi-orderedsetw.r.t. ⊑.Wecannow
construct a partial order on the quotient set of the equivalence
relation (twoprograms P,Qare equivalentif P⊑QandQ⊑P).
Inourrunningexample,thefollowingequivalenceclassesare
formed w.r.t. θ-subsumption:{P1234,P123,P124,P12},{P143,P14},
{P13,P1},{P324,P32},{P24,P2},{P34},{P3}, and{P4}. We restrict
the hypothesis space such that it has one representative from each
class(anyoftheprogramswiththefewestrules)anddefineapartial
order directlyonthese representativesinsteadoftheequivalence
classes. We can achieve this without any loss of generality since
we are discardingonlysemantically equivalent programs. For our
runningexample,thehypothesisspacecannowbereformulated
as{P12,P14,P1,P32,P2,P34,P3,P4}.
Sincethe generalityorderis a partialorder, there may exist mul-
tiple maximal and minimal elements. The set of maximal elements
is denoted max(P)={P∈P|∄P′∈P.P❁P′}, and we call these
themost-general programs.Similarly,thesetofminimalelements
is denoted min(P)={P∈P|∄P′∈P.P′❁P}, and we callthese
themost-specific programs.Figure 1ashowstheinitialversionspace
forourrunningexample,wherethemost-specificandmost-general
programs are coloredyellowandred,respectively.
4.2 The ALPS Algorithm
Given a synthesis problem S=(H,O,I),alpsapplies Algorithm 1
tofindasolutionfor S.Itisafixpointalgorithmthatmaintainsa
4Asubstitution θisaset{v1/t1,···,vn/tn}wherethe viaredistinctvariables
andtiareterms.Notation Cθdenotestheruleobtainedbyapplyingsubstitution θ
onruleC, i.e., for each vi/ti∈θ, wereplaceeachoccurrenceof viinCbyti.pairE=(E+,E−)of positive and negative examples, and a set of
most-general programs Pand most-specific programs Pthat are
always consistent with E. The examples are initially empty, and
P,Pare initialized to be the most general and most specific pro-
grams respectively(wedefinethisinitialization inSection 4.3). At
everyiteration,itaddsa(positiveornegative)examplebyquery-
ing the oracleO. Then, it invokes two refinement operators F↑,F↓
whichrecalculatethemost-generalprogramsandthemost-specific
programsthatagreewiththenewexample(wedefinetherefine-
mentoperatorsinSection 4.3).The algorithmstopswhennonew
examples can be added.
The crux of the algorithm is the way we choose the example
toquerytheoracle.Theunionoftwosetsofprograms P,Pforms
thecommittee P.Thecommittee then picks the mostcontroversial
examplee⋆. IfO(e⋆)=+, thene⋆is added to E+; otherwise, e⋆is
addedto E−.Ifnocontroversialexampleexists,theneveryonein
thecommitteeagrees;thealgorithmterminatesandreturnsset P,
whichcontains allthe most-general andmost-specific solutions.
Inordertodeterminethemostcontroversialexample,weusethe
metricof voteentropy .Itisinspiredbyquery-by-committee[ 24,62],
a greedy yet effective strategy commonly used in active learn-
ing [61]. Since there are only two possible labels for an example,
we use a simplified definition, which is essentially equivalent to
disagreement count.
Definition 4.1 (Vote entropy). For an example eand set of com-
mittee members K,thenormalized voteentropy is:
D(e,K)=1−2
|K|/barex/barex/barex/barexp−|K|
2/barex/barex/barex/barex
wherepisthenumberofcommitteemembersthatassignapositive
label to the example e.
When the vote entropy of an example is zero, all programs in
the committee agree on its label. Figure 1shows theversion space
andthe query posedineachiteration for our running example.
4.3 Refinementwith Meta-Rules
We now give concrete definitions of the initialization functions
and refinement operators, F↑andF↓in Algorithm 1. The design
of the refinement operators is motivated by a practical insight:
the synthesis search should be biased towards patterns that are
frequently used in practice. We are inspired by meta-rules [50],
which are templates that dictate syntactic restrictions on rules and
therefore anaturalrepresentation to biasthe search.
Meta-rules. Ameta-rule is asecond-order rule . Multiple rules can
be instantiated from a meta-rule. We shall use V1andV2to denote
first-andsecond-ordervariables,respectively.Ameta-ruletakes
the following form:
R1(x1,...,xm1):-R2(y1,...,ym2),...,Rn(z1,...,zmn).
wherexi,yi,zi∈V1andRi∈V2.
A meta-rule can be instantiated by substituting second-order
variables with relation symbols. For example, the rules from the
running example are generatedbythe following meta-rules:
T1: R0(x,y) :- R 1(x,y).
T2: R0(x,z) :- R 0(y,z).
519ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA X. Si,W.Lee,R. Zhang, A.Albarghouthi,P.Koutris,andM. Naik
1,2
1,42,3
13,42
34
(a)Initialization
path(4,2)?No1,2
1,42,3
13,42
34
(b) Iteration 1
path(1,2)?Yes1,2
1,42,3
13,42
34
(c) Iteration 2
path(1,4)?Yes1,2
1,42,3
13,42
34
(d)Iteration 3
converged
Figure 1:Versionspaceineachiteration (red/yellow nodes represent most-general/specificprograms inthe currentiteration;
purple nodes represent programs that are both most general and most specific in the current iteration; and grey nodes repre-
sent programs that have been evaluated). Anarrow from utovmeansthat program uismore generalthan program v.
Algorithm2 Meta-rule-guidedrefinement
Function F↓(P,E+,E−)
1:E←(E+,E−)
2:whileP⊈VEdo
3:∆P←(P∩VE+)\VE−
4:∆P←ρ↓(∆P,T)∩VE+
5:P←(P∩VE)∪∆P
6:end while
7:returnPFunction F↑(P,E+,E−)
1:E←(E+,E−)
2:whileP⊈VEdo
3:∆P←(P∩VE−)\VE+
4:∆P←ρ↑(∆P,T)∩VE−
5:P←(P∩VE)∪∆P
6:end while
7:returnP
T3: R0(x,x) :- R 1(x,x).
T4: R0(x,z) :- R 0(x,y), R 0(y,z).
Similartorules,ageneralityorderbetweenmeta-rulescanbees-
tablishedusing θ-subsumptionbyallowingsubstitutionforsecond-
ordervariablesaswellasfirst-ordervariables.Usingthisgenerality
order,asetofmeta-rulesforms apartiallyorderedset.
Initialization. Theinitializationfunction MostGeneral()collects
all rules instantiated from the most general meta-rules and com-
binesthemasthemostgeneralprogram.Theinitializationfunction
MostSpecific()makes each individual rule instantiated from the
mostspecificmeta-rulesasasingleruleprogram,andallofthese
programs form the initialsetofmostspecific programs.
Meta-rule-guidedrefinement. Algorithm 2describesourrefine-
ment operations, F↓andF↑, which are parameterized by a set of
meta-rules T. We explain only top-down refinement F↓in detail,
since bottom-up refinement F↑works inasymmetrical manner.
The algorithm begins with the given set of programs P. Then, it
iteratively specializes theprogramsbyapplyingthespecialization
operator ρ↓, which is guided by T(line2ś5). In each iteration,
the condition P⊈VEchecks whether the current programs are
consistentwiththeexamples.Ifthereisnoviolation,thealgorithm
terminates. Otherwise, line 3first eliminates programs violating
positive examples, and then selects programs violating negative
examplestospecialize.Intheformercase,programsfailtoderivea
positiveexample,andmorespecificprogramswillalsofailtoderive
it.Thisprocessremovesnotonlyinconsistentprogramsbutalso
anyprogramsmorespecificthanthem.Theeliminationhappens
inthethirditerationofourrunningexampleshowninFigure 1c:whenP23is eliminated due to the positive example path(1,2) ,
all the more specific programs P34,P2,P3,P4are eliminated from
considerationas well.
Next, line 4specializes programs violating negative examples
bycalling ρ↓,andeliminatesanygeneratedprogramsthatfailto
deriveapositiveexample.Finally,line 5updatesPbyincludingthe
newspecializedprograms.
The final piece of the puzzle is the specialization operator ρ↓.
Here,ρ↓canspecializeaprogramintwoways:(1)replacearule
it witha more specificone;forinstance,inourrunningexample
shown in Figure 1b, program P12is specialized to P14andP23;
(2) remove a rule that cannot be further specialized; for instance,
P23could potentially be specialized to P2. Finding all more specific
rules for a given rule rcan be efficiently done by consulting the
generality order of the meta-rules T: first, find the meta-rule Tr
usedtoinstantiate r;then,findallmorespecificmeta-rules Tswith
respectto Tr;finallyexamineallrulesinstantiatedfromameta-rule
inTsandkeepthe ones more specific than r.
4.4 AugmentationandPredicateInvention
The choice of meta-rules dictates the effectiveness of our synthesis
algorithm.If theset ofmeta-rules istoolarge,then alpswillnot
beabletoscale,sincethesearchspacewillbehuge.Ontheother
hand,themeta-rulesmustbesufficientlyrichtocapturethedesired
program. Simply reusing meta-rules that are either provided by
the end-user or mined from existing code repositories is usually
insufficient.Tosolvethisproblem,westartwithaverysmallset
ofintuitivemeta-rulesthatarespecifiedmanually(e.g.,thechain
meta-rule), and then extend these using augmentation , a process
that slightly modifieseachmeta-rule.
An augmentation T′of a meta-rule Tis a meta-rule where each
atomR(x1,...,xk)inTisreplacedbyanotheratom R(y1,...,yℓ).
However, we must take care to limit how much the sequence of
variables changes. Denote by dR(T,T′)theedit distance between
the strings x1...xkandy1...yℓ. Then, the augmentation distance
betweenT,T′isdefinedas
AD(T,T′)=/summationdisplay.1
RdR(T,T′)
520Syntax-GuidedSynthesis ofDatalogPrograms ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA
whereRranges over all atoms in T. Our key idea is to consider all
theaugmentationsof Tthatare withinaboundedaugmentation
distance from T. The smaller this bound, the fewer meta-rules will
be generatedfrom T.
Asanexample of augmentation,considerthesetwo meta-rules:
T1: R0(y) :- R 1(z), R2(y,z).
T2: R0(y,z) :- R 1(z,x), R 2(y,z).
Then,T2isan augmentationof T1withdistance 2.
The augmentation distance required for alpsto synthesize a
programPfrom an initialsetofmeta-rules Tis:
AD(P,T)=max
T1min
T2∈TAD(T1,T2)
whereT1ranges over all meta-rules used in P1. In our experiments,
we could synthesize almost all of the programs using an augmenta-
tiondistanceof5from three chain meta-rules.
Predicate invention. Another orthogonal way to improve the
richness of programs in the search space is predicate invention.
Predicate invention helps to break a complex rule into simpler
ones,andtherebyenablestoreuseexistingmeta-rules.Moreimpor-
tantly,itisunavoidableforDatalogprogramswithrecursion.For
instance, consider the following program which computes strongly
connectedcomponents(SCC)inadirectedgraph:
path(x,y) :- edge(x,y).
path(x,z) :- path(x,y), edge(y,z).
scc(x,y) :- path(x,y), path(y,x).
Here, the input and output relations are edgeandscc, respectively.
Given that scccannot be derived by any set of clauses in terms of
onlytheinputrelation edge,anewpredicate pathmustbeinvented.
The difficulty with predicate invention lies in determining what
formtheinventedpredicatesshouldtake.Withoutmeta-rules,we
have no way to effectively constrain the syntax of such predicates.
With meta-rules, we can easily support predicate invention: the
rulesthatdefinethepotentialinventedpredicatesareexactlythe
instantiationsofmeta-ruleswithconcrete relations.
4.5 PropertiesofALPS
Thealpssynthesisalgorithm(Algorithm 1)alwaysmakesprogress:
after every query to oracle O, we remove from consideration a
controversialexamplefrom B.Sincethesetofpossibleexamples
Bis finite, the algorithm always terminates. It also guarantees
that asolution isfoundifthere are nocontroversialexamplesleft
in the committee. To ensure this property, it is critical that the
algorithmtracksboththemost-generalandmost-specificprograms
ateveryiteration.Thefollowingtheoremsuccinctlycapturesthese
properties.We provideits proofinthe Appendix.
Theorem 4.2. LetS=(H,O,I)be a synthesis problem such that
asolutionto SexistsinH.LetPbetheoutputof alps.Then:
(1) (Soundness)Every P∈Pis asolutionto S.
(2)(Completeness) For every solution P∈ HtoS, there exist
programs Pl,Pu∈Psuch that Pl⊑P⊑Pu. An immediate
corollaryisthatifthereexistsaprogramPthatisasolution
toS,thenPis nonempty.
(3) (Termination) alpsterminates in finitelymanysteps.5 EMPIRICAL EVALUATION
We evaluate alpson a variety of synthesis tasks from different
domains. Our implementation5comprises about 8,000 lines of C++
code.ItusesthefixpointengineoftheZ3 smtsolver[31]forDatalog
evaluation.OurexperimentswereperformedonaLinuxmachine
with16 GB ofRAM anda3.0 GHz processor.
Our evaluation aims to answer the following questions:
Q1.Howdoes alpsperformonsynthesistasksfromavarietyof
domainsinterms ofsynthesis time andnumber of queries?
Q2.How much does meta-rule augmentation speed up synthesis?
Q3.Howeffectiveis qbcinreducingthenumberofqueriesasked?
Q4.Howsensitive is alpsto changes inagiven inputdata?
Q5.Howdoes alpscompare withexisting synthesis techniques?
5.1 Benchmark Suite
We collected 34 synthesis tasks from three different application do-
mains: (i) knowledge discovery, ( ii) program analysis and ( iii) rela-
tionalqueries.Table 1presentsusefulcharacteristicsofthesebench-
marks.Thelastthreecolumnsshowthenumberofinputśoutput
relations, the number of rules of the smallest desired program, and
whether the desiredprogram isrecursive ornot, respectively.
Knowledge discovery. The knowledge discovery benchmarks
comprise8tasksofsynthesizingDatalogprogramsfrequentlyused
in the artificial intelligence and database literature. The goal of
the first benchmark inflammation is to discover interesting cor-
relations between patient risk factors and a disease called acute
inflammationsofurinarybladder.Weusedadatasetcreatedbya
medical expert to enable expert systems that perform presumptive
diagnosisofthedisease[ 20].6Thenextfourbenchmarks( abduce,
ancestor ,animals, andbuildWall ) are widely used in the field
ofinductivelogicprogramming[ 46,50].Thesamegenbenchmark
is a standard Datalog program in the database literature [ 7]. The
pathbenchmarkistheproblemdescribedinExample 2.3andthe
sccbenchmark is the problem of computing strongly connected
componentsinadirectedgraph.
Programanalysis. Theprogramanalysisbenchmarkscomprise
11 tasksofsynthesizing staticanalyzers written inDatalog:
•polysite isapolymorphic call-siteinference analysisfor Java;
•downcast isadowncast safetychecker for Java;
•rv-check is the static API misuse detector described in Exam-
ple2.1, which is motivated from a return value checker used in a
toolcalled apisan[72].apisanidentifies apimisusesbydetecting
inconsistent uses of the return values of apifunctions. However,
the tool is neither sound nor complete due to the limitation of
its statistical method. This observation motivated our rule-based
approach for staticAPI misuse detection.
•andersen isaclassic pointer analysisfor C [ 12];
•The next five benchmarks are pointer analyses for Java with
variouscontextabstractions[ 42,66,70].
•modrefisamod-refanalysisforJavaand escapeisanescapeanal-
ysisforJava.Bothbenchmarksoriginatedfromaprogramming
assignment inan onlinecourse onprogram analysis[ 5].
5Ourartifact isavailable onGitHub: https://github.com/XujieSi/fse18-artifact-183 .
6Available at http://archive.ics.uci.edu/ml/datasets/Acute+Inflammations .
521ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA X. Si,W.Lee,R. Zhang, A.Albarghouthi,P.Koutris,andM. Naik
Table 1:Benchmarkcharacteristics.
Benchmark Briefdescription #Relations #RulesRecursive?
KnowledgeDiscovery
inflammation diagnosis of bladderinflammation 72
abduce grandparentof given father/mother [ 46]43
animals distinguishingclassesof animals [ 46] 134
ancestor ancestor in a family tree[ 50] 44 ✓
buildWall learn a stablewall strategy [ 50] 54 ✓
samegen same generationin a family tree[ 7] 33 ✓
path all-pairsreachability in directed graph 22 ✓
scc computeSCCs in directed graph 33 ✓
ProgramAnalysis
polysite polymorphiccall-siteinferencefor Java 63
downcast downcast safetychecker for Java 94
rv-check return-value-checker in APISan [ 72] 55
andersen inclusion-based pointer analysis for C[ 12]54 ✓
1-call-site 1-call-sitepointer analysis for Java[ 70]94 ✓
2-call-site 2-call-sitepointer analysis for java [ 70]94 ✓
1-object 1-object-sensitivepointer analysis [ 42]114 ✓
1-type 1-type-sensitivepointer analysis [ 66] 124 ✓
1-obj-type 1-type-1-object sensitiveanalysis [ 66] 135 ✓
escape escapeanalysis for Java 106 ✓
modref mod-ref analysis for Java 1310 ✓
Relational Queries
sql-1∼1515SQL queries [ 69] ⩽7⩽4
Relational queries. These benchmarks comprise 15 synthesis
tasksfromStackOverflowpostsandtextbookexamples[ 69].We
chosethe15tasksofsynthesizing sqlqueriesthatcanbeexpressed
in Datalog. Each task involves up to 6 input tables and one output
table.The desiredDatalogprograms compriseupto fourrules.
5.2 ExperimentalSetup
Meta-rules. Wefirstapplyonlythefollowingthreechainmeta-
ruleswithupto 5augmentations for allbenchmarks:
R0(v1,v2) :- R1(v1,v2).
R0(v1,v3) :- R1(v1,v2), R2(v2,v3).
R0(v1,v4) :- R1(v1,v2), R2(v2,v3), R3(v3,v4).
We observe that alpsfails to synthesize five context-sensitive
pointeranalysisbenchmarks,asthenecessaryaugmentationdis-
tance is too far and offers no filtering of the search space. In these
cases,wealsoincludedomainspecificmeta-rules,e.g.meta-rulesex-
tracted the remaining four benchmarks. Also, we set the maximum
number ofinventedpredicates to 4.
Input-output relations. Foreachbenchmark, alpsbeginswith
no examplesof output relations and iteratively poses membership
queries about the contents of the output relations. To answer such
queries, we used the known solution of the benchmark (i.e., the de-
sired Datalog program) as an oracle. The populated input relations
range insize from 3to 77 withan averageof22.
5.3 EvaluationResults
Q1:Numberofqueriesandsynthesistime. Table2presentsthe
mainresultsofourevaluation.Consider,forinstance,the ancestor
benchmark. alpsmakes11queriestotheoracle(outofamaximum
of450queries,whichisthesizeoftheHerbrandbase);ittakes25seconds to synthesize 3 programs; and, in the process, it evaluates
24,280programs outof 1010programs inthe search space.
Overall, our results demonstrate the small number of queries
needed to discover non-trivial programs. For most benchmarks,
alpsrequires less than 20 queries; for our largest benchmark, mod-
ref,alpsmakes22queriestotheoracleinordertosynthesize10
rules.Itsynthesizesmostprogramswithinafewminutes.Incertain
examplesÐlike modrefÐa large number of programs are evaluated,
thus requiring more synthesis time.
Q2:Effectivenessofmeta-ruleaugmentations. Figure3shows
thefrequencydistributionofbenchmarksaccordingtotheiraug-
mentation distance with respect to chain meta-rules. Only two
benchmarks can be synthesized with no augmentation, while most
benchmarks(29outof34)canbesynthesizedwithnomorethan
5augmentations.Thisindicatesthatsimplechainmeta-rulesare
quitelimitedbythemselves,butwecanhandlealargenumberof
benchmarks byslightly mutatingthem.
Starting with only chain meta-rules, however, alpsfails to scale
on five context-sensitive pointer analysis benchmarks, whose aug-
mentationdistanceis6orlarger.Weobservethatalthoughthese
five benchmarks are different from each other, their rules are quite
similar.Table 3showstheaugmentationdistancesforeachofthese
fivebenchmarkswithrespecttotwosetsofmeta-rules:chainmeta-
rulesandmeta-rulesminedfromtheotherfourbenchmarks.The
augmentation distance implies that, in comparison with general
chain meta-rules, meta-rules mined from the same domain are
more useful to guide the synthesis search process. Indeed, with
extra meta-rules mined from the other four benchmarks, alpsis
abletosynthesizefourofthefivecontext-sensitivepointeranalysis
benchmarks,as showninTable 2.7
Q3: Quality of qbc.We now investigate the quality of qbc’s
selectionstrategy.Todoso,weinstrument alpstorandomlypick
an example that the committee disagrees on, instead of one that
maximizes vote entropy. For each benchmark8, we ran 100 trials
with random example selection. Figure ( 2a) shows a box plot of
the number of queries made in these trials. We see that random
selection,onaverage,performsmuchworsethan qbc.Forinstance,
on theancestor benchmark, the median for random selection is
more than120queries,while qbconly needs11.
Comparedtothebest-casescenariosofrandomselection, qbc
makes roughly the same amount (about +/-5 queries) of queries for
mostbenchmarks.Forthe andersen benchmark, onerandomtrial
behavessurprisinglywell:itonlyrequires8questionstosynthesize
all 4 expected rules, one of which eliminates 99.7% of the com-
mittee members. This is an artifact of qbc’sconservative example-
selectionapproach:itprefershigh-entropyexamples,soitmaymiss
alow-entropyexamplethatcouldeliminatemostofthecommittee,
indicating qbcisnot optimal but practically effective.
Q4: Sensitivity to the size of input data. We now investigate
the effects of increasing the size of input data on the number of
queries needed. We focus on the andersen benchmark, as it is
demonstrativeofthebehavioracrossourbenchmarksuite.Recall
71-obj-type takesalps17hours to finish and hence is marked as timeout.
8We skip the SQL benchmarks as alpsasks a very small number of queries for them.
522Syntax-GuidedSynthesis ofDatalogPrograms ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA
Table 2:alpsperformanceresults (the timeoutlimit is3 hours).
#queriesasked Metagol run. time(sec.)
byalps#possible
queries#synthesized
programs#evaluated
programssearch
spacetotal
time(sec.) alpssetting idealsettingZaatar
run. time(sec.)
inflammation 8 120 4 2327 1064.3 0.51 0.47 timeout
abduce 11 392 1 4613 1063.36 timeout 0.43 timeout
animals 16 80 2 45152 10675.8 0.46 0.42 timeout
ancestor 11 450 3 24280 101024.6 timeout 0.43 timeout
buildWall 12 392 13 61654 1010128.7 timeout 35.1 timeout
samegen 12 162 2 110338 10922.3 timeout timeout 4.77
path 4 49 3 384 1040.26 timeout 0.43 26.43
scc 14 128 4 57013 10688.7 timeout timeout timeout
polysite 14 204 5 27432 1022130.0 timeout 0.43 timeout
downcast 9 912 1 56489 1028299.8 timeout 0.43 timeout
rv-check 4 24 1 393740 1029361.5 timeout timeout timeout
andersen 15 64 1 100345 1020148.0 timeout timeout 295.31
1-call-site 14 152 3 99697 1032178.3 timeout timeout timeout
2-call-site 17 672 1 184824 1053601.8 timeout timeout timeout
1-object 18 655 1 93362 1048705.1 timeout timeout timeout
1-type 13 215 2 10038 103021.6 timeout timeout timeout
1-obj-type - - - - 1051timeout timeout timeout timeout
escape 9 40 12 5706 10349.9 timeout timeout timeout
modref 22 145 1 1346754 10455307 timeout timeout timeout
sql-1 4 7 1 30 1060.07 0.01 0.01 43.65
sql-2 3 12 1 7 1060.02 0.01 0.01 timeout
sql-3 1 4 1 1 1010.03 0.01 0.01 timeout
sql-4 5 15 1 19 1020.02 0.01 0.01 timeout
sql-5 1 7 1 1 1020.01 0.01 0.01 timeout
sql-6 6 729 1 44 1020.03 0.01 0.01 timeout
sql-7 1 25 1 1 1010.01 0.01 0.01 timeout
sql-8 5 48 2 230 10161.60 0.02 0.01 timeout
sql-9 5 27 1 9 10160.30 timeout 0.01 6260
sql-10 8 40 1 778 102363.2 timeout 0.01 timeout
sql-11 4 25 6 1192 10181.86 timeout 0.04 8320
sql-12 4 34 1 117 10150.20 timeout timeout 2417
sql-13 3 80 1 4 1030.01 timeout timeout timeout
sql-14 3 651 1 13 102590.9 timeout timeout timeout
sql-15 5 266 1 344 101517.7 timeout timeout timeout
(a) (b)
Figure 2: (a) Box plot of the number of queries asked by random selection (green dots mark the number of queries by qbc);
and(b)Numberofqueriesasked by alpsfortheandersen benchmarkunder differentsizesofinput data (where X=7).
thatandersen is a pointer analysis for C programs. We system-
atically increased the size of the input data (i.e., the size of the
analyzed program),and measured the numberof queries needed to
synthesizeAndersen’sanalysis,aswellasthesynthesistime.Fig-
ure(2b)summarizes theresultsofthisexperiment.Itshowsthatas
the size of the data increases, the number of questions asked stays
roughlyconstant.Asaresult,thequestionratio(numberofques-
tions asked to the total number of possible questions) is reducedsignificantly, from nearly 25% to 0.002%. The number of evaluated
programsalsoremainsroughlyconstant.Asexpected,thesynthesis
timeincreaseswithmoredata,as alpsneedstoinvoketheDatalog
solver onlarger inputs.
Q5:Comparisonwith other tools. We now compare alpswith
two state-of-the-art ILP tools: Metagol [ 19] and Zaatar [ 9]. We
523ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA X. Si,W.Lee,R. Zhang, A.Albarghouthi,P.Koutris,andM. Naik
Table 3: Augmentation distances of context-sensitive
pointer analysis benchmarks with respect to chain meta-
rulesandmeta-rules mined fromthesamedomain.
1-call-site 2-call-site 1-object 1-type 1-obj-type
chain 6 8 6 6 8
same domain 3 3 1 2 2
supply both of these tools with all ground facts upfront since they
are non-interactive.
Metagol is an ilptool that is an instance of the meta-interpretive
learningframework[ 50],whichisalsoparameterizedbymeta-rules.
We run Metagol with two settings: the alpssetting, which uses
thesamesetofmeta-rulesthat alpsusesafteritperformsaugmen-
tation,andtheidealsetting,whichconsistsoftheminimalsetof
meta-rules that are sufficient for synthesizing a correct program.
Usingalps’s setting, Metagol cannot finish most knowledge dis-
coverybenchmarksandallprogramanalysisbenchmarks.Using
the ideal setting, Metagol still fails on two knowledge discovery
benchmarksandmostofprogramanalysisbenchmarks.Metagol
also fails on four of the sqlbenchmarks despite their lack of recur-
sion.ItisimportanttonotethatMetagolemploysmeta-interpretive
learning,whichisnotacompletetechnique,soitisnotguaranteed
to terminate,despitefiniteness ofthe searchspace.
Zaatar [9] is a constraint-based Datalog program synthesis tool.
Itfailsonmostofourbenchmarksbecauseitisverysensitivetothe
sizeoftheinputdata,sincethesizeoftheencodingispolynomial
in the input data. In contrast, alpshas much better scalability in
termsofinputsize, as alpsonlyevaluatescandidateprograms on
inputdata instead ofencoding the inputas symbolic constraints.
Summary. To summarize, our experimental evaluation demon-
strates(i)theabilityof alpstosynthesizesophisticatedalgorithms;
(ii) the effectiveness of meta-rules and augmentations; ( iii) the im-
portance of qbcat reducing the number of queries; and ( iv) the
robustnessofour synthesis approach to inputsize.
5.4 Threatsto Validity
Thereareseveralthreatstothevalidityofourapproach.Weoutline
thesenextalongwithproposalsto mitigate them.
•alpsmayfailtosynthesizeadesirableprogrambecausetheinput
relationsdonotcoverallcornercases(i.e.,overfitting).Wecan
mitigate this threat by allowing the user to provide a large input
andtakingadvantageof alps’sabilitytohandlesizeableinput
data as shown in Figure ( 2b). In practice, large input relations
often cover the vastmajority ofcorner cases.
•The labeled examples may be noisy. This threat can be mitigated
bycollectinganswersfrommultipleoracles(e.g.,throughcrowd-
sourcingormultiplereferenceimplementations)andusingthe
majority voteas the final answer.
•Alargenumberofequivalentfinalprogramsexistduetomanyap-
plicablecombinationsofmeta-rules.Thisthreatcanbemitigated
bysacrificingcompletenessandreportingasubsetofprograms.
•The meta-rules generated by alpsmay be insufficient to capture
adesiredprogram.Thisthreatcanbemitigatedbyusingalarger
numberofinventedpredicates.Themoresuchpredicatesweuse,
thesimplerrulesweobtain.Eventually,thedesiredprogramwill
comprisetypicalrules,thus enabling alpsto synthesize it.
Figure 3:Augmentation distance distribution.
6 RELATED WORK
Inductive logic programming. While we use key ideas from
inductive logic programming ( ilp) inalps, a number of properties
distinguish our approach from existing ilpapproaches. First, work
inilpusuallylearnrelations,oftenprobabilisticones[ 21],fromvast
amounts of mined data, e.g., biological data [ 47]. In our work, and
inalargeclassofsynthesistechniques,thegoalisto interactively
inferaprogramfroma small,representativesetofexamples .Second,
mostilpsystems are not adeptat learning recursive rules.In con-
trast, we specifically aim to infer recursive rules. Third, ilpis often
interested in programs that correctly classify mostexamples. In
contrast, we are interested in programs that correctly characterize
allpositive and negative examples. Fourth, many ilpsystems re-
quireacomplicatedinteractionmodel(forexample,F ilp[15]poses
existential queries and cigol[48] poses generalization queries).
In contrast, alpshas a simple interaction model that only poses
membership queries. Lastly, we employ a completesearch strategy,
whereasilpsystems can fail to find a program even if one exists
that isconsistent withthe given examples.
More recently, ilphas been applied to end-user programming
andonlinetutoring[ 29].Meta-InterpretiveLearninghasbeenused
to learn Prolog programs for string manipulation tasks [ 38]. These
applications share similar goals as ours of learning programs by
obtaining examples from users. We focus on Datalog programs
whereas they learn programs in other domains, e.g., string manipu-
lationortabletransformation.Also,whentheirgeneratedprogram
isincorrect,theuserisexpectedtoprovideacounterexample.In
contrast, our approach automatically identifies the most controver-
sial example to pose to the user.
Template-guided synthesis. Templates are commonly used to
guide the search in program synthesis [ 19,64,67,68]. At a high-
level, meta-rules can also be seen as program sketches [ 67], where
the holes are the relation symbols.
Interactive synthesis by example. Some of the programming-
by-example( pbe)approachesinteractivelyqueryanoracle forex-
amples.Jhaetal.[ 32]presentanoracle-guidedsynthesisprocedure
for straight-lines programs encodable in smt. They require the ora-
cle(usuallyareferenceimplementation)toprovidetheoutputwhen
givensomeinput.Anotherrecentinteractivesynthesis approachis
applied in the contextof parsersynthesis [ 37]tolearn agrammar.
Synthesis ofrecursive programs. A number of works have tar-
getedtheproblemofsynthesizingrecursiveprograms[ 8,23,34,35,
524Syntax-GuidedSynthesis ofDatalogPrograms ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA
53,55].Mostoftheseworksfocusonrecursivefunctionalprograms
that manipulate recursive data structures. Datalog programs recur-
sively traverse relations (hypergraphs). To our knowledge, none of
the functional techniques have been appliedto this domain.
Version-space algebras. Version-space algebras were used for
synthesis, initially by Lau et al. [ 36], and more recently in Flash-
Fill [28] for spreadsheet manipulation. alpsmaintains a version
space using most-general and most-specificprograms, as first pro-
posedbyMitchell[ 43].OursettingisdifferentthanMitchell’sin
thesensethatthesearchspaceisdeterminedbyasetofmeta-rules
thatformsapartiallyorderedset,andtherebywecanexploitthe
generalityorder onthe meta-rulesfor our bidirectionalsearch.
Learning forprogram analysis. Recently, several systems have
beencreatedthatapplymachinelearningtechniquestoprogram
analysis. Oh et al . [52]use Bayesian optimization techniques to
effectively learn adaptation strategies for parametric program anal-
ysis, while Bielik et al . [16]apply the ID3 algorithm to learn a
decision tree that represents points-to and allocationsitefactsfor
individualJavaScriptfunctions.Thisworkeitherlearnsanefficient
configurationforprogramanalysisoranaccuraterepresentation
for the results of an analysis. In contrast, our work can learn the
rulesofthe program analysis,expressedinDatalog.
7 CONCLUSIONSAND FUTUREWORK
We proposed a programming-by-example system, alps, to syn-
thesize Datalog programs. It employs a syntax-guided synthesis
approachthatprunesthesearchspacebyexploitingtheobserva-
tion that Datalog programs in practice comprise rules with similar
latent syntactic structure. To this end, we synergistically combined
threetechniques:anovelapproachtosystematicallygeneratemeta-
rules,takingadvantageofdomainknowledge;anactivelearning
techniquecalledquery-by-committeetominimizethenumberof
examples needed; and a bidirectional synthesis strategy to explore
thesearchspaceefficiently.Weevaluatedthesystemonavariety
of synthesis tasks from different domains and demonstrated that it
significantly outperforms existing state-of-the-arttools.
We envision many useful directions to extend our work. One
directionconcernsrepairingexistingDatalogprogramsusingex-
amples rather than synthesizing them from scratch. For instance, a
user may modify an existing program analysis by refining its rules
tobeconsistentwithknowntrueandfalsepositives.Anotherdi-
rection concerns using probabilistic models to expedite the search,
for instance, by predicting which augmentations to use. Finally,
weplantoexplorehowtosynthesizeprogramsthatarenotonly
correctwithrespectto examples,but alsooptimalwithrespectto
objectives such as likelihoodorevaluation complexity.
A PROOFOF ALPSPROPERTIES
ToproveTheorem 4.2,weusetwokeypropertiesabouttheinter-
playbetween qbcandbidirectionalsearch.Thefollowinglemma
capturesthefactthatthealgorithmdoesnotmissanycontroversial
examples, and thus always makes progress in terms of pruning the
searchspace.
Lemma A.1. LetP⊆Hande∈B. ThenD(e,P)/nequal0iff there
exist programs P1,P2∈Psuchthat P1∪I|=eandP2∪I̸|=e.Proof.Thisisdirectlyimpliedbythedefinitionofvoteentropy
(see Definition 4.1). ■
Thenextlemmastateskeyinvariantsthatholdateveryiteration
ofthealgorithm:( i)Itdoesnotmissanyprogramsthataresolutions
to the synthesis problems, by ensuring that the contours of the
version spaceform anupper/lower boundof every solution. ( ii) It
ensures that if the current version space contains non-solutions,
then there are non-zero entropy examples we can ask the oracle
that can eliminatethem.
LemmaA.2(Invariant). LetS=(H,O,I)beasynthesisproblem
such that a solution to Sexists inH. LetE=(E+,E−)be the set of
known examples at any point during execution, and P=P∪P. Then:
(1)Foreverysolution P′∈HtoS,thereexistprograms Pl,Pu∈P
suchthat Pl⊑P′⊑Pu.
(2)If there exists a program P∈Pthat is not a solution to S, then
∃e∈B.D(e,P)/nequal0.
Proof.Wefirstshowitem(1).First,noticethateverysolution
P′∈HtoSbelongs inthe version space VE,since it satisfies all
current examples. Since P⊇max(VE)(by the definition of F↑in
Algo.1), there exists Pu∈Psuch that P′⊑Pu. Similarly, since
P⊇min(VE),there exists Pl∈Psuch that Pl⊑P′.
We next showitem(2). Supposethat P∈Pis nota solution to S,
andletP′beasolutionto S.Then,thereexistsanexample e∈B
suchthateither(a) P∪I|=eandP′∪I̸|=e,or(b)P∪I̸|=eand
P′∪I|=e.We nowdistinguishtwodifferentcases:
•Case(a)holds:since P′isasolution,item(1)tellsusthatthere
existsPu∈Psuchthat P′⊑Pu.Thisimpliesthat Pu∪I̸|=e.
Becausenow P,Pudisagreeonexample e,LemmaA.1implies
thatD(e,P)/nequal0.
•Case (b) holds: since P′is a solution, item (1) tells us that
there exists Pl∈Psuch that Pl⊑P′.This impliesthat Pl∪
I|=e. Because now P,Pldisagree on example e, LemmaA.1
implies that D(e,P)/nequal0.
Thus,inbothcaseswefindanexample esuchthat D(e,P)/nequal0.■
WearereadytoproveTheorem 4.2usingtheLemmas A.1andA.2.
Proof.Thealgorithmterminateswhenforeveryexample e∈B,
we haveD(e,P)=0. Recall that P=P∪P, whereE=(E+,E−)are
the knownexamples.
•(Soundness) As ∀e∈B.D(e,P)=0, the contrapositive of
item(2)ofLemma A.2indicatesthatevery P∈Pisasolution.
•(Completeness)Thisholdsdirectlyfromitem(1)ofLemma A.2.
•(Termination) At every iteration, the algorithm adds one
exampletoeither E+orE−.Noticethat,afteranexample e
is added to E=(E+,E−), it cannot be added again, since it
willneverbecontroversial( D(e,P)/nequal0)fromthatpointon.
Sincewehavefinitelymanyexamplesin B,thealgorithm
terminatesafter finitelymanysteps.
This concludes the proofof the theorem. ■
ACKNOWLEDGMENTS
We thank the anonymous reviewers for useful feedback. This re-
searchwassupportedbyDARPAunderagreement#FA8750-15-2-
0009 andbyNSF awards#1253867,#1526270,and#1652140.
525ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA X. Si,W.Lee,R. Zhang, A.Albarghouthi,P.Koutris,andM. Naik
REFERENCES
[1] BDD-Based DeductiveDatabase. http://bddbddb.sourceforge.net/ .
[2] Datomic. https://www.datomic.com/ .
[3]IRIS (Integrated Rule Inference System) Reasoner. http://repo.roscidus.com/java/
iris.
[4] LogicBlox. http://www.logicblox.com/ .
[5] Righting Code. http://rightingcode.org/ .
[6] Semmle. https://semmle.com/ .
[7]Serge Abiteboul, Richard Hull, and Victor Vianu. 1995. Foundations of databases .
Addison-Wesley.
[8]AwsAlbarghouthi,SumitGulwani,andZacharyKincaid.2013. RecursivePro-
gram Synthesis.In CAV.
[9]Aws Albarghouthi, Paraschos Koutris, Mayur Naik, and Calvin Smith. [n. d.].
Constraint-Based Synthesis of Datalog Programs. In Principles and Practice of
Constraint Programming - 23rd International Conference, CP 2017, Melbourne, VIC,
Australia,August 28 -September 1, 2017, Proceedings .
[10]R. Alur,R. Bodik,G. Juniwal, M. M. K. Martin, M. Raghothaman, S. A. Seshia,R.
Singh, A. Solar-Lezama, E. Torlak, and A. Udupa. 2013. Syntax-guided synthesis.
In2013Formal MethodsinComputer-AidedDesign .
[11]Peter Alvaro, Neil Conway, Joseph M. Hellerstein, and William R. Marczak. 2011.
ConsistencyAnalysis in Bloom:a CALM and Collected Approach.In CIDR.
[12]Lars Ole Andersen. 1994. Program Analysis and Specialization for the C Program-
ming Language . Technical Report. DIKU, University of Copenhagen. Ph.D.
thesis.
[13]Molham Aref, Balder ten Cate, Todd J. Green, Benny Kimelfeld, Dan Olteanu,
Emir Pasalic, Todd L. Veldhuizen, and Geoffrey Washburn. 2015. Design and
Implementation of the LogicBloxSystem.In SIGMOD.
[14]MichaelArntzeniusandNeelakantanR.Krishnaswami.2016. Datafun:AFunc-
tionalDatalog.In ICFP.
[15]Francesco Bergadano and Daniele Gunetti. 1993. An interactive system to learn
functional logic programs. In Proceedings of the International Joint Conference on
Artificial Intelligence(IJCAI’93) .
[16]PavolBielik,VeselinRaychev,andMartinVechev.2017.LearningaStaticAnalyzer
from Data. In CAV.
[17]Martin Bravenboer and Yannis Smaragdakis. 2009. Strictly declarative specifica-
tionof sophisticated points-toanalyses. OOPSLA(2009), 243ś262.
[18]William W. Cohen. 1995. Pac-Learning Recursive Logic Programs: Negative
Results.Journal ofArtificial IntelligenceResearch 2 (1995).
[19]AndrewCropper,AlirezaTamaddoni-Nezhad,andStephenHMuggleton.2015.
Meta-interpretivelearningofdatatransformationprograms.In Proceedingsof
the 24thInternationalConference onInductiveLogicProgramming .
[20]JacekCzerniakandHubertZarzycki.2003. ArtificialIntelligenceandSecurity
inComputingSystems. ChapterApplicationofRoughSetsinthePresumptive
Diagnosisof UrinarySystemDiseases.
[21]Luc De Raedt and Kristian Kersting. 2008. Probabilistic inductive logic program-
ming. In ProbabilisticInductiveLogicProgramming . Springer, 1ś27.
[22]YuFeng,SaswatAnand,IsilDillig,andAlexAiken.2014. Apposcopy:Semantics-
based Detectionof Android MalwareThroughStatic Analysis. In FSE.
[23]JonathanFrankle,Peter-MichaelOsera,DavidWalker,andSteveZdancewic.2016.
Example-directed synthesis: a type-theoreticinterpretation.In POPL.
[24]Yoav Freund, H. Sebastian Seung, Eli Shamir, and Naftali Tishby. 1997. Selective
SamplingUsingtheQuerybyCommitteeAlgorithm. MachineLearning 28,2-3
(1997).
[25]GeorgGottlob,ChristophKoch,RobertBaumgartner,MarcusHerzog,andSergio
Flesca. 2004. The Lixto Data Extraction Project: Back and Forth Between Theory
and Practice. In PODS.
[26]Sergey Grebenshchikov, Nuno P. Lopes, Corneliu Popeea, and Andrey Ry-
balchenko. 2012. Synthesizingsoftwareverifiers from proof rules.In PLDI.
[27]ToddJ.Green.2015. LogiQL:ADeclarativeLanguageforEnterpriseApplications.
InPODS.
[28]SumitGulwani,WilliamR.Harris,andRishabhSingh.2012. Spreadsheetdata
manipulation using examples. CACM(2012).
[29]Sumit Gulwani, José Hernández-Orallo, Emanuel Kitzelmann, Stephen H. Mug-
gleton, Ute Schmid, and Benjamin Zorn. 2015. Inductive Programming Meets
the RealWorld. Commun. ACM 58,11(Oct.2015).
[30]Daniel Halperin, Victor Teixeira de Almeida, Lee Lee Choo, Shumo Chu,
Paraschos Koutris, Dominik Moritz, Jennifer Ortiz, Vaspol Ruamviboonsuk,
Jingjing Wang, Andrew Whitaker, Shengliang Xu, Magdalena Balazinska, Bill
Howe,and DanSuciu. 2014. Demonstrationof theMyriabigdatamanagement
service. In SIGMOD.
[31] Kryštof Hoder, Nikolaj Bjùrner, and Leonardo De Moura. 2011. µZśan efficient
engine for fixed points with constraints. In CAV.
[32]Susmit Jha, Sumit Gulwani, Sanjit A. Seshia, and Ashish Tiwari. 2010. Oracle-
guided component-based programsynthesis.In ICSE.
[33]RossD.King.2004. Applying InductiveLogicProgrammingto PredictingGene
Function. AI Magazine 25,1 (March2004).[34]EmanuelKitzelmannandUteSchmid.2006. InductiveSynthesisofFunctional
Programs:AnExplanation Based Generalization Approach. JMLR(2006).
[35]Etienne Kneuss,Ivan Kuraj,ViktorKuncak,andPhilippeSuter.2013. Synthesis
modulo recursivefunctions. In OOPSLA.
[36]TessaALau,PedroMDomingos,andDanielSWeld.2000. VersionSpaceAlgebra
and its Applicationto Programmingby Demonstration.. In ICML. 527ś534.
[37]Alan Leung, John Sarracino, and Sorin Lerner. 2015. Interactive parser synthesis
by example. In PLDI.
[38]Dianhuan Lin, Eyal Dechter, Kevin Ellis, Joshua B. Tenenbaum, and Stephen
Muggleton.2014. Biasreformulation for one-shot function induction. In ECAI.
[39]Boon Thau Loo, Tyson Condie, Minos Garofalakis, David E. Gay, Joseph M.
Hellerstein, Petros Maniatis, Raghu Ramakrishnan, Timothy Roscoe, and Ion
Stoica. 2009. DeclarativeNetworking. Commun. ACM 52,11(Nov. 2009).
[40]MagnusMadsen,Ming-HoYee,andOndřejLhoták.2016. FromDatalogtoFlix:
ADeclarativeLanguage for Fixed PointsonLattices.In PLDI.
[41]Ravi Mangal, Xin Zhang, Aditya V. Nori,and MayurNaik. 2015. A User-guided
Approach to ProgramAnalysis. In FSE.
[42]AnaMilanova,AtanasRountev,andBarbaraG.Ryder.2002.ParameterizedObject
SensitivityforPoints-toandSide-effectAnalysesforJava.In Proceedingsofthe
2002ACMSIGSOFTInternationalSymposiumonSoftwareTestingand Analysis .
[43]TomMMitchell.1982. Generalizationassearch. Artificialintelligence 18,2(1982),
203ś226.
[44]Raymond J.Mooney. 1996. Inductive Logic Programming for Natural Language
Processing. In Inductive Logic Programming: Selected papers from the 6th Interna-
tional Workshop . SpringerVerlag.
[45]StephenMuggleton.1991. Inductivelogicprogramming. Newgenerationcomput-
ing8,4 (1991).
[46]StephenMuggleton.1995. InverseentailmentandProgol. Newgenerationcom-
puting13,3-4 (1995).
[47]Stephen Muggleton. 1999. Scientific knowledge discovery using inductive logic
programming. Commun. ACM 42,11(1999), 42ś46.
[48]StephenMuggletonandWrayL.Buntine.1988. MachineInventionofFirst-order
Predicates by Inverting Resolution. In Proceedings of the International Conference
onMachineLearning (ICML’88) .
[49]Stephen Muggleton, Luc De Raedt, David Poole, Ivan Bratko, Peter A. Flach,
KatsumiInoue,andAshwinSrinivasan.2012. ILPturns20-Biographyandfuture
challenges. ML(2012).
[50]Stephen H Muggleton, Dianhuan Lin, and Alireza Tamaddoni-Nezhad. 2015.
Meta-interpretivelearning ofhigher-orderdyadicdatalog:Predicate invention
revisited. MachineLearning 100, 1 (2015).
[51]Mayur Naik. Chord: A Program Analysis Platform for Java. http://jchord.
googlecode.com/ .
[52]Hakjoo Oh, Hongseok Yang, and Kwangkeun Yi. 2015. Learning a Strategy
for Adapting aProgram Analysis via BayesianOptimisation. In OOPSLA. ACM,
572ś588.
[53]Peter-Michael Osera and Steve Zdancewic. 2015. Type-and-example-directed
programsynthesis.In PLDI.
[54]GordonDPlotkin.1970. Anoteoninductivegeneralization. Machineintelligence
5,1 (1970).
[55]Nadia Polikarpova, Ivan Kuraj, and Armando Solar-Lezama. 2016. Program
synthesis from polymorphicrefinement types. In PLDI. ACM,522ś538.
[56]DavidPoole.1995. LogicProgrammingforRobotControl.In Proceedingsofthe
InternationalJoint Conference onArtificial Intelligence(IJCAI’95) .
[57]Mukund Raghothaman, SulekhaKulkarni,KihongHeo, and MayurNaik. 2018.
[58]JCA Santos, H Nassif, D Page, SH Muggleton, and MJE Sternberg. 2012. Auto-
mated identification of protein-ligand interaction features using Inductive Logic
Programming:ahexose binding case study. BMCBIOINFORMATICS 13(2012).
[59]BernhardScholz,HerbertJordan,PavleSubotić,andTillWestmann.2016. OnFast
Large-scale Program Analysis in Datalog. In Proceedings of the 25th International
Conference onCompiler Construction (CC 2016) .
[60]Jiwon Seo, Stephen Guo, and Monica S Lam. 2013. SociaLite: Datalog extensions
for efficient socialnetworkanalysis. In ICDE.
[61]Burr Settles. 2012. Active learning. Synthesis Lectures on Artificial Intelligence
and MachineLearning 6,1 (2012), 1ś114.
[62]H.S.Seung,M.Opper,andH.Sompolinsky.1992.QuerybyCommittee.In Proceed-
ingsofthe 5thAnnual Workshop onComputationalLearning Theory(COLT’92) .
[63]AlexanderShkapsky,MohanYang,MatteoInterlandi,HsuanChiu,TysonCondie,
and CarloZaniolo.2016. BigData Analytics withDatalogQueriesonSpark. In
SIGMOD.
[64]RishabhSingh,SumitGulwani,andArmandoSolar-Lezama.2013. Automated
feedback generationfor introductoryprogrammingassignments.In PLDI.
[65]Y. Smaragdakis and M. Bravenboer. 2010. Using Datalog for Fast and Easy
ProgramAnalysis. In Datalog 2.0Workshop .
[66]Yannis Smaragdakis, Martin Bravenboer, and Ondrej Lhoták. 2011. Pick Your
ContextsWell:UnderstandingObject-sensitivity. In POPL.
[67]Armando Solar-Lezama, Liviu Tancau, Rastislav Bodík, Sanjit A. Seshia, and
VijayA.Saraswat.2006. Combinatorialsketchingforfiniteprograms.In ASPLOS.
526Syntax-GuidedSynthesis ofDatalogPrograms ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA
[68]SaurabhSrivastava, SumitGulwani, and Jeffrey S.Foster.2013. Template-based
programverificationand programsynthesis. STTT(2013).
[69]ChenglongWang,AlvinCheung,andRastislavBodik.2017. SynthesizingHighly
ExpressiveSQL Queriesfrom Input-output Examples.In PLDI.
[70]J. Whaley and M. Lam. 2004. Cloning-based context-sensitive pointer alias
analysis using binarydecisiondiagrams.In PLDI.
[71]YangWu,AngChen,AndreasHaeberlen,WenchaoZhou,andBoonThauLoo.
2017. Automated BugRemovalfor Software-Defined Networks.In NSDI.[72]Insu Yun, Changwoo Min, Xujie Si, Yeongjin Jang, Taesoo Kim, and Mayur
Naik. 2016. APISan: Sanitizing API Usages through Semantic Cross-checking. In
Proceedingsofthe USENIXSecuritySymposium .
[73]XinZhang, RaduGrigore, XujieSi,and Mayur Naik. 2017. EffectiveInteractive
Resolution of Static Analysis Alarms.In OOPSLA.
[74]Xin Zhang, Ravi Mangal, Radu Grigore, Mayur Naik, and Hongseok Yang. 2014.
OnAbstraction Refinementfor ProgramAnalysesin Datalog.In PLDI.
527