TDroid: Exposing App Switching Attacks in Android with
Control Flow Specialization
Jie Liu
UNSW Sydney, Australia
jieliu@cse.unsw.edu.auDiyu Wu
UNSW Sydney, Australia
diyuwu@cse.unsw.edu.auJingling Xue
UNSW Sydney, Australia
jingling@cse.unsw.edu.au
ABSTRACT
The Android multitasking mechanism can be plagued with app
switching attacks, in which a malicious app replaces the legitimate
top activity of the focused app with one of its own, thus mounting,
e.g., phishingand denial-of-serviceattacks. Existingmarket-level
defenses are still ineffective, as static analysis is fundamentally
unabletoreasonabouttheintentionofanappanddynamicanalysis
has low coverage.
WeintroduceTDroid,anewmarket-levelapproachtodetect-
ing app switching attacks. The challenge lies in how to handle a
plethoraofinput-dependentbranchpredicates(forminganexpo-
nential number of paths) that control the execution of the code
responsibleforlaunchingsuchattacks.TDroidtacklesthischal-
lenge by combining static and dynamic analysis to analyze an app
withoutproducinganyfalsepositives.Initsstaticanalysis,TDroid
transforms the app into runnable slices containing potentially app
switching attacks, one slice per attack. In its dynamic analysis,
TDroid executes these slices on an Android phone or emulator to
exposetheirmaliciousGUIs.Thenoveltyliesintheuseofanew
trigger-orientedslicing techniquein producingrunnable slicesso
thatcertaininput-dependentbranchpredicatesarespecializedto
execute always some fixed branches.
Evaluated with a large set of malware apps, TDroid is shown
to outperformthe state ofthe art,by detecting substantiallymoreapp switching attacks, in a few minutes per app, on average.
CCS CONCEPTS
•Securityandprivacy →Softwareandapplicationsecurity ;
KEYWORDS
Android GUI Security, Static Analysis, Dynamic Analysis
ACM Reference Format:
Jie Liu, Diyu Wu, and Jingling Xue. 2018. TDroid: Exposing App Switching
Attacks in Android with Control Flow Specialization. In Proceedings of
the 2018 33rd ACM/IEEE International Conference on Automated Software
Engineering(ASE’18),September3–7,2018,Montpellier,France. ACM,New
York, NY, USA, 12pages.https://doi.org/10.1145/3238147.3238188
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,
topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ’18, September 3–7, 2018, Montpellier, France
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.32381881 INTRODUCTION
The Android multitasking mechanism has been plagued by se-
veresecurity risks[ 2].Weintroduceanew programanalysistool,
TDroid, deployable at the market level for detecting app switching
attacks[8] (before they hit the users). In such an attack, a mali-
cious app can replace the legitimate top activity of the focused app
withoneofitsown(openedbytypicallycalling startActivity() ),
thereby mounting, e.g., phishing and denial-of-service attacks.
Challenge. Consideramalwareappthatrunsinthebackground,
keepingtrackofthedevicestatus.Oncethedevicehasreacheda
specificstate,determinedbyan input-dependentbranchpredicate
involvingsomeenvironmentvariables,themalwarewillexecute
somemaliciouscodeforlaunchinganappswitchingattack.Such
attacks can be launched without requiring any permissions, for all
appsinstalledonacompromiseddeviceunderallAndroidversions.
The challenge lies in how to handle a plethora of input-dependent
branchpredicates(forminganexponentialnumberofpaths)that
control the execution of the code responsible for launching such
attacks.State of the Art.
To mitigate app switching attacks (as a special
caseofGUIattacks),severalon-devicedefenseshavebeenproposed,including[
8,14,57](byaddingasecurityindicatorshowingtheapp
identity being interacted with) and [ 41] (by raising an alert dialog,
deployableonlyinrooteddevices).Accordingto[ 52],however,such
passivedefensesareonlymarginallyeffective,yetattheexpense
of negatively impacting system performance and user experience.
To prevent app switching attacks, market-level defenses, which
canbeusedduringthevettingprocess,arepreferred.Staticanalysis,
dynamic analysis, and their hybrids have all been tried, but with
onlylimitedsuccessinhandlinginput-dependentbranchpredicates.
For static analysis, we are only aware of [ 8], which can detect
appswitchingattacks.Theirtool,referredtohereasStaDef,scansanappforthecodeforobtainingtheinformationaboutthefocused
appandthecodeforstartinganewactivity.Iftheformerreaches
the latter, then the app is flagged as suspicious. As a static analysis,
StaDef can only report warnings about possible app switching
attacksinasuspiciousapp,whosecodemuststillbeinspectedbya
human before any final decision can be made.
Fordynamicanalysis,general-purposeGUItestingtools,suchas
Google’s Monkey[15] (randomized),Sapienz (search-based) [37],
andStoat[ 47](model-based)canalsobeusedfordetectingapp
switching attacks (with malicious GUIs visually inspected and con-
firmed by a human analyst). However, these tools have low cov-
erage,asevaluatedinSection 6,asmanyinput-dependentbranch
predicates guiding malicious code may become true only after GUI
testing (e.g., when a targeted victim app is subsequently installed).
Static and dynamic analysis can be used together. Fuz-
zDroid [40], which combines symbolic-execution-enhanced static
236
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Jie Liu, Diyu Wu, and Jingling Xue
analysis and dynamic fuzzing to expose the malicious behaviors in
an app, can be used for detecting app switching attacks. However,
its symbolic execution mechanism cannot generate the test inputs
required to satisfy all the input-dependent branch predicates for
two reasons. First, all such predicates form an exponential number
of paths to be explored. Second, its fuzzing technique only models
some simple APIs, but a malware app can, for example, inspect the
devicestatusbyusingmanydifferentAPIs.Thus,thechancesfor
reaching some malicious code are still low (as evaluated later).
Our Solution. We present TDroid, a market-level approach
that combines static and dynamic analysis to detect app switch-ing attacks. In its static analysis, TDroid identifies suspicious
startActivity() callsleadingtosuchattacksinanappandtrans-
formstheappintoanumberofrunnableslicescontainingpoten-
tially app switching attacks, one slice per attack. In its dynamic
analysis,TDroidsimplyexecutestheserunnableslicesonanAn-
droid device or emulator to expose the malicious calls hidden in
theseslices.Ahumananalystwillflagacall(andtheunderlying
app) as malicious if its exposed UI (screenshot) is malicious (as
discussed in Section 3). Therefore, no false positives are produced.
The key novelty of TDroid lies in its use of a new trigger-
orientedslicingtechniqueforbuildingrunnableslicesthatallow
app switching attacks to be exposed. Traditional slicing [ 22,54],
which reasons about data and control dependences, does not apply,
since all the input-dependent branch predicates that guide some
maliciouscodecannotbeslicedaway.Incontrast,TDroidwillspe-
cialize such predicatesso that the guided maliciouscode is forced
to be always executed.
We have evaluated TDroid with a set of 3814 malware apps
labeled with “Bank”, “Ransom” or “Fraud” in the Android Mal-
ware Dataset [ 53]. These apps do not have the ground truth
about app switching attacks. Statically, TDroid finds 3075 suspi-
cious startActivity() callsin1062suspiciousapps.Dynamically,
TDroidexposesUIsin978outof1062apps,with878appscontain-
ing app switching attacks, confirmed by a human analyst. TDroid
is fast, by spending an average of 160.5 seconds per app for the
1062 apps that are both statically and dynamically analyzed.
TDroidoutperformsthestateoftheartsubstantially.Asastatic
analysis tool for finding app switching attacks, StaDef [ 8]r e -
portsonly1642suspicious startActivity() callsin770suspicious
apps (also reported by TDroid), with 63 suspicious calls missedby TDroid. Note that such pure static error reports are not use-
ful unless a human analyst actually reads the code of these 770
apps. In addition, we have also compared TDroid with four repre-
sentative general-purpose analysis tools, which can also be used
fordetectingappswitchingattacks,using20malwareapps(withonefromeachdistinctmalwarefamily),containing58suspicious
startActivity() calls identified by TDroid. Given a budget of
3hoursperapp,Google’sMonkey[ 15],Sapienz[ 37],Stoat[ 47]
and FuzzDroid [ 40] have achieved their recall rates (percentage
hitratesforthesecalls)as8.62%,10.34%,12.07%and18.97%,respec-
tively. In contrast, TDroid’s recall rate is 94.83%.
We have also evaluated TDroid using a set of goodware apps to
confirm its effectiveness as a market-level tool.
In summary, this paper makes the following contributions (with
theartifactforreproducingallourresultsdownloadableat https:
//tdroidtool.github.io/):•anovelmarket-levelsecuritydefense,TDroid,fordefeating
app switching attacks via a hybrid analysis;
•a new trigger-oriented slicing technique for constructing
runnable slices containing app switching attacks; and
•adynamicanalysisforexecutingrunnableslicesonAndroid
devices or emulators to expose malicious GUIs.
2 BACKGROUND
2.1 Android Components
Androidappsareconstructedfromfourtypesof components, Ac-
tivity(a window containing UI components), Service(an operation
running in the background), Broadcast Receiver (a listener respond-
ing to a system or app announcement), and Content Provider (a
component managinga setof datashared with otherapps). Three
ofthefourcomponenttypes,Activity,Service,andBroadcastRe-
ceiver, are activated by an asynchronous message called an intent.
Activity lies at the heart of the Android programming frame-
work due to its event-driven nature. An activity acts as a container
consisting of different GUI elements (e.g., views and text boxes),
through which, users interact with an app for transitions between
differentactivities.Conceptually,anappexecutesalongtheactivity
transition paths and other callbacks are sprawled out of them.
2.2 App Switching Attacks
Suchattacksaimtostealthefocusofthetop,i.e.,foregroundapp[ 8].
Thisisachievedwhenamaliciousappreplacesthelegitimatetop
activitywithoneofitsown.Appswitchingattackscanbeexploited
for different purposes. As a UI spoofing attack (discussed in Sec-
tion3), a malware app waits until a specific victim app has been
installed and then triggers an app switch with a fake UI requesting
software update in order to lure users to download another mal-
ware app (e.g., a malicious version mimicking the victim app). As a
denial-of-service attack, a malware app continuously monitors the
device status to ensure that it is the top app and triggers an app
switch otherwise, possibly until a ransom has been paid.
2.3 Intermediate Representation (IR)
Given an app, TDroid works on its Jimple IR, a three-address byte-
code IR,constructed by Soot [ 51]. Thefollowing types of control
flow statements exist: (1) jumps, including goto, return, and throw
(treated as return), (2) two-way branches for if statements, and (3)
switches, i.e., multi-way branches (which are not desugared into
two-wayifstatements).TheCFG(ControlFlowGraph)ofamethod
is constructed in the standard way, except for its explicit represen-
tation of jump statements and switch statements. For convenience,
a basic block in a CFG consists of one single statement.
Lets1ands2be two statements in the CFG of a method. We
write s1→ds2ifs2is data-dependent on s1ands1→cs2ifs2is
control-dependent on s1.
3 MOTIVATING EXAMPLE
Figure1shows an example abstracted from Bankun[55], one of
the most widespread malware families [ 1].Bankunmasquerades
as Google Play. Once executed, it checks to see if the device has
installedanyofthefivemajor,legitimateKoreanbankingapps.If
237
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. TDroid: Exposing App Switching Attacks in Android with Control Flow Specialization ASE ’18, September 3–7, 2018, Montpellier, France
1public class Notifications extends Service {
2public void onCreate() {
3 super.onCreate();
4 checkStatus();}
5private void checkStatus() {
6 int bk_type = -1;
7 String pack_name = "";
8 for (int j = 0; j < Config.BKLIST.length; j++)
9 if(getInstalledPkgNames().contains(Config. BKLIST[j])){
10 bk_type = j;
11 pack_name = Config.BKLIST[j];
12 }
13 Intent bkMain = new Intent(this, BKMain.class);
14 bkMain.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
15 bkMain.putExtra( "PKGN", pack_name);
16 if(bk_type == 0){
17 bkMain.putExtra( "BK", "0");
18 startActivity(bkMain);
19 }
20 ...
21 else if (bk_type == 4){
22 bkMain.putExtra( "BK", "4");
23 startActivity(bkMain);
24 }
25 }}
26public class BKMain extends Activity {
27 protected void onCreate(Bundle savedInstanceState) {
28 super.onCreate(savedInstanceState);
29 Intent bkIntent = getIntent();
30 if(bkIntent != null){
31 Logger.i( "uninstall" , bkIntent.getStringExtra( "PKGN"));
32 switch (bkIntent.getStringExtra( "BK")) {
33 case "0": setContentView(R.layout.kb_main_activity);
34 return;
35 ...
36 case "4": setContentView(R.layout.sh_main_activity);
37 return;
38 }
39 }}}
Figure 1: The malware app Bankun.
New version released. 
Please reinstall.
ConfirmNotification
New version released. 
Please reinstall.
ConfirmNotification
KB Kookmin Bank
Figure 2: Bankun’s fake UI for software update (bk_type=0).
aparticularbankingappisinstalled, Bankunwillperformanapp
switching attack to display a fake UI requesting software update
to lure users to download a rogue version of the same banking
app. In addition, Bankunalso steals SMS messages, contacts and
device information from the compromised devices. Without loss of
generality, the code for attacking two banking apps (identified as 0
and 4) is given but the code for the other three (identified as 1 – 3)
is similar and thus elided (lines 20 and 35).
The Service, named Notifications (lines 1 – 25), monitors the
device in the background. In lines 8 – 12, the device is checked
foraninstalledbankingappin Config.BKLIST ,withthelastone
selected as the victim (recorded in bk_type andpack_name ). In
lines13–25, startActivity() iscalledtostartanactivityoftype
BKMainwith a fake UI requesting software update for the victim.
Thebranchpredicateinline16(line21)isinput-dependent,guidingthemaliciouscodeinlines17–18(lines22–23).Inlines32–38,
the activity BKMaindraws a fake UI for the victim targeted, with
different UIs for different banking apps. Figure 2shows the fake
UIforthebankingapp(identifiedas0),requestinganewerbuta
rogue version to be downloaded.
3.1 Existing Approaches
The market-level solutions [ 8,15,37,40,47], reviewed in Section 1
andevaluatedinSection 6,areineffectiveforvetting Bankun.With
purestaticanalysis,StaDef[ 8]cannotdetectappswitchingattacks
inBankun,sincetherearethe startActivity() callsformaking
anappswitch(lines18and23)butnotanycodeforcheckingthe
focused app. Even if Bankunis flagged as suspicious, a human
analyst must still read the code to know why it is malicious.
With pure dynamic analysis, Google’s Monkey [ 15],
Sapienz [ 37], and Stoat [ 47] will always fail if no targeted
banking app in Config.BKLIST is installed yet during testing (in
which case, by_type = -1 always). Evenif somebanking apps in
Config.BKLIST areinstalled,thesetoolswillstillfailinexposing
the malicious UIs in BankunifcheckStatus() is never triggered.
By combining symbolic-execution-enhanced static analysis and
dynamic fuzzing, FuzzDroid [ 40] has achieved an improved cover-
age but will still be ineffective for Bankun. As the input-dependent
branchpredicateinline9cannotbemodeledaccurately, by_type
=- 1is expected. Thus, no startActivity() call can be triggered.
3.2 The TDroid Approach
Figure3gives an overview of TDroid. Given an APK file, TDroid
first performs a static “Pre-Analysis” to look for all suspicious
startActivity() calls that may lead to app switching attacks.
Wefocuson startActivity() sinceitisthemostwidelyusedAPI
forstartinganactivityingoodwareandmalware[ 8].However,our
approach can be generalized to handle other activity-starting APIs.
TDroid then handles each suspicious startActivity() call
separately. TDroid first constructs its runnable slices in “Static
Backward Slicing" and then executes these slices in “Dynamic Exe-
cution"toexposethemalicious startActivity() call(byexposing
malicious UIs). As malicious activities of different class types may
be started at the same startActivity() call, different slices as
highlighted may be generated, one per malicious activity.
Wewillfocusonthesuspiciouscallinline18,identifiedas I18.
The others in lines 20 and 23 are handled similarly.
3.2.1 Pre-Analysis. The objective is to identify all suspicious
startActivity() calls that may lead to app switching attacks.
AstartActivity() call in an app is suspicious if it satisfies two
conditions (Section 4): (1) the app is currently running in the back-
groundand(2)thecall startActivity() maycausethelegitimate
top activity to be replaced by one of his own activities.
ForI18,Bankun is activated by a call to
Notifications.onCreate() (lines 2 – 4), a non-user-driven
callback. Thus, I18can be triggered when Bankunruns in the
background.Thenanactivityoftype BKMaincanbeopened.Based
on the attribute of the intent object (line 14), bkMain, passed to I18
(Table1), the opened activity can be the top activity. Thus, I18is a
suspicious call.
238
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Jie Liu, Diyu Wu, and Jingling Xue
Static Backward Slicing 
Trigger-Oriented 
SlicingControl Flow 
SpecializationSlice 1
Slice N….Slice 1
Slice N….Runnable 
Slice 1
Runnable 
Slice N….Runnable 
Slice 1
Runnable 
Slice N….
Static Backward Slicing 
Trigger-Oriented 
Slicing
Control Flow 
Specialization
Slice 1
Slice N….
Runnable 
Slice 1
Runnable 
Slice N….
Dynamic Execution
Repackaging
Downsized
APK
Execution
(Mobile/Emulator)
Screenshots of 
Malicious UIsSuspicious 
startActivity() Calls
APK
APK
Pre-Analysis
Conditions for App 
Switching Attacks 
APK
s
Pre
-
Analys is
 Pre-Analysis
Conditions for A pp 
Switching Attack s 
Conditions for App 
Switching Attacks 
Figure 3: A schematic overview of the components in TDroid.
3.2.2 Static Backward Slicing. For each suspicious
startActivity() call, we first apply a novel trigger-oriented
slicing technique to generate backward slices with specializable
branchpredicatesforthecall.Werelyonthefollowinginsightto
identify heuristically specializable branch predicates.
Property 1. LetSbe a backward slice computed for a method
m. Let pbe a branch predicate in m.I fpcontrols only one single
non-empty execution path in S, such that pdoes not read the same
memoryaddressthatisalsoreadalongthepath,then pisspecializable
to always execute that path only.
We then apply a new control flow specialization technique to
both(1)addthemissingcontrol-flowstatements(includingjump
statements) in the methods contained in these slices and (2) spe-
cialize the specializable and missing branch predicates thus added.
TDroid is simple and efficient (in terms of generating and running
the slices thus obtained as evaluated later).
GivenI18, we compute some backward slices affecting I18. The
class type for its associated activity is BKMain(lines 26 – 39). So
only one slice will be generated. We start with the slicing criterion
SCBKMain(I18)={18 ,33 ,36}, i.e., the three statements identified
by their line numbers. In addition to line 18, we have also included
lines33and36sincethesearewherethemaliciousUIsaredrawn
inthecallbackmethod, BKMain.onCreate() ,triggeredatline18,
despite the fact that lines 33 and 36 appear lexically after line 18.
(1) Trigger-Oriented Slicing. Traditionally [ 22,54], the back-
wardslicecomputedfor SCBKMain(I18)consistsoflines6,8–10,
13,16–18,29,30,32,33,36.Thus,theinput-dependentpredicatein
line16isincluded.Asdiscussedearlier,applyingaGUItestingtool
to such a slice will hardly expose the hidden malicious behaviors.
Tocompute thebackwardslice for SCBKMain(I18)={18,33,36},
TDroidproceedssimilarlyastraditionally,exceptthatcertaininput-
dependent branch predicates are flagged as specializable (Prop-
erty1).Notethatapredicatethatisinitiallyspecializablecanbe-
come non-specializable as the slice grows. For I18,bk_type == 0
inline16willbespecializedwithaBooleanconstanttoensurethat
I18is always triggered. As a result, all the statements affecting the
definitions of bk_type are no longer in the slice. Trigger-oriented
slicinghastwobenefits.First,itislightweight,costing22.2seconds
perappinourevaluation.Second,itimprovesthecodecoverage
of a subsequent dynamic analysis.
Let us see how TDroid computes the slice from
SCBKMain(I18)={18 ,33 ,36}, with the initial slice being
TBKMain(I18)=SCBKMain(I18). At this stage, no branch predicates
arespecializableyet.Letusstartfromlines33and36.As 32→c33and32→c36,line32isaddedto TBKMain(I18).Aslines33and36
are in two different branches controlled by line 32, Property 1is
violated. So line 32 is not specializable. As 30→c32, line 30 is
added to TBKMain(I18). Line 30 is not specializable by Property 1,
as the variable bkIntent used in line 30 is also used in line 32.
Letusnowstartfromline18.As 17→d32isadatadependence
(through the intent object associated with I18), line 17 is simply
addedtoTBKMain(I18).As16→c17and16→c18,line16isadded
toTBKMain(I18).N o w ,TBKMain(I18)={16,17,18,30,32,33,36}.B y
Property 1,line16isflaggedasspecializablesinceitdoesnotuse
anyvariablealsousedinthesinglepath(lines17and18),controlled
byline16,in TBKMain(I18).Notethatthestatementsthatdefinethe
values used at specializable predicates are ignored.
Finally,13→d17,13→d18,29→d30, and29→d32.S ow e
obtainTBKMain(I18)={13,16,17,18,29,30,32,33,36}, with line 16
as the only predicate flagged as specializable.
Notifications.checkStatus:
8 label1: if true goto  label3;
9         if true goto label2;
12 label2: goto label1;
13 label3: Intent bkMain = new Intent( this, BKMain. class);
16         if false goto label4;
17         bkMain.putExtra( "BK", "0");
18         startActivity(bkMain);
19         return;
21 label4: if true goto label5;
24 label5: return;
BKMain.onCreate:
29  Intent bkIntent = getIntent();
30  if bkIntent == null goto label1;
32        switch(bkIntent.getStringExtra( "BK")){
33        case "0": setContentView(R.layout.kb_main_activity);
34         return;
36         case "4": setContentView(R.layout.sh_main_activity);
37         return;
38         default: goto label1;};
39 label1: return;13 label3: Intent bkMain = new Intent( this, BKMain. class);
16         if false goto label4;
17         bkMain.putExtra( "BK", "0");
18         this.startActivity(bkMain);
29   Intent bkIntent = getIntent();
30      if bkIntent == null goto label1;
32  switch(bkIntent.getStringExtra( "BK")){
33    case "0" : setContentView(R.layout.kb_main_activity);
36     case "4": setContentView(R.layout.sh_main_activity);16
Figure 4: The (simplified) slice for I18in Soot’s Jimple
IR after control flow specialization. The statements in
TBKMain(I18)are highlighted in with line 16 marked in .
The statements in TBKMain(I18)\TBKMain(I18)appear in the
white background.
(2) Control Flow Specialization. Figure4displays the slice
TBKMain(I18)in Soot’s Jimple IR, consisting of the statements high-
lightedinthered background( ).The branchpredicate inline 16
() has been specialized so that line 18 is always triggered. This
slice is not yet runnable, as some jump statements for ensuring its
correct execution are missing.
Instead of complex algorithms for adding missing jumps [ 3,26],
TDroidadoptsasimpleyeteffectiveapproach.Foreverymethod
239
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. TDroid: Exposing App Switching Attacks in Android with Control Flow Specialization ASE ’18, September 3–7, 2018, Montpellier, France
minTBKMain(I18), there are two steps. First, we add all missing
control-flowstatements in mtoTBKMain(I18)toobtain arunnable
slice:TBKMain(I18)={8,9,12,13,16−19,21,24,29,30,32−34,36−
39}.InFigure 4,theaddedstatementsin TBKMain(I18)\TBKMain(I18)
appearinthewhitebackground.Second,thenewlyaddedbranch
predicates in lines 8, 9 and 21 are specialized to execute some fixed
branches(Section 5.3).Forline8(correspondingtoaloop),theloop
body is always skipped. For each if statement in lines 9 and 21,
either branch can be specialized as being taken.
Notifications.checkStatus:
8 label1: if true goto  label3;
9         if true goto label2;
12 label2: goto label1;
13 label3: Intent bkMain = new Intent( this, BKMain. class);
16         if false goto label4;
17         bkMain.putExtra( "BK", "0");
18         startActivity(bkMain);19         return;
21 label4: if true goto label5;
24 label5: return;
BKMain.onCreate:
29   Intent bkIntent = getIntent();
30         if bkIntent == null goto label1;
32        switch(bkIntent.getStringExtra( "BK")){
33       case "0": setContentView(R.layout.kb_main_activity);
34      return;
36     case "4": setContentView(R.layout.sh_main_activity);
37       return;
38      default: goto label1;};
39 label1: return;13 label3: Intent bkMain = new Intent(MainActivity .ctx, BKMain. class);
16         if false goto label4;
17         bkMain.putExtra( "BK", "0");
29         Intent bkIntent = getIntent();
30       if bkIntent == null goto label1;
32      switch(bkIntent.getStringExtra( "BK")){
33      case "0": setContentView(R.layout.kb_main_activity);
36      case "4": setContentView(R.layout.sh_main_activity);16L1  bkMain.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
L2  super.onCreate(savedInstanceState);
L3  ReachReport.reportTargetReached();18         MainActivity .ctx.startActivity(bkMain);MainActivity .ctx
MainActivity .ctx
Figure 5: A repackaged version of Figure 4with all the
changes shown in the blue background ( ).
3.2.3 Dynamic Execution. Werepackage TBKMain(I18)toadown-
sized APK file to expose its malicious UI by dynamic execution.
1 public class MainActivity extends Activity {
2public static  Context ctx;
3protected  void onCreate(Bundle bundle) {
4super.onCreate(bundle);
5ctx = getApplicationContext();
6new Notifications().checkStatus();
7} }
Figure6:ThelauncheractivityofthedownsizedAPKfor I18.
(1) Repackaging. In Figure 4,checkStatus() is the entry
method to activate I18. We make use of the launcher activity
in Figure 6to call checkStatus() (even if it is non-public) on
aNotifications object created ourselves (rather than by the An-
droid framework). Thus, in lines 13 and 18 of Figure 4,this(of
type Notifications ) can no longer be used as a context object.
Rather, as shown in the repackaged version in Figure 5, a con-
textobjectoftype Contextthatismadeavailableinastaticfield
MainActivity.ctx is used instead. L1is added to force an app
switch, since this is possible originally (Section 3.2.1).
As the Android framework is not modeled accurately during
the slicing, some data and control dependences related to callbacks
are missing. L2, as the super call in BKMain.onCreate() , is added.
Finally, L3is added so that screenshots are taken and analyzed.
(2) Execution. We install the downsized APK for I18on an
unmodified Android phone or emulator and then execute it to
exposethemaliciousUIinFigure 2.Similarly,themaliciousUIsfor
the other four banking apps can also be exposed.4 APP SWITCHING ATTACK
AstartActivity() call issuspicious (in opening a top activity) if
itsatisfiestwoconditions:(1)theappcanruninthebackground,
and(2)theappcanreplacethelegitimatetopactivitywithoneof
its own (to therefore steal the focus to become the focused app).
4.1 Background Running Apps
Fora startActivity() call,itscontainingappcanrunintheback-
groundifthecallcanbeactivatedbyanon-user-drivencallback.
User-drivencallbacks manageuserinteractions[ 56],including(1)
lifecycle callbacks for activities and UI components (e.g., dialogs
and menus), defining some changes to their visible state, run-time
eventsandbehaviors,and(2)GUIeventhandlercallbacks,respond-
ingtouseractions(e.g.,clickingabutton). Non-user-drivencallbacks
requirenodirectuserinteractions,includingthelifecyclecallbacks
forservices(e.g., Service.onCreate() ),broadcastreceivers(e.g.,
BroadcastRecevier.onReceive() ), and content providers (e.g.,
ContentProvider.onCreate()).
BankuninFigure 1canbeactivatedtoruninthebackgroundby
the non-user-drive callback Notifications.onCreate() (line 2).
4.2 App Switching
An activity that is opened at a startActivity() can become a
topactivity,determinedbythreefactorsreportedin[ 8]:theclass
type of the Android component from which the call is made, the
launchMode attribute for the opened activity, and the flags set for
itsassociatedintentobject.Inthispaper,wefindthatafourthinflu-
encing factor, the taskAffinity attribute of the opened activity,
is also relevant.
Table1:TheninescenarioswherestartActivity()canopena
top activity (where ∗, as usual, means don’t-care).
Receiver Type
of startActivity()launchMode taskAffinityIntent Flags
(FLAG_ACTIVITY_*)
Non-Activity ∗ ∗ NEW_TASK
Activity ∗ ∗ NEW_TASK & CLEAR_TASK
Activity singleTop ∗ NEW_TASK & MULTIPLE_TASK
Activity standard ∗ NEW_TASK & MULTIPLE_TASK
Activity singleTask ∗ CLEAR_TASK
Activity singleInstance ∗ ∗
Activity singleTop Non-default NEW_TASK
Activity standard Non-default NEW_TASK
Activity singleTask Non-default ∗
As Android’s official documentation does not state clearly when
an opened Activity can become a top one, we have developed a
tool, as in [ 8], to explore all possible combinations of the four
factors.WerestrictourselvestoAndroid4.4,oneofthemostwidelydistributedversions.However,thebasicprinciplebehindappliestootherversions.Table 1givesatotalofninescenariosforanactivity
to become the top one, with the last three being new.
Considerthe startActivity() callI18inFigure 1thatisexam-
ined in Section 3. The class type of the receiver object on which
startActivity() iscalledisa Notifications Service.Inaddition,
its associated intent bkMainis set with the flag NEW_TASK . Thus,
I18is suspicious(falling into the first casein Table 1), regardless of
the class type of any activity that may be opened.
240
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Jie Liu, Diyu Wu, and Jingling Xue
5 THE TDROID DESIGN
We describe our algorithms for realizing the five components in
TDroid (depicted in Figure 3). Given an app, TDroid works on its
JimpleIR(Section 2),bytakingasinput(1)thecallgraph CGforthe
app, (2) the CFGs of its methods, (3) data and control dependences,
and(4) thealias information(in CG).In Section 6, wewillexplain
how (1) – (4) are obtained in our implementation.
Given an app, “Pre-Analysis” is first performed to find all the
suspicious startActivity() callsinCG.Foreachsuspiciouscall I,
our static analysis comes into play first. “Trigger-Oriented Slicing”
first obtains a set T(I)of slices for I, one per malicious activity
that may be opened at Iand “Control Flow Specialization” then
expands it into a set T(I)of runnable slices by performing branch
predicatespecialization.Next,ourdynamicanalysistakesover.For
eachrunnableslice,“Repackaging”firstturnsitintoadownsized
APK file and “Execution” then takes care of executing it on an
Android device or emulator to expose the malicious UI.
5.1 Pre-Analysis
For each startActivity() callI, we check to see if it is suspi-
cious by verifying the two conditions in Section 4. Our subsequent
algorithmsapplytoeachsuspiciouscallinisolation.Inourexample
discussed in Section 3.2.1,I18is suspicious.
5.2 Trigger-Oriented Slicing
Givenasuspicious startActivity() callI,Algorithm 1,named
TOSlicer, generates a set T(I)of slices interprocedurally, one
sliceTt(I)for each class type tassociated with the malicious
activities opened at I. For simplicity, we assume the absence of
static variables in the app considere d. However , global variables
can be handled in the standard manner [22].
Let us start with TOSlicer (line s 1 – 13). We first find the set of
classtypesfortheopenedactivitiesat I(line3).Foreachclasstype
representing suspicious activities (lines 4 and 5), we then set up its
slicingcriterion SCt(I)(line9)andcallInterSlicertocompute
interprocedurallyabackwardslicestartingfromallthepointsin
SCt(I), one at a time (lines 10 – 11). At this stage, all branch
predicates are not specializable yet (lines 7 – 8). To set up SCt(I),
weincludenotonly IbutalsoalltheUI-drawingcalls(e.g.,calls
for modifying the UI contents in Dialog, Activity, or Window) that
can be reached from all the lifecycle callbacks of class tinCG.
Let us now consider InterSlicer (lines 14 – 37). InterSlicer
computes a backward slice interprocedurally from the statement s,
as is done traditionally [ 22,54], except that certain branch predi-
cates are flagged as specializable (Property 1). Therefore, it suffices
to explain only the parts inside the three blue boxes. In line 22, we
ignore all the statements that define the values used at a specializ-
ablebranchpredicate.Inlines26–27,weflaganewlyaddedbranch
predicate as specializable if Property 1is satisfied. In lines 28 – 31,
werecognizethatapredicatethatwaspreviouslyspecializableis
no longer specializable (as Tt(I)has grown big). Thus, the slicing
process must now be restarted from these predicates (line 31).
Itiseasytocheckif s,containedinmethod m,satisfiesProperty 1
ornot.Tmisthecurrentslicefor m(line16).Let s1,··· ,snbethe
nsuccessors of sin the CFG of m, denoted Gm. Let P(si)be the
setofbasicblocks,confinedwithin Tm,reachablefrom si,whichAlgorithm 1: Trigger-oriented slicing.
Input : I
Output : T(I)
1Function TOSlicer ()
2T(I) =∅;
3SetofActTypes = set of types of the activities opened at I;
4foreacht∈SetofActTypes do
5 ifIis suspicious with respect to t(Section4)then
6 Tt(I)=∅;
7 foreachbranch predicate sin CGdo
8 s.spec=false;
9 SCt(I)={Iand all the UI drawing calls reachable in the
lifecycle callbacks of class tinCG};
10 foreachs∈SCt(I)do
11 Tt(I)∪=InterSlicer (s, Tt(I));
12 T(I)∪ ={Tt(I)};
13returnT(I);
14Procedure InterSlicer ( s,Tt(I))
15Letmbe the method containing statement s;
16Tm={s/prime/primeis contained in m|s/prime/prime∈Tt(I)};
17worklist ={s};
18whileworklist /nequal∅do
19 s=worklist .remove();
20 Tm.add(s);
21 foreachs/prime/nelementTmin the CFG of mdo
22 ifs/prime→ds∧(sis not a predicate ∨!s.spec)then
23 worklist .add(s/prime);
24 else ifs/prime→csthen
25 worklist .add(s/prime);
26 ifs/primesatisfies Property 1then
27 s/prime.spec=true;
28 foreachs/prime∈{s/prime/prime∈Tm|s/prime/prime.spec=true}do
29 ifs/primedoes not satisfy Property 1then
30 s/prime.spec=false;
31 worklist .add(s/prime);
32Tt(I)∪=Tm;
33ifany statement in Tmuse any of m’s parameters then
34 SetOfCallSites = set of call sites for minCG;
35 foreachs/prime∈SetOfCallCites do
36 Tt(I)∪=InterSlicer( s/prime,Tt(I));
37returnTt(I);
includes siitself, in Gm. We know that ssatisfies Property 1when
the following two conditions are met. (1) There exists only one
unique 1 /lessorequalslanti/lessorequalslantnsuch that P(si)is non-empty. This can be done
by performing a standard control flow reachability analysis on Gm.
(2) Let abe a memory address read by any statement s/primeinP(si)
(directlyorindirectlyif s/primeisacallsite).Then sdoesnotalsoread
from a. This can be done based on the def-use chains (for local
variables) and alias information (for field accesses).
In our example, the class type of the activities opened at I18
isBKMain. Given that SCBKMain(I18)={18 ,33 ,36}, the final slice
TBKMain(I18)computed is given in Section 3.2.2, where line 16 is
specializable. Thus, T(I18)={TBKMain(I18)}.
5.3 Control Flow Specialization
Given a slice Tt(I), Algorithm 2transforms and expands it into
arunnableslice Tt(I)byperformingtwoflavorsofcontrolflow
specialization.Inourexample,Figure 4demonstratesthetransition
fromTBKMain(I18)toTBKMain(I18)forI18.
In lines 2 – 3, we specialize every specializable branch predicate
identified in Tt(I)to always execute the only branch contained
241
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. TDroid: Exposing App Switching Attacks in Android with Control Flow Specialization ASE ’18, September 3–7, 2018, Montpellier, France
Algorithm 2: Control flow specialization.
Input : Tt(I)
Output: Tt(I)
1Function CFSpec ()
2foreachbranch predicate sinTt(I)s.t.s.spec=truedo
3 Specialize it to execute its unique branch in Tt(I);
4Tt(I)=Tt(I);
5foreachmethodm, contained in Tt(I),i nC Gdo
6 Add the missing control flow statements of mtoTt(I);
7 foreacheach thus added branch predicate sdo
8 ifsrepresents a branch predicate for a loop then
9 Specialize sto skip its associated loop body;
10 else ifsreaches (along any of its branches, say, b)a
statement of minTt(I)then
11 Specialize sto execute b;
12 else
13 Specialize sto execute any of its branches;
14returnTt(I);
inTt(I). In our example, bk_type == 0 in line 16 is specializable,
forcingI18to be always executed in Figure 4.
In lines 4 – 14, we add all the missing control flow statements
(including jump statements) contained in the methods in Tt(I)
so thatTt(I)is runnable. In Figure 4(forI18), all such newly
added control flow statements in TBKMain(I18)\TBKMain(I18)are
showninthewhitebackground.Foreverynewlyintroducedbranch
predicate, which is guaranteed not to control any statement in
Tt(I)by construction, it is specialized depending on which of
the three cases it falls into (lines 7 – 13). In Figure 4(forI18),
TBKMain(I18)\TBKMain(I18)contains three such branch predicates,
in lines 8, 9 and 21 (of the original app in Figure 1), which are
specialized, respectively, according to the three cases in that order.
5.4 Repackaging
Givenarunnableslice Tt(I),wewillrepackageitintoanAPKfile.
There are four tasks, illustrated using our example.
First, we create the launcher activity, MainActivity , forTt(I).
The one for TBKMain(I18)is given in Figure 6. Let m1,··· ,mn
be the predecessor-less methods (regardless of their access mod-
ifiers) backwards reachable from IinCG. Let Cibe the class
where miis defined. For each mi, we add “ new Ci().mi()”t o
MainActivity() . ForTBKMain(I18), as shown in Figure 6,“new
Notifications().checkStatus()” is added.
Second, each object of C ithus created can no longer request
app-level operations such as launching activities. Regardless ofthe object used for calling
startActivity() atI, we replace it
by a context object of type Context stored in a global variable,
MainActivity.ctx , as demonstrated for I18in Figure 6(line 5)
and Figure 5(lines 13 and 18). For Tt(I), an opened activity of
type tcan be the topactivity. Thus, wesimply setthe attribute of
the intent associated with Ias NEW_TASK (e.g., line L1 for I18in
Figure5), so that this is also true for MainActivity.ctx (Table1).
Third,astheAndroidframeworkisnotmodeledaccurately,some
data and control dependences may be missing. Given Tt(I),w eexamine each of the lifecycle callbacks in class t. We add each
missing super call (e.g., line L2 for I18in Figure 5)t oTt(I).
Finally, we inject code into the lifecycle callback onCreate() of
class tforTt(I), the entry method for the opened activity of type
t, in order to capture the malicious UI shown. For I18, this is done
by the call in line L3 in Figure 5.
5.5 Execution
ForeachrepackagedAPKfile,werunitonanAndroiddeviceoremulatortoexposeitsmaliciousUI.Thescreenshotcapturedfor
I18inBankunisgiveninFigure 2.Ahumananalystcanseeclearly
thatBankun, which masquerades as Google Play, is malicious.
6 EVALUATION
WehaveevaluatedTDroidusingbothgoodwareandmalwareapps.
With goodware, which do not contain app switching attacks, we
showthatTDroidisbothefficientandeffectiveasamarket-level
vetting tool. With malware, we both confirm this finding and show
furtherthatTDroidoutperformsthestateoftheartindetecting
substantially more app switching attacks. Below we first discuss
ourresultsforgoodwarebrieflyandthenourresultsformalware
extensively.
Withgoodware,wehaveusedatotalof85Androidappsfromthe
popularAndroidapprepositoryF-Droid[ 11].Tominimizebiases
towardscertainappcategories,weselectedtop5appsfromthetop
chartsinall17appcategories(on23March2018).TDroidanalyzeseach app in 19.2 seconds on average. Statically, TDroid finds 7 sus-
picious
startActivity() callsin6apps: MqttPublisher Plugin
(1),Kwik EFIS (1),Linphone (1),Little Sir Echo (1),EteSync
(1), and Clock(2). Dynamically, TDroid exposes the UIs in 6 of
these7calls: MqttPublisher Plugin (1),Kwik EFIS (1),Linphone
(1),Little Sir Echo (1),EteSync (0), and Clock(2). For the
startActivity() call in EteSync, TDroid has failed to expose
its UI. In this case, the underlying slice is incomplete since some
data dependencies related to IPC (inter-process communication)are missing. The times (in seconds) elapsed on analyzing these
seven apps are
MqttPublisher Plugin (32.2), Kwik EFIS (35.9),
Linphone (73.7), Little Sir Echo (43.3), EteSync (66.7), and
Clock(111.6). As benign apps rarely open a top activity when
running in the background (as expected), TDroid reports only afew suspicious
startActivity() calls. In addition, TDroid can
analyze such real-world apps efficiently and effectively.
With malware, we address three research questions (RQs):
•RQ1.CanTDroiddetectappswitchingattackseffectivelyand
efficiently with a hybrid static-dynamic analysis?
•RQ2.Is TDroid more effective than special-purpose tools devel-
oped for detecting app switching attacks?
•RQ3.Is TDroid more effective than general-purpose tools that
can also be used to find app switching attacks?
We consideranew popularAndroid MalwareDataset[ 53].We
started by selecting a set of all the 4171 malware apps from all the
26families(widelyusedin[ 8,13,14,39,41])labeledwith“Bank”,
"Ransom” or “Fraud”. However, 357 apps cannot be decompiledby Dexpler [
6] successfully. We have finally settled with a set of
3814malwareapps.Despitethelabels,theseappsdonothavethe
ground truth about any hidden app switching attacks.
242
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Jie Liu, Diyu Wu, and Jingling Xue
To address RQ1, we show how TDroid can (for the first time)
detectwhichofthese3814appsdefinitelycontainappswitching
attacks. To address RQ2, we show that TDroid’s static analysis
can discover more suspicious startActivity() calls (and more
suspicious apps) than StaDef [ 8], the only special-purpose tool
available, which applies static analysis to detectingapp switching
attacks.ToaddressRQ3,weshowthatTDroidcanfindsubstantially
moreapp switchingattacks thanthreerepresentativeGUItesting
tools,Google’sMonkey[ 15],Sapienz[ 37],andStoat[ 47],aswell
as a hybrid analysis tool, FuzzDroid [40].
Implementations. WehaveimplementedTDroidinSoot[ 51]
inabout8KLOCofJavacode.Givenanapp(inanAPKfile),wefirst
useDexpler[ 6]toconvertitsDalvikbytecodeintoSoot’sJimple
IR.WethenrunFlowDroid[ 5]ontheJimplecodetobuildacall
graphfortheapp.FlowDroidachievesthisbyworkingwithSoot’s
pointeranalysis, Spark, tocreate adummy main()consistingof
the callbacks found iteratively in the app. We make use of the
data and control dependences, alias information, and the CFGs
forthemethodsinthecallgraphprovidedbySoot.Inparticular,
thedatadependencesforthe“Extras”storedintotheintentfora
startActivity() call are tracked. For example, in Section 3.2.2,
17→d32isfoundbylinkingtheuseof“BK”at getStringExtra()
inBKMain.oncreate() (line 32) with its definition in putExtra()
inNotifications.onCreate() (line 17).
For StaDef [ 8], we have implemented it based on the algorithm
described by its authors (as it is not open-sourced). For Google’s
Monkey[ 15],Sapienz[ 37],Stoat[ 47],andFuzzDroid[ 40],we
use their open-source tools.
TDroid runs on a desktop computer while the app being ana-
lyzed runs on an Android emulator. The Android Debug Bridge
(adb) is used to facilitate communication between the desktop and
emulator. Google’s Monkey [ 15], Sapienz [ 37], Stoat [ 47], and
FuzzDroid [40] operate similarly.
Experimental Setup. Ourdesktopcomputerrunsona64-bit
Ubuntu16.04with8cores(3.20GHzIntelXeon(R)CPU)and256GB
RAM.OurAndroidemulatorisaNexus5withtheKitKatversion
(SDK 4.4, API level 19), one of the most widely distributed Android
versions. The analysis time of an app is the average of 5 runs.
6.1 RQ1: TDroid’s Effectiveness and Efficiency
Figure7depicts our results on analyzing the 3814 malware apps
from 26 malware families. Statically, TDroid finds 3075 suspicious
startActivity() calls in 1062 suspicious apps spreading across
20outofthe26malwarefamilies,inanaverageof16.4secondsper
app.Dynamically,TDroidhassucceededinrunning92.1%(978
1062)
of the 1062 suspicious apps to completion, with 82.7% (878
1062) being
malicious,confirmedbyvisualinspection,inanaverageof160.5
seconds (including both the static and dynamic analysis times) per
app.TheseresultsdemonstrateagainTDroid’seffectivenessand
efficiency, making it deployable as a market-level vetting tool.
TDroidfailedinexecuting84suspiciousapps.For49ofthese
84 apps, their original APK files are faulty (not executable). For the
remaining35apps,theirrepackagedAPKfilesareincompletesince
their underlying slices are incomplete (due to, e.g., the unsound
handling of reflection and the Android framework in Soot).32.941.955.7
5.55.827.2
0102030405060Percentage Distribution (%)3814 
Apps
1 32 4 65
(a) Apps analyzed (b) Attack classification
BankBot ( 1,2) SimpleLocker ( 3) Bankun ( 2,4) Spambot ( 2,6) GoldDream ( 5)
(c) Selective screenshots produced
Figure7:TheTDroidresults.Theappswitchingattacksfallinto six categories:
1sensitive data theft, 2phishing (UI
spoofing), 3loss of availability, 4malware infection, 5
suspicious webviews, and 6admin privilege escalation.
Let us examine the results in Figure 7in more detail. Figure 7(a)
dividesthe878maliciousappsintosixcategories,withtheirper-
centage distributions shown in Figure 7(b) and their representative
malicious UIs in Figure 7(c). “Loss of Availability” is the mostly
dominantattackcategory(55.7%),followedby“Phishing”(41.9%)
andthen“SensitiveDataTheft”(32.9%).Somemalwareapps(27.2%)
exploit an “Admin Privilege Escalation” attack to lure users to give
theiradminprivilegestopreventthemfrombeinguninstalled.Some
malware apps (5.5%), e.g., Bankun, attempt to injectnew malware
appsintothecompromiseddevices.Others(5.8%)displaymalicious
webviews, with possibly malicious URLs.
To examine TDroid further, we have randomly picked
one sample from each of the 20 families containing suspicious
startActivity() calls. Table 2shows the 20 malware samples
selected (Column 1), our results (Columns 3 – 6), and the types
ofattackslaunched(Column7).TDroidfindsstatically58suspi-
cious startActivity callsandexposesdynamicallytheirassoci-
ated UIsin 55 of thesecalls, in under55 minutes (withan average
ofaboutoneminutepercall).Fortheremaining3calls,theircor-
responding slices are incomplete (as mentioned above). For one
inFakeAVand one in SlemBunk , some data dependencies through
SharedPreferences aremissing.Foranotheronein SlemBunk ,its
associated intent object is incomplete.
For the 55 startActivity calls with exposed UIs, 51 are
malicious, and the remaining four, which reside in FakeDoc,
FakePlayer ,Nandrobox , and Zitmo, are benign. Thus, the other
16appsare malicious,capableoflaunching appswitchingattacks.
6.2 RQ2: Special-Purpose Detection
StaDeffinds1642suspicious startActivity() callsin770apps,
in 7.1 seconds per app, on average. As discussed earlier, TDroid
243
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. TDroid: Exposing App Switching Attacks in Android with Control Flow Specialization ASE ’18, September 3–7, 2018, Montpellier, France
Table 2: Effectiveness and efficiency of TDroid in handling a set of 20 selected malware samples.
APK MD5TDroidAttack Types# of Suspicious startActivity() Calls# of Calls with Exposed UIs # of Malicious Calls Time (secs)
Aples 0c9eccbd1f0ed4ed29178f5b2f785b7f 2 2 2 76.04 2,6
BankBot 2ba4663a14899854fff429a6d6035cc2 4 4 4 117.47 1,2,6
Bankun 110001afe867f8e1e79790b2336ec96d 5 5 5 153.97 2,4
FakeAV 418b5b165ac8b2d9611a4c7acdff0c8c 5 4 4 874.02 1,2
FakeDoc 063846036d6b5d45998879ae2cc142ab 1 1 0 54.16
FakePlayer 2337a421045aaebe2be6497dab822826 1 1 0 44.49
Fusob 63c980138792a5fab4fd6e5f1ac6a938 3 3 3 95.91 2,3,5,6
GoldDream 31ff6d0c28cae40d2e97fa7770973fdd 1 1 1 149.78 5
Gumen d30e857aaba02275c54b76badb1bc855 1 1 1 85.02 2,4
Jisut 004d0c40db80d291804c44d531bf7b64 2 2 2 193.94 3
Koler 1e341a93ea251267b7af6548f49752f5 9 9 9 277.43 3,5
Nandrobox 4d871daec6a4270a70f42800f9a932f2 1 1 0 46.62
Roop 7584538eb727cc7acf57c3b1b55ff8e3 1 1 1 157.96 3
SimpleLocker 0b7e470f80205786e00e277fc1d4c224 1 1 1 31.63 3
SlemBunk 41c9add2be9f4b04047ab232eb08058f 12 10 10 460.16 1,2,6
SmsZombie 0e5dd82f8aeddc76160576c512804930 2 2 2 60.03 2,4
Spambot 0c5b3709f970af266393d0206633dec6 1 1 1 136.48 2,6
Svpeng 9a0617349c91000b04a0cf887c63c40e 4 4 4 129.26 1,2
Triada de52d8cbccdb32dbdf576966031bf2bd 1 1 1 103.21 6
Zitmo 003bb03ec84313dc73a86af3876a128d 1 1 0 33.97
Total 58 55 51 3281.55
024681012STadef TdroidTDROID STADEF
Figure 8: Comparing TDroid and StaDef on detecting sus-
piciousstartActivity()callsinthe20selectedmalwareapps.
finds 3075 suspicious calls in 1062 apps, in 16.4 seconds per app,
onaverage.StaDefreports63 suspicious callsmissedbyTDroid,
butonlyasubsetofsuspiciousappsreportedbyTDroid.Intotal,
TDroid has found 1242 malicious startActivity() calls in 205
malicious apps, which are not flagged as suspicious by StaDef.
ItisimportanttonoteagainthatStaDef,asapurestaticanalysis
tool,isnotsuitableforvettingapps,sinceahumananalystmuststill read the code of all suspicious apps to make a final decision.
Forthe63suspicious startActivity() callsreportedbyStaDef
but missed by TDroid, we have inspected their relevant code. Due
to obfuscation, it is unclear whether 15 of these calls are malicious
ornot.PassingthemtoTDroidisstillinconclusiveastheytryto
access a database that could not be reproduced in our emulation
environment.Theremaining48callsareallmalicious,capableof
launching app switching attacks. TDroid has missed these callssincetheyareallmadefromasynchronoustasksstartedbyuser-driven callbacks (e.g.,
onClick), when these malicious apps are
initially running in the foreground. Given these calls, TDroid can
expose their malicious UIs in 27.0 seconds each.
Figure8showsthatTDroidismoreeffectivethanStaDefinfind-
ingsuspicious startActivity() callsinthe20selectedmalware
apps(Table 2).AsdiscussedinSection 6.1,TDroidreports58suspi-
ciouscalls,ofwhich51aremalicious,in16apps.Incontrast,StaDef
reports only25 suspiciouscalls (also reportedby TDroid), whichareallmaliciousin10apps.Inparticular,StaDefmissesappswitch-
ing attacks in the six malicious apps, Bankun,GoldDream ,Gumen,
SimpleLocker ,SmsZombie andSpambot.(RecallthatTDroidfinds
no attacks in FakeDoc, FakePlayer, Nandrobox andZitmo.)
6.3 RQ3: General-Purpose Detection
We compare TDroid with four representative general-purpose
tools, Google’s Monkey (randomized) [ 15], Sapienz (search-based)
[37], Stoat (model-based) [ 47], and FuzzDroid [ 40], which all
involve executing an app to expose its malicious behaviors. The
first three aim for high coverage while the last attempts to reach a
particular program point. Therefore, the criterion used here is the
recallrate,measuredasthepercentagehitrateforthesuspicious
startActivity() detected by TDroid’s static analysis. For these
four tools, the per-app budget allocated 3 hours.
Table 3: Comparing TDroid with Google’s Monkey [15],
Sapienz) [37], Stoat [47], and FuzzDroid [40] in terms of
their ability in exposing the malicious UIs for the 58 suspi-cious startActivity() calls found by TDroid’s static analysisin the 20 selected malware apps (Table 2).
Tool % of Suspicious Calls Reached
Monkey 8.62
Sapienz 10.34
Stoat 12.07
FuzzDroid 18.97
TDroid 94.83
Table3showsthatTDroidissignificantlymoreeffectivethan
the state of the art in exposing the malicious UIs hidden at the58 suspicious
startActivity() calls found by TDroid’s static
analysisinthe20selectedmalwareapps(Table 2).Thisismainly
because these existing tools cannot handle effectively the input-
dependent branch predicates, which come in a variety of flavors in
244
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Jie Liu, Diyu Wu, and Jingling Xue
malwareapps.Forexample,manymaliciousapps,suchas Aples,
Spambot andGoldDream , launch app switching attacks after some
system broadcasts (e.g., reboot completed, network connectivity
changed, and device woke up) are sent.
To improve the coverage, i.e., recall rate of Google’s Monkey
(8.62%), Sapienz [ 37] and Stoat [ 47] inject system-level events
randomly, but are only marginally more effective (with their re-
call rates being 10.34% and 12.07%, respectively). To go further,
FuzzDroid [ 40] applies static analysis to model system broadcasts
and generates candidate environments with dynamic fuzzing toreach a particular code location. However, due to its incomplete
handlingofsystemAPIsandeventdependencies(amongothers),
FuzzDroidisonlyrelativelymoreeffective(at18.97%).Byapply-
ingtrigger-orientedslicing,TDroidcanavoidevaluatingexplicitly
many input-dependent predicates, achieving a recall rate of 94.83%.
6.4 Limitations
TDroid performs its trigger-oriented slicing for an app on a call
graph built by FlowDroid [ 5], together with Soot’s spark pointer
analysis [ 27], in the Soot framework. As reflection is handled only
partially in Soot, the call graph may be incomplete. This can be
improvedbyincorporatingamorepowerfulreflectionanalysistool
[16,31,32,34,59]. In addition, FlowDroid does not support inter-
component communication (ICC). Currently, the data dependences
for the “Extras” added to the intent objects at startActivity()
aretracked.Thecallgraphcanalsobeincompletethisway.This
can be improved by adding an ICC analysis [28].
Persistent storage APIs such as SharedPreferences are widely
used in Android apps. Therefore, the statements operating on per-
sistent data by these APIs can be distributed throughout an app.
Currently, we do not model thedata dependencies through persis-
tent storage, resulting in incomplete slices sometimes (Section 6.1).
7 RELATED WORK
GUI Security. Earlier papers show the possibility of launching
UI spoofing [ 8,9,12] and denial-of-service [ 17,41,42] attacks in
Android by playing tricky maneuvers on the currently active task
oftheforegroundapp.Inparticular,Feltetal.[ 12]assesstherisk
ofphishing attacksonmobiledevices drivenbyinter-appcontrol
transfers.Ren etal.[ 42]study thetaskhijacking attacksinwhich
theattackercanlettheactivitiesofamalwareappresidesideby
sidewiththoseofavictimappinthesametaskandhijacktheuser
sessions of the victim app. Chen et al. [ 9] reveal that GUI confiden-
tiality can be breached by a shared-memory side channel. He et
al.[21]investigatebroadlyanumberofAPI-relatedcompatibility
issues in Android apps due to API evolution.
Several techniques exist for defeating GUI attacks [ 8,41,43].
Bianchietal.[ 8]introduceStaDef(thestaticanalysiscompared
with TDroid) and an on-device defense for mitigating GUI attacks
(includingappswitchingattacks).Renetal.[ 41]alsoproposean
on-device defense for rooted devices.
In this paper, we focus on developing a market-level hybrid
analysis for defending against app switching attacks.
ProgramSlicing. TherehavebeenmanyextensionsofWeiser’s
slicing technique [ 54], including thin slicing [ 46], path slicing [ 25],
and tailoring [ 33]. There are others focusing on handling jumpstatements [ 3], unstructured programs [ 20], jumps and switches
[26], and exceptions [4].
Toobtaindatadependencesrequiredinslicing,thealiasingin-
formation in the program can often be computed by applying a
pointer analysis algorithm [7, 19,24,29,30,45,48–50,58].
Inthispaper,TDroidproducesrunnableslicesbyconsidering
not only data and control dependences as in the prior work but
also control flow specialization in order to expose the malicious
UIs easily.
GUITesting. ToimprovethecoverageofGoogle’sMonkey[ 15]
throughoptimizingtestsequences,Sapienz[ 37]embracesmulti-
objectivesearch-basedtestingandStoat[ 47]resortstoautomated
model-based testing. Dynodroid [ 35] applies an observe-select-
executeprincipletogenerateUIandsysteminputs.EvoDroid[ 36]
adoptssegmentedevolutionarytestingtoimprovecoverage.PUMA[
18]isaprogrammableUIautomationframeworkforimplementing
various state-based test strategies. Some other recent work for
facilitating GUI testing can also be found in [10, 38,44,60].
Despite these advances, GUI testing tools are still poor in test
coverage. In contrast, TDroid has significantly improved coverage
for detecting app switching attacks by applying a new trigger-
oriented slicing technique.
HybridAnalysis. AppDoctor[ 23]combinesstaticslicingand
dynamic execution to find bugs triggered by user actions. Cred-
Miner [61] proceeds similarly to study the prevalence of unsafe
developercredentialuses.However,itexecutesslicesinacustom
engine, requiring a precise model of the Android OS and libraries.
Harvester[ 39]isdesignedtoextractruntimevaluesfromAndroid
apps, by executing a traditional backward slice of an app on an
Android device or emulator to log the values of interest, such as
someclassandmethodnames.FuzzDroid[ 40],whichiscompared
with TDroid in Section 6.3, combines static analysis and dynamic
fuzzingtogeneratecandidateenvironmentstosteeranapptowards
acodelocation.BothHarvesterandFuzzDroidneedtohandle
adequately a large number of system APIs in Android.
In this paper, TDroid combines a novel trigger-oriented slicing
approach and dynamic execution to find app switching attacks
effectively.
8 CONCLUSION
We have introduced a new market-level approach, TDroid, for
detectingappswitchingattacksinAndroidapps,bycombininga
trigger-oriented slicing technique and dynamic execution. TDroid
issubstantiallymoreeffectiveindetectingappswitchingattacks
thanthe stateof theart. Inaddition,TDroidhastwo otherimme-
diate benefits. First, TDroid can be used to extract dynamic values
from Android apps that are of interest to a human analyst, such as
SMS messages and reflective call targets. Second, TDroid can help
GUI testing tools improve their coverage.
ACKNOWLEDGEMENTS
Wewishtothankallthereviewersfortheirconstructivecomments
on an earlier version of this paper. This research is supported by
an ARC grant DP170103956.
245
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. TDroid: Exposing App Switching Attacks in Android with Control Flow Specialization ASE ’18, September 3–7, 2018, Montpellier, France
REFERENCES
[1]2014.ASEC Report. http://download.ahnlab.com/asecReport/ASEC_Report_Vol.
55_Kor.pdf .
[2]2016.Internet Security Threat Report. https://www.symantec.com/content/dam/
symantec/docs/reports/istr-21-2016-en.pdf .
[3]HiralalAgrawal.1994. OnSlicingProgramswithJumpStatements.In Proceedings
of the Conference on Programming Language Design and Implementation.
[4]Matthew Allen and Susan Horwitz. 2003. Slicing Java Programs That Throw
andCatch Exceptions.In Proceedingsofthe WorkshoponPartial Evaluationand
Semantics-based Program Manipulation.
[5]Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bodden, Alexandre Bartel,
JacquesKlein,YvesLeTraon,DamienOcteau,andPatrickMcDaniel.2014. Flow-
Droid:PreciseContext,Flow,Field,Object-sensitiveandLifecycle-awareTaint
AnalysisforAndroidApps.In ProceedingsoftheACMSIGPLANConferenceon
Programming Language Design and Implementation.
[6]Alexandre Bartel, Jacques Klein, Yves Le Traon, and Martin Monperrus. 2012.
Dexpler: Converting Android Dalvik Bytecode to Jimple for Static Analysis with
Soot. InProceedings of the International Workshop on State of the Art in Java
Program Analysis.
[7]Marc Berndl, Ondřej Lhoták, Feng Qian, Laurie Hendren, and Navindra Uma-
nee.2003. Points-toanalysisusingBDDs.In ProceedingsoftheACMSIGPLAN
conference on Programming language design and implementation.
[8]A. Bianchi, J. Corbetta, L. Invernizzi, Y. Fratantonio, C. Kruegel, and G. Vigna.
2015. What theAppisThat? DeceptionandCountermeasures intheAndroid
User Interface. In Proceedings of IEEE Symposium on Security and Privacy (S&P).
[9]QiAlfredChen,ZhiyunQian,andZhuoqingMorleyMao.2014. PeekingintoYour
AppwithoutActuallySeeingIt:UIStateInferenceandNovelAndroidAttacks.
InProceedings of the USENIX Security Symposium.
[10]Wontae Choi, George Necula, and Koushik Sen. 2013. Guided GUI Testing of
AndroidAppswithMinimalRestartandApproximateLearning.In Proceedings
oftheACMSIGPLANInternationalConferenceonObject-orientedProgramming,
Systems, Languages, and Applications.
[11] F-Droid. 2018. Free and Open Source App Repository. https://f-droid.org/.
[12]Adrienne Porter Felt and David Wagner. 2011. Phishing on mobile devices. In
Web 2.0 Security and Privacy.
[13]Yu Feng, Osbert Bastani, Ruben Martins, Isil Dillig, and Saswat Anand. 2017. Au-
tomatedSynthesisofSemanticMalwareSignaturesusingMaximumSatisfiability.
InProceedings of Network and Distributed System Security Symposium (NDSS).
[14]Earlence Fernandes, Qi Alfred Chen, Justin Paupore, Georg Essl, J Alex Halder-
man,ZMorleyMao,andAtulPrakash.2016. AndroidUIDeceptionRevisited:
AttacksandDefenses.In ProceedingsofFinancialCryptographyandDataSecurity
(FC).
[15]Google.2017. UI/ApplicationExerciserMonkey. https://developer.android.com/
studio/test/monkey.html.
[16]Neville Grech, George Kastrinis, and Yannis Smaragdakis. 2018. Efficient Reflec-
tionStringAnalysisviaGraphColoring.In ProceedingsoftheEuropeanConference
on Object-Oriented Programming.
[17]Joji Hamada. 2014. Simplocker: First Confirmed File-Encrypting Ran-
somware for Android. https://www.symantec.com/connect/blogs/
simplocker-first-confirmed-file-encrypting-ransomware-android.
[18]ShuaiHao,BinLiu,SumanNath,WilliamG.J.Halfond,andRameshGovindan.
2014. PUMA:ProgrammableUI-automationforLarge-scaleDynamicAnalysis
of Mobile Apps. In Proceedings of the Annual International Conference on Mobile
Systems, Applications, and Services.
[19]BenHardekopfandCalvinLin.2011. Flow-sensitivePointerAnalysisforMillions
ofLinesofCode.In ProceedingsoftheAnnualIEEE/ACMInternationalSymposium
on Code Generation and Optimization.
[20]Mark Harman and Sebastian Danicic. 1998. A new algorithm for slicing unstruc-
tured programs. Journal of Software Maintenance 10, 6 (1998), 415–441.
[21]DongjieHe,LianLi,LeiWang,HengjieZheng,GuangweiLi,andJinglingXue.
2018. Understanding and Detecting Evolution-induced Compatibility Issuesin Android Apps. In Proceedings of the International Conference on Automated
Software Engineering (ASE).
[22]SusanHorwitz,ThomasReps,andDavidBinkley.1990. Interproceduralslicing
using dependence graphs. ACM Transactions on Programming Languages and
Systems12, 1 (1990), 26–60.
[23]GangHu,XinhaoYuan,YangTang,andJunfengYang.2014.Efficiently,Effectively
DetectingMobileAppBugswithAppDoctor.In ProceedingsoftheNinthEuropean
Conference on Computer Systems.
[24]Wei Huang, Yao Dong, Ana Milanova, and Julian Dolby. 2015. Scalable and
PreciseTaintAnalysisforAndroid.In ProceedingsoftheInternationalSymposium
on Software Testing and Analysis.
[25]Ranjit Jhala and Rupak Majumdar. 2005. Path slicing. In Proceedings of the
conference on Programming language design and implementation (PLDI).
[26]SumitKumarandSusanHorwitz.2002. Betterslicingofprogramswithjumps
and switches. In Proceedings of the International Conference on Fundamental
Approaches to Software Engineering.[27]Ondřej Lhoták and Laurie Hendren. 2003. Scaling Java Points-to Analysis Using
SPARK. In Proceedings of the International Conference on Compiler Construction.
[28]L. Li, A. Bartel, T. F. Bissyandé, J. Klein, Y. Le Traon, S. Arzt, S. Rasthofer, E.
Bodden,D.Octeau,andP.McDaniel.2015. IccTA:DetectingInter-Component
Privacy Leaks in Android Apps. In Proceedings of the International Conference on
Software Engineering.
[29]Lian Li, Cristina Cifuentes, and Nathan Keynes. 2011. Boosting the Performance
ofFlow-sensitivePoints-toAnalysisUsingValueFlow.In ProceedingsoftheACM
SIGSOFT International Symposium on Foundations of Software Engineering.
[30]Lian Li, Cristina Cifuentes, and Nathan Keynes. 2013. Precise and Scalable
Context-sensitivePointerAnalysisviaValueFlowGraph.In Proceedingsofthe
International Symposium on Memory Management.
[31]YueLi,TianTan,YuleiSui, andJinglingXue.2014. Self-inferencingreflection
resolution for Java. In Proceedings of the European Conference on Object-Oriented
Programming.
[32]Yue Li, Tian Tan, and Jingling Xue. 2015. Effective Soundness-Guided Reflection
Analysis. In Proceedings of the International Static Analysis Symposium.
[33]Yue Li, Tian Tan, Yifei Zhang, and Jingling Xue. 2016. Program tailoring: Slicing
bysequentialcriteria.In ProceedingsoftheEuropeanConferenceonObject-Oriented
Programming.
[34]Jie Liu, Yue Li, Tian Tan, and Jingling Xue. 2017. Reflection Analysis for Java:
Uncovering More Reflective Targets Precisely. In Proceedings of the International
Symposium on Software Reliability Engineering (ISSRE).
[35]Aravind Machiry, Rohan Tahiliani, and Mayur Naik. 2013. Dynodroid: An Input
Generation System for Android Apps. In Proceedings of the Joint Meeting on
Foundations of Software Engineering.
[36]RiyadhMahmood,NarimanMirzaei,andSamMalek.2014. EvoDroid:Segmented
Evolutionary Testing of Android Apps. In Proceedings of the ACM SIGSOFT Inter-
national Symposium on Foundations of Software Engineering.
[37]KeMao,MarkHarman,andYueJia.2016. Sapienz:Multi-objectiveAutomated
Testing for Android Applications. In Proceedings of the International Symposium
on Software Testing and Analysis.
[38]NarimanMirzaei,JoshuaGarcia,HamidBagheri,AlirezaSadeghi,andSamMalek.
2016. ReducingCombinatoricsinGUITestingofAndroidApplications.In Pro-
ceedings of the International Conference on Software Engineering.
[39]Siegfried Rasthofer, Steven Arzt, Marc Miltenberger, and Eric Bodden. 2016.
Harvesting Runtime Values in Android Applications That Feature Anti-Analysis
Techniques.In ProceedingsofNetworkandDistributedSystemSecuritySymposium
(NDSS).
[40]SiegfriedRasthofer,StevenArzt,StefanTriller,andMichaelPradel.2017. Making
Malory Behave Maliciously: Targeted Fuzzing of Android Execution Environ-
ments. In Proceedings of the International Conference on Software Engineering.
[41]ChuangangRen,PengLiu,andSencunZhu.2017. WindowGuard:Systematic
Protection of GUI Security in Android. In Proceedings of Network and Distributed
System Security Symposium (NDSS).
[42]Chuangang Ren, Yulong Zhang, Hui Xue, Tao Wei, and Peng Liu. 2015. Towards
Discovering and Understanding Task Hijacking in Android. In Proceedings of the
USENIX Security Symposium.
[43]FranziskaRoesnerandTadayoshiKohno.2013. SecuringEmbeddedUserInter-
faces: Android and Beyond. In Proceedings of the USENIX Conference on Security.
[44]Alireza Sadeghi, Reyhaneh Jabbarvand, and Sam Malek. 2017. PATDroid:
Permission-aware GUI Testing of Android. In Proceedings of the Joint Meeting on
Foundations of Software Engineering.
[45]Yannis Smaragdakis, Martin Bravenboer, and Ondrej Lhoták. 2011. Pick your
contextswell:understandingobject-sensitivity.In ProceedingsoftheannualACM
SIGPLAN-SIGACT symposium on Principles of programming languages.
[46]Manu Sridharan, Stephen J. Fink, and Rastislav Bodik. 2007. Thin Slicing. In
ProceedingsoftheconferenceonProgramminglanguagedesignandimplementation
(PLDI).
[47]Ting Su, Guozhu Meng, Yuting Chen, Ke Wu, Weiming Yang, Yao Yao, Geguang
Pu, Yang Liu, and Zhendong Su. 2017. Guided, Stochastic Model-based GUI
TestingofAndroidApps.In ProceedingsoftheJointMeetingonFoundationsof
Software Engineering.
[48]Yulei Sui and Jingling Xue. 2016. On-demand Strong Update Analysis via Value-
flowRefinement.In ProceedingsoftheACMSIGSOFTInternationalSymposiumon
Foundations of Software Engineering.
[49]Tian Tan, Yue Li, and Jingling Xue. 2016. Making k-Object-Sensitive Pointer
AnalysisMorePrecisewithStillk-Limiting.In ProceedingsoftheInternational
Static Analysis Symposium.
[50]TianTan,YueLi,andJinglingXue.2017. EfficientandPrecisePoints-toAnalysis:
Modeling the Heap by Merging Equivalent Automata. In Proceedings of the ACM
SIGPLAN Conference on Programming Language Design and Implementation.
[51]RajaVallée-Rai,PhongCo, EtienneGagnon,Laurie Hendren,PatrickLam, and
Vijay Sundaresan. 1999. Soot - a Java Bytecode Optimization Framework. In
ProceedingsoftheconferenceoftheCentreforAdvancedStudiesonCollaborative
research.
[52]Jaap Vermeij. 2016. Alerting Users on Android: The Effect of an Alert During a GUI
Confusion Attack.
246
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Jie Liu, Diyu Wu, and Jingling Xue
[53]Fengguo Wei, Yuping Li, Sankardas Roy, Xinming Ou, and Wu Zhou. 2017. Deep
Ground Truth Analysis of Current Android Malware. In Proceedings of the In-
ternational Conference on Detection of Intrusions and Malware, and Vulnerability
Assessment (DIMVA).
[54]MarkDavidWeiser.1979. Programslices:formal,psychological,andpractical
investigations of an automatic program abstraction method. (1979). PhD thesis.
[55]Daniel Xiang. 2013. Android.Bankun. https://www.symantec.com/security_
response/writeup.jsp?docid=2013-072318-4143-99&tabid=2.
[56]ShengqianYang,DacongYan,HaoweiWu,YanWang,andAtanasRountev.2015.
Static control-flow analysis of user-driven callbacks in Android applications. In
Proceedings of the International Conference on Software Engineering.
[57]Lingyun Ying, Yao Cheng, Yemian Lu, Yacong Gu, Purui Su, and Dengguo Feng.
2016. Attacks and Defence on Android Free Floating Windows. In Proceedings of
the Asia Conference on Computer and Communications Security.[58]Hongtao Yu, Jingling Xue, Wei Huo, Xiaobing Feng, and Zhaoqing Zhang. 2010.
Levelby level:makingflow- andcontext-sensitivepointeranalysis scalablefor
millions of lines of code. In Proceedings of the Annual IEEE/ACM International
Symposium on Code Generation and Optimization.
[59]Yifei Zhang, Yue Li, Tian Tan, and Jingling Xue. 2018. Ripple: Reflection analysis
for Android apps in incomplete information environments. Software: Practice
and Experience 48, 8 (2018), 1419–1437.
[60]Yifei Zhang, Yulei Sui, and Jingling Xue. 2018. Launch-Mode-Aware Context-
Sensitive Activity Transition Analysis. In Proceedings of the International Confer-
ence on Software Engineering.
[61]YajinZhou,LeiWu,ZhiWang,andXuxianJiang.2015. HarvestingDeveloper
CredentialsinAndroid Apps.In Proceedingsof theACMConferenceon Security&
Privacy in Wireless and Mobile Networks.
247
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. 