Generating Qualiﬁable Avionics Software:An Experience ReportAndreas W¨olﬂ*, Norbert Siegmund*, Sven Apel*, Harald Kosch*, Johann Krautlager†, Guillermo Weber-Urbina†*University of Passau, GermanyEmail:{andreas.woelﬂ, norbert.siegmund, apel, harald.kosch}@uni-passau.de†Airbus Helicopters S.A.S., GermanyEmail:{johann.krautlager, guillermo.weber-urbina}@airbus.comAbstract—We report on our experience with enhancing thedata-management component in the avionics software of theNH90 helicopter at Airbus Helicopters. We describe challengesregarding the evolution of avionics software by means of real-world evolution scenarios that arise in industrial practice. Akey role plays a legally-binding certiﬁcation process, calledqualiﬁcation, which is responsible for most of the developmenteffort and cost. To reduce effort and cost, we propose a novelgenerative approach to develop qualiﬁable avionics software bycombining model-based and product-line technology. Using thisapproach, we have already generated code that is running onthe NH90 helicopter and that is in the process of replacing thecurrent system code. Based on an interview with two professionaldevelopers at Airbus and an analysis of the software repositoryof the NH90, we systematically compare our approach withestablished development approaches in the avionics domain, interms of implementation and qualiﬁcation effort.I. INTRODUCTIONEngineering in the avionics domain is driven by variouslegally mandated regulations, dedicated to safety and reliabil-ity. Prior to the ﬁrst ofﬁcial ﬂight in a commercial aircraft, anational certiﬁcation authority has to inspect the airworthinessof all components, including airborne computers and software.This process is called avionicsqualiﬁcation. The acceptance isstrictly related to compliance with international aerospace stan-dards, such as DO-178: Software Considerations in AirborneSystems and Equipment Certiﬁcation [1]. Together with whitepapers1from the Certiﬁcation Authorities Software Team,these documents deﬁne process completion and functionalityveriﬁcation with software life-cycle objectives. Depending onthe (safety) criticality of the target system, applicants forqualiﬁcation have to meet a speciﬁc set of life-cycle objectives,determined by different Design Assurance Levels2.In industry, compliance with DO-178 adds about 75%–150% to the total development costs [2], caused by additionaleffort for developing or extending code and documentation forlife-cycle objectives, calledqualiﬁcation assets. By over twothird, the majority of these artifacts relates to software ver-iﬁcation and validation (e.g., establishing bidirectional trace-ability evidence from system requirements to unit tests) [1].Developing qualiﬁcation assets also complicates programmingof the software itself, because many assets must adhere to1https://www.faa.gov/aircraft/aircert/designapprovals/airsoftware/cast/castpapers/2Scale with ﬁve criticality levels, ranging from level A (most critical) tolevel E (least critical), assigned by the national certiﬁcation authority.strict coding constraints, such as the prohibition of late bindingor dynamic dispatch. The impact is most signiﬁcant betweenDesign Assurance Level D and C. Level C is assigned tomission-criticalsoftware and demands about 30% more budgetand schedule than software at Level D [3].In this paper, we report on our experience gained in acooperation between Airbus Helicopters and the University ofPassau. The key objective of the cooperation was to developa highly conﬁgurable real-time database management system,intended for integration in core mission-control applicationsin the avionics software of the Nato Helicopter 90 (NH90).Analogous to product lines in other industry branches [4],customers in the aviation domain can choose among a largenumber of features and conﬁguration options for the airborneequipment, which requires variability of the avionics softwarein the NH90, including the data-management component.In a ﬁrst step, we investigated state-of-the-art developmentmethods used at Airbus Helicopters. There are two basicapproaches to handle variability in qualiﬁed avionics soft-ware: The ﬁrst approach is to consider a software variantas separate unit, such that for each variant, the source codemust be implemented and qualiﬁed manually. The secondapproach is to apply speciﬁcally qualiﬁed development toolsto automatically generate variant-speciﬁc software artifacts.Based on the ﬁndings of a semi-structured interview with twosenior developers at Airbus Helicopters, we found that theseapproaches are economically suboptimal implementing datamanagement in the avionics domain. While an approach ofseparately implementing and qualifying software variants doesnot scale with an ever increasing number of new requirements,introducing a qualiﬁed development tool causes huge initialcosts for either purchasing a commercial tool or implementingand qualifying a suitable tool in-house.Based on our analysis, we propose a novel generativedevelopment approach that addresses the challenges of vari-ability and software evolution in the context of qualiﬁcationdemands in the avionics domain. Essentially, we combined theaforementioned approaches. In a nutshell, using model-basedand product-line technology, we generate tailored system vari-ants based on declarative speciﬁcations written in a domain-speciﬁc language. Furthermore, we ease software veriﬁcationand validation by automatically generating qualiﬁcation assetsin this process. This way, we have a scalable approach in termsof the number of variants and we keep the initial effort feasibleby supporting the qualiﬁcation of the generated code insteadof qualifying the tool itself. We integrated our approach intothe tool chain of the NH90 development environment. Ourimplementation is fully operational. The resulting softwarevariants are executable on the target avionics hardware andcurrently prepared for qualiﬁcation at Design Assurance LevelC as part of the next release of the NH90 System Software.To compare our approach to established development ap-proaches, we systematically describe the evolution of avionicssoftware by means of real-world scenarios regarding datamanagement in the NH90. In detail, we discuss frequencyand severity of functional and non-functional requirementsby combining insights from a developer interview and datacollected from the software repository of the data-managementcomponent of the NH90 System Software. The software repos-itory contains the problem reports, software change notes, andengineering change requests of the past 18 years. In the longrun, developers can use our results to assess maintenance effortin an avionics software project and determine a developmentstrategy for concrete scenarios.In summary, we make the following contributions:•We analyze development approaches applied in the avion-ics domain regarding practicability and feasibility in termsof the challenges of data-management and qualiﬁcationdemands in the avionics domain.•We report on a developer interview at Airbus Helicopters,providing insights into the implementation, maintenance,and evolution of avionics software.•We present a novel generative development approachbased on model-driven and product-line technology, aim-ing at the efﬁcient realization of both implementation andqualiﬁcation of avionics software.•We implement our approach as part of the real-timedatabase management system of the NH90 avionics soft-ware at Airbus Helicopters.•We quantitatively and qualitatively discuss our approachbased on real-world evolution scenarios combined withthe analysis of the software repository of the NH90System Software related to data management.II. AVIONICSSOFTWAREIn this section, we explain the target avionics softwareenvironment and evolution with a focus on data management.Furthermore, we characterize general challenges in develop-ing avionics software and describe established developmentapproaches with a focus on software qualiﬁcation.A. NH90 Avionics Software Evolution and VariabilityThe software division at Airbus Helicopters develops theon-board software for federated avionics in the NH90. TheNH90 is a medium sized multi-role helicopter, manufacturedby the NHIndustries consortium. Its operating system consistsof an application framework, calledNH90 System Software,and several application components, calledOperational Pro-cessing Functions. The programming language of the NH90System Software is Ada3, which has been speciﬁcally de-signed for the application in safety-critical embedded andreal-time systems. The ﬁrst qualiﬁed version of the NH90System Software was released in 1995, the year of the maidenﬂight of the NH90. From the ﬁrst 2 variants for ﬁeld- and3http://www.adacore.commaritime missions, economical success raised this numberto 11 variants in the early 2000s. From here, obsolescenceled to the introduction of additional hardware architectures,causing further variation in the software. Today, 45 variantsare deployed on 3 different hardware platforms, shipped tocustomers in 14 nations [5].The helicopter variants differ in their integral equipmentconﬁguration. Complex equipment provides optional features,from which customers can select arbitrary combinations. Itis also possible that already integrated equipment from adelivered helicopter is replaced by a functional equivalent thatis manufactured by another company. The effects on the asso-ciated avionics software are signiﬁcant. The most frequentlychanged area is the combination and the implementation ofOperational Processing Functions, which control or monitorsubsets of the avionic equipment. Some functions rely on thesame data or services, so the presence or absence of Oper-ational Processing Functions can cause interactions betweenindividual components, particular, affecting data managementand data-bus scheduling. An amendment in the OperationalProcessing Functions regularly requires further adjustments inthe functional capabilities of these components.The constantly growing number of variants and the result-ing complexity requires a re-development of major parts ofthe NH90 System Software. The primary goal of our endeavorwas to improve extensibility and maintainability of the data-management component, while providing sufﬁcient perfor-mance and resource consumption to deploy the software evenon legacy hardware platforms. As part of this re-developmentendeavor, Airbus Helicopters initiated the cooperation with theUniversity of Passau.B. Data Management in the NH90 System SoftwareA central component that posed problems regarding theevolution of variability in the NH90 System Software is thedata-management component. A single avionics computer con-tains about 10–15 Operational Processing Functions that usethe data-management component to store and process variousdata, structured by about 30 entity types4. When we startedthe cooperation, data management was implemented as list-based storage, henceforth calledList Management(LSTM).All data were kept as plain lists of data records. Complexdata-management functionality was left to the individual Op-erational Processing Functions. With the increase of variabilityover time, the developers faced three major problems: First,relationships between entities were only implicitly presentin the source code of the Operational Processing Functions.Second, there was no guarantee that referential integrity of thedata is maintained consistently. Third, values of related entitieshad to be stored redundantly.The re-development group at Airbus Helicopters concludedthat the current data-management solution LSTM should bereplaced by a data- and function-centric component. Sincethere is no commercial-of-the-shelf product available thatcan be qualiﬁed according to thePlan for Software Aspectsof Certiﬁcation5of the NH90, Airbus Helicopters decidedto pursue an in-house development in cooperation with the4The complex data types to handle records in the data-management com-ponent (e.g.,Waypoint).5An agreement between the aircraft manufacturer and the certiﬁcationauthority concerning certiﬁcation activities.NoteNoteQualiﬁed VariantManual DevelopmentSourceCode
Veriﬁcation & Validation Assets+QualificationFig. 1: Code-based development of qualiﬁed avionics softwareUniversity of Passau, henceforth calledEmbedded Database(EDB). To accomplish this goal, we ﬁrst had to discover thefactors that complicate software development in the avionicsdomain.C. Coding Constraints for Avionics SoftwareBased on accumulated knowledge gathered over years,Airbus Helicopters meets high standards with respect to soft-ware quality and safety, resulting in a large number of non-functional requirements. A subset of these requirements relatesto qualiﬁcation, showing compliance with DO-178 for civil-ian or DOD-STD-2167 [6] for military aviation. Conformityto these standards makes programming considerably moredifﬁcult and tedious. For reliability assurance in mission-and safety-critical avionics software, there must be a proofthat program execution and resource consumption are entirelydeterministic and predictable. Depending on the system criti-cality, heavy non-functional requirements prevail. In the caseof the NH90 System Software, we list some representativeexamples of coding constraints, referring to mission-criticalcode, qualiﬁed at Design Assurance Level C:•Dynamic programming mechanisms, such as late bindingor dynamic dispatch are prohibited.•To predict the memory footprint at compile time and toguarantee faultless resource consumption, memory mustbe allocated statically.•Source code that is never executed in any conﬁgurationhas to be completely removed.•Each line of source code must traceably correspond to alow-level system requirement.To get permission for ﬂight, each development artifact must beapproved by designated engineering representatives from thenational certiﬁcation authority. Next, we explain the currentpractice in qualifying avionics software.D. Qualiﬁcation of Avionics SoftwareSoftware veriﬁcation and validation is the most integralpart of the qualiﬁcation process. In this context, DO-178issues two methods:formal methodsandrequirement-basedtesting. Guidance for formal methods is documented in DO-333 [7]. It recommends model checking, theorem proving, andabstract interpretation as approved techniques for formal veri-ﬁcation. By contrast, testing aims at validating the correctness,completeness, unambiguousness, and logical consistency ofsystem requirements by running a comprehensive set of tests.In addition, bidirectional traceability between requirements,source code, and associated tests has to be established [8].Independent of veriﬁcation and validation, two softwaredevelopment approaches are commonly used in the avionicsdomain. In code-based development, both source code andqualiﬁcation assets are implemented manually and submitted
SourceCodeCriteria 1 ToolGenerationQualiﬁed VariantQualification
Veriﬁcation & Validation AssetsNoteNoteFig. 2: Tool-based development of qualiﬁed avionics softwareto the certiﬁcation authority for individual qualiﬁcation (Fig-ure 1). By contrast, tool-based development relies on tool-generated software artifacts (Figure 2). A generator tool, whoseoutput is part of the airborne software (in DO-178 asCriteria 1tool), must be qualiﬁed in compliance with the same softwarelife-cycle objectives at the same Design Assurance Level as theresulting software itself. The beneﬁt of this tool qualiﬁcationis that the output is automatically considered as veriﬁed andvalidated [9], such that no additional approval is required forthe integration of generated artifacts into the airborne software.To properly determine the beneﬁts and drawbacks of theseapproaches regarding the enhancement of data management inthe NH90, we asked developers to report on their experiencegained in the software development process of the currentlyoperating component, which we describe next.III. DEVELOPERINTERVIEWIn this section, we report on the setup, conduct, and resultsof an interview with two senior software developers employedat Airbus Helicopters. The goal was to collect informationon the current data-management component of the NH90avionics software and implications for our new solution. First,we list our research questions, followed by a description ofthe participants, questionnaire, and conduct. The remainder isstructured by the research questions. The survey follows theguidelines provided by Jedlitschka and others [10].A. ObjectivesThe subject of the interview was the development, main-tenance, and evolution of the LSTM, the currently operatingdata-management component of the NH90 avionics software.We had the following research questions:RQ1How much effort was required to implement and qualifythe initial version of the LSTM?RQ2How much effort requires deriving a new LSTM variant?RQ3What situations and circumstances cause typical main-tenance and evolution tasks for the LSTM?B. ParticipantsTwo senior developers of the software division at AirbusHelicopters participated in the interview. The ﬁrst developeris a senior systems software analyst and developer. During 25years of professional experience in the aviation domain, heworked with real-time SCADA systems, supervisory controlsoftware and data acquisition. With 19 years within the NH90software team, he is one of the leading senior developersand assists younger engineers with training and knowledgetransfer. He designed and implemented the LSTM and stillmaintains it. The second developer has been employed formore than 20 years in the avionics software domain. He hasbuilt consolidated expertise in the NH90 software team formore than 10 years. His responsibilities include all areas ofTABLE I: Topics of the semi-structured interviewObjective TopicRQ1,RQ2Chronological sequence of the LSTM developmentRQ1Application designRQ1,RQ2Functional and non-functional requirementsRQ1,RQ2Stakeholders of the LSTM in the NH90 System SoftwareRQ2Proceedings to add, modify, and delete a listRQ2,RQ3Hardware platform and compiler-speciﬁc aspectsRQ1Development approach for unit testsRQ3Software bugsRQ1,RQ2Procedure to verify and validate a new or modiﬁed listRQ1Approach to establish traceabilityRQ3Evolution of functional requirementsRQ3Evolution of non-functional requirementsRQ3Reasons of emergence of new requirementsRQ3Decision making for replacing the LSTM with the EDBthe software life cycle, mainly the development of controlapplications and the design of the NH90 operating system.C. Questionnaire and ConductThe interview was designed as a semi-structured interview.The topics are outlined in Table I. Besides the efforts forinitial implementation and qualiﬁcation, we wanted to collectinformation on what factors contribute to maintenance andevolution effort of complex multi-variant avionics software inindustrial practice. We were particularly interested in reasonsand frequency of changes in the software. Our goal was to getinsights into long-term implications and severity of changesregarding the realization of new and unexpected requirementsin the avionics domain. Therefore, we asked the intervieweesabout real-world challenges, solution approaches, and the timespent on resolving problems. The conversation was conductedface-to-face at the software division of Airbus Helicopters andlasted about 4 hours in total.D.RQ1: How much effort was required to implement andqualify the initial version of the LSTM?The LSTM was implemented by hand (code-based de-velopment). The ﬁrst qualiﬁed release was used for data-management in 7 NH90 variants. The programming of theinitial version lasted about 18 person months.”[The requirements] were constantly moving to [...] a yearand a half, really realistically. If you look at the code, it’snot a huge many thousands of lines, but the concept, wellyou have to satisfy the constraints on the requirements.”For qualiﬁcation, requirement-based testing was used. As partof the speciﬁed process in DO-178, a preliminary design wascreated before programming. This document comprises theinitial software speciﬁcation, including a mapping of low-level system requirements to procedures in the implementation.Traceability evidence as validation asset was built on thismapping. It is realized by adding annotations in the formof machine-readable comments to procedure headers. Thecompleteness and integrity of the traces is then automaticallyproved by tools. The interviewees estimated the effort tocreate the combination of preliminary design and traceabilityevidence at 2.5 person months, which is 10% of the totaldevelopment cost. The development of validation assets inform of functional tests and unit tests was extensive.”[There are] a lot of [tests], almost as much effort todevelop the Operational Processing Function, [...], I wouldsay easily 6 months effort, easily”In summary, the development time for qualiﬁcation assets ofthe initial version amounts to about 8.5 person months.E.RQ2: How much effort requires deriving a new LSTMvariant?The LSTM relies on generic software packages. In Ada,generic units are the instruments to safely implement paramet-ric polymorphism. A generic package represents a parameter-ized template for a package whose parameters can be types,variables, subprograms, and other packages. Each instantiationconceptually creates a copy of the speciﬁcation and body ofthe generic package, customized due to the actual parameters.All LSTM variants share the same operational functionality.They are distinguished by the data dictionary, which is deﬁnedby the absence or presence of certain Operational ProcessingFunctions in a speciﬁc NH90 variant. Each contained entitytype (e.g.Waypoint) is implemented as an independentlist, based on a central generic package. It requires 4 typedeﬁnitions and 9 subprograms to deﬁne the storage structure.”Accessing the data is not hard, that is the easy part. Thedifﬁcult part is where it gets the data that you would liketo modify. [...] Usually, the operator or the pilot is makingchanges to the graphical display, which is representing thedata of one record. [...] This [interaction] is taking thedeveloper three months, but the instantiation that is justone day.”The total cost of deriving a new LSTM variant is the effortrequired for adding or modifying the instantiation of lists,which is 8 person hours per entity type. On a single avionicscomputer, the NH90 System Software uses up to 30 differentlists by 10–15 Operational Processing Functions.F.RQ3: What situations and circumstances cause typicalmaintenance and evolution tasks for the LSTM?Maintenance effort arises from errors and ﬂaws in thesource code. The LSTM head developer reported from source-code changes due to bug ﬁxes, but estimated the correspondingcosts to be minor.”[...] if you consider 15 years of experience, your codekeeps getting better. I mean, the software evolved of course,but not much of changes because of bugs.”The majority of maintenance and evolution effort for theLSTM is caused by engineering change requests, which arerequests for system adjustments arising from new functionalor non-functional requirements. The reasons are mainly newcustomer requests and changes in terms of on-board equip-ment. The new system requirements are allocated to softwarerequirements, triggering development and maintenance activi-ties for the corresponding components.In addition to these general situations, we were interestedin concrete scenarios that represent typical maintenance andevolution tasks in the context of the LSTM. The intervieweesshared a number of actual scenarios, from which we presentthree selected examples for unexpected functional and non-functional requirements with differing severities. Each scenariodescribes a real-world problem, the actual solution, and thetime required to resolve it.Hardware platform:In 2003, a new avionics hardwareplatform was introduced for two NH90 core computers. Thenew board differed in the number of processors and switchedthe processor architecture from CISC to RISC. The compilerrequired a version upgrade of the runtime kernel and anupgrade of the programming language from Ada83 to Ada95.The change in the architecture led to additional platform-speciﬁc customization options in the LSTM, further increasingthe variability of the code signiﬁcantly.”There were some minor complications, but they wererelatively easy to ﬁx. It worked on the host [simulationcomputer], but it didn’t work on the target [avionics board],because the host compiler didn’t change. The ﬁx was donewithin a day, but if you start adding the initial analysis tolocate the error and the tests on the target [avionics board],you can ﬁgure 2 weeks. I would say that is very fair.”The implementation was limited to the generic package forlists, which avoided further variant-speciﬁc modiﬁcations.Memory optimization:Over time, more developers ofOp-erating Processing Functionsused the LSTM as central data-management component. The source code was constantlyextended to support further entity types (i.e., new lists), whichraised a problem related to resource consumption.”Memory was an issue on the ﬁrst computers. They have8MB and you have to get data and executable code in there.Actually the lists didn’t take up that much code, but it wasan issue [...] with all the communication lists and all thecommunication related Operational Processing Functions.”This issue has been addressed with a clone-and-own approach.Some of the lists belong to Operational Processing Functionsthat realize internal control applications, which handle onlyprivate data. These data are never printed on graphical displaysor transferred to other devices. However, due to the implemen-tation as generic package, each list allocates data structuresfor data-transfer functionality, regardless of whether used ornot. Ultimately, a lesser memory footprint could be achievedby creating a slimmed-down copy of the original LSTMscode, in which data structures and functionality related todata transfer have been removed. The implementation requiredapproximately 2 person months.Navigation list:In 2012, the replacement of the data-management component was initiated. The most importantargument emerged from one engineering change request:”There was one big effort when the navigation list came,because there we had to program all the links which arenot in the list generic.”The mapping of the navigation data to the LSTM was difﬁcult.It requires multiple entity types that relate to each other. Forexample, routes are basically sets of route points, which arein turn deﬁned by different types of guidance points, such asairports or hospitals. The architectural design of the LSTM wasnever intended to support such complex data dictionaries. Thiscaused considerable complications regarding data storage andaccess, since there is no mechanism for maintaining referentialintegrity. To solve this problem, a separate wrapper was addedto the LSTM. It enriches the navigation lists by a proper
Development ToolVeriﬁcation & Validation AssetsQualiﬁed VariantGenerationQualificationSource Code
NoteNoteFig. 3: Asset-based development of qualiﬁed avionics softwareaccess interface, which controls data manipulation in termsof consistency and integrity constraints.”[...] and this is where an effort came with another yearto implement. It is maybe the set of requirements that isdifﬁcult. You have to re-think your logic and you have tore-implement this relationship.”Due to the rigorous programming constraints for mission-critical avionics software, the code of the solution is strictlytailored to the speciﬁc use case. It cannot be re-used in differentscenarios (i.e., for varying entity types).G. Key Insights•The development of qualiﬁcation assets for the LSTM wasexpensive, adding about 8.5 person months to the totalimplementation time of 18 person months (45% increase).•A major maintenance effort arises from the realization ofnew functional- and non-functional requirements.•Long-term stability of system requirements is unlikely.Customer requests and new equipment hardware demandconstant modiﬁcations.•The severity of new system requirements varies consid-erably. The technical realization of severe requirementsdemands up to 12 person months of additional develop-ment time, which is an increase of 45% compared to theinitial effort for implementation and qualiﬁcation of 26.5person months.Based on these ﬁndings, we started working on an appropriatesolution for data management in the NH90 avionics software.IV. DESIGNDECISIONS ANDINTEGRATIONRigorous non-functional requirements in combination withstrict coding constraints impose a challenge for a single qualiﬁ-able implementation of the EDB — the new data-managementsolution. These requirements state that the source code of avariant must be tailored to correspond exactly to the speciﬁcequipment conﬁguration and the accessory hardware–softwareco-design of the target system. Avariation pointis a locationin the software that differs in individual variants of the system.In the case of NH90’s data management, variation points arisefrom various low-level functional requirements, such as thepresence of a table or column with a speciﬁc size or datatype. Accordingly, there are many possibilities to derive EDBvariants. As a consequence, an appropriate technical realizationrequires a sophisticated re-use strategy.Next, we compare the two development approaches es-tablished in the avionics domain regarding their applicabilityto multi-variant software systems. In addition, as a corecontribution, we introduceasset-baseddevelopment as a novelapproach.A. Assessment of Established Development ApproachesThe practicability of a development approach depends onthe combination of implementation, qualiﬁcation, and main-tenance effort. To decide whether to use code-based or tool-based development (see Section II), we compare their trade-offs regarding initial effort and effort per variant regardingthese three development activities. We deﬁne the initial effortas the effort required for setup and development of the initialvariant.Incode-baseddevelopment, the initial effort boils downto the manual implementation and qualiﬁcation of the ﬁrstvariant. The approach demands substantial additional budgetand schedule to develop and maintain subsequent variantsby individually adapting or re-implementing source code andqualiﬁcation assets. Although the number of software vari-ants is relatively small (currently 45), multi-variant softwaresystems based on code-based development are hard to grow,since each individual variant must be qualiﬁed and maintained.There is no automatic process to obtain certiﬁcation creditfor unchanged parts of the another software variant. However,some qualiﬁcation assets can be re-produced (e.g., the resultsof the unit tests of unmodiﬁed code).Tool-baseddevelopment relies on tool support. The under-lying generative approach increases quality of the software andfacilitates implementation by generating variants. As no furtherassets are required, the costs for deriving additional variants arereduced to the speciﬁcation as input for the generator tool. Thedisadvantages are huge initial expenses for either purchasinga pre-qualiﬁed commercial tool or developing and qualifyingan appropriate tool in-house.From an economic point of view, it turned out in ourinterview that both code-based and tool-based developmentare impractical for the technical realization of the EDB atAirbus Helicopters. Regarding project parameters, such as thenumber of variants, degree of variability, and potential artifactsize, the cost–beneﬁt ratio is unsatisfactory. To overcome theseproblems, we propose asset-based development.B. Asset-based DevelopmentThe key idea of asset-based development is to combinecode-based and tool-based development, such that we keep theinitial effort feasible, while reducing the effort of maintainingand qualifying a growing number of variants (Figure 3). To thisend, we use model-based and product-line techniques to gener-ate implementation and qualiﬁcation assets that are used for thecode-based qualiﬁcation process. That is, instead of qualifyingthe code generator, as in the tool-based approach, we generateassets that substantially reduce the effort for qualifying thegenerated source code. Following a model-based approach,we create a declarative system speciﬁcation, which is thenautomatically transformed by a non-qualiﬁed generator toolto software artifacts and supplementary qualiﬁcation assets,such that they are amenable to requirement-based testing interms of DO-178. This includes the automatic generation offunctional tests, unit tests at 100% statement coverage, andtraceability evidence to low-level system requirements. Thesequaliﬁcation assets are intended to signiﬁcantly facilitate qual-iﬁcation for each variant. This way, we obtain beneﬁts fromthe generative approach, such as a reduced time-to-market andsoftware quality, while avoiding the high initial costs for eitherpurchasing or developing a fully qualiﬁed tool in-house. The
EDB Metamodel Model Transformation Rules 
EDB Data Model EDB Variant Model Code GeneratorDomainEngineering
EDB Source CodeRequirementsSpeciﬁcation Application Engineering
Functional TestsUnit TestsTraceability EvidenceData GeneratorFig. 4: Overview of the EDB development processasset-based approach does not violate aerospace standards andis fully compliant with DO-178 (civilian aviation) and DOD-STD-2167 (military aviation).C. ImplementationAs illustrated in Figure 4, our approach follows the classicproduct-line process [11], dividing the development into do-main and application engineering. Since data management isused by developers from various backgrounds and divisions,we decided to use a speciﬁcation and conﬁguration mechanismthat is expressive and easy to learn. To this end, we createda domain-speciﬁc language in the form of a set of SysMLmetamodels (domain engineering) [12]. It is used to deﬁne adescriptive system speciﬁcation of a family of EDB variants,consisting of a data model to determine the storage structureand a variability model to deﬁne equipment-speciﬁc varia-tions. During application engineering, the stakeholder createsappropriate SysML models according to her requirements(i.e., equipment and hardware speciﬁcations). Thereupon, acorresponding model transformation is invoked, and a codegenerator instantiates the model-transformation rules, based onsource-code templates, with information extracted from thegiven SysML models. To compose the source code of thetarget EDB variant, the code generator supplements prefab-ricated database parts with glue code and the resulting codecomponents of the model transformation.To facilitate qualiﬁcation, unit tests, functional tests, andtraceability evidence are derived from the declarative systemspeciﬁcation on the basis of generic test cases, also imple-mented as source-code templates. The tests require a consistentand integral database instance of the target EDB variant tooperate on. Therefore, the code generator is connected to adata generator, which receives a normalized relational databaseschema from the data model as input. Then, the data generatorinstantiates the schema with randomly generated values ac-cording to a predeﬁned distribution with respect to foreign-keyintegrity and type-speciﬁc value ranges (e.g., -90.0 to +90.0for the typeLatitude). The resulting tuples are passed tothe code generator, which is now aware of a consistent andintegral database instance. Finally, the source code to ﬁll atest instance as well as associated functional tests, unit tests,and traceability evidence are generated.In terms of tooling, we decided to use open-source softwareonly. It is required by law that the manufacturer of an aircraftis capable to maintain the software across the entire life cycle.Mainly due to its very long-term support, we used PolarSys[13], an open-source tool suite for embedded, model-based,mission- and safety-critical systems. We applied PolarSys tocover all tasks of domain engineering and application engi-neering. With the modeling component Papyrus, we speciﬁedthe domain-speciﬁc language as well as an initial instanceof a data model and a variability model. We implementedthe model-transformation rules using the component Acceleo,which requires OCL [14] as meta-language for the source-codetemplates. Ultimately, we created 24 templates for 12 logicalcomponents of the EDB, 9 templates for test cases, and 2templates to generate test instances. This way, we generatedfully qualiﬁable EDB variants in the programming languagesAda83 and Ada95. Overall, our approach relies on standardtechniques, but combined in a novel way to face the data-management challenges in the avionics domain.A generated variant of the EDB is already integrated asthe new data-management component in the software of theMission Tactical Computerof the NH90. Mainly, it handlescomplex data related to area navigation and radio communi-cation.V. DISCUSSION ANDPERSPECTIVESIn this section, we compare code-based and asset-baseddevelopment by means of the example of the LSTM (old data-management component) and the EDB (new data-managementcomponent). To this end, we systematically review the evo-lution using the real-world scenarios reported in the devel-oper interview (see Section III). We categorize the scenariosaccording to their severities. For each of the categories, wedescribe the proceedings for the technical realization of thesubject, once in context of the LSTM and once in contextof the EDB. This way, we discuss weaknesses and strengthsof code-based and asset-based development. Since there is nocomparable data-management component implemented withtool-based development, an analysis of the tool-based approachremains subject to further work.A. NH90 Maintenance DataTo learn about the frequency of maintenance and evolutiontasks regarding data management, we collected maintenancedata of the NH90 avionics software from two sources. First,we accessed the software repository of two core avionicscomputers of the NH90. Second, we analyzed the source-code ﬁles of the data-management component of the same twoavionics computers. The software repository contains entriesof over 18 years, from 1996 until 2014. For each entry, thereis a short description of the issue, the current status, the dateof creation, and the date of the last modiﬁcation. The data setis divided into three subsets:•Problem Report(PR): describes a situation in which asoftware component is not working as intended. PRs areinitiated by engineers, managers, or software developersto inform project members (including customers) aboutproblems in the source code. Typically, PRs are raised ifa problem is of inter-divisional interest, for example, if itoccurs on the software test bench or at test ﬂights.•Engineering Change Request(ECR): describes a requestto adjust the software. ECRs arise from new systemrequirements, feature requests from customers or devel-opers, and changes in the aerospace standards.•Software Change Note(SCN): documents a softwaremodiﬁcation at a technical level. SCNs are linked to thecausing PRs or ECRs in a many-to-many relationship.As a second source, we examined procedure headers of thesource-code ﬁles of the same two avionics core computers.The headers are auto-generated by the version-control systemand include a full revision history of the target procedure.We parsed 10,768 source-code ﬁles, containing 1,812,289procedure headers with 24,907,787 revisions in total. In 42.7%(10,647,287) of the annotations, we were able to extract a ref-erence to an SCN, which relates these revisions to maintenanceand evolution. The remaining revisions are related to progressin the development process. We transformed the data in bothrepositories into a uniﬁed format, stored them in a database,and joined them on the SCN identiﬁer. This way, we enrichedthe data in the software repository with ﬁle-level information.By means of the folder structure of the source-code ﬁles, wewere able to assign entries in the software repository to logicalsoftware components. Ultimately, we identiﬁed PRs, ECRs,and SCNs related to data management. We start our discussionwith a comparison of initial effort of LSTM and EDB.B. Comparison of Initial EffortFrom the developer interview, we learned that the initialeffort of implementing and qualifying the LSTM amounts to26 person months, which is about 4,160 person hours. Forthe EDB, we estimate 4,848 person hours in total: 3,736person hours development time and 1,112 person hours foradaptation, deployment, and integration at Airbus Helicopters.The majority of effort required to develop the EDB wasspend by the ﬁrst author on the implementation of model-transformation rules (i.e., source-code templates). At ﬁrst, weexperienced a signiﬁcant overhead in programming in OCL.This overhead decreased rapidly with growing experience,such that we could implement templates in OCL as fast assource code in Ada. In this context, asset-based developmentinvolved a 17% higher initial effort due to the integration andfamiliarization of development tools.In the next four subsections, we describe exemplary eventsand examine their effects on the evolution of the data-management component of the NH90 from the perspective ofboth systems. The discussion aims at establishing a descrip-tive and explorable model to assess and identify factors thatinﬂuence maintenance and evolution in the avionics domain.All ﬁgures are meant as an illustration of the events and theircorresponding effects, not for quantitative prediction.C. Deriving Software System VariantsTo derive a new variant of the LSTM, the set of supportedentity types has to be tailored manually by removing, changing,or adding lists in the source code. As reported in the developerinterview, one extension demands about 8 person hours ofdevelopment time. By contrast, the EDB does not demand anymodiﬁcations in source code. Each extension is performed inthe declarative system speciﬁcation (i.e., in the SysML mod-els). To remove, change, or add an entity type, correspondingmodel elements have to be added to the data model and appliedwith stereotypes conﬁguring variant-speciﬁc properties. Aswe ﬁrst created a new data model similar to the entities ofthe LSTM, it required 2 person hours of development time.Naturally, this value depends on the size and complexity of thedata schema and may vary in different scenarios. The modeltransformation to obtain the source code of the target variantis performed within seconds.Figure 5 shows the extrapolation of development time∆(generic_inst)∆(data_model)45005000050100150Number of ExtensionsTotal Development Time (h)ImplementationEmbedded DatabaseList ManagementFig. 5: Effort to modify the set of entity typesto derive a new variant of the LSTM and of the EDB. They-axis depicts the total time for providing source code andqualiﬁcation assets in person hours. The x-axis covers thenumber of extensions in the set of entity types. The valuesof both systems start with an offset for the initial effort andgrow in relation to the required development time. The ratiois illustrated as (genericinst), in the case of the LSTM,and (datamodel), in the case of the EDB. In this scenario,code-based development outperforms asset-based developmentfor a long time. We assume that the break-even point will notbe reached until the end of the life cycle of the NH90. Up tonow, the LSTM was extended to support 30 additional entitytypes.D. Code Re-Use with Clone And OwnThe developers at Airbus resolved two issues in the lifecycle of the LSTM by applyingclone and ownas a re-use strategy. The scenariomemory optimizationfrom thedeveloper interview (see Section III) falls into this category.The approach was used to deploy a solution to a subset of theinstantiated lists. For this purpose, the generic package of theLSTM was copied and adapted to satisfy the requirement.The clone-and-own approach has two major drawbacks,which we illustrate in Figure 6. The y-axis depicts the totaldevelopment time for implementation and qualiﬁcation, withan offset for initial effort. The x-axis represents progress inevolution. The grey areas illustrate the two phases where anew requirement was realized using clone and own.As a ﬁrst drawback, in addition to the effort required to per-form a code change, copied source code must also be qualiﬁed,which involved about 320 person hours for each case in theLSTM. These efforts are illustrated with (cloneandown)assharp increase in development time. For the EDB, the effort isreduced to perform the actual code changes. Contrary to code-based development, asset-based development transforms modelelements to source code. This way, we exploit the generativeapproach to add or remove functionality by integrating con-ditional units directly into the generic application logic (i.e.,introducing new variation points), instead of adapting a codeclone manually.Regardingmemory optimizationas a what-if scenario in thecontext of the EDB, unnecessary data structures or procedureswould be encapsulated as conditional units, which would bepresent in the target source code only if the functionality is in-cluded in the declarative system speciﬁcation of a desired vari-ant. Due to the automatic generation of unit tests and functionaltests, adjustments in terms of qualiﬁcation assets are reduced toNew Requirement∆(clone_and_own)450050005500
EvolutionTotal Development Time (h)ImplementationEmbedded DatabaseList ManagementFig. 6: Effort required to realize evolution tasks by clone and ownthe speciﬁcation of generic test cases. Whenever functionalityis removed, as inmemory optimization, no additional effortfor qualiﬁcation is required. Overall, we approximate the totaldevelopment time for the technical realization of this scenariofor the EDB at about 80 person hours.As a second negative effect of using a clone-and-ownapproach, we identiﬁed increased costs related to maintenanceand evolution after cloning. This situation occurs if a PR orECR concerns code clones. Let us assume, we found changesthat were performed in original source-code ﬁles as well asin two clones A and B. Analyzing the software repository ofthe NH90 in this hindsight, we found 14 intersecting SCNsin the original system and clone A, 5 intersecting SCNs inthe original system and clone B, and no intersecting SCNsin clones A and B. We identiﬁed such additional effort in 19cases. We added up the time intervals of these intersectingSCNs and determined the ratio to the sum of the time intervalof all SCNs in the original system (74 found). This way,we estimate the overhead in development time for the 19intersecting SCNs related to the clone-and-own approach inthe LSTM at 24%. We illustrate this effect as an increasedslope after cloning in Figure 6.In summary, asset-based development improves mainte-nance and evolution in terms of code re-use regarding twoaspects: It reduces the effort required to realize changes withconditional units and code generation, and it entirely eliminatesthe drawbacks arising from using a clone-and-own approach.E. Software Changes in Generic Parts vs. Speciﬁc PartsSo far, we have considered only non-severe requirementchanges, which were realized in the LSTM by means of a mod-iﬁcation of the generic package, as in the scenariohardwareplatform(see Section III). Severe requirement changes, as inthe scenarionavigation list(see Section III), however, requirea speciﬁc solution. To explore the factors of maintenanceand evolution effort related to changing generic and speciﬁcparts of the source code, we analyzed the implementationof the LSTM in this regard. As generic part, we consideredeach line of source code that is re-used either by parametricpolymorphism in a generic package or by clone and own. Weassume that the remaining lines of code constitute speciﬁcfunctionality, which consider the speciﬁc part.Overall, we parsed 57,181 revisions in the generic partof the LSTM. 21,907 (38.3%) of the revisions contain anSCN and thus are considered as relevant for maintenance andevolution. In total, we identiﬁed 90 SCNs, which are related to94 PRs and 10 ECRs. The effort for these tasks is basically theNew Requirement
∆(navigation_list)450050005500
EvolutionTotal Development Time (h)ImplementationEmbedded DatabaseList ManagementFig. 7: Effort required to realize a severe evolution tasksame for code-based and asset-based development, since thetechnical realization affects the generic part of the software andthe qualiﬁcation assets to equal shares (i.e., generic packagesof the LSTM and source-code templates of the EDB).Analogously, we analyzed the speciﬁc part of the LSTM.It contains 165,278 revisions in total, where 83,023 (50.2%)are relevant for maintenance and evolution. In total, we iden-tiﬁed 536 SCNs, related to 474 PRs and 97 ECRs. With 6times more SCNs targeting speciﬁc parts, our data indicatea considerable increase in occurrences of software changesrelated to maintenance and evolution than in the genericpart. Regarding the number of revisions, which has increasedby a factor of 3, the frequency of software changes in thespeciﬁc part of the LSTM is doubled compared to the genericpart. In particular, there is an exceptionally higher numberof ECRs (almost factor 10). This shift shows the increasedsigniﬁcance of realizing new requirements in speciﬁc variantsof the considered software. Next, we discuss the scenarionavigation listfrom the developer interview as representativeexample for the severity of changes of this kind.The interviewees explained that the navigation-list require-ment was realized in the LSTM by implementing a wrapperaround the instantiation of navigation lists with an additionalinterface for data access, to maintain referential integrity andconsistency. For the EDB, this scenario required the adaptionof the domain-speciﬁc language to specify a model elementthat relates entity types in the declarative system speciﬁcation.To this end, we used instances ofSysML::Associationto linkSysML::Blocks— the model elements that represent entitytypes in the data model. We realized this complex requirementby implementing conditional units that were integrated in thesource-code template for query processing.Regarding qualiﬁcation, we deﬁned a generic test set thatcovers the additional functionality. We integrated it into thesame template to automatically generate suitable test cases,amenable for requirement-based testing. Finally, these testcases have been automatically instantiated with valid data fromthe data generator, to create actual unit tests and functionaltests compliant to DO-178.Figure 7 compare the development time required to realizethe scenarionavigation listin the context of the LSTM and theEDB. The axes are as in Figure 6. The grey area illustratesthe phase in which a new requirement arose. The effort forrealizing this severe requirement in the LSTM is illustratedwith (navigationlist)as a stark increase in developmenttime. The developers of the LSTM estimated the effort atabout 12 person months in total, that is 1,432 person hours.The ratio of required effort associated to qualiﬁcation is thesame as for new developments, which was estimated in theinterview at about 45%. In the case of the EDB, we estimatethe development time to 504 person hours, where 24 personhours are spent on extending the domain-speciﬁc language,400 person hours to develop model-transformation rules, and80 person hours to deﬁne and implement the set of test cases.In summary, asset-based development can reduce the effortand cost for implementation and qualiﬁcation compared tocode-based in a severe scenario, such asnavigation list, byalmost two third, which may compensate the higher initialeffort that is required by asset-based development.F . Lessons LearnedAnswering the question of whether code-based, tool-based,or asset-based development is the most suitable approachfor a speciﬁc subject matter depends on an estimation ofthe initial effort and a detailed assessment of potential tasksrelated to maintenance and evolution. In safety-critical appli-cation domains, where the software has to pass a qualiﬁcationprocess, strict coding constraints often demand a tailoredsolution for a speciﬁc problem. Our analysis demonstrates thepotentially high severity of maintenance and evolution tasksin these domains. Real-world scenarios considering severe newrequirements have shown that the technical realization requiresup to one third of the initial development cost. However,the efﬁciency of a development approach depends on theparameters of the target system. If the system requirements arestable or changes are very unlikely, code-based developmentmay still outperform asset-based development. In cases wheremaintenance and evolution is likely, such as in the data-management of the NH90, asset-based development appears tobe an efﬁcient and practical development approach. Regardingtool-based development, further studies are required to exploreits application in software systems, in which maintenance andevolution contribute to a majority of the effort.VI. THREATSTOVALIDITYOur approach to assign source-code ﬁles to logical softwarecomponents based on the folder structure might unintentionallyexclude ﬁles, which threatens internal validity. It is possiblethat semantically related source-code ﬁles are located in differ-ent folders. The PRs, ECRs, and SCNs of these ﬁles might havebeen mismatched. However, through personal communicationwith a senior developer who is familiar with the system asa whole, we have been informed that the source ﬁles of theLSTM as subject matter of our study are well encapsulatedand not scattered over multiple folders or packages.A second threat to internal validity arises from our assump-tion that our data basis is free of defective entries. After man-ually reviewing the textual description of all affected entries(PRs, ECRs, and SCNs), we could not ﬁnd any duplicates,but we cannot guarantee that the repository does not includeinvalid items (e.g., PRs that could not be replicated).Regarding external validity, one could argue that insightsgained from an interview of two developers cannot be used tojustify general statements. Nonetheless, one of the intervieweesis the head developer of the data-management component andhas, much like the second interviewee, decades of experiencein the ﬁeld of avionics software engineering. Furthermore, theirapproximation of the ratio of effort for implementation andqualiﬁcation of the LSTM, as case example of a complexavionics software, agrees with the results of previous work[15] (coding makes up 16%, where unit tests, functional tests,and design reviews sum up to 9% of the total developmentcosts of military avionics software).VII. RELATEDWORKAs a ﬁrst systematic report on achieving beneﬁts fromadopting product-line technology in complex avionics soft-ware, Sharp suggested a logical pattern-driven design to facil-itate the integration of predeﬁned components in the avionicssoftware in the context of the Bold Stroke Initiative at theBoeing Company [16]. A similar approach was proposed byGanesan et al. at the NASA Goddard Space Flight Center.The authors use a layered architecture to re-use modules,conﬁgurable for mission-speciﬁc needs in the Core FlightSoftware (software platform for NASA missions) [17]. Bothapproaches rely on product-line engineering to build hardware-and mission-speciﬁc variants of the avionics software. Theauthors focus on exploring domain and application designrather than facilitating the development process by addressingthe challenges of qualiﬁcation that prevail in the avionicsdomain.Regarding the application of model-based methods in theaerospace industry, Batory et al. suggest GenVoca, a domain-independent model for hierarchical systems as compositionsof reusable components, to create a reference architecture foravionics software synthesis [18]. Similar to the work of Sharpand Ganesan et al. the authors present lessons learned inapplying model-based techniques to improve the applicationdesign, but do not target qualiﬁcation. Hovsepyan et al. reporton an enhancement of the development life cycle at SpaceApplications Services by means of a model-based developmentprocess to establish traceability of system requirements acrossthe phases of the V model [19]. In the work of Dubois et al. atthe Thales Group, model-based methods have been applied inthe form of a domain-speciﬁc language in SysML to supportdomain engineering in context of product-line engineering inthe CEASAR project [20]. Analogous to Hovsepyans work,Dubois et al. used models for maintaining traceability ofsystem requirements to application components, but they donot target code generation or qualiﬁcation. Delange et al.[21] propose model-based engineering to capture architecturerequirements using the AADL modeling language. Their ap-proach exploits AADL models to validate non-functional re-quirements, such as resource dimensioning through simulation,but they did not consider qualiﬁcation obligations.There are model-based and generative approaches to de-velop software systems based on the ARINC 6536speciﬁcation[22]. Horvth et al. [23] discuss model-driven engineering asan approach to systematically develop conﬁguration data. Asimilar strategy is described by Choi et al. [24]. They presenta tool to generate XML conﬁguration ﬁles for an ARINC 653compliant operating system. In contrast to our approach, theauthors apply code generation to derive conﬁguration assets,not qualiﬁcation assets.With Matlab Simulink7and Esterel SCADE8, there are two6A standard for space and time partitioning in avionics operating systems7http://de.mathworks.com/products/simulink/8http://www.esterel-technologies.com/products/scade-suite/commercial products that can be considered as the de factostandard tool set for tool-based development. Both providemodel-based design and code-generation capabilities. EsterelSCADE was successfully applied at Airbus to develop thesoftware for the ﬂight control computers of multiple aircrafts,such as the Eurocopter EC 135/155 and the Airbus A340/500[25]. The share of automatically generated code was 70%,which reduced the change cycle time by a factor of 3 to 4compared to manual coding. Both projects showed complianceto Design Assurance Level A. However, these tools aim atgenerating source code for the most critical components of asystem and require a model-based speciﬁcation at a very lowlevel of abstraction, which is inappropriate to handle complexdata-management functionality.Bridges et al. and Dorodwsky et al. describe the successfulapplication of a generative approach at Airbus Helicopterswithout applying commercial tools [5] [26]. They use tool-based development based on an in-house tool chain based ona fully qualiﬁed code generator. It produces software artifactsfor low level components of the NH90 System Software, suchas the real-time tasking model, processor allocation, and rawdata I/O. The authors identiﬁed qualiﬁcation as key factor, butdid not provide any details on the process.VIII. CONCLUSIONIn our experience report, we described the enhancementof the data-management component of the NH90 helicopterat Airbus Helicopters. In a semi-structured interview with twoprofessional developers, we gained deep insights into the in-dustrial practice of developing qualiﬁed avionics software. Wefound that established development approaches are not feasibleto cope with the challenges of realizing data management insuch an highly sensitive environment.To address problems regarding implementation and qual-iﬁcation effort, especially in the face of software evolution,we propose asset-based development as a novel generativeapproach to develop avionics software. Using model-basedand product-line technology, we successfully implemented theEmbedded Database, a software product line and a generatorinfrastructure to generate fully qualiﬁable variants of real-timeembedded database management systems, which is alreadyintegrated in the NH90 development environment to replacethe former system.By a systematic comparison of the former data-manage-ment component and our solution, we identiﬁed signiﬁcantimprovements when using asset-based development, in termsof ﬂexibility and efﬁciency of realizing tasks related to main-tenance and evolution. Discussing a number of real-world evo-lution scenarios with data collected from the NH90 softwarerepository and the developer interview, we demonstrated thelikelihood and the potential severity of these tasks, and weidentiﬁed the main cost drivers of evolution. Finally, our resultsare not restricted to data management in the avionics domainand may help developers to choose a suitable developmentstrategy in domains where qualiﬁcation plays a key role.IX. ACKNOWLEDGMENTThis work has been supported by the German ResearchFoundation (AP 206/4, AP 206/5, AP 206/6).REFERENCES[1]DO-178C/ED-12C: Software Considerations in Airborne Systems andEquipment Certiﬁcation, RTCA/EUROCAE Std., 2011.[2]E. Thomas, “Certiﬁcation Cost Estimates for Future CommunicationRadio Platforms,” Rockwell Collins Inc., Tech. Rep., 2009.[3]V. Hilderman, “DO-178B Costs versus Beneﬁts,” Consunova Inc., Tech.Rep., 2009.[4]F. J. v. d. Linden, K. Schmid, and E. Rommes,Software Product Linesin Action: The Best Industrial Practice in Product Line Engineering.Springer, 2007.[5]R. Bridges, “NH90 Helicopter Avionics Systems from the 1990s to2010 and beyond,” inProc. Workshop on Software-Architekturen f¨urOnboardsysteme in der Luft- und Raumfahrt. Deutsche Gesellschaftf¨ur Luft- und Raumfahrt, 2007.[6]DOD-STD-2167A: Defense System Software Development, Departmentof Defense Std., 1985.[7]DO-333/ED-216: Formal Methods, RTCA/EUROCAE Std., 2011.[8]W. Wong, A. Demel, V. Debroy, and M. Siok, “Safe Software: Does ItCost More to Develop?” inProc. Int’l Conf. Secure Software Integrationand Reliability Improvement (SSIRI). IEEE CS, 2011, pp. 198–207.[9]DO-330/ED-215: Software Tool Qualiﬁcation Considerations,R T -CA/EUROCAE Std., 2011.[10]A. Jedlitschka and D. Pfahl, “Reporting Guidelines for ControlledExperiments in Software Engineering,” inProc. Int’l Symposium onEmpirical Software Engineering (ISESE). IEEE CS, 2005, pp. 95–104.[11]K. Pohl, G. B¨ockle, and F. J. v. d. Linden,Software Product LineEngineering: Foundations, Principles and Techniques. Springer, 2005.[12]OMG Systems Modeling Language (OMG SysML), Version 1.3, ObjectManagement Group Std., 2012.[13]G. Blondelle, P. Arbaret, A. Rossignol, B. Lundell, C. Labezin,R. Berrendonner, P. Gauﬁllet, R. Faudou, B. Langlois, L. Maisonobe,P. Moro, J. Rodriguez, J. M. Puerta Pena, E. Bonnafous, and R. Mueller,“PolarSys: Towards Long-Term Availability of Engineering Tools forEmbedded Systems,” inProc. European Congr. Embedded Real TimeSoftware and Systems (ERTS). ERTS, 2012, pp. 1–8.[14]OMG Object Constraint Language (OCL), Version 2.3.1, Object Man-agement Group Std., 2012.[15]C. Jones, “Software Cost Estimation in 2002,”CrossTalk: The Journalof Defense Software Engineering, vol. 15, no. 6, pp. 4–8, 2002.[16]D. C. Sharp, “Reducing Avionics Software Cost Through ComponentBased Product Line Development,” inProc. Int’l Digital AvionicsSystems Conf. (DASC). IEEE CS, 1998, pp. 1–8.[17]D. Ganesan, M. Lindvall, C. Ackermann, D. McComas, andM. Bartholomew, “Verifying Architectural Design Rules of the FlightSoftware Product Line,” inProc. Int’l Software Product Line Conference(SPLC). ACM Press, 2009, pp. 161–170.[18]D. Batory, L. Coglianese, M. Goodwin, and S. Shafer, “Creating Ref-erence Architectures: An Example from Avionics,” inProc. Symposiumon Software Reusability (SSR). ACM Press, 1995, pp. 27–37.[19]A. Hovsepyan, D. V. Landuyt, S. Beeck, S. Michiels, W. Joosen,G. Rangel, J. F. Briones, and J. Depauw, “Model-Driven Software De-velopment of Safety-Critical Avionics Systems: An Experience Report,”inProc. Int’l Workshop on Model-Driven Development Processes andPractices. CEUR Workshop Proceedings, 2014, pp. 28–37.[20]H. Dubois, V. Ibanez, C. Lopez, J. Machrouh, N. Meledo, and A. Silva,“The Product-Line Engineering Approach in a Model-Driven Process,”inProc. European Congr. Embedded Real Time Software and Systems(ERTS). ERTS, 2012, pp. 1–9.[21]J. Delange, L. Pautet, A. Plantec, M. Kerboeuf, F. Singhoff, andF. Kordon, “Validate, Simulate, and Implement ARINC653 SystemsUsing the AADL,”Ada Lett., vol. 29, no. 3, pp. 31–44, 2009.[22]Avionics Application Software Standard Interface - ARINC Speciﬁcation653 - part 1, AEEC Std., 2006.[23]A. Horvath, D. Varro, and T. Schoofs, “Model-Driven Development ofARINC 653 Conﬁguration Tables,” inProc. Digital Avionics SystemsConf. (DASC). IEEE CS, 2010, pp. 1–15.[24]E.-T. Choi, O.-K. Ha, and Y.-K. Jun, “Conﬁguration Tool for ARINC653 Operating Systems,”Journal of Multimedia and Ubiquitous Engi-neering, vol. 9, no. 4, pp. 73–84, 2014.[25]J.-L. Camus and B. Dion, “Efﬁcient Development of Airborne Softwarewith SCADE Suite,” Esterel Technologies S.A.S., Tech. Rep., 2003.[26]F. Dordowsky, R. Bridges, and H. Tschope, “Implementing a SoftwareProduct Line for a Complex Avionics System,” inProc. Int’l SoftwareProduct Line Conference (SPLC). ACM Press, 2011, pp. 241–250.