Template-Guided Concolic Testing via Online Learning
Sooyoung Cha
Korea University
Republic of Korea
sooyoungcha@korea.ac.krSeonho Lee
Korea University
Republic of Korea
seonho_lee@korea.ac.krHakjoo Ohâˆ—
Korea University
Republic of Korea
hakjoo_oh@korea.ac.kr
ABSTRACT
We present template-guided concolic testing, a new technique for
effectivelyreducingthesearchspaceinconcolic testing.Address-
ing the path-explosion problem has been a significant challenge
inconcolictesting.Diversesearchheuristicshavebeenproposed
to mitigate this problem but using search heuristics alone is not
sufficienttosubstantiallyimprovecodecoverageforreal-worldpro-
grams.Thegoalofthispaperistocomplementexistingtechniques
and achieve higher coverage by exploiting templates in concolic
testing. In our approach, a template is a partially symbolized input
vector whose job is to reduce the search space. However, choos-
ing a right set of templates is nontrivial and significantly affectsthe final performance of our approach. We present an algorithmthat automatically learns useful templates online, based on datacollected from previous runs of concolic testing. The experimen-
tal results with open-source programs show that our technique
achievesgreaterbranchcoverageandfindsbugsmoreeffectively
than conventional concolic testing.
CCS CONCEPTS
â€¢Software and its engineering â†’Software testing and de-
bugging;
KEYWORDS
Concolic Testing, Online Learning
ACM Reference Format:
SooyoungCha,SeonhoLee,andHakjooOh.2018.Template-GuidedCon-
colic Testing via Online Learning. In Proceedings of the 2018 33rd ACM/IEEE
International Conference on Automated Software Engineering (ASE â€™18), Sep-
tember3â€“7,2018,Montpellier,France. ACM,NewYork,NY,USA, 11pages.
https://doi.org/10.1145/3238147.3238227
1 INTRODUCTION
Concolic testing [ 11,22] is a popular software testing method that
effectively and systematically achieves high code coverage and
finds bugs. The key idea of concolic testing is to simultaneously
execute a program concretely and symbolically, where new test
casesaresystematicallygeneratedbysymbolicexecutionenhanced
âˆ—Corresponding author
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE â€™18, September 3â€“7, 2018, Montpellier, France
Â© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.3238227withconcreteexecution.Recently,concolictestinghasbeenused
in diverse application domains such as operating systems [ 18],
firmware [8, 16,31], and binary code [1, 25] among many others.
A major open challenge in concolic testing is how to effectively
explore the search space. As the number of execution paths in a
realistic program grows exponential, concolic testing must be able
to favor and explore the paths that are most likely to benefit the
finaltesting results.However,guiding concolictesting effectively
isnontrivialandmanydifferentapproaches existwiththegoalof
mitigating the path-explosion problem: e.g., path pruning [ 2,3,17,
28], search heuristics [4, 5,19,23,29], and so on.
Inthispaper,wepresenttemplate-guidedconcolictesting,anew
technique for adaptively reducing the search space of concolic test-
ing.Thekeyideaistoguideconcolictestingwithtemplates,whichrestricttheinputspacebyselectivelygeneratingsymbolicvariables.
Unlike conventional concolic testing that tracks all input values
symbolically, our technique treats a set of selected input values
as symbolic and fixes unselected inputs with particular concreteinputs, thereby reducing the original search space. A challenge,
however, is choosing input values to track symbolically and replac-
ingtheremaininginputswithappropriatevalues.Toaddressthis
challenge, we develop an algorithm that performs concolic testing
while automatically generating, using, and refining templates. The
algorithm is based on two key ideas. First, by using the sequential
pattern mining [ 9], we generate the candidate templates from a set
ofeffectivetest-cases,wherethetest-casescontributetoimproving
codecoverageandarecollectedwhileconventionalconcolictest-
ing is performed. Second, we use an algorithm that learns effective
templates from the candidates during concolic testing. Our algo-rithm iteratively ranks the candidates based on the effectiveness
of templates that were evaluated in the previous runs. Our tech-
nique is orthogonal to the existing techniques and can be fruitfully
combined with them, in particular with the state-of-the-art search
heuristics.
Experimental results show that our approach outperforms con-
ventional concolic testing in term of branch coverage and bug-
finding. We have implemented our approach in CREST [ 7] and
compared our technique with conventional concolic testing for
open-source C programs of medium size (up to 165K LOC). For all
benchmarks, our technique achieves significantly higher branch
coveragecomparedtoconventionalconcolictesting.Forexample,
forvim-5.7,wehaveperformedbothtechniquesfor70hours,where
our technique exclusively covered 883 branches that conventional
concolic testing failed to reach. Our technique also succeeded in
findingrealbugsthatcanbetriggeredinthelatestversionsofthree
open-source C programs: sed-4.4, grep-3.1 and gawk-4.21.
408
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. ASE â€™18, September 3â€“7, 2018, Montpellier, France Sooyoung Cha, Seonho Lee, and Hakjoo Oh
This paper makes the following contributions:
â€¢We present template-guided concolic testing, a new tech-
nique for reducing the input space by selectively generating
symbolic values without any prior domain knowledge.
â€¢We present an online learning algorithm to select useful
templates from previous runs of concolic testing.
â€¢We extensively compare our technique with conventional
concolictestingonopen-sourceCprograms.Wemakeour
tool, called ConTest, and data publicly available.1
2 OVERVIEW
In this section, we illustrate our approach with an example.
2.1 Motivating Example
Fig.1showsacodesnippetsimplifiedfrom tree-1.6.0 ,wherewe
assumethatthebodyof strncmpisnotavailable.Function ftakesas
input two arrays of characters, namely input1andinput2, where
the size of each array is 4. The program execution is determined
by the contents of these arrays. At line 5, Xflagis set to 1 if the
firsttwocharactersof input1areâ€˜-â€™andâ€˜Xâ€™.Atline9, duflag
is set to 1 if input2contains the string "--du". Thus, the error
location(line12)isreachablewhenthefunctionisexecutedwith
the following inputs:
input1: â€˜â€“â€™â€˜Xâ€™**input2: â€˜â€“â€™â€˜â€“â€™â€˜dâ€™â€˜uâ€™
whereâˆ—means an arbitrary character. The goal of concolic testing
istogeneratesuchinputsthatdriveprogramexecutiontohitthe
error location.
However, conventional concolic testing is unlikely to trigger
theerrorduetothehugesearchspace.Inordertoreachtheerror
location, the program execution must hit lines 5 and 9. To do so,
concolic testing initially runs the program with random inputs
while simultaneously executing the program with the symbolic
inputs:
input1: Î±1Î±2Î±3Î±4input2: Î±5Î±6Î±7Î±8
Duringtheexecution,constraintsonthesymbolicvariables( Î±1,...,Î±8)
arecollectedandusedtogeneratethenextinput.Forexample,when
the initial execution follows the true branches of the conditional
statementsatline4andthefalsebranchesofthestatementsatlines
7 and 11, the following constraints are collected:
Î±1=â€˜-â€™âˆ§Î±2=â€˜Xâ€™âˆ§Î±5/nequalâ€˜-â€™.
Negating, for example, the last conjunct will produce input thatmakes the program execution to exercise the true branch of the
firstconditionalstatementatline7.Then,assumingthatthenew
input does not satisfy the second condition at line 7, the following
path condition will be newly generated:
Î±1=â€˜-â€™âˆ§Î±2=â€˜Xâ€™âˆ§Î±5=â€˜-â€™âˆ§Î±6/nequalâ€˜-â€™ (1)
Negatingthelastconjunctagain,concolictestingsucceedstoreach
theprogramlocationrightbeforetheconditionalstatementatline8.
Atthispoint,however,itstillneedstoexplorealargesearchspaceto
generate inputs that satisfy the condition ( !strncmp(...) ), as the
body ofstrncmp is not available and therefore symbolic variables
1ConcolicTesting: https://github.com/kupl/ConTest1voidf(charinput1[4], charinput2[4]){
2intXflag=0, duflag=0;
3
4if(input1[0] == '-'&& input1[1] == 'X')
5Xflag = 1;
67
if(input2[0] == '-'&& input2[1] == '-')
8if(!strncmp("--du", input2, 4))
9duflag = 1;
10
11if(Xflag && duflag) {
12/* Error */
13}
14}
Figure 1: Motivating example
Î±7andÎ±8areunconstrained.Hence,thelasttwocharacters â€™duâ€™
mustbegeneratedbychance,wheretheprobabilityistoolowgiven
that there already exists multiple, more precisely 9, paths from the
entry of the program to line 8.
Our template-guided concolic testing aims to reduce the search
space effectively and automatically. During concolic testing, our
techniqueadaptivelygenerates templates,whichareusedtorestrict
theinputspacebyselectivelyintroducingsymbolicvariables.For
example, when it is applied to the program in Fig. 1, our technique
automaticallyproducesthefollowingtemplateforrestrictingthe
search space:
input1: â€˜â€“â€™â€˜Xâ€™â€˜\0â€™â€˜\0â€™input2: â€˜â€“â€™â€˜â€“â€™Î±7Î±8
Thatis,allinputvaluesexceptforthelasttwoarefixedbyconcrete
values, so that concolic testing no longer needlessly attempts to
explore execution paths that cannot reach line 8. In other words,
ourtechniqueisabletoenforcethenecessaryconditiontoreachthe
error location, enabling concolic testing to focus on generating the
inputsâ€˜dâ€™andâ€˜uâ€™forÎ±7andÎ±8, respectively. With this template,
concolic testing is able to generate the error-triggering input more
effectively,upto9timesfasterthantheconventionalmethodfor
the example program.
2.2 Template-Guided Concolic Testing with
Online Learning
Fig.2illustratesourtechniqueforperformingconcolictestingwhile
automaticallygeneratingtemplatesonline.Ourtechniqueisableto
generate effective templates without any prior domain knowledge.
Thealgorithmrepeatsthefollowingfiveproceduresuntilagiven
testing budget is exhausted.
2.2.1 ConventionalConcolic Testing. We firstperformconven-
tional concolic testing (without template) to generate a set of effec-
tivetestcases.Wesayatestcaseiseffectiveifitenablestoexercise
previously uncovered branches during concolic testing. We run
concolictestingforacertainamountoftimeandcollecteffective
409
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. Template-Guided Concolic Testing via Online Learning ASE â€™18, September 3â€“7, 2018, Montpellier, France
	

  
  




	

	



	
	



 
	
		








	


!	"#	$$	
	










	



	




	


	





	

 
 ! 
 !

"#
$%#
%&$	$'	$	


Figure 2: Overview of our technique
test cases. For example, when we run concolic testing on the exam-
ple program in Fig. 1for fewminutes, we could collect more than
40,000 effective test cases such as the following:
input1: â€˜â€“â€™â€˜Xâ€™â€˜*â€™â€˜*â€™input2: â€˜â€“â€™â€˜â€“â€™â€™Pâ€™â€˜â€“â€™
input1: â€˜â€“â€™â€˜2â€™â€˜Râ€™â€˜Lâ€™input2: â€˜â€“â€™â€˜â€“â€™â€˜sâ€™â€˜yâ€™
2.2.2 Sequential Pattern Mining. Once a dataset of effective test
cases is collected, we try to capture common patterns in those
inputvectors.Specifically,weaimtoextractapartialsequenceof
charactersthatfrequentlyappearintheeffectivetestcases.Todo
so, we use a recent algorithm for sequential pattern mining [ 9],
whichfindsoutthefollowingfourpatternsfrom40,000testcases
collected during the previous phase:
P1:-X-,P2:--s,P3:-X--,P4:---
Forexample,pattern P1saysthateffectivetestcasesarelikelyto
involve characters â€˜-â€™,â€˜Xâ€™, andâ€˜-â€™in order.
2.2.3 Pattern Ranking. After generating the candidate patterns
via sequential pattern mining, we choose the top- kpatterns that
are most likely to maximize unique branch coverage; the coverage
is calculated as the number of branches that conventional concolic
testing has not discovered. In our example, to quickly cover the
uniquebranch(e.g.,thetruebranchatline8inFigure1),pattern P3
in Figure 2is required. However, pinpointing the effective pattern
among the candidates is nontrivial, as running the algorithm on
real-world programs usually discovers thousands of patterns. Even
worse,onlyasmallfractionofthecandidatepatternsiseffectivefor
increasing branch coverage. We address this challenge by ranking
candidatepatternsbasedontheeffectivenessofsimilarpatternsthat
wereevaluatedinthepreviousruns.Weaccumulatesetsofgood
and bad patterns during the algorithm and use them to estimate
the effectiveness of the newly generated patterns. For the example
program, we choose P3andP2whenk=2.
2.2.4 PatterntoTemplate. Thenextstepistotransformpatterns
to templates. Note that a pattern is simply an ordered sequence
ofmeaningfulinputvalues(e.g.characters);tobeatemplate,weneed to decide the position of each value contained in a given
pattern. To do so, we first collect the test-cases containing the
patternand thenidentify thepositionswhere thetemplate values
appear most frequently. For instance, suppose that the concrete
valueâ€˜Xâ€™appearedthe most atthe secondindex inthe test-cases.
Then, we replace the symbolic value Î±2at the second index in
input2with the value â€˜Xâ€™. By applying this rule to patterns P3andP2,whichwereselectedinthepreviousphase,weobtainthe
following two templates:
input1: â€˜â€“â€™â€˜Xâ€™Î±3Î±4input2: â€˜â€“â€™â€˜â€“â€™Î±7Î±8
input1: â€˜â€“â€™Î±2Î±3Î±4input2: Î±5â€˜â€“â€™â€˜sâ€™Î±8
In the rest of this paper, we also represent a template by a set of
concrete values and their positions. For example, the first template
can be represented as follows:
{(0,â€œâˆ’â€),(1,â€œXâ€),(4,â€œâˆ’â€),(5,â€œâˆ’â€)}. (2)
2.2.5 Concolic Testing with Template. The final step is to run
concolictestingwiththegeneratedtemplates( T1andT2).Forex-
ample,whenusingthetemplate T1,weonlygeneratefoursymbolic
values(Î±3,Î±4,Î±7,Î±8)andreplacetherestwithconcretevaluesin
the template T1. Note that the concrete values are not arbitrary but
are effectivelyguiding the concolic testingto reach theerror loca-
tion(e.g.,truebranchatline11inFigure 1)byforcingtheprogram
execution to follow the specific path, taking all true branches of
the conditional statements at lines 4 and 7.
Afterperformingconcolictestingwiththetemplatesforacer-
tain amount of time, we evaluate the qualities of the generated
templatesintermsofthenumberofuniquebranches.Asaresult,
we classify the corresponding patterns into good and bad patterns
in Figure 2, which will be used by the ranking algorithm in the
nextiterationofthealgorithm.Astheentireprocedureisgoingon,
ouralgorithmaccumulatestheevaluationdataandthereforethe
ranking algorithmis able topick more effective patternsbased on
the increased knowledge.
3 TEMPLATE-GUIDED CONCOLIC TESTING
Algorithm 1presentsourtemplate-guidedconcolictesting.Wefirst
describe conventional concolic testing and then explain how to
modify it to our algorithm.
3.1 Conventional Concolic Testing
Withoutline6,Algorithm 1becomesconventionalconcolictesting,
whichtakesaprogram Pandreturnscoveredbranchesaswellas
the set of generated input vectors. At line 2, the sets of covered
branches Band generated input vectors Vare initialized. At line
3,vdenotestheinitialconcreteinputvector,whichisassumedto
begivenforeachprogram.Atline4,thealgorithminitializesthe
symbolic input vector: s=/angbracketleftÎ±1,...,Î±|v|/angbracketright, where each Î±idenotes a
fresh symbol representing the i-th input. At line 7, the program P
is â€œconcolicallyâ€executed; Pisexecuted with theconcrete input v
while it is at the same time executed symbolically with s. Once the
410
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. ASE â€™18, September 3â€“7, 2018, Montpellier, France Sooyoung Cha, Seonho Lee, and Hakjoo Oh
Algorithm 1 Template-Guided Concolic Testing
Input:ProgramPand template T
Output: Covered branches and generated input vectors
1:procedure ConcolicTesting( P,T)
2:B,Vâ†âˆ…,âˆ…
3: vâ†initial concrete input vector
4: sâ†initial symbolic input vector
5:form=1t oNdo
6: v,sâ†Instantiate(v ,T),Instantiate(s ,T)
7: Î¦â†ConcolicExecution( P,v,s)
8: Bâ†BâˆªBranches(Î¦)
9: ifeffectiveinput(v) then
10: Vâ†Vâˆª{v}
11: end if
12: repeat
13: Ï•iâ†Choose a branch from Î¦=Ï•1âˆ§Â·Â·Â·âˆ§Ï•n
14: untilSAT(/logicalandtext.1
j<iÏ•jâˆ§Â¬Ï•i)
15: vâ†model(/logicalandtext.1
j<iÏ•jâˆ§Â¬Ï•i)
16:end for
17:return(B,V)
18:end procedure
executionterminates,the ConcolicExecution functionreturnsthe
current path condition Î¦, a constraint on the symbolic variables
Î±1,...,Î±|v|.Thepathconditionisasequenceofexercisedbranches
in the program and is used to generate the next (concrete) input
vector at lines 12â€“14. At line 13, a branch Ï•iis chosen from Î¦and
negated(line14).Ifthechosenbranch Ï•iisnotcontradictablewith
respect to the current path ( SAT(/logicalandtext.1
j<iÏ•jâˆ§Â¬Ï•i)), the next input
vector is obtainedby solving the negatedconstraint (line 15). The
algorithm repeats the above procedure until the testing budget ( N)
is exhausted. In experiments, we set N=4000.
3.2 Concolic Testing with Template
Our algorithm differs from conventional concolic testing in that
some input values are fixed according to the given template. A
template Tis a set of pairs of indices and values:
T={(i0,v1),...,(im,vm)}.
Intuitively, a pair (i,v)âˆˆTindicates that the i-th input of vand
sis fixed by the concrete value v, so that concolic testing should
notsymbolicallytrackthoseinputsin T.Weassumethatforevery
(i,v)âˆˆT,iis unique and 0 â‰¤i<|v|.
Thetemplateisinstantiatedatline6.Beforerunningtheprogram,
both concrete and symbolic input vectors are modified, where the
Instantiate function replaces a given vector aaccording to the
template Tas follows:
Instantiate(a ,T)=/angbracketleftv1,...,v|a|/angbracketright
whereviisthevalue vinthetemplateif (i,v)âˆˆT.Otherwise,if
(i,v)/nelementT,viis not changed, i.e., vi=ai. That is, given a vector
aandatemplate T,Instantiate(a ,T)replacesthe i-thelementof
aby the value in T. As a result, concolic execution of Pat line
7generatesconstraintsonlyforasubsetoftheoriginalsymbolic
variables ( Î±1,...,Î±|v|). We assume that the modelfunction at line
15 produces arbitrary values for unconstrained symbols.
Our template-guided concolic testing poses a significant chal-
lenge. That is, the effectiveness of our approach depends on theAlgorithm 2 Template-Guided Concolic Testing with Online
Learning
Input:ProgramP
Output: The number of covered branches
1:/* Initialization */
2:/angbracketleftB,TB,Good ,Bad/angbracketrightâ†/angbracketleftâˆ… ,âˆ…,âˆ…,âˆ…/angbracketright
3:repeat
4:/* Step 1: Exploration with conventional concolic testing */
5:Vâ†âˆ…
6:fori=1toÎ·1do
7: (Bi,Vi)â†ConcolicTesting( P,âˆ…)
8: /angbracketleftB,V/angbracketrightâ†/angbracketleftBâˆªBi,VâˆªVi/angbracketright
9:end for
10:
11:/* Step 2: Mining patterns in collected input vectors */
12:Candâ†SequentialPatternMining( V)
13:14:
/* Step 3: Ranking patterns */
15:Rankedâ†PatternRanking(Cand ,Good ,Bad)
16:
17:/* Step 4: Exploitation with templates */
18:whileRanked /nequalâˆ…do
19: pâ†Pick the highest rank from Ranked
20: Rankedâ†Ranked\{p}
21: Tâ†PatternToTemplate( p,V)
22: BTâ†âˆ…
23: fori=1toÎ·2do
24: (Bi,Vi)â†ConcolicTesting( P,T)
25: BTâ†BTâˆªBi
26: end for
27: TBâ†TBâˆªBT
28:
29: /* Check whether pattern pis good or bad */
30: if|BT\B|>Î·3then
31: Goodâ†Goodâˆª{p}
32: else if|BT\B|â‰¤1then
33: Badâ†Badâˆª{p}
34: end if
35:end while
36:untiltimeout
37:return|BâˆªTB|
given template T. For example, when T=âˆ…, the algorithm be-
comestheordinary concolictestingthattracks allinputvariables
symbolically, which often suffers from the path-explosion prob-
lem. On the other hand, when the template is too specific (e.g.
T={(0,v0),(1,v1),...,(|v|âˆ’1,vvâˆ’1)}in the extreme), the algo-
rithm becomesmore likerandom testing and is likely to lose the
benefitofconcolictesting.Themaincontributionofthispaperis
thetechniquethatinterleavesconventionalandtemplate-guided
concolic testing in a way that automatically generates effective
templates and maximizes the final code coverage in the long run.
4 TEMPLATE-GUIDED CONCOLIC TESTING
WITH ONLINE LEARNING
Inthissection,wepresentouralgorithm(Algorithm 2)forperform-
ing template-guided concolic testing while automatically generat-
ing effective templates online. Algorithm 2consists of four main
stages: conventional concolic testing, sequential pattern mining,
411
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. Template-Guided Concolic Testing via Online Learning ASE â€™18, September 3â€“7, 2018, Montpellier, France
ranking,andtemplate-guidedconcolictesting.Atline2,thealgo-
rithm begins with initializing data. The sets BandTBrepresent
branchescoveredbyconventionalconcolictestingandtemplate-
guidedconcolictesting,respectively.Thesets GoodandBaddenote
the effective and ineffective input patterns, respectively.
Thealgorithmhasthreehyperparameters( Î·1,Î·2,andÎ·3).The
first parameter Î·1is used at line 6 and determines the number
conventional concolic executions in the first phase. The second
parameter Î·2, which is used at line 23, denotes the number of
concolic executions with each template. The last parameter Î·3
representsthethresholdvalueforthepattern ptobeagoodpattern
(i.e., included in the set Good). In experiments, we set Î·1=100,
Î·2=20,Î·3=20. In this work, we tuned these hyperparameters
manually by trial-and-error, and found that the performance of
Algorithm 2depends on them substantially. An interestingfuture
direction would be finding optimal hyperparameters automatically
during the algorithm.
4.1 Exploration without Templates
Thefirstphaseofthealgorithm(lines5â€“9)istorunconcolictesting
withouttemplate(i.e. T=âˆ…)toexploreandcollectdiverseinput
vectors that are effective in increasing branch coverage.
Atline5,theset Vofinputvectorsisinitiallyempty.Atlines6â€“9,
ConcolicTesting (Algorithm 1)isrunfor Î·1times.Whenconcolic
testingfinishes,thesets BiandViofcoveredbranchesand effective
inputvectors, respectively,arereturned.We sayinputvectorsare
effective (i.e., effectiveinput at line 9 of Algorithm 1) if they satisfy
thefollowingtwoconditions.First,theinputvectorsshouldbeable
to increase branch coverage after the initial 10% of the budget N
forConcolicTesting isexhausted.Forexample,whenbudget Nis
4,000programexecutions,weignoreinputsgeneratedduringthe
first 400 executions. This is because branch coverage gets easilyincreased in the early stage of concolic testing, no matter what
initial input vectors are used. Second, the input vectors should con-
tribute to discovering branches that are new compared to previous
programexecutions.Collecting effectiveinputsonlyiscrucialbe-
causeblindlycollectingallinputscancauseseriousperformance
degradation in the next stage, sequential pattern mining.
4.2 Mining Patterns
The second step of the algorithm is to mine common patterns from
the collected set of effective input vectors (line 12). We observed
that each effective input vector is likely to have meaningful subse-
quencesthatultimatelycontributetoimprovingbranchcoverage.
The goal ofthis stage is to quicklyextract such subsequences that
arecommontomanyofthecollectedinputsandusethemasthe
candidates to reduce the search space. Fortunately, for this pur-
pose, we can use off-the-shelf techniques called sequential pattern
mining in the data mining community, which can do the desiredtask efficiently. Numerous pattern mining algorithms have been
proposed in the literature [ 9,15,27,30]. We used a state-of-the-art
algorithm,CloFast[ 9],whichavoidsgeneratingredundantpatterns.
CloFast also outperformsthe existingalgorithms interms ofcom-
putation time and memory consumption [ 9]. For example, when
CloFast takes 14,604 effective inputs collected from sed-1.17 ,i t
generates 6,176 candidate patterns in five minutes. In Algorithm 2,Algorithm 3 PatternRanking
Input:Candidate Patterns Cand, Good patterns Good, Bad patterns Bad
Output: Learned Patterns Ranked
1:procedure PatternRanking(Cand ,Good ,Bad)
2:/* Initialize */
3:Pattop,Patmidâ†/angbracketleft /angbracketright ,/angbracketleft/angbracketright
4:Rankedâ†âˆ…
5:/* Step 1: Reflection */
6:whileCand /nequalâˆ…do
7: pâ†pop(Cand)
8: Candâ†Cand\{p}
9: ifMatch(p,Good)âˆ§Â¬Match(p,Bad)then
10: Pattopâ†PattopÂ·p
11: else ifÂ¬Match(p,Good)âˆ§Â¬Match(p,Bad)then
12: Patmidâ†PatmidÂ·p
13: end if
14:end while
15:Pattopâ†PattopÂ·Patmid
16:
17:/* Step 2: Diversification */
18:while|Ranked|<kdo
19: pâ†pop(Pattop)
20: Pattopâ†Pattop\{p}
21: ifDiverse(p,Ranked)then
22: Rankedâ†Rankedâˆª{p}
23: end if
24:end while
25:returnRanked
26:end procedure
thealgorithmismodeledbythe SequentialPatternMining function,
which takes a set of input vectors and returns a set of common
patterns.
4.3 Ranking Patterns
Thethird stepisto rankthecandidate patternsaccordingto their
(estimated) effectiveness (line 15). We designed a ranking function
(PatternRanking ),whichchoosesthetop- kpatternsfromthecan-
didates generated by the pattern mining algorithm. In experiments,
we setkto 20. At line 15 in Algorithm 2, PatternRanking takes
threepatternsets:patternstorank( Cand),goodpatterns( Good),
andbadpatterns( Bad).Then,itreturnsthetop- kpatterns( Ranked)
that are most likely to cover new branches in the future.
The key ideas behind our ranking algorithm (Algorithm 3)i st o
reflecttheexperiencewiththepatternsevaluatedintheprevious
runs and try as many diverse patterns as possible. Hence, the main
loop of the algorithm consists of the two phases: Reflection and
Diversification. Initially, we rank the candidates Candby sorting
thembasedonthefrequencyofeachcandidatecalculatedbythe
sequential pattern mining algorithm in ascending order. The hy-
pothesisisthatthepatternswithhigh frequenciesareunlikelyto
discover new branches. At lines 3-4, PattopandPatmidare initially
empty vectors, and Rankedis an empty set.
In the first stage (Reflection), we transform each pattern pin
Candinto n-grams and check whether any n-grams in the pattern
pare included in any patterns in good or bad pattern sets (line
9-13). To do so, we define a function ngramwhich takes a pattern
andreturnsasetofn-gramsforthepattern,wherethenumbern
412
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. ASE â€™18, September 3â€“7, 2018, Montpellier, France Sooyoung Cha, Seonho Lee, and Hakjoo Oh
ishalfofthelength p(n=/ceilingleftbig
|p|/2/ceilingrightbig).Forexample,whenthepattern
pisastring" s//b",ngram(p)returnsthethree2-grams:" s/", "//",
"/b". Then we classify the patterns using predicate Matchdefined
as follows:
Match(p,P)â‡ â‡’ âˆƒĞ´âˆˆngram(p).Ğ´âˆˆ/uniondisplay.1
p/primeâˆˆPngram(p/prime)
Matchtakesapattern( p)andasetofpatterns( P),andreturnstrue
iffanyofthen-gramsof pisincludedintheunionofn-gramsofthe
patternsin P.Weperform Matchwithboth GoodandBad.When
Match(p,Good) andMatch(p,Bad) are true and false, respectively,
thepattern pisincludedin Pattop,aclasswithhighpriority(line
10).Intuitively,thepattern pgetshighpriorityifitdoesnothave
any of the features having bad patterns Badwhile the pattern p
contains at least one feature of good patterns. At line 11, when
theresultsof Match(p,Good)andMatch(p,Bad)arebothfalse,the
patternpisappendedto Patmid,aclasshavingmiddlepriority(line
12). The patterns in the class Patmiddo not include at least the
featuresofthebadpatterns.Otherwise,thepattern pisremoved
from the candidate group of top- kpatterns.
Inthesecondstep(Diversification),weaimtodiversifythepat-
terns by filtering out similar patterns in Pattop. To diversify the
patterns, we use the following function:
Diverse(p,P)â‡ â‡’ngram(p)/notsubseteql/uniondisplay.1
p/primeâˆˆPngram(p/prime)
Diversereturnstrueiff ngram(p),asetofn-gramsgeneratedbythe
patternp, is not a subset of the union of all n-gram sets generated
by each pattern p/primein the given pattern set P. At line 19, we pop
a pattern p. Then, we add the pattern pinto the set Rankedonly
whenDiverse(p,Ranked)returnstrue(line22).Intuitively,thisstep
makes each pattern in Rankedhave at least one unique n-gram.
4.4 Exploitation with Templates
Thelaststepofthealgorithmistoexploitthepatternslearnedfrom
thepreviousphase.However,thepatternsin Rankedcannotbeused
immediately. Because a pattern is just a sequence of characters, we
need to determine the appropriate position of each character. To
transformapatternintoatemplate,thealgorithmusesthefunction
PatternToTemplate ,whichtakesapatternandasetofinputvectors,
and creates a template for the pattern. We generate the template
in two steps. First, we only collect the input vectors containingthe pattern among the input vectors
Vaccumulated in step 1 of
Algorithm2.Second,foreachcharacterinthepattern,wecompute
the position where the character appears most frequently. Theresulting template is used to perform template-guided concolic
testing.
Atline19ofAlgorithm 2,wefirstpickapattern pwiththehigh-
est priority from the set Ranked. Then, we transform the pattern p
intothetemplate TbyusingPatternToTemplate (line21).Usingthe
template, we perform ConcolicTesting( P,T)forÎ·2times (lines 23-
26).Aswementionedbefore,weset Î·2=20,becauseweexperimen-
tally observed that a good template usually was able to cover new
brancheswithin20trials.Wheneverwerun ConcolicTesting( P,T),
we accumulate the branches covered by each template Tin the
setBT. At lines 30-34, we evaluate the quality of the template T
in terms of the number of uniquely covered branches, where theTable 1: Benchmark programs
Program # Total branches LOC Input type Source
vim-5.7 35,464 165K unsigned char [ 4]
gawk-3.0.3 8,038 30K unsigned char [ 5]
grep-2.2 3,836 15K char [4]
sed-1.17 2,650 9K unsigned char [19]
tree-1.6.0 1,440 4K char [5]
Table2:Branchcoveragesachievedbybaselineconcolictest-
ing on original and modified benchmarks
vim-5.7 grep-2.2 sed-1.17
Org Modify Org Modify Org Modify
CFDS [4] 11,984 12,900 1,833 1,996 908 1,347
CGS [23] 7,507 13,526 1,917 2,072 952 1,236
Random [4] 11,142 11,842 1,767 1,851 917 1,121
Gen [12] 6,197 12,174 1,845 1,884 847 1,326
number is counted as the size of the difference set between the BT
andBsets. When the number is greater than the threshold ( Î·3),
we add the pattern pcorresponding to the template Tto the set
Good. When the number is less than or equal to one, we add the
patternptotheset Bad.Notethattorankthecandidatepatternsin
thenextiterations,weonlyusethepatterns,whicharedefinitely
determinedtobegoodorbad.Thealgorithmrepeatstheprocedure
untilthetimebudgetisexhausted.Then,itreturnsthetotalnumber
of covered branches |BâˆªTB|(line 37).
As the outer loop of Algorithm 2 is repeated, we gradually ac-
cumulate thelearned knowledge, namely GoodandBadsets; the
formerrepresentstheknowledgeforeffectivelyreducingthesearch
spacewhilethelattermustbeavoided.Byiterativelyupdatingthese
sets, our algorithm guides concolic testing towards maximizing
branch coverage.
5 EVALUATION
Inthissection,weexperimentallyevaluateourapproach.Weim-
plemented our approach in a tool, called ConTest, on the top of
CREST[7],apubliclyavailableconcolictestingtoolforCprograms.
We have conducted the experiments to address the following re-
search questions:
â€¢Effectiveness of our approach : How well does our ap-
proach perform compared to conventional concolic testing?
â€¢Efficacyof onlinelearning :Isonlinelearningcrucialfor
generating effective templates?
â€¢Learned patterns : What lessons do the learned patterns
provide about search space reduction?
5.1 Settings
5.1.1 Benchmarks. We have used 5 open-source C programs in
Table1:vim,gawk,grep,sedandtree.Allbenchmarkscamefrom
thepriorworksonconcolictesting[ 4,5,19]withslightmodifica-
tionsontheannotationsforthreebenchmarks( vim,grepandsed).
413
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. Template-Guided Concolic Testing via Online Learning ASE â€™18, September 3â€“7, 2018, Montpellier, France
Duringthiswork, wefoundthatthe performanceofconcolictest-
ing varies significantly depending on how benchmark programs
are annotated, and tried to annotate the programs in ways thatmaximize the performance of the baseline concolic testing. For
example, since
vimis a text editor program, it is natural to take
inputs of type â€˜unsigned charâ€™ (0â€“255). But the previous version
ofvimwasannotatedwiththe CREST_unsigned_short function,
which needlessly generates inputs from the larger space (0â€“65,535).
We replaced it with CREST_unsigned_char . Forsedandgrep,w e
alsochangedtheannotationstomakethemmorenatural.Forex-
ample, the original annotations of sedforced concolic testing to
execute the program with the option â€˜-fâ€™ always turned on. We
fixedthisissuebysymbolizingtheargumentsofthemainfunction.
The modified programs are available with our tool, ConTest.
Table2shows that the baseline concolic testing performs much
betteronthemodifiedprograms.Wecomparedtheperformance
oftheconventionalconcolictestingontheoriginalandmodified
programswithvarioussearchheuristics.Thetablereportsthenum-
ber of branches covered over 100 runs of concolic testing, where a
singlerunconsistsof4,000programexecutions(i.e., N=4000inAl-
gorithm1).Overall,theperformanceofconcolictestingisimproved
significantly with the modifications. For example, concolic testing
withtheCGSheuristic[ 23]forvim-5.7covered13,526branches
on the modified benchmark while the same method managed tocover 7,507 branches only on the original one. In summary, we
modifiedthebenchmarkprogramstomakethebaselineconcolic
testing much stronger.
Wedidnotusethefoursmallprograms,whichwereusedin[ 4,5,
19,23]:cdaudio,floppy,kbfiltrandreplace.Thisisbecausethe
conventional concolic testing already achieves high code coverage
onthoseprograms,asthesizesofthesebenchmarksareverysmall
(e.g.,replace is of 0.5KLoC).
5.1.2 SearchHeuristics. Inevaluation,weconsideredfoursearch
heuristics: CGS (Context-Guided Search) [ 23], CFDS (Control-Flow
Directed Search) [ 4], Random branch search [ 4] and Gen (Genera-
tional search) [ 12]. We chose them because our technique requires
search heuristics to be nondeterministic in order to generate di-
verse input patterns in the first step of Algorithm 2. We did not
use deterministic techniques such as DFS (Depth-First Search) [ 11]
andParaDySE[ 5].Foreachbenchmarkprogram,weappliedour
technique on top of the search heuristic that performs best. For ex-
ample,weusedCGSfor vimandgrep,andCFDSfortheremaining
three programs.
5.1.3 OtherSettings. Weusedthesameevaluationsettingsfor
bothconventionalandtemplate-guidedconcolictesting.First,all
experiments were conducted on a machine with two Intel Xeon
ProcessorsE5-2630and192GBRAM.Second,weperformedcon-
colictestingonallthebenchmarks,using10coresinparallel.Third,
the initial input was fixed for each benchmark. For vim, the largest
benchmark,weallocated70hoursfortestingbudgetand7hours
for the four smaller programs. We set N=4,000 in Algorithm 1.
5.2 Effectiveness of Our Approach
Weevaluatedour techniqueandconventionalconcolictestingon5
benchmarks in terms of branch coverage and bug detection.          YLP&RYHUHG%UDQFKHV
7LPHK7&*6
&)'6
&*6
*HQ
5DQGRP
Figure3:Accumulatedbranchcoverageachievedbyconven-
tional concolic testing and our technique on vim-5.7
Table3:Thenumberofuniquelycoveredbranchesandtrials
Template-Guided Approach Baseline
# Unique Branch # Trials # Unique Branch # Trials
vim 833 2,054 281 2,496
grep 98 2,599 3 1,669
tree 80 2,536 2 3,713
sed 62 9,498 7 11,643
gawk 56 5,100 23 5,261
5.2.1 Branch Coverage. Figure3shows that our approach (T-
CGS) increases branch coverage significantly compared to conven-
tionalconcolictestingon vim-5.7.TheCGSheuristicisarobust
baselinethatcovers806morebranchescomparedtotheRandom
heuristic, the second best of conventional concolic testing. Nev-ertheless, T-
CGS(our template-guidedconcolic testing ontop of
the CGS heuristic) covered 16,197 branches, covering 552 more
branchesthan CGS.Moreimportantly,Table 3showsthat T-CGS
exclusively covered 833 branches that CGSfails to reach over 70
hours, using 10 cores in parallel. The results show that our tech-
niqueenablesconcolictestingtoachievesignificantperformance
gains in practice by effectively reducing the search space.
Figure4showsthatourapproachalsoachieveshigherbranch
coverage than conventional concolic testing on the remaining 4benchmarks. For example, ours (T-
CGS) covered 2,252 branches
forgrep, whileCGScovered only 2,157 branches during the same
time period (7h). Our approach succeeded to cover the branches
that conventional testing fails to reach on all benchmarks. Table 3
reportsthenumberofuniquebranchesandtrials.Theformerde-
notes the number of branches only covered by each approach. For
grepandtree, 98 and 80 branches were exclusively covered by
T-CGSandT-CFDS, respectively. The latter is the total number of
trials that each approach has performed concolic testing during
the same time budget for each benchmark; as we mentioned above,
414
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. ASE â€™18, September 3â€“7, 2018, Montpellier, France Sooyoung Cha, Seonho Lee, and Hakjoo Oh
JUHS&RYHUHG%UDQFKHV
7LPHK7&*6
&)'6
&*6
*HQ
5DQGRP
WUHH&RYHUHG%UDQFKHV
7LPHK7&)'6
&)'6
&*6
*HQ
5DQGRP
VHG&RYHUHG%UDQFKHV
7LPHK7&)'6
&)'6
&*6
*HQ
5DQGRP
JDZN&RYHUHG%UDQFKHV
7LPHK7&)'6
&)'6
&*6
*HQ
5DQGRP
Figure 4: Accumulated branch coverage achieved by conventional concolic testing and our technique on 4 benchmarks
a single trial consists of 4,000 program executions ( N=4,000 in
Algorithm 1).
Becauseourapproachinvolvesadditionalruntimeoverhead(e.g.,
sequentialpatternmining),itisnaturalforourapproachtohave
fewer runs of concolic testing than conventional approach within
thesametimebudget.Table 3showsthatthenumberoftrialsby
baselineisusuallygreaterthanthenumberoftrialsbyourtemplate-
guidedconcolic testing.Forexample,for vim,the largestprogram
inourbenchmarks,thebaseline( CGS)ranconcolictesting2,496
timesfor70hours,whileourtechnique(T- CGS)performedit2,054
times.Oneinterestingpointisthatfor grep,thenumberoftrials
for our technique is greater than that for conventional concolic
testing. This is because the benefit of reducing the search space
(e.g., constraint solving time) in grepis greater than the overhead
(e.g., pattern mining time) caused by our approach.
5.2.2 Bug Finding. During experiments, we have found five
bugsinsed,grep,andgawk,whichareexploitableeveninthelatest
versions of the programs. Table 4shows the bug-triggering inputs
andphenomenonswhentheprogramsareexecutedwiththeinputs.Table 4: Bugs in benchmarks
Phenomenons Bug-Triggering Inputs Version
sed Memory Exhaustion'H
g;D'4.4(latest)
sed Infinite File Write'H
w{ -
x; D'4.4(latest)
grep Segmentation Fault '\(\)\1\+**' 3.1(latest)
grep Non-Terminating '?(^(|^+*)*\+\{8957\}' 3.1(latest)
gawk Memory Exhaustion '$6672467e2=E7' 4.21(latest)
Thetwoerror-triggeringinputsfor sedcouldconsumeallofour
Linuxmachineâ€™smemoryandharddisk,respectively.Thetemplate
used for generating the former input is as follows: { (1, â€˜ \nâ€™), (3,
â€˜\nâ€™), (5, â€˜Dâ€™), (6, â€™ \0â€™) }. The template guides concolic testing to find
thebugeffectively byconcretizing4ofthe6 charactersrequiredto
415
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. Template-Guided Concolic Testing via Online Learning ASE â€™18, September 3â€“7, 2018, Montpellier, France
Table 5: Top 5 good and bad patterns
tree-1.6.0 sed-1.17
good patterns bad patterns good patterns bad patterns
-gd\ 0 -gs\ 0 /\ n\\ \ n\ n\ n[
1d\ 0 1d\ 0 ;/1n ;\\%%\ n-r\ 0 -uF.\ 0 ;\ n$\\ n ;n%%-fi -fx /,} $\};
-fg -fN /\[ Ë†,%
causethebug.In grep,thesegmentationfaultoccurredwhenwe
ran the program with the input we found: grep '\(\)\1\+**' file.
In particular, the input '$6672467e2=E7 'found by our approach
ingawkcauses a lot of memory to be consumed. One interesting
pointisthatthelatestversionof gawkhasalreadyperformedtheex-
ceptionhandlingonsuchperformancebugs.Forexample,whenwe
append a string '66'to the original input '6672467e2=E7 ', an error
handlingmessage(â€œCannotallocatememoryâ€)isprintedandthe
program is terminated. However, the input we found corresponds
tothecornercaseoftheerrorhandlingcode,anditconsumesmorethan100GBofmemoryonourLinuxmachine.Whileourtechnique
generatedthefivebug-triggeringinputsinTable 4,conventional
concolictestingmanagedtogeneratethetwoinputsfor sedonly
within the same time budget.
5.3 Efficacy of Online Learning
We have compared the performance of our pattern ranking algo-
rithm (Algorithm 3) and a naive algorithm that randomly selects
patterns on sed-1.17 . To do so, for the first 10 iterations of the
outerloopofAlgorithm 2,wecomparedthequalitiesofthepatterns
selectedbythetwoalgorithms,wherethequalitiesarequantifiedby
the number of uniquely covered branches that the CFDS heuristic
(the baseline for sed) failed to reach.
Figure5showsthatouralgorithmoutperformsthenaivealgo-
rithm in two aspects. First, our algorithm succeeds in selecting
33effectivepatterns(representedbystarsinthefigure)whilethe
naive algorithm manages to pick 13 effective ones (represented by
circles) for the given budget. As online learning progresses, our
algorithm gradually increases the number of times that it picks up
effective patterns; during thelast 3 iterations (8-10 iterations), our
algorithmsuccessfullyselectedabout55%oftheoveralleffective
patterns. Second, the average and maximum performance of the
patternsselectedbyourlearningalgorithmarehigherthanones
achieved by the naive algorithm; the best pattern chosen by our
algorithm contributed to covering 104 unique branches. On theotherhand,thebestoneofthenaivealgorithmonlymanagedto
cover 58 unique branches. The average performance of effective
patterns selected by ours and random selection algorithm is 54 and
47,respectively.Asaresult,whenthetotalbudgetisexhausted,our
learningandnaiveapproachescovered1,707and1,644branches,
respectively.
In summary, online learning is essential for solving the problem
of selecting good patterns. Blindly reducing the search space with-
out learning can be inferior even to conventional concolic testing.  VHG /HDUQLQJ 5DQGRP8QLTXHO\&RYHUHG%UDQFKHV
,WHUDWLRQV
Figure 5: Comparison with online learning algorithm and
random algorithm
5.4 Learned Patterns
Wediscussgoodandbadpatternschosenduringonlinelearning
interms ofincreasing uniquebranchcoverage.Table 5showsthe
top 5 good and bad patterns on tree-1.6.0 andsed-1.17 . The
formerrepresentsthetop5goodpatternswiththehighestnumber
ofuniquebranchesthatconventionalconcolictestingfailstoreach
and the latter is 5 patterns that do not cover any of the unique
branches.
Fortree-1.6.0 ,goodandbadpatternsarehardlydistinguish-
able.Exceptforthethirdpattern,everyrowshowssimilargoodand
badpatterns.Inparticular,thesecondpatternsareexactlythesame.
Thisexplainswhyourrankingalgorithm(Algorithm 3)shouldcon-
servativelyremovetheunreliablepatterns;recallthatweremove
candidatesifit containsbothgoodandbadfeatures. Ontheother
hands, for sed-1.17 , good and bad patterns are quite distinctive.
However, it is still very difficult for humans to predict which set of
thetwopatternsetscaneffectivelyreducethesearchspace.That
is, manually selecting a set of good patterns is highly tricky, which
is something that machines can do better than humans.
5.5 Threats to Validity
â€¢Benchmarks:Weused5benchmarkprogramswhichwere
widely used from prior work on concolic testing [ 4,5,19].
However,thebenchmarks,acceptingstringsasinput,may
not be sufficient to evaluate the performance of our tech-
nique and conventional concolic testing in general.
â€¢A budget for ConcolicTesting:W es e t Nin Algorithm 1to
4,000, the same value used in prior work [ 4,5,19]. However,
theperformanceofourtechniqueandconventionalconcolic
testing may vary depending on the value.
6 RELATED WORK
Amongexistingworksonmitigatingthepath-explosionproblem
in concolic testing [ 2,4,5,10,12,13,17,23,28,29], we discusstwo
mainapproachesthatarecloselyrelatedtoourapproach:search
416
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. ASE â€™18, September 3â€“7, 2018, Montpellier, France Sooyoung Cha, Seonho Lee, and Hakjoo Oh
heuristicsandsearch-spacereduction.Wealsodiscussrecentworks
that improve software testing with learning [5, 14,20,21,24,26].
SearchHeuristics .Our technique is orthogonal to the existing
works for search heuristics [ 4,5,12,23,29]. To achieve the goal
of maximizing code coverage, search heuristics focus on selecting
oneofthecandidate branchesinthepath,whereasourtechnique
reducesthenumberofthecandidatesbyusingtemplate.Aheuristic
selectsthebranchesthataremostlikelytomaximizecodecoverage
according to its own criterion. For example, the CFDS heuristic [ 4]
selectsabranchclosesttoanyofuncoveredbranchesnearbythe
current execution path. The CGS heuristic [ 23] selects a branch by
performing the breath-first search on execution tree while exclud-
ingbrancheswiththesameâ€œcontextsâ€fromthebranchselection.
Thecontextofeachbranchiscalculatedasasequenceofpreced-
ing branches. The Generational heuristic [ 12] first selects all the
branches once in the current path, and measures the coverage gain
for each branch selection. Then, the heuristic selects the branch
withthehighestgainasthenext-generationbranch.Ourtechnique
can be used in combination with these search heuristics.
Search-Space Reduction .Our work can be seen as a new ap-
proachforreducingthesearchspace[ 2,3,17,28].DASE(Document
Assisted Symbolic Execution)[ 28] is a technique that allows sym-
bolicexecutiontoexercisecorefunctionalitiesoftheprogramby
extractinginputconstraintsfromprogramdocuments(e.g.,manual
pages). Our technique is different from DASE as we do not require
any prior domain knowledge (i.e., documents). Jaffar et al. [ 17] aim
to prune the execution paths guaranteed to not trigger a bug by
using interpolation. Boonstoppel et al. [ 2] proposed the technique,
read-write set analysis, for pruning the number of execution paths
thatproducethesameeffects.Bugraraetal.[ 3]introducedthetech-
niquetodiscardthepathsthataresimilartopreviouslyexecuted
paths. Our technique differs from these works in that we apply
onlinelearningtoadaptivelyreducethesearchspaceofconcolic
testing.
Learning-based Software Testing .At a high-level, our work
belongstothetechniquesthatcombinesoftwaretestingwithma-
chinelearning[ 5,6,14,20,24,26].Learn&Fuzz[ 14]aimstogenerate
inputgrammars(e.g.,PDFobject)forfuzzingbyusingcharacter-
level recurrent neural networks.Skyfire [ 26] aims tolearn a prob-
abilistic context-sensitive grammar from the existing samples to
generate seed inputs for fuzzing. QBE [ 20] learns the kinds of GUI
actionstodetectcrashesorincreaseactivitycoverageinAndroid
GUItestingviaQ-learning.RETECS[ 24]employsreinforcement
learning toautomatically prioritize test casesthat are likely tode-
tectbugsinContinuousIntegration(CI).Lastly,ParaDySE[ 5]aims
to automatically learn search heuristics for concolic testing. In this
work,weuseonlinelearningtoselectgoodtemplates,effectively
reducing the search space of concolic testing.
7 CONCLUSION
Coping with the path-explostion problem continues to be the long-
standing challengein concolictesting. Inthis paper,we presented
anewapproach,whichmitigatesthepath-explosionproblembyre-
ducing the search space using templates. In our approach, concolic
testing uses a set of templates to exploit common input patternsthatimprovecoverageeffectively,wherethetemplatesareautomat-
ically generated through online learning algorithm based on the
feedbackfrompastrunsofconcolictesting.Experimentalresults
demonstrate that our template-guided concolic testing with online
learning outperforms conventional concolic testing significantly in
both branch coverage and bug-finding.
ACKNOWLEDGMENTS
This work was supported by Samsung Research Funding & In-
cubation Center of Samsung Electronics under Project Number
SRFC-IT1701-09. This research was also supported by Basic Sci-
ence Research Program through the National Research Foundation
of Korea (NRF) funded by the Ministry of Science, ICT & Future
Planning (NRF-2016R1C1B2014062).
REFERENCES
[1]Thanassis Avgerinos, Alexandre Rebert, Sang Kil Cha, and David Brumley. 2014.
Enhancing Symbolic Execution with Veritesting. In Proceedings of the 36th Inter-
national Conference on Software Engineering (ICSE 2014). ACM, New York, NY,
USA, 1083â€“1094. https://doi.org/10.1145/2568225.2568293
[2]Peter Boonstoppel, Cristian Cadar, and Dawson Engler. 2008. RWset: Attacking
pathexplosioninconstraint-basedtestgeneration.In InternationalConference
onToolsandAlgorithmsfortheConstructionandAnalysisofSystems.Springer,
351â€“366.
[3]SuhabeBugraraandDawsonEngler.2013. RedundantStateDetectionforDy-
namic Symbolic Execution. In Proceedings of the 2013 USENIX Conference on
AnnualTechnicalConference (USENIXATCâ€™13) .USENIXAssociation,Berkeley,
CA, USA, 199â€“212. http://dl.acm.org/citation.cfm?id=2535461.2535486
[4]J. Burnim and K. Sen. 2008. Heuristics for Scalable Dynamic Test Generation. In
Proceedings of the 2008 23rd IEEE/ACM International Conference on Automated
Software Engineering (ASEâ€™08). IEEEComputerSociety,Washington,DC, USA,
443â€“446. https://doi.org/10.1109/ASE.2008.69
[5]SooyoungCha,SeongjoonHong,JunheeLee,andHakjooOh.2018.Automatically
Generating Search Heuristics for Concolic Testing. In Proceedings of the 40th
International Conference on Software Engineering.
[6]Wontae Choi, George Necula, and Koushik Sen. 2013. Guided GUI Testing of
AndroidAppswithMinimalRestartandApproximateLearning.In Proceedingsof
the2013ACMSIGPLANInternationalConferenceonObjectOrientedProgramming
Systems Languages&#38; Applications (OOPSLA â€™13) . ACM,New York,NY, USA,
623â€“640. https://doi.org/10.1145/2509136.2509552
[7]CREST.AconcolictestgenerationtoolforC.[n.d.]. https://github.com/jburnim/
crest.
[8]DrewDavidson,BenjaminMoench,ThomasRistenpart,andSomeshJha.2013.
FIE on Firmware: Finding Vulnerabilities in Embedded Systems Using Symbolic
Execution.. In USENIX Security Symposium. 463â€“478.
[9]FabioFumarola,PasquaFabianaLanotte,MichelangeloCeci,andDonatoMalerba.
2016. CloFAST:closedsequentialpatternminingusingsparseandverticalid-lists.
Knowledge and Information Systems 48, 2 (2016), 429â€“463.
[10]PatriceGodefroid.2007. CompositionalDynamicTestGeneration.In Proceed-
ingsofthe34thAnnualACMSIGPLAN-SIGACTSymposiumonPrinciplesofPro-
gramming Languages (POPL â€™07) . ACM, New York, NY, USA, 47â€“54. https:
//doi.org/10.1145/1190216.1190226
[11]Patrice Godefroid, Nils Klarlund, and Koushik Sen. 2005. DART: Directed Auto-
mated Random Testing. In Proceedings of the 2005 ACM SIGPLAN Conference on
ProgrammingLanguageDesignandImplementation (PLDIâ€™05).ACM,NewYork,
NY, USA, 213â€“223. https://doi.org/10.1145/1065010.1065036
[12]Patrice Godefroid, Michael Y Levin, David A Molnar, et al .2008. Automated
Whitebox Fuzz Testing.. In Proceedings of the Symposium on Network and Dis-
tributed System Security (NDSS), Vol. 8. 151â€“166.
[13]Patrice Godefroid, Aditya V Nori, Sriram K Rajamani, and Sai Deep Tetali. 2010.
Compositional may-must program analysis: unleashing the power of alternation.
InACM Sigplan Notices, Vol. 45. ACM, 43â€“56.
[14]Patrice Godefroid, Hila Peleg, and Rishabh Singh. 2017. Learn&fuzz: Machinelearning for input fuzzing. In Proceedings of the 32nd IEEE/ACM International
Conference on Automated Software Engineering. IEEE Press, 50â€“59.
[15]Jiawei Han, Jian Pei, Behzad Mortazavi-Asl, Helen Pinto, Qiming Chen, Umesh-
war Dayal, and Meichun Hsu. 2001. Prefixspan: Mining sequential patterns
efficiently by prefix-projected pattern growth. In proceedings of the 17th interna-
tional conference on data engineering. 215â€“224.
[16]Grant Hernandez, Farhaan Fowze, Dave (Jing) Tian, Tuba Yavuz, and Kevin R.B.
Butler.2017. FirmUSB:VettingUSBDeviceFirmwareUsingDomainInformed
417
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. Template-Guided Concolic Testing via Online Learning ASE â€™18, September 3â€“7, 2018, Montpellier, France
Symbolic Execution. In Proceedings of the 2017 ACM SIGSAC Conference on Com-
puter andCommunicationsSecurity (CCS â€™17).ACM,NewYork,NY, USA,2245â€“
2262.https://doi.org/10.1145/3133956.3134050
[17]Joxan Jaffar, Vijayaraghavan Murali, and Jorge A. Navas. 2013. Boosting Con-
colic Testing via Interpolation. In Proceedings of the 2013 9th Joint Meeting on
Foundations of Software Engineering (ESEC/FSE 2013) . ACM, New York, NY, USA,
48â€“58.https://doi.org/10.1145/2491411.2491425
[18]Su Yong Kim, Sangho Lee, Insu Yun, Wen Xu, Byoungyoung Lee, Youngtae Yun,
and Taesoo Kim. 2017. CAB-Fuzz: Practical Concolic Testing Techniques for
COTS Operating Systems. In 2017 USENIX Annual Technical Conference (USENIX
ATC17).USENIXAssociation,SantaClara,CA,689â€“701. https://www.usenix.
org/conference/atc17/technical-sessions/presentation/kim
[19]Yunho Kim and Moonzoo Kim. 2011. SCORE: a scalable concolic testing tool for
reliable embedded software. In Proceedings of the 19th ACM SIGSOFT symposium
andthe13thEuropeanconferenceonFoundationsofsoftwareengineering.ACM,
420â€“423.
[20]YavuzKoroglu,AlperSen,OzlemMuslu,YunusMete,CeydaUlker,TolgaTan-
riverdi, and Yunus Donmez. 2018. QBE: QLearning-based exploration of android
applications.In SoftwareTesting,VerificationandValidation(ICST),2018IEEE11th
International Conference on. IEEE, 105â€“115.
[21]XinLi,YongjuanLiang,HongQian,Yi-QiHu,LeiBu,YangYu,XinChen,and
XuandongLi.2016. SymbolicExecutionofComplexProgramDrivenbyMachine
Learning Based Constraint Solving. In Proceedings of the 31st IEEE/ACM Inter-
nationalConferenceonAutomatedSoftwareEngineering (ASE2016).ACM,New
York, NY, USA, 554â€“559. https://doi.org/10.1145/2970276.2970364
[22]Koushik Sen, Darko Marinov, and Gul Agha. 2005. CUTE: A Concolic Unit
TestingEngineforC.In Proceedingsofthe10thEuropeanSoftwareEngineering
Conference Held Jointly with 13th ACM SIGSOFT International Symposium on
FoundationsofSoftwareEngineering (ESEC/FSE-13) .ACM,NewYork,NY,USA,
263â€“272. https://doi.org/10.1145/1081706.1081750
[23]HyunminSeoandSunghunKim.2014. HowWeGetThere:AContext-guided
Search Strategy in Concolic Testing. In Proceedings of the 22Nd ACM SIGSOFTInternationalSymposiumonFoundationsofSoftwareEngineering (FSE2014).ACM,
New York, NY, USA, 413â€“424. https://doi.org/10.1145/2635868.2635872
[24]Helge Spieker, Arnaud Gotlieb, Dusica Marijan, and Morten Mossige. 2017. Rein-
forcementlearningforautomatictestcaseprioritizationandselectionincontinu-
ousintegration.In Proceedingsofthe26thACMSIGSOFTInternationalSymposium
on Software Testing and Analysis. ACM, 12â€“22.
[25]NickStephens,JohnGrosen,ChristopherSalls,AndrewDutcher,RuoyuWang,
Jacopo Corbetta, Yan Shoshitaishvili, Christopher Kruegel, and Giovanni Vigna.
2016. Driller: Augmenting Fuzzing Through Selective Symbolic Execution. In
ProceedingsoftheSymposiumonNetworkandDistributedSystemSecurity(NDSS) .
1â€“16.
[26]Junjie Wang, Bihuan Chen, Lei Wei, and Yang Liu. 2017. Skyfire: Data-driven
seedgenerationforfuzzing.In SecurityandPrivacy(SP),2017IEEESymposium
on. IEEE, 579â€“594.
[27]Jianyong Wang, Jiawei Han, and Chun Li. 2007. Frequent closed sequence
mining without candidate maintenance. IEEE Transactions on Knowledge and
Data Engineering 19, 8 (2007), 1042â€“1056.
[28]E. Wong, L. Zhang, S. Wang, T. Liu, and L. Tan. 2015. DASE: Document-
Assisted Symbolic Execution for Improving Automated Software Testing. In
2015IEEE/ACM37thIEEEInternationalConferenceonSoftwareEngineering,Vol.1.
620â€“631. https://doi.org/10.1109/ICSE.2015.78
[29]Tao Xie, Nikolai Tillmann, Jonathan de Halleux, and Wolfram Schulte. 2009.
Fitness-guidedpath explorationin dynamicsymbolicexecution. In Dependable
Systems&Networks,2009.DSNâ€™09.IEEE/IFIPInternationalConferenceon .IEEE,
359â€“368.
[30]Xifeng Yan, Jiawei Han, and Ramin Afshar. 2003. CloSpan: Mining: Closed
sequentialpatternsinlargedatasets.In Proceedingsofthe2003SIAMinternational
conference on data mining. SIAM, 166â€“177.
[31]Jonas Zaddach, Luca Bruno, Aurelien Francillon, and Davide Balzarotti. 2014.
AVATAR: A Framework to Support Dynamic Security Analysis of Embedded
Systemsâ€™ Firmwares.. In NDSS.
418
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. 