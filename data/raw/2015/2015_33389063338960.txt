EffectiveError-Specification Inference
viaDomain-KnowledgeExpansion
Daniel DeFreez
Universityof California,Davis, USA
dcdefreez@ucdavis.eduHaaken Martinson Baldwin
Universityof California,Davis, USA
hmbaldwi@ucdavis.edu
Cindy Rubio-González
Universityof California,Davis, USA
crubio@ucdavis.eduAdityaV.Thakur
Universityof California,Davis, USA
avthakur@ucdavis.edu
ABSTRACT
Error-handlingcoderesponds to theoccurrence ofruntimeerrors.
Failuretocorrectlyhandleerrorscanleadtosecurityvulnerabilities
and data loss. This paper deals with error handling in software
writteninCthatusesthereturn-codeidiom:thepresenceandtype
of error is encoded in the return value of a function. This paper
describes EESI,astaticanalysisthatinfersthesetofvaluesthata
function can return on error. Such a function error-specification
canthenbeusedtoidentifybugsrelatedtoincorrecterrorhandling.
The key insight of EESIis to bootstrap the analysis with domain
knowledge related to error handling provided by a developer. EESI
usesacombination ofintraprocedural,flow-sensitive analysisand
interprocedural, context-insensitive analysis to ensure precision
andscalability.Webuiltatool ECCtodemonstratehowthefunction
error-specificationsinferredby EESIcanbeusedtoautomatically
find bugs related to incorrect error handling. ECCdetected 246
bugsacross9programs,ofwhich110havebeenconfirmed. ECC
detected 220 previously unknown bugs, of which 99 are confirmed.
Twopatcheshave already been mergedintoOpenSSL.
CCS CONCEPTS
·Softwareanditsengineering →Automatedstaticanalysis ;
Errorhandlingandrecovery ;Software defectanalysis .
KEYWORDS
errorhandling, staticanalysis,bugfinding
ACMReference Format:
DanielDeFreez,HaakenMartinsonBaldwin,CindyRubio-González,andAditya
V.Thakur.2019.EffectiveError-SpecificationInferenceviaDomain-Knowledge
Expansion.In Proceedingsofthe27thACMJointEuropeanSoftwareEngineer-
ingConferenceandSymposiumontheFoundationsofSoftwareEngineering
(ESEC/FSE ’19), August 26ś30, 2019, Tallinn, Estonia. ACM, New York, NY,
USA,11pages.https://doi.org/10.1145/3338906.3338960
Permissionto make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,
topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ESEC/FSE ’19, August 26ś30,2019, Tallinn,Estonia
©2019 Associationfor Computing Machinery.
ACM ISBN 978-1-4503-5572-8/19/08...$15.00
https://doi.org/10.1145/3338906.33389601 INTRODUCTION
Error-handling code responds to the occurrence of runtime errors
insoftware.Forexample,afunctionattemptingtoallocatememory
needs code tohandle the case when there is no memoryavailable,
and a device driver requires code to handle the situation when
the hardware device does not respond.Incorrect handling ofsuch
errors can lead to serious problems such as security vulnerabilities
anddataloss.Ignoringtheerrorreturnedbyamemoryallocator
would lead to the code accessing invalid memory, and ignoring the
errorreturnedbythehardwaredevicemightleadtodatacorruption.
Thus, correctlyhandling errorsincode isparamount.
ThispaperdealswitherrorhandlinginsoftwarewrittenintheC
programminglanguage.Intheabsenceofexception-handlingmech-
anisms,suchCprogramsusethe return-codeidiom :thepresence
and type of error is encoded in the value returned by a function.
Failuretocorrectlycheckforsucherrorvaluesatfunctioncallsites
can leadto error-handling bugs(Section 4).
This paperpresents Effective Error-Specification Inference (EESI;
pronounced ee-see), a static analysis that infers function error-
specificationsforprogramsusingthereturn-codeidiom.A function
error-specification isthesetofvaluesthatthefunctioncanreturn
onerror.Forexample,thefunction acpi_pci_link_allocate_irq
intheLinuxkernelreturnsanegativeintegeronerror, acpi_ec_
allocreturns0onerror,and acpi_allocate_root_table returns
anonnegative integeronerror.
To understand the challenges in inferring error specifications,
considerthe following (intentionallyabstract)code:
intf1() {
if(f2() < 0) {
f3();
return 0;
}
return 1;
}
The function f1has only two possible return values 0and1. Look-
ing at the body of the function f1, we cannot infer whether f1
returns0or1onerror,orwhetheritisinfallible(doesnotreturn
anyerrorvalue).Thereisnothinginherentinthecodethatimplies
thataparticularvaluerepresentsanerror.Contrastthissituation
with thatin languagessupporting exceptionhandling: exceptions
are caughtandhandledinwell-labeled catchblocks.
Totacklethischallenge, EESIbootstrapstheanalysisbyutilizing
developer-provideddomainknowledge.Suchdomainknowledge
can include a list of functions that only occur along error paths
466
ESEC/FSE ’19, August 26ś30, 2019,Tallinn,Estonia DeFreez,MartinsonBaldwin, Rubio-González, andThakur
(error-only functions ), a list of error codes , or the error specifica-
tion for a few functions (Section 3.2). For example, if the domain
knowledge includes the fact that calls to function f3only occur
along error paths, then EESIwill infer that f1returns0on error; if
thedomainknowledgeprovidedincludesthefactthat f2returns
anonnegativevalueonerror,then EESIwillinferthat f1returns
1onerror.Byexpandinguponthisinitialknowledge, EESIinfers
errorspecifications.
Inpractice,thedomainknowledgerequiredfor EESIisverysmall,
typicallyconsistingofonlyasingleerror-onlyfunction andafew
functionerror-specifications(Section 5.1).Forexample,OpenSSL
was analyzed using the single error-only function ERR_put_error
andthesingleinitialerror-specificationthat mallocreturns0(null
pointer)onerror.Errorcodesareusedinpriorwork[ 21].However,
thedifferenceliesinthefactthat EESIexpandsonthisinitialdomain
knowledge, and is able to find function error-specifications that
arenot restrictedtosucherrorcodes.Forexample, EESIisable to
infer error specifications for functions that return zero, positive,
or nonnegative values on error even though the errorcodes in the
Linux kernel are negative integers.
Errorsmaypropagatethroughlongfunction-callchains,often
crossing subsystem boundaries. For example, a memory allocation
errorstartingattheLinuxkernelslaballocatorwillbefirstreturned
asanullpointerfrom slab_alloc beforebeingconvertedtoaneg-
ative error code in the IP routing function ip_route_input_mc ,
beforefinallybeingconvertedtoapositiveerrorvaluein xfrm4_
rcv_encap_finish ,sevenfunctioncallsawayfromtheoriginaler-
ror.Adevelopermightfinditdifficulttomanuallyinferthefunction
error-specification.Documentationoffunctionerror-specifications,
ifavailable,isoftenincorrect[ 22].Thefunctionerror-specifications
inferred by EESIcan be used at development time to determine
what errors need to be handled. Consequently, EESIneeds to be
scalable.Itcannotrelyonclientsofthecodetoinfertheerrorspec-
ifications,andneedstoinfererrorspecificationsforallfunctions
inthe program, not justpublicAPI functions.
EESIcastsfunctionerror-specificationinferenceascomputing
the least fixpoint of a set of constraints. The constraints are con-
structedviaaflow-sensitiveanalysisofthebody offunctions;the
inferrederrorspecificationsarecontextinsensitive(Section 3).This
formulation enables EESIto scale to large programs, while still
maintaining precision. EESItakes 5 min 25 sec to analyze 320K
lines of Linux file-system code, and obtains an overall precision of
0.93(Section 5.2).
This paper also presents ECC(Section4), an automated tool
that uses the function error-specifications inferred by EESIto find
error-handlingbugs,suchasinsufficienterrorchecks. ECCdetected
246 error-handling bugs across 9 programs, of which 110 have
been confirmed. ECCdetected 220 previously unknown bugs, of
which 99 are confirmed, and we are in the process of confirming
107 potential bugs. Two patches have already been merged into
OpenSSL(Section 5.4).
The contributionsofthis paper can be summarizedas:
•We develop EESI, a static analysis to infer function error-
specifications using domainknowledge (Section 3).
•Wedevelop ECC,atoolthatusesfunctionerror-specifications
to find error-handlingbugs(Section 4).1static int ext4_dx_csum_verify( struct inode *inode,
2 struct ext4_dir_entry *dirent) {
3struct dx_countlimit *c;
4struct dx_tail *t;
5intcount_offset, limit, count;
6
7if(!ext4_has_metadata_csum(inode->i_sb))
8 return 1;
9
10c = get_dx_countlimit(inode,dirent,&count_offset);
11if(!c) {
12 EXT4_ERROR_INODE(inode, "dir seems corrupt? Run
e2fsck -D.");
13 return 0;
14}
15limit = le16_to_cpu(c->limit);
16count = le16_to_cpu(c->count);
17if(count_offset+(limit* sizeof(struct dx_entry)) >
EXT4_BLOCK_SIZE(inode->i_sb) - sizeof(struct
dx_tail)) {
18 warn_no_space_for_csum(inode);
19 return 0;
20}
21t = (struct dx_tail*)((( struct dx_entry*)c)+limit);
22
23if(t->dt_csum != ext4_dx_csum(inode, dirent,
24 count_offset, count, t))
25 return 0;
26return 1;
27}
Figure 1: The function ext4_dx_csum_verify returns 1 for
success and0 forerror.
•Weevaluatetheprecisionoftheerrorspecificationsinferred
byEESIon real-world C code (Section 5.2), and compare
EESIwiththe state of the art (Section 5.3).
•Weevaluatetheeffectivenessof ECCatfindingerror-handling
bugsinreal-world C code (Section 5.4).
2 OVERVIEW
Figure1shows the ext4_dx_csum_verify functionfrom the ext4
Linuxfilesystem.Similartothefunction f1wediscussedinSec-
tion1, it can return either 0or 1.EESIis bootstrapped with the
initialdomainknowledgethatthefunction EXT4_ERROR_INODE is
anerror-onlyfunction :itisonlycalledonerrorpaths.Because ext4_
dx_csum_verify mustreturn 0afterthecallto EXT4_ERROR_INODE
on Line13,EESIinfers that 0is an error value for ext4_dx_csum_
verify.
Thisexampleillustratessomeofthechallengesofinferringfunc-
tionerror-specifications.Onechallengeisthattheerrorspecifica-
tionofafunctioncannotbe inferredfrom its returntype.Pointer-
returning functions often return a null pointer as an error value,
but not always. Identifying such a default error value is even more
difficult for integer-returning functions, such as ext4_dx_csum_
verify.Someprogramsrecommendaspecificconventionforerror
values, but these are not always strictly adhered to. For instance,
although many Linux functions return 0on success and a negative
error code on failure [ 21], the function ext4_dx_csum_verify is
oneofmanyexamplesthatdonotfollowthisconvention.Theer-
rorspecificationof ext4_dx_csum_verify is undocumented,and
467Effective Error-Specification Inference ESEC/FSE ’19, August 26ś30, 2019,Tallinn,Estonia
1static struct buffer_head *__ext4_read_dirblock(...) {
2if(ext4_dx_csum_verify(inode, dirent))
3 set_buffer_verified(bh);
4else{
5 ext4_error_inode(inode, func, line, block,
6 "Directory index failed csum");
7 brelse(bh);
8 return ERR_PTR(-EFSBADCRC);
9}
10}
Figure 2: Excerpt from the function __ext4_read_dirblock ,
which hastheonlycallto ext4_dx_csum_verify .
ReturnedConstant
ReturnedFunctionInference 
EngineLLVM
IRFunction Error
SpecificationsDomain 
Knowledge
CallConstraints
Figure 3: EESI Architecture
a developer must read the definition of the function to learn this
specification, often requiring following longcallchains.
Priorwork[ 13]deduceserrorspecificationofafunctionfromits
usageandonempiricalcharacteristicsoferrorpaths.However,such
an approach must necessarily resolve inconsistencies between call
sitesthroughavotingmechanism,anddoesnotworkforfunctions
withonlyafewcallsites.Forexample,thefunction ext4_dx_csum_
verifyiscalledexactlyonceintheLinuxkernel,fromthefunction
__ext4_read_dirblock (Figure2).
Bugsrelatedtoincorrecterrorhandlingcanbesubtle.Whenthis
call toext4_dx_csum_verify was introduced into __ext4_read_
dirblock inFebruary2013[ 28],ext4_dx_csum_verify returned
1 in two failure cases, leading to undetected checksum failures
inext4,thedefaultfilesystemofmanyLinuxdistributions.This
issue was fixed in 2016 [ 12], whenext4_dx_csum_verify was
patchedtoalwaysreturn0onfailureand1onsuccess.Thisexample
illustratestheneedforanautomatedtechniquethatinfersfunction
error-specifications,andidentifiesbugsrelatedtoincorrecterror
handling.
3 ERROR-SPECIFICATION INFERENCE
This section describes the static analysis used by EESIto infer
function error-specifications (Figure 3) starting with some basic
definitions.
Definition 1. Anerrorvalue forafunction fisavaluereturned
byfthat indicates fencounteredaruntimeerror. ■
Example3.1. Thevalue0isanerrorvalueforfunction ext4_dx_
csum_verify inFigure1;thisfunctionreturns0whenitencounters
aruntimeerror,for example,onLine 13.⊤
≤0/nequal0≥0
<0 0>0
⊥γ(⊤)={...,−1,0,1, ...}
γ(/nequal0)={...,−2,−1,1,2, ...}
γ(≤0)={...,−1,0}γ(<0)={...,−2,−1}
γ(≥0)={0,1, ...}γ(>0)={1,2, ...}
γ(0)={0} γ(⊥)=∅
β(v)=<0ifv<0
0ifv=0
>0ifv>0
Figure 4: Extended-sign lattice Lwith its concretization
function γ:L→P(Z)and abstractionfunction β:Z→L
The set of error values for a function is its error specification .
Functions that have no error values, such as the C library function
strcmp,arecalled infalliblefunctions .However,individualcallers
ofafunctionmighttreatcertainreturnvaluesasindicatinganerror
hasoccurred,butthesereturnvaluesarenoterrorvaluesforthe
called function. For example, a caller of strcmpmight treat the
result of a specific string comparison as an error, but this does not
mean that strcmpisencounteringan error.
Tomaketheproblemofinferringthesetoferrorvaluestractable,
we abstract sets of error values to elements in the extended-sign
latticeL.Thelatticealongwithitsconcretizationfunction γ:L→
P(Z)and abstraction function β:Z→Lis shown in Figure 4. For
example,theelement ⊤concretizestothesetofallintegers Z;⊥
concretizes to the empty set; β(−1)=<0;β(1)=>0;β(0)=0.
TheelementsofLrepresentthemostcommonchecksthatdevelop-
ersperformonerrorvalues. This latticecapturesnull-dereference
checksbecause the null valuefor pointers isrepresentedby0.
Definition 2. Given the set of functions Fin the program, the
error specification E:F→Lmaps each function f∈Ftoℓ∈L
such that γ(ℓ)contains the setof errorvaluesfor f. ■
Example 3.2. In Figure 1,E(ext4_dx_csum_verify )=0∈L.
Thisfunctionreturns0onerrorandtherearenoothererrorvalues.
3.1 IntraproceduralAnalyses
This section describes the flow-sensitive, intraprocedural analyses
usedbyEESI.WeuseFtodenotethesetoffunctionsintheprogram,
Sftodenotethesetofstatementsinfunction f∈F,andcallsites(f)
to denotethe setofstatements that contain acallto function f.
CallConstraintsAnalysis. CallConstraints analysisdetermines
the constraints on function return values necessary to execute a
statement.
Definition3. Givenafunction f∈F,Constraint f(s,f′)=ℓ∈L
if the statement s∈Sfmay be executed when any call to function
f′∈Finfreturns avaluein γ(ℓ). ■
Example 3.3. Constraint f(s3,ext4_dx_csum_verify )=/nequal0∈
Lin Figure 2, because the statement on Line 3(s3) is executed
when the call to the function ext4_dx_csum_verify in function
f=__ext4_read_dirblock returns anon-zerovalue.
468ESEC/FSE ’19, August 26ś30, 2019,Tallinn,Estonia DeFreez,MartinsonBaldwin, Rubio-González, andThakur
f∈Finit
E(f)←Einit(f)InitSpecf/nelementFinit
E(f)←⊥InitBots∈SfRetConst f(s)=c c∈EC
E(f)←E(f)⊔β(c)ErrorCode
s∈SfRetConst f(s)=c s∈callsites(f′)f′∈Feo
E(f)←E(f)⊔β(c)ErrorOnlyCall
s∈SfRetConst f(s)=cConstraint f(s,f′)=ℓ ℓ⊓E(f′)/nequal⊥ℓ/nequal⊤
E(f)←E(f)⊔β(c)ErrorConstant
s∈SfRetFunc f(s)=дConstraint f(s,f′)=ℓ ℓ⊓E(f′)/nequal⊥
E(f)←E(f)⊔E(д)CallPropagation
Figure 5: EESI InferenceRules
ReturnedConstant Analysis. ReturnedConstant analysis deter-
mines the constant, if any, that must be returned if a statement
executes.
Definition 4. Givenafunction f∈F,RetConst f(s)=c∈Ziff
must return the constant cif the statement s∈Sfis executed. ■
Example3.4. RetConst f(s5)=RetConst f(s7)=RetConst f(s8)=
-EFSBADCRC inFigure 2,wheres5,s7,ands8arestatementsonLines
5,7,and8,respectively,infunction f=__ext4_read_dirblock ,
andthe macro EFSBADCRC definesaconstant.
ReturnedFunction Analysis. ReturnedFunction analysis deter-
mines the call return value, if any, that must be returned by a
function if astatementexecutes.
Definition 5. Givenafunction f∈F,RetFunc f(s)=f′∈Fiff
mustreturnthevaluereturnedbyacalltofunction f′infifthe
statement s∈Sfisexecuted. ■
Example 3.5. RetFunc f(s5)=hid_quirks_init in Figure 8(c),
wheres5is the statement on Line 5, andf=hid_init , because
ifLine5isexecutedthenthe function hid_init must returnthe
valuereturnedbyacallto hid_quirks_init .
3.2 Domain Knowledge
EESIutilizes three types of domain knowledge to bootstrap the
error-specification inference:
(i) Error codes EC⊆Zare specific constants that are used to
denoteanerrorvaluebyconvention.Consequently,ifafunction
freturns an error code c∈ECthencis an error valuefor f. For
example,macrossuchas ENOMEMandEFSBADCRC areusedtodenote
errorcodes inthe Linux kernel.
(ii) Error-only functions Feo⊆Fare functions that are only
calledwhenanerrorhasoccurred.Consequently,apathinfunction
дhastoreturnanerrorvalueifacalltoafunction feo∈Feooccurs
along that path. For example, ext4_error_inode in Figure 2is an
error-only function. Consequently, -EFSBADCRC isan errorvalue
for the function __ext4_read_dirblock .
(iii)Initialerror-specification Einit:Finit→Lspecifiesfunc-
tionerror-specificationsforthefunctions Finit⊆F.Forexample,
Finit={malloc}andEinit(malloc)=0∈Lfor OpenSSL, which
states that mallocreturns 0(nullpointer) onerror.3.3 InterproceduralInference Engine
Figure5shows the inference rules that EESIuses to infer the func-
tionerror-specification E:F→L(Definition 2)usingtheresults
of the prior intraprocedural analyses (Section 3.1) as well as the
domainknowledge (Section 3.2).
TheInitSpec ruleinitializesE(f)using the initial error speci-
ficationEinit(f)whenf∈Finit,andtheInitBot ruleinitializes
E(f)to⊥whenf/nelementFinit.
A constant cis returned by a function f∈Fif there exists a
statement s∈SfandRetConst f(s)=c. TheErrorCode ,Erro-
rOnlyCall , andErrorConstant rules all determine whether a
constant cthat can be returned by a function fis an error value
forf.Ifcisdeterminedtobeanerrorvaluefor f,thentheerror-
specification of fis updated using the abstraction of c; that is,
E(f)←E(f)⊔β(c).
TheErrorCode rulestates that if the function fcan return
an errorcode c∈EC,thencisan errorvaluefor f.
TheErrorOnlyCall rulestatesthatifstatement sinfunction
fis a call to an error-only function feoand the function freturns
the constant cwhensisexecuted,then cisan errorvaluefor f.
TheErrorConstant rulestates that if function freturns
the constant cwhen a call to function f′returns an error value,
thencis an error value for f. If the condition Constraint f(s,f′)=
ℓ∧ℓ⊓E(f′)/nequal⊥istruethen sinfcouldbeexecutedwhenthe f′
returnsanerrorvalue.Therestriction ℓ/nequal⊤isaddedtothisruleto
limitthedetrimentalimpactofmissederrorchecks,orotherwise
incorrectcode,onspecification inference.
TheCallPropagation rulestatesthatiffunction freturns
thereturnvalueoffunction дwhenacalltofunction f′returnsan
error value, then the error values of дare also error values for f.
Hence,theerrorspecification E(f)canbeupdatedtoincludethe
errorspecification E(д).
Afterinitializingtheanalysisusingthe InitSpec andInitBot
rules,theremainingrulesareapplieduntilfixpoint,followingastan-
dard Kleene iteration sequence. The analysis terminates because
the height of the lattice Lis finite. The soundness of the inference
rulesfollowsfromthesoundnessoftheunderlyingintraprocedural
analysesandthe correctness of the domainknowledge.
469Effective Error-Specification Inference ESEC/FSE ’19, August 26ś30, 2019,Tallinn,Estonia
4 ERROR-HANDLINGBUG DETECTION
This section describes a static analysis that finds error-handling
bugsusingthefunctionerror-specification E:F→Linferredby
EESI.Specifically,wedescribe Error-CheckChecker (ECC)thatfinds
bugsrelatedto insufficientorincorrecterrorchecks.
Definition6. Anerrorcheck isaconditionalbranchstatementthat
tests if the valuereturnedbyafunctioncallisan errorvalue. ■
ECCfindsinconsistenciesbetweentheerror-specificationofa
function(Definition 2)andtheerrorchecks(Definition 6)associated
with calls to that function. These inconsistencies are manifested in
three differentbugpatterns.
(a) Insufficient error checks. Insufficient error checks occur
when the error checks associated with a call to a function ffail
tocoveralloftheerrorvaluesthat fmayreturn.Thiscanoccur
when the return value of a function is not saved at all, saved but
not checked, or when the return value of a function is checked for
arangeofvaluesthatisapropersubsetoftheerrorvaluesthata
function mayreturn.
(b) Inverted error checks. An inverted error check is an error
checkthatgetsthedirectionoftheerrorpathwrong.Acommon
cause of inverted error checks is the use of error values that do not
conformtotheidiomaticerrorhandlingconventionsusedtosignal
errors in C, such as returning 0 on error. The bug involving the
originalversionof ext4_dx_csum_verify describedinSection 2
is an instance of an inverted error check. In this case, the bug was
fixedbymodifying ext4_dx_csum_verify to return 1onerror.
(c) Incomplete error-specifications. Another type of inconsis-
tency arises when the error check for a function call is correct, but
the implementation of the function does not return the correct set
of errorvalues. This ariseswhen there are error checks for values
thatafunctioncannotreturn,resultingindeadcode.Anexampleof
a previously unknown bug of this type that we found in the Linux
kernel isshowninFigure 8(b).
5 EXPERIMENTALEVALUATION
The experiments described in this section were designed to answer
the following researchquestions:
RQ1Howaccuratelydoes EESIinferfunctionerror-specifications?
RQ2Howdoes EESIcompare withthe state ofthe art?
RQ3Howeffectiveis ECCatfindingerror-handlingbugswhen
using the functionerror-specifications inferredby EESI?
5.1 ExperimentalSetup
Benchmarks. Table1liststheprogramsusedintheevaluationof
EESIandtheirsize.Theseprogramswerechosentobearepresenta-
tive cross section of important software written in C ranging from
operating systems to cryptographic libraries. łLinux FSž stands for
Linux File System, which includes the virtual file system (VFS), the
Linux memory manager, and fourfile systems: ext2,ext4,btrfs,
andFAT.łLinux NFCžis thenear-fieldcommunicationsubsystem
of the Linux kernel. łFull Linux kernelž refers to a runnable Linux
kernel includingallcomponentsinthe defaultconfiguration.
Domain Knowledge. We used the following types of domain
knowledge (see Section 3.2andTable 2) when running EESI:(i)Errorcodes(EC). 34errorcodeswereusedwhenrunning EESIon
LinuxFS,LinuxNFC,andFullLinuxkernel.Noerrorcodeswere
usedfor the restofthe programs.
(ii) Error-only functions. EESIrequired the use of few error-only
functions. Finding these error-only functions was easy, because
they mostly contained errorin their name. For example, OpenSSL
was analyzed using the single error-only function ERR_put_error .
(iii) Initial error-specification. EESIrequired the use of few initial
error-specifications.Theerrorspecificationforallocationfunctions,
such asmalloc,calloc, and__slab_alloc , was used as initial
error-specificationwhenrunning EESIontheprograms,aslistedin
Table2.Errorspecificationsfor13 pthreadlibraryfunctionswas
usedas initialerror-specification when analyzing netdata.
Theerrorspecificationsforthefollowingfunctionswasalsoused
when analyzing Linux FS: sync_inode_metadata ,ext4_inode_
locandjbd2_journal_metadata . These functions were identi-
fied by looking at the position of their corresponding vertices in
thereturnpropagationgraphgeneratedforLinuxfilesystems.A
return propagation graph is a directed graph where every vertex
representsaprogramfunctionandthereisanedgefrom utovif
the function corresponding to vpropagates the return value of the
function corresponding to u. If many vertices are reachable from a
source vertex uin the return propagation graph, then EESIis more
likelytoinfererrorspecificationsfornewfunctionswhentheerror
specification for the function corresponding to uis provided as an
initialerror-specification.
Analysis and Bug Checking Performance. EESIandECCare
implementedusingLLVM[ 14],andareavailable at https://github.
com/ucd-plse/eesi . The full Linux kernel analysis was run on an
Amazon EC2 r4.2xlarge instance, while the rest were run on a 3.60
GHzi7-4790CPUwith32GBofRAM.Table 1showstheruntime
performance of EESIandECC. For 6 out of 9 programs, EESItakes
less than one minute to run. The analyses of OpenSSL, Linux FS,
andFullLinuxkerneltake1min33sec,5min25sec,and12min
47 sec, respectively. ECCis also efficient, with Full Linux kernel
taking the mosttime,11 min 34 sec.
5.2 RQ1: Accuracyof EESI
EESIidentifieserrorspecificationsfor18,919functionsamongall
programsanalyzed.Table 2providesanoverviewofthetypesof
Table 1: Size of programs in KLOC (thousands of lines of
code),andruntimeperformanceofEESIandECC(timesare
minutes:secondsofelapsed wall clocktime).
KLOC EESI ECC
OpenSSL 231 1:33 2:48
PidginOTRv4 7 0:05 0:04
mbedTLS 192 0:32 0:38
netdata 60 0:36 0:59
Linux FS 320 5:25 3:35
Linux NFC 32 0:37 0:35
FullLinux kernel 1,295 12:47 11:34
LittleFS 2 0:03 0:02
zlib 1 0:09 0:08
470ESEC/FSE ’19, August 26ś30, 2019,Tallinn,Estonia DeFreez,MartinsonBaldwin, Rubio-González, andThakur
Table 2:Domainknowledgeused byEESIandthetotal numberofspecification pertype inferred byEESI
Error-Only Functions InitialError-Specifications SpecificationsInferred byEESI
Program EC #Funcs Example #Specs Example <0 0≤0>0/nequal0≥0
OpenSSL 0 1 ERR_put_error 1 malloc(=0)268 2,931 259 72 10 173
PidginOTRv4 0 0 NA 4 malloc(=0) 0 12 0 3 0 0
mbedTLS 0 1 mbedtls_strerror 2 calloc(=0) 231 23 22 2 1 0
netdata 0 1 perror 16 malloc(=0) 11 24 1 4 0 14
Linux FS 34 12 ext4_error 7ext4_inode_loc (<0)2,374 668 625 34 7 21
Linux NFC 34 0 NA 4 __slab_alloc (=0) 838 141 26 18 0 7
FullLinux kernel 34 0 NA 4 __slab_alloc (=0) 5,861 2,981 578 394 13 163
LittleFS 0 0 NA 1 NA 14 2 28 0 0 0
zlib 0 0 NA 1 malloc ( =0) 53 12 0 0 0 0
Total 15 35 9,650 6,794 1,539 527 31 378
inferred specifications. The two most common types are <0and
0with a total of 16,444 specifications. We observe that integer-
returning functions commonly return a negative number onerror,
which is a strong convention in the Linux kernel, and that pointer-
returning functions commonly return 0 (null pointer) on error.
However,theseconventionsarenotalwaysadheredto: EESIalso
infers2,475errorspecificationsofthetypes ≤0,>0,/nequal0,and≥0.
OpenSSL, Linux FS and Full Linux kernel include specifications
from all types. For example, EESIinfers that the Linux FS function
__ext4_read_dirblock (Figure2) has the errorspecification <0.
We compared theoutput of EESIwiththeground truthfor395
functions to evaluate the accuracy of the specifications inferred by
EESI. Ground truthwas obtained via manual review of thesource
code. These 395 specifications included a random sample of 100
(93 correct) specifications from the projects in Table 2, a random
sample of 50 (47 correct) OpenSSL functions, all 95 (92 correct)
functions defined by the zlib library, and an additional 150 (137
correct) randomly sampled specifications in OpenSSLthat overlap
between EESIand APEx (Section 5.3.2). In total, 369 of the 395
function error-specifications inferred by EESIexactly matched the
ground truth. Thus the estimatedprecision of EESIis0.93.
Oneoftheprimarysourcesofinaccuracyin EESIiswhenafunc-
tionusesanoutparameterinsteadofareturnvaluetosignalerrors.
Figure6showsonesuchcasewherethevalue 0isincorrectlyin-
ferred as an error value for tcp_fastopen_defer_connect , when
actually the pointer argument *erris set to-ENOBUFS . Pointer
1bool tcp_fastopen_defer_connect( struct sock *sk,
2 int*err) {
3...
4if(tp->fastopen_req)
5 tp->fastopen_req->cookie = cookie;
6else
7 *err = -ENOBUFS;
8return false; // false is defined as 0
9}
Figure 6: EESI incorrectly infers that 0 is an error value for
tcp_fastopen_defer_connect duetotheuseofanoutparam-
etererrto signalerrors.operands behave similarly to return values in that the caller needs
to check*errinstead of thereturnvalue. Weplanto address this
infuture versionsofthe EESIimplementation.
Frommanual inspectionof395functions, weconcludethat
EESIinferserrorspecificationswithaprecisionof0.93 ,
answeringRQ1.
5.3 RQ2: Comparisonwith State-of-the-Art
Thissectionpresentsaqualitative(Table 3)andquantitative(Ta-
ble4) comparison of EESIwith the error-specification inference
toolAPEx[ 13].
5.3.1 QualitativeComparison. Wecomparethetoolsintermsof
the following fourcharacteristics:
(1) EESI analyzes implementations directly. EESIinfers func-
tion error-specifications directly from the program. APEx relies on
clients of the program to infer function error-specifications. Ob-
tainingandbuildingindividualclientsaddsasignificantamountof
manual effortto the specification inference task.
(2) EESI infers specifications for internal and API functions.
EESIinfers specifications for internal and API functions, while
APEx is limited to frequently used API functions. An API function
Table3:QualitativecomparisonofEESIwithAPEx.(1)EESI
analyzesprogramsdirectlyinsteadofrequiringtheirclients.
(2)EESIinfersfunctionerrorspecificationsforbothinternal
andAPIfunctions.(3)EESIincorporatesdomainknowledge,
insteadofrelyingonthepath-lengthheuristicusedbyAPEx.
(4) EESI scales to large programs, while APEx does not due
to its use ofpath-sensitive symbolicexecution.
EESIAPEx
(1) DirectAnalysis ✓ ✗
(2a) API Functions ✓ ✓
(2b) Internal Functions ✓ ✗
(3) DomainKnowledge ✓ ✗
(4) Scalable ✓ ✗
471Effective Error-Specification Inference ESEC/FSE ’19, August 26ś30, 2019,Tallinn,Estonia
Table 4: Quantitative comparison of EESI with APEx. AllFnsis the total number of non-void functions defined by the library.
APIFnsisthenumberofnon-voidfunctionsdefinedbythelibrarythatarecalledfromoneoftheclientslistedinSection 5.3.2.
Timecompares the time each tool requires to perform its analysis (mm:ss). Total Specs is the intersection of the tool output
withAllFns.APISpecs istheintersectionofthetooloutputwith APIFns.Precision istheratioofcorrectspecificationsreported
bythetooltothetotalnumberofAPIspecsreportedbythetool. RecallistheratioofthetotalnumberofAPIspecsreported
bythetooltothetotalnumberofAPIspecsthatcanreturnanerror.TheOpenSSLresultswerecalculatedforarandomsample
of50APIfunctions.
Time Total Specs API Specs Precision Recall
AllFns APIFns EESIAPEx EESIAPEx EESIAPEx EESIAPEx EESIAPEx
zlib 147 25 0:15 121:15 65 8 17 8 1.0 0.75 0.71 0.33
OpenSSL 7,031 644 1:19 93:20 3,713 313 339 313 0.88 0.76 0.68 0.45
is a function that is defined in a library, and called by clients of
thelibrary.Internalfunctionsarefunctionsthatarenotavailable
toclients.Internalfunctionsareoftenrefactoredintosmallfunc-
tionswhichareonlycalledfromafewlocations.Therefore,relying
on patterns among a large number of calls to these functions to
determinetheerrorspecificationofafunctionisnotaviableoption.
(3)EESIincorporatesdomainknowledge. EESIisbootstrapped
withsmallamountsofdeveloper-providedknowledge.Thisinput
providesafirmfoundationonwhichadditionalfunctionerrorspeci-
ficationscanbeinferred.Incontrast,APExreliesontheassumption
that error paths are shorter than non-error paths. This assumption
frequentlydoesnothold.Thefunction sidtab_reverse_lookup
is one example that illustrates the problem with this approach. An
excerptfromthisfunction,simplifiedforthepurposeofpresenta-
tion,isshowninFigure 7.Atthetopofthefunction,acachelookup
isperformedtocheckiftheentrycanbereturned.Whenthecache
lookup is successful, the function returns 0along the shortest path
throughthefunction.Theerrorcode -ENOMEMisreturnedonfailure;
this errorpathisconsiderably longer thanthe successpath.
(4)EESIscalestolargeprograms. Evenforlargeprogramssuch
astheLinuxkernel, EESIisabletoinfererrorspecificationsforthou-
sands of functions (Table 2) in only a few minutes (Table 1). APEx
can take hours to infer specifications for only the API functions
insmalleruser-spacelibraries[ 13].APExreliesonpath-sensitive
symbolic execution provided by clang static analyzer, which has
already been extensivelyoptimizedfor performance.
1static int sidtab_reverse_lookup( struct sidtab *s,
2 struct context *context, u32 *index) {
3...
4rc = sidtab_rcache_search(s, context, index);
5if(rc == 0)
6 return 0;
7rc = -ENOMEM;
8...// 35 statements omitted
9rc = 0;
10out_unlock:
11return rc;
12}
Figure 7:Example ofashort non-errorpath fromLinux5.3.2 QuantitativeComparison. Weprovideaquantitativecompar-
isonofEESIwithAPExforthelibrariesOpenSSLandzlib.Weused
theclientslistedin[ 13,Table5]toinferspecificationsforOpenSSL
and zlib with APEx: clamav-0.101.2, curl-7.64.1, gnutls-3.6.7, httpd-
1.4.53,lighttpd-1.4.53,lynx-2.8.9,nginx-1.15.12,openssh-8.0p1tor-
0.3.5.8,andmutt-1.12.1.WecomparedAPExresultstotheresults
obtainedwhenrunning EESIonOpenSSLandzlibdirectly(without
the needto analyze theirclients).
NotethatAPExcantreatanapplicationasaclientofitself,how-
ever this requires the application to include a large number of calls
toitsfunctions.WeattemptedtouseAPExtoinferspecificationsin
theLinuxkernelwhentreatingitasaclientofitself.APExcrashed
whenrunontheLinuxkernel;thesymbolicexecutionphasepro-
duced constraints that the APEx analysis scripts were unable to
process.APExalsocrashedwhenusingOpenSSLasaclientofitself,
thus we did not include it when running APEx for OpenSSL. We
didnotconsiderrunningAPExontherestofourprogramsbecause
either they are not libraries, or they do not include a large number
offunctioncallsforAPExtobeeffective.Togatherrun-timeperfor-
mance,thetoolswererunonanAmazonEC2c5.9xlargeinstance
with36 CPUcores and72GBof memory.
All25non-voidzlibAPIfunctionswereusedforevaluation.Due
to the size of the OpenSSL library, a randomsample of 50 non-void
OpenSSL API functions were used for evaluation. Precision and
recallaredefinedintermsoftheexpectednumberofAPIfunctions;
the number of API functions that are called from any of the clients
considered by APEx that can return an error value according to
groundtruth.Groundtruthwasestablishedbymanuallyreviewing
the zlib and OpenSSL source code. Of the 25 zlib API functions,
24 could return an error. Of the 50 randomly sampled OpenSSL
functions, 37 could return an error.
Definition 7. Precision andRecallare definedas:
Precisiondef=|Correct|
|Total|Recalldef=|Total∩Ground|
|Ground|
whereTotalisthesetofspecificationsreportedbythetool, Correct
isthesetofspecificationsreportedbythetoolthatmatchtheground
truth, and Groundis the ground truth set of non-void functions
that can return an error. ■
Table4lists the total number of functions and the total num-
ber of API functions for each library. The table also summarizes
472ESEC/FSE ’19, August 26ś30, 2019,Tallinn,Estonia DeFreez,MartinsonBaldwin, Rubio-González, andThakur
Table 5:Summary ofbugsreported byECC.
TBR: total bug reports, CT: confidence threshold, IBR: in-
spectedbugreports,CB:confirmedbugs,PB:potentialbugs,
BB: benign bugs,FP:falsepositives.
IBRBreakdown
TBR CT IBR CB PB BB FP
OpenSSL 2,014 0.8 112 15 48 2 47
PidginOTRv4 43 0 43 31 7 0 5
mbedTLS 6 0 6 1 0 1 4
netdata 58 0 58 35 15 0 8
Linux FS 1,470 0.8 49 7 12 5 25
Linux NFC 242 0.8 29 2 9 11 7
FullLinux kernel 2,873 0.9 53 19 13 4 17
LittleFS 2 0 2 0 0 0 2
zlib 15 0 15 0 3 6 6
Total 6,723 367 110 107 29 121
theresults.BecauseAPExreliesonclientstoinferfunctionerror-
specifications,itonlyinfersspecificationsforAPIfunctionsandnot
internalfunctions.Thisisreflectedinthedifferenceinthetotalnum-
berofspecificationsinferredbyeachtool(the TotalSpecs column
inTable4).Inparticular, EESIfinds8×and11×morespecifications
than APEx in zlib and OpenSSL, respectively. When restricting the
comparisontoAPIfunctions, EESIalsofindsmorespecifications
than APEx while exhibiting higher precision and recall for both
libraries in considerably less time. EESItook 15 sec to analyze zlib,
and1min19sectoanalyzeOpenSSL.APExtook2hoursand1.5
hoursto analyze the clientsofzlib andOpenSSL, respectively.
In addition to the 50 randomly sampled OpenSSL API functions,
wealsorandomlysampled150OpenSSLspecificationsforfunctions
where both EESIandAPEx providedaspecification.Of these, 137
EESIspecifications and118APExspecifications were correct.
EESIinfers specifications for internal and API functions, is
not dependent on the path-length heuristic, is more scalable,
ismoreprecise,andinfersmoreAPIfunctionspecifications
thanthe state ofthe art. This answers RQ2.
5.4 RQ3: Usefulnessof EESISpecificationsin
Bug Finding
In this section, we evaluate the bug-finding effectiveness of ECC
(Section4), which uses the function error-specifications inferred
byEESI(Section3). Table5summarizes the bug reports produced
byECC. The total bug reports (TBR) per program varied from 2 to
2,873.TheIBRcolumnliststhenumberofbugreportswemanually
inspected. We inspected all bug reports for the 5 programs for
whichECCgenerated less than 100 bug reports. For the remaining
4 programs, we computed a confidence for each bug report, and
onlyinspectedbugreportswhose confidencewasgreaterthanor
equal to the confidence threshold (CT) . The confidence threshold
waschosensoastolimitthenumberofinspectedbugreportsto
around 100per program.The confidence ofabugreportinvolving
the returnvalueofafunction fisdefinedasthe number ofcalls
tofthat have correct error-checks divided by the total number ofcallstof.Therestofthesectiondescribesthebreakdownofthe
inspectedbugreports (IBR Breakdown).
Confirmedandpotentialbugs. Intotal,wefound 110confirmed
bugs(CB) and107potentialbugs(PB) .Confirmedbugs includethe
following:bugsthatwereportedandwereconfirmedbydevelopers
(2),bugsthatwereindependentlyfoundbyothers(11),andbugs
that we confirmed ourselves (97). Potential bugs are instances in
whichthereportisnotanobviousfalsepositive,butthecomplexity
ofthecodepreventsusfromconfirmingthebugwithoutadditional
input from developers. Of the 110 confirmed bugs, 99 bugs were
previously unknown; all of the 107 potential bugs were previously
unknown. Herepreviouslyunknownmeansthat,toourknowledge,
no one knew about them. All bugs were previously unknown to
us. Note that confirmed bugs have been found in all programs
exceptforLittleFSandzlib.Weareintheprocessofreportingall
confirmedandpotentialbugstodevelopers.Patchesweprovided
for two of the OpenSSL bugs were merged into OpenSSL for the
1.1.1brelease [ 5,6].
Confirmed bugs in Linux. ECCfound24 previously-unknown,
confirmed bugs in version 5.0-rc3 of the Linux kernel using error
specifications generated by EESI. Figure8shows one such bug.
InFigure 8(a),thefunction hid_modify_dquirk returnstheerror
code-ENOMEMonLine6ifkzallocisunable toallocate memory.
The function hid_quirks_init in Figure 8(b)correctly checks
the return value of hid_modify_dquirk on Line5, but fails to
propagate the error value. Consequently, EESIinfers that the error
specificationfor hid_quirks_init is⊥.Notallerrorsneedtobe
propagated, but in this case we observe an inconsistency between
the error specification for hid_quirks_init and the error check
onLine4inFigure 8(c).TheerrorcheckonLine 4resultsindead
code.
Confirmed bugs in OpenSSL. ECCfound8 previously-unknown,
confirmed bugs in version 1.1.1a of OpenSSL. Patches sent by us
for two of these bugs have been merged [ 5,6], and we are in the
processofreportingthe remaining.
Figure9shows a previously unknown bug that ECCfound in
OpenSSL.OnLine 6,thecallto M_ASN1_new_of canreturnanull
pointer on memory-allocation failure. On Line 9, this pointer is
dereferenced,resultinginasegmentationfaultif rekisnull.We
generatedapatchforthisbug,whichwasacceptedbytheOpenSSL
developers andmergedintoOpenSSL 1.1.1b[ 6].
It is not immediately obvious that M_ASN1_new_of can return
a null pointer at all, and even less obvious that it returns a null
pointerinresponse tomemory-allocationfailure. M_ASN1_new_of
is a macro wrapping the function ASN1_item_new .ASN1_item_
newreturnsnull when ASN1_item_ex_new returnsnull,which in
turnpropagatestheerrorfrom asn1_item_embed_new ,whichre-
turns null when the OPENSSL_zalloc macro wrapping CRYPTO_
zallocfails,whichpropagateserrorsfrom CRYPTO_malloc .Finally,
CRYPTO_malloc failswhen mallocreturnsanullpointer,allowing
EESIto infer that on Line 6,rekwill be null when mallocfails.
Trackingdownsuchlongerror-propagationchainsmakesitdifficult
for adeveloper to manually inferfunction errorspecifications.
Because of its importance [ 18], OpenSSL has been reviewed
extensively. In January 2019, Quarkslab performed a security as-
sessmentoftheOpenSSLcode,spending60man-daystoauditfour
473Effective Error-Specification Inference ESEC/FSE ’19, August 26ś30, 2019,Tallinn,Estonia
1static int hid_modify_dquirk(...) {
2...
3intret = 0;
4hdev = kzalloc( sizeof(*hdev),...);
5if(!hdev)
6return -ENOMEM;
7...
8out:
9kfree(hdev);
10return ret;
11}
(a)hid_modify_dquirk returnszeroonsuccess
and a negativeerror on failure.1inthid_quirks_init(...) {
2...
3for(;n<count && qparam[n]; n++) {
4...
5if(hid_modify_dquirk(...) != 0){
6pr_warn("Could not parse HID
quirk module param");
7}
8}
9return 0;
10}
(b)hid_quirks_init checks for hid_modify_
dquirk’serror,butfailsto propagate it.1static int __init hid_init( void) {
2intretval = -ENOMEM;
3retval = hid_quirks_init(...);
4if(retval)
5 gotousbhid_quirks_init_fail;
6...
7return 0;
8...
9usbhid_quirks_init_fail:
10return retval;
11}
(c)hid_init expectserrortopropagate,result-
ing indead code.
Figure 8: Bug found by ECC in Linux 5.0-rc3 resulting from an incomplete error specification. The error originating in (a)is
notpropagated by thefunction shownin (b).The missing propagation results indeadcodein (c).
1intcms_RecipientInfo_kari_init(...) {
2ri->d.kari=M_ASN1_new_of(CMS_KeyAgreeRecipientInfo) ;
3if(!ri->d.kari)
4 return 0;
5...
6rek = M_ASN1_new_of(CMS_RecipientEncryptedKey);
7...
8if(flags & CMS_USE_KEYID) {
9 rek->rid->type = CMS_REK_KEYIDENTIFIER;
10}
11}
Figure9:NullpointerdereferencefoundbyECCinOpenSSL,
which was previously unknown to the OpenSSL developers.
We provided apatch that was merged into OpenSSL 1.1.1b.
components of OpenSSL [ 1]. In the code-quality section of their
report on the Secure Remote Password (SRP) protocol, they find
eight cases where the return value of a function is not checked for
errors.Sevenoftheseeightbugsarereported byECC .
Confirmed bugs in Pidgin OTRv4. ECCfound31 previously-
unknown,confirmederror-handlingbugs inthePidginpluginthat
supports the upcoming v4 standard of Off-the-record messaging
(OTR). OTR provides deniability for instant messaging conversa-
tions [3], making it useful for journalists and other actors in sit-
uationswhere itmightbeimportant todenythata conversation
occurred. This OTR plugin was chosen because of its global impor-
tance, and because the developers had identified error-handling
bugsasahighpriority.Thedefectsidentifiedby ECCwouldlead
to crashesorotherundefinedbehaviorinthe plugin.
Benign bugs. Table5also reports 29 benign bugs (BB) . These
areinstancesinwhichchecksareindeedmissing( ECCcorrectly
reports them), but the missing checks do not result in a serious
enough problemtowarrantafix. Anexample ofthiswouldbe an
unchecked output-error during logging; even though the specifica-
tioniscorrect,the errorisconsideredbenign inour evaluation.
Falsepositives. Table5showsthenumberof falsepositives (FP)
reported by ECC. Table6showsa breakdown of the types of false
positives we encountered while inspecting the bug reports for the
threeprograms withthe mostfalsepositives. łIncorrectSpecžfalse
positives occur in ECCwhenEESIhas inferred the incorrect errorTable6:BreakdownoffalsepositivesinECCbugreportsfor
asubset ofprograms.
Linux FS OpenSSL FullLinux Total
IncorrectSpec 1 0 0 1
MissedChecks 21 29 14 64
Interprocedural 1 8 2 11
OutParameter 1 10 0 11
nofail 1 0 1 2
Total 25 47 17 89
specification for a function. Only one of the false positives in ECC
wasdueto inaccuraciesinerrorspecifications inferredby EESI.
ThelargestnumberoffalsepositivesareduetołMissedChecksž,
where the implementation of ECCfailed to identify an error check.
Forexample,theLinuxkerneldefinesassertionfunctionsthatcrash
thekerneloncertainconditions. ECCisnotawareofthesefunctions
and,therefore,reportsthereturnvalueasunchecked.Improving
ECCto remove such false positives ispart of future work.
łInterproceduralžfalsepositivesoccurwhentheerrorvalueis
passed as an argument to callee function that contains the error
check. łOutParameterž falsepositivesoccurwhenthe error value
is assigned to an out parameter and the caller function contains
the error check. Finally, the ł nofailž false positives are peculiar
to Linux, where memory allocations can be requested that will not
fail (the memory allocator willloopindefinitely).
ECCdetected246 error-handling bugs across9programs,
of which 110 have been confirmed. ECCdetected 220 pre-
viously unknown bugs , of which 99 are confirmed, and
weareinthe processofconfirming107potentialbugs. Two
patcheshavealreadybeenmergedintoOpenSSL.Finally, ECC
identified29 benign bugs.This answers RQ3.
5.5 Threatsto Validity
The function error-specifications inferred by EESIare, of course,
dependentuponthedomainknowledgeprovided.AsseeninTable 2,
474ESEC/FSE ’19, August 26ś30, 2019,Tallinn,Estonia DeFreez,MartinsonBaldwin, Rubio-González, andThakur
thetotalnumberofinputsissmall,anditwouldbeeasyforproject
developers to providemore domainknowledge withlittleeffort.
EESIwas evaluated on the programs in Table 2. Our results may
notgeneralizetosoftwarethatexhibitssignificantlydifferenterror-
handlingbehavior.However,theseprogramswerechosentobea
representative crosssection ofimportantsoftware written inC.
6 RELATED WORK
Error-handling specifications. Acharya and Xie [2]use data
miningtechniquesonstatictracestomineerror-handlingspecifi-
cations for relevant APIs used in software packages. The approach
follows a restricted classification of error-handling code and limits
toidentifyingerrorchecksandcleanupcodeinclientcode.Kang
et al.[13]introduce APEx, a tool for finding error specifications
for API C functions. Section 5.3presents a detailed qualitative and
quantitative comparison between EESIandAPEx.
Fault-injection techniques have also been used toextract error-
handling specifications [ 8,19,20,25]. Fetzer et al. [8]introduce
the notion of failure atomicity in the context of exceptions and
proposetechniquestoautomaticallydetectandmasknon-atomic
exception handling in C++ and Java applications. Süßkraut and
Fetzer[25]detect and patch incorrect C error-handling client code.
Incorrecterror-handlingcodeisidentifiedwhenthesystemcrashes.
Patchingtransformsunhandlederrorsintoerrorstheapplication
can handle. Prabhakaran et al. [19,20]build models of how jour-
nalingfilesystemsmustbehave under differentjournalingmodes,
andusethesetofinderror-handlingspecificationsrelatedtodisk
write failures. Marinescu and Candea [16]describe a framework
for testingrecovery code througherror-code injection.
EESIis a static analysis tool and, therefore, better suited to han-
dling systems software such as the Linux kernel. The Linux kernel
comes equipped with a fault injection framework, but injecting
errors into software that interacts with devices is difficult as it
requiresthehardwaretobepresent.Foruser-spacecode, EESIis
complementary to dynamicfaultinjection.
Functionerror-specificationstofinderror-handlingbugs. A
numberoftoolsrequirefunctionerror-specificationstodetectbugs
orinferhowerrorsshouldbehandled.EPex[ 11]takesasinputthe
errorvaluesthatafunctioncanreturnandreportsaspotentialbugs
error paths that do not handle the error, where error handling is
definedasreturninganerrorvalue,logging,orexiting.ErrDoc[ 27]
isanimprovementoverEPex,whichtakesasinputspecifications
inferred using APEx. Because APEx cannot be used to infer specifi-
cations for functionsin the Linux kernel,ErrDoc cannotbe usedto
findorfixerror-handlingbugsintheLinuxkernel.DeFreezetal. [7]
createdFunc2vectoembedfunctionsinavectorspacesuchthat
functionsthatfulfillthesameroleorpurposeareincloseproximity,
and used this embedding to improve the quality of error-handling
specifications. Their specification miner takes as input function
error-specifications. EESIis scalable and capable of inferring more
functionspecificationsthanthestateoftheart.Therefore,allthese
toolscould benefitfrom EESI.
Otherapproachestofindingerror-handlingbugs. Staticanal-
ysis techniques [ 9,21,23,31] have been proposed to track the
propagationoferrorcodesinsystemssoftwaretofindawiderange
oferror-handlingbugssuchasdroppederrorcodes.Sahaetal. [24]present a static analysis to find resource-release omission faults
inCcode.JUXTA[ 17]isasymbolic-executionbasedapproachto
find semantic bugs (including error-handling bugs) across Linux
file systems. Henkel et al. [10]use code embeddings to detect in-
correctreturnederrorcodesinLinuxcode.Byusingtheexpressive
error-specifications inferred by EESI,ECCis able to find subtle
error-handling bugs that do not necessarily involve error codes
(see Section 2and Section 4), which is beyond the capability of the
above techniques. Finally, a large body of work (e.g., [ 4,26,29,30])
has proposed static analysis to find error-handling bugs in Java
programs, whichare outsidethe scope of this paper.
7 CONCLUSION
This paper presented EESI, a static analysis to infer function error-
specificationsforprogramswritteninCthatusethereturn-code
idiom.EESIbootstraps the analysis by using three types of do-
main knowledge: error codes, error-only functions, and initial
error-specifications.Theinferencerulesusedby EESIexpandon
this initial domain knowledge to infer additional function error-
specifications.Ourevaluationof EESIonreal-worldprograms,such
asOpenSSLandtheLinuxkernel,showthat EESIcanaccurately
infer function error-specifications while scaling to large programs.
We demonstrated how the function error-specifications inferred
byEESIcan be used to automatically find bugs related to incorrect
error handling by building a tool named ECCto find three types
of error-handling bugs: insufficient error checks, inverted error
checks,andincompleteerrorspecifications. ECCdetected246bugs
across 9 programs, of which 110 have been confirmed as actual
bugs.ECCdetected 220 previously unknown bugs, of which 99 are
confirmed,andweareintheprocessofconfirming107potential
bugs.Twopatcheshave already been mergedintoOpenSSL.
The careful orchestration of intraprocedural flow-sensitive anal-
ysesandinterproceduralcontext-insensitiveanalysisallows EESI
to be scalable and precise. As shown in our evaluation, EESItakes
onlyminutestorunonevenverylargeprogramssuchastheLinux
kernel.EESIoutperformsthestateoftheart[ 13]inprecision,recall,
and performance. Furthermore, by not relying on heuristics based
onusageoffunctionsorempiricalpropertiesoferrorpaths, EESI
ismore generallyapplicable.
Thescalabilityof EESImakesitagoodfitforcontinuousinte-
grationanddeliverypipelinesthatruntoolsoneverycommit. EESI
could be used tonotifydeveloperswhen the errorspecificationof
afunctionhaschanged.Giventhelongerror-propagationchains
that occur in large programs, this can be particularly useful, as
changing the error specification of a function can have unintended
consequencesthat result indefective error-handling code.
ACKNOWLEDGMENTS
The authors would like to thank Sung Kook Kim, Eric Li, Matthew
Sotoudeh,andJamesSunfortheirvaluablecomments.Thismaterial
is based upon work supported by the National Science Foundation
under Grant No. 1464439 and Grant No. 1750983, a Facebook Prob-
abilityandProgrammingresearchaward,andAWSCloudCredits
for Research.
475Effective Error-Specification Inference ESEC/FSE ’19, August 26ś30, 2019,Tallinn,Estonia
REFERENCES
[1]The ostif and quarkslab audit of openssl is complete (2019), https://ostif.org/the-
ostif-and-quarkslab-audit-of-openssl-is-complete/ , accessed:2019-01-30
[2]Acharya, M., Xie, T.: Mining API error-handling specifications from source code.
In:Chechik,M.,Wirsing,M.(eds.)FundamentalApproachestoSoftwareEngi-
neering,12thInternationalConference,FASE2009.LectureNotesinComputer
Science, vol. 5503, pp. 370ś384. Springer (2009), http://dx.doi.org/10.1007/978-3-
642-00593-0_25
[3]Borisov,N.,Goldberg,I.,Brewer,E.A.:Off-the-recordcommunication,or,whynot
to use PGP. In:Atluri, V., Syverson, P.F., diVimercati,S.D.C.(eds.) Proceedings
of the 2004 ACM Workshop on Privacy in the Electronic Society, WPES 2004,
Washington, DC, USA, October 28, 2004. pp. 77ś84. ACM (2004), https://doi.org/
10.1145/1029179.1029200
[4]Buse, R.P.L., Weimer, W.: Automatic documentation inference for exceptions. In:
Ryder, B.G., Zeller, A. (eds.)ISSTA. pp. 273ś282. ACM (2008)
[5]DeFreez, D.: Fix null pointer dereference in cms_recipientinfo_
kari_init (2019), https://github.com/openssl/openssl/commit/
b754a8a1590b8c5c9662c8a0ba49573991488b20 , accessed:2019-06-30
[6]DeFreez,D.:Fixnullpointerdereferenceinssl_module_init(2019), https://github.
com/openssl/openssl/commit/b754a8a1590b8c5c9662c8a0ba49573991488b20 , ac-
cessed:2019-06-30
[7]DeFreez,D.,Thakur,A.V.,Rubio-González,C.:Path-basedfunctionembedding
andits application toerror-handlingspecificationmining. In: [ 15], pp. 423ś433,
https://doi.org/10.1145/3236024.3236059
[8]Fetzer, C., Högstedt, K., Felber, P.: Automatic detection and masking of non-
atomic exception handling. In: 2003 International Conference on Dependable
Systems and Networks (DSN 2003), 22-25 June 2003, San Francisco, CA, USA,
Proceedings.pp.445ś454.IEEEComputerSociety(2003), https://doi.org/10.1109/
DSN.2003.1209955
[9]Gunawi, H.S.,Rubio-González,C.,Arpaci-Dusseau, A.C.,Arpaci-Dusseau,R.H.,
Liblit, B.: EIO: error handling is occasionally correct. In: Baker, M., Riedel, E.
(eds.) 6th USENIX Conference on File and Storage Technologies, FAST 2008,
February 26-29, 2008, San Jose, CA, USA. pp. 207ś222. USENIX (2008), http:
//www.usenix.org/events/fast08/tech/gunawi.html
[10]Henkel, J., Lahiri, S.K., Liblit, B., Reps, T.W.: Code vectors: understanding pro-
grams through embedded abstracted symbolic traces. In: [ 15], pp. 163ś174,
https://doi.org/10.1145/3236024.3236085
[11]Jana, S., Kang, Y.J., Roth, S., Ray, B.: Automatically detecting error handling
bugs using error specifications. In: Holz, T., Savage, S. (eds.) 25th USENIX
Security Symposium, USENIX Security 16, Austin, TX, USA, August 10-12, 2016.
pp. 345ś362. USENIX Association (2016), https://www.usenix.org/conference/
usenixsecurity16/technical-sessions/presentation/jana
[12]Jeong, D.: ext4: correct error value of function verifying dx checksum
(2016),https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/
?id=fa96454069b85a7e5d10f38b7d95edcd5dc64b9a , accessed:2019-07-04
[13]Kang, Y.J., Ray, B., Jana, S.: Apex: automated inference of error specifications for
C apis. In: Lo, D., Apel, S., Khurshid, S. (eds.) Proceedings of the 31st IEEE/ACM
International Conference on Automated Software Engineering, ASE 2016, Singa-
pore, September 3-7, 2016. pp. 472ś482. ACM (2016), http://doi.acm.org/10.1145/
2970276.2970354
[14]Lattner, C., Adve, V.S.: LLVM: A compilation framework for lifelong program
analysis & transformation. In: 2nd IEEE / ACM International Symposium on
Code Generation and Optimization (CGO 2004), 20-24 March 2004, San Jose, CA,
USA.pp. 75ś88(2004), https://doi.org/10.1109/CGO.2004.1281665
[15]Leavens, G.T., Garcia, A., Pasareanu, C.S. (eds.): Proceedings of the 2018 ACM
JointMeetingonEuropeanSoftwareEngineeringConferenceandSymposiumon
the Foundations of Software Engineering, ESEC/SIGSOFT FSE 2018, Lake Buena
Vista, FL, USA, November 04-09, 2018. ACM (2018), http://dl.acm.org/citation.
cfm?id=3236024
[16]Marinescu,P.D.,Candea,G.:Efficienttestingofrecoverycodeusingfaultinjec-
tion. ACM Trans. Comput. Syst. 29(4), 11:1ś11:38 (2011), https://doi.org/10.1145/
2063509.2063511
[17]Min, C., Kashyap, S., Lee, B., Song, C., Kim, T.: Cross-checking semantic cor-
rectness: the case of finding file system bugs. In: Miller, E.L., Hand, S. (eds.)
Proceedings of the 25th Symposium on Operating Systems Principles, SOSP
2015, Monterey, CA, USA, October 4-7, 2015. pp. 361ś377. ACM (2015), https://doi.org/10.1145/2815400.2815422
[18]Nemec, M., Klinec, D., Svenda, P., Sekan, P., Matyas, V.: Measuring popularity of
cryptographiclibrariesininternet-widescans. In:Proceedingsofthe33rdAnnual
ComputerSecurityApplicationsConference,Orlando,FL,USA,December4-8,
2017.pp. 162ś175(2017), https://doi.org/10.1145/3134600.3134612
[19]Prabhakaran, V., Arpaci-Dusseau, A.C., Arpaci-Dusseau, R.H.: Model-based fail-
ure analysis of journaling file systems. In: 2005 International Conference
on Dependable Systems and Networks (DSN 2005), 28 June - 1 July 2005,
Yokohama, Japan, Proceedings. pp. 802ś811. IEEE Computer Society (2005),
https://doi.org/10.1109/DSN.2005.65
[20]Prabhakaran, V., Bairavasundaram, L.N., Agrawal, N., Gunawi, H.S., Arpaci-
Dusseau, A.C., Arpaci-Dusseau, R.H.: IRON file systems. In: Herbert, A., Birman,
K.P. (eds.) Proceedings of the 20th ACM Symposium on Operating Systems
Principles2005,SOSP2005,Brighton,UK,October23-26,2005.pp.206ś220.ACM
(2005),https://doi.org/10.1145/1095810.1095830
[21]Rubio-González, C., Gunawi, H.S., Liblit, B., Arpaci-Dusseau, R.H., Arpaci-
Dusseau,A.C.: Errorpropagationanalysisfor filesystems. In:Hind, M.,Diwan,
A.(eds.)Proceedingsofthe2009ACMSIGPLANConferenceonProgramming
LanguageDesignandImplementation,PLDI2009,Dublin,Ireland,June15-21,
2009.pp. 270ś280. ACM (2009), https://doi.org/10.1145/1542476.1542506
[22]Rubio-González, C., Liblit, B.: Expect the unexpected: error code mismatches
between documentation and the real world. In: Lerner, S., Rountev, A. (eds.)
Proceedingsofthe9thACMSIGPLAN-SIGSOFTWorkshoponProgramAnalysis
forSoftware ToolsandEngineering, PASTE’10,Toronto,Ontario,Canada,June
5-6,2010.pp. 73ś80. ACM (2010), https://doi.org/10.1145/1806672.1806687
[23]Rubio-González,C.,Liblit,B.:Defectiveerror/pointerinteractionsinthelinux
kernel. In: Dwyer, M.B., Tip, F. (eds.) Proceedings of the 20th International Sym-
posiumonSoftwareTestingandAnalysis,ISSTA2011,Toronto,ON,Canada,July
17-21, 2011.pp. 111ś121. ACM (2011), https://doi.org/10.1145/2001420.2001434
[24]Saha, S.,Lawall,J.,Muller, G.:Finding resource-release omissionfaults in linux.
In: Proceedings of the 6th Workshop on Programming Languages and Operating
Systems, PLOS@SOSP 2011, Cascais, Portugal, October 23, 2011. pp. 1:1ś1:5.
ACM (2011), https://doi.org/10.1145/2039239.2039241
[25]Süßkraut, M., Fetzer, C.: Automatically finding and patching bad error handling.
In:SixthEuropeanDependableComputingConference,EDCC2006,Coimbra,
Portugal, 18-20 October 2006. pp. 13ś22. IEEE Computer Society (2006), https:
//doi.org/10.1109/EDCC.2006.3
[26]Thummalapenta,S.,Xie,T.:Miningexception-handlingrulesassequenceasso-
ciationrules. In:31stInternationalConferenceonSoftwareEngineering,ICSE
2009,May16-24,2009,Vancouver,Canada,Proceedings.pp.496ś506.IEEE(2009),
https://doi.org/10.1109/ICSE.2009.5070548
[27]Tian, Y., Ray, B.: Automatically diagnosing and repairing error handling bugs in
C. In: Bodden, E., Schäfer, W., van Deursen, A., Zisman, A. (eds.) Proceedings of
the 2017 11th Joint Meeting on Foundations of Software Engineering, ESEC/FSE
2017, Paderborn, Germany, September 4-8, 2017. pp. 752ś762. ACM (2017), https:
//doi.org/10.1145/3106237.3106300
[28]Ts’o, T.: ext4: refactor code to read directory blocks into ext4_read_dirblock()
(2013),https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/
?id=dc6982ff4db1f47da73b1967ef5302d6721e5b95 , accessed:2019-07-04
[29]Weimer, W.,Necula, G.C.:Findingand preventing run-time error handlingmis-
takes. In:Vlissides,J.M.,Schmidt,D.C.(eds.)Proceedingsofthe19thAnnualACM
SIGPLANConferenceonObject-OrientedProgramming,Systems,Languages,
andApplications,OOPSLA2004,October24-28,2004,Vancouver,BC,Canada.
pp. 419ś431. ACM (2004), https://doi.org/10.1145/1028976.1029011
[30]Weimer, W., Necula, G.C.: Mining temporal specifications for error detection. In:
Halbwachs,N., Zuck, L.D. (eds.) ToolsandAlgorithmsfor theConstruction and
AnalysisofSystems,11thInternationalConference,TACAS2005,HeldasPart
oftheJointEuropeanConferencesonTheoryandPracticeofSoftware,ETAPS
2005,Edinburgh,UK,April4-8,2005,Proceedings.LectureNotesinComputer
Science, vol. 3440, pp. 461ś476. Springer (2005), https://doi.org/10.1007/978-3-
540-31980-1_30
[31]Weiss,C.,Rubio-González,C.,Liblit,B.:Database-backedprogramanalysisfor
scalable error propagation. In: Bertolino, A., Canfora, G., Elbaum, S.G. (eds.)
37thIEEE/ACM International Conference onSoftware Engineering, ICSE 2015,
Florence, Italy, May 16-24, 2015, Volume 1. pp. 586ś597. IEEE Computer Society
(2015),https://doi.org/10.1109/ICSE.2015.75
476