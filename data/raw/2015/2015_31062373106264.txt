Understanding Misunderstandings in Source Code
DanGopstein?:JakeIannacone?:Yu Yan^=LoisDeLong?:
YanyanZhuang++MartinK.-C. Yeh^=JustinCappos?:
?:NewYork University,USA++UniversityofColorado,Colorado Springs, USA^=Pennsylvania StateUniversity,USA
ABSTRACT
Humans often mistake the meaning of source code, and so mis-
judge a program’s true behavior. These mistakes can be caused
by extremely small, isolated patterns in code, which can lead to
signiicant runtime errors. These patterns are used in large, pop-
ularsoftwareprojectsandevenrecommendedinstyleguides.To
identifycodepatternsthatmayconfuseprogrammersweextracted
a preliminary set of ‘atoms of confusion’ from known confusing
code.Weshowempiricallyinanexperimentwith73participants
thatthesecodepatternscanleadtoasigniicantlyincreasedrateof
misunderstanding versus equivalentcode without the patterns. We
thengoontotakelargerconfusingprogramsandmeasure(inan
experiment with43 participants)theimpact,interms ofprogram-
mer confusion, of removing these confusing patterns. All of our
instruments,analysiscode,anddataarepubliclyavailableonline
for replication,experimentation, andfeedback.
CCS CONCEPTS
·General and reference →Empirical studies ;·Software and
its engineering →Softwareusability ;
KEYWORDS
ProgrammingLanguages;Program Understanding;
ACMReference Format:
D.Gopstein,J.Iannacone,Y.Yan,L.Delong,Y.Zhuang,M.K.-C.Yeh,J.Cap-
pos.2017.UnderstandingMisunderstandingsinSourceCode.In Proceedings
of 2017 11th Joint Meeting of the European Software Engineering Conference
andtheACMSIGSOFTSymposiumontheFoundationsofSoftwareEngineering,
Paderborn, Germany,September 4ś8, 2017(ESEC/FSE’17), 11pages.
https://doi.org/10.1145/3106237.3106264
1 INTRODUCTION
Source code serves a dual purpose. It communicates program in-
structions to machines, and programmer intent to people. Unfortu-
nately,peopleandmachinesoftendrawdiferentconclusionsabout
thebehaviorofapieceofcode.Whileadiferenceofinterpretation
Permissionto make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forproitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
ontheirstpage.Copyrights forcomponentsofthisworkownedbyothersthanthe
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspeciicpermission
and/or a fee. Request permissions from permissions@acm.org.
ESEC/FSE’17, September 4ś8, 2017, Paderborn, Germany
©2017 Copyright held by the owner/author(s). Publication rights licensed to Associa-
tionfor Computing Machinery.
ACM ISBN 978-1-4503-5105-8/17/09...$15.00
https://doi.org/10.1145/3106237.3106264canhappennaturallyinsomesituations(suchasthoseinvolving
randomness, poorly understood APIs, or undeined behavior), it
canalsooccurasaresponsetosmall,self-containedlinesofcode.
These code patterns, which are easy to misinterpret, can naturally
leadtobugsincode.Inturn,theconsequencesofthesebugscan
includediminished productivity,faultyproducts, and higher costs.
Inthepast50yearssincesoftwarehasbecomeubiquitous,we
have seen a proliferation of software bugs. Notable examples, such
asApple’s‘gotofail’SSLbug[ 4],Ariane5’sloatingpointoverlow
bug[23,28],andAT&T’scascadingnetworkfailure[ 6],haveshown
us that it is extremely diicult to deliver bug-free software despite
large incentives to do so. The consequences of the aforementioned
bugs were, respectively, an SSL man-in-the-middle vulnerability to
allOSXandiOSusers,thedestructionofa$500mspacecraft,and
thelossoftransnationalcommunicationfor50millionlongdistance
calls. Each of these failures was caused by a single, well-contained,
programmingerroratthesyntacticorsemanticlevel,ratherthan
the algorithmic or system-levels of the project. Issues like this
are quite common. While editing this document for submission,
Cloudlare published an analysis of ‘Cloudbleed’ [ 21] Ð a bug that
leakedsensitivecustomerdatapubliclyontheweb.Thetwo-line
snippetofcoderesponsibleforthebugcontainstwoofthesmall,
self-containedpatternswediscusshere( Pre-Increment andOmitted
CurlyBraces ,see Table1).
The ability to identify and remove these confusing program ele-
mentsisimportantformorethanjusttheavoidanceofaccidents.
The ability to understand pre-existing source code is one of the
most important elements of a continuously successful software
project.Confusingcodeafectscomprehension,aconceptcentralto
allstagesofsoftwaredevelopment,particularlymaintenanceand
code review. Code review is a valuable tool for validating design
decisions,anditsefectivenessrestsheavilyonthereadabilityof
thesourcecode[ 3].Variousestimatesplacecodemaintenance,or
themodiicationofcodeaftertheproducthasalreadybeendeliv-
ered, as the most expensive phase of development in terms of both
timeandmoney[ 12,27].Thus,beingabletoreliablyidentifyand
removecodethatcancausemisunderstandingswillalsoenhance
productivityandreduce maintenancecosts.
In this work, we seek out and experimentally validate the small-
est pieces of code that can routinely cause programmers to misun-
derstand code. We call these indivisible, misunderstanding-causing
patterns‘atomsofconfusion’or‘atoms’forshort.Theseatomscan
serveasanempiricalandquantitativefoundation forunderstand-
ingwhat makescodeconfusing.Todothis,we selectedprograms
thatarealreadyacknowledgedasconfusingtohumans(winners
of the IOCCC ś the International Obfuscated C Code Contest). We
129
ESEC/FSE’17,September4–8, 2017, Paderborn,Germany Gopstein, Iannacone,Yan,Delong,Zhuang, Yeh,andCappos
isolated small patterns of code, often contained within a single
line, from theIOCCCprograms that were the underlying causeof
programmer confusion. We then performed an empirical human
subjects experiment with 73 participants to ind which of these
codepatternscausedastatisticallysigniicantamountofconfusion
(i.e., lead programmersto believe theprogram containing this pat-
tern behaves diferently than the Clanguage speciication dictates).
Next, we measured the impact of removing these atoms of con-
fusionfromlargerobfuscatedprograms,alsodrawnfromIOCCC
winners. We simpliied the IOCCC programs by applying behavior-
preservingtransformationstoremoveidentiiedatoms,andused
these programs as the basis for a second experiment. We recruited
43participantswhohadnottakenpartinourpriorexperiment.We
were able to determine, quantitatively, how much we could reduce
programmer errorsimply byclarifying theseatoms.
Throughthiswork we have madeseveralunique contributions:
•Methodology for empirically deriving confusing code patterns.
Wedescribeascientiicallysoundmethodforinding,validat-
ing, and measuring the potency of small confusing patterns
in code. Our methods are empirical, quantitative, and ob-
jective, which results in high quality, easily analyzable data.
Given the value of replicable work in empirical software
engineering [ 37], we have made replication packets pub-
licly available at https://atomsofconfusion.com so anyone
can reproduce orextend our work at any time.
•Alarge,publiclyavailabledataset. Wetested122questionson
116subjectsovertwoIRB-approved1experiments.Allofour
anonymized data has already been published to our website
aswell,sootherresearcherscantest theirownhypotheses
onan existing dataset.
•15 statistically signiicant atoms of confusion. We uncovered,
assessed, and analyzed 15 very small, potent sources of con-
fusion.Wedescribetheseobfuscatingatomsandthetrans-
formationsthat clarifythem.
•Survey of these patterns in well-known style guidelines. Some
ofourindingscontradictexpertopinionsfoundinpopular C
style guidelines. We survey several well-known documents,
and point out the recommendations that conlict with our
empirical evidence.
•In-depth analysis of experiment subject responses. Beyond
supporting our primary hypothesis, our data ofers many
interestingviewsintoprogrammercomprehensionandbe-
havior. We explore the potential signiicance of the distri-
butionofwronganswers tothesamequestion,the timeit
takes programmers to answer correctly, and the accuracy of
our subjects’ estimates oftheirownability.
The rest of this paper is laid out as follows. We begin in Section
2, by discussing the many sub-ields of computer science from
which we drew inspiration or direction for our work. Next, we
lay out the major concepts that underlie our research questions in
Section3.InSection4,wedescribetheatomsdiscoveredinIOCCC
winners.Buildingontheidentiiedatoms,weexperimentallytested
whichweremoreconfusingthantransformedcode,asisdetailed
inSection5.Wetooktheconirmedatomsandmeasuredthesize
1All experiments described in this paper were approved by the Institutional Review Boards (IRBs)
at both NYU andPSU.oftheirimpactonsmallprogramsasdescribedinSection6.Finally,
inSections 7and9we discuss our results inalarger context.
2 RELATED WORK
Code confusion is a recognized problem that has had many pro-
posed solutions. Speciiccode constructshave beendeemed taboo
by the programming community [ 29], most notably gotostate-
ment [13], global mutable state [ 42], and magic numbers [ 26]. Less
aggressively,programmers have learnedto avoidcertain patterns
that have been dubbed ‘code smells’, or, as Fowler deined them,
łstructures in the code that suggest... the possibility of refactor-
ingž[19].Inthiswork,weaimtomovetheseideasfromhunches
and ‘gut feelings’ to empirically-veriied examples of diicult code.
Below we summarize the work of others who have attempted to
explainorremedy the challenges of understanding code.
Style guides. Manyofthepatternsweidentiiedoverlapwith
recommendationsgiveninpopularstyleguides.Forexample, The
GNUCodingStandards [39]recommendsavoidingvariablereuse,
andusingassignmentsasconditionalpredicates.NASA’s CStyle
Guide[15] also warns about several of the patterns we investigate,
including recommending the use of explicit comparisonsin predi-
cates,avoidingtheconditionaloperator,andnotusingside-efect
operatorsinrelational expressions.However,wefound situations
where style guidelines do not match our indings, such as avoid-
ingcurlybracesforsingle-statementblocks[ 41].Wedetailthese
indingsinthe Discussionsection.
Obfuscation. Obfuscationtakeslegiblecodeandtransformsit
intoaformthatmasksitsfunction.Theobfuscationtechniquesmost
closelyrelatedtoourworkarethosethatevaluatethełpotencyž[ 11]
(i.e.,humanreadability)ofobfuscation.Ourworkreversesthegoals
ofsuchatechniquebytakingcodethatisdiiculttounderstand
and transforming it into a more readable form. Recently, Avidan
and Feitelson [ 2] reported using a variety of indirect metrics, such
as transparency and low complexity, to evaluate the confusion
ofobfuscation techniques. Ourworkmore directly evaluatescode
confusionbytestingsubjectcomprehension.
Metrics. There have been many eforts to quantify the clarity
of software [ 43]. Multiple studies have shown that the number
of lines of code does correlate with the incidence of bugs [ 35],
implying that more code leads to more bugs. On the other hand,
cyclomaticcomplexity[ 30]looksatalllinearly-independentcircuits
through a program graph. Such a technique is useful for analyzing
codeatthefunction,module,orprogramlevel.Theconfusionwe
study,however,tendstomanifestontheexpressionorstatement
level,whichisiner-grainedandoftenhasaverylowcyclomatic
complexity. Halstead [ 22] proposed measures of software based on
thecounts,proportions,anddiversityofoperatorsandoperandsin
programs,withoutregardtothespeciicoperatorsandoperandsin
use.Yet,wehavefoundthatconfusingelementscanberemovedby
simply moving or replacing operators, while keeping the Halstead
metrics constant. More recently, Shao and Wang [ 36] measured
complexity by the combined cognitive weight of individual control
structures (branch, iteration, concurrency, etc.). However, their
work treats all interactions between control structures as uniform.
Ourresultsindicatethatsomeoperationscanbedisproportionately
more confusing thanothersthat compute the same result.
130UnderstandingMisunderstandingsin Source Code ESEC/FSE’17,September4–8, 2017, Paderborn,Germany
Staticanalysis andtooling. Heuristicscanbeusefulforlag-
gingpotentially detrimental staticproperties ofaprogram. These
actions can be performed by compilers and static analysis tools,
suchasLint[ 24].Insteadofsimplyrejectinginvalidcode,compilers
almostalwaysincludevalidationcodetoalertprogrammerstotheir
mistakes.Atthetimeofthiswriting,GCChas185warninglags,
manyof whichpresenthelpfulcomments aboutcommonunclear
ordangerous sourcecode patterns discoveredduringcompilation.
In general, these tools target issues that overlap with our experi-
ments,basedonthecollectiveanecdotalevidenceofthesoftware
engineering community. The theory put forth in this paper can
bolsterwork onengineering tools byvalidating theirimplicitas-
sumptions andoferingadditionalpatterns to investigate.
Program comprehension. Of the literature in program com-
prehension, the work most related to our investigation is Buse and
Weimer’s[ 7],whichstudiedlocalcodefeaturesofsmallprogram
snippets.However,theirmethodofdeterminingcodecomplexity
isbasedontheopinionofprogrammers,whoratedsnippetsona
1-5 scale of readability. Tashtoush et al. [ 40] also designed a model
of software readability by asking questions about what features
programmersfoundconfusing.Wecomplementthispreviouswork
bytestingan objective measure ofmisunderstanding.
A few of the speciic code patterns we investigate have been
examined in earlier studies. Dolado et al. [ 14] tested whether code
that contained side-efects was more likely to cause subjects to
misinterpretitsfunction.Theirmethodofevaluationisverysimilar
to ours, and their results are generally conirmed by ours, but their
experimentfocusedonlyononecodepattern.Jones[ 25]testeda
hypothesisthatłtherewillbeasigniicantcorrelationbetweena
developer’s knowledge of relative binary operator precedence and
the amount of experience they have had handling the respective
binary operator pairž. His experiment involved subjects placing
redundantparenthesesaroundexpressionswithtwobinaryoper-
atorsandmeasuringthecorrectnessoftheplacement.Confusion
surrounding binary operators is very related to our atom Operator
Precedence .TheprimarydiferencebetweenJones’methodandours
isthathehassubjectsmodifythecodesnippets,whileoursareonly
asked to hand evaluatethe code. While testing the presence of con-
fusion against a clarifying transformation is not the primary focus
ofhiswork,theresultshesharesareconirmedbyourexperiments.
Elshof and Marcotty’s [ 17] work introduced the idea of clarify-
ingtransformationstoimprove thereadability ofsource code.We
leveragetheseideasinourexperimenttomeasurethemagnitude
ofconfusioncausedbyspeciic code elements.
3 DEFINITIONS
Inthissection,weexplainthetermsandconceptsusedinourwork.
Wedeinethesmallestpatternsincodethatcancausemisunder-
standinginprogrammers,theprocessusedtopresentthesepatterns
to test subjects, and the transformations that can remove them. We
alsoreine the scope ofour investigation.
Confusion .Forthepurposeofthiswork,‘confusion’isdeined
aswhathappenswhenapersonandamachinereadthesamepiece
ofcode,yetcome to diferentconclusions aboutits output.Ourgoalwastotargetspeciicsituationswhereaprogrammer
might tend to misunderstand the behavior of a piece of code. Then,
welookedwithinthoseinstancestoidentifycommonpatternsof
codethatcouldbethesourceofthisconfusion.Welabeledthese
patterns ‘atoms of confusion’. We restricted our deinition of an
atom toonly minimalportions ofcode so that our indings would
begeneralizableandoccurfrequentlyinrealprojects.Thischoice
also ensures that we can design experiments that are very accurate
inmeasuringtheextentoftheconfusioncausedbytheatom.For
example,ifasubjectweretomisinterpret a = b++; itisimportant
totestwhethertheywouldmisinterpret a = b; b++; aswell.If
bothassignmentorpost-incrementareconfusingwhentheyappear
alone, then the confusion is not due to the combination of the two.
Exclusions. We acknowledge a number of factors can lead to
programmercomprehensionerrors.Totargetprogrammermistakes
causedbymisunderstanding,asopposedtocognitiveinabilityor
lackofinformationweexcludethefollowingfromourexperiments.
•Non-deterministic : Non-deterministic programs are im-
possible to reliably predict, and are therefore outside the
scopeofourinvestigation.Forexample,weavoidthe rand()
function inour code snippets.
•Undeined / Non-portable : Code which is not executed
uniformly across various computer environments was ex-
cluded.For example a = a++ has nouniversal meaning.
•Computational :Programmerssuferfromworkingmem-
oryandattentionconstraints[ 38],butthisistangentialto
ourinvestigation.Anyconfusionthatcouldberemovedby
using acalculatorisoutsidethe scope of this work.
•APIrelated : In our experiments, we only focus on code for
whichthe entire implementationisavailable.
3.1 Normalization
Before human subjects read source code in either of our experi-
ments, we irst performed a normalization step on the programs.
Anyinstancesoftheaboveexclusionsfoundintheexperiment’s
source code was replaced by conceptually equivalent code that
contained noknown sources of confusion.Wealso made sure not
to encode any ‘meta’ information in our code. The speciic precau-
tions we took were similar to those used by Siegmund et al. [ 38]
whoalsoenforcedabottom-up/syntax-to-semanticsstyleofcom-
prehensionbyremoving beaconsthatmighttriggeraconnection
to pre-existing semantic knowledge. In our case, we removed all
comments, sanitized all string literals, renamed all variables to V1,
V2, etc., and every macro to M1,M2, etc., and we kept all math as
simpleas possible,whilestillpreservingthe atomof confusion.
3.2 Transformation
Atoms of confusion are abnormally confusing patterns in code. We
deine atoms relative to functionally equivalent code that does not
confuse programmers.We call theremoval ofan indivisibly small
sourceofconfusion an atomremoval transformation .Thesetrans-
formations substitute confusing code with similar, but relatively
lessconfusingcode.Forexample,takethecode V1 && F2() .To
remove this atom (which we call Logic as Control Flow ) we add
an explicit if condition around V1to readif (V1) { F2(); } .
Thesetransformationsarenotunique,asthereisnotnecessarily
131ESEC/FSE’17,September4–8, 2017, Paderborn,Germany Gopstein, Iannacone,Yan,Delong,Zhuang, Yeh,andCappos
any one right way to write code. Several types of atoms can be
obviated in multiple ways, and in these cases we used our best
judgmenttochoosethemostunderstandablecodetoreplacethe
atom. This can lead to a pitfall where a transformation either fails
toremovetheoriginalsourceofconfusion,oraddsitsown.This
type oferrorreduces the observedpotency ofthe originalatom.
4 IDENTIFIED ATOMS
Tobuildaninitialsetofpotentialatomsofconfusion,westudied
thecodeofknownconfusingprograms.Wetriedtominimizethe
amount of confusion from exclusions (Section 3) and maximize the
likelihoodofconfusionfrompotentialatomsinourtestset.With
this criteria in mind, we chose to explore the winning entries of
the International Obfuscated C Code Contest (IOCCC). The goal of
thiscompetitionistosolicitprogramsthatdemonstratełviolations
of structured programming, non-clarity, and use of ‘by the K&R
book’Cž[ 33]. IOCCCwinnersaredesignedtocauseconfusion in
programmersand,assuch,theseprogramsofersuicientexamples
of atoms of confusion. WhileIOCCC entriesmay not be generally
representative of real-life programs, they reveal the same patterns
that often docreate confusioninlarge andpopular projects.
Theprocessofidentifyingnewpotentialatomsofconfusionwas
carriedoutbytwohumancoders.Programswerebrokendowninto
smallconfusingsections and compared against eachother to ind
common recurring patterns. Snippetsof code that were confusing,
contained no excluded forms of confusion, and could be simpliied
through a behavior-preserving transformation were considered
candidates to be atomsofconfusion.
5 ATOMEXISTENCE EXPERIMENT
Theirstofourtwoplannedexperiments(Figure1)wasdesignedto
validatetheinitialsetofatomsidentiiedinSection4.Programmers
wereshownaseriesofcodesnippetsandaskedtohandevaluate
each,andsubmitthestandardoutput.Questionswereformulatedin
pairs, each structurally similar, but one containing an atom of con-
fusion,andtheothertransformedtoremovetheatom.Eachsnippet
was designed to be ‘minimal’, that is, to show the smallest possible
pieceof codetoexhibit theefectof theatom. Onlyone atomwas
testedpersnippet.Duetothesmallsizeofmostatoms,theaverage
snippet contained only 8 lines of code, most of which was boiler
plate. Ignoring blank lines, declarations, and experimental printf
statements, the average length of atom-related code was ~1.9 lines
per snippet. We created three pairs of atom candidate/transformed
questionsper atom.An example snippetisshowninFigure 2.
We recruited and tested 73 subjects, predominantly students
at large North American universities. Each subject was required
to have at least 3 months experience with the CorC++program-
ming languages. The questions were presented via a web interface.
Sourcecodewasdisplayedwithnosyntaxhighlighting,sincethe
selection of any particular highlighting scheme would bias the
subjects’abilitytoparsethecode.Eightoftheparticipantsweredi-
rectlysupervisedastheytookthetest,whiletheremainingsubjects
completedthe questionsonline.Design: RandomizedPartialCounterbalanced
Sample: 73 programmers with ≥3 monthsC/C++experience.
Control: Tiny program (~8lines) containingasingleatom.
Treatment : A versionof the controlcode transformedto
remove the atomofconfusion.
NullHypothesis H0:Codefrombothcontrolandtreatment
groupscan be hand-evaluatedwithequal accuracy.
Alternative Hypothesis Ha: The existenceof an atomof
confusioncauses more errorsthanothercode in
hand-evaluatedoutputs.
Figure 1:Summary ofthe Atom ExistenceExperiment
void main() {
char V1 = 2["qwert"];
printf("%c\n", V1);
}
(a)obfuscatedvoid main() {
char V1 = "zxcvb"[4];
printf("%c\n", V1);
}
(b) clariied
Figure 2:Example Reversed Subscripts snippet pair.
5.1 ExperimentalConditions
Beforeexecutingourfull-scaleexperiment,weconductedapilot
experiment on 11 participants with 6 atoms. The pilot helped us
correct small errors in our instrument, and tune the parameters
of our full experiment. Due to the large volume of questions we
wanted to show in the full experiment, we decided not to show
everyquestiontoeverysubject.Toreducementalfatigue,weaimed
toconstrainthelengthofeachsessiontoapproximately60minutes
for the average participant [ 5]. Since each question, on average,
took just under a minute to answer in our pilot, we chose to show
each subject only 2 of each group of 3 question pairings in our
fullexperiment,assignedcyclically.Thismeansthateachsubject
received2⁄3of our 114 questions and each question was received
by2⁄3of all participants. Each subject always saw both the atom
candidate andits transformedpair.
Wecontrolledforthepossibilityofalearningefect[ 32]inthree
distinctways.Firstly,werandomizedtheorderofeveryquestion,
sothatanybiasinherentinthequestionorderingwasdistributed
evenly among all participants. Secondly, between each atom candi-
date/transformedpairofquestionsweenforcedaminimumdistance
of 11 intermediate questions. This number was chosen by extrapo-
lating from our pilot experiment results. In the pilot, we identiied
the optimum distance after which learning efects diminished, and
thenscaledthisvaluebythenumberofnewquestionsaddedfor
the main experiment. Lastly, we randomized constant values in
the code. Atoms, by deinition, cannot rely on the speciic value
of a constant. Therefore, by changing the constant values in our
questionsthevalidityoftheatomremainedintact,whiletheadded
diferences madeitharder to connectthe twoquestionsof apair.
We designed each question such that every common interpreta-
tion,correctandincorrect,wouldresultinadiferentoutput.We
did this by using combinations of constants for our variable initial-
izations, which create diferent values when combined in diferent
ways.Forexample,ifweweretestingwhethersubjectsunderstood
132UnderstandingMisunderstandingsin Source Code ESEC/FSE’17,September4–8, 2017, Paderborn,Germany
Table 1: AtomcandidatesextractedfromIOCCC winners
AtomName Description AtomExample Transformed
Change of Literal
EncodingAll numbers are stored as binary, but for convenience we represent numbers in decimal, hex, or octal.
Dependingonthe circumstance, certain representationsaremoreunderstandable.printf("%d",013) printf("%d",11)
Preprocessor in
StatementThe preprocessor replacesdirectives with whitespace. Consequently, preprocessor directives may be placed
insideastatement.Sincethepreprocessordirectiveandthesourcecodearecompiledindiferentphases,
theyareprocessed independently.int V1 = 1
#define M1 1
+ 1;#define M1 1
int V1 = 1 + 1;
MacroOperator
PrecedenceMacro references are impossible to distinguish from other identiiers and can act in ways that variables and
functionscannot, such as laxparameter binding.#define M1 64-1
2*M12*64-1
Assignmentas Value The assignment expression changes the state of the program when it executes, however it also returns a
value. When reading anassignmentexpressionpeoplemayforgetone of the twoefectsof the expression.V1 = V2 = 3; V2 = 3;
V1 = V2;
Logicas ControlFlow Traditionally, the &&and||operators are used for logical conjunction and disjunction, respectively. Due to
short-circuiting,theycanalso beused for conditional execution.V1 && F2(); if (V1) F2();
Post-Increment/
DecrementThepost-incrementanddecrementoperatorschangethevalueoftheiroperandsby1andreturntheoriginal
value. Confusion arises because the valueof the expressionisdiferentfrom the valueof the variable.V1 = V2++; V1 = V2;
V2 += 1;
TypeConversion TheCcompilerwilloftenimplicitlyconverttypeswhenthereisamismatch.Sometimesthisconversionalso
resultsin a diferentoutcome than areaderexpects.(double)(3/2) trunc(3.0/2.0)
Reversed Subscripts Arrays can be indexed using the subscript operator, but underneath łE1[E2] is identical to (*((E1)+(E2)))ž [ 1].
Since additionis commutative, so tooisthe subscript operator.1["abc"] "abc"[1]
Conditional Operator Theconditionaloperatoristheonlyternaryoperatorin C,andfunctionssimilarlytoanif/elseblock.However,
it is anexpressionfor whichthe valueisthat of the executed branch.V2 = (V1==3)?2:V2 if (V1 == 3)
V2 = 2;
OperatorPrecedence Chasnearly50operatorseachinoneof15precedenceclasseswitheitherrightorleftassociativity.Most
programmersknowonly afunctional subset of these rules.0 && 1 || 2 (0 && 1) || 2
Comma Operator The comma operator is used to sequence series of computations. Whether due to its eccentricity, or its odd
precedence, the comma operatoriscommonlymisinterpreted.V3 = (V1 += 1, V1) V1 += 1;
V3 = V1;
Pre-Increment/
DecrementSimilartopost-increment/decrement,theseoperatorschangeavariable’svaluebyone.Incontrasttothe
otheroperators, pre-increment/decrementirstupdatethe variablethenreturnthe newvalue.V1 = ++V2; V2 += 1;
V1 = V2;
ImplicitPredicate The semantics of a predicate are easily mistaken. The most common example happens when assignment is
used insidea predicate orwhen asuccessstate isrepresented as 0.if (4 % 2) if (4 % 2 != 0)
Repurposed Variables When a variableis used in diferentrolesin aprogram,its currentmeaningcanbediicult to follow. argc = 7; int V1 = 7;
Omitted Curly Braces When controlstatementsomit curly braces,the scopeof theirinluence canbediicult to discern. if(V) F(); G(); if(V){F();}G();
Candidates whicheventually failed to meetstatisticalsigniicance
Dead,Unreachable,
RepeatedRedundant code is executed to no functional efect,but its appearance may imply that meaningful changes
arebeingmade.V1 = 1;
V1 = 2;V1 = 2;
Arithmetic as Logic Arithmetic operators are capable of mimicking any predicate formulated with logical operators. Arithmetic,
however, impliesa non-boolean range, whichmaybeconfusingto areader.(V1-3)*(V2-4) V1!=3 && V2!=4
PointerArithmetic Pointers admit several operations like integer addition/subtraction, but, in many cases, these operations are
interpreted by the readerto efect the targetdata insteadof the pointer data."abcdef"+3 &"abcdef"[3]
ConstantVariables Constantvariablesarealayerofabstractionthatemphasizeaconceptratherthanaparticularvalueitself.
When trying to hand evaluate a piece of code having a layer of indirection can obscure the value of the data.int V1 = 5;
printf("%d", V1);printf("%d", 5);
howthemodulooperatorworked,wewouldavoidanexpression
like8 % 3. In this example if a subject confused %with/they
wouldstillgetthecorrectresult(2)forthewrongreason.Instead,
wewouldbebetterservedchoosingvalueslike 8 % 2thatresultin
adiferent valuewhen interpreted asdivision,asopposed tomod-
ulo.Thistypeofdesignallowsustoinferthecauseoftheconfusion
for the subjects. By analyzing the diferent submitted answers, we
areabletoreverseengineerprobablecausesandmisconceptions
that leadto the subjects’ incorrectunderstanding.
5.2 Statistical Analysis
Using the data gathered in the pilot we ran a power analysis to
determine the ideal sample size for our experiment. We set our
Beta(1-acceptablelikelihoodofatypeIIerror)at β=0.8,Alpha
(acceptable likelihood of a type I error) at α=0.05. Efect size was
calculated using the φ(phi) equation for 2x2 X2tables. Our power
analysisindicated that,for theatom inour pilotwiththesmallest
efectsize, ConstantVariable ,we wouldneed73 subjects.
Results were analyzed using McNemar’s test of marginal homo-
geneity[31]andadjustedusingtheDurkalski[ 16]correctionfor
correlateddataasprovidedbytheRpackageclust.bin.pair[ 20].Mc-
Nemar’s test is usedfor experiments where subjects are testedonpairedquestions.WeappliedtheDurkalskicorrectionforclustered
data since each subject received two pairs of questions for each
atom. Because a subject is likely to answer similarly on both of the
pairs, thesedata are correlated.
The McNemar test reports a chi-squared statistic that can be
used to derive a p-value and efect size. The p-value will tell us the
probabilitythatourresultsoccurredinacasewheretherewastruly
no underlyingefect (i.e., thep-valuetellsus how likely we are to
collect data like ours if atoms actually are not more confusing than
regular code). Efect size is a standard statistical tool to measure
how large of an impact a phenomenon has. The efect size takes
into account the magnitude and sample size of a series of events
andallowsfor comparison withresults from otherdomains.
5.3 Results
Atomsofconfusioncausedconsiderableconfusionamongoursam-
pledprogrammers.Thediferenceinsubjectperformanceinpre-
dictingoutcomeforcodewithatoms,ascomparedtocodewiththe
atomsremoved,isdisplayedinFigure3.Ournullhypothesisisthat
atomsdonotimpacthandevaluationaccuracy.Whentheresults
of all questions from all proposed atoms are collected together, the
null hypothesis can be rejected with a p-value of p=3.68e−78
133ESEC/FSE’17,September4–8, 2017, Paderborn,Germany Gopstein, Iannacone,Yan,Delong,Zhuang, Yeh,andCappos
●●●●●
●●●●
●
●●
●●
●●●●
●●●
●●
●●●
●●●
●●
●●●
●●●●
●●●●●● ●
●●
●●●●●
●●●●
0.0 0.2 0.4 0.6 0.8 1.00.0 0.2 0.4 0.6 0.8 1.0
Atom candidate correctnessTransformed correctness
Figure 3: Subject mean performance on obfuscated vs. clariied
snippets.Subjects abovethediagonal performedbetter on clariied
code,whilethose belowperformedbetter on obfuscatedcode.
and an efect size of φ=0.36. Both these values include the atoms
that individuallywe cannotacceptas confusing.
5.3.1 Whichatomcandidatescanweacceptasatoms? Asshown
in Table 2, of the 19 atom candidates we proposed, we accepted 15
as atoms, having p<0.05. For the 15 accepted atoms, we calcu-
latedtheefectsizeusing φ(thephicoeicient);Acceptedvalues
for small, medium, and large sizes are φ={0.1,0.3,0.5}respec-
tively[10]. By these guidelines, all of our accepted atoms range
from a medium to a very large efect size. This means that not
onlycanweconirmthatatomsofconfusiondoconfusesubjects,
but alsothat thisconfusion isvery noticeableintherawdata.In
addition to p-value and efect size, we also look at diferences in
raw performance percentages. The values are very correlated with
efectsize,however,themagnitudeismoretangible.Forexample,
questionsthatcontaina ChangeofLiteralEncoding atomenjoya
60%boostinaccuracyoncetheatomisremoved.Thisletsusdistin-
guish exactly how many more questions were answered correctly
incode withoutatoms.
Four of our atom candidates were not conirmed as more con-
fusing than their transformations. There are two potential reasons
whyanatomcandidatewouldfailtoreachstatisticalsigniicancein
our experiment: the candidate was not confusing, or the candidate
wasconfusingbutsowasthetransformedcode. Dead,Unreachable,
Repeated,ArithmeticasLogic ,andConstantVariables allexhibited
relatively little confusion in both versions of the questions. Pointer
Arithmetic , on the other hand, was very confusing both before and
afteratomremoval.Whilewehadtriedtofocusontestingwhether
addition and subtraction on pointers was confusing, the results
indicatethatalatentatomexistsinbothversionsofthecode.An-
alyzing the subjects’ responses indicates that many participants
struggledtoevenunderstandthatarraysandstringsareaccessed
with a pointer to their head elements. That is to say, pointer arith-
metic is confusing, but so was the code it was compared against.
We plan to go back and explore these potential atoms in future
experiments.Table 2: Statistical properties of atom candidates
Dispersion ∆ Efect
AtomName Obfs’d Clar’d Correct Size p-value
Change of Literal Encoding 1.65 0.75 0.60 0.63 2.93e-14
Preprocessor in Statement 1.01 0.46 0.47 0.54 8.53e-11
MacroOperatorPrecedence 0.50 0.32 0.36 0.53 1.77e-07
Assignmentas Value 0.99 0.45 0.42 0.52 3.78e-10
Logicas ControlFlow 1.58 0.90 0.41 0.48 5.62e-09
Post-Increment/Decrement 1.31 0.52 0.34 0.45 6.98e-08
TypeConversion 0.85 0.50 0.29 0.42 5.17e-07
Reversed Subscripts 1.71 0.93 0.23 0.40 1.52e-06
Conditional Operator 0.91 0.07 0.23 0.36 1.74e-05
OperatorPrecedence 0.59 0.30 0.14 0.33 5.90e-05
Comma Operator 2.02 0.76 0.23 0.30 2.46e-04
Pre-Increment/Decrement 0.95 0.82 0.16 0.28 6.89e-04
ImplicitPredicate 0.61 0.34 0.10 0.24 4.27e-03
Repurposed Variables 1.78 1.50 0.12 0.22 6.66e-03
Omitted Curly Braces 1.22 0.94 0.14 0.22 8.64e-03
Dead,Unreachable, Repeated 0.19 0.06 0.03 0.16 0.059
Arithmetic as Logic 0.23 0.15 0.03 0.10 0.248
PointerArithmetic 1.54 1.06 0.01 0.03 0.752
ConstantVariables 0.28 0.29 0.00 0.00 1.000
There is also evidence that some atoms actually represent multi-
ple diferent phenomena, and are thus not small, or self-contained.
Forexampletheamalgamatom Dead,Unreachable,Repeated was
designedtocaptureallformsoffrivolouscodeundertheassump-
tionthattheywouldbeidenticallyconfusing.Uponanalysis,our
statisticsindicatedthat,ofitsthreeconstituentpatterns,onlythe
snippet that tested unreachable code was signiicant on its own.
The other two types of code (dead and repeated code) were not
meaningfullyconfusing.Ourexistingsamplesizedidnotreacha
highenoughstatisticalpowertomakeanydecisiveclaimsabout
Dead, Unreachable, Repeated . However, our results do indicate that
there may be a diference in how people perceive diferent types
of redundant code, eventhough theyare oftenconlated incasual
conversation. More data isneededto make astronger claim.
KeyTakeaway :Ofourproposedatoms,15havebeenshownto
bemoreconfusingthancorrespondingclariiedcode.Theseresults
are statistically signiicant and the size of the efect varies from
moderateto very large.
5.3.2 Didsubjectserrinthesameway? Thereisevidencethat
individual atoms behave qualitatively diferent from each other.
By analyzing the number and character of unique answers to a
question,itbecameclearthatthewaysinwhichsubjectswerecon-
fused by atoms varied. For many questions, there was one answer
that consistently seemed correct, but was not. The best example
is from the Change of Literal Encoding atom, which was framed
likeprintf("%d\n", 013); . For this atom, 80% of all subjects
erroneously responded that the statement would print 13, missing
thattheleadingzerodenotesanoctalvalueandwillprint 11when
represented in base ten. This is an exemplary ‘trick’ question in
that somanysubjectsmadethe same,very understandable,error.
Otherquestionshadadiferentfailuremode,inwhichtherewas
a broader distribution of wrong responses. These prominent state-
ments are excerpted from an obfuscated Comma Operator snippet:
int V1 = 3;
int V2 = (V1 *= 2, V1 += 1);
printf("%d %d\n", V1, V2);
134UnderstandingMisunderstandingsin Source Code ESEC/FSE’17,September4–8, 2017, Paderborn,Germany
Out of49 responses to thisquestion, participantsproposed 21dis-
tinctanswers.Somepeopleseemedtoassumethatparenthesesand
commaworkedasatupleoperator,andbelievedtheanswerwas
7 (6, 7) or3 6 4. Others seemed to simply forget which side
of the comma was returned with an answer of 6 7. Some even
constructed semantics whereby the comma would actually prevent
orundo state changeonits left handsidewitharesult of 4 6.
Thisconcept isquantiiedusing entropyasametricfordisper-
sion,orthedegreetowhichallanswersdoordonotresembleeach
other. Table 2 lists the dispersion rates for both the obfuscated and
clariiedprograms ofeachatom.
Key Takeaway : There are some questions that subjects an-
sweredwronginthesameway,andotherstheyansweredwrong
diferently.This qualityisindependent ofatomefectsize.
5.3.3 Howdidquestionplacementafectcorrectness. Sincewe
testedpairsofquestionsthatwerefunctionallyequivalent,there
was concern that, after seeing one question of a pair, the second
wouldbefamiliarandthereforeeasier.Wemitigatedthisbyplacing
aminimumdistancebetweenquestionsofapair,buttoconirm,we
inspectedtheresultsforthisphenomenon.Firstly,wenoticedthere
was a steady increase of correct answers as participants answered
more questions. Between the irst and last questions there was a
~7% increase in correct answers. This was independent of whether
ornotaquestionwaspreceededbyitspair,asitoccurredbothin
the irst and last several questions of the experiment, where the
snippets were uniformly irst and second of a pair, respectively.
Adjusting for this global learning efect and whether a snippet
wasobfuscatedorclariied,asubjectwas1%morelikelytogeta
questioncorrectafterseeingitspair.Thisefectwasnotstatistically
signiicant ( p=0.88) using aone-tailedbinomialtest.
Key Takeaway : Subjects performed better on later questions,
but the order ofquestionsinapair hadlittleto noefect.
5.3.4 Wasthereaspeed/accuracytrade-of? Inmanyphysical
and psychological activities, there is an inverse relationship be-
tween the speed at which an activity is performed and its resulting
accuracy[ 18].Weexpectedtoseeasimilarresultinourexperiment.
Our results, however, indicate the opposite. As subjects responded
quicker,thecorrectnessoftheiranswersincreased acrossallsnip-
pets.Themeanincorrectanswertook23.5secondstoformulate,but
themean correctansweronly18.5. Thediferencewas signiicant
(p=3.35e−32)usingtheWilcoxonranksumtest.Intuitively,this
may mean that a snippet the subject is conident about will take
less efort than a snippet the subject has to work to understand.
Thisalsocorrespondstoresultsfromouranalysisonlearningef-
fect,wherebytheendoftheexperimentparticipantsweredoing
better in both performance and speed. One additional point this
dataimpliesisthatoursubjectswererelativelyattentive.Ifsubjects
had guessed randomly on diicult questions we would expect to
seequickerresponsetimesandpooreraccuracy.Therawdata,how-
ever, suggests subjects did take more time to answer more diicult
questions.
KeyTakeaway :Thereisapositivecorrelationbetweenanswer
speedand correctness. The quicker asubject responded,the more
likely the were to have gotten the answer correct.6 ATOMIMPACTEXPERIMENT
To broaden our understanding of how multiple atoms afect larger
bodiesofcode,wetestedtheirimpacton largersamplesfromthe
samesourceasthecodesnippets(Figure4).Theexperimentused
winning programsfrom the IOCCC before andafter atomsof con-
fusionwereremovedtotestsubjects’abilitytohandevaluatefull
programs.
Design: RandomizedPartialCounterbalanced
Sample: 43 programmers with ≥6monthsC/C++
experience.
Control: Small programs (between 14-84lines) containing
several atomsofconfusion.
Treatment : A versionof the controlcode transformedto
remove the atomsofconfusion.
NullHypothesis H0:Codefrombothcontrolandtreatment
groupscan be hand-evaluatedwithequal accuracy.
Alternative Hypothesis Ha: Multiple atomsof confusion
causemoreerrorsinhand-evaluatedoutputsthanothercode.
Figure 4:Summary ofthe Atom ImpactExperiment
6.1 Design
Participantswereinstructedtołstepthroughtheprogramasifyou
werethecomputer,executingeachinstruction...žandtoł...recordthe
standardoutputoftheprogramž.2Theexperimentalprogramswere
modiied to include a printfafter every control low operation
andotherwisefrequentlyenoughtogatherinformationfromthe
subject.Everylineofoutputwasformattedas label: var1 var2
...,andforcedsubjectstorelaytheirconceptionofthestateof
each modiied piece of memory in the program. Each element of
eachlineofhuman-generatedoutputwasscoredaseithercorrect
or incorrect. For example, a line with a label and 3 parameters
couldgarnerupto4pointsforparticipantsiftheyweretowritethe
entirelinecorrectly.Apointwassubtractedforeachwrongelement.
Every program had several lines of output that each subject was
expected to evaluate and record, and the combined score of all the
linesfrom asingleprogram formedthe subject’s score.
We chose four of the shortest IOCCC winners, so that we had
datapointsfromdiferentconfusingprograms.Weselectedthese
programs from the irst, last, and two intermediate years of the
contest’soperation.Eachprogramwasnormalizedbythesamepro-
cess described in Section 3, removing non- C99compliant code and
out-of-scopesourcesofconfusion.Thesenormalizedśbutother-
wiseunalteredśprogramsservedasourcontrolquestions,andare
referredtoasourobfuscatedquestions.Ourtreatmentquestions
were created by removing each atom through an atom removal
transformation.Theseprogramsasreferredtoasourclariiedques-
tions. Each participant was shown 4 programs, half of which were
from the control set, and the other half from the treatment set. No
one received two versions of the same program. The order and
distribution of questions was randomly generated and assigned to
subjects.
2Completeinstructions can be found at https://atomsofconfusion.com/2016-program-study
135ESEC/FSE’17,September4–8, 2017, Paderborn,Germany Gopstein, Iannacone,Yan,Delong,Zhuang, Yeh,andCappos
We recruited programmers with at least 6 months of CorC++
experience. Before running our experiment we conducted a pi-
lotwith10subjects.Wecalculatedournecessarysamplesizefor
the experiment by estimating the required power to ind statisti-
callysigniicantdiferencesbetweentheresponsesofanobfuscated
programanditscorrespondingclariiedprogram.Ouranalysissug-
gested we needed 40 samples to reach a nominal power of β=0.8
withatypeIerrorrateof α=0.05.Intotal,wecollectedsamples
fromN=43 participants, slightly exceeding our target.
6.2 Analysis
Results were graded dynamically for each test using a program
that attributed partial credit to each response, described as follows.
If a participant made an error and misinterpreted the value of a
variable,thegraderprogramwoulddocktheappropriatenumber
of points, but then modify the original program to continue us-
ingthesubject’sconceptionofthecurrentstate.Thismethodhas
the advantage of avoiding the accumulation of intermediate errors.
Forsomeprogrammingmistakes,oneerrorearlyintheprogram
would cause a subject to incorrectly write every line of output
that follows. Instead we only penalize each error once. As a re-
sult, the total number of measurements per participants is variable,
anddirectcomparisonsbetweenindividualresponsesarediicult.
Consequently,wemakeouranalysesbasedontherateofcorrect
output provided by the subject instead of by the total number of
pointsscored.Whereparticipantsfailedtoreachthehaltstateof
the program, we deducted points for every missed output until
thestandardterminationoftheprogram.Usingcorrectnessrates
over the evaluation output from each subject, we compared the
results from obfuscated and clariied programs. We used a one-
tailedWelch’st-testtoshowthelevelofsigniicancebetweenmean
correctnessratesfromprogramsthatcontainedatomsofconfusion
as opposedto programs that didnot.
6.3 Results
6.3.1 Areclarifiedprogramsevaluatedmoreaccuratelythanob-
fuscated programs? Our results are displayed in Figure 5. Looking
at all obfuscated programs compared against all clariied programs,
we can see that participants had (statistically signiicant) higher
error rates on the obfuscated programs. These results are mirrored
ineachoftheindividualprograms.Ineveryquestionpair,theclari-
ied program was answered with signiicantly more accuracy than
the obfuscated version. However, there is a large variance between
the scores for variousprograms. Question1hadthe lowestscores
overall and Question 2 had the highest. Even in this most extreme
example,theclariiedversionofQuestion1wasansweredcorrectly
atahigherratethantheobfuscatedversionofQuestion2.Every
clariied question was, on average, easier to interpret than every
obfuscated question. The trend continues on a per-subject basis.
The subjects performed better on clariied questions by an almost
8:1 ratio,anddidsobya3.4xmargin inraw score.
KeyTakeaway : Subjects’meancorrectness increasedby more
than50%between obfuscated(0.47) andclariied(0.73) programs.
6.3.2 What other ways can we measure subject performance?
Outside of the primary grading metric, there were several other
0.00.20.40.60.81.0
Obfuscated Clarified  Correctness
All
p: 2.34e−08
d: 0.88Q1
p: 0.0352
d: 0.57Q2
p: 0.0014
d: 0.99Q3
p: 0.0003
d: 1.18Q4
p: 0.0003
d: 1.17
Figure 5: Average score by question type. Rate of correct answers
foreachprogramtype,andforallobfuscatedandclariiedprograms
combined. pdenotesp-value and ddenotesCohen’s defectsize.
    FailuresRate
0.050.100.150.200.250.30
 Give Ups 
p=0.0001Control
Flow Errors
p=0.0021
Obfuscated
Clarified
       SuccessesRate
0.050.100.150.20
Points
Answered
p=0.0020Totally
Correct
p=0.0084
Figure 6:Secondary statisticsregarding subjects’ behavior
indicators that suggested atoms reduced comprehension for partic-
ipants.SeveralsecondarymetricsaregraphedinFigure6.While
all evaluation errors were graded equally and errors were propa-
gated to reduce the cumulative efect of a misunderstanding, some
errors had a larger deviating efect on the participants’ evaluation.
Whenever a subject accidentally followed a wrong low control
path through thecode, almostall following resultswere incorrect.
These low control errors happened roughly 3 times as often in
obfuscated programs. Participants were given the option of giving
up on a question, and code with atoms caused people to give up
3.5timesasoftenascodewithout.Moreover,excludingprograms
whereparticipantsexplicitlygaveup,thesubjectsalsoprovidedsig-
niicantlyfewerlinesofoutputonobfuscatedprograms,skipping
more than twice as many output points as in clariied programs.
Errorsintheresponseswereextremelycommon,butseveralpartic-
ipantswereabletoaccuratelyevaluateentireprograms.Clariied
programs werecorrectlyevaluatedive timesmore often thanthe
obfuscated originals. Each of these diferences is statistically sig-
niicant, showing that programmers are confused by atoms across
manydiferentmetrics.
136UnderstandingMisunderstandingsin Source Code ESEC/FSE’17,September4–8, 2017, Paderborn,Germany
●
●●●
●●
●
●●
●●
●
●●●●
●
●
●
●●●●
●●●
●●●●●
●●●●
●
●●●
●●
●
0.20.40.60.81.0
n=4 n=10 n=13 n=10 n=4 n=1
1 2 3 4 5 6
 (novice)                        (expert)Correctness Rate
Figure 7: How well each subject performed on the atom im-
pactexperiment,relativetotheirperceptionoftheirknowl-
edgeofC/C++
Key Takeaway : Motivation and time-on-task was increased in
programswithatomsremoved,assubjectsgaveup71%lessoften
andwrote32%more output.
6.3.3 Whichcode wasstill confusingin clarifiedprograms? We
removed many atoms from the programs in the atom impact ex-
periment. Yet, even after all known atoms were removed, subjects
still had a 27% error rate on clariied programs, indicating some
sourceofconfusionremainsintheclariiedprograms.Byobserv-
ing whereconfusion happenedinthe clariiedprograms, we can
discovernewatomcandidatestotestinthefuture.Oneofthemost
common errors inclariiedprograms was a misunderstanding of
howCinitializes global variables, with many subjects insisting the
value would be łgarbagež, even though C99states in Section 6.7.8,
p10 łIf an object that has static storage duration is not initialized
explicitly, then... if it has arithmetic type, it is initialized to (positive
orunsigned)zero ž[1].Thisisnotanunknownphenomenon.Infact,
theIndian Hill C Style and Coding Standards [8] recommends using
explicit, ratherthanimplicitvariable initialization.
Key Takeaway :Removingatomsfromaprogramandhaving
subjects evaluate both versions can be used iteratively to continue
identifying newatomcandidates.
6.3.4 SelfPerception. Aftertheexperimentconcluded,weasked
eachsubjectłHowwouldyouestimateyourproiciencyinC/C++?ž
Inaggregate,thesubjects’responseswerequiteaccurate.Theme-
dian self-evaluation for each score was monotonic with perfor-
mance, excepting the singular response in which someone self-
identiied as łExpertž, while their performance suggested less com-
petence (Figure 7).
Key Takeaway : Subjects’beliefs abouttheirproiciencycorre-
latedwell withtheirperformance.
7 DISCUSSION
Here we explore the bigger picture. Now that we have identiied
confusing code patterns, how well are they addressed by expert
recommendations?Arethereanydiscrepanciesbetweentheirex-
perience andour results? Andhowgeneralizable isour work?7.1 Which atomsaremissingfrom popular
style guidelines?
Wesurveyedseveralmodernandclassic Cstyleguides[ 9,15,19,26,
34,39,41]toindreferencestopatternswehaveidentiiedasatoms
of confusion. Of the 19 patterns we proposed, 15 were explicitly
mentioned. Two of the four unmentioned candidates did not meet
statistical signiicance, but the other two ś Reversed Subscripts and
Preprocessor in Statement ś had moderate and very large efect
sizes, respectively. We conducted a preliminary analysis of the
Linux kernel source code to count how often these atoms occur
in practice. Though we found no instances of Reversed Subscript
atoms,there were thousandsofoccurrencesofthe Preprocessorin
Statement . Given that Preprocessor in Statement is the second most
potent atom, it is a topic that ought to be acknowledged in code
comprehensionliterature.
Key Takeaway : Style Guidelines have overlooked some very
confusing patterns that are usedinpractice.
7.2 Wheredo ourresultsdifer from style
guide recommendations?
Themajorityofadviceinpopularstyleguidesseemssound,andour
results largely match their recommendations. However, there were
afewinstanceswhereweeithercouldnotconirmtheirposition,
orfoundevidenceto contradict it.
Assignment as Value : GNU coding standards [ 39] say łassign-
ments inside while-conditions are okž. Our data shows a 38% in-
crease in the number of correctly evaluated assignments when
movedfrom inside the while-condition to outside.
Pointer Arithmetic : Rob Pike [ 34] proposed that, łAn expression
thatevaluatestoanobjectisinherentlymoresubtleanderror-prone
thantheaddressofthatobjectž.Inourexperiment,subjectswere
slightlymorelikelytomakeerrorswhileevaluatingpointernota-
tionthan subscriptnotation.Whilethere is not enough statistical
power to draw any irm conclusions, it is not obvious that pointers
are less confusing thanłexpressionsthat evaluate to objectsž.
Omitted Curly Braces : The Linux style guide states, łDo not
unnecessarily use braces where a single statement will dož, [ 41]
and the NASA C Style Guide [ 15] omits braces in every single-line
selectionexample,exceptwhendemonstratingexplicitlydangerous
constructs.Ourresultsshowthatoursubjectsmade22%moreerrors
when braceswere omitted.
Conditional Operator : Kernighan and Pike [ 26] argue łthe ?: op-
eratorisineforshortexpressionswhereitcanreplacefourlines
of if-else with onež. In our data, which only includes łshort expres-
sionsž,?:leads to 31%more errorsthanif-statements.
Key Takeaway : At least ive popular style guides encourage or
fail to warnagainst confusing patterns usedinlarge projects.
7.3 Didsubject experience haveanefect?
Ourexperimentwasconductedonasamplecomposedlargelyof
students. Based on prior work, we thought it was possible that the
subjects’low experiencemightafecttheir performance.InJones’
investigationofdeveloperbeliefsaboutbinaryoperators[ 25],he
testedforacorrelationbetweenthesubjects’yearsofexperience
and the accuracy of their responses. His results showed no statisti-
cally signiicant relationship between experience and performance.
137ESEC/FSE’17,September4–8, 2017, Paderborn,Germany Gopstein, Iannacone,Yan,Delong,Zhuang, Yeh,andCappos
●●
●●
●●●●
●●●
●●
●●●
●●●●
●
●
●●
●●
●●
●●●
●
●●●●●
●●
●●●
●●
●●
●●●
●●●
●●●
●●
●
●
●●
●●●●
●● ●
●
0 2 4 6 8 10Existence Experiment
Y ears of C experienceCorrectness
0.0 0.5 1.0r = 0.48●●
●
●●●
●
●●
●●●
●●●●●●
●●
●●●
●●
●●●●
●●
●●●
●
●●●
●
●●
●
0 5 10 15 20 25Impact Experiment
Y ears of C experienceCorrectness
0.0 0.5 1.0r = 0.14
Figure8:Thecorrelationbetweenexperiencewith Candper-
formance.Trendsmodeled as monomials.
In both ofour experiments,however,there isa smallto moderate
correlationbetweenyearsofexperiencewith Candperformance.
Figure 8 shows the relationship between these variables. Since our
methodsuseamatchedpairdesignthatcomparesaparticipant’s
answers only against his/her own, the efects of experience do
not impact the internal validity of our methods. Since the average
professional software engineer has more experience than our aver-
age subject, the efect sizes reported may be overstated for some
populations.
We also analyzed whether theclass oferrorswere diferent(i.e
didmoreexperiencedsubjectsgetanyquestionswrongthatless
experienced subjects answered correctly?). Ultimately, we found
thatincorrectanswerswereroughlymonotonicwithexperience.
As experience increased, subjects got fewer and fewer questions
wrong, and the hardest questions were answered incorrectly by
everyone.Theseresults mirrorthoseofDoladoetal.[14].
Key Takeaway : Subjects with more experience make fewer
errorsthansubjectswithless experience.
8 THREATS TO VALIDITY
Wetookmeasurestoensurescientiicrigorwherepossible,both
in thedesign and executionof our experiments. Here we describe
remaining issues,potentialandexistent.
ThreatstoInternalValidity .Despiteourbesteforts,ourdata
indicates thatsomeofourobfuscatedcodestillcontainedsources
of confusion (e.g. in Pointer Arithmetic snippets). This results in ar-
tiicially low efect sizes for otherwise potentially confusing atoms.
In cases where there is a high rate of confusion in obfuscated code,
our data could be improved by simplifying the question subjects
are askedto solve.
Theprocessofinitiallychoosingatomcandidatesisinherently
subjective and it is possible that a diferent team would have se-
lecteddiferentcandidates.Sincecandidateswerelatersubjected
to rigorous validation, our approach is not overly likely to yield
‘false positives’, yet it is susceptible to false negatives (e.g. the mis-
understanding of global variable initialization described in Section
6.3.3). This process does, however, leave room to test new atom
candidates for future experiments.
Wecollecteddataonthenumberofmonths/yearsoursubjects
hadbeenprogrammingin C.Itisausable,butnotidealproxyfor
experience. In future experiments we plan to ask more nuanced
questionsregarding programmingexperience.ThreatstoExternalValidity .Ouratomsweredrawnfroman
obfuscatedcodecontestwhichisquitediferentfrommostother
codebases. This fact does call into question whether these atoms
existinmorepragmaticprojects.Preliminaryworkinthisdirection
by the authors indicates that some atoms do occur frequently in
popular open source projects. In total we’ve found hundreds of
thousands of atoms in gcc and the Linux kernel. As we continue
to uncover data on this topic it will be periodically released to
https://atomsofconfusion.com/2017-atom-inder.
To reduce confounding factors, we prohibited the use of any ex-
ternalresource,whichmaymakeourresultslessapplicabletohow
the programmers actually work. Without imposing such bound-
aries,however,itisdiiculttotellhowmuchoftheobservedefect
isinherentto the programmer.
Inarelateddecision,ournormalizationstepsmayhaveproduced
codethat looks less like that typicallyproduced by a programmer.
The degree to which atoms afect readers inthe context of higher-
level information isstillunknown.
Oursubjectsweredrawnlargelyfromuniversitystudentsand
do not represent the population of all programmers. While the
existence of atoms of confusion is shown by our subjects, it would
be prudent not toassume atomswork the same wayfor everyone.
9 CONCLUSION
Weusedtwoexperimentstoevaluatesmallpatternsincodethat
canproduceconfusioninprogrammers.Weshowedexperimentally
that many code patterns increase misunderstanding at a statisti-
cally signiicant rate versus equivalent code without the pattern.
Wealsoshowedthatremovingthesecodepatternshadasubstan-
tial impact on a programmer’s ability to understand larger code.
Our results provide evidence both for and against common coding
recommendations,andsuggestanewmethodtoexpandonexisting
guidelines. It also suggests some interesting topics for exploration:
•Amorecompletelistofatomscanbegeneratedbyrepeating
theatomdiscoveryprocessfromtheclariiedprogramsin
ouratomimpactexperiment.Subsequentiterationsofthis
processcanbeneitfromthequantitativedatagatheredin
prior experiments.
•Using the atoms described here, large open source projects
can be auditedfor their use of atomsof confusion.
•This methodology can be applied to languages other than C
to improve guidelines andind cross-language similarities.
•The cause ofatomscanbe exploredusing HCItechniques
to understand why programmers make the mistakes they
make,andhowthesecan be prevented.
To encourage other researchers to replicate our work or ex-
plore related questions, our materials and data are available at
https://atomsofconfusion.com.
ACKNOWLEDGEMENTS
WewouldliketothankXiangrenłJackžChenandHongweiłHenryž
Zhou for helping create our instrument and analysis tools. We are
grateful to Kristen Walcott and Frank Ritter for helpful sugges-
tions towards improving our paper. Lastly, this work would not be
possiblewithouttheIOCCCandalloftheparticipantsinourexper-
imentstowhomweareverythankfulfortheirtimeandefort.This
work wassupportedinpart byNSF grants 1444827 and1513457.
138UnderstandingMisunderstandingsin Source Code ESEC/FSE’17,September4–8, 2017, Paderborn,Germany
REFERENCES
[1]1999. IEC 9899: 1999:Programming languagesC. InternationalOrganization for
Standardization (1999), 243ś245.
[2]Eran Avidan and Dror G Feitelson. 2015. From obfuscation to comprehension. In
Program Comprehension (ICPC), 2015 IEEE 23rd International Conference on . IEEE,
178ś181.
[3]Alberto Bacchelli and Christian Bird. 2013. Expectations, outcomes, and chal-
lenges of modern code review. In Proceedings of the 2013 International Conference
onSoftwareEngineering . IEEE Press,712ś721.
[4]Mike Bland. 2014. Finding more than one worm in the apple. Commun. ACM 57,
7 (2014), 58ś64.
[5]MaartenASBoksem,TheoFMeijman,andMonicqueMLorist.2005. Efectsof
mental fatigue on attention: an ERP study. Cognitive Brain Research 25, 1 (2005),
107ś116.
[6]Dennis Burke. 1995. All circuits are busy now: The 1990 AT&T long distance
networkcollapse. California Polytechnic State University (1995).
[7]RaymondPLBuseandWestleyRWeimer.2008. Ametricforsoftwarereadability.
InProceedingsofthe2008internationalsymposiumonSoftwaretestingandanalysis .
ACM,121ś130.
[8]LWCannon,RAElliott,LWKirchhof,JHMiller,JMMilner,RWMitze,EPSchan,
NO Whittington, Henry Spencer, David Keppel, and others. 1991. Recommended
Cstyleandcodingstandards . Pocketreferenceguide.SpecializedSystemsCon-
sultants.
[9]LWCannon,RAElliott,LWKirchhof,JHMiller,JMMilner,RWMitze,EPSchan,
NO Whittington, Henry Spencer, David Keppel, and others. 1991. Recommended
Cstyleandcodingstandards . Pocketreferenceguide.SpecializedSystemsCon-
sultants.
[10]JacobCohen.1988. StatisticalPowerAnalysisfortheBehavioralSciences.2nd
edn. Hillsdale, NewJersey. (1988).
[11]ChristianCollberg, Clark Thomborson, andDouglas Low.1997. A taxonomyof
obfuscatingtransformations . Technical Report.Departmentof ComputerScience,
The Universityof Auckland,NewZealand.
[12]ThomasACorbi.1989. Programunderstanding:Challengeforthe1990s. IBM
SystemsJournal 28,2 (1989), 294ś306.
[13]EdsgerWDijkstra.1968. Letterstotheeditor:gotostatementconsideredharmful.
Commun. ACM 11,3 (1968), 147ś148.
[14]José Javier Dolado, Mark Harman, Mari Carmen Otero, and Lin Hu. 2003. An
empirical investigation of the inluence of a type of side efects on program
comprehension. SoftwareEngineering,IEEETransactionson 29,7(2003),665ś670.
[15] JerryDoland and JonValett.1994. CStyleGuide. (1994). NASA.
[16]Valerie L Durkalski, Yuko Y Palesch, Stuart R Lipsitz, and Philip F Rust. 2003.
Analysis of clustered matched-pair data. Statistics in Medicine 22, 15 (2003),
2417ś2428.
[17]James L Elshof and Michael Marcotty. 1982. Improving computer program
readabilityto aid modiication. Commun. ACM 25,8 (1982), 512ś521.
[18]Paul M Fitts. 1954. The information capacity of the human motor system in
controlling the amplitude of movement. Journal of experimental psychology 47, 6
(1954), 381.
[19]MartinFowler. 2009. Refactoring:improvingthedesignofexistingcode . Pearson
EducationIndia.
[20]Dan Gopstein. 2016. clust.bin.pair: Statistical Methods for Analyzing Clustered
MatchedPairData .https://CRAN.R-project.org/package=clust.bin.pairRpackageversion 0.0.6.
[21]John Graham-Cumming. 2017. Incident report on memory leak
caused by Cloudlare parser bug. (2017). https://blog.cloudlare.com/
incident-report-on-memory-leak-caused-by-cloudlare-parser-bug/ [Online;
accessed 2017-02-23].
[22]Maurice Howard Halstead. 1977. Elements of software science . Vol. 7. Elsevier
NewYork.
[23]J-MJazequelandBertrandMeyer.1997. Designbycontract:ThelessonsofAriane.
Computer 30,1 (1997), 129ś130.
[24] Stephen CJohnson.1977. Lint, a C programchecker .
[25]DerekM.Jones.2006.Developerbeliefsaboutbinaryoperatorprecedence.(2006).
[26]BrianW Kernighan andRob Pike. 1999. The practiceofprogramming . Addison-
WesleyProfessional.
[27]Bennet P Lientz, E. Burton Swanson, and Gail E Tompkins. 1978. Characteristics
of applicationsoftwaremaintenance. Commun. ACM 21,6 (1978), 466ś471.
[28] Jacques-Louis Lions and others.1996. Ariane 5 light 501failure. (1996).
[29]LindsayMarshallandJamesWebber. Gotosconsideredharmfulandotherpro-
grammers taboos.
[30]Thomas J McCabe. 1976. A complexity measure. Software Engineering, IEEE
Transactions on 4 (1976), 308ś320.
[31]Quinn McNemar. 1947. Note on the sampling error of the diference between
correlated proportions orpercentages. Psychometrika 12,2 (1947), 153ś157.
[32]James H Neely. 1991. Semantic priming efects in visual word recognition: A
selectivereviewofcurrentindingsandtheories. Basicprocessesinreading:Visual
wordrecognition 11(1991), 264ś336.
[33]LandonCurtNoll,SimonCooper,PeterSeebach,andABroukhisLeonid.1984.
Rules. (Mar1984). http://www.ioccc.org/1984/rules
[34]Rob Pike. 1989. Notes on Programming in C. URL http://www. lysator. liu.
se/c/pikestyle.html 2 (1989), 4.
[35]JarrettRosenberg.1997. Somemisconceptionsaboutlinesofcode.In Software
Metrics Symposium, 1997. Proceedings,Fourth International . IEEE,137ś142.
[36]JingqiuShaoandYingxuWang.2003. Anewmeasureofsoftwarecomplexity
based on cognitive weights. Electrical and Computer Engineering, Canadian
Journal of 28,2 (2003), 69ś74.
[37]ForrestJShull,JefreyCCarver,SiraVegas,andNataliaJuristo.2008. Theroleof
replicationsinempiricalsoftwareengineering. EmpiricalSoftwareEngineering
13,2 (2008), 211ś218.
[38]Janet Siegmund, Christian Kästner, Sven Apel, Chris Parnin, Anja Bethmann,
Thomas Leich, Gunter Saake, and André Brechmann. 2014. Understanding
understanding source code with functional magnetic resonance imaging. In
Proceedingsofthe36thInternationalConferenceonSoftwareEngineering .ACM,
378ś389.
[39] Richard Stallmanand others.1992. GNU coding standards. (1992).
[40]Yahya Tashtoush,ZeinabOdat,IzzatAlsmadi,andMaryanYatim.2013. Impact
of programmingfeaturesoncodereadability. (2013).
[41]Linus Torvalds. 2001. Linux kernel coding style.
https://www.kernel.org/doc/Documentation/CodingStyle (2001).
[42]WilliamWulfandMaryShaw.1973. Globalvariableconsideredharmful. ACM
Sigplannotices 8,2 (1973), 28ś34.
[43]ShengYuandShijie Zhou. 2010. A surveyonmetric of softwarecomplexity.In
InformationManagementandEngineering(ICIME),2010The2ndIEEEInternational
Conference on . IEEE,352ś356.
extern int
errno
;char
grrr
;main( r,
argv, argc ) int argc ,
r ; char *argv[];{int P( );
#define x int i, j,cc[4];printf(" choo choo\n" ) ;
x ;if (P( ! i ) | cc[ ! j ]
& P(j )>2 ? j : i ){ *argv[i++ +!-i]
; for (i= 0;; i++ );
_exit(argv[argc- 2 / cc[1 *argc]|-1<<4 ] ) ;printf("%d",P(""));}}
P ( a ) char a ; { a ; while( a > " B "
/*- by E ricM arsh all- */); }
139