SMOKE : Scalable Path-Sensitive Memory Leak
Detection for Millions of Lines of Code
Gang Fan‚àó, Rongxin Wu‚àó¬ß, Qingkai Shi‚àó, Xiao Xiao‚Ä†, Jinguo Zhou‚Ä†, Charles Zhang‚àó
‚àóHong Kong University of Science and Technology
{gfan, wurongxin, qshiaa, charlesz}@cse.ust.hk
‚Ä†Sourcebrella Inc.
{xx, jinguo}@sbrella.com
Abstract ‚ÄîDetecting memory leak at industrial scale is still
not well addressed, in spite of the tremendous effort from
both industry and academia in the past decades. Existing worksuffers from an unresolved paradox ‚Äì a highly precise analysis
limits its scalability and an imprecise one seriously hurts its
precision or recall. In this work, we present S
MOKE , a staged
approach to resolve this paradox. In the Ô¨Årst stage, instead of
using a uniform precise analysis for all paths, we use a scalable
but imprecise analysis to compute a succinct set of candidatememory leak paths. In the second stage, we leverage a more
precise analysis to verify the feasibility of those candidates.
The Ô¨Årst stage is scalable, due to the design of a new sparse
program representation, the use-Ô¨Çow graph (UFG), that models
the problem as a polynomial-time state analysis. The second stageanalysis is both precise and efÔ¨Åcient, due to the smaller number
of candidates and the design of a dedicated constraint solver.Experimental results show that S
MOKE can Ô¨Ånish checking
industrial-sized projects, up to 8MLoC, in forty minutes withan average false positive rate of 24.4%. Besides, S
MOKE is
signiÔ¨Åcantly faster than the state-of-the-art research techniques
as well as the industrial tools, with the speedup ranging from
5.2X to 22.8X. In the twenty-nine mature and extensively checked
benchmark projects, S MOKE has discovered thirty previously-
unknown memory leaks which were conÔ¨Årmed by developers,
and one even assigned a CVE ID.
Index T erms‚Äîmemory leak, static bug Ô¨Ånding, use-Ô¨Çow graph,
value-Ô¨Çow graph
I. I NTRODUCTION
Despite the tremendous research progress in recent
decades [1]‚Äì[9], the detection of memory leaks in industrial-
scale is still pretty much an unsolved problem. In the Ô¨Årsthalf of the year 2018, more than 680 memory leak bugs havebeen reported in Firefox [10] and Chrome [11]. More than240 CVE (Common Vulnerabilities and Exposures) entries
in 2017 are memory leaks bugs [12]. Apparently, with the
explosive growth of the code size and the complexity inmodern software [13], a practical memory detector needs tobehighly scalable, checking millions of lines of code within
minutes , and precise, understanding complex path conditions
with less than 30% false positives [14], [15].
The state-of-the-art approaches suffer from the scalability
and precision paradox. One category of the approaches [4]‚Äì[9]give up path sensitivity for scalability, inevitably introducing
¬ßRongxin Wu is the corresponding author.imprecise results. For example, we observed that, S ABER [9],
a recent path-insensitive memory leak detection technique,incurs a false positive rate of 66.7% in our evaluation. Anothercategory [1]‚Äì[3] traverse the control Ô¨Çow graph and use thepath-sensitive analysis to achieve high precision. However,they are known to easily suffer from scalability issues, espe-cially for the whole-program analysis. For example, S
A TURN
[3] is reported to have spent more than 23 hours in checkingmemory leaks for a 5MLoC code base. Our experiment showsthat CSA [1] and I
NFER [2] fail to analyze large projects of
over 2MLoC in two hours.
Our idea to resolve this paradox is based on an observation
that, in real programs, only a small proportion of programpaths lead to memory leaks. Therefore, instead of using asledge hammer, i.e., the expensive path-sensitive analysis, for
all paths, we use a two-staged analysis by Ô¨Årst computing a
succinct set of candidate memory leak paths through a novelscalable and path-insensitive method, followed by a moreprecise and heavy-weight veriÔ¨Åcation of the feasibility of thesepaths, in order to achieve path-sensitivity.
More speciÔ¨Åcally, to check millions of lines of code in
minutes, we believe that the sparse value-Ô¨Çow analysis, already
widely adopted in Ô¨Ånding memory leaks [8], [9], is theright direction as it tracks values along the data dependencerelations on the value Ô¨Çow graph (VFG) instead of the control
Ô¨Çow graph, skipping irrelevant program statements to achievescalability. However, we observe that the VFG, originally
intended for program transformations [16], is not suitable forarbitrary Ô¨Ånite-state-machine properties such as the memoryleak problem, due to the omission of Ô¨Çow information(order
of events) [8]. Therefore, instead of Ô¨Ånding a leak path, VFG-based methods need to deduce the leak path by checkingwhether the non-leak paths (i.e., paths where the heap object is
safely freed) cover all control Ô¨Çow paths from where the heapmemory is allocated. Such an analysis is equivalent to solving
ak‚àíSA T problem, which is NP-hard with the input size
k>2(krepresents the number of the branch conditions) [17].
This induces a very high time complexity in theory and maygreatly compromise the efÔ¨Åciency and scalability in practice.For instance, the most recent VFG technique, Pinpoint [18],in spite of its leap in achieving scalability and precision, stillcannot complete the analysis in some large subjects in our
722019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)
1558-1225/19/$31.00 ¬©2019 IEEE
DOI 10.1109/ICSE.2019.00025
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:58:45 UTC from IEEE Xplore.  Restrictions apply. experiments.
To overcome this limitation, we designed an extension of
VFG, namely the use-Ô¨Çow graph (UFG), that encodes not just
the deÔ¨Ånition but also the use of the problem-relevant heap
objects. All use sites of the same heap object in UFG are
ordered according to the control Ô¨Çow, to check Ô¨Ånite-state-
machine properties and to use polynomial-time graph search
methods to Ô¨Ånd possible memory leak paths. Path-sensitivity
is achieved in the second stage by using a dedicated constraint
solver to verify the feasibility of these candidate leak paths.
The veriÔ¨Åcation process is efÔ¨Åcient because, at this stage, the
number of paths is very small (only 21 on average) and we
use a customized constraint solver to further Ô¨Ålter out ‚Äúeasy-
to-contradict‚Äù ones, leading to a further pruning of the paths.
Finally, we invoke a full SMT solver, such as Z3, for the
remaining candidates.
To evaluate the scalability and effectiveness of our proposed
technique, we implemented a tool, S MOKE , and applied it to
the SPEC2000 benchmark programs and seventeen well main-
tained open source projects. The experimental results have
demonstrated that S MOKE is highly efÔ¨Åcient and effective, as it
could Ô¨Ånish checking industrial-sized projects, up to 8MLoC,
in forty minutes with an overall false positive rate of 24.4%.
This is aligned with the common industrial requirements of
checking millions-of-LoC code [14], [15]. In the twenty-nine
mature and already extensively checked third-party benchmark
projects, S MOKE found thirty previously unknown memory
leaks, all conÔ¨Årmed by the original developers. One of the
reported leaks was even assigned with a CVE ID due to its
high severity.
We highlight our contributions as follows:
‚Ä¢We present the design and the implementation of S MOKE ,
a staged approach for detecting memory leaks. S MOKE
is faster, more scalable, and more precise than the state-
of-the-art approaches.
‚Ä¢We present a novel sparse program representation, namely
the use-Ô¨Çow graph, which allows us to efÔ¨Åciently and ef-
fectively detect memory leaks. Using the use-Ô¨Çow graph,
we can model the memory leak detection problem as a P
problem rather than an NP-hard problem on value-Ô¨Çow
graph.
‚Ä¢We extensively evaluated S MOKE with standard bench-
marks and a broad spectrum of open source projects. The
experimental results demonstrate that S MOKE achieves
the speedup ranging from 5.2X to 22.8X, compared with
the state-of-the-art techniques.
This paper is organized as follows. We Ô¨Årst present motivat-
ing examples in Section II. Section III describes our approach.
The implementation and evaluation are presented in Section
IV and Section V, respectively. Section VI discusses related
works and this paper is concluded in Section VII.
II. M OTIV A TING EXAMPLES
In this section, we use three examples to illustrate the
limitations of the conventional Sparse V alue-Flow Analysis(SVFA) [8], [9] for detecting memory leaks, which gives a
better understanding of the key insights of our approach.
A. Reducing Complexity with Use-Flow Graph
Conventional SVFA techniques, such as F ASTCHECK [8],
start with the sparse value-Ô¨Çow graphs (SVFG) as shown in
Figure 1(b) and Figure 2(b) for the code snippets in Figure
1(a) and Figure 2(a), respectively. In those SVFGs, each edge
represents a data-dependence relation, denoting the Ô¨Çow of
value. For example, the value-Ô¨Çow edge p@s2‚Üíp@s7in
Figure 1(b) implies that the allocated heap object pointed
to bypmay be released at the statement s7(we use si
to represent the statement at line i). In order to decide if
the memory is always released properly, F ASTCHECK an-
notates the control-Ô¨Çow conditions on the value-Ô¨Çow edges
and relies on a constraint solver to solve the conditions.
For the example in Figure 1, we will solve the condition
Fleak=¬¨((¬¨c1‚àß¬¨c2)‚à®(c1‚àß¬¨c2)).I fFleak is satisÔ¨Åable,
there exists a path with no memory release operations, leading
to a memory-leak vulnerability. Note that, in general, solving
Fleakis ak‚àíSA T problem [17] ( krepresents the number of
the branch conditions), which has the best time complexity
ofO((2‚àí2
k+1)n)[19] and is proved to be NP-hard [17] for
k>2.
In S MOKE , we propose a new type of sparse program
representation, named use-Ô¨Çow graph (UFG), that still contains
the necessary control-Ô¨Çow information. SpeciÔ¨Åcally, the UFG
encodes the deÔ¨Ånition and the use of problem-relevant heap
objects, which is similar to the sparseness feature in VFG.
In addition, it records the control Ô¨Çow order of uses of the
same heap object, which enables the checking of Ô¨Ånite-state-
machine properties such as memory leaks. Figure 1(c) shows
the UFG of the code in Figure 1(a). The UFG slices away the
unnecessary program statements, such as the ones in Lines 3
and 4, and only encodes the necessary data dependence and
the control dependence. Meanwhile, UFG explicitly models
the life cycle of a value by creating an out-of-scope node (i.e.,
p@s8in Figure 1(c)), which indicates that the heap object
pointed to by pis no longer referenced. A simple graph
traversal on the UFG shall discover that there exits a path
where the pointer pis never ‚Äúfreed‚Äù. Similarly, a simple graph
traversal on the UFG in Figure 2(c) will verify the absence
of memory leaks, because each path in the graph contains a
memory release operation. It is noteworthy that, using UFG,
we can obtain the same results with the same precision as that
of F ASTCHECK , without collecting constraints for each path
and using a heavyweight constraint solver.
B. Regaining Path-Sensitivity via Staged Constraint Solving
Since most of the allocated memory spaces are managed
properly in common software, many cases of memory leaks
can be detected by graph traversals on the UFG with the Ô¨Çow-
sensitive precision. However, there still exists a handful of
cases that require capturing branch correlations, the impor-
tance of which is illustrated by Figure 3. This example is leak-
free because the memory is allocated and released under the
73
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:58:45 UTC from IEEE Xplore.  Restrictions apply. p@›è‡¨∂
(a) Program leaks on an early exit at line 6(b) Sparse value- flow graph
(c) Use-flow graphp@›è‡¨ª
p@›è‡¨ºA
Leak 
Pathp@ ›è‡¨∂·à∫‡µì‹ø‡¨µ◊®‡µì‹ø‡¨∂·àª
◊©·à∫ ‹ø‡¨µ◊®‡µì‹ø‡¨∂·àª p@›è‡¨ª
1.voidfunc() {
2. char*p = malloc();
3. if(‚Ä¶) // ‹ø_1
4. printf();
5. if(‚Ä¶) // ‹ø_2
6. return;
7. free(p);
8. }
Fig. 1. A memory leak example.
(b) Sparse value-flow graph
(c) Use-flow graph‡µì‹ø‡¨µ ‹ø‡¨µ
p@›å‡¨∂
(a) A code snippet contains no memory leaksp@›å‡¨º p@›å‡¨π
p@›å‡¨µ‡¨¥p@›å‡¨∂
p@›å‡¨π p@›å‡¨º1.voidfunc(booly) {
2. char*p = malloc();
3. if(y) { // ‹ø_1
4. ‚Ä¶
5. free(p);
6. } else{
7. ‚Ä¶
8. free(p);
9. }
10. }
Fig. 2. An example without any memory leaks.
same condition at Line 4 and Line 7, respectively. However,
FASTCHECK , as well as other existing SVFA techniques (e.g.,
SABER ), will mistakenly report it as a memory leak due to
the negligence of the branch correlation. Such negligence is
caused by the large overhead of collecting path conditions
for many paths and the high complexity of conventional
constraint-solving methods.
To correctly identify that the code snippet is leak-free,
SMOKE employs a staged constraint solving process to verify
the feasibility of the candidate leak paths, such as the one
in Figure 3(c). First, we adopt a linear-time solver to Ô¨Ålter
obvious infeasible paths. Most of the false warnings involving
branch correlations can be pruned at this stage. For the
remaining paths with complex path conditions, we adopt a
fully-featured SMT solver, such as Z3 [20], to check their
feasibility to achieve a low false positive rate.
III. M EMORY LEAK DETECTION
In order to speed up the memory leak detection without
losing the precision, we make two design decisions. First,
we use a lightweight Ô¨Ånite-state analysis with a new sparse
program representation, the use-Ô¨Çow graph (Section III-A).
Second, we achieve the precision of path-sensitivity through a
dedicated constraint solver (Section III-B). In this section, we
assume that a program consists of functions in SSA form and
the pointer relations in the program have been resolved. We(b) Sparse value- flow graph
(c) Use-flow graph (a) Branches at line 3 and 
line 6 are correlated‹ø‡¨∂
p@›å‡¨∏
p@›å‡¨ª
p@›å‡¨Ωentry
A
Leak 
Pathp@›å‡¨∏ p@›å‡¨ª 1.voidfunc(booly) {
2. char*p = NULL;
3. if(y)   // ‹ø_1 
4. p = malloc();
5. ‚Ä¶
6. if(y) { // ‹ø_2 
7. free(p);
8. }
9. }
Fig. 3. A false memory leak due to an infeasible program path.
discuss how to satisfy the assumptions in our implementation
in the next section.
A. Finite State Analysis with Use Flow Graph
Our analysis is based on a new type of sparse program
representation, the use-Ô¨Çow graph (UFG). Compared to the
conventional sparse value-Ô¨Çow graph, UFGs have the fol-
lowing features for checking the Ô¨Ånite-state properties of a
program:
‚Ä¢It models the whole life cycle of program variables by
encoding the property-related control Ô¨Çows, which we
referred to as use Ô¨Çows.
‚Ä¢It can be efÔ¨Åciently built in linear time with regard to the
program size.
A Ô¨Ånite-state property of a program can be modeled as a
Ô¨Ånite-state machine (FSM), which deÔ¨Ånes the valid sequences
of operations that can be performed upon an object.
DeÔ¨Ånition 1 (Finite-State Machine (FSM)) .A Ô¨Ånite-state
machine of a program property is a quintuple M=( Œ£ ,S,
s0,Œ¥,F), where
‚Ä¢Œ£is a Ô¨Ånite, non-empty set of classes of program points.
‚Ä¢Sis a Ô¨Ånite, non-empty set of the states of a program
object.
‚Ä¢s0‚ààSis the initial state.
‚Ä¢Œ¥is the state-transition function: Œ¥:S√óŒ£/mapsto‚ÜíS.
Œ¥((s1,P)) =s2means that the state s1of an object
can transit to the state s2if the object goes through a
program point p‚ààP.
‚Ä¢F‚äÜSis the set of Ô¨Ånal states.
Example 1. As shown in Figure 4, we use an FSM to model
different states and state transitions of a heap object. There
are four states in the FSM: Allocated ( A), Freed ( F), Error
(E), and eXit ( X).Ais the initial state, and both Eand X
are the Ô¨Ånal states. Eindicates a safety violation of the Ô¨Ånite-
state property, such as memory leak and double free, and X
denotes a normal exit. The state Awill transit to the state Fif
a newly-allocated heap object goes through a program point
where a ‚Äúfree‚Äù operation is performed. The state Awill transit
to the state E(i.e., a memory leak issue) if a heap object goes
out of its life scope and can be no longer referenced.
74
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:58:45 UTC from IEEE Xplore.  Restrictions apply. 


		
			 
	
Fig. 4. The Ô¨Ånite-state machine for a heap object.
TABLE I
THE ANALYSIS STEPS IN EXAMPLE 3.
Step Vertex Before After
1 t@s2 - {A}
2 t@s3 {A}{ A,F}
3 p@s10 {A}{ A}
4 p@s11 {A}{ F}
5 p@s12{A},{F}{ A,F}
6 t@s6{A,F}{ F,E}
7 t@s7{A,F},{F}{ A,F}
8 t@s9{A,F}{ E,X}
Given an FSM, we can build the sparse program represen-
tation, the use-Ô¨Çow graph, as follows.
DeÔ¨Ånition 2 (Use-Flow Graph (UFG)) .The use-Ô¨Çow graph
of a program with regard to a given FSM is a directed graph
G=(V,E), whereVis the set of vertices and Eis the set
of edges:
‚Ä¢A vertex o@p‚ààVrepresents an object oat a program
pointp.pis one of the following program points:
‚Äìp‚ààPwhereP‚ààŒ£andŒ¥(s,P)/negationslash=s. That is, pis
a program point that can cause a transition between
different states.
‚Äìpis where we call a function using oas an actual
parameter.
‚Äìpis the entry of a function where ois a formal
parameter.
‚Äìfor each o@p/prime‚ààV,pis the dominance frontier [21]
ofp/prime. Intuitively, the dominance frontier is where the
states of the object ofrom different paths can be
merged.
‚Ä¢A directed edge (o1@p1,o2@p2)‚ààEif and only if
o1ando2represent the same object and there exists a
control Ô¨Çow path from p1top2. The path does not go
through any other program point p3such that there exists
o3representing the same object and o3@p3‚ààV.
Given a program and the FSM of a property, the UFG can
be built efÔ¨Åciently according to DeÔ¨Ånition 2 in polynomial
time. The basic idea is to traverse the control Ô¨Çow graph of
each function and remove the statements at program points
that are irrelevant according to the FSM.
Example 2. Figure 5 illustrates an example of the UFG w.r.t.
the FSM in Figure 4. As a sparse representation, all irrelevant
program statements such as the ones at Lines 4 and 5 are not
modeled. We have the vertices t@s7andp@s12because theyt@›èÕπt@›èÕµ
t@›èÕ∏t@›èÕ¥
p@›èÕ≥Õ¥p@›èÕ≥Õ≤
p@›èÕ≥Õ≥call
ret
t@s91.voidfoo() {
2. int*t = malloc(‚Ä¶);
3. bar(t);
4. intq = qux();
5. printf(‚Äú%d\n‚Äù, q);
6. if(‚Ä¶) free(t);
7. ‚Ä¶
8. return;
9. }10.voidbar(int*p) {
11. if(‚Ä¶) free(p);
12. }
Fig. 5. An example to illustrate UFG construction. sirepresents the program
point at Line i.
are the dominance frontiers of t@s6andp@s11, respectively.
At the program points s7ands10, the states of the heap object
from different program paths can be merged. We have the
vertext@s9because this is the end point of the scope of the
heap object t.
Next, we describe how to detect memory leaks using
UFG. The basic idea is to check the state of a heap object
by traversing the UFG inter-procedurally. When traversing a
UFG, we use a set to keep track of the states at each vertex.
From the memory allocation site, the state Ais added to
the set. The state set is propagated forward along the UFG
edges. When visiting a vertex corresponding to a transition of
the FSM, we transit a state accordingly. Otherwise, the states
remain unchanged. At each merge point, we merge the state
sets from different paths by the set union operation. Instead of
giving a complex formal representation of the algorithm, we
use the following example to illustrate the process.
Example 3. We use Table I to illustrate the steps of our state
analysis on the UFG in Figure 5. Each row of the table shows
the state set before and after a vertex. For example, in Steps
5 and 7, since the program points, s12ands7, are dominance
frontiers where two state sets from different paths meet, we
use the set-union operation to merge the states. In Step 8, since
the program point s9represents the end of the scope of the
heap object t, the state Atransits to the state Eand the state F
transits to the state X. Since the state Eis obtained via an out-
of-scope operation, we report a memory-leak candidate. This
candidate will be veriÔ¨Åed path-sensitively as detailed later.
75
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:58:45 UTC from IEEE Xplore.  Restrictions apply. As illustrated by the above example, the UFG is traversed
inter-procedurally. The context-sensitivity is achieved via the
CFL-reachability method [22]. That is, we assign a string to
each state during the graph traversal to check the validity of
the context. When propagating a state along a call edge at
a call site cs, we append a left parenthesis (csto the string.
When propagating a state back to a call site csalong a return
edge, we append a right parenthesis )csto the string. A state
propagation is valid only if the string has matched parentheses.
We create a function summary for each function in a
demand-driven way. That is, when reaching a call site, we
check if the callee has a usable summary so that we do not
need to reanalyze the callee. Otherwise, we create a summary
after the callee is analyzed. In our approach, a summary is a
map between the input states of a parameter pand the states
ofpat the end of a function. Therefore, it is unnecessary to
repeat the analysis of a function at different call sites if its
summary has been created.
Our analysis can be efÔ¨Åciently implemented using the RHS
algorithm [22]. Given an FSM M=( Œ£,S,s 0,Œ¥,F)and its
corresponding UFG G=(V,E), the time complexity of the
algorithm is O(|V|2|S|(|E||S|+|Calls||S|2)), where|Calls|
is the number of call sites in the program to check.
B. Staged Path-Sensitive V eriÔ¨Åcation
1.voidfoo(boolc) {
2. int*t = malloc(‚Ä¶);
3. if(c) 
4. free(t);
5. ‚Ä¶
6. if(!c) 
7. free(t);
8. ‚Ä¶
9. }
A False Leak Patht@›èÕ∑t@›èÕ¥
t@›èÕ∂
t@›èÕªt@›èÕ∫t@›èÕπ{A}
{F}
{A, F}
{F,E}{A}
{A, F}
{A, F}
{E, X}
Fig. 6. A false memory leak case whose path condition contains an apparent
contradiction c‚àß¬¨c.
Some of the UFG paths generated by the aforementioned
state analysis are infeasible, which may result in false positives
as illustrated in Figure 6. To reduce the false positives, we
introduce a path-sensitive veriÔ¨Åcation step where we collect
and solve path conditions of each memory-leak candidate
path. Although the path-sensitive veriÔ¨Åcation is usually expen-
sive, our approach can be efÔ¨Åcient because of two important
observations. First, we observe that the state analysis only
produces a handful of memory leak candidates that require
a path-sensitive veriÔ¨Åcation. This is because most of the heap
memory spaces are managed safely in practice. Second, we
observe that the constraint in a path condition usually has
apparent contradictions such as a‚àß¬¨a, as shown in the
example in Figure 6. The reason is that the programmers tend
to use direct contradictions to ensure some required logicalproperties. Thus, we Ô¨Årst adopt a linear-time solver to detect
apparent contradictions and to Ô¨Ålter obviously infeasible paths.
For the remaining complex cases, we use a fully-featured SMT
solver, such as Z3 [20], to check the path feasibility. The basic
idea of the linear-time solver is similar to the one used in prior
study [18], and it continuously collects the sets of positive and
negative atomic constraints during the construction of a path
condition. An atomic constraint is a Ô¨Årst-order logic formula
that does not contain any logic operator like ‚àß,‚à®, and¬¨.F o r
example, a<2bandcare two atomic constraints in a<2b‚àßc.
If a path condition has an atomic constraint ain both sets, this
path condition must contain a‚àß¬¨aand, thus, is unsatisÔ¨Åable.
IV . I MPLEMENTA TION
We have implemented S MOKE on top of the LLVM frame-
work [23], which takes an LLVM-Bitcode Ô¨Åle as input, for
detecting C/C++ memory leaks.
Similar to some earlier work [8], [9], [24], we have some
unsound trade-offs to make the detector more practical. We
assume a path in UFG is safe if this path Ô¨Çows to a global
pointer or a container (e.g., std::list, std::vector). We do not
report memory leaks if a path ends in a call to exit().I f
a heap object is used as an argument of a library function
(i.e., a function that is not deÔ¨Åned in the bitcode) on a path,
we conservatively treat it as an unknown value and stop
searching this path. We manually modeled some common
library functions, such as memcpy andmemset , to improve
the precision and the recall. Similar to F ASTCHECK [8],
we do not check the arithmetic operations on heap pointer,
free(p+y)is simply treated as free(p).
Figure 7 illustrates the overview of our tool S MOKE .
SMOKE has four phases: Pre-Analyses, UFG Construction,
State Analysis and Path-Sensitive V eriÔ¨Åcation. Here we only
discuss the details of the Pre-Analyses phase since other three
phases have already been discussed in Section III.
In the pre-analyses phase, we conduct several analyses
to compute the necessary information for later phases. We
Ô¨Årst use a Ô¨Çow-sensitive and context-sensitive pointer analysis
similar to the one used in P INPOINT [18] to compute the
data dependence. Control dependence is computed on demand,
since not all functions in a program are related to memory leak
detection. We construct the control dependence by computing
the dominance frontier in the reverse graph of the control Ô¨Çow
graph [21]. To construct the call graph, we use the must-alias
results from the pointer analysis to resolve function pointers,
and adopt a class hierarchy analysis [25] to resolve virtual
function calls.
During the state analysis, we only consider the case when
the memory allocation operation is successful. For instance, if
a heap object is created in x=malloc(), we do not consider
the case when the test x==NULL is true. We use a light-
weight data-Ô¨Çow analysis to identify and ignore UFG edges
on which heap memories have not been successfully allocated.
V. E V ALUA TION
We evaluate the precision, the recall and the scalability of
SMOKE by comparing four well-known static analysis tools
76
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:58:45 UTC from IEEE Xplore.  Restrictions apply. Pointer 
Analysis
UFG ConstructionState 
AnalysisPath-Sensitive 
Verification
Control Flow 
AnalysisData 
Dependence
Control 
DependenceMemory 
Leak
FSMLeak Path
CandidatesMemory
Leaks
Solver Function SummaryUFGChecker
Specification
Program IR Analysis Report Joint
Path ConditionsSAT/UNSATQuery
Fig. 7. System overview of S MOKE
that have memory leak detectors, from both academia and
industry. We compare to both S ABER [9] and P INPOINT [18],
since they are the state-of-the-art SVFA based approaches with
the precision of Ô¨Çow-sensitivity and path-sensitivity, respec-
tively. We also choose CSA [1] and I NFER [2], two prominent
and mature open-source tools from the industry. We plan to
evaluate other memory leak detection tools, such as S A TURN
[3] and C ALYSTO [26]. However, they are either publicly
unavailable or outdated for running in the environments we are
able to set up. To demonstrate the usefulness of our approach,
we also seek conÔ¨Årmations from original developers of the
subjects we use.
For each baseline, we only enable the memory leak detector,
since some tools may have other bug detectors. We set the
timeout to 2 hours, and conÔ¨Ågure each tool with its default
settings. All the experiments are performed on a moderate
computer running Ubuntu-16.04 with an Intel Core i5-6500
quad-core processor, and 64GB physical memory.
A. Subjects for Evaluation
We evaluate S MOKE ,SABER ,PINPOINT , CSA and I NFER
using twenty-nine subjects, including the twelve benchmark
programs from standard SPEC CINT2000 [27], a commonly
used benchmark in the existing literature [9], and seventeen
well tested open-source projects. Table II shows the basic
information of the evaluation subjects. The size of these
subjects ranges from a few thousand of lines of code to nearly
eight million of lines of code. These projects are widely used
and well tested before release. Some of them are regularly
scanned by free or commercial static tools such as C OVERITY
SA VE *and, thus, expected to have high code quality. We
divide the subjects into two categories: medium-sized projects
(including all SPEC CINT2000 programs and the projects with
code size less than 1MLoC) and large-sized projects with code
size larger than 1MLoC.
*https://scan.coverity.com/projects/B. Scalability
To evaluate the scalability of each tool, we Ô¨Årst check
whether it can successfully analyze the selected subjects under
our experimental environment (which is a typical desktop
computer rather than a powerful cluster) and within the time
budget (2 hours). As shown in Table II, S MOKE successfully
analyzes all twenty-nine projects in forty minutes, while others
fail to analyze some of the projects due to either crash (out-
of-memory or segmentation faults) or timeout. For example,
SABER , having the lowest success rate, fails on nine projects,
including two medium-sized and seven large-sized projects.
PINPOINT and CSA achieve the second-best success rate, but
still fail on four projects, which are mostly large-sized projects.
We further compare the time cost of analysis of all the
tools shown in Table II. On average, S MOKE achieves the
highest efÔ¨Åciency and is signiÔ¨Åcantly ( >5.2X faster than
SABER ,>13.0X faster than P INPOINT ,>12.4X faster than
CSA,>22.8X faster than I NFER ) faster than other tools.
SMOKE performs better than S ABER and P INPOINT in all
subjects. Compared to CSA and I NFER ,SMOKE also performs
better on all the subjects, except one medium-sized project,
253.perlbmk .
Overall, the evaluation results show that, compared to other
tools, S MOKE achieves the highest scalability and scales to
millions of lines of code without requiring too much compu-
tation resource (using a desktop computer).
C. Precision
Following the common practice in the literature on memory
leak detection [8], [9], we manually check each error report
provided by all the tools, and then compare their false positive
rate ( FP rate for short) to evaluate the precision. This process
may be subjective and introduce threats to the validity of the
FP results. Therefore, we ask three software engineers to cross-
validate the results and, meanwhile, seek conÔ¨Årmations from
the developers of the subjects. In addition, we release the
reports and data for inspection.‚Ä†
‚Ä†https://smokeml.github.io/data
77
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:58:45 UTC from IEEE Xplore.  Restrictions apply. TABLE II
ANALYSIS TIME COMPARISON
9351+
:OSKYKI :OSKYKI 9VKKJ;V :OSKYKI 9VKKJ;V :OSKYKI 9VKKJ;V :OSKYKI 9VKKJ;V
M`OV       >  >  >  >
\VX       >  >  >  >
MII       >  >  > )XGYN 4'
SIL       >  >  >  >
IXGLZ_       >  >  >  >
VGXYKX       >  >  >  >
KUT       >  >  >  >
VKXRHSQ       >  >  >  >
MGV       >  >  >  >
\UXZK^       >  >  >  >
H`OV       >  >  >  >
Z]URL       >  >  >  >
(LZVJ       >  >  >  >
.ZUV       >  >  >  >
3KSIGINKJ       >  >  >  >
)GLLK       >  > )XGYN 4'  >
2'3+      55: $>  >  >  >
@ROH       >  >  >  >
:S[^       >  >  >  >
'VGINKNZZVJ       >  >  >  >
5VKT992      55: $>  >  >  >
,,SVKM      55: $>  >  >  >
-UJUZ+TMOTK      55: $> 55: $>  > 55: $>
3_972      55: $>  >  >  >
)NXUSK<      55: $> 55: $> 55: $> 55: $>
9QOG      55: $>  >  > 55: $>
(RKTJKX      55: $> 553 $>  > 55: $>
=OTK        >  > )XGYN 4' 55: $>
,OXKLU^      55: $> 553 $> 55: $> 55: $>
9[S     $ > $> $> $> -KUSKZXOI3KGT 9GHKX 6/465/4: )9' /TLKX 925)
Q2U)	'RRUIGZOUTY
9OZKY	,XKK
9OZKY	,[TIY
$32U)
5VKT
9U[XIK
6XUPKIZY96+)
)/4:6XUPKIZ 5XOMOT
"32U)
5VKT
9U[XIK
6XUPKIZY
55: U[ZULZOSK 553 U[ZULSKSUX _ 4' TUZG\GORGHR K
Table III shows the comparison results. On average, S MOKE
achieves an FP rate of 24.4%, which is the lowest one among
all the tools. As discussed in Section V-B, not all the subjects
can be successfully analyzed by all the tools. And the number
of false positives in the failure cases (e.g., S ABER fails in the
project L AME ) is counted as 0. For the medium-sized subject,
the small number of failure cases (only 2 by S ABER ,1b y
CSA and I NFER ) allows a fair comparison of all the tools,
where S MOKE outperforms all other tools with a lowest FP
rate of 15.0%. The second best tool, P INPOINT , achieves a
much higher FP rate of 41.7%. I NFER performs the worst,
with an FP rate of 87.5%. For the large-sized subjects, we
also observe S MOKE achieves the lowest FP rate, which is
consistent with the results in medium-sized subjects.
We further investigate why S MOKE can achieve the lowest
FP rate. S ABER does not capture the path correlation. There-
fore, it cannot Ô¨Ålter out cases with infeasible paths. Since
PINPOINT and CSA achieve the precision of path-sensitivity,
they report the smallest number of false positives. However,
they report much fewer true positive instances, incurring the
higher FP rate. I NFER has the highest FP rate. A manualcheck reveals that I NFER generates a speciÔ¨Åcation for each
analyzed function, and discards some of these speciÔ¨Åcations
for unknown reasons. The omitted speciÔ¨Åcations produce
imprecision in the whole program analysis. For example, a
typical false positive case happens when the speciÔ¨Åcation for
a wrapper function of free (i.e., a library function to free heap
object) is discarded.
D. Recall
From the results in Table III, we observe that S MOKE
reports more memory leaks than other tools. S MOKE reports
158 real memory leaks while the other four tools report only
48 real memory leaks in total.
SABER and P INPOINT make signiÔ¨Åcant precision trade-
offs to achieve efÔ¨Åciency. For instance, they limit the calling
depth for inter-procedural analysis and only report memory
leaks with six levels of function calls. They also stop analysis
whenever they Ô¨Ånd that a heap object is assigned to a global
variable on a path, even when the heap object obviously leaks
on another path. For example, Figure 8 shows a leak found
by S MOKE : A heap object allocated in get dll name Ô¨Çows to
dll name . It leaks when taking the true branch at line 207.
78
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:58:45 UTC from IEEE Xplore.  Restrictions apply. TABLE III
MEMORY LEAK RESULTS
9351+ 9GHKX 6/465/4: )9' /TLKX
	,6	8KV 	,6	8KV 	,6	8KV 	,6	8KV 	,6	8KV
M`OV     
\VX     
MII     4'
SIL     
IXGLZ_     
VGXYKX     
KUT     
VKXRHSQ     
MGV     
\UXZK^     
H`OV     
Z]URL     
(LZVJ     
.ZUV     
3KSIGINKJ     
)GLLK    4' 
2'3+  4'   
@ROH     
:S[^     
'VGINKNZZVJ     
5VKT992  4'   
:UZGR     
"32UI ,68GZK     
,,SVKM  4'   
-UJUZ  4'   4'
3_972  4'   
)NXUSK<  4' 4' 4' 4'
9QOG  4'   4'
(RKTJKX  4' 4'  4'
=OTK    4' 4'
,OXKLU^  4' 4' 4' 4'
:UZGR     
$32U) ,68GZK     
'RR ,68GZK     $32U)
5VKT
9U[XIK
6XUPKIZY96+)
)/4:5XOMOT 6XUPKIZ
"32U)
5VKT
9U[XIK
6XUPKIZY
SABER and P INPOINT cannot Ô¨Ånd this leak since it can Ô¨Çow
to a global variable ( dll delayed ordll imports ) when taking
the false branch at line 207.
CSA does not analyze function calls across different Ô¨Åles.
INFER can only handle a small number of function calls across
different Ô¨Åles. However, we observe that it is very common
that a memory leak relates to functions from different Ô¨Åles. As
a result, CSA and I NFER miss many real memory leaks. For
example, Figure 9 shows a memory leak in Bftpd reported by
SMOKE but not by CSA or I NFER . A heap object allocated
in a source Ô¨Åle cmd.c leaks in another Ô¨Åle commands.c .
E. Contribution of the Analysis Stages
To better understand the effectiveness and the efÔ¨Åciency of
the staged analysis, we report the number of pruned candidates
and the time cost of each stage in Table IV. Note that, since
it is difÔ¨Åcult to calculate the total number of the candidate
paths starting from each allocation sites (e.g., path explosion
due to loops), we estimate the lower bound of the total
number of candidates using the number of allocation sites.Location: import.c:277
195./* add a dll to the list of imports */
196.voidadd_import_dll( const char *name, const char *filename )
197. {
198. DLLSPEC *spec;
199. char*dll_name = get_dll_name( name, filename );
200. structimport*imp = xmalloc( sizeof(*imp) );
201.
202. memset( imp, 0, sizeof(*imp) );
203.
204. if(filename) imp-> full_name = xstrdup( filename );
205. elseimp->full_name = find_library( name );
206.
207. if(!(spec = read_import_lib( imp )))
208. {
209. free_imports( imp );
210. return;
211. }
212.
213. imp-> dll_name = spec->file_name ? spec->file_name : dll_name;
214. imp-> c_name= make_c_identifier( imp-> dll_name );
215.
216. if(is_delayed_import( dll_name ))
217. list_add_tail( &dll_delayed, &imp-> entry);
218. else
219. list_add_tail( &dll_imports, &imp-> entry);
220. }A memory is allocated and  assigned to dll_name
Take the true 
branch at line 207
dll_name is leaked
Fig. 8. A memory leak in Wine
99. appendpath(result, path2);
100. free(path2);
101. returnresult;
102. }69.char*bftpd_cwd_mappath( char*path)
70. {
71. char*result = malloc(‚Ä¶);
72. char*path2;
73. char*tmp;
74. if(! result)
75. returnNULL;
76. path2 = strdup(path);
77. if(! path2)Location:cmd.c:71
Location:commands.c:1522
1543. free(philename);
1544. free(mapped);
1545. philename = NULL;
1546.} 1516.voidcommand_rnto( char*newname)
1517. {
1518. char*mapped = bftpd_cwd_mappath (newname);
1519. if( (! mapped) || (! philename) )
1520. {
1521. control_printf(SL_FAILURE, "451 Error: 
Unable to rename file." );
1522. return;
1523. }
Fig. 9. A memory leak in Bftpd
In the Ô¨Årst stage, S MOKE prunes 98.6% ( 1‚àí610/43,282)o f
the candidates, leaving twenty-one paths on average for each
subject to be checked further. In the second stage, S MOKE
further prunes 65.7% ( 1‚àí209/610 ) of the candidates by
detecting infeasible paths. The above results indicate that both
79
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:58:45 UTC from IEEE Xplore.  Restrictions apply. TABLE IV
STA TISTICS OF TWO ANALYSIS STAGES
	6GZNY:OSK
YKI:UZGR
:OSK	6GZNY:OSK
YKI:UZGR
:OSK
M`OV       
\VX       
MII       
SIL       
IXGLZ_       
VGXYKX       
KUT       
VKXRHSQ       
MGV       
\UXZK^       
H`OV       
Z]URL       
(LZVJ       
.ZUV       
3KSIGINKJ       
)GLLK       
2'3+       
@ROH       
:S[^       
'VGINKNZZVJ       
5VKT992       
,,SVKM       
-UJUZ+TMOTK       
3_972       
)NXUSK<       
9QOG       
(RKTJKX       
=OTK       
,OXKLU^        
:UZGR   
'\KXGMK    YZ9ZGMK TJ9ZGMK	+YZOSGZKJ
6GZNY6XUPKIZ
of the stages are effective in improving the precision.
Table IV shows the time cost of the two stages. S MOKE
spends 94.6% of the time in the Ô¨Årst phase and only 5.4% in
the second phase. The two-staged design signiÔ¨Åcantly reduces
the cost for the path-sensitive analysis and, thus, achieves high
efÔ¨Åciency.
F . Detected Real Memory Leaks
To better understand the usefulness of S MOKE in practice,
we seek conÔ¨Årmations from the original developers of the
subjects. Since we can not Ô¨Çood them with all warnings,
we manually pre-screen the bug reports and choose only the
ones that are likely to have severe impacts. The majority
of the reports are for large and well-maintained projects
such as FFmpeg, Wine, Firefox, MySQL, Godot Engine
and Chrome V8 . All thirty reports get conÔ¨Årmed by their
developers and result in many patches and bug Ô¨Åxes. This
result conÔ¨Årms the usefulness of our approach because those
projects are regularly scanned by free and commercial tools,
and S MOKE only takes 3 ‚àº40 minutes to analyze each project.
We release the conÔ¨Årmed memory leaks online‚Ä°.
Due to the high scalability of S MOKE , we can detect
the inter-procedural memory leaks in large projects without
consuming too much computing resources. Figure 10 shows
‚Ä°https://smokeml.github.io/listLocation: dom /media/encoder/VP8TrackEncoder.cpp:254
249. nsresult
250. VP8TrackEncoder:: GetEncodedPartitions(‚Ä¶)
251. {
252. vpx_codec_iter_t iter = nullptr;
253. EncodedFrame::FrameType frameType = 
EncodedFrame::VP8_P_FRAME;
254. nsTArray<uint8_t> frameData;
277.if(!frameData.IsEmpty()) {
278. // Copy the encoded data to aData.
279. EncodedFrame * videoData = newEncodedFrame();
280. videoData->SetFrameType(frameType);
281.
282. // Convert the timestamp and duration to Usecs.
283. CheckedInt64 timestamp = ‚Ä¶;
284. if(!timestamp.isValid()) {
285. NS_ERROR( "Microsecond timestamp overflow" );
286. returnNS_ERROR_DOM_MEDIA_OVERFLOW_ERR;
287. }
288. videoData->SetTimeStamp(‚Ä¶);
289.to aDatA memory is allocated and  
assigned to videoData
{Take the true 
branch at line 284
videoData is leaked.
Fig. 10. A memory leak in Firefox
Location:SparseLU.h:445
429. constIndex * outerIndexPtr;
430. if(isCompressed()) 
431. outerIndexPtr = newIndex[mat.cols() + 1];
432. else
433. outerIndexPtr = mat.outerIndexPtr();
434.
435. for(Index i = 0; i < mat.cols(); i++) {
436. m_mat.outerIndexPtr()[‚Ä¶] = outerIndexPtr[i];
437. m_mat.innerNonZeroPtr()[‚Ä¶] = outerIndexPtr[i + 1]  
- outerIndexPtr[i];
438. }
439. if(isCompressed()){ 
440. delete[] outerIndexPtr;
441. }
Fig. 11. A false positive report in Blender
a memory leak conÔ¨Årmed by the developers of Firefox ,
a project of approximately eight million lines of code. In
this example, the memory space pointed-to by videoData is
allocated at Line 279 and leaks on an early return at Line 286
when timestamp.isV alid() returns false . This case is not very
complicated. However, because of the complexity in the code
and the enormous project size, this memory leak has been
hidden for more than one year. Figure 9 shows a memory
leak that S MOKE found in Bftpd , a lightweight, Ô¨Çexible FTP
server widely used in desktops, servers, embedded devices,
and media centers. This vulnerability has been in the code
since 2005. It has survived for more than twelve years and has
impacted eighty-six versions altogether. We report this leak to
its developers and receive a conÔ¨Årmation and an appreciation
acknowledgment on its homepage.¬ßA remote attacker can
utilize this leak to launch denial-of-service attacks to the users
ofBftpd . Due to its high severity, a CVE ID (CVE-2017-
16892) is assigned.
80
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:58:45 UTC from IEEE Xplore.  Restrictions apply. G. Limitations
Our approach can be imprecise for several reasons. One
reason is the lack of library speciÔ¨Åcations. Figure 11 shows
a leak-free example simpliÔ¨Åed from a false positive report
in Blender. At Line 431, the program allocates an array
and stores it to the memory pointed-to by outerIndexPtr ,
under the condition that isCompressed() returns true. At Line
440, the program ‚Äúdeletes‚Äù outerIndexPtr when another call
toisCompressed() returns true at Line 439. The function
isCompressed() is implemented in a library, and it returns the
same boolean value at both places. Hence, the two branches
are correlated. Unfortunately, we cannot statically determine
this branch correlation since we do not have the speciÔ¨Åcation
of the library function. One way to mitigate this problem is to
manually or automatically provide speciÔ¨Åcations for libraries
when detecting infeasible paths.
Another reason is that we inherit the imprecision from the
lower-level program analyses such as the pointer analysis. The
pointer analysis may mistakenly identify two different heap
objects as aliases. Operations on one object of the alias pair
may cause state changes of another, which could result in
mutual interference and incorrect results.
There are still some types of infeasible paths that cannot
be identiÔ¨Åed by our approach. Such paths usually involve
complex arithmetic in branch conditions, complicate data
dependence or deep inter-procedural effects. Including more
control and data dependence in the path constraints can help
to mitigate this limitation, at the price of being less efÔ¨Åcient.
VI. R ELA TED WORK
In this section, we survey the related approaches in two
categories.
A. Static Memory Leak Detection
SA TURN [3] reduces the memory leak detection problem
to a boolean satisÔ¨Åability problem and uses a SA T-solver
to Ô¨Ånd memory leaks. Facebook I NFER [2] is based on bi-
abductive inference of separation logic that extends the Hoare
Logic by explicitly modeling the heap. C LOUSEAU [4], [5]
detects memory leaks based on a practical ownership model
of memory management. Orlovich and Rugina [6] proposed a
leak detection algorithm based on a reverse data-Ô¨Çow analysis
that assumes the presence of the leak Ô¨Årst, followed by a
pruning method. S PARROW [7] detects memory leaks in C
programs based on abstract interpretation. Tools based on
symbolic execution such as the CSA [1], C OVERITY SA VE
[28], and K LEE [29] are promising in practice. By treating
all external inputs as symbols and execute the program on
symbols, symbolic execution tools can explore program states
that are hard to reach for concrete executions. However,
symbolic execution tools do not scale to large programs due to
the path explosion problem and intensive uses of the constraint
solver. All of the above techniques are not sparse, which
¬ßhttp://bftpd.sourceforge.net/news.htmlanalyze a lot of irrelevant program statements and, thus, suffer
from performance issues.
FASTCHECK [8], S ABER [9], and P INPOINT [18] are mostly
related to our approach. They work on a sparse value Ô¨Çow
graph with guards annotated on the graph edges. As we
have discussed in this paper, when high precision is required,
VFG-based model of the memory leak problem [8], [9] is
the reason for the analysis to be not scalable. To achieve
scalability, F ASTCHECK and S ABER have to compromise the
path-sensitivity, leading to many false warnings. P INPOINT
improves the sparse value-Ô¨Çow analysis by building precise
data dependence in an efÔ¨Åcient manner, but it does not provide
a better model for memory leak detection. In comparison,
we propose a FSM-based model that enables us to efÔ¨Åciently
detect memory leaks on UFG.
B. Dynamic Memory Leak Detection
Dynamic approaches [24], [30]‚Äì[36] detect memory leaks
by instrumenting and running a program. Some dynamic
approaches operate at the binary level, such as the memcheck
tool of V ALGRIND [31], D R.M EMORY [30] and P URIFY [33].
These approaches track memory allocation and deallocation
during a program‚Äôs execution, and detect leaks by scanning the
program‚Äôs heap for memory blocks that no pointer points to.
INSURE ++ [36] and A DDRESS SANITIZER [35] detect memory
leaks by inserting extra statements to the source code before
compiling the binary.
Unlike static approaches that have relatively high false
positive rate due to the abstraction of concrete program states,
dynamic approaches have few false positives because they
have access to the concrete program states at runtime. How-
ever, dynamic approaches can miss many real bugs because
they cannot cover all possible program behaviors with limited
number of test cases. Also, dynamic approaches are hard to be
applied in a production run, because running the instrumented
program usually causes unbearable runtime overhead.
VII. C ONCLUSION
We have presented an approach to static memory leak
detection, which runs in a fast, scalable, and precise manner.
The key factor to make our technique fast is a staged analysis,
in which we Ô¨Årst efÔ¨Åciently Ô¨Ålter safe cases based on our new
program representation, i.e., use-Ô¨Çow graph, and then employ
a constraint solver to verify path feasibility only for a handful
of leak candidates. We implemented our technique as a tool,
called S MOKE , and evaluated it systematically. The evaluation
results demonstrate that S MOKE is promising as an industrial-
strength static memory-leak detector.
ACKNOWLEDGMENT
We thank the anonymous reviewers for their insight-
ful comments and Dr. Y ulei Sui for his help on the
SABER implementation. This work was partially funded by
Hong Kong GRF16214515, GRF16230716, GRF16206517,
NSFC61628205 and ITS/215/16FP grants.
81
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:58:45 UTC from IEEE Xplore.  Restrictions apply. REFERENCES
[1] The LLVM Foundation, ‚ÄúClang static analyzer,‚Äù https://clang-
analyzer.llvm.org/, 2018.
[2] Facebook, Inc., ‚ÄúInfer,‚Äù 2018. [Online]. Available: http://fbinfer.com/
[3] Y . Xie and A. Aiken, ‚ÄúContext-and path-sensitive memory leak detec-
tion,‚Äù in ACM SIGSOFT Software Engineering Notes , vol. 30, no. 5.
ACM, 2005, pp. 115‚Äì125.
[4] D. L. Heine and M. S. Lam, ‚ÄúStatic detection of leaks in polymorphic
containers,‚Äù Proceeding of the 28th international conference on Software
engineering - ICSE ‚Äô06 , p. 252, 2006.
[5] ‚Äî‚Äî, ‚ÄúA practical Ô¨Çow-sensitive and context-sensitive C and C++
memory leak detector,‚Äù ACM SIGPLAN Notices , vol. 38, no. 5, p. 168,
2003.
[6] M. Orlovich and R. Rugina, ‚ÄúMemory Leak Analysis by Contradiction,‚Äù
Proceedings of International Static Analysis Symposium SAS06 , 2006.
[7] Y . Jung, ‚ÄúPractical Memory Leak Detector Based on Parameterized Pro-
cedural Summaries,‚Äù in Proceedings of the 7th International Symposium
on Memory Management , 2008.
[8] S. Cherem, L. Princehouse, and R. Rugina, ‚ÄúPractical memory leak
detection using guarded value-Ô¨Çow analysis,‚Äù in Proceedings of the
28th ACM SIGPLAN Conference on Programming Language Design
and Implementation , ser. PLDI ‚Äô07. New Y ork, NY , USA: ACM,
2007, pp. 480‚Äì491. [Online]. Available: http://doi.acm.org.lib.ezproxy.
ust.hk/10.1145/1250734.1250789
[9] Y . Sui, D. Ye, and J. Xue, ‚ÄúDetecting memory leaks statically with
full-sparse value-Ô¨Çow analysis,‚Äù IEEE Transactions on Software Engi-
neering , vol. 40, no. 2, pp. 107‚Äì122, Feb 2014.
[10] Mozilla, ‚ÄúMozilla bugzilla,‚Äù 2018. [Online]. Available: https://bugzilla.
mozilla.org/buglist.cgi?quicksearch=memory+leak
[11] Google, ‚ÄúChromium bugs,‚Äù 2018. [Online]. Available: https://bugs.
chromium.org/p/chromium/issues/list?can=1&q=memory+leak
[12] ‚ÄúCVE List,‚Äù 2018. [Online]. Available: https://cve.mitre.org/cgi-bin/
cvekey.cgi?keyword=memory+leak
[13] S. Zacchiroli, ‚ÄúThe debsources dataset: Two decades of debian source
code metadata,‚Äù in IEEE International Working Conference on Mining
Software Repositories , 2015.
[14] S. McPeak, C.-H. Gros, and M. K. Ramanathan, ‚ÄúScalable and incremen-
tal software bug detection,‚Äù Proceedings of the 2013 9th Joint Meeting
on F oundations of Software Engineering - ESEC/FSE 2013 , 2013.
[15] A. Bessey, D. Engler, K. Block, B. Chelf, A. Chou, B. Fulton, S. Hallem,
C. Henri-Gros, A. Kamsky, and S. McPeak, ‚ÄúA few billion lines of code
later,‚Äù Communications of the ACM , vol. 53, no. 2, pp. 66‚Äì75, Feb 2010.
[16] B. Steffen, B. Steffen, J. Knoop, and O. R ¬®uthing, ‚ÄúThe value Ô¨Çow graph:
A program representation for optimal program transformations,‚Äù PRO-
CEEDINGS OF THE EUROPEAN SYMPOSIUM ON PROGRAMMING,
PAGES 389‚Äì405. SPRINGER-VERLAG LNCS 432 , vol. 432, pp. 389‚Äì
405, 1990.
[17] S. A. Cook, ‚ÄúThe complexity of theorem-proving procedures,‚Äù in Pro-
ceedings of the Third Annual ACM Symposium on Theory of Computing ,
ser. STOC ‚Äô71. New Y ork, NY , USA: ACM, 1971, pp. 151‚Äì158.[18] Q. Shi, X. Xiao, R. Wu, J. Zhou, G. Fan, and C. Zhang, ‚ÄúPinpoint:
Fast and precise sparse value Ô¨Çow analysis for million lines of code,‚Äù in
Proceedings of the ACM SIGPLAN 2018 Conference on Programming
Language Design and Implementation , ser. PLDI ‚Äô18. Philadelphia,
PA, USA: ACM, 2018.
[19] E. Dantsin, A. Goerdt, E. A. Hirsch, R. Kannan, J. Kleinberg,
C. Papadimitriou, P . Raghavan, and U. Sch ¬®oning, ‚ÄúA deterministic
(2-2/(k+1))n algorithm for k-sat based on local search,‚Äù Theoretical
Computer Science , vol. 289, no. 1, pp. 69 ‚Äì 83, 2002.
[20] N. Bjorner and L. de Moura, ‚ÄúZ3: An efÔ¨Åcient SMT solver,‚Äù Available
from:http://research.microsoft.com/projects/Z3 , 2007.
[21] R. Cytron, J. Ferrante, B. K. Rosen, M. N. Wegman, and F. K. Zadeck,
‚ÄúEfÔ¨Åciently computing static single assignment form and the control
dependence graph,‚Äù 1991.
[22] T. Reps, S. Horwitz, and M. Sagiv, ‚ÄúPrecise interprocedural dataÔ¨Çow
analysis via graph reachability,‚Äù in Proceedings of the 22Nd ACM
SIGPLAN-SIGACT Symposium on Principles of Programming Lan-
guages , ser. POPL ‚Äô95. New Y ork, NY , USA: ACM, 1995, pp. 49‚Äì61.
[23] C. Lattner and V . Adve, ‚ÄúLlvm: A compilation framework for lifelong
program analysis & transformation,‚Äù in Proceedings of the international
symposium on Code generation and optimization: feedback-directed and
runtime optimization . IEEE Computer Society, 2004, p. 75.
[24] C. Jung, S. Lee, E. Raman, and S. Pande, ‚ÄúAutomated memory leak
detection for production use,‚Äù Proceedings of the 36th International
Conference on Software Engineering , no. undeÔ¨Åned, pp. 825‚Äì836, 2014.
[25] J. Dean, D. Grove, and C. Chambers, ‚ÄúOptimization of Object-Oriented
Programs Using Static Class Hierarchy Analysis,‚Äù in ECOOP‚Äô95 , 1995.
[26] R. DeLine and M. F ¬®ahndrich, Typestates for Objects . Berlin, Heidel-
berg: Springer Berlin Heidelberg, 2004, pp. 465‚Äì490.
[27] J. L. Henning, ‚ÄúSPEC CPU2000: Measuring CPU performance in the
new millennium,‚Äù Computer , 2000.
[28] ‚ÄúCoverity scan,‚Äù https://scan.coverity.com/projects/, 2018.
[29] C. Cadar, D. Dunbar, and D. R. Engler, ‚ÄúKLEE: Unassisted and
Automatic Generation of High-Coverage Tests for Complex Systems
Programs,‚Äù Proceedings of the 8th USENIX conference on Operating
systems design and implementation , 2008.
[30] D. Bruening and Q. Zhao, ‚ÄúPractical memory checking with dr. mem-
ory,‚Äù in Proceedings of the 9th Annual IEEE/ACM International Sympo-
sium on Code Generation and Optimization , ser. CGO ‚Äô11. Washington,
DC, USA: IEEE Computer Society, 2011, pp. 213‚Äì223.
[31] N. Nethercote and J. Seward, ‚ÄúV algrind: A framework for heavyweight
dynamic binary instrumentation,‚Äù 2007.
[32] J. Clause and A. Orso, ‚ÄúLeakpoint: pinpointing the causes of memory
leaks,‚Äù in Proceedings of the 32nd ACM/IEEE International Conference
on Software Engineering-V olume 1 . ACM, 2010, pp. 515‚Äì524.
[33] R. Hastings and B. Joyce, ‚ÄúPurify: Fast Detection of Memory Leaks
and Access Errors,‚Äù in Proceedings of the Usenix Winter 1992 Technical
Conference , 1991.
[34] M. Hauswirth and T. M. Chilimbi, ‚ÄúLow-overhead memory leak de-
tection using adaptive statistical proÔ¨Åling,‚Äù ACM SIGOPS Operating
Systems Review , 2004.
[35] K. Serebryany and D. Bruening, ‚ÄúAddressSanitizer: a fast address sanity
checker,‚Äù ATC , 2012.
[36] ‚ÄúInsure++,‚Äù 2018. [Online]. Available: http://www.parasoft.com/
products/insure
82
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:58:45 UTC from IEEE Xplore.  Restrictions apply. 