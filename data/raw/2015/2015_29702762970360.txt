Automatic Runtime Recovery via Error Handler Synthesis
Tianxiao Gu§Chengnian Sun*Xiaoxing Ma§Jian Lü§Zhendong Su*
§Department of Computer Science and Technology, Nanjing University, China
*Department of Computer Science, University of California, Davis, USA
tianxiao.gu@gmail.com, cnsun@ucdavis.edu, xxm@nju.edu.cn, lj@nju.edu.cn, su@cs.ucdavis.edu
ABSTRACT
Software systems are often subject to unexpected runtime
errors. Automatic runtime recovery (ARR) techniques aim
to recover them from erroneous states and maintain them
functional in the ﬁeld.
This paper proposes Ares, a novel, practical approach for
ARR. Our key insight is leveraging a system’s inherent error
handling support to recover from unexpected errors. To
this end, we synthesize error handlers in two ways: error
transformation andearly return . We also equip Areswith a
lightweight in-vivo testing infrastructure to select the promis-
ing synthesis method and avoid potentially dangerous error
handlers. Unlike existing ARR techniques with heavyweight
mechanisms ( e.g., checkpoint-restart and runtime monitor-
ing), our approach expands the intrinsic capability of runtime
error resilience in software systems to handle unexpected
errors. Ares’s lightweight mechanism makes it practical and
easy to be integrated into production environments.
Wehaveimplemented AresontopofboththeJavaHotSpot
VM and Android ART, and applied it to recover from 52 real-
world bugs. The results are promising — Aressuccessfully
recovers from 39 of them and incurs negligible overhead.
CCS Concepts
•Software and its engineering →Error handling and
recovery;
Keywords
automatic runtime recovery, JVM, exception handling
1. INTRODUCTION
Deployed software systems are subject to runtime errors.
Some of these errors can be anticipated and recovered by
programmatically prepared error handlers. For example,
reading a non-existing ﬁle is invalid and the programmer
needs to explicitly tackle this case by following the usagedescription of certain APIs. The other errors refer to unan-
ticipated errors that are usually related to bugs in programs
(e.g., divide-by-zero, invalid memory access). Ideally these
errors (or bugs) should all be eliminated before release, but
in reality some slip through the software testing phase and
manifest after release and deployment. Diﬀerent from antici-
pated errors, handlers usually do not exist for unanticipated
errors. Thus, when triggered, they may lead to system fail-
ures and incur expensive losses, including security exploits,
data corruptions and system unavailability.
Automatic Runtime Recovery Tomitigatethisproblem,
a number of techniques [12, 25, 24, 22, 7, 27, 8, 18] have been
proposed to make a deployed software system resilient to
runtime errors. That is, once an unanticipated runtime error
occurs in the ﬁeld, these techniques try to recover the system
from the faulty state to a good one in which the system can
still function for subsequent usage. This process is usually
referred to as automatic runtime recovery (ARR).
ARR techniques typically consist of two stages: amend-
ing runtime states to recover from an unanticipated error,
and validating the correctness or feasibility of the recovery
action. Generally, they can be categorized into two classes:
heavyweight and lightweight. The former class relies on
heavyweight mechanisms — e.g., checkpoint creation and
restoration, online validation by restart or re-execution, ex-
pensive instrumentation — to validate the recovery. For
example, ARMOR [8] dynamically replaces a piece of prob-
lematic code snippet with another equivalent code snippet
(provided by developers) and uses checkpoint to rule out
invalid recovery solutions. Although in this class various
recovery techniques [24, 13, 28, 20, 8] have been proposed,
the signiﬁcant runtime overhead is still a major challenge for
heavyweight approaches to be practical.
Lightweight approaches [25, 18] are usually more eﬃcient,
but may be less eﬀective than heavyweight approaches due
to their aggressive nature and insuﬃcient validation of a
recovery. For example, FOC [25] simply discards any invalid
memory write and synthesizes a type-speciﬁc default value
for invalid memory read for server applications. Recently, a
novellightweightapproach, RCV[18], hasbeendemonstrated
to be eﬀective to some extent in practice. However, RCV has
no proactive validation but passive error containment. As the
errorcontainmentonlytakesaccountofpartsofthedataﬂow,
persistent data may also be ruined by manufactured recovery
indirectly. Besides, the control ﬂow may be impacted by the
error and leads to inﬁnite recurrences of erroneous states.
AresIn this paper, we propose a lightweight approach
(referred to as Ares) for runtime error recovery. At the high
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciﬁc permission and/or a
fee. Request permissions from Permissions@acm.org.
ASE’16 , September 3–7, 2016, Singapore, Singapore
c2016 ACM. 978-1-4503-3845-5/16/09...$15.00
http://dx.doi.org/10.1145/2970276.2970360
684
level, our approach expands the intrinsic capability of run-
time error resilience existing in software systems to handle
unanticipated errors. Aresis lightweight, barely incurring
any overhead on normal program executions. Furthermore,
instead of relying on heuristics to generate a singlerecov-
ery action [25, 18], Aressynthesizes multiple error handler
candidates at a time and uses a virtual testing technique to
select the most promising one. Arescan successfully avoid
inﬁnite recurrences of erroneous states due to its adaptive
and context-sensitive nature.
Concretely, once an unanticipated error occurs, we ana-
lyze the current call stack, and synthesize a set of recovery
solutions (by collecting error handlers residing on the stack
or synthesizing new error handlers). Next we determine
which handler is the most viable in terms of minimizing
the negative impact on the subsequent computation. We
perform an in-vivo testing to analyze the impact of every
handler. That is, we continue the execution by interpreting
the buggy program after applying each recovery solution in
a conﬁned virtual execution environment ( viz., a sandbox).
Note that this in-vivo testing is invoked in an on-demand
manner only if an unanticipated error occurs, so it will not
impact the performance of normal program executions. Fi-
nally, we choose the most promising recovery solution, apply
it to and continue the host execution.
In this paper, we use the following two lightweight strate-
gies to synthesize error handlers:
Error Transformation transforms an unanticipated error
to an error of another type which has a proper handler
on the method call stack.
Early Return simply ignores the unanticipated error and
returns to the caller with a default value, i.e.,nullfor
reference types.
We have realized the proposed technique on top of Java
HotSpot VM in OpenJDK.1We embed Java PathFinder
(JPF) into HotSpot VM and use it as the virtual execution
environment for in-vivo testing. The system is evaluated on
43 bugs in large real-world programs, and can successfully
recover from 31 of them.
We have also implemented a mobile version of Areson
top of Android ART.2It can successfully recover from 8 out
of 9 real Android app bugs, avoiding crashing these apps.
Compared to regular Java programs, recovering from these
app bugs is equally important. A survey [2] on mobile apps
shows that 79% of mobile users would not use a mobile app
any more if it is unable to work at the ﬁrst or second time.
In order to ensure reproducibility, we have made all the
data used in this paper ( i.e., source code of Aresand the
program subjects for evaluation) publicly available at http:
//lab.artemisprojects.org/groups/ares . These large real-world
buggy programs will also beneﬁt the research community
by providing a benchmark suite for evaluating various bug
detection, recovery and ﬁxing techniques.
Contributions Our main contributions are as follows:
•We propose a lightweight framework to perform ARR
by exploiting and extending the intrinsic error resilience
of software systems.
•We propose a sandbox approach to evaluating the ef-
fectiveness of multiple recovery solutions, and also a
set of ranking strategies to choose the most viable one.
1http://openjdk.java.net/groups/hotspot/
2https://source.android.com/devices/tech/dalvik/•Our implementation, Ares, is built on top of the widely
deployed Java HotSpot VM and Android ART, making
it easy to be integrated into production environments.
Aresintercepts the internal exception handling mech-
anisms in the two VMs, so the runtime overhead is
negligible during normal program executions.
•The evaluation of Aresis promising. We have applied
Aresto 52 real world bugs from large software projects,
anditcansuccessfullyrecoverfrom39ofthem. Because
their software systems lack intrinsic error resilience, the
13 non-recoverable bugs by Aresrequire more advanced
recovery strategies, which we leave as future work.
Paper Organization The remainder of this paper is orga-
nized as follows. Section 2 introduces necessary background
on exceptions in Java, and Section 3 demonstrates how Ares
recovers from runtime exceptions via two illustrative exam-
ples. Section 4 describes the design and implementation of
Ares. Section 5 presents our evaluation results. Section 6
discusses the limitation of Aresand other design decisions.
Section 7 surveys related work and Section 8 concludes.
2. EXCEPTIONS IN JA VA
This section brieﬂy introduces necessary background on
Java exceptions to provide proper context for our work.
2.1 Exception Handling Mechanism
The Java programming language has a built-in exception
handling mechanism. The basic construct is a try-catch
block, composed of a tryblock and a catchblock that catches
exceptionsthrowninsidethe tryblock. A catchblockdeclares
a catchable exception type Eh, that is, any exception of type
Ehor a subtype of Ehis catchable by the catchblock. We
denote a try-catch block as
(ls, le, lc, Eh) (Try-Catch Block)
where lsandleare the start (inclusive) and end (inclusive) of
thetryblock; lcis the start (inclusive) of the catchblock; Eh
is the catchable exception type. Note that multiple try-catch
blocks can share the same tryblock. Without ambiguity we
use exceptions and errors interchangeably in the remainder
of this paper.
In JVM once an exception of type Eis thrown at a location
l, JVM looks up an exception handler inside the current
method on the top of the call stack. If there exists a try-
catchblock (ls, le, lc, Eh)where ls≤l∧l≤le∧E <:Eh,3
the execution jumps to this handler lc. Otherwise, the stack
frame of this method is popped out and the exception is
delivered down to the stack. The same procedure repeats for
each method frame until an exception handler is located or
the stack becomes empty.
2.2 Exception Hierarchy
Figure 1 shows the hierarchy of exception types in Java.
Generally, there are two types of exceptions:
Checked Exceptions Checked exceptions are used to in-
dicate that certain anticipated errors may happen and must
be noticed by programmers. Therefore, programmers should
explicitly use a try-catch block to catch and handle these ex-
ceptions, or deliver them up to the caller. This is enforced by
the type system of Java. For example, reading a non-existing
3The operator <:denotes subtyping relation.
685Throwbale
Error Exception
IOExceptionRuntime
ExceptionClass
NotFound
Exception
FileNot
Found
ExceptionNullPointer
ExceptionChecked exception
Unchecked exception
Figure 1: Java exception type hierarchy.
ﬁle will throw an exception of FileNotFoundException . Thus
when reading a ﬁle, the programmer needs to either catch
this exception or let the caller handle it.
Unchecked Exceptions Unchecked exceptions do not re-
quire programmers to explicitly handle them, as they are of-
ten assumed not to occur during execution. Thereby, such an
exception may crash the program unexpectedly. Unchecked
exceptionsinJavacanbefurtherclassiﬁedintotwocategories
Error(i.e.,java.lang.Error ) and RuntimeException . The
former category refers to errors related to Java virtual ma-
chines, such as OutOfMemoryError and StackOverflowError ,
which are usually not recoverable for programmers. On the
other hand, RuntimeException and its subclasses are often
symptoms of programmers’ bugs, which are not expected to
manifest at runtime, e.g.,NullPointerException . For sim-
plicity, we will use unchecked exception to refer to the latter
category.
In this paper, we focus on the recovery of the unchecked
exceptions, namely, maintaining the system functional for
subsequent usage by surviving unanticipated unchecked ex-
ceptions. When there is no ambiguity, we use error and
unchecked exception interchangeably in the remainder of this
paper.
3. ILLUSTRATIVE EXAMPLE
This section presents two examples to illustrate how Ares
recovers a software system from unanticipated runtime excep-
tions with its two types of error handler synthesis strategies,
i.e., error transformation and early return.
3.1 Recovery via Error Transformation
We use a real security bug of Tomcat 7 to demonstrate how
Aresrecovers the system from the manifestation of this bug
via error transformation. Figure 2a shows this information
disclosure security bug (CVE-2013-2071) [1].
Themethod fireOnComplete online5realizesthe Observer
design pattern. The listeners are registered to be called
on some events, and may be implemented by third-party
developers. A listener may be buggy and therefore it is
possible that the method call on line 5 abnormally exists
with an unchecked exception. However, the catchblock on
line 6 only handles IOException . This exception will be
propagated along the stack, and results in the server failing
to recycle the data of the current web request. Consequently
the leaked data later becomes accessible for the next web
request.
IfAresis deployed, this security exploit can be prevented.
Errortransformationwillautomaticallyconverttheunchecked1for (AsyncListenerWrapper l : listenersCopy) {
2 try {
3 /*BUG: An unchecked exception may be
4 thrown in the call below. */
5 l.fireOnComplete(event);
6 } catch (IOException e) {
7 }}
(a) Tomcat bug 54178 (CVE-2013-2017)
1for (AsyncListenerWrapper l : listenersCopy) {
2 try {
3 l.fireOnComplete(event);
4- } catch (IOException ioe) {
5+ } catch (Throwable t) {
6+ ExceptionUtils.handleThrowable(t);
7 }}
(b) Patch
Figure 2: Tomcat bug 54178 (CVE-2013-2071) and
its patch.
1/*BUG: getDigest(...) may return null */
2 Stringmd5a1 = getDigest(username, realm).toLowerCase
(Locale.ENGLISH);
3if(md5a1 == null )
4 return null ;
(a) Tomcat bug 54438
1 String md5a1 = getDigest(username, realm);
2/*FIX: check value of
3getDigest(...) */
4if(md5a1 == null )
5 return null ;
6 md5a1 = md5a1.toLowerCase(Locale.ENGLISH);
(b) Patch
Figure 3: Tomcat bug 54438 and its patch.
exception thrown on line 5 into an IOException object which
will be immediately processed by the handler on line 6, pre-
venting information leakage. In fact, the oﬃcial patch, shown
in Figure 2b, is very similar to our recovery process. It just
makes the catchblock capable of handling every exception
(i.e.Throwable ).
The recovery strategy error transformation aims to exploit
the error resilience existing in software systems ( i.e., exist-
ing exception handlers) to handle unanticipated unchecked
exceptions. It is also similar to one of the common ways
developers cope with unchecked exceptions, namely, catching
the unchecked exception, converting it to another type and
re-throwing the new exception.
3.2 Recovery via Early Return
This subsection shows another Tomcat bug, which can be
recovered by the strategy early return . Figure 3a displays
TomcatBug54438. Online2, themethodcall getDigest may
return nullif the username does not exist. This nullfurther
triggers a NullPointerException when we use the returned
digest (i.e.,null) to invoke another method toLowerCase .
To recover from this exception, Aresintercepts the internal
exception handling of JVM. It then ignores the exception and
returns nullfor the call to toLowerCase . However from the
perspective of overhead, Ares’s synthesized error handler does
not incur additional overhead on normal program executions.
Figure 3b shows the developer’s patch to this bug, which
is equivalent to our synthesized error handler, although in
686Virtual Machine Java PathFinderCall StackpatcherCall Stack
rankerexceptionsynthesizer 1.error handlers
2.copy program states
3.most viable error handler
Figure 4: The overall framework of Ares.
diﬀerent representations. It ﬁrst checks whether the return
value of getDigest() isnull. If yes, then it returns from the
current method.
Similar to error transformation, the strategy early return
is inspired by another common way in which developers
handle unchecked exceptions, that is, catching an unchecked
exception and returning from the current method with a
default value ( e.g., 0 for numerics types and null for reference
types).
4. APPROACH
This section describes our approach for ARR. Figure 4
shows the overall framework of Ares.
JVMOur approach is built on a regular Java virtual ma-
chine (JVM). It is used to execute programs in normal
mode. Aresonly intercepts the exception handling of
the underlying JVM. Once an error of interest occurs
(e.g., unanticipated unchecked exceptions), Aresstops
JVM, takes over the execution, and starts the recovery
process.
Synthesizer Basedonthethrownexceptionandthecontent
of the call stack in JVM, the synthesizer generates a set
of candidate solutions for recovery ( i.e., error handlers),
which will be tested in a “sandbox” to assess their
capabilities of recovering from the exception.
JPFWe use Java PathFinder (JPF) as the “sandbox”, be-
cause it supports checkpoint and restoration, facilitat-
ing program state exploration and rollback. In detail,
once we start the recovery process, a JPF instance is
created and initialized with the program states in the
host JVM. We apply a synthesized error handler in
JPF each time until all handlers are tested.
Ranker After the testing of JPF, we propose an eﬀective
heuristic to rank these error handlers and return the
most promising one.
Patcher The patcher will realize the error handler returned
by the ranker in the host JVM on the ﬂy. Then the
program execution resumes.
4.1 Identifying Errors of Interest
Arespiggybacks on the internal exception handling mecha-
nism of JVM. When an exception is thrown, Aresﬁrst checks
whether the exception is of interest and then attempts to
recover from it if yes. Aresonly checks and recovers from
the exceptions that satisfy the following two conditions,
1.The exception must be an unchecked exception, an
object of RuntimeException or its subtype. We omit
checked exceptions as they have been explicitly handled
by programmers, which is enforced by the Java type
system.Algorithm 1: Force-Throwable Error Transformation
Input:/angbracketleftm1,···, mn/angbracketright, the recovery context
Input: E, an unchecked exception
Output: an exception type to which Ecan be
transformed
1fori←2tondo
2 H←exception handlers in method mi
3 li−1←the location of the call to mi−1
4 foreach handler (ls, le, lc, Eh)∈Hdo
5 ifls≤li−1∧li−1≤lethen
6 return Eh
7return null
2.The unchecked exception should have no correspond-
ingeﬀective error handler. Apparently, an unchecked
exception is of interest if it has no error handler in
the whole call stack. We also consider another type
of unchecked exceptions that are handled by a trivial
overly-stated catchblock,e.g., unchecked exceptions
caught by catch( Throwable e){...} . We refer to the
ﬁrst type as uncaught exception and the latter as triv-
ially handled exception .
4.2 Error Handler Synthesis
We synthesize error handlers in two ways: error transfor-
mationandearly return . Before detailing them, we introduce
a notion recovery context to facilitate the description.
Recovery Context Given a thrown exception E, letHbe
the stack frame which has a catchblock to handle E. Then
the recovery context of Eis the sequence of frames in the
stack from the top frame Tto the frame above H(exclusive
ofH),i.e.,[T, H). We also use/angbracketleftm1,···, mn/angbracketright(m1is the top
frame) to denote a recovery context.
Take Figure 2 as an example. An unchecked exception is
thrown in the method call fireOnComplete(event) on line 5.
This exception cannot be handled by the existing handler for
IOException on line 6, and is handled by a catch block for
Throwable in a method frame Endnear the bottom of the
call stack. Therefore, the recovery context for this exception
is the stack frames from the top frame to the frame right
aboveEnd.
For a trivially handled exception, we only try to recover
from it before the last frame of its recovery context. If we
fail to synthesize a proper error handler, we will honor the
original semantics of the program and let the programmed
error handler take charge of the execution.
4.2.1 Force-Throwable Error Transformation
The simplest way to reuse existing error handlers is to
make every catchblock catch Throwable . Thus, we propose
the Force-Throwable Error Transformation (FTET) in Algo-
rithm 1. FTET ignores the type of the raised exception and
usesonlythelocationinformationtosearchforerrorhandlers.
As Java is type-safe, we also need an error transformation
that converts the unchecked exception to the exception that
thecatchblock declares.
4.2.2 Stack-Based Error Transformation
A method should only throw a checked exception that is
declared by the method. Therefore, we propose the Stack-
Based Error Transformation (SBET) in Algorithm 2. In
687Algorithm 2: Stack-Based Error Transformation
Input:/angbracketleftm1,···, mn/angbracketright, the recovery context
Input: E, an unchecked exception
Output: a set Rof checked exception types to which E
can be transformed
1R←?
2fori←2tondo
3 H←exception handlers in method mi
4 S←checked exceptions declared by method mi−1
5 li−1←the location of the call to mi−1
6 foreach handler (ls, le, lc, Eh)∈Hdo
7 ifEh∈S∧ls≤li−1∧li−1≤lethen
8 R←R∪{the type of Eh}
9return R
1public void printMultiLn(String s) {
2 int index = 0;
3 // look for hidden newlines inside strings
4 while ((index=s.indexOf( ’\n’ ,index)) > -1 ) {
5 javaLine++;
6 index++;
7 }
8 writer.print(s);
9 }
Figure 5: Tomcat bug 43758
SBET, not any arbitrary checked exception can be the target
exception of error transformation. First, the target exception
should have a proper error handler in the recovery context.
Second, the checked exception must be declared by one of
the active methods in the recovery context.
In Algorithm 2, once an unchecked exception Eis thrown
in the method m1, we check whether its callers (from m2to
mn) have available exception handlers which we can leverage
to handle E. Speciﬁcally, if a method mideclares to throw
an exception Eh(tested by Eh∈Son line 7) and there is a
handler for this exception, then we can transform EtoEh.
4.2.3 Early Return
This recovery strategy takes as input two parameters: a
number n(n≥1) of stack frames to pop out of the call stack
and a value vof the return type. Once an unanticipated
error occurs, this strategy pops nstack frames from the call
stack and returns vas the return value. If n= 1, we name
this early return as First Early Return (FER).
These two parameters should be carefully chosen, other-
wise early return will result in dense cascaded exceptions or
introduce other unexpected program behavior after recovery.
In particular, the major challenge of early return is how to
fabricate a good return value. In FOC [25] and RCV [18],
they use the default value of a type, e.g.,0for integers,
nullfor object types. However, this may be problematic.
Take Figure 5 ( i.e., Tomcat Bug 43758) as an example. The
bug happens when the parameter sisnull, leading to a
NullPointerException when we call indexOf on line 4. If we
choose v= 0and return it as a default value, implemented
in FOC and RCV, then the loop becomes inﬁnite.
Diﬀerent from FOC and RCV which propose a single recov-
ery solution, Aresproposes a bounded number of parameters
to perform early return recovery. We then use JPF to evalu-
ate these parameters, which is able to weed out inappropriate
parameters. More details are available in Section 4.3.
Void-Only Early Return (VOER) Although it is diﬃ-
cult to choose a good value to return from the domain ofa type, it is easy to choose a value for type void, which is
voiditself. We specialize early return by only returning from
a method with voidreturn type. Void-Only Early Return
(VOER) just walks along the stack to locate the ﬁrst method
with void return type and then makes an early return there.
There may not be such a method. Hence, VOER may fail to
recover from some exceptions.
4.3 Evaluating Synthesized Handlers
As shown in Figure 4, after generating a set of error han-
dlers for a runtime error, we invoke JPF to test the appli-
cability of each handler. Speciﬁcally, Areswalks through
the stack in the host JVM to collect necessary information
to quickly instantiate an instance of JPF. Each time JPF
applies one error handler, and checks whether it can recover
the system from the bug. Thanks to the built-in support
for state checking and restoration of JPF, to test a handler,
we ﬁrst save the current state in which the buggy thread
is about to crash, and then apply the error handler. If the
execution stops, JPF restores the state and starts over to test
another error handler. After all error handlers are tested,
JPF returns a set of viable error handlers, which are later
ranked by the ranking strategy elaborated in Section 4.3.2.
4.3.1 Evaluating an Error Handler
Given a runtime error thrown in the top stack frame m1,
let/angbracketleftm1,···, mn/angbracketrightdenote its recovery context. Before JPF
executes any code of the synthesized error handler, a number
dof call stack frames need to be popped out. Take error
transformation as an example, if the target error handler is
inmi, then stack frames [m1, . . . , m i−1]should be popped
out ﬁrst. The same procedure also applies to early return.
The JPF execution begins at the target error handler in mi.
Theexecutionmaycallnewmethods, createnewstackframes
and increase the stack size. But these new stack frames do
not belong to the recovery context. During the execution,
there is a lowest stack frame mjin the recovery context. We
use[mi, mj)in measuring the length of testing, as they are
related to the context in which the exception is thrown. The
length (j−i)is denoted as c. Besides, we also record the
number of executed instructions as s. Intuitively, these two
metrics are complementary in measuring the conﬁdence of
the JPF testing execution.
The handler evaluation may stop in one of the following
scenarios:
No Error All methods in the recovery context complete
their execution normally.
Timeout In order to maintain responsiveness of the system
underrecovery, westoptestingthecurrenterrorhandler
if a maximum number of instructions (speciﬁed by the
parameter TIMEOUT ) has been executed.
Uninterpretable Behavior The JPF execution encoun-
ters a VM behavior that it cannot interpret, e.g., a call
to uninterpretable native code.
Cascaded Error The applied error handler in JPF execu-
tion triggers another runtime error.
Finally, the testing result of an error handler is represented
as a tuple (t, r, d, s, c ), where tis the type of the error handler
(either error transformation or early return), ris the stop
scenario of the JPF execution, dis the number of discarded
stack frames in the recovery context, sis the number of
688executed instructions, cis the number of stack frames in the
recovery context that have completed their execution.
4.3.2 Ranking Error Handlers
The ranking heuristic is designed based on observation
that the most promising error handler usually outperforms
others in two aspects: fewer discarded stack frames which is
measured by d, and longer JPF testing which is measured
bysandc.
First, we classify testing results as either benignormalig-
nant.No Error andTimeout are straightforwardly treated as
benign. For Uninterpretable Behavior andCascaded Error ,
their executed instructions smust exceed a threshold STEPS.
ForCascaded Error , despite STEPS, their exercised stack
frames cmust further exceed another threshold FRAMES .
Any other result is treated as malignant.
For benign error handlers, their online testing reﬂects high
conﬁdence. Thus, we prefer the one with fewer discarded
stack frames d. If two testing results have the same d, we
choose the one with more executed instructions. Malignant
error handlers are only used when there is no benign one.
For these error handlers, their online testing brings poor con-
ﬁdence. Thus, we simply prefer the one with more executed
instructions.
4.4 Implementation
We have implemented Areson two popular platforms:
Java HotSpot VM and Android ART. This design decision
enables our approach to be a drop-in substitute for standard
VMs, and easy to deploy in production environments without
complex conﬁgurations.
4.4.1 Areson Java HotSpot VM
TheJavaHotSpotVMisanopen-sourceindustrial-strength
JVM. It has been distributed as the default JVM vendor
for popular Linux distributions ( e.g., Ubuntu and Fedora).
We intercept the standard exception handling mechanism of
HotSpot to identify errors of interest and perform recovery.
In this way, our recovery system has little impact on the
performance of software systems in normal execution ( i.e.,
when no unanticipated errors occur). There is even no over-
head when no anticipated or unanticipated exceptions occur,
which is usually the case for majority of execution time.
We embed JPF in the host JVM to test synthesized error
handlers and invoke it on demand when recovery is required.
When a thread is about to crash due to an unanticipated
error of interest, we intercept the error handling process, and
start a JPF instance to continue the execution by applying
an error handler in the same thread. Speciﬁcally, we ﬁrst
create a call stack for JPF by duplicating the stack frames of
the recovery context (the top frames in the call stack of the
about-to-crash thread) in the host JVM. Then the program
execution is altered with an error handler and resumed in this
JPF instance. This process is repeated, with each iteration
applying a diﬀerent error handler. Lastly, we rank these
error handlers and choose the most promising one.
As JPF and JVM have diﬀerent object models, when
JPF needs to access an object in the host JVM at runtime,
Aresconverts that object to the representation of JPF. In
order to reduce runtime overhead, we only convert JVM
objects on demand, that is, we only convert the minimally
suﬃcient objects when they are requested. After the testing
for a handler completes, Aresresets all values of objectsTable 1: Programs used in our experiments.
Bugs Recovered
Tomcat 19 14 web application server
Jetty 12 8 web application server
JMeter 4 4 GUI application
GanttProject 8 5 GUI application
Android 9 8 various mobile apps
Total 52 39
for the next testing. Interactions with external resources
(e.g., ﬁles, databases) are uninterpretable behaviors that
are not supported by JPF. These behaviors should indeed
be forbidden as they may induce side eﬀects on the host
execution during online testing, which are diﬃcult to revert
when JPF tests another error handler.
If a synthesized error handler is applied for recovery, Ares
does not persist it in the buggy method for future program
execution. This is mainly because the error handler is synthe-
sized based on the context ( e.g., method call stack) in which
the error manifests. Next time the method encounters the
same error, Areswill synthesize another error handler based
on the context, which may be diﬀerent from the previous
handler as the context may diﬀer.
4.4.2 Areson Android ART
The mobile version of Aresis implemented on top the new
Android ART released in Android 5.0.1. We modify the ART
runtime and deploy it in a Nexus 5 mobile phone. However,
currently we only implement a conservative strategy in ART
instead of embedding JPF. Android ART uses a diﬀerent
byte code representation ( i.e., dalvik) and a diﬀerent layout
of stack frames, which is not supported by JPF.
Our conservative strategy in Android ART ﬁrst attempts
toapplySBET.IfSBETisnotapplicable, itthenattemptsto
apply VOER. If both fail, we just abort the recovery process.
Our evaluation on nine bugs in real-world Android apps
shows that this strategy is always able to ﬁnd an appropriate
error handler.
5. EXPERIMENTS
To demonstrate the eﬀectiveness of Ares, this section
presents our extensive evaluation of Areson widely-used
web servers, desktop GUI applications and mobile apps. The
experiments on server and desktop applications were con-
ducted on a Linux machine with Intel Quad-Core i7 3.4GHz
CPU and 12 GB memory; those on mobile apps were done
on a Nexus 5 smart phone.
We have evaluated Aresonall 52 exception-related bugs
that we were able to reproduce from several widely-adopted
projects, and Aressuccessfully recovered from 39 of them,
e.g., the program can continue running to serve new user
requests. The 13 non-recoverable bugs are mainly due to
lack of intrinsic error resilience in these software systems.
Tackling them requires more advanced recovery strategies
besides error transformation and early return, which we leave
as future work.
Program Subjects Table 1 lists the details of the program
subjects used in our evaluation. Both Tomcat and Jetty are
popular Java web servers that have been under active devel-
opment for over ten years, and widely deployed in production
environments. JMeter is a web testing tool. GanttProject
689Table 2: Acronyms of exception names
Exception Name Acronym
ArrayIndexOutOfBoundsException AIO
BufferOverflowException BOE
ConcurrentModificationException CME
ClientAbortException CAE
DeploymentException DE
Exception E
EofException EE
FileNotFoundException FNF
IllegalArgumentException IAE
IllegalAccessException ICE
IllegalJidException IJE
IllegalStateException ISE
IllegalUserActionException IUA
InterupptedException IE
IOException IOE
JasperException JE
MalformedURLException MUE
MalformedCachePatternException MCP
MPXJException MPX
NumberFormatError NFE
NullPointerException NPE
RuntimeException RE
ServletException SE
StringIndexOutOfBoundsException SIO
SQLException SQE
Throwable T
UnavailableException UE
UnsupportedEncodingException UEE
UnsupportedOperationException UOE
XNIException XNI
is a project planning tool. The Android apps include web
browsers, instant messengers and productivity tools.
Collection of Bugs In order to collect these bugs, we ﬁrst
searched the bug repositories, revision logs and release notes
with the keywords “exception” or “NPE”. This step yielded
244 bugs. Then we attempted to reproduce all these bugs
according to the instructions recorded in their bug reports.
At last, we obtained 52 bugs that were reproducible in our
testing environment. Besides, almost all bugs were repro-
duced in a standalone server with a deployed web application
or by manually exercising a GUI application. For the other
bugs, we directly used unit tests provided in bug reports.
To save space and facilitate description, we use acronyms
of exceptions in the rest of this section, as shown in Table 2.
5.1 Evaluation on Java HotSpot VM
We evaluate Areswith 43 real-world bugs on the Java
HotSpot VM. In order to better understand the eﬀective-
ness of Ares, we also evaluate four basic strategies with the
same set of bugs, i.e.FTET, SBET, FER and VOER. In
each basic strategy evaluation, given a buggy program, we
apply the strategy to recover the program from not only
the unanticipated exception triggered by the bug, but also
the cascaded exceptions that are of interest for recovery. In
contrast, on each exception of interest, Areswill adaptively
select the most promising error handler based on the context
of the exception rather than sticking to a single strategy.
Theparametersof Aresareconﬁguredasfollows, TIMEOUT =
1000,STEP = 100 ,FRAMES = 1. As Algorithm 2 shows,
SBET returns a set of exception types to transform to. In
the evaluation of the basic strategy SBET, we only use the
ﬁrst exception type in the nearest call stack frame as the
transformation target. Similarly, FER and VOER also pro-
pose a list of call stack frames to return from, as described
in Section 4.2.3; and we select the top frame as the target in
their evaluations.Table 3: Summary of Recovery Results on Java
HotSpot VM
Result FTET SBET FER VOER Ares
N.A. 2 13 0 3 0
Failure 33 24 13 16 12
Repair 5 4 10 3 10
Plausible 3 2 20 21 21
Recovery 8 6 30 24 31
Repair Rate 12.2% 13.3% 23.3% 7.5% 23.3%
Plausible Rate 7.3% 6.7% 46.5% 52.5% 48.8%
Success Rate 19.5% 20.0% 69.8% 60.0% 72.1%
The result of a recovery is analyzed in two steps:
Step One We manually check whether the recovery makes
software functional for later use. Take GanttProject
as an example. After recovery, if we still can make
planning, we then classify this recovery as eﬀective; if
the application crashes or we cannot make planning,
we then classify the recovery as ineﬀective.
Step Two If the recovery is eﬀective, we further compare
thesynthesizederrorhandlerwiththedeveloper’spatch.
If they are semantically equivalent, then we classify
the error handler as a repair, otherwise as a plausible
recovery.
Table 3 summarizes the recovery results. The row N.A.
represents the number of cases where the corresponding
strategy is not applicable ( e.g., no existing exception han-
dler for FTET and SBET); the row Failure represents the
number of cases where the corresponding strategy fails to
recover from the bugs. The Recovery row is the sum of
Repairand Plausible , the Repair Rate is computed as
Repair /(Recovery +Failure ), the Plausible Rate is com-
putedas Plausible /(Recovery +Failure ), andthe Success
Rateis computed as Recovery /(Recovery +Failure ).
Among the four basic strategies, FER is the most eﬀective
one. This observation contributes much to our ranking algo-
rithm. However, FER may result in a catastrophic inﬁnite
loop (e.g., the bug in Figure 5). An inﬁnite loop should
be prevented in advance, as it may propagate bad eﬀects
rapidly. VOER is also eﬀective. However, it results in fewer
repairs but more plausible recoveries. Although FTET has
more applicable scenarios, its repair rate and success rate
are slightly lower than SBET.
Areshas the best overall recovery result and also results in
fewer cascaded exceptions, especially compared to FER (will
be discussed in the following section together with Table 4).
Although our ranking heuristic of Aresoverall works well in
the evaluation, it rejects two repairs ( i.e., Bug 29 and 30 in
Table 4), and accepts two plausible recovery handlers with
fewer cascaded errors than the repairs. We believe that with
an enhanced ranking mechanism, the evaluation results will
be further improved, which we leave as future work.
5.1.1 Details of Evaluation
Table 4 shows the details of our evaluation on the 44 bugs.
The ﬁrst column shows the unique IDs of these bugs in order
to conveniently refer to them in this paper, and the second
column shows the real bug IDs in their corresponding bug
repositories. The third column lists the types of exceptions
thrown when these bugs manifest themselves.
The multi-column Basic Strategy shows the statistics of
recoveries with the four basic strategies. We only show the
690Table 4: Recovery of bugs on the Java HotSpot VM.
#Bug ID ErrorBasic StrategyαAres
FTET SBET FER VOER FTET SBET FER VOER Final Time
tCR tCR tCRtCRrdscrdscrdscrdsc trdscCR(ms)
1TC 43338 IAE E0FICE0Fvoid0P10PC42110C42110C15831C15833void1C158330P723
2TC 43758 NPE E0FJE0F0∞F21RU14210U14210C1160U21200void2U212001R887
3TC 46298 NPESQE0RSQE0Rvoid0P10PT2—0T2—0U14545U14545void1U145450P862
4TC 49184 AIO T0FN.A. void2P11FT3—0N.A. N1503N1503void1N15032P766
5TC 49883 UOE LE0FLE0Fnull7P64PT11—0T11—0T1—1T6—1null1T1—17P249
6TC 51401 IAE E5FN.A. void5P15PC12110N.A. U11600U11600void1U116005P803
7TC 51403 NPE E10FN.A. null22FN.A.C11130N.A. C160N.A. EC1113010F679
8TC 51550 ISEIOE0FIOE0Fnull45F50FN86831N86831T1—7T5—3void1T1—75F969
9TC 51910 NPE T0FIOE0Fvoid1R10RC73940N77611N15077N15077void1N156770R313
10TC 53677 ISECAE0FIOE0Fvoid14F114FN24101T2—0N1932N1932void1N19324F869
11TC 54178 REIOE0RIOE0Rvoid0P10PC22390C22390T1—4T1—4void1T1—40P1277
12TC 54438 NPE T0FIOE0Fnull0R50FN59951T5—0T1—2N52941null1T1—20R766
13TC 54703 NPEIOE0PIOE0Pnull0P30PC18233C18233C18243C38061null1C182430P836
14TC 55454 NPE E1PIOE0Pnull4P40PN161N.A. C110N.A. EN1611P854
15TC 56010 IAE T0FIOE0Fvoid0F10FU330U330U1330U1330void2N2421F635
16TC 56246 NPE N.A. N.A. null0RN.A. N.A. N.A. T1—0N.A. null1T1—00R591
17TC 56736 ISEIOE0FN.A. 00R20PC47030N.A. T1—3T2—2 01T1—30R1131
18TC 58232 NPEDE1FN.A. null4F22FC3480N.A. C110T1—1void2T1—11F1043
19TC 58490 NPEMUE0FN.A. null39P20FU210N.A. C1850U210null1C18507P532
20JT 335500 NPEEE0FIOE0Fvoid16P12FT6—0T6—0U1110U1110void4T4—20P797
21JT 358027 NPEEE0FIOE0Fnull6F20PC41960T4—0C1100C21872void2C218720P775
22JT 375490 NPEIOE0FFNF0Fnull0F20FN1350N1350U1880N242IOEN13500F620
23JT 393158 ISE T3FIOE0F02P22PT2—2T4—0T1—3T2—2 01T1—31P1082
24JT 395794 NPEIAE0FIOE0Fnull0R20PT4—0C87670U11901U21121null1U119010R1065
25JT 401531 SIOUE0FJE0F00F70FT7—0C880U1110U71720null1T2—22F763
26JT 402106 BOE E0FN.A. null0PN.A.T1—0N.A. U150N.A. ET1—01F630
27JT 404283 NPEIOE0RN.A. void0R10RT1—0N.A. U19742U19742IOET1—00R714
28JT 411844 AIO N.A. N.A. void0P10PN.A. N.A. T1—0T1—0void1T1—00P500
29JT 424051 NPE T0FIOE0Fnull5R30FU2930N.A. C1121N.A. TU29301P518
30JT 446107 NPEUE0FSE0Fnull1R31PU49070U49200U121N362null2U214500P765
31JT 465700 NPE E0FIOE0F00F20FC83540U87520T1—0U25796 01T1—00F900
32JM 39599 CMEIUA0FIUA0Fnull2P20PT8—0T8—0U15477U29246null1U154772P579
33JM 51869 IAEIUA1FIUA1Fnull1R33FT8—0T8—0T1—3U35483null1T1—33R588
34JM 53874 NPEUEE0RUEE0Rnull0R30PU13010U13010T1—1U32251null1T1—10R745
35JM 55694 NPEMCP0PN.A. void1P11PU33020N.A. C11820C11820void2T2—30R494
36GP 461 NPE E0FIOE0Fnull36P29PC61270C61270T1—0T2—0null1T1—036P725
37GP 465 AIO IE0FN.A. null2F30FN.A. N.A. U110N.A. 06T6—20F381
38GP 523 NPEIOE0FIOE0F05F52FC91300C91300C170U59230null3U299332F433
39GP 577 REIOE1FIOE0Fnull20P21PC71300C71300C1470C22250void3C348701P361
40GP 607 NPEXNI1RXNI1Rvoid0F10FC21904C21904T1—5T1—5void1T1—50F703
41GP 708 NPEMPX0FMPX0Fvoid1P11PC61280C61280C12576C12576void1C125761P502
42GP 817 NPE IE0FN.A. void0P10PN.A. N.A. T1—2T1—2void1T1—20P590
43GP 830 NPE E0FIOE0Fvoid2P11PN.A. T11—4C1652C1652void4T4—50P417
αtindicates the type of error handler. Speciﬁcally, tis the target exception type for SBET and FTET, the return type for FER, the discarded
stack frames for VOER, and a pair of the return type and the number of discarded stack frames for generic early return. Cindicates the
number of the actual cascaded errors in the host JVM. Rindicates the recovery result. For recovery result, we use F for failure, R for repair,
and P for plausible recovery .(t, r, d, s, c )is the testing result of the JPF execution described in Section 4.3.1. For the stop scenario r, we
use N for No Error , T for Timeout , U for Uninterpretable Behavior , and C for Cascaded Error .
type of the ﬁrst error that is triggered by the bug. For each
basic strategy, we list a tuple including the typeof recovery
solutions, the number of cascaded errors and the recovery
result.
ForAres, we ﬁrst list the testing result (r, d, s, c )for each
basicstrategy. NotethatSBETandVOERmayfailﬁrst, e.g.,
Bug 14. At last, we use a 7-tuple for the most promising error
handler determined by the ranking, including the testing
result (t, r, d, s, c ), the actual cascaded errors in the host
JVM after applying the error handler, and the recovery
result. As JPF has its own implementation of a small set of
library classes, Aresmay fail to apply all basic strategies in
JPF (e.g., Bug 42 and 43) and also result in false cascaded
errors that disappear in the host JVM.
Ares versus FER The major advantage of Aresover FER
is the signiﬁcantly reduced number of cascaded exceptions
induced by the recovery handler. Table 5 shows the statisticsTable 5: Statistics of Cascaded Exceptions of FER
and Ares
MIN MAX StdDev Mean Median
FER 0 45 11.0 5.8 1
Ares 0 36 5.8 2.2 0
of the cascaded exceptions by the two strategies. We also
conducted Wilcoxon Signed-Rank Test. The pvalue for the 1-
tail test is 0.0008, showing that the improvement is statistical
signiﬁcant. Note that the results in Table 5 are computed
by excluding Bug 2, in which FER causes an inﬁnite loop
triggering inﬁnite number of exceptions. This bug further
demonstrates the advantage of Aresover basic strategies.
Overhead Aresperforms recovery on demand, and re-
quires no instrumentation into programs. Thus it imposes no
overhead on normal program executions. The overhead intro-
6911/*method processMatches */
2 List matches = new ArrayList();
3if(isScopeVariable()){
4 String inputString=vars.get(getVariableName());
5 /*BUG: inputString may be null */
6+ if(inputString == null) {
7+ log.warn("...");
8+ return Collections.emptyList();
9+ }
10 matchStrings(..., matches, ..., inputString);
11 } else {...}
12return matches;
Figure 6: JMeter bug 55694 and its patch.
1try {
2 setFormatter((Formatter) cl.loadClass(
formatterName).newInstance());
3 } catch (Exception e) {
4- // Ignore
5+ // Ignore and fallback to defaults
6+ setFormatter(new SimpleFormatter());
7 }
Figure 7: Tomcat bug 51403 and its patch.
duced by Aresonly occurs when an exception is thrown and
the recovery is performed. As Table 4 shows, the recovery
pausing time of all basic strategies is less than one millisec-
ond; and that of Aresranges from 249 to 1277 milliseconds,
which is mainly used to bootstrap JPF.
5.1.2 Analysis of Bug Samples
In addition to the bugs discussed in previous sections, we
further discuss three bugs in detail as follows.
JMeter 55694 As shown in Figure 6, processMatches
calls matchStrings (on line 10) to ﬁnd substrings that match
inputString (on line 4), and saves the results in matches,
which is allocated as an empty list (on line 1). matchStrings
ﬁrst uses inputString to create a matcher object. If the value
ofinputString is null, the constructor results in an NPE.
FER and VOER return from the constructor abnormally
and results in a cascaded error in matchStrings .Aresdetects
the cascaded error and returns from matchStrings directly.
Finally, the execution returns from the processMatches on
line 12 with an empty list. Thus, it has the same behavior
as the patch except the log (on line 7).
GanttProject 830 This bug makes GanttProject not re-
sponsive to any of the bug reporter’s requests. The patch
to this bug is two-fold: It ﬁrst ﬁxes the broken logic to cal-
culate the correct value for a date range and then adds a
catch-and-ignore error handler surrounding buggy methods,
as the calculation of date range is non-trivial and there may
still be bugs.
Although Arescannot calculate the correct date range, it
lets users continue editing and saving their work by using
early return. Once the edited ﬁle is opened with a ﬁxed
version, helpful warnings will lead users to manually reﬁll
the nulliﬁed broken date ranges. Thus, we claim that Ares
produces a plausible recovery.
Tomcat 51403 This bug cannot be ﬁxed by any default
error handlers in this paper. As shown in Figure 7, the patch
assigns a non-default value to the formatter. Currently, Ares
cannot allocate an object instead of null. Using a new-
allocated object requires to update all related references,
which has been well studied in [21].5.2 Evaluation on Android ART
We only evaluate Android bugs using the conservative
strategy as described in Section 4.4.2. As shown in Table 6,
Arescan recover 8 of 9. Two bugs are recovered by SBET
and 6 are recovered by VOER. The only unrecoverable one
incurs an “Application Not Responding” (ANR).
Recovery with VOER VOERcandiscardupto61frames
to recover from an error in this experiment. In Firefox bug
1136157, a NullPointerException occurs during recursively
destroying a set of GUI widgets when closing a page. There
are no reusable error handlers and no methods with void
returntypeintheﬁrst60frames. VOERresultsindestroying
the page, which is just the desired behavior.
Table 6: Recovery of Android apps bugs
App Bug ID Failure Type Result
Swiftp 22 IAE IOE FTP 550
AardDict 68 NPE 32 Ignored
MobileOrg 192 ISE 2 ANR
MobileOrg 344 NPE 13 Ignored
My Expense 136 NFE 4 Finished
OI Notepad 3 NPE 2 Ignored
Conversation 839 NPE IJE Ignored
Firefox 1136157 NPE 61 Finished
Firefox 1114499 NPE 13 Ignored
Recovery with SBET While VOER exhibits signiﬁcant
recovery ability, SBET can also successfully recover from two
errors. Conversation bug 839 occurs when the app fails to
parsetheuseridintoastringbyscanningaQR-Code. Alater
fetch of this id attempts to build a Jidfrom the empty string,
which results in a NullPointerException .Aresconverts this
error into an InvalidJidException to recover the app from
a crash. Although the user fails to load the id, we believe
that it is better than the crash of the whole app.
Swiftp can be used for sharing ﬁles between diﬀerent mo-
bile phones. Swiftp bug 22 is caused by a misuse of an
Android API, which is used for creating named temporary
ﬁles. If the name of the temporary ﬁle has fewer than three
characters, the API throws an IllegalArgumentException .
This error makes the thread terminate abnormally. Ares
converts this error into an IOException , which has an error
handler that sends back an FTP 550 error together with a
message indicating the fail of the rename. Obviously, this
recovery is not a repair but better than no recovery, which
results in a connection loss.
6. DISCUSSION
In this section, we generally discuss the correctness guar-
antee of Ares. Similar to most of the ARR techniques [12,
25, 22, 7, 27, 18], Aresdoes not guarantee the correctness of
the recovered buggy software systems. However, the use of
JPF as a sandbox execution environment makes Arescapable
of eliminating a number of dangerous or infeasible recovery
plans at the early stage ( e.g., avoid applying FER for Bug
2 in Table 4), and selecting the promising/optimal recovery
plan to execute. This step greatly reduces the risk of the
recovery plan’s causing worse consequence than the buggy
program’s default behavior of handling the unanticipated
bug. Besides, we plan to develop new strategies, particularly
for bugs that currently Aresand FER cannot handle. By
combining sandbox testing and new ranking algorithms, we
would avoid using FER to recover bugs that it cannot handle.
692In terms of persistent data safety, Ares’s in-vivo testing
phase forbids writing data to persistent storage. Any of
such attempts will abort the recovery process and resume
the execution in the host VM. For the writes to persistent
storage in the host VM after a recovery handler is applied, we
can leverage the monitoring technique (orthogonal to Ares)
proposed by Long et al.in [18], that is, tracking whether
data that are aﬀected by the recovery process can ﬂow to
the persistent storage.
Compared to correctness-critical software ( e.g., databases,
compilers), ARR techniques are suitable for recovering in-
teractive programs that have the following property: These
programs usually have multiple features, and the malfunction
of one feature (although it can crash the entire program) has
little or no impact on the operation of other features. In this
case, if we can recover the program from this failure, other
features can still run correctly in the current interaction or
the following ones. For example, in the Tomcat bug in Fig-
ure 2, although the failure of a buggy third-party listener can
lead Tomcat to malfunction by leaking private information
(similar to crashing), it does not (and should not) aﬀect the
execution of other features. Our 52 real-world bugs cover
web servers, GUI applications, and mobile apps, most of
which have this property . The evaluation of Areson them
shows that Aresdoes not introduce worse consequences than
program subjects’ default error handlers.
7. RELATED WORK
This section surveys three lines of related work to Ares.
7.1 Automatic Runtime Recovery
Generally, the recovery ability of ARR techniques comes
from either redundancy [24, 8] or just default behavior [25,
18]. The validation of the recovery can be either testing by re-
execution [24, 8] or suppressing catastrophic operations [18,
20]. We mainly discuss these approaches in this paper. Other
approaches[12, 22, 7, 27]thatfocusonspeciﬁcerrordetection
and recovery are not discussed in detail.
Checkpoints and Re-execution Checkpoint has been ex-
tensively studied in software recovery [14, 4]. Lots of ARR
techniques [24, 28, 8] piggyback checkpoints to facilitate val-
idation of their recoveries. ASSURE [28] also reuses existing
error handler. However, it requires proﬁling runs to collect
reusable error handlers before deployment. Areshas no need
to make checkpoints and can dynamically collect reusable
error handlers. It adopts a lightweight testing infrastructure
to rule out potential dangerous recovery.
Memory Error Suppression Memory error suppression
based approaches [25, 20, 18] continue the execution in a
recovery mode until the recovery ends up. Failure-Oblivious
Computing (FOC) [25] discards invalid memory writes(e.g.,
out of bounds writes, null dereference) and manufactures de-
fault values for invalid memory reads. RCV [18] extends FOC
withrecovery shepherding to prevent manufactured values
from ruining persistent data. However, the shepherding may
remain for a long time if there are infected long-live variables.
Besides, both FOC and RCV can only synthesize a single
recovery and may result in inﬁnite loops. APPEND [13]
instruments programs to recover potential null dereferences
by default or user-provided error handlers. NPEFix [10] uses
9 diﬀerent strategies to handle NPE but cannot determine
the ﬁnal strategy and also incurs very high overhead. Aresare not limited in handling memory errors and requires no
additional code, data and instrumentation. Thus, it incurs
negligible overhead in the host JVM.
7.2 Improving Exception Handling
Exception handling is usually used in programmer partici-
pated error recovery [15] but in fact is not well treated by
programmers [26, 5, 30]. Many approaches attempt to auto-
mate exception handling by either using speciﬁc model [6],
predeﬁned strategies [9] or default exception handling [11].
Arescan adaptively synthesize a number of error handlers
and select the most promising one. Besides, we implement
Areson a modern production platform and evaluate it with
real applications used in industry. Azim et al.[3] analyze
the log of Android to detect errors and also handle them by
synthesized error handlers that either ignore errors or reload
GUI. Aresis built on the ART runtime and also supports
error transformation.
7.3 Automatic Program Repair
Recently, a number of approaches on automatic program
repair have been proposed [29, 16]. These approaches usu-
ally require costly computation to ﬁnd a plausibly correct
repair [17]. In contrast, ARR usually has a strict timing
requirement and aims to seek results better than immediate
failures rather than a repair. Arescan also synthesize many
repairs. In fact, a certain number of repairs generated by
existing work simply delete functionality [23, 19].
8. CONCLUSION
Thispaperhaspresented Ares, anautomaticruntimerecov-
ery system implemented on top of the industry-strength Java
HotSpot VM and the Android ART VM. Aresis lightweight
(as it requires only minimal modiﬁcations to the runtime),
and eﬃcient (as it intercepts only the exception handling
mechanism, incurring no overhead on normal program execu-
tion). Thus, it can be seamlessly integrated into production
environments. Aresis also eﬀective as demonstrated by our
evaluation on 52 real-world bugs — it is able to successfully
recover from 39 of the bugs. To ensure reproducibility, we
have released all the source code and data used in this pa-
per, and more details about our evaluation can be found at
http://lab.artemisprojects.org/groups/ares.
9. ACKNOWLEDGEMENTS
We are grateful to the anonymous reviewers for their com-
ments. This research was supported in part by National
Basic Research 973 Program (Grant No. 2015CB352202),
National Natural Science Foundation (Grant Nos. 61472177,
91318301, 61321491) of China, the Collaborative Innovation
Center of Novel Software Technology and Industrialization,
the United States National Science Foundation (NSF) Grants
1117603, 1319187, 1349528 and 1528133, and a Google Fac-
ulty Research Award. The information presented here does
not necessarily reﬂect the position or the policy of the Gov-
ernment and no oﬃcial endorsement should be inferred.
10. REFERENCES
[1]CVE-2013-2071. http://cve.mitre.org/cgi-bin/cvename.
cgi?name=CVE-2013-2071, accessed: 2015-07-22.
[2]Mobile Apps: What Consumers Really Need and Want.
https://info.dynatrace.com/APM_13_WP_Mobile_
693App_Survey_Report_Registration.html, accessed:
2015-07-22.
[3] T. Azim, I. Neamtiu, and L. M. Marvel. Towards
self-healing smartphone software via automated
patching. In Proceedings of the 2014 International
Conference on Automated Software Engineering (ASE) ,
pages 623–628, 2014.
[4]G. Bronevetsky, R. Fernandes, D. Marques, K. Pingali,
and P. Stodghill. Recent advances in
checkpoint/recovery systems. In Proceedings of the 20th
International Parallel and Distributed Processing
Symposium (IPDPS) , April 2006.
[5]B. Cabral and P. Marques. Exception handling: A ﬁeld
study in Java and .NET. In Proceedings of the 21st
European Conference on Object-Oriented Programming
(ECOOP) , pages 151–175, 2007.
[6] B. Cabral and P. Marques. A transactional model for
automatic exception handling. Computer Languages,
Systems & Structures , 37(1):43–61, Apr. 2011.
[7] M. Carbin, S. Misailovic, M. Kling, and M. C. Rinard.
Detecting and escaping inﬁnite loops with jolt. In
Proceedings of the 25th European Conference on
Object-oriented Programming (ECOOP) , pages 609–633,
2011.
[8] A. Carzaniga, A. Gorla, A. Mattavelli, N. Perino, and
M. Pezzè. Automatic recovery from runtime failures. In
Proceedings of the 2013 International Conference on
Software Engineering (ICSE) , pages 782–791, 2013.
[9] H. Chang, L. Mariani, and M. Pezzè. Exception
Handlers for Healing Component-based Systems. ACM
Trans. Softw. Eng. Methodol. , 22(4):30:1–30:40, 2013.
[10]B. Cornu, T. Durieux, L. Seinturier, and M. Monperrus.
Npeﬁx: Automatic runtime repair of null pointer
exceptions in java. CoRR, abs/1512.07423, 2015.
[11] F. Cristian. Exception handling and software fault
tolerance. IEEE Transactions on Computers ,
31(6):531–540, June 1982.
[12] B. Demsky and M. Rinard. Automatic detection and
repair of errors in data structures. In Proceedings of the
18th Annual ACM SIGPLAN Conference on
Object-Oriented Programing, Systems, Languages, and
Applications (OOPSLA) , pages 78–95, 2003.
[13]K. Dobolyi and W. Weimer. Changing Java’s semantics
for handling null pointer exceptions. In 19th
International Symposium on Software Reliability
Engineering (ISSRE) , pages 47–56, 2008.
[14] E. N. M. Elnozahy, L. Alvisi, Y.-M. Wang, and D. B.
Johnson. A survey of rollback-recovery protocols in
message-passing systems. ACM Computing Survey ,
34(3):375–408, Sept. 2002.
[15] J. B. Goodenough. Exception handling: Issues and a
proposed notation. Communications of the ACM ,
18(12):683–696, 1975.
[16] D. Kim, J. Nam, J. Song, and S. Kim. Automatic
patch generation learned from human-written patches.
InProceedings of the International Conference on
Software Engineering (ICSE) , pages 802–811, 2013.
[17] C. Le Goues, M. Dewey-Vogt, S. Forrest, and
W. Weimer. A systematic study of automated program
repair: Fixing 55 out of 105 bugs for $8 each. In
Proceedings of the International Conference on
Software Engineering (ICSE) , pages 3–13, 2012.[18] F. Long, S. Sidiroglou-Douskos, and M. Rinard.
Automatic runtime error repair and containment via
recovery shepherding. In Proceedings of the ACM
SIGPLAN Conference on Programming Language
Design and Implementation (PLDI) , pages 227–238,
2014.
[19] S. Mechtaev, J. Yi, and A. Roychoudhury. Angelix:
Scalable Multiline Program Patch Synthesis via
Symbolic Analysis. In Proceedings of the 38th
International Conference on Software Engineering
(ICSE), pages 691–701, 2016.
[20] V. Nagarajan, D. Jeﬀrey, and R. Gupta. Self-recovery
in server programs. In Proceedings of the International
Symposium on Memory Management (ISMM) , pages
49–58, 2009.
[21] F. Peng, Z. Deng, X. Zhang, D. Xu, Z. Lin, and Z. Su.
X-force: Force-executing binary programs for security
applications. In Proceedings of the USENIX Security
Symposium , pages 829–844, 2014.
[22] J. H. Perkins, S. Kim, S. Larsen, S. Amarasinghe,
J. Bachrach, M. Carbin, C. Pacheco, F. Sherwood,
S. Sidiroglou, G. Sullivan, W.-F. Wong, Y. Zibin, M. D.
Ernst, and M. Rinard. Automatically patching errors in
deployed software. In Proceedings of the ACM SIGOPS
Symposium on Operating Systems Principles (SOSP) ,
pages 87–102, 2009.
[23]Z. Qi, F. Long, S. Achour, and M. Rinard. An Analysis
of Patch Plausibility and Correctness for
Generate-and-validate Patch Generation Systems. In
Proceedings of the 2015 International Symposium on
Software Testing and Analysis (ISSTA) , pages 24–36,
2015.
[24] F. Qin, J. Tucek, J. Sundaresan, and Y. Zhou. Rx:
Treating bugs as allergies—a safe method to survive
software failures. In Proceedings of the ACM
Symposium on Operating Systems Principles (SOSP) ,
pages 235–248, 2005.
[25]M. Rinard, C. Cadar, D. Dumitran, D. M. Roy, T. Leu,
and W. S. Beebee, Jr. Enhancing server availability
and security through failure-oblivious computing. In
Proceedings of the Symposium on Opearting Systems
Design & Implementation (OSDI) , pages 21–21, 2004.
[26]P. Sacramento, B. Cabral, and P. Marques. Unchecked
Exceptions: Can the Programmer be Trusted to
Document Exceptions? In Proceedings of the
International Conference on Innovative Views of .NET
Technologies , 2006.
[27] H. Samimi, M. Schäfer, S. Artzi, T. Millstein, F. Tip,
and L. Hendren. Automated repair of html generation
errors in php applications using string constraint
solving. In Proceedings of the 34th International
Conference on Software Engineering (ICSE) , pages
277–287, 2012.
[28]S. Sidiroglou, O. Laadan, C. Perez, N. Viennot, J. Nieh,
and A. D. Keromytis. Assure: Automatic software
self-healing using rescue points. In Proceedings of the
14th International Conference on Architectural Support
for Programming Languages and Operating Systems
(ASPLOS) , pages 37–48, 2009.
[29] W. Weimer, T. Nguyen, C. Le Goues, and S. Forrest.
Automatically ﬁnding patches using genetic
programming. In Proceedings of the 31st International
694Conference on Software Engineering (ICSE) , pages
364–374, 2009.
[30] D. Yuan, Y. Luo, X. Zhuang, G. R. Rodrigues,
X. Zhao, Y. Zhang, P. U. Jain, and M. Stumm. Simple
testing can prevent most critical failures: An analysisof production failures in distributed data-intensive
systems. In 11th USENIX Symposium on Operating
Systems Design and Implementation (OSDI) , pages
249–265, 2014.
695