Path-BasedFunction Embeddingand Its Application to
Error-HandlingSpecification Mining
Daniel DeFreez
Universityof California,Davis
UnitedStates of America
dcdefreez@ucdavis.eduAdityaV.Thakur
Universityof California,Davis
UnitedStates of America
avthakur@ucdavis.eduCindy Rubio-González
Universityof California,Davis
UnitedStates of America
crubio@ucdavis.edu
ABSTRACT
Identifying relationships among program elements is useful for
programunderstanding,debugging,andanalysis.Onesuchkindof
relationshipissynonymy.Functionsynonymsarefunctionsthat
play a similar role in code; examples include functions that per-
forminitializationfordifferentdevicedrivers,andfunctionsthat
implement different symmetric-key encryption schemes. Function
synonymsarenotnecessarilysemanticallyequivalentandcanbe
syntacticallydissimilar;consequently,approachesforidentifying
code clones or functional equivalence cannot be used to identify
them. This paper presents Func2vec, a technique that learns an
embedding mapping each function to a vector in a continuous
vectorspacesuchthatvectorsforfunctionsynonymsareinclose
proximity. We compute the function embedding by training a neu-
ral networkonsentences generatedusing randomwalks overthe
interproceduralcontrol-flowgraph.Weshowtheeffectivenessof
Func2vecatidentifyingfunctionsynonymsintheLinuxkernel.Fi-
nally, we apply Func2vecto the problem of mining error-handling
specifications in Linux file systems and drivers.We show that the
functionsynonymsidentifiedby Func2vecresultinerror-handling
specifications withhigh support.
CCS CONCEPTS
·Computingmethodologies →Unsupervisedlearning ;·Soft-
wareanditsengineering →Automatedstaticanalysis ;Error
handlingandrecovery ;
KEYWORDS
programanalysis,programembeddings,errorhandling,program
comprehension, specification mining
ACMReference Format:
DanielDeFreez,AdityaV.Thakur,andCindyRubio-González.2018.Path-
Based Function Embedding and Its Application to Error-Handling Speci-
fication Mining. In Proceedings of the 26th ACM Joint European Software
Engineering Conference and Symposium on the Foundations of Software Engi-
neering(ESEC/FSE’18),November4ś9,2018,LakeBuenaVista,FL,USA. ACM,
NewYork, NY, USA, 11pages.https://doi.org/10.1145/3236024.3236059
Permissionto make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,
topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ESEC/FSE ’18, November 4ś9, 2018, Lake BuenaVista,FL,USA
©2018 Associationfor Computing Machinery.
ACM ISBN 978-1-4503-5573-5/18/11...$15.00
https://doi.org/10.1145/3236024.32360591 INTRODUCTION
Apart from writing new code, a software engineer spends a sub-
stantial amount of time understanding, evolving, and verifying
existing software. Program comprehension [16] entails inferring
a mental model of the relationships among various program ele-
ments [15]. When available, documentation can aid program com-
prehension [ 10]. For instance, documentation about high-level API
functionsoftencontainsałSeeAlsožsectionenablingthereader
to navigate to relevant functions. However, such documentation is
eitherunavailableforlow-levelcode,oritisdifficulttomaintainas
thecodeevolves[ 14].Furthermore,languagessuchasClackfea-
tures suchas polymorphismandencapsulation that makeexplicit
the relationships between functions.
Thispaperdealswiththeproblemofidentifying functionsyn-
onyms:functionsthatservethesamepurposeorplayasimilarrole
in code. Identifying function synonyms is especially challenging
inlow-levelcodewritteninC,suchastheLinuxkernel,because
(i) function synonyms are often semantically different and syn-
tactically dissimilar; e.g., snd_atiixp_free andsnd_intel8x0_
freein the Linux PCI sound drivers atiixpandintel8x0 , re-
spectively; (ii) function synonyms need not always have simi-
larnames;e.g., acpi_video_get_brightness andintel_panel_
get_backlight eachreturnthebrightnesslevelofthebacklight;
and(iii)functionswithsimilarnamesarenotnecessarilysynonyms;
e.g.,rcu_seq_start adjusts the current sequence number, while
kprobe_seq_start returns the current sequence number. Thus,
techniques that identify syntactic and semantic code clones, check
semantic equivalence, or rely on naming conventions [ 7,11,31]
cannotbe usedto identifyfunction synonyms.
This paper presents Func2vec, a technique that learns an em-
bedding mapping each function to a vector in a continuous vector
space such that vectors for function synonyms are in close proxim-
ity.Figure 1illustratestheoutputof Func2vecforthePCIsound
drivers; inparticular, Func2vecmaps eachfunction to a vector in
R300,whichisthen projectedonto2-dimensionsusingt-SNE[ 17].
Functions are grouped based on functionality ( probe,open,free,
etc.);e.g., snd_atiixp_free andsnd_intel8x0_free bothbelong
to the group labeled free. Functions within each group are synony-
mous,andare clusteredtogetherinthe Func2vecembedding.
Func2vecis based on the insight that two functions are syn-
onymsifthecontextsinwhichtheyarecalledalongprogrampaths
are similar. Specifically, Func2vecencodes the program as a la-
beledpushdownsystem( ℓ-PDS),wherelabelsrepresentprogram
elementssuchasfunctioncalls,instructions,types,anderrorcodes.
Random walks generated over the ℓ-PDS are used to learn a vector
423
ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA DanielDeFreez,AdityaV.Thakur, andCindy Rubio-González
Figure 1:Function SynonymClusters
embedding using a neural network [ 19].Func2vecis the first te ch-
nique to use static interprocedural program traces to learn a function
embedding that captures thehierarchical structureofprograms.
Using two data sets, we show that Func2vecis capable of accu-
ratelyidentifyingfunctionsynonymsforarunnableLinuxkernel
(2 million LOC). Func2vecis the first to learn a function embedding
forlarge-scale low-level code suchas theLinuxkernel.
As a case study, we apply Func2vecto the problem of mining
error-handlingspecifications intheLinuxkernel.Anerror-handling
specificationliststhefunctionsthatshouldbeexecutedwhenan
erroroccursbasedonthepreviousfunctionscalled.Specification
miningisapopulartechniquewithmanyapplications[ 1,8,30,32].
The number of times a specification occurs in the code is called its
support. To avoid reporting false specifications, only specifications
abovealargesupportthresholdarereported.However,even fora
code base as large as Linux, many true specifications have a low
support[ 30].Furthermore,error-handlingspecificationshavean
even lower support because error-handlingcode isless common.
Thekeyinsightbehindmininghigh-supporterror-handlingspec-
ifications isthat severallow-supportspecifications canbe merged
iftheyinvolvefunctionsynonyms.Ourspecificationminerlever-
agesFunc2vecas well as multiple implementations of Linux file
systems and drivers to obtain mergederror-handling specifications
that have high support; Section 2presents an example.
The contributionsofthis paper are as follows:
•Func2vec, a techniquefor learning afunctionembedding that
captures the hierarchical structure ofprograms (ğ 3).
•Anevaluationoftheeffectivenessof Func2vecforfindingfunc-
tionsynonyms inthe Linux kernel (ğ 4).
•A formulation ofminingerror-handlingspecifications for low-
level systemscode that uses afunction embedding (ğ 5).
•Anevaluationoftheusefulnessof Func2vecforminingmerged
error-handlingspecificationsacross10Linuxfilesystems,and
48 Linux device drivers (ğ 6).
We describe relatedwork inğ 7,andconclude inğ 8.
2 MOTIVATING EXAMPLE
This section illustrates how identifying function synonyms can
be usedtomine error-handlingspecificationsinLinux PCIsound
drivers. Figure 2shows excerpts from the function snd_atiixp_
createin driver atiixp, andsnd_intel8x0_create in driverintel8x0 . Note that the functions look almost identical only be-
cause we have not shown dissimilar code (36 LOC in snd_atiixp_
createand193LOCin snd_intel8x0_create ).
Anerrorhandleriscodethatisexecutedifanerroroccurs;in
Linux, it corresponds to a conditional statement that checks for an
error.Figure 2showserrorhandlersfor snd_atiixp_create and
snd_intel8x0_create (markedH1throughH5).
An error-handling specification imposes requirements on an
errorhandlerbasedonthesetoffunctionsthathavebeenpreviously
called. An error-handling specification is defined as Ce⇒R, where
Cis thecontextandRis theresponse. This specification states that
if the set of functions in the context are successfully called and
an error occurs, then the functions in the response must be called
(usually to release resources acquired by functions in thecontext).
The specification for error handler H2insnd_atiixp_create
(Figure2a)is{pci_enable_device }e⇒{pci_disable_device }.The
samespecificationistrueforerrorhandler H2insnd_intel8x0_
create(Figure2b). Thesupportof the specification is 61 across all
48 Linux device drivers; i.e., there are 61 occurrences that follow
this specification inthe code.
Thespecificationforerrorhandler H4insnd_atiixp_create is
{pci_enable_device,kzalloc,pci_request_regions }e⇒{snd_
atiixp_free }. The support of the specification is only 4. The
specification for the error handler H4insnd_intel8x0_create is
{pci_enable_device,kzalloc,pci_request_regions }e⇒{snd_
intel8x0_free },whichhasthesamecontextasthespecification
foundinatiixpbuthasadifferentresponse.Thisspecificationhas
a support of 7. However, assuming a support threshold of 10, these
two(true)specificationswouldnotbereportedbythespecification
minerdueto theirlowsupport.
Func2vecreports that snd_atiixp_free andsnd_intel8x0_
freeare function synonyms. Thus, the above specifications can be
combinedtoforma mergederror-handling specification.Anerror
handler that supports any one of the specifications in the merge
supports all of the specifications because the functions involved
are synonyms.Consequently, merged specificationshave support
higher than those of the corresponding individual specifications.
Forexample,whenconsidering48devicedrivers, Func2vecfinds
16functionsynonymsfor snd_atiixp_free andsnd_intel8x0_
free.Usingthisinformation,wefindamergedspecificationwitha
supportof80.InLinux,mergedspecificationsoftenresultfromcom-
biningmultiple,similarimplementationssuchasmultipledevice
driversormultiplefilesystems.Ascanbeseen,functionsynonyms
are crucial for findingmergedspecifications withhigh support.
3 FUNC2VEC: PATH-BASEDFUNCTION
EMBEDDING
Func2vecmapsadiscretesetoffunctionstoacontinuousvector
space; that is, given a vocabulary Lof program functions, each
program functionℓ∈Lis mapped to a d-dimensional vector in Rd.
Toaccomplishthis, Func2vecgeneratesalinearizedrepresentation
of programs, viz. łsentencesž over a given vocabulary. Func2vecis
thefirsttousestaticinterproceduralprogrampathsforthispurpose.
Intuitively,ifmanyprogrampathshaveacalltofunction f2after
a call to function f1, and a call to f3after a call to f1, thenf2and
f3should be embeddedclose to eachother.
424Path-BasedFunction Embedding ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA
1585intsnd_atiixp_create( struct snd_card *card){
1595if((err=pci_enable_device(pci) ) < 0) //H1
1596return err;
1597
1598chip = kzalloc( sizeof(*chip),...) ;
1599if(chip == NULL) { //H2
1600 pci_disable_device(pci);
1601return -ENOMEM;
1602}
1609if((err=pci_request_regions(pci) ) < 0){ //H3
1610 pci_disable_device(pci);
1611 kfree(chip);
1612return err;
1613}
1614chip->addr = pci_resource_start(pci, 0);
1622if(request_irq(pci->irq,...)) { //H4
1623dev_err(card->dev, "IRQ␣%d", pci->irq);
1624 snd_atiixp_free(chip);
1625return -EBUSY;
1626}
1632if((err=snd_device_new(card,...) < 0)) { //H5
1633 snd_atiixp_free(chip);
1634return err;
1635}
1639}
(a)Function snd_atiixp_create indriver atiixp2989intsnd_intel8x0_create( struct snd_card *card){
3036if((err=pci_enable_device(pci) ) < 0) //H1
3037return err;
3038
3039chip = kzalloc( sizeof(*chip),...) ;
3040if(chip == NULL) { //H2
3041 pci_disable_device(pci);
3042return -ENOMEM;
3043}
3062if((err=pci_request_regions(pci) ) < 0){ //H3
3063 kfree(chip);
3064 pci_disable_device(pci);
3065return err;
3066}
3179if((err = snd_intel8x0_chip_init()) < 0) { //H4
3180 snd_intel8x0_free(chip);
3181return err;
3182}
3183
3184if(request_irq(pci->irq,...)) { //H5
3185dev_err(card->dev, "IRQ␣%d", pci->irq);
3186 snd_intel8x0_free(chip);
3187return -EBUSY;
3188}
3200}
(b) Function snd_intel8x0_create indriver intel8x0
Figure2:(a)Anexcerptfromthefunction snd_atiixp_create inthedriver atiixp(sound/pci/atiixp.c).The functioncontains
threeerror-handling specifications. Each specification consists of a context set (function calls highlighted in gray) and a re-
sponse set (function calls in a box). The first specification is associated with error handler H2and has a 1-element context
(highlighted in gray) and a 1-element response (in a box). The second specification is associated with error handler H3and
has a 2-element context (highlighted in gray) and a 2-element response (in a box). The third specification is associated with
handlers H4andH5.Ithasa3-elementcontext(highlightedingray)anda1-elementcontext(inabox);(b)anexcerptfromthe
function snd_intel8x0_create in the driver intel8x0 (sound/pci/intel8x0.c) in which threeerror-handling specifications are
alsofound.The specificationsforthetwofunctions differ onlyintheresponse forthethird specification.
A naive approach for linearizing a program is to generate a sen-
tence using the instructions along every valid interprocedural path
in the program. Such an approach has the following disadvantages:
using the entire instruction set would generate sentences with a
verylargevocabulary;therearetoomanyprogrampathsforthis
approachtobepractical;anditdoesnotcapturethehierarchical
structure ofprograms.
Thedesign of Func2vecaddresseseach ofthese disadvantages.
Func2vecabstractseachprograminstructiontoreducethevocabu-
lary. To address the path explosion problem, Func2vecperforms a
randomwalkoftheprogramrestrictedtogenerate γpathsoflength
atmostkstartingatacalltoeachfunction.Lastly,onencountering
a function call, the random walk either outputs the function nameARCHITECTURE Cindy Rubio Gonzalez   |   July 31, 2018
Source 
CodeLLVM
l-PDSRandom 
Walker
Training
Function 
EmbeddingWalks
Source 
CodeLLVM
l-PDS
Random 
WalkerTraining
Function 
Embedding
WalksSource 
CodeLLVM
l-PDSRandom 
WalkerTraining
Function 
EmbeddingWalksSource 
CodeProgram 
Encoder
l-PDSRandom 
WalkerTrainer
Function 
EmbeddingWalks
Source 
CodeProgram 
Encoder
l-PDSRandom 
WalkerModel 
Trainer
Function 
EmbeddingWalks
Figure 3: Func2vecArchitectureitself,ordecidestostepintothefunctiondefinition.Thisstrategy
of the random walk isable to capture the hierarchical structure of
programs: the context preceding the function call can be linked to
either the function call itself or to the context in the body of the
functionbeingcalled.Figure 3showsthethreemaincomponents
ofFunc2vec.
3.1 ProgramEncoder
Apushdownsystem(PDS)isusedtomodelthesetofvalidinter-
procedural paths inthe program[ 26].A PDS is defined as follows:
Definition3.1. Apushdownsystem isatripleP=(P,Γ,∆)where
PandΓare finite sets, control locations andstack alphabet , re-
spectively. A configuration ofPis a pair⟨p,w⟩, wherep∈Pand
w∈Γ∗.∆containsafinitenumberofrules ⟨p,γ⟩֒→⟨p′,w⟩,where
p,p′∈P,γ∈Γ,andw∈Γ∗,whichdefineatransitionrelation ⇒
betweenconfigurationsof Psuchthatif r=⟨p,γ⟩֒→⟨p′,w⟩,then
⟨p,γw′⟩⇒⟨p′,ww′⟩for allw′∈Γ∗. □
cr=⇒c′denotes that the rule r∈∆was used to transition from
configuration ctoc′ofP. To model control flow of a program a
425ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA DanielDeFreez,AdityaV.Thakur, andCindy Rubio-González
1voidpci_disable_device( struct
2 pci_dev *dev) {
3
4struct pci_devres *dr = ...;
5if(dr == NULL) {
6 dr->enabled = 0;
7}
8do_pci_disable_device(dev);
9}
10
11intsnd_atiixp_create(...,
12 struct pci_dev *dev,...) {
13
14struct atiixp *chip = ...;
15if(chip == NULL) {
16 pci_disable_device(dev);
17 return -ENOMEM;
18}
19interr =...;
20if(err < 0){
21 pci_disable_device(dev);
22 kfree(chip);
23 return err;
24}
25chip->addr = ...;
26...
27}
(a)SimplifiedcodefromFigure 2a
atiixp
EQ
pci_disable_device
ENOMEMLT
pci_disable_device
kfreeSTORE
atiixppci_devres
EQ
pci_devres
do_pci_disable_device
snd_atiixp_create kfree
pci_disable_devicen1
n2
n3
n4
n5
n6n7
n8
n9
n10
n11
n12
n13n14
n15
n16n17
n18
n19
n20
n21n22
n23
n24
n25
n26
n27n28
n29
do_pci_disable_device
(b) Graphicalrepresentation of ℓ-PDSRulesfor snd_atiixp_create :
(1)⟨p,n1⟩֒→⟨p,n2⟩:atiixp
(2)⟨p,n2⟩֒→⟨p,n3⟩:EQ
(3)⟨p,n3⟩֒→⟨p,n4⟩
(4)⟨p,n3⟩֒→⟨p,n7⟩
(5)⟨p,n4⟩֒→⟨p,n17n5⟩
(6)⟨p,n4⟩֒→⟨p,n5⟩:pci_disable_device
(7)⟨p,n5⟩֒→⟨p,n6⟩:ENOMEM
(8)⟨p,n6⟩֒→⟨p,ϵ⟩
(9)⟨p,n7⟩֒→⟨p,n8⟩:STORE
(10)⟨p,n8⟩֒→⟨p,n9⟩:LT
(11)⟨p,n9⟩֒→⟨p,n10⟩
(12)⟨p,n9⟩֒→⟨p,n14⟩
(13)⟨p,n10⟩֒→⟨p,n17n11⟩
(14)⟨p,n10⟩֒→⟨p,n11⟩:pci_disable_device
(15)⟨p,n11⟩֒→⟨p,n26n12⟩
(16)⟨p,n11⟩֒→⟨p,n12⟩:kfree
(17)⟨p,n12⟩֒→⟨p,n13⟩
(18)⟨p,n13⟩֒→⟨p,ϵ⟩
(19)⟨p,n14⟩֒→⟨p,n15⟩:atiixp
(20)⟨p,n15⟩֒→⟨p,n16⟩
(21)⟨p,n16⟩֒→⟨p,ϵ⟩
Rulesfor pci_disable_device :
(22)⟨p,n17⟩֒→⟨p,n18⟩:pci_devres
(23)⟨p,n18⟩֒→⟨p,n19⟩:EQ
(24)⟨p,n19⟩֒→⟨p,n20⟩
(25)⟨p,n19⟩֒→⟨p,n22⟩
(26)⟨p,n20⟩֒→⟨p,n21⟩:pci_devres
(27)⟨p,n21⟩֒→⟨p,n23⟩
(28)⟨p,n22⟩֒→⟨p,n23⟩
(29)⟨p,n23⟩֒→⟨p,n28n24⟩
(30)⟨p,n23⟩֒→⟨p,n24⟩:do_pci_disable_device
(31)⟨p,n24⟩֒→⟨p,n25⟩
(32)⟨p,n25⟩֒→⟨p,ϵ⟩
(c)ℓ-PDSrules
Figure 4:Example of ℓ-PDS Encoding
single control location p, and the following three types of rules
r=⟨p,γ⟩֒→⟨p,w⟩are sufficient: (i) internalrules with|w|=1
that model intraprocedural flow; (ii) pushrules with|w|=2 that
model function calls, and (iii) poprules with|w|=0 that model
function returns.
Amostly standard wayofencoding aninterproceduralcontrol-
flowgraph(ICFG)ofaprogramasaPDSisused.Themaindifference
is when a function call is encountered: given a call to function f
whoseentrynodeis efontheICFGedge n1→n2,thePDScontains
boththestandardcallrule ⟨p,n1⟩֒→⟨p,efn2⟩aswellasaninternal
rule⟨p,n1⟩֒→⟨p,n2⟩. This new internal rule is akin to a summary
edge for the called procedure. The addition of this internal rule
allows the random walk used by Func2vec(Algorithm 1) to either
step over orstep intothe functioncall.
A labeled PDS (ℓ-PDS) is a PDS in which each rule is associated
with a sequence of labels,and theselabels are concatenatedas the
ℓ-PDSmakesits transitions.More formally:
Definition 3.2. Alabeled pushdown system (ℓ-PDS) is a triple
L=(P,L,f), whereP=(P,Γ,∆)is a PDS, Lis a finite set of
labels, and f:∆→L∗is a map that assigns a sequence of labels
toeachruleofP.Aconfiguration ofLisapair(c,l),wherecisa
configurationofthePDS Pandl∈L∗.∆andfdefinethetransition
relation⇒lbetween configurations of Lsuch that if cr=⇒c′, then
(c,l)⇒l(c′,ll′),wheref(r)=l′. □
cr=⇒lc′denotes that the rule r∈∆was used to transition from
configuration ctoc′ofL. In practice, labels are only attached
to internal rules of the ℓ-PDS. A unique label is assigned to eachinstructioncategory,errorcode, structtype,andfunction.Each
instructionisabstractedto alistof such labels as follows:
•InstructionsareclassifiedintocategoriessuchasLOAD,STORE,
EQ,etc.Theinternalruleassociatedwithaparticularinstruction
islabeledwiththe corresponding instructioncategory.
•Systems code defines specific constants that are used as error
codes;seeğ 5.Ifsuchanerrorisusedintheinstruction,thenwe
add the error-code label to the corresponding internal rule.
•Iftheinstructionloadsorstorestoa structvariable,thenwe
add thestruct-type label to the corresponding internal rule.
•Iftheinstructionisafunctioncall,thenthefunctionlabeltothe
corresponding internal ruleisadded.
Example3.3. Figure4ashowssimplifiedfunctions pci_disable_
deviceandsnd_atiixp_create (from ğ2). Figure 4bshows a
graphicalrepresentationofthecorresponding ℓ-PDS.Figure 4clists
theℓ-PDS rules; we use the notation r:lto mean that f(r)=l
in theℓ-PDS. The instruction-category labels used in this exam-
ple are {EQ, STORE, LT} (for simplicity, we do not include labels
LOADandRET);the struct-typelabelsare{ atiixp,pci_devres },the
error-code labels are { ENOMEM}, and the function labels are { pci_
disable_device ,kfree,do_pci_disable_device }.
We describe the first 7 rules for the function snd_atiixp_
createin Figure 4c. The internal rule (1) corresponds to line 14
in Figure 4a, where the variable chipof typestruct atiixp is
assigned. Thus, the rule is labeled with struct-type label atiixp.
The internal rule (2) corresponds to the equality expression on
line15,andisattachedtheinstructionlabelEQ.Unlabeledrules(3)
426Path-BasedFunction Embedding ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA
Algorithm1: RandomWalk(L,ℓ,k)
Input:ℓ-PDSL=(P,L,f),startlabelℓ,walklength k
Output:walk={ℓ1,...,ℓn}
1⟨p,n⟩֒→⟨p,n′⟩:l←Random({r:l|r∈∆andℓ∈f(r)})
2c←(⟨p,n′⟩,l)
3forn←0tokdo
4c←Random({c′|cr=⇒lc′for some r∈∆})
5returnLabels(c)
Algorithm2: Func2vec(L,w,d,γ,k)
Input:ℓ-PDSL=(P,L,f), window size w, embedding size d,
walksper label γ,walklength k
Output:Vector representation for labels Φ:L→Rd
1W←∅
2fori←0toγdo
3foreachℓ∈Ldo
4 W←W∪RandomWalk (L,ℓ,k)
5Φ←TrainModel (W,d,w)
and (4) correspond to the trueandfalsebranches of the condi-
tional on line 15. Call rule (5) and internal rule (6) are associated
withthefunctioncall pci_disable_device online16.Notethat
the call rule is not labeled; the internal rule has a function label
pci_disable_device .Finally,rule(7)isgiventheerror-codelabel
ENOMEM,andcorrespondsto the return statementonline 17.■
3.2 Random Walker
Algorithm 1shows how to generate a random walk of an ℓ-PDS.
Given a set S,Random(S)returns an element s∈Sthat is chosen
uniformly at random. Labels(·)returns the sequence of labels as-
sociated with anℓ-PDS configuration. Given an ℓ-PDSL, a start
labelℓ,andawalklength k,arandomwalkisgeneratedasfollows.
A rule associated with label ℓis chosen at random (line 1), and the
configuration cis initialized (line 2). Then, in the loop at line 4the
current configuration cis updated by choosing uniformly at ran-
dom a next configuration in the ℓ-PDS. Note that in Definition 3.2,
labels are concatenatedwhen the configurationisupdated.
Example3.4. Considerlabelℓ=atiixp,andwalklength k=10.
Therearetworulesassociatedwith atiixp:rules(1)and(19)from
Figure4c. Assume rule (1) was chosen and the random walk starts
at rule (1) with label atiixp. Two possible random walks would be:
W1def=atiixpEQpci_disable_device ENOMEM
W2def=atiixpEQpci_devres EQpci_devres do_pci_disable_device .
Duringwalk W1internalrule(6)waschosen,whilewalk W2stepped
intothe functioncallbychoosing the callrule(5). ■
3.3 Model Trainer
Given anℓ-PDSL, a window w, a dimension d, a number of walks
perlabelγ,andawalklength k,Func2vec(Algorithm 2)generates
γwalksforeachlabelin L,andusesthemtotrainthemodel.The
result isavector representation for labels Φ:L→Rd.TrainModel on line5uses a neural network to learn Φ. Tradi-
tional language models try to estimate the probability of seeing
a labelℓigiven the context of the previous labels in the random
walk; viz. Pr/parenleftBig
ℓi|ℓ1,ℓ2,...,ℓi−1/parenrightBig
. Apart from learning the proba-
bility distribution of label co-occurrences, we also want to learn
theembedding: Φ:L→Rd.Thus,ourproblemistoestimatethe
likelihood: Pr/parenleftBig
ℓi|Φ(ℓ1),Φ(ℓ2),...,Φ(ℓi−1)/parenrightBig
. Mikolov et al .[19]in-
troduce a technique that uses a single-layer fully-connected neural
network to approximate this likelihood.It uses a context of size w
both before and after the given word, and considers the context as
a set ignoring the ordering constraint. This results in the the fol-
lowing optimization problem for computing Φ:maximize ΦlogPr/parenleftBig
ℓi|{Φ(ℓi−w),...,Φ(ℓi−1),Φ(ℓi+1),...,Φ(ℓi+w)}/parenrightBig
. The implemen-
tation of Func2vecuses the implementation of Mikolov et al .[19]
providedinGensim [ 25].
4 FUNC2VEC EVALUATION
The experiments in this section are designed to answer the follow-
ingresearchquestions:
RQ1.Howeffectiveis Func2vecatidentifyingfunctionsynonyms?
RQ2. Whatimpact do path-basedsentences have?
Func2vecis evaluated against a runnable Linux kernel with all
filesystemsandPCIsounddriversincluded,roughly2millionLOC.
Theresultingℓ-PDSconsistsof5,407,483stacklocations(nodes),
6,083,632 PDS rules, and 77,194 labels. For this experiment the
number of walks generated per label γwas 100, the walk length
kwas 100, the vector dimension dwas 300, and the window size
wwas10.Settingthewindowsize wto10indicatesawindowof
10+10, where 10 labels in either the forward or backward direction
arewithintheslidingwindow.Theseparameterswerechosenvia
gridsearchoverasmalltrainingsetthatisdisjointfromthegold
standard below. To process the Linux kernel, Func2vecrequires
approximately 24G of memory and two hours of compute time on
Amazon EC2 R4 instances. These instances use Intel Xeon E5-2686
v4(Broadwell) ProcessorsandDDR4 Memory.
Gold Standard. We constructed two gold standard data sets to
evaluateFunc2vec.Thefirstdataset,GS1,consistsof2,652unique
functions that were identified by hand and reviewed with the help
of a Linux kernel developer. These functions form 265 equivalence
classes of function synonyms, ranging in size from two to 94. Note
that the functions in GS1 cross components, can violate naming
conventions,andaregenerallythehardestclassofsynonymstofind.
Specifically,GS1includes6,079functionpairsthataresynonyms,
butdonotfollowanyknownnamingscheme,e.g., nlmsg_trim and
genlmsg_cancel , and 2,279 functions pairs that are notsynonyms,
butdofollowanamingscheme,e.g., sr_release andsd_release .
We constructed a second data set GS2 by relying on a single
strong naming convention. In Linux it is often the case that two
different functions are created that perform essentially the same
task, and one of the functions has underscores prepended to the
name.GS2 consists of the2,017 pairs of functions ofthis form. As
a sanity check, a random sample of 50 pairs was selected and all 50
were judgedto be function synonyms.
Evaluation Metrics. Two different metrics are used to evaluate
Func2vec.ThefirstmetricistheareaundertheReceiverOperating
427ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA DanielDeFreez,AdityaV.Thakur, andCindy Rubio-González
(a)Gold StandardGS1
(b) Gold StandardGS2
Figure 5:ReceiverOperatingCharacteristic (ROC)Curves
Characteristic(ROC)curveforpairsoffunctionsinourgoldstan-
dard, when those pairs are sorted by their cosine similarity. This
evaluates the claim that function synonyms are more similar to each
other than to unrelated functions. For the second metric, the output
ofFunc2vecis clustered using K-Means clustering, and the results
are comparedwiththe gold standardbycomputing the F-score.
Path-Based vs. Flat Comparison. For each metric, the perfor-
mance of the path-based approach used by Func2vecdescribed
in ğ3is compared with a łflatž walker. The flat walker uses an
identicalℓ-PDS, but lists the labels in the order that they appear
in a function instead of generating path-based sentences. All other
parametersandinputsare identicalto the path-basedversion.
Metric 1:ROCCurves. Receiver OperatingCharacteristic (ROC)
curves plot the true positive rate against the false positive rate as a
parametervaries.Theyarecommonlyusedtomeasuretheaccuracy
ofasignaldetector,astheyarewellsuitedforneedle-in-a-haystack
scenarioswheretruepositivesareexpectedtoberelativelyrare[ 18].
That is the case here, where any two function pairs are unlikely
to be synonyms of each other. For the evaluation, a much larger
number of not-synonym pairs are used than synonym pairs, to
mimic this expected distribution. The accuracy of a detector can
be visually gauged by how bowed the curve is. Note that small
changes inthe area underthe curve can hidelarge differences.
TheROCcurvesinFigures 5aand5baregeneratedbysorting
thesimilaritiesinthetwogoldstandarddatasets,respectively,and
thenvaryingtherankcutoff,anapproachusedinLauandBaldwinTable 1:Func2vecMetrics
GoldStandardTest Metric Path-based Flat
GS1:Manuallyreviewed AUROC 0.72 0.56
GS2:Underscore names AUROC 0.81 0.67
GS1:Manuallyreviewed Cluster F1 0.73 0.56
GS2:Underscore names Cluster F1 0.59 0.52
[13]. In essence, function pairs in the gold standard data sets are
sortedandeachpairiscountedaseitheratruepositiveorafalse
positive based on its classification in the gold standard, with the
true positive andfalse positive ratesrecalculatedafter eachpair.
Results. Figure5ashowstheROCcurveproducedwhen Func2vec
isevaluatedagainstourgoldstandarddatasetofmanuallyidenti-
fied function synonyms (GS1). Figure 5bshows the ROC curve pro-
duced when Func2vecis evaluated against our gold standard data
setoffunctionpairsthathaveidenticalnames,onewithprepended
underscores (GS2). The area under each ROC curve (AUROC) is
reportedinTable 1.Theoverallaccuracyof Func2vecishigh,as
evidencedbythesharpriseoftheROCcurves,with Func2vecper-
formingbetterontheeasierunderscorenamesthanthemanually
inspected test set. This answers RQ1. For each of our test data sets,
the path-based walker significantly outperforms the flat walker.
This answers RQ2.
Metric2:K-MeansF-score. Forthesecondmetric,the Func2vec
vectorsareclusteredwithK-Meansandtheresultsarecompared
with theequivalence classes inthegold standard.For eachcluster
Ciand gold standard class Lj, the precision, recall, and F-score are
definedas follows:
Precision (Ci,Lj)=|Ci∩Lj|
|Ci|Recall(Ci,Lj)=|Lj∩Ci|
|Lj|
F(Ci,Lj)=2×Recall(Ci,Lj)×Precision (Ci,Lj)
Recall(Ci,Lj)+Precision (Ci,Lj)
Togetanoverallscorethatcombinesprecisionandrecall,the
F-scoreoverallgoldstandardclassesisused[ 3].Sinceanimperfect
cluster may partially overlap multiple gold standard classes we
computeprecisionandrecallscoresfortheproductofgoldstandard
classes and K-Means clusters. The precision and recall matrices are
combinedintoasingleF-scorematrix,penalizingaclusterforeither
including extra functions or missing functions. The maximum F-
scoreforeachsetofsynonymsinthegoldstandardisused,creating
a mapping between K-Means clusters and gold standard classes.
TheaverageF-scoreoverallclassesinthegoldstandardisreported
here,weightedbythe size of eachgold standardclass.
F=/summationdisplay
iLi
Nmax{F(Ci,Lj)}
Results. Our evaluation of Func2vecshows that it is capable of
clustering functionsynonyms between functions in the Linux ker-
nelwithbothhighprecisionandrecall.TheF-scorenumbersare
reportedinTable 1.TheF-scoreforthepath-basedwalkerishigher
thanthatfortheflatwalker.TheF-scoreforGS1comportswiththe
AUROC. However, the functions in GS2 do not cluster as well as
428Path-BasedFunction Embedding ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USAFunction 
SynonymsSource 
CodeContext / Response 
Extractor
MinerError Handler 
Locator
Specifications
Function 
SynonymsSource 
CodeContext / Response 
ExtractorError Handler 
Locator
Specs Spec Miner
Function 
SynonymsSource 
CodeContext / Response 
ExtractorError Handler 
Locator
Specs Spec Miner
Figure 6:Specification Mining Architecture
those in GS1. After extensive testing, we believe this is a challenge
ofapplyingK-Meansclustering,andthattheAUROCisamorereli-
able metric here. This provides additional evidence for the answers
to RQ1 andRQ2.
Threats to Validity. Identifying function synonyms is an inher-
ently subjective task. We tried to mitigate this as much as possi-
ble by enlisting the assistance of a Linux kernel developer when
constructingourgoldstandard.Multiplepeopleperformedoverlap-
pingclassificationindependently,andanyconflictingclassifications
wereflaggedanddiscussed.Nonetheless,itisnotfeasibletocon-
struct exhaustive ground truth for the Linux kernel, and therefore
itispossiblethat Func2vecwillperformdifferentlyforclassesof
function synonyms we are unaware of.
5 ERROR-HANDLINGSPECIFICATIONS
To show the practical utility of identifying synonymous functions
withFunc2vec, we present a detailed case study exploring their
effectonminingerror-handlingspecifications.Themajorphases
oftheminingprocessare locatingerrorhandlers, extractingerror
handlercontextsandresponses,andfrequentitemsetmining.These
phasesare showninFigure 6anddescribedinthis section.
5.1 DefiningError-HandlingSpecifications
Error-handlingspecificationsareminedbasedontheobservation
that the actions performed after an error occurs (the error-handler
response)frequently dependontheactionscarriedout beforethe
erroroccurred(theerror-handlercontext).Suchacontextandre-
sponse pair definean error-handlingspecification.
ErrorHandlers. Anerrorhandlerisapieceofcodethatisexecuted
upondetectionofanerror.OurevaluationtargetstheLinuxkernel,
which is written in C. Without explicit error-handling language
constructssuchastry/catch,locatingerrorhandlersinCcodemust
relyonsomeamountofdomainknowledge.WeknowthatLinux
defines a specific set of integer error constants, referred to as error
codes. When returned from a function, these error codes denote
that an error has occurred. This is known as the return-code idiom.
Thecontextandresponseof an error handler consist of the func-
tions called before and after an error is detected, respectively. In
many cases, the order in which these functions are called does not
matter.Oncethepredicateassociatedwiththeerrorhandlerisiden-
tified, the context and response are computed via traversing the
code pathsinthe backwardandforwarddirections, respectively.
Example5.1. Thefunction snd_atiixp_create inFigure2acon-
tainsthefiveerrorhandlersH1-H5;whicharelistedinTable 2along
withtheircorresponding contextsandresponses. ■1static struct inode *btrfs_new_inode(...) {
2// Most of the function is omitted
3path = btrfs_alloc_path();
4...
5btrfs_free_path(path);
6ret = ...
7if(ret) {
8// btrfs_free_path not required
9}
10}
Figure 7: Code snippet from the btrfsfile system. The path
isfreed priorto theerrorhandleron line 7is reached.
Error-HandlingSpecifications. Anerror-handlingspecification is
defined as an association rule whose antecedent is the specification
contextandconsequentisthe specificationresponse .Thisrulesimply
means thatthe setoffunction calls inthe contextimplies thatthe
setoffunctioncallsintheresponsearerequiredtohappenoncean
errorisdetected.
Definition 5.2. Anerror-handling specification Sis defined as
CSe⇒RS,whereCS={c1,c2,...,cm}isthecontextsetoffunction
callsforthespecification S,andRS={r1,r2,...,rm}istheresponse
setoffunction calls for the specification S. □
Example 5.3. The following error-handling specifications can be
inferredfor the atiixp sound driver:
S1def={pci_enable_device }e⇒{pci_disable_device }
S2def={pci_enable_device, kzalloc }e⇒{pci_disable_device, kfree }
S3def={pci_enable_device, kzalloc, pci_request_regions }e⇒
{snd_atiixp_free } ■
Definition5.4. Anerror-handlingspecification Sdef=CSe⇒RSis
applicableto anerror-handler H,denotedby S▷H,iffCS⊆CHand
CS∪RS⊈CH, whereCHandRHare the context and response of
the errorhandler H,respectively. □
Example5.5. Considertheerror-handlers H1śH5inEx.5.1and
the specifications in Ex. 5.3; thenS1▷H2,S2▷H3,S3▷H4, and
S3▷H5. ■
The first term CS⊆CHin Definition 5.4says that the entire
specificationcontextmustapplytothehandlercontext.Thesecond
termCS∪RS⊈CHisaddedforcaseswheretherequiredresponse
actionshavealreadyhappenedpriortoaparticularerrorhandler
being reached,as illustratedbythe following example.
Example 5.6. Consider the specification Sdef={btrfs_alloc_
path}e⇒{btrfs_free_path },andthecodesnippetfromthe btrfs
filesystem,showninFigure 7.Thecontext CHfortheerrorhan-
dlerHatline7is{btrfs_alloc_path ,btrfs_free_path }.IfDef-
inition5.4is restricted to only contain the term CS⊆CH, then
specification Sisapplicabletotheerrorhandler H.Clearlythisis
incorrect, as the path has been allocated and then freed prior to
the error handler being reached. Consequently, without the second
term in Definition 5.4, the error handler Hwould be flagged as a
violation, even though the pathhas already been freed. ■
Definition5.7. Anerror-handlingspecification Sdef=CSe⇒RSis
satisfied by an error-handler H, denoted by S▶H, iffS▷Hand
RS⊆RH,whereRHisthe response of H. □
429ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA DanielDeFreez,AdityaV.Thakur, andCindy Rubio-González
Table 2:ErrorHandlers in snd_atiixp_create
ErrorHandler Lines Function Generating Error Context Response
H1 1596 pci_enable_device ∅ ∅
H2 1600-1601 kzalloc {pci_enable_device } { pci_disable_device }
H3 1610-1612 pci_request_regions {pci_enable_device,kzalloc } { pci_disable_device ,kfree}
H4 1623-1625 request_irq {pci_enable_device ,kzalloc,pci_
request_regions }{dev_err,snd_atiixp_free }
H5 1633-1634 snd_device_new {pci_enable_device ,kzalloc,pci_
request_regions ,request_irq }{snd_atiixp_free }
Given an error-handling specification and an error handler, the
miner is able to report a violation of the specification using Defini-
tion5.7.
Example5.8. Considertheerror-handlersinEx. 5.1andthespec-
ifications in Ex. 5.3; thenS1▶H2,S2▶H3,S3▶H4, andS3▶H5.
Ifthecalltofunction snd_atiixp_free online1633inFigure 2a
wasmissing,then S3̸▶H5;i.e.,S3wouldnotbesatisfiedby H5.■
The above definitions of error-handling specifications and satis-
fiability can be extended to handle synonymous functions . LetFbe
thesetoffunctionsintheprogramthatisbeingmined. Π:F→Fis
asaidtobea partitionfunction iffΠ(f1)=Π(f2)forallfunctions f1
andf2thatareidenticalorsynonyms.Weabusenotationslightlyby
extending the partition function that applies to a single function to
a set of functions: Π({f1,f2,...,fn})={Π(f1),Π(f2),...,Π(fn)}.
Similarly,givenanerror-handlingspecification Sdef=CSe⇒RS,we
useΠ(S)to meanΠ(CS)e⇒Π(RS).
Definition 5.9. Given a partition function Π, a setXof error-
handling specifications is said to be a mergederror-handling speci-
fication withrespectto ΠiffΠ(S)=Π(S′)for allS,S′∈X.□
Example 5.10. Letthe partitionfunction Πbe such that
Π(snd_atiixp_free )=Π(snd_intel8x0_free ).Then
{{pci_enable_device, kzalloc, pci_request_regions }e⇒
{snd_attixp_free },{pci_enable_device, kzalloc,
pci_request_regions }e⇒{snd_intel8x0_free }}is a merged
error-handlingspecification withrespectto Π. ■
Using this notation, Definitions 5.4and5.7can be naturally
extendedto mergederror-handlingspecifications.
Definition5.11. Amergederror-handlingspecification Xisap-
plicable to an error-handler H, denoted by X▷H, iff there exists
S∈Xsuch that S▷H. □
Definition 5.12. A merged error-handling specification Xis sat-
isfied byan error-handler H, denoted by X▶H, iff there exists
S∈Xsuch that S▶H. □
5.2 MiningError-HandlingSpecifications
Given a set of error handlers with their respective contexts and
responses, frequent itemset mining is used to infer likely error-
handlingspecifications.Frequentitemsetminingalgorithmstake
the minimum support threshold as a parameter, and return all sets
of items that have a support greater than or equal to this threshold.LetTbe a set of transactions, where each transaction T∈Tis
asetofitems.Afrequentitemsetminingalgorithmreturnsthesets
ofitems that frequently co-occur inthe same transaction in T.
Definition 5.13. Thesupportof a set of items Igiven a set of
transactionsTisdefinedassupp (I)def=|{T∈T|I⊆T}|.□
To construct the merged specifications, frequent itemsets are
mined at a low support threshold. After frequent itemset mining is
performed,specificationsthatusefunctionsynonymsaremerged
together. All pairs of specifications with functions in either the
context orresponse that exceed a similarity threshold are merged.
Set intersection is performed over the remaining items. The transi-
tive closure overthese mergedspecification pairs is taken, yielding
equivalence classes that form the final set of merged specifications.
Thesupportforanunmergedspecificationisidenticaltoitssup-
port as an itemset. However, the support of a merged specification
isnotsimplythesumofthesupportofcorrespondingunmerged
specifications, but the number of uniquetransactions (error han-
dlers)thatsupportthemergedspecification,whichmaybelowerif
the unmergedspecifications share supportingerrorhandlers.
6 SPECIFICATION MININGEVALUATION
This section is designed to answer the following question: what
impactdofunction synonymshave onthe quality ofmined error-
handling specifications?
We mine error-handling specifications in 48 drivers and 10
Linux file systems ( btrfs,ecryptfs ,ext2,ext4,GFS2,HFS,HFS+,
nilfs2,OCFS2, andUFS). We chose Linux filesystems and drivers
because of the dire consequences of error handling defects, but the
mining approach is general and can be applied to other parts of
Linux,ortoanyCprogramthatusesthereturn-codeidiomforerror
handling. Frequent itemset mining is used to infer specifications in
thisevaluation,butfunctionsynonymscouldbeusedtoenhance
otherminingtechniques.
Implementation Details. As shown in Figure 6, our miner takes
asinput(1)errorhandlercontextandresponsesets,and(2)synony-
mous function information. Our implementation relies extensively
ontheLLVMcompilerinfrastructure[ 12].Tolocateerrorhandlers,
weuseanexistingLLVM-basederror-propagationanalysis[ 27ś29],
augmented with an LLVM pass that identifies handlers based on
alistoffunctions that are knownto be calledonlyonerror paths.
Table3showsthetotal numberof errorhandlersfound.Function
synonyms are identified by Func2vec. Eclat/LCM [ 4] is used to
compute frequent itemsets.
430Path-BasedFunction Embedding ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA
Table 3:NumberofErrorHandlers
Impl. #Handlers Impl. #Handlers
btrfs 1990 nilfs2 160
ecryptfs 230 OCFS2 2714
ext2 110 UFS 85
ext4 826 Shared(VFS) 887
GFS2 589 48 sound drivers 3173
HFS/ HFS+ 104 Total 10868
Table4:Specificationsupportimprovementwhenusingsyn-
onyms. The łUn.ž column lists the support for each specifi-
cationwithoutmerging,andthełMrg.žcolumnliststhesup-
port foreachspecification after merging.
Specification Un. Mrg.
{pci_enable_device ,kzalloc,pci_request_regions } 7 80
e⇒{snd_intel8x0_free }
{pci_enable_device ,kzalloc,pci_request_regions } 6 80
e⇒{snd_intel8x0m_free }
{pci_enable_device ,kzalloc,pci_request_regions } 4 80
e⇒{snd_atiixp_free }
{pci_enable_device ,kzalloc,pci_request_regions } 4 80
e⇒{snd_ice1712_free }
{pci_enable_device ,kzalloc,pci_request_regions } 6 80
e⇒{snd_via82xx_free }
{pci_enable_device ,kzalloc}e⇒{snd_nm256_free } 3 124
{pci_enable_device ,kzalloc}e⇒{azx_free } 2 124
{pci_enable_device ,kzalloc}e⇒{snd_ali_free } 2 124
{pci_enable_device ,kzalloc}e⇒{snd_emu10k1x_free } 3 124
{pci_enable_device ,kzalloc}e⇒{snd_ca0106_free } 6 124
{btrfs_alloc_path }e⇒{btrfs_free_path } 487 541
{btrfs_alloc_path }e⇒{btrfs_release_path } 54 541
{gfs2_holder_init }e⇒{gfs2_holder_uninit } 33 74
{gfs2_glock_nq }e⇒{gfs2_glock_dq } 23 74
{gfs2_glock_nq_init }e⇒{gfs2_glock_dq_uninit } 28 74
{hfs_find_init }e⇒{hfs_find_exit } 17 49
{hfsplus_find_init }e⇒{hfsplus_find_exit } 32 49
{__kmalloc }e⇒{kfree} 187 353
{kzalloc}e⇒{kfree} 166 353
Results. Weinspectedallspecificationswithatleastsupport50for
thebtrfs,ext4,GFS2,andOCFS2filesystems,support20forthe
ext2,ecryptfs ,HFS,HFS+,nilfs2,andUFSfilesystems,support
10 for sound drivers, and support 200 for code shared by all imple-
mentations.Beforemerging,thesounddriverresultscontainedonly
10 error-handling specifications above the support threshold, all of
which weredeemed correctby manual inspection.Aftermerging,
therewere31specificationsabovethethreshold,all31beingcorrect.
Beforemerging,thefilesystemresultscontained11error-handling
specificationsabovethesupportthresholds.Aftermerging,there
were 21 specifications above the thresholds, allcorrect.1static int gfs2_get_flags(...) {
2...
3gfs2_holder_init(ip->i_gl, ...);
4error = gfs2_glock_nq(&gh);
5if(error)
6// missing call to gfs2_holder_uninit
7return error;
8...
9gfs2_glock_dq(&gh);
10gfs2_holder_uninit(&gh);
11return error;
12}
Figure8:Bugfoundin GFS2.Thefunctionshouldnotexiton
line7without calling gfs2_holder_uninit .
Examples of Specifications . To further illustrate the impact on
specificationquality, Table 4shows six examples ofmergederror-
handling specifications. The first example shows a specification
foundacrossdevicedrivers(seeğ 2). All18functionsfoundinthe
response sets (e.g., snd_intel8x0_free ,snd_via82xx_free , etc.)
are function synonyms reported by Func2vec(for brevity, we only
list 5 individual specifications). This results in a merged specifi-
cationwithasupportof80.Withoutsynonyms,theseindividual
specifications would not be reportedatallbecausetheyfall below
the support threshold of10.
Not all of the sound driver specifications in Table 4have the
same form. The five specifications in the second row, starting with
snd_nm256_free , are taken from a group of 8 merged specifica-
tions. Unlike the first example, these do not include pci_request_
regions in the context, even though all of these free functions are
synonymsandclosetogetherinthe Func2vecembedding.Thefree
functions in the second row do not call pci_release_regions ,
andtherefore pci_request_regions doesnotappearinanyofthe
contexts.Here,specificationminingand Func2vechaveworkedin
concert to arrive at the correctspecifications.
Thebtrfsexample in Table 4illustrates merging specifications
within a single implementation. btrfs_free_path is a synonym
of the function btrfs_release_path , as the primary purpose of
eachistodropreferencestoapathinthefilesystem.Thedifference
is thatbtrfs_free_path also frees the memory, while callers of
btrfs_release_path handle the memory operation separately.
Mergingtheserelatedspecificationsbringsupthe btrfs_release_
pathversionsothat they appear togetherinthe miningreport.
The specifications shown in the fourth row of Table 4led to the
discovery of two previously unknown bugs in the GFS2file system.
The patch we submitted to fix these bugs was accepted by Red Hat
and mergedinto Linuxversion 4.7.Figure 8shows one ofthe two
bugs.Thefunctionfirstcalls gfs2_holder_init ,whichacquires
a reference to a glock. The function then attempts to enqueue
thisholderstructure.Onthe normalpathwhere gfs2_glock_nq
succeeds, there is no problem. If gfs2_glock_nq fails on line 4,
however, gfs2_holder_uninit is never called even though gfs2_
holder_init completed successfully. As is common with error
handling bugs, only in rare circumstances will this problem be
encountered because it requires gfs2_glock_nq to fail. But when
the bug is triggered the consequences are severe, resulting in an
inaccurate reference count for the glock.
431ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA DanielDeFreez,AdityaV.Thakur, andCindy Rubio-González
ThefifthrowinTable 4showsaspecificationthatcrossestwo
relatedfilesystems,HFSandHFS+.TheHFSandHFS+filesystems
are implemented by Linux to interoperate with Mac OS. Other
relatedfilesystemssuchas ext2andUFSalsocontainspecifications
that can be improvedbymergingwithfunction synonyms.
Finally, the sixth row illustrates how function synonyms can
be useful even for specifications that already have high support.
The function kzallocissimilar to __kmalloc because they both
allocate memory, but kzalloczeroes the memory first. From an
error-handlingperspective they are equivalent.
7 RELATED WORK
Distributed Representations. Distributedrepresentationshave
beenextensivelystudiedinnaturallanguageprocessingandcog-
nition [9]. Recent advances have resulted in scalable approaches
to computing such distributed representations (or vector embed-
dings) given a corpus of sentences; for instance, word2vec [19],
and Glove [ 22]. DeepWalk [ 23] computes vector embeddings of
nodesin a graph. DeepWalk is similar to Func2vecin that they
bothuserandomwalkstogenerateacorpusofsentences.However,
DeepWalk generates walks consisting of nodes, whileFunc2vec
generates walks consisting of labelsalong edges. Func2vecalso
abstractstheprogramcodeintoan ℓ-PDS.Yeetal .[36]applyvector
representations to information retrieval in software engineering
byusingword2vec ondocumentation associatedwithcode.
Nguyen et al . [21]computesdistributed representations of API
functions using word2vec . They generated sentences using the
program AST, as opposed to interprocedural paths, and used their
techniquetomigrateAPIusagesfromJavatoC#.Similarly,Alon
etal.[2]presentsanapproachforlearningprogramrepresentations
using paths in the AST, which is then used to predict names for
variablesandmethodsinJavaScript,Java,Python,andC#programs.
Wang et al . [33]learns program embeddings from program execu-
tion traces, and use the embeddings to classify errors in student
programming assignments written in C#. DeepBugs [ 24] learns
aword2vec -based embedding for each identifier in a JavaScript
programusingthesequenceoftokensaroundtheidentifier.This
embedding is used for name-based bug detection. In contrast to
theseapproaches,weproposeatechniquetolearnafunctionem-
bedding from interprocedural static paths in the program, and use
the embedding in mining error-handling specifications in Linux,
whichiswritten inC.
Error-Handling Specification Mining. One ofthe key develop-
mentsintheerror-handlingspecificationminingliteraturehasbeen
theuseofnormalpathstominespecificationsforerror-handling
paths. This line of thought was first mentioned in [ 35], and was
subsequently usedinseveral otherpapers [ 1,8,30,32,35].
WeimerandNecula [35]findassociationrulesoftheform FCa⇒
FCe,wherefunctioncall FCashouldbefollowedbycall FCe,and
FCeisfoundatleastonceinexception-handlingcode.Improving
on [35], Thummalapenta and Xie [32]mineconditional association
rules of the form (FC1c...FCnc)∧FCa⇒FC1e...FCne, which denotes
asequenceoffunctioncallspriortothetargetfunction FCathat
throws an exception, and then a sequence of recovery function
calls. Acharya and Xie [1]mine error-handling specifications from
interprocedural traces. Cleanup functions are identified from errortraces,whicharethenusedalongwithnormaltracestofindspecifi-
cations.GouesandWeimer [8]broadenthisnotionoftracereliabil-
ity to include a number of other features (e.g., execution frequency,
cloning, code age, density, etc.), and significantly improve the false
positiveratereportedin[ 35].Collectively,theseapproacheshave
beensuccessfulatfindingdefectsinerror-handlingcodethatshares
function calls with normal paths. But there exist functions that are
onlycalledonerrorpaths,andthatareonlymeaningfultoLinux.
Thus the correct use of these functions cannot be deduced from
normal paths or outside programs, and they would be missed by
the above approaches.
Muchoftheworkonerror-handlingspecificationshasfocused
onlanguageswithexception-handlingsupport,suchasJavaorC++.
Severalapproaches[ 5,32,34,35]finderror-handlingspecifications
inJavaprogramsusingstaticanalysis.BuseandWeimer [5]infer
andcharacterizeexception-causingconditions,whicharethenused
asdocumentation.WeimerandNecula [34]usedataflowanalysis
to locate resource management mistakes in error-handling code
andproposealanguageextensiontoimprovereliability.Acommon
mistake found might be the failure to release resources or to clean
up properly along all paths. Identifying blocks of error-handling
code in these languages is comparatively easy, but as we have
shown,itismorechallengingtodistinguishbetweennormaland
error-handlingpathsinLinux.
ImplementationInconsistencies. Engleretal .[6]usethenotion
of internal consistency to find programming errors. One of their
techniquesforfindingrelatedpiecesofcodereliedontheidiomatic
use of function pointers to define multiple implementations of a
single interface. Min et al . [20]compare multiple file systems by
leveraging the VFS interface to identify implementations of the
same functionality.Theseare complementary to our work.
8 CONCLUSION
Weintroducedthenotionof functionsynonyms ,whicharefunctions
that play a similar role in code. Synonymous functions might be
syntacticallydissimilarandmightnotbesemanticallyequivalent.
We presented Func2vec, a technique that learns an embedding
mapping each function to a vector in a continuous vector space
such that vectors for function synonyms are in close proximity.
Specifically, Func2veccomputes a function embedding by training
aneuralnetworkonsentencesgeneratedusingrandomwalksofthe
interproceduralcontrol-flowgraphoftheprogram.Weshowedthe
effectivenessandscalabilityof Func2vecbyevaluatingitagainst
twogold standardsoffunction synonyms inthe Linux kernel.
We showed how Func2veccan improve the quality of error-
handlingspecificationsfor10Linuxfilesystemsand48Linuxde-
vicedrivers.Achallengeinminingerror-handlingspecifications
isthattheirsupportisoftentoolow.Toovercomethischallenge,
Func2vecwas used to identify function synonyms across multiple
implementations of file systems and device drivers. These func-
tion synonyms were then used to merge individual error-handling
specifications,resultinginmergedspecificationswithhighsupport.
ACKNOWLEDGMENTS
This work was supported by NSF grant CCF-1464439, and AWS
Cloud Creditsfor Research.
432Path-BasedFunction Embedding ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA
REFERENCES
[1]MithunAcharyaandTaoXie.2009. MiningAPIError-HandlingSpecifications
from Source Code. In Fundamental Approaches to Software Engineering, 12th
International Conference,FASE2009 (LectureNotes inComputerScience) ,Marsha
Chechik and Martin Wirsing (Eds.), Vol. 5503. Springer, 370ś384. DOI:http:
//dx.doi.org/10.1007/978-3-642-00593-0_25
[2]UriAlon,Meital Zilberstein,OmerLevy,andEranYahav.2018. Ageneralpath-
basedrepresentationforpredictingprogramproperties.In Proceedingsofthe39th
ACMSIGPLANConferenceonProgrammingLanguageDesignandImplementation,
PLDI 2018, Philadelphia, PA, USA, June 18-22, 2018 , Jeffrey S. Foster and Dan
Grossman(Eds.).ACM,404ś419. DOI:http://dx.doi.org/10.1145/3192366.3192412
[3]EnriqueAmigó,JulioGonzalo,JavierArtiles,andFelisaVerdejo.2009. Acom-
parisonofextrinsicclusteringevaluationmetricsbasedonformalconstraints.
Inf. Retr.12, 4 (2009), 461ś486. DOI:http://dx.doi.org/10.1007/s10791-008-9066-8
[4]Christian Borgelt. 2016. Eclat/LCM - Frequent Item Set Mining. http://www.
borgelt.net/eclat.html . (2016). Accessed:2016-04-29.
[5]Raymond P. L. Buse and Westley Weimer. 2008. Automatic documentation
inference for exceptions. In Proceedings of the ACM/SIGSOFT International Sym-
posium on Software Testing and Analysis, ISSTA 2008, Seattle, WA, USA, July
20-24, 2008 , Barbara G. Ryder and Andreas Zeller (Eds.). ACM, 273ś282. DOI:
http://dx.doi.org/10.1145/1390630.1390664
[6]DawsonR.Engler,DavidYuChen,andAndyChou.2001. BugsasInconsistent
Behavior:AGeneralApproachtoInferringErrorsinSystemsCode.In Proceedings
of the 18th ACM Symposium on Operating System Principles, SOSP 2001, Chateau
Lake Louise, Banff, Alberta, Canada, October 21-24, 2001 , Keith Marzullo and
M.Satyanarayanan(Eds.).ACM,57ś72. DOI:http://dx.doi.org/10.1145/502034.
502041
[7]Mark Gabel, Lingxiao Jiang, and Zhendong Su. 2008. Scalable detection of
semantic clones. In 30thInternational Conference onSoftware Engineering (ICSE
2008),Leipzig,Germany,May10-18,2008 ,WilhelmSchäfer,MatthewB.Dwyer,
and Volker Gruhn (Eds.). ACM, 321ś330. DOI:http://dx.doi.org/10.1145/1368088.
1368132
[8]Claire Le Goues and Westley Weimer. 2009. Specification Mining with Few False
Positives.In ToolsandAlgorithmsfortheConstructionandAnalysisofSystems,
15thInternationalConference,TACAS2009(LectureNotesinComputerScience) ,
StefanKowalewskiandAnnaPhilippou(Eds.),Vol.5505.Springer,292ś306. DOI:
http://dx.doi.org/10.1007/978-3-642-00768-2_26
[9]GeoffreyEHinton,JamesLMcclelland,andDavidERumelhart.1986. Distributed
representations,Paralleldistributedprocessing:explorationsinthemicrostruc-
tureof cognition, vol. 1:foundations. (1986).
[10]Mira Kajko-Mattsson. 2005. A Survey of Documentation Practice within
Corrective Maintenance. Empirical Software Engineering 10, 1 (2005), 31ś55.
http://www.springerlink.com/index/10.1023/B:LIDA.0000048322.42751.ca
[11]Raghavan Komondoor and Susan Horwitz. 2001. Using Slicing to Identify Dupli-
cation in Source Code. In Static Analysis, 8th International Symposium, SAS 2001,
Paris, France, July 16-18, 2001, Proceedings (Lecture Notes in Computer Science) ,
PatrickCousot(Ed.),Vol.2126.Springer,40ś56. DOI:http://dx.doi.org/10.1007/
3-540-47764-0_3
[12]ChrisLattnerandVikramS.Adve.2004. LLVM:ACompilationFrameworkfor
LifelongProgramAnalysis&Transformation.In 2ndIEEE/ACMInternational
SymposiumonCode GenerationandOptimization (CGO2004),20-24March2004,
SanJose,CA,USA .IEEEComputerSociety,75ś88. DOI:http://dx.doi.org/10.1109/
CGO.2004.1281665
[13]JeyHanLauandTimothyBaldwin.2016.AnEmpiricalEvaluationofdoc2vecwith
Practical Insightsinto Document Embedding Generation. CoRRabs/1607.05368
(2016). arXiv: 1607.05368http://arxiv.org/abs/1607.05368
[14]Timothy C Lethbridge, Janice Singer, and Andrew Forward. 2003. How software
engineersusedocumentation:Thestateofthepractice. IEEEsoftware 20,6(2003),
35ś39.
[15]Stanley Letovsky. 1987. Cognitive processes in program comprehension. Journal
ofSystemsand software 7,4 (1987), 325ś339.
[16]Walid Maalej, Rebecca Tiarks, Tobias Roehm, and Rainer Koschke. 2014. On the
ComprehensionofProgramComprehension. ACMTrans.Softw.Eng.Methodol.
23,4 (2014), 31:1ś31:37.
[17]LaurensvanderMaatenandGeoffreyHinton.2008. Visualizingdatausingt-SNE.
Journal ofMachineLearning Research 9,Nov(2008), 2579ś2605.
[18]Roy A Maxion and Rachel R Roberts. 2004. Proper use of ROC curves in Intru-
sion/Anomaly Detection .
[19]Tomas Mikolov, Kai Chen, Greg S. Corrado, and Jeffrey Dean. 2013. Efficient
Estimation of Word Representations in Vector Space. (2013). http://arxiv.org/
abs/1301.3781
[20]Changwoo Min, Sanidhya Kashyap, Byoungyoung Lee, Chengyu Song, and Tae-
soo Kim. 2015. Cross-checking semantic correctness: the case of finding file
systembugs.In Proceedingsofthe25thSymposiumonOperatingSystemsPrinci-
ples, SOSP 2015, Monterey, CA, USA, October 4-7, 2015 , Ethan L. Miller and Steven
Hand (Eds.).ACM,361ś377. DOI:http://dx.doi.org/10.1145/2815400.2815422
[21]Trong Duc Nguyen, Anh Tuan Nguyen, Hung Dang Phan, and Tien N. Nguyen.
2017. ExploringAPIembeddingforAPIusagesandapplications.In Proceedingsofthe39thInternationalConferenceonSoftwareEngineering,ICSE2017,BuenosAires,
Argentina, May 20-28, 2017 , Sebastián Uchitel, Alessandro Orso, and Martin P.
Robillard (Eds.). IEEE / ACM, 438ś449. DOI:http://dx.doi.org/10.1109/ICSE.2017.
47
[22]JeffreyPennington,RichardSocher,andChristopherD.Manning.2014. Glove:
Global Vectors for Word Representation. In Proceedings of the 2014 Conference on
EmpiricalMethodsinNaturalLanguageProcessing,EMNLP2014,October25-29,
2014, Doha, Qatar, A meeting of SIGDAT, a Special Interest Group of the ACL ,
AlessandroMoschitti,BoPang,andWalterDaelemans(Eds.).ACL,1532ś1543.
http://aclweb.org/anthology/D/D14/D14-1162.pdf
[23]BryanPerozzi,RamiAl-Rfou,andStevenSkiena.2014. DeepWalk:onlinelearning
ofsocialrepresentations.In The20thACMSIGKDDInternationalConferenceon
Knowledge Discovery and Data Mining, KDD ’14, New York, NY, USA - August 24 -
27,2014,SofusA.Macskassy,ClaudiaPerlich,JureLeskovec,WeiWang,andRayid
Ghani (Eds.).ACM,701ś710. DOI:http://dx.doi.org/10.1145/2623330.2623732
[24]MichaelPradel andKoushikSen.2018. DeepLearningtoFindBugs.(2018). To
appear in Conference on Object-oriented Programming, Systems, Languages,
and Applications, OOPSLA.
[25]Radim Řehůřek and Petr Sojka. 2010. Software Framework for Topic Modelling
withLargeCorpora.In ProceedingsoftheLREC2010WorkshoponNewChallenges
for NLP Frameworks . ELRA, Valletta, Malta, 45ś50. http://is.muni.cz/publication/
884893/en .
[26]ThomasW.Reps,StefanSchwoon,SomeshJha,andDavidMelski.2005. Weighted
pushdown systems and their application to interprocedural dataflow analysis.
Sci. Comput. Program. 58, 1-2 (2005), 206ś263. DOI:http://dx.doi.org/10.1016/j.
scico.2005.02.009
[27]CindyRubio-González,HaryadiS.Gunawi,BenLiblit,RemziH.Arpaci-Dusseau,
andAndreaC.Arpaci-Dusseau.2009. Errorpropagationanalysisforfilesystems.
InProceedingsofthe2009ACMSIGPLAN ConferenceonProgrammingLanguage
Design and Implementation, PLDI 2009, Dublin, Ireland, June 15-21, 2009 , Michael
Hind and Amer Diwan (Eds.). ACM, 270ś280. DOI:http://dx.doi.org/10.1145/
1542476.1542506
[28]CindyRubio-GonzálezandBenLiblit.2010. Expecttheunexpected:errorcode
mismatches between documentation and the real world. In Proceedings of the
9th ACM SIGPLAN-SIGSOFT Workshop on Program Analysis for Software Tools
andEngineering, PASTE’10,Toronto, Ontario, Canada,June5-6, 2010 ,Sorin Lerner
and Atanas Rountev (Eds.). ACM, 73ś80. DOI:http://dx.doi.org/10.1145/1806672.
1806687
[29]Cindy Rubio-González and Ben Liblit. 2011. Defective error/pointer interactions
intheLinuxkernel.In Proceedingsofthe20thInternationalSymposiumonSoftware
TestingandAnalysis,ISSTA2011,Toronto,ON,Canada,July17-21,2011 ,MatthewB.
Dwyer and Frank Tip (Eds.). ACM, 111ś121. DOI:http://dx.doi.org/10.1145/
2001420.2001434
[30]SumanSaha,Jean-PierreLozi,GaëlThomas,JuliaL.Lawall,andGillesMuller.
2013. Hector: Detecting Resource-Release Omission Faults in error-handling
codeforsystemssoftware.In 201343rdAnnualIEEE/IFIPInternationalConference
on Dependable Systems and Networks (DSN), Budapest, Hungary, June 24-27, 2013 .
IEEE Computer Society, 1ś12. DOI:http://dx.doi.org/10.1109/DSN.2013.6575307
[31]Saul Schleimer, DanielShawcrossWilkerson,and AlexanderAiken. 2003. Win-
nowing: Local Algorithms for Document Fingerprinting. In Proceedings of the
2003 ACM SIGMOD International Conference on Management of Data, San Diego,
California, USA, June 9-12, 2003 , Alon Y. Halevy, Zachary G. Ives, and AnHai
Doan(Eds.).ACM,76ś85. DOI:http://dx.doi.org/10.1145/872757.872770
[32] Suresh ThummalapentaandTao Xie. 2009. Miningexception-handlingrulesas
sequence association rules. In 31st International Conference on Software Engineer-
ing,ICSE2009,May16-24,2009,Vancouver,Canada,Proceedings .IEEE,496ś506.
DOI:http://dx.doi.org/10.1109/ICSE.2009.5070548
[33]Ke Wang, Rishabh Singh, and Zhendong Su. 2018. Dynamic Neural Program
EmbeddingforProgramRepair.In InternationalConferenceonLearningRepre-
sentations (ICLR’18) .
[34]Westley Weimer and George C. Necula. 2004. Finding and preventing run-
timeerrorhandlingmistakes.In Proceedingsofthe19thAnnualACMSIGPLAN
ConferenceonObject-OrientedProgramming,Systems,Languages,andApplications,
OOPSLA 2004, October 24-28, 2004, Vancouver, BC, Canada , John M. Vlissides and
DouglasC.Schmidt(Eds.).ACM,419ś431. DOI:http://dx.doi.org/10.1145/1028976.
1029011
[35]WestleyWeimerandGeorgeC.Necula.2005. MiningTemporalSpecifications
forError Detection. In ToolsandAlgorithms fortheConstruction andAnalysisof
Systems,11thInternationalConference,TACAS2005(LectureNotesinComputer
Science), Nicolas Halbwachs and Lenore D. Zuck (Eds.), Vol. 3440. Springer, 461ś
476.DOI:http://dx.doi.org/10.1007/978-3-540-31980-1_30
[36]Xin Ye, Hui Shen, Xiao Ma, Razvan C. Bunescu, and Chang Liu. 2016. From
wordembeddingstodocumentsimilaritiesforimprovedinformationretrieval
insoftwareengineering.In Proceedingsofthe38thInternational Conferenceon
Software Engineering, ICSE 2016, Austin, TX, USA, May 14-22, 2016 , Laura K.
Dillon, Willem Visser, and Laurie Williams (Eds.). ACM, 404ś415. DOI:http:
//dx.doi.org/10.1145/2884781.2884862
433