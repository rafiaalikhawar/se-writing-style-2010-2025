Migrating Cascading Style Sheets to Preprocessors
by Introducing Mixins
Davood Mazinanian, Nikolaos Tsantalis
Computer Science and Software Engineering
Concordia University, Montreal, Canada
{d_mazina, tsantalis}@cse.concordia.ca
ABSTRACT
Cascading Style Sheets ( CSS) is the standard language for
styling web documents and is extensively used in the indus-
try. However, CSSlacks constructs that would allow code
reuse (e.g., functions). Consequently, maintaining CSScode
is often a cumbersome and error-prone task. Preprocessors
(e.g.,LessandSass) have been introduced to ﬁll this gap,
by extending CSSwith the missing constructs. Despite the
clear maintainability beneﬁts coming from the use of prepro-
cessors, there is currently no support for migrating legacy
CSScode to preprocessors. In this paper, we propose a
technique for automatically detecting duplicated style dec -
larations in CSScode that can be migrated to preproces-
sor functions (i.e., mixins). Our technique can parameter-
ize diﬀerences in the style values of duplicated declarations ,
and ensure that the migration will not change the presen-
tation semantics of the web documents. The evaluation has
shown that our technique is able to detect 98% of the mix-
insthat professional developers introduced in websites and
Style Sheet libraries, and can safely migrate real CSScode.
CCS Concepts
•Software and its engineering →Software mainte-
nance tools; Maintaining software;
Keywords
Cascading style sheets, refactoring, duplication, migration
1. INTRODUCTION
Cascading Style Sheets is one of the three fundamental
technologiesinfront-endwebdevelopment(alongwith HTML
andJavaScript ), whichisusedfordeﬁningthepresentation
of documents written in a markup language (e.g., HTML).
Currently, CSSis used in more than 91% of top 10 million
websites in the Alexa ranking [42], and by more than 90% of
front-end web developers [32]. Recently, CSSstarted being
used in a wider spectrum of application domains, includingmobile app UI design (e.g., Apache Cordova, Adobe Phone-
Gap), desktop app styling (e.g., WinJS, GTK+), and Inte-
grated Development Environment theming (Eclipse4/CSS).
Despite its popularity, developing and maintaining CSS
code is a cumbersome task [19, 15, 31]. Among others, two
main reasons for this complexity are 1) the inherent limi-
tations of the language to support reuse, and 2) the lack
of well-documented and empirically validated best practices .
As an example, in CSSthere is very limited support for con-
structs that can facilitate the DRY (don’t-repeat-yourself)
principle, since functions and variables are not supported.
Consequently, style declarations (i.e., statements in CSS
that deﬁne a style, like font-weight: bold ) are extensively
duplicated in CSScode. In a previous work [30], we found
that 40-90% of CSSstyle declarations are duplicated in
modern web applications. This extensive duplication can
deﬁnitely impose high development and maintenance costs.
CSSpreprocessors have emerged as the de-facto solution
to complement “vanilla” CSSby adding the missing con-
structs, which are available in traditional programming lan-
guages (e.g., variables and functions), and thus expedite the
development and maintenance of Style Sheets. The use of
preprocessors is a trend in the industry [9, 41], and leading
web companies have already adopted them. Some exam-
ples of popular preprocessors are Less(used by Twitter),
Sass, Google Closure Style Sheets, and Stylus. Despite the
gradual adoption of preprocessors in the web development
community, thereisstillalargeportionoffront-enddevelop-
ers and web designers using solely“vanilla” CSS. An online
poll with nearly 13,000 responses from web developers [9]
revealed that 46% of them develop only in “vanilla” CSS,
mostly because they are not aware of preprocessors.
Therefore, there is a large community of web developers
that could beneﬁt from tools helping them to automatically
migrate their “vanilla” CSScode to a preprocessor of their
preference. In addition, the community of CSSpreprocessor
developers could beneﬁt from tools helping them to utilize
more eﬀectively the features oﬀered by the preprocessors.
As a matter of fact, in this study we found several cases
where professional developers under-utilize preprocessors.
This is the ﬁrst work to investigate the automatic extrac-
tion of duplicated style declarations in CSS, into function-
like constructs in CSSpreprocessors (i.e., mixins), enabling
thereuseof existing CSScode. Using mixinscan also im-
prove the readability of Style Sheets by assigning descriptive
names to them. According to our previous study [29], de-
velopers introduce mixinsmostly for reusing code in Style
Sheets (63% of the mixinswere called more than once in the
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciﬁc permission and/or a
fee. Request permissions from Permissions@acm.org.
ASE’16 , September 3–7, 2016, Singapore, Singapore
c2016 ACM. 978-1-4503-3845-5/16/09...$15.00
http://dx.doi.org/10.1145/2970276.2970348
672
code base of each project), but also for breaking long style
rules in smaller code fragments, or simply improving code
readability. The proposed approach for abstracting dupli-
cated style declarations to mixinsis one of the fundamental
requirements for developing a full-ﬂedged recommendation
system that can help developers to migrate existing CSS
code to preprocessors, or even improve the maintainability
of a preprocessor code base by eliminating duplication. This
work makes the following contributions:
•We propose a method for detecting opportunities to au-
tomatically extract mixinsfrom existing CSScode. The
approach is preprocessor-agnostic, i.e., it is applicable for
allCSSpreprocessors supporting the notion of mixins;
•We propose a method for assuring that the presentation
semantics of theCSScode are preserved after migration;
•We conduct an empirical study with real websites and
Style Sheet libraries using preprocessors to verify the cor-
rectness and eﬀectiveness of our approach.
2. PRELIMINARIES
2.1 The CSS Language
Style Sheets let developers apply styles to some elements
of one or more target documents (e.g., making all hyperlinks
in anHTMLpage blue and under-lined). CSShas a very
simple syntax, as shown in Figure 1.
Style declarationSelector
Style propertiesStyle values
 p {
font-weight : bold;
}border-bottom : solid 1px #ccc ;
Figure 1: A style rule in CSS Syntax
Astyle rule (i.e.,rule-set) is a fundamental building block
ofCSSﬁles. It consists of a selector, which deﬁnes the
elements of the target documents to be styled (e.g., pfor se-
lecting all paragraphs). Inside the body of a style rule there
are some style declarations , each of which assigns some
style value to astyle property (e.g., assign style value bold
to property font-weight to make the text of the selected
elements bold-faced).
Speciﬁcity and Cascading: InCSS, when two or more
diﬀerent style declarations assign a value to the same prop-
erty of a DOM element in the target document, the web
browser has to decide which style declaration has a prece-
dence over the others. In such a case, the style declaration
belonging to a style rule with a more speciﬁcselector wins
(i.e., its style value overrides the value of the other declara-
tions). Forinstance, selector aselectsallhyperlinkelements,
while selector p aselects only the hyperlink elements, which
are children of paragraph elements ( aandpare both CSS
predeﬁned selectors selecting the <a>and<p>tags in target
HTMLdocuments, respectively). Thus, the style declara-
tions inp awill override the ones in a, because the latter is
more speciﬁc than the former.
On the other hand, in the case that two style rules have
selectors with the same speciﬁcity, the order of style rules
will decide the winning style declaration, i.e., the style dec-
laration in a style rule appearing later in the CSSﬁle will
override the style values of the previous declarations (the so-
calledcascading feature of CSS). However, developers can
use the!important rule (e.g., color: red !important ) toforceadeclarationtoalwaysoverrideotherdeclarationswith
the same property, regardless of the speciﬁcity and location
of the style rule it belongs to. Using !important is a bad
practice in Style Sheet development, but Style Sheet devel-
opers considerably use it [16]. As we will see, when detecting
mixinmigration opportunities, the use of !important has
implications that should be taken into account.
2.2 CSS Preprocessors
As mentioned before, CSSpreprocessors were introduced
to address the limitations associated with CSS. Preproces-
sorsareactuallysource-to-sourcecompilers(i.e., transpilers ).
In other words, they compile the Style Sheet written in their
syntax to“vanilla” CSS, allowing the clients to directly use
the generated Style Sheets without requiring any server-side
processing. This transpilation can be also performed on de-
mand, i.e., when a user requests to view a web page.
Most of the CSSpreprocessors extend the syntax of CSS
to make easier their adoption by CSSdevelopers. There is a
setofcommonfeaturesthatalmostallpopularpreprocessors
support. Because of space limitation, we cannot describe all
these features in this paper (the reader may refer to [29], or
the documentation of CSSpreprocessors [6, 37]). However,
we need to brieﬂy mention the two main features of CSS
preprocessor languages that can be used for eliminating du-
plicated style declarations in Style Sheets:
Extend is a mechanism that enables the reuse of style dec-
larations across style rules. The extending style rule in-
herits all style declarations of the extended style rule, and
can optionally override some of the inherited style declara-
tions in order to change their style values This mechanism
is similar to inheritance in the object-oriented paradigm.
Mixinis a function-like construct containing a set of style
declarations, optionally with parameterized style values. A
mixinis usually called inside the body of a style rule or
another mixinby passing style values as arguments for its
parameters. A mixinparameter may have a default value,
allowing to omit the corresponding argument.
Inthecaseofexactlyduplicatedstyledeclarationsacrossdif-
ferent style rules, one may use either the extendconstruct
or a parameterless mixinfor eliminating duplication. How-
ever, our previous study [29] revealed that developers prefer
to use parameterless mixinsover the extendconstruct (28%
of the 100 analyzed websites exclusively used parameterless
mixins, whileonly9%usedthe extendconstruct). Thispref-
erenceto mixinsisprobablyduetothe styling bugs thatmay
be caused by the incautious use of the extendconstruct [29].
Indeed, the grouping of selectors in CSS, or equivalently the
use of the extendconstruct in preprocessors, might change
theorder dependencies that exist among the style rules, and
thuschangethepresentationofthetargetdocument(i.e., in-
troduce a styling bug) [30]. Additionally, mixinsprovide a
more powerful reuse mechanism by allowing to parameter-
ize the values of style properties. Therefore, in this work,
we propose an approach for detecting mixinopportunities
inCSScode that can help developers to easily migrate to a
preprocessor of their preference.
2.3 Mixins
CSSpreprocessor mixinsare equivalent to functions in
traditional programming languages, and usually contain a
set of style declarations or other mixincalls. The values
of these declarations can be literals (e.g., color or numeric
673values), expressions involving variables, or calls to CSSpre-
processor built-in functions. Just like functions, mixinscan
have one or more parameters, which can be used in the place
of style declaration values. Figure 2a shows a preprocessor
code snippet in Lesssyntax, containing three style rules,
namely.s1,.s2and.s3, and a mixindeclaration .m1,
which is called in style rules .s1and.s2.
When the piece of preprocessor code shown in Figure 2a
is transpiled to CSS, the code shown in Figure 2b is gen-
erated. As it can be observed, the mixincalls are replaced
with the style declarations of the called mixin, and the pa-
rameterized values are replaced with the arguments passed
in the corresponding mixincall.
Mixin
declarationMixin calls
.s1 {
  text-align : center;
  .m1(8pt; Tahoma; 100px);
}
.s2 {
  float: left;
  .m1(10pt; Arial; 70px);
}
.s3 {
  float: right;
  font: 9pt Tahoma
}
.m1(@fontS; @fontN; @colW) {
  font: @fontS @fontN;
  -moz-columns : @colW 3;
  columns : @colW 3;
}
(a) Preprocessor Code
.s1 {
 text-align: center;
 font: 8pt Tahoma ;
 -moz-columns : 100px 3;
 columns : 100px 3
}
.s2 {
 float: left;
 font: 10pt Arial ;
 -moz-columns : 70px 3;
 columns : 70px 3;
}
.s3 {
 float: right;
 font: 9pt Tahoma
} (b) Genereated CSS
Figure 2: Mixin example
In Figure 2a, the mixin.m1contains three style declara-
tions, assigning values for properties: font,-moz-columns
andcolumns. The two latter properties are called vendor-
speciﬁcproperties, and are used to style the same property
for diﬀerent web browsers, e.g., the ones with -moz-preﬁx
will only work for Mozilla Firefox. Web browsers usually
support this kind of properties before they are fully stan-
dardized, because the standardization process is time con-
suming. As a result, developers have to repeat the dec-
laration of the same property with diﬀerent vendor pre-
ﬁxestoachieveaconsistentpresentationacrossmultipleweb
browsers. Indeed, we previously found that developers tend
to usemixinsfor grouping style declarations associated with
vendor-speciﬁc properties [29].
3. AUTOMATIC EXTRACTION OF MIXINS
Our approach for detecting mixinmigration opportunities
isbasedoneliminatingduplicationatthelevelofstyle dec la-
rations, and consists of four main steps, which are explained
in the following subsections.
3.1 Grouping Declarations for Extraction
The ﬁrst step of our approach is to ﬁnd sets of style rules
sharing one or more style declarations styling the same prop-
erties. The tuple /an}bracketle{tS,P/an}bracketri}ht, whereSis a set of style rules shar-
ing a set of style properties Pis considered as a mixin mi-
gration opportunity .
For example, to reverse-engineer the CSScode of Figure
2b to the preprocessor code of Figure 2a, we would need
to group the declarations corresponding to font,columns
and-moz-columns properties from style rules .s1and.s2
and extract these declarations into mixin.m1after param-
eterizing the property values being diﬀerent. In this case,
S1={.s1,.s2}andP1={font,columns,-moz-columns }.There are, however, other mixinmigration opportunities in
the code fragment of Figure 2b; e.g., S2={.s1,.s2,.s3}
andP2={font}.
It should be emphasized that for a given property p∈P
the grouped style declarations should have the same impor-
tance. As mentioned, using the !important rule makes a
declaration to have precedence over other declarations as-
signing a value to the same property. As a result, the im-
portance of the involved declarations should be kept intact
when forming a mixin, to make sure that the presentation
of target documents will be preserved after migration. Con-
sequently, we avoid the grouping of declarations having a
diﬀerent importance (i.e., either all or none of the grouped
declarations may use the !important rule).
Anaiveapproachforﬁndingtherepeatedpropertieswould
be toexhaustively generateallpossible combinationsofstyl e
properties and then examine if they appear together in two
or more style rules. However, this would certainly lead to a
combinatorial explosion, due to the large percentage of du-
plication in CSSﬁles. According to [30], on average, 66% of
the style declarations in Style Sheets are duplicated at least
once (i.e., they share the same property and value with an-
other style declaration). For detecting mixinmigration op-
portunities, the constraint that property values should be
identical or equivalent is not necessary, since mixinsallow
the parameterization of diﬀerences in the property values.
This results to an even larger percentage of declarations
that can be potentially grouped to form a mixin, making
the exhaustive generation inapplicable.
We managed to overcome this issue by treating the initial
problem as a frequent itemset mining problem [39]. In the
dataminingliterature, thereareeﬃcientalgorithmsforﬁnd-
ingthesetsof itemsinadatabase(i.e., itemsets)thatappear
together insor more transactions, where sis theminimum
support count . In our approach, we treat a Style Sheet as
a transactional database. Each style rule is a transaction,
and each property corresponding to a style declaration is
an item. Therefore, a frequent itemset is a set of proper-
tiesPthat appear together in a set of style rules S, where
|S| ≥s. In our work, we set sto two (i.e., the smallest
possible value). We selected this value because we have em-
pirically shown that the median number of times a mixinis
called in real-world CSSpreprocessor code is two [29]. We
adopted the FP-Growth [18] algorithm, because it is con-
sidered eﬃcient and scalable. Applying the FP-Growth
algorithm to the CSScode of Figure 2b will result in the
output shown in Table 1.
Table 1: Frequent itemsets of style properties
|P|S P
1{.s1, .s2}{-moz-columns}
{.s1, .s2}{columns}
{.s2, .s3}{float}
{.s1, .s2, .s3}{font}
2{.s1, .s2}{columns, -moz-columns }
{.s1, .s2}{columns, font}
{.s1, .s2}{-moz-columns, font }
{.s2, .s3}{font, float}
3{.s1, .s2}{font, columns, -moz-columns }
Each row (itemset) in Table 1 constitutes a separate mixin
migration opportunity. The mixin.m1in Figure 2a corre-
sponds to the last itemset of the table, and it subsumes the
ﬁrst three itemsets with |P|= 2, which in turn subsume the
two ﬁrst itemsets with |P|= 1.
674.s1 {
 float: left;
 will-change : transform ;
 border: #f00 1px solid ;
}
.s2 {
 color: red;
 border: dotted red thin ;
}(a) Original CSScode
.mixin(@v1; @v2; @v3) {
  border : @v1 @v2 @v3;
}
 
.s1 {
  float: left;
  will-change : transform ;
  .mixin( #f00; 1px; solid);
}
 
.s2 {
  color: red;
  .mixin( dotted; red; thin);
} (b) Fine-grained parameters
.mixin(@values) {
  border : @values;
}
 
.s1 {
  float: left;
  will-change : transform ;
  .mixin( #f00 1px solid );
}
 
.s2 {
  color: red;
  .mixin( dotted red thin );
} (c) Coarse-grained parameter
.mixin(@style) {
  border : #f00 1px  @style;
}
 
.s1 {
  float: left;
  will-change : transform ;
  .mixin( solid);
}
 
.s2 {
  color: red;
  .mixin( dotted);
} (d) Minimal parameters
Figure 3: Alternative ways for extracting a mixin
3.2 Detecting Differences in Style Values
For a given mixinmigration opportunity /an}bracketle{tS,P/an}bracketri}ht, we need
to check for every property p∈P, if the corresponding style
declarations have diﬀerent (i.e., non-equivalent) values. Fo r
each diﬀerence in the property values, a parameter should
be introduced in the resulting mixin. However, the param-
eterization of diﬀerences can be achieved in several alterna-
tive ways. As an example, consider the CSScode shown
in Figure 3a that contains two style rules for selectors .s1
and.s2, respectively. Both selectors style property border,
which is a well-known shorthand property allowing to set
the values of several other CSSproperties simultaneously,
such asborder-width ,border-style , andborder-color .
In addition, some shorthand properties do not force a spe-
ciﬁc order for the values of the properties they group. As a
result, in selector .s1thebordershorthand styles ﬁrst the
border-color with#f00, then the border-width with1px,
and ﬁnally the border-style withsolid, while in selector
.s2the order is diﬀerent starting ﬁrst with border-style
followed by border-color andborder-width .
In this particular example, and in all the cases involving
shorthand properties, there are three possible ways to pa-
rameterize the diﬀerences in property values:
1. Introduce a separate parameter for each pair of diﬀer-
ent values in the order they appear in the corresponding
shorthand property declarations (Figure 3b). This ap-
proach has two main limitations. First, it may introduce
parameters for properties using diﬀerent kinds of values.
The variables and parameters in CSSpreprocessors do
nothaveatype, andthusitispossibletohaveparameters
accepting arguments of diﬀerent value kinds. However, it
will be extremely diﬃcult for a developer to understand
and reuse a mixinhaving parameters that can take values
for semantically diﬀerent properties (e.g., a property that
should be styled with color values, and a property that
should be styled with dimension values). Second, such an
approach may lead to mixinswith an unnecessarily long
parameterlist, whichis considered acode smell [13], since
it makes more diﬃcult to call and reuse such mixins. In
a previous work [29], we showed that developers mostly
tend to create mixinswith zero or one parameter (68%
of themixinshave either one or no parameters).
2. Introduceasinglemulti-valueparameterforallindividual
properties grouped by the corresponding shorthand prop-
erty (Figure 3c). Although this approach gives more ﬂex-
ibility to the developer when calling the mixin, it is also
more error-prone, because the developer needs to know
very well the CSSdocumentation regarding the individ-ual property values that are mandatory and those that
can be omitted (i.e., optional values), or the order of the
individual property values. Inexperienced CSSdevelop-
erswouldneedtospendtimestudyingthedocumentation
in order to properly call a mixinwith such parameters.
3. Introduce a parameter for each pair of matching individ-
ual properties having non-equivalent values in the cor-
responding shorthand property declarations (Figure 3d).
In the example shown in Figure 3a, the matching individ-
ual properties between the two selectors are represented
with arrows. The dashed-line arrows indicate properties
with equivalent values (e.g., the named color redand the
hexadecimal color #f00are not lexically identical, but
are alternative representations for the same color). The
solid-line arrows indicate properties with non-equivalent
values that should be parameterized. This approach has
two main advantages over the other approaches. First, it
introduces a minimal number of parameters compared to
the ﬁrst approach, when some individual properties are
styled with identical or equivalent values (regardless of
the order they appear in the shorthand property decla-
rations). Second, it allows to introduce parameters with
moresemantically expressive names compared to the sec-
ond approach, since the names of the matching individual
properties can be used as parameter names (e.g., @style
parameter in Figure 3d corresponding to the individual
property border-style ).
3.2.1 Inferring Individual Style Properties
In our approach, we adopted the last parameterization
strategy discussed in the previous section due to its advan-
tages over the other two strategies. To implement this strat-
egy, we ﬁrst need to infer the individual style property (ISP)
corresponding to each style value that appears within the
style declarations for the set of properties Pdeclared in the
set of selectors S. AnISPrepresents the roleof a style value
in a style declaration, and corresponds to the actual individ-
ual style property this value is being assigned to. Table 2
shows the ISPsthat are assigned to the values of the border
style declarations in the example of Figure 3a. For instance,
the pair of values corresponding to colors ( #f00andred)
are both assigned to the same ISP, which is the individual
property border-color .
For the style properties that can accept only a single value
(e.g.,color,float), theISPassigned to their values is the
same as the style property name. For shorthand properties
(e.g.,border,background ,columns), we refer to the CSS
speciﬁcations [43] for assigning an ISPto each one of their
675Table 2: Individual Style Properties (ISPs)
Declaration Style Value ISP
border: #f00 1px solid#f00 "border-color"
1px "border-width"
solid "border-style"
border: dotted red thindotted "border-style"
red "border-color"
thin "border-width"
values. In our implementation, we have coded ISPsfor 47
multi-valued and shorthand CSSproperties, which account
for all major CSSproperties used in Style Sheets. When
comparing two declarations for parameterizing the diﬀer-
ences in their values, we compare each pair of values cor-
responding to the same ISP. We follow the same approach
used in [30] for examining whether two values are equivalent.
Optional (omitted) values: InCSS, some properties can
haveoptional values. For instance, the property fontcan
accept 7 style values, while developers may omit 5 of them.
In the case of omitted values, web browsers follow the CSS
speciﬁcations to compute them. In some cases, they assign
initial(i.e., default) values to the omitted values. In other
cases, the omitted value is calculated based on another ex-
plicitly given value. Following the same approach, for every
omitted value we actually compute a virtual value , and also
assign the appropriate ISPto it. This allows parameteriz-
ing declarations having an unequal number of style values,
e.g.,font: bold 10pt Tahoma andfont: 18pt Arial . In
this example, the ﬁrst declaration is styling the font-weight
ISPwith the explicitly-deﬁned value bold, while the second
one styles the same ISPwith the default value normal.
Shorthand vs. individual properties: Another possible
scenario is having some selectors taking advantage of short-
hand properties, while other selectors are instead declaring
separately individual properties.
Consider the CSSexample shown in Figure 4a. Style rule
.s1contains four separate style declarations for the individ-
ual properties margin-top ,margin-right ,margin-bottom ,
andmargin-left , while style rule .s2contains a single style
declaration for the shorthand property margin. Note that,
thelastvalueinthe margindeclarationisomitted(i.e., there
are three values instead of four). This value corresponds to
themargin-left ISP, and based on the CSSspeciﬁcations,
it should take the margin-right value (i.e., 5px) when it is
omitted. To enable the detection of mixinmigration oppor-
tunities in such cases, we are collapsing the sets of individ-
ual property declarations that can be grouped into virtual
shorthand declarations . In this way, it is possible to ﬁnd
mixinmigration opportunities between selectors either hav-
ing actual or virtual shorthand declarations, and thus the
CSSexample shown in Figure 4a can be migrated to use
themixinshown in Figure 4b.
3.3 Introducing a Mixin in the Style Sheet
In this section, we describe an algorithm that takes as
input amixinmigration opportunity MO=/an}bracketle{tS,P/an}bracketri}htto gen-
erate amixindeclaration and update the style rules in set
Sto call the new mixinpassing the appropriate arguments.
In Algorithm 1, we use the following helper functions.
Function getISPsWithNonEquivalentValues returnsthe ISPs,
which are deﬁned in the style declarations (declared inside
the style rules in set S) corresponding to property pand
have non-equivalent values.
.s1 {
 ...
 margin-left : 5px;
 margin-right : 5px;
 margin-top : 3px;
 margin-bottom : 3px;
 ...
}
.s2 {
 ...
 margin: 2px 5px 1px ;
 ...
}(a) Original CSS
.mixin(@mtop; @mbottom) {
  margin : @mtop 5px @mbottom 5px;
}
 
.s1 {
  ...
  .mixin( 3px; 3px);
  ...
}
 
.s2 {
  ...
  .mixin( 2px; 1px);
  ...
} (b) Extracted mixin
Figure 4: mixinfor shorthand/individual properties
Function generateStyleDeclarationTemplate generates
a style declaration template for property pwith a place-
holder (i.e., an unknown value) for each ISPdeﬁned in the
style declarations (declared inside the style rules in set S)
corresponding to property p. The template will essentially
contain a mapping of ISPsto style values or variables (i.e.,
mixinparameters) after the execution of the algorithm.
Finally, function getStyleDeclaration returns the style
declaration corresponding to property pdeclared inside style
rules, and function getStyleValue returns the style value
corresponding to an ISPdeﬁned in style declaration d.
Algorithm 1: Algorithm for introducing a mixin
Input : Amixinmigration opportunity MO=/an}bracketle{tS,P/an}bracketri}ht
Output : Amixindeclaration M=/an}bracketle{tMp,Md/an}bracketri}ht
A mapping of selectors to lists of mixinarguments
1Mp←∅// the ordered set of mixinparameters
2Md←∅// the ordered set of mixinstyle declarations
3foreach s∈Sdo
4Ma(s)←∅// the list of mixinarguments for s
5end
6foreach p∈Pdo
7diﬀerences←getISPsWithNonEquivalentValues( p,S)
8template←generateStyleDeclarationTemplate( p,S)
9foreach ISP∈template .ISPsdo
10 ifISP∈diﬀerences then
11 param←newMixinParameter( ISP)
12 Mp←Mp∪param
13 ISP/mapsto→param// map ISP to mixinparameter
14 foreach s∈Sdo
15 d←getStyleDeclaration( p,s)
16 arg←getStyleValue( ISP,d)
17 Ma(s)←Ma(s)∪arg
18 end
19 end
20 else
21 s←S0// get the first style rule in S
22 d←getStyleDeclaration( p,s)
23 value←getStyleValue( ISP,d)
24 ISP/mapsto→value// map ISP to common value
25 end
26 end
27 Md←Md∪template
28end
Generating mixin declaration: In order to create the
mixindeclaration, the algorithm generates a style declara-
tion template (line 8) for each property pin the set of style
properties P. Function generateStyleDeclarationTemplate
goesthroughalldeclarationsstyling pinthesetofstylerules
Sand ﬁnds the union of ISPsthat are assigned with values.
This approach can guarantee that all aﬀected ISPswill be
present in the template, even if some style declarations omit
the deﬁnition of optional values. Next, for each ISPin the
template, the algorithm checks if the assigned style values
are equivalent or not. If the values are diﬀerent, the ISPis
mapped to a new mixinparameter, which is also added to
the parameter list of the mixindeclaration. Otherwise, the
676ISPis mapped to the commonly assigned value in all style
rules. Finally, the resulting template after the mapping of
allISPsis added to the list of style declarations inside the
body of the mixindeclaration. It should be emphasized that
the order of the style declarations inside the mixinfollows
the relative order of the style declarations in the original
style rules from which they were extracted. As it will be
explained in Section 3.4, this is essential for preserving the
presentationofthetargetdocuments, inthecasewheresome
style declarations have order dependencies with each other.
In such a case, an ordering that reverses the original order
dependencies between the style declarations would aﬀect the
values assigned to the ISPs, thus changing the presentation.
Adding mixin calls to style rules: Given the mixinmi-
gration opportunity MO=/an}bracketle{tS,P/an}bracketri}ht, for each one of the style
rules in S, a call to the generated mixinshould be added.
Whenever the assigned style values for a given ISPare not
equivalent, the algorithm goes through all style rules in S,
and for each style rule sappends to the corresponding list
ofmixinarguments Ma(s) the actual value assigned to the
ISPbys(lines 14-18). At implementation level, in each
style rule sthe style declarations corresponding to the set
of properties Pare removed, and a mixincall with the ar-
gument list Ma(s) is added.
3.4 Preserving Presentation
In refactoring [34] preserving the behavior of the program
is very critical. The refactored program should have exactly
the same behavior as the original program before refactor-
ing. In a similar manner, any refactoring or migration oper-
ation applied to CSS code should preserve the presentation
of the target documents (i.e., the style values applied to the
DOM elements after refactoring should be exactly the same
as before refactoring). Therefore, in the context of CSS, pro-
gram behavior corresponds to document presentation , and
any CSS refactoring/migration technique should make sure
that document presentation is preserved.
We previously investigated the refactoring of duplicated
style declarations directly in CSSby grouping selectors,
which style properties with equivalent values [30]. We found
that in order to preserve the presentation of the target doc-
uments, the order dependencies between the selectors de-
clared in a CSSﬁle should be preserved after refactoring.
Formally, an order dependency [30] from selector sicontain-
ing declaration dkto selector sjcontaining declaration dl
due to property p, denoted as /an}bracketle{tsi,dk/an}bracketri}htp− → /an}bracketle{tsj,dl/an}bracketri}ht, iﬀ:
a) selectors siandsjselect at least one common element
having property pin the target document,
b) declarations dkanddlset a value to property pand
have the same importance (i.e., both or none of the
declarations use the !imporant rule),
c) declaration dkprecedes dlin the style sheet,
d) selectors siandsjhave the same speciﬁcity.
Practically, if two style rules have selectors with the same
speciﬁcity [2], which select common DOM elements in the
target documents and style the same property, then the style
value initially assigned by the preceding style rule will be
eventually overridden by the value assigned by the succeed-
ing style rule. Therefore, the relative order of these style
rules should be preserved after refactoring in order to obtain
the same value for the property styled in both of them. As
a result, presentation preservation inCSScan be achievedby preserving the order dependencies among all selectors de-
clared in the ﬁle.
Within the context of mixinmigration, the introduction
of a new mixindoes not aﬀect the original order of the style
rules. Therefore, itisnotpossibletobreaktheexistinginter-
selector order dependencies by introducing a mixin. How-
ever, there might exist intra-selector order dependencies be-
tween style declarations in the style rules where the mixin
calls will be added. Consider, for instance, the CSScode
shown in Figure 5c. The border-bottom declaration in se-
lector.aoverrides the style values, which are deﬁned by the
borderdeclaration. The borderdeclaration is a shorthand
declaration deﬁning the border for all individual sides of
an element ( top,right,bottom,left). Next, the developer
overrides with nonethe border styling for the bottom side of
the element. CSSdevelopers tend to override more generic
style properties (e.g,. border) with more speciﬁc ones (e.g.,
border-bottom ), because this approach requires less code
than deﬁning separately all speciﬁc style properties (e.g.,
border-top ,border-right ,border-bottom ,border-left ).
<html>
 ...
 <body>
   ...
   <span class="a">
     test
   </span>
   ...
 </body>
</html>
(a) Sample HTML
.a {
  ...
  border-bottom : none;
  ...
  .mixin1();
}
 
.mixin1() {
  border : solid 3px red ;
  padding : 1px;
} (b)Misplaced mixincall
.a {
  ...
  border : solid 3px red ;
  border-bottom : none;
  padding : 1px;
  ...
}
(c) Original CSS
.a {
  ...
  border-bottom : none;
  ...
  border : solid 3px red ;
  padding : 1px;
}
 (d) Generated CSS
test
(e) Original presentation
test (f) Broken presentation
Figure 5: Intra-selector order dependencies
Applying style rule .ato the sample HTMLcode shown
inFigure5awillresulttoawebdocumentrenderedasshown
in Figure 5e. Let us assume that we extract a mixincon-
taining the borderdeclaration, and we place the mixincall
at the end of .a, as shown in Figure 5b. The preprocessor
will then generate the CSScode shown in Figure 5d, where
theborderdeclaration is placed aftertheborder-bottom
declaration. This will invert the original overriding relation
between the two declarations, resulting to the undesired pre-
sentation shown in Figure 5f (i.e., a styling bug). Therefore,
placing the mixincall in an incorrect position can actually
change the presentation of the target documents.
We deﬁne an intra-selector order dependency from style
declaration ditodj(both declared in the same style rule)
due to individual property isp, denoted as /an}bracketle{tdi/an}bracketri}htisp− − → /an}bracketle{tdj/an}bracketri}ht, iﬀ:
a) declarations dianddjset a value to individual prop-
ertyispand have the same importance (i.e., both or
none of the declarations use the !imporant rule),
b) declaration diprecedes djin the style rule.
To ensure that the presentation of the target documents
will be preserved, we deﬁne the following preconditions :
677✎
✍☞
✌Precondition 1 : The addition of a mixincall in a style
rule should preserve all order dependencies among the
style declarations of the rule.
The problem of ﬁnding an appropriate position for calling
the extracted mixin minside the body of a style rule can
be expressed as a Constraint Satisfaction Problem (CSP)
deﬁned as:
Variables : the positions of the style declarations involved
in order dependencies including m.
Domains : the domain for each variable is the set of values
{1,2,...,N−M+ 1}, whereNis the number of style dec-
larations in the original style rule, and Mis the number of
style declarations extracted from the style rule to m.
Constraints : Assuming that mcontains style declarations
assigning values to the set of individual properties ISPs, an
order constraint is created in the form of pos(di)< pos(dj)
for every order dependency /an}bracketle{tdi/an}bracketri}htisp− − → /an}bracketle{tdj/an}bracketri}htwhereisp∈ISPs.
In the example of Figure 5c, there is one order dependency
border: solid 3px redborder-bottom-style−−−−−−−−−−−−−→ border-bottom: none ,
resulting to the constraint pos(border)< pos(border-bottom ).
Based on this constraint, the call to .mixin1 should be
placed at any position before the border-bottom declara-
tion to preserve the presentation of the target document in
Figure 5a. If there are multiple conﬂicting order dependen-
cies between the mixincall and declarations of the style rule,
it might be necessary to reorder some style declarations in
ordertocomplywiththesolutionreturnedbythesolver. On
the other hand, if the CSP is unsatisﬁable (i.e., no solution
is found) the corresponding mixinmigration opportunity is
excluded as non presentation-preserving.✎
✍☞
✌Precondition 2 : The ordering of the style declarations in-
side amixinshould preserve their original order depen-
dencies in the style rules from which they are extracted.
This precondition is checked by extracting the original order
dependencies between the style declarations inside mixin m
from each style rule where mwill be called. Assuming that
mcontains style declarations assigning values to the set of
individual properties ISPs, if there exist two style rules si
andsj, where an order dependency for the same isp∈ISPs
is reverse, i.e., /an}bracketle{tsi,dk/an}bracketri}htisp− − → /an}bracketle{tsi,dl/an}bracketri}htvs./an}bracketle{tsj,dl/an}bracketri}htisp− − → /an}bracketle{tsj,dk/an}bracketri}ht,
then there is an order dependency conﬂictbetween siand
sj, and the corresponding mixinmigration opportunity is
excluded as non presentation-preserving.
4. EV ALUATION
To assess the correctness and usefulness of the proposed
technique, we designed a study aiming to answer the follow-
ing research questions:
RQ1:Does the proposed technique always detect mixinmi-
gration opportunities that preserve the presentation of
the web documents?
RQ2:Is the proposed technique able to ﬁnd and extract mix-
insthat developers have already introduced in existing
CSSpreprocessor projects?
4.1 Experiment Design
Selection of Subjects: To be able to answer the afore-
mentioned research questions, we need to create a dataset ofTable 3: Overview of the collected data
Name
Less ﬁles
CSS ﬁles
Actual mixins†
Style Rules
Declarations
DetectedOpportunitiesWebsitesaisandbox.com 326113 443188
auroraplatform.com 21183247100
bcemsvt.org 1722163 327 70
brentleemusic.com 131138612344 944
campnewmoon.ca 213218 527162
chainedelespoir.org 28182901081 528
chunshuitang.com.tw 111176 511165
colintoh.com 92459174 48
ﬁrst-last-always.com 16163391116 638
ﬂorahanitijo.com 4111189 822273
greatlakeshybrids.com 113104 373168
hotel-knoblauch.de 112199 446119
intertelecom.ua 1163931329 708
jutta-hof.de 213171 560245
kko.com 11198255 84
med.uio.no 80167621622 436
naeaapp.com 14188281507 382
neofuturists.org 123115221397 593
paulsprangers.com 513125 337 64
schwimmschule-spawala.de 218171 560537
summit.webrazzi.com 11184261 96Librariesbase 2012489 736114
essence 1197114571 5939 615
ﬂatui 601151139 26311346
formstone 3654145 387120
kube 1616374 807206
schema 221125361524 284
skeleton 11295222 45
turret 831341762 2687 307Total 5724419315059 27811 9585
†includes only the mixins, which are called at least two times
CSSﬁles, which actually contain opportunities for introduc-
ingmixinsby grouping style declarations duplicated among
diﬀerent style rules. We relied on the dataset of our previ-
ous study [29], which was used to investigate the practices of
CSSpreprocessor developers by analyzing the code base of
websites using two diﬀerent preprocessors, namely Lessand
Sass. More speciﬁcally, out of 50 websites in which style
sheets were developed using Less, we selected the prepro-
cessor code base of 21 websites, in which at least one mixin
declarationwascalledatleasttwotimes, sincea mixincalled
more than once in the preprocessor code will result in du-
plicated style declarations in the generated CSScode. Our
approach should be able to reproduce the original mixins
declared in the preprocessor ﬁles, and possibly recommend
othermixinopportunities that the developers might have
missed. We further extended this dataset with the CSScode
generatedfromthepreprocessorsourcecodeofeightpopular
Style Sheet libraries. We expect that the selected libraries
apply the best practices regarding mixinreuse, since they
are developed by very experienced developers. The com-
plete list of the selected websites and libraries, along with
the number of Lessﬁles and CSSﬁles (resulting from tran-
spilingLessﬁles), the number of developer-deﬁned mixins,
the total number of style rules and declarations (represent-
ing the size of the analyzed CSSﬁles), and the number of
migration opportunities detected by our approach for each
subjectareshowninTable3. Thecollecteddata, inaddition
to the implemented tools are available on-line [1].
To better demonstrate the size characteristics of the ex-
aminedCSSﬁles, we show the distribution of the number of
style rules and declarations deﬁned in these ﬁles in Figure 6a
and Figure 6b, respectively. The scale of the box plots and
678the underlaid violin plots is logarithmic, and the horizon-
tal bars correspond to the median values. The examined
libraries tend to have more style rules and declarations than
the examined websites. Figure 6c shows the plots for the
number of mixinmigration opportunities detected by our
approach per CSSﬁle in the dataset. As it can be observed,
the median number of opportunities is 73 and 163, for the
libraries and websites, respectively. In order to control for
theCSSﬁle size, and perform a fair comparison between
the number of mixinmigration opportunities in libraries and
websites, we further normalized the number of opportunities
detected in each CSSﬁle by the number of style declarations
deﬁned in it. The normalized medians are 0.13 and 0.35 for
the libraries and websites, respectively. This result shows
that although the CSScode generated by libraries is larger
in size than the code generated by the examined websites,
the libraries tend to have less duplicated style declarations
(and thus less mixinmigration opportunities) than the ex-
amined websites. We can consider this as an indication that
the preprocessor code of libraries is better designed.
  251762
 625
 171
  50 100 2501000
Libraries Websites
(a)#Selectors
  532687
 807
 480
 100 2001500
Libraries Websites
(b)#Declarations
  111346
  73 163
  251000
Libraries Websites
(c)#Opportunities
Figure 6: Characteristics of the analyzed CSS ﬁles
4.2 Results
4.2.1 RQ1: Testing Presentation Preservation
Motivation: The goal of RQ1 is to ensure that our tech-
nique would never recommend the introduction of a mixin
that could change the presentation of the target web docu-
ments (i.e., cause a styling bug).
Method: Let us assume that we have two CSSﬁlesC
andC′(the latter resulting from transpiling the preproces-
sor code after the introduction of a new mixininC) and
we apply them on the same target documents. The target
documents will have the same presentation iﬀ:
1. There is a one-to-one correspondence (i.e., mapping) be-
tween the style rules deﬁned in CandC′.
2. The relative order of the mapped style rules is the same
in bothCandC′(i.e., cascading is preserved).
3. Each pair of mapped style rules from CandC′:
(a) selects the same DOM elements in the target docu-
ments (i.e., speciﬁcity is preserved).
(b) deﬁnes exactly the same set of individual style prop-
erties.
(c) assigns equal or equivalent style values to each de-
ﬁned individual property.
Conditions 1, 2, and 3a are met by the nature of the trans-
formation, because the introduction of a mixindoes not
add or remove style rules (i.e., one-to-one correspondence is
met), does not change the order of the style rules (i.e., cas-
cading is preserved), and does change the selectors speciﬁed
in the style rules (i.e., speciﬁcity is preserved), respectivel y.The only conditions that could be violated from an erro-
neous introduction of a mixinare 3b and 3c. Condition 3b
could be violated, if the introduced mixincontains declara-
tions for more, less, or diﬀerent individual style properties
than those that were removed/extracted from the style rule
calling the mixin. Condition 3c could be violated if the pa-
rameterization of the diﬀerences in the style values is not
correct, or if the mixincall is not placed in the appropriate
position inside a style rule, or if the style declarations are
not ordered correctly inside the mixin(Section 3.4).
Therefore, we developed a method to test conditions 3b
and 3c that takes as input a CSSﬁleCand amixinmigra-
tion opportunity MO, applies MOon ﬁleCto generate the
corresponding CSSpreprocessor code CP, then transpiles
CPto obtain CSSﬁleC′, and examines the assertion:☛
✡✟
✠For every pair of matching style rules ( s,s′) deﬁned in C
andC′, respectively, style-map (s)≡style-map (s′).
Two style rules are considered as matching if they have an
identical selector. Function style-map takes as input a style
rule and extracts a map in which the keys are the individual
style properties ( ISPs) deﬁned in the style rule, and each
key is mapped to the ﬁnalstyle value assigned to the corre-
sponding ISP, after all possible overrides. Two style maps
areequivalent (≡) if their key sets are equal, and the style
values corresponding to each key are equal or equivalent.
Two style values are considered equivalent , when they are
lexically diﬀerent, but constitute alternative representatio ns
for the same style value (e.g., red≡#F00, the ﬁrst is the
HTMLnamed color representation for red, and the second
is the hexadecimal representation for the same color).
Results: In total, we detected and applied 9,585 mixinmi-
gration opportunities and automatically tested them using
the aforementioned method. It should be emphasized that a
large portion of these opportunities overlap with each other
(i.e., they aﬀect common style rules and declarations), and
thus it is not possible to apply them sequentially, since the
application of an opportunity will make infeasible the op-
portunities it overlaps with. Therefore, we applied each one
of them separately on the original CSSﬁles.
We observed several cases where our testing method found
styling bugs, which were due to our faulty implementation
of style value inferencing. As an example, we found cases
in which failing to assign correct ISPsto style values led
to their incorrect parameterization and, consequently, the
resulting preprocessor code was transpiled to a CSSﬁle with
diﬀerent styling semantics than the original CSSﬁle. For
instance, when a shorthand property is assigned with the
valuenone, only one of the ISPsis actually assigned with
none, while the remaining ISPsare assigned with default
values. Our implementation was not inferring correctly the
default values, and this caused problems in preserving the
presentation of the target documents.
Among the detected opportunities, there were 1227 cases,
for which precondition #1 had to be examined, because
there were order dependencies between style declarations ex-
tracted in the mixinand declarations remaining in the style
rules where the mixinwould be called. In one case, ﬁnding
a satisﬁable solution for positioning the mixincall was not
feasible, and thus the migration was not performed. More-
over, there were 1190 cases, for which precondition #2 had
to be examined. In all these cases, the original order of the
declarations inside the extracted mixincould be preserved.
679Overall, none of the issues found using our testing method
was due to a ﬂaw in the approach we proposed for detecting
and extracting mixins. All issues were caused by implemen-
tation bugs that were eventually ﬁxed, resulting in 100% of
the tests being passed. Consequently, we can conclude that
themixinmigrationopportunitiesproposedbyourapproach
are actually safe to apply.
4.2.2 RQ2: Detecting Mixins Deﬁned by Developers
Motivation: The goal of RQ2 is to investigate whether our
technique is able to recommend mixinsthat a human expert
(i.e., a developer with expertise in the use of preprocessors)
would introduce.
Method: To evaluate this research question we ﬁrst built
anoracleof human-written mixinsby extracting all mixins
in our preprocessor dataset being called at least two times.
Thesemixinsare suitable for testing our approach, because
theyintroduceduplicatedstyledeclarationsinthestylerule s
where they are called after transpiling the preprocessor code
to generate CSScode. The mixinscalled only once in the
preprocessor code cannot be detected by our approach, be-
cause they do not introduce duplicated style declarations.
Next, we transpiled each preprocessor ﬁle and applied our
technique to detect all mixinmigration opportunities in the
resulting CSSﬁles.
Amixinm, created by applying the migration opportu-
nitymodetected by our approach, matches with a mixinm′
in the oracle, iﬀ:
1. the set of ISPsstyled by mis equal to or is a superset of
theISPsstyled by m′,
2.mis called in at least all the style rules where m′is called.
The ﬁrst condition ensures that mstyles the same set of
properties as m′. This condition is relaxed, so that mcould
style more ISPsthanm′. This relaxation is necessary to
deal with cases where the preprocessor developer missed the
opportunity to include additional style properties being du-
plicated in the style rules from which m′was extracted. The
second condition ensures that mis called in the same style
rules where m′was called. This condition is also relaxed,
so thatmcould be called in more style rules than m′. This
relaxation is necessary to deal with cases where the pre-
processor developer missed the opportunity to reuse m′in
additional style rules. If m′is matched by applying the ﬁrst
relaxed condition, then m′is not aclosedfrequent itemset,
since there is at least one superset with the same frequency.
Results: Our approach was able to recover 189 out of the
193mixinsin the oracle. In particular, 3 mixinmigration
opportunities detected by our approach were exact matches,
17 contained additional properties (i.e., supersets with the
same frequency), 29 were called by additional style rules
(i.e., same sets with higher frequency), and 214 contained
additional properties and were called by additional style
rules (i.e., supersets with higher frequency). The large per-
centage of inexactly matched mixinmigration opportunities
(260/263 = 98.8%) actually shows that in most of the cases
developers under-utilize mixins.
We further manually investigated the 4 oracle mixinsthat
our approach could not detect. In general, these mixinsfall
into two categories:
Mixins using property interpolation: Interpolation is
anadvancedpreprocessorfeatureallowingtousevariablesto
formpropertynames. Itisusefulforstylingdiﬀerentproper-
ties that have the same sub-properties (e.g., margin-top andpadding-top can be interpolated as @{property}-top ), or
can take the same values. Figure 7a shows an example of an
interpolated property name inside a mixin, and the resulting
CSScode is depicted in Figure 7b. Our technique cannot
detect such mixinopportunities, since it does not support
the parameterization of diﬀerences in property names.
.inherit(@property) { @{property}: inherit; }
.s1 { .inherit( margin); }
.s2 { .inherit( padding); }
(a) Preprocessor Code
.s1 { margin: inherit; }
.s2 { padding: inherit; } (b) Genereated CSS
Figure 7: Example of interpolated property name
Use of!important in arguments: As mentioned before,
in our approach we avoid the grouping of properties having
a diﬀerent importance. However, the !important rule can
be actually used in the arguments of a mixincall to param-
eterize properties having a diﬀerent value and importance,
as shown in the example of Figure 8a, resulting to the CSS
code shown in Figure 8b. Our approach does not support for
the moment such advanced parameterization of diﬀerences.
.s1 { .m(~' red !important '); }
.s2 { .m(blue); }.m(@var){ color: @var; }
(a) Preprocessor Code
.s1 { color: red !important ; }
.s2 { color: blue; } (b) Genereated CSS
Figure 8: Example of !important use in arguments
4.3 Limitations
The success of a recommendation system is associated
with the relevance of the recommendations to its users, of-
ten measured in terms of precision and recall. Assuming
that the mixinsintroduced by developers (e.g., the oracle
used in RQ2) constitute the gold standard, our approach can
achieve very high recall with a small number of undetected
actualmixins(i.e., false negatives), but it generates a large
number of mixinopportunities, and some of them might be
considered irrelevant by the developers (i.e., false positives) .
Although, it is not possible to determine the actual num-
ber of false positives without asking the developers’ opinion
about the recommendations, it is certain that the develop-
ers would like to inspect the smallest possible list of mixin
opportunities that contains most of the relevant ones.
Therefore, we investigated whether it is possible to reduce
the number of generated mixinopportunities (i.e., recom-
mendations) without jeopardizing recall. To achieve this,
we ﬁltered out the mixinopportunities having a number of
style declarations, or parameters above certain thresholds.
The threshold values were automatically derived from the
box plot upper adjacent values for the oracle used in RQ2.
All data points above the upper adjacent value of the box
plots are outliers that correspond to abnormal mixinsin-
troduced by developers. Indeed, deﬁning thresholds based
on box plot outliers is a statistical approach that has been
also used in metric-based rules for detecting design ﬂaws
in object-oriented systems [27]. Table 4 shows the number
ofmixinopportunities obtained using diﬀerent ﬁlters along
with the number of recovered mixinsfrom the oracle. The
results show that it is possible to recover close to 90% of the
oraclemixinswithlessthanhalfoftheoriginalopportunities
by applying appropriate threshold-based ﬁlters.
4.4 Threats to Validity
While the proposed approach for detecting mixinoppor-
tunities is preprocessor-agnostic, our actual implementatio n
680Table 4: Threshold-based ﬁltering of opportunities
Filter #Opp. #Recovered Recall (%)
I None 9585 189 97.9
II #Declarations ≤7 8686 180 93.3
III #Parameters ≤2 4421 176 91.2
IV II & III 4320 169 87.6
for the introduction of mixinscurrently supports only the
Lesspreprocessor. This is because the source code trans-
formations required to introduce a mixinare speciﬁc to the
abstract syntactic structure ofthetargetedpreprocessor. We
selected to support Less, because it is slightly more popular
among the developers [9]; however, the implemented tool is
extensible enough to support any preprocessor. In addition,
we have already shown that [29] code written in Sass(an-
other popular preprocessor) has very similar characteristics
with code written in Less. Thus, examining projects devel-
oped inLessdoes not limit the generalizability of our study.
Nevertheless, we used Lessﬁles collected from a wide range
of web systems, including libraries and websites, to mitigate
the threat to the external validity of our study.
The ultimate approach for testing presentation preserva-
tion would be to compare the target documents, before and
after applying migration transformations, as they are ren-
dered in the browser. However, a visual comparison would
be time-consuming and error-prone. Additionally, the state-
of-the-art automatic techniques are computationally inten-
sive, e.g., diﬀerentiating screen captures of web pages using
image processing methods [7, 25, 36]. We instead consid-
ered all possible presentation changes a mixincan impose
on a Style Sheet, and developed a lightweight static analysi s
method, based on preconditions derived from CSSspeciﬁca-
tions. This approach was able to reveal several styling bugs
due to our faulty implementation, showing that the method
is promising in testing whether presentation is preserved.
5. RELATED WORK
Maintenance of Cascading Style Sheets: CSSmain-
tenance is a rather unexplored research area, despite the
fact that CSSis extensively used in the industry [32]. Pre-
vious works proposed approaches for ﬁnding dead code in
CSSﬁles, in order to reduce their size, and thus the eﬀort
required for their maintenance. Mesbah and Mirshokrae de-
vised a hybrid approach to detect unused style rules in CSS
ﬁles, using dynamic and static analysis [31]. Having the
same goal, Genev` es et al. [15] proposed a technique based
on tree logics. Similarly, Hague et al. [17] used Tree Rewrit-
ing techniques for removing redundant CSSrules. Finally,
Bosch et al. [4] explored the possibility of CSSrefactoring
to remove unused style rules and declarations by statically
extracting the relationships between CSSstyle rules.
Keller and Nussbaumer [19] introduced metrics for mea-
suring the abstractness of CSSﬁles, and explored ways
to make CSSﬁles reusable for diﬀerent target documents.
Gharachorlu [16] investigated code smells in CSScode, and
proposed a statistical model for predicting them. Liang et
al. [24] designed a tool for tracking the visual impact of code
changes in CSSacross a website.
Previous studies also investigated the presence of dupli-
cation in web systems, either in the content [3] and struc-
ture [11, 12, 10, 35, 38, 8] of HTMLpages, or their client-
[22, 5] or server-side [33] scripts. We conducted the ﬁrst
study on CSSduplication [30], investigating the possibility
of refactoring CSSﬁles to remove duplication by groupingstyle rules that share equivalent declarations, i.e., declara-
tions that result to the same presentation. The proposed
approach in [30] eliminates duplications occurring between
style declarations with no diﬀerences in style values, directly
in“vanilla” CSS,whileinthiswork, weproposedatechnique
formigrating CSScode to take advantage of preprocessor
mixins, which allows the parameterization of diﬀerences in
style values. Moreover, in contrast to this work, we did
not use a testing approach in [30] for assuring that the pre-
sentation semantics of style sheets will be preserved after
transformations.
Migration of legacy systems: There are numerous works
in the literature proposing migration techniques for legacy
systems in order to improve their maintainability. Several
researchers developed techniques for migrating procedural
code to the object-oriented paradigm, such as automatic or
semi-automatic translators from C to C++ [44], Eiﬀel [40],
or Java [28]. Migration is also performed when there is a
lack of human resources for maintaining existing software
systems written in an extinct language, e.g., migrating Lisp
to Java [23]. Other works proposed approaches for detecting
opportunitiestouseconstructsintroducedinanewerversion
of a programming language. For Java, there are techniques
for introducing parameterized classes from non-generic ones
[21], the enumerated type [20], and Lambda expressions [14].
Migration of web systems: Some of the studies that in-
vestigated the duplication in the content or structure of web
pages, proposed techniques for migrating duplicated static
web pages to dynamic, server-side web applications [3, 38].
Mao et al. [26] proposed an approach for the automatic mi-
grationof HTMLpageshavingtable-basedstructurestothe
style-based structure, by using clone detection tools to ﬁnd
duplicated code across diﬀerent CSS ﬁles. Their approach
can support only exact duplications, which are removed by
creating a single CSS ﬁle for diﬀerent web pages. Our work
is the ﬁrst one that supports the migration of existing CSS
code to preprocessors and evaluates the correctness and ef-
ﬁcacy of the detected mixinmigration opportunities.
6. CONCLUSIONS AND FUTURE WORK
In summary, the main conclusions and lessons learned are:
1. Our approach facilitates the automatic migration of CSS
code to preprocessors, by safely extracting duplicated
style declarations from CSScode to preprocessor mixins.
2. Our approach is able to recover the vast majority (98%)
of themixinsthat professional developers introduced in
websites and Style Sheet libraries.
3. We found that developers mostly under-utilize mixins
(i.e., they could reuse the mixinsin more style rules,
and/orcouldeliminatemoreduplicatedstyledeclarations
by extracting them into the mixins).
4. By applying appropriate threshold-based ﬁlters, it is pos-
sible to drastically reduce the number of detected mixin
opportunities without aﬀecting signiﬁcantly the recall.
As future work, we are planning to develop a ranking
mechanism in order to help developers prioritize the mixin
opportunities based on their expected beneﬁt on maintain-
ability. We also plan to evaluate our recommendation sys-
tem with actual web developers and ﬁnd ways to further
eliminate recommendations that are irrelevant to them, e.g.,
mixinscontaining semantically unrelated style properties
that a developer would not normally group together.
6817. REFERENCES
[1] Dataset and tool for reproduction and replication.
https://git.io/v6eK6.
[2] CSS Cascading and Inheritance Level 3. Technical
report, World Wide Web Consortium, October 2013.
[3] C. Boldyreﬀ and R. Kewish. Reverse engineering to
achieve maintainable WWW sites. In Proceedings of
the 8th Working Conference on Reverse Engineering
(WCRE) , pages 249–257, 2001.
[4] M. Bosch, P. Genev` es, and N. Laya ¨ıda. Automated
refactoring for size reduction of css style sheets. In
Proceedings of the 2014 ACM Symposium on
Document Engineering (DocEng) , pages 13–16, 2014.
[5] F. Calefato, F. Lanubile, and T. Mallardo. Function
clone detection in web applications: a semiautomated
approach. Journal of Web Engineering , 3(1):3–21,
2004.
[6] H. Catlin. SASS: Syntactically Awesome Style Sheets.
http://sass-lang.com/.
[7] S. R. Choudhary, H. Versee, and A. Orso. WEBDIFF:
Automated identiﬁcation of cross-browser issues in
web applications. In Proceedings of the 26th IEEE
International Conference on Software Maintenance
(ICSM), pages 1–10, 2010.
[8] J. R. Cordy and T. R. Dean. Practical
language-independent detection of near-miss clones. In
Proceedings of the 14th Conference of the Centre for
Advanced Studies on Collaborative Research
(CASCON) , pages 1–12, 2004.
[9] C. Coyier. Popularity of CSS Preprocessors.
http://css-tricks.com/
poll-results-popularity-of-css-preprocessors/.
[10] A. De Lucia, R. Francese, G. Scanniello, and
G. Tortora. Understanding cloned patterns in web
applications. In Proceedings of the 13th International
Workshop on Program Comprehension (IWPC) , pages
333–336, 2005.
[11] G. Di Lucca and M. Di Penta. Clone analysis in the
web era: an approach to identify cloned web pages. In
Proceedings of the 7th IEEE Workshop on Empirical
Studies of Software Maintenance (WESS) , pages
107–113, 2001.
[12] G. Di Lucca, M. Di Penta, and A. Fasolino. An
approach to identify duplicated web pages. In
Proceedings of the 26th Annual International
Computer Software and Applications Conference
(COMPSAC) , pages 481–486, 2002.
[13] M. Fowler, K. Beck, J. Brant, and W. Opdyke.
Refactoring: Improving the Design of Existing Code .
1999.
[14] L. Franklin, A. Gyori, J. Lahoda, and D. Dig.
LAMBDAFICATOR: From Imperative to Functional
Programming through Automated Refactoring. In
Proceedings of the 35th International Conference on
Software Engineering (ICSE) , pages 1286–1289, 2013.
[15] P. Genev` es, N. Laya ¨ıda, and V. Quint. On the analysis
of cascading style sheets. In Proceedings of the 21st
International Conference on World Wide Web
(WWW) , pages 809–818, 2012.
[16] G. Gharachorlu. Code smells in Cascading Style
Sheets: an empirical study and a predictive model .
Master’s thesis, University of British Columbia, 2014.[17] M. Hague, A. W. Lin, and C.-H. L. Ong. Detecting
Redundant CSS Rules in HTML5 Applications: A
Tree Rewriting Approach. In Proceedings of the 2015
ACM SIGPLAN International Conference on
Object-Oriented Programming, Systems, Languages,
and Applications (OOPSLA) , pages 1–19, 2015.
[18] J. Han, J. Pei, and Y. Yin. Mining frequent patterns
without candidate generation. SIGMOD Record ,
29(2):1–12, 2000.
[19] M. Keller and M. Nussbaumer. CSS code quality: a
metric for abstractness; or why humans beat machines
in CSS coding. In Proceedings of the 7th International
Conference on the Quality of Information and
Communications Technology (QUATIC) , pages
116–121, 2010.
[20] R. Khatchadourian, J. Sawin, and A. Rountev.
Automated Refactoring of Legacy Java Software to
Enumerated Types. In Proceedings of the IEEE
International Conference on Software Maintenance
(ICSM), pages 224–233, 2007.
[21] A. Kie˙ zun, M. D. Ernst, F. Tip, and R. M. Fuhrer.
Refactoring for parameterizing java classes. In
Proceedings of the 29th International Conference on
Software Engineering (ICSE) , pages 437–446, 2007.
[22] F. Lanubile and T. Mallardo. Finding function clones
in web applications. In Proceedings of the 7th
European Conference on Software Maintenance and
Reengineering (CSMR) , pages 379–386, 2003.
[23] A. Leitao. Migration of Common Lisp Programs to the
Java Platform - The Linj Approach. In Proceedings of
the 11th European Conference on Software
Maintenance and Reengineering (CSMR) , pages
243–251, 2007.
[24] H.-S. Liang, K.-H. Kuo, P.-W. Lee, Y.-C. Chan, Y.-C.
Lin, and M. Y. Chen. SeeSS: Seeing What I Broke –
Visualizing Change Impact of Cascading Style Sheets
(CSS). In Proceedings of the 26th Annual ACM
Symposium on User Interface Software and
Technology (UIST) , pages 353–356, 2013.
[25] S. Mahajan and W. G. J. Halfond. WebSee: A Tool
for Debugging HTML Presentation Failures. In
Proceedings of the 8th International Conference on
Software Testing, Veriﬁcation and Validation (ICST) ,
pages 1–8, 2015.
[26] A. Y. Mao, J. R. Cordy, and T. R. Dean. Automated
conversion of table-based websites to structured
stylesheets using table recognition and clone detection.
Proceedings of the 17th Conference of the Center for
Advanced Studies on Collaborative Research
(CASCON) , pages 12–26, 2007.
[27] R. Marinescu. Detection strategies: metrics-based
rules for detecting design ﬂaws. In Proceedings of the
20th IEEE International Conference on Software
Maintenance (ICSM) , pages 350–359, 2004.
[28] J. Martin and H. Muller. Strategies for migration from
C to Java. In Proceedings of the Fifth European
Conference on Software Maintenance and
Reengineering (CSMR) , pages 200–209, 2001.
[29] D. Mazinanian and N. Tsantalis. An empirical study
on the use of CSS preprocessors. In Proceedings of the
23rd IEEE International Conference on Software
Analysis, Evolution, and Reengineering (SANER) ,
682pages 168–178, 2016.
[30] D. Mazinanian, N. Tsantalis, and A. Mesbah.
Discovering Refactoring Opportunities in Cascading
Style Sheets. In Proceedings of the 22nd ACM
SIGSOFT International Symposium on Foundations
of Software Engineering (FSE) , pages 496–506, 2014.
[31] A. Mesbah and S. Mirshokraie. Automated analysis of
CSS rules to support style maintenance. In
Proceedings of the International Conference on
Software Engineering (ICSE) , pages 408–418, 2012.
[32] Mozilla Developer Network. Web developer survey
research. Technical report, Mozilla, 2010.
[33] T. Muhammad, M. F. Zibran, Y. Yamamoto, and
C. K. Roy. Near-miss clone patterns in web
applications: An empirical study with industrial
systems. In Proceedings of the 26th IEEE Canadian
Conference on Electrical and Computer Engineering
(CCECE) , pages 1–6, 2013.
[34] W. F. Opdyke. Refactoring object-oriented
frameworks . PhD thesis, University of Illinois at
Urbana-Champaign, IL, USA, 1992.
[35] D. C. Rajapakse and S. Jarzabek. An investigation of
cloning in web applications. In Proceedings of the 5th
International Conference of Web Engineering
(ICWE), pages 252–262, 2005.
[36] S. Roy Choudhary, M. R. Prasad, and A. Orso.
X-PERT: Accurate Identiﬁcation of Cross-browser
Issues in Web Applications. In Proceedings of the 2013International Conference on Software Engineering
(ICSE), pages 702–711, 2013.
[37] A. Sellier. LESS - The dynamic stylesheet language.
http://lesscss.org/.
[38] N. Synytskyy, J. R. Cordy, and T. R. Dean.
Resolution of static clones in dynamic Web pages. In
Proceedings of the 5th IEEE International Workshop
on Web Site Evolution (WSE) , pages 49–56, 2003.
[39] P. Tan, M. Steinbach, and V. Kumar. Introduction to
data mining . Addison-Wesley, 2005.
[40] M. Trudel, C. Furia, M. Nordio, B. Meyer, and
M. Oriol. C to O-O Translation: Beyond the Easy
Stuﬀ. In Proceedings of the 19th Working Conference
on Reverse Engineering (WCRE) , pages 19–28, Oct
2012.
[41] U.S. General Services Administration. CSS coding
styleguide. https://pages.18f.gov/frontend/
css-coding-styleguide/preprocessor/.
[42] W3Techs. World Wide Web Technology Surveys. http:
//w3techs.com/technologies/details/ce-css/all/all.
[43] World Wide Web Consortium. CSS speciﬁcations.
http://www.w3.org/Style/CSS/current-work.
[44] Y. Zou and K. Kontogiannis. A framework for
migrating procedural code to object-oriented
platforms. In Proceedings of the Eighth Asia-Paciﬁc
Software Engineering Conference (APSEC) , pages
390–399, 2001.
683