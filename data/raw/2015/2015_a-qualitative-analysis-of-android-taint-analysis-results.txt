A Qualitative Analysis of
Android Taint-Analysis Results
Linghui Luo
Paderborn University
Paderborn, Germany
linghui.luo@upb.deEric Bodden
Paderborn University & Fraunhofer IEM
Paderborn, Germany
eric.bodden@upb.deJohannes Sp ¨ath
Fraunhofer IEM
Paderborn, Germany
johannes.spaeth@iem.fraunhofer.de
Abstract —In the past, researchers have developed a number
of popular taint-analysis approaches, particularly in the context
of Android applications. Numerous studies have shown that
automated code analyses are adopted by developers only if they
yield a good “signal to noise ratio”, i.e., high precision. Many
previous studies have reported analysis precision quantitatively,
but this gives little insight into what can and should be done to
increase precision further .
To guide future research on increasing precision, we present a
comprehensive study that evaluates static Android taint-analysis
results on a qualitative level. To unravel the exact nature of taint
ﬂows, we have designed COVA, an analysis tool to compute
partial path constraints that inform about the circumstances
under which taint ﬂows may actually occur in practice.
We have conducted a qualitative study on the taint ﬂows
reported by FlowDroid in 1,022 real-world Android applications.
Our results reveal several key ﬁndings: Many taint ﬂows occur
only under speciﬁc conditions, e.g., environment settings, user
interaction, I/O. Taint analyses should consider the application
context to discern such situations. COVA shows that few taint
ﬂows are guarded by multiple different kinds of conditions
simultaneously, so tools that seek to conﬁrm true positives
dynamically can concentrate on one kind at a time, e.g., only
simulating user interactions. Lastly, many false positives arise due
to a too liberal source/sink conﬁguration. Taint analyses must be
more carefully conﬁgured, and their conﬁguration could beneﬁt
from better tool assistance.
Index T erms —taint analysis, path conditions, Android
I. I NTRODUCTION
The past few years have brought to light a wealth of
diverse taint-analysis approaches, most of them static and
for the Android platform [1]–[6]. Static taint analysis is not
a trivial task, due to the static abstractions and sometimes
approximations it requires. Static taint analysis for Android is
particularly challenging since one must consider some rather
unique features of Android: Android apps are not standalone
applications but rather plugins for the Android framework.
As such they have a distinct life cycle, and often numerous
callbacks that respond to various environmental stimuli such as
button clicks or location changes. Android apps often need to
operate correctly for different platform versions and devices,
which is why they often contain code that is conditionalized
with respect to various environment parameters. In Android it
is a common and recommended practice, for instance, to obtain
backward compatibility by probing the platform version.Existing studies show that code analysis tools are most
likely to be adopted if they yield high precision, i.e., a low rate
of false positives [7], [8], which is hard given the challenges
named above. While all existing papers proposing those tools
do comprise an insightful evaluation, often even on a large
scale, these evaluations are virtually all entirely quantitative .
As such, they do permit one to conclude how many taint-
ﬂow warnings a given taint-analysis tool reports on a given
benchmark set, but not of which nature those taint ﬂows
exactly are, i.e., under which conditions they can occur at
runtime, and what could be done further to discard potentially
remaining false positives within those taint ﬂows. The lack of
such qualitative data currently hinders progress in upcoming
directions of research. Researchers are investigating novel “hy-
brid” combinations of static with dynamic analysis which, for
instance, seek to dynamically conﬁrm static-analysis ﬁndings
by computing an actual witness path exposing the taint ﬂow
at runtime [9]–[14]. To guide such research, we present the
ﬁrst study that evaluates static Android taint-analysis results
at a qualitative level. In particular, this study seeks to identify
how taint ﬂows are conditioned on ...
•Environment settings (platform versions, country, etc.):
Malicious applications can leak data based on environ-
ment settings [15], [16].
•User interactions : Previous work [17] has shown that
many Android apps leak data as a result of user actions
on certain widgets in the apps.
•I/O operations : Leaks that depend on speciﬁc inputs are
difﬁcult to trigger dynamically [12], [18], [19], since the
search space is often very large.
To facilitate this study, we have implemented COVA, a
static analysis tool that computes partial path constraints.
COVA can be conﬁgured to track information about the three
factors named above, and thus the circumstances under which
taint ﬂows may actually occur in practice.
We conducted a case study of the most common taint
ﬂows (data leaks) reported by the static taint-analysis tool
FlowDroid [1] from 1,022 real-world Android apps. During
manual inspection of the sampled taint ﬂows, we observed
some default sources and sinks provided by FlowDroid to
be inappropriate: they were causing only false positives, and
in large quantities. Unfortunately, we found this to impact
1022019 34th IEEE/ACM International Conference on Automated Software Engineering (ASE)
978-1-7281-2508-4/19/$31.00 ©2019 IEEE
DOI 10.1109/ASE.2019.00020
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:08:56 UTC from IEEE Xplore.  Restrictions apply. the empirical evaluation of many previously published pa-
pers [20]–[28].
After having eliminated these false positives, we classiﬁed
the reported taint ﬂows with COVA, based on the three factors
mentioned above. Our study reveals that at least 14% of the
ﬂows are conditioned on at least one of the three factors
(environment, interaction, I/O), but also that few ﬂows are
conditioned on multiple factors at the same time. This means
that hybrid analysis tools must be able to deal with those
factors, but for each factor one can likely build specialized
support.
Of special interest to developers are taint ﬂows that are
not conditioned on the three factors above and which are
also are intra-procedural: those “low-hanging fruits” can be
identiﬁed purely statically, and are likely to be both correct
and actionable to the developers. Static analysis tools should
thus aim to prioritize their reporting. We ﬁnd that 3.5% of all
taint ﬂows fall into this category.
To summarize, this paper presents the following original
contributions:
•COVA, a static analysis tool to compute path constraints.
•A micro-benchmark to assess COVA and similar tools.
•A COVA-supported qualitative study of taint ﬂows from
1,022 Android apps.
The insights drawn from the study are:
•Source/sink conﬁgurations are essential to precision. Pre-
vious bad defaults have caused vast amounts of false
positives.
•Many inter-procedural taint ﬂows in Android applications
are conditioned on user interactions, and fewer on en-
vironment conﬁgurations or I/O operations. The three
categories are almost disjoint. This is good news: one
can build effective hybrid analysis tools that specialize
on either category.
•Reported intra-procedural taint ﬂows are most likely to be
true positives. One should thus prioritize their reporting.
We make COVA and the Android apps we analyzed publicly
available at:
https://github.com/secure-software-engineering/COV A.git
The rest of this paper is organized as follows: we ﬁrst motivate
the need for the tool COVA, then explain its design, and lastly
our experimental study.
II. A M OTIV A TING EXAMPLE
Figure 1 shows an Activity of an Android application
that contains a data leak—a simpliﬁed example. The activity
ﬁrst reads the unique device identiﬁer (Line 8), stores it
into variable deviceId before method onClick uses the
variable and sends an SMS containing the identiﬁer to the
phone number “+1234” (Line 15).
State-of-the-art static taint-analysis tools for Android, e.g.,
FlowDroid [1], AmanDroid [2] or DroidSafe [3], are capable
of detecting such leaks with a high precision. The tools de-
liver highly precise context-, ﬁeld-, and ﬂow-sensitive results.However, as we observed during our study, these precision
dimensions are insufﬁcient when trying to understand how and
when apps leak data.
While any of the mentioned taint-analysis tools reports the
leak in Figure 1, none of the tools reports that the leak can only
occur under a speciﬁc execution path. The tools are not path-
sensitive [29]. The app leaks the device identiﬁer only when
it executes the source and sink statements. Their execution
depends on three path conditions [30]. First, the app must
run the correct Android SDK version (Line 7), second, the
user must trigger the app to execute the onClick callback
by pressing a button (Line 11), and third, a special system
feature has to be enabled on the execution device (Line 14).
For an automatic qualitative evaluation of the path condi-
tions of data leaks reported by the taint-analysis tools, we
implemented the static analysis tool COVA. COVA computes
aconstraint map which associates with each statement of a
program the path conditions required to execute the statement.
Figure 2 describes the workﬂow of COVA when used
with a taint-analysis tool. COVA accepts as input an An-
droid application in bytecode format and a set of pre-deﬁned
constraint-APIs . COVA then computes the path conditions,
i.e., the constraint map, which depend on values from the
constraint-APIs. Instead of computing all path conditions for
the program (which is practically infeasible), COVA focuses
on propagating values of the constraint-APIs and path con-
ditions dependent on these. The constraint map computed by
COVA can be used to reﬁne the data leaks reported by an
existing taint-analysis tool, i.e., leaks can be reported with
path constraints. Although we applied COVA to taint analysis,
COVA is applicable to any other client analysis that can
beneﬁt from path information.
To understand, for instance, the leak in Figure 1,
it sufﬁces to track the following constraint-APIs:
Build.VERSION.SDK_INT ,OnClickListener.on-
Click and PackageManager.hasSystemFeature .
COVA performs a context-, ﬂow-, and ﬁeld-sensitive data-
ﬂow analysis starting from the entry point of the program.
In Figure 1, the entry point of the activity is onCreate
and it is always executable, thus the statement at Line 5 has
the initial constraint TRUE . At each reachable invocation of
a constraint-API, COVA generates a tainted data-ﬂow fact,
simply referred to by taint . In Figure 1, COVA propagates the
taint ( sdk ,TRUE , SDK) starting from Line 19. The symbol
sdk is the variable containing the value returned from the
constraint-API; the second entry TRUE is the constraint
under which the data-ﬂow fact at the statement is reachable;
SDK stands for the symbolic value of the static ﬁeld
Build.VERSON.SDK_INT . COVA then propagates the
taints along the inter-procedural control-ﬂow graph (ICFG) of
the program and creates constraints over the symbolic values
of taints whenever taints are used in conditional statements.
For instance, the return value of the method
isRightVersion() istrue when the SDK version
is at most 26. The Android app further branches (indirectly)
based on the version at the if-statement in Line 7. The
103
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:08:56 UTC from IEEE Xplore.  Restrictions apply. 1 public class LeakyApp extends Activity {
2 ...
3 @Override
4 protected void onCreate(Bundle savedInstanceState) {
5 String deviceId = ””;
6 boolean z = isRightV ersion();
7 if(z)
8 deviceId = telephonyManager.getDeviceId (); // source
9 button.setOnClickListener( new View.OnClickListener() {
10 @Override
11 public void onClick(View view) {
12 PackageManager pm = getApplicationContext().getPackageManager();
13 boolean t = pm.hasSystemFeature( ”android.hardware.telephony” ));
14 if(t)
15 smsManager.sendTextMessage (”+1234” ,null , deviceId, null ,null );// sink
16 }});
17 }
18 private boolean isRightV ersion() {
19 int sdk = Build.VERSION.SDK INT;
20 if(sdk >26)
21 return false ;
22 else
23 return true ;
24 }}(sdk ,TRUE , SDK)
(ret ,SDK>26, false)
(ret ,SDK≤26, true)(z,SDK>26, false) (z,SDK≤26, true)
(t,CLICK , TELEPHONY)TRUE
TRUE
TRUE
SDK≤26
TRUE
TRUE
CLICK
CLICK
CLICK
CLICK∧TELEPHONY
TRUE
TRUE
SDK>26
SDK≤26
SDK≤26Variable Constraint ValueConstraint Map
Fig. 1. A motivating example.
Constraint 
MapPre-defined 
Constraint-APIsPre-defined 
Constraint-APIsCOVA
Data 
LeaksTaint-Analysis ToolConstrained 
LeaksBytecode
Fig. 2. The workﬂow of applying COVA to taint-analysis results.
constraint map of COVA captures these path conditions.
COVA computes the taint ( ret ,SDK≤26, true) for the
statement in Line 23; the taint encodes that the return value
ret equals true when the version is SDK≤26. This
taint propagates back to the call site in Line 6 as taint ( z,
SDK≤26, true).
In early results of our qualitative study, we observed many
data leaks to depend on callbacks of user interfaces which
motivated us to symbolically represent them in COVA. Tech-
nically, COVA creates a constraint CLICK at the callback
OnClickListener.onClick and propagates this con-
straint to all statements reachable from this method. CLICK
is a symbolic value representing a button click, only when a
user clicks the button the statements become reachable.
COVA propagates all taints from all constraint-APIs and
simultaneously computes a constraint for each reachable state-
ment based on available taints at the current statement. Once
the data-ﬂow propagation is completed, the constraint map isalso computed.
In this paper, we enrich the leak-reports by FlowDroid
with the constraints computed by COVA. We compute the
constraint of a leak, its leak-constraint , according to the
logical formula Csource∧Csink , in which Csource denotes the
constraint under which the source statement may be executed,
andCsink the same for the sink. In the example, the resulting
leak-constraint is SDK≤26∧CLICK∧TELEPHONY . This
leak-constraint is used later in our study to classify the taint
ﬂows.
III. C OMPUTING THE CONSTRAINT MAP
Computing the constraint map as shown in Figure 1 is non-
trivial. The execution of a branch may simultaneously depend
on two or more values of some constraint-APIs. A static
analysis must jointly propagate all values to compute the ﬁnal
constraint for a branch. As the values have to be propagated
jointly, the analysis is non-distributive [31]. Furthermore, each
value of a constraint-API must be propagated throughout the
whole program, since values can ﬂow to ﬁelds of objects be-
fore the ﬁelds are re-accessed elsewhere and aliasing relations
must be computed.
We implemented the analysis within the data-ﬂow frame-
work V ASCO [32], which solves non-distributive inter-
procedural data-ﬂow problems in a highly precise (context-
and ﬂow-sensitive) manner. V ASCO propagates data-ﬂow facts
(elements of a data-ﬂow domain D) from statement to state-
ment along the inter-procedural control-ﬂow graph (ICFG) of
the program. The ﬂow functions accept a data-ﬂow fact d∈D
and a control-ﬂow edge /angbracketleftn,m/angbracketrightof the ICFG as input, and
104
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:08:56 UTC from IEEE Xplore.  Restrictions apply. output a new value d/prime∈D. Similarly to IFDS [33], V ASCO
differentiates between the following four kinds of functions:
•NORMAL FLOW FUNC : handles intra-procedural ﬂows
wherenis not a call site.
•CALL LOCAL FLOW FUNC : handles intra-procedural ﬂows
wherenis a call site. It propagates the values of local
variables not used at the call site.
•CALL ENTRY FLOW FUNC : handles an inter-procedural
ﬂow from call site nto the ﬁrst statement mof a callee.
It typically maps actual method arguments to formal
parameters.
•CALL EXIT FLOW FUNC : it is the inverse of C ALL EN-
TRY FLOW FUNC .
A. Analysis Domain
The domain D for our analysis in V ASCO is two-
dimensional: C×2T, where Cis a constraint domain and T
is a taint domain. We use ⊥∈Dto denote an unknown fact.
Consider data-ﬂow fact (C,T )∈C×2Tto hold at statement n,
thenCis the constraint under which statement nis reachable.
We seed the data-ﬂow propagation with the fact (TRUE,∅)
at the entry point of the application. The constraint is TRUE ,
as the entry point statement is always reachable. At the entry
point, the set Tis the empty set as no constraint-API call has
been encountered.
In general, Tis the set of taints generated at constraint-APIs
reaching statement n. Each taint is a triple (a,c,v )∈Tand
consists of an access path (a local variable followed by a ﬁnite
sequence of ﬁelds [34]). The access path aencodes how the
value of the constraint-API is heap-referenceable at statement
n. V aluevholds the actual value of a. In the case it is the
return value of a constraint-API, it is represented symbolically,
if possible concrete values of primitive types are traced. The
constraint cdescribes under which conditions ahas the value
v. Note, at a statement nthe constraint cof a taint within
the setTand the constraint Care not necessarily equal (e.g.,
Line 6 in Figure 1).
The meet operator /unionsqis the logical disjunction ∨for the
constraint domain and set union ∪for the taint domain,
i.e., (C1,T1)/unionsq(C2,T2)=(C1∨C2,T1∪T2)for two
data-ﬂow facts (C1,T1)and (C2,T2). For any (C,T ),w e
deﬁne (C,T )/unionsq⊥ =(C,T ). In the following we separate
the ﬂow functions into two parts: the ﬂow functions of the
taint domain and of the constraint domain. Let /angbracketleftn,m/angbracketrightbe a
control-ﬂow edge and let (Cin,Tin)refer to the data-ﬂow
fact before nand (Cout,Tout)denote the fact before m,
then we describe the ﬂow function Fin form of the result
set(Cout,Tout)=F(Cin,Tin). The analysis operates on an
intermediate representation, called Jimple [35]. We deﬁne the
analysis based on the statements affecting either CorTof a
data-ﬂow fact (C,T ).
B. Flow Functions of the Taint Domain
The ﬂow functions of the taint domain mostly follow
standard access-path based taint tracking data-ﬂow propaga-
tion [1], [36]. For instance, as a ﬁeld-sensitive analysis, COVA1. int a = obj.randomV alue();(TRUE,∅)
2. boolean x = getOptionX()(TRUE,∅)
3. if (x)(TRUE,{(x,TRUE,X)})
4 .a=1(X,{(x,X,X )})
(!X,{(x,!X,X )})
5. if (a <0)(X,{(x,X,X ),(a,X, 1)})
/unionsq(TRUE,{(x,!X,X ),(x,X,X ),(a,X, 1)})
(!X,{(x,!X,X )})
6. print(secret)True False
True Incomplete taint set Tin
Fig. 3. An example shows an incomplete taint set. Assume getOptionX() is
a constrain-API whose return value is represented by the symbolic value X.
kills any tainted access path with local variable xat an assign-
ment statement n:x=⋆1. LetT−
in=Tin\{(x,⋆,⋆ )}. For an
assignment statement n:x=yit isTout=T−
in∪{(x,c,v )}
if there is a taint (y,c,v )∈Tin, i.e., if any incoming access
path matches the right side, an access path for the left side is
added to the out set. For a ﬁeld-store assignment statement,
i.e.,n:x.a=y, an access-path based analysis has to add the
indirectly aliasing access paths ofx[1] and COVA relies on
an on-demand alias analysis [36]. A new taint is created at any
assignment statement where the right side of the statement is
labeled as a constraint-API. COVA also tracks values which
are indirectly inﬂuenced by constraint-APIs in form of taints.
We omit the details of each ﬂow function here due to space
constraints2.
C. Flow Functions of the Constraint Domain
To compute Cout, COVA conjoins the constraint Cinwith
an extending constraint Cnew which is created at conditional
statements or UI callbacks, i.e., Cout=Cin∧Cnew . The
constraint of each taint in Tinwill also be extended with Cnew .
Moreover, COVA only propagates taints whose constraints are
not equal to F ALSE . Thus,Tout={(x,c∧Cnew,v)|(x,c,v )∈
T−
inand(c∧Cnew/negationslash=F ALSE )}. In the following we focus on
introducing how Cnew is computed.
NORMAL FLOW FUNC :
For an if-statement n:if(a⊕b)with a comparison oper-
ator⊕, COVA creates Cnew based on the available taints in
Tin. The following cases are considered:
(i)Tincontains only taints for variable a(analog for b).
Assume there are ktaints (a,ci,vi)∈Tinwithi∈{1,...,k}.
Ifbis a constant, COVA creates a constraint eiby substituting
the variable ain the formula a⊕bwith its value viand
1The symbol ⋆is a placeholder representing an irrelevant argument.
2Detailed ﬂow functions can be found in the long version of this
paper at https://github.com/secure-software-engineering/COV A/blob/master/
longversion.pdf
105
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:08:56 UTC from IEEE Xplore.  Restrictions apply. conjoining the result with cifor each taint (a,ci,vi), i.e.,
ei=(vi⊕b)∧ciif the successor statement m is in the
TRUE branch of n. For the case mis in the F ALSE branch
ei=¬(vi⊕b)∧ci.I fbis an untracked variable, the formula
vi⊕bis replaced by the imprecise constraint im(vi)inei.
COVA then computes Cnew=(/logicalortextk
i=1ei)∨cmiss . We explain
the constraint cmiss in the following.
If COVA would track all values used in an if-statement,
the taints (a,ci,vi)∈Tin share the following invariant/logicalortextk
i=1ci=Cin. In practice, we often have an incomplete taint
setTin, which means the value of afor some constraint is
present, but not for the other constraints and the invariant is
violated. Figure 3 illustrates such a case. The taint set before
the statement if(a<0) indicates ato hold the value 1 under
the constraint X. The statement if(a<0) has constraint
Cin=TRUE (in red) and is unconditionally reachable. The
taint set for ais incomplete, because COVA cannot propagate
a taint for aunder the constraint !Xasaholds an unknown
return value of the method call obj.randomValue() .F o r
variableathe constraint !Xis the missing-constraint cmiss .
(ii)Tincontains taints for both aandb. Assume there are
ktaints (a,ci,vi)∈Tinandqtaints (b,dj,wj)∈Tin. COVA
computes eijby substituting aandbanalogously as in the
previous case. eij=(vi⊕wj)∧ci∧djfor the TRUE branch
andeij=¬(vi⊕wj)∧ci∧djfor the F ALSE branch. Let
cmiss anddmiss be the missing-constraints for variable aand
brespectively, Cnew=(/logicalortext
ijeij)∨cmiss∨dmiss .
For a switch-statement, the ﬂow function is analog.
CALL ENTRY FLOW FUNC :For a call n:o.f(a1,...,a k),
Cnew=sym (f)iffis a callback from the constraint-APIs.
CALL LOCAL FLOW FUNC :This function is the same as C AL-
LENTRY FLOW FUNC .
CALL EXIT FLOW FUNC :The constraint stays unchanged.
D. Obtaining the Constraint Map
V ASCO terminates once a ﬁxed point is reached. The result
computed by V ASCO is a map from (ctx,n )∈Context×
Statement to data-ﬂow facts in C×2T. TheCinvalues before
each statement are used to extract the constraint map. Since
a statement ncan be in multiple contexts, COVA merges the
Cinvalues of nfrom different contexts by logical disjunction.
IV . I MPLEMENT A TION
We implemented COVA as an extension to Soot [35]
that computes partial path constraints for Java and Android
applications. The constraint-APIs are given in conﬁguration
ﬁles. For Android apps, we construct call graphs using Flow-
Droid [1]. For alias analysis, COVA’s taint analysis uses
Boomerang [36], a demand-driven ﬂow- and context-sensitive
pointer analysis. To simplify and evaluate the constraints
during the constraint analysis, we rely on the theorem prover
Z3 [37]. COVA only propagates taints with satisﬁable con-
straints. The current implementation fully supports constraints
in boolean propositional logic, equality logic and linear arith-
metic logic. To increase scalability we did not model stringoperations precisely, but instead only use imprecise symbolic
values to express them.
To be able to judge the conﬁdence in the results COVA
reports, we developed a new micro-benchmark (publicly avail-
able with COVA), comprising 92 specially crafted test pro-
grams (e.g., primitives or heap objects used in conditional
statements, nested conditional statements, intra- and inter-
procedural conditional dependencies, callback invocations, in-
direct conditional dependencies, etc.). On this benchmark,
COVA achieved a precision of 100% and a recall of 95%,
which gives us a reasonable conﬁdence of the results COVA
computes.
V. E V ALUA TION
Our evaluation is designed to understand the nature of
taint ﬂows detected by a static Android taint-analysis tool,
and potential avenues to eliminating false positives among
those taint ﬂows. We chose FlowDroid [1] as our evaluation
tool, since it is well maintained and, according to previous
studies [29], [38], beats other tools both in accuracy and
efﬁciency. The evaluation intends to answer the following
research questions:
•RQ1. What types of taint ﬂows does FlowDroid report?
How common is each type?
•RQ2. How large is the fraction of easily actionable
unconditional intra-procedural taint ﬂows, and what char-
acteristics do these ﬂows have?
We next address both questions one after the other.
RQ1. What types of taint ﬂows does FlowDroid report?
How common is each type? :
a) Methodology: We randomly sampled 2,000 Android
apps from the AndroZoo dataset [39]. All sampled apps were
available in popular app stores (Google Play and Anzhi Mar-
ket) between year 2016 and 2018. These criteria ensure that
we report on the real-world apps from recent years. The apps
can be downloaded from this link3. We used FlowDroid v2.5.1
in its default conﬁguration. In this conﬁguration, FlowDroid
lists 47 methods as sources4and 122 as sinks. We applied
FlowDroid to these 2,000 apps and it reported 1,022 apps to
contain data leaks. FlowDroid reported 28,176 taint ﬂows for
these 1,022 apps, which makes it intractable to study every
single taint ﬂow in every app. Thus, our methodology follows
these two steps:
(1) we measured which source-sink-pairs appeared in the
taint ﬂows and chose the top 3 source-sink-pairs among intra-
and inter-procedural taint ﬂows (see Table I) for our case study,
since these source-sink-pairs dominate a large amount of taint
ﬂows, and among most (88%) of the remaining pairs each
pair only appeared in fewer than 50 taint ﬂows (out of 28,176
in total). To determine apps for our case study, we applied
stratiﬁed random sampling : the apps with taint ﬂows using
these 6 source-sink-pairs are divided into 6 groups, one for
3https://www.kaggle.com/covaanalyst1/cova-dataset
446 sources are listed in the conﬁguration ﬁle SourcesAndSinks.txt
and 1 source android.app.Activity.ﬁndViewById(int) is treated specially by
only considering password input ﬁelds.
106
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:08:56 UTC from IEEE Xplore.  Restrictions apply. T ABLE I
STRA TIFIED SAMPLING THE TOP SOURCE -SINK -P AIRS AMONG THE T AINT FLOWS REPORTED BY FLOW DROID
Gr . Source Sink #Taint Flows #Apps #Sampled Apps
Intra-procedural
A java.net.URL.openConnection java.net.HttpURLConnection.setRequestProperty 2,193 535 54
B android.os.Handler.obtainMessage android.os.Handler.sendMessage 1,410 199 20
C java.net.HttpURLConnection.getOutputStream java.io.OutputStream.write 194 166 17
Inter-procedural
D android.database.Cursor.getString android.app.Activity.startActivityForResult 1,440 156 16
E java.net.URL.openConnection java.net.HttpURLConnection.setRequestProperty 862 291 30
F android.database.Cursor.getString android.os.Bundle.putString 847 85 9
each pair, which we here label with A to F. Due to large
amount of reverse engineering and manual work involved in
the inspection, we only sampled 10% of the apps of each
group. The manual inspection was done in pair by two of the
authors.
(2) we conducted an experiment in which we applied both
FlowDroid and COVA to the apps in our dataset. An app
is passed to both FlowDroid and COVA (see Figure 2). The
experiment was designed to classify the taint ﬂows with the
following types :
•UI-constrained taint ﬂows are dependent on UI actions.
•Conﬁguration-constrained taint ﬂows are dependent on
hardware/software conﬁguration.
•I/O-constrained taint ﬂows are dependent on data inputs
through streams or ﬁle system.
Whenever a taint ﬂow is reported by FlowDroid, we conjoin
the constraints of the source and the sink computed by
COVA to obtain the leak-constraint and use it to classify this
taint ﬂow. For instance, the leak in our motivating example
(see Figure 1) will be classiﬁed to both UI-constrained and
Conﬁguration-constrained, since the leak-constraint SDK≤
26∧CLICK ∧TELEPHONY contains symbolic values
which stand for conﬁguration ( SDK and TELEPHONY ) and
UI action (CLICK) at the same time. We collected a list of
constraint-APIs from the Android Platform (API level 27) that
COVA ought to track:
•335 APIs for UI actions, which are UI callbacks. We
ﬁrst scanned the whole Android platform with gestural
keywords such as click, scroll, etc., to extract a list of
possible UI callbacks. Based on this list, callbacks were
manually selected.
•448 APIs for hardware and software conﬁguration. We
collected the APIs based on the ofﬁcial Android guide of
device compatibility [40].
•120 APIs for data input via I/O streams or ﬁle system,
which are mainly from the java.io package.
The selection of the APIs was done by pair-reviewing by
two researchers. The list is publicly available with COVA.
We set a timeout of 30 minutes per app for COVA. COVA
terminated its analysis and computed a complete constraint
map for 315 apps. (In cases in which analysis times out, this
was most often due to slow constraint solving in Z3, see sec-
tion VI.) For the remaining 707 apps, COVA only computed
partial constraint maps. The experiment was conducted on aUI-constrained
Conﬁguration-constrained I/O-constrainedInfeasible
False positives
Unconstrained9.3%
2.7% 0.6%0.7%
31%
54.8%0.04%0.7% 0.1%
0.004%
Fig. 4. Different types of taint ﬂows.
/*** code pattern 1 ***/
HttpURLConnection c = (HttpURLConnection) new
URL( "http..." ).openConnection(); //source
c.setDoInput( true );
c.setRequestProperty( "User-Agent" ,"Mozilla/5.0" );
//sink
/*** code pattern 2 ***/
Message m = handler.obtainMessage(); //source
handler.sendMessage(m); //sink
/*** code pattern 3 ***/
HttpURLConnection c = (HttpURLConnection) new
URL( "http..." ).openConnection();
c.setDoOutput( true );
OutputStream s = c.getOutputStream(); //source
s.write(data); //sink
Listing 1. Code patterns from group A, B, C.
virtual machine with an Intel Xeon CPU running on Debian
GNU/Linux 9 with Oracle’s Java Runtime version 1.8 (64 bit).
The maximal heap size of the JVM was set to 24 GB.
b) Results: Figure 4 shows the different types of taint
ﬂows and their fractions in our study. While the false positives
were all identiﬁed in step (1), the fractions of other types
(UI-constrained, Conﬁguration-constrained, I/O-constrained,
Infeasible, Unconstrained and intersections) were computed in
step (2). The infeasible taint ﬂows are those with unsatisﬁable
leak-constraints reported by COVA. The fraction of the uncon-
strained taint ﬂows is only an upper bound. For apps on which
COVA timed out, if there is no constraint for the source and
107
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:08:56 UTC from IEEE Xplore.  Restrictions apply. public class MainActivity extends Activity {
private String secret;
public void caller(){
this .secret = cursor.getString(i); //source
callee();
}
public void callee() {
Intent i = new Intent();
this .startActivityForResult(i, ...); //sink
}}
Listing 2. Code pattern from group D.
sink statements of a taint ﬂow in the partial constraint map,
we assigned this taint ﬂow with the type “Unconstrained”.
In step (1), we studied the most common taint ﬂows while
keeping the following questions in mind: Is this taint ﬂow
feasible, i.e., could it be a leak? Do some code patterns with
the same source-sink-pair exist in the taint ﬂows? To assess
the feasibility, we used the data-ﬂow path (in Jimple) between
source and sink of each taint ﬂow reported by FlowDroid and
the decompiled code of the apps.
Intra-procedural taint ﬂows, Groups A-C: As shown in
Table I, the source-sink-pair ( URL.openConnection ,HttpURL-
Connection.setRequestProperty ) appeared most frequently in
both intra- and inter-procedural taint ﬂows (group A and E).
While the given source method creates a connection object
with a given URL, the sink sets the general properties of a
HTTP request. This source-sink-pair combination apparently
does not constitute a leak, since the connection is not even
opened when only calling URL.openConnection . One instead
still has to call URLConnection.connect or equivalent methods
(e.g., URLConnection.getInputStream ) to initiate the commu-
nication [41]. During the inspection for the above-mentioned
source-sink-pair in group A, we discovered that the reported
taint ﬂows share some common patterns. Code pattern 1 in
Listing 1 shows an example usage of this source-sink-pair,
which is a common way to set up the header of a HTTP
request. This is no leak.
Code pattern 2 in Listing 1 is another common pat-
tern we identiﬁed in group B. The factory method Han-
dler .obtainMessage is regarded as a source by FlowDroid. This
method creates a new empty message instance. It does not poll
a message from the message queue of the Android handler.
This method should thus be excluded from the list of sources.
Code pattern 3 from group C is a similar case.
In summary, taint ﬂows which fall into these code patterns
are false positives. To determine how many taint ﬂows match
these code patterns, we extended FlowDroid to detect these
patterns, and re-analyzed the apps in groups A, B and C. In the
end, 2,630 (46%) reported intra-procedural taint ﬂows matched
these three code patterns. As shown in these code patterns,
the root cause of these false positives is that their sources,
which FlowDroid uses in its default conﬁguration, are actually
inappropriate, i.e., they do not return sensitive data.
Such a big fraction of false positives caused by this reason
cannot be ignored. Thus, the ﬁrst author examined all 47T ABLE II
INAPPROPRIA TE SOURCES AND SINKS USED BY FLOW DROID
Signature
android.os.Handler.obtainMessage()
android.os.Handler.obtainMessage(int,int,int)
android.os.Handler.obtainMessage(int,int,int,Object)
android.os.Handler.obtainMessage(int)
android.os.Handler.obtainMessage(int,Object)
android.app.PendingIntent.getActivity(Context,int,Intent,int)
android.app.PendingIntent.getActivity(Context,int,Intent,int,Bundle)
android.app.PendingIntent.getBroadcast(Context,int,Intent,int)
android.app.PendingIntent.getService(Context,int,Intent,int)
java.net.URLConnection.getOutputStream()
java.net.URL.openConnection() *[ regarded as both source and sink ]
sources by reading the Javadoc carefully together with one de-
veloper with more than 5 years experience in Java. Altogether,
they identiﬁed 11 APIs that were mistakenly made source/sink
(see Table II). These inappropriate sources and sinks resulted
in 7,767 reported taint ﬂows, which is 28% of all reported
taint ﬂows (intra- and inter-procedural).
About a quarter (11/47) of default sources provided by
FlowDroid are inappropriate and cause more than a quarter
(28%) of all reported taint ﬂows being false positives.
After a discussion with FlowDroid’s maintainers, they con-
ﬁrmed the mistake and removed the inappropriate sources and
sinks from the default list in FlowDroid’s GitHub repository.5
This affects the pairs A, B, C and E.
Inter-procedural taint ﬂows, Groups D-F: Because the
source of group E is inappropriate, the manual inspection
of this group was unnecessary. We next describe the results
of the manual inspection of the remaining groups D and
F. The taint ﬂows from group D use the source-sink-pair
(Cursor .getString ,Activity.startActivityF orResult ). Taint-ﬂows
with this source-sink-pair could be part of a leak when the
intent passed to Activity.startActivityF orResult contains data
reading from Cusor .getString and the second activity passes
this received data to an untrusted sink. Since taint ﬂows using
such inter-component communication are outside the scope
of FlowDroid, our goal for inspection was only to check
if this partial data-ﬂow is feasible. Surprisingly 88% of the
taint ﬂows from Group D proved to be false positives. All
these false positives share a similar code pattern, shown in
Listing 2. In this example, FlowDroid taints this.secret
and reports a leak when the sink method is called on the
base object of the taint this.secret , which is the this
object. However, there is no tainted data that ﬂows into the
intent passed for the sink method. Such over-approximation
in FlowDroid’s analysis logic, while sometimes useful, is too
approximative for the sink Activity.startActivityF orResult .
Generally, taint ﬂows with taints connecting sources and
sinks on the same objects should be ﬁltered. Thus, we extended
FlowDroid with a static analysis that detects such cases and re-
5The link to the commit: https://github.com/secure-software-engineering/
FlowDroid/commit/211b73e32a0ade1ded021f2fc30b0aa647be5862
108
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:08:56 UTC from IEEE Xplore.  Restrictions apply. analyzed the relevant apps. 330 taint ﬂows matched the false
positive pattern in Listing 2. In total, we identiﬁed 978 taint
ﬂows with taints connecting sources and sinks on the same ob-
jects. The sinks appearing in these taint ﬂows are mainly APIs
used for inter-component communication. The remaining sinks
(e.g. HttpResponse.execute(HttpUriRequest) ) only make sense
when the right parameter was tainted. However, FlowDroid
reported these taint ﬂows when the base object was tainted.
In our study, all taint ﬂows reported by FlowDroid with
taints connecting sources and sinks on the same objects
are false positives.
The sink Bundle.putString used in taint ﬂows from group F
is also an API for inter-component communication. Similar to
group D, we checked if the reported partial ﬂow is feasible. We
found out that while 89% of the reported ﬂows are feasible,
the false positives all happened in one app and the ﬂows were
just for putting the name of the app into the sink. However, the
fact that the partial ﬂows are feasible does not mean they are
a part of true leaks, since one does not know how the sensitive
data stored in Bundle were used in other activities, which was
not reported by FlowDroid. In total, we identiﬁed that at least
one third (31%) of taint ﬂows reported by FlowDroid in the
default conﬁguration are false positives.
In step (2), we classiﬁed6taint ﬂows that are dependent
on the constraint-APIs with COVA. For instance, if the
leak-constraint contains symbolic values that relate to the
constraint-APIs from UI callbacks, then this taint ﬂow belongs
to category “UI-constrained”. Certainly, there can be taint
ﬂows which belong to multiple categories.
As shown in Figure 4, among the 14.2% taint ﬂows whose
occurrences are dependent on the constraint-APIs in the cate-
gories, the majority are in a single category – UI-constrained,
which means they only occur when some speciﬁc UI actions
are performed. 2.7% of the taint ﬂows may happen under
certain environment conﬁgurations, and 0.6% are dependent
on inputs from I/O operations. The numbers in the V enn
diagram’s intersections of different categories indicate that
interactions between values read from APIs in different cate-
gories are rare but do exist.
Taint ﬂows are seldom conditioned by combinations of
UI interactions, environment conﬁgurations and I/O opera-
tions. Most taints could thus be dynamically conﬁrmed by
different tools that specialize on the respective category.
Because complex UI dependencies may require a test har-
ness to drive the application with the needed sequences of
events, we investigated the complexity of the UI actions.
Intuitively, taint ﬂows triggered by a sequence of user actions
should exist. A previous study [9] has found malicious ap-
plications in which a user needs to click a series of buttons
to trigger the display of a widget which leaks the data. To
6Note: For the classiﬁcation, we excluded the false positives we identiﬁed
in step (1).123456789 1 0 1 105001,0001,5002,000
1,475
325
114318 297
34 42 16 44 2
Number of UI actionsNumber of taint ﬂows
Fig. 5. The distribution of UI-constrained taint ﬂows.
T ABLE III
TOP CONSTRAINT -API S RELA TED TO T AINT FLOWS
UI Callback #Flows
android.view.View.OnClickListener.onClick 2088
android.widget.AdapterView.OnItemClickListener.onItemClick 623
android.content.DialogInterface.OnClickListener.onClick 595
Conﬁguration #Flows
android.os.Build.VERSION.SDK INT 255
android.content.Context.getSystemService(“connectivity”) 246
android.content.Context.getSystemService(“location”) 224
I/O Operation #Flows
java.io.InputStream.read 158
java.io.BufferedReader.readLine 16
java.io.ObjectInputStream.readObject 10
estimate the complexity, we calculated how many different
UI actions are involved in a UI-constrained taint ﬂow by
counting the number of symbolic values for UI actions used
in the leak-constraint. (Note that our constraint encoding is
able to distinguish different UI actions.) Figure 5 shows the
distribution of UI-constrained taint ﬂows. 56.1% (1,475) of
taint ﬂows happen after a single UI action. There are only
3.8% of taint ﬂows that may require 6 or more UI actions.
Maximally 11 different actions appeared in a leak-constraint.
However, executing the taint ﬂow does not require all 11
actions at the same time, since there are disjunctions in the
leak-constraint (e.g., A∨Bcontains two actions AandB,b u t
one action is sufﬁcient to execute the taint ﬂow).
Despite the existence of sophisticated sequences of UI
actions, our results indicate the dynamic exploration of
most UI action-related taint ﬂows could be easier than
expected.
Among the conﬁguration-constrained taint ﬂows, the dis-
tribution is even simpler: the largest number of taint ﬂows
(85.6%) require a single conﬁguration option and 13.9% of
them are dependent on two options. Only 5 taint ﬂows happen
under a complex conﬁguration with more than two options.
The necessary conﬁguration-based conditions for exposing
taint ﬂows are easy to be satisﬁed in the majority of cases.
Table III shows which constraint-APIs from our categories
are most frequently used. While click events are relevant
to most taint ﬂows related to UI actions, the Android SDK
109
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:08:56 UTC from IEEE Xplore.  Restrictions apply. version plays a considerable role in environment conﬁgura-
tions. This is not surprising to us, since the Android operating
system remains highly fragmented [42]–[44] and developers
are challenged to produce applications that are compatible to
multiple platform versions. However, the importance of taint
ﬂows which only occur in obsolete versions of Android may
be limited in practice. Constraints based on I/O operations are
mostly checking if the end of a data stream has been reached,
e.g.,if(inputStream.read()!=-1) .
Additionally, we observed that for 28% of the 208 infeasible
taint ﬂows, their source statements were not executable, since
the path constraint is F ALSE . For 76% of the infeasible
taint ﬂows, their sink statements will never be executed at
runtime. Such dead code was probably intentionally built in
by developers [45], e.g., during sampling, we inspected code
used for logging (sinks of taint ﬂows) that was disabled with
a boolean ﬂag for the released APK, but not removed.
RQ2. How large is the fraction of easily actionable uncon-
ditional intra-procedural taint ﬂows, and what characteristics
do these ﬂows have? :
c) Methodology: Taint ﬂows that are intra-procedural
and unconstrained, i.e., the leak-constraint computed by
COVA is equal to true , are easy to detect and clearly directly
actionable for developers. We call such ﬂows “low-hanging
fruits” . We sought to acquire the characteristics of the “low-
hanging fruits”, and thus again applied stratiﬁed random
sampling with proportion 10% to the taint ﬂows with top
source-sink-pairs in Table IV.
d) Results: In our study, only 3.5% of the taint ﬂows
are “low-hanging fruits” (intra-procedural and unconstrained).
However, “low-hanging fruits” are still the majority of the
intra-procedural taint ﬂows and they exist in 32% (329) of
the apps in our dataset. During the manual inspection for
taint ﬂows with top source-sink-pairs in Table IV, we found
that taint ﬂows with source-sink-pair of group X cannot
usually be interpreted as leaks. Listing 3 shows a simpli-
ﬁed taint ﬂow using this source-sink-pair. The private ﬁeld
this.secret is ﬁrst tainted. FlowDroid taints the return
value of this.getContentResolver() since the base
object is the preﬁx of the tainted this.secret . Finally,
the taint ﬂow is then reported when the sink is called on
the tainted this.getContentResolver() . This is again
an over-approximation FlowDroid uses similar to the one
in Listing 2. However, such taint ﬂow could be a leak,
since the implementation of Context.getContentResolver and
ContentResolver .query could be overridden maliciously.
In comparison to group X, taint ﬂows of group Y and Z are
straightforward: they log data from databases. Actually, the log
methods from android.util.Log are the most frequently used
sinks. About half (46%) of the “low-hanging fruits” are leaks
in which sensitive information such as data from databases,
location information, device ID, the MAC addresses or even
passwords are logged. Many of these leaks even have source
and sink at the same line of code. In addition, the text that will
be logged often speciﬁes what kind of data is being logged.T ABLE IV
TOP SOURCE -SINK -P AIRS AMONG “LOW -HANGING FRUITS ”
Gr . Source Sink#Sampled/#Total
Taint Flows
Xandroid.database.
Cursor.getStringandroid.content.
ContentResolver.query14/137
Yandroid.database.
Cursor.getStringandroid.util.Log.e 10/96
Zandroid.database.
Cursor.getStringandroid.util.Log.i 7/70
public class MainActivity extends Activity {
private String secret;
public void foo(){
this .secret = cursor.getString(i); //source
this .getContentResolver().query(...); //sink
}}
Listing 3. Code pattern from group X.
Besides log methods, sinks for inter-component communi-
cation such as Bundle.putString ,SharedPreferences.putString
and Context.sendBroadcast are also popular among the “low-
hanging fruits”. They appeared in 20% of the taint ﬂows. To
determine if these taint ﬂows are malicious, additional context
must be provided, since benign applications often use these
methods for accessing and modifying preference data between
activities.
Discussion :First, our results show important ways in which
taint-analysis tools can and should be improved. On the one
hand, the sources and sinks conﬁgured for the tools should
be checked more carefully, since an inappropriate source can
cause a large amount of false positives, as we determined
for FlowDroid in RQ1. Researchers who used FlowDroid
in the default conﬁguration may need to re-evaluate their
conclusions. Even in just a short investigation, we already
found 9 papers in which the respective work was built on top
of FlowDroid and inappropriate sources or sinks were used
[20]–[28]. In none of these papers did the authors mention that
they have manually checked for false positives that would have
been caused by the inappropriate source/sink conﬁgurations.
Hence, while it is possible that such manual checks were
conducted without mentioning them, it is equally possible that
the papers report results that are distorted by the presence
of those false positives. Given the over 1,000 citations of
the FlowDroid paper, many more such works are likely to
exist. On the other hand, some rules used in taint analysis
may be not suitable for all sources and sinks, as we have
seen in the case shown in Listing 2 for FlowDroid, a taint
ﬂow was reported when the base object calling the sink was
tainted. However, here the correct way to report a taint ﬂow
is when the actual argument (intent) of the sink is tainted.
Such cases could be handled easily without increasing analysis
complexity. Although we only studied the results reported by
FlowDroid, problems we discovered for such a widely used
tool may not be a single case among numerous taint-analysis
tools.
Second, hybrid analysis tools may well be feasible for the
110
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:08:56 UTC from IEEE Xplore.  Restrictions apply. case of Android. The results of RQ1 show that to conﬁrm
static taint ﬂows dynamically, they should focus on modeling
UI actions, but in some cases must be able to set correct
environment options as well, and must deal with stream-I/O to
some limited extent. Luckily, the overlap between those three
classes is small, so that one can probably go a long way even
by designing speciﬁc, decoupled analysis tools for all three
situations. Our tool COVA can further aid the implementation
of such hybrid analysis tools: the path constraints it computes
can guide dynamic analyses, even in situations where ﬂows
are not conditioned on external stimuli at all.
Third, “low-hanging fruits”, i.e., unconditional intra-
procedural ﬂows, are quite common—they exist in 32% of all
apps as we show in RQ2. Many of such leaks can be easily
ﬁxed, and so even purely static taint-analysis tools can and
should prioritize these leaks in the report.
VI. L IMIT A TIONS
COVA computes partial path constraints—it only consid-
ers control-ﬂow decisions that are dependent on a list of
constraint-APIs we collected. However, as we discuss in
section V, we feel that by the way this list was collected,
it is comprehensive. Although COVA supports most language
features, some corner cases such as reﬂection or native calls
are not covered [46]. In some cases, the taint set computed by
COVA may be incomplete due to unknown return values of
API method calls such that an over-approximated constraint
is computed. For Android applications, we use the call graph
constructed by FlowDroid. This call graph, however, is par-
tially incomplete for library methods and some UI callbacks
[47], [48]—a known limitation of FlowDroid.
Since COVA uses Z3 for constraint-solving, the limitations
of Z3 are inherited by COVA. In our experiments, an average
of 49% percent of the analysis time was occupied by Z3. In
fact, this is also one of the main reasons why COVA failed
to analyze some apps within the given time budget. In the
worst case, 98% of the analysis time for an app was spent for
constraint-solving. Increasing the time budget may not help,
since Z3 can hit memory pressure and throw exceptions when
solving large formulas, which happened in our preliminary
experiments. Such exceptions cannot be evaded by increasing
the JVM heap size, since they originate from the native code
of Z3. In the future, we plan to turn COVA into an on-
demand analysis such that it only computes a constraint for a
given statement instead of computing a constraint map for all
reachable statements.
Since COVA failed to analyze some apps in our experiment,
our study may have been biased to include only certain kinds
of taint ﬂows. Many of the ”unconstrained” taint ﬂows might
be constrained by multiple factors in reality.
VII. R ELA TED WORK
We discuss how our approach relates to previous work in
the areas of taint analysis, path conditions, as well as hybrid
analysis approaches.Studies Involving Taint Flows: Many researchers have
studied Android applications from various perspectives [17],
[24], [25], [49]–[52]. Avdiienko et al. [24] compared the taint
ﬂows in benign apps against those in malicious apps, and
used machine learning to identify the differences in usage
of sensitive data. Unlike COVA, their approach MUDFLOW
does not consider path constraints. Keng et al. [17] moni-
tored 220 Android apps with the dynamic taint-analysis tool
TaintDroid [53] to study the correlation between user actions
and leaks. However, their results are limited to the leaks they
observed during the runtime. Their results show that many
apps leak data due to user actions on certain GUI widgets,
which we were able to show statically. Closely related to our
approach, Lillack et al. [51] also extended taint analysis to
explore the variability of Android apps based on load-time
conﬁguration. However, their approach encodes constraint
analysis as a distributive problem in the IFDS framework [33].
For our purpose, this model is insufﬁcient, since the execution
of a branch may depend simultaneously on two or more
conﬁguration options, which IFDS cannot express [31], [54].
Path Conditions: Many approaches have considered
path conditions to increase the accuracy of their analysis.
Snelting [30] has shown how exacting and simplifying path
conditions can improve slice accuracy. Taghdiri et al. [55]
made information ﬂow analysis more precise by incrementally
reﬁning path conditions with witnesses that did not yield
an information ﬂow in execution. T ASMAN [56] leverages
backward symbolic execution as a post-analysis to eliminate
false positives in which taint ﬂows along paths are infeasi-
ble at runtime. T ASMAN is based on the distributive IFDS
framework, but constraint computation is not a distributive
problem. T ASMAN thus needs to approximate in places which
COVA can handle precisely. In result, COVA’s computation
is more expensive but COVA’s path expressions are also more
precise. A general major limitation of symbolic execution is
that it cannot explore executions with path conditions which
the underlying SMT solver cannot deal with in the given
time budget [57]. This limitation is shared with COVA. To
improve scalability, modern symbolic execution techniques
mix concrete and symbolic execution in so-called concolic
execution. Anand et al. [58] propose a concolic execution
approach to generate sequences of UI events for Android appli-
cations. Sch ¨utte et al. [59] also use concolic execution to drive
execution to cover target code. They claim that their approach
is not limited to any speciﬁc kind of conditions, i.e., can handle
all kinds of condition (user input, environmental setting and
even remote site input). Y et their prototype ConDroid was only
designed and evaluated for one speciﬁc vulnerability. COVA
was evaluated on a wide range of taint ﬂows. The results of
our study indicate that tools which seek to expose taint ﬂow
dynamically could concentrate on one kind of condition at a
time, which is important for scalability.
Hybrid Analysis: A number of hybrid approaches, i.e.,
combinations of static and dynamic analysis, have been pro-
posed for Android malware detection [9]–[14]. SmartDroid
by Zheng et al. [9] statically detects UI interaction sequences
111
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:08:56 UTC from IEEE Xplore.  Restrictions apply. that lead to sensitive API calls, and it exposes those behaviors
dynamically. Y ang et al. [10] propose a hybrid approach
in which they ﬁrst identify the possible attack-critical path
with static mining algorithms based on sensitive APIs and
existing malware patterns, then execute the program in a
focused scope under dynamic taint analysis. Wong et al. [13]
demonstrate IntelliDroid, a tool which generates a reasonably
small set of inputs statically to trigger malicious behavior of
applications. Their evaluation shows that one only needs to
execute a very small part of the application to expose malicious
behaviors. Recent work of Rasthofer et al. [12] combines a
set of static and dynamic analyses with fuzzing to generate
execution environments to expose hidden malicious behaviors
efﬁciently.
VIII. C ONCLUSION
In this paper, we introduced COVA, a new tool for tracking
user-deﬁned APIs through the program and computing path
constraints based on these APIs. We conducted a COVA-
supported study which gathers information about the nature
of static taint-analysis results, particularly with FlowDroid.
Our study shows important ways how static taint-analysis
tools can be improved and how information about taint-
ﬂows conditioned on different factors can be used for future
taint-analysis research, particularly with the aim of further
eliminating false positives.
IX. A CKNOWLEDGMENT
We would like to thank Manuel Benz for his assistance
in selecting the constraint-APIs and Jonas Manuel for his
assistance in reviewing the default list of sources and sinks
provided by FlowDroid. We would also like to thank our
reviewers for their comments.
This research was supported by the research training group
Human Centered Systems Security (NERD.NRW) sponsored
by the state of North Rhine-Westphalia in Germany.
REFERENCES
[1] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel, J. Klein, Y . L.
Traon, D. Octeau, and P . D. McDaniel, “Flowdroid: precise context,
ﬂow, ﬁeld, object-sensitive and lifecycle-aware taint analysis for android
apps,” in ACM SIGPLAN Conference on Programming Language Design
and Implementation, PLDI ’14, Edinburgh, United Kingdom - June 09
- 11, 2014 , 2014, pp. 259–269.
[2] F. Wei, S. Roy, X. Ou, and Robby, “Amandroid: A precise and general
inter-component data ﬂow analysis framework for security vetting of
android apps,” in Proceedings of the 2014 ACM SIGSAC Conference on
Computer and Communications Security, Scottsdale, AZ, USA, Novem-
ber 3-7, 2014 , 2014, pp. 1329–1341.
[3] M. I. Gordon, D. Kim, J. H. Perkins, L. Gilham, N. Nguyen, and M. C.
Rinard, “Information ﬂow analysis of android applications in droidsafe,”
in22nd Annual Network and Distributed System Security Symposium,
NDSS 2015, San Diego, California, USA, February 8-11, 2015 , 2015.
[4] L. Li, A. Bartel, T. F. Bissyand ´e, J. Klein, Y . L. Traon, S. Arzt,
S. Rasthofer, E. Bodden, D. Octeau, and P . D. McDaniel, “Iccta:
Detecting inter-component privacy leaks in android apps,” in 37th
IEEE/ACM International Conference on Software Engineering, ICSE
2015, Florence, Italy, May 16-24, 2015, V olume 1 , 2015, pp. 280–291.
[5] W . Huang, Y . Dong, A. Milanova, and J. Dolby, “Scalable and precise
taint analysis for android,” in Proceedings of the 2015 International
Symposium on Software Testing and Analysis, ISSTA 2015, Baltimore,
MD, USA, July 12-17, 2015 , 2015, pp. 106–117.[6] L. Li, T. F. Bissyand ´e, M. Papadakis, S. Rasthofer, A. Bartel, D. Octeau,
J. Klein, and Y . L. Traon, “Static analysis of android apps: A systematic
literature review,” Information & Software Technology , vol. 88, pp. 67–
95, 2017.
[7] M. Christakis and C. Bird, “What developers want and need from
program analysis: an empirical study,” 2016, pp. 332–343.
[8] B. Johnson, Y . Song, E. R. Murphy-Hill, and R. W . Bowdidge, “Why
don’t software developers use static analysis tools to ﬁnd bugs?” 2013,
pp. 672–681.
[9] C. Zheng, S. Zhu, S. Dai, G. Gu, X. Gong, X. Han, and
W . Zou, “Smartdroid: an automatic system for revealing ui-
based trigger conditions in android applications,” in SPSM’12,
Proceedings of the Workshop on Security and Privacy in Smartphones
and Mobile Devices, Co-located with CCS 2012, October 19,
2012, Raleigh, NC, USA , 2012, pp. 93–104. [Online]. Available:
http://doi.acm.org/10.1145/2381934.2381950
[10] T. Y ang, K. Qian, L. Li, D. C. Lo, and L. Tao, “Static mining and
dynamic taint for mobile security threats analysis,” in 2016 IEEE
International Conference on Smart Cloud, SmartCloud 2016, New
York, NY, USA, November 18-20, 2016 , 2016, pp. 234–240. [Online].
Available: https://doi.org/10.1109/SmartCloud.2016.43
[11] J. C. J. Keng, “Automated testing and notiﬁcation of mobile app
privacy leak-cause behaviours,” in Proceedings of the 31st IEEE/ACM
International Conference on Automated Software Engineering, ASE
2016, Singapore, September 3-7, 2016 , 2016, pp. 880–883. [Online].
Available: http://doi.acm.org/10.1145/2970276.2975935
[12] S. Rasthofer, S. Arzt, S. Triller, and M. Pradel, “Making malory behave
maliciously: targeted fuzzing of android execution environments,”
inProceedings of the 39th International Conference on Software
Engineering, ICSE 2017, Buenos Aires, Argentina, May 20-28, 2017 ,
2017, pp. 300–311. [Online]. Available: https://doi.org/10.1109/ICSE.
2017.35
[13] M. Y . Wong and D. Lie, “Intellidroid: A targeted input generator for
the dynamic analysis of android malware,” in 23rd Annual Network
and Distributed System Security Symposium, NDSS 2016, San Diego,
California, USA, February 21-24, 2016 , 2016.
[14] M. Xia, L. Gong, Y . Lyu, Z. Qi, and X. Liu, “Effective real-time
android application auditing,” in 2015 IEEE Symposium on Security
and Privacy, SP 2015, San Jose, CA, USA, May 17-21, 2015 , 2015,
pp. 899–914. [Online]. Available: https://doi.org/10.1109/SP .2015.60
[15] J. Oberheide and M. Charlie, “Dissecting the Android Bouncer,”
accessed 2018-07-20. [Online]. Available: https://jon.oberheide.org/
ﬁles/summercon12-bouncer.pdf
[16] T. Vidas and N. Christin, “Evading android runtime analysis via
sandbox detection,” in 9th ACM Symposium on Information, Computer
and Communications Security, ASIA CCS ’14, Kyoto, Japan -
June 03 - 06, 2014 , 2014, pp. 447–458. [Online]. Available:
http://doi.acm.org/10.1145/2590296.2590325
[17] J. C. J. Keng, T. K. Wee, L. Jiang, and R. K. Balan, “The case for
mobile forensics of private data leaks: towards large-scale user-oriented
privacy protection,” in Asia-Paciﬁc Workshop on Systems, APSys ’13,
Singapore, Singapore, July 29-30, 2013 , 2013, pp. 6:1–6:7. [Online].
Available: http://doi.acm.org/10.1145/2500727.2500733
[18] E. J. Schwartz, T. Avgerinos, and D. Brumley, “All you ever
wanted to know about dynamic taint analysis and forward symbolic
execution (but might have been afraid to ask),” in 31st IEEE
Symposium on Security and Privacy, S&P 2010, 16-19 May 2010,
Berleley/Oakland, California, USA , 2010, pp. 317–331. [Online].
Available: https://doi.org/10.1109/SP .2010.26
[19] M. G. Kang, S. McCamant, P . Poosankam, and D. Song, “DT A++:
dynamic taint analysis with targeted control-ﬂow propagation,” in Pro-
ceedings of the Network and Distributed System Security Symposium,
NDSS 2011, San Diego, California, USA, 6th February - 9th February
2011 , 2011.
[20] L. Li, A. Bartel, J. Klein, Y . L. Traon, S. Arzt, S. Rasthofer, E. Bodden,
D. Octeau, and P . D. McDaniel, “I know what leaked in your pocket:
uncovering privacy leaks on android apps with static taint analysis,”
CoRR , vol. abs/1404.7431, 2014.
[21] O. Mirzaei, G. Suarez-Tangil, J. E. Tapiador, and J. M. de Fuentes,
“Triﬂow: Triaging android applications using speculative information
ﬂows,” in Proceedings of the 2017 ACM on Asia Conference on
Computer and Communications Security, AsiaCCS 2017, Abu Dhabi,
United Arab Emirates, April 2-6, 2017 , 2017, pp. 640–651. [Online].
Available: http://doi.acm.org/10.1145/3052973.3053001
112
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:08:56 UTC from IEEE Xplore.  Restrictions apply. [22] D. Zhu, H. Jin, Y . Y ang, D. Wu, and W . Chen, “Deepﬂow: Deep learning-
based malware detection by mining android application for abnormal
usage of sensitive data,” in 2017 IEEE Symposium on Computers and
Communications, ISCC 2017, Heraklion, Greece, July 3-6, 2017 , 2017,
pp. 438–443.
[23] P . Calciati, K. Kuznetsov, X. Bai, and A. Gorla, “What did really
change with the new release of the app?” in Proceedings of the 15th
International Conference on Mining Software Repositories, MSR 2018,
Gothenburg, Sweden, May 28-29, 2018 , 2018, pp. 142–152. [Online].
Available: http://doi.acm.org/10.1145/3196398.3196449
[24] V . Avdiienko, K. Kuznetsov, A. Gorla, A. Zeller, S. Arzt, S. Rasthofer,
and E. Bodden, “Mining apps for abnormal usage of sensitive data,”
inProceedings of the 37th International Conference on Software Engi-
neering - V olume 1 , ser. ICSE ’15. Piscataway, NJ, USA: IEEE Press,
2015, pp. 426–436.
[25] L. Sinha, S. Bhandari, P . Faruki, M. S. Gaur, V . Laxmi, and M. Conti,
“Flowmine: Android app analysis via data ﬂow,” in 13th IEEE Annual
Consumer Communications & Networking Conference, CCNC 2016,
Las V egas, NV , USA, January 9-12, 2016 , 2016, pp. 435–441. [Online].
Available: https://doi.org/10.1109/CCNC.2016.7444819
[26] K. Tian, G. Tan, D. D. Y ao, and B. G. Ryder, “Redroid:
Prioritizing data ﬂows and sinks for app security transformation,”
inProceedings of the 2017 Workshop on F orming an Ecosystem
Around Software Transformation, FEAST@CCS 2017, Dallas, TX,
USA, November 3, 2017 , 2017, pp. 35–41. [Online]. Available:
http://doi.acm.org/10.1145/3141235.3141239
[27] S. Rasthofer, S. Arzt, and E. Bodden, “A machine-learning approach for
classifying and categorizing android sources and sinks,” in 21st Annual
Network and Distributed System Security Symposium, NDSS 2014, San
Diego, California, USA, February 23-26, 2014 , 2014.
[28] S. Wu, P . Wang, X. Li, and Y . Zhang, “Effective detection of android
malware based on the usage of data ﬂow apis and machine learning,”
Information & Software Technology , vol. 75, pp. 17–25, 2016.
[29] L. Qiu, Y . Wang, and J. Rubin, “Analyzing the analyzers: Flow-
droid/iccta, amandroid, and droidsafe,” in Proceedings of the 27th ACM
SIGSOFT International Symposium on Software Testing and Analysis,
ISSTA 2018, Amsterdam, The Netherlands, July 16-21, 2018 , 2018, pp.
176–186.
[30] G. Snelting, “Combining slicing and constraint solving for validation of
measurement software,” Static Analysis SE - 23 , vol. 1145, no. Springer,
pp. 332–348, 1996.
[31] G. A. Kildall, “A uniﬁed approach to global program optimization,” in
Conference Record of the ACM Symposium on Principles of Program-
ming Languages, Boston, Massachusetts, USA, October 1973 , 1973, pp.
194–206.
[32] R. Padhye and U. P . Khedker, “Interprocedural data ﬂow analysis in
soot using value contexts,” in Proceedings of the 2nd ACM SIGPLAN
International Workshop on State Of the Art in Java Program analysis,
SOAP 2013, Seattle, WA, USA, June 20, 2013 , 2013, pp. 31–36.
[33] T. W . Reps, S. Horwitz, and S. Sagiv, “Precise interprocedural dataﬂow
analysis via graph reachability,” in Conference Record of POPL’95: 22nd
ACM SIGPLAN-SIGACT Symposium on Principles of Programming
Languages, San Francisco, California, USA, January 23-25, 1995 , 1995,
pp. 49–61.
[34] A. Deutsch, “Interprocedural may-alias analysis for pointers: Beyond
k-limiting,” in Proceedings of the ACM SIGPLAN’94 Conference on
Programming Language Design and Implementation (PLDI), Orlando,
Florida, USA, June 20-24, 1994 , 1994, pp. 230–241.
[35] P . Lam, E. Bodden, O. Lhotak, and L. Hendren, “The Soot framework
for Java program analysis: a retrospective,” Cetus ’11 , 2011. [Online].
Available: https://sable.github.io/soot/resources/lblh11soot.pdf
[36] J. Sp ¨ath, L. N. Q. Do, K. Ali, and E. Bodden, “Boomerang:
Demand-Driven Flow- and Context-Sensitive Pointer Analysis for
Java,” in 30th European Conference on Object-Oriented Programming
(ECOOP 2016) , ser. Leibniz International Proceedings in Informatics
(LIPIcs), S. Krishnamurthi and B. S. Lerner, Eds., vol. 56. Dagstuhl,
Germany: Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik, 2016, pp.
22:1–22:26. [Online]. Available: http://drops.dagstuhl.de/opus/volltexte/
2016/6116
[37] L. M. de Moura and N. Bjørner, “Z3: an efﬁcient SMT solver,” in
Tools and Algorithms for the Construction and Analysis of Systems,
14th International Conference, TACAS 2008, Held as Part of the Joint
European Conferences on Theory and Practice of Software, ETAPS2008, Budapest, Hungary, March 29-April 6, 2008. Proceedings , 2008,
pp. 337–340.
[38] F. Pauck, E. Bodden, and H. Wehrheim, “Do android taint analysis
tools keep their promises?” in Proceedings of the 2018 26th ACM Joint
Meeting on European Software Engineering Conference and Symposium
on the F oundations of Software Engineering , ser. ESEC/FSE 2018. New
Y ork, NY , USA: ACM, 2018, pp. 331–341.
[39] K. Allix, T. F. Bissyand ´e, J. Klein, and Y . L. Traon, “Androzoo:
collecting millions of android apps for the research community,” in
Proceedings of the 13th International Conference on Mining Software
Repositories, MSR 2016, Austin, TX, USA, May 14-22, 2016 , 2016, pp.
468–471.
[40] “Device compatibility,” accessed 2018-08-20. [Online]. Available:
https://developer.android.com/guide/practices/compatibility
[41] S. J. Fink, E. Y ahav, N. Dor, G. Ramalingam, and E. Geay,
“Effective typestate veriﬁcation in the presence of aliasing,” in
Proceedings of the ACM/SIGSOFT International Symposium on
Software Testing and Analysis, ISSTA 2006, Portland, Maine,
USA, July 17-20, 2006 , 2006, pp. 133–144. [Online]. Available:
http://doi.acm.org/10.1145/1146238.1146254
[42] “Android Fragmentation,” accessed 2018-07-19. [Online]. Available:
https://opensignal.com/reports/2015/08/android-fragmentation/
[43] P . Mutchler, Y . Safaei, A. Doup ´e, and J. C. Mitchell, “Target
fragmentation in android apps,” in 2016 IEEE Security and
Privacy Workshops, SP Workshops 2016, San Jose, CA, USA,
May 22-26, 2016 , 2016, pp. 204–213. [Online]. Available: https:
//doi.org/10.1109/SPW .2016.31
[44] “Platform V ersions,” accessed 2018-07-19. [Online]. Available: https:
//developer.android.com/about/dashboards/
[45] M. Eichberg, B. Hermann, M. Mezini, and L. Glanz, “Hidden truths in
dead software paths,” in Software Engineering 2016, Fachtagung des GI-
Fachbereichs Softwaretechnik, 23.-26. Februar 2016, Wien, ¨Osterreich ,
2016, pp. 63–64. [Online]. Available: https://dl.gi.de/20.500.12116/723
[46] B. Livshits, M. Sridharan, Y . Smaragdakis, O. Lhot ´ak, J. N.
Amaral, B. E. Chang, S. Z. Guyer, U. P . Khedker, A. Møller,
and D. V ardoulakis, “In defense of soundiness: a manifesto,”
Commun. ACM , vol. 58, no. 2, pp. 44–46, 2015. [Online]. Available:
http://doi.acm.org/10.1145/2644805
[47] S. Arzt, “Static Data Flow Analysis for Android Applications,” Ph.D.
dissertation, Technische Universit ¨at Darmstadt, Dec 2016. [Online].
Available: http://bodden.de/pubs/phd-arzt.pdf
[48] Y . Wang, H. Zhang, and A. Rountev, “On the unsoundness of static
analysis for android guis,” in Proceedings of the 5th ACM SIGPLAN
International Workshop on State Of the Art in Program Analysis,
SOAP@PLDI 2016, Santa Barbara, CA, USA, June 14, 2016 , 2016,
pp. 18–23.
[49] R. Stevens, J. Ganz, V . Filkov, P . T. Devanbu, and H. Chen, “Asking for
(and about) permissions used by android apps,” in Proceedings of the
10th Working Conference on Mining Software Repositories, MSR ’13,
San Francisco, CA, USA, May 18-19, 2013 , 2013, pp. 31–40.
[50] W . Y ang, X. Xiao, B. Andow, S. Li, T. Xie, and W . Enck, “Ap-
pcontext: Differentiating malicious and benign mobile app behaviors
using context,” in 37th IEEE/ACM International Conference on Software
Engineering, ICSE 2015, Florence, Italy, May 16-24, 2015, V olume 1 ,
2015, pp. 303–313.
[51] M. Lillack, C. Kastner, and E. Bodden, “Tracking Load-time
Conﬁguration Options,” IEEE Transactions on Software Engineering ,
vol. 5589, no. c, pp. 1–1, 2017. [Online]. Available: https:
//ieeexplore.ieee.org/document/8049300/
[52] H. Chen, H. Leung, B. Han, and J. Su, “Automatic privacy leakage
detection for massive android apps via a novel hybrid approach,” in
IEEE International Conference on Communications, ICC 2017, Paris,
France, May 21-25, 2017 , 2017, pp. 1–7.
[53] W . Enck, P . Gilbert, S. Han, V . Tendulkar, B. Chun, L. P . Cox, J. Jung,
P . D. McDaniel, and A. N. Sheth, “Taintdroid: An information-ﬂow
tracking system for realtime privacy monitoring on smartphones,” ACM
Trans. Comput. Syst. , vol. 32, no. 2, pp. 5:1–5:29, 2014.
[54] M. Sagiv, T. Reps, and S. Horwitz, “Precise interprocedural dataﬂow
analysis with applications to constant propagation,” Lecture Notes in
Computer Science , vol. 915, pp. 651–665, 1995.
[55] M. Taghdiri, G. Snelting, and C. Sinz, “Information ﬂow analysis via
path condition reﬁnement,” in F ormal Aspects of Security and Trust -
7th International Workshop, F AST 2010, Pisa, Italy, September 16-17,
2010. Revised Selected Papers ,2010, pp. 65–79.
113
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:08:56 UTC from IEEE Xplore.  Restrictions apply. [56] S. Arzt, S. Rasthofer, R. Hahn, and E. Bodden, “Using targeted symbolic
execution for reducing false-positives in dataﬂow analysis,” in Proceed-
ings of the 4th ACM SIGPLAN International Workshop on State Of the
Art in Program Analysis, SOAP@PLDI 2015, Portland, OR, USA, June
15 - 17, 2015 , 2015, pp. 1–6.
[57] C. Cadar and K. Sen, “Symbolic execution for software testing: three
decades later,” Commun. ACM , vol. 56, no. 2, pp. 82–90, 2013.
[58] S. Anand, M. Naik, M. J. Harrold, and H. Y ang, “Automated concolictesting of smartphone apps,” in 20th ACM SIGSOFT Symposium on
the F oundations of Software Engineering (FSE-20), SIGSOFT/FSE’12,
Cary, NC, USA - November 11 - 16, 2012 , 2012, p. 59.
[59] J. Sch ¨utte, R. Fedler, and D. Titze, “Condroid: Targeted dynamic
analysis of android applications,” in 29th IEEE International Conference
on Advanced Information Networking and Applications, AINA 2015,
Gwangju, South Korea, March 24-27, 2015 , 2015, pp. 571–578.
114
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:08:56 UTC from IEEE Xplore.  Restrictions apply. 