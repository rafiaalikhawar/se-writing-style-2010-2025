Control Flow-Guided SMT Solving for Program Verification‚àó
Jianhui Chen
School of Software, Tsinghua University
Key Laboratory for Information System Security, MoE
Beijing National Research Center for Information Science
and Technology
Beijing, China
chenjian16@mails.tsinghua.edu.cnFei He‚Ä†
School of Software, Tsinghua University
Key Laboratory for Information System Security, MoE
Beijing National Research Center for Information Science
and Technology
Beijing, China
hefei@tsinghua.edu.cn
ABSTRACT
Satisfiability modulotheories (SMT) solvers havebeen widely ap-
plied as the reasoning engine for diverse software analysis and
verification technologies. The efficiency of the SMT solver has sig-
nificanteffectsontheperformanceofthesetechnologies.However,
the current SMT solvers are designed for the general purpose of
constraint solving. Many useful knowledge of programs cannot be
utilizedduringtheSMTsolving.Asaresult,theSMTsolvermay
spendalotofefforttoexploreredundantsearchspace.Inthispaper,
we propose a novel approach for utilizing control-flow knowledge
in SMT solving.With this technique, the searchspace can be con-
siderablyreducedandtheefficiencyofSMTsolvingisobservably
improved. We conducted extensive experiments on credible bench-
marks, the results show orders of magnitude improvements of our
approach.
CCS CONCEPTS
‚Ä¢Theory of computation ‚ÜíLogic and verification ;‚Ä¢Soft-
ware and its engineering ‚ÜíFormal software verification;
KEYWORDS
Program verification, Satisfiability modulo theory, Control-flow
graph
ACM Reference Format:
Jianhui Chen and Fei He. 2018. Control Flow-Guided SMT Solving for
Program Verification. In Proceedings of the 2018 33rd ACM/IEEE Interna-
tional Conference on Automated Software Engineering (ASE ‚Äô18), Septem-
ber 3‚Äì7, 2018, Montpellier, France. ACM, New York, NY, USA, 11pages.
https://doi.org/10.1145/3238147.3238218
‚àóThisworkwaspartiallyfundedbytheNSFofChinaunderGrantNo.61672310and
Grant No. 61527812, the National Science and Technology Major Project under Grant
No. 2016ZX01038101.
‚Ä†Corresponding author
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
¬© 2018 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.32382181 INTRODUCTION
Satisfiability modulo theories (SMT) are applied in diverse soft-
wareengineeringtechnologies,suchassoftwareverification[ 4,22],
static program analysis [ 12,36], symbolic execution [ 26], test-case
generation[ 37]andsoon.ApowerfulSMTsolverisacrucialfactor
to improve the efficiency of these technologies. However, the SMT
solvers are designed for the general purpose of constraint solv-
ing [16]. Domain-specific knowledge cannot be efficiently utilized
innowadaysSMTsolvers.Ontheotherhand,domainknowledge
may be quite useful for pruning the search space, and thus improv-
ing the efficiency of SMT solvers.
Control-flowgraph(CFG)isagraphrepresentationofprograms.
Itissimplebutinformative.Manydomainknowledgeaboutpro-
grams is implied in this representation. For example, let œÄbe a
programexecution,if œÄpassesabasicblock,itpassesallstatements
in this block; reversely, if it does not pass a block, all statements in
that blockare notexecuted by œÄ.This isstraightforward fromthe
CFG.However,aftertheprogramisencodedintotheSMTformula,
theSMT solverisunaware ofthisknowledge.Moreover,consider
anif-statement,anexecutioncanneverpassbothofitsbranches.
Again, the SMT solver is unaware of this. As a result, the SMT
solver may spend a lot of effort to explore redundant space, which
could have been pruned if the control-flow knowledge is known.
Onemayconsidertospecifythecontrol-flowknowledgeasSMT
constraints.However,specifyingtheseknowledgemayintroduce
additional variables and thus increases the problem complexity.
We have a simpler and smarter solution. The basic idea is to use a
decisionordertoguidetheSMTsolving.Thedecisionorderdecides
at each search step which variable should be taken for assignment.
It determines the search direction in the SMT solving. We propose
toinferadecisionorderfromthecontrol-flowgraphoftheprogram,
and then use this order to guide the search process of SMT solving.
We propose two heuristics for arranging the decision order.
Firstly,werecognizetheimportanceofbranchingconditionsthat
dominate the control flows of the program, and assign the corre-
spondingvariableshigherprioritiesinthedecisionorder.Secondly,
we follow the domination relation of the control flow graph to
arrangethe orderof branchingvariables.In thisway,wepropose
alightweighttechniquetoutilizecontrol-flowknowledge inSMT
solving. It can take full advantage of the built-in features of the
SMT solver.
Moreover, we propose an enhanced CNF conversion procedure.
AftertheprogramisencodedintotheSMTformula,the iteterms
keep the control-flow information of the original program. The
351
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Jianhui Chen and Fei He
conventional approach breaks the nested structures of iteterms,
andthuslosethecontrol-flowinformation.Weproposeanew ite
rewritingalgorithm,withwhichthenestedstructureof itetermsis
kept in some form of CNF formulas. With our enhanced approach,
thegeneratedCNFcontainsfewerclausesandfewervariables.The
efficiency is thus improved.
To the best of our knowledge, this is the first attempt at im-
proving SMT solving by using domain knowledge of programs.
There are some works on domain knowledge-guided SAT solv-
ing [6,40,43,44]. In [44], the structure information of transition
systems is utilized to guide the SAT solvers. In [ 40], the variable
dependencyinformationofthemodelisutilizedtoguidetheSAT
solvers. The paper [ 43] considers the iterative SAT solving for
boundedmodelchecking.Theinformationfromthepreviousun-
satisfiabilitycoreisutilizedtorefinethedecisionorderingforthe
current SAT instance. All these techniques are designed for SAT
solvers,andthedomainknowledgecomesfromthemodelchecking.
In this paper, we consider SMT solving for program verification.
The domain knowledge is different, and the application target is
also different.
WerealizedaprototypeofourapproachontopofCBMCandZ3.
We conducted extensive experiments on 2897 credible benchmarks.
All benchmarks are obtained from SV-COMP‚Äô171. Up to 1411 SMT
instancesaregenerated.Experimentalresultsshowthatthecontrol-
flow knowledge can significantly improve the efficiency of SMT
solving. The average speedup is 3.34 times for all instances, and
8.22 times for satisfiable instances.
In summary, our main contributions include:
‚Ä¢Weproposeanovelapproachforutilizingcontrolflowknowl-
edge in SMT solving. This approach is lightweight, and can
take full advantage of the built-in features of SMT solvers.
‚Ä¢WeproposeanenhancedCNFconversionprocedure,with
which the control-flowinformation can be keptin the CNF
formulas.
‚Ä¢WeimplementourapproachonthetopofCBMCandZ3,and
conductextensive experimentsto evaluateits effectiveness
andefficiency.Resultsshowpromisingperformanceofour
approach.
Therestofthispaperisorganizedasfollows.Section 2introduces
somebackgroundknowledge.Section 3usesasimpleexampleto
motivate our approach. Section 4presents our control-flow guided
SMTsolvingapproach.ExperimentsarereportedinSection 5,r e-
lated works are discussed in Section 6. Finally, Section 7concludes
this paper.
2 PRELIMINARIES
2.1 Notations
In first-order logic (FOL), a termcan be a variable, a constant, or
an-ary function applied to nterms. An atomis/latticetop,‚ä•,o ran-ary
predicate applied to nterms. Aliteralis an atom or its negation. A
FOL formula is built from literals using the Boolean connectives
andquantifiers.Aninterpretation(ormodel) Mconsistsofanon-
emptysetofobjectscalledthedomainof M,writtendom(M);amap
from each variable and each constant, respectively, to an object
1https://sv-comp.sosy-lab.org/2017/indom(M); and an interpretation for each function symbol and
each predicate symbol, respectively. Given a formula Œ¶,w es a y M
satisfies Œ¶, written M|=Œ¶,i fŒ¶is true in the model M.
A first-order theory Tis defined by a signature and a set of
axioms, where the signature defines a set of constant, function and
predicatesymbolsallowedin T,andtheaxiomsdefinetheintended
meanings. A T-model is a model that satisfies all axioms of T.A
formula Œ¶isT-satisfiable if there exists a T-modelMsuch that
M|=Œ¶. A formula Œ¶isT-valid ifM|=Ffor allT-modelsM.
2.2 Control Flow Graph
Acontrol flow graph (CFG) is a graphical representation of com-
putation and control flow in the program. Let a basic block be a
straight-linesequenceofinstructionswithoutanyjumpsorjump
targets.Especially,jumptargetsstartablockandjumpsendablock.
A control flow graph (CFG) is a directed graph, where nodes are
basic blocks and edges represent jumps in the control flow. Two
speciallydesignatedblocks, ENTRYandEXIT,maybeusedinaCFG
to represent the entry and exit points of the program.
Letcbe the condition of a branch-statement. The cis called a
branching condition. And two branches of the branch-statement is
calledcbranchand ¬¨cbranch,respectively.Givenabasicblock,its
block condition is a predicate such that the block is executable iff
the block condition is satisfiable.
2.3 Program Verification
Recentadvancesinmodelchecking[ 6],staticanalysis[ 36],abstract
interpretation [ 12] predicate abstraction [ 4,22], etc, promoted pro-
gramverificationtoapracticaltechniqueforcorrectnessassurance
ofprograms.Loopsarethemainhurdleforprogramverification.
There are mainly two approaches for handling loops in a program:
loop invariant [ 39] and loop unwinding [ 34]. The former approach
usesaloopinvariant,whichholdsatthebeginningofeachiteration
oftheloop,torepresentthebehaviorsoftheloop.However,itrelies
on the user to provide the loop invariant. Automatic generation
ofloopinvariantshavebeenextensivelystudied,buttheexisting
techniques are still not practical enough [ 1]. The more popular
approach for handling loops is by unwinding. With this technique,
each loop is unwound to a predefined depth. As a result, the loops
are replaced by nested if-statements. This technique is good at
bug finding. Other techniques, like k-induction [ 17], enhances this
approach by enabling the correctness proving of programs.
Many of state-of-the-art program verification techniques are
basedonthesatisfiabilitymodulotheories(SMT)solvers[ 5].These
solvers are used as the reasoning engine. In this paper, we assume
all programs have been processed by the loop invariant or loopunwinding technique, and are thus free of loops. The loop-freeprograms are converted to their static single assignment (SSA)
forms[13].WiththeSSAform,thecorrectnessofaprogramcan
easily be encoded as a set of SMT formulas [ 18]. These formulas
are called the verification condition of the program with respect to
the property. The validity of the verification condition implies the
correctness of the program.
352
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. Control Flow-Guided SMT Solving for Program Verification ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
SMT formula Œ¶ 
SAT Solver 
UNSAT SAT Theory Solver 
‚Ñ¨Œ¶ is unsat 
let ùëÄ be a satisfying 
model add a T-conflict clause to Œ¶ 
ùëÄ is ùëá-sat ùëÄ is ùëá-unsat 
‚Ñ¨Œ¶ is sat 
Figure 1: DPLL(T)
2.4 Satisfiability Modulo Theories
Satisfiabilitymodulotheories(SMT)extendsSATwiththeabilityto
reasonwithfirst-ordertheories.Weassumealltheoriesdiscussed
in this paper are decidable, and for each theory T, there is a T-
solver that can check the T-satisfiability of conjunctions of literals
inT. In practice, theories are not isolated. For example, software
verification needs theories of uninterpreted function, arithmetic,
array,bitvectors,andsoon.Nelson-Oppenproposedacombination
method [33] to deal with FOL formulas in multiple theories.
DPLL(T) extends DPLL algorithm [ 14] to incorporate reasoning
abouttheories.ItusesanSATsolvertocopewiththeBooleanstruc-
ture and theory solvers for deciding satisfiability in background
theories. The basic idea of DPLL(T) is illustrated in Fig. 1. Given
anSMTformula Œ¶,eachofitsatomsisfirstreplacedwithafresh
Boolean variable, called the Boolean abstraction. Denote the result-
ing formulaas B(Œ¶). TheBoolean abstraction gives usa lazyway
to solve the SMT formulas. DPLL(T) uses an SAT solver to findassignments for
B(Œ¶)and then uses a theory solver to check the
T-satisfiability of the found assignments. The Boolean abstraction
isanover-approximationoftheoriginalformulawithrespecttoits
satisfiability.If B(Œ¶)isunsatisfiable,thensois Œ¶,butthereverse
may not hold.
Thehigh-levelview ofapracticalDPLL(T)algorithm isshown
inAlg.1.Atthislevel,thealgorithmisthesameasthatofaconflict-
drivenclauselearning-basedSATsolver[7].Thedifferencesliein
the implementations of propagate _and_check(),resolve_conflict()
anddecide(). The method propagate _and_check()repeatedly ap-
plies unit propagation and theory propagation to force values toas many as possible literals. It also checks the
T-consistency of
the current model. The method returns 0 if it encounters a con-flict or
T-inconsistency, and 1 otherwise. In case of conflict or
T-inconsistency,themethod resolve_conflict()isinvokedtolearn
conflictclausesandaddthemtotheclausedatabase.Themethod
decide()decides the next unassigned Boolean variable and guess
its value. If there is no unassigned variable, the current model is
complete, and is thus a satisfying model.
Many heuristics are developed for selecting the next unassigned
variableanddecidingitsvalue.Acommonlyusedbranchingheuris-
tic is the VSIDS branching heuristic, which is employed as the
defaultheuristicinmanywell-knownsolvers[ 8,15,32].DPLL(T)
is essentially a depth-first search algorithm. We may guide the
searchingprocessofDPLL(T)byenforcingavariableorderinthe
decide()method.Algorithm 1 DPLL(T)
Input:An SMT formula Œ¶
Output: SAT or UNSAT
1:whiletruedo
2:while!propagate _and_check()do
3: ifdecision_level ==0then return UNSAT;
4: elseresolve_conflict();
5:if!decide()then return SAT;
3 MOTIVATIONS
In this section, we use a simple example to motivate our approach.
Weshowthatsomeimportantcontrol-flowknowledgeisneglected
by the SMT solver, and utilizing this knowledge can make great
gains.
ConsiderasimpleprogramshownintheleftofFig. 2.Itsmain
partisatwo-tiernestedif-statements.Control-flowgraphofthis
program is shown in Fig. 3, where ellipse nodes represent Entry
and Exit, and rectangle nodes represent blocks. We ignore the
detailed forms of the branching conditions in the program, and
simplyrepresentthemas c0andc1,respectively.Thepropertyisto
verify that x=yholds at the end of this program.
Verification Condition. The original program is firstly converted
intothesinglestaticassignment(SSA)form,whereforeachassignment-
statement, a new variable is introduced for the right-hand-side
variable. After this conversion, there is at most one assignment
for each variable. The SSA form of the program example is shown
in the right of Fig. 2. Note that ite(bool,¬∑,¬∑)is a ternary function
thatreturnsitssecondorthirdargumentdependingonifitsfirst
argument is true or not. Also note thatthe nested structure of the
originalif-statementiskeptintheformulaasanested itestructure.
The verification condition (VC )i s
VC/definesEnc‚àßCor (1)
whereEncis the encoding of the program, and Corthe correctness
condition. For the motivating example, we have
Enc‚â°(x4=ite(c0,1,ite(c1,2,3)))‚àß(y4=ite(c0,1,ite(c1,2,3)))
and
Cor‚â°(x4/nequaly4)
Theprogramis correctwithrespecttothepropertyifandonlyif
VCisunsatisfiable.
ConjunctiveNormalForm. WerelyonanSMTsolvertocheckthe
satisfiabilityof VC.Theformulaneedbeconvertedto conjunctive
normal form (CNF). A conjunctive normal form is a conjunction
of clauses, and each clause is a disjunction of literals. For ease ofunderstanding, we usually write a clause as a logical entailment,
sinceitcanbeconvertedtoaclausedirectly,i.e., A1‚àß¬∑¬∑¬∑‚àßAk‚ÜíB
can be convertedto ¬¨A1‚à®¬∑¬∑¬∑‚à®¬¨Ak‚à®B, whereA1,...,AkandB
are literals. In the remainder of the paper, we also write a CNF as a
set of clauses, and a clause as a set of literals.
MostSMTsolversadopttheTseitin‚Äôstransformationmethod[ 42]
to perform the CNF conversion, which adds a new variable for
eachsubformulaoftheoriginalformula.Considerthemotivating
353
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Jianhui Chen and Fei He
if(c0) 
  x=1;y=1; else   if(c1) 
    x=2;y=2;   else     x=3;y=3; assert(x==y); if(c0)   x1=1;y1=1; else 
  if(c1) 
    x2=2;y2=2;   else     x3=3;y3=3; x4=ite(c0,x1,ite(c1,x2,x3)); y4=ite(c0,y1,ite(c1,y2,y3)); 
assert(x4==y4); 
SSA Program 
Figure 2: Example
example,theCNFof Enc,written CNF(Enc),istheconjunctionof
the following clauses:
c0‚Üíx4=1
¬¨c0‚Üíx4=tx
c1‚Üítx=2
¬¨c1‚Üítx=3c0‚Üíy4=1
¬¨c0‚Üíy4=ty
c1‚Üíty=2
¬¨c1‚Üíty=3(2)
Notethattheauxiliaryvariables txandtyareintroducedforthein-
neritefunctionof VCx4andVCy4,respectively.Moreover, CNF(VC)‚â°
CNF(Enc)‚àßCNF(Cor),whereCNF(Cor)‚â°x4/nequaly4.
TheTseitin‚Äôsmethodguaranteesthattheconvertedformulais
equi-satisfiabletotheoriginalformula.Inotherwords,theverifica-
tion condition VCis satisfiable iff CNF(VC)is satisfiable.
DPLL(T). DPLL(T)isthestandardtechniqueunderlyingmodern
SMT solvers. It starts by replacing each atom of the formula with a
fresh Boolean variable, called Boolean abstraction. In the following,
we usevlto represent the Boolean variable for the atom l. The
Boolean abstraction of CNF(Enc), written B(CNF(Enc)),i s
vc0‚Üívx4=1
¬¨vc0‚Üívx4=tx
vc1‚Üívtx=2
¬¨vc1‚Üívtx=3vc0‚Üívy4=1
¬¨vc0‚Üívy4=ty
vc1‚Üívty=2
¬¨vc1‚Üívty=3(3)
Moreover, B(CNF(VC)) ‚â° B(CNF (Enc)) ‚àß B(CNF (Cor)),where
B(CNF(Cor) )‚â°¬¨vx4=y4.
3.1 Control-Flow Knowledge is Neglected
The first knowledge is about the execution of statements in the
sameblock.ConsideringtheBooleanformula(3),allvariablesare
independenteachother.Thevariables vx4=1andvy4=1canbeas-
signed with different values by DPLL(T). However, if we look at
the original program in Fig. 2, clearly the statements ‚Äúx=1‚Äù and
‚Äúy=1‚Äùareinthesamebasicblock.Foranyexecution,eitherthese
twostatementsarebothexecuted,orneither.Correspondingtothe
Boolean formula (3), the Boolean variables vx4=1andvy4=1must
be assigned with the same Boolean value. Similarly, the Boolean
variables vx4=2andvy4=2, the Boolean variables vx4=3andvy4=3
must be assigned with the same Boolean values, too. This is an
importantknowledgeaboutthecontrolflowoftheprogram,which
is, however, neglected by the SMT solver.x=1; 
y=1;   if(c0) 
x=2; y=2;   if(c1) 
x=3; y=3;   true false 
true false 
assert(x==y); 
Figure 3: Control flow graph of the example
Thesecondknowledgeisabouttheexecutionofmultipleblocks.
The example program has three blocks (at line 2, 5 and 7), with
conditions of c0,¬¨c0‚àßc1, and¬¨c0‚àß¬¨c1, respectively. Apparently,
their conditions are mutually exclusive, hence only one of these
blocks can be executedin one program execution. This important
knowledge is also neglected by the SMT solver. For example, as-
sumethe c0istrue,onlystatements‚Äúx=1‚Äù,‚Äúy=1‚Äù,and‚Äúassert(x==y)‚Äù
areexecuted,theprogram‚Äôscorrectnessisrelevanttothesethree
statements only. For the Boolean formula (3), the first two clauses
encodethe c0branch,andthelastsixclausesencodethe ¬¨c0branch.
WeexpectthelastsixclausesneednotbeconsideredinDPLL(T),
assoonas vc0isassigned true.Theactualsituationisthatthethird
and fourth clauses can be dropped from DPLL(T) (since they are
satisfied),whereasthelastfourclausescannot.TheSMTsolverstill
makes some efforts to consider different assignments of Boolean
variables in these clauses (i.e., to explore the corresponding blocks)
in the subsequent search process.
3.2 Applying Control-Flow Knowledge Makes
Great Gains
Consideringabasicblockwith nstatements,let Œ¶betheformula
that encodes this block, and B(Œ¶)the Boolean abstraction of Œ¶,
there are at least nBoolean variables in B(Œ¶). DPLL(T) treats all
these variables as independent individuals, and needs explore their
2nassignments.Incontrast,withthecontrol-flowknowledgeabout
the execution of statements in the same block, only 2 assignments
of thesenvariables (both trueor bothfalse) need be explored.
Moreover, considering a program with mmutually exclusive
blocks. Without the control-flow knowledge, the SMT solver needs
to explore all combinations of these mblocks. The search space, in
this case, is the Cartesian product of these mblocks. In contrast,
withthecontrol-flowknowledgeabouttheexecutionofmultiple
blocks, eachtime we explore oneblock only. Thesearch space is
the addition of these mblocks. The search space is thus greatly
reduced.
4 CONTROL FLOW-GUIDED SMT SOLVING
To utilize the control-flow knowledge, one may consider adding
constraints to the original formula. However, specifying these con-
straints may introduce additional variables and thus increases the
354
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. Control Flow-Guided SMT Solving for Program Verification ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
Verifier Solver SMT Formula + Order 
A satisfied model / Unsat 
Figure 4: Overview of our approach
problem complexity. We have a simpler and smarter solution. The
basicideaistoinferavariableorderfromthecontrol-flowofthe
program, and then use this order to guide the search process of
DPLL(T)(moreclearly,byenforcingthisorderin decide()ofAlg.1).
Our approach can take full advantage of the built-in features of
DPLL(T).Itprovidesalightweighttechniqueforutilizingcontrol-
flow information. Fig. 4shows an overview of our approach. At
the verifier side, except the SMT formula that encodes the verifi-
cation problem, a decision order on the variables is also generated
(Section4.1). This order records the control-flow information of
the program. An SMT solving involves two steps: CNF conversion
and DPLL(T) . We propose techniques to enhance both steps: a
technique for guiding the DPLL(T) with an order (Section 4.2), and
an enhanced CNF conversion technique (Section 4.3).
4.1 Decision Order
LetŒ¶beaformula, B(Œ¶)theBooleanabstractionof Œ¶,andVtheset
of Boolean variables in B(Œ¶). We distinguish the Boolean variables
for branching conditions, and call them branching variables. Let
Vb‚äÜVbe the set of branching variables in B(Œ¶). We intend to
defineapartialorder /precedesorcurlyoverV.Wecallthisorderthe decisionorder.
Letv1,v2be two variables in V,i fv1/precedesorcurlyv2,w es a yv1isprior tov2
in/precedesorcurly.
IntheCFGofaprogram,anode d1issaidto dominate another
noded2,ifeverypathfrom Entrytod2mustgothrough d1.Con-
sideringtheCFGinFig. 3,thec0nodedominatesallnodesinthe
graph except of Entryand itself; the c1node dominates two of its
successor nodes.
Remarkthatthebranchingconditionsdominatethecontrolflow
of the program. We have the following heuristic.
Heuristic 1. Branching variables are prior toall other variables
inV, i.e.,‚àÄv1‚ààVb,v2‚ààV\Vb.v1/precedesorcurlyv2.
RecalltheproblemdiscussedinSection 3.1:thestatements‚Äúx=1‚Äù
and ‚Äúy=1‚Äù are in the same block, while the Boolean variables vx4=1
andvy4=1canbeassignedtodifferentvalues.WithHeuristic 1,this
isnotgoingtohappen.If vc0=true,byBooleanpropagation(on
thefirsttwoclausesoftheformula(3)),both vx4=1andvy4=1are
forced to be true;i fvc0=false, the first two clauses are trivially
satisfied, and the Boolean variables vx4=1andvy4=1need not be
considered in the subsequent process of DPLL(T).
To further define the order among branching variables, we have
the following heuristic:
Heuristic 2. Given two branching variables v1,v2‚ààVb,v1is
prior tov2,i fv1dominates v2.
The underlying principle of Heuristic 2is straightforward. Con-
sideringtheCFGinFig. 3,ifc0istrue,thewhole falsebranchof c0,c0 
c1 true false 
true false 
Figure 5: Branching graph
nomatter c1holdingornot,canbeexcludedfromtheconsideration.
In contrast, deciding a value of c1cannot drop any branch of c0.
This paper consider loop-free programs only. Thus there can
neverbetwonodes d1andd2intheCFG,suchthatboth d1/precedesorcurlyd2
andd2/precedesorcurlyd1.Inotherwords,theinducedorderbyHeuristic 2isa
partial order.
4.1.1 Inferring the Order. The control-flow graph has all the infor-
mation that we need. Inferring the decision order from the CFG of
a given program is quite easy.
Given a CFG, we construct a so-called branching graph by elimi-
natingallstatementsinformationbutkeepingthebranchingcon-
ditions in the graph. Let dbe a node, except of EntryandExit,
oftheCFG,weuse label(d)todenotethestatementslabeledon d,
parent(d)theparentnodesof d,andchild(d)thechildnodesof d.
If the last statement of label(d)is a branch-statement, we delete
all information in label(d)but keep the branching condition. If the
last statement in label(d)is not a branch-statement, indicating that
dhasonlyonechildnode,weconnectallitsparentnodestothis
single child node, and then delete d.
The resulting branching graph is a directed graph where nodes
are branching conditions, and edges are control flows. All control
flows are kept in the branching graph. The branching graph of the
motivatingexampleisshowninFig. 5.Comparingthebranching
graph(inFig. 5)totheCFG(inFig. 3),fournodesaredeleted,the
labels of two nodes are changed. Note that the Boolean values
associated with edges are all kept.
Apparently, the branching graph induce a partial order that
agreeswithHeuristic 2.Weusethisgraphtoguidethesearchof
DPLL(T).
4.1.2 Storing the Order. Wedesignamechanismtoimplicitlystore
the branching graph. The edges of the graph are recorded in the
identifiers of variables, which won‚Äôt affect the semantics of the
formula.Asaresult,whenanSMTsolverisinvoked,theonlyinputistheSMTformulafile(inSMT-Lib-v.2.0format).Noadditionalfile
need be provided.
All condition variables are indexed by the order of their appear-
ances inthe program. Let vbe acondition variable. Theidentifier
ofvis a series of numbers, separated by ‚Äú_‚Äù, with the first number
being the index of v, and others being indexes of v‚Äôs parents in the
branching graph. For example, the condition variable vc0‚Äôs iden-
tifier is ‚Äú0‚Äù, indicating that c0is indexed by 0, and has no parent;
the condition variable vc1‚Äôs identifier is ‚Äú1_0‚Äù, indicating that c1is
indexed by 1, and its single parent is indexed by 0 (i.e. c0).
355
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Jianhui Chen and Fei He
Algorithm 2 decide()
Input:The current node curin the branching graph
Output: An unassigned variable vand a Boolean value value
1:ifcur==Exitthen
2:(v,value)=decide_nonbranching _variables ();
3:whilevar(cur)is an assigned variable do
4:lettbe the assigned value to cur;
5:cur=next(cur,t);
6:(v,value)=(var(cur),rand(0,1));
7:return(v,value);
When an SMT solver is invoked, it first parses the SMT formula,
and restore the branching graph from the variables‚Äô identifiers.
Then it uses this branching graph to guide its DPLL(T) procedure.
4.2 Control Flow-Guided DPLL(T)
ToguidetheSMTsolving,weenforceadecisionorderinthe decide()
operator of DPLL(T).
Ourimplementationof decide()isshowninAlg. 2.Assumethere
isabranchinggraph,and curisitscurrentnodethatrepresentsthe
lastassignedbranchingvariable.Let dbeanode,and taBoolean
value, we provide two methods for manipulating the branching
graph:var(d)returns the branching variable that drepresents, and
next(d,t)returns the next node following the t-edge ofd.I fcur
is the Exitnode, indicating that all of the branching variables
have beenassigned to avalue, the algorithmrelies on themethod
decide_nonbranching _variables ()toselectthenextvariableandde-
cideitsvalue, whichimplementsthedefaultbranchingheuristics
inconventional SMTsolver [ 3,15].Otherwise, ifthevariable that
currepresents has been assigned a value, the algorithm follows
its valueand move tothe nextnode. This movingprocess repeats
untilwegetanunassignedbranchingvariable.Thenwereturnthis
variable and a randomly decided value.
Moreover,the resolve_conflict()methodinAlg. 1needsbeslightly
modified. In case of backtracking, if the target variable is a branch-
ingvariable,weneedtocorrespondinglymodify curtothenode
that represents the backtracked variable and flip its assigned value.
4.3 Enhanced CNF Conversion
Recalltheproblemabouttheexecutionofmutuallyexclusiveblocks
(seeSection 3.1).AftertheCNFconversion,theconditionsofblocks
are divided into parts. Even two blocks are mutually exclusive, the
SMT solver cannot drop the opposite one.
To solve this problem, we need to enhance the CNF conversion
procedure.Forthemotivatingexample,the CNF(Enc)isexpected
to be the conjunction of the following clauses:
c0‚Üíx4=1
¬¨c0‚àßc1‚Üíx4=2
¬¨c0‚àß¬¨c1‚Üíx4=3c0‚Üíy4=1
¬¨c0‚àßc1‚Üíy4=2
¬¨c0‚àß¬¨c1‚Üíy4=3(4)
Comparedto(2), whichisobtainedby theconventionalapproach,
the block conditions are specified in (4) as the premises of clauses.
Asaresult,iftheconditionpredicateofoneblockis true,bymutual
exclusionofblockconditions,theclausescorrespondingtoother
blocks are trivially satisfied. In the above CNF formula (4), theAlgorithm 3 rewrite_ite()
Input:A SMT formula Œ¶
Output: A rewritten formula Œ®withoutitefunctions
1:Œ®=Œ¶;
2:letitesbe the set of ite-terms in Œ¶;
3:for each ite‚ààitesdo
4:let–¥,l,rbe three real parameters of ite;
5:replaceiteinŒ®with(–¥‚Üírewrite_ite(l) )‚àß( ¬¨–¥‚Üí
rewrite_ite(r));
6:return Œ®;
first twoclauses represent the c0branch, andthe last fourclauses
represent the ¬¨c0branch. Assume vc0istrue, thus¬¨vc0‚àßc1and
¬¨vc0‚àß¬¨c1arefalse,thelastfourclausesarehencetriviallysatisfied.
The atoms in these four clauses, for instance, x4=2,y4=2 and so
on, need not be considered againin DPLL(T). In this way,we avoid
DPLL(T) to explore the ¬¨c0branch.
The key to getting the above CNF is the iterewriting procedure,
which rewrites iteterms into those with only Boolean connectives.
Remark thatall branching conditions ofthe verification condition
formula are stored in the iteterms. The conventional rewriting al-
gorithmbreaksthenestedstructuresof iteterms,andthussplitsthe
block conditions into parts. We want a new iterewriting algorithm
that keeps the block condition as a whole.
Our new iterewriting algorithm is shown in Alg. 3. The algo-
rithm finds all iteterms in Œ¶. Eachiteterm is a ternary function
with three parameters. We store these three parameters in –¥,land
r, respectively. The semantics of the itefunction is that if –¥is
true, it returns l, and otherwise returns r, which is equivalent to
(–¥‚Üíl)‚àß(¬¨–¥‚Üír). Note that landrmay also contain iteterms.
Thealgorithmneedbeappliedto landrrecursively.Finally, Œ®con-
tains noiteterm. Ouralgorithm cancollaborate with theTseitin‚Äôs
algorithm directly sincethe rewritten iteformulas are already in
the form of a conjunction of clauses (Section 3).
Comparing our iterewriting algorithm to the conventional one,
the conventional rewritingalgorithms introducean auxiliaryvari-
able for each ite-term. The most benefit of the conventional ap-
proachisthatallgeneratedclausescontainsonlytwoliteralsfor
generating binaryclauses [41]asmore aspossible.Binaryclauses
are good for Boolean propagations. However, the main problem
here is not Boolean propagation but the theory propagation. With
ourCNFformula,therearesomeresultsthatcanbeforcedbyapply-ingBooleanpropagationonly.Ho wever,With theirCNFformula,in
many cases, must the theory solver be involved can we deduce the
sameresult.Moreover,withourenhancedapproach,thenumber
ofclausesisfewer.Besides,ouralgorithmneedsnottointroduce
auxiliary variables for each iteterm. The total number of variables
is also reduced.
5 IMPLEMENTATION AND EXPERIMENTAL
EVALUATION
In this section, we discuss the implementation and evaluation of
our control flow-guided SMT solving tactic. During the evaluation,
we mainly consider the following research questions:
356
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. Control Flow-Guided SMT Solving for Program Verification ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
110100
1 10 100Control flow-guided / s
Baseline / s(600)(600)
Figure 6: SMT solving time on all benchmarks.
RQ1.How can we evaluate the performance of our tactic credi-
bly?
RQ2.How does the performance vary between our tactic and
the original method on credible benchmarks?
RQ3.Does ourtactic affect the performanceof the SMT solver
in a way as we expected?
5.1 Implementation
We implement our control flow-guided SMT solving tactic (pre-
sented in section 4) in CBMC [ 11,27] and Z3 [ 15]. CBMC is a
well-knownboundedmodelcheckingtoolforC/C++programsand
Z3 is an efficient SMT solver. Both CBMC and Z3 are open-source
projects. In our implementation, CBMC is responsible for gener-
ating SMT formulae that encode the verification conditions of the
programs.Ourdecisionorderinferringalgorithmisimplemented
in CBMC, since the control-flow information can be directly ob-
tainedafterCBMCparsestheprograms.Ourcontrolflow-guided
DPLL(T)algorithmandtheenhancedCNFconversionalgorithm
areimplemented inZ3.The SMTfilestransferred betweenCBMC
and Z3 are in the SMT-LIB-v.2.0 format.
5.2 Experiment Setup
Allexperimentsareconducted ontheReachSafetybenchmarksin
SV-COMP‚Äô17. This benchmark set contains up to 2897 C programs.
Alltheseprogramshavealreadybeenpreprocessedforverification.
WeuseCBMCtogenerateSMTformulasfromthebenchmark
programs.Let kbetheunrollboundofCBMC.Withdifferentvalues
ofk,CBMCgeneratesdifferentSMTformulas.WeasktheCBMC
to generate as many as possible SMT formulas within 5 minutes. If
theunrollboundreaches2000,thegenerationprocessalsostops.
Consider a falsified program, let k‚àóbe the minimal value of ksuch
thatacounterexamplecanberevealedfromtheprogram.Then,for
allgeneratedSMTformulasforthisprogram,theyareunsatisfiable
fork<k‚àó, and satisfiable for k‚â•k‚àó. In order to balance the
numberofsatisfiableandunsatisfiableinstances,wedropsomeSMT
instanceswitharathersmall k.Finally,excludingtheexceptional
cases (timeout, internal error, etc), there are totally 1411 programs
with which CBMC successfully generates SMT instances. All of110100
1 10 100Control flow-guided / s
Baseline / s(600)(600)
Figure 7: SMT solving time on satisfiable benchmarks.
0100002000030000
1 101 201 301 401 501 601 701 801 901Accumulated times / s
#Accumulated solved benchmarks
Baseline Control flow-guided
Figure8:AccumulatedSMTsolvingtimeonallbenchmarks.
these SMT files are plain text files in SMT-LIB-v.2.0 format. The
largest SMT files occupy hundreds of MB.
Wecomparetheperformanceofourcontrolflow-guidedSMT
solving tactic to that of the default heuristic in Z3. The original Z3
with the default heuristic is considered as the baseline. The plus
of Z3 and our tactic is called Z3+. Timeout for each instance is set
to 10 minutes. Notethat some preamble tactics (for example, the
simplifying tactic, thevariable eliminating tactic, etc) arerealized
inZ3,withwhichsomeoftheseSMTinstancescanbeimmediatelysolved,withoutcallingtheDPLL(T)procedure.TherearealsosomeinstancesthataretoohardtobesolvedbyeitherZ3+orthebaseline
in the time limit. We drop the above two kinds of exceptional
benchmarks.Finally,wegot948SMTinstances,where314instances
are satisfiable and 634 ones are unsatisfiable. We believe these
benchmarksaresufficienttoevaluatetheperformanceofourtactic
credibly.
5.3 Experimental Results
Figure6showtheSMTsolvingtimeofthebaselineandourcontrol
flow-guided tactic on all benchmarks. The figure demonstratesthat our tactic is superior to the baseline on the majority of the
357
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Jianhui Chen and Fei He
05000100001500020000
1 51 101 151 201 251 301Accumulated times / s
#Accumulated solved benchmarks
Baseline Control flow-guided
Figure 9: Accumulated SMT solving time on satisfiable
benchmarks.
benchmarks. Especially, our tactic can speed up the SMT solver
by orders of magnitude on about a quarter of the benchmarks,
and there are a very little of benchmarks on which our tactic is
notablyinferiortothebaseline.TheaccumulatedSMTsolvingtime
forsolvedbenchmarksisshowninFigure 8.Ingeneral,ourtactic
uses only 30 .0 percents of time of the baseline to resolve the same
number of the benchmarks.
WealsopresenttheSMTsolvingtimeofthesatisfiablebench-
marks in Figure 7. On satisfiable benchmarks, our tactic is superior
to the baseline for most of the benchmarks. There are only a hand-
ful of benchmarks that cost our tactic more time. Besides, nearlyhalf of the benchmarks are sped up by orders of magnitude. Theaccumulated SMT solving time for all satisfiable benchmarks is
shown in Figure 9. Our tactic costs only 12
.2 percents of time of
the baseline to resolve the same benchmark group.
TheaccumulatedSMTsolvingtimeforsolvedunsatisfiablebench-
marks is shown in Figure 10. The curves for both the baseline and
our tactic are substantially identical. Our tactic saved about 25 .2
percents of the SMT solving time for this group of benchmarks.
Summary of the experimental results for SMT solving time is
presented in Table 1. TheCPU time is the total running time of
each tool on the whole benchmark set. Our tactic costs half the
CPUtime tofinishallthebenchmarksandonlyspendsaquarter
ofCPUtime tofinishthesatisfiablebenchmarkscomparedtothe
baseline.The scoretime istheaccumulatedtimeforsolvingacertain
quantityofbenchmarks,wherethequantityisequaltothemaximal
numberofbenchmarkthatthebaselinecansolve.Allofthe score
timesare indicated by the straight dash line in the curve diagrams
like Figure 8. The ratio of the score time of the baseline and our
tactic indicates the speed-up times of our tactic for solving thesame group of benchmarks. To summarize, our tactic speeds upthe solver by 3
.34 times for all benchmarks and 8 .22 times for
satisfiablebenchmarks.Also,thenumberoftimeoutcaseswithour
tactic is much fewer than that with the baseline. In conclusion, our
controlflow-guidedSMTsolvingtacticcansignificantlyimprove
the performance of the SMT solver.05000100001500020000
1 101 201 301 401 501 601Accumulated times / s
#Accumulated solved benchmarks
Baseline Control flow-guided
Figure 10: Accumulated SMT solving time on unsatisfiable
benchmarks.
Table 1: Summary of experimental result
SubCPU Time / s Score Time / s #Timeout
z3 z3+ Lift z3 z3+ Lift z3 z3+
sat 34573 8135 4.2516573 2016 8.22304
unsat 25994 19619 1.3212794 9567 1.33224
all 60568 27754 2.1829368 8803 3.34528
5.4 Result Analysis
The experimental results illustrate remarkable improvements of
our tactic over the baseline. Also note that the improvement of
our tactic on unsatisfiable benchmarks is not as significant as that
on satisfiable benchmarks. In other words, the utility of our tac-
tic is limited for the unsatisfiable instances. Recall that DPLL(T)is basically an exhaustive search procedure. For an unsatisfiable
formula,no matterour tacticorthe baselinetheyhave toexplore
thewholesearchspacetoproveitsunsatisfiability.Theefficiency
of the control flow-guided approach is thus greatly limited. In fact,
the unsatisfiable cases are hard to be optimized for most of the
existing heuristic methods.
Furthermore, during the DPLL(T) search procedure, the algo-
rithmstopsaslongasasatisfiablevariableassignmentsisfound.If the current variable assignments conflict, a conflict clause is
learnedandthesearchprocedurebacktracks.Toacertainextent,
the number of conflict clauses indicates the try times in the search
procedure of DPLL(T) . Figure 11shows the number of conflict
clauseslearnedduringtheDPLL(T).Aswecansee,onthemajority
of the benchmarks, the number of the conflict clauses learned with
our tactic is fewer than that with the baseline, especially for thesatisfiablebenchmarks.Theseresultsindicatethatourtacticcan
guide DPLL(T) to find a satisfiable solution with fewer try times in
the search procedure.
5.5 Threats to Validity
Themain internalthreatstothevalidityofourapproacharethat
whether the performance improvements are mainly due to our
controlflow-guidedtactic,andthatwhethertheimplementation
358
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. Control Flow-Guided SMT Solving for Program Verification ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
1101001000100001000001000000
1 10 100 1000 10000 100000 1000000Control flow-guided
Baselinesat
unsat
Figure 11: #Conflict clauses learned during DPLL(T) .
of our tactic is credible. Firstly, we only implemented two algo-
rithms in Z3, i.e., the branching heuristic and the enhanced CNFconversion algorithm. They are simple and barely coupled with
other modules. Meanwhile, we have implemented our algorithm as
clearly as we can. Secondly, the adding of the control-flow infor-mation won‚Äôt affect the performance of the original solver, since
weimplicitlyrecordthedecisionorderintheSMTfilebynaming
the SMT variables in a special fashion, which doesn‚Äôt have any
effect on the semantics of the SMT formula. Last but not the least,
we conduct experiments on a large number of benchmarks from
SV-COMP‚Äô17. The experimentalresults show theremarkableper-
formanceofourtechnique.Additionally,theanalysisofthenumberofconflictclausesfurtherdemonstratesthatourtacticdoesacceler-
ate the search procedure, which conforms to our expectations. We
are thus confident in the effectiveness of our tactic.
Anotherthreattothevalidityofourapproachisthatwhether
our approach can be generalized to other solvers other than Z3.
Actually, our tactic is based on the DPLL(T) framework, it has
nothingtodowiththespecificfeaturesoftheZ3solveritself.Thus,
ourtacticcanbeimplementedinany DPLL(T)-basedSMTsolver
for program analysis.
Onemorethreatisthatwhetherourapproachcanbegeneralized
to other program analysis techniques, except BMC. The answeris also yes. Actually, we use CBMC in our experiments only to
generateSMTinstances,andnothingmore.Ourtacticcanbeeas-
ily applied to other program analysis techniques only if they are
SMT-based, i.e., they encode the verification conditions as the SMT
formulas and then rely on an SMT solver to solve these formulas.
6 RELATED WORK
Thereisalargebodyofworkonimprovingtheperformanceofthe
DPLL-basedconstraintsolvers,likeSATandSMTsolvers.Below,
we compare our approach with the most closely related works.
Sinceourapproachisbasedonthebranchingheuristic(alsonamed
thedecision ordering ) of the DPLL backtrack search procedure, we
discuss this aspect first.6.1 Branching Heuristics
OneofthemostfamousbranchingheuristicsisVSIDS[ 30,32].It
increases the ranking values of each literal in a newly inferred con-
flict clause, and also decays these values periodically. The ordering
is based on these ranking values. There are also other branching
heuristics utilize the information from the backtrack search proce-
dure,likeMOMheuristic[ 20,38],Jeroslow-Wangheuristics[ 25],
literal count heuristics [ 31], etc. However, all of these branching
heuristicsaredesignedforthegeneralsatisfiabilityproblems,which
can only utilize the information from the DPLL procedure, and
almostdonotcareaboutthedomain-specificknowledgefromorig-
inalproblemsmodeledbythesatisfiabilityproblems.Ourseman-
ticbranchingheuristiciscombinedwithoneofthemostefficient
heuristics(VSIDS-based),butfocusonthesatisfiabilityproblemsde-rivedfromtheprogramanalysisproblem.Withthedomain-specific
knowledge of program analysis, our heuristic can lead to more
efficient constraint solving.
Thereisalsosomeworkonrefiningthedecisionorderingbythe
domain-specific knowledge of circuits or models. The most closely
relatedworkis[ 44],whereYinetal.refinethedecisionordering
forthesatisfiabilityproblemfromtransitionsystembygivingthe
higher priority to the transition variables over other variables. Be-
sides, all of the transition variables are ordered by the transition
relations in the models. As we discussed in section 1, the program
is more complex than the general transition systems. Furthermore,
thisheuristiccanhardlyworksincealloftheprogramvariablesare
transition variables and the DPLL decision procedure is performed
on the predicates over the program variables instead of on the
program variables directly. Moreover, there are some other related
workrefiningthedecisionorderingbytheknowledgeofthetransi-
tionsystems.In[ 43],Wangetal.identifytheimportantvariablesin
theunsat-core form the previous unsatisfiable BMC instances and
giveprioritytotheseimportantvariablesindecisionorderingon
thecurrentinstance.ShtrichmanandOfer[ 40]suggestsastaticpre-
determiningorderfollowingaforwardorbackwardbreadth-first
searchonthevariabledependencygraphofthetransitionsystem.
In[23],Guptaetal.exploreimplicationslearnedfromthecircuit
structurerepresentedbyBDDstohelptheSATsolving.Sincethere
is less structure information in a CNF formula, Ostrowski et al.[
35] suggests recovering and exploiting structural knowledge by
a set of equations form initial SAT instance to eliminate clausesand variables. All of the work are based on the domain-specific
knowledge of circuits or models, instead of the programs.
6.2 Utilizing Control-Flow Information
Our tactic is based on utilizing the control-flow information of the
program. We also compare our approach with the related work on
utilizingthecontrol-flowinformationforprogramanalysis.In[ 29],
Leinoetal.splitthemonolithicVCofaprogramanalysisprocedure
intotheconjunctionofseveralsmallerVCsaccordingtothecontrol-
flowinformation.ThepartitionresultsinseveralsmallerSMTquery
whichcouldbesolvedmoreefficientlythantheoriginalone.Cimatti
et al. [10] partitions the abstraction problem into the combination
of several smaller abstraction problems by exploiting the structure
of the program. These approaches improve the performance by the
heuristicofpartitionthemonolithicproblemintoseveralsmaller
359
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Jianhui Chen and Fei He
problems utilizing the control-flow information. Our tactic also
utilizedthisheuristicsincegivingprioritytotheconditionvariable
issimilartosplittingthewholeprogramintoseveralprogrampaths
and then solving the path formula one by one.
Symbolicexecutiongeneratesaverificationconditionforeach
path of the program. For different paths (of the control flow of the
program), it generates different SMT formulas. In this respect, one
may saythat thesymbolic executionalso utilizesthe controlflow
informationofprograms.Ho wever,symb olicexecutionutilizesthis
informationatthelevelofVCgeneration,whileoursdoesatthe
level of the SMT solver. With our approach, only one SMT formula
thatencodesverificationconditionsofallpathsoftheprogramis
generated.Ourtacticcanusethemanybuilt-infeaturesoftheSMT
solver, including the conflict clause learning, value propagation
andsoon.Asaresult,theintermediateresultsamongverifyingthe
many paths of the program can be easily and automatically shared.
Belt et al. [ 2] and Feist et al. [ 19] proposed to utilize the control-
flowinformationandthedomain-specificknowledgeofsymbolic
executiontoreducethetimesoftheSMTquery,respectively.For
the same reason, these work are also different from ours.
6.3 Theory-Aware Approach
The optimization of our tactic is based on pruning the conflict
assignmentsearly.Someoftherelatedworkbasedonthetheory-
aware approach also optimize the constraint solving procedure in
this way. The theory-aware approaches discover the constraintsfrom the underlying theory by a lightweight method and utilize
theseconstraintstohelptoprunetheconflictassignmentsinDPLL
procedure. Berzish et al. [ 3] proposed a theory-aware branching
heuristic which prioritizes simpler branches over more complexones in string solvers. They also proposed a theory-aware case-split to circumvent mutually exclusive assignments by the struc-ture of string theory literals. Goldwasser et al. [
21]p r o p o s e da
theory-aware branching heuristic for linear reals arithmetic based
onageometricanalysisoverthelinearconstraints.Theheuristic
suggests the values, which is consistent with the current partialassignment, for the unassigned predicates of linear constraints.
Bruttomesso et al. [ 9] utilize the structural information like equali-
tiesand arithmeticfunctionsto helpto reasonata higherlevelof
abstraction within the theory of bit-vectors. All of these theory-
awareapproachesfocusonthespecifictheory,suchasstringtheory,
linear reals arithmetic theory, and bit-vector theory. However, our
tactic is a high-level approach based on refining branching heuris-
tic of DPLL procedure, which is independent of theories. In [ 28],
Kuehlmannetal.usecircuitspecificknowledgetoguidethesearchofSATsolvingandhelpthesolverreasoningonspecificlogic.This
work is only suitable for circuit problems. Besides the DPLL-based
solver,theotherconstraintsolvercanalsoutilize thetheory-aware
approachtoimprovetheperformancesignificantly.Forexample,
Hooimeijer et al. [ 24] proposed a lazy backtracking search algo-
rithmforsolvingtheregularexpressionconstraintsefficientlyby
afollowgraph andaconstraint-pathmapgeneratedfromthecon-
straint system. This work is specifically for solving the regular
expression constraints.7 CONCLUSION AND FUTURE WORK
In this paper, we present control flow-guided SMT solving tacticutilizing the control-flow information of the programs to refinethe DPLL(T) search procedure in SMT solvers. In our tactic, the
search space is reconstructed continuously and dynamically by the
control-flow information and thus a large number of redundant
searchpathscanbepruned.Weimplementourtacticinthemodern
SMTsolverZ3,andcompareourtacticwiththedefaultheuristic
in Z3. The experiments on SV-COMP‚Äô17 benchmarks have shown
thatourcontrolflow-guidedSMTsolvingtacticcansignificantly
speed up the SMT solving. Especially, our tactic achieves orders of
magnitude improvements on satisfiable benchmarks.
Inalgorithm 2,afteradecisionvariableisselected,itsvalueis
randomlydetermined.Therealsoexistsomestrategiesfordeciding
a variable‚Äôs value in the existing SAT/SMT solvers. Again, these
strategies are not domain specific. We are planning to study to use
the program information to guide the SMT solver for determining
the variables‚Äô values.
REFERENCES
[1]Mike Barnett, Manuel F√§hndrich, K Rustan M Leino, Peter M√ºller, Wolfram
Schulte, and Herman Venter. 2011. Specification and verification: the Spec#
experience. Commun. ACM 54, 6 (2011), 81‚Äì91.
[2]Jason Belt, Xianghua Deng, et al .2009. Sireum/Topi LDP: a lightweight semi-
decisionprocedureforoptimizingsymbolicexecution-basedanalyses.In Proceed-
ingsofthethe7thjointmeetingoftheEuropeansoftwareengineeringconference
and the ACM SIGSOFT symposium on The foundations of software engineering.
ACM, 355‚Äì364.
[3]Murphy Berzish, Yunhui Zheng, and Vijay Ganesh. 2017. Z3str3: A string solver
with theory-aware branching. arXiv preprint arXiv:1704.07935 (2017).
[4]Dirk Beyer, Alessandro Cimatti, Alberto Griggio, M Erkan Keremoglu, and
Roberto Sebastiani. 2009. Software model checking via large-block encoding. In
Formal Methods in Computer-Aided Design, 2009. FMCAD 2009. IEEE, 25‚Äì32.
[5]Dirk Beyer, Matthias Dangl, and Philipp Wendler. 2018. A unifying view on
SMT-basedsoftwareverification. JournalofAutomatedReasoning 60,3(2018),
299‚Äì335.
[6]Armin Biere, Alessandro Cimatti, Edmund Clarke, and Yunshan Zhu. 1999. Sym-
bolic model checking without BDDs. In International conference on tools and
algorithms for the construction and analysis of systems. Springer, 193‚Äì207.
[7]ArminBiere,MarijnHeule,HansvanMaaren,andTobyWalsh.2009. Conflict-
drivenclauselearningSATsolvers. HandbookofSatisfiability,FrontiersinArtificial
Intelligence and Applications (2009), 131‚Äì153.
[8]MarcoBozzano,RobertoBruttomesso,AlessandroCimatti,TommiJunttila,Peter
VanRossum,StephanSchulz,andRobertoSebastiani.2005. Themathsat3system.
InInternational Conference on Automated Deduction. Springer, 315‚Äì321.
[9]Roberto Bruttomesso, Alessandro Cimatti, Anders Franz√©n, Alberto Griggio,
Ziyad Hanna, Alexander Nadel, Amit Palti, and Roberto Sebastiani. 2007. A Lazy
and Layered SMT ( BV) Solver for Hard Industrial Verification Problems. In
International Conference on Computer Aided Verification. Springer, 547‚Äì560.
[10]Alessandro Cimatti, Jori Dubrovin, Tommi Junttila, and Marco Roveri. 2009.Structure-aware computation of predicate abstraction. In Formal Methods in
Computer-Aided Design, 2009. FMCAD 2009. IEEE, 9‚Äì16.
[11]EdmundClarke,DanielKroening,andFlavioLerda.2004. Atoolforchecking
ANSI-C programs. In International Conference on Tools and Algorithms for the
Construction and Analysis of Systems. Springer, 168‚Äì176.
[12]Patrick Cousot and Radhia Cousot. 1977. Abstract interpretation: a unified
latticemodelforstaticanalysisofprogramsbyconstructionorapproximation
of fixpoints. In Proceedings of the 4th ACM SIGACT-SIGPLAN symposium on
Principles of programming languages. ACM, 238‚Äì252.
[13]RonCytron,JeanneFerrante,BarryKRosen,MarkNWegman,andFKenneth
Zadeck.1989. Anefficientmethodofcomputingstaticsingleassignmentform.
InProceedings of the 16th ACM SIGPLAN-SIGACT symposium on Principles of
programming languages. ACM, 25‚Äì35.
[14]MartinDavis,GeorgeLogemann,andDonaldLoveland.1962.Amachineprogram
for theorem-proving. Commun. ACM 5, 7 (1962), 394‚Äì397.
[15]LeonardoDeMouraandNikolajBj√∏rner.2008. Z3:AnefficientSMTsolver.In
InternationalconferenceonToolsandAlgorithmsfortheConstructionandAnalysis
of Systems. Springer, 337‚Äì340.
[16]Leonardo De Moura and Nikolaj Bj√∏rner. 2011. Satisfiability modulo theories:
introduction and applications. Commun. ACM 54, 9 (2011), 69‚Äì77.
360
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. Control Flow-Guided SMT Solving for Program Verification ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
[17]Alastair F Donaldson, Leopold Haller, Daniel Kroening, and Philipp R√ºmmer.
2011. Software verification using k-induction. In International Static Analysis
Symposium. Springer, 351‚Äì368.
[18]Herbert Enderton and Herbert B Enderton. 2001. A mathematical introduction to
logic. Academic press.
[19]JosselinFeist,LaurentMounier,andMarie-LaurePotet.2016. Guideddynamic
symbolic execution using subgraph control-flow information. In International
Conference on Software Engineering and Formal Methods. Springer, 76‚Äì81.
[20]Jon William Freeman. 1995. Improvements to propositional satisfiability search
algorithms. Ph.D. Dissertation. University of Pennsylvania Philadelphia, PA.
[21]Dan Goldwasser, Ofer Strichman, and Shai Fine. 2008. A theory-based deci-
sion heuristicfor DPLL(T). In FormalMethods inComputer-AidedDesign, 2008.
FMCAD‚Äô08. IEEE, 1‚Äì8.
[22]Susanne Graf and Hassen Sa√Ødi. 1997. Construction of abstract state graphs with
PVS.InInternationalConferenceonComputerAidedVerification.Springer,72‚Äì83.
[23]Aarti Gupta, Malay Ganai, Chao Wang, Zijiang Yang, and Pranav Ashar. 2003.
LearningfromBDDsinSAT-basedboundedmodelchecking.In Proceedingsof
the 40th annual Design Automation Conference. ACM, 824‚Äì829.
[24]PieterHooimeijerandWestleyWeimer.2010. Solvingstringconstraintslazily.
InProceedingsoftheIEEE/ACMinternationalconferenceonAutomatedsoftware
engineering. ACM, 377‚Äì386.
[25]Robert G Jeroslow and Jinchang Wang. 1990. Solving propositional satisfiability
problems. AnnalsofmathematicsandArtificialIntelligence 1,1-4(1990),167‚Äì187.
[26]JamesCKing.1976. Symbolicexecutionandprogramtesting. Commun.ACM
19, 7 (1976), 385‚Äì394.
[27]DanielKroeningandMichaelTautschnig.2014.CBMC‚ÄìCboundedmodelchecker.
InInternational Conference on Tools and Algorithms for the Construction and
Analysis of Systems. Springer, 389‚Äì391.
[28]Andreas Kuehlmann, Malay K Ganai, and Viresh Paruthi. 2001. Circuit-based
Booleanreasoning. In Proceedingsof the38thannualDesignAutomation Confer-
ence. ACM, 232‚Äì237.
[29]K Rustan M Leino, Micha≈Ç Moskal, and Wolfram Schulte. 2008. Verification
condition splitting. Submitted manuscript, September (2008).
[30]Jia Hui Liang, Vijay Ganesh, Ed Zulkoski, Atulan Zaman, and Krzysztof Czar-
necki. 2015. Understanding VSIDS branching heuristics in conflict-driven clause-
learning SAT solvers. In Haifa Verification Conference. Springer, 225‚Äì241.[31]JoaoMarques-Silva.1999. Theimpactofbranchingheuristicsinpropositionalsat-
isfiability algorithms. In Portuguese Conference on Artificial Intelligence. Springer,
62‚Äì74.
[32]MatthewWMoskewicz,ConorFMadigan,YingZhao,LintaoZhang,andSharadMalik.2001. Chaff:EngineeringanefficientSATsolver.In Proceedingsofthe38th
annual Design Automation Conference. ACM, 530‚Äì535.
[33]Greg Nelson and Derek C Oppen. 1980. Fast decision procedures based on
congruence closure. Journal of the ACM (JACM) 27, 2 (1980), 356‚Äì364.
[34]Alexandru Nicolau. 1988. Loop quantization: A generalized loop unwinding
technique. J. Parallel and Distrib. Comput. 5, 5 (1988), 568‚Äì586.
[35]Richard Ostrowski, √âric Gr√©goire, Bertrand Mazure, and Lakhdar Sais. 2002.
Recovering and exploiting structural knowledge from CNF formulas. In Interna-
tional Conference on Principles and Practice of Constraint Programming. Springer,
185‚Äì199.
[36]MarcoPistoia,SatishChandra,StephenJFink,andEranYahav.2007. Asurvey
of static analysis methods for identifying security vulnerabilities in software
systems. IBM Systems Journal 46, 2 (2007), 265‚Äì288.
[37]MPrasanna,SSivanandam,RVenkatesan,andRSundarrajan.2005. Asurveyon
automatic test case generation. Academic Open Internet Journal 15, 6 (2005).
[38]DanielePretolani.1996. EfficiencyandstabilityofhypergraphSATalgorithms.
DIMACSSeriesinDiscreteMathematicsandTheoreticalComputerScience 26(1996),
479‚Äì498.
[39]Sriram Sankaranarayanan, Henny B Sipma, and Zohar Manna. 2004. Non-linear
loop invariant generation using Gr√∂bner bases. ACM SIGPLAN Notices 39, 1
(2004), 318‚Äì329.
[40]OferShtrichman.2000. TuningSATcheckersforboundedmodelchecking.In
International Conference on Computer Aided Verification. Springer, 480‚Äì494.
[41]Niklas Sorensson and Niklas Een. 2005. Minisat v1. 13-a sat solver with conflict-
clause minimization. SAT2005, 53 (2005), 1‚Äì2.
[42]GTseitin.1968. Onthecomplexityofderivationinpropositionalcalculus. Studies
in Constrained Mathematics and Mathematical Logic (1968).
[43]Chao Wang, HoonSang Jin, Gary D Hachtel, and Fabio Somenzi. 2004. Refining
theSATdecisionorderingforboundedmodelchecking.In Proceedingsofthe41st
annual Design Automation Conference. ACM, 535‚Äì538.
[44]Liangze Yin, Fei He, and Ming Gu. 2013. Optimizing the sat decision ordering
ofboundedmodelcheckingbystructuralinformation.In Theoreticalaspectsof
software engineering (tase), 2013 international symposium on. IEEE, 23‚Äì26.
361
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. 