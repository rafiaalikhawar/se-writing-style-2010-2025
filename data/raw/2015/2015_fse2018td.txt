Zurich Open Repository and
Archive
University of Zurich
University Library
Strickhofstrasse 39
CH-8057 Zurich
www.zora.uzh.ch
Year: 2018
PyDriller: Python framework for mining software repositories
Spadini, Davide ; Aniche, Maurício ; Bacchelli, Alberto
DOI: https://doi.org/10.1145/3236024.3264598
Posted at the Zurich Open Repository and Archive, University of Zurich
ZORA URL: https://doi.org/10.5167/uzh-197754
Conference or Workshop Item
Accepted Version
Originally published at:
Spadini, Davide; Aniche, Maurício; Bacchelli, Alberto (2018). PyDriller: Python framework for mining software
repositories. In: 26th ACM Joint Meeting on European Software Engineering Conference and Symposium on the
Foundations of Software Engineering, Lake Buena Vista, FL, USA, 4 December 2018 - 9 December 2018. ACM
Press, 908-911.
DOI: https://doi.org/10.1145/3236024.3264598PyDriller: Python Framework forMining SoftwareRepositories
Davide Spadini
Delft Universityof Technology
SoftwareImprovement Group
Delft, The Netherlands
d.spadini@sig.euMaurício Aniche
Delft Universityof Technology
Delft, The Netherlands
m.f.aniche@tudelft.nlAlbertoBacchelli
Universityof Zurich
Zurich, Switzerland
bacchelli@ifi.uzh.ch
ABSTRACT
Softwarerepositoriescontainhistoricalandvaluableinformation
abouttheoveralldevelopmentofsoftwaresystems.Miningsoftware
repositories(MSR)isnowadaysconsideredoneofthemostinter-
esting growing fields within software engineering. MSR focuses
on extracting and analyzing data available in software repositories
to uncover interesting, useful, and actionable information about
the system. Even though MSR plays an important role in software
engineering research, few tools have been created and made public
to support developers in extracting information from Git reposi-
tory.Inthispaper,wepresent Pydriller ,aPythonFrameworkthat
easestheprocessofminingGit.Wecompareourtoolagainstthe
state-of-the-art Python Framework GitPython, demonstrating that
Pydriller canachieve the same results with, on average,50% less
LOCandsignificantly lower complexity.
URL:https://github.com/ishepard/pydriller
Materials: https://doi.org/10.5281/zenodo.1327363
Pre-print: https://doi.org/10.5281/zenodo.1327411
CCS CONCEPTS
·Software andits engineering ;
KEYWORDS
MiningSoftware Repositories, GitPython, Git, Python
ACMReference Format:
Davide Spadini, Maurício Aniche, and Alberto Bacchelli. 2018. PyDriller:
Python Framework for Mining Software Repositories. In Proceedings of
Proceedingsofthe26thACMJointEuropeanSoftwareEngineeringConference
and Symposium on the Foundations of Software Engineering, Lake Buena
Vista, FL, USA,November 4ś9, 2018(ESEC/FSE ’18), 4pages.
https://doi.org/10.1145/3236024.3264598
1 INTRODUCTION
Mining software repository (MSR) techniques allow researchers to
analyze the information generated throughout the software devel-
opmentprocess,suchassourcecode,versioncontrolsystemsmeta-
data,andissuereports[ 5,18,22].Withsuchanalysis,researches
Permissionto make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthefirstpage.Copyrights forcomponentsofthisworkownedbyothersthanthe
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ESEC/FSE ’18, November 4ś9, 2018, Lake BuenaVista,FL,USA
©2018 Copyright held by the owner/author(s). Publication rights licensed to Associa-
tionfor Computing Machinery.
ACM ISBN 978-1-4503-5573-5/18/11...$15.00
https://doi.org/10.1145/3236024.3264598can empirically investigate, understand, and uncover useful and
actionableinsightsforsoftwareengineering,suchasunderstanding
the impact of code smells [ 13ś15], exploring how developers are
doingcodereviews[ 2,4,10,21]andwhichtestingpracticesthey
follow [20], predicting classes that are more prone to change/de-
fects[3,6,16,17],andidentifyingthecoredevelopersofasoftware
team to transfer knowledge [ 12].
Among the different sources of information researchers can use,
versioncontrolsystems,suchasGit,areamongthemostusedones.
Indeed,versioncontrolsystemsprovideresearcherswithprecise
information about the source code, its evolution, the developers of
the software, and the commit messages (which explain the reasons
for changing).
Nevertheless, extracting information from Git repositories is
not trivial.Indeed,manyframeworks can beusedto interactwith
Git(dependingonthepreferredprogramminglanguage),suchas
GitPython [ 1] for Python, or JGit for Java [ 8]. However, these tools
areoftendifficulttouse.Oneofthemainreasonsforsuchdifficulty
isthattheyencapsulateallthefeaturesfromGit,hence,developers
areforcedtowritelongandcompleximplementationstoextract
even simpledata from aGit repository.
Inthispaper,wepresent Pydriller ,aPythonframeworkthat
helpsdeveloperstominesoftwarerepositories. Pydriller provides
developers with simple APIs to extract information from a Git
repository,suchascommits,developers,modifications,diffs,and
source code. Moreover, as Pydriller is a framework, developers
canfurthermanipulatetheextracteddataandquicklyexportthe
results to theirpreferredformats ( e.g.,CSVfilesanddatabases).
Toevaluatetheusefulnessofourtool,wecompareitwiththe
state-of-the-art Python framework GitPython, in terms of imple-
mentation complexity, performance, and memory consumption.
Our results show that Pydriller requires significantly fewer lines
of code to perform the same task when compared to GitPython,
with only a small drop in performance. Also, we asked six develop-
erstoperformtaskswithbothtoolsandfoundthatalldevelopers
spend less time in learning and implementing tasks in Pydriller .
2 PYDRILLER
Pydriller isawrapperaroundGitPythonthateasestheextraction
of information from Git repositories. The most significant differ-
ence between the two tools is that GitPython offers many features
(almost all the features of Git), while PyDriller offers only features
that are important when performing MSR tasks, thus hiding the
underlyingcomplexityto theend user.In thissection, weexplain
the designof Pydriller ,as well as its main APIs.ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA D.Spadini et al.
2.1 Domain Object
Commit. It contains all the information regarding the commit:
thehash,thecommitter(nameandemail),theauthor(nameand
email), the message, the authored and committed dates, a list of
itsparents’hashes(amergecommithastwoparents),andthelist
of modified files (see ‘Modification’ object below). Since loading
the entire object is expensive and time consuming ( e.g.,Pydriller
needs to retrieve and parse the diff of the commit), objects are lazy
loaded,i.e.,are only computedwhen needed.
Modification. This object carries information regarding a file
changedinacommit.Amodificationobjecthasthefollowingfields:
Oldpath: old pathofthe file (can be Noneif the file isadded).
New path: new path of the file (can be Noneif the file is deleted).
Changetype: type:‘Added’,‘Deleted’,‘Modified’,or‘Renamed’.
Diff:diffofthefileasGitpresentsit(startingwith @@xx,xx@@ ).
Source code: source of the file (can be Noneif the file is deleted).
Added:number oflinesadded.
Removed: number oflinesremoved.
Filename: The name ofthe file.
2.2 Architecture
RepositoryMining. This class is in charge of running the MSR
study.Theonlyrequiredparameterofthisclassisthepathtothe
Git repository to analyze. Based on the Git path, the framework
willreturn the listofcommits inthe repository.
SinceMSRstudiesarehighlycustomizable,toallowaresearcher
tocustomizethestudy,weexposeasetofAPIs,makingitpossible
to set the dates in which Pydriller should start to analyze, as well
as filtering only specific commits. The complete list of filters is the
following:
Selectstarting point: since(afterthisdate), fromcommit (after
this commit hash),and from tag(after this commit tag)
Select ending point: to(up to this date), to commit (up to this
commit hash),and to tag(upto this commit tag)
Select by commits: single(single hash of the commit), only in
branches (onlyconsidercertainbranches), onlyinmainbranch
(only commits that belong to the main branch), only no merge
(onlycommitsthatarenotmergecommits),and onlymodifica-
tionswithfiletypes (onlycommitsinwhichatleastonemodifi-
cationwasdoneinthatfiletype, e.g.,byspecifying‘.java’,only
commits withat leastone Java file wasmodifiedare visited.)
In the following, we present some examples of how metrics can
be customizedandadaptedto variousMSR studies:
1# Analyze single commit
2RepositoryMining( 'path/to/the/repo' ,
3single= '6411e3096dd2070438a17b225f4447' )
4
5# Since 8/10/2016
6dt1 = datetime(2016, 10, 8)
7RepositoryMining( 'path/to/the/repo' ,since=dt1)
8
9# Between 2 dates
10dt1 = datetime(2016, 10, 8, 17, 0, 0)
11dt2 = datetime(2016, 10, 8, 17, 59, 0)
12RepositoryMining( 'path/to/the/repo' ,since=dt1,to=dt2)
13
14# Between tags
15first_tag = 'tag1'
16last_tag = 'tag2'17RepositoryMining( 'path/to/the/repo' ,from_tag =first_tag,
to_tag=last_tag)
18
19# Only commits in main branch
20RepositoryMining( 'path/to/the/repo' ,only_in_main_branch =
True)
21
22# Only commits in main branch and no merges
23RepositoryMining( 'path/to/the/repo' ,only_in_main_branch =
True,only_no_merge =True)
24
25# Only commits that modified a java file
26RepositoryMining( 'path/to/the/repo' ,
only_modifications_with_file_types =['.java' ])
After the user configured the RepositoryMining class, thus spec-
ifying which commits to analyze, the user has only to call the
traverse_commit() function that will return the desired list of
commits.Internally, Pydriller obtainsthelistofallthecommits,
filters out the unnecessary ones, converts the commits in a domain
object, and returns the list of resulting commits. This approach has
the advantagethat allthe complexityishiddenfrom users.
Furthermore,if users needmore thanjust visitingcommits, we
createdawrapperforthemostcommonutilitiesofGit,forexample
checkout,reset, log, show a singlecommit.We also built APIs to
helpresearchersinMSR studies,including:
Parse diff : The diff presented by Git is difficult to parse. With
this API, given a diff, it returns a dictionary with the added
anddeletedlines.Forbothgroups,thefunctionreturnsatuple,
corresponding to 1)linenumber inthe file and2)actual line.
Get commits that last modified lines: This function applies
SZZ [17]. Given a ‘Commit’ object as parameter, it returns the
set of commits that changed last the lines modified in the files
includedinthecommit.Thealgorithmworksasfollow(forevery
file in the commit): 1) obtain the diff, 2) obtain the list of deleted
lines, and 3) blame the file and obtain the commits were those
lineswere changedlast.
To facilitate the data analysis, Pydriller gracefully handles
GitPythonexceptions.Forexample,whenretrievingthesourcecode
of non-UTF-8 files ( e.g., bytecodes),GitPython raisesan exception,
while PyDriller returns an empty string. Hence, Pydriller reduces
theburdenofhandlingseveralexceptionsthatadeveloperwould
have to do otherwise.
3 EVALUATION
Toevaluateourtool,wecompare Pydriller againstthestate-of-
the-art Git framework for PythonśGitPython. We select five dif-
ferent common MSR tasks that we encountered in our experience
as researchers in the MSR field, and implement them using both
frameworks. The tasksfollow:
Task1:Calculatingcomplexityoftheaddedlinesforeverycom-
mit.Forthesakeofsimplicity,wedefinecomplexityasthe
number of ifstatements inthe diff.
Task2:Detectingbuginducingcommits.WeuseSZZ[ 17]tore-
trieve the commits where the bug was introduced, as nor-
mallydone inprevious literature [ 14,15,20].
Task3:ObtainingthelistofcommitsthatonlymodifiedJavafiles.
Task4:Linesofcode per sourcefile over time.
Task5:Day of the week developers fixed more bugs between two
releases.PyDriller: Python Framework for Git ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA
Table 1:Comparisonbetween Pydriller andGitPython.
PyDriller GitPython Total
Ex1Time 00:14:59 00:13:25 +00:01:34
MaxMemory (MB) 169 148 +21
LOC 21 54 -61%
Complexity 7 15 -53%
Ex2Time 00:01:14 00:01:00 +00:00:14
MaxMemory (MB) ś ś ś
LOC 19 66 -71%
Complexity 5 6Similar
Ex3Time 00:01:24 00:01:14 +00:00:10
MaxMemory (MB) 94 39 +55
LOC 10 18 -44%
Complexity 2 6-67%
Ex4Time 00:15:03 00:15:47 -00:00:44
MaxMemory (MB) 162 132 +30
LOC 17 42 -60%
Complexity 6 15 -60%
Ex5Time 00:00:02 00:00:03 Similar
MaxMemory (MB) ś ś ś
LOC 12 19 -37%
Complexity 3 4Similar
We run thefive tasks (implemented inboth Pydriller and Git-
Python)on50OSSprojects,25belongingtotheEclipseFoundation
and 25 to Apache. We selected the projects using GHTorrent [ 9],
taking the 25 most starred projects of the two organizations. For
the sake of simplicity, we only report the results of one project,
Apache Hadoop. The results of the other 49 projects can be found
inour on-line appendix [ 19].
Wecomparethetoolsunderdifferentmetrics:linesofcode(LOC)
andcomplexity(McCabecomplexity[ 11])ofbothimplementations,
as well as their memory consumption, and execution time. Table 1
showstheresults.Foralltheexercises,bothinPyDrillerandGit-
Python,thenumberoflinesthatarenotacorefunctionality(for
example the constructor) is three. We keep this number as it is
alwaysthe same for allthe exercises andfor both tools.
Regardingexecutiontime, Pydriller isgenerallyslowerthan
GitPython.Thisdecreaseinspeedisexpected,giventhat Pydriller
isawrapperbuiltontopofthepythonframework.However,the
difference is small: In the most expensive tasks (Ex1 and Ex4), in
which the tools have to analyze the diff or source code of every
file in 20,000 commits, Pydriller is only 1:34 minutes slower in
the first case. In the other task, Pydriller is 44 seconds faster than
GitPython. Nevertheless, both tools take less than 16 minutes to
analyze the entire history of Apache Hadoop (avg. 22 commits per
second).Asformemoryconsumption,thetoolsbehavesimilarly:
In some cases, the used memory is less than 50MB. In the most
memoryconsumingtask(number1),theusedmemorywas169MB.
The large difference between both toolsisinterms ofLOCand
complexityoftheimplementation.Fortheformer,weseethatusing
Pydriller results (on average) in writing 50% less lines of code
thanusingGitPython.Thebiggestdifferenceisinthetask2,whereTable2:Timespentbytheparticipantsoftheexperimentin
solvingtasks3 and4 together.
ParticipantTime (minutes)
withPydrillerTime (minutes)
withGitPythonTotal
P1 45 80-44%
P2 23 45-49%
P3 13 20-35%
P4 19 26-27%
P5 44 46ś
P6 17 30-43%
the tool had to retrieve the bug inducing commits using the SZZ
algorithm: This problem was solved in 19 LOC using Pydriller ,
while66 LOCwithGitPython (70% difference).
We also observe that the complexity of the code written for
Pydriller is significantly lower than for GitPyhon. Table 1shows
that, on average, the codefor Pydriller is 60% less complex. This
is especially the case in tasks that have to deal with retrieving
the diff orsource code of the modified files; indeed, obtaining this
informationin Pydriller isjust1APIcall,whileGitPythonrequires
manylinesofcode andexceptions handling.
4 EVALUATION WITHDEVELOPERS
To furtherevaluate ourtool, weinvited six developersto perform
the same two tasks using both Pydriller and GitPython, and to
note the time they took to solve the problems, as well as their
personal opinions on both tools. All developers had experience in
developing with Pythonand on performingMSRstudies, but they
hadnever usedPyDrillernorGitPython before.
We asked the participants to solve tasks 3 and 4. We chose these
tasks because they are simpler than the first two (to keep the ex-
periment short) and do not require participants to have notions
on how to identify bug fixing commits (Ex5). The setting of the
experiment isthe following:
•Participantsshouldimplementbothtasks,firstwith Pydriller ,
thenwithGitPython.Sinceunderstandinghowtosolvethetasks
doesrequire someadditionaltime, weaskedtheparticipantsto
startwith Pydriller .Thischoiceclearlypenalizesourtool,as
participants will have a better intuition about the tasks when
doingthetaskinGitPython.However,webelievethat Pydriller
issimplertouse,andthatthedifferencebetweenthetwotools
willstillbe significant.
•Participants should take notes about the time it takes them to
implement the tasks. We ask participants to also include the
time spent reading the documentation of the two tools, since
understanding howto use the toolispart of the experiment.
•After having implemented both tasks, we ask to the participants
to elaborate on the different advantages and disadvantages be-
tween both tools.
The result of the experiment is shown in Table 2. Five out of
six participants spent significantly less time to solve the problems
(27%lessintheworstcase,49%lessinthe best case).P5,instead,
solvedboth problemsinthesameamountoftime: theparticipant
did not know how to solve the second task and, since he startedESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA D.Spadini et al.
withPydriller ,thistranslatedinmoretimeinthefirstpart.When
he understood how to solve it, he moved to GitPython already
knowing the solution.
Allparticipantsagreedthat Pydriller waseasiertousethanGit-
Python [P 1−6]. P6said:"I thought PyDriller was a lot more intuitive
than using GitPython. GitPython works exactly like Git, so it isn’t
verywell suited when trying to gain insights about therepository."
Similarly, P 1affirmed that, using Pydriller , he was able to
achieve the same result with simpler and shorter code, and that he
willcontinuetouse Pydriller inhisnextMSRstudies.P 2added
thatGitPythonisusefulwhenonehastosimulateGitcommandsin
Python, but it can be overcomplicated when the goal is to perform
MSRstudies,forwhich Pydriller ismoreappropriate,becauseit
hidesthis complexityfrom its users.
5 RELATED TOOLS
InthissectionwecomparePyDrilleragainsttwoofthemostrecent
andusedMSR tools.
Boa[7]: Boa is a domain-specific language and infrastructure that
eases MSR. The main difference between PyDriller and Boa is that,
while the former can be run on every project, Boa can only be
usedontheirsnapshotsofGitHuborSourceForge,whichcurrently
are3and6 yearsold.Furthermore,PyDrilleriswritteninPython.
Hence, it has all the flexibility of a the programming language and
can be used together with other frameworks. Boa, on the other
hand,hasitsownDSL,andcannotbeusedwithother(external)
libraries. Furthermore, Boa currently includes only the history and
sourcecodeofJavaprojects,while Pydriller canbeusedtoanalyze
repositoriesofany programminglanguage.
GHTorrent [9]:GHTorrentisascalable,queriable,offlinemirrorof
datapresentonGitHub.ThemaindifferencebetweenPyDrillerand
GHTorrentisthat,whiletheformerretrievesalltheinformation
regardingacommit( e.g.,whatfileschanged,diffs,andsourcecode),
the latter focuses on GitHub’s social data, such as pull requests,
issues,andusers.However,GHTorrentdoesnotofferthepossibility
ofnavigatingthroughthecommitsoranalyzingtheproject’ssource
code over time (whichisafeature of Pydriller ).
6 CONCLUSION
Inthispaper,wepresented Pydriller ,aPythonframeworkthat
helps developers on mining software repositories. We showed that
withPydriller ,developerscaneasilyextractinformationfromany
Git repository, such as commits, developers, modifications, diffs,
and source codes, since Pydriller releases simple APIs to help
researchersandpractitioners performingMSR.
We evaluated Pydriller on 5 exercises, comparing it against
GitPython. The evaluation showed that using Pydriller results
in writing (on average) half the code, and 60% less complex. Fur-
thermore,weasked6developerstosolvetwoexercisesusingour
tool,andtheyallagreedthat Pydriller helpedtheminsolvingthe
problems inless time withless code.
The first version of PyDriller has been released on 9th April
2018,andsincethenithasbeendownloadedapproximatively1,000
times per month (as computed through łPypinfož1and Google
BigQuery). We plan to keepimproving Pydriller’s performance as
1https://github.com/ofek/pypinfowellastoperformmoreuserstudieswiththegoalofunderstanding
even betterwhat MSR researchersrequire intheir studies.
ACKNOWLEDGMENTS
D.SpadinigratefullyacknowledgesthesupportofSENECA-EU
MSCA-ITN-2014-EIDno.642954.A.Bacchelligratefullyacknowl-
edgesthesupportoftheSwissNationalScienceFoundationthrough
the SNF ProjectNo.PP00P2_170529.
REFERENCES
[1][n.d.]. GitPython. https://github.com/gitpython-developers/GitPython .([n.d.]).
[2]Alberto Bacchelli and Christian Bird. 2013. Expectations, outcomes, and chal-
lenges of modern code review. In Proc. of the 35th International Conference on
SoftwareEngineering . 712ś721.
[3]AlbertoBacchelli,MarcoD’Ambros,andMicheleLanza.2010. Arepopularclasses
moredefectprone?.In InternationalConferenceonFundamentalApproachesto
SoftwareEngineering . Springer, 59ś73.
[4]Moritz Beller, Alberto Bacchelli, Andy Zaidman, and Elmar Juergens. 2014. Mod-
ern code reviewsin open-sourceprojects: Which problemsdothey fix?. In Proc.
ofthe 11thworking conference onminingsoftwarerepositories . ACM,202ś211.
[5]K. K. Chaturvedi, V. B. Sing, and P. Singh. 2013. Tools in Mining Software
Repositories. In 2013 13th International Conference on Computational Science and
Its Applications . 89ś98.
[6]Marco D’Ambros, Alberto Bacchelli, and Michele Lanza. 2010. On the Impact of
DesignFlawsonSoftwareDefects.In Proc.ofthe10thInternationalConference
onQualitySoftware . 23ś31.
[7]Robert Dyer, Hoan Anh Nguyen, Hridesh Rajan, and Tien N. Nguyen. 2013.
Boa:ALanguageandInfrastructureforAnalyzingUltra-Large-ScaleSoftware
Repositories.In Proc.ofthe35thInt’lConferenceonSoftwareEngineering .422ś431.
[8] EclipseFoundation. [n. d.]. JGit. https://www.eclipse.org/jgit/ . ([n. d.]).
[9]Georgios Gousios. 2013. The GHTorrent dataset and tool suite. In Proc. of the
10thWorking Conference onMiningSoftwareRepositories . 233ś236.
[10]VincentJHellendoorn,PremkumarTDevanbu,andAlbertoBacchelli.2015. Will
theylike this?:Evaluatingcodecontributionswith languagemodels.In Proc.of
the12thWorkingConferenceonMiningSoftwareRepositories .IEEEPress,157ś167.
[11] TJ McCabe. 1976. AComplexityMeasure. (1976).
[12]Audris Mockus, Roy T Fielding, and James Herbsleb. 2000. A case study of open
sourcesoftwaredevelopment:theApacheserver.In Proc.ofthe22ndinternational
conference onSoftwareengineering . Acm, 263ś272.
[13]Steffen M. Olbrich, Daniela Cruzes, and Dag I. K. Sjùberg. 2010. Are all code
smells harmful? A study of God Classes and Brain Classes in the evolution of
three open source systems. In 26th IEEE International Conference on Software
Maintenance (ICSM2010), September 12-18, 2010, Timisoara, Romania . 1ś10.
[14]Fabio Palomba, Gabriele Bavota, Massimiliano Di Penta, Rocco Oliveto, and
Andrea De Lucia. 2014. Do They Really Smell Bad? A Study on Developers’
PerceptionofBadCodeSmells.In Proc.ofthe30thInternationalConferenceon
SoftwareMaintenance and Evolution . 101ś110.
[15]Fabio Palomba, Annibale Panichella, Andy Zaidman, Rocco Oliveto, and Andrea
DeLucia.2017. TheScentofaSmell:AnExtensiveComparisonbetweenTextual
and StructuralSmells. IEEE Transactions onSoftwareEngineering (2017).
[16]Luca Pascarella, Fabio Palomba, and Alberto Bacchelli. 2018. Re-evaluating
Method-Level Bug Prediction. In Proc. of the 25th International Conference on
SoftwareAnalysis, Evolution, and Reengineering . 592ś601.
[17]Jacek Sliwerski, Thomas Zimmermann, and Andreas Zeller. 2005. When do
changes induce fixes?. In Proc. of the 2nd International Workshop on Mining
SoftwareRepositories .
[18]Francisco Zigmund Sokol, Mauricio Finavaro Aniche, and Marco Aurélio Gerosa.
2013. MetricMiner:Supportingresearchersinminingsoftwarerepositories. IEEE
13th International Working Conference on Source Code Analysis and Manipulation,
SCAM 2013 (2013), 142ś146.
[19]Davide Spadini.2017. PyDriller Dataset. (2017). https://doi.org/10.5281/zenodo.
1327363
[20]Davide Spadini, Maurício Aniche, Margaret-Anne Storey, Magiel Bruntink, and
Alberto Bacchelli. 2018. When Testing Meets Code Review: Why and How
DevelopersReviewTests.In Proc.ofthe40thInternationalConferenceonSoftware
Engineering . 677ś687.
[21]PatanamonThongtanunam,ShaneMcintosh,AhmedE.Hassan,andHajimuIida.
2017. Reviewparticipationinmoderncodereview-Anempiricalstudyofthe
android, Qt, and OpenStack projects. Empirical Software Engineering (EMSE) 22,
2 (2017), 768ś817.
[22]Andy Zaidman, Bart Van Rompaey, Serge Demeyer, and Arie van Deursen. 2008.
Mining Software Repositories to Study Co-Evolution of Production & Test Code.
In2008 International Conference on Software Testing, Verification, and Validation ,
Vol. 3.IEEE,220ś229. http://ieeexplore.ieee.org/document/4539549/