Jens Knoop, Uwe Zdun (Hrsg.): Software Engineering 2016,
Lecture Notes in Informatics (LNI), Gesellschaft f ¨ur Informatik, Bonn 2016 59
Getting to Kno wYou:Towards aCapability Model forJava
Ben Hermann1Michael Reif2Michael Eichberg3and Mira Mezini4
Abstract: Developing software from reusable libraries lets de velopers faceasecurity dilemma: Ei-
ther be efﬁcient and reuse libraries as the yare or inspect them, kno wabout their resource usage,
butpossibly miss deadlines as reviews are atime consuming process. In this paper ,w ep ropose a
novelcapability inference mechanism for libraries written in Ja va.I tu sesacoarse-grained capa-
bility model for system resources that can be presented to de velopers. Wefound that the capability
inference agrees by 86 .81% on expectations to wards capabilities that can be deri vedfrom project
documentation. Moreo ver,our approach can ﬁnd capabilities that cannot be disco vered using project
documentation. It is thus ahelpful tool for de velopers mitigating the aforementioned dilemma.
1S ummary
The efﬁcienc yo fs oftware de velopment largely depends on an ecosystem of reuse [Bo99,
Gr93]. Numerous software libraries are available that solv evarious problems ranging from
numerical computations to user interface creation. The safe use of these libraries is an
exigence for the de velopment of software that meets critical time-to-market constraints.
Howe ver,when including software libraries into their products software de velopers entrust
the code in these libraries with the same security context as the application itself re gard-
less of the need for this excessi veendorsement. Forinstance, asystem that makes use
ofalibrary of numerical functions also enables the library to use the ﬁlesystem or make
network connections although the library does not need these capabilities. If the library
contains malicious code it could mak euse of them. In commonly used languages lik eJava
no effecti vemechanism to limit or isolate software libraries from the application code ex-
ists. So de velopers faceadilemma: Either trust the component and ﬁnish the project in
time or be secure, revie wthe library’ ssource code and possibly miss deadlines.
Wepropose to consider this excessi veassignment of authority as aviolation of the Prin-
ciple of Least Privile ge[SS75] .The principle states that every program should operate
under the least set of privilege necessary to complete its job .I no rder to alleviate the de-
scribed dilemma, we introduce an effecti vemechanism in this paper to detect the actual
permission need of software libraries written in Ja va.
Drawing inspiration from Android, we construct acapability model for Ja va.I tincludes
basic, coarse-grained capabilities such as the authority to access the ﬁlesystem or to open a
1Technische Uni versit¨at Darmstadt, Fachbereich Informatik Fachgebiet Softwaretechnik, Hochschulstraße 10,
64289 Darmstadt, hermann@cs.tu-darmstadt.de
2reif@cs.tu-darmstadt.de
3eichberg@cs.tu-darmstadt.de
4mezini@cs.tu-darmstadt.de60 Ben Hermann et al.
network socket. As Ja vaprograms by themselves cannot communicate with the operating
system directly ,anyinteraction with those capabilities has to happen through the use of
the Ja vaNativeInterface (JNI). By tracking the calls backwards through the call graph, we
produce acapability set for every method of the Ja vaClass Library (JCL) and by the same
mechanism to wards methods of alibrary .W ec an thus effecti vely infer the necessary ca-
pabilities of alibrary using our approach. Wecan also infer the subset of these capabilities
used by an application, as it may not use every functionality supplied by the library.
As the precision of our approach is directly depending on the precision of the algorithm
used to calculate the call graph of the library ,w et ook se veral measures to compute a
reasonably precise call graph while not compromising the scalability of the algorithm too
severely.W ee valuated our approach by comparing our results against expectations deri ved
from API documentation. Wefound that for 70 projects from the Qualitas Corpus [Te10],
that we evaluated against, actual results exceeded expectations and produce afar more ac-
curate footprint of the projects capability usage. Thereby ,our approach helps de velopers to
quickly mak einformed decisions on library reuse without the need for manual inspection
of source code or documentation.
In our pursuit to mitigate the software de veloper’ sdilemma w.r.t. library reuse, we thus
contribute the following in our paper:
• an algorithm to propagate capability labels backwards through acall graph,
• alabeling of nati vemethods with their necessary capabilities to bootstrap the pro-
cess,
• acollection of efﬁcient analysis steps to aid the precision of common call-graph
algorithms,
• anevaluation of the algorithm against extracted capability expectations from docu-
mentation.
Weprovide the implementation and all related data of our approach here:
http://www.thewhitespace.de/projects/peaks/capmodel.html
References
[Bo99] Boehm, Barry W:Managing Software Productivity and Reuse. IEEE Computer ,32(9):111–
113, 1999.
[Gr93] Griss, Martin L: Software Reuse: From Library to Factory .IBM Systems Journal,
32(4):548–566, 1993.
[SS75] Saltzer ,J.H.; Schroeder ,M.D.: The protection of information in computer systems. Pro-
ceedings of the IEEE, 63(9):1278–1308, Sept 1975.
[Te10] Tempero, Ewan; Anslo w,Craig; Dietrich, Jens; Han, Ted; Li, Jing; Lumpe, Markus; Melton,
Hayden; Noble, James: Qualitas Corpus: ACurated Collection of Ja vaCode for Empirical
Studies. In: 2010 Asia Paciﬁc Software Engineering Conference (APSEC2010). pp. 336–
345, December 2010.