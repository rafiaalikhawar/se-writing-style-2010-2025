Symbolic Repairs for GR(1) Speciﬁcations
Shahar Maoz
Tel Aviv University
Tel Aviv, IsraelJan Oliver Ringert
University of Leicester
Leicester, UKRaﬁ Shalom
Tel Aviv University
Tel Aviv, Israel
Abstract —Unrealizability is a major challenge for GR(1), an
expressive assume-guarantee fragment of LTL that enables efﬁ-
cient synthesis. Some works attempt to help engineers deal withunrealizability by generating counter-strategies or computing anunrealizable core. Other works propose to repair the unrealizablespeciﬁcation by suggesting repairs in the form of automaticallygenerated assumptions.
In this work we present two novel symbolic algorithms for
repairing unrealizable GR(1) speciﬁcations. The ﬁrst algorithminfers new assumptions based on the recently introduced JVTS.
The second algorithm infers new assumptions directly from the
speciﬁcation. Both algorithms are sound. The ﬁrst is incompletebut can be used to suggest many different repairs. The secondis complete but suggests a single repair. Both are symbolic andtherefore efﬁcient.
We implemented our work, validated its correctness, and
evaluated it on benchmarks from the literature. The evaluationshows the strength of our algorithms, in their ability to suggestrepairs and in their performance and scalability compared toprevious solutions.
I. I NTRODUCTION
Reactive synthesis is an automated procedure to obtain
a correct-by-construction reactive system from its temporal
logic speciﬁcation [ 31]. Instead of using model checking
to verify a manually constructed implementation, synthesisoffers an approach where a correct implementation of thesystem is automatically obtained for a given speciﬁcation,if such an implementation exists. In reactive synthesis, animplementation is given as a controller, i.e., an automatonthat accepts input from the environment and produces thesystem’s output to always satisfy the speciﬁcation (inputfrom the environment may come from sensors, system’s
output includes commands for actuators). If such a controller
exists, the speciﬁcation is considered realizable. Otherwise, the
speciﬁcation is unrealizable, i.e., there exists an environment
that can satisfy all the assumptions while forcing the system
to violate some of its guarantees.
While synthesis from Linear Temporal Logic (LTL) spec-
iﬁcations is generally considered impractical due its high
computational complexity (double exponential in the length of
the formula), in this work we focus on GR(1), an assume-guarantee fragment of LTL that has an efﬁcient symbolicsynthesis algorithm [
3] and whose expressive power covers
most of the well-known LTL speciﬁcation patterns of Dwyer
et al. [ 10], [24]. GR(1) speciﬁcations include assumptions and
guarantees about what needs to hold on initial states, on all
states (safety), and inﬁnitely often on every run (justice).One of the main challenges of reactive synthesis in general
and of GR(1) synthesis in particular is to deal with unrealizable
speciﬁcations [ 1], [4], [7], [18], [21]. One way to deal with
unrealizability is repairing it, by automatically generating a
repair in the form of new, additional assumptions, which would
make the speciﬁcation realizable.
Some existing repair techniques for GR(1) use concrete
counter-strategies (CSs) as a starting point. A concrete CSshows how an environment can satisfy all the assumptions
while forcing the system to violate some of its guarantees.
Since generating a concrete CS is costly, due to the need to
enumerate all its states, the efﬁciency of these repair techniques
is limited. Other repair techniques are deﬁned over the more
general LTL. As such, they may suggest repairs that are outside
the GR(1) fragment, and hence cannot be applied in a GR(1)
setting. These limitations hinder the use of existing repair
approaches by engineers.
In this work we present two novel, symbolic repair
techniques that aim to address these limitations. First,
JVTS-Repair . The JVTS [ 21] is a symbolic representation
of CSs for GR(1), which is computed symbolically, without
the expensive enumeration of concrete states. Given a JVTS,
we generate candidate assumptions that eliminate the CS it
represents. By construction, the nodes of a JVTS represent
symbolically how a CS prevents an implementation. Based on
these nodes, JVTS-Repair creates assumptions that prevent
the CS. By iterating this approach, JVTS-Repair ﬁnds
candidates for repairs. Second, GLASS , which does not rely
on CSs but addresses unrealizability in a “global” way, directly
analyzing assumptions and guarantees. GLASS computes a
safety assumption that ensures the safety guarantees can be
satisﬁed, a justice assumption for each justice guarantee, and
ﬁnally an initial assumption to prevent losing initial states.
One strength of JVTS-Repair is its efﬁciency, thanks to
its symbolic nature. It is also typically capable of generating
many different repairs. It is, however, incomplete; for someunrealizable GR(1) speciﬁcations it cannot suggest a repair
although such a repair exists. One strength of GLASS is that
it is not only very efﬁcient but also complete. We proveits completeness in the paper (as well as demonstrate it in
our evaluation, see below). Unlike JVTS-Repair ,GLASS is
however limited to generating only one repair, and typically
generates a repair that involves more variables than the ones
suggested by JVTS-Repair.
We further extend the two techniques with size minimization
using the notion of repair core, roughly, a locally minimal
10162019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)
1558-1225/19/$31.00 ©2019 IEEE
DOI 10.1109/ICSE.2019.00106
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:39:38 UTC from IEEE Xplore.  Restrictions apply. 1env boolean r; // request
2env boolean c; // clear
3
4sys boolean g; // grant
5sys boolean v; // valid
6
7// sys responds with grant for every request
8gar respond: pRespondsToS(r, next (g));
9
10// if cleared or granted no immediate next grant
11gar ungrant: G( ( c|g )- > next (!g));
12
13// cleared request means not valid
14gar exclude: G(c -> !v);
15
16// infinitely often give valid grants
17gar just: GF(g & v);
Listing 1
UNREALIZABLE REQUEST -GRANT (RG1)SPECIFICATION ,ADOPTED
FROM [1], [23]
subset of a repair that is already a repair, and with support for
auxiliary variables, which are common in speciﬁcations that
use patterns. We describe these extensions in Sect. VII.
We have implemented all the above ideas in Spectra
Tools [ 33]. We present an evaluation of our work over
benchmarks taken from the literature in terms of ability to
repair, computation time, and scalability. The evaluation shows
not only that our symbolic repairs are able to repair many
speciﬁcations that could not be repaired by previous works, but
also that their computation is signiﬁcantly faster. See Sect. VIII.
Program repair is an active research area [ 13]. While we are
partly inspired by works on program repair, we do not deal with
repairing imperative programs but rather with repairing GR(1)
speciﬁcations, which are temporal declarative speciﬁcations for
reactive systems. Most previous works on repairing unrealizable
GR(1) speciﬁcations (e.g., [ 1], [4]) have relied on a concrete
CS. Our algorithms are symbolic. We discuss related work in
Sect. IX.
II. R UNNING EXAMPLE
We adopt the request-grant running example RG1 used in
previous GR(1) repair papers [ 1], [23]1. The environment has
two variables, rfor requests and cfor clearing requests. The
system has two variables, gfor grants and vfor marking grants
valid. Four guarantees express the system’s requirements. The
ﬁrst states that a request is answered by a grant within a
positive ﬁnite number of steps2. The second prohibits a grant
immediately following a grant or a clear. The third states
that clear and valid are always mutually exclusive. The last
guarantee requires a valid grant inﬁnitely often.
The speciﬁcation in Lst. 1 is unrealizable, i.e., there exists
no implementation of the system that satisﬁes all guarantees. A
simple CS demonstrates this: if the environment cancels ( c) all
1Although GR(1) speciﬁcations typically contain assumptions, this example
contains only guarantees. Nevertheless, we chose to use this example here
because it is simple for presentation in a paper format and has been used in
previous closely related works. Note that our repairs handle general GR(1)
speciﬁcations, which indeed typically include assumptions.
2Note that the ﬁrst guarantee is equivalent to the LTL formula G(r→FXg),
which is not a pure GR(1) guarantee. It is implemented with a response pattern
(following [ 24]), which introduces a Boolean auxiliary variable that is implicit
in the speciﬁcation (see also [ 3] for explicitly introducing the variable). We
discuss patterns and auxiliary variables in Sect. VII-B.requests ( r), it prevents vfrom becoming true (to satisfy the
third guarantee), and thus a valid grant (which violates the last
guarantee). How can this unrealizable speciﬁcation be repaired,
i.e., can one add assumptions that will make it realizable?
Our symbolic repair algorithms aim at generating such
assumptions.
Consider the following two assumptions: never cancel a
request immediately in the next state G(r -> ! next (c)) ,
and always eventually issue requests that are not immediately
canceled GF(r & !c) . These two assumptions constitute
a repair of the speciﬁcation, i.e., adding them makes the
speciﬁcation realizable. Such a repair is an example for the
output automatically generated by our repair algorithms.
III. P RELIMINARIES
A. Linear Temporal Logic (LTL)
We will use one of the standard deﬁnitions of linear temporal
logic (LTL) , e.g., as found in [ 3], over present-future temporal
operators X(next), U(until), F(ﬁnally), and G(globally), and
past temporal operator H(historically).
For a ﬁnite set of Boolean variables V,acomputation σ=
s0s1..∈(2V)ωis an inﬁnite sequence of states , i.e., of truth
assignments sitoV.W eu s e σ,i|=ψto denote that the LTL
formulaψholds at position i≥0ofσ, as deﬁned, e.g., in
[3]. We denote σ,0|=ψbyσ|=ψ, and say that σsatisﬁesψ.
B. GR(1) Realizability
LTL formulas can be used as speciﬁcations of reactive sys-
tems where atomic propositions are interpreted as environment
(input) and system (output) variables. An assignment to all
variables is called a state.
A strategy for an LTL speciﬁcation ϕprescribes the outputs
of a system that from its winning states for all environment
choices lead to computations that satisfy ϕ. A speciﬁcation ϕ
is called realizable if a strategy exists such that for all initial
environment choices the initial states are winning states. The
goal of LTL synthesis is, given an LTL speciﬁcation, to ﬁnd a
strategy that realizes it, if one exists.
GR(1) synthesis [ 3] handles a fragment of LTL where
speciﬁcations contain initial assumptions and guarantees over
initial states, safety assumptions and guarantees relating the
current and next state, and justice assumptions and guarantees
requiring that an assertion holds inﬁnitely many times during a
computation. A GR(1) speciﬁcation Sconsists of the following
elements [3]:
•Xinput variables controlled by the environment;
•Youtput variables controlled by the system;
•X/primeandY/primecopies of input and output variables at next step
•θeassertion over Xcharacterizing initial environment states;
•θsassertion over X∪Y characterizing initial system states;
•ρe(X∪Y∪X/prime)transition relation of the environment;
•ρs(X∪Y∪X/prime∪Y/prime)transition relation of the system;
•Je
i∈1..njustice goals of the environment;
•Js
j∈1..mjustice goals of the system.
1017
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:39:38 UTC from IEEE Xplore.  Restrictions apply. A GR(1) speciﬁcation is (strictly) realizable iff the following
LTL formula is realizable:
ϕsr=(θe→θs)∧(θe→G((Hρe)→ρs))∧
(θe∧Gρe→(/logicalanddisplay
i∈1..nGFJe
i→/logicalanddisplay
j∈1..mGFJs
j)).
Speciﬁcations for GR(1) synthesis have to be expressible in
the above structure and thus do not cover the complete LTL.
Efﬁcient symbolic algorithms for GR(1) realizability checking
and controller synthesis have been presented in [ 3], [30]. The
algorithm of Piterman et al. [ 30] computes winning states for
the system, i.e., states from which the system can realize ϕsr.
Note that the problem of satisﬁability, i.e., the existence of
a computation that satisﬁes an LTL formula, is usually easier
than the problem of realizability [20].
C. Counter-Strategies and the JVTS
A speciﬁcation is unrealizable if the environment can force
the system to violate one of its guarantees while satisfying all
the environment assumptions, i.e., the environment has a CS.
A CS can be given by an LTS that for every state prescribes
inputs from the environment that from its winning states for all
system choices lead to computations that satisfy ¬ϕsr.AC S
can ensure ¬ϕsrby either forcing the system to a deadlock
(violation of an initial guarantee or a safety guarantee) or by
satisfying all justice assumptions Je
iand preventing at least
one justice guarantee Js
jforever.
A Justice Violations Transition System (JVTS) [ 21]i s
an acyclic LTS consisting of two types of symbolic states
abstracting the CS, attractor-states (forcing to initial or safety
guarantee violations or to other symbolic states) and cycle-
states (locally preventing at least one justice guarantee). Each
state in the JVTS represents a set of states in some CS, and
each transition in the JVTS represents a set of transitions in
that CS. The JVTS is acyclic, e.g., every play will end in a
deadlock or stay in some cycle state forever.
Deﬁnition 1 (Justice Violations TS (JVTS) structure, see [ 21]
for a complete deﬁnition) .Given an unrealizable GR(1)
speciﬁcation, a JVTS is an acyclic LTS /angbracketleftQ,T,I,L /angbracketright, where:
•Qis a set of symbolic states where each q∈Qis either a
cycle-state or an attractor-state,
•T⊆Q×Qis an acyclic transition relation,
•Iis a set of symbolic initial states, and
•Lis a labeling function that labels all states in Qwith
assertions over X∪Y characterizing the corresponding sets
of concrete states in a CS.
Kuvent et al. [ 21] showed how to compute the JVTS symbol-
ically and thus efﬁciently, without the expensive enumeration
of concrete states of a CS.
D. Symbolic Algorithm Notation
Symbolic synthesis algorithms in our context operate on
sets of states and transitions instead of on their explicit
representations. In our algorithms, we use assertions forsymbolic representation of sets of states (over variables X,
Y) and sets of transitions (over variables X,Y,X/prime, andY/prime).
We operate on assertions using the usual Boolean operators, e.g.,
for an assertion ξoverX∪Y the expression ξ∧θecharacterizes
all states in ξthat are also initial environment states. In addition
to standard Boolean operators we also use prime (ξ), which
translates an assertion ξoverX∪Y to an equivalent assertion
overX/prime∪Y/prime, and quantiﬁcation where for V⊆X∪Y∪X/prime∪Y/prime
existential quantiﬁcation ξ|∃Vyields an assertion without V
that holds iff there exists an assignment to variables in Vs.t.
ξholds (analogous for universal quantiﬁcation ξ|∀V).
All operations used in our algorithms have direct implemen-
tations using Binary Decision Diagrams with CUDD [32].
IV . P ROBLEM DEFINITION
Intuitively, the repair problem takes as input an unrealizable
GR(1) speciﬁcation Sand produces a set of assumptions that
makeSrealizable.
A closer look reveals that some (repaired) speciﬁcations do
not allow assumptions and guarantees to be satisﬁed together
and realizability implies that the system forces the environment
to violate assumptions (a case of non-well-separation [ 25]). We
say a speciﬁcation Sisγ-sat iff all existing assumptions and
guarantees can be satisﬁed together, i.e., when γ=θe∧θs∧
G(ρe∧ρs)∧/logicalandtext
i∈1..nGF(Je
i)∧/logicalandtext
j∈1..mGF(Js
j)is satisﬁable.
Example 1. The speciﬁcation from Lst. 1 is γ-sat. Consider
adding the assumption ψ=G(!g -> next (c)) to always
cancel requests if no grant is given. This speciﬁcation is still
unrealizable but not γ-sat: guarantee ungrant requires that
gbecomes false and together with ψ,gstays false forever and
guarantee just cannot be satisﬁed.
Interestingly, assumption GF(r & !c) from Sect. II makes
the speciﬁcation realizable. However , after adding this assump-
tion a valid system implementation never grants requests, the
environment has to always cancel, and is forced to violate the
new assumption.
We consider repairs leading to γ-unsat speciﬁcations not use-
ful.3Adding assumptions to a γ-unsat speciﬁcation preserves γ-
unsatisﬁability and we thus consider it as unrepairable (indeed
we have found several unrealizable and γ-unsat speciﬁcations
in our evaluation, see Sect. VIII).
Formally, we deﬁne the repair problem as follows: given
an unrealizable and γ-sat speciﬁcation S, ﬁnd additional
assumptions that will make Srealizable and γ-sat. We call
such a set of assumptions a repair.
V . JVTS-B ASED SYMBOLIC REPAIR
We now present our ﬁrst main contribution, namely a
symbolic repair based on the JVTS. We ﬁrst describe an
algorithm to generate candidate repair assumptions from a
JVTS, and then describe the main repair algorithm, which uses
the ﬁrst algorithm as a building block. Finally, we discuss
termination and complexity.
3Alur et al. [ 1] and Cavezza and Alrajeh [ 4] consider weaker formulas for
satisﬁability of their repairs and allow some repairs we consider not useful.
1018
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:39:38 UTC from IEEE Xplore.  Restrictions apply. U	F_J	F_Y
U	F	Y
U	F	Y
Fig. 1. Two JVTSs representing CSs for the running example RG1.
A. Generating Assumptions from a JVTS
Given a JVTS, we generate candidate repair assumptions
based on its cycle nodes, attractor nodes, and edges. We build
the assumptions from the symbolic representation of the JVTS,
with the goal of eliminating the CS (and additional, similar
ones) that the JVTS represents. We present this in Alg. 1.
The ﬁrst loop (lines 1-3) infers justice assumptions from
the cycle nodes of the JVTS by negating the symbolic
representation of the label of the node. The generated justice
assumption eliminates the ability of the environment to violate
the justice of the system represented by the speciﬁc JVTS
cycle node. With the new assumptions, the system can avoid
losing in the scenario of the CS represented by the JVTS by
forcing the environment into the cycle.
Example 2. Fig. 1 (left) shows a JVTS computed for our
running example speciﬁcation RG1 (see Sect. II). The JVTS
has a cycle node in which the justice guarantee just
fails. Negating its label creates the candidate repair justice
assumption φ1:GF( r|( ! c&g )|( c&v ) )
The second loop (lines 4-6) infers safety assumptions from
attractor nodes of the JVTS that have no outgoing edges,
by negating the symbolic representation of the label of the
node. The system can avoid losing by forcing the environment
into such attractor nodes. We ignore attractor nodes thathave outgoing edges because they must produce strongerassumptions than the ones generated next from outgoingedges in lines 7-9, and stronger assumptions are removed
byremoveStrong in line 10 (see bellow).
Example 3. The JVTS in Fig 1 (left) has an attractor without
outgoing edges. Negating its label creates the candidate repair
safety assumption φ2:G( r|! c|! v)
The third loop (lines 7-9) infers safety assumptions from
each edge (v1,v2)of the JVTS. These assumptions prevent the
transition from node v1tov2by negating the conjunction of the
symbolic representation of v1with the primed representation of
v2, i.e., the equivalent assertion on successor states, that has the
system variables quantiﬁed out using existential quantiﬁcation.
The system can avoid the CS by forcing the environment
into node v1, and choosing an action that would make the
environment respond by trying to enter into node v2. Note that
bothv1andv2can be either cycle or attractor nodes.
Example 4. The JVTS in Fig 1 (left) has an edge from the
cycle node to the attractor . This results in the generation ofAlgorithm 1 InferAssumptionsFromJVTS infers candidate repair
assumptions from a given JVTS.
Require: A JVTS/angbracketleftQ,T,I,L/angbracketright
Ensure: A set of GR(1) assumptions, each of which eliminate the CS
1:foreach cycle node v∈Qdo
2: add{GF¬L(v)}toCand
3:end for
4:foreach attractor node v∈Qsuch that ∀v/prime∈Q:¬T(v,v/prime)do
5: add{G¬L(v)}toCand
6:end for
7:foreach two nodes v1,v2∈Qsuch that T(v1,v2)do
8: add{G¬(L(v1)∧prime(L (v2)|∃Y)}toCand
9:end for
10: return removeStrong(Cand )
the candidate repair transition assumption φ3:
G(r | (!c & g) | (c & v) | !next(c) | next(r))
Finally, to avoid redundancy, we return only the weaker
assumptions in the set Cand . Speciﬁcally, the method
removeStrong eliminates an assumption from the set iff it
implies one of the other assumptions in the set. Since we onlyhave justice and safety assumptions, assumption
asm 1implies
assumption asm 2when the propositional formula of asm 1
implies that of asm 2, and either both asm 1andasm 2are of
the same type, or asm 1is a safety assumption and asm 2is a
justice assumption.
Note that by construction, all the generated candidate repair
assumptions are safety or justice assumptions, and in the safety
assumptions for transitions, only environment variables areprimed (since the system variables of
v2are quantiﬁed out).
Thus, importantly, the candidate repair assumptions we generate
respect the restricted structure of individual assumptions in a
GR(1) speciﬁcation.
B. The JVTS-Repair Algorithm
The assumptions inferred from a single JVTS are typically
not enough to ensure realizability, since they only ensure
the elimination of a single CS. On the other hand, adding
assumptions may render a satisﬁable speciﬁcation γ-unsat.
Algorithm 2 uses the algorithm InferAssumptions-
FromJVTS depicted in Alg. 1 for repair generation. It is a
breadth ﬁrst search on assumptions generated from JVTS CSs.
For a given unrealizable and γ-sat speciﬁcation, it searches
for a set of assumptions that makes the speciﬁcation realizable
while keeping it γ-sat, by adding assumption as long as the
speciﬁcation remains unrealizable and γ-sat.
queue is a queue of sets of assumptions, which represent
repair candidates. We begin by inserting an empty set tothe queue. While
queue is not empty, we remove a repair
candidate from it, and add the candidate to the speciﬁcation. If
the reﬁned speciﬁcation is γ-sat and realizable, the candidate
is a repair, thus it is returned, and the search ends. If the
reﬁned speciﬁcation is γ-sat and not realizable, we generate a
JVTS for the reﬁned speciﬁcation, generate assumptions from
it using InferAssumptionsFromJVTS , and add the unions of
the candidate with each of them to queue.
1019
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:39:38 UTC from IEEE Xplore.  Restrictions apply. Algorithm 2 JVTS-Repair computes a repair, or fails.
Require: An unrealizable and γ-satGR(1)speciﬁcation S
Ensure: GR(1)assumptions that make Srealizable and γ-sat, if found
1:queue.enqueue (∅)
2:whilequeue is not empty do
3:candidate ←queue.dequeue
4:refined ←addAssumptions (S,candidate )
5: if isSatisﬁable( refined ) then
6: if isRealizable( refined ) then
7: returncandidate
8: else
9: JVTS←computeJVTS (refined )
10: assumptions ←InferAssumptionsFromJVTS (JVTS )
11: forasm∈assumptions do
12: queue.enqueue (candidate ∪{asm})
13: end for
14: end if
15: end if
16: end while
As adding assumptions to a γ-unsat speciﬁcation cannot
make itγ-sat, we avoid these search paths. Thus, we never
return repair candidates that make the speciﬁcation γ-unsat.
Example 5. When we run JVTS-Repair on ourγ-sat and
unrealizable example speciﬁcation in Lst. 1, it ﬁrst creates
the left hand JVTS in Fig 1. From this JVTS, it generates the
three assumptions φ1,φ2,φ3. With any of these assumptions
the speciﬁcation remains unrealizable and γ-sat.
The search continues and generates repairs in different ways.
F or example, after adding the assumption φ2, Alg. 2 (line 9)
generates the right hand JVTS in Fig 1. From the attractor
at the bottom of this JVTS, it generates the assumption φ4:
G( ! r|! c|! v ) . The set{φ2,φ4}is a valid repair , thus
Alg. 2 returns both assumptions to the engineer .
C. Termination, Complexity, and Soundness
Algorithm 2 always terminates. The while loop in line 2
must terminate, because queue elements increase in the number
of assumptions they contain, each additional assumption causes
the reﬁned speciﬁcation in line 4 to be semantically different
from the speciﬁcation without it (because it eliminates at least
one CS that existed before the assumption was introduced),
and there is a ﬁnite number of speciﬁcations for a given set of
variables. This forms a bound on the size of queue elements,
double exponential in the number of variables (as common
to all CS-based repair approaches [ 4]), and for each size of
queue elements there is only a ﬁnite number of such elements
because the number of assumptions inferred from a JVTS (line
10) is always ﬁnite. The computation time for each iteration is
composed from a γ-sat check, a realizability check, a JVTS
computation, and a call to InferAssumptionsFromJVTS . All
these computations are done symbolically. We performed γ-sat
and realizability checks via ﬁxed-point algorithms, polynomial
in the number of assumptions, guarantees, and state space [ 3].
Note in particular that the computation of a JVTS does not
require the costly computation of a concrete CS. The JVTS is
usually very small, as the number of its cycle nodes is bounded
by the number of justice guarantees, and there are at most two
attractor nodes per cycle node. Accordingly, the time and spaceAlgorithm 3 GLASS computes a repair.
Require: An unrealizable and γ-satGR(1)speciﬁcation S
Ensure: GR(1)assumptions that make Srealizable and γ-sat
1:collSat ← collWinStates( G(ρe∧ρs)∧(/logicalandtext
i∈1..nGFJe
i∧/logicalandtext
j∈1..mGFJs
j))
2:badEnvTrans ←collSat∧ρe∧(ρs⇒¬prime (collSat ))|∀Y/prime
3:ρ/prime←G¬badEnvTrans
4:if isRealizable( addAssumptions( S,{ρ/prime}) ) then
5: return{ρ/prime}
6:end if
7:forJs
j∈Jsdo
8:J←envWinStates( F((Hρe)∧¬ρs)∨/logicalandtext
i∈1..nGFJe
i∧G¬Js
j)
9: addGF¬JtoJ/primeunlessJ=F
10: end for
11: if isRealizable( addAssumptions( S,{ρ/prime,J/prime}) ) then
12: return{ρ/prime}∪J/prime
13: end if
14:win←sysWinStates( addAssumptions( S,{ρ/prime,J/prime}))
15:θ/prime←(θe∧θs∧win)|∃Y
16: return{θ/prime,ρ/prime}∪J/prime
needed for its computation are usually signiﬁcantly lower than
those of concrete CSs [21].
The JVTS based repair is sound (see check in Alg. 2, l. 6)
but incomplete; it does not guarantee that a repair would be
found. We evaluate its performance in Sect. VIII.
VI. GLASS R EPAIR
We now present our second main contribution, namely a sym-
bolic global assumption ( GLASS ) repair that computes repairs
in a “global” way, considering all causes of unrealizability,
instead of a “local” way, considering the causes exhibited
by a CS. GLASS addresses reasons for unrealizability on the
levels of safety guarantees, justice guarantees, and initial states,
by computing respective assumptions that ensure realizability.
GLASS is sound and complete, i.e., it computes a repair for all
γ-sat speciﬁcations. In addition, GLASS does not suffer from
the double exponential complexity of CS-based approaches
(see Sect. V-C and [4]).
A. Algorithm
Algorithm 3 symbolically computes up to three kinds of
assumptions (in this order): a safety assumption ρ/prime, a setJ/primeof
up to|Js|justice assumptions, and an initial assumption θ/prime.
First, Alg. 3 symbolically computes all states collSat from
which the system and environment player can collaboratively
satisfy all safety and justice assumptions and guarantees.
Then, it computes all transitions badEnvTrans that start from
collSat and are legal for the environment ( ρe) but force all
legal system choices ( ρe) to leave the states collSat . The
removal of these bad environment transitions is the safety
assumption ρ/prime. This part is a symbolic version of safety
assumption computation from [ 6], adapted for satisfying all
assumptions and guarantees.
Example 6. No safety assumption is necessary for the speciﬁ-
cation in Lst. 1 ( collSat is the set of all states and ρ/primein l. 3
introduces no restriction). Consider adding the guarantee G(r
->next (v)) , which contradicts guarantee exclude when
the system grants and the environment cancels in the next step.
1020
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:39:38 UTC from IEEE Xplore.  Restrictions apply. Now, Alg. 3 would generate the assumption G(g -> ((c
&v )| next (!c))) , which prevents a cancel in the next
step after a guarantee.
If the assumption ρ/primedoes not make the speciﬁcation
realizable, Alg. 3 computes for every justice guarantee Js
j
the states Jfrom which the environment can prevent Js
jwhile
satisfying all justice assumptions. The negations of these states
are the justice assumptions J/prime. The new justice assumptions
inJ/primeforce the environment to always eventually leave the
states where each Js
jcan be prevented. Technically, the LTL
formula in Alg. 3, l. 8 is a sub-formula of the negation of ϕsr
evaluated inside algorithms for computing GR(1) CS. Also,
the setJcontains all states from leaf cycle-nodes in a JVTS.
Example 7. Algorithm 3 computes the justice assump-
tionGF((!c - >g&v )&( c- >v ) ) . This assump-
tion alone is a repair for the speciﬁcation from Lst. 1.
Finally, if the assumptions ρ/primeandJ/primeare not enough to make
the speciﬁcation realizable, Alg. 3, l. 15 restricts the initial
environment states to θ/primewhere a legal system choice exists to
reach a system winning state, i.e., a state to realize the repaired
speciﬁcation. All computed assumptions are in GR(1).
Example 8. No initial assumption is necessary for the speciﬁ-
cation in Lst. 1. Consider adding the initial guarantee v.I n
this case, Alg. 3 computes the initial assumption !c to avoid
violating guarantee exclude in the initial state.
B. Soundness, Completeness, and Minimality
Algorithm 3 is sound and complete as stated in Thm. 1.
Theorem 1. Given an unrealizable and γ-satGR(1) speci-
ﬁcationS, Alg. 3 computes a repair that keeps Sγ-sat and
makes it realizable.
Proof. The proof shows that each section of Alg. 3 allows the
system to realize safety, justice, and initial guarantees respec-
tively, and that each new assumption preserves γ-satisﬁability.
See supporting materials for details of the proof [37].
The time complexity of Alg. 3 is the same as checking
GR(1) realizability [ 3]: the evaluations of LTL formulas in l. 1
and l. 8 require at most three nested ﬁxed-point iterations with
at most 2|X∪Y|steps, each.
Although the assumptions θ/prime,ρ/prime, and each J∈J/prime, are mini-
mal (see supporting materials [ 37]), already the combination
of someJ∈J/primemight not be minimal, as these sets of states
might not be independent. Importantly, minimality for the
assumptions of GLASS is deﬁned with respect to realizability
from all possible states, whereas minimality for repairs can
also be seen in a “local” way as minimal assumptions that
allow for realizability from at least one state (see Sect. VII-A
and weakness measures in Sect. IX).
VII. I MPORTANT EXTENSIONS AND VARIANTS
A. Repair Core
Both JVTS-Repair andGLASS may yield repairs that
are not minimal in terms of the set of assumptions requiredfor realizability, i.e., where the set of suggested assumptions
includes a strict subset that is already a repair. In general, we
would like to reduce the number of assumptions consisting the
suggested repair, if possible.4
Example 9. As an example, for the speciﬁcation from Sect. II,
the JVTS-based repair suggested the repair consisting on the
set of assumptions {φ1,ψ2,ψ3}whereψ2is:
G(!next(r) | ((r | !c | v) & (! r|c| g)))
andψ3is:GF( ( c|g )&( ! c|v ) ) , which it ob-
tained by ﬁrst taking the justice assumption φ1at level 1
of the search (see Example 2), and then taking assumptions
ψ2andψ3at levels 2 and 3 of the search respectively.
To try to reduce the number of assumptions in the repair,
we apply the delta debugging algorithm DDMin [ 36]t o
heuristically compute what we call a repair core , a locally
minimal subset of the assumptions in the suggested repair
that sufﬁces to make the speciﬁcation realizable. This involves
multiple calls to check realizability, each with a different subset
of additional assumptions. The correctness of applying delta
debugging relies on the following monotonicity: adding an
assumption to a realizable speciﬁcation preserves realizability.
Example 10. Back to our last example above, when we apply
DDMin to {φ1,ψ2,ψ3}we ﬁnd that the subset of assumptions
{ψ3}is a repair core: it is sufﬁcient for realizability, and any
strict subset of it (in this case, no assumption at all) will not
make the speciﬁcation realizable.
Finally, although given the suggested repair, some as-
sumptions that appear already in the original speciﬁcation
may become unnecessary for realizability, we choose not to
remove any assumptions but only to suggest new ones to
add. Suggesting to remove such redundant assumptions is
independent of the repair problem.
In Sect. VIII, as part of our evaluation, we report empirical
results on the effectiveness of using the repair core to reduce
the size of the repairs we found.
B. Dealing with Auxiliary V ariables
Some reactive synthesis tools allow writing speciﬁcations
that are not pure GR(1), yet reducible to GR(1) speciﬁcations,
e.g., ones that use LTL speciﬁcation patterns [ 24]. In this case,
the translation to GR(1) may introduce auxiliary variables,
which were not explicitly declared in the original speciﬁcation.
Though technically, one could use assumptions that include
auxiliary variables in a repair, such assumptions may not
be desirable because the auxiliary variables do not explicitly
appear in the original speciﬁcation and thus are unknown to
the engineer who wrote it. To ensure that we do not generate
assumptions with auxiliary variables, we quantify them out
from all symbolic representations.
4Note that we consider a syntactic notion of minimality here, related to the
number of assumptions in the repair, not a semantic one based on implication
or weakness (see related work discussion in Sect. IX.)
1021
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:39:38 UTC from IEEE Xplore.  Restrictions apply. This quantiﬁcation is performed as follows. In the JVTS-
based repair we existentially quantify auxiliary variables from
all node labels before they are used. In GLASS , we existentially
quantify auxiliary variables from any suggested assumption
when adding it to the speciﬁcation.
It is important to note that when auxiliary variables are
quantiﬁed out, some solutions may be lost. This means
in particular that in this case, the completeness results in
Sect. VI-B will not hold. However, the correctness of repairs
that are found is not affected in this case, i.e., GLASS remains
sound. In Sect. VIII, as part of our evaluation, we report
empirical results on the effect of quantifying out the auxiliary
variables on the ability of GLASS to suggest a repair.
VIII. E V ALUATION
We have implemented JVTS-Repair andGLASS in
Spectra Tools [ 33], based on CUDD [ 32] as a BDD library.
Our implementation includes also the computation of concrete
CS based on [ 18], [27], the computation of the JVTS based
on [21], an implementation of the approach by Alur et al. [ 1],
and the extensions described in Sect. VII.
Means to run our implementation, all speciﬁcations used in
our evaluation, and all data we report on below, are available
in supporting materials for inspection and reproduction [ 37].
We encourage the interested reader to try them out.
We consider the following two research questions. How do
JVTS-Repair andGLASS perform and compare to previous
repair work in terms of
R1. . . the ability to repair?
R2. . . (a) computation time and (b) scalability?
Below we report on the experiments we have conducted
in order to answer the above questions, and on additional
observations from the results of these experiments.
A. Corpus of Speciﬁcations
Previous works on repairing unrealizable GR(1) speciﬁca-
tions have only used a handful of benchmark speciﬁcations for
evaluation, from which we used the following in our evaluation:
the request-grant speciﬁcation we used as a running example,
RG1, taken from [ 1], [23]; a similar smaller request-grant
speciﬁcation, RG2, taken from [ 6]; and the lift speciﬁcation
LIFT used in [ 1], [4]. We further used 3 different sizes of
AMBA (1 to 3 masters), each in the 3 variants of unrealizability
described in [ 7] (with a justice assumption removed, with a
justice guarantee added, and with a safety guarantee added), i.e.,
a total of 9 AMBA speciﬁcations we label AMBA-CIMATTI .
We have used all these in our evaluation.
On top of these, importantly, we used the benchmark
SYNTECH15 [ 12], which includes a total of 78 speciﬁcations
of 6 autonomous Lego robots, written by 3rd year undergraduate
computer science students in a project class taught by the
authors of [ 12]. Out of the 78 speciﬁcations in SYNTECH15,
17 are unrealizable, but 2 of the 17 are γ-unsat (and thus
cannot be repaired by adding assumptions). Therefore below
we report on the remaining 15 speciﬁcations. We label them
SYNTECH15-UNREAL .From the 61 realizable speciﬁcations of SYNTECH15, we
produced unrealizable speciﬁcations as follows. For each
speciﬁcation, we ﬁrst found a core of the assumptions that
maintains realizability [ 7]. Recall that removing any assumption
from the core makes the speciﬁcation unrealizable. From each
speciﬁcation with a core of nassumptions, we created n
unrealizable variants, each of which missing one of the core
assumptions. Some speciﬁcations had an empty assumption
core and thus produced no unrealizable variants. In this way,
we produced a total of 144 unrealizable speciﬁcations. Out of
these 144 speciﬁcations, 8 were γ-unsat because the original
speciﬁcation was not γ-sat, leaving 136 unrealizable repairable
speciﬁcations. We label them SYNTECH15-1UNREAL .
B. V alidation
We have systematically and automatically validated the cor-
rectness of our implementation by actually adding the computed
additional assumptions to the unrealizable speciﬁcations they
are supposed to repair, and by independently checking that the
repaired speciﬁcation is indeed satisﬁable and realizable, for
all the speciﬁcations mentioned in this paper. This validation
includes not only our two symbolic repair techniques but also
our implementation of the algorithm of Alur et al. [1].
The validation increases our conﬁdence in the correctness
of our ideas and their implementation.
C. Experiments Setup
In all cases, we run the three algorithms, AMT13 (our
implementation of the algorithm in [ 1])5,JVTS-Repair , and
GLASS , until termination or timeout, regardless of repairs
found or not.
Using AMT13 requires setting several parameters (see Alur
et al. [ 1]). Since we run until termination or timeout, we
ignored the αparameter. We chose the βparameter according
to the heuristic suggested in [ 1]. The algorithm also requires
the engineer to choose environment variables that appear in
repairs; we always chose all of them.
Using JVTS-Repair andGLASS requires a decision
regarding auxiliary variables. We chose to quantify them out,
taking the risk of loosing some solutions (see Sect. VII-B).
We run all experiments on an ordinary PC, Intel Xeon W-
2133 CPU 3.6GHz, 32GB RAM with Windows 10 64-bit OS,
Java 8 64Bit, and CUDD 3 compiled for 64Bit, using only
a single core of the CPU. We measured the running time to
ﬁnding ﬁrst repair. We excluded the ﬁrst check of satisﬁability
and unrealizability from the measurements (as they are common
and necessary in all approaches).
We used a ﬁxed timeout of 10 minutes. We mark timeouts
byTO. Times we report are average values of 10 runs per
speciﬁcation per algorithm, measured by Java in milliseconds.
Even though the algorithms we deal with are deterministic, we
performed 10 runs since JVM garbage collection and BDD
dynamic-reordering add variance to running times.6
5Note, we count repairs by AMT13 although they might not be γ-sat.
6Since BDD-based implementations’ performance is sensitive to variable
order, we note that in all our experiments we used CUDD’s automatic variable
reordering. This is common practice in the literature.
1022
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:39:38 UTC from IEEE Xplore.  Restrictions apply. ϭϱ
ϳ
ϯ
ϬϮϰϲϴϭϬϭϮϭϰϭϲ
'>^^ :sd^ͲZĞƉĂŝƌ DdϭϯηZĞƉĂŝƌĞĚ^zEd,ϭϱͲhEZ>
ϭϭϭ
ϲϭ
ϮϮ
ϬϮϬϰϬϲϬϴϬϭϬϬϭϮϬ
'>^^ :sd^ͲZĞƉĂŝƌ DdϭϯηZĞƉĂŝƌĞĚ^zEd,ϭϱͲϭhEZ>
Fig. 2. Total numbers of repaired speciﬁcations per algorithm, from
SYNTECH15-UNREAL (left) and SYNTECH15-1UNREAL (right).
ϬϮϬϰϬϲϬϴϬϭϬϬϭϮϬϭϰϬϭϲϬ
'>^^ :sd^ͲZĞƉĂŝƌ Ddϭϯη^ƉĞĐŝĨŝĐĂƚŝŽŶƐ
фϬ͘ϭƐ Ϭ͘ϭƐͲϭƐ ϭƐͲϭϬƐ ϭϬƐͲϭϬϬƐ хϭϬϬƐ hŶƌĞƉĂŝƌĞĚ
Fig. 3. Computation time to suggesting ﬁrst repair, per algorithm, for all
SYNTECH15-UNREAL and SYNTECH15-1UNREAL speciﬁcations, broken
down into ranges.
D. Results: Ability to Repair
Figure 2 presents the results on SYNTECH15-UNREAL and
SYNTECH15-1UNREAL . For each of the three algorithms, we
show the number of speciﬁcations for which at least one repair
was found.
The results show that GLASS is able to repair al-
most all speciﬁcations in SYNTECH15-UNREAL and
SYNTECH15-1UNREAL . The cases where it fails to suggest
a repair are due only to the introduction of auxiliary variables.
We veriﬁed that GLASS always ﬁnds a repair when auxiliary
variables are not quantiﬁed out. Regarding the two other
algorithms, we observe that JVTS-Repair is able to repair
more speciﬁcations than AMT13 .
For the AMBA-CIMATTI speciﬁcations, GLASS repaired
all, but JVTS-Repair andAMT13 repaired none. For all
other speciﬁcations, RG1,RG2, andLIFT , all three algorithms
found a repair.
To answer R1: GLASS repairs all SYNTECH15-UNREAL
and over 80% of SYNTECH15-1UNREAL .JVTS-Repair
repairs 45% while AMT13 repairs only 17% of the above
speciﬁcations. Similar observations hold for the other speci-
ﬁcations in the corpus.
E. Results: Computation Time and Scalability
Figure 3 shows the computation time of all
SYNTECH15-UNREAL and SYNTECH15-1UNREAL
speciﬁcations broken down into several ranges: up to 0.1
seconds, 1 second, 10 seconds, 100 seconds, more than 100
seconds before timeout, and unrepaired either because the
search terminated with no repair or because timeout wasTABLE I
COMPUTATION TIMES TO FIRST REPAIR IN MS ,PER ALGORITHM ,
FOR SELECTED SPECIFICATIONS WITH GROWING NUMBER OF
ADDITIONAL SYSTEM AND ENVIRONMENT V ARIABLES
Speciﬁcation #varsAdded Environment Variables Added System Variables
GLASS JVTS AMT13 GLASS JVTS AMT13
RG1 (Paper example)0 13 78 153 13 78 153
+1 12 955 6110 15 65 TO
+2 15 TO TO 10 68 TO
+3 7 TO TO 12 70 TO
+4 9 TO TO 7 70 TO
+5 6 TO TO 1 62 TO
Lift0 12 53 26 12 53 26
+1 12 89 50 12 59 24
+2 10 975 203 9 57 39
+3 14 125451 193564 9 59 370
+4 10 TO TO 12 54 TO
+5 12 TO TO 10 53 TO
HumanoidL TL4580 6 20 148 6 20 148
+1 4 21 249 8 19 348
+2 10 29 426 7 20 1071
+3 9 42 775 12 20 3475
+4 6 59 1558 6 23 11574
+5 4 90 2900 6 21 47233
Gyro Var17100 7 93 142 7 93 142
+1 9 157 630 7 89 TO
+2 9 3931 31777 12 99 TO
+3 10 TO TO 6 85 TO
+4 6 TO TO 10 94 TO
+5 7 TO TO 6 84 TO
reached. Evidently, GLASS repairs most of the speciﬁcations
very quickly, while JVTS-Repair does less well, which is
still signiﬁcantly better than the AMT13 algorithm, both in the
number of speciﬁcations repaired and in the computation time.
To examine scalability, we conducted the following experi-
ment. Given a speciﬁcation, we created 5 additional variants
with 1 to 5 additional Boolean system variables, and 5
additional variants with 1 to 5 additional Boolean environment
variables. We did not constrain the additional variables in any
way. This results in an exponential inﬂation of the state space,
while having no effect on the unrealizability and the correctness
of suggested repairs. We measured the time required to ﬁnd
the ﬁrst repair.
Table I shows the running times, for RG1,Lift , and two
SYNTECH15-UNREAL speciﬁcations HumanoidLTL_458
andGyro_Var1_710 , and their variants. The lines in the
table with a zero value for number of added variables refer to
the original speciﬁcation.
The results show that the GLASS repair computation time
is almost unchanged. Similarly, JVTS-Repair computation
time is almost oblivious to additional system variables, but in
most cases goes up rather fast with the addition of environment
variables. Finally, they show that the computation time of
AMT13 , which is based on a concrete CS, scales rather poorly
with the addition of either system or environment variables.
Finally, we performed another experiment for scalability
using speciﬁcations we call GFcomplete n. These speciﬁca-
tions have an integer variable kval in the range 1..n, andn
guarantees of the form GF kval=i , for 1≤i≤n. The state
space in these speciﬁcations grows linearly in nrather than
exponentially.
Figure 4 shows computation time to ﬁrst repair (log scale)
ofGFcomplete nspeciﬁcations for 2≤n≤9. Both GLASS
andJVTS-Repair scale well while AMT13 grows quickly,
1023
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:39:38 UTC from IEEE Xplore.  Restrictions apply. ϭϭϬϭϬϬϭϬϬϬϭϬϬϬϬϭϬϬϬϬϬϭϬϬϬϬϬϬ
'&Ϯ '&ϯ '&ϰ '&ϱ '&ϲ '&ϳ '&ϴ '&ϵŵŝůůŝƐĞĐŽŶĚƐ
'>^^ :sd^ͲZĞƉĂŝƌ Ddϭϯ
Fig. 4. Computation times to ﬁrst repair for instances of the GFcomplete n
speciﬁcations. Note that the graph is in logarithmic scale. Missing graph points
forAMT13 are due to the algorithm reaching the timeout.
and fails to ﬁnd a repair within the timeout for the last two
speciﬁcations.
To answer R2: GLASS is able to repair almost all speciﬁ-
cations within 1s. JVTS-Repair andAMT13 are slower.
GLASS scales well and seems to be indifferent to additional
variables. JVTS-Repair scales well only for additional
system variables. AMT13 does not scale well.
F . Results: Additional Observations
Number of variables. In general, one may prefer repairs that
are simpler to understand. As a proxy for simplicity, we report
the number of variables in the repairs we found. We consider
repairs for which all assumptions have up to 5 variables to be
small . We count a variable vif it appears in an assumption.
The algorithms differ signiﬁcantly in this regard. GLASS has
small repairs only for 47% (of 136 repaired speciﬁcations),
JVTS-Repair has small repairs for 57% (of 71), and AMT13
has small repairs for all (of 28) corpus speciﬁcations it repairs.
Effectiveness of repair core. We found that the repair core
(see Sect. VII-A ) is effective in reducing the size of the repairs.
ForGLASS , the repair core is strictly smaller than the initially
suggested repair for 68% of the repaired speciﬁcations. For
JVTS-Repair , the repair core is strictly smaller than the
initially suggested repair for 53% of the repaired speciﬁcations.
Interestingly, without repair core computation, GLASS offered
small repairs only for 25% of the repaired speciﬁcations (as
opposed to 47% reported above), while for JVTS-Repair ,
the difference is insigniﬁcant.
Additional observations appear in [37].
G. Threats to V alidity
We brieﬂy discuss threats to the validity of our results.
Internal. The symbolic computations are not trivial and our
implementation may have bugs. To mitigate this, we performed
a thorough validation using all speciﬁcations available to us,
see Sect. VIII-B.External. First, one of the main threats is the ﬁt of the
generated assumptions to the real world. Note that this threat
equally applies to the previous solutions by Alur et al. and by
Cavezza and Alrajeh [1], [4].
Second, we did not perform a user-study, with engineers, to
examine whether users will ﬁnd the repairs useful, understand
their meaning, and indeed add them to their speciﬁcations.
Third, we have based most of our evaluation on speciﬁcations
from the SYNTECH15 set [ 12], which were created by 3rd
year undergraduate computer science students with no prior
experience in writing LTL speciﬁcations. Due to the lack
of other real-world unrealizable speciﬁcation examples, the
speciﬁcations we used were all unrealizable speciﬁcations
available to us, and ones we have systematically created from
the realizable ones. Still, note that the scope of our evaluation
is much larger than that of similar and competing works on
reactive synthesis in general and on repair in particular.
IX. R ELATED WORK
A. Automatic Program Repair
Program repair is an active research area [ 13], with two main
classes of approaches, both of which start with a faulty program
and a test suite that reveals a defect. Generate-and-validate
approaches explore candidate programs in a search space
until a program that passes all tests is found (see, e.g., [ 22],
[15], [17], [34]). Semantics-driven approaches infer program
speciﬁcations, translate the repair problem into constraints, and
use solvers to ﬁnd patches (see, e.g., [ 16], [28], [29], [35]). A
recent TSE survey [ 13] discusses 108 program repair papers,
more than 50 of which published between 2013 and 2016.
Almost all focus on imperative languages such as Java and C.
We are partly inspired by this body of work. However, we
do not deal with repairing imperative programs but rather with
repairing GR(1) speciﬁcations, which are temporal declarative
speciﬁcations for reactive systems. We focus on repair of
unrealizability based on the symbolic generation of new
assumptions. Both our JVTS-based and GLASS techniques can
be viewed as semantics-driven repairs, as they rely on dedicated
symbolic algorithms to solve what can be viewed as a set of
constraints. The iterative nature of the JVTS-based technique
is somewhat similar to a generate-and-validate approach.
B. Repair of GR(1) Speciﬁcations
GR(1) synthesis was introduced in [ 30]. It has since
been used and investigated by many, including, e.g., Kress-
Gazit et al. [ 19], who used GR(1) in robotics; Maoz and
Ringert [ 24], who showed GR(1) synthesis for speciﬁcation
patterns; D’Ippolito et al. [ 8], [9], who used GR(1) to deal
with fallible domains and non-anomalous event-based behavior
models; and Gritzner and Greenyer [ 14], who used scenario-
based GR(1) speciﬁcations to synthesize executable PLC code.
Several tools support GR(1) synthesis [2], [11], [33].
Some works deal with unrealizable GR(1) speciﬁcations
using CSs and cores, but do not consider repair [ 7], [18], [26].
Below we discuss other works that are most closely related to
ours.
1024
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:39:38 UTC from IEEE Xplore.  Restrictions apply. Li et al. [ 23] suggested mining assumptions from concrete
CS of unrealizable GR(1) speciﬁcations. Strengthening the
speciﬁcation with these assumptions may make the speciﬁcation
realizable. Their algorithm enumerates constraints following
three patterns for GR(1) safety and justice assumptions. If the
CS satisﬁes the enumerated constraint, its negation is added
as an assumption that rules out the CS. Li et al. [ 23] also
suggest using traces of correct behaviors, if available, to validate
candidates. The generation of constraints is unguided and each
requires model-checking against an automaton of the CS.
Alur et al. [ 1] proposed another method for semi-automatic
strengthening of assumptions. Again, they analyze a concrete
CS, but their instantiation of template-based candidate as-
sumptions is guided by the CS. The work provides limited
evaluation over three speciﬁcations. In contrast to [ 1] and [ 23],
ourJVTS-Repair uses a symbolic CS representation. We
have re-implemented the approach from [ 1] in order to be able
to compare it to ours. Our evaluation showed that our symbolic
repairs are able to repair many more speciﬁcations that [ 1]
cannot, and that they are typically much faster.
Cavezza and Alrajeh [ 4] proposed the generation of inter-
polants as a means to compute new assumptions. Similar to [ 1],
[23], this work uses a concrete CS. The work provides evalu-
ation over two benchmarks, Lift and AMBA. Unfortunately,
we were unable to compile and run an implementation of this
approach that we can use to directly compare with our symbolic
repairs (as we have done with [ 1]). However, our evaluation
includes a comparison of results against the same benchmark
speciﬁcations reported on in [4] (Lift and AMBA).
Kuvent et al. [ 21] presented the JVTS, a symbolic represen-
tation of CSs for GR(1). The JVTS is computed symbolically,
without the expensive enumeration of concrete states, it is much
smaller and simpler than its corresponding concrete CS, and it
is annotated with invariants that explain how the CS forces the
system to violate the speciﬁcation. Using the JVTS for repair
was suggested as future work in [ 21]. Our JVTS-based repair
follows this suggestion.
Chatterjee et al. [ 6] presented algorithms for computing
minimal assumptions that repair LTL speciﬁcations. The safety
assumption generation of GLASS repair is inspired by their
algorithm, but is adapted for the γ-sat speciﬁcations and is
formulated and implemented symbolically. Unfortunately, ﬁrst,
the computation of minimal liveness assumptions of [ 6]i s
NP-hard, and second, even if provided with these assumptions,
they cannot be expressed in GR(1).
Most recently, Cavezza et al. [ 5] presented a weakness
measure for GR(1) formulas, which is based on the Hausdorff
dimension, a concept that captures the notion of size of the
omega-language satisfying an LTL formula. The measure
provides a means to quantify the quality of a GR(1) spec-
iﬁcation, by measuring how permissive are its assumptions.
As such, it may be useful in evaluating and selecting between
suggested repairs. We leave the evaluation and selection
between suggested repairs of our symbolic repairs, based on
this measure and on other criteria (see Sect. X), to future work.X. C ONCLUSION AND FUTURE WORK
We presented two symbolic repair techniques for unreal-
izable GR(1) speciﬁcations. The ﬁrst algorithm infers new
assumptions based on the recently introduced JVTS. The
second algorithm infers new assumptions directly from the
speciﬁcation. We further extended our work with repair core,
and with support for speciﬁcations that have auxiliary variables.
We implemented our work, validated its correctness, and
evaluated it on benchmarks from the literature, including
151 unrealizable speciﬁcations of autonomous Lego robots
(SYNTECH15 [ 12]). The evaluation shows not only that
our symbolic repairs are able to repair many speciﬁcations
that could not be repaired by previous works, but also that
their computation is signiﬁcantly faster and scales better
against growing number of variables. Both algorithms are
sound. GLASS is also complete but generates a single repair.
JVTS-Repair typically generates many suggested repairs.
We consider the following future research. The fast computa-
tion time allows our JVTS-based repair to effectively generate
many rather than only one candidate repairs. This is a strength
of the JVTS-based approach that is not available in GLASS ,
and creates an opportunity to select between or prioritize the
different candidate repairs based on some criteria. Such criteria
may include semantic criteria (e.g., implication or weakness [ 5])
and other criteria that may affect the readability and usefulness
of the suggested repairs, e.g., size in terms of number of
assumptions and number of variables used in them (arguably,
an engineer will hesitate to use a repair she cannot understand).
Above all, a suggested repair will not be used if it does not
correctly characterize the behavior of the real environment in
which the system should run, and thus the theoretically weakest
or the smallest repairs may not be the best in practice. We leave
this interesting investigation of multiple repairs presentation
and criteria for selection and prioritization to future work.
The work is part of a larger project7on bridging the gap
between the theory and algorithms of reactive synthesis on the
one hand and software engineering practice on the other. As
part of this project, we are building engineer-friendly tools for
writing and understanding temporal speciﬁcations for reactive
synthesis (see, e.g., [24], [25]).
ACKNOWLEDGEMENTS
We thank Yuval Moskovitch and Slava Novgorodov for
implementing the algorithm of [ 1] in our synthesis environment.
This project has received funding from the European Research
Council (ERC) under the European Union’s Horizon 2020
research and innovation programme (grant agreement No
638049, SYNTECH).
7SYNTECH: http://smlab.cs.tau.ac.il/syntech/
1025
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:39:38 UTC from IEEE Xplore.  Restrictions apply. REFERENCES
[1]R. Alur, S. Moarref, and U. Topcu. Counter-strategy guided reﬁnement
of GR(1) temporal logic speciﬁcations. In FMCAD , pages 26–33. IEEE,
2013.
[2]R. Bloem, A. Cimatti, K. Greimel, G. Hofferek, R. K ¨onighofer, M. Roveri,
V . Schuppan, and R. Seeber. RATSY - A new requirements analysis tool
with synthesis. In CA V, volume 6174 of LNCS , pages 425–429. Springer,
2010.
[3]R. Bloem, B. Jobstmann, N. Piterman, A. Pnueli, and Y . Sa’ar. Synthesis
of Reactive(1) Designs. J. Comput. Syst. Sci. , 78(3):911–938, 2012.
[4]D. G. Cavezza and D. Alrajeh. Interpolation-based GR(1) assumptions
reﬁnement. In TACAS , volume 10205 of LNCS , pages 281–297, 2017.
[5]D. G. Cavezza, D. Alrajeh, and A. Gy ¨orgy. A weakness measure for GR(1)
formulae. In FM, volume 10951 of LNCS , pages 110–128. Springer,
2018.
[6]K. Chatterjee, T. A. Henzinger, and B. Jobstmann. Environment
assumptions for synthesis. In F. van Breugel and M. Chechik, editors,
CONCUR 2008 - Concurrency Theory, 19th International Conference,
CONCUR 2008, Toronto, Canada, August 19-22, 2008. Proceedings ,
volume 5201 of LNCS , pages 147–161. Springer, 2008.
[7]A. Cimatti, M. Roveri, V . Schuppan, and A. Tchaltsev. Diagnostic
information for realizability. In VMCAI , volume 4905 of LNCS , pages
52–67. Springer, 2008.
[8]N. D’Ippolito, V . A. Braberman, N. Piterman, and S. Uchitel. Synthesis
of live behaviour models for fallible domains. In ICSE , pages 211–220,
2011.
[9]N. D’Ippolito, V . A. Braberman, N. Piterman, and S. Uchitel. Synthesizing
nonanomalous event-based controllers for liveness goals. ACM Trans.
Softw. Eng. Methodol. , 22(1):9, 2013.
[10] M. B. Dwyer, G. S. Avrunin, and J. C. Corbett. Patterns in property
speciﬁcations for ﬁnite-state veriﬁcation. In ICSE , pages 411–420. ACM,
1999.
[11] R. Ehlers and V . Raman. Slugs: Extensible GR(1) synthesis. In CA V,
volume 9780 of LNCS , pages 333–339. Springer, 2016.
[12] E. Firman, S. Maoz, and J. O. Ringert. Performance heuristics for GR(1)
synthesis and related algorithms. In D. Fisman and S. Jacobs, editors,
Proceedings Sixth Workshop on Synthesis, SYNT@CA V 2017, Heidelberg,
Germany, 22nd July 2017. , volume 260 of EPTCS , pages 62–80, 2017.
[13] L. Gazzola, D. Micucci, and L. Mariani. Automatic software repair: A
survey. IEEE Trans. Software Eng. , 45(1):34–67, 2019.
[14] D. Gritzner and J. Greenyer. Synthesizing executable PLC code for
robots from scenario-based GR(1) speciﬁcations. In M. Seidl and
S. Zschaler, editors, Software Technologies: Applications and F oundations
- STAF 2017 Collocated Workshops, Marburg, Germany, July 17-21,
2017, Revised Selected Papers , volume 10748 of LNCS , pages 247–262.
Springer, 2017.
[15] J. Hua, M. Zhang, K. Wang, and S. Khurshid. Towards practical program
repair with on-demand candidate generation. In ICSE , pages 12–23,
2018.
[23] W. Li, L. Dworkin, and S. A. Seshia. Mining assumptions for synthesis.
In9th IEEE/ACM International Conference on F ormal Methods and
Models for Codesign, MEMOCODE 2011, Cambridge, UK, 11-13 July,
2011 , pages 43–50, 2011.[16] Y . Ke, K. T. Stolee, C. Le Goues, and Y . Brun. Repairing programs with
semantic code search (T). In ASE, pages 295–306, 2015.
[17] D. Kim, J. Nam, J. Song, and S. Kim. Automatic patch generation
learned from human-written patches. In ICSE , pages 802–811, 2013.
[18] R. K ¨onighofer, G. Hofferek, and R. Bloem. Debugging formal
speciﬁcations: a practical approach using model-based diagnosis and
counterstrategies. STTT , 15(5-6):563–583, 2013.
[19] H. Kress-Gazit, G. E. Fainekos, and G. J. Pappas. Temporal-logic-
based reactive mission and motion planning. IEEE Trans. Robotics ,
25(6):1370–1381, 2009.
[20] O. Kupferman. Automata theory and model checking. In E. M. Clarke,
T. A. Henzinger, H. Veith, and R. Bloem, editors, Handbook of Model
Checking. , pages 107–151. Springer, 2018.
[21] A. Kuvent, S. Maoz, and J. O. Ringert. A symbolic justice violations
transition system for unrealizable GR(1) speciﬁcations. In ESEC/FSE ,
pages 362–372, 2017.
[22] C. Le Goues, T. Nguyen, S. Forrest, and W. Weimer. Genprog: A
generic method for automatic software repair. IEEE Trans. Software
Eng., 38(1):54–72, 2012.
[24] S. Maoz and J. O. Ringert. GR(1) synthesis for LTL speciﬁcation patterns.
InESEC/FSE , pages 96–106. ACM, 2015.
[25] S. Maoz and J. O. Ringert. On well-separation of GR(1) speciﬁcations.
InFSE, pages 362–372. ACM, 2016.
[26] S. Maoz and Y . Sa’ar. Counter play-out: executing unrealizable scenario-
based speciﬁcations. In ICSE , pages 242–251, 2013.
[27] S. Maoz and Y . Sa’ar. Two-way traceability and conﬂict debugging
for AspectLTL programs. T. Aspect-Oriented Software Development ,
10:39–72, 2013.
[28] S. Mechtaev, M. Nguyen, Y . Noller, L. Grunske, and A. Roychoudhury.
Semantic program repair using a reference implementation. In ICSE ,
pages 129–139, 2018.
[29] S. Mechtaev, J. Yi, and A. Roychoudhury. Directﬁx: Looking for simple
program repairs. In ICSE , pages 448–458, 2015.
[30] N. Piterman, A. Pnueli, and Y . Sa’ar. Synthesis of reactive(1) designs.
InVMCAI , volume 3855 of LNCS , pages 364–380. Springer, 2006.
[31] A. Pnueli and R. Rosner. On the Synthesis of a Reactive Module. In
POPL , pages 179–190. ACM Press, 1989.
[32] F. Somenzi. CUDD: BDD package, University of Colorado, Boulder.
http://vlsi.colorado.edu/ ˜fabio/CUDD/cudd.pdf.
[33] Spectra Website. http://smlab.cs.tau.ac.il/syntech/spectra/.
[34] Y . Xiong, J. Wang, R. Yan, J. Zhang, S. Han, G. Huang, and L. Zhang.
Precise condition synthesis for program repair. In ICSE , pages 416–426,
2017.
[35] J. Xuan, M. Martinez, F. Demarco, M. Clement, S. R. L. Marcote,
T. Durieux, D. L. Berre, and M. Monperrus. Nopol: Automatic repair
of conditional statement bugs in java programs. IEEE Trans. Software
Eng., 43(1):34–55, 2017.
[36] A. Zeller and R. Hildebrandt. Simplifying and isolating failure-inducing
input. IEEE Trans. Software Eng. , 28(2):183–200, 2002.
[37] Supporting Materials Website. http://smlab.cs.tau.ac.il/syntech/repair/.
1026
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:39:38 UTC from IEEE Xplore.  Restrictions apply. 