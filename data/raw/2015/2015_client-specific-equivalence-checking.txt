Client-Specific Equivalence Checking
Federico Mora
Univ. of Toronto
Toronto, Canada
fmora@cs.toronto.eduYi Li
Univ. of Toronto
Toronto, Canada
liyi@cs.toronto.eduJulia Rubin
Univ. of British Columbia
Vancouver, Canada
mjulia@ece.ubc.caMarsha Chechik
Univ. of Toronto
Toronto, Canada
chechik@cs.toronto.edu
ABSTRACT
Softwareisoftenbuiltbyintegratingcomponentscreatedbydiffer-
entteamsorevendifferentorganizations.Withlittleunderstanding
of changes in dependent components, it is challenging to maintain
correctnessandrobustnessoftheentiresystem.Inthispaper,we
investigate the effect of component changes on the behavior oftheir clients. We observe that changes in a component are often
irrelevanttoaparticularclientandthuscanbeadoptedwithoutanydelaysornegativeeffects.Followingthisobservation,weformulate
the notion of client-specific equivalence checking (CSE) and develop
an automated technique optimized for checking such equivalence.
We evaluate our technique on a set of benchmarks, including those
from the existing literature on equivalence checking, and show its
applicability and effectiveness.
CCS CONCEPTS
•Software and its engineering →Software evolution ;Dy-
namic analysis ;
KEYWORDS
Software change, equivalence checking, symbolic execution
ACM Reference Format:
FedericoMora,YiLi,JuliaRubin,andMarshaChechik.2018.Client-Specific
EquivalenceChecking. In Proceedingsofthe 201833rd ACM/IEEEInterna-
tional Conference on Automated Software Engineering (ASE ’18), Septem-
ber 3–7, 2018, Montpellier, France. ACM, New York, NY, USA, 11pages.
https://doi.org/10.1145/3238147.3238178
1 INTRODUCTION
Software systems are often composed of multiple related but in-
dependently developed components. Specifications of such com-
ponents are usually limited to the description of their APIs. Yet,
even upgrades that do not alter APIs can hinder the stability of de-
pendentcomponents[ 23].Thus,dealingwithcomponentupgrades
becomes a time-consuming task. This paper addresses the problemby investigating the impact of a change to a component (which we
refer to as a “library”) on its downstream consumers (which we
refer to as “clients”).
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ’18, September 3–7, 2018, Montpellier, France
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5937-5/18/09.
https://doi.org/10.1145/3238147.32381781int client1(int x) {
2 if(x>1 0 )
3 return x;
4 else
5 return lib1(x);
6}
(a)client1.1int client2(int x) {
2 if(x>lib2(x))
3 return x;
4 else
5 return lib2(x);
6}
(d)client2.
1int lib1_old(int x) {
2 return x;
3}
(b)lib1_old.1int lib2_old(int x) {
2 return x-1;
3}
(e)lib2_old.
1int lib1_new(int x) {
2 if(x>1 0 )
3 return 9;
4 else
5 return x;
6}
(c)lib1_new.1int lib2_new(int x) {
2 return x;
3}
(f)lib2_new.
Figure 1: Two client-library pairs illustrating CSE.
Several existing techniques such as ModDiff [ 25], RVT [13],
SymDiff [ 17], and Rêve [ 8] can be used for validating behavioral
equivalence between two versions of a program or for identifying
the precise set of changes between them. Yet, these equivalence
checkingtechniquesdonotexploitthe usagepattern ofaparticular
library component within its client. We argue that the equivalence
checking problem becomes more tractable when the usage pattern
isconsidered.Inparticular,reasoningaboutalibraryupdatewith
respecttoitsimpactonan(unmodified)clientenablesustoproduce
a highly efficient and accurate analysis.
Ourpreliminaryanalysisof66real-lifeclientsoffourlargeopen-
sourcelibrariesshowedthat,in71%ofthecases,thebehaviorofthe
clientcomponentiscompletelyunaffectedbyacommittooneofits
libraries(seeSec. 2formoredetails).Toillustrate,Fig. 1showstwo
simplified client-library pairs, namely, client1which depends on
lib1(Figs.1a-c),and client2whichdependson lib2(Figs.1d-f).Each
of the libraries has two versions, “old ” and “new” For simplicity,
weassumethatallvariablestakearbitraryinputvaluesfromthe
unboundedintegerdomain,sotherearenooverflowsorunderflows.
Forbothclient-librarypairs,thechangesin thelibrariesdoaffect
howthelibrariesbehave,butdonotaffecttheclients’functional
behaviors. For instance, even though lib1_new returns different
values for inputs lesser than 10 compared to lib1_old, the behavior
ofclient1remainsexactlythesamebecauseofthewayitcallsthe
library. We say that the two versions of the libraries are equivalent
with respect to this client.
441
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Federico Mora, Yi Li, Julia Rubin, and Marsha Chechik
In this paper, we provide a method for the effective checking of
aspecialcaseofequivalenceproblems:whethertwolibrarycom-
ponentsareequivalentwithrespecttoaparticularclient.Wefor-
malize the notion of Client-Specific Equivalence (CSE) and provide
implementation forefficiently establishingCSE. Morespecifically,
this paper contributes: (1) empirical evidence for the prevalence
of library changes that do not affect individual clients and, con-secutively, for the applicability of our approach in practice; (2) a
genericframeworkforcheckingCSEwithaneffectiveimplemen-
tationbasedonsymbolicexecution,Clever;and(3)anempirical
evaluation of Clever versus state-of-the-art equivalence checking
tools. Clever inherits the pitfalls of symbolic execution and the
current implementation is limited to integer data-types.
The rest of the paperis structured as follows. Sec. 2describes a
preliminarystudyweconductedtoassessthepracticalrelevance
oftheCSEproblem.Sec. 3presentstheoverviewofourapproach
onsimpleexamples.Sec. 4fixesnotationandprovidesnecessary
background. We formally define our client-specific equivalence
checking framework in Sec. 5.I nS ec .6, we describe our implemen-
tationandevaluateitseffectiveness.Relatedworkisdiscussedin
Sec.7.S ec .8outlines possible future directions and concludes.
2 APPLICABILITY STUDY
Inthissection,weassessthepracticalrelevanceoftheCSEproblem
via manualanalysis of 66client-library functionpairs. Wefound
thesepairsbysearchingGitHubforpopularprojectsthatprovide
functionality to other projects (libraries). We then identified sig-
naturepreservingcommitsthatmodifythesemanticsofalibrary
method and checked how these modifications affect the clients.
The library functionscome from popularopen sourceprojects:
Delorean, OpenSSL, Linux, and GMP. The first three projects have
been “starred” on GitHub over 1,000, 4,000 and 44,000 times re-spectively, while GMP, which is not hosted on GitHub, has been
underactivedevelopmentforover25years.Sixoftheclient-library
function pairs are written in Python, and the remaining 60 – in
C.The automatedanalysis ofthe Pythonexamples isdiscussedin
Sec.6.4. Here we briefly describe the libraries and clients.1
Delorean.__init__ (Delorean). TheDelorean.__init__ libraryfunc-
tion receives two parameters: datetypeandtimezone and returns
a Delorean object that provides users with the datetime manip-
ulation functionality. The behavior of the constructor is entirely
defined by the type of arguments it receives. That is, all condition-
alsbranchbasedonthetypeof datetime andtimezone.Thereare
twochangesofinterestforthislibrary( #679596a ,#064bc8d ).Both
changes,which concernthe settingof aninstance variable _tzinfo
(timezone info), occur inside a check for timezone anddatetime
beingNone; the latter change occurs inside an additional check for
timezone being of type tzinfo. We found three client functions and
analyzedthemwithbothlibraryupdates.Allsixpairsareunaffected
bythelibraryupdatesbecausetheycalltheDeloreanconstructor
with values of datetime,o rtimezone that avoid the change.
BN_is_prime_fasttest_ex (OpenSSL). The library BN_is_prime_-
fasttest_ex receivesfourparameters:aninteger a,anintegerflag
do_trial_division, and two structs used for call back procedure and
1Full study details available at https://client-specific-equivalence-checker.github.io/context that are irrelevant to the change. The function aims to
return 1 if ais prime, and 0 otherwise. do_trial_division specifies
whether the function should attempt to divide aby a constant list
of small primes. The change of interest ( #6e64c560 ) fixes a bug in
which the original function considered small primes as composites
because they are evenly divisible by a prime (themselves). After
thecommit,aptlytitled“Smallprimesareprimestoo”,thefunction
checks that a candidate composite is not in the list of small primes.
Wefound10uniqueclientsforthislibrary:fiveofthemcall BN_-
is_prime_fastest_ex withdo_trial_division = 0, avoiding the change.
RSA_check_key (OpenSSL). TheRSA_check_key function takes
inapointertoaRSAkeyanddecidesitsvalidity.RSAkeysarecom-posedoffiveintegerfields:
p,q,n,e,andd.Themodificationthatwe
considered ( #534e5fa ) adds a check that returns 0 (bad key) if any
of these five components are null. We found 27 clients that are un-
affectedbythislibrarychange.24oftheseclientsconstructanRSA
key by calling either PEM_read_RSAPrivateKey, EVP_PKEY_get1_-
RSA,orRSA_generate_key andthen call RSA_check_key withthis
key. According to the documentation, these three helper functions
successfullypopulatetheRSAfieldswithnon-nullvaluesorreturnnull.Additionallytherearethreeclients(
#fbf15c7 )thatattempted
to access the fields before calling RSA_check_key. The change does
notaffecttheseclientsbecausetheywillcauseasegmentationfault
before calling the library in the cases relevant to the change. We
alsofoundfiveclientsthatareaffectedbythischange.Theseclients
receive the RSA key as an input parameter or use an unknown
functiontogenerateit(e.g., parse_pk_file (dudders/crypt_openssl.c),
and then call RSA_check_key.
gcd(Linux). The Linux project’s gcdfunction calculates the great-
est common denominator of two unsigned integer values using the
standard Euclidean algorithm. The original implementation of this
function was vulnerable to division by zero. To circumvent thisissue, an update (
#e968756 ) was made to check that the smaller
of the two input values is not zero. We found 11 clients for this
librarywithintheLinuxprojectitself.Ofthese,threeareunaffected
by the change. These clients either check that the inputs to gcd
are non-zero directly, or use provably strictly positive values. The
remaining eight clients call the gcdfunction with values set by
parameters and so may be affected by the change.
mpf_get_d_2exp (GMP).We also considered the function mpf_-
get_d_2exp. Fora partialcodelisting, seeFig. 2. Thischange affects
thesignof thereturnwhentheinputis negative.Wefoundseven
unique clients, six of which were unaffected by the change. Three
of these six unaffected clients did not use the returned double, one
alwayscalledthelibrarywithpositivevalues,andone,shownin
Fig.3a, changed the sign of the return when necessary. The one
client affected by the change, shown in Fig. 3b, calls a function
that is undefined on negative inputs with the result returned by
mpf_get_d_2exp.
Summary. Table1summarizestheresultsofouranalysis,listing
the overall number of clients of each library that we considered
andthenumberofwhichhavebeenaffectedorunaffectedbythe
corresponding change. For 71% of the cases considered, clients
remain unaffected by the changes to libraries. We thus conclude
that the problem we are trying to address is of practical relevance.
442
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. Client-Specific Equivalence Checking ASE ’18, September 3–7, 2018, Montpellier, France
1 double mpf_get_d_2exp (signed long int *expptr,
2 mpf_srcptr src) {
3 mp_size_t size, abs_size;
4 mp_srcptr ptr;
5 int cnt;
6+ double d;
7
8 size = SIZ(src);
9 if (UNLIKELY (size == 0)) {
10 *expptr = 0;
11 return 0.0;
12 }
1314
ptr = PTR(src);
15 abs_size = ABS(size);
16 count_leading_zeros(cnt, ptr[abs_size - 1]);
17 cnt -= GMP_NAIL_BITS;
18
19 *expptr = EXP(src) * GMP_NUMB_BITS - cnt;
2021
- return mpn_get_d(ptr, abs_size, 0,
22 - -(abs_size * GMP_NUMB_BITS - cnt));
23 + d = mpn_get_d(ptr, abs_size, 0,
24 + -(abs_size * GMP_NUMB_BITS - cnt));
25 + return size >=0?d:- d ;
26 }
Figure 2: Simplified patch #17323from the GMP library.
1double F_mpz_poly_eval_horner_d_2exp (
2 long *exp, F_mpz_poly_t poly, double val) {
3 ...
4 res =mpf_get_d_2exp(exp, output);
5 // work around bug in earlier versions of GMP/MPIR
6 if((mpf_sgn(output) <0)&&(res >= 0.0))
7 res =-res;
8 ...
9}
(a) Client function F_mpz_poly_eval_horner_d_2exp from the FLINT
library [9].
1REAL log_real(REAL x) {
2 double d;
3 double ln_app;
4 signed long int exp;
5
6 d=mpf_get_d_2exp(&exp, x.get_mpf_t());
7 ln_app =(double) exp *log(2.0) +log(d);
8 return ln_app;
9}
(b) Client function log_real from the MPACK library [19].
Figure3:Anupdateandtwosampleclientsofthe mpf_get_-
d_2explibrary function.
3 OVERVIEW
Inthissection,wegiveanoverviewofourapproachfordetermining
equivalences of libraries with respect to a particular client. We use
the examples in Fig. 1to illustrate the approach: these examples
abstract the patterns observed in the applicability study of Sec. 2.
Example 3.1. Fig.1ashows the source code of a client program;
Figs.1band1cshow the two versions of a library on which this
client could depend. The change introduced in the new version
isanif-statementwhichsplitsthesingleprogrampathoftheold
versionintotwo:whentheinputvalueisgreaterthan10andwhen
itisnot.Inthisexample,thebehaviorof lib1_oldandlib1_new isTable 1: Results of the applicability study.
Project Library Function #Clients #Affected #Unaffected
Delorean Delorean() 30 3
Delorean Delorean()[2] 30 3
OpenSSL BN_is_prime_fasttest_ex 10 5 5
OpenSSL RSA_check_key 32 5 27
Linux gcd 11 8 3
GMP mpf_get_d_2exp 71 6
differentforany input x>10:the oldlibrarywill return x,and the
new library will always return a constant 9. Yet, the two library
versions are equivalent in the eyes of client1because the library is
never called with x>10 (Lines 2-4 in Fig. 1a). Thus, the change
inlib1_new is never exercised. In fact, the two library versions are
conditionally equivalent [15] underthe condition x≤10 and both
returnxforanygiveninput x.Sincelib1isonlycalledbytheclient
under sucha condition (Line 5in Fig. 1a),we say that thatlibrary
versions are client-specific equivalent w.r.t.client_1.
Example3.2. Fig.1dshowsanotherclient, client2.Figs. 1eand1f
showtwoversionsofthelibrarythat clientcalls.Theonlychangeto
theoldlibraryversionisthereplacementof“ x−1”by“x”.Although
thetwolibraryversionsareobviouslynotequivalent,thedifference
does not lead to a different client behavior: lib2_oldalways returns
avaluewhichissmallerthantheinput x,leadingclient2intothe
if-branch(Lines2-3inFig. 1d).Astheresult,theinputvalue xis
returned by the client. The new version of the library, lib2_new,
returns the input itself, leading the execution of client2into the
else-branch (Lines 4-5 in Fig. 1d); yet, input value xis returned by
client2in this case as well.
UnlikeExample 3.1,herethechangeinthelibraryisexercised
by the client. Yet the two library versions are still client-specific
equivalent: the change on the library is “digested” by the client so
that the final output is unaffected. The example shown earlier in
Fig.3afalls into the same category.
Client-Specific Equivalence (CSE). In both examples, changes
inthe libraryprogramsdo notaffect thefinalreturn valuesofthe
client.Wecharacterizeclient-specificequivalenceintermsofthe
client’sobservablebehaviors :weignoretheinternalexecutionsteps
and only observe the input and output values of the client. This
definition of equivalence is also referred to as functional equiva-
lence[20].
CheckingCSE. Now,wedescribeourgeneralframeworkfordeter-
miningclient-specificequivalence.Fig. 4overviewsthearchitecture
oftheframework.Theframeworkacceptsasinputaclientandtwo
versions of a library. We assume that library interfaces remain
unchanged since the change can be easily caught by a compiler.
The framework’smain components are a behavior explorer and
anequivalenceverifier.Thebehaviorexploreranalyzesbehaviors
ofthelibrariesintermsofhowtheyareused,andthenitgenerates
equivalence assertions that must be satisfied for the libraries to
be CSE. The equivalence verifier checks the libraries against theequivalence assertions and either declares them to be equivalent
443
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Federico Mora, Yi Li, Julia Rubin, and Marsha Chechik
Client Lib Lib’ Behavior Explorer
Equivalence
VerifierEquivalence
Assertions

Figure 4: Architecture of the client-specific equivalence
checking framework.
or provides a counter-example which demonstrates the behavioral
differences observed in the client.
Incremental Lazy Exploration. Comparing Examples 3.1and
3.2, we identify two types of CSE: (1) inactive CSE – that holds
whenchangesarenotexercisedbytheclientand(2) activeCSE –
thatholdswhenchangesareanticipated,exercised,andspecially
handled by the client. The biggest distinction being that to show
inactiveCSE,onedoesnotneedtoreasonaboutthesemanticsof
thelibraries:apurelysyntacticcheckonallfeasiblelibrarypaths
suffices to confirm that no change gets exercised. On the other
hand,toclaimactiveCSE,oneneedstoanalyzetheinput-output
relations of the libraries and their interplay with the client.
Withthisinsight,weproposeaCSEcheckingapproachcalled
incremental lazy exploration which prioritizes establishing proof
arguments for inactive CSE while keeping the number of paths
explored to a minimum. It helps to eliminate the main source of
inefficiencyofthegenericCSEframeworkdescribedabove:fully
exploringboththeclientandlibraryprogramsbeforegenerating
equivalence assertions based on the explored behaviors.
We call a path containing a call to the library an active path.
Whenever an active path is explored, we effectively obtain a client
contextfor the library call – a condition over client inputs under
whichthepathistaken.Withthiscontext,weperforma parallel
exploration of both library versions under the given context by
shadowing [5] one with the other. This is done by simultaneously
examiningthesamepathsinbothversionswithsymbolicexecu-
tion[16].Thisstepproducesasetoflibrarypathpairs,andforeach
pair, two checks are performed: (1) isthe path exercising changed
(addedandremoved)code?(2)doesaconcretesimulationonthe
pathpairrevealacounterexample?Bothofthesechecksarerela-
tivelycheap:check(2)canimmediatelyrevealacounterexamplefor CSE, and if check (1) fails for all client contexts, then we can
alsoconcludeCSEwithoutreasoningabouttheactualsemanticsof
the paths explored.
InExample 3.1,webeginbyexploringtheclientandskipthefirst
pathwhichdoesnotinvolvelibrarycalls(row1inFig. 5a).Then
weexplorethesecondpath,showninrow2,andperformaparallel
explorationonbothlibrarieswiththeclientcontext ¬(x>10).The
first rows of Figs. 5band5cshow the only pair of library paths ex-
plored.Wethenperformthefirstcheckandrealizethatthechange
isnotactiveonthispath;therefore,uponfinishingthelibraryex-
ploration,wecanconcludethatthelibrariesareequivalentunder
thecurrentclientcontext.Sincenootherclientpathsremain,we
identifythecaseofinactiveCSE.Weevaluatetherelativeefficiency
of incremental lazy exploration in Sec. 6.Partition Effect Explored Active
1x>10RET=x Yes No
2¬(x>10)RET=lib1(x)Yes Yes
(a)client1.
Partition Effect Explored Active
1True RET=xYes No
(b)lib1_old.
Partition Effect Explored Active
1¬(x>10)RET=xYes No
2x>10RET=9No No
(c)lib1_new.
Figure 5: Paths explored for Example 3.1.
4 BACKGROUND
In this section,we provide the necessarybackground on program
analysis that will be used in the remainder of the paper.
Programs. Werestrictthepresentationtoasimpleimperativepro-
gramminglanguagewherealloperationsareeitherassignments,
assumptions or function calls, and all variables range over inte-
gers. We assume that the type and number of input and output
parameters are statically known for each function.
Aprogram P=(Fc,{Fl}i)consistsofaclientandasetoflibrary
functions,suchthattheclientcallsthelibraries.Eachofthefunc-
tions can be represented as a control flow graph (L,l0,lf,E,V),
whereLisafinitesetofprogramlocations,withaninitiallocation
l0∈Land a final location lf∈L. The set Vdenotes a finite set
of variables, and E⊆L× Σ×Lis the set of control-flow edges,
where Σisthesetofoperationsinstantiatedbyoneofthefollow-
ing constructs: (1) an assignment v←exp, wherev∈V; (2) an
assumption of the form assume(b), where bis a Boolean expres-
sionoverprogramvariables V;(3)callstolibraryfunctions,e.g.,
/vecx←F(/vecy), where/vecxand/vecyare vectors of variables in VandFis a
function in {Fl}i.
We write lσ− →l/primeinstead of (l,σ,l/prime)∈Eto denote an edge
fromltol/primeintroducedbyanoperation σ∈Σ.Weassumethatall
executions of Pterminate, but this assumption does not prevent P
from possibly having an infinite number of paths, such as in the
case where there is a loop whose number of iterations depends on
an unbounded variable.
FunctionSummaries. Givenaprogram Pandafunction Fi,the
function summary ofFiis a first-order formula φiover vectors
ofvariables /vecα,/vecβsuchthat /vecαdenotesFi’sinputparametersand /vecβ
denotes its outputs. A function summary is completeif it is defined
for all possible inputs. We write P[φi]to denote the program with
everyfunctioncall /vecx←Fi(/vecy)replacedby assume(φi[/vecx//vecα,/vecy//vecβ]).In
otherwords, P[φi]islikePbutwitheveryfunctioncall Fireplaced
by its function summary.
For example, the function summary for lib1_new in Fig.1cis
φlib1/prime=ITE(X>10,RET=9,RET=X),whereITEistheif-then-
elseoperator, Xistheinputparameter,and RETistheoutput. φlib1/prime
is also complete since it covers both the case when X>10 and
whenX≤10.
444
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. Client-Specific Equivalence Checking ASE ’18, September 3–7, 2018, Montpellier, France
/llbracket·/rrbracket:(V /mapsto→ Z) /mapsto→( V /mapsto→Z)
/llbracketx←exp/rrbracket(v)=v[x/mapsto→/llbracketexp/rrbracketv] assignment
/llbracketassume(b)/rrbracket(v)=/braceleftbiggvifv|=b
⊥otherwiseassume
/llbracket/vecx←F(/vecy)/rrbracket(v)=/llbracketassume(φF[/vecx//vecα,/vecy//vecβ])/rrbracketvfunction call
Figure 6: Semantics of operations.
Concrete,Abstract,andObservableRuns. Weinterpretseman-
ticsofprogramexecutionsusingaLabelledTransitionSystem(LTS),
(S,s0,sf,Σ,→)foreachcontrol-flowgraph,where S=L×(V/mapsto→
Z)isasetofprogramstates,and s0∈Sandsf∈Saretheinitial
andfinalstates,respectively.Let v:V /mapsto→ Zbeavaluationofthe
variables at state s. We write (l,v)σ−→(l/prime,v/prime)to represent the tran-
sitionfromstate stos/primeiflσ− →l/primeand(v,v/prime)∈/llbracketσ/rrbracket(definedinFig. 6).
Aconcrete run π=s0σ0− −→···σk− − →skof an LTS is an execution
path that starts with an initial state. The set of all concrete runs
iswrittenas Π.Anabstractrun isasetofconcreteruns ˆπ={πi}.
Letω:Π/mapsto→Πbeanobservationfunction whichmapsaconcrete
runπto anobservable run ω(π), hiding unobservable states and
operations.
Recallclient1shown in Fig. 1a. With the values of xandRET
writtencompactlyasatuple, (2,(X,/latticetop ) )→(3,(X,X))isanabstract
run which subsumes all concrete runs going through the if-branch
ofclient1(Lines2and3),where /latticetopdenotesanuninitializedvalue.
By hiding the values of x, the observable part of the same runs can
be written as simply (2,/latticetop )→(3,X).
SymbolicExecution. Symbolicexecution [16]usessymbolicvalues
as input, instead of the actual data, and represents the values of
program variables as symbolic expressions. As a result, output
values computed by the program are also represented as symbolic
expressions.The stateofasymbolically-executedprogramincludes
thesymbolicvaluesofprogramvariables,apathconditionanda
program location. The path condition is a boolean formula over
the symbolic inputs corresponding to the accumulated constraints
along the path which are satisfiable if and only if the associatedpath is feasible. A symbolic path corresponds to an abstract runof the program, which can be instantiated to a concrete run by
computing a satisfying model of the path condition.
5 OUR APPROACH
In this section, we first formalize our client-specific equivalencechecking framework and then report on a specific instantiation
which leverages common patterns observed in inactive CSE cases
tospeedupthe checkingprocess.
5.1 The CSE Checking Problem
Problem Definition. LetFcbeaclientprocedure,andlet Fland
F/prime
lbe two versions of a library procedure such that they share
the same signature and can be called interchangeably from Fc. Let
ωbe an observation function which maps a concrete run to an
observable run only considering the input and output values of theclient.Behav(F)denotesthesetofall(concrete)runsofaprocedure
F.
Definition 5.1 (Client-Specific Equivalence). We sayFlandF/prime
lare
client-specificequivalent w.r.t.Fcandω,denotedby Fl≡(Fc,ω)F/prime
l,
if and only if {ω(π)|π∈Behav(Fc[Fl])}and{ω(π/prime)|π/prime∈
Behav(Fc[F/prime
l])}are equal.
Client-specific equivalence of two library versions is defined in
termsoftheobservablebehaviorsoftheclient.Twoconcretepaths
πandπ/primeareequivalentiftheyfollowtheexactsamesequenceof
state transitions. Two procedures FandF/primeare considered equiv-
alent when their sets of concrete runs are equal. We say that the
observablebehaviorsof FandF/primeareequivalentiftheybothhave
the same set of observable runs defined by ω. Finally, two libraries
FlandF/prime
lareclient-specificequivalentwhenthe observablebehav-
iors of the composed programs, Fc[Fl]andFc[F/prime
l], are equivalent.
5.2 Checking Functional CSE
In most cases, there are infinite number of concrete runs and thus
checkingclient-specificequivalencebyenumeratingallrunsofa
client(composedwithbothlibraries)andexplicitlycomparingthem
against each other is often infeasible. We show that it is possible
toreduce theCSEcheckingproblemtothe validityoffirst-order
formulas. We begin by describing a general algorithmic framework
– Clever,2for checking functional CSE using symbolic execution.
Theinputstothealgorithmareaclient, Fc,andtworelatedlibraries
sharing the same interface, FlandFl’.
Behavior Exploration. First, Clever explores behaviors of the
client through symbolic execution without considering the bod-
iesofthelibraries.Itdoessoviastandardpathexplorationwhile
replacing each library call with an uninterpreted function place-
holder. Focusing only on the client program reduces the number
of paths and allows for modular checking of libraries. The abstract
runs returned from symbolic executing the procedure can be repre-sentedasasetof partition-effectpairs [
20],namely, (pci,obi),where
pcirepresents a path constraint andobistands for an observable
effect constraint for a particular path ˆπi. The path constraint is a
conjunctionofrelationalexpressionsdefinedoverconstantsand
inputvariables.Theeffectconstraintisaconjunctionofexpressions
whichequateaspecialreturnvariable“RET ”toexpressionsover
constants and input variables. Representing effects as symbolic
expressionsoverinputvariablesallowsustoreasonaboutmultiple
concrete runs together.
The set of abstract runs returned from exploring a procedure is
itssummary.Summariescanbe incomplete duetothelimitationsin
symbolic execution. For example, with the presence of unbounded
loops, it is only possible to get paths of limited length.
Equivalence Assertion Generation. Letthesummariesfortwo
library versions produced in the previous step be Behav(Fc[Fl])
andBehav(Fc[F/prime
l]). Clever uses them to generate an equivalence
assertionϕ– a first-order formula with uninterpreted functions as
placeholders for the libraries. The formula ϕserves as a mutual
specification [18]forthetwolibraries–theobservablebehaviors
of the client are equivalent if and only if the library bodies respect
2Clever stands for CLient-specific EquiValence checkER.
445
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Federico Mora, Yi Li, Julia Rubin, and Marsha Chechik
theequivalenceassertion.Followingthenotionof logicalmethod
summary [11],theobservablebehaviorsoftheclientinthiscase
can be encoded as a disjunction over all symbolic paths, and the
resulting equivalence assertion is
ϕ:=/parenleftbig /logicalordisplay.1
ˆπi∈Behav(Fc[Fl])(pci∧obi)⇔/logicalordisplay.1
ˆπ/prime
i∈Behav(Fc[F/prime
l])(pc/prime
i∧ob/prime
i)/parenrightbig,
wherepciandobiarepathandeffectconstraintsof ˆπi,respectively.
EquivalenceVerification. Finally,ϕisverifiedagainstthelibrary
implementations FlandF/prime
l. The verification task can be delegated
to a theorem prover based on the procedure summaries of the
libraries.Wefirstgenerateproceduresummariesforbothlibrary
versions.Thesummariesfor FlandF/prime
larethenusedtoconstrainthe
uninterpretedfunctionplaceholdersintheequivalenceassertion
ϕ. Finally, we check the validity of ϕcomposed with the library
summaries. If a violation is found, we report a counterexample;
otherwise, if the generated summaries are complete, we proved
functional CSE.
Proposition5.2. Givencompletesummariesof Fc,FlandF/prime
l,the
equivalenceassertionisvalidifandonlyif FlandF/prime
lareclient-specific
equivalent w.r.t. Fc.
ProofSketch. Sinceallsummariesarecomplete,anyconcreterunof
theclientisamodelofthepathconstraints.FromDef. 5.1,Fland
F/prime
lare CSE since the equality between concrete runs is established
by the logical equivalence between composed summaries.
5.3 Incremental Lazy Exploration
It may not always be possible to compute complete summariesof client and libraries due to limitations of symbolic executiontechniques. We now present an optimized behavior exploration
strategy,incrementallazyexploration,whichprioritizesestablishing
proofargumentsfor inactiveCSE (seeSec.3)anddisprovingCSE
throughearlydiscoveryofcounterexamples.Thisallows ustospeed
uptheCSEcheckingprocessandobtainpartialresultsevenifthe
path exploration of some functions is not exhaustive.
Apseudo-codeimplementationof Cleverwithincrementallazy
exploration is given in Fig. 7and the workflow for this technique –
inFig.8.Theinputstothealgorithm,asbefore,areaclient, Fc,and
two related libraries sharing the same interface, FlandFl’. This
time,however,weareonlyinterestedinexploringandreasoning
about active paths. We call a summary consisting of only active
paths anactive summary.
The while loop on Line 3drives the lazy exploration: its body
is executed until the client is fully explored. Each iteration takes
apartition-effectpair, p,fromthe client’ssummaryandprocesses
the libraries modulo p, resulting in Behavp(Fl)andBehavp(F/prime
l),
respectively.Ifthesesummariesexercisethedifferenceinthelibrary
versions, checked on Line 6, then Clever does two things. First,
itfindsaconcretevaluethatsatisfies pandcheckswhetheritisa
counterexample.Ifaffirmative,Cleverreportsthat FlandFl’ar e
notclient-specificequivalent.Second,Cleverupdatestheactive
summaries. If no active paths have been found after the clienthas been fully explored, Clever reports equivalence. Otherwise,
Cleverusestheactivesummariestogenerateanassertion(Line 14),
and then check it (Line 15).Require: FccallsFlandF/prime
linterchangebly
Ensure: IfFl≡FcF/prime
lthen returns true, else returns false
1:procedure Clever(F c,Fl,F/prime
l)
2:A←Initial ⊿Initialize active summaries of Fc,Fl,Fl’
3:whilep∈Explore(F c[fl(/vecx)])do
4: Behavp(Fl)←Explore(F l(/vecx)|/vecx|=p)
5: Behavp(F/prime
l)←Explore(F/prime
l(/vecx)|/vecx|=p)⊿Summaries mod p
6: ifpuses change then
7: ifconcrete value for pis a counterexample then
8: returnfalse
9: end if
10: A.update(p,Behavp(Fl),Behavp(F/prime
l))
11: end if
12:end while
13:ifEmpty(A)then return true
14:ϕ←AssertGen( A)
15:ifVerify(ϕ,Fl,F/prime
l)then return true
16:else return false
17:end procedure
Figure7:AlgorithmforcheckingCSEbasedonsymbolicex-ecution and lazy path exploration.
Context-Specific
Parallel
Library
Exploration
Is change 
active?
Is concrete 
CEX?YesClientIncremental
Client ExplorationClient 
ContextLib
Lib’
CEXNo
YesNoActive Paths(1)
(2)Empty
Non-emptyInactive
CSE
VERIFY
Figure 8: Clever workflow with incremental lazy explo-ration.
Proposition5.3. Letcompleteactivesummary meanthemax-
imal active subset of a complete summary. Given complete active
summariesof Fc,FlandF/prime
l,the equivalenceassertion isvalid ifand
only ifFlandF/prime
lare client-specific equivalent w.r.t. Fc.
Proof Sketch. Suppose the equivalence assertion defined over com-
plete active summaries is valid and the libraries are not client-
specificequivalent.ByProposition 5.2,thevalidityoftheequiva-
lence assertion implies that the observable part of the active paths
areequal.Hence,theremustexistaninactivepathwhichcannot
bematched.Thiscontradictsthefactthatinactivepathdoesnotgo
through any change and therefore stays the same in both versions.
The other direction is similar.
Finally,ifwefailtodiscovercounterexamplesorfullyexplore
all client paths with limited resources, we are still able to partially
prove or disprove equivalence for the considered client contexts. A
differentequivalencecheckingtechniquecanbeusedinthiscase
to decide equivalence of the remaining explored contexts.
CleverExample. WenowillustrateCleverusingExample 3.2
from Fig. 1. In Example 3.2, the change is always active so we have
to go through both client contexts (Rows 1-2 in Fig. 9a). When
comparing active library paths which exercise changes, we oppor-
tunistically perform concrete simulation where a concrete input
446
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. Client-Specific Equivalence Checking ASE ’18, September 3–7, 2018, Montpellier, France
Partition Effect Explored Active
1x>lib2(x)RET=x Yes Yes
2¬(x>lib2(x))RET=lib2(x)Yes Yes
(a)client2.
Partition Effect Explored Active
1True RET=xYes No
(b)lib2_old.
Partition Effect Explored Active
1¬(x>10)RET=xYes No
2x>10RET=9No No
(c)lib2_new.
Figure 9: Paths explored for Example 3.2.
satisfying the current client context is used to replay on the paths
from both library versions. In this example, we might use x:=0a s
aconcreteinputwhichturnsoutnottobearealcounterexample.
After failing to quickly find a counterexample, we store the active
path for later use and return to search for a new path in the client.
Inthecaseof client2,thenextpaththatwefindisshowninRow
2 of Fig.9a. Having completed the exploration of the client, we
generate anequivalence assertioninvolving onlythe activepaths
collectedsofarandtrytoproveitsvalidity.Thissucceedsandthus
the case for active CSE is identified for client2.
6 EVALUATION
In this section, we describe our implementation of Clever, report
on an empirical evaluation, and present a case-study. We aim to
answer the following research questions: RQ1: how effective is
Clevercomparedtothestate-of-the-artequivalencecheckingtech-
niques for checking CSE? RQ2: how significant is the impact of
incrementallazyexplorationoneffectivenessof Clever? RQ3:can
Clever be effectively applied to real software projects?
6.1 Implementation
Our implementation3of Clever is built on top of PyExZ3 [ 2],
a symbolic execution engine for Python written in Python, and
PySMT[10],aPythoninterfacetoSMTsolvers.Asaconsequenceof
this combination, our tool is currently limited to integer reasoning.
Thefourkeycomponentsofoursoftwarearesummarygeneration,
support for uninterpreted functions, exploration modulo calling
context, and parallel exploration.
Summarygeneration iscrucialtoClever’sequivalenceassertion
generation. This feature symbolically executes programs returning
a set of partition-effect pairs, one for each explored symbolic path.
Supportfor uninterpretedfunctions enablesthetop-downgenera-
tionofsummariesbyallowingclientexplorationirrespectiveofa
particular version of its library.
WhenCleverencountersacalltoalibrary,itusesthearguments
andcurrentpathconditionasacontextwhenexploringthetwover-
sions ofthelibrary. Our explorationmodulo callingcontext feature
collectsand subsequentlyusesthisclientcontext. Finally,the par-
allel exploration feature allows Clever to explore both versions of
thelibrarywhilemonitoringequivalenceanddiscoveringpotential
3Code is available at https://client-specific-equivalence-checker.github.io/counterexamplesearly.Thefeatureisbasedonshadowsymbolic
execution [5] but incorporates summary generation directly.
Finally, we implemented a driver which connects the above fea-
tures, logs execution information, and provides an interface for
running experiments. Our implementation changed 26 files in the
PyExZ3 project, modifying approximately 1,000 lines of code.
PyExZ3wasnottheonlychoiceofsymbolicexecutionengine,
but its focus on extensibility and its combination of existing fea-
tures made it a natural choice. We also considered KLEE [ 4] which
canprocess Cprograms andimplements shadowsymbolic execu-
tion [5]. However, KLEE does not support uninterpreted functions
or summary generation and was not as amenable to the necessary
modifications as PyExZ3.
6.2 Comparison with Existing Tools
In this section, we report the results of comparing Clever with
well-established equivalence checking tools.
ExistingTools. WecomparedClever,withfourstate-of-the-art
toolsinequivalencecheckingandregressionverification:RVT[ 13],
SymDiff [ 17], ModDiff [ 25], and Rêve [ 8]. All of these tools can
beusedtopr o v e partialequivalence oftworelatedprograms,i.e.,
producing the same outputs for all possible inputs given that both
programsterminate.Therefore, technically,they canalso beused
to check functional CSE by considering the client-library pair asa whole. However, since they are not designed for checking CSE
specifically, they would not be able to leverage the fact that the
clients areunmodified andthe particular usagepatterns observed
in the clients. A more detailed discussion of these approaches is
found in Sec. 7.
Subjects and Methods. We evaluated all tools on 60 benchmarks,
witheachbenchmarkconsistingofapairofprogramsbeforeand
aftersomechangesinthelibrary.Weused23benchmarksfromthe
ModDiff suite [ 25] (in C). We excluded six ModDiff benchmarks
that do not perform updates to libraries. Some of the ModDiff
benchmarksareindexed,e.g. loopmult5 isrelatedto loopmult10.W e
augmented the suite with 16 additional benchmarks that continue
theseindexedpatterns.21benchmarksareexamplesextractedfrom
programs that we inspected during the applicability study (in C
or Python) and examples we constructed ourselves (in Python). In
total, 29 pairs were equivalent and 21 – inequivalent.
To run the different tools on the benchmark, we translated all of
theprogramstoC(requiredbyRVT,ModDiff,Rêve),andPython
(required by Clever) manually; and to Boogie [ 3] (required by
SymDiff) with SMACK [22].
WeperformedtheexperimentsonanIntelCorei74.00GHzCPU
with16GBofmemoryrunningWindows10withCygwin.Foreach
benchmark, we set a timeout of 300 seconds.
Results. Table2showstheresultsofcomparingCleverwiththe
other four state-of-the-art equivalence checking tools. The exe-
cution times are measured in seconds and the winner for eachbenchmark is in boldface. Clever solves the biggest number of
benchmarks and outperforms all of the other tools in the majority
ofthecases.ForRêve,manyinstancesthattimeoutonourmachine,usingthedesktopdistribution,terminateinsecondswhenrunusing
447
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Federico Mora, Yi Li, Julia Rubin, and Marsha Chechik
Table 2: Run-time in seconds of Clever, ModDiff, Rêve,
RVT, and SymDiff, where “–” indicates that the tool either
times out or reports inconclusive results and “×” indicatesan error.
Benchmarks Clever ModDiff Rêve RVT SymDiffEquivalentdivide 0.089 ×– 5.870 –
factorial 0.295 ––– –
fib 0.268 ×–– –
get_sign2 0.068 0.032 –– –
is_prime1 0.056 2.980 – – –
is_prime3 1.289 7.910 – – –
ltfive 0.108 0.792 – – –
multiple 0.077 0.070 – – –
order 0.035 0.122 – 5.000 –
pos2 –– – – ×
pos3 0.085 ––– –
oneN2 0.107 0.048 –– –
oneBound 0.089 0.008 – 4.800 –
add 0.063 0.010<1 4.257 8.480
const 0.062 0.024<1 4.118 8.760
loopunreach2 0.061 0.051<1– –
loopunreach5 0.104 0.068<1– –
loopunreach10 0.104 0.067<1– –
loopunreach15 0.110 0.068<1– –
loopunreach20 0.105 0.067<1– –
unchloop 0.065 0.141<1– –Non-Equivalentdivide2 0.100 ×<5
factorial 0.081 0.089 –
fib 0.216 ––
get_sign 0.066 0.047<5
is_prime2 0.116 9.790<5
loopunreach2 0.062 0.117<1
loopunreach5 0.078 0.154<1
loopunreach10 0.078 0.156<1
loopunreach15 0.079 0.156<1
loopunreach20 0.075 0.143<1
odd –– –
pos –– –
oneN1 0.075 ×<5
the online version of the tool. To optimally capture Rêve’s capabili-
ties,wereportcategoricalresultscollectedfromrunningtheonline
version: termination in <1, and<5 seconds, and non-termination
in over 300 seconds or returning unknown (–).
Since RVT and SymDiff are not designed for disproving equiva-
lence,wedidnotincludetheminthecomparisonfornon-equivalent
cases.Similartotheexperimentresultsreportedin[ 25],RVTand
SymDiffonlysolvedfourandtwobenchmarks,respectively.SymD-
iff crashed with an unhandled exception for pos2while ModDiff
reportedanincorrectresultfor divide,fib,divide2,and oneN1(all
markedby“ ×”).Rêveperformswellonnon-equivalentcasesand
struggles on proving equivalence for benchmarks which requirenon-trivial relational invariants, e.g., divide,factorial, ltfive, etc.
Therearealsoafewcases,including pos2,odd,andpos,thatnotool
couldsolvewithinthegiventimelimit.Thereasonwasthatthey
all have an unbounded loop with a non-trivial loop condition.0 1 02 03 04 05 0050100150
#P a t h sTime (s)Clever
ModDiﬀ
Figure10:CleverandModDiffexecutiontimesversusnum-
ber of paths over fifteen client-specific equivalent probleminstances.
Looking at the equivalent cases, Clever performed significantly
betterthantherestofthetoolson divide,is_prime1, pos3,loopmult15
andloopmult20, which demonstrate the benefits of early detection
of inactive CSE. A common trait of these benchmarks is that the
analysisofalong-runningloopinthelibrarycouldbeavoidedif
thetop-down analysis considered the specific range of input values
coming fromthe client.For instance, bothof thelibrary functions
intheloopmult examplesbothcomputetheproductoftwoinput
parameters, but in slightly different ways. In oder to prove thatthey are equivalent, a bottom-up analysis of RVT and SymDiff
wouldneedtoestablishanon-linearrelationalinvariantbetween
thelibraryfunctions,namely, (RET==x×y)∧(RET/prime==y/prime×x/prime),
wherex,y,x/prime, andy/primeare the input parameters. Yet Clever only
needs to consider the few cases defined by the particular inputs
provided by the clients.
For the non-equivalent cases, Clever was almost always the
best among the four. This shows the advantages of the parallelexploration feature which disproves equivalence by discovering
counterexamples early on.
Overall, Clever and ModDiff were comparable in most of the
cases, and the differences in their run-times were often under asecond. In all of the cases where this difference was larger, the
performanceof Cleverwassuperior.This benefitisillustratedin
Fig.10which plots the execution times of Clever and ModDiff on
the set of equivalent loopmult instances. The first five instances,
loopmult{2,5,10,15,20},weredirectlytakenfromtheModDiffsuite.
We extended the pattern to analyze the growth of the execution
times.Fig. 10showsresultsconsistentwithTable 2.Whenthein-
stancein questionissimple(as measuredinthe numberofpaths),
the two tools perform similarly. As the difficulty increases, Mod-
Diff’sexecutiontimegoesupsignificantlywhileClever’sgrows
linearly. The non-equivalent loopmult instances show a similar
but more pronounced difference. This is because Clever is able to
ignore most library paths due to the client usage of the library.
AnswertoRQ1: Yes,thecomparisonresultssuggestthatour
technique is effective and efficient on deciding client-specific
equivalence, compared with the state-of-the-art.
448
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. Client-Specific Equivalence Checking ASE ’18, September 3–7, 2018, Montpellier, France
10−210−110010110210−210−1100101102
Time (s) by Clever-NTime (s) taken by Clever100101102
100101102#Path by Clever-N
#Path by Clever
Time
#Paths
Figure11:Comparisonoftimeandnumberofpathsbetween
Clever-N and Clever.
6.3 Effect of Incremental Lazy Exploration
To evaluate the effect of incremental lazy exploration, we created a
versionofourtoolwithoutthisfeature,namedClever-N,andcom-
pared it to Clever on the set of benchmarks described in Sec. 6.2.
Fig.11showstheresultsovertwometrics:thetotalnumberof
paths explored, and executiontimes. The axes are logarithmically
scaled. Each (blue) circle shows the comparison of the two tools in
terms of the number of paths explored for a particular benchmark
– the top and right axes represent the results by Clever-N and
Clever, respectively. There are more circles below the diagonalline because Clever is often able to ignore paths in the libraries
when proving equivalence and paths in the client when finding
acounterexample.Therearesomecirclesabovethediagonalline
becausetwodifferentcallingcontextscanleadtotheexplorationofthesamelibrarypath,andbecauseCleverdoesnotavoidexploring
the same path multiple times (at the time of writing).
Similarly, each (red) cross shows the comparison of Clever-
N and Clever in terms of their execution time. The bottom and
left axes represent the running time of Clever-N and Clever,
respectively. Again, the crosses tend to be below the diagonal, sug-
gesting that Clever outperforms Clever-N in most of the cases.
The crosses lying on the right axis represent benchmarks where
CleversucceededandClever-Nwasunabletoterminate.These
includemostofthe loopMult examplescomingfromtheModDiff
benchmarks. Exploiting the specific client contexts, Clever avoids
exploringtheexponentialnumberofpathsforthewhileloopsin
the libraries and thus saves the execution time.
Answer to RQ2: Incremental lazy exploration has a positive
andpronouncedimpactontheeffectivenessof Cleverboth
in terms of running time and the number of paths explored.
6.4 Case Study
InSec.2,wedescribedsixPythonclient-libraryfunctionpairs.In
this section, we report on the experience applying Clever to these
pairs, aiming to answer RQ3.1+ SECOND = 1
2+ MINUTE = 2
3def truncate(self, s):
4- if s == ‘second’:
5+ if s == SECOND:
6 self._dt = self._dt.replace(microsecond=0)
7- elif s == ‘minute’:
8+ elif s == MINUTE:
9 ...
Figure 12: Example string to integer transformation for De-
lorean.truncate.
Preparation. To prepare the examples as a valid input to Clever,
we (Step 1) made the necessary simplifications to external func-
tions; (Step 2) transformed string operations to integer operations;
and (Step 3) wrapped the client function with an entry point for
symbolic execution. We describe these in turn below.
Step 1.To illustrate the required simplifications to external func-
tions,considerthePythondatetimefunction now().Itisintended
toreturnthetimeatinvocation,buttoavoidspuriouscounterex-
amplestoclient-specificequivalence,wesimplifiedittoreturna
fixed time.
Step 2.We illustrate a transformation from string operations
to integer operations in Fig. 12. This figure shows a snippet of a
Delorean methodthat reasonsby caseson asingle argument,and
thecorrespondingtransformation.Becausetheoriginalreasoning
islimitedtocheckingequalityagainstconstantstringvalues,we
transformthefunctiontocheckintegerconstants,ensuringthatthe
mapping from string to integer constants is a bijection, the empty
string is mapped to 0, inputs are transformed accordingly, and the
changes are propagated to all dependent code.
Step3.Wewrapclientfunctionswithanentrypointforsymbolic
executionsothatallargumentsandfunctionreturnsareintegers.
The wrapping function constructs the necessary objects to pass
into the client function, and then deconstructs the output.
Results. Sinceallsixclient-librarymethodpairsareclient-specific
equivalent (see Sec. 2), we added 10 modified examples intended to
break the equivalence. Clever correctly classified all 16 examples,
with an average execution time of 1.517 seconds.4
AnswertoRQ3: Yes,ourapproachcanbeeffectivelyapplied
torealsoftwareprojects.However,ourcurrentimplementa-
tion requires some manual program preprocessing.
6.5 Threats to Validity
The applicability study in Sec. 2relies on manual determination
of ground truth. To ensure internal validity, we had two authors
independently classify each client-library function pair, and a third
author settle conflicting cases.
WemaintainedthreeversionsofthebenchmarksusedinSec. 6.2
(Python,C,Boogie).Toenablecross-languagecomparisonsbetween
the tools, we limited the examples to subsets of the languages that
can be trivially translated: control flow, integer operations, and no
4All examples are available at https://client-specific-equivalence-checker.github.io/
449
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Federico Mora, Yi Li, Julia Rubin, and Marsha Chechik
heap manipulations. Furthermore, since all the tools assume un-
boundedintegers,C’s intdatatypecorrespondsdirectlytoPython’s
forourcomparisons.TheconversionbetweenCandBoogiewas
done automatically, using SMACK [22].
Ourencouragingresultspresentedintheapplicabilitystudyin
Sec.2,inthecomparisonsinSec. 6.2,andinthecase-studyinSec. 2
may not generalize to all software projects. Yet we believe that our
selection process of the sample populations used in these sections
resulted in software representative of current best practice.
7 RELATED WORK
Clever relates to several techniques reviewed below.
ProgramEquivalenceChecking. Differential symbolic execution
(DSE)byPersonetal.[ 20]istheclosestworktoours.DSEperforms
standard symbolic execution on both program versions, before and
afterthechange,andeitherreportsthatthetwoversionsareequiv-
alent orcharacterizes the behavioral differences by identifyingthe
sets of inputs that cause different effects. It also introduced several
notions of behavioral equivalence, including partition-effect and
functionalequivalence.However,thesenotionsaredefinedovera
wholeprogram,withoutseparationbetweenclientsandlibraries.
SymDiff[ 17]alsochecksforpartialequivalencebetweenpairsof
proceduresinaprogram,anditsnotionof mutualsummary [14]
can also be used to encode client-specific equivalence. For exam-
ple, SymDiff implements differential assertion checking (DAC) [18],
whichdefinesprogramequivalenceintermsofuser-providedasser-
tions. Given two program versions PandP/primeand a set of assertions
s.t. all of them hold in P, DAC checks whether these assertions still
holdinP/prime.UnlikeDSE,behavioralpreservationdoesnothavetobe
guaranteedacrossversions,andonlyaweakerformofequivalence
with respect to the assertions is checked. In principle, CSE can
be phrased as DAC by asserting that the input-output relations of
theclientstaythesameevenwhenthelibrarychanges.However,
SymDiff can only prove equivalences, and not disprove them [ 25].
In addition,as shown byour experiments (seeSec. 6.2), SymDiffof-
ten fails to automatically infer mutual summaries which are strong
enough to conclude functional equivalence.
Regression verification [8,13] aims to formally prove that two
programsarefunctionallyequivalent.RVT[ 13]provespartialequiv-
alenceoftworelatedprograms,i.e.,thattheyproducesameoutputs
for all inputs given that both of them terminate, according to a set
of proof rules. Recursive calls are first abstracted as uninterpreted
functions, and then the proof rules for non-recursive functions
aredischargedinabottom-upfashion,whichmakesitdifficultto
exploit specific calling contexts for specific clients. Rêve [ 8] targets
programs with complex arithmetic and control flows, and automat-
icallyprovesequivalencewhen“simple”couplingpredicatesover
lineararithmeticexistforthetwoprograms.Trostanetskietal.[ 25]
recently proposed a modular demand-driven approach, ModDiff,
to improve the precision and scalability of such analysis. Whenconsidering the client and library as a whole, CSE also falls intothe regression verification framework. However, our problem ismore specific in the sense that the change is restricted to the li-
brarypartwhiletheclientiskeptunchanged.Inaddition,thereare
nocircular dependenciesfromthe librariestothe client,allowing
us to optimize equivalence checking by exploring the programstop-downwhilesignificantlylimitingthebehaviorsthatneedtobe
considered.
Incremental Program Analysis. The work on incremental ver-
ification[6,7,24] aims to reuse results from prior verification as
programsevolve,assumingthatproperties(oftheclient)tobeveri-
fied are given. For example, Sery et al. [ 24] uses a compositional
approach, implemented in a tool named eVolCheck, to summarize
the properties of each procedure and then check whether these
propertiesholdfortheupdatedversionoftheprogram.Chakietal. [
6] uses state machine abstractions to analyze whether every
behaviorthatshouldbepreservedisstillavailable(containment ),
andwhetheraddedbehaviorsconformtotheirrespectfulproperties
(compatibility ). Fedyukovich et al. [ 7] offer an incremental verifica-
tion technique for checking equivalence w.r.t. program properties.
Theprimaryfocusofalltheseworksisreusingpriorverification
results as programs evolve while our work focuses on establishing
equivalencew.r.t.aparticularclient.Furthermore,ourworkdoes
not require specifications.
Symbolic Execution. Apart from DSE [ 20], there are a number
of other symbolic execution-based approaches which are related
to our work. Directed incremental Symbolic Execution (DiSE) [21]
builds on DSE by adding static impact analysis for finding possible
locationswheretheexecutionmayvary.Theinsightof DiSEisto
leveragetheinformationextractedfromthecheaperchangeimpact
analysistoenablemoreefficientsymbolicexecutionofprograms
as they evolve. This is similar to our optimizations of collecting
activepathswhichexercisechanges,makingsubsequentanalysis
focused only on potentially changed behaviors.
Godefroid et al. introduced demand-driven compositional sym-
bolic execution [1,12], the key novelty being compositionality: the
search process is made compositional, and, consequently, exponen-
tiallyfasterthanthenon-compositionalone[ 11].Althoughthese
approaches do not address the problem of equivalence checking,
our context-specific library exploration is inspired by them.
8 CONCLUSION AND FUTURE WORK
In this paper, we defined the notion of Client-Specific Equivalence
(CSE)andpresentedanalgorithmcalledClever,whichleverages
heuristics tailored for checking CSE. We implemented a prototype
for Clever and compared it with four state-of-the-art equivalence
checkingtoolsonasetofnon-trivialbenchmarks.Wealsoevaluatedourapproachonareal-worldcasestudy,confirmingitsapplicability
and efficiency.
As future work, we intend to apply Clever to more diverse sys-
tems, extending it to support other programming languages and
language constructs such as heap manipulations. We also intend to
addsupportforfloatingpointnumbers,strings,andobjectscom-
posed of these primitives. Beyond that, we are interested in explor-
ingotherdefinitionsofequivalence,suchas pathequivalence and
partition-effectequivalence [20],whichgivestrongerguaranteesbut
mightbemoreexpensivetocheck.Finally,proposingdesirablefixes
for the identified client-specific inequivalence is another fruitful
direction.
450
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. Client-Specific Equivalence Checking ASE ’18, September 3–7, 2018, Montpellier, France
REFERENCES
[1]Saswat Anand, Patrice Godefroid, and Nikolai Tillmann. 2008. Demand-Driven
Compositional Symbolic Execution. In Proc. of TACAS’08 (LNCS), Vol. 4963.
Springer, 367–381.
[2]Tom Ball and Jakub Daniel. 2015. Deconstructing Dynamic Symbolic Execution.
InProc. of the 2014 Marktober Summer School on Dependable Software Systems
Engineering. IOS Press.
[3]MikeBarnett,Bor-YuhEvanChang,RobertDeLine,BartJacobs,andK.RustanM.
Leino. 2006. Boogie: A Modular Reusable Verifier for Object-Oriented Programs.
InProc.ofFMCO’05,FrankS.deBoer,MarcelloM.Bonsangue,SusanneGraf,and
Willem-Paul de Roever (Eds.). Springer Berlin Heidelberg, 364–387.
[4]Cristian Cadar, Daniel Dunbar, and Dawson Engler. 2008. KLEE: Unassisted and
Automatic Generation of High-Coverage Tesets for Complex Systems Programs.
InProc. of OSDI’08.
[5]CristianCadarandHristinaPalikareva.2014. ShadowSymbolicExecutionfor
Better Testing of Evolving Software. In Proc. of ICSE NIER’14. 432–435.
[6]Sagar Chaki, Edmund Clarke, Natasha Sharygina, and Nishant Sinha. 2008. Veri-
fication of Evolving Software via Component Substitutability Analysis. Formal
Methods in System Design 32, 3 (2008), 235–266.
[7]GrigoryFedyukovich,ArieGurfinkel,andNatashaSharygina.2016. Property-
Directed Equivalence via Abstract Simulation. In Proc. of CAV’16. Springer, 433–
453.
[8]Dennis Felsing, Sarah Grebing, Vladimir Klebanov, Philipp Rümmer, and Mattias
Ulbrich. 2014. Automating Regression Verification. In Proc. of ASE’14. ACM,
349–360.
[9] Flint 2017. FLINT: Fast Library for Number Theory. http://www.flintlib.org.
[10]MarcoGarioandAndreaMicheli.2015. pySMT:aSolver-AgnosticLibraryfor
Fast Prototyping of SMT-Based Algorithms. In SMT Workshop.
[11]Patrice Godefroid. 2007. Compositional Dynamic Test Generation. In Proc. of
POPL’07. ACM, 47–54.
[12]PatriceGodefroid,ShuvenduK.Lahiri,andCindyRubio-González.2011. Stati-
callyValidatingMustSummaries forIncrementalCompositionalDynamicTest
Generation. In Proc. of SAS’11. Springer-Verlag, 112–128.[13]Benny Godlin and Ofer Strichman. 2013. Regression Verification: Proving the
Equivalence of Similar Programs. J. Software Testing, Verification and Reliability
23, 3 (2013), 241–258.
[14]ChrisHawblitzel,MingKawaguchi,ShuvenduK.Lahiri,andHenriqueRebêlo.
2013. Towards Modularly Comparing Programs Using Automated Theorem
Provers. In Proc. of CADE’13. Springer-Verlag, 282–299.
[15]Ming Kawaguchi, Shuvendu Lahiri, and Henrique Rebelo. 2010. Conditional
Equivalence. Technical Report. Microsoft Research.
[16]James C. King. 1976. Symbolic Execution and Program Testing. Comm. of the
ACM19, 7 (1976), 385–394.
[17]ShuvenduK.Lahiri,ChrisHawblitzel,MingKawaguchi,andHenriqueRebêlo.
2012.SYMDIFF:ALanguage-agnosticSemanticDiffToolforImperativePrograms.
InProc. of CAV’12. Springer-Verlag, 712–717.
[18]Shuvendu K. Lahiri, Kenneth L. McMillan, Rahul Sharma, and Chris Hawblitzel.
2013. Differential Assertion Checking. In Proc. of ESEC/FSE’13.
[19]MPACK2017. TheMPACK:MultiplePrecisionArithmeticBLAS(MBLAS)and
LAPACK (MLAPACK). http://mplapack.sourceforge.net.
[20]Suzette Person, Matthew B. Dwyer, Sebastian Elbaum, and Corina S. P ˇasˇareanu.
2008. Differential Symbolic Execution. In Proc. of SIGSOFT FSE’08.
[21]SuzettePerson,GuoweiYang,NehaRungta,andSarfrazKhurshid.2011. Directed
Incremental Symbolic Execution. In Proc. of PLDI’11. ACM, 504–515.
[22]Zvonimir Rakamarić and Michael Emmi. 2014. SMACK: Decoupling Source
LanguageDetailsfromVerifierImplementations:DecouplingSourceLanguage
Details from Verifier Implementations. In Proc. of CAV’14, Vol. 8559. Springer,
106–113.
[23]Julia Rubin and Martin Rinard. 2016. The Challenges of Staying Together While
Moving Fast: An Exploratory Study. In Proc. of ICSE’16. 982–993.
[24]OndrejSery,GrigoryFedyukovich,andNatashaSharygina.2012. Incremental
UpgradeCheckingbyMeansofInterpolation-BasedFunctionSummaries.In Proc.
of FMCAD’12. IEEE, 114–121.
[25]Anna Trostanetski, Orna Grumberg, and Daniel Kroening. 2017. Modular
Demand-DrivenAnalysisofSemanticDifferenceforProgramVersions.In Proc.
of SAS’17. Springer, 405–427.
451
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. 