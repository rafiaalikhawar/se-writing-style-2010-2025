iFixR: Bug Report driven Program Repair
Anil Koyuncu1, Kui Liu1,∗, Tegawendé F. Bissyandé1, Dongsun Kim1,2, Martin Monperrus3, Jacques
Klein1, and Yves Le Traon1
1University of Luxembourg, Luxembourg, {anil.koyuncu, kui.liu,tegawende.bissyande,jacques.klein, yves.letraon}@uni.lu
2Furiosa.ai, Republic of Korea, darkrsw@furiosa.ai
3KTH Royal Institute of Technology, Sweden, martin.monperrus@csc.kth.se
ABSTRACT
Issue tracking systems are commonly used in modern software
development for collecting feedback from users and developers. An
ultimate automation target of software maintenance is then the sys-
tematization of patch generation for user-reported bugs. Although
this ambition is aligned with the momentum of automated program
repair, the literature has, so far, mostly focused on generate-and-
validate setups where fault localization and patch generation are
driven by a well-defined test suite. On the one hand, however, the
common (yet strong) assumption on the existence of relevant test
cases does not hold in practice for most development settings: many
bugs are reported without the available test suite being able to re-
veal them. On the other hand, for many projects, the number of
bug reports generally outstrips the resources available to triage
them. Towards increasing the adoption of patch generation tools by
practitioners, we investigate a new repair pipeline, iFixR , driven
by bug reports: (1) bug reports are fed to an IR-based fault localizer;
(2) patches are generated from fix patterns and validated via regres-
sion testing; (3) a prioritized list of generated patches is proposed
to developers. We evaluate iFixR on the Defects4J dataset, which
we enriched (i.e., faults are linked to bug reports) and carefully-
reorganized (i.e., the timeline of test-cases is naturally split). iFixR
generates genuine/plausible patches for 21/44 Defects4J faults with
its IR-based fault localizer. iFixR accurately places a genuine/plau-
sible patch among its top-5 recommendation for 8/13 of these faults
(without using future test cases in generation-and-validation).
CCS CONCEPTS
•Software and its engineering →Software verification and
validation ; Software testing and debugging.
KEYWORDS
Information retrieval, fault localization, automatic patch generation.
ACM Reference Format:
Anil Koyuncu1, Kui Liu1,∗, Tegawendé F. Bissyandé1, Dongsun Kim1,2, Mar-
tin Monperrus3, Jacques Klein1, and Yves Le Traon1. 2019. iFixR: Bug Report
∗Corresponding author, the same contribution as the first author.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
ESEC/FSE ’19, August 26–30, 2019, Tallinn, Estonia
©2019 Association for Computing Machinery.
ACM ISBN 978-1-4503-5572-8/19/08. . . $15.00
https://doi.org/10.1145/3338906.3338935driven Program Repair. In Proceedings of the 27th ACM Joint European Soft-
ware Engineering Conference and Symposium on the Foundations of Software
Engineering (ESEC/FSE ’19), August 26–30, 2019, Tallinn, Estonia. ACM, New
York, NY, USA, 12 pages. https://doi.org/10.1145/3338906.3338935
1 INTRODUCTION
Automated program repair (APR) has gained incredible momentum
in the last decade. Since the seminal work by Weimer et al. [ 83] who
relied on genetic programming to evolve program variants until one
variant is found to satisfy the functional constraints of a test suite,
the community has been interested in test-based techniques to re-
pair programs without specifications . Thus, various approaches [ 12,
13,18,19,25,26,32,33,38,45,48,49,52,53,55,62,65,83,84,92,93]
have been proposed in the literature aiming at reducing manual de-
bugging efforts through automatically generating patches. Beyond
fixing syntactic errors , i.e., cases where the code violates some pro-
gramming language specifications [ 16], the current challenges lie in
fixing semantic bugs , i.e., cases where implementation of program
behavior deviates from developer’s intention [22, 61].
Ten years ago, the work of Weimer et al. [ 83] was explicitly mo-
tivated by the fact that, despite significant advances in specification
mining (e.g., [ 40]), formal specifications are rarely available. Thus,
test suites represented an affordable approximation to program
specifications. Unfortunately, the assumption that test cases are
readily available still does not hold in practice [ 7,27,68]. There-
fore, while current test-based APR approaches would be suitable
in a test-driven development setting [ 6], their adoption by practi-
tioners faces a simple reality: developers majoritarily (1) write few
tests [ 27], (2) write tests after the source code [ 7], and (3) write tests
to validate that bugs are indeed fixed and will not reoccur [23].
Although APR bots [ 79] can come in handy in a continuous
integration environment, the reality is that bug reports remain the
main source of the stream of bugs that developers struggle to handle
daily [ 5]. Bugs are indeed reported in natural language, where
users tentatively describe the execution scenario that was being
carried out and the unexpected outcome (e.g., crash stack traces).
Such bug reports constitute an essential artifact within a software
development cycle and can become an overwhelming concern for
maintainers. For example, as early as in 2005, a triager of the Mozilla
project was reported in [5, page 363] to have commented that:
“Everyday, almost 300 bugs appear that need triaging. This is
far too much for only the Mozilla programmers to handle. ”
However, very few studies [ 9,43] have undertaken to automate
patch generation based on bug reports. To the best of our knowledge,
Liu et al. [ 43] proposed the most advanced study in this direction.
Unfortunately, their R2Fix approach carries several caveats: as illus-
trated in Figure 1, it focuses on perfect bug reports [ 43, page 283]arXiv:1907.05620v1  [cs.SE]  12 Jul 2019ESEC/FSE ’19, August 26–30, 2019, Tallinn, Estonia A. Koyuncu et al.
R2Fix: Automatically Generating Bug Fixes from Bug ReportsChen Liu, Jinqiu Yang and Lin TanUniversity of Waterloo, ON, Canada{c92liu, j223yang, lintan}@uwaterloo.caMunawar HaﬁzAuburn University, AL, USAmunawar@auburn.eduAbstract— Many bugs, even those that are known anddocumented in bug reports, remain in mature software fora long time due to the lack of the development resources to ﬁxthem. We propose a general approach, R2Fix, to automaticallygenerate bug-ﬁxing patches from free-form bug reports. R2Fixcombines past ﬁx patterns, machine learning techniques, andsemantic patch generation techniques to ﬁx bugs automatically.We evaluate R2Fix on three projects, i.e., the Linux kernel,Mozilla, and Apache, for three important types of bugs:buffer overﬂows, null pointer bugs, and memory leaks. R2Fixgenerates 57 patches correctly, 5 of which are new patches forbugs that have not been ﬁxed by developers yet. We reported all5 new patches to the developers; 4 have already been acceptedand committed to the code repositories. The 57 correct patchesgenerated by R2Fix could have shortened and saved up to anaverage of 63 days of bug diagnosis and patch generation time.Keywords-automated bug ﬁxing; automated program repair;bug report classiﬁcation; ﬁx pattern studyI. INTRODUCTIONEveryday, an overwhelming number of bugs are reported.For example, the Mozilla bug database [4], with a totalof 670,359 bug reports, receives an average of 135 newbug reports daily. The corresponding bugs hurt softwarereliability and security, which are not improved until thebugs are ﬁxed.Upon receiving a bug report, developersdiagnosethe rootcause of the bug,produce a patchthat can ﬁx the bug,andcommitthe patch to the source code repository. Wecombine the ﬁrst two steps (diagnosis and patch generation)under the label ofﬁxinga bug, which is the focus of thispaper. Developers’ bug-ﬁxing process is primarily manual;therefore the time required for producing a ﬁx and itsaccuracy depend on the skill and experience of individuals.Figure 1(a) shows a Linux kernel buffer overﬂow/overrunbug report. The developers ﬁrst need to understand thisbug report by reading the relevant code together with thisreport: the bufferstatecontains only 4 bytes, but 5 bytes,“off\0”, was written to the buffer, wheredenotes onespace character and the single character ‘\0’ is needed tomark the end of the string. The developers then need toﬁgure out how to ﬁx the bug (e.g., by reading the relevantcode and using a debugger to observe and modify theprogram execution). Why are more than 4 bytes assignedto the buffer? Should 5 bytes be allocated instead; shoulddevelopers assign only 4 bytes to the bufferstate; did theBug 11975 - [net/mac80211/debugfs_sta.c:202]: Buffer overrun Description: The trailing zero (`\0’) will be written to state[4] which is out of bound.linux/net/mac80211/debugfs_sta.c:-        strcpy(state, "off/spaceopenbox");+       strcpy(state, "off");(a) Linux Kernel Bug Report(b) Patch to Fix the BugRemove the space characterFigure 1. Converting a bug report to a patch. “-” denotes a line to bedeleted; “+” denotes a line to be added; and “” is one space character.developers forget to check if the array is long enough to holdthe content before the assignment; or was the bug caused bymore complex reasons? The developers then need to checkout the buggy version, modify the buggy code to ﬁx thebug, and generate the patch that can be applied to the sharedsource code repository.The result of this challenging and time-consuming processby developers for bug 11975 is the patch in Figure 1(b). Thepatch deletes the line that writes 5 bytes to bufferstate(denoted by- strcpy(state, "off");), and adds anew line to write only 4 bytes tostate(+ strcpy(state,"off");), which ﬁxes the overﬂow bug.Developers often need to ﬁx more bugs than their timeand resources allow [6]. Although developers spend almosthalf of their time ﬁxing bugs [21], bugs takeyearsto beﬁxed on average [9], [19].Therefore, support to make it easier and faster for de-velopers to ﬁx bugs is in high demand. The capability toautomatically generate patches (e.g., Figure 1(b)) from bugreports (e.g., Figure 1(a)) could: (1) save programmers’time and effort in diagnosing bugs and generating patches,allowing developers to ﬁx more bugs or focus on otherdevelopment tasks; and (2) shorten the bug-ﬁxing time, thusimprove software reliability and security.A. Ideal Goal Versus Realistic GoalIdeally, we want to automatically generate patches for allbug reports. Realistically, it is impossible. We found thatonly 16.7–33.5% of bug reports in the Linux kernel, Mozilla,and Apache bug databases are ﬁxed. This is because, manybug reports are invalid, unreproducible, incomplete, etc.Even among bugs that can be ﬁxed, some are too complexto be ﬁxed automatically because they require redesign ofthe algorithm, addition of new features, etc.
2013 IEEE Sixth International Conference on Software Testing, Verification and Validation
978-0-7695-4968-2/13 $26.00 © 2013 IEEE
DOI 10.1109/ICST.2013.24282
Figure 1: Example of Linux bug report addressed by R2Fix.
(1) which explicitly include localization information, (2) where the
symptom (e.g., buffer overrun) is explicitly indicated by the reporter,
and (3) which are about one of the following three simple bug types:
Buffer overflow, Null Pointer dereference or memory leak. R2Fix
runs a straightforward classification to identify the bug category
and uses a match and transform engine (e.g., Coccinelle [ 66]) to
generate patches. As the authors admitted, their target space repre-
sents <1% of bug reports in their dataset. Furthermore, it should be
noted that, given the limited scope of the changes implemented in
its fix patterns, R2Fix does not need to run tests for verifying that
the generated patches do not break any functionality.
This paper. We propose to investigate the feasibility of a pro-
gram repair system driven by bug reports, thus we replace classi-
cal spectrum-based fault localization with Information Retrieval
(IR)-based fault localization. Eventually, we propose iFixR , a new
program repair workflow which considers a practical repair setup
by imitating the fundamental steps of manual debugging. iFixR
works under the following constraint:
When a bug report is submitted to the issue tracking system, a rele-
vant test case reproducing the bug may not be readily available.
Therefore, iFixR is leveraged in this study to assess to what ex-
tent an APR pipeline is feasible under the practical constraint of limited
test suites .iFixR uses bug reports written in natural language as
the main input. Eventually, we make the following contributions:
•We present the architecture of a program repair system adapted
to the constraints of maintainers dealing with user-reported bugs.
In particular, iFixR replaces classical spectrum-based fault local-
ization with Information Retrieval (IR)-based fault localization.
•We propose a strategy to prioritize patches for recommendation
to developers. Indeed, given that we assume only the presence of
regression test cases to validate patch candidates, many of these
patches may fail on the future test cases that are relevant to the
reported bugs. We order patches to present correct patches first.
•We assess and discuss the performance of iFixR on the Defects4J
benchmark to compare with the state-of-the-art APR tools. To
that end, we provide a refined Defects4J benchmark for APR
targeting bug reports. Bugs are carefully linked with the corre-
sponding bug reports, and for each bug we are able to dissociate
future test cases that were introduced after the relevant fixes.
Overall, experimental results show that there are promising
research directions to further investigate towards the integration of
automatic patch generation in actual software development cycles.
In particular, our findings suggest that IR-based fault localization
errors lead less to overfitting patches than spectrum-based fault
localization errors. Furthermore, iFixR offers provides comparable
results to most state-of-the-art APR tools, although it is run under
the constraint that post-fix knowledge (i.e., future test cases) is
not available. Finally, iFixR ’s prioritization strategy tends to place
more correct/plausible patches on top of the recommendation list.
2 MOTIVATION
We motivate our work by revisiting two essential steps in APR:(1)During fault localization , relevant program entities are identified
as suspicious locations that must be changed. Commonly, state-
of-the-art APR tools leverage spectrum-based fault localization
(SBFL) [ 12,25,32,33,39,50,52,53,62,65,83,92,93], which
uses execution coverage information of passing and failing test
cases to predict buggy statements. We dissect the construction
of the Defects4J dataset to highlight the practical challenges of
fault localization for user-reported bugs.
(2)Once a patch candidate is generated, the patch validation step
ensures that it is actually relevant for repairing the program.
Currently, widespread test-based APR techniques use test suites
as the repair oracle. This however is challenged by the incom-
pleteness of test suites, and may further not be inline with
developer requirements/expectations in the repair process.
2.1 Fault Localization Challenges
Defects4J is a manual curated dataset widely used in the APR litera-
ture [ 12,18,73,84,90,91]. Since Defects4J was not initially built for
APR, the real order of precedence between the bug report, the patch
and the test case is being overlooked by the dataset users. Indeed,
Defects4J offers a user-friendly way of checking out buggy versions
of programs with all relevant test cases for readily benchmarking
test-based systems. We propose to carefully examine the actual bug
fix commits associated with Defects4J bugs and study how the test
suite is evolved. Table 1 provides detailed information.
Table 1: Test case changes in fix commits of Defects4J bugs.
Test case related commits # bugs
Commit does not alter test cases 14
Commit is inserting new test case(s) and updating previous test case(s) 62
Commit is updating previous test case(s) (without inserting new test cases) 76
Commit is inserting new test case(s) (without updating previous test cases) 243
Overall, for 96%(=381/395) bugs, the relevant test cases are ac-
tually future data with respect to the bug discovery process. This
finding suggests that, in practice, even the fault localization may
be challenged in the case of user-reported bugs, given the lack of
relevant test cases. The statistics listed in Table 2 indeed shows
that if future test cases are dropped, no test case is failing when
executing buggy program versions for 365 (i.e., 92%) bugs.
Table 2: Failing test cases after removing future test cases.
Failing test cases # bugs
Failing test cases exist (and no future test cases are committed) 14
Failing test cases exist (but future test cases update the test scenarios) 9
Failing test cases exist (but they are fewer when considering future test cases) 4
Failing test cases exist (but they differ from future test cases which trigger the bug) 3
No failing test case exists (i.e., only future test cases trigger the bug) 365
In the APR literature, fault localization is generally performed
using the GZoltar [ 11] testing framework and a SBFL formula [ 88]
(e.g., Ochiai [ 2]). To support our discussions, we attempt to perform
fault localization without the future test cases to evaluate the per-
formance gap. Experimental results (see details forward in Table 6
of Section 5) expectedly reveal that the majority of the Defects4J
bugs (i.e., 375/395) cannot be localized by SBFL at the time the bug
is reported by users.
It is necessary to investigate alternate fault localization approaches
that build on bug report information since relevant test cases are
often unavailable when users report bugs.iFixR: Bug Report driven Program Repair ESEC/FSE ’19, August 26–30, 2019, Tallinn, Estonia
IRBL FeaturesStep 1 
Bug ReportsSource Code  FilesStep 0
Distribute to Regions 
Standard IRBL
............
RegionsStep 2 Step 3 Step 4 Step 5 
Divide Conquer Best Models  Leaf-wise Weights Computations 
Code changes inSoftware repositoriesBug ﬁx patchesEnhanced AST diﬀ representationsDiﬀ hunk search space constructionRooted tree isomorphism computationClustering based onsubgraph IdentiﬁcationStep 0Step 1Step 2Step 3Step 4Step 5Iterative foldingPatchCandidatesPatchGeneration
PatchValidationRegressionTestingFixPatternMatchingIR-based fault localization Suspicious CodeLocationsBuggyProgram
SelectfixpatternMutatesuspiciouscodeFaultLocalization
Bug Report
FixpatternsManual ValidationDeveloper Test
Code Elements (AST)
Figure 2: The iFixR Program Repair Workflow.
2.2 Patch Validation in Practice
The repair community has started to reflect on the acceptability [26,
63] and correctness [76,91] of the patches generated by APR tools.
Notably, various studies [ 10,34,69,76,94] have raised concerns
about overfitting patches: a typical APR tool that uses a test suite
as the correctness criterion can produce a patched program that
actually overfits the test-suite (i.e., the patch makes the program
pass all test cases but does not actually repair it). Recently, new
research directions [ 89,97] are being explored in the automation
of test case generation for APR to overcome the overfitting issue.
Nevertheless, so far they have had minimal positive impact due to
the oracle problem [98] in automatic test generation.
At the same time, the software industry takes a more systematic
approach for patch validation by developers. For instance, in the
open-source community, the Linux development project has inte-
grated a patch generation engine to automate collateral evolutions
that are validated by maintainers [ 29,66]. In proprietary settings,
Facebook has recently reported on their Getafix [75] tool, which
automatically suggests fixes to their developers. Similarly, Ubisoft
developed Clever [64] to detect risky commits at commit-time using
patterns of programming mistakes from the code history.
Patch recommendation for validation by developers is acceptable in
the software development communities. It may thus be worthwhile to
focus on tractable techniques for recommending patches in the road
to fully automated program repair.
3 THE IFIXR APPROACH
Figure 2 overviews the workflow of the proposed iFixR approach.
Given a defective program, we consider the following issues:
(1)Where is the bug? We take as input the bug report in natu-
ral language submitted by the program user. We rely on the
information in this report to localize the bug positions.
(2)How should we change the code? We apply fix patterns that
are recurrently found in real-world bug fixes. Fix patterns are
selected following the structure of the abstract syntax tree rep-
resenting the code entity of the identified suspicious code.
(3)Which patches are valid? We make no assumptions on the
availability of positive test cases [83] that encode functionality
requirements at the time the bug is discovered. Nevertheless,
we leverage existing test cases to ensure, at least, that the patch
does not regress the program.
(4)Which patches do we recommend first? In the absence of
a complete test suite, we cannot guarantee that all patches that
pass regression tests will fix the bug. We rely on heuristics
to re-prioritize the validated patches in order to increase the
probability of placing a correct patch on top of the list.3.1 Input: Bug reports
Issue tracking systems (e.g., Jira) are widely used by software devel-
opment communities in the open source and commercial realms. Al-
though they can be used by developers to keep track of the bugs that
they encounter and the features to be implemented, issue tracking
systems allow for user participation as a communication channel
for collecting feedback on software executions in production.
Table 3 illustrates a typical bug report when a user of the LANG
library code has encountered an issue while using the NumberUtils
API. A description of erroneous behavior is provided. Occasionally,
the user may include in the bug description some information on
how to reproduce the bug. Oftentimes, users simply insert code
snippets or dump the execution stack traces.
In this study, among our dataset of 162 bug reports, we note that
only 27 (i.e.,∼17%) are reported by users who are also developers1
contributing to the projects. 15 (i.e., ∼9%) bugs are reported and
again fixed by the same project contributors. These percentages
suggest that, for the majority of cases, the bug reports are indeed
genuinely submitted by users of the software who require project
developers’ attention.
Table 3: Example bug report (Defects4J Lang-7).
Issue No. LANG-822
Summary NumberUtils#createNumber - bad behaviour for leading "–"
Description NumberUtils#createNumber checks for a leading "–" in the string, and returns
null if found. This is documented as a work round for a bug in BigDecimal.
Returning nulll is contrary to the Javadoc and the behaviour for other methods
which would throw NumberFormatException.
It’s not clear whether the BigDecimal problem still exists with recent versions of
Java. However, if it does exist, then the check needs to be done for all invocations
of BigDecimal, i.e. needs to be moved to createBigDecimal.
Given the buggy program version and a bug report, iFixR must
unfold the workflow for precisely identifying (at the statement level)
the buggy code locations. We remind the reader that, in this step,
future test cases cannot be relied upon. We consider that if such
test cases could have triggered the bug, a continuous integration
system would have helped developers deal with the bug before the
software is shipped towards users.
3.2 Fault Localization w/o Test Cases
To identify buggy code locations within the source code of a pro-
gram, we resort to Information Retrieval (IR)-based fault localiza-
tion (IRFL) [ 67,80]. The general objective is to leverage potential
similarity between the terms used in a bug report and the source
code to identify relevant buggy code locations. The literature in-
cludes a large body of work on IRFL [ 57,72,81,85,87,96,99] where
researchers systematically extract tokens from a given bug report
to formulate a query to be matched in a search space of documents
formed by the collections of source code files and indexed through
1We rely on email addresses of committers and issue reporters to intersect users
and developersESEC/FSE ’19, August 26–30, 2019, Tallinn, Estonia A. Koyuncu et al.
tokens extracted from source code. IRFL approaches then rank the
documents based on a probability of relevance (often measured as
a similarity score). Highly ranked files are predicted to be the ones
that are likely to contain the buggy code.
Despite recurring interest in the literature, with numerous ap-
proaches continuously claiming new performance improvements
over the state-of-the-art, we are not aware of any adoption in pro-
gram repair research or practice. We postulate that one of the
reasons is that IRFL techniques have so far focused on file-level lo-
calization, which is too coarse-grained (in comparison to spectrum-
based fault localization output). Recently, Locus [ 85] and BLIA [ 96]
are state-of-the-art techniques which narrow down localization,
respectively to the code change or the method level. Nevertheless,
to the best of our knowledge, no IRFL technique has been proposed
in the literature for statement-level localization.
In this work, we develop an algorithm to rank suspicious state-
ments based on the output (i.e., files) of a state-of-the-art IRFL tool,
thus yielding a fine-grained IR-based fault localizer which will then
be readily integrated into a concrete patch generation pipeline.
3.2.1 Ranking Suspicious Files. We leverage an existing IRFL tool.
Given that expensive extractions of tokens from a large corpus of
bug reports is often necessary to tune IRFL tools [ 41], we selected a
tool for which the authors provide datasets and pre-processed data.
We use the D&C [ 30] as the specific implementation of file-level
IRFL available online [ 1] , which is a machine learning-based IRFL
tool using a similarity matrix of 70-dimension feature vectors (7 fea-
tures from bug reports and 10 features from source code files): D&C
uses multiple classifier models that are trained each for specific
groups of bug reports. Given a bug report, the different predictions
of the different classifiers are merged to yield a single list of suspi-
cious code files. Our execution of D&C (Line 2 in Algorithm 1) is
tractable given that we only need to preprocess those bug reports
that we must localize. Trained classifiers are already available. We
ensure that no data leakage is induced (i.e., the classifiers are not
trained with bug reports that we want to localize in this work).
3.2.2 Ranking Suspicious Statements. Patch generation requires
fine-grained information on code entities that must be changed. For
iFixR , we propose to produce a standard output, as for spectrum-
based fault localization, to facilitate integration and reuse of state-
of-the-art patch generation techniques. To start, we build on the
conclusions on a recent large-scale study [ 47] of bug fixes to limit
the search space of suspicious locations to the statements that are
more error-prone. After investigating in detail the abstract syn-
tax tree (AST)-based code differences of over 16 000 real-world
patches from Java projects, Liu et al. [ 47] reported that the follow-
ing specific AST statement nodes were significantly more prone
to be faulty than others: IfStatements ,ExpressionStatements ,
FieldDeclarations ,ReturnStatements andVariableDeclara-
tionStatements . Lines 7–17 in Algorithm 1 detail the process to
produce a ranked list of suspicious statements.
Algorithm 1 describes the process of our fault localization ap-
proach used in iFixR . Top kfiles are selected among the returned
list of suspicious files of the IRFL along with their computed suspi-
ciousness scores. Then each file is parsed to retain only the relevant
error-prone statements from which textual tokens are extracted.
The summary and descriptions of the bug report are also analyzedAlgorithm 1: Statement-level IR-based Fault Localization.
Input : br: a bug report
Input : irT ool : IRFL tool
Output : Sscor e : Suspicious Statements with weight scores
1Function main (br,irT ool )
2 F←fileLocalizations (irT ool ,br)
3 F←selectTop (F,k)
4 cb←bagOfTokens (br) /*cb: Bag of Tokens of bug report */
5 c′
b←preprocess (cb) /* tokenization,stopword removal, stemming */
6 vb←tfIdfVectorizer( c′
b) /*vb: Bug report Feature Vector */
7 forfinFdo
8 S←parse( f) /*S: List of statements */
9 forsinSdo
10 cs←bagOfTokens (s) /*cs: Bag of Tokens of statements */
11 c′s←preprocess (cs)
12 vs←tfIdfVectorizer( c′s) /*vs: Statements Feature Vector */
13 /* Cosine similarity between bug report and statement */
14 sim cos←similarity cosine (vb,vs)
15 wscor e←sim cos×f.score; /* score: Suspicious Value */
16 Wscor e .add(s,wscor e )
17 Sscor e←Wscor e .sort()
18 return Sscor e
(lexically) to collect all its tokens. Due to the specific nature of stack
traces and other code elements which may appear in the bug report,
we use regular expressions to detect stack traces and code elements
to improve the tokenization process, which is based on punctua-
tions, camel case splitting (e.g., findNumber splits into find, number)
as well as snake case splitting (e.g., find_number splits into find,
number). Stop word removal2is then applied before performing
stemming (using the PorterStemmer [ 24]) on all tokens to create
homogeneity with the term’s root (i.e., by conflating variants of the
same term). Each bag of tokens (for the bug report, and for each
statement) is then eventually used to build a feature vector. We use
cosine similarity among the vectors to rank the file statements that
are relevant to the bug report.
Given that we considered kfiles, the statements of each having
their own similarity score with respect to the bug report, we weight
these scores with the suspiciousness score of the associated file.
Eventually, we sort the statements using the weighted scores and
produce a ranked list of code locations (i.e., statements in files) to
be recommended as candidate fault locations.
3.3 Fix Pattern-based Patch Generation
A common, and reliable, strategy in automatic program repair is to
generate concrete patches based on fix patterns [ 26] (also referred
to as fix templates [ 51] or program transformation schemas [ 18]).
Several APR systems [ 14,18,26,31,46,48,49,51,60,73] in the lit-
erature implement this strategy by using diverse sets of fix patterns
obtained either via manual generation or automatic mining of bug
fix datasets. In this work, we consider the pioneer PAR system by
Kim et al. [ 26]. Concretely, we build on kPAR [48], an open-source
Java implementation of PAR in which we included a diverse set of
fix patterns collected from the literature. Table 4 provides an enu-
meration of fix patterns used in this work. For more implementation
details, we refer the reader to our replication package. All tools
and data are released as open source to the community to foster
further research into these directions. As illustrated in Figure 3,
a fix pattern encodes the recipe of change actions that should be
applied to mutate a code element.
2Stop words are from the NTLK framework :https://www.nltk.org/iFixR: Bug Report driven Program Repair ESEC/FSE ’19, August 26–30, 2019, Tallinn, Estonia
Table 4: Fix patterns implemented in iFixR .
Pattern description used by∗Pattern description used by∗
Insert Cast Checker Genesis Mutate Literal Expression SimFix
Insert Null Pointer Checker NPEFix Mutate Method Invocation ELIXIR
Insert Range Checker SOFix Mutate Operator jMutRepair
Insert Missed Statement HDRepair Mutate Return Statement SketchFix
Mutate Conditional Expression ssFix Mutate Variable CapGen
Mutate Data Type AVATAR Move Statement(s) PAR
Remove Statement(s) FixMiner
∗We mention only one example tool even when several tools implement it.
+ if (exp instanceof T) {
...(T) exp...; ......
+ }
Figure 3: Illustration of “Insert Cast Checker” fix pattern.
For a given reported bug, once our fault localizer yields its list
of suspicious statements, iFixR iteratively attempts to select fix
patterns for each statement. The selection of fix patterns is con-
ducted in a naïve way based on the context information of each
suspicious statement (i.e., all nodes in its abstract syntax tree, AST).
Specifically, iFixR parses the code and traverses each node of the
suspicious statement AST from its first child node to its last leaf
node in a breadth-first strategy (i.e, left-to-right and top-to-bottom).
If a node matches the context a fix pattern (i.e., same AST node
types), the fix pattern will be applied to generate patch candidates
by mutating the matched code entity following the recipe in the
fix pattern. Whether the node matches a fix pattern or not, iFixR
keeps traversing its children nodes and searches fix patterns for
them to generate patch candidates successively. This process is
iteratively performed until leaf nodes are encountered.
Consider the example of bug Math-75 illustrated in Figure 4.
iFixR parses the buggy statement (i.e., statement at line 302 in the
fileFrequency.java ) into an AST as illustrated by Figure 5. First,
iFixR matches a fix pattern that can mutate the expression in the
return statement with other expression(s) returning data of type
double . It further selects fix patterns for the direct child node (i.e.,
method invocation: getCumPct((Comparable<?> v)) ) of the re-
turn statement. This method invocation can be matched against fix
patterns with two contexts: method name and parameter(s). With
the breadth-first strategy, iFixR assigns a fix pattern, calling an-
other method with the same parameters (cf. PAR [ 26, page 804]), to
mutate the method name, and then selects fix patterns to mutate the
parameter. Furthermore, iFixR will match fix patterns for the type
and variable of the cast expression respectively and successively.
File: src/main/java/org/apache/commons/math/stat/Frequency.java
Line-301 public double getPct(Object v) {
Line-302 return getCumPct((Comparable<?>) v);
Line-303 }
Figure 4: Buggy code of Defects4J bug Math-75.
3.4 Patch Validation with Regression Testing
For every reported bug, fault localization followed by pattern match-
ing and code mutation will yield a set of patch candidates. In a
typical test-based APR system, these patch candidates must let the
program pass all test cases (including some positive test cases [83],
which encode the actual functional requirements relevant to the
bug). Thus, the patch candidates set is actively pruned to remove
all patches that do not meet these requirements. In our work, in
accordance with our investigation findings that such test cases may
ReturnStatement“raw_code”MethodInvocation“raw_code”MethodName“getCumPct”CastExpression“raw_code”Type“Comparable<?>”VariableName“v”①②③④⑤*“raw_code”denotesthecorrespondingsourcecodeattherelatednodeposition.Figure 5: AST of bug Math-75 source code statement.
not be available at the time the bug is reported (cf. Section 2), we
assume that iFixR cannot reason about future test cases to select
patch candidates.
Instead, we rely only on past test cases, which were available
in the code base, when the bug is reported. Such test cases are
leveraged to perform regression testing [95], which will ensure that,
at least, the selected patches do not obstruct the behavior of the
existing, unchanged part of the software, which is already explicitly
encoded by developers in their current test suite.
3.5 Output: Patch Recommendation List
Eventually, iFixR produces a ranked recommendation list of patch
suggestions for developers. Until now, the order of patches is influ-
enced mainly by two steps in the workflow:
(1)localization: our statement-level IRFL yields a ranked list of
statements to modify in priority.
(2)pattern matching: the AST node of the buggy code entity is
broken down into its children and iteratively navigated in a
breadth-first manner to successively produce candidate patches.
Eventually, the produced list of patches has an order, which carries
the biases of fault localization [ 48], and is noised by the pre-set
breadth-first strategy for matching fix patterns. We thus design an
ordering process with a function3,frcmd : 2P→Pk, as follows:
frcmd(patches)=(pritype◦prisusp◦prichan дe)(patches)(1)
where pri∗are three heuristics-based prioritization functions used
iniFixR .frcmd takes a set of patches validated via regression test-
ing (cf. Section 3.4) and produces an ordered sequence of patches
(frcmd(patches)=seqrcmd∈Pk). We propose the following
heuristics to re-prioritize the patch candidates :
(1)[Minimal changes] : we favor patches that minimize the dif-
ferences between the patched program and the buggy pro-
gram. To that end, patches are ordered following their AST
edit script sizes. Formally, we define prichan дe: 2P→Pn
where n=|patches|,prichan дe(patches)=[pi,pi+1,pi+2,···]
and holds ∀p∈patches ,Cchan дe(pi)≤Cchan дe(pi+1). Here,
Cchan дe(p)is a function that counts the number of deleted and
inserted AST nodes by the change actions of p.
(2)[Fault localization suspiciousness] : when two patch
candidates have equal edit script sizes, the tie is broken by using
the suspiciousness scores (of the associated statements) yielded
during IR-based fault localization. Thus, when Cchan дe(pi)==
Cchan дe(pi+1),prisusp re-orders the two patch candidates. We
define prisusp :Pn→Pnsuch that prisusp(seqchan дe)=
[···,pi,pi+1,···] holds Ssusp(pi)≥Ssusp(pi+1), where
3The domain of the function is a power set 2P, and the co-domain ( Pk) is a k-
dimensional vector space [ 28] where kis the maximum number of recommended
patches, and Pdenotes the set of all generated patches.ESEC/FSE ’19, August 26–30, 2019, Tallinn, Estonia A. Koyuncu et al.
seqchan дeis the result of prichan дeandSsusp returns a suspi-
cious score of the statement that a given patch pichanges.
(3)[Affected code elements] : after a manual analysis of fix pat-
terns and the performance of associated APR in the literature,
we empirically found that some change actions are irrelevant
to bug fixing. Thus, for the corresponding pre-defined patterns,
iFixR systematically under-prioritizes their generated patches
against any other patches, although among themselves the rank-
ing obtained so far (through prichan дeandprisusp) is preserved
for those under-prioritized patches. These are patches gener-
ated by (i) mutating a literal expression, (ii) mutating a variable
into a method invocation or a final static variable, or (iii) insert-
ing a method invocation without parameter. This prioritization,
is defined by pritype:Pn→Pk, which returns a sequence of
topkordered patches ( k≤n=|patches|). To define this priori-
tization function, we assign natural numbers j1,j2,j3,j4∈Nto
each patch generation types (i.e., j1←(i),j2←(ii), and j3←(iii),
respectively) and ( j4←) everything else, which strictly hold
j4>j1,j4>j2,j4>j3. This prioritization function takes the re-
sult of prisusp and returns another sequence [pi,pi+1,pi+2,···]
that holds ∀pi,Dtype(pi)≥Dtype(pi+1).Dtypeis defined as
Dtype: 2P→{j1,j2,j3,j4}and determines how a patch pihas
been generated as defined above. From the ordered sequence,
the function returns the leftmost (i.e., top) kpatches as a result.
4 EXPERIMENTAL SETUP
We now provide details on the experiments that we carry out to
assess the iFixR patch generation pipeline for user-reported bugs.
Notably, we discuss the dataset and benchmark, some implementa-
tion details before enumerating the research questions.
4.1 Dataset & Benchmark
To evaluate iFixR we propose to rely on the Defects4J [ 21] dataset
which is widely used as a benchmark in the Java APR literature.
Nevertheless, given that Defects4J does not provide direct links to
the bug reports that are associated with the benchmark bugs, we
must undertake a fairly accurate bug linking task [ 78]. Furthermore,
to realistically evaluate iFixR , we must reorganize the dataset test
suites to accurately simulate the context at the time the bug report
is submitted by users.
4.1.1 Bug linking. To identify the bug report describing a given bug
in the Defects4J dataset we focus on recovering the links between
the bug fix commits and bug reports from the issue tracking system.
Unfortunately, projects Joda-Time, JFreeChart and Closure have
migrated their source code repositories and issue tracking systems
into GitHub without a proper reassignment of bug report identifiers.
Therefore, for these projects, bug IDs referred to in the commit logs
are ambiguous (for some bugs this may match with the GitHub
issue tracking numbering, while in others, it refers to the original
issue tracker). To avoid introducing noise in our validation data, we
simply drop these projects. For the remaining projects (Lang and
Math), we leverage the bug linking strategies implemented in the
Jira issue tracking software. We use a similar approach to Fischer et
al. [15] and Thomas et al. [ 78] to link to commits to corresponding
bug reports. Concretely, we crawled the bug reports related to each
project and assessed the links with a two-step search strategy: (i)we check commit logs to identify bug report IDs and associate the
corresponding changes as bug fix changes; then (ii) we check for
bug reports that are indeed considered as such (i.e., tagged as "BUG")
and are further marked as resolved (i.e., with tags "RESOLVED" or
"FIXED"), and completed (i.e., with status "CLOSED").
Eventually, our evaluation dataset includes 156 faults (i.e., De-
fects4J bugs). Actually, for the considered projects, Defects4J enu-
merates 171 bugs associated with 162 bug reports : 15 bugs are
indeed left out because either (1) the corresponding bug reports
are not in the desired status in the bug tracking system, which may
lead to noisy data, or (2) there is ambiguity in the buggy program
version (e.g., some fixed files appear to be missing in the repository
at the time of bug reporting).
4.1.2 Test suite reorganization. We ensure that the benchmark sep-
arates past test cases (i.e., regression test cases) from future test
cases (i.e., test cases that encode functional requirements specified
after the bug is reported). This timeline split is necessary to simu-
late the snapshot of the repository at the time the bug is reported.
As highlighted in Section 2, for over 90% cases of bugs in the De-
fects4J benchmark, the test cases relevant to the defective behavior
was actually provided along the bug fixing patches. We have thus
manually split the commits to identify test cases that should be
considered as future test cases for each bug report.
4.2 Implementation Choices
During implementation, we have made the following parameter
choices in the iFixR workflow:
•IR fault localization considers the top 50 (i.e., k=50in Algo-
rithm 1) suspicious files for each bug report, in order to search
for buggy code locations.
•For patch recommendation experiments, we limit the search
space to the top 20 suspected buggy statements yielded by the
fine-grained IR-based fault localization.
•For comparison experiments, we implement spectrum-based fault
localization using the GZoltar testing framework with the Ochiai
ranking strategy. Unless otherwise indicated, GZoltar version
0.1.1 is used (as it is widely adopted in the literature, by Astor [ 59],
ACS [92], ssFix [90] and CapGen [84] among others).
4.3 Research Questions
The assessment objective is to assess the feasibility of automat-
ing the generation of patches for user-reported bugs , while
investigating the foreseen bottlenecks as well as the research direc-
tions that the community must embrace to realize this long-standing
endeavor. To that end, we focus on the following research questions
associated with the different steps in the iFixR workflow.
•RQ1 [Fault localization] : To what extent does IR-based fault local-
ization provide reliable results for an APR scenario? In particular,
we investigate the performance differences when comparing our
fine-grained IRFL implementation against the classical spectrum-
based localization.
•RQ2 [Overfitting] : To what extent does IR-based fault localization
point to locations that are less subject to overfitting? In particular,
we study the impact on the overfitting problem that incomplete
test suites generally carry.iFixR: Bug Report driven Program Repair ESEC/FSE ’19, August 26–30, 2019, Tallinn, Estonia
•RQ3 [Patch ordering] : What is the effectiveness of iFixR ’s patch
ordering strategy? In particular, we investigate the overall work-
flow of iFixR , by re-simulating the real-world cases of software
maintenance cycle when a bug is reported: future test cases are
not available for patch validation.
5 ASSESSMENT RESULTS
In this section, we present the results of the investigations for the
previously-enumerated research questions.
5.1 RQ1: [Fault Localization]
Fault localization being the first step in program repair, we evalu-
ate the performance of the IR-based fault localization developed
within iFixR . As recently thoroughly studied by Liu et al. [ 48],
an APR tool should not be expected to fix a bug that current fault
localization systems fail to localize. Nevertheless, with iFixR , we
must demonstrate that our fine-grained IRFL offers comparable
performance with SBFL tools used in the APR literature.
Table 5 provides performance measurements on the localization
of bugs. SBFL is performed based on two different versions of the
GZoltar testing framework, but always based on the Ochiai ranking
metric. Finally, because fault localization tools output a ranked list
of suspicious statements, results are provided in terms of whether
the correct location is placed under the top-k suspected statements.
In this work, following the practice in the literature [ 48,56], we
consider that a bug is localized if any buggy statement is localized.
Table 5: Fault localization results: IRFL (IR-based) vs. SBFL
(Spectrum-based) on Defects4J (Math and Lang) bugs.
(171 bugs) Top-1 Top-10 Top-50 Top-100 Top-200 All
IRFL 25 72 102 117 121 139
SBFLGZv1 26 75 106 110 114 120
GZv2 23 79 119 135 150 156
†GZv1and GZ v2refer to GZoltar 0.1.1 and 1.6.0 respectively, which are widely used in APR
systems for Java programs.
Overall, the results show that our IRFL implementation is strictly
comparable to the common implementation of spectrum-based
fault localization when applied on the Defects4J bug dataset. Note
that the comparison is conducted for 171 bugs of Math and Lang,
given that these are the projects for which the bug linking can be
reliably performed for applying the IRFL. Although performance
results are similar, we remind the reader that SBFL is applied by
considering future test cases. To highlight a practical interest of
IRFL, we compute for each bug localizable in the top-10, the elapsed
time between the bug report date and the date the relevant test
case is submitted for this bug. Based on the distribution shown in
Figure 6, on mean average, IRFL could reduce this time by 26 days.
Figure 6: Distribution of elapsed time (in days) between bug
report submission and test case attachment.
Finally, to stress the importance of future test cases for spectrum-
based fault localization, we consider all Defects4J bugs and compute
localization performance with and without future test cases.
Results listed in Table 6 confirms that in most bug cases, the
localization is impossible: Only 10 bugs (out of 395) can be localized
among the top-10 suspicious statements of SBFL at the time thebug is reported. In comparison, our IRFL locates 72 bugs under the
same conditions of having no relevant test cases to trigger the bugs.
Table 6: Fault localization performance.
GZoltar + Ochiai (395 bugs) Top-1 Top-10 Top-50 Top-100 Top-200 All
without future tests 5 10 17 17 19 20
with future tests 45 140 198 214 239 263
Fine-grained IR-based fault localization in iFixR is as accurate as
Spectrum-based fault localization in localizing Defects4J bugs. Addi-
tionally, it does not have the constraint of requiring test cases that
may not be available when the bug is reported.
5.2 RQ2: [Overfitting]
Patch generation attempts to mutate suspected buggy code with
suitable fix patterns. Aside from having adequate patterns or not
(which is out of the scope of our study), a common challenge of
APR lies in the effective selection of buggy statements. In typical
test-based APR, test cases drive the selection of these statements.
The incompleteness of test suites is however currently suspected
to often lead to overfitting of generated patches [94].
We perform patch generation experiments to investigate the
impact of localization bias. We compare our IRFL implementation
against commonly-used SBFL implementations in the literature of
test-based APR. We recall that the patch validation step in these
experiments makes no assumptions about future test cases (i.e.,
all test cases are leveraged as in classical APR pipeline). For each
bug, depending on the rank of the buggy statements in the suspi-
cious statements yielded the fault localization system (either IRFL
or SBFL), the patch generation can produce more or less relevant
patches. Table 7 details the repair performance in relation to the
position of buggy statements in the output of fault localization. Re-
sults are provided in terms of numbers of plausible andcorrect [69]
patches that can be found by considering top- kstatements returned
by the fault localizer.
Table 7: IRFL vs. SBFL impacts on the number of generated
correct/plausible patches for Defects4J bugs.
Lang Math Total
IRFL Top-1 1/4 3/4 4/8
SBFL Top-1 1/4 6/8 7/12
IRFL Top-5 3/6 7/14 10/20
SBFL Top-5 2/7 11/17 13/24
IRFL Top-10 4/9 9/17 13/26
SBFL Top-10 4/11 16/27 20/38
IRFL Top-20 7/12 9/18 16/30
SBFL Top-20 4/11 18/30 22/41
IRFL Top-50 7/15 10/22 17/37
SBFL Top-50 4/13 19/34 23/47
IRFL Top-100 8/18 10/23 18/41
SBFL Top-100 5/14 19/36 24/50
IRFL All 11/19 10/25 21/44
SBFL All 5/14 19/36 24/50
∗We indicate x/y numbers of patches: x is the number of bugs for which a correct patch is
generated; y is the number of bugs for which a plausible patch is generated.
Overall, we find that IRFL and SBFL localization information
lead to similar repair performance in terms of the number of fixed
bugs plausibly/correctly. Actually IRFL-supported APR outperforms
SBFL-supported APR on the Lang project bugs and vice-versa for
Math project bugs: overall, 6 bugs that are fixed using IRFL out-
put, cannot be fixed using SBFL output (although assuming the
availability of the bug triggering test cases to run the SBFL tool).ESEC/FSE ’19, August 26–30, 2019, Tallinn, Estonia A. Koyuncu et al.
We investigate the cases of plausible patches in both localization
scenarios to characterize the reasons why these patches appear to
only be overfitting the test suites. Table 8 details the overfitting
reasons for the two scenarios.
Table 8: Dissection of reasons why patches are plausible∗but
not correct.
Localization Error Pattern Prioritization Lack of Fix ingredients
w/ IRFL 6 1 16
w/ SBFL 15 1 10
∗A plausible patch passes all test cases, but may not be semantically equivalent to devel-
oper patch (i.e., correct). We consider a plausible patch to be overfitted to the test suite
(1)Among the 23(=44−21)plausible patches that are generated
based on IRFL identified code locations and that are not found
to be correct, 6 are found to be caused by fault localization
errors: these bugs are plausibly fixed by mutating irrelevantly-
suspicious statements that are placed before the actual buggy
statements in the fault localization output list. This phenom-
enon has been recently investigated in the literature as the
problem of fault localization bias [ 48]. Nevertheless, we note
that patches generated based on SBFL identified code locations
suffer more of fault localization bias: 15 of the 26 (= 50 −24)
plausible patches are concerned by this issue.
(2)Pattern prioritization failures may also lead to plausible patches:
while a correct patch could have been generated using a specific
pattern at a lower node in the AST, another pattern (leading
to an only plausible patch) was first found to be matching the
statement during the iterative search of matching nodes (cf.
Section 3.3).
(3)Finally, we note that both configurations yield plausible patches
due to the lack of suitable patterns or due to a failed search for
the adequate donor code (i.e., fix ingredient [44]).
Experiments with the Defects4J dataset suggest that code locations
provided by IR-based fault localization lead less to overfitted patches
than the code locations suggested by Spectrum-based fault localiza-
tion: cf. "Localization error" column in Table 8.
5.3 RQ3: [Patch Ordering]
While the previous experiment focused on patch generation, our
final experiment assesses the complete pipeline of iFixR as it was
imagined for meeting the constraints that developers can face in
practice: future test cases, i.e., those which encode the functionality
requirements that are not met by the buggy programs, may not
be available at the time the bug is reported. We thus discard the
future test cases of the Defects4J dataset and generate patches that
must be recommended to developers. The evaluation protocol thus
consists in assessing to what extent correct/plausible patches are
placed in the top of the recommendation list.
5.3.1 Overall performance. Table 9 details the performance of the
patch recommendation by iFixR : we present the number of bugs
for which a correct/plausible patch is generated and presented
among the top- kof the list of recommended patches. In the ab-
sence of future test cases to drive the patch validation process, we
use heuristics (cf. Section 4.2) to re-prioritize the patch candidates
towards ensuring that patches which are recommended first will
eventually be correct (or at least plausible when relevant test casesare implemented). We present results both for the case where we
do not re-prioritize and the case where we re-prioritize.
Recall that, given that the re-organized benchmark separately
includes the future test cases, we can leverage them to systematize
the assessment of patch plausibility. The correctness (also referred
to as correctness [69]) of patches, however, is still decided manually
by comparing against the actual bug fix provided by developers
and available in the benchmark. Overall, we note that iFixR perfor-
mance is promising as it manages, for 13 bugs , to present a plausible
patch among its top-5 recommended patches per bug. Among those
plausible patches, 8 are eventually found to be correct.
Table 9: Overall performance of iFixR for patch recommen-
dation on the Defects4J benchmark.
Recommendation rank Top-1 Top-5 Top-10 Top-20 All
without patch re-prioritization 3/3 4/5 6/10 6/10 13/27
with patch re-prioritization 3/4 8/13 9/14 10/15 13/27
∗x/y: x is the number of bugs for which a correct patch is generated; y is the number of
bugs for which a plausible patch is generated.
5.3.2 Comparison with the state-of-the-art test-based APR systems.
To objectively position the performance of iFixR (which does not
require future test cases to localize bugs, generate patches and
present a sorted recommendation list of patches), we count the
number of bugs for which iFixR can propose a correct/plausible
patch. We consider three scenarios with iFixR :
(1)[iFixR top5] - developers will be provided with only top 5 rec-
ommended patches which have been validated only with re-
gression tests: in this case, iFixR outperforms about half of
the state-of-the-art in terms of numbers bugs fixed with both
plausible or correct patches.
(2)[iFixR all] - developers are presented with all (i.e., not only
top-5) generated patches validated with regression tests: in this
case, only four (out of sixteen) state-of-the-art APR techniques
outperform iFixR .
(3)[iFixR opt] - developers are presented with all generated patches
which have been validated with augmented test suites (i.e., opti-
mistically with future test cases): with this configuration, iFixR
outperforms all state-of-the-art, except SimFix [ 19] which uses
sophisticated techniques to improve the fault localization accu-
racy and search for fix ingredients. It should be noted that in
this case, our prioritization strategy is not applied to the gener-
ated patches. iFixR optrepresents the reference performance
for our experiment which assesses the prioritization.
Table 10 provides the comparison matrix. Information on state-
of-the-art results are excerpted from their respective publications.
iFixR offers a reasonable performance in patch recommendation
when we consider the number of Defects4J bugs that are successfully
patched among the top-5 (in a scenario where we assume not having
relevant test cases to validate the patch candidates). Performance
results are even comparable to many state-of-the-art test-based APR
tools in the literature.
5.3.3 Properties of iFixR ’s patches. In Table 11, we characterize
the correct and plausible patches recommended by iFixR top5. Over-
all, update and insert changes have been successful; most patches
affect a single statement, and impact precisely an expression entity
within a statement.iFixR: Bug Report driven Program Repair ESEC/FSE ’19, August 26–30, 2019, Tallinn, Estonia
Table 10: iFixR vs state-of-the-art APR tools.
APR tool Lang∗Math∗Total∗
jGenProg [59] 0/0 5/18 5/18
jKali [59] 0/0 1/14 1/14
jMutRepair [59] 0/1 2/11 2/12
HDRepair [36] 2/6 4/7 6/13
Nopol [93] 3/7 1/21 4/28
ACS [92] 3/4 12/16 15/20
ELIXIR [73] 8/12 12/19 20/31
JAID [12] 1/8 1/8 2/16
ssFix [90] 5/12 10/26 15/38
CapGen [84] 5/5 12/16 17/21
SketchFix [18] 3/4 7/8 10/12
FixMiner [31] 2/3 12/14 14/17
LSRepair [44] 8/14 7/14 15/28
SimFix [19] 9/13 14/26 23 /39
kPAR [48] 1/8 7/18 8/26
AVATAR [49] 5/11 6/13 11/24
iFixR opt 11/19 10/25 21/ 44
iFixR all 6/11 7/16 13/27
iFixR top 5 3/7 5/6 8/13
∗x/y: x is the number of bugs for which a correct patch is generated; y is the number of bugs
for which a plausible patch is generated.
iFixR opt: the version of iFixR where available test cases are relevant to the bugs.
iFixR all: all recommended patches are considered.
iFixR top 5: only top 5 recommended patches are considered.
Table 11: Change properties of iFixR ’s correct patches.
Change action #bugs∗Impacted statement(s) #bugs∗Granularity #bugs∗
Update 5/7 Single-statement 8/12 Statement 1/2
Insert 3/5 Multiple-statement 0/1 Expression 7/11
Delete 0/1
∗x/y−→ for x bugs the patches are correct, while for y bugs they are plausible.
5.3.4 Diversity of iFixR ’s fixed bugs. Finally, in Table 12 we dissect
the nature of the bugs for which iFixR top5is able to recommend
a correct or a plausible patch. Priority information about the bug
report is collected from the issue tracking systems, while the root
cause is inferred by analyzing the bug reports and fixes.
Table 12: Dissection of bugs successfully fixed by iFixR .
Patch
TypeDefect4J
Bug IDIssue ID Root Cause Priority
G L-6 LANG-857 String index out of bounds exception Minor
G L-24 LANG-664 Wrong behavior due missing condition Major
G L-57 LANG-304 Null pointer exception Major
G M-15 MATH-904 Double precision floating point format error Major
G M-34 MATH-779 Missing "read only access" to internal list Major
G M-35 MATH-776 Range check Major
G M-57 MATH-546 Wrong variable type truncates double value Minor
G M-75 MATH-329 Method signature mismatch Minor
P L-13 LANG-788 Serialization error in primitive types Major
P L-21 LANG-677 Wrong Date Format in comparison Major
P L-45 LANG-419 Range check Minor
P L-58 LANG-300 Number formatting error Major
P M-2 MATH-1021 Integer overflow Major
“G” denotes correct patch and “P” means plausible patch.
Overall, we note that 9 out of the 13 bugs have been marked as
Major issues. 12 different bug types (i.e., root causes) are addressed.
In contrast, R2Fix [43] only focused on 3 simple bug types.
6 DISCUSSION
This study presents the conclusions of our investigation into the
feasibility of generating patches automatically from bug reports.
We set strong constraints on the absence of test cases, which are
used in test-based APR to approximate what the program is actually
supposed to do and when the repair is completed [83]. Our exper-
iments on the widely-used Defects4J bugs eventually show that
patch generation without bug-triggering test cases is promising.
Manually looking at the details of failures and success in gener-
ating patches with iFixR , several insights can be drawn:
Test cases can be buggy: During manual analysis of results, we
noted that iFixR actually fails to generate correct patches for threebugs (namely, Math-5, Math-59 and Math-65) because even the test
cases were buggy. Figure 7 illustrates the example of bug Math-5
where its patch also updated the relevant test case. This example
supports our endeavor, given that users would find and report bugs
for which the appropriate test cases were never properly written.
//Patched Source Code:
--- a/src/main/java/org/apache/commons/math3/complex/Complex.java
+++ b/src/main/java/org/apache/commons/math3/complex/Complex.java
@@ -304,3 +304,3 @@ public class Complex
if (real == 0.0 && imaginary == 0.0) {
- return NaN;
+ return INF;
}
//Patched Test Case:
--- a/src/test/java/org/apache/commons/math3/complex/ComplexTest.java
+++ b/src/test/java/org/apache/commons/math3/complex/ComplexTest.java
@@ -333,3 +333,3 @@ public class ComplexTest {
public void testReciprocalZero() {
- Assert.assertEquals(Complex.ZERO.reciprocal(), Complex.NaN);
+ Assert.assertEquals(Complex.ZERO.reciprocal(), Complex.INF);
}
Figure 7: Patched source code and test case of fixing Math-5.
Bug reports deserve more interest: With iFixR , we have shown
that bug reports could be handled automatically for a variety of
bugs. This is an opportunity for issue trackers to add a recom-
mendation layer to the bug triaging process by integrating patch
generation techniques. There are, however, several directions to
further investigation, among which: (1) help users write proper bug
reports; and (2) re-investigate IRFL techniques at a finer-grained
level that is suitable for APR.
Prioritization techniques must be investigated: In the absence
of complete test suites for validating every single patch candidate, a
recommendation system must ensure that patches presented first to
the developers are the most likely to be plausible and even correct.
There are thus two directions of research that are promising: (1)
ensure that fix patterns are properly prioritized to generate good
patches and be able to early-stop for not exploding the search space;
and (2) ensure that candidate patches are effectively re-prioritized.
These investigations must start with a thorough dissection of plau-
sible patches for a deep understanding of plausibility factors.
More sophisticated approaches to triaging and selecting fix
ingredients are necessary: In its current form, iFixR implements
a naïve approach to patch generation, ensuring that the perfor-
mance is tractable. However, the literature already includes novel
APR techniques that implement strategies for selecting donor code
and filters patterns. Integrating such techniques into iFixR may
lead to performance improvement.
More comprehensive benchmarks are needed: Due to bug link-
ing challenges, our experiments were only performed on half of
the Defects4J benchmark. To drive strong research in patch genera-
tion for user-reported bugs, the community must build larger and
reliable benchmarks, potentially even linking several artifacts of
continuous integration (i.e, build logs, past execution traces, etc.).
In the future, we plan to investigate the dataset of Bugs.jar [71].
Automatic test generation techniques could be used as a sup-
plement: Our study tries to cope radically with the incompleteness
of test suites. In the future, however, we could investigate the use of
automatic test generation techniques to supplement the regression
test cases during patch validation.ESEC/FSE ’19, August 26–30, 2019, Tallinn, Estonia A. Koyuncu et al.
7 THREATS TO VALIDITY
Threats to external validity: The bug reports used in this study
may be of low quality (i.e., wrong links for corresponding bugs).
We reduced this threat by focusing only on bugs from the Lang
and Math projects, which kept a single issue tracking system. We
also manually verified the links between the bug reports and the
Defects4J bugs. Table 13 characterizes the bug reports of our dataset
following the criteria enumerated by Zimmermann et al. [ 100] in
their study of “what makes a good bug report”. Notably, as illus-
trated by the distribution of comments in Figure 8, we note that
the bug reports have been actively discussed before being resolved.
This suggests that they are not trivial cases (cf. [ 17] on measuring
bug report significance).
Table 13: Dissection of bug reports related to Defects4J bugs.
Proj.Unique
Bug Reportsw/ Patch
AttachedAverage
Commentsw/ Stack
Tracesw/
Hintsw/ Code
Blocks
Lang 62 11 4.53 4 62 31
Math 100 23 5.15 5 92 51
Code-related terms such as package/class names found in the summary and description, in
addition to stack traces and code blocks, as separate features referred to as hints.
Figure 8: Distribution of # of comments per bug report.
Another threat to external validity relates to the diversity of the
fix patterns used in this study. iFixR currently may not implement
a reasonable number of relevant fix patterns. We minimize this
threat by surveying the literature and considering patterns from
several pattern-based APR.
Threats to internal validity: Our implementation of fine-grained
IRFL carries some threats: during the search of buggy statements,
we considered top-50 suspicious buggy files from the file-level IRFL
tool, to limit the search space. Different threshold values may lead
to different results. We also considered only 5 statement types as
more bug-prone. This second threat is minimized by the empirical
evidence provided by Liu et al. [47].
Additionally, another internal threat is in our patch generation
steps: iFixR only searches for donor code from the local code files,
which contain the buggy statement. The adequate fix ingredient
may however be located elsewhere.
Threats to construct validity: In this study, we assumed that
patch construction and test case creation are two separated tasks
for developers. This may not be the case in practice. The threat is
however mitigated given that, in any case, we have shown that the
test cases are often unavailable when the bug is reported.
8 RELATED WORK
Fault Localization. As stated in a recent study [ 48], fault local-
ization is a critical task affecting the effectiveness of automated
program repair. Several techniques have been proposed [ 67,80,88]
and they use different information such as spectrum [4], text [85],
slice [ 58], and statistics [ 42]. The first two types of techniques
are widely studies in the community. SBFL techniques [ 3,20] are
widely adopted in APR pipelines since they identify bug positions
at a fine-grained level (i.e., statements). However, they have limita-
tions on localizing buggy locations since it highly relies on the testsuite [ 48]. Information retrieval based fault localization (IRFL) [ 41]
leverages textual information in a bug report. It is mainly used to
help developers narrow down suspected buggy files in the absence
of relevant test cases. For the purpose of our study, we have pro-
posed an algorithm for further localizing the faulty code entities at
the statement level.
Patch Generation. Patch generation is another key process of
APR pipeline, which is, in other words, a task searching for another
shape of a program (i.e., a patch) in the space of all possible pro-
grams [ 37,54]. To improve repair performance, many APR systems
have been explored to address the search space problem by using
different information and approaches: stochastic mutation [ 38,83],
synthesis [ 53,92,93], pattern [ 14,18,19,26,32,36,49,51,52,73],
contract [ 12,82], symbolic execution [ 65], learning [ 8,16,55,70,
77,86], and donor code searching [ 25,62]. In this paper, patch gen-
eration is implemented with fix patterns presented in the literature
since it may make the generated patches more robust [74].
Patch Validation. The ultimate goal of APR systems is to auto-
matically generate a correct patch that can actually resolve the
program defects rather than satisfying minimal functional con-
straints. At the beginning, patch correctness is evaluated by passing
all test cases [ 26,36,83]. However, these patches could be overfit-
ting [ 34,69] and even worse than the bug [ 76]. Since then, APR
systems are evaluated with the precision of generating correct
patches [ 19,49,84,92]. Recently, researchers explore automated
frameworks that can identify patch correctness for APR systems au-
tomatically [ 35,91]. In this paper, our approach validates generated
patches with regression test suites since fail-inducing test cases are
readily available for most of bugs as described in Section 2.
9 CONCLUSION
In this study, we have investigated the feasibility of automating
patch generation from bug reports. To that end, we implemented
iFixR , an APR pipeline variant adapted to the constraints of test
cases unavailability when users report bugs. The proposed system
revisits the fundamental steps, notably fault localization, patch
generation and patch validation, which are all tightly-dependent to
thepositive test cases [83] in a test-based APR system.
Without making any assumptions on the availability of test cases,
we demonstrate, after re-organizing the Defects4J benchmark, that
iFixR can generate and recommend priority correct (and more
plausible) patches for a diverse set of user-reported bugs. The repair
performance of iFixR is even found to be comparable to that of
the majority of test-based APR systems on the Defects4J dataset.
We open source iFixR ’s code and release all data of this study
to facilitate replication and encourage further research in this di-
rection which is promising for practical adoption in the software
development community:
https://github.com/SerVal-DTF/iFixR
ACKNOWLEDGMENTS
This work is supported by the Fonds National de la Recherche
(FNR), Luxembourg, through RECOMMEND 15/IS/10449467 and
FIXPATTERN C15/IS/9964569.iFixR: Bug Report driven Program Repair ESEC/FSE ’19, August 26–30, 2019, Tallinn, Estonia
REFERENCES
[1] 2019. D&C. https://github.com/d-and-c/d-and-c.
[2]Rui Abreu, Arjan JC Van Gemund, and Peter Zoeteweij. 2007. On the accuracy
of spectrum-based fault localization. In Proceedings of TAICPART-MUTATION .
IEEE, 89–98.
[3]Rui Abreu, Peter Zoeteweij, Rob Golsteijn, and Arjan JC Van Gemund. 2009.
A practical evaluation of spectrum-based fault localization. JSS82, 11 (2009),
1780–1792.
[4]Rui Abreu, Peter Zoeteweij, and Arjan JC Van Gemund. 2009. Spectrum-based
multiple fault localization. In Proceedings of the 24th ASE . IEEE, 88–99.
[5]John Anvik, Lyndon Hiew, and Gail C Murphy. 2006. Who should fix this bug?.
InProceedings of the 28th ICSE . ACM, 361–370.
[6]Kent Beck. 2003. Test-driven development: by example . Addison-Wesley Profes-
sional.
[7]Moritz Beller, Georgios Gousios, Annibale Panichella, and Andy Zaidman. 2015.
When, how, and why developers (do not) test in their IDEs. In Proceedings of
the 10th FSE . ACM, 179–190.
[8]Sahil Bhatia, Pushmeet Kohli, and Rishabh Singh. 2018. Neuro-symbolic program
corrector for introductory programming assignments. In Proceedings of the 40th
ICSE . ACM, 60–70.
[9]Tegawendé F Bissyandé. 2015. Harvesting Fix Hints in the History of Bugs.
arXiv preprint arXiv:1507.05742 (2015).
[10] Marcel Böhme, Ezekiel O Soremekun, Sudipta Chattopadhyay, Emamurho
Ugherughe, and Andreas Zeller. 2017. Where is the bug and how is it fixed? an
experiment with practitioners. In Proceedings of the 11th FSE . ACM, 117–128.
[11] José Campos, André Riboira, Alexandre Perez, and Rui Abreu. 2012. Gzoltar:
an eclipse plug-in for testing and debugging. In Proceedings of the 27th ASE .
IEEE/ACM, 378–381.
[12] Liushan Chen, Yu Pei, and Carlo A Furia. 2017. Contract-based program repair
without the contracts. In Proceedings of the 32nd ASE . IEEE, 637–647.
[13] Zack Coker and Munawar Hafiz. 2013. Program transformations to fix C integers.
InProceedings of the 35th ICSE . IEEE/ACM, 792–801.
[14] Thomas Durieux, Benoit Cornu, Lionel Seinturier, and Martin Monperrus. 2017.
Dynamic patch generation for null pointer exceptions using metaprogramming.
InProceedings of the 24th SANER . IEEE, 349–358.
[15] Michael Fischer, Martin Pinzger, and Harald Gall. 2003. Populating a release
history database from version control and bug tracking systems. In Proceeding
of the 19th ICSM . IEEE, 23–32.
[16] Rahul Gupta, Soham Pal, Aditya Kanade, and Shirish Shevade. 2017. DeepFix:
Fixing Common C Language Errors by Deep Learning. In Proceedings of the 31st
AAAI . AAAI Press, 1345–1351.
[17] Pieter Hooimeijer and Westley Weimer. 2007. Modeling bug report quality. In
Proceedings of the 22nd ASE . ACM, 34–43.
[18] Jinru Hua, Mengshi Zhang, Kaiyuan Wang, and Sarfraz Khurshid. 2018. Towards
practical program repair with on-demand candidate generation. In Proceedings
of the 40th ICSE . ACM, 12–23.
[19] Jiajun Jiang, Yingfei Xiong, Hongyu Zhang, Qing Gao, and Xiangqun Chen.
2018. Shaping Program Repair Space with Existing Patches and Similar Code.
InProceedings of the 27th ISSTA . ACM, 298–309.
[20] James A Jones and Mary Jean Harrold. 2005. Empirical evaluation of the tarantula
automatic fault-localization technique. In Proceedings of the 20th ASE . ACM,
273–282.
[21] René Just, Darioush Jalali, and Michael D Ernst. 2014. Defects4J: A database
of existing faults to enable controlled testing studies for Java programs. In
Proceedings of the 23rd ISSTA . ACM, 437–440.
[22] René Just, Chris Parnin, Ian Drosos, and Michael D Ernst. 2018. Comparing
developer-provided to user-provided tests for fault localization and automated
program repair. In Proceedings of the 27th ACM SIGSOFT International Symposium
on Software Testing and Analysis . ACM, 287–297.
[23] Natalia Juristo Juzgado, Ana María Moreno, and Wolfgang Strigel. 2006. Guest
editors’ introduction: Software testing practices in industry. IEEE Software 23, 4
(2006), 19–21.
[24] Wahiba Ben Abdessalem Karaa and Nidhal Gribâa. 2013. Information retrieval
with porter stemmer: a new version for English. In Advances in computational
science, engineering and information technology . Springer, 243–254.
[25] Yalin Ke, Kathryn T Stolee, Claire Le Goues, and Yuriy Brun. 2015. Repairing
programs with semantic code search (t). In Proceedings of the 30th ASE . IEEE,
295–306.
[26] Dongsun Kim, Jaechang Nam, Jaewoo Song, and Sunghun Kim. 2013. Automatic
patch generation learned from human-written patches. In Proceedings of the
35th ICSE . IEEE, 802–811.
[27] Pavneet Singh Kochhar, Tegawendé F Bissyandé, David Lo, and Lingxiao Jiang.
2013. An empirical study of adoption of software testing in open source projects.
InProceedings of the 13th QRS . IEEE, 103–112.
[28] A. N. Kolmogorov and S. V. Fomin. 1999. Elements of the Theory of Functions
and Functional Analysis (dover books on mathematics edition ed.). Dover Publi-
cations, Mineola, NY.[29] Anil Koyuncu, Tegawendé F Bissyandé, Dongsun Kim, Jacques Klein, Martin
Monperrus, and Yves Le Traon. 2017. Impact of tool support in patch construc-
tion. In Proceedings of the 26th ISSTA . ACM, 237–248.
[30] Anil Koyuncu, Tegawendé F Bissyandé, Dongsun Kim, Kui Liu, Jacques Klein,
Martin Monperrus, and Yves Le Traon. 2019. D&C: A Divide-and-Conquer
Approach to IR-based Bug Localization. arXiv preprint arXiv:1902.02703 (2019).
[31] Anil Koyuncu, Kui Liu, Tegawendé F. Bissyandé, Dongsun Kim, Jacques Klein,
Martin Monperrus, and Yves Le Traon. 2018. FixMiner: Mining Relevant Fix
Patterns for Automated Program Repair. arXiv preprint arXiv:1810.01791 (2018).
[32] Xuan-Bach D Le, Duc-Hiep Chu, David Lo, Claire Le Goues, and Willem Visser.
2017. S3: syntax-and semantic-guided repair synthesis via programming by
examples. In Proceedings of the 11th FSE . ACM, 593–604.
[33] Xuan-Bach D Le, Quang Loc Le, David Lo, and Claire Le Goues. 2016. Enhancing
automated program repair with deductive verification. In Proceedings of the
32nd ICSME . IEEE, 428–432.
[34] Xuan Bach D Le, Ferdian Thung, David Lo, and Claire Le Goues. 2018. Overfitting
in semantics-based automated program repair. EMSE Journal (2018), 1–27.
[35] Xuan-Bach D. Le, Lingfeng Bao, David Lo, Xin Xia, and Shanping Li. 2019. On
Reliability of Patch Correctness Assessment. In Proceedings of the 41st ICSE .
[36] Xuan-Bach D. Le, David Lo, and Claire Le Goues. 2016. History Driven Program
Repair. In Proceedings of the 23rd SANER , Vol. 1. IEEE, 213–224.
[37] Claire Le Goues, Michael Dewey-Vogt, Stephanie Forrest, and Westley Weimer.
2012. A systematic study of automated program repair: Fixing 55 out of 105
bugs for $8 each. In Proceedings of the 34th ICSE . IEEE, 3–13.
[38] Claire Le Goues, ThanhVu Nguyen, Stephanie Forrest, and Westley Weimer.
2012. GenProg: A generic method for automatic software repair. TSE 38, 1
(2012), 54–72.
[39] Claire Le Goues, ThanhVu Nguyen, Stephanie Forrest, and Westley Weimer.
2012. GenProg: A Generic Method for Automatic Software Repair. TSE38, 1
(2012), 54–72.
[40] Claire Le Goues and Westley Weimer. 2009. Specification mining with few false
positives. In Proceedings of the 15th TACAS . Springer, 292–306.
[41] Jaekwon Lee, Dongsun Kim, Tegawendé F Bissyandé, Woosung Jung, and Yves
Le Traon. 2018. Bench4bl: reproducibility study on the performance of ir-based
bug localization. In Proceedings of the 27th ISSTA . ACM, 61–72.
[42] Ben Liblit, Mayur Naik, Alice X Zheng, Alex Aiken, and Michael I Jordan. 2005.
Scalable statistical bug isolation. In Proceedings of the 26th PLDI . ACM, 15–26.
[43] Chen Liu, Jinqiu Yang, Lin Tan, and Munawar Hafiz. 2013. R2Fix: Automatically
generating bug fixes from bug reports. In Proceedings of the 6th ICST . IEEE,
282–291.
[44] Kui Liu, Koyuncu Anil, Kisub Kim, Dongsun Kim, and Tegawendé F. Bissyandé.
2018. LSRepair: Live Search of Fix Ingredients for Automated Program Repair.
InProceedings of the 25th APSEC . IEEE, 658–662.
[45] Kui Liu, Dongsun Kim, Tegawendé F. Bissyandé, Taeyoung Kim, Kisub Kim, Anil
Koyuncu, Suntae Kim, and Yves Le Traon. 2019. Learning to Spot and Refactor
Inconsistent Method Names. In Proceedings of the 41st ICSE . IEEE, 1–12.
[46] Kui Liu, Dongsun Kim, Tegawendé F Bissyandé, Shin Yoo, and Yves Le Traon.
2018. Mining fix patterns for findbugs violations. TSE(2018).
[47] Kui Liu, Dongsun Kim, Anil Koyuncu, Li Li, Tegawendé F Bissyandé, and Yves
Le Traon. 2018. A closer look at real-world patches. In Proceedings of the 34th
ICSME . IEEE, 275–286.
[48] Kui Liu, Anil Koyuncu, Tegawendé F. Bissyandé, Dongsun Kim, Jacques Klein,
and Yves Le Traon. 2019. You Cannot Fix What You Cannot Find! An Investi-
gation of Fault Localization Bias in Benchmarking Automated Program Repair
Systems. In Proceedings of the 12th ICST . IEEE, 102–113.
[49] Kui Liu, Anil Koyuncu, Dongsun Kim, and Tegawendé F. Bissyandé. 2019.
AVATAR: Fixing Semantic Bugs with Fix Patterns of Static Analysis Violations.
InProceedings of the 26th SANER . IEEE, 1–12.
[50] Kui Liu, Anil Koyuncu, Dongsun Kim, and Tegawendé F. Bissyandé. 2019. TBar
: Revisiting Template-based Automated Program Repair. In Proceedings of the
28th ISSTA . ACM.
[51] Xuliang Liu and Hao Zhong. 2018. Mining stackoverflow for program repair. In
Proceedings of the 25th SANER . IEEE, 118–129.
[52] Fan Long, Peter Amidon, and Martin Rinard. 2017. Automatic inference of code
transforms for patch generation. In Proceedings of the 11th FSE . ACM, 727–739.
[53] Fan Long and Martin Rinard. 2015. Staged program repair with condition
synthesis. In Proceedings of the 10th FSE . ACM, 166–178.
[54] Fan Long and Martin Rinard. 2016. An analysis of the search spaces for generate
and validate patch generation systems. In Proceedings of the 38th ICSE . ACM,
702–713.
[55] Fan Long and Martin Rinard. 2016. Automatic patch generation by learning
correct code. In Proceedings of the 43rd POPL . ACM, 298–312.
[56] Lucia LUCIA, Ferdian Thung, David Lo, and Lingxiao Jiang. 2012. Are Faults
Localizable?. In Proceedings of the 9th MSR . 74–77.
[57] Stacy K Lukins, Nicholas A Kraft, and Letha H Etzkorn. 2010. Bug localization
using latent Dirichlet allocation. IST52, 9 (2010), 972–990.
[58] Xiaoguang Mao, Yan Lei, Ziying Dai, Yuhua Qi, and Chengsong Wang. 2014.
Slice-based statistical fault localization. JSS89 (2014), 51–62.ESEC/FSE ’19, August 26–30, 2019, Tallinn, Estonia A. Koyuncu et al.
[59] Matias Martinez and Martin Monperrus. 2016. Astor: A program repair library
for java. In Proceedings of the 25th ISSTA . ACM, 441–444.
[60] Matias Martinez and Martin Monperrus. 2018. Ultra-Large Repair Search Space
with Automatically Mined Templates: The Cardumen Mode of Astor. In Pro-
ceedings of the 10th SSBSE . Springer, 65–86.
[61] Sergey Mechtaev, Manh-Dung Nguyen, Yannic Noller, Lars Grunske, and Abhik
Roychoudhury. 2018. Semantic Program Repair Using a Reference Implementa-
tion. In Proceedings of the 40th ICSE . ACM, 298–309.
[62] Sergey Mechtaev, Jooyong Yi, and Abhik Roychoudhury. 2015. Directfix: Look-
ing for simple program repairs. In Proceedings of the 37th ICSE . IEEE Press,
448–458.
[63] Martin Monperrus. 2014. A critical review of automatic patch generation learned
from human-written patches: essay on the problem statement and the evaluation
of automatic software repair. In Proceedings of the 36th ICSE . ACM, 234–242.
[64] Mathieu Nayrolles and Abdelwahab Hamou-Lhadj. 2018. CLEVER: combining
code metrics with clone detection for just-in-time fault prevention and resolution
in large industrial projects. In Proceedings of the 15th MSR . ACM, 153–164.
[65] Hoang Duong Thien Nguyen, Dawei Qi, Abhik Roychoudhury, and Satish
Chandra. 2013. SemFix: program repair via semantic analysis. In Proceedings of
the 35th ICSE . IEEE, 772–781.
[66] Yoann Padioleau, Julia Lawall, René Rydhof Hansen, and Gilles Muller. 2008.
Documenting and automating collateral evolutions in Linux device drivers. In
Proceedings of 3rd EuroSys , Vol. 42. ACM, 247–260.
[67] Chris Parnin and Alessandro Orso. 2011. Are automated debugging techniques
actually helping programmers?. In Proceedings of the 20th ISSTA . ACM, 199–209.
[68] Jean Petrić, Tracy Hall, and David Bowes. 2018. How Effectively Is Defective
Code Actually Tested?: An Analysis of JUnit Tests in Seven Open Source Systems.
InProceedings of the 14th PROMISE . ACM, 42–51.
[69] Zichao Qi, Fan Long, Sara Achour, and Martin Rinard. 2015. An analysis of
patch plausibility and correctness for generate-and-validate patch generation
systems. In Proceedings of the 24th ISSTA . ACM, 24–36.
[70] Reudismam Rolim, Gustavo Soares, Loris D’Antoni, Oleksandr Polozov, Sumit
Gulwani, Rohit Gheyi, Ryo Suzuki, and Björn Hartmann. 2017. Learning syn-
tactic program transformations from examples. In Proceedings of the 39th ICSE .
IEEE/ACM, 404–415.
[71] Ripon Saha, Yingjun Lyu, Wing Lam, Hiroaki Yoshida, and Mukul Prasad. 2018.
Bugs.jar: a large-scale, diverse dataset of real-world java bugs. In Proceedings of
the 15th MSR . IEEE, 10–13.
[72] Ripon K Saha, Matthew Lease, Sarfraz Khurshid, and Dewayne E Perry. 2013.
Improving bug localization using structured information retrieval. In Proceedings
of the 28th ASE . IEEE, 345–355.
[73] Ripon K Saha, Yingjun Lyu, Hiroaki Yoshida, and Mukul R Prasad. 2017. ELIXIR:
Effective object-oriented program repair. In Proceedings of the 32nd ASE . IEEE,
648–659.
[74] Eric Schulte, Zachary P Fry, Ethan Fast, Westley Weimer, and Stephanie Forrest.
2014. Software mutational robustness. Genetic Programming and Evolvable
Machines 15, 3 (2014), 281–312.
[75] Andrew Scott, Johannes Bader, and Satish Chandra. 2019. Getafix: Learning to
fix bugs automatically. arXiv preprint arXiv:1902.06111 (2019).
[76] Edward K Smith, Earl T Barr, Claire Le Goues, and Yuriy Brun. 2015. Is the cure
worse than the disease? Overfitting in automated program repair. In Proceedings
of the 10th FSE . ACM, 532–543.
[77] Mauricio Soto and Claire Le Goues. 2018. Using a probabilistic model to predict
bug fixes. In Proceedings of the 25th SANER . IEEE, 221–231.
[78] Stephen W Thomas, Meiyappan Nagappan, Dorothea Blostein, and Ahmed E
Hassan. 2013. The impact of classifier configuration and classifier combination
on bug localization. TSE39, 10 (2013), 1427–1443.
[79] Simon Urli, Zhongxing Yu, Lionel Seinturier, and Martin Monperrus. 2018.
How to design a program repair bot?: insights from the repairnator project. In
Proceedings of the 40th ICSE . ACM, 95–104.[80] Qianqian Wang, Chris Parnin, and Alessandro Orso. 2015. Evaluating the
usefulness of IR-based fault localization techniques. In Proceedings of the 24th
ISSTA . ACM, 1–11.
[81] Shaowei Wang and David Lo. 2014. Version History, Similar Report, and Struc-
ture: Putting Them Together for Improved Bug Localization. In Proceedings of
the 22nd ICPC . ACM, 53–63.
[82] Yi Wei, Yu Pei, Carlo A Furia, Lucas S Silva, Stefan Buchholz, Bertrand Meyer,
and Andreas Zeller. 2010. Automated fixing of programs with contracts. In
Proceedings of the 19th ISSTA . ACM, 61–72.
[83] Westley Weimer, ThanhVu Nguyen, Claire Le Goues, and Stephanie Forrest.
2009. Automatically finding patches using genetic programming. In Proceedings
of the 31st ICSE . IEEE, 364–374.
[84] Ming Wen, Junjie Chen, Rongxin Wu, Dan Hao, and Shing-Chi Cheung. 2018.
Context-Aware Patch Generation for Better Automated Program Repair. In
Proceedings of the 40th ICSE . IEEE/ACM, 1–11.
[85] Ming Wen, Rongxin Wu, and Shing-Chi Cheung. 2016. Locus: Locating bugs
from software changes. In Proceedings of the 31st ASE . IEEE, 262–273.
[86] Martin White, Michele Tufano, Matias Martinez, Martin Monperrus, and Denys
Poshyvanyk. 2019. Sorting and Transforming Program Repair Ingredients via
Deep Learning Code Similarities. In Proceedings of the 26th SANER . IEEE.
[87] Chu-Pan Wong, Yingfei Xiong, Hongyu Zhang, Dan Hao, Lu Zhang, and Hong
Mei. 2014. Boosting Bug-Report-Oriented Fault Localization with Segmentation
and Stack-Trace Analysis. In Proceedings of the 30th ICSME . IEEE, 181–190.
[88] W Eric Wong, Ruizhi Gao, Yihao Li, Rui Abreu, and Franz Wotawa. 2016. A
survey on software fault localization. TSE42, 8 (2016), 707–740.
[89] Qi Xin and Steven P Reiss. 2017. Identifying test-suite-overfitted patches through
test case generation. In Proceedings of the 26th ISSTA . ACM, 226–236.
[90] Qi Xin and Steven P Reiss. 2017. Leveraging syntax-related code for automated
program repair. In Proceedings of the 32nd ASE . IEEE/ACM, 660–670.
[91] Yingfei Xiong, Xinyuan Liu, Muhan Zeng, Lu Zhang, and Gang Huang. 2018.
Identifying patch correctness in test-based program repair. In Proceedings of the
40th ICSE . ACM, 789–799.
[92] Yingfei Xiong, Jie Wang, Runfa Yan, Jiachen Zhang, Shi Han, Gang Huang, and
Lu Zhang. 2017. Precise condition synthesis for program repair. In Proceedings
of the 39th ICSE . IEEE/ACM, 416–426.
[93] Jifeng Xuan, Matias Martinez, Favio DeMarco, Maxime Clement, Sebastian Lame-
las Marcote, Thomas Durieux, Daniel Le Berre, and Martin Monperrus. 2017.
Nopol: Automatic repair of conditional statement bugs in java programs. TSE
43, 1 (2017), 34–55.
[94] Jinqiu Yang, Alexey Zhikhartsev, Yuefei Liu, and Lin Tan. 2017. Better test
cases for better automated program repair. In Proceedings of the 11th FSE . ACM,
831–841.
[95] Shin Yoo and Mark Harman. 2012. Regression testing minimization, selection
and prioritization: a survey. STVR 22, 2 (2012), 67–120.
[96] Klaus Changsun Youm, June Ahn, and Eunseok Lee. 2017. Improved bug local-
ization based on code change histories and bug reports. IST82 (2017), 177–192.
[97] Zhongxing Yu, Matias Martinez, Benjamin Danglot, Thomas Durieux, and Mar-
tin Monperrus. 2017. Test case generation for program repair: A study of
feasibility and effectiveness. arXiv preprint arXiv:1703.00198 (2017).
[98] Zhongxing Yu, Matias Martinez, Benjamin Danglot, Thomas Durieux, and Mar-
tin Monperrus. 2018. Alleviating patch overfitting with automatic test genera-
tion: a study of feasibility and effectiveness for the Nopol repair system. EMSE
Journal (2018), 1–35.
[99] Jian Zhou, Hongyu Zhang, and David Lo. 2012. Where should the bugs be
fixed? more accurate information retrieval-based bug localization based on bug
reports. In Proceedings of the 34th ICSE . IEEE, 14–24.
[100] Thomas Zimmermann, Rahul Premraj, Nicolas Bettenburg, Sascha Just, Adrian
Schroter, and Cathrin Weiss. 2010. What makes a good bug report? TSE36, 5
(2010), 618–643.