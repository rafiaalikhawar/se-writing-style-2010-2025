UI Driven Android Application Reduction
Jianjun Huang1, Y ousra Aafer1, David Perry1, Xiangyu Zhang1,C h e nT i a n2
1. Department of Computer Science, Purdue University, USA 2. Huawei R&D, USA
{huang427, yaafer, perry74}@purdue.edu, xyzha ng@cs.purdue.edu, chen.tian@huawei.com
Abstract —While smartphones and mobile apps have been an
integral part of our life, modern mobile apps tend to contain a lot
of rarely used functionalities. For example, applications containadvertisements and offer extra features such as recommendednews stories in weather apps. While these functionalities are notessential to an app, they nonetheless consume power, CPU cyclesand bandwidth. In this paper, we design a UI driven approachthat allows customizing an Android app by removing its un-wanted functionalities. In particular, our technique displays theUI and allows the user to select elements denoting functionalitiesthat she wants to remove. Using this information, our techniqueautomatically removes all the code elements related to the selectedfunctionalities, including all the relevant background tasks. Theunderlying analysis is a type system, in which each code elementis tagged with a type indicating if it should be removed. From theUI hints, our technique infers types for all other code elementsand reduces the app accordingly. We implement a prototype andevaluate it on 10 real-world Android apps. The results showthat our approach can accurately discover the removable codeelements and lead to substantial resource savings in the reducedapps.
I. I NTRODUCTION
Smartphone apps have become an integral part of our
daily life [1]. However, apps tend to contain a lot of rarely
used functionalities. For example, advertisements are reportedto appear in more than 50% of Android apps [2]. As ad
libraries are provided by third party service providers and
integrated by developers into their apps, this practice has raisedlots of privacy and security concerns [3]. In fact, previous
studies have identiﬁed sensitive information exposure in ad
networks [4], [5], and others have found that upon a user’s
click, advertisements may reach some destinations that play
an important role in propagating attacks [6]. In addition toadvertisements, apps may offer extra features that are usually
not desired by the users. For example, a weather app mayrecommend news stories, and a calendar app may includenews-like sections (as we will show in Section IV-B2).
Besides the non-relevant features, some apps may contain
complex functionalities that are relevant to the apps’ purpose,but considered redundant or distracting by the users. For ex-
ample, a shopping app usually recommends products based on
the user’s proﬁle and shopping history. However, uninterestedusers might ﬁnd such recommendations quite distracting, and
would appreciate it if the app provides an option to turn this
feature off. Besides visual distraction, unwanted functionalities
often incur additional consumption of battery power, CPU
cycles, bandwidth and so on. Previous studies have shown thatmobile apps using ads consume signiﬁcantly more network
data and have increased energy consumption [7].Therefore, there is an increasing need of automatically
customizing mobile apps to meet the various demands of
different user groups. For example, enterprises and government
agencies may want the apps installed on their employee’s de-
vices to not have potentially malicious third party components(e.g., ad components). Users that often operate their devices
in rough environments such as outdoors and battle ﬁelds maywant to minimize battery and data consumption by turningoff unnecessary app features. Even normal users may have
different personal preferences/needs to customize apps. For
example, parents may want to disable components that could
deliver inappropriate content to their children. Unfortunately,
due to the potentially diverse needs, app customization andpersonalization are prohibitively expensive in terms of human
effort for the development team if no automatic tools are
available.
In this paper, we propose a UI driven app customization
technique that removes unwanted features in Android appsthat are associated with given UI elements. In particular, our
technique requires the user to ﬁrst specify the UI elements
denoting functionalities that she wants to remove. Usingthis information, our technique automatically identiﬁes the
program locations that load the s peciﬁc UI elements into code
and store them in variables. With such program locations, our
technique can then track all correlated uses of the UI elements
and the code elements for relevant background tasks, e.g.,
acquiring data from remote serve rs. While the UI related code
elements are directly removable as indicated by the user, the
background tasks require more analysis to determine if theyare removable. Speciﬁcally, our technique examines whether
the background tasks generate data that exclusively ﬂows tothe speciﬁed UI elements. If so, these background tasks areconsidered removable. Otherwise ( i.e., the generated data gets
propagated to other components), the background tasks cannotbe removed. The underlying analysis is a type system, in
which each code element is tagged with a type indicating
if it should be removed. The type system infers types forall correlated code elements from the UI hints. Finally, our
technique reduces the app acco rding to the deduced types.
Our technique can be potentially used in the last stage of
app development to generate a la rge number of customizations
to meet different needs. In addition, it is designed in such
a way that it does not require source code. As such, legacy
apps whose source code and original developers are no longer
available can beneﬁt from our technique as well.
We evaluate our prototype on 10 popular Android apps. Our
evaluation shows a substantial reduction of various resources
978-1-5386-2684-9/17/$31.00 c/circlecopyrt2017 IEEEASE 2017, Urbana-Champaign, IL, USA
T echnical Research286
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:15 UTC from IEEE Xplore.  Restrictions apply. Real-time
WeatherCondition
WEA THERNEWS
Banner Ad
Fig. 1. Screenshot of app WeatherBug.
usage. On average, removing certain UI elements associated
with typical unwanted functionalities results in saving 28.1%
of data usage. 34.1% of CPU time, 26.2% Wi-Fi runningtime, and 37.6% of computed power use. Our achieved results
clearly demonstrate the strength of our proposed UI driven
application reduction.
Our work makes the following contributions:
•We propose a UI driven approach to remove unwanted
functionalities in Android apps associated with UI ele-
ments speciﬁed by the user. Our technique features a typesystem that tags all relevant code elements to indicate if
they are removable.
•We implement a prototype and evaluate it on a set of real-world Android apps. The results show that our approach
accurately discovers the remov able code elements and the
reduction leads to substantial resource savings.
II. M
OTIV A TION
We use WeatherBug [8], a real-world Android app to
motivate our technique. WeatherBug is a popular app thatprovides weather alerts, real-time weather conditions, hourly
forecasts and much more. While the status bar notiﬁcation
provided by WeatherBug is enough to check live weather
conditions, the user can launch the app to receive more detailed
information and access more advanced features. Intuitively,
once the app is launched, the user expects to get a view of
real-time weather conditions. However, the main page offers
much more additional information. As shown in Figure 1, themain page of the app contains the real-time weather condition,
some weather news and a banner ad. If we further scroll down,
the page contains more unrelated information such as photosfrom other users, the closest spark strike and so on.
Besides overwhelming the user with unrelated information,
these components consume additional energy and networkdata. Thus, there is a need to customize/refactor the app to
remove some features that are not essential to various clients.
For example, to prevent visual distraction, reduce potential
privacy leaks and malicious behaviors (in an enterprise envi-
ronment) [9], [3], [6], and to reduce energy and network dataconsumption (in rough environments such as outdoors). The
overarching idea of our work is to customize an app to meetdifferent user needs by specifying what features are not neededon the UI.
Suppose the user wants to remove some unwanted UI com-
ponents and any associated func tionalities in the WeatherBug
app. Speciﬁcally, consider the case in which the user selectsWEATHER NEWS , the highlighted component in Figure 1
for removal. Figure 2 shows simpliﬁed code snippets rep-
resenting the corresponding work ﬂow where
ndescribes
the execution order of a method. When the component is
loaded, the Android OS invokes 1onCreateView which
inﬂates a static layout ﬁle at line 4 to hold the content ofthe component. Additionally, a StoriesAdapter is created
and added to the component. This provides a binding from thecomponent-speciﬁc data set to views that are displayed, e.g.,
the images and the titles of all inner elements. The Android
OS then invokes
2onActivityCreated that eventually
launches a background functiona lity for acquiring data from a
remote server. Once this data is loaded, the background taskinvokes its callback method
3onRequestCompleted .I n
this callback method, the data i s transmitted to a thread and
the thread is queued for execution. Later, the Android OS
executes 4run in the thread. In run , the data is retrieved and
saved to a shared data set at line 30. Next, the thread notiﬁes
StoriesAdapter about the data set change at line 31. Fi-
nally, this data set change notiﬁcation triggers the execution of
5onCreateViewHolder and 6onBindViewHolder .
The method onCreateViewHolder creates a view holder
with an inﬂated view, and the method onBindViewHolder
obtains data from the shared data set and displays it on the
inﬂated view at line 45.
In order to remove the unwanted component, i.e., the UI
elements and functionalities associated with WEATHER NEWS ,
our approach ﬁrst receives the in formation associated with the
elements speciﬁed by the user. Next, it uses this information
to discover the program locations loading the UI elements
into code. Then it takes four steps to remove the UI elements
and associated functionalities: 1) forwardly discovers all code
related to the speciﬁed UI elements; 2) starting from wherethe UI elements use data, backwardly tracks the data to its
generation points in background functionalities; 3) examines
whether the data obtained from the discovered data generation
points are exclusively used by the speciﬁc UI elements or not;
4) iteratively removes the code.
In our motivating example, lines
4, 37 and 43 are associ-
ated with the unwanted UI elements. Our technique forwardly
tracks the uses of the correlated variables, as depicted by
in Figure 2 and identiﬁes lines 7 and 45 that put data to the
speciﬁc UI elements. Line 7binds StoriesAdapter to
the UI component to respond to data changes and displaysthe content, acting similarly to an action handler. We omit
the discussion of tracking the adapter for simplicity. Line
45
displays a short description of the corresponding image asshown in Figure 1 using the given data. Starting from line
45,
we backwardly track the data along onRequestCom-
pleted and then the data generation point in the background
functionality (omitted in the code). We further ﬁnd the location
287
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:15 UTC from IEEE Xplore.  Restrictions apply. 1class StoriesListFragment ... {
2StoriesAdapter adapter ; ArrayList data ;
3public View onCreateView(LayoutInflater inflater,
ViewGroup vg, Bundle b) {
4 View view = inflater.inflate( R.layout .stories ,v g ) ;
5 RecyclerView rv = view.findViewById(...);
6 adapter =new StoriesAdapter( this );
7 rv.setAdapter( adapter );
8 return view;
9}
10
11 public void onActivityCreated(Bundle b) {
12 loadData(); //omitted
13 }
14
15 public void onRequestCompleted(Request req) {
16 UpdateStories ud = new UpdateStories( this , req);
17 handler.post(ud);
18 }
19}20class UpdateStories implements Runnable {
21 StoriesListFragment fragment ;
22 Request request ;
23 public UpdateStories(StoriesListFragment f,
Request r) {
24 fragment =f ;
25 request =r ;
26 }
27 public void run() {
28 List list = request .getResponse();
29 fragment .data .clear();
30 fragment .data .addAll(list);
31 fragment .adapter .notifyDataSetChanged();
32 }
33}34class StoriesAdapter extends RecyclerView.Adapter {
35 StoriesListFragment fragment ;
36 public ViewHolder onCreateViewHolder(ViewGroup vg, int type) {
37 View v = View.inflate(..., R.layout .storiespage , vg);
38 NewsViewHolder vh = new NewsViewHolder( fragment , v);
39 return vh;
40 }
4142 public void onBindViewHolder(ViewHolder vh, int pos) {
43
TextView tv = ((NewsViewHolder)vh).findViewByIdR.id. stitle );
44 StoryInfo info = fragment .data .get(pos);
45 tv.setText(info.getTitle());
46 }
47}1
2
3
4
5
6Indirect call
UI related forward slicing
Backward data tracking
Forward data tracking
nn-th executed method
Fig. 2. Simpliﬁed code snippet for the WEA TH ER NEWS component and the corresponding ﬂows.
1// in class StoriesListFragment
2public View onCreateView(...) {
3TextView tv = new TextView(...);
4tv.setText( "WEATHER NEWS Removed" );
5return tv;
6}
Fig. 3. Removing WEA THER NEWS.
invoking the background functionality at line 12. Next, we
check whether the generated data is only used in the speciﬁc
UI elements by forwardly tracking the data from the data
generation point following in Figure 2. We do not ﬁnd
any other components using the data in the example and
thus the data is speciﬁc to the UI elements. However, the
background functionality is found to be a public component
used at other locations in the app and thus the discovered
code inside the functionality, including the data generation
point, cannot be removed. Finally, our technique removes theother code not occurring in the background functionality and
iteratively removes methods and classes if applicable.
To show the effect of the code reduction, our technique re-
places the layout inﬂation in onCreateView with a dummy
view and eliminates all the othe r removable code elements.
The modiﬁed code snippet and the runtime screenshot isshown in Figure 3. The dummy view is depicted in the
highlighted area. As shown in Section IV, removing theWEATHER NEWS component reduces 9% of the data usage
and 20% of the power consumption.App
UserUI Element
Discovery0
UI Element
Tracking1Backward
Data Tracking2Forward
Data Tracking3
Code
Removal4
Modiﬁed
App
Fig. 4. Approach overview.
III. D ESIGN
In this section, we will discuss our UI driven approach
to discovering removable code elements in Android apps.
Figure 4 shows the work ﬂow of our approach. As discussed in
Section II, after receiving the user speciﬁed UI elements and
discovering the program locations referring to them (step 0),
our approach takes four steps to detect potentially removable
code elements: 1forwardly discovers all uses of the speciﬁed
UI elements; 2backwardly tracks the data used in the
UI elements; 3ﬁnds all uses of the data, starting from the
discovered data generation points; 4iteratively removes the
code elements based on the results of data tracking. Steps 0
and 1are discussed in Section III-C, Section III-D describes
steps 2and 3, and Section III-E talks about step 4.
We use the code snippet in Figure 5 throughout the sec-
tion to exemplify the approach details. Assume that id0
andid1 refer to unwanted UI elements but id2 doesn’t.
BgTask represents a background functionality that obtains
input data from remote servers and stores the result to data .
Line 13 abstracts the operations of obtaining input data byfunction getInputData . A concrete example is Http-
Client.execute() which is commonly used in Android
288
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:15 UTC from IEEE Xplore.  Restrictions apply. 1// class A declares field "data"
2class Bextends A{
3a() { t= new BgTask( this );trigger(t); }
4b() { textView0 = findViewById( id0);//unwanted
5 textView0.setText( data ); } } //‘‘B’’
6class Cextends A{
7c() { g= new BgTask( this );trigger(g); }
8d() { textView1 = findViewById( id1);//unwanted
9 textView1.setText( data .split( ":")[0]);
10 textView2 = findViewById( id2);//not unwanted
11 textView2.setText( data .split( ":")[1]); } }//‘‘C’’
12class BgTask { A ck; BgTask(A a) { ck= a;}
13 void run() { ck.data = getInputData(); }} //‘‘BgTask’’
Fig. 5. Code example for discussion.
Program P ::= K*
Class K ::= M*
Method M ::= m(x) {s*}
Statement s ::= x :=lc/ *constant */
|x : =linﬂate(i) /*inﬂation */
|x : =lﬁndViewById(i) /*get view */
|x : =l/circleminusy/ * unary assignment */
|x : =ly⊕z/ * binary assignment */
|x : =lφ(y, z) /* value merging in SSA */
|x : =ly.z /*get ﬁeld */
|x . y : =lz/ *put ﬁeld */
|x : =lcheckcast(y) /*type cast */
|x : =lnew k(y) /*new instance */
|x : =ly.m(z) /*method call */
|r e t u r nl(x) /*return in a method */
Va r i a bl e x, y, z / *all variables */
ID i /*UI-related Id */
V alue c /*non-Id constant */
Label l /*{l1,l2,l3, ...} */
Fig. 6. Simpliﬁed language model.
apps to fetch remote data from Web servers. The data acqui-
sition task is initiated at two locations: line 3 and line 7. The
data is displayed on UI elements at lines 5, 9 and 11.
A. Language Abstraction
To simplify our discussion, we introduce an abstract lan-
guage, as presented in Figure 6. A program is made up of
classes, a class contains a list of methods, and each method
contains a number of statements. We model common types
of statements and other operations are abstracted away or
simpliﬁed. We label statem ents with a superscript.
As we discussed in Section II, we start our analysis from
the layout inﬂations and aim to remove the inﬂated views.
Thus, we introduce the function inﬂate to represent all kinds
of inﬂations in the code ( e.g., lines 4 and 37 in Figure 2).
Additionally, we introduce another function ﬁndViewById to
represent the operation of an app looking for a UI element.
We abstract all types of assignment, such as unary assign-
ment, binary assignment, type cast assignment and assignment
from/to a ﬁeld variable. Note that our language is a kind of
single static assignment (SSA) language such that conditionals
(including loops) are implicitly represented by the value merge
statement φ(y,z). Since the predicate of the value merge
statement is irrelevant in our analysis, it is abstracted away
and hence yandzdenote the values of the same variable in
the two branches of a conditional.
[s] := statementsIn(m) [m] := methodsIn(k)
x := thisOf(k) x := paramOf(m)
s := returnOf(m)
Fig. 7. Functions for class ,method and statement .
For object creation (i.e., new instance statement) and method
calls, we assume there is only one parameter besides thereceiver object (‘ this ’) of an instance method call. A return
statement returns a value fro m a callee method to a variable
in the caller method.
We also deﬁne a number of auxiliary functions for state-
ments, methods, and classes to acquire correlated informationduring analysis. These functions are shown in Figure 7.Function statementsIn returns all statements inside a method,
represented by [s]. Similarly, methodsIn returns all declared
methods in a class k. Functions thisOf and paramOf behave
similarly, except that one looks for ‘ this ’ reference in the
callee method and the other searches the corresponding formalparameter. The return statement of a method is given by
returnOf .
B. Type System
We formalize our approach in a type system. Code elements,
including variables, statements, methods, and classes are as-
sociated with tags. A tag is treated as the type Tof the code
elementl.W es a y lhas type T, written as l:T. The type of
a code element may be a set of tags, for example, l:{T,T
/prime}.
In this case, We use “ ∪” to union two sets of types together.
In this paper, we deﬁne the type domain as:
Type=/braceleftBigUIRelated UIData InputUIData
Removable Unremovable/bracerightBig
Type UIRelated is used to mark the variables or state-
ments that depend on the speciﬁed UI elements. We type
the code elements with it and propagate it at step 1.F o r
example, we type an inflate() method call where the
inﬂated view is a user speciﬁed UI element and the resultantvariable with UIRelated . When we ﬁnd any data uses on
the speciﬁed UI elements, we type the data variable with
UIData and then backwardly propagate it at step
2.I fw e
reach a data generation poi nt along above propagation, we
get the knowledge that the data is some input data from
outside sources. We type the data generation point and the
data variable with InputUIData and propagate it forwardly
(step 3). Eventually, we can mark which code elements are
removable or deﬁnitely unremovable using the correspondingtypes (step
4).
Notice that type InputUIData can be parameterized with
a data generation point. It will help us distinguish the typesof code elements which are correlated with multiple data
generation points.
In addition to the concrete types, if any code element has
not been visited or is not interesting to us, we say it is not
typed, in the notation of nil.
Consider that the same code element executed in different
calling contexts may produce different results, and in some
contexts it may be related to the speciﬁed UI elements while
289
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:15 UTC from IEEE Xplore.  Restrictions apply. UI-InﬂatebelongToSpecifiedUI (i)
Γ1,{x:=linflate(i)}/epsilon1|=Γ 1⇒[x/epsilon1,l/epsilon1:UIRelated ]Γ1
UI-FindViewbelongToSpecifiedUI (i)
Γ1,{x:=lfindViewById (i)}/epsilon1|=Γ 1⇒[x/epsilon1,l/epsilon1:UIRelated ]Γ1
UI-Call-ThisnonApi(m)Γ 1/turnstilelefty/epsilon1:UIRelated /epsilon1/prime=/epsilon1·lt=thisOf(m)
Γ1,{x:=ly.m(z)}/epsilon1|=Γ 1⇒[x/epsilon1,t/epsilon1/prime,l/epsilon1:UIRelated ]Γ1
UI-BAssignΓ1/turnstilelefty/epsilon1:UIRelated
Γ1,{x/epsilon1:=ly/epsilon1⊕z/epsilon1}/epsilon1|=Γ 1⇒[x/epsilon1,l/epsilon1:UIRelated ]Γ1
UI-ReturnΓ1/turnstileleftr/epsilon1/prime:UIRelated /epsilon1/prime=/epsilon1·lx:=ly.m(z)
Γ1,{returnl/prime(r)}/epsilon1/prime|=Γ 1⇒[x/epsilon1,l/prime
/epsilon1/prime,l/epsilon1:UIRelated ]Γ1
Fig. 8. Rules for discovering code elements associated with the UI elements.
in other contexts it may not be. We use /epsilon1to represent the
calling context which is a stack of labels referring to method
calls or new instance sites. Each code element lis tagged
with a context ( e.g.,l/epsilon1) in order to conduct context-sensitive
analysis. Different contexts are depicted by the subscript of/epsilon1,e.g.,/epsilon1
1and/epsilon12.W eu s e“ ·” to concatenate a context with a
label to form a new context for the statements in the callee
method associated with l, for example, /epsilon1/prime:=/epsilon1·l.
The mappings from the code elements to the types form
the context Γof the type system, which is iteratively updated
during analysis until a ﬁxed point is reached. For example,
at the beginning, Γis empty. Upon a removable statement l/epsilon1,
Γis updated to { l/epsilon1:Removable }. At this point, we have
Γ/turnstileleftl/epsilon1:Removable , which means under (type) context
Γ, statement l/epsilon1is typed with Removable .I no t h e rw o r d s ,
Γ(l/epsilon1)=Removable ,w h e r eΓ(l/epsilon1)evaluates statement l/epsilon1in
the context to obtain the corresponding type.
When a statement l/epsilon1is evaluated, the context may be
updated. We use Γ,l/epsilon1|=Γ⇒Γ/primeto indicate that under
type context Γ, evaluating code l/epsilon1updates the context from
ΓtoΓ/prime.W eu s e [l/epsilon1:T]Γto represent an update to the
context. Speciﬁcally, if no mapping is found for l/epsilon1inΓ,t h e
mapping is added to the context. But if there exists a mappingforl
/epsilon1, the rule substitutes the existing type of l/epsilon1with type
T. Multiple mappings can be updated simultaneously. For
instance, [l/epsilon11:T,l/prime
/epsilon12:T/prime]Γupdate the context for two code
elements l/epsilon11andl/epsilon12.W ea l s ou s e [l/epsilon11,l/prime
/epsilon12:T]Γto denote
[l/epsilon11:T,l/prime
/epsilon12:T]Γfor brevity.
In the following analysis, we deﬁne four type contexts: Γ1,
Γ2,Γ3andΓ4for the four steps respectively. We also have a
special context MR in which the discovered data generation
points are mapped to True orFalse , indicating whether the
corresponding data generation points must be retained or not.
C. Turning Off UI Element
In this section, we discuss how to identify the code elements
related to the unwanted UI elements, i.e., steps 0and 1in
Figure 4. Starting from inﬂate and ﬁndViewById,w ef o r w a r d l y
track the uses of the speciﬁed UI elements and type all
correlated statements and variables with UIRelated .
We deﬁne the rules in Figure 8. We omit the rules for
some statements, e.g., unary assignment, φassignment and
ﬁeld access, due to the space limit. In addition, we do notpresent the rules for API method calls that require models.New instance operations behave similarly to method calls and
thus we omit the corresponding rules too.
Based on the language deﬁnition, the user speciﬁed UI
elements are introduced into the code through layout inﬂation
(inﬂate ) or view ﬁnding ( ﬁndViewById). We apply rules UI-
Inﬂate and UI-FindView to start the analysis. If the given id is
corresponding to a speciﬁed UI element, we say the resultant
variable and the statement are related to speciﬁc UI element.
If the receiver object yof a method call mis typed with
UIRelated , the deﬁnition of ywill be potentially removed.
The removal results in a null r eference, leading to run-time
exceptions. Therefore, we apply rule UI-Call-This in this case
to type the resultant variable x, the method call statement land
the corresponding ‘ this ’ reference in the callee method with
UIRelated . If an actual argument zis typed, the behavior is
similar to UI-Call-This and the corresponding rule is omitted.
Rule UI-BAssign indicates that if a right-hand-side variable is
typed, the left-hand-side variable and the statement are typedtoo. Rule UI-Return is applied when a return variable in a
callee method is typed with UIRelated . It propagates the
type to the resultant variable at the corresponding call site andtypes the call site with UIRelated .
Example: Consider applying the rules to the code snippet
in Figure 5. First, we type textView0 andtextView1 ,
lines 4 and 8 with UIRelated by rule UI-FindView. Then
through type propagation, lines 5 and 9 are typed with UIRe-
lated . We present the context updates as follows. /epsilon1
1is the
calling context of method B.b() and/epsilon12is the calling context
of method C.d() .
UI-FindView(Line 4 /epsilon11,L i n e8 /epsilon12)⇒⎡
⎣textView0 /epsilon11:UIRelated
textView1 /epsilon12:UIRelated
Lines 4 /epsilon11,8/epsilon12:UIRelated⎤⎦Γ
1
UI-Call-This(Line 5 /epsilon11,L i n e9 /epsilon12)⇒/bracketleftbigLines 5 /epsilon11,9/epsilon12:UIRelated/bracketrightbigΓ1
D. Discovering Associated Background Functionalities
If we reach some API method calls that put data to
the speciﬁed UI elements for display, we track where the
data is generated. We backwardly track the generation of
the data and type all the involved statements and associ-ated variables with UIData (step
2). When we reach a
data generation point that acquires data from outside sources
(e.g.,HttpClient.execute() ), we use InputUIData
290
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:15 UTC from IEEE Xplore.  Restrictions apply. UI-Put-DataΓ1/turnstilelefty/epsilon1:UIRelated Γ1/turnstileleftl/epsilon1:UIRelated apiPutDataToUI (m)
Γ1,{x:=ly.m(z)}/epsilon1|=Γ 2⇒[z/epsilon1:UIData]Γ2
Bwd-AssignΓ2/turnstileleftx/epsilon1:UIData
Γ2,{x:=ly⊕z}/epsilon1|=Γ 2⇒[y/epsilon1,z/epsilon1,l/epsilon1:UIData]Γ2
Bwd-Call-ReturnΓ2/turnstileleftx/epsilon1:UIData nonApi(m)/epsilon1/prime=/epsilon1·l{returnl/prime(r)}=returnOf (m)
Γ2,{x:=ly.m(z)}/epsilon1|=Γ 2⇒[r/epsilon1/prime,l/prime
/epsilon1/prime,l/epsilon1:UIData]Γ2
Bwd-Call-ParamnonConstructor (m)/epsilon1/prime=/epsilon1·lp=paramOf (m)Γ 2/turnstileleftp/epsilon1/prime:UIData
Γ2,{x:=ly.m(a)}/epsilon1|=Γ 2⇒[a/epsilon1:UIData]Γ2
Fig. 9. Rules for backwardly discovering data relevant code elements.
Bwd-Call-Data-GenΓ2/turnstileleftx/epsilon1:UIData apiGetInputData (m)
Γ2,{x:=ly.m(z)}/epsilon1|=Γ 3⇒[x/epsilon1,l/epsilon1:Γ3(l/epsilon1)∪{InputUIData (l)}]Γ3
Fwd-AssignInputUIData (ld)∈Γ3(y/epsilon1)
Γ3,{x:=ly⊕z}/epsilon1|=Γ 3⇒[x/epsilon1,l/epsilon1:Γ3(x/epsilon1)∪{InputUIData (ld)}]Γ3
Fwd-Call-ThisnonApi(m)InputUIData (ld)∈Γ3(y/epsilon1)/epsilon1/prime=/epsilon1·lt=thisOf(m)
Γ3,{x:=ly.m(z)}/epsilon1|=Γ 3⇒[x/epsilon1,t/epsilon1/prime,l/epsilon1:Γ3(x/epsilon1)∪{InputUIData (ld)}]Γ3
Fwd-Call-ReturnInputUIData (ld)∈Γ3(r/epsilon1/prime)/epsilon1/prime=/epsilon1·lx:=ly.m(z)
Γ3,{returnl/prime(r/epsilon1/prime)}/epsilon1/prime|=Γ 3⇒[x/epsilon1,l/epsilon1,l/prime
/epsilon1/prime:Γ3(x/epsilon1)∪{InputUIData (ld)}]Γ3
Unexpected-Data-UseInputUIData (ld)∈Γ3(z/epsilon1)UIRelated /∈Γ1(y/epsilon1)apiPutDataToUI (m)
Γ1,Γ3,{x:=ly.m(z)}/epsilon1|=MR(ld)→True
Fig. 10. Rules for discovering the uses of input data.
to type the data variable and the statement, indicating their
correlation with input data. We then forwardly propagate
InputUIData along data ﬂows (step 3). Along the forward
propagation, we parameterize InputUIData withld,ad a t a
generation point, to distinguish data originating from different
points. If we encounter any cases in which the tracked data is
used in some UI components other than the unwanted ones,we need to remember that the corresponding data generation
points from which the data propagations are unremovable. We
deﬁne the backward propagation rules in Figure 9 and theforward rules in Figure 10.
Step
2starts with the discovery of API calls putting data on
speciﬁed UI elements. Rule UI-Put-Data initiates the contextΓ
2which stores mappings from variables or statements to type
UIData , by typing the data variable with UIData .B w d - *
rules are then applied to propagate the type backwardly. If a re-sultant variable xis typed in a method call, the corresponding
return value rin the callee method should also be typed (Bwd-
Call-Return). If a formal parameter pin a callee method is
typed, the corresponding actual argument at the caller is typed
(Bwd-Call-Param). If the typed variable is this reference in
the callee method, we type the c orresponding receiver object.
During the propagation, if we meet a API method call that
acquires outside data and stores the data to any variables
under tracking, we consider the method call as a data gen-
eration point and thus type the data variable and the data
generation point with InputUIData in context Γ
3(Bwd-
Call-Data-Gen). Given the fact that a code element may becorrelated with multiple data generations, we associate eachtypeInputUIData with the location of data generation and
we use a set to represent the type of a code element. Forexample, statement a=b·cconcatenates two strings and
bis generated by a method call at l
0while cis generated
atl1. Therefore, ahas a type of { InputUIData (l0,l1)}. If
either one of the data generation points cannot be removed,this statement is unremovable. The forward propagation rules
are straightforward, similar to the ones for discovering UI
related code elements, except that type InputUIData is
parameterized with a data generation point and the resultant
type is a union of the incoming type and the original types.
If the input data is discovered to be used by some UI ele-
ments that are not correlated with the unwanted UI elements,we apply rule Unexpected-Data-Use and mark in context MR
that the corresponding data generation point must be retained,
i.e., unremovable.
Example: We apply the rules to the example in Figure 5.
Backward data tracking updates Γ
2as:
/bracketleftbigdata{...;3}, data{...;7},Line 13{...;3},L i n e1 3{...;7}:UIData/bracketrightbig
Γ2
We use {...;n} to denote the calling context of method run()
where ndenotes the line number of corresponding trigger site.
The background functionality is triggered in two contexts, one
at line 3 and the other at line 7. This results in different
instances of variable data and the statement of getting input
data. Therefore, variable data at line 13 is deﬁned in two
calling contexts, represented by data{...;3}and data{...;7}.
Starting from the data generation points, we have
⎡
⎣data{...;3},L i n e1 3{...;3},L i n e5 /epsilon11:{InputUIData (Line13)}
data{...;7},L i n e1 3{...;7}:{InputUIData (Line13)}
Line 9/epsilon12,,L i n e1 1 /epsilon12:{InputUIData (Line13)}⎤⎦Γ
3
At line 11, the data is sent to a unspeciﬁed UI element
and the line is typed with InputUIData (Line13). With
291
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:15 UTC from IEEE Xplore.  Restrictions apply. rule Unexpected-Data-Use, we mark the corresponding data
generation point as MR(Line13)→True , saying that the
corresponding data generation point must be retained.
E. Removing Code Elements
After we type all data correlated statements with one or
more InputUIData types, we can ﬁnally determine which
code elements are removable or unremovable (step 4). The
rules are shown in Figure 11. We use lto aggregate the code
element in allcalling contexts, i.e.,l/epsilon1jfor allj.
Rule Remove-Stmt-1 says, if a code element lis directly
related to the speciﬁed UI elements in all possible calling
contexts, it is absolutely removable. If lin a context /epsilon1has
a type of InputUIData which is associated with some data
generation point ld, and the data generation point needs to
be retained when lis not a UI related code element, rule
Unremove-Stmt declares las unremovable. In contrast, if the
corresponding data generation point is not required to beretained and the target lhas not been typed with Unre-
movable , we use Remove-Stmt-2 to mark las removable.
Rules Remove-Method and Remove-Class behave similarly.
If all call sites of a method or instantiation sites of a class areremoved, the method or the class can be fully removed. The
last two rules iteratively remove included code elements when
a method or a class is removable.
We are also able to ﬁnd out the trigger sites of back-
ground functionalities, like the start() call of a Thread
object or execute() call on an AsyncTask instance. If
the triggered operations in b ackground functionalities are all
removable, we can remove the corresponding trigger sites aswell. Furthermore, we do not re move branch statements like
ifandswitch even if they use variables whose deﬁnitions
are removable. Instead, we replace the deﬁnition statement ofeach such variable with a statement that assigns 0 or null to
that variable, depending on the type of the variable.
Example: We can now apply the rules to remove code
elements in Figure 5. We have
/bracketleftbigg
Line 4, Line 5, Line 8, Line 9 :Removable
Line 11, Line 13:Unremovable/bracketrightbigg
Γ4
Therefore we can remove lines 4, 5, 8 and 9. The back-
ground data generation point at line 13 cannot be removedbecause its data ﬂows to non-speciﬁed UI elements at line 11.
However, under the context of class Bwhere the data is
only used in the unwanted UI elements, we can disable thecorresponding trigger of the b ackground functionality to avoid
unnecessary network access after we remove the unwanted UI
elements. We discover the corresponding trigger site at line 3
and we type it with Removable while we retain the trigger
site at line 7.
IV . E
VA L UAT I O N
We implement a prototype T OFU ,t
urning of
 fU
Ie l e m e n t s ,
to discover the removable code elements for speciﬁed un-
wanted UI elements. T OFU is built on top of Soot [10],
supporting rewriting modiﬁed code to DEX ﬁles. We evaluate
TOFU on 10 popular Android apps (Table I). T OFU runs onTABLE I
BENCHMARK APPS AND REMOVED UI.
App
 Removed UI
 Description
WeatherBug
 WEA THER NEWS
 Weather related news
Dictionary.com
 Blog/Slideshow
 Word related items on main page
Baidu iKnow
 Latest Q&A
 Real-time update on main page
Walmart
Recommendation
Recommended items based on
Macy’s
 the other users’ choices
China Calendar
 News Button
 A button to news page
Fox News
 Sponsored Stories
 Ad in each news page
CBS News
 Banner Ad
 Banner ad associated with each
news title and brief introduction
AP Mobile
 Banner Ad
Bottom banner ad in each page
Tattoo My Photo
 Banner Ad
an Intel Core i5 2.5GHz machine with Windows 10 and 8GB
memory.
In our experiments, we specify the UI elements that rep-
resent the unwanted features based on our understanding of
the expected app behavior. The unwanted components include
normal functionalities that certain users may not need ( e.g.,
word related additional information on the main page in a
dictionary app), irrelevant buttons ( e.g., a button leading to
a news page in a calendar app) and advertisements. More
details can be found in Table I. We manually obtain the
corresponding IDs of the speciﬁed UI elements. T OFU then
automates the aforementioned a nalysis and the generation of
the modiﬁed APK ﬁle. Speciﬁcally, given an app, we run it
to the pages containing UI components correlated with theunwanted functionalities in a Nexus 6P running Android 6.0.1.
We then use the Android SDK tool UIAutomator Viewer toobtain the dynamic UI hierarchy, on which we select thecomponents to be removed (corresponding to the unwanted
features). We feed the corresponding information (IDs of
layouts and UI elements) to T
OFU .T OFU then statically
analyzes the app code, removes the code elements markedas removable and rewrites the modiﬁed code to DEX ﬁles,constructing a new APK ﬁle. Next, we sign the APK ﬁle and
run it in the same device in order to measure the savings
resulting from our code reduction.
Each pair of apps (original and modiﬁed) are kept running
for 10 minutes and then their power use is examined. Since
the power consumption proﬁler rounds the result up to an
integer, it may not be able to tell the differences in somecases. If the values are not distinguishable, we continue to
test the pair of apps for anot her 20 minutes. For each app,
at the beginning of ﬁrst run, we disable potential live contentupdate ( e.g., push notiﬁcations) that may largely inﬂuence the
results. For example, the app AP Mobile updates its displayed
live news in the background. If we allow all the categories
(e.g., Sports, Entertainment) to update, in a 10-minute run, we
observed 73MB of data usage, 9 minutes of CPU time and 20
mAh of power use. After unsubscribing all categories except
the Top News, the data usage is reduced to less than 10MB.
A. Experiment Results
Our evaluation aims to measure the beneﬁts of our code
reduction with regards to two aspects: data usage and bat-
tery usage. To evaluate the data usage reduction, we select
292
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:15 UTC from IEEE Xplore.  Restrictions apply. Remove-Stmt-1Γ1/turnstileleftl:UIRelated
Γ4⇒[l:Removable ]Γ4
Unremove-StmtInputUIData (ld)∈Γ3(l/epsilon1)MR(ld)Γ 1(l)/negationslash=UIRelated
Γ4⇒[l:Unremovable ]Γ4
Remove-Stmt-2InputUIData (ld)∈Γ3(l/epsilon1)¬MR(ld)Γ 4(l)/negationslash=Unremovable
Γ4⇒[l:Removable ]Γ4
Remove-MethodnonApi(m)∀(x:=ly.m(z)),Γ4/turnstileleftl:Removable
Γ4⇒[m:Removable ]Γ4
Remove-ClassnonFrameworkClass (k)∀(x:=lnew k(y)),Γ4/turnstileleftl:Removable
Γ4⇒[k:Removable ]Γ4
Remove-StmtsΓ4/turnstileleftm:Removable l∈statementsIn (m)
Γ4⇒[l:Removable ]Γ4
Remove-MethodsΓ4/turnstileleftk:Removable m∈methodsIn (k)
Γ4⇒[m:Removable ]Γ4
Fig. 11. Rules for removing code elements.
TABLE II
EXPERIMENT RESULTS .
App
Data Usage
 CPU Total
 Wi-Fi Running
 Computed Power Use
Original
 Modiﬁed
 Reduction
 Original
 Modiﬁed
 Reduction
 Original
 Modiﬁed
 Reduction
 Original
 Modiﬁed
 Reduction
WeatherBug
 16.84MB
 15.33MB
 9.0%
 2m05s
 1m59s
 4.8%
 8m02s
 5m48s
 27.8%
 5mAh
 4mAh
 20.0%
Dictionary.com
 6.21MB
 3.20MB
 48.5%
 4m22s
 3m56s
 9.9%
 32s
 21s
 34.4%
 8mAh
 7mAh
 12.5%
Baidu iKnow
 3.86MB
 2.42MB
 37.3%
 2m08s
 1m18s
 39.1%
 1m07s
 1m06s
 1.5%
 5mAh
 3mAh
 40.0%
Walmart
 29.67MB
 23.02MB
 22.4%
 8m08s
 7m58s
 2.0%
 1m50s
 1m03s
 42.7%
 17mAh
 14mAh
 17.6%
Macy’s
 30.09MB
 24.32MB
 19.2%
 6m06s
 4m35s
 24.9%
 22s
 21s
 4.5%
 11mAh
 8mAh
 27.3%
China Calendar
 8.49MB
 7.26MB
 14.5%
 9m35s
 6m24s
 33.2%
 32s
 24s
 25.0%
 16mAh
 11mAh
 31.3%
Fox News
 8.71MB
 5.52MB
 36.6%
 6m56s
 6m43s
 3.1%
 27s
 19s
 29.6%
 21mAh
 18mAh
 14.3%
CBS News
 9.55MB
 5.21MB
 45.4%
 8m00s
 2m40s
 66.7%
 38s
 27s
 28.9%
 17mAh
 5mAh
 70.6%
AP Mobile
 9.63MB
 7.09MB
 26.4%
 4m55s
 1m44s
 67.4%
 21s
 12s
 42.9%
 12mAh
 6mAh
 50.0%
Tattoo My Photo
 12.79MB
 10.04MB
 21.5%
 10m13s
 1m00s
 90.2%
 41s
 31s
 24.2%
 25mAh
 2mAh
 92.0%
Average
 28.1%
 34.1%
 26.2%
 37.6%
removable UI elements that are correlated to network access
and measure the incurred data usage before and after their
removal. Similarly, to evaluate the battery usage, we measure
the app’s total CPU time, Wi-Fi running time and computedpower use before and after the code reduction. We obtain this
detailed information through the Setting app. We present the
experiment results in Table II.
From Table II, we observe that removing some unwanted
functionalities and associated UI elements has a minimum
reduction of 9.0% for data usage (WeatherBug), 2.0% for total
CPU time (Walmart), 1.5% for Wi-Fi running time (BaiduiKnow) and 12.5% for the computed power use (Dictio-
nary.com). The maximum reductions for the four factors are
48.5%, 90.2%, 42.9% and 92.0%, respectively. Eventually, we
obtain average reductions of 28.1%, 34.1%, 26.2% and 37.6%
for the four factors, which demonstrate the effectiveness ofour approach.
Figure 12 depicts the time required to analyze the 10 apps
alongside their DEX code size. As shown, the analysis time
increases as the code size increases. We have also observed
that apps with more complex removable functionalities take
longer time to be analyzed. For example, the WeatherBug app
(see Section II) requires more than 10 minutes to ﬁnish theanalysis while the China Calendar app, in which a button is
disabled, only needs one and a half minutes.0.005.0010.0015.0020.0025.0030.00 Analysis Time (Minute) Size(MB)
Fig. 12. App analysis time and the DEX code size.
Search Box
Word of the Day
Blog
Slideshow
(a) App Dictionary.com
clickingMain Page
News Page
(b) App China Calendar
Fig. 13. Screenshots of Dictionary.com and China Calendar.
B. Case Studies
In the following, we use a few cases to illustrate the
application of our approach.
293
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:15 UTC from IEEE Xplore.  Restrictions apply. 1) Removing Unwanted App Components: We use un-
wanted app components to refer to those UI elements that
display information provided by the app providers (not third-
party advertisement) but are probably unwanted by the users,
e.g., the WEA THER NEWS in the WeatherBug app (Figure 1).
Here, we study one more case from the Dictionary.com app
in this section.
As shown in Figure 13a, the main page of the app contains
a search box, a tag for the word of the day and a list of othertopics about language, grammar, etc. Usually, a user launches
the app to look for words and does not expect to be distractedby the other irrelevant contents, which inevitably consume
additional data and battery. In our experiment, we remove
the irrelevant contents (blog and slideshow features) from theapp, which are populated through some background services.
Speciﬁcally, T
OFU ﬁrst locates the program locations ﬁring
the background actions and then disables their invocations.
As a result, the blog and slideshow tags are prevented from
being displayed on the main page, leading to 48.5% data usage
reduction and 12.5% power usage reduction.
2) Removing Unwanted User Actions: The China Calendar
app (com.veryapps.hl ) helps users explore the lunar calendar
(e.g., current lunar day, auspicious information, etc.). However,
the app contains a button in the main page, which once clicked,launches a new page acting similar to a news app (Figure 13b).Accidentally clicking the button will cause unexpected data
usage and battery consumption. The implementation is as
follows:
1// in class MainActivity
2public void onCreate(Bundle b) { //omitted operations
3btn = findViewById(R.id.btn_news_category);
4btn.setOnClickListener( this );
5}
6public void onClick(View v) {
7Intent i = new Intent( this , NewsCategoryActivity. class );
8startActivity(i);
9}
The button handler is simpliﬁed in method onClick at
line 6, in which a new activity presenting the news is started(line 8). The unwanted UI element is referred to at line 3.
T
OFU forwardly tracks the uses of the UI element and types
lines 3 and 4. It further tracks and types the button handlerand the launched activity. After reduction ( e.g., lines 3 and
4), the functionality of the button is disabled. Based on our
experiment, the removal saves 14.5% of data usage, 33.2% of
CPU time, 25% of Wi-Fi running time and 31.3% of power
use when we click the button in original app once per minute
for 10 minutes.
3) Removing Advertisements: Advertisements are com-
monly used in Android apps for monetization purposes. How-ever, mobile advertisements have long been considered a
source of distraction for users [11], responsible for additional
network data and power consumption, not to mention the risks
of privacy leaks and potentially malicious behaviors exhibited
by advertisement libraries [4], [5], [6].
Banner ad, displayed usually at the bottom of the screen (see
Figure 1), is the most common type of mobile advertisement.As shown in Table II, removing the banner ads in apps (CBS
1class ArticleFragment ... {
2LoaderCallbacks callback ; OAdapter madapter ;
3ArrayList contents ;
4ArticleFragment() {
5 callback =new LoaderA( this );
6 madapter =new OAdapter(...);
7}
8void onActivityCreated(Bundle b) {
9 loaderManager.initLoader(..., callback );
10 }
11}
12class LoaderA implements LoaderCallbacks {
13 ArticleFragment fragment ;
14 Loader onCreateLoader( int i, Bundle b) {
15 return new OLoader(...);
16 }
17 void onLoadFinished(Loader l, Object d) {
18 fragment .contents = (ArrayList) d;
19 fragment .madapter .updateContent((ArrayList)d);
20 }
21}
22class OAdapter ... {
23 ArrayList alist ;
24 void updateContent(ArrayList list) {
25 alist .addAll(list);
26 this .notifyDataSetChanged();
27 }
28 View getView( int pos, View v, ViewGroup vg) {
29 vv = inflater.inflate(...); //unwanted UI
30 content =alist .get(pos);
31 vv.set( content );//detail omitted
32 }
33}UIRelated UIData InputUIData
Fig. 14. Code snippet for Fox News.
News, AP Mobile and Tattoo My Photo) has led to a signiﬁcant
reduction of data usage and battery consumption.
App Fox News adopts another type of advertisement, which
displays several pieces of ad titles and images. We noticed thatsuch advertisement is heavily integrated with the app code,compared with the simple banner ad, as shown in Figure 14.
We also show in the same ﬁgure what the correlated statements
are typed with. For example, in their own calling context,line 29 is typed with UIRelated inΓ
1and line 18 is typed
withUIData inΓ2andInputUIData inΓ3. The classes
LoaderA andOAdapter are only used as shown in the
code snippet and thus all the typed statements are removable.Our analysis further locates the trigger for the backgroundfunctionality at line 9 to disable its invocation. According to
Table II, removing the unwanted advertisement in this app
results in 36.6% of data usage reduction and 14.3% of poweruse reduction.
C. Discussion
As mentioned in the introduction, our technique is intended
to help the development team automatically generate various
customizations and personalizations of an app, at the endof development cycle. It is also desirable for retroﬁtting
legacy apps whose source code or original developers are no
longer available. For instance, instead of patching a securityvulnerability in a legacy app, the maintenance team may
choose to remove the corresponding feature. While it is a valid
concern that disabling some features such as advertisements
may have negative impact on the income of the development
team, we anticipate that an alternative business model is for thedevelopment team to sell customized versions at a higher price
to compensate for the loss. A more aggressive business model
294
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:15 UTC from IEEE Xplore.  Restrictions apply. may be to sell the right of customization (using a technique
like ours that is certiﬁed by authorities) to the end users ( e.g.,
enterprises) such that the customized versions will be signedby the original development team or some authorized party on
their behalf to avoid possible legal issues.
As an initial effort of customizing apps by removing fea-
tures, our technique is limited to reducing features associ-ated with given UI elements. W e expect in the future more
techniques can be developed to customize/reduce other app
features ( e.g., background tasks not related to UIs).
In addition, our analysis inherits the limitations of Android
app analysis [12], [13], [14]. Speciﬁcally, our approach re-quires a precise and complete call graph which is usually
not satisﬁed in Android app analysis. Context-sensitive anal-
ysis, as depicted in Section III, is resource intensive, which
inevitably hinders arbitrary app code reduction. Besides, theunderlying rewriting framework Soot limits the capability of
our prototype. Even though all the 10 apps run well without
errors after code reduction, we found that some other apps(e.g., CNN) don’t work correctly after the transformation of
DEX code by Soot, even if we remove nothing in the code.In addition, removing UI elements ( e.g., advertisements) that
are embedded in HTML pages rendered by W ebView is notsupported.
While our technique has usability in consideration to begin
with as it allows users to express their needs through the UI,which is far more intuitive than some formal speciﬁcationlanguage, the implementation is still a research prototype
whose user interface has many places to improve.
V. R
ELA TED WORK
Techniques have been proposed for detecting arbitrary third-
party libraries, including ad libraries, in Android apps. Some
rely on simple techniques such as white-listing namespaces of
popular ad libraries [15], [16]. Narayanan et al. distinguished
primary and non-primary modules of apps through hierarchical
clustering [17] whereas Liu et al. developed a classiﬁer for ads
detection based on code features and package relationship [18].
LibRadar [19] relies on API frequencies. Along the same line,Backes et al. proposed an obfuscation resilient ad detection
technique, through extracting proﬁles resilient to commonobfuscation techniques and relying on class-hierarchy rather
than code [20]. In comparison, our technique is more general.
It focuses on removing features indicated by users on the UI,not just ads. It does not rely on speciﬁc code patterns.
There are also techniques that detect redundancy in appli-
cations [21], [22], [23], [24]. Their purpose is to make the
software systems more resilient to failures and to leverage
duplicated code as test oracles. They are complementary toour technique as redunda nt code can be removed/replaced for
better quality. They discover redundant code starting fromfaulty components in programs while our approach starts fromuser speciﬁcation of UI information.
In addition, a lot of works aim at improving energy
efﬁciency. Gottschalk et al. detected and removed energy-
wasting code in Android apps with the knowledge of energy-inefﬁciency patterns [25], [26]. Sahin et al. studied energy
consumption caused by code obfuscation in mobile apps [27].
Gui et al. measured energy consumption of mobile ads [28].
Banerjee et al. proposed a technique of refactoring Android
apps to enhance energy efﬁciency following a set of guide-
lines [29]. Wu et al. statically detected energy defects in
app UIs with predeﬁned energy draining patterns [30]. Our
proposed approach doesn’t rely on code patterns, nor does it
require domain knowledge to work properly. Energy savingoccurs because of the removal of selected unwanted features.
Martins et al. presented T
AMER to improve battery lifetime
by instrumenting the Android OS and interposing events andsignals that cause background task wakeups [31]. Linares-
Váseuez et al. [32] and Li et al. [33] proposed approaches
for reducing display energy through automatically changing
the color schemes.
There are works using UI info rmation to detect attacks or
privacy leaks. AsDroid [34] uses UI information to conﬁrm
whether a program behavior is expected by the app user.
SUPOR [35], UIPicker [36] and BidText [37] utilize UI
information to check data sensitiveness displayed or enteredon UI. In particular, BidText [37] features a type system
for information disclosure detection by recognizing the text
information as types and performs type propagation along data
ﬂows. The type-based taint analysis system developed by Ernst
et al. predeﬁnes a few security types and checks if types reach
a program point are compatible [38].
VI. C
ONCLUSION
W e propose a static technique to remove code elements
in Android apps. The code elements are relevant to user
speciﬁed unwanted UI elements. The approach identiﬁes the
program locations directly refe rring to the speciﬁc UI elements
and applies a type system to infe r removable code elements.
Each reachable code element is tagged with a type that ispropagated. The types are used to determine whether thecorresponding code elements are removable or not. In addition
to removing code elements that are related to the speciﬁed UI
elements, our technique is also able to discover the associated
background functiona lities and type the c orresponding code
elements in the background functionalities such that they canbe removed too. W e implement a prototype and evaluate it
on 10 real-world Android apps. The results show that our
approach can accurately identif y removable code elements
associated with the speciﬁed UI elements and removing those
functionalities leads to substantial resource savings.
A
CKNOWLEDGMENTS
W e thank the anonymous reviewers for their construc-
tive comments. This research was supported, in part, by
DARP A under contract FA8650-15-C-7562, NSF under awards
1409668, 1320444, and 1320306, and ONR under contracts
N000141410468 and N000141712947. Any opinions, ﬁndings,and conclusions in this paper are those of the authors only and
do not necessarily reﬂect the views of our sponsors.
295
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:15 UTC from IEEE Xplore.  Restrictions apply. REFERENCES
[1] Search Engine Watch, “Mobile now exceeds PC: The biggest shift
since the Internet began,” https://searchenginewatch. com/sew/opinion/
2353616/mobile- now-exceeds- pc-the- biggest- shift-since- the-internet-began.
[2] A. Brain, “Statistics of Android a d networks,” https://www.appbrain.
com/stats/libraries/ad.
[3] J. Boutet, “Malicious Android applications: Risks and exploitation,”
https://www.sans.org/reading- r oom/whitepapers/threats/malicious-
android- applications- risks-exploitation- 33578.
[4] M. Egele, C. Kruegel, E. Kirda, and G. Vigna, “PiOS: Detecting
privacy leaks in iOS applications,” in Proceedings of the Network and
Distributed System Security Symposium , ser. NDSS 2011.
[5] W. Enck, P . Gilbert, B.-G. Chun, L. P . Cox, J. Jung, P . McDaniel,
and A. N. Sheth, “Taintdroid: An inf ormation-ﬂow tracking system for
realtime privacy monitoring on smartphones,” in Proceedings of the 9th
USENIX Conference on Operating Systems Design and Implementation ,
ser. OSDI 2010.
[6] V . Rastogi, R. Shao, Y . Chen, X. Pan, S. Zou, and R. Riley, “Are
these ads safe: Detecting hidden attacks through the mobile app-webinterfaces,” in Proceedings of the Network and Distributed System
Security Symposium , ser. NDSS 2016.
[7] J. Gui, S. Mcilroy, M. Nagappan, and W. G. J. Halfond, “Truth in
advertising: The hidden cost of mob ile ads for software developers,”
inProceedings of the 37th International Conference on Software Engi-
neering , ser. ICSE 2015.
[8] Earth Networks, “Weather by Weath erBug,” https://play.google.com/
store/apps/details?id=com.aws.android.
[9] T. Book, “Privacy concerns in A ndroid advertisin g libraries,” in Master
Thesis , 2013.
[10] “Soot: A framework for analyzing and transforming Java and Android
applications,” http://sable.github.io/soot/.
[11] M. An, “Why people block ads (and what it means for marketers and ad-
vertisers),” https://re search.hubspot.com/repor ts/why-people- block-ads-
and-what- it-means-for-marketers- and-advertisers.
[12] Y . Wang, H. Zhang, and A. Rountev, “On the unsoundness of static
analysis for Android GUIs,” in Proceedings of the 5th ACM SIGPLAN
International Workshop on State Of the Art in Program Analysis ,s e r .
SOAP 2016.
[13] L. Li, T. F. Bissyandé, D. Octeau, and J. Klein, “Droidra: Taming
reﬂection to support whole-program analysis of Android apps,” inProceedings of the 25th International Symposium on Software Testing
and Analysis , ser. ISSTA 2016.
[14] L. Li, T. F. Bissyand, M. Papadakis, S. Rasthofer, A. Bartel, D. Octeau,
J. Klein, and L. Traon, “Static analysis of Android apps,” Inf. Softw.
Technol. , vol. 88, no. C, Aug. 2017.
[15] M. C. Grace, W. Zhou, X. Jiang, and A.-R. Sadeghi, “Unsafe exposure
analysis of mobile in-app advertisements,” in Proceedings of the Fifth
ACM Conference on Security and Privacy in Wireless and Mobile
Networks , ser. WISEC 2012.
[16] T. Book, A. Pridgen, and D. S. Wallach, “Longitudinal analysis of
Android ad library permissions,” CoRR , vol. abs/1303.0857, 2013.
[17] A. Narayanan, L. Chen, and C. K. Chan, “Addetect: Automated detection
of Android ad libraries using semantic analysis,” in 2014 IEEE Ninth
International Conference on Intelligent Sensors, Sensor Networks andInformation Processing , ser. ISSNIP 2014.
[18] B. Liu, B. Liu, H. Jin, and R. Govindan, “Efﬁcient privilege de-
escalation for ad libraries in mobile apps,” in Proceedings of the 13th
Annual International Conference on Mobile Systems, Applications, andServices , ser. MobiSys 2015.
[19] Z. Ma, H. Wang, Y . Guo, and X. Chen, “Libradar: Fast and accurate
detection of third-party libraries in Android apps,” in Proceedings of the
38th International Conference on Software Engineering Companion ,s e r .
ICSE 2016.
[20] M. Backes, S. Bugiel, and E. Derr, “Reliable third-party library detection
in Android and its security applications,” in Proceedings of the 2016
ACM SIGSAC Conference on Computer and Communications Security ,
ser. CCS 2016.[21] A. Carzaniga, A. Gorla, N. Perino, and M. Pezzè, “Automatic
w
orkarounds for web applications,” in Proceedings of the Eighteenth
ACM SIGSOFT International Sym posium on Foundations of Software
Engineering , ser. FSE 2010.
[22] A. Carzaniga, A. Gorla, A. Mattavelli, N. Perino, and M. Pezzè,
“Automatic recovery from runtime failures,” in Proceedings of the 2013
International Conference on Software Engineering , ser. ICSE 2013.
[23] A. Carzaniga, A. Gofﬁ, A. Gor la, A. Mattavelli, and M. Pezzè, “Cross-
checking oracles from intrinsic software redundancy,” in Proceedings of
the 36th International Conference on Software Engineering,s e r .I C S E2014.
[24] A. Gofﬁ, A. Gorla, A. Mattavelli, M. Pezzè, and P . Tonella, “Search-
based synthesis of equivalent method sequences,” in Proceedings of
the 22nd ACM SIGSOFT International Symposium on Foundations of
Software Engineering, ser. FSE 2014.
[25] M. Gottschalk, M. Joseﬁok, J. Jelschen, and A. Winter, “Removing
energy code smells with reengineering services,” in Informatik 2012 .
[26] J. Jelschen, M. Gottschalk, M. Joseﬁok, C. Pitu, and A. Winter, “To-
wards applying reengineering ser vices to energy-efﬁcient applications,”
inProceedings of the 2012 16th European Conference on Software
Maintenance and Reengineering , ser. CSMR 2012.
[27] C. Sahin, M. Wan, P . Tornquist, R . McKenna, Z. Pearson, W. G. Halfond,
and J. Clause, “How does code obfuscation impact energy usage?”
Journal of Software: Evolution and Process , vol. 28, no. 7, pp. 565–
588, 2016.
[28] J. Gui, D. Li, M. Wan, and W. G. Halfond, “Lightweight measurement
and estimation of mobile ad energy consumption,” in Proceedings of
the International Workshop on Green and Sustainable Software ,s e r .
GREENS 2016.
[29] A. Banerjee and A. Roychoudhury, “Automated re-factoring of Android
apps to enhance energy-efﬁciency,” in Proceedings of the International
Conference on Mobile Software Engineering and Systems , ser. MOBILE-
Soft 2016.
[30] H. Wu, S. Y ang, and A. Rountev, “Static detection of energy defect pat-
terns in Android applications,” in Proceedings of the 25th International
Conference on Compiler Construction , ser. CC 2016.
[31] M. Martins, J. Cappos, and R. Fonseca, “Selectively taming background
Android apps to improve battery lifetime,” in Proceedings of the
2015 USENIX Conference on Usenix Annual Technical Conference ,s e r .
USENIX A TC 2015.
[32] M. Linares-Vásquez, G. Bavota, C. E. B. Cárdenas, R. Oliveto,
M. Di Penta, and D. Poshyvanyk, “Optimizing energy consumption ofguis in Android apps: A multi-objective approach,” in Proceedings of
the 2015 10th Joint Meeting on Foundations of Software Engineering ,
ser. ESEC/FSE 2015.
[33] D. Li, A. H. Tran, and W. G. J. Halfond, “Optimizing display energy
consumption for hybrid Android apps (invited talk),” in Proceedings of
the 3rd International Workshop on Software Development Lifecycle forMobile , ser. DeMobile 2015.
[34] J. Huang, X. Zhang, L. Tan, P . Wang, and B. Liang, “Asdroid: Detecting
stealthy behaviors in Android applicati ons by user interface and program
behavior contradiction,” in Proceedings of the 36th International Con-
ference on Software Engineering , ser. ICSE 2014.
[35] J. Huang, Z. Li, X. Xiao, Z. Wu, K. Lu, X. Zhang, and G. Jiang,
“Supor: Precise and scalable sensitive user input detection for Androidapps,” in Proceedings of the 24th USENIX Security Symposium ,s e r .
USENIX Security 2015. [Online]. Available: http://blogs.usenix.org/
conference/usenixsecurity15/technical- sessions/presentation/huang
[36] Y . Nan, M. Y ang, Z. Y ang, S. Zhou, G. Gu, and X. Wang, “Uipicker:
User-input privacy identiﬁcation in mobile applications,” in Proceedings
of the 24th USENIX S ecurity Symposium , ser. USENIX Security 2015.
[37] J. Huang, X. Zhang, and L. Tan, “Detecting sensitive data disclosure via
bi-directional text correlation analysis,” in P
 roceedings of the 2016 24th
ACM SIGSOFT International Sym posium on Foundations of Software
Engineering , ser. FSE 2016.
[38] M. D. Ernst, R. Just, S. Millstein, W. Dietl, S. Pernsteiner, F. Roesner,
K. Koscher, P . B. Barros, R. Bhoras kar, S. Han, P . Vines, and E. X.
Wu, “Collaborative veriﬁcation of information ﬂow for a high-assuranceapp store,” in Proceedings of the 2014 ACM SIGSAC Conference on
Computer and Communications Security , ser. CCS 2014.
296
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:53:15 UTC from IEEE Xplore.  Restrictions apply. 