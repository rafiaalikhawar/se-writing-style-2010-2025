Investigating the Impact of Multiple Dependency
Structures on Software Defects
Di Cuiâˆ—, Ting Liuâˆ—, Yuanfang Caiâ€ , Qinghua Zhengâˆ—, Qiong Fengâ€ , Wuxia Jinâˆ—, Jiaqi Guoâˆ—,Y uQ uâˆ—
âˆ—School of Electronic and Information Engineering, Xian Jiaotong University, Xian 710049, China
{cuidi, wx jin, jasperguo2013 }@stu.xjtu.edu.cn; {tingliu, qhzheng. quyuxjtu }@mail.xjtu.edu.cn
â€ Department of Computer Science, Drexel University, Philadelphia, USA
{yc349, qf28 }@drexel.edu
Abstract â€”Over the past decades, numerous approaches were
proposed to help practitioner to predict or locate defective ï¬les.
These techniques often use syntactic dependency, history co-
change relation, or semantic similarity. The problem is that, it
remains unclear whether these different dependency relations
will present similar accuracy in terms of defect prediction and
localization. In this paper, we present our systematic investigation
of this question from the perspective of software architecture.
Considering ï¬les involved in each dependency type as an indi-
vidual design space, we model such a design space using one
DRSpace . We derived 3 DRSpaces for each of the 117 Apache
open source projects, with 643,079 revision commits and 101,364
bug reports in total, and calculated their interactions with defec-
tive ï¬les. The experiment results are surprising: the three depen-
dency types present signiï¬cantly different architectural views,
and their interactions with defective ï¬les are also drastically
different. Intuitively, they play completely different roles when
used for defect prediction/localization. The good news is that the
combination of these structures has the potential to improve the
accuracy of defect prediction/localization. In summary, our work
provides a new perspective regarding to which type(s) of relations
should be used for the task of defect prediction/localization. These
quantitative and qualitative results also advance our knowledge
of the relationship between software quality and architectural
views formed using different dependency types.
Index Terms â€”Software Structure, Software Maintenance, Soft-
ware Quality.
I. I NTRODUCTION
Over the past decades, numerous approaches were proposed
tohelp practitioner to predict or locate defective ï¬les [1â€“
7], and various dependency structures were used as the basis
for bug prediction/localization algorithms. To the best of
our knowledge, three types of dependency relations have
been frequently and intensively used by researchers: syntactic
relation (derived from source code, such as inheritance and
method call), history relation (derived from the commit history
of a project, mainly co-change frequency among ï¬les), and
semantic relation (derived from identiï¬ers and comments, and
calculate the similarity among software entities). All of these
three relations have been used as features to predict or locate
software defect. The problem is that, it is not clear if and to
extent these dependency relations differ from each other. Prior
research focused on prediction/localization algorithms, but not
on the underlying dependency types, a more fundamental
question.
Ting Liu is the corresponding author.In this paper, we explore the following research questions:
F or these three dependency relations, to what extent are
their structures similar to each other? There are a large
number of publications on using one of them to predict/locate
defects and reported reasonably performance. It is intuitive
that these dependency structures should be highly similar.
We are interested in quantifying the similarity among these
dependency structures to test this intuition.
If and to what extent will these three dependency relations
present similar performance in defect prediction and localiza-
tion tasks? It is unclear whether they have similar relations
with error-prone ï¬les. If the answer is yes, it means that
there is no fundamental difference among these dependency
relations. However, if the answer is no, we need to further
investigate the next question.
Whether the combination of these three dependency struc-
tures has the potential to improve the performance of defect
prediction and localization? If the answer is no, it implies
that these different structures can not be effectively and
efï¬ciently used together, and we should consider which one
to choose. If yes, we further explore how the intersection and
union of these three relations contribute to software defects
prediction/localization.
To answer these questions, we need to systematically in-
vestigate the impact of these dependency structures and their
relations with defective ï¬les. The ideal approach would be us-
ing these dependency types to conduct bug prediction/location
analyses and make a comparison. However, it is not realistic
given the large number of existing tools and algorithms. More-
over, these prediction/classiï¬cation models are black boxes,
hiding the intrinsic relations between these software structures
and defective ï¬les. Instead, we try to reveal the relations by
reversely explaining defects from the perspective of software
architecture views (white box), as shown in Fig. 1.
We employ the DRSpace [8, 9] model, a state-of-the-art
reverse engineering and architecture modeling technique, to
support our study. A DRSpace can be used to model the overall
software architecture as multiple overlapping design spaces.
Each design space can only capture one of many possible
relations. The DRSpace model is also an effective approach to
analyzing software structures in a ï¬ne-grained way.
In this paper, we report our comprehensive empirical study
to investigate the relation of three dependency types (syntactic,
5842019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)
1558-1225/19/$31.00 Â©2019 IEEE
DOI 10.1109/ICSE.2019.00069
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:16 UTC from IEEE Xplore.  Restrictions apply. history, and semantic) with software defects. We intensively
studied 117 Apache open source projects with 643,079 revi-
sion commits and 101,364 bug reports. Using DRSpaces , for
each dependency type, we calculate the interaction between
its design space and defective ï¬les. Based on these data, we
answer the three research questions as follows:
First, comparing the structures formed by syntactic rela-
tion, history relation, and semantic relation, only 25% of
these structures are similar. This result implies that these
three dependency relations form drastically different archi-
tecture views. Intuitively, their effectiveness on defect predic-
tion/localization should be very different and it is imperative
to explore their inï¬‚uences on software defects.
Second, the syntactic, history, and semantic relations capture
different subsets of defective ï¬les. The syntactic structure cap-
tures the largest number of defective ï¬les but with the lowest
accuracy. By contrast, the history structure covers the least
number of defective ï¬les but with high accuracy. The semantic
structure is in-between. It implies that, although there are rich
literature on using one dependency structure to predict/locate
software defects, we should be aware of their signiï¬cant
differences. We need a comprehensive understanding regarding
to the relation between dependency types and defects.
Third, the combination of syntactic structure, history struc-
ture, and semantic structure has the potential to effectively
improve the performance of defect prediction/localization: the
union of them can cover most of the defective ï¬les, and
their intersections can capture ï¬les with most severe problems.
We present the detailed results in Section III. The design of
strategies to ï¬‚exibly combine these three structures to improve
the prediction/localization accuracy is future work.
The contribution of our work is:
â€¢A systematic comparative analysis of different types of
dependencies and their impact on defects. Our empirical
study has revealed, for the ï¬rst time, their drastically
different relations with defective ï¬les, which advanced
our understanding of three dependency types.
â€¢A new perspective to analyze the software defects. Our
empirical study revealed that different dependency struc-
ture captures drastically different subsets of defective
ï¬les. When a bug prediction/localization algorithm is
devised, the designer should take their differences into
account. The union of all three relations can capture more
buggy ï¬les, but their intersection may capture most severe
bugs. Each option comes with costs and beneï¬ts.
â€¢A benchmark to investigate the relation between software
defects and various dependency structures. We collected
117 Apache open projects involving 643,079 revision
commits, and 101,364 bug reports. All original data and
extracted dependencies are publically available1.
The rest of the paper is organized as follows: Section II
presents the related work. Section III and IV introduce our
methodology and experiment results. Section V presents the
1https://github.com/cuidi34/ICSE19-Data.git
ÄÆ‰ÄÅ¶ÄšÄÅ¶ÄÇ‡^ÆšÆŒÆµÄÆšÆµÆŒÄ Å¯Ä‚ÄÅ¬Å½Ç† >Å½ÄÄ‚ÆšÄÍ¬WÆŒÄÄšÅÄÆšÄÄ¨ÄÄÆš
tÅšÅÆšÄÅ½Ç† ÆµÅZÄÆ‰Å½ÆŒÆšÄ‚ÆšÄ‚ÄÄ‚ÆÄ
 ÆµÅÍ²Æ‰ÆŒÅ½Å¶Ä^ÆšÆŒÆµÄÆšÆµÆŒÄWÆŒÄÄšÅÄÆšÅÅ¶Å
ÄÄ¨ÄÄÆšÆ
Ç†Æ‰Å¯Ä‚ÅÅ¶ÅÅ¶Å
ÄÄ¨ÄÄÆšÆ
Fig. 1: Predicting Defects vs Explaining Defects
discussion. Section VI presents the threats to validity. Section
VII concludes the paper.
II. R ELATED WORK
A. Using Dependency Structures to Predict Defects
Over the past decades, using various dependency structures
to predict software defects has been widely studied [1â€“7]. We
summarized classical defect prediction framework in Fig. 2,
which contains three steps: 1) generating dependency struc-
tures, 2) deriving structural measurements, and 3) training
prediction models. In each step, researchers designed various
strategies to improve the accuracy of defect prediction. For
example, within the ï¬rst two steps, Selby and Basili [1] ï¬rst
studied syntactic metrics to predict bug-prone ï¬les. Nagappan
et al. [2] also derived complexity metrics based on syntactic
structures to improve prediction accuracy. Zimmermann et al.
[3] reported that syntactic-based network measures could be
used to construct successful defect predictor. Furthermore,
Cataldo et al. [4] derived change density metrics to mea-
sure history structures for defect prediction. Lin et al. [6]
used advanced machine learning algorithms to automatically
measure semantic structures to improve prediction accuracy.
For the third step, researchers also employed several machine
learning algorithms to train classiï¬cation models to improve
the accuracy of defect prediction. For instance, Li et al.
[10] leveraged ensemble and kernel learning algorithms in
defect prediction to improve the training model. Di Nucci [11]
proposed an adaptive method to dynamically select classiï¬ers
for defect prediction tasks. Our work aims to advance our
understanding regarding to the impact of different software
dependency types on defect prediction/localization, but not to
propose a new prediction/localization approach.
B. Reverse Engineering Techniques
Reverse-engineering is a technique to recover high-level
design from source code. Over the past decades, there are rich
literature about reverse engineering techniques [12â€“15]. These
techniques ï¬rst aggregate program entities, such as ï¬les or
classes, into modules based on different rationales. For exam-
ple, Algorithm for Comprehension-driven Clustering (ACDC )
[12] is a pattern-driven technique proposed by Tzperpos and
Holt, which clusters entities based on naming conventions and
syntactic structures. Architecture Recovery Using Concerns
585
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:16 UTC from IEEE Xplore.  Restrictions apply. >Å½ÄÄ‚ÆšÄÄÄ¨ÄÄÆšÆ ^Å½ÆµÆŒÄÄÅ½ÄšÄ ÄÆ‰ÄÅ¶ÄšÄÅ¶ÄÇ‡^ÆšÆŒÆµÄÆšÆµÆŒÄÆ ÄÆ‰ÄÅ¶ÄšÄÅ¶ÄÇ‡DÄÄ‚ÆÆµÆŒÄÅµÄÅ¶ÆšÆ WÆŒÄÄšÅÄÆšÅÅ½Å¶DÅ½ÄšÄÅ¯
Fig. 2: Classic Defect Prediction Framework
(ARC ) [13] is a NLP-based techniques proposed by Joshua
et al. that leverages semantic structures. Back et al. [16] ï¬rst
leveraged the combination of history and syntactic structures
to improve the quality of recovered design. Mitchell et al.
also proposed a genetic method named Bunch , which improves
reverse engineering results by optimizing objective functions
[17]. Researchers also made systematic comparisons of these
techniques: Nenad et al. [18] conducted a comparative study of
10 reverse engineering techniques and claimed that ARC and
ACDC outperformed others in terms of accuracy. Luttellier et
al. [19] conducted another comparative study and made similar
observations. Our work uses reverse engineering methods
to understand different dependency types but not to recover
architecture.
C. Architectural Smells
Architectural smells were proposed to describe problematic
relations among ï¬les that may have negative impact on soft-
ware quality. Researchers proposed architectural smells based
on different dependency types. For instance, Garcia et al.
[20] ï¬rst deï¬ned a suite of code smells based on syntactical
structures. Ran et al. [21] integrated history and syntactical
relations and proposed a suite of architectural smells called
Hotspot Patterns . Oizumi [22] studied architectural smells by
clustering classical code smells using syntactic and semantic
structures. Fontana et al. [23, 24] summarized the previous
work and developed a tool named ARCAN to support the
automatic detection of these smells. Our work explores the
independence and combination of different dependency types
but not summarizing architectural anti-patterns.
III. M ETHODOLOGY
In this section, we present our systematical study regarding
to the impact of different dependency structures on software
defects. It is not possible for us to directly answer this question
by executing defect prediction tools given the large number
of them. Instead, we leverage DRSpace, a state-of-the-art
reverse engineering technique, to investigate different types
of relations among ï¬les, and their interaction with the set
of buggy ï¬les. Fig. 3 shows the overview of our research
framework that includes three components: Data Collection ,
DRSpaces Generation and Issue Analysis .
A. Data Collection
Here we introduce the subjects we studied, the three types
of relation we extracted, and the defect information collected
from these subjects.1)Subjects :We studied the latest versions of 117 projects
from the Apache community2. These projects vary in sizes,
domains and functionalities, and most of them are widely used
in defect prediction research. The number of ï¬les in these
projects varies from 236 to 7216. The number of lines of
code (LOC) in these projects varies from 11K to 1M. We
additionally crawled the revision history of these projects from
the version control system (Git3), and bug reports from the
issue tracking system (JIRA4). We only study bug reports that
have been ï¬xed. In total, we collected 643,079 commits and
101,364 valid bug reports.
2)Software Relation Extraction :For each subject, we
extract its structural relation, history relation, and semantic
relation as follows:
a) Syntactic Relation: Syntactic dependency is the most
commonly used relation among source ï¬les, including in-
heritance, implementation, method call, ï¬eld access, type
reference, instance creation, etc. We employed Understand5,
a commercial reverse-engineering tool, to extract structural
relations among source ï¬les, and denote the collected syntactic
relation as E1.
b) History Relation: History relation, also known as
evolutionary coupling , is derived from the revision history
of a project, modeling the co-change probability among ï¬les.
In our study, we employed the history coupling probability
(HCP ) matrix [25], a conditional probability model to manifest
how likely a change to a ï¬le may inï¬‚uence other ï¬les. We
implemented this algorithm and conï¬gure the HCP parameters
following the work of Xiao et al. [25]. We denote the collected
history relation as E2.
c)Semantic Relation: Semantic relation is derived from
the source code lexicon to capture the textual similarity
between ï¬les. Here we employed relation topic model (RTM )
[26, 27], a probabilistic topic modeling technique, to capture
the semantic relation among ï¬les based on source code identi-
ï¬ers and comments. We crawled the lexical information using
the lexicon parser in Understand , and implemented RTM using
the lda6package of R. We conï¬gure the RTM parameters
following the work of Bavota et al. [28], and denote the
collected semantic relation as E3.
We can thus model a software system as a directed multi-
graph: (V,E1,E2,E3), where Vrepresents the set of ï¬les
within the system, and E1,E2,E3represent the syntactic
2http://www.apache.org/
3https://git-scm.com/
4https://www.atlassian.com/software/jira
5https://scitools.com/
6http://cran.rproject.org/web/packages/lda/
586
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:16 UTC from IEEE Xplore.  Restrictions apply. ^Å½ÆµÆŒÄÄÅ½ÄšÄ
DÆµÅ¯ÆšÅÆ‰Å¯Ä
ÄÆ‰ÄÅ¶ÄšÄÅ¶ÄÇ‡^ÆšÆŒÆµÄÆšÆµÆŒÄÆ
^ÄÅµÄ‚Å¶ÆšÅÄ
^ÆšÆŒÆµÄÆšÆµÆŒÄ
,ÅÆÆšÅ½ÆŒÇ‡
^ÆšÆŒÆµÄÆšÆµÆŒÄ
ZÄÇ€ÅÆÅÅ½Å¶,ÅÆÆšÅ½ÆŒÇ‡
ÆµÅZÄÆ‰Å½ÆŒÆš
^Ç‡Å¶ÆšÄ‚ÄÆšÅÄ
^ÆšÆŒÆµÄÆšÆµÆŒÄ
^Ç‡Å¶ÆšÄ‚ÄÆšÅÄ
Z^Æ‰Ä‚ÄÄ
^ÄÅµÄ‚Å¶ÆšÅÄ
Z^Æ‰Ä‚ÄÄ
,ÅÆÆšÅ½ÆŒÇ‡
Z^Æ‰Ä‚ÄÄ
ÄÄ¨ÄÄÆš&ÅÅ¯ÄÆ
ÆµÅ
^Æ‰Ä‚ÄÄ
^Ç‡Å¶ÆšÄ‚ÄÆšÅÄ
^ÆµÄÍ²Z^Æ‰Ä‚ÄÄ
^ÄÅµÄ‚Å¶ÆšÅÄ
^ÆµÄÍ²Z^Æ‰Ä‚ÄÄ
,ÅÆÆšÅ½ÆŒÇ‡
^ÆµÄÍ²Z^Æ‰Ä‚ÄÄ
^Ç‡Å¶ÆšÅšÄÆÅÆ
Å¶Ä‚Å¯Ç‡ÆÅÆ
^ÆšÄÆ‰/Í—Ä‚ÆšÄ‚Å½Å¯Å¯ÄÄÆšÅÅ½Å¶ ^ÆšÄÆ‰//Í—Z^Æ‰Ä‚ÄÄ'ÄÅ¶ÄÆŒÄ‚ÆšÅÅ½Å¶
^ÆšÄÆ‰///Í—/ÆÆÆµÄÅ¶Ä‚Å¯Ç‡ÆÅÆ
Fig. 3: Research Framework
relation, history relation and semantic relation among these
ï¬les respectively.
3)Defect Information Extraction :From each project, we
also extracted defect information from bug reports recorded in
its issue tracking system. For each bug report ( BR i), we collect
the set of ï¬les changed to ï¬x it, and the lines of code (LOC)
spent on these ï¬xes. We model these data as follows:
BR i={(Fj,Churn (BR i,Fj))|j=1,2, ..., m} (1)
where mrepresents the number of ï¬les involved in the bug
(BR i). Here each bug is modeled as a set of pairs, each
containing two elements: Fjand Churn (BR i,Fj), representing
the ï¬xed ï¬le and the number of lines of code spent on it to
ï¬x the bug.
We also model the relation between bugs and source ï¬les
as follows:
Fj={(BR i,Churn (BR i,Fj))|i=1,2, ..., n} (2)
where nrepresents the number of bugs a ï¬le ( Fj) is involved.
Here each ï¬le is mapped to a set of pairs, each containing two
elements: BR iand Churn (BR i,Fj), representing an involving
bug and the number of lines of code spent to ï¬x it.
B. DRSpace Generation
In this section, we introduce our method of managing
various dependency structures using Design Rule Spaces
(DRSpaces) [8], a new architecture model.
1)Generating DRSpace :Xiao et al. proposed that a soft-
ware system can and should be viewed as multiple overlapping
design spaces that can be reverse-engineered from source code.
For example, a feature implemented, or a pattern applied,
can be viewed as an individual design space that contains
all the ï¬les participating in the feature/pattern [8]. They also
mentioned that different dependency types, such as inheritance
and method call, can form their own design spaces.
Based on this rationale, they proposed a Design Rule Space
(DRSpace) [8] model, each capturing one design space of thesystem. In a DRSpace, the ï¬les are clustered into hierarchical
layers, and each layer is decoupled into independent modules.
Files in lower layers only depend on the ï¬les in higher layers.
Files in different modules within the same layer are mutually
independent from each other. Moreover, each DRSpace has
one or a few leading ï¬les , and all other ï¬les are directly or in-
directly depend on the leading ï¬les. For example, an observer
pattern DRSpace must contain an observer interface, upon
which all other pattern participants depend. The ï¬les within a
DRSpace can have one or more types of dependencies. This
architecture model is consistent with the deï¬nition proposed
by Bass et al. [29]: the architecture of a software system is a
set of structures, and each DRSpace is one of many module
structures within the system.
In our study, we examine a software structure through the
lenses of DRSpaces. For each subject, using the three types
of relations extracted, we model the project using a suite of
DRSpaces: Syntactic DRSpaces (SynDR ),History DRSpaces
(HisDR ), and Semantic DRSpaces (SemDR ), in which source
ï¬les only have syntactic relation, history coupling relation, and
semantic coupling relation respectively.
2)Generating Sub-DRSpace :Using each ï¬le as a leading
ï¬le, we further split each DRSpace into a set of sub-DRSpaces:
DRSpace =/braceleftbig
sub-DRSpacej|j=1,2, ..., m/bracerightbig
(3)
where mis the total number of sub-DRSpaces. Each sub-
DRSpace ( sub-DRSpacej) consists of two elements:
sub-DRSpacej=(Fj,Suboridnate (Fj)) (4)
where Fjrepresents the leading ï¬le of the sub-DRSpace and
Suboridnate (Fj)represents the ï¬les that directly or indirectly
depend on the leading ï¬le.
For each subject with xï¬les that have syntactic relation
with other ï¬les, yï¬les having history coupling with other ï¬les,
andzï¬les having semantic relation with other ï¬les, we will
generate xsyntactic sub-DRSpaces ,yhistory sub-DRSpaces ,
andzsemantic sub-DRSpaces .
587
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:16 UTC from IEEE Xplore.  Restrictions apply. (a) Syntactic
 (b) History
 (c) Semantic
Fig. 4: Three Dependency Structures of Log4j
(a) Syntactic
 (b) History
 (c) Semantic
Fig. 5: Three DRSpaces of Log4j
C. Issue Analysis
For each subject, given the three DRSpaces and their sub-
DRSpaces, we now present our method of analyzing their
relations with defective, i.e., error-prone ï¬les.
Following the work of Xiao et al. [8], we ï¬rst use a
BugSpace to model the set of ï¬les involved in bug ï¬xing.
We use BugFre x%ileto model the set of ï¬les within the top
xthpercentile of a BugSpace , ranked based on the number of
times they were changed for bug-ï¬xing (bug frequency). We
also use BugChurn x%ileto model the most expensive ï¬les,
ranked within the top xthpercentile based on their lines of
code (LOC) spent on bug ï¬xing (bug churn).
ArchRoot [8, 30] is a greedy algorithm designed to extract
a set of sub-DRSpaces that covers a target set of error-
prone ï¬les, that is, ï¬les within a bug space BugFre x%ile,o r
BugChurn x%ile. The input of this algorithm is a DRSpace
containing all the ï¬les within the system, and a target bug
space. ArchRoot iteratively inspects each sub-DRSpace and
calculates its intersection with the target bug space, and return
a set of sub-DRSpaces. In our study, we denote the union of
all the ï¬les within the sub-DRSpaces calcuated from ArchRoot
as a RootSpace .
D. Running Example
In this section, we demonstrate these concepts and our
method using a running example, Log4j 2.8.27, a distributed
logging system.
Data Collection. We extracted the syntactic relation and
semantic relation from Log4j, version 2.8.2. In this snapshot,
there are 1702 ï¬les, and 8823 pairs of them have structural
relations, and 2678 pairs have at least 70% semantic similarity.
To extract history coupling relation, we collect 9425 revision
commits from May 2010 to Aug 2017. Within this time
period, there are 137 ï¬le pairs having at least 30% co-change
probability. Within the same history period, we collected 634
bug reports that have been resolved, and there are 136 ï¬les
changed to ï¬x these bugs.
7https://logging.apache.org/log4j/2.x/We employ Gephi8, an open source graph visualization
platform, to model these three relations as graphs, as shown
in Fig. 4 (a)-(c). These graphs depict the syntactic structure ,
history structure , and semantic structure among Log4j source
ï¬les, in which vertexes represent ï¬les and edges represent
different relations among them. As we can see from these
graphs, the overall structure formed by these relations are very
different.
DRSpace and Sub-DRSpace Extraction. For each relation,
we generate its DRSpace using Titan [31], a visualization tool
that present ï¬le structures using Design Structure Matrices
(DSMs). A DSM is a square matrix in which rows and columns
are labeled by the same set of ï¬les in the same order. A marked
cell in row xand column y,cell(x, y), means that the ï¬le in
row xdepends on the ï¬le in column y. The marks in the
cells can be used to denote different types of relations. Fig.
5.(a)-(c) depicts the Syntactic DRSpace ,History DRSpace and
Semantic DRSpace of Log4j. Similar to Fig. 4, we can observe
that these structures are drastically different.
For each DRSpaces , we decouple it into a set of sub-
DRSpaces , each led by one ï¬le within the DRSpace. Fig.
6-8 depicts the syntactic sub-DRSpace, history sub-DRSpace
and semantic sub-DRSubpaces led by the same leading ï¬le:
FileManager of Log4j. We explain these DSMs as follows:
Fig. 6 shows the syntactic sub-DRSpace led by
FileManager .Cell(5,1) is labeled with â€œ dpâ€, which
means that DefaultRolloverStrategy syntactically depends
on FileManager . Fig. 7 shows its history sub-DRSpace.
Cell(5,1)is labeled with â€œ (hc,30%) ,#7â€. â€œ(hc,30%) â€
means that DefaultRolloverStrategy is historically coupled
with FileManager and the co-change probability is 30%.
â€œ#7â€ means that these two ï¬les changed together 7 times as
recorded in the commit history. Fig. 8 shows the semantic
sub-DRSpace led by the same ï¬le. Cell(5,1)is labeled with
â€œ(sc,82%) â€, which means that DefaultRolloverStrategy has
82% lexical similarity with FileManager .
Issue and Root Analyses. The sub-DRSpaces shown in Fig.
6-8 are among the output sub-DRSpaces of the ArchRoot
algorithm. The input of this algorithm includes each DRSpace
and all the ï¬les involved in bug ï¬xing, e.g. BugFeq 100% ile.
This means that these sub-DRSpaces cover all the error-prone
ï¬les and reveal their relations.
For example, the columns FRand CRillustrate the rankings
of each ï¬le based on its bug frequency and bug churn. As we
can see, in addition to the leading ï¬le, DefaultRolloverStrategy
and RollingFileManager are ranked within top 1%ile and
top 2%ile resprectively, and are captured by all three sub-
DRSpaces. Other than that, however, the ï¬les captured by
these sub-DRSpaces are very different. Next we explore if
and to what extent their ability of capturing buggy ï¬les are
different.
IV . E XPERIMENT
In this section, we present our exploration of the following
three research questions to understand the impact of different
8https://gephi.org/
588
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:16 UTC from IEEE Xplore.  Restrictions apply. &Z Z Ï­Ï®Ï¯Ï°Ï±Ï²Ï³Ï´
Ï­&ÅÅ¯ÄDÄ‚Å¶Ä‚ÅÄÆŒ Ï°Ğ¹ ÏµĞ¹ Í¾Ï­Í¿
Ï®ZÅ½Å¯Å¯ÅÅ¶Å&ÅÅ¯ÄDÄ‚Å¶Ä‚ÅÄÆŒ Ï®Ğ¹ Ï³Ğ¹ ÄšÆ‰Í¾Ï®Í¿
Ï¯&ÅÅ¯ÄÆ‰Æ‰ÄÅ¶ÄšÄÆŒ Ï¯Ï®Ğ¹ Ï­Ï¯Ğ¹ ÄšÆ‰Í¾Ï¯Í¿
Ï°ZÅ½Å¯Å¯ÅÅ¶ÅZÄ‚Å¶ÄšÅ½ÅµÄÄÄÆÆ&ÅÅ¯ÄDÄ‚Å¶Ä‚ÅÄÆŒ Ï´Ğ¹ Ï®Ï²Ğ¹ ÄšÆ‰ ÄšÆ‰Í¾Ï°Í¿
Ï±ÄÄ¨Ä‚ÆµÅ¯ÆšZÅ½Å¯Å¯Å½Ç€ÄÆŒ^ÆšÆŒÄ‚ÆšÄÅÇ‡ Ï­Ğ¹ Ï¯Ğ¹ ÄšÆ‰ ÄšÆ‰ Í¾Ï±Í¿
Ï²ÅÆŒÄÄÆštÆŒÅÆšÄZÅ½Å¯Å¯Å½Ç€ÄÆŒ^ÆšÆŒÄ‚ÆšÄÅÇ‡ Ï²Ï®Ğ¹ Ï°ÏµĞ¹ ÄšÆ‰ ÄšÆ‰ Í¾Ï²Í¿
Ï³ZÅ½Å¯Å¯ÅÅ¶Å&ÅÅ¯ÄÆ‰Æ‰ÄÅ¶ÄšÄÆŒ Ï±Ï¬Ğ¹ Ï±Ğ¹ ÄšÆ‰ ÄšÆ‰ÄšÆ‰ Í¾Ï³Í¿
Ï´ZÅ½Å¯Å¯ÅÅ¶ÅÆ‰Æ‰ÄÅ¶ÄšÄÆŒ^ÅÇŒÄdÄÆÆš Ï°Ğ¹ Ï³Ğ¹ ÄšÆ‰ ÄšÆ‰ ÄšÆ‰Í¾Ï´Í¿
Fig. 6: Syntactic sub-DRSpace of FileManager
&Z Z Ï­Ï® Ï¯Ï°Ï±Ï²
Ï­&ÅÅ¯ÄDÄ‚Å¶Ä‚ÅÄÆŒ Ï°Ğ¹ ÏµĞ¹ Í¾Ï­Í¿ Í•Î·Ï­Ï² Í•Î·Ï­Ï° Í•Î·Ï­Ï® Í•Î·Ï³ Í•Î·Ï³
Ï®ZÅ½Å¯Å¯ÅÅ¶Å&ÅÅ¯ÄDÄ‚Å¶Ä‚ÅÄÆŒ Ï®Ğ¹ Ï³Ğ¹ Í¾ÅšÄÍ•Ï³Ï¬Ğ¹Í¿Í•Î·Ï­Ï² Í¾Ï®Í¿ Í¾ÅšÄÍ•Ï¯Ï¬Ğ¹Í¿Í•Î·Ï­Ï´ Í•Î·Ï­Ï±Í•Î·Ï­Ï­ Í•Î·Ïµ
Ï¯ZÅ½Å¯Å¯ÅÅ¶ÅZÄ‚Å¶ÄšÅ½ÅµÄÄÄÆÆ&ÅÅ¯ÄDÄ‚Å¶Ä‚ÅÄÆŒ Ï´Ğ¹ Ï®Ï²Ğ¹ Í¾ÅšÄÍ•Ï²Ï­Ğ¹Í¿Í•Î·Ï­Ï° Í•Î·Ï­Ï´ Í¾Ï¯Í¿ Í•Î·Ï­Ï­Í•Î·Ï² Í•Î·Ï­Ï³
Ï°KÆµÆšÆ‰ÆµÆš^ÆšÆŒÄÄ‚ÅµDÄ‚Å¶Ä‚ÅÄÆŒ Ï²Ğ¹ Ï­Ï¬Ğ¹ Í¾ÅšÄÍ•Ï±Ï®Ğ¹Í¿Í•Î·Ï­Ï® Í•Î·Ï­Ï± Í•Î·Ï­Ï­ Í¾Ï°Í¿Í•Î·Ï±Í•Î·Ï´
Ï±ÄÄ¨Ä‚ÆµÅ¯ÆšZÅ½Å¯Å¯Å½Ç€ÄÆŒ^ÆšÆŒÄ‚ÆšÄÅÇ‡ Ï­Ğ¹ Ï¯Ğ¹ Í¾ÅšÄÍ•Ï¯Ï¬Ğ¹Í¿Í•Î·Ï³ Í•Î·Ï­Ï­ Í•Î·Ï² Í•Î·Ï±Í¾Ï±Í¿Í•Î·Ï°
Ï²DÄÅµÅ½ÆŒÇ‡DÄ‚Æ‰Æ‰ÄÄš&ÅÅ¯ÄDÄ‚Å¶Ä‚ÅÄÆŒ Ï­Ï±Ğ¹ Ï±Ï®Ğ¹ Í¾ÅšÄÍ•Ï¯Ï¬Ğ¹Í¿Í•Î·Ï³ Í•Î·Ïµ Í•Î·Ï­Ï³ Í•Î·Ï´ Í•Î·Ï°Í¾Ï²Í¿
Fig. 7: History sub-DRSpace of FileManager
dependency types, syntactic, history and semantic, on software
defect prediction/localization:
RQ1: What is the structural similarity among these different
types of relations?
The answer to this question will advance our understanding
regarding to the overall differences of these three relations.
RQ2: Does each dependency structure present similar per-
formance in terms of capturing defective ï¬les?
The answer to this question will shed lights on their
differences in terms of locating or predicting bugs.
RQ3: Can the combination of these three structures improve
the accuracy of predicting/locating defects? What about their
intersection and union?
The answer to this question will provide suggestions regard-
ing to how different relations can be better leveraged.
A. Structural Similarity
1)Approach :To answer RQ1 , we measure the overall
similarity among these three different relations using MoJoFM
[32], and use C2C [18] to measure the local similarity among
sub-DRSpaces lead by the same ï¬le. As references, we em-
ployed several state-of-the-art reverse-engineering techniques
from the ARCADE [33] toolkit for comparison. The related
concepts are listed as follows:
MoJoFM [32] is a distance score measuring between two
structures, expressed as a percentage, computed as follows:
MoJoFM (A,B)=1âˆ’/parenleftbiggmno(A,B)
max(mno(âˆ€A,B))/parenrightbigg
Ã—100% (5)
where mno(A,B)is the minimum number of Move orJoin
operations needed to transform structure A into structure B.
MoJoFM returns 0% if the two architectures are completely
different. While MoJoFM returns 100% if the two architec-
tures are same. The higher the score, the more similar the two
structures are.
C2C [18] measures to what extent two sub-DRSpaces with
the same leading ï¬le overlap. Given two sub-DRSpaces :SA
andSB with the same leading ï¬le but different substructures:
C2C(A,B)=/braceleftBigg
SAâˆ©SB
SAâˆªSB|SA|,|SB| /negationslash=0
0 other(6)&Z Z Ï­Ï® Ï¯ Ï° Ï±
Ï­ Ï­Ï±Ğ¹ Ï±Ï®Ğ¹ Í¾Ï­Í¿ Í¾ ÆÄÍ•Ï³Ï´Ğ¹Í¿
Ï®Ï° Ğ¹ÏµĞ¹ Í¾Ï®Í¿
Ï¯Ï® Ğ¹Ï³Ğ¹ Í¾ÆÄÍ•Ï³Ï®Ğ¹Í¿Í¾Ï¯Í¿ Í¾ ÆÄÍ•Ï³Ï²Ğ¹Í¿ Í¾ÆÄÍ•Ï³Ï±Ğ¹Í¿
Ï° Ï²Ï®Ğ¹ Ï°ÏµĞ¹ Í¾ ÆÄÍ•Ï´Ï¯Ğ¹Í¿Í¾ÆÄÍ•Ï´ÏµĞ¹Í¿ Í¾Ï°Í¿
Ï±Ï­ Ğ¹Ï¯Ğ¹Í¾ÆÄÍ•Ï´Ï®Ğ¹Í¿Í¾ÆÄÍ•Ï´Ï´Ğ¹Í¿ Í¾ÆÄÍ•ÏµÏ±Ğ¹Í¿ Í¾Ï±Í¿DÄÅµÅ½ÆŒÇ‡DÄ‚Æ‰Æ‰ÄÄš&ÅÅ¯ÄDÄ‚Å¶Ä‚ÅÄÆŒ
&ÅÅ¯ÄDÄ‚Å¶Ä‚ÅÄÆŒ
ZÅ½Å¯Å¯ÅÅ¶Å&ÅÅ¯ÄDÄ‚Å¶Ä‚ÅÄÆŒ
ÅÆŒÄÄÆštÆŒÅÆšÄZÅ½Å¯Å¯Å½Ç€ÄÆŒ^ÆšÆŒÄ‚ÆšÄÅÇ‡
ÄÄ¨Ä‚ÆµÅ¯ÆšZÅ½Å¯Å¯Å½Ç€ÄÆŒ^ÆšÆŒÄ‚ÆšÄÅÇ‡
Fig. 8: Semantic sub-DRSpace of FileManager
TABLE I: The MoJoFM Matrix
Technique SynDR HisDR SemDR ACDC ARC
SynDR - 8%*22%*27% 26%
HisDR -- 24%*16% 12%
SemDR - - - 19% 22%
ACDC - - - - 39%
ARC ---- -
where|SA|and|SB|represent the number of ï¬les contained
inSA andSB respectively.
ARCADE [33] is a software toolkit for reverse-engineering
architectural design from source code. We use two state-of-
the-art reverse-engineering techniques, ACDC [12] and ARC
[13] from ARCADE as references.
2)Results :Table I demonstrates the MoJoFM results as
a square matrix, where rows and columns are labeled by
the same set of recovery techniques in the same order. The
cells contain the average MoJoFM scores. Since the matrix
is symmetric, only half of the cells are labeled with scores.
For instance, the cell (2,3) is marked with â€œ 24*%â€, meaning
that the average MoJoFM score between history ( HisDR ) and
semantic ( SemDR ) DRSpaces of the 117 projects is 24%.
Fig 9 demonstrates the distribution of C2C scores among
three dependency structures. The x-axis in Fig. 9 represents
the C2C results, which is divided into 10 intervals ranging
from 0 to 100%. The y-axis represents the percentage of sub-
DRSpaces pairs whose C2Cscores fall into the given interval.
For example, the ï¬rst bar in Fig. 9 (a) shows that there are
28.4% of syntactic-history sub-DRSpace pairs have less than
10% similarity.
3)Observations :The syntactic relation, history relation,
and semantic relation present drastically different overall
structures ( <25%) : the cells in Table I marked with â€˜*â€™
denotes the average MoJoFM scores among the syntactic,
history and semantic structures of the 117 projects ( 8%-24% ).
The three DRSpaces, SynDR ,HisDR , and SemDR , are also
different from the structures derived from the state-of-the-art
reverse engineering techniques: their similarity scores with
ACDC and ARC are less than 30%: the cells in Table I not
marked with â€˜*â€™ denote the average MoJoFM score between
DRSpaces vs. ACDC/ARC ( 5%-27% ).
The syntactic structure, history structure, and semantic
structure also appear to be signiï¬cantly different when
comparing sub-DRSpaces. Fig. 9 demonstrates that 42%-
58% of sub-DRSpace pairs present relative low similarities
(<30%), and only 7%-24% of sub-DRSpace pairs present
higher similarities ( >70%).
B. The Relation between Dependency and Software Defects
1)Approach :Here we investigate the relation between
each dependency type and software defects, to answer RQ2 .
589
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:16 UTC from IEEE Xplore.  Restrictions apply. 




a aaaaaaaa a
FF3HUFHQWDJH
(a) Syntactic vs History sub-DRSpace




a aaaaaaaa a
FF3HUFHQWDJH
(b) Syntactic vs Semantic sub-DRSpace





a aaaaaaaa a
FF3HUFHQWDJH
(c) History vs Semantic sub-DRSpace
Fig. 9: The distribution of C2C
  


    
3UHFLVLRQ5HFDOO
(a) Syntactic Structure  


    
3UHFLVLRQ5HFDOO
(b) History Structure  


    
3UHFLVLRQ5HFDOO
(c) Semantic Structure
Fig. 10: The Distribution of Precision/Recall to Cover BugSpace (The x-axis represents the precision and the y-axis represents
the recall)
TABLE II: The Precision/Recall to Cover BugFre x%ile and BugChurn x%ile
BugFre x%ile BugChurn x%ile
Syntactic History Semantic Syntactic History Semantic Percentage
Precision Recall Precision Recall Precision Recall Precision Recall Precision Recall Precision Recall
10%ile 9.92% 99.29% 43.77% 31.12% 33.32% 43.49% 10.42% 99.78% 43.72% 32.32% 35.81% 41.98%
20%ile 14.43% 99.36% 48.36% 26.36% 35.63% 43.11% 14.39% 99.67% 46.98% 26.57% 35.99% 42.80%
30%ile 18.34% 99.40% 52.12% 23.86% 38.09% 42.65% 18.77% 99.31% 49.52% 23.06% 38.39% 42.54%
40%ile 22.35% 99.41% 55.55% 22.55% 40.23% 42.47% 22.39% 99.17% 52.61% 21.50% 40.15% 42.48%
50%ile 26.17% 99.39% 58.04% 21.17% 43.52% 42.15% 25.75% 99.05% 55.47% 20.13% 42.50% 42.24%
60%ile 29.47% 99.30% 61.13% 19.96% 46.37% 41.94% 29.18% 98.73% 58.81% 19.28% 45.50% 41.85%
70%ile 32.68% 99.22% 64.35% 19.14% 49.21% 41.64% 32.30% 98.71% 62.24% 18.76% 48.19% 41.46%
80%ile 35.79% 99.03% 67.47% 18.72% 51.99% 41.12% 35.55% 98.67% 66.13% 18.34% 50.80% 41.20%
90%ile 39.07% 98.80% 70.35% 18.02% 54.40% 40.69% 38.63% 98.52% 70.05% 17.88% 53.92% 40.89%
100%ile 41.87% 98.52% 73.91% 17.69% 56.92% 40.46% 41.87% 98.52% 73.91% 17.69% 56.92% 40.46%
We ï¬rst deï¬ne a speciï¬c set of error-prone ï¬les as Tar-
getSpace , which can be either ï¬les frequently involved in bug
ï¬xingâ€” BugFre x%ile, or ï¬les that are most expensive to
ï¬xâ€” BugFre x%ile. To answer RQ2 , we employed multiple
TargetSpace s, from BugFre 10% iletoBugFre 100% ile, and
from BugChurn 10% iletoBugChurn 100% ile. For each Tar-
getSpace , we use the ArchRoot algorithm to locate its corre-
sponding RootSpace and calculate its Precision and Recall as
follows:
Precision =|RootSpace âˆ©TargetSpace |
|RootSpace |(7)
Recall =|TargetSpace âˆ©BugSpace |
|BugSpace |(8)
For each DRSpace formed using syntactic, history, or se-
mantic relation, and each TargetSpace , we run the ArchRoot
algorithm and calculate their precision and recall scores.
2)Results :Table II presents the average precision and
recall scores of the 117 subjects to cover from BugFre 10% ileto BugFre 100% ile, and from BugChurn 10% ile to
BugChurn 100% ile using syntactic structure, history
structure, and semantic structure respectively. Fig. 10 depicts
the distribution of precision/recall scores of these subjects,
where each point represents a subject. Fig. 11 demonstrates
the trend of these scores in Table II.
3)Observations :The syntactic structure, history struc-
ture, and semantic structure present completely different
coverage over bug-prone ï¬les ( BugSpace ). The results in Ta-
ble II and Fig. 10 demonstrate that syntactic structures present
the highest recall (98.5%) but the lowest precision (41.9%) on
average. This is not surprising because the syntactic structure
contains the largest number of ï¬les.
On the contrary, history structures present the highest
precision (73.9%) but the lowest recall (17.7%), which is
understandable since not all buggy ï¬les have to be historically
coupled with other ï¬les. The result of semantic structure is in-
between, 56.9% precision and 40.5% recall on average.
In summary, the three relations present signiï¬cantly dif-
ferent capabilities in term of covering error-prone ï¬les. The
590
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:16 UTC from IEEE Xplore.  Restrictions apply.     

    
%XJ)UHB[3UHFLVLRQ5HFDOO3UHFLVLRQ
5HFDOO
(a)BugFre x%ile Covered by Syn-
tactic Structure    

    
%XJ&KXUQ B[3UHFLVLRQ5HFDOO3UHFLVLRQ
5HFDOO
(b) BugChurn x%ile Covered
bySyntactic Structure




    
%XJ)UHB[3UHFLVLRQ5HFDOO3UHFLVLRQ
5HFDOO
(c) BugFre x%ile Covered by His-
tory Structure 



    
%XJ&KXUQ B[3UHFLVLRQ5HFDOO3UHFLVLRQ
5HFDOO
(d) BugChurn x%ile Covered by
History Structure
 
 
  

    
%XJ)UHB[3UHFLVLRQ5HFDOO3UHFLVLRQ
5HFDOO
(e) BugFre x%ile Covered by Se-
mantic Structure 
 
  

    
%XJ&KXUQ B[3UHFLVLRQ5HFDOO3UHFLVLRQ
5HFDOO
(f)BugChurn x%ile Covered by Se-
mantic Structure
Fig. 11: The Trend of Precision/Recall results of Covering
BugFre x%ile and BugChurn X%ile (The x-axis represents
the BugFre x%ile /BugChurn x%ile and the y-axis represent
the precision/recall)
implication is that, using just one of these relations to conduct
bug prediction/localization will not be sufï¬cient.
C. Dependency Interaction and the Impact on Software defects
1)Approach :To answer RQ3 , we exhaustively studied the
intersection and union of syntactic structure, history structure,
and semantic structure. In total, we generated 8 combinations
of these three dependency structures, measured their interac-
tion with two representative TargetSpace s,BugFre 10% ileand
BugFre 100% ile, and made a systematic comparison.
Generating Combinations: The 8 combinations include: Syn
âˆ©His,Synâˆ©Sem,Hisâˆ©Sem,Synâˆ©Hisâˆ©Sem,SynâˆªHis,
SynâˆªSem,HisâˆªSem, and SynâˆªHisâˆªSem, where Syn,His
and Sem are the abbreviation for syntactic structure, history
structure, and semantic structure. The notation, âˆª, represents
the union operator and âˆ©represents the intersection operator.
Combination measures: For each combination, we gener-
ated its DRSpace, and calculated sub-DRSpaces covering two
TargetSpace s:BugFre 10% ileand BugFre 100% ileusing the
ArchRoot algorithm to generate a RootSpace . As an example,
consider the union of the three structures: ( SynâˆªHisâˆªSem).
Fig. 12 depicts its sub-DRSpace led by FileManager in Log4j.To measure these results, in addition to precision and recall,
we also employ three additional metrics as follows:
File% measures the percentage of ï¬les involved in each
combination.
BFR , following the work of Mo et al. [21], measures the
average bug frequency of each ï¬le in a calculated RootSpace
versus the average bug frequency of all the ï¬les within the
BugSpace , deï¬ned as:
BFR =BugFre (RootSpace )
BugFre (BugSpace )Ã—|BugSpace |
|RootSpace |Ã—100% (9)
where|RootSpace |and|BugSpace |represent the number of
ï¬les involved in them. BugFre (RootSpace )represents the sum
of the number of bug ï¬xes for each ï¬le involved in RootSpace .
BCR , similarly, measures the average bug churn of each ï¬le
in a calculated RootSpace versus the average bug churn of all
the ï¬les within the BugSpace , deï¬ned as
BCR =BugChurn (RootSpace )
BugChurn (BugSpace )Ã—|BugSpace |
|RootSpace |Ã—100% (10)
where|RootSpace |and|BugSpace |represent the number of
ï¬les involved in them. BugChurn (RootSpace )represents the
sum of the lines of code in bug ï¬xes for each ï¬le involved in
RootSpace .
We use an example to illustrate BFR and BCR . For a
BugSpace with three ï¬les: {A,B,C}, its involved bug frequen-
cies and churn are listed as follows: (3,100), (2,200) and
(1,300). For a generated RootSpace :{A,B}, to calculate BFR ,
the results of BugFre (RootSpace )and BugFre (BugSpace )are
counted as 5 and 6 respectively. According to formula (9),
the result of BFR should be (5/6)*(3/2) = 125%, meaning that
the average bug frequency of the ï¬les within the RootSpace is
higher than the average ï¬le within the bug space. The result
ofBCR should be (300/600)*(3/2) = 75%, meaning that the
average bug churn of ï¬les within the RootSpace is lower than
the average ï¬le within the bug space.
In summary, BFR and BCR are used to measure the average
maintenance cost of the RootSpaces calculated from these
combinations, using the average scores of the BugSpace as
a baseline.
2)Results :Table III presents the results. The columns Type
and F ormula present the details of each combination. For each
combination, the other columns present the average scores of
the 117 subjects to cover BugFre 10% ileand BugFre 100% ile
(i.e. the overall BugSpace ) respectively.
3)Observations :The intersection of syntactic, history,
and semantic relations merely covers 0.82% of all the bug-
prone ï¬les ( BugSpace ) but shows nearly 80% precision and
over 500% bug frequency/churn rate. Table III shows that
the intersection of these three structures only occupy 0.28%
of all the ï¬les on average. It can also capture the 2.63% of
the most bug-prone ï¬les BugFre 10% ilewith a relative high
precision (nearly 50%).
The union of syntactic structure, history structure and
semantic structure covers the 99.3% of all the bug-prone
ï¬les( BugSpace ) with 43.4% precision and almost 80% bug
591
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:16 UTC from IEEE Xplore.  Restrictions apply. TABLE III: The Interaction of Dependency Structures
Type Formula File%BugFre 10%ile BugSpace
Precision Recall BFR BCR Precision Recall BFR BCR
Syn (V,E1) 96.38% 10.42% 99.78% 262.50% 210.84% 41.90% 98.50% 70.97% 71.14%
His (V,E2) 8.41% 43.72% 32.32% 2111.37% 1314.45% 73.90% 17.70% 918.09% 560.08%
Sem (V,E3) 35.11% 36.36% 44.45% 1294.51% 862.57% 56.90% 40.50% 284.20% 188.26%
Synâˆ©His (V,E1âˆ©E2) 3.77% 49.12% 15.94% 2802.91% 1332.68% 76.06% 8.13% 1236.42% 602.38%
Synâˆ©Sem (V,E1âˆ©E3) 16.25% 46.52% 31.38% 1732.65% 1057.02% 68.45% 22.05% 551.94% 337.46%
Hisâˆ©Sem (V,E2âˆ©E3) 0.71% 50.97% 4.13% 2846.15% 1566.86% 79.62% 1.88% 1197.66% 562.91%
Synâˆ©Hisâˆ©Sem (V,E1âˆ©E2âˆ©E3) 0.28% 49.94% 2.63% 3043.47% 1536.33% 79.46% 0.82% 1210.64% 524.09%
SynâˆªHis (V,E1âˆªE2) 96.52% 10.54% 99.84% 267.19% 214.68% 42.11% 98.76% 72.55% 72.06%
SynâˆªSem (V,E1âˆªE3) 96.71% 10.52% 99.79% 263.60% 205.87% 41.94% 98.76% 74.25% 73.53%
HisâˆªSem (V,E2âˆªE3) 40.52% 34.85% 62.72% 1161.97% 831.25% 59.46% 52.96% 298.47% 243.59%
SynâˆªHisâˆªSem (V,E1âˆªE2âˆªE3) 97.50% 14.28% 100.0% 424.21% 339.84% 43.45% 99.37% 84.81% 83.29%
&Z Z Ï­Ï® Ï¯ Ï° Ï± Ï² Ï³ Ï´ Ïµ Ï­ Ï¬
Ï­KÆµÆšÆ‰ÆµÆš^ÆšÆŒÄÄ‚ÅµDÄ‚Å¶Ä‚ÅÄÆŒ Ï²Ğ¹ Ï­Ï¬Ğ¹ Í¾Ï­Í¿ Í•Î·Ï´ Í¾ÅšÄÍ•Ï±Ï®Ğ¹Í¿Í•Î·Ï­Ï® Í•Î·Ï­Ï± Í•Î·Ï± Í•Î·Ï­Ï­ Í•Î·Ï± Í•Î·Ï´ Í•Î·Ï°
Ï®DÄÅµÅ½ÆŒÇ‡DÄ‚Æ‰Æ‰ÄÄš&ÅÅ¯ÄDÄ‚Å¶Ä‚ÅÄÆŒ Ï­Ï±Ğ¹ Ï±Ï®Ğ¹ ÄšÆ‰Í•Î·Ï´Í¾Ï®Í¿ Í¾ÆÄÍ•Ï³Ï´Ğ¹Í¿Í•Í¾ÅšÄÍ•Ï¯Ï¬Ğ¹Í¿Í•Î·Ï³ Í•Î·Ïµ Í•Î·Ï­Ï³ Í•Î·Ï°
Ï¯&ÅÅ¯ÄDÄ‚Å¶Ä‚ÅÄÆŒ Ï°Ğ¹ ÏµĞ¹ ÄšÆ‰Í•Î·Ï­Ï® Í•Î·Ï³ Í¾Ï¯Í¿ Í•Î·Ï­Ï² Í•Î·Ï² Í•Î·Ï­Ï° Í•Î·Ï³ Í•Î·Ï²
Ï°ZÅ½Å¯Å¯ÅÅ¶Å&ÅÅ¯ÄDÄ‚Å¶Ä‚ÅÄÆŒ Ï®Ğ¹ Ï³Ğ¹ ÄšÆ‰Í•Î·Ï­Ï± Í•Î·Ïµ ÄšÆ‰Í•Í¾ÆÄÍ•Ï³Ï®Ğ¹Í¿Í•Í¾ÅšÄÍ•Ï³Ï¬Ğ¹Í¿Í•Î·Ï­Ï² Í¾Ï°Í¿ Í¾ÅšÄÍ•Ï¯Ï¬Ğ¹Í¿Í•Î·Ï­Ï´ Í¾ÆÄÍ•Ï³Ï±Ğ¹Í¿Í•Î·Ï­Ï­ Í¾ÆÄÍ• Ï³Ï²Ğ¹Í¿Í•Î·Ï­Ï¬ Í•Î·Ï³
Ï±&ÅÅ¯ÄÆ‰Æ‰ÄÅ¶ÄšÄÆŒ Ï¯Ï®Ğ¹ Ï­Ï¯Ğ¹ Í•Î·Ï± ÄšÆ‰Í•Ï² Í¾Ï±Í¿ Í•Î·Ï­Ï´
Ï²ZÅ½Å¯Å¯ÅÅ¶ÅZÄ‚Å¶ÄšÅ½ÅµÄÄÄÆÆ&ÅÅ¯ÄDÄ‚Å¶Ä‚Å ÄÏ´Ğ¹ Ï®Ï²Ğ¹ ÄšÆ‰Í•Î·Ï­Ï­ Í•Î·Ï­Ï³ ÄšÆ‰Í•Í¾ÅšÄÍ•Ï³Ï¬Ğ¹Í¿Í•Î·Ï­Ï° ÄšÆ‰Í•Î·Ï­Ï´ Í¾Ï²Í¿ Í•Î·Ï² Í•Î·Ï²
Ï³ÄÄ¨Ä‚ÆµÅ¯ÆšZÅ½Å¯Å¯Å½Ç€ÄÆŒ^ÆšÆŒÄ‚ÆšÄÅÇ‡ Ï­Ğ¹ Ï¯Ğ¹ Í•Î·Ï±Í¾ÆÄÍ•Ï´Ï®Ğ¹Í¿Í•Î·Ï° ÄšÆ‰Í•Í¾ÆÄÍ•Ï´Ï´Ğ¹Í¿Í•Í¾ÅšÄÍ•Ï¯Ï¬Ğ¹Í¿Í•Î·Ï³ ÄšÆ‰Í•Î·Ï­Ï­ Í•Î·Ï² Í¾Ï³Í¿ Í•Î·Ï´Í•Î·Ï² Í•Î·Ï³
Ï´ÅÆŒÄÄÆštÆŒÅÆšÄZÅ½Å¯Å¯Å½Ç€ÄÆŒ^ÆšÆŒÄ‚ÆšÄÅÇ‡ Ï²Ï®Ğ¹ Ï°ÏµĞ¹ Í¾ÆÄÍ•Ï´Ï¯Ğ¹Í¿ ÄšÆ‰Í•Í¾ ÆÄÍ•Ï´ÏµĞ¹Í¿ ÄšÆ‰ Í¾ÆÄÍ•ÏµÏ±Ğ¹Í¿Í•Î·Ï´ Í¾Ï´Í¿
ÏµZÅ½Å¯Å¯ÅÅ¶Å&ÅÅ¯ÄÆ‰Æ‰ÄÅ¶ÄšÄÆŒ Ï±Ï¬Ğ¹ Ï±Ğ¹ Í•Î·Ï´ Í•Î·Ï² ÄšÆ‰Í•Î·Ï­Ï¬ Í•Î·Ï­Ï´ Í•Î·Ï² ÄšÆ‰Í•Î·Ï² ÄšÆ‰ Í¾ÏµÍ¿
Ï­Ï¬ZÅ½Å¯Å¯ÅÅ¶ÅÆ‰Æ‰ÄÅ¶ÄšÄÆŒ^ÅÇŒÄdÄÆÆš Ï°Ğ¹ Ï³Ğ¹ Í•Î·Ï° ÄšÆ‰ ÄšÆ‰Í•Î·Ï³ Í•Î·Ï³ ÄšÆ‰Í¾Ï­Ï¬Í¿
Fig. 12: The Combination of Syntactic, History, and Semantic sub-DRSpaces
frequency/churn rate. Table III shows that the union of these
three structures occupy 97.5% of all the ï¬les on average, and
can capture all the most bug-prone ï¬les ( BugFre 10%ile)
with a relative low precision (14.28%).
For intersections of two dependency structures, the
intersection of syntactic structure and semantic structure
(Synâˆ©Sem ) shows a higher recall rate (22.05%) to cover
all the bug-prone ï¬les ( BugSpace ); the intersection of
history structure and semantic structure ( Hisâˆ©Sem ) shows
a higher precision rate (79.62%) to cover all the bug-prone
ï¬les ( BugSpace ).The intersection of syntactic structure and
semantic structure ( Synâˆ©Sem) captures 16.25% of all the ï¬les.
It also covers the most bug-prone ï¬les ( BugFre 10% ile) with
46.52% precision rate and 31.38% recall rate. The intersection
of history structure and semantic structure ( Hisâˆ©Sem) only
captures 0.71% of all the ï¬les, which covers the most bug-
prone ï¬les ( BugFre 10% ile) with a higher precision rate
(50.97%) and a lower recall rate (4.13%). The intersections
involving history relation can improve the precision by 23%-
38%. The intersections involving semantic structure can also
improve the precision by 12%-38%.
For unions of two dependency relations, the union of
syntactic structure and history structure ( SynâˆªHis) covers
98.76% of all the bug-prone ï¬les ( BugSpace ); the union
of history structure and semantic structure ( HisâˆªSem )
shows a higher precision rate (59.46%). The union of
syntactic structure and history structure ( SynâˆªHis) captures
96.52% of all the ï¬les, which also covers the most bug-
prone ï¬les ( BugFre 10% ile) with 10.54% precision rate and
99.84% recall rate. The union of history structure and semantic
structure ( HisâˆªSem) captures 40.52% of all the ï¬les, which
covers the most bug-prone ï¬les ( BugFre 10% ile) with a higher
precision rate (34.85%) and a lower recall rate (62.72%). The
unions involving syntactic structure can improve the recall by58%-81%.
V. R ESULT DISCUSSION
In this section, we discuss the results and answer the three
research questions.
RQ1: The result of RQ1 reveals that the syntactic relation,
history relation, and semantic relation present signiï¬cantly
different structures. Intuitively, this implies that these three
relations will perform drastically different when they are used
to predict or locate software defects. The result of RQ1 also
reveals that these three dependency relations present different
architecture views from the state-of-the-art reverse engineering
techniques. This may provide a new perspective to recover
architecture using these three dependency structures directly.
RQ2: The result of RQ2 demonstrates that the syntactic
relation, history relation, and semantic relations are signiï¬-
cantly different in terms of their ability to capture error-prone
ï¬les. The syntactic structure shows the advantage of covering
most defective ï¬les, while the history structure and semantic
structure show the advantage of improving the coverage ac-
curacy. The indication is that when performing bug location,
prediction, and prioritization tasks, these relations should be
considered and compared separately.
RQ3: The result of RQ3 is unexpected. The intersection
of these relations only covers a rather small portion of defects
(0.82%) but with high precision scores. However, the union
of them can almost cover all the defects (99.37%). These
results demonstrate that these three dependency structures are
independent and complementary. The high recall rate implies
that these three dependency structures are enough for defect
prediction/localization. However, the precision of their union
is merely 43.45%. Thus, we can focus on how to improve
the precision using these three structures. The results of inter-
sections/unions for two structures provide us an intuitive way.
592
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:16 UTC from IEEE Xplore.  Restrictions apply. Compared with using one dependency structure, the combina-
tions involving syntactic structure could further improve the
coverage recall. The combinations involving history structure
and semantic structure can improve the coverage precision.
This inspires us to design proper strategies to combine these
three structures together to improve the accuracy of defect
prediction/localization.
VI. T HREAT TO VALIDITY
In this section, we discuss the threats to validity and
limitation of our study.
1)Internal threats :First, for each subject, we collect
commit data, generate history relation, and derive bug reports
from the beginning of its revision history to the latest release.
Prior research [34] suggested that if only recent history is
used, the result could be different. To validate our work, we
recalculate the data, extracting history relation and bug reports
from the most recent 3 releases of each subject. The results
showed that speciï¬c bug frequency and churn ranking orders
are different, but the general conclusions are exactly the same.
Second, we set the thresholds for determining history cou-
pling and semantic coupling according to previous studies. It
is unclear whether these threshold settings are generalizable.
To eliminate this threat, we conducted a large scale study
using 117 open source projects, and manually inspected the
generated relations for 5 projects. We conï¬rmed that the
extracted software relations are reasonable.
Third, for syntactic structure, history structure and semantic
structure, we employed DRSpaces to understand the archi-
tectural design. In the future, we will use various reverse-
engineering techniques and make a systematical comparison
of their inï¬‚uence on software quality.
Fourth, for each dependency structure, we employ the
ArchRoot algorithm to calculate its interactions with buggy
ï¬les. ArchRoot is a greedy algorithm whose effectiveness and
efï¬ciency can be further improved. In the future, we will
also design pruning strategies to make more detailed and
comparative analyses.
Finally, our research aims at investigating the correlation
between dependency relations and ï¬le error-proneness, but not
causality . We do not have evidence how dependency causes
the presence of defects. In our future work, we will explore
the causality relation by studying each bug report and its
introduced change.
2)External threats :The ï¬rst threat comes from locating
buggy ï¬les using bug reports. Following prior history-based
bug prediction work [4, 8], we link these bug reports with
its ï¬xing commits by heuristically searching BugIDs from
revision messages. However, researchers have [35] pointed out
that, developers may commit bug ï¬xes using wrong bugID or
even without reporting bugID. In these cases, our approach
may be biased. To eliminate this threat, we select the Apache
Open Projects and study bug reports from its issue tracking
system: JIRA. The bug report information in JIRA for Apache
projects is manually entered by experts, containing less noise.In our future work, we plan to study the impact of missing
links to bug reports.
The second threat comes from the chosen subjects. We
intensively studied 117 Apache open source projects. It is still
unclear whether our observations will generalize to closed-
source industrial projects and open-source projects from other
communities. Studying more subjects is our ongoing work.
The ï¬nal threat comes from the imbalance problem, which
is a common problem in machine learning and defect predic-
tion. However, our objective is to investigate the differences
of the three major dependency types, not to propose a new
defect prediction/localization algorithm.
VII. C ONCLUSION
In this paper, we presented our systematic study on the re-
lation between ï¬le error-proneness and syntactic dependency,
history dependency, and semantic dependency. We conducted
our study on 117 Apach open source projects involving
643,079 revision commits and 101,364 bug reports. Supported
by DRSpaces, for each dependency type, we created its overall
DRSpace, split it into a set of sub-DRSpaces, and calculated
their interactions with bug spaces. We investigated three re-
search questions using these data. The results demonstrated
the independence and complementary nature of these three
dependency types, and their drastically different impact on
ï¬le error-proneness. We also presented a suite of qualitative
and quantitative results, which provide new insights that may
beneï¬t defect prediction, localization, and prioritization.
ACKNOWLEDGEMENT
This work was supported by National Key R&D Program
of China (2016YFB1000903), National Natural Science Foun-
dation of China (61632015, 61772408, U1766215, 61532015,
61833015, 61702414), Ministry of Education Innovation Re-
search Team (IRT 17R86), Innovative Research Group of the
National Natural Science Foundation of China (61721002),
Project of China Knowledge Centre for Engineering Science
and Technology. This work was also supported by the United
States National Sciences Foundation grants 1514561, 1514315
and 1816594. T. Liu is the corresponding author.
REFERENCES
[1] R. W. Selby and V . R. Basili, â€œAnalyzing error-prone
system structure,â€ IEEE Transactions on Software Engi-
neering , vol. 17, no. 2, pp. 141â€“152, 1991.
[2] N. Nagappan, T. Ball, and A. Zeller, â€œMining metrics
to predict component failures,â€ in Proceedings of the
28th international conference on Software engineering .
ACM, 2006, pp. 452â€“461.
[3] T. Zimmermann and N. Nagappan, â€œPredicting de-
fects using network analysis on dependency graphs,â€ in
ACM/IEEE International Conference on Software Engi-
neering , 2008, pp. 531â€“540.
[4] M. Cataldo, A. Mockus, J. A. Roberts, and J. D. Herb-
sleb, â€œSoftware dependencies, work dependencies, and
593
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:16 UTC from IEEE Xplore.  Restrictions apply. their impact on failures,â€ IEEE Transactions on Software
Engineering , vol. 35, no. 6, pp. 864â€“878, 2009.
[5] T. L. Graves, A. F. Karr, J. S. Marron, and H. Siy, â€œPre-
dicting fault incidence using software change history,â€
IEEE Transactions on software engineering , vol. 26,
no. 7, pp. 653â€“661, 2000.
[6] S. Wang, T. Liu, and L. Tan, â€œAutomatically learning
semantic features for defect prediction,â€ in Ieee/acm
International Conference on Software Engineering , 2016,
pp. 297â€“308.
[7] Y . Qu, X. Guan, Q. Zheng, T. Liu, L. Wang, Y . Hou,
and Z. Yang, â€œExploring community structure of software
call graph and its applications in class cohesion measure-
ment,â€ Journal of Systems and Software , vol. 108, pp.
193â€“210, 2015.
[8] L. Xiao, Y . Cai, and R. Kazman, â€œDesign rule spaces: A
new form of architecture insight,â€ in Proceedings of the
36th International Conference on Software Engineering .
ACM, 2014, pp. 967â€“977.
[9] Y . Cai, H. Wang, S. Wong, and L. Wang, â€œLeveraging
design rules to improve software architecture recovery,â€
inProceedings of the 9th international ACM Sigsoft
conference on Quality of software architectures . ACM,
2013, pp. 133â€“142.
[10] Z. Li, X. Y . Jing, X. Zhu, and H. Zhang, â€œHeterogeneous
defect prediction through multiple kernel learning and
ensemble learning,â€ in IEEE International Conference on
Software Maintenance and Evolution , 2017, pp. 91â€“102.
[11] D. D. Nucci, F. Palomba, R. Oliveto, and A. D. Lucia,
â€œDynamic selection of classiï¬ers in bug prediction: An
adaptive method,â€ IEEE Transactions on Emerging Top-
ics in Computational Intelligence , vol. 1, no. 3, pp. 202â€“
212, 2017.
[12] V . Tzerpos and R. C. Holt, â€œAcdc: An algorithm for
comprehension-driven clustering.â€ in wcre , 2000, pp.
258â€“267.
[13] J. Garcia, D. Popescu, C. Mattmann, N. Medvidovic,
and Y . Cai, â€œEnhancing architectural recovery using
concerns,â€ in Proceedings of the 2011 26th IEEE/ACM
International Conference on Automated Software Engi-
neering . IEEE Computer Society, 2011, pp. 552â€“555.
[14] A. Corazza, S. Di Martino, V . Maggio, and G. Scanniello,
â€œInvestigating the use of lexical information for software
system clustering,â€ in Software Maintenance and Reengi-
neering (CSMR), 2011 15th European Conference on .
IEEE, 2011, pp. 35â€“44.
[15] B. S. Mitchell, â€œA heuristic approach to solving the
software clustering problem,â€ in Software Maintenance,
2003. ICSM 2003. Proceedings. International Confer-
ence on . IEEE, 2003, pp. 285â€“288.
[16] F. Beck and S. Diehl, â€œEvaluating the impact of software
evolution on software clustering,â€ in Reverse Engineer-
ing, 2010, pp. 99â€“108.
[17] B. S. Mitchell and S. Mancoridis, â€œOn the auto-
matic modularization of software systems using the
bunch tool,â€ IEEE Transactions on Software Engineering ,vol. 32, no. 3, pp. 193â€“208, 2006.
[18] J. Garcia, I. Ivkovic, and N. Medvidovic, â€œA compar-
ative analysis of software architecture recovery tech-
niques,â€ in Automated Software Engineering (ASE), 2013
IEEE/ACM 28th International Conference on . IEEE,
2013, pp. 486â€“496.
[19] T. Lutellier, D. Chollak, J. Garcia, L. Tan, D. Rayside,
N. Medvidovic, and R. Kroeger, â€œComparing software
architecture recovery techniques using accurate depen-
dencies,â€ in 2015 IEEE/ACM 37th IEEE International
Conference on Software Engineering , vol. 2. IEEE,
2015, pp. 69â€“78.
[20] I. Macia, R. Arcoverde, E. Cirilo, A. Garcia, and A. V .
Staa, â€œSupporting the identiï¬cation of architecturally-
relevant code anomalies,â€ in IEEE International Confer-
ence on Software Maintenance , 2012, pp. 662â€“665.
[21] R. Mo, Y . Cai, R. Kazman, and L. Xiao, â€œHotspot
patterns: The formal deï¬nition and automatic detection of
architecture smells,â€ in Software Architecture (WICSA),
2015 12th Working IEEE/IFIP Conference on . IEEE,
2015, pp. 51â€“60.
[22] W. Oizumi, A. Garcia, L. da Silva Sousa, B. Cafeo, and
Y . Zhao, â€œCode anomalies ï¬‚ock together: exploring code
anomaly agglomerations for locating design problems,â€
inProceedings of the 38th International Conference on
Software Engineering . ACM, 2016, pp. 440â€“451.
[23] F. A. Fontana, I. Pigazzini, R. Roveda, and M. Zanoni,
â€œAutomatic detection of instability architectural smells,â€
inIEEE International Conference on Software Mainte-
nance and Evolution , 2017, pp. 433â€“437.
[24] F. A. Fontana, I. Pigazzini, R. Roveda, D. Tamburri,
M. Zanoni, and E. D. Nitto, â€œArcan: A tool for architec-
tural smells detection,â€ in IEEE International Conference
on Software Architecture Workshops , 2017, pp. 282â€“285.
[25] L. Xiao, Y . Cai, R. Kazman, R. Mo, and Q. Feng, â€œIdenti-
fying and quantifying architectural debt,â€ in Proceedings
of the 38th International Conference on Software Engi-
neering . ACM, 2016, pp. 488â€“498.
[26] M. Gethers and D. Poshyvanyk, â€œUsing relational topic
models to capture coupling among classes in object-
oriented software systems,â€ in IEEE International Con-
ference on Software Maintenance , 2010, pp. 1â€“10.
[27] J. Chang and D. M. Blei, â€œHierarchical relational models
for document networks,â€ Annals of Applied Statistics ,
vol. 4, no. 1, pp. 124â€“150, 2010.
[28] G. Bavota, R. Oliveto, M. Gethers, D. Poshyvanyk,
and A. D. Lucia, â€œMethodbook: Recommending move
method refactorings via relational topic models,â€ IEEE
Transactions on Software Engineering , vol. 40, no. 7,
pp. 671â€“694, 2014.
[29] L. Bass, P. Clements, and R. Kazman, Software Archi-
tecture in Practice , 3rd ed., 2012.
[30] R. Kazman, Y . Cai, R. Mo, Q. Feng, L. Xiao, S. Haziyev,
V . Fedak, and A. Shapochka, â€œA case study in locating
the architectural roots of technical debt,â€ in Proceed-
ings of the 37th International Conference on Software
594
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:16 UTC from IEEE Xplore.  Restrictions apply. Engineering-V olume 2 . IEEE Press, 2015, pp. 179â€“188.
[31] L. Xiao, Y . Cai, and R. Kazman, â€œTitan: A toolset that
connects software architecture with quality analysis,â€ in
Proceedings of the 22nd ACM SIGSOFT International
Symposium on F oundations of Software Engineering .
ACM, 2014, pp. 763â€“766.
[32] Z. Wen and V . Tzerpos, â€œAn effectiveness measure for
software clustering algorithms,â€ in IEEE International
Workshop on Program Comprehension , 2004, p. 194.
[33] D. M. Le, P. Behnamghader, J. Garcia, and D. Link, â€œAn
empirical study of architectural change in open-source
software systems,â€ in MSR , 2015, pp. 235â€“245.
[34] S. Wong and Y . Cai, â€œGeneralizing evolutionary coupling
with stochastic dependencies,â€ in Ieee/acm International
Conference on Automated Software Engineering , 2011,
pp. 293â€“302.
[35] A. Bachmann, C. Bird, F. Rahman, P. Devanbu, and
A. Bernstein, â€œThe missing links:bugs and bug-ï¬x com-
mits,â€ in ACM Sigsoft International Symposium on F oun-
dations of Software Engineering, 2010, Santa Fe, Nm,
Usa, November , 2010, pp. 97â€“106.
595
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:37:16 UTC from IEEE Xplore.  Restrictions apply. 