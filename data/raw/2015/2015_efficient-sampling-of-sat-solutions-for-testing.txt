Efficient Sampling of SAT Solutions for Testing
Rafael Dutra, Kevin Laeufer, Jonathan Bachrach and Koushik Sen
EECS Department
University of California, Berkeley, USA
{rtd,laeufer,jrb,ksen}@cs.berkeley.edu
ABSTRACT
Insoftwareandhardwaretesting,generatingmultipleinputswhich
satisfy a given set of constraints is an important problem with
applications in fuzz testing and stimulus generation. However, it is
a challenge to perform the sampling efficiently, while generating a
diversesetofinputswhichsatisfytheconstraints.Wedeveloped
a new algorithm QuickSampler which requires a small number
of solver calls to produce millions of samples which satisfy the
constraintswithhighprobability.Weevaluate QuickSampler on
large real-world benchmarks and show that it can produce unique
validsolutionsordersofmagnitudefasterthanotherstate-of-the-
art sampling tools, with a distribution which is reasonably close to
uniform in practice.
CCS CONCEPTS
â€¢Software and its engineering â†’Software testing and de-
bugging;Formal software verification ;â€¢Hardware â†’Theorem
proving and SAT solving;
KEYWORDS
sampling,stimulusgeneration,constraint-basedtesting,constrained-
random verification
ACM Reference Format:
Rafael Dutra, Kevin Laeufer, Jonathan Bachrach and Koushik Sen. 2018.
Efficient Sampling of SAT Solutions for Testing. In Proceedings of ICSE â€™18:
40th International Conference on Software Engineering , Gothenburg, Sweden,
May 27-June 3, 2018 (ICSE â€™18), 11 pages.
https://doi.org/10.1145/3180155.3180248
1 INTRODUCTION
Givenasetofconstraints,theproblemofgeneratingasetofrandom
solutionstotheconstraintsisimportantbothinsoftwareandhard-
waretestingandverification. Forinstance,conventionalsymbolic
execution [ 13,25] and dynamic symbolic execution techniques [ 1â€“
4,7,8,12,18,19,24,28,35â€“40,42] generate a path constraint for
eachprefixoffeasibleexecutionpathsinaprogramanduseaSMT-
solver to generate a solution for each such constraint. However,
in practice, these techniques face scalability problems because the
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden
Â©2018 Copyright held by the owner/author(s). Publication rights licensed to Associa-
tion for Computing Machinery.
ACM ISBN 978-1-4503-5638-1/18/05...$15.00
https://doi.org/10.1145/3180155.3180248numberofpathsforanyreasonableprogramisastronomicallylarge.
Instead of generating a single solution for the path constraint of
a path prefix, one could generate multiple solutions to randomly
testmultiplepathshavingthesameprefix.Wecallthisapproachconstraint-basedfuzzing.Ifmultiplesolutionscouldbegenerated
efficiently,thiswouldsignificantlyspeedupsymbolicexecutionand
reap the benefits of random testing [6, 17, 21, 22, 34, 45, 46].
Similarideashavebeenproposedanddevelopedinhardwarever-
ification.Forexample, constrained-randomverification (CRV)[33]
has been proposed to generate high-quality inputs for hardwaredesigns. In CRV, verification engineers specify preconditions re-quired by the hardware and other constraints based on domain-
specific knowledge [ 32,47]. Multiple random inputs satisfying the
constraintsarethengeneratedusingaconstraintsolverthatcan
sample random solutions from a constraint.
However,despiteitsimportance,theproblemofsamplingadi-
versesetofsolutionsefficientlyisstillchallengingtoday[ 9].There
are approaches which give strong guarantees of uniformity [ 11],
but are expensive to run when a large number of samples is re-quired. Other approaches use heuristics for faster sampling [
43],
butthatcanmakethesamplesbiasedtowardsoneportionofthe
sampling space.
In this work, we specifically focus on the goal of generating
randomsamplestobeusedasinputsfortesting.Weassumethat
theconstraintsaregivenasBooleansatisfiability(SAT)problems,
since constraints from higher level domains, such as bit-vectors or
othersatisfiabilitymodulotheories(SMT)problemscanbemappedintoSAT.Ourgoalistoefficientlygeneratelotsofrandomsatisfying
assignments to SAT formulas, also known as SAT witnesses.
Inthetestingdomain,itisoftenacceptabletogenerateinvalid
solutionssomeofthetime.Forexample,inconstraint-basedfuzzing,
wemayuseconstraintstodirecttheexecutiontowardsacertain
portion of the program, but it is still fine if some samples donâ€™t
satisfytheconstraintsandendupexecutingotherprogramparts.
Itisalsoimportantto noticethat,inthetestingdomain,themost
importantmetricisthenumberofuniquevalidsolutionsgenerated
overtime.Thatisbecauseeachuniquevalidinputcanhelpcover
newportionsoftheprogramandfindpreviouslyunseenbugs,while
repeated samples do not increase coverage.
Withthatinmind,wehavedesigned QuickSampler ,anewtech-
niqueforefficientsampling. QuickSampler usesasmallnumber
of constraint solver calls to generate a large number of samples.
QuickSampler works as follows. First, it finds a random assign-
ment tothe variables ofthe Boolean formula(i.e. the constraint).Such an assignment may not satisfy the formula.
QuickSampler
then uses a MAX-SAT solver to find a solution of the formula that
is close to the random satisfying assignment. It then flips the value
of each variable in the solutionand again uses MAX-SAT to find
another close solution of the formula. The difference between the
5492018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:53:54 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden Dutra et al.
original solution and the modified solution is called an atomic mu-
tation. For each variable in the formula, this generates at most one
atomicmutation.Asmallboundednumberofsuchatomicmuta-
tions are then combined and applied to the original solution to
generate a potentially new solution. We found that such combina-
tions of small atomic mutations often results in new valid random
solutions.Thisisbecauseeachatomicmutationidentifiesasmall
setofvariablesthataretightlycoupledwitheachother.Whereas
thevariablesfromtwodifferentatomicmutationsareofteninde-
pendent.Therefore,iftwosuchatomicmutationsarecombinedand
applied to the original solution, then the resulting solution will of-
tensatisfytheformula.Theentireprocessisrepeatedseveraltimes.Since
QuickSampler createslotsofsolutionsbysimplycombining
atomicmutations,itavoidsmaking frequentsolvercalls(whichis
often the bottleneck). This in turn results in quick generation of
lots of random solutions.
We have implemented QuickSampler as an open-source tool
availableathttps://github.com/RafaelTupynamba/quicksampler/.
We use Z3 [ 14] to solve MAX-SAT queries. The samples gener-
ated byQuickSampler are not guaranteed to satisfy a given for-
mula,butourexperimentsshowthattheyarevalidsolutionsinourbenchmarkswithhighprobability(i.e.
â‰¥0.75).QuickSampler also
produces unique valid solutions orders of magnitude (i.e. â‰¥1000Ã—)
faster thanother state-of-the-artsamplers, whilegenerating adis-
tributionofsampleswhichisstillclosetouniform.Forapplications
which require only valid solutions, it is also possible to use our
technique,bysimplycheckingthesamplesforvalidityandfiltering
out the invalid ones. Our evaluation shows that QuickSampler
is still faster than the other samplers, even when including this
additional checking.
2 RELATED WORK
Thereareseveraldifferenttechniquesusedtotackletheproblem
of sampling solutions to Boolean constraints [ 29]. The problem of
sampling SAT witnesses is also closely related to the problem of
countingthenumberofsolutions,whichhas# P-completecomplex-
ity. Several sampling techniques can be applied to model counting
or use some form of model counting internally [16, 30, 44].
OneclassofsamplingmethodsisbasedonMarkovChainMonte
Carlo(MCMC)algorithms[ 26,27].Theseincludesimulatedanneal-
ingandMetropolis-Hastingswhichareusedtogeneratesamples
from a probability space. Those MCMC methods are guaranteedto eventually converge to the desired distribution (such as uni-
form sampling). However, this convergence is slow in practice for
real-world problems, so the algorithms typically employ heuris-tics which make the sampling more biased [
27,43]. For example,
[43]combinesMetropolisstepswithrandomwalkstepsthrough
the assignments to the variables of the formula. In comparison,
QuickSampler doesnotneedtowaitforaconvergencetimeand
covers the search space by finding solutions closest to randomly
selected points.
One similar line of work attempts to modify the SAT solver
searchheuristicsinordertogenerateamorediversesetofsolutions
[31]. However, unlike QuickSampler , thisdiversesampling has
different goals and does not attempt to cover the whole searchspace nearly uniformly.
QuickSampler also does not modify theÏƒ: 010001011011
Î´a:100011000000
Ïƒa=ÏƒâŠ•Î´a:110010011011
Î´b:01000110 1000
Ïƒb=ÏƒâŠ•Î´b:00000011 0011
(Î´aâˆ¨Î´b):11001110 1000
ËœÏƒ=ÏƒâŠ•(Î´aâˆ¨Î´b):10001011 0011
Figure 1: Combining two mutations.
inner search strategies of SAT solvers, but instead uses the SAT
solvers as an oracle to answer MAX-SAT queries.
The closest technique to QuickSampler in literature appears
to beSearchTreeSampler [16], which also uses a SAT solver as
anoracle.However, SearchTreeSampler performssimplesatisfi-
ability queries instead of the MAX-SAT queries by QuickSampler .
SearchTreeSampler works by exploring the tree of variable as-
signmentsinabreadth-firstway,generating pseudosolutions,which
are partial assignments to the variables that can be completed to a
full solution. SearchTreeSampler uses a parameter kwhich spec-
ifies the number of samples computed per level in the tree and
canbeusedtotrade-offuniformityandnumberofsolvercallsre-
quired.Ontheotherhand, QuickSampler usesadifferentstrategy
tocoverthesearchspace,andalsogeneratesavastlylargernumber
of samples per solver call, by combining learned mutations.
A different class of algorithms is based on universal hashing
[15,30] and can provide strong guarantees of uniformity. These
techniquesworkbyaddingadditionalconstraintstotheformula
(known as hash functions) in order to partition the search space
uniformly.Thosehashfunctionsaretypicallyformedbycomput-
ing the XOR of a random subset of variables [ 20].UniGen[11]
andUniGen2 [9] are examples of this class, with the latter also
employing parallelism to improve performance. In comparison,
QuickSampler does not attempt to be perfectly uniform, but only
closetouniforminpractice. QuickSampler primarilyaimsforeffi-
ciency,usingsolvercallswhicharemuchlessexpensivetosolve
than the XOR constraints of hash functions, and generating a large
number of samples per solver call.
3 QUICKSAMPLER ALGORITHM
GivenaBooleanformula Ï•,thegoalof QuickSampler istogenerate
unique solutions of Ï•efficiently. Another goal of QuickSampler
istomakesurethatsolutionsof Ï•aresampledalmostuniformly
at random. The key idea behind QuickSampler is to make a small
number of solver calls to generate a large number of potentially
uniquesolutionsof Ï•.Thecorealgorithmbehind QuickSampler
works as follows. QuickSampler assumes that we are given an
initial random solution Ïƒ(i.e. a satisfying assignment to Ï•), where
Ïƒisavectorof1sand0s.Eachlocationinthevectorcorrespondsto
a Boolean variable in Ï•and the value at that location in the vector
denotes the value assigned to this variable in the solution Ïƒ. LetV
be the set of all Boolean variables in Ï•. For example, in Figure 1 we
550
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:53:54 UTC from IEEE Xplore.  Restrictions apply. Efficient Sampling of SAT Solutions for Testing ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden
show a possible vector Ïƒ, in a case where the number of variables
is|V|=12.
Foreachvariable vâˆˆV,QuickSampler findsasolution Ïƒvsuch
thatÏƒvandÏƒare minimally different and Ïƒv(v)/nequalÏƒ(v), where
Ïƒ(v)is the value of the variable vin the solution Ïƒ. Note that such
asolutionmaynotexistforallvariablesin V.Thediffbetween Ïƒ
andÏƒv, which we will denote using Î´vand which is the XOR of
ÏƒandÏƒv, is called an atomic mutation ofÏƒ. That isÎ´v=ÏƒvâŠ•Ïƒ.
In the example from Figure 1, if the first variable of the formula is
a,wemightfindanewsolution Ïƒawhichhasthefirstbitflipped
(correspondingtovariable a)andadditionallyothertwobitsflipped.
Thecorrespondingatomicmutation Î´aisalsoshowninFigure1.
Similarly,ifthesecondvariableoftheformulais b,wemightfind
anewsolution ÏƒbasshowninFigure1,whichhasthesecondbit
(correspondingtovariable b)flipped,butalsoother3bitsflipped.
The corresponding atomic mutation Î´bis again shown in Figure 1.
Bydefinition,theatomicmutation Î´valwaysensuresthatatleast
Î´v(v)is one, i.e. ÏƒandÏƒvat least differ in the value of the variable
vanddifferenceinthevaluesoftheremainingvariablesisminimal.
WewilllaterexplainhowaMAX-SATquerytoaSATsolvercan
be used to find ÏƒvgivenÏ•,Ïƒ, andv. GivenÏƒ,QuickSampler first
computes the set of all atomic mutations by going over all the
variables vâˆˆV. Let us denote the set of all such atomic mutations
byÎ”1Ïƒ. Note that given ÏƒandÎ´v, we can compute ÏƒvasÎ´vâŠ•Ïƒ.
After computing Î”1Ïƒ,QuickSampler computes setsof compos-
itemutations Î”kÏƒfork>1,where Î”kÏƒcontainstheunionofall k
distinctmutationsin Î”1Ïƒ.Forexample,if Î´aandÎ´baretwomuta-
tionsin Î”1Ïƒsuchthat a/nequalb,thenÎ´aâˆ¨Î´bisamutationpresentin
Î”2Ïƒ.(Sinceeachof Î´aandÎ´barebit-vectors, Î´aâˆ¨Î´biscomputed
by taking bitwise OR of the two bit-vectors.) For example, after
computing the atomic mutations Î´a,Î´bâˆˆÎ”1Ïƒfrom Figure 1, the
combined mutation Î´aâˆ¨Î´bis added to Î”2Ïƒ. If we apply the com-
bined mutation to Ïƒ, by computing ÏƒâŠ•(Î´aâˆ¨Î´b)we obtain a new
assignment ËœÏƒ,asinFigure1.Notethat ËœÏƒdiffersfrom Ïƒonallthe
bits set in either of the two atomic mutations Î´aandÎ´b.
This new assignment ËœÏƒis not guaranteed to be a valid solution,
butwehavefoundthatithasahighprobabilityofbeingvalidin
realbenchmarks1.Thisisbecausethedifferences Î´aandÎ´bconsist
of a minimal set of bits which can be flipped while still preserving
the satisfiability of the formula. So the bits in Î´aare likely to be
closelyrelatedtoeachotherbysomeclausesintheformula.Itis
likely that those clauses would still be satisfied in ÏƒâŠ•(Î´aâˆ¨Î´b),
where we flip all the bits from Î´ain addition to the bits from Î´b.
Ingeneral,eachmutation Î´presentina Î”kÏƒdenotesacomposite
mutationandcanbeXORedwith Ïƒtogetanassignment ËœÏƒtothe
variablesin Ï•.Suchanassignmentmayormaynotbeasolutionof
Ï•. Surprisingly, in our experiments we found that for small values
ofk(i.e.kâ‰¤6), more than 73% of such assignments obtained by
XORing are solutions of Ï•. Let us denote the assignments obtained
by applying all the mutations present in Î”kÏƒtoÏƒbyÎ£kÏƒ, i.e.
Î£k
Ïƒ=/braceleftBig
Î´âŠ•Ïƒ|Î´âˆˆÎ”k
Ïƒ/bracerightBig
1Ourheuristictogeneratesamplesexploitstheclausestructurefoundinreal-world
benchmarks. We expectit to perform poorly if appliedto a randomly-generated SAT
formula.We let Î£Ïƒ=âˆª1â‰¤kâ‰¤6Î£kÏƒ. We found experimentally that over all
benchmarks, 75% of the assignments in Î£Ïƒare solutions of Ï•.
We now make a few interesting and important observations
about the set of assignments Î£Ïƒ.QuickSampler needs to make
solvercallsonlytocompute Î”1Ïƒ.Moreover,itisnotalwaysneces-
sary to make a solver call while computing the elements of Î”1Ïƒâ€”if
QuickSampler flips the bit corresponding to the variable vinÏƒ
anddiscoversthattheresultingbit-vectorisasatisfyingassignment
toÏ•, thenQuickSampler can skip the solver call for Î´v. For the
computation of all other Î£kÏƒ,QuickSampler needs no solver calls
because each element in Î£kÏƒis obtained by applying at most kbit-
wiseBooleanoperations.Anassignmentin Î£kÏƒmayormaynotbea
validsolution,howevercheckingitsvalidityisfastandtakeslinear
timeinthesizeof Ï•.Insummary, QuickSampler canpotentially
makesolvercallsforthecomputationof Î£1Ïƒ,butitmakesnosolver
callstocomputetheremainingsets Î£kÏƒ.Anotherobservationisthat
size of Î£kÏƒcould grow exponentially with k. This observation com-
binedwiththefactsthatasignificantnumberofassignmentsin Î£Ïƒ
have been empirically found to be solutions of Ï•and that we make
atmost|V|solvercallssuggeststhatgiven Ïƒ,QuickSampler can
rapidly generate lots of unique solutions of Ï•by making very few
solvercalls.Thisformsthecruxof QuickSampler â€™scorealgorithm
for sampling.
Given a random solution Ïƒ, we described how QuickSampler
generateslotsofsolutionsthataresmallmutationsof Ïƒ.W ene xt
describe how we generate a random solution Ïƒ.QuickSampler
first chooses a random assignment Ïƒ/primeby picking the values of
variablesin Vuniformlyatrandom.ThenitusesaMAX-SATquery
tofindaclosestsolution Ïƒtotherandomassignment Ïƒ/prime.Wepicked
this strategy to make sampling of solutions more uniform. Overall,
QuickSampler execution is divided into epochs. In each epoch,
QuickSampler generates a random solution Ïƒusing the method
described above. Then it computes Î£Ïƒand outputs the elements of
Î£Ïƒthataresolutionsof Ï•.QuickSampler repeatsthisprocessina
loopuntilithasrunoutoftimebudgetorithasfinishedgenerating
a user-specified number of solutions.
NowwedescribehowMAX-SATqueriescanbeusedtoobtain
the random solution Ïƒand also to obtain the solutions Ïƒvfor each
variablev. The maximum satisfiability problem, or MAX-SAT, is
defined as follows: given a set of hard constraints and a set of soft
constraints, find a solution which satisfies all the hard constraints
and additionally satisfies the maximum possible number of soft
constraints. In order to compute the random solution Ïƒ, we just
need to specify one hard constraint that the formula Ï•must be
satisfied and |V|soft constraints indicating that the values of each
variablevshouldpreferablybeequaltotheirrespectivevaluesin
the random assignment Ïƒ/prime, i.e.âˆ€uâˆˆV:Ïƒ(u)=Ïƒ/prime(u). In order
to compute each solution Ïƒv, we specify two hard constraints and
|V|âˆ’1softconstraints.Thehardconstraintsarethattheformula
Ï•must be satisfied and that the value of variable vmust be flipped,
i.e.Ïƒv(v)/nequalÏƒ(v).Thesoftconstraintsarethatthevaluesofother
variables should preferably remain the same, or âˆ€uâˆˆV\{v}:
Ïƒv(u)=Ïƒ(u).
This completes the general description of the QuickSampler
algorithm.However,wehavealsomadesomeadaptationstothis
initialalgorithminordertoimproveitsperformance.Wediscuss
551
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:53:54 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden Dutra et al.
Ïƒa
1Ïƒb
1
2Ïƒc
1
2
3
2
Figure 2: Combining Mutations
in Â§3.1 the eager generation of samples, in Â§3.2 the use of the
independent support of the formula, and in Â§3.3 the removal of
unsatisfiable variables.
3.1 Eager Generation of Samples
Aswehaveseen, QuickSampler onlyrequiressolvercallsinorder
toproducetheatomicmutationsin Î”1Ïƒ.Afterthat,thecomputation
ofthesamplesin Î£kÏƒcanbeperformedwithsimplebitwiseoper-
ations.However,thesolvercallscanbeexpensiveforthelargest
benchmarks.Soideallywewouldliketoleverageeachsolvercall
to generate samples as soon as the call is completed, so that we do
not need to wait for all solver calls before generating samples.
Wehaveadaptedthebasic QuickSampler algorithmtogenerate
samples as soon as each solver call is completed. Figure 2 presents
an example of this eager generation. Each circle represents one
mutationandinsideitweindicatethenumberofatomicmutations
used to generate it. When solution Ïƒais returned by the solver, we
learn one atomic mutation Î´a, represented by the first circle in the
figure. Then, as soon as solution Ïƒbbecomes available, we learn
theatomicmutation Î´bandalsocombineitwith Î´atogeneratea
mutation in Î”2Ïƒ. Then, as soon as solution Ïƒcbecomes available,
we learn the mutation Î´cand combine it with the three previously
known mutations in order to generate three new mutations.
In conjunction with this eager generation of mutations, we also
eliminateduplicatemutationsinthecurrentsamplingepoch.We
found it important to avoid duplicates within one epoch, other-
wise we would output too many repeated samples and perform
unnecessary work computing them.
Wemaintainacollection Î”ofcurrentlyknownmutationsgen-
erated in the current epoch. Whenever we learn a new mutation
from a solver call, we combine it with the mutations in Î”. The new
generated mutations are added to Î”only if they are previously
unseen mutations in this epoch. Also, we only combine the new
atomic mutations with mutations from Î”kÏƒfork<6. We do notwanttogeneratemutationscomposedofmorethan6atomicmuta-
tions, because they would have a lower chance of generating valid
solutions, according to our experiments.
3.2 Independent Support
Similarlyto UniGen2 [9],wecanrestrictoursamplertoonlyoper-
ate over the variablesin an independent support Sof the formula,
instead of generating assignments to all the variables in V. The
independent support is a subset of variables which completely de-
termines all the assignments to a formula. More specifically, given
anassignmentofvaluestothevariablesintheindependentsupport
S,thereisatmostonecompletionofthisassignmenttotheremain-
ing variables which satisfies the formula. So we can think of all
othervariablesbeingdependentonthevariablesintheindependent
support.Knowinganindependentsupportishelpfulinreducing
the number of variables for which we need to assign values.
In many cases, an independent support arises naturally from
the application. For example, when the Tseytin transformation
is used to transform a combinatorial logic circuit into a Boolean
formula in conjunctive normal form (CNF), auxiliary variables are
introduced for all intermediate wires in the circuit. All of thoseauxiliary variables can be uniquely determined given the inputs
to the circuit, so the inputs form an independent support. In cases
when an independent support is not known for a formula, there
are also methods to compute a minimal independent support for
it [23].
3.3 Unsatisfiable variables
IfoneMAX-SATqueryforvariable vreturnsnosolutions,welearn
thatvcan only have one truth value in this formula. When this
happensinthefirstepoch,werecordthevariable vinasetUofun-
satisfiablevariables.Then,wedonottrytoflipthevalueof vagain
inotherepochs.Wefoundthat,overallbenchmarks,onaverage6%
ofthevariablesfromtheindependentsupportwereaddedtothe
setU. This means that, after the first epoch, all subsequent epochs
canworkoverareducedsamplingsetandavoidunnecessarysolver
calls.
4 IMPLEMENTATION
We have implemented2the technique in C++, using Z3 [ 14]a s
the underlying solver. QuickSampler uses the Z3 optimization
subsystem Î½Z[5] in order to solve the MAX-SAT queries. We also
use thepush()andpop()interfaces to efficiently add and remove
constraints from a single solving context.
QuickSampler takes as input a SAT formula in conjunctive
normal form (CNF), represented in the DIMACS file format. The
formula includes a list of variables which compose its independent
support.
Our implementation outputs the samples generated to a file
withoutcheckingiftheyarevalidsolutions.Ifdesirable,itispossible
toaddaposteriorcheckwhichverifiesifthesamplesarevalidor
not(andpossiblyfiltersouttheinvalidones).Wealsodonotcheck
forduplicates,whichcanappearbetweendifferentepochsinthe
sampling algorithm. This global check for uniqueness could alsobe added, but it would require an additional time and memory
2The source code is available at https://github.com/RafaelTupynamba/quicksampler.
552
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:53:54 UTC from IEEE Xplore.  Restrictions apply. Efficient Sampling of SAT Solutions for Testing ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden
overhead.Someapplicationsmightprefernottokeepallgenerated
samples in memory, and allow the generation of repeated samples
instead.
Wehaveimplementedanofflineanalysistocheckifthesamples
arevalidandgeneratehistogramsthatcounthowmanytimeseach
solutionhasbeensampled.Werecordthetimetakenbythesample
generation and also the time taken by the checking phase. The
checking phase is not heavily optimized and for most benchmarks
itwasmoreexpensivethanthesamplingphase.Webelievethereisstillroomforimprovementinthecheckingphase,sinceallitneeds
to do is to propagate the values of the independent support to the
remaining variables and check if all clauses are satisfied.
5 EVALUATION
Weevaluate QuickSampler bycomparingagainsttwostate-of-the-
artsamplers UniGen2 [9]andSearchTreeSampler [16].UniGen2
provides strong uniformity guarantees, by using hash functions
composedofXORconstraintsinordertopartitionthesearchspace
into similar-sized bins.
SearchTreeSampler ,ontheotherhand,usestheSATsolverto
findpseudosolutions (partialassignmentstothe firstfewvariables)andprogressivelyaugmentsthepseudosolutionsintorealsolutions.
SearchTreeSampler isonlyapproximatelyuniform.Theunifor-
mity can be increased with a higher number of samples per level k,
but at a cost of also increasing the number of solver calls required.
In our experiments, we used the default value of k=50.
BothQuickSampler andUniGen2 can leverage the knowledge
of an independent support of the formula to improve sampling
performance.Soinordertomakeforafaircomparison,wemod-
ifiedSearchTreeSampler tousethisadditionalinformation.We
reorder the variables of the formula in order to place first the ones
which are part of the independent support. And we additionally
tellSearchTreeSampler to finish sampling after processing those
variables and output pseudosolutions (assignments to the variables
of the independent support) that it has produced so far. Since an
assignmenttotheindependentsupportcanonlybecompletedto
one solution, there is no need to find assignments to the remaining
variables.
For the evaluation, we use the set of benchmarks from the
UniGen2 paper[9]available online3.From thebenchmarks listed
in[9],wefound173ontheonlinerepo.Thebenchmarksinclude
bit-blasted versions of SMTLib benchmarks, ISCAS89 circuits aug-
mented with parity conditions on randomly chosen subsets of out-
puts and next-state variables, problems arising from automated
programsynthesisandconstraintsarisinginboundedmodelcheck-
ing.Thus,theyarerepresentativeofthekindsofconstraintsthat
mightappearinSMTformulasforsoftwaretestingorcircuitcon-
straints for hardware.
On 10 benchmarks4,UniGen2 reported an error because the
specified independent support is not really an independent sup-
port for the formula. In all those benchmarks, we verified that the
3Benchmarks and source code for UniGen2 were obtained from https://bitbucket.org/
kuldeepmeel/unigen.
4GuidanceService2.sk_2_27, GuidanceService.sk_4_27, IssueServiceImpl.sk_8_30,
PhaseService.sk_14_27, ActivityService.sk_11_27, IterationService.sk_12_27,
ActivityService2.sk_10_27, ConcreteActivityService.sk_13_28, NotificationServi-
ceImpl2.sk_10_36, LoginService.sk_20_34.Table 1: Correctness statistics for the samples produced
in one epoch of QuickSampler (average among all bench-marks)
Atomic mutations Total Valid %
0 1 1 100%
1 32 32 100%
2 511 492 96%
3 5619 5208 93%
4 47493 42179 89%
5 346367 282860 82%
6 2143385 1571553 73%
Total 2543409 1902325 75%
numberofsolutionscomputedbytheexactmodelcountersharp-
SAT [41] is larger than 2|S|, which should not happen if Sis a
realindependentsupportfortheformula.Sowedecidedtoexcludethosebenchmarksfromourresults.Theresultsinthispaperinclude
the remaining 163 benchmarks.
On3benchmarks, UniGen2 couldnotestimatethenumberof
solutions:onparity.sk_11_11, UniGen2 raisedafloatingpointex-
ceptionandonisolateRightmost.sk_7_481andlistReverse.sk_11_43,
theApproxMC[ 10]modelcounterusedby UniGen2 couldnâ€™tfin-
ish even in 40 hours. On 2 benchmarks, UniGen2 estimated the
number of solutions but couldnâ€™t produce any samples: on dou-
blyLinkedList.sk_8_37ittimedoutandondiagStencilClean.sk_41_36
it ran out of memory.
The experiments were conducted on a 12-core, 3.50GHz Intel
Corei7-5930KCPU.Foreachbenchmark,eachofthealgorithms
wasgivenonecoreand1.5GBofmemory.For QuickSampler and
SearchTreeSampler ,weallowedamaximumtimeoutof1hour,or
2 hours on the hardest benchmarks. We also stopped the sampling
after a large number of samples had been produced (at least 10
million samples).
ForUniGen2 ,werequestedthegeneration of1000samplesfor
mostbenchmarks,allowingupto20hourstoproducethem.Forthe
hardest benchmarks, we reduced the number of requested samples
to500.Forallthebenchmarksinwhich UniGen2 failedtoproduce
anysamples, ittimesout after20hours evenwhenthe numberofrequested samples was 1.
5.1 Correctness of Samples
OnTable1,welisttheaveragenumberofsamplesproducedand
how many of those were valid, on one epoch of the sampling algo-
rithm. The results were averaged across all 163 benchmarks. They
areclassifiedaccordingtothenumberofindividualatomicmuta-
tionswhichcomposethemutation.Thebasesolutionusedinthe
epoch is the one with 0 atomic mutations and the neighbors of
thebasesolutionobtainedwhenflippingeachbitcorrespondto1
atomicmutation.Thosearealwaysvalidsolutionstotheformula,
since they are obtained as the result of solver calls.
From2to6atomicmutations,weseethatthefractionofvalid
solutionsdecreasesfrom96%to73%.Andoverall,75%ofallsam-
ples produced were valid, when we allow a maximum of 6 atomic
mutations. Table 1 shows that, by adjusting this maximum, we can
553
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:53:54 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden Dutra et al.
changetheaccuracyofthesampling.Forexample,withamaximum
of 5 atomic mutations instead of 6, the fraction of valid samples
wouldincreaseto83%.However,therewouldbeasubstantialde-
crease in the quantity of samples produced. We have chosen to use
themaximumnumberof6atomicmutationstoallowthegenera-
tion of millions of samples, while still having a reasonably good
accuracy of 75%.
Ifnis the number of atomic mutations, then the number of
mutations of level 6 can go up to/parenleftbign
6/parenrightbig, a sixth-degree polynomial
inn. This explains why we can generate millions of samples from
only tens of atomic mutations.
5.2 Performance Comparison
For the performance comparison, we define tq,ts,tuto be the
average time taken by QuickSampler ,SearchTreeSampler and
UniGen2 ,respectivelytoproduceavalidsample. tqwascomputed
astq=Tq/(sqÂ·p), whereTqis the total execution time, sqis the
total number of samples produced and pis the fraction of samples
which are valid for QuickSampler . We additionally define tâˆ—qto
be the estimated time per valid sample that QuickSampler would
require if it also checked all samples for validity. tâˆ—qwas computed
astâˆ—q=(Tq+Tc)/(sqÂ·p), whereTcis the total time taken to check
the validity of all sqproduced samples.
Table2showstheperformancecomparisonamongaselectedset
of benchmarks. We have included the largest benchmarks (more
than4000variables),thebenchmarkswhichwerelistedasrepresen-
tative benchmarks in [ 9] and the benchmarks used for uniformity
plotsinÂ§5.3.ThisincludesthebenchmarkswhichQuickSampler
or SearchTreeSampler found hard.
ThefirstgroupofcolumnsinTable2showsbasicinformation
about the benchmarks: size of the independent support, number
of variables, clauses and solutions. The number of solutions was
obtainedfrom UniGen2 .Onmostbenchmarks,anexactnumberof
solutionsisknown,whileforsomeweonlyknowanapproximation
(represented with â‰ˆ) and on some UniGen2 failed completely to
compute the number of solutions.
The second group of columns shows results for QuickSampler :
thenumberofepochscompleted,numberofMAX-SATsolvercalls,
number of samplesgenerated, fraction of sampleswhich are valid
and the average times per valid sample tqandtâˆ—q, in microsec-
onds. The third and fourth group of columns present results for
SearchTreeSampler andUniGen2 : the number of samples pro-
duced and the average time per sample, taken in comparison with
the QuickSampler time tq.
The mean value for some ratios of interest is shown on Table 3.
Forexample, ts/tqâ‰ˆ102.5Â±0 .8.Thiswascomputedbytakingthe
averageandthestandarddeviationof log10(ts/tq)acrossallbench-
marks.
Figure 3 shows a comparison of the average time per valid
sample, against SearchTreeSampler andUniGen2 . As reported
in Table 3, QuickSampler was on average 2.5 orders of magni-
tude faster than SearchTreeSampler and 4.7 orders of magnitude
fasterthan UniGen2 .Overall, QuickSampler wasonlyslowerthan
SearchTreeSampler onthebenchmarkdiagStencilClean.sk_41_36,
withts/tq=6.6Â·10âˆ’5. We believe QuickSampler did not do well0 20 40 60 80 100 120 140 16010âˆ’510âˆ’310âˆ’1101103105
Benchmarksts
tq
(a) SearchTreeSampler/QuickSampler
0 20 40 60 80 100 120 140 160101102103104105106107108
Benchmarkstu
tq
(b) UniGen2/QuickSampler
Figure 3: Average time per valid sample
ondiagStencilClean.sk_41_36becausetheZ3solverusedinourim-
plementation did not perform well on this formula. In comparison,
MiniSAT,thesolverusedby SearchTreeSampler ,wasmuchfaster
onthisbenchmark.Theoppositeeffectcanbeseen,forexample,on parity.sk_11_11, where MiniSAT was only able to complete a
small number of solver calls.
Nextwepresentgraphsofthesamemetrics,butnowalsotaking
intoaccountthetimethatwouldberequiredfor QuickSampler to
checkifthesamplesarevalid.Thisshouldonlybeneedediftheap-
plication cannot deal with invalid samples. Figures 4a and 4b show
thecomparisonwith SearchTreeSampler andUniGen2 ,respec-
tively.Weseethat QuickSampler isstill1orderofmagnitudefaster
thanSearchTreeSampler and3.2ordersofmagnitudefasterthan
UniGen2 ,evenwhenincludingthischeckingtime. QuickSampler
wasonlyslowerthan SearchTreeSampler onthreebenchmarks,
554
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:53:54 UTC from IEEE Xplore.  Restrictions apply. Efficient Sampling of SAT Solutions for Testing ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden
Table 2: Comparison of sampling algorithms
QuickSampler SearchTreeSampler UniGen2
Benchmark |S|Vars Clauses Solutions nCalls Samples Valid tq(Î¼s)tâˆ—q(Î¼s)Samples ts/tqSamples tu/tq
blasted_case47 28 118 328 262144 244 6616 10010929 0.564 7.5 26 11694350 41.3 3932170 426
blasted_case110 17 287 1263 16384 1387 22208 10001202 0.822 28.3 29 8502350 14.9 245762 34
s820a_7_4 23 616 1703 591872 128 3093 10002673 0.770 5.9 34 4007950 151.6 2959363 802
s820a_15_7 23 685 1987 722944 114 2759 10014350 0.674 9.0 66 3875900 103.2 3614721 674
s1238a_3_2 32 686 1850 2466250752 9 328 10140047 0.936 2.7 211 1917850 707.2 1001 60515
s1196a_3_2 32 690 1805 1038090240 11 393 10077447 0.803 3.2 246 1848850 609.1 1001 60320
s832a_15_7 23 693 2017 3713024 83 2014 10017640 0.818 6.4 100 2742600 204.4 1001 3803
blasted_case_1_b12_2 45 827 2725 274877906944 1 89 10021799 0.739 2.9 305 1001600 1235.7 1001 71769
blasted_squaring16 72 1627 5835 1865275930882 0 65 10304220 0.209 15.8 1961 285450 799.7 1001 215680
blasted_squaring7 72 1628 5837 274408144896 0 68 11344920 0.112 32.1 3788 255750 438.1 1001 22186
70.sk_3_40 40 4670 15864 8589934592 8 304 10134785 1.000 5.8 1236 4091950 151.2 1001 109854
ProcessBean.sk_8_64 64 4768 14458 â‰ˆ7009386627072 1 86 10011221 0.906 4.1 1294 297900 2932.3 1001 179418
56.sk_6_38 38 4842 17828 3690987520 9 334 10049283 0.930 5.3 694 1685350 406.3 1001 71623
35.sk_3_52 52 4915 10547 4398046511104 2 95 10717156 1.000 2.3 229 2348300 664.6 1001 435883
80.sk_2_48 48 4969 17060 1099511627776 2 126 10252598 1.000 4.0 1399 2572650 350.5 1001 103909
7.sk_4_50 50 6683 24816 2199023255552 2 124 10139607 1.000 4.9 1778 1717250 429.5 1001 296687
doublyLinkedList.sk_8_37 37 6890 26918 2038431744 106 3425 10003513 0.267 678.4 6308 231850 22.9 0-
19.sk_3_48 48 6993 23867 2959802892288 1 89 10198861 0.937 4.1 2010 756400 1156.1 1001 814253
29.sk_3_45 45 8866 31557 347892350976 2 120 10045170 0.855 6.7 2772 215450 2483.0 1001 1995316
isolateRightmost.sk_7_481 481 10057 35275 -0 59 11191269 0.878 11.3 3293 6000 52789.2 0-
17.sk_3_45 45 10090 27056 274877906944 3 157 10181716 1.000 5.7 2374 1600150 392.8 1001 3207452
81.sk_5_51 51 10775 38006 18141941858304 1 52 11099585 0.867 4.0 3863 75850 11859.7 1001 1035125
LoginService2.sk_23_36* 36 11511 41411 â‰ˆ163840 272 6019 10001533 0.724 680.3 3212 1593200 14.8 778250 34
sort.sk_8_52 52 12125 49611 â‰ˆ88046829568 2 105 10563617 0.625 31.1 7354 30650 3775.2 1001 155253
parity.sk_11_11* 11 13116 47506 -68 615 3833 0.809 2322699.9 3535813 462 3.2 0-
77.sk_3_44 44 14535 27573 18253611008 6 249 10014904 0.966 5.8 1580 1478300 420.4 1001 2552683
20.sk_1_51 51 15475 60994 37108517437440 1 52 11126152 0.910 4.0 3751 84250 10695.1 1001 2360454
enqueueSeqSK.sk_10_42 42 16466 58515 â‰ˆ3355443200 4 207 10008980 0.762 34.8 21412 29450 3512.4 1001 30830
karatsuba.sk_7_41* 41 19594 82417 â‰ˆ1245184 2 86 670641 0.088 125504.0 203615 50 1116.2 1001 61
diagStencilClean.sk_41_36* 36 378131 2110471 â‰ˆ13 5 66 87 0.701 120336466 120397476 908868 0.000066 0-
tutorial3.sk_4_31* 31 486193 2598178 â‰ˆ49283072 6 193 2114947 0.798 4281.2 362747 1200 693.2 506 18783
Table 3: Mean ratio comparisons across all benchmarks
Ratio Mean
ts/tq102.5Â±0 .8
tu/tq104.7Â±1 .0
ts/tâˆ—q101.0Â±0 .5
tu/tâˆ—q103.2Â±0 .7
uq/us102.3Â±0 .7
uq/uu104.4Â±1 .1
wheretheratio ts/tâˆ—qwas0.95for17.sk_3_45,0.71for70.sk_3_40
and 6.6Â·10âˆ’5for diagStencilClean.sk_41_36.
Thoseresultsshowclearlythat QuickSampler iscapableofgen-
erating valid solutions orders of magnitude faster than the other
techniques. However, we believe that an even more important met-
ric is the number of uniquevalid solutions generated over time,
sincerepeatedsolutionsdonothelpuncovernewbehaviorinthe
testprogram.Soweperformedanexperimenttoevaluatethenum-
ber of unique valid solutions generated.
All three algorithms were allowed to run until they produced 10
millionsamplesorreached1hourofexecution.Iftheirexecution
times are Tq,Ts,Tu, we define T=min{Tq,Ts,Tu}and look at the
numberofuniquevalidsolutionsthateachalgorithmcouldproduce
in timeTand represent those numbers as uq,us,uu. We found out
thatonmostbenchmarks QuickSampler wasabletoproduce10
millionsamplesbefore1houranditwasthefastestalgorithmto
finish.Sotheuniquenesscomparisonisperformedattime Tq.On
sixbenchmarks,neitherofthealgorithmscouldproduce10million
samples before 1 hour, so the uniqueness comparison is performedat 1 hour. The names of those benchmarks are marked with an
asterisk in Table 2.
Figure5acomparesuniquesolutionsproducedby QuickSampler
andSearchTreeSampler . On average, the number of unique so-
lutions produced by QuickSampler was 2.3 orders of magnitude
larger, as seen in Table 3. On only one benchmark it was lower
(karatsuba.sk_7_41, with uq/us=0.76).
InFigure5b,wepresenttheratioofuniquesolutionsbetween
QuickSampler andUniGen2 .Again,theratiowasloweronlyon
karatsuba.sk_7_41,with uq/uu=0.08.Onaverage, uqwas4.4or-
dersofmagnitudehigherthan uu.Wefoundthat QuickSampler
performed poorly on karatsuba.sk_7_41 because it had not com-
pleted one sampling epoch within the first hour of execution, and
most of the samples are generated towards the end of the sam-
pling epoch. However, within 2 hours, QuickSampler was able to
complete 2sampling epochs,generating avastly largeramount of
samples, as reported in Table 2.
5.3 Uniformity of Coverage
TheresultsfromÂ§5.2showthat QuickSampler canproduceunique
validsolutionsveryfast,whichwasourprimarygoal.Butwewould
still like to check if the distribution of samples produced is similar
to uniform, because we donâ€™t want to be missing a large portion
of the solution space, while focusing on a very biased subset of
solutions.Wehavedesignedourmainsamplingfunctiontostart
from a random point in the space of possible variable assignments
in order to make our coverage more uniform. This also guarantees
that any solution has a positive probability of being output by our
algorithm.
Inordertoempiricallyevaluatetheuniformityof QuickSampler ,
we compare its distribution of solutions with the ones from the
555
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:53:54 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden Dutra et al.
0 20 40 60 80 100 120 140 16010âˆ’410âˆ’2100102
Benchmarksts
tâˆ—q
(a) SearchTreeSampler/QuickSampler
0 20 40 60 80 100 120 140 160101102103104105106
Benchmarkstu
tâˆ—q
(b) UniGen2/QuickSampler
Figure 4: Average time per valid sample, including time to
check validity
two other samplers SearchTreeSampler ,UniGen2 as well as a
distributionfromaperfectuniformsampler.Onlythevalidsamples
are considered in this analysis. We compare on the benchmarks
for which the number of samples generated by UniGen2 in a time
limit of 10 hours was at least five times the total number of solu-
tions.Itisimportantforstatisticalsignificancethateachsolution
be sampled on average at least five times. For each of the bench-
marks, let sq,ss,sube the number of valid samples generated by
each algorithm and s=min{sq,ss,su}. We subsample uniformly s
samples from the valid samples produced by each algorithm and
wealsogenerate ssamplesfromaperfectlyuniformdistribution,
using the total number of solutions provided by UniGen2.
Figures 6 to 10 show the results of the comparison on all bench-
marks for which the number of generated samples scan be at least0 20 40 60 80 100 120 140 160100101102103104
Benchmarksuq
us
(a) QuickSampler/SearchTreeSampler
0 20 40 60 80 100 120 140 16010âˆ’1101103105
Benchmarksuq
uu
(b) QuickSampler/UniGen2
Figure 5: Unique solutions produced over same amount oftime

		
	


	

	
	
 !

"
Figure 6: blasted_case47 histogram
556
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:53:54 UTC from IEEE Xplore.  Restrictions apply. Efficient Sampling of SAT Solutions for Testing ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden

      	 	



 
!"
#
Figure 7: blasted_case110 histogram

     	








 
!
Figure 8: s820a_7_4 histogram

      	




 !
"
Figure 9: s820a_15_7 histogram
fivetimesthenumberofsolutionsbeforethetimeoutisreached.The
xaxis represents the number of times each solution has been sam-
pledandthe yaxisrepresentsthequantityofsolutionswhichhave
beensampled xtimes.Wecanseethat SearchTreeSampler and
UniGen2 areusuallyindistinguishablefromuniform,but QuickSampler
is also very close to uniform behavior.
WehavealsoappliedPearsonâ€™schi-squaredtesttothe ssamples
obtained from each algorithm. We compute the Ï‡2statistic and the
corresponding p-value using the known number of solutions to
     		
	


	

	
	 !
"#

$
Figure 10: LoginService2.sk_23_36 histogram
Table 4: Chi-squared Uniformity Test
Not Rejected Rejected
QuickSampler 149 11
SearchTreeSampler 153 7
UniGen2 155 5
theformula.Werejectthenullhypothesisthatthedistributionis
uniform if the p-value is lower than the confidence level of 0.05.
This gives a bound on the type I error rate (i.e., the probability
thatauniformdistributionismistakenlyrejectedasnon-uniform)5.
Table4showtheresultsofapplyingthistesttothe160benchmarks
for which we know an estimate of the number of solutions. We
canseethat SearchTreeSampler andUniGen2 aremoreuniform,
butQuickSampler is still close to uniform on most benchmarks.
However,thisresultshouldbetakenwithcare,sincetheuniformitytestisnotveryreliableonbenchmarkswhere
QuickSampler com-
pleted a small number of epochs or when the number of produced
samples is too low.
Besides analyzing the uniformity of the distribution, we also
measured the number of unique valid solutions generated. This is
arguablymoreimportantthanthehistogramsofsolutioncounts,
because we want unique solutions to increase coverage in testing.
We computed the number uof unique valid solutions generated
byQuickSampler and also the number Â¯uof unique solutions that
should be generated if the sampling was perfectly uniform. We
record the ratio u/Â¯ufor all benchmarks for which we have an esti-
mateofthenumberofsolutions.Theratio u/Â¯uhadanaveragevalue
of 0.981, with standard deviation of 0.052. Besides one benchmark
(doublyLinkedList.sk_8_37,with value0.41),all otherbenchmarks
hadu/Â¯u>0.87.Incomparison,for SearchTreeSampler ,theaver-
age was 0.996 and standard deviation 0.038. SearchTreeSampler
alsoperformedworstonthebenchmarkdoublyLinkedList.sk_8_37,
with value 0.538, and all other benchmarks having u/Â¯u>0.92.
UniGen2 obtained an average of 1.000 and a standard deviation of
0.002,withaminimumvalueof0.999.OndoublyLinkedList.sk_8_37,
UniGen2 timed out, so we cannot compare on this benchmark.
5We could not perform power analysis to estimate the type II error rate because
that would require a specific alternative hypothesis and we did not see any natural
alternative hypothesis for the distribution of samples.
557
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:53:54 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden Dutra et al.

          	



 
 !  
	
"

Figure 11: s820a_7_4 unique solutions

      	
	
	


	
 
	!
Figure 12: enqueueSeqSK.sk_10_42 unique solutions
We also present plots of the number of unique solutions pro-
ducedovertime,fortworepresentativebenchmarks.InFigure11
weshowthegraphforbenchmarks820a_7_4,wherethenumber
of samples produced is larger than the total number of solutions.
We see that the number of unique solutions grows very fast ini-
tially, and then stabilizes as we approach complete coverage of all
solutions. SearchTreeSampler andUniGen2 ,ontheotherhand,
produce solutions at a much slower rate. In Figure 12 we show
benchmark enqueueSeqSK.sk_10_42, where the number of valid
samplesproducedismuchsmallerthanthetotalnumberofsolu-
tions. We can see that QuickSampler is able to generate unique
solutions orders of magnitude faster than SearchTreeSampler
andUniGen2 .Wealsonoticeadistinctivesteppatterninthegraph.
Thishappensbecauseweproducethelargestnumberofsamples
attheendofeachsamplingepoch,whenthecollectionofknown
mutations is the largest.
Insummary,weseethat SearchTreeSampler andUniGen2 are
a bit closer to uniform sampling, but QuickSampler is still very
close. In almost all cases the number of unique solutions generated
wasveryclosetothenumberthatwouldbeexpectedifthesampling
was uniform and we are able to produce new unique solutions at a
faster rate than the other techniques.6 CONCLUSION
WehavedevelopedanewtechniquetosamplesolutionstoBoolean
constraints, with the goal of applying it to constrained-random
verificationandfuzztesting.Forthoseapplications, itistypically
acceptable to produce a small number of invalid inputs, so we
allowourtechniquetooutputsampleswhicharenotguaranteed
to be valid. By leveraging a small number of MAX-SAT solver calls,
QuickSampler can generate millions of samples.
Our experiments show that the produced samples are valid with
anaverageprobabilityof75%onasetoflarge,real-worldbench-
marks.Moreover, QuickSampler ismorethan2ordersofmagni-
tude faster at producing valid samples, when compared to other
state-of-the-art samplers. It is also more than 2 orders of magni-
tude faster at producing uniquevalid samples, which is specially
importanttoincreasetestingcoverage.Wehavealsoverifiedthat
QuickSampler is still 1 order of magnitude faster even when it
takes the additional time to verify that the generated solutions
arevalid.Finally,thedistributionofsamplesproducediscloseto
uniform on most of the benchmarks.
ACKNOWLEDGMENTS
Research partially funded by Brazilian Science Without BordersCAPES 13245/13-9; NSF grants CCF-1409872 and CCF-1423645;
DARPACRAFTHR0011-16-C-0052;IntelScienceandTechnology
CenterforAgileDesign;andASPIRELabindustrialsponsorsand
affiliates Intel, Google, HPE, Huawei, LGE, Nokia, NVIDIA, Oracle,
andSamsung.Anyopinions,findings,conclusions,orrecommen-
dationsinthispaperaresolelythoseoftheauthorsanddoesnot
necessarily reflect the position or the policy of the sponsors.
REFERENCES
[1]SaswatAnandandMaryJeanHarrold.2011. Heapcloning:Enablingdynamic
symbolic execution of java programs. In ASE. 33â€“42.
[2]SaswatAnand,CorinaS.PÄƒsÄƒreanu,andWillemVisser.2007. JPF-SE:asymbolic
execution extension to Java PathFinder. In TACASâ€™07.
[3]ShayArtzi,AdamKiezun,JulianDolby,FrankTip,DannyDig,AmitParadkar,and
Michael D. Ernst. 2008. Finding bugs in dynamic web applications. In ISSTAâ€™08.
[4]Thanassis Avgerinos, Alexandre Rebert, Sang Kil Cha, and David Brumley. 2014.
Enhancing Symbolic Execution with Veritesting. In Proceedings of the 36th Inter-
national Conference on Software Engineering (ICSE 2014). ACM, New York, NY,
USA, 1083â€“1094.
[5]NikolajBjÃ¸rner,Anh-DungPhan,andLarsFleckenstein.2015. Î½Z-AnOptimizing
SMT Solver.. In TACAS, Vol. 15. 194â€“199.
[6]Marcel BÃ¶hme, Van-Thuan Pham, and Abhik Roychoudhury. 2016. Coverage-
based greybox fuzzing as markov chain. In Proceedings of the 2016 ACM SIGSAC
Conference on Computer and Communications Security. ACM, 1032â€“1043.
[7]Jacob Burnim and Koushik Sen. 2008. Heuristics for Scalable Dynamic Test
Generation. In ASEâ€™08.
[8]Cristian Cadar, Daniel Dunbar, and Dawson Engler. 2008. KLEE: Unassisted and
Automatic Generation of High-Coverage Tests for Complex Systems Programs.
InOSDIâ€™08.
[9]SupratikChakraborty,DanielJFremont,KuldeepSMeel,SanjitASeshia,and
Moshe Y Vardi. 2015. On Parallel Scalable Uniform SAT Witness Generation.. In
TACAS. 304â€“319.
[10]Supratik Chakraborty, Kuldeep S Meel, and Moshe Y Vardi. 2013. A scalable
approximatemodelcounter.In InternationalConferenceonPrinciplesandPractice
of Constraint Programming. Springer, 200â€“216.
[11]SupratikChakraborty,KuldeepSMeel,andMosheYVardi.2014. Balancingscala-bilityanduniformityinSATwitnessgenerator.In DesignAutomationConference
(DAC), 2014 51st ACM/EDAC/IEEE. IEEE, 1â€“6.
[12]Vitaly Chipounov, Volodymyr Kuznetsov, and George Candea. 2012. The S2E
Platform: Design, Implementation, and Applications. ACM Trans. Comput. Syst.
30, 1 (2012), 2.
[13]Lori A. Clarke. 1976. A program testing system. In Proc. of the 1976 annual
conference. 488â€“491.
558
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:53:54 UTC from IEEE Xplore.  Restrictions apply. Efficient Sampling of SAT Solutions for Testing ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden
[14]LeonardoDeMouraandNikolajBjÃ¸rner.2008. Z3:AnefficientSMTsolver. Tools
and Algorithms for the Construction and Analysis of Systems (2008), 337â€“340.
[15]StefanoErmon,CarlaPGomes,AshishSabharwal,andBartSelman.2013. Embed
and project: Discrete sampling with universal hashing. In Advances in Neural
Information Processing Systems. 2085â€“2093.
[16]StefanoErmon,CarlaPGomes,andBartSelman.2012.Uniformsolutionsampling
using a constraint solver as an oracle. Conference on Uncertainty in Artificial
Intelligence (2012).
[17]GordonFraserandAndreaArcuri.2011. EvoSuite:automatictestsuitegeneration
for object-oriented software. In Proceedings of the 19th ACM SIGSOFT Sympo-
siumandthe13thEuropeanConferenceonFoundationsofSoftwareEngineering
(ESEC/FSE â€™11). ACM, New York, NY, USA, 416â€“419.
[18]P.Godefroid,N.Klarlund,andK.Sen.2005. DART:DirectedAutomatedRandom
Testing. In PLDIâ€™05.
[19]P.Godefroid,M.Y.Levin,andD.Molnar.2008. AutomatedWhiteboxFuzzTesting.
InNDSSâ€™08.
[20]CarlaPGomes,AshishSabharwal,andBartSelman.2007.Near-uniformsampling
ofcombinatorialspacesusingXORconstraints.In AdvancesInNeuralInformation
Processing Systems. 481â€“488.
[21]Christian Holler, Kim Herzig, and Andreas Zeller. 2012. Fuzzing with Code
Fragments. In Proceedings of the 21st USENIX Conference on Security Symposium
(Securityâ€™12). USENIX Association, Berkeley, CA, USA, 38â€“38.
[22]Allen D. Householder and Jonathan M. Foote. 2012. Probability-Based Parameter
SelectionforBlack-BoxFuzzTesting.TechnicalReport.CarnegieMellonUniversity
Software Engineering Institute.
[23]Alexander Ivrii, Sharad Malik, Kuldeep S Meel, and Moshe Y Vardi. 2016. On
computingminimalindependentsupportanditsapplicationstosamplingand
counting. Constraints 21, 1 (2016), 41â€“58.
[24]Karthick Jayaraman, David Harvison, Vijay Ganesh, and Adam Kiezun. 2009.
jFuzz: A Concolic Whitebox Fuzzer for Java. In In NFMâ€™09.
[25]JamesC.King.1976. Symbolicexecutionandprogramtesting. Commun.ACM
19 (July 1976), 385â€“394. Issue 7.
[26]Nathan Kitchen and Andreas Kuehlmann. 2007. Stimulus generation for con-
strained random simulation. In Computer-Aided Design, 2007. ICCAD 2007.
IEEE/ACM International Conference on. IEEE, 258â€“265.
[27]NathanBoydKitchen.2010. MarkovChainMonteCarloStimulusGenerationfor
Constrained Random Simulation. University of California, Berkeley.
[28]GuodongLi,IndradeepGhosh,andSreerangaP.Rajan.2011. KLOVER:ASym-
bolic Execution and Automatic Test Generation Tool for C++ Programs. In CAV.
609â€“615.
[29]KuldeepSMeel.2014. Samplingtechniquesforbooleansatisfiability. Masterâ€™s
thesis(2014).
[30]KuldeepSMeel,MosheYVardi,SupratikChakraborty,DanielJFremont,SanjitA
Seshia,DrorFried,AlexanderIvrii,andSharadMalik.2016.ConstrainedSamplingandCounting:UniversalHashingMeetsSATSolving..In AAAIWorkshop:Beyond
NP.
[31]AlexanderNadel.2011. GeneratingDiverseSolutionsinSAT..In SAT.Springer,
287â€“301.
[32]Reuven Naveh and Amit Metodi. 2013. Beyond feasibility: CP usage in
constrained-randomfunctionalhardwareverification.In InternationalConference
on Principles and Practice of Constraint Programming. Springer, 823â€“831.
[33]Yehuda Naveh, Michal Rimon, Itai Jaeger, Yoav Katz, Michael Vinov, Eitan s
Marcu,andGilShurek.2007. Constraint-basedrandomstimuligenerationfor
hardware verification. AI magazine 28, 3 (2007), 13.
[34]Carlos Pacheco, Shuvendu K. Lahiri, Michael D. Ernst, and Thomas Ball. 2007.
Feedback-directed random test generation. In ICSEâ€™07, Proceedings of the 29th
International Conference on Software Engineering. Minneapolis, MN, USA, 75â€“84.
[35]C. Pasareanu, P. Mehlitz, D. Bushnell, K. Gundy-Burlet, M. Lowry, S. Person,
and M. Pape. 2008. Combining Unit-level Symbolic Execution and System-level
Concrete Execution for Testing NASA Software. In ISSTAâ€™08.
[36]Prateek Saxena, Devdatta Akhawe, Steve Hanna, Feng Mao, Stephen McCamant,
and Dawn Song. 2010. A Symbolic Execution Framework for JavaScript. In
Proceedings of the 2010 IEEE Symposium on Security and Privacy (SP â€™10). IEEE,
513â€“528.
[37]Koushik Sen and Gul Agha. 2006. CUTE and jCUTE : Concolic Unit Testing and
Explicit Path Model-Checking Tools. In CAVâ€™06.
[38]Koushik Sen, Swaroop Kalasapur, Tasneem Brutch, and Simon Gibbs. 2013.
Jalangi: A Selective Record-Replay and Dynamic Analysis Framework for
JavaScript. In ESEC/FSEâ€™13. To appear.
[39]KoushikSen,DarkoMarinov,andGulAgha.2005. CUTE:AConcolicUnitTesting
Engine for C. In ESEC/FSEâ€™05.
[40]DawnSong,DavidBrumley,HengYin,JuanCaballero,IvanJager,MinGyung
Kang, Zhenkai Liang, James Newsome, Pongsin Poosankam, and Prateek Saxena.
2008. BitBlaze:ANewApproachtoComputerSecurityviaBinaryAnalysis.In
ICISSâ€™08.
[41]Marc Thurley. 2006. sharpSAT-counting models with advanced component
caching and implicit BCP. SAT4121 (2006), 424â€“429.[42]NikolaiTillmannandJonathandeHalleux.2008. Pex-WhiteBoxTestGeneration
for .NET. In TAPâ€™08.
[43]WeiWei,JordanErenrich, and BartSelman. 2004. Towardsefficient sampling:
Exploiting random walk strategies. In AAAI, Vol. 4. 670â€“676.
[44]Wei Wei and Bart Selman. 2005. A new approach to model counting. In SAT.
Springer, 324â€“339.
[45]Xuejun Yang, Yang Chen, Eric Eide, and John Regehr. 2011. Finding and Un-
derstanding Bugs in C Compilers. In Proceedings of the 32Nd ACM SIGPLAN
Conference on Programming Language Design and Implementation (PLDI â€™11).
ACM, New York, NY, USA, 283â€“294.
[46]MichaÃ…Ä† Zalewski. [n. d.]. American Fuzzy Lop. http://lcamtuf.coredump.cx/afl.
([n. d.]). Accessed October 1, 2016.
[47]Yanni Zhao, Jinian Bian, Shujun Deng, and Zhiqiu Kong. 2009. Random stimulus
generation with self-tuning. In Computer Supported Cooperative Work in Design,
2009. CSCWD 2009. 13th International Conference on. IEEE, 62â€“65.
559
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:53:54 UTC from IEEE Xplore.  Restrictions apply. 