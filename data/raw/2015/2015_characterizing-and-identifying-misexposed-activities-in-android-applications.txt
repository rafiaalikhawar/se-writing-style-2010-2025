Characterizing and Identifying Misexposed Activities in
Android Applications‚àó
Jiwei Yan
Tech. Center of Softw. Eng.
Institute of Software, CAS, China
Beijing, China
yanjw@ios.ac.cnXi Deng
State Key Lab. of Computer Science
Institute of Software, CAS, China
Univ. of Chinese Academy of Sciences
Beijing, ChinaPing Wang
State Key Lab. of Computer Science
Institute of Software, CAS, China
Univ. of Chinese Academy of Sciences
Beijing, China
Tianyong Wu
State Key Lab. of Computer Science
Institute of Software, CAS, China
Beijing, ChinaJun Yan‚Ä†
State Key Lab. of Computer Science
Institute of Software, CAS, China
Univ. of Chinese Academy of Sciences
Beijing, ChinaJian Zhang‚Ä†
State Key Lab. of Computer Science
Institute of Software, CAS, China
Univ. of Chinese Academy of Sciences
Beijing, China
ABSTRACT
ExportedActivity(EA),akindofactivitiesinAndroidappsthatcan
be launched by external components, is one of the most important
inter-component communication (ICC) mechanisms to realize the
interactionandcooperationamongmultipleapps.Existingworks
have pointed out that, once exposed, an activity will be vulnerable
to malicious ICC attacks, such as permission leakage attack. Unfor-
tunately,itisobservedthataconsiderablenumberofactivitiesin
commercial apps are exposed inadvertently, while few works have
studiedthenecessityandreasonabilityofsuchexposure.Thiswork
takesthefirststeptosystematicallystudytheexposingbehavior
ofEAsthroughanalyzing13,873Androidapps.ItutilizestheEA
associatedcallrelationshipsextractedfrombyte-codeviadata-flow
analysis, as well as the launch conditions obtained from the mani-
fest files, to guide the study on the usage and misexposure of EAs.
TheempiricalfindingsarethattheEAmechanismiswidelyadopted
indevelopmentandtheactivitiesareliabletobemisexposeddueto
thedevelopers‚Äômisunderstandingorcarelessness.Furtherstudyonsubsetsofappsselectedaccordingtodifferentcriteriaindicatesthat
the misexposed EAs have specific characteristics, which are manu-
allysummarizedintosixtypicalmisusepatterns.Asaconsequence,
ten heuristics are designed to decide whether an activity should be
exposed or not and are implemented into an automatic tool called
Mist.Experimentsonthecollectedappsshowthataroundonefifth
EAsare unnecessarilyexposedandthereare morethanonethird
EAs whose exposure may not be suggested.
‚àóThis work is supported by National Natural Science Foundation of China (Grant
No. 61672505), the National Key Basic Research (973) Program of China (Grant No.
2014CB340701), and Key Research Program of Frontier Sciences, CAS, Grant No.
QYZDJ-SSW-JSC036.
‚Ä†Corresponding Authors. Email: yanjun@ios.ac.cn, zj@ios.ac.cn
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitationon the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,
topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
¬© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.3238164CCS CONCEPTS
‚Ä¢Generalandreference ‚ÜíEmpiricalstudies ;‚Ä¢Softwareand
its engineering ‚ÜíSoftware testing and debugging;
KEYWORDS
Android apps, Exported Activity, Program Analysis
ACM Reference Format:
JiweiYan,XiDeng,PingWang,TianyongWu,JunYan,andJianZhang.2018.
CharacterizingandIdentifyingMisexposedActivitiesinAndroidApplica-
tions. In Proceedings of the 2018 33rd ACM/IEEE International Conference on
Automated Software Engineering (ASE ‚Äô18), September 3‚Äì7, 2018, Montpellier,
France.ACM,NewYork,NY,USA, 11pages.https://doi.org/10.1145/3238147.
3238164
1 INTRODUCTION
WiththegrowingmomentumoftheAndroidOSanditsappmarket,
thefunctionalitiesofappsbecomerichandspecialized.Itisatrend
thatmoreandmoreappsshareinformationandcollaboratewith
each other to complete a complex task. For instance, an electronic-
paymentappcan be invokedbymultiplethird-partye-commerce
appstoperformthepaymentprocess.Anotherexampleisthatmany
appsareembeddedwithsocialcontactfunctionalitybyinvoking
some mature social contact apps, e.g., Facebook andWeChat.
By default, an activity in an app is invisible to the external apps,
i.e.,theycannotbeactivatedbyactivitiesinotherapps.TheAn-
droid system provides the ‚ÄúExported Activity‚Äù (EA forshort) mech-
anismbywhichanappcansharespecificactivitieswithotherapps.
EAs can be regarded as the interfaces of apps, which usually carry
the key functionalities that the developers want to promote and
willberepeatedlyinvokedbyotherapps.Besides,theinvocation
toEAsmaybeindeterministicduetotheAndroidspecificmapping
mechanism (e.g., implicit invocation, see Section 2.3), which brings
flexibility and uncontrollability to their usage.
Many activities are made to be exposed (i.e., EA) in practice. Ac-
cordingtoourstatistics,aroundtwothirdsofappshaveatleastoneEA,andthepercentageofEAinallactivitiesisabout8.6%(seeSec-tion4.1).Existingworks[
1‚Äì3]haveshownthevulnerabilityofEAs.
For example, the arbitrary data received from external apps may
disturbtheapps‚Äôregularwork-floworevencausecodeinjection,
691
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Jiwei Yan, Xi Deng, Ping Wang, Tianyong Wu, Jun Yan, and Jian Zhang
and the invoking of sensitive APIs in EA without the protection of
permissionsmaycausepermissionleakage.Arecentresearch[ 4]
alsoshowsthatinter-componentcommunication(ICC)methodsare
significantlyusedbymalwaretoleakprivatedata.Thus,wehave
the following hypothesis: exposed activities might bring the
potential vulnerabilities to the entire application . Although
theEAsimplifiesinter-appinteraction,newpotentialsecurityrisks
andfunctionalitybugsthatitmightbringforcedeveloperstothink
carefully before using it.
Recent works [ 5‚Äì9] have provided a series of effective defect
detection approaches that involve EA, however, little is known
aboutwhethertheexposingbehaviorofanactivityisproperornot.
Thewideadoptionofsuchaflexibleanderror-proneEAmechanism
drivesustore-examinetheactivitiesthataredeclaredtobeexposed.
Thus, we make a large-scale empirical study on 12,673 commercial
appsand1200open-sourceonesinordertoanswerthefollowing
three research questions:
‚Ä¢RQ1(UsageofEA): TowhatextentareEAsusedbydevelop-
ers? Which functionalities are EAs mostly used to perform?
‚Ä¢RQ2 (Comparative Analysis): Are there any differences
between the well exposed activities and those should not
necessarily be exposed?
‚Ä¢RQ3 (Characteristics of Misexposed EA): Are there any
common patterns of unnecessarily exposed activities? Can
these misexposed EAs be identified automatically?
Toanswerthesequestions,wefirstobtainthelaunchconditions
ofEAsandextractintentsthatcanstartcertainEAsviadata-flow
analysis on apks. Then, we match intents to activities according to
theAndroidmechanismandconstructthecaller-calleepairswithin
the app set. We further employ a comparative analysis on twosets of selected apps to investigate the misexposure of activities.
The comparison results indicate that the misexposed EAs have
specific characteristics, which are manually summarized into six
typicalmisusepatterns.Furthermore,wesumuptenheuristicrules
based on these patterns to categorize the EAs into four classes,
and implement these ten rules into a tool called Mistfor automatic
misexposed EA identification. The experiments on the collectedappsshowthatabout19.23%EAsareunnecessarilyexposedand
there are 36.50% EAs whose exposure may not be appropriate.
To sum up, the contributions of this work lie in three-fold:
(1)Weconductanempiricalstudyonthreedatasetstounder-
standthe usageand misexposureof EAsin practice.To the
best of our knowledge, this is the first research that system-
atically studies the behavior of activity exposure.
(2)We make use of static analysis techniques to extract EArelated information from tens of thousands of real-world
apps to aid the misexposure identification.
(3)Wesummarizesixkindsofmisusepatternsandextractten
rules,basedonwhichatoolcalled Mistisdesignedandimple-
mented for EA misexposure identification. The experiments
show that our tool can effectively help to find the misex-posed EAs. Both our tool and the related data are publicly
available on GitHub (https://github.com/AndroidMist/Mist).2 BACKGROUND
This section provides the background knowledge about Android
system and exported activity.
2.1 Android Activity
Androidisanopen-sourceandLinux-basedoperatingsystemde-
veloped by Google for portable devices. Except for some native
libraries, Android apps are mainly written in Java and compiledinto Dalvik byte-code, while they also have some configuration
files (e.g., manifest file) to declare the components and layouts. An-
droidappsarecomposedoffourkindsofcomponents,including
Activity, Service, Content Provider,and Broadcast Receiver.Among
them,activityisthemostfrequentlyusedcomponentthatprovides
an interface for the users‚Äô interaction. A research [ 4] shows that
around 67.4% of the total ICC method calls are related to the ac-
tivitycomponent.Theactivitycanbecategorizedintotwokinds,
including the Internal Activity (IA) andExported Activity (EA). The
formeronecanonlybelaunchedbythecomponentsinthesame
app, while the latter one allows other Android apps to launch it.
TheEAprovidesaneffectivewayfortheICCamongmultipleapps,
which is the major component discussed in this paper.
2.2 Activity Attribute and Intent Filter
Androidsystemprovidesanumberofattributesfortheactivity[ 10],
whichcanbemainlysetinthemanifestfilebydevelopers.Weonly
list the relevant ones here.
‚Ä¢android:exported Bydefault,thisattributeissetas false,
i.e.,theactivityisanIA.Developerscanchangeittoexported
by setting its value as true.
‚Ä¢android:permission This attribute defines the permission
whichisrequiredforexternalappstoactivatethisactivity.
If the caller app does not declare this permission, it is not
allowed to call this activity.
Theintent filter is an element of EA that is also set in the
manifestfile,whileanEAcanhavemultipleintentfilters.Itdecides
whatkindsofimplicitintentstheEArespondsto.Anintentfilter
contains several sub-elements, including action,category , and
data.Theresolutionfromintenttointentfiltersisperformedon
theseelementsbasedonspecificrules[ 11].Ifmultipleintentfilters
arecompatible,thesystemdisplaysadialogshowingoptionsfor
userstopickupwhichapptostart.Theintentfilterhasanattribute
android:priority thatprovidesinformationabouthowablean
activity is to respond to the intent that matches the filter. Android
will consider only those with higher priority values as potential
targets for the intent.
2.3 Activity Exposing and Launching
There are two rules to expose an activity, according to the Android
reference [ 10]. First, if the attribute android:exported is set as
true, this activity will be an EA. Besides, for an activity whose
attribute android:exported is not set, it will also be an EA if it
contains at least one intent filter [ 12]. Note that, only effective
intent filters are considered, e.g., intent filters with no action are
ignored because they can not be invoked. The rest activities are
internal ones (IAs).
692
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. Characterizing and Identifying Misexposed Activities in Android Applications ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
BothEAandIAcanbelaunchedbythemechanismofintent[ 11],
whichcanbecategorizedintotwotypes, Explicit Intent andImplicit
Intent.Theexplicitintentsspecifyitstarget bygivingtheactivity
name(thefully-qualifiedclassname),whiletheimplicitintentsonly
declare a seriesof features (e.g., action andcategory), which makes
invokingcomponentsofotherappspossiblewithouttheknowledge
of the concrete component name [ 11]. Android system provides
asetofAPIstoassigntheseattributesthatarerelatedtoactivitylaunching, some of which are listed in Table 1. The combination
of these attributes determines the type of invocation (explicit or
implicit) and which activity to be launched.
Table 1: some attribute assignment APIs of Intent
Intent Attribute API
componentsetClass, setClassName, setComponent,
Intent(Context, Class)
action setAction, Intent(String)
category addCategory
data setData
action, data Intent(String, Uri)
action, data, component Intent(String, Uri, Context, Class)
When receiving an explicit intent, the activity with the same
component name will be directly picked up for reaction. For im-
plicit intents, the system needs to find appropriate activities to
start by comparing descriptions of the intent and the intent fil-ters of other activities. It first compares the action informationbetween the intent and all intent filters of EAs. The action spec-ified in the intent must match one of the actions listed in thefilter. For category matching, every category in the intent mustmatch a category in the filter. For intent without category, thecategory
android.intent.category.DEFAULT will be added by
default. Thus, each intent should declare the default category, or
else it will not be launched by any implicit intent. For the data ele-
ment,eachpartofitisaseparateattributeintheintentfilter,which
canbecomposedasauri: <scheme>://<host>:<port>/<path>
and then be used for data matching.
2.4 An Example of EA
In this subsection, we illustrate the EA and intent mechanism by a
simple example. Figure 1shows a portion of manifest file of an EA
FooActivity .ThisEAdeclares exported=true explicitlyaswell
asapermissionnamed com.intent.permission.Foo .Inaddition,
it has an intent filter for implicit intent calls. This intent filter
willrespondtointentsthatsatisfythefollowingthreeconditions:
containingaction com.intent.action.Foo ;havingnocategoryor
onlythedefaultone;containingdataelementwhosecorresponding
uri matches http://foo.
Figure2shows an activity that can launch this EA. It creates an
intent instance with a string as the parameter, which denotes that
the action is com.intent.action.Foo . Then it sets the category
and data attributes, where the value of category is obtained by
invoking the method getCategoryStr() and the value of data
is obtained from the parameter uriData. Note that if the default
categoryattributeisnotsetinthecode,theAndroidsystemwilladd it to the intent by default. Then the data items are attached,
in which bundleis a mapping from Stringkeys to various values.<activity android:name="FooActivity"
android:exported="true"
android:permission="com.intent.permission.Foo" >
<intent-filter>
<action android:name="com.intent.action.Foo"/>
<category android:name="android.intent.category.DEFAULT"/>
<dataandroid:scheme="http" android:host="foo"/>
</intent-filter>
</activity>
Figure 1: Manifest File of FooActivity
public class FooLaunchActivity extends Activity {
public void startWithData(String uriData) {
Intentintent = new Intent ("com.intent.action.Foo");
StringmyCategory = getCategoryStr();
intent.addCategory(myCategory);
intent.setData(Uri.parse(uriData));
intent.putExtra("key1", "abcdefg");
intent.putExtra("key2", new Bundle());
bundle.putInt("key3", 12345678);
this.startActivity(intent);
}
}
Figure 2: Activity for Launching FooActivity
Finally, this intent will be performed with the API startActivity
and be resolved to the intent filter of the activity FooActivity ,
which will be launched by the Android system after resolving.
3 EMPIRICAL STUDY METHODOLOGY
To the best of our knowledge, there are no systematic empirical
researches thatinvestigate the usageand exposingcharacteristics
of EA mechanism in Android apps. Thus, we conduct an empiri-
cal study to investigate how EAs are used in real-world Androidapps. In this section, we introduce the experimental dataset and
the method of the empirical study.
3.1 Analysis Method
TosystematicallystudytheusageofEA,weperformastatisticanal-
ysistoobtaintheEAdeclarationinformationinmanifest,including
themostcommonlyusedactionsandtheexposingmodesofEAs,
etc. And to make clear how EAs are invoked in the program, we
analyzetheintentrelatedAPIsbyapplyingalight-weightdata-flow
analysis on bytecode of the app. Then we construct two databases
based ontheanalyzing results,i.e.,the EA declaration database and
EA invocation database. The first one stores the EA declaration in-
formation, including activity attributes as well as intent filters, and
the second one stores all possible invocations used in the program.
Finally,theinformationinthetwodatasetsismatchedaccording
totheAndroidmappingmechanismtoconstructthecaller-callee
pairswithintheappset,whichcanguidethestudyontheusage
andmisexposureofEAs.Theoverallanalysisprocessisshownin
Figure3.
3.2 Dataset Collection
Therearethreedatasetsinourempiricalstudy,inwhichDatasetAL
contains all the apps we collected from app markets, and the other
two are selected from Dataset AL according to different criteria.
693
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Jiwei Yan, Xi Deng, Ping Wang, Tianyong Wu, Jun Yan, and Jian Zhang
Manifest 
Analysis
Intent
AnalysisEA Declaration 
Database
EA Invocation  
DatabaseDecompileCall 
Relationship 
ExtractionStatistic
Figure 3: Overall Analysis Process
DatasetAL:13,873Androidappsfromthreemarkets .They
arecollectedfromthreeappmarkets,includinganopen-sourceapp
repositoryF-Droid(1,200,10.8%),GooglePlay(6,946,50.1%),and
a Chinese app market Wandoujia (5,727, 41.3%). For F-Droid, we
downloadalltheavailableappsinJune2017usingawebcrawler.
Considering the scale of Google Play and Wandoujia, obtaining
alltheirappsisnotpossible.SinceGooglePlayhas32categories
and Wandoujia has 14 ones, we download the first 500 apps of
each category by the display order. For Google Play, direct app
downloadingisnotallowed,thuswegetappsfromathird-party
websiteAPKLeecher[ 13]andmisssomeapps.Besides,appsthat
can not be decompiled are excluded from the dataset. Figure 4
displays the downloads and size distributions of the collected apps
usingbox-plots.Aswecansee,theseAndroidappsarewidelyused.
Amongthem,halfhavetheirdownloadcountsintherangefrom
onehundred thousandtoonemillion, asdemonstratedby thesolid
medianline.Andthesizeof theappsrangingfromhundredsofKB
tohundredsofMB,isattheaverageof15MBinGooglePlayand
18MB in Wandoujia, as shown by the X mark symbol.
Google Wandoujia
Google
WandoujiaF-Droid
Figure 4: Downloads and File Size Distribution.
DatasetAR:AppscontainingEAsthatmightnotnecessar-
ily serveas externalinterfaces. We focus on the apps that have
different characteristics with most others and suppose that EAsin them might not necessarily be exposed to external apps. EAs
are specially designed for external interaction rather than internal
main functionality. According to our statistic, most apps exposeonly a small part of activities for external invocation, however,
the percentage of EA in some apps are abnormally high. To get
knowledgeaboutthegenerationofthisdataset,wemakeasmall
empirical study. And in this study, we take the ratio of EA against
the number of activities as the indicator for abnormal app identifi-
cation.First,wepickthetop5appswiththemostabnormalratioof
EAsfromDatasetALandextract327EAsfromthem.Bylaunching
each EA and inspect its bytecode to judge the reasonableness of
theexposure,thetesterreportthat234EAs(71.6%)aresuspected
to be misexposed. Thus, in our experiments, we distinguish theoutlierappsthathavetheabnormalratioofEAsinSection 4.1as
Dataset AR based on the following assumption: the apps with an
abnormal ratio of EAs compared with most of the apps aremore likely poorly programmed.
Dataset MD: Apps containing EAs that are more likely
well declared.
To make a comparative analysis between normal
appsandoutlierappsinDatasetAR,wewanttoextractEAsthat
haveahigherpossibilityofbeingwelldeclared.Consideringthat
widely used apps are more likely to be developed under strict code
regulationsbyskilledprogrammersandmighthavebeenwelltested,
theEAscorrespondingtosuchapps aremorelikelytobewellde-
claredandsuitableforcomparison.Wealsomakeasmallempirical
study for the generation of this dataset. We pick 5 apps with themost downloads from Dataset AL and extract 47 EAs from them.
By launching each EA and inspect its bytecode to judge the rea-
sonableness of the exposure, we find that only 5 EAs (10.6%) arelabeled as misexposed activities. And most of (4/5) these widely
used apps provide specific SDKs (e.g., WeChat‚Äôs open SDK[ 14]) for
external invoking so that have only a small percentage EA (15/476
for WeChat). Therefore, we pick up 50 apps that have the most
downloads in Dataset AL to generate Dataset MD.
3.3 Manifest Analysis
According to the Android reference, any activity must be declared
inthemanifestfile,whichiswritteninXMLlanguage.Therefore,
the complete EA declaration report can be obtained by parsingand analyzing manifest files. We first decompile an apk file intotwo parts, the manifest file and the Dalvik byte-code. Then, weidentify all the
/angbracketleftactivity/angbracketrighttags, and collect the activity attribute
(e.g.,android:exported )aswellastheintentfilter(e.g., android:
action) information.
3.4 Intent Analysis
To have insights into the activity invocation, we make a static
analysis of ICC messages on the program byte-code. In this step,
wemakeuseofaJavabytecodeanalysisframework soot[15]for
data-flow analysis. Considering that existing intent analysis toolis inefficient (e.g., 140 seconds per app using IC3) in analyzing
our large-scale datasets, we adopt a light-weight intent analysis
method in this paper. Our method is mainly based on the reaching
definition technique [ 16], which focuses on statically determining
which definitions may reach a given point in the code.
As shown in Algorithm 1, we perform a variable assignment
analysis on ICC messages. For each method under analysis (in
line 2), we first construct use-define chains [ 17] to capture the data
propagation. In line 3, we recognize all the invocation units by
locating instructions that invoke API startActivityForResult
orstartActivity , and add them into set invs. Then, in line 5, we
makeuseoftheuse-defchaintoobtainthecorrespondingintent
objectintentfor each unit in invs. Next, we collect all the units
thatarerelatedtoobject intentandformaset usesinline6.In
line7-13,weiterateoveralltheunitsinset usesaimingtofindout
all the assignments of each intent-related attribute. ConsideringthateachAPIlistedinTable 1canbeused,wefirstgetthename
of attribute (e.g.,
attr_name=action ) usinggetAttrName(use) .
694
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. Characterizing and Identifying Misexposed Activities in Android Applications ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
For this attribute, we get a mapping of (attribute, variable) by in-
vokingmethod getAttrVar(udc, use) ,andthengettheassign-
mentsofeachvariable,i.e.,a(variable,assignments)mapping,by
invoking getVarAssign(method, var) . Finally, the obtained in-
formation will be added to the output set by invoking method
storeIntentInfo in line 12.
To get the corresponding assignment of a variable, one diffi-
culty is that not all assignments of it can be directly obtained.
For a variable assigned as the return value of a function call, we
search the callee method by its methodSignature and get the last
assignmentofthereturnvalue.Andforavariableassignedinthe
caller method that is passed as a parameter, we search the callermethod by its name through call graph. Because there may be
severalcallermethods,welocateallthecallpointsandaddthese
correspondingassignmentsintoacandidateset.Besides,wetake
careofbranchstatementsandgetallthepossibleassignmentsac-
cording to theuse-def chain. The assignmentobtaining algorithmof method –¥etVarAssi–¥n (method ,var )is shown in Algorithm 2.
3.5 Call Relationship Extraction
Android system has a mechanism for mapping an intent invoca-
tion to activities. When an intent is invoked for activity launching
explicitly,theAndroidsystemwillwakeupthetargetactivitybyitscomponentname.However,fortheimplicitlyinvokedintents,
theAndroidsystemneedstosearchallappsforintentfiltersthat
match the given intent. We simulate the matching process (refer to
Section2.3) between the caller and callee to extract call relation-
ships for the apps we collected. Then, we can obtain the matching
resultsonaspecificdataset,e.g.,thecallersetofgivenEAorthe
callee set of an intent object.
4 OBSERVATIONS FROM EMPIRICAL STUDY
In this section, we discuss our major findings by previous analy-
ses.AllofouranalysisprocessesareperformedonanIntelXeon
CPU@2.40GHzmachine,with64GBmemoryandUbuntu16.04
operating system. It takes about 33 hours to decompile all the apk
files(8secondsperapp),34minutesformanifestfileanalysisand
around 80 hours for intent analysis (20 seconds per app).
Algorithm 1 Activity Invocation Analysis
Input:method name method
Output: intent info
1:res_list=‚àÖ
2:udc=–¥etUseDefineChains (method )
3:invs =–¥etAllUnitsInvokin–¥API (‚ÄústartActivity ‚Äù)
4:foreach unitinvin setinvsdo
5:intent =–¥etIntentVariable (udc ,inv )
6:uses =–¥etUseUnitSet (udc ,intent )
7:foreach unitusein setusesdo
8: ifunituseassigns attribute attrthen
9: attr_name =–¥etAttrName (use )
10: attr_var=–¥etAttrVar (udc ,use )
11: attr_assi–¥n =–¥etVarAssi–¥n (method, attr_var )
12: storeIntentInfo (intent ,attr_name ,attr_assi–¥n )
13: end if
14:end for
15:end forAlgorithm 2 –¥etVarAssi–¥n (method ,var )
Input:method, var
Output: assignment
1:udc=–¥etUseDefineChains (method )
2:unit =–¥etDefUnit (var )
3:ifunitis caller method then
4:callee =–¥etCalleeMethod (unit )
5:var=–¥etRetVar (callee )
6:assi–¥nment =–¥etVarAssi–¥n (callee ,var )
7:else ifunitis callee method then
8:callers =–¥etCallerMethods (unit ,–¥etCallGraph ())
9:foreach method callerincallers do
10:var=–¥etParameterVar (caller ,method, para_index )
11:assi–¥nment =–¥etVarAssi–¥n (caller ,var )
12:end for
13:else
14:assi–¥nment =–¥etUnitAssi–¥n (unit )
15:end if
16:return assignment
4.1 EA usage
In this part, we discuss the usage and functionality of EA.
PercentageofEA. TofigureoutwhetherEAisfrequentlyused
in real-world apps or not, we count the number of activities and
EAs declared in each app. The detailed results of the apps collectedfrom different app markets are shown in Table 2, where the second
to fourth columns show the number of apps (#N), activities (#A)
and EAs (#EA), and the fifth column shows the number of apps
that have at least one EA (#AEA). Note that a special kind of EA,
MainActivity (whose action is android.intent.action.MAIN
andcategoryis android.intent.category.LAUNCHER ),isexcluded
intheprocessofcounting,sinceeach MainActivity istheentry
of its app and is EA by default. Totally, we get 639,483 activities,
amongwhich55,075activitiesareEAs(8.6%).Andthereare9,361
(67.5%) apps that have at least one EA (#AEA), which indicates
thatthe EA mechanism is widely adopted in the real-world
Android applications.
Table 2: Number of Activities and EAs
App Market #N #A #EA #AEA
F-Droid 1200 6898 1109 492
Google Play 6946 195973 17514 4243
Wandoujia 5727 436612 36452 4626
Total 13873 639483 55075 9361
App Market #Avg A#Avg EA#EA/#A #AEA/#N
F-Droid 5.7 0.9 16.0% 41.0%
Google Play 28.2 2.5 8.9% 61.1%
Wandoujia 76.2 6.4 8.3% 80.1%
Average 46.1 4.0 8.6% 67.5%
We calculatethe ratio ofEAs (#EA/#A) of allthe collected apps
anddisplaytheresultsinFigure 5.Theappscollectedfromdifferent
marketsarelabeledwithdifferentcolorsandshapes.Theseapps
alsohavedifferentcharacteristics,e.g.,open-sourceappsinF-Droid
always contain fewer activities than commercial ones. For com-
mercial apps, the apps in Wandoujia are with a higher ratio of EAs
andaremoredispersedthantheseinGooglePlay.Wehavetwoob-
servationsfromFigure 5:1) someapps haveextremely higher
percentageofEAsthanothers;2)whenthenumberofactiv-
ities increases, the ratio of EAs decreases in most cases.
TheLocal Outlier Factor (LOF)algorithm[ 18],isusedtoidentify
outliersbasedonthedensity.Althoughappswithmanyactivities
695
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Jiwei Yan, Xi Deng, Ping Wang, Tianyong Wu, Jun Yan, and Jian Zhang

      3BUJPPG&"
/VNCFSPG"DUJWJUZ8BOEPVKJB (PPHMF '%SPJE
Figure 5: Distribution of the Ratio of EAs
Number of ActivityRatio of EA
Figure 6: Outlier App Detection Result
and few EAs might also be taken as outliers by the LOF algorithm,
theyaremorelikelytobewell-programmedappsindeed.Therefore,
we filter out the apps whose ratio of EAs is less than 0.1. The final
results are displayed in Figure 6, in which the background color
denotes the contour plot based on density. The lighter the color,
the higher the density. To maintain the number consistency of two
datasets, the top 50 outliers (red points) are labeled as outlier apps
and added into Dataset AR.
Functionality of EA. As introduced in Section 2.3,a nE Am a y
containseveralintentfilterstodeclarewhatkindsofimplicitintent
theEArespondsto.Theactionattributeintheintentfilterindicates
which kindof operationsthe EAwill perform aswell asshows its
main functionality. So we extract all the intent filters from the
manifestfileandget63,758actionsthatarein10,010types.Among
theseactions,44,181(69.3%)actionsaresystemonesthataredefined
in theIntent.java file of Android source code.
Table 3: Most frequently used actions
Actions Declared in Manifestsystemandroid.intent.action.VIEW (58.6%)
android.intent.action.SEND (3.1%)
android.intent.action.SEARCH (1.8%)
android.appwidget.action.APPWIDGET_CONFIGURE (1.2%)
android.intent.action.CREATE_SHORTCUT (1.0%)non-systemcom.sina.weibo.sdk.action.ACTION_SDK_REQ_ACTIVITY (2.5%)
com.google.android.gms.appinvite.ACTION_PREVIEW (0.9%)
cn.jpush.android.ui.PushActivity (0.3%)
COM_TAOBAO_TAE_SDK_TRADE_WEB_VIEW_ACTION (0.2%)
com.google.android.gms.actions.SEARCH_ACTION (0.2%)Display, 61.22% Send, 4.44% Other, 2.98%
SDK, 2.90%Search, 2.36%
Setting, 1.67%Debugging, 0.04%
Figure 7: Functionality of Actions.
Table3showsthemostfrequentlyusedactionsinourEAdeclara-
tiondatabase.Themostfrequentlyusedsystemactionis android.in
tent.action.VIEW (58.6%), which is used to display the data to
users,e.g.,textorwebpagebrowsing.Andthemostfrequentlyused
non-system action is com.sina.weibo.sdk.action.ACTION_SDK
_REQ_ACTIVITY (2.5%),whichisusedtocallbackthecallerappwho
invokes sina weibo (asocialnetworkingapplication)withasharing
operation. We also find that the frequently used non-system
actions are always provided by giant companies.
To make clear which functionalities are mostly used by develop-
ers,wepickthe 300mostusedtypesofactions (morethan80%of
count)declaredinthemanifestandmanuallyanalyzetheirfunc-
tionalities.Weget21categoriesintotalandtheresultsareshowninFigure7.ThecategoriesnotshownareShortcut,Pick,Stub,Camera,
Nfc,Push,Communication,Media,Launch,Hardware,Auth,Create,
ShareandInstall.Aswecansee, EA can support various func-
tionalities, in which display (61.22%) is the most commonlyusedfunctionality.
Oneinterestingfindingisthatactionsrelated
to SDK account for 2.90%, which are provided by big companieslikesina, taobao, and etc. By providing SDK to developers, these
companiescanprotectandmanagetheinvocationoftheirEAseas-
ily.Anotherobservationisthatthedebuggingandtestingrelated
EAs still exist in some released apps, which may bring potential
security issues and should not be exposed in the published version.
4.2 Comparative Analysis
Wenowgettwosmalldatasetsusingdifferentpickingcriteria,in
whichDatasetMDcontainsEAsthatbelongtowidelyusedapps
and DatasetAR contains EAsthat come fromapps with abnormal
ratio of EAs. Each dataset contains 50 apps, and we find that these
two datasets are disjoint.
Table 4: General Information of Datasets
App_Num App_Size EA_Num EA_Ratio
Dataset MD 50 1,332MB 598 8.1%
Dataset AR 50 1,522MB 5654 38.5%
Table4lists the general information about the two datasets. As
wecansee,thefirstdifferencebetweenthesetwosetsisthenumber
of EAs. While the size is similar, apps in Dataset AR have much
moreEAsthanthoseinDatasetMD.Thelastcolumngivestheratio
of EAs, which shows EAs in Dataset AR have a larger proportion.
WefurtherinvestigatehowdevelopersexposeanEAwithdiffer-
entexposuremodesandshowtheresultsinFigure 8.Theexposure
mode ‚ÄúExTrue‚Äù indicates the EAs whose attribute exported=true
areexplicitlydeclared,and‚ÄúNoEx‚ÄùindicatestheEAswithoutthatat-tribute. The ratio of activities declared with
exported=true varies
alotinthesetwodatasets,whichis50%onDatasetMDbutonly
15% on Dataset AR. It shows that the attribute exported, which
demonstratestheintentionofdevelopersexplicitly,ismore
696
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. Characterizing and Identifying Misexposed Activities in Android Applications ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
SysActData, 
18.1%NoEx,
50.0%ExTrue,
50.0%NonSysAct,
25.4%
SysActNoData, 
6.5%
Dataset MD: most downloads
SysActData, 
41.7%
NoEx,
85.0%NonSysAct,
33.5%ExTrue, 
15.0%
SysActNoData, 
9.8%
Dataset AR: abnormal ratio
Figure 8: Exposure Mode Comparison
oftenusedinwellprogrammedapps. ForEAsinmode‚ÄúNoEx‚Äù,
we further separate them into three types ‚ÄúSysActData‚Äù, ‚ÄúSysActN-
oData‚Äùand‚ÄúNonSysAct‚Äù,accordingtowhethertheycontainany
dataandnon-systemactionornot.Theresultsshowthat themode
‚ÄúSysActNoData‚Äùisrarelyusedinbothdatasets,whichmight
be an abnormal exposure mode.
4.3 Misexposure Patterns of EA
The results of the comparative analysis guide the misexposure
patternextraction.Besides,manualinspectiononthe100appsfrom
Dataset MD and AR as well as the Android reference also helps.
Wefindsixmisexposurepatternsandseparatethemaccordingto
whether developers know the exposing characteristic or not.
4.3.1 Developer-unanticipated Exposure. As the activity expos-
ing mode is flexible, the developers might not know that their
activities are exposed.
P1:AbnormallyHighPercentageofEA. 1) How to Extract:
Thecomparativeresultsintable 4showthatpoorlyprogrammed
appsmayhavehigherEApercentage,i.e.,declaremoremisexposed
EAs. By comparing the ratio of EAs in each app, we find that some
apps have extremely high EA numbers and ratios, whose function-
alities are usually not designed for external invocation. 2) Case
Study:The app Mobile collaboration , which exceeds millions of
downloads in the market, contains 59 activities and 58 of them
areEAs.ItsratioofEAsreaches98.3%,whiletheaveragevalueis
8.6%.Thisappisdesignedformobileteamworkcooperation,and
all functions must be accessed by users who have logged in. How-
ever, we observe that these EAs can be easily accessed through the
directexternalinvocationswithoutlogin,thatmayviolatethein-
tentionofdevelopers.Anotherexampleisthewell-knownapp Bing
Dictionary,whichhastotally63activitiesand38ofthemareEAs.
However, according to the name of these EAs and the judgment by
manual invocation, most of them seem to be part of the internal
functionalitiesinsteadofbeingspeciallydesignedforexternalin-
vocations. 3) How We Identify: This pattern can be identified by
EA ratio statistic.
P2:Copy-PastedEADeclaration. 1) How to Extract: When
developers want to declare an activity correctly, the most con-
venient way is to imitate the last declared one, i.e., declare by
copy-and-paste. By manual inspection on the manifest files of the
selectedappsinbothdatasets,wefindthatcopy-pastedEAdeclara-
tionswidely exist. 2) Case Study: We findanapp called ToolWiz
Photos, which has totally 197 activities and 128 of them are EAs.
Surprisingly, up to 124 EAs in this app are declared using mode<activity android:exported="true" android:name="com.toolwiz.
photo.community.UserInfoActivity" />
<activity android:exported="true" android:name="com.btows.
photo.editor.ui.SelectiveColorActivity"/>
Figure 9: Copy-Pasted EA Declaration
‚ÄúExTrue‚Äù. In Figure 9, we show some of them and get rid of all the
expose-irrelevantattributes.Ifwestartactivity UserInfoActivity
usingadb command1,the appwillcrash andthrowan exception,
which means that the developers do not expose it deliberately.
AndSelectiveColorActivity isusedforadjustingthetonefora
photo. External invocation is allowed to directly start it without a
targetimage,whichleadsthisactivitytobeinvalidandevencauses
a crash. 3) How We Identify: Misexposures in this pattern can be
found out by calculating the ratio of each mode (see Section 4.2)i n
one app.
P3: Inappropriate Action and Data. 1) How to Extract: Ac-
cordingtotheAndroidreferenceandmanualinspection,wefind
thatthe officiallyprovided systemactions (orcategories) arecom-
monlyused,whicharedifficulttobetakenastheidentifierofan
EA.Developersalwaysadddata,auriobjectthatassignsthedatato
be acted on, to limit the range of resolved activities. Therefore, the
EAdeclarationthatcontainsonlysystemactionswithoutdataitem
required is likely to be misused. 2) Case Study: To ease under-
standing,wediscussarealcasein UCMobile.AsshowninFigure 10,
it declares an EA with the most frequently used system action
android.intent.action.VIEW only. When an implicit call that
onlycontainsthissystemactionissent,dozensofEAsarematched
as candidates to be launched. 3) How We Identify: This pattern
can be identified by analyzing the intent-filers of each EA.
<activity android:name="com.ucweb.activity.LifeAssistantActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW"/>
<category android:name="android.intent.category.DEFAULT"/>
</intent-filter>
</activity>
Figure 10: Inappropriate Action and Data
P4:IncorrectCategorySetting. 1) How to Extract: Accord-
ing to the official reference, Android system will automatically
applythecategory android.intent.category.DEFAULT toallthe
implicit intents, so that an EA must include such category in its
intent filters. Otherwise, no implicit intents will resolve to this EA
with incomplete intent filters. However, they are still exposed in
force and can be invoked by explicit intents. 2) Case Study: As
shown in Figure 11, app Mozilla Browser declares such an EA that
contains an action only. This activity fails to be invoked implicitly,
however,itisexposedbydeclaringintent-filterandcanbeinvoked
explicitly. When this EA is invoked explicitly, a blank window will
show up and then disappear. Then the logcat will give the error
logandroid.view.WindowLeaked ,whichmeanstheactivityhasa
leakedwindow.Obviously,thisactivityisnotreadytobeexposedasan EA.
3) How We Identify: We identify this pattern by detecting
the existence of the default category.
1Considering that the lack of extra data will also cause app crash, all EAs we listed in
this section do not need to receive any extra data.
697
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Jiwei Yan, Xi Deng, Ping Wang, Tianyong Wu, Jun Yan, and Jian Zhang
<activity android:name="org.mozilla.gecko.sync.config.activities.
SelectEnginesActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN"/>
</intent-filter>
</activity>
Figure 11: Incorrect Category Setting
P5: Implicit internal Invocation .1) How to Extract: In the
light of the Android reference [ 10], activities declared with intent-
filterswillexposeanactivity.Developersshouldpreventotherapps
fromcallingoneactivitybynotsettingintentfiltersforit.However,
by our investigation, intent-filters are often used for implicit intra-
invocation due to its convenience, rather than external invocation.
The comparative results in the previous section also show that
widely used apps declare EA in ‚ÄúExTrue‚Äù more frequently. 2) Case
Study:The app ‚Äúdianping‚Äù contains 483 EAs and 481 of them are
in the mode ‚ÄúNoEx‚Äù. Some of them are used for implicit invocation
inferredbythenameoftheseactivities,e.g.,‚ÄúMyCardActivity‚Äùand
‚ÄúAtFriendActivity‚Äù. 3) How We Identify: We identify this pattern
bycomparingtheratioofeachexposuremodeandprovidewarning
information to developers.
4.3.2 Developer-anticipated Exposure. There are also some EAs
thatareexposedfortheconvenienceofdevelopmentandshould
be removed before application being released, otherwise they may
bring unpredictable threats.
P6:DebuggingFunctionality. 1) How to Extract: Inourman-
ual inspection, we find that some activities are designed and ex-
posed to ease the debugging, mainly according to their names.
These exposed debugging activities help to test the target activity
directly,andtheymaymanipulatethedatabaseandlacksecurity
protection,Forgettingtoremovetheminthereleaseversionsmight
beanissue. 2) Case Study: Forinstance,theinvokingoftheEA
DebugDomainSelectActivity in Figure 12launches an activity
that is used for domain testing. 3) How We Identify: By keyword
retrieving, we totally find 13 debugging activities in this app.
<activity android:name="com.dianping.debug.DebugDomainSelectActivity" >
<intent-filter>
<action android:name="com.dianping.action.VIEW"/>
<category android:name="android.intent.category.DEFAULT"/>
</intent-filter>
</activity>
Figure 12: Debugging Functionality
5 MISEXPOSURE CHARACTERIZATION AND
IDENTIFICATION
Through the investigation of collected datasets, we summarize a
seriesofrulestoidentifywhetheranEAismisexposedornot.First,
wegiveseveralfeaturesofactivityinTable 5,includinginforma-
tionabout EAdeclarationandinvocation aswellas theattributes
usedintheidentificationofthemisexposurepatterns.Eachfeature
correspondstoabooleanvariableandthesecondcolumndescribes
the condition to make it true.
Then we summarize the characteristics of misexposed activities
according to the patterns in Section 4.3, and give out the classifi-
cationrulesinTable 6.Asshowninthefirstcolumn,EAscanbeTable 5: Features of EA
Feature Description
exTrue declaresexported=true
ifTrue containsintent filter
noDefault omits the default category
sysActNoData declare only system action without data
priority contains priority setting of intent filter
permission contains permission setting of activity
clsDeclarewith classname that has been declared more than
three times in manifest
clsInvoke with classname that has been externally invoked
actInvokewith non-system action that has been externallyinvoked
similarbelongs to an app that declared EA with the similar
exposure mode shown in Figure 8, including ExTrue,
SysActData, SysActNoData and NonSysAct.
debug contains keywords ‚Äútest‚Äù, ‚Äúdebug‚Äù, etc.
highRatio belongs to an app that has high value of #EA/#A
Table 6: The Classification Conditions of EA
Class PrCondition
MustEA4clsInvoke oractInvoke
5clsDeclare
6priority orpermission
MayEA 9exTrue
MayIA7similar(P2)
8highRatio (P1)
10ifTrueand notexTrue(P5)
MustIA1sysActNoData andifTrueand notexTrue(P3)
2noDefault andifTrueand notexTrue(P4)
3debug(P6)
classifiedintofourclassesaccordingtothenecessityandreason-
ability of the exposure. All the rules can be categorized into two
types, i.e., ‚ÄúMust‚Äù and ‚ÄúMay‚Äù, in which the type ‚ÄúMay‚Äù containssome coarse-grained rules that can not tell which specific EA ismisexposed. For example, the rule
similarcan only figure out a
seriesofsimilarEAstobesuspicious.Thesecondcolumnshows
thepriority(Pr )ofrules,whichissetaccordingtoourexperience.
The last column describes the judgment conditions, which uses
single or the combination of features listed in Table 5. Because one
EAmaysatisfyseveralconditionsatthesametime,whenconditioncollisionoccurs,thefinalclassificationisdeterminedbythepriority
value. For example, the rule debugthat maps to class ‚ÄúMustIA‚Äù has
high priority; while another rule exTrue(mayEA) is more undeter-
mined. When both these conditions are satisfied by one EA, it will
be classified as ‚ÄúMustIA‚Äù at last.
Then we use a logic programming language prologto automati-
callyidentifythemisexposures,inwhichtheprogramlogicisex-
pressedintermsofrelations,representedas factsandrules[19,20].
A fact is composed of an attribute and its value, and a rule is in the
formofHead:-Body. ,inwhichthe Headistheconclusionandthe
Bodycontainsseveralfacts.IfthefactsinBodyaretrue, theHead
is true.
Figure13shows part of our implementation using prolog,i n
which the declaring order of rules decides the priority of matching.
We use features listed in Table 5as attributes of fact, whose values
canbeextractedthroughEAdeclarationandinvocationanalysis.
ForeachEA,wecangettotallytenfactstohelptheclassification.
AndwemakeuseofconditionsandtheirclassesinTable 6todefine
698
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. Characterizing and Identifying Misexposed Activities in Android Applications ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
ten rules, in which the IA classification conditions are linked to
misexposure patterns. For example, line 4-5 in Figure 13represent
a rule, which means if the fact clsDeclare(true) is satisfied, the
class of corresponding activity is ‚ÄúmustEA‚Äù. For other rules that
containseveralfacts,thesefactsarecombined,wherethecomma
indicates ‚Äúand‚Äù, and the semicolon indicates ‚Äúor‚Äù. For instance, the
lines 1-3 mean that if an EA satisfies (noDefault(true) and not
ifTrue(true) and not exTrue(true)) or (debug(true)) ,i t
belongs to class ‚ÄúmustIA‚Äù.
6 EVALUATION
We describe some experiments in this section. A tool called Mist
(MISexposure idenTification for Android) is designed and imple-
mented based on the extracted rules. For the coarse-grained rule
highRatio ,wefindouttheappsthathavemorethan50EAsanda
ratio of EAs larger than 0.4. For rule similar, we only detect apps
thathavemorethan30EAsandusethresholdsthatvaryfrom0.5to
0.7 for different exposure modes. Then we perform experiments on
a large-scale dataset and two small ones, which aims at answering
the following two research questions:
‚Ä¢RQ4(Usefulness): Towhatextentareourmisexposureiden-
tification results consistent with manual checking? Does the
identification help developers to reduce ICC attack threats?
‚Ä¢RQ5 (Result Distribution): What is the distribution of EAs
misexposed inreal-world Androidapps? Do theresults vary
in different datasets?
6.1 RQ4: Usefulness
We randomly select 50 apps and launch their EAs to verify the
identification consistency between Mistand manual checking. Be-
sidesMainActivity ,EAsthatneedtoreceive extra data arealso
excluded,sincetheuncertainlaunchingresultsinducedbydifferent
inputswillobstructthemanualjudgment.Totally,weobtain519
EAs from the selected apps.
Asweknow,therearenocommoncriteriatodeterminewhether
an activity should be exposed or not, and no existing benchmark is
provided for this task. Therefore, to get the correct classification
results for tool evaluation, we design the following regulations for
manual identification according to the launching result:
‚Ä¢TheactivityisanIAifithasdatadependencieswithother
unexecuted internal activities and thus provides incomplete
functionalities;showsabnormaldisplay(e.g.,blankwindow);
throws exceptions; or provides obviously internal function-
alities (e.g., debugging).
‚Ä¢The activity is anEA if it provides complete functionalities
for external apps.
ForeachoftheEAs,weautomaticallygeneratean adblaunching
command,suchas adb shell am start -n package/activity
activity(mustIA):-
noDefault(true), not(ifTrue(true)), not(exTrue(true)); debug(true);
activity(mustEA):-
clsDeclare(true).
Figure 13: Part of the Implementation Using Prolog-d data,accordingtotheEAdeclaration.Theoptions -a(foraction)
and-c(forcategory)arenotadoptedtoensureonlyonetargetwill
respond.WhenthetargetEAislaunched,theGUIinterfacesand
the exception information from logcat are considered in manual
annotation, but the code information is not provided.
Allthe519EAsarelabeledbythreeannotatorsasEAorIAin
aboutfivehours,whiletheautomaticidentificationby Mistonly
takes several seconds. We compare the results committed by all
annotators and find that they annotate same labels on 367 EAs.i.e., all of them label an activity as EA/IA, and the disagreementamong annotators is 29.7%. It is hard for annotators to infer the
intention of developers from the decompiled byte-code, thus, anno-
tatorsmayhavedisagreementonthesameactivity.Forexample,some EAs receive uri as the data item, which can be composed
as<scheme>://<host>:<port>/<path> .Itiseasytogeneratea
legal input but it may not make sense, which may cause invalidinvocation or blank window. The launching of these EAs is diffi-
cult to judge by annotators who are not the developers of the app
under test. Therefore, we perform a strict selection, i.e., we justconsidertheactivitiesthatareclassifiedintothesameclassesby
all annotators as the test oracle and drop the rest. The final results
showthat263(71.6%)EAsaresuccessfullyidentifiedasthesame
typebytheannotatorsandourtool.Theprecisionandrecallofthemisexposureidentificationare0.87and0.77,respectively.Forthoseinconsistent ones, the rules
exTrueandsimilar hit the most ones
(over 50% in total), which should be further studied and refined.
We also collect some apps that have been reported as victims
of ICC attacks. For example, Covert [ 6] is a popular permission
leakage detection tool, whose results are publicly available on web-site[
21].Therearetotallytenactivitiesthatarereportedasvictims
of the permission leakage by Covert, in which seven of them are
MainActivity . We identify the rest three activities using Mistand
findouttwoofthemseemtobemisexposed.Bymanualinspection,
these two activities (from two apps) are inferred to be misexposed
ones(sincetheyaredesignedforimplicitinvocationratherthanex-
ternal invocation), which indicates that the vulnerabilities of these
apps can be fixed by unexposing their activities.
6.2 RQ5: Result Distribution
We extract and collect features for all EAs in apps of the three
datasets, and make use of the rules written in Prologto classify
these EAs. Then we obtain the classification results and show their
statistics in Figure 14.
Aswecansee,inDatasetAL,thereare19.23%ofEAsthatare
classified as ‚ÄúmustIA‚Äù with high certainty. Overall, more than half
(55.73%)ofEAsaresuspectedtobeIAs,whoseexposuremaynotbe
suggested. Our further analysis shows that, in the 9361 apps which
MustEA, 24.24%
MayEA, 20.03% MayIA, 36.50%MustIA, 19.23%
Dataset AL
MustEA, 21.33%
MayEA, 33.83% MayIA, 33.00%MustIA, 11.83%
Dataset MD
MustEA, 16.02%
MayEA, 4.36% MayIA, 65.48%MustIA, 14.15%
Dataset AR
Figure 14: Identification Results on Three Datasets
699
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Jiwei Yan, Xi Deng, Ping Wang, Tianyong Wu, Jun Yan, and Jian Zhang
0.50%1.57%2.47%4.48%6.50%12.09%14.25%16.18%20.03%21.94%
3 debugQSJPSJUZl8 highRatio2 noDefaultDMT*OWPLFl7 similarTZT"DU/P%BUBl5 clsDeclare9 exTrueJG5SVFBOEl
Figure 15: Statistic Results of Each Rule
have at least one EA, 5339 (57.03%) of them are detected to have at
leastonemisexposedEA.Theseresultsindicatethat themisexpo-
sureofEAwidelyexistsinreal-worldapps . For the other two
datasets,thereare55.16%ofEAsseemtobecorrectlyexposedin
DatasetMD.AndfortheDatasetAR,only20.38%ofEAsseemto
be rightly exposed, which is consistent with our assumption.
Tohavesomeintuitiveunderstandingofourrules,wecountthe
hitting number of each rule on Dataset AL. As we can see from
Figure15, the rule ifTrue and not exTrue hits the most EAs.
These EAs are suspected to be IAs and should be checked by their
developers.Rule exTruealsoholdsforalargeproportion,which
shows that a number of developers show their exposing intention
explicitly. And about 16.18% of EAs satisfy the rule clsDeclare ,
which may be public activities provided as the SDK interfaces. For
otherrules,theyhitfewerEAsevensomeofthemhavehighpriority,
indicating that they are discriminative for identification.
7 THREATS TO VALIDITY
As with any system, Misthas its limitations, including the scale of
benchmarks,thesetting,andtheresearchscope.First,theidenti-
fication results are limited by the scale of our dataset, especially
when the rules that involve the number of invocations are used.
Besides,boththethresholdineachruleandthepriorityvalueto
combinetheserulesaresetmanually,whichmaylimittheaccuracy
of identification. These settings can be obtained by a combined
techniqueofprogramanalysisandmachinelearning.Finally,An-
droid apps are composed of four kinds of components, and onlythe most commonly used component
activity is studied in this
paper.Webelievethatthemisexposureofothercomponentshas
similar characteristics with activity and will investigate them in
our following studies.
8 RELATED WORK
ICCAttacksDetection. Currently,mostoftheexistingworkson
testingandanalysisofAndroidapps[ 22‚Äì27]targetattheintra-app
analysis.However,thedesignofICChasitslimitations,whichmay
causebugsorsecurityflaws.ArecentstudybyAhmadetal.[ 28]
discussed the challenges it brings to Android development. Chin et
al. [1] provide tool ComDroid to describe application communica-
tionvulnerabilitiescausedbythemisunderstandingoftheintent
passing system, e.g., unauthorized intent receipt and intent spoof-
ing.Theresearch[ 2]proposesaniterativetestgenerationapproach
todetecttheICCvulnerabilities(e.g.,XSS,SQLinjection,etc.)of
Androidapps.Ineachiteration,theyrecoveredthecustomfields
(variables)ofintentbyinstrumentingtheAPIsthatareusedtoread
such fields and monitoring the app execution. Bagheri et al. [ 6]
implement a tool Covert that can detect the permission leakagecaused by the lack of permission requirements of exposed compo-
nents.Theyfirstperformthestaticanalysistechniquestoobtain
the model of program behavior, and then use the alloy language
(an object modeling notation) to model the combination of apps,
and finally perform the formal analysis technique to verify themodel.Inadditiontoawidevarietyofapproachestoidentifying
vulnerabilities,anexploitgenerationtoolLetterBom[ 7]basedona
combinedpath-sensitivesymbolicexecution-basedstaticanalysisisprovided,whichcanbeusedtoreducethenumberoffalsepositives
invulnerabilitydetection.Inourwork,wepaymoreattentionto
another aspect, i.e., detect whether activities should be exposed or
not instead of detecting its vulnerabilities.
Intent Analysis. TheimplicitcontrolflowintroducedbyICC
mechanism makes the generation of precise call graph and control
flow graph, which are the essential parts of program analysis, very
difficult. In recent years, several researchers aim to expose suchimplicit transitions by intent analysis [
29‚Äì31], in which the tool
Epicc[29]isprovidedbyOcteauetal.forobtainingtheICCmethods
and their parameters. They also provided a tool IC3 [ 30] (Epicc
has now been replaced with IC3 [ 32]) which modeled the ICC
messages with proposed COAL language and implemented the
associatedsolverthatperformsastringanalysistofigureoutthe
ICC specification in Android apps. Based on Epicc and IC3, Li etal. [
4] developed IccTA, a static analysis tool for detecting inter-
componentprivacyleaksinAndroidapps.Thelinksbetweenthe
components are detected by the code instrumentation and static
analysis techniques. Besides the activity, Zhang et al. [ 33] focus on
servicetestingbyextractingservicerelatedintentsusingavariable
assignment analysis.
9 CONCLUSION
Inthispaper,weinvestigatetheexposingbehaviorofEAs,whichisrarelydiscussedinexistingworks.SinceEAsusuallycarrythefunc-
tionalities that are eagerly promoted by developers and vulnerable
to malicious ICC attacks, eliminating the unnecessarily exposed
EAsisasimplebuteffectivewaytoimprovethequalityofAndroid
apps.Therefore,thekeychallengeliesintheidentificationofthe
misexposure. With the help of the static analysis, we derive typical
misexposed activities from tens of thousands of real-world apps.
Byinvestigatingtheseactivities,wesummarizethespecificchar-
acteristicsofmisexposed EAsintotypicalmisuse patterns,which
in general are related to the misunderstanding and carelessness of
developers. We also design several heuristics for misexposed EAidentificationandimplementatoolcalled Mist.Theexperiments
on real-worldapps showthat itcan effectivelyhelp tolocate the
misexposed EAs, and the problem of the misexposure of activitiesis widespread and noteworthy.
Our tool can improve the quality and robustness of Android ap-
plications by detecting misexposures of activities. In the future, we
will improve the accuracy of our tool by using more concise static
analysis and employing machine learning techniques to obtain the
weights (including the thresholds and the priority) from a training
set with sufficiently labeled samples. We will also make further
studiesontheexploitationofthemisexposedactivitiesaswellas
howtore-implement theEAdeclarationsautomaticallytofixthe
misexposures .
700
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. Characterizing and Identifying Misexposed Activities in Android Applications ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
REFERENCES
[1]ErikaChin,AdriennePorterFelt,KateGreenwood,andDavidA.Wagner. An-
alyzinginter-applicationcommunicationinAndroid. In Proceedings of the 9th
International Conference on Mobile Systems, Applications, and Services (MobiSys
2011), pages 239‚Äì252, 2011.
[2]RoeeHay,OmerTripp,andMarcoPistoia. Dynamicdetectionofinter-application
communicationvulnerabilitiesinAndroid. In Proceedings of the 2015 International
Symposium on Software Testing and Analysis, pages 118‚Äì128, 2015.
[3]AdriennePorterFelt,ErikaChin,SteveHanna,DawnSong,andDavidA.Wagner.
Android permissions demystified. In Proceedings of the 18th ACM Conference on
Computer and Communications Security, CCS, pages 627‚Äì638, 2011.
[4]LiLi,AlexandreBartel,Tegawend√©F.Bissyand√©,JacquesKlein,YvesLeTraon,
StevenArzt,SiegfriedRasthofer,EricBodden,DamienOcteau,andPatrickMc-
Daniel. IccTA: Detecting inter-component privacy leaks in Android apps. In
Proceedings of the 37th IEEE/ACM International Conference on Software Engineer-
ing, pages 280‚Äì291, 2015.
[5]MichaelC.Grace,YajinZhou,ZhiWang,andXuxianJiang. Systematicdetection
ofcapabilityleaksinstockAndroidsmartphones. In 19th Annual Network and
Distributed System Security Symposium, NDSS, 2012.
[6]Hamid Bagheri, Alireza Sadeghi, Joshua Garcia, and Sam Malek. COVERT: com-
positionalanalysisofAndroidinter-apppermissionleakage. IEEE Transactions
on Software Engineering, 41(9):866‚Äì886, 2015.
[7]JoshuaGarcia,MahmoudHammad,NegarGhorbani, andSamMalek. Automatic
generation of inter-component communication exploits for Android applica-
tions. In Proceedings of the 2017 11th Joint Meeting on Foundations of Software
Engineering, ESEC/FSE, pages 661‚Äì671, 2017.
[8]Jun Ma, Shaocong Liu, Yanyan Jiang, Xianping Tao, Chang Xu, and Jian Lu.
Lesdroid-at o o lf o rdetecting exported service leaks of Android applications.
The preprint is available at website http://moon.nju.edu.cn/people/junma/static/
files/LesDroid(pre-print).pdf , 2018.
[9]Fengguo Wei, Sankardas Roy, Xinming Ou, and Robby. Amandroid: A precise
and general inter-component data flow analysis framework for security vetting
ofAndroidapps. In Proceedings of the 2014 ACM SIGSAC Conference on Computer
and Communications Security, pages 1329‚Äì1341, 2014.
[10]activity|Android Developers. https://developer.android.com/guide/topics/
manifest/activity-element.html, 2017.
[11] Intents and Intent Filters |Android Developers. https://developer.android.com/
guide/components/intents-filters.html , 2017.
[12]intentfilter|AndroidDevelopers. https://developer.android.com/guide/topics/
manifest/intent-filter-element.html, 2017.
[13]OnlineAPKDownloader |DownloadAPKDirectlyFromGooglePlayToYour
Computer. http://apkleecher.com/, 2017.
[14]Open SDK. https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&
t=resource/res_list&verify=1&id=1417751808&token=&lang=en_US, 2017.
[15] Soot. http://www.bodden.de/2008/09/22/soot-intra, 2017.
[16]Reaching definition |Wikipedia. https://en.wikipedia.org/wiki/Reaching_
definition, 2017.
[17]Use-definechain-Wikipedia. https://en.wikipedia.org/wiki/Use-define_chain,
2017.
[18]Markus M. Breunig, Hans-Peter Kriegel, Raymond T. Ng, and J√∂rg Sander. LOF:
identifying density-based local outliers. In Proceedings of the 2000 ACM SIGMODInternational Conference on Management of Data, pages 93‚Äì104, 2000.
[19]WilliamFClocksinandChristopherSMellish. Programming in PROLOG.Springer
Science & Business Media, 2003.
[20]DennisMerritt. Building expert systems in Prolog. SpringerScience&Business
Media, 2012.
[21] covert. http://www.ics.uci.edu/~seal/projects/covert/index.html.
[22]Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bodden, Alexandre Bartel,
Jacques Klein, Yves Le Traon, Damien Octeau, and Patrick McDaniel. Flowdroid:
precise context, flow, field, object-sensitive and lifecycle-aware taint analysis for
Android apps. In Proceedings of the 2014 ACM SIGPLAN Conference on Program-
ming Language Design and Implementation, pages 29:1‚Äì29:11, 2014.
[23]Michael I. Gordon, Deokhwan Kim, Jeff H. Perkins, Limei Gilham, Nguyen
Nguyen, and Martin C. Rinard. Information flow analysis of Android appli-cations in droidsafe. In 22nd Annual Network and Distributed System Security
Symposium, 2015.
[24]Wei Huang, Yao Dong, Ana Milanova, and Julian Dolby. Scalable and precise
taint analysis for Android. In Proceedings of the 2015 International Symposium on
Software Testing and Analysis, pages 106‚Äì117, 2015.
[25]VitaliiAvdiienko,KonstantinKuznetsov,AlessandraGorla,AndreasZeller,Steven
Arzt,SiegfriedRasthofer,andEricBodden. Miningappsforabnormalusageof
sensitivedata. In Proceedings of the 37th IEEE/ACM International Conference on
Software Engineering, pages 426‚Äì436, 2015.
[26]SongyangWu,PanWang,XunLi,andYongZhang.EffectivedetectionofAndroid
malwarebasedontheusageofdataflowAPIsandmachinelearning. Information
& Software Technology, 75:17‚Äì25, 2016.
[27]Wei Yang, Xusheng Xiao, Benjamin Andow, Sihan Li, Tao Xie, and William Enck.
Appcontext:Differentiatingmaliciousandbenignmobileappbehaviorsusing
context. In 37th IEEE/ACM International Conference on Software Engineering ,
pages 303‚Äì313, 2015.
[28]Waqar Ahmad, Christian K√§stner, Joshua Sunshine, and Jonathan Aldrich. Inter-
app communication in Android: developer challenges. In Proceedings of the
13th International Conference on Mining Software Repositories, MSR 2016,pages
177‚Äì188, 2016.
[29]DamienOcteau,PatrickD.McDaniel,SomeshJha,AlexandreBartel,EricBodden,
Jacques Klein, and Yves Le Traon. Effective inter-component communication
mapping in Android: An essential step towards holistic security analysis. In
Proceedings of the 22th USENIX Security Symposium, pages 543‚Äì558, 2013.
[30]Damien Octeau, Daniel Luchaup, Matthew Dering, Somesh Jha, and PatrickMcDaniel. Composite Constant Propagation: Application to Android Inter-Component Communication Analysis. In Proceedings of the 37th International
Conference on Software Engineering, pages 77‚Äì88, 2015.
[31]Li Li, Alexandre Bartel, Tegawend√© F. Bissyand√©, Jacques Klein, and Yves Le
Traon. Apkcombiner: Combining multiple Android apps to support inter-app
analysis. In Proceedings of 30th International Conference on ICT Systems Security
and Privacy Protection, pages 513‚Äì527, 2015.
[32] Epicc. http://siis.cse.psu.edu/epicc/.
[33]LiLynaZhang,Chieh-JanMikeLiang,YunxinLiu,andEnhongChen. System-
aticallytestingbackgroundservicesofmobileapps. In Proceedings of the 32nd
IEEE/ACM International Conference on Automated Software Engineering, ASE,
pages 4‚Äì15, 2017.
701
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:48:24 UTC from IEEE Xplore.  Restrictions apply. 