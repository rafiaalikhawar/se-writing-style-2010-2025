Defaultiﬁcation Refactoring: A Tool for
Automatically Converting Java Methods to Default
Rafﬁ Khatchadourian
City University of New York, USA
rafﬁ.khatchadourian@hunter.cuny.eduHidehiko Masuhara
Tokyo Institute of Technology, Japan
masuhara@acm.org
Abstract —Enabling interfaces to declare (instance) method
implementations, Java 8 default methods can be used as a
substitute for the ubiquitous skeletal implementation software de-
sign pattern. Performing this transformation on legacy software
manually, though, may be non-trivial. The refactoring requiresanalyzing complex type hierarchies, resolving multiple implemen-
tation inheritance issues, reconciling differences between class
and interface methods, and analyzing tie-breakers (dispatchprecedence) with overriding class methods. All of this is necessary
to preserve type-correctness and conﬁrm semantics preservation.
We demonstrate an automated refactoring tool called M
IGRATE
SKELETAL IMPLEMENTATION TO INTERFACE for transforming
legacy Java code to use the new default construct. The tool,implemented as an Eclipse plug-in, is driven by an efﬁcient,
fully-automated, type constraint-based refactoring approach. It
features an extensive rule set covering various corner-caseswhere default methods cannot be used. The resulting code is
semantically equivalent to the original, more succinct, easier to
comprehend, less complex, and exhibits increased modularity. Ademonstration can be found at http://youtu.be/YZHIy0yePh8.
Index T erms—refactoring, java, interfaces, default methods,
type constraints, eclipse
I. I NTRODUCTION
Java 8 enhanced interfaces enable developers to write
default (instance) methods that include an implementation
that implementers will inherit if one is not provided [1].
Although originally intended to facilitate the addition of newfunctionality to existing interfaces without breaking clients [2],default methods can also be used [3] to substitute the skeletal
implementation pattern [4, Item 18], which is ubiquitous in
many software projects [5]. The pattern involves creating an
abstract skeletal implementation class that implementers canextend. This class provides a partial interface implementationand thus results in an interface that is easier to implement.
Advantages in migrating legacy code from using the skeletal
implementation pattern to default methods include foregoing
the need for subclassing, having classes inherit behavior (butnot state) from multiple interfaces [3], and facilitating local
reasoning [6]. Although advantageous, such a migration re-quires signiﬁcant manual effort, particularly in large projects,as there are subtle language and semantic restrictions that mustbe considered. One such restriction is that interfaces cannotdeclare instance ﬁelds. The migration requires preserving type-correctness by analyzing complex type hierarchies, resolving
issues arising from multiple (implementation) inheritance,reconciling differences between class and interface methods,and ensuring tie-breakers with overriding class methods, i.e.,
rules governing dispatch precedence between class and defaultmethods with the same signature, preserve semantics.
We demonstrate an automated refactoring tool named M
I-
GRATE SKELETAL IMPLEMENTATION TO INTERFACE for
transforming legacy Java code to use default methods. The toolassists developers in taking advantage of enhanced interfacesin an efﬁcient, fully-automated, and semantics-preserving fash-ion. The approach is based on type constraints [7,8] and workson large-scale projects with minimal intervention. Featuring anextensive rule set that covers diverse corner-cases where de-fault methods are prohibited, the approach identiﬁes instancesof the skeletal implementation pattern and safely migratesmethods to corresponding interfaces as default methods.
The related P
ULL UPMETHOD refactoring tool [8,9] ma-
nipulates a type hierarchy by safely moving methods froma subclass up into a super class so that all subclasses mayinherit from it. This refactoring is fundamentally differentfrom migrating method deﬁnitions from skeletal implemen-tations to interfaces as default methods in terms of its goalsand the targeted design pattern. Namely, its sole goal isto reduce redundant code, whereas ours includes openingclasses to inheritance, allowing classes to inherit multipleinterface deﬁnitions, etc. Moreover, while the two refactoringsshare some preconditions, i.e., conditions that must be met toguarantee refactoring correctness, in terms of type constraintsviolations, our approach deals with multiple inheritance, amore complicated type hierarchy involving interfaces sinceclasses may implement multiple interfaces while extending aclass, semantic differences due to class tie-breaking, furtherconstraints on interfaces as they cannot declare ﬁelds, anddifferences between class method headers and correspondinginterface method declarations. Lastly, while methods to bepulled up typically are declared in a common class, in our case,default methods may be migrated from multiple classes intoa single interface, pressing the need for a more widespread,batch processing approach across classes and packages.
Our refactoring tool (available at http://git.io/v2nX0) is
implemented as an open source Eclipse (http://eclipse.org)plug-in built atop of the Java Development Tools (JDT)(http://eclipse.org/jdt) refactoring infrastructure [10]. Our toolcan process projects in batch, mining for occurrences ofthe skeletal implementation pattern than can be converted to
978-1-5386-2684-9/17/$31.00 c/circlecopyrt2017 IEEEASE 2017, Urbana-Champaign, IL, USA
T ool Demonstrations984
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:31:33 UTC from IEEE Xplore.  Restrictions apply. default methods. A refactoring preview pane is provided, along
with detailed information of code that fails preconditions.
For the tool evaluation, an extensive refactoring test suite
was created, featuring 259 refactoring regression tests, trig-gered via continuous integration. Each tests veriﬁes that (i)both the input and output code versions compile successfullyand (ii) the actual refactored version matches that of theexpected refactored version given the initial version of theinput source code. The usefulness of the tool was assess via theanalysis of 19 Java projects of varying size and domain with atotal of∼2.7 million lines of code. Additionally, pull requests
(patches) of the refactoring results were submitted to popular
GitHub (http://github.com) repositories as a preliminary study.
The details of the underlying approach, as well as thorough
experimental results, can be found in our previous work [5].
Beyond [5], we make the following speciﬁc contributions:
Implementation details A thorough treatment of the novel
aspects of the tool implementation is presented in detail. This
includes the tool’s architecture, API usage, data representa-tions, algorithms, and implementation issues and limitations.Furthermore, the tool’s relationship to the P
ULL UPMEMBER
refactoring implementation is thoroughly explored.
User perspective A broad overview of how our tool is used
to perform large-scale refactorings is given. This includes
screenshots of the tool’s usage and a video demonstration.
Our hope is to receive valuable feedback on the improvementof the user interface, as well as promote its usage.
II. E
NVISIONED USERS
The users we envision our tool attracting are especially those
who are tasked with maintaining and/or improving legacy(currently) Java systems. Our tool is most advantageous insituations where legacy systems are using Java 8 and areactively maintained. In this way, using our tool on thesesystems would result in code that is more succinct and easierto maintain, e.g., skeletal implementation classes may be
eliminated, as will be discussed in the following sections.
Since our tool takes advantage of the built-in, user-friendly
Eclipse refactoring infrastructure, developers with even little
refactoring experience may use our tool. Users may be thosethat are tasked with refactoring an entire project or writingnew code in only portions of a large system. Since our tool
will identify possible instances of the skeletal implementation
pattern and that the resulting program will be semanticallyequivalent to the original, users do not necessarily have topossess a thorough knowledge of the pattern.
III. S
OFTWARE ENGINEERING CHALLENGES
In this section, we discuss the Software Engineering chal-
lenges our tool is made to address. Fig. 1 portrays a screenshotof the refactoring preview pane that a user is presented withprior to executing the refactoring on a simpliﬁed example.In order for such a pane to be displayed, the user (devel-
oper) selects Java elements of the Eclipse IDE, e.g., thepackage explorer. M
IGRATE SKELETAL IMPLEMENTATION
TOINTERFACE supports a wide range of element granularity,from (multiple) methods up to (multiple) projects within an
Eclipse workspace. For example, if the user context-clicks(right-clicks) a Java class in the Eclipse UI and selects ourrefactoring option, the tool will traverse the entire class forinstance method deﬁnitions (implementations) that implementan interface method in an interface explicitly speciﬁed as beingimplemented by either the enclosing class or one of its parents.
Background and Motivation. Fig. 1 consists of two panes,
namely, the “Original Source” and the “Refactored Source,”with the former being in input to the tool and the latter theproposed output. Users may select “Finish” if they agree with
the refactoring, and may revise the input parameters (e.g., ﬁles)by unchecking them from the top section. In the each pane,
there are two types, namely, interface
Iand an abstract class
C. On the left, Ideclares a simple, single abstract method
m()(line 4). Class Cimplements Iand thus provides a basic
implementation of m(). Since it is not meant to be directly
instantiated but rather to be used as a skeletal implementation
ofI,Ci is declared as abstract. Instead of implementing I
directly, prospective implementers can subclass Cand thereby
inherit “default” implementations of some or all of the in-terface methods. Often times, such skeletal implementationsprovide “default” method implementations that clients caninherit from rather than providing their own if the implemen-tation is applicable to them. Other times, such abstract skeletalimplementers provide complete implementations comprised ofmore primitive interface methods that subclasses override.
Although useful, there are several drawbacks to the skeletal
implementation pattern, especially w.r.t. inheritance, modular-
ity, and bloat [5]. Classes extending
C, for example, to beneﬁt
from the provided skeletal implementations will not be able to
extend other classes. This could be problematic in situationswhere classes implement multiple interfaces with each one
have its own corresponding skeletal implementer. Moreover,there is no syntactic path between an interface and a skeletalimplementer; clients looking to take advantage of a skeletalimplementation must rely on either a global project analysisand/or documentation. Lastly, skeletal implementers requirean additional, separate type, which could make already highlycomplicated libraries more complicated.
Many of the aforementioned problems can be solved with
default methods that are part of the enhanced interface
feature of Java 8 [11, Ch. 9]. The right pane of Fig. 1 portraysthe refactored version of the left with
m()removed from class
Cand its body appended in the formerly abstract method m()
in interface I. Furthermore, in I,m()is now preﬁxed with the
default keyword. After the refactoring, class Cis now empty;
whether it can be completely removed is explored below.
Now, implementers of Ican simultaneously beneﬁt from
the default implementation of m() and extend a different
class. Implementers also do not need to discover skeletalimplementers of
Ias default implementations are coupled with
the interface method declaration. Lastly, a new type is notneeded to represent the default method.
Although Fig. 1 portrays a scenario where the refactoring
succeeds, cases exist where executing the refactoring would
985
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:31:33 UTC from IEEE Xplore.  Restrictions apply. Fig. 1: Screenshot of the refactoring preview pane for the M IGRATE SKELETAL IMPLEMENTATION TO INTERFACE refactoring.
produce either type-incorrect or semantically-inequivalent re-
sults. For example, consider the following snippet:
interface I {void m();}
interface J {default void m() {/ *... */}}
abstract class C implements I,J {void m() {/ *...*/}}
Here, migrating method C.m() to interface Ias a default
method would cause a compilation error due to class Cnow
inheriting ambiguous method deﬁnitions of method m().
Default methods have many advantageous over the skeletal
implementation pattern, however, there are some potential
trade-offs. For example, placing implementations directly ininterfaces can violate some of the fundamental beneﬁts ofinterfaces acting as abstract data types (ADTs), where imple-mentation details should not be included. Particular to defaultmethods in Java, there has been some reported performancedegradation in certain cases when using default methods [12].However, this has been seen as a temporary JDK/JRE problem
that affects only a small number of cases [13].
Analysis Challenges. Although Fig. 1 is a simple example,
there are many other situations where determining whether it
is safe to convert a method to default may not be obvious:
•A particular skeletal implementer may provide a singleskeletal implementation for multiple interfaces, complicating
the processes of determining the target interface of where
the source class method shall be migrated to as a default
method. Our current implementation rejects input methods
with ambiguous target interfaces.
•A given interface may have multiple skeletal implementers;
which of these should be migrated to the interface as
a default method? Our current implementation performsequivalence set merging to ﬁnd the largest set of equivalent
source methods for migration and fails the others.
•A skeletal implementer may declare instance ﬁelds that areused in the source method. Since instance ﬁelds cannot be
declared interfaces, is it possible to convert such methods todefault? Our current implementation does not allow methods
directly accessing ﬁelds to be refactored, but if the developeris willing to make accessors and mutators part of theinterface, they are free to perform the E
NCAPSULATE FIELD
and E XTRACT INTERFACE refactorings prior to ours.
•Lambda expressions require interfaces with a single abstract
method. Converting a method to default may invalidate this
requirement. Our approaches rejects methods that are partof functional interfaces used in lambda expressions.
•In cases where a class inherits the same method from both a
class and an interface where the interface method is default,the interface method will “lose a tie” to the class. Assuch, we must ensure that the dispatch semantics remainintact after the refactoring. Otherwise, calls to the sourcemethod will not dispatch to the target in the refactoredversion but rather a method in a different class. Our currentimplementation rejects methods in this situation.
Other issues include those related to empty skeletal im-
plementers, i.e., cases where all source methods have beenmigrated to their targets. After the refactoring, further analysisis required to safely remove them. For example, the class maynot be able to be removed if it is instantiated somewhere in thecode base. Other references of the class could arise w.r.t. in-heritance. Due to the pattern structure, it is likely that theskeletal implementer is being extended. Naturally, we wouldreplace the extension of subclasses with the implementation of
the destination interface, i.e., the interface for which the target
method was migrated. However, the subclass classes may have
its own subclasses with references to
super that used to refer
to the super class of the (now empty) skeletal implementer.If the replacement is performed, those references would nowrefer to the interface rather than the super class.
Implementation Challenges. While [5] handles many of the
above issues, implementation-speciﬁc challenges include:
Architecture What is the best way to organize such a refac-
toring tool? As a research prototype, how can the tool simul-
taneously help real developers while being easily evaluated?
Reuse Given that the refactoring problem shares similarity
with the P
ULL UPMETHOD refactoring, how can we best
leverage existing code from that plug-in here?
986
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:31:33 UTC from IEEE Xplore.  Restrictions apply. Fig. 2: High-level system workﬂow.
Applicability Do the various assumptions made in the ap-
proach scale to real-world software refactoring?
Validation Given the signiﬁcant number of “corner-cases”
involved in this refactoring, how can we ensure to developers
that the resulting refactoring code will be type-correct andsemantically equivalent to the original?
Usability Challenges. There are also challenges speciﬁc
to developer adoption. A refactoring that makes such largescale and broad changes may not be immediately appealing todevelopers of mature and highly utilized projects due to risk.As such, our tool needs to address this by incorporating UIfeatures to reduce risk in certain cases. These features wereessential in the tool’s evaluation via a pull request study [5].Such challenges are addressed in the next section.
IV . I
MPLEMENTATION
The M IGRATE SKELETAL IMPLEMENTATION TO
INTERFACE refactoring is implemented as an open source
plug-in for the Eclipse IDE (available at http://git.io/v2nX0).Eclipse has been chosen for its existing, well-documented,and well-integrated refactoring framework [10]. Ourtool has been built atop of this framework and utilizesmany of its features, including source code analysis
and transformation APIs (e.g.,
ASTRewrite ), refactoring
preview pane (as shown in Fig. 1), precondition
checking (e.g., Refactoring.checkInitialConditions() ,
Refactoring.checkFinalPreconditions() ), and refactoring
testing (e.g., RefactoringTest ). ITypeHierarchy ,
which facilitates efﬁcient traversals of a type
hierarchy in Eclipse, is used extensively in checkingrefactoring preconditions. Furthermore, Eclipse is
completely open source for all Java development (seehttp://jetbrains.com/idea/#chooseYourEdition) thus possiblyimpacting more Java developers. Eclipse ASTs with sourcesymbol bindings are used as an intermediate representation.
Workﬂow. Fig. 2 depicts the high-level workﬂow for our
plug-in. The input to our tool is source code at various levelsof granularity (step 1). At the smallest level, the developermay select a single method, or set thereof, for migration. Atthe highest level, the plug-in works on (multiple) projects. Inthis case, the tool will search through each project for methodimplementations to be used as input to the refactoring.
Fig. 3: Architecture and plug-in dependency diagram.
Next, the developer is presented with options regarding the
invasiveness of the refactoring (step 2, discussed later). Thetool proceeds to perform simple checks on the input methods,e.g., whether the input method is contained in a writable ﬁle, instep 3. Traditionally, these basic checks can be repeated, withthe developer possibly selecting different elements to be usedas input to the refactoring. However, our tool slightly breaksfrom this traditional behavior by simply ﬁltering out methoddeﬁnitions that fail the checks using a non-fatal error. In thisway, developers are free to execute the refactoring again withany modiﬁcations they have made to their project(s).
The bulk of the computationally intensive precondition
checking occurs in step 4. Both fatal and non-fatal errors
are reported to the user in step 5. An example of a fatal
error is that no input methods have passed preconditions, assuch, no refactoring can take place. Conversely, an exampleof a non-fatal error is where migrating a method would alterprogram semantics and at least other one method has passed.
If no fatal errors are present, the tool provides the developer
with a preview of the proposed changes (step 7) and performsthe transformation (step 8) upon the developer’s conﬁrmation.Our tool supports undo capabilities in the case the developerchanges their mind after executing the transformation.
Architecture and Dependencies. Fig. 3 portrays the overall
plug-in architecture and dependency overview of our refactor-
ing tool. It consists of four plugins that are organized into two
categories, i.e., internal plug-ins (those not directly interactingwith the developer) and user-facing plug-ins (those directlyinteracting with the developer and utilizing a UI). As shown inFig. 3, the core and testplug-ins are not accessible outside of
the development environment, while UIand eval are invoked
via the Eclipse interface. Splitting the UI into two plug-ins, i.e.,the UI plug-in for normal usage and eval plug-in for evaluatingthe research aspect of the tool, is, we believe, a novel conceptin source code analysis and transformation research prototypedesign. In this way, the deployment artifact of the plug-in does not include the evaluation portion (i.e., buttons to
generate experimental data ﬁles) of the tool, nevertheless,both the evaluation and user plug-ins are available to the
987
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:31:33 UTC from IEEE Xplore.  Restrictions apply. researchers. Doing so makes the plug-in particularly useful
for both tasks. On the other hand, the testplug-in is not part
of the deployable artifact. The foundational Eclipse plug-insand their dependencies are also depicted in Fig. 3.
Relationship to Other Refactoring Plug-ins. The plug-in
menu options are coupled with other reorganization refac-
toring support in Eclipse. Although our approach is type
constraint-based (see [5]), similar to the current Eclipse P
ULL
UPMETHOD refactoring, our implementation is completely
separate from the type constraints generated by the JDT. In
other words, type constraints serve as a conceptual basis.
Some of our implementation leverages and adapts code from
the current Eclipse P ULL UPMETHOD refactoring, especially
those related to determining if a code entity is accessiblefrom another type. However, several important changes werenecessary to achieve the integration. For example, the current
P
ULL UPMETHOD refactoring is not well-suited for batch
processing as its pulled up members must originate fromthe same declaring type. Since Java 8 default methods area new feature that developers may want to adopt to entireprojects, we felt the need to modify the existing code toprocess on the project-level for this particular refactoring. Assuch, our plug-in accepts both ﬁne-grained (e.g., individualmethods) and course-grain (e.g., multiple projects) inputs.Other modiﬁcations included considerations related to modernJava features such as generics and lambda expressions.
T echnical Details. Although a thorough treatment of techni-
cal details can be found in [5], here, we discuss several aspectsof how our implementation realizes the concepts set-forth bytype constraints. As mentioned earlier, we make extensive use
of
ITypeHierarchy to traverse the input methods’ relationships
to other types in the project. The goal is to check of particular
type constraints would be violated as a result of the refactoring.
To demonstrate the imperative-style code that realizes the
more declarative-style type constraints, consider the constraintfor method invocation. This constraint applies to any pro-
gram construct in the form of E.m (E
1,...,E n)to a virtual
method Mwhere Eis an expression. Such a construct may
appear within an input method body being refactored to a
default method. The constraint’s purpose is to preserve type-correctness when the method invocation is moved to theinterface. In short, we must ensure that there is a corresponding
method in the type hierarchy of the destination interface when
E=
this as the type of this will change after the refactoring.
One of the corresponding type constraints for method
calls is [E]≤Decl (M1)∨···∨[ E]≤Decl (Mk)where
RootDefs (M)={M 1,...,M k}, meaning that the type of
Emust be a (sub)type of the type declaring one of the
called method’s root deﬁnitions. Informally, root deﬁnitionsare the top-most types in a type hierarchy declaring a method.Preserving the validity of this constraint guarantees that thereis a corresponding method in the destination interface.
In our implementation, we use
ITypeHierarchy to
check that the called method exists in the destina-
tion interface’s “super type” hierarchy via a call to
IType.newSupertypeHierarchy() . A super type hierarchy isone containing the type in question and all of its super types.
The checking is achieved via the following code snippet; fullsource can be found in our open source repository:
mInHier = isInHier(calledMeth, destInterSuperHier);
boolean isMethInHier(IMethod m, ITypeHierarchy h) {
return Stream.of(h.getAllTypes()).anyMatch(t -> {
IMethod[] meths = t.findMethods(m);return meth != null && meths.length > 0;});}
Real-world Applicability. To increase real-world applicabil-
ity, we relaxed a closed-world assumption utilized by our ap-
proach as detailed in [5]. A closed-world assumption is usefulfor the conceptual basis of automated refactoring approachesas it allows the algorithm designer to assume that all codethat could ever be affected by the refactoring be present at thetime of its execution. While useful in algorithm formulation,it is typical for (i) source code of libraries, frameworks, andremote (e.g., web-based) services not to be present as input tothe tool, and (ii) clients depending (or will be depending in the
future) on the refactored software to not even be associated
with the input project let alone present.
Thus, to make our approach applicable to real-world sce-
narios, we relaxed the above described assumption on several
fronts. For example, if an input method’s destination interface
is outside of the considered source code, it is conservativelylabeled as non-migratable (i.e., failed precondition).
Usability and Managing Risk. We also offer the developer
several options to the refactoring for reducing client impactexist. For instance, we allow the developer to choose whetherempty skeletal implementation classes should be removed.For those not removed, we offer the option to deprecated sothat clients can plan for their future removal. Furthermore, ifsuch classes extend a super class not implementing all of theimplemented interfaces, regardless of client code, the class isnot removed and references not replaced with the super type.We additionally require no mismatches involving exceptionthrows clauses and return types between source and targetmethods. Lastly, an option to not consider non-standard (out-side
java.lang ) annotation differences is available, which may
be useful in projects not using such processing frameworks.
Developers have several other options, including whether
to include only abstract classes as input, which increases thelikelihood classes that truly are skeletal implementers.
V. E
V ALUATION
Our tool successfully converted ∼20% of methods possibly
participating in the skeletal implementation pattern to inter-faces as default methods [5] in 19 real-world, open sourceprojects of varying size and domain with a total of ∼2.7
million lines of code. Our approach is extremely conservative,and thus 20% is respectable considering that the approachis fully automated. Moreover, many of the changes madeby the tool are widespread, and developers do not needto carefully analyze large and complex code bases to take
advantage of default methods for their legacy code. Many
of the precondition failures were related to inaccessibilityof members between skeletal implementers and destinationinterfaces and access to instance ﬁelds.
988
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:31:33 UTC from IEEE Xplore.  Restrictions apply. The correctness of the refactoring approach was validated
in several ways. First, we ensured that no compilation errors
existed before and after the refactoring. Furthermore, weveriﬁed that all unit tests results were identical before andafter the refactoring. A preliminary pull request study wasalso performed to ensure that the musically produced resultsmatched what experienced developers may have written. Fourprojects accepted our pull requests, and the tool’s results wereintegrated into the projects. This indicates that it is useful.
To validate our implementation, our plug-in features an
extensive refactoring test suite with over 200 refactoring tests.
Such tests consist of “before” and “after” ﬁles. The “before”ﬁle is used as input to the tool and the output is matchedagainst the “after” ﬁle. The signiﬁcant number of test casesexercises many corner-cases that appear in the refactoring.
VI. R
ELATED WORK
Current Eclipse refactorings do not have the capability to
deal with default method conversions. In fact, when attempt-ing to “pull up” a method from a class to an interface,Eclipse states that the method already exists in the destinationinterface. Moreover, as previously discussed, the P
ULL UP
METHOD refactoring is not typically widely applicable; it
normally applies to a single class. This is because issuingthis refactoring on a broad scale has potentially disruptiveand widespread results. In contrast, our refactoring has moreof a subtle effect and can be issued throughout the project.Nevertheless, it may be possible to combine our refactoringwith P
ULL UPMETHOD depending on the target.
Another important difference between our tool and P ULL
UPMETHOD is related to a “stubbing” behavior. For example,
in P ULL UPMETHOD , if an instance method call in the
source method exists, that method may be available in thetarget type. If it is not, an abstract method (stub) can becreated in the target type to compensate. However, in ourcase, there may be no relationship between the called instance
method and the destination interface. For example, if the called
instance method is in the skeletal implementer, then, there isa relationship. However, the called method may be inheritedfrom another class that does not implement the interface.
Other refactorings [8,14,15] reorganize type hierarchies,
though not for default methods. [16] and [17] transform Java
programs to use lambda expressions and enumerated types,respectively, while [18] demacroﬁes C++11 programs.
VII. C
ONCLUSION &F UTURE WORK
A refactoring tool that incorporates an efﬁcient, fully-
automated, type constraint-based, semantics-preserving ap-proach that migrates the skeletal implementation pattern in
legacy Java code to instead use default methods has beendemonstrated. The tool is implemented as an Eclipse IDEplug-in and was evaluated using several techniques.
In the future, we plan to compensate for situations where
source methods directly accessing ﬁelds or methods outside
destination interfaces. Since interfaces cannot declare instanceﬁelds, ﬁelds may be encapsulated in the skeletal implementersand corresponding methods declared in the destination inter-
face. A similar methodology could be employed for missingaccessed methods, and missing static ﬁelds could be directlymoved. However, all peer implementers must supply imple-mentations. We also plan to improve refactoring speed [19].
R
EFERENCES
[1] Oracle Corporation, “Java Programming Language Enhance-
ments.” [Online]. Available: http://docs.oracle.com/javase/8/
docs/technotes/guides/language/enhancements.html
[2] ——, “Default methods,” 2016. [Online]. Available: http:
//docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html
[3] B. Goetz, “Interface evolution via virtual extensions
methods,” Oracle Corporation, Tech. Rep., Jun. 2011.[Online]. Available: http://cr.openjdk.java.net/~briangoetz/lambda/Defender%20Methods%20v4.pdf
[4] J. Bloch, Effective Java, 2nd ed. Addison Wesley, 2008.
[5] R. Khatchadourian and H. Masuhara, “Automated refactoring
of legacy Java software to default methods,” in International
Conference on Software Engineering, 2017.
[6] R. Khatchadourian, O. Moore, and H. Masuhara, “Towards
improving interface modularity in legacy java software throughautomated refactoring,” in International Conference on Modu-
larity Companion, 2016.
[7] J. Palsberg and M. I. Schwartzbach, Object-oriented type sys-
tems. John Wiley and Sons Ltd., 1994.
[8] F. Tip, R. M. Fuhrer, A. Kie ˙zun, M. D. Ernst, I. Balaban,
and B. De Sutter, “Refactoring using type constraints,” ACM
Transactions on Programming Languages and Systems, 2011.
[9] M. Fowler, Refactoring: Improving the Design of Existing Code.
Addison-Wesley Professional, 1999.
[10] D. Bäumer, E. Gamma, and A. Kiezun, “Integrating refactoring
support into a Java development tool,” in ACM SIGPLAN con-
ference on Object-Oriented Programming, Systems, Languages,and Applications, 2001.
[11] J. Gosling, B. Joy, G. L. Steele, G. Bracha, and A. Buckley, The
Java Language Speciﬁcation. Addison-Wesley Professional,2014.
[12] L. Rytz, “Performance of using default methods to compile
scala trait methods,” 2016. [Online]. Available: http://scala-lang.org/blog/2016/07/08/trait-method-performance.html
[13] G. Wilkins, “eclipse/jetty.project pull request #773,” Webtide,
2016. [Online]. Available: https://git.io/v56qs
[14] I. Moore, “Automatic inheritance hierarchy restructuring and
method refactoring,” in ACM SIGPLAN conference on Object-
Oriented Programming, Systems, Languages, and Applications ,
1996.
[15] Z. Alshara, A.-D. Seriai, C. Tibermacine, H. L. Bouziane,
C. Dony, and A. Shatnawi, “Migrating large object-orientedapplications into component-based ones: Instantiation and in-
heritance transformation,” in International Conference on Gen-
erative Programming: Concepts & Experience, 2015.
[16] A. Gyori, L. Franklin, D. Dig, and J. Lahoda, “Crossing
the gap from imperative to functional programming through
refactoring,” in ACM SIGSOFT International Symposium on the
F oundations of Software Engineering, 2013.
[17] R. Khatchadourian, “Automated refactoring of legacy Java soft-
ware to enumerated types,” Automated Software Engineering,
vol. 24, no. 4, pp. 757–787, Dec. 2017.
[18] A. Kumar, A. Sutton, and B. Stroustrup, “Rejuvenating C++
programs through demacroﬁcation,” in International Conference
on Software Maintenance, 2012.
[19] J. Kim, D. Batory, D. Dig, and M. Azanza, “Improving refac-
toring speed by 10x,” in International Conference on Software
Engineering, 2016.
989
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:31:33 UTC from IEEE Xplore.  Restrictions apply. 