Boosting Complete-Code Tool for Partial Program
Hao Zhong
Department of Computer Science and Engineering
Shanghai Jiao Tong University, China
zhonghao@sjtu.edu.cnXiaoyin Wang
Department of Computer Science
University of Texas at San Antonio, USA
xiaoyin.wang@utsa.edu
Abstract ‚ÄîTo improve software quality, researchers and prac-
titioners have proposed static analysis tools for various purposes
(e.g., detecting bugs, anomalies, and vulnerabilities). Although
many such tools are powerful, they typically need completeprograms where all the code names (e.g., class names, method
names) are resolved. In many scenarios, researchers have to
analyze partial programs in bug Ô¨Åxes (the revised source Ô¨Ålescan be viewed as a partial program), tutorials, and code search
results. As a partial program is a subset of a complete program,
many code names in partial programs are unknown. As a result,despite their syntactical correctness, existing complete-code tools
cannot analyze partial programs, and existing partial-code tools
are limited in both their number and analysis capability. Insteadof proposing another tool for analyzing partial programs, we
propose a general approach, called G
RAPA , that boosts existing
tools for complete programs to analyze partial programs. Ourmajor insight is that after unknown code names are resolved,
tools for complete programs can analyze partial programs withminor modiÔ¨Åcations. In particular, G
RAPA locates Java archive
Ô¨Åles to resolve unknown code names, and resolves the remainingunknown code names from resolved code names. To illustrate
G
RAPA , we implement a tool that leverages the state-of-the-
art tool, W ALA, to analyze Java partial programs. We thusimplemented the Ô¨Årst tool that is able to build system dependencygraphs for partial programs, complementing existing tools. We
conduct an evaluation on 8,198 partial-code commits from four
popular open source projects. Our results show that G
RAPA
fully resolved unknown code names for 98.5% bug Ô¨Åxes, with
an accuracy of 96.1% in total. Furthermore, our results show
the signiÔ¨Åcance of G RAPA ‚Äôs internal techniques, which provides
insights on how to integrate with more complete-code tools toanalyze partial programs.
Index T erms‚ÄîPartial program, program analysis, boosting
complete-code tool
I. I NTRODUCTION
A partial program is a subset of a complete program. Partial-
code analysis [8] is necessary in many scenarios where only
partial programs are available, such as mining bug Ô¨Åxes forautomatic patching [16] and defect prediction [14], analyzing
forum threads and software documents for code recommenda-tion [44], and ranking code-search results [4]. In our paper, we
follow the deÔ¨Ånition in Dagenais and Hendren [8]‚Äôs as below,which requires partial programs to be free of syntax errors.
DeÔ¨Ånition 1 (Partial Program): Given a complete program
<S r c , D e p> , in which Src is the set of compilable source
Ô¨Åles, and Dep is the set of compiled dependency Ô¨Åles, a partial
program par is a subset of Src .
This deÔ¨Ånition is consistent with the majority of application
scenarios such as analyzing bug Ô¨Åxes, code search results, andsamples in documents, where source Ô¨Åles are incomplete butunlikely to have syntax errors.
Although the syntax of partial programs is often correct, it is
infeasible to compile a partial program, since the code decla-rations it refers to may not be available. For various purposes,researchers (e.g. , [40], [30], [3]) have proposed approaches
that analyze partial programs. However, these approaches havethree limitations. First, most partial-code tools are not general.For example, Zhong et al. [43] propose MAPO that mines
speciÔ¨Åcations for recommending code samples. Mishne et
al.[25] criticize that MAPO cannot mine speciÔ¨Åcations for
partial programs. To handle the problem, Mishne et al. [25]
propose PRIME that compares unknown method calls withknown method calls in other call sequences, when it minesspeciÔ¨Åcations. Although PRIME thus is able to mine speci-Ô¨Åcations for partial programs, its techniques cannot supportpartial-code analysis for other purposes ( e.g., [40]). Second,
due to the difÔ¨Åculties of analyzing partial programs, partial-code analysis is typically imprecise. For example, Mishne et
al.[25] admit that their approach is only relatively precise.
Finally, existing partial-code tools cannot support complicated
analyses. For example, although graphs are informative tocompare code, Kim and Notkin [17] complain that CFG-basedapproaches (e.g. , [2]) cannot analyze partial programs.
Our insight. We notice that many complete-code tools (e.g. ,
W ALA
1) are built on mature compilers (e.g. , Eclipse JDT).
As a partial program is incomplete, a compiler typically failsto resolve unknown code names. When complete-code tools
encounters unknown code names, they will fail to producemeaningful results. If we fully resolve such unknown codenames, it is feasible to boost some complete-code tools toanalyze partial programs.
DeÔ¨Ånition 2 (Code Name): For a given partial program P,
we deÔ¨Åne code names of P, denoted as Names( P)as iden-
tiÔ¨Åers of code elements at all granularities (e.g. , classes/types,
Ô¨Åelds, methods, and variables) appearing in P. Also, we deÔ¨Åne
resolving code name Nas determining the variable type and
the full name of NifNis a variable/Ô¨Åeld; determining the
full name of NifNis a type; and determining the signature
ofNifNis a method.
The beneÔ¨Åts and challenges. Our insight leads to a novel
approach with the following beneÔ¨Åts:
1http://wala.sourceforge.net
978-1-5386-2684-9/17/$31.00 c/circlecopyrt2017 IEEEASE 2017, Urbana-Champaign, IL, USA
T echnical Research671
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:19:44 UTC from IEEE Xplore.  Restrictions apply. TABLE I: The inference strategies of PPA.
Strategy Example
Assignment B.field=‚Äò‚ÄòHello World‚Äô‚Äô; ‚Üí{field,unknown, ‚ãójava.lang.String }
Return int m(){ return method()} ;‚Üí{method,unknown, ‚ãñint}
Method f1=m1(f2); D m1(E p); ‚Üí{f1,unknown, ‚ãóD}and{f2,unknown, ‚ãñE}
Condition if(f){ ...} ;‚Üí{f,unknown, boolean }
Binary and unary operators int i = f-10; ‚Üí{f,unknown, ‚ãñint}
Array f1 = f2[f3]; ‚Üí{f3,unknown, ‚ãñint}and{f8,unknown,unknown[] }
Switch switch(f){ ...} ;‚Üí{f,unknown, ‚ãñint}
Conditional int i=f1?1:f2; ‚Üí{f1,unknown,boolean }and{f2,unknown, ‚ãñint}
BeneÔ¨Åt 1. This is a general approach that enables many
complete-code tools for partial-code analysis. Unknown code
names of partial programs have different impacts on thesetools. Instead of proposing a solutions for speciÔ¨Åc purposes(e.g. , API speciÔ¨Åcation mining), our approach works on all
the complete-code tools that are built on mature compilers.
BeneÔ¨Åt 2. This is a practical way to improve the precision of
partial-code analysis. As partial programs contains unknown
code elements, partial-code tools are typically imprecise. Ourstrategy obtains precise tools for partial-code analysis, sinceit preserves the preciseness of complete-code tools.
Despite the above beneÔ¨Åts, to fulÔ¨Åll this strategy, we shall
overcome the following challenges:
Challenge 1. It is challenging to resolve unknown code names
for partial programs. PPA [8] is the state-of-the-art tool that
resolves code names for unknown code elements, but our studyshows that PPA fully resolves all code names for only 28.7%of partial-code snippets (Section IV-C).
Challenge 2. It is challenging to determine whether unknown
code names are sufÔ¨Åciently resolved. Some complete-code
tools (e.g. , [43]) do not implement complicated code analyses.
As they never touch some code names, boosting such tools isinsufÔ¨Åcient to determine whether unknown code names arefully resolved. In contrast, although we can feed resolvedpartial programs to a compiler, it is a too strict criterion,since it is feasible to conduct many complicated analyses evenwithout producing bytecode from partial programs.
Our Contributions. In this paper, we propose a novel
approach, called Gra
phs for Pa rtial programs (G RAPA ), that
boosts complete-code tools to analyze partial programs. As itcan take huge effort to analyse whole projects, researchers [7],[22], [10], [21] have explored analyzing only a subset of awhole program. Their basic idea is to extract an abstractionof other parts of a program. Even if the abstraction is notfully correct, it speeds up the analysis on the subset of aprogram signiÔ¨Åcantly. Following their idea, G
RAPA enables
partial-code analysis by constructing the context code of apartial program. In particular, to handle the Ô¨Årst challenge, weidentify a compiled release of the complete program whose
version is closest to the partial program to be analyzed, andextract information from the compiled release to fully resolveunknown code names. To handle the second challenge, we
build System Dependency Graphs [12] (SDGs) for partialprograms, which is a general abstraction of all code elements
and relations, compared with lighter weight analyses in task-speciÔ¨Åc tools. It should be noted that a lot of useful analyses,such as change impact analysis [31], information Ô¨Çow analy-
sis [37], and static slicing [15], can be simply performed onthe SDG of the program to be analyzed.
This paper makes the following major contributions:
‚Ä¢A novel research idea for generally improving partial-code tools. Instead of another approach for speciÔ¨Åcpartial-code analysis, our research idea has the potentialto boost many existing complete-code tools for partial-code analysis, if such tools are built on compilers.
‚Ä¢A novel approach, called G RAPA , that boosts complete-
code tools for partial-code analysis. It (1) includes atechnique to locate context versions for a partial program;and (2) extends PPA with additional inference strategies.
‚Ä¢A tool that boosts W ALA for partial-code analyses. Thetool has enabled more in-depth empirical studies, and
more advanced bug detection approaches.
‚Ä¢An evaluation of our tool on 8,198 partial-code bug Ô¨Åxesthat are collected from four popular open source projects.
Our results of the Ô¨Årst evaluation show that G
RAPA fully
resolved unknown code names and thus built SDGs for98.5% of the total bug Ô¨Åxes. Our results of the secondevaluation show that in 96.1% of bug Ô¨Åxes, its code-name resolution results are identical with those generatedby a Java compiler on their corresponding manuallybuilt complete programs. In summary, different fromexisting imprecise partial-code tools, our tool preservesthe preciseness of W ALA.
II. M
OTIV A TIONS
In this section, we use an example to illustrate the ap-
plication scenarios of partial-code analysis and the limita-tion of existing tools. The example is from the committedÔ¨Åles of ARIES-241
2. SpeciÔ¨Åcally, programmers modiÔ¨Åed the
TradeJdbc.java , and added Line 4 as follow:
public TradeJdbc{ ...
1. private ... String getTSIAQuotesOrderByChangeSQL =...
2. public MarketSummaryDataBean getMarketSummary() ... {
3. Connection conn = null;4.+ PreparedStatement stmt = getStatement(conn,
getTSIAQuotesOrderByChangeSQL, ...);}
This bug Ô¨Åx may need to be analyzed for various reasons
such as bug prediction and mining bug/repair patterns, and typ-
ically both the old and new version TradeJdbc.java needs
to be fed into a static analysis tool. According to our deÔ¨Ånitionin Section I, these two versions of
TradeJdbc.java are two
partial programs. PPA is the state-of-the-art tool to analyze
2https://issues.apache.org/jira/browse/ARIES-241
672
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:19:44 UTC from IEEE Xplore.  Restrictions apply. 9HUVLRQV$9HUVLRQ
)LOWHU$9HUVLRQ
6HOHFWRU
&RPSLOHU*5$3$
%7\SH
5HVROYHU9HUVLRQ
&DQGLGDWHV3DUWLDO
3URJUDP
$67$67ZLWK7\SH
%LQGLQJV&$PELJXLW\
5HVROYHU&RQWH[W
9HUVLRQ
$67ZLWK
)XOO%LQGLQJV
Fig. 1: The overview of G RAPA .
partial programs. It is built on existing compilers such as the
Eclipse JDT and Polyglot, and uses its underlying compilerto resolve known code names, and iteratively infers unknowntypes based on known types. Table I shows the eight inferencestrategies of PPA. In this table,
t1‚ãñt2denotes that t1is a
subtype of t2, and t1‚ãót2denotes that t1is a super type of
t2. The method strategy infers variable types based on known
method signatures, and can reversely infer method signatures
based known types, although it is not explicitly deÔ¨Åned
As the types of the getTSIAQuotesOrderByChangeSQL
andconn variables are known in Lines 1 and 3, it shall
be feasible for PPA to infer the parameter types of the
getStatement method in Line 4. However, PPA fails to re-
solve the parameter types as it depends on the underlying com-piler (Eclipse JDT) to acquire the initial resolved code names,
and Eclipse JDT (and most other compilers) stops compilationencountering the unknown type
MarketSummaryDataBean .
Although possible, revising existing compilers to bypass com-pilation stops raises extra burden and limitation. Furthermore,
as
getStatement is inherited, it is impossible for PPA to
fully resolve the method signature as it does not know which
super type of TradeJdbc deÔ¨Ånes the method.
As the above scenario is frequent, in Section IV-C, we Ô¨Ånd
that PPA fully resolves only 28.7% bug Ô¨Åxes. In G RAPA ,w e
acquire initial resolved code names from compiled releases
and propose additional variable and Ô¨Åeld inference strategies(Section III-C). In this example, Aries release several version-
s
3.G RAPA refers to the closest version for resolving more code
names. As the closest version is introduced, it also reducesthe crashing probability of the underlying compiler for otherreasons (e.g. , incompatibility). As a result, in total, G
RAPA
fully resolves 96.1% bug Ô¨Åxes.
III. A PPROACH
A. Approach Overview
Figure 1 shows the overview of G RAPA . The basic idea
behind G RAPA is to extract context code of a given partial
program, and to enable complete-code analysis on the partialprograms with the information from the context code.
DeÔ¨Ånition 3 (Context Code): Given a partial program (i.e.,
a set of source Ô¨Åles) pwhich uses a set of code names
Names( p)as deÔ¨Åned in DeÔ¨Ånition 2, the code context of
pwith depth 1 is deÔ¨Åned as Context
1(p)= p‚à™{v|‚àÉn‚àà
Name(p), v declares n}, where vis a binary or source Ô¨Åle.
The full code context of pis then deÔ¨Åned as Context‚àó(p),
3http://aries.apache.org/downloads/archived-releases.htmlindicating applying Context1function recursively on puntil
the result set no longer change (i.e., the Ô¨Åxed point is reached).
With the deÔ¨Ånition of partial programs, and code context,
we can see that for a partial program p, our goal is to Ô¨Ånd
Context‚àó(p)and feed it to a complete-code analysis tool ( e.g.,
W ALA). The ideal source of context code would be the wholesource code set, and all dependency jar Ô¨Åles at the versionthe partial program is from. However, a recent study [36]shows that even if checking out whole set of source Ô¨Åles,most commits are not compilable.
In G
RAPA , for a partial program, we use the released
versions of the software project it belongs to as its contextcode. As a released version is already successfully compiled,we do not need to Ô¨Åx compilation errors. A partial can refer
to code names that do not appear in any released versions.
For example, a code name may be added after a version isreleased, and deleted before the next version is released. Inaddition, a partial program can be from a code base after itslatest release, so all the released versions are outdated. As aresult, locating context code alone is insufÔ¨Åcient, so we furtherpropose inference strategies to resolve unknown code names.
As shown in Figure 1, G
RAPA has the following major steps.
For a partial program, G RAPA Ô¨Årst searches for a compiled
software versions that encloses the given code piece or is
compatible with it (detailed in Section III-B). We refer to this
version as the context version of the given partial program.
After that, G RAPA extracts ASTs from the partial program,
and resolves unknown type bindings of ASTs (detailed inSection III-C). To integrate with complete-code tools, G
RAPA
further resolves ambiguous types between the partial programsto be analyzed and context code (detailed in Section III-D).
B. Context V ersion Extraction
To efÔ¨Åciently Ô¨Ånd the context version of a partial program,
G
RAPA uses a two-stage strategy: (1) according to the code
names in the partial program, G RAPA identiÔ¨Åes a small set
of context version candidates (detailed in Section III-B1), and
(2) G RAPA tries the context version candidates one by one to
compile the partial program (detailed in Section III-B2).
1) V ersion Filter: GRAPA Ô¨Årst extracts the declared types,
methods, and Ô¨Åelds from the binary code (i.e., all .class Ô¨Åles)
of all available compiled versions, and constructs three lists of
declared code names: Ltdenotes the list of declared types; Lm
denotes the list of declared methods; and Lfdenotes the list
of declared Ô¨Åelds. In a list L={l1,...,l n}, each item, l,i s
in the format of /angbracketleftc, V/angbracketright, where cdenotes a code name, and
V={v1,...,v n}denotes the set of compiled versions that
declare c. For example, at the granularity of types, it extracts
the following list for the released versions of Apache Derby4:
ClientSavepoint, {10.11.1.1}
QualifierUtil, {10.1.2.1, 10.1.3.1}
...
For a partial program, we determine its context-version
candidates based on the code names it uses. A context-version
4https://db.apache.org/derby/
673
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:19:44 UTC from IEEE Xplore.  Restrictions apply. candidate should declare most (if not all) code names used
by the partial program, if the code name is not declared inthe partial program itself. For example, if a partial programdeclares a local variable whose type is , it uses the codename
ClientSavepoint , and 10.11.1.1 will be considered
a context-version candidate. Given partial program p, to extract
the set of code names puses (denoted as Names( p)), G RAPA
applies the following rules.
1) For each a.f expression where ais a variable and fis
a Ô¨Åeld, it adds both aandftoNames( p).
2) For each T.f expression where Tis a type and fis a
Ô¨Åeld, it adds TandftoNames( p).
3) For each a.m(p, ...) expression where ais a variable,
mis a method, and pis a parameter, it adds a,m, and
{p,...} toNames( p).
4) For each T.m(p, ...) expression where Tis a type, m
is a method, and pis a parameter, it adds mand{p,...}
toNames( p).
5) For each m(p,...) expression where mis a method and
pis a parameter, it adds mand{p,...} toNames( p).
6) For each (T)a cast expression where Tis a type and a
is a variable, it adds both TandatoNames( p).
7) For each Ta declaration expression where Tis a type
andais a variable, it adds TtoNames( p).
8) For each T m(T1 p1,...) throws E1,... expres-
sion where Tis a return type, mis a method, p1is a
parameter, T1is the type of p1, and E1is a thrown excep-
tion, it adds T,{T1,...} and{E1,...} toNames( p).
9) For each class|interface|enum T extends
T1,... implements I1,... expression where Tis
a declared class, interface, or enum, T1is a type, and
I1is an interface, it adds {T1,...} and{I1,...} to
Names( p).
To determine the set of context-version candidates based
onNames( p)and a list of declared names L(Lcan be
one of Lt,Lm, and Lf), we developed Algorithm 1. In the
algorithm, Line 1 initializes Vwith the versions of li, where
the declared code name of liappears in the list of called code
names (Names( p)). Line 2 iterates used code names, if they
appear at least in one version. For each iterated code name c,
Line 3 compares whether V‚à©lc.Vis an empty set. If it is not
an empty set, Line 4 updates Vwith V‚à©lc.V. If it is, Line
Algorithm 1 Context V ersion Extraction Algorithm
Input:
Lis a list of declared code names
Names( p)is a set of called code names
Output:
Vis a set of context versions
1:V‚Üêli.Vwhere li.V/negationslash=‚àÖ‚àßl i.c‚ààNames( p)
2:for all c‚ààNames( p)‚àßlc.V/negationslash=‚àÖdo
3: ifV‚à©lc.V/negationslash=‚àÖthen
4: V‚ÜêV‚à©lc.V
5: else
6: break
7: end if
8:end for6 leaves the current Vas the output. This line guarantees that
Vhas at least one version.
Given the set of used code names ( Names(p)), G RAPA runs
Algorithm 1 on each of the three lists of declared code names(L
t,Lm, and Lf) and produces three sets of context-version
candidates as Vt,Vm, and Vf. As Line 6 of the algorithm
guarantees that Vhas at least one version, Vt,Vm, and Vf
are all nonempty sets. Shi et al. [32] show that types are
more unlikely to change than methods and Ô¨Åelds. For a partial
program, G RAPA initiates its context versions VasVt, and
reÔ¨Ånes VasVt‚à©VmandVt‚à©Vm‚à©Vf, if such intersection
does not generate an empty set.
2) V ersion Selector: Our version Ô¨Ålter uses an efÔ¨Åcient
algorithm to quickly Ô¨Ånd context version candidates from
potentially many released versions. However, although thealgorithm guarantees that all code names referred in a partialprogram are declared in a context version candidate, it cannotrule out incompatibilities such as type conÔ¨Çicts in transitive
type inference. With fewer versions as context version candi-dates, we apply a compiler, which is a more heavy weight but
more precise code name resolver, to the partial program and
each of its context-version candidate to select the Ô¨Ånal contextversion. SpeciÔ¨Åcally, as partial programs are syntacticallycorrect, a compiler‚Äôs syntax analysis can build the AST froma partial program, but as partial programs has unknown code
names, the semantic analysis often fails to add name and
type bindings to ASTs. As a result, a compiler will throwexceptions, when it encounters unknown or incompatible codenames.
G
RAPA uses the Eclipse JDT compiler as its underlying
compiler, since many complete-code tools are built on thecompiler. During parsing, a compiler can search its classpath for code names. G
RAPA adds context versions to the
class path of a compiler, since it allows a compiler to search
code names, and thus reduces the possibility of throwingexceptions. As introduced in Section III-B1, G
RAPA can locate
multiple context versions for a partial program. In this step,
GRAPA tries context-version candidates one by one, until no
exceptions are thrown. Although this strategy is simple, our
evaluation results show that it is already sufÔ¨Åcient to analyzereal-world partial programs, such as bug Ô¨Åxes.
Algorithm 2 Inference Algorithm
Input:
Fis a list of facts
Tis a set of known types
Output:
Tis a set of inferred types
1:T‚Üêppa/prime(F, T)
2:whileŒîT/negationslash=‚àÖdo
3: T‚Üêvariable(F, T)
4: T‚Üêfield(F, T)
5: T‚Üêppa/prime(F, T)
6:end while
674
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:19:44 UTC from IEEE Xplore.  Restrictions apply. C. Context-Aware Type Resolver
After the context version is determined, G RAPA further
enhances the inference rules of PPA to take full advantage of
the information from the context code. As shown in Table I,PPA follows eight strategies to resolve unknown type bindings.For example, its assignment strategy is as follow:
1B.field=‚Äò‚ÄòHello World‚Äô‚Äô;
2‚Üífield,unknown,‚ãó java.lang.String
t1‚ãñt2denotes that t1is a subtype of t2, and t1‚ãót2
denotes that t1is an ancestor of t2. As shown in the above
example, PPA considers only the partial program itself, its in-ference strategies are localized to statements, and do not fullyreuse inferred results. In contrast, with context code available,
G
RAPA can link the deÔ¨Ånition and all usage locations of a
variable in the code piece, and infer the variable type based on
the global information from all usage locations. In particular,
GRAPA has the following three additional inference strategies:
1. Variable inference strategy. For each method, the strategy
updates bindings of variables until it is safe. Suppose that amethod declares a variable vand uses the variable in locations
v
1,...,v n. We use dt(v)to denote the type of v, and the
safe order of inferred types follows the deÔ¨Ånition of PPA,
i.e.,unknown <missing <super missing <full .W e
consider the vvariable to be safe, if dt(v)=dt( v1)=...=
dt(vn). For partial programs, a variable can be unsafe, since
a compile can fail to resolve its type at speciÔ¨Åc locations. Forexample, if v
iappears in a code line with a serious compilation
error, a compiler can fail in resolving the bindings for vi.A s
a result, although the bindings of other locations are resolved,the binding of v
iis still unknown. In addition, a variable
can become unsafe during inference. For example, if a known
variable is assigned to vi, the assignment strategy of PPA can
infer the binding of vi. After the inference, vican be safer than
its other locations. When this happens, our variable inference
strategy locates the safest type dt(vi), and propagates dt(vi)
to all the locations of the vvariable to make it safe.
2. Field inference strategy. The Ô¨Åeld inference strategy is
similar to the variable inference strategy, but with a differentvariable scope. The strategy updates bindings of Ô¨Åelds untilthey coincide. For each Ô¨Åeld, the strategy combines solvedtypes in all its usage locations.
3. Switch inference strategy. For a switch statement
switch(v) , PPA deÔ¨Ånes a switch inference strategy that con-
siders dt(v)as a subtype of the int primitive. The strategy is
not fully correct, since dt(v)can be byte ,short ,char ,int ,
String andenum values. G RAPA revises the strategy, and
considers that a switch statement switch(v){ case c1:...
case cn:...} is safe, if dt(v)=dt( c1)...=dt(cn).I f
a switch statement is unsafe, G RAPA locates the safest type
dt(ci)from dt(v)anddt(c1)...d t(cn), and propagates dt(ci)
to all the locations to make it safe.
PPA can infer the type for a variable at a location, but leaves
its type unresolved at other locations. As a result, although
the type of the variable can be useful to infer more unknownbindings, PPA fails to leverage such beneÔ¨Åts. Algorithm 2shows the process to solve the problem. Line 1 infers typeswith our modiÔ¨Åed PPA (ppa
/prime). Here, G RAPA modiÔ¨Åes the
original switch inference strategy of PPA. For a variable ora Ô¨Åeld, Lines 3 and 4 search for its safest type, and updatesall its locations with the safest type. After that, Line 5 furtherinfers types with our modiÔ¨Åed PPA. If more unknown bindingsare resolved, Line 2 repeats the follow-up lines until nonew unknown bindings are thus resolved. Here, ŒîT denotes
newly resolved bindings in each iteration. In Algorithm 2, ourvariable and Ô¨Åeld inference strategies unveil the full potentialof PPA, since they combine facts from different locations to
infer the safest types for unknown code names.
We use the following partial program to illustrate the dif-
ference between G
RAPA and PPA on type binding resolution.
1 b = A.f(1);
...2c=b+"xyz";3 Object obj = A.f(2);
PPA resolves type facts for each variable location in the
example, so for Line 2, it infers variables bandcas of
type java.lang.String , and for Line 3, it infers obj and
A.f as of type java.lang.Object . Finally, based on the
type of A.f , PPA further resolves bat Line 1 as of type
java.lang.Object . Here, PPA leaves the variable bat Line
1 and Line 2 with different types, because it does not know
whether the two appearances refer to the same variable inpartial-code analysis.
In contrast, G
RAPA extracts information from the context
version to conÔ¨Årm that the whole code piece comes from thesame method and the two appearances of
brefer to the same
local variable. G RAPA further uses Algorithm 2 to infer the
type of bacross all appearances, and Ô¨Ånally, the type of b,
andA.f are both updated to java.lang.String .
D. Ambiguity Resolver
If a complete-code tool does not require inter-procedure
analyses, the integration is straightforward. For example, asMAPO implements only intra-procedure analyses, it is feasibleto boost MAPO for partial programs, after unknown bindingsare resolved. However, if a complete-code tool requires inter-procedure analyses, involving the context version into partial-code analysis also results in a new challenge. As the contextversion can contain a copy of the partial programs piece, theremay be two duplicate declarations of the same code name (e.g. ,
types, variables, and methods). In the partial-code analysis, weneed to make sure that G
RAPA analyzes the partial programs
piece, instead of its copy in the context version.
For example, suppose that a partial program implements the
t1,...,t ntypes and t1uses t2. When a inter-procedure tool
analyzes t1, it needs to locate the declaration of t2. When
locating a type, a compiler typically searches the build pathof a project before they search the source code of the project.
G
RAPA builds a temporary project for the partial program, and
adds the context version to the build path of the project. Thecontext version can include t
/prime
2whose name is identical with
t2. As a result, the t/prime
2type in the context version is analyzed,
instead of the t2type in the partial program. As the context
675
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:19:44 UTC from IEEE Xplore.  Restrictions apply. version is only an approximate of the partial program, the
analysis results can be inaccurate.
We envisage that there are at least three techniques to handle
the problem: (1) removing t1,...,t nfrom the build path of
the project, (2) pre-analyzing t1,...,t n, and merging their
analysis results, and (3) changing the search sequence. The
Ô¨Årst technique is simple, but may not work on some complete-code tools. For example, if a compiler cannot Ô¨Ånd a type inthe build path of a project, it may either search the sourceÔ¨Åles of the project or throw exceptions, depending on itsimplementation details. The second technique can introduceextra analysis effort. The third technique requires modifying
source Ô¨Åles of complete-code tools, but it is Ô¨Çexible anddoes not introduce extra analysis effort. Therefore, in theimplementation of G
RAPA , we follow the third technique
and we introduce how we modify the subject complete-code
analysis tool in Section III-E.
E. Implementation
In the current implementation of G RAPA , we select W ALA
as the subject tool to illustrate the potential of our approach.
W ALA implements various analyses (e.g. , type hierarchy
analysis, data Ô¨Çow analysis, slicing, and dependency analysis).W ALA implements its advanced analyses on its uniÔ¨Åed inter-
mediate representation called IR, whose format is like Java
bytecode. When W ALA analyzes Java source Ô¨Åles, it uses theEclipse JDT compiler to build ASTs from source code, andthen translates ASTs into IRs. When the underlying compilerparses a partial program p, it is able to build an AST for p,
since the syntax of pis correct. However, the unknown code
names in pcause exceptions when W ALA translates pto its
IR. As a result, W ALA cannot analyze partial programs.
Like most compilers, W ALA searches the build path Ô¨Årst
when resolving types. As mentioned in Section III-D, wemodify its code to reverse the search strategy. Here, we modify
the classloader of W ALA, instead of the classloader of JVM.
As a result, our tool is not coupled to JVM. It should benoted that our modiÔ¨Åcations to W ALA is minimal and suchmodiÔ¨Åcations are similar for all analysis tools with a speciÔ¨Åccompiler component. For analysis tools that depend on acompiler already supported by G
RAPA (e.g., Eclipse JDT),
GRAPA is able to work with the tools directly.
IV . E V ALUA TIONS
With the implementation of G RAPA , we conducted evalua-
tions to explore the following research questions:
(RQ1) How effectively does G RAPA resolve unknown code
names of partial programs (Section IV-A)?
(RQ2) What is the accuracy of G RAPA to resolve unknown
code names (Section IV-B)?
(RQ3) What is the effectiveness of G RAPA ‚Äôs internal tech-
niques (Section IV-C)?
RQ1 concerns the effectiveness of G RAPA . As our primary
research goal is to boost existing complete-code tools, in
Section IV-A, we select the state-of-the-art tool W ALA asthe subject tool for the Ô¨Årst research question, and use theTABLE II: Overall Result.
Name V Fix SuccessFailure%U F D
Aries 4 547 533 1 10 0 97.4%
Cassandra 116 3,444 3,405 11 16 12 98.9%
Derby 20 2,560 2,538 8 12 0 99.1%
Mahout 13 560 494 3 51 3 88.2%
Total 7,111 6,970 23 89 15 98.0%
U: unsupported fragment; F: not fully resolved; D: defect.
SDG generation for bug Ô¨Åxes as our application scenario. From
four widely used open source projects, we collected 8,198 bugÔ¨Åxes. Our results show that W ALA built SDGs successfully for98.5% of the bug Ô¨Åxes after G
RAPA resolved their unknown
code names. This is a signiÔ¨Åcantly improvement, since as a
complete-code tool, W ALA cannot build any system depen-
dency graphs from such bug Ô¨Åxes. We understand that it ispossible that some code names are wrongly Ô¨Åxed. To explorethis issue, we introduce more evaluations in RQ2.
RQ2 concerns the accuracy of G
RAPA . In Section IV-B,
we select 91 bug Ô¨Åxes, and manually build the correspondingbuggy and Ô¨Åxed versions, and fed the complete built programsto W ALA, so that W ALA can correctly resolve all the codenames and build SDGs correctly. Collecting these SDGs asgolden standard, we compare with them SDGs generatedby G
RAPA for the same buggy and Ô¨Åxed programs (partial
programs). Our results show in 96.1% of bug Ô¨Åxes, G RAPA -
based SDGs are identical to the SDGs in the golden standard.
RQ3 concerns the internal techniques of G RAPA . In Sec-
tion IV-C, we turn off different internal techniques of G RAPA ,
and our results show the signiÔ¨Åcance of individual techniques.
The results also reÔ¨Çect how much code-name resolution is
needed to leverage a complete-code tool such as W ALA.
A. RQ1: The Effectiveness
1) Subject: As we introduced in Section II, bug Ô¨Åxes can
be viewed as partial programs, and we use bug Ô¨Åxes as the
subjects of our evaluation. We use the following two criteriato determine a bug Ô¨Åx:
1. Issue number. Open source projects typically have issue
trackers to track various issues ( e.g., bugs, improvements, new
features, tasks, and sub-tasks). When programmers commit
their modiÔ¨Åed Ô¨Åles, they often write the corresponding issue
number in the message of the commit. For example, inCassandra, a commit‚Äôs message says ‚Äúimplement multiple
index expressions. patch by jbellis; reviewed by Nate McCallfor CASSANDRA-1157‚Äù. In the issue tracker, the page ofthe issue says that CASSANDRA-1157 is a bug. We thusdetermine that the corresponding commit is a bug Ô¨Åx.
2. Keyword. Programmers may detour issue trackers, espe-
cially when they believe that a change is trivial. When they
commit such a change, programmers may write a messageto describe the Ô¨Åx. For example, in Aries, the message of acommit says ‚ÄúFix broken service registration listener‚Äù. We thusdetermine the commit as a bug Ô¨Åx, since its message containswords such as ‚Äúbug‚Äù or ‚ÄúÔ¨Åx‚Äù. The heuristic is simple, and a
676
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:19:44 UTC from IEEE Xplore.  Restrictions apply. number of previous studies (e.g. , [19]) used the same technique
to extract bug Ô¨Åxes.
In Table II, Column ‚ÄúName‚Äù shows project names. All the
projects are from the Apache software foundation. Column
‚ÄúV ersion‚Äù lists released versions of the projects. Column ‚ÄúBug
Fix‚Äù lists number of analyzed bug Ô¨Åxes. We select theseprojects, since they are under active maintenance and theirbug Ô¨Åxes are already collected and conÔ¨Årmed by previousstudies [41]. Here, we Ô¨Ålter bug Ô¨Åxes that do not modify sourceÔ¨Åles or modify only test code. Typically, a released version
does not include test code, so it becomes infeasible to locatecontext versions for test code. As the input of this evaluation,a bug Ô¨Åx is deÔ¨Åned as follow:
DeÔ¨Ånition 4 (Bug Fix): A bug Ô¨Åx between a buggy version
bV and a Ô¨Åxed version fV is a pair of two partial programs
<b p , f p> , where bpbelonging to bV and includes all Ô¨Åle
removed or modiÔ¨Åed, fpbelonging to fV and includes all
source Ô¨Åles added or modiÔ¨Åed during the bug Ô¨Åx.
Tufano et al. [36] analyzed 219,395 snapshots from 100
Apache projects. They found that only 38% code commits are
automatically compilable, and 58% are caused by unresolvablereferences. Mockus et al. [26] introduce that the Apache
foundation has a strict management over its hosted projects.Without such a management system, the problem may beworse in other open source communities (e.g. , Github). As a
result, both bVandfV are typically partial programs. Zhong
and Su [41] show that such partial programs typically containfewer than three source Ô¨Åles.
2) Evaluation Scenario: We use the SDG generation for
bug Ô¨Åxes as our evaluation scenario, due to two considerations.First, analysis of bug Ô¨Åxes is the basis of many downstreamresearch topics such as bug prediction and mining of bug/repairpatterns. Automating in-depth analysis of bug Ô¨Åxes will allowall above research to be applied on a much larger data set.Second, SDGs are general abstractions of all code elementsand relations in the program, and many general code analysistools such as W ALA and CodeSurfer [1] use SDGs as theirdefault output. A lot of useful analysis results, such as change
impact analysis [31], information Ô¨Çow analysis [37], static
slicing [15], can be direct extracted from the SDGs of theprogram to be analyzed. As the output of G
RAPA , an SDG is
deÔ¨Åned as follow (the same as its deÔ¨Ånition in W ALA):
DeÔ¨Ånition 5: A system dependency graph is deÔ¨Åned as
g=/angbracketleftV,E 1,E2/angbracketright, where V is a set of nodes corresponding
to variables/expressions, and E1,E2‚äÜV√óVare two sets
of edges. A /angbracketlefts1,s2/angbracketright‚ààE 1edge denotes a data dependency
from s1tos2, and a/angbracketlefts1,s2/angbracketright‚ààE 2edge denotes a control
dependency from s1tos2.
As an example, Figure 2 shows the built system dependency
graph for the buggy code of DERBY -53965, which swallows
an exception.
1: private static void closeStream(...){
2: try{3: if(stream!=null)
4: stream.close();
5https://issues.apache.org/jira/browse/DERBY -5396.GDWDGHSHQGHQF\Y ELQDU\RSQHYYQXOO
FRQGLWLRQEUDQFK¬´
LQYRNH¬´FORVH
LQYRNH¬´MDYD([FHSWLRQ¬´
UHWXUQYDOXH¬´JRWR¬´ JRWR¬´
FRQWUROGHSHQGHQF\
Fig. 2: Built graphs for partial programs
5:}catch(IOException e){
6: Util.javaException(e); }}
Under this application scenario, with G RAPA , bug predic-
tion and pattern mining tools can easily acquire SDGs and
other down-stream analysis results (e.g. , slicing) from a large
number of bug Ô¨Åxes. While without G RAPA , there must be
a lot of people manually build all the relevant code versions,and analyzing the whole code base is also much slower thananalyzing only the partial programs involved in the bug Ô¨Åxes.
3) Criterion: As we collected thousands of bug Ô¨Åxes and
each Ô¨Åx can contain thousands of unknown code names, it isinfeasible to manually examine whether G
RAPA fully resolved
unknown bindings of a bug Ô¨Åx or not. Instead of a manual ex-amination, we use the underlying complete-code tool, W ALA,
as an automatic measure. A simple tool is insufÔ¨Åcient for the
automated measure, since it may not touch many resolvedcode bindings. In contrast, W ALA is the state-of-the-art toolfor Java analysis, and it implements many advanced analysistechniques that require various code bindings. Our criterionillustrates our contributions to the state of the art, since itcomplements existing tools.
For each bug Ô¨Åx, we extract its buggy Ô¨Åles (revised or
deleted Ô¨Åles of the bug-Ô¨Åxing commit in the pre-Ô¨Åx version)and modiÔ¨Åed Ô¨Åles (revised or added Ô¨Åles of the bug-Ô¨Åxing
commit in the post-Ô¨Åx version). Both the set of the buggy
Ô¨Åles and modiÔ¨Åed Ô¨Åles are partial program, since we did notcheck out their corresponding whole projects. We considerthat bindings in the buggy or modiÔ¨Åed Ô¨Åles are fully resolved,
if W ALA is able to build system dependency graphs fromthe code. For a bug Ô¨Åx, we consider that it is successfully
resolved, if G
RAPA fully resolved all its source Ô¨Åles. Here,
we concede that W ALA can build a system dependency graph
for a partial program, even if it is incorrectly resolved. Wefurther investigate this issue in Section IV-B.
4) Result: G
RAPA uses only tens of released versions to
approximate contexts of thousands of commits, and thus avoideffort of (1) analyzing the whole project for each commit, and(2) building each commit, which often needs nontrivial manualeffort. Our results lead to the following Ô¨Åndings:
1. G
RAPA fully resolved unknown code names for most bug
Ô¨Åxes. In Table II, Column ‚ÄúSuccess‚Äù lists number of successes,
and Column ‚Äú%‚Äù lists success rates. In total, we Ô¨Ånd that
GRAPA fully resolves 98.5% bug Ô¨Åxes, since their dependency
graphs can be built.2. W ALA failed to analyze 0.3% Ô¨Åxes, even after G
RAPA
fully resolved their bindings. Column ‚ÄúFailure‚Äù lists number
of failures. Based on our inspection, we further put them into
three categories. In particular, subcolumn ‚ÄúU‚Äù lists Ô¨Åxes thatW ALA failed to analyze. For example, the ‚Äúf0be890‚Äù commit
677
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:19:44 UTC from IEEE Xplore.  Restrictions apply. TABLE III: The results of comparing with the golden standard.
Name V ersion Fix File Method Same %
Aries 1.0 24 38 456 452 99.1%
Cassandra 3.0.0 14 22 585 558 95.4%
Derby 10.11.1.1 37 88 2,088 1,995 95.5%
Mahout 0.10.0 16 25 661 636 96.2%
Total 91 173 3,790 3,641 96.1%
of Cassandra modiÔ¨Åes SchemaKeyspace.java , a Ô¨Åle with
lambda expressions:
ALL.forEach(table->getSchemaCFS(table).truncateBlocking());
The underlying tool, W ALA, cannot analyze lambda expres-
sions. As another example, we notice that G RAPA fails on the
following code:
final StandardMBean standardMBean =
new StandardMBean(bean, beanInterface){...};
We inspect the relevant code of W ALA, and Ô¨Ånd an assertion:
assert superCtor!=null:"couldn‚Äôt find constructor for
anonymous class";
Based on the error message, W ALA seems to have limitationson analyzing anonymous classes.
3. G
RAPA failed to fully resolve bindings in 1.1% bug
Ô¨Åxes. Subcolumn ‚ÄúF‚Äù lists cases where bindings are not fully
resolved. We Ô¨Ånd that the failed cases fall into three major
categories:
1. InsufÔ¨Åcient facts to infer bindings. For example, we Ô¨Ånd a
code snippet as follows:
ReplicationMessage message = ...;
switch (message.getType()){
case ReplicationMessage.TYPE_LOG:...case ReplicationMessage.TYPE_FAILOVER:...case ReplicationMessage.TYPE_STOP:...default:...
}
In this code snippet, ReplicationMessage is an unknown
code name. Based on the switch statement, G RAPA infers
thatTYPE_LOG ,TYPE_FAILOVER ,TYPE_STOP , and the return
value of the message. getType() method shall be the same.
The type does not appear in any released versions, but between
two versions. As the code snippet does not provide adequateinformation, G
RAPA fails to determine their types.
2. InsufÔ¨Åcient type inference strategies. For example, we Ô¨Ånd
a code snippet as follows:
public class EditAuthorForm extends FormServlet{
private static final long serialVersionUID = ...;
In the above code, FormServlet is an unknown code name,
but the inference strategies of PPA and our extension cannotinfer the binding for the ancestor type.
3. ConÔ¨Çict facts. For example, we Ô¨Ånd the following snippet:
public void setup(String aggregateName){
super.setup(aggregateName); ...;
The above code calls the super.setup(...) method, but in
the located version, the signature of the method is as follow:
public void setup(ClassFactory classfactory, String s,
DataTypeDescriptor datatypedescriptor){...;}The above code and release have different deÔ¨Ånition on the
signature of the super.setup(...) method. We Ô¨Ånd that
when this type of conÔ¨Çicts happens, PPA tends to reject
the information from source code. However, as our locatedreleases are approximate, the information from the build pathshall be rejected, so the strategy of PPA leads to incorrectbinding resolution in this example.
4. The Eclipse JDT compiler failed to parse 0.2% Ô¨Åxes.
Subcolumn ‚ÄúD‚Äù lists cases where the JVM machine crashes:
# A fatal error has been detected by the Java Runtime
Environment:...
We notice that the following method calls appear in crash logs:
ciMethod org/eclipse/jdt/core/compiler/CharOperation...
.../jdt/internal/compiler/ast/TypeReference<init>....../jdt/internal/compiler/ast/Expression<init>...
We suspect that the underlying compiler, Eclipse JDT, is not
designed for parsing partial program, so it reports the aboveproblem when parsing partial program.
In summary, our results show that G
RAPA effectively re-
solved bindings for more than 90% of bug Ô¨Åxes. Only 1.1%
of bug Ô¨Åxes are not fully resolved, which may be resolved inour future work.
B. RQ2: The Accuracy
1) Subject: Table III shows our subjects. We choose the lat-
est version, since it is easier to Ô¨Åx possible compilation errors.
For example, an old version may require a third-party librarythat is no longer available. Column ‚ÄúBug Ô¨Åx‚Äù lists selected bugÔ¨Åxes. Tufano et al. [36] show that recent snapshots are almost
3.76 times more likely to compile than early snapshots. Toreduce the manual effort to prepare the golden standard, weselect bug Ô¨Åxes whose detected version is exactly the latestversion. We Ô¨Ålter out bug Ô¨Åxes whose graphs are not built,and bug Ô¨Åxes that do not have compilation problems. Column‚ÄúFile‚Äù and Column ‚ÄúMethod‚Äù list total source Ô¨Åles and totalmethods of selected bug Ô¨Åxes, respectively.
2) Criterion: For each bug Ô¨Åx, we checked out its buggy
and Ô¨Åxed versions, and repaired all compilation errors. Afterthat, we used W ALA to build SDGs ( G
WA L A ) for the buggy
Ô¨Åles of the bug Ô¨Åx as our golden standard. Meanwhile, weuse G
RAPA to build SDGs (G GRAP A ) from the buggy Ô¨Åles
as a partial program. We implemented a tool to compareG
WA L A with GGRAP A for their differences. The tool uses
the Hungarian algorithm [20] to match nodes, and we deÔ¨Ånethe distance between two nodes (m andn) as follows:
dis(m, n)=|i(m)‚àíi(n)|
i(m)+i( n)+|o(m)‚àío(n)|
o(m)+o(n)+d(l(m),l(n))
(1)
i(m) denotes the indegree of m;o(m) denotes the outdegree
ofm;l(m) returns the label of m; and d(l1,l2)returns the
Levenshtein edit distance between the l1label and the l2label.
3) Result: 1. G RAPA correctly resolved bindings in most
Ô¨Åxes. Table III shows the overall results. Column ‚ÄúSame‚Äù lists
methods whose built graphs are identical. Column ‚Äú%‚Äù listscorresponding percents. In total, 96.1% bindings resolved by
G
RAPA are identical with the golden standard.
678
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:19:44 UTC from IEEE Xplore.  Restrictions apply. TABLE IV: The signiÔ¨Åcance of internal techniques.
NameNo Version No PPA No Extension
Suc. % Suc. % Suc. %
Aries 339 61.9% 353 64.6% 435 79.6%
Cassandra 899 26.1% 1,546 44.9% 2,332 67.7%
Derby 637 24.9% 1,088 42.5% 1,882 73.5%
Mahout 189 33.8% 351 62.6% 442 79.0%
Total 2,041 28.7% 3,307 46.5% 5,113 71.9%
2. G RAPA failed to correctly resolve bindings in only 3.9%
Ô¨Åxes. After manual inspection, we identiÔ¨Åed two types of
wrong resolutions:
1. Not fully resolved bindings. For example, CASSANDRA-
6181 includes the following code:
public void serialize(DataOutput out...)...{
ByteBufferUtil.
writeWithShortLength(tombstones.starts[i], out);...}
In this code, the writeWithShortLength method is un-
known. PPA infers its signature based on its parameters:
writeWithShortLength(Ljava/nio/ByteBuffer;
Ljava/io/DataOutput;)V
When we manually recover the code, we Ô¨Ånd that the decla-
ration of the method is as follow:
public static void writeWithShortLength
(ByteBuffer buffer, DataOutputPlus out)...{...}
The above code has no compilation errors, since DataOut-
putPlus is a subtype of DataOutput . Our tool detects the
following difference:
¬´ZULWH:LWK6KRUW/HQJWK/MDYDQLR%\WH%XIIHU
/MDYDLR'DWD2XWSXW9
¬´ZULWH:LWK6KRUW/HQJWK/MDYDQLR%\WH%XIIHU
/RUJDSDFKHFDVVDQGUDLRXWLO'DWD2XWSXW3OXV9
2. Wrong static and instance code names. For example,
CASSANDRA-8413 modiÔ¨Åes the following code:
bf = FilterFactory.getFilter(...);
Here, the FilterFactory.getFilter(...) method is un-
known. PPA wrongly resolves the static method to an instancemethod, although it correctly resolves all the parameters andthe return value. We identify the wrong resolution, since ourtool detects the following difference:
,QYRNHVWDWLF¬´JHW)LOWHU¬´ ,QYRNHYLUWXDO¬´JHW)LOWHU¬´
In the above two situations, W ALA can still build graphs
based on incorrect binding resolutions. In Table II, the resultson these methods are counted as successes according to thecriterion in Section IV-A. Our tool detected the incorrectresolutions, but as shown in Table III, 96.1% of the totalbindings are correctly resolved.
C. RQ3: Internal Techniques
1) Setup: Our approach has two major techniques to resolve
unknown bindings: (1) it detects the context versions for a
partial program (Section III-B1), and (2) it extends PPA withadditional inference strategies (Section III-C). In this section,we use G
RAPA to analyze the bug Ô¨Åxes in Table II, without
the above techniques to show their signiÔ¨Åcance.2) Result: In Table IV, Column ‚ÄúNo V ersion‚Äù shows the
results when G RAPA does not detect context versions. Column
‚ÄúNo PPA ‚Äù shows the results when G RAPA does not resolve
unknown bindings with PPA. Column ‚ÄúNo Extension‚Äù showsthe results when G
RAPA uses the standard PPA, instead of our
extended PPA as described in Section III-C. Subcolumn ‚ÄúSuc.‚Äùlists number of successes. Subcolumn ‚Äú%‚Äù lists success rate.
The results lead to our Ô¨Åndings:
1. The technique of locating context versions is the most
effective internal technique. Without locating context ver-
sions, only 28.7% of the total Ô¨Åxes are fully resolved. Withoutthe standard PPA and our extended PPA, 46.5% and 71.9%of the total Ô¨Åxes are fully resolved, respectively. The resultshighlight the importance of locating context versions, and theimprovement over PPA.
2. Our extended PPA shows its signiÔ¨Åcance when partial
programs have critical compilation errors. Comparing Col-
umn ‚ÄúNo PPA ‚Äù with Column ‚ÄúNo Extension‚Äù, we Ô¨Ånd thatour extension of PPA improves the success rates. We noticethat like other compilers, the Eclipse JDT compiler can stop
resolving bindings after it encounters a critical compilation
error. For example, in ARIES-241, a method is as follows:
private ... String getTSIAQuotesOrderByChangeSQL =...
public MarketSummaryDataBean getMarketSummary() ... {
PreparedStatement stmt = getStatement(
getTSIAQuotesOrderByChangeSQL, ...);...}
In the method, the code name MarketSummaryDataBean
is unknown, and causes a critical compilation error. The un-
derlying compiler, Eclipse JDT, does not resolve any bindingsinside the method, after encountering the error. For example,although
getTSIAQuotesOrderByChangeSQL is declared in
the same type, its type is resolved as null . Consequently, PPA
fails to resolve the signature of the getStatement method.
Our variable and Ô¨Åeld strategies links resolved bindings beforethe error line and those unresolved bindings after the errorline. In this example, our Ô¨Åeld strategy links the declarationof
getTSIAQuotesOrderByChangeSQL to the parameter of
thegetStatement method. As a result, it becomes feasible to
resolve the signature of the method. In this way, our additionalinference strategies make the improvements in Table IV.
D. Threats to V alidity
The threats to internal validity include our criterion to
determine incorrect resolutions in RQ2. To reduce the bias,
we implement a tool to compare dependency graphs, but even
a tool can introduce errors. The threat could be reduced by
introducing more manual inspections. The threats to externalvalidity include that we focus on only a type of partial pro-grams from only Apache and a single tool, so our effectivenessmay vary on other subjects. To reduce the threat, we selectthousands of commits and the state-of-the-art tool. The threatcould be reduced by analyzing more subject tools.
V. A
PPLICA TIONS OF GRAPA
As a support tool, the beneÔ¨Åts of G RAPA are indirect, and
our evaluations did not show its applications. However, we
679
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:19:44 UTC from IEEE Xplore.  Restrictions apply. believe that G RAPA can be useful in many real applications,
since it enables more accurate analysis on partial programs.
1. More in-depth empirical studies. Researchers have con-
ducted various empirical studies to explore open questions
that involve partial programs (e.g. , bug Ô¨Åxes [38], [41]). As
their underlying partial-code tools are limited and imprecise,
their results can be superÔ¨Åcial or even biased. G RAPA enables
more in-depth analysis on partial programs. Indeed, Zhong andMeng [39] have conducted an empirical study on using pastÔ¨Åxes to construct new patches. As they compare SDGs of bugÔ¨Åxes, their study is infeasible without G
RAPA ,
2. More advanced bug detection/repair approaches. Many
researchers believe that it is feasible to propose more advancedbug detection/repair approaches, based on the knowledge thatis extracted from past Ô¨Åxes. However, as existing partial-code tools are limited, it is quite challenging to automate theextraction. For example, although Kim et al. [16] implemented
tools to reduce their inspection effort, their analysis is largelymanual, which is tedious and error-prone. G
RAPA enables
more in-depth empirical studies on bug Ô¨Åxes [39] and moreadvanced bug detection/repair techniques. Indeed, Zhong andWang [42] have detected previously unknown bugs for all the
four projects, and their tool is built on G
RAPA .
3. Analyzing partial programs in more scenarios. The
applications of G RAPA are not limited to analyzing bug Ô¨Åxes.
Besides this scenario, G RAPA can be applied to many other
scenarios where partial programs and some compiled releases
are available. Typical scenarios include code samples in APIdocuments [40], development emails [30], and code searchengines [24]. It is feasible to extend G
RAPA for the above
scenarios after minor changes. For example, although manycode samples in API documents do not have method/classbodies, Zhong and Su [40] show that it is feasible to constructfake bodies, which enables follow-up analysis. As anotherexample, Terragni et al. [34] propose an approach that extracts
code samples from forums. From such samples, it is feasible
to locate context versions by querying such types on existing
code search engines (e.g. , GrepCode or Github). Despite of
that Algorithm 1 is suboptimal, it achieves more than 90%accuracy, leaving adequate space for further improvements.
VI. R
ELA TED WORK
Partial-code analysis. Mishne et al. [25] propose PRIME that
mines speciÔ¨Åcations from partial programs. Zhong and Su [40]detect errors in code samples of API documentations, and suchsamples are partial programs. Subramanian and Holmes [33]extract API calls from code samples in StackOverÔ¨Çow. Our
approach presents a general way to leverage tools for complete
code, so they can analyze partial programs, complementing ex-isting approaches. Dagenais and Hendren [8] propose PPA thatÔ¨Åxes unknown bindings for partial programs. We are the Ô¨Årst toprovide the insight that extending PPA can potentially leveragecomplete-code tools to analyze partial programs. Ossher et
al.[28] resolve missing dependencies for complete programs,
but most partial programs are not compilable, even if theirdependencies are resolved. Carvalho Gomes et al. [9] analyzeincomplete Java bytecode. During compilation, complete codeinformation is encoded into bytecode, so JVM can execute itcorrectly. When analyzing partial code, we do not have suchinformation, so the problem we target is more challenging.
Code comparison. Fluri et al. [13] compare ASTs of source
Ô¨Åles for their differences. Maletic and Collard [23] translates
Ô¨Åles into srcML and compare the translated format for differ-ences. Kim and David [18] denote code with a set of predicatesand compare these predicates for their differences. Buse and
Weimer [5] generate documents to describe code changes.
Apiwattanapong et al. [2] compare CFGs for their delta.
Although graphs are more informative, Kim and Notkin [17]complain that CFG-based approaches cannot analyze partialprograms, which is complemented by our approach.
Empirical study on bug Ô¨Åxes. Researchers have conducted
various empirical studies to understand the nature of bug Ô¨Åxes.
Yin et al. [38] show that bug Ô¨Åxes can introduce new bugs.
Nguyen et al. [27] show that repetitiveness is common in small
size bug Ô¨Åxes. Eyolfson et al. [11] show that the bugginess
of a commit is correlated with the commit time. Thung et
al.[35] show that faults are not localized. Zhong and Su [41]
analyze the nature of Ô¨Åxing bugs. Canfora et al. [6] analyze the
relations between Ô¨Åxed code elements and the time to Ô¨Åx bugs.With our approach, researchers can integrate more advanced
tools for analyzing bug Ô¨Åxes, reducing the analysis effort.
VII. C
ONCLUSION AND FUTURE WORK
In this paper, we propose an approach that locates ap-
proximate Java archive Ô¨Åles and resolves remaining unknownbindings. After integration, we can boost existing complete-
code tools to analyze partial programs. Based on our approach,we implement G
RAPA , and conduct evaluations on thousands
of partial-code bug Ô¨Åxes. Our results show that our tool
correctly fully resolved unknown bindings for 98.5% of bugÔ¨Åxes, and for 96.1% of bug Ô¨Åxes, our binding resolutions are
identical with our golden standard.
In future work, we plan to explore two directions as follows.
First, applying G
RAPA to different application scenarios may
require more advanced technical adaptations. For example,symbolic analysis often needs a driver function to initiateobjects of partial programs. Person et al. [29] propose differ-
ential symbolic execution that reuses analysis results betweenprogram versions, and test code can provide hints on initiatingobjects. Analyses of forum threads calls for more advancedsearching techniques for context versions. Second, althoughour tool works on Java, our approach is general and can beadapted for other programming languages.
A
CKNOWLEDGMENTS
We appreciate the reviewers for constructive comments, and
Na Meng for repairing bugs in G RAPA . Hao Zhong is spon-
sored by the 973 Program in China (No. 2015CB352203), theNational Nature Science Foundation of China No. 61572313,and the grant of Science and Technology Commission ofShanghai Municipality No. 15DZ1100305. Xiaoyin Wang‚Äôswork is supported in part by NSF grant CCF-1464425 andDHS grant DHS-14-ST-062-001.
680
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:19:44 UTC from IEEE Xplore.  Restrictions apply. REFERENCES
[1] P . Anderson and M. Zarins. The CodeSurfer software understanding
platform. In Proc. IWPC, pages 147‚Äì148, 2005.
[2] T. Apiwattanapong, A. Orso, and M. J. Harrold. A differencing algorithm
for object-oriented programs. In Proc. ASE, pages 2‚Äì13, 2004.
[3] A. Bacchelli, T. Dal Sasso, M. D‚ÄôAmbros, and M. Lanza. Content
classiÔ¨Åcation of development emails. In Proc. ICSE, pages 375‚Äì385,
2012.
[4] S. Bajracharya, T. Ngo, E. Linstead, Y . Dou, P . Rigor, P . Baldi, and
C. Lopes. Sourcerer: A search engine for open source code supporting
structure-based search. In Companion to OOPSLA, pages 681‚Äì682,
2006.
[5] R. Buse and W. Weimer. Automatically documenting program changes.
InProc. ASE, pages 33‚Äì42, 2010.
[6] G. Canfora, M. Ceccarelli, L. Cerulo, and M. D. Penta. How long does
a bug survive? an empirical study. In Proc. WCRE, pages 191‚Äì200,
2011.
[7] P . Cousot and R. Cousot. Modular static program analysis. In Proc.
CC, pages 159‚Äì179, 2002.
[8] B. Dagenais and L. J. Hendren. Enabling static analysis for partial Java
programs. In Proc. OOPSLA, pages 313‚Äì328, 2008.
[9] P . de Carvalho Gomes, A. Picoco, and D. Gurov. Sound control Ô¨Çow
graph extraction from incomplete Java bytecode programs. In Proc.
F ASE, pages 215‚Äì229. Springer, 2014.
[10] T. W. Dillig. A modular and symbolic approach to static program
analysis. PhD thesis, Stanford University, 2011.
[11] J. Eyolfson, L. Tan, and P . Lam. Correlations between bugginess and
time-based commit characteristics. Empirical Software Engineering,
19(4):1009‚Äì1039, 2014.
[12] J. Ferrante, K. J. Ottenstein, and J. D. Warren. The program dependence
graph and its use in optimization. ACM Transactions on Programming
Languages and Systems, 9(3):319‚Äì349, 1987.
[13] B. Fluri, M. Wursch, M. PInzger, and H. C. Gall. Change distilling:
Tree differencing for Ô¨Åne-grained source code change extraction. IEEE
Transactions on Software Engineering, 33(11):725‚Äì743, 2007.
[14] T. L. Graves, A. F. Karr, J. S. Marron, and H. Siy. Predicting fault
incidence using software change history. IEEE Transactions on Software
Engineering, 26(7):653‚Äì661, 2000.
[15] S. Horwitz, T. Reps, and D. Binkley. Interprocedural slicing using
dependence graphs, volume 23. ACM, 1988.
[16] D. Kim, J. Nam, J. Song, and S. Kim. Automatic patch generation
learned from human-written patches. In Proc. ICSE, pages 802‚Äì811,
2013.
[17] M. Kim and D. Notkin. Program element matching for multi-version
program analyses. In Proc. MSR, pages 58‚Äì64, 2006.
[18] M. Kim and D. Notkin. Discovering and representing systematic code
changes. In Proc. ICSE, pages 309‚Äì319, 2009.
[19] S. Kim, T. Zimmermann, E. J. Whitehead Jr, and A. Zeller. Predicting
faults from cached history. In Proc. ICSE, pages 489‚Äì498, 2007.
[20] H. W. Kuhn. The hungarian method for the assignment problem. Naval
research logistics quarterly, 2(1-2):83‚Äì97, 1955.
[21] S. K. Lahiri, K. V aswani, and C. A. Hoare. Differential static analysis:
opportunities, applications, and challenges. In Proc. FOSE, pages 201‚Äì
204, 2010.
[22] F. Logozzo, S. K. Lahiri, M. F ¬®ahndrich, and S. Blackshear. V eriÔ¨Åcation
modulo versions: Towards usable veriÔ¨Åcation. In Proc. PLDI, pages
294‚Äì304, 2014.[23]
J. Maletic and M. Collard. Supporting source code difference analysis.
InProc. ICSM, pages 210‚Äì219, 2004.
[24] C. McMillan, M. Grechanik, D. Poshyvanyk, C. Fu, and Q. Xie.
Exemplar: A source code search engine for Ô¨Ånding highly relevant
applications. IEEE Transactions on Software Engineering, 38(5):1069‚Äì
1087, 2012.
[25] A. Mishne, S. Shoham, and E. Yahav. Typestate-based semantic code
search over partial programs. In Proc. OOPSLA, pages 997‚Äì1016, 2012.
[26] A. Mockus, R. T. Fielding, and J. D. Herbsleb. Two case studies of open
source software development: Apache and Mozilla. ACM Transactions
on Software Engineering and Methodology, 11(3):309‚Äì346, 2002.
[27] H. A. Nguyen, A. T. Nguyen, T. T. Nguyen, T. N. Nguyen, and H. Rajan.
A study of repetitiveness of code changes in software evolution. In Proc.
ASE, pages 180‚Äì190, 2013.
[28] J. Ossher, S. Bajracharya, and C. Lopes. Automated dependency
resolution for open source software. In Proc. MSR, pages 130‚Äì140,
2010.
[29] S. Person, M. B. Dwyer, S. Elbaum, and C. S. Psreanu. Differential
symbolic execution. In Proc. FSE, pages 226‚Äì237, 2008.
[30] G. Petrosyan, M. P . Robillard, and R. D. Mori. Discovering information
explaining API types using text classiÔ¨Åcation. In Proc. ICSE, pages
869‚Äì879, 2015.
[31] X. Ren, F. Shah, F. Tip, B. G. Ryder, and O. Chesley. Chianti: a tool
for change impact analysis of Java programs. In Proc. OOPSLA, pages
432‚Äì448, 2004.
[32] L. Shi, H. Zhong, T. Xie, and M. Li. An empirical study on evolution
of API documentation. In Proc. F ASE, pages 416‚Äì431, 2011.
[33] S. Subramanian and R. Holmes. Making sense of online code snippets.
InProc. MSR, pages 85‚Äì88, 2013.
[34] V . Terragni, Y . Liu, and S. Cheung. CSNIPPEX: automated synthesis
of compilable code snippets from Q&A sites. In Proc. ISSTA, pages
118‚Äì129, 2016.
[35] F. Thung, D. Lo, and L. Jiang. Are faults localizable? In Proc. MSR,
pages 74‚Äì77, 2012.
[36] M. Tufano, F. Palomba, G. Bavota, M. Di Penta, R. Oliveto, A. De Lucia,
and D. Poshyvanyk. There and back again: Can you compile that
snapshot? Journal of Software: Evolution and Process, 2016.
[37] H. Yin, D. Song, M. Egele, C. Kruegel, and E. Kirda. Panorama:
Capturing system-wide information Ô¨Çow for malware detection andanalysis. In Proc. CCS, pages 116‚Äì127, 2007.
[38] Z. Yin, D. Y uan, Y . Zhou, S. Pasupathy, and L. Bairavasundaram. How
do Ô¨Åxes become bugs? In Proc. ESEC/FSE, pages 26‚Äì36, 2011.
[39] H. Zhong and N. Meng. Poster: An empirical study on using hints from
past Ô¨Åxes. In Proc. ICSE, 2017.
[40] H. Zhong and Z. Su. Detecting API documentation errors. In Proc.
OOPSLA, pages 803‚Äì816, 2013.
[41] H. Zhong and Z. Su. An empirical study on real bug Ô¨Åxes. In Proc.
ICSE, pages 913‚Äì923, 2015.
[42] H. Zhong and X. Wang. Detecing bugs with past Ô¨Åxes. In Proc.
OOPSLA, page submitted, 2017.
[43] H. Zhong, T. Xie, L. Zhang, J. Pei, and H. Mei. MAPO: Mining and
recommending API usage patterns. In Proc. ECOOP, pages 318‚Äì343,
2009.
[44] H. Zhong, L. Zhang, T. Xie, and H. Mei. Inferring resource speciÔ¨Åca-
tions from natural language API documentation. In Proc. ASE, pages
307‚Äì318, 2009.
681
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:19:44 UTC from IEEE Xplore.  Restrictions apply. 