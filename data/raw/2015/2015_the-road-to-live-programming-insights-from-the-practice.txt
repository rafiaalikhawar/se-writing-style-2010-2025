The Road to Live Programming: Insights From the Practice
Juraj Kubelka
Pleiad @ DCC, University of Chile
Santiago, ChileRomain Robbes
SwSE @ Free University of
Bozen-Bolzano
Bozen-Bolzano, ItalyAlexandre Bergel
Pleiad @ DCC, University of Chile
Santiago, Chile
ABSTRACT
LiveProgrammingenvironmentsallowprogrammerstogetfeed-
back instantly while changing software. Liveness is gaining atten-
tion among industrial and open-source communities; several IDEs
offer high degrees of liveness. While several studies looked at how
programmers work during software evolution tasks, none of them
consider live environments.We conduct such a studybased on an
analysisof17programmingsessionsofpractitionersusingPharo,
a mature Live Programming environment. The study is comple-
mented by a survey and subsequent analysis of 16 programming
sessions in additional languages, e.g.,JavaScript. We document the
approaches taken by developers during their work. We find that
somelivenessfeaturesareextensivelyused,andhaveanimpacton
the way developers navigate source code and objects in their work.
CCS CONCEPTS
•Software and its engineering →Development frameworks
and environments; Object oriented development;
KEYWORDS
Live Programming, Software Evolution, Exploratory Study
ACM Reference Format:
JurajKubelka,RomainRobbes,andAlexandreBergel.2018.TheRoadtoLive
Programming:InsightsFromthePractice.In ICSE’18:ICSE’18:40thInterna-
tional Conference on Software Engineering, May 27-June 3, 2018, Gothenburg,
Sweden.ACM,NewYork,NY,USA,12pages.https://doi.org/10.1145/3180155.
3180200
1 INTRODUCTION
LiveProgrammingaimstofreeprogrammersfromtheedit-compile-
run loop of standard programming, going as far as to allow pro-
gramstobechangedwhiletheyrun.Recentyearshaveshownthat
there is considerable interest in Live Programming, and liveness
ingeneral:thenewprogramminglanguageSwiftfromApplefea-
turesInteractivePlaygrounds[ 1];Microsoftrecentlypurchaseda
companydevelopingLiveProgrammingtools[ 2];Facebook’sReact
supports instant feedback [ 3]; web browsers come with interactive
consoles and inspectors [ 4]. Academically, a series of international
conferences and workshops have been held on Live Programming,
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,
topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5638-1/18/05...$15.00
https://doi.org/10.1145/3180155.3180200with LIVE 2013 being the most popular workshop at ICSE 2013 [ 5]
(see Section 2 for background on Live Programming).
While some see Live Programming as “the future of program-
ming”, some of its proponents have more concrete and immediate
issues.MicrosoftResearch’sSeanMcDirmid[ 6]wrote:“Thebiggest
challenge instead is live programming’s usefulness: how can its
feedback significantly improve programmer performance?”
While the full vision of Live Programming is yet to be imple-
mentedandmadeavailableatscaletopractitioners,manyelements
of it are in use on a daily basis in some developer communities.
Inparticular,manyoftheLiveProgrammingconceptshavebeen
presentfordecadesintheSmalltalkandLispdevelopmentenviron-
ments; Smalltalk and Lisp feature high degrees of liveness.
This offers us a critical opportunity to understand howliveness
is usedtoday, and offers insights to practitioners, researchers, lan-
guage designers, and tool builders on how to effectively use and
supportLiveProgramming.Inthispaper, weprovideanswersto
severalresearchquestionsontheuseofLiveProgrammingfeaturesinpractice.WefirstprovideessentialbackgroundonLiveProgram-
ming and our main study subject, the Pharo IDE, in Section 2.
Wethenpresentourmethodology(Section3):weanalyzed17
development sessions of 11 programmers, totaling 13 hours of cod-
ing with familiar and unfamiliar code. This was followed by two
confirmatory phases: a survey of 190 Smalltalk developers, and an
analysis of 16 online videos (25 hours) of HTML/JavaScript, C#,
PHP, Haskell, and C/C++ programmers.
Section4 answersour firstresearchquestion, “Do developers
use the Live Programming features of Pharo?” , in the the af-
firmative:wefindthatLiveProgrammingfeaturesandtoolswere
used extensively by Pharo users.
Section5answersoursecondresearchquestion: “How do devel-
opers use Live Programming in Pharo?” . We describe several
usages of Live Programming and contrast them against traditional
programming approaches. Our overall finding is that simple ap-
proaches were favored, and their combinations can be powerful.
We then answer our third research question “Do developers,
other than those we analyzed, behave similarly?” intwoparts.
First, we find that surveyed Pharo users agree with most of the
observationswemade(Section6).Subsequently,weobservethat
users of other languages and tools use more limited capabilities
duetothelimitedextentofthetoolsupport,andwiththeaimof
getting feedback early and often (Section 7).
Wethendiscussourfindingsinthecontextofexistingstudiesand
toolsupportinSection8.Inparticular,wediscusshowareduced
toolset, centering on the concept of the object inspector supports a
large range of use cases.
Finally, we close the paper with a discussion of the threats to
validityofthisstudyinSection9andconcludewithimplications
for tool builders, researchers, and language designers in Section 10.
10902018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Juraj Kubelka, Romain Robbes, and Alexandre Bergel
2 BACKGROUND AND RELATED WORK
2.1 Live Programming Environments
The reader wishing to experience Live Programming concretely
may visit the http://livecoder.net web site for a JavaScript example.
Degrees of liveness. Live Programming allows programmers to
obtainnearlyinstantaneousfeedbackfromtheirprogramsthrough
always accessible evaluation [ 7]. Tanimoto describes four levels
of liveness[ 8]. Atlevel 1, the usermust restart thewhole applica-
tiontoobtainanykindoffeedback.Atlevel2,semanticfeedback
is available on-demand; this is the level provided by interactive
interpreters(Read-Eval-Printloops).Atlevel3,incrementalfeed-
back is automatically provided after each edit operation. Finally,
level 4 applies changes to a running application without explic-itly initiating the application under change. Each level creates a
differentexperienceandcoversolutionssuchasauto-testing,Read-
Eval-Print loops (REPLs), or systems where development tools and
applications share the same environment [9].
WhileelementsofLiveProgrammingdatebackdecades,with
some versions of it supported in LISP’s Read-Eval-Print Loop [ 10],
orinSmalltalkanditsdescendants(e.g., Self[11],Squeak/Smalltalk
[12]orLivelyKernel[ 13]),ithasseenaresurgenceofinterestin
academia and in the industry.
Live Programming research. Academically, both the LIVE pro-
grammingworkshop[ 14]andtheInternationalConferenceonLive
Coding [15] held their 3rd edition in the fall of 2017. Many Live
Programminglanguagesandtoolshavebeenproposed,butmost
ofthem areexperimental.Aswe focusontheusageof livenessin
practice—and due to space constraints—we only give a brief cover-
age ofa handful ofseminal work.The 90’s sawan interest inLiveProgramming for visual languages, such asTanimoto’s VIVA [16],
that introduced the 4 liveness levels. Burnett et al.implemented
level4livenessinavisuallanguage[ 17].Theyalsoconductedacon-
trolled experiment of debugging comparing live and non-live tasks
[18].Theyfoundthatsubjectsperformedtwiceasmanychangesin
livetasks,buttheeffectintermsoftimeandaccuracywasmixed.
Recent works include languages such as McDirmid’s SuperGlue
[19],JonathanEdward’ssubtext[ 20],andGlitch[ 21].Microsoft’s
TouchDevelophasbeenmodifiedtosupportLiveProgramming[ 22].
DeLineetal.proposedTempe,aLiveProgrammingenvironment
for data analysis [23].
Livenessinpractice. Severalframeworksandtoolsnowadaysadd
waystointegrateimmediatefeedback,particularlyontheweb.The
Chrome web development tools [ 4] allow changes to web pages
andJavaScriptcodewithoutreloadingawebpage.Modern,popular
JavaScript frameworks including Facebook’s React.js support Live
Programming in live code editors [3].
Mainstream languages also take steps in this direction: Java sup-
ports a limited replacement of application parts while it is running
through the Java Platform Debugger Architecture [ 24]. Apple’s
newlanguageSwiftsupportsLiveProgrammingwithinteractive
playgrounds[ 1].Finally,Microsoft’sVisualStudio2015supportsin-
teractiveprogrammingforC#andF#withREPLs[ 25,26].Microsoft
also recently acquired the CodeConnect startup, which developed
the Alive extension for Visual Studio [2].2.2 Live Programming in Pharo
WhyPharo? Pharo[27]isaprogramminglanguageanddevelop-
mentenvironmentderivedfrom theSqueak/Smalltalk[ 12]dialect
ofSmalltalk-80[ 28].Asthedevelopmenttoolsandtheapplications
sharethesameruntimeenvironment,developersnaturallyworkon running applications. In addition, developers constantly im-
provePharoitselfbyalteringitwhileitisrunning.SincePharocanupdate any part of an application at runtime, it supports up to Tan-
imoto’s fourth level of liveness. As a descendant of Squeak, Pharo
also features the direct manipulation Morphic UI [ 29], originally
implemented in Self [11].
As a descendant of Smalltalk-80, liveness is present in Pharo
since more than three decades. This has two consequences thatmade Pharo the case study of choice in this work. First, liveness
was designed in the language and the tools since its inception; the
supportisbothmatureandseamless.Moreimportantly,liveness
is also part of the culture of the development community. Pharo is
usedbyanactivecommunityofdevelopers,bothinindustryand
academia.Pharousersareintroducedtolivenesswhentheylearn
the language from the very beginning, and as a result practitioners
use it naturally as part of their daily tasks. This characteristic is
the main driver of our choice of Pharo, as we wanted to know how
developers familiar with liveness use it, in practice.
Liveness in Pharo. We now present the main liveness features of
Pharo, contrasting it with a traditional IDE, Eclipse (assuming a
default configuration).
Codeevaluation. Thefirstdifferenceistheeaseofevaluatingcode
inPharo.Sincethecompilerisauser-accessibleobject, anypieceof
textcanbeselected,andthenbeexecuted,printedout,inspected,de-
bugged,orprofiled,eitherviamenusorkeyboardshortcuts.Eclipse
canonlyrunapplicationsinnormalordebugmode,andexecute
tests.Thisdifferencehasfar-reachingconsequences.Forinstance,
inPharoitiscommontoencounterexecutableexamplesembedded
inmethodcomments.Tobetterunderstandamethod,ausercan
simply select the example, execute it, and observe the result.
Pharo can also compile and update a single method at a time.
Thiscanbedoneevenwhileapplicationsarerunning:anynewcall
tothechangedmethodfromthenonwillcalltheupdatedbehavior.
Accessing objects. The Object Inspector is a tool that displays
objectstates[ 30].Developerscannavigatetheobjectgraph,modify
instancevariables,evaluatecodesnippets,browseitssourcecode,
and invoke inspectors from virtually anywhere. They may open
multipleinspectorsatthesametimeandkeepthemforarbitrary
long periods of time. This is useful for contrasting the object be-
haviors and for evaluating the result of source code change on live
objects. Theinspector can beembedded inother tools [ 31]. Many
objects have custom inspector views.
Eclipse has a more limited Object Inspector in its debugging
perspectivethatcanonlynavigatetheobject’sstructure,changethe
values of primitive types, and is dismissed as soon as the developer
leaves the debugging perspective.
Playground. The Playground is a tool to write code snippets and
exploretheirresults,whicharedisplayedinanembeddedObject
Inspector. Playgrounds can be used to experiment with example
code snippets. Developers can open various playgrounds and keep
them open indefinitely. Eclipse does notprovide a similar tool.
1091
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. The Road to Live Programming: Insights From the Practice ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Debugger. The Pharo Debugger is composed of a stack trace
at the top, a source code editor in the middle, and an embedded
inspector in the lower part with instance and method variables.
Developerscanchangethevariablevalues,editsourcecode,and
observe the effects of these changes. Pharo developers can haveseveral debuggers open at the same time, which allows for easy
comparisonoftheexecutionoftwoexecutionscenarios.Whena
non-existentmethodisinvokedonanobject,thedebuggerofferstocreateit,generatesastub,andthennavigatesinsidethemethodstub,
allowing the developer to implement it with live arguments and
variables at his or her disposal. This process, called “programming
inthedebugger”canberepeatedindefinitely(e.g., anewlyadded
methodcaninturncallanon-existingmethod),andisespecially
popular among proponent of test-driven development.
Eclipse developers can evaluate code snippets inside of a debug-
ger. However, Eclipse does notsupport multiple opened debuggers.
Changingsourcecodeatrun-timeislimitedtomethodsvisiblein
thecall stack;any otherchangeneedsanapplication restart. Pharo
developerscanchangeanysourcecodeelements,includingclass
definitions.ThePharodebuggerisautomaticallyinvokedwhenever
an error occurs, while Eclipse’s has to be invoked manually.
Halo.OriginatingfromMorphic[ 32],theHaloenablesinterac-
tionswithon-screenwidgets.TheHaloisinvokedontheUIelement
under the mouse via keyboard shortcuts. Buttons appear around
thewidget,triggeringactionssuchascopying,altering,deleting,
or inspecting it. Eclipse does notoffer a similar functionality.
2.3 Studies of Developers
Manyobservationalstudiesofdevelopershavebeenconducted.We
very briefly list some here—see Section 8 for discussions in context.
Koet al.studied how developers seek information during main-
tenancetasks[ 33].Lawrance etal.studiedhowdevelopersdebug
fromaninformationforagingperspective[ 34].LaToza etal.present
developeractivitiesandthetoolsupportlevelforthem[ 35].Roehm
et al.conducted an observational study about software comprehen-
sioninsevencompaniesandreportoncomprehensionstrategies
[36]. LaToza et al.compared novice and experts during program
comprehension [ 37]. Robillard et al.contrasted 5 successful and
non-successful developers during maintenance tasks [38].
Astheywork,developersaskmanyquestions.Severalstudies
seek to catalogue them and analyze their tool support. Sillito et
al.[39,40]observed27softwaremaintenancesessions,andlisted
44 questions asked during them. LaToza et al.focus on reacha-
bility questions and provide 12 questions rated by difficulty andfrequency [
41]. Koet al.identify 21 questions about interaction
with codebases and co-workers [ 42]. Fritzet al.present 78 devel-
operquestionswithlackoftoolsupportthatinvolveinformation
integrationfromvarioussources[ 43].Duala-Ekoko etal.conducted
a study on unfamiliar APIs and identified 20 questions [44].
Some studies disallowed the use of runtime information (e.g.,
Robillard et al.[38]); others did allow it, but did not specifically
report it (such as Ko et al.and Lawrance et al.[33,34]). Thus,
studies of live environments, where a high amount of runtime
informationisavailable,complementpreviouswork.DeLineand
Fisherperformedsuchastudy,butintherestrictedcontextofData
Scientists [45], not in software development.Table 1: Participant information.
Participant Programming experience in Current Conducted
Id Any language Smalltalk Position Sessions
[years] [years]
P1 5.5 3 Ph.D. Student S1
P2 15 11 Professor S2
P3 5 1.5 Professional S3
P4 20 13 Professor, Professional S8, S11
P5 7 0.5 Master Student, Professional S9, S12
P6 22 16 Professor S10, S13
P7 10 6 Ph.D. Student S4
P8 4 2 Bachelor Student S5, S14
P9 7 3 Ph.D. Student S6, S15
P10 3 0.5 Professional S16
P11 5 3 Ph.D. Student S7, S17
3 RESEARCH METHOD
3.1 Exploratory Study
Participants. We recruited eleven male participants consisting of
students, academic staff, and professional developers from distinct
small local companies. Their programming experience spanned
from5to22years,withamedianof6years.ExperienceinPharo
or Smalltalk ranged from 0.5 to 16 years, with a median of 3 years.
Theparticipantsconsistedof1bachelorstudent,4Ph.D.students,
2professors,2professionaldevelopers,and2personswithmixed
positions. Details are illustrated in Table 1.
Tasks.We conducted 17 programming sessions, of which 10
sessions(S1–S10)includedan unfamiliarcodebase,and7sessions
(S11–S17)a familiarcodebase.Asessionwasclassifiedas familiar
if the participant was one of the authors of the codebase. In this
case we asked the participant to choose a programming task of
his or her project on which he or she can work during 40 minutes,
and stressed it was not important to finish the task at the end of
the session. In unfamiliar sessions, the participant had little or no
knowledge of the codebase beforehand. We provided him or her a
preparedPharoimagerelatedtoaparticularbug-fixingorextension
task and an explanation of the task.
Study Setting. Participants completed the study using Pharo ver-
sion3.TheycoulduseanyIDEfeatures,andanydocumentation
resources. They were advised to proceed with their work as usual.
Beforeeachsession,wesetuptheparticipant’sdeviceandexplained
the procedure of the session. We asked participants to verbalizetheir thoughts while solving their tasks. Participants did not re-ceive any additional prior training for our study. After about 40
minutes, we informed participants that they could finish whenever
they wanted.
Data Collection and Transcription. We used three data collection
techniques: screen captured videos (including audio, 13 hours in
total), user interactions, and interviews. We summarized what the
participants said, and described the actions they were performing
on the screen; we developed tools to attach timestamps to thetranscriptsandnavigatebacktothevideosasneededduringthe
analysis. These data, recordings, and tools are available at [ 46–48].
We complemented this data with IDE user interactions [ 49],
whichwecapturedwiththeDFlowframework[ 50].Eventsincluded
opening,closing,andmovingofwindows,clicksonUIelements,
navigation and changes to the source code, etc.(see details in [ 50]).
1092
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Juraj Kubelka, Romain Robbes, and Alexandre Bergel
The interactions were not recorded in the session S14 due to the
participant’sincompatiblesetup;weexcludeS14whenwereport
on DFlow data (in Section 4, and in Figure 2; we manually checked
the presence of each tool but did not count the windows).
After each session we conducted semi-structured interviews
in which participants were asked to comment on the challenges
experienced during the sessions and divergences with their day-to-
day work. The interviews lasted from five to fifteen minutes.
3.2 On-line Survey
Since our aim was to confirm the exploratory study findings, we
usedanon-linesurveyasitisadatacollectionapproachthatscales
well[51].Thesurveyissplitintothreeparts:demographicinforma-
tion,toolusagequestionswithmultiplechoices,andopen-ended
questions. None of the questions were mandatory. Excluding de-
mographicsquestions,the surveyconsistedof34 multiple-choice
questionsand2open-endedquestions,andansweringittookabout
10 minutes. The survey is available at [46].
We first ran a pilot survey with a limited number of people
to clarify our questions. We then advertised the survey through
sevenmailinglistsrelatedtoSmalltalkcommunities,andTwitter.
To attract participants we included a raffle of two books.
The survey received 190 responses. Our participants were expe-
rienced(60%morethan10years;10%6to10years;16%3to5years;
and14%2yearsorless),andmanywerefromindustry(44%from
industry, 19% from academia, 24% both, 13% others, e.g.,hobby).
Thisbalanceswithourstudyparticipants,primarilyfromacademia.
RespondentsusedseveralSmalltalkdialects;70%programmeddaily.
3.3 On-line Coding Session Videos
Asconductinganexploratorystudyisatime-consumingprocess
even with a limited number of sessions, we complement this study
with an analysis of publicly available coding session videos. We
searched for programming videos on YouTube, using keywords
such as “coding session”, “programming session”, and “live pro-gramming”, and environments and frameworks that were more
likelytofeatureadegreeofliveness,suchas“Javascript”,“React”,
“C#”, or “Swift”. We also considered the related videos proposed by
YouTube. We selected potentially relevant videos based on their
titleandskimmingtheircontents.Theinitiallistincluded44videos,
totaling about 50 hours. This data is available at [46].
In the second step, we watched and categorized each video in
ordertodeterminewhetheritisaprogrammingsessionorapre-
arranged tutorial or talk. We end up with 16 coding session videos
ofabout25hours.Wethencarefullywatchedthesevideos,looking
for five events: (1) a developer observes a running application or
variablevaluesafterachange;(2)adevelopermodifiessourcecode
or variable values of a running application; (3) a developer uses an
inspector to get runtime values; (4) a developer uses a debugger to
understand a problem; (5) a developer write and run code snippets.
For each event we identified whether: (i) we observe it at least
once;(ii)weobserveapartwhereitisusediterativelyafterasmall
meaningful change; or (iii) we do not observe it.
Thevideosubjectsusethefollowingprogramminglanguages:
11 HTML/JavaScript (69%, 15 hours), 2 Haskell (13%, 3 hours), 1
PHP(6%,2hours),1C#(6%,4hours),and1C/C++(6%,14minutes).4 RESULTS: USAGE OF LIVENESS
In this section, we are concerned whether participants of the ex-
ploratorystudyusetheLiveProgrammingfeatures.Toanswerit,
we divide development tools into two categories: static tools if the
mainpurposeistopresentsourcecode(e.g., SourceCodeandRefer-
encesBrowsers);and dynamictools ifthemainpurposeistopresent
thestateofanapplication(e.g., Debugger,Playground,Inspector,
TestRunner,Profiler).Thegoalofthisclassificationistogetusa
first-orderapproximationoftheuseofLiveProgramming.Thisis
only an approximation, as developers can change source code with
static tools and have an immediate feedback, or use dynamic tools
and observe application states without performing changes.
Figure 1: Dynamic and static tool usage per session.
Figure 1 shows the usage of static (gray) and dynamic (black)
toolsovertimeinallthesessions.Eachsessionlabelincludesthe
following information: session ID, unfamiliar or familiar task, par-
ticipant ID, and dynamic toolusage percentage. In total, ourpar-
ticipantsspent5.5hours(42%)usingdynamictoolsand7.5hours
(58%) using static tools, with 5 sessions having 60% or more of the
timespentwithdynamictools.Inaddition,wecanseethatdevelop-
ers routinely switched between static and dynamic tools, even for
short durations. Thosenumbershighlight the high overall usage of
dynamic tools during the sessions, and its frequency.
Figure 2: Number of windows opened per session
Figure 2 shows, for the most frequently used tools, the number
of windows opened in each session. Results are aggregated for
1093
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. The Road to Live Programming: Insights From the Practice ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
compactness: each tool is summarized by a bar divided in cells.
Eachcellrepresentsthenumberofsessionsforwhichaspecified
rangeofwindowswereopened;graycellstotheleftindicatesparse
or no usage of a tool, while green cells to the right indicate prolific
users.Wesubdividedebuggerusageintwocategories:explicituser
invocation with breakpoints, and automatic invocation by the IDE
when runtime errors occur.
Figure 2 allows us to easily rank tools by usage. The system
browser (222 of 750 development tool windows, or 30%), used to
browse and edit code, unsurprisingly goes first: all subjects used it
extensively.Thencomestheobjectinspector:allbutoneparticipant
usedit(139totalwindows,19%),andmanydidveryfrequently.Our
most prolific participant opened 30 of them! Note that this is an
underestimate, as this number does not include inspectors embed-
ded in other tools (debuggers, playgrounds). Debuggers caused by
runtime errors follow (91 windows, 12%). They were present in all
but3sessions,andappearedforthefollowingreasons:non-existentmethods (60), test case assertion failures (19), and other runtime er-rors(12).Themethodbrowserusedforreferencenavigationcomes
next (91 windows, 12%), being extensively used by half of the par-
ticipants.Next,theplaygroundappears(46windows,6%),although
this metric may be somewhat misleading: all but one participant
usedplaygrounds,andthesewindowstendtobelong-lived.Finally,
debuggers invoked on breakpoints are next (47 windows, 6%), with
8participantsneverusingthem.Othertoolssuchastestrunners
(2 windows), profilers (3 windows), or version control tools (16
windows) saw little use.
Summary:Participantsuseddynamictoolsfrequently.Chiefamong
them was the Object Inspector.
5 RESULTS: LIVENESS EPISODES
Inthissection,wedescribethestrategiesthatprogrammerstook
to make progress in their tasks. They took a variety of approaches,
sometimes taking advantage of Pharo’s liveness (accessing objects,
finding and modifying examples, crafting code snippets, modifying
applications),sometimesemployingmoretraditionalapproaches
(unit testing, debugging, code search, and static exploration). Each
type of usage (or episode, reusing the terminology of Zieris and
Prechelt [ 52]) is illustrated by one or more examples from the tran-
scripts. Finally, we highlight how the approaches can be combined.
5.1 Accessing and Manipulating Objects
Accessing objects with the inspector is the most common strategy
participants took; it was present in all but one sessions. Inspectors
were used frequently due to Pharo’s ease of executing source code
anywhere,includingincodebrowsers,playgrounds,debuggers,and
inspectorsthemselves.Usagesvary insophisticationfromsimple
accesses(checkingofclassnames,variablevalues),tomanipulationthroughexecutionofmethodcallsandcodesnippetsontheobjects.
Basic usages. Participant P4 (S8) copy-pasted an example in a
playgroundinordertounderstandalibrary.Hehadnoideawhat
a variable was; its name “ a” was far from useful. By adding the
method call “ a inspect ” at the end of the example and executing
it, P4 received an inspector on “ a”, where he could see the object’s
state, including its class name.Using multiple inspectors. An important feature of the inspector
isthatonecankeepanynumberofinspectedobjectsopened,for
as longas necessary. In thecase of Eclipse, developerslose access
to objects when they exit a debugging session. Pharo developers
thus can change code and regularly execute methods in previously
inspected objects to see the impact of their changes.
Participant P9(S6) workedwith theRubric frameworkthat cre-
atestexteditors.P9foundouthowthelibraryworksbyopening
inspectorson objectsof interest:P9obtained aninspectoron aUI
widget representing an editor view. The view had a model hold-
ing information about the contained text. Within the inspector,
P9evaluatedandaskedfortheview’smodelandopeneditinan-
otherinspector.ThenP9wassendingmessagestobothobjects,and
observed how they interact and change each other.
InspectingUIobjects. ParticipantP11(S7)wantedtofindwherea
mouse click that opened a UI window is handled. He inspected the
UI window using a halo (see Section 2.2), and found the window’s
class.Hethenputabreakpointintheclassconstructor,triggered
the mouse click again, and found the source code in the debugger.
Notethatbeingabletoinspectgraphicalwidgetsdoesnotalways
result in finding relevant information. Similarly to P11, Participant
P5 (S9) wanted to know where a particular dialog was executed.
He inspected the dialog widget, but started diving in the (complex)
structureoftheobject,expectingtofindarelevantmethodname
(this approach is possible, but is challenging). P5 spent about 20
minutesbeforerealizinghecoulddolikeP11whosubdividedthe
question in two steps: identifying the widget class, then using a
breakpoint to find out where it is created.
Using multiple inspectors with halos is possible too: Participant
P6 (S10) had to fix a bug relating to an application’s text editingarea. Noticing that the bug is not present in another application,
he used halos to find out whether the text editing areas in the two
applications were similar; they were of two different UI widget
classes. P6 could then focus on one class of widgets only.
5.2 Finding, Modifying, and Executing
Examples
Ourparticipantsfoundexamplesfromavarietyofsources:indocu-
mentation, in source code, in test cases, and in dedicated browsers.
Theywereeasytoexecuteandchange,butmorecomplexexamples
weremorechallengingtoreuse.Evenifseldomused,weobserve
that having an example browser with running (living) examples
simplifies exploration and comprehension.
Basicusage. Afteridentifyingtheclassofthetextarea(seeabove),
P6 searched for references of the text area class. Executing some oftheexampleshefoundinhissearch,heconcludedthattheproblem
is not in the widget itself, but likely in its configuration or usage.
Example browser. Participant P4 (S8) was tasked with enhancing
theGlamourUIframework:P4hadtoshowthattime-consuming
UIoperationswereinprogress,avoidingtheimpressionthattheUIisfrozen.P4firstsearchedforacodeexamplethathadsucha
time-consumingoperationintheGlamourexamplebrowser.The
example browser is a browser that only shows methods annotated
asexamples;theexamplesareautomaticallyexecuted,showingthe
resultswithadomain-specificview(forGlamour,itshowstheUI
generated by the example). When he found a suitable example, he
1094
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Juraj Kubelka, Romain Robbes, and Alexandre Bergel
pasteditintoanewplaygroundtoexecuteit.Oncehewasfamiliar
with it, he made changes related to his task.
Isolation issues. Participant P9 (S6) had to replace the legacy text
editor frameworkin the Nautilus browserwith a new framework,
called Rubric. He found an example of a Rubric editor. Despite
having a working example, it took P9 about two and half minutes
toisolatetherelevantpartsinordertoreducethesizeoftheexample
to the minimum working solution.
5.3 Crafting Code Snippets
Pharo’splaygroundisasimplebutpowerfulcombinationofacode
editor and an inspector; participants used it to write small code
snippets that helped them evaluate solutions and isolate bugs.
Isolatingbugs. ParticipantP11(S17)exploredperformanceissues
inanapplication.Hethoughtthattheissuemaybecausedbyoneof
three libraries—three application layers. To remove suspicion from
the uppermost layer of the application, he wrote a code snippet
that was a minimal prototype of the application and only used the
second layer. As the owner of the second layer library, he wrote it
frommemoryinabouttwominutes.Afterfourminutes,hehada
working prototype and discarded the third layer from suspicion.
Multiple snippets. Participant P4 (S8), tasked with enhancing
Glamour’s responsiveness (see above), found a non-responsive ex-
ample to get started. P4 constructed possible solutions, writing
prototypes in different playgrounds. Thus he thought up of several
solutions to the task, made changes in the library, and observed
the behavior of the running prototypes. P4 said that he usually
keeps examples, because “it is an easy way to get back [to an earlier
version] or share gained knowledge with others.”
5.4 Modifying Running Applications
Participants frequently manipulated running applications, particu-
larly when a feature is accessible from the GUI.
Immediate feedback. Nautilus is a source code browser in Pharo.
P11 (S17) was askedto make its fast navigation functionalityuser-
visible.P11workedinNautilusitself,iterativelyperformedchanges
inthecodebase,andimmediatelytestedthechangeeffectsinthe
running application. This way, he verified the correctness of his
progress. In this case, it was not necessary to recompile and restart
Nautilus each time he made progress.
Misleadingfeedback. ParticipantP9(S6,seeabove)wasalsoasked
to change Nautilus: P9 had to replace an old text editor framework
withanewonecalledRubric.Uponfindingrelevantsourcecode,
P9 modified it to ensure that he found the right location. However,
hischangeswereunexpectedly notvisibleinhisrunningversion
of Nautilus. P9 spent about three minutes understanding why the
changes were not reflected in the running application: the method
P9 modified is called only once during the startup of Nautilus (this
could be seen as a limitation of Pharo’s liveness). P9 opened a new
browser and was finally able to see the changes.
5.5 Traditional Approaches
We briefly cover approaches documented in other work.
Test Cases. We found overall few uses of test cases; they were
morecommononfamiliarcodebase.ParticipantsP4(S11)andP8
(S14)usedthetestdrivendevelopment(TDD)methodology:Theyfirstwrotetestcases,thenenhancedsourcecodetosatisfythetests.
The tests ensured their solution’s accuracy. Both were working on
familiar code, and knew since the start what they had to do.
P4 stated during his first session (S11) that he always uses TDD,
but he did not write any test cases in session S8, on unfamiliar
code.Heconfirmedthatinthiscase,hedidnothaveenoughknowl-
edgetowritetestcases.P4insteadwroteseveralprototypesthat
reflectedhisideas,andtheniterativelymadechangestothecode
that he tested on his prototypes. Similarly, participant P6 (S13) was
enhancing a graphical user interface. He expressed—while repeat-
edlymanuallytestingtheuserinterface—thatheusuallywritestest
cases, but “it is hard to write test cases for graphical user interfaces.”
Using the debugger. Participants used a debugger at least once
in each session. Only half of them used breakpoints; the others
onlyreactedtoerrors.Participantsdidnotusuallychangesource
codeinthedebugger.Typically,theerrorshadtobefixedinsource
code locations other than wherethe error occurred. P4 (S11) fixed
afewtestcasesdirectlyinthedebugger,whenitwaspossibletodochangeslocally.Wedidnotseeinstancesof“programmingin
the debugger”.
When using breakpoints, participants were usually interested
in variable valuesand wherea methodis calledfrom. Thishelped
them to comprehend programs (e.g., P11 in S7 above). P8 (S5) used
thedebuggertofindwhereandhowaparticularapplicationpartis
initialized. Later, he regularly changed the code, executed it, and
watched if the implemented parts worked and what was necessary
to fix next. He rewrote his code several times. One reason was that
theobjectsheneededwereavailableindifferentmomentsofthe
execution. He gained the knowledge during his work.
P6 (S10) spent nearly the entire session in a single debugger,
exploring in detail a long method with several conditionals. He
carefully read each statement, evaluated expressions to check their
returnvalues,andobservedallvariablevalues.Finally,heidentified
where to do the change, and changed it (in the debugger itself).
Text Search. Along with reading source code statically, search is
a common tool in traditional IDEs. We observed few text searches.
ApossiblereasonisthatPharohasfragmentedsearchtools,that
increasethecostofsearching:onetoolsearchesinsourcecodetext,
while others do semantic searches e.g.,class and method names.
ParticipantP5(S12)lookedforaclassimplementingatreegraph,
searchingforclassesincludingtheword tree.Hewasnotsuccessful,
butwas convinced that“somethingas fundamentalasatree object
structure has to exist ”. He thus searched the Internet and an online
book. He did not find anything and solved his task differently.
P6 (S13) explored a class and looked for a method using auto-
completion,saying,“thereshouldbeamethodnamedsomethinglike
open.” After several tries he found the method openWithSpec.
Source code exploration. When all else failed, participants had
to resort to static sourcecode exploration. Deciding when to stop
reading code and start changing it was not trivial.
Stopping too early, one risks missing important information
and make incorrect decisions. P2 (S2) was on the right track at
the beginning of his session. Before any changes, he first statically
explored code in order to confirm his thoughts. He focused on the
rightcode,butdismisseddetailsbecausehethoughtitwas“toolow-levelcode.”Hecouldnotconfirmhisassumptions,missedimportant
code for his task, and ended up with a complex solution.
1095
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. The Road to Live Programming: Insights From the Practice ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Neitherdidexploringmorethannecessaryleadtogooddecisions.
P1 (S1) spent his session mostly browsing code. He soon ended up
in a framework that was not important to understand; he spent
almost half his time exploring it. While he gained a comprehensive
knowledge about it, he did not find a starting point for the task.
5.6 Combining Approaches
These episodes are not observed in isolation. Participants switched
techniques during the course of a session as necessary, and also
combinedtechniques,thankstoPharo’sabilitytoopenunlimited
instancesofeachtool.Forinstance,P11combinedhalos,inspectors
anddebugginginS7(above).ThisisbestexemplifiedbyParticipant
P7, while seeking to isolate a bug in a graphical library:
P7 (S4) wrote a code snippet in a playground. The code repre-
sentedtheminimalstepstoreproducethebugintheapplication.
Inadditiontorunningtheapplication,P7wasconcernedabouta
particular object it used. He thus added the inspectmessage to
hissnippetandexecutedit,obtainingtheapplication’sgraphical
windowandaninspectorwiththeobjectofinterest.Hethencrafted
a similar code snippet that involved other UI widgets, and behaved
correctly. He executed this second snippet, and opened a second
inspector. P7 regularly modified and executed the code snippets on
both cases and observed the differences in behavior. By observing
both running examples and the corresponding source code, he was
able to reveal the problem and fix it.
Summary:Participantsemployedavarietyofapproaches,butpre-
ferred simpler ones. Combining approaches had powerful results.
6 RESULTS: ON-LINE SURVEY
In this section, we present the survey results. Figure 3 displays an
overviewoffrequencyanswers,Figure4thenrevealsagreement
responses. Due to the space constraints, we simplified the wording
oftheindividualclaims.Foreasiercomparisonoftheclaims,the
responses“Rarely”,“Occasionally/Sometimes”,“Regularly”,“Dis-
agree”, “Somewhat disagree”, and “Neutral” are aligned on the left.
Figure 3: Frequency answers.
Toolusage. Wefindthatourrespondentsindicatethattheyuse
thelivenessinSmalltalkIDEsoverwhelminglyandoften.Allbut
3 of the respondents (98%) indicated that they used at least one
of the tools often. The inspector once again took the lead (172
Figure 4: Agreement answers.
respondentsuseditatleastoften,90%),followedbythedebugger(all
debuggerusages,155respondents,82%),thenexamples(aggregated,
152 respondents, 80%), code snippets writing tools (e.g., Pharo’s
playground,141respondents,74%).Modifyingrunningapplications
was somewhat less popular (116 respondents, 61%).
Specific practices. We note that keeping inspectors open for long
periods of time (more than one hour) is practiced often by a re-spectable amount of our respondents (73 respondents, 38%), and
regularlybyanadditional44respondents(23%).Participantsalso
tended to evaluate code snippets more than directly changing data
structures, be it in the inspector or the debugger (74 vs 32%, and
62% vs 36%). This also indicates that the playground is not the onlyplace where code snippets are crafted. We note that examples werepopular overall, but that the sources are varied. Dedicated example
browsing tools, still relatively new, were not used extensively.
Agreement answers. We find that our respondents generally
agreed with the statements we proposed. There is a particularlybroad agreement with our assertions on the inspector, and thedebugger. Agreement is more moderate in the case of examples
(finding relevant source code examples is not always easy), and
codesnippets(codesnippetsarelessusedtosketchoutprogram
structures).Respondentsfoundthatfastfeedbackwassomewhat
easier to achieve in inspectors and debuggers than with code snip-
pets (presumably since many queries in the inspector or debugger
donotinvolvewritingcode).Theyfinallyindicatedastrongpref-
erence to check their changes as often as possible, and not only
afterfinishingatask.Werestatethatallofthestatementsproposed
were generally met with agreement.
Comparisons. Wealsoaskedourparticipantstocomparereading
code withother approaches, onboth familiar andunfamiliar code.
Webrieflyrelatetheresultsforspacereasons.Participantsindicated
thattheyfounditeasiertoreadcodethantowriteeithertestsor
codesnippets.Ontheotherhand,theyindicatedthattheyfound
it easier to understand programs by running them (or running
examples), rather than reading code. In all cases, reading code was
slightly easier when said code was familiar.
Summary: Survey participants confirmed that they used liveness
extensively; the inspector was again the most frequently used.
1096
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Juraj Kubelka, Romain Robbes, and Alexandre Bergel
7 RESULTS: ON-LINE CODING SESSIONS
In this section, we present the results of on-line coding session
videos.Figure5displaysourobservationsforeachprogramming
approach.Foreasiercomparison,theconclusions“NotObserved”
have negative values.
Figure 5: On-line coding session video observations.
Immediatefeedback. Thiswasthemostusedapproach.Partici-
pantsusuallytriedtowritetheminimumamountofsourcecode
thattheywereabletorunandtest;sometimesanincorrectbehavior
was expected. In some cases, the application restart was performed
automatically, others manually. Two programmers used test cases
that were re-executed automatically in a text console.
Inspectorusage. Anobjectinspector,inparticularHTML/DOM
inspector and JavaScript object inspector, was the second most fre-
quent tool. Developers predominantly inspected HTML pages and
explored HTML DOM and CSS rules. JavaScript’s object inspector
wasfrequentlyusedinabrowserconsoleinordertocheckavari-
able value, less often to observe an object’s internal structure. Two
programmersexpressedconfusionwhentheyexploredtheinternal
structure of JavaScript objects: the JavaScript inspector exposes
manyinternalobjectattributes(e.g., __proto__variables)thatare
usually not relevant to developers.
Codesnippetusage. Weobservetwosessionswhereprogrammers
wroteandexecutedcodeinaJavaScriptinternetbrowserconsole.In
thefirstcase,thedeveloperwastestingreturnvalueswhilesendingmethodstoanobject.Inthesecondcase,thedeveloperwonderedif
sending a particular method to an object was properly handled. To
obtaintheobject,heloggedthevariabletotheconsoleinhissourcecodeandrefreshedtheapplication.Whentheobjectappearedinthe
console, he used the “Store as Global Variable” feature to make the
objectaccessibleacrossruns.Hethenresumedhiswork,sending
the method to the object several times.
Debugger usage. The debugger was used in only one session,
whereaparticipantputbreakpointsinawebbrowserandobserved
variable values of his recently written program.
Modifying running application. One programmer modified the
runtimestateofhisJavaScriptprogram.Heevaluatedsomecode
in a browser console and thus tested its correct behavior.
Discussion. We conclude that developers use feedback in their
runtime environment; this includes executing applications and oc-
casionally runtime state exploration. We think tool support has
animportantimpact.WebelievethatparticipantsusedtheHTM-
L/DOMinspectoriterativelybecauseitisamaturesolution:they
caneasilyjumpfromHTMLtosourcecode,manipulateitandthus
understand how it works. Similarly, the inspector integrated inweb browser consoles was used frequently. But developers did not
explore internals of JavaScript objects: understanding it is com-
plex and toolsupport is insufficient. Further analysisis needed to
confirm these implications and is out of scope of this paper.
Summary: Developers in other languages use feedback when they
can have it; more limited tool support restricts their options.
8 FINDINGS AND DISCUSSION
We discuss our findings taking as our main point of comparison
thestudyofSillito etal.[39]andinparticulartheextendedaccount
foundinSillito’sthesis[ 40].Thisisthemostextensiveandin-depth
accountofaprogrammingobservationstudythatweknowof.It
alsohastherichestsourceofimplicationstowhichwecancontrast
findings. We also explicitly refer to other work as necessary.
8.1 On Liveness
No silver bullet. We agree with Tanimoto [ 8] that “Liveness by itself
isnotapanaceaforprogrammingenvironment.Neitheritisnecessary
for all programming tasks ”. We find some instances where subjects
were unable or unwilling to use liveness; they were subject to
the same static exploration issues observed in traditional IDEs.Examples include P1 losing time in an overly exhaustive static
exploration,andP2missingvaluableinformationfromatooshallow
one (similar tothe “Inattention Blindness” phenomenon described
byRobillard[ 38]).Missingknowledge,asobservedbyMurphy-Hill
et al.[53] was a factor too, as we observed several instances where
the halo or the debugger could have been used, but were not.
More generally, exploring unfamiliar code also imposed restric-
tions on how participants could obtain feedback, particularly with
test cases (P4, P6), echoing observations by Sillito—writing testcases was the exception and in some cases challenging—and La-
Tozaetal.,whointheirstudyfoundthattestswerenotextensive
enough and that developers could not rely on them [41].
In other cases, participants employed a variety of liveness tech-
niques,butwerenotsuccessful.P9expectedfeedback,andlosttime
when he did not receive it. P4 kept several prototypes of solutions
tohistaskascodesnippets,experimentingwiththemiteratively,
but did not succeed in his task as he “did not want to play with
threads, because it is too complex ”, despite threads being necessary.
Liveness eases checking assumptions. Checking assumptions is
important to ensure task progress, as Sillito observed: “Program-
mers’falseassumptionsaboutthesystemwereattimesleftunchecked
and made progress on the task difficult.” This was more likely when
questions could not be answered directly by tools. In particular,Sillito found that setting breakpoints in the debugger was often
used to assess if code was relevant for the execution of a feature.
LaTozaetal.[37]observedparticipants“gambled”whentheydid
not havesufficient information, andnoticed that “falsefacts” they
inferred often led to further chains of “false facts”.
Ourparticipantswereabletochecktheirassumptionsinavariety
ofadditionalways,suchasP11quicklydiscardinganapplication
layerfromconsiderationthankstoacodesnippet;orP6findingout
that two widgets were from different classesby inspecting them,
andthenfindingfunctioningexamplesofthewidgettoinferthe
error came from its configuration, rather than the widget itself.
1097
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. The Road to Live Programming: Insights From the Practice ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
The participants were often able to quickly check their assump-
tions,rangingfromthesimplest(whatistheclassofthisobject?)
to the more refined, thus spending less time on false tracks. When
itwaspossibletoprogressivelyperformsourcecodechangesand
test the behavior on running applications, participants did take
fulladvantageofit.Forexample,participantP11testedhiswork
aftereverysmallchange.Sometimesheexpectedabrokenbehavior,
sometimes a positive progress; he checked regardless.
Liveness eases refining context. Context is a major hurdle that
tools do not handle well, according to Sillito: “A programmer’s
questions often have an explicit or implicit context or scope. [...] Toolsgenerallyprovidelittleornosupportforaprogrammertospecifysuch
context [...], and so programmers ask questions more globally than
theyintend.”Thebroadenedscopemakesinformationmorelikely
to be missed and makes it even harder to check assumptions.
Pharo’s static exploration tools have the same scoping issues
as traditional tools. In fact, due to the lack of type annotations,
scoping issues are worse than in statically typed languages [ 54–
56]. However, we have seen examples of liveness features being
usedtoreducethescopeofinvestigations,suchasP11discarding
anapplicationlayerthankstoacodesnippet.Akeypointisthat
Pharomakes iteasier toscope runtimequestions asit isoften not
necessary to run the entire application. A developer can focus on an
application’s objects of interest (e.g., P9 inspecting a model and its
view) and explicitly interact with those, for as long as necessary.
Similarly,codesnippetscancall partsofexistingcode,andexamples
focus on a subset of an API.
Some“hardquestions”areeasiertoanswerusingliveness. Sillito
describes 44 questions developers asked during his sessions. While
questionsincategories1(findingfocuspoints)and2(expanding
focuspoints)allhadfullorpartialtoolsupport,questionsincate-
gories3(understandingasubgraph)and4(questionsovergroups
ofsubgraphs)hadmostlyminimal,oratbestpartialsupport.These
questions were higher level and the hardest to answer.
While liveness can not help for all questions, in some instances
it definitely can. Question 27 (how does this data structure lookat runtime?) is directly supported by the object inspector. Sillito
foundthat15%ofsessionsaskedthisquestion.Allbutoneofour
sessions(94%)usedtheinspector.Similarly,Question37(Whatis
themappingbetweentheseUItypesandthesemodeltypes?)can
be easily answered by inspecting UI elements thanks to the halo.
Severalquestionsinthefourthcategoryconcerncomparisons
between types, methods, or runtime behavior. Sillito states that
“Generally making comparisons is difficult ” and “In some cases, even
harderisacomparisonbetweenasystem’sbehaviorintwodifferent
casesasinquestion34(Howdoesthesystembehaviorvaryoverthese
types or cases?) ”. One of Sillito’s subjects wanted to “ figure out why
oneworksandonedoesnot ”,anddidtwoseriesofstaticreference
navigations,comparingthedifferences.Theparticipantobtained
only a partial answer and missed the most important difference.
We found these kinds of comparisons in 12 out of 17 sessions,
often thanks tomultiple inspectors or snippets. Examplesinclude
P4 experimenting with multiple solutions in parallel, P6 inspecting
two similar widgets for differences, P7 contrasting the behavior of
two codesnippets (one correct, oneincorrect), or P11contrasting
an application with a snippet. While it is possible to open multiple
debuggers at the same time, we did not observe this.8.2 On Tool Support
ToolsupportdrivesLiveProgramming. Somemajordifferencesbe-
tween this study and Sillito’s stem from tool support. Sillito states
“[...] the questions asked and the process of answering those are influ-
encedbythetoolsavailable[...].Givenacompletelydifferentsetof
tools or participants our data could be quite different.”
We found evidence of this, as behavior that was easy to perform
withLiveProgrammingtoolswerefrequentlyused.Forinstance,
inspecting an object or executing an example are always one click
away; so programmers used them very frequently. On the other
hand,thePharosearchtoolsarefragmented:differenttoolsperform
different types of searches. The tools are both more difficult to use,
andlessfrequentlyused.Knowledgeisalsoafactor:accessingUI
objectsviahaloswasunder-used,becausemanyparticipantsdid
not know the shortcut to activate it.
Fewsearches. Studyparticipantsusedfewsearches,whichcon-
trastwithstudiesthatfindcodesearchtobeacommonbehavior.
Sadowski et al.[57] summarized these studies, finding code search-
ingprevalentatGoogle.ThisfindingagreeswithKo etal.[58],who
foundthatdeveloperspreferredtousesearchtoolsthatrequired
lessdetails.Anotherreasoncouldbethatusersfoundothertools
moreeffective,beitinspectors,debuggers,orbrowsingsourcecode
references.KoandMyersobservedinanexperimentthatusersof
the Whyline(with extensive runtime information) reliedmuch less
on search than users of their control group [59].
Examplesaremorefrequentlyused. Sillitoobservedthatinonly
26% of sessions (7 out of 27), participants searched for examples
(askingquestionQ4).Theuseofexamplesoccurredin59%ofour
sessions(10outof17).Pharohasamoreprevalent“culture”ofexam-
ples, including executable method comments, classes and methods
marked as examples, and dedicated example browsers. Our survey
offers additional insights. We find agreement with Sillito when
hestatesthatfinding examplesischallenging,asourparticipants
indicated that finding relevant examples was more difficult than
executing or modifying them. We think that the ease of execution
of examples is a significant factor. It is harder to execute, for in-stance, a Java code snippet found on Stack Overflow, as it needs
tobe imported(resolving dependencies)and compiledbeforeone
can try it. Approaches facilitating this process, such as Ponzanelli
et al.[60] or Subramanian et al.[61] should significantly ease these
issues.
Simple works best. Some of the most advanced approaches were
under-usedbyourparticipants.Whilemanydebuggerswereopened
(everyruntimeerrorinPharoopensone),theytendedtobequickly
dismissed;comparativelyfewofthemwereusedindepth,orexplic-
itly opened via breakpoints. While several respondents mentionthat they value being able to "program in the debugger" in oursurvey’s free-form comments, we observed none in our sessions.
Similarly,wepreviouslymentionedthatwritingtestcasesandusinghaloswereunder-used,theformerasitneedsextensiveknowledge
of the code to test, the latter for lack of awareness.
Incontrast,thecomparativelysimplertoolssuchastheinspec-
tor and the playground were used by virtually all the participants.
Thesetoolsareeasilyaccessible:anypieceofcodecanbeevaluated
andinspected.Theyarealsoveryversatile,andthisispartlydueto
the possibility to open multiple instances of thetools at once, and
1098
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Juraj Kubelka, Romain Robbes, and Alexandre Bergel
keepthemforalongperiodoftime.Havingseveralcodesnippetsor
inspectors openat oncemakes it easyto perform comparisonsbe-
tweendifferentscenarios.Keepingthesetoolsopenforlongperiods
oftimemakesiteasiertocheckone’sprogress.Thus,combining
thesetechniquesyieldspowerfulresults,bestexemplifiedbyP7’s
use of two code snippets and two inspectors simultaneously.
Comparisonwithonlinevideos. Whileweobservedsomeliveness
in the analyzed online coding sessions, we found much less usage
than for Pharo participants. All of the online coding sessions used
the facilities afforded by immediate feedback (either by manual
reload of applications, or automatically after source code changes)
tocheckprogressontheirtasks.Nearlyall(10of11)sessionsusing
JavaScript and HTML made use of the object inspector provided
bythewebbrowser.However,theJavaScriptinspectorusagewas
more limited since the tool support is less mature. Other usages of
livenesswereminimal.Thisconfirmsourpreviousobservationthat
tool support is vital for people to make use of liveness effectively.
9 THREATS TO VALIDITY
Empirical studies have to make tradeoffs between internal and
external validity [ 62]. This study’s focus being on how developers
used liveness in practice, we tried to maximize its external validity.
To this aim, we performed our study in 3 steps.
We first observed 11 participants in 17 sessions who all used
the same environment. To vary the situations, they worked on
different tasks from ten different codebases. However, the duration
ofthetaskswasshort(40minutestoanhour),whichrestrictedthe
typesofactivitiesweobserved.Wecouldnotdomoreforlogistical
reasons.
We further attempted to diversify our choice of settings by gath-
ering 16 additional recorded coding sessions online, covering a
variety of languages, settings, and tasks. We wanted to include ses-
sionsoftheJupyterinteractivenotebook[ 63],whichhasinteresting
featuressimilartotheplayground.Wewereultimatelyunsuccessful:
we found mostly tutorials, not real-world coding sessions.
We hadlimitedchoiceof participants,andourparticipantswere
allmale;studiesliketheonesofBeckwith etal.[64]haveshown
that males are more comfortable than females in tinkering. A Live
Programming environment does encourage tinkering. Ina follow-
up study of debugging by end-users [ 65], females were found to be
lessfrequent,butmoreefficientusersoftinkering,showingthatthe
relationshipisnotatallobvious.Assuch,studiesofhowfemales
use Live Programming would greatly extend this work.
The tasks we investigated may not be representative or advanta-
geoustoaLiveProgrammingenvironment,becausesucharepre-
sentativetask listdoes notexist yet.We onlydefined thetaskson
unfamiliarcodeinthefirststudy:wehadnocontrolonthetasks
relatedto familiarcodeandtheonline videotasks,asboth setsof
tasks were defined by the participants themselves.
Thetranscriptionoftheactivityduringthetaskswasperformed
by the primary author. In such cases where the author was unsure,
we held discussions on specific examples. To minimize biases in
interpretation, most of the activity under study was related to tool
usage (plus vocalizations), and we used Minelli and Lanza’s DFlow
tosystematicallyrecordinteractiondata[ 50](exceptinonesession).According to McDirmid, Smalltalk environments such as Pharo
donotcovertheentirespectrumofLiveProgramming(aspecific
example is provided by McDirmid [ 19]). We nevertheless chose
Pharo as it is the “liveliest” environment used by practitioners that
wehadaccessto,andnotethatPharodoesincludeMorphic[ 29],
which fits McDirmid’s stricter definition of Live Programming. We
also focus on liveness, rather than strictly Live Programming.
Wekeptthesurveyasshortaspossibletomaximizeresponses.
Wehadtomakechoicesinwhattoaskandcouldnotincludeevery
observation. Statistics omitted for lack of space—not respondents.
10 CONCLUSION AND IMPLICATIONS
ThelivefeedbackthatLiveProgrammingprovidesisgainingaccep-
tanceinmainstreamtools.Weperformedamulti-phasestudyon
howdevelopersuse livenessinpractice.Afterobserving17devel-
opment sessions of Pharo developers, we concluded that they used
livenessveryfrequently ,anddocumentedthevariousapproaches
they took. We found that participants favored simple approaches ,
andthatlivenessallowedthemto checktheirassumptions.Advanced
participants were able to easily compare and contrast execution
scenarios; practitioners may learn from the successful episodes we
described.Afollow-upsurveyconfirmedourobservationsonthe
frequency of usage of liveness. Finally, we contrasted our findings
withonlinecodingsessionsinotherlanguages,findingextensive
use of immediate feedback, but limitations due to tool support.
Implicationsfortoolbuildersandlanguagedesigners. Themajor
implicationofthisstudyisthat evensmalldosesoflivenessmayhave
a large impact. We saw that the most advanced approaches were
sometimes not necessary, if simpler approaches such as inspecting
coulddothejob.TechnologicallyimpressivetoolssuchastheWhy-
line [59] have been developed, while the Debugger Canvas [ 66]o r
TouchDevelop [ 22] have been put in production. These tools are
extremely useful and required a lot of effort to build. Yet, we think
that adding a simple playground and inspector to an IDE could go
a long way, particularly if multiple instances are allowed.
Similarly,LiveProgrammingresearchfocusesonlanguageswith
maximalliveness[ 6].Yetwebelievethatexploringthedesignspace
ofsimplerrepresentationssuchastheinspectorandplaygrounds
couldleadtosignificantimprovementsonitsown,particularlyif
longevity and multiplicity are included. The notebook metaphor
employed by Jupyter[ 63] elegantly allowsfor multiple code snip-
pets (cells) to coexist, while providing easy visualization of the
results(particularly fordata),even ifitisnot fullylive.The mold-
ableinspectorofChis etal.[30]canbecustomizedforeachtypeof
objectsto displaythemost relevantinformation.Combining both
approaches may be very intriguing.
Implicationsforsoftwareengineeringresearchers. Themajorim-
plication is that there is still a lot to learn in how developers use
liveness.Asthesefeaturesslowlybutsurelyentermainstreamtools,
multiple studies beyond this one are needed to fully understand
how developers can best take advantage of the new capabilities
their development environments will afford them.
AcknowledgmentJurajKubelkaissupportedbyaPh.D.scholarship
fromCONICYT,Chile.CONICYT-PCHA/DoctoradoNacional/2013-63130188.
We also thank Renato Cerro for his feedback and all the participants for
their availability.
1099
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. The Road to Live Programming: Insights From the Practice ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
REFERENCES
[1] K. Eliott, Swift Playgrounds—Interactive Awesomeness (2016).
URL http://bit.ly/Swift-Playgrounds
[2] C. Connect, Code Connect is joining Microsoft (2016).
URL http://comealive.io/Code-Connect-Joins-Microsoft/
[3] R. D. Team, React: A Javascript Library For Building User Interfaces (2017).
URL https://facebook.github.io/react/
[4] G. C. D. Team, Google Chrome Development Tools (2017) [cited August 2017].
URL https://developers.google.com/web/tools/chrome-devtools/
[5]B.Burg,A.Kuhn,C.Parnin(Eds.),Proceedingsofthe1stInternationalWorkshop
on Live Programming, LIVE 2013, San Francisco, California, USA, May 19, 2013,
IEEE Computer Society, 2013.
URL http://ieeexplore.ieee.org/xpl/mostRecentIssue.jsp?punumber=6599030
[6]S. McDirmid, The Promise of Live Programming, in: Proceedings of the 2nd
International Workshop on Live Programming, LIVE ’16, Rome, Italy, 2016.
[7] C. Parnin, A History of Live Programming (01 2013) [cited November 2016].
URL http://liveprogramming.github.io/liveblog/2013/01/
a-history-of-live-programming/
[8]S.L.Tanimoto,APerspectiveontheEvolutionofLiveProgramming,in:Proceed-
ings of the 1st International Workshop on Live Programming, LIVE ’13, IEEE
Press, Piscataway, NJ, USA, 2013, pp. 31–34.
URL http://dl.acm.org/citation.cfm?id=2662726.2662735
[9]P.Rein,S.Lehmann,T.Mattis,R.Hirschfeld,HowLiveareLiveProgramming
Systems?,ProceedingsoftheProgrammingExperience2016(PX/16)Workshop
on - PX/16doi:10.1145/2984380.2984381.URL http://dx.doi.org/10.1145/2984380.2984381
[10]
E.Sandewall,ProgramminginanInteractiveEnvironment:The“Lisp”Experience,
ACM Comput. Surv. 10 (1) (1978) 35–71. doi:10.1145/356715.356719.
URL http://doi.acm.org/10.1145/356715.356719
[11]D. Ungar, R. Smith, SELF: the power of simplicity (object-oriented language),Digest of Papers. COMPCON Spring 88 Thirty-Third IEEE Computer Society
International Conferencedoi:10.1109/cmpcon.1988.4851.URL http://dx.doi.org/10.1109/CMPCON.1988.4851
[12]
D. Ingalls, T. Kaehler, J. Maloney, S. Wallace, A. Kay, Back to the future, Proceed-
ingsofthe12thACMSIGPLANconferenceonObject-orientedprogramming,sys-
tems, languages, and applications - OOPSLA ’97 doi:10.1145/263698.263754 .
URL http://dx.doi.org/10.1145/263698.263754
[13]D. Ingalls, K. Palacz, S. Uhler, A. Taivalsaari, T. Mikkonen, The Lively Kernel
A Self-supporting System on a Web Page, Lecture Notes in Computer Science
(2008) 31–50doi:10.1007/978-3-540-89275-5_2.
URL http://dx.doi.org/10.1007/978-3-540-89275-5_2
[14]J. Noble, S. McDirmid (Eds.), Proceedings of the 2nd International Workshop on
Live Programming, LIVE 2016, Rome, Italy, 2016.
[15]D.Ogborn,G.Wakefield,C.Baade,K.Sicchio,T.Goncalves(Eds.),Proceedings
of the Second International Conference on Live Coding, 2016.
[16]S. L. Tanimoto, VIVA: A visual language for image processing, Journal of Visual
Languages & Computing 1 (2) (1990) 127–139.
[17]M.M.Burnett,J.W.Atwood,Z.T.Welch,Implementinglevel4livenessindeclar-
ative visual programming languages, in: Visual Languages, 1998. Proceedings.
1998 IEEE Symposium on, IEEE, 1998, pp. 126–133.
[18]E. Wilcox, J. W. Atwood, M. M. Burnett, J. J. Cadiz, C. R. Cook, Does continuous
visualfeedbackaiddebuggingindirect-manipulationprogrammingsystems?,in:
ProceedingsoftheACMSIGCHIConferenceonHumanfactorsincomputing
systems, ACM, 1997, pp. 258–265.
[19]S. McDirmid, Living it up with a live programming language, in: ACM SIGPLAN
Notices, Vol. 42, ACM, 2007, pp. 623–638.
[20]J. Edwards, Subtext: uncovering the simplicity of programming, ACM SIGPLAN
Notices 40 (10) (2005) 505–518.
[21]S.McDirmid,J.Edwards,Programmingwithmanagedtime,in:Proceedingsof
the 2014 ACM International Symposium on New Ideas, New Paradigms, and
Reflections on Programming & Software, ACM, 2014, pp. 1–10.
[22]S.Burckhardt,M.Fahndrich,P.deHalleux,S.McDirmid,M.Moskal,N.Tillmann,
J.Kato,It’salive!continuousfeedbackinUIprogramming,in:ACMSIGPLAN
Notices, Vol. 48, ACM, 2013, pp. 95–104.
[23]R. DeLine, D. Fisher, B. Chandramouli, J. Goldstein, M. Barnett, J. F. Terwilliger,
J. Wernsing, Tempe: Live scripting for live data., in: VL/HCC, 2015, pp. 137–141.
[24] Oracle, Java Platform Debugger Architecture (2014).
URL http://docs.oracle.com/javase/7/docs/technotes/guides/jpda/
[25] S. Hanselman, Interactive Coding with C# and F# REPLS (2016).
URL http://bit.ly/InteractiveCodingCF
[26] K. Uhlenhuth, Introducing the Microsoft Visual Studio C# REPL (Nov 2015).
URL https://channel9.msdn.com/Events/Visual-Studio/Connect-event-2015/103
[27]A. Black, S. Ducasse, O. Nierstrasz, D. Pollet, D. Cassou, M. Denker, Pharo by
Example, Square Bracket Associates, 2009.
URL http://pharobyexample.org
[28]A. Goldberg, D. Robson, Smalltalk 80: the Language and its Implementation,
Addison Wesley, Reading, Mass., 1983.URL http://stephane.ducasse.free.fr/FreeBooks/BlueBook/Bluebook.pdf
[29]J. H. Maloney, R. B. Smith, Directness and liveness in the morphic user interface
constructionenvironment,in:Proceedingsofthe8thannualACMsymposium
on User interface and software technology, ACM, 1995, pp. 21–28.
[30]A. Chiş, O. Nierstrasz, A. Syrel, T. Gîrba, The Moldable Inspector, in: 2015 ACM
International Symposium on New Ideas, New Paradigms, and Reflections on
ProgrammingandSoftware(Onward!),Onward!2015,ACM,NewYork,NY,USA,
2015, pp. 44–60. doi:10.1145/2814228.2814234.
URL http://doi.acm.org/10.1145/2814228.2814234
[31]A.Chiş,T.Gîrba,O.Nierstrasz,TheMoldableDebugger:AFrameworkforDe-
veloping Domain-SpecificDebuggers, SpringerInternational Publishing,Cham,
2014, pp. 102–121. doi:10.1007/978-3-319-11245-9_6.
URL https://doi.org/10.1007/978-3-319-11245-9_6
[32]J.H.Maloney,R.B.Smith,DirectnessandLivenessintheMorphicUserInterface
Construction Environment, in: Proceedings of the 8th Annual ACM Symposium
on User Interface and Software Technology, UIST ’95, ACM, New York, NY, USA,
1995, pp. 21–28. doi:10.1145/215585.215636.
URL http://doi.acm.org/10.1145/215585.215636
[33]A. J. Ko,B. A. Myers,M. J. Coblenz, H. H. Aung, An exploratory study ofhow
developers seek, relate, and collect relevant information during software mainte-
nance tasks, IEEE Transactions on software engineering 32 (12).
[34]J. Lawrance, C. Bogart, M. Burnett, R. Bellamy, K. Rector, S. D. Fleming, How
programmersdebug,revisited:Aninformationforagingtheoryperspective,IEEE
Transactions on Software Engineering 39 (2) (2013) 197–215.
[35]T. D. LaToza, G. Venolia, R. DeLine, Maintaining Mental Models: A Study of
Developer Work Habits, in: Proceedings of the 28th International Conference on
SoftwareEngineering,ICSE’06,ACM,NewYork,NY,USA,2006,pp.492–501.
doi:10.1145/1134285.1134355.
URL http://doi.acm.org/10.1145/1134285.1134355
[36]T. Roehm, R. Tiarks, R. Koschke, W. Maalej, How Do Professional DevelopersComprehend Software?, in: Proceedings of the 34th International Conferenceon Software Engineering, ICSE ’12, IEEE Press, Piscataway, NJ, USA, 2012, pp.
255–265.
URL http://dl.acm.org/citation.cfm?id=2337223.2337254
[37]T. D. LaToza, D. Garlan, J. D. Herbsleb, B. A. Myers, Program Comprehension
As Fact Finding, in: Proceedings of the the 6th Joint Meeting of the European
SoftwareEngineeringConferenceandtheACMSIGSOFTSymposiumonThe
Foundations of Software Engineering, ESEC-FSE ’07, ACM, New York, NY, USA,
2007, pp. 361–370. doi:10.1145/1287624.1287675.
URL http://doi.acm.org/10.1145/1287624.1287675
[38]M. P. Robillard, W. Coelho, G. C. Murphy, How effective developers investigate
source code:An exploratorystudy, IEEETransactionson softwareengineering
30 (12) (2004) 889–903.
[39]J. Sillito, G. Murphy, K. De Volder, Asking and Answering Questions during a
ProgrammingChange Task,Software Engineering,IEEE Transactionson 34(4)
(2008) 434–451.
URL http://dx.doi.org/10.1109/TSE.2008.26
[40]J.Sillito,Askingandansweringquestionsduringaprogrammingchangetask,
Ph.D. thesis, University of British Columbia (Feb 2006). doi:http://dx.doi.
org/10.14288/1.0052042.
URL https://open.library.ubc.ca/cIRcle/collections/831/items/1.0052042
[41]T.D.LaToza,B.A.Myers,DevelopersAskReachabilityQuestions,in:Proceedings
of the 32Nd ACM/IEEE International Conference on Software Engineering -
Volume 1, ICSE ’10, ACM, New York, NY, USA, 2010, pp. 185–194.
URL http://doi.acm.org/10.1145/1806799.1806829
[42]A.Ko,R.DeLine,G.Venolia,InformationNeedsinCollocatedSoftwareDevel-
opment Teams, in: Software Engineering, 2007. ICSE 2007. 29th International
Conference on, 2007, pp. 344–353.
URL http://dx.doi.org/10.1109/ICSE.2007.45
[43]T.Fritz,G.C.Murphy,UsingInformationFragmentstoAnswertheQuestions
DevelopersAsk,in:Proceedingsofthe32NdACM/IEEEInternationalConference
on Software Engineering - Volume 1, ICSE ’10, ACM, New York, NY, USA, 2010,
pp. 175–184. doi:10.1145/1806799.1806828.
URL http://doi.acm.org/10.1145/1806799.1806828
[44]E. Duala-Ekoko, M. Robillard, Asking and answering questions about unfamiliar
APIs: Anexploratory study,in: SoftwareEngineering (ICSE), 201234th Interna-
tional Conference on, 2012, pp. 266–276.URL http://dx.doi.org/10.1109/ICSE.2012.6227187
[45]
R.DeLine,D.Fisher,Supportingexploratorydataanalysiswithliveprogramming,
in: Visual Languages and Human-Centric Computing (VL/HCC), 2015 IEEE
Symposium on, IEEE, 2015, pp. 111–119.
[46]J. Kubelka, R. Robbes, A. Bergel, Dataset for The Road to Live Programming:
Insights From the Practice (Feb 2018). doi:10.5281/zenodo.1171119.
URL https://doi.org/10.5281/zenodo.1171119
[47]J. Kubelka, R. Robbes, A. Bergel, Session Video Recordings for The Road to Live
Programming: Insights From the Practice (Feb 2018). doi:10.5281/zenodo.
1170460.
URL https://doi.org/10.5281/zenodo.1170460
1100
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Juraj Kubelka, Romain Robbes, and Alexandre Bergel
[48]J.Kubelka,R.Robbes,A.Bergel,ToolsforTheRoadtoLiveProgramming:Insights
From the Practice (Feb 2018). doi:10.5281/zenodo.1171117.
URL https://doi.org/10.5281/zenodo.1171117
[49]W. Maalej, T. Fritz, R. Robbes, Collecting and processing interaction data for
recommendationsystems,in:RecommendationSystemsinSoftwareEngineering,
Springer, 2014, pp. 173–197.
[50]R.Minelli,M.Lanza,Visualizingtheworkflowofdevelopers,in:SoftwareVisual-
ization (VISSOFT), 2013 First IEEE Working Conference on, 2013, pp. 1–4.
URL http://dx.doi.org/10.1109/VISSOFT.2013.6650531
[51] U. Flick, An introduction to qualitative research, Sage, 2014.[52]
F.Zieris,L.Prechelt,Observationsonknowledgetransferofprofessionalsoftwaredevelopersduringpairprogramming,in:SoftwareEngineeringCompanion(ICSE-
C), IEEE/ACM International Conference on, IEEE, 2016, pp. 242–250.
[53]E. Murphy-Hill, C. Parnin, A. P. Black, How We Refactor, and How We Know It,
IEEETransactionsonSoftwareEngineering38(1)(2012)5–18. doi:10.1109/
TSE.2011.41.
[54]S.Hanenberg,S.Kleinschmager,R.Robbes,É.Tanter,A.Stefik,Anempiricalstudy
ontheimpactofstatictypingonsoftwaremaintainability,EmpiricalSoftware
Engineering 19 (5) (2014) 1335–1382.
[55]S. Endrikat, S. Hanenberg, R. Robbes, A. Stefik, How do api documentation
andstatictypingaffectapiusability?,in:Proceedingsofthe36thInternational
Conference on Software Engineering, ACM, 2014, pp. 632–642.
[56]P. Petersen, S. Hanenberg, R. Robbes, An empirical comparison of static and
dynamic type systems on api usage in the presence of an ide: Java vs. groovy
witheclipse,in:Proceedingsofthe22ndInternationalConferenceonProgram
Comprehension, ACM, 2014, pp. 212–222.
[57]C. Sadowski, K. T. Stolee, S. Elbaum, How developers search for code: a case
study,in:Proceedingsofthe201510thJointMeetingonFoundationsofSoftware
Engineering, ACM, 2015, pp. 191–201.
[58]A.J.Ko,H.H.Aung,B.A.Myers,M.J.Coblenz,AnExploratoryStudyofHow
DevelopersSeek,Relate,andCollectRelevantInformationduringSoftwareMain-
tenanceTasks,Software Engineering,IEEETransactionson32 (12)(2006) 971–
987.
[59]A.J.Ko,B.A.Myers,FindingcausesofprogramoutputwiththeJavaWhyline,
in: Proceedings of the SIGCHI Conference on Human Factors in Computing
Systems, ACM, 2009, pp. 1569–1578.
[60]L. Ponzanelli, G. Bavota, M. Di Penta, R. Oliveto, M. Lanza, Prompter, Empirical
Software Engineering 21 (5) (2016) 2190–2231.
[61]S.Subramanian,L.Inozemtseva,R.Holmes,LiveAPIDocumentation,in:Proceed-
ingsofthe36thInternationalConferenceonSoftwareEngineering,ICSE2014,
ACM, New York, NY, USA, 2014, pp. 643–652. doi:10.1145/2568225.2568313 .
URL http://doi.acm.org/10.1145/2568225.2568313
[62]J. Siegmund, N. Siegmund, S. Apel, Views on internal and external validity in
empiricalsoftwareengineering,in:SoftwareEngineering(ICSE),2015IEEE/ACM
37th IEEE International Conference on, Vol. 1, IEEE, 2015, pp. 9–19.
[63]M.Ragan-Kelley,F.Perez,B.Granger,T.Kluyver,P.Ivanov,J.Frederic,M.Busson-
nier, TheJupyter/IPython architecture: a unified view of computational research,
from interactive exploration to communication and publication., in: AGU Fall
Meeting Abstracts, 2014.
[64]L. Beckwith, M. Burnett, S. Wiedenbeck, C. Cook, S. Sorte, M. Hastings, Effec-
tivenessofend-userdebuggingsoftwarefeatures:Aretheregenderissues?,in:
ProceedingsoftheSIGCHIConferenceonHumanFactorsinComputingSystems,
ACM, 2005, pp. 869–878.
[65]L. Beckwith, C. Kissinger, M. Burnett, S. Wiedenbeck, J. Lawrance, A. Blackwell,
C. Cook, Tinkering and gender in end-user programmers’ debugging, in: Pro-ceedings of the SIGCHI conference on Human Factors in computing systems,
ACM, 2006, pp. 231–240.
[66]R. DeLine, A. Bragdon, K. Rowan, J. Jacobsen, S. P. Reiss, Debugger Canvas:
Industrialexperiencewiththecodebubblesparadigm,in:M.Glinz,G.C.Murphy,
M. Pezzè (Eds.), ICSE, IEEE, 2012, pp. 1064–1073.
1101
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. 